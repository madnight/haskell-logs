00:14:52 <shachaf> Does anyone know anything about this error? https://bugs.launchpad.net/ubuntu/+source/haskell-platform/+bug/711366
00:32:53 * edwardk waves hello.
00:33:24 <dolio> How was Thor?
00:33:43 <edwardk> not bad, not great
00:34:26 * hackagebot semigroups 0.4.0 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.4.0 (EdwardKmett)
00:34:30 <dolio> Partying with Apocalisp isn't easy.
00:34:43 <edwardk> hah
00:35:15 <edwardk> how'd that go? i stayed home and spent some time with Amy
00:35:30 <dolio> I enjoyed it.
00:36:52 <dolio> Kind of reminded me of college.
00:37:21 <edwardk> hah
00:37:26 * hackagebot tagged 0.2.1 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.2.1 (EdwardKmett)
00:37:28 * hackagebot comonad 1.0.3 - Haskell 98 comonads  http://hackage.haskell.org/package/comonad-1.0.3 (EdwardKmett)
00:37:39 <dolio> He was serving Vespers.
00:38:19 <dolio> The cocktail from Casino Royale.
00:38:29 <dolio> Which are surprisingly good
00:38:45 <edwardk> ah. i was trying to place it. the best i could do was the prayer-thingy ;)
00:39:27 <dolio> And we ended up at a club in the financial district.
00:39:33 <dolio> Which isn't really my area....
00:39:50 <dolio> But they were showing Numb3rs on big screen TVs.
00:39:57 <dolio> Which cracked me up.
00:40:26 * hackagebot semigroupoids 1.1.3 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-1.1.3 (EdwardKmett)
00:40:46 <dolio> I see you've been busy releasing packages.
00:40:48 <edwardk> my biggest problem with numbers is the number of liberties it takes with the math to try to make it more accessible. but like myth busters i kind of suck it up and try to accept that the good it does outweighs the harm
00:41:18 <edwardk> reduced the dependencies of semigroups. then it transitively effects most things up the chain =/
00:42:35 <edwardk> plus i have a few bug fixes i need to push out for folks. a couple of misplaced dependency caps, etc.
00:42:46 <edwardk> so i figured now was as good of a time as any
00:43:32 <dolio> 3:30 AM is seems like a good time.
00:45:27 * hackagebot comonad-transformers 1.5.3 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.5.3 (EdwardKmett)
00:47:27 * hackagebot void 0.5.0 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.0 (EdwardKmett)
00:48:27 * hackagebot free 0.1.1 - Haskell 98 monads for free  http://hackage.haskell.org/package/free-0.1.1 (EdwardKmett)
00:50:23 <edwardk> er s/effects/affects
00:50:28 * hackagebot semigroupoid-extras 0.2.2.0 - Semigroupoids requiring Haskell extensions  http://hackage.haskell.org/package/semigroupoid-extras-0.2.2.0 (EdwardKmett)
00:55:09 <MatrixFrog> wheee i just solved Bot Trust with haskell!
00:55:16 <MatrixFrog> (google code jam problem)
00:55:24 <edwardk> =)
00:55:28 * hackagebot categories 0.55.1 - categories from category-extras  http://hackage.haskell.org/package/categories-0.55.1 (EdwardKmett)
00:57:10 <paolino> MatrixFrogg, there were 118 haskellers yesterday
00:57:33 <MatrixFrog> sadly i was not one of them. i used boring old java :(
00:57:56 <paolino> oh, how it was ?
00:58:06 <MatrixFrog> but i managed to hammer out a haskell solution just now, just for fun
00:58:29 * hackagebot streams 0.6.3 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-0.6.3 (EdwardKmett)
00:58:47 <MatrixFrog> the problems were good. you can read them at http://code.google.com/codejam if you want
00:59:47 <MatrixFrog> my haskell code takes about 2 seconds, but my java code is basically instantaneous. so i need to keep working on it...
01:00:00 <paolino> I was there
01:01:24 <pastorn> @type (>=>)
01:01:25 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
01:02:29 * hackagebot recursion-schemes 0.4.1 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-0.4.1 (EdwardKmett)
01:02:45 <MatrixFrog> what's the convention for @? should i do xs@(x:xs') or xs'@(x:xs)?
01:02:59 <edwardk> usuall xxs@(x:xs)
01:03:02 <edwardk> er usually
01:04:03 <edwardk> same character count but has the benefit of being obvious which is which
01:05:10 <MatrixFrog> mmm good plan
01:06:13 <paolino> > foldr1 (*) [2..15]
01:06:14 <lambdabot>   1307674368000
01:06:30 * hackagebot pointed 0.1.1 - Haskell 98 Pointed and copointed data  http://hackage.haskell.org/package/pointed-0.1.1 (EdwardKmett)
01:07:46 <paolino> > permutations [1..5]
01:07:47 <lambdabot>   [[1,2,3,4,5],[2,1,3,4,5],[3,2,1,4,5],[2,3,1,4,5],[3,1,2,4,5],[1,3,2,4,5],[4...
01:08:20 <k0ral> hi guys, I'm working with webkit and gtk and I need the "castTo*" functions reative to webkit package
01:08:38 <k0ral> I read they were in Graphics.UI.Gtk.WebKit.Types
01:09:10 <k0ral> but during compilation, there's this error "Could not find module `Graphics.UI.Gtk.WebKit.Types': it is a hidden module in the package `webkit-0.12.1'
01:09:22 <k0ral> what does that mean ?
01:09:59 <c_wraith> packages can have modules that aren't part of their public interface, and it seems that module is one of those
01:10:14 <c_wraith> look for another module that re-exports the functions you need
01:11:30 * hackagebot ad 1.0.4 - Automatic Differentiation  http://hackage.haskell.org/package/ad-1.0.4 (EdwardKmett)
01:12:15 <k0ral> where am I supposed to find such a module ?
01:12:33 <k0ral> I only know http://hackage.haskell.org/package/webkit
01:12:52 <MatrixFrog> i assume there's a built in function for what i'm trying to do... let me see if i can describe it...
01:12:53 <MatrixFrog> :t find
01:12:54 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
01:12:58 <edwardk> koral: i'd complain to the package author
01:13:14 <k0ral> edwardk: seriously ?
01:13:21 <MatrixFrog> ok so 'find' returns the first item in the list that satisfies the predicate, wrapped in a Maybe
01:13:29 <c_wraith> hmm.  doesn't help that there's a build failure preventing hackage from generating the docs for that package
01:13:34 <MatrixFrog> unless there is no such list, then it returns Nothing. so that's cool
01:13:46 <MatrixFrog> but what i want is to pass in a default value
01:14:03 <MatrixFrog> and then if it's not found in the list, have it return the default value
01:14:03 <k0ral> c_wraith: I've built the doc on my own
01:14:18 <k0ral> c_wraith: I have the doc on my computer
01:14:20 <MatrixFrog> i figure the type of the function i want should be: a -> (a -> Bool) -> [a] -> a
01:14:22 <edwardk> koral: well, the purpose of other-modules is to conceal implementation details that you don't want people to use or to treat as part of the public API. the idea is that they shouldn't need them. but if you write a package and a legitimate user can't use it because you misplaced the abstraction boundary, you'd want to know, wouldn't you?
01:14:44 <MatrixFrog> but i see no such thing on hoogle
01:14:49 <edwardk> as it stands, you are completely out of luck. by letting them know there is an issue you can at least have SOME path to resolution
01:15:21 <k0ral> edwardk: well, yes, but are you sure there is no way recovering those hidden implementations ?
01:15:27 <edwardk> koral: none
01:15:42 <k0ral> that's a shame
01:16:29 <edwardk> koral: if it is a one off project you could bandaid it for your own purposes by pulling the tar ball out of your cabal cache, and moving the package from other-modules to exposed-modules and rebuilding
01:16:37 <edwardk> but that won't let you redistribute your result on hackage
01:17:12 <edwardk> so really the only clean solution is to get the authors of the webkit package to expose what you need (or figure out how you can get by with the public API)
01:17:40 <k0ral> well, thank you for the answer, I'll think about contacting the authors
01:18:31 * hackagebot keys 0.2.4 - Keyed functors and containers  http://hackage.haskell.org/package/keys-0.2.4 (EdwardKmett)
01:19:31 * hackagebot representable-functors 0.4.1 - Representable functors  http://hackage.haskell.org/package/representable-functors-0.4.1 (EdwardKmett)
01:22:34 * hackagebot adjunctions 0.9.1 - Adjunctions  http://hackage.haskell.org/package/adjunctions-0.9.1 (EdwardKmett)
01:23:31 <k0ral> edwardk: still, I quite surprised there's absolutely nothing about this problem on the net
01:23:49 <k0ral> edwardk: maybe I'm misusing the library ?
01:23:50 <edwardk> i complain about it here and there. ;)
01:24:05 <edwardk> (not the webkit thing in general, but the misplaced abstraction boundary issue)
01:24:13 <edwardk> no idea
01:24:20 <edwardk> i don't use webkit
01:25:34 * hackagebot kan-extensions 0.1.2 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-0.1.2 (EdwardKmett)
01:26:50 <_Ray_> edwardk, hopefully this doesn't sound like asskissing but, how long have you been using Haskell? How about programming? How about math?
01:28:11 <MatrixFrog> anyone want to help me make my code a tiny bit less ugly?
01:28:17 <edwardk> i've been using haskell since 2006. programming since i was 7-8, which would put it around '82 or so. Math i discovered I liked when I started using it for 3d graphics in the early 90s, but didn't pick up the formal pieces of paper saying i knew what i was doing with it until around 2005-2006
01:28:22 <MatrixFrog> i have this right now:
01:28:23 <MatrixFrog> find (\bp -> robot == whichBot bp) bps
01:28:45 <MatrixFrog> so... bps is of type [ButtonPress]
01:28:58 <_Ray_> Thanks :)=
01:29:01 <MatrixFrog> where a buttonpress is a robot and an integer
01:29:12 <MatrixFrog> data ButtonPress = ButtonPress Robot Int
01:29:27 <MatrixFrog> whichBot (ButtonPress r _) = r
01:29:44 <MatrixFrog> so i want to go through bps and return the first bp that has 'robot' as its robot
01:29:58 <MatrixFrog> i feel like there's a better way to write that lambda
01:30:35 * hackagebot representable-tries 0.3.2 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-0.3.2 (EdwardKmett)
01:31:00 <Botje> MatrixFrog: find ((== robot) . whichBot) bps
01:31:02 <Botje> is one option
01:31:14 <MatrixFrog> that's what i was just thinking
01:31:14 <Botje> or find (\(ButtonPress r _) r == robot) bps
01:31:26 <MatrixFrog> as soon as i typed it in irc i was like "wait i think i got it!"
01:31:28 <Botje> =)à
01:31:39 <Botje> the rubber duck strikes again!
01:32:04 <MatrixFrog> i think i like this: find ((robot ==) . whichBot) bps
01:32:13 <MatrixFrog> which works just the same i think.
01:32:13 <Botje> yep, also good
01:32:16 * MatrixFrog tries it out
01:34:56 <MatrixFrog> i'm still surprised there's no variant of 'find' like i was expecting
01:35:02 <MatrixFrog> easy enough to write it though
01:35:09 <skurt> I'm looking for some kind of reaaaly simple tutorial how to parse xml in Haskell. Preferably in(with) examples. Anyone have any ideas?
01:35:44 <edwardk> skurt: http://projects.haskell.org/HaXml/
01:35:46 <paolino> MatrixFrog: my solution was (still is) wordy, I was not very happy when I submitted it
01:36:05 <MatrixFrog> well mine too but that's because it was in Java :P
01:36:08 <edwardk> not very simple, but can do pretty much anything you need with xml
01:37:07 <edwardk> http://www.krowland.net/tutorials/haxml_tutorial.html actually uses it a bit
01:38:13 <skurt> edwardk: I saw those two already
01:38:36 <skurt> edwardk: Im actually not sure if its really parsing xml
01:38:44 <roconnor> was the new typeclassopidea made, or was there only a call for contribs?
01:38:47 <edwardk> the latter you're probably right
01:38:56 <edwardk> roconnor: just the call afaik
01:39:20 <edwardk> i sat down and did a 2 hour crash course with byorgey bringing him up to speed on my crazy new hierarchy
01:39:36 <edwardk> but i didn't actually sit down and contribute any docs =)
01:40:05 <edwardk> the main thing i want to get out of it is the death of Pointed
01:40:31 <edwardk> or at least it being reconciled to a very small role, more appropriate to its importance/applicability
01:42:00 <paolino> MatrixFrog: but there are good contestants around: http://code.google.com/codejam/contest/scoreboard/do?cmd=GetSourceCode&contest=975485&problem=1080487&io_set_id=0&username=rst76
01:42:38 <illissius> edwardk: the hierarchy as represented in your hackage packages, or something separate from that?
01:42:42 <edwardk> skurt: have you seen http://hackage.haskell.org/packages/archive/xml-parsec/1.0.3/doc/html/Text-ParserCombinators-Parsec-XML.html ?
01:43:13 <edwardk> illiisius: yep, the hierarchy from the packages above
01:44:02 <paolino> MatrixFrog: this rst76 is a valid example
01:44:32 <_Ray_> "main = interact $ unlines . zipWith (++) ["Case #" ++ show i ++ ": " |i<-[1..]] . map (show . solve . tail . words) . tail . lines" <-- This is why I need to learn Haskell.
01:44:51 <skurt> edwardk: seems good, but is there any way to read how to use it?
01:45:09 <edwardk> i need to figure out a nice way to break up the one monolithic module in 'keys' =/
01:45:26 <edwardk> skurt: hrmm. no idea.
01:46:16 <MatrixFrog> paolino. wow... mine is 96 lines
01:46:16 <skurt> edwardk: and do you have any idea why this: ":m + Text.ParserCombinators.Parsec.XML" do not work?
01:46:30 <edwardk> did you install xml-parsec first?
01:47:18 <skurt> edwardk: nope, thanks
01:47:25 <skurt> edwardk: how did you know btw?
01:47:37 <MatrixFrog> paolino i don't suppose someone sat down and typed this all out at once? they probably did a lot of planning and figuring things out and then it eventually condensed to this?
01:47:40 <edwardk> guessed
01:47:49 <skurt> ah
01:47:55 <edwardk> mainly coz i couldn't think of any other scenario that would fail
01:48:05 <paolino> MatrixFrog: don't think so, sorry :P
01:50:43 <skurt> Well, I have all set
01:50:51 <paolino> MatrixFrog: take a look at the other solutions, he masters programming and has a lot of fun. http://www.go-hero.net/jam/11/name/rst76
01:51:00 <skurt> I have an xml downloaded in a variable called `body`
01:51:17 <paolino> he/she
01:51:17 <skurt> but I still dont have any idea what to do :(
01:51:18 <edwardk> the main gripe i could foresee with xml-parsec is it is tied to parsec-2, so it'll be annoying to use with bytestrings, etc.
01:51:27 <edwardk> hrmm
01:51:37 * hackagebot either 0.2.1 - Haskell 98 either monad transformer  http://hackage.haskell.org/package/either-0.2.1 (EdwardKmett)
01:53:26 <MatrixFrog> cool cool thanks
01:54:03 <k0ral> sorry for the newbie question: I'm using Dyre to allow "easy" configuration of my application, and I'd like to expose some objects (I mean data types) to the Main module, so that the user can perform functions on it; how can I do ?
01:55:30 <edwardk> skurt: well, you can probably parse with 'element'
01:55:52 <edwardk> or anyContent, if you just want to turn it into a data structure
01:56:30 * MatrixFrog got all the types correct in rst76's BotTrust program :)
01:56:55 <skurt> edwardk: Im trying now
01:57:07 <skurt> but I dont understand the documentation a bit
01:57:21 <skurt> for example
01:57:30 <skurt> stringElement :: String -> XMLParser String
01:57:38 <MatrixFrog> so this is interesting, i had a type called TestChamber which represented the current state of the test chamber, but WITHOUT the number of moves that had already happened
01:57:51 <skurt> by descrtiption it should do exactly what I want
01:57:51 <skurt> but
01:58:01 <MatrixFrog> so then i had: solve (a finished tc) = 0
01:58:07 <MatrixFrog> solve tc = 1 + step tc
01:58:15 <MatrixFrog> where step transforms it into one-timestep-later
01:58:34 <skurt> how do I tell it attributeName and give it the XML when it've got only one parameter
01:58:44 <skurt> it doesn't make any sense
01:58:50 <MatrixFrog> so then i guess as it evaluates, i end up with 1 + (1 + (1 + (1 + ...
01:59:06 <MatrixFrog> i just recently got to the part in real world haskell about space leaks and it sounds like my code might be a good example
01:59:13 <edwardk> skurt: hrmm. interesting. i just noticed it is a parser for "Content Posn"  not Char
01:59:39 <skurt> I thought this might work: XMLParser (stringElement "artist") body
01:59:52 <skurt> its similar to simple parsing
02:00:11 <skurt> like: parse (many1 digit) "" "123"
02:01:43 <edwardk> skurt: well, you'd more likely do something like Text.XML.HaXml.Parse.xmlParse "myFileName" "<?xml version=\"1.1\" ?><foo><bar/></foo>"
02:01:48 <edwardk> that will give you a Document Posn
02:03:14 <edwardk> then if you build something like root (Document prolog symtab rootNode misc) = rootNode
02:03:28 <skurt> edwardk: what is the import for that? Text.XML.HaXml?
02:03:32 <edwardk> then you can tall that on your Document, giving you an Element Posn, that you can feed to xml-parsec
02:03:40 <edwardk> Tet.XML.HaXML.Parse
02:04:09 <edwardk> or you can drop the xml-parsec bits completely and just use the result of xmlParse directly
02:05:46 <skurt> edwardk: well...from the beginning. I have the haxml installed
02:06:43 <skurt> but I still cant do that import
02:06:56 <edwardk> one sec. going through it myself
02:06:57 <skurt> I'll reinstall haxml
02:08:03 <edwardk> i can't get HaXml to install  on my machine. i may have broken my ghc earlier today fiddling with my toy compiler
02:10:05 <edwardk> ah nope, had to sudo ln -s /Developer/SDKs/MacOSX10.6.sdk /Developer/SDKs/MacOSX10.5.sdk
02:10:15 <edwardk> some random mac thing
02:10:18 <edwardk> one sec
02:11:48 <Cale> edwardk: One more package and you'll have the entire Recent additions list :)
02:11:52 <Cale> http://hackage.haskell.org/packages/archive/recent.html
02:11:53 <edwardk> hah
02:13:15 <edwardk> and there it goes. i actually had one left to do ;)
02:13:41 * hackagebot graphs 0.3.2 - A simple monadic graph library  http://hackage.haskell.org/package/graphs-0.3.2 (EdwardKmett)
02:14:38 <plumenator> has anyone been able to build gtk2hs on Mac OS X using the instructions on the wiki?
02:15:26 <plumenator> I keep getting this error: make: *** [package.conf.inplace] Error 1
02:15:26 <plumenator> make: *** Deleting file `package.conf.inplace
02:16:38 <edwardk> cale: i've made a clean sweep of the 'what's new' page before, but i think this is the first time i've done so with distinct packages
02:16:41 * hackagebot hashmap 1.2.0.0 - Persistent containers Map and Set based on hashing.  http://hackage.haskell.org/package/hashmap-1.2.0.0 (MilanStraka)
02:16:54 <edwardk> there goes my sweep
02:17:03 <skurt> sorry, my connection fell
02:17:08 <edwardk> at least i got a screenshot
02:17:59 <skurt> edwardk: can you send it? jan.kadera@seznam.cz
02:18:12 <edwardk> skurt: that comment was from a different conversation =)
02:18:24 <skurt> ah
02:19:05 <skurt> and were you able to get it to work?
02:19:43 <edwardk> i just got haxml to install but then got distracted by something cale said about how i'd just filled the what's new package on hackage
02:20:35 <plumenator> Here's the entire output of make when I build GTK2HS: http://hpaste.org/46493/gtk2hs_build_errors
02:20:42 <plumenator> Could anyone take a look?
02:21:01 <plumenator> I'm not able make any sense of it.
02:21:16 <skurt> edwardk: okay
02:23:50 <edwardk> Cale: screenshotted http://i.imgur.com/vTWCs.png
02:24:28 <edwardk> ok. vanity aside. trying to see what i can do with haxml. (never used it really, just read the source)
02:25:24 <skurt> edwardk: thank you
02:25:35 <skurt> edwardk: what I want is something like this:
02:25:44 <hamishmack> plumenator: That is an old gtk2hs
02:25:55 <hamishmack> plimsoll: It is in hackage now
02:25:59 <skurt> Text.XML.HaXml.Parse.xmlParse "foo" "<?xml version=\"1.1\" ?><foo>what I want</foo>"
02:26:07 <skurt> to return "what I want"
02:26:19 <skurt> but this is now how its done :/
02:26:29 <hamishmack> plimsoll: Sorry wrong person
02:26:45 <edwardk> yeah for that you'll need to take the root element, and then access its children, and ask for the first one, expecting it to be a text node
02:26:50 <edwardk> and then ask that for its value
02:27:33 <edwardk> xmlParse gives you a Document. the Document has a root element. the Element is named foo, its children are the child xml nodes. you want a text xml node inside of that root element
02:28:15 <skurt> wow
02:28:17 <skurt> http://timjstewart.blogspot.com/2009/03/exploring-xml-using-haskell.html
02:28:30 <MatrixFrog> i think i'm starting to really get rst76's code for bot trust
02:28:33 <MatrixFrog> this is super clever
02:29:11 <edwardk> skurt: that is a pretty good summary of what you need
02:30:43 * hackagebot fast-math 0.1 - Non IEEE-754 compliant compile-time floating-point optimisations  http://hackage.haskell.org/package/fast-math-0.1 (LiyangHu)
02:52:31 <paolino> MatrixFrog: he got it right, and make it even better then the contest analysis , there is no lookahead
02:54:32 * esap just wrote a function with type: (Random a, RandomGen g, Monad m, Eq b) => (a -> RandomMT g m b) -> b -> RandomMT g m a
02:58:36 <paolino> MatrixFrog: he should use foldl, IMHO, to make it clearer
03:02:02 <paolino> MatrixFrog: also I like more unfoldr than explicit recursion in slice, but that's really taste I suppose
03:13:33 <edwardk> esap: you may be waiting around for it for a while if b is Float or Double ;)
03:15:25 <esap> edvardk: hehe yea, the equivalence class generated by the function in the fiber identified by the 'b' element must be large enough for this to work.
03:16:35 <edwardk> esap: might be nice to have the generalized version that can use a predicate instead
03:18:21 <edwardk> (a -> RandomMT g m b) -> (b -> Bool) -> RandomMT g m a  — or even a -> RandomMT g m Bool -> RandomMT g m a which kind of ruins the bayesian aspect.
03:18:39 <edwardk> er (a -> RandomMT g m Bool) -> RandomMT g m a
03:18:50 <edwardk> which is just repeated drawing
03:19:03 <esap> edwardk: I have a function choice :: (Universe a, Eq b) => (a -> b) -> b -> a, but it doesn't use randomness, it's basically  'head [a | a <- all_elements, f a == b]', where  class Universe a where { all_elements :: [a] }
03:19:39 <jonkri> i have a type, "ClientState s", and want to create a class like "class ClientState s where putSession :: s -> Session s m -> s". should i use "-XMultiParamTypeClasses" and pass the m type to the ClientState type or is there some other way?
03:20:01 <edwardk> that somewhat annoyingly requires your function to be surjective =/
03:20:34 <edwardk> which is basically the same thing as the sort of bayes-rule machinery used above
03:20:43 <Peaker> The Enum class should not have had toInt/fromInt, and then it might have made sense to use it in place of Universe?
03:20:50 <Peaker> (enumerable domain makes sense)
03:21:07 <edwardk> i think there is a decent Enumerable class floating around. copumpkin wrote one i believe
03:21:29 <esap> edwardk: yes, this whole thing is based on surjective function. I have version that doesn't need surjectivity, but which returns Nothing, if it doesn't find an element from the fiber by repeated random choices.
03:22:05 <esap> edwardk: Of course user will need to choose how many random guesses to make at most.
03:22:13 <edwardk> peaker: https://gist.github.com/167980
03:25:28 <edwardk> esap: i wonder if you had an ordering on b if you could model something more like a cumulative distribution function more safely. Returning a such that f(a) <= b. that would work somewhat better for the float, double, etc. cases
03:25:52 <edwardk> still nor perfect if f(a) <= b is never satisfied of course
03:25:53 <edwardk> er not
03:26:09 <edwardk> hence the predicate with redraw approach mentioned above
03:26:53 <Peaker> edwardk, I think it should have stuff like succ/pred (perhaps in a more specific class than the one that lists all)
03:27:34 <edwardk> my problem with Enum is that it is instantiated for Float and Double, so its already been pretty badly compromised ;)
03:27:55 <edwardk> the terrible temptations of sugar ;)
03:29:22 <esap> edwardk: I was also not impressed with Random class because of the instance for Integer.
03:29:55 <edwardk> esap: heh well, if it didn't guarantee uniform random, you could still do something ;)
03:31:46 <edwardk> Integer isn't that problematic except that it provides random along with randomR
03:32:17 <edwardk> if there was a class for just the 'R'd methods, then you could feel better about it ;)
03:33:51 <esap> edward: yea. On the other hand, I'm not sure it's a good thing to represent subsets of the domain with (min,max), it assumes ordering without Ord instance, so I don't really like randomR either.
03:34:49 <edwardk> true
03:35:26 <edwardk> i suppose the problem there is that you'd need an extension to allow randomR to require the Ord.
03:35:39 <edwardk> or you'd need that other class to take an Ord superclass
03:36:41 <esap> edwardk:  But I think it's manageable, at least for simple numbers you get nice even distribution of random values. Anyway, it would not be reasonable to have subsets of the domain to be represented as a list of values.
03:37:28 <edwardk> that and right now everything that has an instance of Random also has an Ord instance
03:37:35 <edwardk> (at least that is provided by default)
03:39:53 <Peaker> edwardk, It's possible to enumerate all possible Floats and Doubles, they're not Reals :)
03:41:00 <esap> edwardk: it's kind of ok for each instance to depend on Ord, but it asks for the question whether the domain could be represented somehow in simple way. My invert function is one approach.
03:41:15 <edwardk> there is the small problem that the Eq used by his (a -> RandomMT g m b) -> b -> RandomMT g m a — will never be able to successfully find a match for a NaN ;)
03:41:33 <edwardk> silly broken equivalence classes
03:41:54 <Peaker> should have been: NaN == NaN
03:42:09 <Peaker> OR: no Eq instance
03:42:43 <edwardk> i actually employ a class which has NaN == NaN, just so i am allowed to exploit pointer equality to short circuit it
03:42:53 <Botje> NaN cat?
03:43:11 <Jafet> > repeat (0/0)
03:43:12 <lambdabot>   [NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,Na...
03:44:40 <Botje> :D
03:45:14 <Jafet> See also "The Complexity of Songs">
03:46:14 <ion> > show (replicate 16 (0/0)) ++ "batman"
03:46:16 <lambdabot>   "[NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN]batman"
03:47:38 <markus3> i think I've successfully tied the knot (http://hpaste.org/46494/tying_the_knot), does it look like the right way to do it?
03:47:46 <Peaker> > (replicate 16 (0/0) >>= show) ++ batman
03:47:47 <lambdabot>   Not in scope: `batman'
03:47:51 <Peaker> > (replicate 16 (0/0) >>= show) ++ "batman"
03:47:53 <lambdabot>   "NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNbatman"
03:48:39 <Jafet> markus3: in these situations, trace is your desert
03:49:12 <ion> > batman
03:49:13 <lambdabot>   "batman"
03:49:50 <markus3> hmm, is that a kind of unsafePerformIO debugging function?
03:50:53 <markus3> oh, yes it is!
03:51:31 <Jafet> @quote oasis
03:51:31 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
03:51:55 <ion> Haha
03:52:14 <Jafet> If you trace parts of the data structure and they're only evaluated once as you traverse them, then you've tied the knot on them
03:52:20 <Jafet> (or use the ghci debugger)
03:54:09 <markus3> so I have tu put it somewhere in the construction of the data, right? like: Constructor (trace "hi!" "String") :: Constructor String
03:55:14 <Jafet> If you want to evaluate the labels once, yes
03:55:30 <Jafet> I imagine you want to tie the graph as well, though
03:57:20 <lifthrasiir> hello everyone.
03:58:28 <Botje> hallo!
03:59:15 <lifthrasiir> well, one of the reasons i joined is of course to ask questions. :p
03:59:17 <esap> edwardk: invert (const (return ()) ()  (where invert :: (a -> RandomMT g m b) -> b -> RandomMT g m a) is basically the same as 'random' lifted to the monad. Also I'm thinking what 'invert . invert' does.
03:59:47 <lifthrasiir> so-- i think i've ran into some problem with Numeric.Rounding. is this a bug or not?: http://codepad.org/kbE5KMQ3
04:00:17 <lifthrasiir> (and anyone can reproduce these results?)
04:02:12 <jonkri> i have a main thread and a thread that i have started with forkIO. when my main thread dies, the forkIO thread lives on. i think i want the forkIO thread to act like what is called a "daemon" thread in java, a thread that dies when there are no non-daemon threads running
04:03:26 <dankna> no built-in functionality for that (it's kind of a weird setup, honestly, on Java's part not yours).  but you can easily implement it with some concurrency primitives.
04:04:17 <jonkri> dankna: which ones? what would be a non-weird setup? :)
04:04:20 <dankna> just have each non-daemon thread that's spawned increment a semaphore, and decrement it when it exits, and then your daemon thread can watch the semaphore for the 1-to-0 transition and exit itself when it happens.
04:04:39 <dankna> note: that's in generic, C-like terminology.  I don't think Haskell calls them semaphores.
04:04:49 <dankna> look in Control.Concurrent for something that strikes your fancy
04:06:05 <jonkri> thanks :)
04:06:07 <dankna> sure
04:06:59 <Jafet> You can make a semaphore thread for every "background" thread, really. Or three. Threads are fairly cheap
04:11:04 <Utkarsh> I'm new to Haskell. Is there a better way to do this?  length [x | (x, i) <- zip xs [1..], x /= i]
04:11:30 <Utkarsh> It counts the number of elements of a list that are out of place, starting with index 1.
04:12:13 <Utkarsh> by 'out of place' I mean the value of element is not equal to the index.
04:12:14 <Jafet> That looks okay
04:12:35 <Jafet> length $ filter id $ zipWith (==) xs [1..]
04:12:45 <mauke> /=
04:12:48 <Jafet> filter not, rather
04:12:50 <Jafet> Or that
04:13:05 <Utkarsh> filter id?
04:13:15 <Botje> length [ () | True <- zipWith (/=) xs [1..] ] -- :)
04:13:23 <aristid> :t length . filter id . zipWith (/=) [1..]
04:13:23 <lambdabot> forall a. (Num a, Enum a) => [a] -> Int
04:13:27 <aristid> point-free :)
04:13:31 * Jafet mentions length . map fromEnum to get on nerves
04:13:33 <edwardk> esap: hrmm, just returned
04:13:42 <Jafet> s/length/sum/
04:14:00 <edwardk> esap: invert (const (return ()) is kinda boring =)
04:14:39 <lifthrasiir> Utkarsh: filter id a-list-of-Bools returns a list of Bools which equal to Trues
04:15:01 <Utkarsh> lifthrasiir: ah!
04:15:04 <lifthrasiir> > filter id [false,true,true,false,true,false]
04:15:05 <lambdabot>   Not in scope: `false'Not in scope: `true'Not in scope: `true'Not in scope: ...
04:15:09 <edwardk> invert . invert should effectively be id assuming that you apply it to a bijective function
04:15:19 <lifthrasiir> > filter id [False,True,True,False,True,False]
04:15:19 <lambdabot>   [True,True,True]
04:15:52 <aristid> @let count = length . filter id
04:15:53 <lambdabot>  Defined.
04:16:01 <Utkarsh> so the best way to count the number of True in a list is 'length $ filter id' ?
04:16:02 <aristid> :t count . zipWith (/=) [1..]
04:16:03 <lambdabot> forall a. (Num a, Enum a) => [a] -> Int
04:16:09 <aristid> Utkarsh: no, length . filter id.
04:16:27 <aristid> if you need it more than once, separate it into a function
04:16:47 <aristid> as i did with the @let here
04:17:22 <aristid> well actually count should maybe defined a bit differently
04:17:24 <Utkarsh> aristid: ah, thanks! I'll play around with zipWith, the solution looks more elegent using zipWith.
04:17:28 <aristid> @let count f = length . filter f
04:17:29 <lambdabot>  <local>:5:0:
04:17:29 <lambdabot>      Multiple declarations of `L.count'
04:17:29 <lambdabot>      Declared at: <loca...
04:17:40 <aristid> @let betterCount f = length . filter f
04:17:41 <lambdabot>  Defined.
04:18:07 <lifthrasiir> i just searched hoogle for count as i thought i missed it. *phew*
04:18:25 <Jafet> @undefine
04:18:34 <Jafet> @let betterCount f = genericLength . filter f
04:18:35 <lambdabot>  Defined.
04:18:38 <aristid> :D
04:18:47 <Jafet> You never know!
04:19:05 <aristid> Jafet: there should totally be a strictLength function
04:19:09 <esap> edwardk: but in a non-bijective case, it could be choosing another representative of the equivalence class.
04:19:16 <edwardk> yeah
04:19:34 <edwardk> in the bijective case the probabilities should cancel, two applications of bayes rule
04:19:51 <edwardk> in the non bijective case you probably don't terminate ;)
04:20:49 <Jafet> Huh? length is strict.
04:21:09 <Jafet> (It has to be, as the result type is flat)
04:21:36 <edwardk> aristid: strict in the sense of forcing the elements, not just the spine?
04:22:14 <aristid> edwardk: strict in the sense of not working with Nat
04:22:30 <aristid> Jafet: genericLength is not, and length is limited to Int
04:22:38 <edwardk> ah
04:23:03 <aristid> afaik it could be written in a bit more optimised way if you don't need to support Nat
04:23:40 <Peaker> Int and other platform-dependent stuff should have been quarantined in some module somewhere
04:24:03 <navaati> hello
04:24:06 <Peaker> @type [genericLength, length]
04:24:07 <lambdabot> forall b. [[b] -> Int]
04:24:13 <Peaker> given specialization, is there any reason to prefer length to genericLength?
04:24:23 <sipa> @src length
04:24:23 <lambdabot> Source not found. :(
04:24:32 <navaati> does importing a module qualified import the instances in it ?
04:24:34 <edwardk> you get to avoid the need to rely on magical specialization
04:24:43 <Peaker> navaati, yeah
04:24:44 <cch> @pl \c -> (c == '\n' || c == ',')
04:24:44 <lambdabot> liftM2 (||) ('\n' ==) ((',') ==)
04:25:16 <Peaker> cch, c `elem` ",\n"
04:25:29 <navaati> I have an error "Could not deduce (Monad ((->) r))" but i import qualified Control.Monad as M
04:25:33 <navaati> how is it possible ?
04:25:34 <Peaker> why does @pl know == specifically?
04:25:45 <cch> Peaker: oh thanks
04:26:21 <navaati> (i verified, there is an instance of Monad for "(->) r" in Control.Monad
04:26:22 <lifthrasiir> @pl \c -> ((c - 5) * (c - 4))
04:26:22 <lambdabot> ap ((*) . subtract 5) (subtract 4)
04:26:45 <lifthrasiir> @pl \c -> ((5 - c) * (4 - c))
04:26:45 <lambdabot> ap ((*) . (-) 5) ((-) 4)
04:26:46 <Peaker> navaati, how did you veirfy?
04:26:52 <Peaker> navaati, there isn't such an instance here
04:27:01 <Peaker> navaati, that instance is in Control.Monad.Instances in my system
04:27:27 <navaati> ah
04:28:00 <navaati> well, i went in the doc of Control.Monad and saw it, but maybe i've got another version…
04:28:39 <navaati> yeah, you're right, thanks
04:33:19 <bsrkaditya> what does @pl do?
04:33:21 <edwardk> navaati: Control.Monad doesn't include the instance for (->) r its in Control.Monad.Instances for historical reasons.
04:33:28 <edwardk> converts to 'pointfree' form
04:33:39 <edwardk> @pl \a b c -> foo a * b c
04:33:39 <cheater93> pl stands for pointless
04:33:39 <lambdabot> (.) . (*) . foo
04:33:49 <Peaker> Since there's only one valid instance of Monad for (->), it should have been included
04:33:54 <mauke> @pl \x -> f x
04:33:54 <lambdabot> f
04:34:09 <mauke> @pl \x -> f (g x)
04:34:10 <lambdabot> f . g
04:34:18 <edwardk> peaker the problem is one of standardization. the haskell report doesn't specify the monad.
04:34:33 <Peaker> It specifies the Monad laws, doesn't it?
04:34:37 <edwardk> and the definition from Control.Monad is imported into the prelude, instances are infectious
04:35:13 <edwardk> it does, but because it doesn't include that instance, you'd violate the report, because someone importing just the prelude and defining it themselves would now fail to compile
04:35:55 <edwardk> any instance you want for classes that are in the report for data types that are in the report would require an amendment to the report
04:36:10 <navaati> hum, another error :
04:36:10 <navaati> Conflicting family instance declarations:
04:36:10 <navaati>       data instance Constraints (Program nc) a
04:36:10 <navaati>       data instance Constraints m a
04:36:10 <navaati> but i defined data instance (M.Monad m) ⇒ Constraints m a and (Program nc) is not a monad, so it shouldn't conflict :/
04:36:12 <edwardk> otherwise you're stuck with orphans like C.M.I
04:37:08 <edwardk> saying data instance Foo m a = .. means you are defining the only such instance
04:37:21 <edwardk> because any other instance will by construction unify with yours
04:37:41 <navaati> but i added a context, so it's not true
04:37:49 <edwardk> the context isn't used in dispatch
04:37:53 <navaati> shit
04:37:54 <edwardk> you'd have to enumerate each case
04:37:59 <mauke> contexts are postconditions
04:38:07 <edwardk> data instance Foo (Either e) a = …
04:38:15 <navaati> it's stupid -_-
04:38:17 <edwardk> think about it this way
04:38:23 <edwardk> how would separate compilation work otherwise?
04:38:33 <navaati> ?
04:38:35 <edwardk> what happens when someone has a perfectly good data instance Constraints Foo a
04:38:42 <edwardk> and then later defines an instance of Monad for Foo?
04:39:17 <edwardk> what happens when you have data instance Monad m => Constraints m a; and data instance Functor f => Constraints f a — which wins?
04:39:46 <edwardk> it introduces a huge ball of ambiguity that requires whole program reasoning to even try to resolve
04:40:01 <navaati> it's not the case ?
04:40:06 <edwardk> right now
04:40:19 <edwardk> but if someone imports your module, you don't know what they'll define
04:40:39 <edwardk> hence the need for the whole program to know if such a definition would be ambiguous.
04:40:53 <navaati> but it should fail for them, not for me where there is no conflicts
04:41:49 <navaati> so it's not possible to make every monad a rmonad :/
04:42:01 <edwardk> the short answer is all it would be doing at best is silently succeeding for you, and then deferring all the hard work of compiling to the last module. you'd lose valuable feedback. the costs are not worth the benefits
04:42:05 <edwardk> no
04:42:09 <edwardk> what you CAN do
04:42:13 <edwardk> is make a wrapper
04:42:33 <edwardk> newtype R m a = R (m a)
04:42:39 <edwardk> and derive Constraints for R m
04:42:45 <dankna> if you ever happen to be using a hybrid Frankenstein build system whereby XCode calls cabal, /do not/ turn on ghc's -ddump-simpl option.  XCode can't cope with the measly 60ish megs of output text, and consumes roughly 12G (!!!) of virtual memory trying to.
04:42:56 <dankna> not that anyone but me is insane enough to try that anyway, but I just thought I'd warn you haha.
04:43:09 <edwardk> and then you can lift a traditional monad into R by wrapping it in a newtype, yielding an RMonad
04:43:15 <edwardk> and manipulate it as such
04:43:23 <edwardk> before lowering it back down by removing the newtype wrapper
04:43:43 <edwardk> if you look at Control.Applicative this is how arbitrary Monads can be used as Applicatives
04:44:21 <navaati> it's annoying, but i guess i've no other choice
04:44:28 <edwardk> it is also, more interestingly how Control.Applicative handles lifting _arrows_ to Applicatives, which couldn't be done by  just defining the typeclass hierarchy differently.
04:45:25 <edwardk> sadly, it is deliberate, and has good motivations, even if it is counter-intuitive and occasionally annoying.
04:47:10 <navaati> it's sad that it's not possible in haskell to define general properties like "every monad is an applicative", or "every function from a -o monad b is an arro from a to b"…
04:48:54 <navaati> (i would use the kleisly arrow all the time if there was no need for a wrapper)
04:49:08 <edwardk> the problem again comes from ambiguity
04:49:29 <edwardk> if i say that every monad is a functor and also that every comonad is a functor, which definition wins when i have a type that is both?
04:49:52 <dankna> okay, so I'm trying to improve the performance of my program, which according to the heap profiler allocates 47 megabytes per second, down from 80 megabytes per second before a bunch of people helped me with it yesterday :)
04:49:57 * mauke defines a property that says every applicative is a monad
04:50:13 <dankna> I invoked GHC with -ddump-simpl and I'm looking through its output hoping to be struck with inspiration
04:50:14 <navaati> well, the compilator should fail if it saw that the both instances exist, but not if there is only one instance
04:50:26 <edwardk> the unwrapped Kleisli arrow case becomes the problem in the sense of which (.) did you mean? the one from Kleisli or the one from (->) ? they yield different answers, and there are cases where both could unify
04:50:54 <dankna> I notice that each function I wrote wound up implemented as about a dozen distinct functions, with numbers appended to their names
04:50:54 <edwardk> well, that would pretty much screw me over. i have a ton of types that are both comonads and monads ;)
04:51:18 <dankna> how do I identify which one is the "main" one?  heh.  is it just the one numbered "1"?
04:52:27 <dankna> oh - I see.  I think I answered my question.  there's a version at the end which doesn't have a number appended, and matches the type signature of what I wrote, so that must be it
04:52:38 <edwardk> navaati: there is some hope that you'll eventually see superclass method definitions with a requirement that if two implicit definitions come into scope that an explicit one must be available to disambiguate, but the kleisli arrow case is fundamental
04:52:56 <edwardk> dankna:  =)
04:53:07 <dankna> :)
04:53:15 <illissius> edwardk: hmm -- what things are both monads and comonads?
04:53:47 <edwardk> (->) e — is a monad, but Monoid e => (->) e is a comonad
04:54:02 <mauke> Identity
04:54:03 <edwardk> Monoid e => (,) e is a monad, and (,) e is a comonad
04:54:07 <edwardk> identity is both
04:54:14 <illissius> yeah, identity was obvious
04:54:18 <pastorn> @type joinMaybes
04:54:18 <lambdabot> Not in scope: `joinMaybes'
04:54:25 <mauke> :t catMaybes
04:54:25 <lambdabot> forall a. [Maybe a] -> [a]
04:54:34 <edwardk> non-empty streams
04:54:44 <edwardk> erc
04:54:45 <edwardk> er etc
04:54:59 <illissius> erc is nice shorthand for er etc.
04:55:08 <edwardk> =)
04:56:10 <edwardk> there are others, yoneda and coyoneda that serve as both
04:56:21 <edwardk> any representable functor
04:56:58 <edwardk> http://hackage.haskell.org/packages/archive/representable-functors/0.4.0/doc/html/Data-Functor-Representable.html provides the definitions for both monads and comonads given tabulate and index
04:57:42 <illissius> ah, yes.. would be nice to have a typeclassopedia v2 :)
04:57:47 <edwardk> which implies that every right adjoint functor can be used as both a monad and a comonad (when the left adjoint functor is a monoid)
04:58:03 <illissius> I looked at representable-functors a while, but wasn't able to gather too much beyond "this looks really interesting" :)
04:58:03 <edwardk> er when the left adjoint at () is a monoid
04:58:13 <edwardk> its actually pretty simple
04:58:37 <edwardk> a functor is representable if you can take f a and find some x such that it is equivalent to x -> a
04:58:45 <edwardk> consider data Pair a = Pair a a
04:58:49 <edwardk> and x = Bool
04:58:58 <edwardk> Bool -> a and Pair a a hold the same amount of information
04:59:17 <edwardk> tabulate f = Pair (f False) (f True) — converts one way
04:59:30 <edwardk> index (Pair a b) False = a; instance (Pair a b) True = b — converts the other way
04:59:51 <Peaker> modulu typos :)
05:00:00 <edwardk> yeah
05:00:35 <edwardk> s/instance/index/ and mutatis mutandis to make it compile
05:01:41 <illissius> hmmmm. a couple of times I've stumpled upon wanting to represent sets of things which were (Eq, Enum, Bounded), and ended up using (a -> Bool) rather than [a] or Set a
05:01:49 <edwardk> the superclasses of Representable and the monstrous pile of default definitions are just powers you pick up from being isomorphic to a function
05:02:11 * illissius tries to work out if this bears any relation..
05:02:30 <edwardk> well, that is closer to http://hackage.haskell.org/packages/archive/representable-functors/0.4.0/doc/html/Data-Functor-Corepresentable.html
05:02:58 <edwardk> corepresentability is isomorphism to a function _to_ some type x. from a contravariant functor
05:03:19 <edwardk> f a ~ (a -> x)
05:03:33 <edwardk> its a lot less interesting ;)
05:04:54 <illissius> heh. allow me to stare at what you've written so far for a few minutes before asking further questions.
05:04:59 <edwardk> the most interesting thing about them is that products and coproducts of corepresentable functors are also corepresentable
05:06:00 <dankna> if I have a function organized as let a = ... b = ... c = ... with many clauses that build on each other
05:06:10 <dankna> and I want to make it stricter to reduce its allocation
05:06:18 <dankna> is it useful to put ! before each clause?
05:06:31 <dankna> I don't really fully understand strictness annotations
05:06:35 <edwardk> dankna: it may be problematic if they are circular
05:06:41 <dankna> happily they are not
05:07:06 <dankna> okay, so it's not obviously irrelevant to what I'm trying to achieve :) good, I'll try it
05:07:23 <edwardk> then the short answer is 'it may help', but folks'd need more info to know if its a good idea
05:07:34 * hackagebot swish 0.3.1.0 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.3.1.0 (DouglasBurke)
05:08:08 <dankna> fair.  well, I'm happy to provide any info people want.  it's a medium-sized program and I doubt you'd want to just read through a dump of the whole thing :)
05:08:32 <edwardk> dankna: you can always hpaste the relevant fragment
05:08:36 <dankna> I'm fine with trying stuff and profiling and iterating and stuff, I don't need to be walked through that
05:08:49 <dankna> yeah, I'll do that in a sec, if it still is the relevant one after these changes
05:13:19 <dankna> does changing let a = ... in ... to let !a = ... in ... force a to be evaluated even if it's never used?  because I don't want that
05:13:37 <dankna> at least, I don't want it in every case, it would be a decision I'd have to think about for each row
05:13:41 <edwardk> yes
05:13:44 <dankna> oh, hmmm
05:13:45 <dankna> okay
05:14:01 <edwardk> ! isn't magic speed dust. you need to be careful
05:14:19 <dankna> yeah
05:14:28 <dankna> well, I'm trying to understand it :)
05:15:09 <dankna> but it doesn't force evaluation if the let itself isn't evaluated, of course?
05:15:26 <edwardk> let (!a,!b) = … in foo can be viewed as desugaring to let (a,b) = … in a `seq` b `seq` foo
05:15:30 <dankna> (how could it, I guess, but I thought I had better ask)
05:15:33 <dankna> gotcha, good then
05:16:12 <edwardk> illissius: did that make any sense at all? =)
05:21:28 <illissius> edwardk: I think I mostly get it. ...what is it useful for? :)
05:22:33 <edwardk> illissius: when you have a representable-functor that is Traversable, it can be quite useful as a way to memoize functions
05:23:22 <edwardk> after all, f a is isomorphic to a function from x -> a, so you can use it as an alternate representation. if f can be indexed into cheaply enough it can be used to memoize the function's answers
05:23:46 <edwardk> consider the Pair a  data type above as memoizing a function from Bool
05:24:08 <edwardk> the representable-tries package provides memotries based on this property
05:24:53 <illissius> hmm, so effectively every HasTrie a => (a :->:) is Representable?
05:25:05 <illissius> (going by the MemoTrie package... /me looks up representable-tries)
05:26:09 <edwardk> the plumbing is a bit complicated by the fact that what i use is an isomorphism to the key of a base functor instead of using it directly
05:26:19 <edwardk> but yes
05:26:46 <edwardk> I require TraversableWithKey1 — which is Traversable on steroids, enriched with access to the 'key' and with the assumption of at least one slot
05:26:55 <illissius> oh hey, another HasTrie and (:->:).
05:26:56 <edwardk> and Representable
05:26:59 <edwardk> yeah
05:27:07 <edwardk> it was designed to feel the same
05:27:32 <edwardk> in fact i started it as a patch to MemoTrie, but it grew out of control and well beyond what it seemed Conal would accept
05:27:43 <illissius> heh
05:27:55 <illissius> guess i'm going to stare at this one for a while as well
05:28:00 <illissius> bbiab :)
05:28:19 <edwardk> FYI: the main purpose for my (:->:) is to enable it to form a semigroupoid
05:29:01 <edwardk> (it picked up the isomorphism baggage as a way to work around the inability for ghc to deal with equality constraints properly as part of class signatures
05:29:15 <edwardk> but it turned out to be useful in its own right
05:35:37 <Athas> I have a function like 'lift $ modify $ \s -> s { needsRedraw = RedrawAll }'.
05:35:37 * hackagebot semigroups 0.5.0 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.5.0 (EdwardKmett)
05:36:09 <Athas> Changing it to check whether the needsRedraw field is already RedrawAll, and returning 's' unchanged if so, cuts its runtime by a third (according to GHC profiling).
05:36:23 <edwardk> athas: sounds about right
05:36:31 <Athas> Is there something I am missing?  This structure is not shared anywhere, and I thought GHC was rather aggressive about optimising that.
05:36:36 <Athas> Maybe I have a thunk somewhere?
05:36:37 <navaati> that's strange : i've a Warning: No explicit method nor default method for `>>=', shouldn't it be an error ?
05:36:37 <edwardk> athas: copying the whole constructor like that can be fairly expensive, and it might reduce sharing
05:37:01 <Athas> Hmm.
05:37:12 <Athas> Maybe there is similar low-hanging fruit to pick.
05:37:23 <edwardk> ghc doesn't track such assignments for equality, since in general it doesn't know how to compare values for equality, or that even if it had an Eq instance, that it really means they are interchangeable
05:37:34 <Athas> My program is already rather fast, but I need it faster yet, which it rather hard. :-)
05:37:52 <Athas> No, I mean, I thought GHC changed data structures in-place if it can determine that they are not shared.
05:39:20 <edwardk> that will not happen if it makes it out of registers basically. if unboxing and strictness analysis keeps it all in registers you'll get basically what you suppose, but ghc won't scribble on a closure directly.
05:39:56 <Athas> I'll keep that in mind.
05:40:00 <edwardk> you'd need both strictness and uniqueness information, while ghc has the former, it doesn't have the latter.
05:40:41 <edwardk> but a surprising amount of such structures can be moved by the compiler into registers if the call pattern and strictness analysis allow for it
05:45:38 * hackagebot comonad 1.1.0 - Haskell 98 comonads  http://hackage.haskell.org/package/comonad-1.1.0 (EdwardKmett)
05:51:39 * hackagebot semigroupoids 1.2.0 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-1.2.0 (EdwardKmett)
05:52:21 <illissius> edwardk: what would HasTrie look like with equality class constraints?
05:52:24 <lifthrasiir> edwardk: eh, sorry for the distraction, but are you maintaining the rounding package?
05:52:39 <edwardk> lifthrasiir: i wrote it but it will never work =)
05:53:00 <edwardk> lifthrasiir: you'd need to build with a non-borked libm.
05:53:15 <lifthrasiir> edwardk: yeah, i just want to point out that maddf and mminusf refers the wrong symbols. ;)
05:53:34 <edwardk> lifthrasiir: ah. i'll get someone to hide the package
05:53:46 <edwardk> if you want to, you can send a patch to my github though
05:54:13 <lifthrasiir> ah, the link to patch-tag.com was broken so i assumed there is no public repo now.
05:54:15 <edwardk> it works for the toy functions, but the trig functions blow sky-high
05:54:31 <edwardk> i defected once patch-tag ate a few months of my work
05:54:42 <navaati> what the hell : ghc emits a warning instead of an error for a missing method in an instance declaration, then it links the program without saying anything and then i get the error at runtime…
05:54:46 <lifthrasiir> hmm, is there any other alternative for explicit rounding?
05:55:13 <edwardk> i'm working on a solid binding to hmpfr. there is one up there, but it requires you to build with integer-simple
05:55:42 <edwardk> to do it right you need foreign prims and hand-rolled c—. its slow going.
05:55:55 <edwardk> when it does happen, my fixed-precision package will be updated
05:56:06 <illissius> navaati: yeah, that's normal.
05:56:29 <edwardk> i need perfectly controlled rounding for taylor models
05:56:52 <edwardk> but i haven't been working on them in a while
05:57:07 <navaati> illissius: really ? weird, what is the reason ?
05:57:18 <illissius> navaati: partly because you can make anything an instance of anything anyways by just using undefined for the method definitions
05:57:21 <edwardk> and copumpkin, who i'd been working on the binding with, is in panama for a couple of weeks, so it won't happen soon =)
05:58:09 <navaati> hum, it's time to activate this ghc option "warnings are errors" :-°
05:58:40 * hackagebot comonad-transformers 1.6.0 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.6.0 (EdwardKmett)
05:59:08 <edwardk> navaati: it warned you it would blow up if you used it… then blew up, seems perfectly reasonable ;)
05:59:35 <edwardk> just use -Wall
05:59:39 <lifthrasiir> edwardk: looks like a binding for MPFR. i don't need the arbitrary precision however (looks nice nevertheless), so that means i should make a new one :p
06:00:02 <illissius> edwardk: (edwardk sure is popular) basically, the difference between representable-tries and MemoTrie is that representable-tries uses an associated type for the trie and a non-associated (:->:) GADT to store it, whereas MemoTrie uses an associated (:->:) datatype for both functions?
06:00:29 <edwardk> lifthrasiir: the problem with binding to MPFR yourself is that it is hard to get right. ghc rebinds the garbage collector for GMP which MPFR depends upon internally, and this means that the 'obvious' binding is insufficient.
06:01:02 <edwardk> illissius: and that many of the tries admit an 'adjust' call to tweak single values, etc.
06:01:10 <lifthrasiir> edwardk: no, i meant that i don't need the full power of MPFR (as the arbitrary precision is not my requirement).
06:01:55 <edwardk> lifthrasiir: yeah, i used MPFR because i can't get rounding to work at all with libm, since libm gives practically random answers if you call cos or sin, etc. with a non-default rounding mode
06:01:57 <lifthrasiir> okay, to be exact, i wanted to build some kind of interval arithmetic package (but far more advanced than Numeric.Interval).
06:02:09 <edwardk> this is despite the fact that libm is where the idea of changing those rounding modes was !*@)(#*)'ing defined
06:02:33 <lifthrasiir> the global rounding mode is quite dangerous obviously.
06:02:33 <edwardk> the original Interval package used rounding to round down and up on the interval endpoints
06:02:51 <edwardk> but then i found that libm rounding was borked for most of the cases i wanted to use it
06:03:05 <edwardk> MPFR is the best portable controlled rounding solution i've found
06:03:16 <lifthrasiir> that is rather unfortunate, as i might build my package on the top of the original interval package
06:03:18 <edwardk> the runner up is a proper libm replacement, but its hard to cabal-ize
06:03:37 <erus`> > reverse "!dlrow elloH"
06:03:37 <lambdabot>   "Holle world!"
06:03:45 <erus`> damn
06:03:56 <edwardk> if i can get the fixed-precision library fixed up by using mpfr internally, i'll flip the interval package over to use it for rounding. the performance loss is worth it to me for the accuracy gain
06:04:07 <Jafet> Draw backs.
06:04:23 <edwardk> since i really want my models to be able to ensure that the answer does lie in the middle of the interval, even when i'm dealing with the degenerate cases
06:05:40 <edwardk> http://lipforge.ens-lyon.fr/www/crlibm/
06:05:46 <edwardk> is a correctly rounded libm
06:06:06 <edwardk> the real one will never be fixed because it has the curse of being maintained by Ulrich Drepper.
06:06:52 <lifthrasiir> edwardk: does the default libm get it right for basic arithmetic operators? (+, -, * and /)
06:07:05 <edwardk> by accident, yes ;)
06:07:06 <Peaker> what is Ulrich's response to the issue?
06:07:45 <edwardk> basically it can cost the common usecase an infinitesimal amount of performance, so screw the folks who need anything more exotic, and then he cites random standards which don't have any mention of rounding modes as justification
06:07:47 <lifthrasiir> (btw thank you for pointing out crlibm! worth looking at it.)
06:08:16 <edwardk> which is complete crap because libm is where the notion of supporting rounding modes in the first place was introduced!
06:09:36 <edwardk> lifthrasiir: no problem. it doesn't work for me because i couldn't come up with a nice way to cabalize its installation, but you may have better luck
06:09:48 <Athas> I know this is a rather vague question, but what is a good data type for representing strings with good append/prepend complexity?  It's for the internal representation of string values in a programming language.
06:10:01 <jaj> it's like strlcpy and strlcat in glibc
06:10:04 <edwardk> Athas: fingertrees of bytestrings
06:10:28 <edwardk> O(min(log n, log m)) append, O(1) cons
06:10:58 <illissius> edwardk: what would it (representable-tries) look like if GHC didn't have to be worked around? (also, is the reason you have separate Zip and Apply classes solely to disambiguate the instances for types like [] which have both 'zipping' instances and Bind/Monad-compatible instances, but not at the same time?)
06:12:32 <edwardk> class (a ~ Key ((:->:) a), TraversableWithKey1 ((:->:) a), Representable ((:->:) a)) => HasTrie a where type (:->:) a :: * -> *
06:12:42 <Athas> edwardk: I considered that as well.  Has it been packaged up anywhere?
06:12:52 <edwardk> and no embedKey/projectKey requirement
06:13:18 <edwardk> Athas: i have a small package i use it in on hackage, and several other internal variations on the theme. one sec
06:13:47 <edwardk> http://hackage.haskell.org/packages/archive/rope/0.6.1/doc/html/Data-Rope.html
06:14:37 <edwardk> the api for that package could use a bit of love though. i designed it to talk about annotated ropes, which are a messier concept
06:14:50 <edwardk> so i didn't work too much on the unannotated rope parts
06:15:28 <Athas> From a cursory examination, it seems adequate.
06:15:28 <edwardk> you can use it to (un)cons utf-8 encoded chars, or to (un)cons individual bytes as needed
06:15:35 <Athas> My needs are rather simple.
06:16:13 <edwardk> let me know how it works for you
06:16:34 <edwardk> i'll probably split it out from the annotated rope code at some point, and rename the other parts something else
06:17:09 <edwardk> especially now that i have some experience flipping the annotations from comonadic code to monadic code, perhaps i can do the same to the annotated rope api
06:17:24 <edwardk> (my graphs package started comonadic)
06:17:37 <skurt> How do I round a number to n decimal numbers?
06:17:52 <skurt> for example 3.1234 -> 3.12
06:17:54 <skurt> ??
06:18:25 <skurt> Pardon me for being an idiot, but I just cant find the solution =O
06:19:22 <edwardk> @type floatToDigits
06:19:22 <dankna> round (input * (pow 10 n)) / (pow 10 n)
06:19:23 <lambdabot> forall a. (RealFloat a) => Integer -> a -> ([Int], Int)
06:19:35 <edwardk> it is in Numeric
06:19:37 <dankna> yeah, or that
06:19:43 <edwardk> its rather obscure =)
06:19:59 <edwardk> floatToDigits 4 (1.0)
06:20:05 <edwardk> > floatToDigits 4 (1.0)
06:20:05 <lambdabot>   ([1],1)
06:20:23 <edwardk> > floatToDigits 8 pi
06:20:24 <lambdabot>   ([3,1,1,0,3,7,5,5,2,4,2,1,0,2,6,4,3],1)
06:20:39 <edwardk> > floatToDigits 10 pi
06:20:40 <lambdabot>   ([3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3],1)
06:21:05 <illissius> edwardk: and for types like Any where you currently reuse the tries for, in this case, Bool, (and Any ~ Key (BoolTrie) doesn't hold), you'd just bite the bullet and define the tries separately?
06:21:24 <edwardk> illissius: yep
06:21:33 <edwardk> this is why the embedKey/projectKey was convenient ;)
06:21:54 <edwardk> saves ~40 instance definitions at a time ;)
06:22:23 <Peaker> edwardk, O(min(log n, log m)) implies o(1) for cons doesn't it?
06:22:28 <skurt> thank you
06:22:37 <edwardk> peaker: yeah it does =)
06:22:52 <illissius> heh, ok. makes sense.
06:23:20 <edwardk> illissius: but while convenient, i converged to it because of the limitation
06:26:49 <illissius> edwardk: I have a small mini-package locally, basically consists of: newtype Atomic a = {- unexported -} Atomic a; atomic :: HasTrie a => a => Atomic a; atomic = memo Atomic; unatomic :: Atomic a -> a; unatomic (Atomic a) = a
06:27:34 <illissius> the purpose was basically to be able to define efficient Eq/Ord instances for Atomic ByteString comparing only the pointer
06:28:01 <edwardk> what are you using for pointer comparison, reallyUnsafePointerEquality ?
06:28:12 <edwardk> or are you taking stablenames?
06:28:18 <illissius> edwardk: ByteString.Internal.toForeignPtr
06:28:20 <illissius> moment
06:28:23 <edwardk> ah
06:28:28 <edwardk> fair nuff
06:29:01 <edwardk> that is a reasonably nice way to intern strings
06:29:01 <illissius> ..this would be a lot more generally useful if GHC allowed pinning arbitrary objects and had reallyUnsafeAddr# though :)
06:29:24 <edwardk> yeah. you _can_ do the stablename thing, but its still a lookup
06:29:36 <edwardk> i have a package for that somewhere
06:30:04 <edwardk> well, at least for tabulating information based on stablenames
06:30:19 <illissius> StableNames don't give you anything more than reallyUnsafePtrEquality# does, do they? still nothing for Ord, and you can still only prove inequality, not equality
06:30:34 <dankna> gah >< this crash in the RTS code that outputs the profile keeps popping up and interfering with my profiling.  maybe I should downgrade to a stable GHC.
06:30:47 <edwardk> reallyUnsafePtrEquality can give you two sided error. both false positives AND false negatives
06:30:58 <illissius> edwardk: that was what I'd heard as well
06:31:09 <illissius> but in #ghc the other day they informed me that that's not the case
06:31:21 <Twey> How false positives?
06:31:22 <edwardk> fair nuff
06:31:22 <illissius> and only false negatives are possible
06:31:45 <Twey> Yeah, false positives doesn't seem very reasonable… if it's positive then it's the same pointer
06:31:46 <edwardk> my recollection was something about how one of them could be moved to where the other was
06:31:52 <Twey> You can't have the same pointer point at two things
06:31:53 <Twey> Ah
06:32:05 <Athas> You can with a segmented memory model!
06:32:08 <edwardk> or that the reading of the address might get moved, but that doesn't jive with my understanding
06:32:09 <Twey> Hm
06:32:10 <Athas> Of course, GHC doesn't run on DOS...
06:32:12 <illissius> edwardk: right. we're probably recalling the same thing. can't remember from where.
06:32:32 <edwardk> because that should require me to stop and do a gc in the middle, and you can't do that in the middle of a primop like that
06:32:40 <Twey> Yeah
06:34:30 <illissius> the fact that GHC uses a copying collector was mentioned, i.e. the place where the GC moves objects from and where it moves them to do not overlap.. but I can't remember if this was -the- reason false positives are not possible, or an "even if -the- reason didn't hold, it would still be impossible because of this one" thing
06:36:11 <edwardk> Athas: i sometimes miss segments, they had nice tricky things you could do with them to emulate capabilities ;)
06:36:40 <edwardk> illissius: i'll buy it
06:40:25 * illissius wonders if pinning arbitrary objects is a really really hard, or just a somewhat-hard-and-no-one's-bothered problem...
06:40:53 <edwardk> i do it in my toy compiler, but i have a different gc design
06:41:03 <Jafet> That... sort of defeats the point of garbage collection?
06:41:11 <illissius> it was something to do with slop
06:41:14 <Jafet> Unless you somehow mark objects when they're generateed
06:41:17 <edwardk> nah. you can do it in other languages
06:41:26 <edwardk> it just makes gc painful
06:41:33 <Jafet> (that is, copying GC)
06:41:33 <illissius> but i didn't quite grasp why the one made the other impossible/difficult
06:42:49 <illissius> (http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/Slop and http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC/Pinned, fwiw)
06:42:55 <edwardk> illissius: because ultimately you need to deal with holes in your various spaces caused by randomly pinned crap.
06:43:24 <edwardk> you can do this a number of ways. by making from and tospaces into lists of pages, or by including said gaps by putting boundaries in, etc.
06:43:36 <edwardk> but you pick up a lot more edge cases
06:44:06 <edwardk> which is dangerous in something like the collector
06:44:20 <illissius> edwardk: it says "Pinned objects are allocated into a block of their own, not mixed up with unpinned objects." -- does "block" mean "contiguous area of memory"?
06:45:40 <edwardk> ghc has a funny way of dealing with pinning. since you have to allocate something pinned or not. in other worlds, you may have every object existing in a single heap, and then pin them post hoc, like in c# with the fixed keyword
06:46:08 <edwardk> illissius: yes
06:47:46 * hackagebot semigroupoids 1.2.1 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-1.2.1 (EdwardKmett)
06:48:19 <illissius> what would be the problem with implementing (say) pin# as moving the object one last time into one of those pinned-object-blocks, and then leaving it there?
06:49:02 <illissius> something about slop making those blocks unpossible to scan/scavenge/similar, which is the connection I didn't get
06:49:16 <illissius> (my knowledge of garbage collectors is very superficial)
06:50:11 <edwardk> what would 'moving it' entail? consider that ghc in general doesn't have any sort of repackClosure# primitive to copy a closure.
06:50:19 <edwardk> also consider the issues with semantics
06:50:58 <edwardk> what happens when that closure contains an unsafePerformIO? and someone references the old location while you're doing this
06:51:03 <Athas> Does the Haskell/GHC API permit something like "read as many characters as you can without blocking"?
06:51:23 <Athas> The only way I can find is an ugly combination of hWaitForInput and hGetChar.
06:52:09 * illissius ponders
06:52:10 <edwardk> athas: you could probably do something horrid with System.Posix.IO and setting the input to nonblocking
06:52:22 <Saizan> edwardk: maybe you could say that pin# also evaluates to WHNF, and get the same semantics of replacing a thunk with the value
06:53:47 <Athas> But how will GHC react if I change its Handles to be nonblocking underneath it?
06:57:47 <edwardk> Athas: like anything else when talking to a nonblocking file
07:00:16 <Saizan> ghc already sets the underlying descriptors to non-blocking i think
07:00:50 * hackagebot comonad-transformers 1.6.1 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.6.1 (EdwardKmett)
07:01:37 <Jafet> Athas: make a thread to do whatever you need to do with the input
07:02:33 <edwardk> ghc's threads are so cheap that that is a pretty good idea
07:06:20 <illissius> Saizan: so it'd make sense to have it be something like pinSeq# :: b -> a -> a, meaning the first argument is evaluated and pinned before returning the second? I was thinking that (at least for purposes of Atomic) you'd want something like "keep 'a' pinned as long as (Atomic a) is alive", so perhaps that could be part of the semantics as well (keeping the first argument pinned at least as long as the second is alive) (as long as we're
07:06:22 <illissius> all wishing for ponies..)
07:06:51 * hackagebot comonads-fd 1.6.1 - Comonad transformers using functional dependencies  http://hackage.haskell.org/package/comonads-fd-1.6.1 (EdwardKmett)
07:08:11 <edwardk> illissius: note that that could be somewhat hazardous because the process of evaluating is going to scribble the forwarding pointer into the closure, so when you do something like ones = 1 : ones, the reference to yourself from within will be pointing to the closure with the forwarding pointer, so it may not wind up pinned, etc.
07:08:20 <edwardk> sounds like a huge implementation headache
07:10:02 <edwardk> for each objection there is some kind of patch, but we have yet to motivate it well =)
07:11:06 <edwardk> also there is a pretty good reason why you can't just pin anything i'd gamble. that is, this pinned memory of which you speak, does it currently contain any references to haskell objects?
07:11:18 <illissius> edwardk: nope
07:11:31 <illissius> that's also something to do with the bit about slop
07:11:32 <edwardk> then you'd have a huge case to deal with in the garbage collector
07:12:16 <edwardk> right now its easy. don't chase any pointers into the pinned block.
07:13:31 <edwardk> this means that everyone would wind up incurring a cost =/
07:14:04 <illissius> edwardk: why is following pointers in pinned objects harder than following them in unpinned ones? i think this might be the nub of the issue
07:14:45 <edwardk> you don't have to do anything with the contents of pinned memory in the gc at all. you don't even have to look at it
07:16:11 <edwardk> have you ever read the original bibop papers?
07:16:38 <illissius> edwardk: about garbage collection? I was about to say I should read a dang book about it before bothering other people :)
07:17:05 <edwardk> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.72.1794&rep=rep1&type=pdf is a good starting point
07:17:44 <edwardk> it talks about how you can use a bibop-like model to mark different regions of memory as pinned, or not-containing-pointers, etc. and use that to help garbage collection and performance
07:18:01 <edwardk> its not directly relevant to ghc, etc. but it does introduce a lot of the ideas and provides references
07:18:55 <edwardk> but in general, you're happiest when you don't have to look at something to decide what to do, because then it doesn't have to be resident during the sweep. this is why cardmarking techniques and other ways of moving the gc data out of band of the object are so popular
07:19:30 <illissius> ah, thanks
07:19:39 * illissius adds that to his pile-of-papers :)
07:19:43 <edwardk> http://www.amazon.com/Garbage-Collection-Algorithms-Automatic-Management/dp/0471941484 is also a good book, covering a surprisingly wide array of techniques
07:19:52 <edwardk> i've read it cover to cover at least a half dozen times
07:19:59 <illissius> :o
07:21:03 <edwardk> i waffled between read barriers and write barriers, and concurrent collection strategies, etc. before i fell back on a very odd little collector
07:21:29 <edwardk> and so i wound up covering a lot of the ground in that book on my own. i learn best by repeating the mistakes of others ;)
07:22:01 <illissius> i'd wager that's true for most people
07:24:18 <Saizan> now i want a primitive to evaluate to rnf and move a full value to the pinned region, for long-lived big objects
07:24:49 <illissius> edwardk: presumably my hazy mental picture of the algorithm currently going "does this point into an unpinned block? ok, then don't follow it", and all that would have to be done to remove the restriction being to remove that check, is *wildly* inaccurate? (and again, this is around the part where slop presumably enters into things in a way I don't understand)
07:24:53 * hackagebot comonad-extras 0.2 - Comonad transformers requiring extensions to Haskell 98  http://hackage.haskell.org/package/comonad-extras-0.2 (EdwardKmett)
07:24:55 * hackagebot either 0.2.2 - Haskell 98 either monad transformer  http://hackage.haskell.org/package/either-0.2.2 (EdwardKmett)
07:25:11 <edwardk> the problem is what do you do with existing references to it? other references to the old version won't get forwarded
07:25:47 <edwardk> illissius: you can remove that check, but then everyone else suffers.
07:26:03 <illissius> Saizan: a primitive to evaluate to rnf would be pretty useful in itself.. :)
07:27:36 <illissius> edwardk: ah, ok. so currently it's primarily there as an optimization, and not as a prerequisite for proper functioning (or, at least, that's part of it)
07:28:22 <edwardk> in most collectors, you usually have a notion of areas that can never contain pointers, where the collector is never responsible for paging that region in.
07:28:45 <edwardk> and yeah
07:28:59 <Saizan> you could do like for thunk updating, and leave forwarding closures in place of the old versions, that get cleaned by the next gc
07:29:14 <edwardk> doesn't work for constructors. no place to write the forwarding.
07:29:31 <edwardk> i went to do that once and was surprised by the memory layout =)
07:30:05 <edwardk> ghc can't move a constructor without stopping the world
07:30:16 <Saizan> oh
07:31:00 <edwardk> other closures have a nice little pointer to write the forwarding pointer before you replace the evaluation function with the forwarding function. closures don't have that
07:31:17 <edwardk> when you gc they get marked and the forwarding pointer is literally scribbled over data
07:33:17 <Saizan> and a primitive that stops the world is not very nice
07:33:29 <edwardk> yeah
07:34:28 <edwardk> and deferring such to gc just adds another rare complication to a hard to test/validate part
07:34:39 <edwardk> and adds overhead to the common case
07:35:54 * hackagebot eq 0.3.1 - Leibnizian equality  http://hackage.haskell.org/package/eq-0.3.1 (EdwardKmett)
07:36:30 <illissius> so, as it turns out, the reason the problem hasn't been solved (surprisingly!), is that it's hard.
07:36:33 <illissius> :)
07:37:07 <edwardk> =)
07:37:11 <JimmyRcom> is there a program extensible in haskell for quick keys, like autohotkeys or xbindkeys
07:37:39 <edwardk> well, there is xmonad, which you can probably do something like that in
07:37:51 <edwardk> but i don't know of something more general purpose
07:38:02 <illissius> otherwise, i'll possibly get back to you in a couple months after having read the paper/book.
07:38:05 <edwardk> or rather more specifically purosed
07:38:07 <illissius> edwardk: thanks for the explanations
07:38:20 <edwardk> illissius: no problem. helps keep me motivated while i refactor =)
07:38:28 <JimmyRcom> xmonad is a little much, I've been using xbindkeys and using guile to extend, which is a lot more annoying
07:38:31 <Athas> Optimising Haskell is more fun than I thought.
07:39:54 * hackagebot free 0.2.0 - Haskell 98 monads for free  http://hackage.haskell.org/package/free-0.2.0 (EdwardKmett)
07:40:45 <illissius> (the other thing arbitrary pinning would get us besides really efficient Eq/Ord instances for arbitrary HasTrie a => Atomic a is really efficient StablePtr-esque functionality)
07:42:55 * hackagebot comonad-transformers 1.6.2 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.6.2 (EdwardKmett)
07:46:55 * hackagebot keys 0.2.5 - Keyed functors and containers  http://hackage.haskell.org/package/keys-0.2.5 (EdwardKmett)
07:52:56 * hackagebot monad-products 0.2.0 - Haskell 98 monad products  http://hackage.haskell.org/package/monad-products-0.2.0 (EdwardKmett)
07:55:38 <vicvicvic> is there an obvious way of reading entire stdin at once, i.e. getContents non-lazily?
07:56:01 <Peaker> @hoogle strict
07:56:01 <lambdabot> module Control.Monad.RWS.Strict
07:56:01 <lambdabot> module Control.Monad.ST.Strict
07:56:01 <lambdabot> module Control.Monad.State.Strict
07:56:05 <Peaker> @hackage strict
07:56:05 <lambdabot> http://hackage.haskell.org/package/strict
07:56:35 <Peaker> http://hackage.haskell.org/packages/archive/strict/0.3.2/doc/html/System-IO-Strict.html
07:57:09 <Peaker> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.4/doc/html/Data-ByteString.html#v%3AgetContents <-- better idea if you care about efficiency
07:57:47 <vicvicvic> i see, strict is the opposite of lazy?
07:57:48 <vicvicvic> :)
07:58:04 <vicvicvic> thanks!
07:58:50 <Peaker> vicvicvic, well, strict is the opposite of non-strict.  eager is the opposite of lazy.  But lots of people don't use these terms accurately
07:58:56 * hackagebot pointed 0.1.2 - Haskell 98 Pointed and copointed data  http://hackage.haskell.org/package/pointed-0.1.2 (EdwardKmett)
07:59:03 <Athas> Hm, how would you handle juxtaposition syntax in a Parsec parser?
07:59:39 <vicvicvic> i see
07:59:45 <Peaker> vicvicvic, strict/non-strict refers to denotational semantics (expected outputs of programs), for example:  f _|_ = _|_  means f is strict on its first arg.   f _|_ = <non-bottom>   means f is non-strict.   Whether it is eager or lazy refers to the operational semantics (not the output of the program, but how it is executed)
08:00:12 <edwardk> sadly i find myself forced to use the incorrect form in my packages by analogy to the monadic equivalents that use the names that way =/
08:00:22 <edwardk> also NonStrict is a crappy module name ;)
08:00:55 <Saizan> Athas: many expr where expr is your expression parser which also swallows trailing spaces?
08:01:01 <Peaker> I think most of the time people really care about eager, lazy, and non-strict.  Very few people want strictness and for very little of the time
08:01:12 <Saizan> Athas: the question mark is because i'm not so sure :)
08:01:39 <Saizan> many1, actualyl
08:01:43 <Peaker> is strictness always a by-product of eagerness or is that just usual/circumstancial?
08:01:59 <Athas> Saizan: that won't work if juxtaposition has the highest precedence.  What I did last time was make my expression parser operate on terms that were already passed through a juxtaposition-handling parser.
08:02:12 <Athas> I don't recall being particularly impressed with the elegance of my parser, though.
08:03:05 <kamilc> hi all
08:03:26 <Saizan> parsec has an expression parser for haskell i think, maybe you can check there
08:03:29 <kamilc> does abybody have/had a problem with simple regexp usage i haskell ??
08:03:56 <Athas> I had, but then I found regex-base.  Now that is a nice library.
08:04:41 <kamilc> @Athas: because i have a problem ( types ) with simple "foobar" =~ "foo" :: String
08:04:41 <lambdabot> Unknown command, try @list
08:05:03 <kamilc> and that gives me: No instances for (RegexMaker
08:05:03 <kamilc>                         Text.Regex.TDFA.Regex CompOption ExecOption source0,
08:05:03 <kamilc>                       RegexContext Text.Regex.TDFA.Regex source10 String)
08:05:03 <kamilc>       arising from a use of `=~'
08:05:14 <Peaker> I found all the regexp libs in Haskell to be trainwrecks :)
08:05:39 <edwardk> term = many1 term0
08:06:21 <doserj> > "foobar" =~ "foo" :: String
08:06:22 <lambdabot>   "foo"
08:06:56 <kamilc> I've got here ghc 7 and regex-tdfa
08:07:05 <edwardk> Peaker: the price of generality. the regex api design was apparently drawn up by someone enamored of how nice it was to use the perl one
08:07:27 <kamilc> also with regex-pcre and regex-posix I've got same problem...
08:07:51 <edwardk> kamilc: you probably need some manual type annotation
08:08:17 <edwardk> kamilc: the regex bindings use a lot of multiparam typeclasses, and usually need some help to figure out which instance you want
08:08:45 <kamilc> ("foobar" :: String) =~ ("foo" :: String) :: String
08:08:55 <kamilc> No instances for (RegexMaker
08:08:55 <kamilc>                         Text.Regex.TDFA.Regex CompOption ExecOption String,
08:08:55 <kamilc>                       RegexContext Text.Regex.TDFA.Regex String String)
08:08:55 <kamilc>       arising from a use of `=~'
08:08:58 <edwardk> =)
08:09:54 <kamilc> i should also confess that i'm a newbe in haskell :)
08:11:24 <Saizan> > let (((:) x) xs) = undefined in () -- i wonder if the parse error here matches the standard or it's a bug+
08:11:24 <lambdabot>   <no location info>: Parse error in pattern
08:11:53 <edwardk> Prelude Text.Regex.Posix> "bar" =~ "(foo|bar)" :: String — works fine for me. what modules have you got imported into scope?
08:12:11 <kamilc> Prelude Text.Regex.TDFA Text.Regex>
08:12:23 <kamilc> thats my prompt in ghci
08:12:30 <edwardk> k
08:12:36 <kamilc> also i'm using OverloadedStrings
08:12:54 <edwardk> thats probably part of your pain
08:13:25 <edwardk> but the manual :: String's you gave above should fix _that_ sub-problem
08:13:37 <edwardk> installing tdfa now
08:13:41 <kamilc> Prelude Text.Regex.Posix> "foobar" =~ "foo" :: String
08:13:41 <kamilc> <interactive>:1:10:
08:13:41 <kamilc>     No instances for (RegexMaker Regex CompOption ExecOption [Char],
08:13:41 <kamilc>                       RegexContext Regex [Char] String)
08:13:41 <kamilc>       arising from a use of `=~'
08:14:29 <edwardk> Prelude Text.Regex.TDFA> "bar" =~ "(foo|bar)" :: String — worked trying with OverloadedStrings now
08:14:48 <edwardk> now i get your problem
08:14:52 <edwardk> okay, trying to fix
08:15:16 <edwardk> at which point Prelude Text.Regex.TDFA> ("bar" :: String) =~ ("(foo|bar)" :: String) :: String fixed it
08:15:37 <kamilc> edwardk - i would buy you a beer over standard tcp/ip if i could :)
08:15:52 <edwardk> did it work for you?
08:17:01 <kamilc> well..... no
08:17:03 <kamilc> Prelude Text.Regex.TDFA> ("bar" :: String) =~ ("(foo|bar)" :: String) :: String
08:17:03 <kamilc> <interactive>:1:19:
08:17:03 <kamilc>     No instances for (RegexMaker Regex CompOption ExecOption String,
08:17:03 <kamilc>                       RegexContext Regex String String)
08:17:03 <kamilc>       arising from a use of `=~'
08:17:05 <kamilc>     Possible fix:
08:17:06 <kamilc>       add instance declarations for
08:17:08 <kamilc>       (RegexMaker Regex CompOption ExecOption String,
08:17:10 <kamilc>        RegexContext Regex String String)
08:17:19 <edwardk> odd
08:17:37 <edwardk> what compiler version?
08:17:54 <kamilc> GHCi, version 7.0.3
08:18:31 <kamilc> regex-tdfa 'caballed' today
08:18:38 <edwardk> Prelude Text.Regex.TDFA> ("bar" :: String) =~ ("(foo|bar)" :: String) :: String   ====> "bar" — here on 7.0.2
08:18:49 <edwardk> and i just cabal installed it in response to your issue
08:20:10 <kamilc> wait.... oh.. i've just learned something
08:20:29 <edwardk> ?
08:20:46 <kamilc> i didn't realize that in ghci ( :module + MODULE ) is somewhat different from ( import MODULE )
08:20:58 <edwardk> the first instance is defined in Text.Regex.TDFA.String directly as written, so something is hinky
08:21:20 <kamilc> now that i imported Text.Regex.TDFA with :module + ..... it works
08:21:33 <edwardk>  =)
08:21:39 <kamilc> my newbe baby - steps :)
08:21:44 <edwardk> no worries
08:23:04 <kamilc> but now how do i get list of matches ? ( "dudududaadudu" =~ "du" :: [String] gives another type system error... )
08:23:16 <kamilc> Prelude Text.Regex.TDFA> "dudududaadudu" =~ "du" :: [String]
08:23:16 <kamilc> <interactive>:1:17:
08:23:16 <kamilc>     No instance for (RegexContext Regex [Char] [String])
08:23:16 <kamilc>       arising from a use of `=~'
08:23:36 <kamilc> that's without OverloadedStrings ( same for :: String work fine )
08:23:54 <Apocalisp> dolio: Hah. Did you get home alright?
08:23:57 <edwardk> have you seen http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/ ?
08:24:13 <edwardk> Apocalisp: he was on here jabbering at 3:30, so i'd hazard yes
08:24:35 <kamilc> yes
08:24:47 <kamilc> and "dudududaadudu" =~~ "du" :: [String] work fine
08:25:30 <kamilc> but returns only first match...
08:25:39 <edwardk> use =~
08:26:07 <kamilc> from abovementioned tutorial:
08:26:09 <kamilc> "foo foo foo" =~ "foo" :: [String]
08:26:09 <kamilc> <interactive>:1:15:
08:26:09 <kamilc>     No instance for (RegexContext Regex [Char] [String])
08:26:09 <kamilc>       arising from a use of `=~'
08:26:42 <edwardk> the tutorial is about 3 years old so be warned. the type checker has been swapped out wholesale in the meantime ;)
08:26:53 <kamilc> :)
08:27:33 <edwardk> they may have had to discard the instance that made that work
08:27:34 <edwardk> checking
08:29:38 <edwardk> > "foo foo foo" =~ "foo" :: [[String]]
08:29:38 <lambdabot>   [["foo"],["foo"],["foo"]]
08:29:42 <edwardk> =)
08:29:49 <edwardk> the instance is a little funny
08:29:59 <kamilc> :) nice - tyhat works
08:30:01 <edwardk> there is a instance RegexLike a b => RegexContext a b [[b]]
08:30:22 <edwardk> and the RegexLike instance that applies is RegexLike Regex String
08:30:34 <edwardk> so you need a list of lists of strings to get it to trigger
08:30:36 <kamilc> ohh.. now i see it
08:30:38 <edwardk> i'm guessing it collided
08:31:03 <kamilc> or i wll try RegexLike a b => RegexContext a b [MatchText b] with MatchText .....
08:31:14 <edwardk> can probably use one of the AllTextMatches constructors
08:31:21 <kamilc> anyway - thak you very much for your time
08:31:26 <edwardk> no problem
08:31:32 <kamilc> you help is priceless to me :)
08:31:46 <edwardk> keeps me awake
08:31:58 <edwardk> now i just need to find a way for folks to send those beers over tcp/ip ;)
08:32:14 <kamilc> hehehe
08:34:14 <edwardk> hah. the internet really does have such services apparently.
08:34:48 <edwardk> http://buddybeers.com/ http://yougotbeer.com etc
08:36:17 <dankna> of course, the person has to like beer
08:36:26 <edwardk> true
08:37:00 * hackagebot photoname 3.0.0 - Rename JPEG photo files based on shoot date  http://hackage.haskell.org/package/photoname-3.0.0 (DinoMorelli)
08:37:22 <Saizan> dankna: did you solve your space leak then?
08:37:44 <Saizan> ooi
08:38:04 <dankna> Saizan: no, I was just about to upload some stuff to presume upon people further regarding it, in fact :D
08:38:37 <dankna> I do thank you again for the help yesterday, it helped a lot - both the 10% space improvement we got, and the priceless getting me oriented with strictness annotations
08:39:16 <Saizan> np
08:39:43 <dankna> I did also define my own strict version of Maybe, which helped measurably though it wasn't a silver bullet
08:39:57 <dankna> http://dankna.com/himitsu/triangles.png
08:40:01 * hackagebot streams 0.7.0 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-0.7.0 (EdwardKmett)
08:40:03 <dankna> http://dankna.com/himitsu/emulator.prof
08:40:18 <dankna> let me change the filename on that to .txt, one sec
08:41:10 <dankna> http://dankna.com/himitsu/emulator.prof.txt
08:41:15 <Saizan> you could also try -hd, so that you can tell apart evaluated lists from closures, iirc
08:41:24 <dankna> http://nopaste.dk/p3278 -- code for Motherboard.NES.cycle, which is the biggest allocator
08:41:29 <dankna> good call, I'll do that
08:42:01 * hackagebot recursion-schemes 0.4.2 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-0.4.2 (EdwardKmett)
08:42:13 <dankna> "Generalized bananas" what O_o
08:42:27 <ClaudiusMaximus> dankna: those triangles look to me like a list is being built up and then reduced, instead of being deforested
08:42:42 <edwardk> dankna: just checking to see if anyone is paying attention
08:42:48 <dankna> haha
08:42:50 <dankna> well done then
08:42:56 <dankna> ClaudiusMaximus, if it helps I know what higher-level control event is correlated with the triangles
08:43:05 <edwardk> dankna: http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=F4E6E4708691C1F6FAA9672CFA6EE8E9?doi=10.1.1.41.125&rep=rep1&type=pdf
08:43:20 <edwardk> bananas lenses and barbed wire come from that paper
08:43:21 <monochrom> they forgot generalized envelopes
08:43:22 <dankna> cool, will read that later
08:43:49 <edwardk> i put a post up on catamorphisms (bananas) in google's knol back in the day, one sec.
08:43:54 <dankna> reminds me of that xkcd "VOLUNTEERS WANTED for a scientific study" ... below that in small print, "Investigating whether people can tell the difference between scientific studies and kidney-harvesting scams."
08:44:07 <edwardk> http://knol.google.com/k/catamorphisms#
08:44:22 <edwardk> it might be a little more accessible than that chapter from meijer's dissertation
08:44:28 <dankna> indeed
08:44:41 <dankna> looks worth the time to read, but not just at this moment
08:44:50 <edwardk> fair nuff =)
08:45:43 <Saizan> ah, yeah, "foldl' ... .. chipsToCycle" will have to produce the cons cells of chipsToCycle because foldl' is not a "good consumer", i.e. foldr/build fusion can't fuse that
08:45:51 <dankna> hmmm, I cannot test with -hd as it makes the nondeterministic crash in the profiler that I found be deterministic (every time).
08:46:00 <ClaudiusMaximus> dankna: i'd personally try to make it cycle !state = ... and make sure State is full of strictness, but not seeing the whole code i don't know if it'd work out (and i suspect the whole code is large)
08:46:30 <dankna> State is indeed full of strictness and the code is not large by some standards but it's a few thousand lines yes
08:46:52 <Saizan> dankna: how many times is Motherboard.NES.cycle called within a spike?
08:46:56 <dankna> I didn't realize (though it's self-evident now that you point it out) that I could make the function parameter strict like that, I'm going to try it
08:46:58 <dankna> about 22,000
08:47:14 <ClaudiusMaximus> dankna: needs {-# LANGUAGE BangPatterns #-}
08:47:15 <dankna> wait, I mean 66,000.  well, one of those.
08:47:21 <dankna> yeah, already have that flag :)
08:47:30 <ClaudiusMaximus> cool
08:48:53 <dankna> made the state parameters of the three cycle functions strict; trying again.  the compile will be a couple minutes.
08:50:58 <dankna> Saizan: while I'm waiting on that, I saw you discussing foldl' and this case yesterday, but I had to go, heh.  what was the outcome of that discussion - did you find anything similar that is a good consumer?  can you point me to a description of the "good consumer" criteria?
08:52:36 <dankna> hmm
08:52:53 <dankna> adding strictness caused a 20% decrease in how much Motherboard.NES.cycle allocates.  good!
08:53:11 <dankna> it's still the biggest allocator, though not by as much
08:54:12 <ClaudiusMaximus> profiling to optimize gets annoying when you have 10 things between 8% and 12% - so i guess it's ok to have a big target
08:54:13 <Pig-Roman> hi
08:54:17 <Pig-Roman> http://en.wikipedia.org/wiki/Context-free_grammar
08:54:20 <dankna> yeah
08:54:23 <Pig-Roman> on this page, what does the ":" symbol mean
08:54:28 <Saizan> dankna: i'm not a big expert in the field, but foldr/build fusion works by noticing that "foldr f z (build g) = g f z" so that everything implemented in terms of foldr and build can be simplified like that once inlining makes those applications apparent
08:54:40 <Saizan> ?type GHC.Exts.build
08:54:40 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
08:54:57 <Pig-Roman> : is set builder?
08:55:10 <dankna> Saizan: so if I change to using foldr instead of foldl', and reverse the order in which the list is generated, that would probably fuse?
08:55:14 <Saizan> dankna: foldl can be written as a foldr, but you end up building up closures to do so instead, so it's not a win
08:55:26 <dankna> hmm
08:55:48 <dankna> Pig-Roman, where on that page specifically?
08:56:00 <Pig-Roman> everywhere
08:56:01 <ClaudiusMaximus> Pig-Roman: seems a bit overloaded in the equations there, i'd pronounce it "such that" or "where" probably
08:56:01 <Saizan> dankna: i think so, i think you'll end up using some stack, though your list is very small..
08:56:05 <edwardk> dankna: you may also want to read the papers on stream fusion, which is modified unfoldr/destroy fusion they make a good case for why that can be optimized better
08:56:12 <dankna> yeah, very small indeed :)
08:56:30 <dankna> edwardk, ah - yes.  sounds like I should.
08:56:46 <jmcarthur> stream fusion is quite beautiful, too, IMO
08:56:52 <Pig-Roman> http://bit.ly/mIMr5N
08:56:57 <Pig-Roman> this picture of the : symbol
08:56:59 <Pig-Roman> what does it mean there
08:57:29 <Saizan> btw, how could the strictness analyzer not realize cycle is strict in the state argument?
08:57:40 <monochrom> the ":" there is just separator, so you can read better
08:58:00 <monochrom> some people would use "." for it, indeed:
08:58:03 <monochrom> @type id
08:58:04 <lambdabot> forall a. a -> a
08:58:13 <monochrom> lambdabot likes to use "." for it
08:58:22 <dankna> Saizan:  I have no idea.  I'm new to having to actually worry about strictness analysis :)
08:58:56 <dankna> Pig-Roman, in that picture, it just separates the left hand of the quantification from the right hand
08:59:14 <dankna> do you understand the for-all and there-exists notation in general?
08:59:22 <dankna> (upside-down-A and upside-down-E)
09:00:19 <doserj> upside-down E is just E
09:00:23 <dankna> Saizan: I'm also not against just adding strictness annotations for readability's sake, even if they express things that the compiler would infer on its own.  Besides, doing so might bring my compile times down. :)
09:00:33 <dankna> doserj: depends on whether you flip it or rotate it
09:00:55 <doserj> ah :)
09:01:11 <Saizan> dankna: yeah, not having to depend on not so predictable optimizations is also nice
09:01:17 <dankna> yeah, exactly so
09:01:41 <Saizan> dankna: though now i wonder if it'd be worth to add bangs to all the let bindings too
09:02:30 <dankna> I tried a bunch of that and had to back it out because it made things worse, but I didn't try doing it in just that function
09:02:41 <Saizan> ah, ok
09:02:46 <dankna> I had done it a little indiscriminately; edwardk helped me a little earlier in understanding when I shouldn't do it
09:05:08 <Saizan> i.e. not when the value might not be needed?
09:05:30 <dankna> yes, that was what he explained, haha
09:05:35 <cinch> > ['w','o'] ++ ['o','t']
09:05:36 <lambdabot>   "woot"
09:05:40 <dankna> lol
09:06:51 <dankna> hmm
09:07:19 <ClaudiusMaximus> Saizan: i guess the strictness analyzer would have to know that PPU.cycle is strict, and that "if ... then strictFunctionOf state else state" might as well be strict?
09:07:26 <dankna> my fusion must not be working quite right, it's still allocating more than the version I don't like
09:08:05 <dankna> I do have output from -hd now if you want to see it (must have changed things enough that I no longer trigger the crash)
09:08:16 <dankna> (disturbing how the crash is metastable like this)
09:08:34 <dankna> (the crash in question is http://hackage.haskell.org/trac/ghc/ticket/5177 btw)
09:08:45 <Saizan> ClaudiusMaximus: the if on cyclePPU should force clockCount, which should force state
09:09:31 <ClaudiusMaximus> Saizan: ah true
09:11:29 <Saizan> dankna: yep, let's see -hd
09:12:50 <dankna> http://dankna.com/himitsu/colorful.png -- the run that gave this was using foldr in Motherboard.NES.cycle
09:13:28 <dankna> you can't see it on that graph, but the other report says the total allocation was consequentially 200M higher
09:13:58 <cinch> > 0.7 + 0.2
09:13:59 <lambdabot>   0.8999999999999999
09:14:14 <mauke> > 0.7 + 0.2 :: Rational
09:14:15 <lambdabot>   9 % 10
09:14:43 <cinch> o.o
09:15:22 <dankna> on an unrelated note, how much interest would there be in a library that stores real numbers by the parameters of an infinite series that converges to them?
09:15:38 <dankna> it's not immediately clear that there exist efficient algorithms to do basic computations on such numbers, but it would be an interesting challenge to find out
09:15:51 <dankna> > pi == (pi * 2) / 2
09:15:52 <lambdabot>   True
09:15:57 <dankna> > pi == (pi * 3) / 3
09:15:57 <lambdabot>   True
09:16:02 <dankna> > pi == (pi * 3.0) / 3.0
09:16:03 <lambdabot>   True
09:16:07 <dankna> > pi == (pi * 1.1) / 1.1
09:16:08 <lambdabot>   True
09:16:15 <flux> hah, foiled :)
09:16:21 <dankna> > pi == (pi * (0.7 + 0.2) / 0.9
09:16:21 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:16:26 <dankna> > pi == (pi * (0.7 + 0.2)) / 0.9
09:16:27 <lambdabot>   False
09:16:30 <dankna> there we go :D
09:16:38 <dankna> it would let that expression evaluate to True, for example :D
09:17:09 <Saizan> mh, aside from the legal-emulator-* stuff they are all constructors
09:17:20 <dankna> (Legal Emulator is, obviously, the name of the program)
09:17:24 <dankna> (it's called that because it is one)
09:17:49 <mauke> > pi == (pi * (0.7 + 0.2)) / 0.9 :: CReal
09:17:49 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
09:17:49 <lambdabot>         against infe...
09:18:03 <mauke> > pi == (pi * (0.7 + 0.2)) / (0.9 :: CReal)
09:18:04 <lambdabot>   True
09:18:08 <dankna> huh.
09:18:20 <dankna> but that's working due to a quirk in the mantissa size of CReal :)
09:18:35 <dankna> > 0.2 + 0.2 :: CReal
09:18:36 <lambdabot>   0.4
09:18:36 <Saizan> i'd suspect some of those closures are lists though, since you've quite little of (:)
09:18:46 <dankna> > 0.7 + 0.2 :: CReal
09:18:47 <lambdabot>   0.9
09:18:56 <aristid> dankna: because (==) even for CReal is not precise?
09:19:12 <dankna> aristid: if CReal is a floating-point format, which I assume it is?  then yes, it's not precise
09:19:37 <dankna> @hoogle CReal
09:19:37 <lambdabot> No results found
09:19:40 <dankna> @google CReal
09:19:41 <lambdabot> http://www.creal.cat/en_index.html
09:19:42 <lambdabot> Title: Home - CREAL
09:19:43 <Saizan> no, CReal isn't
09:19:57 <aristid> dankna: don't assume, man!
09:19:59 <dankna> oh constructive real numbers, cool!
09:20:02 <dankna> http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/Data-Number-CReal.html
09:20:06 <ClaudiusMaximus> > bitSize (0::CReal)
09:20:06 <dankna> didn't know we had that
09:20:07 <lambdabot>   No instance for (Data.Bits.Bits Data.Number.CReal.CReal)
09:20:07 <lambdabot>    arising from a ...
09:20:17 <ClaudiusMaximus> oops, wrong thing
09:20:18 <Saizan> they are quite slow, unfortunately
09:20:32 <dankna> how does it represent things?
09:20:36 <Pig-Roman> cmny.east.verizon.net) has joined #math
09:20:36 <Pig-Roman> * mithridates (~mithridat@142.167.224.95) has joi
09:20:38 <Pig-Roman> oops
09:20:38 <Pig-Roman> Fuck
09:20:45 <Pig-Roman> whats this symbol
09:20:50 <Pig-Roman> ¬
09:21:01 <ClaudiusMaximus> > floatDigits (0::CReal)
09:21:01 <lambdabot>   *Exception: CReal.floatDigits
09:21:05 <dankna> that symbol is unary postfix logical negation, colloqually called "NOT"
09:21:06 <mauke> > showCReal 200 pi
09:21:06 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
09:21:24 <Pig-Roman> ok THANKS
09:21:53 <ClaudiusMaximus> > decodeFloat (42 :: CReal)
09:21:54 <lambdabot>   *Exception: CReal.decodeFloat
09:22:03 <ClaudiusMaximus> useful instance there then...
09:22:06 <mauke> U+00AC (c2 ac): NOT SIGN [¬]
09:22:19 <Pig-Roman> How do I say this in english
09:22:21 <Pig-Roman> http://bit.ly/lXeYr1
09:22:22 <dankna> "This implementation is really David Lester's ERA package." ( http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/Data-Number-CReal.html ) -- Google can't find anything about David Lester or his ERA pacakge
09:22:27 <Pig-Roman> No cycles rule, which is... there does not exist N an element of V, where N yields N
09:22:31 <Pig-Roman> the : is "where" ?
09:22:47 <dankna> I would say "such that" for the :
09:22:52 <dankna> but "where" is also correct
09:23:45 <dankna> hmmmmm
09:24:09 <dankna> looking at the source to the numbers package, his representation is data CReal = CR (Int -> Integer)
09:24:16 <dankna> function taking precision required and returning digits
09:24:27 <dankna> as he says, it's impossible to compare these in the general case
09:24:50 <dankna> the representation I'm thinking of would definitely enable comparison, although I'm not sure it would enable every operation we tend to expect
09:25:01 <dankna> anyway :) back to my profiling :)
09:32:23 <dankna> hmm
09:32:45 <dankna> it may be that I can do the fusing manually.  the resulting code is not that bad-looking (certainly preferable to my eye to the unrolled version)
09:32:56 <dankna> but I'm not sure it's actually more efficient.  testing now.
09:40:58 <haskellnoob> I want to write a program which goes over an input list while updating its state. The state (currently) consists of a couple of lists and a couple of Ints. Each element in the input list might warrant a change in the state. What is a good way to do this? I was thinking of using map together with an accumulator. Is this fine?
09:41:44 <rtharper> haskellnoob: or an unfold?
09:41:50 <mauke> mapM?
09:41:59 <Botje> this just screams "state monad" :)
09:42:03 <haskellnoob> rtharper, mauke: thank you, let me look at those
09:42:06 <mauke> mapM_ actually
09:42:20 <rtharper> mauke: depends on what he wants at the end, I guess
09:42:22 <Botje> but you can get by with a fold, probably
09:42:42 <dankna> http://nopaste.dk/p3281 -- new version of the function I'm worrying about.  it does allocate a bit more than the commented-out version, but I suspect that if the overall space leak were solved, the performance penalty would be acceptable.
09:42:47 <haskellnoob> Botje: thank you, i am a bit scared of monads, maybe this is finally it :)
09:43:22 <merijn> haskellnoob: Pfft, monads are easy as long as you just ignore all the idiot guides on the web :p
09:43:45 <haskellnoob> merijn: could you point me to a non-idiot guide to the state monad? :D
09:43:56 <merijn> @where lyah
09:43:56 <lambdabot> http://www.learnyouahaskell.com/
09:43:58 <haskellnoob> or even a simple example of its use would be good
09:44:07 <dankna> ooh ooh.  "An analogy is like a sandwich in that I'm making one now."
09:44:29 <merijn> The examples of the Maybe and List monad in LYAH are simple and clear IMO
09:44:53 <haskellnoob> merijn: thank you. i hope i will be able to use the State monad after looking at those
09:45:04 <merijn> It also has one on the State monad, I think
09:45:29 <merijn> But I still recommend going over the Maybe/List ones first, because they're really easy and make you go "That's all?!"
09:45:43 <haskellnoob> ok, i will look at that now, and come back if i have more doubts. thanks to you all
09:45:51 <Eduard_Munteanu> dankna: hrm, so the list in there is causing problems. Did you see what dolio said about profiling interfering with optimizations?
09:46:22 <dankna> Eduard_Munteanu: I did not, no.  I am not sure how to measure such an effect though!
09:46:36 <dankna> If there were no space leak, I could run my program for a few minutes and compare how far it gets with and without profiling
09:46:44 <dankna> but since there is, I suspect there is not enough RAM in the universe
09:47:10 <dankna> indeed each of these spikes that you see allocating 200M and taking half a second is supposed to take a 60th of a second :)
09:47:11 <Eduard_Munteanu> dankna: not how far, but you could use -s or -sstderr to see heap statistics
09:47:23 <dankna> good call, okay
09:47:45 <Eduard_Munteanu> (recompiling with profiling flags beforehand)
09:47:45 <Lemmih> dankna: Where's the space leak?
09:48:18 <harad> uh, hey, just a quick question, do I must subscribe to libraries@haskell.org in order to post a question there?
09:48:21 <dankna> Lemmih: http://dankna.com/himitsu/emulator.prof.txt http://dankna.com/himitsu/triangles.png
09:48:43 <dankna> Eduard_Munteanu, okay.  I'm working on running it with -s both with and without profiling, then.
09:48:52 <dankna> (nontrivial as it runs as a library)
09:49:02 <dankna> (but I know how)
09:49:08 <harad> they just rejected the mail I sent there, but nothings is said of why...
09:49:39 <Lemmih> dankna: Is the entire code + input available?
09:50:37 <dankna> if you really want it, but it's 4,000 lines.  because I'm making changes rapidly as people make suggestions, it might make more sense for me to post pieces that you're specifically interested in.
09:51:08 <Lemmih> dankna: I'd like to see the State structure.
09:51:12 <dankna> sure thing
09:51:37 <Lemmih> And sub-structures.
09:51:49 <dankna> right
09:51:51 <dankna> prepping that paste now
09:52:39 <dankna> http://nopaste.dk/p3282
09:56:34 <Lemmih> dankna: Marking a list as strict doesn't really do anything.
09:57:12 <dankna> Lemmih: yeah, I'm aware.  you referring to the ![MicrocodeInstruction] ?
09:57:41 <dankna> by the way, Lemmih, you should be aware that that's not the standard Maybe, it's my own strict-maybe type, following Eduard_Munteanu's suggestion from yesterday
09:57:56 <gwern> 'The GCJ submission took me about two hours. Half of it to find a satisfying way to implement XOR, most of the rest trying to make sense of in which context the "IM IN YR LOOPZ NERFIN YR VAHR" could be of any use with LOLCODE's enforced lexical scope. (and I didn't find any—but maybe I was unlucky when I selected an interpreter)' lol
09:58:03 <Eduard_Munteanu> Not my suggestion :).
09:58:16 <dankna> oh, well it was somebody's :)
09:58:21 <Eduard_Munteanu> But a sensible one anyway.
09:58:24 * dankna nods
09:58:53 <NemesisD> could someone explain the use case of MonadIO
09:59:16 <Lemmih> dankna: Yes, I was referring to ![MicrocodeInstruction]. Do you use immutable arrays to represent mutable memory?
09:59:59 <Lemmih> NemesisD: Monads layered on top of IO can also do IO.
10:00:00 <dankna> I do, yes, but the space taken up by those arrays is the tiny sliver at the bottom of the heap profile, and none of the functions that allocate them are on the top page of the profile report either by time or by allocation
10:00:10 <jmcarthur> NemesisD: when IO is at the bottom of a transformer stack, liftIO makes it convenient to lift any IO action not matter how deep the stack is
10:00:14 <Saizan> will immutable unboxed arrays show up in the heap profiling, btw?
10:00:31 <dankna> I have a good architectural reason for using immutable arrays there, namely I want to add support eventually for saving snapshots of the machine's prior state and backing up to them
10:01:10 <gwern> NemesisD: it may be helpful to look at monadio users like xmonad or gitit
10:01:11 * Saizan has some doubts on that since they aren't traversed by the GC
10:01:34 <dankna> aren't they the ARR_WORDS sliver on my -hy report?
10:01:49 <gwern> NemesisD: I think there is also a neat set of emails on -cafe which show how you can use monadio to interface with a game and plug in a live player, an AI player, quickcheck input or hunit
10:01:53 <dankna> I certainly don't have any mutable arrays anywhere in my code, although maybe ByteString or something is using some
10:01:58 <gwern> (but I may be confusing that with something else)
10:02:08 <Saizan> dankna: i guess so
10:02:12 * dankna nods
10:02:58 <NemesisD> jmcarthur: hmmm. perhaps i don't need it then. i'm writing a library that wraps an internet api. i was basing it off of hs-twitter, which defines the main twitter monad as newtype TM = TM { unTM :: TMEnv -> IO a }. i'm trying to figure out the purpose of this
10:03:29 <dankna> still working by the way on the test of stuff without profiling
10:03:38 <Lemmih> dankna: Any space leak gotta be caused by the lists. There isn't really anywhere else they can hide in that data-type.
10:03:39 <jmcarthur> NemesisD: is TM an instance of MonadIO?
10:03:53 <dankna> Lemmih: hmm.  glad to hear you say that, I was doubting my sanity.
10:04:25 <dankna> the [MicrocodeInstruction] is generated by a function decodeOperation :: Word8 -> [MicrocodeInstruction]
10:04:37 <NemesisD> jmcarthur: oddly enough, no, but the module in which it defines defines liftIO anyways as: liftIO :: IO a -> TM a   liftIO a = TM $ \ _ -> a
10:04:46 <dankna> which I'm somewhat distressed that I see that function showing up on the time profile /at all/ since I'd much rather it be a compile-time-computed lookup table
10:04:47 <NemesisD> so it could be a coincidence
10:05:16 <Lemmih> dankna: Then make it use a lookup table.
10:05:49 <NemesisD> im pretty new to haskell, my theory is that TM lets you compose a bunch of twitter actions and defer the IO calls until you call unTM and pass in the env that has your api key and whatnot
10:06:28 <dankna> well, there's substantial overlap between the cases, which is why I wrote it the way I did; I could do something like compute a Map Word8 [MicrocodeInstruciton] from it, but wouldn't the resulting map get computed at runtime instead of compile-time?
10:07:15 <jmcarthur> NemesisD: oh it can't be an instance of MonadIO because it doesn't have a type parameter
10:07:18 <Lemmih> dankna: Yeah, but only once.
10:07:24 <jmcarthur> NemesisD: it's not even a monad
10:07:38 <dankna> Lemmih: oh!  okay
10:07:45 <Lemmih> dankna: How many instructions can be packed in a Word8?
10:07:56 <jmcarthur> looks like TM is intended to just give you a language to compose some stuff and get an IO action from it
10:08:12 <NemesisD> jmcarthur: it does, i thin, i mistyped: newtype TM a = TM { unTM :: TMEnv -> IO a }, the a would be the type parameter
10:08:18 <dankna> one Word8 opcode is a sequence of up to 8 microcode instructions
10:08:18 <jmcarthur> ah
10:08:42 <jmcarthur> NemesisD: for the record, that is equivalent to     newtype TM a = TM { unTM :: ReaderT TMEnv IO a }
10:09:01 <jmcarthur> NemesisD: maybe a different way of looking at it can help you :)
10:09:42 <NemesisD> jmcarthur: so instead of unTM i'd use runReaderT myEnv ?
10:10:14 <Lemmih> dankna: Using an array would be better than a map, btw.
10:10:17 <jmcarthur> NemesisD: well, you'd need to use either unTM or pattern matching to get the newtype wrapper out of the way, but yeah
10:10:30 <jmcarthur> :t runReaderT
10:10:31 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
10:10:48 <jmcarthur> NemesisD: it might look something like     runReaderT (unTM m) env
10:11:30 <NemesisD> jmcarthur: i see. and in the existing implementation it would be like: unTM env right?
10:11:35 <jmcarthur> yes
10:11:39 <jmcarthur> no
10:11:42 <jmcarthur> unTM m env
10:12:12 <NemesisD> ah and m is the TM i've been composing and such?
10:12:16 <jmcarthur> yes
10:12:25 <Lemmih> dankna: That's the same paste as before.
10:12:28 <NemesisD> cool, i think i'm starting to understand the value of doing it this way
10:12:32 <dankna> oh, whoops?
10:12:52 <dankna> I didn't paste anything just now?
10:12:55 <Lemmih> dankna: That's the same paste as before.
10:13:03 <Lemmih> Oops.
10:13:11 <dankna> were you scrolled up haha
10:13:13 <Lemmih> My bad. sorry. /-:
10:13:16 <dankna> np :)
10:13:30 <dankna> yes, I'll use an array.  not least because then I don't have to depend on the containers package.
10:14:03 <bqf> is there some way to make hugs or ghci print "what it is doing", i.e. print after every function application / print after every substitution? i'm struggling with some code where i could really use a feature like that, pen+paper is not really getting me anywhere this time ;)
10:14:20 <monochrom> not easily
10:14:50 <Eduard_Munteanu> There is something about stepping like in gdb, but you don't really want to do that.
10:14:51 <NemesisD> thanks jmcarthur
10:14:51 <jmcarthur> bqf: ghci can be used as a debugger like that, but it's not as informative as it sounds
10:14:56 <Botje> bqf: import Debug.Trace
10:14:57 <Eduard_Munteanu> Use Debug.Trace
10:15:08 <Botje> and stick something like this at the top of your functions:
10:15:14 <monochrom> ghci has some "debugging" facility, see if it helps: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
10:15:32 <Botje> foo x y z | trace ("foo: " ++ show (x,y,z)) False = undefined
10:15:37 <monochrom> and yeah, annotating with Debug.Trace.trace helps
10:15:38 <dankna> also, cf. http://twitter.com/#!/siegel/status/60348258706403328
10:15:49 <dankna> (sorry - couldn't resist)
10:15:51 <bqf> ok, thanks for all your answers, i'll check it out
10:16:00 <monochrom> hahaha
10:16:03 <dankna> :D
10:16:50 <mauke> http://mauke.dyndns.org/stuff/lisp/implinest.lisp - pararelated
10:17:13 <dankna> ha
10:17:21 <dankna> wow, that's horrible Lisp formatting style :)
10:17:26 <dankna> put them at the ends of lines!!!!
10:17:40 <mauke> don't worry, after you've used lisp for a week or two, you won't even see the ) anymore
10:17:48 <dankna> I know.  I used CL for five years.
10:17:49 <mauke> or so I hear
10:18:00 <dankna> but I format it like ))))))))
10:18:08 <mauke> doesn't keep lispers from complaining about the ) for some reason
10:18:13 * dankna nods
10:18:36 <mauke> well, guess what this code does
10:18:38 <dankna> saw a joke once along the lines of "I hacked into the government's computers and stole their top-secret AI project.  as proof, here are the last hundred lines of the source code:"
10:18:39 <MatrixFrog> pro haskellers use . and $ so they can use very few parens
10:18:44 <dankna> and it's just 100 lines of )
10:18:47 <MatrixFrog> so it balances out
10:19:07 <dankna> well, it's setting up a read-time macro character...
10:19:14 <dankna> #$
10:20:35 <Eduard_Munteanu> Well, that bit about Lisp is interesting, it goes to say what happens when you don't have syntax at all :)
10:20:37 <dankna> reads a multiple-line thing including comments with the ; character and terminated by the next $
10:20:53 <jmcarthur> mauke: "don't worry, after you've used lisp for a week or two, you won't even see the ) anymore"  <-- all i see is blonde, brunette, redhead...
10:20:53 <KirinDave> Eduard_Munteanu: I heard someone describe Lisp as "void style"
10:21:03 <KirinDave> Eduard_Munteanu: Contrasted to ML and Haskell which were "heaven style"
10:21:13 <KirinDave> I rather liked that metaphor. But i love old kung fu movies.
10:21:24 <Eduard_Munteanu> Heh.
10:21:25 <dankna> the contents of the delimited section are a list of Lisp forms, each of which has a helper function called on it...
10:21:46 <Eduard_Munteanu> Well I still think ML is a bit ugly, I struggle to read ML stuff in papers
10:21:54 <KirinDave> Eduard_Munteanu: I think its the approach
10:22:01 <jmcarthur> i hate ML type signatures, mainly
10:22:04 <mauke> http://mauke.dyndns.org/stuff/lisp/add-x.lisp - see it in action
10:22:18 <dankna> they're in the format ((place value) ...) and what happens is that ... is evaluated in a context where the setf place "place" is set to "value", and then it is set back to what it was when the code block exits
10:22:27 <dankna> I'm at a loss for why you'd want this, but that's what it does
10:22:27 <KirinDave> Eduard_Munteanu: He had a style for every language. It was like tom haverfoods for computer languages.
10:23:26 <dankna> hmm
10:23:29 <mauke> dankna: temp is a local macro
10:23:33 <dankna> I don't understand add-x.lisp
10:23:42 <dankna> yes, I see where temp is used
10:23:47 <mauke> http://mauke.dyndns.org/stuff/lisp/add-2.lisp
10:23:49 <dankna> oh
10:23:52 <KirinDave> Waaiiiit
10:23:57 <dankna> right okay, local macro.  only used for keeping track of recursive-p
10:24:03 <KirinDave> Is #$ a symbol macro in the spirit of haskell's $?
10:24:14 <dankna> it's not a symbol macro, it's a reader macro
10:24:19 <KirinDave> sorry, reader macro
10:24:32 <dankna> ah - so this is what it expands to?
10:24:32 <KirinDave> Been awhile since I used alisp that let me do that.
10:25:04 <mauke> dankna: well, this is the original code
10:25:09 <dankna> gotcha
10:25:16 <mauke> almost
10:25:23 <dankna> the thing about Lisp is that it obfuscates /beautifully/
10:25:27 <mauke> it started out as http://mauke.dyndns.org/stuff/lisp/add.lisp
10:26:03 <dankna> yeah, I'm not going to try to read the actual behavior of it, but I assume it's something clever with using S- and K- combinators to implement Peano arithmetic or something
10:26:11 <mauke> nah
10:26:23 <mauke> much simpler
10:26:34 <mauke> original version: http://mauke.dyndns.org/stuff/perl/add.pl
10:26:40 <dankna> lol
10:26:48 <KirinDave> Man
10:26:52 <KirinDave> Angels are weeping.
10:26:59 <KirinDave> Do you wanna see some angels weeping?
10:27:05 <mauke> it adds two numbers using bitwise operations
10:27:09 <dankna> I can read the Lisp version better than I can read the Perl version, haha
10:27:12 <mauke> in a loop
10:27:19 <dankna> oh hey!  xor and and, yes, I see them
10:27:28 <mauke> the loop is now recursion
10:27:35 <mauke> the recursion is now the Y combinator
10:27:45 <mauke> all functions are curried
10:27:47 <KirinDave> So I wrote this text adventure game engine as a way to learn me some more haskell: https://github.com/KirinDave/Rag
10:27:56 <mauke> all functions use CPS
10:27:59 <KirinDave> And a guy I know was like, "I will use this as a chance to branch out and learn me some python"
10:28:05 <KirinDave> So he made a python version
10:28:06 <mauke> every function call is a manual tail call
10:28:09 <KirinDave> https://gist.github.com/960396
10:28:14 <mauke> and we're done. simple.
10:28:17 <KirinDave> That code is nightmare.py
10:28:28 <HugoDaniel> hi
10:28:38 <bqf> Botje (and everyone else who answered): thanks again, through looking up Debug.Trace i also found Hugs.Observe which looks interesting as well :)
10:28:46 <merijn> KirinDave: That's awful python code :(
10:28:55 <Botje> ah, cool :)
10:28:56 <olsner> oh wow, a hashbang with a windows path in it
10:29:00 <KirinDave> merijn: Well to be fair its his first python program.
10:29:02 <KirinDave> But yeah.
10:29:14 <adnam> mauke: was that supposed to sound like the old spice commercial? :-D
10:29:39 <merijn> I read that in the voice of Cave Johnson "And we're done here"
10:30:40 <dankna> OKAY
10:30:45 <dankna> I was able to run the no-profile test
10:30:47 <cheater93> olsner, wtf??
10:31:13 <dankna> http://dankna.com/himitsu/profile.txt
10:31:15 <dankna> http://dankna.com/himitsu/no-profile.txt
10:31:20 <merijn> olsner: Apache sometimes behaves odd when scripts have no hashbang on Windows
10:31:23 <dankna> as you can see, profiling does indeed roughly double the memory usage
10:31:42 <dankna> but a factor of two is not really that big a deal compared to, you know, the factor of two million compared to what I expect to see :)
10:31:45 <merijn> Can't think of another hashbang reason on Windows
10:31:58 <olsner> merijn: Apache sometimes behaves odd [...] on Windows :P FTFY
10:32:18 <merijn> s/on Windows//
10:32:41 <dankna> (well, two thousand, at least.  not two million.)
10:33:34 <mauke> > let add x y | x /= 0 && y /= 0 = add ((x .&. y) `shiftL` 1) (x `xor` y) | otherwise = x `xor` y in add 2 2
10:33:34 <lambdabot>   Ambiguous type variable `a' in the constraint:
10:33:34 <lambdabot>    `Data.Bits.Bits a'
10:33:34 <lambdabot>      a...
10:33:45 <mauke> > let add x y | x /= 0 && y /= 0 = add ((x .&. y) `shiftL` 1) (x `xor` y) | otherwise = x `xor` y :: Integer in add 2 2
10:33:45 <lambdabot>   4
10:33:49 <mauke> there we go
10:35:11 <mauke> > iterate (\(x, y) -> ((x .&. y) `shiftL` 1, x `xor` y)) (2, 2)
10:35:12 <lambdabot>   Ambiguous type variable `t' in the constraint:
10:35:12 <lambdabot>    `Data.Bits.Bits t'
10:35:12 <lambdabot>      a...
10:35:17 <mauke> > iterate (\(x, y) -> ((x .&. y) `shiftL` 1, x `xor` y :: Integer)) (2, 2)
10:35:18 <lambdabot>   [(2,2),(4,0),(0,4),(0,4),(0,4),(0,4),(0,4),(0,4),(0,4),(0,4),(0,4),(0,4),(0...
10:35:34 <mauke> > iterate (\(x, y) -> ((x .&. y) `shiftL` 1, x `xor` y :: Integer)) (437812, 2239121)
10:35:34 <lambdabot>   [(437812,2239121),(283680,2393253),(526400,2150533),(0,2676933),(0,2676933)...
10:40:10 <Eduard_Munteanu> dankna: in my case it wasn't just instrumentation but profiling prevented some rewrite rules from firing.
10:41:18 <dankna> hmm, I see.  well, if that's happening in my case I see no evidence of it, although I'm not sure how I would.
10:41:22 <Eduard_Munteanu> dankna: is the no-profiling version compiled without profiling flags?
10:41:38 <Eduard_Munteanu> or it's just missing -p?
10:41:51 <Eduard_Munteanu> (or -hd)
10:42:01 <dankna> it's compiled and linked without profiling flags
10:42:11 <dankna> I am well aware of the _p.a versions of the libraries, since I have to do my own linking :(
10:42:30 <dankna> (or rather, I have to manually feed the appropriate arguments to clang, which does the linking.)
10:42:49 <dankna> well, I don't /have/ to but it's the simplest way for my situation.  anyway.
10:44:05 <Eduard_Munteanu> Hm, an awful lot of GC work... Productivity  32.0% of total user, 6.5% of total elapsed
10:44:22 <dankna> yeah.
10:44:40 <dankna> well, in principle, only the final state of the simulator is non-garbage
10:44:46 <dankna> so I do expect to see a lot of memory churn
10:44:53 <dankna> but not /this/ much, and not these particular constructors
10:45:10 <Eduard_Munteanu> You could try passing -H64m or something like that, might reduce GC substantially, but I'm unsure it's the right fix.
10:45:27 <dankna> hmm
10:45:30 <Eduard_Munteanu> (or even bigger -H)
10:46:13 <Eduard_Munteanu> The spikes will be bigger but fewer GC overall.
10:46:38 <dankna> it's really the wrong fix
10:46:50 <dankna> it consumes way too much memory, period
10:47:38 <dankna> the spikes /show/ as 60M in the heap profile, but that's somehow an inaccurate view, because it actually allocates about 400M
10:47:51 <dankna> which is just unacceptable, I can't even consider releasing like this
10:48:09 <dankna> (the text file shows the correct figure)
10:49:02 <dankna> hmm
10:49:03 <dankna> cool
10:49:17 <dankna> I implemented lookup arrays for the two opcode-decoding functions and they no longer appear as hot spots
10:49:29 <dankna> nor does MicrocodeInstruction appear on the heap profile
10:51:16 * hackagebot system-fileio 0.1.1 - High-level filesystem interaction  http://hackage.haskell.org/package/system-fileio-0.1.1 (JohnMillikin)
10:52:05 <Eduard_Munteanu> dankna: have you tried inlining 'cycle'? Not sure it works across module boundaries though, but it might, after all it's not your usual C compiler :)
10:52:35 <dankna> it supposedly can, yes.  how do I know whether it's already doing that, haha?
10:53:01 <Lemmih> dankna: Is 70M maximum residency really that bad?
10:53:03 <Saizan> you could look at the code, or at the .hi file to see if the unfolding is exported
10:53:20 <Saizan> *core
10:53:47 <Saizan> ghc --show-iface foo.hi will print the info in the .hi file in a readable form
10:53:53 <dankna> Lemmih: it's more like unbounded maximum residency as measured by top (well, Activity Monitor.app) - the heap profile doesn't reflect the reality
10:54:35 <jonkri> the Maybe monad is the most simple one, right?
10:54:36 <dankna> and also, I believe that the vast amount of unnecessary allocation is why I'm not getting the speed performance I want
10:54:43 <mauke> jonkri: no, Identity
10:54:54 <Saizan> though if the heap profile doesn't reflect the reality maybe it's not a good hint on what to optimize either?
10:55:00 <Lemmih> dankna: I very much doubt it.
10:55:13 <merijn> jonkri: Yes
10:55:18 <Saizan> well, GC does use more memory than the size of the heap
10:55:21 <Eduard_Munteanu> Lemmih: his time is mostly spent doing GC
10:55:34 <Lemmih> dankna: Looking at the -s output, you only spend 1.22s out of 6.05s in Haskell land.
10:55:39 <Lemmih> Eduard_Munteanu: No, it is not.
10:55:40 <Eduard_Munteanu> Twice as much as useful work.
10:55:50 <dankna> Lemmih: yes, I spent the other 5s blocking for input
10:56:03 <dankna> Lemmih: I'm running as a library, so Haskell can't account for that time, but it was blocked
10:56:34 <jonkri> mauke: ah, thanks. i'm writing a (yet another) monad tutorial, and i think the Maybe monad is better to illustrate the concept :)
10:56:50 <dankna> the non-Haskell portion of the program is quite trivial
10:57:23 <Lemmih> dankna: I'd suggest giving it more work. It can be hard to get useful data when it only runs for a second.
10:57:28 <Eduard_Munteanu> jonkri: yeah, though Identity is nice too, if you want to show some easy imperative code
10:57:51 <jonkri> Eduard_Munteanu: aha, will experiment a bit with it :)
10:57:52 * Eduard_Munteanu nods
10:57:53 <dankna> Lemmih: yeah, I was running for only two major iterations at first because any more exhausted my 8G of phyiscal memory, it might be time to up that a bit
10:58:22 <merijn> According to my twitter feed, "luqui: Haskell is a DSL for writing monad tutorials." :p
10:58:28 <dankna> cute
10:58:31 <companion_cube> :D
10:58:33 <merijn> @quote luqui monad.tutorial
10:58:33 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
10:59:01 <merijn> @remember luqui Haskell is a DSL for writing monad tutorials.
10:59:01 <lambdabot> Nice!
10:59:05 <dankna> the simulation also crashes the simulator a few more major iterations in, so it's hard to give it more work, heh
10:59:08 <mauke> preflex: quote . robots
10:59:09 <preflex>  <duqicnk> a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
10:59:11 <Twey> Haha
10:59:22 <dylukes> Hey, does anyone here know how a O_NONBLOCK socket return failure on connect()?
10:59:25 <dankna> I had never noticed until earlier today because I wasn't efficient enough to ever get to that point
10:59:26 <dmwit> Time is made of tiny chocolate robots??!
11:00:01 <Lemmih> dylukes: EAGAIN?
11:00:10 <dylukes> no, connect() is EALREADY
11:00:19 <dylukes> and I don't mean in place of blocking.
11:00:23 <dylukes> I mean, if it just can't connect.
11:00:30 <dylukes> as in, the host doesn't exist
11:00:34 <mauke> dylukes: man 2 connect
11:00:51 <Lemmih> dylukes: ECONNREFUSED?
11:01:25 <merijn> EMIGHTWANTTOREADMANPAGE
11:01:25 <dylukes> not refusal necessarily, just failure.
11:01:29 <Eduard_Munteanu> :)
11:01:31 <dylukes> I guess I could check for any error except EALREADY >_>
11:01:52 <mauke> what about EINPROGRESS
11:08:25 <oi> i still did not understand this type error http://hpaste.org/46489/monadinstance
11:08:42 <oi> does not b mean _anything_ in the type signature?
11:09:01 <mauke> what error?
11:10:14 <oi> Couldn't match type `a' with `[a]'
11:10:15 <lpsmith> oi:  you don't know that the the type of a is a list,  and the monad instance must work on all types of a,  not just those that are lists
11:10:40 <lpsmith> But it looks like you have a couple other conceptual errors
11:10:43 <mauke> besides, parsed and parsed' have different types so they can't be in the same list
11:10:52 <dankna> I seem to have lost track of whether there were any outstanding suggestions for me
11:10:57 <lpsmith> You might want to read "Monadic Parser Combinators" by Graham Hutton
11:11:08 <lpsmith> @where monadic parser combinators
11:11:08 <lambdabot> I know nothing about monadic.
11:11:31 <lpsmith> http://www.cs.nott.ac.uk/~gmh/monparsing.ps
11:11:32 <Eduard_Munteanu> dankna: INLINE pragma for 'cycle'?
11:11:37 <dankna> oh right!  thank you
11:12:05 <Eduard_Munteanu> Hopefully it can give more hints to the strictness analyzer and perhaps enable other optimizations.
11:12:16 <arcatan> mauke: /sb end
11:12:22 <arcatan> mauke: sorry, disregard that
11:12:40 * dankna nods
11:13:39 <mauke> arcatan: my "more" indicator is bright red, so most of the time I don't make that mistake :-)
11:14:00 <Twey> That's a good idea
11:14:49 <dankna> hmm,
11:14:49 <dankna>   cycle :: Motherboard.NES.State -> Motherboard.NES.State
11:14:50 <dankna>     {- Arity: 1, Strictness: U(SS(SUUUUUUUU))m, Inline: INLINE[0],
11:14:50 <dankna>        Unfolding: Worker(ext0: Motherboard.NES.$wcycle (arity 1) -}
11:14:57 <dankna> does that mean it's got the function marked for inlining or not?
11:16:27 <Eduard_Munteanu> I'm not sure at all, but I guess so, it seems to be inlining it before any simplifier stage. That should be alright I think.
11:16:32 <dankna> hmm okay
11:16:42 <dankna> that's without any special annotation by me
11:17:27 <augur> beep boop
11:17:30 <dankna> blip bop
11:18:22 <mafs> For anyone that wants to give their input on why haskell: http://www.reddit.com/r/haskell/comments/h6r6t/ask_raskell_succinctly_why_haskell_for_a_project/
11:18:33 <lifthrasiir> doq d!lq
11:18:59 <Eduard_Munteanu> Wait, I think phase 0 is the last, isn't it?
11:19:21 <Eduard_Munteanu> "Each run of the simplifier has a different phase number; the phase number decreases towards zero."
11:19:52 <Twey> Does that make 0 or 1 the last?
11:21:30 <Eduard_Munteanu> dankna: do you get different output there if you use an INLINE pragma?
11:21:34 <fragamus> I have a question.  I want to make a monad that is a combination of List and State. I had a look at Monad Transformers, and I understand the concept, but I need the syntax to declare this thing.
11:21:37 <dankna> I'm trying now
11:22:20 <dankna> okay yeah
11:22:27 <Eduard_Munteanu> :t StateT
11:22:28 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
11:22:34 <dankna> when I add the pragma, I get a lengthy thing starting with
11:22:34 <dankna>     {- Arity: 1, Strictness: U(SS(SUUUUUUUU))m,
11:22:35 <dankna>        Inline: INLINE (sat-args=1),
11:22:35 <dankna>        Unfolding: InlineRule (1, False, False)
11:22:44 <dankna> and followed by a few dozen lines of code
11:22:54 <dankna> let's see what that does for performance
11:24:03 <Eduard_Munteanu> fragamus: StateT your_state_type [] your_return_type
11:24:54 <Eduard_Munteanu> That's like wrapping StateT around a list of 'your_return_type'
11:25:25 <Eduard_Munteanu> :t runStateT
11:25:26 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
11:25:51 <Eduard_Munteanu> You might find that handy too, along with evalStateT and execStateT
11:26:03 <fragamus> thanx
11:27:27 <fragamus> I think I need it to be the other way around. (ListT)
11:28:01 <dankna> http://dankna.com/himitsu/profile-with-inlining.txt
11:28:03 <dankna> http://dankna.com/himitsu/with-inlining.png
11:28:05 <dankna> http://dankna.com/himitsu/emulator.prof.with-inlining.txt
11:28:41 <dankna> this basically just transferred the expense, both time and space, from Motherboard.NES.cycle to its caller Emulator.gamestateFrameForward
11:28:45 <fragamus> newtype SituationList s a = SL (s -> [(s,a)])
11:28:45 <fragamus> instance Monad (SituationList s) where
11:28:45 <fragamus>         -- (>>=) :: SituationList s a -> (a -> SituationList s b) -> SituationList s b
11:28:48 <fragamus>         (SL p) >>= k = SL ( \s0 ->
11:28:50 <fragamus>                         let
11:28:53 <fragamus>                             xs = p s0
11:28:55 <fragamus>                         in
11:28:58 <fragamus>                             concat (map (\(s1,a) -> let (SL q) = k a in q s1 ) xs)
11:29:01 <fragamus>                     )
11:29:03 <dankna> I ran a few more iterations - as many as I could without the simulator throwing an exception
11:29:03 <fragamus>         -- return :: a -> SituationList s a
11:29:06 <fragamus>         return a = SL( \s -> [(s,a)] )
11:29:11 <dankna> which is why the total usage is increased
11:29:16 <Zao> Mmh, ham.
11:29:20 <fragamus> I wrote that^^^   but now I think I can just use ListT and State
11:29:21 * hackagebot system-fileio 0.2 - High-level filesystem interaction  http://hackage.haskell.org/package/system-fileio-0.2 (JohnMillikin)
11:29:29 <Zao> fragamus: Paste sites are awesome, I hear :D
11:30:02 <Eduard_Munteanu> dankna: so it's just as bad? Oh, and I see your profile shows more useful information now
11:30:07 <fragamus> What
11:30:13 <aristid> @where hpaste
11:30:13 <lambdabot> http://hpaste.org/
11:30:23 <Eduard_Munteanu> fragamus: don't paste that much directly in the channel
11:30:31 <Zao> fragamus: It's considered a bit rude/ugly to paste large amounts (like >2 lines).
11:30:40 <fragamus> sorry
11:30:56 <dankna> Eduard_Munteanu, it does? O_o
11:30:57 <dankna> which one?
11:31:21 <dankna> yes, I think it's just as bad.  let me run a test which is the same number of iterations as I was using before, heh, so I can compare the numbers.
11:32:05 <Eduard_Munteanu> softwareStatePPUState                                            Motherboard.NES     2898     1428124   3.5    6.6     0.0    0.0      4  62541408
11:32:12 <dankna> did that.  it's worse, actually, although not hugely so.  it was at 400M total allocated and now it's around 550M.
11:32:51 <Eduard_Munteanu> My guess is record update messes things up.
11:32:53 <dankna> hmm
11:32:55 <fragamus> i just need syntax for declaring a monad using ListT and State
11:33:09 <Eduard_Munteanu> fragamus: oh, the other way around?
11:33:10 <dankna> softwareStatePPUState is a record field accessor
11:33:12 <Eduard_Munteanu> :t ListT
11:33:12 <lambdabot> Not in scope: data constructor `ListT'
11:33:17 <dankna> if it's allocating, that can only be because the record itself was lazy
11:33:25 <dankna> and it needs to be computed before the result can be returned
11:33:39 <dankna> but I thought I made every freaking record strict :(
11:33:40 <Eduard_Munteanu> Anyway, it's like ListT (State your_state_type) foo
11:33:53 <fragamus> thans
11:34:25 <Eduard_Munteanu> fragamus: because State s gives a monad type
11:34:40 <Eduard_Munteanu> which you can substitute in ListT m a
11:35:01 <Lemmih> dankna: I'd love to tinker with the code if possible.
11:35:21 <Eduard_Munteanu> dankna: not really. I suppose it copies the whole record to update a field, leaves the old copy around and that's claimed back later on by GC
11:35:31 <dankna> Lemmih: well, I can send it to you.  your word not to redistribute it will be good enough (this may or may not end up being an open-source project, I'm undecided).
11:35:36 <Eduard_Munteanu> And the record is huge.
11:35:53 <Lemmih> dankna: I promise I won't redistribute it (:
11:35:56 <dankna> but the record is just a list of pointers, isn't it?
11:36:08 <dankna> I did make them strict, so they should be pointers to things in WHNF, but pointers
11:36:20 <dankna> Lemmih: okay, stand by for tarball :)
11:36:23 <Eduard_Munteanu> Yeah, it isn't unboxing the arrays and all that in there.
11:36:36 <Eduard_Munteanu> But it's still copying all those Words and such
11:36:48 <Eduard_Munteanu> (those aren't any larger than pointers really, I think)
11:36:51 <dankna> Lemmih: the front-end program is Mac-only, but the back-end library should at least be compilable for you
11:38:47 <Eduard_Munteanu> dankna: you know, you could do something, though it's not really nice... make a 'cycle' variant that takes only the fields you need (you need a few anyway AFAICT) and reassemble the record outside the caller's loop
11:39:14 <dankna> I actually need all of them, I think
11:39:27 <dankna> if there are any that I don't need, they shouldn't exist
11:40:14 <dankna> Motherboard.NES.cycle itself takes a State, which consists of the two fields hardwareState :: HardwareState and softwareState :: SoftwareState
11:40:50 <dankna> it passes the State down to the two functions it wraps around, Processor.CPU_6502.cycle and PPU.PPU_NES.cycle
11:41:21 <dankna> each of which are concerned primarily with a single field of the SoftwareState - respectively, CPU_6402_State and PPU_NES_State
11:41:50 <dankna> but they receive their parameters in the form of the overall State alongside callbacks to do specific types of access to it
11:42:02 <dankna> this is so that the individual chips don't need to be aware of the memory model of the larger system they're part of
11:42:30 <dankna> when they call their store/fetch callbacks, those callbacks potentially (depending on the address being accessed) use any field of the full State
11:43:01 <Eduard_Munteanu> Hrm... I'm thinking of putting together a minimal testcase that exhibits this problem.
11:43:36 <dankna> that would be wonderful
11:43:54 <dankna> can I be of assistance?
11:44:39 <jaj> 4
11:44:47 <dankna> 5
11:45:33 <Eduard_Munteanu> Oh, nah, I'm merely looking at your code and writing a tight loop changing record fields.
11:46:11 <dankna> oh, cool then
11:51:25 <keep_learning> hello all
11:51:42 <keep_learning> could some one please tell me why i am getting compiling error for this code
11:51:43 <keep_learning> http://hpaste.org/paste/46497/google_code_jam_magicka_annot#p46498
11:52:50 <kaol> > "435" + 5
11:52:50 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
11:52:50 <lambdabot>    arising from the literal ...
11:53:03 <kaol> > (read "435") + 5
11:53:03 <lambdabot>   440
11:54:07 <dmwit> More importantly, I think,
11:54:17 <dmwit> > "435" ++ 5
11:54:17 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
11:54:17 <lambdabot>    arising from the literal ...
11:54:23 <dmwit> > "435" ++ show 5
11:54:24 <lambdabot>   "4355"
11:54:34 <dmwit> > "435" ++ replicate 5 'a'
11:54:35 <lambdabot>   "435aaaaa"
11:54:55 <dmwit> Anyway, it's a bit tricky to tell for sure without a bit more code than you've posted.
11:55:11 <keep_learning> dmwit, so is there something wrong regarding read function
11:55:19 <keep_learning> dmwit, ?
11:55:25 <dmwit> Post more code.
11:55:28 <dmwit> Then we'll talk.
11:56:30 <Lemmih> keep_learning: Add more type signatures.
11:56:59 <keep_learning> Lemmih, so i have to declare solveHelp outside
11:57:09 <keep_learning> and then call it from solve ?
11:57:15 <keep_learning> Lemmih, am i correct ?
11:57:21 <dmwit> You can put type signatures in where clauses.
11:58:58 <augur> what are galois connections
11:58:58 <Eduard_Munteanu> dankna: http://paste.pocoo.org/show/385374/
11:59:06 <dankna> looking
11:59:31 <Eduard_Munteanu> dankna: 105,091,144 bytes allocated in the heap   with all fields vs 16,065,632 bytes allocated in the heap   with only 2
11:59:32 <tristes_tigres> can I define a function which scope is limited to an instance declaration?
11:59:57 <Eduard_Munteanu> So it kinda scales with the record size.
12:00:04 <dankna> Eduard_Munteanu, hmmm.  so I see.
12:00:34 <Eduard_Munteanu> (plain -O though)
12:00:47 <dmwit> augur: They're adjunctions, but specialized to POSET.
12:00:55 <augur> dmwit: whats an adjunction :D
12:01:03 <dmwit> dunno lol =P
12:01:04 <augur> im not very CTic so
12:01:22 <augur> or UAic
12:01:24 <augur> as it were
12:01:29 <dmwit> Anyway, the definition of Galois connection is about two lines on Wikipedia.
12:01:50 <ddarius> A natural isomorphism between the functors \AB.Hom(FA, B) and \A B.Hom(A,UB) for F -| U.
12:02:13 <augur> dmwit: oh ofcourse!
12:02:30 <augur> er, ddarius
12:02:43 <Eduard_Munteanu> dankna: how do you figure out the maximum residency or whatever your problem was?
12:03:08 <dankna> Eduard_Munteanu, well, there are a number of metrics I was looking at.  the way that I was alerted to the existence of a problem was:
12:04:08 <dankna> a task which I expected to be instantaneous instead took 1.5 seconds; my CPU's fan turned on; my lap nearly got burned; Activity Monitor.app (which is like top, but pretty) reported 2G of real memory being used; my hard disk filled up with swap.
12:04:46 <dankna> that 2G is probably higher than the actual residency, because Haskell probably allocates way more memory than it actually needs; that doesn't bother me
12:05:16 <dankna> outputting a profile with -prof gives me a figure that was initially in the 800M range and got down to about 400M after adding a lot of strictness annotations iteratively with help from this channel
12:06:02 <dankna> (if everything is compiled and linked properly, and the program is invoked with +RTS -p, it saves that to ProgramName.prof in the current working directory; the figure I'm looking at there is the "total alloc" one)
12:06:12 <keep_learning> http://hpaste.org/paste/46497/google_code_jam_magicka_annot#p46500
12:06:32 <keep_learning> almost same error if i declared  it outside
12:06:58 <dankna> outputting a heap profile with +RTS -hy outputs a file ProgramName.hp which you can run the command-line tool hp2ps -c ProgramName.hp on, to produce ProgramName.ps, which you can then view
12:07:12 <dankna> and that gives me that pretty chart with the triangles made of striated bands of wasted memory
12:07:23 <Lemmih> keep_learning: This is wrong: '[y] + s'
12:08:16 <dankna> there are other metrics I have looked at once or twice, but those are the main ones
12:08:39 <Lemmih> keep_learning: Add a type signature to 'checkFun' and GHC will tell you exactly where the problem is.
12:08:55 <keep_learning> Lemmih, thank you
12:09:13 <oi> i'm a little confused, in the paper of Graham Hutton about monadic parser combinators, how the parser how when to "stop" ?
12:09:36 <oi> if the input is a string not a tokenized [string]
12:09:44 <Eduard_Munteanu> dankna: hm, lemme try that.
12:10:05 * dankna nods
12:10:08 <Lemmih> oi: It stops when it has parsed what it wants to parse.
12:10:36 <Lemmih> oi: Like, 'anyChar' parses a character and then "stops".
12:12:28 <oi> so he goes as long as he can?
12:13:27 <mauke> what kind of mental model is this
12:14:24 <dankna> Eduard_Munteanu, hmmmm!  your code allocates 104,018,720 bytes compiled with -O, but only 18,736 bytes compiled with -O2!!!
12:14:27 <dankna> we need to figure out why :)
12:14:49 <dankna> I'm not sure how that's even possible, heh
12:14:50 <Lemmih> mauke: "The Little Engine That Could" model? He keeps going as long as he can. (:
12:15:10 <dankna> it seems like it shouldn't be able to avoid allocating size-of-record times one million bytes, even if its maximum residency is much smaller
12:15:19 <dankna> hmm, it's short enough that I can -ddump-simpl it and try to understand the output
12:16:25 <Lemmih> dankna: Hoisting the loop out of the record makes it run in constant space.
12:16:51 <dankna> Lemmih: could you explain that? :)
12:16:52 <zomg> Any tips on searching for Haskell docs? I tried looking up "mLookup" but hoogle doesn't produce anything and google seems to produce nothing quite useful
12:17:26 <KirinDave> Huh
12:17:37 <KirinDave> Parsec's sepEndBy seems much more permissive than I'd like it to be.
12:17:50 <c_wraith> zomg: hoogle only indexes a small portion of hackage.  it does that to generally provide better results when you're searching for things it has indexed.  you can also use hayoo, which indexes all of hackage, but its results can often be full of noise
12:18:37 <zomg> c_wraith: that doesn't seem to have indexed mlookup either
12:18:56 <c_wraith> zomg: then it's probably not from a package on hackage
12:19:05 <zomg> hrms
12:19:17 <KirinDave> Like, sepEndBy, even if you feed it total garbage, it passes.
12:19:17 <zomg> saw it on an example about converting json into data
12:19:56 <Lemmih> dankna: runLoop r n = let loop acc 0 = acc; loop acc v = loop (acc+1) (v-1) in r{ a = loop (a r) n } -- The loop has been hoisted out and now runs in constant space.
12:20:06 <KirinDave> I can literally give it a jpg file and it is happy.
12:21:00 <dankna> Lemmih: hmmmm, okay
12:21:13 <dankna> it's not clear how I could apply that to my situation, but at least it shows what happens
12:22:43 <Nibble> how does haskell know how to evaluate this: lookup Business ps `mplus` lookup Mobile ps
12:23:26 <ehamberg> Nibble: precedence
12:23:42 <Nibble> ah, so mplus have really low precedence?
12:23:52 <luite> no application has a really high precedence :)
12:24:01 <c_wraith> well, anything used infix has lower precedence than function application
12:24:16 <Nibble> c_wraith: that explains a lot
12:24:32 <c_wraith> it's a really important rule
12:24:49 <ezyang> > [1..undefined]
12:24:49 <lambdabot>   *Exception: Prelude.undefined
12:25:22 <c_wraith> determined: enumFromTo is strict in its second arg
12:25:50 <tristes_tigres> What's the syntax for making 'where' apply to several functions definitions
12:26:06 <Nibble> indention?
12:26:47 <ddarius> tristes_tigres: There is no syntax for that.
12:26:53 <c_wraith> tristes_tigres: a where clause only applies to the equation it's attached to.  Unfortunately, you can't scope across equations
12:27:00 <luite> tristes_tigres: you could use guards instead (possibly with pattern guards), or move the part where you do the matching to within the where clause
12:27:51 <tristes_tigres> ddarius: I have some function that only need within an instance declaration
12:28:03 <arcatan> ~.
12:28:38 <tristes_tigres> a helper function for show instance decl
12:29:11 <tristes_tigres> can I hide it from the top-level?
12:29:22 <Saizan> no
12:30:12 <c_wraith> you can hide it at the module scope, though
12:30:13 <tristes_tigres> Saizan: hmm, strange, I thought it should be trivial
12:31:38 <Otend> Hi.
12:32:09 <abojep> Hi.
12:32:23 <luite> tristes_tigres: you typically hide such functions by not exporting them from the module
12:33:04 <tristes_tigres> luite: OK, but it seems somewhat arbitrary
12:38:08 <dankna> so the question then is why is -O2 on my program not managing to hoist the loop, and how can I modify my program so that it is :)
12:38:22 <Eduard_Munteanu> http://paste.pocoo.org/show/385415/
12:38:25 <Eduard_Munteanu> dankna: it doesn't anymore ^
12:38:37 <Nibble> dankna: try -=3
12:38:42 <Nibble> -O3
12:38:51 <dankna> -O3 exists?  heh :) okay
12:38:58 <Eduard_Munteanu> I don't think so.
12:39:11 <dankna> hmm
12:39:14 <Nibble> -funroll-loops?
12:39:19 <Eduard_Munteanu> 2,340,595,984 bytes allocated in the heap
12:39:34 <Eduard_Munteanu> Nibble: GHC's -O2, not gcc's ;)
12:40:19 <Nibble> lolbo
12:40:22 <Nibble> lolno*
12:40:24 <dankna> -funroll-loops is unlikely to be helpful
12:40:46 <dankna> hmm
12:41:55 <dankna> what's this arrSeq doing... you're totalling up every cell of the array, every iteration?
12:42:04 <dankna> well, that's more work than my code does :)
12:42:08 <dankna> hmm
12:42:09 <Eduard_Munteanu> Although that foldl' might not fuse with elems
12:42:16 <dankna> actually, no, it's not.  I do copy the array every iteration.
12:42:33 <dankna> although I don't actually look at more than one byte of it, so in an ideal world it would be a memcpy
12:42:34 <Eduard_Munteanu> dankna: it's a form of deepSeq there, so I seq the array
12:42:44 <Eduard_Munteanu> I could've folded with seq I suppose.
12:42:51 <dankna> nah, totalling it is fine
12:43:02 <dankna> you just wanted to ensure the array was touched
12:43:06 <dankna> thereby defeating the loop-hoisting
12:43:49 <Eduard_Munteanu> I'm not sure that's the problem, I think it's just the fact modifying Record doesn't happen in-place. It seems to get copied every time.
12:43:51 <dankna> the foldl' probably won't fuse with elems, that was this morning's topic :)
12:44:08 <dankna> well, it's my understanding that ghc never modifies anything in-place (except mutable arrays)
12:44:18 <Eduard_Munteanu> I suppose I should open-code it.
12:44:23 <dankna> (and things on the foreign heap)
12:44:44 <dankna> I am not familiar with open-coding
12:45:18 <Eduard_Munteanu> dankna: I mean write ar ! 0 `seq` ar ! 1 ... just to be sure
12:45:20 <Nibble> you should be
12:45:29 <dankna> oh - okay
12:47:36 <Eduard_Munteanu> Ah, if I do that, -O2 takes it down again
12:47:42 <dankna> hm!
12:47:51 <KirinDave> Would it be insane to make a monoid just for lists of strings that automatically word wrapped as it was appended?
12:48:07 <KirinDave> I think the monoid laws would hold for that operation.
12:48:11 <Eduard_Munteanu> http://paste.pocoo.org/show/385420/
12:48:26 <dankna> KirinDave: a monoid is a relatively simple concept; my main objection to that approach is that it doesn't generalize to non-monospaced fonts :)
12:48:42 <dankna> (because in non-monospaced fonts you use best-fit instead of first-fit to word-wrap, loosely)
12:48:52 <KirinDave> dankna: Fair enough
12:49:01 <Eduard_Munteanu> dankna: you should really avoid creating that list in 'cycle'
12:49:05 <KirinDave> dankna: But if I made a monoid for wrapping lines, Writer would do the work for free.
12:49:19 <dankna> Eduard_Munteanu, let me nopaste my current version of cycle
12:49:24 <KirinDave> dankna: And if I'm already using writer to gather my output lines, I'd just magically have wrapped text
12:49:40 <dankna> KirinDave, yes, an appealing quality
12:49:49 <KirinDave> Damn. I just blew my own mind.
12:49:59 <dankna> http://paste.pocoo.org/show/385421/
12:50:07 <dankna> in this version, I have fused things by hand, so that the list is static
12:50:16 <dankna> and hopefully only ever constructed once, when the program is starting up
12:50:32 <dankna> it does have measurably worse performance than the commented-out version, but "only" by 20%ish
12:50:34 <Eduard_Munteanu> One would hope :)
12:50:41 <dankna> rather than 200%ish like it used to be
12:50:53 <dankna> yes, haha
12:51:26 <Saizan> how does that paste differ from the 200% one?
12:51:43 <dankna> Saizan: the 200% one is.... let me find it
12:53:11 <Eduard_Munteanu> I have to go for a bit, I'll look at it later.
12:53:18 <dankna> http://paste.pocoo.org/show/385423/ -- this is the 200% version
12:53:29 <dankna> Eduard_Munteanu, thanks for all your help so far!  I will continue playing with your test case
12:54:29 <akahn> If you had 5 minutes to present Haskell to a group of OO programmers, what would you show them?
12:54:54 <KirinDave> akahn: What language do they use?
12:54:57 <dankna> it depends.  how long do I have to prepare, before the presentation :)
12:54:58 <KirinDave> akahn: Majority
12:55:01 <akahn> KirinDave: Ruby
12:55:03 <tristes_tigres> OK, another syntax question: what's wrong with definition let (:`) = reducer (:) ? I took it from the article by hinze
12:55:15 <KirinDave> akahn: Okay. Show them type classes.
12:55:16 <dankna> are they systems programmers, applications programmers, embedded-system programmers, server programmers, ...?
12:55:23 <dankna> but yes, type classes are a good choice
12:55:34 <KirinDave> akahn: Show them how type classes are as open as ruby classes but don't suffer the monkey patching problem
12:55:34 <akahn> dankna: they are largely web application developers
12:55:36 <KirinDave> They will understand that
12:55:56 <dankna> hm, then you can't really show them anything in their specific area :/
12:56:34 <akahn> KirinDave: cool. so far i have a simple example of map, which shows a bit of the type system and partial application, and I was thinking I wanted to show more of the type system. can you think of an example of typeclasses that's simple to grasp but actually interesting?
13:07:10 <paolino> functors
13:08:15 <paolino> any class for * -> * kinds is interesting
13:08:19 <zomg> damn those functors, always causing trouble
13:09:34 <ezyang> Functor was a map. He was an abstract map. He was FUNCTOR!
13:09:53 <ezyang> (to the tune of Trogdor)
13:10:13 <akahn> paolino: huh, what's an example of implementing an instance of Functor that is fairly easy to grasp?
13:10:32 <akahn> that would be a good lead-in since my first example is map
13:10:35 <paolino> @instances Functor
13:10:35 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
13:11:02 <paolino> Maybe maybe
13:11:55 <paolino> > (+1) <$> (1,1)
13:11:56 <lambdabot>   (1,2)
13:12:02 <paolino> duh
13:12:35 <paolino> akhan you should write one
13:12:51 <akahn> hm, then i need to think of a compelling example
13:13:48 <paolino> well anything isomorphic to (a,b) is ok
13:15:13 <Guest70933> Are there haskell expert? anybody use haskell in data mining?
13:16:21 <flinstone> ?
13:16:37 <luite> Guest70933: there's a data mining category on hackage, but it's only a few libraries
13:17:03 <flinstone> luite, thanks, because i think using .net for this task
13:17:16 <flinstone> with R
13:17:57 <paolino> data mining is a lot of sql ?
13:18:03 <dankna> there, back
13:18:32 <luite> flinstone: R is probably easier to start with, because it's really popular. but in general, if you're willing to write the code yourself, or the bindings to external libraries, you could perfectly do this in haskell
13:18:43 <applicative> akahn, (a,b) isn't so great since its double polymorphic, so to speak. why not a tree type like Tree a = Node a | Branch (Tree a) (Tree a)  or whatever
13:19:17 <flinstone> luite, i think i will use functions from R. But code will be in C#, or maybe haskell
13:19:50 <akahn> applicative: yeah, I think that would actually be a simpler to grasp fmap example
13:20:22 <dankna> fmap on Maybe is nice too
13:20:29 <flinstone> paolino, no, i think sql is not very good for data mining
13:20:36 <dankna> Maybe is actually one of Haskell's big features imo, even though it's simple from our perspective
13:21:33 <luite> flinstone: I don't think there's bindings for talking with R available
13:22:15 <applicative> well, but it's in the prelude, so it's not so easy to define fmap for it...  what are the constructors of option in ML?  data Option a = Nil | Some a
13:22:54 <flinstone> luite, ((
13:23:08 <applicative> akahn try that:  data Option a = Nil | Some a  and then instance Functor Option where ....
13:23:50 <paolino> I think (a,b) is just the simplest to grasp,  just pointing out the operational side of Functor, but I agree it's not the most meaningful
13:24:06 <akahn> i like the idea of using Maybe, since I agree that that's an interesting feature to show off
13:24:30 <luite> flinstone: doesn't mean that it's impossible of course. but if you want to start simple, you can just output files in a format that R can read with a very simple script, and then read back the result with your haskell program
13:25:28 <paolino> and you can keep Maybe in the pocket for Monad
13:25:38 <akahn> this is a 5 minute talk
13:25:45 <akahn> i'm not touching monads :)
13:26:49 <merijn> akahn: Wuss :p
13:26:51 <applicative> I see you won't be using Ghci for a demo, akahn
13:30:03 <paolino> recursive dataypes are hard in 5 minutes
13:31:08 <applicative> five minutes, wow
13:31:16 <tristes_tigres> I have a number of similar data structures  that I would like to treat as specific cases of some generic datatype. Can data constructors for a generic datatype be in a class declaration, so that constructors for the specific cases can be declared as instances?
13:32:04 <poucet> tristes_tigres: you're looking for type families
13:32:14 <tristes_tigres> pucet: OK, thanks
13:32:28 <poucet> tristes_tigres: the idea is that a type-class can have associated type-declaration
13:32:41 <poucet> http://www.haskell.org/haskellwiki/GHC/Type_families
13:32:49 <applicative> well, but tristes_tigres that might be the answer, but what are these structures like?
13:33:20 <tristes_tigres> applicative: in what sense what are they like?
13:33:28 <paolino> looks more like GADTs
13:33:39 <applicative> I was just wondering if that's the best answer, type families
13:33:41 <danharaj> @quote Oleg
13:33:41 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
13:34:05 <applicative> there are a number of things that you could have in mind -- at least I was thinking so.
13:34:05 <tristes_tigres> applicative: like maybe different kinds of trees that I want to show with the same code
13:34:14 <danharaj> lambdabot should have an oleg facts plugin :p
13:36:13 <danharaj> @quote Oleg
13:36:13 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
13:36:18 <danharaj> that's the only oleg fact? Tsk.
13:36:32 <applicative> @quote oleg
13:36:32 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
13:36:41 <Nibble> It should have a quote database of me
13:37:32 <Nibble> all agree? ay
13:37:44 <tristes_tigres> applicative: type families're the answer for that?
13:38:45 <poucet> @quote love
13:38:45 <lambdabot> ksf says: [on low saxon] it's hard to fit formality into a language that calls a baby (or any child, if a parent wants to express "I love you,  even though...") a bundle of shit.
13:38:48 <poucet> @quote vincenz
13:38:48 <lambdabot> vincenz says: [Ocaml] used to be pretty, Haskell made it ugly
13:39:09 <Nibble> @quote nibble
13:39:09 <lambdabot> No quotes match. That's something I cannot allow to happen.
13:39:35 <applicative> they would permit class Treeish a where type BasicTree a :: * ; node :: BasicTree a -> a  , not getting this quite right
13:39:48 <tristes_tigres> "ype families permit a program to compute what data constructors it will operate on" that's probably what I need
13:40:28 <applicative> the tutorial by Simon Peyton Jones and Oleg is super-excellent.
13:41:25 <tristes_tigres> applicate: http://www.haskell.org/haskellwiki/GHC/Indexed_types <- that tutorial?
13:42:38 * tristes_tigres thinks he is missing some replies because of disconnects
13:43:24 <applicative> tristes_tigres: linked at the bottom http://www.haskell.org/haskellwiki/Simonpj/Talk:FunWithTypeFuns
13:43:37 <tristes_tigres> applicative: thanks
13:43:39 <applicative> the source has some good illustrations
13:44:55 <applicative> The one absurdly called Coercion.hs, is very simple, for example.
13:52:33 <tristes_tigres> applicative: the link to source code at http://haskell.org/haskellwiki/Simonpj/Talk:FunWithTypeFuns is broken
13:54:24 <applicative> tristes_tigres: Yeah, i just noticed, i cant find another.
13:55:08 <applicative> i will try to put it up somewhere
13:57:09 <gwern> if a binary unit is a bit, what is a decimal unit? a dit?
13:57:37 <ion> a digit?
13:57:55 <Nibble> a bigger bit?
13:58:14 <gwern> oh, apparently it *is* a 'dit':  http://en.wikipedia.org/wiki/Ban_%28information%29
13:59:11 <argiopeweb> Ban's the usual one. Dit is used less frequently.
13:59:38 <Nereid> dit is ambiguous
13:59:48 <Nereid> I've seen it to mean something in base d
13:59:51 <argiopeweb> I.E., you never hear kilodit, but you hear kiloban.
14:00:05 <Nereid> like a base-d digit
14:01:27 <gwern> I like the clear analogy - binary bit, decimal dit
14:01:38 <aristid> natural nat
14:02:13 <Nereid> well, actually the base-d usage is probably more restricted to quantum information stuff
14:02:29 <Nereid> like you can talk about a qudit (a d-dimensional system)
14:02:35 <Nereid> :/
14:04:42 * hackagebot JsonGrammar 0.1 - Combinators for bidirectional JSON parsing  http://hackage.haskell.org/package/JsonGrammar-0.1 (MartijnVanSteenbergen)
14:04:59 <danharaj> if I want to hold a list of values of a GADT, I need to use existentials?
14:05:19 <dankna> danharaj: well, that's the easiest way
14:05:33 <danharaj> dankna: what other ways do you have in mind?
14:05:46 <dankna> you could also do a datatype like FooContainer = FooA (Foo A) | FooB (Foo B) | ...
14:05:50 <dankna> for every possible A, B, ...
14:06:11 <Nibble> PooContainer = AnimalA (Poo A)
14:06:23 <dankna> Nibble: do you ever say anything productive :)
14:06:41 <Nibble> lolno, I don't do anything productive either :D
14:06:47 <dankna> haha okay
14:07:11 * monochrom mistypes deepseq as deeqseq
14:07:45 <Nibble> q_q
14:07:52 <monochrom> :)
14:09:29 <gwern> > 10!
14:09:30 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:11:06 <gwern> > let bang n = product [1..n] in bang 10
14:11:07 <lambdabot>   3628800
14:12:19 <argiopeweb> 10 lords a-leaping, 9 ladies dancing, 8 maids a-milking...
14:12:55 <argiopeweb> *grumble* I need to stop hitting ctrl-w without noticing where my mouse is... Sometimes I dislike XMonad.
14:13:35 <argiopeweb> Even though it's pretty clearly a PEBCAK situation.
14:13:45 <Nibble> !g pebcak
14:13:55 <gwern> > 0.97 ^ (2070-2011)
14:13:55 <lambdabot>   0.16578007115626467
14:14:05 <dankna> between keyboard and chair, yes
14:14:41 <argiopeweb> I prefer the chair and keyboard variant, since the phonics doesn't really work if you spell it with KAC, but yes.
14:14:51 <NemesisD> ugh
14:15:02 <dankna> well, if you write it out as words, the rhythm is better the other way :)
14:15:06 <NemesisD> 2 packages in my system define Control.Monad.Reader
14:15:09 <argiopeweb> You don't find many hard 'c's at the end of English words.
14:15:13 <dankna> true
14:15:30 <argiopeweb> But you're right, the rythm is better the other way around.
14:15:38 <argiopeweb> rhythm with all the letters*
14:18:18 <parcs> @hoogle (a, b) -> (b, a)
14:18:18 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
14:18:18 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
14:18:18 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
14:19:24 <gwern> > 0.17 / 2000 * ( 1 - (1.96 / sqrt(0.17-1))
14:19:25 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:19:32 <gwern> > 0.17 / (2000 * ( 1 - (1.96 / sqrt(0.17-1)))
14:19:33 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:19:45 <parcs> > 0.17-1
14:19:46 <lambdabot>   -0.83
14:19:49 <gwern> :t sqrt
14:19:49 <lambdabot> forall a. (Floating a) => a -> a
14:20:03 <aristid> @instances Floating
14:20:03 <lambdabot> Double, Float
14:20:15 <gwern> > 0.17 / (2000 * ( 1 - (1.96 / sqrt (0.17 - 1)))
14:20:15 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:20:18 <gwern> auugh
14:20:42 <applicative> tristes_tigres: I put the type functions code on patchtag http://patch-tag.com/r/schoenfinkel/typefunctions/snapshot/current/content/pretty
14:20:48 <parcs> > 1 / sqrt (5)
14:20:49 <lambdabot>   0.4472135954999579
14:20:51 <argiopeweb> @type (0.17 - 1)
14:20:52 <lambdabot> forall t. (Fractional t) => t
14:20:59 <aristid> parcs: unnecessary ()!
14:21:06 <gwern> it's saying a parse error, not type error
14:21:16 <gwern> > 0.17 / (2000 * ( 1 - (1.96 / (sqrt (0.17 - 1))))
14:21:16 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:21:17 <argiopeweb> True, true.
14:21:21 <gwern> > (2000 * ( 1 - (1.96 / (sqrt (0.17 - 1))))
14:21:22 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:21:23 <parcs> unbalanced parens?
14:21:30 <tristes_tigres> applicative: thanks, maybe update the wiki page?
14:21:34 <argiopeweb> 5 (, 4 )
14:21:36 <gwern> > 1 - (1.96 / (sqrt (0.17 - 1))
14:21:36 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:21:47 <argiopeweb> 3 (, 2 )
14:21:48 <gwern> > 1.96 / (sqrt (0.17 - 1)
14:21:48 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:21:52 <gwern> > 1.96 / (sqrt (0.17 - 1))
14:21:52 <lambdabot>   NaN
14:21:52 <argiopeweb> 2 (, 1 )
14:21:57 <argiopeweb> \o/
14:22:01 <gwern> yeah, must be the parens
14:22:15 <dankna> > (-1) == (pow (sqrt -1) 2)
14:22:16 <lambdabot>   Not in scope: `pow'
14:22:16 <gwern> > 0.17 / (2000 * ( 1 - (1.96 / (sqrt (0.17 - 1)))))
14:22:17 <lambdabot>   NaN
14:22:19 <dankna> > (-1) == (expt (sqrt -1) 2)
14:22:20 <lambdabot>   Not in scope: `expt'
14:22:22 <argiopeweb> It would really be nice if parse errors gave paren counts.
14:22:25 <luite> I count more ( than ) :p
14:22:25 <dankna> > (-1) == ((sqrt -1) ** 2)
14:22:26 <lambdabot>   *Exception: (==): No overloading for function
14:22:27 <gwern> all that work for a NaN :)
14:22:37 <tristes_tigres> applicative: it's basiclally the code fragments from the article, right?
14:22:44 <gwern> > 2000 / (0.17 * ( 1 - (1.96 / (sqrt (2000 - 1)))))
14:22:44 <lambdabot>   12304.091323758576
14:22:58 <applicative> yes, but it helps to be able to run them....
14:24:07 <dankna> > (-1.0) == ((sqrt -1) ** 2)
14:24:07 <lambdabot>   *Exception: (==): No overloading for function
14:24:15 <dankna> > ((sqrt -1) ** 2)
14:24:16 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
14:24:16 <lambdabot>    arising from a use of `...
14:24:22 <dankna> > (sqrt -1)
14:24:22 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
14:24:22 <lambdabot>    arising from a use of `...
14:24:30 <dankna> > (sqrt -1) :: Complex Float
14:24:30 <lambdabot>   Couldn't match expected type `Data.Complex.Complex GHC.Types.Float'
14:24:30 <lambdabot>        ...
14:24:39 <dankna> well, whatever, I was just playing with it
14:24:42 <gwern> > 0.5^(2070-2011)
14:24:43 <lambdabot>   1.734723475976807e-18
14:24:49 <gwern> > (0.5^(2070-2011)) * 100
14:24:50 <lambdabot>   1.734723475976807e-16
14:25:09 <gwern> wow, off the top of my head I'm not even sure what 10^16 is
14:25:27 <argiopeweb> Big number, lots of 0s.
14:25:33 <argiopeweb> Good enough for me.
14:25:54 <aristid> > (sqrt (-1)) :: Complex Float
14:25:55 <lambdabot>   (-0.0) :+ 1.0
14:26:36 <argiopeweb> 10,000,000,000,000,000, to be exact.
14:26:53 <argiopeweb> 10 quadrillion, if I counted right.
14:27:21 <olsner> gwern: 26 :)
14:29:03 <argiopeweb> olsner: parse error (possibly wrong binary operator)
14:30:23 <parcs> > 10 `xor` 16
14:30:24 <lambdabot>   Ambiguous type variable `a' in the constraint:
14:30:24 <lambdabot>    `Data.Bits.Bits a'
14:30:24 <lambdabot>      a...
14:32:25 <olsner> > xor 10 16 :: Int
14:32:25 <lambdabot>   26
14:32:53 <nihtml> @source xor
14:32:53 <lambdabot> xor not available
14:33:22 <aristid> why doesn't it default to Integer? i think that has a Bits instance too
14:33:25 * argiopeweb checks to make sure this isn't ##c++
14:35:32 <monochrom> it defaults to Integer in ghci
14:35:43 <monochrom> @query lambdabot
14:35:43 <lambdabot> Unknown command, try @list
14:36:35 <parcs> > complement $  ((.&.) `on` complement) 10 16 :: Int
14:36:35 <lambdabot>   26
14:36:57 <monochrom> oh, does not default to anything on ghc 6.12.3, defaults to Integer on ghc 7.0.3, that's why!
14:39:55 <tommd> Does there exist a table showing Haskell extensions and compiler support?
14:40:06 <tommd> I feel like I've seen one before, but can't recall.
14:40:27 <parcs> @google Haskell Extensions
14:40:29 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/HaskellExtensions
14:40:29 <lambdabot> Title: HaskellExtensions – Haskell Prime
14:41:33 <tommd> Huh, I could swear I googled exactly that but... thanks!
14:41:43 <hpc> tommd: is this academic, or are you shopping for compilers?
14:42:37 <danharaj> There really is no contest.
14:42:39 <tommd> Academic
14:43:09 <danharaj> GHC is the compiler of choice in almost every situation.
14:43:23 <gwern> hard to think of why you would use ehc/uhc or jhc
14:43:33 <tommd> Because you're using HaLVM.
14:43:56 <danharaj> I thought HaLVM was based on GHC?
14:43:56 <tommd> *That's the reason not to use GHC
14:44:03 <tommd> Yes, I kid, I kid.
14:44:41 <danharaj> The only reason why I wouldn't use GHC proper is because I want to program in Disciple :p
14:48:45 <mietek> Is anyone here from the CMU POP group?
14:53:18 <udoprog> just gonna ask, hoogle says setEffectiveGroupID is exported by System.Posix.User, but ghc 6.12.3 doesn't seem to have it, which version does hoogle use and where can i find equivelant function in my ghc?
14:54:05 <danharaj> That's not part of GHc, that's part of the Unix package
14:54:10 <danharaj> http://hackage.haskell.org/package/unix/
14:55:20 <udoprog> danharaj: k, that cleared things up, thanks
14:56:18 <keep_learning> http://hpaste.org/paste/46504/compilation_error_annotation#p46505
14:56:28 <keep_learning> i am getting compilation error for this problem
14:56:39 <keep_learning> but it interpreting fine with ghci
14:56:46 <Nioate> do I have to write my own functions for extracting multi-byte integers from a ByteString?
14:56:50 <keep_learning> could any one please have a look
14:57:11 <danharaj> keep_learning: what flags did you use when compiling?
14:57:28 <dankna> Nioate: it's not difficult to write them and you probably should because you probably have your own distinct preferences with regard to encoding (in particular, endianness)
14:57:35 <dankna> Nioate: but look at the "binary" package
14:57:37 <dankna> @where binary
14:57:37 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
14:57:54 <dankna> oops
14:57:55 <keep_learning> danharaj, simply ghc   Magicka.hs
14:57:58 <dankna> @hackage binary
14:57:58 <lambdabot> http://hackage.haskell.org/package/binary
14:58:06 <Nioate> dankna: not difficult to write them but dumb for everyone to keep rewriting them
14:58:06 <keep_learning> danharaj, i always compile this way
14:58:09 <dankna> no, I see that that package is something else entirely
14:58:13 <argiopeweb> keep_learning: "--make"
14:58:15 <dankna> Nioate: true, of course, but what can you do
14:58:17 <danharaj> ^ yes
14:58:28 <argiopeweb> Or upgrade to 7.*
14:58:34 <argiopeweb> Which does it automatically.
14:58:40 <dankna> keep_learning, use cabal, it will force you to be more aware of your dependencies
14:58:52 <dankna> keep_learning, in this case you're using the "containers" package but not linking against it
14:59:17 <keep_learning> dankna, thank you
14:59:20 <dankna> sure
14:59:33 <keep_learning> dankna, everyday i learn something in haskell :)
14:59:39 <dankna> indeed
15:06:25 <Nioate> dankna: I forgot to thank you for the link. so thank you.
15:06:41 <dankna> oh, you're welcome.  it isn't quite what you want though :/
15:06:52 <dankna> but it's related.  see the instance Binary Storable, for example
15:07:01 <dankna> er, (Storable a) => Binary a, or whatever
15:11:15 <Eduard_Munteanu> Hrm, it's time I tried GHC 7 too.
15:12:31 <dankna> it compiles faster than it used to, or it felt that way to me last week :)
15:12:43 <dankna> but that was 7.1; 7.0.2 is still a lengthy compile
15:12:54 <argiopeweb> Eduard_Munteanu: I say the same thing every day... Then I remember that I'm waiting to do all updgrades till Fedora 15 comes out at the end of the month and I do full system wipe.
15:15:30 <rostayob> I'm writing some bindings to c functions
15:15:51 <argiopeweb> rostayob: Aren't there automated tools for that nowadays?
15:16:00 <rostayob> argiopeweb: well, more or less
15:16:04 <rostayob> i'm using hsc2cs
15:16:17 <zomg> Would anyone happen to have any examples on how to use hoauth with a use-case where you already have all the oauth tokens and stuff?
15:16:44 <rostayob> anyway, the problem is that I'm writing a binding to a markdown library that converts a char* with the markdown to a char* with the resulting html
15:16:45 <zomg> I managed to create a token and run some request with it but I just received a 401 unauthorized so I'm guesing I screwed up at some point =)
15:17:15 <rostayob> now the problem is that in haskell i'm converting the String to CString with newCString, and then peekCString to convert it back
15:17:32 <rostayob> it works, but while the original works with utf-8, the haskell one doesn't
15:18:19 <argiopeweb> It works when you send it UTF8 as a char*?
15:19:01 <dankna> @hackage utf-string
15:19:02 <lambdabot> http://hackage.haskell.org/package/utf-string
15:19:04 <rostayob> argiopeweb: well if I have the C version that gets a file and outputs the xhtml to stdout, and it works with a file with utf8 chars
15:19:07 <dankna> @hackage utf8-string
15:19:07 <lambdabot> http://hackage.haskell.org/package/utf8-string
15:20:00 <rostayob> dankna: cool, so I should to newCString (fromString hsString)?
15:20:23 <dankna> something along those lines, it depends what you start with and what you want
15:20:31 <dankna> I usually do
15:20:32 <argiopeweb> I've heard Text is good for that as well. Never had to deal with it personally.
15:20:35 <dankna> import qualified Data.ByteString as BS
15:20:39 <dankna> import qualified Data.ByteString.UTF8 as UTF8
15:20:55 <dankna> that way I never get confused about which versions of the similarly-named functions I'm using
15:21:07 <mjrosenb> hey, does haskell have infix type aliases?
15:21:16 <rostayob> dankna: note that i'm not using bytestrings at all, just Strings
15:21:35 <dankna> rostayob: yes, you'll want to use bytestrings, for a couple reasons
15:21:39 <dankna> a) it lets you be explicit about encodings
15:21:40 <navaati> mjrosenb: maybe the TypeOperators extension can help you
15:21:42 <jmcarthur> mjrosenb: it does at least with the TypeOperators extension
15:22:15 <mjrosenb> without the typeoperators extension, can anything at the type level be infix?
15:22:16 <dankna> b) it's more space-efficient; String is defined as [Char] which means an 80-character string on a 64-bit system occupies something like half a kilobyte
15:22:32 <dankna> c) it's more time-efficient for the same reason, for anything but linear access
15:22:51 <rostayob> dankna: ok, thanks. so I should read the file into an utf-8 ByteString, and then convert the ByteString to a CString
15:23:18 <Eduard_Munteanu> Bytestrings also fuse better AFAIK
15:23:28 <dankna> correct.  without going through a Haskell string at all.  conveniently, the bytestring package has functions for reading files into bytestrings, or the network package does if you are receiving the file over a socket.
15:23:42 <rostayob> the thing is that in the end I'll have to deal with Strings
15:23:50 <dankna> (in older versions you needed a separate package, network-bytestring, but that functionality has now been merged into network)
15:23:54 <Eduard_Munteanu> Oh, and don't use unpack and pack, that defeats the purpose ;)
15:23:58 <dankna> why?  perhaps I can suggest a way not to :)
15:24:05 <tristes_tigres> A type family permit a program to compute what data constructor it will operate on. Can this data constructor have different number of arguments in different instances?
15:24:08 <rostayob> dankna: because my application uses Strings :P
15:24:22 <dankna> note by the way that a UTF8 bytestring is simply a bytestring containing data that happens to be UTF8; it's not distinct in the typesystem
15:24:40 <argiopeweb> rostayob: Well stop that. :P
15:24:52 <dankna> that's why you're importing both packages - Data.ByteString (from bytestring) for the datatype, and Data.ByteString.UTF8 (from utf8-string) for the encoding/decoding
15:24:53 <rostayob> argiopeweb: why? if anything, I'll use Text
15:25:08 <rostayob> dankna: yeah i've worked with bytestrings (:
15:25:11 <mjrosenb> also, i seem to fail at remembering how to tell ghc to turn on -XTypeOperators for a single file.
15:25:22 <dankna> {-# LANGUAGE TypeOperators #-} before the module line
15:25:29 <argiopeweb> For reasons ['a'..'c'] stated above.
15:25:48 <mjrosenb> i can never remember when it is LANGUAGE and when it is something else.
15:25:55 <mjrosenb> is there an easy way to determine this?
15:26:01 <dankna> yes.  it's always LANGUAGE.
15:26:11 <rostayob> argiopeweb: mah, I don't like ByteStrings that much. If anything, I find that you're less specific on the encoding, a ByteString is just a series of Word8 in the end
15:26:12 <dankna> I can't think of anything you need in recent GHC's that is anything else.
15:26:15 <mjrosenb> oh, has this always been the case?
15:26:28 <dankna> no, in 6.8ish you used to need GHC-OPTIONS for some things
15:26:34 <dankna> I hear okay things about Text, but I know that Michael Snoyman profiled it for his web framework and found that ByteString was faster
15:26:40 <mjrosenb> ahh.
15:26:40 <dankna> (he also found that my package direct-fastcgi was slow :( )
15:26:57 <rostayob> dankna: I don't care that much about performance that much now (:
15:27:01 <dankna> fair enough
15:28:54 <rostayob> and still, I wouldn't be that comfortable with bytestrings anyway... you're not really sure what's in a bytestring
15:29:45 <rostayob> maybe Text is the best thing
15:29:49 <dankna> that's fair
15:30:00 <Eduard_Munteanu> What do you mean?
15:30:34 <rostayob> dankna: btw, since you're mentioning web framework, that's the app: http://mazzo.li:8000/ (:
15:30:40 <dankna> ah cool
15:30:59 <argiopeweb> You spelled goatse wrong... :\
15:31:09 <rostayob> argiopeweb: that was my friend lol
15:31:32 <rostayob> i should put the new version in the sever, I can't delete post in that one eheh
15:31:39 <argiopeweb> rofl...
15:31:47 <rostayob> dankna: but that's not yesod, it's happstack
15:31:55 <dankna> yick to both :)
15:32:01 <dankna> I prefer FruitTart (unreleased)
15:32:09 <navaati> Text used together with the OverloadedStrings is very convenient
15:32:14 <argiopeweb> It has the best name of the three...
15:32:18 <navaati> the OverloadedStrings extension*
15:32:28 <rostayob> navaati: OverloadedStrings is annoying sometimes
15:33:17 <rostayob> if you've got functions that takes a IsString, you have to explicitly add the type in the code each time
15:33:30 <rostayob> dankna: what's FruitTart?
15:33:35 <dankna> my own package, haha
15:33:40 <argiopeweb> rostayob: AGGH! Why are all your '>' on newlines?
15:33:42 <dankna> http://dankna.com/software/ has a blurb for it
15:33:53 <rostayob> argiopeweb: that's how Html gets rendered
15:33:57 <dankna> it even has a logo! :D (which I paid actual money to have drawn, ahha)
15:34:13 <argiopeweb> danharaj: Looks more like a pie.
15:34:19 <dankna> dankna != danharaj
15:34:28 <argiopeweb> My bad. Stupid auto complete.
15:34:30 <dankna> yeah, sorta
15:34:42 <dankna> but it's a tasty-looking whatever it is
15:34:45 <dankna> ahhhh I want a fruit tart
15:34:52 <argiopeweb> That being said, I couldn't pick a tart out of a lineup, so I shouldn't talk.
15:35:07 <dankna> I actually looked at hundreds of photos of tarts before commissioning this drawing, haha
15:35:13 <dankna> I can assure you it is fairly realistic
15:35:16 <rostayob> dankna: I like the fact that happstack doesn't enforce any pattern really, and it plays well with acid-state, which is grrrrreat
15:35:18 <argiopeweb> Ah, good.
15:35:23 <dankna> I'm /just slightly/ obsesive
15:35:27 <rostayob> dankna: yeah, great logo eheh
15:35:27 <dankna> *obsessive
15:35:30 <dankna> hehehe
15:35:40 <argiopeweb> dankna: Nothing I haven't seen before there...
15:35:57 <dankna> rostayob: yeah - FruitTart does enforce a pattern, which I call model-view (no controller, heh)
15:36:00 <argiopeweb> dankna: So, when's it getting released? :P
15:36:11 <dankna> give me twelve months - I'm getting into FPGA design haha
15:36:22 <rostayob> dankna: that's quite an old pattern (:
15:36:32 <dankna> yes
15:36:49 <argiopeweb> dankna: Ah, FPGAs... Haven't been sidetracked by them in awhile.
15:36:52 <akahn> Bah. For my presentation, I tried using Ord as an example of a typeclass, making a Point type an instance of Ord. But it isn't very interesting :-/
15:36:54 <dankna> argiopeweb, hehehe
15:37:04 <dankna> but one which I haven't found extant frameworks to implement in quite the way I want
15:37:09 <argiopeweb> Verilog, VHDL, or something new and interesting?
15:37:11 <rostayob> Eduard_Munteanu: were you asking to my about ByteStrings? I don't like the fact that they're just a list of bytes, and you don't know what's inside them
15:37:13 <dankna> Verilog
15:38:00 <argiopeweb> I can code that stuff all day... Built a stack-based lisp machine last time.
15:38:07 <dankna> nifty!
15:38:44 <argiopeweb> It really was quite cool. I'll have to pick it back up one of these days and see about making it a bit more useful.
15:38:55 <argiopeweb> It doesn't have any VGA capabilities at the moment.
15:39:02 <dankna> yeah
15:39:06 <dankna> I'm interested in NTSC output actually
15:39:11 <dankna> for self-contained devices :)
15:39:22 <argiopeweb> Cool.
15:39:24 <dankna> yeah
15:39:38 <argiopeweb> How are you planning on pulling that off?
15:39:58 <dankna> there are two approaches that I'm thinking about - note that I haven't really done the important part of the learning yet
15:40:11 <dankna> one is to use a DAC on an outside chip
15:40:27 <dankna> the other is to use one of Cypress Semiconductor's SoCs that has an analog block
15:40:28 <argiopeweb> The "delegate" approach.
15:40:31 <dankna> yes
15:40:57 <rostayob> so going back to the original issue, what's the best method to do String -> CString while preserving utf-8? String -> UTF8 ByteString -> CString?
15:41:11 <c_wraith> yes
15:41:37 <monochrom> I second that
15:41:45 <argiopeweb> dankna: Nifty. I look forward to hearing about it.
15:41:52 <dankna> argiopeweb, thanks :) I look forward to doing it
15:41:58 <monochrom> especially if next you marshal CString to C's char*
15:42:26 <rostayob> monochrom: isn't CString just Ptr CChar?
15:42:43 <rostayob> I mean what else can I marshal it to :P?
15:42:44 <monochrom> oh! you're right
15:43:34 <rostayob> ok, thanks
15:43:47 <rostayob> also, is c2hs better than hsc2hs for simple stuff?
15:46:31 <rostayob> because the last update to hsc2hs was in 2006, is it a dead project?
15:46:54 <argiopeweb> rostayob: I was under the impression it was part of GHC.
15:47:11 <rostayob> argiopeweb: oh, I was looking at the hackage package page
15:47:13 <argiopeweb> http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/hsc2hs.html << It's in the docs.
15:47:44 <rostayob> argiopeweb: oh right
15:48:03 <rostayob> it's strange that it keeps INCLUDE pragmas then
15:48:16 <rostayob> i mean ghc gives warnings
15:48:32 <argiopeweb> Though I'm looking at the hackage page now and it seems odd that it's broken on ghc>6.6
15:48:43 <Kaidelong> I think Yesod has won me over
15:48:49 <Kaidelong> anyone care to talk me out of it?
15:49:18 <aristid> Kaidelong: tell us why it has won you over :)
15:49:41 <Kaidelong> the incomplete book is still better than nothing, mostly
15:49:43 * argiopeweb senses the Socratic Method brewing
15:49:48 <Kaidelong> but also
15:50:23 <Kaidelong> I like the idea of getting statically checked errors for including hamlet that doesn't do the right thing in context
15:50:48 <aristid> Kaidelong: i haven't done anything real with yesod, but i thought widgets were pretty convenient too
15:50:50 <udoprog> hm, getting "Bad interface file: .../haskell98-1.1.0.1/ghc-6.12.3/System.hi" when compiling a project depending on haskell98, anyone can help me with whats up?
15:51:51 <blackdog_> dons: so that caused a bit more fuss than i expected.
15:51:57 <Kaidelong> snap looked a bit haphazard by comparison
15:52:31 <dankna> Kaidelong: I like the idea that when Hamlet is asked "What do you read?" and he answers "Words, words, words," he gets a type error for not saying what kind of words.
15:53:05 <Kaidelong> AFAICS Heist doesn't do anything like that
15:57:04 <NemesisD> jmcarthur: ping
15:57:54 <rostayob> dankna, monochrom: ok, I'm trying to do the String -> UTF8 bytestring conversion but it's not working well: http://hpaste.org/paste/46508/ . I've annotated it with the C version and the output of the two versions
15:58:13 <dankna> hm
15:58:17 <argiopeweb> dankna: Why no love for the non-Mac platforms in Vecky?
15:58:33 <tristes_tigres> is it possible to hide instance declarations from a module, and import only constructors?
15:58:56 <rostayob> oh wait
15:59:13 <rostayob> print will truncate all the chars to 8 bit right? or something like that
15:59:19 <dankna> argiopeweb, because the cost of developing a multi-platform GUI app that will actually sell is something like (n-1)^2000 where n is the number of platforms
15:59:45 <argiopeweb> dankna: wxWidgets bindings to every language under the sun (including Haskell)?
16:00:03 * hackagebot newt 0.0.1.0 - A trivially simple app to create things from simple templates.  http://hackage.haskell.org/package/newt-0.0.1.0 (RoganCreswick)
16:00:09 <rostayob> yes, it's because it calls show
16:00:10 <dankna> won't sell, because wx is a piece of shit.  I have extensive experience with cross-platform widget toolkits and cannot conceive of actually selling a product written in them.
16:00:13 <dankna> they're fine for research.
16:00:13 <rostayob> it works with putStrLn
16:00:15 <rostayob> cool
16:00:36 <dankna> especially when you're targetting the Mac as one of your platforms
16:00:39 <dankna> Win/Lin users aren't very picky
16:00:44 <dankna> Mac users tend to nitpick tiny details
16:01:23 <argiopeweb> dankna: This does tend to be true... Never actually used wxFoo on Mac, so I'm unfamiliar with which standards it may/may not break.
16:01:37 <dankna> to start with, it doesn't use the standard system open-file dialog
16:01:46 <argiopeweb> Okay, that's a deal breaker.
16:01:48 <dankna> it also puts its buttons in the wrong order.  "Okay" should always, always, always be on the right.
16:01:49 <rostayob> mh, why is that I can't get a CString from a lazy BS?
16:01:50 <dankna> yeah
16:02:25 <dankna> anyway, it's a GUI app.  it contains dozens of custom widgets and it's barely 10% done.
16:03:08 <dankna> custom widgets are a pain in cross-platform widget frameworks; they tend to look even worse
16:04:05 <argiopeweb> This I can see being true as well. Are you using Haskell/hoc or just going straight with the ObjC route?
16:04:57 <dankna> straight ObjC (HOC is unmaintained, although my own direct-cocoa aims to replace it), but with Haskell for the scripting engine
16:05:17 <argiopeweb> Ah, clever.
16:05:25 <dankna> thanks :)
16:06:12 <mjrosenb> is there an easy way to truncate a Word16 to a Word8?
16:06:28 <rostayob> mjrosenb: you want to split it or just truncate it?
16:06:33 <dankna> fromIntegral
16:06:38 <mjrosenb> rostayob: split prefferably.
16:07:13 <rostayob> I remember asking that some time ago, and it's not that easy.
16:07:58 <rostayob> otherwise, what dankna said
16:08:23 <rostayob> > fromIntegral (500 :: Word16) :: Word8
16:08:24 <lambdabot>   244
16:08:35 <dankna> > fromIntegral (shiftR (0xBEEF :: Word16) 8)
16:08:36 <lambdabot>   190
16:08:46 <dankna> > showHex (fromIntegral (shiftR (0xBEEF :: Word16) 8)) ""
16:08:47 <lambdabot>   "be"
16:08:47 <argiopeweb> Beef?
16:08:52 <dankna> yes, I'm hungry
16:08:55 <argiopeweb> Delicious.
16:08:58 <dankna> hehe
16:09:06 <dankna> > showHex (fromIntegral (shiftR (0xBEEF :: Word16) 0)) ""
16:09:07 <lambdabot>   "beef"
16:09:11 <argiopeweb> There we go.
16:09:14 <dankna> > showHex (fromIntegral (shiftR (0xBEEF :: Word16) 0) :: Word8) ""
16:09:14 <lambdabot>   "ef"
16:09:18 <dankna> there we go
16:09:57 <argiopeweb> Now if you can just figure out where all those functions came from, you'll be gold.
16:10:09 <argiopeweb> Though I guess showHex and shiftR are the only two... :\
16:10:11 <dankna> showHex is from Numeric in base; fromIntegral is in Prelude
16:10:19 <dankna> shiftR is from Data.Bits in base
16:10:27 <dankna> Word16 and Word8 are from Data.Word in base
16:10:32 <dankna> yes, I /have/ been doing this a lot lately!
16:10:35 <argiopeweb> hehe
16:11:06 <rostayob> dankna: why are you shifting 0?
16:11:11 <argiopeweb> Same, sans the shifting. Interfacing with legacy C apps with proprietary network data formats for the win!
16:11:40 <dankna> rostayob: I'm hoping the compiler will optimize it out :)
16:11:46 <rostayob> > showHex (fromIntegral (0xBEEF :: Word16)) ""
16:11:47 <argiopeweb> ^^ Right answer.
16:11:47 <dankna> rostayob: I'm mostly doing it for consistency
16:11:47 <lambdabot>   "beef"
16:11:57 <rostayob> > showHex (fromIntegral (0xBEEF :: Word16) :: Word8) ""
16:11:57 <lambdabot>   "ef"
16:12:00 <rostayob> oh, ok
16:12:33 <rostayob> > showHex (fromIntegral (shiftL (0xBEEF :: Word16) 2) :: Word8) ""
16:12:33 <lambdabot>   "bc"
16:12:40 <rostayob> > showHex (fromIntegral (shiftR (0xBEEF :: Word16) 2) :: Word8) ""
16:12:41 <lambdabot>   "bb"
16:12:49 <rostayob> > showHex (fromIntegral (shiftR (0xBEEF :: Word16) 8) :: Word8) ""
16:12:50 <lambdabot>   "be"
16:12:52 <rostayob> lol, ok
16:12:55 <dankna> > let { shiftMany input 0 = input ; shiftMany input n = shiftMany (shiftR input 0) (n - 1) } in shiftMany 0x0CD 1000000000
16:12:56 <lambdabot>   Ambiguous type variable `a' in the constraint:
16:12:56 <lambdabot>    `Data.Bits.Bits a'
16:12:56 <lambdabot>      a...
16:13:05 <dankna> > let { shiftMany input 0 = input ; shiftMany input n = shiftMany (shiftR input 0) (n - 1) } in shiftMany (0x0CD :: Word16) 1000000000
16:13:08 <lambdabot>   mueval-core: Time limit exceeded
16:13:11 <dankna> hah
16:13:18 <dankna> so much for it being optimized out
16:13:20 <argiopeweb> Denied.
16:13:29 <dankna> that was what I was trying to test though :D
16:13:33 <rostayob> so yeah, fromIntegral word to get the least significant byte, and fromIntegral (shiftR word 8) to get the other one
16:13:48 <dankna> yeah
16:13:52 <argiopeweb> Pretty sure lambdabot is at -O0. ;)
16:13:56 <dankna> hmm
16:14:24 <rostayob> going to bed, AI exam tomorrow! ehe
16:14:31 <dankna> funfun
16:14:33 <argiopeweb> rostayob: Heh, enjoy
16:14:59 <rostayob> let's hope so ehe
16:15:06 <rostayob> thanks for the help
16:20:06 <jomo> omg, guys - im here few minutes and feel than im in startrek. ;) It is really possible learn haskell? :) What I seen for a while, it is very cryptic... ;)
16:20:42 <argiopeweb> jomo: Sorry, only Klingon spoken here.
16:20:54 <jomo> :)
16:20:57 <argiopeweb> ;)
16:21:02 <dibblego> jomo: sure it's possible mate, just hang in there, ask questions
16:21:06 <ryant5000> has anyone managed to get Haddock working with arrow syntax?
16:21:10 <argiopeweb> Read "Learn you a haskell"
16:21:33 <jomo> OK - will try :) ty
16:21:44 <aristid> @where lyah
16:21:44 <lambdabot> http://www.learnyouahaskell.com/
16:21:46 <argiopeweb> Then "Real World Haskell"
16:21:52 <aristid> @where rwh
16:21:52 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
16:21:57 <dankna> jomo: You have to be careful, or the zygohistomorphic prepromorphisms could blow the entire ship to smithereens!
16:21:57 <argiopeweb> And then everything you can find till you get everything. ;)
16:22:07 <aristid> @where everything
16:22:07 <lambdabot> I know nothing about everything.
16:22:09 <pastorn> jomo: an easy way to test it is http://tryhaskell.org
16:22:13 <dankna> @where nothing
16:22:13 <lambdabot> I know nothing about nothing.
16:22:18 <aristid> :D
16:22:21 <dankna> :D
16:22:24 <argiopeweb> dankna: Really? You had to invoke zygohistomorphic prepromorphisms?
16:22:34 <dankna> sorry, sorry!
16:22:47 <pastorn> jomo: tryhaskell is a web interpreter for haskell expressions, with a clear guide
16:22:48 <argiopeweb> I think my spellchecker had a heart attack checking those...
16:22:51 <jomo> :) i heard about the wonderfull haskell irc community - and as i seen - it is true ;)
16:22:59 <dankna> we try
16:23:37 <argiopeweb> @where anything
16:23:37 <lambdabot> I know nothing about anything.
16:23:44 <argiopeweb> And therein lies the problem.
16:24:13 <dankna> @. elite where cool tricks
16:24:13 <lambdabot> I xnOw not|-|iN9 a8OU+ c00l.
16:24:32 <aristid> @. pl elite where cool tricks
16:24:32 <lambdabot> (line 2, column 1):
16:24:32 <lambdabot> unexpected end of input
16:24:32 <lambdabot> expecting space or simple term
16:24:40 <pastorn> dankna: how paradoxal! my brain is exploding now!
16:24:43 <dankna> haha
16:25:23 <pastorn> dankna: always related; http://www.youtube.com/watch?v=O2rGTXHvPCQ
16:25:45 <dankna> I'm in polite company; I'm therefore not clicking video links :D
16:25:46 <pastorn> irc - like shipping channels
16:26:15 <keep_learning> could some one please tell how can i remove all the string of length from List of string
16:26:28 <keep_learning> deleteBy ( \x y -> length x ==  1 ) "1" .lines $ "2\n5\n1 2 3 4 5\n3\n3 5 6"
16:26:35 <pastorn> keep_learning: so you want [String] -> [String]?
16:26:44 <dankna> > deleteBy ( \x y -> length x ==  1 ) "1" .lines $ "2\n5\n1 2 3 4 5\n3\n3 5 6"
16:26:45 <lambdabot>   ["5","1 2 3 4 5","3","3 5 6"]
16:26:45 <pastorn> @type filter
16:26:46 <keep_learning> pastorn, yes
16:26:47 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
16:26:48 <argiopeweb> keep_learning: Use filter. Always use filter.
16:27:04 <pastorn> @type filter (\str -> length str /= 3)
16:27:05 <lambdabot> forall a. [[a]] -> [[a]]
16:27:07 <aristid> whatever the task, use filter
16:27:10 <keep_learning> argiopeweb, pastorn thank you
16:27:18 <dankna> aristid:
16:27:21 <keep_learning> it looks now i need some sleep :)
16:27:28 <aristid> dankna: filter
16:27:30 <pastorn> @type filter ((3 ==) . length)
16:27:30 <lambdabot> forall a. [[a]] -> [[a]]
16:27:46 <pastorn> keep_learning: ^^^ (for when you're h4xx0r enough)
16:28:05 <pastorn> keep_learning: named variables is for n00bz
16:28:14 <argiopeweb> > filter (1 == length) $ lines "2\n5\n1 2 3 4 5\n3\n3 5 6"
16:28:14 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
16:28:14 <lambdabot>         against inferred ...
16:28:25 <argiopeweb> > filter (\x -> 1 == length x) $ lines "2\n5\n1 2 3 4 5\n3\n3 5 6"
16:28:26 <lambdabot>   ["2","5","3"]
16:28:28 <aristid> @type filter (liftA2 (==) 3 length)
16:28:29 <lambdabot> forall a. [[a]] -> [[a]]
16:28:32 <aristid> :>
16:28:41 <pastorn> aristid: lolz
16:29:00 <argiopeweb> pastorn: I bow to your 1337'ness.
16:29:14 <aristid> @elite pastorn: I bow to your 1337'ness.
16:29:15 <lambdabot> PAST0RN: i 80w 7o yoUR 1337'n3zs.
16:29:16 <argiopeweb> Speaking of which, I'm about to be living at 1337 x st....
16:29:17 <pastorn>  - Luckily i speak leet.
16:29:21 <dankna> > filter (\x -> let prime counter = if (div x counter) * counter == x then True else if counter > (floor $ sqrt x) then False else prime $ counter + 1 in prime x) [0..100]
16:29:22 <pastorn>  - That's so hot!
16:29:22 <lambdabot>   Ambiguous type variable `b' in the constraints:
16:29:22 <lambdabot>    `GHC.Real.RealFrac b'
16:29:22 <lambdabot>   ...
16:29:22 <argiopeweb> rofl...
16:29:28 <aristid> is there an @unelite? :D
16:29:30 <dankna> > filter (\x -> let prime counter = if (div x counter) * counter == x then True else if counter > (floor $ sqrt x) then False else prime $ counter + 1 in prime x) [0..100] :: [Int]
16:29:30 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
16:29:30 <lambdabot>    arising from a use of...
16:29:37 <dankna> > filter (\x -> let prime counter = if (x / counter) * counter == x then True else if counter > (floor $ sqrt x) then False else prime $ counter + 1 in prime x) [0..100] :: [Int]
16:29:37 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
16:29:37 <lambdabot>    arising from a use of...
16:29:47 <dankna> > filter (\x -> let prime counter = if (div x counter) * counter == x then True else if counter > (sqrt x) then False else prime $ counter + 1 in prime x) [0..100] :: [Int]
16:29:48 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
16:29:48 <lambdabot>    arising from a use of...
16:29:51 <pastorn> dankna: do the "let" outside of the filter function?
16:30:02 <dankna> pastorn: but that would not be following aristid's advice!
16:30:03 <pastorn> dankna: and spam lambdabot through a /query :)
16:30:18 <dankna> sorry, okay :)
16:33:07 <pastorn> keep_learning: the trick is that you can skip mentioning variables if they are being used in the same order
16:33:19 <pastorn> @let double x = 2 * x
16:33:20 <lambdabot>  Defined.
16:33:22 <pastorn> @type double
16:33:23 <lambdabot>     Ambiguous occurrence `double'
16:33:23 <lambdabot>     It could refer to either `L.double', defined at <local>:1:0
16:33:23 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.double', imported from Text.PrettyPrint.HughesPJ at State/L.hs:54:0-46
16:33:27 <pastorn> damn
16:33:37 <pastorn> @let dbl x = 2 * x
16:33:37 <lambdabot>  Defined.
16:33:40 <pastorn> @type dbl
16:33:40 <lambdabot> forall t. (Num t) => t -> t
16:33:54 <pastorn> @type (\xs -> map dbl xs)
16:33:55 <lambdabot> forall a. (Num a) => [a] -> [a]
16:34:00 <pastorn> @type map dbl
16:34:01 <lambdabot> forall a. (Num a) => [a] -> [a]
16:34:07 <pastorn> keep_learning: ^^^^
16:34:18 <pastorn> the 2nd style i used there is called "points-free"
16:34:26 <pastorn> well, actually it's pointless
16:34:32 <aristid> :t Text.PrettyPrint.HughesPJ.double
16:34:32 <lambdabot> Double -> Doc
16:34:41 <pastorn> @pl (\xs -> map dbl xs)
16:34:41 <lambdabot> map dbl
16:35:21 <keep_learning> pastorn, thank you
16:35:35 <keep_learning> pastorn, you guys are really great
16:35:52 <pastorn> keep_learning: did you try out "tryhaskell.org"?
16:36:05 <keep_learning> pastorn, nope
16:36:17 <pastorn> you should - it's a great quick start thingy
16:36:59 <pastorn> not as good as the quick start in racket, but still :)
16:37:09 <keep_learning> pastorn, thank you
16:37:24 <keep_learning> pastorn, currently i am using to solve code jam problems
16:37:41 <pastorn> code jam? do you have a problem description somewhere?
16:37:43 <keep_learning> pastorn, so its quite difficult in haskell as i am kind of beginner
16:37:50 <keep_learning> pastorn, yes
16:37:57 <pastorn> keep_learning: but you've programmed in other languages before?
16:38:05 <keep_learning> http://code.google.com/codejam/contest/dashboard?c=975485#s=p2
16:38:14 <keep_learning> pastorn, yes in c++
16:38:37 <keep_learning> but haskell is totally different from c++
16:38:50 <aristid> keep_learning: did you program in c++ templates? :D
16:38:57 <pastorn> keep_learning: i know... there's even a "lolwtf is going on"-tutorial for C and C++ programmers learning haskell
16:39:27 <keep_learning> aristid, not much
16:39:39 <keep_learning> aristid,  i use STL most of times
16:39:43 <pastorn> keep_learning: but it helps to think of all variables as 'const' or 'final' (if you swing the java way)
16:39:46 <keep_learning> mainly on topcoder
16:40:07 <keep_learning> pastorn, yes now it more helpful :)
16:40:16 <pastorn> and to declare variables again you do recursive calls
16:40:21 <keep_learning> every variable is final in haskell
16:40:34 <pastorn> indeed :)
16:40:59 <pastorn> keep_learning: but if you already know how to program then "Real World Haskell" is probably a better book to read than "Learn You A Haskell"
16:41:20 <pastorn> (not as many pretty pictures in RWH, though)
16:42:18 <keep_learning> pastorn, yes currently i am on 8th chapter of real world haskell
16:42:39 <keep_learning> pastorn, now just need more practise on haskell
16:42:53 <keep_learning> pastorn, may be solving more problems on online judges
16:43:05 <keep_learning> pastorn, but the problem is time limit
16:43:14 <keep_learning> pastorn, on online judges
16:43:19 <pastorn> keep_learning: ah, ok
16:43:29 <pastorn> btw, i think i saw this problem solved in LOLCODE
16:43:40 <pastorn> OBTW IT WAS AWESOME TLDR;
16:44:14 <argiopeweb> I CAN HAZ STDIO?
16:44:19 <argiopeweb> STDOUT*
16:44:25 <keep_learning> pastorn, thank you for your great advise
16:44:53 <keep_learning> pastorn, now i am going to logout so good bye
16:45:01 <keep_learning> good bye to all :)
16:45:03 <argiopeweb> 'night.
16:46:23 <argiopeweb> pastorn: I find it odd that people have a hard time working with the immutability concept when coming from the C(++)/Java.
16:47:05 <argiopeweb> Particularly from the OO side, if you're using the whole black-box concept like you should, it should be roughly the same.
16:47:21 <MatrixFrog> when you first see "x = x + 1" in C++/Java, it's crazy confusing
16:47:41 <jomo> hm... tryhaskell.org returning to me "Terminated" in every lesson
16:47:52 <MatrixFrog> but then you get used to it, and then the idea that you *don't* do that becomes confusing
16:47:57 <Kaidelong> argiopeweb: The trouble is that a lot of people don't use C++/Java to do OO
16:48:09 <aristid> MatrixFrog: it probably means that x is of a lazy Nat type, so you can represent infinity with x
16:48:17 <Kaidelong> in mean in theory yes, OO and pure functional programming boils down to two solutions for the same problem
16:48:34 <Kaidelong> but OO languages don't strictly enforce you to encapsulate your state
16:48:49 <KirinDave> Kaidelong: I thought the two systems were isomorphic when all was said and done?
16:48:59 <Kaidelong> They might be
16:49:00 <argiopeweb> Though it's highly recommended by anybody teaching the language.
16:49:27 <Sgeo> Isn't Seph slated to be an OO language with immutability
16:49:29 <Kaidelong> argiopeweb: In practice though, programmers go to great lengths to thwart OO in OO languages and program procedurally instead
16:49:39 <MatrixFrog> aristid: i mean in C++/Java. in that case it just means, take the value that's currently in x, add 1 to it, and then store the result in x
16:49:40 <Kaidelong> I have witness this first hand
16:49:45 <MatrixFrog> (usually)
16:49:54 <Sgeo> Well, almost immutability. It's possible to cheat, for some reason
16:50:13 <aristid> MatrixFrog: sounds pretty improbable
16:50:41 <MatrixFrog> well that's how it is in those languages :)
16:50:48 <aristid> Kaidelong: can you give an example?
16:50:49 <argiopeweb> Kaidelong: Based on the fact that I blame Java for being too OO oriented every day (to its own detriment), I'm likely guilty of the same thing.
16:51:02 <Kaidelong> aristid: using singletons for everything
16:51:12 <aristid> /o\ singetons
16:51:12 <argiopeweb> That's evil.
16:51:46 <Kaidelong> another one I saw was a person who made a single class for his whole program and did everything by passing around heterogenous arrays
16:52:10 <Kaidelong> essentially recreating foo(abitrary number of *s)
16:52:17 <argiopeweb> wow.
16:52:17 <monqy> was he a good programmer
16:52:18 <monqy> was he a good person
16:52:23 <argiopeweb> No, to both.
16:52:27 <Kaidelong> he thought he was
16:52:35 <Kaidelong> I slammed him in peer reviews
16:52:39 <argiopeweb> Good call.
16:52:42 <monqy> quite good
16:52:59 <aristid> Kaidelong: do you think people who are _actually_ good programmers try to thwart OOP, too?
16:53:15 <Kaidelong> no but I don't think the bulk of people who program are good programmers
16:53:22 <argiopeweb> That's a given.
16:54:08 <dankna> I think people who are actually good programmers thwart OOP by using languages that don't have it :)
16:54:28 <argiopeweb> dankna: Only in their spare time.
16:54:32 <dankna> true
16:54:42 <KirinDave> Ha
16:54:44 <KirinDave> OOP isn't bad.
16:54:49 <argiopeweb> dankna: And those of us who are entrepreneurs can as well.
16:54:50 <KirinDave> It just isn't as universally applicable
16:54:51 <dankna> no, it's not bad when it's appropriate
16:54:53 <ryant5000> argiopeweb: or if they work for Galois or me :)
16:54:55 <dankna> argiopeweb, indeed!
16:55:02 <Kaidelong> what I found most hilarious about that situation is that when I refactored his stuff using best practices (which wasted a lot of my time)
16:55:02 <Kaidelong> he complained about my "ravioli code"
16:55:03 <Kaidelong> because he couldn't be arsed to read the documentation I prepared for him
16:55:10 <Kaidelong> that's especially demoralizing because you end up not being motivated to document your code anymore
16:55:20 <argiopeweb> ryant5000: You rank yourself with Galois? :P
16:55:22 <dankna> indeed
16:55:23 <jmcarthur> it is my belief that if one was to distill OOP to its core, it would be purely functional
16:55:31 <ryant5000> argiopeweb: no, but people work for me and write in Haskell :P
16:55:32 <jmcarthur> of course that depends on how you define OOP...
16:55:35 <Eduard_Munteanu> I don't think it's bad either, it's just people thinking this concept is all there is.
16:55:40 <argiopeweb> ryant5000: Good enough. XD
16:55:43 <MatrixFrog> why do i feel like he just picked the name of a pasta and said "that's [whatever pasta] code"
16:55:54 <Kaidelong> KirinDave: I think the problem with OOP is that it is too complex in practice for people to grasp how to use it properly
16:55:59 <ryant5000> argiopeweb: there are a few others as well, of course
16:56:02 <Kaidelong> functional designs are simpler by comparison
16:56:06 <ryant5000> argiopeweb: are you starting a business as well?
16:56:21 <KirinDave> Kaidelong: I dunno if I buy that.
16:56:37 <Eduard_Munteanu> Yeah, and like jmcarthur, it's something that arises naturally, but some are inclined to think the particular form they're using in C++ or whatever is all there is to it.
16:56:39 <argiopeweb> ryant5000: In my spare time. I'm a graduate student working for the university, so not a lot happens that isn't in Java/C++.
16:56:52 <jmcarthur> i arise naturally?
16:56:58 <parcs> oop is nice to play with when you have mixins/traits
16:56:58 <KirinDave> Kaidelong: OOP lets you ignore a lot of problems and get further. They're still problems and you will face them, but often you can defer until later
16:57:04 <Eduard_Munteanu> In Haskell you pretty much have something more general than C++'s OOP, like arbitrary dispatching.
16:57:10 <Eduard_Munteanu> No, OOP concepts ;)
16:57:12 <jmcarthur> ah
16:57:15 <ryant5000> argiopeweb: that's too bad; how come you have to write in Java/C++? i'm surprised a grad school environment isn't more accepting when it comes to FP
16:57:19 <KirinDave> Kaidelong: Especially if the OO language has an easy way to make immutable instances.
16:57:21 <Eduard_Munteanu> *like jmcarthur says
16:57:39 <Kaidelong> KirinDave: But in practice, in the OOP/Imperative combination, problems that should be easy devolve into complicated "design patterns"
16:57:40 <KirinDave> ryant5000: Probably becuase historically fp implementations haven't been up to snuff for what a lot of people want to do.
16:57:46 <jmcarthur> i don't know that i'd say that, unless you are being as specific about what OOP means as i am thinking in my head
16:57:51 <Kaidelong> that might be more a problem with the languages in particular than OOP as a paradigm
16:57:57 <KirinDave> Kaidelong: Design patterns for OO aren't substantially different from design patterns for FP, man.
16:58:08 <Kaidelong> FP has design patterns?
16:58:14 <KirinDave> Kaidelong: Yes.
16:58:27 <Kaidelong> hmm, like which? Continuation passing maybe?
16:58:31 <KirinDave> Kaidelong: import Control.Monad and tell me that's not a pattern.
16:58:31 <argiopeweb> ryant5000: You and me both. We suffer from a lack of theoretical CS types and an over-abundance of folks who don't like change.
16:58:33 <Tyr42> I thought they were all abstracted out?
16:58:35 <jomo> hm... im pretty happy with Perl/Moose... and dont understand what is wrong with OOP...
16:58:42 <KirinDave> Kaidelong: patterns are just a vocabulary to describe the shape of programs.
16:58:46 <Eduard_Munteanu> The idiomatic design patterns in FP would be hylos, anas, catas, zygos etc. ;)
16:58:51 <jmcarthur> i don't believe in "object-oriented programming," actually. i only believe in the existence of objects
16:58:53 <Kaidelong> KirinDave: Ah okay, looking at it that way, it makes sense
16:59:06 <Eduard_Munteanu> I mean, stuff like recursion schemes, reactive FP etc.
16:59:07 <argiopeweb> jmcarthur: I concur.
16:59:12 <ryant5000> argiopeweb: well, i'm trying to change that :)
16:59:19 <ryant5000> (hence my company, iPwn Studios)
16:59:26 <argiopeweb> ryant5000: rofl... Great name.
16:59:28 <KirinDave> Kaidelong: Patterns are often misused prescriptively. THey're a devious trap that way, because someone says, "Oh yeah I'll just implement a visitor and maybe with IoC."
16:59:37 <Kaidelong> But things like the visitor pattern, strategy pattern, etc
16:59:40 <KirinDave> Kaidelong: And that sounds like the summation of a plan, but really it's more of an outline.
16:59:50 <ryant5000> argiopeweb: haha yeah, it's not easy to forget (you decide whether that's a good or a bad thing :P)
16:59:54 <KirinDave> Kaidelong: I think IoC and Visitor are on the order of Applicative and Monad.
17:00:06 <Obvioso> Good day #Haskell
17:00:06 <ryant5000> argiopeweb: we're developing a mobile phone RPG in Haskell
17:00:13 <Eduard_Munteanu> Heh, indeed many OOP patterns really try to deal with language limitations such as parametric polymorphism
17:00:20 <Eduard_Munteanu> *lack of
17:00:27 <KirinDave> Eduard_Munteanu: True.
17:00:31 <Kaidelong> or lack of higher order functions
17:00:38 <Eduard_Munteanu> Visitor = Traversable :)
17:00:49 <argiopeweb> ryant5000: I'm also attempting to change that, though I'm currently in the sole-proprietor position. Trying to push for more FP on the univ. side as well (meeting heavy resistance), but I personally still think I've come out ahead because I've convinced them that version control is a good thing...
17:01:04 <argiopeweb> ryant5000: Which platform?
17:01:10 * hackagebot tagged 0.2.2 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.2.2 (EdwardKmett)
17:01:18 <ryant5000> argiopeweb: iPhone at first, but also android and pretty much everything else
17:01:33 <KirinDave> ryant5000: I remember back in like 2003 some grad students tried to use several different fp environments for security analysis. Like realtime event recognition
17:01:37 <argiopeweb> ryant5000: How are you dealing with the haskell -> iphone interfacing issues?
17:01:41 <Obvioso> question: I'm starting haskell (Chpt. 1 lyah) and I've been trying out cycle and repeat functions
17:01:41 <Eduard_Munteanu> Plus my quarrel with C++ is it's too goddamn verbose.
17:01:49 <ryant5000> argiopeweb: version control is crazy to be missing
17:01:57 <ddarius> Eduard_Munteanu: Program in Java for a while.
17:01:58 <KirinDave> ryant5000: And the implementations were totally inadequate for the job. People were frustrated.
17:02:00 <ryant5000> argiopeweb: it's on Joel Spoolsky's 12 things list
17:02:06 <Tyr42> Obvioso: And?
17:02:10 <Twey> Obvioso: That's not a question ☺
17:02:15 <ryant5000> KirinDave: hm, i hadn't heard about that
17:02:16 <MatrixFrog> i love how there are beginner questions and advanced questions in here all at the same time
17:02:20 <Kaidelong> Eduard_Munteanu: C++ isn't so verbose if you're used to Java
17:02:22 <Eduard_Munteanu> Oh. I never did, so I don't know :)
17:02:26 <Kaidelong> oh
17:02:29 <Kaidelong> I got beaten to it
17:02:29 <Obvioso> I entered [0,3..], and it began to continue a loop I could not end without closing ghci
17:02:29 <KirinDave> ryant5000: I was at UCSB at the time.
17:02:32 <MatrixFrog> Obvioso: if you're just commenting, then... cool! hope you're having fun
17:02:47 <Obvioso> 2 part question, sorry
17:02:48 <ryant5000> argiopeweb: as for the iPhone interfacing issues: we wrote ghc-iphone, and we just use a small Objective-C wrapper to boot  up OpenGL and the other subsystems we need
17:02:48 <Twey> Obvioso: You can hit Ctrl-C to kill the currently executing expression.
17:02:53 <dons> blackdog_: umm. you getting a lot of traffic over this i guess? my blog is getting a ton of hits :}
17:02:53 <argiopeweb> ryant5000: That's what I thought when I got there. It's a lab that does internal and contract work that's associated with the university. They'd been doing "copy the folder and work on the new folder" version control for ~12 years before I got there.
17:02:56 <Tyr42> Obvioso:  Ctrl-C works to break out of it
17:03:04 <argiopeweb> ryant5000: And yeah, we score 2, maybe 3 on the Spolsky scale.
17:03:06 <KirinDave> ryant5000: How's that project going
17:03:08 <ryant5000> argiopeweb: wow
17:03:19 <Obvioso> Tyr42, Twey, and yall, thanks
17:03:26 <Kaidelong> > [0,3..]
17:03:27 <Obvioso> a simple solution
17:03:27 <lambdabot>   [0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,...
17:03:28 <ryant5000> KirinDave: it's going well; we've had a fun time building a game engine from scratch in Haskell :)
17:03:42 <MatrixFrog> good thing lambdabot is smart enough to write "..."
17:03:48 <KirinDave> ryant5000: Can the iphone handle the overhead of the haskell interpreter and keep your game responsive?
17:03:48 <argiopeweb> Seriously.
17:03:53 <MatrixFrog> otherwise we'd all be like "lambdabot: ctrl-C!"
17:03:54 <jmcarthur> smarts has little to do with it
17:03:57 <KirinDave> Or is that still an open question?
17:04:04 <ryant5000> KirinDave: nah, the performance is fine
17:04:12 * hackagebot reflection 0.3.5 - Functional Pearl: Implicit Configurations  http://hackage.haskell.org/package/reflection-0.3.5 (EdwardKmett)
17:04:12 <ryant5000> KirinDave: memory overhead is a bit more of a challenge
17:04:15 <Twey> Interpreter?
17:04:16 <djahandarie> The iPhone wouldn't be running an interpreter.
17:04:18 <Tyr42> :ryant5000 is it opensource?
17:04:21 <monochrom> actually I think you compile -fvia-C for iphone
17:04:22 <jmcarthur> lambdabot is basically doing just     (++"...") . take n . show
17:04:25 <ryant5000> Tyr42: yeah, ghc-iphone is BSD3
17:04:28 <KirinDave> Sorry, I misspoke
17:04:31 <KirinDave> the haskell environment and gc
17:04:34 <Kaidelong> ryant5000: what representation of game state do you use?
17:04:37 <ryant5000> monochrom: yes, we do; so we take a penalty
17:04:38 <argiopeweb> monochrom: fvia-llvm. ;)
17:04:40 <MatrixFrog> i like to think of it as smarts :)
17:04:47 <Tyr42> :ryant5000 I'm going to check that out now
17:04:50 <monochrom> not as slow as interpreted
17:04:52 <ryant5000> Kaidelong: it's reactive
17:05:00 <Kaidelong> I've gotten fond of the "time->display" and "(time->display)->(time->display
17:05:03 <Obvioso> Thanks, g-day
17:05:04 <Kaidelong> )" representations
17:05:09 <Kaidelong> ah must be similar to that then
17:05:24 <ryant5000> Kaidelong: it's tough to avoid space and memory leaks with such a straightforward representation, though
17:05:26 <Kaidelong> does it support networked multi-player?
17:05:32 <ryant5000> Kaidelong: no, not this version
17:05:40 <monochrom> a little bit overhead is fine as ios devices keep upgrading :)
17:05:44 <Kaidelong> reactive programming makes that easy
17:05:52 <ryant5000> our game is very quick action, and cellular networks aren't so great with that
17:05:53 <Kaidelong> so it should be fun to implement it
17:06:08 <Kaidelong> oh no plans for it then
17:06:22 <ryant5000> Kaidelong: not for this game; our next game may be multiplayer, though
17:06:30 <dankna> yeah - the thing with game development is always, well, this project is going to take two years before release; what do we expect the hardware specs to be at that time?
17:07:02 * Kaidelong did something like this for his networking class
17:07:09 <Eduard_Munteanu> Then again C is quite verbose too (less I think), but it's in the right setting.
17:07:12 <dankna> and do we expect this platform to still be relevant by then?  fortunately the iPhone is in a sweet spot between game consoles and computers in that you don't have to worry about back-compatibility going away.
17:07:23 <Eduard_Munteanu> I kinda like it there.
17:07:52 <ryant5000> dankna: yeah; also, our game is quite portable, as the vast majority of it is in Haskell
17:08:00 <Kaidelong> you had actions in a buffer in chronological order, if another player does something, update the game state when it is received by building a new "time -> display" and calculating for the current game
17:08:56 <dankna> ryant5000: although that helps a great deal, and you are to be congratulated for it, it's certainly also true that if you aren't tailoring your graphical and sound effects to precisely as much as the hardware can support, you're making a strategic mistake, and in that sense you're more closely coupled to it than you may realize
17:08:58 <Kaidelong> each action is basically something in the form of (time->display)->(time->display)
17:08:59 <argiopeweb> Eduard_Munteanu: C does what it is designed to do quite well. C++ is as verbose as necessary, and slightly more so in the Boost libraries. Java took the OO idea too far and became verbose everywhere. (IMHO)
17:09:32 <Kaidelong> you can work around space issues by cheating on the time part and not accounting for times before the time of the latest action
17:10:02 <argiopeweb> Kaidelong: how are you keeping track of time?
17:10:04 <ryant5000> Kaidelong: yeah; it's tougher than it seems to get all that stuff just right, though
17:10:12 * hackagebot eq 0.3.2 - Leibnizian equality  http://hackage.haskell.org/package/eq-0.3.2 (EdwardKmett)
17:10:24 <Kaidelong> argriopeweb: I think I used real time to do it
17:10:28 <ryant5000> dankna: yeah; we're not trying to compete with Unreal on graphics
17:10:32 <Kaidelong> so an Int64
17:10:38 <dankna> ryant5000, yeah - you have to strike a balance obviously
17:10:49 <jmcarthur> you can get away with fairly simple representations if you manage to find exactly the right data to store in closures and which to defunctionalize
17:10:50 <dankna> demand the utmost of the hardware, because your competitors will
17:10:53 <dankna> but no more than that :)
17:10:58 <Kaidelong> I have a paper on it lying around somewhere, I implemented the network protocol for it and ran some tests on it to show it worked, but I never put graphics over it
17:11:26 <Kaidelong> IE I showed that all the players eventually have a consistent game state
17:11:27 <ryant5000> dankna: indeed; however, i think with a platform like PS3, Haskell couldh ave a huge advantage
17:11:32 <Kaidelong> even if there is lag
17:11:43 <jmcarthur> the most important thing is to simply avoid accumulating information over time using function composition
17:11:54 <dankna> ryant5000: I could see that.  How do you mean?
17:12:03 <jmcarthur> parallelism?
17:12:04 <argiopeweb> Kaidelong: How did you establish time-0 and adjust for clock drift?
17:12:15 <ryant5000> dankna: one of the biggest issues with the PS3 is that it's difficult for programmers to take advantage of 9 cores of 2 different varieties
17:12:34 <Kaidelong> argiopeweb: I don't recall paying attention to that. Perhaps you just pointed out a fundamental flaw in my design
17:12:54 <Kaidelong> if all the clocks are consistent then the game is consistent but otherwise it might not be
17:12:55 <argiopeweb> Kaidelong: I'm a distributed simulation type: these things will come back and bite you.
17:13:00 <Kaidelong> wait hmm
17:13:10 <dankna> ryant5000: btw - you mentioned you're using OpenGL.  which of the extant bindings to it are you using, or are you using your own, and are you aware of pastorn's upcoming attempts to do a better one for Google Summer of Code?
17:13:31 <ryant5000> dankna: we have some C-side stuff to do the final rendering, so we use straight OpenGL
17:13:40 <Kaidelong> no it'll still be eventually consistent because even if one of the machines has the wrong time, it reports its time as an integer to the other machines, so so long as they *honestly* report what the time is, the game will look consistent in the end
17:13:43 <dankna> ryant5000: hmmm yes, that /would/ be difficult for people not used to Haskell :)
17:13:47 <Eduard_Munteanu> Hrm, that Leibnizian equality looks a lot like extensional equivalence.
17:13:49 <Kaidelong> the time is for them*
17:13:52 <ryant5000> dankna: indeed :)
17:14:08 <Eduard_Munteanu> Or is it different?
17:14:10 <dankna> ryant5000: ah - okay.  so you pass your culled scene graph across the FFI boundary.  well, that's fair.
17:14:26 <Eduard_Munteanu> subst :: forall c. c a -> c b
17:14:30 <Eduard_Munteanu> Hrm, forall c
17:14:32 <ryant5000> dankna: yeah; it lets us avoid some issues with Haskell performance
17:14:34 <argiopeweb> Kaidelong: So they base their view of time passing on other machines as (other machine's reported time - other machine's last reported time)?
17:14:41 <dankna> sorry, I don't mean to be too nosy; obviously at some point this line of questioning gets into proprietary information.  but I'm curious.
17:14:45 <argiopeweb> As opposed to comparing it to their idea of time
17:15:12 <Kaidelong> they just have their own local time, and calculate what the game state is based on what other machines reported they did at time T
17:15:21 <jmcarthur> i still haven't decided for myself where to ideally place the FFI boundary in my graphics pipelines
17:15:48 <argiopeweb> So if you have a machine that is 5 seconds ahead, do its actions happen 5 seconds after they should on the other machines with -5 second view of time?
17:16:06 * Kaidelong thinks about this
17:16:13 <Kaidelong> oh
17:16:14 <Kaidelong> yes
17:16:17 <ryant5000> dankna: no problem :) basically, the stop-the-world GCs that happen every minute or two are pretty obvious; by rendering in a C thread, we can render smoothly regardless
17:16:47 <Kaidelong> and if that machine sends stuff that happens in the future, the game shouldn't crash but it might behave oddly due to how I was optimizing for space
17:16:48 <dankna> jmcarthur: for my NES emulator (but it has very modest rendering needs), the architecture I'm moving towards is keeping almost everything on the Haskell side, exposing each state object via StablePtrs so that the non-Haskell GUI can still manage the lifetime of those objects, but not see inside them
17:17:11 <ryant5000> dankna: how come you're writing the gui in non-haskell?
17:17:14 <dankna> ryant5000, yes, that makes sense
17:17:16 <Kaidelong> but it was a cooperative setting, so I trusted clients to report their own deaths
17:17:30 <dankna> ryant5000: well, I'm targetting the desktop Mac :)
17:17:33 <jmcarthur> dankna: i mean in the sense of how many FFI calls i'm performing on each frame
17:17:45 <dankna> jmcarthur: oh.  roughly two to five, in my case.
17:17:46 <ryant5000> dankna: ah, ok that makes perfect sense
17:18:02 <ryant5000> dankna: hopefully someday someone will rehabilitate the Haskell to Objective-C bindings
17:18:04 <jmcarthur> dankna: yeah, if you were using the opengl bindings you'd be doing waaaay more than that
17:18:05 <dankna> ryant5000: hehe, good.  I was about to explain that HOC is unmaintained and although I have my own project direct-cocoa to replace it
17:18:16 <dankna> (because I have dug around extensively inside HOC and find it not worth salvaging)
17:18:22 <Kaidelong> so if it had graphics you might see another player die for apparently no reason, or stay alive where they should have died and suddenly teleport, or stay alive where they should have died and then die after a delay
17:18:28 <argiopeweb> Kaidelong: Again, that stuff becomes a concern in the massively distributed sim setting. Your ideas could probably be pretty easily combined into some of the standard models to fix it though.
17:18:32 <ryant5000> dankna: yeah, we did the same digging, i think
17:18:35 <dankna> ... that although I have my own project, I don't want to make this one depend on that one because then I'll never finish
17:18:39 <dankna> heh, figures :)
17:18:44 <argiopeweb> As long as everyone agrees on some form of measuring and updating time, it's generally okay.
17:18:57 <ryant5000> dankna: yeah, those kind of dependencies can be killer
17:19:14 <jmcarthur> dankna: i've been writing everything in haskell so far, but it's very likely that all the FFI bandwidth might hurt me too much
17:19:15 <dankna> do get in touch if at any point in the future you want to collaborate on direct-cocoa though, I'd love to see it finished
17:19:26 <jmcarthur> well, i won't say *likely*, but it's certainly possible
17:19:43 <Kaidelong> argiopeweb: I recognize that it probably has some problems, but it was beautifully elegant at the time, so I was rather chuffed at it
17:19:44 <ryant5000> dankna: that could be very useful to us at some point; right now, we're 100% opengl, so we don't touch obj-c very much at all
17:19:53 <ryant5000> dankna: though that's partially due to the lack of decent bindings
17:19:55 <jmcarthur> at least i'm using buffer objects etc. that helps a lot
17:20:00 <dankna> the major difference from HOC so far is that I base the generated bindings on a combination of the data in Apple's XML file that I forget the name of, and the stuff that's available through reflection, because neither is complete
17:20:04 <dankna> HOC uses only the latter
17:20:16 <dankna> the other major difference from HOC is that it's not finished :)
17:20:18 <argiopeweb> Kaidelong: And it worked for the environment you were using it in, which is more important.
17:20:18 <Kaidelong> I also had no way to account for dropped actions
17:20:26 <Kaidelong> I had a way to account for actions arriving out of order
17:20:30 <jmcarthur> maybe i should rethink this. i bet the number of FFI calls is much lower than i was originally figuring...
17:20:31 <ryant5000> dankna: and, another difference, presumably, is that yours builds :P
17:20:31 <Kaidelong> but not for them being dropped
17:20:39 <argiopeweb> Kaidelong: I wouldn't think of implementing the systems I use for sims in a game. Lag would make it unplayable.
17:20:39 <Kaidelong> that'd have been simple to add in though
17:20:41 <dankna> ryant5000: yes, it does, haha :D
17:20:56 <Kaidelong> if there is a "gap" somewhere you could just request the other machiens to resend that action
17:21:13 * hackagebot representable-functors 0.4.2 - Representable functors  http://hackage.haskell.org/package/representable-functors-0.4.2 (EdwardKmett)
17:21:35 <dankna> ryant5000: the open problem is what to do about the fact that in ObjC 2.0 with GC turned on you have a GC on both sides of the FFI - cycles that cross the FFI will not be collected and have to be broken by explicit state management
17:21:35 <ryant5000> Edward Kmett has really been churning out the updates for the last few days
17:21:48 <jmcarthur> ryant5000: oh this is normal :P
17:21:55 <ryant5000> haha
17:22:29 <ryant5000> dankna: yeah; i tried to write a haskell binding for spidermonkey (firefox's erstwhile javascript engine) and ran into the same problem
17:22:41 <dankna> ryant5000: yes.  indeed so.
17:22:56 <ryant5000> dankna: i think there needs to be a hook in the GC
17:23:01 <dankna> ryant5000: I'm leaning towards a lightweight "solution" that just gives the user the ability to manage lifetime manually from both sides
17:23:07 <blackdog_> dons: yeah. i did something really dumb and moved my blog onto the same box as jenkins
17:23:10 <blackdog_> OOM-ahoy!
17:23:13 <dankna> ryant5000: because yes, otherwise you can't do it without delving into GC internals on at least one side, possibly both
17:23:22 <ryant5000> i think haskell's side would probably do
17:23:39 <dankna> ryant5000: Apple's GC /is/ open-source though, so that's something.  but it can't be hooked without binary patching or something similarly nasty.
17:23:48 <blackdog_> dons: is weird to get so much traffic for something so little
17:23:48 <ryant5000> yeah
17:23:52 <dankna> (since it's part of libSystem)
17:24:13 * hackagebot void 0.5.1 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.1 (EdwardKmett)
17:24:24 <dankna> what are you thinking the hook could be, though?
17:25:09 <dankna> you can already create additional GC roots no problem by using StablePtrs; that's not the hard part
17:25:34 <dankna> you could disable GC on the ObjC side and give the GHC RTS the ability to collect ObjC objects...
17:25:41 <dankna> would be substantial coding but not impossible
17:25:51 <ryant5000> dankna: i think it would be sufficient if you could add a function to each ForeignPtr that enumerates all the StablePtrs contained 'within' that ForeignPtr
17:25:57 <dankna> hm!
17:26:11 <dankna> that's a very interesting thought
17:26:12 <ryant5000> even if that function had to be written in C, that wouldn't be so bad
17:26:13 * hackagebot adjunctions 0.9.2 - Adjunctions  http://hackage.haskell.org/package/adjunctions-0.9.2 (EdwardKmett)
17:26:15 * hackagebot representable-tries 0.3.4 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-0.3.4 (EdwardKmett)
17:26:23 <dankna> well, the GC is already written in C, I believe
17:26:25 <dankna> most of the RTS is
17:26:27 <ryant5000> right
17:26:42 <dankna> oh, right, I see what you mean
17:26:57 <Obvioso> question: In reading lyah there is a word in a scentence I cant figure out "The part before the pipe is called the output function". What is the pipe?
17:27:08 <ryant5000> in SpiderMonkey, it's not terribly difficult to enumerate everything that's reachable from an object
17:27:10 <dankna> so you would break the cycles forcibly from the Haskell end
17:27:14 * hackagebot kan-extensions 0.2 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-0.2 (EdwardKmett)
17:27:19 <ryant5000> dankna: exactly
17:27:27 <MatrixFrog> Obvioso: do you have a link to the chapter you're on?
17:27:30 <dankna> which would leave the ObjC side with StablePtrs that don't work, but because the objects containing them are dead, it's okay!
17:27:33 <MatrixFrog> they probably mean this character: |
17:27:41 <Obvioso> yah http://learnyouahaskell.com/starting-out
17:27:56 <ryant5000> dankna: yep
17:27:58 <argiopeweb> Obvioso: Probably refers to the '|' character, without looking at it.
17:28:01 <MatrixFrog> yeah, pipe is just the name of the character |
17:28:03 <ryant5000> ideally, you could have some mutual recursion thing
17:28:05 <Eduard_Munteanu> Yeah it's '|'
17:28:07 <ryant5000> might be more efficient
17:28:08 <argiopeweb> I.E. what MatrixFrog said.
17:28:12 <dankna> okay, so your Haskell-side table of ObjC objects which are referenced from Haskell needs to have the following semantics:
17:28:15 <ryant5000> but that would require that both GCs are developed with that in mind
17:28:21 <MatrixFrog> you could point out to the author that people might not know that...
17:28:22 <Obvioso> cool, thanks
17:28:35 <MatrixFrog> i made some small comment to him one time and he was like "good point, i'll fix that soon"
17:28:38 <dankna> yeah; we don't have the luxury of controlling the ObjC GC, if we want to interoperate with third-party binary libraries
17:28:46 <ryant5000> dankna: yeah
17:29:14 * hackagebot semigroupoid-extras 0.2.3 - Semigroupoids requiring Haskell extensions  http://hackage.haskell.org/package/semigroupoid-extras-0.2.3 (EdwardKmett)
17:30:33 <argiopeweb> Wasn't work being done on a concurrent GC at some point?
17:30:41 <RichardO> Can anyone point me to resources on lazily creating a DAG in haskell?
17:31:08 <dankna> argiopeweb, while that would be nice for many reasons, it is unfortunately not relevant to this problem.  even research into distributed GC isn't :(
17:31:12 <edwardk> argiopeweb: it'd be a rather invasive change
17:31:33 <ryant5000> aren't certain GCs done concurrently now?
17:31:36 <argiopeweb> dankna: Unrelated to your conversation. ;)
17:31:36 <ryant5000> just not all of them
17:31:47 <Obvioso> Q: What doen this "<-" and "<=" mean?
17:31:56 <argiopeweb> Obvioso: -> and =>?
17:32:02 <MatrixFrog> RichardO: i don't know but i imagine it would be sort of similar to creating a tree
17:32:04 <argiopeweb> (direction is important)
17:32:20 <edwardk> <- is used in do sugar and pattern guards. <= is just 'less-than-or-equal'
17:32:28 <Obvioso> argiopeweb, ghci> [x*2 | x <- [1..10], x*2 >= 12] like in this line
17:32:37 <argiopeweb> Ah, pattern guards.
17:32:43 <argiopeweb> And less than or equal.
17:32:47 <Obvioso> I'm not understanding the relation
17:32:51 <ChiliCanoli> anyone know where i can make some serious cash online?
17:32:56 <argiopeweb> Damn you edwardk. Foresight isn't fair.
17:32:59 <edwardk> Obvioso: >= is just a comparison, <- can be read as 'element of' or 'drawn from'
17:33:01 <dankna> ChiliCanoli: try Photoshop
17:33:08 --- mode: ChanServ set +o jmcarthur
17:33:13 <MatrixFrog> RichardO: where a "Node a" contains an "a" plus a list of other nodes
17:33:14 <djahandarie> Obvioso, x*2 >= 12 evaluates to a boolean.
17:33:27 --- mode: jmcarthur set +q *!*@c-24-0-71-119.hsd1.nj.comcast.net
17:33:30 <MatrixFrog> "x times 2 is greater than or equal to 12"
17:33:32 --- mode: jmcarthur set -o jmcarthur
17:33:46 <dankna> oh nice, I didn't know about +q
17:34:05 <edwardk> Obvioso: what that is saying is that you want the squares of all of the elements drawn from the list [1..10] such that twice the number is greater than or equal to 12
17:34:15 <jmcarthur> i prefer to use +q so that they can still leave and come back and be able to read
17:34:22 <edwardk> > [ x | x <- [1..10]
17:34:23 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:34:31 <edwardk> > [x | x <- [1..10]]
17:34:31 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
17:34:34 <Eduard_Munteanu> edwardk: hey, I just saw your Leibnizian eq thingy, is it some form of extensional equality?
17:34:50 <Eduard_Munteanu> (or equivalence)
17:35:17 <edwardk> Eduard_Munteanu: leibnizian equality is just that a == b if for all predicates P, P(a) == P(b) — now, replace P with anything of kind * -> *
17:35:22 <argiopeweb> > [x | x <- [1..10], even x]
17:35:23 <lambdabot>   [2,4,6,8,10]
17:35:23 <Obvioso> thanks
17:35:33 <Obvioso> I think I've got it
17:35:38 <RichardO> MatrixFrog: I think I need to incorporate memoization to know whether or not I have crossed a node.
17:36:09 <Eduard_Munteanu> Hrm, so it's for all such P's, quite a bit different from setoid / extensional stuff.
17:36:14 <edwardk> list comprehensions like that consist of drawing elements from lists and using predicates to filter
17:36:19 <edwardk> Eduard_Munteanu: yeah
17:36:19 <MatrixFrog> yeah, i don't really know... i remember there was someone trying to write a git library in haskell...
17:36:35 <MatrixFrog> which obviously involves a DAG. i can't remember where i saw it, maybe github
17:36:43 <edwardk> http://www.ags.uni-sb.de/~cp/p/eq2.html
17:36:51 <edwardk> note the continuum
17:37:17 <Eduard_Munteanu> Does such an equality even exist in general? Or do you assume type operator injectivity, or stuff like that?
17:37:29 <edwardk> well, consider
17:37:52 * Eduard_Munteanu looks
17:38:06 <edwardk> newtype a := b = Refl { subst :: forall f. f a -> f b }
17:38:22 <edwardk> you can obviously build one such definition
17:38:33 <edwardk> refl :: a := a ; refl = Refl id
17:39:05 <edwardk> using subst on refl you can build up transitivity and with a little trickery, you can get symmetry
17:39:27 <Obvioso> I dont know boolean algebra, would it be a good idea to go over that before continuing learning haskell?
17:39:45 <edwardk> Obvioso: i wouldn't worry too much about it
17:41:15 * hackagebot ad 1.0.5 - Automatic Differentiation  http://hackage.haskell.org/package/ad-1.0.5 (EdwardKmett)
17:41:25 <MatrixFrog> i agree. you'll figure it out as you go
17:41:36 <Eduard_Munteanu> Hrm, that looks true even if I take f :: * -> *, f = const \bot, so you don't need it injective after all right?
17:42:22 <edwardk> Eduard_Munteanu:  correct. you don't need much of anything out of f. just its kind.
17:42:30 <dankna> ryant5000: anyway, thanks for the thoughts on GC, I'll definitely try to use your idea whenever I get back to that project
17:42:35 <argiopeweb> Obvioso: If boolean algebra is the worst of you're worries, you're doing pretty well.
17:42:37 <edwardk> it can be covariant, contravariant, invariant, anyvariant, what have you
17:43:15 * hackagebot categories 0.55.2 - categories from category-extras  http://hackage.haskell.org/package/categories-0.55.2 (EdwardKmett)
17:43:55 <Eduard_Munteanu> edwardk: still it works only for stuff of the same type, because if you have different types I suppose f could map 'b' to \bot and everything else to \top, in which case it's uninhabited
17:44:00 <djahandarie> It's already at 0.55.2??
17:44:01 <ryant5000> dankna: i'd love to see how it comes out :)
17:44:02 <edwardk> Eduard_Munteanu: i think the scala version is slightly more interesting because then variance can enter into the equation
17:44:24 <Obvioso> cool. Ya I'm getton on well in haskell, but I'm still on chapter one in lyah
17:44:28 <sshc> Can a library directly depend on monads-tf and indirectly on mtl?  (For example, a package uses monads-tf, but wants to use fclabels, which depends on "mtl")
17:44:41 <edwardk> Eduard_Munteanu: sure. its just a way of carrying around witnesses for ~. you can just as well rely on GADTs to do it for you
17:44:43 <sshc> (mtl conflicts with monads-tf because they export different modules with the same name)
17:44:53 <argiopeweb> Obvioso: It's a very logical language if you think about it, once you wrap your mind around its few oddities.
17:45:00 <edwardk> data a := b where Refl :: a := a — would work just as well
17:45:11 <Eduard_Munteanu> Ah, the Agda way.
17:45:27 <edwardk> then instance Category (:=) where id = Refl; Refl . Refl = Refl — is trivial
17:45:44 <Eduard_Munteanu> Thanks, makes sense now.
17:45:50 <edwardk> the liebnizian version is interesting because it doesn't require any deep compiler mojo
17:46:20 <Obvioso> I've only programmed in click'n'play and Qbasic before now taking on a more aplicable language as haskell
17:46:28 <edwardk> except rank 2 types
17:46:33 <dolio> It requires impredicativity.
17:46:48 <Eduard_Munteanu> Hrm, yeah.
17:47:09 <edwardk> that and there is already a haskell package providing the GADT version
17:47:27 <djahandarie> It requires impredicativity?
17:47:29 <edwardk> so while i flipped over to a traditional GADT version for a while, i flipped it back
17:47:30 <argiopeweb> Obvioso: Well, coming from QBasic you'll get a chance to kill all your bad habits. If you went straight to something in the C world (C, C++, Java, etc) you wouldn't necessarily be forced to kill the bad habits, and you might pick up some more that would make haskell more difficult to pick up.
17:48:00 <argiopeweb> Flip side is, if you do ever choose to learn C/C++/Java, you're going to spend all your time wishing you were programming in Haskell.
17:48:29 <dolio> djahandarie: Yes.
17:48:52 <Obvioso> argiopeweb: well I didnt commit to Qbasic enough to pick up any real habbit I think. That was way back in highschool computer class
17:48:59 <dolio> Unless you want your equality to inhabit a higher universe.
17:49:12 <djahandarie> Would that be bad?
17:49:12 <argiopeweb> Obfuscate: The worst one is goto. Once you get goto out of your system, you're cool.
17:49:32 <Obvioso> but I still picked up enough to understand programming concepts
17:49:37 <pikhq> argiopeweb: And then you get to add it back when you're well-aware that it's evil! :P
17:49:37 <dolio> djahandarie: Yes. It would be impossible to define transitivity and symmetry that way.
17:50:14 <argiopeweb> pikhq: I have not programmed a single thing that used goto in the past decade. I had to go to great pains to do it on occasion, and I've seen others do it, but I myself have not done so.
17:50:29 <djahandarie> Ah
17:50:42 <pikhq> argiopeweb: The thing is, I sometimes write code for the sake of writing evil code.
17:50:59 <pikhq> And in those contexts, goto and computed goto are absolutely *wonderful*. :P
17:51:24 <argiopeweb> pikhq: Ah, obfuscated code days.
17:51:30 <argiopeweb> This I can see.
17:51:32 <MatrixFrog> pikhq: http://www.ioccc.org/ ?
17:51:36 <dmwit> Fear not. Evil code is perfectly possible in Haskell, as well.
17:52:02 <argiopeweb> dmwit: Examples are necessary.
17:52:04 <pikhq> Heck, even goto is *possible* if you really want it.
17:52:33 <pikhq> Actually, you can get some truly sadistic flow control going on if you work on it.
17:52:36 <dmwit> mauke shared this with us the other day: http://mauke.dyndns.org/stuff/haskell/hell.hs
17:52:37 <luite> hmm, I've used goto in C for deallocating stuffs
17:53:14 <pikhq> I seem to recall combining state and continuation monads into a time travel monad.
17:53:25 <MatrixFrog> why does Int go to 2^29 rather than 2^32 or so?
17:53:31 <luite> and the result was reasonably clear... I coudn't think of a better way of doing it without goto
17:53:42 <luite> MatrixFrog: that's just the guaranteed range
17:53:42 <dibblego> is this Monad instance possible? http://paste.pocoo.org/show/385582/
17:53:56 <MatrixFrog> luite: still a weird guarantee don't you think?
17:53:58 <argiopeweb> dmwit: I really want to know what that does, and I really don't want to run it on my computer. XD
17:54:03 <luite> MatrixFrog: and that's because two bits might be used for tagging
17:54:09 <dankna> MatrixFrog: to create the possibility of using up to three bits for a type tag (although I believe GHC's ints actually do go to 2^32)
17:54:12 <pikhq> MatrixFrog: The *practical* reason is that that allows implementations to "tag" ints using the high bits.
17:54:23 <MatrixFrog> oh ok. sooo what does that mean?
17:54:59 <Eduard_Munteanu> It means "use Int32 if you really want 32-bit ints portably" I think :)
17:55:09 <MatrixFrog> right, but i mean, what is tagging?
17:55:12 <joe6> how can I import a bunch of modules at ghci prompt? I start with "ghci -Wall" and then run the import command on each module. Just curious, if we can import a bunch of modules in one command?
17:55:20 <MatrixFrog> i googled haskell tag but what i found doesn't seem to be what you guys are talking about
17:55:22 <pikhq> MatrixFrog: In some garbage collector designs, you tag integers and pointers so they look different.
17:55:31 <dankna> MatrixFrog, let me find you a survey paper on garbage-collection
17:55:34 <argiopeweb> MatrixFrog: Say I make a hardware platform that supports Haskell, and I have a 32 bit bus. I have to be able to box my values, so I put a tag on them, but I don't want them larger than 32 bits, so I make them 29 bit integers with 3 bit tags.
17:55:35 <luite> MatrixFrog: that ghc could use two bits to determine what kind of thunk is stored at that location, whether it is evaluated for example
17:55:39 <Eduard_Munteanu> MatrixFrog: various information for the RTS, e.g. whether the thunk has been evaluated
17:55:48 <MatrixFrog> oh ok
17:56:12 <pikhq> It's pretty much an implementation-specific detail.
17:56:17 <dankna> Paul R. Wilson, "Uniprocessor garbage collection techniques", 1994.  that's all the bib data I have.
17:56:20 <MatrixFrog> yeah, makes sense. cool. thanks
17:56:39 <dankna> great paper, provides a very comprehensive description of various strategies
17:56:55 <dankna> I don't think it mentions the strongly-typed approach that GHC uses, though :)
17:56:56 <joe6> :m +, got it
17:57:43 <MatrixFrog> do people use unsigned integer types much?
17:57:59 <MatrixFrog> for things that can never be negative anyway it seems like a good idea
17:58:01 <dmwit> Not as much as they ought to.
17:58:04 <Eduard_Munteanu> MatrixFrog: they do make sense in some cases, like binary data
17:58:36 <Eduard_Munteanu> Though it's not usually mandatory to do so.
17:58:56 <Eduard_Munteanu> It's just usual practice.
18:00:13 <Eduard_Munteanu> Have you guys ran into any languages where memory allocation is inferred at compile-time, perhaps a type-oriented approach?
18:00:31 <Eduard_Munteanu> Something like manual memory management but automated.
18:00:37 <dankna> no, I haven't
18:01:09 <argiopeweb> You see it happen a lot with C in hard realtime environments, but I haven't seen it outside of that. And it's less of a language feature and more of a compiler feature.
18:01:12 <dolio> Regions try to do that, in a way.
18:01:28 <dolio> How successful it is is questionable.
18:01:46 <danharaj> if you wanted to do that with recursion, you would need to prove complexity theoretic results, no?
18:02:00 <Eduard_Munteanu> Yeah, though that's a bit different approach, regions usually try to turn allocations into stack data.
18:02:18 <danharaj> Hard realtime system designs like to ban recursion.
18:02:20 <Eduard_Munteanu> Or allocate slabs instead of GCing.
18:02:33 <argiopeweb> danharaj: Indeed.
18:02:50 <argiopeweb> And most of the other things that make life fun.
18:02:56 <danharaj> heh
18:03:14 <danharaj> well when your code is keeping a 500 million dollar aircraft in the air, you don't have room to have fun :p
18:03:25 <argiopeweb> And their memory modellers are seldom entirely accurate; it's mainly a "Can we guarantee that this will run us out of memory? if yes, die()"
18:03:36 <argiopeweb> danharaj: The story of my life.
18:03:36 <Kaidelong> Eduard_Munteanu: I think some people tried to do that with Haskell but ran into problems
18:03:49 <Eduard_Munteanu> Dependent types seem to be able to specify that sorta stuff.
18:03:49 <Kaidelong> JHC might have included an attempt at it
18:03:58 <Eduard_Munteanu> Yeah, I know about JHC.
18:04:18 * hackagebot recursion-schemes 0.4.3 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-0.4.3 (EdwardKmett)
18:05:22 <edwardk> region allocation and lazy languages sadly don't mix
18:05:31 <argiopeweb> Edward Kmett, bringing you zygohistomorphic prepromorphisms since version 0.2.2
18:05:41 <danharaj> edwardk: that's why Disciple :p
18:05:43 <Axman6> So, i've just done some testing with the IterIO package, and damn it's fast!
18:05:54 <danharaj> You know what is awesome about IterIO? dependency hell.
18:06:01 * danharaj pauses to think
18:06:18 <Axman6> yeah i have a feeling that will get fixed by splitting it into different packages
18:06:21 <Axman6> i hope so anyway
18:06:25 * argiopeweb waits for danharaj to finish his GC cycle
18:06:35 <Eduard_Munteanu> I've always felt like GC was a suitable/easy but somewhere deeply the wrong way approach.
18:06:46 <edwardk> my flurry of packages the last 24 hours or so has been basically from trying to fix up my own internal depedency hell ;)
18:06:48 <Eduard_Munteanu> If only there was an alternative.
18:07:35 <danharaj> edwardk: Just don't mess with Tagged. I use it :p
18:07:48 <danharaj> WAIT YOU DID
18:07:51 <danharaj> :O :O :O
18:07:52 <edwardk> danharaj: i inverted a dependency on semigroups
18:08:07 <danharaj> Why does it depend on semigroups now :[
18:08:39 <Axman6> anyway, all I've written is a repimplementation of tee, and it is only about 30% slower than the original tee
18:08:44 <edwardk> because i was pushing semigroups down lower in the dependency chain
18:09:32 <danharaj> edwardk: In my opinion, it's such a basic and self-contained library that it should only depend on base and data-default.
18:09:51 <edwardk> danharaj: understandable. but a similar argument can be made for semigroups
18:09:52 <argiopeweb> Axman6: Have you done any testing/do you know of any testing benchmarking IterIO against the current standard IO systems?
18:09:54 <edwardk> so someone loses =P
18:10:18 <Axman6> awell, this is the only test I've done
18:10:22 <Axman6> argiopeweb*
18:10:30 <Axman6> i haven’t seen any benchmarks yet
18:10:40 <Axman6> waiting for dons to get on it :P
18:10:41 <argiopeweb> You tested with old vs. IterIO?
18:10:42 <danharaj> Is it too ugly to merge the dependency into tagged and pretend it doesn't depend on semigroups?
18:10:48 <argiopeweb> hehe... If in doubt, wait on dons.
18:10:59 <edwardk> yes
18:11:07 <danharaj> fair enough
18:11:22 <danharaj> also another point: you should have made the map for contravariant functiors pamf ;)
18:11:31 <edwardk> =P
18:11:41 <edwardk> that never ends well
18:11:53 <danharaj> what about those bastards who reverse cons as snoc
18:12:08 <argiopeweb> Who does that?
18:12:12 <edwardk> i'm willing to give that one
18:12:13 <edwardk> ;)
18:12:15 <danharaj> anyone who talks about snoc lists.
18:12:56 <Axman6> so my testing against the Iteratee package seems to show that IterIO does a much better ho\b
18:12:59 <Axman6> job*
18:13:18 <Axman6> as in i get 14MB/s throughput with Iteratee, and 1GB/s with IterIO
18:13:23 <Axman6> something feels wrong though
18:13:23 <argiopeweb> Man.
18:13:26 <argiopeweb> That's insane.
18:13:31 <argiopeweb> And yeah, that seems wrong.
18:13:51 <Axman6> but for reference, the native tee does 1.5GB/s
18:13:57 <edwardk> danharaj: i inverted the dependencies from semigroups on tagged and void. this made it so 20+ packages lost a dependency on them
18:14:06 <Axman6> wait... or it did... hmm
18:14:14 <danharaj> edwardk: You are presuming I care about anybody beyond myself :)
18:14:21 <argiopeweb> Axman6: What size file are you using? You shouldn't be able to sustain 1.5gb/s without a pretty crazy drive setup.
18:14:35 <ddarius> danharaj: It's not like "cons" was all that great a name to begin with.
18:14:39 <argiopeweb> Unless you're referring to the horizontal part of the T, in which case it makes sense.
18:14:40 <Axman6> reading in from /dev/zero ;)
18:14:42 <edwardk> danharaj: well, given that 19 of those were mine... you are presuming i care about anybody beyond myself =)
18:14:42 <danharaj> ddarius: I agree.
18:14:45 <dibblego> edwardk: is this a monad? http://paste.pocoo.org/show/385582/
18:14:47 <Axman6> and writing tyo /dev/null
18:14:57 <danharaj> edwardk: Hey, once you put something on Hackage I reserve the right to bitch at you <3
18:15:18 <edwardk> dibblego: looks like an iteratee
18:15:28 <dibblego> edwardk: yes, how does the monad look?
18:15:28 <argiopeweb> ddarius: Eh, "cons"truct... I get it...
18:15:33 <edwardk> dibblego: so, yes
18:15:41 <edwardk> i have a slide deck that describes it
18:15:51 <edwardk> modulo typos, one sec
18:15:55 <Eduard_Munteanu> dibblego: one can't say unless '>>=' is implemented ;)
18:16:13 <edwardk> dibblego: check http://comonad.com/reader/wp-content/uploads/2009/08/A-Parsing-Trifecta.pdf
18:16:17 <dibblego> I keep going down a wrong path trying to implement it
18:16:19 <dibblego> ta
18:16:33 <geheimdienst> > (\(x:xs) -> succ x : xs) "cons"
18:16:34 <lambdabot>   "dons"
18:16:41 <geheimdienst> :-o
18:16:49 <argiopeweb> Axman6: Well, if they can read from a memory device to a memory device at sustained > 1gb/s, they're equivalent when you put them to work on hard media. I think you're good. :P
18:16:55 <edwardk> it is a tricky one
18:16:59 <Axman6> hmm, seems my program is broken =)
18:17:05 <Axman6> not to figure out why...
18:17:09 <argiopeweb> Well, that's a different problem entirely.
18:17:37 <Axman6> ah, i was bei9ng too smart for myself, and not writing to anything by stdout =)0
18:17:41 <Axman6> -_-
18:18:05 <dibblego> edwardk: those slides show a non-transformer version, which I can implement fine
18:18:42 <argiopeweb> "\
18:18:42 <argiopeweb> :\ *
18:18:42 <argiopeweb> How are you testing throughput?
18:18:55 <Axman6> using pv (pipeviewer)
18:19:12 <argiopeweb> Ah.
18:22:54 <Axman6> ok, fixed
18:23:26 <argiopeweb-acqui> New results still look good?
18:24:12 <Axman6> 125MB/s. still better than Iteratee, but nowhere near as good as tee
18:24:31 <argiopeweb-acqui> Odd.
18:24:32 <Axman6> or not...
18:24:47 <Axman6> hmm, why od i keep getting such strange results, now tee is slower >_<
18:25:00 <danharaj> In this episode of #haskell, Axman6 learns first hand how much of a fickle bitch I/O benchmarking can be.
18:25:07 <argiopeweb-acqui> Yep.
18:25:38 <edwardk> dibblego: ah missed the monad. for that i usually just raid oleg's material
18:25:45 <Axman6> ok, seems write speed is greatly dependant on which device you write to...
18:26:10 <dibblego> edwardk: I'm just not convinced I have it right to begin with
18:26:13 <argiopeweb-acqui> My process: Find 5gb file, cat file to program, redirect all output to /dev/null. Compare times, choose higher. Say it's statistically better with a sample size of 1. Move on with life.
18:26:28 <Axman6> ha: 1.01e+03MB/s
18:26:46 <edwardk> dibblego: *nods* if you're still here after game of thrones i'll debug ;)
18:26:55 <edwardk> bbiab =)
18:27:12 <dibblego> ok, I'll keep plugging
18:28:16 <Axman6> > 1e+03
18:28:16 <lambdabot>   1000.0
18:28:31 <Axman6> so about 1GB/s... wonder it's decided to go to scientific notation
18:29:59 <ddarius> Perhaps it didn't want to indicate more than three significant figures.
18:30:36 <Jafet> From a coreutil? Rather unlikely.
18:30:37 <Axman6> well it would have been a lot shorter to say 0.98GB/s
18:30:55 <Axman6> seems to only do it in the range between 1000MB and 1GB
18:31:05 <Axman6> which happily my prtogram sits in =)
18:37:25 <argiopeweb-acqui> As mentioned earlier though, you're testing the cpu-bound part of a disk-bound application. It's debatable of how much use such a benchmark is.
18:38:20 <Axman6> well,  I'd like to measure what the maximum throughput it can handle is
18:39:04 <Axman6> I'm not sure what other benchmark you could really do here
18:40:21 <Obvioso> test
18:40:59 <adamvh> @hoogle [a] -> [[a]]
18:41:00 <lambdabot> Data.List inits :: [a] -> [[a]]
18:41:00 <lambdabot> Data.List permutations :: [a] -> [[a]]
18:41:00 <lambdabot> Data.List subsequences :: [a] -> [[a]]
18:41:03 <argiopeweb> Well, the interrupt mechanism for /dev/[zero|null] is handled differently from standard disk IO, so you'll get weird answers with that, and testing it on disk stuff is essentially only going to test the speed of your disk. I'm not sure it can be reliably tested for pure throughput.
18:42:31 <argiopeweb> Though it's possible that if you use dd as your input you'll be able to glean some additional interesting information.
18:43:15 <sshc> Can a library directly depend on monads-tf and indirectly on mtl?  (For example, a package uses monads-tf, but wants to use fclabels, which depends on "mtl") (mtl conflicts with monads-tf because they export different modules with the same name)
18:44:11 <argiopeweb> sshc: Of course, as long as you hide the appropriate bindings where you're importing them.
18:45:04 <argiopeweb> Does fclabels reexport mtl?
18:45:40 <argiopeweb> The other thing you can do is import one or the other (or both) as qualified.
18:46:37 <dibblego> http://paste.pocoo.org/show/385598/ feels broken
18:47:31 <sshc> I see, thanks.
18:47:40 <sshc> "one or the other" of what?
18:47:54 <argiopeweb> sshc: Either of the modules with conflicting names.
18:49:18 <dankna> sshc: when you use cabal, this is done for you
18:49:47 <dankna> the hiding and showing of packages, that is, not the qualified importation
18:50:23 <argiopeweb> dankna: It gets handled via GHC explicit includes/excludes, right?
18:50:55 <dankna> argiopeweb, yes, if you look at the ghc command lines that cabal spits out, you'll see that it starts by excluding everything and then including only the ones you specified as direct dependencies
18:51:28 <sshc> argiopeweb: Huh?  Are you saying that I can directly use modules that have the same name from different packages? (different from what I said, which was depending directly on a package with "conflicted" with an *indirect* depennndency)
18:53:19 <argiopeweb> You have 3 modules. Module A exports bindings. Module B exports bindings that conflict with Module A. Module C imports module B and re exports bindings from B. Now you have a 4th module that imports A and C. Names clash. Fix: import qualified C as C
18:53:25 <dankna> sshc: yes, you can do that.  it's not standard Haskell but GHC has an extension syntax for it.
18:53:50 <dankna> I think it looks like import "mtl":Control.Monad.State
18:53:58 <dankna> or if you want both of them in the same package
18:54:06 <dankna> import qualified "mtl":Control.Monad.State as MTL
18:54:10 <c_wraith> just a space, not a colon
18:54:13 <dankna> ah okay
18:54:20 <dankna> yeah, I've never used it, so I dunno the syntax
18:54:28 * hackagebot haskelldb-hdbc-mysql 0.1.1 - HaskellDB support for the HDBC MySQL driver.  http://hackage.haskell.org/package/haskelldb-hdbc-mysql-0.1.1 (AndrewMiller)
18:54:29 <c_wraith> though as of mtl 2, most of this shouldn't be necessary
18:55:07 <argiopeweb> Wee, my favorite library got updated /o\
19:05:29 * hackagebot zampolit 0.3 - A tool for checking how much work is done on group projects.  http://hackage.haskell.org/package/zampolit-0.3 (BrianSniffen)
19:08:07 <NemesisD> i'm looking for some guidance for using ReaderT, i wonder if any of you could take a look at this http://hpaste.org/46512/readert_design
19:09:53 <NemesisD> i'm using CampfireM to wrap IO operations. first, i wanted to figure out if the IO operations i'll do like getRooms there should be returning IO [Room] or CampfireM [Room]
19:11:27 <NemesisD> i haven't quite got the types figured out. nowhere in my code am i extracting the environment from the ReaderT, i wanted the methods it called to be passed it by the caller as they will all require it and this seems like the target use case for ReaderT
19:15:49 <adamvh> Hmm, Does Data.Either have a Monad instance?
19:15:59 <dmwit> Control.Monad.Error
19:16:09 <sshc> dankna: Oh, *wow*.  That's a wonderful feature.  Which extension enables that?
19:16:20 <adamvh> dmwit: Ah.
19:16:48 <dankna> sshc: not sure, check the manual
19:17:06 <monochrom> NemesisD: choose one: "getRooms :: CampfireEnv -> IO [Room]", this has nothing to do with CampfireM or ReaderT. "getRooms :: CampfireM [Room]", this uses your CampfilreM.
19:17:31 <monochrom> they have equivalent functionality but you have to choose one and stick to it
19:18:52 <NemesisD> monochrom: what criteria should i use to decide that? I suppose the IO one is easier to use by itself without ReaderT but calling it with ReaderT is theoretically supposed to be more elegant
19:19:11 <monochrom> personal taste
19:19:20 <dmwit> "go with your heart"
19:19:30 <NemesisD> monochrom: if i'm interpreting you correctly, you're saying that if I choose to go with IO [Room], i should not bother with ReaderT at all
19:20:33 <monochrom> if you don't know what your taste is, write both versions, stare at them
19:21:36 <napping> I don't see how IO would make ReaderT obsolete
19:22:03 <monochrom> no one is claiming ReaderT obsolete
19:23:00 <monochrom> the choice is between X -> IO blah and ReaderT X IO blah. actually the choice is between X -> IO blah and one more newtype around ReaderT X IO blah
19:23:14 <NemesisD> monochrom: i think i prefer the CampfireM/ReaderT route, now the trouble is figuring out how to get the definiton of getRooms right. i suspected it would be something like: CampfireM env $ do { some IO ops here}
19:23:14 <monochrom> IOW the choice is how many newtype levels you want
19:24:00 <monochrom> if you use CampfireM, you no longer take a parameter. you use ReaderT's "get"
19:24:10 <monochrom> is that called "get"?
19:24:11 <dmwit> liftIO :: IO a -> CampfireM a
19:24:17 <dmwit> It's called "ask".
19:24:27 <monochrom> you use ReaderT's "ask"
19:24:28 <dmwit> Although I mostly use "asks".
19:24:36 <dmwit> asks f = fmap f ask
19:26:06 <NemesisD> monochrom: so it would be like: getRooms = do    env <- get    return $ doStuff env    ?
19:26:23 <NemesisD> erm ask, not get
19:26:28 <dmwit> That seems unlikely.
19:26:54 <monochrom> env<-ask is right. but I don't understand what you're returning
19:26:55 <dmwit> That would be exactly
19:26:59 <sshc> dankna: I couldn't find any extension that enables that functionality ("import mtl Control.Monad.Error")
19:26:59 <dmwit> getRooms = asks doStuff
19:27:02 <napping> was there supposed to be a newline between get and return?
19:27:09 <dmwit> napping: Yes, probably.
19:27:10 <sshc> Is anybody here aware of any documentation for that?
19:27:14 <NemesisD> monochrom: well the CampfireM wraps an IO
19:27:23 <napping> like getRooms = do { env <- get ; return $ doStuff env}
19:27:29 <dmwit> sshc: It's called package-qualified imports and it's real hush-hush. ;-)
19:27:30 <Eduard_Munteanu> :t get
19:27:30 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
19:27:31 <dankna> one sec, sshc, I'll figure it out
19:27:34 <NemesisD> napping: yeah, i just didn't; know how best to specify it, semicolon would have been right
19:27:41 <Eduard_Munteanu> You want 'ask' for Reader, 'get' for State
19:27:57 <dmwit> sshc: http://www.haskell.org/ghc/docs/7.0-latest/html/users_guide/syntax-extns.html#package-imports
19:27:58 <napping> the explicit grouping is good for IRC and ghci
19:28:31 <NemesisD> this seems kind of inelegant though. i do know that all of my operations *will* need that env, i'd have to ask for every single one
19:28:41 <napping> that looks like you were calling ask to retrieve the reader state, and then mapping a pure function doStuff over it
19:28:50 <dankna> sshc: {-# LANGUAGE PackageImports #-} before your module line
19:28:57 <dankna> and don't forget you need quotes around the package names
19:29:15 <dmwit> NemesisD: Why don't you come up with a real thing you want to do, try it, and ask for critiques of that?
19:29:17 <NemesisD> napping: oh no. doStuff will incur an IO computation
19:29:24 <dmwit> It's impossible to give critiques of vapor like this.
19:29:28 <napping> oh, then you probably can't get away with return there
19:30:31 <NemesisD> dmwit: i've been pushng around code on this problem all afternoon. i could certainly get it in a better state, i just thought the additional business logic wouldn't be helpful to you guys
19:30:50 <NemesisD> i've yet to get it to a state where it compiles
19:30:55 <napping> You could try putting it up somewhere
19:31:09 <firstman> I saw on the hackage page that the category-extras package is obsolete
19:31:27 <napping> I think it was split.
19:31:54 <Eduard_Munteanu> Yeah, edwardk broke it into multiple packages. He was going to make a metapkg for it I think, not sure if that happened.
19:32:03 <firstman> Hmm, do you know if the Control.Monad.Either module from category-extras made it into something else?
19:32:11 <edwardk> dibblego: did you figure out your problem?
19:32:27 <edwardk> firstman: Either
19:32:30 <edwardk> er 'either'
19:32:44 <KirinDave> Hmm. Maybe this isn't going to work.
19:32:45 <edwardk> a tiny little self-contained package with just the EitherT monad
19:33:09 <dmwit> edwardk: I don't suppose there's video to go with your slides...
19:33:16 <edwardk> dmwit: which ones?
19:33:18 <Eduard_Munteanu> http://hackage.haskell.org/package/either
19:33:21 <Eduard_Munteanu> This one maybe?
19:33:25 <dmwit> A-Parsing-Trifecta.pdf
19:33:34 <edwardk> Eduard_Munteanu: thats the one
19:33:43 <KirinDave> I was thinking of making a text-breaking monoid, that took [String] and turned it into a series of strings broken at length N.
19:33:46 <edwardk> dmwit: fraid not. didn't have a camera back then
19:33:48 <danharaj_> umm I have a weird problem with ghci.
19:33:50 <Eduard_Munteanu> I merely grepped the hackage pkgs page
19:34:01 <danharaj_> It's saying that all my modules have mismatched file names and module names... but that's a lie.
19:34:03 <KirinDave> But i don't think it will work as magically as I thought.
19:34:12 <firstman> edwardk: thanks - although it depended on "Data.Semigroupoid.Bifoldable" for some reason :p
19:34:14 <napping> is there a hackage page for category-extras?
19:34:24 <firstman> napping: yup
19:34:25 <Eduard_Munteanu> edwardk: did you make a metapkg for the split category-extras to import them all already?
19:34:41 <edwardk> Eduard_Munteanu: not yet
19:34:41 <dmwit> Maybe the next version of category-extras should just be a package that depends on all the things it got split into.
19:34:55 <napping> where?
19:34:56 <Eduard_Munteanu> Yeah, and de-deprecate it :)
19:34:57 <dmwit> Oh, I see that it's in the works. Great. =)
19:35:09 <edwardk> firstman: ?
19:35:16 <firstman> http://hackage.haskell.org/package/category-extras-0.53.5
19:35:19 <napping> ah, are deprecated packages not included in the main index?
19:35:31 <napping> I guess that would explain it.
19:35:32 <KirinDave> Because then I can't mappend strings to my newtyped wrappedlines
19:36:11 <edwardk> there are only a few things in category-extras that haven't been split out into the smaller packages
19:36:22 <firstman> edwardk: just thought it was funny that the monad instance for Either pulls in so many seemingly unrelated packages
19:36:50 <edwardk> firstman: they are just weaker notions of Monad, etc.
19:37:46 <napping> NemesisD: more code would probably help. It's hard to know what moand to make, if you don't know what operations it should provide
19:37:51 <edwardk> the alternative is worse. that all those other packages pick up a dependency on this, and then worse that the couple of dozen packages above them also in turn pick up dependencies on this unrelated concept
19:37:58 <firstman> I figured.  It makes for an amusing terminal full of text after I "cabal install either"
19:38:09 <edwardk> =)
19:38:20 <edwardk> try cabal install representable-tries some time, that will make you laugh ;)
19:38:22 <argiopeweb> KirinDave: I don't see your problem... Further description/code might be helpful.
19:39:19 <danharaj> Ah ok. --| and -- | are very very different.
19:39:31 <danharaj> Screw the implicit "If there's no module declaration at the top it's Main".
19:39:34 <NemesisD> napping: agree. here's the (mess) state it's in right now http://hpaste.org/46513/readert_design_annotation?pid=46513&lang_46513=Haskell should give more context
19:40:50 <firstman> How do you guys usually deal with Parsec returning Either ParseError a?
19:40:57 <napping> Something like ReaderT IO looks like a good idea
19:41:06 <KirinDave> argiopeweb: I was using a writer to accumulate strings to write out later. But sometimes theyre too long
19:41:19 <edwardk> @type either
19:41:19 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
19:41:22 <edwardk> )
19:41:24 <edwardk> ;)
19:41:29 <napping> you want the monad to manage the connection, so you don't have to worry about the connection stuff most of the time, right?
19:41:39 <firstman> It seems kind of clunky to pattern match to take care of that every time?
19:41:55 <KirinDave> argiopeweb: I thought maybe if I added a new monoid type and behavior, otherwise my code would magically work
19:42:05 <KirinDave> argiopeweb: But now it's trying to mappend [String] to WrappedTextLines
19:42:31 <edwardk> well the short answer is how many times do you really start a parser?
19:42:46 <edwardk> and what else could it do?
19:43:11 <NemesisD> napping: i want campfirem to wrap the IO stuff and handle passing in of the read-only env to the stuff that will actually hit the internet
19:43:51 <napping> You might even consider making CampfireM pure
19:43:53 <KirinDave> argiopeweb: So you can see, I will need to change my tells to do something else. Which is fine. :)
19:45:38 <NemesisD> napping: how do you mean? making CampfireM not have any IO in the type signature?
19:45:48 <dmwit> NemesisD: http://hpaste.org/paste/46513/readert_design_annotation_a#p46514
19:46:43 <dmwit> Forget doGet entirely, just inline it.
19:46:57 <napping> http://apfelmus.nfshost.com/articles/operational-monad.html
19:47:03 <napping> like that, perhaps
19:48:54 <danharaj> :t (f >>=)
19:48:54 <NemesisD> dmwit: it will make sense to not inline it later, a lot of the API calls are going to differ only by the path they hit on the server, i.e. "/room/123.json" instead of "/rooms.json"
19:48:55 <lambdabot> forall (m :: * -> *) a b. (SimpleReflect.FromExpr (m a), Monad m) => (a -> m b) -> m b
19:49:20 <dmwit> NemesisD: Fine. But the type you gave it in your post is ridiculous.
19:49:49 <napping> If your code is not going to be working just with campfire, you might rather just make a library in IO for talking to the server
19:49:58 <napping> getRooms :: Connection -> IO [Room], etc.
19:50:55 <argiopeweb> KirinDave: Sorry, got sucked into #C++...  However, it appears there's no problem here. :P
19:51:00 <NemesisD> napping: it will only be used to work with campfire. this is mostly a learning exercise. i can't imagine too many haskellers having a need for campfire's api.
19:51:12 <KirinDave> argiopeweb: ?
19:51:18 <KirinDave> argiopeweb: I should just not be calling tell in the raw.
19:52:17 <argiopeweb> KirinDave: Exactly. Hence the reason there's no problem here. You know what you're doing. ;)
19:52:20 <dylukes> So, is this just my imagination,
19:52:48 <dylukes> I feel like theres something of a parallel between do-form and imperative style, and the lambda-form of a do block and CPS.
19:54:43 <argiopeweb> dylukes: The former is certainty, hence the reason pages and pages are spent on telling imperative programmers why Haskell's do is not just for making imperative-looking programs. As to the latter, it seems likely.
19:55:02 <napping> Consider the Cont monad, especially
19:56:24 <dylukes> argiopeweb: well, I'm aware of the former's certainty.
19:56:26 <napping> edwardk: looking at your blog, those priority queues are not search queues, are they?
19:56:28 <dylukes> I'm just wondering about the latter.
19:57:27 <xil> hi. I have a function that I'm doing a lot of pattern matching with and I have 1 line IO operations for all of the patterns, so I'm not using do-notation. My function currently returns IO () but I'd like it to be able to return 2 values, without having to sacrifice the fact that I don't use do-notation
19:58:15 <monochrom> f True = putStrLn "hi" >> return ('x', 4)
19:58:18 <Eduard_Munteanu> xil: two values? How about a tuple in IO?
19:58:27 <dylukes> I believe any imperative style program can be expressed in CPS.
19:58:54 <xil> monochrom: okay I wasn't sure the >> was what would  do it. I'm still figuring out Monads but that's exactly what I need. Thank you
19:59:12 <dylukes> So, I'm wondering if that relationship between imperative -> CPS, is equivalent to the relationship between do-block and >>= form.
19:59:12 <parcs> @src (>>)
19:59:12 <lambdabot> m >> k      = m >>= \_ -> k
19:59:14 <xil> Eduard_Munteanu: I meant two possible values, not two at the same time, something like Bool, but it's the >> I was looking for
19:59:16 <dylukes> (using lambdas)
19:59:28 <shachaf> xil: Of course, do { putStrLn "hi"; return ('x', 4) } is the same thing.
19:59:51 <monochrom> oh heh, I'll be smug and claim that ('x',4) is "one value" :)
20:00:23 <xil> parcs: I knew that but it just hasn't entirely settled in yet because I'm nervous about my use of Monads as of now. I just need to learn to be comfortable in the contract I make when defining functions/using defined functions
20:00:24 <dylukes> monochrom: So, do you think Imperative -> CPS is isomorphic to do-block -> >>=?
20:00:34 * shachaf multiple-value-binds.
20:00:49 <xil> shachaf: I hadn't thought of that, haha, but yeah that would do it too
20:00:52 <monochrom> something like that
20:01:38 <shachaf> dylukes: You're not really saying something very precise.
20:01:39 <xil> thanks all. That clears it up
20:01:47 <parcs> hmm
20:01:54 <shachaf> And do-block only kind of has to do with imperativeness, anyway.
20:02:09 <parcs> what's nicer, void a or _ <- a?
20:02:21 <shachaf> (>>=) clearly has a lot to do with CPS.
20:02:25 <shachaf> parcs: "void"?
20:02:30 <parcs> @type void
20:02:31 <lambdabot> Not in scope: `void'
20:02:33 <parcs> @hoogle void
20:02:34 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
20:02:35 <Eduard_Munteanu> shachaf: void casts
20:02:39 <Eduard_Munteanu> Oh.
20:02:42 <parcs> it's Functor f => f a -> f ()
20:02:49 <parcs> defined in Control.Monad
20:02:57 <shachaf> Can't you just say "a"?
20:03:02 <Eduard_Munteanu> I think the terminology is borrowed from C though.
20:03:02 <parcs> not with -Wall
20:03:11 <NemesisD> dmwit: your code looks really nice, it seems to want me to declare an instance for (MonadIO ((->) CampfireEnv))
20:03:20 <Eduard_Munteanu> (using void casts to explicitly tell the compiler you willingly ignore the return value)
20:03:34 <shachaf> (void*)a
20:03:48 <Eduard_Munteanu> no, (void) f(1)
20:03:53 <shachaf> Yes, yes.
20:04:14 <shachaf> Quite annoying when gcc makes you do that in unions.
20:04:24 <dmwit> NemesisD: Hm.
20:04:33 <Eduard_Munteanu> It does? I thought it was merely a warning you could turn on.
20:04:37 <shachaf> Wait, it's a completely different thing it makes you do.
20:04:39 <shachaf> Never mind.
20:05:00 <NemesisD> dmwit: the docs for Control.Monad.IO.Class says that any monad built from applying a sequence of monad transformers to IO will be an instance (automatically?), seems that would already apply to my CampfireM no?
20:05:53 <NemesisD> newtype CampfireM a = CampfireM {unCampfireM :: ReaderT CampfireEnv IO a}
20:06:03 <dmwit> NemesisD: What's the exact error?
20:06:18 <monochrom> the doc just means ReaderT C IO is a MonadIO.
20:06:30 <edwardk> napping: fraid not
20:06:41 <edwardk> napping: just optimal priority queues, no search functionality
20:07:08 <dmwit> NemesisD: Also, you probably need to add "deriving (MonadIO, MonadReader)" or so to the end of your newtype declaration.
20:07:12 <dmwit> :i MonadReader
20:07:13 <edwardk> psqueues by construction have to give up a logarithmic factor somewhere
20:07:26 <dobblego> edwardk, I have a type checking solution but I think it is incorrect, something ain't right
20:07:32 <zomg> Anyone happen to have any examples of using Network.HTTP to create a persistent http request?
20:07:39 <dmwit> "deriving (MonadIO, MonadReader CampfireEnv)", probably
20:07:45 <edwardk> dobblego: hpaste?
20:08:22 <dobblego> edwardk, in a meeting on my phone atm, gimme 15 mins
20:08:30 <edwardk> kk
20:13:38 <jmcarthur> man, i just wrote a 25 line function. i don't think i've written a function that large in quite a long time
20:13:54 <NemesisD> dmwit: sorry, my editor's copy function wasn't playing nicely with me: this is what i have right now http://hpaste.org/46515/getrooms
20:14:10 <jmcarthur> even before pulling out duplicate code (which there is a big opportunity for in this function)
20:14:22 <jmcarthur> in C i wouldn't even blink if i had written a 50 line function...
20:14:42 <argiopeweb> jmcarthur: I have one I work on on a weekly basis in a legacy system that's over 7k.
20:14:52 * jmcarthur cries
20:15:04 <argiopeweb> As do I, on a weekly basis.
20:15:14 <dmwit> NemesisD: :t curlOpts
20:15:52 <dmwit> Alternately, paste enough code that I can reproduce your error locally.
20:16:18 <NemesisD> dmwit: sorry T.Text -> [CurlOption], :t CurlOption is an ADT in curl
20:16:21 * ddarius thinks that the largest function he may have written was actually in Haskell and over 900 lines long.
20:17:03 <dmwit> NemesisD: You gave getRooms the wrong type.
20:17:14 <dmwit> NemesisD: It should just have type "getRooms :: CampfireM [Room]".
20:17:21 <NemesisD> oh yeah, i forgot
20:17:35 <NemesisD> bingo!
20:18:01 <argiopeweb> ddarius: Damn. Were you Doing Something Wrong (TM), or did it legitimately need to be that large?
20:20:55 <dibblego> edwardk: http://paste.pocoo.org/show/385598/
20:23:51 <jnhnum1> hey guys, if I were writing a haskell program and it used a mutability-reliant (but deterministic) algorithm like dijkstra's, how bad form would it be to use unsafePerformIO to expose this as a "pure" function?
20:24:13 <dibblego> jnhnum1: bad, use ST
20:24:18 <epdtry> jnhnum1: why not use ST instead?
20:24:51 <jnhnum1> oh ... looking up what ST is now
20:25:03 <NemesisD> it works!! thanks so much dmwit napping and everyone else, now to clean up this ugly ugly code
20:26:34 <lpsmith> jmcarthur: I find I write long-ish functions in Haskell when I don't know how to tease apart the problem cleanly
20:26:58 <dibblego> edwardk: it's definitely not right, since there is no call to >>= on f, only liftM
20:28:58 <jnhnum1> dibblego, epdtry: would using ST complicate the types of any other functions which used dijkstra?
20:29:14 <lpsmith> But how do you count the llines of a function?  I find that these longer functions are individually short,  but have lots of helper functions defined in a big "where" clause
20:30:01 <mjrosenb> is the sort from Data.List stable?
20:30:45 <c_wraith> jnhnum1: runST makes it pure from the outside
20:31:36 <c_wraith> jnhnum1: the internal implementation may depend on mutability, but as long as that's all on the inside, none of the crazy ST types escape
20:32:12 <Nolrai223> Hey cabal is failling to install the time package, which seems odd to me. Does  "time-1.2.0.4 failed during the configure step. The exception was: ExitFailure 1" mean something useful to someone?
20:32:28 <jnhnum1> c_wraith: great thanks - I'll do some more research about ST
20:33:04 <Nolrai223> This is prevting me from upgrading to the newest version of cabal.
20:33:51 <c_wraith> Nolrai223: there's probably a better error message buried somewhere in a ton of output before that
20:34:46 <jmcarthur> lpsmith: well, in this case it's just that i'm writing some stream fusion stuff for a fairly complex data type
20:34:52 <jmcarthur> lpsmith: it also has a little duplication though
20:35:44 <jmcarthur> lpsmith: and most of these lines are indeed in a where clause, as is typical with stream fusion stuff
20:35:58 <jmcarthur> but mostly case expressions, not tons of small functions
20:38:26 <Nolrai223> hmm, I think its saying I need cabal 1.10 but I need the new time to install cabal 1.10..So should I like uninstall cabal or something?
20:39:08 <dibblego> edwardk: I am not convinced it is a monad
20:39:40 * hackagebot gofer-prelude 2.30.3 - The Gofer 2.30 standard prelude  http://hackage.haskell.org/package/gofer-prelude-2.30.3 (DonaldStewart)
20:41:40 * hackagebot wai-handler-devel 0.4.2 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-0.4.2 (MichaelSnoyman)
20:41:42 * hackagebot warp-static 0.1.1 - Static file server based on Warp and wai-app-static  http://hackage.haskell.org/package/warp-static-0.1.1 (MichaelSnoyman)
20:42:02 <lpsmith> jmcarthur:  I find I kind of write a big ugly knot of mutually recursive helper functions :-P
20:42:31 <lpsmith> usually not reusable and given generic names,   I'm fond of "loop"
20:42:44 <finlayt> hello
20:42:52 <lpsmith> hello :)
20:43:00 <finlayt> can anyone help me with the profiling options
20:43:04 <finlayt> ?
20:43:17 <finlayt> I have a test program, and would like to generate a .prof report
20:43:41 * hackagebot wai-app-static 0.2.0 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-0.2.0 (MichaelSnoyman)
20:43:43 * hackagebot yesod-static 0.2.0 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-0.2.0 (MichaelSnoyman)
20:44:01 <finlayt> ghc -prof -auto-all linedirect.hs
20:44:04 <finlayt> is that right ?
20:45:10 <finlayt> I get the error "linedirect: Most RTS options are disabled. Link with -rtsopts to enable them."
20:45:25 <finlayt> when I try to run it with the  +RTS -s -p -RTS flags
20:45:32 <finlayt> anyone know what I am doing wrong ?
20:45:53 <napping> Compile with -rtsopts (you might need to delete a .o or something to get it to actually re-link)
20:46:01 <finlayt> k
20:46:22 <finlayt> thanks, that worked
20:46:44 <finlayt> had to remove the .o
20:47:01 <napping> there was some worry about people feeding +RTS options to cgi scripts
20:49:28 <napping> I think it would have been enough to disable the options that let you say where profiling output could go
20:52:36 <napping> dibblego: do you have any side conditions?
20:53:12 <dibblego> side conditions?
20:53:14 <napping> side conditions on the leftover input in a Done
20:53:34 <jmcarthur> dibblego: " it's definitely not right, since there is no call to >>= on f, only liftM"  <-- that's not necessary in all cases. sometimes >>= on the underlying monad isn't needed until you write the run function. i think codensity is an example of this
20:53:57 <jmcarthur> maybe even just ContT
20:54:04 <jmcarthur> i guess so yeah
20:54:05 <napping> otherwise, return () >>= (\v -> Done v EOF) /= Done () EOF
20:54:08 <dibblego> jmcarthur: you mean, it might be right and only Functor f => is needed?
20:54:14 <jmcarthur> dibblego: maybe
20:54:20 <jmcarthur> that is my intent, yes
20:54:30 <dibblego> feels wrong though
20:54:32 <jmcarthur> i just don't mean to imply that i think it's necessarily correct
20:54:36 <dibblego> right ta
20:54:58 <jmcarthur> maybe try writing the run function for it?
20:55:06 <napping> the first monad law should hold, yes?
20:55:30 <dibblego> I think I could write run
20:55:36 <dibblego> but not sure how it would help
20:55:45 <jmcarthur> i just suspect that >>= will come up there
20:56:31 <jmcarthur> if it does not then we might be more certain that IterV is at least not a transformer. could still be a monad though, i suppose
20:56:34 <napping> Didn't I just provide a counterexample?
20:56:53 <jmcarthur> oh i didn't notice.
20:56:55 * jmcarthur looks
20:57:02 * dibblego writes run
20:57:21 <Kaidelong> How are comonads used in practice. It does not strike me as a very useful thing to prove
20:57:42 <Kaidelong> (was reading the blog post on functional segments being comonads and applicative functors)
20:57:46 <argiopeweb> Is there any library support/work being done to mirror the more useful functionality in Erlang (mainly simple distribution model, lightweight multithreading [does par fill that spot?], fault tolerance, and no-downtime code changes) in Haskell?
20:58:01 <napping> Kaidelong: they don't seem to be used much, but have you read about multiplate?
20:58:08 <Kaidelong> I haven't
20:58:24 <jmcarthur> Kaidelong: monads tend to be for things that you can't unwrap arbitrarily. comonads tend to be for things that you can't wrap arbitrarily
20:58:41 <napping> perhaps useful for representing data, rather than computation
20:58:51 <Kaidelong> yeah but Haskell's type system doesn't seem expressive enough to make comonad-like stuff very useful
20:58:53 <jmcarthur> i like comonads for automata
20:59:11 <napping> why would comonads need a fancier type system than monads?
20:59:22 <djahandarie> Kaidelong, why anymore so than mo... oh.
20:59:27 <jmcarthur> i used comonads in a game simulation before on a discrete board
20:59:39 <Kaidelong> the whole idea would be that the comonad's type would tell you something about the values in it?
20:59:46 <jmcarthur> i also am using comonads for some frp stuff that i'm working on
21:00:03 <Kaidelong> hence why you can't arbitrarily go a -> w a
21:00:16 <dibblego> I am using CoStateT to implement lenses in Scala
21:00:21 <dibblego> jmcarthur: http://paste.pocoo.org/show/385632/
21:00:30 <Kaidelong> I guess it would work in certain areas
21:00:33 <Kaidelong> like non-empty lists
21:00:51 <napping> It doesn't seem to be important that you can't go a -> w a
21:01:18 <Kaidelong> oh in the case of non-empty lists you can arbitrarily go a -> w a
21:01:24 <dibblego> pointed/copointed are annoying
21:01:31 <napping> The comonads that seem useful do make it possible to write a -> w a functions
21:01:42 <napping> nothing in the definition prohibits that
21:01:53 <napping> just like many monads let you write a function m a -> a
21:02:06 <jmcarthur> dibblego: huh, so you only needed return and liftM...
21:02:07 <Kaidelong> I imagine that there are useful ones that prohibit a total function "a -> w a" but aren't useful without some way to tie types to their values
21:02:17 <dibblego> jmcarthur: yeah, it's a bit suspicious
21:02:29 <Kaidelong> programming by contract is what I'm thinking
21:02:38 <jmcarthur> it could still be some sort of obfuscated free monad
21:03:25 <napping> dibblego: so, what about (\v -> Done v EOF) () = Done () EOF, return () >>= (\v -> Done v EOF) = Done () Empty ?
21:03:43 <napping> you have some plan to patch that up with a monoid on Input?
21:04:04 <dibblego> napping: is that a Monad implementation?
21:05:05 <jmcarthur> this would be a free monad, i'm sure:   data IterV e f a = Done a | Cont (Input e -> f (IterV e f a))
21:05:09 <napping> apparently not, if it evaluates like that
21:05:25 <jmcarthur> it's just a question of whether that can still work with that extra (Input e) in the Done constructor
21:05:31 <napping> I think it's a counterexample to your first paste being a monad
21:07:28 <dibblego> data IterV e f a = Done a (Input e) | Cont (Input e -> f (IterV e f a))
21:07:34 <dibblego> that seems to be the same as Data.Iteratee
21:07:37 * Kaidelong goes to take a look at multiplate
21:08:19 <dibblego> and that has a Monad
21:08:28 * dibblego goes nuts
21:09:06 <applicative> napping must mean the implementation violates the monad laws?
21:09:32 <napping> I think they have some side conditions about what you are allowed to provided as the reamining input
21:10:02 <napping> and lots of handwaving, and maybe it's not really a monad either...
21:11:08 <applicative> oh, napping, you are thinking there's no legitimate implementation?
21:12:06 <napping> I'm not sure about that
21:12:10 <jmcarthur> @unmtl WriterT o m a
21:12:20 <jmcarthur> :t runWriterT
21:12:24 <jmcarthur> *sigh*
21:12:24 <napping> It seems return x >>= f = f x could be patched up by combining the remaining input
21:12:47 <Kaidelong> @botsnack
21:13:43 <applicative> what is forcing this result?: return () >>= (\v -> Done v EOF) = Done () Empty
21:14:03 <applicative> Intuitively it should be Done () EOF.
21:14:13 * KirinDave sighs.
21:14:15 <napping> the definition of bind in the first past
21:14:22 <KirinDave> Anyone got some pointers for my ugly ass code?
21:14:23 <KirinDave> http://hpaste.org/46517/how_do_i_shorten_this
21:14:35 <dibblego> actually, Data.Iteratee is slightly different
21:14:53 <dibblego> the Monad instance is not on IterV but on Iteratee, which is mutually-dependent with IterV
21:15:11 <dibblego> perhaps there is no Monad for IterV
21:15:24 <dibblego> in which case, I am a knob head
21:16:17 <napping> which iteratee package are you looking at?
21:16:17 <applicative> Oh I see the other paste.  The problem is from this line, then? : Done a i >>= f = case f a of  Done a' _ -> Done a' i
21:16:39 <dibblego> Data.Iteratee but version 0.3.5 which is quite old
21:17:08 <dibblego> but more closely resembles this code
21:17:11 <dibblego> http://hackage.haskell.org/packages/archive/iteratee/0.3.5/doc/html/src/Data-Iteratee-Base.html
21:17:57 <napping> IterateeG?
21:18:14 <dmwit> KirinDave: What's the difference between the behavior of that code and the bits I pasted last night?
21:18:21 <dmwit> (Just out of curiosity.)
21:18:29 <applicative> Done a EOF >>= f = case f a of  Done a' _ -> Done a' EOF, then later  Done a i >>= f = case f a of  Done a' Empty -> Done a' i
21:18:30 <KirinDave> dmwit: I lost the code you pasted last night?
21:18:44 <KirinDave> dmwit: Chrome, a fine piece of software, crashed without saving history.
21:18:51 <dmwit> oh
21:18:56 <dmwit> Do you want it again?
21:19:02 <KirinDave> Sure, if you have it at hand
21:19:09 <dmwit> http://hpaste.org/46492/text_wrap
21:19:10 <KirinDave> This doesn't even work right. Has a rad bug.
21:19:25 <napping> are you trying to wrap nicely?
21:19:31 <napping> or just take/drop?
21:19:32 <dmwit> napping: Yes.
21:19:32 <dibblego> I think "(IterV e f) is not a monad" is a true statement
21:19:36 <Kaidelong> @src unwords
21:19:39 <KirinDave> napping: I just want simple wrapping, yeah.
21:20:16 <napping> wrapping between words is a bit harder
21:20:31 <dmwit> My paste wraps between words.
21:20:34 <dmwit> It's not all *that* hard.
21:22:45 <Kaidelong> KirinDave: what is that thing supposed to do?
21:22:56 <KirinDave> Kaidelong: Wraps words.
21:23:19 <Kaidelong> what does that mean exactly?
21:23:23 <dmwit> The first guard looks unnecessary to me.
21:23:38 <dmwit> Kaidelong: e.g. wrap 5 "a b c d e" = ["a b c", "d e"]
21:23:48 <dmwit> Kaidelong: So no line is longer than 5 characters.
21:24:03 <Kaidelong> aight
21:24:06 <dmwit> (unless it has to be -- if a single word is longer than 5 characters, for instance)
21:24:18 <applicative> dibblego, the newer oleg definition of 'iteratee' is sort of like this IterV, but moves the leftovers from Done a (Input e) to Cont (Input e -> f (Iter e f a, Input e) )
21:24:24 <napping> dibblego: if you define a monoid on Input with unit Empty, the first two laws at least work out
21:24:35 <dmwit> ...and wrap 5 "ab cdef g" = ["ab", "cdef g"]
21:24:43 <dmwit> (so it doesn't cut in the middle of a word)
21:25:00 <applicative> Done is just Done a, not Done a (Input e) so to say.   I can't remember if this was one of the reasons for the change.
21:25:06 <napping> .. and use that monoid to combine extra input in the first case of the definition of >>=
21:25:12 <dibblego> napping: I think I was on the wrong track with an instance Monad for IterV
21:25:12 <dmwit> err... wrap 5 "ab cdef g" = ["ab", "cdef", "g"], I guess
21:26:10 <dmwit> KirinDave: Also, I'd recommend making the accumulator accumulate in reverse order, so using (nw : accum) instead of (accum ++ [nw]) and [unwords (reverse accum)] rather than [unwords accum].
21:26:27 <KirinDave> Yeah I thought about that.
21:26:35 <KirinDave> Honestly I'm just trying to read through your code.
21:26:46 <dmwit> KirinDave: Oh, I can help there!
21:27:15 <dmwit> KirinDave: Your "lsf" parameter is encapsulated in my "lengths" list.
21:27:30 <dmwit> KirinDave: "lengths" is a list of what "lsf" would be after each possible break.
21:27:51 <KirinDave> Yeah well yours doesn't have my stupid bug too. :)
21:28:01 <dmwit> KirinDave: Then "numToTake" just scans "lengths" looking for the first place it goes over the limit, but definitely taking at least one word.
21:28:20 <dibblego> back later, thanks for the tips
21:28:25 <dmwit> (Hence the "max 1" at the beginning.)
21:28:36 <KirinDave> Ooohhh....
21:28:50 <KirinDave> So scanl is building a list of reductions.
21:28:55 <dmwit> KirinDave: And the (-1) argument to scanl is basically doing what your "if lsf == 0 then 0 else 1" thing was doing, but in a bit more principled way.
21:29:04 <KirinDave> And you take tail because you MUST take 1 word
21:29:46 <dmwit> Actually, the tail is just to make the length work out properly. =P
21:29:54 <dmwit> Just a trick, nothing deep there.
21:30:06 <dmwit> It's the "max 1" that guarantees that at least one word is taken.
21:32:17 <Kaidelong> Okay KirinDave
21:32:20 <Kaidelong> I put down my two cents
21:32:23 <Kaidelong> no idea if it works
21:34:09 <dmwit> Cool approach, Kaidelong.
21:34:50 <dmwit> Constantly appending short strings with (++) worries me, though.
21:34:56 <dmwit> It's O(n^2)...
21:35:12 <Kaidelong> I will confess I wasn't really trying to be efficient
21:35:26 <dmwit> Yeah. This problem probably doesn't really demand efficiency.
21:35:40 <Kaidelong> "w ++ (' ':x)" is probably a no brainer improvement though
21:35:56 <dmwit> That doesn't really address the problem.
21:36:01 <Kaidelong> yeah
21:36:07 <Kaidelong> but I mean
21:36:11 <Kaidelong> on reflection, it seems obvious
21:36:14 <KirinDave> Is a Difference List a good call here?
21:36:55 <dmwit> A difference list seems like overkill.
21:37:21 <dmwit> You're only ever adding on one end of the list, so you don't need dlist's extra power.
21:37:35 <KirinDave> But it is free appends :)
21:37:44 <KirinDave> Well constant appends.
21:37:53 <dmwit> If you store your String backwards, it has free appends, too. =)
21:39:45 <Kaidelong> unwords[w,x] works too
21:40:05 <Kaidelong> not that it works any differently, I guess
21:49:01 <adamvh> Hmmm.  I have a value of type    Either ParseError a
21:49:13 <adamvh> or rather
21:49:18 <adamvh> Either ParseError [a]
21:49:36 <adamvh> and I'd like to do some IO based on every element of the list
21:49:53 <adamvh> what's a good, idiomatic way to do this?
21:51:10 <dmwit> What do you want to do with ParseErrors?
21:52:18 <dmwit> :t \fForErrors fForVal -> either fForErrors (mapM_ fForVal)
21:52:34 <dmwit> No lambdabot, huh?
21:52:40 <adamvh> dmwit: Well, I'd prefer to just ignore them
21:52:45 <adamvh> to be honest
21:52:55 <dmwit> What does "ignore" mean?
21:52:58 <dmwit> Raise an exception?
21:53:05 <dmwit> Print something nasty to stderr and exit?
21:53:16 <dmwit> Do nothing at all?
21:53:36 <adamvh> Well, if this were Python or Lisp or what have you, I would simply not write any code related to them
21:53:43 <adamvh> and my program would just crash
21:53:53 <dmwit> So you want to raise an exception, then.
21:54:04 <adamvh> I suppose so
21:54:28 <dmwit> Try (either (error . show) (mapM_ functionThatMucksAboutWithASingleValueFromTheList)), then.
21:56:46 <adamvh> that works quite nicely, thanks  Sorry if that question was a bit n00bish.
21:57:10 <dmwit> Not at all.
21:58:15 <adamvh> I found a thread on Haskell-cafe about the many irritations of mixing IO and Maybe / Either ParseError / etc
21:58:26 <adamvh> so I knew I was not entirely alone in my frustration :p
21:59:15 <adamvh> The global-ness of instance declarations seems problematic, from reading a few threads related to the issue
22:04:29 <Kaidelong> hmm, well, I made another annotation
22:04:42 <Kaidelong> I think this time I basically ended up just rewriting what was there originally, though
22:05:26 <dmwit> ack
22:06:15 <Kaidelong> oh no
22:06:17 <Kaidelong> it is different
22:07:31 * dmwit points at http://hpaste.org/46492/text_wrap again
22:09:18 <Kaidelong> that's nice
22:11:10 <Kaidelong> hmm
22:11:33 <Kaidelong> I probably should have used "(null . drop (c-1))(w)" in mine
22:11:47 <Kaidelong> that gets rid of the polynomial
22:12:33 <Kaidelong> as opposed to "c > length w"
22:12:43 <KirinDave> Haha
22:12:55 <KirinDave> dmwit's is so much faster than mine.
22:13:27 <dmwit> Kaidelong: You could also do "fromIntegral c > genericLength w", and use the lazy Nat type. =)
22:15:17 * Kaidelong goes to try them all our
22:16:54 * argiopeweb is going to spend the next 10 hours learning Erlang + OTP.
22:17:06 <KirinDave> argiopeweb: It's not a short process.
22:17:20 <KirinDave> argiopeweb: OTP is pretty huge.
22:17:25 <napping> try out binary pattern matching
22:17:45 <argiopeweb> The language should be easy. OTP is huge and I won't master it in 10 hours, but I'll be able to use it.
22:18:05 <napping> that's one interesting thing in the language
22:18:14 <argiopeweb> That just can't help but be fun...
22:18:25 <KirinDave> Yeah
22:18:30 <napping> oh, the live update stuff too
22:18:30 <KirinDave> Erlang is kinda fugly.
22:18:46 <argiopeweb> Live update kicks ass. I wish I had that functionality in Haskell.
22:18:58 <napping> I don't think there's anything else interesting in the language
22:19:08 <argiopeweb> Of course, then we could essentially do everything Erlang did, and then where would we be?
22:19:31 <Kaidelong> That's weird
22:19:31 <c_wraith> an alternate syntax for the language sure would be nice, though
22:19:42 <KirinDave> argiopeweb: Erlang's live-update support is not magic.
22:19:43 <Kaidelong> I can't replicate your results in GHCi KirinDave
22:19:43 <argiopeweb> napping: Unlike Haskell, which I learn/use purely because I like the language, I have actual planned used for erlang.
22:20:01 <Kaidelong> Let me try with a much bigger string
22:20:05 <argiopeweb> KirinDave: Of course not. It's a VM + handler code.
22:20:33 <napping> just don't think the language part looks easy and skip over those
22:20:41 <KirinDave> argiopeweb: Haskell could have it. The way it's implemented is remarkably simple. :)
22:20:43 <napping> well, I guess you can do without binary patterns
22:20:57 <argiopeweb> KirinDave: Then why doesn't it, damn it!
22:21:23 <argiopeweb> napping: I won't skip anything. Even if I already know what at tuple is, every language has something that can be applied elsewhere.
22:21:49 <argiopeweb> Case in point: I write C++ and Java significantly differently since I started using Common Lisp and then Haskell.
22:22:07 <KirinDave> argiopeweb: yeah, same here.
22:24:14 <argiopeweb> I might also add I have much less desire to write in C++ than I used to. I started out with less than no desire to write Java, so it didn't get much worse.
22:25:12 <pikhq_> argiopeweb: You *could* get that back, if you wanted.
22:25:21 <pikhq_> You should now understand template metaproramming.
22:25:39 <argiopeweb> pikhq_: I would hope.
22:25:50 <pikhq_> It's just a purely functional strict language with pattern matching, after all.
22:25:53 <argiopeweb> pikhq_: This being said, my coworkers would find where I lived and murder me.
22:25:55 <Kaidelong> KirinDave: now I can replicate your results quite dramatically
22:26:02 <KirinDave> Kaidelong: Yeah.
22:26:10 <Kaidelong> actually your version still hasn't stopped running
22:26:20 <KirinDave> Kaidelong: Well I need to do that reverse thing.
22:26:27 <Kaidelong> all the others took less than a second
22:26:29 <KirinDave> Kaidelong: I knew it was a problem, I was just keeping the code shorter.
22:27:21 <argiopeweb> GAH!!! Dynamic is one thing, but there should be no reason you can mix datatypes in a single list...
22:27:24 <argiopeweb> Evil.
22:27:56 <dmwit> argiopeweb: Go on then, how would you prevent that with dynamic typing?
22:27:59 <Kaidelong> dmwit's version seems to work the best except for small values of n where the first wrap I posted for some reason seems to have an advantage
22:28:03 <KirinDave> argiopeweb: I have a simple counterpoint.
22:28:07 <napping> Erlang is dynamically typed, yes
22:28:18 <KirinDave> Kaidelong: Also, mine is helped a lot by reversing.
22:28:19 <Kaidelong> no idea how to explain that
22:28:27 <KirinDave> argiopeweb: Json.
22:28:37 <argiopeweb> KirinDave: Well put.
22:28:56 <argiopeweb> dmwit: You wouldn't. You would simply discourage it in practice and blow up at runtime.
22:28:57 <dmwit> Also, even Haskell has heterogeneous lists. =)
22:28:57 <napping> You might be able to get dialyzer running, if you really want
22:29:22 <napping> I don't think it's particularly abused in OTP
22:29:29 <argiopeweb> 1> [1, 2, 3, {numbers,[4,5,6]}, 5.34, atom]. << That's not going to happen in haskell. ;)
22:29:34 <dmwit> \bot isn't around, but consider (3, "hello", True, ZipList []).
22:29:49 * Kaidelong was testing with a 525 MB text file
22:29:49 <dmwit> Sure it is, just not with square brackets.
22:30:10 <napping> or with {} brackets, for that matter :)
22:30:15 <Kaidelong> actually medical data, so I should probably not paste the results
22:30:25 <dmwit> It could happen with {}...
22:30:43 <KirinDave> argiopeweb: I mean people use algebraic datatypes to handle it, but that's always a pain.
22:30:57 <dmwit> Kaidelong: Out of curiosity, how small does "n" have to be to give yours an edge?
22:31:08 <dmwit> Are we talking small like 1000 or small like 10?
22:31:09 <Kaidelong> really tiny values, like n<5
22:31:13 <dmwit> yeah
22:31:15 <Kaidelong> so it's insignificant
22:31:16 <dmwit> Okay.
22:31:17 <Kaidelong> just odd
22:31:21 <dmwit> agreed
22:31:25 <Kaidelong> as in, I wasn't expecting it
22:31:28 <argiopeweb> > odd 5
22:31:31 <KirinDave> Kaidelong: Try mine with the reversed accum :)
22:31:32 <argiopeweb> Ah, too late.
22:32:03 <dmwit> Kaidelong: It's likely due to being a bit worse at GC.
22:32:19 <Kaidelong> it still uses more memory but for some reason it takes less time
22:32:24 <dmwit> (There's some spurious sharing in the last line.)
22:32:46 <Kaidelong> I suppose it is better at behaving like straight up "words"
22:33:56 <KirinDave> Holy crap.
22:33:58 <KirinDave> MapAccumL?
22:34:02 <KirinDave> Are you kidding me?
22:39:32 <Kaidelong> oh no I'm wrong
22:39:43 <Kaidelong> in some cases wrapd uses more memory than wrap1
22:53:56 <Algo> http://hackage.haskell.org/package/acme-now
22:54:01 <Algo> What the hell does this even do?!
22:54:15 <applicative> tells you the time of day?
22:54:24 <shachaf> Algo: Didn't you read? It "provides an interface to that moment, allowing it to be used in computations"
22:54:47 <Kaidelong> Algo: The whole point is that it is hard to tell what it does
22:54:50 <dmwit> It's a joke, like don't. =)
22:55:05 <Kaidelong> actually, I think, the behavior is implementation dependent
22:55:15 <Kaidelong> it illustrates how NOT to use unsafePerformIO
22:55:21 <dmwit> http://hackage.haskell.org/package/acme-dont
22:55:34 <applicative> > don't $ do { a <- [1,2,3]; show a}
22:55:48 <QtPlatypus> Algo: Hackage follows the CPAN convention of sticking jokes under acme.
22:55:57 <Algo> Ah, I see
22:56:07 <Kaidelong> basically
22:56:35 <Kaidelong> depending on the implementation
22:56:47 <Kaidelong> now might be the current time, or the "now" of some time in the past
22:56:59 <Kaidelong> (try it out in GHCi)
22:57:17 <applicative> it would be more widely imported if it returned a pure number, rather than a calendar time
22:57:19 <shachaf> Kaidelong: No, the point is that it's always the current time.
22:57:25 * shachaf wonders whether http://hackage.haskell.org/package/BASIC should be in ACME.
22:57:39 <Kaidelong> shachaf: well yes
22:58:19 * applicative thinks, at least that would put it at the top of the page, something it certainly merits
22:59:11 * shachaf never actually got it to work.
22:59:31 <applicative> it doesn't build?
22:59:51 <shachaf> It builds, but then it doesn't build.
23:00:04 * shachaf suspects that wasn't that useful a statement.
23:00:12 * applicative grasped it
23:00:24 <shachaf> It fails to build the BASIC programs.
23:01:04 <applicative> hmm, busted at the outset here; it needs the llvm package.
23:01:17 <shachaf> Well, yes, it had that.
23:01:19 <shachaf> Never mind.
23:02:19 <danharaj> are library dependencies in Cabal case sensitive?
23:02:54 * shachaf suspects so, but won't say anything because he doesn't know.
23:03:30 <applicative> cabal install fffff isn't case sensitive
23:05:48 <applicative> but the library field in a .cabal file is case sensitive, it seems
23:08:04 <danharaj> hmmm
23:08:16 <danharaj> If I use Control.Monad, should I specify a dependency to haskell2010?
23:08:20 * applicative remembers playing "HiLo.hs" from the BASIC package, but it was a long time ago
23:08:21 <danharaj> Is that the right thing to do?
23:08:44 <danharaj> or is it defined in base and I'll have a conflict?
23:09:38 <applicative> what do they have to do with each other?  (just wondering)
23:09:59 <danharaj> hm? I was just looking through hackage to find out where all my dependencies live
23:10:05 <danharaj> and Control.Monad is in Base and Haskell2010
23:11:40 <danharaj> ah whatever. I depend on base so hard in other ways.
23:11:42 * applicative has never seen Haskell2010 specified in  a file.
23:12:11 <danharaj> Is there a command to ask cabal to pretend to build/install my package to check for errors?
23:12:20 <applicative> dry run?
23:12:29 <danharaj> no thanks, I'm driving.
23:12:40 <c_wraith> yes, that's why you're qualified to make the run
23:13:35 <argiopeweb> Only at 2 AM would that have been that funny.
23:14:01 <c_wraith> it's 2 am somewhere
23:14:11 <argiopeweb> Right here.
23:14:14 <applicative> "    --dry-run Do not install anything, only print what would be installed." I think that will check for consistency.  But isn't there something better?
23:14:20 <argiopeweb> Well, 0219.
23:14:39 <c_wraith> there ghc-pkg check
23:14:56 <c_wraith> err, *there's.  That at least will tell you if what you currently have installed is consistent
23:16:30 <applicative> danharaj: what's to be said against  just building it?
23:17:34 <danharaj> applicative: I want to figure out how to use Cabal as a developer before I do that :)
23:18:51 <applicative> you don't have to install it, but only the ghc can tell you if everything is sound
23:20:03 * applicative always feels divine approval when his module type checks
23:20:20 <danharaj> How do you use cabal to test builds of a library? Like, I'm going to be hacking on this thing and rebuilding every day somewhat.
23:20:41 <danharaj> or should I be using another tool?
23:21:00 <applicative> cabal configure then cabal build then cabal clean then etc. is what i do, but i'm kind of an idiot
23:23:01 <danharaj> mm
23:23:03 <danharaj> yay, it works
23:36:03 <NemesisD> any of you guys use aeson
23:40:33 <argiopeweb> NemesisD: I've heard it recommended, but every library I've seen uses JSON
23:42:40 <shaleh> is it quiet in here or is client misbehaving?
23:44:29 <dmwit> shaleh: It's just quiet.
23:44:36 <dmwit> It's latish in the States.
23:44:56 <argiopeweb> Early-morningish, actually
23:45:02 <shaleh> indeed, almost midnight here
23:45:07 <argiopeweb> Well, I guess it's latish on the other coast.
23:45:09 <shachaf> argiopeweb: Not in the west coast!
23:45:21 <shachaf> Which is where all true Haskellers are.
23:45:25 * argiopeweb waves
23:45:50 <shachaf> But, yes, this channel is too quiet.
23:45:51 <shaleh> shachaf: I thought "true haskellers" were British? (-:
23:45:55 * argiopeweb pulls out his gun and gets in his truck and plays his country music
23:46:01 <shachaf> So, #haskell, what's a monad, *really*?
23:46:12 <shaleh> shachaf:
23:46:14 <shaleh> bah
23:46:16 <shaleh> silly client
23:46:36 <shachaf> Cale: lambdabot is down, by the way.
23:46:43 <shaleh> a way to ward off newbies? (re: what is a monad?)
23:47:12 <argiopeweb> No, that's zygohistomorphic prepromorphisms.
23:47:22 <shaleh> argiopeweb: good point (-:
23:47:51 <argiopeweb> A concept that's harder to type than explain. :\
23:47:59 * shachaf is vaguely disturbed by shaleh's smileys.
23:48:12 <ddarius> shachaf: Do you find them sinister?
23:48:15 <shaleh> shachaf: left handed habit.
23:48:35 <neophyte> is anyone in grad school?
23:48:48 * argiopeweb tentatively raises hand
23:48:55 <neophyte> nice, what do you study
23:48:56 <shaleh> and i have been doing them since before there were GUI clients which tried to have images for expressions
23:49:34 <shachaf> I guess they kind of look like Hebrew. Except they're on the wrong side.
23:49:49 <shaleh> shachaf: I hadn't thought of that
23:49:50 <argiopeweb> SE formally, though I'm really more of a CS type.
23:51:07 <neophyte> i'm a math major interested in pursuing cs in grad school
23:51:22 <NihilistDandy> neophyte: Me, too :)
23:51:29 <NihilistDandy> Might double major in CS, actually
23:51:33 <neophyte> very nice, glad i'm not the only one.
23:51:40 <argiopeweb> Depending on where you go, you should be well prepared if you have a basic understanding in CS and some minor programming skills.
23:51:49 <argiopeweb> You'll just have more reading to do.
23:52:00 <neophyte> it is too late for me to double major in cs, i'll be getting just a pure math degree
23:52:08 * argiopeweb has a CS prof who started as AE and then went CS for grad
23:52:17 <NihilistDandy> neophyte: Good. Glad you're not applied
23:52:25 <NihilistDandy> ;D
23:52:51 <neophyte> argiopeweb, i have some basic programming experience. by the time i graduate i'll have 2 or so theory courses under my belt.
23:53:21 <neophyte> i'm mostly interested in theory, i find it fun, and pretty similiar to what i do in math
23:53:48 <neophyte> sort of wish i knew i was interesed in cs earlier
23:54:00 <argiopeweb> Again, depends on where you go. Soft CS is almost all math and theory. Lambda calculus is your friend.
23:54:28 <argiopeweb> Hard CS is ridiculous and should be combined with SE to make SE less of a business/planning degree.
23:55:19 <pikhq_> CS education pretty much sucks, and the only reason people do well in spite of it is that CS attracts many smart people.
23:55:53 <argiopeweb> I highly recommend a class on programming languages that gets good coverage of the paradigms/BNF/GCs & etc and a compiler class if you can find them.
23:56:00 <argiopeweb> pikhq_: I can second that.
23:56:28 <argiopeweb> pikhq_: And the ones that aren't smart generally get hired to be programmers, albeit better payed than those with technical degrees.
23:57:25 <neophyte> argiopeweb will do, my theory of computation course covered: finite automata, grammar, computability and complexity. i thought the most interesting topics were the latter two.
23:58:46 <neophyte> of course in computability we just proved various things about turing machines, we didn't go into any other model of computation such as lambda calculus, but i feel like that is something i could easily teach myself.
23:58:48 <argiopeweb> neophyte: That's our first 200 level CS course. Data structures & algorithms builds on the latter 2, programming language theory builds on grammar.
23:59:18 <neophyte> very cool.
23:59:37 <neophyte> i plan to take a second semester course in it, but it mainly will focus on computability/complexity.
