00:09:54 * hackagebot synthesizer-dimensional 0.5.1 - Audio signal processing with static physical dimensions  http://hackage.haskell.org/package/synthesizer-dimensional-0.5.1 (HenningThielemann)
00:29:55 * ivanm tries to work out why exactly he's using "flip compare" instead of just compare ...
00:30:58 <ivanm> oh, that's right... I wanted longer lists first...
00:32:19 <ivanm> @src [] compare
00:32:19 <lambdabot> Source not found.
00:32:52 <ivanm> what's that way of getting the source for an instance from lambdabot?
00:33:23 <c_wraith> @src [] (>>=)
00:33:23 <lambdabot> xs >>= f     = concatMap f xs
00:33:35 <c_wraith> you had the syntax right, it's just not in lambdabot
00:34:10 <Phyx-> I wonder if I pretend this bug doesn't exist if it'll just go away
00:35:30 <ivanm> ahhhhh
00:36:09 <c_wraith> anyway, []'s Ord instance is just what you'd get from deriving Ord
00:36:50 <c_wraith> data [a] = [] | a : [a] deriving Ord
00:36:57 <c_wraith> The first constructor < the second constructor
00:37:13 <c_wraith> and if the constructor is the same, it compares elements in left-to-right order
00:37:18 <c_wraith> so first the a, then the [a]
00:38:07 <ivanm> well the instance isn't a derived one.. ;-)
00:38:41 <c_wraith> No, there are funny bootstrapping issues with using deriving in the standard libs.  plus, you know, that not being valid syntax for a data declaration anyway.
00:39:29 <c_wraith> But the Ord instance is the same as a derived one would be
00:40:37 <ivanm> yeah
00:40:56 * ivanm rebels and defines his own list comparison function
00:41:27 <ivanm> since I don't want to have to use "map reverse . sortBy (flip compare)"
00:41:53 <c_wraith> well, you're already using sortBy.  easy to fix it, then :)
00:46:23 <fragamus> @type Data.Map
00:46:24 <lambdabot> Couldn't find qualified module.
00:46:33 <fragamus> @type Data.Map.Map
00:46:35 <lambdabot> Not in scope: data constructor `Data.Map.Map'
00:46:51 <fragamus> hey guys help me
00:47:25 <fragamus> what is the type name of one of those map thingies
00:47:57 <ddarius>  @type tells you the type of values
00:48:04 <ddarius> :k Data.Map.Map
00:48:05 <lambdabot> * -> * -> *
00:48:17 <fragamus> thanx
00:48:27 <c_wraith> @type M.fromList
00:48:28 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
00:58:07 <fragamus> @type Data.Map.empty
00:58:08 <lambdabot> forall k a. M.Map k a
01:07:37 <c1de0x> so i'm thinking i might be able to parse bit-structures using parsec3, if I use a bitstream Stream type.
01:07:43 <c1de0x> but it's a bit ugly :(
01:08:09 <c1de0x> how does parsec backtrack with custom Streams
01:08:10 <c1de0x> ?
01:08:27 <c1de0x> the only required operation is uncons, so how does it return tokens to the underlying stream?
01:08:28 <Axman6> why wouldn't it?
01:09:11 <c1de0x> (unconsumed tokens, if a rule can't be reduced)
01:09:59 <c1de0x> i need to be able to take different paths in the parse-graph depending on the value of e.g. the next three bits.
01:10:15 <c1de0x> and if none of the values matches a transition, i need to backtrack.
01:10:41 <c1de0x> in which case, the next rule (on the other side of the nearest <|>) may need less than 3 bits, or more.
01:11:47 <ivanm> don't you use try f <|> g to do that?
01:11:53 <c1de0x> does the try parser just hold the pre-existing state of the underlying streams until a rule is successfully reduced.
01:12:13 <c1de0x> ivanm yeah, but if my underlying stream works on bits,... i'm not sure that f and g can consume differing lengths of bits.
01:12:45 <c_wraith> why wouldn't that be allowed?
01:12:45 <c1de0x> unless f is specified as bitparser bitparser bitparser
01:12:53 <c1de0x> and g is bitparser bitparser for e.g.
01:13:15 <c1de0x> but then it makes it unwieldy for me to convert the three bits into an integer, to determine which path to take next.
01:13:42 <c1de0x> sometimes 4 bits in a row choose the path, and sometimes they're jsut a 4 bit field.
01:14:39 <c_wraith> well, yes, the types need to match
01:14:55 <c1de0x> yeah. this is my issue.
01:15:11 <c_wraith> but that'd be your issue whether you're using custom bitstreams or not
01:15:21 <c1de0x> i know.
01:15:30 <c1de0x> it;s just more apparent with bitstreams, as it's
01:15:44 <c1de0x> 'easier' to interpret 4 bits as either a 4 bit immediate value, or 4 bitfields
01:16:46 <c_wraith> I...  don't really see a difference.  Is 4 characters in a row a word, or 4 unrelated symbols?
01:24:18 <boegel> is GHC.Conc.Sync special?
01:25:10 <boegel> ghci can't seem to find the module, but hoogle is returning functions from that module (with a local search)
02:29:10 <fragamus> I need help
02:29:42 <fragamus> I am using State monad and I need to generate a random number to modify the state
02:31:26 <ivanm> @google random supply monad
02:31:27 <lambdabot> http://book.realworldhaskell.org/read/programming-with-monads.html
02:31:28 <lambdabot> Title: Chapter 15. Programming with monads
02:31:31 <ivanm> fragamus: ^^
02:32:29 <fragamus> http://hpaste.org/46921/need_help_generating_random_ze
02:33:03 <fragamus> I just need zero_one_two to be a random number 0-2
02:33:41 <ivanm> @type randomR
02:33:41 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
02:34:44 <Eduard_Munteanu> You can get an infinite supply (e.g. list) of randomness from IO and pass that on to your State-ish function
02:35:22 <ivanm> @type randomRs
02:35:23 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
02:36:17 <Eduard_Munteanu> @hoogle random
02:36:17 <ivanm> > randomRs (0,2) (mkStdGen 3)
02:36:17 <lambdabot> package random
02:36:17 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
02:36:17 <lambdabot> module System.Random
02:36:18 <lambdabot>   [2,0,1,0,0,1,0,0,1,0,2,1,0,1,1,1,2,0,2,0,1,0,0,0,1,2,2,1,2,2,2,2,2,0,1,1,1,...
02:37:35 <fragamus> i beg you to look at my hpaste and give me clue im a newb
02:38:05 <Eduard_Munteanu> fragamus: take what ivanm told you, and pass it into your State function
02:38:15 <fragamus> uh
02:39:00 <blamout> this error message start to makes me hate sdl... "Loading package SDL-0.6.2 ... can't load .so/.DLL for: SDL (addDLL: could not load DLL) ", sdl is set up properly, I don't understand what's happening... any clues?
02:39:06 <Eduard_Munteanu> You can augment your state type to carry the random list around.
02:39:18 <fragamus> randomRs (0,2) (mkStdGen 3)
02:39:37 <Eduard_Munteanu> Yeah, that.
02:39:41 <Saizan> blamout: does it work when compiled?
02:40:07 <Eduard_Munteanu> blamout: Windows?
02:40:33 <ivanm> Eduard_Munteanu: well, using newStdGen....
02:41:23 <blamout> yes
02:41:24 <Eduard_Munteanu> blamout: if it's Linux or something Unix-y I'd take a look at that .so, maybe it's a linker script.
02:41:25 <blamout> windows...
02:41:27 <Eduard_Munteanu> Ah.
02:41:34 <blamout> :/
02:41:41 <ivanm> blamout: chuck the .dll file in the folder with your code
02:41:47 <blamout> done too
02:42:05 <blamout> I saw some posts already about this issue
02:42:19 <blamout> people talking about a known problem unsolved for long time o_O
02:42:36 <blamout> but not much detail, so I can't be sure it's the same thing
02:45:25 <Xaratas> hi, i have a parse error in a case but cannot find out why. http://hpaste.org/46922/parse_error  I use the same kind of case in other places without problems
02:46:47 <ivanm> Xaratas: you have to have something = case ....
02:46:57 <ivanm> in your case, trieB' = case ...
02:47:45 <Xaratas> ah
02:48:13 <Xaratas> :)
02:48:25 <Xaratas> good to know, thanks ivanm
02:50:19 <ivanm> np
02:59:22 <develhevel> do i need hClose when i work with readFile? or only for openFile
03:02:42 <Silvah> :t readFile
03:02:42 <lambdabot> FilePath -> IO String
03:02:49 <Silvah> What would you want to close?
03:03:29 <ivanm> develhevel: it does it for you
03:04:30 <Silvah> o.O
03:04:38 <Silvah> readFile name   =  openFile name ReadMode >>= hGetContents
03:05:53 <Silvah> So when the file gets closed?
03:06:06 <ivanm> yeah, doesn't openFile do some kind of magic?
03:06:15 <Eduard_Munteanu> Probably the RTS gets at it after you return from main.
03:06:38 <Eduard_Munteanu> Just like glibc frees handles and allocations left over.
03:07:06 <fragamus> @type mkStdGen
03:07:07 <lambdabot> Int -> StdGen
03:07:10 <Eduard_Munteanu> It's probably not a big deal especially when _reading_ a file.
03:07:20 <ivanm> @type newStdGen
03:07:21 <lambdabot> IO StdGen
03:07:27 <ivanm> fragamus: ^^ what you want
03:07:43 <Silvah> Eduard_Munteanu: *glibc* frees handles and allocations?
03:08:45 <Eduard_Munteanu> IIRC yes; though the kernel might get at it anyway.
03:09:08 <roconnor> I think hGetContents will close the handle when it lazilly gets to the end?
03:09:09 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
03:11:01 <Eduard_Munteanu> Silvah: do you have valgrind? Take a look at --run-libc-freeres=<yes|no>
03:11:23 <Eduard_Munteanu> So it normally doesn't but you can instruct it too. Anyway, this is more about how the GHC RTS handles this sort of stuff.
03:11:44 <Eduard_Munteanu> s/too/to/
03:12:03 <Saizan> hGetContents does the closing when/if it reaches EOF, otherwise the garbage collector will
03:12:06 <Silvah> Eduard_Munteanu: no, I don't have valgrind, its developers are too lazy and/or stupid to make it work on OS I'm using.
03:13:11 <Eduard_Munteanu> :)
03:14:22 <fragamus> I need my state monad to incorporate IO so i can access random numbers
03:14:36 <ivanm> no you don't
03:14:46 <ivanm> either pre-supply it with random numbers from the beginning
03:15:16 <fragamus> i need them to be global so that different instances dont generate identical sequences
03:15:19 <ivanm> or have your State monad store the current seed, and give it one from newStdGen
03:15:29 <ivanm> that should produce unique sequences
03:17:57 <absence> http://pastebin.com/KpLYQNDw <- is it possible to make this more concise using library functions? (it calls the getTag action until it returns endtag, and returns a list of all the tags)
03:19:04 <Eduard_Munteanu> fragamus: you can do stuff like   consume = do { (st, r:rs) <- get; put (st, rs); return r }
03:19:56 <Eduard_Munteanu> (where 'st' is your proper state and 'rs' the random numbers)
03:20:27 * hackagebot polyparse 1.6 - A variety of alternative parser combinator libraries.  http://hackage.haskell.org/package/polyparse-1.6 (MalcolmWallace)
03:22:10 <Phyx-> is there a set of Haskell benchmarks that produce alot of data?
03:22:48 <fragamus> Ed: yes I got that
03:23:03 <fragamus> thanks
03:27:52 <Athas> I have a .cabal file that defines both a library and executable.  Is there a way to avoid duplicating the build-depends field?
03:31:14 <ivanm> Athas: you shouldn't need to have any common ones for the executable
03:31:34 <ivanm> unless you use cabal-1.8's "use the library" feature, which results in haddock docs not building :s
03:31:53 <Athas> So I don't need a build-depends field for the executable?  How does that work?
04:08:12 <osfameron> gosh. deleting from a red-black tree is a PITA
04:08:28 <osfameron> okasaki didn't mention that bit in Purely FP datastructures did he?
04:08:45 * osfameron can't find his copy of the book, but his paper doesn't, and the internets suggest the book doesn't either
04:12:07 <jeffz> osfameron: it doesn't mention a delete operation
04:12:17 <gienah> osfameron: it looks like there is an implementation in coq here: http://coq.inria.fr/distrib/v8.2/contribs/FSets.FSetRBT.html
04:12:38 <Jafet> I guess Okasaki knew.
04:13:04 <osfameron> gienah: thanks.  I don't read Coq though :-(
04:13:26 * osfameron will read the algorithm descriptions on wikipedia and have a go at it
04:13:34 <osfameron> I guess the ones on hackage will be interesting too
04:18:10 <absence> is there a library function similar to this? sequenceUntil act p = act >>= \x -> if p x then return [] else (x:) `liftM` sequenceUntil act p
04:21:36 <Eduard_Munteanu> Maybe/MaybeT kinda lets you do that.
04:22:09 * ski might call that `replicateUntilM'
04:22:14 <Athas> What's the best Haskell indentation mode for Emacs?  There seems to be several.
04:23:44 <erus`> is there a haskell type language on the jvm?
04:24:26 <ivanm> Athas: indent is the newest one
04:24:31 <ivanm> it's a little fussy though
04:24:37 <Athas> haskell-indent-mode?
04:24:39 <ivanm> indentation is the one with the tab-cycle
04:24:40 <ivanm> yeah
04:25:05 <Athas> It doesn't indent do-blocks as well...
04:25:38 <ivanm> sure it does
04:28:17 <gienah> osfameron: looks like there is some extracted ocaml code from the coq here: http://www.lri.fr/~filliatr/fsets/ it  might be possible to extract haskell code from the coq
04:29:05 <osfameron> gienah: ta ;-)
04:30:00 * osfameron is actually implementing is in nothaskell (Perl in this case) but at least I may be able to understand the spec in haskell...
04:30:01 <absence> ski: hmm yes, it fits better with replicateM :)
04:32:38 <gienah> osfameron: of course coq can not extract perl :-)
04:36:42 <osfameron> gienah: yup, I can imagine it'd have some trouble with that ;-)
04:36:52 <hpc> gienah: sure it can! #!/usr/bin/perl \n print `runhaskell theactualoutput.hs`
04:37:25 <hpc> :P
04:37:41 <gienah> hpc: perfect solution :-)
05:16:45 <ezyang> Hey #haskell, recommend me a PPM library. Or should I just build it myself...
05:17:07 <aristid> what is PPM?
05:17:18 <ezyang> "Portable Pixel Map"
05:17:44 <Ke> isn't ppm just plaintext in trivial format
05:17:46 <ezyang> I'm revising for a computer graphics exam, and I figure the best way to internalize the algorithms is to implement them.
05:17:51 <ezyang> Yes, it is pretty trivial.
05:18:04 <aristid> ezyang: look at this list: http://en.wikipedia.org/wiki/PPM
05:18:32 <ivanm> IIRC, RWH covers PPM.....
05:18:54 <ezyang> Oh that's right, I do remember that!
05:19:03 <Axman6> there was a pretty cool underhanded C contest winner i think that implemented a redaction program to black out certain areas of the image, but managed to keep a large portion of the information there
05:19:33 <Jafet> Actually, plaintext pixmap is less trivial to parse than binary pixmap
05:19:56 <aristid> but probably still trivial enough
05:19:59 <Jafet> hackage must have libraries for other formats, though
05:21:08 <ivanm> well, yeah, there's been a minimal PPM parser that was included as part of a first year Haskell assignment last year...
05:21:51 <ezyang> The only thing is that I want to spend as little time on the file format as possible.
05:23:01 <Jafet> ([[Pixel]]?)
05:23:17 <ezyang> but I do want to be able to see the picture!
05:23:31 <ezyang> Also, [[Pixel]] is /such a bad idea/ :-)
05:23:50 <ezyang> I think I'll use Data.Vector.Unboxed.Mutable
05:25:04 <ezyang> Hmm, since no one seems to support vector directly, I'll guess I'll write it myself.
05:26:16 <Jafet> Also, PPM formats are funny in that hardly any software that implement them implement them completely
05:26:35 <Jafet> Each PPM stream is allowed to contain a series of images
05:26:42 <ezyang> Hmm, actually, vector seems to be pretty inappropriate for multi-dimensional arrays.
05:26:50 <Jafet> Kind of like TIFF, the other meta-format that's never implemented properly
05:26:52 <ivanm> ezyang: REPA?
05:27:04 <ivanm> not sure why I capitalised that...
05:27:31 <aristid> ivanm: maybe because people were talking about PPM, TIFF, RWH...?
05:27:40 <ivanm> heh, could be
05:27:53 <ezyang> Ee, repa looks exactly what I want.
05:28:28 * Saizan notices the anagram just now
05:28:33 <ezyang> Hmm, but my GHC is too old :-(
05:28:35 <ivanm> ezyang: dons did a recent tutorial on repa if you want to get up to steam on the API
05:28:36 <aristid> looks like repa does not comonad instances!
05:28:49 <ivanm> Saizan: what anagram?
05:29:37 <Saizan> of repa
05:29:56 <Jafet> > permutations "repa"
05:29:57 <lambdabot>   ["repa","erpa","pera","epra","prea","rpea","aper","paer","pear","aepr","eap...
05:30:00 <luite> notlob
05:30:12 <ivanm> Saizan: which particular anagram?
05:31:04 <ezyang> Ah well, time to bust out 7.0.3, then.
05:31:15 <ezyang> I hope Cabal doesn't do bad things to .cabal.
05:31:27 <Saizan> ivanm: rape, but pera too
05:31:36 <ivanm> OK then...
05:31:47 <dafis> ezyang: careful, I don't know if repa is affected, but for vectors, check #5149
05:31:50 <ivanm> ezyang: you'll have to rebuild everything...
05:32:28 <dafis> ezyang: so perhaps 7.0.2 is the better choice until 7.0.4 comes
05:32:29 <ezyang> dafis: Won't be doing floating point, should be OK.
05:32:37 <ivanm> why is "cabal upload" asking me for Hackage username and password when they're already set in my ~/.cabal/config ?
05:32:53 <dafis> ezyang: okay, the 7.0.3 has a couple of bug fixes over 7.0.2
05:32:58 <dafis> *then
05:33:04 <ezyang> ivanm: A build GHC regularly; it can't be that bad, right? :-)
05:33:15 <dafis> ivanm: a bug in cabal install
05:33:30 <dafis> ivanm: the darcs version is said to be fixed
05:33:41 <ezyang> Oh hey, repa supports bmp natively.
05:33:48 <dafis> cool
05:33:58 <ivanm> dafis: OK
05:34:16 <dafis> ivanm: I have an alias
05:34:27 <dafis> (supplying username and pw)
05:36:07 * hackagebot wl-pprint-text 1.0.0.0 - A Wadler/Leijen Pretty Printer for Text values  http://hackage.haskell.org/package/wl-pprint-text-1.0.0.0 (IvanMiljenovic)
05:37:49 <tomh> hmm there is no safe way to get an array element?
05:38:47 <dafis> tomh: what do you consider the unsafe way?
05:38:51 <tomh>  !
05:38:53 <dankna> tomh: you would need type-level indices
05:39:06 <dankna> which is... possible but nontrivial
05:39:12 <dankna> (I think)
05:39:22 <tomh> well ! could return a maybe right?
05:39:28 <dankna> ah, yes, it could
05:39:32 <dafis> you could get a (Maybe element) safely
05:39:34 <dankna> you can write that wrapper yourself
05:39:47 <aristid> :t inRange
05:39:48 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
05:39:52 <tomh> dankna: ofcourse I can, but why is it not by default?
05:40:04 <tomh> Map.lookup is a Maybe
05:40:12 <tomh> :t Map.lookup
05:40:12 <dankna> yeah, weird
05:40:13 <lambdabot> Couldn't find qualified module.
05:40:18 <tomh> oh
05:40:20 <mornfall> Well, (!!) is unsafe too.
05:40:22 <dankna> I mean, "the default status of features is nonexistent"
05:40:34 <dankna> one possible explanation is simply that nobody has implemented it
05:40:35 <dafis> :t M.lookup
05:40:36 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
05:40:40 <Jafet> Because the range of indices for an array is usually known in advance
05:41:03 <Jafet> ... is my guess.
05:41:05 <mornfall> And so is head.
05:41:06 <mornfall> Etc.
05:41:10 <tomh> yeah, but...but..thats going back to C style array out of bound errors ;p
05:41:31 <tomh> anyway Ill write it myself
05:41:39 <aristid> tomh: well yeah, the bounds really should be in the type. but that would be messy in haskell as it is
05:41:44 <dafis> tomh: C doesn't have array out of bounds errors
05:41:47 <aristid> maybe type-level naturals will improve that
05:42:05 <dankna> aristid: are we getting standard type-level naturals in Haskell 2011?
05:42:05 <Jafet> Oleg has written type-level bounds checking
05:42:07 <tomh> dafis: I mean the index out of bound or whichever it throws :P
05:42:09 <ktosiek> dafis: they are called segmentation faults
05:42:11 <ktosiek> ;-)
05:42:16 <tomh> yeah that
05:42:19 <dafis> ktosiek: quite
05:42:19 <aristid> dankna: i don't know. probably not?
05:42:21 <Jafet> In C, it's just undefined
05:42:26 <dankna> yeah, hm
05:42:31 <Jafet> (And not Haskell's undefined, mind you)
05:42:31 <aristid> dankna: i think GHC has some patch flying around that has it
05:42:33 <mornfall> ktosiek: Sometimes. :) Othertimes they are called "wrong output".
05:42:37 <aristid> not sure if they applied it
05:42:41 <dankna> there's actually several packages that provide it
05:42:45 <dankna> but it would be more useful were it standard
05:43:04 <aristid> dankna: i mean integrated in the compiler. and there is a GHC patch for that
05:43:14 <dankna> hmm, neat
05:43:24 <aristid> it got its own kind, even
05:43:28 <dankna> nice!
05:43:47 <aristid> now if i would find that patch :D
05:44:40 <aristid> dankna: i think it was this: http://hackage.haskell.org/trac/ghc/ticket/4385
05:46:22 <dankna> aristid: hmmmm.  I shall have to save that and read the discussion there later.
05:47:37 <dankna> in particular it links to http://hackage.haskell.org/trac/ghc/wiki/TypeNats which is nice
05:48:10 <dankna> I see that he (the one who wrote the patch) has migrated his changes to git, so that's evidence he's still working on it
05:49:27 <aristid> iavor diatchki?
05:50:15 <dankna> yes
05:50:49 <ezyang> Ah Iavor. Great guy.
05:52:41 <aristid> \o/ "There is a new kind, Nat. It is completely separate from GHC's hierarchy of sub-kinds, so Nat is only a sub-kind of itself. "
05:53:16 <dankna> I was briefly insane enough to want type-level floats
05:53:19 <dankna> but I forget why
05:54:10 <aristid> heh.
05:54:26 <aristid> dankna: type-level rationals... maybe. but floats?! insane :)
05:54:52 <dankna> hehe :)
05:55:00 * dafis likes type-level NaNs
06:00:56 <Jafet> There's a Nat package using binary encoding, too
06:09:01 <iago> hi all, should I assume that once I get an "Internal Happy error" (from a parser built with Happy...) there is nothing I can do?
06:12:40 <aristid> why isn't TupleSections in the standard? (Haskell 2010?)
06:12:47 <aristid> is there any problem with it?
06:13:37 <isomorphic> I'm reading RWH - Chapter 16
06:13:44 <isomorphic> Can anybody explain the following?
06:13:44 <ivanm> aristid: I think it may have been introduced too late
06:14:13 <isomorphic> (char ',' >> cells)  -- Found comma?  More cells coming
06:14:25 <isomorphic> It's on the page http://book.realworldhaskell.org/read/using-parsec.html
06:14:56 <isomorphic> ie: isn't char ',' "thrown away" ?
06:15:04 <Botje> yes
06:15:16 <dafis> isomorphic: it's just for checking there is one
06:15:26 <Botje> char ',' is a parser that only succeeds if there is a ',' at the front of the input
06:15:40 <isomorphic> right- so it succeeds, and throws the comma
06:16:06 <Botje> yes
06:16:19 <Botje> if it fails, the <|> combinator tries the other parser, which always succeeds
06:16:36 <isomorphic> Yes.  But on success of the first parser
06:16:57 <isomorphic> >> cells results in a call to 'cells' with the remainder of the line?
06:17:01 <isomorphic> ie: sans the comma?
06:17:05 <Botje> yes
06:17:12 <isomorphic> thanks :)
06:45:13 <aristid> ivanm: lol that wl-pprint-text announcement is a funny read
06:47:32 <ivanm> aristid: glad someone enjoyed it :D
06:47:47 <ezyang> With Repa, I can't draw pixels easily. Is this intentional?
06:48:07 <ivanm> ezyang: maybe see how the bmp version does it?
06:49:52 <ezyang> oh, well, bitmap files are just a stream of values which get slurped up into the Repa array. This doesn't actually seem appropriate for, you know, pixel drawing.
06:52:28 <aristid> ivanm: i'm pretty easy to entertain, so it doesn't mean much :P
06:53:21 <ivanm> preflex: seen roconnor
06:53:21 <preflex>  roconnor was last seen on #haskell 3 hours, 44 minutes and 17 seconds ago, saying: I think hGetContents will close the handle when it lazilly gets to the end?
06:53:32 <ivanm> @tell roconnor try data-clist instead of pointedlist
06:53:33 <lambdabot> Consider it noted.
06:54:21 <ezyang> Why would I use unboxed vector over an stuarray?
06:54:32 <ezyang> (ignoring fusion, for a moment)
06:54:57 <ivanm> ezyang: I think that's pretty much it
06:55:04 <dafis> ezyang: ignoring fusion, I know no reason
06:55:06 <ezyang> Huh, curious.
06:55:09 <ivanm> and that a lot of high-performance packages are migrating over to it
06:55:18 <ivanm> i.e. compatability
06:55:29 <ivanm> e.g. aeson
06:56:16 <ezyang> Why doesn't vector support multi-dimensional indexing? Seems like a handy thing to have...
06:57:00 <ivanm> *shrug* ask Roman ;-)
06:57:23 <dafis> ezyang: iirc, it's much harder to get fusion for those
06:57:39 <ivanm> dafis: that's probably it
06:58:44 <ezyang> OK, in that case I guess UArray + Codec.Image.DevIL will be my choice of poison.
06:58:57 <ezyang> Maybe I'll play with repa later :^)
06:59:01 <ivanm> ezyang: noooo! don't kill yourself!
06:59:02 <ivanm> :p
07:02:49 <luite> does repa have a safe mode where everything is bounds checked?
07:04:44 <dafis> luite: methinks vector can be built to do bounds-checking with a flag, wouldn't surprise me if it was the same for repa
07:07:12 <luite> dafis: yeah I know about vector, but I can't  find it in the repa .cabal, it might be buried deeper in the code
07:07:51 <dafis> perhaps there's no such flag for repa
07:09:08 <luite> possibly. I think it would be useful to have for debugging, and for safely using it in lambdabot and similar applications
07:28:13 <Aune> Hello all. I decided to learn some graph-theory so I started reading http://book.huihoo.com/pdf/graph-theory-With-applications/   . Now I got to question 1.4.4 which is: "Find a bipartite graph that is not isomorphic to a subgraph of any k-cube". Any pointers?
07:28:19 <_exterm> Hello everybody
07:28:41 <_exterm> I'm experimenting with type classes. Why does this http://hpaste.org/46931/class_chaos not work?
07:31:06 <dafis> _exterm: the signature says test can be *any* type that belongs to Group
07:31:08 <Lemmih> _exterm: You're stating that 'test' is any instance of Group /and/ an Int. It clearly can't be both at the same time.
07:31:27 <dafis> what if someone writes "instance Group Word"?
07:33:05 <_exterm> OK, the problem I'm trying to solve is that I have some enum types and I want to define a list of values that belong to any of these enums. thought I could solve that by type classes.
07:34:07 <iskren> hello, I'm trying to run some tests with HUnit, but I can't make it compile. I want the main to execute the tests (main = runTestTT root) and I'm compiling with ghc (ghc Tests.hs). It gives undefined reference (linker problems)
07:34:34 <dafis> iskren: ghc --make
07:34:37 <iskren> that works
07:34:41 <_exterm> Is there a sensible way to do that?
07:34:45 <dafis> unless you're using ghc-7.*
07:35:06 <iskren>  6.12.3
07:35:23 <iskren> is that a problem?
07:36:53 <dafis> iskren: no, but as of ghc-7, --make is the default, so if you get "undefined reference" with ghc-7, it's not as simple as a forgotten --make
07:36:56 <iskren> in the ghci it works fine (loading the test file and running it manually)
07:37:19 <dafis> iskren: ghci uses --make since Simon-knows-when
07:37:20 <_exterm> Lemmih: I'm trying to do something like this: http://hpaste.org/46932/try
07:37:59 <iskren> dafis, ok, but why is it not finding the HUnit library, I've installed it from fedora package... it should be placed correctly
07:38:20 <dafis> iskren: what's the error message?
07:39:18 <iskren> http://fpaste.org/dOvh/
07:40:06 <dafis> iskren: looks like stale .hi and .o files, rm Test.o; rm Test.hi; ghc --make Test; or ghc --make -fforce-recomp Test
07:40:34 <Lemmih> _exterm: You really don't want to do that.
07:40:43 <_exterm> :-D
07:42:48 <_exterm> Lemmih: i have multiple selectors to select values for multiple options, like dropdowns containing A and B  or D and E. I then need to express restrictions (if A, then not E) and display them in the interface (the second dropdown just contains D if A is selected).
07:43:32 <_exterm> Lemmih: my Idea for the restrictions was: (Exclude, A, E) for "if A then not E".
07:43:58 <_exterm> but for that I need this kind of list...
07:44:18 <Lemmih> _exterm: I'm not sure I'd try to enforce this in the type-system.
07:45:28 <Lemmih> _exterm: How about using a tree, instead?
07:45:34 <_exterm> Lemmih: I don't want to enforce it but I have to have some way to express it.
07:45:43 <_exterm> Lemmih: How?
07:46:56 <_exterm> Lemmih: Sounds like that would lead to duplication in the specification
07:46:58 <Lemmih> _exterm: [Branch A [Leaf D], Branch B [Leaf E]] perhaps.
07:47:24 <parcs> what is the language extensions that permits a function like `f :: Enum a => [a]; f = [True, False, ()]` ?
07:48:06 <nihtml> :t liftIO
07:48:06 <dafis> parcs: none yet
07:48:07 <lambdabot>     Ambiguous occurrence `liftIO'
07:48:07 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
07:48:07 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
07:48:08 <Lemmih> parcs: -XUnsafeCoerceEverything
07:48:29 <parcs> i thought i remember reading about it in the users' guide..
07:48:35 <Lemmih> parcs: I'm kidding, of course. There is no such extension.
07:48:41 <Tomsik_> parcs: you can have existentially-typed constructructors
07:48:54 <Tomsik_> data X = forall Enum a . X a
07:48:57 <_exterm> Lemmih: Good idea but then I would get [Branch A [Leaf D], Branch B [Leaf E, Leaf D]] instead - also in reality I have a lot more Options so this would grow very large and contain duplicated data. Like this: [Branch A [Leaf D], Branch B [Leaf E, Leaf D], Branch C [Leaf E, Leaf D]]
07:49:01 <parcs> Tomsik_: ah, that was it!
07:49:04 <Tomsik_> and then f :: [X]
07:49:29 <Jafet> > let f :: Show a => [a]; f = [True, False, ()]; in show =<< f
07:49:30 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
07:49:30 <lambdabot>         against inferred type ...
07:50:13 <Jafet> > let f :: forall a. Show a => [a]; f = [True, False, ()]; in show =<< f
07:50:14 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
07:50:14 <lambdabot>         against inferred type ...
07:50:23 <Jafet> Hrm
07:51:13 <Lemmih> _exterm: Write a helper function so you don't have to type in the duplicates by hand?
07:52:42 <Lemmih> _exterm: Or use the tree to enumerate exclusions instead of inclusions.
07:54:57 <_exterm> Lemmih: My collegaue just mentioned that we would get the same problem with the tree because the tree would be of the type Group a => a (with my first example http://hpaste.org/46931/class_chaos in mind).
07:55:31 <_exterm> The tree would have elements from any of the enums.
07:55:47 <alexbagel> hello, is there a helper function somewhere to flip an Ord enum? i.e. \x -> case x of {GT -> LT; LT -> GT; EQ -> EQ}
07:55:57 <Lemmih> _exterm: I don't see why you would want that.
07:56:08 <dafis> alexbagel: flip compare
07:56:16 <ClaudiusMaximus> @hoogle Ordering -> Ordering
07:56:16 <lambdabot> Prelude pred :: Enum a => a -> a
07:56:16 <lambdabot> Prelude succ :: Enum a => a -> a
07:56:16 <lambdabot> Prelude id :: a -> a
07:56:31 <mauke> > let f = compare EQ in map f [GT, LT, EQ]
07:56:33 <lambdabot>   [LT,GT,EQ]
07:56:37 <_exterm> Lemmih: you would put all the values in the same enum?
07:57:37 <Lemmih> _exterm: In your example, you grain absolutely nothing by having T1 and T2 as distinct types.
07:58:00 <alexbagel> hmm, thanks guys but not not exactly what i need. i guess I'll just keep writing my own one-liner. cheers
07:59:05 <_exterm> Lemmih: yes, it is difficult to condense it into a minimal example. I'm filling dropdown boxes. Each dropdown box contains all values of "its" enum.
07:59:44 <dafis> alexbagel: mauke's compare EQ does exactly what you asked
08:02:24 <Lemmih> _exterm: Without knowing more about what you're actually trying to do, I can't be of much help.
08:03:31 <burbul> Could I ask an elementary question about the State monad?
08:03:41 <parcs> no! never!
08:04:01 <burbul> :) Why isn't it defined as 'State s a = State s -> (a,s)' ?
08:04:21 <mauke> because State s is a kind error
08:04:22 <burbul> or maybe 'State s a = State (s -> (a,s))'
08:04:29 <alexbagel> dafis: yes. yes it does. my apologies
08:04:36 <dafis> burbul: because you cant't write a Monad instance for that
08:04:44 <mauke> @src State
08:04:45 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
08:05:01 <mauke> burbul: it is defined as that
08:05:29 * dafis overlooked the second 'State' :(
08:05:38 <_exterm> Lemmih: OK, thanks for your help so far though! I think we'll solve this with some more brainstorming.
08:05:49 <dafis> mauke: it was, no longer in mtl-2
08:06:23 <burbul> In the tutorial I'm looking at there's a bit about { runstate :: ... }
08:06:39 <mauke> yes
08:07:07 <mauke> saves you having to write runState by hand
08:07:11 <SpinDoctor> newbie trying EclipseFP for first time.  Anyone familiar with it?
08:07:14 <parcs> that's just for convenience, to be able to extract it without pattern matching
08:07:28 <dafis> burbul: newtype State s a = State { runState :: s -> (a,s) } is the same as newtype State s a = State (s -> (a,s)); runState :: State s a -> (s -> (a,s)); runState (State m) = m
08:07:53 <dafis> just with some more convenient syntax
08:07:55 <burbul> I see --- thanks
08:07:59 <mauke> capture :: (PeekClass s p, MonadState (M.Map k [c]) p, PositionClass p, Stream s c, Ord k) => k -> p a -> p ()
08:08:06 <mauke> this code might be a bit too generic
08:08:16 <burbul> I didn't realise you could still pattern match against the variant with braces
08:12:55 <absence> http://pastebin.com/uJTNVckL <- is there a better way to write a single toList function rather than one for each data constructor?
08:13:15 <mauke> *> let p = lift (some anyToken)  in tparse (capture 0 p >> capture 1 p) "abc"
08:13:15 <mauke> [fromList [(0,"a"),(1,"b")],fromList [(0,"ab"),(1,"c")],fromList [(0,"a"),(1,"bc")]]
08:13:18 <mauke> whee
08:18:19 <cizra2> cabal install network fails mysteriously
08:18:37 <Cale> Without printing any messages?
08:18:56 <cizra2> http://hpaste.org/46934/cabal_install_network_fail
08:19:04 <cizra2> No, not *that* mysteriously.
08:19:16 <cizra2> "Ambiguous occurrence `closeFdWith'
08:19:38 <Cale> Which GHC do you have?
08:19:54 <cizra2> And the mysterious part of it is that a package with such a useful name fails to install.
08:20:00 <cizra2> 7.0.2, as it syas in the paste.
08:20:11 <Cale> hmm
08:20:16 <dafis> cizra2: my guess, closeFdWith was added to GHC.Conc and network hasn't yet been updated
08:21:26 <dafis> OTOH, network-2.3.0.2 built fine with my 7.0.3
08:22:35 <Cale> absence: um... I don't think I understand the purpose of your code...
08:23:19 <cizra2> dafis: Yeah, sounds like it'd be simply fixed by adding qualified import or something.
08:23:20 <Cale> absence: You're aware that the functions you're writing are partial, and will fail when presented with the wrong constructor? Is that intentional?
08:27:15 <dafis> cizra2: New guess: you're using an old cabal
08:28:50 <dafis> cizra2: if base >= 4.3.1, closeFdWith is imported from GHC.Conc, otherwise it's defined in Network.Socket, protected by a MIN_VERSION_base pragma, that pragma was broken in earlier Cabal versions, I suspect that's what's happening here
08:28:59 <Cale> absence: It would be better generally to pattern match on constructors when extracting whatever data you're getting out of the Tag values, and be able to handle failure more appropriately like that.
08:33:11 <cizra2> dafis: Okay, how do I upgrade it? cabal install cabal did nothing and cabal install cabal-install failed because it depends recursively on network, which fails to install.
08:33:30 <dafis> cizra2: cabal install network-2.2.3.1; cabal install cabal-install-0.10.2; cabal install network; I think that should work
08:34:58 <dafis> perhaps you need a constrain network < 2.3 when installing cabal-install
08:35:05 <dafis> constraint*
08:37:32 <Tomsik__> setup: The program pgconfig is required but it could not be found.
08:37:42 <Tomsik__> (cabal install hdbc-postgresql)
08:37:55 <dafis> Tomsik__: OS?
08:37:56 <Tomsik__> What now? I've got a working postgres server
08:37:58 <Tomsik__> Debian
08:38:15 <Tomsik__> And I can use psql to manipulate my db
08:38:35 <dafis> apt-get search pgconfig ?
08:38:43 <Tomsik__> nope, didn't show anything
08:38:50 <parcs> which pgconfig?
08:39:01 <Tomsik__> nope
08:39:05 <Tomsik__> not as root either
08:39:48 <parcs> hmm, my postgres installation doesn't have pgconfig either
08:40:00 <parcs> let me try to install hdbc-postgresql
08:40:26 <parcs> is this postgres 9 you're using?
08:41:04 <parcs> it installed for me
08:41:08 <Tomsik__> yep
08:41:25 <Tomsik__> 9.0.4 to be exact
08:41:32 <Tomsik__> that's weird
08:41:59 <parcs> i'm also using version 9
08:43:03 <Tomsik__> Okay, works, I needed libpg-dev
08:44:59 <cizra2> dafis: I think it worked. Thank you very much.
08:45:13 <dafis> :D
08:47:10 <absence> Cale: it's intentional that i'm pattern matching on only the type i want for now. i'll add checks that return Nothing for wrong types later, when i'm sure i'm on the right track
08:48:15 <absence> Cale: what i want is a general function that can turn a ListTag into e.g. [Double] without having to write one function for each "subtype". is this possible?
08:51:10 <Cale> absence: What type would your general function have?
08:56:33 <absence> Cale: no idea
08:57:12 <absence> is there a tutorial or something on how to use types like these?
08:57:53 <FUZxxl> Is the type system of haskell turing complete?
08:58:19 <dolio> No.
08:59:37 <olsner> not even with ghc extensions?
09:00:01 <FUZxxl> It's because I've read about that. (But I forgot where)
09:00:05 <dolio> With GHC extensions, the type system is Turing complete.
09:00:20 <dolio> But with GHC extensions, it is no longer Haskell's type system.
09:00:23 <FUZxxl> dolio: which extensions? There are so many.
09:00:35 <thoughtpolice> undecidable instances is the big one.
09:00:49 <dolio> Yes, you need undecidable instances and functional dependencies, probably.
09:00:56 <dolio> And multi-parameter type classes.
09:01:10 <dolio> Alternately, you can replace the latter two with type families.
09:16:06 <absence> http://pastebin.com/8q2C9sRf <- is there a better or more concise way to get at the contents of an algebraic data type than this?
09:16:49 <fragamus> i am a newb i have a question: here is my main:
09:16:52 <fragamus> main = do x <- getStdGen; newStdGen; print x
09:17:06 <jmcarthur> :t newStdGen
09:17:07 <hpc> absence: do you need it to have the Tag -> Maybe foo type?
09:17:07 <lambdabot> IO StdGen
09:17:13 <hpc> absence: because you can use records
09:17:23 <fragamus> I want to create an array of x's
09:18:02 <fragamus> main =  putStrLn (show [x | y <- [0..99]])
09:18:12 <absence> hpc: probably not, just thought Nothing would be better than a crash :) how would it look with records?
09:18:26 <fragamus> I want to make an array of random number generators
09:18:33 <mauke> fragamus: why?
09:18:56 <Twey> That's a very strange thing to want
09:19:00 <hpc> absence: data Tag = stuff .. | DoubleField {doubleField :: Double} | FloatField {floatField :: Float} | ...
09:19:31 <hpc> absence: you can add more constructors that have a doubleField too, so long as all doubleFields are the same type
09:19:41 <hpc> absence: which is easier than adding more patterns onto each getter function
09:19:47 <Axman6> fragamus: not an array of random numbers? o.O
09:19:47 <fragamus> because I am making an array of creatures with random behavior and i dont want them to do the same thing
09:20:12 <mauke> fragamus: you know you can split RNGs, right?
09:20:24 <Axman6> you can split StdGens to get two StdGens which are different
09:20:26 <fragamus> yes thats what newStd Gen does
09:21:02 <Axman6> :t splitStdGen
09:21:03 <lambdabot> Not in scope: `splitStdGen'
09:21:09 <Axman6> @hoogle split
09:21:09 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
09:21:09 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
09:21:09 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
09:21:09 <dafis> :t split
09:21:10 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
09:21:35 <dafis> :t replicateM
09:21:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
09:21:52 <dafis> fragamus: replicateM 100 newStdGen
09:22:09 <dafis> gives you a list of StdGens
09:22:25 <fragamus> really?
09:22:35 <dafis> fragamus: try it
09:22:58 <fragamus> ok
09:23:08 <absence> hpc: this looks promising, thanks! is it possible to make doubleField not crash if used on the wrong Tag though?
09:25:02 <hpc> absence: with some `catch`ing perhaps, but it would be ugly
09:25:23 <hpc> i only brought it up because if returning Maybe isn't important, this way is less verbose
09:25:34 <iskren> dafis, It doesn't work with deleting the hi/o files and forcing recomp
09:26:12 <absence> hpc: but if i want Maybe, there's only the verbose way?
09:26:17 <iskren> is this the correct place to ask questions about happy?
09:27:37 <dafis> iskren: so, ghc --make -fforce-recomp Test still says undefined reference?
09:27:52 <hpc> absence: afraid so
09:28:19 <iskren> http://fpaste.org/5PdJ/ yes
09:29:40 <dafis> iskren: there's no --make in that command line, you were using 6.12.3, weren't you?
09:29:56 <rovar> http://hpaste.org/46936/abstract_monads
09:31:16 <rovar> technically,  I think that withMongoDBPool should be in the Network.Abstract.NetworkIO monad because that's where DB.newConnPool is.. but I was under the impression that the whole point of network.abstract.networkio is that it would run inside of MonadContolIO
09:31:29 <rovar> might someone be able to shed some light on this?
09:31:41 <iskren> dafis, yes, 6.12.3. I'm not using make, because I want an executable
09:31:50 <iskren> Tests.hs contains a main
09:32:03 <iskren> if I load it in ghci it works just fine
09:32:22 <dafis> iskren: --make is fine for that, alternatively, you could pass all required packages on the command line
09:33:00 <dafis> iskren: if there's a Main module with a main function, ghc --make produces an executable
09:33:24 <dafis> iskren: if the module in Tests.hs is called Tests, ghc --make -main-is Tests
09:37:20 <fragamus> @type replicateM 100 newStdGen
09:37:21 <lambdabot> IO [StdGen]
09:37:48 <fragamus> creatures = Prelude.map (\g -> (Data.Map.empty, 0.0,g)) generators
09:38:01 <fragamus> no workie ^^^
09:38:53 <fragamus> generators = replicateM 100 newStdGen
09:38:57 <fragamus> creatures = Prelude.map (\g -> (Data.Map.empty, 0.0,g)) generators
09:38:58 <dafis> fragamus: do gens <- replicateM 100 newStdGen; let { creatures = ... ; }; somethingWithCreatures
09:39:09 <fragamus> ty
09:39:51 <boegel> I'm using this to generate a random value of a given type:
09:40:20 <boegel> liftM return $ interpret "show (fst $ random (mkStdGen " ++ show (abs seed) ++ ") :: " ++ t ++ ")" infer
09:40:38 <boegel> this returns something of type (Interpreter (Maybe String))
09:40:45 <boegel> and it works great
09:41:22 <boegel> if the random generation fails, it returns Nothing, otherwise it returns e.g. Just "12345" if t == "Int"
09:41:45 <boegel> now, what if t == "a"... is ther any way to transform this to make it generate a String representation of a value of *any* type?
09:42:01 <iskren> dafis, well I tried with -main-is -- and it now fails with this http://fpaste.org/QTTn/
09:43:00 <boegel> > let t = "Int"; seed = 0 in liftM return $ interpret "show (fst $ random (mkStdGen " ++ show (abs seed) ++ ") :: " ++ t ++ ")" infer
09:43:02 <lambdabot>   Not in scope: `interpret'Not in scope: `infer'
09:43:12 <dafis> iskren: did you remove .o and .hi? otherwise do or use -fforce-recomp
09:43:25 <boegel> > let t = "Int"; seed = 0 in liftM return $ Language.Haskell.Interpreter.interpret "show (fst $ random (mkStdGen " ++ show (abs seed) ++ ") :: " ++ t ++ ")" Language.Haskell.Interpreter.infer
09:43:26 <lambdabot>   Not in scope: `Language.Haskell.Interpreter.interpret'Not in scope: `Langua...
09:43:28 <boegel> meh
09:49:12 <BCoppens> boegel: life sucks, doesn't it? :P
09:49:30 <djahandarie> Gah. It's really annoying when Hackage just stops responding to me.
09:53:26 <Tomsik__> How you break lines in Hamlet?
09:53:38 <Tomsik__> If you do <br> single line
09:53:41 <Tomsik__> it does two line breaks
09:53:47 <Tomsik__> if you don't, it doesn't break them at all
09:56:52 <parcs> Tomsik__: http://paste.pocoo.org/show/393204/
09:57:05 <parcs> that is one way, at least
09:57:20 <dylukes> so, what should I use if I want to do parsing/lexing in Haskell?
09:57:28 <dylukes> I mean, what are the "best" tools at the moment.
09:57:44 <dylukes> For imperative style grammars.
09:57:49 <ion> Parsec is great, but i’ve been meaning to look at Polyparse as well.
09:57:49 <Tomsik__> I'm doing something more like this: http://paste.pocoo.org/show/393205/
09:58:05 <Tomsik__> Should I have a <br> on the next line then?
09:58:12 <iskren> dafis, ok, so If I pass all the hs files to the compiler AND the --make option (because passing .o files and --make doesn't work) it works
09:58:17 <dylukes> ion: It's not super easy to work with LR(k) grammars though… chain still baffles me a bit >_<
09:58:37 <parcs> Tomsik__: yeah
09:58:51 <ion> Parsec implements PEG AFAIU.
09:58:52 <Tomsik__> Okay, thanks, I thought there'd be something like that trailing hash thing
09:59:00 <parcs> there probably is
10:01:25 <dafis> iskren: with --make you shouldn't need to pass any .hs except the one with the main function
10:03:21 <dylukes> It'd be nice if there were some more...
10:03:26 <dylukes> complete parsec examples
10:03:58 <pikhq> dylukes: Define "complete".
10:04:03 <dylukes> Eh, well,
10:04:07 <dylukes> at least covering some more advanced usage.
10:04:14 <dylukes> beyond the basic oneOf/many combinators :P
10:04:22 <dylukes> maybe some examples of how to use the error handling built-in,
10:04:25 <dylukes> or chainl
10:04:42 <pikhq> Sorry, can't help you there.
10:04:52 <pikhq> At least not unless I get around to doing some more work on it.
10:05:24 <dylukes> What've you finished?
10:05:26 <aristid> dylukes: did you try reading that introduction to parsec? the module names are outdated, but everything else still works)
10:05:38 <dylukes> aristid: Which one? Link heh?
10:05:56 <dylukes> I mean, the best I ever really saw was Scheme in 48
10:06:00 <dylukes> but that's not exclusively parsec :P
10:06:09 <dylukes> And does it's own custom error handling
10:06:57 <pikhq> I suppose I *could* pastebin a simple sexp parser, but about the only "complex" thing about it is a nice handful of combinators.
10:07:04 <aristid> dylukes: http://legacy.cs.uu.nl/daan/download/parsec/parsec.pdf
10:07:27 <dylukes> Ok, I think what I'll do
10:07:33 <dylukes> is just try to make a simple "natural" calculator.
10:07:38 <dylukes> And see how that turns out.
10:08:05 <dylukes> 1 + 1 + 1 (E + E + E) won't work LL...
10:08:15 <dylukes> since E -> E + E
10:09:40 <aristid> chainl1 or sepBy1, i guess.
10:16:12 <dylukes> So, the thing is.
10:16:20 <dylukes> Hm.
10:24:03 <dylukes> Can you get the arity of a function?
10:24:29 <aristid> 1
10:24:42 <aristid> it's always 1 :)
10:26:41 <dylukes> aristid: True enough… but...
10:26:43 <dylukes> oh well
10:26:44 <dylukes> anyways
10:26:44 <dylukes> https://gist.github.com/985696
10:26:50 <dylukes> this is what I'll work with.
10:27:05 <dylukes> No exponentiation since that'd get messy with negated exponents...
10:27:13 <dylukes> or division.
10:27:27 <dylukes> Really Sub/Mul can both be expressed in terms of Neg/Add
10:27:30 <dylukes> >_>… anyhow
10:28:24 <jrick> > sqrt(-1) == sqrt(-1)
10:28:25 <lambdabot>   False
10:28:26 <jrick> ?
10:28:32 <dylukes> > sqrt(-1)
10:28:33 <lambdabot>   NaN
10:28:40 <jrick> yeah but still
10:28:41 <dylukes> > NaN
10:28:41 <lambdabot>   Not in scope: data constructor `NaN'
10:28:54 <aristid> jrick: NaN is special.
10:28:57 <mercury^> > read "NaN"
10:28:58 <lambdabot>   *Exception: Prelude.read: no parse
10:28:59 <dylukes> NaN can't be equal to NaN
10:29:04 <dylukes> because its not a number,
10:29:09 <dylukes> so the concept of "equality" doesn't hold.
10:29:13 <dylukes> Alternatively,
10:29:17 <dylukes> it's special, deal with it.
10:29:18 <jrick> then why is still part of Eq?
10:29:33 <dylukes> Is it?
10:29:36 <aristid> jrick: IEEE 754 defines it this way.
10:29:39 <mercury^> Instances of Eq need to satisfy no special properties.
10:29:47 <mercury^> You can define a == b = False
10:30:09 <aristid> jrick: you can think of NaN as an analogue of bottom (undefined)
10:30:14 <mercury^> It can be asymmetric, irreflexive and so on.
10:30:26 <jrick> hm, ok
10:30:42 <absence> are there any rules of thumb for when it's better to use this style "getShortData = fromIntegral <$> D.getWord16be" or this "getShortData = D.getWord16be >>= return . fromIntegral"?
10:30:58 <mercury^> Where with "and so on" I clearly meant "intransitive" :>
10:31:36 <aristid> absence: i like the first better.
10:32:06 <dolio> Intragnisent
10:32:06 <mercury^> It is also more general.
10:33:38 <absence> aristid: what about mixing them, is that good/bad/neither? e.g. getStringData = BC.unpack <$> (getLength >>= D.getLazyByteString . fromIntegral)
10:33:51 <aristid> absence: i'd use =<<, then.
10:33:55 <dafis> absence: or, if you're afraid to confuse your audience with Applicative, fmap or liftM
10:34:03 <aristid> absence: that way, it has one direction of flow.
10:34:28 <absence> aristid: good point
10:34:35 <mercury^> dolio: did you mean "intransigent"?
10:34:43 <dolio> No.
10:34:52 <mercury^> What does "intragnisent" mean?
10:36:21 <dylukes> https://gist.github.com/985704
10:36:29 <dylukes> any ideas how to start it :\
10:36:30 <dolio> It's from Futurama. There's an episode where the mob bots are supporting a strike, and one of them asks what they're going to do if management remains intragnisent.
10:36:31 <dylukes> I'm not sure >_<
10:37:04 <mercury^> dolio: I see.
10:38:26 <luite> does anyone know who runs projects.haskell.org ?
10:40:24 <SoleSoul> Hello. How do I convert a char to a string without keeping the ' ?  using show prodces for example '{' and I need only {. thanks
10:40:46 <mercury^> SoleSoul: return
10:40:48 <Zao> SoleSoul: Make a one-element list.
10:40:57 <Zao> @src String
10:40:57 <lambdabot> type String = [Char]
10:40:59 <luite> (:[])
10:41:09 <mercury^> > return '{'
10:41:09 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Types.Char))
10:41:10 <lambdabot>    arising from a use of...
10:41:15 <mercury^> Bleh.
10:41:20 <mercury^> > return '{' :: String
10:41:21 <lambdabot>   "{"
10:41:39 <Zao> > let x = '{' in ([x], x:[], (:[]) x, return x :: String)
10:41:40 <lambdabot>   ("{","{","{","{")
10:42:22 <Zao> mercury^: return must be one of the least inituitive ways to explain what a String is :D
10:43:17 <SoleSoul> Thanks. I got two solutions, one simple: '{':[] and one interesting. I like the simple but I would love to know what does return do in this case
10:43:36 <dylukes> anyone know how to change the indent level in haskell-mode?
10:43:37 <Zao> @type return
10:43:39 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
10:43:59 <Zao> SoleSoul: return lifts a value into a monadic value.
10:44:08 <Zao> SoleSoul: List is a monad.
10:44:36 <SoleSoul> no one told me list is a monad :
10:44:38 <SoleSoul> :(
10:44:41 <SoleSoul> :)
10:44:52 <SoleSoul> I'll leave that for later then
10:45:03 <SoleSoul> and use '{':[]
10:45:47 <Zao> > do { return 'x' `mappend` return 'y' } :: String
10:45:48 <lambdabot>   "xy"
10:47:43 <aristid> @pl \x -> f x <|> return x
10:47:43 <lambdabot> liftM2 (<|>) f return
10:48:02 <aristid> @pl \x -> option x (f x)
10:48:03 <lambdabot> ap option f
10:50:38 <Phyx-> does Haskell2010 come with a new FFI adendum?
10:51:29 <dylukes> Phyx-: Aren't we at Haskell2011 at this point >_>?
10:51:35 <dylukes> Oh wait no, HP2011
10:54:43 <Cale> Phyx-: It comes with the old one
10:54:52 <Cale> It's almost identical to Haskell 98 anyway
10:56:35 <Phyx-> Cale: mkay, just wondering
10:59:28 <luite> Cale: do you know who runs projects.haskell.org?
10:59:53 <Cale> What is projects.haskell.org?
11:00:01 <luite> haskell community server
11:00:27 <luite> but I'll take that as a no :)
11:00:34 <Cale> Is that the same as code.haskell.org?
11:01:42 <luite> yeah appears to be the same
11:02:25 <Cale> That's run by Galois
11:03:35 <luite> oh it's on a server in germany
11:04:51 <erus`> Imagen if you will: a rock paper scissors program that allows you to swap out the ai function for another one: the ai function has a single parameter (players last hand). Unlike any imperative languages, you would not be able to store the history of the hands or the reason you made your last move. Is a different model needed for haskell? is this a problem?
11:06:42 <Cale> erus`: The AI function could take the other player's last throw and produce a new guess and a new AI function.
11:08:29 <erus`> ah good idea. I'm still not thinking-with-higher-order-functions™
11:09:17 <erus`> its like thinking with portals but not as nerdy
11:09:20 <Cale> Another, more mundane option is just to take the last throw, and a current state, and produce a throw and a new state.
11:09:35 <byorgey> haha, I would have said it's more nerdy =)
11:09:49 * hackagebot hakyll 3.1.2.4 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-3.1.2.4 (JasperVanDerJeugt)
11:10:00 <boegel> BCoppens: you mean, life in a statically typed language sucks?
11:10:06 <boegel> BCoppens: dude, have you even tried Python?
11:10:28 <erus`> i wish haskell had operator overloading
11:10:34 <erus`> i would die happy
11:10:37 <Cale> It does.
11:10:38 <ziman> doesn't it?
11:11:22 <Phyx-> classes
11:11:43 <erus`> whats the class for + ?
11:11:47 <Cale> Only, it's a bit of an insult to call it overloading, since it's so much better.
11:11:48 <Cale> Num
11:11:54 <byorgey> @type (+)
11:11:55 <lambdabot> forall a. (Num a) => a -> a -> a
11:11:58 <erus`> but a vector3d isnt a num?
11:12:06 <byorgey> it can be if you make it one.
11:12:22 <erus`> what about a matrix?
11:12:26 <byorgey> instance Num Vector3D where ...
11:12:29 <byorgey> why not?
11:12:36 <erus`> num is a scalar
11:12:41 <erus`> vector3d is a vector
11:12:43 <Cale> sure, you can make those Num instances, though matrix multiplication is inappropriate for (*)
11:12:56 <Cale> (as is scalar multiplication)
11:13:10 <erus`> why cale?
11:13:32 <erus`> because of a * b != b * a ?
11:14:13 <Cale> Ordinary multiplication takes two elements of the same type and produces an element of that same type. Scalar multiplication takes a scalar and a vector.
11:15:04 <Cale> Matrix multiplication would be okay if restricted to square matrices of a fixed size.
11:15:10 <Cale> (those form a ring)
11:15:37 <byorgey> or if you don't track matrix size in your types and are OK with (*) throwing an exception if given incompatible matrix sizes.
11:15:41 <byorgey> but that is not the Haskell Way.
11:15:41 <Cale> yeah
11:16:31 <Cale> erus`: anyway, any string of symbol characters can be defined as an infix operator
11:16:38 <Cale> so it's not like there's a shortage :)
11:16:54 <scree> meh, I tried type-safe matrices once.  I do not think they're worth the effort in the current type system
11:17:00 <Cale> It's common to use *^ or *. for scalar multiplication
11:17:39 <Cale> and ^*^ or .*. for matrix multiplication
11:17:49 * hackagebot hakyll 3.1.2.5 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-3.1.2.5 (JasperVanDerJeugt)
11:18:00 <erus`> im working with fixed 3*3s
11:18:28 <Cale> In that case, you could define an instance of Num for them and define multiplication on them to do matrix multiplication.
11:18:48 <Cale> fromInteger should produce a multiple of the identity matrix
11:19:37 <Cale> I guess theoretically you could worry that abs and signum don't make much sense, but most people overlook that.
11:19:43 <erus`> i dont need to multiply a matrix by a scalar yet. but vector * matrix i do
11:19:53 <erus`> will that have to be another symbol?
11:19:54 <Cale> Yeah, give those different names.
11:20:09 <erus`> damn
11:20:20 <Cale> Because they have incompatible types
11:20:29 <erus`> function overloading
11:20:35 <erus`> thats what i need :)
11:20:56 <Cale> Theoretically, our Num class could be general enough to allow the result type to be a function of the input types, and all three could be different
11:21:09 <Cale> But that would be annoying
11:21:36 <Cale> Because it would often result in ambiguous types and would force you to put in more type signatures than you'd normally want to.
11:22:06 <erus`> ok im gonna port my code if i can get glfw working on windows
11:22:11 <erus`> see how many LOC i save
11:22:25 <Cale> class GenMultiply a b where
11:22:32 <Cale>   type MulResult a b
11:22:46 <Cale>   (.*.) :: a -> b -> MulResult a b
11:22:58 <Cale> instance GenMultiply Matrix3 Vector3
11:23:10 <Cale>   type MulResult Matrix3 Vector3 = Vector3
11:23:24 <Cale>   m .*. v = ...
11:23:44 <Cale> ^^ you could do something like that with various instances
11:29:42 <erus`> ah
11:30:01 <erus`> where does cabal install glfw? some functions dont seem to exist
11:33:10 <erus`> never mind :)
11:33:23 <erus`> they should really put glfw in the prelude rather than glut
11:33:38 <erus`> callbacks are such a bad idea
11:34:01 <Cale> Really neither is in the Prelude.
11:34:33 <erus`> glut comes with haskell for windows
11:35:05 <sinelaw> hello
11:36:00 <xplat> Prelude is just the stuff you can get without an explicit import, like length or (.)
11:37:37 <erus`> errr standard library i mean
11:38:09 <dafis> Platform
11:38:25 <erus`> yeah that one. got there in the end.
11:38:39 <erus`> But seriously, who do i suggest they change it to?
11:41:41 <erus`> wow 7 meg executable for glfw helloworld :O
11:42:11 <dafis> erus`: have you enabled object-splitting?
11:43:11 <parcs> spli-objs at least triples compile time
11:43:32 <dafis> sure?
11:43:34 <erus`> dafis: whats the flag?
11:43:44 <parcs> i would build libraries with -shared and then link with -dynamc
11:43:44 <erus`> compiled in like a second anyway
11:43:57 <parcs> i mean compiling libraries with split-objs
11:44:08 <dafis> erus`: you need to do it when you install the libraries, split-objs: True in the cabal config
11:44:50 <erus`> meh, i'll worry about that later
11:45:04 <parcs> erus`: with dynamic linking my opengl hello world is 16k :D
11:45:37 <erus`> the glfw.dl is only 48k :S
11:45:58 <erus`> haskell, you so crazy
11:46:13 <erus`> @ty get
11:46:14 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
11:46:52 * hackagebot stream-fusion 0.1.2.3 - Faster Haskell lists using stream fusion  http://hackage.haskell.org/package/stream-fusion-0.1.2.3 (DonaldStewart)
11:53:20 <Twey> My new pet Haskell hate is mixing libraries that use Data.Text and Data.Text.Lazy
11:54:20 <ClaudiusMaximus> @hoogle runSTUArray
11:54:21 <lambdabot> Data.Array.ST runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
11:57:48 <derwolf> join #tag
11:57:50 <ClaudiusMaximus> (i thought i'd ask a related question, but while phrasing it i realized in my case i could have a 3D array instead of arrays of tuples or tuples of arrays)
12:17:23 <erus`> should i use type or data for a vector3d struct?
12:20:05 <dylukes> Ok, silly question.
12:20:12 <dylukes> Say I'm using parsec and TokenParser
12:20:22 <dylukes> and I want to have a parser for natural numbers.
12:20:24 <dylukes> simplest would be
12:20:32 <dylukes> natural = PT.natural lexer
12:20:39 <dylukes> (where lexer is the token parser from the langdef)
12:20:48 <dylukes> but then natural is of the Parsec String u Integer
12:20:52 <dylukes> I want it to be of type
12:20:56 <dylukes> Parsec String u (Expr Integer)
12:21:25 <dylukes> I'm thinking lambda + pattern matching :\?
12:21:50 <dylukes> (\(Parsec s u a) -> (Parsec s u (Expr a))
12:22:00 <siracusa> Expr <$> PT.natural lexer
12:22:22 <dylukes> why would that work ?
12:22:29 <dylukes> I'm not sure I see given the types...
12:22:33 <dylukes> :t <$>
12:22:33 <lambdabot> parse error on input `<$>'
12:22:35 <dylukes> :t (<$>)
12:22:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:22:42 <djahandarie> It's just fmap.
12:22:42 <dylukes> yeah… not seeing it.
12:22:45 <dylukes> No I know
12:22:51 <dylukes> I'm just not seeing how it'd do that.
12:23:00 <ClaudiusMaximus> can instance implementations have dependency loops?
12:23:35 <djahandarie> dylukes, what you're trying to do is exactly the Functor instance for Parsec, isn't it?
12:23:47 <dylukes> Oh, is it?
12:23:52 <dylukes> That'd make sense then I guess.
12:24:08 <djahandarie> I think it is, haven't used Parsec for awhile.
12:24:25 <dylukes> Ah okay, so ParsecT's functor instance just maps over the result type.
12:24:27 <dylukes> that'd make sense.
12:24:53 <dylukes> ._.
12:25:05 <dylukes> looks a bit more complex than that… but the type suggests thats what it does.
12:25:10 <dylukes> http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/src/Text-Parsec-Prim.html#runParsecT
12:25:12 <dylukes> take a look :\
12:25:14 <siracusa> <$> and fmap will give the same result, but <$> looks nicer IMO
12:25:29 <dylukes> siracusa: Plus its more consistent with the applicative style of parsec...
12:25:38 <siracusa> yes
12:26:01 <dylukes> parsecMap is a bit confusing :\
12:26:08 <dylukes> I mean, the type signature makes sense, but
12:26:14 <dylukes> I'd love to understand the implementation
12:26:39 <siracusa> erus`: data
12:27:13 <ClaudiusMaximus> would something like class Num a => ShowHelper a where ...  with the existing class Show a ... => Num a  make the ShowHelper class useless for doing something like instance ShowHelper a => Show a where ... ?
12:27:30 <erus`> @ty Float
12:27:31 <lambdabot> Not in scope: data constructor `Float'
12:28:17 <siracusa> Float already is a type
12:28:20 <ClaudiusMaximus> i guess i'll try it and see what explodes
12:32:24 <siracusa> Indeed, you need Show to get Num. Why is that?
12:33:45 <dylukes> siracusa: alright, say
12:33:50 <dylukes> I have a Parser s u a,
12:33:57 <dylukes> and I want to do a case of over the result
12:34:16 <dylukes> (in this case, operator returns an operator string, and I want to convert that to an Expr constructor)
12:34:55 <erus`> how do i split code into different files?
12:35:08 <erus`> import x? where x is Type?
12:35:40 <siracusa> dylukes: You can use (\e -> case e of { A -> Expr A; ... }) <$> parser then (if that was the question)
12:35:42 <erus`> or is there a packag keyword or something
12:35:48 <ziman> you split it in modules (that export things)
12:36:01 <dylukes> siracusa: er.. no
12:36:07 <siracusa> erus`: x is a module name
12:36:15 <dylukes> operator will return the string representation of an operator
12:36:19 <dylukes> so "+" or "-", etc
12:36:34 <dylukes> I want to switch over those and convert them to data constructors
12:36:37 <ziman> @google haskell modules
12:36:38 <lambdabot> http://www.haskell.org/tutorial/modules.html
12:36:39 <lambdabot> Title: A Gentle Introduction to Haskell: Modules
12:36:42 <ziman> looks readable.
12:36:50 <dylukes> so I have Parsec String u String
12:36:51 <dylukes> I want
12:36:58 <parcs> irc is the best search engine
12:37:05 <siracusa> > case "+" of { "+" -> "plus"; "-" -> "minus" }
12:37:05 <lambdabot>   "plus"
12:37:07 <dylukes> Parsec String u (Expr Integer -> Expr Integer -> Expr Integer)
12:37:32 <dylukes> I suppose I could just fmap here again :\
12:38:22 <siracusa> dylukes: Yes, just fmap/<?> the case functions over the parser
12:38:32 <dylukes> <?>?
12:38:34 <siracusa> *function
12:38:43 <siracusa> Erm <$>
12:38:57 <dylukes> yeah, my bad
12:39:05 <dylukes> I need to remember what fmap is ^_^
12:39:11 <dylukes> I mean, now I do.
12:39:24 <dylukes> but it's suppose to be for mapping between categories, which is what I'm doing here heh
12:39:59 <erus`> oh god this is confusing
12:40:32 <siracusa> dylukes: You can also write it in do notation: do { e <- parser; case e of { "+" -> return Plus; ... } }
12:40:39 <dylukes> mm yeah
12:40:46 <dylukes> Ugh, well this is a snafu.
12:40:54 <osfameron> presumably there's an "on error resume next" monad in Haskell too? http://www.guardian.co.uk/info/developer-blog/2010/dec/10/vb3-redux
12:40:55 <dylukes> I have Add/Sub/Mul, which are all binary operators
12:41:03 <dylukes> GADT type Expr Integer -> Expr Integer -> Expr Integer
12:41:05 <dylukes> but I also have Neg
12:41:10 <dylukes> which is unary D:
12:43:43 <dylukes> https://gist.github.com/985814
12:43:53 <dylukes> the problem is operator :\
12:44:05 <dylukes> since, Neg doesn't match.
12:44:30 <dylukes> I'm not sure how to resolve that nicely :\
12:44:58 <dylukes> maybe I should just split into two separate unaryOperator and binaryOperator parsers?...
12:45:11 <erus`> ziman: how do i export a constructor?
12:45:39 <parcs> Bool(True)
12:45:55 <ziman> erus`, writing module MyModule ( MyType(Constr1, Constr2), myFun )
12:46:20 <erus`> ziman: thanks
12:46:26 <ziman> (or you can use MyType(..) to export all constructors)
12:46:43 <erus`> I think they deliberately make this hard to watch people squirm
12:47:01 <ziman> this looks good, too: http://en.wikibooks.org/wiki/Haskell/Modules
12:47:07 <erus`> ziman: can multiple files be the same module?
12:47:21 <erus`> or like parent::module
12:48:27 <siracusa> dylukes: What do you need operator for?
12:48:28 <ziman> erus`, AFAIK they cannot; the module must have the same name as the file has (modulo the .hs extension).
12:48:35 <dylukes> one moment siracusa
12:48:58 <dylukes> okay
12:49:08 <scree> erus`: you can do heirarchical modules, Data.List.Foo.Bar, which mirror the directory structure, but it's one module per file (AFAIK)
12:49:19 <dylukes> so siracusa, operator should parse an operator and return the proper data constructor
12:49:24 <parcs> erus`: they make this hard to avoid ambiguity
12:49:32 <erus`> scree: that should work :)
12:49:35 <dylukes> the type as it is, is Parsec String u (Expr Int -> Expr Int -> Expr Int)
12:49:48 <dylukes> so it only parses binary operators
12:49:49 <scree> erus`: People often have a directory Foo/ and a top-level Foo.hs which just imports and reimports all the modules Foo.Blah
12:49:56 <dylukes> I also want to have it work for unary operators as well.
12:50:06 <dylukes> I guess I could use Either, but that seems a bit… eh
12:50:06 <scree> erus`: s/reimports/reexports
12:50:13 <erus`> ah that makes sense
12:50:43 <dylukes> I guess it would make more sense to have separate parsers entirely,
12:56:28 <rostayob> what library should I use for a little visualization program? it's similar to a classical game of life
12:56:35 <rostayob> so moving cells (:
12:57:07 <rostayob> I've used SDL in the past with C, are the bindings good? is there something more specific?
13:03:37 <erus`> whats the Num divide operator?
13:03:51 <erus`> `/' is not a (visible) method of class `Num'
13:03:58 <parcs> @src Num
13:03:59 <lambdabot> class  (Eq a, Show a) => Num a  where
13:03:59 <lambdabot>     (+), (-), (*)           :: a -> a -> a
13:03:59 <lambdabot>     negate, abs, signum     :: a -> a
13:03:59 <lambdabot>     fromInteger             :: Integer -> a
13:04:19 <luite> :t (/)
13:04:19 <lambdabot> forall a. (Fractional a) => a -> a -> a
13:04:20 <Lemmih> :t (/)
13:04:20 <lambdabot> forall a. (Fractional a) => a -> a -> a
13:04:22 <ziman> Num does not have division, Fractional has.
13:04:24 <luite> :t div
13:04:25 <lambdabot> forall a. (Integral a) => a -> a -> a
13:04:41 <luite> erus`: these are the two, but both belong to different classes
13:04:43 <ziman> s/has/does/
13:05:15 <erus`> :|
13:06:47 <erus`> can i just throw an exception for abs and signum etc to supress the warnings?
13:08:06 <parcs> of course you can
13:11:50 <throoze> hi!
13:11:56 <throoze> could someone help me??
13:12:03 <throoze> please?
13:12:14 <parcs> no
13:12:28 <throoze> ah
13:12:42 <throoze> please, im just starting to use haskell...
13:12:48 <parcs> okay okay fibe
13:12:51 <parcs> fine*
13:12:55 <parcs> what's the problem
13:13:10 <throoze> i have an asignment at college
13:13:39 <throoze> i need to implement in lexicograph analizer for a language they invented
13:13:50 <throoze> im using alex
13:14:06 <tomh> if you derive Ord, is it lexicographically?
13:14:26 <tomh> like A Int Int Int is sorted on the first int first?
13:15:20 <throoze> when im defining my tokens, i dont know what to do with the token corresponding to numbers, given that the language accept numbers like '.4' or '8.'
13:15:54 <throoze> so, i have two problems... read doesnt seems to like reading these things
13:16:30 <throoze> and i dont know what type should i asign to the constructor of TkNum
13:16:43 <throoze> if its Int or Float or what?
13:17:04 <throoze> hello???
13:17:12 <throoze> are you there?
13:17:28 <siracusa> Does this language distinguish integer and floating point numbers?
13:17:45 <throoze> no. it just has numbers
13:17:57 <throoze> and they can be written in those formats
13:17:59 <siracusa> Then probably Float or Double
13:18:23 <luite> erus`: these are the two, but both belong to different classes
13:18:25 <siracusa> and you have to write your own parsing function if read won't accepts it.
13:18:26 <luite> oops
13:19:07 <scree> tomh: yes
13:19:14 <tomh> ok cool
13:19:56 <scree> tomh: and A _ < B _ if data Foo = A ... | B ...
13:20:11 <tomh> ok
13:20:12 <throoze> so, does my parser fuunction have to turn any number read into a Float or a Double??? isnt any type that can be a Int or float or All those at the same time?
13:21:37 <siracusa> throoze: yes and no
13:21:50 <ziman> how about just prepending a zero to the number to be read?
13:23:34 <scree> throoze: you should parse to whatever your internal representation is.  if your internal representation has ints and floats as separate things, your parser should decide which one it is.  if it just treats everything as floats, you should parse them as floats
13:24:27 <throoze> the thing is they are not trated like any of standar types.... the type is 'num'
13:24:58 <throoze> and you can write the number in the format you prefer
13:25:04 <siracusa> But you need a Haskell data type to represent then "num" type
13:25:08 <throoze> buet the type is still num
13:25:25 <throoze> exactly, so you suggest it is Float?
13:25:29 <scree> throoze: what do the semantics of this language demand a "num" do?
13:26:10 <throoze> it can be operated with other nums and it can constrict vectors and matrixes
13:26:10 <scree> throoze: if it's acceptable for your language to output "1.00" when "1" would also be appropriate, Float is your best bet
13:26:44 <luite> or Rational, then you can represent everything you can read exactly
13:26:58 <luite> and you can always decide to convert to floating point later
13:28:22 <throoze> in this stage of my project, semantics is not important... i just have to recognize the tokens. In order to do so, i need to create the data type Token, wich has a constructor for every kind of token i can parse
13:28:57 <throoze> for the toke that represents the type num, my first approach was:
13:29:05 <throoze> Token =
13:29:10 <throoze> .....|
13:29:36 <throoze> TkNum (Int,Int) Num
13:30:02 <throoze> but ghc complains because Num is not a type, but a classtype
13:30:31 <throoze> so, thats wher i should use Float o Rational???
13:30:39 <throoze> where*
13:30:43 <siracusa> Rational is probably the best solution
13:31:34 <throoze> ok ill give it a try!!! thanks to everybody!!! =)
13:33:10 <throoze> im trying: read "4" :: Rational
13:33:29 <throoze> and i got: ***Exception: Prelude.read: no parse
13:33:34 <Twey> > read "4 % 1" :: Rational
13:33:35 <lambdabot>   4 % 1
13:33:36 <dylukes> > read "4/1" :: Rational
13:33:37 <lambdabot>   *Exception: Prelude.read: no parse
13:33:40 <dylukes> :\
13:33:53 <dylukes> > read "4.0" :: Real
13:33:53 <Twey> The syntax is "<numerator> % <denominator>"
13:33:54 <lambdabot>   Class `GHC.Real.Real' used as a type
13:34:03 <dylukes> Twey: huh.
13:34:22 <siracusa> > toRational $ (read "4.0" :: Float)
13:34:22 <lambdabot>   4 % 1
13:34:35 <Twey> > toRational $ read "4"
13:34:36 <lambdabot>   4 % 1
13:34:50 <dylukes> gaaah
13:34:57 <siracusa> > toRational $ read "4.5"
13:34:58 <lambdabot>   *Exception: Prelude.read: no parse
13:34:59 <dylukes> stupid operator arity >_<
13:35:40 <dylukes> https://gist.github.com/985873
13:35:58 <dylukes> So, the problem is, PT.operator will just consume input for *all* operators.
13:36:11 <k0ral> still no answer from ross for a hackage account :(
13:37:16 <dylukes> anyone have an idea how to fix this?
13:39:08 <siracusa> dylukes: You need `try' which allows backtracking for already read parts of the input
13:39:34 <dylukes> Yeah… I wish there was a nicer alternative here though.
13:39:48 <dylukes> imperatively I'd branch depending on whether the token is unary or binary
13:39:54 <dylukes> but here I can't, since they have unique types.
13:40:07 <Twey> You can always factor a ‘try’ parser into one that doesn't use ‘try’… I think
13:40:11 <dylukes> Alternatively, I could make a simple data OpToken = AddTok | MulTok etc...
13:40:15 <Twey> It may not be as pretty, though
13:40:20 <dylukes> But, I'd like to have the parser actually generate the AST directly
13:40:32 <dylukes> Twey: take a look at my code and see what you think?
13:40:45 <dylukes> The problem, really, is that PT.operator sees ~ and +-* identically...
13:40:56 <dylukes> I could use Either :\
13:42:46 <dylukes> like this...
13:42:46 <dylukes> https://gist.github.com/985885
13:43:05 <siracusa> dylukes: You shouldn't return the constructors without arguments applied to them
13:43:21 <dylukes> Well, the idea was to then have in my expr parser something like
13:43:30 <dylukes> (pseudo)
13:43:31 <dylukes> a <- expr
13:43:35 <dylukes> b <- op
13:43:37 <dylukes> c <- expr
13:43:42 <dylukes> return b a c
13:43:57 <siracusa> which only works for binary operators
13:44:06 <dylukes> hm
13:44:13 <dylukes> So, how would you structure it better :\?
13:44:41 <dylukes> How would you do something like "3 + 2" then
13:44:58 <dylukes> into (Add (Nat 3) (Nat 3)
13:45:00 <dylukes> )
13:45:15 <siracusa> The basic idea is okay, you'd just have to add an alternative for unary operators
13:45:20 <dylukes> Preferably without resorting to lookahead.
13:47:54 <ddarius> Twey: It would be simply converting the grammar to LL(1).
13:49:00 <djahandarie> k0ral, he's usually really fast. He's probably just busy with something.
13:55:57 <throoze> bye!
14:00:51 <rovar> can someone help me with some overlapping monad instances?
14:00:53 <rovar> http://hpaste.org/46936/abstract_monads
14:01:50 <rovar> one API requires that it run in MonadControlIO  but its defined to run in Network.Abstract.NetworkIO
14:02:02 <rovar> both classes seem to share common instances..
14:02:17 <rovar> but i'm not sure if that even matters..
14:02:29 <rovar> also LANGUAGE OverlappingInstances doesn't alleviate the problem in this case.
14:07:29 <rovar> ah..it looks like overlapping instances wouldn't help anyways.. since its used at definition time
14:09:39 <twomashi> Hi all
14:09:45 <Saizan> yeah, i wonder how the NetworkIO IO one could match here
14:10:01 <Saizan> rovar: what's the type of DB.newConnPool ?
14:10:16 <twomashi> I have this type, and I want to run a command in it with system: type UDPHandler = SockAddr -> String -> IO ()
14:10:23 <rovar> Saizan, it's a Network.Abstract.NetworkIO
14:10:26 <rovar> specifically...
14:10:34 <rovar> let me find it
14:11:03 <rovar> newConnPool :: NetworkIO m => Int -> t -> m (ConnPool t)
14:11:41 <rovar> if I make withMongoDBPool into a NetworkIO, then that module builds, but I am simply pushing the problem out to the next module
14:13:40 <Saizan> well, why should MonadControlIO m imply NetworkIO m?
14:14:08 <rovar> I am guessing that NetworkIO should (or at least could?) imply MonadControlIO
14:14:46 <rovar> I could alter the MongoDB api to make NetworkIO an instance of MonadControlIO (they are both already instances of MonadIO iirc)
14:15:10 <Saizan> it doesn't work like that
14:15:43 <Saizan> you can make a type an instance of a typeclass, not another typeclass
14:15:58 <Saizan> you could make them superclasses but they look fairly unrelated
14:16:38 <rovar> I thought the whole point of MonadControlIO was that it be generic enough to run any io oriented monad
14:16:42 <Saizan> i mean, it might make sense to make MonadControlIO a superclass of NetworkIO maybe, but that wouldn't help with you
14:17:35 <rovar> i run into this problem any time I try to combine two or more sufficiently complex APIs
14:17:38 <Saizan> that might be, but newConnBool requires more out of the monad, it requires to support whatever NetworkIO m requires
14:17:59 <rovar> true
14:18:12 <Saizan> so your withMongoDB should have (NetworkIO m) => .. if it wants to be polymorphic
14:18:42 <Saizan> if you need them you can have both constraints: (MonadControlIO m, NetworkIO m) => ..
14:19:39 <Saizan> these constraints typically should propagate until you use these functions in a context where 'm' gets specific enough that they can be discharged
14:20:00 <rovar> gotcha
14:24:00 <rovar> Saizan:  I think that fixed it. Thanks.
14:27:15 <rovar> arg
14:27:33 <rovar> my son hit the switch on one of my two surge protectors
14:27:50 <rovar> had he hit the other one, things would have gotten serious
14:28:31 <k0ral> djahandarie: fine
14:28:32 <dylukes> Goddamit.
14:28:40 <dylukes> I instanced Show to print out my AST.
14:28:44 <k0ral> I'll wait some days
14:28:44 <dylukes> Then I noticed,
14:28:47 <dylukes> my output was legal lisp.
14:28:48 <dylukes> >_>
14:29:24 <Twey> dylukes: Haha
14:29:49 <dolio> Is it legal Haskell, though? That's the important part.
14:30:09 <dylukes> dolio: nope
14:30:10 <iago> hi, I am using HughesPJ pretty-printing combinators to produce relatively big output and I am experiencing a very high memory consumption, I guess that the use of the combinators is introducing some strictness that forces to build the whole document before print anything... is there any way to fix this ?
14:30:18 <dolio> For shame.
14:31:15 <dylukes> you can see why
14:31:16 <dylukes> https://gist.github.com/985927
14:31:16 <dylukes> haha
14:32:05 <dolio> Well, that's just not a legal Show instance. :)
14:33:02 <dylukes> how is it not?
14:33:06 <dylukes> I works.
14:33:11 <dylukes> It works*
14:33:52 <dolio> show is supposed to produce output that you could paste into a Haskell source file and get back the original value.
14:34:04 <dolio> Although not even all the standard library stuff accomplishes that.
14:34:09 <ezyang> #haskell poll: what's your favorite abbreviation of 'fromIntegral'? I personally use 'fi'
14:34:20 <dylukes> dolio: never knew that :|
14:34:54 <dylukes> ezyang: I use fI (capital I)
14:35:25 <djahandarie> I don't abbreviate it
14:36:19 <ezyang> djahandarie: But then code can look really messy!
14:38:59 <erus`> @ty fromIntegral
14:38:59 <lambdabot> forall a b. (Integral a, Num b) => a -> b
14:39:31 <erus`> @hoogle Num -> Integral
14:39:31 <lambdabot> Warning: Unknown type Num
14:39:31 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
14:39:31 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
14:45:45 <dylukes> okay
14:45:47 <dylukes> here we are
14:45:52 <Zao> Lies.
14:47:08 <dylukes> No I mean...
14:47:14 <dylukes> https://gist.github.com/985940
14:47:22 <dylukes> so, here the issue arises
14:47:27 <dylukes> that if you try to parse "3+2"
14:47:32 <dylukes> it will fall into infinite recursion.
14:47:40 <dylukes> What is the preferred way to fix this.
14:49:31 <Botje> I avoided it by letting parsec do all the nasty operator parsing for me
14:49:39 <bos> dylukes: you've written a classic parsing bug.
14:49:45 <dylukes> bos: I'm aware of this.
14:49:50 <dylukes> I just never actually got around to solving it :D
14:50:03 <dylukes> I'd like to do so without using lookAhead
14:50:04 <dylukes> >_>
14:51:00 <Botje> the traditional response is to left-factor your parser
14:51:08 <dylukes> hm?
14:51:10 <dylukes> chainl would work, except it does 2+
14:51:13 <dylukes> I only want 2 values D:
14:51:24 <bos> dylukes: your grammar is left-recursive. such grammars will always infinite-loop with a parsec-like parser.
14:51:37 <dylukes> bos: So what's the solution/
14:51:43 <bos> dylukes: read up on left recursion and left factoring.
14:51:46 <Zao> Unleftify it :D
14:51:52 <Zao> (not a real term)
14:52:00 <dylukes> Could you, as an example,
14:52:03 <dylukes> tell me how I'd do it for this case?
14:52:15 <bos> too busy, sorry.
14:53:05 <Botje> dylukes: instead of binaryOperator parsing an expr, make it parse a term first
14:53:37 <Botje> and then you check if there's a + or - after the term. if so, parse them, if not, return the number you just parsed
14:54:22 <Botje> a term is then a factor followed by * and another factor, or just a factor
14:54:31 <dylukes> Botje: define term?...
14:54:38 <Botje> and a factor is either a natural number or an expr in parens
14:54:43 <dafis> dylukes: term = natural <|> parens, I'd think
14:55:04 <dylukes> But what *is* a term.
14:55:07 <Botje> by structuring your parser this way you also encode operator precedence
14:55:09 <dylukes> as opposed to an expression
14:55:16 <dafis> ah, missed the definition of term :(
14:55:29 <Botje> expr: term + term | term - term | term
14:55:40 <Botje> term: factor * factor | factor / factor | factor
14:55:49 <Botje> factor: number | parens expr
14:56:04 <dafis> factor: natural | ( expr )
14:56:16 <dylukes> why ( expr )?
14:56:19 <dylukes> and not expr?
14:56:32 <dafis> dylukes: it has to be an atom
14:56:41 <dylukes> the only atoms I have here,
14:56:43 <dylukes> are numbers.
14:56:49 <dafis> to stop left-recursion
14:57:05 <dylukes> this means I have to remove binaryOperation though
14:57:15 <dylukes> and make individual per-operator parsers :|
14:57:19 <Botje> yes. or at least thoroughly rewrite it.
14:57:26 <Botje> that's why I used parsec's nice operation parser generator
14:57:33 <dylukes> Where's that? :D
14:58:15 <dylukes> Text.Parsec.Expr you mean?
14:58:34 <Botje> yes
14:58:50 <Botje> because it's such a recurring pattern and such a pain to write out by hand :)
14:59:29 <Botje> although you should do it once just to see /why/ it's such a pain
14:59:46 <dylukes> heh
14:59:58 <dylukes> so then, how are Statement, Expression, Term, Factor usually "defined"
15:00:07 <dylukes> Is it really just a stratification of "Expression"?
15:00:12 <dylukes> To remove recurrence?
15:00:26 <Botje> and to encode operator precedence, yes
15:00:27 <dylukes> (same as Set, Set1, Set2… for sets?)
15:00:30 <Botje> like i showed above
15:00:39 <dylukes> mm...
15:00:47 <dylukes> I'll try with the Expr stuff.
15:00:51 <dylukes> The built in I mean
15:01:28 <dylukes> http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/Text-Parsec-Expr.html
15:01:34 <dylukes> what the hell is <?> doing here ._.
15:01:46 <dylukes> oh, I guess the wording just throws it off.
15:02:13 <Botje> <?> is just a human readable name for your parser
15:02:45 <dylukes> So I'll try something similar, but that uses constructors instead of actual math...
15:03:02 <ddarius> Botje: It's not all that bad to write out expression parsers by hand, it's just a easily systematizable and common thing to do.
15:03:12 * hackagebot resource-pool 0.1.1.0 - A high-performance striped resource pooling implementation  http://hackage.haskell.org/package/resource-pool-0.1.1.0 (BryanOSullivan)
15:03:29 <fizruk> hi all
15:03:49 <fizruk> how can I tell cabal to install certain version of package?
15:03:51 <dylukes> time to rewrite!
15:06:28 <parcs> fizruk: cabal install network-2.1.4
15:07:25 <fizruk> parcs: thanks!
15:07:42 <mreh> what function am I supposed to use to sample a reactive behaviour?
15:09:07 <mreh> 'at' one would presume
15:10:35 <rovar> how do I go about making calls to items which specify rigid type variables?
15:11:20 <shachaf> rovar: By providing more context to #haskell.
15:11:37 <rovar> shachaf: good point
15:11:53 <rovar> https://github.com/TonyGen/mongoDB-haskell/blob/master/Database/MongoDB/Connection.hs line 169
15:12:06 <rovar> and
15:12:20 <tomh> :t swap
15:12:21 <lambdabot> Not in scope: `swap'
15:12:28 <tomh> where did swap go?
15:12:31 <fizruk> does cabal have an uninstall option?
15:12:41 <rovar> shachaf: http://hpaste.org/46940/and_this
15:12:43 <shachaf> tomh: It was never there.
15:12:47 <tomh> mm
15:12:51 <shachaf> (Was it?)
15:12:52 <tomh> on hoogle it is -.-
15:13:11 <tomh> in Data.Tuple
15:13:16 <rovar> so MongoDBReader t m a.   t can be of type DB.Service, although its not specified.
15:14:39 <rovar> when I try to pass in a DB.Host to a param specified by t,  it complains vociferously
15:14:49 <fizruk> ghc-pkg unregister. sorry for noise
15:18:53 <mreh> yikes
15:22:26 <sina> guys, any idea why someone might get [( Program error: pattern match failure: matchAbstractE_v1926 ('(',('\\',((FuncE . uncurry (:) ('d',[]),(' ',("->",(' ',(ApplyE [(FuncE . uncurry (:) ('a',[])] ++ map matchApplyE_v1920 [],')')))))))
15:22:47 <sina> patter match failure in general
15:26:39 <scree> sina: pattern match failure occurs when you have non-exhaustive patterns, e.g. (\(x:xs) -> x) []
15:26:49 <scree> > (\(x:xs) -> x) []
15:26:50 <lambdabot>   *Exception: <interactive>:3:1-12: Non-exhaustive patterns in lambda
15:27:30 <tg_> can someone tell me what i'm doing wrong w.r.t imports
15:27:35 <tg_> the link is directly copy/paste from LYAH:
15:27:36 <tg_> http://hpaste.org/46941/writer
15:28:20 <parcs> tg_: what is the error you're getting
15:28:34 <tg_> not in scope: data constrcut 'Writer'
15:28:35 <tg_> several times
15:28:54 <tg_> if I delete the instance decleration, just once
15:29:02 <tg_> i am sure i am missing something basic here
15:29:27 <parcs> it's because the latest mtl doesn't export the Writer constructor
15:30:01 <parcs> instead of pattern matching against Writer, use the runWriter function to extract its contents
15:30:08 <parcs> @type runWriter
15:30:09 <lambdabot> forall w a. Writer w a -> (a, w)
15:30:17 <parcs> @src Writer
15:30:18 <lambdabot> Source not found. My pet ferret can type better than you!
15:30:19 <aristid> parcs: there is no Writer constructor anymore
15:30:31 <parcs> ...oh
15:30:49 <parcs> oh yeah, i think it's a type synonym now
15:30:58 <sina> scree I don't fully understand you
15:31:02 <aristid> Writer is now just a type synonym to WriterT with Identity, yes
15:31:09 <sina> but I had a [_] which I changed to _ and apparently that fixed it
15:31:40 <parcs> tg_: you may use the PackageImports extension to specify an older version of mtl (1.x) to use
15:32:17 <parcs> or maybe even the -package flag
15:32:26 <parcs> possibilities, possibilities…
15:33:22 <tg_> can someone annotate the paste so it compiles with WriterT
15:33:25 <tg_> so I can see how it's done
15:33:31 <parcs> okay
15:36:04 <parcs> http://hpaste.org/paste/46941/writer_annotation#p46942
15:36:07 <dylukes> What's the Applicative equivalent of >>?
15:36:09 <dylukes> :t >>
15:36:09 <lambdabot> parse error on input `>>'
15:36:12 <dylukes> :t (>>)
15:36:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
15:36:19 <parcs> i just defined the Writer type myself
15:36:24 <copumpkin> :t (*>)
15:36:25 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
15:36:26 <dylukes> :t (*>)
15:36:27 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
15:36:29 <dylukes> mmk
15:37:12 <fragamus> @type newStdGen
15:37:12 <lambdabot> IO StdGen
15:38:08 <fragamus>  
15:38:10 <fragamus> creatures = Prelude.map (\g -> (Data.Map.empty, 0.0,g)) generators
15:38:17 <dylukes> @hoogle (a -> b -> c) (a -> c -> b)
15:38:17 <lambdabot> No results found
15:38:22 <dylukes> @hoogle (a -> b -> c) -> (a -> c -> b)
15:38:22 <lambdabot> Data.Foldable foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
15:38:23 <lambdabot> Data.Foldable foldr' :: Foldable t => (a -> b -> b) -> b -> t a -> b
15:38:23 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
15:38:30 <dylukes> :t swap
15:38:31 <lambdabot> Not in scope: `swap'
15:38:35 <dylukes> :t flip
15:38:36 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
15:38:49 <dylukes> :t Prelude.flip
15:38:50 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
15:44:24 <dylukes> wtffff
15:45:54 <dylukes> https://gist.github.com/985985
15:47:09 <dylukes> I'm not sure what to make of this ._.
15:49:08 <dafis> dylukes: you need (PT.reservedOp parser name)
15:49:16 <dylukes> ah, right
15:49:18 <dylukes> >_<
15:51:53 <dylukes> :D
15:51:57 <dylukes> parse expr "" "1+2"
15:52:00 <dylukes> Right (+ (1) (2))
15:52:43 <dylukes> the only thing is since the Mul/Add/Etc data constructors require that their parameters are Exprs, I have to wrap the values in Pars
15:52:46 <dylukes> oh well.
15:52:53 <fragamus> @type newStdGen
15:52:54 <lambdabot> IO StdGen
15:54:13 <eikenberry> When using ByteString how do you avoid Ambiguous related errors with Prelude versions of the same functions?
15:54:22 <ben> You import ByteString qualified
15:55:10 <eikenberry> ben. Thanks. Googling qualified imports.
15:55:28 <ben> import qualified Data.ByteString.Lazy as L
15:55:36 <ben> L.length or whatever
15:56:57 <eikenberry> ben. Thanks again.
15:58:38 <dylukes> :D
15:58:40 <dylukes> hurray!
15:58:41 <dylukes> https://gist.github.com/985993
15:58:42 <dylukes> it works
15:58:47 <dylukes> but, one flaw I'd like to fix.
15:59:07 <dylukes> notice in Table, where I supply the function the operator should be mapped too
15:59:19 <dylukes> the parameters to Mul/Sub/Add necessarily have to be Expr's
15:59:24 <dylukes> so I wrap the subexpressions in Par
15:59:30 <dylukes> can anyone think of a cleaner way to do this?
15:59:38 <dylukes> Or should I just do a second pass to remove redundant parentheses?
16:00:31 <mauke> I don't get it
16:00:36 <mauke> why does Par exist?
16:00:44 <dylukes> Par is for parentheticals.
16:00:52 <mauke> why does it exist?
16:00:52 <dylukes> I just made it an operator. For some reason.
16:01:05 <dylukes> For parenthesized expressions.
16:01:13 <mauke> how are they different?
16:01:19 <dylukes> To the evaluator it will just be a hint to indicate "evaluate everything inside first"
16:01:30 <mauke> how is Par x different from x?
16:01:53 <tg_> le sigh, I am not getting this...
16:02:01 <dylukes> mauke: It's for the syntax tree >_<
16:02:06 <dylukes> Par x = (x)
16:02:07 <parcs> tg_: do you still want the writert version?
16:02:13 <dylukes> so, if x is just a Nat, its not different
16:02:20 <dylukes> but if x is some complicated Expr, it is.
16:02:25 <tg_> parcs, I have the paste, but now "tell" doesn't work like LYAH says it would
16:02:26 <mauke> dylukes: how is it different?
16:02:26 <dylukes> To indicate order of evaluation.
16:02:29 <mauke> dylukes: how is it different?
16:02:37 <dylukes> jesus, stop spamming obnoxiously ._.
16:02:42 <mauke> start answering
16:02:49 <parcs> tg_: elaborate!
16:02:56 <dylukes> sec, typing
16:03:42 <dylukes> 1 + 2 * 3 => (Add (Nat 1) (Mul (Nat 2) (Nat 3))
16:03:43 <dylukes> (1+2)* 3 => (Mul (Par (Nat 1) (Nat 2)) (Nat 3))
16:03:53 <dylukes> err, replace Par with Par (Add...
16:03:59 <dylukes> hm
16:04:01 <dylukes> >_>
16:04:12 <dylukes> Yeah, I see your point now I think
16:04:26 <tg_> parcs: http://hpaste.org/46943/tell_fails
16:04:36 <dylukes> mauke: Alright, we'll its useless for indicating parens themselves but,
16:04:52 <dylukes> how do you propose I box arbitrary expressions for use in the table definition?
16:04:53 <dylukes> :|
16:05:05 <dylukes> oh… right… a and b...
16:05:07 <dylukes> will be Expr...
16:05:10 <dylukes> ugh...
16:05:12 <dylukes> I'm too tired.
16:05:20 <mauke> dylukes: why does Expr have a type parameter?
16:05:37 <dylukes> because I was considering trying it with other types.
16:05:40 <parcs> tg_: oh, because i removed the Control.Monad.Writer import because its definition of Writer is invalid with that in the book
16:05:42 <parcs> one sec
16:05:47 <ddarius> mauke's School of Hard Knocks
16:07:14 <parcs> http://hpaste.org/paste/46943/tell_fails_annotation#p46944 should work
16:23:42 <zztr> is there an osgi for haskell?
16:24:19 <zztr> ie, dynamic, versioned, loading and unloading of dependencies
16:26:09 <dylukes> One thing I never get tired of with Haskell
16:26:13 <dylukes> always so easy to refactor :|
16:36:16 <dylukes> alright...
16:36:17 <dylukes> https://gist.github.com/986016
16:36:20 <dylukes> mauke: Happy now?
16:36:32 <dylukes> also, I'd like to rewrite rational on line 36, but I'm not sure how...
16:36:40 <dylukes> I'm almost certain that can be made better though.
16:37:14 <dmwit> Anybody got a copy of ghc7 lying around?
16:37:28 <dmwit> Can you try, in ghci, doing ":{" and then, on the next line, ^C?
16:37:40 <dylukes> nothing happens
16:37:49 <dylukes> heres the result
16:37:49 <dylukes> http://cl.ly/6z45
16:37:52 <dmwit> Do you still have a "pipe" thing?
16:37:56 <dylukes> Ctrl-C just goes to the next line.
16:37:58 <dylukes> Yes.
16:37:59 <dmwit> Does it respond instantly to new lines?
16:38:07 <dylukes> yep
16:38:09 <dmwit> e.g. does "23" all alone print "23" next?
16:38:14 <dmwit> Great, I think I found a bug, then. =D
16:38:18 <dylukes> it prints 23
16:38:25 <dylukes> http://cl.ly/6z35
16:38:27 <dylukes> what's supposed to happen?
16:38:50 <dmwit> ^C should probably return the prompt to "Prelude>" rather than "Prelude|".
16:39:12 <dmwit> (Though everything but the prompt seems to be behaving more or less as I expect.)
16:39:13 <dylukes> ah I see.
16:39:19 <dylukes> what is :{?
16:39:49 <geheimdienst> a man with a drooping moustache
16:40:16 <dmwit> dylukes: :{ and :} delimit multi-line ghci commands.
16:40:20 <dylukes> I see.
16:40:45 <saiko-chriskun> let's say I have MyTypeCon String String, and a list, ["str1", "str2"]
16:40:51 <saiko-chriskun> how would I apply MyTypeCon to the list?
16:41:15 <aristid> so that the result is MyTypeCon "str1" "str2"?
16:41:33 <saiko-chriskun> yeah
16:41:44 <aristid> f [a,b] = MyTypeCon a b
16:42:02 <saiko-chriskun> oh right
16:42:04 <saiko-chriskun> hah
16:42:13 * saiko-chriskun goes away now
16:44:37 <dafis> dmwit: Prelude| :}
16:44:37 <dafis> unknown command ':}'
16:44:37 <dafis> use :? for help.
16:44:58 <dafis>  :} doesn't work :(
16:45:59 <mnslaww> In Network.Wai, is it a bad idea to use responseLBS?
16:46:30 <mnslaww> earlier versions of the module suggest that it is a convenient way to convert lazy-style code to enumerator-style code, but the current version seems to discourage it
16:48:34 <dmwit> dafis: :} only works if you've previously begun a multi-line command with :{ (and haven't canceled it with ^C since then).
16:51:05 <dafis> Prelude> :{
16:51:05 <dafis> Prelude| do putStrLn "One"
16:51:05 <dafis> Prelude|    putStrLn "Two"
16:51:05 <dafis> Prelude| :}
16:51:05 <dafis> One
16:51:06 <dafis> Two
16:51:12 <dafis> Ah, good to know
16:51:28 <siracusa> dmwit: Seems to be an old bug, already present in 6.10
16:51:46 <dmwit> siracusa: I'm sure it goes all the way back to the first version that had multiline commands.
16:51:51 <dmwit> I don't think it's a regression.
16:52:06 <parcs> mnslaww: how does the current version appear to discourage the use of responseLBS?
16:52:41 <mnslaww> parcs- The advantages of enumerators over lazy IO have been debated elsewhere and so will not be addressed here. However, helper functions like responseLBS allow you to continue using lazy IO if you so desire"
16:52:59 <mnslaww> parcs- that seems quite discouraging :-/
16:53:09 <parcs> ah, yeah
16:53:38 <parcs> for my website i created a simple responseBS function that works with string BSes and used that instead
16:53:57 <parcs> strict*
16:54:40 <mnslaww> parcs- is that a serious performance consideration? i'm mainly going to be rendering json or html templates
16:55:34 <dafis> ClaudiusMaximus: do you need a 1-1 correspondence between DoubleDouble (QuadDouble) values and String representations?
16:56:01 <ClaudiusMaximus> dafis: not personally..
16:56:12 <ClaudiusMaximus> dafis: ..and i don't know if anyone but me uses it :)
16:56:16 <parcs> mnslaww: no, it was mainly done as an exercise. i have no idea how what the performance benefit (if any) it yields
16:56:57 <dafis> ClaudiusMaximus: Okay, because if you did, you'd basically need to print to full precision
16:57:26 <parcs> if you're interested enough i suggest you send an email to the web-devel mailing list. the creator of the package is very responsive there
16:58:25 <mnslaww> parcs- do you mind sharing the code for the strict version of responseBS (if it was relatively short)? i think that could significantly aid my understanding. and thanks for the email suggestion
17:05:04 <parcs> it's simply responseBS s h = ResponseBuilder s h . Blaze.ByteString.Builder.fromByteString
17:05:25 <dmwit> Well, before I was baffled because after this refactoring everything broke. Now I'm baffled that before the refactoring, nothing was broke.
17:05:37 <mnslaww> parcs- cool. thanks a lot for your help
17:05:43 <sina> is there a way to comment a block in haskell?
17:05:46 <sina> instead of -- ?
17:05:49 <dmwit> {- like this -}
17:05:55 <sina> forgot it
17:05:56 <sina> yeah
17:05:58 <dmwit> {- {- this also works, unlike in C++ -} -}
17:06:14 <copumpkin> nested comments are the bomb
17:06:18 <sina> have it on my code :| such a stupid question ! lol
17:06:32 <sina> really it wont get annoyed by the second -} ?
17:06:47 <nornagon_> i'm trying to update cabal on OSX
17:06:49 <mauke> nested comments are stupid
17:06:53 <dmwit> Nope, it parses comments (to the extent necessary to recognize {- and -} inside).
17:07:01 <mauke> and the only language that has them is ocaml
17:07:12 * mauke rants and raves
17:07:18 <sina> mauke they aren't .... sometimes you have some sort of comment, but want to disable a whole block for debugging
17:07:40 <sina> that happened to me lots of times in like php, and it gets annoyed by every */
17:07:41 <mauke> sina: putStr "-} where is your god now?"
17:07:56 <nornagon_> cabal install cabal-install fails, though -- looks like time-1.1.4 depends on a newer cabal than I have, and cabal-install seems to depend on time-1.14
17:08:12 <dmwit> mauke: Yep, that's always a problem.
17:08:18 <mauke> dmwit: not with nested comments
17:08:36 <aristid> mauke: huh? does ocaml parse quotes inside comments?
17:08:46 <nornagon_> https://gist.github.com/986039
17:08:46 <mauke> aristid: yes. ocaml lexes comments.
17:09:05 <mauke> that's the only way you can *nest* comments
17:09:31 <mauke> the correct solution would be doing what C does :-(
17:09:43 <aristid> #if 0
17:10:02 <dmwit> The correct solution is getting your editor to help your compiler.
17:10:12 <mauke> aristid: yeah
17:10:35 <sina> I have program that is supposed to parse anonymous functions. like this (\x -> a)
17:10:55 <sina> but I dont know how to parse it like \x -> a + b
17:11:10 <sina> basically having `function` in the middle
17:11:24 <sina> it currently parses func a fine
17:11:28 <aristid> sina: the operator?
17:11:41 <dolio> The correct solution is obviously doing what OCaml does.
17:11:55 <sina> aristid: I dont mean just + . it can be other operators
17:11:59 <mauke> dolio: no, I don't want syntax errors in my comments
17:12:05 <sina> so I cant just parse the + sign
17:12:05 <mauke> they're fucking comments
17:12:21 <aristid> sina: in haskell, there is a whole set of operator characters
17:12:48 <aristid> sina: it's basically everything that is a unicode punctuation or symbol character, except a few that are reserved for something else
17:13:12 <sina> yeah ,so if I want to tell the parser to parse operators, whats the best way you think?
17:13:30 <aristid> just do it?
17:13:49 <dmwit> You get to choose whether you bite it on input ({- "-}" -}) or whether you bite it on input ({- " -}). It's not clear to me that either choice is the obviously right one.
17:14:00 <sina> matching unicode? the thing is that it might not always be there
17:14:08 <mauke> dmwit: neither is correct
17:14:45 <aristid> dmwit: #if 0 is a nice solution.
17:15:07 <dmwit> I don't see that #if 0 works around this in any way.
17:15:09 <mauke> the trick is to separate disabled code from comments
17:15:11 <dmwit> What do you do with, e.g.
17:15:14 <dmwit> #if 0
17:15:17 <dmwit> foo = "\
17:15:19 <dmwit> #endif
17:15:21 <dmwit> "
17:15:23 <dmwit> #endif
17:15:24 <dmwit> ?
17:15:30 <aristid> dmwit: C parses that correctly.
17:15:43 <dmwit> What if I don't agree with you about what "correctly" means?
17:15:52 <aristid> it is specified, so you can't.
17:15:59 <dmwit> Yes, I can.
17:16:01 <aristid> the \ puts the lines together
17:16:02 <mauke> dmwit: well, that's a syntax error no matter what you do
17:16:13 <aristid> so the first #endif is no longer at the beginning of the line
17:16:14 <dmwit> Haskell and OCaml both specify their comment syntax, yet mauke disagrees with both.
17:16:15 <mauke> you've got an unterminated string
17:17:01 <aristid> you may argue that C's "paste lines together with \" should not exist
17:17:10 <aristid> but the way it behaves is consistent
17:17:29 <dmwit> mauke: Yes, that's an idea. Separating disabled code from comments.
17:17:50 <mauke> which is what C does
17:18:00 <aristid> but the best thing is not commenting out code at all
17:18:05 <aristid> we got version control systems
17:18:24 <dmwit> Oh, nonsense.
17:18:30 <aristid> i hate it when people have functions that are 50% commented out code
17:18:46 <dmwit> Everybody tries to avoid checking in broken code, and sometimes you have to comment out code to unbreak it.
17:18:53 <dmwit> (during debugging)
17:19:05 <aristid> no, not everybody tries to avoid checking in broken code :p
17:19:21 <dmwit> Naturally, you shouldn't check in commented-out code, but saying you can't do it at all doesn't strike me as a good solution.
17:19:23 <aristid> and well yeah, during debugging you may need that.
17:19:37 <aristid> i don't say you should never do it. but avoid it.
17:21:28 <geheimdienst> an extra feature for inactive code is smelly, i think. but what i'd like to see is runnable example code in haddock comments
17:22:20 <aristid> geheimdienst: how would that work?
17:26:44 <geheimdienst> i think it should be like a unit test. you write something like "> reverse [1,2,3] \n -->> [3,2,1]" in the documentation and there's a tool that runs that stuff, like unit tests ...
17:27:06 <geheimdienst> really, it's not rocket science. it would be a pretty modest addition to haddock syntax
17:27:09 <ezyang> Yes, that would be quite handy.
17:29:02 <ivanm> geheimdienst: there's doctest IIRC
17:29:09 <ivanm> and latest haddock has support for it I think
17:29:22 <geheimdienst> yes, i've heard of doctest ...
17:29:35 <geheimdienst> sounds good, need to check that out
17:31:15 <ivanm> hackage!
17:31:33 <ivanm> though by "support" I think it just means markup support, not actually running it
17:31:37 <ivanm> but I could be wrong
17:32:16 <dankna> okay, so
17:32:58 <dankna> I have an architecture (this program is a hardware simulator/emulator) where I have a bunch of chips/processors, each defined in their own file/module and not knowing anything about the system as a whole
17:33:24 <dankna> I found my simulation to be very slow, and through extensive profiling and working with people in here I determined the main expense to be allocating state structures each iteration
17:33:44 <dankna> following a suggestion, I am currently reworking things to keep the state "uncurried" (flattened into its individual fields) on the stack
17:33:56 <dankna> with a monad that ... I think I just solved my problem
17:34:02 <dankna> so never mind the rest of what I was going to say :)
17:34:18 <Saizan> so ti really worked?
17:34:35 <ivanm> dankna: heh, isn't it great how you can solve your own problems by trying to explain what's wrong when asking for advice?
17:34:38 <geheimdienst> "ai'm in ur #haskll, rubberducking teh dudes"
17:34:41 <dankna> Saizan: oh you're there :) well it hasn't worked yet but I spent the past couple days writing Template Haskell...
17:34:43 <dankna> ivanm: yes
17:34:47 <dankna> ivanm: yes it is
17:35:05 <Eduard_Munteanu> Ugh... so basically you'll end up using something like tuples instead of records?
17:35:09 <dankna> Saizan: ... to generate the definitions of the flattened-record monad and the accessors
17:35:31 <dankna> no, no tuples.  that would still allocate memory.  they have to be individual parameters.  it's okay - Template Haskell tucks it all under the hood.
17:35:37 <Eduard_Munteanu> Hrm.
17:35:39 <Saizan> dankna: yeah, i'd have done the same
17:35:46 <Eduard_Munteanu> Well you know... ST is probably really good at that already.
17:36:24 <dankna> Saizan: yeah.  so the generated TH is correct, as far as I can tell.  I was able to run it with no changes to the rest of the code and it ran fine, although it didn't perform any better, but that was expected.
17:36:30 <Saizan> with ST it'd be fairly different, but it could be a solution too
17:37:07 <dankna> Saizan: so what I'm doing now is modifying the rest of the code to actually access fields one at a time as they're needed, instead of asking for a state structure (which of course forces it to allocate no matter what) and then peeking into it
17:37:17 <dankna> Saizan: so sometime today, hopefully, I'll know whether your solution works!
17:37:44 <dankna> hmmm, I should look into ST, since I don't know much about it.  I am dubious that it can avoid allocation though.
17:37:50 <Saizan> dankna: cool :)
17:37:55 <dankna> yeah :)
17:38:13 <Eduard_Munteanu> Of course, only if you access individual fields.
17:38:29 <Saizan> well, you could keep each field in its own STRef, and have a version of the record where the fields are those STRefs
17:38:57 <Saizan> then you wouldn't need to allocate a new record constructor, since you're modifying the STRef's instead
17:39:00 <dankna> hmmm
17:39:05 <dankna> yes I see
17:39:09 * dankna skims http://www.haskell.org/haskellwiki/Monad/ST
17:39:13 <ddarius> At which point you could use a State s a = Reader (STRef st s) a approach.
17:39:14 <dankna> I don't really like that style, to be honest
17:39:23 * Eduard_Munteanu already sees a ReaderT over ST sort of setup in this
17:39:40 <Eduard_Munteanu> Heh, yeah.
17:40:01 <Saizan> yeah, though you'd have a record of STRef's instead of a single one
17:40:05 <dankna> it makes it harder to reason about the behavior of the program, due to mutability
17:40:12 <ddarius> Saizan: Indeed.
17:40:20 <ddarius> The monad would still need to be custom.
17:40:29 <dankna> if you're curious, what I was going to ask about...
17:40:48 <ddarius> dankna: You can make it look -exactly- like a pure State monad.
17:40:54 <dankna> I defined (Monad m) => MonadChip m where ... {- accessors -}
17:41:04 <dankna> ddarius: hm!  that's interesting
17:41:44 <Saizan> the specialized curried/cps monad is potentially faster because fields might be kept in registers if the optimizers is doing its job
17:41:45 <dankna> and then what I do is, each chip's cycle function has a signature like :: (Monad m, MonadChip mc) => (mc a -> m a) -> m ()
17:41:58 <Eduard_Munteanu> ddarius: I don't think you can go out of runST and back into it using the same refs though
17:42:14 <dankna> in other words it gets called in an opaque monad that it knows nothing about, with /one/ accessor, that being "liftChip" which lifts an action in the monad that it does know something about into this monad
17:42:17 <Eduard_Munteanu> So it'd need some 's' passing around.
17:42:34 <ddarius> Eduard_Munteanu: The only time you'd use runST is in the runState function.
17:42:35 <dankna> the reason for doing it that way instead of simply having the opaque monad be translucent and an instance of MonadChip is that this way I can have multiple instances of the same chip in it
17:43:17 <dankna> my question was going to be how I could define the MonadChip instance without affecting the opaque monad type, but I realized that all I need is a newtype.
17:43:41 <dankna> Saizan: there are, uh, 49 fields though :) so I doubt most of them are in registers :)
17:47:17 <ClaudiusMaximus> arg.  my heap profile graph looks like this :(   http://claudiusmaximus.goto10.org/g/ruff/ruff-gl.png  - it "feels" like runSTUArray is too lazy, saving all the work til the end instead of working incrementally
17:48:29 <dankna> ClaudiusMaximus: wow, that looks familiar
17:48:33 <ezyang> that seems unlikely, given that STUArray = *unboxed* array.
17:48:45 <dafis> ClaudiusMaximus: did you make the stuff inside the runSTUArray strict enough?
17:49:15 <ClaudiusMaximus> dafis: i don't know - i've got bang patterns on my inner loops...
17:49:17 <ezyang> I'd be looking at Mandelbrot.Iterate.IterD
17:49:41 <ezyang> Also, compile with profiling and get yerself some cost-center figures.
17:49:56 <ClaudiusMaximus> ezyang: the yellow one (OutDi...) should not be increasing, it should be written to the array as soon as it's ready
17:50:18 <ezyang> Well, that's not the unboxed arrays fault.
17:50:43 <ezyang> That's whatever is invoking whatever function is writing to the array. But you're using an STUArray, right? That is strict in its state.
17:51:43 <ezyang> Anyway, get yourself a cost center profile. It will be enlightening.
17:51:58 <ezyang> Among other things, it will tell you which functions generating all of these left over yellow bits.
17:53:15 <ezyang> So then you can go look at /that/. Don't go randomly sprinkling stricts in your code. It won't help. Really.
17:53:34 <ClaudiusMaximus> ezyang: i did, it wasn't enlightening (need to add more SCC i think..)
17:53:41 <ezyang> Have you tried -auto-all?
17:54:03 <ezyang> First thing you should reach for.
17:54:13 <ClaudiusMaximus> ezyang: yeah, no help - 66% of time/alloc in one function, all the things below it had 0.1% ...
17:54:32 <ezyang> How big is that function? :^)
17:54:43 <ezyang> It almost certainly is the culprit.
17:57:54 <ddarius> http://hpaste.org/46948/state_implemented_in_terms_of
17:58:32 <dankna> ddarius: thanks, interesting.  I'll keep that around in case Saizan's approach doesn't work.
17:58:48 <ddarius> dankna: You'd still have to modify it slightly.
17:59:30 <dankna> a lot, rather
17:59:41 <ddarius> Not much.
17:59:47 <dankna> I wouldn't want to use MonadState at all - going through those accessors would construct the entire tree
18:00:03 <ddarius> Correct, you wouldn't want to use MonadState at all, though you could still implement it.
18:00:05 <dankna> I'd have to use a custom monad that has an accessor for each actual field, like what I'm doing now
18:00:08 <dankna> right
18:00:49 <dankna> well, I'd call that a day's work to implement, given that I'd have to modify my TH stuff appropriately, so I'd consider it a lot :)
18:01:08 <dankna> although in some sense yes, I see that the changes I'd need are trivial
18:01:29 <ddarius> How many fields do you have in this record?
18:01:37 <dankna> 49 flat fields
18:01:53 <dankna> that is, once all the sub-records are considered to be part of the parent
18:01:58 <dankna> there's then 49 fields remaining
18:02:33 <ddarius> With the ST approach, it's not necessary to flatten the record other than to save a little on indirection.
18:02:34 <dankna> (a fair chunk of my TH deals with coming up with decent names for all these accessors!)
18:02:51 <dankna> hmm, yes, I see
18:07:39 <ClaudiusMaximus> stupid glut :( window close button -> aborts program -> profiling output file is empty
18:08:18 <dankna> ClaudiusMaximus: yes.  I ran into that as well.  have to call hs_exit() somehow to fix it.  (I was using Cocoa as the front-end though, not GLUT)
18:16:04 <tg_> i keep getting errors about the string/character literal 'o' in "otherwise"
18:16:10 <tg_> what's the general problem(s)?
18:16:46 <dankna> hpaste one of the errors
18:16:48 <dons> can't tell from that. do you have a paste somewhere? (e.g. hpaste.org)
18:17:29 <tg_> http://hpaste.org/46949/test
18:17:48 <tg_> this is LYAH
18:17:53 <tg_> i keep getting them in different places
18:18:04 <qacek> is the diff array package still considered inefficient compared to MArray?
18:18:27 <dons> qacek: in fact, its been removed from the core libraries
18:18:33 <ClaudiusMaximus> tg_: should be `mod` not 'mod'
18:18:36 <dons> qacek: try something like vector or repa as an alternative.
18:18:43 <dons> ClaudiusMaximus: well spotted!
18:18:43 <ClaudiusMaximus> > 'mod'
18:18:44 <lambdabot>   <no location info>:
18:18:45 <lambdabot>      lexical error in string/character literal at chara...
18:18:48 <tg_> ClaudiusMaximus: sigh thanks
18:19:17 <tg_> question without having learned about any monad except writer:
18:19:45 <tg_> is there a monad which acts like writer but just writes haskell expressions?
18:19:55 <tg_> is that what streams are?
18:19:59 <tg_> *shrugs*
18:20:54 <dmwit> I thought Writer did just write (monoidal) Haskell expressions.
18:21:12 <tg_> in that case
18:21:26 <tg_> I guess I need to write a PlusMinus and a MinusPlus Monoid
18:21:41 <dmwit> hm?
18:21:50 <dmwit> :t runWriter
18:21:51 <lambdabot> forall w a. Writer w a -> (a, w)
18:21:52 <tg_> dmwit: just an experiment
18:22:21 <dmwit> > runWriter (tell (Sum 3) >> tell (Sum 5) >> return 72) -- like this, you mean?
18:22:21 <lambdabot>   (72,Sum {getSum = 8})
18:22:27 <tg_> nope
18:22:34 <tg_> I need a multiplicative version
18:22:48 <dmwit> > runWriter (tell (Product 3) >> tell (Product 5) >> return 72)
18:22:49 <lambdabot>   (72,Product {getProduct = 15})
18:23:13 <tg_> one implemented using central differences :o
18:23:22 <tg_> the units are going to be:
18:23:41 <dmwit> > second ($0) $ runWriter (tell (Endo (+3)) >> tell (Endo (*5)) >> return 72)
18:23:42 <lambdabot>   Couldn't match expected type `Data.Monoid.Endo a'
18:23:42 <lambdabot>         against inferred ...
18:23:48 <tg_> 1 = ((p * p) * p)/p
18:23:51 <dmwit> > second (flip appEndo 0) $ runWriter (tell (Endo (+3)) >> tell (Endo (*5)) >> return 72)
18:23:52 <lambdabot>   (72,3)
18:24:03 <dmwit> > second (flip appEndo 10) $ runWriter (tell (Endo (+3)) >> tell (Endo (*5)) >> return 72)
18:24:04 <lambdabot>   (72,53)
18:24:06 <tg_> and -1 = 1/((p * p)(p * p))
18:24:10 <tg_> something like that
18:24:12 <tg_> errrr
18:24:15 <tg_> that last one has to have a p on top
18:24:26 <tg_> applicative endocunfcotr huh
18:25:01 <tg_> dmwit: i don't know what I want yet, but i'll get back soon
18:25:32 <Throoze> hey
18:25:45 <Throoze> please, does someone know what does this means???
18:26:04 <Throoze> templates/wrappers.hs:373:3667:     Couldn't match expected type `[Char]' against inferred type `Float'       Expected type: AlexAcc (AlexPosn -> String -> Token) user       Inferred type: AlexAcc (AlexPosn -> Float -> Token) user1     In the expression: (AlexAcc (alex_action_54))     In the expression: [(AlexAcc (alex_action_54))]
18:26:23 <Throoze> Im building a lexicographic analizer with alex
18:26:55 <Throoze> thats the output of the command ghc --make Mymodule.hs
18:27:04 <byorgey> Throoze: did you write the code [(AlexAcc (alex_action_54))] or was that auto-generated?
18:27:30 <byorgey> if auto-generated (as I suppose) then it is probably a bug in alex
18:27:42 <Throoze> that was auto-generated
18:28:02 <Throoze> no idea what to do???
18:28:02 <dmwit> Bonus points for pasting code to hpaste.org. =)
18:28:03 <ddarius> I doubt it's a bug in Alex.
18:28:19 <byorgey> ddarius: oh?
18:28:19 <tg_> has anyone named the thing that you get when you do MapM versus MapM_
18:28:27 <tg_> is it like a "signature" or a "depth counter" or
18:28:39 <dankna> tg_: uhhh, a list?
18:28:50 <tg_> dankna: yeah, but certainly there's information in it
18:28:57 <ddarius> byorgey: Alex takes semantic actions and plenty of other input.  That can readily be ill-typed.
18:28:57 <byorgey> tg_: the underscore usually means you are "throwing away" some results
18:28:59 <Throoze> what do you think ddarius??
18:29:12 <byorgey> tg_: I'm not aware of a special name for that pattern.
18:29:20 <dmwit> I think we've helped you as much as we can without seeing your alex file.
18:29:34 <Throoze> hehehe sorry...
18:29:51 <Throoze> is there some place where i can paste code??
18:29:56 <tg_> @hpaste
18:29:56 <lambdabot> Haskell pastebin: http://hpaste.org/
18:30:02 <Throoze> or it is supposed to be pasted here?
18:30:44 <dons> no, at the paste bin
18:32:27 <Throoze> http://hpaste.org/46950/alex_for_vectorinox
18:32:36 <Throoze> heres my code
18:33:57 <dmwit> > mappend ("hello", "goodbye") (", world", " friend")
18:33:58 <lambdabot>   ("hello, world","goodbye friend")
18:34:39 <Throoze> has anyone seen the code?
18:35:56 <ddarius> What's the type of TkNum
18:35:56 <siracusa> Throoze: How is TkNum defined?
18:37:46 <byorgey> ddarius: heh, you're right that I jumped the gun on blaming alex =)
18:39:25 <deech> Hi all, I am trying to understand delimited continuations using some of the Scala tutorials. I am trying to translate the first example on here (http://suereth.blogspot.com/2010/03/how-you-should-think-about-delimited.html) and am having difficulties. Any help is appreciated.
18:39:56 <deech> Here's what I have so far : runCC $ reset $ (\p -> (shift p (\f -> 1 + f(f(4)) + 1))), but it doesn't compile.
18:41:22 <ddarius> deech: What's the type of f?
18:42:01 <deech> ddarius I
18:42:03 <Throoze> data Token =  ... | TkNum     (Int,Int) Float  | ...
18:42:06 <deech> I'm not exactly sure.
18:42:34 <dylukes> Er...
18:42:39 <dylukes> How do I express modulus for rationals?
18:42:45 <deech> The result I was hoping for was: 1 + f(f(4)) + 1 == 1 + (1 + 4 + 1) + 1
18:43:36 <siracusa> Throoze: You have to convert the string s to a Float value in the alernative for TkNum
18:44:39 <ClaudiusMaximus> hm, my calculations are getting forced by writeArray it seems, instead of earlier...
18:46:34 <koninkje> copumpkin: Well I just read a paper that said that Google's Web1T corpus only has 13.5M words (< 2^24) so you should be fine in morphologically poor languages like English
18:46:46 <ddarius> deech: I didn't ask about the result, I asked about the type.  shift is a library function, what's its type?
18:46:51 * koninkje deals with morphologically rich languages however
18:47:12 <copumpkin> koninkje: oh, I was mostly just balking at the notion of anything "human" exceeding the range of a Word64
18:47:20 <deech> ddarius : shift :: MonadDelimitedCont p s m => p b -> ((m a -> m b) -> m b) -> m a
18:47:44 <koninkje> copumpkin: Just take a look at any agglutinative language (Japanese, Hungarian, Inuit,...)
18:48:01 <ddarius> deech: So now what is f's type?
18:48:09 <copumpkin> > maxBound :: Word64
18:48:10 <lambdabot>   18446744073709551615
18:48:16 <copumpkin> koninkje: with more than that?
18:48:18 <copumpkin> o.O
18:48:37 <deech> ddarius : ((m a -> m b) -> m b)
18:48:48 <deech> Oh I see why it isn't compiling.
18:48:50 <dmwit> > logBase 2 (18446744073709551615 / 13500000)
18:48:51 <lambdabot>   40.31354392851236
18:48:59 <koninkje> If you have a language that inflects for tense (past,present,future), aspect (passive,active), mood (indicative,subjunctive), person (1st,2nd,3rd), number (singular,plural)...
18:49:11 <copumpkin> sure
18:49:12 <ddarius> deech: That's incorrect, but I think you saw what you needed to see anyway.
18:49:14 <koninkje> that's what? 3*2*2*3*2*n forms for n verbs
18:49:42 <koninkje> Those would all be ~6 forms in English
18:49:44 <dmwit> Do you need an additional 40 bits to encode tense, aspect, mood, person, and number?
18:49:57 <dmwit> Seems unlikely.
18:49:58 <deech> ddarius: Thanks! I will press on. I appreciate the help.
18:50:20 <koninkje> dmwit: If you have a decent morphological analyzer and can separate the different morphemes, then no
18:50:30 <koninkje> dmwit: If you're just hashing strings, then maybe
18:50:49 * copumpkin still has trouble seeing that kind of explosion :)
18:50:52 <copumpkin> but who knows
18:51:18 <koninkje> Also, In agglutinative languages you glom lots of words together into one. E.g "I wanted to believe that you said" could be one word
18:51:41 <copumpkin> well, in japanese you don't even have clear word boundaries if you just have a chunk of text
18:51:50 <koninkje> Again, morphological analysis will save you; but if you're just hashing strings...
18:53:26 <koninkje> Of course, the bigger issue from an NLP perspective is that with so many different forms of "the same word" your statistics will always be sparse (without morphological analysis to hlp abstract over things)
18:56:25 <dylukes> So,
18:56:25 <dylukes> https://gist.github.com/986107
18:56:28 <dylukes> ideas/comments?
18:58:14 <dylukes> er,
18:58:14 <dylukes> https://gist.github.com/986110
18:58:15 <dylukes> this one
18:59:12 <ClaudiusMaximus> http://hpaste.org/46952/profiling anyone can see if there's anything obviously wrong there that might cause it not to evaluate incrementally?
19:00:40 <eekTheCat> why is lambda calculus and the ability to curry important?
19:00:56 <eekTheCat> you can have partial application without these ideas right?
19:01:13 <ClaudiusMaximus> dylukes: why GADTs?  just for kicks?
19:01:22 <dylukes> ClaudiusMaximus: Yeah
19:01:26 <copumpkin> to pretend his type is polymorphic when it isn't
19:01:33 <dylukes> ClaudiusMaximus: also because I had earlier been playing with different number types :\
19:01:41 <Pseudonym> eekTheCAT: You can, but it's important to be able to have functions which return functions. Not being able to do that is an artificial restriction.
19:01:54 <ddarius> eekTheCat: Currying and the lambda calculus are more important than partial application, so that doesn't really matter.
19:02:11 <dylukes> copumpkin: Secretly I just feel more comfortable with GADT's than plain old ADTs...
19:02:23 <dylukes> I always find little catch22's with ADTs… GADTs feel more friendly >_<
19:02:28 <copumpkin> fair enough
19:02:33 <copumpkin> until you try to make a GADT-style record :)
19:02:35 <ddarius> That makes no sense.
19:02:38 <copumpkin> where the syntax makes no sense
19:03:07 <dylukes> what does it look like? :|
19:03:20 <dylukes> I never really have big records.
19:04:01 <eekTheCat> ddarius, how is it important?
19:04:25 <ddarius> eekTheCat: How is partial application important?
19:04:31 <eekTheCat> Pseudonym, high order functions necessitate currying?
19:04:40 <dmwit> dylukes: Why does Expr take a type-level argument, if it's always going to be Rational?
19:04:48 <ddarius> eekTheCat: The ability to curry is equivalent to supporting higher order functions.
19:04:50 <dylukes> dmwit: Earlier it wasn't always Rational >_>
19:04:55 <dylukes> dmwit: And, I'm thinking of adding Booleans :D
19:05:03 <copumpkin> ugh booleans
19:05:08 <dylukes> My checklist atm:
19:05:12 <dylukes> 1) Get mod/exp working
19:05:14 <dylukes> 2) booleans
19:05:19 <dylukes> 3) assignment/REPL
19:05:23 <dylukes> this is just for fun ^_^
19:05:28 <dylukes> I'm quite content with it though.
19:05:41 <dylukes> Any thoughts on how to do modulus/exponentiation on Rational?
19:05:51 <dmwit> A REPL is going to be hard if you don't separate type-checking from term construction.
19:05:58 <dmwit> :t fmod
19:05:59 <lambdabot> Not in scope: `fmod'
19:06:06 <copumpkin> > (5 :: Rational) ^ 5
19:06:07 <lambdabot>   3125 % 1
19:06:15 <copumpkin> oh, modular exponentiation?
19:06:21 <dylukes> > (5 :: Rational) ^ (4 :: Rational)
19:06:22 <lambdabot>   No instance for (GHC.Real.Integral GHC.Real.Rational)
19:06:22 <lambdabot>    arising from a use...
19:06:30 <dylukes> Remember, *all* of my expressions are Rational.
19:06:31 <dmwit> :t (^^)
19:06:32 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
19:06:36 <dmwit> :t (**)
19:06:37 <lambdabot> forall a. (Floating a) => a -> a -> a
19:06:38 <copumpkin> a rational power won't always lead to a rational answer
19:06:40 <ddarius> dylukes: 2^(1/2) is not a rational
19:06:44 <eekTheCat> ddarius, ok I see that. And I would say that is more important than just partial application
19:06:48 <eekTheCat> thanks
19:06:49 <dylukes> ddarius: Ah true :|
19:06:55 <dylukes> So, what do you suggest I do?
19:07:00 <dylukes> Fucking numbers, why don't you work.
19:07:01 <copumpkin> introduce moar typez
19:07:04 <copumpkin> always the answer
19:07:13 <dylukes> I think I'll just drop exponentiation for now.
19:07:23 <dylukes> dmwit: what'd you mean about separating type-checking from term construction?
19:07:53 <dmwit> dylukes: Using GADTs, you can enforce the restriction that only well-typed terms in your term language are also well-typed Haskell terms.
19:08:13 <dmwit> This is because you've basically forced the Haskell type-checker to do your type-checking work for you during term construction.
19:08:20 <dylukes> Hm yeah.
19:08:38 <dylukes> Might be best not to constrain the specification of the language with the implementation like that.
19:08:40 <dylukes> :|
19:08:49 <dmwit> When you write a term like If foo bar baz, the Haskell type-checker checks that "foo :: Expr Bool", and "bar" and "baz" are both "Expr a" for the same "a".
19:09:04 <dmwit> (I'm assuming that's what you meant by "add booleans", anyway.)
19:09:07 <Pseudonym> eektTheCat: Higher-order functions don't necessitate currying, but there's a tradeoff here.
19:09:17 <dylukes> So, maybe by initial AST construction should not actually evaluate literals?
19:09:25 <dylukes> but just associate each AST node with its relevant tokens?
19:09:30 <dylukes> then go through and type check?
19:09:35 <dylukes> I'm not quite sure how to go about it :\
19:09:36 <dmwit> Yes, that's what I suggest.
19:09:45 <dmwit> e.g. Expr should have no type-level arguments.
19:10:04 <Pseudonym> All nontrivial languages _need_ currying, whether it's built-in, a library, or unwieldy closure-creating syntax.
19:10:22 <dylukes> dmwit: I think later I'll redo this
19:10:29 <dylukes> splitting Integer and Real types,
19:10:32 <dylukes> adding a Boolean type,
19:10:34 <dylukes> and lambdas.
19:10:37 <Pseudonym> Haskell gives you currying at the language level and does the unwieldy clusure stuff for you.
19:10:46 * dmwit shrugs
19:10:53 <dylukes> And then do a proper type checker.
19:11:03 <Pseudonym> It's not the only option.  Boost.Function gives it to C++ programmers in convenient library form, which also works.
19:11:03 <dylukes> I'd like to have it not necessarily be too "tied" to Haskell itself.
19:11:18 <dylukes> Pseudonym: Python has it hacked in via functools.partial
19:11:35 <Pseudonym> dylukes: Please don't call it "Real".
19:11:51 <dylukes> Pseudonym: Float
19:11:53 <dylukes> happy? :\
19:12:03 <Pseudonym> Fortran has a lot to answer for. You can't represent all real numbers in a computer.
19:12:17 <dylukes> heh
19:12:34 <Pseudonym> Yeah.
19:12:37 <Pseudonym> Sorry, lag is bad today.
19:12:48 <copumpkin> there should be two Exprs
19:12:54 <copumpkin> one with type-level args and one without
19:13:07 <dylukes> copumpkin: hm?
19:13:21 <copumpkin> raw expr has no type arguments and is easy to build
19:13:44 <copumpkin> then your typechecker takes raw expr and returns exists t. Either TypeError (Expr t)
19:13:59 <dylukes> forall*?
19:14:00 <dylukes> :P
19:14:07 <copumpkin> I'd hope not forall
19:14:15 <dylukes> Do we even have an exists keyword?
19:14:18 <copumpkin> no
19:14:23 <Pseudonym> Not officially.
19:14:33 <dylukes> then how can we have exists t.
19:14:34 <dylukes> >_
19:14:35 <dylukes> >_>*
19:14:50 <copumpkin> forall r. RawExpr -> (forall t. Either TypeError (Expr t) -> r) -> r
19:14:54 <copumpkin> how about that
19:15:01 <dylukes> gah its ugly D:
19:15:02 <dylukes> :P
19:15:06 <copumpkin> life goes on
19:15:11 <copumpkin> I quite like working with that stuff, anyway
19:15:13 <amedxy> hi guys
19:15:14 <dylukes> hm.
19:15:18 <dylukes> Yeah, looks neat nontheless.
19:15:35 <dmwit> RawExpr -> Either TypeError (forall t. (Expr t -> r) -> r)
19:15:44 <dylukes> but, RawExpr itself,
19:15:52 <dylukes> would it have to hold the tokens?
19:15:55 <Pseudonym> exists a. (F a -> G) = (forall a. F a) -> G
19:16:23 <dmwit> or data ExisntentialExpr = forall t. Expr t
19:16:29 <dylukes> so data RawExpr = RawExpr String or something like that?
19:16:35 <dylukes> or hm, no
19:16:40 <dylukes> RawExpr is still a tree.
19:16:40 <amedxy> is correct this : "data Btree (a,a) = Leaf (a,a)| Fork (Btree (a,a)) (Btree (a,a))
19:16:40 <amedxy> "
19:16:54 <dmwit> RawExpr looks just like your current Expr, but with "Rational" erased everywhere it occurs as an argument to Expr.
19:16:55 <copumpkin> dmwit: good point
19:17:02 <amedxy> hello
19:17:13 <dylukes> dmwit: So still a GADT, okay whew.
19:17:23 <dmwit> amedxy: No. You can't pattern match on type arguments.
19:17:25 <dylukes> Again, my mind fails when I'm pushed back into plain-old ADT land >_>
19:17:31 <copumpkin> you can write plain old boring types (like RawExpr) as GADTs :P
19:17:41 <copumpkin> data Bool where True :: Bool; False :: Bool
19:17:41 <dylukes> copumpkin: I wouldn't have it any other way .__.
19:17:42 <dmwit> amedxy: Try "data Btree a = Leaf a | Fork (Btree a) (Btree a)" instead.
19:17:51 <dylukes> copumpkin: I know I know :P
19:17:59 <copumpkin> dylukes: I still find it hard to believe that a tiny superficial syntactic difference makes your mind fail ;)
19:18:05 <dmwit> dylukes: No, it's an ADT, but written with GADT syntax.
19:18:08 <dylukes> oh well :)
19:18:09 <amedxy> dmwit i need a bintree with a pair of integers
19:18:14 <dylukes> dmwit: I like the syntax more, shush
19:18:18 <dylukes> keep going anyways
19:18:20 <dmwit> amedxy: Then use "Btree (Int, Int)".
19:18:35 <dylukes> The only thing is, I don't see how I can construct the RawExpr tree,
19:18:39 <dylukes> without potential type errors,
19:18:42 <dmwit> amedxy: ...*after* defining "Btree" for any type "a".
19:18:52 <dylukes> unless I leave the tokens un… loaded into values.
19:18:56 <dylukes> w/e
19:19:00 <dylukes> continue what you were saying please.
19:19:18 <amedxy> data Btree (Int,Int) = Leaf (Int,Int)| Fork (Btree (Int,Int)) (Btree (Int,Int)) ?
19:19:24 <dmwit> amedxy: No.
19:19:34 <dmwit> amedxy: data Btree a = Leaf a | Fork (Btree a) (Btree a)
19:19:35 <dmwit> for real
19:19:48 <amedxy> and the pair?
19:19:53 <dmwit> comes later
19:20:12 <dmwit> Later, you can define a particular function "f :: Btree (Int, Int) -> Int" or whatever.
19:20:50 <dylukes> copumpkin: ?
19:20:55 <copumpkin> omnom
19:20:58 <copumpkin> yogurt time
19:21:04 <dylukes> >_>
19:21:06 <dmwit> dylukes: Ask a more specific question, and we'll do our best.
19:21:21 <dylukes> Alright, I'm going to just try to write this with a separate type checker tomorrow :)
19:21:31 <dylukes> gnite then
19:21:37 <copumpkin> aw
19:21:42 <copumpkin> you don't want to follow my awesome advice?
19:22:25 <dylukes> I will! Tomorrow!
19:22:29 <copumpkin> hrrmpf
19:22:37 <dylukes> Sorry copumpkin, do you feel neglected?
19:22:41 <copumpkin> YES
19:23:13 <amedxy> dmwit i can't understanding
19:24:41 <dmwit> amedxy: The basic pattern is: define what a btree is for *any* type "a", and then specialize "a" to the actual type you're interested in later.
19:25:17 <aristid> @pl \a (x,y) -> x < a && a < y
19:25:18 <lambdabot> (`ap` snd) . (. fst) . ap (flip . (((.) . (&&)) .) . flip (<)) (<)
19:25:29 <aristid> @pl \a x y -> x < a && a < y
19:25:30 <lambdabot> ap (flip . (((.) . (&&)) .) . flip (<)) (<)
19:25:46 <aristid> @pl \x y a -> x < a && a < y
19:25:47 <lambdabot> (. flip (<)) . ap . ((&&) .) . (<)
19:25:53 <aristid> @pl \x y a -> x < a && y < a
19:25:54 <lambdabot> (. (<)) . ap . ((&&) .) . (<)
19:26:06 <amedxy> dmwit tks
19:26:12 <amedxy> i'm newbie
19:28:45 <amedxy> for print a line of *'s (************) I use : printx y = take y (sequence "*")
19:29:10 <koninkje> @src replicate
19:29:11 <lambdabot> replicate n x = take n (repeat x)
19:30:31 <koninkje> i.e., printx = (`replicate` '*') is better
19:30:45 <amedxy> oh tks
19:31:17 <koninkje> (or printx n = replicate n '*', if you prefer)
19:31:29 <aristid> or printx = flip replicate '*'
19:32:35 <amedxy> tks aristid
19:34:55 <amedxy> aristid:  this is "*******" but for ********** ?
19:35:42 <aristid> > replicate 10 '*'
19:35:43 <lambdabot>   "**********"
19:35:47 <aristid> > replicate 20 '*'
19:35:48 <lambdabot>   "********************"
19:36:11 <amedxy> ok this is correct
19:36:32 <amedxy> but i want *********** not "*********"
19:37:00 <aristid> > text $ replicate 20 '*'
19:37:01 <lambdabot>   ********************
19:37:07 <dmwit> Perhaps you meant to use putStr or putStrLn instead of print.
19:37:23 <aristid> or that.
19:47:04 <ClaudiusMaximus> hm, with the deepseq sledgehammer the graph is flat, but no better - the yellow shouldn't be there for so long...  http://claudiusmaximus.goto10.org/g/ruff/ruff-gl_deepseq.png
19:49:43 <diabolix> so, I find that a common operation in some of my code is to have functions that take a record, and return something that is essentially a copy, but with one field altered, is clear/short way to say 'copy the contents of this record, but change this field?
19:50:23 <dmwit> record { field = newValueOfField }
19:50:43 <ClaudiusMaximus> gets uglier for modification, like  \x -> x{ fieldY = f (fieldY x) }
19:51:18 <dmwit> That problem has been solved for a while, I guess.
19:51:20 <ivanm> does it make sense to use binary even when I don't want to make instances of the Binary class?
19:51:28 <dmwit> The various lens packages are for just that kind of thing.
19:51:39 <ivanm> (I need to implement 3 different ways of serialising a data type)
19:53:05 <ddarius> ivanm: Of course it does.
19:53:53 <diabolix> dmwit: thanks, thats splendid.
19:55:24 <diabolix> that makes this slop code so much better.
19:56:11 <diabolix> I thought as a c/c++/assembly guy I would hate this language, but I'm just tickled pink.
19:57:36 <copumpkin> I spent ages doing loads of really low-level stuff and love haskell :)
19:57:59 <diabolix> I'll never touch python outside of work again.
19:57:59 <KirinDave> It's liberating.
19:58:03 <ddarius> Continuation passing style kind of ruins assembly.
19:58:13 <KirinDave> Yay. Screw that bizarre, pompous language.
19:58:33 <KirinDave> It is so weird that people insist Python is simple
19:58:51 <ddarius> simple = intuitive = familiar
19:58:54 <copumpkin> python is pythonic
19:59:07 <ddarius> Is Icon iconic?
19:59:08 <KirinDave> When in reality it's like the Special Case Express, taking a bullet route to confusing exceptions and inexplicable semantic choices.
20:00:46 <KirinDave> I just recently ran across http://evalinux.wordpress.com/2008/12/11/default-parameters-values-and-mutable-callable-objects/
20:00:58 <KirinDave> Which is just... it's like the most awful way to implement default values.
20:01:02 <BMeph> ddarius: To the U of A CS department, it is. :)
20:01:04 <KirinDave> They don't have to do it that way
20:02:49 <diabolix> unfortunately I'm employed by the same company as Guido, so I won't be able to escape python for a while.
20:03:06 <dmwit> The monoids package depends on the text package?
20:03:08 <diabolix> not that I don't like my job, I just don't like python.
20:03:29 <copumpkin> dmwit: probably provides instances for it?
20:04:02 * BMeph doesn't mind Python, but definitely preferred Icon to it.
20:04:15 <koninkje> last time I used it(python) it was a lot better than Java at least
20:04:15 <dmwit> Seems to.
20:04:22 <dmwit> instance Generator Text
20:04:42 * copumpkin coughs http://snapplr.com/hc8z
20:05:18 <dmwit> Aaaah, show us that backend, Google!
20:05:44 <ddarius> copumpkin is easily amused.
20:05:45 <diabolix> why would you cut a sentence short in the middle of a line... that doesn't even make sense.
20:05:49 <copumpkin> certainly
20:06:01 * copumpkin giggles
20:06:03 <dmwit> diabolix: Automated, most likely.
20:06:11 <diabolix> I know, but horribly.
20:06:49 <diabolix> cutting off text prematurely is actually a very interesting problem when you take hebrew and aramaic into account.
20:07:20 <ddarius> You know how many ems fit in the box, but you don't have the actual font metrics, so you truncate at the number of ems.
20:08:18 <diabolix> google does it in most UIs buy actually sending more text than necissary, and using CSS to truncate. that way you don't have problems in languages where characters have continuations that depend on what comes after them.
20:09:04 <ddarius> Yes, that's the thing to do unless you actually can calculate the font metrics at display time, which you usually can't outside of desktop applications.
20:12:12 <dmwit> bleh
20:12:17 <dmwit> Things aren't building.
20:12:24 <dmwit> Might as well upgrade to GHC7. =P
20:13:31 <rndm> hi. i'm a newbie. i want to map over a list but the function i want to apply depends on position in that list. what's a nice way to write that?
20:13:52 <ddarius> :t \f -> map f . zip [0..]
20:13:53 <lambdabot> forall b t b1. (Num t, Enum t) => ((t, b1) -> b) -> [b1] -> [b]
20:14:29 <rndm> now i stare and wait for that to click =)
20:14:30 <ddarius> :t \f -> zipWith f [0..]
20:14:31 <lambdabot> forall a b c. (Num a, Enum a) => (a -> b -> c) -> [b] -> [c]
20:14:50 <ddarius> Depending on whether f is curried or uncurried.
20:15:34 <ddarius> > zip [0..] "hello"
20:15:35 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
20:16:09 <dmwit> preflex: seen edwardk
20:16:09 <preflex>  edwardk was last seen on #haskell 4 days, 7 hours, 46 minutes and 22 seconds ago, saying: byorgey: byorgey: byorgey!
20:17:06 <dmwit> ?tell edwardk I relaxed the dependencies of the monoids package to allow "containers" up to 0.3.*, "array" up to 0.3.*, and "parallel" up to 2.2.*, and it seemed to build.
20:17:07 <lambdabot> Consider it noted.
20:20:13 <rndm> ddarius: so in the first case f explicitly takes a 2-tuple, and in the second f is just a bivariate function?
20:24:22 <diabolix> its gonna take me a while to get used to the fact that stuff can still execute after return ().
20:27:15 <copumpkin> return is just a function
20:27:25 <dmwit> rndm: yes
20:27:52 <rndm> dmwit: thanks.
20:28:42 <rndm> if f and g are univariate functions that can be composed what is the difference between h = f g and h = f . g ?
20:28:50 <diabolix> copumpkin: but one with a confusing name for someone who has coded c/c++ all there life.
20:28:58 <copumpkin> yeah, I don't like it
20:29:23 <dmwit> rndm: The former passes "g" as the first argument to "f"; the latter first applies "g" to an argument, then passes the result as the first argument to "f".
20:29:55 <dmwit> Compare "h = f g" and "h x = f (g x)".
20:30:05 <rndm> dmwit: thanks.
20:38:30 <amedxy> dmwit i have a some problems with the types
20:39:55 <amedxy> printx n		=	putStrLn(replicate n '*')
20:40:06 <amedxy> rectangle x y	=	iterate (printx y) x
20:40:12 <dmwit> ?hpaste
20:40:13 <lambdabot> Haskell pastebin: http://hpaste.org/
20:40:26 <dmwit> (Don't paste much more than two lines in-channel.)
20:40:34 <amedxy> ok
20:41:32 <dmwit> Also, you'll probably like
20:41:44 <dmwit> replicateM_ :: Int -> IO () -> IO ()
20:41:45 <amedxy> http://hpaste.org/46953/rectangle
20:42:00 <dmwit> Which is like replicate, but it does an action n times rather than making a list of n copies of a thing.
20:42:18 <dmwit> ?index replicateM_
20:42:18 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
20:44:52 <amedxy> for(i=1 to i=x) do {printx y}
20:45:14 <dmwit> Yes, that is the replicateM_ pattern.
20:46:09 <dmwit> > unlines $ join (.) (replicate 3) '*'
20:46:10 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
20:46:10 <lambdabot>         against inferred type...
20:46:26 <dmwit> > unlines . replicate 3 . replicate 3 $ '*'
20:46:28 <lambdabot>   "***\n***\n***\n"
20:48:36 <ClaudiusMaximus> hooray, fixed my sawtoothy heap profile, finally looks like http://claudiusmaximus.goto10.org/g/ruff/ruff-gl_cps_stref.png instead of http://claudiusmaximus.goto10.org/g/ruff/ruff-gl.png several hours ago..
20:50:22 <alexsuraci> aw, old one was prettier
20:55:34 <Volt_> ClaudiusMaximus: what did you do?
20:57:17 <ClaudiusMaximus> Volt_: made an iteration function write directly to an array and return a list of things todo instead of returning a list that i partitionEithers and then wrote one half to the array and the others todo
20:57:33 <ClaudiusMaximus> (phrased badly... it's too late/early here)
20:58:54 <ClaudiusMaximus> using an stref to count how many were written to the array instead of testing if that list was null was probably the key
20:59:54 <Volt_> Ah, I think I understand
21:02:41 <ClaudiusMaximus> http://hpaste.org/paste/46952/profiling_annotation#p46954
21:05:38 <_Ray_> Hi :) I'm trying to install haskell-platform on ubuntu via "sudo aptitude install haskell-platform". However, the package complains that "haskell-platform: Depends: ghc6 (< 6.12.1+) but 6.12.3-1ubuntu7 is to be installed." It says the way to resolve these dependencies is, well, to not install haskell-platform. What can I do to fix this?
21:08:24 <Volt_> ClaudiusMaximus: how did you pinpoint that as the problem?
21:08:36 <_Ray_> Ah, it seems to be a bug in Ubuntu at the moment. :( There's a pseudo-patch on the (still open, assigned to nobody) bug report.
21:12:30 <ClaudiusMaximus> Volt_: guesswork more than science, sadly
23:27:29 <amedxy> somebody?
23:28:52 <adnam> hey man
