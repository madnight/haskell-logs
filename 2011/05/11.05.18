00:00:14 <dankna> Veid: the short answer to that is no; the long answer is not really
00:00:32 <issactrotts> interesting: the only part of snap that won't install is the umbrella package "snap".
00:00:32 <Veid> Where else does it install to?
00:00:54 <dankna> I have mine configured to install to /usr/local/cabal/ghc-7.1.20110504/blahblahblah/
00:00:56 <issactrotts> others such as snap-server, snap-core, heist, etc. install just fine.
00:01:02 <dankna> or other directories depending on which ghc I'm using today
00:01:14 <issactrotts> going for the hail mary: cabal install snap --upgrade-dependencies --reinstall
00:01:56 <Veid> I've got ghc and the haskell platform installed via homebrew
00:01:58 <Veid> Works out nicely
00:03:19 <issactrotts> Can you post a link to homebrew? Googling it is useless
00:03:33 <Veid> https://github.com/mxcl/homebrew
00:03:36 <Veid> Much better than macports
00:04:26 <issactrotts> thanks
00:07:04 <issactrotts> ...and fail. snap-0.4.2 depends on hint-0.3.3.2 which failed to install.
00:07:44 <mjrosenb> hrmm, i seem to be failing at permuting a list in linear time in haskell.
00:09:26 <proq> Veid: what's wrong with the OS X ghc installer?
00:09:51 <Veid> I don't like how it installs into Library
00:09:52 <issactrotts> does that include snap
00:09:54 <issactrotts> ?
00:10:06 <wookydocky123> @src splitAt
00:10:06 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
00:10:14 <Veid> I'd rather have it install into my centralized location at /usr/local/cellar
00:10:55 <adrake> osfameron: here is a nice example: http://hpaste.org/46783/example_case
00:11:28 <Veid> Plus if I want to uninstall it, and everything that came with it, it's as simple as: brew uninstall ghc
00:14:05 <Veid> @src putStrLn
00:14:05 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
00:14:43 <adrake> so yeah, if anybody can come up with a clean way to write "findBranchTargets" from that example above
00:18:42 <issactrotts> I like brew so far. It doesn't have a snap pkg but i guess it will be easy to make one.
00:20:36 <ddarius> mjrosenb: id permutes a list in constant time
00:21:37 <c_wraith> that's a boring permutation
00:21:58 <issactrotts> cabal-install is a disaster for package management. I've never had it go smoothly. Hopefully brew will be better...
00:33:26 <mjrosenb> ddarius: randomly permutes, in such a way as to get all n! permutations ... eventually
00:34:52 <Jafet> next_permutation can be written in amortized constant time
00:36:13 <mjrosenb> Jafet: that seems unlikely, but not unlikely enough for me to actually call you out on it.
00:37:03 <Jafet> Increment a counter in factorial base
00:37:17 <Jafet> Hrm, maybe not
00:37:39 <Jafet> Logarithmic, then
00:39:04 <mjrosenb> however, getting the nth permutation is then going to take nlog m, and with a random permutation, is going to take log n*(n!) in the length of the list
00:39:13 <mjrosenb> which is a bit worse than n^2
00:39:54 <Jafet> So you want to apply a particular permutation; that's trivially o(n) then
00:42:08 <MaskRay> there is a O(n log n) approach to get the kth permutation
00:42:58 <MaskRay> how to implement an O(n log m) approach?
00:43:03 <mjrosenb> Jafet: how?
00:43:47 <mjrosenb> also, does anyone know how to use state random?
00:43:50 <Jafet> Or more precisely, the maximum number of slave fairy hours you need to compute that is at least O(n)
00:45:11 <Jafet> adrake's code is weird
00:46:11 <Jafet> BrainfuckUltimateEnterpriseHighMilliolegs
00:49:50 <erus`> hello = "Hello World!" -- <- is that a function or a variable?
00:49:57 <erus`> *constant variable
00:50:20 <shachaf> instance IsString (a -> b) where who knows?
00:52:13 <Jafet> It's a definition that defines hello to be the value "Hello World!", which isn't a function unless someone like shachaf is poking around in your code
00:52:36 <Jafet> A function takes one (or more?) parameters.
00:52:49 <shachaf> Jafet: Someone like http://www.samuelhughes.com/isstring/index.html , rather.
00:55:25 * mjrosenb has appeared to have made a mistake
00:55:40 <mjrosenb> permuting a list of 10,000 elements uses 2G of ram.
00:56:22 <poltak> mjrosenb: .... kinda overkill
00:56:31 <Jafet> Err, parameter.
00:56:31 * Jafet coughs
00:58:14 <mjrosenb> poltak: yeah, kinda
01:03:44 <rostayob> I've written a really simple parser with continuations: https://gist.github.com/977251 to consume bytestrings. Still, a parser written with attoparsec is slightly faster. what tricks are there to be faster?
01:03:56 <rostayob> i mean my implementation is really really simple
01:04:08 <rostayob> but it's still a little bit slower
01:07:13 <poltak> rostayob: lol
01:07:26 <rostayob> poltak: ?
01:08:38 <osfameron> adrake: hmmm.  If you look up some Haskell tutorials for creating a parse-tree/compiler, you'd often see a single "data" declaration with all the things like "BottomInsn" etc. as alternative constructors
01:08:59 <osfameron> adrake: e.g.: data Instruction = SubInsn | TopInsn | AddInsn ... etc.
01:09:09 <osfameron> adrake: I don't know if modelling it like that would help?
01:09:26 <osfameron> certainly, using typeclasses is a little more advanced (and therefore, potentially more confusing?)
01:10:22 <c_wraith> rostayob: I don't see any optimization pragmas in your code.  take a look at the attoparsec source, especially for {-# #-} pragmas
01:10:34 <issactrotts> I installed haskell-platform via homebrew, and then did cabal install snap. Worked just fine. Thanks a lot!
01:10:57 <rostayob> c_wraith: oh, right. I've tried inling functions, but it doesn't give a noticeable difference in speed
01:11:20 <Jafet> adrake: if you're doing this purely as an exercise in typeclass hacking, you might see how GHC's Control.Exception does how you want
01:12:22 <isomorphic> Hey can anybody recommend a good Haskell  web framework - I've briefly looked at Yesod, but I'm also curious about Happstack and Snap.
01:13:07 * hackagebot bindings-levmar 1.0 - Low level bindings to the C levmar (Levenberg-Marquardt) library  http://hackage.haskell.org/package/bindings-levmar-1.0 (BasVanDijk)
01:13:09 * hackagebot levmar 1.0 - An implementation of the Levenberg-Marquardt algorithm  http://hackage.haskell.org/package/levmar-1.0 (BasVanDijk)
01:13:28 <rostayob> isomorphic: I use happstack and I'm quite happy.
01:16:52 <Jafet> @hoogle (<:)
01:16:52 <lambdabot> No results found
01:17:02 <Jafet> (Good.)
01:17:44 <osfameron> this is written all wrong http://tutorial.happstack.com/tutorial/your-first-happstack
01:17:55 <osfameron> "My Goodness! That's a lot of instances!" er, yes
01:18:29 <osfameron> I don't understand the point of scaring your tutorial reader first.  That could be done after showing a "Hello World!" page, and how simple it is.
01:20:21 <rostayob> also, stupid question: when I try to compile with profiling support and then run with +RTS, I get "Most RTS options are disabled. Link with -rtsopts to enable them."
01:20:57 <Jafet> And the question is...?
01:21:17 <rostayob> Jafet: what does that mean? linking what with -rtsopts?
01:21:23 <rostayob> I mean I can't get it to work
01:21:29 <Jafet> Your program.
01:21:35 <rostayob> Jafet: i did that
01:22:19 <Jafet> Hm, I don't know then. That's a ghc7 change, I presume
01:22:33 <rostayob> i'm following the ghc 7 manual
01:22:40 <rostayob> this: http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/profiling.html
01:23:59 <zenzike> rostayob: with ghc7 you need to do ghc -rts opts to compile your program wiht +RTS functinality
01:24:46 <zenzike> ie, you do "ghc -rtsopts Foo.hs", and then you are able to do ./Foo +RTS bar
01:25:07 <rostayob> zenzike: that's how have been compiling
01:25:31 <zenzike> have you trieed forcing a recompile?
01:25:47 <rostayob> zenzike: oh wait, actually putting the argument before seems to work
01:26:10 <rostayob> I was calling it like ./foo bar +RTS...
01:26:35 <zenzike> rostayob: ah yes. the point of +RTS is that everything after is an RTS argument
01:26:41 <Jafet> RTS options are enclosed within +RTS ... -RTS.
01:26:53 <zenzike> Jafet: beat me to it :-)
01:29:16 <rostayob> ok, thanks to both (:
01:31:31 <exeter> hello haskellers, I am reading a opengl tutorial http://www.cin.ufpe.br/~haskell/hopengl/install.html and have problems with installing hopengl
01:31:45 <exeter> i typed cabal install hopengl but there was no such package
01:32:09 <exeter> so I typed cabal install opengl-2.4.0.1 and the answer was "cabal: There is no available version of opengl that satisfies ==2.4.0.1"
01:32:25 <exeter> but on the opengl site it's written winxp and beyond should come equipped with opengl
01:32:42 <exeter> so I wonder: should i cabal installa  previous version or update opengl?
01:33:38 <exeter> (or am I missing something)
01:38:39 <rostayob> exeter: I have no experience with windows at all, but that tutorial is really, really old. and haskell moves fast
01:39:12 <rostayob> what you should do is just install the haskell platform, and then cabal install opengl
01:39:40 <exeter> rostayob: I did it! Unfortunately i get cabal: There is no available version of opengl that satisfies ==2.4.0.1"
01:39:46 <exeter> when installing cabal install opengl-2.4.0.1
01:39:52 <exeter> should i just type cabal install opengl?
01:40:03 <rostayob> exeter: yes, but that's strange
01:40:06 <rostayob> try cabal update first
01:40:17 <exeter> ok
01:41:19 <exeter> "No packages to be installed. All the requested packages are already installed." I feel very (naive), rostayob :P
01:43:01 <rostayob> so you've got opengl already! be happy
01:45:13 <kosmikus> exeter: there may be a problem with case-sensitivity; the package is actually called OpenGL
02:02:51 <sanjoyd> BONUS: I love your book.
02:07:42 <o-_-o> //topic BONUS is da man
02:08:29 <poltak> Ye!
02:13:50 <Jafet> http://hpaste.org/46785/brainfuck
02:13:54 <Jafet> Seems correct enough
02:15:28 <flux> if there is a forte for functional languages with pattern matching and easy linked lists, it must be writing brainfuck interpreters :)
02:15:59 <merijn> flux: Really? Seems to me brainfuck really wants mutable cells to use as registers...
02:17:08 <Jafet> It's primarily a demonstration of knots, although I think it could be done better
02:18:15 <o-_-o> in Data.Vector.Unboxed, if I do
02:18:16 <o-_-o> let vec0 = fromList [1..10], I get a Unboxed Vector of type Double
02:18:27 <o-_-o> how do I get an unboxed vector of Int ?
02:18:47 <mjrosenb> @unpl \x -> x
02:18:47 <lambdabot> \ x -> x
02:18:56 <mjrosenb> @pl \x -> x
02:18:56 <lambdabot> id
02:19:22 <mjrosenb> @pl x >>= (\y -> return (f y))
02:19:22 <lambdabot> f `fmap` x
02:20:02 <mjrosenb> @pl x >>= (\y -> return (f y z))
02:20:03 <lambdabot> flip f z `fmap` x
02:20:19 <o-_-o> ah...figured it out
02:20:30 <o-_-o> let vec0 = fromList [1..10::int]
02:20:55 <Jafet> Weird... it defaults to Double?
02:20:57 <Axman6> o-_-o: or you can add :: Vector Int to the end of the line
02:21:07 <Jafet> I guess that makes sense for Vector
02:21:39 <o-_-o> ah...nice
02:21:47 <o-_-o> thanks Axman6
02:21:58 <Axman6> which is probably clearer
02:25:27 <o-_-o> indeed it is...
02:42:31 <MasseR> Can I create a custom directory structure with cabal? For example for building a web app
02:44:55 <mjrosenb> if i want to sort a list of strings by their length, i can use sortBy (f length)
02:44:58 <mjrosenb> what is f?
02:45:18 <Jafet> :t comparing
02:45:19 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
02:45:38 <sipa> :t sortBy . comparing length
02:45:38 <lambdabot>     Couldn't match expected type `[a] -> Ordering'
02:45:39 <lambdabot>            against inferred type `Ordering'
02:45:39 <lambdabot>     Probable cause: `comparing' is applied to too many arguments
02:45:45 <sipa> :t sortBy (comparing length)
02:45:46 <lambdabot> forall a. [[a]] -> [[a]]
02:47:13 <Jafet> Hm, no one answered that question within twenty seconds. I must have disconnected again.
02:47:32 <erus`> does anyone know how to compile resources into an executable with ghc?
02:49:07 <Jafet> (Was I right?)
02:50:16 <quicksilver> Jafet: I don't think so, no.
02:50:22 <quicksilver> Jafet: don't know which question you meant though.
02:53:27 <exeter> i am having problems with the opengl tutorial http://www.haskell.org/haskellwiki/OpenGLTutorial2#Back_to_the_callbacks
02:53:57 <exeter> the example I pasted is an animation
02:54:11 <exeter> which compiles good on my pc but... does not animate
02:54:37 <exeter>   displayCallback $= (display angle)   idleCallback $= Just (idle angle)
02:54:47 <rostayob> is there a lazy version of the Get monad?
02:55:21 <exeter> i have these two callbacks ^-- , am I missing something
02:55:31 <mjrosenb> iirc, there is something else that can be used for things other than comparing
02:56:14 <mjrosenb> wait, where is comparing defined
02:57:17 <erus`> glut is such a pain
02:57:43 <exeter> erus`: do I have any other option?
02:57:54 <erus`> sdl/anything + glut
02:57:59 <erus`> + opengl*
02:58:23 <erus`> (i just don't like the callbacks)
02:58:42 <erus`> no other game/multimedia library seems to use callbacks
02:58:58 <erus`> well for the game loop anyway
02:59:10 <ClaudiusMaximus> exeter: probably you miss "postRedisplay Nothing" in the idle callback
02:59:27 <exeter> I've commented it out ClaudiusMaximus
02:59:58 <exeter> and still no improvement ClaudiusMaximus
03:00:09 <quicksilver> exeter: paste your entire code.
03:00:16 <quicksilver> into hpaste or similar
03:00:23 <quicksilver> otherwise we're all just guessing.
03:00:29 <exeter> ( also I have written angle $=! (a + 0.1) instead of angl- ok
03:02:15 <exeter> there quicksilver & ClaudiusMaximus http://hpaste.org/46786/glut_stuff
03:04:23 <quicksilver> exeter: and wht happens? something is drawn but it doesn't animate? or nothing is drawn?
03:04:56 <exeter> something is drawn (i.e. 7 color squares), but it does not animate
03:05:13 <exeter> so I was wondering how to check that the timer actually ticks
03:05:20 <quicksilver> you miss 'swapBuffers'
03:06:20 <quicksilver> the last command in 'display' should be 'swapBuffers' not 'flush'
03:06:26 <quicksilver> that postRedisplay line needs to be *in*
03:06:32 <quicksilver> that comment is wrong (as far as I know)
03:06:43 <quicksilver> all modern opengl systems use double-buffers and you shouldn't try not to.
03:07:43 <exeter> quicksilver: I copied from the tutorial http://www.haskell.org/haskellwiki/OpenGLTutorial2#Back_to_the_callbacks
03:07:45 <quicksilver> exeter: I saw.
03:07:48 <exeter> and I am using single buffer for this
03:07:49 <quicksilver> I think the tutorial is wrong.
03:07:55 <exeter> (or better, the tutorial is using)
03:07:56 <quicksilver> don't use a single buffer.
03:08:33 <ClaudiusMaximus> exeter: callbacks are in IO, so you can print to terminal to check callbacks are firing
03:08:36 <quicksilver> put   initialDisplayMode $= [ DoubleBuffered, RGBAMode, WithDepthBuffer, Multisampling] just before createWindow
03:08:51 <quicksilver> you don't need 'multisampling' if you don't want, but you do need the others.
03:09:08 <Entroacceptor> (the tutorial talks about doublebuffering)
03:09:23 <quicksilver> I have no idea what the basis of the tutorial's advice but as far as I understand, doublebuffering is the correct default for all cards made in the last 12 years
03:09:35 <quicksilver> and I suspect quite a few card/OS combinations don't support singlebuffering at all.
03:09:47 <Entroacceptor> doublebuffering is the way to go since 1990
03:09:48 <exeter> Entroacceptor: *after* that section
03:10:28 <exeter> anyway, let's try to recompile that
03:11:07 <ezyang> What's the easiest way to convert an HP profile into a png?
03:11:59 <exeter> quicksilver: blank window (black), without animation and without squares
03:12:35 <exeter> I'm getting a bit frustrated, if there is better tutorial even on another library i am more than willing to change :S
03:14:09 <hvr> dons: any plans on updating http://hackage.haskell.org/package/loch-0.2 to work w/ GHC7? :-)
03:14:12 <quicksilver> it's a bit weird that tutorial, which is a shame
03:14:16 <quicksilver> it does lots of things strangely
03:14:25 <quicksilver> doesn't reset matrices, doesn't set up matrices in the reshape callback
03:16:47 <exeter> and the tutorial was written in 2008, not in the XX century, grrrr
03:17:37 <mjrosenb> what is the syntax for referencing an infix function in a module
03:17:45 <mjrosenb> e.g. not M.(!)
03:18:10 <zenzike> mjrosenb: use Module ( (!) )
03:18:21 <poltak> zenzike: I really like Haskell
03:18:28 <ClaudiusMaximus> ezyang: hp2pretty < foo.hp > foo.svg && rsvg foo.svg foo.png   # is what i do; misses some features of hp2ps though
03:19:41 <quicksilver> mjrosenb: M.!
03:19:49 <quicksilver> mjrosenb: and (M.!)
03:19:55 <quicksilver> > 1 Prelude.+ 2
03:19:56 <lambdabot>   3
03:19:59 <mjrosenb> yeah, finally found it.
03:21:55 <zenzike> poltak: that's good! why the message though?
03:22:04 <ezyang> cool, that works well enough.
03:23:05 <quicksilver> exeter: http://hackage.haskell.org/package/nehe-tuts should get you working code you can start from
03:23:56 <exeter> thanks quicksilver
03:24:44 <exeter> one last thing quicksilver , is SDL stable/usable with haskell?
03:39:00 <mjrosenb> :t concat . replicate 10
03:39:01 <lambdabot> forall a. [a] -> [a]
03:39:14 <mjrosenb> is there a function that does something equivalent to that?
03:39:29 <Cale> exeter: I expect reasonably so. The libraries have been around a long time at least, and while I haven't used them extensibly, the bits I have used were no worse than using SDL in C.
03:41:08 <Cale> mjrosenb: not really
03:41:13 <exeter> thanks cale
03:41:27 <Cale> ([1..10] >>) is equivalent, but that's sneaky
03:42:09 <Cale> mjrosenb: Note cycle though
03:42:15 <Cale> > cycle "abc"
03:42:15 <lambdabot>   "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcab...
03:42:43 <Axman6> > let f xs = take (10 * length xs) (cycle xs) in f "abc"
03:42:44 <lambdabot>   "abcabcabcabcabcabcabcabcabcabc"
03:43:22 <Cale> That works, but it's a bad way to do it. Only use cycle if that "10" was something you'd have to compute to line up with, say, zipping to another list.
03:43:38 <poltak> cycle "abc"
03:43:50 <poltak> The bot's being an ass
03:44:09 <Axman6> i think you mean you're not using it right =)
03:44:14 <poltak> lies
03:44:15 <Axman6> > cycle "abc"
03:44:15 <lambdabot>   "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcab...
03:44:17 <Cale> You need to prefix your input with '> ' to have the bot treat it as a command.
03:44:17 <luite> Cale: last time you said that I should add comment and definition cells to my haskell web thingie, does this look similar to what you had in mind? http://jabberwock.xs4all.nl/exp/wolfgang/
03:44:36 <poltak> >cycle "abc"
03:44:44 <poltak> > cycle "abc"
03:44:44 <lambdabot>   "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcab...
03:44:48 <poltak> yeah brudda
03:44:49 <Cale> looks excellent :)
03:45:03 <poltak> let's do something on the weekend, Cale
03:45:03 <luite> incidentally that page shows how cycle [1,2,3] looks on the heap ;)
03:46:51 <luite> Cale: it automatically highlights errors in the code while you type, but doesn't reload expressions automatically
03:47:19 <Cale> luite: Seems sensible :)
03:47:36 <Cale> I like it a lot, is it still top-secret? :)
03:48:41 <osfameron> can you use MACID with Yesod?
03:49:09 <luite> Cale: well not top secret, but it's not always online, because I'm still changing lots of things
03:49:39 <Cale> It evaluates server-side, yeah?
03:50:07 <luite> Cale: and I need to think a bit more about security now that users can load code. Template haskell and quasiquoting ar disabled, and the source is checked first (parsed with haskell-src-exts, and imports + pragma's matched agianst a whitelist)
03:51:02 <mjrosenb> Cale: yeah, concat . replicat x seems easier.
03:51:14 <Cale> Now all we need is to compile GHC with a javascript backend and have in-browser GHC :)
03:51:17 <luite> yes, I've been thinking about doing it client side, by using a javascript backend for ghc or something, but that would make it impossible to use most of the packages from hackage
03:51:51 <luite> there is a javascript backend, but it's experimental and quite limited
03:52:27 <Cale> Yeah, I would expect compiling GHC itself with the javascript backend to be pretty hard :)
03:53:16 <luite> hehe, yes, although, there's an x86 emulator in javascript, that can run linux. so you might just use that and the native ghc. best of both worlds ;)
03:53:37 <Cale> Yeah, that would be pretty epic
03:54:15 <Cale> That's almost reasonable
03:54:35 <Cale> I wonder if we can get GHC running inside that thing :)
03:56:55 <Botje> alternatively, compile to C and run it with emscripten / syntensity
03:57:36 <Cale> unfortunately, the C backend doesn't really compile *to* C
03:57:52 <luite> I hope to have a showcase of worksheets in categories, where they could be used to explain haskell concepts, or as interactive illustrations for other fields, but I still need to work out how to actually store the documents
03:57:56 <Cale> It compiles via GCC, and mangles the assembly output.
03:58:11 <luite> the easiest is te hpaste model, with a save button that gives you a permanent url
03:58:28 <luite> but then you cannot edit the page without changing the url
03:58:34 <Botje> I think emscripten can also work from llvm bitcode, but not sure
03:59:09 <luite> hmm I would like to have some more client-side evaluation, but I think that server-side will still be required for some things
03:59:20 <luite> for example, I think vacuum uses dot to layout the graph
04:04:10 <dcoutts> MasseR: no, cabal does not do deployment really. You can make a script yourself that does it. When you configure a package you can control the libdir, bindir etc etc
04:05:21 <dcoutts> MasseR: and the cabal copy --destdir=./blah/ will help
04:07:51 <luite> Botje: hmm, emscripten does look interesting, but I guess it would be difficult to get haskell running on that
04:12:55 * hackagebot mpppc 0.1.1 - Multi-dimensional parametric pretty-printer with color  http://hackage.haskell.org/package/mpppc-0.1.1 (DarinMorrison)
04:21:21 <karlos_> test
04:24:43 <cinch> haskell is the best thing since sliced bread
04:26:16 <cinch> i like it, because pure functions are inherently more modular
04:28:20 <cinch> which other languages are pureley functional?
04:28:46 <karlos_> racket
04:28:58 <karlos_> clojure
04:29:05 <osfameron> is racket a language or a framework?
04:29:13 <karlos_> language
04:29:18 <cinch> hmm are you sure those enforce purity?
04:29:18 <Kaidelong> clojure is purely functional?
04:29:28 <Kaidelong> isn't racket just scheme?
04:29:35 <karlos_> yeah
04:29:38 <Kaidelong> mercury and clean are pure
04:29:48 <Kaidelong> purity is a bit uncommon
04:29:59 <Kaidelong> applicative common lisp is pure
04:30:07 <cinch> in clojure you can modify "global" variables
04:30:42 <Kaidelong> it's also total
04:30:57 <Kaidelong> coq, agda, and epigram are pure and total
04:30:58 * hackagebot mpppc 0.1.2 - Multi-dimensional parametric pretty-printer with color  http://hackage.haskell.org/package/mpppc-0.1.2 (DarinMorrison)
04:31:06 <osfameron> I thought schemes were pure, in general?
04:31:16 <cinch> Kaidelong: whats total?
04:31:16 <Kaidelong> osfameron: ??? No?
04:31:19 <osfameron> Kaidelong: what do you mean by "total"?
04:31:35 <Kaidelong> osfameron: functions are fully defined over their domains
04:31:43 <mjrosenb> in general, total means that all functions terminate
04:31:43 <osfameron> ah
04:32:01 <osfameron> now *that*'s a real hair-shirt..
04:32:02 <Kaidelong> mjrosenb: terminate sensibly, as opposed to an exception or something
04:32:32 <cinch> oh so haskell isnt total
04:32:40 <osfameron> so, is racket a good scheme to start with?
04:32:50 <hpc> doesn't total just mean a function has finite output for every finite input?
04:32:53 <mjrosenb> Kaidelong: yeah.
04:33:26 <hpc> you can't easily discuss "termination" of an infinite list
04:33:35 <cinch> osfameron: racket is kinda advanced, i'd start with R5 scheme
04:33:38 <mjrosenb> hpc: if you are a lazy function, then you can output an infinite list
04:33:48 <Kaidelong> hpc is right
04:34:00 <Kaidelong> it is not right to say that everything in a total language terminates
04:34:20 <Kaidelong> operating systems, games, and such, could be played forever, potentially
04:34:27 <osfameron> cinch: heh. googling R5 scheme givces my R6...
04:34:55 <cinch> osfameron: R5RS i mean, its the standard the most schemes implement
04:35:03 <Kaidelong> Pretty sure no scheme at this point is pure
04:35:03 <mux> also, unless I'm missing something, a total language only guarantees that your function is well defined for any possible input, but that doesn't preclude having general recursion and potentially, infinite loops
04:35:18 * osfameron adds scheme to his list of languages-to-learn (which is currently: haskell, javascript (properly), C, and... oh actually, probably a lisp variant like Clojure anyway)
04:35:32 <flux> mux, hm, if you have infinite loops for some values, is it really defined for those inputs?
04:35:40 <Kaidelong> mux: why shouldn't it? if it doesn't terminate for some terminating input, why would you consider it "defined"?
04:35:49 <hpc> osfameron: you aren't going to enjoy javascript
04:36:00 <Botje> why not?
04:36:03 <hpc> it's too quirky for my tastes, at least
04:36:05 <Botje> it's scheme with C syntax
04:36:10 <osfameron> hpc: oh, I like javascript already.
04:36:16 <osfameron> but I don't get the prototyped OO
04:36:21 <osfameron> so I'd like to learn it better
04:36:27 * osfameron writes really bad javascript tbh
04:36:37 <mux> flux: the legitimacy of using "well defined" in that case is indeed arguably wrong, but what I mean to say is that totality of a language doesn't imply termination, at all
04:36:52 <mux> as far as I know anyway
04:36:59 <mjrosenb> Kaidelong: isn't the point of total functions that they map every input to an output, so if they don't terminate, they *can't* be total?
04:37:06 <osfameron> if someone sticks a better language in *every browser that exists* I'll happily use that.  But Javascript will do till then ;-)
04:37:25 <flux> there was this ml-like tota language around. what was it called?
04:37:36 <Kaidelong> mjrosenb: I agree
04:37:53 <mjrosenb> osfameron: i use browsers that don't have javascript.
04:37:59 * hackagebot pisigma 0.2.1 - A dependently typed core language  http://hackage.haskell.org/package/pisigma-0.2.1 (DarinMorrison)
04:38:08 <Kaidelong> anyway
04:38:21 <Kaidelong> pure languages in the vein of haskell are mostly rare/obscure
04:38:23 <Kaidelong> oh
04:38:28 <Kaidelong> Curry is another pure language
04:38:33 <cinch> Kaidelong: i've heard good things about Mercury
04:39:01 <osfameron> mjrosenb: I'll make a note to not try to sell you any RIA ;-)
04:39:05 <flux> clean apparently is nice, but commercial
04:39:08 <mux> I think people are confusing totality as in "you cannot write functions such as head or fromJust" and other features such as enforcing you can only recurse on structurally smaller arguments (as in agda)
04:39:53 <mjrosenb> mux: but they are the same thing; functions that return a value for every possible input.
04:40:03 <mux> but as far as I know a total language doesn't necessarily enforce any kind of recursion and thus cannot guarantee termination
04:40:40 <mux> mrdomino: I think they aren't, I highly dislike how CS puts inifinite loops and functions calling error in the same bag (bottom)
04:40:50 <hpc> wait, is \x -> fix (x:) a total function?
04:41:01 <mux> I think it is
04:41:10 <Kaidelong> hpc: it's co-recursive
04:41:12 <mjrosenb> well the definition of a total function is something that returns a value for every input
04:41:22 <mjrosenb> no matter how you break that rule, you are breaking it.
04:41:30 <hpc> Kaidelong: so not total?
04:41:44 <Kaidelong> co-recursion is fine I think
04:41:48 <mjrosenb> what on earth does co-recursive mean?
04:41:48 <Kaidelong> but if you tried to fold over it
04:42:12 <Kaidelong> mjrosenb: basically where you describe a data structure recursively
04:42:44 <Kaidelong> well it's not actually a data structure
04:42:45 <quicksilver> mux: you are wrong. Total languages cannot contain general recursion.
04:42:54 <Kaidelong> structural recursion on it won't neccessarily terminate
04:43:00 <quicksilver> at least, that's the accepted definition IME.
04:43:03 <Kaidelong> I think that distinction was the important one
04:43:17 <Kaidelong> fix . (:) makes codata, not data
04:43:19 <mux> quicksilver: do you have links handy?
04:43:58 <quicksilver> mux: http://scholar.google.co.uk/scholar?cluster=7988962173271339683&hl=en&as_sdt=0,5 is good
04:44:05 <mux> quicksilver: thank you
04:44:28 <mjrosenb> so codata is just data that has been defined in terms of itself?
04:44:52 <quicksilver> mjrosenb: no, plain data can be recursive too
04:45:13 <quicksilver> the standard "list" type can be considered a data type - but if considered that way, infintie lists don't exist.
04:45:28 <quicksilver> using this meaning of the words, haskell doesn't have "data" types, only codata.
04:45:47 <quicksilver> all haskell recursive types have greatest-fixed-point semantics - that is, codata semantics.
04:46:08 <Kaidelong> I thought haskell, exactly by not being total, doesn't need a distinction
04:46:37 <magicman> What would least-fixed-point semantics of the list definition look like? Is this question actually meaningful?
04:46:43 <Kaidelong> so you can reason about haskell "co-data" like it is "data" and vice versa
04:47:44 <mjrosenb> so co-data is what would normally be called infinite-structures
04:47:52 <dblhelix> quicksilver: in haskell, gfps and lfps coincide: types have both initial-algebra and final-coalgebra semantics
04:47:56 <mjrosenb> or is there some other distinction having to do with laziness?
04:48:02 * Kaidelong doesn't remember if co-data was neccessarily infinite
04:48:19 <opqdonut_> harper said he doesn't like teaching in Haskell because Haskell doesn't have data
04:48:37 <opqdonut_> he also has some related musings about the semantics of laziness in his blog
04:48:49 <mjrosenb> opqdonut_: you at CMU?
04:48:49 <opqdonut_> ( http://existentialtype.wordpress.com/ )
04:48:50 <Kaidelong> harper missed the point that it doesn't matter and that impurity is the worse thing to swallow
04:49:03 <opqdonut_> mjrosenb: I merely read his blog
04:49:09 <quicksilver> magicman: as it does in a strict langauge like an ML
04:49:11 <opqdonut_> Kaidelong: I agree
04:49:11 <mjrosenb> opqdonut_: ahh.
04:49:22 <quicksilver> magicman: so, all finite lists are in the semantics, but infinite ones are not.
04:49:24 <opqdonut_> Kaidelong: but some nice food for thought in his blog anyway
04:49:29 <Kaidelong> sure
04:49:32 <quicksilver> magicman: lists in most programming languages are probably like this.
04:49:56 <opqdonut_> in haskell one can try something like "
04:49:59 <opqdonut_> gah
04:50:11 <opqdonut_> "data List a = Nil | Cons !a !List"
04:51:06 <magicman> quicksilver: I understand. Sadly, it didn't help me understand the data VS codata as much as I had hoped it would. Thanks, though :)
04:51:58 <Kaidelong> I don't claim to really understand it
04:52:14 <luite> http://jabberwock.xs4all.nl/exp/wolfgang/ <- properly working Diagrams tutorial now here (click on button to load it at the top) (the SVG backend for diagrams has some issues, so it uses PNG now)
04:52:14 <Kaidelong> the main thing I get from it is that you can't use induction to prove properties about codata
04:52:26 <quicksilver> dblhelix: I don't understand that. Surely the set "all finite lists" is a fixed point of the operations [] and (:) whatever language you're in? Fixed points like this are - or can be thought of as - syntactic operations.
04:54:06 <Kaidelong> strictness also causes proof related problems of its own IIRC
04:54:08 <magicman> Kaidelong: Right. Because there's doesn't necessarily have to be a base case at the end of the induction ([] for lists, for example).
04:54:44 <luite> hmm, it looks like it gives an error some times, I'll check that later
04:54:44 <Kaidelong> fst(x,_|_) should be x, not _|_
04:55:08 <Kaidelong> if you want to be able to say something like "fst(x,y) = x"
04:55:49 <luite> a apparently it breaks if you click the "Load diagrams tutorial" button twice
04:55:52 <quicksilver> Kaidelong: unless you change your quantifiers.
04:56:12 <quicksilver> Kaidelong: "forall 'valid values y' . fst (x,y) = x"
04:56:24 <quicksilver> Kaidelong: where 'valid values' excludes non-terminating programs or whatever.
04:56:33 <quicksilver> I think when proving stuff in strict languages you routinely do that.
04:58:32 <Kaidelong> quicksilver: but since they tend to be impure, you end up with the problem of y being able to change x
04:58:54 <Kaidelong> like if x is a mutable reference
04:58:54 <quicksilver> Kaidelong: also true.
04:59:03 <quicksilver> Kaidelong: also y may actually *be* x
04:59:06 <quicksilver> aliasing is great
04:59:12 <quicksilver> (not that it affects that precise property)
05:00:22 <dblhelix> quicksilver: have a look at algebraically compact functors if you're into that stuff (for example: http://boole.stanford.edu/pub/barr/algcomp.ps)
05:00:46 <magicman> Pft. When purity is gone, away go (almost all) nice properties.
05:03:26 <hpc> luite: the "close window" hover thingy likes to stick around after the window is closed
05:03:40 <hpc> luite: when you close things at the bottom it leaves the scroll area very large
05:04:21 <luite> firefox?
05:04:34 <hpc> sec, lemme get a picture
05:05:04 <Jafet> Bah, "tying the knot" describes what happens to your head when you try to do it properly.
05:05:08 <luite> I think I can reproduce it
05:05:18 <luite> not sure about the scroll area part :)
05:05:24 <hpc> luite: http://dl.dropbox.com/u/37707/Untitled.png
05:05:42 <hpc> it seems to fix itself at random
05:06:11 <luite> hpc: right, it probably closes when you mouseover some element that it has a handler for
05:06:33 <luite> I use a library for that, which was still beta when I installed it, so I'll update that first
05:06:45 <hpc> groovy
05:10:48 <luite> arhg this is annoying, isn't it possible to have firefox 3 and 4 installed side by side?
05:11:00 <luite> by the way, is your firefox 3 or 4?
05:11:09 <hpc> 4
05:11:27 <hpc> i assume the problem exists for ff3 too
05:11:45 <luite> probably, but I can't seem to reproduce the problem with the scroll area
05:12:18 <luite> ah
05:12:22 <luite> succeeded
05:12:31 <luite> was indeed caused by a lingering tooltip at the bottom
05:15:10 <kstt> jaspervdj: hi, we are in the process of porting our Hakyl 2.4 blog to hakyll 3.1 (blog.demotera.com). The documentation is still quiet terse, could I read some code samples showing how to use tags and rss with hakyll 3 ?
05:16:02 <kstt> This time, I serously plan to have a clean codebase for this blog, and to publish it somewhere :)
05:17:29 <marcot> What's the recommended way to convert from Word8 to Word64?
05:17:36 <hpc> fromIntegral?
05:17:42 <hpc> :t fromIntegral
05:17:43 <lambdabot> forall a b. (Integral a, Num b) => a -> b
05:17:49 <hpc> @src fromIntegral
05:17:49 <lambdabot> fromIntegral = fromInteger . toInteger
05:18:03 <marcot> hpc: Ok, thanks.  I thought there could be a "faster" way, but I will use it.
05:18:05 <hpc> (that could be very slow)
05:18:10 <Jafet> unsafeCoerce is faster
05:18:26 <hpc> Jafet: oh, that's actually safe? :D
05:18:30 <marcot> will unsafeCoerce work correctly in this case?
05:18:33 <Jafet> Oh, he wanted safe?
05:18:46 <hpc> @src Word8
05:18:46 <lambdabot> Source not found. The more you drive -- the dumber you get.
05:18:51 <FUZxxl> marcot: Try it out.
05:18:53 <jaspervdj> kstt: There's some examples in https://github.com/jaspervdj/hakyll/tree/master/examples
05:19:00 <hpc> @hoogle Word8
05:19:00 <lambdabot> Data.Word data Word8
05:19:00 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
05:19:10 <Jafet> I would tend to assume that unsafeCoerce is not safe.
05:19:14 <kstt> thank you jaspervdj
05:19:27 <hpc> ghci> unsafeCoerce (6 :: Word8) :: Word64
05:19:27 <hpc> 38977841823481862
05:19:37 <marcot> Well, I'll use fromIntegral first, then try unsafeCoerce.
05:19:41 <hpc> ghci> unsafeCoerce (6 :: Word64) :: Word8
05:19:41 <hpc> 6
05:20:13 <Jafet> marcot: before making assumptions about speed, whatever that is, you might want to examine the core.
05:20:18 <hpc> it looks like you can convert from word8 to word16 and word32
05:20:23 <hpc> but not from 8 to 64
05:20:31 <hpc> and you can convert from anything down to anything else
05:20:39 <marcot> Jafet: ok, thanks for the tip, I'll inspect it.
05:20:41 <Jafet> hpc: only by accident
05:20:54 <hpc> my guess would be that the < 32 words are all stored in 4 bytes
05:20:55 <marcot> hpc: What I want in my case is actually from 8 to 64
05:20:56 <ezyang> Hot off the press! http://blog.ezyang.com/2011/05/anatomy-of-a-thunk-leak/
05:21:01 <Jafet> On a big-endian 32-bit ghc, you're liable to get 0 instead
05:21:32 <hpc> i don't have ghc on my 64-bit windows so i can't test what it does there
05:24:31 <marcot> > unsafeCoerce (6 :: Word64) :: Word8
05:24:31 <lambdabot>   Not in scope: `unsafeCoerce'
05:25:35 <frerich2> "The great idea of constructive type theory is that there is no distinction between programs and proofs: the code embodies the reasoning the justifies it, and the reasoning is just a form of code.  This is [..] sometimes grandly called the “Curry-Howard isomorphism”, the small problem being that neither Curry nor Howard invented it, nor is it an isomorphism."
05:25:37 * frerich2 snickers
05:26:43 <Jafet> Sort of like the Holy Roman Emperor, then.
05:28:57 <jaspervdj> ezyang: cool
05:29:06 <hpc> Jafet: :D i am not the only one bothered by that
05:29:11 <jaspervdj> ezyang: I'm definitely a fan of your series
05:33:34 <ezyang> jaspervdj: Cool! Let me know if there are any unclear bits.
05:34:01 <zenzike> is there a means of parsing a simple date string into a UTCTime? eg "2011-05-11"?
05:34:22 <zenzike> (the read instance requires the time of the day, which is a bit of a pain ..)
05:35:05 <exeter> I am having problems installing SDL.  "* Missing (or bad) header file: SDL.h * Missing C library: SDL " <-- how can I check if SDL is installed properly on my system
05:35:10 <exeter> +?
05:35:30 <pastorn> exeter: what OS are you running?
05:35:41 <exeter> pastorn: win7
05:36:02 <pastorn> exeter: http://www.libsdl.org/ <-- download & install
05:36:10 <pastorn> i think the haskell bindings use version 1.2
05:36:51 <jaspervdj> zenzike: https://github.com/jaspervdj/hakyll/blob/master/src/Hakyll/Web/Page/Metadata.hs#L139
05:37:10 <exeter> pastron, I have downloaded and installed (i.e. pasting stuff into mingw folder and in windows/system32). Still I get this quizzical error
05:38:10 <pastorn> @paster
05:38:10 <lambdabot> Haskell pastebin: http://hpaste.org/
05:38:15 <pastorn> exeter: ^^^
05:39:20 <exeter> pastorn: http://hpaste.org/46791/exe
05:40:55 <Jafet> Heh, I didn't even put eof into the interpreter when it finished executing the program and exited
05:41:12 <Jafet> Maybe I should rnf getContents
05:44:32 <pastorn> exeter: did you read the docs for haskell sdl for installation?
05:44:56 <Jafet> On the other hand, ghci takes forever to run it...
05:45:11 <exeter> pastorn: no :| Where to find them?
05:45:14 <ezyang> Anyone implemented a function that assigns colors to strings?
05:46:39 <Jafet> ezyang: er... const Blue?
05:46:43 <Jafet> What do you mean?
05:46:52 <flazz> haskell-src-exts-1.10.2 failed to install (as a dep via cabal install) on ghc 7.0.2 (linux). how do i diagnose what is wrong?
05:47:09 <ezyang> As in, I have a bunch of data that I'll be graphing, and I'd like "f" to be the same color across all graphs, without actually having to hard-code colors.
05:47:13 <ben> Like those irc clients that give different colors to different nicknames?
05:47:28 <ezyang> yeah. Except that I don't get to see all my data at once.
05:47:35 <ezyang> so it needs to be consistent across runs.
05:47:37 <Ferdirand> computer-assisted synesthesia
05:47:41 <ben> hm
05:47:43 <ezyang> precisely.
05:47:56 <ezyang> One simple thing to do is hash the string, convert it into a color code, and use that.
05:48:08 <ezyang> but I don't know if I'll get a particularly good distribution that way.
05:48:53 <Ferdirand> the mapping from hash to color code would probably need to be carefully constructed
05:49:09 <Ferdirand> or not
05:49:52 <quicksilver> hash the string and reduce modulo some relatively small number
05:50:17 <Jafet> Since names don't go away like nicks do, you could assign them incrementally and avoid conflicts
05:50:23 <quicksilver> and index into a list of predetermined colours
05:50:32 <quicksilver> finite size therefore you will get clashes.
05:50:42 <quicksilver> but, at least you get a good distribution.
05:50:57 <ezyang> Mmhmm.
05:51:03 <exeter> pastorn: can you please point me at those docs?
05:51:26 <Ferdirand> how fast do you need it to be ? maybe it makes sense to look at the correlation of usage across different symbols
05:51:49 <Ferdirand> so that you can at least put some effort into maximizing contrast across strongly correlated names
05:52:14 <ezyang> While we're on the subject of graph design, I'm not really sure what I'm supposed to do if one graph goes up to 80M and the other only up to 1.2k. How do you compare them while giving reasonable resolution to the 1.2k one but still showing the 10000 magnitude difference...
05:52:31 <Ferdirand> log scale ?
05:52:31 <ezyang> I'm thinking maybe I'll just special case a few names I care about.
05:52:43 <ezyang> log scale is pretty misleading if you don't know how to read it...
05:53:00 <ezyang> also it doesn't really work for this kind of graph: http://blog.ezyang.com/img/thunk-leak/strict-tick-opt.png
05:53:26 <pastorn> exeter: go to the sdl hackage page, download the .tar.gz and look there
05:53:31 <Jafet> I don't see why not, ezyang.
05:53:39 <Zao> pastorn: cabal unpack ?
05:53:46 <Jafet> Wait, did you make all those graphs yourself? That's nice.
05:53:58 <ezyang> If you add log x + log y, you get log xy
05:54:05 <ezyang> Jafet: Nah, hp2pretty made them for me.
05:54:43 <mux> funny how nearly everytime I had a space leak in haskell code, it was due to me using tuples
05:55:01 <ion> I opened that link not paying attention to the channel, then looked at the image some time later. From the first look i thought it came from ##crawl since TSO is a god in Dungeon Crawl and you get MUTations. :-P
05:55:33 <Ferdirand> how can you care both about visually representing the sum of two items and keeping the graph clear when one is very large wrt the other ?
05:55:56 <ezyang> :-(
05:56:15 <Jafet> You could rasterize a very large graph, and be done with it...
05:56:17 <ezyang> There is another constraint, which is that I want these heap profiles to look like what other people will see when they heap profile their code.
05:56:18 <zenzike> jaspervdj: thanks very much :-)
05:56:29 <ezyang> Not very web friendly...
05:56:40 <Jafet> ion: not to mention all the FUN
05:57:09 <Jafet> ezyang: well, that's the only option if you want to preserve sums.
05:57:17 <Jafet> Short of showing two graphs.
05:57:42 <ezyang> yeah.
05:58:02 <ezyang> maybe the answer here is just to emphasize the scale on the graph.
05:58:12 <pastorn> Zao: BAH
05:58:17 <Jafet> I don't think people will be confused if you show the same data on two scales.
05:58:18 <pastorn> Zao: who has the time?
05:58:29 <Jafet> Just emphasize what each graph is meant to show.
05:59:38 <fizruk> > class C a
05:59:39 <lambdabot>   <no location info>: parse error on input `class'
06:02:38 <ClaudiusMaximus> ezyang: hp2pretty has many missing features so far - if you add them, would be good to make it somewhat compatible with hp2ps - i'm the maintainer but not much time for all my many projects...
06:02:55 <ezyang> Nah, I just hacked around some of the numeric constants in the code :-)
06:03:39 <dmwit> ezyang: At least for that graph, it seems like you could take a 0.05-second slice out of the middle where nothing is changing and make a different kind of graph.
06:04:11 <ezyang> No, that's right.
06:04:17 <dmwit> Then you *would* be able to do a log-scale.
06:05:07 <ezyang> Though, it occurs to me, if I slice up the graphs too much, they won't help people interpret the default graphs hp2ps spits out.
06:05:18 <ezyang> (since that's not what you're going to see...)
06:05:25 * dmwit nods
06:05:36 <dmwit> There are always conflicting goals. =/
06:05:51 <dmwit> All the most interesting questions have them.
06:05:51 <ezyang> perhaps this is a case of "we should make hp2ps's output better" :-)
06:05:59 <ezyang> yep
06:06:04 <LeCamarade> checking for path to top of build tree... utils/ghc-pwd/dist/build/tmp/ghc-pwd: /lib/libc.so.6: version `GLIBC_2.9' not found (required by utils/ghc-pwd/dist/build/tmp/ghc-pwd)
06:06:18 <LeCamarade> On running ./configure for GHC 7.0.x. What fe do?
06:06:51 <exeter> ok, I'm editing a SDL.cabal file
06:06:53 <LeCamarade> I have this core app of my company’s that I last compiled on 6.10, but created on 6.4 (!), and I want to move it to 7.0, because it is desperate for Unicode.
06:07:00 <pastorn> exeter: is that wise?
06:07:13 <exeter> I whish to add "C:\Program Files (x86)\MinGW\include\SDL" in the Include-Dirs: , but cabal does not like spaces, what to do?
06:07:25 <LeCamarade> Before, I hesitated to mess with the code, because I thought, since ≥6.12 would fix Unicode, I could just recompile.
06:07:42 <dcoutts> exeter: you can use Haskell String syntax
06:07:46 <exeter> pastron, new info, but still didn't manage to work. I hope me switching to archlinux will get me in a better position
06:07:49 <LeCamarade> But getting ≥ 6.12 to run on my computer is in itself a task for an army. Hence why I am here, O friends.
06:07:59 <exeter> dcoutts: as in ?
06:08:26 <dcoutts> exeter: as in " and the usual Haskell escape character syntax.
06:08:27 <exeter> now I have =   Include-Dirs: "C:\Program Files (x86)\MinGW\include\SDL"                 "C:\Program Files (x86)\MinGW\lib"
06:08:45 <dcoutts> exeter: '\' is the escape character in Haskell string syntax
06:09:16 <dcoutts> > "C:\Pr"
06:09:16 <lambdabot>   <no location info>:
06:09:17 <lambdabot>      lexical error in string/character literal at chara...
06:09:18 <exeter> thanks dcoutts , but would my pasted include.dirs work? because it doesn't
06:09:21 <dcoutts> > "C:\\Pr"
06:09:22 <lambdabot>   "C:\\Pr"
06:09:27 <exeter> doh
06:09:29 <exeter> thanks
06:09:36 <Jafet> > text "C:\\Winblowz"
06:09:37 <lambdabot>   C:\Winblowz
06:09:37 <dmwit> LeCamarade: I suppose you've already tried to install glibc 2.9...?
06:09:55 <LeCamarade> dmwit: Trying … failing.
06:10:15 <exeter> * Missing C libraries: SDL.dll, SDLmain This problem can usually be solved by installing the system packages that provide these libraries (you may need the "-dev" versions). If the libraries are already installed but in a non-standard location then you can use the flags --extra-include-dirs= and --extra-lib-dirs= to specify where they are.
06:10:24 <exeter> I hate myself today. How can I check if SDL is installed?
06:10:32 <exeter> I've got all includes and header in mingw folder!!!!
06:10:58 <Jafet> You also need to specify the library to link: SDL.dll.
06:11:15 <exeter>   Extra-Libraries: SDL.dll SDLmain <- like so, Jafet ?
06:11:32 <dcoutts> the .dll suffix is not needed I think
06:11:42 <dcoutts> but the library dirs is important
06:24:01 <exeter> and that's were the problem was!
06:24:20 <exeter> minGW is on a "wrong" directory
06:24:44 <exeter> where do I find the cabal config file to change that?
06:30:28 <ClaudiusMaximus> ezyang: i might have some time to hack on hp2pretty today, actually - what would you think about usage like: hp2pretty foo.hp bar.hp quux.hp # generates foo.svg bar.svg quux.svg with comparable colours (based on hashed names) ; with a command line flag to fit all the graphs into the same scale (either time or memory or both)
06:31:01 <ezyang> That would be pretty useful, actually.
06:32:54 <ClaudiusMaximus> ezyang: cool.  if you have a nice short but meaningful name for the flags, all i can think of is --uniform-scale none|time|memory|both  which is a bit clumsy
06:35:21 <LeCamarade> Man, I cannot build glibc either.
06:35:26 * ezyang can't think of anyting better. 
06:36:04 <LeCamarade> See, the problem is that if I go with Platform, it will ask for cabal-install ≥0.8, and I have failed to install it. If I run it myself … I’ve _still_ failed to install. :'(
06:36:11 <LeCamarade> I am going to sit here and cry.
06:37:00 <LeCamarade> lambdabot: putStrLn "Help LeCamarade. :o("
06:37:15 <LeCamarade> > "Aide-moi."
06:37:16 <lambdabot>   "Aide-moi."
06:37:50 <nihtml> pas la peine de lui faire parler français, son cœur est à l'anglais, LeCamarade ;)
06:38:58 <LeCamarade> nihtml: L’anglais australien. :o)
06:53:17 <Saizan> i thought the haskell platform included cabal-install
06:53:28 * hackagebot redis 0.11 - A driver for Redis key-value database  http://hackage.haskell.org/package/redis-0.11 (AlexanderBogdanov)
06:54:08 <byorgey> Saizan: it does
07:06:30 * hackagebot diagrams-cairo 0.1.1 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-0.1.1 (BrentYorgey)
07:07:12 <spirit> i want to check two lists for (in)equality and i'd like to tell haskell that order doesn't matter, i.e. i want [1,2,3] == [3,2,1] to evaluate to true (by default it's false). how would i go about this?
07:07:23 <rostayob> spirit: you use a set, not a list
07:11:34 <Saizan> (==) `on` sort
07:13:00 <spirit> in what order to i write it? [1,2,3] ... `on` sort ... [3,2,1] ?
07:13:42 <ion> :t (==) `on` sort
07:13:42 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Bool
07:14:14 <Saizan> > ((==) `on` sort) [1,2,3] [3,2,1]
07:14:15 <lambdabot>   True
07:14:23 <Axman6> > let (===) = (==) `on` sort in [1,2,3] === [3,2,1]
07:14:24 <lambdabot>   True
07:14:39 <spirit> cool :-)
07:14:59 <ion> > ((==) `on` Set.fromList) [1,2,3] [3,2,1]
07:14:59 <lambdabot>   Not in scope: `Set.fromList'
07:15:14 <ion> > ((==) `on` Data.Set.fromList) [1,2,3] [3,2,1]
07:15:15 <lambdabot>   Not in scope: `Data.Set.fromList'
07:15:49 <djahandarie> > ((==) `on` S.fromList) [1,2,3] [3,2,1]
07:15:50 <lambdabot>   True
07:16:02 <djahandarie> Don't ask me why it's imported like that
07:16:15 <spirit> i get out of scope too, for `on` and sort
07:16:28 <ion> (Of course, not much more useful than sort if you convert from list to set all the time instead of just using sets in the first place.)
07:16:32 <djahandarie> spirit, import Data.Function   import Data.List
07:16:44 <frerich2> Maybe I'm spoiled by JavaScript but '===' looks to be "less tolerant" than '==' to me. Maybe call it 'equivTo' so you can say '[1,2,3] `equivTo` [3,2,1]'
07:16:57 <merijn> spirit: Also, if you can't find where to import functions from, Hoogle is your friend :)
07:17:05 <djahandarie> frerich2, I think he just wanted to show that you can do it infix.
07:18:49 <merijn> > let (≈) = (==) `on` sort in [1,2,3] ≈ [3,2,1] -- Pfft, we didn't invent unicode for nothing!
07:18:50 <lambdabot>   True
07:19:21 <djahandarie> Yes, we only invented it for making programming a pain. :)
07:19:50 <frerich2> merijn: hihi :-)
07:19:57 <merijn> djahandarie: Yeah, I always wonder how people write out unicode math in here. I haven't found a convenient way to type lambda/forall/exists/etc yet :\
07:20:09 <opqdonut_> tex-input-mode for emacs
07:20:16 <opqdonut_> type \forall and it turns into a forall symbol
07:20:40 <djahandarie> merijn, you just did type them ;)
07:20:43 <merijn> I usually google and copy...I wish OSX supposrted (La)TeX for inputting unicode symbols
07:20:47 <opqdonut_> (M-x set-input-method TeX)
07:20:59 <ion> The LaTeX input method for ibus
07:21:03 <merijn> djahandarie: By Googling for "unicode math" and copying ;p
07:21:22 <merijn> opqdonut_: But I'm a vim heathen, so I don't use emacs :<
07:21:24 <djahandarie> merijn, I mean when you wrote 'forall'. That's good enough for me, don't need no damn symbol. :)
07:21:51 <merijn> djahandarie: But then I'll be stuck coding in ASCII for the rest of my life!!
07:22:00 <ion> merijn: Se LaTeX input method for ibus. ;-)
07:22:04 <ion> The
07:22:35 <frerich2> Hm, is there some guideline which forbids that Data.Ord depends on Data.Function? Just noticed that Data.Ord.comparing is not defined using Data.Function.on
07:23:45 <merijn> ion: Hmm, have to check out how well that works on OSX...
07:24:11 <quicksilver> frerich2: hysterical raisins.
07:24:17 <Botje> comparing is in Data.Ord now?
07:24:54 <frerich2> quicksilver: Err... sorry, I failed to look up what that means :-}
07:25:16 <quicksilver> frerich2: comparing came first, before there was on.
07:25:19 <merijn> frerich2: It's a spoonerism of "historical reasons"
07:25:38 <quicksilver> frerich2: and nobody took the time or saw the point to update its definition
07:25:42 <quicksilver> now that 'on' exists.
07:25:56 <quicksilver> merijn: more of a malapropism I suppose
07:25:58 <merijn> Don't break what ain't fix or something :p
07:26:24 <frerich2> quicksilver: Oh okay, well I don't see a point either (there are lots of cases like that [like notElem]). Just made me wonder whether there is some dependency hierarchy among the standard modules.
07:26:50 <merijn> frerich2: I think there is, it just chronological rather then logical ;)
07:27:09 <quicksilver> yeah, there's something of a dependency hierarchy but it's chronological and a bit arbitrary
07:27:30 <quicksilver> to the extent that the standard modules are in separate packages there is some effort to not depend needlessly on other packages
07:29:33 <LeCamarade> Okay, advise me: if I have a legacy app that is lame at Unicode, what is, currently, the best strategy to make it Unicode-aware? Some time ago, it used to be "Use Unicode IO libs, instead of the usual." But since 6.12, Unicode IO comes pre-installed. Is the best strategy, therefore, to just rebuild the app with a new compiler, or will that not necessarily spare me the headache of having to use a library to get a Unicode-aware app?
07:30:13 <LeCamarade> I actually waited for the next GHC iteration, but when it came, I could not get it to work on the system i had the machine running on. Which is how I end up in this here wee pickle.
07:30:40 <merijn> I'm going to run for president of the world on the platform of outlawing any non-UTF-8 encoding...(punishable by defenestration, of course)
07:31:05 <LeCamarade> merijn: Merijn for President!
07:31:06 <Botje> what? UCS-2 is perfectly valid, if wasteful
07:31:21 <zygoloid> Botje: don't be so BMP-centric!
07:31:29 <merijn> Botje: UCS-2 is even more braindead then UTF-16
07:31:39 <merijn> UCS-2 can't even represent all unicode codepoints...
07:32:18 <LeCamarade> Huffman-coding of symbols, of course, is the problem. But if you will have to do it, do UTF-8. If I start a network from scratch, as I very well plan to, symbols will be symbols. F the BS. Points on an XY plane. Why is that so hard?
07:32:20 <merijn> And UTF-16 breaks legacy C code because you can suddenly have NULL bytes mid-string
07:33:26 <Jafet> Vote for me. I'll outlaw legacy C code.
07:33:29 <Zao> merijn: You're doing it wrong treating a sequence of UTF-16 code units as meaningful octets.
07:33:35 <merijn> Jafet: Oh! Compelling!
07:34:07 <merijn> Zao: Name one argument in favor of UTF-16 over UTF-8...
07:34:09 <zygoloid> the world runs on legacy C code
07:34:21 <merijn> zygoloid: Which is why we can't have nice things
07:34:27 <merijn> Also, COBOL
07:34:32 <Zao> merijn: I'm not interested in getting into an argument about the pros and cons of the different transformation formats.
07:34:43 <LeCamarade> Zao: But if it is text, it is going to end up in a printf somewhere. Regardless of how well you treated it. Short of making your libc on top of libc, you are stuck with fearing NULs.
07:34:45 <Zao> merijn: I'm just saying that if you use UTF-16, you should treat it as a sequence of code units, not octets.
07:35:03 <zygoloid> merijn: utf-16 is smaller for certain corpuses. (and that's about it)
07:35:28 <zygoloid> (yes, i agree, you should compress with compression algorithms...)
07:35:55 <merijn> Not to mention that UTF-8 is smaller for the very common case of ASCII data :p
07:35:57 <LeCamarade> Ultimately, we will be wondering why we didn’t just plot symbols like the little pictures they are. Do not seek to Huffman-code human expression; you will fail.
07:36:16 <LeCamarade> Turing guarantees it.
07:37:04 <zygoloid> merijn: i know plenty of people who would contest the assertion that ASCII is very common :)
07:37:43 <merijn> zygoloid: Yes, but for other encodings UTF-16 is not always shorter then UTF-8 anyway
07:37:48 <merijn> I propose to replace all humans with androids so we can just program to never generate ambiguous data for our programs. We'd save hours on writing boring parsing code :>
07:39:42 <Jafet> Google is already working on that
07:39:53 <erus`> lol
07:40:51 <erus`> replace all hipster iphone users with android 13 year old complainers
07:41:09 <erus`> the only way to win is not to play
07:42:16 * edwardk waves hello.
07:43:24 * ion waves sine
07:44:36 * edwardk banishes his clone.
07:48:03 <bsrkaditya> what does @ do in haskell
07:48:14 <bsrkaditya>  for example in here
07:48:22 <LeCamarade> As-patterns.
07:48:28 <LeCamarade> Read it as "as".
07:49:01 <bsrkaditya> can you give me a link where this is explained?
07:49:05 <bsrkaditya> thaks!
07:49:14 <LeCamarade> > (\x @ (y, z) -> (x, y, z)) (1, 2)
07:49:14 <lambdabot>   ((1,2),1,2)
07:49:38 <Eduard_Munteanu> bsrkaditya: there isn't much to explain   basically a@(pattern) let's you pattern-match while still keeping a name to the whole thing, for example...
07:49:53 <ion> > (\a@b@c@d@e@f@g -> (a,b,c,d,e,f,g)) 42
07:49:54 <Eduard_Munteanu> xss@(x:xs) gives you access to x, xs and the whole thing
07:49:54 <lambdabot>   (42,42,42,42,42,42,42)
07:50:10 <bsrkaditya> I see
07:50:13 <bsrkaditya> thanks
07:50:21 <LeCamarade> With it, you can pattern match and yet still keep the variable name.
07:50:28 <Eduard_Munteanu> *lets
07:51:23 <cinch> <interactive>:1:1: parse error on input `*'
07:51:54 * LeCamarade re-attacking the installation problem again again. Again. Again.
07:51:57 <bsrkaditya> annotate' :: (RepoPatch p) => [DarcsFlag] -> [String] -> Repository p C(r u r) -> IO ()
07:52:14 <ion> @tell oceanspray I take it you didn’t notice my response earlier? http://hpaste.org/46715/parsing_indented_layout
07:52:14 <lambdabot> Consider it noted.
07:52:16 <bsrkaditya> annotate' opts args@[_] repository
07:52:43 <bsrkaditya> why would anyone make a pattern match like that?
07:53:05 <Eduard_Munteanu> bsrkaditya: because it only works for lists with a single element.
07:53:06 <bsrkaditya> could he not simply keep args instead of args@[_] ?
07:53:19 <Eduard_Munteanu> s/works/matches/
07:53:28 <rostayob> bsrkaditya: args would match all
07:53:34 <Saizan> i guess the rest of the function assumes args is a singleton
07:53:45 <Saizan> still quite weird though
07:53:46 <ClaudiusMaximus> bsrkaditya: it asserts that args is a 1-element list, so other patterns below might match the other cases
07:53:53 <edwardk> bsrkaditya: the idea of using an @ pattern is that if you use xxs@(x:xs) instead of replacing xxs with x:xs in the body of your function, you can avoid 'reconsing' the list together, and share the reference
07:54:04 <LeCamarade> Anybody here using Platform on SuSE 11?
07:54:20 <LeCamarade> Venez à mon secours !
07:54:42 <Eduard_Munteanu> I wonder if it actually improves sharing/performance in any way. I'd assume it wouldn't if the compiler was smart.
07:54:49 <edwardk> Eduard_Munteanu: it does
08:03:12 <Perlkonig> Question: So I have a program that's taking a while to complete (as expected). I have become accustomed to being able to print some sort of progress message to the screen during a long process. How might I accomplish this in Haskell? Basically I'm running a process over an infinite list until it finds an answer. I would like to print out the number it's currently processing.
08:03:55 <edwardk> look at trace in Debug.Trace
08:04:06 <edwardk> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Debug-Trace.html
08:04:18 <edwardk> or more likely traceShow
08:04:40 <Perlkonig> edwardk: Thank you! Still learning all the available libraries. This looks like it will do the trick.
08:05:08 <develhevel> is "{-# LANGUAGE ForeignFunctionInterface #-}" needed if i work with FFI? try to compile without ad it works
08:05:09 <edwardk> it is especially useful when you are getting started.
08:05:24 <edwardk> develhevel: FFI is kind of assumed these days
08:05:55 <edwardk> develhevel: it was the first or second addendum to the haskell 98 report (the other was hierarchical namespaces) you don't need to turn either on per se.
08:06:43 <develhevel> ok so i leave it out
08:06:52 <ClaudiusMaximus> i'd quite like a progress bar for a pure computation in a gtk app - would unsafePerformIO and tryPutMVar be too dirty?
08:06:55 <LeCamarade> Should I take it that I MUST have glibc 2.9 to compile GHC 7.0? (Where “MUST” is as defined in RFC 2119?)
08:06:59 <hydo> A question in the form of a paste: http://hpaste.org/46795/latin1_only_please
08:08:05 <develhevel> i'm trying to get the symbol names by hand and want to use FFI for some c++ calls, should i use ccall or do the other have some advantages? (with ccall it works fine)
08:08:15 <ClaudiusMaximus> or should i restructure my computation into IO so i can abort it easily too?
08:08:25 <hydo> ugh, yea, the syntax is off, but the point is still made, I think.
08:08:38 <LeCamarade> hydo and I have a related problem.
08:09:28 <spirit> when i have a module that's comprised of a class -- can i add import statements at all?
08:09:57 <LeCamarade> Encoding is hairy business under GHC, ain’t it? (In GHC’s defence, I saw how Ruby 1.9 solved the problem, and it just may be a bigger problem that was created. The Encoding object in Ruby 1.9 does give me interesting headaches from time to time.)
08:09:57 <Jafet> ClaudiusMaximus: usually you can separate it into a build/fold, then stick the IO in between
08:10:04 <hydo> There, I kinda fixed it.
08:10:29 <Jafet> Encoding is hairy business, period.
08:10:54 <Jafet> That's why you read binary data with ByteString and process it with Text.Encoding.
08:11:08 <hydo> Jafet, LeCamarade: I thought I could get around the hairy if I just simply dropped everything that wasn't latin1.  Apparently, not.
08:11:11 <Jafet> Of course, only if it's textual binary data.
08:11:52 <LeCamarade> My problem is even worse, actually. Having done this app on 6.4, I did not use ByteString, which probably has nice solutions for internationalisation.
08:11:58 <Jafet> hydo: UTF-8 is ASCII-compatible, not Latin-1-compatible.
08:12:13 <Jafet> LeCamarade: ByteString has nothing. It's just... a bytestring.
08:12:28 <LeCamarade> I still use [Char], as the traditions of our fathers were.
08:12:34 <Jafet> hydo: (it obviously can't be Latin-1-compatible, because Latin-1 uses all 255 nonzero octets.)
08:12:44 <aristid> Latin 1 is by necessity only compatible to itself as it has no gaps in the encoding
08:14:23 <Jafet> hydo: you would filter the Text for Latin-1, and encode it yourself.
08:14:48 <Jafet> develhevel: try extern "C"
08:15:56 <ClaudiusMaximus> ezyang: do you still have the .hp files for all of the images in your post?
08:16:05 <develhevel> Jafet: cant want to call it on librarys which already exists
08:16:12 <ezyang> Hmm, no, but I can trivially regenerate them.
08:16:44 <ezyang> (well, as in, recompile the programs and rerun them)
08:17:01 <Jafet> develhevel: then wrap it in C.
08:17:28 <ClaudiusMaximus> ezyang: i'd quite like them as a test case for these enhancements to hp2pretty - if you can, email them to me (or upload a tarball somewhere)
08:17:33 <Jafet> Or write a program that can somehow portably and reliably unmangle your symbols.
08:17:39 <Jafet> Your choice...
08:17:53 <ezyang> ok.
08:19:27 <Jafet> Er, mangle. Or generate-an-FFI-for.
08:20:48 <hydo> Jafet: isn't that what I'm doing in that paste?
08:21:15 <Jafet> Nope.
08:22:33 <ezyang> http://web.mit.edu/~ezyang/Public/thunk-hp.tar.gz
08:23:38 <ClaudiusMaximus> ezyang: thanks!  (btw, wget downloaded it as a tar, without gzipping)
08:24:20 <ezyang> upsy.
08:24:50 <ezyang> I guess tar doesn't do filename detection.
08:25:02 <develhevel> Jafet: i dont know if i'm right is there even sometink other like ccall?
08:25:29 <Jafet> Sorry, your question failed to parse
08:25:31 <spirit> can a class be an instance of Eq?
08:26:02 <ezyang> Formalisms are high cost, high value items.
08:26:10 <ezyang> They're no fun to learn, but once you know them they help a lot.
08:26:14 <Silvah> spirit: it wouldn't make any sense.
08:26:15 <ClaudiusMaximus> ezyang: http://claudiusmaximus.goto10.org/g/hp2pretty/stable-colours/
08:26:21 <Silvah> A class is not a type.
08:26:41 <ezyang> Nice.
08:26:47 <byorgey> spirit: only types can be instances of classes.
08:26:56 <byorgey> spirit: however, a class can have another class as a superclass.
08:27:02 <ezyang> Did you purposely give similar thunks similar colors?
08:27:16 <ezyang> (if not, that would probably be a cool feature to have)
08:27:42 <ClaudiusMaximus> ezyang: no - i copied/changed the hashing function from base-4.3.1.0:Data.HashTable
08:28:06 <ezyang> Aha!
08:28:08 <ClaudiusMaximus> ezyang: i might have broken it with my changes
08:29:13 <ClaudiusMaximus> ezyang: i use different 'magic' for hue/saturation/value in the hope that similar hues will have different brightnesses
08:29:43 <ezyang> classy.
08:38:03 <ClaudiusMaximus> > mconcat (Last (Just (False, False)) : Last Nothing : [])
08:38:04 <lambdabot>   Last {getLast = Just (False,False)}
08:40:15 <ion> claudiusmaximus: data Progress a = Step Rational (Progress a) | Result Rational a
08:40:25 <syri> Hi. I need some help regarding DBDirect-hdbc-mysql
08:40:44 <ion> showProgress (Step n next) = ioCode >> showProgress next
08:40:55 <ion> showProgress (Result n r) = ioCode
08:40:58 <syri> What are the driver options the program expects and what is the expected format?
08:41:54 <anchovy7> does compiling libraries with split-objs increase their size?
08:43:11 <int-e> anchovy7: given that you end up with way more files in the .a files, I assume so.
08:43:35 <int-e> anchovy7: it also increases the memory usage by the linker. but the resulting executables should be smaller.
08:46:15 <anchovy7> does split-objs help in way for executables linked dynamically?
08:47:10 <int-e> I don't know. I think it should not affect them at all.
08:47:56 <LeCamarade> Forgive me father, for I have sinned: I use read (show str) to turn [Char] into ByteString. Is there a better way, and should I feel ashamed? How many “Hail Mary”s?
08:48:09 <anchovy7> @hoogle pack
08:48:09 <lambdabot> Data.ByteString pack :: [Word8] -> ByteString
08:48:09 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
08:48:09 <lambdabot> Data.ByteString.Lazy pack :: [Word8] -> ByteString
08:48:16 <LeCamarade> Hey!
08:48:22 <quicksilver> LeCamarade: depends what encoding you want.
08:48:28 <quicksilver> 'pack' gives you the 'strip high bytes' encoding.
08:48:33 <quicksilver> if that's what you want it's fine.
08:48:34 <LeCamarade> anchovy7: Thanks. 
08:48:41 <quicksilver> (that's the same as read (show str) I believe)
08:49:05 <anchovy7> actually
08:49:08 <LeCamarade> quicksilver: Well, it should work until I think it is killing my code. I am re-writing this dodgy app from back then.
08:49:16 <anchovy7> you can also use fromString
08:49:22 <anchovy7> @hoogle fromString
08:49:22 <lambdabot> Data.String fromString :: IsString a => String -> a
08:50:20 <LeCamarade> My installation doesn’t seem to have it implementing IsString.
08:51:11 <applicative> where is there a fromString for ByteString, it doesn't come with it for some reason, so you don't naturally use {-#OverloadedStrings#-}
08:51:39 <anchovy7> @src ByteString fromString
08:51:39 <lambdabot> Source not found. You untyped fool!
08:51:53 <ben> Should you not really use the encoding package or similar?
08:52:01 <quicksilver> it's only exported byt he Char8 packages
08:52:05 <anchovy7> Data.ByteString.[Lazy.]Char8 should export an IsString instance
08:52:19 <quicksilver> as you might expect, since it only supports the Char8 "encoding"
08:52:27 <quicksilver> also known as "ignore high bytes"
08:56:26 <applicative> oh it's in the Char8 modules, the IsString instance.
08:57:17 <applicative> I think I had forgotten.
08:57:31 <applicative> The way I usually use is via Data.Text
08:57:41 <justWondering> is haskell to lisp as vi to emacs?
08:59:41 <applicative> LeCamarade: were you using string 'literals' in your program?
08:59:53 <LeCamarade> Yes, I was.
09:00:05 <applicative> I see, so OverloadedStrings would be nice.
09:01:51 <applicative> which ByteString module are you importing?
09:04:46 <spirit> if i wanted to define equality for sets via their elements, say for all elements a of A holds a in B and for all elements b of B holds b in A -- how would i haskell that?
09:05:49 <applicative> if you import Data.Text () you have the IsString instance for Text, so you literal strings will be read as Texts; then you can use something like encodeUtf8 http://hackage.haskell.org/packages/archive/text/0.11.0.7/doc/html/Data-Text-Encoding.html
09:06:25 <applicative> @faq Can Haskell haskell that?
09:06:25 <lambdabot> The answer is: Yes! Haskell can do that.
09:07:38 <applicative> spirit, you mean you want two 'sets' to be the same if all of their 'elements' are the same?
09:08:01 <applicative> unlike e.g. lists?  Or is it a more technical question
09:08:59 <spirit> maybe it's more of a technical question, not sure whether i should use (all) or forall
09:11:07 <applicative> do you have a bit of code?  its a little opaque I at least am finding
09:12:21 <spirit> i'm building on code that's been written by someone else. all seemed fine until today -- i seem to be in trouble regarding equality.
09:12:36 <spirit> the code defines its own class Set
09:12:45 <ClaudiusMaximus> ezyang: http://claudiusmaximus.goto10.org/g/hp2pretty/ subfolders uniform-*  (the code is a bit ugly but it seems to work ok)
09:12:47 <applicative> right, that often happens.
09:13:03 <spirit> and I don't know how to tell it what equality is, i.e. equality with the emptyset
09:13:09 <byorgey> spirit: paste the code?  hpaste.org
09:14:09 <spirit> it's a whole package, many classes unfortunately. all seemed to work just fine until i started reading from disk. all of a sudden it takes order into account, which it didn't before. well weird.
09:14:10 <djahandarie> ClaudiusMaximus, I wonder if it's problematic that nothing shows up at all on the better graphs :p
09:15:06 <ClaudiusMaximus> djahandarie: it's a command line flag to explicity enable "comparable" graphs
09:15:35 <ClaudiusMaximus> djahandarie: i'll make a release shortly...
09:17:17 <spirit> my code is here: http://hpaste.org/46797/equality_issue
09:18:18 <ion> claudiusmaximus: Did you notice my message?
09:18:27 <spirit> the issue seems to be that isEmptySet isn't defined. weird as it may sound, the code has been working... until i recently started reading from disk.
09:19:35 <spirit> i tried all afternoon to get the equality definition into the package, tried different modules, no success :-/
09:19:58 <applicative> spirit, you can use toList,
09:20:57 <spirit> isEmptySet s = (toList s) == []
09:21:00 <spirit> like that?
09:21:29 <applicative> isEmpty set = null (toList set)
09:21:43 <applicative> isEmpty = null . toList
09:22:50 <spirit> cheers so much! i paused the haskell bit of my project a few months back, went to c++ for a while and now that i'm short of time it's rather troublesome to get the final haskell bits to run.
09:24:00 <spirit> leksah is rather flaky too, when editing it keeps on telling me the file has changed from disk (sure, i'm editing it!) and sometimes it even crashes :-/
09:24:01 <ClaudiusMaximus> ion: yes, but was busy on other things
09:24:22 <pastorn> spirit: maybe some old swap file?
09:24:40 <ClaudiusMaximus> ion: looks like a nice solution
09:24:40 <spirit> where would that be?
09:24:53 <spirit> it's a very fresh install
09:24:54 <pastorn> spirit: where the file is, i guess
09:25:06 <pastorn> i don't know how leksah works
09:25:09 <pastorn> i only use gvim
09:25:34 <applicative> spirit, since there's a toList you should have an empty :: s a -> Bool  ;  empty = null . fromList
09:25:37 <spirit> is that th
09:26:07 <spirit> is sfiles where leksah stores swap files? those might be from all the crashes?
09:26:27 <scree> spirit: I'm confused by a lot of things with this code.  One is: is toList defined in terms of isEmptySet in the instance you're working with?  It is in the default instance
09:26:55 <scree> s/default instance/default implementation
09:27:24 <applicative> spirit, ah, I didn't see the isEmpty set is one of the required methods
09:27:29 <ion> claudiusmaximus: It would be made mode generic by using a type parameter for the progress. data Progress p r = Step p (Progress p r) | Result p r
09:27:50 * hackagebot blaze-builder 0.3.0.1 - Efficient buffered output.  http://hackage.haskell.org/package/blaze-builder-0.3.0.1 (SimonMeier)
09:29:43 <spirit> it might be fixed, need to check more thoroughly though!
09:30:09 <spirit> (i'll reimplement the package once i'll have more time, using standard haskell packages -- might make more sense)
09:32:17 <spirit> unfortunately still the same issue :-/ it doesn't recognise set [1,2,3] == set [3,2,1]
09:32:50 <scree> spirit: I'm confused as to what the issue is here.  Do you have code that actually breaks?
09:33:11 <spirit> i added isEmpty set = null (toList set)
09:34:41 <scree> spirit: that code will only ever kick in if someone implements toList but not isEmptySet, right?
09:34:46 <spirit> yes, the code relies on setEqual, it won't construct a morphism later on cos it won't accept sets required are equal
09:35:49 <spirit> i don't know when it;ll kick in, it seems circular to me
09:35:59 <scree> spirit: can you post a compile error?  or am I still misunderstanding?
09:36:20 <spirit> it's not a compile error, it's an error i get at runtime
09:36:46 <spirit> here it comes:
09:36:48 <spirit> pullbacks_first: consSetMor:
09:36:48 <spirit> 	incorrect domain
09:36:48 <spirit> 	o1= {"1->1[label=bookmark", "1->1[label=library]", "1->1[label=toc]", "1->1[label=press and hold]", "1->1[label=swipe page right]", "1->1[label=swipe page left]", "1->1[label=tap page right]", "1->1[label=tap page left]", "1->1[label=scrub bar drag right]", "1->1[label=scrub bar drag left]"}
09:36:48 <spirit> 	keySet f= {"1->1[label=scrub bar drag left]", "1->1[label=scrub bar drag right]", "1->1[label=tap page left]", "1->1[label=tap page right]", "1->1[label=swipe page left]", "1->1[label=swipe page right]", "1->1[label=press and hold]", "1->1[label=toc]", "1->1[label=library]", "1->1[label=bookmark]"}
09:36:59 <spirit> o1 and keySet f should be equal
09:37:12 <jmcarthur> hpaste is your friend
09:37:16 <spirit> and to me they seem equal, just not their order
09:37:32 <scree> spirit: so, what is the instance type in that context?
09:37:53 <spirit> instance of o1 and keySet f?
09:38:32 <scree> spirit: I mean, what is the type that implements Set in this context; what is the "instance Set Foo"?
09:40:08 <spirit> ah -- so here it is :-)
09:40:10 <spirit>     instance Set SetSeq where
09:40:10 <spirit>         emptySet = SQ []
09:40:20 <spirit> isEmptySet (SQ []) = True
09:40:20 <spirit>         isEmptySet other   = False
09:40:26 <scree> spirit: PASTE!
09:40:28 <Luke> how do I export a data constructor from a module along with all the record accessors?
09:41:16 <spirit> http://hpaste.org/46798/instance_set_foo
09:41:21 <spirit> how come it's not working?
09:41:39 <mm_freak> Luke: i think it was like Type(Constructor(..), …)
09:41:48 <Luke> ah yeah.. the ".."
09:41:52 <Luke> couldn't remember
09:41:54 <Luke> thanks
09:42:52 * hackagebot hp2pretty 0.4 - generate pretty graphs from heap profiles  http://hackage.haskell.org/package/hp2pretty-0.4 (ClaudeHeilandAllen)
09:44:33 <scree> spirit: what's the "remove" instance code?
09:45:57 <spirit> oops -- posted it now as an annotation of the original
09:48:58 <scree> spirit: with that code I get "[1,2,3] == [3,2,1]" is true
09:49:44 <scree> spirit: could you deconstruct your minimal counterexample a bit?  it's a bit difficult to see what's going on with that
09:50:04 <spirit> i got that too until recently
09:50:13 <scree> spirit: e.g. what is a "1->1[label=foo]"?
09:50:27 <spirit> the only 'new' thing is that i'm reading from disk now
09:50:44 <scree> spirit: what do you mean by "reading from disk"?
09:51:04 <spirit> reading files that contain the input from disk
09:51:55 <spirit> it's a mapping of edges, 1->1 like graphviz writes it. the labels are from an ebookreader
09:51:58 <spirit> not important
09:52:58 <scree> spirit: ok.  could the problem be that your set *elements* look the same under Show, but aren't the same under Eq?
09:53:46 <ktosiek> Hi! I want to write an IRC bot, but I don't know how plugins should work - I want them to have some (optional) state and a way to read and set the bots state too
09:54:23 <spirit> how could i check that?
09:55:15 <spirit> i mean it does make sense since the problem only occurred once i started reading from disk (maybe something's wrong there)?
09:55:22 <scree> spirit: for an equality check that's failing, print something like [(a, b, a == b) | a <- toList s1, b <- toList s2]
09:55:28 <syri> Does anyone has a problem building packages that depend on unix-2.4.2.0? I get the error libHSunix-2.4.2.0.a(Signals.o): In function `sq9K_info':
09:55:29 <syri> (.text+0x3594): undefined reference to `rtsTimerSignal
09:55:54 <zygoloid> ktosiek: there's a paper on how plugins work in lambdabot and yi. that'd be a good place to start.
09:56:14 <spirit> is it possible to copy from the irc window?
09:56:19 <scree> spirit: it depends on the elements.  If it's being serialized and deserialized, it's possible your EQ instance could 'break' somehow
09:56:27 <applicative> syri, hm.  what platform are you using, what distribution?
09:56:34 <ktosiek> zygoloid: thanks! Any clues where to find it?
09:56:43 <syri> linux, debian
09:56:49 <spirit> will quickly check! thanks so much for helping
09:57:56 <syri> unix package was installed without problems. I even reinstalled it just in case. Installation is done with cabal
09:59:59 <spirit> how do i print it though. via error () ?
10:00:30 <spirit> error (show ([(a,b, ...))?
10:00:36 <scree> spirit: would work
10:00:48 <scree> spirit: or maybe trace or traceShow
10:00:50 <scree> @hoogle trace
10:00:51 <lambdabot> Debug.Trace trace :: String -> a -> a
10:00:51 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
10:00:51 <lambdabot> module Debug.Trace
10:01:52 <spirit> it actually does take into account order... (1,3,false),...
10:01:55 <spirit> :-/
10:01:57 <spirit> but why!?
10:02:22 <scree> spirit: (1,3,false) is correct, no?
10:02:35 <applicative> syri, is there a 'haskell platform' package for debian, I can't remember
10:02:47 <applicative> in principal unix should come with that.
10:03:18 <applicative> then if you install a later one with cabal install, it should be as user.
10:03:27 <syri> there are debian packages. I have installed ghc as a debian package. The rest are installed via cabal
10:03:34 <scree> spirit: again, the more code you can paste, the easier it is for me to figure out what's going on
10:03:36 <spirit> i pasted it on hpaste as an annptation. not easy to read i fear
10:04:00 * hackagebot cpsa 2.2.4 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.2.4 (JohnRamsdell)
10:04:22 <zygoloid> ktosiek: http://gernot-heiser.org/~dons/hs-plugins/paper/
10:04:24 <applicative> syri, have you looked at > ghc-pkg list
10:04:26 <spirit> enough triples with true too -- those i want!
10:04:34 <applicative> and also > ghc-pkg check
10:05:26 <mjrosenb> gah, all of this code should be shoved into a MaybeT
10:05:41 <mjrosenb> or i could just write it in prolog
10:05:50 <ktosiek> zygoloid: thank you :-D
10:09:17 <zygoloid> ktosiek: np :)
10:09:44 <spirit> i also pasted the source code, where i put the error message
10:12:50 <scree> spirit: so, as far as I can tell from that data, those sets are genuinely not the same
10:14:01 <spirit> what's the difference?
10:14:08 <spirit> how did you find the difference?
10:14:27 <applicative> syri: there is a Haskell Platform package for debian versions (which includes the unix package) I think it's best to install the platform, then arrange that cabal installs separately, so you don't overwrite.
10:17:02 <chrissbx> What is >> in english? I know >>= is called "bind", but >>?
10:17:25 <djahandarie> "bind without the equal sign"
10:17:46 <scree> spirit: so, I've reconstructed the original lists, as lists of strings.  One contains "1->1[label=bookmark]", the other "1->1[label=bookmark"
10:17:56 <chrissbx> djahandarie: seriously?
10:18:07 <djahandarie> chrissbx, no :p It doesn't have a name.
10:18:13 <spirit> yeah
10:18:25 <copumpkin> chrissbx: "then"
10:18:28 <djahandarie> And "bind" as a function is usually flip (>>=)
10:18:53 <djahandarie> copumpkin, reverse state monad?
10:18:54 <chrissbx> ok
10:18:58 <scree> spirit: that seems to be bad
10:19:11 <copumpkin> djahandarie: the effects still happen in that order
10:19:33 <chrissbx> What is the reason that >>= is called bind?
10:19:48 <chrissbx> At one point I thought >> was "bind" because it binds actions together..
10:20:13 <copumpkin> probably
10:20:14 <spirit> o dear, that was it. so it had to do with reading from file, a typo! thanks so much!!!
10:21:14 <scree> spirit: np
10:25:03 <jmcarthur> man i wish i had stopped to think about how difficult it would be to try to combine fusion with lots of unsafe stuff
10:25:46 <mjrosenb> @hoogle (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c
10:25:47 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:25:47 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
10:25:47 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
10:26:04 <mjrosenb> hrmm, i suspect i want liftM2
10:26:16 * applicative expresses confidence in jmcarthur
10:26:16 <djahandarie> liftA2*
10:27:39 <mjrosenb> what is the difference between liftM2 and liftA2?
10:27:57 <RichardBarrell> liftM2 is for Monads, liftA2 is for Arrows.
10:27:58 <mjrosenb> actually, no
10:27:59 <djahandarie> liftM2 is too specific. You can do that generalization with Applicatives only.
10:28:11 <djahandarie> RichardBarrell, Applicatives*
10:28:15 <mjrosenb> that is not the thing that i want
10:28:22 <djahandarie> mjrosenb, what are you trying to do?
10:28:35 <RichardBarrell> djahandarie: oops, forgot that there was more than one 'A'. :)
10:28:41 <mjrosenb> i want (a -> a -> a) -> Maybe a -> Maybe a -> Maybe a
10:29:12 <djahandarie> mjrosenb, it should still work fine.
10:29:21 <applicative> > (+) <$> Just 1 <*> Just 1
10:29:21 <lambdabot>   Just 2
10:29:43 <applicative> > liftA2 (+) (Just 1) (Just 1)
10:29:44 <lambdabot>   Just 2
10:29:48 <mjrosenb> frob f Nothing x = x; frob f (Just x) Nothing = Just x; frob f (Just x) (Just y) = f x y
10:30:25 <mjrosenb> so sort of like liftA2, but with a MonadPlus.
10:30:32 <applicative> > (+) <$>  Nothing <*> Just 1
10:30:32 <lambdabot>   Nothing
10:31:00 <applicative> ah I see it's for a -> a -> a more powr
10:31:34 <djahandarie> ? I'm confused how that gives it more power
10:31:43 <mjrosenb> frob f x y = liftA2 f x y `mplus` x `mplus` y
10:31:48 <mjrosenb> i guess?
10:32:18 <mjrosenb> so are things that are Applicative a subset or supreset of things that are Monad?
10:32:28 <applicative> superset
10:32:33 <applicative> wait
10:33:00 <applicative> every monad instance induces a corresponding applicative instance
10:33:24 <applicative> some applicative instances cannot be extended to a monad instance, e.g. the familiar ZipList
10:33:30 <djahandarie> > msum [Nothing, Just 1, Nothing]
10:33:30 <lambdabot>   Just 1
10:34:18 <mjrosenb> applicative: is there a website that talks about that?
10:34:25 <applicative> djahandarie, it means he can use one of the arguments as a defalut
10:34:36 <applicative> @where typeclassopedia
10:34:36 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
10:34:46 <applicative> mjrosenb: ^^^^
10:37:33 <applicative> djahandarie: at least that's what I was thinking.   liftA2 f has to give you Nothing if either arg is Nothing. but mjrosenb f Nothing (Just x) = Just  x which makes sense given f :: a -> a -> a, no?
10:39:26 <djahandarie> That f in his definition is not a -> a -> a
10:39:39 <applicative> really?
10:39:55 <djahandarie> The last clause makes it a -> a -> Maybe a
10:40:03 <mjrosenb> djahandarie: i amended my original type to something that was.
10:40:04 <applicative> i was looking at this one:  mjrosenb	i want (a -> a -> a) -> Maybe a -> Maybe a -> Maybe a
10:41:00 <applicative> oh i see, he queried hoogle with the broader signature
10:41:20 <mjrosenb> i have now realized that i in fact want something kind of different, but that one is the interesting one.
10:41:30 <djahandarie> It's easy to fix by just adding a Just
10:41:43 <mjrosenb> @hoogle (a->a->a) -> Maybe a -> Maybe a -> Maybe a
10:41:43 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
10:41:43 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:41:43 <lambdabot> Data.Foldable foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
10:43:31 <mjrosenb> frob f x y = foldl1 f $ catMaybes [x,y]
10:43:34 <mjrosenb> *almost*
10:47:07 <kergo> I am trying to understand type classes and I've started with Functor. I'd like to know if one mental analogy I'm making isn't misguided: can I see a functor as a not-yet-applied function? i.e. if even? 2 == True, then fmap (+3) (even? 2) == (even? 5) == False
10:48:06 <mjrosenb> kergo: usually, functors are compared to containers.
10:48:07 * hackagebot wumpus-core 0.51.0 - Pure Haskell PostScript and SVG generation.  http://hackage.haskell.org/package/wumpus-core-0.51.0 (StephenTetley)
10:48:09 * hackagebot wumpus-basic 0.18.0 - Basic objects and system code built on Wumpus-Core.  http://hackage.haskell.org/package/wumpus-basic-0.18.0 (StephenTetley)
10:48:50 <mjrosenb> kergo: what you are talking about is called 'currying'
10:48:54 <zygoloid> kergo: you can sort of see a functor as some sort of abstract operation over some (unknown, possibly infinite) set of values from the type
10:49:07 * hackagebot wumpus-drawing 0.4.0 - High-level drawing objects built on Wumpus-Basic.  http://hackage.haskell.org/package/wumpus-drawing-0.4.0 (StephenTetley)
10:49:10 * hackagebot wumpus-tree 0.16.0 - Drawing trees  http://hackage.haskell.org/package/wumpus-tree-0.16.0 (StephenTetley)
10:49:15 <mjrosenb> kergo: also, i do not believe that your use is correct.
10:49:46 <mjrosenb> > fmap (+3) even 2
10:49:46 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
10:49:47 <lambdabot>    arising from the literal `3'...
10:49:47 <ion> Functor is a type that usually contains or results in a value or values you can apply a function to. fmap (+3) (Just 2) results in Just 5, fmap (+3) [0,1,2] results in [3,4,5], fmap (+3) aParsecParser results in a parser that, when successful, results in the original value plus 3.
10:50:10 <kergo> mjrosenb, no, I know it wouldn't work, I meant it as an analogy.
10:50:32 <kergo> mjrosenb, but I've read the container analogy breaks down after a while, so I wanted to get a better understanding.
10:50:46 <copumpkin> danharaj: " And when I say brilliant, I mean brilliant with respect to the average PhD recipient."
10:51:07 <copumpkin> is that a really strong statement? :P
10:51:30 * mjrosenb does not remember anything where the container analogy broke down
10:51:49 <ion> mjrosenb: A Parsec parser, an IO action
10:51:56 <copumpkin> from my experience in academia, I'm not sure the average intelligence of phd recipients is much higher than that of the general population
10:52:13 <ion> many1 digit :: Parser String
10:52:18 <jrick> a phd is only a license to say silly things
10:52:19 <ion> read <$> many1 digit :: Parser Integer
10:52:34 <kergo> Ok, I'll stick with "contains" for now, I'll see what happens later.
10:52:53 <ion> readFile "foo" :: IO String
10:52:56 <ion> read <$> readFile "foo" :: IO Integer
10:53:56 <ion> (<$> is the infix alias of fmap)
10:54:48 <ion> Neither of those “contains” a string (or an integer), but both result in one.
10:55:07 <mjrosenb> ugh.  i have designed this poorly
10:55:34 <mwc> Anybody know what GHC warn flag controls the "Bindings containing unlifted types should use an outermost bang pattern" warning?
10:56:09 <mjrosenb> i want syntactic sugar for $ in a do block
10:56:17 <mjrosenb> whic seems like a bad idea in general
10:56:49 <ClaudiusMaximus> mwc: -f(no-)warn-lazy-unlifted-bindings perhaps (there's a list in the man page)
10:57:19 <mwc> ClaudiusMaximus: heh, I was staring at that list and didn't see that one
10:57:26 <rostayob> Is there a way to convert 4 Word8 directly to an Int?
10:57:36 <copumpkin> rostayob: shift and or?
10:57:41 <copumpkin> you need to pick a byte order
10:57:49 <rostayob> copumpkin: right
10:58:27 <zygoloid> rostayob: there sure is. add them!
10:59:00 <ClaudiusMaximus> @hoogle Word8 -> Word8 -> Word8 -> Word8 -> Int32
10:59:00 <lambdabot> Control.Monad liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
10:59:00 <lambdabot> Data.List zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
10:59:00 <lambdabot> Control.Monad liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
10:59:34 <rostayob> actually, it's an unsigned integer
10:59:39 <rostayob> i'll just use CUInt i guess
11:01:03 <kergo> ion: Do you have a uniform mental representation for what fmap does in the case of [] and in the case of IO, or do you shift representations depending on context?
11:01:12 <ion> > foldl1 (\acc x -> acc .|. (fromIntegral :: Word8 -> Integer) x `shiftL` 8) [1..4]
11:01:12 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
11:01:13 <lambdabot>         against inferred type...
11:01:58 <sgronblo> Am I the only one who thinks it seems lik a bit of a pain to work with regexps in haskell?
11:02:05 <ion> A moment, phone
11:03:42 <applicative> sgronblo: yes, but i'm not too good at them outside haskell...  are you sure you need them though?
11:04:32 <ClaudiusMaximus> rostayob: alloca $\i -> pokeArray (castPtr i) [u,v,w,x] >> peek i -- different results depending on host byte order :)
11:05:02 <sgronblo> well I'm not doing anything at the moment. but some of my recent attempts at coding haskell have ended due to the lack r'strings' and the overabundance of choice of regexp modules.
11:05:03 * applicative has trouble reasoning about greediness! away with greedy evaluation
11:05:25 <ion> kergo: In every one of the types [] a, Maybe a, IO a, Parser a the ‘a’ is the type fmap acts on. For every one of them the current behavior is pretty much obvious.
11:05:39 <c_wraith> applicative: I've had issues with that recently.  "You mean it's evaluated just because I gave it a name?  wtf?!"
11:05:40 <byorgey> sgronblo: there are usually better ways that regexps to get done whatever you want to do.
11:05:47 <byorgey> *than
11:05:58 <applicative> c_wraith, are you writing ML?
11:06:09 <c_wraith> applicative: ruby, in that case.  >_>
11:06:17 <applicative> hah, yes
11:06:40 <applicative> sgronblo: i was approaching byorgey's thought, without his expertise
11:06:52 <ClaudiusMaximus> i tried to parse some namespace heavy XML with haskell but i didn't manage to figure it out, in the end i used bash/grep/sed stuff just to get something working quick :(
11:07:37 <jmcarthur> it's been said that the difference between call-by-value and call-by-name/call-by-need is not about whether arguments are evaluated but about what can be bound to a name
11:08:05 <rostayob> ClaudiusMaximus: right.... I'm parsing a strange dump
11:08:16 <kergo> ion: To see if I understood correctly: so the difference is that with Maybe a, you have a box that already contains a value of type a, but with IO a, you have an IO action that will, when performed, contain a value of type a ?
11:08:40 <c_wraith> kergo: what value of type a is held by Nothing?
11:08:42 <applicative> jmcarthur: namely in call by name, it's the calculation that is bound to the name?
11:09:11 <kergo> c_wraith: ahem.. so you a have a box that either contains Nothing or contains a value of type a.
11:09:14 <jmcarthur> kergo: with Maybe a you have a box that *might* contain a value of type a. with IO a, you have an action that will, when performed, *return* (not contain) a value of type a
11:10:08 <jmcarthur> applicative: as i understand it, yeah
11:10:30 <Eduard_Munteanu> It's not something about IO really, but about the primitive operations that IO stuff usually entails.
11:10:53 <c_wraith> data Degenerate a = Degenerate ; instance Monad Degenerate where ...
11:11:15 <applicative> return x = Degenerate
11:11:40 <c_wraith> It's a fun instance.  obeys all the laws!
11:11:55 <applicative> m >>= f = Degenerate
11:12:53 <Eduard_Munteanu> Isn't that the trivial monad?
11:12:55 <applicative> It took me a second to see that m >>= return was Degenerate, but surely m is Degenerate
11:13:33 <applicative> i mean, to see that m = m >>= return
11:13:56 <c_wraith> given that there's only one value of m (despite it having many potential types), yes.  It's sort of trivially true. :)
11:14:17 <Eduard_Munteanu> Ah, I thought there was something actually known as "the trivial monad"
11:14:37 <c_wraith> some people say "the trivial monad" when talking about identity
11:14:49 <Eduard_Munteanu> It's interesting because there's no dual trivial comonad to it.
11:14:50 <c_wraith> So..  No, there's no standard trivial monad.
11:15:53 <Eduard_Munteanu> Since counit / coreturn :: w a -> a, but you can't actually write that (at least constructively)
11:16:15 <luite> is it possible to prettyprint haskell source with haskell-src-exts in such a way that source (error) locations are completely accurate if loaded in ghci?
11:17:06 <ion> > flip showHex "" (foldl1 (\acc x -> acc `shiftL` 8 .|. x) . map fromIntegral $ ([1,2,3,4] :: [Word8]) :: Integer)
11:17:08 <lambdabot>   "1020304"
11:18:25 <luite> does the haskell-src-exts author visit this channel?
11:18:50 <copumpkin> preflex: seen nibro
11:18:50 <preflex>  nibro was last seen on #haskell 1 year, 192 days, 22 hours, 50 minutes and 34 seconds ago, saying: Phyx-: updating is good :)
11:20:57 <luite> what's a good hosting provider for cheap (virtualized?) servers with lots of ram and a good cpu
11:21:33 <luite> linode gets pretty expensive if you want more ram
11:23:00 <FUZxxl> ezyang: So, this is my problem:
11:23:29 <FUZxxl> I want to create bindings for libnova, an LGPL astronomics library. (Just for fun)
11:24:57 <ezyang> ok...
11:25:02 <FUZxxl> First, I wanted to create the haskell equivalents to the types used in libnova.
11:25:11 <FUZxxl> Eg. for ln_date (just for practise).
11:25:32 <FUZxxl> So I created an ADT and wrote an instance of Storable.
11:26:10 <FUZxxl> The problem is, that libnova.h doesn't typefs the struct, so one must write struct ln_date instead of ln_date.
11:26:20 <FUZxxl> But that doesn't work with the sizeof makro.
11:26:41 <ezyang> IIRC, c2hs should be ok even in the absence of typedefs.
11:26:46 <ezyang> What are you specifically using?
11:26:59 <FUZxxl> cabal + c2hs
11:27:14 * hackagebot pugs-compat 0.0.6.2 - Portable Haskell/POSIX layer for Pugs  http://hackage.haskell.org/package/pugs-compat-0.0.6.2 (AudreyTang)
11:27:24 <ezyang> No, as in, what have you tried, in your Haskell.
11:27:29 <FUZxxl> Hm...
11:27:36 <FUZxxl> instance Storable LNdate where
11:27:36 <FUZxxl>   sizeOf _ = {#sizeof ln_date #}
11:28:10 <dcoutts> FUZxxl, ezyang: I thought c2hs only liked single type names, not "struct foo", so I thought you do need to use typedefs.
11:28:28 <dcoutts> didn't we discuss that yesterday?
11:28:34 <ezyang> Oh, ok. That's possible.
11:28:51 <FUZxxl> dcoutts: Yes. But since ezyang wrote an excellent tutorial about c2hs, he may have another idea.
11:29:06 <FUZxxl> ezyang: You weren't here yesterday?
11:29:14 * hackagebot pugs-DrIFT 2.2.3.2 - DrIFT with pugs-specific rules.  http://hackage.haskell.org/package/pugs-DrIFT-2.2.3.2 (AudreyTang)
11:29:15 <ezyang> No, I didn't see that discussion.
11:29:25 <ezyang> Anyway, the way to resolve this conclusively is to check the c2hs source code.
11:29:46 <ezyang> and there may be a relevant feature request in the c2hs trac. I must admit, most of my c2hs work was with type'defed structs.
11:29:57 <dcoutts> FUZxxl: so did you try adding the typedef into the generated header using #c .. #endc ?
11:30:11 <FUZxxl> dcoutts: Yes.
11:30:15 * hackagebot Pugs 6.2.13.20110519 - A Perl 6 Implementation  http://hackage.haskell.org/package/Pugs-6.2.13.20110519 (AudreyTang)
11:30:21 <dcoutts> and?
11:30:22 <FUZxxl> But I dislike this approach... too much boilerplate.
11:30:30 <FUZxxl> But it works, yes.
11:30:39 <dcoutts> how so? It's 3 extra lines right?
11:30:42 <djahandarie> Whoa, new Pugs
11:30:46 <djahandarie> Don't see that every day
11:31:20 <FUZxxl> dcoutts: It's an extra line for each struct. There are about 20 structs at all. It's that kind of "duplication" I try to avoid.
11:31:35 <dcoutts> FUZxxl: ok, so 22 lines extra.
11:31:51 <hellertime> I've created a simple recurring time library that I was thinking of putting up on Hackage. Is that sort of thing encouraged, or should I gauge interest first?
11:32:02 <dcoutts> FUZxxl: your welcome to send in a patch to c2hs to support compound type names
11:32:08 <FUZxxl> dcoutts: :)
11:32:14 <FUZxxl> Uhh...
11:32:22 <FUZxxl> Who wrote c2hs?
11:32:27 <dcoutts> FUZxxl: we've already had some patches along those lines for other use cases
11:32:45 <dcoutts> FUZxxl: Manuel wrote it, I've rewritten bits of it, he and I are maintainers
11:32:59 <FUZxxl> dcoutts: It would be nice to be able to automagically derive Storable.
11:33:06 <FUZxxl> dcoutts: Okay.
11:33:11 <ezyang> That's what systems like Greencard are for.
11:33:22 <ezyang> though, IIUC Greencard is a dead-end?
11:33:46 <FUZxxl> What is greencard?
11:33:48 <dcoutts> FUZxxl: aye, it depends on a system for setting defining marshalers
11:33:52 <edwardk> pugs lives?
11:33:59 <dcoutts> erm, defining default marshalers
11:34:02 <cheater_> why is greencard a dead-end?
11:34:32 <ezyang> No one's really working on it? I might be wrong.
11:34:39 <dcoutts> FUZxxl: really the problem is that there's not quite enough info in a C struct to bind it automatically in the general case, especially for pointers.
11:34:44 <edwardk> guess audrey got bored
11:34:56 <djahandarie> Haha
11:35:00 <dcoutts> ezyang: greencard used IDL right?
11:35:04 <ezyang> Heh. "Sounds like the standard problem with anything FFI related"
11:35:19 <FUZxxl> dcoutts: But what about "easy" cases.
11:35:20 <FUZxxl> ?
11:35:24 <ezyang> I didn't look at it closely enough to know. I just had to choose between hsc2hs, c2hs and greencard at the start of my internship.
11:35:51 <ezyang> anyway, I'm compiling c2hs, and I'll poke at it real quick.
11:35:54 <dcoutts> FUZxxl: right, so for by-value things and pointer types that are defined using {# pointer #} then in principle it's doable.
11:36:08 <FUZxxl> okay.
11:36:28 <dcoutts> ezyang: imho, we could do a lot better with c2hs than we currently do. The basic approach I think is sound.
11:36:43 <ezyang> Yeah, me too. The question is finding interested devs :-
11:36:53 <dcoutts> ezyang: it's got lots of warts though currently. Nothing fundamental.
11:37:38 <dcoutts> ezyang: right, my involvement with it was from when I was a gtk2hs hacker, and gtk2hs uses c2hs so we need it to be reliable on lots of platforms and cope with all the funny system C headers.
11:37:52 <dcoutts> which is why I rewrote the C parser to do C99 + GNU C extensions
11:38:35 <dcoutts> I didn't get into the heart of c2hs, from the C AST onwards
11:42:09 <k0ral> I'm trying to use multithreads in my gtk app but it doesn't work while I used forkIO and -threaded
11:42:33 <k0ral> I found no example of the use of forkIO in a gtk context
11:42:47 <k0ral> would anyone have a clue on it ?
11:43:01 <k0ral> posting my code in hpaste
11:43:07 <ezyang> OK. Looks like struct is not a reserved word in the C2HS lexer, so yes, there is no way to directly say "struct foo" in a sizeof pragma.
11:44:24 <ezyang> FUZxxl: If you wanted to fix this, make struct a defined keyword in ./C2HS/CHS/Lexer.hs, then teach C2HS/CHS.hs how to turn a struct token into the appropriate identifier, which Language.C should present.
11:44:30 <ezyang> All in all, it should be pretty trivial.
11:44:54 <merijn> k0ral: GTK stores thread local state I think. This means it must always run in the same OS thread (which you can accomplish with forkOS, I think)
11:44:55 <monochrom> k0ral: see my http://www.vex.net/~trebla/haskell/gtk-interact.xhtml for a tested example of gtk and threading
11:45:02 <FUZxxl> ezyang: okay..
11:45:04 <ezyang> since I'm pretty sure that if you can get the right representation into language.c, everything else will follow.
11:45:13 <ezyang> If that's not the case, then it might be a bit trickier.
11:45:21 <k0ral> http://hpaste.org/46810/forkio_and_gtk_callback
11:45:21 <ezyang> Source diving code you know nothing about is good for you! :-)
11:45:30 <monochrom> the short story is "postGUIASync" and/or "postGUISync"
11:45:40 <sm> +1
11:45:52 <k0ral> merijn: trying forkOS right now
11:45:58 <monochrom> which is actually well-documented and well-explained in the gtk2hs haddock, so there is no excuse
11:46:34 <merijn> ezyang: Speak for yourself, I dived right into existing point-free Haskell code. Still utterly confused, but now also have brain trauma....
11:47:15 * ezyang may be suffering from stockholm syndrome; he needs to rewrite the stack area allocator in GHC, but he hasn't understood the existing code yet... 
11:47:51 <monochrom> forkOS is unrelated here
11:47:59 <ezyang> But fortunately, c2hs is pretty straightforward because it's all bog standard tokenizer and parser and if there's one type of DSL Haskell is good at, it's parsing code.
11:48:09 <ezyang> (well, this bit, anyway.)
11:48:24 <dcoutts> monochrom: does initGUI allow -threaded mode these days?
11:48:35 <FUZxxl> ezyang: I like the code you write for GHC. It's clear in comparison to some other things.
11:48:37 <monochrom> yes, in fact recommended
11:48:48 <ezyang> Aww, thanks!
11:48:52 <dcoutts> monochrom: sigh, I think that's setting people up for failure.
11:49:25 <monochrom> no it doesn't
11:49:46 <dcoutts> monochrom: because they'll have no idea of the dangers and they'll get random segaults and failures
11:49:53 <monochrom> old gtk-0.11 examples and not reading docs set up people for failure
11:49:59 <dcoutts> nobody reads docs
11:50:04 <dcoutts> nor should they have to
11:50:16 <monochrom> what?
11:50:26 <ClaudiusMaximus> i use gtk with -threaded and +RTS -N  and i got random failures when i forgot to postGUI(A)Sync in the right places (as the documentation makes clear)
11:50:39 <dcoutts> yes, it's totally unsafe
11:50:49 <dcoutts> and hard to use safely even if you're aware of the issue
11:50:58 * dcoutts uses gtk2hs with the single threaded rts and uses forkIO liberally
11:51:05 <ClaudiusMaximus> it would be better if there was a GTK Monad that reminds you via the type system to use postGUI(A)Sync
11:51:11 <ClaudiusMaximus> but i don't know if that's possible
11:51:19 <dcoutts> indeed, that would be a solution
11:51:24 <dcoutts> I've thought about that a bit before
11:51:29 <ezyang> This is what we invented types for! (Well, not quite...)
11:52:02 <dcoutts> ezyang: exactly. It's a big effort however to move the whole of gtk2hs from IO () to GUI ()
11:52:28 <monochrom> if you don't read docs, how do you even know of initGUI?
11:52:31 <ClaudiusMaximus> dcoutts: true, breaking all user code (i guess inserting liftIO everywhere?)
11:52:37 <k0ral> merijn: works like a charm, thank you very much
11:52:47 <dcoutts> ClaudiusMaximus: right, though hopefully not everywhere
11:53:04 <ClaudiusMaximus> maybe something to suggest for gtk3hs!
11:53:08 <k0ral> monochrom: reading at your example, thank you, I really need references like this
11:53:08 <ezyang> Clearly all of IO should have been actually spelled as MonadIO m => m
11:53:35 <ezyang> Unfortunately, GUI programming is another one of those things that everyone wants, but no one wants to work on.
11:53:54 <dcoutts> I've been doing lots of GUI hacking recently, cleaning up ThreadScope
11:54:03 <dcoutts> it's really not that bad
11:54:04 <ezyang> How has that been going?
11:54:25 <dcoutts> eZet-: quite well, the state management is no longer embarrassing :-)
11:54:26 <ezyang> (I was referring to actually writing the GUI framework, as opposed to writing the GUI--wasn't clear)
11:54:29 <ezyang> Cool.
11:54:41 <dcoutts> oops, eZet-/ezyang
11:55:54 <merijn> ezyang: That's because GUI's, user interface and graphics implementations are not "cool" to do :p
11:55:58 <dcoutts> ezyang: there's two big things needed for gtk2hs, one is for me to do more apache configuration work on the community server so we can restore the gtk2hs website, and the other is for someone to write a new gobject code gen using the new GObject API introspection data
11:56:10 <merijn> As someone put it in the #python channel: "I have created a revolutionary AI from first principles! Also, can anyone tell me how to draw coloured dots on the screen?" :p
11:56:35 <sm> lol
11:56:36 <ezyang> Which is a shame, because as the recent interest in diagrams shows, people really do like graphics.
11:57:03 <sm> yes they do. I think it's what got many of us into computing
11:57:19 <sm> that and the sound effects
11:58:19 <sm> those came a bit later (for me, the vic-20 intro to programming course)
11:58:36 <ezyang> HTML is truly a fantastic innovation.
12:00:39 <monochrom> graphics and sound did not get me into computing. logic did. i.e., computer is more consistent than human
12:01:14 <Entroacceptor> mmmh
12:01:26 <Martty> dot dot
12:01:43 <Entroacceptor> monochrom: you really got me thinking now :)
12:04:27 <Entroacceptor> I think it was the tinkering
12:04:54 <monochrom> yes, that is also a lot of fun. it's very programmable
12:05:46 <monochrom> both human and computer are equally programmable. but computer is more consistent
12:05:47 <tolearn> which is the best learning basic book or tutorial for learning haskell?
12:06:25 <monochrom> learnyouahaskell.com
12:07:00 <tolearn> thanks
12:07:05 <Entroacceptor> ymmv, of course
12:07:11 <mafs> tolearn: List here: http://www.haskell.org/haskellwiki/Learning_Haskell -- I personally like a combination of Real World Haskell (http://book.realworldhaskell.org/) and LYAH (http://learnyouahaskell.com/)
12:08:03 <merijn> tolearn: I second LYAH (I think Real World Haskell is a nice follow-up to it)
12:08:37 <merijn> On a related note, BONUS is a god amongst men for writing LYAH :>
12:08:56 <mafs> Yeah, I agree on that as a follow-up. I read the two somewhat concurrently, but let my RWH reading lag behind LYAH a bit
12:10:14 <mreh> is there a Parsec combinator that will say "unexpected <everything I just consumed>"
12:11:24 <mreh> like a sort of token parser
12:11:53 <navaati> hello
12:12:06 <mreh> hello
12:13:19 <tolearn> i was searching for something concise and overall vision of haskell, i had read some of the ones you listed here. I like simplicity and neat syntak like Ruby. I found haskell reading learnyouahaskell and i feel it pretty interesting. I knew of Scheme and had some experience with it. Sorry my english.
12:13:41 <dylukes> Now, this may be the wrong place to ask but,
12:13:50 <dylukes> which functional language (other than Haskell) do you guys think is best?
12:13:52 <navaati> i'm re-re-reading the typeclassopedia, and i'm wondering if there is somewhere a version of the Prelude wich is "purified" of all the ugly things described in the paper (like fail, or the fact that monad is defined in term of bind instead of applicative + join)
12:14:15 <earthy> fail can not be purified
12:14:20 <zaero> LYAH was difficult for me but I'm not sure why.  I think it introduced things in a different order than my brain wants them.  I switched to reading RWH and like it better so far.
12:14:21 <dylukes> Is Monad not yet a subtype of Applicative as of HP2011?
12:14:22 <mreh> isn't that what category extras was for?
12:14:30 <zaero> Since both are free online, skim them and see what works better for you
12:14:41 <dylukes> LYAH's first few chapters,
12:14:46 <navaati> dylukes: can prolog be considered as a functional language ? then prolog
12:14:46 <dylukes> are a much better preliminary introductin.
12:14:49 <dylukes> than RWH.
12:14:57 <dylukes> but RWH is better for the intermediate stuff it seems.
12:15:05 <navaati> earthy: why ?
12:15:25 <earthy> fail is necessary for pattern matching in do syntax
12:15:47 <earthy> i.e.  do Just bar <- lookup thingy ; return bar
12:16:04 <earthy> what to do if the match fails? :)
12:16:06 <monochrom> if you like concise, "a gentle introduction to haskell"
12:16:12 <tolearn> i was having fun with LYAH until things complicated :-)
12:16:40 <mreh> don't be put off when it gets complicated
12:16:47 <tolearn> :-)
12:16:48 <mreh> it's all possible
12:16:54 <navaati> in the typeclassopedia there is "what happens if foo produces an empty list? Well, remember that ugly fail function in the Monad type class declaration?"
12:16:54 <navaati> why isn't it possible to just throw a classical "incomplete pattern" error ?
12:17:23 <dylukes> I think what I was wondering more,
12:17:31 <dylukes> is, is there a language in the haskell style,
12:17:40 <dylukes> that has a bit less… grime.
12:17:43 <mreh> Miranda :)
12:17:45 <dylukes> Or rather, cruft.
12:17:47 <mreh> grime?
12:17:50 <copumpkin> ?
12:18:01 <dylukes> oversights, special cases, etc
12:18:05 <mreh> what grime were you refering to
12:18:07 <dylukes> Existentials would be nice for instance.
12:18:14 <copumpkin> dylukes: there's a reason they aren't there
12:18:15 <andreeppinghaus> hi
12:18:19 <dylukes> I mean grime as in little bits that feel like they're misisng.
12:18:21 <copumpkin> dylukes: what other things?
12:18:22 <earthy> navaati: what would the semantics be of the do in that case?
12:18:23 <dylukes> copumpkin: Im sure
12:18:24 <dylukes> one moment
12:19:01 <navaati> earthy: i don't get what you mean
12:20:02 <earthy> do you get that do syntax is syntactic sugar for calls to >>= and function abstraction?
12:20:14 <navaati> yeah, of course
12:20:32 <earthy> that is, in the report, it is defined as a translation to >>= and abstraction
12:20:33 <byorgey> navaati: it would be possible, sure.  but one of the nice possibilities of certain monads is to model failure.
12:20:35 <andreeppinghaus> hi all, the meaning of this name command (n, _,_,) ?
12:21:03 <earthy> well, to support matching, they decided it would be 'nicer' to have the monad implicitly contain a notion of failuer
12:21:10 <earthy> well, 'monad', really
12:21:24 <earthy> because that makes things like the list and maybe monads *very* nice ;)
12:21:32 <byorgey> navaati: but you're right that there is a choice involved; the current behavior is not the only possible behavior
12:21:41 <navaati> byorgey: ins't the possibility to model error in the MonadError class ?
12:21:49 <monochrom> > runState (do { [] <- return [()]; return () }) ()
12:21:50 <lambdabot>   *Exception: Pattern match failure in do expression at <interactive>:3:15-16
12:21:54 <earthy> unfortunately the choice was made in the language report
12:21:58 <monochrom> there is your pattern failure
12:22:12 <byorgey> navaati: yes, or MonadZero.  Obviously you already know how I feel about the "fail" function being in the Monad class ;)
12:22:22 <tolearn> mathematics + programming == haskell ?
12:22:26 <monochrom> no
12:22:32 <dylukes> sorry back
12:22:34 <copumpkin> dylukes: :t True could now be Bool, or exists a. a, or exists a. Show a *> a, or exists a. Eq a *> a, or whatever else
12:22:39 <earthy> so no haskell implemantation can claim to be haskell without allowing fail in the 'monad'
12:22:39 <copumpkin> tolearn: they aren't disjoint to begin with
12:22:52 <dylukes> its less "bad things" about haskell,
12:23:02 <dylukes> and more, that I'd like to play with some other stuff
12:23:06 <monochrom> haskell won't do "math" for you if you are thinking "solve x^3 + x + 1 = 0"
12:23:07 <dylukes> like dependent typing, existentials, etc
12:23:12 <copumpkin> then move to agda :)
12:23:20 <copumpkin> #agda is friendly too
12:23:28 <dylukes> I should learn Agda actually.
12:23:29 <dylukes> If just for fun.
12:23:35 <mreh> root finding would be great for games
12:23:36 <copumpkin> it's very profound
12:23:42 <navaati> what is the difference between agda and prolog ?
12:23:44 <copumpkin> and agda helps you teach yourself advanced math
12:23:46 <FUZxxl> dylukes: Haskell has existential types
12:23:54 <dylukes> copumpkin: that'd be nice.
12:24:03 <dylukes> On a random note, I'm still trying to see how I might be able to make Hac Phi
12:24:03 <copumpkin> I like using it for that purpose
12:24:08 <dylukes> I'm in Cape Cod the weekend of.
12:24:14 <dylukes> so, I could take a bus from Boston to Phi.
12:24:23 <copumpkin> cool :) I'm in Boston too
12:24:26 <copumpkin> and so is edwardk
12:24:26 <dylukes> But, I'm not sure my parents would like me staying alone in Philadelphia over a weekend XD
12:24:37 <mreh> west philidelphia?
12:24:38 <dylukes> Still need to find a good way to pitch it.
12:24:46 <djahandarie> Yes, catch the amtrak or whatever copumpkin and edwardk are taking with them
12:24:58 <dylukes> I mean, at that point, I'll be 17...
12:25:04 <dylukes> It actually just occurred to me this morning,
12:25:10 <copumpkin> we promise not to feed you alcohol
12:25:12 <dylukes> that for the last few weeks I've been noting my age is 17.
12:25:14 <dylukes> But I'm actually 16.
12:25:15 <dylukes> Oops.
12:25:25 <fazzone> when is it good practice to have / not have type annotations (or whatever they're called)?  Only when the types can't be inferred?  All the time?
12:25:25 <djahandarie> Man, you're 16? Damn youngins...
12:25:37 * copumpkin glares at djahandarie 
12:25:42 <aristid> is it even legal to be in irc before you're 21?
12:25:48 <dylukes> aristid: Sure, why not?
12:25:53 <dankna> I have to recommend against taking a bus from Boston to Philly
12:25:55 <monochrom> I use type annotations to remind me or to help haddock
12:25:59 <aristid> dylukes: was supposed to be a bad joke :P
12:26:09 * edwardk looks up
12:26:10 <dylukes> aristid: Definitely was pretty bad!
12:26:15 <djahandarie> copumpkin, what?
12:26:16 <dankna> long-distance busses are usually lacking in bathrooms, air-conditioning, and people who didn't just step out of prison
12:26:16 <aristid> dylukes: thanks :)
12:26:22 <navaati> i hope so, if note this would be monstruous piece of shit (17 here too, but i do haskell since i'm 15)
12:26:23 <dylukes> dankna: It's a six hour bus ride.
12:26:33 <dylukes> A greyhound or something.
12:26:39 <dankna> dylukes: really?  because it's six hours from Boston to NYC and Philly is another three, by car
12:26:42 <mreh> you can't ride a single bus for 6 hours in this country
12:26:49 <dylukes> ugh, annoying.
12:26:52 <dylukes> Anyways, I used to take greyhounds quite a bit.
12:26:53 <navaati> s/note/not
12:26:56 <copumpkin> trains are fun
12:26:59 <copumpkin> expensive though
12:27:00 <dylukes> When I was 7 I went from Portland down the Mexico in a greyhound!
12:27:06 <dylukes> to Mexico*
12:27:07 <dankna> well, I'd enjoy seeing you there, but know what you're getting into!
12:27:18 <copumpkin> dankna: you gonna be at hac phi?
12:27:23 <dylukes> dankna: I grew up riding buses and trains :).
12:27:25 <dankna> yes, definitely (I already confirmed)
12:27:35 <dylukes> How many people are looking like they'll show up
12:27:38 <copumpkin> yay
12:27:44 <dankna> are you?  perhaps we can work on the cross-compilation thing haha
12:27:45 <mreh> has anyone been to Hoodlums?
12:27:47 <copumpkin> dylukes: I dunno, the attendee list on the wiki is rather incomplete
12:27:50 <mreh> London
12:27:51 <dankna> or I can work on it while you stand over me with a whip
12:27:55 <copumpkin> but join #haskell-hacphi and bug the organizers for a list
12:27:56 <dylukes> copumpkin: Seemed like it.
12:28:03 <dylukes> If I can't actually make it,
12:28:06 <djahandarie> dylukes, dmwit should have a decent list
12:28:12 <dylukes> can you guys hook me up to an arduino powered rolly-chair?
12:28:16 <dankna> dylukes: maybe your parents will spring for Amtrak if you tell them my parolee-on-the-bus story
12:28:24 <dylukes> With telephony on a laptop?
12:28:29 <dylukes> I'll be there in spirit. from the future.
12:28:34 <dankna> hehe, that'd be cool
12:28:44 <dylukes> If you work it out, I'll do it :P.
12:28:48 <dankna> I'm too cheap to buy an Arduino, I bought a knockoff with a PIC
12:28:55 <dylukes> I own a Duemillanove.
12:29:00 <dylukes> Just make it so I can control it over ssh or some shit.
12:29:03 <dylukes> :)
12:29:13 <dankna> just to bootstrap my custom thingy, heh, because I can't program the bootloader without already having one ><
12:29:18 <navaati> the ethernet module doubles the cost :(
12:29:26 <dankna> indeed
12:29:28 <dylukes> navaati: erp.
12:29:37 <djahandarie> I think I'm going to bug/help byorgey with typekinds if at all possible at hac phi :p
12:29:38 <dylukes> Wait, why would you need ethernet?
12:29:47 <earthy> !sigh
12:29:47 <dylukes> I meant you could have a laptop on Skype which I can connect too...
12:29:50 <navaati> you talked about ssh
12:29:50 <earthy> 16
12:29:55 <earthy> over half a lifetime ago
12:29:57 <dylukes> which can control the arduino via direct serial
12:30:03 <dylukes> and then the arduino just runs motors.
12:30:19 <dankna> earthy: HAH!  it's less than half my lifetime ago.  you're old! :D
12:30:23 <earthy> young enough to not have seen any windows older than '95
12:30:31 <byorgey> djahandarie: I definitely plan to be working on that again by the time Hac phi rolls around, but I'll probably actually be hacking on diagrams at Hac phi
12:30:33 <dylukes> earthy: HAH! it's my lifetime! you're old!
12:30:35 <copumpkin> dankna: how old are you?
12:30:38 <earthy> (my first windows was 2.11 ;))
12:30:39 <dankna> thirty
12:30:51 <dylukes> My first windows was 95 :O
12:30:57 <byorgey> djahandarie: but you are free to bug me/drag me into interesting conversations about it/etc. =)
12:30:58 <navaati> oh ! but then an arduinno is overkill…
12:31:02 <earthy> then again, I've been programming functionally for 17 years, so there. :P
12:31:04 <djahandarie> byorgey, hehe okay
12:31:20 <dankna> byorgey: are you working on a native Haskell diagram-rendering thing?
12:31:32 <djahandarie> byorgey, I'll actually be seeing you during that Oregon Coq thing as well
12:31:36 <copumpkin> byorgey: got an attendance list for hac phi? :)
12:31:42 <byorgey> ONE AT A TIME
12:31:54 <byorgey> =)
12:32:00 <dankna> byorgey: if so, remind me at the con to give you my ObjC code that draws pretty arrows between ellipse-shaped nodes.  I'd like it to see some use, even if it's only by being ported to Haskell.
12:32:01 * djahandarie imagines byorgey slamming his desk
12:32:05 <byorgey> djahandarie: cool, see you then
12:32:07 <monochrom> indeed, haddock specifies that a doc annotation ("-- |doc") must be before: type signature; data; newtype; type; class. so without a type signature your doc is ignored
12:32:07 <edwardk> byorgey: byorgey: byorgey!
12:32:19 <earthy> oh, is there a new typeclassopedia?
12:32:21 <copumpkin> byorgey! byorgey! byorgey!
12:32:22 <byorgey> dankna: not at this exact moment but it's high on the list.
12:32:30 <dankna> byorgey: cool :)
12:33:07 <dylukes> oh dankna
12:33:09 <dylukes> you finished that?
12:33:16 <dylukes> I thought you were having issues with the line drawing or w/e
12:33:33 <dankna> dylukes: I got that sorted, thanks to someone's help, I think it was yours, doing the line integral for me
12:33:45 <dylukes> No, I didn't do the line integral, thats for sure.
12:33:48 <dankna> dylukes: however, no, Vecky is on hold while I recapture my motivation and commune with nature.
12:33:55 <dankna> oh okay haha.  well it was someone's in here.
12:34:02 <dylukes> Line integrals are something I don't feel like dealing with >_>
12:34:19 <djahandarie> Line integrals in my #haskell ? Go back to #calculus !!
12:34:21 <dankna> the code I was offering to share is actually a separate project, although I wrote it with a mind towards incorporating it into Vecky once I generalized it a bit.
12:34:46 <dankna> http://abstrusegoose.com/156 hah
12:35:01 <merijn> dankna: I love that one :)
12:35:11 <dankna> hehe
12:35:17 <dankna> I'm reading the archives of it for the first time
12:35:31 <dylukes> Hey wait a sec,
12:35:35 <adorablepuppy> I made this hashmap thing. Getting the key works, but getting the value spits a ton of type errors. http://hpaste.org/46817/hashmap_thing
12:35:38 <dylukes> is there still an agda interactive session?
12:35:44 <dylukes> or do you *have* to use the emacs mode?
12:35:56 <merijn> dankna: Although not as much as: http://abstrusegoose.com/206
12:35:57 * djahandarie forwards dylukes to #agda
12:35:58 <Saizan> is there a spec somewhere for "typekinds"?
12:36:03 <dylukes> *sigh* oh well
12:36:06 <copumpkin> dylukes: you pretty much have to use emacs if you want to be productive :)
12:36:12 <dankna> merijn: ah yes, another good one!
12:36:12 <copumpkin> dylukes: but come to #agda and we'll sell it to you harder
12:36:16 <ion> dankna: Haha
12:36:41 <merijn> copumpkin: Ahahahahaha
12:36:48 <djahandarie> Saizan, most of it I've seen is in http://www.cis.upenn.edu/~byorgey/talks/typetype-HIW-20101001.pdf
12:36:52 <fazzone> what are some pointers for good Haskell style?
12:36:58 <merijn> "Agda" and "productive" in the same context >.>
12:37:26 <dankna> fazzone: as far as syntactic style, indentation and whatnot, there isn't really a lot of convention
12:37:27 <Saizan> merijn: there's even a productivity checker!
12:37:41 <dankna> fazzone: I think the most important thing is to not put exceptions in pure code, and not put IO everywhere
12:37:44 <Saizan> djahandarie: thanks
12:38:11 <merijn> Saizan: Pfft, so do I. It's a script that at random intervals generates a popup which says "GET TO WORK!" to snap me out of procrastinating :p
12:38:22 <fazzone> dankna: what about things like type signatures?  when should you / should not write them yourself?  Only when they can't be inferred?  all the time?
12:38:50 <ion> Whenever they’re useful for documentation (read: at least everything you export) and/or code verification.
12:38:54 <djahandarie> I feel like it might be nicer to model KindFacts when you're able to lift stuff into the type/kind level
12:38:55 <dankna> fazzone: for file-level functions, always.  for things in let expressions, whenver you feel they help.
12:39:09 <adorablepuppy> fazzone: Always write type signatures. :)
12:39:12 <dankna> "Programs should be written primarily for humans to read and only secondarily for computers to execute."
12:39:35 <ion> > {- adorablepuppy: -} ((+) :: Num a => a -> a -> a) (1 :: Integer) (2 :: Integer)
12:39:36 <lambdabot>   3
12:39:54 <monochrom> you cannot always write type signatures. not inside "let" or "where".
12:39:57 <dankna> thank you, ion.  I was going to make that joke but didn't :)
12:40:05 <dankna> monochrom: uh, let does allow signatures
12:40:17 <fazzone> dankna, adorablepuppy: thanks!
12:40:17 <adorablepuppy> ion: Well, obviously always is a loaded word.
12:40:38 <ion> Or even… (puts on glasses) overloaded?
12:40:40 <monochrom> I am referring to certain things not having type signatures writable in haskell 98/2010
12:40:55 <dankna> oh, okay
12:43:39 <merijn> fazzone: I always write signatures for top level functions, but not functions in where/let clauses (unless needed because they can't be inferred)
12:44:23 <dankna> I write them in let clauses (I don't use where clauses) whenever I feel it helps readability.  for example, if the function is three hundred freaking lines long and needs some light reading to break it up :(
12:44:37 <monochrom> I find it more flexible to not write type signatures for unexported things
12:44:57 <parcs> i try to write explicit type signatures for every single expression
12:44:58 <merijn> fazzone: Mostly because writing out a type signatures is a good intermediate step between thinking and coding to decide what the hell you need to do and how. And if you write something different from what you meant (but something that does typecheck) the compiler will yell at you, which helps
12:45:20 <parcs> the type inference system is not trustworthy
12:45:28 <merijn> dankna: If your function is three hundred lines long the solution is to STOP WRITING FUNCTIONS WHICH ARE SO DAMN LONG!
12:46:16 <dankna> merijn: actually I'm planning to ask the channel in general how I can make that function easier to maintain.  once it's performing better.
12:46:55 <monochrom> perhaps dankna's 300-line long function is a 10-line main body with 29 aux functions inside "let", each aux function 10-lines again
12:47:04 <fazzone> merijn: thank you also!
12:47:27 <dankna> monochrom: sadly, it's actually like a 2-line main body with 30 aux /variables/ inside "let"
12:47:42 <dankna> monochrom: each depending on about five previous ones
12:47:55 <merijn> Kill it with fire?
12:48:05 <monochrom> if you nest the "let"s it may be better
12:48:16 <dankna> it's already leaning pretty far to the right
12:48:19 <dankna> indentaiton-wise I mean
12:48:34 <monochrom> then my condolence
12:48:45 <uniquenick> is there a simple way to turn [(A,1),(B,1),(A,2)] into [(A,3),(B,1)]?
12:49:10 <dankna> uniquenick: yes.  one sec.
12:49:38 <adorablepuppy> My hashmap problem, annotated with actual error messages from ghci this time. http://hpaste.org/46819/hashmap_thing_annotation
12:49:51 <monochrom> > M.empty
12:49:51 <lambdabot>   fromList []
12:50:22 <monochrom> > M.fromListWith (+) [('A',1), ('B',2), ('A',2)]
12:50:23 <lambdabot>   fromList [('A',3),('B',2)]
12:50:31 <monochrom> > M.toList (M.fromListWith (+) [('A',1), ('B',2), ('A',2)])
12:50:32 <lambdabot>   [('A',3),('B',2)]
12:50:53 <monochrom> but requires your A,B's type to be instance of Ord
12:50:58 <dankna> sortBy (on compare fst) $ Map.toList $ foldl' (Map.coalesce (+) 0) Map.empty
12:51:07 <Cale> adorablepuppy: propertyValue :: Property -> a  asserts that for *any* type a that I choose ahead of time, propertyValue can take a property and give me a value of type a
12:51:21 <dankna> mine only requires A to be Ord and B to be Num
12:51:40 <dankna> note: I probably got most of the function names wrong, but they do exist
12:51:42 <monochrom> A,B are values there
12:51:55 <Cale> adorablepuppy: So, for example, if I chose (Integer -> String) as the type a, propertyValue should be able to take a Property and give me a function (Integer -> String)
12:52:06 <Cale> adorablepuppy: This is clearly not what you mean :)
12:52:15 <dankna> propertyValue _ = undefined
12:52:39 <adorablepuppy> Cale: If a isn't going to work, what can I do in that scenario?
12:52:45 <Cale> Yeah, basically the only thing it could produce with that type is the value undefined
12:52:57 <dankna> well, or it could shell out to QuickCheck and produce an arbitrary value
12:53:09 <Cale> You have to pattern match in each case where you inspect a Property, if you want to do it that way.
12:53:47 <adorablepuppy> Cale: I thought that's what I was doing below the type signature.  . .
12:54:20 <Cale> You are, but you're returning val in every case, and each of the occurrences of val has a different type, while they're supposed to match
12:54:28 <Cale> (they're all supposed to be 'a')
12:54:33 <Cale> If you wanted to, you could encode the type of property in the type system though.
12:54:55 <Cale> data Property a = Prop String a
12:55:14 <Cale> propertyValue :: Property a -> a
12:55:23 <Cale> propertyValue (Prop _ val) = val
12:55:41 <dankna> http://abstrusegoose.com/125 -- I did not know this
12:55:55 <adorablepuppy> Cale: I knew I had to be going about this in the wrong way. Thanks for your guidance.
12:56:35 <Cale> adorablepuppy: Well, this will result in static checking of the property type. You might only know what type of Property you have at runtime, in which case this won't work.
12:56:35 <hpc> dankna: omg cool
12:56:53 <dankna> hpc: yeah!  .... so is the fish using capacitance?  or what?
12:57:19 <hpc> i would guess so
12:57:35 <hpc> i never was very good at magnetism
12:57:36 <dankna> well, that's my guess as well, but only because that's what we use for proximity sensing devices, haha
12:58:10 <k0ral> hey guys, I (again) need the assistance of a gtk user
12:58:19 <navaati> yeah ?
12:58:23 <dankna> okay, I asked an EE who I know.  will report back when he answers in a few hours, if anyone is interested, haha.
12:58:33 <iande> dankna: potentially, hammerhead sharks and platypuses do it too
12:58:37 <dankna> k0ral: I don't use gtk, but I occasionally port stuff written against it :)
12:58:44 <dankna> iande: hmmm, interesting point, yeah
12:59:22 <k0ral> dankna: you tell me what you think about this then :
12:59:23 <stepkut> anyone know of a good color scheme for Haskell syntax highlighting on a black background ?
12:59:36 <adorablepuppy> Cale: That might be a problem. Perhaps I should have separate propertyValue functions for each type?
12:59:44 <dankna> I don't use syntax highlighting
12:59:45 <hpc> stepkut: i like the vim defaults
12:59:54 <k0ral> the thing is: some widgets have default handlers for some events, like keyPress event
12:59:56 <dankna> and I really don't feel Haskell has enough syntax to merit it
13:00:09 <stepkut> hpc: is there an easy way for me to find those and translate them (by hand) into css ?
13:00:26 <k0ral> in C for example, you derive a widget an reimplement those handlers
13:00:30 <k0ral> C++*
13:00:34 <mjrosenb> gnah, when was state added to mtl?
13:00:41 <k0ral> (well, C too actually)
13:00:53 <hpc> stepkut: do you have linux? i am on my phone and cannot easily mess with screen atm
13:00:59 <k0ral> and you can call the *parent* handler to perform the default operation
13:00:59 <mjrosenb> and is there a way to define something like a weak function in C?
13:01:16 <stepkut> hpc: I do.. I fonud haskell.vim, but it seems to just leverage some default colors from vim
13:01:26 <k0ral> well, I'm in a situation where I'd like to trigger this "parent" handler
13:01:35 <hpc> stepkut: then edit a haskell file :P
13:01:41 <k0ral> but I'm not able to figure out what it corresponds to in haskell
13:01:55 <hpc> the keywords are let in where module import do hiding as
13:01:57 <k0ral> ... was I clear ?
13:02:00 <hpc> iirc
13:02:09 <hpc> and qualified
13:02:14 <stepkut> hpc: well, i was hoping to actually get the color names / hex codes
13:02:23 <hpc> oh
13:02:33 <hpc> check your terminal config
13:02:52 <hpc> sorry i cant help more lol
13:03:23 <dankna> k0ral: hmm, your question was clear, but I'm not sure how gtk does that.
13:03:32 <dankna> k0ral: the answer will be found in the glib docs, not the gtk docs
13:03:52 <k0ral> dankna: good point
13:04:29 <jmcarthur> to me, syntax highlighting is nice because it at least tells me when i'm inadvertently used a keyword as an identifier
13:04:38 <jmcarthur> *i've
13:04:46 <hpc> oh! stepkut: you can also go through the stylesheets for lyah
13:04:51 <jmcarthur> or when i have misspelled a keyword
13:05:11 <k0ral> dankna: but I still don't see anything like a parent in glib :s
13:05:20 <dankna> jmcarthur: but Haskell has very few keywords and I've finally stopped wanting to use the word "type" as a variable :)
13:05:24 <jmcarthur> ideally, syntax highlighting would give me information that is not merely syntactical, *or* it would be something you assign yourself with semantic meaning
13:05:26 <mjrosenb> @src state
13:05:26 <lambdabot> Source not found. You untyped fool!
13:05:45 <dankna> jmcarthur: yes, I agree.  I want an editor that integrates the shading-for-recentness-of-changes from darcs annotate.
13:06:01 <jmcarthur> it would be pretty cool if namespacing was done with normal/bold instead of lowercase/uppercase, for example
13:06:04 <dankna> (but I'm not willing to go back to Emacs for it, so don't bother telling me about such a mode)
13:06:07 <stepkut> hpc: hmm, lyah is not much better than what I already have
13:06:08 <dankna> oooh that /would/ be nice
13:06:13 <hpc> jmcarthur: i see it as helping to see the "shape" of code at a glace
13:06:20 <k0ral> dankna: maybe using the "after" operator instead of "on"; trying right now
13:06:23 <dankna> k0ral, one sec, maybe I can solve your problem with google
13:06:33 <stepkut> hpc: I think I will just tweak what I have
13:06:35 <stepkut> hpc: thanks!
13:06:43 <hpc> so being more than just keywords is not that important
13:06:52 <jmcarthur> s/namespacing/constructor-or-variable/
13:07:20 <jmcarthur> or maybe formatting could be used to determine whether you *intend* something to be used as a keyword or as an identifier
13:07:23 <dankna> ah - they refactored the object system into its own library now, gobject
13:07:29 <k0ral> dankna: it's solved, don't bother
13:07:32 <dankna> jmcarthur: yeah, that would be nice
13:07:34 <dankna> k0ral: oh, okay
13:07:38 <k0ral> dankna: the after operator is the right answer
13:07:52 <k0ral> dankna: thank you for leading me to glib's doc :)
13:08:00 <dankna> sure thing
13:08:07 <k0ral> dankna: hadn't investigated this way
13:08:26 <Peaker> dankna: what editor are you using instead of emacs?
13:08:42 <adorablepuppy> Now that I separated out each type into it's own function, works great. Though, it's not as clean as I would have liked.
13:09:03 <dankna> Peaker: TextWrangler on the Mac.  the single biggest killer feature for me was auto-indentation but then I migrated to Haskell and that stopped working anyway :)
13:09:18 <Peaker> dankna: doesn't emacs have that?
13:09:51 <Peaker> dankna: or you mean that was emacs's killer feature?  in that case, what killer features does TextWrangler have?
13:10:04 <dankna> Peaker: not crashing all the time.
13:10:54 <jmcarthur> i'm not sure i've ever had emacs crash
13:10:54 * thoughtpolice has never had his emacs crash, and he's quite happy with haskell-mode + ghc-mod
13:11:07 <dankna> yeah, that's the problem with Emacs though:
13:11:10 <jmcarthur> actually, i've had agda-mode lock it up, but that's not emacs's fault
13:11:23 <dankna> mildly different usage styles produce vastly different experiences
13:11:32 <thoughtpolice> just the flymake stuff is wonderful, although the autocompletion could use some work (like a dropdown list, instead of having to enumerate possibilities with combined key combos)
13:11:58 <navaati> thoughtpolice: never heard of this ghc-mode, what does it do ?
13:12:09 <Peaker> I've had emacs crash some in the past, I think I might have used the nightly-snapshots back then, though.. otherwise it's relatively stable.. (it managed to freeze due to too much fast output today though)
13:12:10 <dankna> I had to turn haskell-mode off, I kept trying to use its smart indentation for when you start a new line and having to hit tab twentyish times to get to where I wanted to be
13:12:25 <jmcarthur> haskell-mode has several indentatione modes
13:12:28 <jmcarthur> *indentation
13:12:40 <jmcarthur> oh i misread
13:12:43 <thoughtpolice> navaati: it basically adds flymake + some other features to your haskell-mode. for example, it'll compile everything under -Wall and highlight all errors/warnings in the source as you type. i normally always know my code compiles by the time i leave my editor :)
13:12:56 <thoughtpolice> navaati: check it out - http://hackage.haskell.org/package/ghc-mod
13:13:08 <ktosiek> talking about indentation, are there any popular styles/guidelines for indenting haskell?
13:13:34 <jmcarthur> huh, never heard of ghc-mod
13:13:36 <dankna> ktosiek: not really, no.  I have been evolving my own with a mind towards eventually writing the aforementioned nonexistent autoindenter.
13:13:48 <thoughtpolice> the exception is working on, say, GHC - modules there don't exist in the standard hierarchal library format and there, and the build process is a bit complicated
13:13:54 <thoughtpolice> but it works wonderful for cabal projects, for example
13:13:55 <navaati> omg great, but then leksah isn't usefull anymore !
13:14:23 <jmcarthur> what i wish emacs would do is detect haskell indentation levels that are already there and maintain them if i do something that means they need to shift one way or the other
13:14:35 <thoughtpolice> navaati: kazu has never announced it IIRC, for some strange reason. it has documentation and works really well too, which is strange.
13:14:42 <thoughtpolice> er, i meant to send that to jmcarthur :)
13:14:50 <jmcarthur> ah
13:15:01 <jmcarthur> well now i'm gonna try it
13:15:16 <jmcarthur> any gotchas?
13:15:42 <thoughtpolice> jmcarthur: i haven't stressed it a lot, i mostly use the basic autocomplete for identifiers, and the flymake mode
13:16:01 <thoughtpolice> that pays itself off pretty quick IMO, like I said, for anything cabal based, i almost always know stuff builds by the time i leave emacs/switch to my terminal to build
13:16:31 <jmcarthur> does it rely on cabal to use flymake?
13:16:46 <thoughtpolice> but it works pretty well, highlights lines correctly for warnings/errors, etc. it also runs all files under -Wall by default, so you can keep warning numbers low if possible
13:17:06 <jmcarthur> yeah i keep my warning numbers at zero if at all possible
13:17:07 <thoughtpolice> jmcarthur: no, i think it just searches the paths from the root of where you started emacs, and expects the hierarchal library format to fall out from there
13:17:21 <jmcarthur> ah
13:17:40 <jmcarthur> so emacs --daemon might not entirely like it
13:17:44 <thoughtpolice> although it normally correctly determines e.g. if i start emacs under ~/code/proj, and the library hierarchy starts at ~/code/proj/src/Foo, I can launch emacs from ~/code/proj and it'll pick it up
13:17:52 <jmcarthur> ah
13:18:17 <thoughtpolice> if it could probe cabal for build info though, that would pretty much be awesome as hell
13:19:20 <dcoutts> I wonder what sort of interface it'd want
13:19:26 <thoughtpolice> jmcarthur: but yeah, i haven't stressed it hugely, but kazu's been working on it for a while, and it's really really easy to install and use if you already have haskell-mode
13:19:50 <dcoutts> problem is, you don't want it reproducing an entire build system
13:19:53 <thoughtpolice> one thing that it won't get correct though: preprocessors. she for example must be run as a preprocessor over a file, but the OPTIONS_GHC pragma will cause the line info from ghc-mod to be off by a line as a result
13:19:59 <dcoutts> it'd always be incomplete or out of sync
13:20:00 <thoughtpolice> which is slightly annoying :/
13:20:12 <dcoutts> right, and it gets worse
13:20:18 <jmcarthur> dcoutts: obviously cabal should have an emacs mode built in :P
13:20:22 <dcoutts> heh
13:20:49 <dankna> Emacs users have trained themselves not to notice that everything they use is incomplete and out of sync
13:20:52 <dankna> for example, eshell
13:21:03 <sm> thoughtpolice: I knew of ghc-mod, but not exactly what it did - good to hear that stuff
13:21:04 <jmcarthur> i disagree. i use emacs but not eshell :P
13:21:09 <dankna> haha okay
13:21:14 <dcoutts> thoughtpolice: presumably what it needs is a way to say which modules/files it wants built and to get the errors for each module reported in a way that they can be separated.
13:21:48 <thoughtpolice> ghc-mod probably isn't the "true way" to do things like this i guess. it works mostly by just invoking GHC and looking at results, and not a whole ton beyond that (the helper executable is built on the ghc-api,) i'm just not sure I want to wait around long enough for anybody to write something better :p
13:22:17 <thoughtpolice> in the face of even slightly more complicated build rules, that can totally break down sometimes
13:22:41 <dcoutts> thoughtpolice: then perhaps all one needs is to use a ghc wrapper program and to call $ cabal build ${target} --with-ghc=ghc-wrapper
13:23:32 <jmcarthur> does ghc have a flag for a machine-readable stdout/stderr format? that might be a reasonable addition (at least more reasonable than a built-in emacs mode)
13:23:40 <thoughtpolice> dcoutts: hm, that's an interesting solution! but won't cabal invoke the given GHC with lots of GHC-specific options? the regular option parser to set up DynFlags in the compiler for example, isn't exposed to the GHC-api I don't think
13:24:06 <dankna> actually I believe I saw that in the API
13:24:11 <monochrom> emacs haskell-mode is neato
13:24:14 <dcoutts> thoughtpolice: yes, lots of ghc specific options but that's ok. ghc ghci ghc --make all use the GHC API
13:24:16 <thoughtpolice> hm, things may have changed then!
13:24:22 <jmcarthur> ah
13:24:27 <thoughtpolice> dcoutts: ah
13:25:00 <Peaker> monochrom: it kinda sucks
13:25:15 <Peaker> at least all the indenters for haskell mode I used were pretty horrible
13:28:25 <monochrom> not horrible at all here
13:28:39 <NihilistDandy> Peaker: haskell-mode's awesome :D
13:28:58 <NihilistDandy> I'm quite fond of the font-lock things, too
13:32:07 <sgronblo> does haskell platform come with some sort of offline docs?
13:32:46 <NihilistDandy> sgronblo: It should. Where they are depends on your install
13:33:27 <sgronblo> NihilistDandy: where should i be looking? is it html or some sort of perldoc manpage type thing?
13:33:37 <NihilistDandy> There should be a /doc directory with a bunch of html files in it
13:33:40 <dankna> it's html
13:33:42 <jmcarthur> font lock screws up apparent indentation, for me
13:33:43 <dankna> what platform are you on?
13:33:47 <NihilistDandy> sgronblo: What system are you on?
13:34:06 <NihilistDandy> jmcarthur: Really? That's odd. I haven't seen any problems so far
13:34:59 <jmcarthur> NihilistDandy: try something like (foo :: Bar) $ do foo ; bar   -- where ";" is a newline and "bar" is aligned with "foo"
13:35:19 <NihilistDandy> kayo. Just a second
13:35:21 <jmcarthur> NihilistDandy: since font lock turns the :: into a one-wide character, when it looks like it's aligned, it actually isn't
13:36:33 <navaati> this is why font lock is shit, and unicode character replacement at the typing time is the right solution
13:36:40 <jmcarthur> err  "bar" is aligned with the second "foo"
13:36:48 <jmcarthur> i should have given the foos different names
13:36:59 <jmcarthur> navaati: yeah i like the agda input mode for that
13:37:13 <NihilistDandy> jmcarthur: hmm. I kind of see what you mean. It's off by one space.
13:37:29 <dons> huh. new high score today. 793.
13:37:32 <dons> 800 is close.
13:37:33 <NihilistDandy> Not terribly bothersome, but I can see how it could be problematic
13:38:18 <monochrom> not off by any space here
13:38:41 <jmcarthur> monochrom: different font maybe?
13:39:41 <monochrom> I don't know. I don't "customize" fonts
13:42:36 <NihilistDandy> I generally don't worry about the indentation looking off in emacs. haskellmode knows what it's doing, and if I'm worried I can just look at it in plaintext
13:45:28 <ion> The documentation for Data.Time.Clock.UTC: “UTC is time as measured by a clock, corrected to keep pace with the earth by adding or removing occasional seconds, known as "leap seconds". These corrections are not predictable and are announced with six month's notice. No table of these corrections is provided, as any program compiled with it would become out of date in six months.”
13:45:36 <ion> *zing*
13:45:56 <sgronblo> NihilistDandy: ubuntu
13:46:41 <NihilistDandy> sgronblo: What do you get when you run `which ghc`?
13:47:21 <sgronblo>  /usr
13:48:03 <c_wraith> I totally think making seconds a little longer is much better than adding leap seconds
13:48:05 <ion> I’m sure you don’t get that.
13:48:08 <NihilistDandy>  /usr what? Is that really all it returned?
13:48:17 <NihilistDandy> c_wraith: METRIC TIME
13:48:46 <c_wraith> I'm not a physicist.  I don't need a time scale that's invariant over nature.
13:48:54 <zenzike> does anyone here use leksah?
13:48:57 <c_wraith> I need a time scale that's invariant over calendars.
13:49:14 <monochrom> ion: there is Data.Time.Clock.TAI if you do have a leap seconds table
13:49:36 <sgronblo> NihilistDandy: that's interesting. which ghc seems to return the cwd.
13:49:45 <ion> Let me quote the last part again: “any program compiled with it would become OUT OF DATE in six months” (emphasis mine). ;-)
13:50:26 <NihilistDandy> sgronblo: That doesn't make sense...
13:50:39 * hackagebot diagrams-core 0.1.1 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-0.1.1 (BrentYorgey)
13:50:47 <monochrom> apparently, the way OSes deal with it is to push updates every six months
13:50:59 <NihilistDandy> ion: Heh
13:51:18 <NihilistDandy> THEY RAN OUT OF DATES
13:51:40 * hackagebot diagrams-lib 0.1.1 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-0.1.1 (BrentYorgey)
13:51:42 * hackagebot diagrams-cairo 0.1.2 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-0.1.2 (BrentYorgey)
13:52:30 <sgronblo> NihilistDandy: oh wait, maybe this update of ubuntu wiped out my earlier install of haskell platform...
13:52:46 <sgronblo> and then there was some problem with the package last time i tried reinstalling it
13:52:48 <NihilistDandy> I suppose it could have.
13:53:06 <jmcarthur> thoughtpolice: ghc-mod doesn't appear to be using -Wall by default. are you sure you didn't have to enable it somehow?
13:53:44 <sgronblo> The following packages have unmet dependencies: haskell-platform : Depends: ghc6 (< 6.12.1+) but 6.12.3-1ubuntu7 is to be installed
13:53:54 <sgronblo> this apparently hasn't been fixed yet :(
13:54:09 <ion> yeah :-\
13:54:54 <NihilistDandy> Ah
13:56:12 <monochrom> http://packages.ubuntu.com/natty/haskell-platform
13:56:45 <monochrom> it says both "ghc6 (<< 6.12.1+)" and "ghc6 (>= 6.12.1)", I wonder what it means
13:57:13 <monochrom> natty's ghc6 is 6.12.3
13:57:29 <jmcarthur> natty screwed up the platform
13:58:00 <jmcarthur> it's a known bug
13:58:06 <jmcarthur> probably won't be fixed until the next major update
13:58:09 <monochrom> perhaps time to bring up my http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
13:59:03 <sm> monochrom: how about merging that with cabal docs ?
13:59:28 <monochrom> what is "cabal docs"?
13:59:33 <sm> and updating the cabal-install web presence ?
13:59:36 <jmcarthur> dude i didn't know about haskell-mode's ghc core stuff
13:59:41 * dcoutts notes that he is currently rewriting the cabal user guide
13:59:47 <sm> \o/
13:59:48 <dcoutts> I'll be asking for feedback
13:59:51 <NihilistDandy> jmcarthur: Really?
13:59:58 <jmcarthur> yeah really
14:00:03 <jmcarthur> i had been using ghc-core
14:00:07 <byorgey> dcoutts++
14:00:20 <jmcarthur> and scrolling every time
14:00:50 <dcoutts> sm, monochrom, byorgey: currently just a new intro and quickstart:
14:00:51 <dcoutts> http://code.haskell.org/~duncan/cabal/user-guide/#introduction
14:00:52 <dcoutts> http://code.haskell.org/~duncan/cabal/user-guide/developing-packages.html#quickstart
14:01:29 <sgronblo> I guess I'll have to continue coding python then
14:01:35 <monochrom> haha
14:01:50 <monochrom> I recommend javascript
14:01:55 <NihilistDandy> jmcarthur: Maybe *I* don't know what you mean. I think I'm confused
14:01:56 <byorgey> dcoutts: cool, let me know when you're at a point where you would like some feedback
14:02:10 <dcoutts> byorgey: btw, I've also been making some changes to cabal init, based on writing that quickstart guide
14:02:19 <byorgey> dcoutts: oh, good
14:02:40 <byorgey> dcoutts: I hope to have some time to hack on it this summer as well
14:02:44 <jmcarthur> NihilistDandy: in the Haskell menu there is Load Tidy Core
14:02:46 <dcoutts> byorgey: great
14:02:52 <sgronblo> why did they have to mess up the haskell platform :(
14:03:06 <jmcarthur> NihilistDandy: it seems to open another buffer with the core output of the current file
14:03:22 <monochrom> because "they" are fallible
14:03:31 * NihilistDandy nods
14:03:48 <dcoutts> byorgey: in particular I'm making the "metadata" questions optional, so the only compulsory Q will be lib or exe
14:04:03 <jmcarthur> would be nice if it would show me just the core of the function the cursor is over, but whatever
14:04:05 <byorgey> dcoutts: yeah, that sounds like a good idea
14:04:07 <dcoutts> byorgey: so for throwaway packages you can just hit enter a few times
14:04:15 <monochrom> ah I see what "ghc6 (<< 6.12.1+)" and "ghc6 (>= 6.12.1)" means
14:04:18 <jmcarthur> i guess it's not always clear what to show
14:05:09 <dcoutts> byorgey: and I've added Q to ask if the user wants explanatory comments. I hope that'll solve the problem that the user wants it first time, but in general we don't want to have lots of very verbose .cabal files around.
14:05:09 <byorgey> dcoutts: as long as it's clear to new users that they probably do want it to ask them the optional questions
14:05:29 <byorgey> yes, great
14:05:30 <dcoutts> byorgey: it'll ask, but they all have a default, so you can always hit enter
14:05:45 <byorgey> ok, sounds good
14:05:46 <dcoutts> in some cases that default is just blank, e.g. category, or license
14:07:24 <sm> dcoutts: I suppose hackage will may complain about missing metadata at upload time, in which case that sounds great
14:07:41 <dcoutts> sm: yes, as will cabal sdist and cabal check
14:08:12 <sm> this new intro is also great, I like that you have simplified Cabal vs cabal-install
14:08:32 <dcoutts> yeah, that's one of the main things the rewrite is for
14:08:41 <dcoutts> that 'cabal' the program is the main user interface
14:08:41 <sm> "There is a command line tool, called “cabal”, that users and developers can use to install Cabal packages. " . Simple :)
14:08:59 <dcoutts> the old user guide didn't mention cabal-install at all
14:09:02 <dcoutts> talked about Setup.hs
14:10:16 <o1iver> hey guys. I am just starting out and am misunderstaning one thing: how can I pattern match a data types inner types?
14:11:01 <o1iver> lets say: data Path = Path [String]. Now why can't I do f (Path x:xs) ? Onlye f (Path x)
14:11:13 <navaati>  you need parens
14:11:15 <monochrom> f (Just (Right x : xs)) = ...
14:12:11 <o1iver> thanks guys! that just saved me some time :-) cheers
14:12:29 <monochrom> mr (Right (Just in : bieber)) = ...
14:13:22 <NihilistDandy> monochrom: lol
14:15:18 <sm> dcoutts: I imagine you'll add an explanation of cabal vs [Ss]etup.hs and when to use each
14:15:59 <monochrom> yeah that helps a lot because Setup.hs does things a bit differently
14:16:35 <dcoutts> sm: from the point of view of building packages (as opposed to creating them) I'll only describe Setup.hs in some special section about the interface for tool authors, e.g. distro packaging scripts
14:17:07 <monochrom> yes, like that, Setup.hs is when you make a *.deb or *.rpm etc
14:22:05 <sm> oh.. I would have guessed "the Setup.hs script is how a package can customize cabal's behavior. It can be invoked directly to perform some tasks, but usually you will run it via the more capable cabal tool."
14:23:28 <dcoutts> sm: I'd prefer to take the approach of describing making packages separately from building packages
14:23:29 <monochrom> that is also right. that is a whitebox view. "it's for *.rpm makers" is a blackbox view
14:24:10 <dcoutts> rather than for each feature talking about how it's used on the author and builder side
14:25:37 <o1iver> what lib function would you use to split a string by a single char?
14:26:05 <sm> sounds good. That was intended for a developer.. as a dev I would guess I shouldn't be running Setup.hs directly ever, except possibly as a convenience when cabal is not installed (but nowadays, that should be never)
14:26:42 <mauke> o1iver: http://hackage.haskell.org/packages/archive/split/0.1.4/doc/html/Data-List-Split.html#v:splitOn
14:26:56 <ktosiek> O_O
14:27:16 <o1iver> mauke: ok
14:27:33 <o1iver> mauke: I wasn't sure because it said stability = experimental
14:27:59 * ktosiek goes to change his span (==char) to splitOn
14:28:11 <mauke> meh
14:28:16 <ktosiek> I have to start to read before I write
14:28:57 <mauke> o1iver: if it does change in the future, I'll just change my code
14:29:11 <dcoutts> sm, monochrom: one issue we still have is that Setup.hs can take extra custom paramaters and we have no way for tools like cabal-install to know that and enable them to be passed through sensibly.
14:29:17 <o1iver> mauke: yeah I think I will use that for now
14:30:29 <monochrom> that one is hard to solve
14:30:32 <dcoutts> sm, monochrom: generally, in future revisions of the Cabal spec I want to make it clearer that Setup.hs is a machine interface not a human one. And perhaps start stripping out some user-oriented features.
14:30:56 <dcoutts> cut down the minimal required interface that Setup.hs must support
14:31:03 <sm> I think that sounds good.. having only one way to do things simplifies
14:31:11 <dcoutts> but choose that smaller set carefully so that it is useful as a machine interface
14:31:43 <dcoutts> e.g. "Setup.hs sdist" is not needed, but "Setup.hs sdist --output-dir" is essential.
14:31:49 <sm> monochrom: why is that hard ? it seems like cabal and Setup.hs should be using the same options processing code ?
14:31:53 * hackagebot getemx 0.1 - Fetch from emusic using .emx files  http://hackage.haskell.org/package/getemx-0.1 (BenWolfson)
14:32:11 <dcoutts> sm: remember that Setup.hs can be a totally custom implementation.
14:32:37 <dcoutts> and in theory it only has to implement a minimal number of commands and options
14:32:48 <dcoutts> that bit of the spec is now very unclear
14:35:32 <sm> I wonder if Setup.hs needs arbitrary commands/options, seems like it could get by with eg the  flags defined in the cabal file
14:36:04 <dcoutts> sm: you mean the 'flag' sections in the .cabal file?
14:36:07 <sm> yes
14:36:17 <dcoutts> those are a bit limited
14:36:42 <dcoutts> and don't (and should not) cover things like building for profiling or hpc
14:36:49 <mjk> can I make a function to convect "IO Int" to "Int"?
14:37:05 <monochrom> no, cannot.
14:37:41 <dcoutts> sm: the package author and package builder roles are different, the author supplies info in the .cabal file while the builder supplies info to the configure/build system
14:38:11 <mjk> monochrom: if I want to do this like a task, how to do it?
14:38:51 <monochrom> no, I really mean cannot be done. in haskell 98 or 2010.
14:39:04 <byorgey> mjk: see http://stackoverflow.com/questions/4235348/converting-io-int-to-int
14:39:50 <Phyx-> do or do not, there is no IO
14:39:50 <sm> dcoutts: excuse my confusion, I hope it's useful for designing docs :)
14:39:58 <sm> builder is similar to "user", right
14:40:03 <sm> the person doing cabal install
14:40:05 <dcoutts> yes, usually
14:40:22 <sm> the author creates the .cabal file and possibly a custom Setup.hs
14:40:44 <ion> IO Integer does not contain an integer, it contains a promise of doing some computation that results in an integer. You get to use that integer (eventually) by using the >>= operator.
14:40:52 <monochrom> note also that you almost never need "IO Int to Int".
14:41:37 <ion> :t (>>=)
14:41:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:41:58 <sm> I'm wondering how/if to it could be made unnecessary ever to run Setup.hs directly. I guess Cabal could have an api for Setup.hs to declare custom options/commands to be exposed some way in cabal's ui
14:42:18 <dcoutts> sm: right, that's plausible
14:42:40 <osfameron> monochrom: "almost never" ?
14:42:47 <Peaker> mjk: instead of taking the value outside of IO into your function, you take your function into IO
14:42:55 <dcoutts> sm: note that it's not just cabal-install that ought to know, IDEs would like to know this too
14:42:59 <monochrom> yes, almost never.
14:43:14 <sm> yes true
14:44:14 <mjk> I see. thanks all!
14:44:16 <monochrom> the set of times you need IO Int -> Int has measure 0.
14:45:32 <osfameron> monochrom: that looks more like "never" ;)
14:45:33 <hpc> :t randoms
14:45:34 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
14:45:36 <sm> part of my interest in this is that as an author I have this vague sense that if I try anything fancy in Setup.hs, it won't work well with the nice cabal ui (and others)
14:46:07 <monochrom> when doing FFI you need it sparingly
14:46:32 <monochrom> and therefore you can impeach me for lying about "cannot be done in haskell 2010"
14:46:42 <osfameron> heh
14:48:35 <sm> if Setup.hs was just another dumb declarative config file, I (and new users/authors) would have to think less. But I see it needs to be more powerful than that
14:48:58 <sm> I need to read that new doc
14:50:05 <sm> seems like the goal is to put as much as possible into the declarative .cabal file, and messy procedural bits are left in Setup.hs
14:50:53 <dcoutts> it's slightly more subtle than that, but in general, yes
14:52:09 <dcoutts> there's two points of view to consider: what is the minimum required to implement a Cabal package, and the other is how to we make a useful fully featured build systems that is convenient for users
14:53:32 <dcoutts> these two are rather in tension, and the solution is to allow multiple build systems and different ones to implement more or less functionality
14:53:49 <dcoutts> but that also requires that the supported features be discoverable
14:54:25 <sm> yes
14:55:27 <sm> a small issue: I usually see Setup.hs, but I think setup.hs is also supported.. and here I see ./setup for the compiled version.. any chance it could be standardised to setup.hs ?
14:56:13 * sm is reading misc.html
14:56:38 <dcoutts> Setup.hs is the most common, I don't want to add confusion by adding more variants or changing the standard one
14:56:56 <dcoutts> I've mostly managed to eliminate Setup.lhs as an alternative
14:57:04 <sm> oh, that's another one
14:57:32 <ClaudiusMaximus> :t readFloat
14:57:33 <lambdabot> forall a. (RealFrac a) => String -> [(a, String)]
14:57:37 <ClaudiusMaximus> :t showFloat
14:57:38 <lambdabot> forall a. (RealFloat a) => a -> String -> String
14:57:51 <ClaudiusMaximus> why the different constraints?
14:58:44 <sm> anyway, you said "I *will* be asking for feedback".. I should let you write
14:59:09 <sm> thanks
15:00:29 <rex_fernando> in gtk2hs, is there a way to write a custom widget?
15:01:25 <dcoutts> rex_fernando: yes, just customise a DrawArea or EventBox
15:02:50 <rex_fernando> so do you somehow subclass the DrawArea gobject within haskell?
15:03:13 <parcs> is there a way to automate the building of an executable with -dynamic in the case that it has to be compiled twice? why doesn't ghc automatically do it for you, anyway?
15:03:57 <dcoutts> rex_fernando: you can make a data type and make it an instance of WidgetClass
15:04:46 <dcoutts> rex_fernando: if you mean what GObject type will C code see, yes it'll still be a GtkDrawArea
15:05:44 <dcoutts> or whatever other top level widget you use
15:06:34 <rex_fernando> ok, so you can't create a subclass gobject subclass from within haskell then?
15:08:29 <dcoutts> rex_fernando: no, the current glib bindings do not support that (because it's basically never needed)
15:09:40 <dcoutts> it almost never matters what GObject type foreign code sees (so long as it is some subclass of GtkWidget or whatever)
15:09:57 <rex_fernando> ok, so that doesn't mean much flexibility is lost using haskell?
15:09:57 <dcoutts> rex_fernando: do you have some use case for it?
15:10:02 <rex_fernando> that's what I was curious about
15:10:12 <dcoutts> I've never found a use case for it
15:10:15 <rex_fernando> nothing specific, just curious
15:10:27 <rex_fernando> ok
15:10:29 <rex_fernando> thanks :)
15:10:37 <dcoutts> rex_fernando: the only exception is GtkTreeModel and the gtk bindings provide that case specially.
15:10:58 <spirit> could it be that ubuntu lucid lynx cannot go to sleep while leksah is running? i tried to put my laptop to sleep just then and it wouldn't. on closing leksa it went to sleep alright
15:11:11 <ezyang> Can you use Haskell's functional dependencies to do database modeling? :^)
15:11:40 <rex_fernando> ok
15:12:59 <jeffz> spirit: check the dmesg log perhaps.
15:13:40 <spirit> where do i find that?
15:15:06 <jeffz> spirit: /var/log -- this has nothing to do with haskell though, programs don't have to do anything special to make sleep work.  you might be better off asking in a linux specific channel why sleep is failing,  though dmesg should show something usually.
15:16:14 <rostayob> I've asked this question a few hrs ago, but if I have a ByteString, is there a fast way of putting the raw data in an Int? ClaudiusMaximus suggested something I think
15:18:09 <Peaker> @type runGet (get :: Get Int)
15:18:10 <lambdabot> Not in scope: `runGet'
15:18:10 <lambdabot> Not in scope: type constructor or class `Get'
15:18:26 <Peaker> @type Data.Binary.Get.runGet (Data.Binary.get :: Data.Binary.Get.Get Int)
15:18:26 <lambdabot> BSLC.ByteString -> Int
15:20:15 <spirit> cheers, jeffz!
15:20:35 <rostayob> Peaker: I could use getWord32 I guess. thanks.
15:21:33 <rostayob> Peaker: actually, getWord32 is just shifting and OR'ing
15:22:48 <Peaker> rostayob: well, shifting and oring that you won't have to do
15:24:06 <rostayob> Peaker: actually, that works on lazy bytestrings only
15:24:57 <Saizan> @hoogle readInt
15:24:57 <lambdabot> Numeric readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
15:24:57 <lambdabot> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
15:24:57 <lambdabot> Data.ByteString.Lazy.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
15:25:09 <Saizan> rostayob: ^^^
15:25:39 <Peaker> I thought "putting the raw data in an Int" meant not "read"ing it
15:26:08 <rostayob> Saizan: that reads the int digits
15:26:13 <Peaker> rostayob: you can translate it to a lazy bytestring first, but indeed the lack of polymorphism between lazy/strict bytestrings is super annoying
15:28:24 <rostayob> Peaker: mhm... there must be a fast and unsafe way :D
15:30:04 <rostayob> to be specific, I have a dumped ints in little endian and I have to convert them to Ints
15:30:26 <Saizan> rostayob: ah, yeah, sorry
15:30:57 <rostayob> what I'm doing now is  shiftL (ti b4) 24 .|. shiftL (ti b3) 16 .|. shiftL (ti b2) 8  .|. ti b1
15:31:10 <Peaker> rostayob: I am guessing that the low-level assembly can be optimized in this case
15:31:15 <rostayob> with b1..b4 being the individual Word8s
15:31:24 <rostayob> and ti being fromInteger . toInteger
15:31:26 <Peaker> rostayob: even if GHC misses the optimization op here, low-level optimizer can
15:31:29 <Saizan> rostayob: with the .Internal modules you can access the underlying Ptr and use Int's Storable instance, i guess
15:31:34 <Peaker> rostayob: there's fromIntegral
15:31:36 <Peaker> @src fromIntegral
15:31:36 <lambdabot> fromIntegral = fromInteger . toInteger
15:31:43 <rostayob> oh, right (:
15:33:04 <rostayob> wait let's profile. maybe i shouldn't worry
15:35:57 <rostayob> the thing that's taking time is fromIntegral more then the shifting
15:36:10 <Peaker> Can anyone recommend some "alternate Prelude" and basic libs? I want one with a good Num class, Iteratee-like basic file I/O taking the "obvious" function names, polymorphic strings, polymorphic container operations, etc?
15:36:11 <rostayob> is there a shortcut to go from Word8 -> INt
15:36:37 <Peaker> rostayob: fromIntegral :: Word8 -> Int      is taking a lot of time? With optimizations on?
15:36:50 <hpc> @free f :: f a -> g a
15:36:51 <lambdabot> Extra stuff at end of line
15:36:52 <rostayob> Peaker: no, sorry, wrong row
15:37:00 <hpc> bah
15:37:12 <rostayob> well actually
15:38:28 <rostayob> i have some trouble in interpreting the profile data
15:39:03 <rostayob> http://hpaste.org/46820/profile that's what I have, "takeInt" is the function that gets 4 bytes and shifts them to form an Int
15:39:31 <rostayob> it is definitely taking time
15:44:25 <dons> Peaker: such a Prelude doesn't exist. nice idea though
15:46:15 <Peaker> dons: I saw a bunch of other Preludes, I guess each of them "fixes" one particular thing
15:46:53 <dons> mostly type class hierarchies
15:46:58 <dons> but i like this idea of fixing io subsystems
15:52:40 <parcs> how does one dynamically link an executable with cabal?
15:53:13 * hackagebot riak 0.5.0.0 - A Haskell client for the Riak decentralized data store  http://hackage.haskell.org/package/riak-0.5.0.0 (BryanOSullivan)
15:54:08 <parcs> ghc-options: -dynamic doesn't cut it because this ghc complains that the executable has to be compiled twice
15:54:32 <hpc> can you ignore the warning?
15:54:39 <hpc> or is it an error?
15:54:45 <parcs> it's an error
15:55:34 <parcs> "Dyanmic linking required, but this is a non-standard build (eg. prof). You need to build the program twice: once the normal way, and then in the desired way using -osuf to set the object file suffix."
15:56:03 <parcs> not sure what's so non-standard about the build, though
15:56:05 <dcoutts> parcs: see cabal configure --help
15:58:44 <hew> hi
15:58:51 <parcs> dcoutts: can you elaborate? i can't spot what i'm supposed to spot
15:59:03 <dcoutts>     --enable-executable-dynamic    Enable Executable dynamic linking
15:59:15 <parcs> i don't see that anywhere
15:59:35 <dcoutts> parcs: what version of ghc and cabal are you using?
15:59:55 <hew> anyone know why "tryhaskell.org" showing Terminated! message when typing "something" at lesson1/step2?
16:00:01 <parcs> ghc 7.0.2, cabal-install 0.10.2, Cabal 1.10.1.0
16:00:14 <hpc> hew: what is ':t something'?
16:00:20 <hew> "name"
16:01:13 <hew> it was right after typing in 5 + 7.... it instructs to type "chris"
16:01:20 <hew> Terminated! message occurs
16:01:23 <dcoutts> parcs: hmm, you're quite right sorry. It's only in cabal head. I'd forgotten that.
16:02:10 <hpc> hew: looks like the server is overloaded
16:02:15 <parcs> dcoutts: yeah actually i saw that the commit for that occurred in january
16:02:16 <hpc> hew: try typing in '5'
16:02:36 <hew> yes
16:02:38 <parcs> and the latest version of Cabal/cabal-install are from march...
16:02:57 <hew> so just try it when it's not so busy then
16:03:16 <hew> thanks hpc
16:03:58 <dcoutts> parcs: there's two branches on the go, head branch and the stable cabal-1.10 branch
16:04:23 <dcoutts> parcs: so that's why you might see new features being committed that do not appear in stable releases
16:04:33 <parcs> oh okay
16:05:30 <dcoutts> we're committed to keeping a stable API for a release series, e.g. 1.10.x and that often precludes backporting new features
16:06:17 <parcs> is darcs.haskell.org/cabal-install/ still the official repo?
16:07:19 <dcoutts> yep
16:07:36 <dcoutts> parcs: but you need the darcs.haskell.org/cabal/ repo really
16:08:07 <dcoutts> perhaps both, I'm not sure if the released cabal-install still builds against Cabal head
16:08:33 <parcs> i'll get both
16:10:30 <parcs> by the way, your repositories are using a deprecated format
16:12:37 <krey_> hi, can someone help me understand adjunctions using haskell?
16:16:39 <krey_> it's quiet here today...
16:31:27 * hackagebot hsignal 0.1.3.6 - Signal processing and EEG data analysis  http://hackage.haskell.org/package/hsignal-0.1.3.6 (VivianMcPhail)
16:32:27 * hackagebot llvm 0.9.1.1 - Bindings to the LLVM compiler toolkit.  http://hackage.haskell.org/package/llvm-0.9.1.1 (BryanOSullivan)
16:35:52 <Peaker> Do people manage to use ghci's debugger? Is it usable with IO actions or only with pure code? Is it usable with an executable that's going wrong, or do you have to re-compile in ghci mode?
16:36:03 <ezyang> I don't use ghci's debugger.
16:36:46 <jmcarthur> i too am not a fan of the ghci debugger
16:37:18 <jmcarthur> not sure about executables. should be possible to use with IO or pure code though
16:37:18 <noses> one big restriction is that it can only step through interpreted code
16:44:12 <Peaker> noses: which seems completely opposite to what you'd typically want and what *sounds* easy to implement
16:47:57 <jmcarthur> why is that what you would typically want?
16:48:59 <c_wraith> people who use debuggers usually think of them as tools they can attach to a running program in a strange state
16:50:34 <mjrosenb> does anyone have experience using State StdGen?
16:50:47 <mjrosenb> or RandomGen g => State g for that matter?
16:51:52 <Peaker> jmcarthur: because you have a program that doesn't work
16:51:58 <Peaker> jmcarthur: so typically that's what you would want to debug
16:52:18 <Peaker> jmcarthur: if it's just a small component you're still writing, you don't really need a debugger most of the time, it's all still fresh in your mind and you can just make a change or two and get ir giht
16:52:23 <Peaker> get it right, that is
16:56:54 <jmcarthur> Peaker: presumably you could just load the main file and run main, though, no?
16:57:15 <Peaker> jmcarthur: if you can debug IO actions (ideally without recompilation), then yeah
16:57:35 <Peaker> But apparently you can only debug pure code
16:57:40 <jmcarthur> oh, huh
16:59:29 <noses> Peaker: where did that "apparently you can only debug pure code" come from?
16:59:33 <mjrosenb> if i compile a program with -threaded, then run it with -N4, without doing any explicit threading, will my program be able to take advantage of the extra threads in any way shape or form?
17:00:07 <noses> no
17:00:49 <Peaker> noses: oh, I may be wrong, can it step through IO code?
17:01:05 <noses> maybe ghc's garbage collector will run things in multiple threads
17:01:33 <mjrosenb> that is kind of dissappointing
17:01:43 <mjrosenb> not horribly suprising, but still, dissapointing.
17:02:09 <noses> annotations to do things in parallel are not difficult to add
17:02:10 <m3ga> @hoogle parseTime
17:02:10 <lambdabot> Data.Time.Format parseTime :: ParseTime t => TimeLocale -> String -> String -> Maybe t
17:02:10 <lambdabot> Data.Time.Format class ParseTime t
17:02:20 <noses> it's more difficult to get a speedup
17:03:34 <mjrosenb> noses: i suspect i'll be able to get a speedup
17:03:42 <m3ga> if I use parseTime to parse something like "Tue May 17 17:32:35 2011 +0100" into a ZonedTime and then use formatTime with the same format string I used for parseTime, shouldn't I get the same string I started with?
17:03:42 * JuanDaugherty .oO(naivete/unrealistic expectation)Oo.
17:04:31 <mjrosenb> noses: however, i have no clue where annotations should be addded, since places where parallel  may occur are in monads
17:04:41 <mjrosenb> noses: that being said, what annotations are these?
17:05:20 <ddarius> Peaker: There is no limitation on what type of code the GHCi debugger can work on.  How would it even know?
17:05:59 <Peaker> ddarius: well, the difference would be whether stepping through with the debugger performs side-effects or not
17:09:24 <ddarius> Peaker: 1) You can easily check what it does, 2) what do you expect it do when it does step through IO code, explode?
17:11:42 <jmcarthur> mjrosenb: the GC is parallel, so there is a little chance of a free speedup there, at least
17:12:01 <Peaker> ddarius: I'd expect it to only debug evaluation, not execution
17:12:31 <jmcarthur> Peaker: in ghc there isn't a huge difference, is there?
17:12:39 <jmcarthur> i mean in terms of implementation
17:13:25 <jmcarthur> i mean... i don't see how it could evaluate IO without executing it
17:13:30 <ddarius> Peaker: Why would you expect that?
17:13:34 <noses> and ghci has never executed IO for you either?
17:13:51 <ddarius> Peaker: And why wouldn't you just check?
17:14:06 <Peaker> ddarius: because I'd say: "debug evaluation of main" and it's just give me back an opaque IO ()  value and say "done".. not sure how I could tell it to step through main
17:14:18 <jmcarthur> have you tried?
17:14:25 <Peaker> No, I'm explaining my expectations :)
17:14:28 <jmcarthur> :P
17:15:12 <ddarius> Peaker: And if you stepped through unsafePeformIO main what would you expect?
17:15:47 <jmcarthur> for some reason that made me laugh
17:15:53 <mjrosenb> so one of the functions that i have is findBest :: Int -> (a -> a -> Ordering) -> (State StdGen a) -> (State StdGen a)
17:15:54 <jmcarthur> i need to take a break from my computer
17:16:24 <pastorn> jmcarthur: no! don't!
17:16:32 <pastorn> you might get hurt!
17:16:49 <mjrosenb> which splits the input stream in half, runs the input state, then recurses n times, running with n different PRNG's
17:17:01 <mjrosenb> and combines the results using a simple selection function
17:17:15 <mjrosenb> i suspect that this can be parallelized pretty easily
17:18:16 <jmcarthur> pastorn: i'm making coffee. that means BOILING WATER. dangerous stuff
17:18:55 <Peaker> ddarius: ah, that might work
17:20:17 <pastorn> jmcarthur: you're a brave soul
17:30:09 <noses> haskell is the best imperative language; I'm having some trouble with reversing a list in place http://hpaste.org/paste/46821/inplace_reverse_annotation#p46822
17:36:17 <ddarius> noses: Why don't you write some helper functions that make that not so godawful.
17:37:15 <noses> ddarius: is it possible to avoid the   e <- newIORef E   though?
17:37:35 <noses> the one in revinp
17:38:17 <dmwit> No, because your top-level type is not a pointer.
17:38:44 <noses> is that a defect in haskell?
17:38:57 <dmwit> No, it's there in the usual reverse-in-place algorithm as well.
17:39:08 <dmwit> You just don't notice, because newIORef E is written NULL.
17:39:27 <ddarius> dmwit: He could reuse the one that is already in the list.
17:39:43 <dmwit> Yes, I suppose so.
17:40:35 <ddarius> Though it would be more sensible to have a global constant one, and yes, the issue comes from the asymmetry in the type.
17:47:03 <tg_> without looking ahead, is the <*> applicative functor for Sets the power set?
17:47:14 <tg_> cause the <*> for lists looks awfully like that
17:47:30 <copumpkin> nope
17:47:32 <copumpkin> and nope
17:47:42 <copumpkin> it's a cartesian product of function application
17:47:46 <tg_> wrongness in droves
17:47:51 <sipa> anyone familiar with using lhs2tex in separate source files?
17:47:52 <tg_> in both cases?
17:48:03 <copumpkin> Set isn't an Applicative functor, sadly
17:48:09 <tg_> awh :(
17:48:12 <sipa> so with each file piped through lhs2tex separately?
17:48:22 <copumpkin> tg_: it could be with moar language features that do not exist yet
17:48:25 <copumpkin> but it currently is not
17:48:37 <tg_> copumpkin: just to satisfy curiosity, like what?
17:48:43 <tg_> don't say dependant types
17:48:46 <copumpkin> constraint families
17:48:47 <copumpkin> nah :)
17:48:49 <tg_> whew
17:48:56 <copumpkin> the issue is that
17:49:01 <copumpkin> list can hold anything you throw into it
17:49:05 <copumpkin> Set has some restrictions
17:49:13 <Peaker> @type fmap
17:49:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:49:16 <tg_> everything has to be a set...
17:49:23 <tg_> no
17:49:28 <copumpkin> :t S.fromList
17:49:29 <lambdabot> forall a. (Ord a) => [a] -> S.Set a
17:49:35 <copumpkin> note that Ord a constraint
17:49:43 <copumpkin> you can only stick Ord'ey things into it
17:49:43 <tg_> the set has to have a total ordering
17:49:49 <copumpkin> you can't have a Set of functions, for example
17:50:02 <Peaker> whenever you use fmap, the compiler lets you choose whatever "a" and "b" you'd like. "a" is fine for a set because "f a" is evidence you have Ord in it. But "b" must be Ord for fmap to work on a set
17:50:03 <tg_> but if you knew the range and domain of the functions, you could fake it?
17:50:04 <copumpkin> anyway, that's why Set can't currently be a functor
17:50:16 <copumpkin> tg_: sort of
17:50:34 <copumpkin> but with the worst efficiency you can imagine
17:51:01 <copumpkin> and even then, only if the domain is finitely enumerable/compact and the codomain is in Eq
17:51:06 <copumpkin> which would still be constraints on it
17:51:17 <tg_> copumpkin: I once printed a blank piece of paper in Wordpad to get it from the back of my printer to the front, so I could reach it without moving at all.
17:51:30 <tg_> copumpkin: yeah, interestingly I am pretty sure that is the case here
17:51:41 <tg_> codomain being in eq, I don't know
17:51:58 <tg_> i'm not hip with all of the co- things... the codomain is the range?
17:52:07 <tg_> or the kernel of an image, in groupspeak?
17:53:09 <tg_> no. the codomain is everything in the domain but not in the image
17:53:35 <tg_> no, the codomain *is* the image.
17:53:44 <tg_> you should know, being a copumpkin and all.
17:54:01 <copumpkin> I just mean the range
17:54:03 <copumpkin> the output of the function
17:54:40 <tg_> ok, thanks. back to study.
17:55:24 <copumpkin> np
17:55:25 <tg_> one more thing... <*> is the cartesian product in some sense, what does that make pure in the same analogy
17:57:57 <ion> How would you put (a -> b)s into a set?
17:58:13 <tg_> ion: asking me?
17:58:16 <geheimdienst> @instances Eq
17:58:16 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
17:58:25 <ion> yes
17:58:28 <copumpkin> ion: easy! you'd write an Ord instance for it :)
17:58:33 <ion> :-)
17:58:46 <geheimdienst> first come first served
17:59:01 <tg_> if the functions run over a countably infinite set with a known supermum and infimum
17:59:02 <copumpkin> to write such an Ord instance
17:59:09 <tg_> then you can always get an Ord out of it, I'd guess
17:59:10 <tg_> but I am not sure
17:59:25 <tg_> (the Pisot-V numbers)
17:59:51 <copumpkin> in my enumerable package, I have an instance for enumerating functions of a given type
17:59:54 <copumpkin> to get an ord instance
18:00:03 <copumpkin> you'd just see which of the two comes first in the enumeration!
18:00:03 <copumpkin> :P
18:00:19 <tg_> right, and the P-V numbers are totally ordered, I think
18:00:25 <tg_> if I understand the concepts right
18:02:04 <tg_> ... which raises the question, do I?
18:02:29 <tg_> If you know the exact order type of a set... then you can determine the order type of the power set
18:02:41 <tg_> so if you limit functions to that as a domain, then you can get a total ordering?
18:07:19 <nkpart> http://code.google.com/p/ideah/source/list <- Interesting
18:08:14 <ddarius> codomain usually means the set -containing- the image.
18:09:15 <tg_> ok, "the image of a function is a subset of its codomain"
18:10:00 * ddarius runs to get sushi.
18:10:39 <tg_> a "surjection" function is defined as: a function whose codomain = image.
18:10:40 <tg_> hmm
18:11:01 <tg_> i really dislike those names (in,sur,bi)-jection
18:11:19 <ion> sur-curious
18:11:42 <tg_> lol
18:12:00 <tg_> someone who wants to try putting anything in them
18:12:54 <tg_> what else lies between <functor> .. <applicative> .. <monad>
18:13:22 <tg_> byorgey's typeclassopedia seemed to say nothing, at least nothing commonly used?
18:13:25 <copumpkin> there's pointed and/or apply between functor and applicative
18:13:33 <copumpkin> pointed is boring, apply is nice
18:14:04 <tg_> pointed is just pure, yes?
18:14:13 <tg_> I asked before, in the <*> = cartesian product analogy, what is pure?
18:14:20 <tg_> a norm?
18:15:36 * tg_ wishes to hear "that's stupid", if that's stupid
18:15:49 <ion> “that’s stupid”, if that’s stupid
18:15:56 <tg_> â
18:15:58 <tg_> gracias
18:16:11 <tg_> I should have said iff, though. :?
18:17:47 <tg_> I do wish there were an internet award for most helpful chatroom in the universe, because #haskell would win it, hands down.
18:19:02 <ion> The set consisting of just the single value perhaps.
18:19:48 <ion> (Ignore me, i’m ignorant of set theory.)
18:20:29 <tg_> that would have to be the unit?
18:20:46 <tg_> {e}
18:21:46 <ion> I guess
18:22:14 <tg_> it's the only thing guaranteed to be in both sets, other than the empty set
18:22:38 <tg_> hum. anyway, back to study.
18:28:23 <danharaj> Is there any way to tell ghc to put all of the object files it generates and whatnot into a separate directory from the source?
18:28:45 <tg_> -odir <dir>
18:29:02 <tg_> http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/separate-compilation.html#output-files ?
18:29:13 <danharaj> tg_: thanks.
18:49:03 <greenland> #haskell, is there a way I can make two self-referential variables without causing an infinite loop when the console decides to print one of the values out?
18:50:44 <Axman6> not really, unless you have some way of limiting the depth to which you print
18:51:08 <greenland> I assume im "doing it wrong" then, and theres a better way to get the functionality I want?
18:51:22 <parcs> greenland: maybe try the data-pprint package?
18:52:36 <Axman6> greenland: what are you trying to do...
18:53:51 <greenland> i've a construct thats basically 4 corners, and they specify the opposite corner... abstract visual logic for a game, so there may be multiple ways to implement it
18:59:22 <Cale> There's no real distinction between self-referential and infinite.
18:59:24 <greenland> originally implemented in python where doing the same thing would just result in it printing the memory address of the referenced variable instead of the infinite recursion
18:59:52 <Cale> If you want to build graph structures which are more easily inspected and modified, use Data.Map or Data.IntMap
19:00:25 <Cale> You can use Int "addresses" in an IntMap, for example, like you would use pointers in memory.
19:00:37 <greenland> Cale: thanks
19:07:57 * hackagebot plot-gtk 0.1.0.5 - GTK plots and interaction with GHCi  http://hackage.haskell.org/package/plot-gtk-0.1.0.5 (VivianMcPhail)
19:10:24 <Krimpet> Hello, folks, I was wondering if anyone knew anything about this odd error I'm getting when I try to compile a Happy-generated parser. Happy spits out a parser fine, but when I try to compile it, I'm getting: Parser.hs:494:31: Not in scope: `happyError'
19:11:53 <Krimpet> Oh, duh, I have to declare it myself.
19:12:56 <Krimpet> Just noticed that. :)
19:15:17 <ddarius> > let a = const 2 b; b = const 1 a in (a,b)
19:15:17 <lambdabot>   (2,1)
19:15:26 <ddarius> Keine Probleme.
19:17:01 * hackagebot plot-gtk 0.1.0.6 - GTK plots and interaction with GHCi  http://hackage.haskell.org/package/plot-gtk-0.1.0.6 (VivianMcPhail)
19:24:23 <ivanm> preflex: seen Cale
19:24:23 <preflex>  Cale was last seen on #haskell 23 minutes and 59 seconds ago, saying: You can use Int "addresses" in an IntMap, for example, like you would use pointers in memory.
19:24:30 <ivanm> Cale: you still here?
19:32:25 <ivanm> does anyone know what the dual graph of a single edge would be?  Is it just a single node or a node with a loop?
19:32:48 <Cale> ivanm: hey
19:32:53 <Cale> It's a node with a loop
19:32:57 <ivanm> good-o
19:33:11 <Cale> There's an edge in the dual graph for every edge in the original.
19:33:23 <ivanm> now to find out why my planar code doesn't like it when two faces adjoin more than once...
19:33:33 <ivanm> (it repeats the same damn edge :@)
19:42:15 <JuanDaugherty> that sounds like a meaningless query, how is a single edge a graph?
19:42:49 <JuanDaugherty> and if it were I would think it was self dual
19:42:52 <ivanm> JuanDaugherty: OK, a graph consisting of only 2 nodes and an edge between them
19:43:28 <ivanm> there's only one face though; ergo, the dual has one node
19:48:44 * ivanm grumbles at his current setup not allowing for proper calculation of duals
19:49:14 <ivanm> I've been bitten by the "every edge has an inverse" requirement :s
20:18:38 <ivanm> hooray for abusing my serialising code to make a really simple dual-graph function! ;-)
20:23:54 <danharaj> aughhh
20:24:15 <danharaj> can anyone familiar with the opengl library tell me why this might fail to load a texture? http://hpaste.org/46823/
20:29:45 <JuanDaugherty> you'll prolly get a solution quicker by asking why it did in fact fail and supply more detail about that
20:29:56 <JuanDaugherty> *supplying
20:29:59 <danharaj> I don't know why it failed.
20:30:14 <danharaj> I am running gdebbuger and all I know is that the texture isn't being loaded.
20:39:24 <ivanm> danharaj: usage of opengl is rare enough that emailing the list is probably a better idea
20:49:17 <JuanDaugherty> boy just when I was thinkin how spiffy HP and stuff were becoming, I tried cabal installing leksah
20:51:28 <ivanm> JuanDaugherty: you'll probably need to install gtk2hs-buildtools yourself first
20:51:48 <JuanDaugherty> no there's a mess of other problems
20:51:51 <ivanm> and depending on your distro/OS, you'll have to install gtk+ libraries yourself
20:52:14 <NemesisD> hi all, i'm about to upload my first package to hackage, had a few questions. First, it warns "exposed modules use unallocated top-level names: Web"
20:52:29 <JuanDaugherty> said spiffiness is more important to me than anything leksah might have
20:52:47 <NemesisD> the preview the package checker shows none of the modules i export as having links to their documentation. is this just how the checker works or would my uploaded project not have those links?
20:53:04 <ivanm> NemesisD: just how it works
20:53:13 <ivanm> as the previewer doesn't actually try running haddock
20:53:49 <Jafet> Web.Scale?
20:54:00 <JuanDaugherty> (i.e. haskell pkg problems)
20:54:07 <NemesisD> ivanm: oh ok. should i worry about the toplevel Web missing? i used the hs-twitter package as a template for my project structure since it is in the same domain sort of
20:54:24 <ivanm> NemesisD: Jafet heh
20:54:26 <NemesisD> * and hs-twitter defines Web.Twitter
20:54:36 <ivanm> NemesisD: what is your package about?
20:54:56 <NemesisD> ivanm: it implements the campfire API. campfire is a web-based project group chat from 37signals
20:55:24 <ivanm> would Network work?
20:55:38 <ivanm> the web packages seem to generally just have their own specific modules :s
20:55:55 <NemesisD> if that is the best fit, sure. i just interpreted network as being more low level stuff like TLS or HTTP libs
20:56:10 <tyler-iphone> can i declare functions that use IO outside of main?
20:56:17 <ivanm> yeah, it's a bit ambiguous
20:56:23 <ivanm> tyler-iphone: sure
20:56:41 <Jafet> You can declare functions that use IO inside of main, too.
20:56:53 <tyler-iphone> ivanm: ok wasn't sure. so i can only invoke IO bound stuff inside main, but im not limited to declaring them there
20:57:05 <ivanm> not at all
20:57:39 <tyler-iphone> ivanm: "not at all" as in i'm correct, or i'm incorrect?
20:58:24 <ivanm> "you're not limited"
20:58:29 <tyler-iphone> Jafet: thnx
20:58:54 <NemesisD> ivanm: what do you mean by declaring their own specific modules?
20:59:20 <Axman6> tyler-iphone: how do you think all the IO functions are declared in the Prelude =)
20:59:46 <tyler-iphone> Axman6: oh, that makes it obvious ;)
21:00:09 <ivanm> NemesisD: Yesod has Yesod.*; etc.
21:00:17 <ivanm> they all have their own top-level namespace
21:00:39 <tyler-iphone> the reason im asking, is because im trying to use haskell's separation of pure/impure and apply it to the way i program in other languages
21:00:50 <Jafet> Many of them are Web Frameworks (tm), so they can get away with it
21:02:21 <NemesisD> oh
21:03:16 <jhickner> does this look right? new brew install of haskell on OSX and getting weird regex errors: http://hpaste.org/46824/weird_regex_behavior
21:04:17 <NemesisD> oh weird. you have to ask some guy for a hackagedb account?
21:05:07 <jeffz> I signed up for a hackage account yesterday, took <24 hours.
21:05:25 <Jafet> Um, you thought it was like github?
21:05:27 <ddarius> NemesisD: Ross isn't just "some guy."
21:05:36 <ddarius> And welcome to the Haskell community.  It's tight knit.
21:06:15 <NemesisD> sorry. some guy was a comment on his singularity and the fact that its a person, not a comment on his merit ;)
21:06:38 <NemesisD> Jafet: yes, or rubygems/packaging systems in other languages
21:07:10 <ddarius> Currently the security of Hackage depends on members not being evil.
21:07:15 <NemesisD> it seems fitting in any case considering haskellers who, to paraphrase "think a long time before they code"
21:07:55 <ddarius> (Amazingly, this has worked fine for the past several years.)
21:07:58 <NemesisD> fair enough. the world will survive for <24 hrs without my amateurish haskell library ;)
21:08:24 <Jafet> jhickner: the instance is now in Text.Regex.Posix.String
21:09:11 <Jafet> Hm, and there doesn't seem to be a Bool instance anymore
21:09:37 <blbrown_win3> is there a haskell that works on minix.  Or one that would be easiest to port?
21:09:42 <jhickner> Jafet: thanks, that works
21:10:52 <jeffz> blbrown_win3: hugs might work with little or no effort.
21:12:28 <Jafet> http://hackage.haskell.org/trac/ghc/wiki/Building/Porting looks straightforward enough
21:13:33 <dankna> except it lies!  cross-compilation is currently broken afaik
21:14:34 <Jafet> I don't know much, but minix 3 should have enough of posix, gnu and linux (through packages) for it to work
21:15:17 <dankna> the issue is http://hackage.haskell.org/trac/ghc/ticket/3472
21:15:41 <dankna> you can't compile your new GHC on Minix 3 because GHC only bootstraps from GHC,
21:15:50 <dankna> and you can't compile it on another platform because you can't cross-compile (currently)
21:17:57 <Jafet> That's sad
21:18:12 <pikhq> How the heck did they manage to build it on seperate architectures?
21:18:15 <dankna> in several ways, yes.  I'm ostensibly working on fixing it as part of a larger problem.
21:18:44 <dankna> pikhq: it used to work.  if you /really/ need to bootstrap you can play games with a chain of old versions.  I did that to get my x86_64 OS X binaries.
21:19:02 <pikhq> dankna: Oh, *jeeze* that's painful.
21:19:06 <dankna> it is
21:19:28 <pikhq> So, to get GHC on a new architecture you literally need to make it work on a *chain* of architectures?
21:19:33 <pikhq> Erm, chain of GHCs.
21:19:35 <pikhq> *vomit*
21:19:48 <dankna> at present, yes.  note that donations of programming effort to remedy this are gladly accepted.
21:19:59 <Jafet> You also need to port gcc first, I imagine.
21:20:14 <Jafet> And perl, because those older GHCs use the evil mangler
21:20:23 <ivanm> Jafet: newer GHCs still use it
21:20:27 <dankna> well, yes, but few architectures are genuinely new
21:20:28 <pikhq> Jafet: I consider that a non-issue, as GCC works on most architectures that you're able to still build on.
21:20:29 <ivanm> if you use -fvia-c
21:20:31 <JuanDaugherty> getting to work on a new architecture == porting
21:20:51 <JuanDaugherty> why would you think it would be a "just works" kind of thing?
21:20:53 <ddarius> Hey, you could have to port LML build HBC and then bootstrap GHC through a generation of implementations.
21:20:58 * dankna is going to be introducing an entirely novel architecture sometime around six months from now when he gets around to FPGA design :)
21:21:32 <JuanDaugherty> i.e the class/course?
21:21:38 <pikhq> JuanDaugherty: There's a difference between "just works" and "needing to write a backend for *every version of GHC in a chain of them*".
21:21:43 <dankna> it will be an instruction set based on STG, which may or may not be a good idea but it will be fascinating to learn from, either way.
21:21:51 <dankna> no, self-directed experiments
21:21:56 <pikhq> Erm.
21:22:03 <pikhq> Difference between "porting" and
21:22:29 <ddarius> dankna: Learning?  On your own?  Heaven forfend!
21:22:41 <Jafet> Port gcc once... that's your backend. Hopefully.
21:23:00 <dankna> ddarius: yeah, I had a false start when I couldn't get a Verilog hello-world to run, but it turned out the simulator I was using wasn't 64-bit-clean and I fixed it by using a different one.
21:23:10 <pikhq> Jafet: GHC outputs fairly architecture-specific C, I thought.
21:23:20 <dankna> GHC's C is highly arch-specific, yes
21:23:24 <pikhq> And hence you'd need to port it *even if* you used -fvia-c
21:23:57 <pikhq> If it weren't for that, you could just grab the C output of GHC and cross-compile that.
21:24:07 <Jafet> Yes, but that doesn't change on every version of GHC.
21:24:13 <dankna> note that doing so would not get you a working native compiler
21:24:20 <dankna> wait, yes it would
21:24:28 <dankna> sorry, it's after midnight here :)
21:24:29 <jeffz> blbrown_win3: you might try jhc too
21:24:39 <Jafet> It would, but it wouldn't get you a working arch-specific GHC
21:24:44 <dankna> right, okay
21:24:46 * JuanDaugherty would personally consider it hubristic to tackle a ghc port to a really new arch and would not even have to think about leaving to glasgow
21:25:14 <dobblego> I have a copy of LYAH to give away. I want to give it away to noobs who are just learning, by setting them some haskell/FP challenge and give me the best solution. Any suggestions?
21:25:18 <jrick> ghc on OpenBSD/loongson would make my day
21:25:22 <pikhq> How many archs does GHC even target, anyways? x86 and x86_64 and... What else? ARM, maybe?
21:25:44 <JuanDaugherty> *leaving it
21:25:56 * stepcut attempted a port of GHC to arm back in the day.. I did actually compile one simple haskell app using it that run on ARM..
21:26:05 <dankna> ARM is a third-party port not in the main tree yet.  we do target PPC and SPARC.
21:26:07 <m3ga> linux-powerpc is currently broken in head
21:26:20 <dankna> though I don't think anyone would actually notice if PPC were broken completely
21:26:27 <m3ga> i noticed
21:26:40 <dankna> there's also the broken JavaScript backend, which I think it is quite important to revive someday
21:26:54 <pikhq> Ah, PPC and SPARC. The other architectures that have had any reason for a backend in the past 10-15 years.
21:27:02 <ddarius> dobblego: Wouldn't the person who gives you the worst answer be the person most in need of it?
21:27:02 <stepcut> dankna: didn't someone just do work on ghcjs?
21:27:14 <dankna> just recently?  not that I heard
21:27:16 <dobblego> ddarius: yes I've heard that argument, but that's not fun
21:27:40 <dankna> how about the most /surprising/ answer gets the book
21:28:16 <dobblego> all submissions will be people who have had one hour exposure to haskell/FP -- I'm sure the best solution will still need the book
21:28:34 <JuanDaugherty> why would anybody want the physical book? OCD?
21:28:46 <dankna> to read on the subway because they don't have an iPhone
21:29:01 <stepcut> dankna: http://article.gmane.org/gmane.comp.lang.haskell.cafe/88970
21:29:08 <JuanDaugherty> compensating the author is the only good reason I can think of
21:29:13 <dobblego> the publisher sent us 3 copies. My son stole mine and took it to school. The other was stolen by an OCD paper addict. The other is up for grabs
21:29:18 <dankna> stepcut: ah!  excellent
21:29:37 <ddarius> JuanDaugherty: Many people prefer books.  I do, though I mostly read from my computer.
21:29:42 <dankna> god that's quite a hack to get output out of the thing.  not surprising.  when I looked at their older version of the code it was a hack too :(
21:29:42 <ddarius> (Papers are expensive.)
21:29:54 <stepcut> dankna: yeah.. and of course, you can now boot linux in your browser on a virtual 486.. so we can just target that too ;)
21:30:13 <dobblego> so no suggestions then?
21:30:22 <ddarius> dobblego: I forgot the question.
21:30:31 <dobblego> for a problem to set
21:30:36 <dankna> stepcut: yes, I'm aware.  how is performance on that?  when I tried it out, it spent a few minutes loading and then told me Safari wasn't supported.
21:30:54 <stepcut> dankna: worked fine for me on chrome.. about 20bogomips
21:31:05 <dankna> how many mhz is that ^^'
21:31:11 <dankna> well, cool
21:32:58 <stepcut> dankna: around a 40Mhz 486DX I think
21:33:08 <dankna> ah that's pretty nice!
21:33:13 <Jafet> But only when spinlocking
21:33:22 <pikhq> Well, it *is* from Fabrice Bellard.
21:33:40 <pikhq> If anyone could get "reasonable" performance out of a PC emulator in Javascript, it would be him.
21:33:50 <stepcut> pikhq: :)
21:33:58 <dankna> I don't know of him
21:34:19 <Jafet> I wonder if you can run his tcc-linux bootloader in it
21:34:40 <Jafet> And boot linux from source in a javascript 486 emulator
21:34:41 <pikhq> dankna: You may know him for qemu, tcc, ffmpeg, 2 entries in the IOCCC, and Bellard's formula for computing digits of pi.
21:34:41 <mzero> he wrote major portions of QEMU i believe
21:34:59 <mzero> and the image used in his x86/JS page includes tcc
21:35:14 <dankna> ah, okay, yes, those works are familiar to me :)
21:36:25 <stepcut> he also wrote an emacs clone
21:36:36 <dankna> that was a waste ><
21:36:40 <stepcut> :)
21:36:42 <dankna> if you're going to write a text editor it should be novel
21:36:53 <pikhq> Oh, yeah, he did, didn't he. I was only naming stuff just about anyone knowledgable would have ran into, though.
21:37:06 <stepcut> maybe he added proper tail recursion and pre-emptive multitasking -- that would be nice.
21:37:53 <mzero> well... if we can find a JavaScript implementation in emacs-lisp... then we can run.... oh never mind
21:37:55 <mzero> :-)
21:37:56 <pikhq> (at least one of his IOCCC entries was especially notable: it was the highly obfuscated compiler for a subset of C)
21:37:58 <dankna> maybe he made it provide a consistent user experience across all platforms and work styles, rationalized and combined the diverse input schemes, ...
21:38:15 <dankna> hah nice!
21:38:55 <Axman6> a pretty impressive compiler too, included everything: preprocessor, parser, and code generator
21:39:01 <stepcut> emacs 24 will have it's own package manager (similar to apt-get, cabal, etc)
21:39:13 <mzero> Yo dawg, I heard you like to run linux on x86… …so we put linux on x86 in your JavaScript so you can run linux on x86 while run JavaScript while you browse on linux on x86!
21:39:51 <dankna> > fix meme
21:39:52 <lambdabot>   Not in scope: `meme'
21:40:17 <Jafet> Once you port X11 to it, you can then run a browser in it
21:40:29 <pikhq> Axman6: Yeah, he later deobfuscated it to make tcc.
21:40:36 <Axman6> yeah
21:40:49 <Axman6> tcc is pretty cool, you use it to write C scripts
21:41:12 <pikhq> And boot a kernel without a bzimage.
21:41:53 <stepcut> Axman6: no, you use qemacs to write the c scripts and tcc to compile
21:42:27 <Axman6> uh, yeah :P
21:42:31 * ddarius hasn't heard of the Novel text editor.
21:42:45 <stepcut> while running linux in a browser that is running under linux in qemu :)
21:43:11 <stepcut> while watching movies using ffmpeg
21:43:20 <Axman6> at 0.1fps
21:43:32 <stepcut> nah, you use ffmpeg on the host system
21:43:37 <Axman6> which would probably be a decent speed for that setup
21:47:29 <ivanm> what do people think of the diagrams in the dual graph section of http://code.haskell.org/~ivanm/Data-Graph-Planar.html ?
21:47:36 <ivanm> are they understandable?
21:47:52 <dankna> better than nothing I guess
21:47:57 <mzero> oh - I bet tibbe knows...
21:48:08 * tibbe appears
21:48:18 <mzero> what is MUT_ARR_PTRS_FROZEN?
21:48:28 <mzero> i suspect it has to do with my use of Vector
21:48:34 <ivanm> dankna: was that aimed at me?
21:48:46 <dankna> ivanm: yes
21:48:47 <tibbe> it's the header used in the heap object for MutableArray#
21:48:54 <tibbe> actually Array#
21:49:05 <mzero> huh - I'm using only immutable Vectors.....
21:49:16 <tibbe> they are built on top of Array#
21:49:18 <mzero> but, er, well, making many of them
21:49:18 <ivanm> I'm not particularly happy with the sample dual graph... but I'm rather limited with ASCII art :s
21:49:23 <mjrosenb> is there anything like on, but also does fmap?
21:49:24 <mzero> these things don't seem to be going away
21:50:13 <tibbe> it's a word stored in the array heap object header, if you allocate arrays, you get those
21:50:38 <tibbe> mzero: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects?redirectedfrom=Commentary/Rts/HeapObjects#Arrays
21:50:46 <mzero> that is to say, I should have about 300k Vectors at anyone time... but I have over 300Mbytes of these things
21:51:11 <Axman6> o.O
21:51:22 <Axman6> time for a better data representation?
21:52:00 <mzero> hmmm.... maybe
21:52:03 <tibbe> hmm
21:52:12 <tibbe> are these appearing in profiling somewhere?
21:52:22 <mzero> yah
21:52:23 <mzero> yeah
21:52:34 <mzero> everything else in the profile is constant
21:52:43 <tibbe> link?
21:53:19 * mzero wonders if there is a hpaste like thing for images... but guesses not....
21:53:37 <jeffz> mzero, imgur.com
21:55:03 <mzero> http://imgur.com/AhzDV
21:56:02 <tibbe> lists holding on to vectors?
21:56:39 <tibbe> MUT_ARR_PTRS_FROZEN are the actual vector payloads (and are accounted for separately from the Vectors that reference them)
21:56:48 <tibbe> that's my interpretation
21:57:26 <mzero> so those are the actual lists of pointers to the thunks
21:57:43 <mzero> my Vectors are 128 long
21:58:10 <mzero> is a reference to a thunk 4 or 8 bytes (on a 32-bit machien)
21:59:02 <tibbe> right: so the MUT_ARR_PTRS_FROZEN are the 128*WORD_SIZE + GC HEADER worth of payload in your vectors
21:59:20 <tibbe> Vector is just the Vector constructor (which contains a pointer to the Array# and a few Ints)
21:59:50 <mzero> source here, btw: https://bitbucket.org/mtnviewmark/haskell-playground/src/58c51e1746b8/blog/Prefix.hs
22:00:09 <tibbe> http://darcs.haskell.org/ghc/includes/rts/storage/Closures.h
22:00:17 <tibbe> scroll down to StgMutArrPtrs to see the header
22:01:11 <tibbe> the same struct is used for both immutable and mutable arrays, just the header differs
22:01:30 <tibbe> that's how you can have O(1) freeze :: mutable -> immutable
22:03:53 <mzero> so let's see....    350k vectors x (128 entries each x 4 bytes each ref + 4 bytes header) = 175MB
22:04:05 <mzero> I'm seeing double that...
22:04:39 <mzero> hmmm... so prehaps vector accum is the culprit....
22:05:58 <tibbe> the Vector constructor adds another 4 words per Vector
22:06:12 <tibbe> also the MUT_ARR_PTRS_FROZEN header is more than one word
22:06:29 <mzero> well, the 128 entries still dominates
22:06:44 <tibbe> right
22:06:48 <tibbe> just FYI
22:06:57 <mzero> maybe I'm barking up the wrong tree (as it were) here....
22:07:01 <tibbe> it's 3 words + SIZE >> 8 bytes
22:07:25 <tibbe> the SIZE >> 8 bytes if for a card marking table used by the GC
22:07:37 <tibbe> but you're right, the payload definitely dominates
22:08:08 <tibbe> there might also be some slop as arrays are not allocated in the nursery but rather using the "big object" allocator
22:08:12 <mzero> I'm trying to write a blog post about how a lazy infinite data structure isn't just about being "clever" -- but lets you structure your code nicely -- wihtout having to sprinkle tests and initialization code throughout your functions
22:08:20 <tibbe> not quite sure how it works, you'd have to ask Simon M
22:08:28 <tibbe> ah
22:08:30 <tibbe> nice
22:08:50 <tibbe> feel free to paste the code if you want me to have a look
22:09:30 <mzero> yeah -- I compare HS to CPP.. then show how in CPP you'd "solve" the code mess by writing operator[] overloads that would initialize the structure as you go.... effectively writing a lazy infinite structure in CPP
22:09:44 <tibbe> ah
22:09:52 <tibbe> cool :)
22:10:47 <mzero> "See, you (the C++ programmer) already knew about lazy infinite data structures!   So now the Haskell one is understandable... and 1/3 the lines of code.... and paralellizable with just one code line change.... etc..."
22:11:42 <tibbe> :)
22:13:34 <blackdog> taking over the world with the judicious and ruthless application of sweet reason
22:19:14 <pmatey> Hello all. Is there a way to ignore dependency requirements when using cabal? I'm trying to install "hs-twitter" and I've manually built/installed "mime" but cabal still complains about incompatible "mime" dependecies (base 3). Thanks.
22:20:06 <ddarius> People all over the world, join hands, start a Lb train, Lb train
22:32:58 <c1de0x> is there a typeclass for 'streams' which supports (seek,tell,read,write) operations?
22:44:32 <jeffz> what's the non-whitespace layout equiv for case statements?
22:44:37 <jeffz> @pl \x -> case x of ;True -> False
22:44:38 <lambdabot> (line 1, column 17):
22:44:38 <lambdabot> unexpected ";"
22:44:38 <lambdabot> expecting variable, "(", operator or end of input
22:47:32 <jeffz> @pl case 2 of { (1) -> "A"; (2) -> "B"; (3) -> "C" }
22:47:32 <lambdabot> (line 1, column 11):
22:47:32 <lambdabot> unexpected "{"
22:47:32 <lambdabot> expecting variable, "(", operator or end of input
22:51:47 <ivanm> anyone care to provide feedback on the documentation in http://code.haskell.org/~ivanm/Data-Graph-Planar.html ?
23:09:09 <c1de0x> has anyone ever done a parsec type library/extension for bitstreams?
23:09:27 <c1de0x> (i.e. where the primitive tokens are variable length bit-sequences)
23:10:24 <kmc> you could make Parsec 3 do that, couldn't you?
23:11:01 <kmc> wouldn't the primitive tokens be just 0 and 1?
23:12:09 <c1de0x> well. ideally i'd like to use 'bitstream' tokens.
23:12:18 <c1de0x> although, not necessarily from http://hackage.haskell.org/package/bitstream
23:12:47 <c1de0x> i.e. i'd like to be able to specify an arm decoder in 'pseudo-ebnf'
23:13:52 <kmc> yeah, you can do that in Parsec
23:14:02 <kmc> you can make it parse any stream type
23:14:22 <c1de0x> hrm. maybe it's worth a shot.
23:14:43 <kmc> http://hackage.haskell.org/packages/archive/parsec/3.1.1/doc/html/Text-Parsec-Prim.html#t:Stream
23:14:44 <c1de0x> how would i get it to consume a single bit though?
23:15:06 <kmc> note that there's already an instance «Monad m => Stream [tok] m tok»
23:15:11 <kmc> so you can already parse a [Bool]
23:16:21 <kmc> if you're adapting Parsec to a new stream type, you'd build some "primitive" parsers using Text.Parsec.Prim.token
23:16:28 <kmc> in the case of bitstreams, you just need 0 and 1
23:33:05 <argiopeweb> I'm trying to find aspect ratios of a variety of images. Does a library exist which can handle this, or do I need to find individual libraries for [jpg, png, gif, etc] and pick and choose as necessary?
23:33:59 <kmc> perhaps you can use SDL-image
23:34:19 <c_wraith> GD might work
23:34:44 <argiopeweb> Hmm, hadn't thought about sdl... *investigates*
23:34:44 <kmc> stb-image does a few formats
23:35:02 <kmc> or you can shell out to "convert"
23:35:24 <jeffz> generate some html+js from haskell and access the properties from the dom, *duck*.
23:36:48 <manateeUser> /join #test123
23:37:16 <argiopeweb> jeffz: You'd better watch it. I keep a slapping-trout around for people like you. <.<
23:37:39 <jeffz> hey, it eliminates the need to call out to strange and foreign C libraries.
23:38:21 <argiopeweb> jeffz: This is true... I can't say that querying the dom via JS is any better though.
23:41:38 <argiopeweb> kmc: SDL-image has a generic load, which I like, though I'll have to use the surface operations to get dimensions. c_wraith suggested GD, which has a simple width/height tuple function, but it only supports jpeg and gif and has separate load functions.
23:41:59 <argiopeweb> And I'm not even going to get into dealing with raw data from stb if I can help it. ;)
23:43:17 <kmc> argiopeweb, well, there's the part where Javascript is a vastly better language than C for applications programming
23:44:38 <argiopeweb> kmc: Indeed. I'll probably end up going with the sdl route in the end.
23:45:00 <kmc> for example it seems stb has the property that untrusted images can pwn your program
23:45:10 <kmc> i wonder how many users of the Haskell library are aware of this caveat of the C library
23:45:17 <kmc> which it seems is not documented in the Haskell documentation
23:45:38 * roconnor <3 PSQueue
23:46:26 <argiopeweb> kmc: Probably all the ones who didn't immediately load the .c and associated website.
23:48:38 <kmc> what website?
23:52:16 <argiopeweb> kmc: Shouldn't have assumed. I only pulled up the .c without looking at any websites. I assumed that one of the two websites would contain greater detail on the code/its limitations, but I was apparently wrong.
23:53:41 <kmc> i guess one should expect that a random undocumented C library is vulnerable to many buffer overflows and other nastiness
23:53:50 <kmc> it's not something i expect of Haskell libraries
23:55:10 <argiopeweb> kmc:  Ah, the dangers of haphazardly writing wrappers around C libraries instead of writing fresh Haskell libraries.
23:55:23 <argiopeweb> They add that little spice of excitement we all need in life.
23:55:30 <kmc> or carefully writing wrappers around C libraries
23:55:49 <kmc> where here "carefully" means "reading the first 10 lines of the C library's documentation and copying that warning to your docs"
23:56:20 <argiopeweb> lol...
23:56:26 <argiopeweb> This also works.
23:57:37 <kmc> i feel like for every programmer using C for a good reason there's ten using C out of ignorance or machismo
23:58:18 <argiopeweb> Tcsh... Macho men use asm.
23:58:31 <kmc> i guess it is not so surprising, when schools teach that the alternatives to C are Java and various "scripting languages" with awful interpreters
23:58:42 <argiopeweb> kmc: Matlab? :P
23:58:47 <kmc> haha
23:59:22 <vLK> Quite the opposite, ignorant programmer despise C
23:59:23 <kmc> no, macho men write "C" but make sure that each statement relies on Undefined Behavior™ so that it's actually no more portable than asm, and less readable at that
