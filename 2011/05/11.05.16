00:00:01 <rothwell> not sure where i'd make that change
00:00:01 <kamatsu> might have to edit the makefile
00:00:10 <rothwell> hehe, the makefile is about seven lines
00:00:21 <rothwell> let me see...
00:00:29 <kamatsu> anything which includes agda compiler options?
00:00:57 <rothwell> yeah, think so
00:01:05 <rothwell> what units can i pass for -K?
00:01:13 <kamatsu> bytes i believe
00:01:23 <kamatsu> make it bigger than 8388608
00:01:58 * rothwell rebuilds
00:03:15 <kamatsu> the agda compiler isn't that efficient
00:03:26 <kamatsu> it seems to assume gobs and gobs of ram is available.
00:03:32 <rothwell> 89692 m0            1 118    0  2347M  2325M CPU4    4   1:32 100.00% agda
00:03:42 <rothwell> it's certainly up to something
00:03:45 <kamatsu> compiling the entire stdlib will take some time
00:04:03 <kamatsu> I tend to just compile on the fly as I import stuff in emacs
00:04:06 <rothwell> it does have plenty of memory to work with in this case, at least
00:04:23 <kamatsu> then again, my pet project at the moment is rewriting that whole stdlib
00:04:31 <kamatsu> I think it's pretty crappy, to be honest.
00:04:34 <rothwell> ah, right
00:04:45 <rothwell> hehe, i've no opinion yet... not been able to use it
00:05:00 <kamatsu> it's poorly documented and in some cases sacrifices clarity for generality
00:05:23 <kamatsu> Some of the stuff in it is quite painful to use
00:06:04 <rothwell> hoping i won't need much
00:10:10 <rothwell> it's still running the checks
00:10:14 <rothwell> certainly seems a lot happier
00:25:11 * hackagebot repa-devil 0.1.1 - Support for image reading and writing of Repa arrays  http://hackage.haskell.org/package/repa-devil-0.1.1 (DonaldStewart)
00:56:52 <rothwell> agda standard library is downright mastaburtory
00:57:15 <rothwell> is there really some practical benefit to calling Nat 'ℕ'?
00:57:48 <alexbagel> @google define mastaburtory
00:57:50 <lambdabot> http://actionman-nickspix.blogspot.com/2007/09/worst-of-year.html
00:57:50 <lambdabot> Title: Nick's Pix: THE WORST OF THE YEAR
00:58:51 <rothwell> maybe i meant mαϛταβυrτσrϒ
01:08:31 <alexbagel> is there a generic version of "words" or "lines"? to split on a different char
01:11:58 <frerich2> alexbagel: There is a whole module dedicated to splitting lists, see http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
01:12:25 <Jafet> unfoldr (something . span c)
01:12:36 <boegel> is there a way to avoid scientific syntax when showing Double values?
01:12:42 <boegel> > show 0.00000001
01:12:43 <lambdabot>   "1.0e-8"
01:12:52 <Jafet> *cough* printf?
01:12:55 <boegel> I don't want this ^
01:13:19 <Jafet> *uncough*
01:13:20 <alexbagel> frerich2: ooh fun, i'll check it out, thanks
01:14:25 <boegel> > printf "%lf" 0.00000001
01:14:25 <lambdabot>   Ambiguous type variable `a' in the constraints:
01:14:26 <lambdabot>    `Text.Printf.PrintfType ...
01:14:27 <jan247> kamatsu, Axman6. thanks btw for the help :)
01:14:33 <boegel> > printf "%lf" (0.00000001 :: Double)
01:14:33 <lambdabot>   Ambiguous type variable `a' in the constraints:
01:14:33 <lambdabot>    `GHC.Show.Show a'
01:14:33 <lambdabot>      a...
01:14:44 <boegel> > printf "%lf" (0.00000001 :: Double) :: String
01:14:45 <lambdabot>   "*Exception: Printf.printf: bad formatting char l
01:14:52 <boegel> > printf "%f" (0.00000001 :: Double) :: String
01:14:53 <lambdabot>   "0.00000001"
01:14:56 <boegel> nice
01:18:42 <Jafet> > ""++ printf "%f" 1e-8
01:18:43 <lambdabot>   "0.00000001"
01:19:05 <boegel> that works too, but it's ugly imho :)
01:19:06 <Jafet> Must be all the type inteference
01:19:25 <boegel> Jafet: it kind of hides what you're trying to do
01:20:16 <nlogax> reminds me of JS.. "2" + 1 === "21", but +"2" + 1 === 3  (it's not the same at all but gross :)
01:20:48 <ectospasm> my brain hurts
01:20:57 <liyang> rothwell: Well it *is* ℕ.
01:21:21 <quicksilver> > let asString :: String -> String; asString = id; in asString $ printf "%f" 1e-8
01:21:22 <lambdabot>   "0.00000001"
01:21:41 <quicksilver> see also showFFloat and showGFloat
01:21:49 <liyang> rothwell: it's still three keystrokes: \bn
01:22:02 <liyang> rothwell: (and because we can.)
01:23:18 <ectospasm> I'm _slowly_ working through the Hercules beetle book.  Functional programming is just not intuitive, and the authors' examples call upon my memories of Lisp, but it's not helpful.
01:26:44 <empity> ectospasm: it is intuitive if you are a mathematician
01:26:52 <empity> not if you are a java programmer ;)
01:27:48 <ectospasm> I'm just trying to learn it so I know what I'm doing with xmonad.hs.
01:27:50 <ectospasm> (-;
01:35:26 * jeffz glares at cabal.
01:36:44 <jeffz> cabal.exe: HENet-0.0.1: library-dirs: .libs is a relative path (use --force to override) \n $ cabal build --force \n cabal.exe: unrecognized option `--force'
01:50:29 <empity> jeffz: well means that --force is not recognized
01:50:32 <empity> not much to sayh
01:51:42 <yitz> ectospasm: did you try LYAH? perhaps that will tickle your intuitive bone a little more.
01:51:59 <yitz> @where lyah
01:51:59 <lambdabot> http://www.learnyouahaskell.com/
01:52:13 <jeffz> empity: yes, my point is it's somewhat contradictory, it says to use --force but force isn't accepted
01:53:12 <yitz> jeffz: --force is an option of install, not build. or perhaps it will work if you put --force between cabal and build?
02:05:05 <isomorphic> so, I have declare a newtype, that's a tuple
02:05:18 <isomorphic> and I've made the tuple an instance of Ord
02:06:26 <isomorphic> What I'd really like is to be able to do comparisons in relation to either of the first and second tuple parts
02:06:26 <isomorphic> whereas making it an instance only gets me one or the other
02:06:26 <Jafet> Sounds cool
02:06:34 <isomorphic> what's a more correct way of doing this, perhaps using the type system?
02:06:53 <yitz> isomorphic: why, you can define your instance however you'd like
02:07:05 <tibbe> isomorphic, one newtype for each way you want to define <=
02:07:15 <Jafet> :t Data.Ord.compare
02:07:15 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
02:07:26 <isomorphic> tibbe - that sounds like a plan
02:07:47 <quicksilver> or just have different functions to compare by first or second?
02:07:54 <quicksilver> do you actually need it to be an Ord instance at all?
02:07:55 <Jafet> Does what you're doing need an Ord instance at all?
02:08:03 <tibbe> isomorphic, so the default tuple does lexicographical comparison, first it compares the first part and if that's equal it compares the second
02:08:26 <isomorphic> Yup - the tuple is a way of representing a tree
02:08:35 <isomorphic> first member has the total count of descendents
02:08:40 <isomorphic> second has a string
02:08:55 <isomorphic> I'm solving the longest repeated substring problem
02:09:24 <isomorphic> so, the condition I'll ultimately look for is the "deepest" descendent having at least n descendents
02:09:51 <isomorphic> where deepest is the longest string (in my case) since I'm collecting an array of these tuples
02:09:52 <tibbe> hmm, it quite unintuitive that a single element array is created by newArray (0,0)
02:10:33 <liyang> does anyone still use array? Thought it was all vector these days.
02:10:35 <isomorphic> see, I'd like to be able to find (in a list of my tuples) the longest string, using, say the function maximum
02:10:42 <isomorphic> (which requires it to be an instance of Ord)
02:11:03 <tibbe> isomorphic, is there a maximumBy?
02:11:13 <liyang> :t on
02:11:13 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
02:11:14 <tibbe> liyang, I'm writing a test for GHC
02:11:24 <isomorphic> but I'd also like to be able to compare numbers of descendents
02:11:26 <tibbe> liyang, so I can't depend on vector
02:11:33 <liyang> tibbe: aah. D:
02:11:48 <liyang> :t compare `on` snd
02:11:48 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
02:11:59 <liyang> :t comparing snd
02:11:59 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
02:12:00 <isomorphic> Ah - yes, that would be a good option
02:23:58 <ourfrank`> When I ask ghci about the type of (+), I get a func that takes (Num a)'s. But when I declare (let add = (+)) and then ask the type of add, I get a func that takes Integer's. Why does this happen?
02:24:14 <quicksilver> ourfrank`: it's called the monomorphism restriction
02:24:24 <Jafet> let-bindings are not polymorphic
02:24:25 <quicksilver> http://www.haskell.org/haskellwiki/Monomorphism_restriction
02:24:39 <Jafet> :t let add = (+) in add
02:24:40 <lambdabot> forall a. (Num a) => a -> a -> a
02:24:42 <sipa> you can declare it explicitly to be Num a => a -> a -> a
02:24:59 <Jafet> :t let add x y = x + y in add
02:25:00 <lambdabot> forall a. (Num a) => a -> a -> a
02:25:09 <quicksilver> Jafet: let bindings are too polymorphic :P
02:25:10 <ourfrank`> Thanks, guys! Now I know what the NoMonomorphismRestriction extension does.
02:25:20 <quicksilver> > let x = id in (x 3,x 'a')
02:25:20 <lambdabot>   (3,'a')
02:25:24 <manateeUser> Hello everybody
02:25:26 <Jafet> Er, they are in our fairyland
02:25:44 <quicksilver> they are in the fairyland of haskell, yes.
02:26:20 <quicksilver> that lambdabot test I just did is haskell98
02:33:38 <eikke> did anyone ever experiment with using InfiniBand RDMA from Haskell? (i.e. not MPI or IPoIB, but more low-level verbs)
02:34:05 <isomorphic> Thanks to all before - ended up learning the 'comparing' combinator
02:34:28 <mm_freak> Jafet: let bindings are polymorphic, just not by default
02:34:37 <mm_freak> and i don't think it has anything to do with the monomorphism restriction
02:34:50 <mm_freak> it has rather to do with the new type inference algorithm in GHC 7
02:35:02 <mm_freak> in older GHCs let bindings were polymorphic by default
02:35:08 <poltak> What about Java?
02:36:19 <Kaidelong> mm_freak: New defaulting rules?
02:37:06 <mm_freak> Kaidelong: no, new type inference rules
02:38:33 <mm_freak> i've read a paper about the new type inference algorithm…  IIRC the new algorithm avoids some problems in the context of certain type system extensions
02:39:11 <mm_freak> and it also allows you to use ScopedTypeVariables less often, although i still prefer explicit type signatures
02:40:33 <Jafet> I thought scoped type variables was necessary if you were anal about explicit type signatures
03:02:31 <blackdog> is there a safe equivalent of (!!) ?
03:02:58 <blackdog> hoogle doesn't give me anything for Int -> [a] -> Maybe a
03:03:19 <quicksilver> listToMaybe . take 1 . drop n ? :P
03:04:02 <blackdog> (and fair enough, "don't use !!, it's slow" is sensible too)
03:04:03 <HugoDaniel> blackdog: try the Safe package
03:04:40 <HugoDaniel> http://hackage.haskell.org/package/safe
03:04:42 <HugoDaniel> here
03:04:57 <blackdog> that looks cool
03:04:59 <HugoDaniel> it is one of the first packages i usually add to my modules
03:05:06 <blackdog> not sure i want to adda  whole new package for one use, though
03:05:18 <HugoDaniel> the other one is a module to do some proper error handling i created
03:05:20 <Jafet> (spoon .) . (!!)
03:05:26 <HugoDaniel> yeah, or spoon
03:05:35 <HugoDaniel> spoon is usefull for all those cases that you dont find in safe
03:05:43 <quicksilver> yuck
03:05:53 <HugoDaniel> http://hackage.haskell.org/package/spoon
03:05:58 <quicksilver> I can't believe you can talk about spoon like its' a serious choice.
03:06:15 <quicksilver> spoon is for working around other libraries with major design errors which you are unable to fix
03:06:19 <Jafet> I wasn't
03:06:21 <quicksilver> it's absolutely not to be used with (!!)
03:07:11 <quicksilver> list have a weak API for getting nth elements - which it would be nice to fix. But it does partly reflect that lists aren't a great structure for getting nth elements.
03:07:27 <osfameron> why does it make it Maybe (i.e. at that point, why not just make it MonadFail generically?)
03:07:47 <Jafet> I could counter with spoon.head
03:08:00 <quicksilver> osfameron: false generalisation
03:08:08 <quicksilver> osfameron: how does MonadFail contain any more information than Maybe?
03:09:00 <Jafet> Polymoarphism
03:09:24 <osfameron> quicksilver: then you could use it in IO or [] and get a sensible result out of it
03:10:07 <quicksilver> osfameron: but it's a trivial adapter to use it in either of those cases
03:10:23 <osfameron> fair enough
03:10:28 <quicksilver> and gratuitous polymorphism just increases the number of errors which don't throw error messages
03:11:02 <Kaidelong> @hoogle listToMaybe
03:11:02 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
03:11:13 <Kaidelong> > listToMaybe [1..10]
03:11:14 <lambdabot>   Just 1
03:11:34 <Kaidelong> @ty (listToMaybe .) . drop
03:11:35 <lambdabot> forall a. Int -> [a] -> Maybe a
03:11:35 <osfameron> aha.  I was thinking of the Not just Maybe pattern I'd heard of, which seems to be deprecated now anyway, http://www.haskell.org/haskellwiki/Not_just_Maybe
03:12:43 <quicksilver> osfameron: certainly people disagree with that argument ;)
03:12:57 <Kaidelong> > let (!!) = ((listToMaybe .) . drop) in (!!) <$> [[1..10]] <*> [1..11]
03:12:58 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
03:12:58 <lambdabot>         against inferred type ...
03:13:08 <osfameron> quicksilver: I take the point about gratuitious polymorphism though
03:13:09 <quicksilver> there was a long discussion about it in the context of map lookup, I think.
03:13:18 <Kaidelong> > let (!!) = flip((listToMaybe .) . drop) in (!!) <$> [[1..10]] <*> [1..11]
03:13:19 <lambdabot>   [Just 2,Just 3,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9,Just 10,Nothing,No...
03:14:01 <Eduard_Munteanu> Dependent lists would be an even safer way.
03:15:59 <wjt> is there a good reason for the name of ‘spoon’?
03:16:18 <Eduard_Munteanu> Then again, bounds isn't the only concern.
03:16:36 <Eduard_Munteanu> Off-by-one errors might still be common.
03:16:41 <quicksilver> wjt: it's reference to the film 'the matrix' I believe.
03:17:17 <wjt> i see
03:27:03 <Eduard_Munteanu> Hrm, type-level nats seem a bit dubious in Haskell... I wonder how you'd do Fin or stuff like that.
03:28:28 <Eduard_Munteanu> n < k for Fin k might be usable, but it needs explicit proof passing, I guess.
03:39:48 <ezyang> @seen fuzxxl
03:39:48 <lambdabot> Unknown command, try @list
03:39:48 <preflex>  fuzxxl was last seen on #ghc 19 hours, 55 minutes and 58 seconds ago, saying: Oh yes. This is my space leak: https://gist.github.com/969253
03:40:07 <ezyang> @tell fuzxxl I diagnosed your space leak; fromList is not strict in the combining function.
03:40:08 <lambdabot> Consider it noted.
03:44:17 <ezyang> I think it's kind of funny that that Haskell community has converged on the term "space leak", when everyone else uses "memory leak"
03:45:26 <ezyang> I guess it does mean something quite different for non-GC'd memory.
03:46:55 <Lemmih> You can still have memory leaks in your Haskell code. It is just quite rare.
03:47:30 <earthy> the term 'memory leak' also supports the notion of memory that the program thinks is still allocated but is no longer
03:47:54 <earthy> whereas 'space leak' supports the notion of memory that the programmer thinks should no longer be allocated but still is
03:49:02 <ezyang> *nod*
03:49:43 <opqdonut_> I also like the term time leak (a problem at least in some early frp implementations)
03:50:13 <zygoloid> if you mention memory leaks people say things like "i thought haskell had GC"
03:50:19 <quicksilver> sanity leaks are common when trying to implement code with high millioleg ratings.
03:53:12 <poltak> quicksilver: do you use Java?
03:55:26 <quicksilver> I have done in the past. why?
03:56:29 <jeffz> I wish cabal would give me more debug output when it fails to find a C library in the configure step.  I don't understand why it's failing with --extra-include-dirs= and --extra-lib-dirs= set.
03:57:57 <dcoutts> jeffz: use -v3, it gives the failing output of gcc
03:58:36 <jeffz> ahh i tried -vv
04:01:27 <jeffz> there we go... I had forgot to run ranlib on the libfoo.a
04:02:52 <jeffz> dcoutts, thanks
04:03:41 <dcoutts> jeffz: ah, sorry -v is not cumulative it's numbered and each one overrides the previous
04:06:05 <jeffz> dcoutts: second issue, it's warning me about relative paths for library-dirs saying to use --force to override, but configure, build nor install seem to take that option
04:06:25 <jeffz> (when I cabal build)
04:09:21 <dcoutts> jeffz: oh, that'll probably be ghc-pkg complining, not cabal
04:09:28 <jeffz> ah
04:09:51 <dcoutts> jeffz: I'd not noticed that ghc-pkg is doing that now and thus cabal ought to check for relative paths first
04:09:57 <dcoutts> jeffz: would you mind filing a ticket
04:10:11 <jeffz> sure
04:10:14 <jeffz> finally, it seems strange that if I pass --extra-include=foo and --extra-lib-dirs=bar to cabal configure, I need to pass them again to cabal install
04:10:17 <dcoutts> jeffz: the right solution here would be for cabal to make the paths absolute before passing them on to ghc-pkg
04:10:37 <dcoutts> jeffz: sigh, that's a long standing issue about what 'install' actually means.
04:10:54 <dcoutts> we currently make it mean "do everything": configure, build and install
04:11:02 <dcoutts> which means it has to take all the configure options too
04:11:49 <jeffz> ah okay
04:11:51 <dcoutts> a better solution would involve some sort of persistence of the configuration and only have cabal install override that saved config if you use extra config flags
04:12:18 <dcoutts> jeffz: in the mean time, there's a secret undocumented cabal install --only flag
04:19:31 <jeffz> filed here http://hackage.haskell.org/trac/hackage/ticket/842
04:28:13 <djanatyn> I'm going to have to learn how to make a cabal file soon.
04:28:30 * dcoutts is currently writing a new cabal tutorial / user guide
04:29:09 <djanatyn> Ooh!
04:29:17 <djanatyn> I'll be sure to read it, since I'm starting a cool new project.
04:29:33 <djanatyn> https://github.com/djanatyn/htd/blob/master/main.hs <-- I'm making a todo list application in haskell!
04:29:38 <djanatyn> And I should push my changes
04:30:10 <djanatyn> pushed, woot
04:30:16 <jeffz> djanatyn: cool! I'm looking for a todolist application replacement for 'ToDoList' which doesn't support unicode.
04:30:25 <djanatyn> jeffz: Don't expect much ;)
04:30:36 <djanatyn> Right now I've got it set up to add lines to a text file, and to read the contents of a text file
04:30:52 <djanatyn> I have a few goals, though.
04:31:05 <jeffz> will it have a gui?
04:31:20 <djanatyn> I want it to organize a text file, provide numbers for each task, support listing tasks as done or not done, and deleting tasks by their number
04:31:24 <djanatyn> jeffz: Ermm, maybe? :)
04:31:33 <jeffz> hehe
04:31:42 <djanatyn> I'm new to this Haskell stuff. This is my second haskell script, so I guess!
04:31:50 <djanatyn> That would be interesting. I could use wxWidgets or something.
04:32:11 <djanatyn> besides that, this is the only other haskell code I've written: https://github.com/djanatyn/guessingGame/blob/master/guess.hs
04:32:23 <djanatyn> So I'm new to this whole haskell thing in general.
04:32:48 <dmedvinsky> theAnswer = 24 haha
04:32:54 <djanatyn> I've been reading a lot about haskell, and doing a lot with ghci, but I've just started writing and structuring real applications that do stuff. It's actually quite a lot of fun, but error-handling is...different
04:33:02 <djanatyn> The type system makes writing stuff really fast sometimes
04:33:19 <djanatyn> And luckily, I've got some talented friends who are helping me out when I run into problems.
04:34:02 <djanatyn> I still have to make sure my Haskell code doesn't look like C code ;)
04:34:19 <djanatyn> I started out with C, and I've recently noticed that I write every language as C with a different syntax.
04:36:42 <dmedvinsky> djanatyn: soon you'll notice you write every language as Haskell but without lots of cool stuff ;-)
04:36:59 <djanatyn> dmedvinsky: I read a blog post about that :)
04:46:19 <frerich2> Hm, I recently wondered whether I can improve some of my code by having a function which curries a group of related functions in one go. I.e.instead of having a few functions which all somehow deal with one magic value (like, a number to guess), maybe it'd be neat to have one function which returns a tuple of functions.
04:46:26 <frerich2> I hope I'm making some sense :-}
04:46:40 <frerich2> Does anybody know whether this kind of thing has a name to google for?
04:47:16 <opqdonut_> that's usually just called a closure
04:47:29 <opqdonut_> and a closure that contains functions is usually termed an object
04:47:30 <opqdonut_> :)
04:56:01 <MasseR> :/ can't compile hdbc-postgresql on ubuntu because there's no pgconfig :/
04:57:30 <mm_freak> djanatyn: the one titled "why learning python/haskell makes you a worse programmer"?
04:58:15 <companion_cube> "you get accustomed to too much power, it is wrong!"
04:58:35 <mm_freak> i like that post actually, because it's totally true
04:58:45 <mm_freak> i have to code PHP at work
04:58:54 <mm_freak> and i hate it
05:00:01 <rostayob> Do I have to take particular precautions when using unsafePerformIO in a multithreaded context? apart from the usual unsafePerformIO precautions :P
05:12:01 <mm_freak> rostayob: i'd suspect problems running an STM action inside of unsafePerformIO
05:13:21 <mm_freak> though i can't really tell why
05:13:32 <mm_freak> just a bad feeling, i guess
05:13:34 <rostayob> mm_freak: no STM, just a foreign binding
05:13:43 <rostayob> mm_freak: https://github.com/rostayob/upskirt/issues/1
05:14:27 <mm_freak> well, the unsafety of FFI calls is magnified by the unpredictability of unsafePerformIO
05:14:48 <rostayob> yeah but what he's saying is that multi threading breaks it
05:14:58 <rostayob> which sounds strange to me
05:16:14 <rostayob> also, the code is quite straightforward
05:18:33 <quicksilver> well, unsafePerformIO'd code can be run twice
05:18:44 <quicksilver> if it's demanded by two different threads, I believe.
05:19:33 <rostayob> quicksilver: well yes, but this shouldn't break things, right?
05:20:14 <rostayob> as long as the results are consistent of course
05:22:54 <quicksilver> rostayob: depends what your code does :)
05:23:04 <quicksilver> some IO may perform badly when run twice?
05:23:21 <quicksilver> If your code is FFI code maybe they liibrary you're calling isn't threadsafe?
05:24:49 <rostayob> quicksilver: what would being thread safe mean in this context? The function I'm linking to boils down to processing a char[]
05:24:53 <rostayob> to another char[]
05:27:07 * hackagebot protocol-buffers 2.0.5 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-2.0.5 (ChrisKuklewicz)
05:28:07 * hackagebot protocol-buffers-descriptor 2.0.5 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  http://hackage.haskell.org/package/protocol-buffers-descriptor-2.0.5 (ChrisKuklewicz)
05:28:09 * hackagebot hprotoc 2.0.5 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/hprotoc-2.0.5 (ChrisKuklewicz)
05:30:04 <rostayob> quicksilver: I mean there are no concurrency issues, or other nasty stuff like that. THat's why I'm using unsafePerformIO anyway
05:30:52 <quicksilver> rostayob: I was talking about FFI code - C libraries - , which is often not threadsafe.
05:31:15 <quicksilver> it may be using static storage, for example.
05:32:36 <rostayob> quicksilver: I don't think that's the case. it simply gets a struct with the input buffer and another struct that it will fill with the output
05:33:59 <rostayob> mhm
05:35:08 <rostayob> with static storage you mean global variables right? or anyway changing stuff out of the scope of the function arguments
05:36:20 <mm_freak> rostayob: you are asking, whether something, which inherently breaks haskell, does break concurrent applications
05:37:06 <rostayob> mm_freak: well I'd like to use that C library and I'm trying to understand what could go wrong
05:37:21 <mm_freak> what do you need unsafePerformIO for?
05:37:42 <zygoloid> your instance Storable Buffer looks wrong
05:38:22 <rostayob> zygoloid: what's wrong?
05:38:41 <zygoloid> the 'poke' looks like it: 1) allocates a temporary string buffer, 2) writes a pointer to that buffer into the c buffer's 'data', then 3) frees the buffer
05:39:39 <zygoloid> (so by the time you use the Buffer for anything the data pointed to by it has already been freed)
05:39:40 <rostayob> zygoloid: mh, you are right
05:39:53 <rostayob> i never call poke anyway, but that's a stupid mistake
05:41:22 <rostayob> anyway I have to run, I wonder what it could be :P
05:41:33 <rostayob> zygoloid: thanks for noticing that
05:42:17 <zygoloid> np. sorry it's not the bug you're looking for :)
05:43:20 <FUZxxl> ezyang: Are you there?
05:53:48 <luite> Cale: Last time you said that I should add comment and definition cells. Ive been hacking last weekend and I now have a new preview: http://jabberwock.xs4all.nl/exp/wolfgang/ , with markdown text cells. Does this look somewhat like you had in mind?
05:54:48 <FUZxxl> @msg ezyang "I knew this before. So I used a tricky combination of foldr' and insertWith'. Data.Map really needs fromList'."
05:54:48 <lambdabot> Not enough privileges
05:54:56 <FUZxxl> wtf?
05:55:04 <FUZxxl> Who has enough privileges?
05:55:24 <mauke> FUZxxl: you do, you can just /msg him directly
05:55:32 <dmedvinsky> FUZxxl: maybe you wanted @tell
06:02:14 <mm_freak> FUZxxl: what would fromList' do?
06:02:27 <mm_freak> strict version of fromList?
06:05:00 <jonkri> will ErrorT monads automatically catch errors and return "Left"? if not, why use ErrorT at all? why not just return an Either value?
06:09:38 <FUZxxl> mm_freak: Yes.
06:10:10 <FUZxxl> fromList, but strict in the return type of the accumulator or its arguments.
06:11:16 <opqdonut_> jonkri: because the monad means that you don't have to pattern match all those Eithers by hand
06:11:23 <mm_freak> FUZxxl: what's the goal?  to have a fully evaluated map in the end?
06:12:01 <mikeg> Why not just use a map that's strict in both keys and values? Isn't that all that's accomplished with a "strict" fromList?
06:12:21 <jonkri> opqdonut_: there are very few places in the function which may generate an error. i think a monad may be overkill in my case
06:12:41 <opqdonut_> jonkri: sure, you can start with manual Eithers
06:12:54 <opqdonut_> and then switch to a Monad if things become a pain in the ass
06:16:11 <FUZxxl> Look at this: https://gist.github.com/969253
06:16:41 <jonkri> thanks opqdonut_ :)
06:17:39 <poltak> it's a me, Conan O'brien!
06:25:32 <mikeg> Oh, I think FUZxxl wants fromListWith' like insertWith' (there is no insert' or fromList')
06:30:41 <mm_freak> jonkri: i don't see why a monad would be overkill, even if its functionality is not used often
06:30:54 <mm_freak> i find myself writing MaybeT one- or two-liners all the time
06:32:00 <mm_freak> also i often have a ReaderT, even when the environment is asked for only in very few places
06:32:28 <jonkri> mm_freak: interesting. this function is pretty big, it's the main state loop of the program. it's type is stateLoop :: (MonadIO m, CE.Exception e) => StateT (State s m) m (Either e ())
06:32:31 <Axman6> hmm, anyone know how you'd do binary search on an array to find the first value that's greater than a given value?
06:32:38 <jonkri> at the moment :)
06:32:54 <Axman6> (well, to find the index of the first value that's greater than the input)
06:32:57 <jonkri> would wrapping the whole thing in ErrorT generally be considered bloated?
06:33:40 <Axman6> StateT (State s m) o.O
06:33:54 <Axman6> that's a pretty bizzare type
06:34:13 <Axman6> i can't even figure out how that's supposed to work...
06:34:20 <jonkri> Axman6: i know :) it wraps a client's arbitrary monad
06:34:31 * ManateeLazyCat I'm reading Haskell Communities and Activities Report, so many crazy idea. :)
06:34:45 <jonkri> hi ManateeLazyCat. nice to see you again :)
06:34:58 <ManateeLazyCat> jonkri: Hey, nice to meet you too. :)
06:35:21 <jonkri> Axman6: i've been thinking about this architecture for a while, i will post my suggestion on haskell-cafe next wednesday
06:35:37 <mm_freak> jonkri: why would you have a State computation as the state?
06:35:37 <jonkri> there is a reason for wrapping it, but whether or not it's correct, i'm not sure :)
06:36:03 <jonkri> mm_freak: client callbacks, which operate in and may modify the state a client-specific state
06:36:05 <Axman6> why not just take the state from State and make it the state in the StateT?
06:36:06 <ManateeLazyCat> jonkri: I remember we see before? :)
06:36:35 <jonkri> ManateeLazyCat: we were talking about gtk2hs, gobject introspection, and your text editor ;)
06:36:51 <ManateeLazyCat> jonkri: Is magic editor. :)
06:36:51 <jonkri> Axman6: "yo dawg, i herd you like states" :D
06:37:01 <mm_freak> jonkri: btw, you can do this:  type MyAppT m = StateT Clients (EitherT SomeException m)
06:37:10 <jonkri> i'm still too confused about these things to get what that means yet ;)
06:37:19 <mm_freak> stateLoop :: MonadIO m => MyAppT m ()
06:37:30 <ManateeLazyCat> jonkri: I perhaps just have time after June, then i will speed time on gtk2hs, update to gtk+ 3.0 :)
06:37:32 <mm_freak> if you want to throw a Left, just lift
06:37:41 <mm_freak> otherwise you're in StateT all the time, no difference
06:37:50 <Axman6> ManateeLazyCat: is that a good idea? how many distros are using gtk3?
06:38:54 <jonkri> i have a (blocking) createSession function which operates in "m ()", which starts this loop with "runStateT stateLoop state'"
06:39:06 <ManateeLazyCat> Axman6: I'm use Gnome3 and Ubuntu 11.04, i have install libgtk-3-* in my box. :)
06:39:22 <ManateeLazyCat> Axman6: Stable enough, so i need find some time to update gtk2hs API. :)
06:39:23 <jonkri> fedora ships with gtk 3 any day now
06:39:58 <Axman6> ManateeLazyCat: sure, but you're not everyone... i would recommend making a gtk3 specific version (maybe gtk3hs? =)
06:40:25 <jonkri> mm_freak: ah, EitherT "inside" the StateT... i tried it the other way around :P
06:40:36 <ManateeLazyCat> Axman6: I think should be "Gtk to haskell" ? ;p
06:40:49 <ManateeLazyCat> gtk2hs == "Gtk to haskell"
06:40:51 <Axman6> it was a joke ;)
06:41:01 <Axman6> a pun on the current name
06:41:10 <Axman6> a pretty good one i thought >_>
06:41:21 <jonkri> :)
06:41:48 <ManateeLazyCat> I'm busy on new software-center now for linux-deepin, so perhaps haven't so much time on gtk2hs.
06:41:50 <mm_freak> jonkri: practically the difference is which monad you want to lift
06:41:52 <jonkri> mm_freak: which doesn't make any sense now that i think about it :)
06:42:11 <mm_freak> jonkri: in this case, though…  for other monads it may make a huge difference, which way you combine them
06:42:19 <ManateeLazyCat> But before that, i need write mail-client to reading gtk2hs mailing-list, my mail-client was broken.
06:42:29 <jonkri> oh
06:43:04 <jonkri> ManateeLazyCat: what's wrong with thunderbird? ;)
06:43:16 <ManateeLazyCat> jonkri: I'm use Emacs reading mail. :)
06:43:21 <mm_freak> jonkri: but you can easily see the semantics of the resulting monad by manually de-monad-transforming your type =)
06:43:43 <ManateeLazyCat> jonkri: But slow and crap, i don't want to play it. :)
06:43:52 <jonkri> ManateeLazyCat: hehe ok
06:44:05 <jonkri> mm_freak: cool
06:45:43 <ManateeLazyCat> http://fprog.ru/ looks like a wonderful magazine for functional programming, unfortunately, i can't understand Russian.
06:46:31 <ManateeLazyCat> I always worried my Python code, not like Haskell, check everything for you, less bug....
06:47:23 <ManateeLazyCat> @package she
06:47:24 <lambdabot> http://hackage.haskell.org/package/she
06:48:10 <ManateeLazyCat> "Strathclyde Haskell Enhancement", ah.
06:49:41 <jonkri> mm_freak: what's the difference between ErrorT and EitherT in the type you suggested?
06:50:20 <mm_freak> jonkri: i don't know, it depends on the monad transformer library you use
06:50:40 <mm_freak> i've never used ErrorT, only EitherT
06:50:53 <mm_freak> because exceptions are not always errors
06:50:58 <ManateeLazyCat> mm_freak: Any new version fastirc? ;p
06:51:12 <mm_freak> ManateeLazyCat: no =)
06:51:25 <mm_freak> no time for fastirc
06:51:52 <ManateeLazyCat> mm_freak: Ok, :)
06:52:04 <jonkri> ah, got it
06:53:30 <geo> lambdabot; unpl id
06:53:36 <geo> lambdabot: unpl id
06:54:16 <mm_freak> ManateeLazyCat: you'll have to wait a few weeks, before i can start working on fastirc
06:54:25 <geo> lambdabot> unpl id
06:54:34 <jonkri> mm_freak: are you using http://hackage.haskell.org/package/EitherT?
06:54:44 <Axman6> > @unpl id
06:54:45 <lambdabot>   <no location info>: parse error on input `@'
06:54:46 <ManateeLazyCat> mm_freak: Hehe, i have waiting few months. :)
06:54:49 <Axman6>  @unpl id
06:54:51 <Axman6> @unpl id
06:54:52 <lambdabot> (\ a -> a)
06:55:02 <geo> > unpl id
06:55:03 <lambdabot>   Not in scope: `unpl'
06:55:06 <ManateeLazyCat> mm_freak: But yes, i understand, we are all busy man. :)
06:55:12 <Axman6> unpl isn't a function
06:55:19 <Axman6> it's a lambdabot command
06:55:22 <geo> > @pl
06:55:22 <lambdabot>   <no location info>: parse error on input `@'
06:55:35 <geo>  > @pl \x y -> y
06:55:41 <mm_freak> jonkri: i'm using my own library
06:55:44 <Axman6> -_-
06:55:47 <mm_freak> jonkri: it's on hackage, too, called 'contstuff'
06:55:51 <Axman6> @pl \x y -> y
06:55:51 <lambdabot> const id
06:56:11 <geo> @pl \x y -> y
06:56:11 <lambdabot> const id
06:56:18 <mm_freak> jonkri: it's a bit more complicated than the existing MT libraries, but also faster and more flexible
06:56:25 <jonkri> cool, thanks
06:56:43 <Janni> Hi.
06:56:44 <mm_freak> the wiki page is terribly outdated though, so you'll have to work out how to use it from the haddock docs
06:56:56 <ManateeLazyCat> Janni: HI. :)
06:57:14 <MasseR> Does anyone have a HaskellDB tutorial/example?
06:58:19 <geo> @pl \v -> map (:v) seeds
06:58:19 <lambdabot> flip map seeds . flip (:)
06:58:42 <ManateeLazyCat> MasseR: http://trac.haskell.org/haskelldb/
06:59:18 <MasseR> Would this be the first trac page which has something usable :P
06:59:19 <geo> Axman6: thanks
07:00:23 <geo> @pl \x -> x `divisible` 5 || x `divisible` 3
07:00:23 <lambdabot> liftM2 (||) (`divisible` 5) (`divisible` 3)
07:00:57 <Jafet> any (divisible x) [3,5]
07:01:04 <joe_> hola
07:01:16 <Jafet> Oh, sorry
07:01:17 <joe_> what
07:01:30 <geo> @pl \x -> (n * (5 * n - 3)) `div` 2
07:01:30 <lambdabot> const ((n * (5 * n - 3)) `div` 2)
07:01:37 <geo> @pl \n -> (n * (5 * n - 3)) `div` 2
07:01:38 <lambdabot> (`div` 2) . ap (*) (subtract 3 . (5 *))
07:01:51 <joe_> nobody cares
07:01:56 <Jafet> @pl \x -> any (divisible x) [3,5]
07:01:56 <lambdabot> flip any [3, 5] . divisible
07:01:59 <Taytay_> hello
07:02:16 <geo> @pl f n = n == f (maximize ((<= n) . f) 0 n)
07:02:16 <lambdabot> f = fix (ap (==) . ap (.) (join . flip flip 0 . (maximize .) . flip ((.) . flip (<=))))
07:02:25 <geo> @pl isPoly f n = n == f (maximize ((<= n) . f) 0 n)
07:02:26 <lambdabot> isPoly = ap (==) . ap (.) (join . flip flip 0 . (maximize .) . flip ((.) . flip (<=)))
07:02:32 <Taytay_> srry bout our name, paprika is in here too
07:02:36 <Axman6> geo: please stop spamming the channel
07:02:45 <Taytay_> ?????
07:02:59 <Taytay_> who is spamming
07:02:59 <Axman6> geo: /msg lambdabot @pl f x y = z
07:03:20 <Taytay_> i am confused
07:03:26 <geo> Axman6: thanks again
07:03:30 <Axman6> QuickTimei was talking to geo ...
07:03:34 <Axman6> uh, Taytay_ *
07:03:38 <alexbagel> what does @pl do? make pointfree?
07:03:57 <Axman6> that autocomplete does odd things sometime...
07:04:17 <Jafet> Nothing; it's pointless
07:06:43 <ezyang> FUZxxl: Now I am!
07:06:44 <lambdabot> ezyang: You have 1 new message. '/msg lambdabot @messages' to read it.
07:06:57 <zenzike> on the off chance, does anybody know if there are issues with using AUTOINCREMENT in HDBC?
07:07:06 <ManateeLazyCat> Hehe, first time seen Agda, MiniAgda, Clean... :)
07:07:10 <ezyang> @messages
07:07:11 <lambdabot> FUZxxl said 57m 44s ago: I knew this before. So I used a tricky combination of foldr' and insertWith'. Data.Map really needs fromList'.
07:07:41 <ezyang> @tell FUZxxl Ah! I wasn't sure if you knew, because you claimed it was a "streaming" problem, which it was not.
07:07:41 <lambdabot> Consider it noted.
07:10:17 <tg_> ezyang: little harsh
07:11:57 <ezyang> tg_: Just saying it as it is :^)
07:12:49 <tg_> ezyang: damn painful truths
07:18:42 <zygoloid> ezyang: your definition of time leak does not match the one i understood
07:19:15 <tg_> zygoloid: you see, the Internet is a series of tubes...
07:19:23 <zygoloid> (which is where an operation runs slowly due to having built up a long chain of thunks to evaluate)
07:19:50 <tg_> that sounds like a space-time leak to me
07:19:57 <zygoloid> oh noes!
07:19:59 <tg_> where it takes you forever to get from one local point to another local point
07:20:05 <tg_> because of a lot of mass in between
07:20:41 <zygoloid> a space-time leak sounds like a hole in the fabric of reality
07:21:28 <int-e> right ... the rts creates black holes all the time.
07:21:56 <tg_> yeah, I was using what's called an "analogy"
07:23:46 <Chris_______> hi
07:24:03 <Chris_______> is anybody here?
07:24:11 <Lemmih> Chris_______: Yeah.
07:24:22 <Chris_______> ("1,2,3)
07:24:26 <ezyang> zygoloid: My impression of a time leak is when you have an event that requires the whole history of time to be preserved.
07:24:38 <ezyang> Perhaps I should not say "stream of time" but rather "stream of events in time"
07:24:55 <Chris_______> who is u?
07:24:57 <quicksilver> that sounds like a common case of space leak doesn't it, ezyang ?
07:25:04 <tg_> ezyang: in physics, those two things are the same :O
07:25:12 <Chris_______> i no speak english good
07:25:12 <zygoloid> ezyang: that's a special case, i think. i'm doing some googling, and it appears "time leak" is used for non-FRP things pretty frequently
07:25:19 <ezyang> Yes, it is a space leak.
07:25:20 <joe_> rt
07:25:20 <joe_> hrth
07:25:21 <joe_> hrh
07:25:21 <joe_> rh
07:25:22 <joe_> rt
07:25:22 <joe_> t
07:25:22 <joe_> rt
07:25:23 <joe_> jh
07:25:23 <joe_> f
07:25:23 <joe_> j
07:25:24 <joe_> r
07:25:24 <joe_> tj
07:25:24 <joe_> r
07:25:25 <joe_> r
07:25:28 --- mode: ChanServ set +o quicksilver
07:25:28 --- mode: ChanServ set +o mauke
07:25:32 <ezyang> zygoloid: OK, I'm not very familiar with the time leak literature. Just read a few blog posts about it :-)
07:25:35 <tg_> 10:34 -!- computer249 [c7d4fa61@gateway/web/freenode/ip.199.212.250.97] has joined #haskell
07:25:36 <Lemmih> Chris_______: I'm a Haskell programmer. Are you interested in Haskell?
07:25:42 <tg_> 10:32 -!- Chris_______ [c7d4fa61@gateway/web/freenode/ip.199.212.250.97] has joined #haskell
07:25:46 <meow> meow
07:25:54 <tg_> these are all the same ip address
07:25:57 --- mode: quicksilver set +b *!*c7d4fa61@*.199.212.250.97
07:25:57 --- kick: meow was kicked by quicksilver (meow)
07:26:02 --- kick: Chris_______ was kicked by quicksilver (Chris_______)
07:26:07 <zygoloid> ezyang: (my understanding is that the 'time' refers to runtime, not some domain-specific modelling of time)
07:27:01 <aristid> #haskell has a pretty long ban list
07:27:18 <Kaidelong> it seems to be a pretty big channel
07:27:20 <ezyang> "A time leak is a situation in which a value is dependent on past values for an arbitrary time interval, and they are not evaluated as they are produced, thus, suddenly forcing a value may take an arbitrary amount of time." http://blog.edwardamsden.com/2011/03/demonstrating-time-leak-in-arrowized.html
07:27:31 <Kaidelong> so I imagine it shows up high enough in the list for people to find it
07:27:31 <int-e> aristid: there's no garbage collection, I think
07:27:33 <ezyang> ah, I guess I've missed the latter segment.
07:27:35 <aristid> Kaidelong: it is. but i wonder if it makes sense to clean up the banlist once in a while.
07:27:41 <quicksilver> we're a big channel, we get our share of annoyances because we come top or near top of various lists of channels
07:28:08 <quicksilver> there is garbage collection but it's the old fashioned type, triggered when we run out completely, I think :)
07:28:43 <tg_> quicksilver: is there a point to what just happened though? Is that a "just wants to watch the world burn" kind of thing?
07:29:07 <quicksilver> tg_: probably someone not really understanding what IRC is and just messing around to see what would happen
07:29:10 <quicksilver> is my guess.
07:29:24 <int-e> tg_: I wouldn't read much into it. Misguided kids having what they perceive as fun, more likely than not.
07:29:29 <tg_> quicksilver: at least you made his lesson efficient
07:29:33 <quicksilver> I wouldn't be surprised if someone (else) left the freenode web irc window open and they clicked on it.
07:29:44 <zygoloid> ezyang: the FRP leaking-the-history meaning seems more prevalent (based on my googling) but the leak-which-builds-up-a-runtime-cost meaning seems to be older
07:29:57 <ezyang> interesting.
07:30:06 <tg_> ezyang: I don't see why it's an incorrect analogy...
07:30:12 <ezyang> well, I'll remove that remark for now, as it's not too important.
07:30:17 <tg_> though, we obviously have space leak problems, and time-leak problems
07:30:21 <zygoloid> seems like what you call a thunk leak is what was once called a time leak
07:30:33 <tg_> so there ought to be analogies in [space-time] leaks and [time-space] leaks
07:30:40 <tg_> valid, useful, or not
07:31:03 <int-e> every time leak is also a space leak then, right?
07:31:10 <ezyang> Amortization also counts as a "time leak"
07:31:12 <zygoloid> http://www.haskell.org/pipermail/haskell-cafe/2007-October/032590.html
07:31:15 <ezyang> but that's not necessarily a space leak.
07:31:18 <Tomsik> I'm wondering: are lisp macros anything besides higher-order functions in a non-strict language?
07:31:27 <int-e> (since that chain of thunks has to be stored somewhere?)
07:31:38 --- mode: quicksilver set -o quicksilver
07:31:45 <ezyang> Tomsik: Yes.
07:31:56 <ezyang> but they are frequently used to simulate control flow.
07:32:03 <quicksilver> Tomsik: they operate on source bypassing the normal rules of evaluation
07:32:13 <tg_> ezyang: well, I'm specifically asserting that the kind of thing you're describing (building up a chain of thunks in memory (space) which have to be executed to be cleared (time)) is similar to "mass" in space-time, in a sense... a bunch information curled up on itself that has to be "evaluted" to be released (as energy)
07:32:26 <quicksilver> Tomsik: so viewed from the context of lisp they're different.
07:32:30 <tg_> I understand the physics much more than the CS in this case
07:32:49 <Tomsik> Yes, they've got a different underlying mechanic, but is there an example of macro use that would be awkward as a higher-order function?
07:33:00 <ezyang> My intuition for this comes in the fact that TIME(f(n)) is a subset of SPACE(f(n))
07:33:11 <ezyang> Tomsik: Making your own syntax
07:33:32 <Tomsik> It's a bit of exaggeration calling it syntax I think
07:33:40 <dolio> Tomsik: How about a macro that rewrites "(shift n e)" into "(shift (lambda n e))"?
07:33:59 <tg_> ezyang: is "TIME" "DTIME"?
07:34:13 <ezyang> yeah.
07:34:16 <tg_> ok.
07:34:20 <ezyang> though I think it works if you make either D or N.
07:34:23 <zygoloid> but it's true of NTIME too
07:34:26 <ezyang> *both*
07:34:27 <dolio> Or (lambda (n) e). My lisp is rusty.
07:34:33 <zygoloid> indeed it's true of ATIME
07:34:52 <dolio> Anyhow, macros can introduce new constructs that bind variables.
07:35:16 <ezyang> See also, Template Haskell.
07:35:20 <Tomsik> dolio: okay, name capture can't be done with higher-order functions. I see.
07:35:28 <dolio> And they can rewrite the syntax tree into arbitrary other syntax trees.
07:35:56 <Tomsik> ezyang: TH isn't run-time stuff AFAIK
07:36:01 * ManateeLazyCat pasted "funny message when do "darcs get --lazy http://joyful.com/repos/darcsum"" at http://paste2.org/get/1419599
07:36:13 <ezyang> Oh, I thought lisp macros were mostly compile time affairs.
07:37:04 <Tomsik> No, it's generate-code-on-the-fly stuff
07:37:25 <djanatyn> Uhh. How do I print an "IO String"?
07:37:37 <mauke> djanatyn: you don't
07:37:42 <mauke> djanatyn: how would that be useful?
07:37:42 <dolio> @type (>>= putStrLn)
07:37:43 <lambdabot> IO String -> IO ()
07:37:52 <int-e> ManateeLazyCat: you can embarass kowey by telling him that you're a fan of the picture ;)
07:37:53 <poucet> What dolio said
07:37:56 <djanatyn> mauke: well.ll
07:41:02 <ManateeLazyCat> int-e: Hehe. :)
07:45:12 <sm> hi ManateeLazyCat .. cute isn't it
07:45:23 <ManateeLazyCat> sm: Yep. :)
07:45:36 <sm> I maintain that repo, I'll upgrade it as soon as I've got the ok from another contributor
07:45:56 <ManateeLazyCat> sm: Nice code. :)
07:46:17 <sm> nice elisp code ?
07:46:56 <ManateeLazyCat> sm: Yes. :)
07:47:04 <FUZxxl> ezyang: Are you here?
07:47:07 <FUZxxl> I am back now.
07:47:26 <sm> well thanks! on behalf of the author(s). I just fixed a few bits
07:49:50 <ManateeLazyCat> sm: elisp is funny language, when i reading "regular expression", just feeling like yesterday ... :)
07:50:20 <ion> http://timelessrepo.com/json-isnt-a-javascript-subset
07:50:22 <sm> regexps aren't old! :)
07:51:35 <Kaidelong> they aren't?
07:51:49 <ManateeLazyCat> sm: Haha, enjoy elisp time, it's a language release your imagination... :)
07:52:06 <sm> Kaidelong: I mean using them doesn't make you out of date :)
07:52:31 <Kaidelong> well I would be surprised if it did
07:52:33 <Tomsik> regexps are like DFA-old
07:52:43 <Kaidelong> they are DFAs
07:52:50 <ManateeLazyCat> sm: I mean, i feeling i wrote those elisp code like yesterday when everytime i read them. :)
07:53:06 <Kaidelong> NDFAs model them better IMHO but all NDFAs are really DFAs
07:53:15 <sm> it is strange reading elisp after a lot of haskell isn't it
07:53:21 <ManateeLazyCat> Elisp's regex is *wonderful*, special integrate with Emacs. :)
07:55:44 <ManateeLazyCat> sm: No, i love elisp, it teach you many cool things that java idiot never knows. :)
07:56:21 <Kaidelong> haven't used it, but heard elisp is rather hard to use
07:56:34 <Kaidelong> due to its scoping rules, mostly
07:56:49 <dolio> NDFA?
07:56:55 <flux> kaidelong, emacs HEAD has (optional) lexical scoping!
07:57:47 <Kaidelong> dolio: NFA
08:05:51 <mm_freak> what's wrong with elisp scoping?  i'm curious, because i don't know it
08:06:12 <mm_freak> does it have the same brain-damaged scoping as javascript?
08:06:15 <quicksilver> dynamic by default, mm_freak
08:06:39 <osfameron> javascript is lexically scoped isn't it?  oh yes, by function rather than block, which is a little annoying.
08:06:51 <osfameron> dynamic scoping is rather *more* brain-damaged
08:07:06 <mm_freak> osfameron: in javascript variable scope is global by default
08:07:28 <quicksilver> well, undeclared variables, sure.
08:07:34 <quicksilver> but undeclared variables are a programmer error.
08:07:38 <osfameron> heh
08:07:38 <mornfall> Ah, like in bash. :)
08:07:43 <osfameron> is there a 'use strict' for js?
08:07:51 <quicksilver> there is jslint
08:08:00 <mm_freak> quicksilver: weird to hear such a statement from a haskell programmer
08:08:02 * osfameron has finger memory of 'var foo' for js
08:08:24 <mm_freak> quicksilver: not checking for NULL and comparing int to string are programmer errors, too, in that sense
08:08:33 <quicksilver> mm_freak: why? haskell forces you to declare your variables too.
08:08:55 <mornfall> quicksilver: Does JS? That's the question.
08:08:56 <mm_freak> yes, and for me it's a language programmer to allow undeclared variables
08:08:59 <mm_freak> not a programmer error
08:09:08 <mm_freak> language programmer → language error
08:09:13 <quicksilver> it's a flaw in the langauge, yes.
08:09:27 <quicksilver> but once your'e working with the language, it's a programmer error to use it.
08:09:33 <quicksilver> like 'with'
08:09:46 <quicksilver> all languages have flaws (although JS has more than many) - good programmers avoid them.
08:10:01 * osfameron hugs "Javascript: the good parts"
08:10:15 <mm_freak> again in that sense there is no real reason to prefer haskell over, say, C++
08:10:17 <osfameron> jslint is worth using then?
08:10:23 <edwardk> osfameron: that finger memory screws me up in scala all the time, because while var works, you usually want val
08:10:24 <mm_freak> being a good programmer C++ would be just as good
08:10:29 <mornfall> osfameron: Other than, somehow runs on most systems, are there any? :P
08:10:52 <osfameron> mornfall: sure. it's a fun little language. Running on most systems *is* a big selling point though.
08:11:19 <quicksilver> mm_freak: being a good programming in C++ doesn't get you garbage collection or lightweight threads or STM
08:11:23 <osfameron> and prototypical OO is quite interesting (though totally does my head in - I've never worked it out)
08:11:30 <quicksilver> but, yes, it's true that good programmers can write good C++.
08:11:31 <mornfall> osfameron: I'd say if it wasn't for the widespread out-of-the-box support, no-one would even know about it.
08:11:48 <Botje> osfameron: did you read that paper where a guy makes a bootstrapping prototype OO implementation in 200 lines of C?
08:11:50 <osfameron> didn't one of the haskell compilers have a Javscript backend?
08:12:03 <osfameron> Botje: heh, no, not heard of that
08:12:35 <mm_freak> quicksilver: my point is that it's a mistake to make the programmer responsible…  in the first instance the programmer is the one, who forgot about the language flaw, but in the second instance the language could have done a better job
08:12:54 <int-e> osfameron: this? http://www.haskell.org/haskellwiki/Yhc/Javascript
08:13:22 <osfameron> int-e: ah, yes, yhc.  Is that still actively developed?
08:13:29 <quicksilver> mm_freak: of course. It's a stupid feature of the language. I wouldn't personally describe it as a flaw in javascript scoping, though.
08:13:42 <quicksilver> it's a flaw in how undeclared variables are treated.
08:13:58 <mm_freak> quicksilver: ok, that's controversial…  others might see it as a good feature
08:14:39 <Botje> gah. and of course now i can't find it anymore :(
08:14:43 <mm_freak> there are indeed people, who find dollar signs in front of variables to be great (not talking about javascript here)
08:14:55 <Botje> hey! I rather like perl!
08:15:18 <mm_freak> Botje: in perl they have at least /some/ reason for being there
08:15:35 <mm_freak> but i'm talking about PHP, which is about as braindead as a language can get
08:15:41 <osfameron> javascript allows $variables too, of course ;-)
08:15:50 <tibbe> I'm feeling extra thick today. How do I write a function that runs a sub-computation in StateT but preserves the state?
08:16:17 <mm_freak> tibbe: get the state and perform another runStateT
08:17:08 * ski . o O ( `\(State f) -> State (\s -> (fst (f s),s))' )
08:17:35 <mm_freak> :t state
08:17:35 <lambdabot> forall s a. (s -> (a, s)) -> State s a
08:17:38 <ski> (mutatis mutandis for `StateT')
08:17:47 <ManateeLazyCat> Bye all, good night! :)
08:17:54 <mm_freak> g'night ManateeLazyCat
08:18:55 <Botje> sigh. if i ever find it again i'll gve you a ping
08:19:23 <tibbe> I'm messing something up
08:19:24 <tibbe> hmm
08:19:41 <tibbe> perhaps using StateT s1 (ST s2) a was a bad idea
08:19:46 <tibbe> perhaps I should just use ST
08:21:34 <int-e> osfameron: http://yhc06.blogspot.com/2011/04/yhc-is-dead.html ... I guess not.
08:22:40 <bob31> any unknown incompatibilities of haskell-mode with Emacs 24?
08:22:46 <bob31> *known
08:23:12 <bob31> "function definition is void: incf"
08:24:47 <tibbe> ski, what if the State constructor isn't exported
08:29:38 <tg_> q: from examples in http://learnyouahaskell.com/making-our-own-types-and-typeclasses -
08:29:50 <tg_> at the very bottom with the Barry type
08:29:55 <ski> Tomsik : see <http://mumble.net/~campbell/scheme/foof-loop.txt> for a non-trivial macro .. also see macros implementing pattern-matching constructs
08:29:58 <ski> ezyang : in parsing, there's also disjunctions keeping the already-seen input alive
08:29:59 <tg_> with kind (* -> *) -> * -> * -> *
08:30:19 <ski> <ezyang> Oh, I thought lisp macros were mostly compile time affairs.
08:30:20 <tg_> actually let me just put this in a pastie
08:30:20 <ski> <Tomsik> No, it's generate-code-on-the-fly stuff
08:30:49 <ski> imu, macros are really compile-time stuff (i ignore FEXPRs and similar)
08:31:22 <ski> it's just that traditionally, many Lisp systems compile things on the fly in the interactor (repl)
08:32:26 <ski> tibbe : then you have to resort to the accessor `runState' and the producer function `state', possibly using view-patterns
08:33:58 <tibbe> ski, http://hpaste.org/46724/local
08:35:25 <tibbe> nm
08:35:27 <tibbe> I'm being stupid
08:37:23 <tg_> ok, LYAH question:
08:37:24 <tg_> http://hpaste.org/46725/discussing_kinds_annotation
08:37:54 <tg_> in general, it's about reading kind statements
08:38:49 <quicksilver> tg_: and the question is?
08:38:55 <tg_> quicksilver: is that annotation correct?
08:39:01 <tg_> or am I misunderstanding?
08:39:10 <quicksilver> your conclusion is right.
08:39:19 <quicksilver> those "two concrete types" are really (*) and (*)
08:39:20 * osfameron didn't get the LYAH stuff on kinds.
08:39:24 <quicksilver> the -> aren't part of them.
08:39:38 <quicksilver> and we don't call (* -> *) functor types
08:39:41 <kosmikus> the parentheses in line 13 are wrong
08:39:42 <tg_> quicksilver: well, I was thinking of them as things similar to group homomorphisms, one an injection, and one a bijection
08:39:46 <ski> tibbe : i'm tempted to suggest renaming `local' to `saveExcursion' :)
08:39:46 <tg_> quicksilver: what do we call them?
08:39:51 <quicksilver> so... the details of your language are wrong, but your conclusion is right.
08:39:59 <quicksilver> tg_: "types of kind * -> *"
08:40:05 <kosmikus> tg_: we call them types of kind * -> *, or sometimes type constructors
08:40:34 <quicksilver> kosmikus's point about the ()s in line 13 is a good one, too.
08:40:52 <tibbe> ski, haha
08:40:59 <ski> tibbe : anyway, the `local' name isn't really good, maybe `restoringRandomState' or `withPreservedRandomState' or something ?
08:41:26 <tg_> ok, are the parens for kinds left- or right-associative?
08:41:39 <quicksilver> -> is right associative
08:41:44 <quicksilver> for kinds just like for types
08:42:01 <tg_> quicksilver: and there's always an implicit * sitting at the rightmost point?
08:42:14 <quicksilver> Int -> Int -> Int and * -> * -> * are the same 'shape'
08:42:18 <kosmikus> there's nothing implicit
08:42:21 <ski> tibbe : also, maybe you really want to use something similar to `newStdGen', i.e. use `split' on the current `StdGen', using one clone in the sub-computation, and another as the new state ?
08:42:25 <JKL_> data Test = Test { foo :: Int } What is foo called here?
08:42:29 <quicksilver> that rightmost * doesn't look implicit to me.
08:42:38 <quicksilver> JKL_: selector function or record label
08:42:39 <ski> @type local
08:42:40 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
08:42:55 <tg_> quicksilver: LYAH mentioned that we an assume (in data Barry t k p) that p *must* be *
08:43:13 <tg_> that is always a correct assumption - the last type paramter is always *?
08:43:20 <quicksilver> not really.
08:43:25 <tg_> doh. :(
08:43:26 <kosmikus> theorbtwo: every value is of a type that has kind *
08:43:31 <kosmikus> tg_: ^^
08:43:32 <quicksilver> it's just that kind inference makes some simplifying assumptions.
08:43:33 <kosmikus> theorbtwo: sorry
08:43:38 <JKL_> can i have different data with same name selector function?
08:43:48 <quicksilver> if you gave an explicit kind signature you could make p (or k) more complex.
08:43:59 <kosmikus> tg_: you use "p" as the type of the field yabba, so it must be of kind *
08:44:09 <ski> tg_ : s/(* ->) and (-> *)/* and */
08:44:17 <quicksilver> oh that's true. I didn' spot that about p.
08:44:23 <quicksilver> but an assumption is being made with k.
08:44:32 <kosmikus> tg_: similarly, the result of applying t to k must be of kind *
08:44:37 <quicksilver> technically we don't know "k" is *, but GHC assumes that to keep things simple.
08:44:55 <tg_> quicksilver: I guess I'm asking, when I see type chains or kind chains like this, I should figure them out right to left?
08:45:05 <tg_> Is there some literature on how to mechanically decode these things
08:45:10 <tg_> I don't feel confident at all about it.
08:45:20 <quicksilver> tg_: are you happy with Int -> Int -> Int ?
08:45:26 <ski> JKL_ : .. or field, or projection function
08:45:29 <tg_> quicksilver: being * -> * -> *?
08:45:36 <tg_> Sure, because :k Int is Int :: *
08:45:36 <JKL_> do i have to have different selector function name for every data?
08:45:39 <quicksilver> tg_: no. it isnt.
08:45:47 <quicksilver> tg_: Int -> Int -> Int has kind *
08:45:56 <quicksilver> but that wasn't what I was asking :)
08:46:03 <ski> tg_ : `p' must have kind `*' since it's used as the type of a field
08:46:08 <quicksilver> I was asking if you're happy reading the type signature Int -> Int -> Int?
08:46:16 <tg_> quicksilver: I guess not. :(
08:46:19 <quicksilver> because the process of reading the kind signature * -> * -> * is the same
08:46:25 <ski> tg_ : iow, it is used concretely, as a type which can have values, so its kind must be `*'
08:46:28 <quicksilver> left to right or right to left is up to you.
08:46:32 <quicksilver> but they both 'take two arguments'
08:46:52 <quicksilver> Int -> Int -> Int is a function which takes two (Int) arguments and returns one (Int)
08:47:04 <ski> tg_ : similarly `t k' is used concretely, so it follows that `t k :: *' and thus `t : k0 -> *' where `k :: k0'
08:47:11 <quicksilver> * -> * -> * is the kind of a type constructor which takes two (*) arguments and returns a (*).
08:47:39 <tg_> * -> * -> * is a type constructor function which takes two star-types and retursn one star-type?
08:47:43 <tg_> yes ok
08:47:54 <quicksilver> yes.
08:48:06 <ski> tg_ : now Haskell just plain assumes that `k0' must be `*' as well, if nothing forces it to be anything else (like using e.g. `k p' somewhere .. or like a kind annotation with extensions would)
08:48:07 <tg_> quicksilver: so I can always analyze these things in that language
08:48:17 <tg_> using the type-constructor-as-a-function language
08:48:50 <ski> tg_ : iow, types can't be polymorphic, you can't e.g. make a `Flip :: forall k0 k1. (k0 -> k1 -> *) -> k1 -> k0 -> *'
08:50:21 <tg_> ski: ok
08:50:23 <tg_> thanks all
08:51:15 <ski> (to clarify : one could imagine types being able to be polymorphic. it's just that (the current) Haskell doesn't allow that)
08:51:52 <tg_> is there some canonical documentation to explain this specifically?
08:51:57 <tg_> on haskell wiki or wikibooks or something?
08:52:43 * ski doesn't know ..
08:54:45 <JKL_> if i have data Car and data Employee, they both can't have field company?
08:55:14 <zygoloid> JKL_: not if they're in the same module
08:55:33 <JKL_> ok
08:56:15 <zygoloid> when you define a data type T with a field f of type U, you implicitly also define a function f :: T -> U. that's what causes the problem
08:56:49 <JKL_> if I put car and employee to different modules then i have to type Car.Car Employee.Employee ?
09:00:50 <Cobra> JKL_: only if you import them qualified
09:02:05 <JKL_> but I could have get 2 functions named company to same "namespace"?
09:02:26 <Jafet> Use C++ for a while, and you'll never want to again
09:02:57 <Twey> Hah
09:03:17 <Cobra> JKL_: you'd have to use Car.company and Employee.company
09:03:46 <JKL_> ok, thx
09:03:51 <Twey> JKL_: You can import qualified Car; import qualified Company; import Car hiding (company); import Employee hiding (company)
09:04:03 <Twey> Then you only have to use the qualified names where it's ambiguous
09:04:27 <mm_freak> i'd rather import qualified Company; import Company (Company)
09:04:31 <Twey> (you can also use ‘import qualified Employee as E’ so you only have to type E.company instead of Employee.company)
09:04:48 <Twey> mm_freak: Yeah, agreed
09:05:02 <JKL_> i like the Employee.company one better :)
09:05:44 <JKL_> but this is not a stopper, i just put some characters after each other and see what happens :)
09:15:07 <lifthrasiir> @pl (\x -> print x >> return x)
09:15:08 <lambdabot> liftM2 (>>) print return
09:17:54 <aristid> -XDeriveFunctor is a pretty neat extension
09:21:25 <augur> anyone know of any good papers on the topic of references/pointers and denotational semantics?
09:30:43 <spirit_> how do i read a file line by line?
09:31:10 <ski> @type hGetLine
09:31:10 <lambdabot> Not in scope: `hGetLine'
09:31:19 <ski> @index hGetLine
09:31:19 <lambdabot> System.IO
09:31:23 <ski> @type System.IO.hGetLine
09:31:24 <lambdabot> GHC.IO.Handle.Types.Handle -> IO String
09:31:37 <spirit_> ah :-)
09:31:43 <spirit_> cheers!
09:32:14 * ski hs no idea what's up with the Way.Too.Deep.Module.Indirection there ..
09:32:17 <Jafet> liftM lines . readFile
09:32:33 <ski> *nod*
09:32:35 <Jafet> ski: tariffs?
09:32:43 <ski> sorry ?
09:33:12 <Jafet> Bureaucratic hindrance to importing
09:33:25 <ski> ah, you mean syntactic salt ?
09:34:12 <spirit_> i was looking for something that would leave me with a String, not an IO String.
09:34:18 <Jafet> The real reason is probably something along the lines of, when would you ever use System.IO in lambdabot
09:34:19 <ski> (imo, `:t',&c. should only answer with module-qualifications that are actually currently in scope)
09:34:24 <Jafet> Or mueval
09:34:32 <Jafet> :t interact
09:34:33 <lambdabot> (String -> String) -> IO ()
09:34:49 <alexbagel> spirit_: you'll have to give up on that one I'm afraid
09:34:59 <ski> spirit_ : you want an action that does I/O to read the *current* contents of a file -- of *course* you'll get `IO'
09:35:00 <Jafet> @hoogle hInteract
09:35:00 <lambdabot> No results found
09:35:02 <k0ral> hi, is it normal that a "cabal install" doesn't detect some files' changes ?
09:35:43 <spirit_> i came across 'lines', but applying that to the result of hGetContents wasn't quite what i wanted. not IO though, so not too bad
09:36:23 <Jafet> Why are you trying to do I/O without using IO?
09:36:39 <Jafet> IO isn't evil. I/O is evil. IO lets you do I/O.
09:36:41 <spirit_> i need to parse the contents and then pass it onto functions
09:36:52 <spirit_> non IO functions
09:36:53 <ski> @type lines .: readFile
09:36:54 <lambdabot> FilePath -> IO [String]
09:37:02 <Jafet> (or is evil transitive?)
09:37:43 <ski> surely doing I/O through `IO' is evil, while `IO' itself isn't necessarily evil
09:38:00 <ski> (iow `IO', modulo the I/O done, isn't necessarily evil)
09:38:01 <Jafet> spirit: then read the file with IO, and parse its contents using the functions without IO.
09:38:09 <dcoutts> k0ral: which files?
09:38:12 <Jafet> > putStr ""
09:38:13 <lambdabot>   <IO ()>
09:38:18 <spirit_> what functions might be suitable?
09:38:25 <k0ral> well, my source files
09:38:26 <Jafet> Good point
09:38:26 <Jafet> The rts is evil!
09:38:45 <ski> spirit_ : e.g. `hGetContets' or `hInteract'
09:39:00 <Jafet> spirit: the ones you are talking about.
09:39:03 <k0ral> i changed some code but cabal complains about something that doesn't exist anymore
09:39:11 <k0ral> dcoutts: ^
09:39:32 * ski ponders what `hInteract' is really supposed to do ..
09:39:32 <dcoutts> k0ral: missing packages? what was the complaint exactly?
09:39:58 <Jafet> Interact non-interactively
09:40:14 <Jafet> Well, you could point it at a pty...
09:40:21 <ski> yeah .. but write the results back to the same file, overwriting ?
09:40:36 <ski> unlinking the old file, making a replacement ?
09:40:43 <ski> taking two `Handle's ?
09:40:45 <Jafet> Writing to the pty, whatever that means for the pty
09:40:46 <monochrom> or to the same handle which has a socket behind it
09:40:54 <ski> *nod*
09:41:16 <spirit_> where would i find hInteract?
09:41:22 <ski> you wouldn't
09:41:28 <k0ral> dcoutts: no, it's just that it complains about a function that has 3 arguments whereas I've just made it with 4 arguments, but it didn't detect the change
09:41:31 <ski> we're pondering what it's supposed to do
09:41:47 <ski> spirit_ : there is an `interact' for `stdin'&`stdout'
09:41:57 <Jafet> Well, you are – I never gave it any thought
09:42:15 <dcoutts> k0ral: cabal relies on ghc --make to detect these kinds of changes
09:42:21 <ski> spirit_ : if you're just wanting to use input to a file, and not necessarily (directly) output something, then you don't need `interact' (or `hInteract') here
09:42:27 <k0ral> dcoutts: I just don't want to have to remove all intermediate compilation file each time
09:43:00 <spirit_> i'd like to read the contents of a file as a single big string
09:43:10 <dcoutts> k0ral: it's possible you've found a bug with the ghc recomp checker, you'd need to boil down a test case
09:43:27 <k0ral> dcoutts: I hardly think so
09:43:33 <dcoutts> k0ral: does it involve multiple packages or is it all within one package?
09:43:39 <ski> (Jafet : .. heard about "majestic plural" ? ;)
09:43:43 <k0ral> dcoutts: multiple packages
09:43:55 <k0ral> it detected a modification on Main.hs
09:43:59 <Jafet> No, we have not
09:44:03 <ski> spirit_ : then `hGetContents' is for you
09:44:06 <k0ral> which imports a module I made called Gui.hs
09:44:15 <k0ral> but didn't noticed I also updated Gui.hs
09:44:30 <ski> @hoogle hGetContents
09:44:31 <lambdabot> Data.ByteString hGetContents :: Handle -> IO ByteString
09:44:31 <lambdabot> System.IO hGetContents :: Handle -> IO String
09:44:31 <lambdabot> Data.ByteString.Char8 hGetContents :: Handle -> IO ByteString
09:44:41 <spirit_> i could split the string afterwards? via split?
09:44:42 <ski> spirit_ : there's also `ByteString' versions ^
09:44:48 <ski> sure
09:44:57 <k0ral> dcoutts: I doubt it's a bug, I just think I'm not doing something well, I'm still a newbie
09:44:58 <spirit_> cool, will try, cheers!
09:47:28 <Silvah> ski: hGetContentsIfYouDontCloseTheHandleTooEarly?
09:49:02 <Jafet> OrTwiddleWithTheFileOrSomeOtherThing
09:49:27 <Twey> Heh
09:49:42 <Twey> hGetContentsProbably
09:50:36 <Silvah> By the way: any ideas how http://hpaste.org/46727/code can be improved?
09:51:31 * ski nods solemnly in Silvah's general direction
09:51:54 <ski> (semi-closed `Handle's shouldn't be `hClosed')
09:53:25 <Botje> Silvah: you could make handleAdjacentLetters' return Maybe (Boolean, String)
09:53:32 <ski> i might replace `x2:xs' by `xs1@(x2:xs)' in the pattern, and with `xs1' in the recursive call ..
09:53:51 <Botje> hmm, but that's not really very nice :(
09:55:05 <Botje> Silvah: why would handleAdjacentLetters need to be invoked multiple times?
09:55:17 * ski wonders if this really needs fixpoint-iteration
09:55:41 <int-e> Botje: eea -> eaa -> eä?
09:56:02 <Botje> .. otherwise you could shift letters in front of the input instead of simply returning them
09:56:03 <int-e> not sure that's intended.
09:56:11 <Silvah> int-e: it is.
09:57:00 <ski> maybe use a zipper ?
09:57:48 <Silvah> ski: what do you mean?
09:58:07 <ski> each time you make a change, take one step back in the list, continuing from there
09:58:49 <ski> instead of returning characters, add them to an accumulator
09:58:56 <ski> then at the end, reverse the accumulator
09:59:50 <ski>   loop acc (x0:x1:xs)
10:00:00 <chegibari> Hello. I installed a fresh copy of ubuntu and installing haskell packages. I'm getting lots of "unresolvable dependecies" errors. What's wrong? Do I have to add some haskell specific repository?
10:00:19 <ski>     | x0 == x1  = loop (x0:acc) (x1:xs)
10:00:31 <ski>     otherwise = case x0 of
10:01:14 <ski> or, no
10:01:21 <ski>     otherwise = case (x0,acc) of
10:01:29 <jmcarthur> chegibari: i think the haskell platform is completely borked in the latest version of ubuntu
10:01:41 <chegibari> oh good
10:02:01 <jmcarthur> yeah they did a great job
10:02:03 <int-e> ski: why give an otherwise clause at all? just fall through to the next case, which will then be (x:xs) ... http://hpaste.org/46729/title_must_be_provided
10:02:04 <chegibari> it was half borked in the previous version and I upgraded just forthat
10:02:06 <ski>         ('e',x_1:acc) -> loop acc (x_1:"ea"++xs)
10:02:13 <ski> or something like that
10:02:13 <jmcarthur> heh, bad idea
10:02:22 <int-e> (can somebody explain to me why it suggests foldr?)
10:02:27 <ski> int-e : yeah, that's probably better
10:02:36 <int-e> ah. because I messed up the identifier.
10:02:39 <zygoloid> int-e: i love your choice of title :)
10:03:01 <chegibari> what do people use to program in haskell then?
10:03:05 <ski> (int-e : oh, you didn't annotate ?)
10:03:14 <jmcarthur> anything but ubuntu, basically
10:03:20 <jmcarthur> or just install manually
10:03:20 <chegibari> ah
10:03:29 <jmcarthur> instead of using the ubuntu packages
10:03:35 <chegibari> is vanilla debian ok?
10:03:38 <int-e> ski: I did, then it demanded a title and then it became a new paste. Perhaps I did something wrong (other than not providing a title from the beginning)
10:03:41 <jmcarthur> yes
10:03:45 <chegibari> ok
10:03:51 <jmcarthur> well, unstable, at least. i don't know about stable
10:04:22 <chegibari> thanks god virtual machines are cheap reinstall
10:04:44 <zygoloid> that HList warning is amazing :)
10:04:49 <jmcarthur> why not use your host machine?
10:04:59 <chegibari> jmcarthur: thanks. I thought ubuntu was cool but apparently it's all marketing
10:05:01 <jmcarthur> is it ubuntu?
10:05:22 <jmcarthur> eh, i'm not going to bad mouth ubuntu a lot here. it does some things right and other things wrong
10:05:38 <chegibari> no I use linux in virtual machines. I usually use windows, visual studio and all that stuff
10:05:43 <jmcarthur> ah
10:05:48 <jmcarthur> well, haskell works on windows too
10:05:59 <Jafet> HLi...nt?
10:06:16 <chegibari> but I thougt experimental studd was easier to compile and install on linux
10:06:21 <chegibari> stuff
10:06:45 <int-e> ski: And yes, if I had provided a title it seems it would've become an annotation. (Why do annotations need their own title anyway?)
10:06:50 <jmcarthur> i find linux nicer to use in nearly every way, but it's largely personal preference
10:07:07 <chegibari> for usual stuff GHCi on windows is cool
10:07:35 <int-e> Or is that solely an anti-spam measure?
10:08:41 <jmcarthur> afaik, arch linux and debian unstable have the best infrastructure for haskell stuff, btw
10:09:01 <jmcarthur> gentoo supposedly has a simple overlay, but i don't know much about how overlays really work
10:09:39 <jmcarthur> and of course those are probably not the only distros with decent support, but they are the ones i hear the most positive and least negative for haskell
10:10:21 <Silvah> int-e: well, that's certainly cleaner than my code.
10:10:22 <Eduard_Munteanu> In Gentoo you merely have 'layman' fetch and install the overlay, then you unmask the packages you want to use.
10:10:40 <chegibari> jmcarthur: thanks for the suggestions. I'm going to try debian unstable
10:12:46 <ski> int-e : i'm not sure. i usually don't feel it too onerous to provide a simple title, though
10:13:09 <ski> (however the title maximal length is *way* too small ..)
10:15:25 <alt-nick> hmm
10:15:30 <spirit_> when i want to read from file, via hGetContents, and the contents of my file look like this: ["1[label=singleNodeAff]"] do i need to escape quotation marks?
10:15:32 <dankna> hmm
10:15:48 <int-e> ski: I agree it's not too much.
10:15:57 <dankna> so I'm trying to deepseq a bunch of records, and some of them have Maybe fields
10:16:10 <dankna> Control.DeepSeq appears to define an instance NFData a => NFData (Maybe a)
10:16:24 <jmcarthur> hmm
10:16:24 <dankna> and I do have the instance NFData a in the same file
10:16:46 <dankna> but I'm getting a compile-time error that there is no instance NFData (Maybe a) (for my specific value of a)
10:16:50 <dankna> any clues? :)
10:16:50 <byorgey> spirit_: no, hGetContents just gives you the raw contents of the file as a String, it does no interpretation/parsing at all
10:17:07 <scooty-puff> http://pastebin.com/zWt52XrJ
10:17:10 <scooty-puff> this does not compile
10:17:25 <scooty-puff> does anyone have any advice as to how to properly write the Show constraint?
10:17:28 <Silvah> pastebin.com?
10:17:54 <jmcarthur> scooty-puff: i would be surprised if deriving works with GADTs at all
10:18:01 <Silvah> Nooo, use hpaste, or anything, but not pastebin.com...
10:18:02 <Eduard_Munteanu> WTH?
10:18:14 <Eduard_Munteanu> It breaks my xmobar string
10:18:15 <byorgey> Silvah: what's wrong with pastebin.com?
10:18:29 <jmcarthur> Eduard_Munteanu: the pastebin link? works in mine
10:18:34 <Silvah> Copying doesn't work.
10:18:45 <scooty-puff> i tried writing the Show instance manually, but had trouble in defining the constraint instance (Show (a x y)) => ...
10:18:48 <jmcarthur> i find pastebin difficult to read
10:18:48 <spirit_> so it's alright if i print contents yields "[\"1[label=singleNodeAff]\"]
10:18:51 <Eduard_Munteanu> jmcarthur: yeah, but loading it in Firefox makes xmobar behave funny.
10:18:55 <jmcarthur> hpaste much easier on the eyes
10:19:08 <Eduard_Munteanu> I get "CoulCould not parse string [...]"
10:19:12 <int-e> Silvah: you can always copy the "raw paste data"
10:19:17 <Saizan> scooty-puff: you can't, basically
10:19:31 <jmcarthur> spirit_: '\"' is a single character, not two
10:19:40 <int-e> (disclaimer, I have javascript disabled, I don't know whether they hide that part when using JS)
10:19:50 <Saizan> scooty-puff: you'd need a constraint like instance forall x y. Show (a x y) => Show (List i a) and you can't
10:19:53 <scooty-puff> Saizan, is there anyway to say for all x and y?
10:19:56 <Eduard_Munteanu> Maybe I'm not escaping stuff correctly.
10:19:58 <Silvah> int-e: on hpaste you can copy the colorized code and it'll work fine.
10:20:01 <scooty-puff> Saizan, o
10:20:13 <Eduard_Munteanu> Anyway, pastebin.com is alright I guess.
10:20:21 <Saizan> scooty-puff: unless you define a typeclass class Show2 a where show2 :: a x y -> String
10:20:48 <int-e> Silvah: yes, I was describing a workaround, not saying that pastebin.com's behaviour is good :)
10:20:57 <spirit_> cheers!
10:21:06 <scooty-puff> Saizan, that will do it, thanks
10:21:20 <Eduard_Munteanu> int-e: well yeah, I'm using noscript as well
10:21:48 <dankna> no clue?  okay - in general, how do I debug why an instance that is defined isn't being found?
10:22:01 <byorgey> scooty-puff: by the way, you can put all the extensions in a single pragma, like {-# LANGUAGE X, Y, Z #-}
10:22:30 <scooty-puff> byorgey, i had, but once it gets over 80 characters, i usually break them out (or newline separate)
10:23:00 <Saizan> dankna: it means it's defined in a module you aren't importing
10:23:01 <byorgey> sure, but you can break a single pragma over multiple lines
10:23:13 <byorgey> it's not a big deal, either way is fine, just thought maybe you didn't know
10:23:19 <int-e> Saizan, scooty-puff: that Show2 class does not allow any interesting implementations though, does it? I mean, you get at all the structure of 'a', of course, but you can do nothing with x or y.
10:23:21 <scooty-puff> k, thanks
10:23:34 <dankna> Saizan: I am though :( it's defined in Control.DeepSeq, and I checked the source of the deepseq package (checking that it's the same version I'm actually running) and there's only one source file in it, so it's not a re-export issue
10:23:43 <scooty-puff> yeah, i'm using x and y as phantom types, so they're really just getting in the way here
10:24:06 <zygoloid> int-e: that's sorta the nature of the problem, though. x and y genuinely could be anything, unless (:<) grows a constraint
10:24:18 <dankna> I mean it's a trivial instance, so I could always work around it by adding my own definition, but I'm nervous about that producing misbehavior
10:24:30 <dankna> plus I don't like things that I don't understand
10:24:34 <int-e> zygoloid: yes, I wasn't aware that they're phantom types. if they are, Saizan's suggestion is exactly the right solution
10:24:43 <zygoloid> *nod*
10:26:12 <Saizan> dankna: is it easy to reproduce?
10:26:43 <dankna> Saizan: for me, yes, happens every time.  it's part of that same project with the exotic build system, but in this case I can probably do a reduction in about ten minutes if you want one.
10:27:02 <dafis> dankna:  if Saizan doesn't, I do :)
10:27:04 <ski> scooty-puff : make sure to have `showsPrec2' in it, not just `show2' ..
10:27:15 <dankna> dafis: thanks :) and hi, I don't believe you and I have talked before.
10:27:20 <scooty-puff> ski, ok
10:27:21 <dankna> I shall get working on it, then
10:28:08 <int-e> ski: Ah, my hpaste problem also comes down to having Javascript disabled. With Javascript, I a) get a default for the title and b) it doesn't actually submit anything if I leave the title out.
10:28:08 <dafis> dankna:  I'm not sure, but I think we took part in a couple of conversations simultaneously here over time
10:28:21 <ski> int-e,scooty-puff : well, you should add `Show' constraints on `x' and `y', of course
10:28:42 <dankna> dafis: hmm it's certainly possible.
10:28:58 <dafis> dankna:  but not important, is it?
10:29:19 <ski> int-e : oh, i've never noticed anything about default titles .. but then i use w3m, which doesn't support ECMAScript ..
10:29:30 <dankna> no, not at all important, I was only asking by way of "cool, someone new"
10:30:02 <dafis> dankna:  no, I'm just often not here for a while, so people sometimes forget me
10:30:22 <dankna> gotcha
10:30:27 <Eduard_Munteanu> Yeah, I've seen dafis around
10:30:27 * ski . o O ( .. how could one forget dafis ? )
10:30:45 <dankna> OH
10:30:47 <dafis> ski:  Alzheimer's, Amnesia, ...
10:30:51 <dankna> I figured it out in the course of doing the reduction
10:30:56 <dankna> the instance in question was on Maybe
10:31:24 <dankna> I had completely forgotten that as part of an earlier change I was using a custom version of Maybe!
10:31:31 <jmcarthur> lol
10:31:33 <dankna> (to add strictness)
10:31:37 <dafis> dankna:  oops
10:31:40 <dankna> quite so
10:31:40 <ski> dafis : my condolences ..
10:31:59 <dafis> ski:  np, I know the solution now
10:32:25 <ski> dafis : haha ! :)
10:32:36 <ski> s/dafis/dankna/
10:32:48 <dankna> ski: yeah :) pretty amusing explanation
10:43:56 <luite> are there existing "safe evaluation" programs for haskell, that let the user upload their own haskell module (including language pragma's and imports)?
10:44:22 <dankna> mueval and lambdabot both do it
10:44:25 <dankna> I believe there was an effort to merge them
10:44:32 <dankna> but I don't know where it got
10:44:41 <luite> dankna: hmm, how can a user add an import to lambdabot?
10:44:45 <zygoloid> lambdabot uses mueval
10:44:52 <dankna> oh, so the merging did happen then
10:45:01 <danharaj> FUCK
10:45:02 <Jafet> I think luite wants safe execution as well
10:45:06 <danharaj> hmatrix is GPL.
10:45:07 <dankna> luite: I don't think that functionality is exported on the IRC interface
10:45:13 * danharaj MEH
10:45:22 <luite> theres @let which I believe adds things to a L.hs file
10:45:26 <tg_> inside do <..>, what are some alternative names for return (so as not to conflict with the imperative version)
10:45:27 <luite> but not a complete module
10:45:32 <Jafet> Take a stress pill, danharaj.
10:45:33 <tg_> is "yield" a good one?
10:45:37 <Jafet> The blue ones.
10:45:38 <dankna> luite: I would check the mueval docs then
10:45:47 <dankna> Jafet: yes, haha
10:45:48 <Jafet> tg: pure
10:45:48 <danharaj> Jafet: I sampled all of the pills in my cabinet. Am I doing it right.
10:45:50 <jmcarthur> danharaj: yeah... :\
10:46:00 <tg_> Jafet: ohhhh yeah... lol that makes sense
10:46:08 <tg_> Jafet: that's also the only function in "Pointed" typeclass, isn't it?
10:46:09 <luite> dankna: I've already seen the source code, but I don't think it does that
10:46:15 <luite> the L.hs part is lambdabot
10:46:21 <dankna> oh, hm
10:46:32 <Jafet> luite: the only one I know that lets you execute arbitrary actions is geordi/codepad
10:46:36 <Jafet> Er, ideone probably has its own too
10:46:43 <luite> Jafet: is its code available?
10:46:49 <luite> I don't want IO by the way
10:46:57 <Jafet> Then you won't need that
10:46:58 <luite> at least not unrestricted
10:47:12 <tg_> luite: when you get your answer -> h-m
10:47:12 <luite> I'll use some safe type so that some IO actions can be executed
10:47:35 <Jafet> hackage seems to have one of those.
10:47:41 <noteventime> Isn't return usually called µ in category theory? :)
10:48:02 <noteventime> Or is it join that tends to be called µ
10:48:13 <ski> tg_ : also `unit' and `eta' have been used ..
10:48:14 <dafis> noteventime:  join
10:48:19 <ski> noteventime : yes
10:48:34 <noteventime> Not the most explanatory name in a programming setting though
10:48:48 <tg_> ski: eta?
10:48:53 <noteventime> Right, eta for return
10:48:54 <tg_> ski: unit also makes sense
10:49:38 <noteventime> Though eta has a tendency to be used for natural transformations in general
10:49:44 <tg_> though unit is specifically "return ()" right?
10:49:51 <luite> Jafet: the problem is that I do want to prevent IO action, so I need more safety in the program itself than geordi, but I need to allow much more than mueval
10:50:08 <ski> η
10:50:19 <tg_> luite: just allow IO actions that make sense in the framework of pandoc or whatever
10:50:36 <tg_> only allow transformations from markup -> markup
10:50:48 <luite> tg_: I'll wrap them in some special type that I execute
10:51:10 <Jafet> I don't suppose you can adapt mueval to recognize anything of the SafeIO type and execute it
10:51:12 <ski> tg_ : no `unit :: a -> m a', and `multiply :: m (m a) -> m a' (i haven't seen `multiply' like this, but i think it's what `mu' is short for)
10:51:37 <danharaj> mu is not short for anything, it's the greek letter mu.
10:51:42 <ski> yes
10:51:47 <danharaj> That natural transformation I've seen called 'join'.
10:51:49 <luite> SafeIO, is that an existing thing?
10:51:58 <luite> or do you just mean some hypothetical newtype :)
10:52:03 <ski> which was presumably chosen because of the inital sound in the pronounciation of `multiply'
10:52:19 <tg_> ski: moo-tiply?
10:52:19 <Jafet> It exists in a package, but I have no idea what it's called
10:52:33 <tg_> ST?
10:52:42 <danharaj> probably not, and the claim is unverifiable either way. If you're using multiple natural transformations in a definition, you tend to just use consecutive greek letters.
10:52:42 <tg_> no
10:52:55 <ski> tg_ : take initial phoneme, write it with a greek letter
10:53:32 <monochrom> luite: codepad.org seems to be willing to execute your code, including haskell
10:53:41 <Eduard_Munteanu> It's actually closer to 'maul' than to 'mu'.
10:54:04 <luite> monochrom: that seems to be down, is that a bad sign? :)
10:54:06 <Jafet> codepad executes executables
10:54:07 <Jafet> It cares little for haskell expressions
10:54:20 <monochrom> yeah I can't get it to respond either :)
10:55:11 <luite> it's for this thing by the way, I've shown it before, but I've been hacking on it a bit more: http://jabberwock.xs4all.nl/exp/wolfgang/
10:55:28 <luite> in the example there's a cell with haskell source code
10:55:46 <ski> @hackage twilight-stm
10:55:46 <lambdabot> http://hackage.haskell.org/package/twilight-stm
10:55:55 <luite> the haskell source code snippets should be combined to a module, each snippet might have a list of language pragma's and imports
10:56:08 * ski seems to recall there was some other package for safe I/O, but can't recall it
10:56:10 <luite> and these should be loaded for evaluating the expression cells
10:56:29 <dankna> ah cool, you added explanatory paragraphs
10:56:57 <luite> dankna: I fixed some of the editor glitches too :)
10:57:00 <dankna> nice :)
10:58:02 <luite> it's still quite unpolished of course, loading the modules on the server is quite important and tricky to get right, so I want to get that done early
10:58:08 <tg_> ski: lol, I was very close.. ST -> STM  heh
10:58:10 <tg_> lucky guess
10:58:13 <mkscrg> Anybody know an easy way to get more verbosity from an exception in ghci? As in, I'd like a line number associated with "Prelude.head: empty list"
10:59:10 <noteventime> Talking of category theory, does anyone know of a good explanation of why the Yoneda Lemma (_not_ the usual proof of it) implies full faithfullness of the Yoneda embedding. All proofs I've seen either refer to the exact structure of the natural isomorphism given in the proof of the yoneda lemma or just gloss over it. It's probably trivial, but I just can't seem to figure it out.
10:59:10 <dankna> mkscrg: s/head/(trace "A" head)/g in all your source files, with a different string instead of "A" for each instance
10:59:20 <dankna> mkscrg: will produce very verbose output in a real program though
10:59:57 <dankna> mkscrg: this is why we don't like pure code that throws exceptions - it's quite difficult to trace those exceptions to their sources
11:00:54 <mkscrg> dankna: Thanks, that's a good idea. It's barely more than a toy, so I'll give that a try.
11:00:55 <ClaudiusMaximus> or, s/head/(\(x:xs)->x)/ (i seem to recall unmatched patterns give location information?)
11:01:01 <dankna> yeah
11:01:19 <mkscrg> nice
11:01:44 <mkscrg> Also you make a good point about head being unsafe. I'd never seen it as a real issue until now
11:02:30 * dankna nods
11:02:35 <jmcarthur> well, it's unsafe if you consider partiality to be an effect, at least
11:03:22 <luite> monochrom: I think I need to parse the snippets for imports and language pragma's, then check those against the whitelisted modules and pragma's, and then combine everything in a single module by moving the imports to the right place
11:03:38 <luite> dankna: oh the haskell source editor + highlgihter is new too
11:03:40 <jmcarthur> when i first started haskell, i saw partiality as an exception (and therefore unsafe), then i learned to work with _|_ effectively and integrated it into my pure mental model of computation, then i started seeing _|_ as an effect rather than a value so now i consider partiality to be a kind of effect again
11:03:57 <dankna> oh you implemented highlighting?  nice
11:04:23 <luite> dankna: well implemented.. I added the haskell parser/highlighter from codemirror to the javascript includes :p
11:04:30 <dankna> ah gotcha
11:04:49 <jmcarthur> err... my first use of the word "partiality" was intended to be restricted to "undefined" and "error", not to infinite loops
11:04:50 <ski> mkscrg : also see <http://www.haskell.org/ghc/docs/latest/html/users_guide/assertions.html>
11:05:34 <jmcarthur> the thing that changed is that now i see infinite loops as effects as much as i see thrown errors as effects
11:06:41 <dankna> hm
11:06:41 <dankna> interesting
11:07:03 <ski> @hackage safe
11:07:03 <lambdabot> http://hackage.haskell.org/package/safe
11:07:09 <ski> mkscrg : also that ^
11:07:40 <Eduard_Munteanu> The thing is both undefined and infinite loops make a definition partial because you don't get a result out of it.
11:07:59 <jmcarthur> right
11:08:21 <jmcarthur> well, the result is _|_ if you want to look at _|_ as a value
11:08:35 <jmcarthur> but i think it's easier to reason about code without _|_, therefore the classification of partiality as an effect
11:08:57 <luite> does haskell-src-exts parseFile automatically load required fixities to parse a file?
11:09:14 <ski> (.. there's a difference between a computation ending without a value, and it not ending at all)
11:09:41 <jmcarthur> luite: it might if the fixity is in the file itself (don't know for sure), but i know it doesn't if the fixity is in another module entirely
11:09:42 <ski> (hence nontermination is a different effect than partiality)
11:10:00 <monochrom> @quote monochrom debate
11:10:00 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
11:10:07 * hackagebot wai-handler-devel 0.4.3 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-0.4.3 (MichaelSnoyman)
11:10:42 <jmcarthur> nontermination is a value in domains that include partial functions
11:10:45 <luite> jmcarthur: hmm, that would make it difficult to use I guess...
11:11:05 <danharaj> is there a way to make ghci list the contents of a loaded module?
11:11:28 <monochrom> ":browse MyModule" lists something
11:11:33 <danharaj> <3
11:12:05 <Test_> hello
11:12:11 <Test_> who is in here?
11:12:12 <danharaj> :o it looks like I need to compile it first? "Failed to load interface for `Foo' "
11:12:24 <luite> but I don't need to fully parse the .hs files, just lexing to find the imports and the LANGUAGE pragma's is enough
11:12:27 <ski> Test_ : try typing `/names' ..
11:12:31 <jmcarthur> Test_: only 780 people
11:12:37 <monochrom> if it is your own module, you only need ":load MyModule"
11:12:38 <Test_> '/names'
11:12:49 <ski> *without* the quotes ..
11:12:50 <jmcarthur> oh no
11:12:56 <monochrom> if it is a lib module, you don't even need :load
11:13:44 <monochrom> if it doesn't say "module MyModule where", :browse Main
11:15:36 <danharaj> monochrom: Ah silly me, I thought :b was short for :browse :p
11:15:59 <dcoutts> k0ral: ohh, ok. So you change a module in another package, but don't re-install that package?
11:16:02 <dafis> danharaj:  it was, before the debugger
11:16:36 <Test_> hey what ide do yall use for haskell?
11:16:41 <monochrom> yeah, the only other "b" commands are "back" and "break" for the debugger
11:16:47 <dafis> kate + ghci
11:16:55 <Cobra> vim
11:16:58 <djahandarie> emacs/haskell-mode
11:17:00 <jmcarthur> Test_: i think most of us probably use either vim or emacs
11:17:00 <dschoepe> Test_: emacs
11:17:10 <monochrom> I used to just write ":b MyModule" too a long time ago
11:17:24 <monochrom> I use emacs
11:17:32 <jmcarthur> emacs here as well
11:17:37 <noteventime> emacs :)
11:17:38 <Test_> wow, alot of emacs
11:17:43 <temoto> Hello. How to get a list of all possible permutations (not sure it's the proper word) for a list? [1,2,3,4] -> [[1,2,3,4], [1,3,4,2], [1,4,3,2], ...]
11:17:48 <monochrom> any editor you like is good enough
11:18:02 <dafis> temoto:  Data.List.permutations
11:18:05 <Jafet> > permutations [1..4]
11:18:05 <lambdabot>   [[1,2,3,4],[2,1,3,4],[3,2,1,4],[2,3,1,4],[3,1,2,4],[1,3,2,4],[4,3,2,1],[3,4...
11:18:07 <ski> Test_ : a few probably uses yi or leksah .. and ManateeLazyCat uses Manatee
11:18:12 <monochrom> unless you absolutely insist on a full-blown IDE
11:18:13 <dankna> TextWrangler, a GUI text editor for the Mac
11:18:19 <Test_> I was just wondering, can anyone link me to a website that shows instructions for getting haskell working on emacs
11:18:22 <int-e> @where permutations
11:18:22 <lambdabot> I know nothing about permutations.
11:18:29 <Test_> cuz I can't find anything
11:18:29 <dankna> I saw something the other day which points out that there are two kinds of IDEs, good ones and bad ones, haha
11:18:30 <int-e> @index permutations
11:18:30 <lambdabot> bzzt
11:18:37 <jmcarthur> Test_: google haskell-mode
11:18:40 <dankna> and that it's important to realize that the good ones actually are decent ways to work
11:18:42 <Jafet> @permutations where
11:18:42 <lambdabot> Unknown command, try @list
11:18:44 <danharaj> @where haskell-mode
11:18:44 <lambdabot> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
11:18:45 <int-e> @hoogle permutations
11:18:45 <lambdabot> Data.List permutations :: [a] -> [[a]]
11:18:46 <djahandarie> Does anyone know how yi development is coming along? Last I looked at it, it looked really damn complicated for an editor. Must be one of the most complicated applications on Hackage
11:18:49 * danharaj boom B)
11:19:05 <danharaj> Isn't Yi supposed to be emacs but better and haskell?
11:19:22 <ski> @where aliquot_sequences
11:19:22 <lambdabot> I know nothing about aliquot_sequences.
11:19:46 <ski> @where yi
11:19:46 <lambdabot> http://www.haskell.org/haskellwiki/Yi
11:19:49 <ski> @where leksah
11:19:49 <lambdabot> http://www.leksah.org/
11:19:55 <ski> @where manatee
11:19:55 <lambdabot> I know nothing about manatee.
11:19:58 <ski> ho, hum
11:20:19 <Eduard_Munteanu> I hear Yi's vim mode is quite sucky, isn't it?
11:20:31 <Eduard_Munteanu> I'd consider it as a scriptable Vim alternative otherwise.
11:20:35 <djahandarie> I wouldn't mind something like Leksah, but when I tried it awhile back the interface was just... weird
11:21:15 <noteventime> Maybe I should give Yi a try again
11:21:31 <ski> @ask ManateeLazyCat maybe you would like to add a `@where+ manatee <http://path/to/manatee/information>' ?
11:21:31 <lambdabot> Consider it noted.
11:22:19 <temoto> @djinn String -> IO Int
11:22:19 <lambdabot> Error: Undefined type String
11:22:28 <temoto> @djinn [Char] -> IO Int
11:22:28 <lambdabot> Error: Undefined type []
11:22:43 <ski> `djinn' doesn't support recursive types
11:22:59 <temoto> looking for "123" -> 123, "x" -> error
11:23:03 <ski> (nor abstract types like `IO' (other than `(->)', of course))
11:23:13 <Jafet> temoto: const (return 0)
11:23:16 <Jafet> Ta-da!
11:23:25 <ski> > read "123" :: Int
11:23:26 <lambdabot>   123
11:23:28 <ski> > read "x" :: Int
11:23:29 <lambdabot>   *Exception: Prelude.read: no parse
11:23:34 <temoto> Yeah, thanks.
11:23:41 <Jafet> @hoogle String -> Int
11:23:42 <lambdabot> Test.HUnit.Base Label :: String -> Node
11:23:42 <lambdabot> Prelude read :: Read a => String -> a
11:23:42 <lambdabot> Text.Read read :: Read a => String -> a
11:24:14 <temoto> Hm, how to read N ints?
11:24:21 <copumpkin> dons: you in NYC yet?
11:24:23 <ski> > case (reads :: ReadS Int) "x" of [(n,"")] -> Just n; _ -> Nothing  -- when you want catch the error
11:24:24 <lambdabot>   Nothing
11:24:36 <noteventime> temoto: Depends on how they're separated
11:24:37 <Jafet> read N times
11:24:39 <ski> temoto : use `reads' for that, as well
11:26:03 <temoto> > (reads :: ReadS (Int, Int)) "3 4"
11:26:04 <lambdabot>   []
11:26:27 <ski> > (reads :: ReadS (Int, Int)) "(3,4)"
11:26:28 <lambdabot>   [((3,4),"")]
11:26:43 <temoto> Mine are separated with space.
11:27:32 <dons> copumpkin: few more weeks
11:28:24 <copumpkin> dons: cool :)
11:31:04 <ski> > case replicateM 4 (StateT (reads . dropWhile isSpace)) `runStateT` "0 12 345 6789" of [(ns,"")] -> ns :: [Integer]
11:31:05 <lambdabot>   [0,12,345,6789]
11:31:10 <ski> temoto : ^
11:31:29 <temoto> cheesus christ
11:31:33 <ski> you can probably do it more fancy
11:31:48 <temoto> ski, thank you.
11:31:52 <ion> ghci> let natural :: Parser Integer; natural = read <$> many1 digit in parse (sepBy natural space <* eof) "" "0 12 345 6789"
11:31:55 <ion> Right [0,12,345,6789]
11:32:29 <ski> (that was the simplest/fastest way i could think of .. realizing i had to add `:: [Integer]' at the end there took the most time)
11:32:55 <ski> indeed, if you need more complicated reading, you should use a parsing framework
11:33:16 <djahandarie> ski, I wonder if that would translate nicely to an ala/under usage
11:33:22 <mauke> > map read $ words "0 12 345 6789" :: [Integer]
11:33:23 <lambdabot>   [0,12,345,6789]
11:33:30 * ski doesn't understand `ala'
11:33:39 <copumpkin> :t ala
11:33:40 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
11:33:48 <djahandarie> I wish that type signature were nicer
11:33:48 <ski> mauke : that doesn't handle parse failure
11:33:59 <copumpkin> type families ftw
11:34:00 <copumpkin> ;)
11:34:04 <copumpkin> fuck ghc 6
11:34:09 <djahandarie> lol
11:34:52 <ion> FWIW, the Parsec version gives quite nice error messages. ghci> let natural :: Parser Integer; natural = read <$> many1 digit in parse (sepBy natural space <* eof) "" "0 12 345 x 6789"
11:35:02 <ion> Left (line 1, column 10): unexpected "x", expecting digit
11:35:12 <temoto> mauke, thanks, that's way simpler.
11:35:37 <ski> > map read $ words "0 12 345 oops 6789" :: [Integer]  -- temoto
11:35:37 <lambdabot>   [0,12,345,*Exception: Prelude.read: no parse
11:35:45 <ski> > case replicateM 4 (StateT (reads . dropWhile isSpace)) `runStateT` "0 12 345 oops 6789" of [(ns,"")] -> ns :: [Integer]
11:35:46 <lambdabot>   *Exception: <interactive>:3:0-118: Non-exhaustive patterns in case
11:35:49 <ski> heh
11:35:59 <ski> > case replicateM 4 (StateT (reads . dropWhile isSpace)) `runStateT` "0 12 345 oops 6789" of [(ns,"")] -> Just ns :: [Integer]; _ -> Nothing
11:36:00 <lambdabot>   Couldn't match expected type `[GHC.Integer.Type.Integer]'
11:36:00 <lambdabot>         against i...
11:36:02 <ski> (:
11:36:13 * ski sighs
11:36:14 <ski> > case replicateM 4 (StateT (reads . dropWhile isSpace)) `runStateT` "0 12 345 oops 6789" of [(ns,"")] -> Just (ns :: [Integer]); _ -> Nothing
11:36:15 <lambdabot>   Nothing
11:36:19 <ski> there you go
11:36:34 <Perlkonig> Hello, all! I was wondering what variant of "map" maps a function over every element in a multidimensional list?
11:36:38 <mauke> > case replicateM 4 (StateT (reads . dropWhile isSpace)) `runStateT` "0 12 345 6789" of [(ns,"")] -> Just (ns :: [Integer]); _ -> Nothing
11:36:40 <temoto> I prefer errors :)
11:36:40 <lambdabot>   Just [0,12,345,6789]
11:37:17 <RayNbow> :t fmap . fmap
11:37:18 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
11:37:21 <mauke> > case replicateM 4 (StateT reads) `runStateT` "0 12 345 6789" of [(ns,"")] -> Just (ns :: [Integer]); _ -> Nothing
11:37:22 <lambdabot>   Just [0,12,345,6789]
11:37:35 <dafis> :t map . map
11:37:36 <noteventime> > let { sepBy _ [] = []; sepBy p xs = (:) <$> fst <*> sepBy p . dropWhile p . snd $ break p xs } in sepBy isSpace
11:37:36 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
11:37:37 <lambdabot>   Overlapping instances for GHC.Show.Show
11:37:37 <lambdabot>                              ([GHC....
11:37:46 <mauke> :t unfoldr
11:37:47 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
11:37:49 <RayNbow> :t fmap fmap fmap
11:37:50 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
11:38:05 <Perlkonig> Thank you.
11:38:14 <mauke> Perlkonig: map
11:38:17 <ski> mauke : ah, nice .. i was thinking i needed the `dropWhile isSpace' when i got failure due to parsing `[()]'
11:38:21 <noteventime> > let { sepBy _ [] = []; sepBy p xs = (:) <$> fst <*> sepBy p . dropWhile p . snd $ break p xs } in sepBy isSpace "11 22 33 44"
11:38:22 <lambdabot>   ["11","22","33","44"]
11:38:35 <RayNbow> > fmap fmap fmap sqrt $ [[1..10], [], [11..20]]
11:38:36 <lambdabot>   [[1.0,1.4142135623730951,1.7320508075688772,2.0,2.23606797749979,2.44948974...
11:38:44 <ski> temoto : so, scratch the `. dropWhile isSpace' ..
11:40:14 <aristid> > sqrt .: [[1..10], [], [11..20]]
11:40:16 <lambdabot>   [[1.0,1.4142135623730951,1.7320508075688772,2.0,2.23606797749979,2.44948974...
11:40:17 <noteventime> Never mind whatever I wrote :p not nice in any way
11:40:22 <ion> aristid: haha
11:42:09 <ski> temoto : btw, <http://cvs.haskell.org/Hugs/pages/libraries/base/Text-ParserCombinators-ReadP.html> is a nice little parsing lib .. as is <http://hackage.haskell.org/packages/archive/Encode/1.1/doc/html/Parsek.html>
11:42:28 <djahandarie> I really need to add instances for mtl to Newtype
11:42:54 <noteventime> Perlkonig: Not sure it's what you wanted, but can't you just do nested maps?
11:42:54 <djahandarie> I can't decide on how to do it though
11:42:57 <djahandarie> Someone decide for me
11:43:04 <copumpkin> do it right.
11:43:05 * ski idly wonders whether there is any main difference between those, both having been written by Claessen, and both doing parallel parsing
11:43:06 <copumpkin> :)
11:43:15 * hackagebot mysql 0.1.1.1 - A low-level MySQL client library.  http://hackage.haskell.org/package/mysql-0.1.1.1 (BryanOSullivan)
11:43:21 <djahandarie> Add more dependencies to the package, or create another package with a bunch of orphans?
11:43:46 <scavenger> isMyVal :: String -> Bool
11:43:47 <scavenger>   isMyVal "url" = True
11:43:47 <scavenger>   isMyVal _ = False
11:44:02 <temoto> ski, yeah, i used parsec in past, but reading some integers separated by space for programming contest requires way simpler things than parsec. (map read) . words  is fine enough.
11:44:04 <djahandarie> I think I'll just create another package with orphans
11:44:07 <scavenger> malformed class assertion
11:44:11 <scavenger> why
11:44:15 * hackagebot mysql-simple 0.2.1.2 - A mid-level MySQL client library.  http://hackage.haskell.org/package/mysql-simple-0.2.1.2 (BryanOSullivan)
11:44:23 <ski> temoto : btw, note that `Parsec' and `Parsek' are different ..
11:44:26 <k0ral> dcoutts: ^^ no, but don't bother I cleaned the files and now it works fine
11:45:02 <djahandarie> bos, when do we get a high-level MySQL client library? :D
11:45:12 <ski> scavenger : `isMyVal = ("url" ==)'
11:45:19 <bos> djahandarie: whenever someone writes one :-)
11:45:32 <djahandarie> Heh
11:45:46 <temoto> ski, oh, maybe parsek is rewrite to try some new approaches?
11:45:54 <bos> i think of "high-level" as "i can write queries using a type-safe Haskell EDSL"
11:45:59 <bos> which i'm not gonna write
11:46:00 <djahandarie> Yeah
11:46:29 <djahandarie> Those sorts of things end up being harder to use anyways do to the type-magic usually required to make them work
11:46:30 <scavenger> tx ski but i'm trying to understand why my idea didn't compile
11:46:30 <danharaj> ... why does codec.bmp think my bitmap has zero image size.
11:46:33 <danharaj> God damnit.
11:46:35 <djahandarie> due*
11:47:38 <eyebloom> Is there anyone who wouldn't mind helping interpret a small piece of code?
11:48:34 <djahandarie> eyebloom, sure.
11:48:54 <djahandarie> Drop it in http://hpaste.org and paste the link here
11:49:02 <eyebloom> I'm just learning haskell, otherwise experienced.
11:49:29 <eyebloom> one moment
11:50:53 <emir> hi lazy people
11:51:00 <eyebloom> http://hpaste.org/46731/snippet_from_graph_algorithm
11:51:23 <eyebloom> This is from an inductive graph traversal algorithm.
11:51:41 <eyebloom> Basically the part I don't understand is the match function.
11:51:58 <eyebloom> And it's been hard to search for because it's such a common term.
11:52:21 <eyebloom> It's not in Prelude, but I can't tell where it's imported from.
11:52:52 <eyebloom> I'm sure it's standard :(
11:53:49 <danharaj> can anyone help me figure out why Codec.BMP hates my bitmaps?
11:53:55 <monochrom> package "fgl", module "Data.Graph.Inductive.Graph", it's a class method of class "Graph"
11:54:46 <monochrom> it doesn't come with GHC, but it comes with Haskell Platform
11:55:47 <eyebloom> Thanks, how can you tell that, or are you just familiar with the module?
11:56:37 <ClaudiusMaximus> @hoogle match +fgl
11:56:37 <lambdabot> Could not find file:
11:56:37 <lambdabot>     fgl
11:56:37 <lambdabot> Searched:
11:56:45 <eyebloom> Ahh, alright found it.
11:56:46 <ClaudiusMaximus> (works in the web interface)
11:57:33 <eyebloom> Thank you...
11:58:08 <ClaudiusMaximus> not sure if hoogle web interface can search all of hackage (assuming you didn't know which package), would be cool
11:58:40 <eyebloom> Just learning all these tools. Thanks for the help.
12:00:23 <danharaj> dons: do you know which mailing list I can go to for help about the bmp library? It refuses to acknowledge my bitmaps as legitimate for use with repa-io :\
12:02:33 <luite> danharaj: don't you use the repa-devil library?
12:03:21 <danharaj> luite: I don't want to use repa-devil yet.
12:03:42 <danharaj> I do want to know why the bmp library thinks my bitmaps have zero size, even though they're completely well formed.
12:04:11 <luite> hehe the bmp lib is probably very simple so it shouldn't be too hard to debug
12:04:33 <dmwit> The bmp format is pretty darn simple.
12:04:41 <dmwit> The spec is maybe one page long.
12:05:17 <gwern> @quote long
12:05:18 <lambdabot> MarkPilgrim says: "In the long run, the utility of all non-Free software approaches zero. All non-Free software is a dead end."
12:07:58 <sm> I think s/all/any particular/ would be more accurate
12:08:38 <sm> commercial software seems to always have a bit of utility here and there
12:10:21 <sm> and that remark was really unnecessary. Drat you lambdabot, drat you...
12:11:06 <Jafet> At least he capitalized "Free".
12:11:38 <Jafet> "In the long run, the utility of all projects promoting 'freedom' approach zero..."
12:16:24 * hackagebot data-clist 0.0.5 - Simple functional ring type.  http://hackage.haskell.org/package/data-clist-0.0.5 (JohnVanEnk)
12:23:17 <chegibari> The value of Mark Pilgrim's (or any other Free software advocate's) words on Free software approach zero faster than the value of non-Free software
12:33:39 <_linuxftw> I'm looking for a function to take a list and send all the even indexed elements to a new list, and all the odd indexed elements to a different list. :: [a] -> ([a], [a])
12:35:01 <hpc> index [] = []; index (x:[]) = ([x],[]); index (x:y:zs) = let (as, bs) = index zs in (x:as, y:bs)
12:35:12 <spirit__> i have a list [[1],[2]] that i'd like to flatten by one level in order to get [1],[2] -- how do i go about it?
12:35:32 <hpc> spirit__: concat
12:35:43 <hpc> :t concat
12:35:43 <lambdabot> forall a. [[a]] -> [a]
12:35:55 <hpc> :t join -- a bit more general than concat
12:35:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:37:06 <jmcarthur> :t join (***) (map snd) . partition (fst . even) . zip [0..]
12:37:07 <lambdabot>     Couldn't match expected type `(Bool, b)'
12:37:07 <lambdabot>            against inferred type `Bool'
12:37:07 <lambdabot>     In the second argument of `(.)', namely `even'
12:37:17 <jmcarthur> :t join (***) (map snd) . partition (even . fst) . zip [0..]
12:37:18 <lambdabot> forall b. [b] -> ([b], [b])
12:37:24 <jmcarthur> _linuxftw: ^^
12:37:36 <hpc> > let index [] = []; index (x:[]) = ([x],[]); index (x:y:zs) = let (as, bs) = index zs in (x:as, y:bs) in index [1..10]
12:37:37 <lambdabot>   Couldn't match expected type `[a]'
12:37:37 <lambdabot>         against inferred type `([t], [a1...
12:37:48 <jmcarthur> > join (***) (map snd) . partition (even . fst) . zip [0..] $ ['a'..'z']
12:37:49 <lambdabot>   ("acegikmoqsuwy","bdfhjlnprtvxz")
12:38:08 <hpc> > let index ([],[]) = []; index (x:[]) = ([x],[]); index (x:y:zs) = let (as, bs) = index zs in (x:as, y:bs) in index [1..10]
12:38:09 <lambdabot>   Couldn't match expected type `([t], [t1])'
12:38:09 <lambdabot>         against inferred type `[...
12:38:14 <hpc> er, whatever
12:38:18 <_linuxftw> I understand jmcarthur's solution a little better :P
12:38:27 <hpc> :P
12:38:34 <ski> > let evensOdds [] = ([],[]); evensOdds (a:as) = (a:odds,evens) where (evens,odds) = evensOdds as in evensOdds [0 .. 7]
12:38:34 <lambdabot>   ([0,2,4,6],[1,3,5,7])
12:39:04 <hpc> ski: ooh, clever
12:39:11 <_linuxftw> join (***) though? what does it do?
12:39:16 <hpc> :t join (***)
12:39:17 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
12:39:21 <jmcarthur> @unpl join (***)
12:39:21 <lambdabot> ((***) >>= \ a -> a)
12:39:27 <ski> @let [] /\/ rest = rest; (a:odds) /\/ evens = a : (evens /\/ odds)
12:39:28 <lambdabot>  Defined.
12:39:31 <jmcarthur> that doesn't really help
12:39:41 <hpc> > join (***) (+5) 4
12:39:42 <lambdabot>   (9,9)
12:39:45 <ski> > (uncurry (/\/) . evensOdds) [0 .. 7]
12:39:46 <lambdabot>   [0,1,2,3,4,5,6,7]
12:39:54 <jmcarthur> _linuxftw: it's the same as:    \f (a, b) -> (f a, f b)
12:39:57 <hpc> :t (&&&)
12:39:58 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:40:10 <_linuxftw> ahh, right
12:40:20 <ski> > (evensOdds . uncurry (/\/)) ("abcd","0123")
12:40:21 <lambdabot>   ("abcd","0123")
12:40:31 <hpc> > join (&&&) (+5) 4
12:40:32 <lambdabot>   (9,9)
12:41:25 <ski> _linuxftw : also see `evensOdds' ^
12:42:33 <ski> (hpc : btw, your fix is `index [] = ([],[])')
12:42:43 <hpc> yeah, i notices
12:42:45 <hpc> d
12:42:55 <hpc> didn't want to spam the channel any more than i already had
12:43:20 <ski> hmm ..
12:46:44 <ryant5000> @seen Cale
12:46:44 <lambdabot> Unknown command, try @list
12:46:44 <preflex>  Cale was last seen on #haskell 13 hours, 52 minutes and 36 seconds ago, saying: for example
12:47:33 <ski> @let onHalves :: ([a] -> [b]) -> ([a] -> [b]) -> ([a] -> [b]); onHalves f g = uncurry (/\/) . (f *** g) . evensOdds
12:47:34 <lambdabot>  Defined.
12:47:53 <ski> > (revese `onHalves` map toUpper) "abcdefgh"
12:47:54 <lambdabot>   Not in scope: `revese'
12:47:56 <ski> > (reverse `onHalves` map toUpper) "abcdefgh"
12:47:58 <lambdabot>   "gBeDcFaH"
12:49:41 <ski> that's in the style of `onLines',`onWords',`perLine',`perWord' at <http://www.haskell.org/haskellwiki/Tangible_Value#IO>, and other such <http://www.haskell.org/haskellwiki/DeepArrow>s
12:50:31 <ski> > (const "" `onHalves` map toUpper) "abcdefgh"
12:50:33 <lambdabot>   "BDFH"
12:50:54 <dafis> > foldr (\x ~(xs,ys) -> (x:ys,xs)) ([],[]) [1 .. ]
12:50:59 <lambdabot>   ([1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,...
12:51:32 <ski> > join (***) (take 4) (foldr (\x ~(xs,ys) -> (x:ys,xs)) ([],[]) [1 .. ])
12:51:33 <lambdabot>   ([1,3,5,7],[2,4,6,8])
12:51:38 <gwern> hm, found another problem in haskell-src-exts. `on` is ambiguous when combined with $
12:51:39 <dafis> > let (os, es) = foldr (\x ~(xs,ys) -> (x:ys,xs)) ([],[]) [1 .. ] in (take 5 os, take 5 es)
12:51:39 <lambdabot>   ([1,3,5,7,9],[2,4,6,8,10])
12:52:29 <ski> @let onHalves' :: (forall a. [a] -> [a]) -> (forall a. [a] -> [a]) -> ([a] -> [a]); onHalves' f g = uncurry (/\/) . (f *** g) . evensOdds
12:52:29 <lambdabot>   TypeOperators is not enabled
12:52:43 <ski> that's not really good either ..
12:53:49 <dons> danharaj: see also http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Repa_Tutorial#Example:_parallel_image_desaturation
12:53:51 <ski> either one should use a `forall a. [a] -> [b]' to preserve the length but change the order, or one should use `map f' for some `f' to preserve order (and length) but access elements
12:53:53 <dons> for some examples with devil
12:54:00 <ski> though i suppose one could do both, hm ..
12:54:25 <gwern> I have to say, running haskll-src-exts on thousands of haskell files seems like a pretty good test suite :)
12:57:41 <xplat> i must say i am truly impressed by the breadth and depth of yi's deps
12:57:42 <ski>   data Foo f a b = F {shuffle :: forall ab. f ab -> f ab,transform :: a -> b}
12:57:57 <ski>   runFoo :: Foo f a b -> (f a -> f b)
12:58:58 <ski>   runFoo f = fmap (transform f) . shuffle f  -- need `Functor f' as well
12:59:21 <xplat> and i get * Missing (or bad) header file: HsUnixCompat.h
12:59:33 <ski> this might make an interesting `Category'/`Arrow' ..
13:01:25 <xplat> oh, libbsd-dev
13:03:13 <dmwit> ski: Can't say I understand why you've mixed shuffle and transform together that way.
13:12:17 <ski> dmwit : just pondering around. i started wanting something ensuring that list length was preserved, but then for some reason i added the `shuffle' bit ..
13:18:52 <noteventime> ski: Looks something like a functor composed with an endo-natural transformation
13:21:39 <ski> noteventime : yeah, i soon generalized to `forall ab. f ab -> g ab' ..
13:21:44 <balor> When declaring an instance Arbitrary Foo, how can I ask for a listOf arbitrary Char?
13:22:24 <ski> balor> :t listOf
13:23:41 <balor> ski, I'm being n00bish, but I can't figure out how to give listOf a Gen Char
13:23:52 <noteventime> ski: So composition would be given by composing the functions and natural transformations separately?
13:24:16 <ski> balor : what is the type of `listOf' ? lambdabot refuses to give me an answer ..
13:24:39 <sipa> :t listOf
13:24:40 <lambdabot> forall a. Gen a -> Gen [a]
13:24:41 <ski> hm, though maybe with a qualified `@type' ..
13:24:49 <ski> @type Test.QuickCheck.listOf
13:24:50 <lambdabot> forall a. Gen a -> Gen [a]
13:25:02 <noteventime> Isn't Gen a monad?
13:25:03 <ski> yeah .. i tried `@hoogle' to no avail, and concluded it didn't know
13:25:07 <ski> yes
13:25:16 <noteventime> Why not replicateM arbitrary?
13:25:25 <noteventime> err replicateM n arbitrary
13:25:27 <ski> balor : do you want `Char' or `Foo' ?
13:25:37 <ski> @type Test.QuickCheck.vector
13:25:37 <lambdabot> forall a. (Arbitrary a) => Int -> Gen [a]
13:25:57 <balor> oh, Char.  I think listOf (Char `fmap` arbitrary) will do the trick
13:26:05 <ski> no
13:26:11 <ski> `Char' is not a constructor
13:26:15 <balor> ah
13:26:31 <ski> balor : if in the right context, `listOf arbitrary' should do it
13:26:48 <ski> otherwise, try ascribing `arbitrary' with `Gen Char'
13:27:11 <ski> i.e. `listOf (arbitrary :: Gen Char)'
13:27:32 <ski> noteventime : yes .. i'm still pondering whether this is as useful as i initially thought ..
13:28:09 <ski> noteventime : i suppose one nice thing is that one can do a projection `Foo f g cat a b -> cat a b'
13:28:24 <balor> ski, thanks.
13:30:05 <noteventime> ski: I might be a little slow at the moment, but wouldn't naturality and functoriality make it somewhat pointless to keep track of shuffle and transform separately?
13:30:24 <ski> anyway, i wonder what's the best way to combine `forall ab. f ab -> g ab' and `fmap' of an `a -> b' sequentially
13:30:46 <noteventime> Rather than just applying the functor and the natural transformation and composing the results
13:31:12 <xplat> 'sequentially' isn't necessary, those two things will always commute
13:31:12 <ski> noteventime : well, you can still project, here .. otherwise i'm not sure if there maybe is some efficiency gain
13:31:38 <ski> xplat : yes, but i have to make an arbitrary choice when writing the code .. which is better ?
13:32:37 * ski recalls having some related issue, but in a more complicated situation (composable continuations, if you must know)
13:32:54 <xplat> presumably the best thing, unless you're going to be strict, is apply NTs before fmaps, because NTs can only discard or duplicate information, so you always end up with a decrease in work :)
13:33:12 <FUZxxl> If I add "Extra-libraries:" to my .cabal file, where does cabal looks for this library?
13:33:26 <xplat> er, i guess the opposite, fmaps before NTs
13:33:40 <xplat> got a little confused
13:33:43 <ski> xplat : i was thinking that could be better as well .. and then it could be a gain to keep them separate until the `runFoo'
13:33:50 <noteventime> xplat: Why would you end up with less work if it duplicates information?
13:34:03 <xplat> noteventime: because the work would be shared
13:34:12 <ski>   runFoo f = fmap (transform f) . shuffle f  -- this order, i mean
13:34:16 <xplat> so no extra
13:34:25 <noteventime> Well, less extra :)
13:34:41 <xplat> no, shuffle f . fmap (transform f)
13:34:48 <ski> why ?
13:35:32 <ski> hmm
13:35:45 <xplat> because some of the transformed cells can be thrown away without evaluating (true either way) and the evaluation will be shared for the dups (only true this way)
13:35:52 <ski> i suppose it's better to only `transform f' duplicated elements once
13:36:05 * ski was thinking of the case of discarded elements
13:37:59 <ski> (combined with speculative evaluation, or the `shuffle f' `seq'ing elements, i suppose .. but i see this is probably not so important)
13:38:38 <xplat> so if your transform is ZipList's 'pure' composed with runIdentity, and your transform is 'factor', you definitely want to shuffle left of transform :)
13:39:15 <xplat> *if your shuffle
13:40:51 <xplat> (sadly i don't think fmap preserves cyclicity of 'cycle' in any common haskell implementation)
13:42:47 <ski> *nod*
13:42:50 <ski> @djinn (a0 -> Cont2 o0 p0 a0) -> (b0 -> Cont2 o1 p0 a1) -> ((a0,a1) -> Cont2 (o0,o1) (p0,p1) (b0,b1))
13:42:50 <lambdabot> -- f cannot be realized.
13:42:57 <ski> i wanted something along those lines ..
13:43:06 <ski> er
13:43:25 <ski> @djinn (a0 -> Cont2 o0 p0 a0) -> (b0 -> Cont2 o1 p1 a1) -> ((a0,a1) -> Cont2 (o0,o1) (p0,p1) (b0,b1))
13:43:25 <lambdabot> -- f cannot be realized.
13:43:28 <ski> that one
13:43:46 <ski> <ski> @djinn-add data Cont2 o p a = C2 ((a -> p) -> o)
13:44:07 <danharaj> :t cycle
13:44:08 <lambdabot> forall a. [a] -> [a]
13:44:48 <copumpkin> > fix cycle
13:44:51 <lambdabot>   mueval-core: Time limit exceeded
13:45:09 <ezyang> "I'm not a bike repair shop!"
13:45:26 <copumpkin> > fix ((1:) . cycle)
13:45:27 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:45:52 <xplat> > fix reverse
13:45:56 <lambdabot>   mueval-core: Time limit exceeded
13:45:58 <danharaj> > cycle [1]
13:45:59 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:46:16 <xplat> oh, right, ghc only catches those in compiled code
13:48:22 <xplat> i wonder what 'fix car' would do
13:48:38 <koninkje> > fix head
13:48:40 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
13:48:50 <dylukes> > let car = "Audi A8" in fix car
13:48:51 <lambdabot>   Couldn't match expected type `a -> a'
13:48:51 <lambdabot>         against inferred type `[GHC.T...
13:48:56 <mauke> fix error
13:49:00 <xplat> wrong cars
13:49:03 <koninkje> > fix cdr
13:49:04 <lambdabot>   Not in scope: `cdr'
13:49:12 <xplat> > fix tail
13:49:15 <osfameron> woah!  parsec is easy to use
13:49:15 <lambdabot>   mueval-core: Time limit exceeded
13:49:29 <osfameron> (I'm not saying I understand how it works... but *using* it is very very nice)
13:49:43 <xplat> heh, i have the opposite problem
13:49:58 <osfameron> xplat: you understand it, but can't use it? ;-)
13:50:35 <dylukes> > fix . car [0..]
13:50:37 <lambdabot>   Not in scope: `car'
13:51:03 <dylukes> > let car (x:_) = x in fix . car [0..]
13:51:04 <lambdabot>   No instance for (GHC.Show.Show (f a))
13:51:05 <lambdabot>    arising from a use of `M8929822480...
13:51:08 <dylukes> .__.
13:51:54 <stephan> are there any examples on how to use Network.Curl? and also how to perform http PUT? (e.g. for a accessing a web service)
13:51:59 <roconnor> twanvl_: Too bad I can't make it to your talk in Nijmegen
13:53:01 <aristid> stephan: other packages are much easier to use than Network.Curl. for example HTTP or http-enumerator
13:53:38 <osfameron> hmmm.  Text.ParserCombinators.Parsec clashes badly with Control.Applicative...
13:53:42 <twanvl_> roconnor: it was your multiplate paper that inspired me to give that talk
13:53:44 <osfameron> I thought they were supposed to be easy to use together?
13:53:50 <osfameron> I'm probably Doing It Rong
13:54:06 <c_wraith> osfameron: sounds like.  How do they "clash"?
13:54:09 <roconnor> twanvl_: my paper wouldn't exist if it weren't for your blogging
13:54:29 <osfameron> c_wraith: if I import both, then it complains that 'many' and '<|>' are ambiguous
13:54:29 <twanvl_> yay, recursion!
13:54:52 <roconnor> twanvl_: are you a masters or phd student yet?
13:55:06 <twanvl_> I am a phd student now
13:55:12 <roconnor> horray
13:55:13 <roconnor> where?
13:55:14 <twanvl_> but not working on anything haskell related
13:55:22 <osfameron> aha!  googling (and getting to the RWH site) I see I have to do: import Text.ParserCombinators.Parsec hiding (many, optional, (<|>))
13:55:33 <twanvl_> in Nijmegen
13:55:38 <roconnor> oh wow
13:55:48 <roconnor> which group
13:56:08 <twanvl_> in the machine learning group
13:56:31 <c_wraith> osfameron: Hmm.  Ugly, but I know why it does that.  import Control.Applicative hiding ((<|>), many)
13:56:49 <roconnor> boo, you should be in the foundations group :P
13:57:01 <osfameron> c_wraith: aha, the RWH thing I found ^^ suggested to hide them from T.PC.P instead
13:59:20 <stephan> aristid: thanks! I will look into http-enumerator or HTTP
14:05:55 * hackagebot hakyll 3.1.2.2 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-3.1.2.2 (JasperVanDerJeugt)
14:08:02 <Twey> Ooh, new Hakyll.
14:08:28 <temoto> Looking for a beautiful way to get first elements of list whose sum equals to N.
14:08:29 <temoto> (and [] if there is no such sum)
14:08:29 <temoto> (and list is sorted)
14:08:45 <jaspervdj> Twey: Just a small bugfix :-)
14:09:08 <Twey> What was the bug?
14:10:09 <jaspervdj> Twey:
14:10:19 <jaspervdj> Twey: https://groups.google.com/d/topic/hakyll/357iZ7u8ODU/discussion
14:10:50 <jaspervdj> copy/paste fail -- luckily irssi prevented me from pasting 20 lines
14:11:01 <Twey> Heh
14:11:25 <Twey> Ah, that doesn't apply to me
14:11:29 * Twey doesn't bother upgrading.
14:12:12 * osfameron writes something to parse and simplify mockingbird combinators: https://gist.github.com/975406
14:12:28 <osfameron> (it doesn't do transformations or anything useful yet, of course)
14:12:40 <osfameron> but Parsec++ again
14:13:03 <danharaj> DevIL is LGPL :[
14:13:10 <danharaj> great.
14:19:29 <ezyang> Is there a way to make GHC's GC hyperactive?
14:19:49 <pastorn> ezyang: isn't there a function runGC :: IO ()
14:19:54 <pastorn> @hoogle gc
14:19:54 <lambdabot> Data.Typeable gcast :: (Typeable a, Typeable b) => c a -> Maybe (c b)
14:19:54 <lambdabot> Data.Typeable gcast1 :: (Typeable1 t, Typeable1 t') => c (t a) -> Maybe (c (t' a))
14:19:54 <lambdabot> Data.Typeable gcast2 :: (Typeable2 t, Typeable2 t') => c (t a b) -> Maybe (c (t' a b))
14:20:00 <pastorn> @hoogle IO ()
14:20:00 <lambdabot> Network.BSD endHostEntry :: IO ()
14:20:01 <lambdabot> Network.BSD endNetworkEntry :: IO ()
14:20:01 <lambdabot> Network.BSD endProtocolEntry :: IO ()
14:20:03 <pastorn> bah
14:20:15 <ezyang> Oh, I guess that works.
14:20:24 <pastorn> http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-Mem.html#v:performGC
14:24:51 <tg_> oh my god.
14:25:00 <tg_> Some of the tidbits in LYAH are fantastic
14:25:09 <tg_> In the second line, Avril tells us that she doesn't like our current romantic partner.
14:25:12 <tg_> lol
14:27:39 <ezyang> Next question; what do you think is the best way to make a Haskell script busy wait in such a way that: 1. doesn't allocate memory (or at least uses a small constant amount of space), 2. still has heap profiles triggered.
14:27:44 <ezyang> threadDelay seems to fail (2)
14:29:15 <osfameron> aha... <* eof   doesn't DTRT
14:29:23 <osfameron> it just silently ignores the eof
14:30:56 <mauke> osfameron: that surprises me
14:31:23 <ezyang> Hmm, summing a big list seems to be the ticket.
14:32:40 <hpc> ezyang: be careful how you sum it though ;)
14:34:30 <osfameron> mauke: oh?  lemme double check then
14:38:28 <osfameron> mauke: quite right, sorry.  I'd got my precedence wrong
14:44:56 <ezyang> Is there a way to access current memory residency from GHC?
14:46:44 <ClaudiusMaximus> ezyang: what are you up to? i came up with this which seems to work to some degree with -threaded : main = forkIO (forever performGC) >> threadDelay 100000000
14:47:28 <monochrom> eh? shouldn't you be including the delay in the parentheses?
14:47:59 <ClaudiusMaximus> monochrom: ezyang wanted hyperactive GC as far as i understood it?
14:48:10 <ezyang> ClaudiusMaximus: That won't show up on the heap profile, unfortunately :-(
14:48:26 <ezyang> Oh wait, you're talking about repeatedly performGC'ing
14:48:45 <ezyang> Actually, the GC runs enough for my needs, it turns out. I was just getting confused by the fact that big memory means slow runtime, due to longer gc runs.
14:48:47 <ClaudiusMaximus> ezyang: well, with that program i get 5007 heap samples over 1m40s or so
14:48:54 <ezyang> Oooh
14:49:03 <ezyang> I bet I could approximate heap size by checking how long performGC takes.
14:49:17 <ClaudiusMaximus> with  +RTS -C -hy -i0.02 -N
14:49:34 <ClaudiusMaximus> that sounds almost as dirty as reading from /proc/self or whatever it is
14:50:45 <stulli> Why can't i overload the read function in Read? It worked with Show though... http://hpaste.org/46736/overriding_read
14:50:58 <ezyang> Here's what I'm working on, btw: http://hpaste.org/46737/memory_pressure
14:51:36 <ezyang> I need to adjust how much work the busy wait does, because it's super fast when there's no mem and super slow when there is lots of mem.
14:52:18 <mauke> stulli: because read is not in Read
14:54:17 <stulli> mauke: huh, you are right. so i need to overload readsPrec?
14:54:31 <mauke> yeah
14:54:52 <stulli> thanks, i didn't expect that
14:55:20 <monochrom> when implementing a simple Read instance, you may ignore the Int parameter of readsPrec
14:58:10 <temoto> Is permutations a proper way to find all subsequences of [Integer] whose sum equals to some number?
14:58:36 <temoto> actually only first such subsequence is required
14:58:47 <ezyang> Ah, I can't use /self/proc because GHC doesn't free memory back to the OS immediately.
14:59:05 <monochrom> even combinations may be too slow, nevermind permutations
14:59:36 <ddarius> monochrom: The goal was propriety, not performance.
15:00:06 <monochrom> permuations is still improper because of irrelevant redundancies
15:00:30 <aristid> nub may help
15:00:44 <temoto> What if performance is the goal?
15:00:53 <temoto> ?nub
15:00:53 <lambdabot> Maybe you meant: bug run
15:02:35 <dented42_> I've been told that GHC threads are very lightweight. what is the practical limit on the number of threads GHC can handle? tens, hundreds, thousands, millions?
15:03:13 <danharaj> I think its towards the millions.
15:03:16 <danharaj> I don't know though.
15:03:30 <danharaj> or was it thousands and sparks were millions?
15:03:35 <danharaj> someone else should answer >___>
15:04:39 <shachaf> danharaj: Aren't sparks for parallelizing things across cores etc.?
15:06:10 <temoto> dented42_, on memory consumption, each thread takes ~260 bytes, so 1GB can fit 3-4 millions.
15:06:30 <Twey> dented42_: Definitely several hundred thousand.
15:06:52 <dented42_> ok, is there much of a slowdown as the number of threads increases?
15:07:21 <Twey> I believe not, but I've never actually used that many threads, so I wouldn't know for sure
15:07:21 <dented42_> I mean, obviously more threads means less time for each individual thread.
15:07:43 <Twey> Yes, but that's not necessarily an issue
15:07:50 <Twey> If they're sliced smartly
15:08:13 <temoto> dented42_, on CPU cost (scheduling overhead), that's low enough, primarily because they're userland threads.
15:08:53 <dented42_> so would it be acceptable for a server program of some sort to spawn a thread for each incoming connection?
15:08:56 <Twey> If you have a hundred threads not doing anything and two active threads, the only difference between that and just the two threads should be the scheduling overhead, which I believe is pretty small
15:09:00 <Twey> Yes, definitely
15:09:15 <Twey> I believe Snap does that, and Snap is, well, snappy ☺
15:09:15 <dented42_> ok, good.
15:09:27 <dented42_> thanks so much ^_^
15:10:00 <temoto> If your hundreds of thousand of threads sleep waiting for something to happen, then "more -> slower" doesn't really apply.
15:10:26 <temoto> Twey, what's Snap?
15:10:41 <Twey> Snap is a Web framework.  http://www.snapframework.com/
15:13:24 <Tinned_Tuna> Hi.
15:13:40 <Tinned_Tuna> So, as a learning exercise, I've been trying to write a parser for lambda expressions using Parsec
15:13:47 <Tinned_Tuna> but I've gotten myself a little unstuck
15:13:50 <Tinned_Tuna> http://hpaste.org/46738/lambda_calculus_parsec_strugg
15:14:02 <Tinned_Tuna> is my code, and as you can see, the error relates to my type declaration.
15:14:25 <ion> oceanspray: Did you notice my message earlier?
15:15:45 <Twey> Tinned_Tuna: Types and type constructors are in different namespaces
15:15:55 <Twey> (type constructors are actually values)
15:16:23 <Twey> Tinned_Tuna: Haskell expects a type where you've put ‘Constant’, but you've given it the name of a type constructor; a type with that name doesn't exist in the type namespace
15:17:01 <ion> | Abstraction {- ← new data constructor name -} Constant Expr {- ← both are supposed to be types -}
15:17:52 <Tinned_Tuna> hence it could be "Abstraction (Constant String) Expr"
15:17:56 <monochrom> I would do Abstraction String Expr
15:17:58 <Tinned_Tuna> Or am I misunderstanding
15:18:14 * hackagebot happstack-hsp 6.1.0 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-6.1.0 (JeremyShaw)
15:19:03 <ion> Constant is in a completely different namespace than where Expr and String are.
15:19:32 <ion> You can not use it anywhere a type goes into.
15:19:39 <Tinned_Tuna> Ok :-(
15:19:56 <stepkut> dented42_: haskell threads are extremely lightweight. Forking a new thread for each incoming request is common practice.
15:20:02 <Tinned_Tuna> So, using monochrom's suggestion, I'd just modify my abstraction function?
15:20:08 <ion> You can use it as a function and as a part of a pattern, but not as a type.
15:20:58 <ion> constant :: Parser Expr
15:21:04 <ion>     var <- constant
15:21:08 <ion>     return (Abstraction var body)
15:21:23 <ion> To match that it should be: | Constant Expr Expr
15:21:41 <ion> The type of var is Expr
15:21:52 <felher> Hey folks: Why does 'map (1+) [1,2,3,4]' do the same as 'map (+1) [1,2,3,4]'? Does map know on which side to put the items of the list?
15:22:09 <ion> 1+4 is the same as 4+1
15:22:20 <stepkut> felher: it's because (+) is commutative.. try it with (-) instead..
15:22:29 <MHD0> I'm looking at parser library implementations, and Parsec 3's continuation approach seems to notch. How would an ST based parser fare?
15:23:06 <stepkut> (except, there is a funky rule about how (-1) is parsed)
15:23:08 <shachaf> stepkut: (-) is a rather unhelpful example here. :-)
15:23:11 <felher> ion, stepkut: yeah, but (1+) 3 works, while 3 (1+) doesnt. So why do both work in 'map'?
15:23:17 <stepkut> shachaf: yeah, I realized it as soon as I said it
15:23:49 <stepkut> felher: beacuse (+1) 3 and (1+) 3 both work
15:23:50 <ion> @src map
15:23:50 <lambdabot> map _ []     = []
15:23:50 <lambdabot> map f (x:xs) = f x : map f xs
15:24:07 <ion> f is (1+) or (+1), x is 3. See how f always goes before x?
15:25:57 <felher> stepkut, ion . Oh, sorry, i mixed ' 3 (+1) vs (+1) 3' and '(+1) 3 vs (1+) 3' up. :) thnx
15:27:40 <ddarius> > 3 (+1)
15:27:41 <lambdabot>   3
15:28:12 <ion> ;-)
15:28:18 <aristid> > 3 "ddarius"
15:28:19 <lambdabot>   3
15:28:55 <aristid> > (3 + id) 4
15:28:57 <lambdabot>   7
15:29:27 <ion> ((1+) + (+1)) 4
15:29:32 <ion> > ((1+) + (+1)) 4
15:29:32 <lambdabot>   10
15:29:39 <parcs> > sec^2 - 1 $ 1242353
15:29:40 <lambdabot>   Not in scope: `sec'
15:30:11 <Tinned_Tuna> > 3 (-1)
15:30:12 <lambdabot>   3
15:30:15 * hackagebot text-icu 0.6.3.4 - Bindings to the ICU library  http://hackage.haskell.org/package/text-icu-0.6.3.4 (BryanOSullivan)
15:30:16 <Tinned_Tuna> > (-1) 3
15:30:17 <lambdabot>   -1
15:32:12 <aristid> Tinned_Tuna: this will NOT work in your own ghc
15:35:34 <parcs> > deriv (sin^2 + cos^2) x
15:35:35 <lambdabot>   1 * cos x * sin x + sin x * (1 * cos x) + (1 * negate (sin x) * cos x + cos...
15:36:57 <aristid> > deriv sin x
15:36:59 <lambdabot>   1 * cos x
15:37:13 <aristid> > deriv (sin x) x
15:37:14 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif a
15:37:14 <lambdabot>                        ...
15:37:18 <aristid> :t deriv
15:37:20 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
15:37:26 <nihtml> > (-1) 2
15:37:27 <lambdabot>   -1
15:37:44 <ben> w/chogall?
15:37:44 <ben> Day changed to 17 Mai 2011
15:37:51 <ben> aw fuck, sorry
15:37:58 <parcs> > deriv (+1) x
15:37:58 <ben> wrong terminal type :<
15:37:59 <lambdabot>   1
15:38:04 <parcs> > deriv (fix (+1)) x
15:38:05 <lambdabot>   *Exception: stack overflow
15:38:35 <parcs> > deriv (fix 1) x
15:38:36 <lambdabot>   0
15:39:18 <tswett> > (sin^2) x
15:39:18 <lambdabot>   sin x * sin x
15:39:22 <tswett> Blasphemy.
15:39:31 <monochrom> haha
15:39:34 <Eelis> omg..
15:39:45 <nihtml> haha
15:39:51 <monochrom> > (sin^2) 5
15:39:51 <ion> What is the size of the stack, btw?
15:39:52 <lambdabot>   0.9195357645382262
15:39:53 <atoll> Hi, i was wondering if Nil had a tail and a head.
15:40:00 <atoll> :D nihtml
15:40:13 <tswett> atoll: the empty list?  If you try to take its tail or its head, you will get an error.
15:40:17 <monochrom> Nil doesn't have a tail or a head
15:40:22 <Eelis> > (sin^(-1)) x
15:40:23 <lambdabot>   *Exception: Negative exponent
15:40:27 <atoll> nihtml 1 atoll 0
15:40:42 <monochrom> (sin^2) (pi/4)
15:40:46 <monochrom> > (sin^2) (pi/4)
15:40:46 <tswett> @type (-1)
15:40:47 <lambdabot>   0.4999999999999999
15:40:47 <lambdabot> forall a. (Num a) => a
15:40:52 <tswett> > 1 2 3
15:40:52 <monochrom> nice
15:40:52 <lambdabot>   1
15:40:57 <MHD0> atoll: also remeber that  lists are monads
15:41:28 <tswett> The [] type constructor is a monad.
15:41:31 <tswett> To be precise.
15:41:42 <hpc> > do {1;2;3;4}5
15:41:43 <lambdabot>   <no location info>: parse error on input `5'
15:41:46 <hpc> > do {1;2;3;4} 5
15:41:47 <lambdabot>   <no location info>: parse error on input `5'
15:41:50 <atoll> Even if Nil has Nil as a tail is it not a list with a head and a tail ?
15:41:54 <hpc> > (do {1;2;3;4})5
15:41:55 <lambdabot>   4
15:42:10 <MHD0> tswett: Same thing, less precise terminology.
15:42:25 <monochrom> head and tail are for Cons, not for Nil
15:42:35 <MHD0> @info [Int]
15:42:35 <lambdabot> [Int]
15:42:40 <MHD0> @info []
15:42:40 <lambdabot> []
15:42:45 <MHD0> ?
15:42:50 <MHD0> :info []
15:42:50 <tswett> atoll: if Nil had Nil as a head and Nil as a tail, then it would be a list with a head and a tail.  But I think it's better for head [] and tail [] to be errors.
15:43:09 <tswett> @info \x -> x + 5
15:43:09 <lambdabot> \ x -> x + 5
15:43:24 <MHD0> lol, useless
15:43:24 <tswett> @info ap const 3 5
15:43:24 <lambdabot> ap const 3 5
15:43:28 <nihtml> @help info
15:43:28 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:43:44 <pikhq> atoll: Here is the actual notion of a "list" (note: given syntax not actually valid Haskell): data [a] = [] | a : [a]
15:43:50 <tswett> It's impossible to tell what lambdabot's typo-corrector is correcting it to.  It must forever remain a mystery.
15:43:58 <atoll> Sure, it's just that in my head, a list was something infinite which contain Nil as last recursive element.
15:44:15 <MHD0> atoll: it is
15:44:16 <nihtml> it is
15:44:20 <parcs> > deriv (undefined :: Num a => a) x -- not lazy enough?
15:44:21 <MHD0> but that's the point
15:44:21 <lambdabot>   *Exception: Prelude.undefined
15:44:31 <tswett> atoll: lists either are infinite or end in Nil at some point, but not both.
15:44:33 <hpc> @help @info
15:44:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:44:34 <MHD0> Nil is the last thing
15:44:43 <hpc> @info run
15:44:43 <lambdabot> run
15:44:49 <hpc> @info @run
15:44:49 <lambdabot>  Parse error at "@run" (column 1)
15:44:50 <tswett> @info (
15:44:50 <lambdabot> Unbalanced parentheses
15:44:54 <pikhq> atoll: And head (x:_) = x; tail (_:x) = x. As you can see, they are both undefined for [].
15:44:59 <hpc> @info []
15:44:59 <lambdabot> []
15:45:37 <tswett> So, what is a ByteString?  Is it an immutable array of bytes?
15:45:50 <MHD0> Actually, I have a funny idea. Say you have a haskell machine that reduces every expression in zero time.
15:46:08 <monochrom> yes
15:46:11 <Twey> Zero time?
15:46:13 <Twey> Neat
15:46:19 <Twey> Infinite computing power
15:46:28 <MHD0> What happens if, say you have list "digitsOfPi :: [Int]"
15:46:38 <MHD0> and then on that haskell machine say
15:46:46 <MHD0> "last digitsOfPi"
15:46:48 <MHD0> ...
15:46:49 <Twey> MHD0: What is 0 * infinity?
15:46:58 <tswett> MHD0: that expression cannot be reduced, so its behavior is undefined.
15:46:59 <MHD0> Twey: 0
15:47:13 <MHD0> Neat, I broke an infinitely fast compter.
15:47:24 <MHD0> OR
15:47:27 <pikhq> MHD0: Such a Haskell machine would, of necessity, have or *be* a halting oracle.
15:47:29 <monochrom> I only dare to imagine a zeno machine. the nth step takes 2^-n seconds
15:47:44 <tswett> MHD0: it gives an error message.  :P
15:47:50 <pikhq> MHD0: So, it would be quite trivial to make that expression evaluate to: error "Expression does not halt."
15:48:26 <MHD0> OR: what it's gonna do is cause the universe to split into 10 parraless where the expression evaluates to one of the ten digits.
15:48:33 <MHD0> paralells*
15:48:40 <tswett> Parallels.  :)
15:48:49 <MHD0> Gah
15:48:51 <MHD0> :P
15:48:56 <tswett> It will actually give -3.  :P
15:49:03 <pikhq> MHD0: But none of the above digits is the correct answer for last digitsOfPi.
15:49:10 <pikhq> The only correct result is _|_.
15:49:23 <MHD0> Yeah, but the other is more fun.
15:49:27 <MHD0> :P
15:49:41 <pikhq> Which, curiously, means even our finite machines compute the correct result. :)
15:50:13 <tswett> My computer would eventually run out of memory if it tried to compute the last digit of pi.
15:50:16 <tswett> Probably.
15:50:21 <pikhq> tswett: _|_
15:50:25 <MHD0> Alternately, for more infinite computing fun in haskell imagine the monad "NIO"
15:50:32 <tswett> pikhq: is Graham's number also _|_?
15:50:50 <tswett> Or, I should say.  If I try to calculate Graham's number but my computer runs out of memory, is that _|_?
15:50:52 <pikhq> tswett: No, that's your computer failing to imitate a Turing machine on this.
15:51:01 <MHD0> tswett: no, if you have nigh infinite memory you can compute it.
15:51:37 <hpc> pikhq: or failing to implement a full graph reduction
15:51:37 <MHD0> The NIO monad is kinda like IO but an instance of mplus
15:51:45 <MHD0> MonadPlus*
15:51:54 <hpc> you can express the idea of grahm's number as a thunk just fine ;)
15:51:57 <aninhumer> If you can compute in zero time there's no time for the memory to be filled in :P
15:52:24 <MHD0> And it is also an instance of MonadLogic
15:52:25 <pikhq> Also, I'm fairly certain each individual digit of pi can be computed independently of the others in O(1) time, so main = print <<= show <<= last digitsOfPi won't really run out of memory.
15:52:38 <pikhq> It'll just grind a long, long time.
15:52:49 <MHD0> @type =>>
15:52:49 <lambdabot> parse error on input `=>>'
15:52:52 <tswett> pikhq: in binary, yes.
15:52:55 <MHD0> @type (=>>)
15:52:56 <lambdabot> Not in scope: `=>>'
15:53:29 <tswett> Also, surely you can't calculate the Graham's number'th digit of pi in constant time.
15:53:35 <tswett> If you can, I invite you to tell me what it is.
15:53:51 <tswett> Surely calculating the nth digit takes O(log n) time.
15:53:51 <pikhq> I never said anything about constant space.
15:54:06 <MHD0> tswett: Sure, find me a computer with G(65) bytes of memory
15:54:09 <hpc> pikhq: O(memory) is always less than O(time)
15:54:18 <MHD0> where G(x) is the grahams sequence
15:54:20 <hpc> pikhq: because it takes O(memory) time to fill that memory
15:54:26 <MHD0> and G(64) is grahams number
15:54:38 <tswett> MHD0: log G_64 is almost exactly equal to G_64.
15:54:50 <MHD0> tswett: Yeah
15:55:02 <tswett> It's certainly closer to G_64 than to G_63.
15:55:05 <tswett> (In a sense.)
15:55:53 <SoleSoul> Hi. I tried to unregister all cabal packages. I tried to run  cabal list --installed | grep "*" | awk '{print $2}' | xargs ghc-pkg unregister      That doesn't work. I get command line syntax error. what did I do wrong? thanks!
15:56:43 <ion> * isn’t a valid regexp.
15:56:46 <mauke> oh wow
15:56:51 <pikhq> Anyways, I'm sorry, it's not constant time, as exponentiation isn't constant time.
15:56:55 <mauke> grep "*" actually runs here
15:57:18 <SoleSoul> ion: it doesn't serve the purpose of a regexp wildcard
15:57:23 <tswett> Ah, yes.  How fast is calculating a^b, anyway?
15:57:33 <SoleSoul> ion: it's just to get the lines with names
15:57:49 <tswett> O(b log a) or something?
15:57:53 <mauke> SoleSoul: grep '^\*'
15:58:10 <SoleSoul> mauke: I don't want a wildcard
15:58:18 <SoleSoul> mauke: I want a plain chat
15:58:18 <hpc> SoleSoul: exactly
15:58:21 <mauke> yes, that's why I used \
15:58:23 <SoleSoul> char
15:58:36 <hpc> SoleSoul: * is a quantifier, \* is escaped
15:58:40 <dafis> tswett:  if multiplications are (were) O(1), a^b would be O(log b) with repeated squaring
16:00:08 <SoleSoul> cabal list --installed | grep "*"    and    cabal list --installed | grep "\*"   gives exactly the same output. I just tried. This is not the problem :/
16:01:28 <mauke> SoleSoul: what's the error message?
16:02:15 <SoleSoul> mauke: sadly it's "ghc-pkg: command-line syntax error "
16:02:18 <dafis> tswett:  but multiplications of two d-digit numbers are O(d^(1+x)), with x > 0 depending on the algorithm, I don't remember what the current best is; At the end you're multiplying two numbers with about (b/2)*log a digits, so it's at least O((b*log a)^(1+x))
16:02:38 <Lemmih> SoleSoul: Did you try 'xargs -n 1'?
16:02:43 <hpc> SoleSoul: does the output make sense when you stop at awk?
16:02:57 <tswett> dafis: I think multiplication using the fast Fourier transform makes it O(d log d).
16:03:00 <SoleSoul> hpc: yes. Lemmih: no. I'll try
16:04:05 <SoleSoul> Lemmih: works! thanks :)
16:05:42 <SoleSoul> Thanks to all others also :)
16:06:28 <dafis> tswett:  according to wikipedia, not quite, but close
16:06:57 <tg_> any reason why :set args would seem to have no effect in ghci?
16:06:57 <SoleSoul> btw, will removing ghc and deleting .config/cabal clean all traces of cabal packages?
16:07:04 <SoleSoul> (I use arch)
16:07:44 <tg_> :set args blah blah blah
16:07:49 <tg_> -> no arguments are set
16:08:33 <alpounet> SoleSoul, if it removes your ~/.ghc/ dir, then yes
16:08:48 <SoleSoul> I'll delete it then. Thank you
16:09:09 <alpounet> however
16:09:30 <alpounet> it'll be like you've never installed any library
16:09:30 <dafis> tg_:  works here; ghci> :set args "3"; ghci> main
16:09:52 <tg_> dafis: ah. "main" causes it, ":main" doesn't
16:10:06 <SoleSoul> it's ok. I prefer it like that. I will use only pacman (arch's package manager) from now on
16:10:12 <tg_> oh... :main runs with given arguments. *foreheadslap*
16:10:16 <SoleSoul> alpounet: that's what I want
16:10:26 <tg_> so main is calling the function main
16:10:34 <tg_> dafis: thanks :)
16:10:43 <dafis> tg_:  you're welcome
16:11:01 <SoleSoul> I did so much mess while trying to install yi and failed so I decided to reinstall everything haskell related
16:11:23 <SoleSoul> isn't there a static build? like you can put on diskonkey
16:11:43 <SoleSoul> of yi
16:16:32 <luite> which language or other pragma's might be unsafe to allow when running untrusted code?
16:17:34 <tswett> When in doubt, toss everything out.
16:18:42 <joe6> is there a hasakell function that can delete list from a list such as delete "junk" "junk abcd junk" = " abcd "
16:18:45 <dafis> I thought, when in doubt, castle
16:19:31 <mauke> > filter (`notElem` "junk") "junk abcd junk"
16:19:32 <lambdabot>   " abcd "
16:20:37 <dafis> joe6:  you could use the split package, concat (someSplitStrategy "junk" list)
16:20:53 <dafis> @hackage split
16:20:53 <lambdabot> http://hackage.haskell.org/package/split
16:21:05 <tswett> dafis: that only applies to imperative languages.
16:21:41 <taktoa> I'm working on a control theory project
16:21:46 <dafis> joe6:  concat (splitOn "junk" list) should do it
16:21:54 <joe6> dafis, thanks
16:22:02 <taktoa> it essentially involves tuning three different control algos with a genetic algorithm
16:22:20 <taktoa> then running the control algorithms on an inverted pendulum simulation
16:22:59 <taktoa> (the simulation uses the Runge-Kutta method of numerical integration on the Lagrangian mechanical equations for an idealized inverted pendulum
16:23:09 <taktoa> anyways, here's the git repo
16:23:10 <taktoa> https://github.com/taktoa/Control-Theory/blob/master/Debug/
16:23:34 <taktoa> I'm having a bit of a problem with my bang-bang controller code
16:23:47 <taktoa> (BangBangImp.hs)
16:24:18 <taktoa> when I run "runBangSim", it takes much longer than it should and then fails with a <<loop>> runtime error
16:24:42 <edwardk> ezyang: yes
16:24:47 <taktoa> if anyone could respond to this question expediently, it would be greatly appreciated
16:25:05 <edwardk> er woops, window was scrolled, question was an hour and a half ago =)
16:26:02 <taktoa> this is the relevant program code
16:26:03 <taktoa> https://github.com/taktoa/Control-Theory/blob/master/Debug/BangBangImp.hs
16:28:01 <dafis> taktoa:  you tyr to write to fitnessHandle after closing it, that should be a problem if you get there
16:28:07 <dafis> *try
16:28:46 <dafis> taktoa:  hPrint trackHandle bang on line 52, probably
16:28:58 <taktoa> yeah
16:29:01 <taktoa> just fixed it
16:29:10 <taktoa> will push to git when ready
16:29:20 <dafis> taktoa:  but that shouldn't give you a <<loop>>, I think
16:29:32 <taktoa> ok
16:30:37 <taktoa> still getting the <<loop>>
16:31:25 <dafis> taktoa:  line 29, let chromToBConfig (a:b:c:_) = BConfig a b c
16:31:40 <taktoa> what's wrong with is
16:31:49 <dafis> taktoa:  the other way round?
16:32:02 <taktoa> err
16:32:09 <taktoa> one sec
16:32:23 <dafis> taktoa:  or are you defining chromToBConfig there?
16:32:28 <taktoa> I'm defining it
16:33:07 <dafis> okay, but don't use a new 'let' on every line, please
16:33:16 <taktoa> ?
16:33:22 <taktoa> how do I prevent that?
16:33:36 <taktoa> "where"?
16:33:51 <monochrom> most "let"s can be replaced by spaces
16:33:56 <taktoa> ah
16:33:59 <taktoa> didn't know that
16:34:27 <monochrom> on a one-liner, it becomes:
16:34:41 <monochrom> > let { x=1; y=2; z=3; t=x } in z
16:34:42 <lambdabot>   3
16:35:16 <monochrom> in fact, don't be afraid of "forward" references either
16:35:39 <monochrom> > let { x=y; y=z; z=t; t=0:x } in take 10 t
16:35:40 <lambdabot>   [0,0,0,0,0,0,0,0,0,0]
16:36:26 <monochrom> same story with "where". one "where" can host a whole slew of bindings
16:36:36 <taktoa> just pushed
16:36:45 <taktoa> might want to refresh
16:37:19 <taktoa> fixed all the excessive let statements
16:37:38 <taktoa> ignore all the "putStrLn "<letter>"" things in runBangSim
16:40:06 <taktoa> I've traced the error
16:40:15 <taktoa> down to line 51
16:40:19 <dafis> taktoa:  and, what was it?
16:40:46 <taktoa> not sure
16:40:52 <taktoa> I just know it happens on line 51
16:41:20 <joe6> is there a splitOn for string? there is a splitOn on Text and I hate to use pack and unpack just to use that function?
16:41:23 <joe6> > splitOn
16:41:24 <lambdabot>   Not in scope: `splitOn'
16:42:18 <dafis> taktoa:  probably because line 51 is where the evaluation of disp and fitness is demanded
16:42:19 <taktoa> just pushed again
16:42:32 <mauke> joe6: Data.List.Split
16:43:23 <joe6> i am looking for something with the functionaltiy that Data.Text.splitOn has?
16:43:40 <joe6> > Data.Text.splitOn
16:43:41 <lambdabot>   Not in scope: `Data.Text.splitOn'
16:43:47 <joe6> @hoogle Data.Text.splitOn
16:43:48 <lambdabot> No results found
16:43:54 <joe6> @hoogle splitOn
16:43:54 <lambdabot> No results found
16:43:56 <exlevan> joe6: Data.List.Split.splitOn
16:44:18 <joe6> exlevan, ok, thanks. I could not find in hoogle.haskell.com. Thanks a lot.
16:45:07 <exlevan> joe6: it's in the 'split' package, you may need to install it
16:45:40 <joe6> exlevan, got it. Thanks a lot.
16:45:56 <joe6> mauke, sorry,  i thought you were just referring to the split function
16:47:59 <dafis> taktoa:  I suspect you hit a loop in bangSim, try printing out bang, disp and fitness to see whether things hang there
16:48:18 <dafis> (perhaps with fewer iterations)
16:48:21 <taktoa> I just did that
16:48:26 <taktoa> one second
16:49:01 <taktoa> just pushed out a new revision
16:49:19 <taktoa> the error is sourcing from the bangGenetic function
16:49:33 <taktoa> and I think it comes down to line 31 or 32
16:49:54 <taktoa> or maybe 36
16:50:50 <taktoa> err, I meant 29, 30, or 35
16:51:48 <dafis> taktoa:  30 is the most likely candidate
16:52:01 <taktoa> yeah
16:52:24 <taktoa> [[zz]] must be turkish or something
16:52:24 <dafis> which brings us back to bangFitness and then bangSim
16:53:03 <taktoa>  I mean Thai
16:53:13 <taktoa> yeah, bangFitness
16:53:15 <dafis> taktoa:  what are bEvaluate and update?
16:53:15 <SamB> @pl (\k t -> chr $ a + flip mod 26 (ord k + ord t -2*a))
16:53:15 <lambdabot> ((chr . (a +) . flip mod 26) .) . flip flip (2 * a) . ((-) .) . (. ord) . (+) . ord
16:53:33 <taktoa> they're in other files
16:53:36 <taktoa> but
16:53:41 <SoleSoul_> Can a haskell program be compiled statically? I mean, portable, to take with me in my diskonkey. for example, yi. is it possible?
16:53:44 <taktoa> update is the simulation updater
16:54:08 <dafis> taktoa:  are they candidates for the cause of the <<loop>>?
16:54:09 <taktoa> and bEvaluate evaluates the input to the bang-bang controller and gives the requisite output
16:54:14 <taktoa> maybe
16:54:19 <taktoa> I'm not sure
16:54:30 <dafis> taktoa:  which files?
16:54:37 <taktoa> BangBang.hs
16:54:40 <taktoa> and Simulation.hs
16:54:52 <taktoa> https://github.com/taktoa/Control-Theory/blob/master/Debug/BangBang.hs
16:54:57 <taktoa> https://github.com/taktoa/Control-Theory/blob/master/Debug/Simulation.hs
16:55:40 <dafis> taktoa:  bEvaluate is kosher
16:56:09 <taktoa> sounds good
16:56:31 <taktoa> I know update is kosher
16:56:45 <dafis> update on the other hand may well contain a loop
16:56:46 <taktoa> b/c I use it in other circumstances and it doesn't go into a <<loop>>
16:57:00 <dafis> ah, okay
16:57:25 <taktoa> though the variables do seem to go asymptotic after a certain period of time
16:57:31 <monochrom> SoleSoul_: as much as any c program
16:57:37 <ion> crawl
16:57:43 <ion> whoops
16:58:34 <dafis> taktoa:  what's theta?
16:58:48 <taktoa> it's the angle of the inverted pendulum from vertical
16:59:00 <taktoa> or it's the accessor function for SState for that variable
16:59:14 <taktoa> or it's any number of random local variables
16:59:32 <dafis> taktoa:  I mean, is it a complicated function or just a projection, could that cause a <<loop>>?
16:59:43 <taktoa> nothing complicated
16:59:58 <taktoa> just an accessor function
17:00:00 <dafis> and average is sum/length?
17:00:04 <taktoa> yeah
17:00:33 <dafis> so we're back at square one :(
17:00:59 <taktoa> when I profile it average takes up a surprisingly large amt of cpu (about 1%)
17:01:08 <taktoa> but that's nbd
17:01:28 <taktoa> probably due to the large number of iterations
17:04:09 <taktoa> how does seq work?
17:04:12 <dafis> taktoa:  where's runGen defined?
17:04:25 <taktoa> if I could get fitness to be strictly evaluated in bangGenetic
17:04:35 <taktoa> I could determine where the error is
17:04:42 <dafis> taktoa:  seq evaluates its first argument to weak head normal form when the second argument is demanded
17:04:50 <taktoa> runGen is in Genetic.hs
17:08:33 <joe6> i have this: http://pastebin.com/f0VKDPVc , curious why I should not be doing this instead : (read " 0xaf\n ") ::Int
17:08:36 <taktoa> dafis: got anything?
17:08:52 <dafis> taktoa:  not yet
17:09:06 <joe6> any suggestions, please?
17:15:59 <dafis> taktoa:  No, sorry, I don't see where the loop originates, try nailing it with a smaller problem and lots of debug output
17:16:20 <taktoa> dafis: will do...
17:16:32 <dafis> good luck
17:16:48 <dafis> and let me know what it was if you find out
17:18:02 <taktoa> dafis: just one question. Is there any way I can get line 29 to be evaluated strictly ie using seq or $!
17:18:30 <taktoa> nevermind
17:18:41 <taktoa> just realized that line 29 defines a function
17:18:45 <taktoa> *facepalm*
17:25:01 <taktoa> dafis: found something interesting
17:25:09 <taktoa> if I go into ghci
17:25:14 <dafis> taktoa:  what?
17:25:28 <taktoa> and manually type in lines 38 through 41
17:25:39 <taktoa> line 41 takes a while to load
17:25:41 <taktoa> but then
17:25:55 <taktoa> when I type "bcfg" to see what I got out of line 41
17:26:00 <taktoa> it also takes time to load
17:26:06 <taktoa> which makes little sense
17:26:18 <taktoa> if it was evaluated when I typed in line 41
17:26:26 <taktoa> why would it be re-evaluated?
17:26:50 <taktoa> unless it's taking a long time for some other reason
17:27:09 <taktoa> as of now "bcfg" still hasn't evaled
17:28:06 <dafis> taktoa:  bcfg <- bangGenetic scfg doesn't necessarily evaluate bcfg
17:28:18 <taktoa> then why does it take a while?
17:30:00 <dafis> taktoa:  it needs to evaluate bcfg far enough to have an expression it can bind to the name, that may still be a long way from something printable
17:30:13 <taktoa> ah
17:30:50 <dafis> taktoa:  so I think you'd need to look at runGen
17:31:21 <dafis> evrything up to that looks trivial
17:31:37 <taktoa> hrm
17:31:40 <dafis> (in terms of computation time)
17:31:43 <taktoa> runGen works though
17:31:48 <taktoa> look at Tests.hs
17:31:53 <taktoa> geneticTest
17:32:00 <taktoa> it runs pretty quickly
17:32:03 <taktoa> 10k iterations
17:32:16 <taktoa> 1.2 seconds
17:35:13 <dafis> taktoa:  but with only one gene per chromosome, you have twenty for the real thing
17:35:39 <taktoa> hrm...
17:35:45 <taktoa> not sure
17:36:00 * taktoa downs a Red Bull
17:36:09 <taktoa> It's going to be a loooong night
17:36:17 <dafis> taktoa:  that may make a huge difference or not, I don't know yet
17:36:24 <taktoa> given that this is due tomorrow
17:38:07 <dafis> taktoa:  you might be bitten by the laziness of generating the random lists
17:38:35 <taktoa> any way I can strictly eval them?
17:39:11 <dafis> taktoa:  in Utils.hs, import Control.Exception and "evaluate (sum list)" before returning it
17:39:29 <dafis> oops,
17:39:44 <dafis> evaluate (return $! sum list)
17:39:50 <taktoa> where's that
17:39:54 <taktoa> (line #
17:41:15 <taktoa> dafis: which line?
17:41:22 <dafis> taktoa:  let { randInfList = randomRs range stdGen; resultList = take size randInfList; }; evaluate ...
17:41:34 <dafis> lines 32, 38
17:41:43 <dafis> Utils.hs
17:41:52 <taktoa> thanks
17:41:55 <taktoa> one sec
17:42:34 <taktoa> why are we summing the list though?
17:43:05 <dafis> taktoa:  to evaluate the elements
17:43:24 <taktoa> I get it- kind of- not really
17:43:44 <taktoa> the output of randomIntList is an IO [Int]
17:43:54 <taktoa> if you sum it, it will no longer be correct
17:44:04 <dafis> taktoa:  although, since you create a new StdGen for each list, that should not be such a big problem here
17:44:29 <dafis> taktoa:  why would it no longer be correct?
17:44:31 <taktoa> so I shouldn't implement the evaluate (sum list) thing?
17:44:43 <taktoa> sum [Int] = Int
17:44:46 <taktoa> right?
17:44:58 <dafis> taktoa:  evaluate the sum, return the list
17:45:13 <taktoa> ah
17:45:15 <taktoa> I see
17:45:39 <taktoa> b/c if you evaluate the sum, the list is necessarily evaluated
17:46:13 <dafis> taktoa:  right, and if you do it at creation, it's not intertwined with other calculations
17:46:28 <dafis> I don't know whether that's important here, though
17:47:02 <taktoa> it compiles!
17:47:13 <taktoa> let's see if it runs
17:47:46 <taktoa> :-/
17:47:55 <taktoa> still get the <<loop>>
17:47:56 <taktoa> BUT
17:48:01 <taktoa> it executes very quickly
17:48:11 <taktoa> almost instantly
17:48:47 <dafis> taktoa:  in each IO thingy, a `putStrLn "I'm here"'
17:48:53 <taktoa> just pushed
17:49:07 <taktoa> define each IO thingy?
17:49:35 <dafis> taktoa:  each function with return type IO something
17:49:42 <taktoa> ah
17:49:51 <taktoa> that's a lot of functions
17:49:58 <taktoa> which module specifically
17:50:08 <dafis> taktoa:  printf-debugging, the best debugging method man has ever invented
17:50:20 <taktoa> yeah, I was doing it earlier
17:50:24 <dafis> taktoa:  Genetic
17:50:27 <taktoa> ok
17:51:36 <gwern> print debugging is great when your mental model of the program and would could go wrong is that detailed
17:51:51 <taktoa> to me, the main problem
17:52:02 <taktoa> lies somewhere in the following functions
17:52:33 <taktoa> runGen, runGen', generation, mutation, fillInPop, makeInitChroms, makeInitChroms'
17:52:58 <taktoa> I've never had problems with crossover or selection
17:54:06 <taktoa> dafis: well I can tell you one thing
17:54:14 <taktoa> dafis: It is executing
17:54:23 <taktoa> your addition made it wicked faste
17:54:25 <taktoa> *fast
17:55:43 <dafis> taktoa:  and, do we already know what printed last before the <<loop>>?
17:55:44 <taktoa> dafis: I've narrowed the location of the error to spop on line 118
17:55:50 <taktoa> yes
17:56:07 <taktoa> err 117
17:56:22 <taktoa> it happens on the last line of runGen
17:56:33 <dafis> let spop = (ksort snd (chromsToPop chroms cfg))
17:57:08 <dafis> taktoa:  by the way, if you want only the head of a sorted list, minimumBy is faster
17:58:07 <dafis> taktoa:  how long is chroms, roughly?
17:58:34 <taktoa> umm
17:58:38 <taktoa> where exactly
17:58:46 <taktoa> there are many vars named "chroms
17:58:54 <dafis> propenultimate line of runGen
17:59:09 <dafis> chroms <- runGen' ...
18:00:06 <taktoa> umm
18:00:13 <taktoa> chroms is 16 or so
18:00:20 <taktoa> it's the size of popSize
18:00:22 <taktoa> of cfg
18:00:26 <taktoa> which is smallish
18:00:31 <taktoa> less than 50, certainly
18:01:11 <dafis> okay, so it's not the sort that's the problem
18:02:13 <taktoa> btw propenultimate is a neat word - I knew about penultimate (although I recently used it and received blank stares)
18:03:05 <dafis> taktoa:  before the let spop ..., print (map sum chroms)
18:03:43 <taktoa> interesting
18:04:12 <taktoa> the <<loop>> happens after the print
18:04:31 <taktoa> which, by the way, results in [236.996]
18:04:42 <eyebloom> Is (=>) a keyword?
18:05:07 <taktoa> eyebloom: not really
18:05:14 <dafis> eyebloom:  reserved symbol, so yes, except terminology
18:05:31 <eyebloom> Can you explain it briefly?
18:06:01 <porco> @help
18:06:01 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:06:04 <taktoa> it separates a polymorphic type variable definition from a type definition
18:06:12 <dafis> eyebloom:  you can't use "=>" as an operator symbol (but it's a symbol, not a word, so...)
18:06:24 <shachaf> @ty (+) :: (=>) (Num a) (a -> a -> a) -- Hmm.
18:06:25 <lambdabot> parse error on input `=>'
18:06:27 <shachaf> Bah.
18:06:52 <dafis> shachaf:  neat idea, prefix (=>)
18:07:00 <eyebloom> I see. It's not listed here: http://haskell.org/haskellwiki/Keywords#-.3E
18:07:09 <eyebloom> Even though many other operators are.
18:07:32 <eyebloom> Symbols, I mean.
18:07:39 <taktoa> dafis: so do you think the problem isn't in Genetic?
18:07:59 <taktoa> b/c it prints out map sum chroms just fine
18:08:08 <taktoa> and the loop happens afterwards
18:08:09 <dafis> taktoa:  so, chroms is evaluated, then let's see whether fst (head spop) comes before the <<loop>>
18:08:15 <taktoa> and it can't be the sort
18:08:16 <shachaf> eyebloom: Feel free to edit, as it says at the top of the page. :-)
18:09:05 <dafis> taktoa:  not the sort, but it could be the fitnessFunction that the sort requires
18:09:19 <taktoa> true...
18:09:41 <taktoa> but doesn't it evaluate the fitnessfunction many many times when it runs runGen'?
18:10:02 <taktoa> why would it fail then and not before?
18:11:02 <dafis> taktoa:  I haven't followed the code to that level, where would it execute the fitness function before?
18:11:34 <taktoa> at the end of generation
18:11:41 <taktoa> err
18:11:58 <taktoa> sorry
18:12:00 <taktoa> one sec
18:12:07 <taktoa> selection
18:12:23 <eyebloom> I don't think I would make good wiki contributions yet. Give me a few months.
18:12:33 <taktoa> in generation, it uses selection
18:12:40 <taktoa> which contains chromsToPop
18:12:48 <taktoa> which runs the fitness function
18:13:06 <taktoa> dafis: do you see now?
18:13:39 <dafis> taktoa:  right, so that is extremely unlikely to be the problem then
18:13:48 <dafis> back to BangBangImp
18:14:25 <eyebloom> Sorry to belabor this: If => is just syntactic sugar, what is the substitution?
18:14:27 <taktoa> so we know the problem is somewhere in bangGenetic
18:14:43 <taktoa> I don't think => is syntactic sugar
18:15:09 <dafis> taktoa:  take out the old print statements, and insert new ones in BangBangImp, sorry
18:15:13 <taktoa> AFAIK it's a language construct; a part of the type system
18:15:31 <taktoa> dafis: will do, one sec and I'll push to github
18:16:36 <taktoa> dafis: refresh
18:17:40 <taktoa> there should be a Google Docs for code
18:17:50 <taktoa> so you could do real-time collaboration
18:18:42 <taktoa> ok, I put in putStrLn's in runBangSim
18:18:56 <taktoa> compiling...
18:19:12 <taktoa> interesting!
18:19:20 <dafis> taktoa:  ?
18:19:24 <taktoa> it fails on line 50
18:19:36 <dafis> huh?
18:19:42 <taktoa> "Irrefutable pattern failed for pattern fitnessFile : trackFile : _"
18:20:31 <taktoa> Line 51:13-42
18:20:32 <dafis> taktoa:  did you forget the args?
18:20:49 <desaiu> Does Haskell have an equivalent to Python's PEPs?
18:20:53 <taktoa> I didn't change it
18:20:55 <taktoa> at all
18:21:26 <taktoa> oh
18:21:32 <dafis> taktoa:  btw, I can't see any putStrLns, github hates me
18:21:33 <taktoa> yeah sorry I did forget the args
18:21:49 <taktoa> yeah, I haven't pushed out the putStrLn changes
18:21:51 <taktoa> lemme do that
18:22:20 <taktoa> should see them in t-9 seconds
18:22:32 <taktoa> now
18:23:27 <dafis> taktoa:  nope, nothing, github hates me
18:23:42 <taktoa> are you in BangBangImp
18:23:49 <dafis> yes
18:24:11 <taktoa> refresh
18:24:58 <taktoa> dafis: do you see the changes
18:25:11 <dafis> refresh, change page, latest commit I see is 3da45...
18:25:43 <taktoa> huh, I don't see the changes either
18:25:59 <dafis> aha, in history, I see later changesets
18:26:22 * dafis is glad he's not the only one github hates
18:27:02 <dafis> taktoa:  now I see them
18:27:16 <dafis> a to j
18:27:20 <taktoa> ok
18:27:40 <taktoa> I had to do "git push origin master"
18:28:47 <taktoa> ok so the look happens at f
18:28:51 <taktoa> between f and g
18:28:52 <dafis> taktoa:  but those won't help much, the let bindings are lazy, so the first possible point of failure is between f and g
18:28:59 <taktoa> yea
18:29:05 <taktoa> and that's where it happens
18:29:15 <taktoa> I'm going to separate them out
18:29:24 <dafis> taktoa:  print bang, then print disp, then fitness
18:30:08 <taktoa> yup, implementing now
18:31:04 <Boney> 9
18:31:39 <taktoa> refresh github
18:32:04 <taktoa> ok, it happens after d
18:32:13 <dafis> taktoa:  btw, I just noticed, fitness is the same as disp, or am I too sleep-deprived?
18:32:25 <taktoa> ummm no
18:32:37 <taktoa> but if fitness is bad, then disp is bad
18:32:53 <taktoa> disp is just fitness * bIters
18:33:17 <taktoa> err
18:33:29 <taktoa> actually fitness might be equal to disp
18:33:59 <taktoa> the problem seems to arise when we try to print bcfg
18:34:18 <taktoa> even though we can evaluate fitness, disp, and bang, all of which source from bcfg
18:34:23 <taktoa> this makes NO SENSE
18:34:28 <taktoa> no fcuking sense
18:36:29 <taktoa> dafis: what do you think is going on
18:36:38 <dafis> taktoa:  instance Show where show = show
18:37:06 <taktoa> OH
18:37:13 <taktoa> *facepalm*
18:37:21 <taktoa> idiot idiot idiot
18:37:27 <dafis> taktoa:  replace that with deriving Show, and you're home
18:37:46 <Twey> Ooh, someone's doing the Idiot Dance.
18:38:12 <blackdog> Twey: next come the promises never to be so stupid again.
18:38:52 <dafis> wow, that was a hunt for red herrings
18:39:23 <taktoa> yup
18:39:40 <taktoa> though, it was very helpful
18:40:02 <dafis> taktoa:  at least, you should be able to get an hour or two of sleep
18:40:10 <taktoa> making the randomness code strict made is WAY way way faster
18:40:15 <dafis> now it's solved
18:40:40 <taktoa> heh, still need to do a paper on it + a presentation + I need to hammer out problems in Neural and PID
18:40:55 <taktoa> and I need to make a script that collects all the data
18:41:15 <dafis> taktoa:  doesn't sound nice
18:41:17 <taktoa> well, I already did that last part
18:41:22 <taktoa> but still
18:42:28 <dafis> taktoa:  anyway, I'll try to get a few hours of sleep now, bye
18:53:22 <taktoa> does anyone here have experience with lagrangian mechanics or the runge-kutta method of numerical integration?
18:54:02 <taktoa> I'm having trouble with my inverted pendulum simulation in that it consistently goes asymptotic after a short number of iterations
18:54:34 <dankna> ah yes, the numerical integration....  I failed to fix my 2D physical-simulation engine once because I couldn't understand that :D
18:54:45 <dankna> so yes, I have experience with it, but not the kind you were hoping
18:55:17 <taktoa> heh
19:42:15 <adnap> @tell conal i tried the program that i sent you on windows and it works
19:42:15 <lambdabot> Consider it noted.
19:42:41 <adnap> anyone in here have a mac?
19:44:55 <adnap> this is weird... it's so dead in here.
19:45:09 <dankna> I have a Mac
19:45:45 <adnap> okay, cool.  can you try running this haskell program from ghci? http://hpaste.org/46743/gluttwowindowdemo
19:46:19 <adnap> you need the glut and opengl libs as well as the .so files for glut and opengl
19:54:34 <dankna> yes, I'm famliar with how to run the stuff.  one sec.
19:57:59 <dankna> apparently OpenGLRaw is a prerequisite for the GLUT package, so it may take a moment while I get that installed
19:58:03 <applicative> adnap, I'm getting a nice spinning square
19:58:19 <adnap> applicative: are you getting two windows with a red and blue square?
19:59:00 <applicative> no, i just compiled and called the module, is there another incantation?  It's blue, and doing a semi random rotation.
19:59:25 <applicative> wait, found the red window,
19:59:33 <applicative> so looks good?
19:59:37 <adnap> applicative: it's supposed to launch two windows, one with a red square and the other with a blue square.  one square spins clockwise and the other counter-clockwise.
20:00:11 <applicative> the blue on responds to clicking on it, the other seems lifeless.
20:00:28 <adnap> applicative: can you invoke main from ghci?
20:00:39 <applicative> just a sec
20:00:39 <adnap> applicative: i need to know if it works from ghci
20:01:17 <adnap> applicative: the program doesn't respond to user input.
20:02:26 <adnap> applicative: can you private message me and let me know if it works from ghci?  i have to go unfortunately.
20:02:34 <adnap> applicative: thanks
20:02:35 <applicative> adnap, maybe it was an illusion!  it emphatically doesn't work from ghci.  there is the familar clearing of whitespace for the image, but no image. and it can't be killed from the desktop.
20:02:41 <dankna> I'll let you know how it works with @tell, adnap
20:03:16 <adnap> applicative: okay, that's expected.
20:03:40 <adnap> applicative: conal told me glut screws up on his mac and i just wanted to make sure.
20:04:09 <applicative> adnap, yeah I'm familiar with it.
20:04:50 <applicative> I haven't looked at the module, but I wonder why the red one isn't rotating.  Is there a problem with two windows maybe?
20:05:08 <applicative> there is always the possibility, indeed likelihood that my installationis out of kilter.
20:06:41 <applicative> adnap I think what it responds to it being moved into focus from behind the other one.
20:07:01 <applicative> that's what the clicking was doing.  (maybe)
20:07:23 <dankna> applicative: are you on a Mac?  did you run it from inside a .app bundle?
20:07:35 <dankna> because inability to focus things is expected behavior if you run a GUI program without a bundle
20:07:37 <adnap> okay, i don't have to go after all
20:08:32 <adnap> the rotation may start to act weird over time because i forgot to add to the angle modulo 2 * pi
20:08:38 <dankna> hmm
20:08:53 <dankna> I made a fake bundle and it still doesn't spin the red one, only the blue one spins
20:08:56 <adnap> the main thing i am concerned with is just whether both windows will launch on mac
20:09:02 <adnap> from ghci
20:09:29 <dankna> adnap: because of the issue with needing a bundle to properly do most GUI things, ghci probably can't do that
20:10:09 <adnap> dankna: what makes you think you need a bundle?
20:10:45 <dankna> adnap: because I've compiled a lot of cross-platform programs for the Mac and observed that, across languages, without a bundle you get misbehavior
20:10:50 <applicative> adnap, as for the fact that one rotates and the other not, maybe it's something about the code, if I reverse the lines introducing windo1 and window 2, I get the red one spinning
20:10:52 <dankna> it's been a while, they may have changed things, but.
20:11:26 <applicative> danka i'm on osx; it is not buried in a .app directory
20:11:52 <adnap> applicative: i guess glut is failing to redraw the second window
20:12:12 <applicative> it makes it but doesn't redraw, hm.
20:12:31 <adnap> but it doesn't make the windows from ghci, right?
20:12:57 <applicative> have you tried some of the known expedients people use with ghci on macs?  there is one that springs from the school of expression business.
20:13:14 <dankna> phew - it locked up my machine hard when I tried from ghc
20:13:16 <dankna> *ghci
20:13:20 <dankna> but I was able to kill it eventually
20:13:30 <adnap> okay
20:13:43 <adnap> sorry about that
20:13:49 <dankna> not your fault
20:14:26 <dankna> hmm
20:14:32 <dankna> I may be misunderstanding GLUT
20:14:35 <avenge> > a :× b
20:14:36 <lambdabot>   Not in scope: data constructor `:
20:14:45 <dankna> but doesn't postRedisplay prepend a display event to the queue?
20:14:49 <dankna> you're using it as if it acknowledges a display event
20:15:05 <applicative> apfelmus mentions it here, I think it didn't work, i'll see. http://stackoverflow.com/questions/5868916/haskell-graphics-library-that-works-in-ghci-on-macos-x
20:15:07 <dankna> your idleCallback, as I understand it, should be calling postRedisplay on both windows
20:15:15 <adnap> postRedisplay tells glut to call the display callback again
20:15:20 <dankna> okay
20:16:13 <adnap> if you remove it, one one frame will be drawn for each window
20:16:17 <adnap> *only one
20:16:46 <dankna> well, let me rewrite it the way I think it it's supposed to work and see what happens
20:17:43 <jeffz> adnap: it doesn't look like you're doing things in the correct order
20:18:05 <adnap> jeffz: can you be more specific?
20:18:15 <jeffz> I'm about to refer you to something.
20:18:19 <adnap> okay
20:18:31 <adnap> i've tested the program on windows and linux and it seems to work fine.
20:18:51 <jeffz> http://google.com/search?q="managing multiple windows with opengl and glut"
20:19:07 <jeffz> it says to register callbacks such as the display update one before creating the second window
20:19:44 <dankna> okay, I modified this and got both things spinning
20:19:54 <dankna> only when run compiled, though
20:19:55 <jeffz> when you create a window, you implicitely have some state of the "current window" iirc
20:20:01 <adnap> right
20:20:16 <jeffz> the powerpoint slide as the first hit on google illustrates
20:20:20 <adnap> the only difference i can see in this ppt is that it says to initialize the idle callback first
20:20:22 <dankna> http://hpaste.org/46746/fixed_halfway
20:20:28 <adnap> sorry
20:20:28 <adnap> last
20:20:29 <dankna> see
20:20:33 <dankna> this one won't pin the cpu to 100%
20:20:38 <dankna> because it only invokes the callback when idle
20:20:45 <dankna> instead of constantly
20:20:58 <dankna> also, it spins both windows
20:21:10 <dankna> there's obviously some platform difference in how GLUT dispatches update events
20:21:13 <adnap> okay
20:21:24 <adnap> yeah, that makes more sense
20:21:31 <adnap> but it still fails in ghci i assume
20:21:36 <dankna> yes
20:22:02 <adnap> that's mostly what i'm concerned with, although it's good to know that i was doing things incorrectly with glut
20:22:05 <dankna> I believe the .app bundle requirement has something to do with being unable to open a mach port with which to communicate with the window manager
20:22:51 <adnap> i will look into that.  if you find anything documenting that, let me know.
20:22:56 <dankna> I will
20:23:27 <adnap> also, let conal know since all i'm doing is trying to help him
20:24:07 <dankna> nodnod
20:24:50 <adnap> thanks for the help!
20:24:51 <adnap> :P)
20:24:53 <dankna> np
20:26:41 <applicative> hm, i get nothing if i open in ghci, and call main.  but runhaskell glutty.hs gives me the image, but with an evil mode of presence on the screen.
20:43:22 <NihilistDandy> http://www.xtranormal.com/watch/11762072/native-html5
20:45:04 <MatrixFrog> xtranormal is quite fun
20:45:20 <NihilistDandy> Indeed it is
20:45:32 <NihilistDandy> I quite enjoy this gar1t fellow
20:45:41 <MatrixFrog> the MS guy's voice kind of reminds me of c3po
20:45:57 <NihilistDandy> Hehe
20:46:40 <MatrixFrog> actually all the browsers seem to be falling away from point releases a little bit
20:46:49 <MatrixFrog> there's not gonna be a firefox 4.1 for example
21:09:41 <Axman6> :t let x x = x in x
21:09:42 <lambdabot> forall t. t -> t
21:10:55 <shachaf> :h let x x = x in x
21:10:58 <lambdabot> forall h. h -> h
21:12:03 <copumpkin> :x let x x = x in x
21:12:40 <lambdabot> forall x. x -> x
21:12:56 <copumpkin> that's right
21:13:20 <Eduard_Munteanu> What? :)
21:13:32 <Eduard_Munteanu> :p let x x = x in x
21:13:38 <Eduard_Munteanu> Hah.
21:14:09 <Eduard_Munteanu> Now how did you accomplish that?
21:14:27 <shachaf> Ask copumpkin.
21:14:50 <lambdabot> forall p. p -> p
21:14:58 <Eduard_Munteanu> Oh...
21:15:10 <Eduard_Munteanu> Hrm :)
21:15:28 <Eduard_Munteanu> Somebody is speaking through her.
21:16:14 <copumpkin> 'tis lord inglip
22:01:11 <dons> ...
22:02:59 <copumpkin> ...
22:03:15 <djahandarie> Nothing to see here folks
22:03:15 <shachaf> preflex: seen gropaga
22:03:15 <preflex>  gropaga was last seen on #haskell-blah 44 minutes and 52 seconds ago, saying: e
22:03:16 <Eduard_Munteanu> Totally ...
22:21:21 <notyy> dropWhile (=='1') "abc123"  ,I don't know why this doesn't work,anyone can help?
22:21:41 <Veinor> because dropWhile only drops 'from the start'
22:21:44 <ivanm> > dropWhile (=='1') "abc123"
22:21:45 <lambdabot>   "abc123"
22:21:50 <ivanm> sure looks like it works...
22:21:51 <Veinor> > dropWhile (== '1') "11111abc111"
22:21:51 <lambdabot>   "abc111"
22:21:59 <ivanm> > dropWhile (not . (=='1')) "abc123"
22:22:01 <lambdabot>   "123"
22:22:05 <ivanm> notyy: ^^
22:22:20 <notyy> .....
22:22:29 <Veinor> what are you trying to do?
22:22:35 <notyy> ivanm:thank you..
22:22:40 <ivanm> anyone here have any suggestions on how to draw _planar_ graphs?
22:22:42 <notyy> I want get 123
22:22:52 <Zao> @type isDigit
22:22:53 <lambdabot> Char -> Bool
22:22:57 <ivanm> graphviz keeps insisting on crossing edges, not drawing them in the order specified, etc. :@
22:23:40 <notyy> thank you
22:24:26 <MatrixFrog> notyy i think maybe you want: dropWhile (/= '1')
22:24:38 <MatrixFrog> or dropWhile (not . isDigit) or something
22:25:14 <notyy> MatrixFrog:yes,dropWhile (not . isDigit)  is what I needed
22:25:18 <ivanm> MatrixFrog: *facepalm* gah, didn't think about /=
22:26:05 <MatrixFrog> or you could write a dropUntil function
22:26:17 <MatrixFrog> (unless it already exists. maybe it does...)
22:43:54 <avenge> Hey, can someone try 3 lines of code for me?
22:44:12 <avenge> I'm getting weird internal exceptionsin ghci, and wonder if it's just my setup.
22:44:13 <MatrixFrog> avenge: someone other than ghci or lambdabot? :P
22:44:22 <avenge> http://hpaste.org/46748/ghci_702_unicode_problem
22:44:44 <avenge> Does lambdabot allow data declarations?
22:45:04 <ivanm> what's the error?
22:45:10 <ivanm> avenge: nope
22:45:23 <MatrixFrog> i don't think ghci does either, iirc
22:45:23 <avenge> The code loads fine into ghci, but when I enter x, it throws an exception while printing its value.
22:45:40 <avenge> hPutChar: invalid argument (Invalid or incomplete multibyte or wide character)
22:46:06 <avenge> Sorry, I mean when I put it in a file, I can load the file with ghci.  But it craps out in the middle of printing x.
22:46:19 <MatrixFrog> ok makes sense
22:46:23 <avenge> Obviously some weird unicode thing.  My LANG environment variable is en_US.utf8.
22:46:39 <avenge> But problem happens with LANG=C, too.
22:46:48 <avenge> Anyway, I have to go.  Was just bugging me.
22:47:06 <MatrixFrog> oh yeah, something to do with the "x" character probably
22:47:12 <MatrixFrog> the "times" character
22:47:18 <MatrixFrog> what text editor are you using
23:04:53 <adrake_> I am a bit confused by the paragraph in the Attoparsec documentation illustrating how 'string "foo" <|> string "bar"' will succeed in attoparsec but not parsec due to string being all-or-nothing
23:05:31 <adrake_> it seems from some simple tests that any parser becomes all or nothing in the context of <|>, thus that property of string is not particularly illustrated
23:06:19 <ivanm> I would randomly guess that for parsec you need to do 'try (string "foo") <|> string "bar" '
23:06:22 <adrake_> parseOnly ((word8 0x41 >> word8 0x42 >> takeWhile1 (\x -> True)) <|> Data.Attoparsec.takeByteString) (B.pack "ACDE") for example, returns "ACDE". I would expect, since there was at least 0x41 (A) consumed in the first alternative, that the second would return "CDE"
23:06:30 <ivanm> so that if the first parser fails it will move on
23:06:51 <adrake_> ivanm: I know how to make parsec do that, but the attoparsec documentation seems to imply that you need to do that as well
23:07:23 <ivanm> adrake_: sounds like attoparsec automatically un-reads partial parses
23:07:29 <ivanm> whereas parsec doesn't
23:07:34 <Jafet> You are describing the (non-intuitive) behaviour of parsec's (<|>).
23:07:55 <adrake_> Jafet: I am aware, but the attoparsec documentation appears to claim that attoparsec shares that behavior
23:08:10 <ivanm> adrake_: not for string though
23:08:24 <ivanm> in attoparsec, string will revert unsuccessful parses
23:08:37 <adrake_> right, but I am getting that behavior without using strings
23:08:41 <adrake_> see my large example above
23:09:05 <quicksilver> the point the attoparsec docs are making is that "string" in particular is special (in attoparsec)
23:09:26 <Saizan> adrake_: the documentation for string is simply saying "you don't need try around uses of string like you'd need in parsec"
23:09:34 <adrake_> Saizan: I see
23:09:42 <quicksilver> string is a magic hardcoded parser
23:09:45 <Jafet> Oh, I thought it was making (<|>) special
23:09:46 <quicksilver> it's not a sequence of char parsers
23:09:48 <adrake_> I understand that
23:10:04 <ivanm> Jafet: nope; you need polyparse for that :p
23:10:05 <adrake_> what I don't understand is why they illustrated that fact with the use of <|>
23:10:14 <ivanm> (though there <|> is called onFail)
23:10:20 <adrake_> since <|> rolls back the failed parses anyway
23:10:23 <Saizan> because try is only relevant wrt <|>
23:10:25 <quicksilver> adrake_: no, it doesn't.
23:10:28 <ivanm> adrake_: because that's the whole point?
23:10:40 <adrake_> quicksilver: then why does my example above behave that way?
23:10:59 <adrake_> quicksilver: I can't come up with an example where a failed alternative consumes input
23:11:06 <adrake_> quicksilver: even using a sequence of word8s
23:11:26 <Saizan> adrake_: it's about the lack of commitment. in parsec the parser (string "foo" <|> string "for") would simply fail when passed the input "for"
23:11:48 <adrake_> Saizan: that isn't my question, though
23:12:04 <Saizan> adrake_: because since it'll be able to consume "fo" with the first parser, then it won't even try the other
23:12:11 <adrake_> yes, I understand that
23:12:31 <adrake_> wait
23:12:50 <quicksilver> Saizan: adrake has an example (pasted a few lines up) in which attoparsec sodesn't appear to behave like this.
23:12:56 <Saizan> adrake_: so the difference is about trying the other alternative or not, it's standard behaviour that the alternative doesn't pick up where the first parser failed but from the start
23:12:57 <adrake_> ok, that's something I didn't know about parsec
23:13:18 <adrake_> Saizan: I see
23:13:36 <adrake_> Saizan: my question then takes the form of "why illustrate the magic of string that way"
23:13:51 <adrake_> since whether or not I used the string combinator, the behavior in parsec or attoparsec would be the same
23:13:54 <ivanm> adrake_: because how else would you demonstrate it?
23:14:06 <Saizan> adrake_: it won't?
23:14:07 <ivanm> since it behaves differently in parsec to attoparsec
23:14:29 <ivanm> adrake_: in your example, you're not using string as the first combinator in <|>
23:14:39 <Saizan> (string "foo" <|> string "for") with input "for" will succeed in attoparsec and will fail in parsec
23:14:43 <adrake_> right
23:14:52 <adrake_> and my example above succeeds in attoparsec and also fails in parsec
23:15:01 <quicksilver> please LISTEN! people.
23:15:11 <quicksilver> adrake_'s question is: why does the following succeed? parseOnly ((word8 0x41 >> word8 0x42 >> takeWhile1 (\x -> True)) <|> Data.Attoparsec.takeByteString) (B.pack "ACDE")
23:15:30 <ivanm> quicksilver: that might be his question, but it wasn't what he asked :p
23:15:32 <quicksilver> his point is that that should fail, as the word8 0x41 shouuld commit to the first branch
23:15:38 <quicksilver> ivanm: yes, it was. Repeatedly.
23:15:40 <adrake_> quicksilver: not quite
23:15:49 <adrake_> quicksilver: well, if I did ask that, it was not intentional
23:16:04 <adrake_> I understand why it succeeds, as attoparsec does not make commitments to the failed branch
23:16:09 <ivanm> quicksilver: it wasn't what he initially asked at least
23:16:30 <Saizan> > ord 'A' == 0x41
23:16:31 <lambdabot>   True
23:16:39 <Saizan> > ord 'C' == 0x42
23:16:40 <lambdabot>   False
23:16:54 <quicksilver> adrake_: no. attoparsec and parsec both make committments to failed branches
23:17:00 <quicksilver> the difference is in string specifically
23:17:07 <quicksilver> and least that's what I have always understood...
23:17:13 <quicksilver> ...and I can't explain your example in the light of that :)
23:17:19 <adrake_> quicksilver: my example above is a counterexa efb :P
23:17:21 <quicksilver> I would have thought your example should be no parse.
23:17:22 <quicksilver> yes.
23:17:45 <Jafet> Or pack "CDE"
23:17:53 <adrake_> I expected pack "CDE" given the documentation
23:18:11 <quicksilver> it ought to need a try around the first alternative.
23:18:23 <ivanm> adrake_: what does it return?
23:18:27 <adrake_> ivanm: ACDE
23:18:47 <ivanm> huh, I guessed "DE" rather than "CDE"
23:19:47 <ivanm> well, apparently takeWhile doesn't fail
23:20:23 <Saizan> "CDE" wouldn't make any sense
23:20:52 <augur> whats the notation for infix constructors? is it just f op g?
23:20:58 <adrake_> Saizan: if it consumed A because it succeeded, did not consume C because it expected B and then gave up and switched to the other branch
23:21:05 <ivanm> augur: yeah
23:21:09 <ivanm> but it has to start with a : IIRC
23:21:13 <adrake_> Saizan: this behavior seemed useless to me, so I wanted to make sure I had interpreted it right
23:21:20 <Saizan> adrake_: branches are supposed to not communicate
23:22:41 <adrake_> Saizan: I didn't think they should, but that's what I read the documentation as implying. Of course, the parser alternative instance has no documentation that I can find, so I was left to reading that out of the string documentation
23:30:25 <Saizan> adrake_: my guess is that it changed behavior to not commit anywhere at some point, and the doc wasn't updated
23:30:54 <Saizan> weird though, might actually be a bug
23:40:37 <Athas> Can it really be true that writing a Setup.hs is the best way to get cabal to install some shell scripts along with the main executable?
23:40:50 <Athas> (It was the last time I asked, but maybe things changed.)
23:40:58 <poltak> Athas: jdk
23:52:05 <Saizan> preflex: seen bos
23:52:05 <preflex>  bos was last seen on #haskell 12 hours, 6 minutes and 22 seconds ago, saying: which i'm not gonna write
23:52:57 <chrissbx> What does the term "monad" exactly represent? Is the value that for example the expression (a >> b) returns a monad?
23:53:20 <chrissbx> I find the first two sentences from the wikipedia article confusing:
23:53:36 <MatrixFrog> chrissbx you might try Real World Haskell
23:53:50 <Athas> It's simpler if you don't think too much about what a monad *is*, and focus on what it *does*, for the moment.
23:53:53 <Athas> (But yes.)
23:53:57 <MatrixFrog> wikipedia is notorious for being overly technical at the expense of being readable
23:54:01 <chrissbx> "a monad is a programming structure that represents computations. Monads are a kind of abstract data type constructors that encapsulate program logic (instead of data in the domain model)"
23:54:16 <chrissbx> What confuses me is that the first sentence seems to say that what I said above is correct,
23:54:18 <MatrixFrog> exactly what i'm talking about
23:54:23 <Saizan> @ask bos is it normal for attoparsec's <|> to always backtrack? e.g. parseOnly ((char8 'a' >> fail "") <|> return 'b') (pack "ac") == Right 'b'
23:54:23 <lambdabot> Consider it noted.
23:54:32 <chrissbx> but then abstract data type constructor sounds to me like what bind is.
23:55:21 <chrissbx> Athas: I don't want to learn about monads, I already know how to use and define them, but I'm unclear about the actual term "monad" itself.
23:55:29 <Saizan> chrissbx: the monad is the type constructor
23:57:21 <Saizan> (a >> b) is called a monadic action, for example
23:57:21 <chrissbx> Hm. I'm more fluent in Scheme and Clojure, so if you could explain without involving type terminology? :)
23:57:21 <Saizan> so e.g. Maybe is a monad, while (Just 'a') is a monadic action (often just action) in the Maybe monad
23:57:21 <chrissbx> hm k
23:57:38 <Saizan> :t Just 'a'
23:57:39 <lambdabot> Maybe Char
23:57:52 <chrissbx> So monad is "the library", versus when I use the library it's a monad action.
23:58:26 <Saizan> the type
23:58:49 <chrissbx> yeah ok
