00:05:26 * hackagebot combinatorial-problems 0.0.4 - A number of data structures to represent and allow the manipulation of standard combinatorial problems, used as test problems in computer science.  http://hackage.haskell.org/package/combinatorial-problems-0.0.4 (RichardSenington)
00:23:44 <haskelldude> hi,
00:24:07 <mjrosenb> haskelldude: morning
00:25:02 <haskelldude> can sm1 show me how to use "where" with guards?
00:25:56 <ion> I don’t think sm1’s here.
00:26:16 <Phyx-> think that's short for someone
00:26:40 <littlebobby> implications (a -> b) are hard to grasp
00:26:45 <ion> > let f x | x = yeah | otherwise = nope where { yeah = 1; nope = 0 } in f False
00:26:46 <lambdabot>   0
00:26:50 <haskelldude> :) yes. someone
00:29:49 <haskelldude> hello?
00:30:05 <mjrosenb> haskelldude: ion posted some code that did what you asked.
00:31:07 <haskelldude> mjrosenb thanks ddnt c
00:31:34 <mjrosenb> haskelldude: i should hope so, this is #haskell, not ##c.
00:34:13 <haskelldude> is the use of  "otherwise" a must?
00:34:26 <ion> no
00:50:30 <mjrosenb> > otherwise
00:50:30 <lambdabot>   True
00:51:01 <shachaf> > тrue
00:51:02 <lambdabot>   otherwise
00:51:09 <ion> :-D
00:51:55 <shachaf> I wish Haskell didn't have syntax that depended on built-in types (in a nice way, I mean).
00:52:33 <Phyx-> shachaf: you mean lists?
00:52:48 <ion> and ‘do’ and ‘otherwise’?
00:53:06 <ion> and guards (they depend on Bool)
00:53:28 <shachaf> Guards and if, yes.
00:54:01 <shachaf> And the rest of it.
00:55:08 <ion> (Not that ‘otherwise’ is Haskell syntax, to be pedantic, but it’s rather closely related to guards.)
00:55:49 <Phyx-> otherwise isn't build in syntax
00:56:17 <Phyx-> ah, you said it yourself
00:56:47 <Phyx-> so you're basically wishing that Haskell had no syntactical sugar?
00:57:31 <ion> I for one love ‘do’, but i would like ‘if’ to be a function.
00:58:27 <ion> As for guards, dunno… ‘otherwise’ is a bit kluge-ish but a nicer alternative doesn’t immediately come to mind.
00:59:27 <Phyx-> if can't be a function and impose the same syntax people expect
00:59:46 <shachaf> Phyx-: No, I wish the syntax was general enough that it would work just as well with user-defined operators.
01:00:03 <shachaf> s/operators/types and values/
01:01:02 <Phyx-> shachaf: in terms of types, aren't the only special syntaxed types, [], (,) and variables?
01:01:12 <shachaf> Bool is another.
01:01:23 <Phyx-> Bool isn't special
01:01:25 <shachaf> I don't mine (,) as much, I guess.
01:01:29 <shachaf> Sure it is. Guards depend on it.
01:01:44 <Phyx-> it's just another constructor
01:01:48 <shachaf> Even with NoImplicitPrelude they use GHC.Bool
01:01:56 <Phyx-> guards just accept a Bool value
01:02:05 <Phyx-> besides, guards are sugar
01:02:23 <Phyx-> they're not there durin typechecking so it's unfair to say Bool is special because of that
01:02:48 <shachaf> I don't see how it's unfair. It's special-purpose syntax that depends on predefined types.
01:03:19 <Phyx-> predefined normal types
01:03:23 <Phyx-> that doesn't make Bool special
01:03:30 <Phyx-> that makes guards special
01:05:30 <mjrosenb> right, but you can't define a new "bool" type, along with a new if function
01:07:19 <Phyx-> you can't define a new If function
01:07:24 <Phyx-> because that syntax is special
01:07:31 <Phyx-> but the Bool isn't
01:07:53 <Phyx-> you can define MyBool = MyTrue | MyFalse
01:08:28 <zygoloid> Phyx-: your position is inconsistent. Bool is special because special syntax uses it.
01:08:59 <Phyx-> i disagree
01:09:01 <Phyx-> 100%
01:09:08 <Phyx-> and it's not inconsistent
01:09:09 <zygoloid> you cannot define a type which has the same properties as Bool
01:09:18 <Phyx-> oh?
01:09:18 <zygoloid> therefore Bool is special
01:09:19 <Phyx-> import Prelude hiding (Bool)
01:09:19 <Phyx-> data Bool = True | False
01:09:23 <Phyx-> seems to do just that
01:09:25 <zygoloid> nope
01:09:30 <Phyx-> yes it does
01:09:32 <zygoloid> it doesn't work in 'if' or in guards
01:09:33 <Phyx-> try it
01:09:37 <Phyx-> ofcourse it would
01:09:39 <Phyx-> it's the same type
01:10:47 <Phyx-> semantically there's nothing special about bool
01:10:54 <Phyx-> other that it's defined in the base
01:11:04 <zygoloid> Phyx-: if that worked, i'd agree with you
01:11:19 <vold_> couldn't match expected type 'GHC.Bool.Bool' against inferred type 'Bool'
01:11:26 <Phyx-> Right, the only reason, it doesn't it because of how GHC does type resolution
01:11:34 <Phyx-> not because there's anything inherently special about Bool
01:11:42 <zygoloid> Phyx-: no, it doesn't work because the haskell report says so
01:12:10 <zygoloid> (because Prelude.Bool is special)
01:12:12 <maurer_> Phyx-: if is a special form which operates on Prelude.Bool
01:12:28 <Phyx-> zenzike: where?
01:12:34 <maurer_> Phyx-: As if is not replaceable, you cannot make it use YourMod.Bool instead
01:13:52 <Phyx-> maurer_: yes, if is special and replacable, that doesn't mean Bool isn't. My point is quite simple. some syntax can't be defined at user level, like if, that doesn't mean the types they depend on are special, e.g. can't be defined in a normal haskell file
01:14:12 <Phyx-> semantically and syntactically there's nothing really special of the Bool type
01:14:17 <Phyx-> nor it's constructors
01:14:20 <Phyx-> unlike []
01:14:43 <zygoloid> its specialty is imbued upon it by other constructs
01:14:45 <shachaf> No, syntactically there's something different -- you can do if True then ... else ..., but you can't do if MyTrue then ... else ...
01:15:11 <shachaf> The type Prelude.Bool has a property -- namely, that it can be used in an if and in guards -- that other types don't have. :-)
01:15:19 <zygoloid> Phyx-: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-320003.6
01:15:21 <Phyx-> shachaf: that has nothing to do with Bool being special, it has to do with how types are resolved.
01:15:26 <zygoloid> note: "as defined in the Prelude"
01:16:41 <Phyx-> zygoloid: that line does absolutely nothing to say that Bool is special, I've stated repeatedly that the only thing about bool is that it's defined in the prelude. It doesn't use any special syntax or treatment. It's not special in the sense that it's not user defineable. It can't be put in the same class as if and guards
01:16:46 <Phyx-> that's been my position all along
01:17:00 <quicksilver> aren't we just arguing about the meaning of the word "special" now?
01:17:05 <quicksilver> that seems like a boring argument.
01:17:14 <quicksilver> of course, Phyx- is wrong and Bool is special, but it's still boring ;)
01:17:21 <Phyx-> fine whatever
01:17:28 * shachaf finds this argument amusing at this point. :-)
01:17:30 <kalven> well, if there's nothing else to argue about...
01:18:12 <shachaf> I wish Haskell *syntax* depended minimally on types that can't be overridden. How's that?
01:19:08 <quicksilver> shachaf: -XNoImplicitPrelude gets you pretty close I think?
01:19:18 <zygoloid> i thought we'd started with a pretty clear definition of special: a type is special if there is syntax which depends on it
01:19:19 <maurer_> Phyx-: I would counterpose that we should remove the "if" bit of syntax
01:19:21 <shachaf> quicksilver: Still leaves you with things like guards.
01:19:27 <zygoloid> in that sense it seems clear to me that Phyx- is just wrong
01:19:39 <Phyx-> zygoloid: that's the definition that YOU started with
01:19:42 <Phyx-> which I was opposed to
01:19:58 <quicksilver> shachaf: doesn't -XNoImplicitPrelude mean that guards use whichever 'Bool' type is in scope?
01:20:01 <quicksilver> I haven't tried.
01:20:05 <zygoloid> Phyx-: umm, the notion of "special syntaxed types" was yours, not mine
01:20:24 <quicksilver> zygoloid, Phyx- : well my point is, we don't have an argument of substance - of logic - merely an argument of premises.
01:20:32 <quicksilver> it's clear that everyone's logic is sound.
01:20:32 <Phyx-> zygoloid: correct, I said, the function IF is special syntaxed, that doesn't mean the types it depends are on
01:20:46 <quicksilver> we just differ on the premise, i.e. what does "special" actually mean.
01:21:01 <quicksilver> I would agree to differ on the definition.
01:21:18 <zygoloid> Phyx-: i see now that i misunderstood what you meant by that phrase :)
01:32:17 <erus`> printf("2 ^ 0 = %d!", 2^0); //prints 2 = 2
01:32:20 <erus`> am i going mad
01:35:01 <shachaf> erus`: Not "2 ^ 0 = 2!"?
01:35:25 <erus`> yeah
01:35:30 <erus`> ^ isnt power of in c?
01:35:35 <Phyx-> no
01:35:39 <shachaf> Of course not.
01:35:40 <Phyx-> bitwise XOR
01:35:50 <erus`> what about C++?
01:36:07 <shachaf> In C++ it does operator^.
01:36:14 <shachaf> Which is still xor for ints.
01:39:02 <zygoloid> well... in c++ it does xor for ints and operator^ for user-defined types :)
01:39:17 <zygoloid> (you didn't expect consistency, did you?)
01:39:44 <shachaf> zygoloid: ?
01:41:26 <zygoloid> shachaf: See c++11 (13.3.1.2)/1. for ints, 2^0 does not call operator^.
01:41:40 <shachaf> Oh, I see.
01:46:07 <shachaf> zygoloid: Is there a practical difference as far as the user can tell?
01:47:08 * quicksilver wonders the same
01:47:20 <quicksilver> is it somethign to do with how it behaves when the arguments are different types?
01:47:41 <quicksilver> resolution rules different for 'real' operatorX methods as opposed to builtin xor?
02:07:13 <zygoloid> there is a practical difference: f(UDT, int) can be called as f(0, 0) if there's an implicit conversion from int to UDT
02:07:32 <zygoloid> operator@(UDT, int) can't be called as 0@0 even if there's such an implicit conversion
02:07:53 <zygoloid> (i say practical, but i've never seen this come up in practice!)
02:09:08 <quicksilver> zygoloid: I thought it might be something along those lines.
02:09:37 <quicksilver> zygoloid: implicit conversions were C++'s mistake to correspond to haskell's defaulting and DMR mistake.
02:12:47 * wli attempts to hammer out a wrapper for http://hackage.haskell.org/packages/archive/bindings-gsl/0.2/doc/html/Bindings-Gsl-OneDimensionalMinimization.html
02:13:52 <wli> cabal is taking a long while... gcc spinning.
02:14:44 <dcoutts> any idea what it's doing?
02:18:30 <wli> No, but it finished. Now I just have to grind out some sort of native Haskell wrapper.
02:21:54 <frerich> @djinn (a -> b) -> (c -> b) -> Either a c -> b
02:21:54 <lambdabot> f a b c =
02:21:54 <lambdabot>     case c of
02:21:54 <lambdabot>     Left d -> a d
02:21:54 <lambdabot>     Right e -> b e
02:23:08 <frerich> @djinn (arg1 -> arg2 -> res) -> ((arg1,arg2) -> res)
02:23:08 <lambdabot> f a (b, c) = a b c
02:23:29 <cheater_> what is haskell's defaulting and dmr mistake?
02:30:26 <ketil> I'm getting a segfault from ghci - there was a warning earlier about incompatible versions of mtl, could the segfault be a consequence of that, or should it be reported as a bug?
02:31:53 <ion> @@ @pl @djinn (a -> b) -> (c -> b) -> Either a c -> b
02:31:54 <lambdabot>  (line 1, column 36):
02:31:54 <lambdabot> unexpected ">" or "-"
02:31:54 <lambdabot> expecting variable, "(", operator or end of input
02:32:02 <ion> @ @pl @djinn (a -> b) -> (c -> b) -> Either a c -> b
02:32:21 <ion> @@ @pl @djinn (arg1 -> arg2 -> res) -> ((arg1,arg2) -> res)
02:32:21 <lambdabot>  f = (`ap` snd) . (. fst)
02:33:51 <co_dh> :t curry
02:33:52 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
02:34:00 <co_dh> :t uncurry
02:34:00 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
02:37:27 <mjrosenb> @djinn  ((b, b1) -> c, b) -> b1 -> c
02:37:27 <lambdabot> f (a, b) c = a (b, c)
02:38:25 <mjrosenb> @@ @pl @djinn  ((b, b1) -> c, b) -> b1 -> c
02:38:25 <lambdabot>  f = uncurry ((. (,)) . (.))
02:38:42 <mjrosenb> lambdabot: you can do better than that :-p
02:41:15 <shachaf> mjrosenb: ?
02:41:48 <mjrosenb> :t uncurry curry
02:41:49 <lambdabot> forall b b1 c. ((b, b1) -> c, b) -> b1 -> c
02:42:25 <mjrosenb> unless @djinn found something that is not isomorphic to curry
02:42:50 <shachaf> Oh.
02:43:00 <shachaf> Well, @pl's purpose is to convert to point-free style.
02:43:06 <shachaf> The optimizer is just a bonus. :-)
02:43:08 <mjrosenb> @unpl ((. (,)) . (.))
02:43:08 <lambdabot> (\ g j d -> g (((,)) j d))
02:43:24 <mjrosenb> yup, that looks like curry to me
02:43:34 <mjrosenb> shachaf: it is supposed to be an "optimizer"
02:43:43 <Jafet> Optimizing for lulz.
02:43:57 <shachaf> mjrosenb: Given that you saw the output of @djinn above, it seems likely that it's curry. :-)
02:44:09 <shachaf> @pl (+3)
02:44:09 <lambdabot> (3 +)
02:44:27 <shachaf> @help pl
02:44:27 <lambdabot> pointless <expr>. Play with pointfree code.
02:45:09 <mjrosenb> shachaf: well it is uncurry curry
02:45:33 <mjrosenb> and  f (a, b) c = a (b, c) is not immediately obvious as "uncurry curry" to me
02:46:03 <mjrosenb> oh wait, i know what that does
02:46:11 <mjrosenb> i was thinking of something far more mystical.
02:46:37 <shachaf> ?
02:46:44 * shachaf suspects he should goto sleep;
02:47:18 <mjrosenb> although the fact that uncurry seems to stack is kinda awesome
02:47:23 <mjrosenb> :t :t  uncurry . uncurry (uncurry uncurry) . uncurry (uncurry (uncurry uncurry))
02:47:23 <lambdabot> parse error on input `:'
02:47:28 <mjrosenb> :t  uncurry . uncurry (uncurry uncurry) . uncurry (uncurry (uncurry uncurry))
02:47:29 <lambdabot> forall a b c a1 b1 b2 a2 b3 b4 b5. (((a2 -> b3 -> b4 -> b5 -> ((a1 -> b1 -> b2 -> a -> b -> c, (a1, b1)), b2), (a2, b3)), b4), b5) -> (a, b) -> c
02:47:47 <zygoloid> @type fmap . fmap (fmap fmap) . fmap (fmap (fmap fmap))
02:47:48 <lambdabot> forall a (f :: * -> *) a1 (f1 :: * -> *) (f2 :: * -> *) a2 b (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => (a -> f2 (a1 -> a2 -> b)) -> f a -> f (f2 (f1 a1 -> f1 (f3 a2 -> f3 b))
02:47:48 <lambdabot> )
02:48:50 <shachaf> @ty fmap (fmap fmap (fmap (fmap fmap))) (fmap (fmap (fmap fmap)))
02:48:51 <lambdabot> forall a (f :: * -> *) a1 (f1 :: * -> *) (f2 :: * -> *) a2 b (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => (a -> f2 (a1 -> a2 -> b)) -> f a -> f (f2 (f1 a1 -> f1 (f3 a2 -> f3 b))
02:48:51 <lambdabot> )
02:49:02 * zygoloid ponders whether there's a simple characterization of functions for which combinations (using application and composition) are always well-typed
02:49:26 <ajnsit> How do we pass flags to Cabal while building code?
02:50:09 <ajnsit> I mean I see cabal files with code like "if flag(production) ..."
02:50:20 <mjrosenb> zygoloid: this is unfortunately not the case with uncurry
02:50:30 <dcoutts> ajnsit: ah, then it's cabal configure -fproduction
02:50:34 <mjrosenb> :t  uncurry . uncurry uncurry . uncurry
02:50:35 <lambdabot>     Couldn't match expected type `(a1 -> b1 -> a -> b -> c, (a1, b1))'
02:50:35 <lambdabot>            against inferred type `(a2, b2) -> c1'
02:50:36 <lambdabot>     Probable cause: `uncurry' is applied to too few arguments
02:51:02 <ajnsit> dcoutts, ah okay thanks
02:53:21 <zygoloid> mjrosenb: that's a shame. it is the case for fmap and id, at least.
02:53:32 * wli attempts to make C function pointers out of Haskell functions.
02:54:00 * JuanDaugherty asks why you do that?
02:54:10 * zygoloid hands wli unsafeCoerce and a very long fuse
02:54:15 <aleator> wli: Just did that a minute ago :)
02:54:34 <wli> A C API requires a function pointer.
02:54:45 <zygoloid> foreign export?
02:55:11 <aleator> Actually, that is foreign import "wrapper"
02:55:34 <wli> http://hackage.haskell.org/packages/archive/bindings-gsl/0.2/doc/html/Bindings-Gsl-OneDimensionalMinimization.html <-- the module I'm trying to devise a Haskell wrapper for
02:56:28 <wli> The C function takes a C function pointer.
02:56:38 <zygoloid> "foreign export dynamic" seems like what you want?
02:56:55 <wli> zygoloid: What am I supposed to export?
02:57:14 <zygoloid> that's not what foreign export dynamic does :)
02:57:30 <zygoloid> it generates a function :: haskell function -> IO (c function pointer)
02:57:33 <aleator> wli: foreign import ccall "wrapper" wrapPrinter :: (CString -> IO ()) -> IO (FunPtr (CString -> IO ())) is what you're looking for
02:57:56 <wli> zygoloid: I'm trying to create a native Haskell wrapper for this thing. It has to pass a Haskell function passed to it as a C function to the C function.
02:57:56 <aleator> Well, if your c function is void (char*).. anyway
02:58:11 <zygoloid> that's exactly what foreign export dynamic is for
02:58:33 <accel> is there a place like a reverse kick-starter? where I can set aside money saying "I will contribute BLAH to anyone who rewrites pdftex in literate Haskell" ?
02:58:56 <Phyx-> wli: you can use the dynamic import like zygoloid said
02:58:57 <zygoloid> accel: sounds a bit like rentacoder
02:59:05 <Phyx-> i have a few examples here if you want wli
02:59:17 <Phyx-> but it's not that hard, lol
02:59:29 <zygoloid> accel: maybe rentacoder + groupon? :)
02:59:30 <accel> zygoloid: no, the difference is taht lots of people can contribute
02:59:33 <wli> aleator: Trying it.
02:59:39 <accel> so for example, I'm only willing to contribute $100.00
02:59:49 <accel> but maybe 1000 other people are also willing to give $100.00
03:00:01 <Phyx-> ah didn't see that aleator gave an example
03:00:06 <aleator> wli: mind you, I never heard about dynamic import, so that might be even better way.
03:00:07 <accel> and suddenly, the 100K tag makes it worth someone, with the proper skills, to spend a year rewriing it
03:00:17 <ben> accel: bountysource?
03:00:29 <zygoloid> accel: well, there's pledgebank, but that's not exactly right either
03:00:42 <accel> ben: holy shit; that's cool; never heard of it until now
03:00:51 <Phyx-> aleator: dynamic is the other way around, from a FunPtr to a haskell function
03:01:03 <ben> I have no idea whether anyone uses it[ anymore], I just heard it mentioned a while ago
03:01:17 <accel> actually; i have a better idea
03:01:19 <aleator> Phyx-: Ah, right. I guess that happens relatively rarely.
03:01:24 <accel> (1) post a kickstarter, saying I will do it for $100K
03:01:32 <accel> (2) after collecting money, hire someone on rentacoder for $50K
03:01:38 <accel> and take other $50K in management fees
03:01:56 <zygoloid> haha
03:02:02 <Phyx-> aleator: I use them when interfacing with the ghc api, but I guess that's not very common either
03:02:19 <ben> (3) spent $80k in time rewriting it because the rentacoder guy wrote it in php
03:04:06 <mjrosenb> @src second
03:04:07 <lambdabot> Source not found. You speak an infinite deal of nothing
03:04:13 <zygoloid> accel: you'd contribute $100 for a pdftex rewrite in lhs?
03:04:25 <accel> zygoloid: yeaah
03:04:35 <zygoloid> @src Arrow -- mjrosenb
03:04:35 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
03:04:40 <zygoloid> @src Arrow
03:04:41 <lambdabot> class Arrow a where
03:04:41 <lambdabot>     arr, pure   :: (b -> c) -> a b c
03:04:41 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
03:04:42 <ben> Why not go the entire distance and rewrite latex as a haskell DLS
03:04:43 <ben> DSL
03:04:43 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
03:04:45 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
03:04:47 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
03:04:49 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
03:04:59 <accel> zygoloid: i've been reading the TexBook lately
03:05:07 <accel> zygoloid: it's beautiful ....; the typesetting algorithm
03:05:17 <accel> to have a pdfTeX in LHS is worth $100 to me
03:05:25 <accel> ben: actually, DSL would probably be even cooler
03:05:30 <accel> I'm almost excited to write it myself
03:05:46 <JuanDaugherty> calling into C from haskell is one thing, calling into haskell from C quite another
03:06:09 <Phyx-> JuanDaugherty: I do it quite often :P
03:06:12 <shachaf> Right. Those are only the same thing if C = Haskell.
03:06:23 <Phyx-> even calling from C# into Haskell
03:07:07 <JuanDaugherty> for great good?
03:07:27 <mjrosenb> zygoloid: iirc, second is defaulted to be implemented in terms of first and arr.
03:07:40 <Phyx-> JuanDaugherty: yes, for world peace almost, lol
03:07:59 <JuanDaugherty> well carry on
03:08:03 <Phyx-> JuanDaugherty: it's not that hard, and in fact, the entire process can be automated, which i have
03:08:11 <hpaste> wli pasted “MinOneDim.hs” at http://hpaste.org/48500
03:08:38 <wli> The foreign import is not going well.
03:09:19 <Phyx-> wli: you have to put it on the top of the file
03:09:31 <Phyx-> and the syntax is wrong
03:09:37 <wli> Phyx-: How? It's a function argument.
03:09:42 * JuanDaugherty certainly didn't mean to indicate it was impossible, in fact I'm dedicated to the idea of language neutral programming linking across arbitrary langs on a given platform
03:09:48 <Phyx-> wli: you have to statically declare a "conversion" function
03:09:52 <Phyx-> and you call that on an argument
03:10:19 <Phyx-> wli: for instance "foreign import stdcall "wrapper" mkCBF3 :: (SinglePtr -> MultiPtr) -> IO (CBF3Ptr)"
03:10:48 <zygoloid> mjrosenb: sounds right to me. second a = arr swap >>> first a >> arr swap where swap (a,b) = (b,a)
03:10:51 <Phyx-> creates a function mkCBF3 which converts a function of type SinglPtr -> MultiPtr to a FunPtr
03:11:27 <Phyx-> wli: you want to do (Double -> Double) -> FunPtr (Double -> Double)
03:11:27 <Phyx-> ?
03:11:47 <wli> Phyx-: gsl_functions do something strange.
03:12:37 <mjrosenb> zygoloid: and where does >>> come from?
03:13:08 <Phyx-> wli: what is the type of the function pointer you need?
03:13:47 <Phyx-> wli: better yet, what is the type of C'gsl_function ?
03:13:58 <Phyx-> since f' seems to be unused
03:15:38 <Phyx-> ah, i see the type
03:16:24 <Phyx-> wli: http://pastebin.com/4TWaPKwg
03:16:25 <mauke> The paste 4TWaPKwg has been copied to http://hpaste.org/48501
03:17:22 <wli> Bindings.Gsl.MathematicalFunctions.C'gsl_function :: GHC.Ptr.FunPtr (CDouble -> GHC.Ptr.Ptr () -> IO CDouble) -> GHC.Ptr.Ptr () -> Bindings.Gsl.MathematicalFunctions.C'gsl_function
03:18:57 <Phyx-> wli: this should work http://pastebin.com/4TWaPKwg
03:18:57 <mauke> The paste 4TWaPKwg has been copied to http://hpaste.org/48501
03:19:35 <Phyx-> wli: for more you can check out this example http://www.haskell.org/haskellwiki/GHC/Using_the_FFI#Calling_Haskell_from_C
03:19:52 <Phyx-> the callbacks section
03:20:42 <wli> Hmm, now it seems to think CDoubles and Doubles are different somehow.
03:20:53 <Phyx-> well, they are
03:21:05 <Phyx-> they're different types
03:21:26 <Phyx-> didn't even see that the orinal inputs were Doubles
03:21:44 <Phyx-> :t CDouble
03:21:45 <lambdabot> Not in scope: data constructor `CDouble'
03:22:05 * wli is clueless as to how to convert them.
03:22:45 <quicksilver> wli: realToFrac ?
03:23:51 <Phyx-> ^^^ what he said
03:23:54 <Phyx-> lol
03:25:50 <zygoloid> mjrosenb: depends on your base version :)
03:25:57 <mjrosenb> @src (>>>)
03:25:57 <lambdabot> Source not found.
03:26:56 <mjrosenb> the online docs say that it is an operation on categories
03:27:05 <zygoloid> mjrosenb: it's a method of Arrow in older base, it's defined as (.) (from Category) in newer base
03:27:15 <wli> quicksilver: Just had to add it in enough places. I'm getting there.
03:27:26 <zygoloid> or maybe flip (.) :)
03:28:54 <mjrosenb> this is specifically for the Category instance of (->), right?
03:29:33 <mjrosenb> oh, it is defined in terms of (.) where (.) is the category function
03:29:55 <mjrosenb> so >>> will work with all categories
03:35:06 <ski> Phyx- : do you need `IO' in that wrapper ?
03:36:09 <Phyx-> ski: I think so
03:39:28 <Phyx-> ski: my guess is to stress the point that you're doing something that has implication on the *real world*. In practice I've found it to be an issue only in the case of having a function with lists like [Int] -> [Int]
03:40:03 <Phyx-> un which case, unless the original function was also in IO, you would need unsafePerformIO
03:41:34 <Phyx-> ski: just checked, yeah it has to be in the form of ft -> IO (FunPtr ft) (FFI Addendum)
03:47:17 <ski> Phyx- : yeah, i just checked too
03:47:51 <ski> (i think i was confusing with a `dynamic' import)
03:49:22 <ski> Phyx- : i think the reason for requiring `IO' with `wrapper' import is that the conversion function allocates a new `FunPtr foo', which has an identity, and thus can be compared for equality
03:50:26 <ski> similarly to if we had a variant of `IORef' which allocated a new *immutable* cell, it would still have to be in a monad, because it generates a new reference each time, comparing unequal to any other reference
03:50:59 <Phyx-> ski: I was with you till the last part, comparison equality doesn't require IO does it? I understad the allocation part though
03:51:12 <ski> (such a type could be useful to "find one's way around" cyclic graphs, e.g., to know when one has reached the same position again)
03:51:26 <Phyx-> comparing equality*
03:51:34 <Phyx-> I should stop making up word groups
03:51:59 <ski> Phyx- : exactly because comparision/equality doesn't require `IO', does the *generation* of a new reference require `IO' (or some other monad)
03:52:09 <Phyx-> ah ok
03:52:58 <ski> if we run `newIORef x' twice, we get two references, comparing unequal
03:53:07 <Phyx-> yeah
03:54:00 <ski> then there's also the fact that the wrapper allocates memory which has to be freed .. though that's probably only observable in the sense that the memory can get exhausted sooner
03:54:38 <Phyx-> yup
03:55:16 <Phyx-> need to finish reading the addendum one of these days
03:55:24 <Phyx-> I've only read the parts I've needed
03:56:05 <ski> hm .. `type IRef :: * -> * -> *; newIRef :: a -> IT s (IRef s a); readIRef :: IRef s a -> a; runIT :: (forall s. IT s a) -> a'
03:56:28 <ski> also `instance Eq (IRef s)'
03:56:35 <ski> does that sound useful ?
03:57:03 <quicksilver> is that related to IVars?
03:57:14 <quicksilver> which could be read outside IO but if they did, they blocked until they were set.
03:57:36 <quicksilver> I never liked that idea, I don't like using blocking to sequence pure computation with IO execution
03:58:01 <ski> no, this is not `IVar'
03:58:03 <Phyx-> if that's the case, wouldn't an Eq instance deadlock when comparing the same IRef ?
03:58:53 <ski> `IVar's have a mutative operation for setting the value
03:59:32 <ski> the `Eq' instance wouldn't touch the contents of an `IRef', similarly to what happens with `IORef' already, i think
03:59:40 <quicksilver> ski: I can see it's not the same :)
03:59:46 <quicksilver> I was asking if it was related.
03:59:47 * wli will do the unsafety bits to yank the foreign calls out of IO.
04:00:37 <ski> quicksilver : depends on what you mean. i some sense it's related, in that it's related to `TVar',`MVar',`SampleVar',`Chan',`IORef',`STRef s'
04:01:26 <quicksilver> :)
04:01:29 <Phyx-> wli: you really don't need to do that in 99% of the cases
04:01:36 <ski> the point of `IRef' was meant to be a "handle" or indirection, which you can use to build cyclic structures, where you can check when you reach the same point in the structure
04:01:55 <Phyx-> ski: ah, that does sound handy
04:01:59 <ski> so, the thing an `IRef s a' adds over an `a' is the identity of the node
04:02:21 <ski> and the monad is because we need to generate fresh `IRef s's when we generate them
04:02:22 <wli> Phyx-: Numerical bits have no business with IO.
04:02:57 <ski> hm, though maybe the `s' argument wouldn't be appropriate here ..
04:04:36 <ski> it would seem to be useful, even expected, to be able to traverse structures with `IRef's, without having to keep track of a particular `s', specifically after the `s' thread has ended
04:06:52 <ski> quicksilver : anyway, `IVar's block until they're set because they can be unset for a while. these `IRef's would be set by construction, so that shouldn't be an issue
04:09:40 <Axman6> damn, seems I've missed an interesting discussion :(
04:10:08 <ski>   cyclicIRef :: (IRef a -> a) -> IRef a  -- hm, how to generalize nicely ?
04:10:45 <ski> (i suppose that ought to be monadic, since it allocates a new reference)
04:10:55 <ski>   cyclicIRef :: (IRef a -> a) -> I (IRef a)
04:11:44 <ski>   cyclicIRef :: Applicative i => (i (IRef a) -> i a) -> I (i (IRef a))  -- hm ?
04:12:32 <Axman6> ski: what you're talking about seems similar to the monad-par stuff
04:12:53 <ski> is that about doing computation in parallel ?
04:12:59 <Axman6> yeah
04:13:06 <stevenlawren> Hello - would anyone be good enough to give me a history lesson? Did Haskell ever consider continuation passing IO? I've heard that Haskell used to have an IO system before monads and it didn't work out as good as people thought it would. What's wrong with continuation passing IO?
04:13:25 <ski> Axman6 : i'm only talking about generating fresh references, to be able to tell when you visit the same place, in graphs
04:13:31 <Axman6> but it has a notion of variables that can only be written to once. not sure if they have tests for equality or not, but it seems it could be implemented
04:13:45 <ski> i.e. saner versions of cyclic data structures
04:14:15 <Axman6> stevenlawren: i believe that earlier imlpementations of Haskell/Gopher used continuation passing IO
04:14:20 <ski> Axman6 : yeah, i'm not talking about `IVar's which can be written to at most once
04:14:39 <ski> i'm talking about reference cells which contain a value by construction, always
04:14:43 <wli> Hmm, unwrapping a pointer is coming up.
04:14:55 <stevenlawren> Axman6: thanks. how come it didn't work out? what's wrong with it? It's popular again with jnode, so what's the catch?
04:15:28 <Axman6> i think monadic IO is much clearer to work with, and allows you to clearly separate IO and non-IO code
04:16:11 <Axman6> which is a huge win in terms of being able to understand what your program is doing, as well as encouraging people to minimise the amount of IO they perform
04:16:15 <quicksilver> stevenlawren: monads are a more general construction?
04:16:20 <ski> stevenlawren : Haskell *used* continuation-passing I/O
04:16:41 <quicksilver> stevenlawren: so it's interesting to have a general construct which has re-usable algorithms (like mapM, etc) which apply to IO and other stuff.
04:16:50 <Axman6> quicksilver: were you used haskell when there was continuation passing IO?
04:17:07 <ski> but in many cases, the CPS I/O was used in an essentially monadic way, for reasons of composability
04:17:08 <quicksilver> no.
04:17:16 <stevenlawren> ok, great, so there are no massive pitfalls that were found with haskell and are now being forgotten?
04:18:23 <Axman6> there probably are =)
04:19:44 <joe6> i want [1,2,3]  -> [(1,2),(2,3),(3,1)] and I am using this to do that: zipWith (\x y -> (x,y)) ([1..10]) (take 10 . drop 1 . cycle $ [1..10])
04:19:56 <joe6> just curious if there is a better way of doing it.
04:20:09 <joe6> > zipWith (\x y -> (x,y)) ([1..10]) (take 10 . drop 1 . cycle $ [1..10])
04:20:11 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,1)]
04:20:23 <Axman6> joe6: use zip =)
04:20:44 <Axman6> stevenlawren: it's possibly the main reason for moving is what quicksilver said, that it allows you to write much more natural and concise code, by letting you take advantage of all the monadic functions like mapM, etc.
04:20:52 <Axman6> possible*
04:21:10 <joe6> Axman6: that was awesome. Thanks.
04:21:21 <stevenlawren> ok, thanks everyone
04:21:25 <joe6> > zip ([1..10]) (take 10 . drop 1 . cycle $ [1..10])
04:21:27 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,1)]
04:21:45 <quicksilver> you can lose the take 10
04:21:54 <quicksilver> zip clips to the shorter list anyway
04:22:05 <Axman6> > zip [1..10] [1..]
04:22:06 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
04:22:13 <Axman6> @src zip
04:22:13 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
04:22:13 <lambdabot> zip _      _      = []
04:22:59 <ski> (Axman6 : i've played a little with an older version of Haskell User's Gofer System which used `Dialogue'-based I/O, e.g. in a CPSy way ..)
04:23:19 <Phyx-> > map (id &&& id) [1..10]
04:23:20 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
04:23:29 <Phyx-> > map (id &&& (- 1)) [1..10]
04:23:30 <lambdabot>   [(1,-1),(2,-1),(3,-1),(4,-1),(5,-1),(6,-1),(7,-1),(8,-1),(9,-1),(10,-1)]
04:23:36 <Phyx-> > map (id &&& (subtract 1)) [1..10]
04:23:37 <lambdabot>   [(1,0),(2,1),(3,2),(4,3),(5,4),(6,5),(7,6),(8,7),(9,8),(10,9)]
04:24:00 <ski> > let frob = "frob" in zip frob (tail (cycle frob))
04:24:01 <lambdabot>   [('f','r'),('r','o'),('o','b'),('b','f')]
04:24:16 <ski> joe6 : ^
04:24:39 <hpc> @quote consecutive
04:24:39 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
04:24:40 <Phyx-> ooh nice
04:24:54 <hpc> > (zip`ap`tail) [1..5]
04:24:55 <lambdabot>   [(1,2),(2,3),(3,4),(4,5)]
04:25:13 <quicksilver> > (zip`ap`(tail.cycle)) [1..5]
04:25:15 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,1)]
04:25:22 <joe6> ski, Phyx, that is cool. Thanks.
04:25:31 <saati> @src ap
04:25:31 <lambdabot> ap = liftM2 id
04:25:50 <saati> @src liftM2
04:25:50 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
04:26:03 <hpc> ap = (<*>), if you look at it more theoretically
04:26:20 <ski> saati : in this case `ap f g a = (f a) (g a)'
04:26:53 <hpc> :t \x -> join ($ x)
04:26:54 <lambdabot>     Occurs check: cannot construct the infinite type:
04:26:54 <lambdabot>       b = (a1 -> b) -> a
04:26:54 <lambdabot>     Probable cause: `$' is applied to too many arguments
04:27:04 <hpc> o.O
04:27:23 <ski> @type mfix . (Data.IORef.newIORef .)  -- what i'm basically pondering
04:27:24 <lambdabot> forall a. (GHC.IORef.IORef a -> a) -> IO (GHC.IORef.IORef a)
04:27:58 <magicman> :t maybe
04:27:59 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
04:27:59 <ski> @slap GHC for irritating with irrelevant implementation details
04:28:00 <lambdabot> go slap GHC for irritating with irrelevant implementation details yourself
04:29:28 * hackagebot Pathfinder 0.5.8 - Relational optimiser and code generator  http://hackage.haskell.org/package/Pathfinder-0.5.8 (JeroenWeijers)
04:30:58 <ski> @type \make -> mfix (Data.Traversable.traverse Data.IORef.newIORef . make)
04:30:59 <lambdabot> forall a (t :: * -> *). (Data.Traversable.Traversable t) => (t (GHC.IORef.IORef a) -> t a) -> IO (t (GHC.IORef.IORef a))
04:38:21 <ski>   (forall a. (f a,g a)) -> (forall a. f a,forall a. g a)
04:38:40 <ski>   (forall a. Either (f a) (g a)) -> (forall a. Either (f a) (g a))
04:38:53 <ski> these are not possibly to write, yes ?
04:39:03 <koala_man> false -> a, right? by the Curry--Howard isomorphism, shouldn't we be able to implement f :: Bottom -> a ?
04:39:19 <ski> @djinn Void -> a
04:39:20 <lambdabot> f = void
04:39:35 <ski>   void v = case v of {}
04:39:43 <ski> koala_man : so, yes
04:40:15 <koala_man> ahh, thanks!
04:40:53 <byorgey> alas, last I checked  case v of {}  is not valid Haskell syntax
04:41:00 <byorgey> although it should be
04:41:01 <ski> koala_man : ideally, the syntax `case <expr> of {}' would be allowed by `EmptyDataDecls'
04:41:27 <ski> while we wait for that to happen, you have to workaround it
04:41:56 <ski> e.g.
04:42:18 <ski>   void v = seq v (error "void _")
04:43:20 <ski> (so that if you pass e.g. `error "foo" :: Void' to `void', the blame you get from the call is the one from `error "foo"', not from `void' itself)
04:44:10 <ski> koala_man : .. did you have any particular use of `Void' or `void :: Void -> a' in mind ?
04:45:06 <koala_man> I'm porting a java program with a lot of void functions
04:45:35 <koala_man> I mean no, it's just to understand the theory
04:45:49 <ski> well, generally, the right translation of `void' in C or C++ or Java or C# is `()'
04:46:09 <ski> (blame the C crowd for naming the type wrong !)
04:46:14 <Phyx-> C# has ()?
04:46:24 <ski> it has `void', iirc
04:47:03 <koala_man> no, you can't have empty tuples in C#
04:47:06 <ski> koala_man : if you have a function/method which *never*returns* (like `exit' or `longjmp' in C, e.g.), then the appropriate type to use is `Void', though
04:47:25 <koala_man> ooh, I never considered that
04:47:43 <ski> i used `Void' in Haskell for actions in a monad which never returned
04:47:59 <ski>   killThread :: SystemM Void
04:48:20 <ski>   spawnThread :: SystemM Void -> SystemM Thread
04:48:51 <ski>   runSystemM :: SystemM Void -> IO ()
04:49:39 <ski> (where `SystemM' was a custom monad, implementing cooperative concurrency, amongst a few other things)
04:50:49 <ski> anyway, initially i used `()' instead of `Void', but it was hairy to keep myself sane, passing around `undefined's, not knowing for sure which was legitimate, and which wasn't
04:51:11 <ski> so i switched to `Void', to be able to get rid of all the `undefined's, to make sure the code was correct
04:51:48 * wli is slowly getting somewhere.
04:52:57 <ski> koala_man : so, typically you use `()', usually inside some monad, for `void'. `Void' is more rarely needed. ok ?
04:58:23 <koala_man> ski: I was kidding about the java thing :P
04:59:15 <ski> .. oh
04:59:21 <koala_man> thanks though! C-H is more awesome the more I look at it
04:59:53 <ski> koala_man : what do you think about `(forall a. (f a,g a)) -> (forall a. f a,forall a. g a)' and `(forall a. Either (f a) (g a)) -> (forall a. Either (f a) (g a))', then ?
05:00:07 <ski> ought they to be true or not ?
05:00:45 <koala_man> surely not
05:01:08 <ski> er, sorry, the last one was meant to be `(forall a. Either (f a) (g a)) -> Either (forall a. f a) (forall a. g a)'
05:01:18 <ski> koala_man : why not ?
05:01:51 <ski> the latter is a kind of disjunction property, sortof
05:01:59 <koala_man> I'm changing my mind
05:02:09 <ski> the former even classicists should agree with, i think
05:02:37 <koala_man> I misinterpretted it
05:03:17 <zygoloid> ski: (forall a. Either a (Not a)) -> Either (forall a. a) (forall a. Not a) ?!
05:04:14 <ski> zygoloid : sure, why not :)
05:04:58 <ski> the idea being that a proof of `forall a. Either (f a) (g a)' must be parametric in `a', and so which choice is chosen can't depend on the type `a'
05:05:44 <ski> zygoloid : of course the `Either' here is an additive disjunction
05:05:55 <ski> with a multiplicative disjunction, the picture would be different
05:06:53 <ski> (the multiplicative `Or' would be where `forall a. Or a (Not a)' actually holds)
05:16:42 <ski> hm, ok i can write `(forall a. (f a,g a)) -> (forall a. f a,forall a. g a)', indirectly
05:17:02 <koala_man> ¬(A ∧ B) -> (¬ A ∨ ¬B)
05:17:21 <koala_man> ehm. how do you express that demorgan's law for @djinn?
05:17:32 <koala_man> @djinn ((a,b) -> Void) -> Either (a -> Void) (b -> Void)
05:17:32 <lambdabot> -- f cannot be realized.
05:18:34 <ski> @djinn Not (Either a b) -> (Not a,Not b)
05:18:34 <lambdabot> f a = (\ b -> a (Left b), \ c -> a (Right c))
05:18:40 <byorgey> koala_man: that direction of de morgan's law is not valid in intuitionistic logic.
05:19:08 <byorgey> although you can go the other direction as ski demonstrates.
05:19:55 <ski> @djinn (a -> Not b) -> (b -> Not a)
05:19:55 <lambdabot> f a b c = a c b
05:20:02 <ski> @djinn (a -> b) -> (Not b -> Not a)
05:20:02 <lambdabot> f a b c = b (a c)
05:20:53 <byorgey> @djinn (((a,b) -> Void) -> Either (a -> Void) (b -> Void)) -> (Not (Not c) -> c)
05:20:53 <lambdabot> -- f cannot be realized.
05:20:56 <ski> @djinn (Not a,Not b) -> Not (Either a b)
05:20:56 <lambdabot> f (a, b) c =
05:20:57 <lambdabot>     case c of
05:20:57 <lambdabot>     Left d -> a d
05:20:57 <lambdabot>     Right e -> b e
05:21:05 <ski> ^ other direction :)
05:21:43 <ski> @djinn Either (Not a) (Not b) -> Not (a,b)
05:21:43 <lambdabot> f a =
05:21:43 <lambdabot>     case a of
05:21:43 <lambdabot>     Left b -> \ (c, _) -> b c
05:21:43 <lambdabot>     Right d -> \ (_, e) -> d e
05:21:48 <koala_man> so it's true, just not constructable through intuitionist logic?
05:21:52 <byorgey> eh, maybe "other direction" was not the right word
05:22:04 <ski> koala_man : it's not true, in intuitionistic logic
05:22:05 <byorgey> koala_man: it depends on what you mean by "true".
05:22:13 <byorgey> it is valid in classical logic.
05:22:15 <ski> @djinn Not (a,b) -> Either (Not a,Not b)
05:22:15 <lambdabot> Error: kind error: (KVar 5,KStar)
05:22:24 <ski> er ?
05:22:32 <ski> ah
05:22:37 <ski> @djinn Not (a,b) -> Either (Not a) (Not b)
05:22:37 <lambdabot> -- f cannot be realized.
05:22:44 <ski> @djinn NotNot (Not (a,b) -> Either (Not a) (Not b))
05:22:44 <lambdabot> f a =
05:22:44 <lambdabot>     void (a (\ _ ->
05:22:44 <lambdabot>              Right (\ b ->
05:22:44 <lambdabot>                     void (a (\ _ ->
05:22:44 <lambdabot>                              Left (\ c -> void (a (\ d -> void (d (c, b))))))))))
05:23:10 <byorgey> heh, interesting =)
05:23:25 <siracusa> @src NotNot
05:23:25 <lambdabot> Source not found. You type like i drive.
05:23:38 <ski> koala_man : `|- phi' is derivable in classical propositional logic, iff `|- Not (Not phi)' is derivable in intuitionistic propositional logic
05:23:50 <ski> <ski> @djinn-add type NotNot a = Not (Not a)
05:23:58 <ski> @djinn-env
05:23:58 <lambdabot> data () = ()
05:23:58 <lambdabot> data Either a b = Left a | Right b
05:23:58 <lambdabot> data Maybe a = Nothing | Just a
05:23:58 <lambdabot> data Bool = False | True
05:23:58 <lambdabot> data Void
05:24:00 <lambdabot> type Not x = x -> Void
05:24:02 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
05:24:04 <lambdabot> class Eq a where (==) :: a -> a -> Bool
05:24:06 <lambdabot> type NotNot a = Not (Not a)
05:25:04 <ski> byorgey : i believe you'd need a few `forall's for that `.. -> (Not (Not c) -> c)' one
05:25:16 <byorgey> ski: yes, I think you're right
05:25:37 <ski> that, or instantiate them in the right way, statically
05:26:00 <byorgey> yeah, but I don't know what the right way is off the top of my head
05:26:30 <ski> hm .. or maybe the antecedent is weaker ?
05:26:47 <byorgey> no, they are equivalent
05:27:15 <ski> hm, i don't see it
05:27:34 <ski> is this a derivation result, or an admissibility result ?
05:27:57 * ski suspects admissibility, in case the former wasn't weaker
05:28:38 <byorgey> ski: oh, hm, I was confused, it's  ~(~A /\ ~B) -> A\/B  which is equivalent to double negation elim
05:28:52 <ski> yeah, that one sounds more likely :)
05:28:55 <hpaste> wli annotated “http://pastebin.com/4TWaPKwg” with “http://pastebin.com/4TWaPKwg (annotation)” at http://hpaste.org/48501#a48502
05:28:55 <mauke> The paste 4TWaPKwg has been copied to http://hpaste.org/48501
05:29:21 <ski> i mean, intuitionistically, you can only (at least directly) extract a single bit of information from `Either (Not a) (Not b)'
05:29:37 <byorgey> haha, mauke, that looks like a bug =)
05:29:49 <ski> so, if you can serialize `c' to bits in `NotNot c -> c', all is probably well
05:38:53 <ski>   distAllSum :: AllSum f g -> Either (All f) (All g)
05:39:09 <ski> ok, i was actually able to define this as well -- nice :)
05:41:13 <nick__> \help
05:41:27 <nick__> What's up?!  I'm using GHC 7.0.3 with Linux. The 'epoll' system call should be used, while the 'select' call is actually used. The application terminated with the  "file descriptor 1025 out of range for select (0--1024)" error. Is there any way to make GHC use 'epoll'?
05:42:29 <Axman6> nick__: seems like you should be asking in #ghc. that's odd indeed
05:42:52 <ski> koala_man : C-H exercise, define `AllProd f g -> (All f,All g)',`AllSum f g -> Either (All f) (All g)' :)
05:43:30 <wli> I think I see why they ditched the library call: it calls abort() and kills the program (and circumvents the ghc runtime) when things go wrong.
05:46:04 <nick__> Axman6: thanks
05:49:21 <koala_man> ski: what's AllProd, Allsum and All?
05:50:31 <ski>   newtype All f = A (forall a. f a)
05:50:43 <ski>   newtype AllProd f g = AP (forall a. (f a,g a))
05:50:54 <ski>   newtype AllSum f g = AS (forall a. Either (f a) (g a))
05:50:59 <ski> koala_man ^
05:51:42 <ski> if you prefer, you can try doing it using `Rank2Types' (and maybe `ImpredicativeTypes') instead of `PolymorphicComponents'
05:52:03 <ski> so, it's basically just proving
05:52:06 <ski>   (forall a. (f a,g a)) -> (forall a. f a,forall a. g a)
05:52:07 <ski> and
05:52:16 <ski>   (forall a. Either (f a) (g a)) -> Either (forall a. f a) (forall a. g a)
05:52:28 <ski> in Haskell (with extensions)
05:54:17 <ski> (btw, the reverse directions of those are easy)
05:58:22 <byorgey> ski: interesting exercise =)
06:01:08 * ski is proving a few other similar laws
06:01:24 <ski> .. and trying to come up with some shockingly non-classical ones
06:01:56 <ski> hm .. i wonder whether i can prove `Not (forall a. Either a (Not a))' ..
06:02:16 <byorgey> the AllProd one was not that hard, but my intuition is failing me for the AllSum one
06:02:18 <ski> (that is valid in Markov's School, as well as in Brouwer's School)
06:03:40 <wli> Is there a sigprocmask?
06:05:41 <ski> byorgey : you can "cheat" with (ostenable) partiality
06:05:56 <byorgey> ski: yes, I have been thinking along those lines
06:06:29 <ski> this is correct iff a value of type `forall a. f a' is basically a value of type `f a' for a generic `a'
06:06:31 <byorgey> ski: intuitively it seems like you have to first find out whether the constructor is Left or Right, and then trust (by parametricity) that the constructor cannot change when you use it at a different type
06:06:36 <byorgey> right.
06:07:14 <byorgey> ok, so maybe my intuition was good.  I just haven't found the right syntax to make GHC accept it yet =)
06:07:50 <ski> (in e.g. the implementation of MetaML i've been playing with, this is *not* true .. there is a value of type `forall a. a' which only fails when you instantiate the type variable)
06:08:23 <w3rs> hi all. What name sould I choose for this function:
06:08:26 <w3rs> :t \f ref -> readIORef ref >>= f >>= writeIORef ref
06:08:27 <lambdabot> Not in scope: `readIORef'
06:08:27 <lambdabot> Not in scope: `writeIORef'
06:08:49 <byorgey> ski: hah! got it.  I was being silly before
06:08:55 <w3rs>  :: (a -> IO a) -> IORef a -> IO ()
06:08:59 <ski> but i'm arguing that `AllSum f g -> Either (All f) (All g)' ought to hold (at least in a weak admissability sense) in a parametric system
06:09:15 <byorgey> ski: yes, makes sense to me
06:09:29 <ski> @type \f ref -> Data.IORef.readIORef ref >>= f >>= Data.IORef.writeIORef ref
06:09:29 <lambdabot> forall a. (a -> IO a) -> GHC.IORef.IORef a -> IO ()
06:09:50 <ski> w3rs : `withIORef_'
06:09:52 <w3rs> ski, oh thanks
06:10:07 <ski> hm
06:10:17 <w3rs> it's like modify, but monadic
06:10:22 * ski actually reads the code
06:10:29 <ski> (as opposed to just the type)
06:10:30 <byorgey> withIORef_ implies to me that it would not modify the value of the IORef
06:10:45 <ski> yeah, i was mistaking `IO a' for `IO b'
06:11:11 <ski> @type Data.IORef.modifyIORef
06:11:11 <lambdabot> forall a. GHC.IORef.IORef a -> (a -> a) -> IO ()
06:12:01 <ski> w3rs : so some variant of `modifyIORef', i think
06:12:01 <w3rs> updateIORef ?  is there a common pattern for such functions? somewhere in lenses packages
06:12:34 <ski> though it might be better to have the argument order consistent with `modifyIORef'
06:12:55 <ski> w3rs : that could work -- i'm not sure if there's a good naming convention
06:13:42 <byorgey> the other argument order is also nice because you can write   updateIORef r $ \v -> do ...
06:13:59 <ski> yeah .. and partially apply to a specific reference
06:15:40 <ski>   ContT2 (updateIORef ref) :: ContT2 () a IO a  -|  ref :: IORef a  -- e.g.
06:15:48 <w3rs> thanks. I'll stick to curriable arguments order
06:22:37 * wli fails to block SIGABRT
06:24:31 <wli> installHandler isn't cutting it.
06:27:57 <ski>   noExcludedMiddle :: Not (AllSum Identity Not)
06:28:08 <ski> went ok
06:28:21 <ski> byorgey : wanna try that one ? :)
06:28:36 <byorgey> oh, interesting! sure, I'll try it
06:28:49 <ski> (it's not very hard. just fun to be able to code it)
06:29:21 <ski> koala_man : you can of course try too, if you care for it :)
06:29:49 <ski> (btw, `Not' is defined in the obvious way)
06:31:42 <koala_man> ski: I will, I just have to pretend to work for a bit
06:34:29 <byorgey> ski: done.
06:34:39 <byorgey> parametricity is rather powerful.
06:35:16 <byorgey> ski: am I right in assuming that this one also requires partiality-which-really-isn't-because-of-parametricity ?
06:35:34 <byorgey> That's how I did it and intuitively it seems like there's no other way.
06:37:03 <byorgey> I guess the strange thing here is that in a parametric system, forall a. Either a (Not a)  is a very strange proposition -- it is NOT what is usually meant by LEM.
06:37:50 <byorgey> it means "either everything is provable, or nothing is", which is obviously false (and easy to derive a contradiction from)
06:37:58 <ski> byorgey : yeah, i used `distAllSum', as previously defined
06:38:09 <ezyang> Sorry, what is LEM?
06:38:18 <ski> "law of excluded middle"
06:38:24 <ski> (which is really sortof a misnomer)
06:38:24 <ezyang> huh.
06:38:37 <ski> ezyang : `|- A \/ Not A'
06:39:11 <byorgey> ski: ah, right, for some reason I didn't think of using distAllSum, but that makes perfect sense
06:39:26 <ski> byorgey : your way is probably essentially the same
06:39:30 <byorgey> yes, it is
06:40:47 <byorgey> ski: thanks for the enlightening exercises =)
06:41:11 <ski> byorgey : yeah `forall a. Not (Either a (Not a))' is quite different from `Not (forall a. Either a (Not a))'
06:41:52 <byorgey> ah, right
06:41:54 <ski> `forall a. Not (Either a (Not a))' can't be provable in an intuitionistic system, because if it was, we'd get an inconsistency from that and `forall a. NotNot (Either a (Not a))', which *is* probably intuitionistically
06:42:05 <ski> s/probably/provable/
06:42:37 <ski> (so that is then a proof of `Not (forall a. Not (Either a (Not a)))' :)
06:43:07 <byorgey> heh, right =)
06:43:28 <ski>   factorM :: Functor f => f (All g) -> All (Comp f g)  -- hm, this is provable
06:43:34 <ski> s/M/F/
06:44:00 <ski> can we reverse this, maybe under more assumptions on `f' (and `g' as well ?) ?
06:45:15 <hpaste> wli annotated “http://pastebin.com/4TWaPKwg” with “http://pastebin.com/4TWaPKwg (annotation)” at http://hpaste.org/48501#a48503
06:45:15 <mauke> The paste 4TWaPKwg has been copied to http://hpaste.org/48501
06:45:51 <ski> ezyang : operationally, to the extent that it actually works, `LEM' isn't about excluding middles, but about excluding one or the other alternative in the disjunction (which therefore must be of the multiplicative kind)
06:45:53 <jaspervdj> tibbe: Er, do you have 5 minutes? I've got a little headache on lenient UTF-8 decoding?
06:46:01 <wli> This is having the problem that blocking SIGABRT isn't actually working.
06:47:36 <ski> (byorgey : btw, the "easy to derive a contradiction from" holds if we allow `distAllSum'-like parametricity on disjunctions .. not otherwise, i think)
06:48:12 <byorgey> ski: yes, that's what I meant
06:48:48 <byorgey> ski: The intuitive meaning I assigned to it, "either everything is provable or nothing is" only holds if we allow distAllSum
06:49:08 <ski> in Markov's School, `Not (forall a. Either a (Not a))' is provable because of Church's Thesis (every function is algorithmic)
06:50:04 <ski> in Brouwer's School, `Not (forall a. Either a (Not a))' is provable because of Bar induction (more or less that every function from infinite input to finite output can only depend on a finite part of the input, since it's computable)
06:50:26 <ski> note that Markov's and Browuer's schools are incompatible with each other
06:50:31 <tibbe> jaspervdj, sure
06:50:53 <byorgey> ski: interesting, I'll have to read more about this
06:51:12 <jaspervdj> tibbe: Well, when you use lenient decoding, invalid characters are replaced by � (0xFFFD), the unicode replacement character
06:51:30 <byorgey> ski: the reverse of factorF should hold if we restrict f to polynomial functors, since then we can "push the forall through" using distAllProd and distAllSum
06:51:45 <ski> so this parametricity result above might be a third incompatible way, i'm not sure
06:51:53 <jaspervdj> tibbe: The problem is, this is encoded as 3 UTF-8 bytes. So lenient decoding is very inefficient when there are invalid characters, because you have to resize the array
06:52:10 <ski> byorgey : yeah, i was pondering `Traversable f'
06:52:13 <tibbe> jaspervdj, right
06:52:28 <tibbe> jaspervdj, but we'd hope it's a rare occurrence
06:52:38 <jaspervdj> Yes, I guess
06:53:04 <jaspervdj> tibbe: But wouldn't it be dangerous for (d)dossing servers by using a worst case?
06:54:56 <ski> byorgey : btw, "Constructivism in Mathematics - An introduction - Volume I" by Anne Sjerp Troelstra and Dirk van Dalen talks about this about `Not (forall a. Either a (Not a))' in Markov's and Bishop's schools -- that's where i saw it
06:55:05 <Cale> Resize what array?
06:55:16 <byorgey> ski: ok, thanks for the reference
06:57:20 <tibbe> jaspervdj, but we double the allocation size each time so it shouldn't be particularly efficient
06:57:38 <tibbe> jaspervdj, the attacker can't make the attach take more than O(n) resources from the server
06:57:55 <tibbe> jaspervdj, and his connection will likely be dropped by the server if it looks suspicious
06:58:02 <tibbe> jaspervdj, don't worry about it at this level
06:58:30 <ski> the other intersting thing in Markov's school (apart from Church's Thesis, and consequences) is Markov's Principle : `MP : (P : A -> Bool) -> Not (forall a : A. P a == True) -> exists a : A. Not (P a == True)'
06:58:34 <jaspervdj> tibbe: ok :-)
06:59:00 <jaspervdj> tibbe: Then I'll go with a quick memcpy + a validation loop for decoding
06:59:13 <ski> in a more general intuitionistic sense, this shouldn't be interpreted as holding for every type `A', but only for certain types like `|N' and similar types, which admit a kind of unbounded search
07:00:48 <tibbe> jaspervdj, do you validate first or memcpy first?
07:00:58 <ski> Markov's rationale for the principle being that it is evident that if not every natural number satisfies a decidable property, then there is an algorithm for finding a natural number which fails to satisfy the propety : just try one natural number after the other, until you find the first failing one !
07:01:08 <tibbe> jaspervdj, you can definitely move the uncommon case out of the path of the common case
07:02:58 <jaspervdj> tibbe: I'm not sure what is most efficient yet
07:04:40 <linduxed> i'm looking through this book that is introducing me to the concept of Maybe and Just. the thing is that i'm unsure why i should use them. in this example it's obvious what it does http://pastie.org/2140010 . in this one however (which i've written and can't get to work) i have no understanding for how and why i should use it http://paste.pocoo.org/show/423651/
07:05:23 <quicksilver> linduxed: it doesn't work because "tail xs == null" is wrong.
07:05:26 <Cale> linduxed: Maybe is used whenever a value might or might not be available
07:05:27 <quicksilver> null is a function.
07:05:36 <quicksilver> you mean "null (tail xs)"
07:05:54 <Cale> You could also write:
07:06:00 <Cale> mySecond [x] = Nothing
07:06:11 <Cale> mySecond (x:y:xs) = Just y
07:07:27 <Cale> The idea is that in the case of a list of length 0 or 1, there is no second element, and so you want to represent that possibility somehow.
07:07:32 <ion> > let mySecond = listToMaybe . drop 1 in (mySecond [], mySecond [0], mySecond [0..42])
07:07:33 <lambdabot>   (Nothing,Nothing,Just 1)
07:07:46 <Cale> In the case where there is no second element, the function produces the value Nothing
07:08:00 <Cale> and when there is, it produces Just x, where x is the second element
07:09:45 <Cale> linduxed: Make sense?
07:10:50 <linduxed> Cale: processing....
07:10:57 <linduxed> quicksilver: oh i see
07:11:00 <Cale> > find isUpper "here is a string with no uppercase letters"
07:11:01 <lambdabot>   Nothing
07:11:18 <Cale> > find isUpper "here is a string with Some Uppercase Letters"
07:11:18 <lambdabot>   Just 'S'
07:12:13 <linduxed> Cale: ok i think i understand now
07:12:15 <ion> Are you perhaps familiar with SQL? It’s exactly the same concept as columns that may be NULL.
07:12:33 <linduxed> Cale: however... why do i need the "Just" thing?
07:12:42 <Cale> Because Nothing isn't a Char
07:13:04 <linduxed> Cale: i don't see why i just can't return xs instead of Just xs for instance
07:13:09 <Cale> and so whatever it produces in the case when it succeeds can't be directly a Char either
07:13:14 <tibbe> jaspervdj, that's the hard part :)
07:13:25 <Cale> (they obviously have to have the same type)
07:13:30 <ski> ion : except that SQL is confused about what `NULL' means ..
07:13:46 <ion> ski: SQL or some SQL implementations? (I don’t know which.)
07:13:48 <ski> (or at least it's traditionally used in a confused way)
07:13:50 <linduxed> OH NOW it hit me
07:14:10 <ski> ion : it could be either, i suppose. both are crazy
07:14:11 <linduxed> both Nothing and Just are of the type Maybe
07:14:17 <linduxed> so i can't return a
07:14:20 <ion> @src Maybe
07:14:21 <lambdabot> data Maybe a = Nothing | Just a
07:14:23 <Cale> Yeah, well, Nothing, and Just x for any x
07:14:27 <linduxed> becuase i specified to return a Maybe
07:14:31 <Cale> yeah
07:14:37 * linduxed is a fucking genius
07:14:38 <jaspervdj> tibbe: http://jaspervdj.be/tmp/decoding.markdown Something like that might work
07:14:40 <Cale> Nothing :: Maybe a
07:14:40 <linduxed> :-P
07:14:46 <Cale> Just :: a -> Maybe a
07:14:48 <quicksilver> ion: the standard is pretty weird. It's also true that not all implementations conform to the standard.
07:15:01 <ski> ion : `NULL' is sometimes used for "inapplicable", and sometimes for "unknown" .. and there's probably more uses as well
07:15:12 <quicksilver> ion: weirdness in the standard: "1 + NULL" is NULL, but "SUM({1,NULL})" is 1.
07:15:19 <linduxed> Cale: i might just have stepped a bit closer to functional programming right there
07:15:21 <ion> Heh
07:15:26 <linduxed> Cale: thx for the help
07:15:26 <quicksilver> the {} is pseudo-syntax but the meaning is hopefully clear.
07:15:30 <Cale> no problem
07:15:53 <aristid__> :t catMaybe
07:15:54 <lambdabot> Not in scope: `catMaybe'
07:15:56 <aristid__> :t catMaybes
07:15:57 <lambdabot> forall a. [Maybe a] -> [a]
07:16:04 <linduxed> btw, i take it that Maybe is a type built into Prelude?
07:16:09 <ion> yes
07:16:11 <ski> @index Maybe
07:16:11 <lambdabot> Data.Maybe, Prelude
07:16:19 <ski> @src Maybe
07:16:19 <lambdabot> data Maybe a = Nothing | Just a
07:16:22 <Cale> linduxed: yeah, it's just an ordinary datatype which is declared in the Prelude
07:16:32 <jaspervdj> tibbe: The otherwise case should allow insertion of longer replacement chars
07:16:43 <Cale> (It doesn't require any special compiler support)
07:16:56 <Cale> Same goes for Bool
07:17:17 <gwern> 'And of course I can't talk about performance without mentioning Haskell somewhere :-) I've taken Loitsch's library and written a Haskell interface, which I've measured to be 30 times faster than the default renderer used in the Haskell runtime libraries. This has some nice knock-on effects: my aeson JSON library is now 10 times faster at rendering big arrays of floating point numbers, for instance. I accidentally noticed in the course of that work ...
07:17:23 <gwern> ... that my Haskell text Unicode library's UTF-8 encoder wasn't as fast as it could be, so I improved its performance by about 50% along the way. Hooray for faster code!'
07:17:35 <tibbe> jaspervdj, that would be the gist of it yes. I'd have a look and see if any other programming languages use UTF-8 internally and see how they implement decode
07:17:44 <roconnor> hi gwern
07:20:16 <ski> (Cale : apart from guards, and to a lesser degree conditionals ..)
07:20:30 <Cale> Right
07:20:39 <jaspervdj> tibbe: OK
07:20:48 * hackagebot splot 0.2.1 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.2.1 (EugeneKirpichov)
07:24:08 <tibbe> jaspervdj, perhaps look in ICU
07:24:12 <tibbe> jaspervdj, or just try it out :)
07:24:48 * hackagebot GLFW-b 0.0.2.9 - GLFW bindings  http://hackage.haskell.org/package/GLFW-b-0.0.2.9 (BrianLewis)
07:29:43 <tibbe> jaspervdj, you can use tricks like testing 8 bytes of ASCII at once, until you either hit a non-ASCII character or you don't have 8 bytes left in the buffer
07:30:46 <ajnsit> I am trying to read the source of the Haskellers website trying to understand how Yesod works.. I came across this line - mkMessage "Haskellers" "messages" "en"
07:30:54 <ajnsit> the type of this expression is Q [Dec]
07:31:13 <ajnsit> What I don't understand is how it can be valid in the middle of the code all on its own
07:31:44 <jaspervdj> tibbe: good idea
07:32:01 <Cale> ajnsit: That's because splices in TH are now allowed to be without the surrounding $(...)
07:32:25 <quicksilver> Cale: weird. How do you recognise them then?
07:32:36 <quicksilver> that must be top-level if it's a Dec; is it only at the top level?
07:32:51 <Cale> I'm not sure of the details
07:33:21 <ion> AFAIR dropping the $() is only allowed in the top level.
07:33:33 <Cale> ajnsit: So the Q action there is run at compile time to generate a list of declarations which is spliced in at that point in the code.
07:33:46 <tibbe> jaspervdj, you'd read 8 (or 4) bytes as a Word from the ByteString
07:33:48 <ajnsit> okay that makes sense
07:34:08 <jaspervdj> tibbe: Yeah, and .&. that with a constant, right?
07:34:24 <ajnsit> it seems the more I go deeper into haskell the more black magic I uncover :)
07:34:26 <jaspervdj> tibbe: But I'll save these optimizations for later, first get a byte-per-byte version working
07:34:40 <Cale> Well, TH is kinda black magic by nature.
07:34:55 <Cale> (It's a macro system)
07:35:05 <quicksilver> ajnsit: TH isn't really part of haskell
07:35:37 <ajnsit> quicksilver, yes I understand
07:35:53 <ajnsit> but it's a standard part of GHC
07:36:17 <saml> ghc isn't standard
07:36:25 <saml> don't use it.
07:36:40 <tibbe> jaspervdj, http://hpaste.org/48504
07:36:44 <tibbe> jaspervdj, sure, get it working first
07:36:44 <ajnsit> saml, what's standard then?
07:37:05 <saml> haskell98
07:38:41 <ajnsit> saml, well that's only the language semantics.. Wouldn't you say that the Haskell Platform is closer to the idea of a "Programming Language standard"
07:38:58 <saml> sorry. you can use ghc. i allow
07:39:11 <ajnsit> saml, thank you
07:39:14 <quicksilver> ajnsit: saml was joking. Of course use GHC.
07:39:33 <quicksilver> and some kind of macro system is essential
07:39:40 <quicksilver> TH is not that nice tho :(
07:40:06 <ajnsit> quicksilver, yeah I am getting that
07:40:45 <saml> why macro system is essential?
07:41:04 <saml> do {}  isn't enough?
07:41:12 <saml> what does macro solve?
07:42:46 <yitz> saml: one important use is quasiquoters
07:42:50 <tibbe> jaspervdj, an 8-byte loop can be as much as 10x faster than a 1-byte loop
07:42:53 <quicksilver> repeated code.
07:43:02 <quicksilver> there are lots of places haskell can't abstract
07:43:09 <quicksilver> like creating multiple similar types
07:43:10 <ion> saml: You can’t generate, say, a data type without some kind of macros.
07:43:17 <yitz> saml: they let you define syntax that gets checked at compile time
07:43:21 <quicksilver> or creating new types based programatically on the structure of old types
07:43:27 <ajnsit> quicksilver, lots of places where haskell can't abstract *yet*
07:43:48 <quicksilver> ajnsit: well there are quite good reasons why the haskell core language can't do these things.
07:44:17 <quicksilver> it's hard to imagine a language which can create multiple new types based on an old type at compile type without it being, really, some kind of staged execution/macro system
07:44:31 <quicksilver> and if you have that, you might as well make the separation explicit.
07:44:40 <quicksilver> in many ways it would be nicer to have something a little more like metaml though
07:45:58 <tibbe> jaspervdj, I really recommend you look into some state-of-the-art validators eventually. They typically use some kind of state table approach.
07:46:03 <ajnsit> quicksilver, I'm sure some Haskeller someday will find some mathematically rooted abstraction that just perfectly fits those cases
07:46:51 <ajnsit> when I started out with Haskell I was suprised at the difficulty of defining functions that take variable number of arguments.. Then I discovered Applicative
07:47:15 <ajnsit> I still find all this Category theory to be black magic
07:47:40 <ajnsit> sure when you work out the types on a piece of paper it works but I still can't wrap my head around it.. not really
07:49:45 <jaspervdj> tibbe: I will, I suppose there's plenty of material out there
07:49:54 <jaspervdj> gotta go afk now, be back later
07:53:57 <tibbe> jaspervdj, ok, ttyl
07:56:50 <ski> Cale : i'd prefer if dropping splices were not allowed at all ..
07:57:54 <quicksilver> the best way would be to program your editor to hide the $( ... )
07:57:55 <ski> (i.e. if you want to provide macros as opposed to just splice and unsplice, provide macros for real (possibly with restrictions), don't pretend staging is macros)
07:58:09 <quicksilver> but, instead display them in Fraktur font
07:58:43 <ski> hehe
07:59:21 * ski likes how Frege talks about German and Latin variables ..
07:59:46 <quicksilver> ski: what would your preferred staging/macros system for a haskell-like language be?
07:59:58 <quicksilver> I liked the presentations I saw on metaml but I've never tried to use it.
08:02:54 <ski> the MetaML / MetaOCaml system is very nice. it statically checks that your code-generating functions can only generate type-correct code
08:03:25 <ski> if you need dynamically-type-checked code generation, they support that as well
08:03:26 * quicksilver nods
08:03:35 <ski> but they're not macro systems
08:03:41 <quicksilver> well, SPJ has definitely said they're going towards typed splices
08:03:55 <quicksilver> (optionally typed, IIRC)
08:04:16 <zygoloid> there's a heavily-cc'd bug which requests less type-checking of slices too :)
08:04:18 <quicksilver> ski: so what does a macro system need to be able to do?
08:05:06 <ski> wrt binding, the MetaML / MetaOCaml system is nicer than quotation and unquotation in Lisps
08:05:40 <ski> Lisps treat quoted expressions with local variables as just a nested list of symbols
08:06:20 <ski> (btw, the `syntax-case' and similar systems in Scheme are better in this regard, so that above only apply to the traditional `quasiquote' and `unquote')
08:06:31 <dankna> typed splices would be nice
08:06:37 <zygoloid> i've seen three different models requested: 1) no typechecking until splice-time, 2) only reject quotations which cannot be spliced, 3) perform all typechecking that you can early
08:06:49 <zygoloid> they all have use-cases, and ghc currently supports none of them
08:06:54 <zygoloid> (or rather, a mixture of them)
08:07:47 <ski> quicksilver : going from `$(fooGenerator [|blah|])' to `fooMacro blah' is basically the difference between staging and macros, afaiui
08:08:13 <Enigmagic> i just want pattern splices :|
08:08:25 <ski> yeah, that
08:08:49 <zygoloid> i want to be able to use top-level decls from the same module in my splices :)
08:09:10 <ski> quicksilver : also, a macro system worth its salt should allow you to define your own macros which bind variables, (and it should be hygienic, when it does this)
08:09:12 <zygoloid> (but i don't want all the downsides which are a necessary consequence of that)
08:09:18 <benmachine> I wish there was a nicer thing that did the job of cpp
08:09:23 <dankna> I just want to understand to what extent we already have quasiquoting, and how to use it :(
08:10:37 <benmachine> it annoys me how order of things in the file is relevant to TH, even though I don't see how it could be any other way
08:10:42 <kmc> benmachine, yes!  sometimes TH is way too cumbersome and you just want to copy some boilerplate
08:10:49 <kmc> but CPP is annoying for that
08:10:52 <benmachine> yes
08:11:08 <dankna> speaking of preprocessors, have people been following the thread on ghc-cvs where we are talking about moving to Clang on OS X?
08:11:11 <benmachine> but also I was thinking conditional compilation
08:11:33 <ski> quicksilver : so e.g. one should be able to see `\<pat> -> <expr>' as basically syntactic sugar over a syntax/macro `lambdaStx <pat> <expr>', being equivalent to `$(mkLambda [pat|<expr>|] [expr|<expr>])'
08:12:10 <kmc> dankna, for what? -fvia-C? building the RTS?
08:12:39 <dankna> building the entire compiler.  we have little choice, because a little birdie informed us that gcc is on its way out.
08:12:53 <monochrom> yikes
08:12:55 <dankna> yeah
08:13:13 <dankna> there are probably ways we could kludge it into still using gcc but it would be very messy and Clang is the future anyway
08:13:19 <monochrom> but gcc has always been "out" in windows anyway
08:13:38 <dankna> well, yeah
08:13:45 <zygoloid> clang is the future on every platform</shameless promotion>
08:13:58 <benmachine> gcc is on its way out?
08:14:24 <int-e> seems doubtful
08:14:31 <benmachine> surely it's far too large to die
08:14:55 <monochrom> oh, llvm? then fine with me
08:15:00 <zygoloid> you think it'll receive government bailouts?
08:15:28 <monochrom> it receives FSF bailouts. same difference :)
08:15:41 <nus> heh, seems like there'd be mingw for osx... MinGX ?-)
08:16:07 <edon> if you know that f^n x `op` y = x `op` (g^n y) , how do you prove using equational reasoning that the same holds for n+1 (the induction case), where f^n x = (!! n) $ iterate f x
08:17:10 <dankna> anyway, the reason I mentioned this is that one solution that came up was to make a "cpp" but with knowledge of Haskell's token-level syntax
08:17:28 <dankna> another solution was to reword the few places where our syntax trigger's Clang cpp's error messages to not do that :)
08:17:37 <int-e> benmachine: my thought exactly. and there are people who will be unwilling to contribute to a BSD licensed project. of course it's well possible that we will no longer see so many (gcc based) free or open source compilers for the various embedded platforms. is that good? I dunno.
08:17:41 <quicksilver> ski: ok but to me that doesn't really seem different from splicing, it's just different (meta) syntax
08:17:46 <dankna> we're probably going with the latter, but some people have expressed interest in doing it the right way, and I'm willing to do the work if we really need it
08:18:07 <dankna> imo if people are unwilling to contribute to a BSD project we can live without them
08:18:15 <dankna> I'm unwilling to contribute to a GPL project, so ^^'
08:18:48 <Enigmagic> int-e: there are certainly a lot of llvm based compilers for embedded platforms
08:18:55 <monochrom> I have to know more than "f^n x `op` y = x `op` (g^n y)". I have to know: "for all x, f^n x `op` y = x `op` (g^n y)".
08:18:57 <ski> quicksilver : doing DSL, it's less ugly to have macros (typically with binders), than having to splice and unsplice all the time
08:18:57 <quicksilver> dankna: "building the entire compiler"
08:19:09 <quicksilver> dankna: but, GCC is not used that much to build GHC is it?
08:19:22 <quicksilver> ski: OK, I see.
08:19:25 <dankna> quicksilver: well, ghc saves a reference internally to the cc it was built with and uses it as the linker when compiling Haskell and mixed-language programs
08:19:29 <monochrom> so that I can deduce: "f^n (f x) `op` y = f x `op` (g^n y)"
08:19:44 <quicksilver> dankna: OK, but that's technically using the linker.
08:20:03 <dankna> quicksilver: you're right of course, but it's not a clean distinction as things stand, though it could be made to be
08:20:04 <ski> quicksilver : effectively, macros let you extend the base constructions, so that them and your extensions are on a more equal footing
08:20:10 <monochrom> and then hopefully you can further go f x `op` (g^n y) = x `op` g (g^n y)
08:20:10 <quicksilver> and ghc does have some hooks to subcontract C code to a C compiler.
08:20:17 <edon> monochrom: yes, i didn't state it correctly, prepend for all x to it
08:20:42 <quicksilver> ski: yes that makes sense. Although my sense of hygiene actually quite likes the inequality sometimes.
08:21:13 <ski> quicksilver : well, macros should be hygienic in most cases
08:21:24 <Martty> hygienic but NSFW
08:21:27 <ski> (i'm not sure what sense you have of "hygiene" here, though)
08:21:53 * ski was talking about the sense in which `syntax-rules', but not `defmacro', is hygienic, in the Lisp world
08:22:25 <ski> (and hygiene here more or less means that macros respect static/lexical scope)
08:24:02 <ski> with hygiene : (a) using a macro `foo', `let x = .. in foo (..x..)' the occurances of `x' in `..x..' refers to the `x' bound by the `let'
08:27:05 <ski> so with hygiene, defining a macro `foo' so that `foo <expr>' expands to `let x = ... in ..y..(<expr>)..' any occurances of `x' in `foo <expr>' will *not* refer to the `x' in the expansion of the macro. additionally (b), `y' in expansions of the macro will refer to the `y' which was in scope where the macro was defined, not the `y' which is in scope where it is used, regardless of whether `y' was exported from the module defining the macro or no
08:27:09 <koala_man> could someone name another language where the type system can prevent nulls and side effects?
08:27:28 <quicksilver> ski: I meat I like a clear syntactic separation between core language constructs and custom macros.
08:27:41 <JuanDaugherty> do you now?
08:27:42 <ski> koala_man : Clean,Mercury,Agda,Coq ?
08:27:53 <quicksilver> ski: however, this distrust of macros may be based on bad experiences of poor macro systems.
08:28:04 <koala_man> great, thanks!
08:28:04 <quicksilver> ski: maybe an elegant hygienic one would convince me otherwise
08:28:37 <rtharper> one does not often here "elegant" and "hygienic" attributed to the same thing at the same time
08:28:38 <JuanDaugherty> *elegant hygienic meat*
08:28:39 <rtharper> *hear
08:28:44 <ski> quicksilver : yeah, in some cases it's important to know what are core constructions -- e.g. if you want to induct on them (i.e. analyze (and usually translate) expressions)
08:29:24 <ski> quicksilver : i think most/many macro uses only construct code, though, not take it apart, and then it doesn't matter very much
08:31:16 <ski> but yes, text macros like CPP are bad : too weak and not hygienic. traditional lisp macros are powerful, but not hygienic
08:32:02 <ski> i don't have much experience with Camlp4, so i can't comment much on that, though i've heard lispers complain about it
08:33:47 <rtharper> why are you still talking about hygiene
08:33:47 * rtharper is concerned.
08:34:02 <JuanDaugherty> it's a fixation
08:34:13 <JuanDaugherty> with The Clean
08:34:15 <ski> rtharper : if your macros aren't, you ought to be !
08:34:29 * rtharper is macroless, except in LaTeX.
08:34:39 <kmc> i think it's important to have *a* mechanism for non-hygenic macros
08:36:11 <nus> doomed to manual gensym'imng
08:36:17 <ski> that could be true. hygiene should be the default, though
08:37:14 <nus> ski, it'd cover most cases
08:37:17 <kmc> i'd rather write true metaprograms instead of using some syntax rules DSL, though
08:37:21 <ski> (nus : well, and inable to express the (b) case above)
08:37:36 <ski> hygienic macros /= `syntax-rules'
08:38:20 <ski> kmc : you can use e.g. `syntax-case' to write (hygienic per default) meta-programs in scheme
08:38:32 <nus> kmc, *true metaprograms*? what's that?
08:38:44 <ski> (as opposed to in a DSL like `syntax-rules')
08:40:31 <kmc> nus, if I'm writing macros in Scheme then I want them to be Scheme programs that produce Scheme programs, not some other restricted thing that produces Scheme programs
08:41:03 <kmc> most attempts at the latter end up with cumbersome flaws that people have to work around
08:41:09 <ski> kmc : so use `syntax-case' or explicit-renaming, or any of the other variants i can't recall the name of
08:41:11 <kmc> see: C preprocessor, C++ templates
08:41:18 <kmc> yeah, i don't know how syntax-case works
08:41:38 <ski> it's basically pattern-matching on syntax objects
08:48:53 <fasta> Given a program or source code, how do I get all the cabal packages that it needs?
08:49:28 <fasta> (GHC knows this, because it can build the program)
08:49:56 <nus> fasta, is a .cabal file somewhere around?
08:50:26 <fasta> nus: no.
08:50:38 <dcoutts> fasta: I guess you could load it in ghci and see what packages it loads. Those are the ones you need to list in the .cabal file.
08:51:17 <kmc> you can also use ghc -v --make
08:51:21 <kmc> and look at the linker command line
08:57:34 <hpaste> o1iver pasted “Lexer” at http://hpaste.org/48506
08:57:38 <o1iver> Hi everyone. I have written a simple lexer (as part of a bigger project) and just changed it from the original version to do some error handling. I was wondering if someone could have a quick look (its only 38 lines) and see if using Either that way is appropriate... Thank you!
08:59:24 <benmachine> o1iver: looks reasonable enough. why does UnknownCharacter take a String rather than a Char?
09:00:34 <fasta> dcoutts: that doesn't list bytestring for example.
09:00:48 <o1iver> benmachine: yeah I wasnt sure about that, but I put it as String, in case I would rather specifiy why exactly it is invalid (but I agree the constructor UnknownCharacter should really have a Char)
09:01:17 <dcoutts> fasta: then it's not used
09:01:40 <tibbe> jaspervdj, I think we'll have to stream straight out of the ByteString if it validates
09:01:57 <tibbe> jaspervdj, as copying it to a Text and then streaming it (using stream fusion) will add an extra copy
09:02:16 <dcoutts> fasta: note of course that what ghci loads is all the needed packages, they may only be used indirectly, and not imported from directly.
09:02:26 <dcoutts> so you don't necessarily have to list all the packages ghci loads
09:02:35 <o1iver> benmachine: the thing I am not sure about currently is wheter returning [Either LexerError Character] is better than returning Either LexerError [Character] (and then just have some more general error message)...?
09:02:46 <o1iver> *whether
09:03:06 <benmachine> o1iver: well, that depends a little on how you use it
09:03:18 <benmachine> o1iver: but note that you can turn the former into the latter fairly easily
09:03:37 <tibbe> dcoutts: I have this algorithm for fast validation of UTF-8 data, but I can't figure out how to adapt it to fusion (which is used in Text). The problem is that the algorithm validates 8 bytes at the time and I'm not sure how to combine that with fusion.
09:03:41 <tibbe> dcoutts: any ideas?
09:03:57 <tibbe> dcoutts: the difference in validation performance is almost 10x
09:04:05 <o1iver> benmachine: yes that is true. I guess that it comes down to *how* you display errors ("invalid chars in str" vs. "invalid chars: c1 c2 c3")
09:04:27 <benmachine> o1iver: mm. are errors likely to cascade?
09:04:38 <benmachine> that would possibly make reporting all of them unhelpful
09:04:50 <dcoutts> tibbe: so you want to write a fusible ByteString -> Text function right?
09:04:53 <benmachine> but actually, how often are you going to get a lexer error
09:05:01 <tibbe> dcoutts: I sometimes wonder if stream fusion is worth it; working on Text rarely involves long pipelines and lots of functions on Text can't fuse. Fusion also adds overheads in cases like this one.
09:05:02 <benmachine> surely only really when someone's accidentally fed you completely the wrong sort of file?
09:05:09 <benmachine> or something
09:05:09 <tibbe> dcoutts: yes
09:05:20 <dcoutts> tibbe: yeah, I wonder about that too sometimes
09:05:25 <benmachine> so I'd be inclined only to bother reporting the first error
09:05:47 <o1iver> benmachine: that is exactly the thing I am still struggling (in the sense: haven't figured out how to do it nicely) yet... the application does: computation . parse . lex and I have to figure out how to handle the errors nicely in all cases
09:05:58 <tibbe> dcoutts: we could perhaps speed up decodeUtf8 5x using this, which feels like it would be more than fusion would buy us.
09:06:00 <dcoutts> tibbe: so if you can write the algorithm as Stream Word8 -> Stream Char then you're done
09:06:06 <benmachine> o1iver: throw monads at the problem until it goes away
09:06:09 <o1iver> benmachine: input is from a web form, so I guess errors may be very common
09:06:09 <tibbe> dcoutts: that's the crux
09:06:32 <dcoutts> tibbe: but if you need to read from an in-memory bytestring, not a stream, then you'll have to write ByteString -> Stream Char
09:06:51 <tibbe> dcoutts: right, I'm not sure how to do that though
09:06:52 <o1iver> benmachine: last night I was using Maybe in the lexer, a custom error Monad in the parser and Either in the final computation, so thats why I am reworking it
09:06:55 <dcoutts> tibbe: which means it will not fuse on the consumer side
09:07:02 <dcoutts> but still on the producer side
09:07:04 <o1iver> o1iver: got a bit out of hand :-p
09:07:10 <tibbe> dcoutts: perhaps do a single validation pass over the whole ByteString and then stream if from the beginning
09:07:30 <benmachine> o1iver: psh, that doesn't sound too bad :P
09:07:33 <dcoutts> tibbe: presumably you can validate incrementally, no?
09:07:46 * benmachine shrugs
09:07:46 <tibbe> dcoutts: would decodeUtf8 by itself fuse so only one Text gets allocated?
09:07:55 <tibbe> dcoutts: yes, at 8 byte at the time
09:08:02 <littlebobby> wli, yesterday you stated "Instruction selection and register allocation are not trivial", was this only in regards to c++ or is this a general fact? I have no experience with compilers as you might have noticed.
09:08:13 <dankna> it's a general fact
09:08:36 <o1iver> benmachine: well the (maybe utopian) idea is that in the end, I use the same error handling monad in all the parts of the application and can thus just chain all the functions together and get something like Either out...
09:08:46 <dankna> they're the heart of any compiler, where by heart I mean the only part I don't feel competent to mess with :)
09:08:48 <dcoutts> tibbe: ah, so the algorithm doesn't natively produce chars as the output unit
09:08:56 <littlebobby> dankna, ok thanks :-)
09:08:59 <dankna> np
09:09:06 <benmachine> o1iver: well, that ought not to be too hard, but I never have much problem mixing my monads
09:09:19 <tibbe> dcoutts: no, it essentially returns Bool (or the number of valid characters)
09:09:26 <dcoutts> tibbe: ah so it's a validation that doesn't also decode
09:09:28 <dankna> mixed monads and mixed drinks? there has to be some sort of gag there
09:09:32 <tibbe> dcoutts: rights
09:09:41 <tibbe> dcoutts: we could have it decode as well I guess
09:09:49 <benmachine> o1iver: it's nice to use Maybe when you don't need Either so that people can see there's only one kind of error
09:09:50 <hpaste> o1iver pasted “monad-mix” at http://hpaste.org/48507
09:09:53 <dcoutts> tibbe: so what kind of function do you want to write? will it just throw pure error, so will it be ByteString -> Text ?
09:09:59 <tibbe> dcoutts: but it would still consume say 8 bytes and produce 8 Chars at the time
09:10:01 <littlebobby> there really are 10-100x more things I'd like to read than I can make time for. the ml-compiler book is on my long-term list
09:10:11 <benmachine> o1iver: 'either' and 'maybe' make the transitions not too painful
09:10:20 <benmachine> :t either (const Nothing) Just
09:10:21 <lambdabot> forall a a1. Either a1 a -> Maybe a
09:10:26 <tibbe> dcoutts: it will switch to a slower loop in case of invalid Chars (and replace them using the replacement char)
09:10:29 <o1iver> benmachine: see the paste... thats what my parse + lex function looked like, and that just doesnt look nice
09:10:32 <dcoutts> tibbe: yes, that will be more interesting to stream, because it's got this 8 byte buffer, which does not correspond to a fixed number of chars
09:10:41 <dankna> littlebobby: I know the feeling!  Do you mean Andrew Appel's _Modern Compiler Implementation in ML_?  That's a good one.
09:10:42 <dcoutts> tibbe: it'll have to use a little state machine style
09:10:47 <tibbe> dcoutts: the validation function is highly optimized for common patterns (like mostly ASCII data)
09:11:02 <littlebobby> dankna, indeed that's the one. and it would be an excuse to learn yet another PL
09:11:05 * dankna nods
09:11:06 <benmachine> o1iver: conceded, that could be prettier
09:11:14 <tibbe> dcoutts: actually, if it manages to validate 8 bytes that are known to be ASCII it could output 8 Chars
09:11:30 <littlebobby> dankna, "the haskell road to logic, math and programming" which I've recently started reading is my excuse to learn haskell
09:11:38 <dankna> ah, nice!
09:11:39 <o1iver> benmachine: yeah, thats why I am going through everything step by step again :-) (first time using monads, so might as well learn it right from the start)...
09:11:45 <tibbe> dcoutts: essentially the algorithm has several fast/slow paths for ASCII/non-ASCII that consume 1 or 8 bytes or the time
09:11:45 <dankna> not familiar with it, but it sounds like a good thing
09:11:51 <dcoutts> tibbe: if one is decoding too, is there still a performance advantage? You'd be saving at most one comparison per char right?
09:12:07 <o1iver> But ok, thanks. I will leaver the lexer like this and then have a look at the parser now. Thanks for the help!
09:12:27 <benmachine> o1iver: np :) good luck
09:12:29 <littlebobby> dankna, it's great so far. I does only expects secondary school math and maybe programming knowledge as a prerequisite
09:12:32 <tibbe> dcoutts: you can validate 8 ASCII chars at once by reading a 64 bit word and and-ing it with some value
09:12:39 <o1iver> benmachine: thanks
09:12:47 <littlebobby> it only expects... sorry :-)
09:13:23 <rtharper> dcoutts, tibbe: If you don't use stream fusion for decoding, as you said, don't you still have to decode to edit?
09:13:31 <kmc> littlebobby, register allocation involves assigning registers from a fixed set to each of arbitrary number of variables, such that no two variables live at the same time share the same register
09:13:35 <dankna> littlebobby: np.  sounds nice!
09:13:43 <rtharper> You'd have to look at the core, but I don't think there's any additional inherent overhead to using streams
09:13:57 <kmc> i.e., assigning colors from a fixed set to each of arbitrary number of nodes in a graph, such that no two nodes which share an edge have the same color
09:14:05 <kmc> which is a classic NP-complete problem
09:14:17 <tibbe> dcoutts: rtharper: validation of ASCII looks like: indexWord32 src 0 .|. indexWord32 src 4 == 0
09:14:28 <nniro> y :)
09:14:30 <tibbe> validates 8 ascii chars
09:14:48 <rtharper> tibbe: validation is fine, but what about when you want to actually do something with the text?
09:14:59 <kmc> littlebobby, as for instruction selection, a modern processor has dozens of ways to accomplish any particular operation
09:15:03 <littlebobby> kmc, I suppose then, that if you have only pure functions that it cuts down complexity by quite a bit?
09:15:13 <tibbe> rtharper, then you need to copy (as per usual)
09:15:31 <littlebobby> kmc, interesting, thanks
09:15:42 <kmc> which of these is actually fastest will depend on the particular CPU model, the surrounding code, etc.
09:15:50 <tibbe> rtharper, if you need to edit you will need one copy in the end
09:15:54 <ski> o1iver : hrm, why  (\cs' -> ..cs'..) cs  instead of simply  ..cs..  ?
09:15:59 <tibbe> rtharper, e.g. word . decodeUtf8
09:16:00 <kmc> that's why gcc wants to know if you have a Core 2 or an Athlon or a VIA C3 for producing the fastest code
09:16:06 <littlebobby> indeed
09:16:16 <tibbe> rtharper, take the common example of splitting a string into words and inserting the words in a map
09:16:25 <rtharper> tibbe: so you want I/O to do no decoding, only validation
09:16:52 <rtharper> that makes sense, esp if you are reading in UTF-8 into a UTF-8 array
09:16:52 <tibbe> rtharper, once we have validated we can either 1) stream or 2) cast the value to a Text (if text is switched to UTF8)
09:17:13 <tibbe> rtharper, right, once we have read the thing into a buffer and validated we're done
09:17:26 <tibbe> rtharper, with UTF-16 backed Text it doesn't make much sense
09:17:27 <dcoutts> tibbe: yes, this makes most sense if the Text internal rep is UTF8
09:17:36 <rtharper> yeah
09:17:36 <tibbe> dcoutts: so that's what's jaspervdj is doing.
09:17:50 <kmc> littlebobby, most compilers go through a static-single-assignment intermediate form
09:17:51 <dcoutts> otherwise it's hard to see how we can save much when we have to decode anyway
09:17:56 <kmc> even if the language they're compiling has mutable variables
09:17:56 <tibbe> i suspect most of the time working with Text today is in decoding
09:18:18 <tibbe> an 8 byte loop it literally 10x faster than byte-by-byte validation
09:18:26 <kmc> littlebobby, you still have a non-trivial register allocation problem
09:18:37 <tibbe> dcoutts: decoding something that's valid is typically faster too
09:18:53 <tibbe> dcoutts: right now we do 1-byte interleaved validation/decoding
09:18:59 <dcoutts> tibbe: yes, Text already makes that assumption iirc
09:19:19 <dcoutts> tibbe: validation is easy if you're also decoding
09:19:20 <kmc> bbbl, work
09:19:22 <o1iver> ski: I didn't actually think I could do it that way, but I wonder myself now! Thanks for pointing it out...
09:19:39 <tibbe> dcoutts: but not fast
09:19:41 <dcoutts> tibbe: if I recall, assuming the encoding is valid only saves you one comparison when decoding
09:21:59 <ski> o1iver : `containsUnknown (Ok (XString ts)) = (not . null) [() | TUnknown <- ts]' is a bit simpler, imo
09:22:38 <tibbe> dcoutts: you can also check several bytes as once when decoding
09:22:50 <dcoutts> tibbe: really? I've never seen that
09:23:04 <ski> o1iver : also, i'd move the pattern-matching in `containsUnknown' to `checkUnknown'
09:23:08 <tibbe> dcoutts: read one word, mask, and then you might hold 8 ASCII chars
09:23:22 <dcoutts> tibbe: ah, special casing for ascii
09:23:42 <tibbe> dcoutts: yes, UTF-8 is overwhelmingly ASCII if you look at real data
09:24:03 <tibbe> dcoutts: this whole argument is based on the fact that input data follows certain patterns. Perhaps I should have said that up front.
09:24:18 <tibbe> so read a word and & 0x8080808080808080L
09:24:30 <tibbe> then you know you have 8 ASCII chars
09:24:36 <tibbe> that we can stream
09:24:54 <o1iver> ski: the strange one line let .. in is because I first tried to pattern match on multiple patterns in a lambda, and that didnt work so I got this as an option from someone here. But the list comprehension look nice (alhtough I haven't used a single one yet)...
09:25:08 <tibbe> dcoutts: I guess we could stick those 8 chars in the stream state somehow
09:25:18 <dcoutts> yes, that's possible
09:25:35 <o1iver> ski: I am actually reworking this whole thing from the bottom up, using a custom error handling Monad (the same for both the lexer and the parser)
09:25:36 <tibbe> dcoutts: having to stream a Char at the time makes it a bit tricky and I don't know if the overhead of state management will kill any benefit
09:25:40 <ski> o1iver : list comprehensions are nice in that match failures in generators will just "fail the list", instead of generating an error
09:26:20 <dcoutts> tibbe: in theory (according to my thesis :-) ) it's pretty efficient
09:26:41 <o1iver> ski: yes, I am realizing, that "error" is an evil thing in haskell :-p
09:27:06 <tibbe> dcoutts: I should try it out
09:27:22 <ski> o1iver : yeah, as much as possible, try to not use or rely on partiality, since it requires I/O to be caught
09:27:55 <ski> o1iver : in specific domains, use `Maybe' or lists or `Either error', or your custom error/exception datatype
09:28:19 <o1iver> ski: yes that is exactly the thing I realized last night. I thought I would just let the parser throw errors and then catch them, but then realized that they can only be caught in the IO monad, which I didn't like
09:28:55 <o1iver> ski: thats what I am doing right, now, either Either (;-)), Maybe or some custom datatype
09:29:57 <tibbe> dcoutts: I think I'll try to add a fast decodeUtf8 to text
09:30:32 <dcoutts> tibbe: ok
09:32:39 <fxr> connect bot is cool
09:33:19 <tibbe> dcoutts: yielding many things seems almost like the opposite problem of yielding nothing (for which we have a specific constructor)
09:33:33 <fxr> but i need an emacs compatible keylayout for the android i guess
09:33:36 <dcoutts> tibbe: you just need to maintain internal state
09:33:54 <dcoutts> tibbe: and these extra states get eliminated (if you follow the rules)
09:34:11 <dcoutts> rather, the dynamic data allocation associated with the extra states gets eliminated
09:34:18 <dcoutts> turned back into control flow state
09:35:36 <tibbe> dcoutts: so I need to change the state from 'index' to 'validChars,index'
09:35:51 <tibbe> dcoutts: and then I skip validate until validChars i 0 again
09:36:12 * hackagebot bindings-svm 0.2.0 - Low level bindings to libsvm.  http://hackage.haskell.org/package/bindings-svm-0.2.0 (PauloTanimoto)
09:37:42 <dcoutts> tibbe: the data that gets eliminated corresponds to constructors in the state type
09:38:02 <dcoutts> tibbe: data in fields in constructors does not get eliminated
09:38:57 <tibbe> dcoutts: but turned into parameters to the constructor specialized functions?
09:39:17 <dcoutts> tibbe: right
09:40:30 * ski wonders whether dcoutts is talking about some extension or pragma, or just optimizations
09:40:32 <bgamari> Is there any way to get the compiler to never permanently construct a list (i.e. always recompute its elements)?
09:40:45 <dcoutts> ski: just stream fusion optimisation
09:40:55 <ski> ok
09:41:23 <ski> bgamari : you could represent it in Church form ..
09:41:39 <kmc> bgamari, you can usually manage that with a dummy argument
09:42:04 <kmc> this is one of the few applications of functions of type () -> A
09:42:17 <kmc> i'm not sure if GHC guarantees that it *won't* perform the relevant optimization, though
09:42:45 <kmc> bgamari, what's the context for you wanting to do this?
09:42:49 <dcoutts> kmc: ghc tries not to increase or decrease sharing
09:42:53 <bgamari> ski: reading
09:43:16 <ski> bgamari : i.e. represent `[a]' as `forall r. (a -> r -> r) -> r -> r'
09:43:38 <bgamari> kmc: I have a list of times, I want to shift them in time and pass them to a function which will iterate over them several times
09:43:50 <kmc> > let fibs () = 0 : 1 : zipWith (+) fibs (tail fibs) in (take 5 $ fibs (), take 5 $ fibs ())
09:43:51 <lambdabot>   Couldn't match expected type `[a]' against inferred type `() -> t'
09:43:55 <kmc> bleh
09:44:07 <kmc> bgamari, why does it matter how many times the list is recomputed?
09:44:24 <bgamari> kmc: The list is large enough where it's far preferred to simply perform the subtraction multiple times than hold multiple copies of the list
09:44:59 <kmc> oh, so you want to not store the intermediate list?
09:45:06 <bgamari> kmc: Right
09:45:36 <kmc> that's interesting... sort of the thing fusion is used for, but i don't think it's applicable here, because you do have this time/space tradeoff
09:45:55 <bgamari> That is right
09:46:08 <kmc> yeah, what ski said is probably the way to go
09:46:08 <bgamari> I saw Data.Vector, but it doesn't look quite applicable
09:46:08 <ClaudiusMaximus> bgamari: i worked around that space leak once using something like [ x + y | x <- [1 .. 1000000], y <- [x+1-x {- hack to prevent this list being kept in memory -} .. 1000000] ]
09:46:17 <kmc> some kind of functional form
09:46:42 <d7> ClaudiusMaximus: How does that prevent the list from being kept in memory?
09:46:48 <kmc> in fact the Stream type from fusion would be useful
09:46:51 <d7> Oh, that reminds me
09:46:53 <ClaudiusMaximus> d7: because of the data dependency on x
09:47:01 <d7> ClaudiusMaximus: Ah
09:47:15 <ion> How pretty
09:47:33 <ClaudiusMaximus> d7: of course, a sufficiently magic compiler might notice that x + k - x = k  forall x for that particular Num instance
09:47:48 <kmc> i wonder how to construct a hard "optimization barrier" for GHC
09:48:06 <kmc> maybe a foreign call
09:48:07 <d7> So... I was reading more about comonads this morning. I was wondering... is there more than one valid comonad behavior for lists, like the way there is more than one valid way to interpret monadic computations for lists?
09:48:14 <bgamari> kmc: I see what you mean about Stream
09:48:24 <kmc> in gcc you sometimes inhibit optimizations with:  asm volatile("");
09:48:46 <rtharper> d7: Well, since a monad is defined by the monad laws, as long as you can satisfy them...
09:49:51 <ski> d7 : `[]' isn't a comonad
09:50:04 <kmc> it would be nice to have a function which is equivalent to 'id' but is opaque to the compiler until late codegen phase
09:50:17 <bgamari> kmc: It would
09:50:23 <rtharper> kmc: use an 'id' with NOLINE?
09:50:25 <kmc> may already exist
09:50:32 <rtharper> *NOINLINE
09:50:39 <kmc> rtharper, i'm not confident that NOINLINE will prevent *all* knowledge propagation
09:50:55 <rtharper> no, it won't, but what do you want to hide? =)
09:50:56 <kmc> it knows that 'id' is strict, even if it's not inlined
09:51:02 <rtharper> ah, I see
09:51:02 <rtharper> yes
09:51:13 <rtharper> well, the type sort of tells you that
09:51:36 <rtharper> isn't any function forall a. a -> a going to be strict?
09:51:38 <d7> ski: I was reading a little thing on comonads that used lists?
09:51:41 <kmc> rtharper, i think so
09:51:51 <rudyl313> how can I read values so that if the parse succeeds I get "Just a" and if it fails I get "Nothing" (as opposed to getting a runtime exception)?
09:51:53 <kmc> you can come up with a slightly less trivial exmaple though
09:51:57 <kmc> rudyl313, reads
09:52:06 <kmc> :t reads
09:52:07 <kmc> > reads "123abc" :: [(Int,String)]
09:52:07 <lambdabot> forall a. (Read a) => String -> [(a, String)]
09:52:08 <lambdabot>   [(123,"abc")]
09:52:09 <rudyl313> kmc: thanks
09:52:22 <ski> d7 : streams, as well non-empty lists form comonads
09:52:31 <d7> ski: Ah. Okay.
09:52:35 <kmc> wish we had a std lib name for «\x -> case reads x of [(v,"")] -> Just v; _ -> Nothing»
09:52:37 <ion> > case (reads :: ReadS Integer) "42" of (n, ""):_ -> Just n; _ -> Nothing
09:52:38 <lambdabot>   Just 42
09:52:39 <rtharper> isn't stream isomorphic to nonempty list?
09:52:42 <rtharper> oh, wait
09:52:43 <rtharper> no
09:52:44 <rtharper> nevermind
09:52:50 <ski> d7 : also, which ways had you in mind for making `[]' a monad ?
09:52:52 * rtharper shuts up, now =p
09:52:59 <ion> kmc: (v,""):_ rather than [(v,"")]
09:53:13 <d7> ski: Well then I more correctly state my question; is there more than one valid interpretation of streams as a comonad?
09:53:27 <ski> rtharper : when i say "streams", unqualified, i don't mean "potentially finite streams"
09:53:27 <kmc> ion, i would disallow ambiguity
09:53:33 <k0ral> hey, how could you write the sortest function :: Int -> IO () that does absolutely nothing ?
09:53:38 <rtharper> ski: Right, I realised =)
09:53:49 <kmc> k0ral, f _ = return ()
09:53:52 <o1iver> Is it normal to use the FlexibleInstances extension?
09:53:55 <k0ral> I tried \_ -> return () :: Int -> IO () but it complains
09:53:57 <o1iver> or is it a bad iead?
09:54:03 <rtharper> ski: I always assume that's what stream means, which is not really accurate, heh
09:54:06 <kmc> :t (\_ -> return ()) :: Int -> IO ()
09:54:07 <lambdabot> Int -> IO ()
09:54:12 <ski> k0ral : `(\_ -> return ()) :: Int -> IO ()
09:54:15 <kmc> o1iver, it's usually fine
09:54:27 <kmc> :t \_ -> return () :: IO ()
09:54:28 <lambdabot> forall t. t -> IO ()
09:54:31 <k0ral> kmc: Couldn't match expected type `IO ()' with actual type `()'
09:54:31 <kmc> :t \_ -> (return () :: IO ())
09:54:32 <lambdabot> forall t. t -> IO ()
09:54:39 <o1iver> kmc: It is necessary if I want to make (Either x) and instance of Monad right?
09:55:18 <kmc> o1iver, is it?
09:55:31 <ski> d7 : "is there more than one valid interpretation of streams as a comonad?" -- maybe. i can only think of one atm, though
09:55:47 <o1iver> kmc: haha, thats what GHC was saying :-)
09:55:48 <k0ral> kmc: ah shouldn't use :: Int -> IO () but simply :: IO () at the end of line
09:56:05 <ski> d7 : i suppose you could use `instance Monoid m => Comonad (m ->)' for other monoid structures on `Nat', though ..
09:56:12 <kmc> k0ral, the body of the lambda extends as far right as possible
09:56:22 <ski> (d7 : e.g. the multiplicative structure)
09:56:28 <kmc> k0ral, so if you want the type sig to apply to the lambda expression itself, use parens
09:56:30 <o1iver> kmc: so its not necessary?
09:56:41 <kmc> o1iver, i don't know.  which rule on Haskell 98 instances is violated?
09:56:59 <kmc> anyway FlexibleInstances is fine
09:57:23 <d7> ski: I do not understand, but that's okay. Ty.
09:57:24 <kmc> it's in the class of "Haskell 98 disallows this to be nice to implementers; GHC is so awesome we let you do it anyway"
09:57:32 <k0ral> kmc: fair enough
09:57:35 <k0ral> thank you
09:57:43 <ski> d7 : with the additive interpretation, we have basically `(scaffold as !! m) !! n = as !! (m + n)', so with the multiplicative, we'd get `(scaffold as !! m) !! n = as !! (m * n)'
09:57:55 <ski> d7 : note that `Stream a' is isomorphic to `Natural -> a'
09:58:01 <d7> Ahh
09:58:19 <ski> d7 : there is an obvious way to do `instance Monoid m => Comonad (m ->)'
09:58:33 <o1iver> Well I don't honestly get all this stuff yet... But I guess that it has something to do with Monad Instance only taking types of kind * -> * (not that I now understand why this requires flexibleInstances whatever they mean)... I will come back to that later :-)
09:58:39 <ski> d7 : the usual comonadic structure on `Stream' corresponds to taking the additive monoid on `Natural'
09:59:02 <kmc> o1iver, FlexibleInstances doesn't let you violate kind rules
09:59:06 <kmc> (Either T) has kind * -> *
09:59:08 <ski> (d7 : and `scaffold :: Comonad w => w a -> w (w a)')
09:59:09 <kmc> because (Either T S) has kind *
09:59:43 <kmc> there's no reasonable meaning for kind errors such as «instance Monad Either» or «instance Show Maybe»
09:59:54 <kmc> they're just like type errors, but one level up
10:00:01 <kmc> so there's no GHC extension which allows such things
10:00:06 <o1iver> ok
10:00:13 <kmc> for details on FlexibleInstances see GHC manual
10:00:22 <o1iver> yeah ok, I will have a look
10:00:26 <d7> ski: I see.
10:00:47 <kmc> you need it for example for «instance Show (Maybe Char)»
10:00:57 <kmc> H98 only lets you do «instance Show (Maybe t)»
10:01:14 <kmc> i.e. the type in the instance head must be of the form (C a b c ...) where C is a constructor and a,b,c are variables
10:01:15 * ski mumbles `showList'
10:01:18 <o1iver> But what does the error "All instance types must be of the form (T a1 ... an) where a1 ... an are type *variables*" mean?
10:01:30 <kmc> it means what it says / what I said
10:01:31 <d7> o1iver: I think he just said. :)
10:01:39 <o1iver> d7: yep :-)
10:01:45 <d7> That FlexibleInstances is so very useful.
10:01:56 <lysgaard> Anyone have experince with realtime 2d drawing in haskell? I'm trying to visualise a planetal orbital program I've written.
10:02:02 <kmc> Text.Printf has the horrid hack IsChar class to get around this in H98
10:02:23 <d7> It seems like GHC has a bunch of indispensable extensions like this. Do people actually use other haskell compilers that don't have these?
10:02:23 <kmc> «instance Foo [Char]» ⇒ «instance (IsChar c) => Foo [c]»
10:02:44 <kmc> d7, people actually use other haskell compilers (sometimes) but they tend to have the same indispensable extensions
10:02:47 <d7> kmc: Damn you are busting out the unicode in rare form today.
10:02:58 <kmc> d7, if you consult the logs I think you'll see it's not rare ;)
10:03:07 <kmc> fwiw the only GHC extension I consider truly indispensable is RankNTypes
10:03:16 <o1iver> So is there any way of making Either an instance of Monad without FlexibleInstances?
10:03:27 <kmc> there is no way of making Either an instance of Monad, at all
10:03:28 <kmc> kind error
10:03:39 <ski> o1iver : `instance Monad (Either e)'
10:04:15 <kmc> yep, that's valid H98
10:04:22 <ski> (that is making `Either e' (for any type `e'), not `Either' itself, an instance of `Monad', as kmc so kindly observed)
10:04:36 <kmc> (you should probably give a body for the instance, but it's actually not required)
10:04:57 <kmc> o1iver, what instance were you trying to write?
10:05:11 * ski guesses the obvious instance
10:05:18 <o1iver> kmc: because using (Either e) doesn't give me access to the "e" Data Constructor and thus I cannot for example do fail s = Left (** s)
10:05:44 <kmc> right
10:05:49 <d7> Damn looking over the instances for Either
10:05:56 <d7> MonadFix is one I should grok
10:06:16 <byorgey> MonadFix does not come up all that often.
10:06:17 * hackagebot reactive-banana 0.3.0.1 - Small but solid library for  functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.3.0.1 (HeinrichApfelmus)
10:06:28 <kmc> o1iver, 'fail' kind of sucks anyway
10:06:39 <o1iver> kmc: Either ErrorDataType String. But I have got it working using FlexibleInstances... I am just trying to understand why it doesn't work without it
10:06:51 <ski> o1iver : i'd ignore `fail' ..
10:06:55 <kmc> because "All instance types must be of the form (T a1 ... an) where a1 ... an are type *variables*"
10:07:03 <kmc> neither ErrorDataType nor String is a type variable
10:07:05 <d7> byorgey: It looks awesome.
10:07:18 * hackagebot reactive-banana-wx 0.3.0.1 - Examples for the reactive-banana library, using wxHaskell.  http://hackage.haskell.org/package/reactive-banana-wx-0.3.0.1 (HeinrichApfelmus)
10:07:34 <byorgey> d7: forgive me, I misinterpreted your motivation.  proceed. =)
10:07:57 * ski wants nothing to do with nonsense like `instance Error e => Monad (Either e)'
10:08:05 <kmc> exactly
10:08:13 <kmc> i just noticed that C.M.Instances got rid of that
10:08:16 <o1iver> kmc: mmmh ok. Still don't get it, but I think I will just keep going and hope I "get" it at some point :-)
10:08:32 <kmc> o1iver, what's to get?  there's a rule in the Haskell 98 spec that says "All instance types must be of the form (T a1 ... an) where a1 ... an are type *variables*"
10:08:46 <kmc> your instance violates that rule, therefore it is not valid Haskell 98
10:08:48 <ski> (kmc : and not a second too early ..)
10:08:50 <o1iver> kmc: the cause it quite probably my confusion about type variables
10:09:11 <kmc> well, ErrorDataType and String are specific types
10:09:18 * hackagebot unix-bytestring 0.3.5 - Unix/Posix-specific functions for ByteStrings.  http://hackage.haskell.org/package/unix-bytestring-0.3.5 (WrenThornton)
10:09:38 <ski> o1iver : are you trying to `instance Monad (Either MyError)' ?
10:10:29 <hpaste> o1iver pasted “Either Monad” at http://hpaste.org/48509
10:10:40 <kmc> ski, yes
10:10:51 <lysgaard> Anyone have experience in 2D drawing in Haskell?
10:10:58 <kmc> lysgaard, little bit
10:11:43 <kmc> o1iver, ParserError is not a type variable, it's a specific type
10:12:14 <kmc> if you have «instance Monad (Either ParserError)» then you can't use, say, «Either Char t» or «Either Bool t» with 'return' or (>>=)
10:12:31 <kmc> (set aside for the moment the question of what happens if you give *both* instances)
10:12:49 <lysgaard> kmc: I want to visualize a orbit simulator I've written.
10:12:57 <kmc> lysgaard, realtime?
10:13:43 <lysgaard> kmc: yeah
10:14:22 <o1iver> kmc: ok I think I get it... I can't make (data Da a b) not (data Db) an instance of Monad, only (data Dc a)
10:14:38 <kmc> o1iver, that is a separate issue.  that is the "kind error" issue
10:15:40 <kmc> in «instance Monad M» you have «return :: a -> M a» and therefore M must be a type constructor with one type parameter
10:15:58 <ski> o1iver : if you want `Either MyError', then do a `newtype'-wrapper
10:16:31 <ski> (or use a generic `Monad (Either e)' instance)
10:16:32 <kmc> o1iver, «instance (Either MyError)» is not a kind error, because you've partially-applied Either to the point where it has only one type parameter left
10:16:35 <o1iver> kmc: ok, that makes sense, a lot of sense actually
10:16:45 <kmc> but it is disallowed by Haskell 98 for a different reason
10:17:01 <kmc> actually i don't know the *reason*, but the rule is "All instance types must be of the form (T a1 ... an) where a1 ... an are type *variables*"
10:17:07 <o1iver> ski: yeah I was playing with that generic instance before
10:17:44 <ski> o1iver : it should be doable to have than generic instance, and then use `Either MyError' for your specific uses
10:18:18 <Neurax> helo
10:18:30 <kmc> o1iver, there is no GHC extension which lets you get away with kind errors.  at that point the program would be total nonsense
10:18:35 <o1iver> kmc: ok, now I understand that problem. So [1] you cannot have a partially applied type in an instance and [2] The monad must be of kind * -> * because otherwise the (>>=) function wouldnt work
10:18:47 <kmc> no, you can have a partially applied type in an instance
10:18:57 <kmc> you wrote «instance Monad (Either e)»
10:19:04 <kmc> that is a partial application of Either
10:19:22 <Neurax> \die
10:19:24 <o1iver> ski: yes, I am currently playing around with that, still trying to wrap my head around that
10:19:38 <kmc> o1iver, do you understand that there are two issues at play here?
10:19:48 <kmc> one is the kind issue
10:19:55 <kmc> which is fundamental to Haskell's type system or any other similar type system
10:20:04 <o1iver> kmc: yes
10:20:15 <kmc> the other is the Haskell 98 restriction that instances must have the form (T a b c) and not, say (T Char Bool Int)
10:20:21 <kmc> that one is not fundamental, and GHC lets you lift that restriction
10:20:34 <kmc> ok
10:21:01 <ezyang> Does anyone know how long stupid search for the 8-queens problem usually takes? (No optimizations)
10:21:12 <kmc> so «instance (Either MyError)» has a fine kind, but breaks the other rule
10:21:18 <kmc> which is why it goes through with -XFlexibleInstances
10:21:39 <zygoloid> > product [1..8]
10:21:40 <lambdabot>   40320
10:21:48 <zygoloid> ezyang: ^^ not a stupid length of time
10:21:49 <o1iver> OK and the type issue is that because of the type of (>>=) a data type can only be of kind *->*... right?
10:21:57 <kmc> or the type of 'return'
10:22:04 <zygoloid> ezyang: but, depends how stupid you mean
10:22:09 <kmc> @src Monad
10:22:09 <lambdabot> class  Monad m  where
10:22:10 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
10:22:10 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
10:22:10 <lambdabot>     return      :: a -> m a
10:22:10 <lambdabot>     fail        :: String -> m a
10:22:30 <o1iver> ok, I get that problem now
10:22:37 <kmc> 'm' is always used in type signatures as «m a» or «m b» never «m» or «m a b»
10:22:50 <kmc> within the definition of "Monad"
10:22:59 <kmc> that forces m's kind to be (* -> *)
10:23:12 <ezyang> I did a non-parallelized port of https://github.com/simonmar/monad-par/blob/master/examples/queens.hs
10:23:25 <kmc> if T can be the type of something, then T has kind *
10:23:27 <o1iver> So if (>>=) had type a -> b -> M a b we could have an instance like (Either a b)?
10:23:27 <ezyang> But I'm not sure if I did it correctly.
10:23:36 <kmc> o1iver, no, then you would have an instance Either
10:23:49 <o1iver> kmc: yeah yeah ok, got that the wrong way round
10:23:56 * ski . o O ( `Monad :: (* -> *) -> constraint' )
10:23:56 <o1iver> kmc: my bad, but thats what I meant
10:24:03 <kmc> class C where { f :: C a b -> () }
10:24:07 <kmc> err
10:24:10 <kmc> class C t where { f :: t a b -> () }
10:24:17 <kmc> instance C Either where { f _ = () }
10:24:25 <ezyang> Hmm, I think I accidentally infinite looped it.
10:24:48 <kmc> similarly you can write «instance Show (Either a b)» but not «instance Show (Either a)» or «instance Show Either»
10:24:54 <kmc> because the Show class wants a parameter with kind *
10:25:19 <o1iver> kmc: ah ok. That makes a lot of sense now (and I feel pretty stupid :-p)
10:25:30 <kmc> don't feel stupid, this is tricky stuff
10:25:49 <kmc> polymorphism over type *constructors*, in addition to types, is one of the main places where Haskell's type system is more powerful than most other languages
10:26:14 <rtharper> Hear, hear =)
10:26:24 <o1iver> kmc: well thanks a lot for the explanation. I did not understand that the types of the class functions (if that is what they are called) where the reason for that type constraint
10:26:25 <ski> kmc : yeah, i tried to convince an #sml resident the other way of the merit of that
10:26:45 <kmc> o1iver, yeah, and it's tricky because the kind is inferred, not written
10:26:57 <kmc> though I think GHC has a separate extension which would let you write «class Monad (m :: * -> *) where ...»
10:27:14 <ski> probably `KindSignatures' allows that as well
10:33:42 <o1iver> kmc: ok, so now this Illegal instance declaration error is because there is simply a rule that it must be of the form (T a1 ... an) where a1 ... an are type variables and in my case they were types
10:33:51 <kmc> right
10:33:57 <kmc> i don't actually know the reasoning behind that rule
10:34:00 <kmc> would be interested to know
10:34:40 <o1iver> kmc: but ski's generic Either instance (Either a) is legal because in that case a is a type variable
10:34:50 <kmc> correct
10:34:57 <kmc> i think the rule is just to make life easier for implementors
10:35:20 <o1iver> implementors of the type checking system?
10:35:23 <kmc> yes
10:35:42 <kmc> if someone says "show v" and (v :: A (B C) (D (E F)))
10:35:51 <kmc> then by this rule you already know the exact instances to look for
10:36:29 <kmc> (A s t), (B s), C, (D s), (E s), F
10:36:43 <mekeor> when i say 'fac 0 = 1' and 'fac n = n*fac(n-1)'. is it possible that 'fac x', where 'x' is a very big integer, causes a stack-overflow?
10:37:06 <dmwit> kmc: But you might need additional instances or fewer instances.
10:37:23 <dmwit> For example, you wouldn't need an instance for C if the declaration "instance Show (B a)" existed (with no context).
10:37:24 <kmc> dmwit, some of those instances might have constraints of their own
10:37:31 <kmc> *nod* that's true
10:37:36 <ski> > let fac 0 = 1; fac n = n*fac(n-1) in fac 10000000000000000
10:37:37 <kmc> mekeor, stack in GHC Haskell means something different than in most language implementations
10:37:37 <lambdabot>   *Exception: stack overflow
10:37:43 <gwern> so what's the performance penalty for STM these days compared to locks?
10:37:46 <dmwit> I see.
10:37:49 <dmwit> Yes, okay, I see.
10:37:52 <kmc> it's about nested pattern matching, not nested function calls
10:38:12 <ski> mekeor : yes, the nested `n * ((n-1) * ((n-2) * ...))' causes the overflow
10:38:44 * gwern wonders because of http://news.ycombinator.com/item?id=2710235 
10:39:02 <dmwit> gwern: When there's little contention, STM fares well.
10:39:40 <danharaj> let fac n 0 = n; fac n m = fac (n*m) (m-1) is fac 1 10000000000
10:39:43 <danharaj> woops
10:39:49 <mekeor> ski: is it possible to avoid this case? or does haskell (or rather GHC) try to do so?
10:39:50 <danharaj> > let fac n 0 = n; fac n m = fac (n*m) (m-1) in fac 1 10000000000
10:39:56 <lambdabot>   mueval: ExitFailure 1
10:39:56 <lambdabot>  mueval-core: Time limit exceeded
10:40:01 <danharaj> yay, different.
10:40:04 <c_wraith> in fact, where there's little contention, STM could conceivably outperform a lock-based system
10:40:44 <danharaj> mekeor: When possible, try to use an accumulating parameter.
10:40:55 <kmc> STM research really started in 2003?
10:40:59 <kmc> i am suspicious of that claim
10:41:22 <kmc> funny that nobody mentions Clojure in this thread
10:41:31 <danharaj> > let fac n = fac' 1 n; fac' n 0 = n; fac' n m = fac' (n*m) (m-1) in fac 10000
10:41:32 <lambdabot>   284625968091705451890641321211986889014805140170279923079417999427441134000...
10:41:35 <c_wraith> heh.  I know I'd wished for something with STM's main properties before 2003
10:41:41 <ski> mekeor : .. keeping the accumulator forces, if it's something small/strict like an `Int'
10:41:41 * JuanDaugherty does a profundity or gobbledeygoook check on STM
10:42:09 <dylukes> kmc: Which libraries (IO/ST/STM/etc) are actually in haskell?
10:42:11 <c_wraith> I mean, the idea is rather obvious to anyone who ever used a relational DB, then had to struggle with manual locking.
10:42:18 <dylukes> MVar etc
10:42:25 <dylukes> I mean, are any pure haskell?
10:42:34 <kmc> dylukes, IO is in the spec
10:42:35 <mekeor> ski: ok.. i see; thanks so far
10:42:47 <mekeor> danharaj: was the result right?
10:42:48 <kmc> ST is useless without Rank2Types which is not in any approved Haskell spec
10:42:58 <danharaj> mekeor: Probably?
10:42:59 <gwern> kmc: wikipedia says stm began in '95
10:42:59 <azaq23> > let fac 0 = 1; fac n = n `seq` (n * fac (n-1)) in fac 10000
10:43:00 <lambdabot>   284625968091705451890641321211986889014805140170279923079417999427441134000...
10:43:12 <gwern> kmc: 'The idea of providing hardware support for transactions originated in a 1986 paper and patent by Tom Knight[1]. The idea was popularized by Maurice Herlihy and J. Eliot B. Moss[2]. In 1995 Nir Shavit and Dan Touitou extended this idea to software-only transactional memory (STM)[3].'
10:43:15 <c_wraith> kmc: I think the question was more about "which can be implemented in haskell without the FFI"?
10:43:32 <hpaste> “Ben Gamari” pasted “GC churn yet again” at http://hpaste.org/48510
10:43:49 <kmc> you *can* implement ST in Haskell without the FFI, but you have a roughly O(log #STRefs) slowdown compared to GHC's implementation
10:44:02 <hpaste> “Ben Gamari” annotated “GC churn yet again” with “GC churn yet again (profile)” at http://hpaste.org/48510#a48511
10:44:05 <kmc> also some typing issues arise, even setting aside Rank2Types
10:44:12 <stulli> Why is the Haskell STM implementation regarded as superior to other languages?
10:44:12 <ski> c_wraith : you can't implement `type a -> b' in Haskell ..
10:44:17 <Cale> dylukes: If you're asking about what can be implemented without lower level support, the answer would be none of them (though ST/STM could be implemented in terms of IO, though this shouldn't be surprising)
10:44:21 <kmc> stulli, you mean the GHC implementation?
10:44:25 <stulli> yes
10:44:34 <kmc> i'm not sure it is regarded as superior
10:44:38 <kmc> i don't think there's much to compare to
10:44:39 <o1iver> kmc, ski: thank you again for taking the time explaining this stuff! It was extremely helpful and I also thing I may have started **getting** monads after this discussion! Thanks again. I am always amazed at how nice people are in #haskell :-) Thanks!
10:44:42 <bgamari> I think I'm one-by-one running down the list of ways to write memory-inefficient haskell code
10:44:43 * JuanDaugherty (profundity vs. gobbledeygoook is Sartre specific, this is worthwhile original software concept vs. something else)
10:44:50 <ski> stulli : one advantage is that `STM'-actions can't do (irreversable) I/O
10:44:56 <kmc> stulli, in what other languages do people use STM?
10:44:57 <bgamari> Anyone have any idea what would explain the profile at http://hpaste.org/48510
10:45:02 <kmc> the only major one I know of is Clojure
10:45:08 <c_wraith> stulli: it's superior to .NET's (dead) STM implementation because you can't do IO inside of STM
10:45:14 <kmc> Microsoft had some project to add STM to C# which failed hard because.. yeah, that
10:45:26 <Cale> dylukes: It's possible to imagine that IO is a GADT or other datatype representing an abstract syntax of IO actions, and the RTS inspects that syntax and actually carries out the described actions
10:45:28 <kmc> also they wanted to allow nested transactions for some reason
10:45:43 * JuanDaugherty (s/profundity/erudition/)
10:45:48 <stulli> kmc: Well, i don't know if people _use_ STM in other languages, but there are some implementations AFAIK
10:45:50 <c_wraith> stulli: it's not superior to Clojure's STM system because Clojure supports MVCC.  Clojure doesn't forbid IO inside of STM, though, so it's kind of a wash.
10:46:10 <kmc> what's MVCC?
10:46:18 <c_wraith> multi-version concurrency control
10:46:26 * hackagebot angel 0.2 - Process management and supervision daemon  http://hackage.haskell.org/package/angel-0.2 (JamieTurner)
10:46:26 <ski> o1iver : the best way to thank is to try to be as helpful :)
10:46:40 <c_wraith> It basically is a way to make reads more consistent
10:46:48 <kmc> i know Clojure uses locks in implementing STM while GHC's is lockless (?)
10:46:55 <c_wraith> You can get inconsistent reads in GHC's STM
10:46:57 <o1iver> ski: in 10 000 hours (that's what I hear it takes to *get anything*) :-)
10:47:14 <kmc> o1iver, please, don't try to "get" monads.  there is nothing to get
10:47:23 <kmc> it's just an API.  lots of types implement this API but they don't have much in common
10:47:37 <kmc> i wish GHC's RTS had a way to detect high contention and switch away from lockless STM to something else
10:47:40 <ski> o1iver : well, you can always start helping directly with the things you do understand and you see someone else struggling with
10:47:54 <o1iver> kmc: well I mean that I understand what is going on with (>>=)
10:48:09 <kmc> in what sense?
10:48:15 <o1iver> ski: true true!
10:48:22 <Cale> I think what trips people up about monads isn't the monad part. It's just the functional programming part, mostly :)
10:48:23 <kmc> the implementations of (>>=) for these different types have little in common
10:48:53 <monochrom> >>= is an overloaded operator just like ==
10:48:53 <kmc> Cale, yeah, or sometimes polymorphism over type constructors
10:48:53 <c_wraith> Cale: I actually had a lot of trouble with the higher-kinded polymorphism part.  Once I understood that, the rest fell into place quickly
10:49:03 <c_wraith> yes, exactly what kmc said
10:49:07 <kmc> that's what o1iver and I were discussing before
10:49:21 <Cale> Yeah, some people actually miss that altogether :P
10:49:29 <o1iver> well my understanding (please correct me) is that the general idea behind (>>=) is that it chaines together functions on the data "contained" in a Monad
10:49:45 <Cale> It's semi-pointless to talk about monads if you can't write code which works in more than one at a time
10:49:46 <kmc> o1iver, that's an analogy, which will serve you well in some cases and poorly in others
10:50:02 <kmc> the analogy is in the word "contained"
10:50:05 <monochrom> it is a good plan to do Functor first, such as in LYAH
10:50:07 <o1iver> kmc: you mean the problem with the Monad = container analogy
10:50:10 <kmc> yeah
10:50:21 <stulli> kmc: What's bad about lockless STM?
10:50:25 <kmc> my claim is that there *isn't* a general idea behind (>>=)
10:50:40 <kmc> it's just a function, with a specific type, which is implemented lots of different ways
10:51:06 <Cale> Well, you can always think of monadic values as containers, but your notion of "container" has to get pretty weird and generic.
10:51:14 <kmc> it's implemented whichever way happens to make "do" syntax and liftM, mapM, etc. into useful tools, for your particular type
10:51:18 <o1iver> well I guess that the meaning comes from the monad laws...
10:51:27 <monochrom> YES!
10:51:27 <Cale> (probably weirder than most people would like :)
10:51:34 <kmc> the monad laws don't give you much either
10:51:39 <monochrom> there is no "meaning" apart from axioms
10:51:40 <kmc> they certainly don't say what (>>=) actually "means"
10:51:52 <c_wraith> kmc: for instance:  Thread A reads TVars c and d.  Thread B reads TVar c and writes to TVar d.  if those happen to occur in the order:  1. A reads c  2. B reads c  3. B writes d  4. A reads d.  GHC's STM will result in A seeing "inconsistent" values for c and d.  Clojure, because it has MVCC, will result in A reading the value that d had when it read from c
10:52:04 <kmc> o1iver, another insight is that most monads are useless if you *only* use the Monad typeclass functions
10:52:06 <ski> (o1iver : of course we try to have our fun too, with crazy types and pointless foolery .. as long as we try to help people as well, i see no problem with this)
10:52:09 <kmc> you have to have some type-specific "primitives"
10:52:17 <o1iver> kmc: well the Right identity kind of does, doesnt it?
10:52:24 <kmc> how so?
10:52:33 <kmc> btw i like to think of the monad laws in terms of (>=>) not (>>=)
10:52:35 <kmc> @src (>=>)
10:52:35 <lambdabot> Source not found. Take a stress pill and think things over.
10:52:46 <avartanian> Quick question: if I think of (a -> b) as a type (that type being: "function") is there any way of making a data structure an "instance" of the type (say Data.Map.Map a b or ([a],[b])?
10:52:47 <danharaj> :t (>=>)
10:52:50 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
10:52:53 <Cale> (f <=< g) x = f =<< g x
10:52:55 <kmc> f >=> g = \x -> f x >>= g
10:53:10 <o1iver> kmc: ok its hard to explain the meaning of the Right Identity :-)
10:53:28 <kmc> o1iver, in which case the laws are
10:53:31 <kmc> return >=> f = f
10:53:31 <Cale> the monad laws become:  (return <=< f) = f,  (f <=< return) = f, and (f <=< g) <=< h = f <=< (g <=< h)
10:53:33 <kmc> f >=> return = f
10:53:37 <monochrom> there is no conflict between "Monad does not mean much" and "Monad laws give the only meaning".
10:53:45 <kmc> ((a >=> b) >=> c) = (a >=> (b >=> c))
10:53:59 <monochrom> in fact, they probably justify each other
10:53:59 <c_wraith> kmc: is that a sufficient explanation of MVCC?  (It makes decisions on whether commit transactions much more complicated, which is why it's not in GHC, I believe)
10:54:03 <kmc> iow (>=>) (or (<=<) if you like, Cale) is an associative binary operator with "return" as its unit
10:54:12 <Cale> Or you can go with >=> instead of <=< if you prefer. It's backward compared to normal (.) though :)
10:54:16 <kmc> c_wraith, ok
10:54:26 <danharaj> :t lookup
10:54:27 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
10:54:30 <kmc> stulli, the main disadvantage of lockless STM afaik is that you get livelock with heavy contention
10:54:34 <ski> kmc,Cale : yay! for stereo talk :)
10:54:36 <linduxed> i just tried loading the following code into ghci but i got "Can't find interface-file declaration for variable print" http://paste.pocoo.org/show/423853/
10:54:40 <danharaj> :t flip lookup
10:54:41 <lambdabot> forall a b. (Eq a) => [(a, b)] -> a -> Maybe b
10:54:43 <c_wraith> @quote stereo
10:54:43 <lambdabot> LoganCapaldo says: * LoganCapaldo must resist urge to mention stereo
10:54:44 <kmc> locks are useful for forcing threads into orderly well-defined execution
10:54:48 <danharaj> avartanian: There you go.
10:54:52 <linduxed> some help would be appreciated
10:54:58 <bgamari> Any ideas concerning the GC churn caused by http://hpaste.org/48510
10:55:09 <bgamari> Strictness in dot doesn't help
10:55:11 <danharaj> avartanian: If you don't mind the lack of totality, then
10:55:25 <danharaj> :t (fromJust .) . flip lookup
10:55:25 <Cale> linduxed: That is weird. What exactly are you doing?
10:55:26 <lambdabot> forall a a1. (Eq a1) => [(a1, a)] -> a1 -> a
10:55:59 <kmc> o1iver, anyway, just by saying "(>=>) is an associative binary operator with an identity" I have not said anything about what (>=>) actually "does" or "means"
10:56:05 <linduxed> Cale: well as the comment specifies i want to calculate the length of a list
10:56:09 <kmc> for example (+) is also an associative binary operator with an identity
10:56:13 <Cale> linduxed: I understand that
10:56:15 <kmc> as is (&&), as is (++)
10:56:21 <linduxed> Cale: and all i did was :load length.hs
10:56:26 <Cale> okay
10:56:35 <linduxed> eeeerr
10:56:38 <linduxed> now it worked
10:56:43 <linduxed> i just restarted ghci
10:56:45 <Cale> huh
10:56:45 <linduxed> ....
10:56:45 <danharaj> can't you think of any monad is a less powerful Cont?
10:56:46 <Cale> okay
10:56:50 <linduxed> that was weird
10:56:53 <ski> @hoogle (a -> Maybe b) -> [(a,b)]
10:56:54 <lambdabot> No results found
10:56:56 <Cale> Indeed :)
10:57:00 * linduxed didn't change anything
10:57:16 <kmc> avartanian, no
10:57:23 <Cale> kmc: One subtlety here is the shape of the types
10:57:35 * JuanDaugherty does not smile upon but is not ready to frown or spit on STM. 
10:57:51 <ski> danharaj : hm ?
10:58:09 * monochrom ♥ STM
10:58:15 <Cale> When we say that "<=< is a binary operator with return as the identity" what we're really saying is that it's the composition of a category, rather than just that it's a plain old monoid ;)
10:58:37 <avartanian> danharaj kmc Thanks. What I'm trying to do is create a typeclass which has members that are functions so that they can easily be called, but also mutated independently of knowledge of the specific data structure used to implement.
10:58:44 <avartanian> An example may help:
10:58:48 <kmc> yeah, the higher-kinded polymorphism again
10:58:53 <Cale> well...
10:58:54 * ski whispers the magic incantation `Kleisli'
10:59:10 <stulli> kmc: I know livelocks can happen with lockless STM, i wasn't aware you could avoid them with a different implementation. Also i thought the whole point of STM was to avoid handling locks. I think i need to read up some more.
10:59:11 <dylukes> a Level 27 Oleg Kiselyov is summoned!
10:59:14 <Cale> that it's not a *total* function, you can't just compose any two a -> m b arrows
10:59:21 <avartanian> Let's say I'm coding Dijkstra search...
10:59:26 <kmc> stulli, the point of STM is that the *programmer* does not write locks
10:59:28 <Cale> the types have to line up too :)
10:59:31 <kmc> they just say "atomically (do this stuff)"
10:59:32 <avartanian> Off topic: Who the heck is the shadowy Oleg Kiselyov?
10:59:41 <danharaj> A type wizard.
10:59:46 <ski> @quote oleg
10:59:46 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
10:59:46 <dylukes> type magician.
10:59:48 <kmc> stulli, but the person implementing STM in the language runtime or whatever could use locks to implement those semantics
10:59:49 <djahandarie> atomically $ save Madoka
10:59:53 <avartanian> Who seems like the awesomestest hacker ever, but I can't get any info about him.
11:00:09 <dylukes> @quote Leinor monads
11:00:09 <lambdabot> No quotes for this person. There are some things that I just don't know.
11:00:10 <Cale> He's just this guy, you know?
11:00:12 <dylukes> @quote Leinor
11:00:12 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
11:00:14 <ski> @quote .oleg.
11:00:15 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
11:00:17 <dylukes> @quote Veinor monads
11:00:17 <kmc> stulli, the trivial implementation of STM is to take a global lock around each transaction, and that of course can't livelock (or even deadlock)
11:00:18 <lambdabot> Veinor says: I can teach you monads if you sign this contract ／人◕‿‿◕人＼
11:00:20 <dylukes> there we go
11:00:22 <dylukes> djahandarie: ^
11:00:28 <danharaj> avartanian: This is his website: http://okmij.org/ftp/
11:00:33 <avartanian> Okay well my Dijkstra...
11:00:48 <djahandarie> dylukes, I remembered that quote :p
11:00:49 <avartanian> Let's say...
11:00:50 <dylukes> Cale: What is that quote from?
11:00:51 <avartanian> data DijkstraSearch a n = DijkstraSearch {    unvisitedNodes :: [a],   weight :: (a,a) -> n,   neighborsOf :: a -> [a]   state :: a -> NodeState   }
11:00:58 <Cale> dylukes: hhgttg
11:01:05 <dylukes> Ah, right.
11:01:09 <avartanian> In other words DijkstraSearch is an instance of the problem.
11:01:31 <avartanian> And it is very natural to say that the instance needs a state function where you can query if each vertex is Visited, Unvisited, etc.
11:01:42 <avartanian> But you also need mutators for it.
11:02:03 <dylukes> http://en.wikipedia.org/wiki/Oleg_Kiselyov
11:02:12 <dylukes> Same guy amirite.
11:02:16 <avartanian> So you need a method like:: mark :: a -> NodeState -> DijkstraGraph a n ->  DijkstraGraph a n
11:02:35 <avartanian> But that mark method can't really "reach into" the structure of the function to mutate it efficiently.
11:02:40 <ski> dylukes : somehow, i suspect that's a different person
11:02:55 <dylukes> ski: I don't know...
11:03:10 <monochrom> different perons
11:03:13 <Cale> avartanian: Use Data.Map :)
11:03:17 <avartanian> So my thinking was: if there is some typeclass that represented a "mutable function".
11:03:51 <avartanian> Cale okay so nothing comes to mind?
11:03:55 <Cale> avartanian: You may be about to invent lenses? :)
11:04:01 <avartanian> I may just roll my own.
11:04:03 <avartanian> class MutableFunction f a b | f -> a b where    get :: f -> a -> b   set :: f -> a -> b -> f
11:04:14 <kmc> Cale called it
11:04:16 <Cale> yes, you're inventing lenses.
11:04:19 <avartanian> Oh dear God.
11:04:21 <stulli> kmc: Ok, i see. Thanks for the explanation. Maybe you can recommend good papers about implementations of STM? I'm just starting to get into that topic.
11:04:25 <avartanian> This is what I love about Haskell.
11:04:33 <kmc> stulli, unfortunately I don't know any papers on the topic
11:04:34 <avartanian> And the Haskell community.
11:04:36 <danharaj> This is what I hate about Haskell.
11:04:37 <kmc> just what I've picked up hanging out here
11:04:48 <kmc> stulli, if you find some good papers, let me know!
11:04:49 <avartanian> Okay Cale, I'm going to go check out lenses.
11:04:51 <dylukes> It's kind of hard to really "invent" something ,sadly.
11:04:51 <Cale> data Lens a b = L { get :: a -> b; put :: b -> a -> b }
11:04:59 <avartanian> A week ago I accidentally invented arrows.
11:05:01 <dylukes> Wait.
11:05:05 <dylukes> What would 'colenses' be?
11:05:05 <ski> avartanian : at least, it's possible that you're inventing lenses
11:05:17 <dylukes> Cale: What's the categorical dual to a lense?
11:05:28 <stulli> kmc: Sure i'll do :)
11:05:54 <ski> dylukes : you might be better off asking edwardk about that ..
11:05:59 <Cale> ummmm...
11:06:04 <dylukes> He's not around aki
11:06:06 <dylukes> ski*
11:06:06 <avartanian> Cale thanks so much. I'm going to go study lenses now.
11:06:13 <Cale> Yeah, he's probably thought about it more than I have :)
11:06:30 <Cale> avartanian: I'll see if I can find you a link...
11:06:32 <dylukes> so the categorical dual of something is just flipping the arrows around >_>?
11:06:35 <ski> dylukes : `@ask edwardk hi! what's the dual of a lens ?'
11:06:42 <Cale> Edward did a talk on them using scala for some reason
11:06:43 <dylukes> @ask edwardk hi! what's the dual of a lens ?
11:06:43 <lambdabot> Consider it noted.
11:07:07 <dylukes> I still don't quite get data/codata, but it seems interesting nonetheless.
11:07:25 <djahandarie> data and codata are not categorical duals
11:07:29 <djahandarie> ...afaik.
11:07:30 <Cale> http://twanvl.nl/blog/haskell/overloading-functional-references
11:08:09 <ski> djahandarie : they should ?
11:08:43 <Cale> "Lenses are the coalgebras for the costate comonad"
11:08:47 <Cale> http://patternsinfp.wordpress.com/2011/01/31/lenses-are-the-coalgebras-for-the-costate-comonad/
11:09:05 <djahandarie> ski, I don't see it
11:09:22 <dylukes> what is "the algebra" of a monad?
11:09:26 <dylukes> or the coalgebra of a comonad?
11:09:32 <dylukes> I mean, what is the definition of "algebra" here
11:09:41 <danharaj> dylukes: F-algebras and G-coalgebras
11:09:44 <ski> djahandarie : `data List a = Nil | Cons a (List a)' vs. `data Stream a = Head :: a & Tail :: Stream a'
11:09:55 <danharaj> http://en.wikipedia.org/wiki/F-algebra
11:09:58 <wli> littlebobby: Those aspects of the compiler are largely independent of the source language. I wouldn't call them hearts of compilers. Compilers are long chains of phases acting on the transformed programs (in heavier-duty ones; student job all bets are off). There is a lot of trickiness about realistic / modern CPU's that makes the things I was on about more difficult than they should be.
11:09:59 <Cale> nonono, this is a different kind of algebra
11:10:05 <danharaj> what it is
11:10:07 <danharaj> why are you lying to me
11:10:07 <ski> djahandarie : er, imagine s/data Stream/codata Stream/
11:10:17 <Cale> http://en.wikipedia.org/wiki/Eilenberg%E2%80%93Moore_algebra#Algebras_for_a_monad
11:10:30 <Cale> It's similarish
11:10:36 <Cale> but it insists on some laws
11:10:42 <byorgey> it's the same thing, with additional laws, right?
11:10:46 <Cale> yeah
11:10:52 * ski still doesn't really understand Eilenberg-Moore :/
11:11:02 <littlebobby> wli, thanks
11:11:09 <msieradzki> I don't understand the error here: http://hpaste.org/48512 is it caused by monomorphism restriction (I disabled it with LANGUAGE)?
11:11:12 <danharaj> Cale: I vaguely think that those algebras were the first things to be called F-Algebras, and then the weaker notion was developed.
11:11:37 <dylukes> note to self: actually finish Awodey
11:11:41 <avartanian> Cale This is a good thing. Shows I'm not crazy for wanting to do something like this.
11:11:49 <dylukes> probably covered in there
11:11:51 <danharaj> Let's not get ahead of ourselves.
11:12:05 * ski is irritated every time someone says "algebra" when they mean "monoid"
11:12:06 <Cale> ski: You think of TX as consisting of all "expressions" built over constants in X in some language described by the monad T
11:12:09 <byorgey> msieradzki: no, that's not caused by the MR
11:12:15 <msieradzki> oh well I've got 1 idea (as usual after pasting to irc) that it might be that I don't specify
11:12:16 <Cale> ski: and h: TX -> X as "evaluating" those expressions
11:12:17 <msieradzki> that it's float vector
11:12:24 <msieradzki> so Num instance leads nowhere
11:12:35 <byorgey> msieradzki: there's some type variable involved that GHC doesn't know how to instantiate
11:12:51 <byorgey> msieradzki: yes, adding a type signature to vb ought to solve it
11:13:01 <djahandarie> ski, I mean the construct data itself, not an instance of it.
11:13:02 <Cale> ski: For example, consider the monad which arises from the forgetful/free adjoint pair between vector spaces and sets
11:13:09 <msieradzki> it does, I just wondered where the problem lies
11:13:18 <ski> djahandarie : me too
11:13:20 <msieradzki> but I forgot that it has no way to figure out it should be float
11:13:25 <Cale> ski: This monad sends a set X to the set of all formal linear combinations of elements of X
11:13:27 <djahandarie> ski, I still don't see it then :p
11:13:35 <Cale> ski: and an algebra for that monad
11:13:43 <djahandarie> ski, what category are we in such that the opposite category yields something like codata?
11:14:00 <ski> djahandarie : given an endo-functor `F', the initial and terminal `F'-algebras
11:14:06 <linduxed> ok here's an intersting one
11:14:10 <bgamari> How is it that a simple function unpacking a tuple, f (a,o) = o, could allocate memory?
11:14:13 <Cale> is a set V which has a function h: TV -> V, that sends a linear combination of elements of V to an element of V (which is like a holistic combination of addition and scalar multiplication)
11:14:35 <Cale> and if you work out what the algebra laws say, they'll turn out to be exactly the vector space axioms
11:14:37 <monochrom> yikes, so IO doesn't have an Eilenberg-Moore IO-algebra, since I can't do IO String -> String
11:14:38 <byorgey> bgamari: it might be that the tuple was represented by some unevaluated thunk
11:14:42 <linduxed> Could not deduce (Fractional a) arising from a use of `/'  is what i get when i try to load this code http://pastie.org/2141133
11:14:56 <linduxed> how could i fix that ?
11:15:05 <Cale> (only, expressed in terms of taking linear combinations of linear combinations, rather than separated into little pieces)
11:15:07 <byorgey> bgamari: so upon evaluating f it has to evaluate the pair to weak head normal form first, which might allocate memory
11:15:25 <bgamari> byorgey: And this would be counted against f?
11:15:27 <monochrom> oh, unless I play with IO (IO a) -> IO a
11:15:32 <Cale> Well, one will be, the other is that h (return x) = x
11:15:32 <bgamari> byorgey: by the profiler
11:15:33 <ski> Cale : `h' a morphism in `Set' or `Vect' ?
11:15:38 <Cale> in Set
11:15:40 <byorgey> bgamari: I'm not sure, just guessing
11:15:54 <wli> This stupid C library is calling abort() and System.Posix.Signals.installHandler sigABRT Ignore Nothing is not working.
11:16:23 <djahandarie> ski, ah, I think you're right
11:16:29 <Cale> So the algebras for this monad are sets together with functions h which amount to being an appropriate way of defining what vector spaces are.
11:16:49 <Cale> (in terms of sets)
11:17:39 <joe6> is there a better way of writing this: http://pastebin.com/mBPMRDsr
11:17:41 <mauke> The paste mBPMRDsr has been copied to http://hpaste.org/48515
11:17:54 <joe6> i have a bunch of concatenations on map results
11:19:08 <Cale> ski: Every algebraic theory (consisting of some operations and some equational laws they have to satisfy) corresponds to some monad on Set, such that the structures satisfying the theory are the algebras for the monad.
11:19:46 <ski> Cale : and the Eilenberg-Moore category is here ?
11:20:09 <Cale> ski: Equivalent to the category of vector spaces
11:20:49 <linduxed> could someone give me a hint as to how i should modify the division on line 4 in http://pastie.org/2141133 ?
11:20:52 <Cale> (or in general, the category of such operational algebras and the appropriate notion of morphisms between them)
11:21:05 <byorgey> joe6: are fx, fy, and fz all the same type?
11:21:21 <Cale> linduxed: You need to modify the type signature
11:21:23 <linduxed> i'm quite sure that the problem lies in a type mismatch, but I don't know how to solve it
11:21:33 <bgamari> What does the BLACKHOLE closure description in the heap profiling results mean?
11:21:40 <Cale> linduxed: Num isn't enough to ensure you're allowed to divide
11:21:42 <bgamari> It seems to be chewing up memory
11:21:50 <Cale> linduxed: You need Fractional
11:22:00 <dylukes> kmc: btw, i'm quite ashamed, I couldn't even get past the third one without having to look up help
11:22:06 <byorgey> joe6: if so you can write   ($) <$> [fx, fy, fz] <*> directionsData
11:22:06 <linduxed> Cale: oh....
11:22:09 <dylukes> though, I refuse to look at the C source, so that's part of it.
11:22:13 <linduxed> Cale: i would never have guessed
11:22:16 <Cale> linduxed: You can also just delete the type signature
11:22:23 <Cale> linduxed: and ask ghci to guess it for you
11:22:27 <Cale> :t myMean
11:22:28 <lambdabot> Not in scope: `myMean'
11:22:33 <dylukes> At least I'll end up learning gdb better
11:22:41 <linduxed> Cale: i've been taught to always include a signature
11:22:53 <Cale> @let myMean [] = 0; myMean xs = sum xs / fromIntegral (length xs)
11:22:54 <lambdabot>  Defined.
11:22:56 <linduxed> Cale: so that my functions become clearer
11:22:59 <Cale> :t myMean
11:23:00 <lambdabot> forall t. (Fractional t) => [t] -> t
11:23:17 <Cale> Sure, but if you're having trouble with one, you can always ask the compiler for it
11:23:24 <Cale> and then paste it in when you're satisfied
11:23:28 <linduxed> Cale: true
11:23:58 <Cale> :t (/)
11:23:59 <linduxed> Cale: so i take it Num is basically the same as Fractional, but it's not made for division?
11:23:59 <lambdabot> forall a. (Fractional a) => a -> a -> a
11:24:12 <linduxed> ok
11:24:14 <dylukes> linduxed: FACT: Haskell number hierarchy is fucked up.
11:24:14 <Cale> Yeah, Num is a superclass of Fractional
11:24:25 <Cale> Hey, it's not *that* fucked up
11:24:26 <linduxed> dylukes: hahaha
11:24:39 <linduxed> Cale: oh i see
11:24:39 <Cale> It's actually a lot more sensible than it looks at first
11:24:53 <Cale> But there are a couple things which could be done to clean it up and make it more general
11:24:55 <linduxed> Cale: i'm sure it is, it's just that i'm not used to it yet
11:24:56 <dylukes> Is there a flowchart in existance?
11:25:15 <Cale> Yeah, in the report, there's a graph of the class relationships for the Prelude stuff
11:25:33 <Cale> http://www.haskell.org/onlinereport/classes.gif
11:26:00 <Cale> The naming is a bit weird
11:26:11 <monochrom> Num is roughly ring
11:26:18 <Cale> Kinda
11:26:26 <Cale> Except that we want Float as an instance
11:26:29 <Cale> ;)
11:26:39 <Cale> and there's abs and signum in there, but there probably shouldn't be
11:26:52 <monochrom> valuation ring (!!)
11:27:06 <Cale> haha, yeah
11:27:29 <Cale> well, sorta
11:27:36 <monochrom> or I guess euclidean domain or something
11:27:58 <Cale> :t abs
11:27:59 <lambdabot> forall a. (Num a) => a -> a
11:28:02 <monochrom> @type div
11:28:02 <lambdabot> forall a. (Integral a) => a -> a -> a
11:28:47 <monochrom> well, the hierarchy doesn't copy from abstract algebra because it is more pragmatically inspired
11:29:28 <Cale> yeah, and I kinda think that's appropriate, so long as we have floating point arithmetic hanging around
11:29:59 <Cale> But there are some names like Real, which make no sense :P
11:30:02 <Cale> :t toRational
11:30:02 <lambdabot> forall a. (Real a) => a -> Rational
11:30:09 <Cale> ^^ whaaaaaaaat ;)
11:31:53 <joe6> byorgey, thanks.
11:31:59 <monochrom> well the more important point is "class (Num a, Ord a) => Real a ...". the total order.
11:32:24 <monochrom> toRational is probably just icing
11:33:27 <Cale> But it means that computable real types need to implement toRational in some kinda-broken fashion (by taking some arbitrary approximation perhaps)
11:33:55 <Cale> Which seems sort of ironic for a Real class ;)
11:34:24 <azaq23> > toRational pi
11:34:24 <lambdabot>   884279719003555 % 281474976710656
11:34:32 <kmc> yep, that's pi
11:34:35 <kmc> > toRational τ
11:34:36 <lambdabot>   Not in scope: `
11:34:40 <wli> Finite bounds on precision were presumed.
11:34:40 <Cale> > toRational (pi :: CReal)
11:34:41 <lambdabot>   *Exception: CReal.toRational
11:34:45 <Cale> ^^ ;)
11:35:12 <monochrom> computable reals already break == of Num
11:35:49 <monochrom> "The class Num of numeric types is a subclass of Eq, since all numbers may be compared for equality"
11:35:50 <wli> SIGABRT coming from this C library when it errors is refusing to be dealt with by sigaction
11:36:05 <monochrom> the whole hierarchy has finitism in mind
11:36:48 <hpaste> “Ben Gamari” pasted “GC churn” at http://hpaste.org/48519
11:36:57 <djahandarie> bgamari, again? :p
11:37:08 <djahandarie> Ah, different file this time :)
11:38:07 <wli> [pid 16612] rt_sigaction(SIGABRT, {SIG_IGN, [], 0}, NULL, 8) = 0 ... [pid 16612] tgkill(16611, 16612, SIGABRT) = 0, [pid 16612] --- SIGABRT (Aborted) @ 0 (0) ---
11:38:31 * djahandarie recommends    data Datum v = Datum !Int !v
11:39:33 <kmc> monochrom, indeed.  real numbers can't be compared for equality!
11:39:45 <bgamari> djahandarie: I think it changed slightly ;)
11:39:51 <bgamari> djahandarie: Ahh, thanks!
11:41:13 <kmc> haha, great quit message
11:41:29 <monochrom> haha
11:41:33 <dylukes> I think mine is still EXC_BAD_ACCESS
11:41:50 <dylukes> oh, no I don't have any turned on.
11:42:17 <kmc> dylukes, what level are you on now?
11:42:34 <dylukes> kmc: Im a bit busy, but I'm on level 4
11:42:36 <kmc> bgamari, a blackhole is a thunk currently being evaluated
11:42:48 <dylukes> I had to look for help on 3 though, so I'm brushing up on gdb and some basic asm first
11:42:51 <djahandarie> bgamari, you are probaly also getting some overhead from the dictionary passing from Num v =>
11:42:53 <shachaf> Level?
11:42:59 <stevelawren> Hello, irc://irc.freenode.net/#cabal is very quiet at the moment so member:I'll ask this here again if that's ok - member:I know what cabal puts local binaries (or aliases to) in ~/.cabal/bin. What is the equivalent for globally installed binaries? What do member:I need to add to my path for global binaries?
11:43:04 <kmc> shachaf, of http://io.smashthestack.org:84/
11:43:18 <mjrosenb> @djinn (a -> Maybe b) -> (a,c) -> Maybe (b,c)
11:43:19 <lambdabot> f a (b, c) =
11:43:19 <lambdabot>     case a b of
11:43:19 <lambdabot>     Nothing -> Nothing
11:43:19 <lambdabot>     Just d -> Just (d, c)
11:43:22 <dmwit> Oh, wli, good to see you! It's been a long time.
11:43:55 <mjrosenb> kmc: is that the game that you told me about with exploiting binaries?
11:44:00 <kmc> yeah
11:44:07 <dmwit> stevelawren: Check ~/.cabal/config, the "prefix" and "bindir" settings.
11:44:18 <dmwit> stevelawren: (In the "install-dirs global" section.)
11:44:45 <mietek> Is there a way to choose one of two overlapping instances for my type synonym instance?
11:44:56 <djahandarie> bgamari, also, getting rid of dAbs and dOrd and directly pattern matching in dot might helps things in case they aren't getting inlined.
11:44:59 <mietek> I want to have a special notion of equality on tuples, for example
11:45:09 <dmwit> mietek: Use newtype.
11:45:10 <mietek> Just for syntactic sweetness
11:45:15 <bgamari> djahandarie: Dictionary passing?
11:45:18 <kmc> hide the prelude instance
11:45:25 <mietek> kmc: aha!  How?
11:45:30 <kmc> hmm
11:45:32 <djahandarie> bgamari, yeah, a 'dictionary' gets passed at runtime when you use typeclasses.
11:45:32 <bgamari> djahandarie: The polymorphism implied by Num v => is costing me?
11:45:35 <djahandarie> Yes.
11:45:38 <dmwit> {-# LANGUAGE NoImplicitPrelude #-}
11:45:38 <bgamari> Ouch
11:45:39 <kmc> -XNoImplicitPrelude plus an explicit import
11:45:43 <Eduard_Munteanu> If it's special, do you need it to be (==)?
11:45:49 <dmwit> And don't import anything that uses the Prelude either.
11:45:51 <kmc> except, i think you can't import anything
11:45:52 <bgamari> djahandarie: Is there no way around this?
11:45:53 <dmwit> That's a hard way to go, I think.
11:45:55 <kmc> yeah
11:45:56 <djahandarie> bgamari, sure there is.
11:46:03 <mietek> Let's see if it's more pain than it's worth
11:46:05 <djahandarie> bgamari, you can use the SPECIALIZE pragma.
11:46:10 <bgamari> djahandarie: I'm surprised it can't compile a version dot of dot specifized for dot
11:46:13 <bgamari> Int rather
11:46:14 <bgamari> ahh
11:46:15 <shachaf> kmc: Is the "Too many open files" error supposed to be part of it?
11:46:20 <bgamari> djahandarie: Excellent
11:46:20 <dmwit> mietek: You can ask GHC to choose an instance for you, but you can't direct the choice yourself.
11:46:27 <kmc> shachaf, heh, no, i think that's just their server being overloaded
11:46:30 <stevelawren> dmwit: bindir relates to prefix, which relates to the individual package name (prefix: /Library/Haskell/$compiler/lib/$pkgid), so the binaries are just put into package subdirectories - is there no global directory of binaries like you get when you install locally?
11:46:36 * shachaf will look later, then.
11:47:03 <dmwit> stevelawren: You may set one yourself, of course.
11:47:14 <stevelawren> dmwit: sorry, just found it - /Users/XXXX/Library/Haskell/bin
11:47:15 <stevelawren> symlink-bindir
11:47:45 <ski> bgamari : .. `BLACKHOLE' sounds like infinite loops a la `let x = x in x'
11:47:50 <djahandarie> bgamari, I think if you   module Main (main) where   at the top it should be able to optimize more aggressively.
11:48:04 <stevelawren> thanks very much
11:48:09 <thoughtpolice> djahandarie: why?
11:48:17 <copumpkin> djahandarie: I think it just sticks that in implicitly if you leave it out
11:48:25 <copumpkin> djahandarie: oh, you mean not implicitly exporting everything?
11:48:26 <thoughtpolice> (curious, never heard that before, i thought it was implicit)
11:48:44 <copumpkin> that'd make sense, I guess
11:48:47 <djahandarie> Yeah, not exporting everything is what I mean.
11:51:21 <thoughtpolice> hm, i do wonder if that actually makes a difference. something in my brain tells me it wouldn't, but i wouldn't be surprised if i was wrong
11:51:26 <bgamari> djahandarie: Done
11:51:44 <bgamari> djahandarie: Unfortunately it doesn't seem like the strictness in Datum made any difference
11:51:51 <djahandarie> thoughtpolice, yeah I'm not entirely sure about it since I always put it in anyways, not sure of the exact implicit behavior
11:52:04 <djahandarie> thoughtpolice, I do know that exporting stuff prevents certain optimizations though.
11:52:11 <bgamari> ski: With small enough arrays the program terminates with the right answer, so I think the logic is correct
11:52:35 <thoughtpolice> huh, i wonder what kinds of optimizations are inhibited
11:52:39 <djahandarie> bgamari, can I see the current version?
11:53:14 <bgamari> djahandarie, ski: Unfortunately now the thing just exits with a stack overflow whenever I run with a large enough data set for the profiler to be useful
11:53:23 <copumpkin> thoughtpolice: if something is exported, it needs to be general and seems like it'd be less likely to be inlined
11:53:29 <copumpkin> thoughtpolice: not sure if GHC actually does this
11:53:39 <hpaste> “Ben Gamari” pasted “New GC churn” at http://hpaste.org/48521
11:53:47 <copumpkin> but if something isn't exported and is typeclass-polymorphic, it could be specialized easily
11:54:03 <copumpkin> assuming it's only used for a handful of instances
11:54:03 <djahandarie> bgamari, try killing dAbs and dOrd like I mentioned
11:54:09 <thoughtpolice> copumpkin: well, the new inliner sticks the original, unoptimized definition into interface files, and then those unoptimized versions are inlined/optimized at call sites when it's beneficial, doesn't it? so in terms of intra-module optimizations, the inliner will inline as it sees fit, and in other modules, it'll still inline the same way with the original copy
11:54:25 <thoughtpolice> this is apparently one of the major changes that makes the inliner more predictable, because previously it would put optimized definitions in the interface files
11:54:28 <thoughtpolice> (i think)
11:54:35 <bgamari> djahandarie: I seem to have quite a knack at finding ways to fool ghc producing inefficient code ;)
11:54:36 <copumpkin> that's only if you mark something as inlinable isn't it?
11:54:39 <bgamari> djahandarie: alright
11:54:54 <thoughtpolice> copumpkin: you may be right
11:54:56 * thoughtpolice searches
11:55:46 <djahandarie> i.e.,     dot ((Datum aa _):as) ((Datum bb _):bs)
11:56:16 <djahandarie> I don't see why making Datum a strict pair would cause a stack overflow, it has nothing to do with your recursion.
11:56:18 <ski> djahandarie : ERROR: redundant brackets detected
11:57:13 <ski> (hm, sorry .. i see that's probably bgamari's code)
11:57:34 <bgamari> djahandarie: Perhaps the use of the word "now" in my statement was misleading
11:57:40 <bgamari> djahandarie: It did this before as well
11:57:59 <thoughtpolice> copumpkin: according to this - http://hackage.haskell.org/trac/ghc/wiki/Status/Oct10 - the new inliner even affects things marked INLINE, however, something I remember reading on g-h-u somewhat seems to contradict this?
11:58:08 <copumpkin> well, I just mean
11:58:12 <copumpkin> things with no markings at all
11:58:15 <copumpkin> neither inline or inlinable
11:58:22 <copumpkin> if I were Mr Compiler
11:58:38 <copumpkin> I'd be more inclined to just inline the code, even if large, if it was used in only a couple of places and wasn't exported
11:58:44 <avartanian> And I'm assuming there is no way to make a typeclass look like an operator, i.e. class (-->) a where ...
11:59:06 <bgamari> djahandarie: For the record, dot requires the second entry in Datum
11:59:19 <djahandarie> Yeah, I see that now
11:59:23 <thoughtpolice> copumpkin: yeah i think you're right, these rules are only in effect for things marked inline/inlineable - i thought they generally affected how the inliner does it's thing
12:01:51 <hpaste> “Ben Gamari” pasted “GC churn (Accessors removed)” at http://hpaste.org/48522
12:02:20 <hpaste> “Ben Gamari” annotated “GC churn (Accessors removed)” with “GC churn (Profile)” at http://hpaste.org/48522#a48523
12:03:31 <hpaste> “Ben Gamari” annotated “New GC churn” with “New GC churn (profile)” at http://hpaste.org/48521#a48524
12:04:12 <djahandarie> bgamari, so that helped a bit eh?
12:05:33 <bgamari> djahandarie: Damn, not actually
12:05:48 <bgamari> djahandarie: The profile from the old code was with a different data set size
12:06:03 <djahandarie> Heh okay, I would have surprised if that really did it.
12:06:15 <hpaste> “Ben Gamari” annotated “New GC churn” with “New GC churn (correct profile)” at http://hpaste.org/48521#a48525
12:06:34 <djahandarie> Well, it did help some :p
12:07:16 <wli> (a) set signal handler/disposition of SIGABRT to SIG_IGN (b) call C library after all sorts of pain (c) C library does abort(3) (d) for whatever reason, the signal is not ignored as it should be.
12:07:22 <bgamari> djahandarie: Indeed it did, mysteriously
12:07:50 <bgamari> djahandarie: Although at what cost :P
12:08:23 <bgamari> djahandarie: Anyways, clearly I'm still missing something critical
12:08:53 <djahandarie> bgamari, are you compiling with -funbox-strict-fields?
12:09:05 <bgamari> Unfortunately it seems the program runtime is too short for the profiler to produce output
12:09:13 <copumpkin> you can't unbox polymorphic fields
12:09:15 <bgamari> djahandarie: Nope
12:09:20 <copumpkin> I vaguely remember Datum being polymorphic
12:09:20 <djahandarie> Ah, copumpkin is right, nevermind
12:09:27 <copumpkin> but the !Int (iirc) works
12:09:35 <bgamari> bah
12:09:39 <djahandarie> It will inbox just the first part?
12:09:40 <wli> Last annotation on http://hpaste.org/48501
12:09:51 <djahandarie> unbox*
12:10:04 <copumpkin> yeah
12:10:17 <bgamari> Perhaps if I rip out the polymorphism for now (although that is quite a bummer)
12:10:59 <djahandarie> bgamari, you can always add {-# UNPACK #-} before the !Int if unbox-strict-fields doesn't catch it for whatever reason
12:11:12 <ski> (s/Datum being polymorphic/Datum being parametric/)
12:11:27 <copumpkin> bgamari: is it a "closed" sort of thing?
12:11:34 <copumpkin> or could anything go into there?
12:12:02 <bgamari> copumpkin: Really just Nums
12:12:26 <copumpkin> hm, doesn't help much
12:12:34 <djahandarie> It'd be interesting if you could specialize a data type.
12:13:00 <bgamari> Although I don't think the polymorphism is the problem
12:13:12 <bgamari> I just changed Datum to data Datum = Datum !Int !Int
12:13:16 <bgamari> and nothing improved
12:13:24 <djahandarie> With -funbox-strict-fields on?
12:14:03 <djahandarie> It should help at least some with everything unboxed
12:15:12 <bgamari> djahandarie: Yes, with unbox-strict-fields
12:15:32 <hpaste> “Ben Gamari” annotated “New GC churn” with “New GC churn (specialized with funbox-strict-fields” at http://hpaste.org/48521#a48526
12:15:58 <bgamari> The compiler seems to think I'm doing something quite tricky
12:16:20 <djahandarie> bgamari, it went twice as fast.
12:16:26 <djahandarie> You edited the dOrd/dAbs version
12:18:36 <bgamari> djahandarie: Yes I did
12:18:47 <bgamari> djahandarie: The real problem is the memory consumption
12:18:59 <bgamari> This algorithm should be able to run with constant memory
12:19:52 <bgamari> I really don't know what is causing the stack overflows
12:20:18 <avartanian> Another quick q: let's say I have data Person = Person { firstName :: String, lastName :: String } ... but there are like 20 such fields in the structure. It's a big ol' structure. And I wanna write setFirstname :: String -> Person -> Person. Is there any shortcut constructor to using Person firstName lastName to construct the thing?
12:20:36 <avartanian> i.e. record structure gives me accessors, does it give me (immutable) mutators as well?
12:20:44 <djahandarie> bgamari, it doesn't stack overflow for me
12:20:49 <djahandarie> Oh, it does
12:21:11 <azaq23> avartanian: If p is an object of type Person, do p { firstName = "blah" }
12:21:26 <azaq23> you'll get a new person value with different firstName
12:21:50 <avartanian> azaq23 Oh brilliant thanks so much!
12:22:00 <avartanian> Sorry for such a newb question.
12:22:26 <ski> avartanian : note that this is unfortunately painful syntaxwise, with nested record updates. lenses / functional references help some with this
12:22:31 <bgamari> djahandarie: Yeah, and everything we've looked at so far spents >50% of CPU time in the GC
12:22:38 <Wooga> lol, amazing
12:22:55 <Wooga> haskell mod in emacs feels less "autopilot" then vim one
12:22:57 <bgamari> I just don't understand how I manage to trip up the compiler so easily
12:22:58 <Wooga> (by default)
12:23:57 <avartanian> ski so if you had big records, you'd definitely use Data.Lenses?
12:23:59 <Wooga> you have to press all C-c, <Tab> and other things to keep it identing right
12:24:38 <lispy> preflex: seen pastorn
12:24:39 <preflex>  pastorn was last seen on #haskell 9 days, 22 hours, 59 minutes and 7 seconds ago, saying: gwern: ^^^
12:26:53 <ski> avartanian : well, more like if i had *nested* records
12:27:19 <ski> avartanian : wide records are not really very painful with the record update syntax
12:27:52 <tommd> preflex: seen lispy working on darcs
12:27:53 <preflex>  lispy was last seen on #haskell 3 minutes and 14 seconds ago, saying: preflex: seen pastorn
12:28:16 <tommd> preflex, you need to parse English better.  If I can learn it so can you.
12:28:40 <ski> avartanian : i mean `rec { foo = (foo rec) { bar = (bar (foo rec)) { baz = ...}} }' is painful
12:29:18 <nus> wli, was that happening in GHCi?
12:30:54 <bgamari> djahandarie: Ideas?
12:31:09 <bgamari> I really don't know how to get to the bottom of the stack overflow
12:31:21 <bgamari> does the profiler disable TCO as well?
12:31:34 <augur> @tell edwardk i think some of the problem with blocking is knowing what the type systems should look like in the first place
12:31:34 <lambdabot> Consider it noted.
12:33:14 <djahandarie> bgamari, the problem is that you are using + which is strict
12:33:27 <djahandarie> This can't be tail call optimized unless you rewrite it
12:33:36 <djahandarie> Look at the difference between foldr and foldl'
12:33:43 <djahandarie> You want foldl'
12:33:53 <djahandarie> I need to grab lunch though, I'll be back in a bit
12:34:09 <bgamari> djahandarie: Alright
12:34:09 <danharaj> I have a computational complexity question. Consider merging binary trees, from the leaves up. An example is merge sort on a binary tree where the leaves are singleton lists. Merge sort combines leaves by merging them in linear time. If you work out the total work it does, you get a complexity of n*log n for merge sort. What do you get if instead of linear work for each pair of leaves, you do O(k*log k) work?
12:34:14 <bgamari> djahandarie: No worries. Thanks!
12:34:45 <danharaj> Is it O(n * (log n)^2)?
12:36:36 <bgamari> djahandarie: Although I must say I'm not sure what I'm going to be folding
12:37:11 <bgamari> djahandarie: Since I sometimes move forward in a, sometimes in b
12:37:20 <bgamari> djahandarie: I can't just fold over zip a b
12:39:02 <lispy> tommd: I think I gave up on^W^W^Wmoved on from working on darcs
12:47:52 <quiznilo> does GHC always take forever to compile?
12:48:04 <quiznilo> what is it bootstrapping or something?
12:48:42 <byorgey> quiznilo: yes.
12:48:46 <byorgey> and yes.
12:49:00 <byorgey> quiznilo: out of curiosity, why are you compiling GHC?
12:49:10 <quiznilo> I iz running gentoo!
12:49:17 <byorgey> ah.
12:49:19 <quiznilo> an app I want to install deps on haskell
12:49:24 <quiznilo> I suppose coded in haskell
12:49:29 <byorgey> which app?
12:49:32 <quiznilo> though I've always been curious about haskell
12:49:42 <quiznilo> some gnome alarm clock deal
12:49:48 <quiznilo> http://alarm-clock.pseudoberries.com/#download
12:50:18 <kmc> hehe
12:50:26 <quiznilo> http://alarm-clock.pseudoberries.com/ sorry
12:50:26 <kmc> quiznilo, Haskell is a cool language! you should stay here and learn it
12:50:36 <kmc> and yes, GHC takes a long time to compile itself
12:50:40 <danharaj> I don't see any haskell source files in the source o.O
12:50:47 <kmc> GHC is a pretty sophisticated compiler, which hurts both sides of that equation :)
12:50:48 <quiznilo> I like haskell cause no one will bitch at me when I use recursion
12:50:56 <quiznilo> and I love recursion
12:51:14 <kmc> quiznilo, oh no, do you work at one of those companies where recursion is considered an advanced technique for wizards only?
12:51:38 <quiznilo> danharaj: the thing deps on GIO
12:52:06 <quiznilo> kmc: I'm not a professional coder
12:52:10 <quiznilo> I dabble with C#
12:52:19 <kmc> cool
12:52:25 <quiznilo> people still complain at me about using recursion
12:53:04 <kmc> heh, who?
12:53:07 <danharaj> Well to be fair, recursion is a pain in the ass in a lot of languages.
12:53:07 <quiznilo> no, they don't consider it 'advanced', they consider it a 'bad programming technique', and complain about shredding the stack
12:53:22 <danharaj> Good news everyone! Haskell doesn't have a stack.
12:53:27 <kmc> a lot of C# programmers are pretty sympathetic to functional programming
12:53:28 * danharaj </Farnsworth>
12:53:34 <kmc> they keep "borrowing" FP features ;)
12:53:45 <quiznilo> o rly?  stackless... I had heard about stackless python
12:54:00 <quiznilo> they use stackless python in eve online
12:54:04 <danharaj> Well the guys who work on F# are in the same building as the GHC Simons, no?
12:54:15 <byorgey> danharaj: yes, right down the hall
12:54:16 <kmc> quiznilo, the Haskell standard says nothing about stacks, afaik
12:54:34 <kmc> GHC has a "stack" and a "heap" but they're used for very different things from what a C programmer might expect
12:54:45 <kmc> and implemented differently
12:54:50 <bgamari> djahandarie: Thanks, it looks like your hint was enough
12:54:54 <quiznilo> I'll tell people that when they complain about my using recursion in haskell
12:54:58 <bgamari> djahandarie: I rewrote it using seq
12:54:59 <kmc> hehe
12:55:27 <hpaste> “Ben Gamari” pasted “No GC Churn!” at http://hpaste.org/48527
12:55:37 <danharaj> Like many things in programming, iteration is just a simple degenerate form of recursion.
12:55:42 <byorgey> quiznilo: if you want to further blow their minds, tell them that Haskell *doesn't have loops*, just recursion
12:55:50 <quiznilo> nice
12:55:51 <quiznilo> :D
12:55:56 <kmc> quiznilo, you can still blow the stack in Haskell
12:55:58 <kmc> in GHC Haskell i mean
12:56:11 <kmc> but it's a result of nested pattern matching, not nested function calls
12:56:20 <ezyang> We actually have two stacks.
12:56:23 <kmc> you can also write things which are obviously not tail recursive, yet run in constant space
12:56:24 <Cadynum> is there a way to block a thread indefinitely in haskell? (without mvars and such)
12:56:24 <ezyang> It's all very hilarious.
12:56:36 <kmc> Cadynum, forever (threadDelay maxBound)
12:56:58 <kmc> quiznilo, because (say) a lazy list producer and a lazy list consumer effectively form coroutines
12:57:03 <Peaker> Cadynum: forever (threadDelay maxBound) ?
12:57:22 <Peaker> ezyang: two stacks?
12:57:34 <ezyang> GHC Haskell, yep.
12:57:43 <ezyang> One traditional stack, and one for spilling registers.
12:58:03 <kmc> ezyang, is there still a split between pointers and primitives as well?
12:58:07 <Cadynum> kmc, no non-hacky way? or does it actually delay it forever and not just maxBound us?
12:58:23 <kmc> Cadynum, it delays forever, in increments of maxBound
12:58:29 <kmc> it will wake up briefly in between
12:58:30 <kmc> do you care?
12:58:36 <Cadynum> oh yeah, i missed the forever
12:58:40 <quiznilo> http://paste.pocoo.org/show/424016/ <-- evil recursive ways
12:58:53 <Cadynum> not really, just wondering if there's some non hacky way to solve it
12:58:59 <kmc> Cadynum, without MVar also?
12:59:03 <Cadynum> yeah
12:59:03 <kmc> or TVar?
12:59:17 <Cadynum> the thread is supposed to "wake up" by an exception
13:00:03 <quiznilo> that is a silly example though, I wouldn't parse a large CSV using recursion
13:00:53 <quiznilo> in C#
13:00:57 <kmc> Cadynum, on UNIX you could make a pipe and read one end of it
13:01:12 <kmc> or maybe just call pause(2)
13:01:56 <Cadynum> indeed. but they are all hacky :)
13:02:59 <benmachine> Cadynum: why not just signal with an MVar instead of an exception?
13:03:04 <bgamari> djahandarie: Is this roughly what you meant? http://hpaste.org/48527
13:03:22 <ezyang> kmc: Mmm, I don't think so.
13:03:41 <kmc> ezyang, yeah, I think it was in the original STG paper, but they got rid of it by the eval/apply paper
13:04:18 <Cadynum> benmachine, i need to run an io computation which might block indefinitely, so it needs to be interrupted externally by an exception
13:04:28 <Cadynum> benmachine, it will either sit at this io computation or just sit and wait for a signal
13:04:43 <benmachine> ah I see
13:04:45 <benmachine> fair enough
13:12:23 <quiznilo> hey this is a cool little app
13:22:59 <linduxed> so i was thinking of using sortBy to sort a list of lists by their length
13:23:23 <linduxed> so i know that i will be using sortBy and length... in some way
13:23:33 <linduxed> but i don't understand how to combine them
13:23:38 <linduxed> any ideas?
13:25:02 <ski> > sortBy (comparing length `mappend` compare) (words "A quick brown fox jumps over the lazy dog")
13:25:03 <lambdabot>   ["A","dog","fox","the","lazy","over","brown","jumps","quick"]
13:25:06 <tommd> linduxed: "comparing"
13:25:10 <ski> linduxed : like that ^ ?
13:25:47 <tommd> > sortBy (comparing length) [[(), (), ()], [ () ], [ (), ()]]
13:25:48 <lambdabot>   [[()],[(),()],[(),(),()]]
13:25:59 <linduxed> yeah that was the result i was looking for...
13:26:16 <linduxed> but i can't say i understand sortBy, or taht comparing function either
13:26:23 <ski> @type comparing
13:26:23 <linduxed> *understand better
13:26:24 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
13:26:34 <ski> @type comparing length
13:26:35 <lambdabot> forall a. [a] -> [a] -> Ordering
13:26:38 <ski> @type comparing fst
13:26:38 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
13:27:19 <benmachine> @type comparing reverse
13:27:20 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Ordering
13:27:21 <ski> linduxed : `comparing f' means the comparision function which compares the `f' parts of the inputs
13:27:38 <benmachine> > comparing reverse [1,2,3,4] [1,1,4,4]
13:27:38 <ski>   (comparing f) x y = compare (f x) (f y)
13:27:38 <lambdabot>   LT
13:27:46 <benmachine> > compare [1,2,3,4] [1,1,4,4]
13:27:47 <lambdabot>   GT
13:27:51 <ski> @type compare
13:27:52 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
13:27:56 <ski> @type sortBy
13:27:56 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
13:28:18 <ski> linduxed : `sortBy' wants a comparing function, like `compare'
13:28:46 <rhd> is there anything like Processing for haskell?
13:28:55 <linduxed> ski: ok that explains it a bit
13:29:33 <linduxed> ski: i'll stare at that stuff you and lambdabot wrote, hopefully i'll understand it soon
13:29:49 <acowley> rhd: No, but gloss is a good start
13:29:55 <Peaker> @type sortBy . comparing
13:29:55 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> [a]
13:30:47 <rhd> acowley: that looks good enough
13:30:59 <djahandarie> bgamari, yep, that looks about right.
13:31:29 <ski> linduxed : for the  comparing length `mappend` compare  trick, see <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx> by Cale
13:32:30 <monochrom> haha, monoids in my programming language
13:33:30 <bgamari> djahandarie: Excellent. Thanks!
13:33:43 <kmc> a monoid is like a centipede
13:33:48 <mjrosenb> monoids: the curiously strong typeclass
13:34:13 <monochrom> a human monoid is like a human centipede
13:34:28 <tgeeky> monads? in *my* programming language? It's more likely than you'd think! [click here]
13:34:33 <tgeeky> s/monads/monoids/
13:34:53 <djahandarie> bgamari, yep, no problem :)
13:35:24 <bgamari> Along the lines of my first question today, if I call Data.Vector.Unboxed.toList and try to iterate over the returned list more than once, the list will be constructed, right?
13:35:32 <quiznilo> is tgeeky a channel bot?
13:35:42 <quiznilo> oops... no heh
13:35:43 <tgeeky> yes
13:35:44 <acowley> Hm, I'd never seen that monoid technique for ordering
13:35:47 <acowley> that's really nice
13:35:52 <monochrom> all of us are bots
13:35:52 <bgamari> It seems like this really cripples the usefulness of toList
13:36:14 * tgeeky cries, what can I say to convince you I'm real? *sob*
13:36:17 <bgamari> Sometimes you really just want a list to act like a generator (in python, for instance)
13:36:50 <acowley> bgamari: why are you using toList?
13:37:25 <bgamari> acowley: I have an algorithm that works on lists but I want to work on unboxed data
13:37:38 <mjrosenb> was Cale the person that had a example of using haskell in a vaguely oo-ish way implementing a (asteroids-like) game?
13:37:44 <bgamari> acowley: In particular this, http://hpaste.org/48527
13:38:58 <monochrom> tgeeky: if your reflex action for "what is 4*0?" is grabbing a calculator, you're a human and real
13:39:54 <tgeeky> whew!
13:39:56 <kmc> :t comparing length `mappend` compare
13:39:57 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Ordering
13:40:01 <danharaj> I find it interested that bos posted the same link to /r/programming and /r/haskell with very different headlines.
13:40:05 <danharaj> interesting*
13:40:16 <tgeeky> different strokes for different folks
13:40:46 <bgamari> acowley: Any comment?
13:40:51 <kmc> right, for /r/programming you want a title like "Agile Haskell with Node.js: Real Hackers use Bitcoin"
13:41:33 <acowley> bgamari: my first reaction is that I wouldn't write it this way
13:41:45 <kmc> Cale, that's a fantastic example for monoids
13:41:52 <bgamari> acowley: How would you rather write it?
13:42:11 <bgamari> It seems like [] has the right properties for what I'm doing
13:42:14 <acowley> bgamari: thinking
13:42:15 <kmc> what was the original link article? it seems to be down
13:42:19 <bgamari> acowley: Sure
13:43:21 <ski> mjrosenb : i vaguely seem to recall so .. ask him ?
13:44:09 <kmc> oh here
13:44:10 <kmc> http://www.rubinsteyn.com/writing/monoids.html
13:44:14 <monochrom> and I suppose the corresponding /r/haskell title would be "codensity comonad for cofree coalgebra"
13:44:31 <acowley> that's a co-ok title
13:45:01 <acowley> I'm still bothered by that "co-well" wording in an early codensity paper
13:45:52 <acowley> bgamari: I suppose if you have to do the traversal in this fashion, you could think about carrying indices for each vector in the recursion rather than going through list
13:46:03 <ski> (kmc : .. and the Yoneda blurb for management types into category theoretic modelling of the workplace ?)
13:46:04 <danharaj> A distinguished professor at my university once remarked that good terminology only has at most one co- in it.
13:46:18 <danharaj> So it should be density comonads and codensity monads :p
13:46:35 <kmc> haha ski
13:46:46 <ski> danharaj : actually it *is* `CoDensity' monads and `Density' comonads ..
13:46:47 <acowley> danharaj: the coformulation of that rule is what we follow
13:46:53 <mjrosenb> Cale: did you have an example of using haskell in a vaguely oo-ish way implementing a (asteroids-like) game?
13:46:59 <kmc> yes, to get on /r/programming it is best to talk about management, not programming
13:47:06 <linduxed> ski: i think i kinda understand it now, thx for the help
13:47:07 <ski> (kmc : i assume you know which blurb i'm thinking of ?)
13:47:07 <danharaj> ski: yes it is. :p monochrom threw me off
13:47:24 <kmc> ski, nope
13:47:36 <mjrosenb> Cale: iirc, the person who had that example was hosting it on a computer that died, and it was of questionable recoverability
13:47:48 <ski> @quote Yoneda's.lemma
13:47:49 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment.
13:47:49 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
13:47:52 <ski> kmc : that one ^
13:48:08 <danharaj> for a real example, I disagree with 'cofree comonad'. :p
13:48:18 <Harbinger> http://www.golem.de/1106/84553.html
13:48:35 <Harbinger> oops. sorry
13:48:45 <monochrom> almost banned you for it :)
13:49:08 <bgamari> acowley: Hmmm
13:49:17 <bgamari> acowley: that feels like yuck for some reason
13:49:22 <acowley> bgamari: I agree
13:49:49 <acowley> bgamari: but the advantage of vectors/arrays is O(1) lookup and tight packing
13:50:19 <acowley> bgamari: I suspect there might be a way to compute indices in a somewhat clever fashion
13:50:30 <bgamari> acowley: But it seems like it should be possible to iterate over it more easily
13:50:54 <acowley> bgamari: the problem is the traversal pattern you need
13:52:04 <byorgey> acowley: were you looking for me?
13:52:24 <bgamari> acowley: How would a strictly increasing traversal help?
13:52:38 <acowley> byorgey: Yeah, I wanted to see if you were back around campus
13:52:55 <byorgey> acowley: yes, I am
13:52:56 <acowley> bgamari: the problem is the irregular step interval
13:53:08 <byorgey> acowley: although I will probably not be in tomorrow since we are having a piano delivered (!)
13:53:14 <acowley> whoa!
13:53:19 <bgamari> acowley: Yes. Rather, how would a regular step interval help?
13:53:21 <acowley> that's awesome
13:53:29 <acowley> bgamari: it could more easily be abstracted
13:53:35 <byorgey> acowley: but we should hang out sometime
13:53:47 <acowley> bgamari: the fact that you have data-sensitive traversal steps makes it harder to abstract the traversal strategy
13:53:55 <acowley> bgamari: which leaves you with more explicit plumbing than most Haskell code
13:54:10 <bgamari> bah
13:54:37 <bgamari> I was quite pleased with how nicely the code look, too
13:55:10 <bgamari> Really I just want a contiguously allocated list with cheap iteration
13:55:45 <bgamari> If I could just tell the compiler that the result of toList wants to be thrown away this would be trivial
13:56:39 <mietek> @pl do { a <- randomIO; b <- randomIO; return (a, b) }
13:56:40 <lambdabot> (line 1, column 4):
13:56:40 <lambdabot> unexpected "{"
13:56:40 <lambdabot> expecting variable, "(", operator or end of input
13:57:02 <benmachine> @. pl undo  do { a <- randomIO; b <- randomIO; return (a, b) }
13:57:02 <lambdabot> (`fmap` randomIO) . (,) =<< randomIO
13:57:09 <mietek> Ugh
13:57:13 <benmachine> mm
13:57:21 <benmachine> :t (,) <$> randomIO <*> randomIO
13:57:22 <lambdabot> forall a a1. (Random a, Random a1) => IO (a, a1)
13:57:26 <monochrom> (,) <$> randomIO <*> randomIO
13:57:35 <mietek> Aha
13:57:46 <benmachine> or liftA2 (,) randomIO randomIO
13:57:50 <monochrom> yeah
13:57:51 <benmachine> or liftM2
13:59:03 <linduxed> what's the simples way of checking whether there's only one element in a list?
13:59:26 <linduxed> i don't feel like doing the "if null (tail x)"
13:59:32 <tromp> attern matching
13:59:40 <linduxed> ok...
13:59:48 <linduxed> and an example would be?
14:00:06 <tromp> > let f [_] = True; f _ = False in f [42]
14:00:07 <lambdabot>   True
14:00:12 <monochrom> > case [1,2,3] of [x] -> "good"; _ -> "bad"
14:00:13 <lambdabot>   "bad"
14:00:19 <monochrom> > case [5] of [x] -> "good"; _ -> "bad"
14:00:20 <lambdabot>   "good"
14:01:11 <linduxed> ok now i get it
14:01:13 <linduxed> thx
14:01:17 <bgamari> acowley: I guess I could implement some sort of iterator type, having,
14:01:28 <bgamari> acowley: advance :: Iter -> Iter
14:01:31 <kmc> yes, "if null x then tail x" is clearly wrong
14:01:37 <bgamari> acowley: value :: Iter -> v
14:01:40 <kmc> i might even call it... an anti-pattern
14:01:49 <bgamari> acowley: Does anything like this exist?
14:01:50 <kmc> if i didn't instinctively want to slap everyone who talks about patterns
14:05:42 <napping> patterns? Like (x,[z])? I suppose an anti-pattern is a hypothesis like x <> True of the sort you sometimes need to prove things about functions defined by overlapping patterns
14:07:43 <kmc> :D
14:09:47 <mjrosenb> napping: are you using <> as the not-equals operator?
14:10:27 <napping> yes - you can't do a lot of proving in Haskell
14:11:38 <napping> I've only used "Program Definition" in Coq, which writes the (logical) inequaliy <>
14:14:58 <napping> Actually, I don't know of any other systems the supply hypotheses like that, but probably there are some
14:16:31 <lispy> ?hoogle (<>)
14:16:32 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
14:16:32 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
14:16:43 <lispy> napping: FWIW, I initially thought you meant that <>
14:16:58 <lispy> > text "hi" <> text " there"
14:16:59 <lambdabot>   hi there
14:18:36 * ddarius is not aware of a programming language that lacks at least one example of a monoid.
14:19:04 <dankna> what are the monoids in C, for example?
14:20:05 <kmc> integers with addition and zero
14:20:11 <dankna> ah, yes, okay
14:20:15 <kmc> boolean (&&) and True
14:20:25 <dankna> True isn't a C literal but I take your point :)
14:20:31 <dibblego> f(g(x))
14:20:36 <kmc> is 'true' a C99 literal?
14:20:36 <lispy> 0 and !0
14:20:51 <dankna> you know, I don't recall, but I don't think it is.  they tried to stick to __* for new names in C99.
14:21:00 <kmc> ok
14:21:15 <kmc> the linux kernel has a few identifiers with seven underscores in a row
14:21:31 <dankna> ouch!
14:21:33 <dankna> why?
14:21:43 <ddarius> That means you'll have to use at least 8 to be safe.
14:21:44 <kmc> crazy
14:22:46 <Veinor> in c99 bool is the literal true of type bool
14:23:03 <dankna> I thought it was __bool
14:23:04 <Veinor> er... i meant true, and c++98
14:23:11 <dankna> oh, c++98, yeah
14:23:16 <dankna> doesn't have back-compat constraints
14:23:19 <Veinor> in c99 there's _Bool
14:23:40 <dankna> and 0 and 1 are the literals, are they not?
14:23:41 <Veinor> and <stdbool.h> which #defines bool, true, and false
14:23:48 <dankna> ah!  okay
14:23:50 <dankna> that makes sense then
14:31:18 <lispy> <stool.h>?
14:35:39 <mietek> Does it make sense to have lists containing billions of entries?  I think most stdlib functions will stack overflow on large lists, right?
14:35:54 <kmc> they'll only stack overflow if they do nested pattern matching
14:36:35 <kmc> also, are you truly building a list of billions of elements all at once?
14:36:44 <kmc> or just using a lazy list as a way to stream elements from one place to another
14:37:18 <mietek> Streaming would make sense
14:37:27 <kmc> if you're really holding all that data in memory persistently, you should probably use a more efficient data type
14:37:35 <mjrosenb> sml/nj has a hilarious problem with building large lists statically
14:37:37 <mietek> Right now, I'd like to know how to find out which function is doing a stack overflow
14:42:09 <kmc> mietek, possibly ghci debugger is helpful
14:42:10 <kmc> possibly not
14:42:37 <mietek> Is it possible to get a stack trace out of GHC RTS?
14:43:13 <ddarius> The GHC "stack" isn't like what you'd see in an eager language.
14:43:21 <kmc> Maybe -xc ?
14:43:26 <kmc> +RTS -xc that is
14:43:39 <thoughtpolice> what does -xc do?
14:43:41 <Peaker> I wish "Stack overflow" in Haskell was more useful
14:43:41 <mjrosenb> mietek: is this with ghci, or compiled code?
14:43:45 <kmc> "(Only available when the program is compiled for profiling.) When an exception is raised in the program, this option causes the current cost-centre-stack to be dumped to stderr."
14:43:47 <Peaker> (ghc)
14:43:57 <kmc> "This can be particularly useful for debugging: if your program is complaining about a head [] error and you haven't got a clue which bit of code is causing it, compiling with -prof -auto-all and running with +RTS -xc -RTS will tell you exactly the call stack at the point the error was raised."
14:44:09 <thoughtpolice> ah, how nice
14:44:17 <kmc> i guess the profiling stack is more like a conventional language's stack
14:45:22 <monochrom> yeah
14:45:36 <acowley> I want datatype specialization to get unpacked strict fields
14:47:02 <mietek> Hmm
14:47:24 <monochrom> no, probably the profiling stack is the same as real stack with more source-level annotations
14:48:16 <mietek> I see, this is silly
14:48:24 <kmc> so expressions get charged to the thing that forces them?
14:48:26 <kmc> i guess that's reasonable
14:48:52 <mietek> { do gen <- newStdGen; let rs = take 100000 (randoms gen) :: [Int]; putStrLn (show (last rs)) }
14:49:03 <napping> I think the profiling stack remembers something of the context that produced the thunk
14:49:04 <Runar> @type iota
14:49:05 <lambdabot> forall t t1 t2 a b t3. (((t -> t1 -> t2) -> (t -> t1) -> t -> t2) -> (a -> b -> a) -> t3) -> t3
14:49:11 <mietek> If my calculations are correct, this overflows the stack
14:49:19 <Runar> can "iota iota" typecheck somehow?
14:50:19 <hpaste> mietek pasted “Random overflow” at http://hpaste.org/48535
14:50:26 <xil> hi. I'd like to know more about order of operations. Is there a resource I can see defining the order in which functions are applied etc.? for example, I wrote the (?:) function and I'm wondering whether I have to put parentheses around the first input to make sure the function applies to the whole thing.
14:50:56 <monochrom> the typical slogan "the real stack is useless because evaluation order is not what you think" is bogus. clearly, for those of us who understand lazy evaluation, evaluation order is what we think. so the real reason should be something along the line of "from the real stack you still can't recover variable names"
14:51:32 <kmc> xil, the order in which things happen, at runtime? or the syntactic structure?
14:51:35 <kmc> i'm guessing you mean the latter
14:51:41 <spetrea> err
14:51:43 <xil> kmc: latter, yes
14:51:55 <kmc> xil, well, infix operators always bind more loosely than functoin application
14:52:02 <kmc> > succ 3 * 2
14:52:03 <lambdabot>   8
14:52:04 <Peaker> monochrom: isn't that why compiled languages keep debugging information?
14:52:16 <spetrea> I just made a quick benchmark between   memoization vs. general memoization vs. Y combinator , turns out Y combinator is  really slow
14:52:18 <kmc> xil, the relative precedence of infix operators is set by these "infixr" / "infixl" declarations
14:52:19 <spetrea> https://gist.github.com/1054480
14:52:30 <spetrea> uh, why was I expecting Y combinator to somehow be better?
14:52:30 <monochrom> yes, and ghc doesn't keep debugging information. until you -prof
14:52:32 <spetrea> faster
14:52:34 <mjrosenb> mietek: no stack overflow in ghci; i've multiplied that constant by 10 just to make sure.
14:52:50 <spetrea> why would one even want to use Y Combinator, except for a purely educational reason ..
14:52:53 <spetrea> or as a curiosity
14:53:15 <benmachine> can anyone comment on how using bindings-dsl compares with c2hs, or any other FFI tools?
14:53:21 <xil> kmc: so only infix functions have precedence levels? Everything else works pretty much as expected?
14:53:21 <kmc> spetrea, sometimes the code using a fixpoint operator is more clear / concise than explicit recursion
14:53:22 <mietek> mjrosenb: indeed! Curious
14:53:27 <monochrom> which Y Combinator? the lambda calculus one? or the Paul Graham school for startups?
14:53:30 <mietek> Why does it overflow when compiled, then?
14:53:37 <kmc> spetrea, I expect never in Javascript, sometimes in Haskell
14:53:40 <spetrea> monochrom: got my gist ?
14:53:47 <monochrom> no
14:53:51 <kmc> > fix ((0:) . scanl (+) 1)
14:53:52 <spetrea> monochrom: ^^
14:53:53 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:54:01 <benmachine> spetrea: anonymous recursive functions
14:54:11 <spetrea> benmachine: yes, why is that desirable ?
14:54:16 <kmc> > let fibs = 0 : scanl (+) 1 fibs in fibs
14:54:18 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:54:23 <napping> the lambda-calculus definitions of the Y combinator are not useful, of course
14:54:23 <spetrea> kmc: and in Haskell, does it yield better performance or... what's the reaason ?
14:54:26 <kmc> spetrea, don't name things if you don't have to
14:54:36 <spetrea> napping: which ones are useful then ?
14:54:39 <kmc> another example i use is "loops" in IO
14:54:45 <benmachine> spetrea: it's not very often, but sometimes it's a more concise way of doing things
14:54:46 <napping> fix f = let x = f x in x
14:54:49 <kmc> fix $ \again -> do ... when (whatever) again
14:54:58 <monochrom> before "forever" came along, I used to write fix (\again -> do stuff; again). because I'm too tired of "let".
14:55:06 <spetrea> kmc: I won't name anything, I'm just curious why Y Combinator matters at all, I mean I read articles on it, and couldn't find an use for it, except from a purely theoretical point of view
14:55:14 <Peaker> spetrea: points-free style (of which "fix" is a special case) explicitly names the structure of the variable, whereas point-ful style explicitly names the "points" that connect the structure
14:55:20 <mietek> mjrosenb: it takes an inordinate amount of memory in ghci
14:55:26 <kmc> spetrea, anonymous recursion = not-named recursion
14:55:28 <kmc> that's what i meant
14:55:30 <Peaker> oops, "of the value/function", not "of the variable"
14:55:38 <linduxed> i'm trying to create my own implementation of intersperse but i get the error "Couldn't match type `a' with `[a]'"  http://pastie.org/pastes/2142071/text
14:55:57 <spetrea> kmc: yes, why is anonymous recursion desirable ?
14:55:57 <kmc> spetrea, also, I'm talking about fixpoint combinators in general
14:55:59 <Peaker> spetrea: when you use "fix", it is clear that there's recursion going on. Using names, you have to notice that there's a recursive/co-recursive reference
14:56:01 <monochrom> spetrea, if you find no use for it, feel free to not use it. but don't speak for me
14:56:08 <kmc> spetrea, because you shouldn't name things if you don't have to.  it adds noise to the code
14:56:10 <Peaker> (that may not be a big advantage, and indeed fix is rarely used)
14:56:11 <kmc> see my "fibs" example above
14:56:19 <kmc> see also my "again" example
14:56:27 <kmc> spetrea, the Y combinator isn't even well-typed in Haskell
14:56:28 <linduxed> i don't see why it has an issue with the joining of the lists...
14:56:34 <kmc> @src fix
14:56:35 <lambdabot> fix f = let x = f x in x
14:56:43 <kmc> fix f = f (fix f) -- alternatively
14:56:48 <mjrosenb> linduxed: myIntersperse _ [x] = [x] -- you've said that the second argument has type [[a]], and the return value has type [a]
14:56:48 <xil> is there a way to find the infixity of a function in the interpreter?
14:56:53 <Peaker> kmc: people are better trained to read point-ful code -- so if the whole reason is avoiding names, I'm not sure it's worth it.. I like point-free and combinators like "fix" because I believe they make generalization easier
14:56:54 <benmachine> xil: :info +
14:57:00 <benmachine> xil: or :i + for short
14:57:05 <mjrosenb> linduxed: but in that line, you are assuming that they are both [[a]].
14:57:07 <kmc> shrug
14:57:15 <kmc> 'fix' is rarely used
14:57:17 <monochrom> in fact you can :info + * $
14:57:22 <kmc> in a few places it makes for nice code
14:57:27 <Peaker> kmc: generalizing the type of "fix" to some Category subclass rather than functions could prove useful.. and not easily possible (without adding syntax sugar) in the point-ful version
14:57:32 <kmc> my loop example is more realistic
14:57:33 <kmc> anyway ,bbl
14:57:42 <linduxed> mjrosenb: oh ok, i'll see if i can figure it out from there
14:58:15 <monochrom> I shall ask the meta question next time. why is "why is ___ useful apart from theory?" useful apart from ego?
14:58:22 <mietek> So, how would you generate a million random numbers, without running out of memory?
14:58:40 <spetrea> monochrom: well, it's really a tough questions
14:58:43 <benmachine> monochrom: why are metaquestions useful, apart from silliness? :P
14:58:46 <spetrea> *question
14:58:49 <monochrom> haha
14:59:08 <mietek> A million ints should take, what, 2 words per list element?
14:59:24 <napping> monochrom: Isn't that question equivlent to "I don't see how to use __ in code. Should I be using it?"
14:59:24 <spetrea> monochrom: I mean, something might be interesting but when it boils down to practice I'm asking myself "why/where/when would I need  this... ever ?!?"
14:59:25 <benmachine> mietek: do you need all the numbers at once?
14:59:35 <linduxed> ok now for this code  http://pastie.org/pastes/2142122/text  i get this error  http://pastie.org/2142124
14:59:40 <mjrosenb> mietek: plus gc overhead.
14:59:41 <monochrom> I'll drop the "apart from ego" part. just plain: why would anyone even ask "why would one even want to use Y Combinator, except for a purely educational reason .."?
14:59:49 <benmachine> spetrea: I thought that when I first learnt about const and id, now I use them all the time
14:59:49 <linduxed> i bet it's basically the same issue
14:59:59 <Peaker> monochrom: learning about use in practice could be pedagogical -- it is sometimes a separate/interesting thing in and of itself
15:00:05 <benmachine> spetrea: I'd say don't worry about it, remember that it exists, and it may or may not come up
15:00:14 <danharaj> I'm pretty sure (.) is the most common function in my code.
15:00:15 <benmachine> monochrom: in case there's a trick they're missing?
15:00:19 <monochrom> I mean, seriously, you are free to not use it, but don't stop me from using it, I have good value judgement too, I know when to best use it or not use it, thank you very much
15:00:36 <benmachine> monochrom: if only we all had your wisdom :P
15:00:57 <napping> monochrom: How in the world are you reading "Is __ useful in practice" as "You should stop using __"
15:01:26 * edwardk waves hello.
15:01:26 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:01:50 <monochrom> benmachine, clearly an asker who words it as "why would anyone even bother" has already made up his/her mind that there is no trick missing
15:02:08 <edwardk> @tell dylukes a state algebra. kinda boring ;)
15:02:08 <lambdabot> Consider it noted.
15:02:09 <benmachine> monochrom: I disagree, sometimes people word things badly without realising it
15:02:23 <edwardk> @tell dylukes technically a state monad-algebra
15:02:23 <lambdabot> Consider it noted.
15:02:33 <danharaj> edwardk: I wanted to ask you something about free comonads.
15:02:40 <benmachine> and anyway, made-up minds can still be blown if the trick is sufficiently clever :P
15:02:40 <edwardk> shoot
15:02:52 <monochrom> I agree and disagree. We should never guess what the speaker means, so as to train the speaker to be more precise.
15:03:03 <mjrosenb> linduxed: sort of.  the type of (++) is [a] -> [a] -> [a], and you've said that separator is of type a, not [a].
15:03:22 <danharaj> edwardk: So as I understand it, free monads are like expression trees, and >>= is substitution of trees into free variables of an expression that defines a new tree. Is that roughly correct?
15:03:32 <mjrosenb> linduxed: and i guarantee that you previous fix was not what you intended.
15:03:32 <edwardk> danharaj: yep
15:04:00 <napping> monochrom: and you are assuming that sort of question implies a closed mind. At most, it implies that they have tried and failed to find a use (at least if they are asking out of the blue - people saying things like that in response to seeing an actual use probably have made up their mind)
15:04:11 <edwardk> and the dual of substitution is redecoration, so cofree comonads have a tree with ornaments dangling from it, and you get to redecorate the tree all at once by looking at it different ways
15:04:25 <danharaj> edwardk: hmm
15:04:27 <o1iver> Hey. Do any of you know what may be the cause of the Happy Parser throwing an "Internal Happy error"? Is it something about my grammar?
15:04:33 <dylukes> edwardk: just curious thats all
15:04:34 <lambdabot> dylukes: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:04:55 <dylukes> I never really got the "decoration" metaphor :\?
15:04:55 <benmachine> o1iver: I'd be surprised if an error in your grammar got called 'internal'
15:04:55 <edwardk> extend takes something that knows how to look at the entire tree all at once 'from some perspective', and pick a new value for one location.
15:04:59 <dylukes> could someone elaborate that a bit?
15:05:33 <danharaj> edwardk: I find the substitution notion useful in thinking about monads. >>= in general feels like some sort of substitution operation. I'd like to grasp this 'decoration' intuition to help build my comonadic intuition.
15:06:05 <o1iver> benmachine: yeah, thats what I thought, but then I am kind of stuck... No idea how to fix it and I really don't want to go IO just catch an exception that should be internal (especially because I just added Either monad threading to handle errors)...
15:06:27 <edwardk> danharaj: extend never changes the shape of the comonad. if you have a comonad that has 5 holes for 'a's to hide, then after you extend some operation, and apply it you'll get a comonad that has 5 holes for b's to hide in it.
15:06:38 <danharaj> :t extend
15:06:39 <lambdabot> Not in scope: `extend'
15:06:41 <edwardk> danharaj: comonads never grow or shrink through extend
15:06:48 <benmachine> o1iver: what's the exact error?
15:06:53 <edwardk> extend :: Extend f => (f a -> b) -> f a -> f b
15:06:54 <danharaj> :t (=>>)
15:06:54 <lambdabot> Not in scope: `=>>'
15:07:16 <o1iver> my grammar defines this statement (a) or (a,b,c) or (a-x), but if I give it "(" it throws that internal error
15:07:16 <edwardk> written in the ass-backwards haskell way it'd be f a -> (f a -> b) -> f b
15:07:29 <benmachine> o1iver: I mean the exact text of the error
15:07:29 <edwardk> dylukes: sure
15:07:41 <o1iver> benmachine: mmmh how do I get that ?? :-p
15:07:47 <edwardk> lets make a comonad.
15:07:52 <danharaj> edwardk: Your signature is analogous to >=>, right?
15:07:56 <edwardk> newtype Two a = Two a a
15:07:56 <o1iver> It just says: "Exception: Internal Happy error"
15:08:04 <benmachine> o1iver: oh, that's odd
15:08:06 <edwardk> my signature is analogous to =<< actually
15:08:11 <benmachine> o1iver: what's the happy version?
15:08:14 <danharaj> ah yes derp
15:08:27 <edwardk> (=<<) is a bit better way to think about bind because it has a meaning in categories that lack exponentials
15:08:39 <edwardk> (=<<) :: (a -> m b) -> (m a -> m b)
15:08:39 <o1iver> benmachine: 1.18.6
15:08:50 <edwardk> it takes a Kleisli arrow from a -> b and yields one in the base category
15:09:05 <monochrom> napping, in this particular case, the asker reveals that he/she has seen an actual use https://gist.github.com/1054480
15:09:10 <o1iver> benmachine: and I think I read somewhere, that an internal happy error is something very bad, ie shouldnt really happen
15:09:14 <edwardk> the -> between arrows is the mapping, the two arrows it wraps are in the target category
15:09:33 <benmachine> o1iver: my first guess would be bug in happy, yeah
15:09:34 <edwardk> since all monads in haskell are strong, we can reflect this in the category itself, which is why we just use ->
15:10:07 <linduxed> mjrosenb: hmmm now i think i understand. separator is a "a" while ++ wants two "[a]" to work with. i couldn't write "x:separator ++ myInter....." either because ":" wants a list to the right
15:10:22 <edwardk> if you had a more general monad type you'd have bind :: Monad m (~>) => (a ~> m b) -> (m a ~> m b)
15:10:43 <o1iver> benmachine: so should I send an email to Simon Marlow? Don't see a mailing list... (or Haskell-Cafe?)
15:10:45 <edwardk> and in the comonad case extend :: Comonad m (~>) => (w a ~> b) -> (w a ~> w b)
15:10:49 <linduxed> mjrosenb: hmmm, if that is correct then i'm quite short on options here. i have no idea how to solve this
15:11:05 <edwardk> whereas the haskell version only makes sense if you have a LOT of structure in your category
15:11:05 <danharaj> edwardk: Ok hold on a sec. So we have multiple views of the same object, as a function in our category, and as a function outside of it.
15:11:12 <napping> monochrom: that's not exactly a clear use in practice - you see that it's from a blog post that is explicitly using snippets of code to try to work out a theoretical idea
15:11:22 <danharaj> And we conflate the views in Haskell because we have the structure to make the correspondence
15:11:37 <edwardk> danharaj: yeah
15:11:48 <benmachine> o1iver: I guess you send something to the bug-reports address, yeah, although haskell-cafe might be helpful, I dunno
15:11:59 <danharaj> <== is a function from Ob Kleisli to Hom_Hask (A, B)
15:11:59 <edwardk> danharaj: its hard to see how comonads are related to monads because you don't know what arrows to flip unless you de-conflate them though
15:12:10 <o1iver> benmachine: ok will do, cheers!
15:12:15 <danharaj> =<<*
15:12:16 * benmachine doesn't haskell-cafe due to high volume having a tendency to drown him slightly
15:12:46 <edwardk> better thought of as a mapping from the arrows of Kleisli m to the arrows of Hask
15:13:04 <danharaj> ah, I thought the objects in Kleisli m were the arrows.
15:13:15 <mjrosenb> linduxed:
15:13:17 <mjrosenb> > [2,3]++1:[4,5]
15:13:18 <lambdabot>   [2,3,1,4,5]
15:13:22 <edwardk> =<< :: takes Hom_Kleisli_M (A,B) to Hom_Hask (M A, M B)
15:13:49 <linduxed> mjrosenb: hmm, yeah
15:13:51 <linduxed> mjrosenb: clever
15:13:59 <linduxed> mjrosenb: sorry not used to this yet
15:14:22 <edwardk> nah the objects are the same as the base category
15:14:40 <danharaj> ah ok. Silly me :p
15:14:56 <edwardk> given M is a monad on C, Hom_Kleisli_M (A,B) = Hom_C (A, M B)
15:15:34 <mietek> http://hpaste.org/48536
15:15:38 <mietek> Overflow vs no overflow
15:15:42 <edwardk> but anyways given that Monads are all strong, and that haskell has full exponentials, you get the flipped around inside out definition we use
15:15:49 <edwardk> so redecorating =)
15:15:55 <danharaj> yes quite :)
15:17:17 <edwardk> the extend operation is responsible for evaluating some function from (f a -> b) on potentially lots of 'views' of f, one for every a in it, taking each of the b's that results, and putting them in the spot associated with each view.
15:17:30 <edwardk> lets try a few.
15:17:38 <edwardk> (,) e is a comonad
15:17:56 <edwardk> extend :: ((e, a) -> b) -> (e, a) -> (e, b)
15:18:12 <edwardk> extend f ea@(e, _) = (e, f ea)
15:18:26 <edwardk> here we only have one hole, and only one perspective
15:18:30 <danharaj> mhm
15:18:38 <edwardk> data Two a = Two a a
15:18:52 <edwardk> extend (Two a -> b) -> Two a -> Two b
15:18:55 <edwardk> er extend ::
15:19:01 <napping> mietek: that's funny. Maybe randoms is defined badly?
15:19:23 <edwardk> extend f ab@(Two a b) = Two (f ab) (f (Two b a))
15:19:33 <edwardk> here we had to construct a second perspective to fill the second hole
15:19:37 <monochrom> mietek: you can get a similar phenomenon with rs = scanl1 (+) (replicate 1000000 0)
15:19:53 <danharaj> edwardk: hmm, I'll have to think about that.
15:20:04 <eyu100> > 1
15:20:05 <lambdabot>   1
15:20:07 <edwardk> using f ab to fill the second hole would fail the laws
15:20:12 <eyu100> > unsafePerformIO
15:20:13 <lambdabot>   Not in scope: `unsafePerformIO'
15:20:25 <eyu100> > coerce
15:20:25 <edwardk> so you know at least that you need f (Two b ...)
15:20:26 <lambdabot>   Not in scope: `coerce'
15:20:31 <edwardk> the other comes about trying to fill in the gap
15:20:31 <eyu100> > arr
15:20:32 <lambdabot>   Overlapping instances for GHC.Show.Show ((b -> c) -> a b c)
15:20:32 <lambdabot>    arising from...
15:20:45 <eyu100> > arr (+1)
15:20:45 <lambdabot>   No instance for (GHC.Show.Show (a a1 a1))
15:20:46 <lambdabot>    arising from a use of `M720827...
15:20:47 <napping> mietek: well, it's almost certainly iterating random :: g -> (a, g) to make the list
15:20:48 <edwardk> lets consider a comonad for an infinite binary tree
15:20:59 <edwardk> data Bin a = Bin (Bin a) a (Bin a)
15:21:06 <edwardk> extract (Bin _ a _) = a
15:21:06 <napping> and if you don't look at any of the earlier number then it has a stack of 100000 calls
15:21:22 <monochrom> "random :: g -> (a, g)" is pretty lazy with the generator, at least for StdGen
15:21:27 <edwardk> extend f t@(Bin l _ r) = Bin (extend f l) (f t) (extend f r)
15:21:39 <edwardk> here we're giving your comonad access to 'see' all the nodes in the tree below it
15:21:45 <linduxed> this was interesting. i got a runtime error with the following error text  http://pastie.org/2142203  for the following code  http://pastie.org/2142206
15:21:49 <edwardk> but your perspectives can't look up
15:22:11 <mjrosenb> @djinn (a -> Maybe b) -> (a,c) -> Maybe (b,c)
15:22:11 <lambdabot> f a (b, c) =
15:22:11 <lambdabot>     case a b of
15:22:11 <lambdabot>     Nothing -> Nothing
15:22:12 <lambdabot>     Just d -> Just (d, c)
15:22:22 <mjrosenb> @@ @pl @djinn (a -> Maybe b) -> (a,c) -> Maybe (b,c)
15:22:23 <lambdabot>  (line 1, column 42):
15:22:23 <lambdabot> unexpected ">" or "-"
15:22:23 <lambdabot> expecting variable, "(", operator or end of input
15:22:33 <linduxed> i'm not quite sure why it expects a [[Char]] when it has actually descended one level...
15:23:03 <edwardk> now, we can define extend using duplicate and fmap, just like we can define bind in terms of join and fmap for a monad.
15:23:06 <edwardk> so far so good?
15:23:15 <edwardk> duplicate :: Extend f => f a -> f (f a)
15:23:20 <danharaj> edwardk: Give me a couple of seconds to digest :p
15:23:25 <edwardk> =)
15:23:36 <sully> > foldr f z [a, b, c, d, e]
15:23:37 <lambdabot>   f a (f b (f c (f d (f e z))))
15:24:05 <danharaj> Now, Two a has more than one comonad instance, doesn't it? Couldn't you take the instance for (,) a and use it for Two a?
15:24:06 <mjrosenb> linduxed: what is the type of ["aaa","bbb","CCC","dDd"]
15:24:08 <monochrom> linduxed: from a -> [[a]] -> [a] to Char -> [String] -> String, therefore myIntersperse '.' ["aaa","bbb","CCC","dDd"]
15:24:09 <mjrosenb> ?
15:24:26 <edwardk> danharaj: nope, because of the a in both places
15:24:29 <danharaj> actually nevermind no that's dumb
15:24:31 <edwardk> (e, f a) would be ill typed
15:24:32 <danharaj> yeah
15:25:26 <linduxed> mjrosenb: [[Char]] would be my guess
15:25:30 <edwardk> when we start playing with tree or zipper-like structures you can often decide if you can see ancestors and or descendants
15:25:43 <edwardk> or you might have a current location that you an increase or change only in one direction
15:25:58 <danharaj> so that explains the word 'hole' in both ideas :p
15:26:09 <edwardk> nothing says there have to be a finite number of holes either.
15:26:17 <edwardk> data Store s a = Store (s -> a) s
15:26:20 <napping> mietek: if you define (last' [x] = x; last' (x:xs) = x `seq` xs), then last' rs won't stack overflow
15:26:27 <linduxed> monochrom: i'm terribly sorry, but I don't see your point. I'm too confused i think
15:26:31 <edwardk> has a function that can take an s, and give me an a, and which has an s lying around
15:26:37 <edwardk> extract (Store f s) = f s
15:26:42 <monochrom> set a=Char
15:26:47 <mjrosenb> linduxed: yup, and then what is the type of "."?
15:26:48 <edwardk> duplicate (Store f s) = Store (Store f) s
15:27:26 <linduxed> mjrosenb: it's a string...
15:27:31 <linduxed> mjrosenb: oh i see
15:27:31 <mjrosenb> edwardk: is there an example of that online that does not hav a half dozen other conversations threaded throughout it?
15:27:47 <edwardk> mjrosenb: probably not a good one ;)
15:27:48 <linduxed> mjrosenb: or well, i think i see. got an idea
15:28:14 <danharaj> edwardk: It seems to me that you can deduce what extend should look like by thinking of your 'observation' functions.
15:28:23 <linduxed> mjrosenb: nope my idea didn't help
15:28:27 <edwardk> danharaj: yeah.
15:28:27 <danharaj> observation being a function :: w a -> w a that's nice.
15:28:28 <linduxed> mjrosenb: i'm still lost
15:28:34 <edwardk> danharaj: now, lets look at cofree
15:28:42 <mjrosenb> linduxed: ok, what did you try this time?
15:28:44 <edwardk> data Cofree f a = a :< f (Cofree f a)
15:28:52 <edwardk> extract (a :< _) = a
15:28:55 <edwardk> that one is easy
15:29:01 <linduxed> mjrosenb: instead of "." i wrote .
15:29:01 <ddarius> Now start talking about the comonad related to face and degeneracy maps.
15:29:15 <mjrosenb> linduxed:
15:29:19 <mjrosenb> :t (.)
15:29:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:29:25 <monochrom> myIntersperse '.' ["aaa","bbb","CCC","dDd"]
15:29:37 <danharaj> edwardk: That looks like (a, f a, f^2 a, ...), right?
15:29:39 <edwardk> ddarius: =P
15:29:39 <linduxed> mjrosenb: yeah i thought about that after typing it
15:29:42 <mietek> napping: right, cheers
15:29:54 <edwardk> danharaj: almost, but those are zipped up
15:30:06 <edwardk> a * f (a * f(.... ))
15:30:10 <edwardk> the distinction is important
15:30:13 <danharaj> ok.
15:30:19 <danharaj> Sort of like how you can represent a zipper in two ways.
15:30:25 <edwardk> there is a comonad for a * f (a * f( ...)) in that 'horner's rule' form, but not for
15:30:27 <napping> mietek: by the way, if you really need to fast-forward a random generator, there are usually much better ways
15:30:35 <edwardk> data Tensors f a = a :- Tensors f (f a)
15:30:41 <mietek> I'm sure, but no, that was just testing stuff
15:31:03 <ddarius> danharaj has stumbled upon a (current) sore point for edwardk.
15:31:29 <linduxed> mjrosenb: oh wait!
15:31:44 <linduxed> mjrosenb: if i do '.' instead of "." it counts as a char
15:31:52 <linduxed> mjrosenb: i read that now...
15:32:01 <linduxed> mjrosenb: then it was coded right
15:32:04 <edwardk> danharaj: actually its a little bit stickier. you can always unzip a Cofree f to get Tensors f
15:32:08 <edwardk> but you can't go back
15:32:13 <napping> mietek: there's a fair number of functions that fail like
15:32:14 <edwardk> not in general given just a Functor
15:32:30 <edwardk> danharaj http://hackage.haskell.org/packages/archive/ad/1.1.0/doc/html/Numeric-AD-Types.html#t:Tensors provides the one direction
15:32:48 <danharaj> edwardk: I'm not familiar with this usage of 'Tensor'
15:32:52 <edwardk> danharaj: in fact my AD library is careful to give all of its answers zipped up in the functor you supply
15:33:05 <mjrosenb> hrmm, does @pl not like case statements?
15:33:18 <monochrom> @pl \x -> case x of x -> x
15:33:18 <lambdabot> (line 1, column 19):
15:33:18 <lambdabot> unexpected ">" or "-"
15:33:18 <lambdabot> expecting variable, "(", operator or end of input
15:33:24 <monochrom> yeah
15:33:36 <bos31337> other companies use expensive firewalls and crypto hardware to protect their intellectual secrets. edwardk uses category theory!
15:34:09 <danharaj> edwardk: anywho. So the free comonad for the identity functor is (a, (a, (a, ...))), correct?
15:34:13 <napping> mietek: in short, you get a stack overflow if there's a lot of work you need to do all at once to compute a value (not tail recursive). There's a fair number of list producing functions where later elements depend on earlier elements, so if you drop elements you can get extra forced work
15:34:23 <monochrom> the AD library contains the secret of the universe encoded in category theory
15:34:24 <bos> edwardk: did you see odersky getting snitty about category theory in scala-land?
15:34:28 <djahandarie> @remember bos other companies use expensive firewalls and crypto hardware to protect their intellectual secrets. edwardk uses category theory!
15:34:28 <lambdabot> Good to know.
15:34:34 <edwardk> think of a tensor just as a matrix with potentially more than 2 dimensions. i use f (g (h x)) where f g and h are traversable as a 3 dimensional tensors
15:35:18 <edwardk> bos: *shrug* scala like all languages is a testament to the limitations of its designer
15:35:22 <mjrosenb> mietek: i would recommend using the split function if you need to perform "sequential" computations where the first computation can use alot of randomness.
15:35:38 <mjrosenb> (assuming split doesn't do anything horribly silly)
15:35:43 <edwardk> danharaj: yep
15:35:45 <mietek> mjrosenb: I wanted to be able to pass a large chunk for random numbers to another function
15:35:52 <mietek> s/for/of/
15:35:59 <edwardk> danharaj: and Cofree Maybe is a non-empty list monad
15:36:07 <edwardk> Cofree [] is the Tree type from containers
15:36:15 <edwardk> which is a non-empty rose-tree
15:36:22 <eyu100> > undefine
15:36:23 <lambdabot>   Not in scope: `undefine'
15:36:24 <mjrosenb> mietek: and as long as it uses them in order, you should be fine.
15:36:25 <eyu100> > undefined
15:36:26 <lambdabot>   *Exception: Prelude.undefined
15:36:27 <bos> mietek: what are you trying to do with the random library?
15:36:41 <mjrosenb> mietek: the problem is if you want to pass two chunks of random numbers to two functions
15:36:42 <napping> "split" is supposed to produce another statistically unrelated generator
15:36:42 <monochrom> mietek: if the other function evaluates the chunk of random numbers in order, it's fine
15:36:54 <mjrosenb> mietek: and you don't know what order they will be evaluated in.
15:37:12 <edwardk> danharaj: but Cofree is basically just that Bin monad we defined early generalized to not caring about what functor you wrap it around, so given any functor f, Cofree f is a comonad.
15:37:16 * ddarius thinks of tensors as multilinear functions.
15:37:17 <mietek> mjrosenb: err
15:37:21 <edwardk> and it can redecorate
15:37:30 <mietek> Let me try that again
15:37:39 * roconnor wishes ReadInt took a (Char -> Maybe Int) instead of (Char -> Bool, Char -> Int)
15:37:51 <ddarius> (Actually, that's a lie.  I usually try to avoid thinking of such unstructured concepts as tensors.)
15:37:51 <edwardk> ddarius: as do i, but the representation of a tensor is a more concrete and accessible thing ;)
15:38:20 <danharaj> edwardk: So this is what they mean when they say a comonadic value is a value in context. For Cofree comonads, the value is fst, and the context is snd.
15:38:58 <edwardk> danahraj: for the product comonad, for the cofree comonad, you have access to a lot of other values
15:39:05 <mjrosenb> also, fun fact about random numbers:
15:39:08 <mietek> mjrosenb: I have no idea what you just said, about two functions
15:39:17 <mjrosenb> > take 30 $  map (fst . randomR (0,5). mkStdGen ) [0..]
15:39:19 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]
15:39:27 <edwardk> in the store comonad you can choose any value for s and get a different value.
15:39:47 <mietek> mjrosenb: my original overflow example involved using last on a large list
15:39:53 <kmc> edwardk, if a language is testament to the limitations of its designer, does a committee language get the union or the intersection?
15:39:58 <mietek> mjrosenb: which I understand is a mistake in itself
15:40:03 <edwardk> kmc: usually the union ;)
15:40:10 <balor> What does foo@Bar{..} mean in the parameters to a function?  Is it the element foo of the record Bar?
15:40:16 <linduxed> i've noticed that "myIntersperse _ [[x]] = [x]" does not match ["foobar"]
15:40:24 <danharaj> I thought it gets some subspace of the union with an intractable topology :p
15:40:37 <kmc> balor, pattern x@p matches the same things as pattern p
15:40:42 <linduxed> how should i change that line so that it matches a single string in a list?
15:40:45 <edwardk> kmc: i say usually, because Haskell was designed by committee and largely (aside from the great monomorphism revolution of 98) emerged unscathed
15:40:46 <kmc> but it also binds the name 'x' to the whole thing matched
15:40:54 <kmc> edwardk, yeah
15:41:08 <danharaj> let me see if I can define extend myself for Cofree f a
15:41:23 <kmc> i think in the case of Java it's the limits of the imagination of its designers, in particular in believing that "ordinary programmers" could use such advanced techniques as functions
15:41:23 <benmachine> I always thought haskell was better for having been designed by committee
15:41:23 <balor> kmc, thanks
15:41:24 <mjrosenb> mietek: yes, but presumably your actual function will use them in order, however, if you have let rands = randoms gen :: [int]; f (take (10^6) rands) + g (take (10^6) (drop (10^6) rands))
15:41:28 <kmc> but i don't actually know much about the history of Java
15:41:36 <mjrosenb> mietek: where both f and g use the "random numbers" in a sane fashion
15:41:39 <benmachine> but maybe I'm excessively naive
15:42:01 <mjrosenb> if g is evaluated before f, then you are likely to stack overflow, whereas if f is evaluated before g, you're fine.
15:42:06 <edwardk> danharaj: now an interesting result is that codensity can improve the asymptotic performance of code over free monads, but density does nothing to improve the asymptotic performance of code over cofree comonads.
15:42:29 <kmc> o_O
15:42:41 <edwardk> this goes back to the fact that monads are about substitution, but comonads just redecorate
15:42:47 <mjrosenb> linduxed: you currently have ... [[x]]  = [x], right?
15:43:01 <edwardk> comonads don't change the shape involved, while free monads grow monotonically
15:43:21 <edwardk> free monads pay ever increasing costs for left associated binds, codensity right associates them all
15:43:29 <edwardk> but cofree comonads pay the same cost every time
15:43:46 <edwardk> because the shape never changes!
15:43:48 <linduxed> mjrosenb: in the code? yes that hasn't changed
15:44:49 <danharaj> so is extend for Cofree f a this? extend g ab@(a, b) = (g ab, fmap g b)?
15:45:04 <edwardk> probably fmap (extend g)
15:45:06 <edwardk> but otherwise
15:45:10 <danharaj> yes that.
15:45:27 <mjrosenb> linduxed: well, what values can [[x]] match?
15:46:02 <edwardk> danharaj: now, with those insights in mind, look at comonad-transformers =)
15:46:07 <linduxed> mjrosenb: hmmm, a list containing one thing
15:46:09 <edwardk> and comonads-fd
15:46:17 <edwardk> and mix and match them with the mtl
15:46:22 <linduxed> mjrosenb: or wait, no
15:46:37 <danharaj> edwardk: Are you trying to make me join the dark side of the force?
15:46:50 <edwardk> danharaj: nah, i already proved there was more power on the light side of the force.
15:46:54 <linduxed> mjrosenb: a list containing a list of things, which would also be equivalent to a list with a string in
15:46:57 <danharaj> heh.
15:47:06 <edwardk> my last two articles showed there are strictly fewer comonads in haskell that are interesting than monads ;)
15:47:21 <tgeeky> edwardk: oh, is that what that meant?
15:47:37 <edwardk> every comonad gives rise to a monad transformer, but not every monad is a monad transformer
15:47:40 <danharaj> certainly there are countably many of both.
15:47:43 <edwardk> tgeeky: yeah
15:48:00 <tgeeky> edwardk: I read it and thought that I was a blithering ok at
15:48:01 <tgeeky>                  comonad-transformers =)
15:48:02 <tgeeky> grr.
15:48:09 <mjrosenb> linduxed: well [x] matches a list with one thing in it, which can be a string (just call it a list of charactors, it is easier)
15:48:13 <tgeeky> I read it and thought I was a blithering imbecile.
15:48:35 <shachaf> A charactor sounds like some kind of villain.
15:48:38 <edwardk> anyways, the reason why the dual trick doesn't work is pretty subtle
15:48:42 <mjrosenb> linduxed: and if [x] :: String, then [x] matches a list that has *one* character in it, right?
15:48:46 <linduxed> mjrosenb: really? i thought x couln't mean String in that case
15:48:53 <shachaf> Like the Tomator.
15:49:03 <mjrosenb> linduxed: String is just an alias for [Char]
15:49:06 <danharaj> edwardk: It reminds me how in other places in math, sometimes the dual object is harder to construct.
15:49:07 <edwardk> but ultimately you can do the same sandwiching trick to wedge a comonad in the middle of a left kan extension, but you just get something isomorphic to the same comonad
15:49:07 <linduxed> mjrosenb: oh wait sorry cancel that
15:49:23 <linduxed> mjrosenb: i was a bit more confused for a second than i already am
15:49:24 <linduxed> :-P
15:49:33 <edwardk> danharaj: here it comes about from the biasing caused by the fact that values and continuations aren't created equal
15:50:03 <edwardk> you'd need to be working in a classical setting to get the opposite, which leads to bad things, like unsafePerformIO
15:50:14 <edwardk> so its good we don't have it =P
15:50:15 <linduxed> mjrosenb: so yes that was my thinking. [[Char]] would match against [[x]] and i would get [x] back
15:50:30 <linduxed> mjrosenb: which would be the first string in a list of strings
15:50:41 <edwardk> anyways, gotta run. i'm going to be late
15:50:45 <roconnor> edwardk: right, it somehow comes down to the fact that programs are constructive?
15:50:46 <danharaj> ta
15:50:52 <edwardk> roconnor: yeah
15:50:54 <danharaj> thanks for the lesson.
15:51:08 <roconnor> and constructive logic isn't symmetric in its sequents
15:51:19 <edwardk> roconnor: you'd need an adjunction from Hask -> Hask^op. we only have one, and its pretty boring
15:51:53 <mjrosenb> so if we go to match [[x]] against ["hello","world"], this fails because [[x]] says that the list needs to have length 1, but ["hello", "world"] has length 2.
15:51:59 <mjrosenb> linduxed: ^
15:52:08 <edwardk> (it is a contravariant version newtype Void a = Void (Void a)
15:52:29 <edwardk> that is self-adjoint and you can define (Void a -> b) -> Void b -> a
15:52:36 <edwardk> because you shouldn't be able to construct Void ;)
15:52:43 <mjrosenb> linduxed: so if we try to match [[x]] agains just ["hello"], the first level succeeds becaus they both have one element, and it proceeds to the inner pattern/value
15:52:59 <roconnor> we need more functions of type ((a -> Void) -> Void) -> a
15:53:05 <edwardk> yeah
15:53:12 <roconnor> @free foo :: ((a -> Void) -> Void) -> a
15:53:12 <lambdabot> (forall k. g (k . f) = h k) => f (foo g) = foo h
15:53:15 <edwardk> given that you can define lots of interesting comonads ;)
15:53:17 <mjrosenb> linduxed: desugaring "hello" into ['h','e','l','l','o'], and matching against [x] fails
15:53:37 <linduxed> mjrosenb: oh i see
15:53:40 <mjrosenb> linduxed: because the length of the pattern is 1, but the length of the string is 5.
15:53:43 <roconnor> edwardk: does linear-logic have this?
15:53:59 <edwardk> i leave it to you to find out. i really am going to be late now =)
15:54:08 <linduxed> mjrosenb: then... well i'll have to rewrite my code somehow then
15:54:09 <roconnor> ok
15:54:13 <mjrosenb> linduxed: try going back to what you had before, ... [x] = [x]
15:54:22 <linduxed> mjrosenb: no that doesn't work
15:54:23 <mjrosenb> linduxed: and think of a different way to solve the problem
15:54:34 <linduxed> mjrosenb: then it complains about the signature
15:57:14 <mjrosenb> linduxed: yes, and you tried to fix it by replacing [x] = [x] with [[x]] = [x], which changed the meaning of the pattern from "match a list of strings that has one string" to "match a list of strings that has a single string that consists of a single character"
15:57:23 <mjrosenb> there is another way to fix it
15:57:47 <mjrosenb> in this instance, what does the pattern [x] do?
15:58:17 <linduxed> it matches against a list with one thing in it
15:58:40 <linduxed> so a string with one char in it for instance
16:00:06 <linduxed> I DID IT
16:00:36 <linduxed> i changed the line with myIntersperse _ [x:xs] = x:xs
16:00:42 <linduxed> it WORKS
16:01:03 <linduxed> i'm not sure if it's the pretty way to do it... but hey it works!
16:01:25 <mjrosenb> linduxed: can i see the code that you have?
16:01:50 <linduxed> mjrosenb: http://pastie.org/pastes/2142373/text
16:01:52 <mjrosenb> linduxed: and i would argue that it does not work :-p
16:03:44 <mjrosenb> linduxed: try myIntersperse '.' ["hello","world",""]
16:04:40 <eyu100> @free foo :: Void
16:04:40 <lambdabot> foo = foo
16:04:43 <monochrom> hacking is pretended programming
16:04:45 <linduxed> mjrosenb: yeah i got "hello.world.." as a return value
16:05:06 <linduxed> oh wait... there's an extra dot at the end
16:05:25 <linduxed> well then you're right, it doesn't quite work
16:05:42 <linduxed> mjrosenb: but to be honest i'm just shooting in the dark now
16:06:06 <mjrosenb> @unpl \(x,y) -> fmap (,y) (f x)
16:06:07 <lambdabot>  Parse error at "y)" (column 18)
16:06:17 <mjrosenb> @unpl \(x,y) -> fmap (\a -> (a,y)) (f x)
16:06:17 <lambdabot> \ (x, y) -> fmap (\ a -> (a, y)) (f x)
16:06:17 <linduxed> this is the closest i've gotten to it and I don't see how I'm to do this with pattern matching
16:06:26 <eyu100> @free foo :: Int -> Int
16:06:27 <lambdabot> foo = foo
16:06:35 <mjrosenb> @pl \(x,y) -> fmap (\a -> (a,y)) (f x)
16:06:35 <lambdabot> uncurry (flip (fmap . flip (,)) . f)
16:06:57 <eyu100> @free foo :: (Int -> Int) -> Int -> Int
16:06:57 <lambdabot> foo = foo
16:07:00 <mjrosenb> linduxed: what values does [x:xs] match?
16:07:38 <linduxed> a list of (a single value with a list tacked on to it)
16:07:53 <eyu100> @pl a = a
16:07:53 <lambdabot> a = fix id
16:08:04 <eyu100> wow I didn't know that
16:08:05 <linduxed> which doesn't apply to an empty list
16:08:08 <eyu100> @pl id
16:08:09 <lambdabot> id
16:08:09 <mjrosenb> right, and when i pass in "", which is the empty list, it fails to match.
16:08:15 <eyu100> @pl a = 2 * a
16:08:15 <lambdabot> a = fix (2 *)
16:08:40 <mjrosenb> so why do you have x:xs, which explicitly matches non-empty lists, and the rhs is the exact same thing?
16:09:03 <eyu100> @pl a n = n : (a (n+1))
16:09:03 <lambdabot> a = fix (ap (:) . (. (1 +)))
16:09:11 <eyu100> ^^ didn't know that either
16:09:21 <eyu100> @pl [1..]
16:09:22 <lambdabot> [1..]
16:09:32 <eyu100> @pl a n = [n..]
16:09:33 <lambdabot> a = enumFrom
16:09:40 <eyu100> wow
16:09:54 <linduxed> mjrosenb: i have it because it is the only thing that has worked somewhat like i want it to
16:10:05 <linduxed> mjrosenb: that's really my reason
16:10:36 <linduxed> mjrosenb: i want it to match a single string on that line... that's how i came up with that
16:10:51 <eyu100> @pl foo x y = x * y
16:10:51 <lambdabot> foo = (*)
16:10:54 <aavogt> > let ip = foldr (\a b -> if null b then a else a  ++ "." ++ b) [] in ip ["hello","world",""]
16:10:56 <lambdabot>   "hello.world"
16:11:07 <eyu100> @pl foo x y z = x*y*z
16:11:08 <lambdabot> foo = ((*) .) . (*)
16:11:27 <eyu100> @pl foo [] = 1
16:11:27 <lambdabot> (line 1, column 8):
16:11:27 <lambdabot> unexpected "="
16:11:27 <lambdabot> expecting variable, "(", operator or end of input
16:11:35 <eyu100> @pl foo x = 1
16:11:35 <lambdabot> foo = const 1
16:11:51 <mjrosenb> linduxed: ok, well how about just naming the x:xs as y, so you have ... [y@(x:xs)] = y
16:11:51 <aavogt> \bot also replies to private messages
16:12:09 <eyu100> @pl foo x = return x
16:12:09 <lambdabot> foo = return
16:12:14 <eyu100> @pl foo x = asdasoi x
16:12:14 <lambdabot> foo = asdasoi
16:12:22 <mjrosenb> linduxed: note: this won't change the behavior, but it will get you one step closer to the solution.
16:12:28 <eyu100> @pl foo x = foo x
16:12:29 <lambdabot> foo = fix id
16:12:36 <linduxed> mjrosenb: i've never used the @ sign... what does it do?
16:12:37 <eyu100> @pl foo = foo
16:12:37 <lambdabot> foo = fix id
16:12:42 <eyu100> @pl foo = undefined
16:12:42 <lambdabot> foo = undefined
16:14:38 <mjrosenb> linduxed: y@(x:xs) says match the value passed in against x:xs, bind both x and xs, *and* if that succeeds, then bind the whole expression to y.
16:15:10 <mjrosenb> linduxed: it is sort of like saying ... [x:xs] = let y=x:xs in y
16:15:17 <mjrosenb> linduxed: but better in most ways.
16:16:15 <linduxed> mjrosenb: ok so if the paranthesis actually binds to a value, then put it into the variable to the left of the @
16:16:20 <linduxed> more or less i guess
16:16:37 <linduxed> well i've added that... and yes the behavior is exactly the same
16:16:48 <mjrosenb> yup.
16:17:15 <mjrosenb> now, that you have y@x:xs, and neither x nor xs is mentioned in the rhs, why do you need x:xs?
16:17:16 <eyu100> @pl foo x y = 1
16:17:16 <lambdabot> foo = const (const 1)
16:17:31 <mjrosenb> just get rid of that whole section
16:17:33 <eyu100> @pl foo x y z = x (y + z 1)
16:17:33 <lambdabot> foo = (. ((. ($ 1)) . (+))) . (.)
16:17:39 <eyu100> =D
16:17:47 <aavogt> mjrosenb: do you know a situation where  "[x:xs] = let y=x:xs in y"  is better?
16:18:24 <d7> Has anyone here used the redis library?
16:18:37 <ozataman> d7: yep
16:18:43 <d7> ozataman: With pubsub?
16:19:06 <mjrosenb> aavogt: i cannot think of one, unless *not* sharing data is somehow beneficial.
16:19:22 <mjrosenb> aavogt: and even then, it is only a single cons cell that is *not* shared.
16:19:32 <d7> ozataman: I'm just curious if the type signature of subscribe is implying that there is a stream goin' on here.
16:21:42 <linduxed> mjrosenb: well removing the line has the side effect of making myIntersparse always put an instance of the separator at the end of any non-empty string
16:23:44 <ozataman> d7: sorry, haven't used pubsub. best is probably to stage a quick test and publish messages from redis-cli and listen/print to screen on Haskell side
16:24:05 <d7> ozataman: That is my plan
16:24:15 <d7> ozataman: I cannot imagine how else it could work tho...
16:24:49 <linduxed> mjrosenb: dude, i'm sorry but this is taking an enormous amount of time.  no offence at all, i'm thankful for help and insights you've given me, but if this is an elaborate process leading to the point of "yeah, you should have added two brackets" then I'm better off just skipping this excercise and move on to the next one
16:25:29 <ozataman> d7: seems like subscribe would block and return an infinite list of messages
16:25:43 <linduxed> mjrosenb: i know i won't learn as much... but all i'm asking for is how to pattern match for one string using the signature i've got
16:25:50 <linduxed> mjrosenb: i'm at a loss
16:27:02 <linduxed> mjrosenb: i don't have an idea how to do this properly. the closest thing i had you shot down with an example that indeed didn't produce expected results
16:27:03 <d7> ozataman: I've just never used something like this before, I dunno how IO and an infinite lazy list interact.
16:27:08 <Saizan> ?src intersperse
16:27:09 <lambdabot> intersperse _   []     = []
16:27:09 <lambdabot> intersperse _   [x]    = [x]
16:27:09 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
16:27:18 <Saizan> linduxed: ^^^
16:27:32 <ozataman> d7: I'm guessing it will be like doing f <- readFile
16:28:03 <Saizan> é
16:28:09 <Saizan> ?type intersperse
16:28:10 <lambdabot> forall a. a -> [a] -> [a]
16:28:18 <kmc> IO and lazy lists do not interact, in general
16:28:21 <Saizan> ?type intercalate
16:28:22 <lambdabot> forall a. [a] -> [[a]] -> [a]
16:28:28 <kmc> it is fine for an IO action to produce a lazy list, just like any other thing
16:28:35 <linduxed> Saizan: that was my idea too... but the excercis provided me with this signature to work with "intersperse :: a -> [[a]] -> [a]"
16:28:42 <d7> kmc: I guess I will have to play with the api then
16:28:48 <kmc> however if you want to write an IO action which produces a lazy list *whose elements are determined by incremental execution of IO*
16:28:51 <kmc> then you have to use hacks
16:28:55 <kmc> that's what readFile does
16:29:02 <kmc> readFile actually totally breaks one of the core rules of Haskell
16:29:44 <kmc> readFile gives you a value for which evaluation drives execution
16:29:45 <Saizan> linduxed: what was the problem with your http://pastie.org/pastes/2142373/text ?
16:29:52 <kmc> normally execution drives evaluation and never the other way around
16:30:28 <linduxed> Saizan: that ["hello","world",""] had an extra dot at the end
16:30:40 <linduxed> Saizan: i don't think that's how it should be
16:31:06 <mjrosenb> linduxed: i meant remove the @(x:xs), so the line reads ... [y] = y
16:31:25 <mjrosenb> linduxed: so [y] matches a list with a single string, and it returns just that string.
16:32:06 <Saizan> linduxed: yeah, change the second line with "myIntersperse _ [x] = x"
16:32:34 <linduxed> thx a lot
16:32:43 <linduxed> yeah i think that does the trick
16:33:10 <Saizan> linduxed: "myIntersperse _ [x:xs] = x:xs" doesn't match the [""] case, which gets handles by the third clauses which inserts the separator
16:33:25 <Saizan> *clause
16:33:31 <linduxed> Saizan: yeah now i see that
16:43:13 <tommd> > "ping... (I'm lagging hard or my name isn't Don Stewart)"
16:43:14 <lambdabot>   "ping... (I'm lagging hard or my name isn't Don Stewart)"
16:50:17 <kmc> Lambda Robots: 100% Loyal
16:51:47 <wli> I can't get the GSL one-dimensional minimization library function to stop raising SIGABRT. Maybe this merits some sort of effort to grind out Brent's algorithm in plain Haskell.
17:34:58 <benmachine> so if I'm a haskell programmer and I want to write an android app
17:35:20 <ddarius> benmachine: Start a company and hire Cale.
17:35:26 <benmachine> :P
17:35:33 <benmachine> is GHC on android together yet?
17:35:35 <monochrom> hire me too
17:36:11 <benmachine> monochrom: I will pay you in kind words how about that
17:36:37 <monochrom> depends on what I do in return. maybe wise words
17:37:31 <benmachine> that is actually a pretty good deal
17:43:10 <ddarius> benmachine: I see you are starting immediately.
17:43:54 <benmachine> ddarius: :>
17:44:06 <wli> benmachine: Wouldn't cross-ghc make more sense than attempting to run ghc on cellphones?
17:44:26 <benmachine> wli: sure, it's all the same to me :)
17:46:12 <augur> are there combinators for primitive recursion and general recursion?
17:47:07 <wli> My knowledge of the ghc codebase is negligible. I'm not likely to be the one you want unless you want ramp-up time.
17:48:21 <benmachine> wli: I don't want people, I want information :P
17:48:45 <wli> benmachine: I thought you wanted code and/or programmers to devise it for you.
17:49:03 <benmachine> well, that would be *nice* but the stuff about hiring people was a joke
17:49:41 <benmachine> what I want to know is if people can compile haskell onto android yet (I believe not) and if not what other languages would #haskell recommend I learn
17:52:24 <wuxingbo> everyone: I'd like to use "a = 0b1010001", but it seems haskell don't support it. a lot of language don't support "0b" form of int value, why, I think it's very useful.
17:56:45 <napping> what do you need that for?
17:56:57 <tgeeky> representing binary strings, of course
17:57:23 <tgeeky> wuxingbo: http://www.haskell.org/onlinereport/haskell2010/haskellch15.html#x23-20800015
17:58:18 <tgeeky> wuxingbo: I thought haskell supported that, but it looks like it only has special support for octal and hex
17:58:35 <napping> hex has an integer number of bits per digit
17:58:37 <wuxingbo> napping: I'd like to write some bits value, I have to convert it to hex mode...
17:58:43 <napping> or you could write the converter from string
17:58:53 <napping> and package it as a quasiquoter, if you want compile-time checking
17:58:56 <tgeeky> but I am certain someone has implemented this in some package on hackage
17:59:03 <napping> something like [bin| 0100001 |]
17:59:43 <tgeeky> qq for binary?
18:00:22 <wuxingbo> [bin| 0100001 |] is that templete haskell?
18:00:41 <tgeeky> just quasiquoting, not full TH, but yes
18:00:41 <napping> no, that's what you might write if you defined your own quasiquoter
18:02:05 <wuxingbo> I think write a convertion func seem make it noisy: a = fromBin "1010101"
18:02:42 <napping> if it's that much of a bother, let b = fromBin in b"1010101"
18:02:52 <napping> assuming you scope it over a longer block
18:03:16 <wuxingbo> or I should make it a operator? "<!> 101010101"
18:03:18 <napping> what kind of code are you writing that wants binary literals anyway? That only seems to come up a lot in masks for OS stuff
18:03:33 <kmc> bit masks show up everywhere
18:03:50 <kmc> OS, file formats, network protocols, efficient sets, ...
18:04:00 <Draconx> wuxingbo, except for very small numbers, hexadecimal is generally much easier for humans to understand than binary anyway.  And for very small numbers, it doesn't really matter what base you use.
18:04:30 <wuxingbo> a lot of "register" stuff... hundreds of bit fields.
18:05:05 <kmc> quasiquoting uses "full TH"
18:05:20 <kmc> a quasiquoter is basically a tuple (String -> ExpQ, String -> PatQ)
18:05:24 <kmc> or whatever
18:05:50 <napping> the main advantage of using a quasiquoter is that errors in the string will be compile-time errors
18:05:55 <monochrom> > (False /= True, False /= False)
18:05:56 <lambdabot>   (True,False)
18:06:08 <aavogt>  TypeQ too
18:10:06 <wuxingbo> maybe I should expand the Parsec to read "0b10101" as "integer", write all values in a text file then parse it.
18:16:29 <ivanm> @type replicateM
18:16:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
18:23:12 <steveklabnik> hey everyone! I'm upgrading an old computer, it's probably been since november since it's been updated. when i run xmonad --recompile, i get an error about an error in my config, 'could not find module 'Prelude.'. This seems bad. thoughts?
18:23:18 <steveklabnik> google didn't really help much. :/
18:23:31 <kmc> i would guess that your GHC install is some variety of fucked
18:23:53 <steveklabnik> im on arch, i told it to uninstall and reinstall. maybe i didnt get it all :/
18:24:29 <benmachine> steveklabnik: try ghc-pkg list
18:24:43 <napping> 'Prelude.' ?
18:24:52 <benmachine> napping: mm, good point
18:25:26 <steveklabnik> benmachine: that gives me a directory. it has a bunch of blank files in it
18:25:27 <napping> Seems like that would be a syntax error if it's actually in the file, though
18:25:43 <napping> yeah, parse error on input `.'
18:25:45 <benmachine> steveklabnik: what do you mean?
18:26:19 <steveklabnik> benmachine: since i dont have x, i cant really copy it... it prints out /usr/lib/ghc-7.0.3/package.conf.d
18:26:30 <steveklabnik> forgive minor typos
18:26:45 <steveklabnik> napping: i guess that's possible, this config DID work six months ago, though.
18:26:56 <benmachine> steveklabnik: sure but under that
18:27:04 <benmachine> steveklabnik: the key things are, is stuff highlighted in red
18:27:04 <steveklabnik> id be suprised if i was doing anything strange. admittedly, i havent done much haskell in the last six months.
18:27:09 <benmachine> steveklabnik: is the base package there
18:27:11 <steveklabnik> benmachine: thats the only thing. just that one line
18:27:11 <benmachine> stuff like that
18:27:21 <napping> steveklabnik: nah, can't be that - an extra period in the file makes a different syntax error
18:27:27 <benmachine> steveklabnik: ah, that's definitely not how it's meant to be
18:27:42 <benmachine> I've no idea how you managed that :P
18:27:52 <steveklabnik> :/
18:27:57 <benmachine> you said you reinstalled ghc already?
18:28:06 <steveklabnik> well, im telling pacman to uninstall basically EVERYTHING related to haskell.
18:28:27 <steveklabnik> ... i'm pretty sure i did, but one more time can't hurt, eh?
18:28:41 <benmachine> steveklabnik: did you say that directory was full of empty files?
18:29:00 <steveklabnik> it's got a few, yeah. one or two look really odd.
18:29:23 <steveklabnik> when i try to reinstall xmonad, i'm getting another odd error, hmm...
18:29:29 <steveklabnik> maybe i SHOULD just wipe this machine. :/
18:29:37 <benmachine> steveklabnik: hah, don't give up yet
18:29:41 <steveklabnik> :)
18:29:45 <benmachine> steveklabnik: tell me more about the odd files
18:29:48 <steveklabnik> okay
18:30:05 <steveklabnik> well, one second. so when i'm reinstalling xmonad through pacman, it gives me an error:
18:30:17 <steveklabnik> ghc: /usr/bin/ghc exists in filesystem
18:30:29 <steveklabnik> so pacman apparently _thinks_ it's installed, but it says it doesnt upgrade
18:30:36 <benmachine> is it trying to install ghc and failing because it's already there?
18:30:51 <steveklabnik> maybe?
18:31:05 <steveklabnik> that is what which gch says...
18:31:15 <benmachine> ok, well, is the ghc package actually installed atm
18:32:01 <steveklabnik> yeah, apparently even though pacman says it's not installed it actually is
18:32:10 <benmachine> ah
18:32:17 <mjrosenb> @src liftM2
18:32:17 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
18:32:19 <benmachine> so you have the files but pacman doesn't know about them
18:32:23 <benmachine> that sounds like a recipe for trouble
18:32:27 <steveklabnik> yeah.
18:32:36 <benmachine> I think you can tell pacman to force the install
18:32:55 <benmachine> --force will overwrite conflicting files
18:33:09 <benmachine> so you can either do that
18:33:15 <benmachine> or remove the files manually and then install ghc
18:33:23 <steveklabnik> is it possible that i installed ghc through cabal, maybe?
18:33:25 <steveklabnik> hmm
18:33:28 <benmachine> uh no
18:33:29 <steveklabnik> just wondering how it got there.
18:33:31 <benmachine> not really :P
18:33:39 <benmachine> cabal compiles stuff
18:33:40 <steveklabnik> yeah, because it's written in haskell. okay.
18:33:45 <napping> you maybe have installed it yourself, I usually do
18:33:49 <benmachine> well, and ghc just isn't on hackage
18:34:06 <benmachine> napping: yeah, I do that too nowadays, but it's more usual for it to end up in /usr/local in that case
18:34:19 <steveklabnik> napping: i try to stay away from doing that. I might have, but it's not in /usr/local/src, so...
18:34:39 <steveklabnik> i think i'm just going to kill every file that's related to ghc on the system, and then try to install through packman again
18:35:36 <napping> not if you install it locally
18:35:38 <napping> less sudo that way
18:36:03 <benmachine> napping: well, either way it shouldn't end up where pacman puts it, which is /usr/bin :)
18:40:30 <rhdoenges> how do I filter a list so that all elements are unique?
18:40:31 <steveklabnik> uuuuugh. okay. well. at least i got ghc and xmonad installed through pacman.
18:40:59 <benmachine> steveklabnik: good work, what remains?
18:41:01 <steveklabnik> but i'm back to the error i got in the very first place: it wants libgmp.so.3, which i dont have, because that's really old.
18:41:05 <benmachine> ah
18:41:08 <benmachine> what wants that?
18:41:17 <steveklabnik> it's what happens when i run startx
18:41:21 <augur> koninkje_away: oi
18:41:23 <steveklabnik> it says xmonad does
18:41:26 <augur> steveklabnik: whoa whoa whoa
18:41:32 <augur> dont you belong in #ranarchism
18:41:40 <steveklabnik> augur: theoretically. ;)
18:41:42 <steveklabnik> how's it going?
18:41:54 <augur> pretty good
18:42:03 <benmachine> steveklabnik: ok by the sounds of it the version of xmonad you installed isn't the one you're running, and you have an old one around somewhere
18:42:03 <augur> you?
18:42:12 <benmachine> steveklabnik: try xmonad --recompile from a command line
18:42:41 <augur> ezyang: link to the debate?
18:42:52 <ezyang> augur: Not posted yet, but I think it was video'd.
18:42:57 <augur> ah
18:42:58 <ezyang> So keep your eyes peeled.
18:43:01 <steveklabnik> benmachine: --recompile... now gives me cannot find module Xmonad.Util.EZConfig
18:43:05 <augur> this was eliezer yudkowsky, now?
18:43:12 <steveklabnik> augur: good, actually. about to start reading Capital. should be fun.
18:43:13 <ezyang> Yes. I spelled it wrong, didn't I. ^_^
18:43:16 <augur> no
18:43:24 <augur> oh it seems you did
18:43:25 <benmachine> steveklabnik: at a guess, you need xmonad-contrib?
18:43:26 <augur> didnt even notice
18:44:05 <steveklabnik> benmachine: yeah, seems reasonable.
18:44:52 <steveklabnik> aaaaaaaaaaaand it works!
18:45:00 <steveklabnik> thanks so much you guys!
18:45:20 <steveklabnik> talking through things helps so much. this is basically what i was doing, but you know what it's like when you start explaining a problem....
18:46:25 <benmachine> steveklabnik: :)
18:48:34 <ksf> how do I do a footnote on the haskellwiki?
18:48:41 <ksf> wikipedia's <ref> doesnt' work.
19:15:07 <JuanDaugherty> ksf it should, that's pretty basic
19:15:30 <JuanDaugherty> in the basic mediawiki pkg if somebody didn't clobber it
19:17:37 <JuanDaugherty> see thoughtcrime.biz/eg/EnWP shows a bunch of articles where I have copied templates and the like but cites are basic if it's the actual mediawiki pkg
19:17:38 <ksf> yessss. the usual answer to any bug I didn't like at work was "I don't believe it", too.
19:18:28 <byorgey> does anyone know of a LaTeX package for typesetting the sorts of proofs where in between each line you have the reason for that step listed in curly braces?
19:18:41 <ksf> haskell.org is chronically understaffed with admins.
19:19:07 <ksf> not with haskell hackers, mind you, but with admins that don't lose their dignity when digging around in non-haskell source.
19:19:30 <JuanDaugherty> byorgey, not off hand but sure there are several on CTAN if it's still or the PrimeTime TeX CD
19:20:15 <byorgey> ah, I found http://www.ctan.org/pkg/tex-ewd
19:20:21 <JuanDaugherty> AMSTeX too
19:20:26 <byorgey> the trick was just figuring out what to google for
19:22:05 <JuanDaugherty> *still there
19:24:03 <blackdog> anyone had luck getting the ghc llvm backend working on mac? it keeps telling me that -fllvm is incompatible with -fPIC and -dynamic
19:24:56 * ksf thinks "getting the llvm backend working" and "dynamically linking stuff" are distinct.
19:26:22 <blackdog> ksf: well, yes. i want to build one of my apps using the llvm backend though, and that's what's stopping me.
19:26:37 <blackdog> wondering if it's a known problem
19:27:14 <ksf> why do you want to dynamically link it?
19:27:22 <blackdog> i don't particularly
19:27:28 <blackdog> but i get that error when i pass -static too
19:27:31 <ksf> well, then don't.
19:27:34 <ksf> now that's strang.
19:27:45 <ksf> static is the default, though.
19:27:48 <eyu100> @pl f x a b c = a*x*x + b*x + c
19:27:49 <lambdabot> f = (((+) .) .) . ap (flip . (((.) . (+)) .) . (flip =<< ((*) .) . (*))) (*)
19:27:50 <Axman6> blackdog: 32 bit works i believe, not 64 bit
19:28:06 <wli> Gilbert Strang doesn't really have Brent's method around, though he does have plenty of other things.
19:28:08 <blackdog> ksf: running "ghc --make  -fforce-recomp -static -O2 -fllvm main.hs"
19:28:39 <eyu100> @pl f a = a + a + a * a + a + a + (a + a) - a - (a * a)
19:28:40 <Axman6> @pl f x a b c = ((a*x + b) * x + c
19:28:40 <lambdabot> f = liftM2 (-) ((-) =<< liftM2 (+) ((+) =<< (+) =<< ap ((+) . join (+)) (join (*))) (join (+))) (join (*))
19:28:40 <lambdabot> (line 1, column 11):
19:28:40 <lambdabot> unexpected "="
19:28:40 <lambdabot> expecting variable, "(", operator or end of input
19:28:44 <Axman6> @pl f x a b c = ((a*x + b) * x) + c
19:28:44 <lambdabot> f = (((+) .) .) . (flip =<< ((flip . ((*) .) . (+)) .) . (*))
19:29:30 <eyu100> @pl f x a h = let sq x = x*x in (sq (x-a)) + h
19:29:31 <lambdabot> f = flip flip (join (*)) . ((((+) .) . flip id) .) . (-)
19:30:19 <eyu100> @pl f = let f = f in f
19:30:19 <lambdabot> f = fix id
19:30:24 <thelema_> I'm trying to analyze the method of determining the clock resolution in criterion: https://github.com/bos/criterion/blob/master/Criterion/Environment.hs (measureEnvironment) Is this really using the average value of the difference of successive calls to getTime?
19:30:30 <eyu100> @pl f = f
19:30:30 <lambdabot> f = fix id
19:30:41 <eyu100> @pl f = undefined :: (Int -> Int)
19:30:41 <lambdabot> (line 1, column 3):
19:30:41 <lambdabot> unexpected "="
19:30:41 <lambdabot> expecting variable, "(", operator or end of input
19:30:41 <blackdog> Axman6: ok, just followed the warren of bash files calling bash files and it turns out i do have the 64 bit version of ghc installed.
19:31:08 <Axman6> blackdog: maybe you could keep going and find out how to make llvm work with 64 bit =)
19:31:17 <eyu100> @pl f x = Maybe 1
19:31:17 <lambdabot> f = const (Maybe 1)
19:31:25 <eyu100> @pl f x = Maybe x
19:31:25 <lambdabot> f = Maybe
19:31:36 <eyu100> @pl f x = Nothing
19:31:36 <lambdabot> f = const Nothing
19:31:56 <Saizan> blackdog: "ghc --info" next time :)
19:32:46 <eyu100> lololololol
19:32:46 <blackdog> Axman6: i've had the flu for three days. right now, web programming feels intellectually demanding;)
19:32:49 <eyu100> I lol'd
19:32:52 <blackdog> Saizan: gah. thanks :)
19:33:00 <Axman6> blackdog: ouch
19:33:11 <eyu100> lo
19:33:53 <eyu100> @pl f x = f . g
19:33:53 <lambdabot> f = fix (const . (. g))
19:34:12 <eyu100> @pl f x = (f+f)
19:34:13 <lambdabot> f = fix (const . join (+))
19:35:06 <kmc> is there a good writeup on how @pl works?
19:38:09 <ddarius> The source.
19:38:18 <danharaj> pff
19:38:22 <ddarius> It's just a (poorly implemented) optimizing compiler to combinators.
19:38:41 <ddarius> In that regard, David Turner's earlier work is relevant.
19:46:08 <danharaj> is there a way to change the rounding behavior of `round'? Like an obscure flag I can pass to GCC?
19:48:26 <ddarius> Use a different function (?)
19:49:43 <danharaj> Well round gets compiled down to a primop, and the rounding behavior is the default rounding mode for IEEE754 Floats. I was wondering if I can change the rounding mode of the hardware.
19:49:59 <kmc> you can do so by a foreign call
19:50:26 <kmc> you probably have to do one per RTS thread
19:50:35 <kmc> it applies to all Haskell threads that get scheduled on that RTS thread
19:50:45 <danharaj> sounds hairy.
19:50:52 <danharaj> but I suppose that's what I get.
19:51:01 <kmc> this is what you get when you mess with us
19:51:16 <ion> hammer time
19:51:28 <blackdog> kmc: oh, i love lambda police!
19:52:36 <c_wraith> I don't know any way to run code on each of the GHC capabilities
19:54:00 <c_wraith> or how to detect what capability you're bound to
19:54:26 <c_wraith> (even for forkOS threads, which are bound to a single capability)
19:55:25 <danharaj> sounds like you can break referential transparency by changing the state of the FPU in a thread then.
19:55:32 <thelema_> what does "U.tail . U.filter (>=0) . U.zipWith (-) (U.tail times) $ times" do when U is Data.Vector.Unboxed?
19:56:02 * aavogt thought this package messed with rounding modes, but apparently not http://hackage.haskell.org/package/intervals-0.2.0.1
19:56:57 <c_wraith> thelema_: computes a new vector contain the differences between adjacent elements
19:57:05 <c_wraith> (of the original)
19:57:20 <thelema_> c_wraith: the filter (>=0) part removes negative values, right?
19:57:27 <c_wraith> oh, right.  yes
19:58:07 <thelema_> and "getTime" does exactly that - returns the current time, right?
19:58:11 <c_wraith> yes
19:58:26 <kmc> danharaj, indeed you can
19:58:41 <kmc> but there are lots of other ways to break referential transparency by making foreign calls
19:59:00 <thelema_> hmm, very odd.  I dunno what the meaning of the mean of the difference vector would be
20:00:17 <napping> sounds like Haar wavelet stuff
20:00:58 <thelema_> napping: it's part of the criterion code for computing the timer resolution
20:01:10 <napping> wait, no I'm confused
20:01:36 <napping> those wavelets only use differences of averages
20:01:58 <c_wraith> oh.  well, negative differences indicate timer rollover, so I can see why those are thrown out
20:02:40 <thelema_> the filter makes sense, but the mean doesn't.
20:02:47 <c_wraith> sure it does
20:02:53 <c_wraith> it's the average time it takes to do an iteration of the loop
20:02:56 <napping> If it calls the timer a bunch of times in a row, differences between successive calls is the interval
20:03:28 <thelema_> isn't the clock resolution the minimum amount of time it can measure?
20:03:52 <c_wraith> yes
20:03:53 <thelema_> i.e. if you call the getTime function twice quickly enough, you get the same time
20:04:09 <napping> then you'd always decide the resolution was zero
20:04:19 <thelema_> after the resolution length of time passes, you're guaranteed to get the "next" time value
20:04:20 <c_wraith> napping: not with enough samples
20:04:23 <rhdoenges> is there a standard factoring function or do I need to roll my own?
20:04:29 <napping> If you took the minimum, I mean
20:04:44 <napping> I think average is probably a better idea of timer overhead
20:04:50 <thelema_> well, I don't see how keeping zero values could be useful
20:05:11 <c_wraith> thelema_: differences of successive values will be zero when you're sampling faster than the clock resolution
20:05:12 <thelema_> napping: there's a separate routine to compute the cost of a timer call.
20:05:22 <napping> Well, if it always comes out zero then there is probably negligible timer overhead
20:05:26 <c_wraith> thelema_: those are *very* important
20:05:49 <c_wraith> thelema_: because when you average over all the zeros and the non-zeros, *that* is when you get the average time
20:06:09 <napping> Ah, that makes sense
20:06:10 <thelema_> but why is the average time = the clock resolution?
20:06:18 <rhdoenges> (for prime factorization)
20:06:22 <napping> if the timer is actually better than the resolution the result is returned in
20:06:45 <napping> rhdoenges: I doubt it's in the standard libraries, but maybe on hackage
20:07:35 <rhdoenges> napping: thanks.
20:07:43 <thelema_> If I wanted the timer resolution, I'd take differences between timer calls, and find the nonzero minimum of all these differences
20:08:36 <thelema_> of course if the timer had resolution higher (less time) than its cost for calling, this wouldn't work, as I'd get multiples of the timer each time
20:11:37 <aavogt> @hackage primes
20:11:37 <lambdabot> http://hackage.haskell.org/package/primes
20:15:33 <ddarius> @quote Manuel.Chakravarty unsafePerformIO
20:15:33 <lambdabot> No quotes for this person. Your mind just hasn't been the same since the electro-shock, has it?
20:15:41 <ddarius> @quote Chakravarty unsafePerformIO
20:15:41 <lambdabot> No quotes for this person. This mission is too important for me to allow you to jeopardize it.
20:16:17 <ion> @quote unsafePerformIO
20:16:18 <lambdabot> danharaj: says: unsafePerformIO : The gateway function
20:16:22 <ion> @quote unsafePerformIO
20:16:23 <lambdabot> c_wraith says: oh.  well, then.  some actually *do* simply unsafePerformIO into Mordor.
20:16:36 <c_wraith> I said that?  hm.
20:16:41 <Hunner> heh
20:17:11 <shachaf> ?remember c_wraith I said that?  hm.
20:17:11 <lambdabot> Okay.
20:19:45 <ddarius> @remember ManuelChakravarty After all, you can import any C function with a pure type which also allows you to wreak arbitrary havoc.  We enable the user to disguise arbitrary machine code as a Haskell function of essentially arbitrary type.  In comparison, `unsafePerformIO' seems angelic.
20:19:46 <lambdabot> I will never forget.
20:22:12 <kmc> @type unsafePerformIO
20:22:16 <lambdabot> Not in scope: `unsafePerformIO'
20:22:18 <kmc> @quote unsafe
20:22:18 <lambdabot> Peaker says: * FunctorSalad doesn't think things like sexuality are impure <Peaker> only if wrapped in unsafePerform...
20:22:22 <ivanm> @hoogle unsafePerformIO
20:22:23 <lambdabot> Foreign unsafePerformIO :: IO a -> a
20:22:23 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
20:22:28 <kmc> @quote unsafe
20:22:29 <lambdabot> danharaj says: unsafeCoerce should be renamed to badPun
20:22:33 <kmc> hehehe
20:22:41 <kmc> it might be a *good* pun
20:22:49 <kmc> but the burden is on the code author
20:50:17 * hackagebot shady-gen 0.5.1 - Functional GPU programming - DSEL & compiler  http://hackage.haskell.org/package/shady-gen-0.5.1 (ConalElliott)
20:52:18 * hackagebot shady-graphics 0.5.0 - Functional GPU programming - DSEL & compiler  http://hackage.haskell.org/package/shady-graphics-0.5.0 (ConalElliott)
20:56:10 <inter> Does a good Haskell library for performing narrowing computations in a nondeterministic context exist? I have been using Curry, but constantly re-rolling nonexistent libraries is a pain.
20:59:20 * wli wonders if things have finally calmed down enough for him to even start attempting a from-scratch implementation of Brent's method for minimization as described in http://linneus20.ethz.ch:8080/1_5_2.html
21:00:11 <wli> (The GSL library routine for this is spoiled by abort() calls on minimization failure instead of orderly returns of failure codes.)
21:00:16 <ivanm> inter: what do you mean?
21:05:17 <Axman6> wli: do you know the full name of this Brent person?
21:05:50 <Axman6> it's not richard brent is it?
21:06:12 <wli> Axman6: Richard Brent, Algorithms for minimization without derivatives, Prentice-Hall (1973), republished by Dover in paperback (2002), ISBN 0-486-41998-3.
21:06:30 <Axman6> huh, he was my lecturer last semester
21:08:06 <Axman6> i think... unless there's another richard brent working on similar things...
21:09:51 <eyu100_> @help
21:09:51 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:09:58 <eyu100_> @list
21:09:59 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
21:10:04 <Axman6> ha, it is him. this is the second time in a month or so I've run into some work by him
21:10:53 <eyu100_> > let (a, b, c, x) = (1, 1, 1, 1) in a*x*x+b*x+c
21:10:55 <lambdabot>   3
21:13:57 <wli> For that (a,b,c) coefficient triple, it's x^2 + x + 1 = (x+1/2)^2 + 3/4, minimized at x = -1/2 (which may or may not be within the interval for minimization search).
21:16:48 <eyu100_> lol
21:17:18 <eyu100_> > case 1 of 1 -> 2 ; 2 -> 3
21:17:19 <lambdabot>   2
21:17:39 <kmc> > let 2+2 = 5 in 2+2
21:17:40 <lambdabot>   5
21:17:43 <eyu100_> if True then True; else False
21:17:49 <dankna> lol
21:17:52 <eyu100_> > if True then True; else False
21:17:54 <lambdabot>   <no location info>: parse error on input `;'
21:17:58 <kmc> you have not been paying attention
21:18:04 <eyu100_> > if True then True else False
21:18:04 <lambdabot>   True
21:18:12 <kmc> > fix error
21:18:13 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
21:18:17 <eyu100_> rofl
21:18:31 <kmc> triple fault!
21:18:35 <eyu100_> kmc how does your 2+2=5 work?
21:18:42 <dankna> it shadows the definition of +
21:18:50 <kmc> > let 2+2 = 5 in 3+3
21:18:51 <lambdabot>   *Exception: <interactive>:3:4-10: Non-exhaustive patterns in function +
21:19:05 <eyu100_> > let 2+2 = 5 in 4
21:19:06 <lambdabot>   4
21:19:10 <kmc> > let 0 = 1 in 4
21:19:11 <lambdabot>   4
21:19:19 <dankna> > let 0 = 1 in 0
21:19:19 <lambdabot>   0
21:19:22 <eyu100_> > let 1 = 2 in let 1 = 3 in 1
21:19:23 <lambdabot>   1
21:19:27 <eyu100_> ???
21:19:33 <kmc> "let" is lazy
21:19:43 <dankna> > let !0 = 1 in 0
21:19:44 <lambdabot>   *Exception: <interactive>:3:4-9: Non-exhaustive patterns in pattern binding
21:19:48 <kmc> it only matches patterns when the variables in those patterns are forced
21:19:51 <kmc> in this case, no variables
21:19:55 <dankna> ahhh
21:19:56 <dankna> of course
21:19:58 <eyu100_> > let !1 = 2 in let !1 = 3 in 1
21:19:58 <lambdabot>   *Exception: <interactive>:3:4-9: Non-exhaustive patterns in pattern binding
21:20:02 <eyu100_> ah
21:20:12 <eyu100_> let !1 = !1 in !1
21:20:20 <eyu100_> > let !1 = !1 in !1
21:20:21 <lambdabot>   <no location info>: parse error on input `!'
21:20:38 <eyu100_> > take 2 [1..]
21:20:39 <lambdabot>   [1,2]
21:20:43 <eyu100_> > take 2 ![1..]
21:20:44 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
21:20:44 <lambdabot>         against inferred t...
21:20:57 <eyu100_> > 2#
21:20:57 <lambdabot>   Couldn't match kind `#' against `*'
21:21:24 <eyu100_> > runST undefined
21:21:25 <lambdabot>   *Exception: Prelude.undefined
21:21:37 <eyu100_> > fix undefined
21:21:38 <lambdabot>   *Exception: Prelude.undefined
21:21:51 <eyu100_> > undefined >> undefined >> arr undefined
21:21:52 <lambdabot>   No instance for (GHC.Show.Show (a b b1))
21:21:52 <lambdabot>    arising from a use of `M1083961...
21:22:04 <eyu100_> lol I like how undefined can be any type
21:22:23 <eyu100_> > undefined . undefined
21:22:24 <lambdabot>   No instance for (GHC.Show.Show (f b))
21:22:24 <lambdabot>    arising from a use of `M1384524248...
21:22:31 <identity_> :t undefined . undefined
21:22:32 <kmc> > let undefined = undefined in undefined
21:22:32 <lambdabot> forall b (f :: * -> *). (Functor f) => f b
21:22:35 <lambdabot>   mueval-core: Time limit exceeded
21:22:38 <identity_> it's pretty useful
21:22:38 <eyu100_> > putStrLn "hi"
21:22:39 <lambdabot>   <IO ()>
21:22:40 <kmc> :t let undefined = undefined in undefined
21:22:41 <lambdabot> forall t. t
21:22:52 <identity_> for writing up interfaces and implementing them later on
21:22:52 <kmc> eyu100_, lambdabot will evaluate IO but won't execute it
21:23:00 <eyu100_> ah
21:23:09 <eyu100_> will it do ST?
21:23:20 <kmc> > runST (return ())
21:23:21 <lambdabot>   ()
21:23:27 <eyu100_> > return ()
21:23:28 <lambdabot>   No instance for (GHC.Show.Show (m ()))
21:23:28 <lambdabot>    arising from a use of `M843155473...
21:23:34 <kmc> > runST (newSTRef 0 >>= readSTRef)
21:23:35 <lambdabot>   0
21:24:02 <eyu100_> > return 5 >>= (\x -> 1 :: Maybe Int)
21:24:03 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
21:24:03 <lambdabot>    arising f...
21:24:05 <identity_> :t runST
21:24:06 <lambdabot> forall a. (forall s. ST s a) -> a
21:24:17 <eyu100_> :t gfoldl
21:24:18 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall d b. (Data d) => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
21:24:23 <eyu100_> ^^
21:24:29 <eyu100_> crazy type...
21:24:36 <kmc> yep, gfoldl is quite a function
21:24:44 <wli> Axman6: The initial bracketing search is throwing me for a loop. The iteration once a bracketing triplet is established is easy enough to understand, though.
21:24:51 <identity_> doesn't not grok
21:24:54 <identity_> does*
21:25:03 <eyu100_> what's the most complicated type you've seen used seriously?
21:25:20 <kmc> eyu100_, http://hackage.haskell.org/packages/archive/sessions/2008.7.18/doc/html/Control-Concurrent-Session.html
21:25:25 <eyu100_> for me it's gfoldl but I don't know that much about haskell
21:25:39 <eyu100_> wtf?
21:26:10 <identity_> never seen gfoldl used and I don'teven understand what it's used for
21:26:18 <identity_> But I probabl know less haskell than you do
21:26:33 <kmc> to understand gfoldl you should read the "Scrap Your Boilerplate" papers
21:26:51 <kmc> even then it's dodgy
21:26:56 <shachaf> SPJ's slides are helpful too.
21:27:05 <eyu100_> why is Control.Concurrent.Session so complicated?
21:27:06 <kmc> slides on syb?
21:27:26 <shachaf> Yes. http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/
21:28:00 <shachaf> https://docs.google.com/viewer?url=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fum%2Fpeople%2Fsimonpj%2Fpapers%2Fhmap%2FBoilerplate%2520v3.ppt
21:29:12 <kmc> @quote <kmc> boilerplate
21:29:12 <lambdabot> <kmc> says: SYB has some pretty serious machinery inside <kmc> as though all the scrapped boilerplate has been bolted together to make some kind of steam-powered death robot
21:29:20 <Saizan> "PhD required" on slide 7 is quite ironic, considering they are advocating SYB instead
21:29:30 <ddarius> inter: You probably want to look at the Wired papers.
21:29:53 <ddarius> SYB is atrocious.
21:30:24 <eyu100_> is uniplate better?
21:30:51 <ddarius> It's not as powerful, but it's much simpler, and much more controlled, and much more efficient.
21:30:55 <ddarius> See also multiplate.
21:31:52 <eyu100_> lol the syb slides say it is simple and elegant
21:32:00 <ddarius> What would really be awesome is if Haskell got pattern calculus features, but that would change Haskell too much to happen.
21:32:49 <shachaf> Pattern calculus features?
21:33:39 <Jafet> Hm, would it really?
21:33:53 <ddarius> @google Delia Kesner first class patterns
21:33:55 <lambdabot> http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/k/Kesner:Delia.html
21:33:55 <lambdabot> Title: DBLP: Delia Kesner
21:34:01 <ddarius> @google Barry Jay bondi
21:34:03 <lambdabot> http://third-bit.com/blog/archives/3335.html
21:34:03 <lambdabot> Title: The Third Bit » Blog Archive » 11 Programming Languages Worth Checking Out
21:34:10 <ddarius> Bloody shite
21:35:15 <Jafet> I thought Bondi was pronounced “bond-ee”.
21:35:33 <A1kmm> Has anyone else had trouble building text-0.11.1.3 (and text-0.11.1.2) with --enable-shared?
21:35:49 <Jafet> Oh, it is.
21:35:57 <ivanm> Jafet: you referring to the beach?
21:36:02 <ivanm> if so, it's bond-eye
21:36:41 <ddarius> It's a programming language named after the beach.
21:39:13 <A1kmm> Well, if anyone else has the problem, it was fixed by ghc-pkg recache - may have been related to upgrading Cabal rather than anything text specific.
21:43:07 <Axman6> ddarius: i think there's some problems with pattern calculus at the moment relating to type checking, it's possible that types cannot be known until runtime i think
21:45:09 <ddarius> There are statically typed pattern calculi.  Bondi is statically typed.
21:58:33 <poindontcare> umm, trying to build haskell and getting the following error utils/ghc-cabal/ghc-cabal.hs:356:                        ++ extensionsToFlags (compiler lbi) (extensions bi)
21:58:46 <poindontcare> utils/ghc-cabal/ghc-cabal.hs:356:61: Not in scope: `extensions'
21:59:16 <poindontcare> when I run make in ghc after a darcs update
22:00:52 <eyu100_> :i gfoldl
22:00:57 <eyu100_> :t gfoldl
22:00:58 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall d b. (Data d) => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
22:01:30 <eyu100_> :t (~||~)
22:01:31 <lambdabot> Not in scope: `~||~'
22:01:37 <eyu100_> :t sjump
22:01:37 <lambdabot> Not in scope: `sjump'
22:01:49 <eyu100_> > fmap fmap fmap
22:01:49 <lambdabot>   Overlapping instances for GHC.Show.Show
22:01:50 <lambdabot>                              ((a ->...
22:02:03 <eyu100_> @pf f = fmap fmap fmap
22:02:04 <lambdabot> Maybe you meant: bf pl
22:02:12 <eyu100_> @pl f = fmap fmap fmap
22:02:12 <lambdabot> f = fmap fmap fmap
22:02:24 <eyu100_> :t fmap fmap fmap
22:02:25 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
22:02:40 <Eduard_Munteanu> poindontcare: you might want to try in #ghc too
22:03:40 <poindontcare> ah thanks
22:32:43 <ttvd_> hi, how do i get something like MAX_INT in haskell?
22:32:51 <ttvd_> i want max values for types
22:34:05 <dobblego> @type maxBound
22:34:05 <lambdabot> forall a. (Bounded a) => a
22:37:16 <ivanm> is there any way to specify that I want integral values in ghci to default to Int rather than Integral?
22:37:19 <ttvd_> how does that work?
22:37:33 <ivanm> > maxBound :: Int
22:37:34 <lambdabot>   9223372036854775807
22:37:35 <ivanm> ttvd_: ^^
22:37:45 <ivanm> @src Bounded
22:37:46 <lambdabot> class  Bounded a  where
22:37:46 <lambdabot>     minBound, maxBound :: a
22:37:49 <ttvd_> thanks
22:43:22 <eyu100_> > maxBound :: Float
22:43:22 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Float)
22:43:23 <lambdabot>    arising from a use of...
22:43:30 <eyu100_> > maxBound :: Char
22:43:30 <lambdabot>   '\1114111'
22:43:40 <eyu100_> > minBound :: Char
22:43:41 <lambdabot>   '\NUL'
22:43:55 <eyu100_> > undefined
22:43:56 <lambdabot>   *Exception: Prelude.undefined
22:44:02 <eyu100_> :t undefined
22:44:03 <lambdabot> forall a. a
22:44:13 <eyu100_> :t Num a
22:44:13 <lambdabot> Not in scope: data constructor `Num'
22:44:21 <eyu100_> :t Just 1
22:44:21 <lambdabot> forall t. (Num t) => Maybe t
22:44:33 <eyu100_> :t Just 1.2
22:44:34 <lambdabot> forall t. (Fractional t) => Maybe t
22:44:42 <eyu100_> :t Just Just Just Just Nothing
22:44:43 <lambdabot>     Couldn't match expected type `(a -> Maybe a)
22:44:43 <lambdabot>                                   -> (a1 -> Maybe a1)
22:44:44 <lambdabot>                                   -> Maybe a2
22:45:01 <eyu100_> :t Just$Just$Just$Just$Just$Just$Just$Nothing
22:45:01 <lambdabot> forall a. Maybe (Maybe (Maybe (Maybe (Maybe (Maybe (Maybe (Maybe a)))))))
22:45:19 <eyu100_> :t Just
22:45:19 <lambdabot> forall a. a -> Maybe a
22:45:24 <eyu100_> :t Nothing
22:45:25 <lambdabot> forall a. Maybe a
22:45:31 <eyu100_> :t ()
22:45:32 <lambdabot> ()
22:45:42 <eyu100_> :t () -> ()
22:45:43 <lambdabot> parse error on input `->'
22:45:52 <eyu100_> :t undefined :: () -> ()
22:45:52 <lambdabot> () -> ()
22:46:11 <eyu100_> @pl f x = undefined x
22:46:12 <lambdabot> f = undefined
22:46:16 <eyu100_> @free f x = x
22:46:17 <lambdabot> Extra stuff at end of line
22:46:24 <eyu100_> @free (f x = x)
22:46:25 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
22:46:33 <eyu100_> @free forall a. a
22:46:34 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
22:46:38 <eyu100_> @help free
22:46:38 <lambdabot> free <ident>. Generate theorems for free
22:46:45 <eyu100_> @free id
22:46:45 <lambdabot> f . id = id . f
22:46:56 <eyu100_> @free const
22:46:56 <lambdabot> f . const x = const (f x) . g
22:47:03 <eyu100_> @free fix
22:47:04 <lambdabot> f . g = h . f => f (fix g) = fix h
22:47:18 <eyu100_> @free show
22:47:19 <lambdabot> Extra stuff at end of line in retrieved type "forall a. (Show a) => a -> String\n"
22:47:31 <eyu100_> @free (+)
22:47:31 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
22:47:35 <eyu100_> @free +
22:47:35 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
22:47:45 <eyu100_> @free (+1)
22:47:45 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
22:47:51 <eyu100_> @free cons
22:47:51 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `cons'\n\n"
22:48:18 <eyu100_> @free return
22:48:18 <lambdabot> Expected variable or '.'
22:48:26 <eyu100_> @free >>=
22:48:26 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
22:48:40 <eyu100_> free Int -> Int
22:48:43 <eyu100_> @free Int
22:48:43 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
22:48:48 <eyu100_> @free f::Int
22:48:48 <lambdabot> f = f
22:48:53 <eyu100_> @free f::Maybe Int
22:48:54 <lambdabot> $map_Maybe $id f = f
22:49:03 <ion> How about doing that in private?
22:49:26 <eyu100_> great idea
22:49:30 <eyu100_> sorry I'm a noob XD
23:06:40 <hpaste> Sordina pasted “Dragon Curve ASCII” at http://hpaste.org/48550
23:14:34 <hpaste> Sordina annotated “Dragon Curve ASCII” with “Dragon Curve ASCII (annotation)” at http://hpaste.org/48550#a48551
