00:05:33 <Arafangion> rprije: While I don't know haskell (yet), I do wonder if you mean "option" when you say "alternative"?
00:06:16 <shachaf> You may not know Haskell, but clearly you've already picked up the spirit of pedantry. :-)
00:07:51 <Arafangion> shachaf: Heh, but I disagree! "alternative" means he wants a completely different option!
00:08:22 <shachaf> "alternative" is used in the sense of "pick one of N alternatives".
00:08:49 <Arafangion> That's recursive.
00:09:10 <shachaf> I gave an example, not a definition.
00:09:40 <Arafangion> shachaf: Interesting, the dictionary agrees with you.
00:10:58 * Arafangion disagrees with the dictionary, then goes and hunts for some meat.
00:54:25 * hackagebot blaze-html 0.4.1.4 -   http://hackage.haskell.org/package/blaze-html-0.4.1.4 (JasperVanDerJeugt)
01:39:55 <isomorphic> So, I'm using quickcheck and I have a function with the signature listOfInt :: Gen [Int]
01:40:10 <isomorphic> It generates a list of Int's using listOf1
01:40:32 <isomorphic> I'd like to constrain listOfInt to generate Positive Integers
01:40:51 <isomorphic> that is, change the signature to listOfInt :: Gen [Positive Int]
01:41:16 <isomorphic> However, it seems like the 'Positive' newtype stops the rest of my code typechecking
01:41:54 <isomorphic> What do I do at the border of my 'Positive Int' code and my 'Int' code to satisfy the type checker?
01:44:25 <ski> presumably there's some unwrapper function for `Positive'
01:45:24 <ski> or you could probably rewrite `listOfInt' to use a specialized generator for `Int', which only generates positive integers
01:45:59 <isomorphic> ski: that second solution is effectively what I've done in the past
01:46:15 <isomorphic> it just strikes me that there ought to be a better way, given the existence of 'Positive'
01:46:30 <ski> how is `Positive' defined ?
01:47:19 <ski> i assume it's something like `newtype Positive a = MkPositive {unPositive :: a}'
01:47:21 <isomorphic> http://hackage.haskell.org/packages/archive/QuickCheck/2.1.0.1/doc/html/src/Test-QuickCheck-Arbitrary.html#Positive
01:48:00 <isomorphic> yup, with a newtype
01:48:12 <Cale> isomorphic: fmap (map Positive) ?
01:48:23 <ski> ok, there seems to be no unwrapper, so you have to do it yourself
01:48:40 <Cale> You want to wrap your values in Positive, right?
01:48:50 <Cale> The constructor is exposed
01:48:50 <ski>   listOfInt = liftM (map (\(Positive n) -> n)) (..original code..)
01:48:54 <ski> Cale : the other way around
01:49:08 <ski> or define `getPositive :: Positive a -> a', and use that there
01:49:12 <Cale> "I have a function with the signature listOfInt :: Gen [Int]... I'd like to constrain listOfInt to generate Positive Integers"
01:49:26 <ski> <somorphic> However, it seems like the 'Positive' newtype stops the rest of my code typechecking
01:49:29 <Cale> that reads the other way around to me :)
01:49:33 <Cale> hmm
01:49:47 <Cale> isomorphic: What are you trying to do exactly? ;)
01:50:00 <isomorphic> I'd like to get rid of the Positive type :P
01:50:14 <isomorphic> so, I'll generate some ints that are positive
01:50:18 <isomorphic> Positive*
01:50:26 <ski> i thought the rest of the code wanted `Int', but `listOfInt' used `Positive', since that's what isomorphic wanted to generate there
01:51:02 <isomorphic> Yes, the re st of the code wants Int- specifically, I'm trying to place the Positive Int into a data type that takes an Int
01:51:15 <isomorphic> I'm wondering how to fix things so that the types line up
01:51:25 <isomorphic> Pattern matching looks to be the best option so far
01:51:26 <Cale> Then pattern match the Positive constructor :)
01:51:28 <Cale> yeah
01:51:38 <Cale> It's pretty much the only option to start with
01:51:39 <ski> so, if you add `liftM (map getPositive)', that should convert the body from `Positive Int' to `Int'
01:51:49 <ski> so you could retain `listOfInt :: Gen [Int]' then
01:52:24 <ski> (or you could make a wrapper, with that type .. or you could change all the users instead, which might be more work)
01:56:46 <isomorphic> let fromPositive x = (\(Positive y) -> y)
01:56:57 <isomorphic> ^-- should that work?
01:57:59 <ski> you're not using `x'
01:58:12 <ski>   getPositive (Positive a) = a
01:58:13 <ski> should work
01:58:18 <ski> or
01:58:25 <ski>   getPositive = \(Positive a) -> a
01:58:30 <ski> if you really want to
01:58:40 <isomorphic> ah - good point :P
01:58:49 <isomorphic> second one is pointfree?
01:58:54 <ski> no
01:59:02 <ski> `a' is the point :)
01:59:27 <isomorphic> ah, thanks ski :)
01:59:45 <isomorphic> and thanks Cale!
02:00:24 <ski> (and you're not going to be able to make it point-free, or at least you need some operation that uses explicit pattern-matching, for other (possibly pointfree) operations to be able to call that, to unwrap)
02:01:16 <isomorphic> incidentally, I notice that the data construction Positive doesn't seem to be exposed by import Test.QuickCheck (Positive) - does that seem right?
02:02:39 <ski>   import Test.QuickCheck (Positive (Positive))
02:02:40 <ski> or
02:02:42 <ski>   import Test.QuickCheck (Positive (..))
02:03:34 <ski> (though,hm .. i thought that you couldn't hide the data constructor but not the type constructor, if you named them the same)
02:05:20 <isomorphic> lol.  so, incidentally, if you unwrap the Positive values... you get regular negative values :?
02:05:24 <isomorphic> :/ * even
02:06:27 <ski> you get regular `Int's
02:06:40 <ski> and since they're already generated, they should be positive
02:06:42 <isomorphic> yup
02:07:04 <ski> (unless you somewhere cheat and wrap non-positive integers inside `Positive')
02:07:23 <isomorphic> well, that's how quickcheck does it - it wraps non-positive ints
02:09:02 <ski> surely it wraps *positive* integers ?
02:09:14 <ski> (otherwise it wouldn't be very useful)
02:09:29 <benmachine> isomorphic: are you definitely using a Gen Positive, and not something like fmap Positive (Gen Int)
02:09:46 <benmachine> (not that the latter is syntax that makes sense but still)
02:09:52 <isomorphic>  Gen [Positive Int]
02:10:34 <isomorphic> listOfInt :: Gen [Positive Int] ;listOfInt = listOf1 arbitrarySizedIntegral
02:10:50 <ski> isomorphic : as long as you're not yourself wrapping any values in the data constructor `Positive', you should be fine
02:11:20 <ski> @type Test.QuickCheck.listOf1
02:11:21 <lambdabot> forall a. Gen a -> Gen [a]
02:11:34 <ski> isomorphic : it looks ok
02:12:52 <ski> if you do
02:12:59 <ski>   listOfInt :: Gen [Int]
02:13:28 <ski>   listOfInt = (getPositive `map`) `liftM` listOf1 arbitrarySizedIntegral
02:13:32 <ski> that should also be ok
02:13:39 <ski> hm, that could be simplified to
02:13:56 <ski>   listOfInt = listOf1 (getPositive `liftM` arbitrarySizedIntegral)
02:14:34 <ski> the `getPositive' will unsure that `arbitrarySizedIntegral' has type `Gen (Positive Int)', so that it only generates positive integers
02:14:42 <ski> s/unsure/ensure/ :)
02:14:48 <ski> isomorphic : ^
02:15:00 <isomorphic> ski: thank
02:15:02 <isomorphic> thanks*
02:15:25 <isomorphic> while we're here - you mentioned above - getPositive `liftM` arbitrarySizedIntegral
02:15:51 <isomorphic> I assume that this is to lift the getPositive function into the monad returned by arbitrarySizedIntegral
02:16:12 <isomorphic> can you contrast the use of `liftM` with the use of `fmap`?
02:16:39 <ski> using `liftM' and `fmap' would be the same
02:17:09 <isomorphic> ah - that's good :)  I'm picking something up :P
02:17:23 <ski> if `Monad' had `Functor' as a superclass, as would be good and proper, we wouldn't need `liftM' at all
02:17:28 <ion> > (succ <$> [42], succ `fmap` [42], succ `liftA` [42], succ `liftM` [42])
02:17:29 <lambdabot>   ([43],[43],[43],[43])
02:17:43 <isomorphic> ah - gotcha
02:18:04 <isomorphic> Monad vs Functor - and the curiosity that even though a monad is a functor, Haskell doesn't think so.
02:18:05 <ski> as it is now, for monads which someone has recalled to make an instance of `Functor', you can use either, and they should work the same
02:18:21 <ski> (if they do not, someone has made a bug)
02:18:22 <isomorphic> ah - thanks :)
02:18:28 <isomorphic> the pieces are fitting together
02:18:32 <isomorphic> (slowly)
02:18:47 <ski> so, if you want, in those cases you could always use `fmap' instead of `liftM'
02:19:18 <ski> but if you're writing code which is polymorphic in a monad, then you need `liftM', otherwise you're adding another `Functor' class constraint
02:19:43 <ion> I tend to use applicative functors a lot and only use the monad instance when i really need the functionality of >>=
02:20:06 <ski> that might be bearable in some cases, but in some polymorphic cases, you have to match an interface that doesn't provide `Functor', so then you *must* use `liftM' (or an equivalent thereof)
02:20:22 <ski> ion : yeah, that's generally a good idea
02:21:40 <isomorphic> @type filter
02:21:41 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
02:21:51 <ski> @type partition
02:21:52 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
02:21:58 <isomorphic> @type sort
02:21:59 <lambdabot> forall a. (Ord a) => [a] -> [a]
02:22:07 <ski> @type sortBy
02:22:08 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
02:22:35 <isomorphic> So, I am chaining together a heap of functions - sort, nub, etc, using fmap
02:23:03 <isomorphic> I just added a new one - (filter (not . (==) x)) - again using fmap - and it freaked out
02:24:01 <isomorphic> Ie: sort `fmap` nub `fmap` (map fromPositive) `fmap` listOfInt
02:24:04 <isomorphic> (okay)
02:24:05 <isomorphic> but
02:24:08 <ski> you could write `(==) x' as `(x ==)'
02:24:35 <ski>   (sort . nub . map fromPositive) `fmap` listOfInt
02:25:27 <scree> sorry, what are the types meant to be there?
02:25:59 <scree> it looks like you want "sort . nub . map fromPositive $ listOfInt"
02:26:17 <ski> scree : `listOfInt :: Gen [Positive Int]' and `sort . nub . map fromPositive :: [Positive Int] -> [Int]'
02:26:27 <scree> ah ok
02:27:53 <shachaf> sort . nub is probably more efficiently written as (Set.toList . Set.fromList).
02:28:25 <scree> or fmap head . group . sort
02:28:29 <scree> but the guy left
02:28:34 <shachaf> Oh.
02:28:43 <scree> oh no, he's back
02:28:51 <isomorphic> sorry - I have dodgy internet ;)
02:29:17 * ski doesn't recall the relative precedences of `.' and `fmap' .. possibly you can remove the brackets around the composition chain
02:29:21 <shachaf> Also, fmap f (fmap g x)) == fmap (f . g) x
02:29:45 <shachaf> Alternatively, (.) = fmap is always associative. :-)
02:29:49 <ski> <shachaf> sort . nub is probably more efficiently written as (Set.toList . Set.fromList).
02:29:52 <ski> <scree> or fmap head . group . sort
02:30:12 <ski> shachaf :)
02:30:18 <isomorphic> hrmm - so I am trying to add a filter to my composition chain
02:30:37 <isomorphic> filter (not . (x ==)) - but x has type Gen Int
02:30:49 <ski> oh
02:31:01 <scree> monad time
02:31:08 <ski> you'll need to execute the action, then
02:31:33 <isomorphic> Excellent - a motivated monad example :P
02:31:48 * hackagebot hlint 1.8.11 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.11 (NeilMitchell)
02:33:50 <isomorphic> So, to let ghci help me - I've broken it into two lines
02:34:05 <isomorphic> c  <-  (sort . nub . map fromPositive) `fmap` listOfInt
02:34:11 <ski>   (uncurry (filter . (not .: (==))) . second (sort . nub . map fromPositive)) `fmap` liftM2 (,) x listOfInt
02:34:14 <ski> might work
02:34:19 <isomorphic> dp <- filter (not . (x ==)) c
02:34:29 <ski> hm, i suppose `not .: (==)' is just `(/=)', though
02:34:31 <isomorphic> (that second part is obviously naive)
02:34:50 <isomorphic> @type uncurry
02:34:51 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
02:35:07 <ski> using `do'-notation, you need basically `n <- x' somewhere
02:35:21 <ski> (in my case, it's hidden inside `liftM2')
02:35:52 <isomorphic> okay, so with do notation
02:36:07 <isomorphic> I've got the line c <- ( sort ... )
02:37:02 <ski> so then you need `filter (n /=) c', yes ?
02:37:45 <isomorphic> okay - that line doesn't have a <-?
02:37:55 <isomorphic> that is, an `<-`
02:38:10 <ski> well, you'll probably want to wrap it in `return', if you don't want to do anything more with it
02:38:52 <ski> (you could probably use `fmap' with `filter' on the `n <- x' line, but i've got a feeling it might look ugly)
02:39:11 <isomorphic> well, actually, I'd like to pass it to a data type constructor and return that
02:39:25 <ski> ok, then do that :)
02:39:44 <isomorphic> lol - yes, sorry, was thinking out loud
02:39:49 <isomorphic> or typing, or something
02:42:03 <isomorphic> oh, weird
02:42:19 <isomorphic> so, after c  <-  (sort . nub . map fromPositive) `fmap` listOfInt
02:42:25 <isomorphic> c has the type [Int]?
02:42:52 <benmachine> that's weird?
02:43:01 <shachaf> Assuming that that expression has the type m Int for some Monad m (e.g. Gen).
02:43:13 <isomorphic> benmachine: I'm still getting a feel for this monad business :P
02:43:15 <benmachine> actually I suspect it has type Num n => n
02:43:23 <benmachine> oh
02:43:34 <benmachine> except listOfInt is probably Gen (Positive Int) or something
02:43:43 <shachaf> You can equivalently say l <- listOfInt; let c = (sort . nub . map fromPositive) l
02:44:14 <augur> is there a function that applies a function to something repeatedly until nothing changes?
02:44:50 <shachaf> fix. :-)
02:44:54 <benmachine> hah
02:44:54 <isomorphic> augur: I think the concept is that of a fixed point
02:44:58 <benmachine> technically, yes
02:45:01 <augur> does fix do that? hmm
02:45:07 <benmachine> but fix (+0) won't do what you want
02:45:32 <shachaf> augur: Well, it'll compute a fixed point, at least. :-)
02:45:37 <sipa> fix will apply a function to something repeated until it returns its own input
02:45:37 <benmachine> yes
02:45:40 <hpaste> cripple pasted “roleofp” at http://hpaste.org/47928
02:45:45 <sipa> that's not the same as until nothing changes
02:45:52 <VitamnP> Could someone please explain to me the role of p in this function? http://hpaste.org/47928
02:45:54 <benmachine> sipa: isn't it?
02:46:13 <sipa> benmachine: well, "the same" defined in terms of Eq :)
02:46:32 <augur> wheres the source for fix?
02:46:35 <augur> @src fix
02:46:36 <shachaf> @src fix
02:46:36 <lambdabot> fix f = let x = f x in x
02:46:36 <lambdabot> fix f = let x = f x in x
02:46:44 <shachaf> fix f = f (fix f)
02:46:45 <benmachine> sipa: well, if fix gives an answer, then the Eq instance *should* say they're equal
02:46:50 <benmachine> if it's a sensible Eq instance
02:46:50 <augur> yeah thats not what i want
02:46:51 <sipa> benmachine: of course
02:47:09 <augur> i want something more like
02:47:11 <benmachine> augur: I don't think there's a standard function that does what you want
02:47:11 <sipa> benmachine: that's just (a == a) is True
02:47:36 <augur> fix' f x = let x' = f x in (if x' == f x then x' else fix' f x')
02:47:46 <shachaf> benmachine: In most cases the Eq instance will say nothing, since fix f will be _|_. :-)
02:48:36 <isomorphic> hrmm - so I have my 'x' - which is just a Gen (Positive Int)
02:48:38 <benmachine> :t let xs = iterate ((+1) . sqrt) 0 in fst . head . dropWhile (uncurry (==)) . zipWith xs $ tail xs
02:48:39 <lambdabot>     Couldn't match expected type `a -> b -> c'
02:48:39 <lambdabot>            against inferred type `[a1]'
02:48:39 <lambdabot>     In the first argument of `zipWith', namely `xs'
02:48:45 <benmachine> :t let xs = iterate ((+1) . sqrt) 0 in fst . head . dropWhile (uncurry (==)) . zip xs $ tail xs
02:48:46 <lambdabot> forall a. (Floating a) => a
02:48:49 <benmachine> let xs = iterate ((+1) . sqrt) 0 in fst . head . dropWhile (uncurry (==)) . zip xs $ tail xs
02:48:53 <benmachine> er
02:48:54 <benmachine> > let xs = iterate ((+1) . sqrt) 0 in fst . head . dropWhile (uncurry (==)) . zip xs $ tail xs
02:48:56 <isomorphic> and I have a c  <-  (sort . nub . map fromPositive) `fmap` listOfInt
02:48:56 <lambdabot>   0.0
02:48:59 <benmachine> oh
02:49:02 <benmachine> hrm.
02:49:30 <isomorphic> should I really need to take the result out of the monad to apply filter?
02:49:48 <isomorphic> ie: let z = filter (not . (x ==)) `fmap` c
02:49:54 <shachaf> Grr. "out of the monad".
02:50:09 <shachaf> There's no such thing.
02:50:10 <benmachine> > let xs = iterate ((+1) . sqrt) 0 in zip xs $ tail xs
02:50:11 <lambdabot>   [(0.0,1.0),(1.0,2.0),(2.0,2.414213562373095),(2.414213562373095,2.553773974...
02:50:14 <isomorphic> shachaf: What's happening in fact?
02:50:20 <benmachine> > let xs = iterate ((+1) . sqrt) 0 in fst . head . dropWhile (uncurry (/=)) . zip xs $ tail xs
02:50:21 <lambdabot>   2.618033988749895
02:50:29 <benmachine> hmph, close enough :P
02:52:36 <ski> isomorphic : `x' is a `Gen'-action, that every time you run it, will generate an `Int'
02:53:01 <ski> isomorphic : you run it by saying e.g. `n <- x', so `n' becomes the result `Int' from that run of `x'
02:53:15 <ski> the next time you run `x', you'll probably get a different integer
02:53:50 <isomorphic> ski: I think I get where you're going - like IO
02:53:58 <ski> isomorphic : if you say `(x ==)' you're trying to compare the `Gen'-action, the "recipe for randomly generating an `Int'", with something
02:54:07 <ski> yes, `Gen' is just another monad
02:54:36 <ski> so i think you really want `(n ==)' (or rather `(n /=)', so you can skip the `not'), there
02:55:32 <isomorphic> Ah- now, maybe I see
02:55:48 <isomorphic> I'd like to do my filtering based on some generated value
02:55:59 <isomorphic> and my list is based upon some generated value
02:56:17 <isomorphic> does this mean I must have evaluated the action before I can apply filter?
02:56:34 <ski> yes
02:56:45 <ski> though s/evaluated/executed/
02:57:01 <shachaf> Executed, not evaluated.
02:57:15 <ski> you execute/run an action by saying e.g. `n <- x'
02:57:38 <shachaf> You evaluate values. You execute xecutes.
02:58:19 <ski>   ((filter `flip` c) . (/=)) `fmap` x  -- should combine `x' and the `filter'
02:58:24 <ski> but as i said, it's ugly
02:58:34 <ski> better to say `n <- x'
02:58:37 <augur> er, obviously i typoed earlier
02:58:44 <ski> (also i'd rename `x' to something else)
02:58:56 <augur> steadyState f x = let x' = f x in (if x' == x then x' else steadyState f x')
02:59:05 <augur> which works. :T
02:59:17 <ski> the brackets are not needed
02:59:21 <ski> i'd use `where'
02:59:28 <augur> i know but its more readable that way
02:59:33 <augur> for irc i mean
02:59:41 <augur> for me anyway
03:00:21 <ski> i might call it `fixedPointIterate', instead
03:00:43 <isomorphic> ski: Ah, yes, gradually coming together now :P
03:01:09 <isomorphic> So, to be clear, it wouldn't make sense to fmap filter into the Gen monad?
03:02:26 <ski>   fixedPointIterate f a0
03:02:33 <ski>     | a0 == a1   = a0
03:02:43 <ski>     | otherwise = fixedPointIterate f a1
03:02:48 <ski>       where
03:02:52 <ski>       a1 = f a0
03:03:14 <ski> isomorphic : you could do it, i did it above
03:03:21 <ski> it looked ugly, though
03:04:23 * ski ponders how to do fixed-point iterations with diffs ..
03:04:49 <isomorphic> ski:  (uncurry (filter . (not .: (==))) . second (sort . nub . map fromPositive)) `fmap` liftM2 (,) x listOfInt ?
03:04:50 <augur> ski: k :P
03:06:30 <isomorphic> @type second
03:06:31 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
03:06:39 <isomorphic> @type uncurry
03:06:40 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
03:06:46 <dmwit> fixedPointIterate f a = head [x | (x, x') <- ap zip tail (iterate f a), x == x']
03:07:00 <augur> ski: why the preference for wheres and guards?
03:07:04 <ski> isomorphic : oh, i had forgotten about that .. i suppose that's not *as* ugly, though
03:07:18 <dmwit> > let fixedPointIterate f a = head [x | (x, x') <- ap zip tail (iterate f a), x == x'] in fixedPointIterate sin 1
03:07:21 <lambdabot>   mueval-core: Time limit exceeded
03:07:29 <dmwit> > let fixedPointIterate f a = head [x | (x, x') <- ap zip tail (iterate f a), x == x'] in fixedPointIterate sin 0.000000001
03:07:30 <isomorphic> ski: My problem is I can't read it :/
03:07:30 <lambdabot>   1.0e-9
03:07:38 <isomorphic> (yet)
03:07:41 <ski> augur : for some reason i think `if'-`then'-`else's looks slightly ugly
03:07:47 <dmwit> > sin 1e-9
03:07:48 <lambdabot>   1.0e-9
03:07:48 <augur> ah ok
03:07:52 <ski> augur : generally i think `where' is more readable than `let'-`in', though
03:08:53 <ski> `foo = fooExpr where bar = barExpr' instead of the mixed-order `foo = let bar = barExpr in fooExor'
03:09:11 <augur> well, i have a phonology done for danka's and my project for hac phi :T
03:09:29 <shachaf> Hmph, NoImplicitPrelude still uses GHC.Bool.Bool and not your own Bool/True/False. :-(
03:09:34 <ski> isomorphic : if you write the code in a way that is more readable to you, that's probably better (and it would probably be more readable to me, as well)
03:09:48 <shachaf> Blatant favoritism.
03:10:08 <dmwit> shachaf: There's rebindable syntax extensions if you want to muck about with how if/then/else works.
03:10:10 * ski idly wonders what `danka' is
03:10:47 <shachaf> dmwi: I meant for guards, not if/then/else.
03:11:56 <dmwit> hmph
03:12:01 * shachaf supposes dmwi is the analogue to danka.
03:12:04 * ski wonders whether Core has guards in `case'
03:12:10 <isomorphic> What does it mean when a type signature has just a return type, and that return type is polymorphic
03:12:26 <shachaf> ski: Does it have guards at all?
03:12:39 <shachaf> isomorphic: That means it's a value.
03:12:41 <ski> if it has guards, it would be in `case', i should think
03:12:53 <dmwit> isomorphic: It means it's a polymorphic expression.
03:12:56 <isomorphic> ie: arbitraryBoundedIntegral :: (Integral a, Bounded a) => Gen a   <- how is the type of a inferred?
03:13:11 <dmwit> isomorphic: By looking at the source of arbitraryBoundedIntegral.
03:13:18 <shachaf> @ty 5 -- Simpler example.
03:13:19 <ski> isomorphic : the uses of `arbitraryBoundedIntegral' determine which `a' to use
03:13:19 <lambdabot> forall t. (Num t) => t
03:13:47 <isomorphic> ah - so it's kind of just overloaded
03:13:54 <dmwit> Ah, I see I misunderstood the question, so you should prefer ski's answer to mine, probably.
03:14:06 <ski> > read "123" :: Int
03:14:07 <lambdabot>   123
03:14:08 <ski> > read "123" :: Bool
03:14:09 <lambdabot>   *Exception: Prelude.read: no parse
03:14:11 <ski> @type read
03:14:11 <lambdabot> forall a. (Read a) => String -> a
03:14:19 <dmwit> :t read "123"
03:14:20 <lambdabot> forall a. (Read a) => a
03:14:31 <dmwit> :t maxBound - 1
03:14:32 <lambdabot> forall a. (Bounded a, Num a) => a
03:14:47 <isomorphic> Ah - so the context in which the expression occurs determines its type
03:15:13 <dmwit> Well... all expressions have a most general type.
03:15:39 <dmwit> ...which is independent of its context.
03:15:51 <dmwit> But yes, context will determine how a polymorphic type becomes monomorphic.
03:33:27 <Romney12> Like individual mandate Obamacare, an agressive foreign policy, and the rest of Barack Obama's policies?  Are you nervous around Black people but still like Obama's policies?  Then vote for Mitt Romney, the White Barack Obama!
03:40:35 <isomorphic> Okay - so now I have finished generating random things, and I'd like to do a list comprehension
03:41:22 <isomorphic> so, [(+) x y | x <- b, y <- b, x /= y] where b = testClaims :: Gen [Int]
03:42:25 <isomorphic> do I need to fmap / liftM the list comprehension into Gen [Int]?
03:43:23 <isomorphic> I've just tried a (redundant) do zz <- testClaims; return zz to get testClaims executed
03:43:27 <isomorphic> ... not the answer :/
03:43:29 <aristid> isomorphic: to get a list of [a] into m [a], use return. to get a list of [m a] into m [a], use sequence
03:44:00 <aristid> where m is a type that is an instance of Monad
03:44:40 <aristid> @src sequence
03:44:40 <lambdabot> sequence []     = return []
03:44:40 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
03:44:41 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
03:45:27 <isomorphic> aristid: Hrmm - I have a list of random numbers which is m [a]
03:46:35 <isomorphic> or, if you like Gen [Int]
03:47:05 <isomorphic> wouldn't I just need to do, do x :: Gen [Int] ?
03:48:39 <isomorphic> @type sequence
03:48:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
03:49:16 <isomorphic> see, I already have m [a]
03:49:43 <isomorphic> I think I just want [a] back
03:49:57 <isomorphic> ? :/
03:51:22 <luite> isomorphic: you can only get [a] back if you have some "run" function for the monad
03:52:28 <benmachine> isomorphic: write a function that takes an [a] argument and does what you want, then how you put it in the monad depends on what type it is
03:52:43 <benmachine> isomorphic: if you make a function [a] -> m b, then you can use >>= to apply it to an m [a]
03:53:11 <benmachine> isomorphic: and get an m b, alternatively, if you have [a] -> b for some other b, you can still get an m b by using fmap or liftM
03:53:25 <benmachine> isomorphic: you can't in general get just a b, though
03:53:51 <benmachine> isomorphic: does that make sense?
03:54:19 <luite> isomorphic: hmm, I can't find the one for Gen, but you do what benmachine says, you combine monadic computations into a large one with an "m a" result, and then you run that. for a random monad, that typically means that you supply an initial seed
03:54:27 <isomorphic> benmachine: That's very helpful - am having a go :)
03:54:52 <luite> runGen :: Seed -> Gen a -> a
03:54:57 <luite> something like that
03:55:02 <aristid> isomorphic: Gen is not from QuickCheck, is it?
03:55:05 <isomorphic> luite: Yup, trying to combine them now
03:55:08 <benmachine> it is
03:55:13 <isomorphic> Ah - gotcha
03:55:23 <isomorphic> aristid: Yes. it is
03:55:30 <aristid> no run function for that one.
03:55:31 <benmachine> runGen doesn't exist exactly like that, but some similar things do that I forget the name of
03:55:32 <luite> isomorphic: I don't know if that's the actual name
03:55:39 <luite> isomorphic: bit you might look at MonadRandom instead
03:55:42 <benmachine> sample' for example
03:55:47 <luite> that does ahve explicit run functions
03:55:49 <benmachine> sample' :: Gen a -> IO a
03:55:52 <benmachine> er
03:55:54 <benmachine> sample' :: Gen a -> IO [a]
03:56:03 <luite> oh ok, that's not good :(
03:56:07 <aristid> you probably don't WANT to get the a out of Gen a, at least not under normal circumstances
03:56:11 <benmachine> it's useful for testing
03:56:17 <benmachine> aristid: right
03:56:19 <luite> yeah but not for learning monads :)
03:56:24 <benmachine> hah
03:56:26 <benmachine> fair enough
03:56:41 <isomorphic> looks like i'm putting my list comprehension in the monad
03:56:50 <benmachine> mm
03:56:59 <benmachine> I think you're mostly supposed to use Gen via its Testable instance
03:57:05 <benmachine> and quickCheck
04:04:23 <albertid> Hi, whats the {a = 1, b = 2} syntax?
04:04:39 <benmachine> albertid: it's called record syntax but I have to run off before explaining it
04:04:51 <albertid> thx, I just needed a keyword to google :)
04:18:18 <sanjoyd> I have a regular sum-of-products type like "data Foo = Bar Int Char Bool"; and now I have a bunch of functions which take a Foo, change on field and return a new Foo. The problem is that I end up writing the code as (change Bar x y z = Bar (x+1) y z).
04:18:29 <sanjoyd> This gets problematic as I change Foo's representation.
04:18:57 <sanjoyd> Is there some elegant way to say: "this new Foo is the same as this old Foo, except at this one place?"
04:19:55 <olsner> sanjoyd: sounds like you're looking for records
04:24:14 <opqdonut> sanjoyd: record syntax. "data Foo = Bar {intField :: Int, charField :: Char, boolField :: Bool}; change bar = bar {intField = intField bar + 1}"
04:25:01 <sanjoyd> opqdonut: okay, I did not know about the change keyword.
04:25:03 <sanjoyd> opqdonut: thanks.
04:25:25 <sanjoyd> s/change/that I could do bar {x = intF y + 1}
04:25:29 <opqdonut> yeah
04:25:35 <opqdonut> that's called a record update
04:34:34 <Koterpillar> [newbie] doubleTake1 = (null [True]) && (null ['a']) is possible, how to make doubleTake2 f = (f [True]) && (f ['a']) ?
04:35:24 <sanjoyd> I think buy doubleTake2 :: (forall a.[a]-> Bool)->Whatever
04:35:28 <sanjoyd> I'm not sure though.
04:35:33 <sanjoyd> s/buy/by/
04:35:54 <mauke> you need Rank2Types
04:38:56 <Koterpillar> Okay, I thought there was something wrong with it. Thanks sanjoyd, mauke!
05:12:53 <magicman> Yeah, that is a classic Rank[2N]Types example.
05:13:44 <magicman> </late>
05:22:25 <yhosok> which best framework for web app now?. i think yesod is that.
05:23:38 <Axman6> which ever one you like best
05:24:12 <VitamnP> implement fetish porn cam site in haskell
06:47:23 <ddarius> ndm is teaching Haskellers C#.
06:48:38 * hackagebot download 0.3.2 - High-level file download based on URLs  http://hackage.haskell.org/package/download-0.3.2 (DonaldStewart)
06:48:59 <Axman6> ddarius: I'd quite like to see that
06:54:36 <ivan_> Hello!
07:01:15 <ivan_> Whats a good place to learn Haskell from?
07:01:29 <ddarius> @google Whats a good place to learn Haskell from?
07:01:30 <iskren> Hello. I'm having problems building a project. It builds fine on linux 32bit (ghc 6.12.3) but it fails on macosx 64bit (ghc 7.0.2). http://fpaste.org/F6z3 <-- build log. The project can be found here http://iskren.info:8112/file/eac426cb7305
07:01:31 <lambdabot> http://stackoverflow.com/questions/1012573/how-to-learn-haskell
07:01:31 <lambdabot> Title: functional programming - How to learn Haskell - Stack Overflow
07:01:39 * hackagebot hackage-sparks 0.5.1 - Generate sparkline graphs of hackage statistics  http://hackage.haskell.org/package/hackage-sparks-0.5.1 (DonaldStewart)
07:02:03 <geheimdienst> ivan_: an often-recommended starting place is the book "learn you a haskell". it's on the web for free
07:02:06 <geheimdienst> @where lyah
07:02:06 <lambdabot> http://www.learnyouahaskell.com/
07:04:02 <ClaudiusMaximus> preflex: zdec ___stginit_haskell98zm1zi1zi0zi1_Char_
07:04:02 <preflex>  ___stginit_haskell98-1.1.0.1_Char_
07:05:16 <hpc> is that an un-mangler?
07:05:35 <ClaudiusMaximus> iskren: not sure if this would help (afaik ghc --make should find the right things), but maybe ghc --make -package haskell98 ...  might do the trick?
07:05:35 <ivan_> Hay iskren are you from FMI?
07:05:59 <DasIch> is there a parser for command-line options that supports commands?
07:06:57 <DasIch> e.g. `add` in `git add`
07:07:05 <aa_> DasIch: what are you writing?
07:07:12 <aa_> DasIch: (hi)
07:07:40 <DasIch> aa_: my first real haskell app ;)
07:07:55 <aa_> DasIch: cool, me too!
07:08:01 <aa_> DasIch: but what is it?
07:08:28 <iskren> ivan_, yes :)
07:08:29 <DasIch> aa_: i want something to manage my music collection
07:08:42 <iskren> ClaudiusMaximus, is this package the standart one?
07:08:51 <ivan_> Me too!
07:09:08 <iskren> I was just reading http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/separate-compilation.html << the part with the makefile
07:09:25 <DasIch> aa_: not sure i'll manage to come up with something usable but it's worth a try
07:11:10 <ivan_> iskern, I am starting to learn haskell and was wondering if "Learn you a haskell..." is a good place to start?
07:11:38 <aa_> ivan_: I found it nice
07:11:48 <DasIch> ivan_: i think it is, although i'm a beginner
07:11:58 <aa_> I mean the tone is very informal, but apart from that it makes sense and the author is passionate
07:12:24 <ivan_> I have functional programming experience in Lisp
07:13:29 <iskren> ivan_, I've read some parts of "Real world haskell" and also attended a course in the university. But generally speaking you should just start writing code :)
07:13:35 <nus> DasIch, hackage.haskell.org is your frend, there're HCL, cmdlib, cmdargs, console-program packages.
07:13:57 <ivan_> I want to learn enougth too get to juicy stuff like Monads.
07:14:17 <nus> ivan, juice is elsewhere
07:14:27 <iskren> ivan_, monads are not that important in my oppinion -- I mean you don't have to know them to write code :)
07:14:38 <nus> erhhm, that wass for ivan_
07:14:40 <DasIch> real world haskell appears to be more of a reference than a tutorial
07:14:48 <DasIch> nus: thanks
07:15:17 <iskren> DasIch, hm, I wouldn't say that. The first few chapters explain the stuff pretty well (that is what I have read :))
07:15:35 <ClaudiusMaximus> iskren: another idea: maybe modify parser.y to import Data.Char instead of Char, Data.List instead of List
07:15:41 <ivan_> iskren, I will follow your advice :)
07:15:55 <iskren> ClaudiusMaximus, thanks! I'll try that.
07:17:06 <ivan_> iskren, I think we know each other from NOI :)
07:17:39 <iskren> ivan_, this is possible
07:18:15 <iskren> ClaudiusMaximus, actually this is more reasonable, because all other files import Data.List, and the parser code was copy pasted (parts of it) from somewhere.
07:20:01 <melker> hey you guys
07:20:21 <melker> Ive seen that haskell supports so called Lazy Evaluation
07:20:36 <melker> is that a new thing or has it been around for some time
07:20:51 <DasIch> melker: that is an essential part of the language
07:20:59 <melker> I looked it up at wiki and only found two languages that had support for it and haskell was one
07:21:05 <melker> DasIch: cool
07:21:21 <benmachine> melker: well, haskell has been around for a good while now
07:21:30 <Nimatek> It's a concept that arose in the 70's.
07:21:38 <benmachine> it was first developed about 20 years ago
07:21:41 <melker> I meant more if it is used industrially
07:21:50 <benmachine> haskell is used industrially to some extent
07:21:57 <benmachine> and some other languages have lazy ideas in them
07:22:04 <benmachine> like python's iterators
07:22:10 <benmachine> I think D has a lazy keyword
07:22:19 <Arafangion> C#'s linq.
07:22:24 <Twey> I think all languages have some method of doing things lazily
07:22:32 <melker> I was wondering if this lazy evaluation thing is good for simulation of differential equations
07:22:33 <Twey> Purely-strict languages are not very useful
07:23:10 <melker> there you sometimes have intermediate evaluations that you arent really interested in, but you the values to compute the necessary variables
07:23:22 <ddarius> Lazy evaluation goes back to at least the 1930s.
07:24:15 <melker> you need the values even, sry
07:24:59 * Twey defers to benmachine, the maths student.
07:25:04 <Twey> :þ
07:25:17 <benmachine> wibble
07:25:26 <benmachine> erm, I don't see how lazy evaluation is relevant to DEs
07:25:34 <xplat> even if/then/else is a limited form of lazy evaluation
07:25:56 <benmachine> well, I guess it would be useful
07:25:59 <ClaudiusMaximus> melker: lazy evaluation does help for some things (like getting a potentially infinite list of closer approximations, from which you can pick the one that's close enough)
07:25:59 <Arafangion> xplat: How so?
07:26:17 <benmachine> but you have to program mathematical calculations quite intelligently to make use of laziness
07:26:46 <xplat> the 'then' and 'else' parts are not evaluated before the if statement receives and checks its condition, and one will not be evaluated at all
07:27:15 <xplat> a lot of languages only allow lazy evaluation for built-in constructs like that
07:27:18 <Arafangion> xplat: That's merely sequential evaluation.
07:27:44 <Arafangion> xplat: In a sense, you're evaluating all branches at once, and discarding teh branches you don't use.
07:27:51 <nus> melker, you simulate a phenomenon, modelled by differential equations, haskell could be helpful in that.
07:28:16 <xplat> Arafangion: in the same sense, you are doing the same thing in lazy evaluation
07:28:44 <Arafangion> xplat: To me, the main point of lazy evaluation is that evaluation is deferred until it's needed.
07:28:47 <melker> xplat I read about that too. but I was more wondering if evaluation of nested functions could be faster. by not actually computing the values for each part.. but Im not sure if this is what lazy evaluation does..
07:28:58 <Arafangion> xplat: An if/then/else construct in most languages is not deferred. It's immediate.
07:29:27 <aa_> I have a do which returns IO [String], is there a way to get the [String] from calling with a normal function?
07:29:41 <benmachine> the thing about lazy evaluation is that in principle
07:29:47 <xplat> Arafangion: the main point of lazy evaluation is that evaluation of an application can sometimes succeed even if the evaluation of its argument would fail
07:29:51 <benmachine> anything that you can do *with* lazy evaluation you can also do without
07:30:04 <benmachine> the difference is that lazy evaluation is much more convenient and allows for more composable and modular code
07:30:06 <melker> but is it faster ben?
07:30:20 <Arafangion> xplat: So you mean that short-circuit evaluation could be considered lazy evaluation?
07:30:33 <benmachine> melker: an algorithm tuned for a particular purpose will only calculate what is necessary: in this case lazy evaluation is irrelevant
07:30:46 <benmachine> melker: the advantage of lazy evluation is not performance
07:31:02 <ezyang> Lazy evaluation can give performance benefits.
07:31:08 <xplat> benmachine: only true to an extent.  you can get rid of 'if' from strict evaluation any more than you can get rid of 'case' from lazy evaluation
07:31:19 <aa_> hmm, that's weird, I don't even know what IO [String] is
07:31:23 <xplat> *you can't
07:31:25 <aa_> is that a single term?
07:31:27 <benmachine> melker: it's that you can do things like write a function that generates a sequence, and not encode the termination condition in that function
07:31:48 <benmachine> which makes that function simpler, and means you can use it in more places
07:31:59 <benmachine> because each use can take only what it needs, and no unnecessary work will be done
07:32:11 <Twey> aa_: IO [String] is a recipe for an impure computation, which, when executed, will yield a string
07:32:13 <melker> ah I think I get it. I was hoping that it could be fast for evalution of say f(x)=x+3x+1.5+sin(3x+1-5+x^2)
07:32:17 <Twey> Er, a [String] even.
07:32:23 <aa_> Twey: right
07:32:28 <Twey> You can't ‘extract’ the value because it doesn't exist yet
07:32:39 <aa_> Twey: but to get that string I have to bind it in another do with <-, for example?
07:32:53 <Twey> What you *can* do is push another instruction onto the recipe to say ‘… and then do this with it’
07:32:54 <benmachine> melker: not especially, lazy evluation doesn't help much there
07:33:07 <Twey> do-syntax is just sugar for that
07:33:07 <xplat> melker: only if you extract the common subexpression, but strict evaluation works just as well in that case
07:33:43 <aa_> Twey: so in genral once I am in impure land, do I have to stay there forever, calling pure from impure?
07:33:52 <benmachine> aa_: the idea of binding with <- is that you give a name to the result of running the recipe, and then you can do something with that name
07:33:53 <Twey> aa_: Yes
07:34:06 <aa_> right, ok thanks makes sense
07:34:06 <xplat> Arafangion: yes, short-circuit operators like && and || can be considered lazy evaluation and are implemented that way in some languages
07:34:13 <Twey> aa_: You can't escape IO (and you wouldn't really want to)
07:34:20 <Twey> But you can call pure functions within IO
07:34:22 <aa_> ok cool
07:34:26 <benmachine> aa_: it's not as much of a restriction as it sounds
07:34:27 <melker> ok thank guys
07:34:27 <Twey> And they will then be pure
07:34:39 <aa_> it's cool, it's just an entry point really
07:34:41 <xplat> (haskell has them that way, and scala implements them with call-by-name, which is just a possibly-less-efficient version of lazy evaluation)
07:34:43 <Twey> Right
07:34:54 <benmachine> aa_: mostly you make pure functions the major component of your program, and then a small IO thing that gets some input and applies it
07:34:57 <aa_> I was just wondering if having this impure entry poing is correct
07:35:21 <benmachine> aa_: so most programming you do is in a pure context, even though you can only use that code by getting IO to call it
07:35:23 <Arafangion> xplat: So your argument is based on an implementation of such rules, and not infact based on the actual use of the if/then/else expression of other languages?
07:35:39 <aa_> in soviet haskell, IO "do" you :P
07:36:08 <aa_> ok, well, excellent jokes aside ;) thanks, it makes sense
07:36:10 <Arafangion> aa_: `do`, you mean?
07:36:20 <xplat> Arafangion: no, but the fact that these operators can be implemented using built-in non-strict forms of evaluation is illustrative of the fact that they are doing non-strict evaluation
07:37:48 <Arafangion> xplat: I'm going to have to learn more haskell and other theory before I can continue this conversation. :(
07:38:50 <Arafangion> xplat: However, an if/then/else, basically evaluates the conditional, tests the result against zero and jumps. Execution then continues from wherever the program counter is at.
07:39:00 <Arafangion> xplat: At least, in one language I was working in.
07:40:08 <melker> IO you $
07:40:29 <xplat> Arafangion: Haskell's lazy evaluation is also implemented in a way that involves modifying the program counter ...
07:41:12 <Arafangion> xplat: That in effect produces a jmp.
07:41:30 <xplat> so i don't see how these viewpoints contradict each other in any way
07:41:59 <xplat> it just comes down to which will give you more insight in a given situation
07:42:18 <Arafangion> xplat: If you do an if/then/else, then teh result will *always* be evaluated at that moment.
07:42:52 <Arafangion> xplat: However, if you do lazy evaluation, a result is only evaluated "when it is needed", which could potentially be immediate, or in 10 minutes, or never.
07:43:21 <xplat> Arafangion: but unlike a cond() function written in those languages, it will not evaluate the condition, the then-part, and the else-part, and then decide which of the latter results to return.  one of the parts will be evaluated after the condition, the other not at all.
07:44:10 <Arafangion> xplat: Yes, it short-circuits the evalutation.
07:44:39 <Arafangion> xplat: It can be painful to realise that operators in some languages don't do short circuit evaluation - eg, boolean operators in BASIC.
07:45:49 <xplat> you could also say it's not the if statement itself that causes the then-part to be evaluated, it's the surrounding context.  (almost) all the other evaluation in the language is strict, so you end up in the same situation you would in haskell if you did let it = if blah then whee else ugh in it `seq` otherstuff
07:47:10 <Arafangion> xplat: if/then/else can be reduced to just JMPZ, in 8051 assembly.
07:47:28 <Arafangion> "Jump if the accumulator is zero".
07:47:50 <xplat> Arafangion: how good the optimizer is is irrelevant :)
07:48:39 <luite> especially if it's for a target that no haskell compiler supports ;)
07:48:56 <aa_> DasIch: what are you using for options in the end?
07:49:07 <Arafangion> xplat: Ah, so you *are* arguing that it could be implemented as lazy evaluation, and not that the construct in other languages do it as such?
07:51:00 <xplat> Arafangion: i'm arguing that it is semantically a form of lazy (or more precisely, non-strict) evaluation, and whether languages choose to implement it in terms of general lazy evaluation or using special tricks that only work for the few lazy functions they supply is their own business
07:51:16 <DasIch> aa_: i think i go with cmdargs
07:52:00 <Arafangion> xplat: It could only be regarded as having lazy semantics if said langauge performs the evaluation lazily.
07:52:48 <Arafangion> xplat: Conceptually, you could say that it's lazy, but I think it's incorrect to say that it's *semantically* lazy.
07:53:14 <xplat> Arafangion: even GHC will compile lazy evaluation to  work eagerly if the strictness analyzer tells it the result will always get forced immediately.
07:54:18 <Arafangion> xplat: Interesting, however that doesn't suggest that GHC is violating semantics to do that, because (as you say), it has analysed the code and determined that evaluating the result immediately doesn't change the semantics, so therefore, it can force it for performance reasons.
07:55:32 <xplat> Arafangion: that's the same thing a C compiler does, only because C is so ubiquitously strict everywhere but if, &&, and ||, the strictness analysis is trivial and doesn't need to be done explicitly
07:56:05 <xplat> (oh, and while)
07:56:09 <aa_> DasIch: ok cool
07:56:42 <xplat> (and for, but for is just sugar for while, and ?:, but that's just an inline if)
07:56:47 <Arafangion> xplat: And while? YOu mean, while loops?  Yes, we are really arguing if all conditionals are lazy, even when evaluated immediately.
07:59:47 <chfo> i'm using parsec and want to check for a hex value of 0x255. how can i do this? currently i am doing `anyChar`
08:00:01 <Arafangion> xplat: Say, suppose you have an: if true() then foo = long_operation() else foo = alternative();; something(); processFoo(foo);
08:00:20 <Arafangion> xplat: In C, that is always executed in turn, only 'alternative()' is skipped.
08:00:36 <xplat> Arafangion: in C there are so few lazy constructs that 'short circuiting' evaluation is a legitimate and complete technique for implementing laziness and doesn't cause any problems for the semantics of lazy constructs
08:00:56 <xplat> for example, sequencing (;) is strict in C
08:01:35 <Arafangion> xplat: It's completely linear, and every operation is done at that moment.  If it semantically had lazy evaluation, then 'something()' could occur before 'long_operation()'.
08:01:47 <ddarius> Arafangion: There is no equivalent to that in Haskell.  The only reason you'd evaluate an if-then-else at all is if you wanted the result.
08:02:10 <xplat> no, the ; ensures that something() must occur before long_operation()
08:02:14 <Arafangion> ddarius: xplat is explicitly saying that the if-then-else construct in other languages such as C could be understood as lazy.
08:02:30 <ddarius> Arafangion: Yes, the -if-then-else- construct, not the entire language.
08:02:44 <xplat> er, that long_operation() must occur before something()
08:02:54 <ddarius> Arafangion: As he said, ; is what's forcing the if-then-else so to speak.
08:03:49 <ddarius> Arafangion: If you did: const (if true then f x else g x) 3 in Haskell, then the entire if-then-else wouldn't be executed, but that says nothing about the behavior of if-then-else, rather it says something about const or function application.
08:04:14 <ddarius> Er switch 3 and the if-then-else.
08:04:39 <Arafangion> ddarius: In that case, the semantics are quite different, yes?
08:05:10 <ddarius> Arafangion: Different from what?
08:05:52 <Arafangion> ddarius: Than such a construct in C, which really just lets you skip branches.
08:06:02 <Arafangion> ddarius: Doesn't defer them or anything.
08:06:25 <ddarius> Arafangion: Neither does Haskell's if-then-else.
08:07:29 <Arafangion> ddarius: Having yet to learn Haskell, I assume that haskell's if-then-else statement is only evaluated if the result is known, and then, only the respective branch will contain the value?
08:08:07 <Nimatek> "cond ? (a,b) = if cond then a else b" should be added to prelude tbh.
08:08:54 <Draconx> Nimatek, nothing should be added to the prelude tbh.
08:09:13 <Draconx> it's got too much stuff already.
08:09:31 <Nimatek> And that's bad?
08:09:32 <ddarius> Arafangion: Branches don't "contain" values.  Haskell's if-then-else just evaluates the condition and then returns either the first argument or the second.
08:09:33 <benmachine> some things should be taken out, some might be nice to add
08:09:56 <benmachine> Nimatek: it's kind of annoying sometimes
08:09:57 <Draconx> plus, adding anything to the prelude potentially breaks any existing code.
08:10:09 <Arafangion> ddarius: Perhaps a poor choice of words on my part, your clarification matches what I thought haskell would do.
08:10:40 <Arafangion> ddarius: On the 8051 assembly, however, you pretty much just have structured GOTO.
08:10:48 <Arafangion> On C, I mean.
08:11:21 <ddarius> Arafangion: You can't tell whether it is a "goto" or not from within C.
08:11:33 <Arafangion> ddarius: It's always a goto in C!
08:11:50 <benmachine> Arafangion: what if the compiler makes it not so?
08:12:00 <benmachine> can't you do branch predication or something
08:12:26 <Arafangion> benmachine: The CPU typically does branch prediction, yes, and the compilers can influence that, but it's still always a goto.
08:12:35 <benmachine> Arafangion: predication /= prediction :)
08:12:38 <benmachine> http://en.wikipedia.org/wiki/Branch_predication
08:12:46 <ddarius> Arafangion: Write me a C program whose standard defined behavior would differ if if was implemented as a goto versus not being implemented as a goto.
08:12:46 <xkb> Are there any recommended tutorials on QuickCheck? Especially on creating instances of Arbitrary for Records and other "complex" datatypes?
08:12:48 <xplat> you can, or the compiler could do a different strength reduction
08:12:57 <benmachine> (I made the same mistake and I imagine everyone does, it's an annoying name)
08:13:32 <Arafangion> ddarius: Somehow, I think I would be the last person to be able to write such a program.
08:13:54 <ddarius> Arafangion: Find me one then.
08:13:54 <xplat> Arafangion: i rather think you would be the first
08:14:10 <xplat> (unless you exploit undefined behaviour)
08:14:49 <benmachine> xplat: in fairness, quite a lot of production C exploits undefined behaviour :P
08:15:07 <ddarius> (Incidentally, in Scheme, call/cc can differentiate between two common implementations of letrec.)
08:15:49 <xplat> benmachine: true, but you'd have to get pretty hardcore with it to meet this challenge.  inspecting your own code segment or messing with CPU performance counters ...
08:16:05 <benmachine> mm, that I won't deny
08:16:07 <Arafangion> And on an 8051? Ha.
08:16:25 <Arafangion> All branches are done with goto. End of story.
08:16:25 <benmachine> but doesn't branch predic*a*tion demonstrate that it isn't always a goto anyway
08:16:33 <benmachine> Arafangion: did you read my wiki article
08:16:35 <Arafangion> There is no branch prediction on an 8051.
08:16:40 <benmachine> well it's not mine, the one I linked to
08:16:43 <Arafangion> (Or predication, afaik)
08:16:53 <xplat> branch predic*a*tion produces code that doesn't branch
08:17:20 <Arafangion> Actually, you could do predication, but it'd be pointless on  8051.
08:17:51 <xplat> a C compiler could optimize if (a) then b |= a to just b |= a on a 8051, and that's branchless
08:18:37 <benmachine> why are we suddenly so interested in 8051s
08:18:38 <ddarius> Arafangion: Looking at the instruction set, I can see several ways of implementing if-then-else without branches.
08:19:04 <Arafangion> ddarius: Only if you waste memory.
08:19:13 <benmachine> Arafangion: sometimes you waste memory
08:19:35 <ddarius> Arafangion: Not necessarily, and even so, so?
08:19:40 <monochrom> every irc client wastes memory
08:20:03 <Arafangion> ddarius: There are two accumulators, and a tiny number of registers. Doing branch predication on 8051 is quite hard.
08:20:16 <ddarius> I didn't say anything at all about branch predication.
08:20:38 <ddarius> And again, so?  You didn't say it was difficult, you said it was impossible.
08:20:48 <Arafangion> Except for trivial cases that I've recently been alerted to. (Seems every time I'm in Haskell, I learn something profound)
08:22:16 <ddarius> Not that this has anything to do with C.
08:22:47 <Arafangion> ddarius: Indeed.
08:23:25 <Arafangion> You guys have made the point, though, I've got more reading material now. :) Seems that I *have* done branch predication in specific situations, but only when it actually saves memory - which is infrequent.
08:24:00 <Arafangion> And back to the original point, it's indeed interesting to consider if/then/else as lazy.
08:24:25 <monochrom> at least consider it non-strict please
08:24:48 <ddarius> Yes, technically "lazy evaluation" is a specific implementation strategy.
08:25:55 <xplat> the difference in this case is irrelevant though
08:26:37 <Arafangion> I suppose it has the same semantics unless the language does uses both lazy evaluation, and strict evaluation, and doesn't completely match up the two semantics proeprly.
08:26:51 <Arafangion> For example, I have to be aware of what expressions in C# are lazily evaluated, and which are not.
08:27:22 <Arafangion> Because msot of C# is strict, and only a specific subset is lazy.
08:28:12 <xplat> if C let you write your own lazy functions there could maybe be a difference between lazy and other non-strict semantics
08:29:02 <Arafangion> C# has a difference.
08:29:27 <Arafangion> You can choose to process a list lazily or strictly.
08:29:40 <Arafangion> (Including, having that list generated lazily)
08:30:16 <xplat> i guess even while could let you distinguish them depending on how effects are integrated with evaluation
08:31:13 <Arafangion> I must confess, the usual reason why it matters in C# is when side effects come into play.
08:31:25 <chfo> is it possible to write this in one line: https://gist.github.com/1dccef5755b4a18ab605
08:31:46 <monochrom> main = getArgs >>= main'
08:32:13 <chfo> thank you :)
08:33:11 <ddarius> There is nothing that isn't possible to write in one line in Haskell.
08:37:15 <xplat> or pretty much any language other than python
08:37:25 <xplat> well, or fortran
08:37:40 <dino-> dons_: Late, I know, but congrats on the new position.
08:37:56 <benmachine> cpp directives can't be written on one line, although theoretically they're optional
08:38:08 <Arafangion> xplat: You can do "everything on one line", except for the imports. It's just very, very hard.
08:38:45 <ddarius> xplat: Also COBOL.
08:38:52 <ddarius> And various assembly languages.
08:38:53 <Arafangion> (Essentially, you use lambda a lot, but because they're limited to one expression, and it's python, you have to use a crapload of them)
08:39:02 <Tomsik> If you don't have a limit on line length...
08:41:10 <dino-> @quote typecheck
08:41:11 <lambdabot> Saizan says: yesterday i was so drunk i was trying to typecheck the people at the party.. "what's your monad!?"
08:41:41 <dino-> There was one about randomly-generated snippets of code type checking.
08:42:05 <dino-> What ddarius said above about "possible to write in one line" made me remember it.
08:43:05 <monochrom> @quote drunk
08:43:05 <lambdabot> dons says: keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd,
08:43:05 <lambdabot> perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
08:46:01 <Saizan> @quote random
08:46:01 <lambdabot> ilyas says: Haskell is a language where you start reading up on random abstract algebra before you feel ready to implement a simple bayesian network app.
08:46:13 <Saizan> @quote random.code
08:46:13 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
08:46:34 <dino-> @quote snippet
08:46:34 <lambdabot> sigfpe says: Haskell is so strict about type safety that randomly generated snippets of code that successfully typecheck are likely to do something useful, even if you've no idea what that useful
08:46:35 <lambdabot> thing is.
08:46:46 <dino-> There it is
08:49:04 <mgsloan> has anyone made one of those?
08:51:07 <yoki> hi there, i want to use HXT - Text.XML.HXT.Arrow.Pickle for parsing xml output in string format, but the API only takes a FilePath AFAIK
08:51:47 <yoki> here is the api http://hackage.haskell.org/packages/archive/hxt/latest/doc/html/Text-XML-HXT-Arrow-Pickle.html#v:xunpickleDocument
08:51:50 <yoki> here is example code http://pastebin.com/k2pRfhPX
08:51:50 <benmachine> I once looked into the idea of generating random bits of haskell-src-exts AST
08:51:52 <mauke> The paste k2pRfhPX has been copied to http://hpaste.org/47935
08:51:57 <benmachine> got bored before it went anywhere interesting :P
08:52:45 <luite> hehe randomly generate code with a specified type, and modify it until it quickchecks?
08:53:00 <mgsloan> ah, happen to have the code lying around? I'd be interested in taking a look - it's a bit related to an idea I've been playing with for a while
08:53:25 <mgsloan> luite - that's the general plan :D except I'm going to involve the user in the process
08:54:16 <benmachine> luite: nah, I'd write a function to randomly generate expressions of type <foo> and then build it up right first time
08:54:19 <benmachine> as it were
08:54:25 <benmachine> oh wait I see what you mean
08:54:27 <benmachine> sure maybe :P
08:54:57 <benmachine> mgsloan: I don't think I ever produced anything useful, but I'll see if I've got it
08:55:13 <mgsloan> thanks!
08:55:20 <benmachine> mgsloan: no, looks like I got rid of it, sorry :(
08:55:25 <benmachine> it was more of an idea than a useful thing
08:55:31 <dino-> yoki: Wondering if something like Text.XML.HXT.Arrow.ReadDocument.readString or readFromString can help here.
08:55:41 <benmachine> I am writing a type-checker for haskell-src-exts expressions though which could potentially be useful
08:56:01 <mgsloan> no worries, I've got some machinery /kinda/ like that, but it doesn't generate anything but function apps
08:56:13 <luite> benmachine: manually doing the type checking, or using the ghc api?
08:56:45 <benmachine> luite: manually. I want to be independent of GHC in the long run
08:57:06 <luite> oh that could be a lot of work :)
08:57:10 <dino-> Oh, that calls readDocument, hm
08:57:33 <benmachine> luite: yeah, it depends how complex I want it to be – I've already done a typechecker for lambda expressions
08:57:57 <benmachine> luite: and I found something that purports to typecheck haskell98+MPTCs
08:57:59 <mgsloan> ahh, indeed! a typechecker which avoids needing to run GHCi.interpret/typeof on potential function applications could be a pretty big performance win
08:58:02 <benmachine> luite: so I'm tryign to adapt that
08:58:26 <luite> you don't want any of the other extensions?
08:58:29 <benmachine> mgsloan: I just think it would be handy to have as a component separate from the monolithic GHC distribution
08:58:37 <benmachine> luite: well, not if they're going to be a nightmare to implement :P
08:59:04 <luite> hehe ask SPJ, it took him a few tries ;p
08:59:16 <ddarius> benmachine: Well, if you start from the metatheory GHC currently uses, it won't be nearly as bad as it was for the GHC folk.
08:59:41 <benmachine> ddarius: I'm starting from a paper I found called 'typing haskell in haskell'
08:59:47 <benmachine> I don't know how closely that relates to how GHC does it
09:01:18 <ddarius> benmachine: Not very.  That's a rather old paper.
09:01:42 <ddarius> benmachine: I would recommend looking at things like HM(X) and Chameleon, and also modern papers on System Fc.
09:01:48 <luite> something about System Fc maby be more useful
09:01:51 <luite> bah
09:02:31 <benmachine> ddarius: anything specific? the advantage of using thih is that I just have to adapt work instead of start anew, which vastly increases the chances it will ever actually be finished :P
09:03:15 <ddarius> I'm pretty sure THIH won't put you in a good position for handling much of the newer features, or even some old features.
09:03:29 <ddarius> There isn't too much work on System Fc, so just read it all.
09:03:46 <ddarius> HM(X) has a larger literature, but I don't have any specific recommendations.
09:05:22 <ddarius> Chameleon is(was) a Haskell-like language using the HM(X) framework.
09:07:53 * hackagebot runghc 0.1.0.2 - runghc replacement for fast repeated runs  http://hackage.haskell.org/package/runghc-0.1.0.2 (MikeZuser)
09:10:34 <benmachine> ddarius: hmm, ok.
09:36:07 <lebedev> names
09:40:10 <Popsicle_> test.
09:49:59 <accel> s/window 3
09:52:04 <mietek> Anyone interested in delimited continuations?
09:52:40 <mietek> I could use a little help with mixing CC-delcont's Control.Monad.CC adn IO
09:52:48 <mietek> s/adn/and/
09:53:59 * hackagebot air 2011.6.19 - air  http://hackage.haskell.org/package/air-2011.6.19 (JinjingWang)
09:54:59 * hackagebot hack2 2011.6.19 - a Haskell Webserver Interface (V2)  http://hackage.haskell.org/package/hack2-2011.6.19 (JinjingWang)
09:55:59 * hackagebot hack2-contrib 2011.6.19 - Hack2 contrib  http://hackage.haskell.org/package/hack2-contrib-2011.6.19 (JinjingWang)
09:58:00 * hackagebot hack2-handler-happstack-server 2011.6.19 - Hack2 Happstack server handler  http://hackage.haskell.org/package/hack2-handler-happstack-server-2011.6.19 (JinjingWang)
09:59:00 * hackagebot nemesis 2011.6.19 - a Rake like task management tool  http://hackage.haskell.org/package/nemesis-2011.6.19 (JinjingWang)
10:01:55 <sanjoyd> Is there a difference between the types (Int) and Int?
10:02:00 * hackagebot miku 2011.6.19 - A minimum web dev DSL in Haskell  http://hackage.haskell.org/package/miku-2011.6.19 (JinjingWang)
10:02:19 <Saizan> sanjoyd: no
10:02:39 <sanjoyd> So there is no difference between a tuple of one element and that element.
10:03:52 <Saizan> there's no unary tuple, in fact
10:04:16 <anagri> ye all rhaskellers
10:09:47 <fem> hello?
10:12:29 <Saizan> hi
10:15:58 <Maxikq> hello! could anyone help me? I have to read list of tuples (Int, Int, Int) from file to my function, how to do it? I've read this line with list as IO String, but how to convert it to [(Int, Int, Int)]?
10:16:49 <hpc> :t read -- Maxikq
10:16:50 <lambdabot> forall a. (Read a) => String -> a
10:16:51 <mauke> what format is it in?
10:17:03 <hpc> :t map read . lines -- Maxikq
10:17:03 <lambdabot> forall a. (Read a) => String -> [a]
10:17:37 <ion> > (read :: String -> [(Int, Int, Int)]) "[(0,1,2),(3,4,5)]"
10:17:37 <lambdabot>   [(0,1,2),(3,4,5)]
10:18:16 <hpc> > map read . lines $ "(1,2,3)\n(4,5,6)" :: [(Int, Int, Int)]
10:18:18 <lambdabot>   [(1,2,3),(4,5,6)]
10:18:21 <Maxikq> w8 i'll try some of your ideas
10:18:50 <benmachine> @let readsMaybe s = case reads s of [r] -> Just r; _ -> Nothing
10:18:51 <lambdabot>  Defined.
10:19:00 <ion> :t map read . lines =<< readFile "foo" :: IO [(Int, Int, Int)]
10:19:01 <lambdabot>     Couldn't match expected type `IO [(Int, Int, Int)]'
10:19:01 <lambdabot>            against inferred type `[a]'
10:19:01 <lambdabot>     In the first argument of `(.)', namely `map read'
10:19:10 <ion> :t map read . lines <$> readFile "foo" :: IO [(Int, Int, Int)]
10:19:11 <lambdabot> IO [(Int, Int, Int)]
10:19:12 <ion> brainfart
10:19:34 <benmachine> :t unfoldr readsMaybe
10:19:35 <lambdabot> forall a. (Read a) => String -> [a]
10:19:58 <ddarius> :t fmap fst . listToMaybe . reads
10:19:59 <lambdabot> forall a. (Read a) => String -> Maybe a
10:20:11 <benmachine> > unfoldr readsMaybe "(1,2,3)\n(4,5,6)\n(7,8,9)" :: [(Integer,Integer,Integer)]
10:20:12 <lambdabot>   [(1,2,3),(4,5,6),(7,8,9)]
10:20:44 <ion> @hoogle readsMaybe
10:20:44 <lambdabot> No results found
10:20:59 <ddarius> readsMaybe = listToMaybe . reads
10:21:06 <benmachine> ion: I defined it up there ^
10:21:17 <benmachine> ddarius: I had it also Nothing if reads returned more than one, but that works too
10:21:21 <ion> Ah, i’m being blind.
10:21:34 <ddarius> benmachine: Point.
10:22:31 <ion> You’d want ‘r:_ -> Just r’, not ‘[r] -> Just r’, i think. Not that i’ve ever encountered a ReadS that does return multiple alternatives.
10:23:16 <hpc> > readS "1.5" :: ReadS Int
10:23:16 <lambdabot>   Not in scope: `readS'
10:23:22 <hpc> > reads "1.5" :: ReadS Int
10:23:23 <lambdabot>   Couldn't match expected type `Text.ParserCombinators.ReadP.ReadS
10:23:23 <lambdabot>           ...
10:23:25 <hpc> pah
10:23:45 <ion> > (reads :: ReadS Integer) "1.5"
10:23:46 <lambdabot>   []
10:24:58 <Maxikq> could anyone explain on sample how to use some of your ideas? i'm beginner, but i have to do it : (
10:25:18 <hpc> Maxikq: suppose you made a file with a tuple on each line
10:25:25 <Maxikq> no
10:25:29 <ion> Exactly what format does the file have? What does readFile "thefile" print in ghci?
10:25:44 <Maxikq> i've got something like that [(1,1,1), (2,2,2)] for ex. in one line
10:26:10 <ion> read <$> readFile "foo" :: IO [(Integer, Integer, Integer)]
10:26:11 <Maxikq> exactly: first line number, second line number, third line this list of tuples
10:26:47 <Maxikq> what i have to import to use this?
10:26:49 <ion> That was not exact. Please paste some of the output.
10:26:53 <hpc> Maxikq: all of those are in prelude
10:27:00 <benmachine> hpc: <$> isn't
10:27:01 <ion> <$> isn’t.
10:27:04 <hpc> oh yes
10:27:16 <hpc> fmap read $ readFile "foo" :: whatever
10:27:24 <benmachine> yes that's a bit better
10:29:04 <hpaste> hpc pasted “tuples” at http://hpaste.org/47937
10:29:32 <Maxikq> gr8! thanks, i'll check it
10:29:34 <hpc> that paste will compile and run like i think you want
10:29:43 <hpc> given a suitable definition of doWhateverYouWantWith ;)
10:30:34 <Maxikq> ofc : )
10:31:26 <ion> read `fmap` readFile "foo" to get rid of the ($) but still not have to import the scary Control.Applicative.
10:34:00 <Maxikq> i haven't figure out this do notation yet, why it doesn't work: tuples <- fmap read $ readFile "77" 	print $ tuples !! 0
10:34:40 <ion> Probably because it wasn’t able to infer the type of tuples in order to pick the correct version of read.
10:35:06 <ion> The assumption in hpc’s paste was that doWhatever would be :: [(Integer, Integer, Integer)] -> …
10:35:16 <ion> But to explicitly tell the type, you could do:
10:35:31 <ion>   tuples <- read `fmap` readFile "77" :: IO [(Integer, Integer, Integer)]
10:35:33 <drdo> Haskell is marked as having gtk3 bindings but the link is to the gtk2hs page, does it support gtk3?
10:36:28 <dcoutts> drdo: not sure, it might build against the gtk3 headers, my guess is it doesn't, but that it will not be much work to get it working
10:37:24 <Maxikq> @ion cool, now it works, thank you very much
10:37:24 <lambdabot> Maybe you meant: do id join nixon run wn yow
10:37:30 <ion> read is :: (Read a) => … -> a, print is :: (Show a) => a -> …
10:37:40 <HairyDude> How do I turn on FFI highlighting in the vim haskell mode?
10:37:44 <ion> If you just feed stuff from read to print without specifying the type, Haskell can’t know what type you want.
10:37:59 <Maxikq> ok, i see
10:38:09 <ion> On the other hand, if instead of print you used something that is :: [(Integer, Integer, Integer)] -> …, Haskell would know which read to use.
10:38:42 <Maxikq> i'll remember, thanks
10:41:25 <ion> An alternative type annotation that is equally valid for that specific example would be: do tuples <- read `fmap` readFile "77"; print $ (tuples :: [(Integer, Integer, Integer)]) !! 0. or even print (tuples !! 0 :: (Integer, Integer, Integer)).
10:42:18 <Maxikq> interesting, i didn't know that i can specify type in body of function
10:42:18 <ion> Or even (print :: [(Integer, Integer, Integer)] -> IO ()) $ tuples !! 0. :-P
10:42:50 <ddarius> Why are we using !! 0?
10:43:22 <ion> Dunno, i just annotated his example with the required type without changing anything else.
10:43:54 <Maxikq> i just wanted to check how it works, i'll use it in another way
10:45:55 <parcs> @src (!!)
10:45:55 <lambdabot> xs     !! n | n < 0 = undefined
10:45:55 <lambdabot> []     !! _         = undefined
10:45:56 <lambdabot> (x:_)  !! 0         = x
10:45:56 <lambdabot> (_:xs) !! n         = xs !! (n-1)
10:46:25 <parcs> two undefineds :(
10:47:22 <benmachine> f x = undefined only has one!
10:47:31 <benmachine> (f x = f x doesn't have any)
10:47:48 <ion> f = f  -- pointfree!
10:49:05 <benmachine> :P
10:49:24 <ClaudiusMaximus> @hoogle atMay
10:49:25 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
10:49:46 <ddarius> head = (!! 0)
10:49:49 <ion> > let a = a in а 5
10:49:51 <lambdabot>   6
10:50:08 <benmachine> ...wat
10:50:35 <ddarius> > "let a = a in а 5"
10:50:36 <lambdabot>   "let a = a in \1072 5"
10:50:40 <ClaudiusMaximus> @pl \a b c d e f g -> e g g f a c e
10:50:41 <lambdabot> const . (const .) . flip flip id . (liftM2 (flip . (flip .)) .) . flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip . join)
10:50:42 <benmachine> :<
10:50:46 * benmachine feels betrayed
10:51:24 <ddarius> You can trust me, benmachine, when I say you can't trust anyone on the internet.
10:51:25 <benmachine> :t а
10:51:26 <lambdabot> <no location info>: not an expression: `'
10:51:29 <parcs> :t take 1 . drop
10:51:30 <lambdabot>     Couldn't match expected type `[a]'
10:51:30 <lambdabot>            against inferred type `[a1] -> [a1]'
10:51:30 <lambdabot>     Probable cause: `drop' is applied to too few arguments
10:51:38 <ion> :t take 1 .: drop
10:51:39 <lambdabot> forall a. Int -> [a] -> [a]
10:51:42 <parcs> :t take 1 .: drop
10:51:43 <lambdabot> forall a. Int -> [a] -> [a]
10:51:54 <benmachine> ddarius: I see no problems with this assertion.
11:10:09 * hackagebot mersenne-random 1.0.0.1 - Generate high quality pseudorandom numbers using a SIMD Fast Mersenne Twister  http://hackage.haskell.org/package/mersenne-random-1.0.0.1 (DonaldStewart)
11:19:41 <sshc> Can Template Haskell or CPP be used to add pragmas (NOINLINE in particular)?
11:23:06 <hpaste> Maxikq pasted “getline” at http://hpaste.org/47940
11:23:16 <Maxikq> how to get single line?
11:23:34 <Maxikq> why it doesn't work, i'm confused by this "do notatation" xd
11:24:07 <merijn> Maxikq: What did you expect to happen and what actually happened?
11:24:08 <ben> openmodes are a bunch of constructors, not strings
11:24:09 <ion> head . map lines <$> readFile "77"
11:24:15 <ben> aren't they
11:24:26 <Maxikq> i mean i want a function which result is single line from file
11:24:30 <merijn> "It doesn't work" is a kind of vague to troubleshoot :p
11:25:06 <merijn> ben: You appear to be right
11:25:06 <Maxikq> i know; p but i thought that for someone who know haskell the error will be obvious:D
11:25:22 <iskren> I'm having some problems building stuff with main: http://fpaste.org/KgEj/ (build log), http://iskren.info:8112/file/3d069916ff11/Makefile << makefile
11:25:27 <merijn> Maxikq: You didn't paste the error though, but ben seems to be correct
11:25:45 <merijn> Maxdamantus: openfile doesn't take a string as second argument it takes an IOMode
11:26:03 <merijn> eh, s/Maxdamantus/Maxikq
11:26:06 <Maxikq> prac3.hs:275:5:     The last statement in a 'do' construct must be an expression:     line <- hGetLine handle return line hClose handle
11:26:08 <Maxikq> error
11:26:21 <merijn> Maxikq: Valid constructors appear to be: ReadMode, WriteMode, AppendMode and ReadWriteMode
11:26:38 <Maxikq> there is ReadMode
11:26:39 <ion> Incorrect indentation?
11:26:40 <merijn> eh
11:26:45 <merijn> Hmm, I fail at reading :p
11:27:22 <ion> But anyway, head . lines <$> readFile "77"  (map lines was a brainfart)
11:27:47 <ben> merijn: haha, me too
11:28:03 <Maxikq> in which lib is <$>
11:28:09 <noteventime> Maxikq: Control.Applicative
11:28:14 <Maxikq> thanks
11:28:16 <ion> Control.Applicative. You can use `fmap` in its place, too.
11:28:17 <noteventime> It's just an infix notation for fmap though
11:28:24 <ben> shouldn't we not use readFile
11:28:28 <merijn> Maxikq: It works here, did you mix tabs and spaces or something?
11:28:33 <ben> isn't that lazy IO
11:28:45 <Maxikq> maybe xD w8 i'll check it out
11:28:50 <ion> :t bracket
11:28:51 <lambdabot> Not in scope: `bracket'
11:28:55 <ion> @hoogle bracket
11:28:55 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
11:28:55 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
11:28:56 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
11:29:02 <merijn> Maxikq: The error also seems to indicate incorrect indentation
11:29:19 <ben> "withFile "foo.hs" ReadMode hGetLine" seems decent
11:29:30 <ben> except with "77" I guess
11:29:32 <ion> In IO code that has something like open; read; close, you’ll want to use bracket to make sure the close still happens if the reading raises an exception.
11:29:43 <ion> withFile does that.
11:31:04 <Twey> ben: Yes, but the Right alternative to lazy I/O is iteratees, and that's maybe jumping in at the deep end a bit :þ
11:32:01 <merijn> Twey: Especially considering the obtuse documentation of the various iteratee implementations...
11:32:09 <Twey> Well yes :þ
11:32:26 <Twey> In fairness, iteratees as a concept are quite tricky.  At least, I find them so.
11:33:35 <iskren> hm the -main-is option should be given when compiling to object file, not when linking... interesting :)
11:38:23 <ben> Twey: I haven't figured out iteratees myself so I have to agree :V
11:38:34 <kmc> i sort of get iteratees but i feel like they're Not There Yet
11:39:21 <kmc> i'm writing an attoparsec parser and i'm happy to expose it so someone else can use it as an iteratee ;)
11:40:05 <ben> I read a paper or other on iteratees and it all made perfect sense and seemed like an obvious solution to an important problem
11:40:17 <ben> the next time I looked at them I had no idea what was going on
11:40:21 <ben> clearly there's more than meets the eye
11:40:29 <kmc> yeah, the core idea is nice
11:40:48 <kmc> then you look at the library docs and it's not clear how it all fits together to implement that core idea
11:41:05 <merijn> ben: Well, the idea is pretty simple. It's just that the library docs aren't very clear on how to actually use them
11:41:05 <ben> maybe this haskell: the craft of functional programming book will say something about it :V
11:42:14 <Maxikq> read (head . lines <$> readFile "77") :: Int , why it doesn't work (some error with type [Char] and IO String) i know that probably it's stupid :D but i'm beginner so you know xd i'm trying third hour to read one stupid file :D
11:42:56 <merijn> Maxikq: You're returning an "IO String" (or "IO [Char]") whereas whatever you are giving it to is expect a String (or [Char])
11:43:14 <monochrom> make it read . head . lines <$> readFile "77" :: IO Int
11:43:33 <kmc> Maxikq, http://www.haskell.org/haskellwiki/Introduction_to_IO
11:43:42 <Maxikq> thanks :D you're the masters
11:43:50 <kmc> a value of type IO String describes some actions you could take to produce a String
11:43:54 <kmc> it's not a String itself
11:43:56 <merijn> Maxikq: You can use either do notation's "<-", fmap or the IO monad's ">>=" to get it
11:44:05 <monochrom> @type read . head . lines <$> readFile "77"
11:44:06 <lambdabot> forall a. (Read a) => IO a
11:44:22 <Maxikq> thanks for info
11:44:26 <monochrom> (just checking operator precedence)
11:44:37 <mietek> How can I link my program with a cabalised package without installing the package?
11:44:40 <ion> :t read <$> withFile "77" ReadMode hGetLine
11:44:41 <lambdabot> Not in scope: `withFile'
11:44:41 <lambdabot> Not in scope: data constructor `ReadMode'
11:44:41 <lambdabot> Not in scope: `hGetLine'
11:44:44 <Reaganomicon> What is <$>?
11:44:51 <merijn> :t (<$>)
11:44:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:44:52 <ion> An infix alias of fmap
11:45:02 <merijn> Reaganomicon: Infix fmap apparently
11:45:08 <kmc> it's supposed to match Applicative's (<*>)
11:45:09 <parcs> iteratees are much more easily understood if you remove the monad transformer stuff that is added. specifically, the m type parameter
11:45:27 <kmc> :t (<$)
11:45:28 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
11:45:33 <Reaganomicon> Any idea why ghci can't find it with :t?
11:45:43 <Reaganomicon> is there some sort of an include I should be doing first?
11:45:43 <kmc> Reaganomicon, because you have to import it, from Control.Applicative
11:46:02 <monochrom> :m + Control.Applicative
11:46:12 <merijn> In these cases Hoogle is your friend too :)
11:46:15 <Reaganomicon> So there isn't any centralized docs for looking these things up?
11:46:21 <Reaganomicon> oh hoogle
11:46:26 <Reaganomicon> Forgot about that one
11:46:44 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/index.html has the centralized docs
11:46:48 <kmc> but you still have to know which module it's in
11:46:49 <merijn> Reaganomicon: Well, there's http://www.haskell.org/ghc/docs/latest/html/libraries/index.html but that only works if you know where you're supposed to look
11:46:56 <merijn> Hoogle is usually easier :)
11:48:04 <Reaganomicon> I'm firmly convinced that Haskell is magic created and maintained by lispliches
11:48:04 <Reaganomicon> Now if only I could convince my school to drop ocaml in favour of it... :(
11:48:34 <monochrom> ocaml is fine
11:48:51 <monochrom> ocaml's type system already blows minds
11:49:02 <merijn> monochrom: Not if you come from Haskell's nice syntax...
11:49:18 <kmc> ocaml has some cool features haskell doesn't
11:49:22 <monochrom> nice syntax is orthogonal to type system
11:49:31 <merijn> I had to TA an ocaml practical (as a short notice substitute) a few months back, man that was painful
11:49:47 <monochrom> just think of records
11:49:50 <kmc> i wrote a compiler in ocaml... i would rather have used Haskell, but it's not a big difference
11:49:51 <merijn> I wanted typeclasses so badly :(
11:49:58 <kmc> at least they didn't make us write our compiler in Java, like every other school does
11:50:01 <Reaganomicon> ocaml doesn't have where, which leads to a nest of let ... in, which is ugly as sin. :(
11:50:06 <kmc> Visitor Pattern wheeeeee
11:50:11 <merijn> kmc: Hah, ours made us write it in C :D
11:50:16 <dolio> Java?
11:50:22 <dolio> My school used C++.
11:50:25 <kmc> dolio, when?
11:50:29 <Reaganomicon> The absence of where is a crime against code.
11:50:32 <monochrom> just think of records, and haskell is the painful one and ocaml is the nice one
11:50:36 <dolio> 7 years ago?
11:50:43 <kmc> i liked the availability of non-recursive let, however
11:50:49 <kmc> recursive let has screwed me in Haskell a few times
11:51:01 <Twey> What do OCaml records have?
11:51:04 <Nimatek> I'd prefer C++ to Java.
11:51:05 <merijn> kmc: Everytime people mention stuff like "design patterns" I always go "huh?", then they explain what they mean and I go like "that's so simple, why do you even need a pattern for that?"
11:51:12 <dolio> Twey: They're extensible records.
11:51:18 <kmc> merijn, design patterns are standardized workarounds for language flaws
11:51:20 <Twey> Oh, nice
11:51:22 <Eduard_Munteanu> Dunno, I'm not sure we do much Java here.
11:51:23 <merijn> Twey: structural subtyping
11:51:23 <Twey> Why don't we do that?
11:51:24 <monochrom> extensible records and a right synta
11:51:33 <kmc> Twey, Hugs has them
11:51:37 <merijn> kmc: I know :p
11:51:37 <Reaganomicon> merijn: Well, you need to name your hack before you can talk about it with others.
11:51:40 <kmc> plus there are various libs to fake them in GHC
11:51:51 <Twey> I don't understand why none of this has been implemented in GHC
11:51:57 <Eduard_Munteanu> In my major there's a lot of Matlab, and some C and C++. In the CS-ish major they even do Haskell.
11:51:59 <kmc> Reaganomicon, but it's better if you implement your hack as a library
11:52:01 <merijn> Twey: Lack of demand?
11:52:05 <kmc> but in Java you often can't
11:52:08 <Twey> merijn: *Really*?
11:52:20 <Twey> The *number one* complaint I hear about Haskell is ‘the record system sucks’
11:52:31 <merijn> Twey: Isn't that more the accessing part?
11:52:34 <dolio> It doesn't suck enough for anyone to get off their ass, though.
11:52:35 <Twey> (okay, after ‘it's too hard and breaks my procedurally-oriented brain’)
11:52:38 <Reaganomicon> Also OCaml doesn't have cabal or a decent REPL :(
11:52:57 <dolio> OCaml's REPL is better than ghci, isn't it?
11:53:03 <Eduard_Munteanu> Agda got some parts of the record system better, but it still sucks :)
11:53:03 <mauke> dolio: no
11:53:06 <kmc> i remember having to use rlwrap with it
11:53:08 <dolio> Really?
11:53:08 <monochrom> ocaml's record and object are unified under the same subtyping type system. you don't have to worry about one of them being disadvantaged when compared to the other
11:53:09 <kmc> but that's ok
11:53:09 <merijn> Twey: I don't really need structural subtyping, its sorta nice to have. Better accessors would be good, though
11:53:15 <mauke> dolio: no readline support
11:53:20 <merijn> dolio: It doesn't even do backspacing...
11:53:21 <dolio> Oh, geeze.
11:53:23 <Eduard_Munteanu> Because they didn't even get to the part where you can use record update syntax.
11:53:25 <kmc> rlwrap fixes that
11:53:28 <Twey> But there are existing systems like TRex and stuff
11:53:29 <merijn> dolio: That's how I learned rlwrap existed
11:53:32 <mauke> merijn: backspace works, that's done by your terminal
11:53:48 <kmc> OCaml is more of an "academic language" than Haskell in terms of library availability, branding, etc
11:53:50 <merijn> mauke: I just got "^H" in my ocaml prompt
11:53:55 <Twey> mauke: Eh?  No it's not
11:54:03 <kmc> this is not necessarily a fair or meaningful point for comparison
11:54:04 <Twey> It's done by readline or whatever you're using
11:54:07 <mauke> Twey: no
11:54:10 <kmc> but it does influence a lot of things
11:54:27 <mauke> merijn: try running 'reset'
11:54:37 <merijn> Doesn't backspace depend on whether your terminal is in cooked/raw or the in-between mode?
11:54:39 <monochrom> but you can just type in a whole module at the repl cold
11:54:43 <mauke> merijn: yeah
11:54:44 <Twey> Unless you've got a line-buffering terminal, I don't even see how that is possible
11:54:51 <mauke> Twey: that's the default
11:55:01 <Twey> Oh, really?
11:55:10 <Twey> Why do so many things disable it, then?  >.>
11:55:20 <mauke> like what?
11:55:21 <dolio> monochrom: Yeah, that's the part where it's obviously ahead.
11:55:33 <Twey> Like GHCi
11:55:34 <merijn> mauke: I don't have to do ocaml anymore, so the problem is already solved by uninstalling ocaml :D
11:55:51 <mauke> Twey: because ghci uses readline/haskeline/whatever
11:56:06 <mauke> which is far more flexible than supporting backspace
11:56:09 <Twey> Aha
11:56:28 * Eduard_Munteanu wonders who's guilty of making Haskell popular. :)
11:56:35 <mauke> you don't get line editing, for example
11:56:49 <mauke> oh, and you can try this by running 'cat'
11:56:52 <Twey> Maybe people should just write better terminals :þ
11:57:12 <Twey> Yeah, I believe you
11:57:22 <mauke> <backspace> should delete the last character, ^W the last word, and ^U the whole input line
11:57:54 <monochrom> and ^D the whole session :)
11:58:07 <drdo> emacs is the solution to all your problems
11:58:12 <monochrom> hehe
11:58:22 <mauke> no, ^D makes the active read() call return immediately
11:58:24 <monochrom> yes, use the emacs ocaml mode
11:58:27 <merijn> Don't you mean problem to all my solutions? :>
11:58:39 <mauke> if there is no active input, it will return 0, signifying EOF
11:58:43 <Eduard_Munteanu> ^D is basically EOF
11:58:45 <monochrom> "there is an emacs mode for that"
11:58:54 <mauke> otherwise it will transmit the current line to the program
11:59:01 <mauke> without \n, of course
11:59:21 <vikramverma> ^H can be used in place of backspace to delete the last character.
11:59:38 <mauke> not here
11:59:55 <Twey> ^H *is* backspace to delete the last character.  Unless your terminal uses ^?.
12:00:10 <mauke> yeah, ^? here
12:00:22 <Twey> Here too, I think
12:00:25 <mauke> ^H is not backspace because that's incompatible with emacs
12:00:33 <vikramverma> mauke: What environment are you in?
12:00:37 <mauke> or rather, ^H is backspace on output but not input
12:00:41 <Twey> Haha, I can backspace over my irssi prompt
12:00:42 <Twey> >.>
12:00:49 <Eduard_Munteanu> Here ^/ is some sort of undo
12:01:20 <mauke> vikramverma: tmux in urxvt in xmonad in X
12:01:35 <vikramverma> mauke: Oh hey, same! :P
12:02:04 <Eduard_Munteanu> It kinda depends on terminal settings, chosen termcap etc.
12:02:11 <mauke> emacs wants to use ^H to mean "help", which I think is the only reason <backspace> sends ^?
12:02:33 <ski> dolio : ocaml's repl allows you to define new types in it
12:03:12 <ski> (and new exceptions and new classes and new modules and new module signatures, of course)
12:03:16 <Maxikq> so could someone explain how to use do notation to get Int form IO Int ? i've got:
12:03:17 <Maxikq> load = do  	line <- read . head . lines <$> readFile "77" :: IO Int 	return line
12:03:50 <xplat> someone should write an ocamlp4 thingy to let you write ocaml programs in haskell syntax
12:03:59 <Twey> Maxikq: Tada: ‘line’ is an Int
12:04:12 <Twey> (but try not to mix tabs and spaces)
12:04:25 <parcs> mauke: heh, same here
12:04:31 * vikramverma was serious: tmux+Urxvt+XMonad http://i.imgur.com/kfAQa.png
12:04:51 <Maxikq> line is Int?
12:05:04 <Maxikq> there is ":: IO Int"
12:05:28 <identity_> I really should try xmonad
12:05:28 <Twey> Maxikq: read . head . lines <$> readFile :: IO Int
12:05:29 <merijn> Maxikq: "read . head . lines <$> readFile "77"" is an IO Int, "<-" makes it usable as an int
12:05:35 <Twey> Maxikq: line :: Int
12:05:43 <Twey> That's what <- does
12:05:57 <identity_> at any rate, I regularly run 4 terminals all ssh'd into different servers which are tmuxed to maintain irssi and other stuff open
12:06:02 <Twey> Er, … <$> readFile "77" :: IO Int
12:06:02 <Maxikq> nice, but how can i use it? for example in prelude
12:06:13 <ski> Reaganomicon : batteries adds `where' to OCaml, using Camlp4 <http://batteries.forge.ocamlcore.org/doc.preview:batteries-beta1/html/extensions.html#where>
12:06:13 <mauke> Maxikq: you can't change the prelude
12:06:15 <merijn> Maxikq: "line <- foo" basically says "I want to access foo's 'IO a' as an 'a' named line"
12:06:22 <Maxikq> something like load+5 doesn't work
12:06:32 <mauke> Maxikq: 'load' is not 'line'
12:06:32 <Reaganomicon> ski: don't campl4/5 addons clash horribly?
12:06:37 <ion> <- “draws” an ‘a’ out of an ‘IO a’ (or more generally, ‘m a’).
12:06:46 <Twey> Maxikq: load :: IO Int
12:06:52 <Maxikq> owh
12:06:54 <merijn> Maxikq: No, but "do line <- load; line +5" does
12:06:54 <ski> Reaganomicon : i dunno, i haven't used them very much
12:06:56 <kmc> Maxikq, you can't really get Int from IO Int.  you can feed an IO Int into a (Int -> IO SomethingElse) and get an IO SomethingElse overall result
12:07:08 <kmc> Maxikq, the "do" notation makes this look more like you're just getting the Int out
12:07:10 <Twey> kmc: Vice versa?
12:07:20 <Twey> Feed an (Int -> IO SomethingElse) into an IO Int
12:07:26 <ski> merijn : `load' is not an `Int', but an `IO Int'
12:07:31 <kmc> you could think of it that way
12:07:44 <Maxikq> mhm, so if i want a function which return the first line as Int isn't possible?
12:07:52 <merijn> ski: I fail to see how that applies to anything I said?
12:07:56 <kmc> Maxikq, right
12:08:01 <kmc> Maxikq, there's no real (IO Int -> Int) function, because an IO Int isn't anything like an Int -- it's a recipe for getting Ints
12:08:16 <identity_> @type unsafePerformIO
12:08:16 <lambdabot> Not in scope: `unsafePerformIO'
12:08:22 <kmc> you can execute the same (IO Int) several times and get different Ints each time.  furthermore, each execution might have other effects
12:08:28 <merijn> identity_: Don't give new people rope to hang themselves
12:08:32 <Twey> merijn: Obvious misdirect
12:08:35 <Maxikq> i read this introduction a little :
12:08:51 <ski> merijn : sorry ?
12:09:04 <Maxikq> so how shoud i do this?
12:09:05 <ski> er
12:09:08 <Maxikq> i've got a file
12:09:16 <ski> Maxikq : `load' is not an `Int', but an `IO Int'
12:09:26 <Cale> Maxikq: If you want to perform an IO action, you have to do it from inside another IO action.
12:09:30 <Maxikq> first line : for ex. 7, snd  line 7 thrd [(1,2,2), (1,2,2)]
12:09:32 <ski> merijn : sorry, pebkac
12:09:36 <merijn> ski: np :D
12:09:48 <Maxikq> i want to get this datas to function
12:09:52 <identity_> merijn: Well
12:09:55 <identity_> I give them a rope
12:10:06 <kmc> do { a <- readLn; b <- readLn; xs <- readLn; return (f a b xs) }
12:10:06 <identity_> they can use it as a lifeline or they can hang themselves
12:10:14 <identity_> at any rate, I was just being obnoxious intentionally :P
12:10:21 <kmc> there are more concise ways such as:  liftM3 f readLn readLn readLn
12:10:22 <Cale> Maxikq: Thankfully, the 'main' for your program is always an IO action, so the way you'll typically design your program is as a "candy shell" outside of IO actions, with a "chocolate interior" of pure functions and values. :)
12:10:23 <merijn> Maxikq: The basic idea of haskell is not to get IO data to a function, but get a function to the IO data :)
12:10:40 <Maxikq> hah :D
12:10:45 <Twey> But green Smarties cause cancer!
12:11:26 <Maxikq> w8 a sec i'll try to do this in kmc way :P
12:11:39 <kmc> if you want to use liftM3, you can import it from Control.Monad
12:12:07 <mietek> Sigh
12:12:18 <mietek> How can I build a cabal package without using Cabal?
12:12:28 <mietek> I'd just like to link it together with my code
12:12:32 <kmc> why are you doing that?
12:12:39 <aa_> why is http://paste.pocoo.org/show/414392/ a non-standard pattern guard?
12:12:41 <kmc> is your code also a cabal project or no?
12:12:48 <mietek> kmc: Because of contest restrictions in the ICFP contest
12:12:52 <kmc> ah
12:12:57 <mietek> Silly, I know
12:13:01 <mietek> My code is not cabalised
12:13:05 <dcoutts> mietek: so what do you need to do exactly?
12:13:08 <kmc> what happens if you just copy over the .hs files and import them
12:13:09 <mauke> aa_: because of all the 'let's
12:13:13 <merijn> Maxikq: Think of it like this, instead of specifying a program by saying "read an int from a file, do something with it, then print it" you say this. "If you give me an action which can read an int from a file, I can give it an a function taking and int and doing something with it, thus turning it into an action which can read an int from a file and then do something with"
12:13:13 <kmc> ghc --make will find them through imports
12:13:35 <aa_> mauke: is ther ea better way to do it?
12:13:41 <kmc> aa_, you can replace each "let x = y, " with "x <- y, "
12:13:48 <kmc> a pattern guard whose pattern is just a variable
12:13:53 <merijn> Maxikq: So you construct bigger actions by gluing smaller actions together with pure functions. Then at the end all you have is sequence of actions and your program consists of "run these actions one after another"
12:13:59 <dcoutts> mietek: kmc's suggestion is probably simplest
12:14:15 <kmc> if the cabal file specifies GHC options you may have to do something accordingly
12:14:16 <Twey> Woah, what is this?  I've never even seen this guard syntax before
12:14:20 <Twey> Is that an extension?
12:14:26 <Maxikq> hard thing ;p
12:14:34 <kmc> Twey, the "let" syntax is not supported afaik
12:14:40 <ddarius> Twey: An old one.
12:14:44 <Twey> Oh
12:14:45 <merijn> Maxikq: What are you reading now to learn Haskell?
12:14:46 <Twey> I see
12:14:49 <kmc> pattern guards are supported in GHC -- they're even in Haskell 2010
12:14:51 <Twey> Pre–pattern guards?
12:14:59 <kmc> > let f x | (Just y) <- x = 1 | otherwise = 0 in (f Nothing, f (Just 3))
12:15:00 <lambdabot>   (0,1)
12:15:21 <Twey> No need for the first brackets, I think?
12:15:26 <mietek> dcoutts, kmc: do I need to rearrange the source files from the package, i.e. take them out of the directory hierarchy provided in the package?
12:15:28 <mauke> aa_: | head s == 's' = let ws = words s in OptionLine { optionname = head ws, optionvalue = concat (tail ws) }
12:15:30 <Maxikq> what you mean? now i'm writting a homework project
12:15:40 <Twey> > let f x | Just y <- x = 1 | otherwise = 0 in (f Nothing, f $ Just 3)
12:15:40 <lambdabot>   (0,1)
12:15:42 <Maxikq> i'm reading here; http://learnyouahaskell.com/chapters
12:15:55 <aa_> mauke: ok, like that, thanks
12:16:27 <merijn> Maxikq: Ah. Yeah that one is good. But it doesn't explain IO until quite late. Which is good (in the sense that when you read about IO it will make sense), but also bad (since it can be hard to do "simple things" at first)
12:19:12 <Cale> Maxikq: I wrote a quick intro here: http://www.haskell.org/haskellwiki/Introduction_to_IO
12:19:24 <Cale> Maxikq: to get you started with the idea of IO
12:20:02 <Maxikq> i've read it fast, i'll take a deep look bit later
12:22:13 <Maxikq> it's really annoying when i can't do simple thing ;p and when i know languages like c++,delphi, java etc. and know i'm sitting about 4th hour on reading one stupid file ;p
12:22:41 <Maxikq> i've done whole project, the last thing is to read input datas from file and i'm stuck
12:22:52 <hpaste> Maxikq pasted “do” at http://hpaste.org/47942
12:22:59 <mauke> Maxikq: you should have learned javascript, then this would be easy
12:23:21 <Maxikq> i don't know how to do this ;D
12:23:22 <merijn> Maxikq: Like I said, when you know other languages it can be frustrating that the basics of IO can be so tricky to newcomers. But its worth sticking with it, once it clicks you'll go "Oooooooh!"
12:23:34 <dolio> ski: I know.
12:23:39 <Maxikq> : D
12:24:17 <dcoutts> mietek: no, keep the dir structure
12:24:21 <Maxikq> look at my hpaste, i don't know what is wrong and how it should be done, i'm trying on simple things
12:25:34 <ion> liftA2 (+ `on` read) getLine getLine :: IO Integer
12:25:41 <ion> liftA2 ((+) `on` read) getLine getLine :: IO Integer
12:26:04 <hpaste> merijn annotated “do” with “do (annotation)” at http://hpaste.org/47942#a47943
12:26:23 <merijn> ion: Yeah, that's not scary and intimidating at all for newcomers :D
12:27:17 <monochrom> the moment you get rid of "I'm just trying to do simple things" mindset, the moment it will become simple
12:27:19 <Maxikq> : P
12:27:57 <ion> ((+) `on` read) a b = read a + read b. liftA2 f getLine getLine: draw a from getLine, draw b from getLine, then result in f a b.
12:28:02 <monochrom> and merijn has pasted actual code so you can learn from it
12:28:11 <merijn> Maxikq: What the example basically does is take two actions and creates a new bigger action which takes the result of reading two integers and then adding them
12:28:38 <ddarius> :t readLn
12:28:39 <lambdabot> forall a. (Read a) => IO a
12:28:49 <Maxikq> merijn: where is your code?
12:28:55 <Maxikq> i see only my code
12:28:58 <ion> reload
12:29:03 <merijn> Maxikq: hpaste just mentioned it: http://hpaste.org/47942#a47943 :)
12:29:08 <merijn> Might need to refresh the page
12:29:35 <Maxikq> ok
12:29:55 <merijn> Maxikq: "fmap read getLine" basically says "take an action which reads a line and turn it into an action that reads an integer"
12:29:59 <sshc> Can a splice in Template Haskell be expanded to a pragma?
12:30:32 <merijn> Maxikq: The do notation then takes two such actions and combines them into a bigger action still which reads two integers, adds them together and prints the result
12:31:02 <Twey> @tell BONUS Typo in chapter ‘Zippers’, fourth code block: missing space before the first ->
12:31:02 <lambdabot> Consider it noted.
12:31:19 <Maxikq> merijn: btw. thank you for helping me :)
12:31:44 <Maxikq> and how it knows about Integers? it concludes it from result (a+b) ?
12:34:20 <parcs> @src readLn
12:34:21 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
12:34:40 <merijn> Maxikq: Do you understand the type signatures?
12:35:00 <merijn> If so, I'll annotate the example and hopefully that'll help make sense of everything
12:35:10 <Maxikq> i'm scared to say yes :P so let's say that a little bit
12:35:28 <Maxikq> i'll check it
12:36:38 <Maxikq> btw. i've change (readFile "77"), and why it doesn't work then? I've go "no parse"
12:37:40 <Maxikq> i've change getLine to (readFile "77")
12:38:29 <ion> To get better parse error messages, use a proper parser library such as Parsec instead of read.
12:41:17 <mietek> Is the transformers package part of the Haskell Platform?
12:41:41 <sam7> I have a question about haskell
12:41:44 <kmc> think so
12:41:50 <kmc> sam7, i'd say you're in the right place
12:42:01 <sam7> how do you use functions that are in another file?
12:42:08 <sam7> I have a file primes.hs
12:42:12 <kmc> you import that module and then you just use them
12:42:20 <sam7> and I am writing a new file using a method there
12:42:29 <kmc> rename primes.hs to Primes.hs
12:42:32 <kmc> then write "import Primes"
12:42:46 <noteventime> Does anyone know a good article on the issues arising from using type classes/instances where data types/functions results in an easier and more flexible code?
12:42:48 <sam7> oh... let me give it a shot right now
12:42:54 <hpaste> merijn annotated “do” with “Type annotated my annotation” at http://hpaste.org/47942#a47944
12:43:38 <merijn> Maxikq: This might be a bit complicated, but if you study the type signatures you can learn a lot from http://hpaste.org/47942#a47944
12:44:50 <Maxikq> merijn: thank you, i'll check it, but i have to fight with this project for a while ;p
12:45:02 <sam7> I am tryhing
12:45:03 <sam7> but
12:45:05 <sam7>     File name does not match module name:
12:45:13 <sam7> I get this msg?
12:45:22 <merijn> sam7: Ah, you need "module Primes where" at the top of Primes.hs :)
12:46:18 * hackagebot Cabal 1.10.2.0 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.10.2.0 (DuncanCoutts)
12:46:28 <dcoutts> @yarr!
12:46:29 <lambdabot> Drink up, me 'earties
12:46:36 <merijn> Maxikq: It can also be really helpful to grab a pen and paper and do some of these type substitutions by hand, you'll learn a lot :)
12:47:00 <Maxikq> yea i have to do this before exam : )
12:49:02 <hpaste> Maxikq annotated “do” with “Type annotated my annotation (annotation)” at http://hpaste.org/47942#a47945
12:49:13 <Maxikq> ok, so i need to read 1. 2. and 3. line
12:49:25 <Maxikq> how to change this head to get another lines?
12:49:43 <Maxikq> i've tried with  !! but i put it in a wrong place
12:50:03 <sam7> hm...
12:50:09 <sam7> I got Primes.hs from a source
12:50:10 <aa_> can I pattern match on a constructor?
12:50:18 <merijn> Maxikq: Ah, so you want to add the first line of all three files, then the second line of all three files?
12:50:29 <merijn> aa_: Yes, otherwise what's the point of pattern matching? :>
12:50:35 <Maxikq> no no :D
12:50:37 <sam7> and it has Data.Numbers.Primes {...} where
12:50:55 <sam7> when I want to use one of the functions
12:51:02 <sam7> I have to import Data.Numbers.Primes ??
12:51:12 <aa_> merijn: so I am trying something like Foo:ws to match if the head is a Foo
12:51:14 <mjrosenb> kmc: are you icfp'ing?
12:51:21 <kmc> no :/
12:51:22 <kmc> you?
12:51:23 <hpaste> Maxikq annotated “do” with “Type annotated my annotation (annotation) (annotation)” at http://hpaste.org/47942#a47946
12:51:24 <merijn> Maxikq: Then what? You want to add all lines of all three files together?
12:51:43 <mjrosenb> kmc: yeah, we managed to talk maurer_ into using sml
12:51:45 <Maxikq> i wan't to read three lines of one file ;P i know i'm trying to do this around
12:51:52 <mjrosenb> kmc: he has not really enjoyed the language thusfar.
12:52:07 <kmc> haha
12:52:19 * hackagebot JsonGrammar 0.2 - Combinators for bidirectional JSON parsing  http://hackage.haskell.org/package/JsonGrammar-0.2 (MartijnVanSteenbergen)
12:52:27 <Maxikq> merijn: check hpaste
12:52:28 <aa_> merijn: ah my mistake I needed parentheses around it
12:52:39 <merijn> Maxikq: readFile already reads all lines of the file, the "lines" function turns it into a list of lines. head then returns the first item of that list
12:52:54 <merijn> Maxikq: If you don't want just the first line, remove the "read . head" part
12:54:20 <hpaste> Maxikq annotated “do” with “Type annotated my annotation (annotation) (annotation) (annotation)” at http://hpaste.org/47942#a47947
12:54:29 <sam8> I have a question about importing files
12:54:36 <Maxikq> probably wrong
12:55:13 <sam8> if I am importing a file from another file, where do these files have to be in?
12:55:26 <sam8> do they ahve to be in same folder?
12:55:33 <mauke> no, they can be anywhere
12:55:40 <kmc> if Foo.hs has "import Bar" then it will look for Bar.hs next to Foo.hs
12:55:48 <kmc> if you "import Bar.Baz" it will look in Bar/Baz.hs
12:55:51 <hpaste> merijn annotated “do” with “Type annotated my annotation (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/47942#a47948
12:56:11 <kmc> but you can package your library and install it, and then things are different
12:56:19 <merijn> Maxikq: Almost, also. Note that the third line is not an int so you can't really add c to a and b
12:56:41 <parcs> kmc: i thought module loading was relative to the current directory, not the directory of the file that's being loaded
12:56:44 <Maxikq> yea, i know, it doesn't matter know
12:56:59 <Maxikq> i'm just trying to get idea of working on that
12:57:27 <kmc> maybe that's true parcs
12:57:45 <hpaste> merijn pasted “Example” at http://hpaste.org/47949
12:58:01 <merijn> Maxikq: If you ignor/remove the last line you could do something like that example
12:58:23 <sam8> wow it finally worked
12:58:25 <sam8> thank
12:58:27 <sam8> s
12:59:08 <merijn> Maxikq: Basically, ln is a list of String "map read" turns it into a list of Int, sum adds them together turning it into an Int, then print finally prints the result
12:59:26 <Maxikq> merijn: but let's assume that my file has numbers in each line
12:59:40 <Maxikq> and what's wrong in my code?
13:00:01 <Maxikq> i've got error No instance for (Read (IO a0))       arising from a use of `read'
13:00:12 <merijn> The read calls don't return an IO Int, but Int so the "<-" is unnecessary
13:00:27 <merijn> See my annotation of your example: http://hpaste.org/47942#a47948
13:01:11 <merijn> But if all your lines contain Int's it is much nicer to use map to turn the String list into an Int list, instead of doing it one item at a time
13:01:20 <xplat> heh, someone should do a read instance for IO
13:01:32 <merijn> (That's what my other example http://hpaste.org/47949 does)
13:03:50 <Maxikq> The last statement in a 'do' construct must be an expression:
13:04:08 <Maxikq> when i've tried your annotation
13:04:32 <merijn> Hmm, I'm not sure I did the let right inside the do annotation
13:04:49 <merijn> Someone else would have to check :p
13:05:31 <Maxikq> without in
13:05:33 <Maxikq> it shoul de
13:05:37 <Maxikq> it should be
13:06:01 <monochrom> delete "in"
13:06:16 <Maxikq> i've just written that;p
13:06:17 <monochrom> (you can keep "in" but you have to change indentation)
13:06:46 <merijn> Blah, and I was so close >.>
13:06:52 <monochrom> also if the file content is like "7." you should try to read it as Double not Int
13:07:02 <monochrom> > (7.) :: Int
13:07:03 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:07:03 <lambdabot>         against inferred type ...
13:07:07 <monochrom> will not work
13:07:16 <monochrom> > 7. :: Int
13:07:16 <lambdabot>   <no location info>: parse error on input `::'
13:07:30 <monochrom> > read "7." :: Int
13:07:31 <lambdabot>   *Exception: Prelude.read: no parse
13:07:58 <Maxikq> maybe i should try takeWhile (/= '.') smth
13:08:30 <monochrom> read as Double, use "floor" or something to get Int, if you are hell-bent to have Int
13:08:48 <merijn> Maxikq: That'd work too
13:08:51 <monochrom> I would just keep everything as Double since that's the usual intention of the notation "7."
13:08:52 <Maxikq> read "7." :: Double
13:08:59 <Maxikq> > read "7." :: Double
13:09:00 <monochrom> > read "7." :: Double
13:09:00 <lambdabot>   *Exception: Prelude.read: no parse
13:09:00 <lambdabot>   *Exception: Prelude.read: no parse
13:09:07 <merijn> monochrom: Well, if all his lines end with . he might as well do something like "takeWhile" as he suggested :)
13:09:07 <monochrom> oh, sorry, nevermind then
13:09:12 <Maxikq> i;ve done it
13:09:14 <Maxikq> (takeWhile (/= '.') (ln !! 0))
13:09:19 <Maxikq> read (takeWhile (/= '.') (ln !! 0))
13:09:40 <Maxikq> > read (takeWhile (/= '.') ("10." !! 0))
13:09:41 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
13:09:41 <lambdabot>         against inferred ty...
13:10:04 <Maxikq> > read (takeWhile (/= '.') (['1', '0', '.'] !! 0))
13:10:05 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
13:10:05 <lambdabot>         against inferred ty...
13:10:21 <Maxikq> nvmd ;p
13:10:21 <merijn> Nicer (but only works if all lines are Ints, so with last line being a list it won't work): map (read . takeWhile (/= '.')) ln
13:10:49 <merijn> > map (read . takeWhile (/= '.')) ["10.", "19.", "1.", "7."]
13:10:51 <lambdabot>   [*Exception: Prelude.read: no parse
13:10:58 <merijn> pffft
13:11:08 <merijn> > map (read . takeWhile (/= '.')) ["10.", "19.", "1.", "7."] :: [Int]
13:11:09 <Maxikq> yeap i've asked about tuples about 2h earlier :D i'll try know do whole thing
13:11:09 <lambdabot>   [10,19,1,7]
13:12:52 <Eliel> Is there a way to make a function that takes another function plus the same number of strings as the given function has parameters, then tries to call read on each of those strings and apply them to the given function?
13:13:20 <ben> for a fixed number of parameters that sounds relatively straightforward
13:13:22 <merijn> Eliel: You mean a function with a variable number of arguments (like C's printf)?
13:13:26 <Eliel> yes
13:13:32 <Eliel> variable number
13:13:37 <ben> Have you looked at haskell's printf? :)
13:13:43 <Eliel> uhm, no
13:13:48 <kmc> Eliel, what's the type of your desired function?
13:13:51 <merijn> It's possible, but not entirely simple
13:14:00 <merijn> Haskell's printf does that, though
13:14:03 <ben> It's in Text.Printf or something and has a bunch of typeclass magic and is probably not a good plan for imitation
13:14:05 <kmc> you can't really make one function that does it
13:14:07 <merijn> @hoogle printf
13:14:07 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
13:14:08 <lambdabot> module Text.Printf
13:14:08 <lambdabot> Text.Printf class PrintfArg a
13:14:14 <kmc> you can make a family of functions, using type classes
13:14:16 <Eliel> kmc: I find myself having a difficult time making up a type for it :)
13:14:20 <ben> It's probably easier than printf since you know a type instead of having to parse a string at runtime
13:14:35 <mauke> ben: but now you have to parse a type at compile time
13:14:42 <ben> mauke: yeah, sure
13:15:05 <ben> Maybe you could do something where you use a `applyWithRead` operator (with a shorter name) in front of every parameter and save yourself some type magic
13:15:11 <kmc> printf is just a bad fit for Haskell.  if you specify formats using typed combinators rather than [Char], you don't need these hacks
13:15:14 <ben> similarly to all the `ap` stuff
13:15:28 <ben> but printf is so terse :V
13:15:30 <mauke> typed combinators are bad hacks for format strings
13:15:34 <merijn> kmc: That's because we don't have dependent types yet :p
13:15:44 <kmc> ...
13:15:46 <kmc> ?
13:15:53 <ben> Can we have a template haskell compile time printf function that translates into a bunch of typed combinators?
13:15:54 <kmc> you don't need dependent types for well-typed combinator printf
13:15:59 <mauke> ben: yes
13:16:10 <kmc> @quote stark
13:16:10 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
13:16:13 <Eliel> what I actually want to make is a function that takes a constructor plus urls that are links to json objects, fetches the urls, parses them to suitable types with Aeson and then applies the results to the constructor.
13:16:19 <Eliel> but I thought to start simple :P
13:16:22 <merijn> kmc: No, but if you have it then it wouldn't be such a bad fit anymore :p
13:16:27 <kmc> i think it still is
13:17:11 <merijn> I was somewhat expecting "@quote stark" to come back with "Winter is coming." :>
13:17:17 <ben> heh
13:17:37 <kmc> ;P
13:18:01 <Maxikq> merijn: yeah! i've done finally reading datas from file and everything works great
13:18:02 <identity_> what is the advantage of using Network.accept vs. Network.Socket.accept?
13:18:10 <merijn> Maxikq: :)
13:18:13 <identity_> As in, does either give an advantage?
13:18:28 <hpc> identity_: what are the types of those two?
13:18:29 <merijn> identity_: Less typing for the former? (Wild ass guess)
13:18:48 <mauke> :t Network.accept
13:18:48 <lambdabot> Network.Socket.Socket -> IO (GHC.IO.Handle.Types.Handle, Network.Socket.HostName, Network.Socket.Internal.PortNumber)
13:18:55 <Maxikq> merijn: thousand beers for you :)
13:19:03 <mauke> :t Network.Socket.accept
13:19:04 <lambdabot> Network.Socket.Socket -> IO (Network.Socket.Socket, Network.Socket.Internal.SockAddr)
13:19:19 <merijn> Maxikq: That's not gonna improved the C code I'm writing right now >.>
13:19:34 <identity_> I do want to be able to set the buffering of the socket which I can do with the handle
13:19:37 <identity_> can I do that with the socket?
13:19:45 <identity_> I can't use send on a handle
13:19:49 <merijn> identity_: Probably with the call that opens the socket?
13:19:56 <identity_> hmm
13:19:59 <mauke> what do you mean by "set the buffering"?
13:20:03 <Maxikq> thanks for help and for your patient :) oh you can divide it for whole year:P
13:20:15 <Alan1> I'm fairly new at Haskell ... how do I turn --> lst = fst (head (tail [(5,'b'),(1,'c')])) <-- into a function where I can put in my own pairs of strings
13:20:20 <hpc> identity_: sockets are lower-level than handles; i suspect they are unbuffered
13:20:32 <identity_> ah
13:20:43 <mauke> Alan1: what strings?
13:20:45 <Cale> Alan1: lst x = fst (head (tail x))
13:20:51 <Cale> ?
13:20:52 <hpc> Alan1: there's a definition of function composition in the prelude that goes something like
13:20:54 <parcs> identity_: http://hackage.haskell.org/packages/archive/network/2.3.0.4/doc/html/src/Network.html
13:21:00 <hpc> (f . g) x = f (g x)
13:21:10 <hpc> so yours would be lst = fst . head . tail
13:21:15 <parcs> er, that was supposed to contain the fragment that points to the definition of accept
13:21:27 <Maxikq> merijn: i'll check your annotation about types for sure, but probably tomorrow, because i'm really tired today, i've been setting on haskell since morning (12h)
13:21:40 <Maxikq> sitting*
13:21:54 <Cale> Though if at all possible, you should avoid 'head' and 'tail' in favour of pattern matching. What if the list is empty?
13:21:59 <identity_> parcs: already got that up
13:22:04 <identity_> I'll stick with Network.Socket.accept
13:22:08 <parcs> identity_: well then you know the difference
13:22:15 <gwern> @wn prima facie
13:22:17 <lambdabot> *** "prima" wn "WordNet (r) 2.0"
13:22:17 <lambdabot> prima
13:22:17 <lambdabot>      adj : indicating the most important performer or role; "the
13:22:17 <lambdabot>            leading man"; "prima ballerina"; "prima donna"; "a star
13:22:17 <lambdabot>            figure skater"; "the starring role"; "a stellar role";
13:22:19 <lambdabot> [4 @more lines]
13:22:21 <gwern> @more
13:22:21 <lambdabot>            "a stellar performance" [syn: {leading(p)}, {prima(p)},
13:22:23 <lambdabot>             {star(p)}, {starring(p)}, {stellar(a)}]
13:22:25 <lambdabot>      n : used primarily as eating apples
13:22:27 <lambdabot> No match for "facie".
13:22:33 <Cale> lst (x:(u,v):xs) = u
13:22:36 <hpc> @wn "prima facie"
13:22:37 <lambdabot> *** "prima facie" wn "WordNet (r) 2.0"
13:22:37 <lambdabot> prima facie
13:22:37 <lambdabot>      adj : as it seems at first sight; "a prima facie case of murder"
13:22:37 <lambdabot>      adv : at first sight
13:22:43 <Cale> gwern: ???
13:22:53 <gwern> Cale: just mkaing sure I was using it right
13:23:03 <tristes_tigres> So, if nested datatypes represent a generic datatype with some restriction imposed ... How do you go about transforming them back into generic datatype?
13:23:05 <Maxikq> merijn: now i'm going to take a rest, thank you once again : ) see ya
13:23:12 <Alan1> thanks Cale
13:23:28 <Cale> Alan1: no problem :)
13:23:46 <Cale> Alan1: So this makes it obvious that there are a couple more cases which are possible but not being handled
13:23:48 <xplat> prima facie love
13:23:54 <Cale> lst [] = ...
13:24:04 <tristes_tigres> Should I look into "generalized folds", or there's some simpler explanation?
13:24:05 <Cale> lst [(u,v)] = ...
13:24:14 <Cale> (the case of 0 or 1 element lists)
13:24:40 <Cale> tristes_tigres: hmm...
13:24:54 <Cale> tristes_tigres: I mean, I guess you could put all the constructors in the same datatype?
13:25:08 <Cale> tristes_tigres: and just make it directly recursive?
13:25:15 <Cale> (rather than mutually recursive)
13:25:33 <Cale> At least, if I understand the question :)
13:25:55 <tristes_tigres> Cale: I mean, I have some nested datype value, and I want o compute corresponding generic value
13:27:23 <tristes_tigres> That is, if I have data Tree23 a = Zero a | Succ (Tree2 (Node a)); data Node a = Node2 a a
13:27:34 <parcs> what is a generic value?
13:27:45 <tristes_tigres> and just want to write a function convert :: Tree2 a -> Tree a
13:28:36 <tristes_tigres> data Tree a = Leaf a | Node (Tree a) (Tree a)
13:28:56 <tristes_tigres> So Tree2 has to be balanced, but Tree does not
13:29:35 <tristes_tigres> Tree 2 is a restriction on Tree
13:30:58 <Cale> ah, okay, so you probably want a typeclass for this... because you're going to end up with Tree2's at more and more complicated types which need to be converted back...
13:31:12 <Cale> er, hmm
13:31:25 <Cale> Just trying to think if there's an obvious way to do without that.
13:31:42 <mauke> convert (Zero a) = Leaf a; convert (Succ t) = fixup (convert t); fixup (Leaf (Node2 x y)) = Node (Leaf x) (Leaf y); fixup (Node x y) = Node (fixup x) (fixup y)
13:31:59 <ddarius> It should be a SMOPR.
13:32:07 <Cale> SMOPR?
13:32:27 <ddarius> "simple matter of polymorphic recursion"
13:32:41 <Cale> standard
13:32:46 <tristes_tigres> What is a good intro into polymorphic recurion?
13:33:05 <lispy> ?hoogle catch
13:33:05 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
13:33:05 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
13:33:05 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
13:33:20 <tristes_tigres> mauke: thnks
13:34:27 * hackagebot snap-core 0.5.0 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.5.0 (GregoryCollins)
13:34:46 <Cale> That on its own doesn't typecheck?
13:35:24 <ski> you need type signatures with polymorphic recursion
13:35:29 * hackagebot Yogurt 0.4.1 - A MUD client library  http://hackage.haskell.org/package/Yogurt-0.4.1 (MartijnVanSteenbergen)
13:35:35 <sorje> Is there some haskell-natural way to make a Tree2 a "subtype" of Tree?
13:36:11 <Cale> What's a subtype? ;)
13:37:27 * hackagebot snap-server 0.5.0 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.5.0 (GregoryCollins)
13:37:29 * hackagebot snap 0.5.0 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.5.0 (GregoryCollins)
13:37:57 <ski> sorje : Haskell doesn't have subtypes
13:38:14 <sorje> sub as in subset. Every Tree2 is supposed to be a Tree too, by simply forgetting the extra structure
13:38:43 <Cale> That would defeat the purpose of the Tree2 type by allowing non-balances trees in it.
13:38:50 <Cale> balanced*
13:38:59 <Cale> (If you made them the same type)
13:39:10 <sorje> No, that's not what I meant (and said, I think)
13:39:27 <tristes_tigres> Every Tree2 is a subset of Tree
13:39:34 <sorje> ski, ok
13:39:56 <Cale> If Zero is a constructor of Tree2, then it can't be a constructor of Tree unless Tree2 = Tree
13:40:07 <tristes_tigres> but not vice versa. Therefore, Tree2 is a restriction of Tree
13:40:22 <sorje> (I'd like to see a construction that gives you a forgetful functor Tree2 -> Tree)
13:40:34 <Cale> Sure, that's what tristes_tigres is trying to write
13:40:57 <Cale> (it's a natural transformation :)
13:41:38 <hpc> perhaps you could use a phantom type, and smart constructors?
13:41:40 <ski> sorje : there's something called "refinement types", which possibly could give you what you want
13:41:44 <sorje> (between what functors?)
13:41:45 <hpc> data Balanced; data Unbalanced
13:41:53 <hpc> data Tree b a = ...
13:42:02 <Cale> sorje: Tree2 and Tree
13:42:06 <hpc> emptyBalanced :: Tree Balanced a
13:42:18 <ski> e.g. "Refinement Types for ML" by Tim Freeman,Frank Pfenning at <http://www.cs.cmu.edu/~fp/papers/pldi91.pdf>
13:42:18 <sorje> Cale: Oh, I have thought of those as Categories ;-)
13:42:36 <Cale> Tree2 and Tree are both endofunctors on the category of Haskell types
13:42:55 <tristes_tigres> mauke: your solution doesn't compile
13:43:08 <ski> tristes_tigres : did you add type signatures ?
13:43:27 <cheater_> tristes_tigres, knowing mauke you're probably missing a thousand language extensions :p
13:43:42 <mauke> cheater_: what
13:43:42 <ski> cheater_ : polymorphic recursion is not a language extension
13:44:11 <sorje> Cale: I still prefer thinking of them as categories ;-)
13:44:12 * cheater_ goes to read up on polymorphic recursion
13:44:28 <tristes_tigres> cheater: complains about inability to construct infinite type
13:44:34 <ski> (polymorphic recursion is supported in Haskell98)
13:44:50 <ski> tristes_tigres : well, *did* you add type signatures, or not ?
13:44:50 <hpaste> “Cale (really mauke)” pasted “convert” at http://hpaste.org/47950
13:45:21 <sorje> ski: nice article, thanks. I suppose it's not something that's implemented in haskell?
13:45:21 <ddarius> @let (a:as) /\/ bs = a:(bs /\/ as)
13:45:22 <lambdabot>  Defined.
13:45:26 <Cale> tristes_tigres: You need to add all the type signatures, since they can't be inferred
13:45:40 <Cale> sorje: What are the objects and arrows?
13:45:46 <ski> ddarius : no base case ? :)
13:45:57 <tristes_tigres> Cale: I see. What is a good intro into polymorphic recursion?
13:46:02 <ddarius> ski: I'm only considering streams.
13:46:06 <mauke> Cale: fixup doesn't need a signature
13:46:06 <sorje> Cale: Objects are instances of trees and arrows are whatever operation you want to define on them
13:46:11 <ski> sorje : no. but maybe if there's enough demand, it could be
13:46:26 <sorje> +s
13:46:36 <ski> (or maybe there's some problems, possibly interacting with other features, that i'm not aware of)
13:46:40 <ddarius> > zip [0..] (fix (\pot -> True:(pot /\/ repeat False)))
13:46:41 <lambdabot>   [(0,True),(1,True),(2,False),(3,True),(4,False),(5,False),(6,False),(7,True...
13:46:59 <Cale> sorje: I suppose every Haskell datatype is a category in another way: the objects are values, and there is exactly one arrow x -> y whenever y is more defined than x
13:47:03 <ddarius> > zip [1..] (fix (\pot -> True:(pot /\/ repeat False)))
13:47:04 <lambdabot>   [(1,True),(2,True),(3,False),(4,True),(5,False),(6,False),(7,False),(8,True...
13:48:23 <sorje> Cale: sorry, I wasn't aware of any conventions
13:48:25 <ski> > fix $ \bs -> cycle [0,1] /\/ bs
13:48:26 <lambdabot>   [0,0,1,0,0,1,1,0,0,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,1,0,0,...
13:48:52 <ski> ddarius : is that any wellknown sequence ?
13:49:01 <ddarius> ski: Which?
13:49:03 <ski> yours
13:49:36 <ski> (mine is related to kronecker symbol, iirc)
13:49:40 <ddarius> ski: You can already start to see the pattern, alternatively you could calculate it.
13:50:45 <ski> .. oh
13:51:47 <ski> writing it as `fix $ \pot -> (True : repeat False) /\/ pot' makes it easier to see what's going on
13:51:53 <ski> (for me, at least)
13:52:04 <tristes_tigres> What is the reason why the type of "convert" can not be inferred
13:52:40 <ski> tristes_tigres : because it uses polymorphic recursion, because you're using a nested / non-regular datatype
13:53:35 <ion> > fix $ \☺ -> ('a' : repeat ' ') /\/ ☺
13:53:36 <lambdabot>   <no location info>: parse error on input `\
13:53:39 <kstt> in case of interest, I'm in #postgresql talking about mapping algebraic data types to sql tables
13:53:41 <ski> (i suppose not every recursion function matching on a non-regular type has to use polymorphic recursion, but i'd expect them to use it in most cases, still)
13:53:55 <ion> > fix $ \meh -> ('a' : repeat ' ') /\/ meh
13:53:56 <lambdabot>   "aa a   a       a               a                               a          ...
13:54:27 <ion> > fix $ \meh -> ('a' : 'b' : repeat ' ') /\/ meh
13:54:28 <lambdabot>   "aaba b a   b   a       b       a               b               a          ...
13:55:35 <ddarius> kstt: Figure out a nice way of doing Either A B and the rest is easy.
13:55:52 <ddarius> At least for the polynomial subset.
13:56:35 <identity_> Could someone explain the purpose of dupChan? I don't get why you would need to duplicate channels as it is described.. Why not just pass the channel around without duplicating it? Doesn't that do the same thing?
13:57:04 <ben> If you put something in a channel that has been dupped, a copy of it shows up in every duplicate iirc
13:57:06 * ski thinks "Modelling Large Datasets Using Algebraic Datatypes: A Case Study of the CONFMAN Database" <http://www.ocaml.info/oefai/reports/TR-2002-27/> and "Using Algebraic Datatypes as Uniform Representation for Structured Data" <http://www.ocaml.info/oefai/papers/algebraic_dts/> by Markus Mottl might be interesting for kstt
13:57:27 <sam5> Can someone help me with a code?
13:57:34 <identity_> ben: Aye, I get that much, but why duplicate it? If you pass it to your threads without duplicating it, they get everything you put in it as well
13:57:35 <sam5> list :: Int -> [Int] -> [Int]
13:57:43 <kstt> thank you ski
13:58:12 <sam5> I'm trying to make a function
13:58:16 <ski> > fix $ \abacaba -> repeat 'a' /\/ map succ abacaba
13:58:18 <lambdabot>   "abacabadabacabaeabacabadabacabafabacabadabacabaeabacabadabacabagabacabadab...
13:58:18 <sam5> that takes in a base number and a list
13:58:31 <ski> > fix $ \abacaba -> repeat 0 /\/ map succ abacaba
13:58:33 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,...
13:58:42 <sam5> and want to make a list of the base number ^ each number in the list
13:59:22 <ion> > let list base = map (base^) in list 2 [0..5]
13:59:23 <lambdabot>   [1,2,4,8,16,32]
14:00:29 <sam5> oh I see...
14:00:39 <ski> > map (fix $ \loop n -> let (n',r) = n `divMod` 2 in if r /= 0 then 0 else 1 + loop n') [1 ..]
14:00:40 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,...
14:01:28 <Saizan> identity_: do c <- newChan; d <- return c; writeChan c 1; writeChan c 2; liftM2 (,) (readChan c, readChan d) <- this will return (1,2)
14:01:42 <Saizan> identity_: do c <- newChan; d <- dupChan c; writeChan c 1; writeChan c 2; liftM2 (,) (readChan c, readChan d) <- this will return (1,1)
14:02:46 <identity_> Saizan: ah. So writing to one changes both, reading from one changes one
14:02:48 <identity_> I see
14:03:23 <tristes_tigres> Is it true that an explicit type signature must always be more restrictive than the inferred one?
14:04:01 <ion> :t show
14:04:02 <lambdabot> forall a. (Show a) => a -> String
14:04:07 <ion> :t show :: (Show a) => a -> String
14:04:08 <lambdabot> forall a. (Show a) => a -> String
14:04:14 <ion> Equally restrictive is just fine.
14:04:23 <parcs> :t id :: a -> a
14:04:24 <lambdabot> forall a. a -> a
14:04:56 <tristes_tigres> more or equally restrictive, I mean
14:05:09 <identity_> tristes_tigres: I think the inferred type is always the least restrictive type possible
14:05:24 <ion> How would, say, show :: a -> String work?
14:05:39 <Saizan> most likely true for haskell2010, some extensions might break that
14:05:57 <ion> Except for const "foo", it can’t do much.
14:06:19 <merijn> ion: What do you mean?
14:06:44 <tristes_tigres> identity_: But the report says : "a type signature can be used to specify a type more general than the one that would be inferred"
14:06:45 <Saizan> then even in haskell98 there are cases where a type signature is required for the code to typecheck
14:06:53 <identity_> tristes_tigres: What ion is getting at is that (show :: a -> String) is useless because show needs a type a that is an instance of the Show typeclass to be able to show it.
14:06:57 <identity_> tristes_tigres: Huh
14:06:58 <danharaj> monomooorphism restriiccctioononnnn
14:07:00 <identity_> tristes_tigres: Guess I may be wrong then
14:07:03 <merijn> ion: Oh, without the (Show a). Yeah, then it can't do much more then const "foo" :p
14:07:33 <tristes_tigres> identity_: What you said was what I thought until now
14:08:19 <identity_> At any rate, like ion said, your explicit type signature can be equally restrictive as the inferred one(and possibly more general according to that report, apparently)
14:08:53 <tristes_tigres> identity_: more general == less restrictive
14:09:01 <identity_> aye
14:09:14 <Saizan> the monomorphism restriction means that in a module like "foo = show; bar = foo 'a'" the inferred type for foo is Char -> String
14:09:24 * tristes_tigres watches as his illusion of understanding Haskell crumbles
14:09:38 <ddarius> It's possible, as danharaj has said, that the inferred type is less general than an explicit type you could provide.  Also, for interest, I believe it's possible to have inferred types that can't be written explicitly.
14:09:40 <Saizan> so you can indeed make it more general with "foo :: Show a => a -> String; foo = show; bar = foo 'a'"
14:11:05 <ski> > fix $ \ns -> 0 `unifyHead` ns /\/ map succ ns
14:11:07 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
14:11:41 <ski> (ddarius : yes, it's possible)
14:11:42 <augur> why am i getting parse errors on a where inside of an instance declaration? :|
14:11:52 <ski> paste code ?
14:12:18 <danharaj> augur: probably improper indentation. GHC gives the most unhelpful parse errors.
14:12:25 <tristes_tigres> ddarius: How is it possible to have  inferred types that can't be written explicitly ?
14:12:32 <augur> http://hpaste.org/47952
14:12:44 <Saizan> (for a while it was even possible to have inferred types that when written explicitly would give a type error)
14:12:55 <augur> hpaste has somehow messed up my tabs :|
14:13:13 <danharaj> tabs = 8 spaces
14:13:19 <tristes_tigres> Saizan: That would seem to indicate that type system is somewhat pathological
14:13:22 <lispy> tabs in haskell == madness
14:13:27 <Saizan> augur: maybe using tabs is your problem
14:13:33 <ski> augur : the clauses for `ortho' are not aligned
14:13:37 <augur> Saizan: maybe!
14:13:39 <lispy> layout + tabs = huh?
14:13:57 <Saizan> tristes_tigres: i'd say it was a bug of ghc
14:14:00 <lispy> symbols + words = cryptic messages
14:14:25 <ski> augur : if you use tabs, then it's a good idea to always break line after layout-introducing keywords, i.e. `let',`where',`of',`do'
14:15:48 <ddarius> > fix ([1..] /\/)
14:15:49 <lambdabot>   [1,1,2,1,3,2,4,1,5,3,6,2,7,4,8,1,9,5,10,3,11,6,12,2,13,7,14,4,15,8,16,1,17,...
14:15:55 <ski> tristes_tigres : you can have an inner definition in a `where' or `let' whose type has to refer to a nonlocal type variable. Haskell98 doesn't let you write the type signature in such cases (GHC and Hugs does though, with extensions)
14:16:04 <Tomsik> :t /\/
14:16:05 <lambdabot> parse error on input `/\/'
14:16:08 <Tomsik> :t (/\/)
14:16:08 <lambdabot> forall t. [t] -> [t] -> [t]
14:16:13 <Tomsik> what the hell is it
14:16:27 <Tomsik> @src (/\/)
14:16:28 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:16:34 <sam5> in haskell
14:16:35 <identity_> > "foo" /\/ "bar"
14:16:35 <ski> Saizan : more like a bug in the language spec, no ?
14:16:36 <lambdabot>   "fboaor"
14:16:48 <mauke> > [a,b,c] /\/ [x,y,z]
14:16:49 <lambdabot>   [a,x,b,y,c,z]
14:16:50 <danharaj> :t / \ /
14:16:51 <lambdabot> parse error on input `/'
14:17:05 <sam5> is there a function that shrinks all the duplicates in a list ????
14:17:11 <ski> Tomsik : `@let infixr 5 /\/; [] /\/ bs = bs; (a:as) /\/ bs = a:(bs /\/ as)'
14:17:12 <gwern> huh. I didn't even know anyone was working on SafeHaskell, much less that it was done
14:17:26 <gwern> sam5: sure, `nub`. only handles consecutive duplicates though
14:17:27 <Tomsik> sam5: nub, although it's slow
14:17:37 <ski> > nub "banana"
14:17:38 <lambdabot>   "ban"
14:17:41 <pedro3005> i wonder why haskell seems to have some completely random std functions
14:17:55 <ski> gwern : not just consecutive ones ..
14:18:02 <danharaj> pedro3005: like what?
14:18:13 <pedro3005> like that one
14:18:20 <gwern> pedro3005: fans of the random function on the committee, the remit as the unification of all lazy FP langs, etc
14:18:27 <danharaj> How is nub random? Wouldn't you like to remove duplicates in a list sometimes?
14:18:29 <gwern> ski: oh. that must be Unix's sort I was thinking of
14:18:50 <pedro3005> not nub, /\/
14:18:54 <danharaj> oh
14:18:55 <sam5> Oh I see
14:18:59 <danharaj> that's not in the standard library
14:19:04 <ski> pedro3005 : `(/\/)' is not a standard function
14:19:11 <sam5> so for instance, [1, 2, 2, 4, 2] will become [1, 2, 4, 2]?
14:19:16 <sam5> if you call nub?
14:19:23 <danharaj> > nub [1,2,2,4,2]
14:19:23 <lambdabot>   [1,2,4]
14:19:25 <ski> pedro3005 : i think "Haskell: The Craft of Functional Programming" defines it, though
14:19:45 <hpc> > map head . group [1, 2, 2, 4, 2]
14:19:46 <lambdabot>   No instance for (GHC.Num.Num [a])
14:19:47 <lambdabot>    arising from a use of `e_112242' at <i...
14:19:59 <hpc> > map head . group $ [1, 2, 2, 4, 2]
14:20:01 <lambdabot>   [1,2,4,2]
14:20:05 <ski> sam5 : the first instance of every element is kept, every consecutive instance is removed
14:20:12 <ski> @src nub
14:20:12 <lambdabot> nub = nubBy (==)
14:20:15 <ski> @src nubBy
14:20:15 <lambdabot> nubBy eq []             =  []
14:20:16 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
14:20:23 <danharaj> I call (x . y . z $ a) "Dot dot goose"
14:20:58 <danharaj> > repeat 1 /\/ repeat 2
14:21:00 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
14:21:36 <danharaj> > [1,3..]  /\/ [2,4..]
14:21:38 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:21:52 <danharaj> Huh. I swore interleave was a prelude function.
14:22:01 <hpc> @src interleave
14:22:01 <lambdabot> Source not found. My brain just exploded
14:22:06 <hpc> :t interleave
14:22:06 <pedro3005> > nubBy (>) [1..10]
14:22:06 <lambdabot> forall (m :: * -> *) a. (MonadLogic m) => m a -> m a -> m a
14:22:07 <lambdabot>   [1]
14:22:08 <tristes_tigres> OK, thanks for the helpful discussion
14:22:20 <hpc> > interleave [1..5] [2..6]
14:22:20 <lambdabot>   [1,2,2,3,3,4,4,5,5,6]
14:22:28 <hpc> @hoogle interleave
14:22:28 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
14:22:28 <lambdabot> Control.Monad.ST unsafeInterleaveST :: ST s a -> ST s a
14:22:28 <lambdabot> Control.Monad.ST.Lazy unsafeInterleaveST :: ST s a -> ST s a
14:22:35 <hpc> huh
14:22:55 <ski> @hoogle+
14:24:29 <pedro3005> I had to use numbers in base 26 the other day in a program. So I thought I'd represent it as an [Int]. then made this function for converting one to base 10
14:24:32 <pedro3005> convert10 num base = sum $ map (uncurry (*)) (zip (map (base ^) [0..]) num)
14:24:44 <ion> Is there a name for the practice of calling the local helper function “go”? How did that specific word become the one used by everyone?
14:24:48 <pedro3005> I wonder if representing it as an [Int] is not the best way or if there's a better way to convert
14:24:56 <danharaj> ion: I use worker, or aux.
14:24:58 <Elvish_Pillager> Bahaha! Just released a first version of my Haskell game at www.elidupree.com! (It's pretty rudimentary right now, but I love that I could make complex 2D collision detection at a reasonable speed)
14:25:05 <merijn> ion: I remember a mailing list thread about this
14:25:40 <merijn> ion: The answer is mostly, because it is a convention in the GHC source. And it is a convention there because Simon Marlow (I think) likes to use it and thinks go is a nice short name
14:25:51 <ion> > let f base = foldl' (\acc n -> base*10 + n) 0 in f 10 [1..4]
14:25:52 <ski> > (uncurry (/\/) . (snd &&& fst) . halves) [0 ..]
14:25:52 <danharaj> Elvish_Pillager: You should host your project on github.
14:25:52 <lambdabot>   104
14:25:53 <lambdabot>   [1,0,3,2,5,4,7,6,9,8,11,10,13,12,15,14,17,16,19,18,21,20,23,22,25,24,27,26,...
14:25:56 <ion> uh
14:26:05 <ion> > let f base = foldl' (\acc n -> acc*base + n) 0 in f 10 [1..4]
14:26:06 <lambdabot>   1234
14:26:22 <Elvish_Pillager> danharaj: Sorry if this sounds like a total noob question, but, what's github? :o
14:26:36 <ion> merijn: Ok, thanks :-)
14:27:17 <danharaj> Elvish_Pillager: Do you know what version control is?
14:27:34 <sshc> Why does "unsafe" block all other threads while "safe" with -threaded doesn't?  This seems counter-intuitive, since "safe" is used when the foreign import might call back into haskell code, and "unsafe" can (but doesn't have to) be used for efficiency otherwise: wouldn't that make "safe" more efficient?
14:27:38 <Elvish_Pillager> danharaj, yes
14:28:12 <ion> pedro3005: See above.
14:28:24 <merijn> Elvish_Pillager: Git is a distributed version control system and GitHub is a site that provides (free, for open source code) hosting for said repositories
14:28:47 <danharaj> ^ yes. Also it makes it easy for people to fork your project, send you patches, etc.
14:29:09 <pedro3005> > let f base = foldl' (\acc n -> acc*base + n) 0 in f 11 [1..4]
14:29:09 <ski> > (fix $ \loop -> uncurry (:) . second (uncurry (/\/) . (loop . snd &&& loop . fst) . halves) . unCons) [1 ..]  -- hm
14:29:10 <lambdabot>   1610
14:29:11 <lambdabot>   [1,3,2,7,6,5,4,15,14,13,12,11,10,9,8,31,30,29,28,27,26,25,24,23,22,21,20,19...
14:29:23 <pedro3005> > let f base = foldl' (\acc n -> acc*base + n) 0 in f 11 [11]
14:29:24 <lambdabot>   11
14:29:37 <merijn> Elvish_Pillager: If your not currently using a distributed version control system, I can highly recommend switching to one. (Personally I prefer Mercurial, but whether you use Git or that doesn't matter)
14:29:48 <Elvish_Pillager> danharaj, merijn: checking out gitHub now
14:29:48 <merijn> As long as it isn't svn :>
14:30:26 <jrick> mercurial's nicer :|
14:30:48 <danharaj> to be honest I'd prefer darcs but github is popular.
14:30:49 <ddarius> danharaj: You're probably thinking of intersperse or maybe intercalate.
14:31:06 <jrick> haven't tried darcs
14:31:09 <jrick> yet
14:31:15 <danharaj> ddarius: probably.
14:31:30 <danharaj> To be honest I don't think the VCS you use is that important, just as long as it doesn't give you a headache.
14:32:13 <merijn> jrick: That's why they invented hg-git ;)
14:33:15 <augur> how do you pattern match different record constructors?
14:33:18 <Elvish_Pillager> blah blah blah, github's terms of service are boring and stupid
14:33:31 <mauke> separately
14:33:32 <augur> like.. data Foo = Bar { ... } | Baz { ... }
14:33:43 <augur> if i want to separate these cases, what would i do?
14:33:51 <augur> f :: Foo -> a
14:33:52 <danharaj> case foo of ...
14:33:54 <augur> f (Bar x) ?
14:34:26 <augur> or is id f (Bar {...}) ?
14:34:39 <mauke> huh?
14:34:44 <mauke> I don't get the problem
14:35:06 <augur> mauke: suppose i have data Foo = Bar { a :: String, b :: Int } | Baz { a :: String, b :: Int }
14:35:13 <augur> what do the patterns look like in a pattern match?
14:35:59 <ion> f :: Foo -> …; f (Bar a b) = …; f (Baz a b) = …
14:36:00 <mauke> Bar{}, Bar s i, Bar{ a = s }, Bar{ b = i }, Bar{ a = s, b = i }
14:36:16 <hpc> foototuple (Bar{a = a, b = b}) = (a,b)
14:36:23 <danharaj> Record syntax is sugar, you can pattern match them as regular data constructors
14:36:25 <hpc> or ion's pattern
14:36:32 <augur> ok, ill give that a go
14:36:41 <hpc> you can also record-match on regular data types too
14:36:48 <spuz> if I have a list of tuples say [(1, 4), (2, 9), (4, 2)], how can I find the tuple with the largest second element in that list?
14:36:56 <hpc> > let isLeft (Left{}) = True in isLeft (Left 5)
14:36:57 <lambdabot>   True
14:37:04 <spuz> in this case, (2, 9)
14:37:15 <parcs> augur: also check out the neat language extensions for pattern matching against a record
14:37:16 <hpc> :t maximumBy
14:37:17 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
14:37:35 <hpc> > maximumBy (comparing `on` snd) [(1, 4), (2, 9), (4, 2)]
14:37:36 <lambdabot>   Occurs check: cannot construct the infinite type: b = b -> a
14:37:44 <hpc> > maximumBy (snd `on` comparing) [(1, 4), (2, 9), (4, 2)]
14:37:45 <lambdabot>   Occurs check: cannot construct the infinite type: b = (a, b) -> c
14:37:52 <hpc> > maximumBy (comparing snd) [(1, 4), (2, 9), (4, 2)]
14:37:53 <lambdabot>   (2,9)
14:38:06 <ion> @src comparing
14:38:06 <lambdabot> Source not found. You untyped fool!
14:38:11 <spuz> hpc: thanks
14:38:21 <hpc> comparing x = x `on` compare -- or something like that
14:38:23 <hpc> @src on
14:38:23 <lambdabot> (*) `on` f = \x y -> f x * f y
14:38:35 <hpc> compare `on` x
14:38:39 <parcs> are there any record-based data types exposed to lambdabot?
14:38:40 <ion> compare `on` x, yes
14:39:15 <identity_> given something like: liftM (map read . lines) $ readFile "somefile" .. how would I force this to be read and parsed immediately instead of waiting for it to be used?
14:39:26 <identity_> Using seq or whatever
14:39:59 <mauke> evaluate (length xs)
14:40:35 <ski> > (fix $ \loop -> id `perCons` onHalves ((loop *** loop) . swap)) [1 ..]
14:40:37 <lambdabot>   [1,3,2,7,6,5,4,15,14,13,12,11,10,9,8,31,30,29,28,27,26,25,24,23,22,21,20,19...
14:40:48 <ski> parcs : `Tree'
14:40:49 <Elvish_Pillager> merijn: I'm having trouble convincing myself to switch to a distributed version control system. Do you have clever arguments?
14:41:01 <ski> @type Node
14:41:02 <lambdabot> forall a. a -> Forest a -> Tree a
14:41:04 <merijn> Elvish_Pillager: What are you using right now?
14:41:05 <ski> @type rootLabel
14:41:06 <lambdabot> forall a. Tree a -> a
14:41:09 <ski> @type subForest
14:41:10 <lambdabot> forall a. Tree a -> Forest a
14:41:19 <ski> > Node 0 []
14:41:19 <lambdabot>   Node {rootLabel = 0, subForest = []}
14:41:27 <Elvish_Pillager> merijn: Right now I'm not using anything. I just have source files that I edit and occasionally make deliberate backups of.
14:41:57 <merijn> Elvish_Pillager: In that case the main argument is that they're freaking simple to use and so very useful
14:42:27 <Elvish_Pillager> merijn: Where can I learn to use one of them in <15 minutes?
14:43:09 <merijn> Elvish_Pillager: I can literally create a new repository to work in with one command and start committing
14:43:43 <merijn> Elvish_Pillager: http://hginit.com/ has a nice introduction to Mercurial. Most of the basic ideas also apply to darcs/git (albeit with slightly different commands)
14:43:45 <Elvish_Pillager> merijn: yeah, but I'm in the position of not knowing how to do that and needing to learn a new system before I cna start.
14:44:37 <E0F> hi guys, is there any performance issue with GHC 7.0.2 on Linux ? I'm new to Haskell and I find the naive recursive implementation of the fibonacci sequence very slow for native code especially as compared with the C equivalent (same algorithm)
14:44:42 <merijn> That one is really basic, but then again for private projects you only need a handful of simple commands anyway :)
14:45:23 <merijn> E0F: The naive recursive implementation of fibonacci produces exponential behavior which indeed makes it terribly slow for any non-trivial number :p
14:45:41 <hpc> E0F: can you paste the code for both?
14:45:50 <merijn> That's just a matter of recursion being a sucky way to implement fibonacci, though.
14:46:44 <E0F> yes I know about that, but my point is the C equivalent is really faster and I made some research on the internet and people with similar hardware get far shorter running time
14:47:02 <mauke> E0F: can you paste the code for both?
14:47:07 <E0F> ok
14:48:42 <merijn> It's pretty easy to implement a non-recursive fibonacci in Haskell which should produce much better speed :)
14:49:17 <hpaste> merijn pasted “Non-recursive fibonacci” at http://hpaste.org/47953
14:49:26 <noteventime> Non-explicitly recursive or actually non-recursive?
14:49:51 <noteventime> ;)
14:49:56 <Cale> Not doubly recursive, I think is what's meant.
14:50:10 <noteventime> Yea, I was just being annoyin :)
14:52:03 <E0F> http://pastebin.com/X2R44wGT
14:52:05 <mauke> The paste X2R44wGT has been copied to http://hpaste.org/47954
14:52:06 <E0F> here it is
14:52:30 <E0F> i'm not looking for a non recursive uber-efficient algorithm, there are already many on the haskell wiki
14:52:35 <mauke> one major difference: your haskell code uses bigints
14:52:45 <mauke> how did you compile fibhs?
14:53:00 <Cale> E0F: You're working on Integer values. To get the same thing in C, you'll need to use GMP
14:53:08 <E0F> ghc -O2 -o fibhs fibhs.hs
14:53:27 <Cale> Try changing the type signature to Int -> Int and see what it does to the runtime
14:53:42 <merijn> E0F: My version runs in "real    0m0.012s"
14:53:57 <E0F> thank you, I'll try this I forgot about the difference
14:54:11 <hpc> @src Int
14:54:11 <lambdabot> data Int = I# Int#
14:54:14 <hpc> @src Integer
14:54:14 <lambdabot> data Integer = S# Int#
14:54:14 <lambdabot>              | J# Int# ByteArray#
14:54:24 <E0F> merijn: I'll have a look at your code it must be very instructive :)
14:54:47 <Cale> why not just:
14:54:49 <Eduard_Munteanu> Integer *is* slower, despite some people warning about "premature optimization" :)
14:54:56 <Cale> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
14:55:08 <Cale> rather than the weird where thing :)
14:55:09 <hpc> Eduard_Munteanu: premature generality, perhaps
14:55:30 <hpc> it's not often you need numbers larger than 2^64
14:55:34 <identity_> Uh.. This line: putStrLn $ hostname ++ " failed authentication with " ++ user ++ ":" ++ pass prints ":passhostname failed authentication with user". Every time I only print either the user or the pass, it works fine. if I print both, the everything following the second to last (++) is printed before everything else. o.o
14:55:36 <merijn> Cale: Oh, I remember something similar not working directly when I was doing primes. But might just be cargo cult programming by myself :p
14:55:54 <E0F> because i'm running a silly "benchmark" and I'm trying to find out why do people have faster running times with the same code and equivalent hardware
14:56:03 <Cale> I actually really hate that Int is in the prelude
14:56:13 <Cale> Sure it's faster, but it's also broken :P
14:56:20 <Eduard_Munteanu> How so?
14:56:24 <danharaj> broken or ambiguous?
14:56:49 <mdeboard> I'm having trouble conceptualizing something. I have a string 's' of length n I want to slice up into m-length bites, with overlap. In other words, I want to take m, then drop 1, then take m, then drop 1, then take m, then drop 1...until length s is 0. I'm having trouble wrapping my brain around how to handle this recursively. Can someone help?
14:56:51 <Cale> Well, it's not often that you really want to be working in the ring of integers modulo 2^n
14:57:04 <Cale> ;)
14:57:09 <merijn> E0F: Wait, the naive version has a runtime of 34s on your system?
14:57:14 <merijn> That can't be right...
14:57:16 <E0F> well it is really faster with Int
14:57:18 <danharaj> I thought overflow was undefined for Int ;)
14:57:24 <E0F> merijn: exactly !
14:57:26 <hpc> merijn: with Integer? i believe it
14:57:41 <Eduard_Munteanu> Mind that most stuff that would interface with Haskell code will rather expect integers modulo 2^n than bigints.
14:57:45 <hpc> i switched the type to Int -> Int and compiled without optimizations
14:57:49 <Eduard_Munteanu> The mindset is there.
14:57:49 <dino-> identity_: Maybe a nutty character in pass, like CR
14:57:53 <hpc> and got real    0m21.256s
14:57:58 <dino-> (but no line feed)
14:58:01 <identity_> dino-: hmm. Good idea. let me check that out
14:58:11 <identity_> Oh, no, ruled that out
14:58:11 <ski> Cale : it would be more useful if it allowed working in `|Z / (p^n * |Z)' for any prime `p' and natural number `n' ..
14:58:14 <Cale> I get 5 seconds with Integer.
14:58:19 <identity_> it doesn't matter whether I print user or pass first
14:58:22 <identity_> if I print either, it works
14:58:27 <Cale> cale@ender:~$ time ./fib
14:58:27 <Cale> 102334155
14:58:27 <Cale> real	0m5.463s
14:58:27 <Cale> user	0m5.432s
14:58:27 <Cale> sys	0m0.012s
14:58:34 <Cale> fib :: Integer -> Integer
14:58:42 <merijn> E0F: Hmm, quite slow here too. That's ridiculous >.>
14:58:46 <Cale> I'm using 7.0.3 though
14:59:02 <merijn> 38s with 7.0.2 here
14:59:17 <E0F> Cale: 5s with integer ? I've got 1,4s with Int and I have an Intel Core i7 @ 3Ghz
14:59:21 <hpc> with O2, real    0m2.817s
14:59:41 <hpc> (this is on a laptop with a core2 duo
14:59:41 <Cale> I have a core i5
14:59:44 <hpc> )
14:59:53 <Cale> 1.4 s with Int
15:00:02 <Cale> So your Integer is slower for some reason
15:00:05 <merijn> 11s with Int and no optimizations
15:00:11 <dino-> identity_: Not sure. Wondering if you can make this happen in a small, isolated example.
15:00:18 <dino-> And put on paste
15:00:18 <E0F> Dude there must be something wrong I guess, because I have 34s with Integer and full optimizations
15:00:58 <identity_> dino-: Hmm.. I don't think so, to be honest. Though my application isn't longer than 30 lines or so
15:01:12 <Cale> It might be the difference between 7.0.2 and 7.0.3, or it might be related to which version of libgmp we're using?
15:01:17 <parcs> breaking news: different processors run at different speeds
15:01:23 <hpc> i was using 6.12
15:01:25 <merijn> E0F: I go from 38s to 7s when I turn on -O2 on (with 7.0.2)
15:01:28 <Cale> parcs: Mine should be slower than his though
15:01:39 <identity_> dino-: Want me to paste it? It runs on port 1337 and to test it you merely need to telnet to locahost:1337 and type a user/pass
15:01:49 <merijn> parcs: If he is enabling O2 and his runtimes stay the same but others don't, then that's weird
15:02:00 <dino-> @paste
15:02:00 <lambdabot> Haskell pastebin: http://hpaste.org/
15:02:01 <merijn> E0F: Which compiler version are you using?
15:02:11 <Cale> He's running 7.0.2
15:02:16 <merijn> Weird
15:02:17 <E0F> merijn: 7.0.2 too with -O2 enabled
15:02:23 <dino-> identity_: Better show us more of it, I think.
15:02:31 <merijn> Same here, but I get 31s faster
15:02:35 <identity_> alright
15:02:36 <merijn> 64bit or 32bit?
15:02:37 <identity_> sec
15:02:40 <dino-> Because that line up there, how could it not work?!
15:02:41 <Cale> I get 9.6 seconds with no optimisations
15:02:53 <E0F> 64 bits on Fedora 15
15:02:55 <Cale> err. well, with no specific -O flag
15:03:13 <hpc> Cale: it defaults to no optimizations, i believe
15:03:15 <Cale> I'll try with -O0
15:03:21 <Cale> yeah, same
15:03:30 <Cale> I'm on a 32 bit machine
15:03:37 <Cale> So that might have something to do with it?
15:03:52 <merijn> E0F: 64bit GHC version as well?
15:03:58 <E0F> of course :)
15:04:06 <merijn> I'm confused then
15:04:16 <Cale> E0F: Just for fun, you might try installing 7.0.3
15:04:19 <hpaste> identity_ pasted “output madness” at http://hpaste.org/47955
15:04:25 <identity_> @ dino
15:04:27 <Cale> (and please don't compile it yourself, get the binary)
15:04:28 <identity_> @ dino- *
15:04:32 <merijn> Because that's the same as me and I get significant speed up from -O0 to -O2 (although not on linux)
15:04:33 <E0F> GMP 4.3.2
15:04:33 <sshc> Why does "unsafe" block all other threads while "safe" with -threaded doesn't?  This seems counter-intuitive, since "safe" is used when the foreign import might call back into haskell code, and "unsafe" can (but doesn't have to) be used for efficiency otherwise: wouldn't that make "safe" more efficient?
15:04:38 <ddarius> Cale: There's 7.0.4 now.
15:04:58 <Cale> or yeah, we could do that :)
15:05:04 <hpc> sshc: "this function is safe to thread" vs "this function is not safe to thread"
15:05:07 <Cale> yeah, 4.3.2 for me too
15:05:38 <hpc> sshc: oh nvm, i see where the inconsistency is
15:05:44 <hpc> yeah, i am foncused
15:05:55 <E0F> merijn: do you get the improvement with Integer or Int ?
15:06:04 <dino-> identity_: Happens even without the forkIO ?
15:06:11 <merijn> E0F: Yes, that also give a speedup here
15:06:28 <identity_> dino-: Yes. It has been uncommented since I started writing since the gameThread is undefined.
15:06:30 <dino-> I've had things like this with child threads' stdout output getting mangled together, like individual chars in the same line.
15:06:38 <merijn> -O0 Integer == 38s, -O2 Integer == 8s, -O0 Int == 4s
15:06:51 <dino-> Solved with having an output thread that's the only thing allowed to speak with the outside world.
15:06:55 <dino-> hm :/
15:07:02 <Cale> oh, Integer -> Integer with -O0, I get 28s.
15:08:18 <dino-> And printf does the same thing. huh
15:08:19 <E0F> wait, I have recompiled the code with integer and -O2 in a different folder and it is now 5,7s
15:08:39 <identity_> dino-: Aye. It's strange
15:08:40 <E0F> I guess I didn't clean up the former binary the last time I tried
15:08:44 <identity_> I have no idea what to make of it
15:09:05 <dino-> Try nobuffering on stdout as well.
15:09:09 <identity_> hmm
15:10:00 <E0F> thank you for your time guys, and thanks for pointing out the difference between Integer and Int :)
15:10:05 <identity_> dino-: Same result
15:10:09 <dino-> !
15:10:35 <identity_> What is also strange is that my file contains a user foo:bar(and I have confirmed that it is read properly and my validation works as intended in ghci)
15:10:37 <ddarius> identity_: You are not trimming the \r.
15:10:40 <E0F> I guess i'll keep on learning Haskell it seems to be a really great programming language, also I want to try functionnal programming
15:10:56 <identity_> ddarius: hm?
15:11:00 <identity_> yeah
15:11:05 <identity_> that could be it I guess
15:11:15 <dino-> Ah, I was thinking that earlier, CR but no line feed.
15:11:17 <dino-> no newline
15:12:45 <whatsup159951> hey :)
15:12:53 <whatsup159951> migh You help me please?
15:13:17 <danharaj> ok
15:13:29 <sam5> Hi, I have a question about haskell
15:13:43 <whatsup159951> I got a board with black and white poles. I got a list of tuples of white poles (x, y, value_of_pole)
15:13:43 <identity_> dino-: ddarius Thanks a lot. :) The \r was the issue.
15:13:46 <sam5> I keep getting the error Couldn't match expected type `Int' with actual type `Integer'
15:13:58 <whatsup159951> I wanna create a graph consists of white poles and check if it's connective
15:14:12 <whatsup159951> any tricky way to do that?
15:14:17 <sam5> can I somehow cast an Int to an Integer?
15:14:18 <dino-> identity_: I think I wasn't clear earlier, I was asking about "funky characters"
15:14:33 <danharaj> sam5: Can you put your code on hpaste.org?
15:14:36 <dylukes> Oh god. Finally the internet.
15:14:42 <sam5> ok
15:14:44 <dylukes> It's dial up though...
15:14:44 <sam5> one sec
15:14:51 <dylukes> Writing Agda in japanese. I am so bored. :D
15:14:54 <identity_> dino-: Yeah, I had already thought of it by then, but I thought I had checked properly whether either contained funky chars by switching the pass and the user in the output
15:15:15 <whatsup159951> do You understand my problem? (i'm not native english-speaker - that's why i'm asking that)
15:15:31 <ddarius> dylukes: You and djahandarie would get along.
15:15:53 <djahandarie> Last time we met I beat him up
15:15:58 <danharaj> whatsup159951: What are the edges in your graph? The nodes are 'white' poles right?
15:16:06 <dino-> The \r is handy sometimes for doing progress-bar type effects in the shell. Repainting same line repeatedly. But is evil for tail/less/etc.
15:16:16 <whatsup159951> danharaj, yup, right now i got a list of tuples
15:16:21 <sam5> http://hpaste.org/47956
15:16:22 <whatsup159951> each tuple is a white pole
15:16:26 <ddarius> djahandarie: Not inconsistent with my statement.
15:16:51 <identity_> dino-: Aye. I may use \r eventually for something like that in this program, heh
15:17:05 <ddarius> identity_: Use show in the future to see what is actually displayed, i.e. turn putStrLn into print.
15:17:17 <dylukes> He didn't beat me up.
15:17:17 <dylukes> He's a liar and a cheat.
15:17:26 <identity_> ddarius: I'll remember that
15:17:52 <danharaj> sam5: What is the error you get exactly, can you annotate your paste with that too?
15:17:58 <identity_> But I guess I'll just write a hGetLine wrapper: wrapper handle = filter isPrint <$> hGetLine handle
15:18:00 <djahandarie> dylukes, you just don't remember.
15:18:08 <danharaj> whatsup159951: what are the edges in your graph that you want to check for connectivity?
15:18:08 <sam5> ok just one sec
15:18:33 <dylukes> But yeah
15:18:54 <dylukes> I
15:18:54 <dylukes> Kind of bored up here.
15:19:11 <dylukes> I brought Programming In Scala, and a book of japanese short stories with guided translations
15:19:18 <whatsup159951> danharaj, I wanna check if i can reach to any white pole from any white pole moving left-right-up-down
15:19:19 <dylukes> Agda in japanese is the logical conclusion of this endeavor.
15:19:31 <whatsup159951> like in the maze
15:20:04 <danharaj> whatsup159951: and you can't move over black poles?
15:20:15 <whatsup159951> yup
15:20:29 <merijn> danharaj: Sounds like the setup for an extremely bad/racit joke >.>
15:20:36 <dylukes> Wow.
15:20:38 <danharaj> merijn: heh.
15:20:49 <dylukes> The internet is so slow, emacs is frozen on M-x gist-buffer
15:21:16 <sam5> http://hpaste.org/47957
15:21:19 <sam5> here it is...
15:21:26 <sam5> I keep getting Integer Int error...
15:21:30 <danharaj> whatsup159951: I'm not sure how to go about it the best way, maybe someone else can help you.
15:21:50 <whatsup159951> maybe something from Data.Graph?
15:22:10 <danharaj> whatsup159951: even simpler, since your graph is a grid, you can store it as an array.
15:22:14 <whatsup159951> i found that a few minutes ago, that haskell has own types for graphs
15:22:19 <dylukes> so, a few things I'd love to know
15:22:25 <dylukes> in agda-mode, how do I evaluate an arbitrary term?
15:22:30 <whatsup159951> what array will bring me?
15:22:32 <dylukes> Just to, you know, make sure things work.
15:22:39 <danharaj> sam5: You did not paste the error you get when you try to compile.
15:22:47 <dylukes> djahandarie: *ping*
15:23:17 <sam5> oops... sorry about that
15:23:20 <sam5> here it is http://hpaste.org/47958
15:23:22 <augur> if anyones going to hacphi: http://www.haskell.org/haskellwiki/Hac_φ/Talks#Workshop_Polls
15:23:55 <danharaj> whatsup159951: Your poles are on a grid right? So you have three possible values: data Pole = White (valuetype) | Black (valuetype) | Empty, so you have an array of Poles, right?
15:24:20 <whatsup159951> danharaj, err, only white or black
15:24:20 <dylukes> for instance, if I try to enter 七 + 二 (defined shorthands...)
15:24:26 <whatsup159951> and i can move only on white
15:24:43 <dylukes> the result is just 自然数　(Nat), which is correct… but not helpful.
15:24:55 <dylukes> I'd like the actual result of the addition, even as a chain of succ
15:25:35 <parcs> dylukes: i believe #agda would be more helpful
15:25:36 <dylukes> djahandarie: You think you might be able to help me out?
15:25:58 <dylukes> I'm on dialup.
15:26:05 <dylukes> Do you know how hard it is to join another channel?
15:26:22 <dylukes> It takes at least 20-30 seconds.
15:26:48 <whatsup159951> dylukes, in the same network?
15:27:03 <ddarius> dylukes: That doesn't sound like our problem.  In fact, it doesn't sound like much of a problem at all.
15:27:08 <dylukes> I just got in.
15:27:11 <dylukes> That should give you an idea.
15:27:20 <merijn> sam5: Try using "(num - 1 :: Int)" at the end instead of just "num-1"?
15:27:24 <dylukes> It's because of how long it takes to send the namelist.
15:27:56 <Cale> whatsup159951: Implementing a go board? :)
15:28:03 <sam5> Ok I'll try
15:28:03 <dylukes> I get 50 b/s… and maybe up to 1.0kb/s on a GOOD DAY during an extended download.
15:28:33 <merijn> sam5: Basically, the type checker sees that "list base num" returns an Int, but "num - 1" can be parsed as an Integer or as an Int, so it's guessing "Integer". But you can't compare Int and Integer, adding the ":: Int" should beat it into actually seeing it as an Int
15:28:41 * hackagebot vector 0.7.1 - Efficient Arrays  http://hackage.haskell.org/package/vector-0.7.1 (RomanLeshchinskiy)
15:28:56 <whatsup159951> Cale, it's rather a maze
15:29:03 <whatsup159951> not a go game
15:29:08 <Cale> okay :)
15:29:22 <danharaj> whatsup159951: ok. so do you want to find all the connected components or do you just want to find out if there is only one connected component?
15:29:24 <Cale> I suppose that's another decent place you need to check connectivity of that sort :)
15:29:43 <whatsup159951> Cale, what do You mean?
15:30:36 <Cale> A go board has black and white stones on it, and it's important to find groups of connected white and black stones.
15:30:45 <Cale> (in the same sense of connectivity)
15:30:54 <Cale> But whatever :)
15:31:37 <sam5> http://hpaste.org/47959
15:31:37 <dylukes> Cale: Do the rules of go fit in exactly with flood filling?
15:31:58 <dylukes> Go board seems like a mathematically fun thing to play with.
15:33:04 <whatsup159951> so maybe You can help me with transforming list of tuples (x, y, value) into graph?
15:33:11 <whatsup159951> I have no idea how can i do it too
15:33:13 <danharaj> sam5: Give a type signature for both base and num. base :: Int, num :: Int
15:33:26 <Cale> dylukes: Well, two stones x and y are considered connected if they are vertically or horizontally adjacent, or there is a third stone z which x and y are both connected to.
15:33:56 <dylukes> (Proof!)
15:34:00 <dylukes> (jk)
15:34:10 <Cale> That's the definition
15:34:20 <dylukes> Yes yes, I know.
15:34:37 <dylukes> Well, third stone z of the same color and two stones x and y
15:34:38 <danharaj> whatsup159951: How do you want to represent your graph? You can represent it as a Data.Map where the keys are vertices and the values are lists of adjacent nodes.
15:34:41 <dylukes> as two*
15:35:38 <Cale> Yeah, all three stones have to be the same colour :)
15:35:54 <dylukes> I've played it a while back.
15:35:55 <dylukes> Fun game.
15:36:16 <whatsup159951> danharaj, let me check how Data.Map looks like
15:36:18 <Cale> I got to around 6 kyu before I stopped playing regularly
15:36:19 <sam5> how do you declare type signature when I declare them?
15:36:40 <sam5> can I somehow change the function's return type to be Integer?
15:36:42 <Cale> (because I left the university and lost my source of opponents)
15:37:09 <danharaj> sam5: I don't know exactly what the type of your function is because I don't know the type of (base^), but you probably need to work with Ints because of the library you're using.
15:37:14 <sam5> because I tried writing list :: Integer -> Integer -> Integer
15:37:29 <danharaj> sam5: If you don't tell GHC the type of a number, it assumes it is Integer.
15:37:46 <sam5> then can I declare:
15:37:48 <Cale> list base num = fromIntegral . length . nub . map (flip mod num) . map (base^) $ [1..num-1]
15:37:52 <sam5> list :: Int -> Int -> Int ?
15:37:57 <Cale> or you can use genericLength
15:38:02 <Cale> which is a little safer
15:38:12 <Cale> length :: [a] -> Int
15:38:15 <Cale> unfortunately
15:38:24 <danharaj> really? that's silly.
15:38:28 * dylukes does this when bored: http://hpaste.org/47960
15:38:29 <Cale> Yeah :/
15:38:38 <dylukes> I should really do something more interesting than natural numbers :|
15:38:42 <dylukes> kind of dull on their own.
15:39:25 <benmachine> dylukes: succ a - 0 = a?
15:39:35 <dylukes> whoops.
15:39:40 <whatsup159951> err, i think i wanna use Data.Graph and use function reachable
15:40:31 <sam5> um...
15:40:37 <sam5> where was fromIntegral again?
15:41:20 <danharaj> whatsup159951: Ok. try that and tell us how it goes. I haven't used Data.Graph before so I don't know how nice it will be.
15:42:10 <whatsup159951> danharaj, as far as i will get know how to transform list of tuples into graph
15:42:22 <sam5> wait... wow it worked
15:42:25 <sam5> whew!!
15:45:59 <sam5> Can I ask for one more help...
15:46:00 <sam5> http://hpaste.org/47963
15:51:48 <siracusa> sam5: I think it work if you chage the primroot signature to primroot :: Integer -> [Integer]
15:51:59 <siracusa> * it will
15:53:07 <sam5> oh...
15:53:19 <sam5> I don't really get the types...
15:53:34 <sam5> I thought Integer has more range...
15:54:03 <c_wraith> Integer is unbounded.  Int is (on GHC) 32-bit or 64-bit, depending on your platform
15:54:44 <ski> > let list base num = genericLength . nub . take (num - 1) $ iterate ((`mod` num) . (base *)) 1 in list 5 23
15:54:45 <lambdabot>   22
15:55:02 <ski> sam5 : ^ that's a better way to compute it
15:57:41 <sam5> hm... I see ski
15:57:49 <sam5> I'm new to haskell
15:57:55 <sam5> and I wasn't familiar with iterate...
15:59:28 <Cadynum> hey. what would you recommend to use for parsing a really simple ByteString, for example "\"Hello\" 19 9" ?
16:00:32 <ski> sam5 : the point is that it is better to reduce the representative of the number in `|Z / (num * |Z)' after each multiplication by `base', instead of doing it at the end
16:00:33 <mdeboard> I'm trying to run a Levenshtein distance function against every 3-character substring (without jumbling order) in string 's', and am having trouble grokking how to handle it. I'm sure I need to "take 3, then drop 1, then take 3, then drop 1, then take 3, then drop 1..." and so on. However I could really use some help or guidance on how to approach this as i'm stumped.
16:01:17 <luite> mdeboard: the tails function might come in handy
16:01:30 <luite> > tails "hello world"
16:01:31 <identity_> > tails "this is a string"
16:01:31 <lambdabot>   ["hello world","ello world","llo world","lo world","o world"," world","worl...
16:01:31 <lambdabot>   ["this is a string","his is a string","is is a string","s is a string"," is...
16:01:32 <ski> sam5 : the differences you notes before were due to overflow (wraparound) for `base ^ n' before the `flip mod num' applied
16:01:52 <identity_> > make take 3 $ tails "hello world"
16:01:52 <lambdabot>   Not in scope: `make'
16:01:54 <identity_> eh
16:01:57 <identity_> > map take 3 $ tails "hello world"
16:01:58 <lambdabot>   Couldn't match expected type `a -> b'
16:01:58 <benmachine> Cadynum: hm. when I think of parsing bytestrings I think of attoparsec, but that might be overkill for you
16:01:58 <lambdabot>         against inferred type `[[a1] ...
16:02:07 <identity_> > map (take 3) $ tails "hello world"
16:02:08 <lambdabot>   ["hel","ell","llo","lo ","o w"," wo","wor","orl","rld","ld","d",""]
16:02:13 <ski> sam5 : it's also possibly to work not in `Integer', but a type which is exactly `|Z / (num * |Z)', then doing `base ^ n' would be fine
16:02:24 <identity_> mdeboard: is that what you needed?
16:03:01 <Cadynum> benmachine, im looking for something very simple if that exists
16:04:07 <mdeboard> omfg.
16:04:14 <mdeboard> I'.
16:04:22 <confound> You'?
16:04:25 <mdeboard> I'!
16:04:36 * mdeboard hurriedly tabs over to ghci
16:04:59 <identity_> possibly
16:05:18 <ski> > let list base num = takeWhile (/= 1) . tail $ iterate ((`mod` num) . (base *)) 1 in list 5 23
16:05:19 <lambdabot>   [5,2,10,4,20,8,17,16,11,9,22,18,21,13,19,3,15,6,7,12,14]
16:05:20 <identity_> > filter ((== 3) . length) . map (take 3) $ tails "hello world"
16:05:21 <lambdabot>   ["hel","ell","llo","lo ","o w"," wo","wor","orl","rld"]
16:05:33 <ski> > let list base num = (1 +) . genericLength . takeWhile (/= 1) . tail $ iterate ((`mod` num) . (base *)) 1 in list 5 23
16:05:34 <lambdabot>   22
16:05:40 <Nibble> Loading package ghc-7.0.2 ... ghc: This ELF file contains no symtab
16:05:42 <Nibble> Loading package ghc-7.0.2 ... ghc: This ELF file contains no symtab
16:05:44 <ski> sam5 : ^ that's probably even better
16:05:52 <Nibble> how to fix?
16:06:17 <luite> Nibble: upgrade to 7.0.4
16:06:18 <benmachine> Cadynum: I think if it were me I'd use things like Data.ByteString.Char8.break (== ' ')
16:06:41 <ski> > let list base num = (1 +) . genericLength . takeWhile (/= 1) . tail $ iterate ((`mod` num) . (base *)) 1 in map (`list` 23) [1 .. 22]
16:06:43 <lambdabot>   [1,11,11,11,22,11,22,11,11,22,22,11,11,22,22,11,22,11,22,22,22,2]
16:06:49 <whatsup159951> hi again, anyone had some fun with Data.Graph? 'cos i have problem with creating graph...
16:07:01 <whatsup159951> did tried a few minutes ago and it failed
16:07:03 <Nibble> luite: easier said than done, damn arch
16:07:04 <luite> Nibble: I believe that's caused by incomplete support for stripped files in older ghc's. you might be able to get it working if you can recompile the file and then don't strip it
16:07:07 <benmachine> Cadynum: there are a few libraries on hackage but I couldn't vouch for any of them, I've not tried them
16:07:08 <mdeboard> But what do I need to import for tails?
16:07:18 <mdeboard> hrm
16:07:28 <mdeboard> Well, how do I search for that info?
16:07:36 <benmachine> Cadynum: in fairness, attoparsec's dependencies are actually pretty light
16:07:58 <benmachine> parsec will do bytestrings too
16:08:00 <Cadynum> benmachine, hm, it would look quite ugly but i suppose that is the quick way to do it
16:08:03 <identity_> mdeboard: Data.List probably
16:08:06 <identity_> also, hoogle
16:08:07 <mdeboard> a just found it
16:08:10 <identity_> @hoogle tails
16:08:10 <mdeboard> with hoogle :P
16:08:10 <lambdabot> Data.ByteString tails :: ByteString -> [ByteString]
16:08:10 <ski> @index tails
16:08:10 <lambdabot> Data.List tails :: [a] -> [[a]]
16:08:10 <lambdabot> Data.ByteString.Char8 tails :: ByteString -> [ByteString]
16:08:11 <lambdabot> Data.List
16:08:21 <Cadynum> benmachine, its hard to choose something when there are so many alternatives :)
16:08:25 <benmachine> yeah
16:08:28 <identity_> mdeboard: you have the haskell platform installed?
16:08:30 <ski> mdeboard : `@index tails' says `Data.List'
16:08:32 <identity_> i.e. cabal as well?
16:08:53 <benmachine> but attoparsec is quite mature I think
16:09:05 <whatsup159951> @hoogle Data.Graph
16:09:05 <lambdabot> module Data.Graph
16:09:06 <lambdabot> module Data.Graph.Inductive.Graph
16:09:06 <lambdabot> Data.Graph type Graph = Table [Vertex]
16:09:20 <identity_> mdeboard: http://www.haskell.org/haskellwiki/Hoogle#GHCi_Integration
16:09:43 <adimit> If I define some Word8's in my code like: nl8 = fromIntegral.fromEnum $ '\n' — will GHC optimize these away completely and just put numbers in the code?
16:10:06 <Cadynum> benmachine, alright, i will look into it. thanks
16:10:54 <parcs> adimit: yeah
16:11:34 <whatsup159951> @src reachable
16:11:34 <lambdabot> Source not found. I've seen penguins that can type better than that.
16:11:38 <whatsup159951> @hoogle reachable
16:11:39 <lambdabot> Data.Graph reachable :: Graph -> Vertex -> [Vertex]
16:11:39 <lambdabot> Data.Graph.Inductive.Query.DFS reachable :: Graph gr => Node -> gr a b -> [Node]
16:11:46 <adimit> parcs: thanks. I tried looking at the core, but it was a bit… convoluted.
16:13:25 <mdeboard> identity_: I do indeed, still an incredible noob (just took it up today. And yeah I have Cabal
16:13:36 <mdeboard> cabal ins
16:13:37 <mdeboard> oop
16:13:45 <identity_> mdeboard: then check that link and get hoogle set up in your ghci. It's beautiful
16:13:53 <mdeboard> identity_: It's building now, thanks
16:14:19 <mdeboard> I can do :reload hoogle right
16:14:22 <mdeboard> in ghci
16:14:24 <mdeboard> no need to :q etc
16:14:50 <identity_> mdeboard: not sure
16:36:24 <Elvish_Pillager> Jeez, cabal just sent me on a chase five dependency levels deep to install this new module with profiling.
16:36:26 <whatsup159951> nvm, i did that ;)
16:45:51 * hackagebot stringsearch 0.3.6.1 - Fast searching, splitting and replacing of ByteStrings  http://hackage.haskell.org/package/stringsearch-0.3.6.1 (DanielFischer)
16:53:58 <mdeboard> Thanks all for your help with the tails bit, that helped a ton.
17:11:43 <koninkje> @seen edwardk
17:11:44 <lambdabot> Unknown command, try @list
17:11:44 <preflex>  edwardk was last seen on #haskell 1 day, 1 hour, 41 minutes and 54 seconds ago, saying: *nods*
17:17:22 <mdeboard> foldl1 foo
17:29:52 <proq> does anyone have a link to steps to compiling hugs into an objective-c program?  I would like to use a hugs repl in my cocoa app
17:33:07 <Eduard_Munteanu> Hrm, how do I use the GHC module? It seems to be hidden.
17:34:45 <Eduard_Munteanu> Ah, -package GHC
18:04:18 <copumpkin> roconnor: let me know if you want to collaborate on your btc implementation
18:13:51 <slack1256> do somebody here use the grapefruit library?
18:14:02 <slack1256> i can't find any tutorial on haskellwiki
18:15:42 <siracusa> There's no tutorial, you'll have to learn from the package documenation and the examples.
18:16:53 <slack1256> is worth it? or should i learn others toolkits?
18:17:42 <tricky> \hey
18:17:42 <tricky> how can i calculate the length of array?
18:18:15 <tricky_temp> do You know what i mean?
18:18:16 <siracusa> slack1256: Grapefruit is very limited in its current version. If you want to create complex GUIs you better use pure gtk2hs or wx
18:19:00 <siracusa> tricky_temp: You mean array or list?
18:19:40 <tricky_temp> array(1,3)[(1,1),(2,2),(3,3)]
18:19:40 <tricky_temp> array(1,3)[(1,1),(2,2),(3,3)]
18:19:41 <tricky_temp> array(1,3)[(1,1),(2,2),(3,3)]
18:20:43 <slack1256> siracusa: do this  (max . indices)
18:20:44 <tricky_temp> sorry, irc crashed - i mean: array(1,3)[(1,1),(2,2),(3,3)]
18:20:53 <tricky_temp> something like that
18:20:56 <tricky_temp> the size is 3
18:21:01 <tricky_temp> but which function returns it?
18:21:19 <tricky_temp> as a Int
18:21:21 <tricky_temp> or Integer
18:21:28 <ClaudiusMaximus> > bounds (listArray (1,3) (repeat 4))
18:21:28 <lambdabot>   (1,3)
18:21:32 <slack1256> (max . Data.Array.IArray.indices)
18:21:37 <slack1256> would work
18:21:43 <Axman6> would it?
18:22:11 <slack1256> yes i suppose, i haven't worked that much with arrays, but this show you a list of indices
18:22:15 <Axman6> > max . indices . array (7,10) $ zip [7..10] [1..]
18:22:15 <lambdabot>   Overlapping instances for GHC.Show.Show ([i] -> [i])
18:22:15 <lambdabot>    arising from a use ...
18:22:16 <tricky_temp> ClaudiusMaximus, look more clear, thanks :)
18:23:12 <slack1256> print $ max . indices . array (7,10) $ zip [7..10] [1..]
18:23:23 <slack1256> > print $ max . indices . array (7,10) $ zip [7..10] [1..]
18:23:24 <lambdabot>   Overlapping instances for GHC.Show.Show ([i] -> [i])
18:23:24 <lambdabot>    arising from a use ...
18:25:27 <Axman6> @hoogle bounds
18:25:27 <lambdabot> Data.Array.IArray bounds :: (IArray a e, Ix i) => a i e -> (i, i)
18:25:28 <lambdabot> Data.Graph type Bounds = (Vertex, Vertex)
18:25:28 <lambdabot> Data.Array.MArray getBounds :: (MArray a e m, Ix i) => a i e -> m (i, i)
18:25:36 <Axman6> @hoogle boundsSize
18:25:36 <lambdabot> No results found
18:27:30 <ddarius> @src Ix
18:27:30 <lambdabot> class (Ord a) => Ix a where
18:27:30 <lambdabot>     range           :: (a,a) -> [a]
18:27:31 <lambdabot>     index           :: (a,a) -> a -> Int
18:27:31 <lambdabot>     inRange         :: (a,a) -> a -> Bool
18:27:31 <lambdabot>     rangeSize       :: (a,a) -> Int
18:27:47 <hpaste> Haisheng pasted “MaxSizeFile.hs” at http://hpaste.org/47969
18:28:54 <Axman6> > rangeSize . indices . array (7,10) $ zip [7..10] [1..]
18:28:55 <lambdabot>   Couldn't match expected type `(a, a)' against inferred type `[i]'
18:29:10 <Axman6> > rangeSize . indices $ array (7,10) (zip [7..10] [1..])
18:29:11 <lambdabot>   Couldn't match expected type `(a, a)' against inferred type `[i]'
18:29:17 <ddarius> :t rangeSize . bounds
18:29:18 <lambdabot> forall a e. (Ix a) => Array a e -> Int
18:29:19 <Axman6> :t indices
18:29:20 <lambdabot> forall i e. (Ix i) => Array i e -> [i]
18:29:26 <Axman6> bleh, bounds, of course
18:29:33 <Axman6> > rangeSize . bounds . array (7,10) $ zip [7..10] [1..]
18:29:35 <lambdabot>   4
18:32:57 <mdeboard> When I use elemIndex a b, it returns something like "Just 5". How do I "get" just the integral part of that result?
18:33:42 <identity_> :t elemIndex
18:33:43 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
18:33:53 <hpaste> Haisheng annotated “MaxSizeFile.hs” with “MaxSizeFile.hs (annotation)” at http://hpaste.org/47969#a47970
18:34:05 <identity_> mdeboard: If you think about it, when you want to check if an element is in a list, and get its index
18:34:05 <Axman6> case elemIndex (1,10) of Nothing -> error "lol"; Just x -> x
18:34:17 <identity_> it isn't given that the element is in the list
18:34:24 <mdeboard> RIght, I get that
18:34:24 <identity_> Therefore we have the Maybe type
18:34:39 <identity_> For computations that can return a result, or no result
18:34:45 <identity_> @info Maybe
18:34:46 <lambdabot> Maybe
18:34:48 <identity_> lol.
18:34:51 <mdeboard> But if the reslut is not Nothing type
18:34:57 <mdeboard> result*
18:35:01 <Axman6> then pattern match on it
18:35:01 <identity_> fromJust, for example
18:35:04 <identity_> or pattern match
18:35:06 <mdeboard> I want that int
18:35:13 <identity_> :t fromJust
18:35:13 <lambdabot> forall a. Maybe a -> a
18:35:16 <identity_> > fromJust (Just 3)
18:35:16 <mdeboard> ah
18:35:17 <lambdabot>   3
18:35:22 <identity_> but fromJust isn't safe either
18:35:25 <monqy> :t maybe
18:35:26 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:35:26 <identity_> > fromJust Nothing
18:35:27 <lambdabot>   *Exception: Maybe.fromJust: Nothing
18:35:30 <Axman6> > fromJust Nothing
18:35:31 <lambdabot>   *Exception: Maybe.fromJust: Nothing
18:35:32 <Axman6> bah
18:35:35 <mdeboard> I can't get Hoogle working on my machine :\ haskell-src-exts doesn't want to install
18:35:59 <identity_> what version of ghc?
18:36:05 <identity_> and what is the error?
18:36:18 <mdeboard> 6.12.1 ghc
18:36:34 <c_wraith> mdeboard: you probably don't have happy installed.  cabal can't do that automatically
18:36:37 <Axman6> that's a quite old ghc
18:36:45 <c_wraith> it's not that old
18:37:08 <Axman6> well I'd expect to see at elast 6.12.3
18:37:18 <c_wraith> mdeboard: often the actual error is in output that scrolled off the screen.
18:37:43 <c_wraith> mdeboard: scroll up a bit and see if there's something that's more specific.  (though I really do suspect the problem is that happy isn't installed)
18:38:18 <mdeboard> let me upgrade ghc then
18:38:25 <identity_> whatever it is, ghc 6.12.3 comes with whatever it needs
18:38:27 <Axman6> try installing happy first
18:38:28 <mdeboard> I've definitely installed happy
18:38:32 <identity_> running an old ghc(not by choice) on another box
18:38:33 <mdeboard> 2-3 times
18:40:16 <mdeboard> ah apt doesn't have anything newer
18:40:32 <identity_> mdeboard: what distro?
18:40:34 <identity_> debian?
18:56:56 <mustelo> how long should a build from source take for ghc?
19:08:44 <dafis> mustelo: depends, can take several hours
19:08:58 <mustelo> okay, just making sure I wasn't crazy
19:09:23 <dafis> mustelo: how long already?
19:09:41 <mustelo> around 1.5 hours so far, but it's a slow box, so that sounds reasonable
19:10:01 <dafis> how slow?
19:10:08 <mustelo> 1.2GHz
19:10:13 <mustelo> one core
19:10:16 <dafis> RAM?
19:10:22 <mustelo> plenty
19:10:50 <dafis> then I'd estimate about 2.5-3 hours total
19:10:57 <mustelo> sounds good
19:30:39 <sshc> Is there a pragma or other means of instructing GHC to silence missing type signatures for *particular*, designated top-level declarations (but otherwise emit warnings as usual for values/functions that aren't explicitely designated as such)?
19:30:49 <sshc> To silence the warning, I mean
19:34:39 <Axman6> sshc: why not put the type sigs in? just curious
19:39:52 <Elvish_Pillager> woot woot enjoying using Darcs for my project.
19:44:03 <mdeboard> identity_: Ubuntu
19:44:22 <mdeboard> identity_: happy's binary is in ~/.cabal/bin which was unexpected
19:44:52 <Axman6> do you have ~/.cabal/bin in your path?
19:45:12 <mdeboard> literally just added it
19:46:00 <ski> hm .. `instance P.Num Foo where (P.+) = fooPlus' doesn't work ?
19:46:28 <ski> i get "Qualified name in function definition: P.+"
19:47:08 * ski wonders how one is supposed to instance a qualified-imported class ..
19:48:00 <Eduard_Munteanu> ski: maybe being in 'instance ... where' brings it in scope?
19:48:04 <mdeboard> Yeah .cabal/bin is on path, I can type 'happy' but haskell-src-exts still throws
19:48:20 <Eduard_Munteanu> Wait, that wouldn't work well.
19:48:27 <mdeboard> setup: happy version >= 1.17 is required but can't be found. I've got 1.18+ on.
19:50:03 <cmccann> ski, I think you write the instance functions unqualified
19:50:09 <cmccann> even if they were imported qualified
19:50:14 <cmccann> or something like that
19:50:43 <cmccann> e.g. "instance P.Num Foo where + = ..."
19:50:51 <cmccann> except (+) not +
19:54:00 <ski> haha
19:54:17 <ski> `instance P.Num Foo where (+) = (+)' actually *works* !
19:55:00 <Axman6> of course
19:55:06 <cmccann> ski, I assume the RHS (+) is a function in scope unqualified
19:55:14 <ski> Eduard_Munteanu,cmccann : yeah, but what's strange is that the `(+)' in the right-hand-side is not the same
19:55:33 * ski thinks this confusing behaviour
19:55:40 <cmccann> yeah it seems weird at first
19:55:56 <ski> well, it's still weird, now that i'm aware of it
19:56:24 <ski> (i.e. i would prefer different behaviour)
19:56:31 <cmccann> but on the other hand, it's not like anything else can be bound inside an instance definition
19:56:43 <Eduard_Munteanu> Yeah, that'd be my complaint with what I suggested.
19:57:00 <Eduard_Munteanu> How do you make a difference between a recursive call and a module-local (+)?
19:57:02 <ski> imo, the original `instance P.Num Foo where (P.+) = fooPlus' is what should work
19:57:11 <cmccann> so it's still pretty unambiguous
19:57:13 <Eduard_Munteanu> Yeah.
19:57:16 <cmccann> even if it counterintuitive
19:57:19 <ski> assume that we extend the module system to allow rename-on-import
19:57:48 <ski> if i rename `(+)' to `preludePlus', then i should be able to say `instance P.Num Foo where preludePlus = fooPlus'
19:59:41 <ski> (a way to get something closer to the extant behaviour would be something like `local open P in instance Num Foo where (+) = fooPlus', but in this case `(+)' would refer to `(P.+)' everywhere inside the `local'-`in')
20:01:38 <ski> Eduard_Munteanu : to make it recursive, i think you have to `instance P.Num Foo where (+) = (P.+)'
20:01:59 <Eduard_Munteanu> Hrm, I see. Confusing :)
20:02:34 <ski> > let f f = f in f 0
20:02:34 <lambdabot>   0
20:02:40 <ski> imo, that's also confusing
20:02:55 <ski> > let f x x = x in f 0 1
20:02:55 <lambdabot>   Conflicting definitions for `x'
20:02:56 <lambdabot>  Bound at: <interactive>:1:6
20:02:56 <lambdabot>            <in...
20:03:08 <Eduard_Munteanu> But I guess it's consistent once you see how it works.
20:03:16 <ski> where the two patterns `x' introduce bindings at the same time
20:03:41 <ski> imo, the two patterns `f' and `f' in `f f = f' also ought to introduce bindings at the same time
20:04:18 <ski> (which would make that an illegal definition)
20:04:24 <confound> f f f f f f
20:04:39 <Eduard_Munteanu> I think the pattern-matching binding shadows the function name definition
20:04:46 <ski> yes it does
20:04:54 <ski> that's what i was complaining about :)
20:05:14 <Eduard_Munteanu> Hopefully -Wall complains loudly about it :)
20:07:27 <ski> > let map _ [] = []; map_f@(map f) (a:as) = f a : map_f as in map succ [0 ..]  -- would also be nice if it worked
20:07:28 <lambdabot>   <no location info>: Parse error in pattern
20:48:16 <om-foxy> what is the "-B" option passed to `initGhcMonad`?  When I pass `Nothing` to `runghc` I get "ghc: missing -B<dir> option"
20:48:26 <om-foxy> the page in the manual that lists flags does not contain a "-B" option.
20:48:47 <om-foxy> this is in the GHC API (package ghc)
20:51:20 <monochrom> something like /usr/local/lib/ghc-7.0.3 adjust it to your installation
20:52:05 <monochrom> the ghc-paths package helps you be more automatic
20:52:26 <om-foxy> I've tried that and I get "*** Exception: /usr/lib/ghc-7.0.3/settings: openFile: does not exist (No such file or directory)"
20:52:38 <om-foxy> there is no settings file in that directory tree
21:51:30 <sshc> Out of curiosity: is there a way to enable the monomorphism restriction when the 2010 standard flag is passed to GHC?
21:52:15 <sshc> (How exactly does setting default-language: Haskell2010 affect cabal's behaviour?)
21:58:27 <Jafet> -XYesISeriouslyWantThatDreadedMonomorphismRestriction
