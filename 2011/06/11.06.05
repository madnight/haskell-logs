00:23:01 <edwardk> preflex: xseen ddarius
00:23:02 <preflex>  ddarius was last seen on freenode/#haskell 2 hours, 26 minutes and 41 seconds ago, saying: 9000! is quite a bit.
00:23:22 <handonson> What would be the fastest way to convert "1111" :: String to 16 :: Int ?
00:23:46 <dankna> > const 16 "1111"
00:23:47 <lambdabot>   16
00:23:55 <handonson> ):
00:23:56 <dankna> that's indisputably the fastest way to do that conversion
00:24:12 <dankna> I'd also like to note that 1111 as binary is actually 15
00:24:21 <handonson> my apologies
00:24:38 <dankna> no worries.  anyway, questions like "what's the fastest way...?" are a little hard to answer.
00:24:55 <dankna> better to ask "is this way which I've hpasted source for going to be pointlessly slow or not?"
00:25:56 <handonson> well, from my experience, #haskell has been pretty good at figuring that out.
00:26:20 <Jafet> You need something that goes at 88mph
00:26:54 <edwardk> dankna: Numeric.readInt
00:27:14 <dankna> no, he wants it in binary
00:27:18 <edwardk> dankna: something like readInt 2 (`elem` "01") (\c -> fromEnum c - fromEnum '0') — but i haven't used it in a long time so i may have screwed it up
00:27:23 <handonson> readInt surely works
00:27:27 <edwardk> readInt is parameterized on the base
00:27:29 <dankna> oh
00:27:31 <dankna> okay then!
00:27:46 <edwardk> you tell ht the base, what characters are valid digits, and how to convert them to Ints
00:27:56 <dankna> > readInt 2 (`elem "01") (\c -> ord c - ord '0') "1111"
00:27:57 <lambdabot>   <no location info>: parse error on input `"'
00:28:01 <dankna> > readInt 2 (`elem` "01") (\c -> ord c - ord '0') "1111"
00:28:02 <lambdabot>   [(15,"")]
00:28:02 <edwardk> :t Numeric.readInt
00:28:03 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
00:28:08 <dankna> lookit that
00:28:32 <ddarius> edwardk: You have a Haskell video game named after you.
00:28:42 <edwardk> hah, nikki and the robots? =)
00:29:29 <ddarius> Yes.
00:30:02 <dankna> er, how is that named after edwardk?
00:30:17 <arcatan> because edwark is a robot
00:30:17 <edwardk> dankna: the version was named "Edward"
00:31:53 <edwardk> ddarius: need a good name for a typeclass for a class describing the operations made available on a monadic that supports vector operations. it isn't a vector space per se, unless you throw in a given element to the monad to use as an index though,
00:32:00 <edwardk> er on a monad
00:32:09 <dankna> oh, cool :)
00:32:22 <Axman6> > readInt 2 (`elem` "01") (\c -> ord c - ord '0') "111 hello 101"
00:32:24 <lambdabot>   [(7," hello 101")]
00:33:20 <edwardk> class (Alternative v, MonadPlus v, Num (Scalar v)) => Foo v where type Scalar v; (.*) :: Scalar v -> v a -> v a; linear :: [(Scalar v, a)] -> v a — etc.
00:33:36 <edwardk> if it knew 'a' i'd be comfortable calling it a vector space.
00:34:03 <edwardk> or a module
00:35:10 <ddarius> You might be able to view it as a module in a space of functors.
00:35:42 <edwardk> i was playing around with these the other day, and basically observed that the optimizations offered by oleg's hansei for probabalistic programming basically come from taking a basic probability monad, and then taking the free monad of it, and then taking the codensity monad of that, as a series of successive optimizations
00:35:54 <ddarius> There's probably a term for it in representation theory.
00:36:19 <edwardk> i ran through the representation theory wikipedia article the other day looking for a good name =)
00:36:30 <edwardk> but its not exactly my strong suit
00:38:07 <edwardk> right now i have that and a Basis or Space type that define inhabitants of the vector space bundle or whatever this thing is that i can cup and cap for trace diagrams
00:38:20 <edwardk> er typeclass
00:39:30 <edwardk> i have importance sampling working as long as you only use unitary transformations, but was saddened that i couldn't get it to perform well for a general purpose vector space monad, (>>=) caused information to have to flow too many ways =(
00:40:46 <edwardk> but importance sampling over a free monad of a basic probability or quantum computation monad is quite nice. i can give improving answers with error bounds.
00:43:56 <edwardk> @hpaste
00:43:56 <lambdabot> Haskell pastebin: http://hpaste.org/
00:45:14 <edwardk> http://hpaste.org/47461/vector_spaces
00:45:43 <edwardk> not much yet. just hacking around. sigfpe and thorsten seem to have actually done a pretty good job of exploring this space
00:46:39 <edwardk> but the Codensity (Free (Linear p)) rep is actually rather nice. you get the importance sampling benefits of Free and the asymptotic improvement of Codensity over big Free trees.
00:47:28 <edwardk> oleg gets that in hansei, but being oleg its just because he shifts and resets everywhere with delimited continuations
00:47:38 <edwardk> you don't need callCC, codensity is enough
00:49:23 <edwardk> (i have some other code for dealing with products and sums, etc of various bases.
00:52:34 <ddarius> So if you had [(Scalar v, v a)], I'd say it would definitely be a module object in a category of monads.
00:53:14 <edwardk> i could allow that, but then i lose the cheap transformation back and forth for the non-free case
00:53:27 <edwardk> linear can be moved off into another class
00:53:49 <edwardk> i have one for evaluating anyways
00:54:30 <edwardk> so something MonadModule ish
00:54:46 <edwardk> what a generic sounding name ;)
00:57:33 <ddarius> edwardk: You can add some random Greek prefixes and suffixes if it will make you feel better.
00:57:43 <edwardk> it might
00:58:22 <tsanhwa> :t FromJSON
00:58:23 <lambdabot> Not in scope: data constructor `FromJSON'
00:58:29 <kenjin2201> Is it possible to install gtk2hs on Windows 7 64bit? It's really frustrating to install GUI package...
00:58:35 <tsanhwa> :i FromJSON
00:59:03 <Eduard_Munteanu> @hoogle fromjson
00:59:03 <lambdabot> No results found
00:59:13 <Eduard_Munteanu> @hayoo fromjson
00:59:14 <lambdabot> Unknown command, try @list
00:59:14 <tsanhwa> @hoogle FromJSON
00:59:15 <lambdabot> No results found
00:59:30 * Eduard_Munteanu thought there was a plugin for that one too :/
00:59:34 <tsanhwa> FromJSON is defined in Data.Aeson
00:59:53 <tsanhwa> it is a typeclass
01:00:52 <tsanhwa> according to the haddoc, Data.Map.Map is an instance of FromJSON, while my ghci complained it is not. so I go here to ask lambdabot :)
01:01:15 <Eduard_Munteanu> Well then there isn't much point in :t-ing it :)
01:01:37 <tsanhwa> yes, so I tried using :i :)
01:02:22 <Eduard_Munteanu> Well you might need to import the right module
01:02:55 * Eduard_Munteanu should do well to use 'well' well less often ;)
01:03:21 <tsanhwa> I suspect so too. but I check the source code, that Map instance does be defined.
01:03:37 <tsanhwa> :D
01:06:57 <Eduard_Munteanu> Actually it's got one for    FromJson v => FromJson (Map String v)
01:08:07 <Eduard_Munteanu> Are you trying to use the same sort of Map?
01:08:39 <Eduard_Munteanu> (note the class constraint on 'v' too)
01:12:06 <tsanhwa> Eduard_Munteanu: I find out what's wrong. it is related to the polymophism: while Map String Int is an instance, (IsString k) => Map k Int is not
01:12:19 <tsanhwa> see the ghci session: http://hpaste.org/47463/aeson
01:14:29 <tsanhwa> I just realize that when I literally write down (Data.Map.singleton "a" 0), it is polymophic rather than concret type
01:16:25 <tsanhwa> maybe we need a instance declaration in Aeson as (IsString a, Num b) ToJSON (Map a b), :)
01:26:00 <fragamus> @hoogle boxMuller
01:26:01 <lambdabot> No results found
01:27:27 <fragamus> @hoogle Data.Random.Normal
01:27:28 <lambdabot> No results found
01:29:25 <ClaudiusMaximus> fragamus: http://hackage.haskell.org/packages/archive/random-fu/latest/doc/html/Data-Random-Distribution-Normal.html#v:boxMullerNormalPair might be what you desire
01:37:28 <fragamus> ClaudiusMaximus: thank you
01:38:41 <fragamus> camelCase vs. under_score
01:39:45 <fragamus> I hear that Japanese people have a hard time with camel because they aren't used to capitalization
01:40:02 <fragamus> I try to use under_score for that reason
01:40:55 <fragamus> what is your opinion
01:41:04 <companion_cube> they have a hard time with english anyway
01:41:43 <fragamus> well I have a hard time with Japanese
01:42:14 <fragamus> and with Haskell
01:42:52 <fragamus> hlint was bitching about my underscores
01:43:06 <onmach> I don't use camelcase in any other language
01:43:23 <onmach> except in rare cases
01:46:11 <Eduard_Munteanu> Considering the written language, I think it's not much of an overstatment to say they're having a hard time with Japanese too :P
01:46:28 <Eduard_Munteanu> (well, Chinese might be more accurate there)
01:50:49 <ArnoVanLumig> is it just me, or is a predictive parser not quite practical for parsing programming languages?
01:51:59 <ArnoVanLumig> I'm not experienced with parsing at all, but even just parsing all the possible forms of numeric literals (0, 0123, 0x123, 0.1f, 0.1e10f, 1d, etcetera) takes nearly one hundred lines of code
01:52:11 <fragamus> http://hackage.haskell.org/packages/archive/random-fu/0.1.0.0/doc/html/src/Data-Random-Distribution-Normal.html
01:52:14 <fragamus> or
01:52:27 <fragamus> http://hackage.haskell.org/packages/archive/normaldistribution/1.1.0.1/doc/html/Data-Random-Normal.html
02:01:27 <arcatan> fragamus: in Haskell, camelCase, because that's what everyone else uses.
02:08:51 <onmach> :ls
02:14:17 * osfameron is half considering writing a book on FP data-structures in modern perl https://github.com/osfameron/pure-fp-book
02:14:33 <osfameron> i.e. a bit like Okasaki, only targeted at the working programmer, rather than a computer scientist ;-)
02:15:57 <onmach> I have no clue what a moose object is
02:16:15 <erikde> osfameron: sounds like a great idea
02:17:05 <osfameron> onmach: if you're interested, http://moose.perl.org - it's a bit like a port of Smalltalk/CLOS to "Modern Perl"
02:19:03 <onmach> too much perl for my blood
02:19:21 <osfameron> ;-)
02:20:14 <onmach> I would like to read the chapter on grids
02:20:21 <osfameron> yes, me too!
02:20:25 <osfameron> as they are a massive PITA
02:20:31 <onmach> tried to make a roguelike, and arrays were tossed out pretty fast
02:20:33 <osfameron> oh wait, does that mean I have to write one :-(
02:20:35 * osfameron cries
02:20:37 <onmach> I eventually used map for coords
02:22:31 <Omie> Hi ! I am not able to open http://hackage.haskell.org/package/gtk-0.12.0
02:22:37 <Omie> is it just me ?
02:23:46 <ArnoVanLumig> Omie: works fine here
02:24:14 <Omie> ArnoVanLumig: k, thanks. will try rebooting router
02:24:46 <osfameron> onmach: heh, yes, I've done that - in fact I'll add that to the list of options, ta
02:41:49 <lpsmith> heh, with a little tweaking it looks like my json-builder package is going to beat the pants off of aeson in terms of json serialization,  even when I'm serializing bos's data structure
02:43:33 <roconnor> is REST just about making client's stateless?
02:43:57 <ArnoVanLumig> roconnor: no, about making servers stateless
02:44:06 <ArnoVanLumig> as in: have no client state
02:44:10 <roconnor> ah
02:44:14 <lpsmith> it's not there yet though
02:44:18 <roconnor> yes, that is what I meant to say
02:44:28 <roconnor> clearly the servers will have server state
02:50:25 <robertosucks> can someone explain me what is the different between curried functions and parcial applyed functions?
02:50:56 <lpsmith> robertosucks: partial application is what you do to a curried function
02:51:07 <lpsmith> :t mappend
02:51:08 <lambdabot> forall a. (Monoid a) => a -> a -> a
02:51:14 <lpsmith> that's a curried function
02:51:18 <lpsmith> :t uncurry mappend
02:51:19 <lambdabot> forall a. (Monoid a) => (a, a) -> a
02:51:23 <lpsmith> that's not
02:51:42 <lpsmith> :t mappend [1,2,3]
02:51:42 <lambdabot> forall t. (Num t) => [t] -> [t]
02:51:47 <robertosucks> max is a curried function right?
02:51:51 <lpsmith> yes
02:51:56 <lpsmith> :t max
02:51:57 <lambdabot> forall a. (Ord a) => a -> a -> a
02:52:01 <lpsmith> :t uncurry max
02:52:01 <lambdabot> forall a. (Ord a) => (a, a) -> a
02:52:46 <roconnor> can I use acid-state with snap?
02:52:56 <c_wraith> yeah
02:53:19 <robertosucks> lpsmith, basicaly it is like ((max 1)5)
02:53:25 <robertosucks> but what i dont understand
02:53:35 <roconnor> acid-state seem like it could be useful for all sorts of non-web-server applications
02:53:38 <robertosucks> is max 1 will return 1, and max 5 will return 5
02:53:46 <robertosucks> so when they are compared?
02:54:00 <lpsmith> no,  max 1 returns a function,  not 1
02:54:24 <robertosucks> but what function? that it what i dont understand
02:54:41 <lpsmith> >  map (max 3) [1..5]
02:54:42 <lambdabot>   [3,3,3,4,5]
02:55:25 <lpsmith> the function that returns 3 if it's argument is smaller than three,  otherwise it returns it's argument
02:55:54 <robertosucks> sorry i am not getting it :(
02:55:57 <robertosucks> damm it
02:56:07 <lpsmith> that's ok,  let's try again
02:56:40 * hackagebot hmatrix-repa 0.1 - Adaptors for interoperability between hmatrix and repa  http://hackage.haskell.org/package/hmatrix-repa-0.1 (VivianMcPhail)
02:56:57 <lpsmith> @let  maxone n = max 1 n
02:56:58 <lambdabot>  Defined.
02:57:14 <ski> > let maxOf3And = max 3 in [maxOf3And 1,maxOf3And 2,maxOf3And 3,maxOf3And 4,maxOf3And 5]
02:57:14 <lambdabot>   [3,3,3,4,5]
02:57:23 <lpsmith> "maxone" is the the function that "max 1" returns
02:57:45 <lpsmith> > map maxone [-3..3]
02:57:46 <lambdabot>   [1,1,1,1,1,2,3]
02:58:01 <lpsmith> > map (max 1) [-3..3]
02:58:02 <lambdabot>   [1,1,1,1,1,2,3]
02:58:07 <DrSyzygy> Yay! Tropical geometry in #haskell!
02:58:31 * papermachine gets out his festive shirt.
02:58:38 <robertosucks> i think i am getting this
02:58:50 <lpsmith> yeah,  ski's verbiage is a bit better than mine :)
02:59:48 <ski> robertosucks : do you know `map' ?
03:00:35 <robertosucks> ski, applyies a functions in a lit
03:00:38 <robertosucks> list
03:00:40 <ski> > let maxOf3And = max 3 in map maxOf3And [1,2,3,4,5]
03:00:41 <lambdabot>   [3,3,3,4,5]
03:01:03 <ski> > let maxOf3And = max 3 in map (map maxOf3And) [[1,2,3],[4,5],[6],[]]
03:01:04 <lambdabot>   [[3,3,3],[4,5],[6],[]]
03:01:21 <ski> robertosucks : can you figure out how those ^ works ?
03:01:23 <robertosucks> ok i get that
03:01:47 <robertosucks> it test every number in the list if it is greater than 3
03:02:02 <ski> so `map maxOf3And' is also a partial application
03:02:06 <robertosucks> if it is it stays the same, but if it is not it is replace by 3
03:02:17 <ski> > map (map (max 3)) [[1,2,3],[4,5],[6],[]]
03:02:17 <lpsmith> yep
03:02:18 <lambdabot>   [[3,3,3],[4,5],[6],[]]
03:02:33 <ski> so that uses a partial application involving another partial application
03:03:04 <robertosucks> so ((,max 3) 5)
03:03:21 <robertosucks> first it pass 3, best max is evaluated with 5?
03:03:28 <arcatan> with QuickCheck2, how do I get arbitrary integer from some range
03:04:03 <ski> first `3' is passed to `max', and it returns a `maximumOf3And' function, which is then passed `5'
03:04:11 <ski> (and that returns `5')
03:05:07 <robertosucks> maximumof3And is auto created?
03:05:42 <ski> yes, except it doesn't get a name
03:06:07 <robertosucks> ok
03:06:08 <ski> functions are values and can exist without names, just like you can have a list `[2,3,5]' without giving it a name
03:06:23 <robertosucks> thank you
03:06:30 <ski> my `let maxOf3And = max 3 in ...' gave the function `max 3' a (local) name `maxOf3And'
03:14:07 <arcatan> i guess elements [1..40] will do
03:16:16 <erus`> > let mul a b = [0,a..] !! b in mul 3 4 -- I wrote my own mul function
03:16:17 <lambdabot>   12
03:18:18 <Veinor> :t \a b -> [0, a..] !! b
03:18:19 <lambdabot> forall t. (Num t, Enum t) => t -> Int -> t
03:19:08 <chrisdone> What's the function equivalent of [a,b…n]?
03:19:09 <Jafet> :t \a b = genericIndex [a..] (pred b)
03:19:09 <lambdabot> parse error on input `='
03:19:14 <Jafet> :t \a b -> genericIndex [a..] (pred b)
03:19:15 <lambdabot> forall b a. (Enum b, Integral a) => b -> a -> b
03:19:20 <Jafet> Aww.
03:19:23 <Jafet> :t enumFromTo
03:19:24 <lambdabot> forall a. (Enum a) => a -> a -> [a]
03:19:32 <Jafet> :t enumFromThenTo
03:19:32 <lambdabot> forall a. (Enum a) => a -> a -> a -> [a]
03:21:54 <Lemmih> > let mul a b = iterate (+a) 0 !! b in mul 7 7
03:21:55 <lambdabot>   49
03:23:29 <Lemmih> ?type let mul a b = iterate (+a) 0 `genericIndex` (b `asTypeOf` a) in mul
03:23:29 <lambdabot> forall a. (Integral a) => a -> a -> a
03:36:07 * hackagebot hsignal 0.2.1.0 - Signal processing and EEG data analysis  http://hackage.haskell.org/package/hsignal-0.2.1.0 (VivianMcPhail)
03:50:17 <helino> hi, I got a question about style. Do you usually import modules with "import required ... as ..." or do you just use "import ..."?
03:51:16 <helino> I guess the reason for "import required ... as ..." is to improve readability (it's very easy to which module as function belongs to)
03:51:56 <helino> at the same, time it doesn't look as nice if you already know from which module a function comes from
03:52:25 <osfameron> where's the best place to upload a 42 minute video? (haskell-related)
03:52:36 <osfameron> are there any community video channels?
03:53:25 * ski often imports like `import Control.Monad (liftM,liftM2,guard,MonadPlus (mzero,mplus))'
03:53:49 <ben> osfameron: I am not sure there is a preference, but I have seen http://vimeo.com/channels/haskell
03:54:02 <Jafet> helino: perhaps you meant to say "import qualified ... as ..."
03:54:16 <osfameron> ben, thanks.  I'll try that
03:54:18 <Jafet> People do that when different modules export the same names.
03:54:39 <helino> Jafet: yes, that's what I meant :)
03:55:34 <helino> Jafet: what about in general, do you just go with "import ..."?
03:56:04 <Jafet> For example: import Data.List; import qualified Data.Map as M; import qualified Data.Set as S; -- now there are three functions `lookup', `M.lookup', `S.lookup'
03:57:36 <helino> Jafet: I understand, but what if you only import Data.Map? Do you still use "import qualified Data.Map as M" (since then, a reader can easily see that M.lookup is Data.Map.lookup)?
03:58:12 <ben> It's kind of customary to import Data.Map qualified :)
03:58:24 <Jafet> It's rare for a large program to not use List, so the convention is to not clash with names in List
03:58:37 <Jafet> It makes it hard to later use List functions, for instance
03:58:58 <Jafet> And for that reason, modules like Map and ByteString which share names with List are always import qualified, as a convention
03:59:36 <helino> Jafet: I see, thanks for your help!
04:36:30 <tsanhwa> @hg liftIO
04:36:31 <lambdabot> Maybe you meant: . ? @ bf bug do ft ghc id msg pl rc thx v wn
04:36:37 <tsanhwa> @hoogle liftIO
04:36:38 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
04:38:01 <ski> @index liftIO
04:38:02 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
04:40:50 <tsanhwa> hehe.. I think I need the one in Trans, thanks
04:54:10 <ski> tsanhwa : all those are the same .. if you're already importing one of the others, you don't *need* to import `Control.Monad.Trans' as well
04:58:45 <tsanhwa> ski: oh.. thanx
05:05:46 <SoleSoul> Hello. I tried using a combination of let and where clauses to save some lines of code but it did not work. the code is here: http://hpaste.org/47465/quivalent    Can anybody take a look and tell me if there is a way to achieve what I try to do or there is no way to do it and I have to write some code twice?
05:06:15 <osfameron> hurrah. http://vimeo.com/24676617/ has finished uploading (my talk on Haskell from last week)
05:07:08 <Veinor> SoleSoul: rewrite expList into a function: expList = fst . parseExpressionList
05:07:15 <Veinor> then replace your expList with expList e
05:08:33 <SoleSoul> Veinor: Thank you. I guess such level of dynamic code is not allowed in a where clause?
05:08:37 <pastorn> SoleSoul: you can pattern match in where clauses...
05:08:58 <pastorn> where (x,y) = splitAt 4 "slitme up"
05:10:46 <SoleSoul> pastorn: This is good to know and will shorten the code. Thanks. If I understand it correctly it won't help me with the 'e' though
05:11:45 <pastorn> SoleSoul: the where-clause can't see the e
05:11:54 <pastorn> since it's declared in the 'let'
05:12:39 <SoleSoul> ah, now I understand
05:13:04 <pastorn> SoleSoul: also consider using "case of"
05:15:11 <pastorn> SoleSoul: i'll do some rewriting...
05:15:47 <SoleSoul> pastorn: can I use "case of" inside the 'where'? i.e. where x = case y of 1 -> 'a' 2 -> 'b' etc..
05:16:00 <SoleSoul> with new lines
05:16:37 <SoleSoul> > print a
05:16:39 <lambdabot>   <IO ()>
05:17:11 <Zao> SoleSoul: You could have guards on x.
05:17:18 <SoleSoul> > let y = 1 in x where x = case y of 1 -> 'a'
05:17:19 <lambdabot>   <no location info>: parse error on input `where'
05:17:48 <Zao> x | case y of ..
05:18:08 <pastorn> SoleSoul: no, but you should case instead of guards
05:18:17 <Zao> Or if y is of Eq,   x | y == 1 = 'a'  \n | y == 2 = ..
05:18:29 <pastorn> SoleSoul: guards are for boolean matchin, usually you want to express ranges and stuff like that with guards
05:18:47 <Zao> SoleSoul: As for what you can have on the right side of your =, anything that you usually have when defining a binding.
05:18:58 <pastorn> f x | x < 0 = ...; | (x >= 0 && x < 100) = ...; | otherwise = ...
05:19:02 <pastorn> ^^^ SoleSoul
05:20:05 <SoleSoul> I'm trying to understand, Is there anything wrong in the way I used guards?
05:20:19 <SoleSoul> is it discouraged?
05:22:00 <SoleSoul> Zao: I pasted a code before where I used guards and let and where and I had a problem with it. Thanks for the info but this is the way I already do it :)
05:22:11 <pastorn> SoleSoul: not that i haven't tested this: http://hpaste.org/paste/47465/quivalent_annotation#p47466
05:22:18 <pastorn> but it *should* work
05:22:21 <pastorn> ;)
05:22:28 <pastorn> it typechecks in my head
05:23:17 <SoleSoul> pastorn:  I'm gonna try it!
05:23:19 <SoleSoul> thanks
05:23:31 <pastorn> SoleSoul: it's cool :)
05:23:34 <Zao> SoleSoul: Following links involves moving my mouse and depressing the mouse button. Way too much effort :D
05:23:46 <SoleSoul> :)
05:23:51 <pastorn> SoleSoul: i don't know what this is for, but i always recomend people to read "monadic parsing in haskell"
05:23:55 <pastorn> because it's awesome
05:24:29 <SoleSoul> pastorn:  it's for a java-like language parsing.
05:24:40 <pastorn> SoleSoul: so read that paper, i think you will gain loads from it
05:24:40 <SoleSoul> homework I chose to try doing in haskell
05:24:53 <SoleSoul> in order to learn haskell
05:24:55 <pastorn> SoleSoul: then you should *definetly* read that paper
05:25:06 <SoleSoul> problem is, I didn't even finish lyah
05:25:08 <SoleSoul> :)
05:25:13 <pastorn> once you have you will be able to use parsec and knock this bullshit assignment out of the water
05:25:16 <pastorn> SoleSoul: no need
05:25:53 <pastorn> SoleSoul: you need to understand how (++) works and you need to know what (String -> (a,String)) means
05:26:55 <SoleSoul> pastorn: FUNCTIONAL PEARLS?
05:27:04 <larsrh> are there any other languages (except Haskell derivates) which specify type classes?
05:27:10 <SoleSoul> I mean, is that the name of the publication?
05:27:11 <pastorn> i think it might be... by Hutton, 1998
05:27:17 <SoleSoul> yes
05:27:22 <SoleSoul> thanks
05:27:28 <pastorn> larsrh: bitc is messing with it
05:27:43 <pastorn> java has interfaces :)
05:28:11 <larsrh> pastorn: yeah, and Scala has implicits :)
05:28:27 <pastorn> larsrh: go has automagical typeclasses... you just declare the functions for your type (overloading, i guess) and then you magically become part of their typeclass equivalent
05:29:21 <pastorn> SoleSoul: when you read that paper, make sure you copy all the code you see and *RUN IT*
05:29:27 <sipa> pastorn: hmm, essentially an implicit typeclass per function declaration type?
05:29:55 <SoleSoul> pastorn: I don't know, I neved dealt with monads besides IO
05:30:04 <SoleSoul> maybe it's for a bit later?
05:30:06 <pastorn> sipa: i dunno... there are a million Rob Pike videos... he likes to bring up some file handle equivalent as an example
05:30:33 <pastorn> sipa: where File, Socket, etc. etc. all are part of this interface thingy
05:30:52 <pastorn> SoleSoul: don't worry about monads, they're just warm fuzzy things
05:31:06 <pastorn> SoleSoul: seriously, trust me, you're ready for this
05:31:15 <SoleSoul> ok, thank you!
05:31:29 <pastorn> :)
05:32:51 <pastorn> SoleSoul: the paper is quite old, so some names have changed ("MonadPlus"/"MonadZero", "(++)", "(+++)")
05:33:20 <pastorn> so when you reach page 3 i think you might get trouble loading some stuff... just ask here and we'll help out :)
05:33:49 <SoleSoul> ok, thanks
05:33:52 <SoleSoul> :)
05:36:04 <SoleSoul> pastorn: btw, your code is beautifully equivalent to my intention :)
05:36:38 <SoleSoul> and no errors
05:37:08 <pastorn> hehe, cool
05:37:58 <Kaidelong> so in haskell-mpi, is unitTag just a fancy way of writing "toTag 0"?
05:38:15 <Kaidelong> if I do "fromEnum unitTag :: Int" I get 0
05:38:23 <Kaidelong> oh
05:38:31 <Kaidelong> found it in the source code
05:38:34 <Kaidelong> it's "toTag ()"
05:38:52 <Kaidelong> which may itself be the same as "toTag 0"
05:39:23 <jkramer> Ahoy
05:42:02 <roconnor> @type utcTimeToPOSIXSeconds
05:42:03 <lambdabot> Not in scope: `utcTimeToPOSIXSeconds'
05:42:08 <roconnor> @hoogle utcTimeToPOSIXSeconds
05:42:08 <lambdabot> Data.Time.Clock.POSIX utcTimeToPOSIXSeconds :: UTCTime -> POSIXTime
05:42:21 <roconnor> @hoogle POSIXTime
05:42:21 <lambdabot> Data.Time.Clock.POSIX type POSIXTime = NominalDiffTime
05:42:22 <lambdabot> Data.Time.Clock.POSIX getPOSIXTime :: IO POSIXTime
05:45:41 <pastorn> jkramer: heyo
05:47:01 <pastorn> Am I alone in thinking that Data.Time wasn't very expressive until noticing the Num instance?
05:54:00 <parcs> nope!
05:59:48 <pastorn> parcs: :D
06:25:33 <pastorn> SoleSoul: how's it going?
06:26:52 <SoleSoul> pastorn: I'm first trying to correct my application so I would be able to send it. Then I'll start reading although I would have wanted to read it first.
06:27:05 <SoleSoul> I have a deadline...
06:27:23 <SoleSoul> (which have already passed :)
06:36:39 <EM03> what is the -> used for in haskell?
06:38:19 <adnam> EM03: it's used for a few different things, \a b -> x uses it to separate the parameter list from the lambda body, in a type signature it's used to separate the types, id :: a -> a
06:38:30 <EM03> ah
06:38:34 <iskren> hello
06:38:38 <parcs> it's also used in case expressions and arrow notation
06:38:44 <EM03> in coffeescript its used for like function definition was curious if they got it from haskell
06:38:46 <Axman6> > (\x y -> x + y) 5 7
06:38:47 <lambdabot>   12
06:38:56 <EM03> http://jashkenas.github.com/coffee-script/
06:38:57 <roconnor> Any thoughts on fingertree-psqueue vs PSQueue?
06:39:00 <EM03> look how they use it there
06:39:30 <iskren> I'm trying to define a function B in the where clause of another function A. A is polymorphic on type 'c'. How can I state that B is also polymorphic on the same type?
06:39:36 <Axman6> EM03: they may well have got it from Haskell, I'm not sure I've seen it elsewhere
06:39:59 <EM03> but they use it for function definition
06:40:03 <Axman6> iskren: i think you need to turn on ScopedTypeVariables
06:40:26 <Axman6> at the top of your file, put the line: {-# LANGUAGE ScopedTypeVariables #-}
06:40:33 <roconnor> iskren: that is really hard to do without ScopedTypeVariable
06:40:40 <adnam> EM03: (x y -> x + y) is a function definition also
06:41:00 <roconnor> iskren: but it can be sometimes with sprinkings of asTypeOf and maybe a few undefineds
06:41:12 <EM03> ah
06:41:18 <EM03> so maybe they did steal it from haskell
06:41:20 <pastorn> SoleSoul: then you're OK :)
06:41:26 <Axman6> adnam: not in haskell...
06:41:30 <roconnor> @src asTypeOf
06:41:30 <lambdabot> asTypeOf = const
06:41:35 <roconnor> @type asTypeOf
06:41:36 <lambdabot> forall a. a -> a -> a
06:41:53 <pastorn> SoleSoul: actually, i think you might have needed to do a parser the "wrong way" in order to understand the benefits of doing it right
06:42:00 <roconnor> iskren: oh, right, but without ScopedTypeVariables you cannot give an annotation of the type
06:42:01 <adnam> Axman6: why is it not a definition?
06:42:08 <Axman6> well, you're missing the  \
06:42:25 <adnam> doh
06:42:28 <SoleSoul> pastorn: I am willing to take that experience.
06:42:48 <pastorn> hehe :)
06:43:13 <SoleSoul> pastorn: Are monads a thing which should be avoided if possible?
06:43:21 <Axman6> no
06:43:32 <iskren> roconnor, Axman6 I didn't get all the additional info, but just ScopedTypeVariables doesn't help
06:43:43 <pastorn> SoleSoul: depends... i try to not use them if i can help it, but for parsers they're awesome
06:43:43 <iskren> I want to have type signatures ... is that so hard?
06:43:51 <Axman6> iskren: you'll need to share the code then
06:43:51 <SoleSoul> ok
06:43:54 <pastorn> SoleSoul: brevity is not always the same as clarity
06:44:27 <iskren> http://fpaste.org/Hn0D/ <-- the problem is the definition of solve and depEval
06:44:30 <pastorn> SoleSoul: but for parsing i use monads (or "applicative functors")
06:44:49 <roconnor> iskren: unfortunately, yes it is hard, due to silly decisions made in the Haskell report.
06:45:10 <roconnor> iskren: IIRC when you use ScopeTypeVariable I think you have to use forall to quantify your type variables.
06:45:20 <SoleSoul> there is such  a chapter in lyah. someday I'll read it
06:45:42 <pastorn> SoleSoul: there's a functional pearl which explains it better, i think
06:45:53 <roconnor> With Haskell 98, you can make values whose type you cannot express in Haskell; an significant oversight IMHO.
06:45:54 <pastorn> though i only read the first two-three pages of that
06:46:03 <iskren> roconnor, so use forall only for the outer function, right?
06:46:15 <SoleSoul> pastorn: I'll look there first then
06:46:24 <roconnor> iskren: ya, use foralls for the top level function
06:46:36 <roconnor> or at least one forall for the variable you want to reuse inside
06:47:07 <pastorn> SoleSoul: just get through (most of) monadic parsing first :)
06:47:24 <SoleSoul> pastorn:  will do
06:47:31 <iskren> roconnor, thanks, that worked. I'm still not 100% sure what forall says (I read the haskell wiki ones but I couldn't get it all)
06:48:27 <roconnor> iskren: you can think of all unbound type variables as being implicity bound by a forall at the beginning of the type
06:48:51 <roconnor> iskren: the only reason you need to explicity add forall for scoped type variables is backwards compatibility with Haskell 98, AFAIU
06:49:27 <Eduard_Munteanu> iskren: it's the universal quantifier. It just says 'here's my signature, for all types a you have  ...'.
06:49:35 <Eduard_Munteanu> (for example)
06:49:46 <iskren> roconnor, the implicit forall is ok, but there are cases where the forall is "scoped" for part of the definition, and at least in the wiki they say its different. So you can do more with forall than without
06:50:54 <Eduard_Munteanu> Yes, depending where you put it, you can get "nastier" types (unrelated to ScopedTypeVariables).
06:51:12 <Eduard_Munteanu> Rank-2/n polymorphism.
06:51:43 <iskren> http://en.wikibooks.org/wiki/Haskell/Polymorphism#Higher_rank_types
06:51:52 <Eduard_Munteanu> Or even impredicative types.
06:52:02 <iskren> yes, that is what I don't understand :)
06:54:13 <Eduard_Munteanu> Which one? Impredicativity or higher-rank?
06:54:57 <Eduard_Munteanu> Impredicatives types are just a generalization, in the sense that you're allowed to put foralls inside any type constructor.
06:55:12 <Eduard_Munteanu> (not just (->))
06:55:21 <roconnor> iskren: yes this true
06:55:34 <roconnor> you can write foo :: (forall a. a -> a) ->  Whatever
06:55:47 <roconnor> which requires that the input *be* a polymorphic funciton
06:56:02 <iskren> aaah, I get it now
06:56:05 <roconnor> iskren: I've done this before
06:56:15 <iskren> you mean -- explain it to somebody :)
06:56:30 <roconnor> used functions taking polymorphic paramters
06:57:20 <roconnor> runST is a canonical example, though why it uses polymorphic function parameters is quite difficult to grasp
06:57:33 <iskren> thanks for the explanation and for the scoped variables flag
06:57:45 <Kaidelong> I thought it was a canonical example of an existential type
06:58:10 <Saizan> not really
06:58:38 <Kaidelong> @ty runST
06:58:39 <lambdabot> forall a. (forall s. ST s a) -> a
06:58:44 <Kaidelong> hmm
06:58:58 <Kaidelong> that matches
06:59:06 <Kaidelong> where did I read that then
06:59:36 <Saizan> there's a wikibook article on existential types which uses runST as an example
06:59:52 <Eduard_Munteanu> Maybe if you consider ST as some sort of arrow-like constructor
07:00:04 <Eduard_Munteanu> But it isn't one really.
07:02:58 <parcs> @type runST (newSTRef True)
07:02:59 <lambdabot>     Inferred type is less polymorphic than expected
07:02:59 <lambdabot>       Quantified type variable `s' escapes
07:02:59 <lambdabot>     In the first argument of `runST', namely `(newSTRef True)'
07:04:32 <parcs> @type runST . newSTRef -- a better error message
07:04:33 <lambdabot>     Couldn't match expected type `forall s. ST s a'
07:04:34 <lambdabot>            against inferred type `ST s (STRef s a1)'
07:04:34 <lambdabot>       Expected type: a1 -> forall s1. ST s1 a
07:05:54 <Eduard_Munteanu> @type runST . newSTRef $ True
07:05:55 <lambdabot>     Inferred type is less polymorphic than expected
07:05:55 <lambdabot>       Quantified type variable `s' escapes
07:05:55 <lambdabot>     In the second argument of `(.)', namely `newSTRef'
07:06:39 <Eduard_Munteanu> Arguably the first tells about the intent.
07:07:54 <parcs> yeah, true..
07:09:04 <companion_cube> lazy IO is so hard...
07:11:54 <Egbert9e9> what kind of GUI lib looks and feels native on each platform it runs on?
07:12:52 <Axman6> ha
07:12:56 <Axman6> none of them
07:15:03 <isomorphic> Egbert9e9: QT tries hard.
07:15:49 <osfameron> doesn't wx also?
07:17:17 <Axman6> they;re both pretty crap on OS X
07:17:37 <Egbert9e9> this sucks :(
07:18:15 <Egbert9e9> so i can't write for the mac look and feel?
07:18:55 <Axman6> not with the usual multi platform frameworks
07:19:09 <Axman6> Qt might be the best, i can’t remember how ugly it looks
07:19:19 <ion> Make the UI layer very thin and implement native UIs for any platforms you want.
07:19:33 <isomorphic> Egbert9e9: QT comes with some demos. Run them and see if they're close enough for you.
07:19:33 <Axman6> yeah, that's usually the best advice
07:20:10 <Axman6> that's how Transmission handles it, and it's got four or five different interfaces (Mac, windows, linux, web and CLI)
07:20:35 <isomorphic> http://wiki.wxwidgets.org/WxWidgets_Compared_To_Other_Toolkits    <-- this page says WxWidgets looks native-ish, but I've never used it.
07:20:39 <Egbert9e9> i've heard that lazarus deals with that
07:22:16 <Axman6> Egbert9e9: link?
07:24:39 <isomorphic> Egbert9e9: what language are you writing in btw?
07:24:51 <Egbert9e9> haskell
07:25:14 <Egbert9e9> Axman6: uhm.. sec
07:25:36 <Axman6> all my searching can find is an IDE
07:26:10 <Egbert9e9> ya, it compiles for each platform
07:26:13 <pastorn> SoleSoul: is everything crystal clear? i might be dissapearing soon...
07:26:27 <Yrogirg> hello! what  does @ mean?
07:26:42 <pastorn> Yrogirg: it means you can give a variable multiple names
07:26:54 <ion> Wx is horrible on all platforms.
07:26:56 <Yrogirg> where I can read about it?
07:27:04 <Yrogirg> @ is pretty unsearchable
07:27:08 <pastorn> f x@y = ... -- means that in ... you can use x an y and it refers to the same
07:27:14 <SoleSoul> pastorn: I have problems not related to what we talked about. I really appreciate your help and I'll be around sometimes. You don't have to wait for me. Thank you very much!
07:27:17 <pastorn> Yrogirg: but you can also do pattern matching!
07:27:27 <parcs> Yrogirg: http://en.wikibooks.org/wiki/Haskell/Pattern_matching#As-patterns
07:27:35 <Egbert9e9> Axman6: using the platform's native GUI libs, or somesuch
07:27:48 <Yrogirg> thank you
07:27:53 <pastorn> f x@(left,right) = ... -- here 'x' is the whole pair, 'left' the left element and 'right' the right one
07:28:29 <Axman6> > let f xss@(x:xs) = (x,xs,xss) in f [1,2,3]
07:28:30 <lambdabot>   (1,[2,3],[1,2,3])
07:30:33 <Josh___> Hi ! I've a n00b question
07:31:21 <Josh___> i've downloaded some -doc packages for haskell. now how do I use them ? I got them for offline reference
07:31:35 <Axman6> what OS are you on?
07:31:38 <Josh___> for example libghc6-gtk2hs-doc
07:31:40 <Josh___> Ubuntu
07:31:57 <ion> dpkg -L packagename
07:32:15 <byorgey> Josh___: the docs got installed in the standard place for documentation, probably something like /usr/share/doc or /usr/local/share/doc
07:37:05 <Omie> excellent ! found them in /usr/share/doc/libghc6-gtk-doc/html/
07:37:17 <Omie> thanks ion  byorgey  :)
07:37:43 <Omie> Thanks Josh___  even I didnt know !!
07:39:41 <shepheb> I need something to seed a random number generator with in Haskell, but th Data.Time library is a tangle. wht's the quick way to get some big, unpredictable integer to seed it with?
07:40:59 <parcs> @hoogle randomIO
07:40:59 <lambdabot> System.Random randomIO :: Random a => IO a
07:41:07 <Jafet> How unpredictable?
07:41:18 <parcs> specifically, randomIO :: IO Integer
07:41:37 <Jafet> That doesn't make sense without context.
07:41:47 <Jafet> (base, apparently, uses the range of Int.)
07:41:50 <shepheb> I know how to use System.Random
07:42:06 <shepheb> but I'm implementing something that needs to be seeded to a given value for testing, then back to random later
07:42:38 <byorgey> so what's wrong with randomIO for obtaining a seed?
07:42:40 <shepheb> so I was intending to use the current time in milliseconds or something, but that lead me down the rabbit hole of Data.Time
07:43:03 <shepheb> that might work
07:45:04 <Jafet> @src Random Integer
07:45:04 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
07:45:26 <Jafet> Oh well, it might be long.
07:50:13 <jkramer> http://paste.pocoo.org/show/401131/
07:50:42 <jkramer> This works fine
07:50:54 <jkramer> But when I remove getHistory and put it in Web.Mechanic, it doesn't
07:51:55 <jkramer> Then I'm getting this: http://paste.pocoo.org/show/401132/
07:52:36 <jkramer> What's wrong here? :(
07:53:36 <cnJamesDeng> I have a array index out of range exception that really stuck me.
07:53:36 <cnJamesDeng> ** Exception: Ix{Int}.index: Index (1) out of range ((1,-193459561))
07:54:05 <cnJamesDeng> http://stackoverflow.com/questions/6241650/haskell-array-index-out-of-range
07:54:08 <Axman6> means you've defined a strange range for the array
07:54:16 <byorgey> jkramer: looks like the monomorphism restriction
07:54:21 <tsuraan_> I'm trying fold a function over a bytestring where the function needs access to two different positions in the string (the distance between the two positions is a constant).  So far, I've tried using Data.Sequence to keep track of the entire window (very slow), using a list fold over ByteString.zip to combine the ByteString with a tail of itself (also pretty slow), and just keeping track of the bytestring fold's position in the
07:54:23 <tsuraan_> string.  At this point, I think I must be doing something really wrong, because even that is weirdly slow
07:54:41 <byorgey> jkramer: try adding {-# LANGUAGE NoMonomorphismRestriction #-} to the top of Web.Mechanic, or give getHistory an explicit type signature
07:54:55 <Axman6> woah, someone actually using the debugger :O
07:55:06 <tsuraan_> my fold keeping track of the index is this: snd $ BS.foldl (\(!idx,!h) w -> (idx+1, fromIntegral $ w + w)) (0,0) bs
07:55:36 <tsuraan_> and without the index is this: BS.foldl (\h w -> fromIntegral $ w + w) 0 bs
07:55:47 <byorgey> cnJamesDeng: yes, that is a weird error, I looked at it but have no ideas
07:55:53 <byorgey> cnJamesDeng: I hope someone can help you figure it out
07:55:54 <tsuraan_> the one without the index runs at 370MB/s, the one with the index runs at 29MB/s
07:56:20 <Axman6> tsuraan_: shouldn't you be using h somewhere there?
07:56:25 <tsuraan_> is there some obvious thing I'm doing wrong with my addition?
07:56:51 <Axman6> either you're calculating 0^(length bs) or last bs + last bs
07:56:54 <tsuraan_> Axman6: I would be using the h, but I'm just trying to find the bottleneck now.  it seems to be in the index calculation
07:57:48 <jkramer> byorgey: Thanks, works fine with the type signature :)
07:57:49 <tsuraan_> I'm trying to calculate a rolling adler32, but not having much luck iterating through the bytestring quickly.
07:58:23 <jkramer> I don't get why the location of the function makes a difference though
07:59:04 <Jafet> There is a checksumming package on Hackage
07:59:11 <byorgey> jkramer: when getHistory is in the where block it is being used with a particular monad so there is no problem giving it a monomorphic type
07:59:13 <Jafet> (Or is it already slower than yours?)
07:59:54 <tsuraan_> I haven't seen anything that does rolling checksums; they all seem to be pure additive
08:00:14 <jkramer> byorgey: But it also worked with the function as top-level function outside main, as long as it was in the same file
08:01:08 <Jafet> tsuraan: well, comparing the ghc core might tell you where the difference lies
08:01:38 <tsuraan_> how can I generate that?  I thought -fvia-c and -C would do it, but I'm not getting any ".c" dump.  using ghc 6.12
08:02:10 <Axman6> tsuraan_: you do not want to read the C output by GHC
08:02:23 <Axman6> use the ghc-core program on hackage
08:02:27 <tsuraan_> ok
08:02:34 <Axman6> cabal install ghc-core
08:02:41 <byorgey> jkramer: hmm, but I suppose the call to getHistory still gives type inference some extra information
08:02:42 <Jafet> You probably don't want via-C anyway, with a sufficiently modern ghc.
08:02:53 <Jafet> The flag to dump core is -ddump-simpl.
08:02:56 <Axman6> then ghc-core -- <normal GHC flags> foo.hs
08:03:02 <Jafet> (And not that kind of dump core...)
08:03:12 <tsuraan_> ok, I'll give that a shot
08:03:15 <byorgey> jkramer: I forget the precise details.
08:03:49 <tsuraan_> my guess is that my function that calculates indices is making and dumping a lot of temp pairs, but I would have thought escape analysis would prevent that from actually happening
08:04:03 <tsuraan_> anyhow, I'll look at the core thing.  usually better than guessing...
08:05:33 <Jafet> If that's your hypothesis, add lots of cost-centres to track allocation.
08:06:46 <tsuraan_> ghc -ddump-simpl gives a ton of undefined reference messages.  is that normal?
08:07:20 <Jafet> I don't think so.
08:08:09 <tsuraan_> ghc-core still worked, so I guess it's probably ok :)
08:08:46 <jkramer> byorgey: My guess is that the other file is a independent compilation unit which is probably even compiled before the main file and so there's no known context for the function at compile time
08:09:40 <flamingspinach> is the ghci included in the haskell platform for linux compiled with readline?
08:10:21 <byorgey> jkramer: yes, that sounds right
08:10:25 <flamingspinach> the haskell wiki suggests that the windows binaries for ghci aren't, but that some other binaries of ghci are
08:10:46 <tsuraan_> to use profiling, do you have to rebuild all your deps with profiling support?
08:11:03 <flamingspinach> but ghci doesn't seem to obey my ~/.inputrc on linux (i.e. vi mode)
08:11:07 <kamaji> Hi hasklers, is it bad to use list comprehensions and 'head' to generate a single number?
08:11:24 <jmcarthur> all your deps need profiling support
08:11:39 <jmcarthur> kamaji: only if there's a chance that the list comprehension yields an empty list
08:12:09 <jmcarthur> if there is a chance of that happening, try listToMaybe
08:12:11 <jmcarthur> :t listToMaybe
08:12:12 <lambdabot> forall a. [a] -> Maybe a
08:12:27 <jmcarthur> it's like head, but it gives Nothing if the list is empty
08:12:30 <kamaji> oh ok
08:12:31 <kamaji> cheers!
08:12:52 <Jafet> tsuraan: yes, it's one of those things no one ever teaches you for your first ~/.cabal
08:12:56 <jmcarthur> it's found in Data.Maybe, btw
08:13:21 <Omie> Hi ! outh <- openFile "pOutput.txt" WriteMode ; it wont create new file if pOutput.txt does not exist. is this normal ?
08:14:11 <Omie> http://zvon.org/other/haskell/Outputio/openFile_f.html says it should create file. but it doesnt :-(
08:15:03 <Omie> and I'm providing full path like /home/haskell/pOutput.txt in place of just pOutput.txt
08:15:48 <Jafet> Perhaps your process is not allowed to create a file there.
08:16:12 <Jafet> Yay, parting shot
08:16:21 <Twey> Haha
08:18:56 <lispy> Omie: it's unfortunate that the zvon stuff shows up in google results :(
08:19:14 <lispy> Omie: That stuff was outdated and wrong when I started learning Haskell in 2002
08:19:16 <lispy> er, 2003
08:19:26 <applicative> Omie yes it 'deprecated'
08:19:31 <osfameron> how come it has such googlejuice?
08:19:49 <osfameron> ah, because it's a general site with outdated info
08:19:54 <applicative> googlejuice is self-reproducing, we should blow up that company
08:19:55 <osfameron> such sites tend to do oddly well on google
08:20:47 <osfameron> you could lower its haskell-related juice at least, by contacting people who link to it
08:21:11 <applicative> Omie, if you are doing a simple read or write of a file you can do :  readFile "a.txt" which 'returns' the contents , writeFile "b.txt" "hahahah" writes a file with "hahaha"
08:21:12 <osfameron> ah, http://zvon.org/comp/r/ref-Haskell.html says that he's veen notified of significant changes
08:21:21 <Jafet> We should make Hoogle index all Haskell-related material
08:22:03 <applicative> Omie, are you using the ghc or hugs?
08:22:19 <Jafet> ...by type!
08:22:32 <lispy> Jafet: I think that's a known bug which is like 80% complete.  I forget the details, but I was looking at it in the hoogle bug tracker
08:22:52 <lispy> Jafet: Well, I guess the bug was actually to index hackage
08:22:57 <lispy> Maybe you mean blogs too
08:23:05 <luite> can't you use hayoo instead?
08:23:07 <applicative> where is the online html for the base libraries?
08:23:22 <Jafet> I'm not sure; many blogs are poorly typed
08:24:05 <applicative> http://www.haskell.org/ghc/docs/latest/html/libraries/base/index.html  -- Omie here is the main stuff
08:24:24 <lispy> Yeah, we need that link to be higher on the googles
08:24:56 <applicative> how do we do that? there must be known procedures...
08:25:44 <Jafet> On which keywords do we need it to be rated higher?
08:26:21 <osfameron> "haskell", "haskell + $functionName" ?
08:26:54 <osfameron> "haskell fromIntegral" for example
08:26:54 <Jafet> Well, the latter is clearly Hoogle's job.
08:27:10 <Jafet> Perhaps Hoogle should be promoted on Google...
08:27:20 <osfameron> and "haskell head" :-(
08:27:39 <lispy> Any google employees here that can just adjust the index ;)
08:27:46 <Jafet> @google Haskell head
08:27:47 <lambdabot> http://zvon.org/other/haskell/Outputprelude/head_f.html
08:27:47 <lambdabot> Title: Haskell : head
08:28:07 <applicative> grrrrrr
08:28:19 <applicative> what do we do about that?  maybe we could just write google?
08:28:22 <Jafet> I don't think most Google employees are allowed to adjust the index.
08:28:53 <Jafet> And those that are tend to have a policy of generally not doing it.
08:29:10 <applicative> but they know who to mention it to.  it's all google's fault, there's no corruption in this.  it's a defect of their approach.
08:29:30 <osfameron> does hoogle have linkable pages?
08:29:45 <osfameron> e.g. instead of http://www.haskell.org/hoogle/?hoogle=head "http://www.haskell.org/hoogle/head"
08:29:48 <Jafet> Well, fixing it manually provides clearer evidence of a fault than the fault itself.
08:30:30 <Jafet> Or in other words, there is corruption, but it's endemic!
08:30:35 <osfameron> as google's algorithms might not like the ?param version as much as the url one
08:30:50 * hackagebot dtd-types 0.3.0.1 - Basic types for representing XML DTDs  http://hackage.haskell.org/package/dtd-types-0.3.0.1 (YitzGale)
08:30:52 * hackagebot dtd-text 0.1.0.0 - Parse and render XML DTDs  http://hackage.haskell.org/package/dtd-text-0.1.0.0 (YitzGale)
08:31:41 <Egbert9e9> how do you call the [Model.cellText := ind] kind of syntax?
08:31:49 <Jafet> Haddock coalesces entire modules onto one page... perhaps unappealing to googlebot.
08:32:39 <byorgey> Egbert9e9: I don't think it's special syntax.  It is just using an operator named :=
08:32:47 <byorgey> and [ ] means to create a singleton list
08:32:49 <applicative> yes, haddock is definitely doing something wrong from that point of view.  someone needs to think this out, I think.
08:33:27 <applicative> would it be easy to make hoogle have a 'page' haskell.org/hoogle/openFile for each function in base, say?
08:33:37 <Egbert9e9> byorgey: hmmm, okay
08:33:59 <byorgey> Egbert9e9: is there some code in particular you are trying to understand?
08:34:33 <applicative> Egbert9e9: it looks like a list, thats the [   ]. then := is no different from +
08:34:39 <applicative> > [1+1]
08:34:40 <lambdabot>   [2]
08:35:02 <applicative> the semicolon shows that := is a constructor, though
08:35:10 <applicative> or am I forgetting something
08:35:19 <Jafet> applicative: why stop at base? That seems fairly arbitrary.
08:35:33 <applicative> Jafet, yes,
08:36:23 <applicative> but if osfameron is right, there would be a big win from little programming torture
08:36:31 <Jafet> If you extend it to all hackage, then you might as well modify haddock. And I think you shouldn't modify haddock just to appease googlebot when it parses one particular copy of online documentation
08:36:46 <Jafet> Then again, I don't think that makes it worthwhile to modify Hoogle (the website) either
08:38:02 <applicative> Jafet, I was just thinking the main thing is to beat out the zvon menace.
08:39:50 * hackagebot todos 0.5 - Easy-to-use TODOs manager.  http://hackage.haskell.org/package/todos-0.5 (IlyaPortnov)
08:46:22 <Jafet> And the Communists, don't forget the Communists
08:47:03 <Silvah> What Communists?
08:47:22 <applicative> the Red Menace, the Zvon Menace, the OO Menace
08:50:10 <applicative> the response of haskellers to g. bracha 'types are anti-modular' is so far leaving me completely confused.
08:50:27 <ezyang> How so?
08:51:14 <applicative> oh ezyang, i was just trying to open the paper you linked to see if i could get a clue
08:51:33 <ezyang> Actually, now that I've vaguely read his argument, my link is kind of a non-sequitur
08:51:53 <ezyang> His particular argument is quite different from the problems Pierce is talking about.
08:52:34 <applicative> I see, youve figured it out then
08:53:01 * ezyang isn't sure what he's figured out ^_^ 
08:53:53 <applicative> i didn't mean, seen all the way to the bottom of g bracha's thought, and whatever the truth is...
08:54:33 <ezyang> I think he's making some argument about separate compilation.
08:54:52 <ezyang> Strike out the word "modularity"; it has too many extra meanings to be useful in this particular case. It's a very technical argument.
08:55:28 <applicative> the thought is then that types impede separate compilation somehow?
08:55:40 <applicative> i guess that's obvoiusly part of his meaning
08:55:44 <lispy> ezyang: ping!
08:55:48 <lispy> ezyang: how's it going?
08:56:03 <lispy> ezyang: I have questions for you about that thing you tried to help me with a while back related to that stuff
08:56:04 <ezyang> lispy: Heya! I have six hours of exams tomorrow! :-)
08:56:11 <lispy> ezyang: yikes!
08:56:16 <lispy> ezyang: I'll ask you again later :)
08:56:18 <ezyang> But no problem, I'm goofing off right now.
08:56:19 <lispy> ezyang: study well
08:56:30 <ezyang> applicative: Yeah, something like that.
08:56:35 <lispy> (good luck, though I know you won't need it)
08:56:43 <ezyang> lispy: I can't do any investigative work, but I can answer it if I can...
08:57:06 <lispy> ezyang: Well, do you remember how I was using a makefile from inside Setup.hs to build a library?
08:57:16 <ezyang> Ahhh, yes, I remember.
08:57:41 <lispy> ezyang: Do you have the sample Setup.hs still?  I tried to find it but I seem to have lost it.  At the time I just made the static version work now Conal wants the dynamic version to work
08:57:55 <lispy> ezyang: I hacked in back in the way I think it should go but ghci segfaults when I run a function from the library
08:58:05 <lispy> I ran ghci in gdb but no dice
08:58:18 <lispy> Not sure how else to debugger this
08:59:09 <lispy> The only other thing I can think to try is deleting/moving the static/dynamic libraries to see that ghci is using it and that it uses the right one
08:59:17 <lispy> Other than that I'm kind of out of ideas
08:59:55 <ezyang> looks like this is the one: http://hpaste.org/44744/setuphs_with_usbuilt_librari
09:00:11 <ezyang> but if it's linking, then it's probably a different problem.
09:00:19 <dolio> applicative: He's just wrong. Types don't prevent separate compilation.
09:00:22 <ezyang> Here's a question: did you initialize the FFI binding?
09:00:35 <applicative> bracha's argument seems to turn on 'user defined types' especially too.  if somehow all possible haskell types, or isomorphism classses, had canonical names ..?
09:00:53 <applicative> dolio, what is he saying that's valid?  he must be thinking something ?!
09:00:58 <ezyang> i,i Modules are not modular!
09:01:03 <lispy> ezyang: It's segfaulting when I call the libraries initialize function :)
09:01:07 <ezyang> (since they all live in a global namespace :-)
09:01:09 <ezyang> ouch!
09:01:32 <lispy> Graphics.UI.GLFW.initialize is the segfaulter
09:01:35 <dolio> Just because he's thinking something doesn't mean it's right.
09:01:35 <ezyang> Is this on Linux?
09:01:51 * applicative needs to return to his sml studies to grasp the module concept better
09:01:54 <lispy> ezyang: osx, i could possible still use the osx valgrind port if taht's what you're thinking
09:01:57 <ezyang> dolio: It's worthwhile trying to figure out if they're trying to say something sensible.
09:02:05 <ezyang> Does it segfault on Linux?
09:02:21 <ezyang> I don't think I ever actually tested this trick on OS X
09:02:29 <lispy> I can let cabal/ghc do the full build on linux.  I only need to use a makefile on osx due to objective-c
09:02:47 <lispy> ezyang: I also sent joel an email asking for help
09:02:52 <dolio> He's saying that, for instance, in Haskell, the compiler must consult other modules to determine their type interface.
09:02:55 <dolio> That's true.
09:02:57 <lispy> ezyang: I bet when he gets back to me he'll know more
09:03:06 <ezyang> Right, but can you load it in ghci (ostensibly there's a dynamic library)
09:03:07 <dolio> But then he's ascribing that to all type systems ever.
09:03:23 <ezyang> Gdb is probably giving you useful info, but you don't know how to interpret it. Happens to me all the time.
09:03:43 <lispy> ezyang: I can show you the gdb output
09:03:47 <applicative> dolio, what you say suggests the same is true for ML unless you are fastidious in some way
09:03:54 <dolio> It doesn't really have to do with the type system, either.
09:04:06 <lispy> ezyang: http://hpaste.org/47457/segfault_in_ghci
09:04:13 <dolio> It has to do with how much you can specify in the module system.
09:04:32 <lispy> ezyang: gdb is pretty amazing, but in this case I don't think it's all that helpful
09:04:50 <thoughtpolice> lispy: valgrind 'just works' on OS X now, btw
09:04:59 <dolio> And he hasn't demonstrated either that all type systems require this anyway.
09:05:04 <thoughtpolice> (homebrew users, unite: brew install valgrind to get a working valgrind 3.6.1)
09:05:19 <ezyang> Do you have a debugging copy of GHC lying around? Might have to build one.
09:05:20 <lispy> thoughtpolice: that's what I've heard.  Do you think it will help much?
09:05:30 <thoughtpolice> lispy: looking at backtrace...
09:05:30 <ezyang> That trace looks like there ought to be symbols, but there's not.
09:05:33 <lispy> ezyang: Oh, good point.  I do not.  I could build one.
09:06:00 <thoughtpolice> lispy: (chat backtrace i mean.) oh, segfault? hm. maybe not, but if there's something fishy going on, it may be able to tell you about e.g. bad pointer writes or somesuch
09:06:04 <ezyang> also, compiling the ObjC with debugging info would also probably be good.
09:06:06 <thoughtpolice> memcheck will do a lot of nice things like that for you
09:06:07 <tsuraan_> can you use ghc --make with ghc -prof?
09:06:08 <lispy> I need to go break the fast so I can meet my lady friend.  So this will have to wait, but thanks muchly for the helps.
09:06:08 <dolio> applicative: You probably can just reference other modules in ML. Because sometimes people don't give a shit about whether you can completely separate two modules at compile time.
09:06:14 <ezyang> you should also try 'disas' on the code block.
09:06:18 <ezyang> bye bye!
09:06:25 <lispy> ezyang: I did that part, -g to gcc
09:06:35 <tsuraan_> the profile doc says to use "-o", but linking doesn't seem to work if I just do that
09:06:38 <ezyang> it doesn't seem to have found it, judging from the error messages.
09:06:51 <lispy> Yeah... :(
09:06:55 <lispy> anyway, thanks!
09:06:57 * lispy has to run
09:07:44 <dolio> But you can also explicitly program to a module interface, in which case you're not referencing any other code or modules.
09:07:55 <tsuraan_> nm, lazyness strikes again :(
09:08:31 <applicative> tsuraan_, accept laziness!
09:08:50 * ezyang goes library wrads. 
09:08:54 <ezyang> *Wards
09:09:57 <tsuraan_> applicative: I like a lot of the power of lazyness, but when I have a main that does nothing but "return $ myfn args", I expect myfn to be called :)  Replacing with "return $! myfn args" is easy, but I forget and it confuses me
09:12:27 <applicative> tsuraan_: yes of course. wasn't being too serious.  but of course do { args <- .......; return $ myfn args} is fmap myfn args
09:12:55 <applicative> somehow it would be silly for, say, fmap head (readFile "foo") to read the whole file just to find out what the first char is
09:13:22 <applicative> pardon ludicrously unsafe example
09:13:55 <tsuraan_> so, I have a tiny code snippit here: https://gist.github.com/1009130 .  My profiling output shows that 99.5% of my time is spent in runBS, but only 42.5% of my time is spend in BS.foldl.  can somebody recomend another place to put SCC annotations to see where the other half of my time is being spent?
09:16:04 <Jafet> What about allocations?
09:16:09 <tsuraan_> profiling also shows that I am allocating 5GB to process that 16MB bytestring; I think the only allocation being done is in the tuple that I'm carrying around to keep track of my index and my "hash".  is there some trick to get rid of that tuple?
09:16:13 <Jafet> Perhaps you should post the profile report.
09:16:20 <tsuraan_> one sec
09:16:41 <tsuraan_> https://gist.github.com/1009135
09:16:59 <tsuraan_> so, a ludicrous amount of allocation
09:17:23 <tsuraan_> given that the idea would be about 16MB
09:17:29 <tsuraan_> *ideal*
09:19:14 <Jafet> Well, compiling your code with -Wall immediately suggested a problem.
09:19:19 <Jafet> Can you spot it?
09:21:04 <applicative> nice warnings
09:21:46 <tsuraan_> so the defaulting idx to Integer is fixed by making the initials to foldl be (0 :: Int, 0) instead of (0, 0)
09:22:19 <tsuraan_> didn't change the behaviour though
09:22:44 <tsuraan_> still 5GB allocated.  profile looks basically the same
09:24:38 <Jafet> Well, we have that out of the way.
09:25:03 <tsuraan_> is there an unboxed STRef that I could keep the index in?  Would that be a sane use of ST?
09:25:45 <Jafet> That probably won't help.
09:26:00 <tsuraan_> ok
09:26:34 <tsuraan_> I wouldn't be able to update the value in the foldl anyhow, would I?
09:26:35 <Jafet> Just to be sure, I'd add a cost-centre to fn.
09:26:39 <tsuraan_> ok
09:26:45 <osfameron> cost-centre?
09:27:34 <Jafet> You could, but I'm sure GHC can do it the right way once you find out what's wrong.
09:27:58 <tsuraan_> and I am using ghc 6.12
09:28:09 <tsuraan_> I have 7.0.3 on some other machines, if you think that would make a difference
09:29:46 <Jafet> Also, I didn't know main could :: IO a, where a isn't ().
09:31:08 <tsuraan_> new code: https://gist.github.com/1009142 new prof: https://gist.github.com/1009143
09:31:29 <tsuraan_> yeah, I did think that type was sort of weird.  it doesn't seem to hate that though
09:32:03 <tsuraan_> if I take the strictness off of the "h" parameter to fn, it allocates 3.5GB instead of 5GB
09:33:11 <tsuraan_> and it also cuts the run time from 32s to 10.8s
09:33:34 <tsuraan_> that's sort of weird; is fromIntegral slow to convert a word8 to a word32?
09:37:08 <tsuraan_> yeah, weird.  If I change "upd wrd" to give "0 :: Word32" and keep the h parameter to fn strict, it allocates 3.3GB; if I let "upd wrd" be "fromIntegral (0 :: Word8)" it allocates 5.5GB
09:37:37 <tsuraan_> so fromIntegral isn't very fast on word types
09:37:43 <KirinDave> tsuraan_: That seems odd
09:37:52 <KirinDave> tsuraan_: Can you reproduce it in a minimal context?
09:38:16 <tsuraan_> I'll give it a shot
09:39:01 <kmc> why are you trying to minimize allocation?
09:39:07 <kmc> is GC taking a significant amount of time?
09:39:45 <tsuraan_> kmv: I'm guessing that allocation is what's hurting my performance, but I'm really not sure.  it seemed like something to attack
09:39:49 <kmc> Jafet, yeah, i think that's a bug... it should at least warn, the way "do" warns now when you discard a non-() result
09:40:09 <kmc> tsuraan_, did you run with:  ./myprog +RTS -s
09:40:18 <kmc> probably so, if you have the allocation figures
09:40:28 <kmc> it should tell you what percentage of your time was spent on GC
09:40:53 <kmc> also you can try like +RTS -A400M
09:41:05 <kmc> which increases the size of the allocation area to 400M, so GC will happen much less frequently
09:41:16 <tsuraan_> does this prof give allocation figures: https://gist.github.com/1009143 ?  I don't see it, anyhow
09:41:35 <Jafet> Productivity  99.6% of total user, 57.1% of total elapsed
09:41:54 <kmc> anyway try out +RTS -s
09:42:04 <tsuraan_> ok
09:42:12 <tsuraan_> without profiling running?
09:42:19 <kmc> yeah
09:42:27 <Jafet> On the other hand, it is suspicious for 32-bit checksumming to use that much time
09:43:37 <tsuraan_> here's the output of +RTS -s : https://gist.github.com/1009155
09:43:58 <tsuraan_> what does MUT mean?
09:44:38 <dons> time spent actually evaluating your program
09:44:42 <dons> not in the GC
09:44:58 <dons> this was known as the "mutator" in old graph reduction models of lazy evaluation, since that was the time spent mutating the graph
09:45:24 <vitka> I thought it was "mean user time".
09:45:26 <vitka> lol
09:45:33 <Jafet> Oh hi, it's dons
09:45:41 <Jafet> Your problem is half-solved
09:45:41 <dons> vitka: hehe
09:46:00 <tsuraan_> ?
09:46:15 <tsuraan_> aha
09:46:23 <KirinDave> tsuraan_: Dons is considered one of the more loquacious and helpful authorities on these sorts of problems.
09:46:48 <dons> trying to find an early reference for "mutator"...
09:46:52 <KirinDave> So I don't mean to be "that guy"
09:47:06 <KirinDave> But isn't this sort of pattern far better suited to an iteratee approach?
09:47:13 <KirinDave> Which would also make the space use easier to reason about.
09:47:58 * hackagebot hscolour 1.19 - Colourise Haskell code.  http://hackage.haskell.org/package/hscolour-1.19 (MalcolmWallace)
09:48:13 <KirinDave> (I understand that is not really answering the question, but...)
09:48:26 <tsuraan_> KirinDate: about the minimal test case for fromIntegral being "slow", here's an attempt.  code: https://gist.github.com/1009162, results: https://gist.github.com/1009165
09:49:03 <KirinDave> Jeeez bench is an amazing packaged
09:49:11 <tsuraan_> I think iteratees are higher-level than I want right now; I'm just trying to access two different locations in a bytestring :)
09:50:09 <tsuraan_> so that "benchmark" I posted is comparing id to fromIntegral; in C I think they'd be close to the same speed, but I honestly haven't tried it.  I think it's just a register load though
09:51:55 <vitka> What about -O2? Maybe it'll optimize it away.
09:52:11 <Jafet> I assume we've all been using -O2.
09:52:33 <tsuraan_> I've been using O3
09:52:47 <applicative> what does O3 do?
09:52:53 <Eduard_Munteanu> In many (most?) cases it's not even a register load.
09:52:59 <tsuraan_> not a clue :)  I'm a gcc user
09:53:20 <KirinDave> O2 is where fusion starts happening
09:53:48 <tsuraan_> O3 is slightly faster than O2, in the fromIntegral speed test, according to criterion
09:53:49 <KirinDave> right?
09:54:08 <Eduard_Munteanu> Like in Word64 -> Word32 you should just take the lower 32 bits via %e* on x86-64
09:54:21 <applicative> tsuraan_: It doesn't matter here, but where you are trying to be wildly strict, these tuple types can be misleading
09:54:31 <Eduard_Munteanu> tsuraan_: there's no O3 in GHC
09:54:38 <applicative> in fn (!idx, !h) w = (inc idx, upd w))
09:54:39 <Eduard_Munteanu> well, except -optc-O3
09:54:52 <tsuraan_> misleading how?
09:55:11 <applicative> the tuple constructor itself is lazy (,)
09:55:34 <tsuraan_> doesn't destructuring it in the function call force evaluation?
09:55:35 <applicative> its not mattering here since its all arithmetic and everything needs to be known.
09:55:36 <dons> well, i could find mutators described by around 1988. though earlier papers by augustss et al don't use that term
09:55:53 <dons> so i want to say circa G-machine era, though can't confirm
09:58:32 <Jafet> "Mutator" has been used since the lisp days
09:59:01 <applicative> tsuraan_ see the discussion around slides 29 - 30 in tibbe's primer  http://www.slideshare.net/tibbe/highperformance-haskell
09:59:02 <Jafet> At least, this paper by Baker mentions it as if it were a standard term.
09:59:43 <dons> ah, good ref.
10:00:32 <applicative> tsuraan_: the definition of mean goes wrong surprisingly on p 29 .  the attractive solution is the Strict Pair definition a few slides later.
10:00:32 <dons> actually, looks like GC folklore
10:01:04 <applicative> tsuraan_: I think this doesn't bear on your case, though. I just mention it as possible trap in the future.
10:01:30 <KirinDave> Perhaps we should focus on actually helping tsuran make his code faster?
10:01:49 <KirinDave> I don't meant to break the reverie, but I suspect that's what interests him far more than historical references or future pitfalls. :)
10:01:50 <tsuraan_> thanks for the info.  I actually had that slide set open already; it's quite a bit to get through :)
10:01:52 <applicative> I was going to say, tsuraan_ act fast before dons vanishes!
10:01:55 <tsuraan_> hehe
10:01:57 <Jafet> I can't read core really well, but it looks like the pair gets unboxed anyway.
10:02:12 <KirinDave> dons: Can I invoke you like Suarez's daemon? I could give you a few drops of blood to help him, too.
10:02:48 <dons> mmm
10:03:04 <dons> looks like a good novel, i should read this!
10:03:07 <dons> thanks for the ref :)
10:03:28 <KirinDave> dons: Suarez's Daemon series is _amazing._
10:03:39 <KirinDave> dons: And the audible reading is, similarly, a work of art.
10:03:56 <dons> ah, "mutator" was invented by .... Djikstra!
10:04:00 <applicative> tsuraan_ maybe it would help if people had a clearer idea of where this is going, this is a rather opaque fragment.....
10:04:09 <KirinDave> dons: The kevin bacon of computing
10:04:18 <tsuraan_> yeah, it's getting sort of disjoint
10:04:26 <tsuraan_> working on a more clear example
10:05:29 <kenjin2201> Is Haskell only for smart people? It took a really long time for me just to grasp the idea of monad. And then there's monad transformer. Do those really get accustomed to..even to average minds like me?
10:06:12 <Jafet> Some people have similar thoughts about arithmetic and literacy.
10:06:17 <Tomsik> kenjin2201: it's not hard, it's just different
10:06:33 <Tomsik> kenjin2201: like, many people have trouble with pointers in C
10:06:44 <kenjin2201> Tomsik : Maybe it's just that you dont realize you are actually a smart person
10:06:46 <tsuraan_> um, so I think that hint way above, about using Int instead of the guessed Integer, actually was the problem :-/
10:06:54 <pikhq_> "Trouble with pointers" is really overstating it.
10:07:03 <pikhq_> Erm, under.
10:07:06 <pikhq_> Understating it.
10:07:13 <KirinDave> kenjin2201: You're trying to rebuild a new foundation for programming.
10:07:23 <KirinDave> kenjin2201: Think back. Learning pointers sucks about as much as learning monads.
10:07:41 <tsuraan_> so to answer kenjin2201, even slow people like me can get Monads given enough effort :)  Still working on getting Haskell though :)
10:07:49 <kenjin2201> I have 3 years experience of Lisp. :(
10:08:23 <jmcarthur> kenjin2201: it's like learning to program all over again, but not like rocket science.
10:08:26 <tsuraan_> so yeah, making the loop that adds up the bytestring index use Int instead of Integer fixed that micro-issue
10:08:30 <Tomsik> kenjin2201: just think about this: when somebody is speaking a few accents of English for years, would it be easy from him to learn Italian?
10:08:59 <KirinDave> kenjin2201: Think back to learning macros, esp defmacro style direct-to-code macros. Learning that at first is really mind-blowing.
10:09:07 <Tomsik> kenjin2201: depends on the flavour of lisp
10:09:22 <kenjin2201> Macros were way simpler to me than monad transformers
10:09:27 <KirinDave> kenjin2201: Now imagine instead of something kinda perched on top of the rest of the language (like macros), instead you're doing stuff way at the bottom (structure of functional, lazy programs)
10:09:46 <KirinDave> kenjin2201: I'm saying, the thing is that it's harder because more has to rest on it.
10:10:03 <kenjin2201> I'm not being agressive here.... Is it worth?
10:10:05 <KirinDave> It's like you're reading multivariable calculus when you don't know what a "limit" is.
10:10:13 <KirinDave> kenjin2201: I like it. YMMV.
10:10:57 <kenjin2201> Ok...then say I somehow got it....is it really worth trying it?
10:10:59 <applicative> kenjin2201, have you used Parsec ?
10:11:04 * hackagebot sbv 0.9.19 - Symbolic bit vectors: Bit-precise verification and automatic C-code generation.  http://hackage.haskell.org/package/sbv-0.9.19 (LeventErkok)
10:11:19 <kenjin2201> applicative: A little.
10:11:23 <dons> yay. found it.
10:11:24 <dons> It was therefore tempting to investigate whether a second processor--called "the collector"--could collect garbage concurrently with the activity of the other processor--for the purpose of this discussion called "the mutator"-- which would be dedicated to the computation proper. "On-the-Fly Garbage Collection:  An Exercise in Cooperation"  Dijkstra, Lamport, et al. 1978
10:11:36 <dons> http://research.microsoft.com/en-us/um/people/lamport/pubs/garbage.pdf
10:12:12 <kenjin2201> I just finished reading the tutorial "Write yourself scheme in 48 hours". And I thought it's too much just to implement mutable states.
10:12:20 <KirinDave> dons: Haha, first reference on that page nearly ripped my eyes out
10:12:24 <dons> tsuraan_: ^^
10:12:34 <applicative> kenjin2201: I was just going to say, the basic type ParsecT is a monad transformer. It's fairly easy to see why, though the whole thing is a bit complicated admittedly
10:12:36 <KirinDave> dons: Always fun to see your former mentor's name on a piece of paper.
10:12:50 <jmcarthur> kenjin2201: that's only a bad thing if you see mutable state as a golden hammer, though
10:13:30 <kenjin2201> CAn you recommend a easiest tutorial for monad transformer?
10:13:45 <jmcarthur> i wouldn't bother
10:14:01 <Tomsik> If you grasp intuitions about monads you'll understand monad transformers
10:14:02 <KirinDave> kenjin2201: Well you gotta remember, anyone writing a scheme tutorial for haskell for the internet? They're probably going to approach things from a pretty abstract standpoint
10:14:07 <applicative> kenjin2201: I think what you need is a good use case
10:14:10 <KirinDave> I've seen that tutorial, I know how you could do it more easily.
10:14:11 <jmcarthur> just use haskell as you please, and eventually you will ask in here "what's a nice way to design this?" and monad transformers will come up, and you will be enlightened
10:14:13 <Tomsik> they're just monads, litte more complicated, but not much
10:14:16 <tsuraan_> dons: thanks, I think :)
10:14:22 <KirinDave> jmcarthur has it right.
10:14:34 <kmc> kenjin2201, 'all about monads' may be helpful
10:14:35 <kmc> it's a bit flawed though
10:14:41 <Tomsik> complicated as in more complicated than the straightward monads like Maybe or []
10:15:09 <kmc> a monad transformer is a type-level 'function' which takes a monad and gives you another monad
10:15:45 <kenjin2201> Will learning Haskell pay off? It's the hardest language I ever met. And the most interesting at the same time though
10:15:50 <kmc> pay off how?
10:15:53 <jmcarthur> Monads are like analogies.
10:15:57 <kmc> will it make you rich? probably not
10:16:09 <kmc> will it make you a better programmer in other languages? likely
10:16:12 <KirinDave> kenjin2201: Yeah dude, objective value judgements are hard to come by. :)
10:16:16 <kenjin2201> kmc : I dont know...I really dont know
10:16:28 <Tomsik> It will sure make you write better C code
10:16:29 <jmcarthur> to me, that fact this it's interesting was the payoff
10:16:33 <KirinDave> kenjin2201: We see people doing production work in Haskell
10:16:40 <KirinDave> You won't get hired at Square doing that, but...
10:16:48 <osfameron> square?
10:16:51 <jmcarthur> that it turns out to actually be very practical for me is just bonus
10:16:57 <Tomsik> But you'll do work of ten, KirinDave? :p
10:17:26 <kenjin2201> Do you ever see Haskell programmers who aren't very bright? :)
10:17:27 <KirinDave> Tomsik: I'd like to think I already do.
10:17:33 <KirinDave> kenjin2201: I am one.
10:17:41 <kenjin2201> I don
10:17:42 <applicative> kenjin2201: I'm not very bright, i'm not even a programmer....
10:17:50 <KirinDave> kenjin2201: All these people around me here are much better at math and functional programming.
10:18:01 <kmc> in addition to the mind-expansion and what-not, Haskell is actually a great tool for solving many real-world problems.  but the amount you have to learn to get to that point is rather extreme
10:18:28 <Tomsik> Haskell is great for not wasting time debugging
10:18:37 <applicative> kenjin2201: how long have you been studying haskell?
10:18:39 <Tomsik> Not trivial bugs at least
10:18:39 <kenjin2201> It's really fun and frustrating at the same time.
10:18:43 <kmc> another facet to consider: knowing Haskell will help you get a job programming not-Haskell
10:18:56 <kenjin2201> applicative: 2 month..
10:19:05 <Tomsik> Yeah, recruiters are very happy to hire people using FP languages
10:19:11 <Tomsik> it shows that you've got an initiative
10:19:16 <kmc> employers look for Haskell knowledge as a sign of intelligence, even if they have zero intent of using the language
10:19:34 <jmcarthur> which is both a good and bad thing for me
10:19:38 <kmc> right, there's also that -- the fact that you learned something 'useless' shows that you care more about programming
10:19:40 <applicative> kenjin2201: I see.  Maybe you should just take it easy, I think there is an element of 'sinking in', which takes a while.
10:19:52 <kmc> Paul Graham wrote an essay about that -- "The Python Paradox", back before Python was mainstream ;P
10:20:00 <jmcarthur> already hard to find an FP job. even harder when the job ads include FP even though the job doesn't use it
10:20:43 <kmc> all the over-funded Valley hipster startups are using Scala now
10:21:01 <kmc> Scala and Haskell have a lot in common; knowing Haskell will certainly help you get a Scala job
10:21:13 <kmc> and if you're a Haskell fanatic at heart, using Scala will be a lot less depressing than using Java or Ruby
10:22:17 <dons> there are regular jobs on the haskell reddit, however, they are highly skilled (natural result of the current over-supply of FP programmers wrt. jbs)
10:22:20 <dons> jobs
10:22:38 <kmc> does that over-supply also mean they're under-paid?
10:22:51 <dons> no, due to the core requirement for the technology.
10:23:06 <earthy> ;)
10:23:07 <dons> you're paying for good people, not any people. and good people are few and generally already employed
10:23:18 <kmc> then the supply is actually quite low
10:23:20 <applicative> kenjin2201 wasn't worried about the economic aspect, just whether it was going to be flat out too hard for him, or so I thought
10:23:20 <dons> at least that's my experience. the pay is good :)
10:23:27 <dons> of experts? yes.
10:23:34 <kmc> on an unrelated note, LinkedIn's price-to-earnings ratio is over 2,000
10:23:34 <dons> and people are mostly hiring experts
10:23:54 <kenjin2201> yeah right. applicative
10:24:07 <kmc> yes, i think it's worth it
10:24:12 <kmc> if you like a challenge
10:24:34 <kmc> it's certainly very common to be frustrated learning haskell
10:24:45 <kmc> partially because Haskell is hard.  partially because it's different
10:25:00 <kenjin2201> I have to admit it's really fun to learn Haskell.
10:25:09 <applicative> kenjin2201: I would think 2 months is probably one of the times one hits a wall.
10:25:09 <earthy> partially because even haskell has hysterical raisins
10:25:43 <tsuraan_> ok, so here's a closer-to-what-I'm-doing example.  code is here: https://gist.github.com/1009218 profile is here: https://gist.github.com/1009219
10:26:04 <tsuraan_> and, I lost dons :(
10:26:10 <tsuraan_> but, there are lots of other people here :)
10:26:11 <kenjin2201> applicative: It was really great before I see tons of monads at the same time.
10:27:11 <applicative> kenjin2201: yes it's too much to assimilate at once, and then you think the secret is a general grasp of the monad concept
10:27:23 <stulli> kenjin2201: Don't try to understand monads right now, just use them and get a feeling for it.
10:27:24 <earthy> kenjin2201: well, monads you just get used to
10:27:32 <kmc> the various monads don't necessarily have much in common
10:27:35 <tsuraan_> so, the real problem with what I'm doing (now that I know how to profile my code, yay!) is that BS.index is slowing me down a lot.  That seems weird, since in that snippet the distance between my current byte and my byte I'm looking up is 8 bytes, so they should both be in L1 cache
10:27:46 <kmc> "Monad" is just the name of an API that they share, but implement differently
10:27:53 <Jafet> tsuraan, dd if=/dev/urandom of=/dev/null bs=16384 count=1024
10:28:21 <applicative> kenjin2201: but you should just fiddle with the ones youre already using, like [] , Maybe , IO , etc.
10:28:54 <tsuraan_> jafet: 16777216 bytes (17 MB) copied, 3.52333 s, 4.8 MB/s
10:29:07 <kenjin2201> Maybe I just thought I'm used to those when I'm not actually.
10:29:27 <earthy> kenjin: yes. that happens.
10:29:47 <Jafet> tsuraan: well, I added a strict pair to your original test case and it became the bottleneck. It now runs at 1 second here, allocating 1GB.
10:30:00 <MHD> man, SSA is weird...
10:30:22 <MHD> or rather, cramming an SSA into a Writer monad is weird.
10:34:41 <tsuraan_> jafet: doing the same on this lowered the runtime from 19.48 down to 3.46
10:34:44 <tsuraan_> so, awesome
10:34:46 <tsuraan_> thanks!
10:35:14 <stulli> Huh, there is no getStr in hscurses?
10:35:54 <jbh> hello, guys! somebody here using xmonad? i would need some help with the configuration
10:36:21 <Jafet> stulli: potentially ambiguous semantics, perhaps. (Should it echo, for instance?)
10:36:34 <dons> jbh: try in #xmonad
10:36:57 <jbh> dons: already tried. nobody replies there
10:37:12 <tsuraan_> using strict pair, the bytestring iteration runs at 186 MB/s.  awesome!
10:37:37 <KirinDave> Wait
10:37:42 <Tomsik> Jafet: I think echo is set as separate option
10:37:47 <KirinDave> tsuraan_: Would you mind pasting the final simplified version?
10:37:56 <KirinDave> tsuraan_: I've been following along with your epic quest. :)
10:38:32 <stulli> Tomsik: Yes, you are right
10:38:37 <Jafet> Often you control echo by turning it off in the terminal and then simulating it yourself
10:39:01 <Jafet> There are some higher-level libraries on curses that do these things
10:39:36 <kmc> Haskell has this vty library
10:39:55 <stulli> I'm just reading the ncurses documentation where wgetStr() got mentioned, just wondering why it's not in hscurses
10:39:57 <applicative> kenjin2201: no you understand Maybe and [] just fine, the 'monadiness' of [] boils down to the possibility of getting into list-land with [x] and of keeping from having to go into list of list of list of land with concat
10:40:04 <kmc> ncurses itself is about the worst library you could ever invent
10:40:25 <kmc> in particular the monadiness of [] is exactly the same as list comprehensions
10:40:36 <tsuraan_> KirinDave: here's the final solution: https://gist.github.com/1009232
10:40:36 <Jafet> Well, it's not so bad when you consider that it's for you to interface to 1970s terminals.
10:41:03 <kmc> « do { x <- xs; y <- ys; return (f x y) } »   ==>   « [f x y | x <- xs, y <- ys] »
10:41:33 <KirinDave> tsuraan_: Thank you.
10:41:41 <applicative> tsuraan_: so the strict pairs did help
10:41:48 <tsuraan_> yeah, the strict pairs did it
10:42:23 <tsuraan_> I still don't understand why; I thought that using bang patterns in a destructuring assignment did the same thing, but I'll figure it out
10:42:48 <stulli> kmc: Thanks for the tip, i'll check vty out for sure. ncurses is giving me headaches already.
10:43:08 <applicative> tsuraan_: yeah, it's incredibly simple but somehow hard to see, like a lot of things in haskell, i suppose
10:43:33 <tsuraan_> yeah, haskell is crazy.  there's a lot to love, and a lot to learn.  I'll get it eventually
10:44:07 <kmc> tsuraan_, well, the strict pair is strict on *creation*
10:44:18 <kmc> if you force (PS x y) then you also force x and y
10:44:48 <kmc> destructuring with bang-patterns would force it when you use the value, no?
10:45:00 <KirinDave> It seems to me
10:45:11 <KirinDave> that lazy tuples cause a lot of problems in #haskell
10:45:43 <Jafet> Yes, but you use the value on the next iteration. Maybe it adds up.
10:45:54 <kmc> without a new datatype, to get strict pairs you'd need to always construct them as like «x `seq` y `seq` (x,y)»
10:46:14 <kmc> :t let sp x y = x `seq` y `seq` (x,y) in sp
10:46:15 <lambdabot> forall a a1. a -> a1 -> (a, a1)
10:46:32 <kmc> :t let sp !x !y = (x,y) in sp
10:46:33 <lambdabot> Illegal bang-pattern (use -XBangPatterns)
10:47:35 <tsuraan_> is the problem that I need to force evaluation in the return of the function, and not in the call of the next function?
10:48:02 <tsuraan_> I was thinking that "f (!x, !y) = ..." was the same as "f (SP x y) = ...",
10:48:35 <tsuraan_> but is the issue actually that "... = (x,y)" is not the same as "... = SP x y"?
10:48:56 <kmc> well, just saying (SP x y) doesn't force anything either
10:49:09 <KirinDave> tsuraan_: I always thought de-structuring didn't necessarily cause use.
10:49:11 <kmc> there's no "absolute" way to force stuff... you can only add rules of the form "if you force x, force y first"
10:49:14 <kmc> that's what seq does
10:49:24 <kmc> the SP type has the rule "if you force (SP x y), force x and y first"
10:49:34 <KirinDave> kmc: Isn't there a thing to go to hnf in Control?
10:50:13 <tsuraan_> and BS.foldl forces whatever is returned by the given function
10:50:19 <kmc> KirinDave, what's your point?
10:50:33 <KirinDave> kmc: Wouldn't that be another way to do it?
10:50:34 <tsuraan_> so if you return a tuple, you get nothing (unless using seq).  if you return SP, it evaluates SP's contents
10:50:58 <Jafet> Hmm. What about foldl'?
10:51:00 <kmc> why does foldl force it?
10:51:02 <kmc> foldl' would
10:51:10 <tsuraan_> and to be clear with my code, I should be using BS.foldl', but BS.foldl is the same as BS.foldl' in that case
10:51:12 <Jafet> I forgot about that.
10:51:19 <kmc> KirinDave, do you mean normal form, not head normal form?
10:51:35 <kmc> i mean a term in nf is *also* in hnf and whnf
10:51:43 <kmc> but there's no way to force "only" to hnf
10:52:14 <KirinDave> kmc: I was under the impression that Control.Parallel rnf did that?
10:52:27 <kmc> doesn't rnf reduce to normal form?
10:52:32 <KirinDave> "Reduces its argument to (head) normal form."
10:52:37 <kmc> hmm
10:52:41 <KirinDave> So sayeth docs
10:52:41 <kmc> confused
10:52:47 <KirinDave> http://hackage.haskell.org/packages/archive/parallel/1.1.0.1/doc/html/Control-Parallel-Strategies.html#t:NFData
10:53:13 <Jafet> I suppose that is intended as "normal form (and head normal form)"
10:53:37 <kmc> hmm, i was confused because i know it doesn't reduce under lambda
10:53:46 <kmc> but i think that's okay, because ther's no NFData instance for (a -> b)
10:53:51 <Jafet> ...which is what rnf does.
10:54:00 <kmc> so all the lambdas that appear are fully applied
10:54:28 <Jafet> I can't imagine any such instance without liberal amounts of magic
10:54:43 <Jafet> From the runtime, that is
10:55:08 <kmc> yeah
10:55:36 <Jafet> As a side note, rnf is also known as deepSeq.
10:55:39 <KirinDave> But there is an instance for tuples?
10:56:35 <kmc> yes
10:57:03 <Jafet> rnf (a, b) = rnf a `seq` rnf b `seq` (a, b)
10:57:31 <Jafet> See kmc's "forcing rule" rule to understand why it works
10:57:42 <kmc> yeah, rnf does not violate that rule
10:57:52 <kmc> it just forces further (recursively)
10:58:11 <kmc> there is no f such that merely writing (f x) anywhere causes x to be forced
10:58:22 <Jafet> Also note that the class is named NFData... clearly they already knew the limitations
10:58:36 <Jafet> (Otherwise it could just be called `NF')
11:00:11 <KirinDave> okay
11:02:00 <Favonia> the semantic of Haskell is non-strict almost everywhere, even if you write "(x `seq` f x)", the whole thing is just another pending computation. seq just forces x to be reduced first
11:02:59 <Favonia> oops, I should say lazy evaluation. it is possible to implement non-strict by something other than lazy evaluation
11:03:23 <Favonia> GHC uses lazy evaluation anyway
11:03:27 <jmcarthur> but haskell is specified to be non-strict, not lazy
11:03:38 <jmcarthur> yeah, ghc should be the subject here
11:03:52 <Favonia> jmcarthur: yes, I know that :) sorry for my imprecise languages
11:04:15 <jmcarthur> np
11:04:33 <Favonia> Haskell is non-strict, and GHC implements it with lazy evaluation
11:05:09 <Tomsik> Well, GHC is not lazy
11:05:22 <Tomsik> It performs strictness analysis
11:07:11 <Favonia> Tomsik: well personally I treat that as some kind of optimization... but your point is taken
11:07:38 <Jafet> GHC is supposed to produce programs whose running time resembles that of strict code, semantics resembles that of lazy code, and memory usage resembles that of non-strict code.
11:07:46 <Jafet> It's a thankless job!
11:08:22 <Tomsik> To realize what laziness means you have to glance at Algol for a second
11:08:39 <Tomsik> Or at least lazy evaluation of real lambda calculus
11:08:57 <Jafet> Many Algol compiler writers were lazy in implementing laziness
11:09:12 <earthy> um?!
11:09:13 <Favonia> Jafet: about memory usage, I thought strict code uses less memory
11:09:24 <Favonia> Jafet: (?)
11:09:29 <earthy> jafet: which algol? which laziness? :)
11:09:41 <Twey> Favonia: Strictness means loading everything into memory at once
11:09:45 <Twey> So no
11:09:59 <jmcarthur> Jafet: don't you mean to swap non-strict and lazy in that statement?
11:10:32 <earthy> or did you mean call-by-name parameter passing as it existed in Algol 60? :)
11:11:02 <Jafet> Consider memory usage of let x = [1..n] in (sum x, length x) when evaluated using call-by-name versus call-by-need
11:11:14 <Jafet> Memory residency, that is
11:12:17 <Favonia> Twey: no, it just means whether to reduce arguments to values first
11:12:48 <earthy> ah
11:12:50 <Twey> Favonia: Fully reduce, yeah… so what happens when you pass a big list?
11:13:00 <Tomsik> earthy: call-by-name is for sure lazy
11:13:04 <Jafet> Well, a term that generates a big list
11:13:13 <Twey> Well, yes :þ
11:13:20 <jmcarthur> Tomsik: you mean non-strict
11:13:29 <Favonia> Twey: the only insane way to do that in a strict language, is to simulate lazy evaluation, I guess
11:13:32 <jmcarthur> Tomsik: laziness usually is meant to imply sharing
11:14:01 <Twey> That's why strict languages have pointers and references and macros and other means of avoiding truly strict calling
11:14:04 <Favonia> Twey: s/insane/sane/
11:14:35 <jmcarthur> is it possible to have a useful language that is completley strict?
11:14:56 <jmcarthur> *completely
11:14:57 <Jafet> That used to be a stereotype of C++
11:15:15 <Tomsik> jmcarthur: I thought it's the other way around
11:15:21 <Favonia> Twey: I know. but then there is a overhead. also sometimes you would have large pending unreduced computations
11:15:38 <Jafet> "In C++, you make a dozen copies of yourself and shoot them all in the foot"
11:15:38 <Favonia> Twey: I would say that there is a trade-off
11:15:55 <jmcarthur> Tomsik: a function is strict if f _|_ = _|_. a function is non-strict when it is merely not strict.
11:16:03 <Twey> Favonia: Sure, but it's never going to be as big an issue as loading a massive list into memory all at once.
11:16:10 <Twey> Or, gods forbid, an infinite one ;)
11:16:19 <jmcarthur> Tomsik: but that says nothing about sharing
11:16:25 <jmcarthur> i should stop here
11:16:33 <jmcarthur> this is not what people talk about when a language is "non-strict"
11:17:09 <Favonia> Twey: please understand that I like Haskell more than SML. there is absolutely no reason try to convince me that Haskell is better :P but there is a trade-off anyway
11:17:22 <Twey> Favonia: I'm not trying to :þ
11:17:24 <Tomsik> jmcarthur: I was told that call-by-name lambda calculus evaluation strategy is canonical "lazy"
11:17:42 <Twey> I don't believe that SML implements strictness in the way that is meant here
11:17:49 <Twey> No sane language would
11:18:06 <Favonia> Twey: hmmm what did you mean?
11:18:17 <jmcarthur> Tomsik: let me just rewind here...
11:18:26 <jmcarthur> Tomsik: a non-strict language allows you to define and use non-strict functions
11:18:54 <jmcarthur> Tomsik: call-by-name and call-by-need both satisfy that
11:19:05 <Tomsik> Okay, I see what you mean now
11:19:12 <jmcarthur> Tomsik: laziness is when you add sharing to that
11:19:28 <Favonia> Tomsik: to be precise, actually (un-optimized) GHC uses (almost) call-by-need, which is call-by-name + sharing
11:19:49 <jmcarthur> ^^
11:20:04 <Favonia> jmcarthur: sorry for my slow typing :P
11:21:19 <Twey> Favonia: With the caveat that jmcarthur is probably going to step in in a minute and say ‘you're totally wrong, Twey’, a truly strict language is one in which you evaluate *everything* as soon as it is passed, which means that if you pass a large term around, you use a large amount of memory, even if you don't need to use the value, since it's implemented before the function is ever called
11:21:27 <Twey> Favonia: Like C does
11:21:53 <jmcarthur> i approve
11:22:02 <jmcarthur> err
11:22:07 <Twey> Heh
11:22:07 <jmcarthur> except for the thing about C ;)
11:22:11 <Jafet> In this context, "strict" usually refers to applicative-order evaluation for lambda calculus
11:22:14 <Twey> C does, doesn't it?
11:22:24 <Jafet> Which reduces terms to normal form, or die trying
11:22:39 <Twey> It just gets around it by using pointers and having a ‘dereference’ operation that is separate from the ‘evaluate’ operation, so you can safely pass a pointer and have it fully evaluated but leave the big structure unreferenced
11:22:46 <jmcarthur> Twey: if, &&, ||, ?:
11:22:55 <Twey> Oh, yeah, and the magic stuff
11:23:03 <Twey> I was thinking of function calls
11:23:40 <Favonia> jmcarthur: also "andalso" "orelse"
11:23:41 <Twey> unreferenced?  Undereferenced
11:24:05 <Twey> Yeah.  It avoids strictness in many ways.  :þ  But it does have call-by-value.
11:24:22 <Twey> andalso and orelse are in C too?
11:24:37 <Twey> Google says they're C#
11:24:40 <jmcarthur> also, if you really really want to be pedantic, you have to specify what "evaluated" means. in the case of C, a function is evaluated even if there are things to evaluate in its body
11:24:42 <Favonia> Twey: oh I was talking about SML :P
11:24:47 <Twey> Oh, right.
11:25:36 <Twey> jmcarthur: For example?
11:26:19 <jmcarthur> Twey: if it reduced in function bodies then the trick of using a function to simulate a value that is computed on demand would not work
11:27:45 <jmcarthur> of course you can't actually create such a thing dynamically in C without making sort of an interpreter anyway
11:28:43 <Twey> jmcarthur: Oh, you mean when passing a function?
11:28:47 <Twey> … pointer
11:28:56 <Favonia> jmcarthur: technically speaking, eta-equivalence is broken in SML. that's one of the reasons I dislike SML. :(
11:28:58 <jmcarthur> see that makes it even weirder
11:29:24 <jmcarthur> because if you have pointers then the indirection further complicates what you might actually mean by "evaluation"
11:29:59 <Twey> That's what I meant by separating ‘evaluate’ and ‘dereference’ earlier
11:30:03 <jmcarthur> yeah
11:30:10 <jmcarthur> hmm
11:30:17 <Twey> Because after all, functions aren't really values in C, so they can't be passed or evaluated
11:30:23 <Twey> Only function pointers are/can
11:30:36 <jmcarthur> actually, pointers don't have to throw things off that much anyway. it's undefined to assign a null pointer anyway
11:31:02 <jmcarthur> i'm not as sure about pointers to invalid addresses
11:31:41 <Favonia> Twey: hmm I think functions are "defined" to be values in SML, so even if the function body is un-evaluated, it is still fine..?
11:31:53 <jmcarthur> correct
11:31:58 <Twey> Yeah
11:32:05 <Jafet> Also undefined (probably because doing that in many systems being used at the time would actually corrupt other processes or the operating system)
11:32:07 <jmcarthur> this is easier to talk about with SML than C
11:32:16 <Twey> Favonia: I'm talking about C; I don't know much SML, and I would be surprised if just about anything I said WRT C applied to it :þ
11:32:36 <Twey> Alright
11:32:51 <Favonia> Twey: I am sorry :P I am still trying understand "evaluation" and "dereference"
11:33:24 <flamingspinach> can anyone answer my question about ghci? :)
11:33:46 <Twey> flamingspinach: Want to repeat it?
11:33:52 <jmcarthur> to clear something up: strictness doesn't have as much to do with function arguments as it does with what can be bound
11:33:53 <flamingspinach> is the ghci included in the haskell platform for linux compiled with readline? the haskell wiki suggests that the windows binaries for ghci aren't, but that some other binaries of ghci are, but ghci doesn't seem to obey my ~/.inputrc on linux (i.e. vi mode)
11:34:02 <Twey> flamingspinach: No
11:34:08 <flamingspinach> I see
11:34:10 <Twey> It uses Haskeline for licensing reasons
11:34:13 <conal> yesterday, i re-read the first half of "Can Programming Be Liberated from the von Neumann Style?" (http://www.thocp.net/biographies/papers/backus_turingaward_lecture.pdf). quite some gems there! he has some remarks about trying to apply denotational or axiomatic semantics to von Neumann languages, which i see as equally applicable to recent discussions here about 'IO' in Haskell.
11:34:18 <jmcarthur> so i don't just mean function pointers being passed as arguments
11:34:21 <jmcarthur> i mean any function
11:34:30 <Twey> flamingspinach: Unless you have an old version, pre-switch
11:34:33 <flamingspinach> licensing reasons?
11:34:45 <Twey> GHC is BSD-licensed, but readline is GPL
11:34:49 <flamingspinach> ah
11:34:49 <conal> e.g., "Although a great amount of excellent work has been published on proving facts about programs, von Neumann languages have almost no properties that are helpful in this direction and have many properties that are obstacles (e.g., side effects, aliasing)."
11:35:00 <conal> "Denotational semantics and its foundations provide an extremely helpful mathematical understanding of the domain and function spaces implicit in programs. When applied to an applicative language (...), its foundations provide powerful tools for describing the language and for proving properties of programs. When applied to a von Neumann language, on the other hand, it provides a precise semantic description and is helpful in identifying
11:35:01 <conal> trouble spots in the language."
11:35:26 <conal> "But the complexity of the language is mirrored in the complexity of the description, which is a bewildering collection of productions, domains, functions, and equations that is only slightly more helpful in proving facts about programs than the reference manual of the language, since it is less ambiguous."
11:35:58 <conal> then remarks about axiomatic semantics and how it's only tractable with toy subsets of imperative languages.
11:36:20 <conal> and then: "Thus denotational and axiomatic semantics are descriptive formalisms whose foundations embody elegant and powerful concepts; but using them to describe a von Neumann language can not produce an elegant and powerful language any more than the use of elegant and modern machines to build an Edsel can produce an elegant and modern car."
11:37:09 <conal> i think his basic points all hold if you replace "von Neumann language" with "Haskell's IO".
11:37:23 <ehamberg> flamingspinach: put “editMode: Vi” in ~/.haskeline
11:37:28 <Twey> Is Haskell's IO not a von Neumann language?
11:37:35 <flamingspinach> ehamberg: oh cool, thanks :)
11:37:43 <jmcarthur> it is designed to be one, isn't it?
11:37:47 <Jafet> IO is the stone soup language
11:37:49 <ehamberg> flamingspinach: no problem :)
11:37:49 <Twey> That's what I thought
11:38:04 <Jafet> Which kind of proves conal's point, I suppose
11:38:08 <conal> Twey: it is in a perhaps broader sense than people usually mean "language"
11:38:32 <Twey> Maybe
11:39:25 <conal> Twey: e.g., people often call haskell (including IO) "a pure functional language".
11:39:29 <jmcarthur> i've been thinking lately that instead of my tendency to think of IO as a sin bin that i might be more productive to just consider it a foreign function interface
11:39:38 <flamingspinach> ehamberg: it seems to be a little... lacking in vi support though, haha
11:39:41 <Jafet> So how's the field of FRP research coming along, ay?
11:39:45 <flamingspinach> c3w doesn't work properly, for example
11:39:57 <jmcarthur> s/System\.IO/Foreign.IO/
11:40:13 <Favonia> jmcarthur: haha :)
11:40:22 <Jafet> Chinese IO
11:40:23 <ehamberg> flamingspinach: yeah, it's… okay. ;)
11:40:29 <cheater_> flamingspinach, heh
11:40:42 <flamingspinach> oh hey cheater_
11:40:47 <flamingspinach> man, I recognize a lot of people in here lol
11:41:04 <ehamberg> flamingspinach: hmm, c3w works here.
11:41:07 <cheater_> troll.
11:41:22 <conal> jmcarthur: does it give you some kind of helpful clarity to say "FFI" instead of "sin bin"?
11:41:33 <ehamberg> personally i wish people would make vim modes, not vi modes, so that ciw and other “text motions” commands would work :P
11:41:44 <Jafet> One implies guilt; the other implies pragmatism?
11:41:58 <Jafet> Of course, they refer to the same thing.
11:42:07 <cheater_> <3 flamingspinachtroll
11:42:16 <conal> jmcarthur: in both cases, we care about the imperative stuff, and we don't have a denotative ("genuinely functional" in Peter Landin's words) basis for it.
11:42:17 <flamingspinach> ehamberg: odd, it definitely doesn't work here - it just does 3w
11:42:31 <jmcarthur> conal: it permits me to use IO in the implementation of language primitives, whereas calling it a sin bin basically permits nothing with a clean conscience
11:43:13 <conal> jmcarthur: in the implementation of denotationally well-defined primitives?
11:43:27 <jmcarthur> hopefully
11:43:35 <jmcarthur> :)
11:43:49 <Jafet> "One cannot proceed from the informal to the formal by formal means."
11:43:55 <conal> jmcarthur: ah. i'm with you there.
11:44:37 <conal> jmcarthur: one way i try to express what i think is the same perspective is to say that all haskell is built on top of unsafePerformIO except for IO
11:45:19 <Jafet> That seems to be conflating Haskell with its implementations
11:45:22 <conal> jmcarthur: meaning all of the primitive operations.
11:45:39 <conal> Jafet: oops. yes, thanks.
11:45:40 <jmcarthur> yes. that is the kind of bottom-up, operational sense i am thinking of
11:45:56 <conal> Jafet: what i meant by "built", but worth saying so explicitly.
11:46:06 <conal> s/built/implemented/
11:46:10 <conal> for clarity
11:46:48 <jmcarthur> IO is just a more type safe FFI, then
11:48:31 <Jafet> If you consider the computer system to be "IO"...
11:49:02 <jmcarthur> that's not quite what i'm getting at
11:49:23 <conal> jmcarthur: iiuc, you're talking about moving IO *out* of the programming model into the implementation.
11:49:32 <jmcarthur> yes
11:49:44 <conal> jmcarthur: good. me too.
11:49:44 <jmcarthur> even if only philosophically
11:49:59 <jmcarthur> i honestly don't mind IO being around
11:50:14 <conal> sure. for now only philosophically. while we're still figuring out how to program denotatively/functionally
11:52:24 <jmcarthur> i think a lot of the places we are getting hung up are in finding the answers to questions of the form "How do you express <something intrinsic to the way existing programming models work> denotatively?"
11:53:19 <conal> jmcarthur: indeed! "where's my goto?" "where's my assignment?" as if goto or assignment were intrinsic to problem-solving or computation.
11:53:39 <conal> jmcarthur: similarly, "where's my file system?"
11:54:16 <jmcarthur> right, that's where i'm going with it. maybe the file system is another "goto"
11:55:00 <jmcarthur> or maybe it's being placed (again, philosophically) at a low level when it is actually high level
11:55:26 <conal> jmcarthur: yeah. file systems as habitual rather than natural.
11:57:14 <jmcarthur> i find the habit hard to break. not so much with file systems specifically, but with other things which i probably can't even identify because the habits are so ingrained
11:58:03 <dcracked> hey, which kind of steps are required for proper coverage definition?
12:00:29 <conal> jmcarthur: i often wonder what helps people notice (unconscious) assumptions and hence start to wonder about other possibilities.
12:00:32 <Jafet> But how would you respond to "where's my file system"? Is a file system necessarily a means to some end?
12:01:07 <jmcarthur> Jafet: that's also a question i struggle with
12:01:19 <Favonia> conal: force them to learn new things
12:01:45 <Tomsik> You need storage, you need to navigate through it
12:01:56 <conal> Jafet: you could respond by asking a question like "what problem are we trying to solve by choosing to use a file system?"
12:01:57 <jmcarthur> Tomsik: why?
12:02:01 <Tomsik> What do you propose if not a file system? A database?
12:02:05 <Jafet> You can write pretty semantics for new things, but a border will emerge when you put it next to the old things.
12:02:21 <Tomsik> jmcarthur: Well, I for one like my ebooks.
12:02:32 <conal> Tomsik: propose for what? (ask a deeper question)
12:02:55 <Tomsik> Propose for a persistent data storage.
12:03:10 <Jafet> conal: it is a cultural artifact in a sense; often the question becomes "how can I solve this problem using a file system?"
12:03:17 <jmcarthur> Tomsik: ebook management sounds like a good case for a database, sure. i'm not sure that it must be part of a much larger filesystem or database, though. i'm not convinced either way, that is
12:03:34 <Jafet> I find myself doing that kind of transformation all the time
12:03:59 <jmcarthur> Tomsik: there's always orthogonal persistence (nowadays often waved off as a pipe dream when people bring it up, though)
12:03:59 <Jafet> So the "file system" has become a self-evident entity, or something
12:04:09 <conal> Jafet: i like that reframe, as it makes the *choice* of using a file system explicit and separate from the deeper problem.
12:04:49 <conal> which reminds us that we might also pursue the path of solving the problem differently.
12:05:29 <jmcarthur> the filesystem is to persistence as system memory is to values (?)
12:06:15 <conal> jmcarthur: makes sense to me.
12:06:20 <jmcarthur> the former not intrinsic to the latter, but provides the usual interface for working with it
12:06:48 <conal> i like this quote from Luke Palmer: "You must be the change you wish to see in the world (– Mahatma Gandhi). As applied to software: design software as if it were the beautiful paradise you want it to be, then build pieces of the scaffolding back to the status quo." http://lukepalmer.wordpress.com/2009/06/17/my-premonition/
12:07:08 <Twey> I do that ^_^
12:07:13 <conal> :)
12:07:46 <Jafet> Using GHC RULES!
12:08:17 <jmcarthur> yes, yes it does
12:08:25 * BMeph enjoys OSes that explicitly use a database for their "file system"... ;)
12:09:05 <conal> as i read Luke, he's saying to implement elegant, denotative interfaces using non-denotative mechanisms. rather than letting non-denotative mechanisms bubble up into our programming model as we're currently doing with IO.
12:10:33 <Twey> Dana looks neat
12:12:14 * BMeph just wants his flying car, already... ;)
12:12:18 <Twey> Haha, « JavaScript has grown up and is taking something by storm, though I’m not sure it knows exactly what. »
12:12:27 <Twey> Heh
12:14:08 <Twey> conal: Is Eros dead?
12:15:11 <conal> Twey: no. just resting while i'm waiting for progress on cross-platform GUIs & graphics in Haskell-land.
12:16:30 * hackagebot bert 1.1.1 - BERT implementation  http://hackage.haskell.org/package/bert-1.1.1 (MariusEriksen)
12:16:41 <conal> Twey: i switched to making a new functional->gpu compiler to go with a new Eros. the compiler works well, but i don't have a ghi- and mac-friendly basis for doing interactive graphics or guis.
12:17:07 <Twey> conal: As in, a more functional interface than Gtk2Hs?
12:17:12 <conal> the new graphics are insanely fast.
12:17:20 <Twey> Neat!
12:17:30 * hackagebot bert 1.1.2 - BERT implementation  http://hackage.haskell.org/package/bert-1.1.2 (MariusEriksen)
12:17:37 <Twey> EDSL?
12:17:58 <rdrey> hi :)
12:18:04 <Twey> Hi
12:18:10 <conal> Twey: i hide the cruftiness of gtk2hs behind my an elegant functional interface (TV). but gtk2hs itself isn't yet mac-friendly.
12:18:25 <Twey> conal: Ah, really?  I thought GTK ran on Macs too
12:18:28 <conal> Twey: yes, edsl. generates optimized glsl code.
12:18:44 <conal> Twey: runs through the X11 server, so is ugly & clumsy to use.
12:18:58 <Twey> Oh, right :-\
12:19:32 <conal> i've been stuck on this kind of issue for almost two years now.
12:20:02 <conal> would love to get back to elegant, functional guis & graphics in haskell.
12:20:26 <rdrey> hey guys, i have my first proper nooby question. keen to help? :)
12:20:46 <rdrey> problem2 = sum [x | x <- fib, x <= 20, x `mod` 2 == 0]         where fib = 1 : 2 : zipWith (+) fib (tail fib)
12:21:08 <sipa> > [x | x <- fib, x <= 20, x `mod` 2 == 0]         where fib = 1 : 2 : zipWith (+) fib (tail fib)
12:21:09 <lambdabot>   <no location info>: parse error on input `where'
12:21:15 <conal> now i'm thinking of giving up on all of these packages and instead spit out webgl & jsQuery code to be viewed in a browser.
12:21:22 <rdrey> i can use fib like a standard list (say "fib !! 1")
12:21:27 <sipa> > let fib = 1 : 2 : zipWith (+) fib (tail fib) in [x | x <- fib, x <= 20, x `mod` 2 == 0]
12:21:31 <lambdabot>   mueval-core: Time limit exceeded
12:21:35 <monochrom> problem2 will never finish
12:21:38 <rdrey> but the list comprehension doesn't seem to return
12:21:41 <rdrey> yeah
12:21:51 <sipa> you want the sum of an infinite list?
12:21:52 <conal> i don't know how to rebuild eros in a web page, though. :/
12:21:57 <Twey> That's because it is a standard list… it's just infinite
12:21:58 <jmcarthur> it will keep trying to draw values from fib forever
12:22:01 <BMeph> rdrey: "fib" is a standard list, but we get you. Go on. :)
12:22:02 <rdrey> only for x <+ 20
12:22:02 <monochrom> > [x | x <- [0,1,0], x<1]
12:22:03 <lambdabot>   [0,0]
12:22:11 <rdrey> <= 20
12:22:14 <monochrom> > takeWhile (< 1) [0,1,0]
12:22:15 <lambdabot>   [0]
12:22:17 <monochrom> is why
12:22:20 <Twey> conal: You could switch to wxHaskell or something?
12:22:25 <Twey> Or Qt
12:22:28 <Twey> Qt is popular
12:22:55 <conal> Twey: i wish i could use wxHaskell. kills ghci, as do most gui libs.
12:22:59 <monochrom> haskell is just a programming language, not a mathematician
12:23:22 <conal> i don't think i've tried Qt. i'd be surprised if it worked on a mac and didn't kill ghci.
12:23:23 <rdrey> i don't get the [0,1,0] sory
12:23:27 <rdrey> sorry*
12:23:32 <BMeph> rdrey: Here's a hint - once if finds an element not less than 20, do you want it to stop, or to keep looking,in case there are other elements less than 20? ;)
12:23:43 <Jafet> What about drawing your own widgets in an OpenGL viewport?
12:23:52 <Twey> conal: :-\
12:24:06 <Twey> Qt works anywhere Opera runs
12:24:12 <Twey> Which definitely includes Macs
12:24:16 <Twey> Don't know about killing GHCi
12:24:19 <rdrey> BMeph: hmmm, i want only elements < 20... thought the list comprehension sorted that out for me ;
12:24:29 <conal> Jafet: i'd be happy to, but the opengl interaction libs have these same problems.
12:24:30 <jmcarthur> Qt also should not require X11
12:24:49 <Twey> Yeah, it doesn't
12:25:06 <BMeph> rdrey: It does. It just doesn't do it the way you may think it does. Please look at my last question for you again. :)
12:25:09 <Twey> conal: What do you mean by ‘kills GHCi’ exactly?  It segfaults when run from GHCi?
12:25:18 <conal> is there a Qt binding on hackage? and if so, has anyone tried it on a mac? and with ghci?
12:25:21 <BMeph> rdrey: "Once if finds an element not less than 20, do you want it to stop, or to keep looking,in case there are other elements less than 20?" ;)
12:25:47 <BMeph> rdrey: "Once IT finds..." I mean.
12:25:57 <conal> Twey: i mean that you can open a top-level window and close it, but if you try again, the host process crashes.
12:26:04 <monochrom> computer doesn't know that in fib there are only finitely many elements satisfying your condition
12:26:08 <Twey> Oo-er.
12:26:25 <rdrey> noow i get it! :) that's why i need a takeWhile
12:26:31 <rdrey> thanks guys!
12:26:32 <Jafet> Is fixing ghci out of the question?
12:26:39 <conal> wxWindows was restartable until version 1.4 or so. not since then.
12:26:43 <jmcarthur> i don't think qthaskell is on hackage
12:26:51 <Twey> I don't think it's GHCi's problem
12:27:01 <Twey> The toolkit expects a single main loop
12:27:02 * BMeph cheers rdrey on! Yay! :D *\o/*
12:27:05 <rdrey> i didn't realize the list comprehension was going to search through the infinite list. makes sense, though.
12:27:13 <rdrey> thanks!
12:27:22 <conal> Twey: it's not GHCi's problem. it's GHCI's users' problem.
12:28:14 <conal> Twey: my gui & graphics programs are often half-liners. so i want a repl, not a batch compiler.
12:28:35 <conal> for the same reason i like repls in general when i use high-level languages.
12:29:34 <Jafet> Perhaps you could make a wrapper that spawns a new process to do whatever that would kill ghci
12:29:35 <conal> if anyone here would like to help to find a path to cross-platform, ghci-friendly interactive graphics and/or guis, i'd love to get the help.
12:30:17 <conal> Jafet: do you mean assuming that process didn't need haskell computation?
12:30:36 <BMeph> conal: Have you asked chrisdone how he wrote tryhaskell.org? :)
12:30:37 <Jafet> That's a problem.
12:31:19 <conal> in a sense, spawning a process is what i have in mind, generating webgl+jsQuery code. pretty restrictive though. no haskell computation at run-time.
12:31:23 <Jafet> fork() comes to mind, but I hear that ghci won't have it anyway.
12:31:40 <conal> BMeph: do you think tryhaskell.org is relevant for these issues?
12:32:58 <BMeph> conal: I think however he organized it to do the graphics drawing may at least give you good ideas, even if it isn't more directly usable.
12:33:41 <conal> BMeph: ah. tryhaskell has graphics?
12:34:30 <BMeph> conal: try(haskell) it out. ;)
12:34:49 <conal> BMeph: i'm there now.
12:38:00 <tgeeky> conal: I think whoever might be referring to luite's "Wolfgang" fork of tryhaskell
12:38:08 <tgeeky> which I plan (but am not yet) working on
12:38:19 <conal> oh!
12:38:24 <tgeeky> which has graphics support (and examples), rendered to pngs through cairo
12:38:32 <tgeeky> using Diagrams of byorgey's work
12:38:33 <tgeeky> et al
12:38:47 <tgeeky> I wasn't aware that tryhaskell had any such thing
12:39:03 <tgeeky> conal: Diagrams could *surely* use your guidance
12:39:18 <tgeeky> s/guidance/input/
12:39:21 <byorgey> it already has!
12:39:34 <tgeeky> in which case s/most of that//
12:40:01 <conal> byorgey: how did you guys do in your search for a denotational design?
12:40:06 <byorgey> conal: there is also http://pnyf.inf.elte.hu/fp/Diagrams_en.xml
12:40:18 <byorgey> conal: oh yes, I have been meaning to email you back for a while now
12:41:09 <byorgey> conal: I think we have something quite nice, although I need to write it up
12:41:13 <conal> byorgey: have you found any package for guis or interactive graphics that run on mac (w/o using X11) and don't kill ghci?
12:41:37 <conal> byorgey: let me know if you'd like a review
12:41:56 <byorgey> conal: sadly, no, I don't use a mac
12:42:17 <byorgey> conal: ok, thanks!
12:42:18 <tgeeky> conal: interactive seems to be the holy grail part
12:42:32 <conal> tgeeky: yep.
12:43:24 <tgeeky> conal: I had been lost for a few days, but I'm currently working on making someting interesting out of the combination of [mpppc] [invertible-syntax] and [partial-isomorphisms]
12:43:39 <pastorn> conal: what semantics do you place in "interactive" here? is GTK interactive? is OpenGL interactive?
12:43:42 <conal> byorgey: your "<|>" operator is under rather than over. deliberate choice?
12:43:53 <byorgey> conal: I have a <|> operator?
12:44:15 <conal> byorgey: hah :). i'm looking at circle 5 <|> rect 8 8 `move` (3,0)
12:44:19 <byorgey> conal: oh! That URL I linked to is someone else's work
12:44:21 <conal> byorgey: in http://pnyf.inf.elte.hu/fp/Diagrams_en.xml
12:44:29 <conal> byorgey: oh! silly me.
12:44:48 <byorgey> conal: in diagrams, mappend = over
12:45:05 <conal> whenever someone has under instead of over, i suspect they're thinking operationally. i.e., draw this; then draw that
12:45:23 <byorgey> indeed, you're the one who convinced me it should be 'over' =)
12:45:24 <luite> conal: I'm working on interactive web based graphics with diagrams by the way (tryhaskell + graphics and more). the interaction model is quite limited tough
12:45:36 <conal> byorgey: glad to hear it. it's important to me to confound imperative readings
12:45:56 <jmcarthur> what is under and over here? is "over" supposed to be like First or Last?
12:46:09 <tgeeky> conal: that translates into one should draw back-to-front?
12:46:13 <jmcarthur> and why is one a nicer choice than the other?
12:46:29 <byorgey> jmcarthur: if you write  circle <> square, should the circle be on top of the square, or under it?
12:46:31 <tgeeky> jmcarthur: I *think* they mean something like z-depth
12:46:38 <conal> jmcarthur: over is a classic operation on pictures.
12:46:47 <jmcarthur> i get that, but i don't understand which one they chose
12:47:27 <jmcarthur> if i say "a <> b", does that mean a is over b or does it mean b is over a?
12:47:27 <byorgey> the library I just linked to chose "under"
12:47:28 <conal> jmcarthur: i prefer over in part because it produces a cognitive dissonance kick if the reader has an operational mindset.
12:47:44 * jmcarthur looks
12:47:52 <byorgey> I think over is also more intuitive because you can write
12:47:55 <byorgey> circle <>
12:47:56 <byorgey> square
12:48:01 <mrrk> i'm trying to install haskell-src using cabal, but it fails because "the program happy is required but it could not be found", even after i manually install happy
12:48:06 <conal> byorgey: maybe the library writer didn't *choose* under but rather was thinking operationally.
12:48:08 <byorgey> and then the visual layout of the code corresponds to the right meaning
12:48:15 <conal> byorgey: speculating
12:48:27 <byorgey> conal: yes, good point.
12:48:28 <mrrk> has anyone dealt with that before?
12:49:09 <jmcarthur> conal: ah, so it's just to reenforce to the user that old ways of thinking may not apply?
12:49:19 <tgeeky> conal: I see why your argument is compelling for habit-breaking, but not in a more general sense...
12:50:22 <conal> jmcarthur: mainly to re-train the reader, though not just. iirc, "over" is a more popular notion in image composition.
12:50:47 <tgeeky> conal: given that those two choices are dual to each other, what is the dual to making either choice?
12:51:20 <conal> tgeeky: i don't understand your question. could you rephrase?
12:51:22 <tgeeky> conal: <behind> or <ahead>?
12:51:43 <Twey> mrrk: Do you have ~/.cabal/bin in your PATH?
12:51:50 * conal is still puzzled :/
12:51:53 <tgeeky> conal: setting mappend or <|> to be over, or under
12:52:02 <tgeeky> is the order of composition, yes?
12:52:27 <jmcarthur> actually, both ways can be seen as operational ways of looking at it. back to front is kind of the traditional implementation, but front to back is common now because the depth test is so cheap and it means you can avoid rerendering the same pixels over and over
12:52:30 <BMeph> mrrk: I believe you'll need to ... never mind, Twey's got you. :)
12:53:17 <tgeeky> conal: I'm trying to say I don't see why either of them is a good choice, if you could use a more explicit operator
12:53:19 <conal> jmcarthur: yeah. for a more sophisticated model than the painter's algorithm.
12:53:50 <conal> tgeeky: oh. i see. i usually have over & under explicitly also.
12:53:56 <hpc> perhaps you could use the operators (^.) and (.^)
12:54:03 <DanKrejsa> http://hpaste.org/47480/type_synonym_error_applying_mo
12:54:04 <hpc> ie, "over-under" and "under-over"
12:54:25 <conal> tgeeky: and i define mappend = over, as it's my bias for the reasons i gave.
12:54:30 <DanKrejsa> I'm not sure why a type synonym does't work here, just starting out with monadLib.
12:54:55 <mrrk> Twey: thanks, that must be it
12:55:21 <conal> moreover, in the Pan model of images (function of space), mappend = liftA2 mappend,
12:55:24 <tgeeky> conal: i see. I would think operators which allow: inside, outside, or tangent
12:55:28 <tgeeky> might be nice
12:55:35 <dal9k> what would be a good first project in haskell?
12:55:44 <roconnor> @hoogle fromLeft
12:55:44 <lambdabot> No results found
12:56:02 <conal> tgeeky: could be interesting to look for a supporting denotational design.
12:56:04 <tgeeky> dal9k: find a poorly document hackage library whose function interests you, document it
12:56:10 <hpc> dal9k: my first project was an irc bot
12:56:12 <conal> tgeeky: ie one that permits inside, outside, tangent, etc.
12:56:15 <hpc> documenting hackage libs is a good one too
12:56:25 <tgeeky> conal: Yeah. I think it would imply that each Diagram has a metric
12:56:32 <tgeeky> conal: for later, though. one step at a time with me :)
12:56:41 <hpc> hackage is always in need of more docs
12:56:53 <dal9k> tgeeky: i meant as a user, not as a contributor
12:57:13 <dal9k> thanks both
12:57:16 <conal> tgeeky: i've probed these questions a few times and haven't found a denotational basis i'm happy with that supports those operators
12:57:46 <conal> tgeeky: the problem still interests me. if you give it a try, please let me know.
13:01:22 <luite> conal: what kind of interactivity where you looking for
13:01:27 <luite> were
13:02:07 <conal> luite: for guis, the usual kind (buttons, sliders, etc). for graphics, mousing & clicking.
13:02:29 <conal> s/mousing & clicking/mouse motion & buttons/
13:03:29 <conal> luite: is wolfgang somewhere i can play with it? occurs to me that i might be headed for something similar but using webgl for rendering.
13:03:38 <luite> conal: ah, I already support those things partially (both buttons and sliders, and graphics with "mousing")
13:04:04 <conal> luite: ... since i'm generating glsl code.
13:04:06 <luite> conal: not at the moment, sorry. I'm restructuring the backend
13:04:30 <conal> luite: okay. please let me know. maybe there's something fun we could do together.
13:04:35 <luite> since I had to restart the old one every few hours :)
13:05:51 <conal> luite: i'm about to start a project with sean seefried, but perhaps you've already done much of the work.
13:05:59 <luite> conal: I have two types of interactivity. one is GUI's, where the gui is a description of some input elemements, for example a slider with a range
13:06:49 <luite> and the gui is rendered in the browser using javascript (jquery-ui), when the user changes something, it sends a request to the server
13:07:19 <conal> luite: nice. are you generating the javascript stuff from high-level specs?
13:07:57 <DanKrejsa> Hi anyone, I'm confused about why the type synonym error occurs in the code at http://hpaste.org/47480/type_synonym_error_applying_mo . I'm just starting to use monadLib.  I'm also an IRC newbie, sorry for any etiquette blunders.
13:08:00 <conal> luite: have you seen TV? i'm thinking i'll make a back-end for jsquery-ui. or better yet, maybe someone else would like to, and i could advise.
13:08:14 <luite> conal: well, there's an issue. since each request is basically something like: "make X the toplevel module, evaluate expression Y" where both X and Y are strings, the callback has to contain a function name
13:08:33 <luite> that's the main limitation, every expression is text
13:08:57 <hpc> DanKrejsa: when you write 'type X a = ...', you have to refer to the type as 'X something'
13:09:12 <hpc> DanKrejsa: change that one line to type T1 = StateT Int Id
13:10:07 <DanKrejsa> hpc: Thanks!
13:10:14 <luite> conal: I'd like to remove that, but it has to remain "webscale", I need to be able to somehow create a new GHC session and evaluate the expression. Even though multiple reuqests are evaluated in the same GHC API session, the client can never be certain that he gets the same one for the next request
13:10:56 <tgeeky> conal: I would recommend using ExtJS rather than jquery
13:11:16 <conal> tgeeky: oh? i haven't heard of ExtJS. what do you like about it?
13:12:10 <tgeeky> conal: I was *very* impressed. It seems to be more well-organiezed compared to jQuery, and it has a very predictable syntax that could be rolled up using JSON in many areas
13:12:28 <tgeeky> conal: http://www.sencha.com/products/extjs/examples/
13:12:33 <conal> tgeeky: neat. thanks!
13:12:49 <conal> my JS chops are near zero. grateful for advice & help
13:13:49 <zomg> Ext has a pretty steep learning curve though
13:13:52 <tgeeky> conal: this might also interest you (it does me) - it's a over-project to protovis
13:13:55 <tgeeky> http://mbostock.github.com/d3/
13:14:03 <zomg> But yeah it's probably much more suitable for large scale projects than jQuery
13:14:21 <tgeeky> zomg: dunno about that, there is at least one very good book to help the path, and with Ext4 the examples are very parsable
13:14:54 <zomg> Perhaps they've improved on that front then
13:14:58 <zomg> Haven't really touched it for a while :)
13:15:14 <conal> is anyone here interested in helping make a JS backend (e.g., jquery or ExtJS) for TV?
13:15:15 <zomg> I've mostly used Dojo myself
13:15:17 <conal> @wiki TV
13:15:18 <lambdabot> http://www.haskell.org/haskellwiki/TV
13:15:57 <fragamus> http://hackage.haskell.org/packages/archive/random-fu/0.1.0.0/doc/html/src/Data-Random-Distribution-Normal.html
13:16:01 <fragamus> or...
13:16:02 <tgeeky> conal: I will be, right after I get the above project out of the way (pretty-parser)
13:16:19 <conal> tgeeky: cool. let me know when you're ready.
13:16:19 <fragamus> http://hackage.haskell.org/packages/archive/normaldistribution/1.1.0.1/doc/html/Data-Random-Normal.html
13:16:43 <fragamus> which one is better?
13:17:01 <tgeeky> conal: I suggest you take a look at the examples in D3 and protovis. It's not as "complete" in terms of an overall application GUI feel as ExtJS or jquery, but it *is* a smart API.
13:17:32 <conal> tgeeky: kthx.
13:18:32 <conal> i've been pleasantly surprised with how non-ugly some js programming can be.
13:18:50 <tgeeky> conal: yeah, me too lol
13:19:11 <tgeeky> conal: I have noticed that reaction several times in the past few months.
13:20:56 <tgeeky> conal: there's something to be said for compactness, too. ExtJS as a package is ~ 26 MB. Protovis is 800Kb. D3 is 1.2M.
13:21:13 <conal> tgeeky: yoiks.
13:24:13 <roconnor> the serialization in acid-state doesn't appear to pe
13:24:24 <roconnor> the serialization in acid-state doesn't appear to pereserve sharing as far as I can tell
13:24:34 * roconnor wants more magic
13:26:13 <Nordvind> Howdy
13:26:26 <roconnor> ... though if I never checkpoint and only replay, I guess I get my sharing back ...
13:26:27 <roconnor> hmmm
13:27:20 <shurane> so i want to filter q <- [1..100] so that p `mod` q == 0 -- how would I do that without a lambda? (I'm not using list comprehensions, just using them because they are clear)
13:27:56 <Nordvind> any ideas, why HOpenGL program window may remain minimized?
13:28:22 <dolio> > let p = 7 in filter ((==0) . (p `mod`)) [1..100]
13:28:23 <lambdabot>   [1,7]
13:28:51 <pastorn> Nordvind: it's not HOpenGL, it's the library that creates the window that's messing with you
13:29:05 <dolio> @pl filter (\q -> p `mod` q == 0) [1..100]
13:29:05 <lambdabot> filter ((0 ==) . (p `mod`)) [1..100]
13:29:10 <pastorn> Nordvind: so, SDL, GLUT, GTK, XGL or what have you
13:29:21 <DukeDave> Hey gang, is it possible to implement the second instance of Show here: http://pastebin.com/A7ehpami
13:29:40 <DukeDave> Or does it just not make sense because the kinds don't match?
13:30:19 <shurane> Ooh, function composition
13:30:19 <Nordvind> @pastorn GLUT
13:30:22 <lambdabot> No match for "GLUT".
13:30:39 <hpc> @help @pastorn
13:30:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:30:39 <Nordvind> hmmm
13:30:48 <shurane> thanks, pastorn
13:30:50 <sipa> @Nordvind is this a test function?
13:30:50 <shurane> er
13:30:50 <lambdabot> Unknown command, try @list
13:30:51 <shurane> dolio: *
13:30:59 <hpc> @help pastorn
13:31:00 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:31:12 <dolio> Common mistake.
13:31:36 <pastorn> hpc: how may i serve?
13:32:10 <hpc> just wondering what command λbot thought was being invoked
13:32:16 <Nordvind> @ sipa well, it's that HOpenGL tutorial, that draws a window
13:32:55 <Nordvind> may this be the issue with my ATI card?
13:33:13 <pastorn> Nordvind: perhaps, but unlikely
13:33:24 <monochrom> you can preserve your twitter habit by a small modification: just do "thank you @monochrom" instead of "@monochrom thank you"
13:33:46 <pastorn> Nordvind: what are you using to creae a window? (OpenGL/HOpenGL are the *wrong* answers)
13:34:12 <Nordvind> moment
13:34:17 <hpc> (GLUT is one possible answer)
13:34:42 <pastorn> SDL another
13:34:50 <Nordvind> GLUT it is
13:35:17 <Nordvind> Graphics.UI.GLUT module imported
13:35:26 <dwaynecrooks> use /nick dwaynecrooks
13:37:05 <Nordvind> well, guess I'll just purge my ghc, and install a haskell-platform
13:37:05 <hpc> dwaynecrooks: ??
13:37:19 <Nordvind> thanks for help, anyway
13:37:30 <parcs> \\\\\\\\
13:37:37 <roconnor> what's the best way to write a safe version of (l!!i)? listToMaybe (drop i l) ?
13:38:07 <roconnor> @hoogle [a] -> Int -> Maybe a
13:38:08 <lambdabot> Prelude (!!) :: [a] -> Int -> a
13:38:08 <lambdabot> Data.List (!!) :: [a] -> Int -> a
13:38:08 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
13:38:25 <roconnor> @hoogle Int -> [a] -> Maybe a
13:38:25 <hpc> roconnor: personally, i would write the recursion myself, just to be sure there's less wrapping/unwrapping
13:38:25 <lambdabot> Prelude (!!) :: [a] -> Int -> a
13:38:26 <lambdabot> Data.List (!!) :: [a] -> Int -> a
13:38:26 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
13:38:31 <parcs> roconnor: Safe.atMay
13:38:36 <monochrom> assert (i < length l) (l !! i)
13:38:49 <hpc> monochrom: way too strict
13:39:12 <roconnor> monochrom: in my case my list might be shorter than the length
13:39:31 <roconnor> than the index
13:40:04 <dwaynecrooks> @hpc yeah?
13:40:04 <lambdabot> Maybe you meant: ghc pl rc src
13:40:36 <dwaynecrooks> how do i respond to an individual??
13:41:57 <monochrom> you can try "hello @monochrom"
13:41:58 <roconnor> dwaynecrooks: name followed by a colon
13:42:42 <hpc> dwaynecrooks: you can also type the start of their name, then press tab
13:42:51 <hpc> and it will complete on its own, in any sane client
13:43:08 <hpc> 16:54 < dwaynecrooks> use /nick dwaynecrooks
13:43:16 <hpc> dwaynecrooks: ^
13:43:26 <dwaynecrooks> hpc, oh ok thanks
13:43:30 <dwaynecrooks> hpc: oh ok thanks
13:46:28 <roconnor> @type unfoldr
13:46:28 <dbpatterson> can I have a data constructor that has a function that involves a typeclass? Ie, the following is valid: data T = T (Int -> Int). Is there a way to write this: data T = T (Num -> Int)?
13:46:29 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
13:46:45 <ezyang> dbpatterson: Sort of.
13:46:55 <ezyang> There are these things called datatype contexts, but they don't actually do what you want.
13:47:00 * roconnor wonders if he should use build instead of unfoldr to get fusion
13:47:12 <ezyang> since you have to respecify the typeclass at any usage site.
13:47:29 <dbpatterson> ezyang: damn :)
13:47:49 <ezyang> What I suspect you actually want are context synonyms, which a lot of people have been wanting for a while, but haven't been implemented yet.
13:48:00 <dbpatterson> ezyang: what are those?
13:48:14 <Tomsik_> data T = forall n . Num n => T (Num -> Int)
13:48:14 <Tomsik_> ?
13:48:20 <Tomsik_> -XExistentialQuantification
13:48:31 <Tomsik_> err
13:48:38 <Tomsik_> T (n -> Int)
13:48:47 * hackagebot hakyll 3.1.2.8 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.1.2.8 (JasperVanDerJeugt)
13:48:47 <Tomsik_> Is that what you want?
13:48:49 <hpc> dbpatterson: what you probably want to do is write "data T a = T (a -> Int)" and constrain functions on that type with "Num a"
13:48:50 <ezyang> Tomsik_: yah, that's with datatype contexts.
13:49:16 <Tomsik_> Well, then you've got GADTs
13:49:30 <ezyang> No no, GADTs are orthogonal.
13:49:32 <dbpatterson> the problem is that that means that I have to change the type of everything that uses the type, right?
13:49:39 <ezyang> Yes.
13:50:57 <dbpatterson> hpc: okay, I'll try that.
13:51:01 <Tomsik_> Ah, the thing is that you have to thread context?
13:51:26 <ezyang> Yes.
13:51:50 <dbpatterson> ezyang: hmm. and no way around that huh. that's kind of what I was trying to avoid! oh well...
13:52:21 <ezyang> Well, there is a "way" around it.
13:52:43 <ezyang> where a "way" is data T = T ((forall a. Num a => a) -> Int)
13:53:45 <dbpatterson> what is the downside to that?
13:53:48 <ezyang> Oh, actually, Tomsik_'s proposal is different from datatype contexts. Mea culpa.
13:53:58 <ezyang> and it may do what you want.
13:54:09 <ezyang> For mine, the downside is that it's pretty hard to actually get things that are (forall a. Num a => a)
13:54:53 <ezyang> Whereas for Tomsik's, you can only use functions that support all of Num, e.g. only use Num operations.
13:54:59 <applicative> @type 1
13:54:59 <lambdabot> forall t. (Num t) => t
13:55:06 <applicative> @type 2
13:55:07 <lambdabot> forall t. (Num t) => t
13:55:15 <applicative> I think that's about it, no?
13:55:18 <ezyang> Numeric literals being one particular exception :-)
13:55:32 <ezyang> but threading the high-rankness may get annoying
13:55:32 <parcs> @src Num
13:55:33 <lambdabot> class  (Eq a, Show a) => Num a  where
13:55:33 <lambdabot>     (+), (-), (*)           :: a -> a -> a
13:55:33 <lambdabot>     negate, abs, signum     :: a -> a
13:55:33 <lambdabot>     fromInteger             :: Integer -> a
13:56:05 <ezyang> So, tell us, what are you actually trying to do?
13:56:09 <applicative> dbpatterson: what are you going to do with this type T, once you have it?
13:56:18 <applicative> like ezyang said
13:56:49 <dbpatterson> applicative: well, pass it in a type that can vary but will only be used by that function in a very specific way.
13:57:00 <dbpatterson> basically, I hae a library that takes a concrete type
13:57:17 <dbpatterson> it passes that to a function, and the only thing the function does is turn it into a string.
13:57:45 <dbpatterson> I would like to be able to substitute in different types, so long as they can also be turned into a string.
13:57:56 <ezyang> Ah yes, the ECB one. Quite good.
13:57:59 <dbpatterson> without having to change the whole library
13:58:35 <ezyang> Why not make the function take a String?
13:58:40 <dbpatterson> so I thought, if I can just change that concrete type into a class with that one function, and write the instance for the existing data type, then I should be able to add new ones in easily
13:59:25 <ezyang> mix.
13:59:30 <ezyang> (re ECB. Ignore that.)
13:59:36 <dbpatterson> ezyang: well, within the library the type carries a bit more data. It is just passed to this function i that way. I guess I could do the conversion first…
13:59:37 <ezyang> dbpatterson: Can you paste some type signatures?
14:00:13 <applicative> dbpatterson yeah, it's still a little opaque somehow.
14:00:38 <dbpatterson> sure, it's from the digestive-functors library - the type is data Environment m i = Environment (FormId -> m (Maybe i)) |NoEnvironment (from  https://github.com/jaspervdj/digestive-functors/blob/master/digestive-functors/src/Text/Digestive/Types.hs#L50)
14:01:05 <ezyang> More signatures!
14:01:28 <dbpatterson> data FormId = FormId
14:01:28 <dbpatterson>     { -- | Global prefix for the form
14:01:28 <dbpatterson>       formPrefix :: String
14:01:28 <dbpatterson>     , -- | Stack indicating field. Head is most specific to this item
14:01:28 <dbpatterson>       formIdList :: [Integer]
14:01:29 <dbpatterson>     } deriving (Eq, Ord)
14:01:51 <dbpatterson> (from https://github.com/jaspervdj/digestive-functors/blob/master/digestive-functors/src/Text/Digestive/Result.hs#L50)
14:02:39 <dbpatterson> an example of an actual environment: napEnvironment :: (MonadSnap m) => Environment m SnapInput
14:02:39 <dbpatterson> snapEnvironment = Environment $ \id' -> do
14:02:39 <dbpatterson>     input' <- getParam (SB.fromString $ show id')
14:02:39 <dbpatterson>     return $ SnapInput <$> input'
14:02:39 <dbpatterson>  ( https://github.com/jaspervdj/digestive-functors/blob/master/digestive-functors-snap/src/Text/Digestive/Forms/Snap.hs#L34 )
14:03:15 <ezyang> (maybe hpaste at this point)
14:03:51 <dbpatterson> ezyang: hmm. okay
14:06:05 <uniquenick> what is the not-horrible way to do this?  http://hpaste.org/47483/derp
14:07:07 <applicative> dbpatterson: I hadn't known about this swank ..../Result.hs#L50 thing on github. very nice.
14:08:03 <Ziphilt> uniquenick: what exactly are you trying to do there?
14:08:24 <dbpatterson> here: http://hpaste.org/47484/typeclass_argument_to_function — includes the code that does not work currently
14:08:30 <MHD> I have a class called "Represent." Is it weird when you start thinking of bad rap when you program?
14:08:46 <MHD> "I'mma represent my soft type!"
14:09:05 <Zao> MHD: You're either going to write awesome or horribad code real soon now.
14:09:17 <MHD> Zao: I know
14:09:20 <uniquenick> Ziphilt: adding up the probability of each option.  each of the arguments is a % change to occur, like 0.13 or whatever
14:09:26 <Zao> Or both.
14:09:37 <MHD> Exactly, looking towards both.
14:09:44 <shepheb> @quote rational.line
14:09:45 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
14:09:48 <uniquenick> the code works correctly, it is just super ugly copy+pasting each line like that, and I need to add 8 more layers of ugly
14:10:02 <Ziphilt> i understand, you want to refactor
14:10:12 <Ziphilt> i am asking about the meaning, so i can better herp
14:10:15 <Ziphilt> *help
14:10:20 <shepheb> old quote: "Betta watch yo back when I'm packing a nine / I'll pump you fulla holes like the rational line."
14:10:21 <Ziphilt> herp derp
14:10:23 <uniquenick> I am herping enough for the both of us
14:10:45 <uniquenick> it works out average attacks per attack round for a game
14:10:57 <dolio> The paste indicates there's more derping going on than herping.
14:11:29 <uniquenick> so if you have a 5% chance to quadruple attack and a 5% chance to triple attack, the quad comes first, then the triple is checked from the remaining swings
14:12:34 <Ziphilt> why are they all added up?
14:13:15 <dolio> (1 - x) - (1 - x) * y = (1 - x) * (1 - y)
14:13:34 <Ziphilt> also, doesn't (1 - quad) - (1 - quad) equal zero?
14:14:18 <uniquenick> it would equal zero, but I don't do that?
14:14:23 <Ziphilt> oh failure on my part to parse infix associativity
14:14:54 <dolio> 4*q + 3*(1-q)*t + 2*(1-q)*(1-t)*d + (1-q)*(1-t)*(1-d)
14:15:05 <MHD> Aww LLVM and it's many options!
14:16:50 <ddarius> dolio: Now write it as a scanl.
14:17:11 <dolio> That was my plan, but I'm not sure scanl is the right way.
14:20:07 <dolio> > scanl1 (\(p, r) e -> (p*e, r*(1-e))) [q,t,d]
14:20:08 <lambdabot>   Occurs check: cannot construct the infinite type: t = (t, t1)
14:20:25 <dolio> > scanl (\(p, r) e -> (p*e, r*(1-e))) (1,1) [q,t,d]
14:20:25 <lambdabot>   [(1,1),(1 * q,1 * (1 - q)),(1 * q * t,1 * (1 - q) * (1 - t)),(1 * q * t * d...
14:20:46 <dolio> > scanl (\(_, r) e -> (r*e, r*(1-e))) (1,1) [q,t,d]
14:20:47 <lambdabot>   [(1,1),(1 * q,1 * (1 - q)),(1 * (1 - q) * t,1 * (1 - q) * (1 - t)),(1 * (1 ...
14:21:13 <applicative> dbpatterson: this is rough!
14:21:22 <dbpatterson> applicative: what is?
14:23:41 <parcs> how does one simulate the exists keyword using forall ?
14:23:49 <dolio> > zipWith (*) [4,3,2,1] . zipWith (*) [q,t,d,1] . scanl (\p e -> p * (1-e)) 1 $ [q,t,d]
14:23:51 <lambdabot>   [4 * (q * 1),3 * (t * (1 * (1 - q))),2 * (d * (1 * (1 - q) * (1 - t))),1 * ...
14:23:54 <roconnor> Types are Antimodular?
14:24:01 <roconnor> I'm not going to enjoy reading this ...
14:24:05 <applicative> The hell they are!
14:24:17 <dolio> That's shorter, at least.
14:24:22 <applicative> or no, Yeah, but in a good way....
14:25:19 <roconnor> maybe types without polymorphisms isn't modular
14:26:59 <dolio> I Have Defined Modularity in Such a Way that No One Really Cares Whether Their Programs are Modular or Not.
14:29:10 <ddarius> dolio: No, his argument is that separate modules do have dependencies on each other, but if we just -close our eyes-, they will go away.
14:29:38 <dolio> They don't necessarily, though.
14:29:44 <ddarius> They don't at all.
14:30:04 <applicative> dbpatterson: anyway: in " case env of Environment f -> lift $ lift $ f name " you want to give it a Text, but it wants a FormID, i.e. a String [Integer] pair
14:30:13 <dolio> You can structure an ML program such that no module needs to know about any other module.
14:30:34 <dolio> And his problem with that seems to be that ML can't infer the signatures for that.
14:31:13 <dbpatterson> applicative: yes, exactly. the only thing that is done with it is call show, which is a special instance declared above. So I thought, if I can only replace it with a typeclass that implements some sort of showlike function, then it would work..
14:31:30 <ddarius> He's not complaining about one module depending on the implementation of another, he's complaining about one module depending on the interface of another.
14:31:54 <jesusabdullah> o/
14:32:19 <dolio> I thought he was complaining that to know what the interface of some other module is, you have to have access to that module.
14:32:21 <ddarius> But I guess you mean you can parameterize by everything and never import a module.
14:32:40 <ddarius> dolio: No, he finds needing access to a signature file just as bad.
14:32:58 * BMeph always thinks of England when he closes his eyes. Force of habit.
14:33:06 <ddarius> Even if that file doesn't even require an implementation to exist yet.
14:33:18 <applicative> dbpatterson, but what is wrong with data Environment a m i = Environment (a -> m i) | NoEnvironment
14:34:24 <jesusabdullah> Are one-liner fibbonacci sequences still a hobby here? I realized I don't know how to specify my fibs in a nice manner >_<
14:34:39 <jesusabdullah> Used the obvious pattern matching but of course that blows the stack hard-core
14:34:50 <jesusabdullah> or, rather, pattern matching and recursion
14:35:16 <applicative> dbpatterson then you add constraints on the consequent functions, snapEnvironment :: (MonadSnap m, Show a) => Environment a m SnapInput
14:35:27 <jesusabdullah> My intuition is that there should be a way to "pop" values onto the end of a list based on values already on it, but I'm having trouble reasoning about it
14:35:30 <jesusabdullah> >_<
14:35:38 <applicative> dbpatterson: etc etc  -- or is this unpleasant threading?
14:36:08 <jesusabdullah> (I'm finally reading through LYAH after meaning to for like years)
14:36:36 <Twey> jesusabdullah: You can use laziness to use earlier parts of the list in constructing the rest of the list
14:36:52 <ddarius> dolio: Brian's comment is on point.
14:36:52 <Twey> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
14:36:53 <lambdabot>   not an expression: `let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)'
14:36:55 <Twey> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
14:36:56 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:37:08 <applicative> whoa, I built ghc head, and sure enough 'MonadComprehensions' is a 'supported language'
14:37:17 <Twey> \o/ Whee
14:37:40 <jesusabdullah> Twey: I see!
14:38:11 * applicative does ./ghci -XMonadComprehensions
14:38:32 <jesusabdullah> Twey: That's even better than I expected!
14:38:42 * applicative does the extremely imaginative: Prelude> [x*x | x <- Just 3]
14:39:09 <jesusabdullah> [
14:39:18 <jesusabdullah> blegh, laggernets
14:39:41 <dbpatterson> applicative: yeah, trying to avoid having to thread that type everywhere. Obviously I need to change the places that actually use it, but Environment shows up all over the place, so if it's type could remain the same… well that'd be preferrable.
14:40:17 <ceii_> why's everyone so excited about monad comprehensions? aren't they simply do blocks with annoying punctuation?
14:40:46 <applicative> ceii_: Yeah! Isn't that exciting?!
14:40:51 <dolio> They're do blocks that are more suggestive for certain uses.
14:41:05 <Eduard_Munteanu> I don't know why they were so excited to remove them in the first place :/
14:41:23 <applicative> ACTION does the thrilling Prelude> [reverse x | x <- readFile "/Users/applicative/Desktop/degrees.txt"]
14:41:24 * applicative
14:41:29 * applicative does
14:41:33 <Tomsik_> It's all about guards I suppose
14:41:35 <ceii_> Actually I always thought even list comprehensions were superfluous and should be removed >_>
14:41:39 <dolio> Eduard_Munteanu: Type errors with "Monad" in them are scary to students.
14:42:06 <Tomsik_> ceii_: I find do-syntax indentation-error-prone for one
14:42:13 <ddarius> dolio: There is also the possibility that you won't get a type error, and in many cases, you'll get a type error without Monad.
14:42:16 <Eduard_Munteanu> Ah so specializing comprehensions to lists allowed friendlier error reporting?
14:42:48 <ceii_> Tomsik_, what about do { blah ; blah } ?
14:42:59 <applicative> thats what they said, Eduard_Munteanu
14:43:00 <Eduard_Munteanu> Anyway I thought that's what Helium was for, really easy Haskell.
14:43:10 <Tomsik_> ceii_: that's even worse
14:43:15 <ddarius> Eduard_Munteanu: Helium was made long after Haskell 98.
14:43:25 <Eduard_Munteanu> Oh, oops.
14:43:26 <ceii_> yeah, maybe you're right
14:44:18 <dolio> Eduard_Munteanu: Anyhow, that was the justification for several of the Haskell 98 changes.
14:44:25 <dolio> map specialized to lists....
14:44:31 <Eduard_Munteanu> Eww.
14:44:54 <dolio> (++) too, as I recall.
14:44:58 <Tomsik_> > let isJustTrue a = [x | x <- a, x] in isJustTrue $ Just True
14:44:59 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
14:44:59 <lambdabot>         against inferred typ...
14:45:01 <Eduard_Munteanu> Eww.
14:45:01 <Tomsik_> darn
14:45:02 <Eduard_Munteanu> :)
14:45:08 * ddarius has virtually never had an error due to bad indentation of do blocks, and has certainly had more 'missing semicolon' errors in C# etc.
14:45:21 <Tomsik_> ddarius: you're a happy man :)
14:45:27 <ceii_> we could have had (++) :: Monoid a => a -> a -> a ?
14:45:30 <ceii_> Aaaargh
14:45:37 <Tomsik_> Most trouble I had was with if-then-else blocks
14:45:38 <dolio> (++) used to be mplus, so no.
14:45:48 <ddarius> Tomsik_: Just don't use if-then-else.
14:46:04 <Eduard_Munteanu> It's really annoying Prelude clobbers namespace needlessly, without using typeclasses.
14:46:47 <Eduard_Munteanu> Yeah, case-of is usually better if you go on multiple lines.
14:47:08 <saterus> is (<*>) pronounced apply?
14:48:11 <ion> It’s pronounced <*>
14:48:12 <hpc> saterus: i think so, yea
14:48:12 <Eduard_Munteanu> It's interesting to note someone thought about all this and worked it out.
14:48:21 * BMeph calls (<*>) "a-ap".
14:48:26 <mightybyte> How do you get rid of a "Constraint is no smaller than the instance head" message and avoid needing UndecidableInstances?
14:48:27 <Eduard_Munteanu> At least before they got a marketing dept..
14:49:33 <KirinDave> Hey guys, the docs seem to not show me
14:49:40 <KirinDave> When you foldl a Data.Map, what does the accum function get passed?
14:49:52 <dankna> :t Data.Map.foldl
14:49:53 <lambdabot> Not in scope: `Data.Map.foldl'
14:49:55 <dankna> hm
14:49:57 <dankna> :t Data.Map.fold
14:49:58 <lambdabot> forall a b k. (a -> b -> b) -> b -> M.Map k a -> b
14:50:22 <Eduard_Munteanu> It can only be passed one thing.
14:50:39 <Eduard_Munteanu> The type tells you that.
14:50:47 <ddarius> Eduard_Munteanu: Not true.
14:51:03 <Tomsik_> mightybyte: make a dozen datatype constructors so contraint is smaller than the instance head? :p
14:51:08 <Tomsik_> I guess you don't
14:51:13 <Eduard_Munteanu> How so? How do you get an 'a' or a 'b'?
14:51:27 <ceii_> Eduard_Munteanu, add a few "sensibly"s everywhere and it whould work.
14:51:30 <ddarius> Still, it's pretty easy to guess the reasonable answer, though the -order- is not given by the type.
14:51:34 <Eduard_Munteanu> Wait, actually for the 'b'.
14:51:46 <KirinDave> So
14:51:52 <KirinDave> fold doesn't take the keys
14:52:02 <parcs> has anyone here successfully built disciple? what's your secret? i'm getting a bunch of "cannot satisfy dependencies errors"
14:52:03 <ceii_> KirinDave, yep
14:52:03 <Eduard_Munteanu> Yeah that's what I mean.
14:52:05 <KirinDave> If I want to squash a map into a tuple list, I'll need to iterate over the keys
14:52:13 <applicative> ACTION demands join sugar with his MonadComprehensions! join [writeFile "blah.txt" (x ++ y) | x <- readFile "degrees.txt" , y <- readFile "mark.txt"]
14:52:13 * applicative
14:52:16 <dankna> :t Data.Map.toList
14:52:16 <lambdabot> forall k a. M.Map k a -> [(k, a)]
14:52:19 <KirinDave> Ahh
14:52:22 <applicative> man i'm having trouble with /me
14:52:22 <KirinDave> OR READ THE DOCS :)
14:52:37 <ddarius> applicative: Your /me is broken.
14:52:41 <mightybyte> Tomsik_: Yeah, but I don't know what that means.
14:53:08 <applicative> ddarius, no the stupidity is closer to the surface.  what can i say, MonadCompehensions is too exciting!
14:53:14 <ceii_> mightybyte, it means GHC's can't prove that instance resolution will always terminate
14:53:33 <Tomsik_> mightybyte: it means that arguments you're passing recursively are not syntactically strictly smaller
14:53:43 * applicative demands join sugar with his MonadComprehensions! who wants to import Control.Monad anyway?
14:53:43 <ceii_> because you have recursive constraints on types that aren't structurally smaller
14:53:44 <Tomsik_> I guess you're using data families?
14:53:57 <mightybyte> ceii_: Right.  I get that, but I'd like to avoid that.
14:54:07 <mightybyte> Tomsik_: Yes
14:54:49 <Tomsik_> The first thing is to make sure that it always terminates
14:55:25 <ddarius> applicative: join = (>>= id) = do n <- m; x <- n; return x = [x | n <- m, x <- n]
14:55:40 <ceii_> then, encode a termination proof, for example as a new parameter to the class that actually decreases in recursive constraints
14:55:57 <mightybyte> I have a fairly normal type class Foo, and the error is regarding "instance Foo m => Bar m where ..."
14:56:19 <mightybyte> ...and my Bar type class is the one with the associated type.
14:56:21 <ddarius> mightybyte: And if you have instance Bar m => Foo m ?
14:56:48 <mightybyte> ddarius: That doesn't make sense in this case.
14:57:03 <ceii_> ...but GHC doesn't know that. Bleh
14:57:07 <ddarius> It doesn't matter if it makes sense, the point is if you allow the former then you allow the latter.
14:57:08 <mightybyte> grrrr
14:58:07 <ceii_> Guess you'll need to ass a newtype: Bar a => Foo (GodDammit a)
14:58:12 <ceii_> add*
14:58:59 <mightybyte> ceii_: But Foo is a type class, not a newtype
14:59:41 <ceii_> No, I mean instianciate Foo for a newtype over a rather than a itself
14:59:51 <ceii_> so the constraint "Bar a" is smaller
15:00:38 <ceii_> newtype Wrap a = Wrap a ; instance Bar a => Foo (Wrap a) where ...
15:01:36 <mightybyte> ceii_: But I don't want it to be a concrete type.  I want it to be anything that has an instance of the Foo type class.
15:01:57 <mightybyte> Is there some way I can change the way the Foo or Bar type classes are constructed to eliminate this problem?
15:02:06 <ceii_> I don't think you can make that work
15:02:19 <ddarius> Anyway, instance Bar m => Foo m doesn't mean "if there's a Bar instance then there's a Foo instance"  it means "there's a Foo instance for all m and it requires a Bar instance."
15:02:24 <ddarius> As such, it makes little sense.
15:02:37 <mightybyte> ddarius: Ahhhh
15:07:56 <KirinDave> Man
15:08:09 <KirinDave> It seems like converting a ByteString to a String is an inordinate amount of work
15:08:37 <ddarius> It's just pack.
15:08:46 <mauke> unpack
15:09:03 <ddarius> Er, yes, what mauke said.
15:09:15 <KirinDave> except that then I do that, I don't have a string
15:09:21 <ddarius> :t unpack
15:09:23 <lambdabot> forall n o. (Newtype n o) => n -> o
15:09:26 <ddarius> Cripes
15:09:29 <KirinDave> Troloo
15:09:33 <ddarius> :t Data.ByteString.unpack
15:09:34 <KirinDave> It's like Word8 or something
15:09:34 <lambdabot> BSC.ByteString -> [Word8]
15:09:41 <KirinDave> Which is not the same as Char
15:09:44 <KirinDave> or so the compiler complains
15:09:46 <ddarius> :t Data.ByteString.Char8.unpack
15:09:47 <lambdabot> BSC.ByteString -> [Char]
15:10:00 <KirinDave> right, but I don't have a Char8
15:10:01 <applicative> ddarius, yeah but who wants:  [writeFile "blah.txt" (x ++ y)| x <- readFile "degrees.txt" , y <- readFile "mark.txt"] >>= id
15:10:06 <KirinDave> I have this funky CIByteString
15:10:16 <KirinDave> From Snap
15:10:28 <ddarius> Of course, if by "convert to String" you mean "decode to String", then that wouldn't be what you want.
15:10:40 <ddarius> applicative: That's not what I suggested.
15:11:12 <ddarius> @hackage encode
15:11:12 <lambdabot> http://hackage.haskell.org/package/encode
15:11:24 <KirinDave> 404
15:11:27 <mauke> KirinDave: there is no Char8
15:11:52 <ddarius> @hackage Encode
15:11:52 <lambdabot> http://hackage.haskell.org/package/Encode
15:11:53 <mauke> "Char8" is just part of a module name
15:11:56 <KirinDave> I am almost tempted to show and the drop 1
15:12:15 <KirinDave> Because at least that will do exactly what I want
15:13:08 <applicative> ddarius, what would be the sugariest way of getting an IO() for [writeFile "blah.txt" (x ++ y) | x <- readFile "degrees.txt" , y <- readFile "mark.txt"]
15:13:47 <KirinDave> I mean, should I unpack and the fromIntegral?
15:14:19 <mauke> KirinDave: why not use Data.ByteString.Char8.unpack?
15:14:19 <ddarius> applicative: The translation of join for that would be, [() | x <- readFile "degrees.txt", y <- readFile "mark.txt", () <- writeFile "blah.txt" (x++y)]
15:15:01 <KirinDave> mauke: But do I have a String at the end of that?
15:15:09 <ddarius> @src String
15:15:10 <lambdabot> type String = [Char]
15:15:15 <mauke> KirinDave: yes
15:15:53 <ddarius> Albeit a crazy one if you are using any encoding/characters that don't map the ASCII range to ASCII.
15:16:05 <rdrey> i have another issue... http://hpaste.org/47489/nooby_error
15:16:25 <rdrey> i seem to be unable to use foldl
15:16:47 <mauke> rdrey: no, you're unable to use (*) on functions
15:16:53 <mauke> maxima is a list of functions
15:17:16 <mauke> rdrey: look at the type of 'max'
15:17:16 <rdrey> damn, was meant to be a list of values
15:17:49 <rdrey> ok, will do, thanks for the hint. so max doesn't return the maximum element of a list?
15:17:57 <mauke> :t max
15:17:58 <ddarius> :t max
15:17:59 <lambdabot> forall a. (Ord a) => a -> a -> a
15:17:59 <lambdabot> forall a. (Ord a) => a -> a -> a
15:18:02 <ddarius> :t maximum
15:18:02 <mauke> there, I'll do it for you
15:18:03 <lambdabot> forall a. (Ord a) => [a] -> a
15:18:35 <hpc> @src maximum
15:18:35 <lambdabot> maximum [] = undefined
15:18:36 <lambdabot> maximum xs = foldl1 max xs
15:18:39 <rdrey> aaah, max takes two values and compares them?
15:18:55 <rdrey> thanks! maximum it is! :)
15:19:22 <rdrey> i need to learn how to read type declarations more quickly, still confuse me
15:20:05 <KirinDave> I guess I don't understand how bytestring types inter-relate
15:20:23 <applicative> ddarius, ah indeed.  a little disappointing.
15:20:48 <rdrey> ooh, maximum doesn't like empty lists ;) that error is nice and clear :)
15:21:23 <Saizan> KirinDave: there are only two, often named strict and lazy, the latter is more or less a list of the former
15:23:09 <ddarius> :t let maximumB [] = maxBound; maximumB xs = maximum xs in maximumB
15:23:10 <lambdabot> forall a. (Ord a, Bounded a) => [a] -> a
15:23:16 <ddarius> s/maxBound/minBound/
15:26:39 <rdrey> mauke++
15:26:46 <rdrey> how does this work? :)
15:27:04 <applicative> ddarius, I'm getting a better sugar high from the identical: [act | x <- readFile "degrees.txt", y <- readFile "mark.txt",  act <- writeFile "marky.txt" (x ++ y)]
15:27:53 <ddarius> applicative: All you've done is named () act.
15:28:06 <applicative> ddarius, yeah, i just thought () was heartless
15:28:12 <ddarius> act is misleading.
15:28:15 <parcs> how would one make  the `parse` function typecheck in http://www.haskell.org/haskellwiki/Generalised_algebraic_datatype#Motivating_example
15:28:23 <applicative> yeah, i'm trying to think of something better
15:28:35 <ddarius> applicative: How 'bout ()?
15:30:55 <Saizan> parcs: i'd make parse :: String -> UntypedTerm; typecheck :: UntypedTerm -> Maybe TermWithType; using data TermWithType where TWT :: Type t -> Term t -> TermWithType
15:31:23 * applicative goes back to demanding JoinSugar implying MonadComprehensions
15:31:41 <Saizan> though maybe here it's not that easy to make a useful definition for Type
15:31:42 <ddarius> applicative: You haven't actually proposed any sugar.
15:32:05 <applicative> ddarius, true, maybe like in the she preprocessor, no that's hideous
15:32:45 <applicative> he uses a @ before the last bracket to join everything
15:33:47 * applicative delays his demand for JoinSugar until after IdiomBrackets is introduced in ghc 12.2
15:45:18 <rdrey> i'm off, thanks for all the help! i'll be back with more nooby issues some time :)
15:45:36 <mun> hi
15:45:45 <hanDerPeder> trying to install yesod on a vps with only 512mb of memory. ghc gets killed when compiling monad-control because of out-of-memory error. Does anyone know of a workaround for this?
15:46:11 <mun> in the logical expression "f = 1 & g = 2", is "f = 1" a 'term'? is it a 'subexpression'?
15:46:33 <dschoepe> hanDerPeder: You can compile it on your desktop, in a chroot if necessary, and copy the results to the server, but that's not a pretty workaround.
15:47:01 <hanDerPeder> i agree, thanks though!
15:47:13 <dolio> f = 1 is a proposition, probably.
15:48:07 <ddarius> It is both a term and a subexpression.
15:49:00 <mun> ddarius, right. but in what situation would it be referred to as a 'term'/'subexpression'?
15:49:04 <dolio> I wouldn't necessarily agree that it's a term. But the question is pretty under-specified.
15:51:50 <applicative> in logic there is a distinction between a formula and an expression for an object,  a 'term' would be eg (x + y)
15:52:35 <applicative> in "(x + y ) = ( y + x) or x = y " the terms present are x and y, and x + y and y + x
15:53:07 <applicative> the subformulae are (x + y) = (y + x) and x = y
15:53:25 <applicative> i think sub expression is not standard but would mean either a subformula or a term
15:58:16 <applicative> the difference from something like haskell is the great distinction made between a function sign which makes a term from one or more terms, and a predicate or relation symbol, which makes a formula or proposition from one or more terms
16:02:59 <parcs> hanDerPeder: if your development environment and your vps are on the same architecture, you can compile on one machine and synchronize to the other with, say, rsync
16:04:42 <parcs> synchronize ~/.cabal, ~/.ghc, that is
16:16:43 <shurane> would there be a neat way to convert an Integral to a List of digits? So 12345 -> [1,2,3,4,5], but would also work for like... 0 -> [0]?
16:18:34 <sipa> > map (read . []) . show $ 12345
16:18:34 <lambdabot>   Couldn't match expected type `a -> GHC.Base.String'
16:18:35 <lambdabot>         against inferre...
16:18:51 <sipa> > (map (read . []) . show $ 12345) :: [Int]
16:18:52 <lambdabot>   Couldn't match expected type `a -> GHC.Base.String'
16:18:52 <lambdabot>         against inferre...
16:19:28 <sipa> > (map (read . []) . show $ 12345 :: Integer) :: [Int]
16:19:29 <lambdabot>   Couldn't match expected type `a -> GHC.Base.String'
16:19:29 <lambdabot>         against inferre...
16:21:18 <parcs> > let f 0 = [0]; f n = let (q, r) = n `quotRem` 10 in r : f q in reverse (f 12345)
16:21:19 <lambdabot>   [0,1,2,3,4,5]
16:21:38 <parcs> s/[0]/[]
16:22:20 <sipa> > let f 0 = [0]; f n = let (q, r) = n `quotRem` 10 in r : f q in reverse (f 0)
16:22:21 <lambdabot>   [0]
16:22:24 <sipa> > let f 0 = []; f n = let (q, r) = n `quotRem` 10 in r : f q in reverse (f 0)
16:22:25 <lambdabot>   []
16:22:34 <BMeph> > (map (read . (:[])) . show $ 12345 :: Integer) :: [Int] -- This, sipa? ;)
16:22:35 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
16:22:35 <lambdabot>         against inf...
16:22:51 <BMeph> ...I guess not. :)
16:22:56 <shurane> parcs,sipa: does that work for f 0?
16:23:24 <parcs> shurane: no, but wrap it in another function that replaces [] with [0]
16:23:27 <BMeph> > (map (read . (:[])) . show) $ 12345 :: [Int]
16:23:28 <lambdabot>   [1,2,3,4,5]
16:23:34 <BMeph> > (map (read . (:[])) . show) $ 0 :: [Int]
16:23:35 <lambdabot>   [0]
16:23:40 <BMeph> Better. :)
16:24:15 <parcs> > let f 0 = []; f n = let (q, r) = n `quotRem` 10 in r : f q; g x = case f x of [] -> [0]; a -> a in reverse (g o)
16:24:19 <lambdabot>   mueval-core: Time limit exceeded
16:24:25 <parcs> uh oh >_>
16:24:37 <BMeph> > let f = map (read . (:[])) . show in map f [0,7..150] :: [Int]
16:24:37 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
16:24:37 <lambdabot>         against inferred type ...
16:24:46 <BMeph> > let f = map (read . (:[])) . show in map f [0,7..150] :: [[Int]]
16:24:48 <lambdabot>   [[0],[7],[1,4],[2,1],[2,8],[3,5],[4,2],[4,9],[5,6],[6,3],[7,0],[7,7],[8,4],...
16:24:59 <parcs> > let f 0 = []; f n = let (q, r) = n `quotRem` 10 in r : f q; g x = case f x of [] -> [0]; a -> a in reverse (g 0)
16:25:00 <lambdabot>   [0]
16:25:02 <parcs> > let f 0 = []; f n = let (q, r) = n `quotRem` 10 in r : f q; g x = case f x of [] -> [0]; a -> a in reverse (g 12345)
16:25:03 <lambdabot>   [1,2,3,4,5]
16:25:13 <BMeph> > let f = map (read . (:[])) . show in f 12345
16:25:14 <lambdabot>   [*Exception: Prelude.read: no parse
16:25:22 * BMeph sighs
16:25:32 <lovecastle>  > map (+1) [1,2,3]
16:25:40 <lovecastle> > map (+1) [1,2,3]
16:25:41 <lambdabot>   [2,3,4]
16:25:43 <lovecastle> yay
16:25:49 <parcs> return > (:[])
16:26:03 <BMeph> > let {f :: Integral i => i => [i]; f = map (read . (:[])) . show} in f 12345
16:26:04 <lambdabot>   <no location info>: malformed class assertion
16:26:14 <BMeph> > let {f :: Integral i => i -> [i]; f = map (read . (:[])) . show} in f 12345
16:26:15 <lambdabot>   Could not deduce (GHC.Read.Read i)
16:26:15 <lambdabot>    from the context (GHC.Real.Integral i...
16:26:32 <BMeph> ...really, Dude? Really? :\
16:26:52 <BMeph> > let {f :: (Read i, Show i) => i -> [i]; f = map (read . (:[])) . show} in f 12345
16:26:53 <lambdabot>   [1,2,3,4,5]
16:27:17 * BMeph is NOT inpressed with the DMR....
16:28:37 <parcs> :t o
16:28:38 <lambdabot> Expr
16:29:25 * Saizan is not impressed with defaulting
16:29:53 <parcs> > o `quotRem` 10
16:29:54 <lambdabot>   (o `quot` 10,o `rem` 10)
16:30:52 * BMeph would have been impressed with 19th cen. UK naval recruitment... ;þ
16:38:25 <shurane> BMeph: what's DMR?
16:38:38 <shurane> as in, have a link so I can read about it?
16:38:55 <hpc> http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/monomorphism.html
16:39:04 <parcs> dreaded monomorphism restriction?
16:40:39 <hpc> er
16:40:41 <hpc> http://www.haskell.org/onlinereport/decls.html#sect4.5.5
16:53:57 <magicman> I wonder...
16:54:00 <magicman> > [a..e]
16:54:01 <lambdabot>   *Exception: not a number
16:54:08 <magicman> Awww
16:54:23 <cmccann> > ['a'..'e']
16:54:24 <lambdabot>   "abcde"
16:55:20 <cmccann> > a
16:55:21 <lambdabot>   a
16:55:25 <magicman> Yeah, I was just wondering if simple-reflect did anything like that.
16:55:39 <magicman> Apparently not. Oh, well.
16:55:43 <magicman> > [a,b,c,d,e]
16:55:45 <lambdabot>   [a,b,c,d,e]
16:55:50 <magicman> :t [a,b,c,d,e] -- ;)
16:55:51 <lambdabot> [Expr]
16:56:28 <cmccann> ah, I was wondering what you were trying for
16:56:36 <cmccann> lambdabot has lots of weird stuff enabled
16:56:47 <magicman> Yep. Was playing with that for a bit :)
16:57:45 <cmccann> > minBound :: Expr
16:57:46 <lambdabot>   minBound
16:57:55 <hpc> > (do{1;2;3;4})5
16:57:56 <lambdabot>   4
16:58:22 <magicman> XD
16:58:36 <cmccann> > succ a
16:58:37 <lambdabot>   succ a
16:58:50 <cmccann> > pred (succ a)
16:58:51 <lambdabot>   pred (succ a)
16:58:53 <cmccann> ok then
16:59:02 <cmccann> > pred (succ a) == a
16:59:03 <lambdabot>   False
16:59:55 * cmccann thinks this seems more confusing than helpful
17:01:15 <geheimdienst> @check \a -> pred (succ a) == a
17:01:16 <lambdabot>   "*Exception: Prelude.Enum.().pred: bad argument
17:12:05 <jesusabdullah> Is the "see the source" tool part of lambdabot or part of ghci?
17:12:11 <jesusabdullah> Either way, how does it work again? :S
17:12:20 <geheimdienst> @src pred
17:12:21 <lambdabot> Source not found. Where did you learn to type?
17:12:26 <geheimdienst> @src foldr
17:12:26 <lambdabot> foldr f z []     = z
17:12:26 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:12:42 <jesusabdullah> I see
17:12:47 <geheimdienst> in haddock documentation, you can also click the "source" links on the right-hand side
17:13:00 <jesusabdullah> Oh snap, there it is!
17:13:02 <jesusabdullah> Thanks!
17:13:56 <jesusabdullah> awexome
17:13:58 <ddarius> The @src command is just a dictionary in lambdabot.
17:14:07 <jesusabdullah> *nod*
17:14:20 <jesusabdullah> It's been a year or so since I last hung out here, so
17:14:27 <jesusabdullah> That's *my* excuse!
17:16:38 <geheimdienst> suppose a clever, open-minded but very old-fashioned coworker from the c/c++ camp. what would be good bait?
17:16:44 <geheimdienst> what would be a good, short haskell example program (or several) that shows off why haskell is cool?
17:17:13 <holmak> I think Parsec always makes for a neat demo
17:17:17 <geheimdienst> (basic stuff, no futuhistocryonic bamboozloids)
17:17:18 <cmccann> geheimdienst, maybe something using STM
17:17:31 <cmccann> showing a C/C++ programmer a library that makes concurrency simple and painless ought to be a shock
17:17:54 <cmccann> since the only reason STM works so easily is because of Haskell itself
17:17:54 <Zao> cmccann: You should be keelhauled for lumping the languages together like that.
17:17:55 <geheimdienst> holmak, you mean code using parsec, or the implementation of parsec?
17:18:08 <geheimdienst> stm is a good idea, yes
17:18:17 <holmak> geheimdienst: Code using Parsec
17:18:21 <Zao> STM has suboptimal implementations though.
17:18:47 <cmccann> Zao, compared to Haskell the difference between C and C++ is pretty minor
17:19:03 <cmccann> C++ lets you do type-level metaprogramming, C is easier to interface with Haskell's FFI
17:19:07 <cmccann> not sure what else matters?
17:19:17 <cmccann> I guess there are some other differences but I can't recall what
17:19:17 <holmak> If they are a C programmer, the Error monad is a cool way of handling C-style goto-exit error handling
17:19:24 <ddarius> geheimdienst: Does he do template metaprogramming stuff?
17:19:30 <Zao> RAII? Class-based polymorphism? operator overloading?
17:19:45 <Zao> C++ isn't "C with classes, lol", you know.
17:19:57 <Zao> Anyway, back to starcraft 2 stream, IRC is distracting.
17:19:59 <geheimdienst> well c++ "lets you do type-level metaprogramming" in the same sense as a fork lets you wipe your butt
17:20:12 <cmccann> C++ is C with a whole bunch of ad-hoc features dumped in
17:20:14 <cmccann> plus the kitchen sink
17:20:21 <cmccann> it's like perl, except less well-planned
17:20:28 <Zao> geheimdienst: Compared to TH, it's heaven.
17:20:45 <cmccann> anyway, C++ is a terrible language that noone should use
17:20:50 <cmccann> so it doesn't really matter
17:20:56 <geheimdienst> ddarius: i guess he knows what it is and is kinda intrigued that you could shoot yourself in the foot in clever, puzzling ways
17:20:57 <holmak> Ow, and I was just about to make the jump to learn TH...
17:20:59 <Zao> cmccann: You are a terrible person no-one should listen to.
17:21:07 <cmccann> ok
17:21:13 <Zao> It's a bit sad when the language trolls hit this channel.
17:21:31 <Zao> It's usually so understanding of the strengths of other languages.
17:21:45 <geheimdienst> zao: are you serious? i don't think cmccann was trolling
17:21:48 <hpc> !quote feed the trolls
17:21:57 <cmccann> C++'s only strong suit is legacy code support
17:22:02 <hpc> @quote feed the trolls
17:22:02 <lambdabot> No quotes for this person. Listen, broccoli brains, I don't have time to listen to this trash.
17:22:02 <cmccann> everything else is better done in some other language
17:22:12 <hpc> :(
17:22:31 <holmak> C++ still has performance computing cornered, last I'd heard
17:22:53 <geheimdienst> you know what, i'll check out some of the code from RWH. that should be readable and well-commented
17:23:00 <holmak> Which is probably the hardest thing to beat it at
17:23:00 <hpc> depends on what you want to compute, i thought
17:23:08 <geheimdienst> thanks guys in the meantime :)
17:23:17 <hpc> fortran for craptons of math, erlang for stuff that you run in parallel
17:23:22 <cmccann> "performance computing" is sort of broad, yeah
17:23:23 <gienah> geheimdienst: this is a classic post on C++ template meta programming and haskell: https://bartoszmilewski.wordpress.com/2009/10/21/what-does-haskell-have-to-do-with-c/
17:23:52 <holmak> I'm thinking of game engines, databases, arguably operating systems, ...
17:24:29 <cmccann> a lot of that stuff is still done in plain C, isn't it?
17:24:45 <hpc> linux is written in C, mac written in god-only-knows
17:24:52 <hpc> windows written in i-forget
17:25:01 <argiopeweb> C++
17:25:12 <cmccann> except maybe the game engines, since that's one of the few cases where using OOP everywhere can actually help
17:25:14 <holmak> I think the leading-ish ones are all C++
17:25:39 <hpc> Source is C++
17:25:40 <argiopeweb> Mac is BSD which is C (entirely, I think) and Objective C.
17:25:50 <argiopeweb> I may be wrong on BSD.
17:25:59 <hpc> it has a lot of BSD parts
17:26:08 <hpc> but i think the OS is just boring posix
17:27:50 <holmak> Haskell seems to be doing impressive things in the web server space, though
17:28:16 <holmak> There is Snap, at least, which is allegedly blindingly fast
17:28:48 <cmccann> is it? that never struck me as a space that had interesting things to be done, really
17:29:30 <holmak> Impressive in terms of performance
17:29:36 <cmccann> compared to what, though?
17:29:59 <holmak> Apache and node.js, I think Snap benchmarks against
17:30:17 <hpc> benchmarking haskell against javascript? it hardly seems fair ;)
17:30:28 <cmccann> yeah, I was gonna say
17:30:41 <hpc> and apache isn't much better either lol
17:30:46 <gienah> hpc: node.js is written in C++ with some app javascript stuff
17:31:34 <holmak> Javascript nowadays is probably like Python: a thin layer of scripting over fast C libraries
17:31:59 <cmccann> I mean, I would assume that any serious server written in Haskell is going to be competitive just because of having a good optimizing compiler
17:32:19 <cmccann> it's not hard to be fast compared to something like Python or PHP or whatever
17:32:31 <hpc> or perl
17:32:40 <cmccann> or Ruby or JS or whatever, yeah
17:32:52 <hpc> the codebase at my work takes two seconds to compile
17:33:09 <hpc> the only thing saving it from disaster is mod_perl compiling only once
17:33:25 <cmccann> more interesting would be how snap compares to Java-based stuff or whatever
17:34:20 <holmak> Snap versus Java and Apache? I'm not sure what people usually run Java web apps on
17:34:30 <cmccann> yeah, I dunno either
17:34:43 <cmccann> just seems like that would be a more interesting comparison
17:34:54 <hpc> i think you run java web apps as the server itself
17:35:20 * hackagebot sbv 0.9.20 - Symbolic bit vectors: Bit-precise verification and automatic C-code generation.  http://hackage.haskell.org/package/sbv-0.9.20 (LeventErkok)
17:35:21 <hpc> the performance benefit of server-side java code is that the JVM can optimise parts of the code that run more frequently
17:35:46 <c_wraith> Lemmih: you around?
17:37:59 <cmccann> would also be interesting to compare snap to something written in an ML dialect but I'm not sure how many of those exist
17:38:54 <Azverkan> anyone know of a haskell helper library to make System.Console.GetOpt a little more sane?
17:39:12 <holmak> CmdArgs is supposed to be good
17:39:30 <holmak> Haven't tried it myself
17:40:46 <identity_> cmdargs is pretty sexy, yes.
17:40:55 <holmak> Azverkan: See here - http://hackage.haskell.org/packages/archive/cmdargs/0.7/doc/html/System-Console-CmdArgs-Implicit.html
17:42:11 <Azverkan> trying the sample out now
17:46:44 <Azverkan> other than supplying "-h" by default it looks much better
17:46:54 <Azverkan> not supplying
17:53:33 <luite> hmm, is hackage slow?
17:59:35 <c_wraith> @tell Lemmih I'm having some issues with SDL-mixer, and could use a hand with it - sometime.
17:59:36 <lambdabot> Consider it noted.
18:04:31 <dbpatterson> I have a cabal issue - I need to include  package as a dependency (ghc complains, and tells me what package to include), but when I try to include it (and it is installed, ghc-pkg list confirms that), it complains that no versions are installed. Any ideas? (paste at http://hpaste.org/47492/cabal_confused )
18:08:44 <drhodes> > msum [Just 1, Just2]
18:08:45 <lambdabot>   Not in scope: data constructor `Just2'
18:08:51 <drhodes> > msum [Just 1, Just 2]
18:08:52 <lambdabot>   Just 1
18:09:01 <drhodes> why not Just 3 ?
18:09:09 <mauke> why Just 3?
18:09:16 <hpc> msum is more like Alternative than Monoid
18:09:23 <hpc> er, MonadPlus is more like
18:09:28 <luite> dbpatterson: it's possible that the package was installed with a different version of its dependencies than required for installing your package
18:09:39 <drhodes> ok, thanks. I'll investigate further into Monoid.
18:09:44 <hpc> > Just 1 <|> Just 2
18:09:44 <dbpatterson> luite: thanks, I'll look into that :)
18:09:44 <lambdabot>   Just 1
18:09:51 <hpc> > Nothing <|> Just 2
18:09:52 <lambdabot>   Just 2
18:10:07 <hpc> this behavior is especially useful for parsers
18:10:25 <drhodes> yeah, I've used it in parsec
18:10:27 <luite> dbpatterson: try cabal install --only-dependencies
18:11:22 <dbpatterson> luite: same error. I'm going to reompile a bunch o' stuff
18:11:50 <luite> dbpatterson: hmm, ok, don't know then :)
18:12:41 <luite> there's also an --upgrade-dependencies flag, that might help
18:16:46 <Zearen> http://hpaste.org/47493/dialogin <- I have no clue why I'm getting this error.  Help?
18:20:03 <mauke> I hate it when people do that
18:22:37 <Zearen> Sorry?  It's hard to keep track.  Some channels prefer that behavior while others do not.
18:23:42 <jmcarthur> i'm not sure what mauke is talking about, honestly
18:24:31 <mauke> pasting a random snippet from the middle of a program
18:24:42 <mauke> especially when it uses a library I'm not familiar with
18:24:46 <jmcarthur> ah
18:25:05 <mauke> that means I have no chance to even understand the issue
18:25:24 <mauke> oh, also when it doesn't even say which library it is
18:25:44 <mauke> in fact, rule of thumb: paste your whole program
18:25:45 <jmcarthur> yeah, i also looked at the paste and them just closed the window because i don't know the library
18:25:50 <jmcarthur> *then
18:25:50 <mauke> if that's too long: write a shorter program
18:26:14 <Zearen> Oh!  Righto, sorry 'bout that.  Wasn't even thinking
18:30:47 <Zearen> Well, is anyone here actually familiar with gtk2hs? There was no channel, so I thought I'd just ask :/
18:30:50 <luite> is there a posix or linux function for deleting a directory, without deleting the contents manually first?
18:31:17 <bd_> luite: POSIX forbids deleting directories that aren't empty
18:31:19 <mauke> luite: not as far as I know
18:31:38 <luite> bd_: yes I know that the standard rmdir and unlink functions don't do it
18:32:07 <mauke> Zearen: that's a "poll" style question and unlikely to get answers
18:32:45 <bd_> luite: Basically you're required to traverse the directory and remove all contents manually. POSIX doesn't give you a single call to do it because, well, you don't really need it.
18:33:21 <cmccann> er, isn't that just what rm -r does?
18:33:23 <Zearen> v_v I'm trying.  Seriously, I'm not new to haskel and this is the first error I've ever had to ask for help.
18:33:26 <cmccann> or is that outside the posix standard
18:33:44 <bd_> rm -r isn't a function, it's a program
18:33:48 <geheimdienst> Zearen: what mauke is trying to say is "don't ask to ask, just ask" :) no sweat
18:33:55 <luite> bd_: I'm ok with linux specific functions if necessary
18:33:56 <bd_> which recursively unlink() and rmdir()s things, one file or directory at a time
18:34:12 <bd_> luite: There are no Linux specific functions for this. You have to recursively traverse the directory.
18:34:20 <bd_> Just look at strace rm -rf, you'll see it going one file at a time
18:34:28 <mauke> strace doesn't tell you about functions
18:34:34 <bd_> ltrace then
18:34:35 <Zearen> geheimdienst: oO' That's what I did first, and I got yelled at, so now I'm all confused
18:34:45 <mauke> Zearen: you didn't get yelled at
18:35:36 <luite> traversing the directory could case some race conditions... what if some process creates a new file while you're traversing
18:35:42 <luite> *create
18:36:07 <applicative> Zearan, what is the error like?
18:36:15 <mauke> applicative: did you look at the paste?
18:36:22 <applicative> oh i didn't see it.
18:36:29 <Zearen> http://hpaste.org/47494/dialogin_take_2
18:36:35 <bd_> luite: Then your rmdir call fails
18:36:49 <luite> bd_: I know, I don't want that...
18:36:58 <bd_> luite: If you want, you could rename the directory before removing it. This doesn't help if a process has the directory set as current directory, of course.
18:37:26 <mauke> Zearen:     Could not find module `Util':
18:37:52 <bd_> luite: anyway, there is no atomic operation to remove an entire directory tree. This is a deliberate design decision; it's non-trivial to lock an entire directory tree like that, since you don't even know what's in the directory until you do a whole lot of IO, and you don't want to lock the entire FS
18:38:55 <geheimdienst> Zearen: don't sweat the getting "yelled" at. honestly, i think mauke was a little overzealous there
18:39:40 <Zearen> mauke: Sorry, multiple file program.  just slap "(|>) = flip ($)" at the top and get rid of the import and you should see the error I'm seeing
18:40:17 <mauke> Zearen: first I need to grab some dependencies :-)
18:40:34 <mauke> oh hey, cairo desn't build
18:41:52 <Zearen> Huh, weird.
18:44:32 <luite> bd_: fair point, but still annoying ;p
18:44:40 <mauke> compiling Cabal for the third time ...
18:44:43 <Zearen> Oh, and since I forgot to mention it in chat, the issue is line 44:25, where it complains expected Dialog, inferred Button
18:45:54 <geheimdienst> :t onClicked
18:45:55 <lambdabot> Not in scope: `onClicked'
18:46:54 <Zearen> (ButtonClass onClicked :: (ButtonClass b) => b -> IO () -> IO (ConnectId b)
18:47:14 <geheimdienst> thanks, got it :)
18:49:35 <mauke> yeah, I can't install cairo
18:49:51 <Zearen> What's the error?
18:50:27 <applicative> castToButton, unsurprisingly is returning a Button
18:50:31 <mauke> sec, need to fix my paste script first
18:50:37 <mauke> yay for yak shaving
18:50:39 <geheimdienst> Zearen: could it be the DMR? in line 43 you say "getWidget castToDialog", and 1 line later it complains that it expects things to match Dialog ...
18:50:53 <dmwit> geheimdienst: You should use "on buttonClicked" instead, it's the future. =)
18:50:55 <applicative> getWidget, unsurprisingly wants a Widget
18:51:29 <geheimdienst> dmwit: as often, i have no clue about any of this stuff :) never used gtk
18:51:49 <applicative> scratch second remark....
18:52:02 <geheimdienst> Zearen: i think dmwit may or may not be on to something
18:52:37 <Zearen> I mean, I'm new to the library, so let's see
18:54:41 <mauke> http://hpaste.org/47495/argh
18:57:44 <geheimdienst> Zearen: so, any changes to the error if you put LANGUAGE NoMonomorphismRestriction at the top and recompile?
18:57:49 <applicative> mauke do you have the funny gtk2hshelper binary, whatever its called
18:59:10 <applicative> "gtk2hs-buildtools" there are three little programs.
18:59:56 <Zearen> No, but I just failed haskell 101
19:00:37 <Zearen> getWidget is an IO type.
19:01:35 <mauke> applicative: I have now
19:02:18 <dmwit> Using "on buttonClicked" instead of "onButtonClicked" shouldn't change any errors.
19:02:29 <dmwit> I think "onButtonClicked" is even defined as "on buttonClicked".
19:06:52 <Zearen> it Compiles now, and geheimdienst NoMonomorphismRestriction fixed it, but I'm going to have to look up what that is.
19:07:58 * geheimdienst feels so proud
19:08:22 <luite> geheimdienst fixed the monomorphismrestriction!
19:08:32 * cmccann is still hoping for eventual implemention of a polymorphism restriction
19:12:40 <applicative> boy, Zaeren, I'm almost ready to compile your module, and geheimdienst gets all the verdienst
19:12:58 <geheimdienst> :D
19:13:00 <geheimdienst> geheimverdienst
19:13:13 * geheimdienst gives some verdienst to applicative
19:13:30 * applicative expresses gratitude
19:19:40 <reacocard> anyone know how I can put a widget inside another widget in Yesod? eg. if i have one widget that has a <div> in it, how can i nest the othe widget's html inside that div while preserving the stylesheets and such from the second widget properly?
19:22:04 <tswett> Verdienst sounds yummy.  Can you eat it?
19:23:18 <DevHC> [1 of 1] Compiling Main             ( rvc.hs, rvc.o )
19:23:18 <DevHC> SpecConstr
19:23:18 <DevHC>     Function `go{v s1pr} [lid]'
19:23:18 <DevHC>       has one call pattern, but the limit is 0
19:23:18 <DevHC>     Use -fspec-constr-count=n to set the bound
19:23:19 <DevHC>     Use -dppr-debug to see specialisations
19:23:21 <DevHC> Linking rvc ...
19:23:23 <DevHC> WAT?????????????????
19:30:40 <parcs> DevHC: it's a debug message for advanced users that you may safely ignore
19:33:51 <DevHC> epic! built-in sp4m!
19:36:25 <luite> hmm, why isn't there an atomic nonblockingReadChan :: Chan a -> IO (Maybe a)
19:37:23 <dmwit> There's isEmptyChan.
19:37:41 <dmwit> ...although that's not the same, is it?
19:37:42 <dmwit> huh
19:39:30 <luite> not really, if you do isEmptyChan and the a readChan, then it would still block if another thread grabbed the value
19:39:34 <argiopeweb> DevHC: 1337 isn't.
19:47:29 <DevHC> argiopeweb: u mean 1337ness?
19:48:16 <parcs> luite: you can dup the chan, check if it's empty and conditionally grab the value
19:51:58 <luite> parcs: that doesn't sound terribly convenient, since you have to dup the chan before values added. and I don't think it solves this issue. the thread should get the value if available, but it should never block
19:52:08 <luite> and a value should never be handled by more than one thread
19:52:49 <mustelo> @pl (\x y -> f (g x) (h y))
19:52:49 <lambdabot> (. h) . f . g
19:52:52 <parcs> hmm, forgot about that..
19:53:13 <parcs> :t on
19:53:14 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
19:53:58 <mustelo> @pl (\x y -> f (g x) y)
19:53:58 <lambdabot> f . g
19:59:38 * hackagebot csv-enumerator 0.8.2 - A flexible, fast, enumerator-based CSV parser library for Haskell.  http://hackage.haskell.org/package/csv-enumerator-0.8.2 (OzgunAtaman)
20:00:24 <mustelo> @pl (\x y -> f $ g (h x) (j y))
20:00:24 <lambdabot> (f .) . (. j) . g . h
20:00:38 <mustelo> I'm over my head on this one...
20:03:48 <Favonia> @pl (\x y -> f $ g (h x) y)
20:03:48 <lambdabot> (f .) . g . h
20:04:02 <Favonia> @pl (\x y -> f $ g x (j y))
20:04:03 <lambdabot> (f .) . (. j) . g
20:04:26 <Favonia> @pl (\x y z -> f $ g (h x) (j y) (k z) )
20:04:26 <lambdabot> ((f .) .) . flip flip k . ((.) .) . (. j) . g . h
20:04:32 <Jafet> Connect the dots: Haskell edition
20:04:59 <Jafet> (de Bruijn-numbered dots?)
20:05:14 <Favonia> this one is really beyond my understanding...
20:07:26 <Favonia> Jafet: is there an inverse function of @pl in lambdabot?
20:07:45 <luite> @unpl id
20:07:45 <lambdabot> (\ a -> a)
20:08:00 <Favonia> luite: thanks
20:08:07 <luite> @unpl ((f .) .) . flip flip k . ((.) .) . (. j) . g . h
20:08:07 <lambdabot> (\ u aj am -> f (g (h u) (j aj) (k am)))
20:08:29 <luite> not bad :)
20:09:09 <Favonia> @unpl (.(.)) .(.(.)). (.(.))
20:09:09 <lambdabot> (\ o u -> o (\ j k g c -> u (j k g c)))
20:09:16 <parcs> the function instance of Applicatives is useful here
20:09:41 <parcs> @pl (\x y z -> f $ (g <$> h <*> j <*> k) x y z)
20:09:42 <lambdabot> ((f .) .) . (g <$> h <*> j <*> k)
20:10:01 <Favonia> @unpl (.).((.((.).)).).(.(.(.(.)))).((.).)
20:10:01 <lambdabot> (\ v b c ah r -> v (\ ar -> b c (\ au -> ar (\ k l -> au (k l)))) (\ e f -> ah r (e f)))
20:11:06 <Favonia> parcs: seems that it doesn't understand <$>
20:11:40 <Jafet> @pl (\x y z -> f $ (liftM3 g h j k) x y z)
20:11:40 <lambdabot> ((f .) .) . liftM3 g h j k
20:11:55 <Jafet> Or Monad (a->)
20:13:34 <Favonia> i think it's just a simple syntax parser that recognizes flip, $, (, ), dots, dots and dots.
20:14:33 <parcs> and ap
20:15:05 <parcs> @pl (\x y -> (x, y))
20:15:05 <lambdabot> (,)
20:15:08 <parcs> and that
20:15:16 <HeyAll> hello...
20:15:28 <parcs> but i think (a, b) is already syntactic sugar for (,) a b
20:15:51 <parcs> @pl (\x y z -> (x, y, z))
20:15:51 <lambdabot> (,,)
20:15:51 <Jafet> Syntactic kool-aid.
20:16:28 <Favonia> @pl (,,,,,,,,,)
20:16:28 <lambdabot> (,,,,,,,,,)
20:16:34 <parcs> @unpl (,,,,,,,,,,)
20:16:34 <lambdabot> (,,,,,,,,,,)
20:16:40 <parcs> @unpl (,,,)
20:16:40 <lambdabot> (,,,)
20:16:41 <Favonia> a fixed point!
20:17:17 <Favonia> @pl (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
20:17:17 <lambdabot> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
20:17:34 <parcs> @pl \f g x -> f x (g x)
20:17:35 <lambdabot> ap
20:17:48 <Axman6> @unpl (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
20:17:49 <lambdabot> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
20:17:53 <Axman6> o.O
20:18:00 <Axman6> @unpl (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1,,,,,,,,,,,)
20:18:01 <lambdabot>  Parse error at "1,,,,..." (column 162)
20:18:07 <Axman6> :\
20:18:20 <Favonia> @unpl (,,) 1 2 3
20:18:20 <lambdabot> (,,) 1 2 3
20:18:28 <Favonia> @pl (,,) 1 2 3
20:18:29 <lambdabot> (1, 2, 3)
20:18:34 <mauke> @unpl (,,) 1 2 3 4
20:18:35 <lambdabot> (,,) 1 2 3 4
20:18:57 <mauke> @pl (,,) 1 2 3 4
20:18:57 <lambdabot> (1, 2, 3) 4
20:19:00 <mauke> @pl (,,) 1 2
20:19:00 <lambdabot> (,,) 1 2
20:19:34 <parcs> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
20:19:36 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w ->
20:19:36 <lambdabot> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33)
20:20:07 <acfoltzer> poor lambdabot :(
20:20:20 <Favonia> why is it "t28"? i thought it should be t27 :P
20:21:03 <Favonia> @pl (,)(.)(,)(.)
20:21:03 <lambdabot> ((.), (,)) (.)
20:21:08 <mauke> @pl \a b c d e f g h m n o p s t u z -> l a m b d a b o t
20:21:11 <lambdabot> ((const . ((const . const . const . const . ((const . ((const . const . ((const . const) .)) .)) .)) .)) .) . join . ((flip . (flip .)) .) . (flip =<< ((flip . (flip .) . flip) .) . flip . l)
20:21:46 <Favonia> const, join, and =<< ...
20:21:55 <mauke> @. unpl pl \a b c d e f g h m n o p s t u z -> l a m b d a b o t
20:21:58 <lambdabot> (\ as ct _ cw _ _ _ _ cz _ dc _ _ df _ _ -> ((\ di r s v -> ((\ al dr ac ad ag -> al dr ag ad ac) >>= \ y z aa -> y aa z) (\ an ao -> l as ao an) di s v r) >>= \ bx -> bx) ct cw cz dc df)
20:22:04 <parcs> @pl \i n c e p t i o n -> i n c e p t i o n
20:22:08 <lambdabot> const (const ((((const .) .) .) . flip flip id . ((flip . ((flip . ((flip . (ap .)) .)) .)) .) . flip flip id . ((flip . ((flip . ((ap . (flip .)) .)) .)) .) . flip flip id . ((flip . ((flip . (ap .)
20:22:08 <lambdabot> ) .)) .) . ((((flip .) .) .) .) . ((flip .) .) . (((flip .) .) .) . (flip .) . ((flip .) .) . flip . (flip .) . flip flip))
20:22:08 <lambdabot> optimization suspended, use @pl-resume to continue.
20:22:30 <parcs> @pl-resume
20:22:33 <lambdabot> const (const ((((const .) .) .) . flip flip id . ((flip . ((flip . ((flip . (ap .)) .)) .)) .) . flip flip id . ((flip . ((flip . (liftM2 flip .)) .)) .) . flip flip id . ((flip . ((flip . (liftM2
20:22:34 <lambdabot> flip .) . flip . (flip .)) .) . flip . (flip .)) .) . flip . (flip .) . flip flip))
20:22:41 <mauke> @pl \c e i n o p t -> i n c e p t i o n
20:22:43 <lambdabot> flip flip id . ((flip . (liftM2 (flip . ((flip . (flip .)) .) . flip . (flip .)) .)) .) . flip flip id . (liftM2 (flip . ((flip . (flip .)) .)) .) . flip . (flip .) . flip flip
20:22:57 <Favonia> poor lambdabot...
20:23:40 <Favonia> acfoltzer: i feel sorry about it
20:24:03 <parcs> you know what's awesome
20:24:27 <parcs> four or more consecutive flips yield the same function
20:24:36 <parcs> :t flip flip flip flip
20:24:37 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) b1. (Functor f, Functor f1) => f1 ((f (a -> b) -> a -> f b) -> b1) -> f1 b1
20:24:40 <parcs> :t flip flip flip flip flip
20:24:41 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) b1. (Functor f, Functor f1) => f1 ((f (a -> b) -> a -> f b) -> b1) -> f1 b1
20:24:44 <parcs> :t flip flip flip flip flip flip
20:24:46 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) b1. (Functor f, Functor f1) => f1 ((f (a -> b) -> a -> f b) -> b1) -> f1 b1
20:25:25 <Favonia> @unpl flip flip flip flip
20:25:26 <lambdabot> (\ f l -> f l (\ g h i -> g i h))
20:25:39 <parcs> however
20:25:48 <parcs> :t [flip flip flip flip ,flip flip flip flip flip ,flip flip flip flip flip flip ]
20:25:49 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) b1. (Functor f, Functor f1) => [f1 ((f (a -> b) -> a -> f b) -> b1) -> f1 b1]
20:26:14 <parcs> oh, it works!
20:26:26 <Jafet> How flippant
20:26:43 <Favonia> @unpl [flip, flip]
20:26:44 <lambdabot> [(\ a b c -> a c b), (\ d e f -> d f e)]
20:28:16 <parcs> @type (fix <*> flip) flip flip flip
20:28:17 <lambdabot>     Occurs check: cannot construct the infinite type:
20:28:17 <lambdabot>       a = a -> (a -> t -> t1 -> t2) -> t -> t1 -> t2
20:28:17 <lambdabot>     Probable cause: `flip' is applied to too few arguments
20:28:34 <parcs> :t fix flip $ flip flip flip flip
20:28:35 <lambdabot> forall b (f :: * -> *) a b1 (f1 :: * -> *) b2. (Functor f, Functor f1) => (f1 ((f (a -> b1) -> a -> f b1) -> b2) -> f1 b2) -> b
20:29:35 <Jafet> Heh a -> b
20:32:38 <parcs> @pl \f l -> f l (\g h i -> g i h)
20:32:39 <lambdabot> flip flip flip
20:32:43 <lpsmith> ugh,  so the current version of json-builder on hackage is ~25% slower than aeson when serializing json arrays,  which is to be expected as I hadn't really done much benchmarking/tweaking yet.  It's enough slower that it most cases,  it almost wipes out the savings from not having to marshal your data structure into an array.   But I can write code specifically for serializing lists and vectors to
20:32:43 <lpsmith>  JSON arrays with the current approach that almost a factor of two faster than AESON.
20:33:31 <parcs> so i guess it's three or more flips
20:35:14 <lpsmith> And I now have an alternate implementation of json arrays that is comparable to aeson,  but it doesn't seem to benefit from special-casing lists and vectors.  :-(
20:35:46 <luite> hmm, is there a packaga that has ffi bindings for the chroot function?
20:42:29 <mkserra> hello math geniuses and cs professors, quick newbie question
20:42:42 <mkserra> how do I change args <- getArgs
20:42:49 <mkserra> so that args will be a list of Int
20:43:26 <applicative> luite http://hpaste.org/47497/esotericbot_chroot ?
20:43:29 <dmwit> args <- fmap (map read) getArgs
20:43:37 <jmcarthur> mkserra: args <- liftM (map read) getArgs; <use args like a [Int]>
20:44:06 <mkserra> fmap == liftM ?
20:44:10 <mkserra> but they satisfy different laws?
20:44:14 <jmcarthur> same laws
20:44:19 <jmcarthur> different type classes
20:44:25 <jmcarthur> IO is an instance of both
20:44:27 <applicative> they are the same
20:44:30 <mkserra> ahh
20:44:40 <mkserra> thanks guys!
20:45:14 <applicative> @type fmap
20:45:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:45:21 <applicative> @type mapM
20:45:22 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
20:45:27 <applicative> @type (<$>)
20:45:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:45:38 <handonson> is there "mutable linked list" in Haskell?
20:46:04 <dibblego> no, but it would be easy to write one -- not particularly useful though
20:46:30 <applicative> handonson, what are you going to do with a mutable linked list, once you get it
20:46:47 <handonson> store some editable text
20:47:12 <jmcarthur> handonson: why does it need to be mutable?
20:47:23 <jmcarthur> and why does it need to be a linked list?
20:47:25 <handonson> because it is ... editable?
20:47:50 <jmcarthur> mutation is vastly overrated when you can pretty efficiently make new versions of immutable structures
20:48:12 <handonson> like ... 1kb of text?
20:48:13 <dibblego> (:) edits an immutable linked list
20:48:23 <jmcarthur> for some definition of "edits"
20:48:30 <mauke> handonson: 1kb is nothing
20:48:34 <jmcarthur> but yeah, and (:) is really really fast
20:48:51 <mauke> handonson: why do you want to store text in a linked list?
20:48:53 <jmcarthur> handonson: what operations do you need to be efficient?
20:48:57 <dibblego> I use HXT on 320GB of text each day
20:49:00 <jmcarthur> handonson: and yeah, why a linked list?
20:49:21 <handonson> because if i do that with array, it will demand copying a lot
20:49:29 <mauke> do what?
20:49:30 <handonson> for inserting text here and there
20:49:40 <mauke> is that a problem?
20:49:53 <handonson> i don't want to do copying
20:49:56 <jmcarthur> my "inserting" you mean such that the result is longer than the input?
20:49:58 <mauke> why not?
20:49:59 <jmcarthur> *by
20:50:37 <handonson> because I don't want to! look, i'm not trying to make some production-use software. i'm just coding something just for fun, and I want to use mutable linked list for this particular job
20:50:41 <jmcarthur> and i assume you mean you intend to insert into arbitrary locations in the string?
20:50:45 <dibblego> in Java, the typical "alternative" to a linked list is an array -- not so in haskell, we have decent libraries
20:50:48 <handonson> so can't you guys just tell me how to make a mutable linked list in Haskell?
20:51:12 <dibblego> we could, but we are certain you don't want that -- that's why we are asking you these questions to figure what you really do want
20:51:18 <applicative> handonson, dont worry, they are just getting a feeling for the problem, imagining all the possibilities
20:51:19 <dibblego> is that cool with you?
20:51:44 <jmcarthur> handonson: what you are asking is not very useful or convenient for any use case i can think of involving text. we are trying to help you find a better way, *especially* for something you are just trying to get done quickly
20:52:28 <handonson> jmcarthur: no. To get it done *quickly*, I can just use any immutable structure provided by Haskell Platform.
20:53:05 <jmcarthur> handonson: i'm leaning toward Data.Sequence right now, but if we know more about what you're actually doing we might be able to advise something better.
20:53:32 <dibblego> Zipper is another alternative
20:53:39 <jmcarthur> yes
20:53:45 <handonson> jmcarthur: and you're right about the point that, some new text will be inserted to arbitrary position
20:54:00 <handonson> or removed from
20:54:04 <dibblego> I work with text editors a lot -- we use zippers for this
20:54:14 <jmcarthur> zippers are very nice indeed
20:54:26 <mauke> handonson: "I don't want to" is not particularly helpful
20:54:49 <handonson> mauke: to whom?
20:54:55 <mauke> anyone
20:54:57 <handonson> and for what?
20:55:13 <mauke> understanding your constraints, getting the code written
20:55:20 <jmcarthur> handonson: what you are asking is not very haskelly at all, and that's the reason we are confused
20:55:32 <mauke> handonson: do you know about IORefs?
20:55:35 <fragamus> @type stdUniform
20:55:36 <lambdabot> Not in scope: `stdUniform'
20:55:52 <dibblego> it is so not useful, that I doubt anybody has bothered writing it
20:56:44 <jmcarthur> dibblego: (i've implemented a mutable doubly linked list in haskell before, but immediately regretted it)
20:57:00 <dibblego> DList dude
20:57:14 <handonson> jmcarthur: why isn't mutable structures haskelly?
20:57:54 <fragamus> @hoogle stdUniform
20:57:54 <lambdabot> No results found
20:57:57 <jmcarthur> handonson: because purity is nice
20:58:10 <jmcarthur> and worth getting used to
20:58:30 <handonson> and why do we have all these mutable structures for IO, State, STM, etc then?
20:58:38 <applicative> I see, zippers have already come up.
20:58:52 <applicative> handonson, maybe take a look at the simple http://hackage.haskell.org/package/ListZipper
20:59:03 <jmcarthur> IORef is a crutch. State is not mutation. STM is more for shared-memory concurrency than plain mutation
20:59:14 <dibblego> handonson: State is not mutable, IO and ST are controlling certain types of mutation that are significantly departed from your use-case
20:59:45 <handonson> dibblego: I already use ST in my use-case
21:00:08 <dibblego> handonson: I am inclined to suspect it is inappropriate
21:00:10 <handonson> jmcarthur: what do you think about MArrays?
21:00:23 <jmcarthur> usually inappropriate
21:00:29 <dibblego> try Data.Sequence for your use-case
21:00:31 <handonson> they're not haskelly?
21:00:58 <fragamus> @type boxMullerNormalPair
21:00:59 <lambdabot> Not in scope: `boxMullerNormalPair'
21:01:00 <dibblego> handonson: it is a combination of your stated problem and suggested solution that is not haskelly
21:01:16 <luite> what's a good way to get the number of processes in a process group, in linux?
21:01:31 <handonson> dibblego: i didn't ask you
21:01:33 <dibblego> we could go right ahead and create a mutable linked list, but you'd be hard-pressed to come up with a use-case for which it is appropriate
21:02:05 <jmcarthur> handonson: dibblego has my permission to answer for me. i will speak up if he preempts me with an answer i disagree with
21:02:26 <handonson> dibblego: I asked only "mutable linked list" and he responded "it's not haskelly at all"
21:02:41 <dibblego> handonson: I suspect this is because there is no use-case for it
21:02:41 <handonson> dibblego: so how do you deduce "it is a combination of your stated problem and suggested solution that is not haskelly" here?
21:02:55 <handonson> where the stated problem... is not stated?
21:02:57 <koninkje_away> dibblego: TChans are implemented as mutable linked lists
21:02:57 <lambdabot> koninkje_away: You have 1 new message. '/msg lambdabot @messages' to read it.
21:03:01 <dibblego> handonson: because there exist structures, such as IO and ST, for where there are legitimate use-cases
21:03:19 <dibblego> koninkje_away: thanks
21:03:24 <jmcarthur> handonson: i've never seen an appropriate use case for mutable linked lists in a haskell project. we have nicer, simpler alternatives
21:03:26 <fragamus> @messages
21:03:26 <lambdabot> You don't have any new messages.
21:03:48 <jmcarthur> handonson: it would help if you would actually state the problem as we've been asking. we can't really help much otherwise.
21:04:11 <handonson> jmcarthur: and TChans are not part of an appropriate haskell project?
21:04:23 <jmcarthur> when did i say that?
21:04:41 <handonson> you've never seen an appropriate use case for mutable linked lists in a haskell project, didn't you?
21:04:49 <handonson> i mean, have you?
21:05:07 <dibblego> "I haven't seen" is distinct from "There exists"
21:05:17 <dibblego> *not exists
21:05:25 <handonson> dibblego: and he hasn't seen TChans before?
21:05:37 <dibblego> I don't know, I can't speak for that much
21:05:46 <applicative> hm, TChans http://hackage.haskell.org/packages/archive/stm/2.1.1.2/doc/html/src/Control-Concurrent-STM-TChan.html
21:05:50 <jmcarthur> i've used STM, but never TChan
21:06:03 <koninkje_away> dibblego: Though, to be fair, the "mutation" is of the write-once variety
21:06:05 <jmcarthur> i've never used Chan either
21:06:32 <konikje> That is, it's only there for appending to the end of the list
21:06:33 <applicative> data TList a = TNil | TCons a (TVarList a)  ; type TVarList a = TVar (TList a)
21:07:21 <jmcarthur> applicative: i have an empty TList. how do i destructively append a list to it?
21:07:22 <dibblego> I doubt a linked list is appropriate at all, mutable or not, but we are having difficulty getting to the problem
21:07:54 <jmcarthur> applicative: (my point is that there are also many ways a linked list can be mutable)
21:08:02 <konikje> jmcarthur: you never "have an empty TList", you only ever have a TVar (TList a)
21:08:14 <jmcarthur> konikje: aha
21:08:17 <applicative> It doesn't seem appropriate for an editor, does it.  konikje seems to have experience with it
21:08:26 <konikje> jmcarthur: in the implementation, I mean
21:08:29 <jmcarthur> yeah
21:09:10 <konikje> It's just a standard linked list FIFO buffer: keep pointers to the head and tail, adjust the head on read, adjust the tail on write
21:09:21 <dibblego> "...some new text will be inserted to arbitrary position" <-- not a linked list
21:09:52 <handonson> dibblego: why not?
21:10:15 <dibblego> because insertion will be expensive
21:10:19 <jmcarthur> requires attaching at both ends of the inserted string
21:10:32 <dibblego> this is beside the point of mutable or not
21:10:37 <handonson> in C you can have linked lists with destructive updates like inserting some items to an arbitrary position, that takes constant time
21:10:43 <konikje> That problem specification sounds a bit like an IntMap, only one that exposes its trie structure so that you can easily increase the indices of all the end
21:11:01 <jmcarthur> handonson: only if you had already traversed the list to the point you want to insert, which took O(n) time
21:11:21 <jmcarthur> handonson: and if that's the kind of usage you are planning, a zipper would be perfect
21:11:41 <dibblego> I am reasonably confident a zipper is most appropriate
21:11:54 <handonson> i'm reading the zipper docs and it seems right
21:11:55 <dibblego> but Data.Sequence may help as an intermediate step
21:12:22 <konikje> Data.Sequence only helps for adding/removing on both ends; not random
21:12:23 <applicative> the last bit of 'learn you a haskell' is about zippers, I'm not sure how successful it is though
21:12:39 <jmcarthur> konikje: O(log n) split and append, isn't it?
21:12:44 <jmcarthur> or something like that
21:12:50 <konikje> probably
21:12:54 <dibblego> ah yeah, I was thinking IntMap conceptually
21:13:12 <konikje> jmcarthur: but that's not the ideal use case
21:13:31 <applicative> yi uses a zipper, but I think it is doing something much more complicated
21:13:32 <handonson> is it the ListZipper package or is there something else I have to take a look?
21:14:12 <jmcarthur> konikje: i'm not sure that you can do much better for arbitrary insertion than O(log n) unless you can benefit from having already traversed to the correct point for other reasons
21:14:23 <konikje> true
21:14:38 <handonson> how is IntMap implemented?
21:14:40 <jmcarthur> Data.Sequence has pretty bad constant factors, though, sadly
21:14:49 <konikje> handonson: big-endian patricia trie
21:15:26 <jmcarthur> at least for splitting and appending
21:15:31 <konikje> i.e., trie-ing on the bits of the number in big-endian order
21:15:32 <applicative> there is a pile of zipper stuff on hackage, but I think people write them on the fly. here's the Illustrated Guide http://learnyouahaskell.com/zippers
21:15:35 <jmcarthur> and its space usage is kind of unfortunate
21:15:52 <jmcarthur> Seq, i mean. IntMap is nice
21:16:23 <konikje> jmcarthur: do you know if the Data.Seq issues are algorithmic problems vs implementation problems?
21:16:27 <handonson> what? trie? for IntMap? the naming convention of computer scientists is still beyond my understanding
21:16:59 <konikje> handonson: there should be a link to the paper it's based on, which is pretty readable
21:16:59 <jmcarthur> konikje: i suspect it's just due to trashing the cache
21:17:05 * konikje nods
21:17:27 <applicative> handonson, the literature surrounding the zipper concept is unbelievably beautiful, by the way.
21:17:48 <konikje> handonson: essentially, for IntMap, it's a binary tree where you chose the left or right branch based on whether the "next" bit of the Int is 0 or 1
21:18:09 <konikje> there are some optimizations to help flatten the tree when it's sparse though
21:18:50 <handonson> huh.
21:19:04 <handonson> that sounds ... feasible
21:19:34 <koninkje> The awesomeness of IntMap is due to two factors:
21:19:46 <koninkje> 1) you never need to bother with rebalancing stuff
21:20:04 <koninkje> 2) you get fast support for set-theoretic operations like union, intersection,...
21:20:29 <handonson> I understand 1 but 2 is ... what?
21:20:33 <handonson> really? how?
21:20:43 <koninkje> IntSet is the same thing, the only difference between the two is whether the keys have associated values
21:20:50 <koninkje> handonson: read the paper :)
21:21:01 <handonson> how do you efficiently make a union of two tries? oh okay
21:21:14 <BMeph> Bah. Reading papers is for l00serZ. ;þ
21:21:39 <koninkje> You only need to traverse the part of the trie that intersects, so you can stitch them together
21:22:05 <koninkje> BMeph: but Okasaki rocks :)
21:23:05 <koninkje> E.g., union etc for IntMap is O(n+m) which is just about optimal
21:23:45 <koninkje> Much better than the O(m*log n) you get with some other structures
21:25:04 <koninkje> handonson: Or you could just read the source code :)
21:25:26 <holmak> Can anyone recommend a good way to recursively grab all the filenames from a directory? Aside from rolling my own from getDirectoryContents?
21:26:18 <dibblego> holmak: hackage/filemanip
21:28:40 <holmak> filemanip looks nice, but it says it only works on Unix systems...is that the case?
21:29:51 <dibblego> yeah dunno if it still does -- I wrote a small package called filepather because of that
21:32:35 <Volt_> holmak: check out the tar package. Codec.Archive.Tar.Entry has a getDirectoryContentsRecursive function.
21:35:35 <handonson> I can't pick the right package of zipper.
21:35:55 <The_Ice> looks like it's easy to write your own getDirectoryContants-based, than add unnecessary depends
21:38:00 <scrappy_doo> hello haskellers
21:38:32 <holmak> Why do work when I can shamelessly leech off of other peoples'? :)
21:40:27 <applicative> holmak did someone mention http://hackage.haskell.org/package/directory-tree-0.10.0 It should be portable. I
21:41:08 <uniquenick> why is 0.1 * 1 ok, but if I define "x = (0.1, 1)" and then do "fst x * snd x" I get a type error?
21:41:19 <applicative> holmak, I notice it has few but reputable reverse dependencies http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/directory-tree-0.10.0#direct
21:41:23 <mauke> monomorphism restriction
21:42:16 <scrappy_doo> Does anyone know how to convert a Data.Time.Clock.NominalDiffTime to plain seconds?
21:42:27 <handonson> scrappy_doo: realToFrac
21:43:05 <handonson> I had some hassle figuring out that too
21:43:08 <holmak> applicative: Good call on the dependencies. I had seen that package, but was slightly bewildered by the API. I'll look again.
21:43:33 <uniquenick> mauke: so what am I supposed to do instead?
21:43:42 <applicative> uniquenick: give a type
21:43:52 <handonson> uniquenick: x = (0.1, 1.0)
21:43:57 <mauke> uniquenick: explicit type signature or disable the monomorphism restriction
21:44:02 <applicative> uniquenick: or else use -XNoMonomorphismRestriction :)
21:44:20 <applicative> @type (1.1,1)
21:44:20 <lambdabot> forall t t1. (Fractional t, Num t1) => (t, t1)
21:44:39 <applicative> @type let x = (1.1,1) in fst x * snd x
21:44:40 <lambdabot> forall b. (Fractional b) => b
21:44:52 <applicative> > let x = (1.1,1) in fst x * snd x
21:44:53 <lambdabot>   1.1
21:45:17 <applicative> ^^^ in lambdabot they use NoMonomorphismRestriction
21:45:49 <Omie> hi ! there isn't any way to access clipboard on Linux platform ?
21:45:52 <applicative> uniquenick, is this error occurring inside ghci?
21:45:57 <uniquenick> yeah
21:46:18 <handonson> uniquenick: when you write a numeric literal, the compiler will try to infer the type of that literal, as "1" can be any of Int, Integer, Float, Double, etc. So what you do is, 1. Give it an explicit type signature, so the compiler won't have to 'guess' any more. e.g. (0.1, 1) :: (Float, Float)
21:46:21 <uniquenick> I am not really trying to fix it, since I know I can just do x = (0.1,1.0)
21:46:25 <applicative> ghci will default to reading (1.1,1) as (Double,Integer)
21:46:42 <uniquenick> just trying to understand why and the more general "what type thingy do I add to fix this"
21:47:24 <handonson> 2. Disable monomorphism restriction, so 1 can be any type that is instance of Num
21:48:19 <handonson> iirc it was in ghci ... :set -XNoMonomorphismRestriction ?
21:48:34 <handonson> or maybe i'm totally wrong.
21:48:44 <applicative> thats exactly right
21:49:19 <uniquenick> so, tacking a "x :: (Double, Double)" in there is a "correct" thing to do?
21:49:33 <handonson> one of the correct things, yes
21:49:38 <applicative> if that's what you're talking about I suppose.
21:50:03 <applicative> but the first line of my .ghci file is :set -XNoMonomorphismRestriction like handonson said.  it has occasional downsides
21:50:07 <Axman6> if you want the most general type, then you'd use "x :: (Floating a, Floating b) => (a,b)" >_>
21:50:19 <mauke> that's not the most general type
21:50:34 <Axman6> s/the most/a more/
21:50:43 <mauke> <lambdabot> forall t t1. (Fractional t, Num t1) => (t, t1)
21:51:18 <handonson> uniquenick: you may want to do x :: (Float, Float) instead of x :: (Double, Double) if what you're going to do is mainly about multiplication ... although the difference is very small in modern CPUs.
21:55:00 <applicative> uniquenick: part of this is just the defaulting done inside ghci, if I understand.  for example, you will presumably get an error if you try this:
21:55:02 <applicative> > let x = (1.1,1) in take (snd x) "ha"
21:55:03 <lambdabot>   "h"
21:55:15 <applicative> since
21:55:18 <applicative> @type take
21:55:19 <lambdabot> forall a. Int -> [a] -> [a]
21:55:31 <applicative> but ghci will take snd x to be an Integer
21:56:51 <scrappy_doo> Why is DiffTime defined as "MkDiffTime Pico" if it's a number of seconds?
21:57:15 <mauke> scrappy_doo: why not?
21:57:42 <scrappy_doo> mauke is Pico some kind of data type?  It sounds like picosecods instead of seconds.
21:58:13 <applicative> uniquenick: I am supposing you define x = (1.1,1) on one line in ghci , then try to use snd x with take later.  the inference will already have occurred
21:59:39 <applicative> uniquenick: it will let you get away with the one liner << let x = (1.1,1) in take (snd x) "ha" >> since the second part forces an interpretation on the first
22:00:54 <applicative> uniquenick: a lot of this nonsense wont occur if you import a module in which you define these things without signatures since ghc has all the information at once, so to speak
22:15:15 * applicative wonders what's next after "Agda compiler backend targeting JavaScript"
22:19:28 <uniquenick> is there already a function equivilent to: map (\ (a, b) -> a * b)?
22:20:24 <mauke> :t map (uncurry (*))
22:20:25 <lambdabot> forall a. (Num a) => [(a, a)] -> [a]
22:21:11 * albel727 wonders if uniq means (.)
22:22:59 * hackagebot hsignal 0.2.2 - Signal processing and EEG data analysis  http://hackage.haskell.org/package/hsignal-0.2.2 (VivianMcPhail)
22:24:24 <scrappy_doo> handonson thanks
22:28:33 <scrappy_doo> Why is DiffTime a Real?  It doesn't make sense to multiply or divide times by each other.
22:55:50 <roconnor> @type fromRational
22:55:51 <lambdabot> forall a. (Fractional a) => Rational -> a
22:55:54 <roconnor> @type toRational
22:55:55 <lambdabot> forall a. (Real a) => a -> Rational
22:56:03 <roconnor> scrappy_doo: only to get toRational I think
22:56:38 <roconnor> not that I think that it is worth it
23:07:48 <Azverkan> whats the correct cross platform way to abort on ctrl-c / ctrl-break events for Haskell executables that make calls to blocking foreign C functions?
23:24:21 <Omie> Hi ! Need help with clipboard object. clipboardGet returns IO Clipboard. and textBufferCutClipboard requires Clipboard. How do I get clipboard from IO Clipboard ?
23:29:01 <roconnor> Omie: "do {clipboard <- clipboardGet; foo textBufferCutClipboard }"
23:29:10 <roconnor> er
23:29:21 <roconnor> Omie: "do {clipboard <- clipboardGet; textBufferCutClipboard clipboard }"
23:29:24 <roconnor> better
23:36:38 <Omie> roconnor: thanks
23:37:47 <Omie> and how do I check types of methods in gtk classes in terminal ? something like :l Graphics.UI.Gtk.Multilne.TextBuffer first ?
23:41:06 <mauke> you can 'import' modules in ghci
23:43:08 <handonson> Omie: :m + Graphics.UI.Gtk is the traditional way
23:43:23 <handonson> this imports virtually everything in GTK
23:43:36 <handonson> or just use 'import' as m·auke said
23:46:04 <Omie> oh, okay. thanks
23:47:26 <Omie> now when it says
23:47:27 <Omie> textBufferCutClipboard  :: (TextBufferClass self) => self -> Clipboard -> Bool -> IO ()
23:47:29 <Omie> I'm supposed to call it like textBufferCutClipboard textBufferObject clipboardObject boolValue
23:47:30 <Omie> right ?
23:48:06 <handonson> i think so ... ?
23:48:44 <Omie> that => confuses me :(
23:48:56 <Omie> what does it mean exactly ?
23:49:05 <mauke> => separates class constraints from the type
23:49:19 <Omie> means ?
23:49:24 <saati> self is a TextBufferClass in the following expression
23:49:25 <mauke> here it says that self must implement TextBufferClass
23:49:28 <saati> and self -> Clipboard -> Bool -> IO ()
23:50:02 <poltak> You guys don't think Haskell will ever been taught in schools?
23:50:12 <saati> poltak: there are schools teaching haskell
23:51:13 <adu> becuase haskell is awesome
23:52:04 <Omie> got the above part. thanks. I still have more questions though :-P
23:53:08 <Omie> buff <- textViewGetBuffer $ mainText gui works fine in other functions but now its saying     Couldn't match expected type `IO TextBuffer'  against inferred type `SelectionTag -> TextBuffer'
23:53:24 <mauke> missing function argument?
23:54:26 <ion> omie: You may want to read LYAH.
23:54:48 <Omie> this is my code - http://hpaste.org/47500/notepadinprogress
23:54:52 <adu> Omie: => means context
23:54:58 <Omie> error on ine 182
23:55:24 <adu> Omie f :: C a => a -> r
23:55:27 <Jafet> ion: nah, Haskell is magic. You can write code in it without understanding and it just works
23:55:38 <ion> true
23:55:41 <argiopeweb> Jafet: I have long expected such a thing is true.
23:55:42 <mauke> Omie: what's the type of textViewGetBuffer?
23:55:53 <Omie> I've got RWH in hands. read few things but I am not getting it much, so thought to jump in coding directly
23:56:05 <adu> means that f is a function of 1 parameter 'a', and returns 'r' and that the context assertion 'C a' is true about 'a', roughly speaking
23:56:17 <argiopeweb> Jafet: I've been waiting for the research document with the proofs for awhile though. ;)
23:56:28 <Omie> mauke: its textViewGetBuffer :: (TextViewClass self) => self -> IO TextBuffer
23:56:44 <ion> Jump to LYAH.
23:56:45 <argiopeweb> Omie: Read LYAH then RWH. All will be clear.
23:57:00 <argiopeweb> Further, somewhat of RWH is now out of date.
23:57:16 <mauke> Omie: oh, no idea then
23:57:49 <shurane> sipa, BMeph: what's the difference between the ways you guys went around digitifying a number and this: let n = 0 in [ read [t] :: Int | t <- show n]
23:59:18 <Jafet> shurane: that one looks ugly
23:59:24 <shurane> argiopeweb: why do you say RWH is out of date?
23:59:26 <Jafet> It's also partial; consider n = -1
23:59:37 <adu> RWH is brand new
23:59:41 <adu> WTF
