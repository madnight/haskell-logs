00:00:11 <mauke> probably exceptions and possibly mtl
00:00:35 <argiopeweb> shurane: Quickcheck 1 is deprecated, They introduce n + k-patterns (albeit with a caveat). The FFI is now in the standard. Those three come to mind right off.
00:00:49 <shurane> Jafet: I don't think the other two pieces of code handle that either, I think.
00:00:51 <Jafet> Real Old Haskell
00:01:03 <Jafet> shurane: what were the other versions?
00:01:17 <shurane> argiopeweb: alright cool, just wanted some pointers before I slog through it.
00:01:41 <shurane> argiopeweb: although it's got a commenting system -- I wonder if that's noted somewhere?
00:01:47 <argiopeweb> shurane: Most of it is.
00:02:04 <argiopeweb> The few things that are out of date become obvious once you try to use them.
00:02:20 <Jafet> argiopeweb: of course, those are just tools to present the actual ideas, so the fact that the implementation has moved on is no detraction.
00:02:22 <argiopeweb> And quickcheck 1 is still around, QC2 is just worlds better.
00:02:53 <argiopeweb> Jafet: Hence "somewhat of RWH is now out of date", not "Don't read RWH, it is no longer relevant"
00:02:56 <adu> n+k is so passe
00:03:15 <shurane> Jafet: listify n = (map (read . (:[])) . show) n :: [Int]
00:03:16 <Jafet> Well, the outdated parts have no extant substitute.
00:03:28 <Jafet> So that's not a very useful comment, either.
00:03:51 * ddarius wonders if QuickCheck 2 is QuickCheck 2 Deux or is the same QuickCheck 2 that's been around for almost a decade.
00:04:20 <Jafet> shurane: oh that one's identical
00:04:40 <argiopeweb> ddarius: I honestly don't know. I simply know "QC in RWH" and "the QC that gets installed by cabal unless you specify a version"
00:05:48 <jaspervdj> ddarius: cabal install quickcheck will install QuickCheck 2
00:05:59 <exeter> I am using getDirectoryContents, and subsequently filter the results for "." and ".." to get "clean" contents. Still, I fear this is not at all portable (working on win32 here). Is there a "correct" way to do what I'm trying to do?
00:06:01 <jaspervdj> Because it's the latest version
00:06:23 <mauke> exeter: I think that is the correct way
00:06:26 <ddarius> jaspervdj: Why are you telling me that?
00:07:05 <jaspervdj> ddarius: Uh, I thought you asked two minutes ago? 09:24  ! ddarius wonders if QuickCheck 2...
00:07:08 <exeter> mauke: soon I will switch to linux, will it work there too? (or on bsd systems, for what is worth?) It seems a clever hack!
00:07:40 <mauke> exeter: honestly, I'm surprised you get "." and ".." on windows
00:07:46 <mauke> it's a rather unixy thing
00:07:52 <ddarius> jaspervdj: And how do you think your comment answers my question at all?
00:08:10 <exeter> ahah, well, that is that then, thanks mauke
00:09:07 <jaspervdj> ddarius: Oh, I'm sorry if it didn't, I must've misunderstood you
00:10:05 <mauke> I'm not sure if I'm confused less or confused more
00:10:40 <exeter> mauke: are you referring to my answer?
00:10:48 <exeter> or to ddarius' one?
00:11:15 <mauke> jaspervdj's
00:14:34 <Jafet> "." and ".." are valid filenames in Windows, and probably reserved for the same purpose
00:15:15 <poltak> saati: schools such as?
00:15:44 <saati> poltak: http://www.haskell.org/haskellwiki/Haskell_in_education
00:17:40 <poltak> saati: I am completely and utterly shocked
00:17:44 <mauke> Jafet: yes, but getting them back from readdir() seems curious
00:18:09 <Jafet> That depends on which readdir you were using, eh.
00:18:20 <shurane> Jafet: while we're on the subject, is there a way to enforce like... natural numbers instead of integers? Or just Z+?
00:18:25 <Jafet> A cygwin readdir would invariably do it
00:18:33 <shurane> well, rather something built in, I mean
00:18:53 <Jafet> shurane: f n | n <= 0 = error "zomg runtime exception" | otherwise = ...
00:19:44 <handonson> shurane: use Data.Word.Word32
00:19:45 <Jafet> You could make your own type and enforce it as best you can, but then you run into Num-hates-you.
00:19:49 <handonson> unsigned integers!
00:19:52 <handonson> sorry.
00:20:44 <poltak> hang on. I have do a shit now. Will be back soon!
00:20:51 <ddarius> Sooner or later, there will be a built-in Natural type like the built-in Integer type.
00:21:14 <mauke> it can't take more than a few decades
00:21:29 <exeter> ^-- the shit of poltak
00:22:29 <Jafet> I support any effort by poltak to become less full of shit
00:22:39 <ddarius> Jafet: Good luck.
00:28:06 <Jafet> Hrm, I wonder.
00:28:14 <Jafet> > (-1) :: Word32
00:28:15 <lambdabot>   4294967295
00:28:36 <Jafet> D'oh
00:28:40 <ddarius> > complement 0 :: Integer
00:28:41 <lambdabot>   -1
00:28:59 <albel727> not unexpected, really.
00:29:06 <ddarius> Completely expected.
00:47:32 <scrappy_doo> shurane: there's a Natural type definition at http://www.haskell.org/tutorial/moretypes.html
01:02:48 <exeter> I've got a function k a->b and a constructor data Qqqq = Cnst b. When I write (Cnst.f) in a "map" expression iget a "Not in scope" error. How to fix this?
01:03:10 <exeter> (i.e. to be able to "chain" constructors and functions)
01:03:41 <Saizan> exeter: put spaces around the .
01:04:10 <Saizan> otherwise Cnst is interpreted as a module name
01:04:38 <exeter> thanks
01:04:43 <mauke> you should put spaces around operators anyway
01:05:17 <exeter> mauke: i do, but "." is more readable when "unspaced", I feel
01:05:25 <mauke> you're wrong
01:05:30 <exeter> :o
01:05:43 <mauke> I shall call this C programmer's disease
01:05:49 <exeter> :D
01:05:57 * exeter is a former C++ programmer
01:06:02 <mauke> it makes sense if you're accessing struct members or something
01:06:15 <mauke> it makes no sense if . is a completely unrelated operator
01:06:38 <mauke> funnily enough I see the same thing in Perl
01:06:48 <mauke> (. is string concatenation there)
01:09:51 <shachaf> mauke: Do spaces around operators make sense in general?
01:10:21 <shachaf> I shall call that non-J programmer's disease
01:10:33 <mauke> heh
01:11:04 <shachaf> I'm not really convinced that the whole spaces-around-operators thing is worth it in readability.
01:11:42 <shachaf> But if you do it for, say, (+), you should do it for (.).
01:12:31 <mauke> and if you do it for ., you should do it for +
01:12:35 <mauke> and you have to do it for .
01:12:36 <edon> there is also a prettifier for emacs which makes \ a lambda and . a compisition operator (a circle), and it doesn't work if you don't put spaces around it
01:12:44 <shachaf> mauke: Only for constructors.
01:13:12 <shachaf> edon: So some emacs prettifier somewhere is broken?
01:14:15 <handonson> i have *never* seen anyone writing "f$g x". it seems pretty obvious that spacing infix operators is at least the dominant convention in Haskell.
01:15:32 <ion> $x also means something else than $ x when using TemplateHaskell IIRC.
01:18:08 <Saizan> spacing is less common in sections
01:29:38 * ddarius will call the belief that there must be rigid rules for laying out code, programmer's disease.
01:36:53 <argiopeweb> ddarius: Does that make everyone who uses a language which is alignment sensitive (Haskell, Python, etc) a carrier?
01:37:04 * mux wonders what to use for efficiently converting integral types to/from ByteString's
01:37:30 <argiopeweb> mux: Binary?
01:38:40 <mux> mmm, I guess I could do that.
01:38:51 <argiopeweb> As in Data.Binary, not any other possible interpretation of that interrogative statement.
01:39:20 <mux> except that binary deals with lazy bytestrings.
01:39:54 <rtharper> is it possible using lhs2TeX to have a code block in a different style than the rest of the doc?
01:40:36 <argiopeweb> mux: That's addressed in the binary docs, though I don't remember what the end conclusion is. The other serialization library does strict, but I can't for the life of me remember what it's called.
01:40:46 <mux> argiopeweb: cereal
01:41:00 <argiopeweb> Of course.
01:41:03 <mux> but serialization libraries are definitely too much for what I need
01:41:57 <ddarius> argiopeweb: No.
01:43:32 <argiopeweb> mux: Have you looked at Text.Parse.ByteString?
01:44:39 <mux> argiopeweb: well I'm already using attoparsec
01:44:54 <argiopeweb> Further, that's the inverse of what you want... I'm starting to think it's bed time.
01:45:05 <mux> I actually need both ways
01:46:27 <mux> attoparsec actually already gives me numeric parsers that should be just fine
01:47:35 <argiopeweb> And my muddled brain isn't giving me the answer to replacing show..
01:47:35 <mux> I'll just have to decide on what to use for formatting (maybe Text.Printf.Mauke)
01:48:50 <kosmikus> rtharper: only by compiling it separately
01:49:00 <rtharper> kosmikus: ah, kk, thanks
01:50:27 <argiopeweb> mux: I personally would just use Data.Binary.encode, but if you really need strict, I've reached my mental capacity for this wake cycle. ;)
01:50:52 <o-_-o> byorgey: ?
01:53:06 <o-_-o> http://hpaste.org/47502/diagramslib_compile_error
01:53:09 <mux> argiopeweb: I loathe using a full-featured serialization binary just to format integral numbers, I'd rather keep on using B.pack . show :-)
01:53:19 <mux> s/binary/library/
01:53:20 <o-_-o> Can anyone help me with this error ?
01:53:24 <rtharper> kosmikus: I need to stop finding ways to need lhs2TeX to do exotic things for me
01:53:42 <mux> http://hackage.haskell.org/package/bytestring-show-0.3.4 that would be okay I guess
01:53:56 <kosmikus> rtharper: it's not all that exotic
01:54:07 <rtharper> =p
01:54:19 <kosmikus> rtharper: which styles do you want to use at the same time, btw?
01:54:25 <rtharper> poly and tt
01:54:34 <mux> damn, it uses lazy bytestrings...
01:54:42 <rtharper> but it was for something I was using verbatim for, but wanted some fancy formatting for some of the names
01:54:54 <rtharper> I used alltt and just set the mathematical symbols mysef
01:55:01 <rtharper> myself*
01:55:47 <MasseR> Is 'foreign' a keyword?
01:56:11 <MasseR> Or rather, why does 'foreign = undefined' give parse errors
01:56:19 <MasseR> Wait.. FFI?
01:56:27 * mux guesses so
01:56:29 <argiopeweb> Yep.
01:57:00 <argiopeweb> mux: I'm not sure B.pack . show is really doing what I thought you were trying to do, but I suppose it works. :\
01:58:22 <argiopeweb> And it's going to be a pain in multiple parts of the anatomy to bit-pack an integral type into a bytestring without invoking (ominous dominus) a serialization library.
01:58:48 <mux> argiopeweb: well I'm just formatting integral values into ByteStrings, so B.pack . show obviously works :)
01:59:29 <argiopeweb> I'd say just stick with that then. Give it a function name and run. It's not like some library is going to be any faster. :P
02:00:31 <argiopeweb> And with that, 3 hours of sleep is needed.
02:00:52 <mux> argiopeweb: a library sure would be faster, there's quite an overhead in having an intermediate String representation
02:02:04 <serrph> hi, I am learning haskell and I'm having trouble figuring out something on my code. Is this the right place for this kind of questions?
02:04:46 <roconnor> serrph: yes
02:06:45 <serrph> roconnor: http://hpaste.org/47503/typedoubt, I'm having trouble finding the type for this function
02:08:09 <serrph> roconnor: ghci says it should start with (Integral b, Floating b), but how one be both?
02:08:41 <roconnor> serrph: what is the type ghci gives?
02:09:01 <serrph> (Integral b, Floating b) => b -> b -> b
02:09:06 <roconnor> serrph: the problem appears to be in the use of **
02:09:20 <roconnor> there are 3-exponential operators in haskell, each with thier ownuse
02:09:23 <roconnor> :type (^)
02:09:33 <roconnor> @type (^)
02:09:34 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
02:09:43 <roconnor> this one works for positive integer exponents
02:09:48 <roconnor> @type (^^)
02:09:49 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
02:09:54 <roconnor> this one works for positive or negative integer exponents
02:09:59 <roconnor> @type (**)
02:10:00 <lambdabot> forall a. (Floating a) => a -> a -> a
02:10:07 <roconnor> this one works for floating point exponents
02:10:26 <roconnor> serrph: in your case n is an postive integer, so you likely want  to use (^) instead of (**)
02:10:48 <roconnor> (by possitive I really mean non-negative)
02:11:54 <serrph> roconnor: and should i leave ** with the (-d) exponent?
02:12:46 <roconnor> serrph: is d supposed to be a floating point number?
02:12:51 <serrph> yes
02:13:01 <roconnor> then you  can leave it be although...
02:13:01 <serrph> roconnor: it appears to be right now
02:13:23 <roconnor> I shoudl mentiong that (exp 1)**(-d) is equal to exp (-d)
02:14:33 * roconnor realizes that Pdf isn't portalbe document format, but probabity density function
02:14:44 <serrph> roconnor: oh, yes - thank you. I was just thinking about the e constant. This didn't even cross my mind
02:45:06 * hackagebot bibtex 0.0.6.1 - Parse, format and processing BibTeX files  http://hackage.haskell.org/package/bibtex-0.0.6.1 (HenningThielemann)
03:10:22 * hackagebot egison 0.1.2.1 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-0.1.2.1 (SatoshiEgi)
03:20:41 <Veid> How can I create an "or" expression in a list comprehension? Like: [x | x <- [1..10], (x `mod` 2 == 0) OR (x `mod` 3 ==0)]
03:22:04 <erus`> Veid yes
03:22:09 <erus`> ||
03:22:14 <Veid> Oh
03:22:16 <Veid> Wow
03:22:18 <erus`> > True || True
03:22:19 <lambdabot>   True
03:22:21 <Veid> I should have tried that
03:22:25 <Veid> Stupid me!
03:22:30 <Veid> Thank you
03:23:10 <identity_> Veid: When in doubt, look up the type signature. Although Bool -> Bool -> Bool isn't quite as filled with information as some type signatures are, but it will still find it for you if try
03:23:16 <identity_> @hoogle Bool -> Bool -> Bool
03:23:16 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
03:23:17 <lambdabot> Prelude (||) :: Bool -> Bool -> Bool
03:23:17 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
03:23:27 * osfameron skims http://okmij.org/ftp/Haskell/Zipper2.lhs and eeeks
03:23:36 <identity_> That's assuming you recognize && and || from other languages
03:23:40 <identity_> Like C or something
03:23:55 <Veid> I do recognize it. I just didn't think that it would be the same in Haskell
03:24:15 <identity_> Hoogle that shit up
03:24:24 <Veid> Didn't know about hoogle, thanks for showing me that
03:24:29 <identity_> Yeah, it's awesome
03:24:34 <identity_> You can get a plugin for it as well
03:24:38 <identity_> So that you can hoogle in your terminal
03:24:52 <Veid> Where
03:24:54 <identity_> And with the right configuration, you can add a :hoogle command to ghci as well
03:24:59 <identity_> Let me find a link for you, sec
03:25:01 <Veid> Oh my
03:25:26 <identity_> http://www.haskell.org/haskellwiki/Hoogle
03:25:33 <identity_> cabal install hoogle
03:25:33 <identity_> echo >> ~/.ghci ':def hoogle \x -> return $ ":!hoogle \"" ++ x ++ "\""'
03:27:11 <Veid> Installing it, do do do
03:27:36 <identity_> Also, "plugin" wasn't the right word to use. It's a standalone app, etc
03:36:26 * hackagebot latex 0.1 - Parse, format and process LaTeX files  http://hackage.haskell.org/package/latex-0.1 (HenningThielemann)
03:56:08 <blackdog> is there no way to do profiling with parallel haskell programs?
03:56:17 <blackdog> ghc tells me I need -N1 with -p
04:00:27 <Saizan> i'm pretty sure i've seen profiles for programs running on more than one OS thread
04:05:02 <identity_> I seem to remember there being a way to make hoogle only show a few results when you use it instead of it flooding my terminal with thousands of functions
04:05:06 <identity_> can't seem to find it
04:05:11 <identity_> anyone happe nto have it handy?
04:05:55 <Saizan> checked hoogle --help?
04:06:03 <identity_> yeah, doesn't really tell me much
04:06:09 <identity_> just a few commands etc
04:06:11 <identity_> no flags
04:06:26 <identity_> I can just use head, I guess
04:07:18 <Saizan> identity_: hoogle search --help
04:07:40 <blackdog> Saizan: main: bad option -N3: only -N1 is supported with profiling
04:07:48 <blackdog> maybe threadscope?
04:07:54 <identity_> Doesn't work. But I just used ... | head -n 10
04:07:57 <identity_> works like a charm
04:08:20 <Saizan> we must have a different version then
04:08:59 <blackdog> Saizan: i'm running 7.0.3 on mac
04:09:22 <blackdog> (or were you talking to identity_?)
04:10:39 <identity_> if it was @ me, I'm running 4.2.3
04:10:43 <identity_> of hoogle.
04:25:57 <kamaji> What does "in" do?
04:26:40 <Martty> 3 points for the team
04:26:41 <quicksilver> it's a keyword
04:26:52 <quicksilver> it's part of the 'let' syntax.
04:28:06 <kamaji> quicksilver: Ah thanks
04:28:46 <kamaji> I don't really get it though :D
04:29:16 <jeltsch> Hi, is there a version 0.12 of soegtk?
04:31:22 <jeltsch> I tried installing Gtk2Hs 0.11, but it doesn’t work with the current Cabal.
04:31:33 <jeltsch> I get the following error message: http://hpaste.org/47508
04:32:05 <kamaji> quicksilver: oh, so it's like the reverse of func/where ?
04:32:23 <quicksilver> yes. Where is just another syntax for let.
04:32:36 <quicksilver> the structure is subtly different though in occasionally useful ways
04:32:47 <quicksilver> (where can only attach to definitions, scopes over guards)
04:33:01 <jeltsch> quicksilver: No, let creates expressions. So the local variables cannot be used in guards.
04:33:28 <quicksilver> I believe I just said that.
04:33:57 <jeltsch> Sorry, we had a synchronization problem.
04:33:58 <quicksilver> where is, in fact, syntactic sugar for let - but the desugar is not entirely immediate, and requires grouping guards and rewriting to case.
04:34:01 <quicksilver> :)
04:34:13 <kamaji> well i'm lost.... but I got what I came here for :P
04:34:17 <kamaji> so thanks :D
04:42:56 <aavogt> hi, when I try to build hinotify, I end up with the same error as http://people.debian.org/~lucas/logs/2011/03/13/haskell-hinotify_0.3.1-1_lsid64.buildlog
04:43:35 <aavogt> since the hackage build worked, this means my inotify.h is somehow different?
04:43:41 <identity_> > sortBy (comparing snd) $ [("foo", 1), ("bar", 3)]
04:43:42 <lambdabot>   [("foo",1),("bar",3)]
04:43:46 <identity_> Man, shit doesn't get more idiomatic than that.
04:44:48 <aavogt> > map length [ "comparing snd", "compare`on`snd" ]
04:44:49 <lambdabot>   [13,14]
04:45:22 <identity_> I think comparing is sexier
04:45:34 <identity_> (and it is shorter, as you showed)
04:47:39 <blackdog> ok, so that's sorta weird. 62% of the cpu time in my program is in 'floor'.
04:48:17 <blackdog> i'm calling floor after calling logBase (fromIntegral p) (fromIntegral n)
04:48:22 <aavogt> perhaps floor gets the time because it forces some other computation which isn't 'profiling' code
04:48:37 <blackdog> is there some equivalent integer log base function?
04:49:33 <blackdog> aavogt: https://gist.github.com/1010144
04:50:31 <blackdog> aavogt: both diff_i and logged show almost negligible usage
04:51:16 <aavogt> force the the p (and no?) when you call diff_i then?
04:51:55 <kamaji> Is it possible to declare a list on multiple lines?
04:51:57 <aavogt> as in   diff_i x = x `seq` floor2 (logged x)
04:53:13 <aavogt> (or maybe before calling logged, I don't think it makes a difference)
04:53:19 <blackdog> went down from 60 to 55
04:53:30 <blackdog> (sorry, 62 to 56)
04:53:55 <aavogt> what kind of Num is this?
04:54:03 <identity_> kamaji: yep'
04:54:04 <Tomsik> blackdog: if there isn't you can easily write that
04:54:16 <Cale> kamaji: You can continue any line of code into multiple lines, just start the next line farther in.
04:54:58 <blackdog> Tomsik: yeah, think that might be my way forward
04:55:10 <blackdog> aavogt: posted the full program at the same address
04:55:15 <blackdog> it should be an Int
04:55:45 <kamaji> Cale: so if I have a list of lists, each sublist has to be indented one further?
04:56:58 <qubodup> hi
04:57:06 <Cale> kamaji: myList = [[first list],
04:57:14 <Cale> kamaji: myList =  [second list],
04:57:18 <Cale> er, sorry
04:57:27 <Cale> IRC line editing fail :)
04:57:36 <kamaji> ohh, I was opening with [ and continuing later
04:57:38 <Cale> erase the myList = from the second line
04:57:52 <Cale> but you get the idea
04:59:01 <qubodup> I'm using Qt USleep (should be using win32::Sleep) for timing a physics engine and on *SOME* windows operating systems this leads to extreme slowdown.
04:59:27 <qubodup> or rather some systems running Windows XP but apparetnly also on 7
05:00:09 <kamaji> Cale: I'm probably being really stupid here, but I can't get it to work
05:00:12 <kamaji> I tried these: http://pastebin.com/kxY4Guxi
05:00:15 <mauke> The paste kxY4Guxi has been copied to http://hpaste.org/47509/httppastebincomkxy4guxi
05:00:51 <blackdog> aavogt: ha, it _was_ floor. rewriting to use an int log goes heaps faster.
05:01:30 <kamaji> oh, you can't do "let" expressions in a .hs file?
05:01:53 <mauke> that's not an expression
05:01:54 <identity_> Within the scope of a function, yes
05:02:02 <identity_> floating at the top scope, no
05:02:06 <identity_> Don't need to
05:02:11 <mauke> just remove let
05:02:14 <identity_> ^
05:02:48 <kamaji> fair enough!
05:02:52 <kamaji> thanks
05:03:05 <Cale> Yeah, at the top level, it's sort of like everything is in one big 'let' already, so you don't need the let.
05:03:16 <Cale> (and it's not permitted)
05:03:36 <Jafet> Actually it's one big where
05:03:41 <Cale> heh, indeed
05:04:02 <Cale> For the purposes of typechecking/inference as well, it behaves like a big let.
05:04:09 <Jafet> module .. where ..
05:04:09 <Cale> (types are generalised)
05:04:45 <kamaji> That makes so much sense, heh
05:10:24 <Jafet> Huh, I merely mistyped +RTS -h instead of +RTS --help
05:10:55 <Jafet> "prog: internal error: heapCensus, unknown object: 7\n    (GHC version 7.0.3 for x86_64_unknown_linux)\n    Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug\n"
05:12:49 <adimit> Interesting. It seems SmallString does have a defined Hashable instancee, but, when trying to shove SmallStrings into a HashMap, ghc complains about a missing instance declaration (which definitely is in SmallString.)
05:13:35 <adimit> It just isn't in Data.Hashable, but it's in Data.SmallString, which is probably why there's a problem here. Why is that?
05:14:22 <Jafet> The instance is in scope, I suppose?
05:14:40 <adimit> Jafet: I did import SmallString qualified. So that might be the case?
05:14:50 <adimit> (i.e. that might be the culprit)
05:15:34 <adimit> Can I import the instance declaration unqualified explicitly?
05:15:43 <Jafet> Nope, instances are always imported
05:15:54 <Jafet> In fact it's usually the reverse that causes problems
05:16:29 <adimit> I just tried it w/o the qualified import. Doesn't work either.
05:17:28 <aavogt> how about just trying    hash (undefined :: SmallString)?
05:18:07 <Lemmih> preflex: @seen c_wraith
05:18:08 <preflex>  c_wraith was last seen on #haskell 11 hours, 18 minutes and 47 seconds ago, saying: @tell Lemmih I'm having some issues with SDL-mixer, and could use a hand with it - sometime.
05:18:35 <adimit> aavogt: no instance, again.
05:18:48 <aavogt> does your error includes package versions when naming the Hashable class?
05:19:02 <mauke> how do you know SmallString does have a defined Hashable instance?
05:19:12 <aavogt> like     hashable-x.y.z:Hashable foo
05:19:17 <adimit> aavogt: no
05:19:21 <adimit> mauke: it's in the docs.
05:20:01 <mauke> where?
05:20:29 <adimit> http://hpaste.org/47510 <- here's the exact error. The instance declaration is here: http://hackage.haskell.org/packages/archive/smallstring/0.3.0/doc/html/Data-SmallString.html
05:20:47 <adimit> I have the exact same version installed.
05:21:50 <mauke> do you have older versions too?
05:22:03 <quicksilver> maybe the instances is for the wrong version of Hashable
05:22:05 <adimit> mauke: no.
05:22:15 <mauke> confusing
05:22:27 <adimit> I just installed both hashable and smallstring over cabal seconds ago.
05:22:36 * mauke tries
05:22:42 <adimit> Actually, smallstring pulled its own hashable…
05:22:58 <adimit> mauke: thanks :-)
05:23:09 <adimit> quicksilver: sounds like an idea…
05:23:22 <mauke> hashable (≥1.0.1 & <1.1)
05:23:38 <blackdog> any repa hackers? trying to work out how to take a slice of a flat array
05:23:47 <blackdog> just the first n elements
05:24:34 <aavogt> adimit: how did you load the  Data.Hashable into ghci?
05:24:46 <adimit> aavogt: > import Data.Hashable
05:25:00 <aavogt> try :m + Data.Hashable   instead
05:25:18 <aavogt> I've seen this issue but I'm not sure if it's reported
05:25:28 <adimit> mauke: my installed version is 1.0.1.1, which does fall into the constraints.
05:25:49 <mauke> how many hashables do you have?
05:26:20 <mauke> smallstring-0.3.0 depends on smallarray-0.2.1 which failed to install.
05:26:22 <mauke> bah
05:26:42 <aavogt> mauke: it works here
05:27:23 <adimit> mauke, aavogt: here's using ghci, without any imports other than Data.Hashable and Data.SmallString: http://hpaste.org/47512/smallstring_hashable
05:29:00 <quicksilver> that's not what we need to know.
05:29:09 <quicksilver> what we need to know is which versions of Hashable you have, adimit
05:29:14 <quicksilver> paste the output of ghc-pkg list
05:29:15 <adimit> indeed.
05:29:25 <mauke> grr
05:29:46 <adimit> quicksilver: I think I've seen why: http://hpaste.org/47514/aoeu
05:29:53 <mauke> how do you get ghci to tell you which packages it loaded?
05:30:10 <quicksilver> I am not aware of any way mauke
05:30:25 <quicksilver> that will be why, adimit
05:30:29 <adimit> so you're right, it seems there's different versions of hashable, and smallstring just uses not the one ghci uses.
05:30:34 <adimit> oh dear, but how do I fix it?
05:30:58 <quicksilver> your smallstring has an instance of hashable-1.0.1.1 but you are asking for an instance of hashable-1.1.2.0
05:31:17 <identity_> mauke: :show modules
05:31:23 <quicksilver> adimit: a good approach is to buy a new computer, install a fresh operating system, install haskell from scratch, and hope you don't make this mistake again.
05:31:28 <identity_> or :show packages
05:31:29 <identity_> it seems
05:31:37 <osfameron> quicksilver: heh
05:31:53 <mauke> identity_: it's lying
05:32:10 <adimit> well, it's not really my mistake. smallstring just pulled an old version of hashable, without me asking it to do that (it's in the version constraints.)
05:32:10 <mauke> and the output doesn't include versions
05:32:35 * adimit is annoyed at cabal's packaging policy right now…
05:32:37 <identity_> submit a bug report and tell them that it's dishonorable
05:32:44 <adimit> I shall.
05:32:45 <quicksilver> adimit: right. The ideal fix is a version of smallstring which supports the new hashable.
05:32:56 <quicksilver> which may be nothiing more than a dependency change and a re-upload
05:33:11 <quicksilver> (unless there actualy is an important new change)
05:33:35 <aavogt> don't your GHCis print out a whole bunch of package names and versions when you try to run some code?
05:33:55 <adimit> actually, they didn't.
05:34:21 <adimit> Since smallstring doesn't have a bug tracker, I guess I'll have to bug the author. :-(
05:35:14 <adimit> Is there a list of packages included with Haskell-Platform and their respective versions?
05:35:26 <quicksilver> the package versioning problem does indeed cause a lot of real problems.
05:35:42 <quicksilver> its absence would cause other problems, though, and we don't really know what that would be like because we haven't tried it.
05:42:43 * hackagebot clustertools 0.1.5 - Tools for manipulating sequence clusters  http://hackage.haskell.org/package/clustertools-0.1.5 (KetilMalde)
05:43:03 <adimit> I bugged the author. I hope ghc(i) has some way to restrict the version of packages on the command line.
05:45:58 <quicksilver> adimit: yes. It does.
05:46:00 <quicksilver> adimit: -package
05:46:16 <quicksilver> or you can hide the 'too-new' hashable entirely if you like.
05:46:19 <adimit> quicksilver: thank you. It seems ghc-pkg lost its 'mask' operation …
05:46:29 <quicksilver> ghc-pkg hide
05:47:25 <adimit> ah, good. thanks again :-)
05:51:51 <adimit> so, the theory goes: I ghc-pkg hide hashable-1.1.2.0, then when I load ghci, it should *not* ever load 1.1.2.0, no?
05:52:26 <adimit> because that's not what happens.
05:52:30 <blackdog> i'd like to compute a list at compile time and bake it into the executable. is there a sensible way of doing that?
05:52:35 <blackdog> my template haskell is not wonderful :/
05:55:55 <pamiz> adimit: you can use ghc-pkg unregister <package> to remove a package
05:56:53 <adimit> pamiz: in which case I'm breaking unordered-containers, which was my reason to use smallstring in the first place. I'm probably stuck not being able to use SmallString at all, for now.
06:02:24 <quicksilver> adimit: well if your goal is to use smallstring with unordered-containers and they dpeend on different versions of hashable then you are, clearly, in trouble :)
06:04:08 <adimit> quicksilver: yeah. I'll have to stick with Data.Text for indexing, which is suboptimal, but meh.
06:06:49 <applicative> when Haskell was named after Haskell Curry, was the Curry Howard business at the forefront of their minds?  The wikipedia article seems to think so.
06:07:23 <applicative> i would have thought it was 'currying' and polymorphism and, not sure what else
06:08:14 <poltak> Hehe, curry as in the food :P
06:08:17 <quicksilver> well the curry-howard isomorphism is relevant to the question of why H-M is a sensible structure for a type system.
06:08:39 <quicksilver> so it *is* relevent to haskell's language design.
06:08:50 <quicksilver> but, yes, currying is very relevant too
06:09:05 <quicksilver> and those two things are very much related to each other, too.
06:09:18 <applicative> quicksilver, I was thinking the analogy makes the type system surveyable in a way
06:10:38 <applicative> Somehow this doesnt seem ideal: The language is rooted in the observations of Haskell Curry and his intellectual descendants, that "a proof is a program; the formula it proves is a type for the program"
06:11:01 <quicksilver> applicative: yeah, I agree, that's not really ideal.
06:11:29 <quicksilver> haskell is not rooted in the observation of haskell curry - it's rooted in ML and lazy ML and miranda.
06:11:41 <Jafet> (tm)
06:11:56 <quicksilver> the practical desire to have a common functional lazy language as a basis for research
06:12:12 <quicksilver> it was named for haskell curry as a tribute to some important contributions he made to PL theory.
06:12:22 <applicative> the writer is clearly trying to explain the reason for the name.
06:12:32 <quicksilver> yeah, he's making it seem more important than it is.
06:12:52 <quicksilver> the name is not important; it's trivial - it was just a way of choosing a unique name and acknowledging a good researcher.
06:13:02 <quicksilver> it would still be the same language if it had been called 'Milner'
06:13:17 <quicksilver> or even Girard. Etc.
06:13:30 <Cale> Lambek might also have been a good name :)
06:13:41 <applicative> yes, but are you sure there aren't any specifically curryish things in Haskell not in ML?  laziness, the main thing, is irrelevant.
06:14:14 <Cale> Better to save Lambek's name for the future language which is even more categorical in nature though :)
06:14:46 <quicksilver> applicative: fairly sure. I do not have an encyclopedic knowledge of Curry's work though.
06:15:12 <quicksilver> but I'm pretty sure that curry's contributions to PL theory were just as much realised in ML and miranda.
06:15:14 <mm_freak> add dependent types and haskell is about the most sophisticated language for real world applications in existence
06:15:30 <Cale> Even without dependent types, it is
06:15:31 <mm_freak> well, IMO it is already even without them
06:15:37 <mm_freak> hehe
06:15:51 <mm_freak> i'm not even sure whether you can add them to haskell easily
06:15:52 <applicative> in ML isn't there a distinction between two place functions and functions from (a * b)
06:16:55 <Cale> mm_freak: Yeah, the direction which Simon has been taking, as far as I can see, is to try to get as close to dependent types as possible while maintaining a pretty decent level of type inference.
06:16:55 <applicative> mm_freak, now that agda has a javascript backend, it's going to take over!
06:17:19 <quicksilver> applicative: like the distinction between functions a -> b -> c and (a,b) -> c in haskell, you mean?
06:17:19 <Cale> and I think that's a pretty nice compromise
06:17:49 <quicksilver> it will be interesting to see how the datakind stuff works out in practice.
06:18:25 <applicative> quicksilver: they have that, but isn't there something in between those types so to say
06:19:43 <quicksilver> not that I know of.
06:19:48 * hackagebot binding-core 0.2 - Data Binding  http://hackage.haskell.org/package/binding-core-0.2 (GideonSireling)
06:20:03 <mm_freak> Cale: i could live with less inference, since i write a lot of type signatures
06:21:20 <Cale> mm_freak: The problem is that Haskell is currently a really good language at the tiny scale, and forcing more type signatures sort of ruins that.
06:21:28 <applicative> quicksilver: no this is not making sense, sorry.
06:21:38 <quicksilver> applicative: I quite often don't.
06:22:37 <Cale> On the other side of things, there are often type signatures which are rather large and which I would rather not write (for instance, because they are larger than the code in question)
06:23:08 <Cale> One thing I've really been wishing for lately is context synonyms. That'll be nice when it comes :)
06:24:55 <mm_freak> Cale: i think haskell is not used by people, who just want to write quick-n-dirty code
06:25:10 <mm_freak> haskell is for the correct, yet productive programmer, who is willing to specify his program
06:25:13 <Cale> Sometimes I want to write quick-n-dirty code in Haskell.
06:25:22 <kamaji> If an expression appears twice in a function, it will only be evaluated once, right?
06:25:26 <wjt> so. do people have scripts to fill in the ‘Source-Repository: this’ section of their .cabal file when they tag new releases?
06:25:30 <Cale> I use Haskell to write one-off scripts all the time.
06:25:30 <mm_freak> kamaji: depends
06:25:37 <kamaji> i'll whip up an example
06:25:39 <mm_freak> kamaji: if it has a name, it will be evaluated only once
06:25:45 <kamaji> mm_freak: as in, inside a where clause?
06:25:48 <mm_freak> let y = ... in f y y
06:25:50 <mm_freak> evaluated once
06:25:54 <mm_freak> f ... ...
06:25:59 <mm_freak> possibly evaluated twice
06:26:09 <kamaji> ok
06:26:14 <kamaji> cheers
06:26:30 <Cale> The nice thing about it is that quick and dirty Haskell code tends to still be in nice enough shape that as it evolves into something more serious, you can add in the type signatures and such.
06:26:52 <Cale> and you end up with the more carefully designed program automatically ;)
06:27:49 * hackagebot binding-gtk 0.2 - Data Binding in Gtk2Hs  http://hackage.haskell.org/package/binding-gtk-0.2 (GideonSireling)
06:27:51 * hackagebot binding-wx 0.2 - binding-core wrapper for WxHaskell  http://hackage.haskell.org/package/binding-wx-0.2 (GideonSireling)
06:28:01 <mm_freak> Cale: good point
06:28:27 <mm_freak> Cale: what i would like in haskell are partial signatures
06:28:51 <Jafet> @hoogle [(a, b)] -> ([a], [b])
06:28:52 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
06:28:52 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
06:29:10 <mm_freak> (Int -> ?r) -> [?r]
06:29:15 <applicative> quicksilver, in sml if I write const as infix or prefix, I get a different signature http://hpaste.org/47516/mysteries_of_sml
06:29:16 <mm_freak> where ?r is inferred
06:29:31 <Jafet> That's syntactic sugar, mostly
06:29:49 <mm_freak> and scoped type variables by default
06:31:53 <applicative> sml assumes that an infix operator acts on pairs.
06:31:56 <quicksilver> applicative: that's because infix operators desugar to operations on (,)
06:32:16 <quicksilver> in a strict language it matters less
06:32:21 <quicksilver> although it wouldn't matter very much in haskell either.
06:32:27 <quicksilver> I think it's the wrong decision even in ML
06:32:35 <quicksilver> but I think they do it because it feels "more symmetrical"
06:32:40 <quicksilver> not sure.
06:34:23 <applicative> in ML and haskell an infix operator has something on the right and something on the left, so the pair is salient. if there were 'mixfix' it would be different, one would immediately go to the curried version... ?
06:35:01 <applicative> i mean, since the defined term might have ten holes in it, so to say
06:35:18 <applicative> (I wonder how many _ holes agda allows)
06:41:14 <applicative> we_hold_these_truths_to_be_self_evident_that_all_men_are_created_equal : {A : Set} -> (a b c d e f g h i j k l m : A) -> A
06:41:30 <applicative> we a hold b these c truths d to e be f self g evident h that i all j men k are l created m equal = a
06:41:31 <varnie> Hi. is it true that I can use "foo <- bar" only in case of IO-function?
06:41:40 <Zao> varnie: You can do it in any do block.
06:41:40 <applicative> doesn't bother agda at all
06:41:53 <applicative> varnie, not at all
06:42:04 <Zao> varnie: Also, <- is also used in list comprehensions.
06:42:14 <Axman6> and monadic do blocks
06:42:35 <applicative> > do {x <- Just 2; return (x * x)}
06:42:36 <lambdabot>   Just 4
06:42:53 <applicative> > do {x <- [1..10]; return (x * x)}
06:42:54 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
06:43:26 <varnie> how to fix this: " The last statement in a 'do' construct must be an expression: x <- bar" ?
06:43:48 <applicative> write a new line, return x for example
06:44:02 <Axman6> or remove the the "x <- "
06:44:06 <identity_> varnie: Look up how the do construct is just syntactic sugar for >>= and >>
06:44:11 <identity_> Then everything will make sense
06:44:41 <applicative> at the moment it's like bar >>= \x -> ...   with nothing filling the blank
06:44:48 <identity_> I was just ytping that
06:44:56 <identity_> God damn it
06:45:01 <identity_> I never get to show off my wits in here.
06:45:22 <solrize> http://emilis.github.com/2011/04/12/usefullnes-of-inventing-languages.html   this is funny
06:45:23 <applicative> @quote fugue
06:45:23 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
06:45:46 <companion_cube> nice ref to Hofstadter, i guess
06:46:03 <identity_> applicative: so true
06:46:21 <identity_> The simple questions are the worst
06:46:24 <applicative> it's pleasing when there are 40 simulaneous answers
06:46:38 <identity_> They always end up stirring up the wizards
06:46:57 <identity_> And in 10 minutes, everyone is trying to golf something to pieces
06:46:58 <varnie> I posted my simple code having errors there: http://hpaste.org/47517/newbie_needs_help
06:47:00 <identity_> well, anti-golf
06:47:29 <identity_> varnie: Int isn't a monad
06:47:32 <applicative> okay identity_  you figure it out!
06:47:44 <applicative> instance Monad Char
06:47:49 <identity_> lol
06:47:50 <varnie> I just don't understand why it doesn't work
06:48:01 <identity_> varnie: That's because you don't understand monads
06:48:06 <varnie> that's true;)
06:48:27 <identity_> For that to work, the following would have to be legal: 123 >>= return
06:48:32 <varnie> speaking shortly, I cannot use "x <- bar" in case I don't work with monads, correct?
06:48:36 <Axman6> <- doesn't say that the thing on the left is equal to the thing on the right
06:48:42 <zygoloid> hlint is one step away from explaining how to fix the code :)
06:48:53 <identity_> varnie: Yes, basically
06:49:03 <zygoloid> 'Error: redundant do. Why not myFoo = bar'
06:49:10 <identity_> You can look at <- as something that unwraps whatever is contained in a monad and gives you the value
06:49:36 <identity_> But there are a billion awesome explanations of monads
06:49:38 <varnie> so, for simple "assignments" I cannot use '<-' (as I tried there: x <- bar)?
06:49:38 <Axman6> identity_: you'll get yelled at for saying that, i always do
06:49:43 <hpc> varnie: you know what Functor is?
06:49:48 <Axman6> varnie: have a look at this: http://random.axman6.com/blog/?page_id=70
06:49:49 <identity_> In fact, there is one that explains how monads are burritos
06:49:51 <identity_> Axman6: I know
06:49:51 <varnie> I have an idea, yes
06:49:52 <identity_> :(
06:50:10 <identity_> Then there's another one that explains how monads aren't burritos
06:50:17 <varnie> thanks for the help and the link
06:50:26 <Axman6> identity_: even if it is a very good way of getting people into a position where they can actually use the features they want to, enabling them to learn what is actually going on later...
06:50:31 <Axman6> :'(
06:50:37 <identity_> And then there's a bunch that explains how monads are just monoids in the category of endofunctors
06:50:42 <identity_> Axman6: Precisely
06:50:45 <applicative> varnie, this is valid
06:50:46 <applicative> http://hpaste.org/paste/47517/newbie_needs_help_annotation#p47518
06:51:03 <djahandarie> identity_, no one actually explains it like that, it's a joke.
06:51:04 <identity_> Axman6: Sometimes  the best way to continue is just know how to use something without understanding it fully
06:51:08 <Axman6> i hate people who have to be correct when teaching difficult ideas to people who don't understand them
06:51:17 <identity_> djahandarie: I wasn't being serious :P
06:51:21 <Axman6> identity_: agreed. many here seem to oppose that idea though
06:51:22 <djahandarie> Ah.
06:51:43 <varnie> okay, and why this innocent line doesn't work? "x = bar"
06:52:07 <djahandarie> Axman6, I think it's totally possible to do that, it's just that most people who try to do it suck.
06:52:08 <varnie> I get: "parse error on input `='"
06:52:09 <Axman6> varnie: you need to use let in a do block to do that
06:52:16 <applicative> you can do 'let x = bar' in a do block
06:52:25 <varnie> oops, surely. sorry, my bad
06:52:29 <identity_> Axman6: The fact that I wouldn't let myself move on until I understand monads like all these category theory wizards do impeded my learning process.. But I eventually gave up and allowed myself to learn to use the monad transformers and all that without understanding them fully, and eventually I actually understood them.
06:52:37 <identity_> until I understood*
06:52:50 <Axman6> identity_: that was my experience as well
06:53:37 <identity_> Though neil( I think it was neil) had a great deal to do with the breakthrough hehe
06:53:58 <varnie> The last statement in a 'do' construct must be an expression
06:54:11 <varnie> but I already have "let x = bar in x"
06:54:22 <varnie> how to say it returns "x"?
06:54:46 <applicative> the last bit of a lambda abstraction must be an expression.  foo = \x ->  is not valid
06:54:46 <varnie> I stuck with this newbie problem again and again
06:54:47 <hpc> varnie: if x :: Int or whatever, you want return x :: m Int
06:54:57 <hpc> for some monad m
06:55:11 <varnie> I don't have any monads in my simple function
06:55:32 <identity_> varnie: What exactly are you trying to do?
06:55:42 <varnie> I just want to assign 'x' to bar function result and to return it (i.e. return x)
06:55:45 <identity_> It seems like you're thinking a bit too much on the imperative side
06:56:13 <varnie> myFoo = do let x = bar in HOW_TO_RETURN_X_HERE where bar = 123
06:56:29 <identity_> myFoo = let x = bar in x where bar = 123
06:56:33 <identity_> however
06:56:39 <kosmikus> if you don't use monads, then you shouldn't use "do" or "return"
06:56:41 <identity_> myFoo = bar where bar = 123 works as well
06:56:43 <applicative> > let bar y = y * y ; x = bar 2 in x
06:56:44 <varnie> hmm.. I tried that, but it didn't work
06:56:44 <lambdabot>   4
06:56:46 <identity_> or just .. myFoo = 123
06:56:53 <identity_> varnie:
06:56:56 <SpiceMan> newbie question. where the hell are the modules? :p
06:57:07 <hpc> SpiceMan: a module is a file, basically
06:57:09 <applicative> you write them.
06:57:13 <identity_> SpiceMan: In another dimension
06:57:14 <varnie> here's the code snippet: "http://hpaste.org/paste/47517/newbie_needs_help_annotation#p47519"
06:57:18 <SpiceMan> like System.Enviroment
06:57:27 <applicative> in base
06:57:37 <applicative> do you want to find the source on your system, or the documentation?
06:57:51 <applicative> SpiceMan, do you have ghc installed?
06:57:54 <identity_> varnie: Well, first of all, your list syntax is off(you put the 3 outside the list)
06:58:08 <hpc> SpiceMan: a module is just a haskell file; you know how when you type a command into a shell, it searches $PATH (/bin, /usr/bin, etc)
06:58:08 <SpiceMan> applicative: only that, it seems. debuntu with apt-get install ghc6
06:58:14 <SpiceMan> perhaps a pretty bare thing
06:58:26 <hpc> SpiceMan: ghc does the same thing, and in this case it finds System/Environment.hs somewhere in that path
06:58:26 <varnie> identity_, yes I agree.
06:58:39 <kosmikus> varnie: your program looks like it should just be "myFoo = 123"
06:58:48 <identity_> what he said
06:58:53 <varnie> i know, it is "synthetic" example
06:58:59 <applicative> i think there is a second apt-get for the documentation but here's system enviroment http://haskell.org/ghc/docs/latest/html/libraries/base/System-Environment.html
06:59:29 <kosmikus> varnie: well, you can make it more complicated, but it's hardly worth it
06:59:29 <applicative> Spiceman or more generally  http://haskell.org/ghc/docs/latest/html/libraries/
06:59:39 <kosmikus> varnie: you can write "myFoo = let x = 123 in x"
06:59:41 <identity_> SpiceMan: Why not install the haskell platform?
06:59:42 <varnie> no, I am just asking how to fix it?
06:59:47 <identity_> Gives you docs + cabal + ghc
06:59:54 <varnie> and why my code doesn't work
07:00:05 <kosmikus> varnie: I'm telling you how to fix it. Write "myFoo = 123".
07:00:09 <identity_> varnie: Well, the fact is that your code is .. strange. it doesn't make sense. What do you want to do?
07:00:13 <SpiceMan> identity_: sounds like a good idea.
07:00:14 <identity_> What do you want your function to do?
07:00:27 <identity_> SpiceMan: Just remove the old ghc before you do
07:00:29 <kosmikus> varnie: yes, your code is strange indeed.
07:00:44 <varnie> I want to have some variable, holding some calculated result with the help of some helper function, and to return in in the end
07:01:04 <kosmikus> varnie: then you'd be at the "myFoo = let x = 123 in x"
07:01:07 <varnie> let's think that bar is some function with many math calculations
07:01:14 <kosmikus> although calling x a "variable" is somewhat misleading
07:01:18 <applicative> is there something else Spiceman should know to remove? maybe not if it was just ghc.
07:01:37 <varnie> so, in this case we cannot perform just simple "let x = 123"
07:01:41 <mm_freak> what's your problem with monads?  they are just monoids in the category of endofunctors
07:01:44 <mm_freak> =P
07:01:50 <mm_freak> (actually i don
07:01:51 <varnie> i.e. we need to invoke some function doing the real job
07:01:53 <identity_> mm_freak: yeah, we already went there bro
07:01:53 <SpiceMan> that's the only thing I've installed. should be fine
07:01:59 <mm_freak> 't understand that definition)
07:02:15 <kosmikus> varnie: it's still not quite clear to me what you want
07:02:16 <identity_> varnie: Well, your myFoo doesn't take an argument, and neither does bar
07:02:26 <identity_> "take an argument" yeah yeah, I know it's all currying
07:02:26 <mm_freak> identity_: i know, i was just joking
07:02:28 <varnie> myFoo should return Int
07:02:28 <applicative> SpiceMan http://packages.debian.org/search?keywords=haskell-platform
07:02:39 <kosmikus> varnie: assuming you have a function called "bar", you can call it on an argument like this "myFoo = bar 123"
07:02:40 <varnie> did I write it wrong?
07:03:04 <kosmikus> varnie: there are several things that are strange in your example
07:03:08 <applicative> SpiceMan, see the linux material on the still-early-spring Platform site http://hackage.haskell.org/platform/
07:03:10 <kosmikus> varnie: first of all, the "do" should go
07:03:17 <identity_> varnie: Giving us a concrete, real-world example of what you are trying to accomplish would perhaps be better. It's hard to explain how to solve pseudo-goals sometimes
07:03:18 <varnie> why?
07:03:23 <kosmikus> varnie: second, why use both "let" and "where"
07:03:39 <kosmikus> varnie: third, the layout is messed up
07:04:11 <identity_> varnie: In haskell, you cannot just 'call functions' one after each other
07:04:17 <mm_freak> btw, were applicative functors in haskell really inspired by SK calculus or did that just turn out to be a fortunate incident?
07:04:20 <identity_> there is no "function = do this; do that;"
07:04:23 <varnie> one moment, pls
07:04:34 <identity_> Even when you're using monads, it just seems that way due to syntactic sugar
07:05:00 <varnie> here it is
07:05:00 <varnie> http://hpaste.org/paste/47517/newbie_needs_help_annotation#p47521
07:05:18 <applicative> SpiceMan, if you install the Platform, come back here and people can explain how to install other libs with cabal and so forth.
07:05:25 <varnie> please keep in mind I don't want to return the result of that computation on the fly, I want to return it using some "x" (variable?)
07:05:30 <SpiceMan> excellent. it installed lots of crap like mesa and x11proto whatever and this VM doesn't even have X
07:05:36 <SpiceMan> debuntu--
07:05:37 <varnie> just for educational purposes
07:06:10 <Axman6> varnie: there's no need to use do there at all, this is not a monadic computation, so do is not needed, and shouldn’t be used because it's confusing
07:06:11 <identity_> varnie: why are you using let, then?
07:06:18 <identity_> why would you 'store it as x'?
07:06:22 <SpiceMan> applicative: no sweat, I'll RTFM. but wanted to fiddle quickly before falling asleep today :)
07:06:27 <varnie> I am just learning how to use let
07:06:31 <identity_> just make it myFoo = someFunctionDoingHardWork
07:06:39 <identity_> Alright, in that case
07:06:48 <applicative> SpiceMan: damn, sorry, the platform libraries include some gui things, so inevitably in come the c library dependencies. I hadn't thought of that as an objection til now
07:06:49 <varnie> and I don't understand why "let x = foo x" doesn'r work
07:06:50 <identity_> myFoo = let x = someFunctionDoingHardWork in x
07:06:58 <SpiceMan> applicative: no problem
07:07:15 <varnie> identity_, I have exactly the same but mine code doesn't work
07:07:40 <hpc> mm_freak: would you like an explanation of "monoid in the category of endofunctor"?
07:07:51 <varnie> so, "myFoo = do let x = bar in x" is wrong?
07:07:52 <identity_> varnie: you forgot to remove the do, probably
07:07:55 <osfameron> hpc: I would!
07:07:57 <identity_> Yes, remove the "do"
07:08:02 <osfameron> (though I suspect I wouldn't understand it)
07:08:07 <applicative> SpiceMan it will have deposited the docs somewhere that probably passed by too quickly, you can locate them with eg "locate Environment.html" in the morning.....
07:08:09 <identity_> For now, just think "I only need do when I'm using monads"
07:08:16 <hpc> so imagine the data type for endofunctors
07:08:18 <identity_> If you don't know if you're using monads, you probably aren't
07:08:30 <hpc> data Endo a = Endo {appEndo :: a -> a}
07:08:31 <Axman6> varnie: do is only for monadic code, and this isn't monadic, it's just normal simple functions
07:08:33 <joe6> is there some higher order function that will try the current function n number of times after a sleep of x seconds?
07:08:36 <osfameron> hpc: this is a lazy explanation right?  so I should say "What are endofunctors?" ?)
07:08:44 <varnie> identity_, yes, now it works smoothly. thanks
07:08:57 <varnie> Axman6, now I see. thank you.
07:09:16 <hpc> so categories, then
07:09:17 <osfameron> hpc: ah, functors that return the same type of data as they input?
07:09:29 <Favonia> joe6: sounds like threadDelay?
07:09:30 <identity_> joe6: forever $ yourIOFunction >> makeThreadSleep
07:09:31 <kosmikus> varnie: but let's remain clear that "let x = something in x" is just a complicated way of writing "something"
07:09:31 <identity_> ?
07:09:39 <hpc> osfameron: yeah, more or less
07:09:45 <identity_> eh, forever.. Probably don't want that
07:09:48 <joe6> Favonia: identity_ : cool, thanks
07:10:07 <identity_> @hoogle repeatM
07:10:07 <lambdabot> No results found
07:10:13 <identity_> Why doesn't this exist, again?
07:10:46 <varnie> I cannot write "x <- foo" in the "do" block in case my code is not monadic?
07:10:57 <hpc> a category (in haskell, not category theory) is something in 'class Category a where id :: b `a` c; (.) :: (b `a` c) -> (z `a` b) -> (z `a` c)'
07:10:57 <identity_> varnie: You cannot use a do block if your code is not monadic
07:11:09 <hpc> ie, it has an identity and a notion of composition
07:11:34 <varnie> "parse error on input `<-'"
07:11:36 <hpc> an endofunctor is a function in the category that goes from a type 'a' to the type 'a' again
07:11:44 <osfameron> hpc: I'm not understanding the `a` notation - the parametrized type is an infix function?
07:11:45 <hpc> hence the above definition of Endo
07:11:52 <hpc> osfameron: yeah, just for illustration
07:11:52 <mm_freak> hpc: honestly i don't really care…  unless i have a specific need to go that deep into CT, i'll refrain from doing that =)
07:12:09 <mm_freak> hpc: after all i understand the haskell concepts quite well without knowing a whole lot about CT
07:12:13 <varnie> myFoo = y <- 123; y"
07:12:28 <identity_> varnie: y is not a monad
07:12:48 <varnie> okay, I have to learn it well...
07:12:50 <osfameron> hpc: what are b and c in the category?
07:12:56 <varnie> thanks for the patience btw
07:12:59 <hpc> osfameron: anything
07:13:01 <identity_> varnie: I think your problem is that you're trying to write imperative code in a functional language
07:13:05 <joe6> is there an  alternative for repeatM?
07:13:13 <hpc> osfameron: like the 'a' in the Functor definition
07:13:22 <kosmikus> varnie: forget about do-blocks until you actually need them ;)
07:13:23 <identity_> joe6: oh
07:13:25 <identity_> replicateM
07:13:44 <hpc> anyway, it turns out that you can make a monoid out of a category
07:13:46 <identity_> Seems like exactly what you need.
07:13:55 <hpc> where mempty = id, mappend = (.)
07:13:58 <identity_> replicateM numTimes $ doStuff >> sleep
07:14:01 <varnie> and what about "code layout" rules? where can I get info regarding this?
07:14:06 <osfameron> hpc:  I think I'd need to mull over the idea of a category first
07:14:16 <osfameron> hpc:  what are they good for?  what kind of thing goes in them?  etc.?
07:14:24 <hpc> and in the case of the kleisli category, id :: a -> m b = mempty = return
07:14:25 <kosmikus> varnie: what are you using to learn Haskell?
07:14:29 <hpc> and (.) = (>>=)
07:14:42 <varnie> I am reading Real World Haskell online book
07:14:56 <varnie> and trying to solve 99 problems of Haskell
07:15:00 <mm_freak> hpc: (.) = (>=>)
07:15:05 <varnie> solved 10 of them, though :)
07:15:05 <joe6> > :t replicateM
07:15:06 <lambdabot>   <no location info>: parse error on input `:'
07:15:13 <joe6> @hoogle replicateM
07:15:14 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
07:15:14 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
07:15:15 <hpc> mm_freak: ah, indeed
07:15:24 <hpc> :t (>=> return)
07:15:24 <mm_freak> hpc: in fact (<=<)
07:15:25 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> a -> m b
07:15:37 <hpc> :t (>=> join)
07:15:38 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m (m (m c))) -> a -> m c
07:15:43 <identity_> :t join
07:15:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:15:47 <identity_> oh, yeah.
07:15:56 <identity_> > join [["foo"]]
07:15:57 <lambdabot>   ["foo"]
07:17:42 <hpc> :t (=<<)
07:17:42 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
07:18:03 <Favonia> varnie: a possible way to understand do/monad/<- is to treat that as a sequence of computations. in your non-monadic code the "=" is more like mathematical equality. x = 1+1 "means" x=2 forever. it is different from "assigning 2 to x" where x is more like a memory cell
07:19:32 <kamaji> Is there something to take the intersection of two sorted lists?
07:20:52 <Axman6> > [1,2,3] // [2,3]
07:20:54 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
07:20:54 <lambdabot>         against inferred t...
07:20:58 <Axman6> :t (//)
07:21:00 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
07:21:07 <zygoloid> map head . filter ((>1) . length) . group $ sort (as ++ bs)
07:21:08 <Axman6> :t (\\)
07:21:08 <zygoloid> :)
07:21:09 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
07:21:10 <identity_> @hoogle (//)
07:21:10 <lambdabot> Data.Array.IArray (//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
07:21:18 <Favonia> @src intersect
07:21:19 <lambdabot> intersect = intersectBy (==)
07:21:26 <Favonia> @src intersectBy
07:21:27 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
07:21:49 <zygoloid> kamaji: there's nothing in the standard library for that which is O(n), that i know of
07:21:50 <Favonia> kamaji: seems that there is a slow implementation here
07:22:05 <Favonia> kamaji: (for sorted lists)
07:22:31 <kamaji> Favonia: sorry, where is "here"? heh
07:22:40 <kamaji> do you mean intersect?
07:22:49 <Favonia> kamaji: yes
07:22:54 <Favonia> @hoogle intersect
07:22:55 <lambdabot> Data.List intersect :: Eq a => [a] -> [a] -> [a]
07:22:55 <lambdabot> Data.List intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
07:22:55 <lambdabot> Data.IntMap intersection :: IntMap a -> IntMap b -> IntMap a
07:23:27 <kamaji> I'm guessing that would be too slow on sorted lists?
07:23:50 <zygoloid> intersectSorted (x:xs) (y:ys) = case compare x y of LT -> intersectSorted xs (y:ys); EQ -> x:intersectSorted xs ys; GT -> intersectSorted (x:xs) ys; intersectSorted _ _ = []
07:23:55 * hackagebot temporary 1.1.2 - Portable temporary file and directory support for Windows and Unix, based on code from Cabal  http://hackage.haskell.org/package/temporary-1.1.2 (MaxBolingbroke)
07:24:01 <Favonia> kamaji: I agree :) personally I might just write one by myself
07:24:10 <Favonia> kamaji: like zygoloid did
07:24:17 <kamaji> I'm not going to look at that because I need to learn how to do it :P
07:24:27 <kamaji> also i've never come across 'case', hehe
07:28:32 <Cale> You should also be aware that so long as these sorted lists you're working with are finite, there's a good library (Data.Set) for sets, with an efficient intersection operation among others.
07:30:09 <kamaji> Cale: it's primes unfortunately, so infinite lists everywhere
07:32:32 <hpc> kamaji: think about what happens at the front of the two lists
07:32:57 <hpc> kamaji: obviously if the two head elements are equal, you will have that at the head of the output list
07:33:29 <hpc> kamaji: if the head of list A is larger than the head of list B, what do you know about list B?
07:33:51 <harlekin> How would I read the creation time of a file?
07:33:59 <kamaji> hpc: I get the algorithm, just finding it tricky to write in haskell
07:34:09 <harlekin> There is getModificationTime in System.Directory, but I cannot find anything that gives me the creation time.
07:34:16 <mercury^> Cale: are you an op in #math?
07:35:04 <mercury^> Thanks.
07:36:57 <hpc> harlekin: linux filesystems don't store the creation date of files
07:37:42 <hpc> not sure if there exist any windows/mac-specific modules to do what you want
07:37:53 <harlekin> hpc: they don't? oh. this is embarassing. O:
07:38:41 <hpc> harlekin: no problem; it took me a minute too
07:40:05 <hpc> kamaji: ah, nvm then :P
07:40:47 <hpc> kamaji: the trick will be in how you do the recursion
07:41:23 <hpc> in this case, the kind of recursion you want is 'foo (args) = (first element):(function call that will compute the rest of the list)'
07:42:01 <hpc> i can't really explain any better without giving away the implementation :P
07:43:07 <Favonia> kamaji: you might also want to check "guards" for determining whether the first list has a "larger" head, if you are not comfortble with "cases" (yet) :P
07:45:12 <rdrey> hi everyone! another quick newb question, sorry: why is y = [floor(sqrt(fromIntegral 16))..2] empty?
07:45:22 <kamaji> hpc: thanks ^^
07:45:39 <Axman6> > [4..2]
07:45:40 <lambdabot>   []
07:45:44 <Axman6> > [4,3..2]
07:45:46 <lambdabot>   [4,3,2]
07:45:59 <rdrey> oh, thanks ;)
07:46:00 <kamaji> Favonia: cheers, i'll have a lookylook
07:46:58 * hackagebot binding-core 0.2.1 - Data Binding  http://hackage.haskell.org/package/binding-core-0.2.1 (GideonSireling)
07:56:19 <kamaji> ooh, what does foo (x:xs) evaluate to when the parameter is []?
07:56:37 <kamaji> oh I just catch it when xs == []
07:57:11 <Favonia> @check (\(i :: Positive Int) -> (floor . sqrt . fromIntegral) (i^2) == i )
07:57:12 <lambdabot>   Parse error in pattern at "->" (column 23)
07:57:15 <hpc> kamaji: foo (x:xs) will match non-empty parameter lists
07:57:35 <hpc> > let foo [] = "empty list"; foo (x:xs) = "non-empty list" in foo []
07:57:35 <lambdabot>   "empty list"
07:57:42 <hpc> > let foo [] = "empty list"; foo (x:xs) = "non-empty list" in foo [1,2,3]
07:57:42 <lambdabot>   "non-empty list"
07:58:24 <kamaji> Oh, I forgot I could do multiple definitions of the function
07:58:32 <kamaji> but I cheated a bit :D
08:00:08 <kamaji> hpc: thanks btw!
08:00:18 <kamaji> woohooooooo
08:02:58 <Tasser> can I overload a function by return value?
08:03:46 <Axman6> :t let f x = f x in f
08:03:47 <lambdabot> forall t t1. t -> t1
08:03:54 <Axman6> completely overloaded!
08:04:32 <Tasser> huh?
08:05:22 <kamaji> thanks all for halp!
08:08:29 <djahandarie> Tasser, you mean you just want to return one type in one case, and another type in another case?
08:08:43 <Favonia> Tasser: yes you can. by "abusing" typeclasses. I think regex modules are nice examples.
08:09:04 <djahandarie> Ugh, that thing? Please don't do that thing
08:09:35 <Tasser> djahandarie, choosing a function by which type(class) you want returned
08:09:39 <identity_> Hmm.. so I need a function that takes a seed, calls my function on it which is in the IO monad, and then continually calls my function on the result
08:09:48 <identity_> doesn't this exist already?
08:09:57 <identity_> not sure I can whip up the type so I can't hoogle it
08:10:18 <Favonia> rdrey: you might be interested in this
08:10:23 <Favonia> > let i = 15633814156853823 in (floor . sqrt . fromIntegral) (i^2) == i
08:10:25 <lambdabot>   False
08:10:33 <Tasser> Favonia, hm, oke
08:10:46 <identity_> oh, iterate
08:11:23 <djahandarie> Tasser, you can do it with typeclasses. And you don't return a typeclass, you return a type.
08:12:22 <djahandarie> (Well, you return a value with a concrete type, normally, when doing this sort of adhoc polymorphism.)
08:12:54 <Favonia> djahandarie: hmm.. is there anything particularly bad about regex modules?
08:13:02 <Zao> @type flip fix 9001 $ \f x -> g x >>= f
08:13:03 <lambdabot> forall a (m :: * -> *) b. (Num a, SimpleReflect.FromExpr (m a), Monad m) => m b
08:13:14 <djahandarie> Favonia, I just think they're particularly ugly.
08:13:23 <Zao> identity_: Something along that idiom is used in Geordi to loop until happy.
08:13:41 <identity_> @hoogle (a -> m b) -> a -> m [b]
08:13:42 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
08:13:42 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
08:13:42 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
08:13:48 <identity_> eh
08:14:12 <identity_> Zao: Not sure I know that idiom
08:14:39 <identity_> but I basically need iterateM or just sequence $ iterate if iterate was (a -> b) -> a -> [b]
08:14:45 <ClaudiusMaximus> @type \f a -> iterate (f =<<) (return a)
08:14:46 <lambdabot> forall (m :: * -> *) b. (Monad m) => (b -> m b) -> b -> [m b]
08:15:05 <Zao> identity_: That particular snippet will invoke f with the seed (9001), which will invoke your function g and pass the result to itself, which will ...
08:15:36 <djahandarie> Tasser, basically you can concoct up a type class for specifically that function, and do the 'overloading' by writing instances.
08:15:37 <Zao> (nothing more than naming a lambda locally so it can be reused)
08:15:38 <Favonia> djahandarie: hmm... I 60% agree they are kind of ugly. I just couldn't think of a straightforward example for overloading with return types.
08:17:31 <kenjin2202> Hello, I have imported Control.Monad.State. But I see this error    Not in scope: data constructor `State', LYAH says it's there.
08:17:35 <Tasser> Favonia, read ;-)
08:17:46 <Tasser> (just came to mind)
08:18:37 <djahandarie> I think that is somewhat of a code smell though, to overload your return type with a typeclass.
08:19:52 <c_wraith> kenjin2202: that library changed since LYAH was written.  The State constructor no longer is present.
08:20:01 <kenjin2202> Oh...
08:20:35 <kenjin2202> What should I use then?
08:20:56 <c_wraith> there's a function, state, that does the same thing, now
08:21:15 <kenjin2202> Thank you, c_wraith
08:30:05 * hackagebot dtd-text 0.1.1.0 - Parse and render XML DTDs  http://hackage.haskell.org/package/dtd-text-0.1.1.0 (YitzGale)
08:30:21 <hpc> :t state
08:30:22 <lambdabot> forall s a. (s -> (a, s)) -> State s a
08:32:11 <ski> Tasser : `reads' is an example of operation overloaded on result value
08:32:39 <ski> > reads "32.01" :: [(Integer,String)]
08:32:40 <lambdabot>   []
08:32:47 <ski> > reads "32.01" :: [(Double,String)]
08:32:48 <lambdabot>   [(32.01,"")]
08:33:01 <quicksilver> so is return.
08:34:50 <ski> @type (`fix` 9001) $ \loop x -> ?g x >>= loop  -- Zao, i might write that like this
08:34:50 <lambdabot> forall (m :: * -> *) a b. (Num a, ?g::a -> m a, Monad m) => m b
08:35:45 <Yrogirg> Hi! I've just encountered a lambda expression of kind \f(x) -> smth, for example \ f(x) -> f(5.0)
08:35:45 <Yrogirg> This seems to be rather stunning for me. I have a feeling it is somehow used somewhere. Does anybody know any neat examples on the matter?
08:36:30 <ski> @type \f(x) -> (f,x)
08:36:31 <lambdabot> forall t t1. t -> t1 -> (t, t1)
08:36:51 <ski> Yrogirg : `\ f(x) -> ...' probably doesn't mean what you think it does
08:37:32 <ski> > (\f -> f(0.5)) (^ 2)  -- though maybe you had something like this in mind ?
08:37:33 <lambdabot>   0.25
08:38:04 <hpc> oh god, the f(x) syntax
08:38:30 <ski> `f(x)' is the *value* of a the function `f' in the argument `x'
08:38:39 <ski> `f' is the function *itself*
08:39:12 <ski> (and in Haskell, `f(x)' can be simpler written as `f x')
08:39:16 <Yrogirg> I'm not sure I have any thoughts what it does.
08:39:16 <Yrogirg> Prelude> let a = \f(x) -> f(pi)
08:39:16 <Yrogirg> Prelude> a cos(3)
08:39:16 <Yrogirg> -1.0
08:39:16 <Yrogirg> Prelude> a sin(3)
08:39:17 <Yrogirg> 1.2246467991473532e-16
08:39:53 <opqdonut> Yt
08:39:55 <opqdonut> gah
08:39:56 <magicman> That's the same as "let a = \f x -> f pi".
08:40:06 <ski> Yrogirg : `a cos(3)' is parsed as `(a cos) 3'
08:40:07 <Yrogirg> yeah
08:40:12 <opqdonut> yeah, I was about to say what magicman said
08:40:12 <quicksilver> Yrogirg: "a cos(3)" is "a cos 3" which calls 'a' with two arguments.
08:41:01 <magicman> So "a cos(3)" = "a cos 3" = "cos pi", and "a sin(3)" = "a sin 3" = "sin pi". Because the 'x' parameter of the lambda gets ignored.
08:41:06 <hpc> > sin pi
08:41:07 <lambdabot>   1.2246467991473532e-16
08:41:12 <hpc> > sin pi :: CReal
08:41:13 <lambdabot>   0.0
08:41:25 <varnie> gotta go. bye
08:43:32 <ski> Yrogirg : if you want to understand it in traditional math function application notation : `a cos(3)' means `a(cos)(c)' (i.e. `(a(cos))(3)'), not `a(cos(3))'
08:44:46 <Yrogirg> I now the haskell notation a x for a(x). What actually surprised me is the \f x -> ... syntax itself
08:45:14 <Yrogirg> it resembled me pattern matching
08:45:29 <ski> (this is a bit related to that in analysis, `D sin(x)' could be accepted, if it's interpreted as `D(sin)(x)', but `D x^2' is wrong (unless `x' and `x^2' here are functions))
08:45:52 <ski> Yrogirg : `\f x -> ...' is short for `\f -> \x -> ...'
08:45:57 <Yrogirg> indeed I'm thinking about differentiation right now
08:45:59 <quicksilver> Yrogirg: it is the syntax for a lambda with two parameters.
08:46:05 <quicksilver> \a b -> a+b
08:46:06 <ski> you *can* pattern-match here, but you must bracket then
08:46:23 <ski> > (\(a:as) -> (a,as)) [0,1,2,3]
08:46:24 <lambdabot>   (0,[1,2,3])
08:46:37 <ski> > (\(Just a) -> a) (Just 2)
08:46:38 <lambdabot>   2
08:46:40 <ski> > (\(Just a) -> a) Nothing
08:46:40 <lambdabot>   *Exception: <interactive>:3:1-14: Non-exhaustive patterns in lambda
08:46:50 <Yrogirg> no, I meant not that pattern matching based on type constructors
08:46:52 <Zao> ski: Neat.
08:47:06 <Favonia> Yrogirg: I would like to add that paratheses and lacking of spaces in cos(3) do not make them "closer" or special in Haskell. "cos(3)" = "cos (3)" = "cos 3". I've heard that something like this is been treated more carefully in Fortress (another PL).
08:47:14 <ski> Yrogirg : so `\(Just a) -> ..a..' is fine, but `\Just a -> ..a..' is bad
08:47:39 <ski> Yrogirg : you always match on *data* constructors, not *type* constructors
08:51:19 <ski> Yrogirg : .. all clear ?
08:51:52 <Yrogirg> yes, the part `\f x -> ...' is short for `\f -> \x -> ...' cleared it all, thank you
08:52:44 * ski nods gravely
09:03:46 <k0ral> in Gtk package, Abstract.Widget is said to provide "data Color" according to the documentation: http://hackage.haskell.org/packages/archive/gtk/0.12.0/doc/html/Graphics-UI-Gtk-Abstract-Widget.html
09:04:16 <k0ral> however, it's not in the source file (notice how the documentation doesn't offer a direct link to its implementation)
09:04:38 <k0ral> which package should I import to get it ?
09:08:15 <byorgey> k0ral: I just grepped through the source for it and it looks like it is being imported from Graphics.UI.Gtk.General.Structs
09:08:57 <tromp> package Data.Colour
09:09:40 <tromp> wait; different spelling
09:10:47 <byorgey> yeah, I don't think Gtk uses Data.Colour
09:10:51 <k0ral> the doc doesn't mention this Structs package
09:10:58 <k0ral> will try anyway
09:12:06 <byorgey> k0ral: I'm guessing it is not exported as part of the package, it is a purely internal module
09:12:26 <byorgey> which would also explain why the export of Color has no associated Source link
09:12:53 <byorgey> in which case there's no way to get access to it.
09:13:30 <fragamus> cabal install random-fu    <---- no workie
09:14:45 <k0ral> byorgey: hum hum, can't believe that
09:15:21 <byorgey> fragamus: are you looking for sympathy or help?  If the latter, I suggest you provide a bit more information =)
09:15:22 <k0ral> byorgey: you're telling me functions using Color as argument are provided but unusable ?
09:15:51 <byorgey> k0ral: that doesn't necessarily follow, unless there is no other way to get hold of a Color value
09:16:04 <byorgey> k0ral: I'm guessing there are other functions which return Color
09:16:16 <byorgey> although I am not familiar with Gtk
09:16:30 <fragamus> sympathy please
09:16:47 <k0ral> byorgey: import Graphics.Rendering.Pango.Structs
09:17:21 <byorgey> fragamus: ah, in that case, I'm very sorry for your loss
09:17:37 <fragamus> thank you that's much better now
09:18:12 <fragamus> src/Data/Random/Source/StdGen.hs:132:29:
09:18:13 <fragamus>     Couldn't match type `a0' with `b'
09:18:13 <fragamus>       because type variable `b' would escape its scope
09:19:21 <byorgey> k0ral: it looks like Color is exported (along with its constructor) from Graphics.UI.Gtk.Gdk.GC
09:19:37 <mdmkolbe> Algorithm W is known to be exponential in the size of the program in the worst case.  However, is it also exponential in the size of the resultant types?  If not exponential, then what?
09:20:30 <fragamus> could one of you guys try installing random-fu to see if it works on your machine
09:20:34 <k0ral> byorgey: that's better than importing from Pango, thank you :)
09:20:52 <byorgey> fragamus: I'll try.  What version of GHC do you have?
09:21:02 <byorgey> fragamus: and have you done a recent 'cabal update'?
09:21:06 <pozic> fragamus: trying to grow your botnet?
09:21:44 <fragamus> 7.0.3
09:22:01 <fragamus> yes i updated a few mins ago
09:22:22 <djahandarie> pozic, no, that is only if you download the definitely-not-a-botnet package
09:23:31 <byorgey> fragamus: yes, I get the same error
09:23:38 <fragamus> pozic: yes install my malware random-fu  i will rule your hardware  haaar   prepare to be boarded ye scurvy functional programming dogs
09:23:51 <djahandarie> Hahahaha
09:24:02 <djahandarie> @yarr
09:24:02 <lambdabot> Aye Aye Cap'n
09:24:27 <pozic> Hackage is a great attack vector.
09:25:19 <pozic> It gets code, usually without inspection, via http to be executed on development machines which likely also have access to the internals of some sensitive networks.
09:25:24 <mdmkolbe> pozic: heh, "cabal install binutils"
09:25:56 <pozic> Better developed systems have gpg keys to at least counter some attacks.
09:26:14 * hackagebot revdectime 0.1 - A French revolutionary decimal time (metric) clock  http://hackage.haskell.org/package/revdectime-0.1 (KamilStachowski)
09:26:20 <djahandarie> Would be interesting to add GPG support to cabal
09:27:15 <GilJ> Can anyone tell my why array indexing is O(n)?
09:27:35 <tromp> it's not
09:27:55 <mdmkolbe> GilJ: list indexing is O(n) (list != array)
09:27:56 <Zao> GilJ: Depends on what you mean by "array".
09:27:58 <tromp> :t (!)
09:27:59 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
09:28:07 <mdmkolbe> :t (!!)
09:28:08 <tromp> that's O(1)
09:28:08 <lambdabot> forall a. [a] -> Int -> a
09:28:22 <tromp> list indexing is O(n)
09:29:42 <pozic> cabal-update cabal-install gives me: ghc: could not execute: /usr/lib64/ccache/gcc
09:30:08 <GilJ> Thanks a lot guys! Now i can hipster on and code more haskell!
09:30:09 <pozic> Executing gcc works.
09:30:19 <GilJ> /q/
09:31:30 <mdmkolbe> pozic: does executing /usr/lib64/ccache/gcc work? ("gcc" from the command line is probably some other command)
09:31:45 <pozic> mdmkolbe: no.
09:31:56 <pozic> mdmkolbe: but I never told cabal to do anything with that path.
09:36:46 <mun_> Hi
09:36:56 <mdmkolbe> pozic: well "ccache" IIRC is a special compiler that attempts to cache compilation results, so did you maybe enable some kind of caching flag in either cabal or GHC?  (I'm shooting in the dark here.)
09:37:34 <mun_> if i have a polymorphic function f, then for f(a), does that mean the type of 'a' is necessarily a subtype of the type of the domain of f?
09:40:06 <mdmkolbe> mun_: Are you comming from an object-oriented background?  Haskell doesn't have the concept of subtype and it means something very different by polymorphism than OO languages.
09:41:07 <djahandarie> He just tends to ask his various logic questions in here :p
09:41:34 <mun_> mdmkolbe, right. so in the case of f(a), what does it say about the type of 'a'? is there some property the type of 'a' need to satisfy?
09:42:26 <mdmkolbe> mun_: it depends on the type of f
09:43:58 <mdmkolbe> mun_: if "f:: forall t. t -> blarg", then "a" can have any type.  If "f :: forall t. (t, t) -> blarg" then "a" must be something like (Int, Int) or (Char, Char), etc.
09:44:52 <mun_> right.
09:44:53 <mun_> thanks
09:45:03 <msieradzki_> is there any documentation about FFI between GHC and code compiled with MSVC?
09:45:32 <msieradzki_> I saw 1 comment that most of that documentation is outdated so I'm not sure if old GHC docs are up to date
09:48:07 <mdmkolbe> Any type theory experts around?  I was wondering about HM-type inference.  It is known to be exponential in the size of the program in the worst case.  However, is it also exponential in the size of the resultant types?  Might it be linear in the size of the resultant type?
09:52:01 <tarrasch> Hello. When I want documentation I usually use hoogle/hayoo. When I want haddock-documentation I usually just google the module name and hackage provides the documentation. Do cabal (or something) auotmatically supply me with offline-docs like hackage has? I would like to get documentation to view offline (the same as hackage has). Any ideas?
09:52:32 <o1iver> hey guys. I just saw don stewarts slides "Pratical Haskell Programming". I was wondering if there was a video of that presentation...
09:52:46 <o1iver> link if needed: http://donsbot.files.wordpress.com/2009/01/semicolon.pdf
09:56:30 <holmak> tarrasch: There is a command-line version of Hoogle on Hackage -- see here http://www.haskell.org/haskellwiki/Hoogle
09:57:09 <holmak> I don't know if it can display Hackage-style docs, though
09:57:16 <msieradzki_> more generally, how do I set mingw/cygwin environment so that cabal/ghc will find C libs even on Windows?
10:02:21 <tarrasch> So most haskellers usually seek up documentation more or less  in the way I described? Looking at hackage site when you want documentation for a module. Seems reasonable.
10:03:04 <dankna> actually, I have all docs installed locally
10:11:07 <holmak> tarrasch: I think so. Hoogle will also search for and link to Hackage packages, so I always go to Hoogle first for everything.
10:21:14 <sm> holmak: only if you add +therightpackagename, right
10:21:31 <stepkut> let's say I have, reads ("123" ++ repeat 'a') :: [(Int, String)]. That will return [(123, repeat 'a')]. Is there some way of telling how many characters reads consumed from the list ?
10:24:07 <deech> Hi all,
10:24:25 <deech> I've been going trying to setup xmonad on dual heads.
10:24:37 <Zao> deech: I've been going to #xmonad.
10:24:59 <deech> Zao: Crap, I though I did. Sorry
10:25:42 <Twey> stepkut: length (show "123") assuming show/read are well-behaved
10:25:49 <Twey> Er
10:25:55 <Twey> length (show 123)
10:25:59 <stepkut> Twey: ah, clever
10:26:00 <siracusa> stepkut: I don't think so, because you can have arbitrary whitespace before that number which length you cannot reconstruct.
10:26:06 <stepkut> siracusa: right
10:26:10 <Twey> Yeah, I guess so
10:26:16 <Twey> You probably need a Real Parser™
10:26:32 <stepkut> Twey: well, I have a real parser.. the question is how to lift read instances into that parser
10:26:44 <stepkut> Twey: the tricky part is updating the parse position
10:26:48 <holmak> sm: Hoogle always seems to produce links to packages, in the web version at least.
10:27:25 <Twey> stepkut: Mmm, I see :-\
10:27:26 <sm> maybe the core packages, but not all of them
10:28:44 <holmak> sm: I mean to say, it will search through all the *names* of packages on Hackage, but won't find functions in them
10:29:23 <holmak> So I can search for "Filepather" and get a link to the package, though I can't search for its functions
10:33:37 <sm> holmak: oh, yes it searches all package names
10:33:56 <holmak> That's all I meant to say, sorry for the ambiguity.
10:34:41 <sm> no worries
10:36:31 <varnie> hi. a simple question -- I have some module which exports several functions, but I can use all the rest ones in my program (which hadn't been exported)
10:36:36 <varnie> is it okay?
10:37:08 <sm> varnie: no, if you specify any exports then nothing else is exported
10:38:01 <varnie> module Foo (bar1) where  bar1 = blabla; bar2 = blablablabla;
10:38:24 <varnie> so, I am exporting only bar1 function from it to the "outer world".
10:38:42 <varnie> now, when I do :import Foo in GHCI console, I still can access bar2
10:39:02 <tarrasch> varnie, saved the file? :p
10:39:04 <ezyang> Whoa, Galois has another internship position available. Guess the funding spigot is flowing.
10:40:14 <tarrasch> varnie, actually I would *want* that behavior, at least for ghci since I usually use the ghci for manually testing my functions and examine signatures. Maybe new GHC7 feature?
10:40:17 <varnie> I wrote it incorrectly, it is so when I perform ":load Foo" in the GHCI session
10:40:41 <siracusa> varnie: GHCi allows you to use all functions from a module if that module is the only currently loaded module.
10:40:57 <varnie> hmm, then all is okay:) thank you for the point
10:41:13 <tarrasch> siracusa, have it always been like that?
10:41:32 <tarrasch> Anyway, it's a great I think
10:41:40 <siracusa> tarrasch: At least from 6.10 on
10:42:23 <siracusa> You can also ad an * before or after the module name to load all top-level variables
10:43:52 <linus73> hello
10:44:53 <fragamus> @type newStdGen
10:44:54 <lambdabot> IO StdGen
10:45:24 <tarrasch> siracusa, that's great to know! I've always wanted to do that, thanks :)
10:45:39 <tarrasch> linus73, hi!
10:46:13 <fragamus> @type Data.Random.Normal.normal
10:46:14 <lambdabot> Couldn't find qualified module.
10:49:08 <Favonia> @hoogle normal
10:49:08 <lambdabot> Language.Haskell.TH NormalB :: Exp -> Body
10:49:09 <lambdabot> Language.Haskell.TH.Syntax NormalB :: Exp -> Body
10:49:09 <lambdabot> Language.Haskell.TH normalB :: ExpQ -> BodyQ
10:50:21 <c_wraith> http://www.stanford.edu/group/gender/cgi-bin/wordpressblog/2011/06/researcher-reveals-how-computer-geeks-replaced-computer-girls/
10:51:36 <c_wraith> err.  meant to post that to -blah.  oh well
11:03:13 <sm> hrm.. when to explicitly list every imported symbol, and when not
11:04:09 <dankna> sm: never imo.
11:04:15 <dankna> you can get ghc to spit out such a list, I think
11:04:22 <adnam> sm: http://hackage.haskell.org/trac/ghc/wiki/Commentary/CodingStyle#Imports
11:04:35 <kamaji> is there a nice way to create a recursive function, say foo, with some initial arguments without making two functions?
11:05:53 <adnam> kamaji: think you need fix then, but i'd prefer two functions. you can always have a local let/where
11:06:26 <sm> thanks
11:07:22 <kamaji> adnam: I'm just talking generally, if that indicates bad code then that's fine by me :P
11:08:13 <kamaji> I don't see how the let/where would work though, unless it defines a function?
11:08:24 <sm> that's an interesting doc
11:08:26 <dankna> let and where do define functions
11:08:39 <dankna> let foo <patterns> = ...
11:08:58 <sm> I always thought explicit imports were recommended for code readability and possibly compilation speed, but if GHC avoids them I'll give it a try
11:09:00 <adnam> kamaji: sure you get two functions then
11:09:08 <damjan> I'm compiling pandoc (on arch linux) but it fails with http://paste.pocoo.org/show/401750/
11:09:24 <damjan> ghc is 7.0.2
11:09:28 <kamaji> so it's generally okay practice as long as it's within the 'main' function?
11:09:58 <adnam> it's okay practice anywhere, with a local declaration you don't bloat the modules namespace
11:10:40 <kamaji> oh I see, you have to explicitly export stuff in haskell, don't you
11:11:31 <kmc> from a module?
11:11:35 <kmc> if you have no export list, everything is exported
11:11:40 <kmc> otherwise, yes, it's explicit
11:11:58 <adnam> kamaji: http://hpaste.org/47523/exports
11:12:15 <adnam> do i messed that up
11:12:18 <adnam> doh*
11:12:40 <adnam> http://hpaste.org/47524/exports_annotation
11:18:20 <kamaji> adnam: oh cool, cheers
11:18:31 <kamaji> sorry I went to defrost some chicken, hoho
11:19:31 <Jeanne-Kamikaze> how can I force the execution of an IO action ? I'm trying to calculate time delays by reading the cpu clock and different spots but lazy evaluation is killing me
11:19:38 <Jeanne-Kamikaze> *at
11:19:46 <adnam> Jeanne-Kamikaze: what do you have?
11:20:10 <ulfdoz> Sieht imho bedeutend besser aus, als der Motif-Kram.
11:20:10 <Jeanne-Kamikaze> as in exact code ?
11:20:17 <ulfdoz> ewin, sorry.
11:20:40 <kmc> Jeanne-Kamikaze, laziness is about evaluation; you care about execution (as you said)
11:20:49 <kmc> Haskell makes a strong distinction between the two
11:20:52 <adnam> Jeanne-Kamikaze: yeah
11:21:13 <kmc> anyway, to execute an IO action, it suffices to glue it onto the other actions that eventually make up "main"
11:21:27 <adnam> i usually ended up with that problem when i was map:ing over IO instead of using mapM
11:21:27 <kmc> if you put "main = do x; y; z" then all of x,y,z will be executed, even if their results are unused
11:22:00 <Jeanne-Kamikaze> but if I do x <- someAction; stuff, stuff; use x here, when is someAction performed ?
11:22:05 <kmc> before the stuff
11:22:08 <Jeanne-Kamikaze> oh
11:22:25 <Jeanne-Kamikaze> then this must be going wrong somewhere else, thanks
11:22:34 <mun_> mdmkolbe, hi again.
11:22:41 <kmc> Jeanne-Kamikaze, there's a few exceptions, sort of
11:22:53 <mun_> mdmkolbe, going back with subtypes, is it not appropriate to think about subtypes in functional programming?
11:22:58 <ben> Just before someAction is performed, x is not immediately evaluated to WHNF or anything though, right?
11:23:13 <kmc> you mean just after? no
11:23:17 <Jeanne-Kamikaze> no
11:23:25 <kmc> an IO action can yield a totally unevaluated value
11:23:47 <kmc> Jeanne-Kamikaze, the standard library has some "lazy IO" function like readFile, which give you actions that execute immediately
11:23:56 <kmc> and do the actual IO behind the scenes as the return value is evaluated
11:24:00 <kmc> this is kind of terrible
11:24:02 <Jeanne-Kamikaze> hang on, if I actually open a file handle, read, close the handle, and say print the contents, I get nothing, presumably because the contents are not read until they are needed, and the handle has been previously closed
11:24:13 <kmc> it breaks the rules, confuses beginners, and fails to handle errors
11:24:21 <kmc> yeah, you've probably run into this lazy IO stuff
11:24:23 <hpc> Jeanne-Kamikaze: depends on how you read
11:24:23 <Jeanne-Kamikaze> esxactly
11:24:41 <hpc> Jeanne-Kamikaze: hgetContents is the "lazy read"
11:24:51 <hpc> or any other "getContents"-ish function
11:25:22 <Jeanne-Kamikaze> right
11:25:38 <hpc> and that's all i can properly explain without someone saying im wrong :P
11:25:44 <hpc> haven't had to do file IO in a while
11:26:06 <kmc> it's regrettable that the stdlib doesn't have a strict getContents
11:26:21 <kmc> imo lazy IO falls into that category of "cute, but really a bad idea"
11:26:56 <joau> Hi, I was wondering if it is possible to reuse the final state returned from a runstate as the initstate of another runstate? And if it is a good idea?
11:27:03 <kmc> yes, and yes
11:27:06 <hpc> getContents' = do{all <- getContents; let all' = rnf all in return all'}
11:27:13 <kmc> the "state" is just a value being passed around to some functions
11:27:28 <kmc> it's not a special destructive update thing
11:28:13 <hpc> :t get >>= id
11:28:14 <lambdabot> forall (m :: * -> *) b. (MonadState (m b) m) => m b
11:28:27 <joau> kmc, seems like it somehow get's a bit messed up the second time it gets sent in
11:29:05 <kmc> then you're doing something wrong
11:29:20 <kmc> also, why are you chaining them together like this
11:29:31 <kmc> instead of chaining the State actions themselves
11:29:40 <hpc> @src State (>>=)
11:29:42 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
11:29:53 <joau> Just trying to involve the IO monad, as I am reading user input in between
11:29:57 <kmc> hpc, that still requires forcing to WHNF before the file is read
11:30:19 <dolio> @src >>= State
11:30:19 <lambdabot> Source not found. Sorry.
11:30:27 <hpc> @src State >>=
11:30:27 <lambdabot> Source not found. I am sorry.
11:30:32 <hpc> @src State =<<
11:30:32 <lambdabot> Source not found. :(
11:30:35 <hpc> eh
11:30:49 <kmc> hpc, maybe "return $! all'"
11:31:19 <hpc> kmc: what do you mean before the file is read?
11:31:44 <hpc> oh!
11:31:54 <hpc> the IO action gets whdf'd before the file is read
11:32:00 <kmc> i mean that executing your getContents' will not force any reading
11:32:09 <hpc> yeah, i see now
11:32:19 <kmc> yeah, IO actions themselves are always evaluated to whnf before being executed.  because (conceptually) the runtime system has to pattern-match on them
11:32:38 <hpc> but $! would make it so rwhf on the IO action will rnf the input, which forces reading from file
11:32:50 <kmc> yeah
11:33:14 <hpc> someone should contribute that to System.IO
11:34:39 <kmc> i think it's really hard to get stuff added to base
11:35:12 <damjan> is there a different channel where I can ask pandoc questions?
11:37:38 <mdmkolbe> mun_: sub-types vs not sub-types has nothing to do with functional programming.  It has more to do with what kind of type system is used by a particular language.  In the type system that Haskell uses, no, it is not appropriate to think of subtypes in the sense of one type inheriting from another.  (Technically, there are other notions of subtypes which Haskell does have but until you really understand basic Haskell types, you should 
11:38:07 <hpc> getContents' seems like a sufficiently important obvious omission that it would be added
11:38:22 <kosmikus> mdmkolbe: your message was cut after "you should" ...
11:42:13 <mdmkolbe> mun_: ... you should ignore them.)
11:42:21 <mdmkolbe> kosmikus: thx
11:49:38 * hackagebot compdata 0.3 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.3 (PatrickBahr)
12:01:20 <Omie> Hi everyone ! I finished making my first Gtk2Hs program.. Notepad :-D
12:02:25 <dolio> @type (id :: Int -> Int) :: (forall a. a) -> Int
12:02:26 <lambdabot>     Couldn't match expected type `forall a. a'
12:02:27 <lambdabot>            against inferred type `Int'
12:02:27 <lambdabot>     In the expression: (id :: Int -> Int) :: (forall a. a) -> Int
12:02:40 * ClaudiusMaximus working on a gtk2hs program today - discovered size groups last night, so my labels+entries line up nicely :)
12:03:19 <sm> monochrom: where's your cabal doc, again ?
12:03:24 <Omie> you can check source here - http://hpaste.org/47526/hnotepad http://hpaste.org/47527/hnotepad__glade Its not so Haskellish I guess... so.. please do tell me where to improve :)
12:04:06 <dolio> @type (\x -> (id :: Int -> Int) x) :: (forall a. a) -> Int
12:04:07 <lambdabot> (forall a. a) -> Int
12:11:42 <seydar> copumpkin: lolzzzzzzz @ you
12:25:10 <ClaudiusMaximus> > isDenormalized (1e-40 :: Float)
12:25:11 <lambdabot>   True
12:25:21 <ClaudiusMaximus> darn
12:26:40 <sanjoyd> What is the difference between "data A = B Integer" and "newtype A = B Integer"?
12:27:26 <kmc> to first approximation, the newtype is the same but with less run-time overhead
12:27:33 <mauke> B undefined is undefined, while B undefined isn't
12:28:09 <mauke> for less confusion dial two different identifiers ... after the beep
12:28:48 <sanjoyd> mauke: yeah, thought so. :)
12:29:00 <sanjoyd> So newtype does not create a different _|_ ?
12:29:03 <kmc> correct
12:29:27 <kmc> the intent is that compilers can represent your newtype A the same way they represent Integer
12:29:36 <kmc> so there is no run-time overhead
12:29:51 <kmc> but this entails collapsing the ⊥'s so that's what the spec says
12:30:01 <sanjoyd> data => sum domains of (product domains of the types each constructor takes).
12:30:13 <sanjoyd> newtype => alias to clear things up.
12:30:28 <kmc> if you just want an alias, you'd use 'type'
12:30:43 <kmc> that's transparent and gives you no additional type checking
12:31:03 <ddarius> The Report calls newtype a "type renaming"
12:31:18 <sanjoyd> Oh, okay.
12:31:19 <kmc> 'newtype' is useful for "this type is semantically distinct, and shouldn't be mixed, but can have identical representation to an existing type"
12:31:28 <kmc> ddarius, that's... unfortunate
12:31:37 <sanjoyd> Clearer now. Thanks! :)
12:39:45 * hackagebot gitit 0.8.0.1 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.8.0.1 (JohnMacFarlane)
13:00:04 <LittleQNCCU> hello, may i ask how to identify "a variable is some type", just return True and False
13:00:44 <c_wraith> LittleQNCCU: you can't.  all types are at compile time, not run time.  The question doesn't even make sense.
13:01:18 <c_wraith> (there are some hedges, like things that use Typeable..  But generally, if you're asking that question, you're not thinking in haskell)
13:01:31 <LittleQNCCU> okay
13:02:05 <LittleQNCCU> i'm a beginner of Haskell, thank's for ur help
13:02:12 <c_wraith> Well, what are you doing?
13:02:19 <c_wraith> We can be a bit more helpful than that.
13:02:38 <c_wraith> Like, tell us why you want to do that, and we might be able to provide an alternate way of doing things.
13:02:53 <LittleQNCCU> i'm using haskell to implement a clite interpreter
13:03:26 <LittleQNCCU> I need to validate some statements.
13:03:55 <LittleQNCCU> a statement will be the following form:(Variable, Type)
13:04:19 <LittleQNCCU> Variable, Type are self-defined types
13:05:09 <LittleQNCCU> validStmt mp  (Assign var e)  = var::
13:05:20 <LittleQNCCU> validStmt mp  (Assign var e)  = ???
13:05:21 <Cale> LittleQNCCU: Yeah, so you're probably building up some environment of variables (values of type Variable) and types (values of type Type), and you want to look in that mapping to answer the question.
13:05:34 <LittleQNCCU> yeah
13:05:48 <Cale> LittleQNCCU: So you'll use something like Map Variable Type
13:06:03 <LittleQNCCU> yap:D u got it
13:06:28 <Cale> and you'll do a lookup in the map
13:07:06 <LittleQNCCU> Yeah, but i use data statement to define Type or Variable
13:07:22 <LittleQNCCU> for instances, data Type =  CInt | CFloat | CBool | CChar deriving Show
13:09:05 <Cale> validStmt mp (Assign var e) = case Map.lookup var mp of Nothing -> False; Just t -> inferTypeOf mp e == t
13:09:11 <Cale> ^^ to some approximation
13:10:11 <parcs> anyone know how to restart the ghci process within emacs' haskell-mode?
13:10:58 <LittleQNCCU> okay, i'll try to understand the answer provided by you, i'm a very beginner:)Thanks for your help
13:11:55 <LittleQNCCU> people on haskell channel are very friendly!
13:13:38 <Cale> LittleQNCCU: Like, if the variable being assigned to doesn't have a type in your mapping, then something has gone wrong, and the statement is invalid. If it does, and the mapping says it has type t, then the type inferred for the expression e had better be t as well, in this simple system.
13:14:09 <Cale> (if there was some polymorphism, you'd have to be a little more careful than just checking that the inferred type equals the declared type)
13:14:34 <LittleQNCCU> yeah, i just found the things what you just told me. Nice XD
13:15:30 <LittleQNCCU> If they didn't match the types I specified, they won't come to there, right?
13:18:00 <kamaji> I'm trying to implement pollard-rho, and i'm sure I can get rid of some brackets in this expression, can anyone help? pollardRho' n (f x) ((f . f) y) (gcd (abs (x - y)) n)
13:18:06 <kamaji> should I just use a where clause?
13:18:50 <kmc> ((f . f) y) ==> (f . f $ y)
13:18:51 <LittleQNCCU> I think it will recusively validate statements. The problem became easier.
13:19:03 <kmc> (gcd n $ abs (x-y))
13:19:19 <kamaji> oh, for some reason I thought $ eliminated brackets on the RHS.... seems really dumb now :P
13:19:29 <kmc> hmm?
13:19:33 <kmc> that is the RHS of something, yes?
13:19:42 <adimit> nom nom brackets.
13:19:49 <kmc> ($) isn't special bracket-elimination syntax; it's just an operator
13:20:06 <kamaji> I thought it sort of turned everything to the right of $ into a single thing.. I didn't really get it
13:20:17 <Taslem> $ has low precedence.
13:20:17 <adimit> :t ($)
13:20:17 <lambdabot> forall a b. (a -> b) -> a -> b
13:20:24 <kmc> @src ($)
13:20:24 <lambdabot> f $ x = f x
13:21:03 <kmc> > succ $ 4*5
13:21:04 <lambdabot>   21
13:21:09 <kmc> > (succ $ 4)*5
13:21:10 <lambdabot>   25
13:21:16 <adimit> It just has lower precedence than everything else, ensuring that all other operators will be applied *before* ($)
13:21:42 <kamaji> hmm... ok
13:22:01 <Taslem> Tge prefix - operator technically has lower precendce, doesn't it?
13:22:02 <kamaji> thanks
13:22:38 <kmc> maybe Taslem
13:22:43 <kmc> it's a syntactic special case
13:23:00 <Taslem> Yeah, I guess.
13:23:00 <kmc> > -2 $ (+1)
13:23:02 <lambdabot>   -2
13:23:05 <kmc> > -(2 $ (+1))
13:23:06 <lambdabot>   -2
13:23:10 <kmc> > (-2) $ (+1)
13:23:11 <lambdabot>   -2
13:23:20 <kmc> ?
13:23:36 <kmc> oh, stupid lambdabot
13:23:40 <adimit> lol.
13:23:43 <kmc> lol indeed
13:24:57 <adimit> neither of these are actually valid haskell.
13:25:09 <Tyr42_> I just tried them in ghci
13:25:13 <kmc> they're valid Haskell in the presence of certain unorthodox type class instances
13:25:14 <Tyr42_> doesn't work
13:25:15 <kmc> which lambdabot has
13:25:22 <kmc> but they do not require language extensions
13:25:25 <kmc> > 3 $ 49
13:25:27 <lambdabot>   3
13:25:36 <adimit> O_o  you're right.
13:25:53 <adimit> didn't know lambdabot had such… interesting… classes defined.
13:26:04 <kmc> yeah
13:26:09 <adimit> This is some sort of Num (a -> b)?
13:26:12 <kmc> yes
13:26:22 <adimit> is that useful at all?
13:26:22 <kmc> an integer literal is a constant function
13:26:37 <kmc> f + g = \x -> f x + g x
13:26:49 <ski> > (cos^2 + sin^2) `map` [0,pi/8 .. pi]
13:26:49 <kmc> similar things are common in maths
13:26:50 <lambdabot>   [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0]
13:37:15 <adimit> ok, so since this is quiet, I'll just ask a random question, more because I'm too lazy to think. Iteratees (with John Lato's iteratee): I'm making a *huge* data structure inside an iteratee, and I'd like to spit out progress statistics on stdout. How do I do that?
13:37:33 <fragamus> I have a question: I'm using randT and loving it. I can snag a random number whenever I want one like this: coin <- getRandomR (0, 1 :: Int ) BUT... now I have a function that requires that I suppy it a Random.RandomGen, and then it returns a modified Random.RandomGen   SO... I need to jam that modified one back into the RandT monad.
13:38:10 <adimit> (addendum: it should be per-chunk. So I've read a chunk into my data structure, now please give me information.)
13:38:19 <fragamus> Can said randomGen be jammed back into RandT?
13:39:43 <kmc> you're using the MonadRandom package?
13:40:23 <fragamus> yah
13:40:37 <kmc> you could do it if the RandT data constructor were exported
13:40:45 <osfameron> adimit: I don't know anything about Iteratees, sounds interesting though.  For the usage statistics, could you put the whole thing in a Writer monad, or am I way off the mark?
13:41:02 <parcs> fragamus: newGen <- blah; lift $ evalRandT restOfOperations newGen
13:41:43 <adimit> osfameron: that's my current idea. I just discovered, though, that the size function of Data.HashMap isn't O(1), so that'll make my endeavours a little… difficult.
13:42:13 <osfameron> adimit: oh? what's that?
13:42:59 <adimit> osfameron: HashMap? It computes the size of itself by recursing over its tree structure. If I did a size operation some 2000 times just for status updates, I'd significantly slow down operation.
13:43:04 <kmc> there's no way to ask RandT for the RandomGen it's using
13:43:14 <kmc> fragamus, you might have to drop down a level and use StateT
13:43:49 <Tasser> are there continuations? (or how you write it)
13:44:17 <adimit> also, there's some other architectural awkwardness. If I put everything in a writer monad, I'd have to… well, lazily print the result of runWriterT where the iteratee is inside a monad stack.
13:44:31 <parcs> fragamus: never mind, missed the part where you require the original randomgen
13:44:46 <fragamus> gah
13:45:25 <tsuraan_> is there a list of known regressions from ghc 6.12 to 7.0.3?  I have some numerical code I've been trying to tune under ghc6 that takes about 100x longer to run in ghc7
13:47:43 <tsuraan_> using -fllvm or -fasm under ghc7 doesn't make much of a difference.  compiling with O2 on both versions
13:51:47 <osfameron> adimit: oh I see.  you could use a State monad then and increment every time you add a value to the hashmap instead?  Then again, perhaps you could just do it with a size operation and profile to see if it *actually* slows you down much
13:54:15 <adimit> osfameron: since I do an update operation, not insert (technically, insertWith) I'd have to do a lookup, *then* update. Which would just amount to counting chunks. That's OK though, I'd settle for that, right now. Though my current problem is a different one: how do I print per-chunk status information, which would depend on the last chunk's status information? (I.e. cumulative status information.)
13:54:51 <adimit> This would obviously have to be done in a fold. But I don't know if I.foldl' f 0 >>= loggerIteratee will get the job done (i.e. print cumulative status information per chunk.)
13:55:32 <adimit> (where f is the counting function, and loggerIteratee is using IO-lifting to print.
14:04:12 * hackagebot persistent-equivalence 0.1 - Persistent equivalence relations (aka union-find)  http://hackage.haskell.org/package/persistent-equivalence-0.1 (ChrisSmith)
14:08:20 <MHD> When is it desirable to have separate definitions of >> and >>=?
14:08:48 <sipa> possible optimized implementation for >>
14:08:53 <adimit> Maybe when >>= would be significantly more expensive than >>
14:09:02 <MHD> okay
14:09:06 <adimit> since >> is implemented in terms of >>=
14:09:12 <adimit> @src (>>)
14:09:12 <lambdabot> m >> k      = m >>= \_ -> k
14:09:46 <MHD> adimit: are ther any such cases in some widely used library?
14:10:22 <adimit> MHD: I am not aware of any, but I have also never really been interested, so there might be any.
14:10:55 <adimit> *some
14:12:01 <dolio> In a probability monad, I think m >> n = n.
14:12:07 <MHD> Why isn't there a module with a definition of "instance Monad m => Functor m" and an "instance Monad m => Applicative m" and an "instance MonadPlus m => Alternative m"?
14:12:19 <dolio> Whereas for m >> = \_ -> n, you're required to do a bunch of work that will work out to n.
14:12:40 <MHD> It's like the twentieth time i do "fmap = liftM" and "pure = return"
14:12:48 <byorgey> MHD: because those instances would overlap with every other instance ever.
14:13:25 <byorgey> MHD: I must say I'm surprised you have encountered a type which is an instance of Monad but not Functor.
14:13:36 <byorgey> although things which are Monad but not Applicative are still sadly common
14:13:41 <MHD> byorgey: I write monads myself alot
14:13:52 <byorgey> oh, I see, of course.
14:14:25 <scree> MHD: there are certainly cases where this would not be appropriate, i.e. you want optimized implementations of fmap or whatever
14:14:35 <byorgey> MHD: there have been various proposals over the years of various ways of specifying default implementations in terms of other type classes
14:14:42 <byorgey> none has particularly caught on
14:14:47 <MHD> sad
14:14:51 <scree> MHD: and having a general instance of the form you give prohibits that
14:15:21 <MHD> Would be nice if a more specific instance overwrote a more general
14:15:22 <dolio> Those instances just don't work appropriately.
14:15:39 <dolio> And overlapping instances are evil in general.
14:15:55 <scree> MHD: if it bothers you, it's not absurd to write TH for "derive Functor", "derive Applicative" &c.
14:16:12 <dolio> GHC can already derive Functor.
14:16:18 <MHD> scree: how do I do that?
14:17:05 <Tomsik> There was one person at my uni who wrote a very syntactic work on deriving functor instances for positive types
14:17:21 <MHD> holy damn it's a thunderstorm outside.
14:17:22 <Tomsik> which is as generic as possible if I understand correctly
14:17:29 <scree> MHD: it's a rather nasty case of TH.  Essentially you write a syntax tree for "instance Functor (foo) where fmap = liftM" and so on
14:17:31 <dolio> And SHE has facilities for default superclass instances. That's not really an option for Monad, Functor, etc. though.
14:18:15 <scree> MHD: if you don't know TH, look at some tutorials; if you do, look at the docs to find out exactly what to write.  I'd say only I can't remember either
14:18:31 <MHD> scree, dolio: Excuse my Acronym noobishness TH = Type Hack? SHE = ?
14:18:38 <rdrey> hey, i saw a tutorial somewhere had a ghci set flag that would return how long a command took to run. anyone know the flag?
14:18:46 <Eduard_Munteanu> MHD: Template Haskell
14:18:48 <dolio> SHE = Strathclyde Haskell Enhancement.
14:18:49 <scree> MHD: TH = Template Haskell. SHE = ?
14:18:57 <parcs> rdrey: set +s
14:19:01 <dolio> It's full of great stuff.
14:19:02 <MHD> dolio: What's SHE?
14:19:03 <rdrey> thanks
14:19:11 <dolio> It's a preprocessor for Haskell.
14:19:16 <MHD> okay
14:19:27 <byorgey> MHD: not what, who ;-)
14:19:33 <dolio> It adds a bunch of features. Superclass defaults being one.
14:19:41 <dolio> Pattern synonyms are another nice feature.
14:20:35 <dolio> It's also got some aspect oriented stuff I don't know much about, and some faux dependent typing which you probably aren't interested in.
14:20:40 <dolio> And idiom brackets.
14:23:06 <scree> which reminds me -- does anyone know if there's a reason why TH has to suck at quasiquoting instance declarations?  Is it a wanted feature?
14:23:49 <c_wraith> Does it?  I hadn't noticed it does.
14:24:23 <scree> either that or I've been an idiot the one or two times I've wanted to do TH on instance decls.  You have to build them by hand I think
14:24:35 <scree> which is not great for readability
14:24:46 <c_wraith> ah.  sounds like you don't know about [d| |] quotes
14:25:25 <c_wraith> [| |] quotes have type Q Exp.  [d| |] quotes have type Q [Decl]
14:25:27 <Lemmih> c_wraith: Yo yo.
14:25:35 <scree> c_wraith: I think I do; and I can write a list of foo = bar declarations I want to put in my instance declaration; but I then have to add the instance header manually
14:26:47 <c_wraith> Lemmih: So, if I use SDML-mixer and play music, it always stops well before the end of the music.  Either when I generate a ton of input events at once, or if I don't do that, something like 30 seconds in.
14:26:50 <scree> c_wraith: i.e., [d| fmap = liftM] works fine; [d| instance Functor $(name) where fmap = liftM] does not
14:27:27 <c_wraith> scree: that's odd.  Should work.  does name have the right type for a sub-splice there?
14:28:06 <scree> c_wraith: probably not; I haven't tried to do this recently so I'm making that up; but I have tried once or twice in the past
14:28:12 * scree goes away to try again
14:28:20 <c_wraith> scree: ok.  I would think it *should* work.
14:29:15 <Lemmih> c_wraith: Hm. I don't know why that is.
14:30:29 <c_wraith> Lemmih: http://hpaste.org/47531/sdlmixer has the code...  Note that there's a bunch of unrelated stuff in there - that was my testbed for learning pretty much all of it.
14:30:37 <c_wraith> Lemmih: it's still pretty short
14:31:15 <c_wraith> Lemmih: one thing I don't know is if I'm doing anything horribly wrong. :)
14:31:45 <edwardk> scree: the main problem with quasiquoting instance declarations with [d| |] brackets is that TH expansion and type expansion are interleaved and you have to pass type checking at each stage.
14:32:53 <edwardk> worst case you can build the instance statement yourself and just feed it quoted declarations for the body
14:33:41 <edwardk> c_wraith: another option is instance Monad $(name) => Functor $name where' which will cause it to realize the Monad instance is present, especially if the Monad instance is in the same file.
14:33:58 <edwardk> you'll wind up with a spurious Monad constraint in the haddock, but it'll typecheck
14:34:07 <edwardk> i had to use that in a couple of places in my ad package
14:34:22 <c_wraith> Interesting.
14:36:09 <scree> edwardk: interesting.  So, I can make a simple case work, but only by turning on extensions to stop it complaining about "instance Functor t_aL9" (needs FlexibleInstances)
14:36:16 <scree> edwardk: which I guess is what you just said
14:37:23 <scree> edwardk: and, yes, in the past I guess I've resorted to your "worst case" if the alternative was some less comfortable type extension, or not at all
14:39:32 <edwardk> well, instance Functor t_aL9 is somewhat dangerous is that name thing actualy returning a variable and not a full type expansion?
14:40:08 <edwardk> if its just returning a variable you're making up the functor instance Functor f where fmap = liftM which is definitely not what you want!
14:40:28 <edwardk> if its returning a type constructor you're better off
14:43:55 <scree> edwardk: in my (hastily mocked-up) version it's a quote for $(conT n), n a Name
14:43:57 <tsuraan_> could somebody with ghc7 installed try running this small program: https://gist.github.com/1011151 ?  On the same machine, ghc6 is running it at 270ms/loop, and ghc7 is running it at 60s/loop.  I'm wondering if my setup is sane
14:44:03 <scree> edwardk: so I guess that's the latter
14:44:09 <edwardk> ah
14:44:10 <edwardk> good
14:44:15 <edwardk> the expansion you gave scared me
14:44:41 <scree> edwardk: right, that compiler error is surprising
14:45:46 * scree wonders if tsuraan_ is a code injection vector
14:45:54 <tsuraan_> I hope not
14:46:09 <tsuraan_> does anything in that snippet look dangerous?
14:46:34 <tsuraan_> I guess it's longer than it used to be, but it's still not many lines of code
14:47:06 <edwardk> great now, given scree's comments and tsuraan's reply i'm having snow crash flashbacks. if i flicker out of the channel, don't look ;)
14:47:13 <tsuraan_> hehe
14:47:26 <Cale> tsuraan_: mean: 247.5636 ms, lb 247.3975 ms, ub 247.7841 ms, ci 0.950
14:47:38 <Cale> tsuraan_: I'm using 7.0.3
14:47:49 <tsuraan_> Cale: thanks!  my system must be borked, somehow
14:47:58 <Cale> Did you compile with -O2?
14:48:11 <tsuraan_> ghc -Wall -O2 --make Easy.hs
14:48:17 <tsuraan_> and I've tried -fllvm
14:48:23 <neilk_> Hi folks. I am trying to eval if Haskell is a fit for my next project. I got into an interesting discussion on Hacker News about it -- someone who was very against Haskell from an ops perspective -- and I was wondering if anyone here could provide a countering opinion
14:48:31 <tsuraan_> I was hoping that would make it faster, but it didn't help any
14:48:35 <maurer_> tsuraan_: Do you have an old CPU?
14:48:49 <blackh> neilk_: How many would you like?
14:48:49 <tsuraan_> no, it's a recent amd64
14:48:54 * maurer_ is wondering if ghc is being confused as to what low level insns can be used
14:49:08 <neilk_> blackh: as many as required :)  Anyway the discussion is here : http://news.ycombinator.com/item?id=2620679
14:49:25 <Cale> neilk_: What sort of project? Haskell is a pretty awesome language in general.
14:49:25 <blackh> neilk_: That was a joke. :) OK - Will read.
14:49:44 <MHD> what significance does the "m -> e" have in "instance Monad m => MonadError e m | m -> e where"?
14:49:49 <kmc> "functional dependency"
14:49:53 <neilk_> Cale: a web-based voting system
14:49:55 <tsuraan_> it's a dual-socket hex-core (total of 12 cores) machine, tons of RAM
14:49:59 <kmc> says that for each 'm', there is only one possible 'e'
14:50:19 <MHD> kmc: Yes, that's what it's called. Waht exactly does it do?
14:50:20 <kmc> you can't write both "instance MonadError B A" and "instance MonadError C A"
14:50:30 <MHD> kmc: Okay
14:50:41 <kmc> it allows the implementation to make this assumption, which resolves some otherwise-ambiguous situations
14:50:42 <neilk_> Cale: Getting votes right is extremely important, so I like how testable I can make Haskell. Plus, I just find other languages retarded, the more I learn of Haskell.
14:50:48 <kmc> and it checks the assumption when you add more instances
14:51:20 <Cale> Seems reasonable.
14:51:22 <edwardk> effectively your choice of monad there is determining the error type used
14:51:40 <neilk_> Cale, blackh: Actually the parent post to mine might be a better start -- nostrademons asserts that Haskell development in real production would be "hellish" and he also asserts a student of SPJ's says the same thing.
14:51:53 <neilk_> http://news.ycombinator.com/item?id=2620002
14:52:12 <edwardk> neilk_: haskell in production is actually really nice
14:52:17 <monochrom> that would imply Galois.com is hell
14:52:34 <edwardk> everyone i know that is using it in a production setting is very happy with it.
14:52:47 <kmc> i would say it was hell five or six years ago
14:52:50 <c_wraith> Eh.  From the former Galois employees that work here, they don't do much that's a lot like "production" use. :)
14:52:54 <maurer_> tsuraan_: mean: 276.4456 ms, lb 276.2433 ms, ub 276.7145 ms, ci 0.950
14:52:55 <kmc> before cabal, hackage, etc
14:53:03 <maurer_> tsuraan_: You must have a unique configuration?
14:53:10 <c_wraith> But my company has lots of haskell code in production
14:53:13 <kmc> the Haskell ecosystem has changed a tremendous amount
14:53:18 <liyang> We do!
14:53:21 <neilk_> edwardk: in the thread nostrademons asserts that there are bizarre spikes in memory usage; is that a factor of just not knowing how to avoid space leaks. He also suggests that because it's hard to work logging into a non-monadic situation, you can't figure things out quickly.
14:53:24 <edwardk> since cabal came along, and the community grew up with it, and things have settled with the haskell platform its been a wonderfully productive environment
14:53:33 <tsuraan_> maurer_: thanks
14:53:40 <kmc> there are a lot of criticisms that were totally valid 5 years ago, but are no longer relevant
14:53:45 <blackh> neilk_: From a practical perspective (and from much experience), the *only* thing I think is difficult with Haskell for production system is the issue of space leaks.  However, there are two things: 1. If you spend the time to understand the issue and treat it as a design issue, then most people (myself included) find that it is not a problem.  It *does* contribute to Haskell's overall learning curve, however, but for "junior programmers" on a large tea
14:54:10 <tsuraan_> maurer_: I don't think it's terribly unique.  it's a 12-core machine with 16GB RAM, but I wouldn't expect that to hurt anything
14:54:12 <Cale> blackh: Your message was cut off at "on a large te"(am)
14:54:17 <neilk_> FYI, nostrademons is a Google employee BTW and from experience I know that they tend to see the world in terms of their own tools. They're all like "well that's nice but I can't do this at a datacenter level"
14:54:30 <blackh> am, I doubt it would be a problem in practice.  2. Haskell has so many advantages for real world projects, that they very largely offset the space leaks.  In other words, you will save time elsewhere. [thanks]
14:54:49 <neilk_> blackh: thanks
14:55:10 <neilk_> blackh: seriously, my day job is PHP (Wikipedia). What you people call a space leak, we call allocating a new variable.
14:55:18 <kmc> hahaha
14:55:21 <edwardk> frankly i've never faced these magical memory spikes folks complain about, and i've written some code in haskell that runs for a very long time. use strict containers and ! where you take small steps and know you need the answers and they go away. write code from the bottom up in the most general terms and it is easily testable, so you don't NEED complicated logging frameworks
14:55:22 <Cale> neilk_: blackh and I are using Haskell in a game, and it's working out reasonably well. Space issues have not been too much of a problem so far as I'm aware... (have they?)
14:55:31 <edwardk> and the few things you need to log you can use Debug.Trace or Debug.Traced
14:55:32 <blackh> neilk_: Logging in non-monadic situations:  In my experience it's not a problem in practice.  For debugging, you use Debug.Trace.  If you need actual logging, then you need to do it properly anyway.
14:57:06 <blackh> Cale, neilk_: Overall they have not been a problem at all - but then I have gone through the learning curve and know how to avoid them.  There was one exception, however:  Someone wrote a whole pile of code and said "Hey - this leaks."  It turned out to be a data structure with closures referencing the data structure.  That's what I mean about "design issues".  The structure of the data wasn't really quite thought out right.
14:57:19 <edwardk> and if you wrote the code in the more general fashion you'd probably have a monad threaded through or an initial encoding of something in a big ADT that you can print out so the logging 'd be irrelevant
14:57:20 <neilk_> yeah
14:57:48 <Cale> neilk_: In my experience, space issues are not really more of a problem than they are in most other languages, they're just different. You can write programs in any language which use too much memory.
14:58:24 <neilk_> It is often said that laziness makes it hard to predict memory usage in Haskell, though. I'm not sure I can envision how that comes to pass, though.
14:58:32 <edwardk> also the issue that nostrawhateverhisname is complains about with records is largely a non issue addressed by the appropriate use of lenses.
14:58:36 <neilk_> In any case, all that says to me is that one needs to test it more
14:58:49 <neilk_> with bigger datasets
14:59:02 <edwardk> neilk: it is often said, but mostly by people new to the language or who don't understand why and when to put in ! annotations ;)
14:59:02 <Cale> Well, it's somewhat true, if you're unfamiliar with how lazy evaluation works, it can catch you off guard a lot.
14:59:42 <edwardk> or even when to take them out.
15:00:08 <Cale> Edward Yang has been doing a series on this lately, hasn't he?
15:00:20 <neilk_> is there a good primer on Lenses?
15:00:27 <scree> so, I've seen the case blackh talks about -- data structures referencing themselves and avoiding GC -- hit just as hard in a strict language (OCaml).  Lazyness doesn't have to be the issue
15:00:28 <blackh> neilk_: People complain about other things in Haskell, such as the field accessors being a bit fugly to use, modules being a bit over-simple in their design, etc, and so on, but those things are not problems in practice.  A lot of complaints come from people not knowing how to do things.  I think the space leaks are the only actually legitimate complaint about Haskell.
15:00:42 <edwardk> the beautiful part about laziness to me trumps the rare strictness issues. which is that i can compose two lazy algorithms and get an asymptotically optimal result without rewriting them to care about each other.
15:01:12 <neilk_> I have encountered this "Lens" term and it is completely baffling -- seems to be a type of a mapping between types or something
15:01:26 <blackh> neilk_: Another way I like to put it is this: Haskell has lots of huge advantages.  Laziness is one of them, but out of all of them, it's the only one that comes with a significant cost.
15:01:36 <dankna> @src nub
15:01:36 <lambdabot> nub = nubBy (==)
15:01:39 <dankna> @src nubBy
15:01:39 <lambdabot> nubBy eq []             =  []
15:01:39 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
15:01:41 <edwardk> neilk: the short version: consider a function that knows how to get a b out of an a.    a -> b
15:01:46 <neilk_> Unfortunately, I am only spottily self-educated in CS and when you all say things like "A lens is a bijection" it's not helpful :)
15:01:50 <edwardk> neilk_:  then consider a function that knows how to put it bac
15:01:53 <edwardk> b -> a -> a
15:02:04 <edwardk> pair them up, and you have a lens, consisting of a getter and a setter.
15:02:07 <blackh> neilk_: Lenses are pretty simple...  My favourite package is fc-labels, but there are about four of them.
15:02:36 <edwardk> you can also tuple them up, a -> (b, b -> a) — so that you have a function from a a to a value for the 'field' and a function that'll set it to something else.
15:03:02 <blackh> neilk_: What lenses are is a representation of something contained in some data structure, in such a way that you get and set the value.  The most obvious case of this is fields in a 'data' record.
15:03:09 <edwardk> neilk_: it turns out that this is enough that you can define a lot of nice functions, once that modify the field, (getting, changing, then setting) etc. while remaining purely functional
15:03:35 <edwardk> yeah, heck i have lenses in comonad-transformers even
15:04:13 <edwardk> http://hackage.haskell.org/packages/archive/comonad-transformers/1.6.3/doc/html/Data-Lens-Common.html and http://hackage.haskell.org/packages/archive/comonad-transformers/1.6.3/doc/html/Data-Lens-Lazy.html
15:04:33 <Cale> Actually, there was a pretty good intro talk on lenses aimed at scala people as I remember it...
15:04:37 <neilk_> blackh: ok, so it's a sort of purely functional getter/setter pair of functions to transform something
15:04:43 <Cale> *cough* *cough*
15:04:47 <edwardk> cale: hahaha
15:04:51 <blackh> neilk_: That's it
15:05:07 <neilk_> I see -- that makes sense now, in the context of record types
15:05:19 <dolio> I heard is was all functional evangelism, and not suitable for real world stuff.
15:05:20 <edwardk> http://www.youtube.com/watch?v=efv0SQNde5Q&list=PLEDE5BE0C69AF6CCE
15:05:31 <edwardk> dolio: =)
15:05:54 <blackh> neilk_: We use them in the game to represent getting the position or velocity out of a 'signal' representing motion, so they can be more abstract than just a field value.
15:05:59 <edwardk> neilk: that video is me rambling on about how you can use lenses to write imperative code functionally
15:06:18 <neilk_> edwardk: thanks!
15:06:37 <neilk_> neilk_: bookmarked
15:06:37 <edwardk> neilk: its scala, but if you can read java and haskell you'll be fine
15:06:44 <dolio> How well does that actually translate into Haskell? I guess it's only slightly more verbose.
15:06:44 <neilk_> er, I mean edwardk: bookmarked.
15:07:11 <neilk_> edwardk: I know a little Scala.
15:08:01 <edwardk> dolio: the code from the talk?
15:08:09 <blackh> neilk_: Don't underestimate the power of referential transparency, though.  As a project gets larger, referential transparency makes your life easier and easier.
15:08:31 <edwardk> dolio: you need to use a function for getting rather than implicitly convert a lens into a getter, and otherwise its the same or less verbose throughout
15:08:43 <Peaker_> "space issues" may not be especially hard in Haskell -- but the lack of a good debugger emphasizes them.  GHC's operational semantics are significantly less predictable than other languages
15:08:54 <blackh> neilk_: Out of all the advantages of Haskell, referential transparency is the big one in my opinion.
15:09:12 <Peaker_> blackh: do we have to choose?
15:09:12 <Evious> Typed side effects. Oh god, being able to track side effects with types.
15:09:29 <Peaker_> Evious: thereby converting them from "side effects" to "effects" :)
15:10:52 <kmc> yeah, it's more than just tracking them
15:11:18 <kmc> we write functional programs that construct imperative programs
15:11:59 <ClaudiusMaximus> what might cause cabal not to build documentation, with a message like "haddock: failed to parse haddock prologue from file: dist/doc/html/qd/haddock-prolog32607.txt"
15:12:22 <Evious> Mm. Yeah, there is something more - I don't know the full picture.
15:12:54 <Cale> ClaudiusMaximus: Hmm, maybe version problem?
15:13:03 <Cale> (that was a shot in the dark)
15:13:05 <Evious> Sadly, this is why I don't think I can use Haskell at work: the big picture is huge, massive. Someone trying to maintain my code will look at Foo <$> a <*> b <*> c and pass out.
15:13:34 <c_wraith> Evious: the type "IO (IO Int)" is meaningful, and means something different from "IO Int".  That should be your first indication what the difference between just marking side effects and making effects truly first-class is.
15:13:35 <ClaudiusMaximus> Cale: doubt it, as cabal clean doesn't fix it (the first thing i tried..)
15:14:00 <kmc> Evious, how is that expression "big picture"?
15:14:03 <kmc> it's only got two operators in it
15:14:13 <Cale> ClaudiusMaximus: I'm using haddock 2.9.2 with cabal-install 0.8.2 and Cabal 1.8.0.6
15:14:15 <kmc> (you might prefer to write «liftA3 Foo a b c»)
15:15:03 <neilk_> Evious: I think it's a matter of familiarity. Some people still run screaming from regexes, but I happen to be great at them -- it helps that one knows it is like programming in a tiny language
15:15:22 <kmc> not that tiny, once Perl et al got their grubby mitts on it
15:15:24 <Evious> kmc, I was looking at some of my QuickCheck code today, and it's covered in applicative functors. And then I thought about explaining what the stuff does to someone else modifying the code, and kinda balked :E
15:15:25 <kmc> not even regular anymore!
15:15:57 <mauke> that's not perl's fault
15:16:00 <ClaudiusMaximus> Cale: i'm using the same versions
15:16:02 <kmc> well, if you're working in IO, (liftA3 f a b c) is very much like f(a,b,c) in most other languages
15:16:05 <mauke> regexes were irregular long before perl
15:16:25 <kmc> it executes effects associated with a, b, c, in that order, and then passes the results to f, which can also execute some effects and return a value
15:16:56 <sm> ClaudiusMaximus: you could run haddock your self on various modules and narrow it down
15:17:08 <Evious> Yeah, I can probably explain it as packing a pure function with impure, effectful ones. Giving the pure one effects. But that's a pretty huge leap to a Ruby programmer.
15:17:22 <kmc> but really, the function call doesn't execute any effects, it just returns a description of how to perform effects
15:17:29 <c_wraith> Evious: then just say "It makes the types right". :)
15:17:32 <kmc> Evious, it's a huge leap, *and* it's wrong
15:17:45 <Evious> Well there you go, I don't even know how this stuff works :p
15:17:52 <Evious> I just know the compiler yells at me if I make mistakes.
15:17:57 <kmc> there are no impure functions
15:18:06 <kmc> no impure values at all, if "impure" means that evaluation causes a side effect
15:18:31 <Cale> Evious: The right way to look at it is that a value of type IO t is a description of some (possibly effectful) stuff which could be done to produce a value of type t
15:18:35 <Peaker_> Evious: instead of executing effects you compose effects together to yield bigger and bigger effects, until you have a big effect called main
15:19:35 <Evious> So <$>, <*>, and co composes a pure function, with effects (QuickCheck's Gen a in my case) to produce a larger effect.
15:19:47 <Peaker_> I think it is also useful to view (>>=) as a "sandwich" of (effect, pure computation, effect), such that the pure computations get to "See" the effect result, and the last effect depends on the computation.  By repeatedly "sandwiching" you get a very big interlace of (effect, computation, effect, ...)
15:19:58 <kmc> Evious, yeah
15:20:01 <Peaker_> (each depending on the former)
15:20:04 <kmc> though "compose" isn't quite the right word
15:20:05 <Evious> Hell yes, a monad food analogy. :D
15:20:18 <Evious> Sandwiches?
15:20:22 <Peaker_> Heh
15:20:34 <kmc> they're called 'applicative functors' so i'd say 'apply' is a better term
15:20:35 <edwardk> great, a monad is like a dagwood.
15:20:40 <kmc> the big picture idea is that evaluation != execution
15:20:49 <Peaker_> I just mean the interlacing of  E,C,E  into  E   gives you a very long chain of E,C,E,C,E,...
15:21:02 <Peaker_> (hidden behind one E)
15:22:18 <Cale> edwardk: Well, the IO monad *specifically* is like a dagwood ;)
15:22:39 <Peaker_> I liked this explanation when wondering why (>>=) was powerful enough to allow computations and effects to be interlaced freely
15:23:02 <companion_cube> a really nice thing is the ability to pass IO a through a MVar or a Chan
15:23:07 <kmc> yes!
15:23:18 <kmc> functional imperative concurrent programming
15:23:20 <blackh> neilk_: Rebuttals of what nostrademons said: 1. Complaint is because he is not used to Haskell's method of extensibility, which is different. 3. Point-free style should only be used where it increases clarity. 4. Complaining because Haskell is different. 5. That names should be descriptive is not the only opinion.  The very short version of the counter argument is that names should be as general as the code.
15:23:24 <kmc> screw this one-paradigm bullshit
15:23:47 <ben> paradigms are expensive. jeez.
15:23:57 <kmc> companion_cube, i also like the ability to pass an (IO a) which uses a hidden Chan, hidden by closure
15:24:11 <neilk_> blackh: oh yeah, many of his arguments are really just admonitions not to make certain stylistic mistakes -- they're not fundamental issues
15:24:18 <Peaker_> kmc: that's a very common feature in today's PL's
15:24:22 <neilk_> blackh: I didn't bother raising those here
15:24:40 <kmc> you're saying that people on the internet focus on trivial syntactic / stylistic issues?
15:24:45 <kmc> i'm shocked! ;)
15:24:58 <Cale> Name length should be proportional to the size of the scope of the thing being named divided by its frequency of occurrence.
15:25:00 <companion_cube> kmc, i've found myself sending a  Blah -> IO ()  through a chan to be able to "use" a thread-local Blah in every thread
15:25:20 <companion_cube> but yeah, passing (IO a) gives you a huge power
15:25:30 <Cale> If a variable is only around for one line, it is 100% okay for it to be one letter, because its definition is on the same line as every use.
15:25:32 <companion_cube> even like spawning another thread...
15:25:32 <Peaker> Gilad Bracha's "modularity implies the ability compile a module without first compiling its dependencies and thus types are unmodular" is a wrong assumption followed by a non-sequitur too
15:25:47 <edwardk> well, if you really like the dagwood story, i suppose you could start with the free monad of a functor, then show that if that functor is actually a monad you can smash the free monad down into a single layer of the monad without ambiguity.
15:26:04 <blackh> neilk_: Another thing: Of course we want production systems to be robust.  Code correctness is a bigger factor than operational issues - at least that's what Haskell people argue.
15:26:06 <edwardk> peaker: yeah
15:26:08 <kmc> i like that i can create a Chan and then do something like «return (writeChan chan)»
15:26:18 <kmc> that way my users can send me messages but not spy on or steal my other messages
15:26:41 <kmc> in Java you can probably accomplish this with some 300-line AbstractWriteOnlyQueueTransformerFactoryManager
15:26:41 <edwardk> cale++
15:26:47 <Peaker> edwardk: Gilad Bracha was lecturing around here, and sort of considered a celeb in the geek group.. I wish I could go there, I wonder if he's open to reason :)
15:26:48 <dmwit> Cale: I'm not sure I agree.
15:27:01 <dmwit> Cale: One common style is to have some data that gets passed all around and used in every function.
15:27:08 <Peaker> kmc: In C#, Python, Ruby, Clojure, Scala, ... it's easy
15:27:24 <kmc> i agree
15:27:25 <dmwit> Cale: Are you saying that if every function is a one-liner, then it's still okay to name all that shared information "a", "b", "c", and "d"?
15:27:26 <Peaker> I don't think Haskell should take pride in the ease of doing things that are now very easy in most other languages (except Java)
15:27:42 <edwardk> peaker: well, i love one paper he wrote on mirrors for reflection to death, but he's also said some remarkably stupid things on his blog from time to time.
15:27:59 <dmwit> The conceptual scope of a variable may be much larger than its lexical scope.
15:28:41 <Peaker> edwardk: He wrote in the local group's mailing list something along "classes are the natural abstraction, arising throughout history of mankind" (as in, Javascripts prototypes and probably other ideas are "unnatural" to the human mind)
15:29:00 <kmc> haha
15:29:03 <edwardk> dmwit: depends if i have a data type, i probably want its constructors and its field accessors to be fairly verbose and obvious., but i don't want to be writing foo = State $ \the_state_no_really_i_mean_it -> …
15:29:13 <edwardk> just because i keep using \s -> (a,s)
15:29:35 <dmwit> edwardk: On the other hand, the name "s" has a strong convention around it, which makes it a better name than many other one-character names.
15:29:36 <Peaker> edwardk: how often do you manually populate State constructors? :)
15:29:47 <monochrom> considering that marx thinks that the whole history of mankind is just class struggles
15:29:50 <edwardk> peaker: sadly more than most. ;)
15:30:01 <Peaker> monochrom: haha
15:30:02 <edwardk> peaker: (blame scala's crappy type inference) ;)
15:30:08 <monochrom> an not even prototype struggles
15:30:11 <dmwit> edwardk: I'm not saying that one-character names are never appropriate. Just that the rule is not so easy to state as Cale claims. =)
15:30:46 <Evious> Ha!
15:30:47 <Cale> dmwit: If you're really passing that stuff around everywhere, you form a convention, and a short name becomes okay. I see what you mean though.
15:30:54 <edwardk> yes, but as a rule of thumb its pretty good =)
15:31:12 <dmwit> I think the rule of thumb should be that the more monomorphic your value is, the longer its name should be. =)
15:31:41 <edwardk> ah good, then i can get by with single character names nigh everywhere
15:32:08 <dolio> Define a graph to be any monad....
15:32:13 <Cale> dmwit: Note that if you're going to be passing something around all over the place, you also want its name to be short because you're going to have to type its name a lot.
15:32:20 <dmwit> Class constraints are more monomorphic than no constraints... functions are more monomorphic than type variables...
15:32:27 <edwardk> dolio: =) it worked didn't it? =)
15:32:50 <dolio> Apparently.
15:32:56 * Evious just realized that (<$>) = fmap
15:32:56 * dmwit nods at Cale
15:32:59 <dmwit> naming is hard
15:33:17 <dmwit> Maybe the hardest unsolved problem in computer science. =)
15:33:38 <edwardk> names are easy, until you need to cooperate with another person
15:33:44 <dmwit> haha
15:33:47 <kmc> Evious, yep, and also = liftM, except that some historical bullshit gets in the way
15:33:51 <dmwit> other people--
15:34:33 <Cale> Maybe when someone finds a good constructive algorithm proving that P = NP, we'll be able to write a program to solve the problem of finding good variable names.
15:34:36 <Peaker> Evious: fmap can only apply "inside" a Functor wrapper "f a".. It can alter the "a", but it cannot touch the "f".  So if you want to do something with multiple wrappers "f a" and "f b", that's when you need something that can compose "f"s.  <*> takes "f (a->b)" and "f a" and squashes the f's together into a single f with a "b" inside it
15:34:41 <Evious> Maybe the rise of the social network will help with that. Github is slowly becoming a code-centric version of Facebook: maybe it'll breed cultures of programmers who can cooperate effectively.
15:35:28 <Cale> I'm secretly hoping that P = NP, but in the surprising(?) fashion that the best possible algorithm is something like O(n^(Graham's number))
15:35:37 <kmc> i think it's easier to understand Applicative in terms of liftA2, liftA3, etc.
15:35:48 <kmc> and (<*>) as a more general operator which can be used to implement those
15:36:05 <Evious> That's loosely the way I understand it, except without ever using liftA*
15:36:11 <kmc> :t liftA2 ($)
15:36:12 <lambdabot> forall b b1 (f :: * -> *). (Applicative f) => f (b -> b1) -> f b -> f b1
15:36:22 <maurer_> :t liftA2
15:36:23 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
15:36:30 <kmc> here's another situation where preferring curried functions pays off
15:41:11 <Cale> Or even more infuriatingly, the best possible algorithm for solving NP complete problems is O(n^3), but with a constant factor something like G, making it totally impractical for any input size :)
15:42:06 <kmc> i'm hoping that P ?= NP is independent of the axioms of ZFC
15:42:29 <Peaker> I like <*> because it gets you out of the pickle after you apply (fmap binFunc) on something -- and get stuck with a partially applied: f (sndarg -> result)
15:42:36 <dmwit> That would be a whopper of an axiom.
15:42:38 <companion_cube> never mind NP, we have good sat solvers now
15:42:54 <kmc> yeah, i used Yices to get points at pub trivia the other day
15:43:10 <Peaker> If you try to think how you would attempt to use Functor to add two wrapped values, you start by fmapping (+) on one of them, and then the "obvious" extension you need to be able to apply the other wrapper is <*>
15:43:11 <edwardk> companion_cube: =) NP is the new P ;)
15:43:27 <Cale> P = NP is equivalent to Aleph_1 = c
15:43:29 <Cale> ;)
15:43:54 <companion_cube> with quantum mechanics + sat solvers, soon, NP = O(1) !
15:44:10 <adimit> that's a rumor, at best.
15:45:32 <edwardk> well, quantum computing doesn't take us much closer to NP
15:45:52 <monochrom> since not even flying cars or mars colonization has happened after 50 years of predicting them, quantum computers will not happen for another 100 years
15:46:15 <edwardk> just changes the question to P ?= QPP ?= NP
15:46:35 <Cale> Pop science is always so ridiculously enthusiastic about quantum computing, when the reality of the situation with quantum algorithms is that we don't really even know all that many ways to take advantage of quantum computers even if we could build them. Factoring integers, sure, but unless you can express your problem in terms of that...
15:47:02 <monochrom> enough to break some banks :)
15:47:03 <adimit> …, which, if you don't know if you can, you probably can't…
15:47:11 <c_wraith> to a cryptographer, all problems look like factoring integers!
15:47:34 <olsner> Cale: wikipedia says "At present, all known algorithms for NP-complete problems require time that is superpolynomial in the input size, and it is unknown whether there are any faster algorithms."
15:47:36 <Cale> Oh yeah, also, searching unsorted databases.
15:47:58 <monochrom> or let's say just get into RMS's accounts and post fake articles in his name :)
15:48:49 <Cale> (you can do that in O(n^(1/2)) time rather than O(n))
15:49:29 <c_wraith> well.  isn't the hook for quantum computing "free parallelism"?
15:49:31 <ClaudiusMaximus> fixed my cabal/haddock problem, i had a string like this which haddock didn't like:  @'RealFloat'@'s
15:49:43 <Cale> c_wraith: That's what people say, but that's not true.
15:50:06 <Cale> It's a lie which conveniently avoids explaining how qubits really work :P
15:50:29 <adimit> I'm always so annoyed when people say "all problems with the complexity of NLP algorithms will be solved when we have quantum computers. That's when we'll have machines more powerful than human brains!"
15:50:35 <kmc> it is funny that quantum computers turn out to be good at one of the few hard problems which isn't known to be NP-hard
15:50:36 <theorbtwo> To say that quantum computing is only good for factoring integers is to say that it's only useful for breaking crypto, which is to say that it's pretty fucking useful if you don't mind doing things that are probably illegal.
15:50:40 * adimit rages and gets violent.
15:51:00 <blackh> theorbtwo: Illegal things are more fun than legal ones.
15:51:10 <kmc> c_wraith, free parallelism but you can only observe the threads obliquely
15:51:14 * adimit wonders if quantum computing makes fat.
15:51:22 <adimit> *one
15:51:48 <companion_cube> with quantum computing, you can do Gödel's encoding on the fly !
15:52:03 <companion_cube> let's compact [Integer] to Integers
15:52:24 <c_wraith> kmc: so the trick is figuring out how to derive an answer from what you can actually observe?
15:52:54 <danharaj> is there a way to analyze memory use within ghci?
15:53:45 * hackagebot smallarray 0.2.2 - low-level unboxed arrays, with minimal features.  http://hackage.haskell.org/package/smallarray-0.2.2 (AntoineLatter)
15:53:52 <kmc> c_wraith, yeah
15:54:08 <adimit> ooh nice, Antoine is fixing the bug I bugged him about already.
15:54:12 * adimit is a happy camper.
15:54:24 <Peaker> what's the advantage of smallarray of UArray?
15:54:47 * hackagebot smallstring 0.3.1 - A Unicode text type, optimized for low memory overhead  http://hackage.haskell.org/package/smallstring-0.3.1 (AntoineLatter)
15:56:18 <dolio> edwardk: By the way, I figured out why foldLeft for maps requires the result type to be the same as that of the values stored in the map.
15:56:20 <adimit> Peaker: it's smaller. allegedly. You should maybe look at the type definitions, but the memory footprint, overall, should be smaller, methinsk.
16:00:48 <kmc> why's that dolio?
16:01:06 <dolio> kmc: It doesn't. Scaladoc has a variable capture bug.
16:01:26 <Peaker> why is everyone using scala? :P
16:01:35 <dolio> Money.
16:01:37 <kmc> heh
16:01:56 <kmc> Java
16:03:42 <companion_cube> scala has a smoother learning curve
16:03:53 <dolio> Heh.
16:04:05 <Peaker> it seemed awfully complex for my Haskell trained mind
16:04:20 <Peaker> the pagefuls of code implementing a "lazy const" looked awful, too
16:04:33 <kmc> everyone knows Haskell is too useless and academic
16:04:46 <kmc> so look for something similar but enterprisey
16:05:20 <Evious> Interfacing to a pile of Java libraries isn't bad.
16:05:36 <kmc> it is hard to make big improvements, in any domain, because people innately seek compromise
16:05:40 <Evious> You'll never find yourself needing to fix or implement stuff :)
16:05:55 <kmc> Evious, err, then what am i programming
16:05:58 <kmc> if not fixes or implementations
16:06:17 <Evious> I meant the "oh god, there's no functioning MongoDB driver" kind of fixing and implementing.
16:06:30 <kmc> i question the average code quality of this pile of java libs
16:07:32 <maurer_> Curiosity, how do others feel about non-monadic exceptions? Other than for debugging purposes, I _really_ hate them. If there is a failure mode your function can encounter, it should be expressed in the return type.
16:07:44 <tsuraan_> I agree
16:08:00 <ezyang> I think they're fine for impossible situations.
16:08:06 <kmc> Evious, also, Java is so pathetically non-expressive that the Java library APIs will still suck to use without extra wrapping
16:08:09 <c_wraith> well.  "impossible" situations. :)
16:08:16 <tsuraan_> I hate that they're used for so much stuff in the socket library
16:08:21 <ezyang> or "oh shit, I didn't feel like coding this special case"
16:08:40 <kmc> yeah, the real warning sign is if you want to *catch* one
16:09:00 <Evious> kmc, oh yeah. Still, I've been programming commercially in Erlang for half a year, and as nice as the OS community is sometimes I wish I had Java's libraries. It's the biggest thing I find missing.
16:09:14 <kmc> cool, how do you like Erlang?
16:09:17 <kmc> also what do you use it for?
16:09:23 <parcs> tsuraan_: you should be using network-enumerator ;)
16:09:34 <tsuraan_> yeah, I will be soon enough :)
16:09:43 <blackh> IMO there's a good reason why Scala should be used in industry: It's a bridge to functional programming.  Haskell is a chasm full of lava to functional programming. :)
16:09:54 <blackh> And I don't mean Kansas Lava.
16:09:57 <kmc> haha
16:10:18 <maurer_> ezyang: The biggest part I'm annoyed at is when I call out into, say, a file-format parser, and if the file doesn't match, it releases a wild IO error I have to catch to stop the whole place from burning down
16:10:34 <companion_cube> scala also has a nice mix of static/dynamic types for concurrency
16:10:39 <companion_cube> with actors
16:10:40 <Evious> kmc, short answer: fucking love it. Long answer: I use it for precisely the niche it occupies (massively parallel, firm real time, robust network servers capable of handling really messed up failures, and capable of hot code upgrades to boot) and manage to avoid all the things it sucks at.
16:10:59 <ezyang> It's pretty unacceptable for IO errors.
16:11:17 <Evious> It's a really fascinating take on a functional language. I really, really enjoy the way it deals with failure... And find it leaking into the Haskell code I write, with disastrous results. At least until that Cloud Haskell project really gets going :)
16:12:24 <kmc> there's a similar argument for using Java in industry
16:12:50 <Evious> Untyped exceptions are kind of nice if all your code is in actors, and you can detect and handle failure of one actor in another actor.
16:13:13 <Evious> It lets you write code for the common case, safe in the knowledge that whatever edge or corner cases occur your "error handling" code elsewhere will cope.
16:13:13 <kmc> GHC Haskell's exceptions are also untyped (if by that you mean dynamically typed)
16:13:18 <companion_cube> will cloud haskell have stuff like link() ?
16:13:31 <maurer_> The main issue here is that when I import J random nub's library, I want to be able to assert things like "his code can't take down the program, the worst it can do is lie to me"
16:13:38 <Evious> I assume so. You can implement link() via just monitor().
16:13:57 <kmc> making a development job more accessible is good for hiring managers but may not be good for the code quality or for the happiness of the people who work there
16:13:57 <blackh> Evious: Here's a question, because I've been using Scala actors.  How composable are actors?  Presumably you can't apply combinators directly to manipulate an actor - is that right?
16:14:18 <blackh> e.g. merge the output of these two actors.
16:14:24 <Evious> blackh, interesting question.
16:14:28 <companion_cube> what do you mean by "output" ?
16:14:45 <Evious> I may not be qualified to answer it, because Erlang's approach to everything is to keep things simple. Very, very simple.
16:15:02 <Peaker> maurer_: you want sandboxing at the function call level?
16:15:10 <blackh> I am thinking in FRP terms, which I don't think applies to actors, because actors choose their own recipient of output, while FRP code chooses its own input source.  i.e. reversed.
16:15:22 <Peaker> maurer_: Haskell is somewhat amenable to that -- if you limit imports.. but resource use cannot be sandboxed afaik
16:15:23 <int80_h> any yesod users here atm?
16:15:39 <Evious> Erlang actors are generally structured as "one code module defines one actor", and arranged in a fairly simple tree. So, you can compose them in pretty arbitrary structures, but to keep things manageable you keep it as simple as possible, and just have a tree with occasional messages shooting across branches.
16:15:53 <parcs> int80_h: try #yesod :)
16:16:02 <int80_h> parcs: They're all afk :)
16:16:14 <parcs> ah, then ask the question here and hope for the best
16:16:16 <Evious> So if by "compose" you mean the kind of craziness monadic parsers get up to, that never happens in Erlang. Things are kept simple at all costs.
16:16:27 <int80_h> parcs: will do
16:16:34 <Evious> (Which, since asynchronous message passing is a complete nightmare to reason about, may be just fine.)
16:17:33 <blackh> Evious: Thanks - that answers my question.  I can highly recommend looking at FRP - though it's a little difficult to get into since everyone has a different idea of what FRP is.
16:17:45 <blackh> FRP is not suitable for distributed processing, though.
16:17:55 <Evious> I've tried to get into it in the past, and found no production-capable libraries.
16:17:55 <Peaker> blackh: why not?
16:18:00 <Evious> Maybe that's changed in the past year or two.
16:18:17 <maurer_> Peaker: Not really sandboxed, I just want to be able to asser thing slike "You know those holes we poke in our pure sandbox, where we can throw exceptions, and do IO and stuff? Yeah, don't allow those
16:18:38 <Peaker> maurer_: what about use of lots of memory or cpu power, killing the host?
16:18:40 <int80_h> http://hpaste.org/47540/problem_with_radiofield
16:18:52 <blackh> Peaker: Because its "component size" is too fine-grained, and state is not neatly encapsulated inside containers (actors).  i.e. the cost model of actors fits distributed processing perfectly and not so for FRP.
16:19:42 <Peaker> blackh: Too fine-grained doesn't sound like a problem, just distribute according to whatever division you'd like with whatever granularity...  State seems very neatly encapsulated behind time-varying values
16:19:44 <Evious> blackh, if you go looking for details on how Erlang composes actors, look into "OTP Design Principles"/supervision trees. The OTP process structure is designed to compose actors in a way that produces really, really robust software. It's fairly limited and simple, but produces very stable code.
16:20:36 <maurer_> Peaker: While that would be awkward, it is a problem that I don't feel can be easily solved without crippling libraries
16:20:45 <blackh> Evious: There aren't any, except possibly Scala.React.  There will be soon, though.  The reason why I mention it is that it deals rather well with the whole reasoning-about-asynchronous-events thing.
16:20:47 <maurer_> Peaker: Exceptions can be thrown out of pure functions without crippling libraries
16:20:57 <maurer_> Peaker: (as can _most_ IO holes)
16:20:59 <blackh> Peaker: Then FRP needs you!
16:21:32 <Evious> What's the difference/relation between FRP and iteratees/enumerators/enumeratees?
16:21:51 <Evious> Iteranumeratortees?
16:22:01 <Evious> Man, that's a naming scheme with endless possibilities :D
16:22:12 <blackh> Evious: I don't know - but there must be some overlap, since they both model streams of asynchronous events.
16:22:12 <c_wraith> They're almost entirely unreleated :)
16:22:21 <c_wraith> *unrelated
16:22:46 <kmc> there probably is some deep connection that nobody is aware of yet
16:22:55 <blackh> I would say there is.
16:23:29 <c_wraith> I don't know.  I feel like asynchronous is a key part of FRP, but only an incidental detail of some cases for iteratees
16:24:17 <conal> FRP has an implementation-independent semantics. i don't think iteratees etc do.
16:24:56 <Peaker> maurer_: I agree totality would be nice
16:25:39 <Peaker> maurer_: and it would be nice to have sandboxing in the sense of no ambient authority -- even in IO, pass all authority as an argument, always (i.e: sandboxed things cannot call "open", but they can take an open file handle)
16:26:53 <Peaker> conal: Iteratees have operational semantics, don't they?  Basically specification of which order IO actions will be bound
16:27:20 <maurer_> Peaker: That is very different from what I am asking for.
16:27:40 <maurer_> I am just asking for a mode of pure type signatures that doesn't have holes poked in it.
16:27:54 <Peaker> conal: I think they're very useful because we want the bottom "ugly" part (IO) to meet via implementation layers with the upper "nice" parts (denotational) -- and I think that doing this is easier by building nicer operational semantics on top of the bottom, too
16:27:56 <conal> Peaker: s/semantics/denotation/ (in my previous remark)
16:28:20 <Evious> maurer_, that won't guarantee much though. You've still got the halting problem, and non-total functions.
16:28:35 <Peaker> conal: I mean, IO has no denotation too, but iteratees are much nicer to work with than IO in many senses -- so can aid an "ugly" library implementing a nice denotation
16:28:38 <conal> Peaker: have you heard of anyone giving even an *operational* semantics for iteratees that isn't just an implementation?
16:28:43 <kmc> you can have (conservative) effect-typing for non-termination
16:29:05 <conal> Peaker: perhaps so. hasn't been demonstrated, afaik.
16:29:15 <Peaker> conal: no, but it sounds like it should be a reasonable task for the core combinators at least
16:29:34 <kmc> it's possible to rewrite any terminating function to a form where it's easy for the machine to prove termination
16:30:00 <Peaker> conal: also, even while chasing denotational wonders, one can toy with denotation-less fun like iteratees to see machines doing cool things :)
16:30:03 <kmc> (assuming a sufficiently powerful language"
16:30:22 <monochrom> consider using "trace semantics" for denotational semantics for interactions, i.e., a set of histories of messages sent/received. for example people do this for CSP
16:30:24 <Peaker> (eventually machines will probably be able to do cool things via denotational programming, but as long as many problems are unsolved..)
16:30:34 <maurer_> Peaker: So, I'm willing to have a pure function potentially never terminate.
16:30:54 <Peaker> maurer_: so it's just pure exceptions you don't want?
16:30:55 <conal> Peaker: sure. i see a role for iteratees in imperative/nondenotative programming.
16:30:57 <maurer_> Peaker: I'm not willing for it to issue side effects, or to throw exceptions
16:31:21 <Peaker> maurer_: non-termination is sometimes considered a side-effect
16:31:41 <maurer_> Peaker: I'm not considering it as one, because that's not a solveable problem without very weak languages.
16:32:35 <kmc> or strong languages which require some extra effort from the programmer
16:32:58 <kmc> if you can prove the function terminates, you can prove it to the machine
16:33:16 <Peaker> maurer_: Apparently "very weak languages" manage to solve problems thrown at them.. TC may be overrated
16:33:20 <maurer_> kmc: While true, there are some things you don't actually want to terminate, especially in haskell land
16:33:38 <Peaker> maurer_: don't you want them to be productive?
16:33:45 <maurer_> Peaker: Yes, but that change requires a modification to the compute model. You are trying to add features, I'm trying to remove them :P
16:34:02 <monochrom> (joke: strong language has never required extra effort from the programmer. look at the leaked windows kernel source code for example. programmers are more than glad to "f**k" "s**t" --- strong language there :) )
16:34:12 <Peaker> maurer_: Replacing general recursion with other forms of recursion is both removing and adding
16:34:12 <Draconx|Laptop> Peaker, unfortunately, "very weak languages" are generally incapable of describing their own interpreter.
16:34:55 <adimit> where "very weak" is a misleading notion. Brainfuck is potent as shit.
16:35:09 <Peaker> Draconx|Laptop: Yeah, or interpreting stronger languages... But is this a problem in practice?
16:35:41 <Peaker> Draconx|Laptop: Such languages can have a "Partiality" monad for such cases?
16:35:45 <monochrom> since every program tries to include a lisp implementation, yes :)
16:35:52 <Draconx|Laptop> Peaker, well, it's often hard to run a program without an interpreter for it.
16:36:04 <argiopeweb> monochrom: You're misquoting.
16:36:06 <Peaker> Draconx|Laptop: you can write the interpreter in the non-terminating subset
16:37:19 <Draconx|Laptop> Peaker, sure, but then you probably have turing completeness.
16:37:38 <Draconx|Laptop> Peaker, which, according to you, "may be overrated".
16:37:47 <Peaker> Draconx|Laptop: Yeah, sure, but you still have the subset you can use when not writing interpreters :)
16:38:08 <Peaker> Draconx|Laptop: It being useful/necessary sometimes does not mean it isn't overrated
16:38:20 <monochrom> I think having two subsets works out in practice.
16:39:09 <monochrom> Observe that even here we have a no-unsafePerformIO subset and a yes-unsafePerformIO subset
16:39:19 <dmwit> I bet I can design a non-TC language that can interpret itself.
16:39:31 <dmwit> I'll call it... hmmm... let's say, HQ9X+
16:39:32 <Draconx|Laptop> dmwit, I bet that you can, too.
16:39:43 <Peaker> the "hello" language that has just 1 valid program, "hello", which prints "hello"
16:39:56 <Peaker> It is also a perfectly valid interpreter for "hello" programs
16:40:32 <monochrom> when people here look at "fst :: (a,b) -> a" they don't say "oh maybe it uses unsafePerformIO so no free theorems don't apply"
16:41:45 <Peaker> @free fst :: (a,b)->a
16:41:45 <lambdabot> f . fst = fst . $map_Pair f g
16:43:16 <Draconx|Laptop> monochrom, I thought that seq basically invalidates most free theorems anyway?
16:43:33 <monochrom> oh ha
16:43:44 <maurer_> Draconx|Laptop: seq can only do that with the help of exceptions or unsafeperformio
16:43:50 <Draconx|Laptop> maurer_, or non-termination.
16:44:07 <maurer_> Draconx|Laptop: True. I don't really usually bother trying to enforce termination from the language though
16:44:36 <Draconx|Laptop> maurer_, the point is that, due to seq, applying a free theorem can turn a terminating program into a non-terminating one.
16:44:45 <maurer_> Draconx|Laptop: Sure.
16:45:39 <Peaker> so they'd still be true up to refine-ness, which is still useful?
16:45:49 <Peaker> (if the value is defined, it will have this value)
16:45:59 <monochrom> yeah
16:46:18 <adimit> oh shit. So, a haskell program segfaults. what's next (i.e. how do I find the offending code, what are my debugging possibilities?)
16:46:35 <adimit> (i'm assuming a bug in ghc, and/or any of my libraries. The program is trivial.)
16:46:39 <kmc> it's compiled with GHC?
16:46:58 <kmc> boil it down to a minimal test case, then look at the GHC trac for similar-looking open bugs
16:47:01 <kmc> what libraries are you using?
16:47:04 <kmc> can i see the code?
16:47:20 <adimit> kmc: iteratee. It seems to be a problem with iteratee's mapReduce.
16:47:34 <adimit> kmc: a sec, I'll try to boil it down to a simple test case first.
16:47:34 <kmc> oh dear
16:49:06 <adimit> … this seems to be a very fragile bug… might take me a couple of minutes to isolate.
16:50:16 <adimit> erhm. I doubt this is a problem with iteratee.
16:50:34 <adimit> O_o I have never seen such weirdness.
16:51:59 <adimit> It seems to be connected to compiling with profiling options (-prof -auto-all -rtsopts)
16:57:57 <adimit> Here's an absolutely not minimal code example, but I wanna go to bed soon, so I'll not yet boil it down: http://hpaste.org/47541/segfault
16:58:29 <adimit> I'll try to provide more info, and maybe a post to the ghc bugtracker or haskell-cafe tomorrow.
16:59:22 <adimit> oh, the funnies. It seems to also depend on the input file >.<
16:59:57 <adimit> and not on the profiling options, as I reproduced the result without profiling.
17:02:05 <adimit> gotcha. It's smallstrig (methinks.)
17:10:13 <int80_h> hmm, solved my own problem. It was indentation the whole time!
17:22:23 <SpiceMan> uhm. what's /= ?
17:22:38 <maurer_> SpiceMan: Not equal
17:22:46 <SpiceMan> oh. thanks.
17:23:14 <maurer_> It's supposed to be a look-alike to ≠
17:24:06 <monochrom> similarly, \ is ascii-art for λ
17:24:31 <parcs> i think =/= is better than /=
17:24:47 * maurer_ should get a keypad with unicode λ ≠, arrows, etc and abuse the hell out of syntax overloading
17:24:51 <Evious> That's a 50% increase in keystrokes, though.
17:25:03 <Evious> Resulting in a 33% drop in productivity.
17:25:25 <geheimdienst> maurer_: there's a package that does that for you :) ... unicode-operators or somesuch
17:25:34 <SpiceMan> text-to-speech is a sharp drop of keystrokes *and* productivity :p
17:25:36 <parcs> base-unicode-symbols :)
17:25:43 <kmc> you still can't use λ for lambda, can you?
17:25:52 <kmc> it's an identifier since it's a lower-case letter
17:25:54 <maurer_> geheimdienst: I'd still need a special keypad
17:25:56 <argiopeweb> geheimdienst: Causes alignment issues in non-enabled editors though.
17:25:56 <geheimdienst> i guess not, it's not an operator
17:26:06 <geheimdienst> kmc ^^
17:27:44 <geheimdienst> oh, there's also a language extension for "->", "forall", "=>" and a few other things http://www.haskell.org/ghc/docs/7.0-latest/html/users_guide/syntax-extns.html#unicode-syntax
17:27:50 <geheimdienst> still no lambda
17:27:51 <parcs> argiopeweb: i like the fact that i can vertically align ∷ and = with UnicodeSymbols
17:28:16 <parcs> argiopeweb: oops, errorneously directed that to you
17:28:27 <monochrom> the theorem prover HOL4 makes a special case for λ to allow it to stand for \ while other greek letters are identifiers
17:28:59 <blackdog> could someone shed some light on the difference between Repa and Accelerate?
17:30:14 <geheimdienst> maurer_: about needing a special keypad, i think people would just use compose sequences. i use them all the time for stuff that's not on my keyboard (á ø « ...)
17:30:15 <int80_h> if I have "let foo = 100", how can I tell the compiler that foo is an Int?
17:30:31 <maurer_> geheimdienst: If I were using compose sequences, I'd just stop bothering and use normal keys
17:30:35 <argiopeweb> parcs: No problem.
17:30:38 <parcs> int80_h: 100 :: Int
17:30:46 <geheimdienst> > let foo = 100 :: Int
17:30:47 <lambdabot>   not an expression: `let foo = 100 :: Int'
17:30:50 <maurer_> geheimdienst: /= is faster than a compose sequence for ≠
17:30:54 <kmc> let foo :: Int; foo = 100
17:30:54 <geheimdienst> > let foo = 100 :: Int in 1
17:30:55 <monochrom> let { foo :: Int; foo = 100 }  or multi-line layout
17:30:55 <lambdabot>   1
17:31:11 <kmc> int80_h, or you just use it elsewhere in a way that forces the type to Int
17:31:22 <geheimdienst> maurer_: yeah, one key faster :) that's true
17:31:44 <geheimdienst> > let foo :: Int = 100 in 1
17:31:45 <lambdabot>   1
17:31:58 <kmc> that... works?
17:32:06 <kmc> that's an extension, PatternSignatures or whatever
17:32:06 <geheimdienst> yo, that's allowed with some language extension
17:32:32 <monochrom> lambdabot is an extension whore
17:32:36 <int80_h> could someone tell me which extension exatcly?
17:32:45 <int80_h> I luv me some extensions.
17:32:57 <int80_h> by extension, I luv lambabot.
17:33:05 <parcs> int80_h: extension for what?
17:33:17 <int80_h> parcs:  > let foo :: Int = 100 in 1
17:33:51 <monochrom> file:///usr/local/haskell-platform-2011.2.0.1/share/doc/ghc/html/libraries/Cabal-1.10.1.0/Language-Haskell-Extension.html has a list of all extension names
17:34:01 <int80_h> ah
17:34:07 <parcs> @type do { x :: Int <- return 5; return (x + 1 }
17:34:08 <lambdabot> parse error on input `}'
17:34:23 <int80_h> you accidently a )
17:34:23 <parcs> ^ that's be nice to have..
17:34:27 <parcs> oh
17:34:29 <parcs> @type do { x :: Int <- return 5; return (x + 1) }
17:34:31 <lambdabot> forall (m :: * -> *). (Monad m) => m Int
17:34:32 <parcs> :O
17:37:03 <parcs> what's the name of that extension?
17:38:29 <monochrom> "PatternSignatures   Deprecated, use ScopedTypeVariables instead."
17:39:11 <geheimdienst> yeah, i think ScopedTypeVariables was the name
17:41:11 <Peaker> I don't understand why pattern signatures is part of scoped type variables, what's the relation?
17:41:49 <monochrom> I don't know either. it's one of the most mysterious mergers in history
17:42:18 <geheimdienst> while we're at it, is there some index or summary of all language extensions?
17:42:41 <kmc> the manual
17:42:43 <kmc> GHC manual
17:42:44 <monochrom> file:///usr/local/haskell-platform-2011.2.0.1/share/doc/ghc/html/libraries/Cabal-1.10.1.0/Language-Haskell-Extension.html
17:42:52 <kmc> http://hackage.haskell.org/packages/archive/Cabal/1.10.1.0/doc/html/Language-Haskell-Extension.html
17:42:57 <geheimdienst> i find the chapters in the ghc users guide very complete, but finding any particular extension (that you don't quite remember by name) always takes time
17:43:11 <holmak> What is the best JSON package out there? aeson?
17:43:26 <geheimdienst> monochrom: link doesn't work, plz make your harddrive accessible
17:43:43 <monochrom> if you install ghc, you have that page somewhere on your disk too
17:43:59 <monochrom> can you access your disk?
17:44:16 <Peaker> a recent blog post had a nice diagram of ghc extensions
17:45:02 <holmak> geheimdienst: Try this, if you are running in hard-drive-free mode: http://hackage.haskell.org/packages/archive/Cabal/1.10.1.0/doc/html/Language-Haskell-Extension.html
17:45:06 <geheimdienst> monochrom: j/k. it's just that it's ~/.cabal/share/doc/... for me, and maybe the Cabal version is a little off
17:46:09 <geheimdienst> kmc, holmak: thanks, that's what i meant. if it had actual links into the users guide, and maybe examples, it'd be unimprovably perfect
17:46:10 <Saizan> ghc --supported-languages , also
17:46:16 <byorgey> Peaker: one of the main reasons for pattern signatures is to bring some type variables into scope.
17:47:21 <holmak> Ah, kmc beat me to it. Eyeball failure!
17:49:03 <geheimdienst> any theories why the source code comments use «&#xa7;» instead of «§»? http://hackage.haskell.org/packages/archive/Cabal/1.10.1.0/doc/html/src/Language-Haskell-Extension.html#Extension
17:49:23 <kmc> i wrote that
17:49:25 <kmc> but i don't remember
17:49:32 <geheimdienst> :D
17:49:35 <argiopeweb> :\
17:49:44 <monochrom> for fear of non-utf8 software
17:49:50 <kmc> i think i wasn't on my Compose key kick yet
17:49:54 <geheimdienst> > ord '§'
17:49:55 <lambdabot>   167
17:49:56 <monochrom> for example, old ghc and old haddock
17:49:57 <kmc> §§§§§
17:51:03 <argiopeweb> I'm ashamed to say I don't even know what the default compose key on XWindows is. :\
17:51:05 <monochrom> it may still be a good idea for another 20 years
17:51:23 <argiopeweb> X11, even.
17:51:30 <argiopeweb> It must be bed time again.
17:51:57 <geheimdienst> argiopeweb: just configure it to some useless key. menu or capslock or something
17:52:24 <argiopeweb> geheimdienst: I'll probably get around to it eventually...
17:52:25 <monochrom> I map it to a windows key
17:53:14 <monochrom> maybe I should map it to the menu key
17:53:17 <parcs> i map it to ralt
17:54:10 <argiopeweb> I use right alt when I"m doing 1-handed stuff (laptop)
17:54:20 <argiopeweb> Menu key is free though.
17:56:26 <monochrom> I have been using the menu key for virtualbox's escape key
17:57:16 <monochrom> but recent versions of virtualbox allow key combo (e.g., ctrl-menu) so I may change it and free up menu for compose
18:06:04 <Iso> Hello there.
18:06:14 <argiopeweb> Good evening.
18:06:26 <Iso> Thanks :)
18:06:58 <argiopeweb> What's up?
18:07:08 <Iso> I’m new to this Haskell world, so the answer to this question might look a bit newbish, but i’m stuck with cabal when trying to install the shpider package.
18:07:23 <Iso> I’ll paste you the trace in a few seconds.
18:07:44 <blackdog> ouch: https://gist.github.com/1011504
18:07:51 <argiopeweb> HPaste.org, if you would.
18:08:00 <blackdog> floor of NaN just picks a number out of the air?
18:08:00 <byorgey> Iso: no question is too newbish for this channel =)
18:08:26 <Iso> Haha, thank you : d
18:08:36 <Iso> I just configured my XMonad btw.
18:08:46 <argiopeweb> Good stuff.
18:08:51 <blackdog> Iso:  it's the gateway drug
18:09:00 <argiopeweb> blackdog: That's an understatement.
18:09:07 <byorgey> Iso: nice =)
18:09:25 <blackdog> argiopeweb: what, xmonad, or that floor is a magician?
18:09:48 <argiopeweb> Probably D, all of the above, but I was thinking of XMonad.
18:09:52 <parcs> > floor (0/0)
18:09:53 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
18:10:01 <parcs> neato
18:10:19 <argiopeweb> Seems broken.
18:10:29 <parcs> > ceil (0/0)
18:10:30 <lambdabot>   Not in scope: `ceil'
18:10:34 <parcs> > ceiling (0/0)
18:10:35 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
18:11:14 <parcs> > ceiling (0/0) `logBase` 10
18:11:15 <lambdabot>   Ambiguous type variable `b' in the constraints:
18:11:15 <lambdabot>    `GHC.Real.Integral b'
18:11:15 <lambdabot>   ...
18:12:21 <Iso> Here you go: http://hpaste.org/47546/shpider_install_fail
18:14:10 <parcs> > ((,) <*> negate (fromIntegral (floor (0/0)))) (`logBase` (10 :: CReal)) (0/0)
18:14:11 <lambdabot>   Couldn't match expected type `t1 -> t'
18:14:11 <lambdabot>         against inferred type `(a, a...
18:15:23 <argiopeweb> Iso: That's an odd one.
18:16:11 <Iso> :]
18:17:36 <Iso> I’m running Arch Linux, with GHC 7.0.2 and Cabal 0.10.2
18:18:04 * aavogt has seen that building hinotify
18:18:09 <argiopeweb> And I'm guessing you have libcurl and libcurl-devel installed?
18:18:29 <argiopeweb> aavogt: What fixed it?
18:18:43 <aavogt> I didn't find anything
18:18:48 <argiopeweb> :\
18:19:41 <aavogt> but this "#include" no longer works might be worth looking into
18:20:02 <Iso> argiopeweb, I don’t know, lookin’
18:20:24 <argiopeweb> You know, I've seen that one before too...
18:20:28 <argiopeweb> I can't remember where though.
18:20:58 <Iso> There’s no “libcurl” nor “libcurl-devel” package on Arch. Just diggin’ deeper.
18:21:33 <argiopeweb> https://bugs.launchpad.net/ubuntu/+source/haskell-curl/+bug/771067
18:21:42 <argiopeweb> Nothing there as of yet, but that's the bug you're looking for.
18:21:56 <Iso> Looks like libcurl and curl are bundled together, so yes, libcurl is installed.
18:22:03 <argiopeweb> Based on the fact that Hackage says it builds, I'm guessing some manner of regression in libcurl.
18:23:14 <argiopeweb> Try just running "cabal install curl". I just did it on my machine with Curl 7.21.3 x86_64 and haskell curl-1.3.7
18:23:41 <Iso> That’s what I just deed, I’ll give shpider another try :)
18:23:44 <argiopeweb> hehe
18:24:04 <Iso> Same errors :(
18:24:09 <argiopeweb> :\
18:24:16 <argiopeweb> What does curl--version say?
18:24:34 <Iso> Oh, just remembered.
18:24:52 <Iso> Shpider comes with a modified version of curl. This may be the point.
18:24:58 <argiopeweb> :\
18:25:35 <Iso> From the package description: “Shpider contains a patched version of the curl package ( the original package's garbage-collection caused non-deterministic behaviour ).”
18:26:04 <argiopeweb> I didn't even know curl was garbage collected...
18:26:39 <argiopeweb> s/garbage collected/written in a garbage-collected language/
18:26:50 <Iso> Anyway, isn’t there another lib for web crawling ?
18:27:06 <Iso> I was looking for a python’s Mechanize alter ego.
18:27:08 <geheimdienst> what is curl written in?
18:27:14 <Iso> C, I guess.
18:27:34 <Iso> Yep, says Wikipedia.
18:28:20 <argiopeweb> Don't we generally refer to C's "garbage collection" as memory management? :P
18:29:08 <argiopeweb> I don't even refer to C++'s shared_ptr (and kin) as garbage collection. That's "Automatic memory management".
18:29:17 <blackdog> ah, i am in a state of sin:) my original floating point algorithm for taking integer logs is unstable
18:29:23 <argiopeweb> though I have been told I'm odd.
18:29:47 <argiopeweb> blackdog: Unstable?
18:30:03 <blackdog> my implementation called floor on the result of logbase a b
18:30:07 <blackdog> logBase, should i say
18:30:27 <blackdog> which gets it wrong on logBase 11 19487171
18:31:22 <blackdog> a sneaky bug - didn't catch it in 100 000 quickcheck tests
18:31:23 <geheimdienst> iso: from https://github.com/ozataman/shpider i gather that shpider recently moved away from its custom curl and is now using the standard one
18:31:35 <blackdog> i suppose i should probably restrict the base to be small
18:31:48 <argiopeweb> And here I thought I needed to do penance for punching holes in plastic with a soldering iron...
18:32:02 <argiopeweb> Still 100k qc tests is impressive.
18:32:23 <blackdog> basically, it's only going to be wrong when it's an exact integer match
18:32:24 <Iso> How nice :) thank you geheimdienst, I’ll try it immediately.
18:32:51 <blackdog> but i should use the integer version anyway, the float version is hellaciously slow
18:33:00 <blackdog> was my reference version. cue hilarity.
18:35:00 <Iso> This one worked like a charm geheimdienst, thanks a lot :)
18:35:26 <Iso> Well, I guess the hackage.haskell.org page should be updated as well : d
18:37:18 <geheimdienst> iso: you're right. the newest shpider version on hackage is from november :-/ that's unfortunate
18:37:56 <aavogt> Iso: this makes it work too http://hpaste.org/47548/shpider
18:39:12 <Iso> Thank you aavogt, but I installed the git version already :(
18:39:30 <aavogt> so this also fixes my hinotify issue tentatively
18:39:53 <Iso> Anyway, if you want to take a look on my XMonad conf, check out http://code.krml.fr/desktop (including screenshots as well) :)
18:40:44 <geheimdienst> aavogt: what's the connection between curl and hinotify?
18:41:32 <aavogt> geheimdienst: -fvia-C
18:41:32 <geheimdienst> ... oh you mean just replacing "OPTIONS #include" with "LANGUAGE ForeignFunctionInterface"
18:45:02 <aavogt> getting rid of the OPTIONS -#include  and the -fvia-C
18:45:36 <aavogt> preflex: seen kolmodin
18:45:36 <preflex>  kolmodin was last seen on #haskell 51 days, 16 hours, 39 minutes and 43 seconds ago, saying: :)
18:52:18 <gienah> aavogt: kolmodin hangs out in #gentoo-haskell
18:53:54 <luite> of course that's not terribly limited because you could generate a haskell interpreter, in theory :)
18:53:58 <luite> err oops
18:57:30 <dankna> @hoogle foldM
18:57:30 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
18:57:31 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
18:57:31 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
19:18:14 * hackagebot persistent-equivalence 0.1.1 - Persistent equivalence relations (aka union-find)  http://hackage.haskell.org/package/persistent-equivalence-0.1.1 (ChrisSmith)
19:18:28 <Iso> Hmm, unfortunately Shpider looks unfinished and is poorly documented; do you have another package doing the same job (Web crawling, like perl’s WWW::Mechanize lib)?
19:18:39 <holmak> Does anyone know how long GHC takes to build? Do I need to write my VM into my will?
19:20:28 <cmccann> holmak, probably a finite amount of time
19:20:53 <holmak> cmccann, Thanks for putting a bound on that :p
19:20:59 <erikde> holmak: completely machine dependant. in my 2.8Ghz Core2 its a bit less than an hour.
19:21:21 <blackdog> erikde: here's the problem i was talking about
19:21:21 <blackdog> https://github.com/mwotton/codejam_c_fast
19:21:36 <cmccann> the one time I built GHC from source I think it took around 90min or so
19:21:50 <blackdog> ended up not needing Repa - you get handed 1000 entries straight up, so it's just as easy to parallelise over that
19:22:06 <blackdog> but that one runs in under a second on my machine:)
19:26:19 <blackdog> Iso: as far as i know, it's a bit of a gap in haskell's libraries
19:26:43 <blackdog> there are lots of very fast web interaction libs, but they're a bit clumsy to actually use - there's nothing as smooth as httparty, restclient or mechanize.
19:27:00 <blackdog> i would very much like one to exist and it's on my #projectaweek list
19:37:15 <kniu> Galois internship, eh?
19:39:25 <ymasory> anyone have a copy of the cormen algorithms book, third edition?
19:39:30 <ymasory> handy
19:41:38 <Iso> blackdog, thank you :)
19:41:52 <acfoltzer> kniu: ?
19:41:59 <acfoltzer> I just started mine today
19:42:11 <kniu> Referring to this: http://corp.galois.com/blog/2011/6/6/announcing-internship-available-at-galois-inc.html
19:42:19 <kniu> I'm at an internship too.
19:42:25 <acfoltzer> ah
19:42:36 <acfoltzer> yes, I heard about this one.
19:42:37 <kniu> Fall seems like a weird time.
19:43:13 <acfoltzer> it's a lot more systems/imperative-focused than I'd have expected from Galois
19:43:25 <acfoltzer> but sounds pretty interesting
19:44:28 <kniu> Indeed, though
19:44:53 <kniu> what kind of "security" concerns do they have in mind specifically for vehicles?
19:47:29 <Iso> Good night everyone :)
19:47:41 <dankna> well, I can think of plenty of vulnerabilities that vehicles running semi-autonomously would have
19:48:00 <dankna> "I swear, officer, I didn't mean to run down that group of nuns, my car seemed to have a mind of its own!"
19:48:10 <kniu> specifically vehicles and not other safety-critical embedded applications?
19:48:26 <dankna> yes - with a pacemaker, the worst-case scenario is simply that the owner dies
19:48:33 <dankna> with a car, the worst-case is considerably worse than that
19:48:52 <kniu> YOU FUNNY MAN, DANKNA
19:48:57 <kniu> I KILL YOU LAST
19:48:58 <blackdog> and the standards are much more stringent. if an idiot crashes a ford, they don't try to take all the fords off the road.
19:49:01 <dankna> I wasn't really trying to joke
19:49:06 <dankna> yeah, what blackdog just said
19:49:27 <blackdog> but you could save a million lives and lose one, and still get banned
19:49:30 <cmccann> vehicles would seem to be a fairly significant combination of high risk, large number of targets, and general lack of oversight in day to day use
19:49:44 <liyang> What if it's a pacemaker in someone who happened to be driving at the time?
19:49:50 <dankna> and also, the other thing is that they are presumably working with vehicles, and not with other safety-critical embedded systems :)
19:49:59 <dankna> liyang: well, there's that, haha
19:50:44 <acfoltzer> indeed, some fly: http://corp.galois.com/blog/2010/9/22/copilot-a-dsl-for-monitoring-embedded-systems.html
19:51:42 <dankna> cool.
20:15:03 <holmak> Is there a recommended way to bundle programs (built with Cabal) with files they depend on, for distribution?
20:16:14 <ivanm> holmak: which OS?
20:17:07 <holmak> I suppose there's no cross-platform solution. In my case, Windows and Ubuntu
20:21:10 <ivanm> holmak: I believe there are tools to create apt packages
20:21:27 <ivanm> and also a utility to help generate windows installers
20:21:50 <holmak> Sure, I've done both of those. I was wondering if there was something that went along nicely with Cabal.
20:22:09 <ivanm> uhhh.... Cabal is just a build library
20:22:25 <kniu> Put the files in your tarball.
20:22:29 <dibblego> cabal sdist
20:24:08 <blackdog> ivanm: what's your point? obviously it makes sense to use the information in the .cabal file to seed a binary package
20:24:19 <holmak> Ok, thanks for the info.
20:24:30 <ivanm> blackdog: right, but it seems he wants some automagic way of using Cabal (possibly conflating it with cabal-install)
20:25:10 <ivanm> what would be the best way of checking that a provided Text value isn't (case-insensitively) identical to one of a list of provided values?
20:25:27 <ivanm> pattern-matching? or using a Set?
20:25:58 <dankna> ahhhh.... calling ObjC -> Haskell -> ObjC loses thread-local data such as the current run loop!
20:26:04 <dankna> wonder how I can fix that ><
20:26:17 <blackdog> ivanm: "go along nicely" suggests that you can get the info out programmatically to me, not that cabal should actually know the details of forty different package standards
20:26:41 <ivanm> blackdog: he wanted something cross-platform; that's how I interpreted it *shrug*
20:27:40 <holmak> Specifically, my cabal-built exe depends on other files, which are not dropped in the cabal bin directory. So, the program only runs from within its own repo.
20:28:08 <holmak> It seemed to me like distributing programs with their resource files might be a problem other people have had...
20:28:27 <ivanm> holmak: are the resource files listed in the .cabal file?
20:28:29 <dankna> holmak: is there a reason you're not using Cabal's data-files:
20:28:37 <ivanm> if so, then they should also get installed
20:29:22 <holmak> Aha! That looks like what I wanted.
20:30:04 <sm> holmak: I had that problem, and data-files was not a solution because not everyone installs via cabal
20:30:14 <sm> I used the nice file-embed package
20:30:27 <ivanm> sm: ummm... runhaskell Setup.hs install will also install it
20:30:42 <sm> definitely not everyone uses that
20:30:52 <sm> say you want to ship a binary
20:31:09 <ivanm> sm: that then becomes a OS-specific installation problem
20:31:16 <dankna> realistically, you only want to ship a binary on Win or Mac
20:32:44 <sm> well, file-embed solved this for me in a platform-independent and installer-independent way
20:32:59 <sm> YMMV!
21:39:08 <ivanm> preflex: seen chrisdone
21:39:09 <preflex>  chrisdone was last seen on #haskell 1 day, 18 hours, 20 minutes and 57 seconds ago, saying: What's the function equivalent of [a,b…n]?
21:40:19 <luite> enumFromThenTo
21:40:42 <ddarius> @pl [a,b .. n]
21:40:43 <lambdabot> [a,b..n]
21:41:31 <ivanm> luite: I think it's a bit late ;-)
21:42:01 <luite> hehe I was just being useless, as usual :p
21:50:28 <holmak> historical re-enactment?
22:19:58 <fragamus> caball install random-fu    <----- no workie
22:20:08 <fragamus> cabal even
22:21:19 <ivanm> fragamus: well, an error message would help... :p
22:21:35 <fragamus> "no workie"
22:21:51 <ivanm> it actually just spits out "no workie" ?
22:21:58 <fragamus> try it
22:22:30 <ivanm> or you could just paste the error message
22:22:45 <ivanm> e.g. I may not have haskell on this machine...
22:22:47 <fragamus> src/Data/Random/Source/StdGen.hs:132:29:
22:22:48 <fragamus>     Couldn't match type `a0' with `b'
22:22:48 <fragamus>       because type variable `b' would escape its scope
22:23:17 <ivanm> fragamus: ghc 7 ?
22:24:52 <fragamus> The Glorious Glasgow Haskell Compilation System, version 7.0.3
22:25:17 <ivanm> yup; sounds like the removal of let generalisation or something
22:25:34 <ivanm> so even if I _did_ try it, I probably wouldn't have that error (since I still use 6.12.3)
22:25:51 <SpiceMan> cabal installing stuff... installs some sort of man pages or docs?
22:26:14 <SpiceMan> I successfuly installed random-fu and I don't know what that is haha
22:26:38 <ivanm> SpiceMan: helps generate numbers or something
22:26:52 <fragamus> ok ima install 6.12.3
22:26:57 <ivanm> SpiceMan: there will probably be docs in ~/.cabal/share/doc/index.html
22:27:00 * SpiceMan was expecting something like perl's perldoc
22:27:11 <ivanm> fragamus: do you really need random-fu?
22:27:12 <SpiceMan> ivanm: oh. ok.
22:27:23 <fragamus> yah
22:27:31 <ivanm> what for?
22:27:53 <fragamus> normal distribution monad style
22:28:11 <ivanm> yeah, it's a ghc-7-only build problem (looking at the hackage page)
22:28:24 <ivanm> yeah, it's a ghc-7-only build problem (looking at the hackage page)
22:28:32 <ivanm> gah, stupid xchat
22:28:41 <ivanm> fragamus: do you really need that packagfe specifically?
22:28:47 <ivanm> are you sure what you need isn't elsewhere?
22:29:03 <ivanm> you may wish to try sending an email to the maintainer, asking him to update it
22:29:04 <fragamus> well im writing my own
22:29:23 <ivanm> your own what?
22:30:19 <fragamus> normal distribution thingy
22:30:35 <ivanm> doesnt' statistics have one?
22:30:50 <fragamus> no
22:32:12 <ivanm> thought it did
22:32:16 <ivanm> or mwc-random?
23:13:31 <k0ral> I can't see any JavascriptCore Binding in hackage, do you confirm ?
23:14:16 * hackagebot file-embed 0.0.4.1 - Use Template Haskell to embed file contents directly.  http://hackage.haskell.org/package/file-embed-0.0.4.1 (MichaelSnoyman)
23:16:40 <ivanm> k0ral: as in direct C bindings? no, don't think so
23:16:58 <ivanm> but I'm not that familiar with what "JavascriptCore" is...
23:17:18 <k0ral> the webkit's javascript engine
23:17:27 <k0ral> there is a webkit binding
23:17:33 <k0ral> but no javascriptCore
23:17:41 <k0ral> I'm then screwed up
23:18:03 <k0ral> I've started to write a browser and now I'm stuck :(
23:29:41 <ivanm> k0ral: ask people on the gtk2hs team then about it
23:29:50 <ivanm> though why work on another browser?
23:31:03 <k0ral> ivanm: because I'm still unsatisfied by the existing ones
23:31:03 <k0ral> -by +with
23:32:45 <ivanm> unsatisfied enough to write an entire new browser?
23:32:52 <ivanm> you've also tried ones like uzbl I presume?
23:33:20 <k0ral> of course, I even use it in a daily basis
23:34:35 <k0ral> and writing an "entire" new browser is not really big deal when it's a minimal one
23:36:14 <shurane> this is just wonderage, is there something for haskell what virtualenv for python is?
23:36:24 <ivanm> what's virtualenv?
23:40:56 <shurane> i haven't used cabal install yet, but 'cabal install' works globally, right? virtualenv lets you install to an 'environment'. useful to test out packages without committing.
23:42:09 <shurane> hm, maybe that wasn't descriptive. Uh, different environments can have different combinations of modules (and versions) and it's easy to switch between them.
23:43:17 <ddarius> shurane: There's things like capri and another thing.
23:43:19 <ddarius> See hackage.
23:43:22 <ivanm> shurane: cabal install defaults to local
23:43:23 <shachaf> @hackage cabal-dev
23:43:23 <lambdabot> http://hackage.haskell.org/package/cabal-dev
23:43:35 <ivanm> but yeah, there's capri and cabal-dev for directory-based testing
23:49:15 * hackagebot progression 0.5 - Automates the recording and graphing of criterion benchmarks  http://hackage.haskell.org/package/progression-0.5 (NeilBrown)
