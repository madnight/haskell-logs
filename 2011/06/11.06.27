00:00:16 <ddarius> Simply implement a wrapper that provides a look ahead buffer.
00:00:29 * hackagebot double-conversion 0.1.0.0 - Fast conversion between double precision floating point and text  http://hackage.haskell.org/package/double-conversion-0.1.0.0 (BryanOSullivan)
00:00:35 <ddarius> This is already basically what BufferedReader does, albeit for a different purpose.
00:01:20 <dobblego> what is its type?
00:01:38 <ddarius> dobblego: Type of what?
00:01:44 <dobblego> safePeek for BufferedReader
00:02:30 * hackagebot text-format 0.3.0.0 - Text formatting  http://hackage.haskell.org/package/text-format-0.3.0.0 (BryanOSullivan)
00:03:07 <ddarius> For a wrapper that provides look-ahead, it would be something like Maybe<E> LookAheadReader<E>.Peek().
00:03:14 <ivanm> dammit, even if I wanted to I can't automatically provided anonymous sub-graphs/clusters with unique IDs in case a later sub-graph/cluster _has_ that ID :s
00:06:30 * hackagebot archlinux 1.3 - Support for working with Arch Linux packages.  http://hackage.haskell.org/package/archlinux-1.3 (PeterSimons)
00:11:58 <wli-needjob> Gah, now it's not converging.
00:12:59 <hpaste> wli annotated “Remez.lhs” with “Remez.lhs (annotation)” at http://hpaste.org/48395#a48397
00:14:31 <ivanm> wli-needjob: you're that desperate that you're advertising in IRC? :p
00:14:44 <wli-needjob> ivanm: You might say that.
00:15:39 <darkangel> hi there
00:16:10 * ivanm waves idly in darkangel's general direction
00:16:28 <darkangel> i have a question about type inference. Can someone help me?
00:16:43 <ivanm> that is only possible if there's a question to answer! ;-)
00:16:48 <shachaf> darkangel: Only if you ask i.
00:16:56 <Phyx-> shachaf: i?
00:16:58 <shachaf> s/.$/t./
00:17:20 <ivanm> shachaf: isn't the "$" redundant there?
00:17:31 <shachaf> ivanm: No, because otherwise the . would match the first character.
00:17:58 <darkangel> if I import ByteString.Lazy haskell can't figure out what putStr use in case putStr (pack "Hello"). Why so?
00:18:01 <ivanm> duh, "." needs escaping
00:18:04 * shachaf can't think of a way of golfing that regexp any substitution any further.
00:18:11 <ivanm> darkangel: as there are two different putStr in scope
00:18:14 <shachaf> s/any /
00:18:19 <ivanm> the bytestring version and String version
00:18:30 <shachaf> s/$/\// # On previous s/...
00:18:35 <darkangel> pack "Hello" has ByteString type why not just use ByteString.putStr?
00:18:46 <ivanm> darkangel: as it isn't a type inference problem
00:18:50 <ivanm> it's a scoping one
00:19:02 <darkangel> mm
00:19:08 <ivanm> darkangel: what you say would be true if putStr was a class method, but it isn't
00:19:30 <darkangel> hm. okay
00:19:45 <darkangel> but thats wierd...
00:20:04 <ivanm> not really
00:20:14 <Cale> darkangel: Deciding how names resolve to definitions is done *before* typechecking.
00:20:18 <darkangel> what can i read about such things?
00:20:26 <darkangel> scoping etc
00:20:37 <ivanm> @google haskell scoping
00:20:38 <lambdabot> http://stackoverflow.com/questions/333185/what-type-of-scope-does-haskell-use
00:20:38 <lambdabot> Title: What type of scope does Haskell use? - Stack Overflow
00:21:02 <darkangel> in C++ compiller simply peek up bytestring version
00:21:33 <darkangel> can't understand why haskell cannot
00:21:39 <Saizan> yes, C++ is much less principled about overloading
00:21:53 <ivanm> darkangel: different overloading mechanisms
00:21:56 <Cale> darkangel: Because what type do we infer for putStr then?
00:22:01 <ivanm> Haskell only allows overloading via type classes
00:22:09 <wli-needjob> The algorithm needs major rework from all appearances.
00:22:14 <Cale> If there are multiple definitions in scope from different modules
00:22:30 <ivanm> the fact that there is a bytestring for putStr is because the String one isn't in scope within the bytestring implementation
00:22:40 <Cale> It would have type something like  (String -> IO ()) || (ByteString -> IO ()), supposing that were valid syntax.
00:22:42 <ivanm> wli-needjob: which algorithm?
00:23:10 <wli-needjob> ivanm: My pitiful attempt at a Remez solver (hpasted with numerous annotations).
00:23:20 <ivanm> oh, not the scoping one :p
00:23:22 <Cale> But that sort of type system extension gets really hairy complexity-wise. You end up with lots of common cases where it takes exponential time to typecheck.
00:23:24 <darkangel> Cale: Nope. It can just peek up putStr from different modu;e
00:23:30 <Cale> (rather than just contrived cases)
00:23:44 <Cale> darkangel: Suppose I write   foo = putStr
00:23:49 <darkangel> that has exacly type i need
00:23:51 <ivanm> darkangel: do you mean "pick" rather than "peek" ?
00:23:51 <Cale> darkangel: What type do we infer for foo?
00:24:04 <darkangel> :) maybe
00:24:07 <Cale> darkangel: If I load that module into ghci and do  :t foo
00:24:12 <Cale> what should I expect?
00:24:29 <Cale> It depends on which version you pick.
00:24:30 <darkangel> hm - error :)
00:24:31 <Cale> yeah?
00:24:39 <ivanm> darkangel: remember, Haskell is much stricter in terms of types than C++, etc.
00:24:57 <shachaf> :t foo -- Error: This type is too annoying to show.
00:24:58 <lambdabot> Not in scope: `foo'
00:25:01 <Cale> We *could* extend the type system to allow it to have multiple types
00:25:05 <ivanm> shachaf: lol
00:25:06 <Cale> like:
00:25:19 <Cale> foo :: (String -> IO ()) || (ByteString -> IO ())
00:25:36 <darkangel> ivanm: yes i now, but mixing String and ByteString code is real pain :(
00:25:46 <Cale> but once you allow that sort of thing, it becomes really common that typechecking takes exponential time, which is bad
00:25:51 <ivanm> darkangel: what are you using Bytestring for?
00:25:56 <ivanm> and why not Text?
00:26:05 <wli-needjob> ivanm: I could probably at least attach rational regression with the glpk lib, though.
00:26:20 <darkangel> I am just toying. I know about Text
00:26:22 <ivanm> Cale: suggest somewhere that it can't be done, and wait until augustss or dons prove us otherwise :p
00:26:38 <Cale> (because when you have a composition of a bunch of defined things, the compiler basically has to try all possible combinations to determine which of them typecheck)
00:26:51 <darkangel> I just hit ambiguaty and try to understand why
00:27:09 <ivanm> darkangel: anyway, that's what qualified modules + module aliasing is for
00:27:36 <Saizan> darkangel: import qualified ByteString as BS then you can use BS.putStr, or you can instead hide the putStr from Prelude if you prefer
00:27:47 <darkangel> ivanm: Yes I know. But from my C++ exp that wierd :)
00:28:40 <shachaf> @wiki TypeDirectedNameResolution
00:28:40 <lambdabot> http://www.haskell.org/haskellwiki/TypeDirectedNameResolution
00:28:47 <thoughtpolice> ivanm: oleg can probably do it in linear time.
00:28:55 <darkangel> I am only half-year haskell and 15 year c++ - its not so easy to understand ^)
00:29:04 <ivanm> darkangel: isn't functional programming and lack of mutability wierd? :p
00:29:47 <Cale> darkangel: C++ lets you define a name at different types, and uses just the local type context when trying to determine which to use. Since C++ forces you to declare the type of essentially every little thing that you use (except in the middle of expressions), and it has only fairly weak polymorphism, it's always locally clear which version of the thing is needed.
00:30:46 <darkangel> Cale: Yeah. c++ is horrible in that sence. Too much typing
00:31:44 <Saizan> Cale: the horror part is that such overloading resolution is done after splicing templates
00:31:47 <darkangel> I think haskell (functional languages) is a future. That why i started to teach it.
00:32:05 <Cale> Haskell opted for something which is both more convenient to use, and more principled.
00:32:38 <Cale> (which is typeclasses)
00:33:02 <Cale> but it means that you can't just define a new name anywhere that the same as the existing one and get some kind of polymorphism
00:33:11 <Cale> It's not like the ad-hoc polymorphism which C and C++ have
00:33:31 <Cale> You declare a class, which is like a predicate (boolean function) on types
00:33:57 <darkangel> Cale: Why than not modify string and bytestring to allow such polymorphism? Using typeclasses?
00:33:58 <Cale> together with an interface of functions or other values
00:34:05 <Cale> Sure, could be done
00:34:10 <Cale> We could have in the Prelude:
00:34:16 <shachaf> Type classes aren't really used for the same type of overloading you do in C++, though.
00:34:28 <Cale> class PutStr a where
00:34:35 <Cale>   putStr :: a -> IO ()
00:34:48 <Cale> instance PutStr String where
00:34:53 <Cale>   putStr = ...
00:34:59 <Cale> instance PutStr ByteString where
00:34:59 <darkangel> Cale: I understand
00:35:02 <Cale>   putStr = ...
00:35:03 <shachaf> Cale: You don't really think that would be a good idea, do you? :-)
00:35:06 <Cale> No.
00:35:11 <Cale> I wouldn't do it myself :)
00:35:16 <darkangel> :)
00:35:29 <Cale> If I was actually going to do something like that, I would define:
00:35:34 <Cale> class IsString where
00:35:48 <Cale> er, IsString a
00:35:53 <darkangel> Why not class Strings where putStr = .... putStrLn  = ....
00:35:55 <Cale>   toString :: a -> String
00:36:14 <Cale> Though that loses the efficiency that the ByteString library got you in the first place (possibly)
00:36:21 <shachaf> Whoa, toString? Courageous and innovative!
00:36:26 <Cale> darkangel: Could do that too
00:36:30 <darkangel> fromString :)
00:36:52 <ddarius> Cale: IsString is taken.
00:36:57 <Cale> I know ;)
00:37:33 <Cale> We could add toString to it though
00:37:46 <Cale> (come to think of it, why isn't toString in it?)
00:37:57 <Cale> I guess it's minimal for what they were trying to do.
00:38:54 <ivanm> preflex: seen bos
00:38:55 <preflex>  bos was last seen on #ghc 3 days, 10 hours, 14 minutes and 26 seconds ago, saying: dcoutts: ping
00:39:07 <ddarius> Cale: The pattern for that sort of thing is to have a separate class for the to case, e.g. Integral and Real.
00:39:16 <bos> iva?
00:39:19 <bos> ivanm: ?
00:39:33 <Cale> ddarius: I guess, but "IsString" seems pretty suggestive of an isomorphism
00:39:54 <shachaf> ddarius: IsChar has both toChar and fromChar.
00:39:55 <ddarius> It is a strange name.
00:40:03 <ddarius> @hoogle IsChar
00:40:03 <lambdabot> Text.Printf class IsChar c
00:40:07 <ivanm> bos: is there any way of customising Data.Text.Lazy.Read.double or something similar without copying the floaty function from the source?
00:40:21 * elliott thinks class Put a where put :: a -> IO () would be a good idea
00:40:26 <elliott> (instance Put String where put = putStr, etc.)
00:40:47 <shachaf> IsChar is only used for working around Haskell 98, of course. :-)
00:41:01 <ddarius> Indeed.
00:41:04 <bos> ivanm: customizing? no.
00:41:24 <ddarius> elliott: And what would the Int instance do?
00:41:32 <elliott> ddarius: There would be none.
00:41:43 <ddarius> elliott: Okay, what other instances would there be?
00:41:44 <ivanm> bos: because I want to be able include cases like ".3" :/
00:41:50 <elliott> ddarius: ByteString, Text.
00:41:59 <elliott> (And other similar types -- strings or byte sequences.)
00:42:06 <elliott> Although I think we need more generality in that area anyway.
00:43:08 <darkangel> One more question. Why ByteString doesn't have ++ operator?
00:43:20 <ddarius> @hoogle append
00:43:20 <lambdabot> Data.ByteString append :: ByteString -> ByteString -> ByteString
00:43:20 <lambdabot> Data.ByteString.Char8 append :: ByteString -> ByteString -> ByteString
00:43:20 <lambdabot> Data.ByteString.Lazy append :: ByteString -> ByteString -> ByteString
00:43:26 <elliott> darkangel:
00:43:27 <elliott> :t (++)
00:43:28 <darkangel> That i now
00:43:28 <lambdabot> forall m. (Monoid m) => m -> m -> m
00:43:30 <darkangel> know
00:43:33 <elliott> oh god damn it caleskell
00:43:36 <elliott> :t (Data.List.++)
00:43:37 <lambdabot> forall a. [a] -> [a] -> [a]
00:43:39 <darkangel> why not ++
00:43:44 <elliott> darkangel: (++) is a list operator.
00:43:49 <elliott> ByteStrings are not lists.
00:43:51 <ddarius> darkangel: For the exact same reasons as the putStr case.
00:43:55 <darkangel> oh
00:43:59 <elliott> Haskell doesn't have unrestricted overloading (a very dangerous thing).
00:44:01 <darkangel> i understanded that
00:44:03 <elliott> So you could have Data.ByteString.++.
00:44:06 <elliott> But you couldn't use it as just ++.
00:44:12 <elliott> (String is [Char], i.e. a list of characters, so ++ works on it.)
00:44:30 <elliott> As for why it's Data.ByteString.append and not Data.ByteString.(++)... dunno.
00:44:52 <ivanm> elliott: because some people have argued that ++ should be used for mappend in general IIRC
00:44:58 <ivanm> also, qualified operators are a PITA
00:44:58 <shachaf> Perhaps to make it less conveninent to do an expensive operation?
00:45:01 <darkangel> not to have clashes?
00:45:02 <elliott> ivan: Such as lambdabot ;-)
00:45:06 <shachaf> ivanm: ByteString doesn't have a Monoid instance.
00:45:08 <elliott> darkangel: There would be no clash.
00:45:15 <danharaj> Wasn't there a proposal for type directed name resolution or somesuch?
00:45:20 <elliott> darkangel: But shachaf may be right; "append" on ByteStrings will be slow.
00:45:27 <elliott> danharaj: Precisely that, ye.s
00:45:28 <elliott> yes.
00:45:30 <shachaf> I suppose ByteString isn't in Monoid for a similar reason?
00:46:15 <elliott> shachaf: It should be, IMO; expense shouldn't justify omission of an algebraic property.
00:46:27 <elliott> Unless we want to start putting big O bounds in typeclass definitions??
00:46:40 <shachaf> Sounds like a great idea!
00:46:43 <ddarius> It does.
00:46:51 <shachaf> Make it enforced by the type system, too.
00:47:00 <danharaj> screw you guys
00:47:01 <elliott> shachaf: Sweet. I never liked having a computable compiler, anyway.
00:47:05 <ddarius> In fact, Edison does this.
00:47:08 <danharaj> I don't want to prove complexity theorems in my code.
00:47:27 <danharaj> Question: who uses Edison :p
00:47:32 <elliott> shachaf: Also, we should let the type system prove that nobody will ever use our programs wrongly.
00:47:36 <flux> danharaj, but wouldn't it be nice if the compiler were able to infer upper bounds
00:47:43 <elliott> Then nobody can tell us our UI broke, or our program was used for an illegal purpose, etc.
00:47:43 <Saizan> i'd pretend O(..) bounds by any "container" typeclass
00:47:46 <ddarius> danharaj: You don't have to prove tight ones necessarily.
00:47:52 <elliott> I love specifying things!
00:47:57 <elliott> I specify that it's the best!
00:48:19 <danharaj> But the question is, how much do we add to the type system to be able to get even loose bounds, without getting full dependent typing?
00:52:15 <Saizan> it's not that straightforward even in a dep. typed language, you can't tell beta redexes apart from what they evaluate to, so you'd need some deep embedding of the code you want to analyse
00:53:08 <Saizan> or maybe abstract types whose exposed operations have the complexity annotated in the types
00:53:33 <elliott> woo, compiling ghc
00:53:35 <elliott> i was getting cold
00:53:36 <Saizan> you'd have to trust whoever made those annotations though
00:53:38 <danharaj> could you exploit universal properties to get complexity theorems for free?
00:53:44 <elliott> now my lap is turning into charcoal
00:53:45 <danharaj> very simple ones
00:54:01 <shachaf> elliott: Does GHC compilation even use all cores?
00:54:08 <elliott> help my face is on fire
00:54:09 <Saizan> danharaj: bubblesort and quicksort have the same type
00:54:14 <elliott> shachaf: it supports parallel make :P
00:54:22 <elliott> but actually it looks like it's mostly waiting on io
00:54:24 <thoughtpolice> shachaf: make -j8 uses my 8 hardware threads
00:54:25 <elliott> so under a core is being utilised
00:54:27 <elliott> its still burning though
00:54:29 <shachaf> GHC uses make?
00:54:43 <elliott> shachaf: I'm not compiling /with/ GHC
00:54:46 <elliott> I'm /compiling GHC/
00:54:52 <danharaj> Saizan: But are they the same recursion pattern?
00:54:55 <shachaf> Right, but I'd forgotten that it uses make.
00:54:56 <elliott> Which has... always used make to my knowledge?
00:55:02 <thoughtpolice> it has.
00:55:13 <elliott> And now autoconf
00:55:15 <shachaf> Right, I just haven't compiled it in a couple of years.
00:55:17 <elliott> (I think that's new)
00:55:31 <flux> but.. make.. is written in C? ;-)
00:55:35 <thoughtpolice> for certain definitions of 'new', autoconf based tooling has been around for quite a while
00:55:57 <Saizan> danharaj: probably no
00:56:03 <elliott> flux: clearly we need a haskell rewrite
00:56:09 <thoughtpolice> the parallel builds on GHC get bottlenecked at some points because the compilation sequentializes to do some things, but the extra threads can help take the build time down a lot because of libraries for example - almost all of them can be compiled in parallel
00:56:50 <Saizan> there's shake somewhere on github/hackage
00:57:14 <thoughtpolice> yes, max has been working on a clean-room implementation for a while now
00:57:18 <thoughtpolice> https://github.com/batterseapower/openshake
00:57:54 <shachaf> Why doesn't @djinn suppose RankNTypes? :-(
00:58:01 <shachaf> s/se/rt/
00:58:03 <elliott> Saizan: no i mean a gnu make compatible :)
00:58:07 <elliott> shachaf++ i lol'd
00:58:26 <shachaf> ?
00:58:37 <elliott> shachaf: erm, isn't that undecidable?
00:59:03 <shachaf> Well, in general, sure.
00:59:12 <elliott> Right.
00:59:33 <shachaf> Lots of things are undecidable in general. It could still try.
01:00:15 <Saizan> that'd need a fairly different algorithm, i suspect
01:00:39 * hackagebot KdTree 0.2 - KdTree, for efficient search in K-dimensional point clouds.  http://hackage.haskell.org/package/KdTree-0.2 (IssacTrotts)
01:01:47 <danharaj> well, list fold has a fairly behaved complexity
01:01:49 <danharaj> hmm
01:03:42 <shachaf> What about just Rank2Types?
01:08:31 <iwtu> hi guys! have anyone some experience with Aho-Corasick in Haskell?
01:27:19 <sohum> @hoogle (a -> b -> c) -> a -> (b -> c)
01:27:20 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
01:27:20 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
01:27:20 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
01:27:37 <sohum> wait, that's just application
01:27:42 * sohum headdesk
01:28:40 <shachaf> @ty id
01:28:42 <lambdabot> forall a. a -> a
01:28:42 <shachaf> @ty ($)
01:28:43 <lambdabot> forall a b. (a -> b) -> a -> b
01:28:45 <shachaf> @ty ($$)
01:28:46 <lambdabot>     Ambiguous occurrence `$$'
01:28:46 <lambdabot>     It could refer to either `L.$$', defined at <local>:13:0
01:28:46 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.$$', imported from Text.PrettyPrint.HughesPJ at State/L.hs:54:0-46
01:28:50 <shachaf> Hmph.
01:29:09 <shachaf> @ty ($$$)
01:29:10 <lambdabot> forall t t1 t2 t3. (t -> t1 -> t2 -> t3) -> t -> t1 -> t2 -> t3
01:30:35 <darkangel> Is there any simple way to get grouped matched from regex?
01:31:09 <darkangel> let foo = "bar foo" =~ "(bar)|(foo)"
01:31:32 <darkangel> and foo will be ["bar", ""]
01:32:27 <darkangel> doing let (_,_,_,foo) = "bar foo" =~ "(bar)|(foo)" :: [String, String, String, [String]] is too way verbose
01:33:36 <sohum> so, if I have a f = (value, fn), where fn :: a -> b, what's the closest I can get to treating it as a function a -> (value, b)?
01:33:38 <ddarius> I recommend using the not insane API.
01:33:51 <shachaf> There's a not insane API?
01:34:00 <sohum> @hoogle (v, a -> b) -> a -> (v, b)
01:34:01 <lambdabot> No results found
01:34:33 <sohum> actually, hang on
01:34:39 <sohum> that's just the reader monad, isn't it
01:34:51 <ddarius> @djinn (v, a -> b) -> a -> (v, b)
01:34:52 <lambdabot> f (a, b) c = (a, b c)
01:35:06 <shachaf> @. pl djinn (v, a -> b) -> a -> (v, b)
01:35:06 <ddarius> sohum: Not just that, it's the strength of the Reader monad.
01:35:06 <lambdabot> f = uncurry ((.) . (,))
01:35:54 <shachaf> Strength?
01:35:58 <sohum> ddarius: what do you mean?
01:36:25 <elliott> <sohum> @hoogle (a -> b -> c) -> a -> (b -> c)
01:36:28 <elliott> unfortunately this function cannot type.
01:36:33 <elliott> it is a limitation of the current haskell type system.
01:36:33 <ddarius> @google tensorial strength
01:36:48 <lambdabot> Plugin `search' failed with: thread killed
01:36:51 <ddarius> @google tensorial strength
01:37:00 <sohum> elliott: isn't that just id?
01:37:20 <elliott> sohum: sshhhhhh
01:37:51 * sohum winkwinknodnod
01:38:08 * shachaf is still mad that he can't have a generic f x y = x (x y).
01:38:50 <Boxo> :t \x y -> x (x y)
01:38:58 <Boxo> @type \x y -> x (x y)
01:38:58 <shachaf> @botsneak
01:39:52 <elliott> poor sneaking bot
01:41:52 <shachaf> Cale: @botsneak
01:41:58 <jonkri> i want to validate xmpp jids, which could be utf-8 encoded and internationalized. for validating and parsing such an object, do you think regular expressions would do the job or should i go for something like parsec?
01:44:05 <ion> The grammar from thespec should translate quite naturally to Parsec or equivalent.
01:49:36 <Kaidelong> r f
01:49:41 <Kaidelong> wws
01:49:44 <Kaidelong> sorry
01:50:08 <jonkri> ion, thanks :)
01:50:18 <ivanm> @type \ x y -> x (x y)
01:50:18 <lambdabot> forall t. (t -> t) -> t -> t
01:50:21 <ivanm> Boxo: ^^
01:52:44 <shachaf> @ty (\x y -> x (x y)) :: forall l b. (forall a. a -> l a) -> b -> l (l b)
01:52:44 <lambdabot> forall (l :: * -> *) b. (forall a. a -> l a) -> b -> l (l b)
01:54:51 <shachaf> @ty (\x y -> x (x y)) :: forall l b. (forall a. l a -> a) -> l (l b) -> b
01:54:52 <lambdabot> forall (l :: * -> *) b. (forall a. l a -> a) -> l (l b) -> b
01:59:05 <sohum> gah
02:00:18 <sohum> there's no way to make something created via a data constructor behave like a function, is there?
02:00:56 <Kaidelong> functions themselves?
02:01:06 <kosmikus> sohum: I don't understand the question. Data constructors behave like functions already.
02:01:34 <Kaidelong> I think he might be wondering how to define the function datatype?
02:02:18 <Kaidelong> data a -> b = \a-> b
02:02:19 <Kaidelong> I guess
02:02:30 <Kaidelong> not that that would work
02:02:33 <Kaidelong> but you could do say
02:02:46 <sohum> syntactically - I want to be able to use f = Foo id with the syntax f 5
02:02:50 <Kaidelong> oh
02:02:59 <Kaidelong> nm I didn't do it right anyway
02:03:15 <sohum> (instead of unFoo f 5)
02:03:44 <kosmikus> ah
02:04:33 <ddarius> edwardk: Recently mentioned a hacky way to get that effect that he had figured out long ago.
02:04:53 <sohum> (and the reason is because the type is cyclic, so I can't just synonym it)
02:05:02 <kosmikus> well, no. function application isn't overloaded. you can tweak a bit with applicative functors and the like, but you won't be able to write just f 5 ...
02:05:58 <ddarius> kosmikus: Yes, but what you can do is make a smart constructor that is overloaded that resolves to either a function or the non-function type.
02:06:17 <kosmikus> ddarius: I've been thinking about that for a moment.
02:07:05 <kosmikus> ddarius: it might work, and if you say it does ...
02:09:56 <zenzike> is there a sensible way to convert a CShort into an Int?
02:10:09 <zenzike> fromIntegral?
02:10:11 <ddarius> Yes.
02:12:42 <zenzike> ddarius: thanks
02:12:58 <jonkri> parsec vs attoparsec? :)
02:16:52 <sohum> ddarius: a smart constructor?
02:19:23 <profmakx> copyrofl!
02:20:27 <elliott> hm, did there not use to be a haskell-platform package on hackage?
02:20:37 <hpaste> sohum pasted “Smart constructor?” at http://hpaste.org/48400
02:20:50 <sohum> ddarius: something like that^
02:20:51 <sohum> ?
02:21:26 <elliott> people actually use unicode in haskell?
02:22:07 <sohum> oh, um, woops
02:22:09 <sohum> sorry about that
02:22:15 <sohum> I copypasted from emacs
02:23:19 <elliott> i was just surprised, that's all :)
02:24:16 <sohum> I wonder if you can get ghc to accept the unicode
02:24:41 <elliott> yes.
02:24:44 <elliott> UnicodeSyntax, IIRC.
02:25:16 <sohum> oh, as a LANGUAGE option?
02:25:32 <sohum> neat!
02:27:57 <elliott> oh no, i am making the unicode spread :(
02:31:28 <sohum> I like unicode :(
02:34:01 <elliott> sohum: but with haskell it is just making things unnecessarily painful while still sticking to the programs-as-flat-unstructured-text-stream dichotomy :(
02:34:10 <elliott> it is like the worst of both worlds and you should feel bad. but maybe only a little bad.
02:41:26 <JuanDaugherty> what dichotomy, elliott?
02:42:43 * JuanDaugherty the dichotomous monopole I assume
02:43:03 <osfameron> why would you have emacs transform valid haskell into something else?
02:43:31 <sohum> osfameron: it's display layer only
02:43:42 <osfameron> yes, but why?
02:43:45 <sohum> I feel like a terrible person for using Impredicative Types
02:43:53 <sohum> osfameron: because I think it looks nicer?
02:46:19 <Saizan> ImpredicativeTypes are nice
02:51:42 <osfameron> what are ImpredicativeTypes?
02:53:27 <Cale> osfameron: That's where you instantiate a parametric datatype (like Maybe) with a polytype (like  forall a b. (a -> b) -> [a] -> [b])
02:54:39 <Cale> Just (\f -> reverse . map f) :: Maybe (forall a b. (a -> b) -> [a] -> [b])
02:57:18 <osfameron> how do I add -XRankNTypes ?
02:58:09 <osfameron> ah, {-# LANGUAGE RankNTypes #-}
02:58:17 <Saizan> {-# LANGUAGE RankNTypes #-}
02:58:21 <osfameron> Cale: that example still doesn't compile though
02:58:37 <Saizan> or :set -XRankNTypes in ghci
02:59:01 <Cale> That's not a higher rank type, it's an impredicative type
02:59:10 <Cale> and ImpredicativeTypes has been removed, no?
02:59:34 <osfameron> ah, that was the error message that ghci gave when I tried to paste that line
03:00:05 <osfameron> I've tried running with just {-# LANGUAGE ImpredicativeTypes #-} which accepts the language extension, but gives an error in compilation
03:00:42 <Saizan> maybe ImpredicativeTypes doesn't enable forall .. by itself
03:00:52 <Saizan> and it's no longer deprecated, btw
03:01:07 <Cale> oh, it's not deprecated?
03:01:18 <Cale> I thought they dropped support altogether
03:01:41 <Cale> I haven't been following GHC features closely enough lately though
03:05:49 <hpaste> example pasted “Cale” at http://hpaste.org/48401
03:05:57 <Cale> oops, blah :)
03:06:34 <Cale> ^^ but that's an example of impredicative types. Seems to work in newish GHC anyway :)
03:07:19 <zygoloid> Cale: i keep doing that. i think the title and author boxes are not the intuitive way around
03:07:53 <Cale> I don't think I should have to fill in an Author box every damn time in the first place.
03:08:29 <osfameron> how do you call that function?
03:08:37 <ben> I too posted some snippets named "Ben" a while back, fortunately before it autoposted them into the channel
03:08:55 <osfameron> it looks like "g" should be a function [a] -> [a].   Shouldn't 'id' work as a trivial one?
03:09:33 <Cale> yeah, it should
03:10:09 <Cale> interesting, it's broken
03:10:11 <osfameron> f (Just id) gives me "Couldn't match expected type `forall a. [a] -> [a]' with actual type `a0 -> a0'"
03:10:15 <Cale> yeah
03:10:15 <osfameron> perhaps I need a newer ghci?
03:10:18 <osfameron> oh, ok
03:10:19 <Cale> no
03:10:23 <Cale> an older one, probably
03:10:28 <osfameron> ah, heh
03:10:39 <Cale> I heard that they were removing support for ImpredicativeTypes entirely a while back
03:11:03 <Cale> So I was surprised that the extension was still there
03:11:20 <quicksilver> I thought they were only removing support for the inference algorithm they used
03:11:24 <quicksilver> not impredicate types altogether
03:11:54 * osfameron doesn't understand what extension is being used in that example
03:12:02 <osfameron> why couldn't you write that function otherwise, I mean?
03:12:39 <quicksilver> Cale: ""Yes, impredicative types are still in, but in a simpler form than before, along the lines of QML"" -- SPJ
03:13:07 <zygoloid> http://www.haskell.org/pipermail/haskell-cafe/2010-November/086566.html
03:13:19 <Saizan> osfameron: because Maybe (forall a. ...) is not even a valid type without ImpredicativeTypes
03:13:19 <zygoloid> Cale: ^^
03:13:25 <quicksilver> zygoloid++ # saving me the trouble of finding the link.
03:13:41 <osfameron> ok, but why isn't: f :: Maybe ([a]->[a]) -> Maybe ([Int], [Char])  valid?
03:13:47 <quicksilver> I wish GHC's mailman installation put the link to the article in the archives in the header somewher.e
03:14:09 <sohum> osfameron: because a isn't instantiated anywhere
03:14:20 <sohum> osfameron: or, rather
03:14:24 <Saizan> osfameron: that's actually forall a.
03:14:24 <Cale>  Maybe (forall a. [a] -> [a]) -> Maybe ([Int], [Char])  you mean
03:14:38 <sohum> osfameron: the *function* with that type is fine, but the forall is outside the Maybe
03:14:41 <Cale> (the forall is important)
03:15:11 <Saizan> osfameron: that's actuallty "f :: forall a. Maybe ([a]->[a]) -> Maybe ([Int], [Char])" which means that f can't pick an 'a' to use the function in the Maybe with
03:15:11 <Cale> GHC accepts the definition of the function, but I'm not sure how to apply it
03:15:23 <osfameron> and ImpredicativeTypes are what allow you to declare a function with that forall ?
03:15:25 <Saizan> osfameron: the caller of f will decide what to use for 'a' instead
03:15:46 <Cale> Well, apply it to something other than Nothing anyway
03:16:48 <Saizan> Cale: try let x :: Maybe (forall a. [a] -> [a]); x = Just id in f x
03:17:05 <dBuchmann> Hi everybody. I'm new and I got a question, hope I can ask :)
03:17:15 <ben> Give it a shot
03:17:38 <Cale> Saizan: ghc balks at the definition of x
03:18:02 <dBuchmann> Nice. I'm in need for tls/ssl support. What options do I have?
03:19:18 <dBuchmann> There is no native support so far, right?
03:19:19 <ben> There's a tls package on haskell and a hsopenssl, but I don't know anything beyond that :)
03:19:23 <ben> err, on hackage
03:19:42 <Saizan> Cale: i se
03:19:52 <Saizan> *see
03:20:25 <Saizan> seems like ghc's typechecker should start taking type annotations in more consideration
03:20:26 <dBuchmann> Everything I found on hackage said about itself that it is incomplete
03:20:41 <Cale> dBuchmann: looking on hackage, there are some projects which claim you shouldn't use them yet, and there is hsgnutls, which is a binding that should work
03:20:58 <Cale> (though it's still incomplete)
03:21:36 <sohum> @pl \x -> (x,[])
03:21:36 <lambdabot> flip (,) []
03:22:03 <sohum> :t id &&& const []
03:22:03 <lambdabot> forall b a. b -> (b, [a])
03:22:24 <kapper> Hi. I'm trying to make a function to calculate the # of fib. numbers between i and j. This is what i did:
03:22:26 <kapper> fibs' = 0 : 1 : zipWith (+) fibs' (tail fibs')
03:22:26 <kapper> howManyFibs' i j = let xs = [ x | x <- fibs', x <= j, x >= i]
03:22:26 <kapper>                    in length xs
03:23:05 <dBuchmann> ok, thanks. http://hackage.haskell.org/package/hsgnutls mentions that it is just a fork. and I can't find the official. Can somebody give me directions? Sorry
03:23:08 <kapper> But it just hangs there...if i do f.ex : x <- take 500 fibs' in the list comprehension, it works fine...
03:23:26 <Cale> kapper: That won't terminate, because it can't know that there are no fibs arbitrarily far into the list which satisfy the conditions.
03:23:29 <zenzike> kapper: it hangs there after producing some values presumably?
03:23:55 <kapper> Yes, it shows the list...then hangs.
03:24:11 <Cale> kapper: You should use dropWhile (> i) (takeWhile (< j) fibs')
03:24:21 <Cale> er
03:24:25 <Cale> backward :)
03:24:59 <Cale> dropWhile (< i) (takeWhile (<= j) fibs)
03:25:26 <Cale> The important part being the takeWhile
03:25:33 <zenzike> kapper: yep, Cale's solution basically encodes the fact that your fibs are monotonically increasing, so when you get one that's larger than j, you can stop looking.
03:26:30 <kapper> Ahh, great. That works. Thanks!
03:29:04 <mjo> I find it slightly surprising that there's no canonical way to say (dropWhile ...) . (takeWhile ...) because it seems quite a common construction
03:30:14 <cheater_> why
03:30:25 <luite> hmm, I don't think it's that common
03:31:46 <quicksilver> :t span
03:31:47 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
03:31:50 <quicksilver> mjo: ^^ ?
03:32:47 <Peaker> with Impredicative Types: would (>>=) be able to get a polymorphic (higher-ranked) value as a result of an IO computation?
03:33:19 <Peaker> if so, doesn't it make  newIORef undefined >>= (\polymorphicIORefHere -> ...)  allow unsafeCoerce?
03:33:37 <Peaker> actually, that's not polymorphicIORef but an IORefOfPolymorphic?
03:36:14 <Peaker> newIORef (undefined :: forall a. a) :: IO (IORef (forall a. a))       -- then you (>>= (\x -> ...)) with ImpredicativeTypes, would x have type:  IORef (forall a. a) ?
03:36:28 <Saizan> yes
03:36:40 <Peaker> would this allow implementing IO-based unsafe coerce?
03:36:44 <Saizan> no
03:36:53 <Peaker> why not?
03:37:07 <Peaker> oh, you can't write non-polymorphic values into it?
03:37:20 <Saizan> right
03:37:27 <Saizan> you'd need (x :: forall a. IORef a) for unsafe coerce
03:38:04 <Peaker> newIORef undefined :: forall a. IO (IORef a) ---   so the only way to move the "forall" between the IO and the IORef is unsafePerformIO?
03:38:21 <kapper> I used to program with ML, but the lazyness of Haskell is quite amazing...Two lines of code, and i can calculate arbitrarily large fibs in a split second...I cant' really get my mind around how it's really possible though...
03:38:35 <rsuniev2> > sequence [Right 1, Left "Er"]
03:38:36 <lambdabot>   Overlapping instances for GHC.Base.Monad
03:38:36 <lambdabot>                              (Data...
03:38:38 <Peaker> Saizan: because I was long confused on why unsafePerformIO was the only way to unsafe coerce with mutable variables..
03:39:56 <rsuniev2> > Control.Monad.sequence [Right 1, Left "Er"]
03:39:56 <lambdabot>   Overlapping instances for GHC.Base.Monad
03:39:57 <lambdabot>                              (Data...
03:40:05 <rsuniev2> hm
03:40:21 <Peaker> Left "Er"   would be the senseful result
03:41:24 <rsuniev2> I want Either list. Is it possible to do?
03:41:35 <Peaker> rsuniev2: what result do you want?
03:41:49 <Saizan> Peaker: yeah, there's no other legit way to push the forall a. past the IO type constructor
03:42:34 <rsuniev2> Peaker: Either [1,"er"]
03:42:54 <Peaker> Saizan: is there any way to make unsafePerformIO  be only unsafe w.r.t IO execution, and not w.r.t making values more polymorphic than they should be? :)
03:43:11 <Peaker> rsuniev2: Either is a type, not a value
03:43:21 <Peaker> rsuniev2: what value do you want to result from that?
03:43:29 <aavogt> @hoogle [Either a b] -> ([a],[b])
03:43:29 <lambdabot> Data.Either partitionEithers :: [Either a b] -> ([a], [b])
03:43:48 <Peaker> > partitionEithers [Right 1, Left "Er"]
03:43:49 <lambdabot>   (["Er"],[1])
03:45:40 <rsuniev2> I need similar behaviour similar to this
03:45:43 <rsuniev2> > sequence [Just 1, Just 2, Just 3]
03:45:44 <lambdabot>   Just [1,2,3]
03:45:52 <rsuniev2> But for Eithers
03:46:05 <rsuniev2> does it makes sense? Or I am missing smth
03:47:01 <aavogt> @type \l r -> map (either l r)
03:47:01 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> [Either a b] -> [c]
03:49:46 <Saizan> Peaker: not that i can think of
03:57:12 <Boxo> > (\(a,b) -> a ++ b) $  partitionEithers [Right 1, Left "Er"]
03:57:12 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
03:57:13 <lambdabot>    arising from the literal ...
03:57:35 <Boxo> > (\(a,b) -> a ++ b) $  partitionEithers [Right "heh", Left "Er"]
03:57:36 <lambdabot>   ["Er","heh"]
04:02:23 <hpaste> sohum annotated “Smart constructor?” with “Smart constructor testing” at http://hpaste.org/48400#a48403
04:03:01 <sohum> ddarius: I can't seem to get it to work, though. See http://hpaste.org/48400#a48403 for the error "No instance for (FooLike (forall a. FooLike a => a))"
04:30:35 <jonkri> is it, given there is less documentation available for attoparsec, worth to learn attoparsec instead of parsec?
04:35:38 <kstt> jonkri: both are based on the same concept : monadic parsing. Understanding this concept is 90% of what you will have to learn before getting started.
04:35:54 <jonkri> kstt, obliged :)
04:36:36 <kstt> the rest mostly differs in implementation, types, and local policies
04:36:42 <kstt> that's not much
04:37:00 <jonkri> i see
04:37:28 <kstt> if you are not familiar with all that, I'd recommand you to get started at the begining : Parsec 2.
04:38:26 <kstt> Its descendant are mostly optimisations of it, so they are a bit harder to understand.
04:40:48 <identity_> This iteratee/iterator stuff.. It seems to be popular these days, people doing IO with it and so on. What exactly is the purpose of using it? What are the advantages? I don't quite get the concept.
04:41:10 <kstt> attoparsec in combination with iteratees have a very good reputation for IO intensive applications (network, big files ...)
04:41:11 <aavogt> ReadP is even simpler
04:43:20 <kstt> identity_: try to work without them first. When problems arise, you'll understand the point of the iteratee model.
04:43:27 <parcs> @google iteratee advantages
04:43:28 <lambdabot> http://stackoverflow.com/questions/3788853/what-makes-iteratees-worth-the-complexity
04:43:28 <lambdabot> Title: haskell - What makes Iteratees worth the complexity? - Stack Overflow
04:44:15 <identity_> Thanks :)
04:44:19 <identity_> I'll check that link out
04:46:15 <jonkri> kstt, thanks. my application is not at all io intensive :)
04:46:50 <kstt> then I'd recommand to start with parsec 2
04:47:35 <jonkri> kstt, parsec 3 is an optimization?
04:50:26 <kstt> optimization + generalisation I think, but I'm not really familiar with Parsec 3
04:50:33 <ksf> gobject really, really needs a spec language.
04:51:01 <ksf> or people should just re-write their libraries in vala.
04:51:22 <wjt> ksf: does gobject-introspection get you anywhere near?
04:52:01 <wjt> ksf: there's a work-in-progress library for reading .gir files and generating Haskell code you might be interested in if so: http://git.rhydd.org/?p=haskell-gi;a=summary
04:52:18 <ksf> clutter doesn't have a .gir file I'd know of.
04:52:23 <ksf> it's written in plain C
04:52:37 <ksf> but, yes, generating bindings from introspection might be worth a try.
04:52:52 <augur> beep boop
04:53:16 <wjt> ksf: you generate gir files from the C code
04:53:45 <ksf> oh.
04:53:49 <wjt> and i'm pretty sure that clutter is introspectable, given that gnome-shell is written in javascript using gi and uses clutter :)
04:54:03 <ksf> also, at least gentoo doesn't build clutter with introspection support, by default.
04:54:22 <wjt> can't help you there ;-)
04:54:49 <sohum> @pl \(n,a) f -> (fst $ f n, a ++ snd $ f n)
04:54:49 <lambdabot> uncurry (ap ((.) . ap . (((,) . fst) .) . flip id) (flip ((.) . (++ snd)) . flip id))
04:55:08 <ksf> well, it probably wouldn't be necessary to require introspection on the target machines.
04:55:36 <wjt> i'm not sure whether the generated code from that application needs it or not
04:56:18 <sohum> @pl \x -> (fst x, a ++ snd x)
04:56:18 <lambdabot> liftM2 (,) fst ((a ++) . snd)
04:56:39 <ksf> ...the monospaced parts on that blog are cut off on the right.
04:56:40 <sohum> :t id *** (a ++)
04:56:40 <lambdabot>     No instance for (Monoid Expr)
04:56:41 <lambdabot>       arising from a use of `++' at <interactive>:1:8-11
04:56:41 <lambdabot>     Possible fix: add an instance declaration for (Monoid Expr)
04:56:54 <sohum> :t id *** ([] ++)
04:56:54 <lambdabot> forall b a. (b, [a]) -> (b, [a])
04:57:10 <aavogt> @ty \f -> second (f ++)
04:57:11 <lambdabot> forall b d. (Monoid b) => b -> (d, b) -> (d, b)
04:57:22 <sohum> oh, right, duh :p
05:00:08 <aavogt> @ty \a f -> second (a++) . (id &&& id) . f
05:00:09 <lambdabot> forall a (f :: * -> *). (Monoid a, Functor f) => a -> f a -> f (a, a)
05:00:38 <aavogt> @pl \a f -> (id &&& (a++)) . f
05:00:38 <lambdabot> (.) . (id &&&) . (++)
05:01:47 <aavogt> it looks clean, but I'm not sure I'd like to decipher how that one works, at least without a type signature
05:03:17 <ksf> http://bugzilla.o-hand.com/show_bug.cgi?id=1452 \o/
05:03:54 <aavogt> are there reasons not to share subexpressions like the (f n) above?
05:05:34 <aavogt> somehow it might lead to lower memory usage if the f is cheap, but the result is much larger than the input, and you use the snd long after the fst has been garbage collected?
05:08:24 <iwtu> Hi guys. I've got my own trie and I must find out how to build failure function in Aho-Corasick. any idea to right direction?
05:17:43 <ziman> Add an extra failure field of type "MyTrie" to each tree node. Then you "just" need to get sharing right.
05:18:00 <balor> What's the best way to do [Char]->Int when you're guarantted (all isNumber str) where str is [Char]
05:18:21 <trygvis> read
05:19:11 <trygvis> :t read
05:19:12 <lambdabot> forall a. (Read a) => String -> a
05:20:02 <augur> ksf: so when you said codensity is optimization
05:20:31 <iwtu> ziman, you mean MyTrie a | Leaf | Branch (Map.Map Char MyTrie) MyTrie ?
05:20:36 <wjt> balor: 'course, that can overflow :)
05:21:16 <ziman> iwtu, yes.
05:21:45 <iwtu> ziman: i wasn't wasting of memory?
05:22:04 <iwtu> won't it be wasting of memory?
05:23:27 <ziman> iwtu, no, the MyTrie's will be shared (think of them as references).
05:23:34 <iwtu> ziman: if key is not in map i can just pass the last MyTrie
05:24:18 <trygvis> balor: the "read" was to you
05:25:01 <iwtu> ziman: ok. I will try. Now I am going to figure out how to build the failure Tree
05:25:03 <ziman> iwtu, at this point, you might benefit from the record syntax; you don't use Leaf anywhere except for creating a new Branch, anyway
05:25:10 <ziman> iirc
05:25:48 <iwtu> ziman: please so me some example
05:25:52 <iwtu> *show
05:25:58 <ziman> so you could just write data MyTrie a = Branch { children :: Map.Map Char MyTrie; failure :: MyTrie }
05:26:58 <iwtu> ziman: it seems nice! How do I access to values?
05:27:06 <ziman> to get named fields and selector functions; for more on that see http://learnyouahaskell.com/making-our-own-types-and-typeclasses, part Record Syntax
05:27:32 <iwtu> ziman thanks!
05:29:13 <balor> trygvis, yes, thanks...have been playing with making it work.
05:52:00 <MasseR> The more I work with PHP the more I appreciate Haskell :/
05:52:14 <Phyx-> Truer words have never beens spoken
05:52:21 <Phyx-> been*
05:54:05 <MasseR> all ($ x) validators -> function($x) use($validators) { return all($validators, function($y) use ($x) { return $y($x); }); }
05:54:45 <parcs> web development in haskell isn't exactly bliss, either
06:03:05 <xplat> parcs: but doing anything besides web development in PHP is *even worse*
06:04:48 <Martty> untrue
06:05:15 <xplat> i don't think i've seen a language yet that would make web development 'bliss' anyway
06:05:35 <identity_> So I'm reading this tutorial on Enumerators and Iteratees: http://www.mew.org/~kazu/proj/enumerator/
06:06:01 <identity_> I'm following the example of the function "consumer", basically, but it seems the library is different from when the tutorial was written
06:06:13 <Twey> Any sizeable project in PHP contains a buggy, underspecified implementation of half of Snap
06:06:20 <identity_> i.e. the type signature Iteratee String IO () isn't valid
06:06:51 <ben> Are you using Data.Enumerator from the 'enumerator' package, or the Data.Iterator stuff
06:06:55 <ben> err, Data.Iteratee
06:07:05 <Twey> identity_: There are several competing iteratee libraries; which are you using?
06:07:22 <identity_> Twey: Just the one that was installed, but let me check
06:07:46 <Tomsik> Excuse my ignorance, but is there an unlying difference between iteratee libraries?
06:07:53 <xplat> this tutorial is for Data.Enumerator
06:07:56 <parcs> their implementation
06:08:04 <Twey> Tomsik: Naming, implementation
06:08:10 <Twey> Some of the stuff they've built on top
06:08:13 <Twey> The basic concept is the same
06:08:14 <identity_> xplat: There are no other libraries that would 'put themselves at' Data.Enumerator?
06:08:14 <xplat> there are differences of interface too
06:08:17 <identity_> I'm using Data.Enumerator
06:08:28 <parcs> identity_: what type does ghc infer for the function?
06:08:28 <Twey> Yeah
06:09:14 <Tomsik> Implementation, what is there besides a newtime wrapper?
06:09:20 <Tomsik> because that's what I've seen
06:09:34 <Phyx-> which license is GHC distributed under?
06:09:35 <identity_> parcs: what function? It says Iteratee is: m (Step a m b) -> Iteratee a m b
06:09:44 <Twey> Phyx-: BSD
06:10:06 <parcs> identity_: the 'consumer' function
06:10:19 <identity_> parcs: It doesn't type check
06:10:24 <identity_> oh, sec
06:10:43 <identity_> leaving out the type signature it doesn't type check either
06:11:20 <xplat> identity_: Iteratee String IO () should be a perfectly valid type, you probably just have a mistake in the function somewhere?
06:12:11 <xplat> (Data.Enumerator is not my favorite iteratee library, but it seems to be everyone else's)
06:12:29 <identity_> xplat: the error is "Not in scope: type constructor or class 'Iteratee'", even though I import Data.Enumerator which contains the definition for Iteratee..
06:12:55 <xplat> what is the import line you use?
06:13:05 <identity_> But then again, Iteratee in Data.Enumerator is: Iteratee :: m (Step a m b) -> Iteratee a m b
06:13:07 <parcs> identity_: can you paste the entire file, with imports and all?
06:13:10 <identity_> alright
06:13:52 <hpaste> identity_ pasted “iteratee madness” at http://hpaste.org/48410
06:14:07 <ben> "iteratee madness", how redundant
06:14:17 <xplat> qualified
06:14:39 <xplat> if you import qualified, you have to use Data.Enumerator.Iteratee instead of just Iteratee
06:14:42 <identity_> ugh
06:14:43 <identity_> wow
06:14:44 <identity_> thanks
06:14:47 <identity_> massive brainfart
06:15:14 <identity_> <3
06:15:28 * identity_ sits in a corner
06:16:23 <xplat> also, you need Iteratee $ in front of the do
06:17:02 <ben> If I have an Enumerator X m b and an Iteratee X m Y, can I combine those and run an Iteratee Y m Z off them?
06:17:11 <ben> (using the enumerator package)
06:17:39 <xplat> in the middle you need to use an Enumeratee instead
06:17:41 <identity_> xplat: Seems to type check
06:17:57 <ben> xplat: Can I build an Enumeratee out of an Iteratee somehow?
06:18:43 <xplat> hm, maybe you don't need Iteratee $, Iteratee is a monad in its own right after all
06:19:01 <identity_> The type signature for enumList in the tutorial is: Integer -> [a] -> Enumerator a m b, while in the current package it is Integer -> [a] -> Step a m b -> Iteratee a m b.. What is the difference?
06:19:41 <xplat> the 'case foo' stuff just made my think what you had was a step function to wrap instead of an iteratee action
06:20:07 <ben> I'm having a really hard time keeping all the boilerplate straight to write the Enumeratee
06:20:12 <xplat> identity_: there is no difference
06:21:40 <identity_> xplat: Well, there sure seems to be. There's a whole extra parameter, mainly Step a m b. Though it does work
06:21:43 <identity_> I don't get this o.o
06:21:54 <xplat> ben: if there's a nice way to handle enumeratees with Data.Enumerator i haven't seen it yet.  if i had maybe i would like it better.
06:22:25 <ben> xplat: I'm kinda disappointed because I figured that is what iteratees are all about
06:22:41 <xplat> identity_: the type Enumerator a m b is an alias for Step a m b -> Iteratee a m b, so the parameter is actually there in both cases
06:22:45 <ben> now I can't keep it together long enough to write a thing that takes bytestrings and passes them off line by line as strings to another iteratee :/
06:23:15 <identity_> xplat: OH
06:23:26 <identity_> I didn't notice that one said Iteratee and one enumerator
06:23:48 <xplat> ben: there are basically two kinds of composition that iteratees deal with: 'horizontal' composition (sequencing of iteratees, or appending of enumerators) and the 'vertical' kind involving enumeratees
06:24:15 <ben> I'm not sure what sequencing of iteratees means
06:24:32 <xplat> every iteratee implementation i've seen is much weaker at handling vertical composition than horizontal, although they vary in how much weaker
06:24:57 <ben> is that just x <- iter1; y <- iter2; return (x,y) basically
06:25:22 <xplat> ben: yes.  or x <- iter1; y <- iter2 x
06:25:27 <ben> right
06:25:29 <ben> hmm
06:26:24 <ciaranm> let's say i wanted something like Either, except that when used as a Functor the Left option should be functioned and the Right option left alone. what would the 'instance Functor' declaration look like?
06:26:36 <dmwit> can't
06:26:38 <dmwit> sorry
06:26:56 <shachaf> newtype Flip f a b = Flip f b a
06:26:57 <xplat> an example of a really basic thing that you will find missing from a lot of enumerator libraries is a function that takes two enumeratees and returns a new enumeratee where one takes the other's output as input
06:27:30 <xplat> basically sh's '|' for enumeratees
06:27:55 <ben> Either' a b = Right a | Left b, instance Functor Either a where...?
06:27:57 <ben> +data
06:28:16 <ciaranm> ben: that's cheating!
06:28:43 <dmwit> Are you Turkish?
06:28:53 <byorgey> ciaranm: since Haskell does not have type-level lambdas, there is no way to make any but the last type parameter functorial
06:29:16 <quicksilver> you can newtype it, which is similar but lets you use the underlying type underneath
06:29:29 <shachaf> What sort of language doesn't even support type-level lambdas?
06:29:36 <ciaranm> ah, that's a shame. i was mostly wondering about what byorgey said
06:29:44 <quicksilver> newtype Rehtie b a = Backwards (Either a b)
06:29:46 <ben> xplat: that's somewhat of a letdown. I was hoping it would be simple to express "take this enumerator from a socket that gives bytestrings, plug an enumeratee on it that splits the bytestrings by line and spits out one String per line, and then use an iteratee to pick the right line"
06:30:19 <ben> Clearly computers are not sufficiently advanced for that kind of thing, yet.
06:30:35 <byorgey> mind you, adding support for type-level lambdas would come at the cost of decidable typechecking
06:30:52 <xplat> ben: composing an enumeratee with a plain iteratee or enumerator is easier
06:31:26 <shachaf> What sort of language needs decidable typechecking?
06:31:39 <ben> I've been trying to write that enumeratee on top of an Iteratee ByteString m String, but I'm not entirely getting anywhere
06:31:47 <xplat> shachaf: not C++
06:31:53 <dmwit> Decidable typechecking is a nice feature.
06:31:57 <dmwit> Not required, just nice.
06:32:27 <shachaf> byorgey: Is that for any sort of type-level lambdas? Could they be restricted somehow for simpler things like Flip?
06:32:30 <geheimdienst> the programs i run aren't decidable either ... *shrug*
06:32:40 <xplat> practically speaking a lot of languages that have decidable typechecking really don't
06:32:54 <shachaf> geheimdienst: I've decided not to run undecidable programs.
06:33:08 <ciaranm> types being arbitrary expressions c++-style is occasionally handy. or would be if the syntax weren't so painful...
06:33:08 <xplat> NEXPTIME-complete has the same significance to humans as undecidable
06:33:16 <dmwit> Decidable evaluation is significantly less important than decidable typechecking in practice.
06:33:24 * osfameron googles type-level lambdas
06:33:58 <eikke> osfameron: "Fun with type functions" (or something alike) is a nice read (if that's what you're looking for...)
06:34:12 <Cale> "Most" polynomial functions are too large for practical purposes as well for that matter.
06:34:32 <xplat> x^109380917489108928320132021938901471903982103218903290 + 3?
06:34:33 <Cale> (FSVO most)
06:34:36 * dmwit shows off his O(n^17) type-checker
06:34:53 <ciaranm> i never got discussions about "most" functions. "most" functions are utterly ill behaved and completely useless
06:34:53 * shachaf shows off his O(-n^17) type-checker
06:35:16 * eikke was impressed by the 'session types' concept he found out about last week
06:35:19 * shachaf is only showing off the fact that he didn't sleep last night.
06:35:58 <Cale> I'm waiting for someone to show that P = NP, but that the best polynomial time solution to an NP-hard problem is O(n^G), where G is Graham's number.
06:36:00 <xplat> Cale: of course, to say 'most' polynomial functions you have to pick a probability measure on them, and natural ones weight the practical polynomials heavily
06:36:12 <osfameron> eikke: thanks
06:36:19 <Cale> Or s/probability measure/measure/
06:36:56 <Tomsik> Cale: well, good luck in waiting :p
06:37:53 <Tomsik> There's a relatively easy proof of DTIME(n^k) != NTIME(n^k), but it doesn't work if you add even a tiny bit on the left side
06:38:56 <Tomsik> And that DTIME(f(n)) is contained in DSPACE(f(n) / log(f(n))) for f(n) >= n forall n
06:39:02 <Tomsik> It's... pretty weak
06:39:13 <Tomsik> That we don't have much stronger results
06:43:30 <xplat> we've proven that a lot of the more obvious proof techniques in complexity theory won't work for the problems we'd like to use them for
06:43:54 <xplat> (to be as vague as possible)
06:45:06 <xplat> (well, i guess to be as vague as possible i would have to say 'something is true')
06:47:05 <Tomsik> I was wondering why don't people think of relativisation-resistant proofs as hard anymore
06:47:17 <Tomsik> They say it's because of IP = PSPACE
06:47:44 <xplat> no, it's because people who think of them as hard all quit when they found out how many there are :)
06:47:44 <Tomsik> But it's a proof that shows equality -- but what about proofs that show that classes are not equal?
06:51:32 <xplat> maybe they just ascribe the hardness to separation results rather than to non-relativisability?
07:07:18 <sgronblo> Is it possible in haskell to decide which of a functions parameters to partially apply values to? Something like f x = g _ y z ?
07:07:44 <sgronblo> Or is the first applied value always applied to the leftmost parameter?
07:07:46 * ciaranm hands sgronblo a flip
07:08:07 <xplat> you can use flip, or (`g` x) if it's only one
07:08:10 <sgronblo> Yeah I remember flip
07:08:13 <shachaf> sgronblo: What's the _ supposed to represent?
07:08:36 <sgronblo> It's supposed to mean that f's x goes there.
07:08:53 <xplat> you mean f x = g x y z?
07:09:17 <ciaranm> concocting something like c++'s std::bind could be an interesting exercise
07:09:23 <xplat> because that, you know, works as is
07:09:28 <sgronblo> Hmm, I might actually have meant that yeah :)
07:09:58 <byorgey> sgronblo: if you don't want to define f you can always write  \x -> g x y z
07:10:39 <byorgey> a partial application like  g y z  essentially expands to  \x -> g y z x   anyway.
07:11:23 <Twey> http://haskell.spreadshirt.com/oleg-already-did-it-A6499531 — oh, man, I want one of these for CamHac.
07:12:39 <Twey> \x -> g x y z = \x -> flip g y x z = \x -> flip (flip g y) z x = flip g y `flip` z
07:12:54 * Twey is trying to decide whether that's over the boundary or not.
07:13:43 <linduxed> what is the function that joins a number of lists?
07:14:17 <Twey> linduxed: join
07:14:17 <companion_cube> concat ?
07:14:22 <Twey> Also concat
07:14:28 <Twey> But join is shorter and more general
07:14:30 <linduxed> i think it was concat yes
07:14:40 <linduxed> i'll check if that does the trick..
07:14:41 <Twey> > join [[1, 2, 3], [4, 5, 6], [7, 8]]
07:14:42 <lambdabot>   [1,2,3,4,5,6,7,8]
07:14:53 <parcs> which is more general, mconcat or join
07:14:57 <xplat> > let rotl3 = (flip .) . flip in rotl3 g y z $ x :: Expr
07:14:58 <lambdabot>   g x y z
07:15:00 <Twey> parcs: Neither
07:15:14 <Twey> They're not the same operation (they just happen to be on lists)
07:15:44 <parcs> yes but aren't monads monoids or something like that
07:15:45 <linduxed> hmmmm
07:15:50 <Twey> parcs: No; monads are functors
07:15:52 <linduxed> concat worked fine in ghci
07:15:56 <Twey> Not necessarily monoids
07:16:01 <linduxed> but when i tried join i got not in scope
07:16:12 <xplat> monadpluses at particular types are monoids
07:16:14 <Twey> linduxed: You'll need to ‘import Control.Monad’
07:16:16 <parcs> Twey: i'm referring to this (which i hardly understand) http://blog.sigfpe.com/2008/11/from-monoids-to-monads.html
07:16:22 <linduxed> Twey: oh
07:16:55 <xplat> also, monads are a kind of monoid in math, but that doesn't carry over to haskell
07:16:57 <linduxed> ok that worked... but is there a reason for me to use join over concat?
07:17:20 <ciaranm> two characters shorter
07:17:47 <quicksilver> I prefer concat to join but I think it's a matter of taste
07:18:15 <xplat> linduxed: if what you're doing is 'really' a join, you should use join so your function generalizes.  if it really only makes sense for lists, you should use concat
07:18:44 <xplat> (if it makes sense for lists of monoids, you should use mconcat)
07:19:09 <linduxed> xplat: ok, i'll ponder on that one for a second
07:19:23 <parcs> oh wait that post says that all monads are monoids so join is more general
07:20:54 <xplat> parcs: i don't think the second clause follows from the first
07:21:30 <quicksilver> the sense in which all monads are monoids is not related to the thing above about lists and concat.
07:24:02 <erus`> at what point is a function evaluated?
07:24:09 <erus`> when it reaches an IO thing?
07:24:15 <parcs> quicksilver: i asked whether mconcat is more general than join less than a page ago
07:24:32 <quicksilver> parcs: mconcat is differently general to join :)
07:24:43 <quicksilver> they are different generalisations of [[a]] -> [a]
07:24:57 <quicksilver> they are incomparable though.
07:25:21 <xplat> > mconcat $ map (First . Just) [1, 2, 3]
07:25:23 <lambdabot>   First {getFirst = Just 1}
07:25:24 <xplat> > join $ map (First . Just) [1, 2, 3]
07:25:25 <lambdabot>   Couldn't match expected type `Data.Monoid.First
07:25:25 <lambdabot>                            ...
07:25:38 <xplat> hence join is not strictly more general than mconcat
07:25:59 <jonkri> why is there a build error on unicode-normalization on hackage? compact-string is on hackage. http://hackage.haskell.org/packages/archive/unicode-normalization/0.1/logs/failure/ghc-7.0
07:27:43 <xplat> erus`: an expression returning an IO action is evaluated just before the IO action would be executed.  Any expression is evaluated just before it would be pattern-matched on.
07:30:38 <xplat> also, when 'seq a b' is evaluated, first a is evaluated before b is evaluated and returned
07:31:27 * shachaf finds it odd that seq isn't strict in its arguement (when only given one).
07:32:15 <xplat> those three rules are basically all you need to know, although if you do a lot of FFI stuff there might be a couple more things that would be helpful
07:32:58 <xplat> oh, or parallel stuff, i think 'pseq' is a special case too
07:33:33 <roconnor> > seq (seq undefined) 0
07:33:34 <lambdabot>   0
07:33:38 <roconnor> > seq (seq undefined undefined) 0
07:33:39 <lambdabot>   *Exception: Prelude.undefined
07:33:49 <roconnor> > seq (flip seq undefined) 0
07:33:51 <lambdabot>   0
07:34:02 <roconnor> > seq (pseq undefined) 0
07:34:03 <lambdabot>   0
07:36:07 <parcs> > fix ($!) x
07:36:22 <lambdabot>   thread killed
07:37:33 <parcs> > fix id x
07:37:37 <lambdabot>   mueval-core: Time limit exceeded
07:37:39 <parcs> > fix ($) x
07:37:48 <xplat> parcs: redundant, $ is id
07:37:53 <lambdabot>   mueval: ExitFailure 1
07:38:05 <xplat> ... huh?
07:38:10 <parcs> so much for that..
07:38:12 <parcs> :P
07:38:14 <xplat> bleh, CAFs
07:38:32 <int-e> f x = id f x = f `id` x = f $ x
07:38:48 <parcs> int-e: yeah but apparently they're not operationally the same
07:39:05 <xplat> i think $ is defined with 2 arguments
07:39:30 <xplat> which means GHC can compile it differently
07:39:45 <int-e> parcs: ah, might be optimized differently (and yes, ($) is not a replacement for id, only vice versa, because of the restricted type.)
07:40:13 <xplat> it makes different decisions as to when to make what kind of thunks and so on
07:40:26 <shachaf> > fix ($) x
07:40:41 <xplat> strictness analysis might have different results too
07:40:42 <lambdabot>   thread killed
07:41:11 <xplat> ... also, mueval's failure modes don't seem very dependable!
07:41:30 <xplat> O_o
07:42:42 <shachaf> > fix ($) x
07:42:54 * shachaf wonders how many messages you can get out of it.
07:42:57 <lambdabot>   thread killed
07:43:13 <Twey> > text "As many as you like."
07:43:14 <lambdabot>   As many as you like.
07:44:21 <iwtu> > :t "hello"
07:44:22 <lambdabot>   <no location info>: parse error on input `:'
07:44:33 <ior3k> uh, I pasted this on #xmonad, but I think my problem has probably more about not understanding parameterized types properly than with XMonad itself: http://hpaste.org/48408
07:44:59 <ior3k> why exactly do I need to always append 2 type variables to Space if I don't care what they are at all?
07:45:22 <parcs> > vcat $ repeat $ text "As many as you like."
07:45:22 <lambdabot>   *Exception: stack overflow
07:45:46 <shachaf> parcs: No, only up to IRC line length. :-)
07:46:35 <xplat> shachaf: believe me, you wouldn't like more than that many messages
07:48:58 <parcs> ior3k: can you point to an example?
07:49:16 <ior3k> parcs: sorry, what do you mean?
07:49:39 <parcs> ior3k: i see no place where you append two type variables to Space
07:50:18 <ior3k> parcs: oh, sorry, I mean one. Initially I had "l a" instead of "Layout a" but I was advised to change it
07:50:52 <ben> If I have x :: IO [String], why won't x >>= putStrLn . concat work
07:51:11 <Twey> ben: It will
07:51:24 <shachaf> @ty return ["a","b"] >>= putStrLn . concat
07:51:25 <lambdabot> IO ()
07:51:49 <ben> For some reason I get something about bytestrings
07:52:59 <ior3k> parcs: the problem is that I don't really understand exactly what (or why) I should put there.... I looked at some other XMonad modules, (e.g., PerWorkspace, and notied it uses LayoutClass as a constraint, but when I tried to use it it says LayoutClass is not a type
07:53:13 <ior3k> so there's definitely something I'm missing regarding type parameters
07:53:22 <shachaf> ben: That has nothing to do with the line you quoted.
07:53:31 <shachaf> Maybe you imported ByteString.putStrLn or something of the sort?
07:54:24 <ben> I only seem to import qualified ByteString
07:54:43 <ben> Oh, I broke (.)
07:54:46 <ben> that was unexpected
07:55:45 <ben> Dreaded monomorphism restriction, indeed. I said import Prelude hiding ((.)) and (.) = fmap, like, a week ago and forgot all about it. And then used . to map over bytestrings or something silly.
07:58:56 <iwtu> Int can have a negative value. What's type only for non-negative value?
07:59:06 <Lemmih> iwtu: Word.
07:59:17 <shachaf> Word for an unsigned machine integer.
07:59:18 <iwtu> :)
07:59:40 <shachaf> There's no type fro natural numbers, though.
08:29:35 <monadic> is there a to make sure my Gen instance is working properly from GHCi? That is, a way to do Gen a -> IO a or (Seed Type) -> Gen a -> a
08:29:51 <monadic> using QuickCheck 2.4
08:30:14 <Cale> monadic: sure, one sec let me look it up
08:30:18 <quicksilver> monadic: sample or sample'
08:30:36 <monadic> quicksilver: Thanks.
08:30:39 <quicksilver> sample' gives an array of 20 tests.
08:30:46 <quicksilver> sample prints the
08:30:49 <quicksilver> s/array/list/
08:30:55 <Cale> right, right
08:31:01 <Cale> quicksilver beat me to it
08:31:04 <Cale> file:///home/cale/.cabal/share/doc/QuickCheck-2.4.0.1/html/Test-QuickCheck-Gen.html
08:31:08 <Cale> errrr
08:31:09 <Cale> lol
08:31:24 <Cale> Things are awkward now that I'm using local documentation, can't do that anymore :P
08:31:41 <Cale> http://hackage.haskell.org/packages/archive/QuickCheck/2.4.1.1/doc/html/Test-QuickCheck-Gen.html
08:31:44 <geheimdienst> cale, link doesn't work. please put your hard drive on the internet
08:31:48 <Cale> unGen :: StdGen -> Int -> a
08:31:53 <Cale> there's also that
08:32:13 <Cale> Which would let you use the stuff from System.Random with it.
08:32:28 <shachaf> Cale adheres to the UNIX rule of starting a username with a lowercase character on his local machine?!
08:32:32 * shachaf thought he'd be above that.
08:33:09 <ion> I wouldn’t mind being above case-sensitive filesystems, but alas, life isn’t that nice.
08:33:19 <monadic> is it even legal to start with a capital? haha
08:33:26 <monadic> I've never tried
08:34:06 <Cale> Well, I'm using a unix-ish machine...
08:35:07 <ion> I don’t see why not. An interesting question is what a mail delivery agent does if users foo and Foo exist and someone sends an email to FOO@… (since email addresses are case-insensitive).
08:35:17 <quicksilver> uppercase is perfectly legal in unix usernames
08:35:22 <quicksilver> its just unconvential.
08:35:35 <quicksilver> having two usernames which differ only in case is probably illegal though.
08:35:46 <Cale> I don't want to have to hit the shift key while logging in
08:35:52 <shachaf> quicksilver: Not according to whatever installer I was using when I installed some UNIX for the first time!
08:36:03 <Cale> Though, I guess I have an uppercase letter in my password, so :P
08:36:04 <shachaf> I guess it was the second time. And I suppose it was Debian.
08:36:39 <quicksilver> shachaf: tell that to the exim maintainers
08:36:46 <quicksilver> "Debian-exim" has an uppercase D
08:36:50 <ion> Cale just reduced the time needed to bruteforce his password by orders of magnitude.
08:36:53 <quicksilver> or it did when I first installed exim at least.
08:37:16 <quicksilver> ion: email address are, technically, case-sensitive in the local part.
08:37:35 <quicksilver> ion: (or at least, that part is up to the local agent to interpret, and it is permitted to interpret case if it chooses)
08:38:06 <quicksilver> but most local agents choose to interpret them by case folding.
08:38:50 <Cale> I'm not sure about that actually. Knowing that I *do* have at least one uppercase letter in my password doesn't cut the search space down all that much.
08:39:14 <Tomsik> It does
08:39:20 <Cale> It does cut it down...
08:39:33 <quicksilver> but not by an order of magnitude (or anything close)
08:39:58 <quicksilver> the number of passwords which contain no uppercase later (which have been eliminated) are a very small fraction of the whole.
08:40:05 <ion> You said you have “an” uppercase letter. :-)
08:40:17 <benmachine> especially given that we'd reasonably believe it was true anyway
08:40:59 <ion> benmachine: Why would anyone lie when giving specifics in public about the kind of password she uses?
08:41:09 <shachaf> > length . filter isUpper $ ['\000'..]
08:41:11 <lambdabot>   1452
08:42:39 <Cale> Create a user with a newline in the username.
08:43:21 <sshc> How commonly used are QSem(N) (semaphores) in Haskell?  Is there an alternative that I should consider using?
08:43:33 <Cale> sshc: infrequently, I think
08:43:43 <Cale> sshc: MVar/Chan is usually enough
08:43:59 <monadic> sshc: MVar/Chan or TVar/TChan for STM are most common I think
08:44:04 <Cale> But, it depends on what you're doing.
08:44:12 <quicksilver> yeah, the name QSemN scared me off
08:44:20 <quicksilver> so I rewrote the functionality I needed in MVar or Chan.
08:44:21 <quicksilver> ;)
08:44:29 <sshc> Cale: Can their <being using occasionally> be justified, or are they generally deprecated?
08:45:17 <ion> I’ve never used non-ASCII characters in my passwords (now your searchspace for my passwords is slightly smaller :-P). I wonder if using them causes a huge amount of pain from charset issues?
08:45:26 <Cale> sshc: Not deprecated at all
08:45:27 <sshc> (I'm not actually using them directly, but considering supporting them extensively in a library I'm writing)
08:45:36 <sshc> *nod*
08:45:38 <sshc> Thanks.
08:45:46 <Cale> sshc: Just not frequently the solution to a problem which actually occurs? At least I haven't needed them.
08:46:43 <Cale> Out of curiosity, what do you need quantity semaphores for?
08:48:02 <sshc> I don't.
08:48:02 <Cale> oh
08:48:14 <Cale> er, what kind of support then?
08:52:24 <mauke> The paste D7Tn8jXc has been copied to http://hpaste.org/48212
08:52:47 <djahandarie> mauke, why is that firing when there is no paste to copy? :p
08:53:14 <ion> And why is that sent with PRIVMSG instead of NOTICE?
08:53:26 <djahandarie> Because no one actually uses NOTICE.
08:54:25 <benmachine> ion: given that sometimes using full stops is too much to ask, I imagine it does, yes (wrt password charsets)
08:56:40 <byorgey> shachaf: oh, sorry I missed your question earlier.  Yes, there a probably ways to restrict type-level lambdas so as to keep typechecking decidable.
08:56:56 <byorgey> shachaf: see e.g. the work on "higher-order pattern unification".
08:57:03 <byorgey> I'm not familiar with the details though.
08:58:07 <djahandarie> byorgey, you missed out on Pizza Research Institute man. Great pizza.
08:58:36 <byorgey> djahandarie: so I've been told.  I'm sorry I missed out.
08:59:34 <shachaf> ((==) `on` location) byorgey djahandarie?
08:59:50 <shachaf> Oh, yes, OR.
08:59:51 <byorgey> False
09:00:17 <djahandarie> Only if your equality is parametrized by time and it's set awhile ago.
09:00:20 * djahandarie afk
09:01:30 <byorgey> shachaf: I was at OPLSS with djahandarie but left early.
09:01:37 <shachaf> Ah.
09:01:50 <byorgey> hence I missed out on pizza, apparently.
09:02:12 <shachaf> byorgey: You left early to visit us in CA, right?
09:02:35 <byorgey> right
09:02:44 <byorgey> I did visit CA, but only for about two hours.
09:03:12 <byorgey> if you didn't come visit me while I was in the SFO airport then it's not my fault.
09:03:27 <shachaf> byorgey: You should've mentioned!
09:03:42 <byorgey> heh, are you in the SFO area?
09:04:03 <xplat> in the old days, it wasn't illegal to start a unix username with a capital, it was impossible
09:04:06 <wli-needjob> nus: A higher priority is probably a more effective method of extremizing the deviation.
09:04:11 <byorgey> honestly I wouldn't have had time to hang out, I spent the entire time waiting in line to get through security
09:04:13 <shachaf> Well, within half an hour or so. :-)
09:04:34 <byorgey> and then sprinting to my gate, just barely making it on before they closed the jetway door immediately behind me
09:04:43 <shachaf> Maybe a bit more. Probably too far to warrant a trip to the airport, but still.
09:04:49 <xplat> because if you tried to log in with such a username, unix would assume you were using a weird terminal that sent lowercase letters as capital
09:04:57 <shachaf> byorgey: Why did you have to go through security?
09:05:15 <byorgey> shachaf: I flew into Terminal 1 and left out of Terminal 3
09:05:51 <byorgey> the security guard I asked said I had to exit security to get from Terminal 1 to Terminal 3, I don't know whether that was actually true
09:06:21 <xplat> quicksilver: also, email addresses are case-sensitive in the local part, except for postmaster.  all casings of postmaster must go to the same mailbox.
09:06:42 <shachaf> Seems a bit odd. Oh, I'm probably thinking of SEA, not SFO.
09:09:01 <edwardk> byorgey: yowsa
09:10:02 <xplat> trolled by a security guard?
09:10:06 <edwardk> hrmm, looks like i'll need to pull free back out of comonad-transformers and into its own package. =( the undecidable instances it requires are the only ones in that package
09:10:14 <byorgey> edwardk: yeah, it was pretty ridiculous.  I have never seen such a long line for security.  It felt like I was waiting to get on a rollercoaster, except it was less exciting and when waiting for a rollercoaster the people behind you in line to not constantly complain about having to wait in a long line
09:10:25 <edwardk> hah
09:10:38 <xplat> edwardk: why does a free comonad require undecidable instances?
09:10:38 <byorgey> xplat: hah, I hope not
09:10:49 <edwardk> at least at a rollercoaster you can get one of those little passes that let you wander around and just walk up when your buzzer goes off
09:10:49 <shachaf> byorgey: Fly OAK next time!
09:10:57 <edwardk> xplat: Eq, Ord, Show, Read
09:11:02 * shachaf had a good experience with the security line at OAK, at least.
09:11:18 <edwardk> xplat: instance (Eq (f (Free f a)), Eq a) => Eq (Free f a)
09:11:25 <byorgey> shachaf: I doubt there are many flights between Oakland and Eugene
09:11:28 <edwardk> etc
09:12:10 <shachaf> I suppose so.
09:12:24 <edwardk> xplat: there is also the complication that i really should make the instances for MonadFoo live with the free monad. the transformers <-> mtl split isn't something you can model outside of the transformers package. everyone else is forced to be monolithic if they want to provide instances for the mtl types.
09:12:30 <edwardk> er mtl classes
09:12:41 <xplat> edwardk: ah, the Eq (f (Free f a)) doesn't recurse the right way
09:13:07 <edwardk> xplat: yeah, you can hack Show with some chicanery
09:13:40 <edwardk> xplat: instance (Show (f Showable), Show a) => Show (Free f a)
09:14:03 <edwardk> where you make Showable a newtype that looks like newtype Showable = Showable (Int -> String -> String)
09:14:38 <edwardk> and you _don't export Showable_, so that any instance that covers Showable must technically be a universally quantified instance over that argument.
09:14:55 <edwardk> but you can't do that for Eq, Ord, etc.
09:15:29 <xplat> any class with binary operations, basically
09:15:40 <jeena> How are you supposed to combine a State Monad and a IO Monad to be able to print out the state sometimes? I tried https://gist.github.com/1049251 but I'm only getting errors
09:15:41 <edwardk> well, Read is also problematic
09:15:56 <edwardk> StateT s IO
09:16:06 <jeena> Ah I see
09:16:10 <xplat> ah, so it only works with linear negative occurrences
09:16:23 <shachaf> Cale: Did you see that?
09:16:29 <edwardk> yeah
09:16:44 <edwardk> that is the only hack i have so far for this sort of thing
09:16:50 <byorgey> jeena: with StateT s IO  you can use the State operations as usual, and you can wrap IO operations using the 'liftIO' function to lift them into the StateT s IO monad
09:16:54 <edwardk> i used it in my ad package IIRC.
09:16:55 * hackagebot crypto-api 0.6.2.1 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.6.2.1 (ThomasDuBuisson)
09:17:16 <jeena> Ok thanks, I'll try that
09:17:23 <HugoDaniel> i need a very fast one-way hashing function, is there something like that in hackage ?
09:17:32 <byorgey> like   do { s <- get; liftIO (print s); put (s + 1) }  or whatever
09:17:33 <shachaf> const 0
09:17:41 <shachaf> That's as one-way as you can get.
09:17:54 <edwardk> shachaf: =P
09:18:03 <xplat> also about as fast as you can get
09:18:24 <edwardk> hugodaniel: do you need it cryptographically strong or just good enough for a non-attacked hash table?
09:18:26 <xplat> not very good at avoiding collisions, though
09:18:27 <shachaf> ✓, ✓
09:18:48 <edwardk> hugodaniel: if you don't need cryptographically one-way, there is Hashable.
09:19:21 <xplat> cryptographically strong and fast are not very compatible though
09:19:40 <shachaf> "cryptographically strong and fast" -- sounds like a superhero.
09:19:50 <edwardk> if you _do_ need cryptographic strength, there is always http://hackage.haskell.org/package/Crypto-4.2.3
09:19:53 <HugoDaniel> edwardk: i just need to create etags for my http headers
09:20:05 <jeena> very nice, it prints, thanks!
09:20:49 <edwardk> hugodaniel: then shachaf's suggestion would probably be a bad idea ;)
09:21:04 <HugoDaniel> :D
09:21:09 <xplat> technically you could do fine with a CRC64, maybe even CRC32, depending on your usage scenario
09:21:20 <edwardk> then i'd probably just use Hashable
09:21:56 <HugoDaniel> cool :)
09:21:57 <HugoDaniel> thanks
09:23:04 <xplat> although if you use a crypto hash then you open things up to users providing distributed p2p cacheing if you get super-popular.  not that it happens often even if you do.
09:23:21 <edwardk> hah
09:24:19 <HugoDaniel> :D
09:25:22 <xplat> also, for people who are behind large institutional caches, using a weak hash opens up a possibility of large-scale cache poisoning via mitm being profitable for someone even if one-on-one mitm wouldn't be
09:25:39 <HugoDaniel> oh
09:25:45 <HugoDaniel> i guess ill have to use CRC666 then
09:26:17 <Cale> shachaf: Did I see what?
09:26:22 <Cale> (probably not)
09:26:52 <shachaf> Cale: edwardk is recommending StateT s IO.
09:26:55 <Cale> hehe
09:27:07 <Cale> I guess it's the answer to the question at hand
09:27:25 <shachaf> What would your answer be?
09:28:26 <Cale> Depends on more than the example provides.
09:28:58 * hackagebot scrypt 0.2.1 - Stronger password hashing via sequential memory-hard functions.  http://hackage.haskell.org/package/scrypt-0.2.1 (FalkoPeters)
09:29:47 <HugoDaniel> ill use scrypt! this didn't happen by chance
09:29:57 <HugoDaniel> everything has a purpose, we are all connected
09:30:07 <xplat> newtype IOState s a = IOState (ReaderT (IORef s) IO a)
09:30:30 <xplat> HugoDaniel: New York Telephone?
09:31:14 <azaq23> also, selection bias
09:38:39 <hello0292> hello
09:39:43 <hello0292> hello/
09:39:47 <azaq23> hi
09:39:58 <hello0292> Whats happening ?
09:40:09 <shachaf> Somebody set up us the bomb.
09:40:24 <hello0292> What?
09:40:29 <azaq23> You're in the freenode #haskell channel right now. Press one for further instructions
09:40:43 <hello0292> 1
09:41:21 <ion> Move all ZIG
09:42:07 <hello0292> So what is being discussed in this room?
09:44:12 <ion> Him http://en.wikipedia.org/wiki/Gordon_Haskell
09:45:19 <tommd> lol
09:46:02 <vold_> While trying to lazily implement find, I try to use a WriterT [FilePath] IO (). Here's my code (http://hpaste.org/48420). I'm not sure why this isn't lazy yet.
09:46:23 <vold_> If somebody has a minute hints would be greatly appreciated
09:46:58 <azaq23> I don't always haskell, but when I do...
09:47:33 <xplat> that looks like a bad idea ...
09:47:52 <tommd> Well, 'trace' will force 'dir' for one.
09:48:10 <tommd> And using lists in a Writer is generally bad
09:48:30 <tommd> and yikes! Unsafeness, refactor! refactor!
09:48:34 <vold_> okay.
09:48:59 <vold_> I'm really really fresh, this is my first try to build something with haskell that actually works.
09:49:47 <vold_> any hint on how this can be done? ListT IO? (In case you haven't noticed yet, transformers still really confuse me)
09:50:12 <xplat> i think that mapM_ is going to kill the laziness
09:50:19 <tommd> You don't even need the unsafe calls, they are worthless
09:50:32 <xplat> mapM_ find' contents
09:51:02 <vold_> tommd: okay. I thought that all IO stuff was strict without unsafeInterleaveIO.
09:51:19 <xplat> if you want to do what you're doing, you should probably build a list directly rather than use WriterT
09:53:39 <tommd> I annotated it with my take
09:53:50 <tommd> http://hpaste.org/48420
09:53:52 <xplat> because you have to basically replace every (x:y) with (x:unsafeInterleaveIO y) and the WriterT [Filepath] will build a lot of them where you can't get to them
09:53:56 * tommd runs off
09:54:24 <tommd> (after I suggest using dlist instead of built-in lists for your Writer)
09:54:40 <vold_> thanks
09:55:34 <xplat> i don't see how that annotation even tries to be lazy, in fact it doesn't
09:56:54 <vold_> hm. that looks a nicer than my version, but I have a feeling that it's more "low-level"
09:57:52 <xplat> #48422 is doing the same thing as #48420 more simply, but not doing what #48420 is trying to do
09:58:21 <xplat> i wouldn't say either is more 'low-level'
09:59:35 <xplat> i should explain that being 'lazy' as in 'lazy IO' is very different from being lazy in the way of ordinary pure code and it takes very different techniques
09:59:53 <vold_> okay.
10:00:27 <vold_> I thought that this laziness was a property of the monad(s) being used.
10:01:26 <xplat> no, like i said IO-laziness is very special and requires, in addition to ordinary laziness, very careful use of 'unsafeInterleaveIO' to achieve
10:01:31 <c_wraith> yes, but IO is a strict monad
10:01:42 <benmachine> vold_: maybe this is interesting http://www.reddit.com/r/haskell/comments/cs54i/how_would_you_write_du_in_haskell/
10:02:04 <c_wraith> if you write to a file, you don't want to have to force the result to cause the file to actually be written.
10:02:06 <benmachine> it contains a few different approaches for doing directory traversal stuff in sensible ways
10:02:38 <vold_> benmachine: thanks, I'll read it right now
10:02:52 <c_wraith> That's why IO is strict, by default.  Making it lazy means that its effects are done at unpredictable times, if at all.
10:03:03 <vold_> c_wraith: I understand that. I naively thought it could help to use unsafeInterleaveIO everywhere :)
10:03:09 <benmachine> vold_: it's quite long, feel free to skim :P
10:03:23 <c_wraith> vold_: well, yes.  "unpredictable" is the key word there :)
10:03:27 <xplat> these drosophy1lum s are multiplying as fast as fruit flies.  and dropping like them too.
10:03:35 * monochrom feels sad about the pervasive abuse of "strict". no, strictness is not enough to specify order
10:04:04 <vold_> c_wraith: I don't care about unpredictability with this tool, actually. I'm having a hard enough time getting it to work at all :)
10:05:13 <xplat> the recommended way to do this lately is to make find into an enumerator to feed FilePaths to an iteratee
10:14:25 <HugoDaniel> i like the OverloadedStrings extension
10:17:47 <burp> we all do :)
10:27:11 <FUZxxl> When is the release of GHC 7.2?
10:30:32 <Igloo> "soon"
10:35:11 <ezyang> Man, I'm so spoiled by GHC's memory profiling.
10:35:35 * shachaf is so spoiled by every-other-language's stack traces.
10:36:52 <hpaste> “Stoyan Peev” pasted “Parsing” at http://hpaste.org/48423
10:38:38 <vold_> \o/ I made a lazy version. It's really ugly, though.
10:42:47 <hpaste> vold_ pasted “lazy find, working but ugly” at http://hpaste.org/48424
10:43:47 <vold_> any comments on how to make this nicer would be really great
10:47:50 <Cale> There might be a way to reduce the number of unsafeInterleaveIO's that you do, but fundamentally, it's always going to be sorta ugly (because it's semi-unsafe, and so a bit of that ugliness is by design)
10:48:23 <parcs> vold_: the order in which you're concatenating the lists is slow
10:48:39 <parcs> and probably anti-lazy
10:48:42 <Cale> oh, yes
10:48:53 <Cale> It should be files ++ concat subFind
10:49:12 <Cale> Unless order matters
10:49:25 <tommd> Hence my suggestions on using dlist.
10:49:38 <Cale> Or just list functions...
10:50:37 <parcs> i shouldn't say anti-lazy, that doesn't make any sense. but one would assume that the least-deep directories come first, not the most deep
10:50:38 <vold_> I am actually trying to list them in that order.
10:51:05 <vold_> If I didn't overlook something, this produces output like find
10:51:23 <vold_> i.e. / | /folder | /folder/file | /file
10:52:11 <vold_> I'll look into dlists on another day
10:52:18 <parcs> what about files ++ path : concat subFind ?
10:53:35 <vold_> lol. Now that I look at it again, find doesn't even split directories and files.
10:53:59 <parcs> and you're not catching IO errors (i.e permission denied or something)
10:54:15 <vold_> yup. that's on my todo
10:56:47 <hpaste> “Stoyan Peev” annotated “Parsing” with “Parsing (annotation)” at http://hpaste.org/48423#a48425
10:58:34 <hpaste> “Stoyan Peev” annotated “Parsing” with “Parsing (annotation)” at http://hpaste.org/48423#a48426
10:58:43 <parcs> vold_: a suggestion: http://paste.pocoo.org/show/421453/
11:00:04 <parcs> that should probably mimic the output of find
11:02:21 <vold_> I think I'll go for http://paste.pocoo.org/show/421456/ until I someday decide to look into iteratee
11:02:47 <xplat> parcs: doesn't yours completely fail to return files?
11:03:11 <xplat> (i.e. only returns directories)
11:04:36 <parcs> yeah so what! :P
11:04:53 <vold_> :)
11:06:09 <vold_> I am a bit disappointed about how simple this solution is. I looked at WriterT [FilePath] ListT IO [FilePath] or something like that for a few hours =/
11:07:32 <parcs> xplat: but actually it only doesn't return files within a directory only if there are no subdirectories. and on top of that, it returns duplicate values for each subdirectory in a directory. my logic is completely screwed
11:07:53 <vold_> logic is overrated anyways.
11:08:16 <parcs> if it type checks it works!
11:09:10 <thoughtpolice> those are the rules 'round here!
11:11:33 <eddayyy> what should you do in order to compose monads in a nice way?
11:14:11 <c_wraith> eddayyy: that's not fully known, yet.  Monad Transformers are...  a well-understood option, but they have some significant limits, too
11:14:13 <hpaste> eddayyy pasted “The wrong way to do it?” at http://hpaste.org/48427
11:14:53 <eddayyy> c_wraith: as you can see by my code i'm pretty lost at this early stage
11:15:29 <c_wraith> eddayyy: are you writing your own Riak library?
11:15:46 <eddayyy> c_wraith: http://github.com/et4te/snap-extension-riak
11:16:03 <eddayyy> c_wraith: its a snap extension to support riak as a db backend
11:16:33 <c_wraith> eddayyy: I wouldn't do that...  The entire snap extension mechanism is going to deprecated soon.
11:16:33 <eddayyy> but its not complete, missing a few final touches... and awaiting the arrival of secondary indices
11:16:43 <eddayyy> c_wraith: really?
11:16:44 <hpaste> “Stoyan Peev” annotated “Parsing” with “Parsing (annotation)” at http://hpaste.org/48423#a48428
11:17:07 <c_wraith> eddayyy: yep.  It's really not a very good design, and doug and gregory have been working on a much better one
11:17:27 <eddayyy> c_wraith: interesting. is there a new design i can see somewhere? or should i give up on this lib and do ?
11:18:06 <c_wraith> eddayyy: the new design isn't public yet.  Heck, I don't even know anything about it (though that's because I said I wouldn't have time to contribute much to that effort)
11:18:25 <eddayyy> c_wraith: so my efforts were in vain? :(
11:18:38 <c_wraith> eddayyy: well.  not if you learned something? :)
11:18:42 <luite> :)
11:19:15 <luite> so far, my efforts writing websites in haskell have been rather... frustrating...
11:19:25 <c_wraith> eddayyy: but my first comment was going to be "also, you know bos is writing a riak library...  If you're not using that, you should be"
11:19:31 <eddayyy> c_wraith: i learnt tons, but i wanted to contribute back somehow... *sigh*
11:20:03 <eddayyy> c_wraith: sure i'm using boss riak lib :)
11:20:43 <c_wraith> eddayyy: well, you still can.  I suspect that whatever the new mechanism ends up being, you'll be in a good position to implement it, based on your code and experience
11:20:58 <c_wraith> eddayyy: there'll just be a bit of a delay before you get there.
11:21:49 <c_wraith> eddayyy: anyway.  Let's forget about that for the moment, and look at your original question :)
11:22:10 <eddayyy> c_wraith: :) would be nice to get some nice monad composition going
11:22:49 <c_wraith> eddayyy: your MonadRiak class seems useless.  you could write a function with that type signature, given just the MonadIO constraint
11:23:27 <c_wraith> eddayyy: what idea is that class supposed to be conveying?
11:23:28 <eddayyy> c_wraith: i was initially thinking of doing it this way so that the type returns an IsContent data type rather than raw content
11:24:07 <eddayyy> c_wraith: so returns a User data type directly transformed from JSON etc, rather than Content
11:26:27 <eddayyy> so here getObject may return any known IsContent data type
11:26:41 <eddayyy> the code doesn't work very well though
11:26:42 <eddayyy> :/;
11:26:51 <c_wraith> eddayyy: I'm asking about the other class, though.
11:27:16 <c_wraith> eddayyy: it appears to do nothing.  Assuming you have a riak lib function that's (Connection -> IO a) -> IO a
11:27:32 <eddayyy> c_wraith: oh, uhm, it was needed in the snap extension at some point
11:28:08 <eddayyy> instance (MonadAuth m, MonadRiak m) => MonadAuthUser m Params where
11:28:23 <c_wraith> eddayyy: to make it interesting, you should at least change it to class (MonadIO m) ⇒ MonadRiak m where withDB ∷ (Connection → m a) → m a
11:29:03 <c_wraith> eddayyy: otherwise, that class is just a meaningless restriction on top of MonadIO
11:29:14 <eddayyy> c_wraith: ah yeah :P
11:29:48 <eddayyy> i should probably mention im bignoob with haskell
11:30:39 <eddayyy> c_wraith: so what i could do here is to define getObj etc within MonadRiak instead?
11:30:56 <c_wraith> eddayyy: yes, that sounds like a reasonable thing to do
11:31:54 <c_wraith> eddayyy: actually, nevermind.  It's not necessarily a reasonable thing to do.  You have two different things going on...  A withConnection function, and then getter/setter functions that use that connection
11:32:11 <c_wraith> err, withDB in this case
11:33:32 <c_wraith> you need to look at the use patterns for each.  get/put functions that don't take the connection would require the connection to be in the environment somehow
11:33:55 <eddayyy> c_wraith: yeah thats why i needed to compose the two monads, i always need the connection & other state in the environment
11:33:56 <c_wraith> There are a lot of different ways you could approach this, design-wise.  I'm not sure what the best is.
11:34:24 <eddayyy> c_wraith: how would you have done it? :D
11:34:54 <c_wraith> If you just explicitly pass the connection, rather than getting it from the environment, it's probably the simplest.  You wouldn't need either of those classes, then
11:35:34 <eddayyy> c_wraith: then theres no design :P
11:35:58 <eddayyy> c_wraith: i could do it the simple way but i'm sure theres a more elegant approach than this, to hide the environment i mean
11:36:13 <c_wraith> eddayyy: sure, but you have to consider the use cases.  Is that lack really an issue?  Explicit control over connection scoping is really handy
11:36:34 <eddayyy> c_wraith: hmm good point.
11:36:37 <gwern> running my usual repo updates today. it's always interesting how many github repos are no longer available or around
11:36:40 <gwern> lots of flux
11:37:08 <eddayyy> c_wraith: i think it would be useful at the very least to have some way of getting riak objects back fully converted though, provided what i'm getting has an IsContent instance
11:37:58 <c_wraith> eddayyy: alternatively, you could do something with the connection scoping to hide the state.  This one's an interesting idea, but I'm not sure it's good.
11:38:26 <eddayyy> c_wraith: actually what i have in the environment is not a connection, its a connection pool
11:38:34 <c_wraith> eddayyy: even better. :)
11:38:57 <eddayyy> c_wraith: the Connection -> IO a is the connection that gets passed into the lambda, but the connection is fetched from a pool
11:39:09 <eddayyy> so there is explicit control over the connection here, just not of the pool
11:39:49 <eddayyy> c_wraith: i would think it makes sense to hide the details of the pool though. aside from initialization parameters theres not much interesting there.
11:40:40 <eddayyy> thats not to say the implementation is uninteresting, just the interface :P
11:41:24 <hpaste> c_wraith annotated “The wrong way to do it?” with “The wrong way to do it? (annotation)” at http://hpaste.org/48427#a48431
11:41:41 <c_wraith> eddayyy: there's an alternative concept
11:41:49 <c_wraith> eddayyy: I'm not sure it's actually any good
11:42:40 <c_wraith> eddayyy: actually, that should be ReaderT, not StateT
11:42:57 <c_wraith> but in any case...  It hides passing the connection around
11:43:22 <c_wraith> and doesn't, in fact, introduce any new type classes
11:44:15 <o1iver> hi everyone. I am having a first look at the Happy parser, but I am struggling... How would I define a rule for a list like this "[a,b,c]"?
11:44:42 <xarch_> hello
11:44:43 <lambdabot> xarch_: You have 1 new message. '/msg lambdabot @messages' to read it.
11:44:45 <o1iver> I am trying to parse single-liuen statements like this: "abc.[a-z]
11:45:39 * hackagebot randproc 0.2 -   http://hackage.haskell.org/package/randproc-0.2 (DavidBanas)
11:46:46 <xarch_> I heard Lawvere tried to teach topology to high-school students, do you know if he wrote some topology book for high schoolers?
11:46:55 <o1iver> that would be a token list of this type: [TokenChar 'a', TokenChar 'b', TokenChar 'c', TokenDot, TokenLeftSquareBracket, TokenChar 'a', TokenHypen, TokenChar 'z', TokenRightSquareBracket]
11:47:01 <Somelauw> When doing math and I need to give a function definition, I sometimes feel tempted to write a lambda.
11:47:29 <xarch_> (or something about topology for high school students)
11:48:06 <c_wraith> eddayyy: the reason I'm not sure of the usefulness of that setup is that it might introduce a bunch of extraneous "lift"s into your action that's running inside withDB
11:48:34 <Tyr42> I was reading Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire by Erik Meijer, Maarten Fokkinga and Ross Paterson
11:48:57 <Tyr42> and can't help noticing similarities in some of the functions
11:49:01 <Tyr42> to arrows
11:49:40 <xarch_> I think the link is rather about point-free
11:49:56 <xarch_> hm
11:50:35 <xarch_> and functions like +++, |||, *** or &&& are also, I think, used a lot in category theory
11:50:45 <xarch_> but with different names
11:51:28 <joe6> > elemIndices "**gpsim> "  "**gpsim> junk jnuk **gpsim> "
11:51:29 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:51:29 <lambdabot>         against inferred ty...
11:51:51 <hpaste> c_wraith annotated “The wrong way to do it?” with “The wrong way to do it? (annotation) (annotation)” at http://hpaste.org/48427#a48433
11:51:59 <joe6> is there a function that can search a substring within a string and return the number of occirrences.
11:52:28 <joe6> s/occirrences/occurrences/
11:53:19 <c_wraith> eddayyy: Oh, I see now why you had MonadRiak.  Ok, the latest paste is a suggestion for how you could do what you want, I think.
11:53:43 <Tyr42> Oh, I see someone translated it
11:53:44 <Tyr42> http://blog.ezyang.com/2010/05/bananas-lenses-envelopes-and-barbed-wire-a-translation-guide/
11:54:10 <shachaf> > length . filter ("**gpsim> " `isPrefixOf`) . tails $ "**gpsim> junk jnuk **gpsim> "
11:54:12 <lambdabot>   2
11:54:20 <shachaf> How efficient!
11:54:34 <stepcut> let's say I have a list of path segments like ["foo/bar", "baz"]. does System.FilePath include an function that will check for special characters in those path segments (for example, in Unix, / can not appear in a path segment, it can only be used as a path separator)
11:54:34 <djahandarie> xarch_, no, but yrlnry has written or started writing, or something like that, a simple intro to topology (I think for high school students).
11:54:45 <joe6> the ByteString library has findSubStrings
11:54:58 <joe6> :t findSubstrings
11:54:59 <lambdabot> Not in scope: `findSubstrings'
11:55:13 <joe6> > findSubstrings
11:55:14 <lambdabot>   Not in scope: `findSubstrings'
11:55:29 <Cale> joe6: length . filter (isPrefixOf needle) . tails $ haystack
11:55:30 <joe6> shachaf, thanks.
11:55:54 <djahandarie> xarch_, http://blog.plover.com/math/topology-doc.html
11:56:00 <joe6> Cale, thanks.
11:59:42 <yrlnry> djahandarie:  the intention was that it was for first-year CS grad students.
12:06:34 <c_wraith> @quote stack-calculator
12:06:34 <lambdabot> stack-calculator says: let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
12:06:45 <c_wraith> I think I just learned CPS
12:08:37 <shachaf> Someone posted a link yesterday -- maybe ddarius? -- to something involving writing RPN in Haskell. Does anyone here have it?
12:09:04 <thoughtpolice> shachaf: http://www.eecs.usma.edu/webs/people/okasaki/hw02postfix.pdf
12:09:09 <thoughtpolice> (irclogs for great justice!)
12:09:39 <thoughtpolice> also: < ddarius> Though, Ralf Hinze finally published a paper that generalizes this to LR grammars if I recall correctly.  That paper has been available unpublished for several years as well.
12:10:12 <shachaf> thoughtpolice++
12:11:03 <monochrom> heh c_wraith
12:11:29 <shachaf> Oh, the reason I thought of this was the quote c_wraith just posted.
12:11:36 * shachaf managed to forget that remarkably quickly.
12:12:50 <monochrom> damn, hw02 means haskell workshop 2002, not homework #2
12:14:44 <monochrom> gross, the types of the combinators grow huge
12:15:26 <ddarius> monochrom: It would be rather narrow-minded to limit one's self to only those terms that have small typse.
12:16:01 <monochrom> I just worry for the compiler
12:16:18 <joe6> any suggestions on how I can have a pattern guard similar to this:  | hReady hout == False && isSuffixOf "**gpsim> " recvd
12:16:25 <joe6> :t hReady
12:16:25 <lambdabot> Not in scope: `hReady'
12:16:33 <joe6> :t System.IO.hReady
12:16:34 <lambdabot> GHC.IO.Handle.Types.Handle -> IO Bool
12:16:59 <joe6> could probably use a lambda function and can I use >> in a guard?
12:17:07 <joe6> i meant >>=
12:17:21 <shachaf> No, because a guard's type is Bool.
12:17:23 <monochrom> "For example, the factorial function in Section 6 uses begindef with 18 arguments and makes GHC noticeably sluggish"
12:17:31 <joe6> ok, thanks.
12:17:59 <monochrom> "The recursive Fibonacci function ... uses begindef with 24 arguments, and crashes the compiler after a long wait" (!)
12:24:14 <ddarius> monochrom: That was in 2002.
12:24:34 <monochrom> oh heh
12:25:05 <monochrom> today you just double the program length to crash today's compiler
12:26:04 <k0ral> waw
12:26:18 <k0ral> first time I met such an ugly error
12:26:24 <k0ral> undefined reference to `__stginit_hbrozm0zi5zi3_Pathszuhbro_'
12:26:35 <k0ral> looks like a C linker error
12:27:02 <k0ral> happens since last GHC upgrade
12:28:27 <ddarius> It is a linker error.
12:28:37 <ddarius> (The linker doesn't have anything to do with C.)
12:29:24 <shachaf> Well, it's used for linking compiled C code.
12:29:27 <acowley> cabal clean your hbro directory
12:29:38 <monochrom> preflex: zdec __stginit_hbrozm0zi5zi3_Pathszuhbro_
12:29:38 <preflex>  __stginit_hbro-0.5.3_Paths_hbro_
12:30:04 <k0ral> ?
12:30:04 <dbanas> ANNOUNCE: v0.2 of `RandProc` library released to HackageDB: http://hackage.haskell.org/package/randproc
12:30:37 <acowley> k0ral: what is the "?" for?
12:30:50 <k0ral> acowley: for what monochrom did
12:30:58 <k0ral> acowley: and cabal clean doesn't fix it
12:31:18 <acowley> he decoded the z-encoded name
12:31:41 <acowley> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/SymbolNames
12:37:24 <k0ral> so ?
12:38:17 <acowley> I would still guess you've got some stale build artifacts lingering somewhere, but I don't know where.
12:38:47 <hpaste> “Stoyan Peev” annotated “Parsing” with “Parsing (annotation)” at http://hpaste.org/48423#a48434
12:39:19 <thoughtpolice> alternatively, for some reason the linker isn't picking up his Paths_hbro module - that's what the overall zenc'd name refers to. that symbol in particular is used for the way GHC does module initialization when executables load
12:40:19 <thoughtpolice> so, it should definitely be there - the __stginit symbol will exist even if the module is practically empty, IIRC, since the module is still linked and must be initialized (this module initialization thing causes lots of dead code to accrue in executables in some cases, but it's been changed in 7.2 for the better)
12:40:59 <acowley> Right, but the reason why the missing file is only run into at link time is the odd bit
12:41:25 <thoughtpolice> yeah, i also wonder if there are OTHER linker errors besides just that one
12:41:36 <thoughtpolice> (more specifically missing symbols)
12:42:23 <acowley> k0ral: are you building hbro itself? Have you tried cabal install --reinstall'ing any dependencies of whatever you're building?
12:43:12 <thoughtpolice> i'd speculate (reasonably, I think) that if the linker was entirely missing the paths_hbro module, then you'd have more missing symbol errs, providing you refer to things inside that module. however, if it's used, but __stginit is the *only* thing missing, that's um... a bit more odd i think.
12:43:24 <thoughtpolice> i also wonder what 'nm' says if you run it over Paths_hbro.o
12:43:25 <k0ral> acowley: I'm indeed building hbro itself, and since last GHC upgrade cabal install automatically reinstalled all dependencies but maybe  I should do it manually in case some of them weren't reinstalled
12:43:30 <thoughtpolice> (this should exist somewhere inside dist fwiw)
12:43:51 <k0ral> thoughtpolice: wait a minute :)
12:44:02 <thoughtpolice> if the __stginit_hbrozm0zi5zi3_Pathszuhbro_
12:44:13 <thoughtpolice> *if the __stginit_hbrozm0zi5zi3_Pathszuhbro_ symbol is in there, the linker is definitely missing something badly
12:44:37 <k0ral> it's there : 0000000000000ea8 T __stginit_hbrozm0zi5zi3_Pathszuhbro_
12:44:48 <k0ral> do you need the whole output ?
12:45:06 <thoughtpolice> no that's fine, the 'T' means that symbol is definitely inside the object file
12:45:27 <thoughtpolice> k0ral: does the Paths_hbro.o file get included in the final link? you can do 'cabal install -v -v -v' or something and it'll dump lots of info
12:45:30 <thoughtpolice> including all GHC invocations
12:48:23 <k0ral> no Paths_hbro at all in cabal install -v -v -v output
12:48:39 <k0ral> :s
12:48:40 <acowley> whoa
12:49:56 <thoughtpolice> k0ral: ding ding! :) i wanted to speculate it was that, otherwise the situation would potentially be a whole lot weirder (by default the reasonable me wants to assume that 1+1=2 and the world is otherwise alright, which was confirmed this time)
12:50:34 <thoughtpolice> k0ral: but does Paths_hbro get compiled by cabal? if you do it without the '-v -v -v' cabal-install shows the 'Paths_hbro' module being compiled yes?
12:50:42 <k0ral> yes
12:51:02 <k0ral> because I import it if I remember well
12:51:07 * k0ral is checking
12:51:59 <k0ral> yes it's imported in one of the source files
12:52:10 <thoughtpolice> k0ral: hm, looking at your .cabal file for hbro from hackage, could you try including 'Paths_hbro' in an other-modules field in the source file? say below your exposed-modules field
12:52:12 <k0ral> (was not sure whether I commented it out or not)
12:52:31 <thoughtpolice> i'm hesitant as to whether or not this should work, but ISTR needing to tell cabal about *_paths files in the past
12:52:48 <k0ral> in the library section you mean ?
12:52:53 <thoughtpolice> yes
12:53:09 <k0ral> oh yes that's a missing line
12:54:18 <k0ral> and... wait for it... that fixes it !
12:54:23 <k0ral> :)
12:54:24 <thoughtpolice> \o/
12:54:27 <acowley> hooray!
12:54:28 <k0ral> noob mistake
12:55:21 <thoughtpolice> yeah, i imagine what was happening was you didn't tell cabal to include it, so the library would compile fine, but the actual Paths_hbro module was not included in the archive, so the library did compile fine, it was just registered with GHC while it was incomplete
12:55:30 <thoughtpolice> which would explain why you wouldn't see errs until you tried to link with it later
12:56:16 <k0ral> well, thank you acowley and thoughtpolice, and sorry for bothering with a noob mistake
12:56:36 <acowley> that's a tricky thing, though, that it worked before the compiler upgrade
12:56:55 <thoughtpolice> yeah, that's really fairly bizzare IMO
12:56:56 <acowley> Cabal is full of mystery. Nothing noobish about it.
12:56:59 <k0ral> actually, I happened to modify the code just after GHC's update
12:56:59 <monochrom> you never know that the only change was ghc upgrade
12:57:12 <monochrom> see?
12:57:15 <acowley> haha
12:57:26 <k0ral> yes, but you know I changed so little in my code...
12:57:34 <thoughtpolice> i'm also surprised cabal doesn't tell you that it compiles modules as part of a library, but doesn't have them 'registered' in exposed-modules or other-modules
12:57:38 <k0ral> just moved that import from the executable file to the library one
12:57:42 <k0ral> and boom
12:57:58 <thoughtpolice> yeah that makes sense as to why you would see it now then too.
12:58:07 <thoughtpolice> if you downgraded your GHC but still had that change i imagine it'd be the same
12:58:48 <thoughtpolice> acowley: from the Distribution.Simple module - "This module isn't called "Simple" because it's simple. Far from it. It's called "Simple" because it does complicated things to simple software."
12:58:52 <thoughtpolice> ;)
13:00:01 <yrlnry> Just like Hook::LexWrap isn't called "LexWrap" because it makes a lexically-scoped wrapper, but because…
13:00:07 <yrlnry> Hmmm.
13:00:11 <yrlnry> Because it doesn;t.
13:00:36 <yrlnry> Oh, sorry, totally wrong channel.
13:00:51 <monochrom> noticing incomplete module lists amounts to parsing source code yourself or calling up ghc-api
13:03:48 <djahandarie> yrlnry, basically the same as high schoolers. ;)
13:04:39 <monochrom> calling up ghc-api amounts to cabal.exe being 60MB and whole new threads in reddit, stackoverflow, haskell-cafe, #haskell, and ubuntuforums on why cabal is so huge
13:07:39 <Phyx-> monochrom: is that post stripped?
13:07:47 <Phyx-> why not just pack the executable too?
13:08:06 <Phyx-> usually shaves off big chunks here
13:09:49 <yoki> hey, if 'get :: IO (Maybe String)' how do you something like 'do; text <- fromMaybe "" get' ?
13:10:27 <yoki> i could do it in two lines, e.g. do; g <- get; let text = fromMaybe "" g
13:10:42 <iwtu> hi guys! what wrong with that type? type automata = [Map.Map Char Int]
13:11:14 <monochrom> use Automata
13:12:05 <sully> type automata = [Map.Map Char  Int]
13:12:10 <sully> argh!
13:12:15 <iwtu> I am so STUPID. But I used to it
13:12:20 <sully> my window manager is being screwy
13:12:48 <iwtu> sully: I am sorry :(. do you want an ice-cream?
13:13:14 <sully> nah, I'm good.
13:14:12 <iwtu> btw guys, what IDE/idetor do you use on Haskell?
13:14:22 <monochrom> I use emacs
13:14:45 <monochrom> any editor you are used to is just fine
13:14:51 <Nimatek> MS Word.
13:15:11 <DukeDave> Hey guys, one liner challenge: Replace the first instance of the largest element in a list with itself plus 200
13:15:31 <DukeDave> I'm good except for the "first instance" caveat :|
13:15:35 <DukeDave> > (\xs -> let m = maximum xs in map (\y -> if y==m then (m+10) else y) xs) [4,5,9,3,9]
13:15:36 <lambdabot>   [4,5,19,3,19]
13:15:45 <DukeDave> Or, erm, plus 10 ;)
13:15:45 <iwtu> monochrom: isn't it some nice IDE with nice auto completion and red underline in case of bad syntax?
13:16:09 <sam8> if I have a file that defines some new types... how can I import it to my main file?
13:16:19 <monochrom> I don't know
13:17:14 <iwtu> monochrom: I have learnt vim. One crazy editor is enough for me.
13:17:24 <d7> Hmm
13:17:32 <d7> I am trying to port something to haskell and hitting a conceptual wall
13:17:40 <DukeDave> sam8: If your module has the same file name as the module, and is in the same directory as your main, then a normal "import" should work.
13:18:04 <sam1> hi
13:18:10 <sam1> if I have a file that defines some new types
13:18:11 <iwtu> sam1: hi!
13:18:17 <monochrom> sam1 = sam8
13:18:19 <sam1> how can I import it to another file?
13:18:25 <d7> Specifically this:
13:18:27 <d7> https://github.com/codahale/metrics/blob/development/metrics-core/src/main/java/com/yammer/metrics/core/MeterMetric.java
13:18:45 <d7> I can imagine how to, in a single-threaded context, make all these metrics save for the meter work
13:18:49 <d7> (it's just a state monad)
13:19:09 <d7> And even for a multi-threaded context, you can just use M/Tchans to pipe the events.
13:19:19 <d7> But what I don't know how to do, easily, is periodically have the meter update itself.
13:19:36 <d7> Anyone have any suggestions?
13:21:53 <Runar> > (\xs -> let m = maximum xs; (h, t) = break (== m) xs in h ++ (head t + 200) (tail t)) [4,5,9,3,9]
13:21:54 <lambdabot>   Occurs check: cannot construct the infinite type: a = t -> [a]
13:22:51 <Runar> > (\xs -> let m = maximum xs; (h, t) = break (== m) xs in h ++ ((head t + 200) : tail t)) [4,5,9,3,9]
13:22:52 <lambdabot>   [4,5,209,3,9]
13:23:11 <Runar> DukeDave ^^
13:24:18 <edwardk> ddarius: i improved your comonad to monad trick: http://comonad.com/reader/2011/monads-from-comonads/ =)
13:25:16 <DukeDave> Runar: Very, very nice!
13:25:16 <DukeDave> Runar++
13:26:04 <djahandarie> edwardk, cool
13:26:24 <DukeDave> Runar++
13:31:52 <d7> I can never tell if it is worth trying to figure out things like that, edwardk.
13:31:57 <d7> Comonads seem like a whole another thing.
13:32:32 <edwardk> d7: the comonad-transformers library was put together largely to disabuse folks of that notion. notice that the comonads there admit operations just like those of the mtl.
13:32:37 <ddarius> unsafePerformIO: It kills comonads dead
13:32:44 <edwardk> and here i show that you can use the comonads to derive efficient monads. ;)
13:32:58 <edwardk> well, reasonably efficient i guess
13:33:29 <d7> None of these things ever seem to help me very much with my concurrency questions.
13:33:42 <d7> I guess just because good concurrency support is relatively new in haskell.
13:33:49 <ddarius> d7: You need profunctors.
13:33:59 <edwardk> redecorating a comonad is something that can be done nicely in parallel
13:34:18 <d7> ddarius: I want to be a pro functor.
13:34:21 <edwardk> in fact they make a nice model for cellular automata, simultaneous play games, and other very concurrent activities
13:34:42 <d7> edwardk: I wonder then if they could be useful to the specific problem I named earlier.
13:34:55 <d7> I guess this "Codata and Comonads in Haskell" paper goes on the pile.
13:34:58 <edwardk> i was kind of tuned out for that while writing =)
13:35:08 <djahandarie> ddarius, how does a profunctor help?
13:35:16 <edwardk> d7: kieburtz's OI stuff is completely unimplementable, be warned
13:35:24 <ddarius> @google profunctor concurrency
13:35:26 <lambdabot> http://portal.acm.org/citation.cfm?id=1079730
13:35:26 <lambdabot> Title: Relations in Concurrency
13:35:27 <Wantstolearn> Hi.I wish to install HAskell on Ubuntu 11.04
13:35:36 <Wantstolearn> How do I do that
13:35:43 * roconnor wonders if we need to define a type a :<- b
13:35:44 <sipa> aptitude install ghc
13:35:52 <Wantstolearn> ok
13:36:14 <edwardk> roconnor: that store comment of yours sent me off on a two hour tangent, i hope you're happy ;)
13:36:24 <ddarius> I defined one in my Monad Reader article.
13:36:24 <Wantstolearn> sudo apt-get install ghc
13:36:32 <roconnor> very
13:36:34 <Wantstolearn> lol 292 mb
13:37:02 <Wantstolearn> Thanks for the help roconnor
13:37:10 <roconnor> edwardk: funny; I was just trying to recite what I thought you told me some months ago. ... and I got it wrong.
13:37:13 <edwardk> roconnor: i was pleased to show that Co (Store s) a ~ Codensity (->) s a ~ State s a
13:37:24 <edwardk> =)
13:37:40 <edwardk> er Codensity ((->) s) a
13:37:52 <Wantstolearn> hmm is it installing ghc 6 or ghc 7
13:37:57 <Wantstolearn> i thought 7 was better
13:37:57 <roconnor> Co is a good name
13:38:12 <roconnor> clearly we need to rename the State monad the Costore monad.
13:38:19 <edwardk> =)
13:38:43 <Clint> Wantstolearn: http://packages.ubuntu.com/search?keywords=ghc
13:39:02 <Wantstolearn> yep it installs v 6
13:39:10 <Wantstolearn> can you update it afterwards
13:39:15 <edwardk> I started with Co<something> trying to figure out what something should be then just ripped out <something> coz it said what i wanted to say =)
13:40:13 <Wantstolearn> its installing version 6.12.3
13:40:23 <Wantstolearn> is version 7 still in development
13:40:23 <Wantstolearn> or
13:40:32 <Wantstolearn> I thought it was finnished
13:40:35 <roconnor> edwardk: you maintain the mtl?!
13:42:38 <djahandarie> roconnor, he does as of a few days ago
13:42:52 <d7> edwardk: For 2 reasons. 1, the pdf versions I can find have terrible print.
13:43:04 <roconnor> ah good.  edwardk, please delete the mtl. :)
13:43:35 <d7> edwardk: It's also bad form to start talking about your constructions as if you've already made them to me while in the introduction to the paper that introduces me to them. I dunno if that is Kieburtz's fault tho.
13:43:50 <ddarius> roconnor: You could do that at any point yourself.
13:44:34 <roconnor> ya, but since I'm not the maintainer, Ross would probably get mad and revoke my Hackage privledges
13:44:46 <roconnor> I like Hackage more than I dislike the mtl.
13:44:53 <roconnor> and I dislike the mtl quite a bit.
13:45:01 <ddarius> The wrath of Ross is what keeps Hackage good.
13:45:56 <identity_> roconnor: why do you dislike mtl?
13:46:42 <roconnor> identity_: the state instance for ContT State are wrong (or was it the other way around)
13:47:09 <roconnor> identity_: there are extra functions, such as listen and pass, that don't belong in the classes.
13:47:35 <roconnor> identity_: the order of (a,s) in state and writer is backwards.
13:47:53 <identity_> Hmm
13:48:02 <roconnor> @type runState
13:48:03 <lambdabot> forall s a. State s a -> s -> (a, s)
13:48:11 <identity_> I've never used Cont* as I don't get them
13:48:16 <roconnor> fair
13:48:24 <identity_> but as for the rest, I don't think it's a biggie
13:48:28 <roconnor> I think there were a few other problems
13:48:37 <identity_> but you want it to match (State s a) -> s -> (s, a)?
13:48:42 <identity_> that is, same order as State?
13:49:02 <roconnor> you want (s,) because this is (should be) a functor
13:49:12 <roconnor> making a functor out of (,s) is harder.
13:49:21 <roconnor> though this is a problem specific to Haskell.
13:49:21 <identity_> Ah, now you're speaking way over my head :P
13:49:54 <identity_> But I'll assume you are correct
13:50:02 <roconnor> identity_: just like it is helpful to carefully chose the order of arguments in functions, it is also important to choose the order of arguments of type constructors
13:50:17 <identity_> and now I will use this knowledge to pretend way more than I know and head over to a place like stackoverflow and hate on the mtl and shit
13:50:29 <identity_> roconnor: Indeed
13:50:30 <roconnor> except it is even more important with type constructors because Flip doesn't compute away.
13:50:40 <identity_> Yeah
13:51:25 <roconnor> identity_: you can tell which libraries are the most mediocore by simply looking to see if they are included in the Haskell Platform :)
13:51:51 <identity_> roconnor: So you're saying that if they are included they're 'mediocre'?
13:52:00 <Phantom_Hoover> Cale, hey, I hear Caleskell is your fault.
13:52:08 <ddarius> "Most mediocre"
13:52:16 <roconnor> that's been my (limited) experience with the mtl and data.binary
13:53:16 <roconnor> Phantom_Hoover: how do you mean?
13:53:32 <Phantom_Hoover> I mean that he is the one at fault!
13:56:28 <roconnor> identity_: ah, right. ListT isn't even a monad transformer.
13:57:01 <djahandarie> roconnor, depends on your definition of monad transformer I guess.
13:57:07 <int80_h> > let test = "1234"
13:57:08 <lambdabot>   not an expression: `let test = "1234"'
13:57:14 <int80_h> > read test
13:57:14 <lambdabot>   Not in scope: `test'
13:57:17 <roconnor> djahandarie: something that takes monads and produces monads?
13:57:28 <djahandarie> It does do that.
13:57:33 <djahandarie> Some of the time.
13:57:46 <roconnor> given any monad produces a monad.
13:57:55 <djahandarie> :p
13:59:24 <int80_h> > read "1234"
13:59:24 <lambdabot>   *Exception: Prelude.read: no parse
13:59:33 <int80_h> > read "1234" :: Int
13:59:33 <Lemmih> roconnor: Do you have any plans for a more memory efficient blockchain representation?
13:59:34 <lambdabot>   1234
13:59:44 <roconnor> Lemmih: not yet
14:00:08 <roconnor> My current plan is to acquire more memory
14:00:43 <copumpkin> moar money
14:00:43 <Lemmih> roconnor: Hah, I have 12gigs but the GC time becomes unbearable.
14:01:06 <roconnor> Lemmih: Oh strange.  I've only tried upto april, but I'm expecting it to fit in 1G
14:01:08 <djahandarie> Lemmih, you obviously need a faster processor.
14:01:30 <identity_> So, Iteratees and Enumerators seem pretty cool, but so far it seems like you're doing a bit of boilerplate having to explicitly check whether stuff is Just or Nothing and so on. Is there any way to get around this?
14:01:34 <identity_> or am I just being silly?
14:01:42 <Lemmih> roconnor: I made the code fast enough to validate all the blocks before a new block is mined but the exponential GC kills it.
14:01:44 <roconnor> Lemmih: I've processed upto april in a little over 0.5GB
14:02:15 <Lemmih> roconnor: april 2011?
14:02:18 <roconnor> yes
14:02:38 <roconnor> it took about 90 minutes or so on my laptop.
14:03:02 <roconnor> I specifically limited the heap though with an RTS flag.
14:03:12 <roconnor> hmm
14:03:17 <roconnor> maybe it took longer than 90min
14:03:20 <roconnor> I forget
14:03:47 <roconnor> but either there have been a *lot* of transaction since april (possible I suppose) or something is wrong.
14:03:59 <int80_h> > read "1234" :: Int
14:04:00 <lambdabot>   1234
14:04:03 <Lemmih> That's quite a long time. I process about 1000 blocks per second.
14:04:18 <ddarius> > 90*1000*60
14:04:18 <lambdabot>   5400000
14:04:27 <roconnor> Lemmih: but you said you speed things up?
14:04:29 <int80_h> > read $ head ["1234","5678"] :: Int
14:04:30 <lambdabot>   1234
14:05:09 <edwardk> roconnor: sadly i must refuse to delete the mtl
14:05:23 <roconnor> Lemmih: I spent a lot of type garbage collecting to fit everything in 0.5GB
14:05:28 <roconnor> *a lot of time
14:05:41 <edwardk> i think ross would figure out something was up when i submitted the request to him to mark it deprecated ;)
14:06:00 <roconnor> edwardk: can you make the mtl maintainer?
14:06:04 <roconnor> *make me
14:06:16 <edwardk> roconnor: hahaha
14:06:48 <Lemmih> roconnor: I removed some bottlenecks and used an impure SHA implementation.
14:07:16 <roconnor> booo ;)
14:07:48 <roconnor> as I recall all the time is spend either verifying signatures or hashing.
14:07:53 <Lemmih> roconnor: Ok, it seems that 'printTx' is important for keeping memory usage low. I had disabled it to get more speed.
14:08:03 <roconnor> oh ya
14:08:15 <roconnor> I haven't quite figured out all the strictness things yet.
14:09:01 <roconnor> Lemmih: Did I send you the modifed PSQueue?
14:09:05 <roconnor> I don't think I did
14:09:07 <Lemmih> roconnor: Nope.
14:09:20 <roconnor> I'm using a hacked PSQueue to add strictness annotations.
14:09:39 <cies> hi!  im looking for a function that does:  "f 3
14:09:48 <int80_h> could someone tell me why I get this error "*** Exception: Prelude.read: no parse" when I try to do this "read $ head jobs :: Int". jobs is a [String].
14:09:54 <roconnor> I was having major memory issues before so that was part of the changes ...
14:10:05 <int80_h> and I'm doing that in ghci
14:10:09 <roconnor> not that that change fixed those issues.  It was caused by bytestrings instead.
14:10:25 <cies> hi! im looking for a function to get the sign of a number; like "f 3" yields "1" and "f -3" yields "-1"
14:10:30 <cies> anyone an idea?
14:10:32 <Lemmih> int80_h: It fails to parse?
14:10:37 <roconnor> > signum 3
14:10:38 <lambdabot>   1
14:10:40 <roconnor> > signum (-3)
14:10:41 <lambdabot>   -1
14:10:55 <cies> roconnor: thanks!
14:11:00 <int80_h> Lemmih: I suppose. But why?
14:11:00 <Lemmih> > read "failure" :: Int
14:11:01 <lambdabot>   *Exception: Prelude.read: no parse
14:11:06 <nlogax> > (read "1", read "2 hamburgers") :: (Int, Int)
14:11:07 <lambdabot>   (1,*Exception: Prelude.read: no parse
14:11:09 <cies> roconnor: was looking already for 10 minutes in docs
14:11:15 <roconnor> np
14:11:16 <int80_h> jobs = ["1234"]
14:11:29 <int80_h> so
14:11:32 <roconnor> I guess hoggle isn't so good for this problem.
14:11:34 <roconnor> *hoogle
14:11:56 <int80_h> > read $ head ["1234","5678"] :: Int
14:11:57 <lambdabot>   1234
14:12:06 <int80_h> that works fine
14:13:16 <roconnor> Lemmih: anyhow, you can trying adding some !'s to the data type in PSQueue to make it look more like how Data.Map is.
14:13:42 <roconnor> but I may need to add some !'s to purecoin too.
14:14:10 <roconnor> I'm tempted to upload a new version of PSQueue.
14:14:24 <identity_> So, I'm thinking about enumerators/iteratees.. Let's say I have an Enumerator that receives it's data from the network, and a list of iteratees to consume the input and act on some commands that might be being sent from the itnernet. Would it be possible to define an iteratee that simply 'peeks' data and doesn't process it unless it's the command the iteratee is to process?
14:14:33 <int80_h> Lemmih: Okay I noticed that jobs looks like this [".00001"], therefor not an Int. But I get the same error when I change to Float in the above command
14:14:34 <identity_> And then passes it on to the next iteratee, so I could simply chain them up
14:15:00 <int80_h> > read $ head [".0001",".0002"] :: Float
14:15:01 <lambdabot>   *Exception: Prelude.read: no parse
14:15:03 <o1iver> Hi there. Could somebody here explain something about the Happy parser?
14:15:50 <Lemmih> int80_h: Custom formats need custom parsers.
14:16:04 <Lemmih> int80_h: If the output wasn't created with 'show', don't use 'read'.
14:16:31 <int80_h> Lemmih: read is the only way I know how to change String to Num
14:16:52 <int80_h> Lemmih: is there an alternative way?
14:17:00 <sam1> Can someone help with an error...?
14:17:02 <sam1> http://hpaste.org/48443
14:17:07 <o1iver> Why are these two ambiguous? 1: l Bracket char rBracket              { TLiteral '~'}
14:17:07 <o1iver>  2: l Bracket char hyphen char rBracket  { TRange $2 $4  }?
14:17:25 <int80_h> read ".0001" : Float
14:17:30 <int80_h> > read ".0001" : Float
14:17:31 <lambdabot>   Not in scope: data constructor `Float'
14:17:37 <chrisdone> Who's going to the berlin hackathon in 29-31th july?
14:17:37 <int80_h> > read ".0001" : float
14:17:37 <lambdabot> chrisdone: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:17:38 <lambdabot>   Couldn't match expected type `[a]'
14:17:38 <lambdabot>         against inferred type `GHC.Types...
14:17:49 <Lemmih> > let myRead x = read ("0" ++ x) in myRead ".0001" :: Double
14:17:51 <lambdabot>  Terminated
14:18:10 <int80_h> > read ".0001" : Double
14:18:11 <lambdabot>   Not in scope: data constructor `Double'
14:18:14 <Lemmih> > let myRead x = read ("0" ++ x) in myRead ".0001" :: Double
14:18:15 <lambdabot>   1.0e-4
14:18:18 <int80_h> > read ".0001" :: Double
14:18:19 <lambdabot>   *Exception: Prelude.read: no parse
14:18:20 <identity_> int80_h: You're missing the second :
14:18:37 <Lemmih> > let myRead x = read ("0" ++ x) in myRead "1.0001" :: Double
14:18:38 <lambdabot>   1.0001
14:18:52 <Lemmih> int80_h: There. Fixed forever.
14:21:04 <ion> > let myRead x = read ("0" ++ x) in myRead "-1.0001" :: Double
14:21:05 <lambdabot>   *Exception: Prelude.read: no parse
14:21:56 <Lemmih> ion: Shush, you. (:
14:22:37 <Lemmih> roconnor: How do you deal with orphan blocks? Do you somehow disconnect the mainline from the rest of the network?
14:22:52 <roconnor> at the moment orphan blocks are simply rejected
14:23:06 <roconnor> I plan to make composate data type to hold orphans and the main chain.
14:25:09 <o1iver> so could anybody give me a hand with this parsing ambiguity...
14:25:11 <o1iver> ?
14:27:09 <o1iver> why are 1: | '(' char ')' and 2: | '(' char '-' char ')'   ambiguous? With LL[2] this should not be ambiguous right?
14:34:47 <Clint> what happened to http://bifunctor.homelinux.net/~roel/hackage/packages/hackage.html
14:36:58 <acowley> Did edwardk coin the term "codensity monad"?
14:37:44 <roconnor> I presumed codensity was a term from category theory
14:38:01 <acowley> When I google it I come up with 99.9% edwardk
14:39:24 <paczesiowa> is cabal-dev (or capri) equivalent to python's virtualenv?
14:40:09 <parcs> yep
14:42:04 <dolio> He didn't come up with it.
14:42:25 <paczesiowa> parcs: both of those tools look more complicated
14:43:32 <parcs> maybe because you're not familiar with them
14:44:05 <parcs> or because managing compiled libraries is inherently more complicated than managing interpreted ones
14:44:45 <thoughtpolice> cabal-dev is basically the "de facto" way to sandbox things these days
14:44:51 <thoughtpolice> and it's not any harder to use than cabal install
14:45:14 <thoughtpolice> "cabal-dev install" on your local package you're working on, instead of "cabal install" is pretty much 99% of it
14:46:01 * lispy recommends not feeding paczesiowa 
14:46:08 <paczesiowa> thoughtpolice: when I'm working on something, I don't [cabal ]install it, usually play with it in ghci
14:46:55 <thoughtpolice> paczesiowa: 'cabal-dev ghci' on your package, and you get a sandboxed GHCi shell of your cabal package
14:47:05 <thoughtpolice> with all the dependencies downloaded and sandboxed
14:49:03 <erus`> what the fuck is this monster in my room? http://imgur.com/hDXco
14:49:05 <chrisdone> paczesiowa: cd repo; cabal-dev install; cabal-dev ghci. I do this regularly for packages I'm playing with.
14:49:26 <chrisdone> erus`: A simple beetle. Don't go out much, do you?
14:49:36 <erus`> its HUUUUGE
14:49:46 <erus`> i live in england
14:49:49 <erus`> we dont have beetles
14:49:58 <paczesiowa> thoughtpolice: according to cabal-dev's readme it still installs the library, wouldn't that be kind of slow?
14:50:07 <erus`> is it poisonous ?
14:50:33 <paczesiowa> lispy: what's your problem?
14:52:19 <chrisdone> erus`: I worry for your safety for reasons other than being oblivious to common species of harmless beetle.
14:52:22 <thoughtpolice> paczesiowa: what do you mean? it always has to 'install' the library and register it, but it does it in a local sense and does not let the registration touch your global/user ghc package configs.
14:52:43 <lispy> My problem is that I have no patience for trolling today.  If you have questions about using cabal-dev that's fine, but the way you're seeking help here looks more like trolling.
14:52:49 <erus`> why do they have to fly into my room
14:53:25 <erus`> they 'nip' you it says on random website
14:54:18 <paczesiowa> thoughtpolice: it could be interpreted (like regular ghci Some/Module.hs)
14:55:02 <paczesiowa> lispy: how come?
14:56:11 <thoughtpolice> i'm not sure i follow still. what does interpretation have to do with it? you cannot use 'cabal-dev ghci' without already issuing a 'cabal-dev install', because 'cabal-dev ghci' in reality points a ghci instance to your sandboxed package database, and excludes the user package DB (where cabal puts stuff by default) to give you a clean slate
14:56:57 <thoughtpolice> and 'cabal-dev install' will *build* your code, not interpret it. when you begin issuing 'import' or :m requests in the resulting GHCi shell, that's loading object files with native code, not interpreting things
14:57:24 <chrisdone> Just try it, it takes like two minutes.
14:58:01 <paczesiowa> chrisdone: I will as soon as ghc finishes compiling
14:58:28 <thoughtpolice> yes, it really is stupid simple to use as a tool. i see very little complications with it and it effectively kills the diamond dependency problems that sometimes hit cabal (which have not bitten me in a very long time personally, but they bite others frequently. it definitely hasn't bit since i started using cabal-dev)
14:59:44 <paczesiowa> thoughtpolice: thanks, I'll try it.
15:00:45 <thoughtpolice> i think there was actually a GSoC proposal this year to integrate cabal-dev directly into cabal. i don't think it got picked. maybe for good reason, because maybe it would be really easy, but i would like to see cabal-dev put into cabal personally.
15:01:19 <thoughtpolice> the situation isn't *that* much worse right now, though, so it's not a huge deal. it would just be nice to have that functionality as a built in, not an add on
15:01:20 <lispy> thoughtpolice: That scares me.  Cabal-dev works really well unlike cabal-install.  I would hate to see cabal-dev decrease in quality.
15:01:27 <Peaker> thoughtpolice: when is cabal-dev's sandbox cleared to be empty?
15:02:34 <thoughtpolice> Peaker: it's all put under a 'cabal-dev' directory inside your local copy. you can just clean it by removing it, by default 'cabal-dev clean' and 'cabal clean' only default to rm -rf'ing ./dist, not ./cabal-dev
15:03:07 <thoughtpolice> this is so you don't do 'cabal clean' or something on accident i imagine and have to redownload 9,000 other packages when you rerun 'cabal-dev install' 2 seconds later
15:03:36 <lispy> Yeah, you definitely want them as separate actions
15:03:47 <lispy> Like make clean vs. make mrproper in the linux tree
15:03:47 <chrisdone> cabal-dev add-source lib/* is a joy.
15:03:58 <thoughtpolice> ohmygod, how did i forget that
15:04:07 <thoughtpolice> basically the other greatest feature cabal-dev has :)
15:04:08 <lispy> chrisdone: I haven't tried it, but Josh told me that you should be able to do cabal-dev install /path/to/something too
15:04:19 <Peaker> Who's Mr. Proper?
15:04:22 <lispy> now that cabal-install support local install paths
15:04:31 <thoughtpolice> Peaker: another name for 'Mr. Clean', IIRC
15:04:35 <thoughtpolice> so it's a cleaning joke :P
15:04:39 <chrisdone> Haven't tried that either.
15:04:39 <lispy> Peaker: in the linux kernel tree mrproper is a full clean of even your kernel config :)
15:04:44 <thoughtpolice> (i think it's the european name or something)
15:04:54 <Peaker> ah :) I remembered something like that vaguely
15:05:44 <chrisdone> Mr Muscle (or Mr Muscolo here in Italy, IIRC) too
15:06:19 <thoughtpolice> lispy: re cabal-dev merger, i could see that happening maybe. i think duncan is in the process of currently centralizing the cabal repositories (notably putting Cabal and cabal-install into one repository for easier management,) so perhaps just putting cabal-dev in there and making it 'part of the toolset' would be another option
15:07:02 <thoughtpolice> it can still be independently maintained (by rogan et al,) it just lives with Cabal itself instead. i wonder if anyone has brought this up
15:07:14 <thoughtpolice> i think duncan only announced that cabal thing a few days ago, may be worth mentioning
15:07:40 <lispy> thoughtpolice: cabal-dev is in a git repo, FWIW
15:07:42 <hpaste> identity_ pasted “iteratee + ByteString madness again” at http://hpaste.org/48444
15:07:48 <thoughtpolice> lispy: is cabal still in darcs?
15:08:03 <identity_> Someone take a look @ the above?
15:08:05 <thoughtpolice> if so, then :(
15:08:28 <lispy> thoughtpolice: yes it is
15:08:58 <identity_> I know what it's complaining about, but the whole fucking mess that ByteString imports are have always annoyed me. different packs and unpacks and so on. I'm not really supposed to be importing Data.ByteString.Internal, am I?
15:09:15 <thoughtpolice> :( i guess i figured it was switched along with ghc. that sucks (for certain values of 'sucks' - darcs is fine, it just means we can't keep cabal-dev with cabal i guess :( )
15:09:52 <thoughtpolice> identity_: trust me, you are not alone in sentiments like this.
15:10:10 <identity_> ByteString mess?
15:10:11 <identity_> I'm glad
15:10:34 <identity_> So what exactly am I supposed to be importing to get that to typecheck?
15:10:38 <parcs> identity_: what's it complaining about?
15:10:43 <identity_> parcs: oh
15:10:48 <identity_> forgot to add the errors
15:10:49 <identity_> duh
15:10:49 <lispy> identity_: you can import Internal, you just should know what you're doing and minimize importing it
15:10:56 <thoughtpolice> identity_: well that, and the more general problem of "over 9,000 string types, everywhere up in this place"
15:11:15 <ddarius> There are relatively few string types.
15:11:21 <ddarius> Now array types...
15:11:42 <hpaste> identity_ annotated “iteratee + ByteString madness again” with “iteratee + ByteString madness again (annotation)” at http://hpaste.org/48444#a48445
15:11:46 <identity_> @ parcs
15:12:06 <identity_> lispy: That is not the issue, in reality. I want to understand why it's complaining.
15:12:07 <lispy> thoughtpolice: <purist>ByteString is not a String type!!</purist>  Yeah, the proliferation of string types is annoying....I hope that when Data.Text is utf-8 internally that I can stop using ByteString except when I need binary blobs
15:12:13 <thoughtpolice> well, there are at least strict and lazy versions of text, and in terms of types, they aren't the same. so coupled with the default String type, that's already 5 different stringlike types you have to deal with on a regular basis (especially as text and bytestring are popular for different reasons.
15:12:19 <thoughtpolice> but yes, the array situation isn't any better TBH
15:12:22 <ddarius> lispy: I agree with you first statement.
15:12:34 <thoughtpolice> er, I guess I also meant 'text and bytestring' in that last message
15:12:36 <identity_> well, rather what I'm supposed to import for that to typecheck
15:12:56 <identity_> it seems the different modules are exporting different bytestrings and so on, and I don't really get why there are so man ydifferent versions(except for the lazy and strict ones)
15:12:58 <ddarius> thoughtpolice: There are like 45 array libraries.
15:12:59 <parcs> identity_: you're omitting some import statements..
15:13:19 <lispy> ddarius: but with utf8-string you can effectively use it as a String type.  I am looking forward to Data.Text improvements though.
15:13:29 <tommd> Clearly the solution is to make a 46th array library that has the best parts of all the other 45 libraries...
15:13:33 <lispy> Sometimes a good-enough library, really is good enough :)
15:13:38 <identity_> parcs: Obviously, but none that are relevant to the error. It's complaining about the ones re. bytestring and those are the ones I showed
15:13:40 <thoughtpolice> ddarius: i could believe it.
15:13:44 <parcs> anyway Data.ByteString.Internal.ByteString is simply the strict ByteString type. you're using lazy bytestring, so there's a type mismatch
15:13:50 <thoughtpolice> actually, nvm the 'could'
15:13:51 <thoughtpolice> i do believe it
15:14:59 <identity_> God, this doesn't type check either. parcs I did that before then it starts complaining on the "BS/8.null" call. But I have to go, I'm sorry. I'm abroad and using someone else's computer, writing code over a shell
15:15:04 <identity_> Now the owner needs it :(
15:15:11 <parcs> identity_: and yes, the imports _are_ relevant to the error. how am i supposed to know what EB.takeWhile refers to?
15:15:34 <parcs> okay, cya
15:15:57 <thoughtpolice> ddarius: hm... let's see, there's the basic array package, vector, uvector, storablevector, um... anything else i'm missing? of course you also have to count for every one of those the 10+ support packages that go with it, none of which necessarily overlap in functionality/completeness between different array types...
15:16:14 <ddarius> thoughtpolice: carray, Ptr, repa, accelerate, dph
15:16:22 <ddarius> ByteString
15:16:36 <thoughtpolice> ah, repa and accelerate yeah. never heard of carray
15:17:03 <thoughtpolice> i even wonder if you should count uvector these days, considering it's basically useless in every way compared to vector.
15:17:21 <dolio> No, you should not count uvector.
15:17:31 <thoughtpolice> i figured as much.
15:18:03 <hpaste> mgsloan pasted “Statically typed regular expressions preview” at http://hpaste.org/48446
15:18:13 <djahandarie> mgsloan, :o
15:18:19 <mgsloan> :)
15:18:52 <dolio> Isn't repa related to dph?
15:19:01 <dolio> Not that I know the difference.
15:19:31 <aavogt> mgsloan: you should be able to leave off the $ in [$reg|
15:20:03 <hpaste> mgsloan annotated “Statically typed regular expressions preview” with “Statically typed regular expressions preview (annotation)” at http://hpaste.org/48446#a48447
15:20:08 <thoughtpolice> dolio: repa uses the same primitive libraries that DPH does, yes (dph-prim-par etc,) but i couldn't articulate the differences very well either
15:20:12 <thoughtpolice> dolio: but they're quite related i'd say
15:20:23 <mgsloan> aavogt - ahh, good to know!
15:21:02 <dolio> I mean, repa seems to be the parallel array part of DPH. But I'm not sure what of DPH is left after that.
15:21:22 <dolio> vector is the non-parallel array part, possibly with some additions.
15:21:37 <ddarius> dolio: repa is about shaped arrays.  Kind of like APL style multidimensional arrays.
15:21:39 <dolio> I guess neither vector nor repa have the syntax sugar.
15:21:43 <edwardk> acowley: no, i stole it from a text on topology
15:22:20 <acowley> edwardk: hmm, I guess google doesn't know any topology
15:22:33 <acowley> either that or you are a bigger branch of mathematics than topology
15:22:46 <ddarius> acowley: I doubt 40 year old topology texts get as many links as blogs.
15:22:57 <paczesiowa> is there any way to make cabal-dev configure with a cabal flag (-ftest)?
15:23:45 <acowley> ddarius: No, but you might expect the term to show up in some article somewhere
15:24:03 <edwardk> acowley: you might start http://dml.cz/bitstream/handle/10338.dmlcz/105644/CommentatMathUnivCarol_016-1975-3_9.pdf
15:24:05 * ddarius might've surpassed the other Derek Elkins if he hadn't countered with a MySpace and Facebook page.
15:24:09 <edwardk> that is around 1975
15:24:23 <edwardk> the original term was coined in 1974 iirc
15:24:40 <edwardk> the term 'monad generated by a functor' for that construction goes back to 1972
15:25:01 <augur> edwardk!
15:25:10 <augur> i demand your answer!
15:25:15 <augur> also, koninkje_away: be less away!
15:25:18 <acowley> edwardk: you should encourage these authors to blog :P
15:25:30 <edwardk> hah, you have crappy timing again, as i'm about to go back to work =P
15:25:34 <augur> :|
15:25:52 <edwardk> koninkje is in canada for a few weeks so he's less accessible than usual
15:26:12 <djahandarie> I have almost surpassed the other Darius Jahandarie.
15:26:19 <augur> oh they dont have internet in canada, i forgot
15:26:37 <edwardk> hah, well, he is away from his usual haunts i mean
15:26:41 <acowley> edwardk: have you written anything about codensity from a topology perspective to make the connection?
15:26:52 <edwardk> acowley: zip
15:27:11 <edwardk> acowley: zip as in zero, not zip as in zipping ;)
15:27:15 <augur> edwardk: you should write stuff about applications of CT concepts
15:27:17 <augur> lots of examples
15:27:39 <acowley> Codensity is a topological zipper. Got it.
15:27:42 <edwardk> i suck at examples ;)
15:27:46 <edwardk> =P
15:28:08 <augur> edwardk: just stick some types in somewhere!
15:28:27 <acowley> I can't read this paper. Skimming through it is yielding too many foreign concepts "...extremely co-well powered category..."
15:28:30 <edwardk> mac lane uses the codensity monad on p.250 of categories for the working mathematician in an exercise
15:28:40 <augur> lol
15:29:10 <ddarius> Density was one of the motivating concepts of Kan extensions.
15:29:17 <acowley> I only ever borrowed Jean Gallier's copy of Mac Lane and opted not to buy my own. I just found it too belligerent towards my brain.
15:29:42 <ddarius> acowley: Just read TTT and repeat until enlightenment.
15:29:54 <edwardk> you can go backwards from that to the definition of a codense functor, which is the subject of the preceding 4-5 pages
15:30:52 <edwardk> this is the way he sets up the "All Concepts are Kan Extensions" topic
15:30:53 <acowley> ddarius: barr and wells?
15:32:34 <acowley> I hope one day to use the phrase "co-well" in a sentence
15:32:44 <edwardk> acowley: much of the code in my latter two kan extensions posts comes from translating those 4-5 pages
15:34:29 <acowley> Okay. I was just wondering about the naming of things.
15:35:00 <acowley> Codensity is a very provocative name, and I couldn't figure out where the name came from
15:35:51 <edwardk> in short the codensity monad in Hask says that every type of kind * -> * gives rise to a codense functor from the discrete category of Hask to Hask. and we can then use the codensity monad of that functor as a monad in Hask.
16:19:37 <mauke> djahandarie: excellent question
16:19:58 <mauke> especially given that the original event happened 4 days ago
16:29:13 <ezyang> Does anyone know of a treatment of free monads that doesn't use the standard Roll/Return datatype; that is, they only use the free structure to implement bind? Can you even do that?
16:33:11 <Saizan> by free structure you mean that it's a left adjoint of the forgetful functor?
16:33:27 <ezyang> yes.
16:33:35 <ezyang> (though those words don't mean very much to me)
16:34:21 <tsuraan> I'm trying to work out how to use network-enumerator.  That package provides an enumSocket, which wraps a socket in an (Enumerator ByteString m b).  Just for simplicity, I'd like to write an Iteratee (I think that's what I want) that just prints out whatever it gets from the socket, but Enumerator maps a Step to the next Iteratee, and Step isn't an IO, so I don't see how I can do any actions from within my Step.  Where did I go wrong?
16:34:28 <Saizan> doesn't sound very hard, but i haven't seen such a treatment
16:34:49 <ezyang> I'm mostly curious to know if there exists monads for which Free m = m
16:34:54 <ezyang> (for a suitable definition of =)
16:36:53 <parcs> tsuraan: Enumerators don't map a step to the next iteratee, enumerators feed data into an iteratee
16:38:24 <ezyang> There are some technical difficulties in erasing the Roll/Return from the free monad.
16:38:24 <ezyang> You end up having to adjust the data type.
16:38:26 <ezyang> Did ekmett Ever follow up the "more later" in http://comonad.com/reader/2008/monads-for-free/
16:38:26 <ezyang> *edwardk
16:38:27 <Saizan> you surely have flatten :: Monad m => Free m a -> m a
16:38:27 <ezyang> yep.
16:38:34 <ezyang> wait.
16:38:42 <ezyang> Not, necessarily? Not sure.
16:39:35 <Saizan> flatten (Return a) = return a; flattern (Roll m) = m >>= flatten
16:39:50 <tsuraan> parcs: ok, I think I'm just missing how you tie an iteratee to an enumerator.  there's "run", which "runs an interatee", but what do you do to make the output of an enumerator (which maps Step to Iteratee) to the iteratee that you have made?
16:40:01 <ezyang> No you can't do that
16:40:05 <ezyang> cuz m is only a functor.
16:40:16 <Saizan> i added Monad m => for a reason :)
16:40:17 <ezyang> you've just replaced the free monad with whatever monad you picked.
16:40:23 <ezyang> pff :-)
16:40:28 <parcs> tsuraan: if you're using the enumerator package, take a look at (==<<) or its synonym ($$)
16:40:33 <Peaker> tsuraan: http://hackage.haskell.org/packages/archive/enumerator/0.4.10/doc/html/Data-Enumerator-Binary.html#v:iterHandle <-- an iteratee that dumps into a handle
16:40:58 <Saizan> flatten is not an isomorphism in general, anyhow
16:41:10 <Peaker> I think having ==<< and $$ is confusing -- it isn't really quite like =<< so they should have stuck with $$ or better yet, a letter-name..
16:41:20 <tsuraan> parcs: ok, I was looking for Enumerator -> Iteratee; I missed the synonym :)
16:41:29 <Peaker> I also had trouble finding $$
16:43:33 <parcs> ==<< is very similar to =<<. it just unwraps and rewraps the Step within an Iteratee: ttp://hackage.haskell.org/packages/archive/enumerator/0.4.10/doc/html/src/Data-Enumerator.html
16:43:48 <tsuraan> Peaker: ok, I was trying to figure out how to do IO from a Step; doing it from within an Iteratee makes a lot more sense :)
16:44:37 <Peaker> @hoogle (==<<)
16:44:37 <lambdabot> No results found
16:46:16 <Peaker> I think if there was a chaining operator that used type-class magic so that you could chain enumerators to enumeratees, enumeratees to enumeratees and enumeratees to iteratees -- that would be cool
16:46:23 <Peaker> it would just be a "unix pipe"
16:47:03 <Saizan> ezyang: anyhow, if you can find m's which are isomorphic to Free m, then they must be monads
16:47:08 <Peaker> producer >-> transformer >-> transformer >-> consumer
16:47:36 <tsuraan> Peaker: I actually thought that was the point of the enumerators stuff.  I guess I won't spend so much time looking for those functions now :)
16:47:40 <iwtu> is any way to insert in list at proper index?
16:47:57 <ezyang> Saizan: True.
16:48:17 <Peaker> tsuraan: there are apparently different functions for chaining producers (enumerators) and transformers (enumeratees), transformers and transformers, transformers and consumers (iteratees)
16:48:20 <Peaker> and the names suck
16:48:24 <benmachine> iwtu: yes, but if you want to do that you may find it easier to use Data.Sequence or something similar
16:48:51 <benmachine> iwtu: try splitAt, it may help
16:49:33 <benmachine> iwtu: but lists aren't the best thing for random access like that
16:49:50 <iwtu> benmachine, I make my own data type so I can use Data.Sequence :)
16:50:17 <Peaker> there's =$ and $= for the producer/transformer VS. transformer/consumer  compositions :(
16:51:24 <benmachine> iwtu: ok I don't know what you mean by that (Data.Sequence also has a splitAt, it'll probably be faster)
16:51:36 <Peaker> and I'm not sure how you're supposed to compose enumeratees (maybe Category-wise, or just (.)? )
16:53:20 <parcs> Peaker: with >=>, i believe
16:53:45 <Peaker> parcs: don't you agree it's a bit annoying to have so many different operators for the same semantic meaning?
16:53:50 <iwtu> benmachine, I need to modify element of list. Element of list is Data.Map. I need to modify by insert
16:54:18 <Peaker> @type insert
16:54:19 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
16:54:33 <benmachine> iwtu: you have a list of maps, and want to insert something into one of them?
16:54:35 <Peaker> > insert 100 [1..10]
16:54:36 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,100]
16:54:46 <Peaker> insert is snoc? bah
16:54:51 <benmachine> Peaker: no
16:54:57 <Peaker> oh, insertion sort
16:55:04 <benmachine> > insert 55 [10, 20 .. 100]
16:55:04 <lambdabot>   [10,20,30,40,50,55,60,70,80,90,100]
16:55:07 <ddarius> > foldr insert [] [10,9  .. ]
16:55:08 <lambdabot>   *Exception: stack overflow
16:55:21 <parcs> Peaker: yeah, it's a little silly
16:55:22 <ddarius> Ah, yes, that will take a bit.
16:55:25 <Peaker> ordInsert or sortInsert would be a nicer name for this not-so-useful function
16:55:29 <ddarius> > foldr insert [] [10,9  .. 0]
16:55:30 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10]
16:55:39 <benmachine> Peaker: agreed
16:56:01 <identity_> :t insert
16:56:02 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
16:56:08 <iwtu> benmachine, element is Data.Map and I want to insert to insert into the Map
16:56:11 <identity_> @index insert
16:56:12 <lambdabot> Data.Graph.Inductive.Internal.Heap, Data.HashTable, Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
16:56:19 <identity_> huh
16:56:20 <identity_> didn't know
16:56:21 <Peaker> I keep writing my own SEC combinators on lists.. iwtu seems like he could use them
16:56:46 <wli-needjob> SEC?
16:56:52 <iwtu> SEC?
16:57:37 <Peaker> @where SEC
16:57:37 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
16:58:16 <parcs> the enumerator library would be much simpler without the the hoops it goes through to get a monad transformer instance of iteratee, i think
16:58:16 * hackagebot haskell-src-meta 0.4.0.1 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-0.4.0.1 (BenMillwood)
16:58:27 <Peaker> iwtu: you can just use splitAt and recombine the lists
16:58:34 <iwtu> I need a function f(i,x) = k. i is index, x is Ord and k si number. i,k are numbers of states in automata
16:59:38 <gfarfl> iwtu: if you make it a sequence of Maps, it looks like you can do: adjust (insert x) index sequence
17:00:57 <iwtu> gfarfl, I think so, too
17:02:53 <benmachine> so guys, if I'm deprecating things in a module, what effect should that have on the version number of the next release?
17:03:33 <edwardk> removed functionality should cause the major version # to bump
17:03:48 <benmachine> sure, but it's not removed
17:03:55 <edwardk> the major version # are the x & y out of x.y.z.w
17:03:56 <benmachine> it's still there, but it just spits a warning if you use it
17:04:08 <dankna> I think deprecation ought to count as removal for that purpose, but I have no idea what the standard says
17:04:08 <benmachine> I mean deprecating as in the pragam
17:04:09 <identity_> what about minor API change?
17:04:20 <identity_> e.g. not backwards compatible change
17:04:23 <benmachine> dankna: the PVP page on the wiki doesn't know about the deprecate pragma
17:04:28 <dankna> I see
17:04:31 <tommd> benmachine: I don't think the PVP says anything, but I'd bump the C (in A.B.C.D versions)
17:04:35 <edwardk> i'd probably still bump the major version. the reason being that -Wall will crap out
17:04:44 <benmachine> edwardk: you mean -Werror?
17:04:59 <edwardk> and virtually everyone who builds on cabal builds with -Werror or -Wall
17:05:02 <edwardk> yeah
17:05:05 <aavogt> people widely use -Werror?
17:05:06 <benmachine> ho hum
17:05:10 <benmachine> I don't
17:05:12 * identity_ doesn't
17:05:15 * identity_ didn't know
17:05:16 <tommd> That's news to me
17:05:26 <edwardk> i use -Wall everywhere at least
17:05:29 <gfarfl> iwtu: actually, since Map.insert takes a key and a value, you need to change that to (uncurry insert (key,value))
17:05:30 <benmachine> enough people do that I'm inclined to agree with edwardk
17:06:16 <benmachine> which means I just screwed up :P oh well
17:06:27 <benmachine> (I released 0.4.0.1 with two things deprecated)
17:06:33 <benmachine> over 0.4
17:06:52 <benmachine> so auxiliary question: can I get a version "unreleased"?
17:07:03 <benmachine> almost certainly overkill in this case
17:07:06 <benmachine> but would be nice to know
17:07:11 <iwtu> gfarfl, what si curry and uncurry?
17:07:18 <identity_> iwtu: smart functions
17:07:22 <identity_> iwtu: you understand currying?
17:07:26 <identity_> :t curry
17:07:26 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
17:07:31 <iwtu> hope so
17:07:32 <identity_> :t uncurry
17:07:33 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
17:07:39 <identity_> take a curried function and uncurry it
17:07:49 <identity_> example:
17:08:02 <parcs> :t uncurry uncurry
17:08:03 <lambdabot> forall a b c. (a -> b -> c, (a, b)) -> c
17:08:04 <identity_> > let addNumbers a b = a + b in uncurry (3, 4)
17:08:05 <lambdabot>   Couldn't match expected type `a -> b -> c'
17:08:05 <lambdabot>         against inferred type `(...
17:08:06 <identity_> eh
17:08:13 <identity_> > let addNumbers a b = a + b in uncurry addNumbers (3, 4)
17:08:13 <lambdabot>   7
17:08:30 <parcs> :t uncurry 3
17:08:30 <lambdabot> forall a b c. (Num c) => (a, b) -> c
17:08:41 <aavogt> benmachine: if you upload a 0.4.0.2, soon, nobody is going to use 0.4.0.1
17:08:54 <geheimdienst> > (uncurry subtract (3,4)) == subtract 3 4
17:08:54 <lambdabot>   True
17:08:57 <parcs> @type curry 3
17:08:58 <lambdabot> forall a b c. (Num c) => a -> b -> c
17:09:42 <iwtu> please, just one and make it simple :)
17:09:54 <identity_> iwtu: basically "take a function that accepts two parameters and make it accept those parameters as a tuple", though that isn't correct to say and it works on functions of more than 'two parameters' as well
17:10:17 <benmachine> aavogt: hmm, so I upload 0.4 as 0.4.0.2, and then 0.4.0.1 as 0.5? I guess that would work, but it's kind of silly :P
17:10:18 <geheimdienst> iwtu: think of uncurry as unwrapping a tuple
17:10:21 <identity_> :t uncurry map
17:10:21 <lambdabot> forall a b. (a -> b, [a]) -> [b]
17:10:24 <geheimdienst> > subtract 8 3
17:10:25 <lambdabot>   -5
17:10:32 <geheimdienst> > uncurry subtract (8,3)
17:10:33 <lambdabot>   -5
17:10:45 <identity_> :t substract
17:10:46 <lambdabot> Not in scope: `substract'
17:10:51 <identity_> :t subtract
17:10:52 <lambdabot> forall a. (Num a) => a -> a -> a
17:10:55 <identity_> :t uncurry subtract
17:10:56 <lambdabot> forall a. (Num a) => (a, a) -> a
17:11:01 <identity_> ^
17:11:36 <aavogt> @let substract = subtract
17:11:36 <lambdabot>  Defined.
17:11:37 <geheimdienst> yeah, that's it. uncurry turns "a -> a -> a" into "(a -> a) -> a"
17:11:46 <identity_> > let tikkaMasala = curry in curry . uncurry $ subtract 42 0
17:11:47 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b -> c)
17:11:47 <lambdabot>    arising from a use...
17:12:03 <identity_> eh
17:12:05 <geheimdienst> no, into "(a, a) -> a", obviously
17:12:11 <geheimdienst> 8)
17:12:20 <iwtu> wait
17:12:22 <identity_> > let tikkaMasala = curry in (curry . uncurry $ subtract) 42 0
17:12:24 <lambdabot>   -42
17:12:34 <iwtu> (a,a) curry and a -> a uncurry?
17:13:54 <identity_> iwtu: A "curried function" is basically a function that takes multiple arguments(an n-tuple) into a chain of partial functions, each taking one argument
17:13:59 <identity_> :t subtract
17:14:00 <lambdabot> forall a. (Num a) => a -> a -> a
17:14:11 <identity_> :t subtract 3
17:14:12 <lambdabot> forall t. (Num t) => t -> t
17:14:41 <identity_> In Haskell, there is no such thing as a function 'taking multiple arguments' unless it takes an n-tuple
17:15:29 <identity_> uncurry takes a curried function and uncurries it, making it take a tuple instead. curry does the opposite
17:15:33 <identity_> unwrapping a tuple
17:16:15 * wli-needjob misses his typeclasses for tuple component genericity but never got the trick for n-tuple currying/uncurrying.
17:16:55 <iwtu> but imporatant is if arguments fit, is not?
17:17:13 <identity_> iwtu: What do you mean?
17:17:42 <identity_> Just play around with uncurrying functions and looking at their types, and the types of the originals
17:17:45 <identity_> :t map
17:17:46 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:18:12 <identity_> A function that takes a function of type (a -> b), a list of a's and returns a list of b's.
17:18:15 <identity_> :t uncurry map
17:18:16 <lambdabot> forall a b. (a -> b, [a]) -> [b]
17:18:37 <identity_> now it's a function that takes a tuple containing a function (a -> b) and a list of a's
17:18:41 <identity_> returning a list of b's
17:19:07 <identity_> it becomes even clearer with simpler functions
17:19:10 <identity_> :t subtract
17:19:11 <lambdabot> forall a. (Num a) => a -> a -> a
17:19:13 <identity_> :t uncurry subtract
17:19:13 <lambdabot> forall a. (Num a) => (a, a) -> a
17:19:49 <iwtu> how can i choose between curry an uncurry funciton?
17:22:57 <gfarfl> iwtu: you can use the curry / uncurry functions to modify existing functions when necessary
17:24:09 <ddarius> Uses of curry or uncurry are fairly rare.
17:24:39 <gfarfl> indeed, I'm not sure why I put it in the example I gave
17:24:48 <xplat> > let {delist [] = Nothing; delist (a:as) = Just (a,as); enlist = maybe [] (uncurry (:)); mapHead = (enlist .) . (. delist) . fmap . first} in uncurry (++) . second (mapHead (200+)) . join (break . (==) . maximum) $ [1,2,6,4,3,5]
17:24:49 <gfarfl> still, it spawned a nice discussion :)
17:24:50 <lambdabot>   [1,2,206,4,3,5]
17:25:35 <iwtu> **** I cannot load Data.Sequence
17:25:35 <identity_> xplat: I'm sure that explained it to him perfectly
17:26:51 <iwtu> :(
17:30:15 <joe6> is there a better way of writing this: http://pastebin.com/gew9MjcP
17:30:17 <mauke> The paste gew9MjcP has been copied to http://hpaste.org/48448
17:30:28 <hpaste> identity_ pasted “enumerator + bytestring mess” at http://hpaste.org/48449
17:30:37 <identity_> ^plox
17:32:58 <benmachine> identity_: if it helps, Data.ByteString.Char8.ByteString = Data.ByteString.ByteString
17:33:36 <identity_> benmachine: Alright, I see
17:33:52 <identity_> benmachine: But do you have any idea about the inconsistency?
17:33:55 <identity_> Why it is there, etc?
17:33:57 <benmachine> no, it sounds weird to me
17:34:12 <identity_> Aye
17:36:23 <benmachine> identity_: possibly it could be to do with constructing lazy bytestrings being more efficient?
17:36:32 <identity_> Hmm, I guess
17:36:56 <identity_> At any rate, it finally typechecks and I can try to look at the forest without the trees getting in the way
17:37:11 <benmachine> :)
17:37:13 <identity_> (read: enumerators/iteratees .. without .. bytestrings)
17:37:33 <benmachine> mm
17:40:31 <parcs> identity_: change BS.null to Data.ByteString.Lazy.null
17:40:59 <identity_> parcs: aye, I know
17:41:05 <identity_> I just thought the inconsistency was strange
17:45:53 <iwtu> I my distribution, Arch Linux is ghc broken second day. I have upgrade 10 minutes ago :(
17:46:15 <identity_> iwtu: broke how?
17:46:17 <parcs> identity_: oh, didn't read the comment :P
17:46:21 <identity_> It doesn't break on its own :P
17:46:34 <identity_> parcs: Then there's also the thing with the different pack's and so on. It just seems confusing :(
17:46:57 <parcs> i think the reason behind the inconsistency is that when going across different Chunks it's more efficient to append two lazy bytestrings than to append two strict bytestrings
17:47:13 <parcs> concat *
17:47:26 <gfarfl> iwtu: I'll pacman -Syu now, and see what happens
17:47:54 <parcs> i guess concat and apped are interchangeable here
17:48:08 <identity_> parcs: That does make sense, yeah
17:48:12 <iwtu> gfarfl, don't
17:48:47 <iwtu> < max 3 5
17:48:56 <iwtu> > max 2 5
17:48:57 <lambdabot>   5
17:49:06 <identity_> parcs: Here's an example:
17:49:07 <identity_> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
17:49:07 <identity_> Data.ByteString.Lazy pack :: [Word8] -> ByteString
17:49:33 <identity_> I import DBL for the ByteString definition, but I need DBL8 for the pack from String -> DBL.ByteString
17:49:41 <identity_> this is really annoying
17:50:01 <identity_> and DBL itself contains a pack :: [Word8] -> DBL.ByteString
17:50:13 <Saizan> doesn't DBL8 export the ByteString type too?
17:50:18 <identity_> instead of two packs, "pack8" and "pack" or something
17:50:32 <identity_> Saizan: Not sure, but it doesn't export null
17:50:34 <identity_> which I need as well :)
17:50:38 <parcs> yeah, there're 4 separate interfaces to what is essentially the same data type
17:50:40 <iwtu> gfarfl, https://bugs.archlinux.org/task/24862#comment79309
17:50:59 <Saizan> 2 datatypes, 4 interfaces, actually
17:51:09 <parcs> yeah, true
17:51:31 <identity_> parcs: A couple of different, qualified modules are fine. 2 datatypes, 4 interfaces, but functions with the same name on all of them = *roooar*
17:51:48 <identity_> but meh
17:51:58 <identity_> I'll pray to god and hope I live through this
17:52:08 <iwtu> gfarfl, , I go to downgrade
17:52:44 <parcs> i wonder if it would be better to have two interfaces and have all word8 functions postfixed with _w8 or something instead
17:53:00 <Saizan> i think they's probably accept a patch exporting null from DBL8
17:54:01 <ezyang> I feel like I'm on the very tip of having enough material at my fingertips to understand edwardk's recent posts. Soo close, yet soo far.
17:54:08 <Saizan> parcs: considering that .Char8 is the interface that shouldn't actually be there i think that's pretty backwards
17:54:48 <identity_> Saizan: Yeah?
17:55:11 <identity_> How would I go about posting such a patch? Where do I find the current sources, etc?
17:55:23 <thoughtpolice> #haskell - a place where you can find bits and pieces of the minds edwardk has blown
17:55:25 <parcs> Saizan: why is that? i know that the Char8 functions are implemented in terms of the Word8 ones, but aren't the Char8 functions more used?
17:55:39 <parcs> directly, anyway
17:56:31 <identity_> thoughtpolice: #haskell - where a computer scientist's incredible endeavors in functional programming have gotten him meme'fied to the point where he is to the channel what Chuck Norris is to the web
17:56:53 <Saizan> well, the whole idea of treating Char as a byte is quite wrong, though you can hide the fact by claiming you use latin1 :)
17:57:04 <parcs> yeah, i just considered that
17:57:22 <identity_> Saizan: 256 different characters enough for anyone
17:57:24 <identity_> for all sane alphabets
17:58:42 <Saizan> identity_: the hackage page has an home page link which has a source link :)
17:58:59 <Saizan>  http://darcs.haskell.org/bytestring
17:59:21 <gfarfl> iwtu: after some fiddling around reinstalling cabal packages, I can't see any obvious problems
17:59:37 <identity_> Thanks, I'll take a look
18:00:05 <hpaste> megajosh2 pasted “Ambiguous type variable?” at http://hpaste.org/48450
18:00:18 <megajosh2> Can anybody tell what I'm doing wrong?
18:00:33 <edwardk> ezyang, thoughtpolice: =)
18:01:09 <Saizan> megajosh2: Plugin is not what you think it is, probably
18:01:59 <megajosh2> Saizan: Not sure what you mean
18:02:20 <Saizan> megajosh2: were you trying to make a datatype that could hold a value of any specific type as long as that type is an instance of PluginData?
18:02:35 <megajosh2> Saizan: That's exactly what I was aiming for
18:02:47 <identity_> Saizan: I'm full of shit. DBL8 does export null
18:03:06 <Saizan> megajosh2: then it's data Plugin = forall a. PluginData a => Plugin { getPlugin :: a }
18:03:14 <megajosh2> Hmm
18:03:20 <megajosh2> Alright, thanks
18:03:24 <megajosh2> I'll see if that fixes it
18:03:35 <iwtu> gfarfl, I ran pacman -Syu too. before just -Sy ghc
18:04:11 <gfarfl> iwtu: what's the actual error(s) you're getting?
18:04:17 <Saizan> your version was forcing the value inside to be polymorphic, instead, so that the specific type got decided when you unwrapped it
18:04:39 <Saizan> but your code wasn't specifying it in any way, hence the ambiguity
18:04:47 <iwtu> gfarfl, I run pacman -Syu, so it will take a while
18:06:06 <megajosh2> Hmm
18:06:37 <megajosh2> I was using PolymorphicComponents before to make that, but now it says I need to use either ExistentialQuantification or GADTs
18:07:09 <identity_> Hmm. Is it possible to use an enumerator/enumeratee/iteratee to wedge between an enumerator and an iteratee that would basically limit what the iteratee can consume? E.g. if fooE $$ fooI and fooI consumes the whole file, can I do some fooE ?? (bar $$ fooI) to only pass a few lines of the file to fooI?
18:07:10 <Saizan> ExistentialQuantification is the most accurate here
18:11:36 <iwtu> gfarfl, I forgot pacman -Suy solves most of problems.
18:17:04 <guest> how do I include a js file using blaze in Happstack ?
18:17:23 <guest> do i have to write a server part?
18:20:01 <marchdown> What engine does book.realworldhaskell.org use? Is it open-source?
18:20:29 <edwardk> ezyang: reading dominic orchard's stuff. i notice he's selling the same codo notation i've advertised for the last few years ;)
18:20:49 <edwardk> marchdown: iirc bos wrote it. you could probably ask him about open sourcing
18:21:26 <Axman6> marchdown: you mean the commenting system? there's a haskell package for it
18:21:51 <Axman6> can't remember the name. it's a name similar to docbook i think, bit not...
18:22:03 <marchdown> Yep. Looks like hgbook uses it too.
18:22:08 <edwardk> oh wait, there are some differences
18:22:14 <marchdown> hsbook?
18:23:30 <parcs> identity_: yep, those are enumeratees
18:23:35 <marchdown> Thanks, I'll wait for bos.
18:24:02 <identity_> parcs: How would one implement something like that? I tried just "take 10", take wants an iteratee, etc
18:24:24 <edwardk> ezyang: also his bido stuff at the end seems to make the same mistake that sigfpe and uustalu and vene made with how to mix comonads and monads
18:25:13 <Axman6> marchdown: http://hackage.haskell.org/package/doc-review
18:25:25 <marchdown> Thank you.
18:25:33 <edwardk> ah he is in estonia, so that makes sense
18:27:04 <edwardk> ezyang: given the bido stuff in his later slides, i'd gather that his when monads/comonads overlap stuff is just the distributive law for a monad over a comonad that others have talked about
18:27:09 <Luke> is there a way to have to maybe variables and ensure both of them are the same besides function clause-ing out each case?
18:28:10 <edwardk> Luke: You want to compare Maybe Var to Maybe Var where Var is something like Int?
18:28:33 <aavogt> > let a = Just 0; b = Just 1; n = Nothing; in [a==b, a == n, n == n]
18:28:34 <lambdabot>   [False,False,True]
18:28:43 <edwardk> Luke how should Nothing compare to Nothing? or to something else?
18:29:13 <Luke> edwardk: I want to ensure (Maybe a) and (Maybe b) are both "Just"
18:29:27 <Luke> or both Nothing
18:29:30 <Luke> just that they're the same
18:29:47 <edwardk> and otherwise return false?
18:29:50 <Luke> given two variables, I want to make sure they were constructed with the same data constructor
18:29:50 <edwardk> then just use ==
18:30:06 <Luke> a and b could be different types
18:30:37 <edwardk> you just care that both are Just?
18:30:50 <edwardk> (==) `on` isJust
18:31:03 <geheimdienst> > let f a b = isJust a == isJust b in [f (Just 3) Nothing, f (Just 3) (Just 2), f Nothing Nothing]
18:31:04 <lambdabot>   [False,True,True]
18:31:07 <Luke> well i'm looking for something more generic
18:31:18 <Luke> that can work for any wrapper type
18:31:20 <geheimdienst> > let f a b = isJust a == isJust b in [f (Just 3) Nothing, f (Just 3) (Just "lol"), f Nothing Nothing]
18:31:21 <lambdabot>   [False,True,True]
18:31:25 <aavogt> @ty (==) `on` (constrIndex . toConstr)
18:31:25 <lambdabot> forall a. (Data a) => a -> a -> Bool
18:31:53 <edwardk> @type (==) `on` (() <$)
18:31:54 <lambdabot> forall (f :: * -> *) b. (Eq (f ()), Functor f) => f b -> f b -> Bool
18:32:06 <edwardk> bah
18:32:33 <Luke> basically using (==) `on` the constructor
18:32:33 <edwardk> @type \x y -> (() $< x) == (() $< y)
18:32:34 <lambdabot> Not in scope: `$<'
18:32:34 <lambdabot> Not in scope: `$<'
18:32:51 <edwardk> @type \x y -> (() <$ x) == (() <$ y)
18:32:52 <lambdabot> forall (f :: * -> *) b b1. (Functor f, Eq (f ())) => f b -> f b1 -> Bool
18:33:00 <Luke> nice
18:33:03 <Luke> thanks
18:33:26 <edwardk> @type \x y -> void x == void y
18:33:26 <lambdabot> Not in scope: `void'
18:33:27 <lambdabot> Not in scope: `void'
18:33:35 <megajosh2> @type on
18:33:35 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
18:33:46 <edwardk> void is in Control.Monad does the same thing
18:34:30 <edwardk> (as the () <$ part)
18:34:46 <aavogt> @ty \a b -> let f x = constrIndex (toConstr x); g x = dataTypeName (dataTypeOf x) in f a == f b && g a == g b
18:34:47 <lambdabot> forall a a1. (Data a, Data a1) => a -> a1 -> Bool
18:35:19 <aavogt> @let eqConstr a b = let f x = constrIndex (toConstr x); g x = dataTypeName (dataTypeOf x) in f a == f b && g a == g b
18:35:19 <lambdabot>  Defined.
18:35:31 <edwardk> aavogt: the danger there is when you have a functor made up of multiple layers
18:35:34 <aavogt> > eqConstr (Just 3) (Just "lol")
18:35:36 <lambdabot>   True
18:36:04 <edwardk> > eqConstr [1,2] [1]
18:36:05 <lambdabot>   True
18:36:31 <edwardk> same constructor but the same probably belongs in the equality constraint
18:36:40 <edwardk> er s/same/shape
18:37:22 <aavogt> you're complaining about the name?
18:37:40 <Luke> hmm maybe it'd be easier to just expand out the function clauses for pattern matching =)
18:38:24 <aavogt> this one is written once and works for any data type you have a data instance for
18:40:01 <edwardk> aavogt: mostly complaining about whether or not it implements the most useful generalization of his suggested function
18:40:18 <edwardk> this one works, but it only compares the outer most constructor, so lots of things compare as equal even in a recursive data type
18:40:47 <aavogt>  bothJust Just{} Just{} = True; bothJust _ _ = False -- probably the most direct way?
18:40:53 <edwardk> whereas the void based one compares 'shapes'
18:41:16 <edwardk> > eqConstr [1,2] [1]
18:41:18 <lambdabot>   True
18:41:40 <edwardk> > (\x y -> (() <$ x) == (() <$ y)) [1,2] [1]
18:41:41 <lambdabot>   False
18:41:52 <aavogt> the Data constrain should be enough to write that one
18:41:58 <edwardk> he asked for it to work for types other than Maybe
18:42:35 <edwardk> it _can_. but its also a pretty heavy weight tool for that task, as evidenced by the fact that it was addressed just by functor ;)
18:43:02 <edwardk> plus lots of Data instances lie. for instance there is a Data instance for Map, but you probably shouldn't use it =(
18:43:14 <aavogt> how about Either?
18:44:07 <ivanm> edwardk: did you reply to my message via lambdabot? because if so it seems she forgot it :/
18:44:14 <edwardk> the left hand sides are left untouched. any data version would have to decide how you wanted to clean it out
18:44:26 <edwardk> ivanm: not only lambdabot but i have as well ;)
18:44:39 <ivanm> heh
18:44:55 <ivanm> I was asking if you remembered what question I asked that you replied "yes" to 4 days ago
18:45:06 <edwardk> ivanm: hahaha
18:45:14 <edwardk> ivanm: now i've doubly forgotten ;)
18:45:18 <ivanm> heh
18:45:32 <ivanm> I probably asked on my uni machine, so I might be able to check there when I go in
18:47:39 <ivanm> edwardk: Oh, I think I might recall...
18:47:47 <sam9> Hi can I ask a question?
18:47:58 <ivanm> IIRC, it was what you thought of the possibility of using a repa-style approach to multivariable polynomials
18:48:03 <ivanm> sam9: I believe you just did
18:48:09 <ivanm> and as such, your quota is all used up for the day
18:48:09 <ivanm> :p
18:48:21 <sam9> haha
18:48:25 <sam9> well..
18:48:28 <sam9> I have a function
18:48:29 <sam9> ntt :: (Num a) => [a] -> [a] -> [a]
18:48:39 <sam9> ntt ru xs = ...
18:48:43 <sam9> where ru and xs are lists
18:49:05 <ivanm> OK
18:49:12 <sam9> um... so the problem is
18:49:37 <sam9> I defined a new type that is instance of num
18:49:55 <sam9> and I want list ru to be Integer and xs to be this new type...
18:49:59 <sam9> is that possible?
18:50:06 <ivanm> no
18:50:13 <ivanm> since by your type signature they have to be the same type
18:50:20 <edwardk> brb
18:50:23 <ivanm> but it may be that your type signature is too strict
18:50:38 <ivanm> sam9: alternatively, do "map fromInteger" on your ru list before passing it to ntt
18:50:59 <sam9> hm... I believe I tried that and had some problems...
18:51:05 <sam9> let me try quickly
18:51:48 <edwardk> i was playing around with representing polynomials as the linear combinations of basis vectors in a free module over a set of basis vectors
18:52:25 <edwardk> so we make newtype Linear s a = Linear [(s,a)] — for a Num s
18:52:28 <ivanm> "free module" ?
18:52:31 <sam9> I tried
18:52:51 <edwardk> then we define a normalization pass, but the Monad/Applicative for (Linear s) don't normalize
18:52:59 <edwardk> then we can make a class for the notion of a Basis
18:53:23 <sam9> and if I directly do fromIntegral as I am calling the function it works but if I don't it gives me error
18:53:30 <edwardk> class Basis a where cup :: Num s => a -> a -> Linear s (); cap :: Num s => Linear s (a,a)
18:54:01 <ivanm> edwardk: what are cup and cap meant to be?
18:54:10 <ivanm> sam9: well, yes... that's kind of the point
18:54:16 <edwardk> an example Basis would be Bool. instance Basis Bool where cup a b | a == b = return () | otherwise = empty
18:54:31 <edwardk> cap = return (True, True) <|> return (False, False)
18:54:48 <sam9> so I have to do fromIntegral everytime I input?
18:54:57 <edwardk> cup is basically the action of the dot product, cap is used when dualizing dual vectors back to normal vectors
18:54:58 <ivanm> sam9: yes
18:55:06 <edwardk> with those in hand you can define stuff like
18:55:08 <ivanm> sam9: or adapt your function appropriately
18:55:26 <ivanm> where is empty from?
18:55:35 <sam9> how can I adapt my function exactly?
18:55:53 <edwardk> transpose m i = do (j, k) <- cap; l <- m j; cup k i; return l
18:56:02 <edwardk> ivanm: Alternative
18:56:04 <ivanm> sam9: without knowing what your function is I can't say
18:56:07 <ivanm> oh, right
18:56:14 <edwardk> ivanm: i presumed the obvious implementation of MonadPlus and Alternative
18:56:29 <ivanm> yeah, I've never really used them so not that familiar with their methods
18:56:51 <edwardk> transpose :: (Num s, Basis a, Basis b) => (a -> Linear s b) -> b -> Linear s a
18:57:12 <sam9> its not too long... I'm sorry but if you can take a look... :(
18:57:13 <edwardk> adding an Ord constraint on Basis means you can make that renormalize as well
18:57:13 <sam9> http://hpaste.org/48451
18:57:47 <ivanm> @type genericIndex
18:57:48 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
18:58:11 <edwardk> ivanm: anyways, a fun observation is that given two instances of Basis you can define the tensor and direct product of them.
18:58:34 <sam9> @type genericIndex
18:58:35 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
18:58:38 <sam9> ?
18:58:42 <ivanm> sam9: no, you're doing * so they need to be the same type
18:59:04 <ivanm> you _can_ do a wrapper around ntt: ntt' ru xs = ntt (map fromInteger ru) xs
18:59:20 <ivanm> edwardk: heh, way more than what I need :p
18:59:21 <edwardk> instance (Basis a, Basis b) => Basis (a,b) where cup (a,b) (c,d) = cup (a,c) >> cup (b,d); cap = abide <$> cap <*> cap where abide (a,b) (c,d) = ((a,c),(b,d))
18:59:27 <edwardk> ivnm: well, not exactly
18:59:39 <edwardk> it is exactly what you need to make multivariant polynomials ;)
18:59:54 <sam9> hm... let me try that
19:00:09 <edwardk> lets make a basis: newtype P x = P Int  — here we'll ignore cap for now.
19:00:57 <edwardk> representing the polynomial power basis. P n :: P x, represents x^n in
19:01:06 <edwardk> our free module
19:01:21 <edwardk> now you can talk about elements of (P x,P y)
19:01:36 <sam9> hm... it worked...
19:01:38 <edwardk> which is a power of x paired with a power of y,
19:01:48 <sam9> Thanks ivanm
19:01:52 <ivanm> edwardk: "P n :: P x" ?
19:01:58 <sam9> Oh... can I ask one more question...?
19:02:02 <ivanm> should that be :^: or something?
19:02:07 <ivanm> sam9: I dunno... :p
19:02:26 <sam9> I have a file that declares some new types...
19:02:43 <edwardk> once put in the Linear s monad, and normalized you can extract the coefficients of x^3 y^4 by looking for the scalar coefficients of (P 3, P 4) in your free module.
19:02:44 <sam9> what is the common way to import to another file so I can use it?
19:02:54 <ivanm> sam9: import Foo ?
19:03:01 <edwardk> no that was actually :: as in P n given type P x
19:03:04 <sam9> um... do I have to make it a module?
19:03:22 <ivanm> edwardk: oh, so it wasn't meant to be Haskell? :p
19:03:24 <Saizan> yes
19:03:24 <edwardk> n :: Int
19:03:25 <edwardk> yes
19:03:26 <edwardk> =)
19:03:32 <edwardk> no that was
19:03:45 <edwardk> P 3 :: P x  — for some variable x in scope
19:03:58 <ivanm> oh, P (3 :: P x) ?
19:04:08 <edwardk> no. (P 3) :: P x
19:04:20 <edwardk> remember, newtype P x = P Int
19:04:29 <Cale> Finite dimensional vector spaces over a field F are algebras for the monad of F-linear combinations of elements of a set.
19:04:31 <ivanm> oooohhhhh.... _now_ I get you!
19:04:37 <edwardk> takes a phantom type to indicate what variable its in
19:04:43 * ivanm hated linear algebra for a reason... :p
19:04:48 <Cale> Actually, I should say, all vector spaces
19:05:11 <edwardk> yeah, i'm just using the free module, but the same vocabulary applies =)
19:05:12 <djahandarie> @quote ivanm < Cale> Finite dimensional vector spaces over a field F are algebras for the monad of F-linear combinations of elements of a set. < ivanm> oooohhhhh.... _now_ I get you!
19:05:12 <lambdabot> No quotes match. I've seen penguins that can type better than that.
19:05:17 <djahandarie> @remember ivanm < Cale> Finite dimensional vector spaces over a field F are algebras for the monad of F-linear combinations of elements of a set. < ivanm> oooohhhhh.... _now_ I get you!
19:05:18 <lambdabot> I will never forget.
19:05:18 <Cale> It's just nicer in the f.d. case, because you get those cute operations.
19:05:28 <ivanm> djahandarie: I was saying that to edwardk, not Cale
19:05:33 <Cale> Y U REMEMBER THING WITH MISTAKE
19:05:33 <djahandarie> I know :p
19:05:35 <Cale> ???
19:05:38 <edwardk> yeah. you can still cup, its capping that you can't do
19:05:38 <ivanm> and why remember it twice? :/
19:05:48 <djahandarie> Cale, too bad, don't make mistakes
19:06:00 <ivanm> oh, first one was quote rather than remember
19:06:07 <djahandarie> Yes, I do that every time
19:06:13 <edwardk> i'm currently splitting the two operations out so i can distinguish between the two possibilities.
19:06:41 <ivanm> edwardk: but will the end result be usable by anyone apart from yourself? :p
19:07:18 <edwardk> ivanm: anyways, with that you can now talk about Linear Double (P x, P y) as a multivariate polynomial with variables in x and y
19:07:37 <ivanm> with terms that are Double?
19:07:41 <edwardk> and you can switch to different bases for the polynomials, like Chebyshev polynomials.
19:07:49 <edwardk> with coefficients that are anyways
19:08:12 <edwardk> Linear s (P x, P y) will look like [(s, (P x, P y))]
19:08:38 <edwardk> with the normalization pass merging together coefficients for the same basis vector
19:09:37 <edwardk> i use the free monad of this when playing with probabilities and quantum computation
19:09:56 <ivanm> edwardk: what do you mean by "free monad" ?
19:10:00 <edwardk> because there i know the resulting matrices are unitary or subunitary
19:10:12 <edwardk> newtype Free f a = Pure a | Free (f (Free f a))
19:10:14 <edwardk> er data
19:10:18 <ivanm> oh, right, that thing
19:10:30 <ivanm> that I have trouble getting my head around :p
19:10:33 <edwardk> you know the thing that comes out of my mouth every other word that isn't Codensity ;)
19:10:37 <sam9> ivanm: sorry buy why couldn't I change my declaration to (Num a) => [Integer] -> [a] -> [a] ?
19:10:42 <edwardk> i just blogged about it again ;)
19:10:49 <ivanm> sam9: you can, if you shove a fromInteger in your code
19:11:37 <ivanm> sam9: but currently you're doing (gi xs n) * (gi ru (n * k))
19:11:44 <ivanm> as such, that will require xs and ru to be the same type
19:11:45 <sam9> ivanm: so if I do fromIntegral whenever I use ru then it would work?
19:12:02 <ivanm> if you make that: (gi xs n) * fromInteger (gi ru (n * k)) then it will work
19:12:16 <sam9> hm... I see... let me give it a try
19:12:36 <ivanm> sam9: also, why are you using genericIndex and genericLength rather than !! and length ?
19:12:43 <iwtu> any idea what's wrong?
19:12:54 <ivanm> they will slow your code down...
19:13:00 <ivanm> iwtu: with what?
19:13:02 <iwtu> http://codepad.org/eWHG8K0T
19:13:08 <sam9> ivanm: I just thought there might be some type conflicts...
19:13:22 <ivanm> sam9: how?
19:13:24 <edwardk> ivanm: https://github.com/ekmett/dsl2011/blob/master/VectorSpace.hs is a toy version of what i described, modulo the polynomial stuff
19:13:33 <ivanm> iwtu: you can't pattern match on Seq.empty
19:13:35 <edwardk> that was the version i used during the dsl workshop
19:13:53 <ivanm> iwtu: even if you could, you'd also have missing cases
19:14:22 <iwtu> ivana i know about missing cases but firt I wan to compile :)
19:14:23 <ivanm> @type empty
19:14:24 <lambdabot>     Ambiguous occurrence `empty'
19:14:24 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
19:14:24 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:56:0-22
19:14:41 <ivanm> iwtu: why not just use [] rather than Seq.empty ?
19:14:52 <iwtu> can I?
19:14:55 <edwardk> and if you care about quantum computation https://github.com/ekmett/dsl2011/blob/master/QM.hs is a version that added control for fanout of qbits
19:15:02 <edwardk> but that is pretty scary
19:15:04 <ivanm> iwtu: unless your import is wrong and that should be Data.Sequence rather than Data.List
19:15:23 <edwardk> and i don't think the workshop version had quantum lambdas
19:15:42 <sam9> ivanm: hm... you were right... I did not need those genericLength ... I just had some trouble last time so...
19:15:49 <sam9> ivanm: I'm very new to haskell :(
19:16:02 <iwtu> ivan, yes! :)
19:16:31 <edwardk> sam9: i'd highly recommend working on code that is less heavily packed together. move more stuff to the top level so you can see the combinators and the type signatures and you'll have an easier time
19:16:57 <edwardk> even if you don't plan on exporting those implementation details
19:17:13 <iwtu> ivanm, Map.empty also [] ?
19:17:19 <ivanm> edwardk: decided not to make an actual Num instance for a non-trivial one?
19:17:22 <ivanm> iwtu: no
19:17:32 <ivanm> iwtu: that was a mistake because I think your code is wrong anyway
19:17:35 <ivanm> iwtu: your imports are wrong
19:17:43 <ivanm> you should have Data.Sequence not Data.List
19:17:47 <edwardk> ivanm: the QM case or for Linear?
19:17:55 <ivanm> in VectorSpace.hs
19:17:59 <Saizan> edwardk: what's the advandage of Free (Linear p) ?
19:18:20 <Saizan> as opposed to just Linear p, i mean
19:18:27 <iwtu> http://codepad.org/iMYnT9ab
19:18:55 <ivanm> iwtu: you can't use []
19:18:58 <ivanm> I said that was a mistake
19:19:02 <edwardk> saizan: when the sum of p's is at most 1 in some sense (either because its a probability) or its a quantum complex probability such that the sum of the squares of the absolute values is 1 then you can choose to walk the free monad structure in a way that maximizes information gain by putting entries on a heap
19:19:12 <ivanm> because I thought you actually were using lists as sequences
19:19:20 <ivanm> @hoogle Seq a -> Bool
19:19:21 <lambdabot> Data.Sequence null :: Seq a -> Bool
19:19:21 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
19:19:21 <lambdabot> Data.Sequence index :: Seq a -> Int -> a
19:19:21 <edwardk> in the general linear case its a wash
19:19:30 <ivanm> iwtu: use Seq.null with guards
19:19:37 <edwardk> but in either of those latter cases you can get ever improving answers
19:19:53 <ivanm> or else use one of the unsnoc functions in Data.Sequence
19:20:10 <edwardk> see proj and proj_ at the bottom of the file which return the result as an non-empty stream of tightening bounds.
19:20:47 <ivanm> edwardk: so is there any particular reason for not making edwardk: so is there any particular reason for not making Linear an instance of Num ?
19:20:51 <Saizan> thanks :)
19:21:14 <ivanm> @type (<$)
19:21:15 <edwardk> in the probability case they return a p + [0,e]  in the quantum probability case they return a ball of radius e around the answer.
19:21:15 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
19:21:29 <ivanm> huh, don't recall that being part of Functor..
19:21:35 <benford> Hi folks could anyone help me fix my cabal install on osx, I seem to have a lot of broken libraries
19:21:36 <edwardk> ivanm: how does * work?
19:21:58 <edwardk> ivanm: in the polynomial case you have an answer. in general?
19:22:07 <ivanm> ahhh, fair enough
19:22:32 <edwardk> ivanm: its exported by Data.Functor and Control.Applicative
19:22:35 <ivanm> benford: run "ghc-pkg list" and do a "cabal install" for each broken package
19:22:53 <ivanm> edwardk: is it a newer addition to Functor?
19:23:04 <edwardk> ivanm: shortly after Applicative was added
19:23:06 <benford> thanks ivanm
19:23:09 <ivanm> ahhh
19:23:56 <edwardk> probably around when (*>) and (<*) got stuffed in
19:24:01 <iwtu> ivanm, you know what I mean. I am not sure about syntex. Can you fix it in order to show me?
19:25:42 <ivanm> iwtu: http://codepad.org/OeiEbYvz
19:26:05 <iwtu> thanks! :)
19:47:56 <ivanm> what would be the definition for compare for pairs? compare (a1,b1) (a2,b2) = case compare a1 a2 of EQ -> compare b1 b2; o -> o ?
19:48:46 <mjrosenb> ivanm: sounds correct.
19:51:24 <Saizan> compare (a1,b1) (a2,b2) = compare a1 a2 `mappend` compare b1 b2
19:51:52 <ivanm> well, I have a Map (Int, Int) a, and I want all those (Int,Int) pairs from the keys such that \ (w',b') -> w' <= w && b' <= b
19:53:24 <ivanm> and it seems to be faster to do [(w',b') | w' <- [0..w], b' <- [0..b], (w',b') `M.member` wbMap] than filtering on M.keys
19:54:09 <augur> which one of you peeps is brokendroid on twitter
19:58:07 <aavogt> ivanm: what fraction of the keys in the map does that accept in your case?
19:58:46 <ivanm> different each time
19:59:16 <ivanm> it's a repeated function, taking about 20% runtime for some reason :/
19:59:56 <ivanm> (when I wouldnt think it would be that expensive proportionally)
20:01:03 <aavogt> I mean if w*b is more than the number of elements in the Map, you're better off filtering on M.keys
20:01:49 <ivanm> the keys are sparse, if that makes a difference
20:03:56 <accel> nyone know how involved AH was in the skype fiasco?
20:13:23 <om-foxy> when a constant such as `alist = [1 :: Int,2,3,4,5]` is exported from a module, does that object exist as a CAF rather than a closure?
20:14:12 <wli-needjob> Isn't that by definition a CAF?
20:15:04 <om-foxy> I'm loading a module dynamically via GHC-API and I get an error: "During interactive linking, GHCi couldn't find the following symbol:
20:15:06 <om-foxy>   X_alist_closure"
20:15:21 <om-foxy> when I remove that from the export list the linking goes fine.
20:20:31 <morolin> Noob here: as I understand it, function composition is done with '.', but that character is also used to access functions brought in in qualified libraries.  Is there any connection between the two operations?
20:21:14 <om-foxy> morolin: no
20:21:20 <morolin> om-foxy: thanks
20:22:40 <monochrom> preflex: zdec ghczmprim_GHCziTypes_ZMZN_closure
20:22:40 <preflex>  ghc-prim_GHC.Types_[]_closure
20:22:41 <Hunner> Is there a way to get the time-cost for functions?
20:23:15 <Hunner> (specifically curious about elim, but also in general)
20:27:49 <Saizan> Hunner: it might be specified in the docs
20:28:01 <monochrom> om-foxy: I tried "ghc -c -ddumpl-asm" and I find X_alist_closure there.
20:28:23 <monochrom> actually I had -O too
20:29:39 <monochrom> without -O it is still there. just with less efficient contents
20:29:59 <monochrom> preflex: zdec ZC
20:29:59 <preflex>  :
20:32:07 <Hunner> Saizan: okay, so http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:elem doesn't mention anything (this is the right place, right?) but the source looks to be O(n)
20:32:09 <monochrom> sorry, same content, different internal naming and order
20:32:52 <Saizan> Hunner: yes, it's O(n)
20:33:19 <om-foxy> monochrom: I'm loading "X.hs" via the GHC API.  When I `touch X.hs` to force recompilation, the closure is found, however, when there is no compilation necessary, I get the error.  I've also verified that `alist` exists in the names exported by the module in both cases.
20:34:10 <koninkje> augur: Your wish is my command
20:34:32 <monochrom> your state is my comonad hehe
20:34:54 <augur> koninkje! :D
20:35:00 * hackagebot GLFW-b 0.0.2.8 - GLFW bindings  http://hackage.haskell.org/package/GLFW-b-0.0.2.8 (BrianLewis)
20:35:05 <augur> koninkje: ive been told you do some amount of linguistics
20:35:11 <augur> dirty modelling stuff
20:35:16 <koninkje> "some" ;)
20:35:22 <augur> or at least for modelling-ish reasons
20:35:42 * koninkje is working on a PhD in computational linguistics
20:35:48 <augur> *hiss*
20:35:49 * koninkje ...and cognitive linguistice
20:35:51 <augur> computationalists
20:35:53 <augur> COGNITIVE
20:35:55 <augur> eugh
20:36:09 * koninkje ...and unsuccessfully avoiding doing type theory
20:36:24 <augur> shame on you type theory is awesome
20:36:37 <koninkje> I know! that's why I keep failing to avoid it
20:36:45 <Hunner> koninkje: o/
20:36:47 <augur> :D
20:37:00 <koninkje> Hunner: welcome :)
20:37:08 <augur> koninkje: whats your primary interest ey?
20:37:10 <koninkje> Hunner: when'd you join the club?
20:37:13 <augur> in linguistics i mean :p
20:37:39 <Hunner> koninkje: I used haskell a lot during school, and just now rediscovering it after a year of being out
20:38:17 <koninkje> augur: In pure linguistics, morphological interfaces; especially morphosyntax and the semantics that goes along with it
20:38:29 <augur> nifty
20:38:32 <Hunner> koninkje: I ended up teaching a haskell BD, though not as good as yours
20:38:38 <augur> i saw your CCG presentation thing
20:38:49 <koninkje> augur: In not quite so pure linguistics, applying type theory and grammar formalisms to the pure issues
20:38:52 <augur> was that nasslli last year?
20:39:00 <koninkje> Yeah, last summer
20:39:03 <augur> cool
20:39:06 <koninkje> Were you there or just saw the slides?
20:39:14 <augur> nah i wanted to go but no money for it
20:39:16 <augur> same this year
20:39:19 * koninkje nods
20:39:20 <augur> edwardk linked to them
20:39:28 <koninkje> I saw
20:39:54 <koninkje> Hunner: Did I ever do a Haskell BD? I thought I just did Perl...
20:40:18 <augur> koninkje: so i take it youre not a fan of chomskyan linguistics huh
20:40:19 <augur> :P
20:40:28 <koninkje> not so much )
20:40:31 <koninkje> er, :)
20:40:39 <augur> for shame!
20:40:50 <augur> there are some interesting possibilities that noones looked into
20:41:00 <Hunner> It may have been the perl one that turned into haskell.. it was so long ago that I forget, but you definitely showed something about Haskell
20:41:41 <koninkje> I dunno, some crazy part of me is interested in how *we* process language, not just how some machine somewhere might possibly be able to process language (in O(n^8) time, or whatever it is)
20:42:06 <augur> well, im not interested in how some machine somewhere might do it either
20:42:09 <augur> neither are many chomskyans
20:42:22 <koninkje> Well, they're not interested in how people do it :)
20:42:23 <augur> also, stabler's shown that minimalist grammars are mildly CS just like CCG :P
20:42:31 <augur> oh ofcourse they are, koninkje
20:42:38 <augur> some are anyway
20:42:48 <koninkje> I was pretty sure Stabler proved it was a bit stronger than mild-CF
20:42:52 <koninkje> er, mild-CS
20:42:55 <augur> nup
20:43:00 <augur> mildly CS.
20:43:05 <koninkje> hmm, reference?
20:43:22 <augur> the UMD-associated psycho/neuro/acqui people are all chomskyans
20:43:31 <augur> hmm ill have to find, but most of stablers papers
20:43:40 <koninkje> yeah
20:44:44 <koninkje> The more computationally minded Chomskyans are alright, but too much of that world has been drowned un pseudo-formalisms; which is why I'm a fan of the more formal grammars
20:44:51 <augur> Michaelis, J. Derivational minimalism is mildly context-sensitive. In Proceedings, Logical Aspects of Computational Linguistics, LACL’98 (NY, 1998), Springer, pp. 179–198.
20:44:55 <lemon__> hi
20:44:58 <augur> Stabler, E. P. Varieties of crossing dependencies: Structure dependence and mild context sensitivity. Cognitive Science 93, 5 (2004), 699–720.
20:45:02 <lemon__> please is this possible ?
20:45:03 <lemon__> function a
20:45:03 <lemon__>   | condition1 = val1
20:45:04 <lemon__>     where
20:45:04 <lemon__>       ...
20:45:04 <lemon__>   | condition2 = val2
20:45:05 <lemon__>     where
20:45:07 <lemon__>       ...
20:45:10 <augur> lemon__: use hpaste
20:45:25 <augur> koninkje: ill agree about the pseudo-formalism crap
20:45:40 <augur> its frustrating trying to talk about minimalism when everything is so fucking fuzzy
20:45:51 <dolio> lemon__, I don't think where clauses scope that way, no.
20:46:13 <lemon__> so i can use where only on the last guard  ?
20:46:24 <koninkje> augur: thanks for the links, I'll have to check them out
20:46:26 <augur> koninkje: it seems CCG < MG
20:46:27 <dolio> A single where block would apply to all the guards.
20:46:38 <lemon__> aah
20:46:44 <lemon__> great, thank you
20:46:58 <dolio> > let f x | x > 5 = y | x < 5 = y | otherwise = 4 where y = 2 in f 5
20:46:58 <lambdabot>   4
20:47:00 <om-foxy> monochrom:  I just did `ghc -c -ddump-asm`.  The problem is that the dynamic linker only finds the constant `alist` when the .hs file is recompiled, not when the .o hasn't changed.
20:47:59 <koninkje> augur: That's what I thought. CCG ~ TAG ~ the other one I forget. So since MG is more powerful than CCG it's in a different class (between CCG ~ TAG and CS)
20:48:17 <augur> koninkje: head grammars and linear indexed grammars are the other two.
20:48:36 <augur> MG is a superset of CCG and a subset of CS but still Mildly CS
20:48:37 <koninkje> right
20:48:51 <lemon__> dolio: thank you very much :)
20:48:52 <augur> so what kinds of computational/CTic techniques do you use, koninkje
20:49:29 <koninkje> I've always taken "mildly CS" to be an official name for the TAG etc class, rather than for anywhere between CF and CS; though I know other folks differ
20:49:39 <augur> no, mildly CS is just a class of properties
20:50:15 <augur> wikipedia says it has to admit cross serial dependencies, polynomial time parsable, and have constant growth
20:50:31 <augur> im guessing this is joshi's def
20:50:57 <koninkje> Joshi's def was based on the three-way reduction, IIRC
20:51:09 <augur> maybe!
20:51:15 <augur> maybe its vijay-shanker and weirs. who knows.
20:51:29 <koninkje> in any case, it's not expecially well mapped out like sub-CF is :)
20:51:39 <koninkje> brb, laundry
20:51:39 <augur> so what kind of stuff do you use CS-y theory for?
20:51:42 <augur> D:
20:51:44 <augur> laundry :|
20:51:53 <augur> you're a geek! you dont need clean clothes
20:54:21 <parcs> :t fromIntegral :: Integral a => a -> a -- does using this incur a performance penalty ?
20:54:21 <lambdabot> forall a. (Integral a) => a -> a
20:55:46 <dmwit> parcs: Yes, using anything incurs a performance penalty.
20:55:56 <dmwit> (Or: what's your real question?)
20:57:56 <parcs> ..i'm not sure i have a real question, actually
20:57:58 <parcs> i need sleep
20:57:59 <om-foxy> dmwit: so doing nothing is the most efficient?
20:58:08 <lemonade> another quick question, if i have [ a | b <- c, foo = myfunction b, a = fun foo ] this will not compile. If i use let will it be ok ?
20:59:04 <dmwit> Try it. =)
20:59:04 <koninkje> augur: Well, for example, the semantic logic presented in my NASSLLI slides is based off stuff in type theory
20:59:26 <augur> koninkje: i didnt really get your slides. needs a video. :P
20:59:45 <koninkje> A lot of things about partial evaluation, staged computation, and the explicit recursion breaks in PiSigma look very similar
21:00:01 <augur> tell me more ..
21:00:04 <koninkje> Unfortunately, I haven't had the time to thoroughly explore which of them reduces to which
21:00:10 <edwardk> heya koninkje: augur has wanted to pick your brain for a while.
21:00:13 <lemonade> dmwit: it seems to work but i don't understand very much the concept so i'm asking :)
21:00:13 <edwardk> oh, wait there he is
21:00:15 <dolio> > [ y | x <- [1..3], let y = x+1 ]
21:00:16 <lambdabot>   [2,3,4]
21:00:21 <augur> edwardk: ALREADY ON IT THANKS
21:00:21 <augur> GOSH
21:00:24 <edwardk> =)
21:00:34 <lemonade> good
21:00:35 <augur> edwardk: get back to writing about CT with examples.
21:00:36 <lemonade> thx
21:00:58 <edwardk> busy trying to refactor the way the free package and mtl and the comonad-transformers package interact
21:00:58 <dmwit> lemonade: That's not so much a concept as it is syntax.
21:01:02 <dmwit> Nothing deep to understand.
21:01:13 <augur> edwardk: sounds pretty pointless if noone knows what to do with it!
21:01:25 <koninkje> augur: So you have an expression like this (\_A a. [ \_B b. ... ]_C) [...]_A
21:01:44 <augur> what now
21:01:45 <koninkje> augur: the beta reduction will move the second ... into wherever it goes in the first ...
21:01:56 <augur> \_A ?
21:02:05 <lemonade> dmwit: well for me its weird, because in where expression, i don't have to use let for new variables, they just start to exist
21:02:14 <koninkje> But now, we're under a bracket, so the question is: do we keep evaluating?
21:02:22 <dmwit> lemonade: Yep. Just a different syntax here.
21:02:27 <lemonade> ah, ok
21:02:28 <lemonade> :)
21:02:31 <augur> koninkje: hold on, step back. i dont follow this notation
21:02:33 <koninkje> augur: lambdas and values are subscripted by their "dimension"
21:02:39 <augur> ??
21:02:55 <koninkje> Okay, step one, we'll just have one dimension, k?
21:03:16 <augur> sure, whats a dimension? :P
21:03:42 <koninkje> Well, if there's only one, it doesn't matter :)
21:03:56 <augur> :P
21:03:58 <koninkje> Basically, all values are explicitly boxed like so: [ e ]
21:04:00 <augur> ok one dimension!
21:04:07 <augur> ok, and boxes are... boxes?
21:04:22 <koninkje> And all functions, _as functions_ are just like usual (\x. e)
21:04:28 <augur> crucially, can they be wooden chests or only cardboard boxes
21:04:35 <augur> ok
21:04:39 <koninkje> N.B., functions _as values_ are boxed: [ \x. e ]
21:04:51 <augur> hmm
21:05:00 <koninkje> Now, beta reduction only occurs when a function is applied to a box
21:05:10 <augur> ok
21:05:18 <koninkje> (\x. e) [f] ---> e{x->f}
21:05:39 <koninkje> But, for example, this doesn't simplify (\x. e) (\y. f)
21:05:48 <augur> ok
21:05:49 <koninkje> That's a composition of sorts
21:05:50 <augur> interesting
21:06:22 <koninkje> So if we just have this much it's maybe interesting, but not especially useful
21:06:42 <koninkje> To generalize this, we add the notion of "dimensions" or "axes"
21:06:57 <koninkje> All boxes exist on a dimension: [ e ]_A
21:07:20 <augur> ok
21:07:21 <koninkje> and all functions take arguments from a specified dimension: (\_A x. e)
21:07:45 <koninkje> With multiple dimenstions we revise our beta reduction to say that we only reduce if the dimensions match
21:08:02 <koninkje> (\_A x. e) [ f ]_A ---> e{x->f}
21:08:05 <augur> sure sure
21:08:53 <koninkje> so, the reason I came up with all this, is that if we visualize these "dimensions" as an actual multidimensional space, then we'd expect something like this to work:
21:09:24 <koninkje> (\_A x. \_B y. e) [ f ]_B ---> (\_A x. e{y->f})
21:09:44 <augur> hmm
21:09:47 <Cale> cute
21:09:49 <augur> that seems not kosher
21:09:50 <augur> but ok
21:10:02 <koninkje> It's just named arguments right? only dimension-safe
21:10:07 <augur> so different dimensions allow permutation of lambdas
21:10:29 <koninkje> well, the funny thing is, there are two different ways of phrasing the rules
21:10:34 <augur> \_A x. \_B y. M   ~   \_B y. \_A x. M
21:10:44 <koninkje> The first way is, as you say, rearranging lambdas
21:11:01 <koninkje> The other way is to rearrange the applications
21:11:13 <koninkje> Both of them, of course, when the dimensions aren't the saem
21:11:56 <dmwit> (\_A x. e) [ e' ]_B ~ (\_A x. e [ e' ]_B) -- this looks like a very scary rule
21:12:08 <Cale> It does mildly smack of dynamic scoping.
21:12:29 <koninkje> e.g., (\_A x. \_B y. e) [f]_B [g]_A ---> (\_A x. \_B y. e) [g]_A [f]_B ---> (\_B y. e{x->g}) [f]_B ...
21:12:53 <koninkje> dmwit: yes, that does look scary
21:12:56 <augur> koninkje: ok
21:13:07 <Cale> Is that scary?
21:13:31 <koninkje> Cale: Well it alters the type-- er, dimensions
21:13:48 <dolio> @karma type
21:13:48 <lambdabot> type has a karma of -1
21:14:07 <augur> koninkje: ok so hows this connect to language? :p
21:14:32 <koninkje> So I came up with all of this to model the (constrained) free word order in Japanese
21:14:37 <dmwit> Well, given that when I said "scary" I meant only "a new kind of rule that dmwit has never seen", yes, it's scary. =P
21:14:40 <augur> aha
21:14:42 <koninkje> ...which is what the NASSLLI talk was about
21:15:04 <augur> koninkje: can i point out that the lambda calculus already allows the rearranging of lambdas? :P
21:15:17 <augur> well, (a -> b -> c) -> (b -> a -> c)
21:15:39 <koninkje> The funny thing is. The two different rules (let's call the chi and ksi) agree in almost all circumstances that arise in natural language
21:15:55 <augur> which rules now
21:16:03 <koninkje> The only place I've found that they disagree is with subordinate clauses, and native speakers disagree about which is right!
21:16:16 <koninkje> augur: rearrange lambdas vs rearrange applications
21:16:26 <augur> oh ok
21:16:59 <augur> so how is this different from the sort of stuff you could do with a flip combinator?
21:17:17 <koninkje> Yes, I know that lmabda calculus can already rearrange lambdas, but the problem is that there's no good syntax-directed method for generalizing over the need for those combinators
21:17:51 <augur> ahh, so you tie these into some syntactic stuff, not just freely choose combinators to make it parse?
21:18:01 <koninkje> exactly
21:18:04 <augur> interesting
21:18:06 <augur> what triggers it?
21:18:17 <koninkje> We want the good parses to type check and the bad parses not to
21:18:39 <koninkje> chi- (or ksi-)reduction is just part of the normal reduction
21:19:01 <koninkje> So evaluation is chi/beta-reduction (or chi/beta/eta- ...)
21:19:23 <koninkje> With the right internal representation you don't even need to simulate using the combinators
21:19:41 <koninkje> the need for combinators just comes from artificially linearizing the calculus to put it on paper
21:19:41 <augur> ok.. im not following how this would be triggered tho
21:20:00 <augur> i mean, otherwise wouldnt it just be like free use of combinators
21:20:03 <koninkje> Well, if we have an application then we need to reduce it, right?
21:20:11 <augur> sure
21:20:14 <augur> i suppose
21:20:19 <hpaste> Rex pasted “list of eithers to either of list” at http://hpaste.org/48452
21:20:20 <koninkje> So if it doesn't reduce right away, try all reorderings
21:20:42 <augur> what determines if it reduces, exactly?
21:20:59 <rex_fernando> I'm new at haskell, and was wondering what I'm doing wrong (pasted above)
21:21:04 <koninkje> If the dimension of the outermost lambda matches the dimension of the first applicand
21:21:10 <augur> oh i see
21:21:18 <augur> so just the normal sense + dimensions
21:21:26 <koninkje> exactly
21:21:39 <augur> ok
21:21:43 <augur> hmm
21:21:48 <koninkje> Of course, you can come up with some fun non-reducing expressions like: [e]_X [f]_Y
21:21:55 <rex_fernando> or if there's any better way to do that
21:21:57 <koninkje> Which is, of course, just a tuple of e and f
21:22:12 <augur> sort of a tuple
21:22:13 <koninkje> The curry/uncurry isomorphism comes for free
21:22:18 <augur> hm.
21:22:26 <koninkje> from the notation I mean
21:22:27 <dolio> rex_fernando, "iter d:b ds" = "(iter d):(b ds)"
21:22:48 <dolio> You want "iter (d:b) ds"
21:22:59 <augur> koninkje: so basically your dimensions are simultaneous arguments
21:23:16 <koninkje> Under the reordering lambdas rule, yes
21:23:30 <koninkje> under reordering applications, it's not quite (though it's close)
21:23:42 <augur> well, sort of simultaneous. arguments under some partial ordering that lets you freely choose one of multiple outer most arguments
21:24:12 <augur> presumably \_A x. \_A y. M   /~   \_A y. \_A x. M
21:24:17 <koninkje> Well, with reordering lambdas, say I have a function (\_A x. \_B y. \_C z. ...)
21:24:34 <rex_fernando> dolio: thanks a lot
21:24:42 <koninkje> given that function, the A, B, and C need to ---in some sense--- be applied all at once
21:24:56 <augur> koninkje: ok
21:25:10 <augur> but what about the possibility of multiple lambdas with the same dimension
21:25:20 <koninkje> If we apply it as (foo [a]_A [d]_D [b]_B [c]_C) then we're hosed
21:25:26 <augur> i mean, \_A x. \_B y. \_A z. M
21:25:36 <koninkje> there's no way to rearrange the lambdas in foo in order to move the [d]_D out of the way
21:25:43 <augur> do you want the B to be able to permute or
21:26:03 <augur> i see, so if foo has no D dimension
21:26:10 <augur> then you're stuck
21:26:37 <koninkje> But, if you do want it to reduce (by fiat), then you want to use the reordering of applications instead; then you can just push it out of the way
21:27:11 <koninkje> Where this difference shows up in natural language is whether the phenomenon called "scrambling into" is allowed
21:27:39 <koninkje> I.e., can constituents of the matrix clause scramble their way into the middle of the subbordiate clause
21:27:50 <koninkje> Some languages say yes; others say no
21:28:02 <koninkje> Just like the two different rules: one says yes, the other says no
21:28:06 <augur> right but
21:28:12 <augur> that sort of doesnt answer the question then :P
21:28:19 <koninkje> whic question?
21:28:27 <augur> i mean, the mystery of scrambling is precisely that
21:28:38 <koninkje> what?
21:28:49 <augur> ofcourse we know that there are these effects, and the simplest answer would be to just parameterize what can scramble where
21:29:01 <augur> but thats a huge hairy mess
21:29:31 <koninkje> But that all boils down to whether the semantics of the grammar is using chi-reduction or ksi-reduction
21:29:55 <koninkje> That decides whether the grammar allows scrambling into or not
21:30:11 <augur> hm.
21:30:25 <augur> do you read only the CCG-ish literature on scrambling?
21:30:33 <koninkje> The other big question that shows up is when certain kinds of scrambling are prohibited...
21:30:36 <koninkje> nope
21:30:57 <augur> cause the chomskyan literature is pretty extensive and from what ive seen the facts are really messy
21:31:04 <koninkje> ...For example, in Japanese, for affective verbs the primary affect must always preceed the secondary affect
21:31:20 <koninkje> However, it is worth noting that both affects use the same case marking
21:31:37 <augur> i should find masaya's paper for you
21:31:42 <augur> it was abotu scrambling and case i think
21:31:45 <koninkje> If we use the case marking as the dimensions (reasonable enough), then the fact that they can't scramble falls out for free
21:32:55 <koninkje> One of the other nice metatheoretical things that falls out from this grammar formalism is that it explains the correspondence between languages with case and scrambling, vs those without case and without scrambling
21:33:22 <koninkje> basically it comes down to how much the grammar leans on dimensionality, vs how close to uni-dimensional it is
21:34:08 <augur> hmm masaya's paper isnt available :(
21:34:21 <augur> er
21:34:29 <augur> case and scrambling arent as tightly correlated as that, you know
21:34:44 <augur> many languages are case heavy but lack scrambling
21:34:44 <koninkje> I know, but there is a strong correlation nevertheless
21:34:54 <augur> and many are case free but obnoxiously scrambling
21:35:14 <augur> ehh.. im not so sure its even a strong correlation
21:35:33 <koninkje> It's strong enough to have been commented on repeatedly in the literature
21:36:34 <koninkje> So far as I'm aware, noone else has any formalized reason for why the correlation should exist
21:36:42 <augur> i'd want to see the data on it.
21:36:53 <koninkje> the correlation?
21:36:55 <augur> yeah.
21:37:22 <augur> a lot of seeming correlations are illusions. i'd want to see a proper analysis that factors out relatedness and sprachbund effects
21:38:01 <koninkje> I'd love to see that too; unfortunately I don't know that the data has been collected yet
21:38:30 <augur> well then i'd be skeptical of the claimed correlation :P
21:38:33 <koninkje> e.g., WALS is only so much better than anecdotal evidence
21:39:07 <cheater_> right so you define dimensions as the cases, and then in a long-winded discourse you conclude that from this that languages with few cases are like one-dimensional.
21:39:20 <cheater_> i bet you write a thousand papers a year
21:39:24 <cheater_> jesus
21:39:36 <koninkje> cheater_: that's not at all what I said
21:39:44 <augur> koninkje: pay him no mind
21:40:33 <cheater_> <koninkje> If we use the case marking as the dimensions                   languages with case and scrambling, vs those without case and without scrambling                   basically it comes down to (..) how close to uni-dimensional it is
21:40:48 <koninkje> So anyways, I use programming language theory for stuff like that
21:40:55 <augur> hm!
21:41:00 <cheater_> see look i took your conversation and extracted the meaning out of it, leaving out the .pdf lingo
21:41:08 <koninkje> Also, I tend to work on multi-grammars for machine translation
21:41:17 <cheater_> how's that for language formalism! applied!
21:41:49 <augur> koninkje: we should form a little study group of some sort for linguistic applications of plt and ct and so forth
21:42:00 --- mode: ChanServ set +o Saizan
21:42:07 <koninkje> definitely
21:42:46 <koninkje> I'm still trying to work out decent ways of applying CT to linguistics (directly)
21:43:02 <cheater_> with this amount of literary output you could even start a journal or two :p
21:43:06 <augur> ive been trying to work out an understanding of derivationality in plt terms. it seems to me like its just induction principles.
21:43:09 --- mode: Saizan set +q cheater*!*@*
21:43:26 <koninkje> augur: what do you mean by "derivationality"?
21:43:28 --- mode: Saizan set -o Saizan
21:43:31 <augur> koninkje: im still trying to work out decent ways of applying CT to computer science!
21:43:36 <koninkje> hee hee
21:43:38 <augur> derivationality is a chomskyan notion
21:43:46 <koninkje> ah, I think I missed that one
21:43:50 <augur> its fuzzy, but the idea generally is something like
21:44:14 * koninkje has studied a good deal of Chomsky, but nothing over the last 5~7 years
21:44:27 <augur> a property (say, a relation over a tree) can be constructed in the course of a derivation rather than only at the end
21:44:58 <augur> noone really has a good explanation of what "in the course of a derivation" means, tho
21:45:14 <koninkje> riiight
21:45:18 <augur> sometimes its used to mean constraints on derivations
21:45:34 <augur> which i interpret to mean formal constraints on inference rules
21:45:46 <augur> but people talk about other things like c-command being derivational
21:46:34 <koninkje> I'd guess it's more about constraints on the global derivation, rather than just constraints on the local rules
21:46:39 <augur> but the best formulation i can figure is really just that derivationality = being an induction principle
21:46:50 <koninkje> (context sensitivity and all that)
21:46:50 <augur> well see thats the thing
21:47:02 <augur> people dont want to have constraints on global derivation structures
21:47:11 <koninkje> of course they don't :)
21:47:12 <augur> those are representational/global constraints
21:47:17 <Eduard_Munteanu> augur: oic back
21:47:18 <augur> i mean, some do, but the derivationalists dont :p
21:47:41 <augur> the idea of derivationality is that you localize the constraints
21:47:47 <koninkje> I'm just thinking that it sounds a lot like some of the constraints or "features" that show up in machine translation
21:47:49 <augur> but its still really a fuzzy notion.
21:48:00 <augur> i'd point you to the epstein et al book on the topic
21:48:10 <koninkje> We;d like for them to be as local as possible, but there are certain constraints we'd like but which we don't know how to make local
21:48:11 <augur> its so .. murky
21:48:30 <augur> yeah that seems to be related, definitely
21:49:01 <augur> there are also ideas like inclusiveness, which is also murky, but which roughly means something like "dont add or remove information"
21:49:04 <koninkje> n.b., that's with a really guts and bolts kind of grammar; so not really the kind of "locality" that gets talked about in, say, TAG
21:49:17 * koninkje nods
21:49:29 * koninkje runs out again
21:49:55 <augur> and other things like shortest move which are crazy transderivational optimization-like ideas that seem to capture a good deal of binding facts
22:02:10 * koninkje returns
22:02:50 <augur> return!
22:03:00 <rhdoenges> where should I begin if I want to learn haskell? I've never really programmed functionally effectively before and I want to start.
22:03:29 <augur> @where lyah
22:03:29 <lambdabot> http://www.learnyouahaskell.com/
22:03:32 <koninkje> augur: One of the other nifty things about my multi-dimensional lambda calculus is that the conflation between composition and application that's so common in CT notation also falls out of it
22:03:35 <augur> rhdoenges: there.
22:04:00 <augur> koninkje: so explain that part again
22:04:19 <rhdoenges> augur: thanks.
22:04:27 <koninkje> So in CT folks will write things like FG to mean (F . G)
22:04:36 <augur> sure sure
22:05:09 <koninkje> If we consider functors at functions, then the application (F G) is just (F G) because it can't reduce, no boxes
22:05:37 <augur> hm
22:05:37 <koninkje> Whereas (F G X) where X is some [e] is the same as F(G X)
22:05:55 <augur> so its a sort of syntactic notion of composition
22:05:58 <augur> not a semantic one
22:06:05 <koninkje> yep
22:06:31 <augur> i see
22:07:09 <koninkje> So, composition, application, and tupling are all done via juxtaposition in that calculus
22:07:29 <koninkje> Which is kinda wacky, but also makes a disturbing amount of sense
22:08:19 <augur> but its crucially syntactic composition and tupling
22:08:32 <koninkje> yes
22:09:16 <koninkje> this is one of the interesting things that falls out even without the multiple dimensions
22:10:06 <augur> that falls out of the normal LC tho
22:10:14 <koninkje> how so?
22:10:42 <koninkje> (\x. e) (\y. f) ---> e{x->(\y. f)}
22:10:45 <augur> well, fg cant reduce
22:11:04 <koninkje> but (f g) can
22:11:12 <augur> no it cant
22:11:21 <augur> beta reduction only applies to lambda expressions
22:11:23 <koninkje> I just did it above
22:11:32 <augur> if f and g are both variables, it cant reduce
22:11:41 <augur> no no im being very specific in what im writing :P
22:11:44 <koninkje> okay, fine, we do delta-reduction first
22:11:51 <augur> delta reduction?
22:12:09 <koninkje> replace defined variables by their definition
22:12:26 <koninkje> I'm pretty sure that one's called delta
22:12:44 <dolio> Yes.
22:13:00 <augur> no i dont mean defined variables
22:13:08 <augur> \f. \g. f g
22:13:16 <augur> f g cannot reduce
22:13:27 <Hunner> @djinn (a -> a -> b) -> (a -> b)
22:13:28 <lambdabot> f a b = a b b
22:14:00 <koninkje> Sure, but what about when f and g are concrete, i.e. defined
22:14:20 <augur> koninkje: well thats different, obviously
22:14:33 <augur> im just saying, the LC already has cases where things dont reduce
22:14:44 <koninkje> category theorists like saying things like define (FG)(X) = F(GX)
22:14:47 <augur> even tho in principle they could eventually reduce after substitution
22:14:54 <augur> yes i know :P
22:15:08 <augur> \f. \g. \x. f (g x)
22:16:06 <augur> koninkje: but i get your point
22:16:16 <koninkje> oh good :)
22:16:26 <augur> i would be concerned about how that would work tho, because the LC is usually structured
22:16:44 <augur> expressions are technically trees, or at least properly parenthesized
22:17:00 <augur> f g x is (fg)x where f is APPLIED to g, right
22:17:30 <augur> but if you take seriously the juxtapose stuff like you're doing, you're making it ambiguous whats an application and whats a composition
22:17:43 <koninkje> application chains are associative in the dimensional lambda calculus
22:17:43 <augur> the categorialists get away with it because they have conventions, right
22:18:14 <augur> but i would worry about introducing ambiguities that themselves need a theory
22:18:22 <Eduard_Munteanu> I think it's all composition if you take points as generalized elements.
22:18:32 <augur> yes theres that too
22:18:39 <koninkje> But it's not ambiguous because we distinguish functions as procedures vs functions as data, just like CT does morphisms vs exponentials
22:18:40 <augur> except when its not
22:18:54 <augur> F(GX)(HY) is certainly not FGXHY as a composition, surely surely
22:19:08 <koninkje> Why not?
22:19:23 <augur> well, how does the F get the HY
22:19:28 <augur> XHY is just that X
22:19:38 <augur> if X is a generalized element
22:19:45 <augur> so GXHY is just that GX
22:20:03 <dolio> GXHY is a tuple of GX and HY in his calculus.
22:20:08 <koninkje> (F G X H Y) ---> (F GX H Y) ---> (FGX H Y) ---> (FGX HY) ---> FGXHY
22:20:10 <augur> dolio: only syntactically
22:20:33 <koninkje> No, applying H to Y has to give some kind of result
22:20:36 <koninkje> right?
22:20:40 <augur> ofcourse
22:20:49 <koninkje> So (H Y) ---> HY
22:20:50 <augur> but X is a generalized element, so composing with that result eliminates it
22:21:01 <koninkje> (whatever that happens to be)
22:21:03 <augur> X . H . Y   ~   X
22:21:10 <augur> modulo types
22:21:21 <koninkje> no, X H Y ~ X HY
22:21:34 <augur> yeah
22:21:37 <augur> but like i said
22:21:44 <jeffz> HP is very slow to download, 30kb/sec avg!
22:21:47 <augur> if X is a generalized element, the HY is irrelevant
22:21:58 <koninkje> what do you mean by "generalized element"?
22:22:00 <augur> X as a generalized element is just \_ -> x
22:22:07 <dolio> No, that's also wrong.
22:22:14 <augur> dolio: no its not, what
22:22:20 <augur> generalized elements are X -> 1 -> Y
22:22:26 <dolio> Generalized elements are not, in general, constant functions.
22:22:32 <koninkje> So is X = (\_ -> x) or is X = [\_ -> x] ?
22:23:01 <augur> dolio: if x is a generalized element x : Y -> X
22:23:09 <dolio> Yes.
22:23:16 <augur> then x = x' . ! . f
22:23:20 <dolio> It is any arrow from Y to X.
22:23:40 <koninkje> For F(GX)(HY) to be well-formed, X has to be a box in order for it to reduce with G. Assuming X is a box then FGXHY is just fine
22:23:43 <augur> er, no f sorry
22:23:46 <koninkje> ... and means the same
22:24:09 <augur> mm dolio http://ncatlab.org/nlab/show/generalized+element
22:24:21 <koninkje> Or there has to be a box [GX], in which case it's also fine
22:24:48 <koninkje> Remember, there's no silent coercions between morphisms and exponentials here
22:25:13 <dolio> augur: That page says exactly what I said.
22:25:22 <augur> it says the opposite!
22:25:50 <augur> it says clearly that a generalized element is just an x : U -> X that produces x
22:26:08 <dolio> It says that any morphism from U to X is a generalized element of X at stage U.
22:26:24 <dolio> It says nothing about it factoring through a terminal object.
22:26:28 <augur> hmm...
22:26:33 <augur> ok well either way
22:26:34 <lemonade> I've got problem. I have code, successfully compiled but it does segfault. (it says stack overflow). I would like to trace it and find out where is the problem, but no trace is printed. Can I do anything about it ?
22:27:15 <augur> if Y is a generalized element and so is X, XY is not going to give you back Y magically. So F . X . Y isnt going to be the same as (FX)Y
22:27:41 <koninkje> lemonade: segfault is different from stack overflow; you could post your code to hpaste
22:28:34 <lemonade> koninkje: well the code is quite complex and i dont want to bother you
22:28:43 <koninkje> lemonade: ah
22:29:22 <lemonade> i just don't understand why the traces are not printed
22:29:44 <koninkje> Probably the things being traced aren't being evaluated
22:29:59 <dolio> That's probably the cause of the stack overflow, too.
22:30:16 <lemonade> well i would think that is impossible
22:30:21 <lemonade> if i paste two lines from the code
22:30:26 <lemonade>             let (_, mv_tmp) = (show "makeMinMaxDecision2") `trace` minmaxCalculate board depth 1
22:30:30 <lemonade> this trace is printed
22:30:43 <lemonade> minmaxCalculate board depth cur_depth
22:30:43 <lemonade>   | (depth == cur_depth)  = (show "minmaxCalculate1") `trace` (score_simple,boardBotPosition board)
22:30:43 <lemonade>   | otherwise = (show "minmaxCalculate2") `trace` res
22:30:50 <lemonade> neither of this traces are printed
22:31:09 <lemonade> but this is just one call there should not be a stack overflow between them
22:31:45 <koninkje> So, before it can print either trace it must compute depth and cur_depth far enough to decide equality
22:31:57 <augur> koninkje: do you know of any good reading for applications of CT? cause noone seems to :P
22:32:06 <koninkje> (otherwise it doesn't know whether the guard fails or succeeds, right?)
22:32:28 <lemonade> koninkje: yes, but these values are parameters
22:32:29 <koninkje> augur: can you narrow down the domain a bit? ;)
22:32:46 <koninkje> lemonade: yes, but Haskell is lazy, so they may not have been computed yet
22:32:58 <lemonade> aah
22:33:02 <augur> koninkje: ct for plt
22:33:09 <augur> that isnt type theory stuff
22:33:42 <koninkje> ...oh, darn
22:34:17 <lemonade> koninkje: you are right thank you so much!
22:34:19 <koninkje> I was going to suggest some of Neil Ghani and Patricia Johann's work; but that's still fairly type theoretic
22:34:24 <augur> :)
22:34:26 <koninkje> lemonade: np :)
22:34:37 <augur> the coolest stuff ive seen so far is the levitation stuff
22:35:06 <koninkje> Though they do things like use CT to show that we can make the standard suite of catamorphisms, paramorphisms,... for GADTs too
22:35:33 <Saizan> the levitation paper uses CT?
22:35:35 <koninkje> (though ekmett suggests that there may be some squishyness in their particular proof)
22:36:00 <augur> Saizan: no but i think the original paper on codes does
22:36:06 <augur> the altenkirch and someone paper
22:36:13 <augur> and its all algebraic notions
22:36:13 <koninkje> augur: There are a few papers on applying monads to language-based security problems
22:36:29 <augur> thats really specific and sounds horrendous
22:36:30 <augur> :P
22:36:49 <koninkje> hey, you wanted non-type theory!
22:36:53 <koninkje> :P
22:36:57 <augur> yeah but not /security/ stuff
22:36:59 <augur> come on
22:37:16 <koninkje> it's language-based at least
22:37:20 <augur> pah
22:37:21 <koninkje> bisimulations and all that fun stuff
22:37:34 <augur> i could read on these simulation concepts
22:37:37 <augur> thatd be interesting i bet
22:37:40 <augur> i dont know anything about it
22:38:04 * koninkje tries to think if Amal has any decent intro stuff
22:38:17 <augur> i also want to see applications of adjunction. i keep hearing that they relate to optimization of some sort but i cant see how they apply to what people normally mean when they say optimization
22:38:46 <koninkje> hmm, I haven't heard them being mentioned with optimization before (or I've forgotten)
22:39:14 <augur> people also keep mentioning kan extensions but god knows how those touch reality
22:39:18 <Eduard_Munteanu> augur: in the meanwhile, any introductory stuff on your kind of linguistics?
22:39:26 <augur> Eduard_Munteanu: why yes!
22:39:40 <koninkje> augur: that's right, I've been meaning to ask; what soet of linguistics do you do?
22:39:59 <Eduard_Munteanu> I asked him a couple of times before but I'm still really unsure :)
22:40:01 <augur> syntax
22:40:19 * Eduard_Munteanu doesn't really know linguistics at all
22:40:33 <augur> Eduard_Munteanu: http://www.wellnowwhat.net/blog/?p=93
22:40:44 <Eduard_Munteanu> Thanks, *looking*
22:40:54 <augur> my map is missing a label for GS but thats ok cause noone cares about it
22:41:22 <augur> also its a very high level overview
22:42:45 <Eduard_Munteanu> Ok, so earlier when I mixed "computational" and "linguistics" I wasn't too off, this is about formal languages, right?
22:42:57 <augur> actually you were way off
22:43:01 <Eduard_Munteanu> :)
22:43:02 <augur> most comp ling is nlp these days
22:43:14 <augur> which means CFGs and bayesian inference
22:43:18 <koninkje> augur: so what sort of syntax do you work on, other than covering the literature?
22:43:19 <augur> or maybe support vector machines
22:43:21 <augur> or whatever you like
22:43:37 <koninkje> augur: FWIW, when I said I do comp ling, I meant I do comp ling
22:44:07 <koninkje> I also do nlp incidentally, but my interest is in the linguistics not the stats/machine learning/ignoring linguistics
22:44:23 <augur> koninkje: broadly chomskyan topics. the things i mentioned earlier are what i study -- derivationality, inclusiveness, transderivationality
22:44:31 * koninkje nods
22:44:45 <augur> im trying to bring actual computational/plt ideas to bear on the topic
22:44:51 <koninkje> Any languages in particular, or the standard Chomskyan bias for English?
22:45:03 <augur> and im increasingly of the thought that we shouldnt be thinking of complexity hierarchies
22:45:09 <augur> what chomskyan bias for english
22:45:15 <augur> do you read the chomskyan literature? :P
22:45:19 <koninkje> yes
22:45:24 <koninkje> :P
22:45:34 <augur> its a bias for english /and japanese/
22:45:35 <augur> come on man
22:45:36 <hpaste> lemonade pasted “tmp” at http://hpaste.org/48455
22:45:42 <augur> if it works for english and japanese its obviously universal
22:45:47 <koninkje> it doesn't work very well for languages with free order, so far as I've seen
22:46:00 <augur> you're looking in the wrong places
22:46:06 <augur> lots of work has been done on that
22:46:16 <augur> and much of it shows that "free" isnt
22:46:22 <koninkje> I know lots of work has been done, but what I've seen I find unsatisfactory
22:46:40 <Eduard_Munteanu> Just to be clear (possibly a stupid question), this stuff applies to natural languages too?
22:46:46 <augur> Eduard_Munteanu: which stuff
22:46:50 <koninkje> well, yes, "free" isn't; but that's the name we've inherited
22:46:51 <Eduard_Munteanu> augur: the stuff you do
22:46:58 <augur> Eduard_Munteanu: its /just/ natural language
22:47:07 <Eduard_Munteanu> Hm.
22:47:25 <lemonade> hm i didn't want this spam :), however: http://hpaste.org/48455 here seems to be the problem the makeMinMaxDecision' is called with parameter 2 and it goes stack overflow on the line with trace. Can you tell me any advice where might be the problem ?
22:47:56 <augur> koninkje: i would suggest you read some more recent stuff. theres been a lot of work on scrambling in the last 10 or 20 years, especially thanks to the massive number of japanese syntacticians
22:48:34 <augur> its almost a running joke that if you meet a japanese syntactician and ask their specialty, the answer will be scrambling
22:48:45 <dolio> lemonade: Nothing in that code requires the evaluation of mv_tmp
22:49:11 <dolio> lemonade: So the trace never needs to be evaluated.
22:49:37 <dolio> Unless something else is evaluating the contents of the mvar.
22:50:14 <lemonade> dolio: well, this code uses separate thread and in mvar should be the result of this thread
22:50:25 <lemonade> and the mvar is indeed needed
22:50:34 <koninkje> augur: I've read some of it, but as I said... I'm not a chomskyan :P
22:51:16 <Eduard_Munteanu> So it's tough to agree with Chomsky even on technical rather than political stuff? :)
22:51:19 <koninkje> (so it hasn't been very satisfying what I've seen)
22:51:34 <dolio> lemonade: Also, your code is kind of wrapping and unwrapping things needlessly.
22:51:54 <koninkje> Eduard_Munteanu: there are broadly two schools of linguistics: Chomsky, and everyone else
22:51:54 <dolio> move = Just mv_tmp, and then you use isJust on it, which is True, and fromJust, which is mv_tmp.
22:52:19 <augur> koninkje: well, you have to read it for real
22:52:20 <koninkje> Eduard_Munteanu: except of course that Chomsky is no longer the leading person in that school, and there is crossover
22:52:27 <Eduard_Munteanu> Oh, heh.
22:52:28 <dolio> So that one line reduces to 'when True $ swapMVar mvar mv_tmp'
22:52:33 <lemonade> dolio: in fact, i don't understand the monads that are around, my code is inspired by this code http://jaspervdj.be/posts/2010-03-01-my-tron-bot.html
22:52:36 <augur> Eduard_Munteanu: there are two notions of chomskyan at play too
22:52:43 <augur> Eduard_Munteanu: theres chomskyan-as-in-what-chomsky-does
22:52:53 <dobblego> when True == id?
22:52:55 <augur> and chomskyan as in UG, formalisms, etc.
22:53:08 <lemonade> dolio: well but that means that mv_tmp is needed and should be evaluated shouldn't it ?
22:53:10 <augur> for instance, CCG, HPSG, etc are chomskyan in the latter sense
22:53:14 <augur> but not in the former sense
22:53:30 <Eduard_Munteanu> Presumably Chomsky did that stuff before.
22:53:34 <augur> the broader chomskyan program of discovering the fundamentals of language qua language
22:53:37 <koninkje> erm, I'm not sure I'd call CCG chomskyan
22:53:41 <augur> vs the narrow chomskyan program of doing it this way
22:53:43 <dolio> lemonade: Why would it be needed? We can just stick the delayed computation in mvar.
22:53:56 <augur> koninkje: sure it is. in the broad sense of studying UG its definitely chomskyan
22:53:58 <dolio> And if anyone ever gets it out and looks at it, then it will be evaluated.
22:54:09 <Eduard_Munteanu> s/did/used to do/
22:54:14 <dolio> But you're overwriting most of the things you stick in there on the way down.
22:54:16 <augur> its rare to find a CCGer who says theres no UG
22:54:21 <lemonade> dolio: yes, but mvar is monad and i thought that it should be forced
22:54:28 <dolio> Nope.
22:54:29 <koninkje> augur: But the CCGists I've talked to don't believe in UG
22:54:35 <augur> really? wow
22:54:39 <augur> you know some odd CCGists
22:55:14 <koninkje> Unless you're taking an *extremely* liberal notion of UG; far more liberal than Chomsky ever did
22:55:28 <augur> for a field that is so stuck into a tight formalism, i find it hard to believe that any of them honestly disbelieves in UG of some sort
22:55:47 <augur> i just mean the notion that there are syntactic principles that are not "anything you want to say can be said"
22:56:11 <dmwit> dobblego: yes
22:56:13 <lemonade> dolio: could you please look at this code? http://jaspervdj.be/posts/2010-03-01-my-tron-bot.html . On the bottom there is almost the same code that i have -- from line >         makeMinMaxDecision' depth = do . This code seems to be evaluated, why ?
22:56:16 <augur> i mean, the hardcore cognitivists think that syntax is effectively unrestricted, and anything "universal" comes from other cognitive aspets
22:56:21 <dmwit> dobblego: At a more restricted type, of course.
22:56:23 <koninkje> Coming from the non-UG camp, I'd say that the difference is the belief about whether the core of language is language-specific, or merely a general part of cognition
22:56:24 <augur> whereas ive never seen a CCGist who says that
22:56:41 <augur> ive never even SEEN a CCGist who would say that
22:56:52 <koninkje> we should meet sometime :)
22:57:01 <augur> i mean, all of these combinators and such are pure syntax
22:57:24 <augur> S_{<,x}? that aint general cognition
22:57:32 <koninkje> Exactly, there's nothing about natural language in there. It's just the same sort of stuff that comes out of mathematics, graphs,...
22:57:43 <augur> oh sure but thats not the point
22:57:49 <iwtu_> how can I use the operator? (|>) :: Seq a -> a -> Seq a
22:57:50 <augur> i mean, everything is some stuff that comes out of math
22:58:03 <koninkje> augur: but that _is_ the point
22:58:05 <augur> brains are just a special algebraic object!
22:58:16 <dmwit> iwtu_: Use it as you would (:), but for appending to the other end.
22:58:26 <augur> yeah but brains dont come equipped with abstract algebra, koninkje
22:58:32 <augur> atleast noone thinks they do
22:58:38 <dmwit> (xs |> x) is a sequence starting like xs and ending with x.
22:58:41 <koninkje> Chomsky has at various points espoused the notion of a natural-language-specific module
22:58:47 <koninkje> I don't believe in such a thing
22:58:55 <koninkje> This thing has traditionally been called UG
22:59:03 <augur> so what does S_{<,x} relate to in the rest of cognition, koninkje
22:59:04 <dolio> lemonade: boardBotMove probably looks at its argument before deciding what to return.
22:59:12 <augur> where are these combinators outside of language?
22:59:38 <iwtu_> dmwit, is also anyother way?
22:59:41 <koninkje> lambda calculus
22:59:50 <augur> koninkje: so the brain implements LC?
22:59:56 <augur> qua LC?
22:59:57 <koninkje> perhaps
22:59:58 <dmwit> iwtu_: Are you asking about syntax?
23:00:06 <dmwit> iwtu_: (I'm not sure I understand the question.)
23:00:33 <augur> koninkje: and S_{<,x} is a _primitive_ in this version of LC?
23:00:40 <iwtu_> dmwit, yes. about syntax
23:00:54 <augur> cause i mean, the point of steedmans work is that you dont get all of LC
23:00:55 <koninkje> I'm not shure what you're meaning by S_{<,x}
23:01:01 <lemonade> hmmm thats bad
23:01:01 <augur> you get this ontology of combinators
23:01:09 <augur> S_{<,x} -- left cross composition
23:01:17 <Eduard_Munteanu> iwtu_: you can't pattern-match using (|>) if that's what you might be asking
23:01:18 <koninkje> ah
23:01:19 <augur> or was that left cross application
23:01:22 <lemonade> dolio: thank you very much i'm going to fix it somehow :)
23:01:36 <Eduard_Munteanu> iwtu_: you can use viewl / viewr for that though.
23:01:43 <augur> i mean, natural language aint TC, koninkje
23:01:44 <dmwit> iwtu_: Yes, there are other ways. All the usual section syntax is possible. All of the following are equivalent: "xs |> x", "(xs |>) x", "(|> x) xs", "(|>) xs x"
23:01:46 <Eduard_Munteanu> :t viewl
23:01:46 <lambdabot> Not in scope: `viewl'
23:01:54 <Eduard_Munteanu> @hoogle viewl
23:01:55 <lambdabot> Data.Sequence viewl :: Seq a -> ViewL a
23:01:55 <lambdabot> Data.Sequence data ViewL a
23:02:03 <Eduard_Munteanu> @src ViewL
23:02:03 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
23:02:09 <dolio> lemonade: If you want to make sure that pattern match is evaluated, you should use a case statement to do it.
23:02:12 <dmwit> ViewL ~= Maybe (a, Seq a)
23:02:18 <augur> so theres some restriction of the LC thats at work in natural language
23:02:35 <koninkje> augur: I think a big part of the problem is that syntactic theories have generally not considered the role of semantics seriously
23:02:44 <lemonade> dolio: how ?
23:02:54 <augur> certainly possible, but i dont see how that relates to the point
23:03:06 <iwtu_> dmwit, can I use it as a function?
23:03:09 <koninkje> Who's to say that the meaning of utterances isn't TC? I've yet to see evidence
23:03:17 <dmwit> iwtu_: Yes, it is a function.
23:03:23 <augur> koninkje: no not meanings
23:03:24 <augur> syntax
23:03:36 <dolio> lemonade: maxMinMaxDecision' depth = case ... `trace` ... of (_, mv_tmp) -> do ...
23:03:37 <koninkje> The focus on syntactic trees is a diversion from the real goal, which is comprehension (and production) of language
23:03:40 <augur> meanings are whatever they are, chomsky isnt talking about meanings
23:03:46 <augur> no not even trees, dude
23:03:47 <Eduard_Munteanu> iwtu_: it is one, it's not a constructor
23:03:56 <augur> just the syntax abstractly speaking
23:04:20 <augur> take it from a processing perspective if you want, but that doesnt change things
23:04:22 <koninkje> This is part of why I like CCG, it's trying to answer the question of how sentences are parsed into meanings, not into structural multigraphs
23:04:26 <lemonade> dolio: great, i'm going to try it thank you once again :)
23:04:29 <augur> yeah but koninkje
23:04:33 <augur> CCG is not TC
23:04:40 <augur> thats my point
23:05:15 <augur> CCG is not TC, and so if you think the brain more generally is roughly TC, the grammars of natural languages are just general cognitive stuff
23:05:19 <augur> otherwise you'd have TC grammars
23:05:31 <koninkje> I don't agree
23:05:36 <augur> if you use CCG, you're implicitly (or explicitly osmetimes) assuming that grammars are not TC
23:05:40 <augur> because CCG is not TC
23:06:11 <augur> i mean look at programming languages, koninkje
23:06:17 <augur> many of them have very simple grammars
23:06:24 <augur> lisp, for example, is clearly CF
23:06:31 <augur> and not even strongly CF
23:06:35 <augur> but its semantics is TC
23:06:52 <sanjoyd> @kind (->)
23:06:53 <lambdabot> ?? -> ? -> *
23:06:55 <augur> theres a clear distinction between the syntax and semantics of a language
23:06:59 <sanjoyd> What do the ? and the ?? mean?
23:07:10 <koninkje> I never said that the grammars themselves are TC. What I said is that the grammars are but a means to an end, and I've seen no evidence that the end is not TC
23:07:16 <dolio> sanjoyd: ?? includes the # kind.
23:07:23 <augur> koninkje: right but what im saying is that UG is a theory of the grammars themselves
23:07:24 <augur> thats it
23:07:28 <dolio> ? includes the ?? and the (#) kind.
23:07:41 <augur> the whole point of UG is that grammars are not TC
23:07:42 <sanjoyd> Okay, what is the # kind? (I can't google #).
23:07:44 <dolio> # is the kind of unboxed types, (#) is the kind of unboxed tuples.
23:07:52 <sanjoyd> Oh, okay.
23:07:53 <sanjoyd> Thanks.
23:08:00 <augur> noone disagrees that the end result, the semantics or whatever, could be TC
23:08:02 <augur> that would be stupid
23:08:08 <koninkje> augur: and I'd say that the notion of structure captured by grammaticality is more general than just natural language
23:08:10 * sanjoyd /can/ google unboxed types and unboxed tuples.
23:08:12 <augur> the disagrement is over the grammars themselves
23:08:21 <koninkje> in any case, I got to run, the misses is home
23:08:24 <koninkje> ciao
23:08:31 <hpaste> mgsloan pasted “Regex on the left of the equals :)” at http://hpaste.org/48456
23:08:31 <augur> koninkje: maybe, but thats more work you'd have to do
23:08:49 <augur> so far there seem to be oddities that are only grammar related
23:08:55 <augur> bye koninkje_away :|
23:09:20 <mgsloan> check this stuff out! regex quasi quoter + view patterns ftw!
23:09:39 <mgsloan> not the best example, but I hope you can see the possibilities
23:09:46 <Eduard_Munteanu> The idea is you can pass unboxed values into a function, but not return them.
23:09:56 <Eduard_Munteanu> As far as dolio explained to me before :)
23:10:00 <dolio> No.
23:10:05 <augur> Eduard_Munteanu: so are you reading BHG?
23:10:06 <dolio> You can return unboxed tuples, but not pass them.
23:10:40 <dolio> You can both return and accept unboxed types.
23:10:43 <Eduard_Munteanu> dolio: erm, that's the other one, I started talking about #
23:10:48 <Eduard_Munteanu> Oh, right.
23:11:00 <dolio> Int# -> Int# is okay.
23:11:07 <dolio> (# Int, String #) -> String is not.
23:11:08 <Eduard_Munteanu> augur: BHG?
23:11:14 <dolio> As far as GHC is concerned, that is.
23:11:20 <augur> Eduard_Munteanu: the blog post i linked you to! :|
23:11:34 <Eduard_Munteanu> Oh, Brief History of Grammar.
23:11:34 <augur> dolio: whats boxing now
23:11:41 <Eduard_Munteanu> Yeah, I was looking through it. :)
23:11:54 <augur> Eduard_Munteanu: no no battle hstar galactica
23:11:54 <augur> :D
23:11:58 <Eduard_Munteanu> dolio: what was that stuff about regparm you told me?
23:12:03 <Eduard_Munteanu> :))
23:13:04 <Eduard_Munteanu> I remember you said something about how passing unboxed values to function makes sense because you can fit them into register parameters.
23:13:36 <augur> whats boxing!
23:13:45 <Eduard_Munteanu> @src Int
23:13:45 <lambdabot> data Int = I# Int#
23:14:30 <Eduard_Munteanu> augur: whether you have naked values or not. The usual stuff in Haskell is wrapped in a "box".
23:14:40 <dolio> regparm?
23:14:46 <dolio> Oh.
23:14:48 <Eduard_Munteanu> Register parameters.
23:14:58 <augur> Eduard_Munteanu: hmm
23:15:11 <dolio> Eduard_Munteanu: If you want to pass multiple arguments in registers, GHC can figure that out with T -> U -> V.
23:15:21 <dolio> Pass the T and U in registers.
23:15:42 <dolio> But the only way to return multiple things is (T, U), which is heap allocated.
23:15:50 <Eduard_Munteanu> Oh, right.
23:16:00 <augur> im not sure i follow but thats ok :D
23:16:01 <dolio> So (# T, U #) is necessary to pass back multiple results efficiently.
23:16:14 <dolio> But it's not really necessary for passing things in.
23:16:20 <Eduard_Munteanu> augur: http://www.haskell.org/haskellwiki/Unboxed_type
23:17:01 <Eduard_Munteanu> Though we could return at least some unboxed tuples as such, on x86-64.
23:17:14 <Eduard_Munteanu> Say, (# Int, Int #)
23:17:51 <dolio> Eduard_Munteanu: It might have some optimization advantages for GHC, too. I'm not sure.
23:18:19 <dolio> Since you're required to write code like 'case f x of (# y, z #) -> ...' when using unboxed tuples.
23:18:30 <dolio> You can't just write 'g (f x)'.
23:18:38 <augur> weird
23:18:42 <augur> whats the point of boxing?
23:18:44 <augur> and unboxing?
23:18:53 <Eduard_Munteanu> augur: thunks... for the first.
23:19:05 <Jafet> To implement non-strictness.
23:19:09 <augur> hmm
23:19:22 <Jafet> In the STG machine, at least
23:19:30 <augur> but i mean why expose the unboxed values
23:19:42 <Eduard_Munteanu> While unboxed stuff is cheaper if you can work with them. Say, STUArray.
23:20:02 <Eduard_Munteanu> Basically STUArray is much like a C array.
23:20:10 <Jafet> If they're strict anyway, unboxing them is usually faster, and uses less space.
23:20:21 <augur> hm
23:21:20 <iwtu_> dmwit, can you check it, please? http://codepad.org/XPEIRdcT
23:22:06 <Jafet> An Int is a two-word structure containing an I# tag and a thunk or NF value, an Int# is a native machine integer
23:24:30 <iwtu_> or anyone else can check? i can't complile http://codepad.org/XPEIRdcT
23:25:12 <gfarfl> iwtu_: Undefined variable "|>" is because the operator is under Seq. i.e. (Seq.|>)
23:25:19 <dolio> Uniform implementations for polymorphism also requires boxing.
23:25:40 <Eduard_Munteanu> I wonder if it's possible to avoid thunks completely.
23:25:41 <iwtu_> gfarfl, ach
23:26:21 <Eduard_Munteanu> Like using indirect loads and handling uncomputed stuff via a SIGSEGV handler.
23:26:33 <gfarfl> iwtu_: fyi, you can use 2 import calls to import some things unqualified
23:26:35 <Jafet> That sounds way more expensive than thunks
23:27:05 <iwtu_> gfarfl, hm?
23:27:41 <dolio> (Int, Int) needs to look the same as Float, or else you might have to generate two implementations of, say, reverse.
23:27:56 <dolio> One for [Float] -> [Float] and one for [(Int, Int)] -> [(Int, Int)].
23:28:03 <dolio> Which is what C++ does.
23:28:13 <Eduard_Munteanu> Jafet: yeah but currently it's just as expensive to reuse computed values, no?
23:28:21 <gfarfl> iwtu_: import Data.Sequence ((|>),(<|)); import qualified Data.Sequence as S
23:28:27 <iwtu_> http://codepad.org/OVpOjQBz how deal with `c' ?
23:28:42 <Jafet> From what I know, each SEGV represents one MMU interrupt
23:28:58 <wli> A bit more than that.
23:29:07 <Jafet> You'll win a ridiculous haskell implementation award, but probably not performance
23:29:13 <lemonade> dolio: :(. I'm not able to make the case statement you told me. How exactly should it look like. I have         makeMinMaxDecision' depth = case (show "kuk") `trace` (_, mv_tmp) of (_, mv_tmp) -> do but it doesn't work...
23:29:35 <iwtu_> logic is not enough. I always have to fight with syntax
23:29:44 <accel> quit
23:29:52 <azaq23> iwtu_: a Guard is something like an "if", not a pattern match. You do "... | Just x"; this doesn't pattern match, but construct a Maybe value from x
23:30:00 <Eduard_Munteanu> Heh, yeah, unfortunately SIGSEGVs aren't fast.
23:30:35 <Eduard_Munteanu> Backpatching code might be better though.
23:30:36 <ivanm> when profiling, what determines which functions are listed up the top of the profiling report?
23:30:36 <Jafet> Reusing a computed value is basically just following a pointer
23:30:44 <wli> MMU interrupts happen quite routinely; SIGSEGV is a special sort of operating task switch (with some provisos, killing the process without a task switch without some special setup ahead of time) that occurs only when the kernel can't automatically handle the MMU interrupt.
23:30:54 <azaq23> > let f (Just c) = show c; f Nothing = "Nothing" in (f (Just 10), f Nothing)
23:30:55 <lambdabot>   ("10","Nothing")
23:31:04 <dolio> lemonade: The thing that should go between the 'case' and the 'of' is the stuff on the right hand side of the = in your original code.
23:31:26 <ivanm> > let f = maybe "Nothing" show in (f (Just 10), f Nothing)
23:31:27 <lambdabot>   ("10","Nothing")
23:31:28 <ivanm> azaq23: ^^
23:31:44 <Jafet> Yeah, but Eduard_Munteanu's plan involves using the interrupts to do non-strict computation
23:31:59 <Eduard_Munteanu> Nah, it was just an idea I threw out.
23:32:01 <dolio> let p = e in ...  ==> case e of p -> ...
23:32:07 <Eduard_Munteanu> It's not really a plan :)
23:32:56 <iwtu_> azaq23, so how can I get the value/
23:33:02 <iwtu_> ?
23:33:13 <dolio> lemonade: I have to get some sleep now.
23:33:28 <Eduard_Munteanu> We use a similar approach in a JIT compiler, but only for lazily compiling methods.
23:33:30 <lemonade> dolio: ok, thank you very much again i try to do something with it
23:33:42 <lemonade> however i don't have "in" in the let statement
23:34:10 <lemonade> so can i leave the ... blank ?
23:34:20 <dolio> lemonade: I know. But 'do { let p = e ; ... }' is the same as 'let p = e in do ...'
23:34:23 <Eduard_Munteanu> (erm, Java JIT compiler)
23:34:32 <lemonade> ah
23:34:55 * wli would generally regard that as a method of interpretation.
23:35:30 <Jafet> Besides, POSIX doesn't let you return from a SEGV.
23:35:50 <wli> Jafet: Um, it does.
23:36:22 <Eduard_Munteanu> (Erm, not methods other stuff, for methods it's just trampolines)
23:36:42 <Jafet> A real SEGV, that is
23:36:44 <Eduard_Munteanu> But yeah, we basically do some expensive work then backpatch code so next time it's cheaper.
23:36:54 <azaq23> iwtu_: Map.lookup x (Seq.index i) will return a maybe value. You'll have to pattern match on it (or use, like ivanm suggested, the maybe function). Try to write it as "case Map.lookup x (Seq.index i) of { Nothing -> ...; Just c -> ...; }; this should work, then reread your resources chapter on pattern matching syntax and functions guards again
23:37:23 <wli> Jafet: It's even routine when GC methods deliberately trigger SIGSEGV to trap read or write accesses.
23:37:31 <Eduard_Munteanu> However in something like Haskell one would expect new computations to be just as cheap or so.
23:37:57 <Jafet> Hmm
23:38:10 <Jafet> “According to POSIX, the behavior of a process is undefined after it ignores a SIGFPE, SIGILL, or SIGSEGV signal that was not generated by kill(2) or raise(3).”
23:38:26 <iwtu_> azaq23, I will have to. I though that -> was just for types and lamba funcion
23:38:34 <Eduard_Munteanu> Jafet: *ignores*
23:38:54 <drbean> augur, koninkje_away:
23:39:07 <drbean> What was TC? Typed calculus?
23:39:11 <augur> drbean: turing complete
23:39:40 <wli> Jafet: Well, half the universe is riding on undefined behavior.
23:39:47 <Eduard_Munteanu> Jafet: we can recover successfully if we decide it's one of those expected SIGSEGVs.
23:39:47 <augur> me -> sleep
23:40:12 <Jafet> Sure; for any behaviour you can find a standard in which it's undefined
23:40:21 <Eduard_Munteanu> (class fields IIRC, not methods, now that I remember)
23:41:14 <azaq23> iwtu_: Well, -> is just syntax. In type declarations it denotes the function type, for lambdas it marks the beginning of the functions body, in case ... of statements it denotes each case; there's also something called view pattern in which -> is also used.
23:41:33 <azaq23> iwtu_: -> is only part of the case ... of syntax, it's not intrinsically related to pattern matching
23:42:41 * Eduard_Munteanu remembers some Haskell compiler didn't do thunks
23:44:22 <syntaxfree> I always thought lazy evaluation was achieved with thunks.
23:44:28 <syntaxfree> and rewarded with thanks.
23:48:52 <syntaxfree> I get pinged every time someone says "syntax".
23:50:15 <Jafet> Be glad you're not applicative
23:57:05 <ivanm> syntaxfree: which IRC client?
