00:00:19 <blackdog> ivanm: have you seen axman6 around?
00:00:32 <blackdog> i want to see if i can taunt him into optimising some of my code
00:00:47 <ivanm> I think he was around this morning
00:00:53 <ivanm> but he probably has SES training on tonight
00:01:06 <ivanm> so you're probably out of luck ;-)
00:01:22 * blackdog considers obligatory "escape from canberra" joke and discards it as unworthy of anything but a meta-joke.
00:01:27 <develhevel> ivanm: big thx for the function, this was what i'm looking for :)
00:01:47 <ivanm> np
00:02:42 <ivanm> rothwell: isn't your solution just a re-implementation of maybeToList . reads ?
00:02:48 <ivanm> I mean listToMaybe
00:02:59 <rothwell> could be
00:03:11 <ivanm> > listToMaybe . reads $ "12353a" :: Maybe (Int, String)
00:03:12 <rothwell> i only mentioned it because i happened to write it two days ago, and he asked...
00:03:13 <lambdabot>   Just (12353,"a")
00:03:19 <ivanm> rothwell: ^^
00:03:46 <rothwell> i'm sure there are a ton of ways to write it
00:08:49 <frerich2> ivanm: Hmm, your little isInt function got me thinking - is 'liftM2' the trick here to write it point-free? I'm just a beginner but I recently wrote a similiar function and it's "isInt s = (&&) (not . null $ s) (all isDigit s)". I didn't think it would be possible to 'extract' the 's' out of there.
00:09:13 <frerich2> I tried, but I failed. I didn't think of "liftM2" though (the whole "lifting" business is still a bit obscure to me)
00:11:31 <Jafet> Incredibly, sid broke my /usr/local ghc
00:11:39 <Jafet> /usr/bin/ld: cannot find crt1.o: No such file or directory
00:13:40 <acowley> frerich2: use applicative notation and it's even nicer! (&&) <$> not . null <*> all isDigit
00:14:05 <acowley> frerich2: and, yes, that is the reader monad ((->) a)
00:14:08 <Jafet> Applicative is the correct instance here
00:14:29 <Jafet> The Monad one doesn't generalize well
00:15:18 <acowley> An important functor to ponder is ((->) a), the applicative instance is straightforward
00:17:29 <Jafet> Then again, you don't need any instances: flip all [not.null, all isDigit] . flip ($)
00:20:13 <acowley> arrows are another option: uncurry (&&) . (not . null &&& all isDigit)
00:20:57 <Jafet> Sometimes I feel like the only reason I use Arrow is because tuples suck
00:21:26 <shachaf> Arrow is pretty much Control.TupleExtras
00:32:11 <ivanm> acowley: I don't think the Applicative version is nicer...
00:32:23 <ivanm> the monadic one emphasises the "joining" nature of it more IMHO
00:34:04 <acowley> But there is no joining. If one of the arms was a -> m b, then you'd need join. Instead we just have a computational context with no flattening required.
00:35:57 <acowley> Admittedly, this is a bike shed. Some folks think <$> is too ugly to use, so that could be a factor, too.
00:36:59 <Jafet> Call it .
00:39:22 <ivanm> acowley: my point is more that it isn't as obvious to me that the && is being applied on both sides of the <*>
00:39:41 <frerich2> Oh well you guys are going way above my head. Remember, I still tip-toe about the idea of "lifting" things and you throw applicative and arrows and whatever at me :-}
00:39:49 <ivanm> whereas liftM2 has connotations of "lifting" both of them into the &&
00:40:09 <ivanm> admittedly, I've enver really used Applicative in anger
00:40:28 <acowley> Yeah, I like to read "f <$> a <*> b" as "f a b" which I know how to read because it's just function application.
00:41:30 <Jafet> Just remember that the type of (&&) is actually Bool -> (Bool -> Bool)
00:41:58 <acowley> frerich2: I always advise people to focus on Functor and Monoid until you're pretty sure there are no more secrets there. At that point, Applicative and even Monad are small steps, even though you discover there really were more secrets! :)
00:42:11 <Jafet> If I installed ghc using a particular gcc, can I make it use a different gcc?
00:42:21 <Jafet> It seems that sid mangled /usr/local/bin/gcc
00:42:51 <ivanm> Jafet: edit /usr/bin/ghc (it should just be a script)
00:42:56 <ivanm> and remove the line specifying gcc
00:43:05 * ivanm hates that particular "feature"
00:43:21 <Jafet> Oh, so it is
00:43:26 <Jafet> *Remove*?
00:43:56 <ivanm> sure, remove it and the reference to it in the exec line
00:44:06 <ivanm> we do that when building GHC on gentoo
00:44:09 <ivanm> because otherwise it stuffs up
00:44:23 <ivanm> (especially when using something like distcc)
00:44:42 <ivanm> I mean, you _could_ just point it to your new gcc
00:44:55 <ivanm> but if it's still just gcc, then there should be no need
00:45:11 <ivanm> IIRC, that's there more so that if you built ghc with a different C compiler it should keep using that C compiler
00:45:20 <ivanm> well, that particular flavour of C compiler
00:45:32 <Jafet> Oh, so it's optional.
00:45:42 <ivanm> yup
00:48:00 <Jafet> Indeed. Thank you
00:48:33 <ivanm> Jafet: ahhh, apparently it's because it used different options with older versions of gcc
00:48:57 <ivanm> but if you use gcc >= 4 (and ghc was built with >= 4) then there's no problem
00:51:08 <ivanm> OK, I think I've shot myself in the foot... I've specified that Dot graphs can be directed or undirected, and this is configurable via a class method
00:51:29 <ivanm> but now I'm wanting to write a new representation that actually has graph-like functions for it
00:51:40 <ivanm> so how do I deal with it potentially being undirected? :/
00:54:33 <Jafet> What kind of functions wouldn't make sense at all for undirected graphs?
00:54:53 <ivanm> Jafet: no, it's how to deal with it
00:55:13 <ivanm> I'm guessing I'll just have to make all such functions "smarter"
00:55:18 <Jafet> To detect directedness of graphs?
00:55:26 <ivanm> yeah, and adjust accordingly
00:55:51 <ivanm> e.g. you add an edge "a -> b"; if the graph then becomes undirected then you have to return "a" as a successor edge to "b"
00:55:51 <luite> Jafet: topological sort :p
00:56:46 <Jafet> Oh, so the class method is a toggle switch for all edges.
00:56:54 <ivanm> yup
00:57:09 <ivanm> Jafet: "directedness" isn't stored in the edges; it's stored for the _graph_
00:57:19 <Jafet> Maybe index edges both ways, with the corresponding space costs
00:58:11 <develhevel> who can explain me functors for dummys?
00:58:14 <ivanm> well, I was already going to store both predecessor and successor edges
00:58:16 <develhevel> dummies
00:58:22 <ivanm> develhevel: you know the map function for lists?
00:58:44 <develhevel> yes
00:58:59 <ivanm> so all Functor is is extending that idea to other data structures
00:59:26 <ivanm> so for any parametrised type (Maybe a, Seq a, etc.) you can now do a "map" function on them
00:59:38 <ivanm> it only changes the values, not the internal structure
00:59:42 <ivanm> > fmap (Just 3)
00:59:44 <lambdabot>   Couldn't match expected type `a -> b'
00:59:44 <lambdabot>         against inferred type `Data.M...
00:59:49 <ivanm> > fmap show (Just 3)
00:59:50 <lambdabot>   Just "3"
00:59:53 <ivanm> > fmap show Nothing
00:59:54 <lambdabot>   Nothing
01:00:07 <ivanm> develhevel: that is, fmap id x == x
01:00:09 <Jafet> And singleton!
01:00:27 <ivanm> Jafet: hmmm?
01:00:38 <Jafet> Wait, wrong class
01:00:40 <develhevel> ah okay :) so easy to understand, so its only like map but for all kind of types not only lists
01:00:41 <Jafet> Sorry
01:00:47 <ivanm> develhevel: right
01:00:58 <ivanm> develhevel: it doesn't work for Set though, as Set has a constraint on the values it can take
01:01:05 <ivanm> Functor doesn't allow you to have constraints though
01:01:22 <ivanm> there is an RFunctor class in heffalump's rmonad package though if you need such functionality
01:02:16 <ivanm> Jafet: is that what you meant by "index edges both ways" ? Store both successor and predecessor edges for each node?
01:02:41 <Jafet> Yeah; if you're already doing that and still have a problem, then I failed to understand it
01:03:11 <ivanm> nah, I didn't think of having smarter functions until just now
01:03:43 <ivanm> I was originally trying to work out how to do some crazy storage scheme of "just in case it's an _undirected_ graph..."
01:04:50 <ivanm> (i.e. rather than storing each edge twice, store it 4 times with tags indicating if it's the "real" edge of the inverse of a real edge)
01:05:36 <Jafet> If you don't want to clutter your functions, you could try doing some OOP
01:05:52 <ivanm> huh?
01:05:56 <Jafet> Store some basic accessor functions with the graph
01:06:08 <Jafet> Then makeDirected and makeUndirected replaces those functions
01:06:21 <ivanm> nah, don't think so
01:28:09 <develhevel> is there any difference, i have a function foo a -> Bool and now i can make: "if not . foo a ..." and "if not $ foo a ..."
01:28:23 * hackagebot criterion-to-html 0.0.0.1 - Convert criterion output to HTML reports  http://hackage.haskell.org/package/criterion-to-html-0.0.0.1 (JasperVanDerJeugt)
01:28:54 <ivanm> develhevel: the former won't typecheck
01:29:02 <sipa> develhevel: (not . foo a) == (\x -> (not (foo a x)))
01:29:12 <ivanm> > (succ . (*2)) 3
01:29:14 <lambdabot>   7
01:29:22 <ivanm> > succ . (*2) $ 3
01:29:24 <ivanm> develhevel: ^^
01:29:24 <lambdabot>   7
01:29:55 <Jafet> > (+1) (*2) 3
01:29:56 <lambdabot>   7
01:30:22 <ivanm> Jafet: is that using the function monad or something?
01:30:27 <shachaf> > (+) (*2) (+3) 4
01:30:28 <lambdabot>   15
01:30:48 <shachaf> ivanm: It's using functions, which are an instance of monads.
01:31:05 <Jafet> @instances Num
01:31:05 <lambdabot> Double, Float, Int, Integer
01:31:11 <Jafet> Lies
01:31:14 <ivanm> OK, is that using the monad instance for functions then?
01:31:31 <shachaf> @instances-importing L Num
01:31:32 <lambdabot> Double, Float, Int, Integer
01:31:34 <ivanm> how else does yours work then, where (+) is taking in two functions and returning a function?
01:31:34 <shachaf> Pah.
01:31:42 <ivanm> or is this a Caleskell-ism? :p
01:31:48 <shachaf> ivanm: Where are there any Monad-related functions used there?
01:31:59 <Jafet> This is the most popular misfeature of lambdabot that's misattributed to Cale
01:32:05 <Jafet> @hackage vector-space
01:32:05 <lambdabot> http://hackage.haskell.org/package/vector-space
01:32:11 <shachaf> > 1 1
01:32:12 <lambdabot>   1
01:32:21 <Jafet> Num instance for functions
01:32:27 <ivanm> Jafet: eh, I just call all of lambdabot's variant of Haskell "Caleskell" whether it's Cale's fault or not :p
01:32:44 <ivanm> > 1 2
01:32:45 <lambdabot>   1
01:33:21 <Jafet> > 1.0 2.0
01:33:21 <lambdabot>   1.0
01:33:29 <bmm> Hi everybody. I'm completely new to Haskell and have decided to take on a HelloWorld kind of app called tweetcloud. I would like some hints on how to collect #hash strings when I have a Network.Curl callback function.
01:33:54 <balon> hi to all :D
01:33:59 * bmm has source on https://github.com/bneijt/tweetcloud
01:39:08 <Jafet> If you don't give a more direct elaboration, few people would bother to look up your code and the Curl documentation
01:39:36 <Jafet> They probably want you to use an IORef for that
01:39:47 <ivanm> there are already some twitter libraries/implementations available as well
01:40:21 <bmm> I've looked at the twitter libraries, and the streaming IO library uses an Iteratee
01:40:50 <bmm> Which I found two confusing, so I copied the Curl part of the code. Now I have a curl callback function and need to do some buffering to get words out of it.
01:41:17 * bmm finds out hpaste.org is down?
01:41:26 <Jafet> collectHashesTo :: IORef (Seq String) -> String -> IO ()
01:41:53 <isomorphic> Does anybody have a good example of the 'optional' parsec combinator?
01:41:59 <luite> bmm: chrisdone rewrote hpaste with snap and now it's down
01:42:09 <bmm> Jafet: ok... I'm not sure what an IORef is so, I'll look that up.
01:42:32 <ivanm> @hoogle optional
01:42:33 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
01:42:33 <lambdabot> Text.Parsec.Combinator optional :: Stream s m t => ParsecT s u m a -> ParsecT s u m ()
01:42:33 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
01:42:43 <ivanm> isomorphic: I've used the polyparse variant
01:42:55 <o-_-o> byorgey: What are the differences between SVG and diagrams ?
01:42:57 <ivanm> that does the same thing
01:43:45 <isomorphic> ivanm: Hrm.  I guess I'm wondering how that return type gets combined (or whether it's appropriate to combine it) across the <|> operator
01:44:00 <isomorphic> essentially, I just want to throw away junk from my input stream
01:46:34 <ivanm> isomorphic: no idea about <|>
01:47:21 <ivanm> isomorphic: but AFAIK, it'd be implemented something like: try (liftM Just p) <|> return Nothing
01:53:23 <isomorphic> ivanm: sorry, I don't quite follow - what would be implemented as try (liftM Just p) <|> return Nothing ?
01:53:37 <ivanm> isomorphic: that is my guess as to how optional is implemented
01:53:45 <isomorphic> Ah - thanks :)
01:54:02 <ivanm> @type (<|>)
01:54:03 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
01:54:22 <ivanm> isomorphic: if you want to use optional on one side of <|>, the other side has to return a Maybe a as well
01:54:50 <isomorphic> Ah - so I can prefix the other side with a 'Just'?
01:55:11 <isomorphic> or perhaps pattern match out the maybe?
01:55:14 <isomorphic> they're my options?
01:57:01 <ivanm> well, you'll have to fmap or liftM Just
01:57:31 <isomorphic> oh - to get it into the parser monad?
01:58:15 <ivanm> yup
01:58:24 <isomorphic> cool thanks :)
02:02:49 <isomorphic> @type optional
02:02:50 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f (Maybe a)
02:03:12 <isomorphic> @src optional
02:03:13 <lambdabot> optional v = Just <$> v <|> pure Nothing
02:03:45 <isomorphic> Hrmm.. I'm not sure this is the same optional - is there a way to make mueval print the module name?
02:04:50 <ivanm> @index optional
02:04:51 <lambdabot> Text.ParserCombinators.Parsec.Combinator, Text.ParserCombinators.Parsec, Text.ParserCombinators.ReadP, Distribution.Compat.ReadP
02:04:56 <ivanm> isomorphic: it is
02:05:06 <ivanm> <$> = fmap = liftM; pure = return
02:05:16 <ivanm> well, they're equivalent anyway
02:05:20 <ivanm> @src (<$>)
02:05:20 <lambdabot> f <$> a = fmap f a
02:05:41 <isomorphic> Prelude Text.ParserCombinators.Parsec Data.Maybe> :t optional
02:05:41 <isomorphic> optional
02:05:42 <isomorphic>   :: Text.Parsec.Prim.Stream s m t =>
02:05:42 <isomorphic>      Text.Parsec.Prim.ParsecT s u m a
02:05:42 <isomorphic>      -> Text.Parsec.Prim.ParsecT s u m ()
02:06:25 <ivanm> isomorphic: parsec-3 is a lot more polymorphic than parsec-2 was
02:06:39 <ivanm> but yeah, that appears to do something else...
02:06:44 <isomorphic> ah okay
02:06:56 <isomorphic> well, I guess my issue is with this last part of the return
02:06:59 <isomorphic> the ()
02:07:11 <ivanm> yeah, looks like it tries to consume without returning anything...
02:07:13 <ivanm> *shrug*
02:07:20 <ivanm> I've never used parsec, so can't really help you ;-)
02:07:20 <isomorphic> Yup - that's the aim
02:07:28 <isomorphic> Okay, thanks though! :)
02:07:46 <isomorphic> still very helpful!
02:09:33 <isomorphic> Is there something I can lift into a monad containing () to make it a string?
02:09:48 <isomorphic> > show ()
02:09:49 <lambdabot>   "()"
02:10:00 <isomorphic> @type show ()
02:10:01 <lambdabot> String
02:10:11 <isomorphic> ... hrmm..
02:10:13 <erus`> @type show
02:10:13 <lambdabot> forall a. (Show a) => a -> String
02:20:28 <Jafet> Any function on () is const x
02:20:33 <Jafet> Except the non-functions
02:22:07 <shachaf> Jafet: What do you mean?
02:22:34 <shachaf> > map id [(),undefined]
02:22:36 <lambdabot>   [(),*Exception: Prelude.undefined
02:25:56 <quicksilver> shachaf: 'id' is 'const ()', on (0
02:25:59 <quicksilver> on ().
02:26:09 <quicksilver> shachaf: all total functions on () are "const something".
02:26:29 <shachaf> Total?
02:26:50 <shachaf> Who brought totality into it?
02:27:17 <osfameron> what is the RWH commenting feature powered by?
02:27:21 <osfameron> and is it opensource?
02:27:26 <afy> does anyone know where i can find some decent documentation for tagsoup? I can only find snippets of code
02:29:00 <quicksilver> shachaf: total is what Jafet meant by 'functions' ... 'except the non-functions'
02:29:06 <quicksilver> shachaf: a partial function is, in fact, not a function.
02:29:09 <ivanm> osfameron: I think snoyman is working on something similar
02:29:15 <ivanm> but I can't recall what RWH's version is called
02:29:16 <shachaf> quicksilver: Pft. I thought this was #haskell.
02:29:20 <ivanm> preflex: seen dons
02:29:20 <preflex>  dons was last seen on #ghc 10 hours, 15 minutes and 43 seconds ago, saying: dcoutts: well done on graduating
02:29:32 <ivanm> shachaf: you mean this _isnt'_ #haskell ? :o
02:29:53 <osfameron> ivanm: yeah, the rwh site doesn't mention "comments powered by" prominently on the book site footers, so I'm guessing it was an internal tool that's not packaged up for release
02:30:04 <Jafet> Welcome to #haskell, the channel about #haskell
02:30:05 * osfameron skims their blog looking for a meta-post about it
02:30:44 <osfameron> aha, http://www.realworldhaskell.org/blog/2008/02/10/about-our-comment-system/
02:31:15 <osfameron> ok, so DocBook + Django
02:31:31 * osfameron is using PseudoPod (though it does compile to DocBook, hmmmm)
02:34:54 <zygoloid> Welcome to $ fix ("the channel about " ++)
02:38:50 <isomorphic> Jafet: Do you mean that I can pattern match as in case myFunction of ; const x -> Nothing ; result y -> Just y ?
02:40:53 <isomorphic> ie:  Having a Something () matches const x ?
02:41:43 <Jafet> Any function of type () -> a can only be equivalent to const x, where x :: a
02:42:20 <Jafet> Your code isn't legal anyway... you can't deconstruct functions, and you can only pattern match with constructors
02:43:18 <isomorphic> :/
02:45:58 <Cale> ivanm: The problem is that it's not a variant of Haskell at all :P
02:46:31 <ivanm> Cale: well, I was being generous ;-)
02:46:53 <Cale> fine :)
02:48:34 <Jafet> Platonic variants
02:50:57 <isomorphic> alright - I have a function that's going to return a GenParser Char st String - as in, it's a parsec thing - should I expect to be able to pattern match the thing returned?
02:51:50 <isomorphic> http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/Text-Parsec-Prim.html#t:Parsec
02:54:11 <bmm> I'm almost somewhere with my code, but now I want something like "words" but which allows you to define multiple seperation characters (space and ")
02:54:29 * bmm tried hoogle Char -> String -> [String] but did not find anything
02:55:00 <mauke> look at Data.List.Split
02:55:10 <isomorphic> @i GenParser
02:55:10 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
02:55:36 <bmm> mauke: thanks!
02:55:39 <ivanm> isomorphic: as in you want to match the result mid-parse?
02:55:56 <ivanm> you can with a helper function of using a case statement inside the parsing do-block
02:56:14 <isomorphic> Ah - that seems like a good plan
02:56:19 <isomorphic> I'll have a look
02:56:42 <isomorphic> ah - turns out I'm back to my old problem
02:56:43 <ivanm> isomorphic: if you haven't coded much with parsec yet: polyparse is a _much_ simpler parsing model
02:57:16 <isomorphic> ivanm: I think I've got my head around parsec's operation - it's more than language that's messing with me ;)
02:58:21 <isomorphic> I've taken your comments re the Maybe and decided to make a :: GenParser Char st (Maybe String)
02:58:47 <isomorphic> inside it, there's a :: GenParser Char st () and a :: GenParser Char st String
02:59:11 <isomorphic> I'm just trying to sneak some combination past ghc ;)
03:04:37 <isomorphic> hpaste seems to be up
03:07:32 <bmm> isomorphic: not at my end
03:07:46 <isomorphic> :(
03:09:25 <bmm> I have two working main implementations: one will spray messages on a websocket (in an infinite loop), the other will read an HTTP stream and collect "#hash" words. Now I need to connect the two and I have no idea how to do that, any pointers are very welcome
03:09:56 <isomorphic> bmm: DNS cache?  Looks to be working for me
03:10:41 <bmm> did hpaste switch hosts? hpaste.org has address 109.74.197.248
03:11:29 <isomorphic> http://hpaste.org/47612
03:11:50 <isomorphic> bmm: I have the same host
03:11:51 <bmm> isomorphic: works :)
03:12:05 <bmm> Ah, just need a redirect to /new ;)
03:13:23 <ivanm> what's better behaviour when trying to add a node into a graph that already exists there?
03:13:41 <ivanm> to just return the original graph, to replace the original value with the new one or to throw an error?
03:13:55 <Jafet> insertWith
03:14:51 <ivanm> Jafet: I don't think that'll work; because when you try to do that you typically want them to be completely separate
03:15:11 <Jafet> I want what to be separate?
03:15:14 <bmm> My first paste: http://hpaste.org/47613 Question: two working main implementations that do IO, how can I connect them?
03:15:26 <ivanm> Jafet: the two nodes
03:15:48 <ivanm> especially since in this graph you also need to specify which cluster to put that node in
03:16:01 * bmm off to lunch, but back within the hour
03:16:20 <Jafet> Which two nodes?
03:16:26 <Jafet> :t S.insertWith
03:16:26 <lambdabot> Couldn't find qualified module.
03:16:31 <Jafet> :t Data.Set.insertWith
03:16:32 <lambdabot> Not in scope: `Data.Set.insertWith'
03:16:42 <ivanm> Jafet: was your "insertWith" statement meant to be at me?
03:16:46 <ivanm> because I thought it was...
03:16:54 <ivanm> @type M.insertWith
03:16:55 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
03:17:05 <Jafet> Strange, why wouldn't it be in Set...
03:17:51 <ior3k> sorry to interrupt...
03:18:05 <ior3k> let's say there's a "data Shape = Circle Radius | Rectangle Side Side" declaration in a library I don't control. Now let's say I'd like to add a Polygon [Side] constructor to create a new Shape
03:18:05 <ivanm> @hoogle (Ord a) => (a -> a -> a) -> a -> Set a -> Set a
03:18:06 <lambdabot> Data.Set fold :: (a -> b -> b) -> b -> Set a -> b
03:18:07 <lambdabot> Data.Foldable foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
03:18:07 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
03:18:15 <ior3k> would I be able to do that?
03:18:21 <ivanm> ior3k: nope
03:18:49 <blackdog> ior3k: datatypes are designed to be closed
03:18:49 <ivanm> ior3k: your only option is to create a new data structure that uses the existing one as well as any extensions you may wish to add
03:18:55 <ivanm> which isn't really what you want
03:19:03 <blackdog> if you need something to be open, you usually use a typeclass
03:19:23 <blackdog> (hi again, btw - always like to see the rubyists persevering with haskell:)
03:19:28 <Jafet> ivanm, just to be clear, I mean something like insertWith (\oldNode newNode -> ...) node graph, and the function gets called if node is already in graph
03:19:51 <ior3k> blackdog: it's been tough :)
03:19:53 <Jafet> Persevering?
03:20:06 <blackdog> Jafet: it's a real mental shift
03:20:16 <ior3k> what if the original author didn't have the foresight to make Shape a typeclass?
03:20:18 <blackdog> ruby lets you do pretty much anything.
03:20:27 <blackdog> ior3k: you fork his code and improve it;)
03:20:36 <Jafet> Oh, I'm sure that's not true.
03:20:50 <blackdog> i know it seems like a pain, but it's how you get some guarantees about what code actually does.
03:21:15 <blackdog> Jafet: what, that ruby forbids some things?
03:21:18 <ivanm> Jafet: yeah, I don't think it's going to be applicable here: a node also has a cluster that it can be found in and attributes for it
03:21:41 <blackdog> i'm pretty sure you could redefine the basic notion of calling a function while in the middle of one...
03:21:48 <ivanm> whilst the attributes can be merged, I would think that if someone tries to add an existing node to a graph, then there's probably a bug in their code
03:22:01 <dcoutts> blackdog: or you use an OO style of data structure
03:22:38 <dcoutts> (e.g. record of functions for inspecting / taking apart the data)
03:22:48 <Jafet> ivanm: seems like you've answered it for yourself
03:22:51 <ivanm> hey dcoutts
03:22:56 <dcoutts> @yarr!
03:22:56 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
03:23:07 <dcoutts> lambdabot: don't be rude to ivanm
03:23:15 <ivanm> Jafet: right, but what's the best way to handle that? returning the original graph or an error?
03:23:17 <blackdog> dcoutts: yeah, that's true
03:23:20 <ivanm> dcoutts: heh
03:23:38 <dcoutts> ivanm: hia :-)
03:23:39 <blackdog> but those functions would still have to have a consistent type
03:23:57 <Jafet> Returning the original graph would hide the supposed bugs
03:23:58 <blackdog> they couldn't take a polygon now instead of a square
03:24:01 <dcoutts> blackdog: indeed, a fixed interface, but the internals can be anything at all
03:24:22 <isomorphic> So, the paste at http://hpaste.org/47612 - I've tried to take the result of soj and pattern match.  GHC complains about my returning Nothing - but shouldn't this be wrapped back up when returning y?
03:24:48 <Jafet> blackdog: haskell lets you overload statements!
03:25:00 <blackdog> dcoutts: congrats on the viva, btw:)
03:25:15 <dcoutts> blackdog: oh ta :-)
03:26:01 <Jafet> isomorphic: y <- foo; foo is from the monad
03:27:05 <thomastang> \quit
03:27:16 <thomastang> quit
03:27:20 <thomastang> \quit
03:27:31 <blackdog> thomastang: jeez, you don't need to rub it in
03:27:35 <Jafet> Stay here!
03:27:43 <blackdog> but if you must leave, try the other slash
03:27:44 <isomorphic> Jafet: Not quite sure what you mean.  y is from GenParser Char st String?  (which should be the type of soj?)
03:28:04 <Jafet> Your foo isn't from the monad.
03:28:15 <Jafet> let y = foo;
03:29:47 <isomorphic> I think I understand - instead I should say let x = soj; y <- case x of .... ?
03:30:09 <Jafet> No, you don't
03:30:17 <isomorphic> :/
03:30:55 <Jafet> do x <- foo -- foo is monadic, x is not
03:31:59 <isomorphic> Isn't that okay?  I'd like to pattern match on x - so I need it not to be monadic
03:32:10 <isomorphic> and soj is monadic
03:32:33 <Jafet> Then how do you explain y <- (bar :: Maybe a)
03:32:50 <Jafet> bar isn't monadic.
03:33:38 <Jafet> (Do you know which monad is being used?)
03:34:00 <isomorphic> I think two monads are in use: Maybe and GenParser
03:34:00 * frerich2 reads "soj" and thinks he wasted too much time on Diablo.
03:34:40 <Jafet> Nope, Maybe isn't a monad there
03:35:07 <isomorphic> Jafet: Oh - okay
03:35:43 <Jafet> And even if you were using it as a monad, it isn't the one that's the subject of the do-syntax block.
03:36:05 <Jafet> (s/monad/Monad/g)
03:36:05 <isomorphic> Jafet: That bit makes sense
03:36:15 <Cale> Jafet: ... oh, okay.
03:37:01 <Cale> y <- bar :: Maybe a  is perfectly acceptable in a do-block in the Maybe monad
03:38:25 <isomorphic> So, if i'm understanding correctly, i can't use a case statement inside a do-block for a GenParser to insert a Maybe type into the GenParser monad?
03:39:19 <isomorphic> ... because the case statement must evaluate to something that's not monadic?
03:39:31 <ior3k> ok, sorry about the basic questions, but given data's limitations, does it make sense to export those kinds of types at all?
03:41:58 <ior3k> shoudn't everything be a typeclass?
03:41:58 <isomorphic> If that's correct, it sounds like I need to get the string *out* of the GenParser monad in order to convert it to a maybe string
03:41:58 <ior3k> (if it's meant to be reused, I mean)
03:43:53 <ior3k> (sorry about the repost, I got disconnected:)
03:44:05 <ior3k> (12:01:34) ok, sorry about the basic questions, but given data's limitations, does it make sense to export those kinds of types at all?
03:44:05 <ior3k> (12:01:52) shoudn't everything be a typeclass?
03:44:05 <ior3k> (12:02:15) (if it's meant to be reused, I mean)
03:44:49 <blackdog> ior3k: typically, you'll export the type but not the constructors
03:45:03 <blackdog> so the impl can be changed, at least.
03:45:31 <blackdog> the kind of reuse you do in haskell is quite different, and on the level of functions
03:46:50 <johnson09> can anyone tell me what a "caveat" is?
03:47:50 <mauke> a "be careful"
03:47:52 <Veinor> 'something to be aware of'
03:48:36 <hyuma> hello, any idea about lambda calculus? http://paste.pocoo.org/show/403371/
03:48:45 <hyuma> as regards call by value with static scoping
03:48:51 <hyuma> x is 5 and 7?
03:48:54 <mauke> what
03:49:19 <mauke> 1) what language is that?  2) what does that have to do with lambda calculus?  3) what does that have to do with haskell?
03:49:20 <johnson09> And how do you pronounce it? "cave-eat"? "cave-at"?
03:49:27 <ivanm> more the former
03:49:47 <mauke> johnson09: I pronounce it germanly
03:49:47 <Cale> cav-ee-at
03:49:49 <ior3k> blackdog: how do you extract values from the exported Shape, then? Accessor functions?
03:49:57 <mauke> kah-vay-aht
03:50:21 <Veinor> i think it's 'cahv-ee-aht'
03:50:24 <Entroacceptor> it's Latin
03:50:31 <blackdog> ior3k: yeah, that's one way of doing it. but it's going to vary case by case, depending on how much you want to hide.
03:50:33 <hyuma> im looking for a helo channel for lambda calculus someone tells me to ask here
03:50:55 <johnson09> ivanm: former as in the before or after?
03:50:56 <Cale> hyuma: Did you link to the wrong paste?
03:51:03 <Veinor> \ˈka-vē-ˌät, -ˌat; ˈkä-vē-ˌät; ˈkā-vē-ˌat\
03:51:05 <blackdog> one approach is to use records and export the accessors - that way, if you find a better way of doing it, you can export normal functions with new implementations later
03:51:11 <Cale> (because your paste didn't seem to have anything to do with the lambda calculus)
03:51:14 <johnson09> Veinor: that ain't english, son
03:51:16 <ivanm> johnson09: the first one
03:51:18 <hyuma> Cale: not i'm talking about http://en.wikipedia.org/wiki/Evaluation_strategy
03:51:30 <Cale> hyuma: Okay...
03:51:30 <ior3k> blackdog: but in that case you can't use pattern matching, right?
03:51:36 <blackdog> ior3k: yep.
03:51:37 <benmachine> good afternoon, #haskell
03:51:43 <mauke> hyuma: hello?
03:51:50 <hyuma> mauke: hello.
03:51:51 <johnson09> mauke: hello?
03:52:04 <mauke> hyuma: are you going to answer my three questions?
03:52:04 <benmachine> johnson09: hello!
03:52:18 <hyuma> muake: not a language, is only a evaluation strategy
03:52:40 <hyuma> mauke: i just thinked someone could help me, thats all
03:52:43 <mauke> huyma: if it's not a language, it can't be understood
03:52:45 <Cale> hyuma: The thing you linked to isn't an evaluation strategy...
03:52:50 <johnson09> benmachine: Please to make you acquaintance
03:53:00 * benmachine tips hat
03:53:02 <Cale> hyuma: (the wikipedia page was about evaluation strategies...)
03:53:27 <Cale> hyuma: I guess I just don't understand what you're asking
03:53:28 <ior3k> blackdog: ok, I think I get it, basically pattern matching should be used more for "private" methods since it depends on argument positioning, etc
03:53:42 <hyuma> Cale: is possibile value the 2 write(x), considering call by value and call by reference
03:54:01 <hyuma> with static scoping and dynamic scoping
03:54:16 <mauke> what does scoping have to do with evaluation strategy?
03:54:24 <Cale> The code that you posted looks mangled
03:54:48 <hyuma> http://en.wikipedia.org/wiki/Scope_(computer_science)
03:54:52 <Cale> errr... oh, maybe it's just the indentation is weird
03:55:14 <mauke> can we move this to #haskell-blah?
03:55:15 <hyuma> Cale, it's onyl a portion of code
03:55:21 <mauke> hyuma: it's not code
03:55:30 <hyuma> mauke: oh my god i know
03:56:45 <Cale> hyuma: I can't parse your question...
03:56:48 <Cale> <hyuma> Cale: is possibile value the 2 write(x), considering call by value and call by reference
03:58:11 <Cale> Oh, I think I'm starting to see what you're asking about.
03:58:19 <Cale> Let me clean this up...
04:00:49 <hyuma> read pvt
04:29:57 <kstt> hey. I've installed cabal without syntax highlighting support. Now I want to reinstall it with highlighting support. Can cabal do this without breaking already installed librairies that depends upon currently installed pandoc ? Last time I did that, I broke a lot of packages.
04:30:32 <kstt> huh, sorry for the confusion, the first sentence should read : I've installed PANDOC without syntax highlighting support.
04:30:38 <dcoutts> kstt: sadly no, not if you're reinstalling the same version of pandoc
04:31:01 <benmachine> kstt: if you recompile pandoc with different options the ABI might change
04:31:11 <benmachine> so stuff built against it will have to be rebuilt against the new one
04:31:22 <kstt> yes, that's surprisingly related to the version of the package. No problem with different version, but things break if same version. Strange.
04:31:30 <ivanm> benmachine: it will definitely change; pretty sure adding highlighting support changes the API
04:31:45 <benmachine> ivanm: oh, yes, I suppose so
04:32:11 <kstt> benmachine: but there is room for both variants in my hard drive, no need to unregister previous variant.
04:32:48 <kstt> and, above all, no need to break dependencies silently, which seems to be current behaviour. A blocking warning at least would be nice.
04:32:58 <benmachine> yeah I'd like more warnings
04:34:00 <Cale> lol, hpaste just ate my paste. I'm not sure what it has done... :)
04:34:25 <bmm> Is there a default implementation for waitForChildren somewhere? Of should I copy it form the Control.Concurrent documentation?
04:34:28 <kstt> as dcoutts pointed out, if I waited for an other pandoc release, I could reinstall pandoc with highlighting support, without breaking dependent packages.
04:35:07 <Cale> http://hpaste.org/47618 -- wtf? I lost the indentation on two lines.
04:35:23 <Cale> (there's supposed to be a nested do block there)
04:35:46 <mauke> Cale: don't bother, he's long gone, and that wasn't C
04:36:08 <Cale> mauke: He's not gone, I'm talking to him in private
04:36:23 <mauke> ah, interesting
04:36:30 <Cale> I made a valid C version of the program with not much change.
04:36:34 <mauke> he's been to ##c in the mean time
04:37:03 <dcoutts> kstt: or do a local version bump yourself, just append a .0 or a date or something
04:37:15 <kstt> lol :)
04:37:55 <Cale> mauke: This is a slightly different program than he started with, but we changed it to illustrate some more things: http://codepad.org/nEFMi0QX
04:38:25 <kstt> thanks for the tip. I think I'll just reinstall the whole thing. Do you know if I can stick somewhere cabal flags for certain packages, please ? I'd like to set -f highlighting for pandoc once and for all.
04:38:50 <kstt> even when installed as a dependency
04:38:57 <mauke> Cale: void main is invalid; nested functions are invalid
04:39:04 <mauke> write may clash with write(2) on unix
04:39:24 <Cale> mauke: Well, codepad.org seems to compile and run it just fine anyway :P
04:39:32 <Jafet> unix is invalid
04:39:42 <Cale> So it's close enough to C to actually run :)
04:39:49 <mauke> Cale: yes, but with no guarantees about its semantics
04:39:50 <chrisdone> You can tell mauke's been exposed to ##c for a substantial length of time.
04:40:03 <Cale> Whatever.
04:40:11 <Jafet> He's more of an exposer than an exposee
04:40:16 <mauke> chrisdone: oh hey, welcome to 1995 or so
04:40:54 <RichardBarrell> Nested functions in C are a gcc extension.
04:40:59 <Jafet> Now let's get back to C++, okay?
04:41:04 <chrisdone> mauke: Were you in C scene? ;)
04:41:17 <mauke> chrisdone: what's that?
04:41:33 <RichardBarrell> If you use them then don't plan on being portable to other C compilers.
04:41:39 <blackdog> is there a non-recursive way of computing integer logs in haskell?
04:42:02 <Jafet> What's recursion?
04:42:46 <Cale> chrisdone: Did you see what happened to my paste?
04:42:48 <chrisdone> Cale: I fixed the indentation, but there's some oddity with the highlighter library that I don't comprehend: http://hpaste.org/47618
04:42:51 <blackdog> Jafet: something that doesn't particularly want to run on a GPU:)
04:42:56 <Cale> chrisdone: Cool, thanks
04:43:01 <kstt> hi chrisdone, I enjoyed reading your blogpost about new amelie design, snap and postgresql-simple ! I'll soon use postgresql-simple, as soon as it is on hackage. Also, I noticed you implemented a pool for it, and wondered if you are aware of the generic resource-pool package (also by BOS).
04:43:04 <quicksilver> recursion is, fundamentally, haskells only form of looping.
04:43:18 <Jafet> For large numbers, binary search is a little bit better than linear search
04:43:47 <blackdog> quicksilver: not really true if you're using Accelerate
04:43:49 <chrisdone> Cale: It appears to add newlines after comments. I 'patched' that by display:none'ing those, but lo, it breaks indentation. The package doesn't contain an example stylesheet so it's not clear to me.
04:44:08 <chrisdone> kstt: Ah, I hadn't seen that, thanks. I'll check it out.
04:44:08 <blackdog> you go to a fair bit of effort there in order not to do tests
04:44:11 <quicksilver> blackdog: yes, it remains absolutely true.
04:44:15 <Cale> Which highlighter are you using?
04:44:19 <quicksilver> blackdog: Accelerate is a DSL, it's not haskell ;)
04:44:23 <Jafet> Or if you can get a base-2 logarithm somehow
04:44:35 <chrisdone> Cale: Literally, highlighter: http://hackage.haskell.org/package/highlighter
04:44:42 <blackdog> quicksilver: alright then, to clarify: I care about writing fast code that looks like haskell:)
04:44:45 <blackdog> http://hpaste.org/47619
04:44:47 <Jafet> Unfortunately, you probably can't
04:44:56 <quicksilver> blackdog: so your question is really 'is there a good way of calculating integers logs using the constructs accelerate gives me.
04:45:08 <kstt> chrisdone: it seems BoS has not advertised it much. It works really well as a drop-in solution.
04:45:14 <blackdog> more or less to that spec. unfortunately log laws don't seem to help me in the realm of integers.
04:45:25 <quicksilver> blackdog: I don't know the answer, but your mention of haskell in the first question sent me astray :)
04:45:59 <Jafet> They would, by making a search faster
04:46:08 <ivanm> the function parameter for Data.Map.alter takes a Nothing to indicate the value wasn't present in the original Map, right?
04:46:32 <chrisdone> kstt: Ah, brilliant! This also implements limitations and timeouts, something I wanted but didn't want to implement at the time. Grand.
04:47:38 <Jafet> Actually, given that you're operating on small numbers, binary search is probably bad, unless some parameters are constant
04:49:09 * chrisdone copokes copumpkin
04:49:44 * hackagebot yesod 0.8.2.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.8.2.1 (MichaelSnoyman)
04:50:43 <kstt> chrisdone: indeed. The only point I'm not entirely happy with, is the handling of breakage. If an exception reaches the pool (through a pooled ressource), this resources is closed, and the exception is raised to the caller. While it's a sane default, I'd like it to be customizable, for exemple I'd like the pool to retry the action on a newly created resource. That would handle cleanly the case of database connection lost.
04:51:50 <kstt> I could obviously wrap the pool in a smartish type, but I think this behaviour should be configurable.
04:52:29 <chrisdone> kstt: Sure.
04:52:49 <kstt> other than that, things just work well !
04:54:17 <chrisdone> kstt: Gonna send bos a patch? ;)
04:56:17 * bmm found CHP and is now looking into it
05:08:45 <kstt> chrisdone: I'm really interested by your work on pgsql-simple, I'll try to take some time to study it more. Out of curiosity, what protocol specs did you use ?
05:09:09 <chrisdone> kstt: This one: http://www.postgresql.org/docs/current/static/protocol.html
05:09:21 <kstt> ok thanks
05:10:22 <johnson09> Is there much use in learning Haskell over popular imperative language, other than educational reason?
05:11:09 <chrisdone> johnson09: Sure, Haskell has many features valuable for serious projects.
05:11:29 <johnson09> chrisdone: Is it used by Google?
05:11:36 <johnson09> as in Google search algorithms?
05:12:12 <chrisdone> johnson09: I heard some projects in Google are Haskell. But, no, Google's main languages are Java, C++, Python and Go.
05:12:23 <kstt> johnson09: want to know my favourite feature of functional programming ? I can *reason* about my programs on a sheet of paper, and that's very valuable. Less and less trial-and-error in front of a screen ruinning my eyes and my brain. Big win !
05:13:31 <johnson09> kstt: So you mean functional is the future?
05:15:11 <chrisdone> To make a prediction like that accurate you would have to limit the scope to one person.
05:16:01 <kstt> yeah, don't know if it is THE future, but surely it's MY future :)
05:16:34 <chrisdone> Cale: Ahhhhh. I figured it out. It's \r characters.
05:16:50 <Cale> chrisdone: ah, okay
05:17:06 <chrisdone> Seems to be splitting by \n and not taking \r into account.
05:17:13 * chrisdone strips 'em
05:17:48 <aavogt> > lines "a\n\rb\nc\rd"
05:17:49 <lambdabot>   ["a","\rb","c\rd"]
05:18:27 <chrisdone> > unlines . lines $ "a\n\rb\nc\rd\r\nz"
05:18:29 <lambdabot>   "a\n\rb\nc\rd\r\nz\n"
05:18:39 <ski> (.. opening text files in binary mode ?)
05:21:47 <poucet> > lines "a\r\nb\r\n"
05:21:49 <lambdabot>   ["a\r","b\r"]
05:24:29 <chrisdone> Cale: A'ight, fixed.
05:24:39 <develhevel> what is the sequence for a tab? i know \n is a new line but what is tab?
05:25:00 <Cale> \t
05:25:17 <ski> "\t" is horizontal tab, "\v" is vertical tab
05:25:24 <develhevel> thx
05:28:07 <develhevel> is there a function which checks if a function name is a falid sequence of chars?
05:28:55 <chrisdone> A valid sequence of characters for a Haskell-98 symbol?
05:30:04 <develhevel> i want to let the user choose a function name, and need to chose if it is valid e.g. it dont begins with a number
05:30:06 <chrisdone> Cale: Do you prefer the purple theme (a la olde Haskōl and hpaste), or blue theme (a la haskell.org)?
05:30:45 <SoleSoul> Hello guys. I am on a haskell parser for a java-like code for a long time. After a chage somewhere in the code it seems like I created an infinite loop. I can't find where. Is there a way to know which functions are being called? to debug it somehow? I don't want to change the code if possible. Thanks.
05:30:58 <SoleSoul> *I am working
05:31:07 <chrisdone> develhevel: You can check with Data.Char using isDigit, or ((`elem` (map show [1..9]).return), or use Parsec, or regex.
05:31:20 <dankna> SoleSoule: look into Debug.Trace.trace
05:31:56 <SoleSoul> I heard this name before. how does it work? is it like cout from places in the code?
05:32:16 <SoleSoul> dankna: or is it a wrapper for the application which traces the function calls?
05:32:18 <chrisdone> > any isDigit $ take 1 $ "1x"
05:32:19 <lambdabot>   True
05:32:28 <dankna> it's like cout, yes
05:32:42 <SoleSoul> dankna: then I'll have to change the code?
05:32:59 <dankna> yes you will.  it's the best approach that's available, because you can't get a simple call stack because of lazy evaluation.
05:33:08 <SoleSoul> danka: (it's quite long)
05:33:14 <SoleSoul> dankna: (it's quite long)
05:33:29 <dankna> I suggest you start with just a few trace statements around where you suspect the problem might be.
05:33:33 <dankna> Perhaps the last things you changed.
05:33:48 <dankna> If you had been using a version-control repository, you could compare the last working version with your current one.
05:33:58 <dankna> But since I infer you are not or you would have thought of that, you have to do it the hard way.
05:34:46 <SoleSoul> dankna: It looks weird to me, as a beginner, that there is no debugger
05:35:10 <dankna> SoleSoul: Yes, it does look weird, doesn't it.
05:35:27 <dankna> SoleSoul: Again because of lazy evaluation, a debugger in the true sense is not really possible.
05:35:50 <dankna> SoleSoul: Hopefully the other productivity enhancements Haskell brings to the table are enough to offset this lack.
05:35:55 <Cale> Oh, chrisdone left.
05:35:58 <opqdonut> what is the "true sense" of a debugger?
05:36:08 <SoleSoul> dankna: If only I could have the list of calls...
05:36:09 <opqdonut> haskell can perfectly well be debugged, see the ghci debugger
05:36:14 <dankna> SoleSoul: Indeed, if only!
05:36:37 <SoleSoul> opqdonut: can I get the list of calls from ghci?
05:36:39 <opqdonut> yes
05:36:49 <SoleSoul> very good! how?
05:36:50 <SoleSoul> :)
05:37:03 <SoleSoul> :l file.hs
05:37:09 <SoleSoul> I guess
05:37:11 <SoleSoul> and then?
05:37:18 <ehamberg> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
05:37:35 <dankna> I actually haven't played around with that much.
05:37:40 <mightybyte> Where is the Monad instance of Either defined?
05:37:54 <geheimdienst> ehamberg: nice link, thanks a lot
05:37:58 <opqdonut> SoleSoul: see :trace and :history
05:38:09 <opqdonut> and read the ghc manual's chapter on debugging
05:38:23 <ski> mightybyte : `Control.Monad.Error' iirc ..
05:38:43 <SoleSoul> opqdonut: I tried trace and history but it said "not stopped at a breakpoint" because I killed it with ^C
05:39:06 <SoleSoul> opqdonut: the problem is an infinite loop and I don't know where it occurs
05:39:21 <mightybyte> ski: From mtl?
05:39:44 <opqdonut> SoleSoul: ah, see -fbreak-on-exception
05:39:44 <ski> iirc, yes
05:40:07 <SoleSoul> opqdonut: tried that also. :set -fbreak-on-exception
05:40:12 <SoleSoul> I'll try again
05:41:57 <SoleSoul> opqdonut:  Empty history. Perhaps you forgot to use :trace?  <- this is what happens after ^C and :history
05:42:12 <SoleSoul> opqdonut:  I ran :trace main
05:42:39 <mightybyte> ski: Oh, it's Control.Monad.Trans.Error
05:43:20 <mightybyte> What's the recent change mentioned here?  http://stackoverflow.com/questions/6290712/using-either-in-haskell/6290743#6290743
05:45:55 * hackagebot blaze-html 0.4.1.3 - A blazingly fast HTML combinator library.  http://hackage.haskell.org/package/blaze-html-0.4.1.3 (JasperVanDerJeugt)
05:47:18 <SoleSoul> l
05:48:35 <opqdonut> SoleSoul: hmm, that's weird
05:49:20 <SoleSoul> opqdonut: can I provide more information?
05:49:39 <develhevel> i have a list of 100 entries, how go get e.g. the entry at position 3? or on the 43th position?
05:49:45 <opqdonut> I'm getting the same behaviour with something simple
05:49:59 <geheimdienst> > [1..99] !! 42
05:50:00 <lambdabot>   43
05:50:27 <ski> develhevel : it's better to use a different data structure, if you're going to do arbitrary indexing
05:50:52 <develhevel> ski: which?
05:50:56 <Cale> For example, an array, or Data.Sequence, or Data.Map
05:50:56 <geheimdienst> yeah. (!!) is available, but it's used sparingly in haskell
05:51:04 <ski> develhevel : depends. e.g. arrays
05:51:29 <kstt> develhevel: you usually don't need it
05:51:30 <Cale> xs !! n will take n steps to reduce
05:51:51 <Cale> well, n+1 :)
05:53:13 <SoleSoul> opqdonut: do you know what can I do? who should I ask?
05:53:55 <kstt> does anybody know if cabal can be configured to automatically use a set of flags for a given package ?
05:54:12 <opqdonut> SoleSoul: sorry, no idea :/
05:54:16 <Cale> SoleSoul: One option for finding your infinite loop would be just to enable profiling by compiling with -prof -auto-all and then run the program with +RTS -p in addition to its usual commandline options
05:54:35 <SoleSoul> opqdonut: Thank you for your help
05:54:46 <Cale> SoleSoul: and then look at the profiling output and see what code looks like it has a large number in the "entries" column
05:54:56 <SoleSoul> Cale: I'll see if I will get it right. I'm trying now
05:55:28 <Cale> SoleSoul: Usually we try to debug Haskell programs by breaking them down into smaller programs which can be tested independently. If you have a lot of mutual recursion, that can be hard though.
05:56:34 <SoleSoul> Cale: Most RTS options are disabled. Link with -rtsopts to enable them. <- do it?
05:56:52 <Cale> yeah
05:57:01 <Cale> btw, I hate that
05:57:06 <Cale> It's new in GHC 7
05:57:10 <Cale> I don't understand why they did it
05:57:16 <SoleSoul> Cale: tried it. didn't change
05:57:32 <Cale> rm *.o *.hi
05:57:35 <Jafet> -fforce-recomp
05:57:36 <SoleSoul> ah ok
05:57:53 <Jafet> I don't understand why they don't do that
05:58:22 <dankna> security.
05:58:26 <SoleSoul> now its running infinitly
05:58:32 <SoleSoul> ^C?
05:58:47 <dankna> some of us would regard ti as rather upsetting if our programs responded to command-line options we didn't explicitly request.
05:59:06 <dankna> yes, it's true that the other could be the default, but if you don't know about the feature, it's like GHC has betrayed you.
05:59:14 <dankna> so I like the new default.
05:59:56 <Cale> SoleSoul: yeah
06:00:04 <Cale> SoleSoul: and see if there's a .prof file created
06:00:06 <SoleSoul> Cale: I opened the prof file
06:00:17 <SoleSoul> what am I looking for? :)
06:00:26 <Cale> Something with a lot of entries
06:00:34 <Cale> Maybe you could put it on hpaste
06:00:43 <SoleSoul> ooo think I see it
06:01:18 <SoleSoul> Cale: but it's in 4 functions which call each other :/
06:01:59 <SoleSoul> Cale: at least I know its these four. Now I have to rethink about their logic, right? no more hints
06:02:06 <Cale> yeah
06:02:23 <SoleSoul> Cale: Ok. thank you! first step closer to solution
06:05:19 <SoleSoul> Cale: here is the prof file. Is there more info to get from there? http://hpaste.org/47620   I even found the line which I can comment out to prevent the infinite loop but I don't understand the cause of it because it's not a recursion line.
06:06:09 <Cale> Well, let's look at those 4 definitions
06:08:06 <SoleSoul> Cale: tokLex is not recursive. it is only being called by the recursive functions so I think we can ignore it. I'll look into the other 3
06:09:03 <SoleSoul> Cale: Ah! It has to be in the most outer function of the 3!
06:12:08 <develhevel> is it possible to replace items in a list on a speficic number. e.g. ["a", "b", "c"] and i want to change the 2nd to "d"
06:13:58 * hackagebot http-enumerator 0.6.5.2 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.6.5.2 (MichaelSnoyman)
06:14:32 <Cale> develhevel: It's possible, but there's no function in the Prelude to do it.
06:15:15 <Cale> replace k v xs = [if n == k then v else x | (n,x) <- zip [0..] xs]
06:15:16 <ski> > let (xs !!<- n) f = front ++ f x : back where (front,x:back) = splitAt n xs in [[0,1,2,3],[4,5,6],[7,8],[9],[]] !!<- 1 $ \xs -> reverse (xs !!<- 2 $ \x -> x^2)
06:15:18 <lambdabot>   [[0,1,2,3],[36,5,4],[7,8],[9],[]]
06:15:24 <Cale> Or you can use splitAt
06:15:33 <Cale> (which is a bit cheaper)
06:15:46 <Cale> again, if you're doing this a lot and doing lots of random access, you probably want Data.Map
06:15:58 * hackagebot authenticate 0.9.0.2 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.9.0.2 (MichaelSnoyman)
06:16:07 <ehamberg> > let l = ["a","b","c"] in take 1 l ++ ["d"] ++ drop 2 l
06:16:08 <ski> develhevel : ^ that is one way to do it
06:16:08 <lambdabot>   ["a","d","c"]
06:18:26 <develhevel> i will use drop and take, seems the easyest way for me
06:19:02 <bmm> chp-plus won't install because of  "`Test.QuickCheck.Property' does not export `liftIOResult", I'm using cabal, what am I doing wrong?
06:19:03 <ski> it's somewhat better to use `splitAt' if you're going to need both `take' and `drop' (at basically the same index)
06:19:04 <frerich2> Cale: Out of curiousity, why would a splitAt-based version be cheaper than your list comprehension?
06:20:02 <develhevel> ski: ah okay, that sounds logically
06:20:05 <SoleSoul> Cale: Thank you very much! I found the faulty function. I saved this conversation for future reference. :)
06:21:21 <ski> (develhevel : and if it wasn't clear, `xs !!<- n $ \x -> f x' will replace the `n'th element `x' of `xs' with `f x')
06:21:30 <Cale> frerich2: Because it doesn't induce any cost for the elements of the list beyond the one being replaced
06:25:33 <frerich2> Cale: Ah, true!
06:26:41 <frerich2> Cale: Are you the author of "Monads as computation" on the Haskell wiki?
06:26:50 <Cale> yes
06:27:41 <erus`> is there a nibble type ? (4bit)
06:27:43 <frerich2> Cale: First of all, thanks a lot for it! It seems that everybody agrees that it's one of the (few :-/) correct *and* comprehensible texts on monads in Haskell. I recently read it (I'm still trying to digest monads, I'm quite new at Haskell) and one thing came to my mind while reading it. Maybe you can shed some light?
06:27:51 <Cale> sure
06:28:15 <frerich2> Cale: You wrote "Given a pair of computations x and y, one can form the computation x >> y, which intuitively "runs" the computation x, throws away its result, then runs y returning its result." and then give the following signature:
06:28:24 <frerich2> Cale: "(>>) :: (Monad m) => m a -> m b -> m b"
06:28:33 <Cale> yep
06:28:59 <frerich2> Cale: However, if it "runs y returning its result", shouldn't the signature be 'm a -> m b -> b' since 'm b' is the type of the computation 'y' and hence the type of its result is 'b'?
06:29:16 <Cale> The computation x >> y is itself a computation
06:29:17 <kstt> "return" is confusing here
06:29:29 <Cale> computations return values when run
06:30:07 <Cale> If x :: m a is some computation, then running the computation x produces a result of type a
06:30:21 <Dr_H> hey
06:30:59 * hackagebot authenticate 0.9.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.9.1 (MichaelSnoyman)
06:31:03 <frerich2> Cale: Right, I understood that. You explicitely wrote "Given a monad M, a value of type M t is a computation resulting in a value of type t.". So in the signature of '>>', running the computation y (which has the type 'm b' according to the signature) should yield a value of type 'b', right?
06:31:06 <frerich2> Ah, but hold on...
06:31:19 <Cale> frerich2: >> takes two computations and produces another
06:31:30 <Cale> by gluing them together in the way that I described
06:31:31 <kstt> I find this confusing. If "x :: a" then the result of x is of type "a", forall "a".
06:31:33 <frerich2> What confuses me is that you write '>>' is a computation *and* you write that it runs the computation 'y' and returns its result.
06:31:42 <Jafet> Programming analogies are like leaky screwdrivers.
06:31:51 <Cale> kstt: we mean a specific a really ;)
06:31:55 <frerich2> I guess what's meant is that the computation *generated by* '<<' yields a 'b'.
06:32:15 <Cale> frerich2: I'm describing what the computation does when it's run
06:32:19 <Cale> yeah
06:32:30 <frerich2> It starts to make sense.
06:32:33 <ski> "run" is different from "evaluate"
06:32:46 <Cale> yes, that's important
06:33:09 <kstt> frerich2, Cale: I really think the problem lies in the "return" word, nothing more. In the context of monads, "return" has a specific meaning, which is different from a regular function.
06:34:05 <Cale> I try not to use the word 'return' when referring to the manner in which functions applied to arguments evaluate to values.
06:34:34 <kstt> frerich2: in the Monad class, return has type : "a -> m a"
06:34:44 <frerich2> kstt: Yes, I understood that.
06:35:19 <byorgey> hi Dr_H
06:35:43 <Jafet> @quote Monads.are.monads
06:35:43 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
06:35:48 <Jafet> @quote Monads.are.just.monads
06:35:48 <lambdabot> No quotes match. :(
06:36:21 <kstt> frerich2: then, you know why "Given a pair of computations x and y, one can form the computation x >> y, which intuitively "runs" the computation x, throws away its result, then runs y *returning* its result." implies (>>) :: (Monad m) => m a -> m b -> m b
06:36:39 <byorgey> @quote Monads.are.just.monoids
06:36:39 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
06:37:01 * hackagebot yesod-examples 0.8.0.2 - Example programs using the Yesod Web Framework.  http://hackage.haskell.org/package/yesod-examples-0.8.0.2 (MichaelSnoyman)
06:37:20 <mauke> preflex: quote Duqicnk
06:37:20 <preflex>  <Duqicnk> a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
06:37:26 <Cale> I think the important thing is to look at the sentence carefully, since it is a bit of a mouthful...
06:37:46 <Jafet> @quote dolio monad
06:37:46 <lambdabot> dolio says: Monad are just monads in the 2-category of categories.
06:37:47 <Cale> It's important to see that it's "the computation x >> y, which (...)"
06:38:02 <Cale> everything in the (...) there is an explanation of what the formed computation does
06:38:10 <Cale> (when run)
06:40:01 * hackagebot makedo 0.1 - Helper for writing redo scripts in Haskell  http://hackage.haskell.org/package/makedo-0.1 (EricKow)
06:40:13 <byorgey> o-_-o: diagrams and SVG have very different purposes.  SVG is a standard format for storing and transmitting vector graphics.  Diagrams is a framework for programmatically creating vector graphics.
06:42:44 <scott_> Hey. How's it going?
06:43:30 <Jafet> @vixen How's it going?
06:43:30 <lambdabot> i'll hafta plead the fifth on that one.
06:46:01 <develhevel> howto check if a char is a-z A-Z?
06:46:27 <mauke> \c -> inRange ('a', 'z') c || inRange ('A', 'Z') c
06:46:48 <frerich2> Cale: I must be dense, and I almost don't dare to ask any further, but: in the part "[..] then runs y returning its result.", in what sense is "returning" meant? in the 'a -> m a' sense?
06:47:02 <ski> > isAlpha `map` "You might want this instead ?"
06:47:03 <lambdabot>   [True,True,True,False,True,True,True,True,True,False,True,True,True,True,Fa...
06:47:23 <erus`> @Hoogle Word8 -> Int
06:47:23 <lambdabot> Maybe you meant: google hoogle
06:47:28 <erus`> @hoogle Word8 -> Int
06:47:28 <lambdabot> Data.ByteString count :: Word8 -> ByteString -> Int
06:47:29 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
06:47:29 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
06:47:30 <Cale> frerich2: Well, the m a which is created by 'return v' is a computation which does nothing except to return v
06:47:36 <copumpkin> > isAlpha . "ugh . is fmap"
06:47:36 <Cale> frerich2: So, they're related.
06:47:37 <lambdabot>   [True,True,True,False,False,False,True,True,False,True,True,True,True]
06:47:40 <mauke> frerich2: no, in the m a sense
06:48:03 <Cale> frerich2: Remember that we're talking about an arbitrary bunch of computations which produce values when "run", whatever it means to "run" them.
06:48:49 <erus`> > let x = 3 :: Int in Word8 x
06:48:49 <lambdabot>   Not in scope: data constructor `Word8'
06:48:51 <Cale> frerich2: If they're parsers, for example, it means to allow them to (possibly) consume some of the input, and produce a result, along with a depleted bunch of input (possibly in many ways)
06:48:53 <erus`> > let x = 3 :: Int in Data.Word8 x
06:48:54 <lambdabot>   Not in scope: data constructor `Data.Word8'
06:49:02 <erus`> @import Data
06:49:03 <lambdabot> Unknown command, try @list
06:49:08 <erus`> :import Data
06:49:25 <Cale> frerich2: If they're IO actions, when they run they'll have a bunch of I/O effects before returning some value.
06:49:35 <Cale> frerich2: Like  getLine :: IO String
06:49:49 <Cale> will ask the user for a line of text, and return a String result
06:49:52 <frerich2> Cale: Yes, I understood that.
06:50:12 <Cale> So  getLine >> getLine
06:50:13 <frerich2> Cale: It's just the description of the '<<' function which, at least to my naive reading, doesn't fit what the signature of << says
06:50:21 <Cale> will ask for two lines of text, but only return the second one
06:50:22 <erus`> how can I coerc an Int to a word8?
06:50:27 <Cale> >> you mean
06:50:31 <frerich2> Cale: Hmm let me digest that...
06:50:49 <copumpkin> erus`: you don't coerce things in haskell, but we do have fromIntegral :)
06:51:10 <ski> frerich2 : e.g. `return 2' is an action that when run does nothing and returns `2', while `putStr "hello" >> return 2' is an action that when run will output `hello' before returning `2'
06:51:47 <byorgey> @quote fromIntegral
06:51:47 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
06:51:58 <frerich2> Cale, ski: Thanks a ton, I think I understood what '>>' does all the time. It's just that I read the textual (english) description in a strange way.
06:52:08 <erus`> cheers copumpkin
06:53:04 <frerich2> Cale, ski: If you don't mind, with your getLine example, a second question comes to mind. In 'getLine >> getLine' (or 'putStr "foo" >> getLine'), there is no data dependency between the two "chained" computations, right? How comes the computation generated by '>>' still enforces a sequence?
06:53:25 <Cale> frerich2: Because that's what >> does. :)
06:53:40 <mauke> frerich2: think of it as constructing a syntax tree
06:53:44 <Cale> I mean, you can think of the type IO t as being internally something like:
06:53:49 <Cale> data IO t where
06:53:49 <mauke> huhu
06:53:56 <Cale>   ReturnIO :: t -> IO t
06:54:08 <Cale>   BindIO :: IO t -> (t -> IO s) -> IO s
06:54:16 <Cale>   GetChar :: IO Char
06:54:25 <Cale>   PutChar :: Char -> IO ()
06:54:28 <Cale> etc, etc.
06:54:43 <Cale> That is, you get a bunch of values which just represent what's supposed to be done
06:55:10 <Cale> and then the Haskell runtime system goes through the value defined as main and carries out the actions in an effectful way
06:55:37 <Cale> It's not actually implemented like this, but it could be.
06:56:27 <Cale> Does that help?
06:56:30 <Cale> So when you write...
06:56:37 <frerich2> Cale: Maybe the lazy nature of Haskell is getting me a bit confused at this point, but with >>=, I understand why the second computation is run after the first (since the result of the first is passed, so there is a data dependency, right?). However, with >>, the result of the first is thrown away, nothing depends on the result - why is the first computation run anyway, if nothing needs the result?
06:56:55 <frerich2> Cale: It's very much appreciated, and I'm moving foprward in my understanding, thanks a ton for your patience with my questions :-)
06:56:58 <mauke> frerich2: laziness is irrelevant here
06:57:08 <mauke> >> does not ignore its first argument
06:57:13 <Cale> Evaluation is completely separate from execution
06:57:23 <Cale> Evaluation means turning expressions into values
06:57:47 <mauke> a >> b = BindIO a (\_ -> b)
06:57:49 <Cale> Execution (of IO actions) means examining these values describing I/O to be performed and actually carrying out the I/O described.
06:57:54 <Cale> Yeah?
06:58:03 * frerich2 nods
06:58:24 <frerich2> Somehow this all sounds a bit like the 'command' pattern in e.g. C++, or closures in general.
06:58:31 <frerich2> Like a 'delayed' execution.
06:58:31 <Cale> So when you evaluate x >> y, nothing visible actually happens, it just evaluates to a value which describes the action of doing x and then y
06:58:58 <Cale> Every Haskell program is a functional program which constructs an imperative program which is then run :)
06:59:05 <mauke> frerich2: nah, we're building a straight up tree
06:59:06 <Cale> Well "imperative"
06:59:16 <copumpkin> Cale: for some values of "then"
06:59:20 <mauke> ok, some of the nodes contain callbacks
06:59:47 <zygoloid> frerich2: if nothing needs the result, the first computation of (>>) isn't necessarily executed; it depends on the monad.
06:59:47 <Cale> yeah, the processes of evaluation and execution get interleaved because of >>=
07:00:09 <frerich2> zygoloid: AHA!
07:00:10 <copumpkin> but ideally that shouldn't be observable
07:00:17 <zygoloid> > runIdentity (undefined >> return 0) -- it isn't necessarily even /evaluated/
07:00:18 <lambdabot>   0
07:00:23 <ski> frerich2 : one possibly way to think of it is that the second computation has a data dependency on the new state of the world produced by the first computation
07:01:07 <byorgey> (for the IO monad in particular)
07:01:10 <zygoloid> > Nothing >> Just "hello" -- but sometimes the result can be affected by the first computation
07:01:11 <lambdabot>   Nothing
07:01:24 <mauke> argh, not this "state of the world" again
07:01:30 * ski grins
07:01:33 <benmachine> if you really want >> to preserve order (as you do in IO), you can just introduce an entirely artificial data dependency
07:01:52 <mauke> you don't have to introduce data dependencies because the execution of IO is not in Haskell
07:01:55 <mauke> it's not lazy
07:02:09 <Cale> Yeah, in the GHC implementation, they do the somewhat hacky thing of using impure functions and tokens to keep the data dependencies straight
07:02:18 <Cale> But you needn't actually think about it that way
07:02:33 <Cale> It's easier to think about it in terms of values which simply describe stuff to be done.
07:02:46 <ski> (in a system with uniqueness typing, one could do it this way)
07:02:54 <zygoloid> you can imagine that the IO moand builds a tree, which some imperative exoprogram executes
07:03:49 <frerich2> I think I've never been so close to really "getting" it than right now. And somehow, there doesn't seem to be terribly much "meat" to it, actually.
07:03:58 * frerich2 has to find a way to not forget this
07:04:33 <Cale> Yeah, there's not a whole lot to this.
07:04:56 <Cale> In general, Monad just describes a certain API shape which some libraries conform to.
07:05:26 <mauke> I have no context
07:05:28 <Cale> and when they conform to it, we have a bunch of general polymorphic functions ready
07:05:29 <mauke> frerich2: do you know javascript?
07:05:43 <frerich2> mauke: Yes, actually I was just thinking of it (of closures, in particular)
07:06:04 <mauke> well, IO should make you think of XMLHttpRequest
07:06:20 <mauke> closures are sort of orthogonal
07:06:24 <mauke> maybe diagonal
07:09:23 <frerich2> I think another thing which confused me was that 'monad' referred to different types. Sometimes it was used for a parametrized type (like 'IO a'), something it was used for a tuple consisting of a type, the bind function and the return function - and sometimes people talked about a "monadic" interface but a library had totally different names for thigns (but in principle, they do the same job of 'building computation'
07:09:23 <frerich2>  and 'running computation, build new computation using some custom function').
07:09:43 <frerich2> Actually, now I finally realize why the second argument of >>= has a signature much like return.
07:10:11 <Cale> frerich2: The term "monad" always refers to the type constructor
07:10:13 <Cale> IO is a monad
07:10:17 <Cale> Maybe is a monad
07:10:21 <Cale> getLine is not a monad
07:10:26 <Cale> Just 5 is not a monad
07:10:38 <Cale> IO Integer isn't even a monad, really
07:10:43 <Cale> But it's a monadic type, if you want
07:13:06 <frerich2> Hmm, actually, if I have a function 'f :: MyFancyMonad ()' in something like 'f >>= \_ -> error "foo"', can Haskell tell that the computation produced by 'f' doesn't need to be executed since its result is not evaluated by the function which should yield a new computation?
07:13:14 * frerich2 hopes he got his 'evaluate' vs. 'execute' terminology right
07:13:34 <ski> > Nothing >>= \_ -> error "foo"
07:13:35 <lambdabot>   Nothing
07:13:56 <ski> > Just 2 >>= \_ -> error "foo"
07:13:57 <lambdabot>   *Exception: foo
07:13:58 <Cale> frerich2: f probably shouldn't be called a function
07:14:04 <Cale> (because it has no parameter)
07:14:05 <dylukes> I just came up with a terrible monad analogy involving rear-ends and AIDS
07:14:10 <frerich2> Cale: Ok, true
07:14:15 <dylukes> I'm not going to elaborate. Use your imagination.
07:14:16 <mauke> frerich2: it does need to be executed
07:14:31 <mauke> it may have "effects" within MyFancyMonad
07:14:31 <ski> frerich2 : `f' will need to be executed. in some cases it doesn't need to be evaluated, though
07:15:08 <frerich2> Hm, I see.
07:15:18 <Cale> f is a computation, it doesn't produce one :)
07:15:27 <ski> > runIdentity (undefined >> return 0)  -- zygoloid's example
07:15:29 <lambdabot>   0
07:15:39 <Cale> The result of a computation in general is not the most important thing about it
07:15:47 <companion_cube> omg dylukes, please do not write a tutorial
07:15:48 <Cale> It's only part of what the computation is
07:16:04 <mauke> > (Nothing >>= \_ -> error "foo")
07:16:04 <lambdabot>   Nothing
07:16:31 <Cale> frerich2: But of course, it depends on which monad we're talking about
07:16:31 <frerich2> Cale: Yes, makes sense.
07:16:41 <Cale> frerich2: (>>=) will have a different implementation in each case
07:16:56 <bmm> I can't get CHP examples to work because chp-plus won't install. What do you guys use for concurrency?
07:16:58 <ski> @src Identity (>>=)
07:16:59 <lambdabot> m >>= k  = k (runIdentity m)
07:17:03 <ski> @src Identity
07:17:04 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
07:17:15 <frerich2> So, in short, Haskell always *has to* execute computations since it cannot possibly tell what side-effects they may have, but it *may* decide not to evaluate the result?
07:17:16 <Cale> But in IO, for example, we can't just not run getLine if we're ignoring its result, since the effect of asking the user for input is still important.
07:17:26 <Cale> yeah
07:17:31 <frerich2> I see.
07:17:48 <frerich2> So a monad has more language support than I thought, I though tit's just a library-level thing.
07:17:50 <Cale> What evaluation will have to happen depends on the monad in particular, and the implementation of these primitives.
07:17:59 <Cale> It is just a library level thing.
07:18:05 <ski> in `Identity' there is nothing else but returning the result, so if we ignore the result, we don't have to evaluate the action
07:18:35 <Cale> We can't really say anything much about what gets evaluated in general, since the implementation of >>= and return will be different for every monad.
07:18:46 <ski> frerich2 : the language support is the `do'-syntax, which is syntactic sugar over `(>>=)',`(>>)' and `fail'
07:19:11 <frerich2> Cale, ski: I greatly appreciate your patience though, feel free to start calling me things in case you're running out of it.
07:19:18 <mauke> bmm: threads
07:19:21 <Cale> But 99.9% of the time, >>= will not ignore its first parameter, even if the function it gets ignores its argument
07:19:40 <Cale> (but there are exceptions to this, as people pointed out)
07:19:44 <ski> frerich2 : there's also some implementation support for things like `IO' and `ST' which isn't implemented in Haskell only
07:20:03 <mauke> frerich2: Haskell doesn't even know what "computations" are
07:20:10 <mauke> that's a man-made term
07:20:21 <ski> *nod*
07:20:45 <geheimdienst> ... as opposed to haskell, which was passed to us from alien space ant goddesses
07:21:00 <mauke> all hail
07:21:12 <ski> (.. wasn't it a giant beetle ?)
07:21:24 <mauke> <Spance> monads mo problems
07:21:50 <frerich2> mauke: Is there a quasi-standard name for the value produced by 'return'? Computation? Action? Command?
07:22:07 <ziman> "a monadic value", maybe?
07:22:07 <dankna> I thought it had five eyes.  Or was that Lisp?
07:22:17 <bmm> mauke: with MVars to communicate (I want to broadcast IO over multiple threads)
07:22:20 <Cale> frerich2: I've been using the term computation or action
07:22:20 <bmm> ?
07:22:24 <ski> "computation" and "action" are common words for values of type `m a', with `m' being a monad
07:22:52 <companion_cube> bmm, you can use chans to broadcast stuff
07:22:59 <geheimdienst> ski: alien space ant goddesses, i say! with exoctic names like quessoonia, biitaaya, and simon!
07:23:04 <companion_cube> with dupChan
07:23:20 <dankna> simon is a very exotic name indeed
07:23:30 <mauke> frerich2: "action" is relatively common; some people like "mote"
07:23:36 <kmc> :t (>>= return)
07:23:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
07:23:43 <frerich2> dir
07:23:45 <frerich2> sorry.
07:24:13 <Cale> Where "some people" is maybe 5 people :)
07:25:02 <kmc> i talk about "IO actions" but the metaphor becomes less useful in some other monads
07:25:06 <kmc> is "Nothing" a "Maybe action"?
07:25:09 <ski> yes
07:25:11 <Cale> I guess so :)
07:25:21 <Cale> I would say it is, yeah
07:25:24 <kmc> IO is an unusual monad in several ways
07:25:43 <copumpkin> I dare someone to prove it's a monad
07:25:47 <kmc> and its unusual properties would remain even if we interfaced to it by special-purpose functions, rather than the generic Monad API
07:26:13 <kmc> bbl
07:29:49 <ski> (.. compare `seq undefined ()' and `seq (undefined >>= return) ()' in `IO' e.g.)
07:31:06 <ski> > do s <- ["abc","de","ef"]; "<" `mplus` s `mplus` ">\n"
07:31:08 <lambdabot>   "<abc>\n<de>\n<ef>\n"
07:36:09 <matthiasgorgens> Hi.  I am writing a utility that will among other things download large files.  Is curl the right package to use?
07:36:16 <matthiasgorgens> (the memory footprint should still be small.)
07:36:33 <matthiasgorgens> (or smallish, i.e. it should not scale with the size of the files to be downloaded.)
07:43:27 <mm_freak_> matthiasgorgens: from the interface the curl package doesn't seem to be a good option there, because it uses String
07:44:03 <matthiasgorgens> mm_freak_, it seems like you can give curl some kind of buffer to write to, instead of a string.
07:44:37 <mm_freak_> couldn't find that
07:44:48 <mm_freak_> but there is the http-enumerator library, which is probably a better choice
07:45:50 <matthiasgorgens> mm_freak_, I'll have a look at http-enumerator.  thanks.
07:46:17 <matthiasgorgens> mm_freak_, i do know that the command-line curl is able to do the right thing, so i was hoping for the haskell bindings to be fine as well.
07:50:15 <mm_freak_> matthiasgorgens: in general if you need high performance I/O in haskell and you see a String-based interface, it should make you very sceptical…  usually you would use a ByteString or Text interface together with a good I/O design pattern like iteratees
07:51:04 <matthiasgorgens> mm_freak_, yes, I know. :o)  And I also hope that overloadable string literal will make it into the standard some day.
07:58:41 <matthiasgorgens> mm_freak_, i found that it's possible (and already supported) to use curl with (lazy) bytestrings.
07:59:33 <mm_freak_> matthiasgorgens: if the semantics of lazy bytestrings suffice for you, then that's probably fine
08:06:41 <matthiasgorgens> mm_freak_, i found a way to use curl. :o)
08:06:50 <matthiasgorgens> mm_freak_, now I just have to verify that the memory usage is indeed low.
08:07:50 <buntfalke> Hi
08:08:02 <buntfalke> Is there a "evaluate small expressions"-bot here?
08:08:17 <sipa> > 5*3
08:08:17 <lambdabot>   15
08:08:22 <buntfalke> thanks ;-)
08:08:31 <tromp> > map succ "HAL"
08:08:32 <lambdabot>   "IBM"
08:08:37 <buntfalke> hehe
08:09:16 * hackagebot RBTree 0.0.5 - Pure haskell Red-Black-Tree implemetation  http://hackage.haskell.org/package/RBTree-0.0.5 (XingboWu)
08:10:01 <sipa> > let f = 1:1:zipWith (+) (tail f) f in take 10 f
08:10:03 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
08:10:39 <benmachine> > let f = 0 : scanl (+) 1 f in take 10 f
08:10:40 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
08:10:43 <mm_freak_> matthiasgorgens: go ahead =)
08:11:11 <mm_freak_> buntfalke: if you want to make some lengthy tests, you can also talk to lambdabot in query
08:12:33 <ion> > text $ map succ "à"
08:12:34 <lambdabot>   b
08:12:48 <ion> > text "à" --huh?
08:12:49 <lambdabot>   a
08:12:55 <ion> mkay
08:13:24 <mauke> > st 1
08:13:26 <lambdabot>   "1st"
08:13:36 <buntfalke> mm_freak_: ooh, I see. I forgot the ">" when in query. thanks! :-) (I use "[date] <nick>: Actual message" as IRC line-format and missed the extra > that way...)
08:14:09 <buntfalke> ion: Why is that? Why does it silently unaccent the letter?
08:14:43 <ion> Probably some encoding issue.
08:15:05 <mm_freak_> > fix (\x y -> (y:) . liftA2 x id (+y)) 0 1
08:15:07 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:15:16 <dolio> > "à"
08:15:17 <lambdabot>   "a\768"
08:15:59 <buntfalke> yes, maybe utf8 multibyte chars break somehow
08:16:20 <mauke> > text "à"
08:16:21 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
08:16:30 <mauke> > text "̀"
08:16:31 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
08:16:35 <dolio> > map succ "à"
08:16:36 <lambdabot>   "b\769"
08:16:54 <benmachine> liftA2 x id (+y) = pure x <$> id <*> (+y) = pure x . id <*> (+y) = pure x <*> (+y) = x . (+y)
08:16:58 <benmachine> or am I missing something
08:17:31 <mauke> yes, duplication
08:17:41 <mm_freak_> > fix (\x y -> liftA2 (.) (:) (liftA2 x id . (+))) 0 1
08:17:42 <lambdabot>   Couldn't match expected type `[a]' against inferred type `a -> [a]'
08:17:46 <mm_freak_> > fix (\x -> liftA2 (.) (:) (liftA2 x id . (+))) 0 1
08:17:47 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:18:16 <mauke> http://mauke.dyndns.org/tmp/flow.png
08:18:40 <benmachine> mauke: yes but pure x <*> (+y) = x <$> (+y)
08:18:40 <dolio> liftA2 x id (+y) = liftA2 x ask (+y)
08:19:06 <benmachine> oh
08:19:15 <benmachine> yes that makes sense
08:19:19 * benmachine wonders where he went wrong
08:19:28 <benmachine> oh silly me
08:19:34 <benmachine> pure x <*> id <*> (+y)
08:19:46 <benmachine> not <$>
08:20:00 <mauke> :t \x y -> liftA2 x id (+y)
08:20:01 <lambdabot> forall a c. (Num a) => (a -> a -> c) -> a -> a -> c
08:20:02 <benmachine> i.e. x <*> (+y)
08:20:12 <mauke> yes
08:20:40 <mm_freak_> > fix (\x -> (.) <$> (:) <*> (.) (liftA2 x id) (+)) 0 1
08:20:42 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:20:45 <mm_freak_> symbol salad fibs =)
08:20:58 <mauke> needs more <*>
08:21:33 <mauke> > fix (\x -> (.) <$> (:) <*> (.) (x <*>) (+)) 0 1
08:21:34 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:21:52 <buntfalke> > 'a' == ['a', 'e', 'i', 'o', 'u']
08:21:53 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
08:21:53 <lambdabot>         against inferred type...
08:21:59 <mauke> > fix (\($) -> (.) <$> (:) <*> (.) (($) <*>) (+)) 0 1
08:22:00 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:22:25 <Jafet> @pl \x -> (.) <$> (:) <*> (.) (x <*>) (+)
08:22:25 <lambdabot> ((.) <$>) . ((:) <*>) . (. (+)) . (<*>)
08:22:27 <mauke> > fix (\($) -> (.) (.) (:) <*> (.) (($) <*>) (+)) 0 1
08:22:29 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:22:40 <mm_freak_> wonderful
08:22:44 <benmachine> delightful
08:22:46 <benmachine> full marks
08:22:49 <mauke> > fix (\($) -> (.) (.) (:) <*> (.) ((<*>) ($)) (+)) 0 1
08:22:50 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:22:59 <mm_freak_> lol
08:23:27 <mm_freak_> the latest in obscurity
08:23:34 <buntfalke> hehe
08:23:38 <mauke> > fix (\($)->(.)(.)(:)<*>(.)((<*>)($))(+)) 0 1
08:23:39 <mm_freak_> you don't understand it, even if you de-obscure it =)
08:23:40 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:23:52 <mm_freak_> let's do something great
08:23:54 <Jafet> @faq can Haskell run perl?
08:23:54 <lambdabot> The answer is: Yes! Haskell can do that.
08:23:58 <erus`> whats the mapIO function again?
08:24:00 <dbpatterson> is there any way to parse MM.DD.YYYY with Data.Time.Format (from the time package) with NO padding? Every field I can find for month (%m) and day (%d, %e) has padding, with either zeros or spaces…
08:24:14 <mauke> Jafet: http://mauke.dyndns.org/stuff/haskell/yes.hs
08:24:15 <erus`> like map (putStrLn show) [1..]
08:24:23 <mauke> erus`: mapM_ print
08:24:24 <mm_freak_> > fix (\($) -> fmap fmap (:) <*> fmap ((<*>) ($)) (+)) 0 1
08:24:25 <dbpatterson> ie, I want to be able to parse 6.9.2011
08:24:25 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:25:24 <mm_freak_> dbpatterson: IIRC the padding is optional for parsing…  try it out
08:25:55 <dbpatterson> mm_freak_:  unfortunately it is not
08:26:26 <dbpatterson> i can get "05. 6.2011" to parse with "%m.%e.%Y" but even removing that space doesnt work
08:27:14 <mm_freak_> dbpatterson: see the glibc-style modifiers
08:27:39 <mm_freak_> dbpatterson: %-m.%-d.%Y
08:27:50 <dbpatterson> again, would think it would work, but it doesnt, parseTime defaultTimeLocale "%m.%-e.%Y" "05.1.2011" yields Nothing
08:28:25 <dbpatterson> results in Nothing :(
08:28:29 <mm_freak_> ok, then i don't know
08:28:53 <mm_freak_> tell your users that they have to use spaces or zeroes for type safety =)
08:29:32 <Jafet> Get less american users
08:29:43 <kamaji> fewer
08:29:51 <Jafet> That also works
08:29:56 <kamaji> OH GOD I HATE MYSELF
08:30:33 <mauke> get users that are less american
08:30:37 <mm_freak_> "the latest security feature is that you have to use proper padding in your dates, because otherwise the existential hypermatrix family would overflow scoped type variables into dark matter"
08:31:03 <kamaji> that sounds serious
08:31:06 <dbpatterson> hmm.. does anyone actually use the time package's parsing? Because the formatting code can result in an unparseable date, which seems like something that is very broken.
08:31:37 <dbpatterson> ie, formatTime defaultTimeLocale "%-m.%-d.%Y" yields something without padding, which as far as I can tell, is now unparseable.
08:31:38 <mm_freak_> i think yesod uses it for date/time fields in forms
08:32:10 <mm_freak_> actually i've seen that happen and didn't relate it to padding
08:32:21 <mm_freak_> you could preprocess the string before passing it to the date parser
08:32:42 <dbpatterson> mm_freak_: yeah, I probabl will have hto. but that sounds like a broken parser :)
08:33:50 <mm_freak_> dbpatterson: i was in fear that there were no problems, when you use haskell…  now i'm relieved =)
08:34:03 <k0ral> anyone would know why readProcess "xclip -o" [] [] fails ?
08:34:18 <benmachine> k0ral: fails in what sense
08:34:39 <k0ral> instead of returning the content of clipboard, it prints (exit 127): failed
08:34:44 <ion> :t readProcess
08:34:46 <lambdabot> Not in scope: `readProcess'
08:34:51 <ion> @hoogle readProcess
08:34:51 <lambdabot> No results found
08:35:13 <benmachine> I thought xsel was the one that printed your clipboard
08:35:29 <ion>   :: FilePath -> [String] -> String -> IO String
08:35:38 <monochrom> perhaps xclip does not exist
08:35:47 <ion> Try readProcess "xclip" ["-o"] []
08:36:00 <benmachine> that does sound more likely
08:36:02 <k0ral> ion: I'm so ashamed
08:36:38 <ion> xsel is generally better, btw. xclip seems to have encoding issues.
08:36:43 <k0ral> ion: but stil doesn't work with same error output
08:36:58 <benmachine> k0ral: does xclip definitely work in a normal shell?
08:36:59 <k0ral> well, let's go replacing xclip with xsel
08:37:04 <k0ral> benmachine: yes it does
08:37:09 <benmachine> oh
08:37:12 <benmachine> hm
08:37:31 <benmachine> 127 does seem to be "command not found" error
08:37:47 <benmachine> try with the full path to xclip? (which xclip)
08:37:57 <k0ral> ohhhh
08:38:03 <k0ral> :D that's funny
08:38:14 <k0ral> haha
08:38:18 <k0ral> actually
08:38:27 <k0ral> using ["-o"] works
08:38:39 <k0ral> but since my last selection was the error code to paste it here
08:38:44 <benmachine> haha
08:38:45 <k0ral> it printed it :D
08:38:49 <benmachine> :P
08:39:23 <k0ral> thank you guys
08:40:14 <monochrom> haha that was tricky
08:41:37 <NemesisD> anyone got any experience with the warp server? i'm trying to determine if it's a good choice for concurrent connections
08:42:04 <monochrom> the warp server? the os/2 warp server?
08:42:28 <NemesisD> Network.Wai.Handler.Warp
08:45:41 * hackagebot comonad-transformers 1.7 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.7 (EdwardKmett)
08:48:42 * hackagebot comonads-fd 1.7 - Comonad transformers using functional dependencies  http://hackage.haskell.org/package/comonads-fd-1.7 (EdwardKmett)
08:48:44 * hackagebot keys 0.3.0 - Keyed functors and containers  http://hackage.haskell.org/package/keys-0.3.0 (EdwardKmett)
08:49:19 <NemesisD> found a paper by Snoyman himself, looks like it uses threads to achieve high concurrency
08:50:42 * hackagebot representable-functors 0.5.0 - Representable functors  http://hackage.haskell.org/package/representable-functors-0.5.0 (EdwardKmett)
08:51:42 * hackagebot adjunctions 1.0.0 - Adjunctions  http://hackage.haskell.org/package/adjunctions-1.0.0 (EdwardKmett)
08:54:42 * hackagebot representable-tries 0.5.0 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-0.5.0 (EdwardKmett)
08:55:05 <tgeeky> someone's been busy
08:56:22 <edwardk> slow day
08:56:40 <edwardk> folded free and cofree into comonad-transformers
08:57:10 <tgeeky> edwardk: yeah... I took a look at all of the packages you have on hackage this morning, and I decided that I should revisit them later for sake of my brain not exploding
08:58:12 <edwardk> hahaha
08:58:32 <tgeeky> edwardk: I did appreciate your lecture on lenses, though. Did I hear correctly that you delivered it with little to no sleep?
08:59:17 <edwardk> i was a bit sleepy by then, as it was the last talk of the night
08:59:27 <tgeeky> oh, ok
08:59:28 <edwardk> and yeah i hadn't really slept the night before
08:59:41 <tgeeky> did pretty well either way
08:59:45 <edwardk> thanks =)
09:00:24 <k0ral> hmm, if "xclip -o" returns an empty string, readProcess waits forever
09:00:36 <k0ral> how could I fix it ?
09:01:58 <benmachine> k0ral: that's odd.
09:02:51 <benmachine> k0ral: does the xclip process normally terminate in that case?
09:03:16 <benmachine> k0ral: I don't have xclip so I can't test, but for me e.g. running "echo" ["-n"] returns an empty string
09:03:18 <joe6> anyone aware of a haskell call graph lister for assembly code?
09:03:20 <benmachine> immediately
09:03:43 * hackagebot kan-extensions 0.5.0 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-0.5.0 (EdwardKmett)
09:03:47 <joe6> or, any suggestions on which library could be a best fit for something like that?
09:04:16 <k0ral> benmachine: I may be wrong, actually it just doesn't work anymore for any string while it worked 5 minutes ago, I may have broken something, forget my question
09:05:09 <joe6> i mean the graphing library that can be used as a backend for such "call graph lister"?
09:05:44 * hackagebot comonad-extras 0.3.0 - Comonad transformers requiring extensions to Haskell 98  http://hackage.haskell.org/package/comonad-extras-0.3.0 (EdwardKmett)
09:05:45 <tgeeky> trying to install [cairo] from hackage, I got pkg-config, where do I get cpp?
09:06:01 <tgeeky> (on Windows :( )
09:06:35 <k0ral> benmachine: how do you know the meaning of error codes ? now i have (exit 2): failed
09:07:01 <tgeeky> i guess i don't have the full mingw
09:07:14 <benmachine> k0ral: I knew 127 = command not found because I guessed, and then ran a command that didn't exist, and then checked what error code it returned
09:07:27 <benmachine> k0ral: error 2 sounds like it might be coming from xclip itself, maybe check the man page
09:07:35 <k0ral> I checked
09:07:44 * hackagebot pointed 0.1.4 - Haskell 98 Pointed and copointed data  http://hackage.haskell.org/package/pointed-0.1.4 (EdwardKmett)
09:08:06 <benmachine> k0ral: well tbh I'm only guessing :)
09:08:28 <benmachine> edwardk: so what's the point of data-default?
09:08:37 <benmachine> I am personally of the view that there is none
09:09:08 <ion> > fix (liftM2(.)(:).(.(+)).ap) 0 1
09:09:10 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
09:09:13 <mauke> it's good for records
09:09:51 <edwardk> ben-machine: pointed for non-functor-like things basically. i don't like it (or Pointed)
09:09:53 <sipa> ion: that's the least readable fib i've ever seen :)
09:09:56 <tgeeky> @oeis 0 1 1 2 3 5 8 13 21 34 55 89
09:09:57 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.
09:09:57 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:10:02 <tgeeky> shame on me.
09:10:05 <edwardk> but sometimes you need it (if you want to make things that are Pointed)
09:10:10 <Jafet> @quote undoubtedly
09:10:11 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
09:10:33 <benmachine> edwardk: hmm. some of the instances are kind of silly
09:10:42 <Jafet> I think Default is useful, if only to get everyone to write its instances only once
09:10:46 <sipa> what is the kind of silly?
09:10:46 <djahandarie> I like Pointed
09:10:46 <edwardk> i haven't looked at it lately
09:10:48 <sipa> * -> * ?
09:11:04 <edwardk> jafet: yeah
09:11:13 <benmachine> Jafet: why would you need a type class that did that, though?
09:11:16 <Jafet> ?? -> ?? -> ?!
09:11:16 <lambdabot> Plugin `compose' failed with: Unknown command: "!"
09:11:18 <benmachine> what do you use it for
09:11:22 <ion> I like data-default.
09:11:51 <benmachine> ion: why
09:12:00 <Jafet> I had a use for it once, but didn't feel like importing it, so I wrote it myself. I don't remember the application though
09:12:09 <ion> If only everything had a Default instance. One tends to need to have a bunch of orphan instances to take advantage of it.
09:12:28 <benmachine> ion: but what *for*? what makes a certain value of a type the 'default' value?
09:12:32 <djahandarie> Orphans. :<
09:12:34 <benmachine> why is 0 more default than 1?
09:12:42 <mauke> benmachine: because it's in the middle
09:12:42 <djahandarie> @quote djahandarie orphan
09:12:43 <lambdabot> No quotes match. It can only be attributed to human error.
09:12:43 <edwardk> benmachine: consider trying to make a Pointed instance for (,) e — you need a default value for e
09:12:47 <djahandarie> Aw, was never added
09:12:59 <edwardk> benmachine: you don't need any LAWS for it, because Pointed is kinda silly like that, just an e.
09:13:05 <benmachine> edwardk: well, I could argue about the point of Pointed, too :P
09:13:16 <edwardk> benmachine: as do i ;)
09:13:28 <edwardk> but as long as people persist in wanting that you need data-default
09:13:34 <benmachine> mauke: it isn't, there are more negative numbers than positive ones :P
09:13:42 <mauke> benmachine: not in Integer
09:14:00 <benmachine> mauke: sure there are! look, I can pair every negative integer with two positive ones
09:14:04 <benmachine> QED
09:14:05 <edwardk> benmachine: as for why its more important i tend to use the argument that data-default should be compatible with the mempty of the Monoid for a given type
09:14:16 <edwardk> ben-machine: it being 0
09:14:28 <benmachine> edwardk: well, except that 1 is a mempty too :)
09:14:30 <Jafet> benmachine: it was a generalized zero for tuples, and the alternative was making pairs an instance of Num
09:14:35 <dolio> That proof is backwards.
09:14:38 <zygoloid> there is no Monoid instance for Int
09:14:45 <tgeeky> benmachine: the number of imginary quadratic fields with class number 1 to the number of integers
09:14:50 <benmachine> zygoloid: indeed, and for good reason
09:14:50 <edwardk> benmachine: yes, but you don't usually get unallocated memory from the operating system initialized to 1s ;)
09:14:51 <tgeeky> s/the/compare the/
09:14:52 <Jafet> There are too many Monoid instances for Int
09:15:04 <zygoloid> benmachine: exactly
09:15:16 <benmachine> edwardk: you don't usually get unallocated memory from the operating system :P
09:15:23 <Jafet> (Two many?)
09:15:25 <benmachine> unless you're programming in something awful called C
09:15:31 <ion> It’s just a pattern that happens a lot: you need a construct a value with sensible defaults for the fields. For instance, a State variable that has a counter (integer, should start at 0, right?), a list for accumulating something (should start at []) and, say, a map for finding duplicates in whatever’s being worked on (should start at M.empty). instance Default MyState where def = MyState def def def
09:15:36 <Jafet> And on an awful operating system
09:15:51 <dolio> There are more than two.
09:15:51 <ion> runState f def
09:15:54 <benmachine> ion: but the defaults for the fields are not a property of the type; they depend on context
09:15:54 <mauke> or you have a config record
09:16:05 <Jafet> benmachine: context saves typing
09:16:10 <mauke> one that users override some fields of
09:16:20 <benmachine> mauke: then I'd have defaultConfigRecord
09:16:22 <Jafet> If you know what context it is, which classes require you to know, anyway.
09:16:22 <benmachine> as a value
09:16:26 <mauke> doStuff def{ withCherry = True }
09:16:30 <mauke> benmachine: yeah, and that's silly
09:16:32 <benmachine> Jafet: I think you're misunderstanding me
09:16:34 <ion> It seems to me that the defaults match most situations.
09:16:38 <mauke> I don't want to type defaultConfigRecord every time
09:16:49 <Jafet> I'm not. Saving typing is more important than you might think
09:16:51 <dolio> (+) (*) min, max, (.&.), (.|.), xor, ...
09:16:55 <ion> If they don’t match yours, well, do def = MyState 1 def def, or use a newtype, or whatever.
09:17:08 <benmachine> so we're using type classes *purely* as name overloading in this case?
09:17:11 <zygoloid> ion: but what about a state that accumulates a product (integer, should start at 1, right?), a list of candidate naturals (should start at [1..], right?), ...
09:17:22 <edwardk> benmachine: yes.
09:17:27 <mauke> zygoloid: well, then you're weird and shouldn't use def
09:17:34 <benmachine> well, humbug :P
09:17:38 <joe6> anyone used fgl (functional graph library)? i am trying to build an asm call tree listing and am wondering if that would be a good fit?
09:17:44 <dolio> Type classes are name overloading.
09:17:46 <Jafet> All uses of type classes are name overloading
09:17:53 <zygoloid> it's fair to argue that 0 and [] are more common default values, but they're not canonical.
09:17:54 <benmachine> too much polymorphism makes ben grumpy
09:17:57 <Jafet> And context saves typing.
09:18:00 <edwardk> no laws for you
09:18:19 <Jafet> More arbitrary than Arbitrary!
09:18:32 <benmachine> Jafet: well, often there's a common idea, too; I don't really feel like there's any consistent semantics to a def value
09:18:47 <benmachine> any consistent meaning
09:19:09 <mauke> the semantics is: what is the intuitively obvious default value for this type?
09:19:23 <zygoloid> benmachine: sampled across a large corpus of program executions, what value is most likely to be in an object of this type? ;p
09:19:34 <benmachine> I think that's silly
09:19:45 <Jafet> Then don't use Default
09:19:46 <benmachine> and edwardk if you don't like it I think you are encouraging it by using it
09:19:48 * hackagebot recursion-schemes 0.5.0 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-0.5.0 (EdwardKmett)
09:19:55 <edwardk> benmachine: i only import it to define Pointed instances
09:20:01 <ion> jafet: You do not understand. They’re making him use it on gunpoint.
09:20:07 <edwardk> and i don't define Pointed instances in my main packages, only in the pointed package
09:20:07 <benmachine> edwardk: you use it in a different package as well
09:20:12 <benmachine> data-tagged I think?
09:20:17 <Jafet> That coercion sounds unsafe
09:20:22 <benmachine> tagged
09:20:27 <edwardk> only when i'm going to need it for Pointed instances, elsewhere or it would require me to give orphans elsewhere
09:20:39 <benmachine> ion: well, if I only ever read my own code I wouldn't get much done :)
09:20:58 <edwardk> there is a reasonable choice of 'def' for Proxy. as their is only one choice ;)
09:21:19 <benmachine> edwardk: well, but that makes it even more worthless, since you can just write Proxy in that case
09:21:26 * copumpkin changes his last name to Kan
09:21:26 <benmachine> which is a whopping 2 extra characters :P
09:21:28 <copumpkin> for epic confusion
09:21:33 <edwardk> benmachine: yes, if you are monomorphic ;)
09:21:37 <mauke> benmachine: and a shift key
09:21:45 <djahandarie> copumpkin extension
09:21:46 <ion> Kaaaaaaaaaaaaaan
09:21:56 <benmachine> edwardk: don't polymorphic values of Proxy kind of defeat the point :P
09:22:04 <edwardk> it is a useless class, but its occasionally marginally useful when defining other slightly less useless classes
09:22:05 <ion> @hoogle Proxy
09:22:06 <lambdabot> Network.Browser data Proxy
09:22:06 <lambdabot> Network.Browser Proxy :: String -> Maybe Authority -> Proxy
09:22:06 <lambdabot> Network.Browser getProxy :: BrowserAction t Proxy
09:22:13 * dolio also changes his last name to Kan.
09:22:21 <benmachine> edwardk: anyway, some guy the other day said he thought tagged would be useful but didn't like the extra dependencies, which is what got me on the issue
09:22:27 <edwardk> *shrug*
09:22:33 <edwardk> i've fought this battle before.
09:22:40 <copumpkin> dolio: man, that'd be even more confusing
09:22:43 <mauke> heaters gonna heat
09:22:49 <benmachine> copumpkin: I like your last name :(
09:22:50 <dolio> Two Daniel Kans at work.
09:22:52 <edwardk> i can force other people to have orphans, or i can add dependencies to tagged.
09:22:59 <edwardk> i hate orphans more than i hate a few extra dependencies
09:23:11 <copumpkin> benmachine: thanks :) but Kan is more hardcore-sounding
09:23:12 <edwardk> sorry orphans
09:23:16 <benmachine> edwardk: well, or people could just not use the class, then there'd be no orphans :P
09:23:18 <copumpkin> and I'm really hardcore
09:23:28 <dolio> Maybe I could be Daniel Khan. That'd clear things up.
09:23:28 <mauke> or I could move the instances to data-default, but then I'd have to depend on tagged
09:23:31 <benmachine> copumpkin: well, move the current one into a middle name or something
09:23:46 <edwardk> benmachine: not for default. i mean the instances for containers in tagged, etc.
09:23:54 <ion> I need a Default instance for Bool and DList
09:24:17 <mauke> didn't I define one for Bool?
09:24:19 <benmachine> edwardk: well, yes, in general that's fair, I'm not advicating zero dependencies, just advocating disposing of ones that don't help much
09:24:25 <edwardk> what i have is a solution that converged on the fewest number of orphan instances, so i'm sorry if it makes someone not use the package
09:24:33 <edwardk> but ultimately that is where it landed in the hierarchy
09:24:38 <ion> Let’s see, i may have an old version of Default.
09:24:45 <mauke> doesn't look like it
09:24:53 <edwardk> yes, but you aren't going to win me over to killing the dependency on data-default. otherwise some of the Pointed instances pick up needless Monoid constraints.
09:25:08 <zygoloid> what would the default bool be?
09:25:12 <mauke> False
09:25:25 <copumpkin> do you have a Default () ?
09:25:29 <mauke> of course
09:25:31 <copumpkin> yay
09:25:59 <ion> > toEnum def :: Bool
09:26:00 <lambdabot>   Not in scope: `def'
09:26:15 <benmachine> edwardk: oh, as you wish. I think Monoid constraints are more useful than Default constraints, but if you've already had the argument I can't imagine I'm telling you anything new
09:26:21 <edwardk> anyways, the weight of having data-default which has dependencies that precisely overlap those of tagged as a dependency of tagged is pretty slight ;)
09:26:24 <ski> `Default Void' ?
09:26:36 <edwardk> ski: nope
09:26:40 <mauke> benmachine: how is a Monoid constraint "more useful" if you're never going to call mappend?
09:26:48 <ski> `Default (IORef AnythingYouLike)' ?
09:27:02 <edwardk> ski: i don't give you instances for void for anything where the Void type appears in positive position
09:27:05 <mauke> ski: that sounds extremely unsafe
09:27:17 <benmachine> mauke: you might want to call mappend? how is a Default constraint useful if you can't do anythign in particular with the value?
09:27:36 <edwardk> (unless you must also supply it in negative position)
09:27:44 <mauke> it imposes no additional constraints
09:27:46 <edwardk> in which case i can hand you your void back
09:27:55 <benmachine> mauke: but it also provides no information
09:28:08 <mauke> so?
09:28:29 <benmachine> so what's the use?
09:28:52 <mauke> this is going nowhere
09:28:58 <benmachine> probably you are right
09:29:01 <mauke> you call whatever, you provide the answer
09:29:08 <mauke> answer? I mean instance
09:29:41 <benmachine> I'm not sure whether I disagree with you about how classes should be used, or if you're jsut scratching an itch I've never happened across
09:32:35 <benmachine> I should totally get a blog, they're useful for complaining
09:32:47 <ski> (mauke : i'm not sure the `IORef' one would be unsafe .. but probably not useful)
09:33:05 * ski thought IRC was for complaining
09:33:35 <elliottt> ezyang: are you around?
09:33:49 * hackagebot streams 0.8.0 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-0.8.0 (EdwardKmett)
09:34:21 <ezyang> elliottt: Yo!
09:34:28 <mauke> ski: what would the instance look like?
09:34:55 <edwardk> ski: the problem with the IORef one is that it isn't referentially transparent. def /= def
09:34:57 <elliottt> yay!
09:35:11 <elliottt> ezyang: we've finally put in for approval to make abcbridge an open source project
09:35:21 <elliottt> not sure when it'll happen, but i wanted to give you the heads up :)
09:35:22 <ezyang> Yaaaaaay! :-D
09:35:23 <edwardk> but let x = def in x == x
09:35:49 * hackagebot representable-tries 0.5.0.1 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-0.5.0.1 (EdwardKmett)
09:35:51 * hackagebot recursion-schemes 0.5.0.1 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-0.5.0.1 (EdwardKmett)
09:36:35 <ski> mauke : `instance Default (IORef Foo) where def = myPreviouslyAcquiredIORefFoo'
09:36:56 <mauke> how are you going to acquire an IORef in the global scope?
09:37:02 <ski> magic
09:37:30 <ski> as soon as you've got one such, i don't see a problem
09:37:35 <edwardk> ski: even if you add the unsafePerformIO you're breaking referential transparency
09:37:45 <ski> (i'm assuming it's properly monomorphic, of course)
09:37:46 <Jafet> I tried once, never succeeded
09:38:05 <edwardk> you'd have to have some type-based lookup to access a dictionary of them to get it safely
09:38:13 <ski> edwardk : i don't see it. elaborate ?
09:38:19 <edwardk> def /= def
09:38:24 <ski> why not ?
09:38:39 <ski> surely any `IORef Foo' is equal to itself ?
09:38:58 <edwardk> for that, you need to be able to get one per type, rather than one per def.
09:39:01 <edwardk> which means you'd need
09:39:08 <edwardk> instance Typeable a => Default (IORef a)
09:39:15 <ski> i didn't talk about that
09:39:34 <ski> i talked about `Default (IORef AnythingYouLike)', no `forall's
09:39:51 <edwardk> ah
09:40:04 <ski> (with `AnythingYouLike' monomorphic .. i probably should have mentioned that explicitly)
09:40:27 <edwardk> then instance Default (IORef Foo) where def = unsafePerformIO newIORef {-# NOINLINE def #-} will probably work
09:40:31 <edwardk> ah
09:41:24 <edwardk> what a hideous instance ;)
09:41:53 <edwardk> okay. i think i've uploaded all the packages broken by folding free into comonad-transformers
09:42:19 <edwardk> @tell dcoutts could you deprecate my free package on hackage? I've folded it into comonad-transformers
09:42:20 <lambdabot> Consider it noted.
09:45:13 <ski> (fwiw, i think `Default' might be (very slightly) useful a class, but i would never make instances of it for `Integer' or `Bool', using `Any',`All',`Sum',`Product',&c. instead)
09:46:59 <edwardk> i believe for data-default to be useful, there should be instances for it for all Monoids
09:47:08 <edwardk> equal to the mempty of the Monoid
09:48:13 <ski> i wonder whether it'd be useful/good to have a way of specifying that certain types are not instances of certain classes ..
09:49:41 <chrisdone> Ciao λ-knights.
09:50:11 <copumpkin> chrisdone: ciao!
09:50:45 <chrisdone> ¿Come va?
09:52:04 <Veinor> ski: how so?
09:52:50 <ion> Ah, indeed: ‘instance Monoid a => Default a where def = mempty’ would make ‘DList a’ have the proper Default instance without Default having to depend on DList.
09:53:54 <mauke> edwardk: breaks for Maybe
09:54:04 <ski> Veinor : istr there being cases where we know there can't be a sensible instance
09:54:28 <Veinor> like Complex and Ord?
09:54:41 <edwardk> breaks?
09:54:41 <ski> Veinor : other (not as compelling) cases are when there's no preferred implementation (`Monoid Integer' e.g.)
09:54:47 <edwardk> oh
09:54:49 <edwardk> crap
09:55:42 <ski> if we think of specifying instances as writing more-or-less Prolog clauses (with some extra stuff), then it might be nice to add some negative information to some predicates
09:55:49 <edwardk> anyways, like i said before , i don't _like_ data-default. i just provide instances where it makes sense ;)
09:56:27 <ski> chrisdone : btw, you asked about cut in ##prolog some time ago -- is the confusion cleared up ?
09:56:53 <ion> Perhaps instance priorities, where the highest would be picked in case of overlapping instances.
09:57:12 <ski> Veinor : anyway, i don't know whether this is a useful idea .. just something to ponder, perhaps
09:57:17 <chrisdone> ski: Sure. I grok the concept. Thanks.
09:57:22 <Veinor> what'd the point me?
09:57:25 <Veinor> be
09:57:35 <chrisdone> Ah, it's ##prolog? I put #prolog on hpaste.
09:57:39 * chrisdone updates
09:57:54 <ski> it was #prolog up to maybe one or two years ago
09:58:21 <ski> freenode wanted double-hashes in exchange for giving ops (which noone had before)
09:58:24 <chrisdone> I assumed it was somehow official but I suppose that's not the case.
09:58:34 <chrisdone> Oh, heh.
09:58:56 <ion> What *is* the meaning of the double-hash thing in Freenode?
09:58:57 <edwardk> ski: yeah they did that when i rescued the ##logic channel
09:59:11 <edwardk> ion: ## is 'about' some abstract topic. # is about some concrete product
09:59:20 <edwardk> or in some sense officially endorsed
09:59:21 <ion> Ok, thanks.
09:59:25 <chrisdone> ion: It means an "about" channel, rather than official.
09:59:27 <edwardk> #math _should_ be ##math
09:59:29 <ski> edwardk : strangely they haven't done that with #constructive-math, though ..
09:59:38 <ben> If you have an open source project named foo, you get to file a request that #foo is handed over to you
09:59:52 <ski> (which was more or less recently registered)
09:59:55 <ben> and then wait for a couple of years, I guess
10:01:57 <mauke> edwardk: the Monoid thing makes complete sense
10:02:06 <mauke> I may upload a new version in the next days
10:02:37 <ski> edwardk : let's hope noone will remind freenode ops about that ..
10:02:53 <edwardk> ski" tey seem to enforce it lazily when you need something from them
10:02:59 <edwardk> er they
10:03:18 <ski> well, don't force the thunk !
10:03:49 * ski . o O ( `unsafeInterleaveIO' )
10:04:38 <mauke> *> (def, def) :: (Any, All)
10:04:38 <mauke> (Any {getAny = False},All {getAll = True})
10:04:39 <mauke> whee
10:04:55 <mauke> actually, make that def :: (Any, All)
10:05:03 <djahandarie> edwardk, careful, any non-Haskeller freenode staff might find that offensive ;)
10:05:27 * ski . o O ( to FD or not to FD, that is the question .. )
10:06:10 <ion> < zygoloid> ion: but what about a state that accumulates a product (integer, should start at 1, right?)
10:06:13 <ion> ghci> def :: Product Integer
10:06:16 <ion> Product {getProduct = 1}
10:06:32 <mm_freak_> does anyone know how to tell pandoc as which HTML elements the headers should be rendered?
10:06:32 <mauke> how did you know?
10:06:40 <mm_freak_> they seem to be hardcoded, which is quite unfortunate
10:07:02 <benmachine> mm_freak_: headers?
10:07:21 <monochrom> perhaps meaning <head> ... </head>
10:07:34 <mm_freak_> benmachine: section titles, sorry
10:07:35 <djahandarie> I imagine he means <h1> - <h5>
10:07:40 <mm_freak_> djahandarie: exactly
10:07:51 <mm_freak_> pandoc starts at <h1>, but i'd prefer it to start at <h3>
10:08:05 <ion> The hN tags are what’s wrong with HTML. :-P
10:08:08 <benmachine> ah. in markdown I imagine it's just a case of more #s
10:08:18 <benmachine> but if you're using latex or something I dunno
10:08:24 <mauke> should I add ByteString instances to Data.Default?
10:08:57 <benmachine> mauke: the only downside I see is an extra dependency, but I imagine everyone ever has bytestring installed
10:08:59 <mm_freak_> hmm
10:09:12 <dcoutts> edwardk: at the moment you need to ask Ross to mark it as deprecated, and pointing to the replacement
10:09:12 <lambdabot> dcoutts: You have 4 new messages. '/msg lambdabot @messages' to read them.
10:09:14 <benmachine> (albeit possibly at more than one version, which could get nasty)
10:09:15 <mauke> yeah, it's kinda backwards
10:10:03 <edwardk> dcoutts: no problem
10:10:03 <ion> mauke: Won’t def = mempty already handle ByteString?
10:10:19 <mauke> ion: I can't define that
10:10:32 <edwardk> dcoutts: i need to talk to him about mtl stuff anyways
10:10:55 <ion> mauke: How did you handle Any, All? By manually writing specific instances?
10:11:10 <mauke> yes
10:11:12 <ion> ok
10:11:14 <mm_freak_> so i guess the header elements are hardcoded
10:11:34 <ion> So, i still won’t have my Default (DList a). :-(
10:11:36 <mauke> ion: what you want would be instance (Monoid a) => Default a
10:11:43 <mauke> and that overlaps with EVERYTHING
10:11:47 <ion> yeah
10:12:05 <djahandarie> How about we just kill Default and use Monoid's mempty directly ;)
10:12:25 <edwardk> djahandarie: because if you just _want_ the Pointed you probably don't need the Monoid ;)
10:13:18 <mauke> djahandarie: because I can't write 'mempty' for 'return ()'
10:13:20 <benmachine> djahandarie: inorite :P
10:13:24 <edwardk> this is kind of the flipside of the argument that we don't need a semigroup type coz you can just use a Monoid everywhere
10:14:07 <benmachine> mauke: you *can* make IO () a monoid though :)
10:14:41 <benmachine> actually that was totally something I was going to do
10:14:50 <benmachine> submit a library proposal for an applicative f => f () newtype
10:15:31 <parcs> can the type inference system be improved to 'properly' handle class instances that are in the form of 'C a => T a' ?
10:16:05 <parcs> or is such a limitation intrinsic to type classes?
10:16:15 <mauke> parcs: that's a bit like asking if the runtime system can be improved to properly handle overlapping function definitions
10:16:35 * ski idly wonders whether this `DList a' is `a -> a' or something else
10:16:41 <monochrom> the answer to both is yes
10:19:15 * ski ignorantly thinks that `instance C0 a => C a' and `instance C1 a => C a' ought to be ok, as long as `C0' and `C1' are disjoint
10:19:51 <mauke> I see typeclasses as functions
10:20:17 <mauke> what you wrote is: C a = C0 a; C a = C1 a
10:20:43 <ski> i think of it more like `c(A) :- c0(A). c(A) :- c1(A).' (in Prolog syntax)
10:21:27 <benmachine> a thing that people like about haskell is import-safety, so that a program can't change meaning by adding imports (it can fail to compile, but can't compile to something else)
10:21:30 <ski> we want there to be at most one solution to `c(A)', to be able to determine which instance to use without having to specify it explicitly at the use
10:21:54 <ski> and that forces the disjointness of c0/1 and c1/1, for this to be ok
10:22:10 <benmachine> that's something that's broken by overlapping in general, but might be ok if the contexts are forced to be disjoint
10:22:18 <benmachine> it sounds a bit fragile though
10:24:31 <ski> (mauke : i'm not sure if you're familiar with logic programming. ask if the Prolog-cast of it was unclear)
10:24:49 <mauke> I'm not
10:25:18 <ski> benmachine : it could be that there's sensible considerations that would rule out what i'm wishing for .. i'm not sure about it, though
10:25:33 <benmachine> ski: agreed on both counts
10:26:00 <benmachine> well, I think that at the least, it does make things a bit more fragile, it makes new instances more likely to break your code
10:26:31 <benmachine> I'm also not sure how often disjoint constraint heads are actually what you want
10:27:53 <mauke> what if I have instance C T; instance (C a) => D a where x = 1; instance D T where x = 2; ?
10:28:31 <benmachine> mauke: sounds non-disjoint to me
10:28:39 <benmachine> but maybe I interpreted it wrong
10:28:54 <benmachine> (the proposal I mean)
10:29:03 <mauke> I don't have a C1
10:29:14 <mauke> how can it be joint?
10:29:46 <benmachine> mauke: inasmuch as there are two instances satisfied by T
10:30:14 <ski> (mauke : i'm interpreting "I'm not" as you not being familiar with logic programming)
10:30:24 <mauke> ski: indeed
10:30:38 <ski> mauke : consider a relation relating two lists to the concatenation of them : `append([    ],Bs,     Bs ). append([A|As],Bs,[A|AsBs]) :- append(As,Bs,AsBs).'  (`:-' is Prolog-speak for `<=')
10:31:55 <magicman> @t mapM
10:31:56 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
10:32:00 <ski> mauke : that is comparable to `[    ] ++ bs = bs; (a:as) ++ bs = a : asbs where asbs = as ++ bs', but somewhat more flexible
10:32:01 <magicman> :t mapM
10:32:02 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
10:32:24 <mauke> ski: yeah, because it can run backwards
10:32:38 <ski> mauke : a query/question/equation `?- append([0,1,2],[3,4],List).' would execute similarly to `[0,1,2] ++ [3,4]' selecting one clause at each recursive call (based on the top-level constructor of the first argument), returning the solution `List = [0,1,2,3,4]'
10:33:01 <magicman> *revelation*
10:33:15 <magicman> mapM for State is foldr in disguise.
10:33:53 <ski> mauke : however, if you query `?- append(Prefix,Suffix,[0,1]).' it will generate three solutions : `Prefix = [],Suffix = [0,1]';  `Prefix = [0],Suffix = [1]'; `Prefix = [0,1],Suffix = []'
10:33:53 <magicman> mapM_ gets even closer...
10:34:44 <ski> mauke : what Prolog does is it tries each of the clauses, when there is a potential overlap (comparable to `C0 a => C a' together with `C1 a => C a')
10:35:24 <mauke> I can see that
10:35:50 <mauke> the problem is that you can't have ambiguous results during method resolution
10:35:54 <ski> so, i suppose i'm asking for the instance resolver to do this kind of back-tracking, but only accept the program if there's exactly one instance
10:36:42 <mauke> that means adding 'import Foo ()' can break your program
10:38:27 <ski> *nod*, if it defines a competing instance
10:38:28 <mauke> and now I'm wondering how to encode append() using regexes
10:38:43 <ski> heh
10:40:16 <benmachine> mauke: adding import Foo () can surely already break your program, if by break you mean stop-from-compiling
10:40:46 <benmachine> (e.g. if Foo doesn't compile at all :P or if Foo defines outright duplicate instances with your program)
10:41:11 <mauke> true
10:44:21 <mauke> % perl -MData::Dumper -wle 'my @r; "01" =~ /^(.*?)(.*)\z(?{push @r, [$1, $2]})(?!)/; $Data::Dumper::Terse = 1; $Data::Dumper::Indent = 0; print Dumper \@r'
10:44:24 <mauke> [['','01'],['0','1'],['01','']]
10:44:30 <lee__> What's the best way to cons a value of type (Maybe a) onto a list of a?
10:44:41 <mauke> lee__: impossible
10:44:45 <mauke> Maybe a is not a
10:45:10 <ski> mauke : does that non-deterministically match the irregex on the string ?
10:45:38 <mauke> depends on your definition of "deterministic"
10:45:44 <zygoloid> lee__: "maybeToList maybeA ++ listOfA" is reasonable, if that's what you mean
10:46:02 <ski> @let maybeCons = maybe id (:)
10:46:03 <lambdabot>  Defined.
10:46:11 <ski> mauke : angelic
10:46:27 <mauke> what
10:46:56 <lee__> Yeah, I've got a maybeCons that patttern matches Nothing -> xs      (Just y) -> y:xs
10:47:01 <ski> > Just 0 `maybeCons` (Nothing `maybeCons` (Just 1 `maybeCons` [2,3]))
10:47:03 <lambdabot>   [0,1,2,3]
10:47:39 <lee__> Looks like that is about the same as ski's solution, but less elegant
10:47:51 <ski> mauke : angelic nondeterminism means the program will try all possibilities for you. demonic nondeterminism means the program will arbitrarily select one possibility, and you have to be prepared for any of them
10:48:11 <ski> mauke : concurrency gives rise to demonic nondeterminism
10:48:48 <ski> the nondeterminism of Prolog (as well as the list monad) is the angelic variety
10:49:23 <mauke> ah
10:49:29 <mauke> then yes
10:49:33 <ski> @type catMaybes  -- lee__, maybe this can be useful as well ?
10:49:35 <lambdabot> forall a. [Maybe a] -> [a]
10:49:53 <chrisdone> ski: What would `amb' non-determinism be called?
10:49:53 <ski> yes, angelic; or yes, demonic ? :)
10:49:58 <ski> chrisdone : angelic
10:50:02 <mauke> perl's regexes have a defined matching order
10:50:10 <mauke> a regex is a series of constraints
10:50:25 <benmachine> someone remind me how amb works
10:50:26 <mauke> the first part simply matches a string as two substrings
10:50:39 <benmachine> (or where I can find out)
10:50:42 <mauke> then I have an embedded action that records what substrings matched
10:50:47 <mauke> then I fail
10:50:52 <chrisdone> benmachine: http://chrisdone.com/posts/2011-04-10-amb-list-monad.html
10:50:58 <mauke> that way it will run through all permutations
10:51:39 <chrisdone> benmachine: The difference between amb and the list monad is that the list monad tries all possibilities, amb stops at the first success.
10:51:44 <ski> (btw, `angelic nondeterminism' and `demonic nondeterminism' is also known as `all-solutions nondeterminism' respectively `committed-choice nondeterminism' .. they also correspond to the `Hoare' and `Smyth' preorders on power-domains -- though i always forget which of them is angelic and which is demonic)
10:51:54 <benmachine> chrisdone: the 'who owns the fish' link seems to direct to hpaste - recent pastes
10:52:13 <mauke> hmm
10:52:24 <mauke> regexes give you the first matching result
10:52:35 <chrisdone> (Also http://www.haskell.org/haskellwiki/Amb)
10:52:37 <mauke> by forcing failure and grabbing intermediate state I get all possible results
10:53:25 <Jafet> amb is neutral lawful
10:53:31 <Jafet> It only works when it does
10:53:56 <benmachine> chrisdone: eep. I never quite got around to understanding ContT
10:54:23 <ski> chrisdone : "amb stops at the first success." -- depends on how you call it
10:55:31 <benmachine> ls
10:55:35 * benmachine
10:55:51 <Jafet> . ..
10:56:07 <chrisdone> benmachine: The jist of it is that "amb <some collection>" runs the rest of the code with each item in the collection (in some order), if at any point the code has amb <empty>, then it goes back and tries the next item in the collection.
10:56:38 <dankna> gist, dammit
10:56:51 <benmachine> chrisdone: ah. if you used the list monad but only demanded the first element of the result, wouldn't that be the same?
10:56:52 <chrisdone> dankna: :(
10:56:54 <dankna> jist a) is wrong and b) makes me think of another context altogether
10:57:15 <mauke> do { xs <- many anyChar; ys <- many anyChar; eof; modify ([xs, ys] :); fail "" }
10:57:16 <dankna> sorry, haha, former English teacher
10:57:20 <benmachine> it should be gyst, like cyst
10:57:23 <mauke> ^ haskell version of my regex code
10:57:24 <dankna> hee
10:57:32 <mauke> probably running in some ParserT State thing
10:57:53 <chrisdone> benmachine: Yeah, it would just be different performance.
10:57:59 <benmachine> chrisdone: ah, fair enough
10:58:21 <dylukes> Bored.
10:58:27 <dylukes> I think I'll implement BK trees in haskell.
10:58:28 <ski> see the `reify (reflect [0,2] ++ reflect [0,1]) :: [Int]' example at <http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue2/FunWithLinearImplicitParameters#Monadic_Reflection>, for `amb' in Haskell
10:58:29 <dylukes> For the hell of it :\
10:58:43 <dylukes> hm, I wonder if theres a more natural purely functional data structure...
10:58:49 <ski> chrisdone,mauke,benmachine : ^
10:58:53 <dylukes> That doesn't involve reconstructing an entire tree….
10:59:53 <mauke> ski: that page has terrible formatting
11:00:10 <ski> yes. it's converted from old hawiki
11:00:10 <mm_freak_> pandoc doesn't seem to support {.php}, while it recognizes {.haskell} and {.perl} without problems
11:00:23 <benmachine> mauke: see the note at the top
11:00:30 <benmachine> mm_freak_: because no-one likes php :P
11:00:31 <chrisdone> ski: Haha, ohhh nooooo. Not delimited continuations!
11:00:32 * benmachine silly
11:00:38 * chrisdone brain explodes
11:00:38 <ski> authored by our dear TheHunter
11:00:40 * benmachine hacks at the page formatting
11:00:51 <mm_freak_> benmachine: i wanted to express in a blog post how much i hate PHP, but without code examples that's really difficult =)
11:00:53 <dylukes> Seems like implementing Levhenstein distance finding is an interesting problem of its own TT_TT
11:00:57 <ski> preflex: xseen TheHunter
11:00:57 <preflex>  TheHunter was last seen on freenode/#haskell 68 days, 4 hours, 13 minutes and 25 seconds ago, saying: hmm
11:01:08 <benmachine> mm_freak_: haha :>
11:01:31 <mm_freak_> seriously =)
11:01:45 <TheHunter> that wasn't him
11:01:53 <mm_freak_> well, then i will write PHP without highlighting
11:02:02 <ski> TheHunter : yeah, i know that wasn't you ..
11:02:25 <TheHunter> how do you know it wasn't me?
11:02:29 <mm_freak_> benmachine: btw, nobody likes perl, but pandoc still recognizes it ;)
11:02:44 <benmachine> mm_freak_: I like perl as long as no-one makes me write any :(
11:02:45 <ski> TheHunter : because you're been missing for several years, silly
11:03:11 <benmachine> or read any, actually
11:03:14 <chrisdone> Ah, I just saw Neil Mitchell's coming to camhac. ヽ(´ー｀)ﾉ
11:03:18 <benmachine> I... like the name? a bit?
11:03:18 <TheHunter> nah, I've been here all along
11:03:43 <benmachine> chrisdone: your weird thing's left arm doesn't have a glyph in this font :(
11:03:46 * ski . o O ( <http://community.schemewiki.org/?composable-continuations-tutorial> )
11:04:06 <erus`> is there a 'fold until' or something?
11:04:11 <erus`> or a find first of
11:04:26 <kosmikus> \Andres{Which reminds me that we have given few examples earlier. Perhaps
11:04:27 <kosmikus> we can show some cool functions on the AST or the perfect tree, in order
11:04:27 <kosmikus> to show how |map| and |cata| can be used.}%
11:04:27 <kosmikus> \Pedro{I am not entirely sure what you mean.}%
11:04:34 <kosmikus> sorry
11:04:35 <ski> @type find
11:04:36 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
11:04:44 <mm_freak_> btw, when people are asked for useful real world haskell projects, the most common packages mentioned are GHC, darcs and xmonad
11:04:56 <kosmikus> http://community.schemewiki.org/?composable-continuations-tutorial> )
11:04:56 <kosmikus> 20:26 < erus`> is there a 'fold until' or something?
11:04:57 <mm_freak_> i think, pandoc is also incredibly useful as a standalone program
11:05:00 <erus`> > find (== 2) [1..10]
11:05:01 <kosmikus> grr
11:05:01 <lambdabot>   Just 2
11:05:04 <ski> kosmikus : intriguing ..
11:05:19 <benmachine> mm_freak_: yeah, I write stuff for my website with pandoc
11:05:21 <erus`> will that stop looping when it finds the first match?
11:05:24 <chrisdone> benmachine:（　´_ゝ`）
11:05:25 <benmachine> it's pretty convenient
11:05:28 <kosmikus> ski: my mouse is generating click events without me pressing anywhere
11:05:28 <erus`> is it quick?
11:05:29 <djahandarie> ( ´_ゝ｀)
11:05:31 <benmachine> chrisdone: :P
11:05:37 <ski> erus` : "stop looping" yes
11:05:37 <djahandarie> ( ｀_ゝ´)
11:05:38 <mm_freak_> benmachine: i mostly use pandoc as a library, but i've also used it standalone
11:05:44 <kosmikus> ski: quite scary
11:06:21 <chrisdone> That ain't no mouse, it's a rat!
11:06:47 <kosmikus> chrisdone: :)
11:06:53 <chrisdone> ( Also http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_sec_4.3 )
11:07:02 <kosmikus> I seem to have it under control now ;)
11:07:11 <chrisdone> SICP is the xkcd of computing. /Obligatory SICP link/
11:07:19 <Veinor> haha
11:07:20 <ski> kosmikus : "If your rodent causes you to sin, tear it out and throw it away."
11:07:26 <djahandarie> What is xkcd of?
11:07:44 <kosmikus> ski: it's a touchpad, actually ;)
11:07:47 <dylukes> SICP is dry as hell, but pretty neat ^^.
11:08:01 <dylukes> If you find it interesting despite the dryness, you're cut out to stay in #haskell ~
11:08:06 <chrisdone> dylukes: With the accompanying lectures it's slightly more moist.
11:08:17 <erus`> no hang on. let say i have a list of numbers and i need to get all the numbers from the start of the list until i hit an odd number OR the number after the current one is a 7
11:08:17 <dolio> The lectures are great.
11:08:22 <dylukes> I should get those.
11:08:23 <dylukes> which ones?
11:08:24 <erus`> how can i do that?
11:08:27 <ski> @where sicp
11:08:28 <lambdabot> The Wizard book : "Structure and Interpretation of Computer Programs" at <http://mitpress.mit.edu/sicp/> by Hal Abelson,Gerald Jay Sussman with Julie Sussman, videos at <http://swiss.csail.mit.edu/
11:08:28 <lambdabot> classes/6.001/abelson-sussman-lectures/>
11:08:30 <dylukes> Are they on the MIT lecture podcast list?
11:08:47 <chrisdone> dylukes: I'd guess not, they're from like 1986.
11:08:56 <chrisdone> http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/
11:08:59 <dylukes> Meh, that stuff gets catalogued.
11:08:59 <mm_freak_> ski: looks like those "composable continuations" are what we would call resumable exceptions
11:09:14 <dolio> You can reflect upon how much less ridiculous 2010s nerds look than 80s nerds.
11:09:17 <ski> mm_freak_ : they are not exceptions
11:09:28 <ion> That’s a great set of video lectures.
11:09:30 <chrisdone> dolio: :D And then be jealous of their wizardous flair.
11:09:32 <mm_freak_> ski: a generalized form of exceptions
11:09:50 <ski> mm_freak_ : are you talking about resumable conditions, in some Lisp systems ?
11:09:51 <dylukes> dolio: Haha.
11:09:56 <dylukes> I'm a sexy nerd. Get used to it.
11:10:00 * dylukes is egotistical.
11:10:19 <mm_freak_> ski: i didn't read the whole article, but there are packages in haskell, which introduce resumable exceptions
11:10:52 <mm_freak_> 'reset' accounts for 'try' and 'shift' accounts for, let me call it, 'throwWithCC'
11:11:00 <dolio> I expect delimited continuations are more general than resumable exceptions.
11:11:03 <ski> mm_freak_ : composable continuations are a side-effect, so couldn't be had in Haskell, except wrapped into a computation type
11:11:45 <ski> with composable/delimited continuations, you can reflect *any* computable monadic effect into a side-effect
11:11:46 <mm_freak_> dolio: of course, the difference is that you can pass the continuation around
11:12:20 <ski> (per Andrzej Filinski. see "Representing Monads" and "Reflecting Monads")
11:12:35 <mm_freak_> hmm, ok
11:12:38 <dylukes> Hey one question,
11:12:45 <dylukes> if we keep generalizing everything,
11:12:52 <dylukes> will we eventually reach a generalized singularity?
11:12:55 <mm_freak_> ski: because you can call the same continuation multiple times?
11:13:00 <dylukes> Where one concept can be used to express every other one?
11:13:14 <Jafet> Program in unary
11:13:14 <dankna> that already exists
11:13:19 <dankna> it's the concept "concept"
11:13:19 <dylukes> Except, it'd be a more general form, not something you can build the others with...
11:13:20 <mm_freak_> dylukes: we're already there
11:13:29 <dylukes> mm_freak_: ?
11:13:37 <mm_freak_> dylukes: you cannot be more general than 'a'
11:13:38 <ski> mm_freak_ : basically yes. i believe in a system with control over how many times values are used, continuations would not necessarily be side-effectful
11:13:48 <dylukes> mm_freak_: So… a single symbol?
11:13:59 <dylukes> mm_freak_: What about the null symbol/unit symbol case?
11:14:10 <ski> dylukes : consider the concept of concepts which are an instance of themselves ..
11:14:19 <mm_freak_> dylukes: it was just a joke actually, but the concept of "most general" is already here
11:14:19 <dylukes> ski: Is that a proper category?
11:14:25 <mm_freak_> dylukes: the type 'a' is most general
11:14:34 <mm_freak_> it unifies with every other type
11:14:36 <dylukes> Set X, the
11:14:41 <ski> dylukes : .. as in category theory ?
11:14:46 <dylukes> set of all concepts, and barbers who may or may not shave themselves.
11:14:55 <dylukes> ski: yeh
11:15:10 <mm_freak_> dylukes: btw, CT is far from covering every concept
11:15:19 <dylukes> I know XD.
11:15:20 <ski> i think it's not well-defined enough to answer whether it is a Category
11:15:27 <dylukes> go formalize it.
11:15:35 <mm_freak_> it doesn't even cover the less-than relation, even though it covers the less-than-or-equal relation
11:15:42 <dylukes> I'm going to try to figure out how to implement levenshtein distance finding most efficiently in haskell...
11:15:46 <dylukes> or at least… most elegantly.
11:16:02 <mm_freak_> dylukes: side note:  there is already a library for that
11:16:06 <mm_freak_> see the edit-distance library
11:16:40 <mm_freak_> you may want to check out how it works, but since it's working on String, it's probably not very efficient
11:16:48 <dylukes> mm_freak_: I know.
11:16:52 <dylukes> Well, I want to do it on String
11:16:55 <dylukes> but I want to figure it out myself
11:16:56 <dylukes> ^^
11:17:02 <mm_freak_> ok, have fun =)
11:17:03 <dylukes> I don't want to cheat and look at it.
11:17:15 <mm_freak_> learning haskell?
11:18:13 <dylukes> heh?
11:18:20 <dylukes> No, I just want to figure out the algorithm as a little puzzle.
11:18:26 <mm_freak_> ah, ok
11:18:30 <dylukes> I had to rebook a flight 12 hours later.
11:18:34 <dylukes> I'm bored in the airport.
11:18:47 <mm_freak_> i see =)
11:18:59 * ski wonders whether there's a better name for Martin-Lf's concept of `category' in "Intuitionistic Type Theory" (1984)
11:19:00 <shapr> hej andersk, är du svensk?
11:19:44 <ion> I’ve been wondering why MIT.EDU hostnames always seem to be in UPPERCASE. :-)
11:20:07 <dylukes> Could you implement matrices by defining Ix (a,b)?
11:20:14 <dylukes> or, Ix (m,n) if you prefer...
11:20:16 <Jafet> '(HISTORICAL REASONS?)
11:20:34 <dylukes> XD.
11:20:34 <mauke> dylukes: doesn't that already exist?
11:20:34 <ski> there is already an `instance (Ix a,Ix b) => Ix (a,b)'
11:20:44 <dylukes> Oh. figures ^^
11:20:54 <jonkri> i have a type question if someone wouldn't mind to take a look: http://paste.pocoo.org/show/403618/ ... thanks in advance! :)
11:20:55 <dylukes> So, I can just use that to represent a matrix I guess.
11:21:02 <ski> @instances-importing Data.Ix Ix
11:21:04 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
11:21:24 <Jafet> Heh... Bool, Ordering
11:21:39 <dylukes> Ordering?
11:21:42 <dylukes> Also, Bool. Lol.
11:21:45 <ski> @src Ordering
11:21:46 <lambdabot> data Ordering = LT | EQ | GT
11:21:49 <dylukes> hah
11:21:50 <Jafet> And unit
11:22:01 <dylukes> You can use that for array indicifying?
11:22:07 <andersk> shapr: No, sorry.
11:22:10 <dylukes> indicification* my bad.
11:22:11 * Jafet makes a note to create an array on unit.
11:22:27 <Jafet> Indexing.
11:22:46 <mauke> jonkri: too many parens
11:22:51 <ski> jonkri : `data State s m = ...' doesn't define a class
11:22:56 <dylukes> @hoogle Ix
11:22:56 <lambdabot> module Data.Ix
11:22:56 <lambdabot> Data.Ix class Ord a => Ix a
11:22:56 <lambdabot> Data.Array.IArray ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
11:23:00 <dylukes> @hackage Ix
11:23:00 <lambdabot> http://hackage.haskell.org/package/Ix
11:23:15 <mauke> jonkri: instance ClientState (State s m) m
11:23:32 <jonkri> ski, it should be "now, i want to have a such instance of the following type"
11:23:56 <ski> (mauke : too many, where ?)
11:24:27 <jonkri> mauke, Illegal instance declaration for `NX.ClientState (State s m) m', (All instance types must be of the form (T a1 ... an), where a1 ... an are *distinct type variables*,...
11:24:40 <jonkri> do i need FlexibleInstances?
11:25:41 <ski> (oh)
11:25:56 <Jafet> If you did, ghc would probably tell you that
11:26:01 <dylukes> When you use array and supply a function to construct it,
11:26:07 <dylukes> does it specify any sort of evaluation order?
11:26:15 <dylukes> er, filling order?
11:26:20 <Jafet> Why would evaluation order matter?
11:26:27 <dylukes> not evaluation… filling order, ahem.
11:26:34 <Jafet> Yeah. Why would that matter?
11:26:41 <dylukes> Say you wanted to make the value at one index based on another
11:26:47 <dylukes> a[i] = a[i-1] + 10
11:26:52 <ski> it's evaluated lazily
11:27:11 <Jafet> Hm, I don't think that works
11:27:19 <Jafet> Oh, what ski said
11:27:25 <benmachine> http://www.haskell.org/haskellwiki/User:Benmachine <-- eep
11:27:30 * Jafet still lives in unboxed-land
11:28:11 <benmachine> oh man I think I found a bug in the wiki
11:29:35 <benmachine> oh hmm
11:30:07 <benmachine> the haskell parser does odd things when you open a comment but don't close it
11:30:40 <jonkri> mauke, FlexibleInstances and MultiParamTypeClasses seemed to do the trick
11:31:23 <dankna> so!  GUI-design opinion time!
11:31:32 <dankna> I'm afraid I don't have mockups for this, so you'll have to picture it
11:31:54 <chrisdone> dankna: I'm picturing the Louvre.
11:31:57 <dankna> I am writing a text editor.  It is to have splittable windows, in the vertical dimension only - that is, you can make it show multiple documents, or multiple views of the same document.
11:32:03 <dankna> chrisdone: sounds good, keep doing that.
11:32:22 <dankna> The border between sub-windows is to be about 2.5 lines of text in height
11:32:41 <dankna> There will also be an extra border at the very bottom of the window
11:32:44 <Jafet> GNU screen does that. It's terrible and useless.
11:32:49 <ski> > let tabulate ix f = listArray ix (map f (range ix)); nFibs n = arr where arr = tabulate (0,n-1) fib; fib 0 = 0; fib 1 = 1; fib n = arr ! (n-1) + arr ! (n - 2) in nFibs 12
11:32:50 <lambdabot>   array (0,11) [(0,0),(1,1),(2,1),(3,2),(4,3),(5,5),(6,8),(7,13),(8,21),(9,34...
11:32:51 <dankna> yes, well, this is a GUI thing
11:32:59 <dankna> the reason it's thick is to display useful information in it
11:33:01 <Jafet> Especially with current trends in computer screens.
11:33:14 <ski> Jafet : i don't enable that in GNU Screen ..
11:33:19 <dankna> Jafet: actually, could you explain that a little more - why is it useless and how do current trends affect it?
11:33:25 <ski> dylukes : see the above ^ example
11:33:30 <dylukes> hm?
11:33:34 <Jafet> Why not split windows horizontally?
11:33:41 <dankna> Jafet: because the GUI gets more complicated
11:33:50 <dylukes> I split my windows down the middle vertically.
11:33:54 <dylukes> like, with emacs.
11:34:01 <dylukes> I prefer being able to see more vertical content...
11:34:04 <Jafet> Well, doing it vertically is pretty useless these days
11:34:11 <dankna> the border will display, in the lower-left corner, (XXX, YY) / ZZZ, representing current cursor position (x, y) and total line count
11:34:11 <dylukes> why?
11:34:14 <dylukes> we have widescreen monitors.
11:34:15 <dylukes> :|
11:34:21 <Jafet> It may be harder to do it the other way, but at least that has a payoff
11:34:36 <dankna> Jafet: it's not harder to do - it's harder to do in a way that doesn't confuse and frustrate
11:34:38 <benmachine> dylukes: I do that with vim
11:34:48 <dankna> okay, so I'm hearing a vote for allowing vertical splitting :(
11:35:05 <Jafet> Vote? We DEMAND
11:35:05 <dankna> anyway, leaving that aside for the moment
11:35:11 <dylukes> DEMAND VERTICAL SPLITTING HNGHGHGHGHGGH
11:35:14 <dylukes> LETS FIGHT ABOUT IT
11:35:21 <Jafet> Okay, that's enough.
11:35:30 <dylukes> hey could someone explain monty hall to me?
11:35:33 <dankna> no
11:35:34 * ski usually does `split-window-horizontally', often with `follow-mode', in an `161x72' sized terminal
11:35:35 <dylukes> I'm ABSOLUTELY sure its 50/50.
11:35:38 <dankna> so let me finish my freaking question
11:35:40 <benmachine> (guys, an aside: who do I tell that I broke the wiki?)
11:35:45 <benmachine> dankna: go on
11:35:58 <dankna> dylukes: I had to actually try it myself - do the actual trials by hand - to believe it
11:36:07 <dylukes> dankna: Really?
11:36:09 <dankna> dylukes: I was convinced it was an artifact of how you counted, but no, it's real.  I suggest you do the same.
11:36:11 <dankna> dylukes: yes.
11:36:15 <dylukes> I'm just kidding btw.
11:36:16 <dylukes> trolling
11:36:18 <dankna> okay haha
11:36:20 <dylukes> Writing out the table was proof enough
11:36:29 <benmachine> dankna: what's your damn question :P
11:36:34 <dylukes> Pretending you refuse to understand it is a great troll.
11:36:46 <dankna> everyone: so in addition to the cursor position and line count in the lower-left corner
11:36:48 <Entroacceptor> dankna: don't you know anything about chatiquette? Don't ask to ask!
11:36:59 <benmachine> dylukes: from the same class as "I heard that 0.9 recurring is a bit smaller than 1"
11:37:01 <dankna> it will have the title of the document /beneath/ it in the center, and an icon for that document (draggable)
11:37:15 <dylukes> benmachine: haha.
11:37:20 <dylukes> What is the consensus on that?
11:37:21 <dankna> is this too much information?  too confusing?
11:37:33 <dankna> is there anything useful it could put in the lower-right?
11:37:37 <benmachine> dankna: what's the icon for?
11:37:55 <dankna> benmachine: on the Mac, you can get a proxy for the file in the window you are editing by dragging its icon out of its titlebar.
11:37:58 <dylukes> whats the best way in haskell to take the minimum of three things?
11:38:01 <Jafet> If it's confusing, try using more words
11:38:01 <Entroacceptor> lower-right is for "split horizontally"
11:38:03 <benmachine> dankna: ah, neat
11:38:10 <benmachine> dylukes: a `min` b `min` c is not bad
11:38:20 <Jafet> Instead of fewer (a common mistake)
11:38:22 <ski> @type minimum  -- is a possibility
11:38:23 <lambdabot> forall a. (Ord a) => [a] -> a
11:38:27 <dylukes> Oh god.
11:38:30 <dankna> you can use that to move the file to a new location, copy it to somewhere, or whatever.  in my program you will also be able to drag that icon to another titlebar to open it in that window
11:38:36 <Entroacceptor> but without a mockup I don't really know
11:38:38 <dankna> benmachine: indeed :D
11:38:45 <dankna> Entroacceptor: hmmm.... that's a thought certainly, yes
11:39:16 <Entroacceptor> or maybe some mode info
11:39:32 <benmachine> dylukes: (btw, 0.9 recurring is exactly equal to 1)
11:39:34 <dankna> no, I thought about that.  I feel that mode info is already on the screen in several places and doesn't need to be there again.
11:39:36 <Jafet> Like <icon> <file> (at line XXX, column YY out of ZZZ lines)
11:39:59 <dankna> Jafet: the problem with that is that the icon and file pertain to the frame below; the position and line count pertain to the frame above!
11:40:05 <dankna> that's the real subtlety, which I'm wondering if it's a good idea
11:40:12 <chrisdone> What's the preferred choice of words mapping for referring splitting?
11:40:17 <Jafet> Aha, the real question finally arrives
11:40:23 <dankna> chrisdone: that question doesn't grammar
11:40:40 <benmachine> dankna: yeah, that sounds iffy to me
11:40:48 <dankna> I mean I can cue it visually somehow, perhaps
11:40:56 <benmachine> dankna: I'd put all the information about each window in the same place
11:40:59 <Jafet> Well, I'd put them all on the same row or equivalent-horizontal-widget, if possible
11:41:06 <dankna> probably not by offsetting the text baselines, but maybe by clever background design
11:41:29 <benmachine> dankna: I think it's visually distracting to have conceptually distinct information together
11:41:47 <chrisdone> When you say ‘vertical split’ do you mean that the two resulting components are now vertically stacked, or that the line created between them is vertical?
11:41:50 <dankna> benmachine: I think you're probably right, but...  I can't play with the titlebar of the window itself, it takes weird hacks to draw into it.
11:41:54 <dankna> chrisdone: the former
11:42:09 <benmachine> dankna: so don't write filenames in the titlebar, I reckon
11:42:14 <xplat> i think the best idea is just split in the other direction
11:42:21 <Jafet> You seem to be approaching this problem with a preconception of layout (caused by Mac OS visual convention?)
11:42:23 <benmachine> xplat has a point too
11:42:26 <dankna> benmachine: what, leave the titlebar blank?  I want this to feel like a Mac app
11:42:36 <benmachine> dankna: write "dankna's awesome text editor" in it
11:42:42 <dankna> ugh!  no :)
11:42:44 <dankna> just no :)
11:42:47 <benmachine> :P fine
11:42:58 <benmachine> (I don't think that practice is unusual though)
11:43:01 <Jafet> "dankna's hipster text editor"
11:43:08 <chrisdone> “no”
11:43:12 <dankna> maybe not, but it's really against sound principles
11:43:28 <dylukes> odd question,
11:43:30 <dankna> sure
11:43:33 <dylukes> if you're doing something like...
11:43:33 <benmachine> dankna: I think if you want a filename in the title bar then you want a title bar per file
11:43:38 <ski> (.. was dankna considering putting information about one of the buffers in the titlebar, but not for the other buffers ?)
11:43:40 <benmachine> otherwise it's weird
11:43:44 <dylukes> a@(_:_)
11:43:50 <dankna> ski: no
11:43:51 <dylukes> whats the preferred naming for those two parts?
11:43:59 <dankna> benmachine: I call them first and rest
11:44:02 <dbpatterson> is there any way to reduce the amount of memory that GHC uses when linking? I'm unable to build some packages on an EC2 instance with ~600MB ram because it runs out of memory (ld specifically)
11:44:02 <dylukes> (a:as) is common, but what about when you want the WHOLE thing as well :|?
11:44:06 <dankna> s/benmachine/dylukes/
11:44:09 <dylukes> dankna: Yeah but I have two.
11:44:13 <dylukes> a and b
11:44:15 <benmachine> dylukes: sometimes I do xs@(y:ys)
11:44:16 <xplat> i go with ah:at sometimes
11:44:24 <dylukes> xplat: heh, yeah i was thinking that
11:44:25 <dankna> benmachine: well, my separator bar will look like a title bar visually
11:44:33 <benmachine> dankna: that's a little odd, imo
11:44:34 <dankna> I think I'm going to do a mockup and come back in five minutes
11:44:35 <dankna> okay?
11:44:40 <ski> dylukes : `bar' and `bars' is common
11:44:52 <dylukes> ski: But I have
11:44:56 <dylukes> bar@(…:bars)
11:44:59 <dankna> benmachine: oh I know it's odd!  that's why I'm considering everything very carefully :)
11:45:00 <tgeeky> bos: can you update the links in the configurator package
11:45:01 <dylukes> what would I call the head element?
11:45:05 <ski> `bar0@(bar:bars)'
11:45:07 <xplat> dankna: you definitely don't expect a titlebar to go below the window
11:45:08 <ski> er
11:45:12 <ski> `bars0@(bar:bars)', that should be
11:45:17 <dankna> xplat: I agree, somebody else was suggesting that, not me
11:45:24 <ski> (that's what i do, usually)
11:45:26 <dylukes> hm
11:45:31 <dylukes> I'd switch bar and bars0 there
11:45:33 <dankna> xplat: it's the title for the thing below it; the information for the thing above it
11:45:33 <benmachine> dylukes: if bar is type a, I'm used to bars being [a]
11:45:42 <benmachine> bar@(_:bars) violates that
11:45:44 <dylukes> bar@(bars0:bars) makes more sense.
11:45:45 <xplat> but emacs/texmacs peeps will expect a separator bar to talk about the window above it
11:45:51 <xplat> so it's kind of lose/lose
11:45:56 <ski> dylukes : i disagree
11:46:04 <dylukes> how so?
11:46:13 <dylukes> xplat: Huh?
11:46:15 <benmachine> xplat: the vim information bar goes below the document too
11:46:15 <dankna> xplat: yes, well, given my choice between the conventions Apple established by actual experiments, and the conventions Emacs established by fiat, I will go with the former
11:46:22 <dylukes> What're you making?
11:46:24 <ski> dylukes : what benmachine said
11:46:28 <dylukes> dankna: ?
11:46:40 <dankna> dylukes: you're asking me what I'm making?  it's a structure editor for Haskell
11:46:47 <dylukes> Structure editor?
11:46:49 <dankna> at least, initially for Haskell.  broader language support is an eventual goal.
11:47:08 <dankna> like a text editor but with knowledge of the language's full grammar, and the document is always in a valid state except that it can have holes in it.
11:47:10 <benmachine> dankna: is this similar to Peaker's idea that I vaguely recall?
11:47:18 <xplat> dankna: does apple have conventions like that for vertically splitting windows?  i didn't think that was part of their UI guidelines ...
11:47:19 <benmachine> ah, it sounds a bit like that
11:47:22 <dankna> yes, it's a synthesis of Peaker's idea and an older idea of my own
11:47:24 <ski> dankna : i hope you're going for cross-referencing and such
11:47:28 <benmachine> I had that idea too :P
11:47:28 <dankna> xplat: they actually do have conventions
11:47:30 <dankna> ski: I definitely am
11:47:43 <dankna> benmachine: yes well, I'm making it real =p
11:47:47 <benmachine> dankna: yay :)
11:47:50 <dankna> hehe :)
11:48:12 * benmachine has many more ideas than implementation ability
11:48:19 <chrisdone> Oh. I just realised Seven of Nine takes the role of Data in Voyager. What do you call a character like that? I'm thinking Tropes will know.
11:48:20 <benmachine> that doesn't quite grammar but you get what I mean
11:48:25 <dankna> xplat: they have NSSplitView in fact, which provides built-in functionality.  I'm not using it because I need to have a view in the divider bar instead of just a bar.
11:48:29 <dankna> yes, I know what you mean
11:48:42 <benmachine> chrisdone: data was better though :(
11:48:49 <dankna> I do too, but I feel this one deserves to be a priority because it would be of such immediate practical use to me and to others
11:48:51 <dylukes> Apple has UI conventions for everything...
11:48:55 <dylukes> And yet everyone chooses to break them.
11:49:06 <dylukes> Follow them, and your application will generally look better than if you didn't. True story.
11:49:06 <dankna> dylukes: but if you break them with awareness at least, it's semi-okay
11:49:07 <benmachine> dylukes: not everyone. it really does help when you don't imo
11:49:11 <dylukes> dankna: Sure.
11:49:15 <xplat> chrisdone: there are several tropes that Data was associated with, most of which 7of9 also takes
11:49:19 <dylukes> I can see where breaking them is helpful in some cases,
11:49:22 <dylukes> hence guidelines, not rules.
11:49:27 <dylukes> But in the case of… most programs...
11:49:29 <dankna> you call that character "the Spock" =p
11:49:30 <joeytwiddle> if i want to return either a No or a Yes with an object attached, what do we call the returned data type?
11:49:40 <dankna> because Spock invented the role, haha
11:49:44 <dylukes> hah
11:49:49 <geheimdienst> what are we talking about? (re apple ui rules)
11:49:51 <benmachine> joeytwiddle: a tuple? *shrug*
11:50:01 <djahandarie> joeytwiddle, Either?
11:50:01 <benmachine> geheimdienst: dankna is talking about UI design for a thing
11:50:11 <tgeeky> dankna: watcha workin on these days?
11:50:16 <ski> joeytwiddle : either a "no", or a "yes, with object attached" ?
11:50:16 <dankna> geheimdienst: my structure editor for Haskell and splitting its windows.  I'm now preparing a mockup of how I think it will look.
11:50:19 <dankna> tgeeky: see above :D
11:50:25 <benmachine> djahandarie: hmm, that depends on whether the type for No is the same as the type for yes
11:50:27 <joeytwiddle> yes ski
11:50:32 <ski> joeytwiddle : if so, `Maybe MyObjectType'
11:50:33 <benmachine> joeytwiddle: ah, that's Maybe then
11:50:34 <dylukes> dankna: I'd love to see :\
11:50:36 <dylukes> Or help even.
11:50:40 <geheimdienst> i see
11:50:41 <joeytwiddle> ah a Maybe, thanks guys
11:50:43 <dankna> dylukes: great!  I had hoped as much!  are you on a Mac?
11:50:44 <joeytwiddle> :)
11:50:44 <tgeeky> dankna: i just joined after a reboot :/ 1 line summary?
11:50:46 <xplat> joeytwiddle: if the object explains the answer we call it 'Dec'
11:50:48 <dylukes> I have nothing better to do, and if you need someone with experience in OS X dev,
11:50:49 <dylukes> I can help.
11:50:50 <chrisdone> xplat: One applicable trope is Become A Real Boy.
11:50:59 <djahandarie> joeytwiddle, ah, my bad, I parsed your question wrong. Maybe it is. :)
11:51:01 <benmachine> dylukes: I have a macbook but I installed linux on it :(
11:51:02 <dylukes> Yeah, and I know AppKit through and through.
11:51:10 <benmachine> I did install GHC on my mac at home though
11:51:14 <dylukes> Seriously, I have most of the Cocoa std lib memorized TT_TT
11:51:14 <dankna> tgeeky: a structure editor for Haskell, with deep understanding of the language's grammar and features such as cross-referencing and always having a complete parse of the document as you work.
11:51:16 <dylukes> just from usage.
11:51:31 <xplat> chrisdone: 7of9 is kind of ambivalent on that one actually
11:51:35 <geheimdienst> i found it kinda interesting that with the new xcode, they seem to acknowledge what the xmonad users have known all along. it doesn't scale to have lots of unmanaged overlapping windows
11:51:37 <dylukes> Some of it is *ridiculous* underneath...
11:51:42 <benmachine> dankna: do you have thoughts on how you're going to parse an incomplete document?
11:51:44 <dylukes> geheimdienst: Heh.
11:51:49 <dylukes> btw,
11:51:49 <tgeeky> dankna: soudns cool
11:51:49 <dylukes> http://ridiculousfish.com/blog/archives/2005/12/23/array/
11:51:58 <xplat> chrisdone: but definitely closer to it than Spock :)
11:51:59 <tgeeky> benmachine: paragraph parse
11:52:00 <dankna> dylukes: well, awesome, I'd love to have you onboard.  after I do this mockup and make a decision I'll get you set up and discuss what you might contribute.
11:52:05 <dylukes> interesting article about CFArray (the C underpinning of NSArray)
11:52:11 <dylukes> dankna: Is there a salary involved?
11:52:14 <benmachine> tgeeky: that'd be a good start, but ideally you want word parse too :)
11:52:14 <dankna> benmachine: yes, that was the key point that made me realize this was the time to do it.
11:52:15 <dylukes> Just curious :P.
11:52:22 <chrisdone> xplat: I was hoping for a trope like "outsider learning how to be more human" as a device/platform for the writers to point out absurdities in human behaviour.
11:52:30 <dankna> dylukes: no, but if I ever make money from it I'll feel morally obligated to share some with you, in proportion to your contribution
11:52:32 <benmachine> dankna: ah, awesome. I'd be interested in a parser that could parse incomplete documents for all sorts of reasons
11:52:34 <joeytwiddle> i can't think what Dec is short for.  Decanter?
11:52:40 <dylukes> Well, I'd love to help either way.
11:52:42 * ski wonders whether attribute grammars would be useful for (roughly) parsing and reparsing partial code
11:52:45 <dylukes> joeytwiddle: Decimal?
11:52:47 <tgeeky> benmachine: i mean to say, paragrah-by-paragraph parsing
11:52:49 <dylukes> Decaton?
11:52:49 <chrisdone> joeytwiddle: December?
11:53:00 <dylukes> dankna: Mind explaining what it actually is >_>?
11:53:02 <benmachine> tgeeky: hmm, I see
11:53:04 <dankna> benmachine: me too, yes, my Joy parser generator was going to be that.  but I realized that by keeping the document in a database and treating text as an export format only, I don't need a parser.
11:53:11 <dylukes> Btw, with the onset of full-screen programs in OS X,
11:53:16 <dylukes> can we have XMonad run as a space now?
11:53:19 <dylukes> ^^?
11:53:23 <chrisdone> dankna: You wrote a program in Joy? Can I see?
11:53:26 <dankna> we already had full-programs
11:53:30 <benmachine> dankna: one of my shelved projects is getting an online error-correcting haskell parser
11:53:36 <dylukes> Well, now they're better integrated.
11:53:43 <dankna> chrisdone: no, Joy is the name of my parser generator; I didn't know about the language by that name when I picked it
11:53:46 <geheimdienst> how do you mean "onset of full-screen programs"?
11:53:55 <dylukes> I wrote an iPhone app in Malbolge.
11:53:59 <benmachine> (I go and look at uu-parsinglib every now and then to try to work out what it is, and fail :P)
11:54:03 <tgeeky> benmachine: given a file with satisfiable (import,export,pragma) definitions, split the document on "\n\n", parse the results
11:54:03 <dankna> I'll let dylukes answer that, I've got the disturbing feeling I just forgot to answer someone
11:54:07 <chrisdone> (￣ー￣)
11:54:09 <dankna> personal stack overflow thing
11:54:11 * Entroacceptor backs away from dylukes 
11:54:12 <dylukes> dankna: what?
11:54:13 <tgeeky> benmachine: or something like that :/
11:54:21 <dankna> dylukes: answer geheimdienst's question :)
11:54:26 <tgeeky> benmachine: at least, that's how I would *pretty print* haskell source
11:54:30 <dylukes> geheimdienst: ah,
11:54:32 <dankna> dylukes: and clarify your own
11:54:33 <benmachine> tgeeky: sure, that'd be a good start, but you'd want to parse paragraphs that were still being written I'd've thought
11:54:37 <dylukes> OS X Lion has built in support for full-screen applications.
11:54:42 <dylukes> multiple of them, at once.
11:54:45 <xplat> joeytwiddle: Decidable
11:54:50 <dylukes> That is, they operate as their own virtual desktops.
11:54:54 <benmachine> tgeeky: plus in principle it's possible for e.g. instance declarations to take multiple paragraphics
11:54:55 <dylukes> virtual screens*
11:54:57 <tgeeky> benmachine: yeah, if a paragraph fails to parse, then you highlight the entire paragraph as untypecheckable
11:54:58 <benmachine> er, paragraphs
11:55:03 * benmachine crosses brainwires
11:55:23 <dylukes> geheimdienst: http://cl.ly/7VQ4
11:55:23 <dankna> benmachine: you were the one asking about the parsing strategy, right?  I think you were also the one who I lost my thread with mentally.  I had already said that the trick is to keep the code in a database and treat text as an export format only, right?  had you replied to that?
11:55:27 <tgeeky> benmachine: yeah, that can be solved I think (at least for pretty printing, maybe not for actual parsing)
11:55:41 <tgeeky> dankna: i think there is a better solution, btw
11:55:44 <dankna> benmachine: that may be a disappointing answer in that it implies less power in the thing, but it's also a nice answer
11:55:44 <dylukes> notice Mail/Safari run as their own screens entirely...
11:55:49 <benmachine> dankna: no, I didn't realise what you meant at first
11:55:55 <benmachine> I'm interested to see how that turns out
11:56:08 <dankna> tgeeky: oh I know a lot about parsing algorithms, and I definitely know there are better ways
11:56:12 <dylukes> dankna: So, mind explaining what you want to do?
11:56:16 <tgeeky> dankna: not for parsing, for storage
11:56:26 <dylukes> i can contribute the OS X side of things, I may be deficient in the necessary haskell ^^.
11:56:27 <dankna> dylukes: well, the goal is to be less than Emacs but more than Vi, sort of
11:56:37 <dylukes> Hm, well, I'm an emacs user of a few months.
11:56:43 <benmachine> dankna: but but but vi > emacs :P
11:56:43 <tgeeky> dankna: store all code in as small of a fragment as possible, in a ref-by-value docstore (like git)
11:56:44 <dylukes> And I use TextMate on occasion.
11:56:58 <dylukes> and Eclipse when I HAVE TO. (guy)
11:56:59 <dylukes> guh*
11:57:00 <dankna> dylukes: it will be a modal editor, and the currently-focused frame will always have a handy quick-reference guide listing keystrokes you might want to use right now
11:57:08 <dylukes> Oh, huh.
11:57:09 <joeytwiddle> roger that xsplat
11:57:13 <dankna> dylukes: the quick-ref guide will be in a contrasting color
11:57:13 <geheimdienst> i don't get it. http://www.cl.ly/7VQ4 looks like a windows taskbar or alt-tab chooser. (cmd-tab for mac people)
11:57:22 <ski> dankna : a bit like Alfa, then ?
11:57:30 <dankna> ski: not familiar with Alfa
11:57:35 <dylukes> geheimdienst: It's MC, successor to Expose.
11:57:43 <dylukes> Let me give you the full screenshot and you'll inderstand
11:58:12 <dylukes> I was just using it to show you fullscreen programs...
11:58:18 <dylukes> http://cl.ly/7V0D
11:58:47 <dankna> dylukes: I can get you set up to build and play with it today, but I think it might be about two weeks before there's enough infrastructure in place for you to hack on.
11:58:54 <dylukes> mmk.
11:58:56 <dankna> tgeeky: what other storage mechanism did you think might make sense?
11:58:58 <dylukes> No problem.
11:59:05 <dylukes> How is it repod?
11:59:16 <dylukes> I can, and certainly will, bitch about interface ^^.
11:59:21 <dylukes> rest assured.
11:59:23 <dankna> dylukes: cool then :) it's darcs, and it builds by Cabal but you'll need to install a custom-patched version of the Cabal library....
11:59:31 <dylukes> Are you using HOC or something?
11:59:33 <dankna> good!  I need someone who's strong on UI design to check my sanity
11:59:52 <tgeeky> dankna: store ASTs themselves, store hs files, store lhs files
11:59:54 <dankna> no, I'm using my nascent support for having Cabal build hybrid Haskell-ObjC programs; I've been working with dcoutts to get it in, but he's being slow about reviewing my patches
12:00:00 <dylukes> .__.
12:00:03 <dylukes> Crazy.
12:00:05 <dankna> yes
12:00:11 <dylukes> Do you have much ObjC experience?
12:00:13 <dankna> a lot, yes
12:00:19 <dylukes> I can at least bring that to the table too, okay good.
12:00:23 <dylukes> I know the runtime inside and out ^^.
12:00:27 <dankna> good ^_6
12:00:28 <dankna> er ^_^
12:01:04 <dylukes> I'm considering writing a simple OO language this week,
12:01:08 <dankna> sounds fun
12:01:13 <dylukes> that just compiles (via haskell) one-to-one to C
12:01:18 <dylukes> using the objc runtime :P.
12:01:21 <dankna> ooh neat hehe
12:01:33 <dylukes> I'm thinking of doing something with actors.
12:01:37 <dankna> dylukes: okay I'm afk to make that mockup that I promised would be ready in five minutes, ten minutes ago.  well not afk but away from this window.
12:01:37 <Peaker> dankna: keep me posted about your progress!
12:01:41 <dylukes> I got around to implementing them using futures with GCD.
12:01:43 <dankna> Peaker: absolutely and thank you!
12:01:46 <dylukes> So I have lazy computation working :D
12:01:50 <dankna> yay for GCD
12:01:58 <geheimdienst> i still don't get that mission control thing. it looks like they made expose a little more useful again; i felt it clearly went downhill with the update after 10.4
12:02:15 <dylukes> geheimdienst: Lion changes window management a lot, for the better.
12:02:18 <dylukes> for us power users ^^
12:02:23 <dylukes> gestures and shortcuts for everything
12:02:31 <dylukes> you open it with three finger up
12:02:37 <dylukes> you can swap spaces in it, or outside it,
12:02:45 <dylukes> with ctrl-arrows or three finger swipes in any direction...
12:02:48 <geheimdienst> ... apart from that, "support for fullscreen apps"? that sounds ridiculous. every possible operating system supports fullscreen apps
12:03:03 <dylukes> plural.
12:03:04 <dylukes> apps.
12:03:05 <dylukes> At once.
12:03:26 <dylukes> Windows XP/Vista/7 don't support more than one at a time.
12:03:29 <geheimdienst> if they make some progress on the issue of keyboard shortcuts, that's great. i found the mac always lacking
12:03:32 <dylukes> Linux does with some hackery (like everything)
12:03:41 <dylukes> geheimdienst: Actually… they were always there just undocumented.
12:03:52 <dylukes> And you can easily use OSAX to hack in your own shortcuts to *every* menu item.
12:05:09 <dylukes> Are you for or against gesture shortcuts?
12:05:16 <xplat> dankna: what font did you use for your logo?
12:05:18 <dylukes> I personally find them pretty nice for some general things.
12:05:34 <dylukes> Can I see the logo danka?
12:05:36 <dankna> xplat: oh, I have to check, it's a fairly nice one isn't it?
12:05:36 <dylukes> dankna*
12:05:40 <dankna> dylukes: sure :)
12:05:45 <dylukes> I want to try to guess the font :D
12:05:49 <dylukes> inb4 lucida granda
12:05:50 <dankna> http://dankna.com/himitsu/how-many-dee.html -- the top logo
12:05:54 <dylukes> (sexiest sansserif font)
12:05:54 <geheimdienst> no i meant things like: in windows/linux, you could always press alt or f10 to focus the menu bar. on the mac it was something considerably less simple (ctrl-f2 if memory serves). then, selecting menu items didn't work well because if two items started with the same letter, they need an extra enter
12:06:03 <dankna> note that I edited the control points on the T, and it's custom-kerned as well
12:06:09 <geheimdienst> it all seemed not well thought out
12:06:15 <dylukes> I'll be honest. I like the "flat" one more >_>
12:06:20 <dylukes> The bottom one looks very 1990s
12:06:29 <dylukes> Can you send me the PSD? I'd like to toy with it ^^.
12:06:34 <dankna> I do too, I got rid of it
12:06:39 <dankna> it's in Illustrator, not Photoshop
12:06:46 <dankna> do you have Illustrator?  I can export to SVG if that would help you
12:06:51 <dylukes> I have Illustrator.
12:06:54 <dylukes> I own CS5 >_>
12:06:54 <dankna> great, then yes
12:06:57 <dankna> me too :)
12:07:07 <dylukes> I'm the only person under 20 who hasn't pirated it.
12:07:08 <dylukes> ^^.
12:07:14 <dankna> lol yeah, well done!
12:07:16 <dylukes> I get it for free through the university haha.
12:07:17 <dankna> I imagine you are
12:07:21 <dylukes> No way in hell I could afford it.
12:07:22 <dankna> http://dankna.com/himitsu/Te.ai
12:07:34 <dylukes> So, you're going to name it Te?
12:07:44 <xplat> Tree editor
12:07:50 <dylukes> Ah I see :)
12:07:57 <geheimdienst> dankna: how about teh? :)
12:07:58 <dylukes> You know,
12:08:02 <dylukes> apple has guidelines on icons too ;)
12:08:09 <xplat> twice as explanatory as vi
12:08:22 <dbpatterson> how can this have happened, and how do I get around it? (this occurs when I try to unregister a package that has been breaking all sorts of dependencies): ghc-pkg: /var/lib/ghc-6.12.1/package.conf.d/HTTP-4000.0.9-8aacce6d9ab5d0272b72d52bc52e4254.conf: removeLink: does not exist (No such file or directory)
12:08:50 <dankna> geheimdienst, it's to be pronounced "Tay"
12:08:59 <dylukes> Oh, one nice thing geheimdienst
12:09:03 <dankna> dylukes: yes I know they do :)
12:09:07 <dylukes> the built in preview app now opens a *lot*
12:09:22 <dylukes> It opens all of the office formats (dunno about open office though), and even colladas.
12:09:23 <dylukes> :|
12:09:27 <dylukes> So much for "pdf viewer" huh.
12:09:37 <dylukes> It's just a viewer, but nice to have built in,
12:10:29 <xplat> dankna: so which font?
12:10:35 <dankna> xplat: oh, let me look, I have it open now
12:10:40 <dylukes> TT_TT
12:10:42 <dylukes> Sad realization,
12:10:49 <dylukes> the only thing I've contributed to the haskell communitu
12:10:49 <dylukes> ,
12:10:56 <dylukes> is the color scheme on the Haskell Platform site
12:10:57 <dankna> xplat: it appears to be Myriad Pro
12:11:02 <dylukes> I really like those colors though.
12:11:03 <dankna> dylukes: this is your chance to contribute more :D
12:11:05 <dylukes> Myriad is a sexy font too!
12:11:10 <dankna> isn't it
12:11:19 <xplat> i'm unfamiliar with it other than seeing it in that logo
12:11:22 <dylukes> Lucida Grande though.
12:11:29 <dylukes> Nicest, most readable sans serif.
12:11:31 <dylukes> It's great.
12:11:35 <dylukes> (Facebook uses it, for reference)
12:11:42 <monochrom> dbpatterson: a happy desync of /var/lib/ghc-6.12.1/package.conf.d/package.cache and the rest
12:11:55 <dankna> Lucida is a fine font as well
12:11:58 <dylukes> Or maybe they don't anymore.
12:12:00 <geheimdienst> xplat: as i recall, it's apple's corporate font these days
12:12:01 <dylukes> dankna: font *family*
12:12:05 <dankna> yes, that
12:12:11 <dylukes> geheimdienst: Lucida grande is the UI font.
12:12:20 <geheimdienst> i know
12:12:34 <dylukes> Anyways, lets see about this icon
12:12:38 <dbpatterson> monochrom: getting rid of the HTTP file in that directory worked (it did not have the hash as part of the name, not sure how it got goofed up)…
12:13:00 <dankna> note that the .ai has a couple layers of decoration that I was thinking of adding on top of the flat thing
12:13:07 <dylukes> whats up with the other stuff?
12:13:09 <dylukes> Yeah
12:13:12 <dylukes> they look very 1990s >_>
12:13:15 <dankna> oh, those are other icons the program will use
12:13:26 <dylukes> going to be blunt, I don't like them,
12:13:27 <dankna> yeah - well I didn't want to add gradients and studio lighting
12:13:28 <dylukes> :P
12:13:29 <dankna> that's fine
12:13:40 <dylukes> Maybe if I get bored I could try improving them… never know.
12:13:42 <dankna> do you at least like the folder icon?  I slaved on that one
12:14:02 <dankna> the arrow pointing right is only for the first-run experience, it points to the text "Recent projects will appear here."
12:14:10 <monochrom> my http://www.vex.net/~trebla/haskell/sicp.xhtml#unsafeInterleave shows a way to get it, although I doubt that you do "cabal install --global" all that often
12:14:12 <benmachine> dylukes: if it makes you feel any better my contribution to the haskell community is a paragraph of the cabal user guide
12:14:36 <benmachine> ok that's unfair I've also maintained some stuff no-one cares about :P
12:14:50 <dylukes> I mean, the file one is okay
12:14:55 <dylukes> I just don't like the yellow.
12:15:00 <dankna> thanks, i'm glad the file one is okay.  yeah the yellow I dunno about.
12:15:07 <dylukes> Look at XCodes built in icons.
12:15:09 <dankna> that's #ffffcc, a color I've used for ages.
12:15:18 <dylukes> http://cl.ly/7UHN
12:15:20 <dylukes> pretty nice imo
12:15:26 <dankna> hmm I agree
12:15:32 <dankna> of course, we don't own those :) so we can't use them
12:15:55 <dankna> okay by the way
12:16:01 <dylukes> or
12:16:02 <dankna> the "file" icon is to represent a file /within/ a Te project
12:16:06 <dankna> so it doesn't have .te or anything on it
12:16:08 <dylukes> http://cl.ly/7UE3
12:16:17 <dankna> this is the generic one, which we can superpose an extension on
12:16:19 <dylukes> within the application, use the built in icons
12:16:22 <dylukes> they're there for a reason.
12:16:26 <dylukes> People recognize them.
12:16:34 <dankna> we don't own those icons and we are someday going to be cross-platform
12:16:38 <dylukes> The second you think you need your own custom icon suite, I think you've failed.
12:16:42 <dankna> and I want to use the same icon on all platforms
12:16:42 <dylukes> Well, write different interfaces.
12:16:52 <benmachine> dankna: why use the same icon on all platforms?
12:16:53 <dylukes> Using the same interface on all platforms dooms you to looking bad.
12:16:56 <dylukes> Or mediocre at best.
12:16:57 <dankna> benmachine: that's a point
12:16:59 <monochrom> just don't use icons
12:17:01 <dankna> dylukes: it will be a different codebase
12:17:17 <dylukes> Show me a mockup,
12:17:22 <dylukes> and I'll show you a better one.
12:17:23 <dylukes> Deal?
12:17:25 <dankna> dylukes: the program, as you'll see when you get your hands on it, is split into a Haskell back-end and an ObjC front-end
12:17:29 <dylukes> I have 4 more hours at the airport.
12:17:45 <ski> dankna : an Alfa screenshot <http://i.imgur.com/Qag5P.png>
12:17:47 <dankna> dylukes: heh!  ouch!  that reminds me that I'm supposedly doing a mockup of the divider bars right now
12:17:56 <dylukes> Can you show me a mockup of the whole thing?
12:17:59 <dankna> ski: oh interesting!  I approve of the use of proportional fonts
12:18:04 <dankna> dylukes: I can send you a .app ?
12:18:09 <dylukes> Sure.
12:18:28 <geheimdienst> dylukes: i disagree, i think the apple standard icons are less than well done. the different folder icons for instance all have an identical shape and color, except for tiny changes in contrast
12:18:39 <dylukes> Not those ones.
12:18:39 <ski> dankna : the window to the right shows dynamically computed shortcuts of keys to press to insert constructs or applications of operations, filtered through type checking
12:18:42 <dylukes> The black and white icons.
12:18:44 <ski> @where Alfa
12:18:45 <lambdabot> Proof editor, using Agda1 proof engine/checker, at <http://www.cse.chalmers.se/~hallgren/Alfa/>,(broken) <http://www.cs.chalmers.se/~hallgren/untested>,<http://ogi.altocumulus.org/~hallgren/untested>
12:18:45 <lambdabot> ,<http://ogi.altocumulus.org/~hallgren/untested/for_Linux/alfa-041029-bin-i386-Linux-RedHat9.tar.gz>,<http://ogi.altocumulus.org/~hallgren/untested/Source_code/alfa-050126.src.tar.gz>. Also see `
12:18:45 <lambdabot> Agda',`Fudgets',`GF'
12:18:46 <dankna> dylukes: http://dankna.com/himitsu/Te.zip
12:19:07 <ski> dankna : ^ if you want to try Alfa .. it's using Agda1 as proof-engine, a predecessor to Agda2
12:19:08 <byorgey> why is _everything in italics_ in that screenshot
12:19:25 <dankna> ski: sounds interesting, I'll look at it at some point
12:19:30 <dylukes> Okay, yeah I think I can improve this dankna
12:19:41 <byorgey> looks cool though
12:19:42 <dylukes> The new project/open project dialog can certainly be improved,
12:19:42 <dankna> dylukes: cool good :) do tell me how
12:19:48 <dylukes> I can also *show* you.
12:19:50 <monochrom> because everything in math is in italics
12:19:54 <ski> it happens for some reason that variables are displayed in italic
12:19:59 <dylukes> I would suggest aligning it more with the Xcode 4 menu.
12:20:04 * ski hasn't considered it before
12:20:11 <dylukes> http://cl.ly/7TTT
12:20:31 <dankna> I thought about that, I did look at that
12:20:34 <dankna> I actually don't like it
12:20:38 <dylukes> I don't like all of it.
12:20:44 <dylukes> But I do like some aspects of it.
12:20:45 <dylukes> Specifically,
12:20:48 <dylukes> the LACK OF HUGE BUTTONS.
12:20:49 <dylukes> >:(
12:20:53 <dankna> the most important buttons on there - "Open Other..." and "New" are too small (actually, "New" doesn't exist at all)
12:21:12 <dankna> they're a pain in the ass to click, resulting in me trying (and so far failing) to memorize the key shortcut for new project so I can do it that way instead
12:21:12 <dylukes> There are better ways to emphasize UI elements than size.
12:21:30 <dankna> it's not for showing their importance, it's to make them easy to click
12:21:48 <dylukes> hm, ill play with my own mockups
12:22:10 <dankna> please do :)
12:22:15 <dankna> let me send you the .xibs?
12:22:22 <dylukes> Oh, don't worry.
12:22:25 <dankna> okay
12:22:43 <dylukes> One thing I'd suggest btw,
12:22:45 <dylukes> moving forward,
12:22:46 <dankna> by all means
12:22:52 <dylukes> design this is a Document-Based App,
12:22:57 <dankna> not precisely
12:23:03 <dylukes> No, the reason I say so,
12:23:09 <dylukes> is it gives you a lot of for-free functionality on Lion
12:23:10 <dankna> a) there will be no master wrapper window, yes, I hate that in XCode
12:23:20 <dylukes> as in, you get auto-saving, versions, resume support, etc all for free.
12:23:24 <dankna> b) no, Lion's version-control won't work with what I'm doing
12:23:27 <dylukes> Just follow the contract for the NSDocument support.
12:23:32 <dylukes> How so?
12:23:37 <dankna> c) I can't be an NSDocument, I already tried
12:23:43 <dylukes> ?
12:23:45 <dankna> because there's one file on disk, the "project", which contains its own filesystem
12:23:56 <dylukes> Explain...?
12:23:58 <dankna> the illusion that I'm preserving is that the project itself is always in synch with what's on the disk
12:24:03 <dylukes> Also, an NSDocument doesn't have to represent a single file.
12:24:12 <dankna> so anything like moving or renaming of files is written through in a single transaction
12:24:15 <dylukes> Right, that's the goal of the Lion auto-saving too.
12:24:23 <dylukes> No point in reinventing the wheel.
12:24:24 <dankna> no the problem is that an NSDocument represents /less/ than a single file
12:24:26 <dankna> for me
12:24:35 <dylukes> your "document" is a file.
12:24:37 <dylukes> er, a project
12:24:51 <dylukes> for instance, Xcode treats files, projects and workspaces as individual NSDocuments.
12:24:55 <dylukes> Which, may contain each other.
12:24:55 <dankna> no, because each "file" within the project has its own save state, undo history, and all that
12:25:00 <dylukes> Thus, changes are propagated down.
12:25:08 <dankna> mm, I didn't realize that, but.
12:25:17 <dylukes> For instance, consider,
12:25:24 <dylukes> in Xcode you have per-file history
12:25:30 <dylukes> despite the fact that your "Document", a project,
12:25:33 <dylukes> is a directory
12:25:44 <dylukes> Actually, its a few directories, and a file pretending to be a directory.
12:25:50 <dankna> yes, but each file exists on disk, in XCode's case
12:25:52 <dylukes> er, a directory pretending to be a file*
12:26:01 <dylukes> They don't have too.
12:26:05 <dylukes> they're weakly linked resources.
12:26:16 <dylukes> It's possible to weakly link in a file that exists on say, a mounted drive
12:26:24 <dylukes> or, on a web service through FUSE
12:26:24 <dankna> that's a nice notion, but in fact when you get into the details, as I'm sure you're aware, the single most important methods in NSDocument are the ones that load and save
12:26:52 <dylukes> Yeah.
12:26:57 <dylukes> But consider what your "document" is.
12:27:05 <dankna> and my "files" can't be represented as blobs (roughly, as NSDatas), either, because they're composed of rows in multiple tables in a database
12:27:24 <dylukes> also, I suggest you look at NSDocument as of 10.7 >_>
12:27:26 <dankna> when I get access to Lion, which will probably be the same time as everyone else because I don't want to pay $99
12:27:28 <dylukes> It's significantly different.
12:27:35 <dankna> careful, you're under NDA on that
12:27:37 <dankna> and I'm not
12:27:39 <dankna> anyway,
12:27:47 <kmc> haskell?
12:27:48 <dylukes> Nope, I'm not.
12:27:55 <dylukes> maybe we should query instead.
12:28:31 <Jafet> Haskell is the answer, not the question.
12:28:46 <kmc> @faq What is the question?
12:28:46 <lambdabot> The answer is: Yes! Haskell can do that.
12:28:50 <monochrom> the answer looking for a question
12:29:02 <kmc> @. elite faq How can I be more eleet?
12:29:02 <lambdabot> +|-|3 4NzWER is: YeS! Hasx31| (AN dO t|-|at.
12:29:21 <monochrom> @vixen what questions does haskell answer?
12:29:22 <lambdabot> church is my favourite computer scientist.
12:29:43 <monochrom> that is jeopardy-grade! :)
12:31:49 <benmachine> lb prefers church to curry? how about that.
12:32:02 <geheimdienst> okay, ghci tells me "no instance for Show UTCTime" when i do "print =<< getCurrentTime". a minimal program works, however. how can this be?
12:32:14 <geheimdienst> (assuming Data.Time.{Format,Clock} are imported)
12:32:49 <shachaf> geheimdienst: :m + Data.Time?
12:33:05 <shachaf> instance Show UTCTime -- Defined in time-1.1.4:Data.Time.LocalTime.LocalTime
12:33:52 <chrisdone> So, that's why hpaste went down last night. :/
12:33:55 <chrisdone> amelie[13278]: segfault at b64fef70 ip b788377c sp b64feedc error 6 in libpcre.so.3.12.1[b7872000+2f000]
12:33:59 <chrisdone> God damn C libraries!
12:34:20 <Jafet> benmachine: familiarity breeds contempt, etc
12:34:35 <Jafet> @quote integerToBreakfast
12:34:35 <lambdabot> integerToBreakfast says: = (["Cornflakes", "Strawberry jam toast", "Grapefruit", "Cup of tea and a biscuit, gotta dash", "Bacon, eggs, toast, tomato and mushroom. You deserve it", "Waffles", "
12:34:35 <lambdabot> Porridge of some description", "Orange juice and muffins", "Apples, pears, mango and kiwi", "A selection of cold meats with crisp bread", "Headache pills and water", "Leftover pizza", "Leftover
12:34:35 <lambdabot> vindaloo curry"] !!)
12:35:11 * benmachine is atheist and has curry paste
12:35:52 <kmc> Caltech's CS 1 course contains a truly wretched "separation of church and state" pun
12:36:15 <geheimdienst> okay importing Data.Time fixed it, but the question remains why i have to do that in ghci and not in ghc
12:36:56 <chrisdone> I'm so sick of C libraries segfaulting my Haskell programs.
12:37:22 <c_wraith> geheimdienst: ghc has some non-trivial-to-cause bugs causing instances to be in scope when they shouldn't be
12:37:52 <Cale> chrisdone: Regular expressions are BS too...
12:38:01 <Jafet> Use the pugs regex engine and smirk
12:38:25 <Cale> We need a haskell-y highlighter library which doesn't use regular expressions at all.
12:38:31 <chrisdone> Agreed.
12:38:31 <copumpkin> I agree
12:38:32 <geheimdienst> c_wraith: interesting. under that theory, i found a 3-line example program that triggers one of those bugs
12:38:45 <Jafet> Using haskell-src?
12:38:46 <geheimdienst> should i submit it to some bugtracker or something?
12:38:50 <c_wraith> yeah, you should
12:39:01 <Jafet> What does hscolour use?
12:39:07 <chrisdone> (Yeah, highlighter library is using pcre-light.)
12:39:21 <geheimdienst> i've got to run now, but i'll check with #ghc on that issue tonight
12:40:18 <chrisdone> Seems to be a custom parser, no dependencies apart from base.
12:40:45 <monochrom> haskell-src may be overkill
12:41:18 <monochrom> and underkill at the same time. highlighters are expected to try its best in spite of blatant syntax errors
12:41:27 <chrisdone> Indeed.
12:41:44 <kmc> most highlighters do only lexical analysis, or maybe lexical + basic nesting
12:42:35 <Eliel> We're using HaskellDB for a project we're working on and We've made a nice newtype monad that's basically ReaderT Database IO a. Also a nice withDb wrapper to run it all so the database reference doesn't need dragging along. But here's a snag. HaskellDB's transaction function is typed Database -> IO a -> IO a ...
12:42:37 <chrisdone> I was (and am) going to use haskell-src-exts to parse hpastes (if they parse), and display a pretty printed kind of collapsible view of the code. Thought it would be nice.
12:43:17 <Eliel> Did we just waste our effort making this nice monad instance to simplify our code?
12:43:43 <monochrom> does it simplify your code?
12:43:45 <c_wraith> Eliel: no.  Just write your own withTransaction function that works correctly with your types, and use it instead.
12:44:40 <Eliel> c_wraith: I'll take a shot at that, as soon as I find where haskellDB has hid the real transaction function.
12:45:04 <c_wraith> Eliel: just call its withTransaction function.  It's easier than you think.
12:45:33 <Eliel> haskellDB has withTransaction?
12:45:45 <c_wraith> well, whatever the function you were using is.
12:45:47 <tgeeky> can someone point me to any .jpeg or .png or otherwise - text ORC tools on hackage?
12:45:59 <c_wraith> looks like it's just named transaction, I guess
12:46:38 <Eliel> I'd call it but while I can fix it's return type by lifting it, I have no idea how to lift the parameter it takes so it'll take functions written to work with this DBConnection monad we made.
12:46:41 <tgeeky> or at least point me to which category I should look in? :o
12:47:00 <kmc> tgeeky, i usually ignore the category, just do Ctrl-F
12:47:06 <parcs> :t ask -- Eliel
12:47:07 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
12:47:07 <kmc> you want OCR?
12:47:21 <tgeeky> kmc: yeah, I think that's the right term
12:47:29 <kmc> i don't see anything
12:47:32 <tgeeky> kmc: me neither.
12:47:39 <kmc> maybe the best you can do is find a C library and wrap it
12:47:46 <c_wraith> Eliel: you just deconstruct it down to IO, then build it back up when it's done
12:47:48 <chrisdone> I don't suppose it'd be hard to write a tokenizer with Parsec.
12:47:59 <kmc> if you can make a nice wrapper it would be great to upload it
12:48:07 <chrisdone> Has anyone, per chance, already written a simple Haskell tokenizer?
12:48:33 <kmc> is the tokenizer of haskell-src-exts separable?
12:48:39 <chrisdone> Hm, could be, I'll see.
12:48:45 <kmc> does GHC still use Alex + Happy?
12:49:23 <parcs> does anyone recommend a particular irc client library?
12:49:42 <Eliel> c_wraith: ok, thank you. I'll see if I can figure it out.
12:49:54 <siracusa> kmc: Are you sure GHC uses Alex? It doesn't support Unicode, afaik
12:50:00 <kmc> i'm not sure
12:50:03 <c_wraith> Eliel: if you were using exactly ReaderT, it'd look something like:  \action -> do { env <- ask ; lift $ transaction (runReaderT action env) }
12:50:12 <kmc> maybe it has a custom lexer
12:50:18 <kmc> i thought it used Happy at one point, anyway
12:50:19 <chrisdone> parcs: simple-irc is simple, but I tend to just use Network.IRC and Network as these client libraries always miss something I need.
12:50:42 <Eliel> c_wraith: ah, thank you. Now I understand :)
12:50:45 <c_wraith> Eliel: the idea is that you can take it out of your wrapper, then put it back in, without losing anything.  This can be done with any monad transformer, but is easiest with ReaderT
12:50:51 <chrisdone> Ah, it has a .ly file.
12:51:03 <chrisdone> What is that, alex or happy?
12:51:10 <siracusa> happy
12:51:10 <parcs> chrisdone: Network.IRC from the 'irc' package?
12:51:16 <chrisdone> parcs: Yeah.
12:51:20 <chrisdone> siracusa: Ah, okay.
12:51:41 <parcs> thanks for the suggestion
12:51:43 <chrisdone> Ah, sweet. Here's the lexer.
12:52:20 <chrisdone> Nice, looks pretty separable. module Language.Haskell.Exts.Lexer (Token(..), showToken, lexer)
12:52:51 <xplat> dankna: i know it differs from your original concept, but, submitted for your approval: http://ompldr.org/vOHpvNg/telogo0s.png
12:53:23 <dankna> xplat: looking!
12:53:25 <Eliel> monochrom: yes, I believe it does simplify the code.
12:53:31 <dankna> heh!  that differs substantially
12:53:40 <kmc> i wrote a program to solve Kakuro puzzles using the list monad, it's nothing groundbreaking, but do y'all think i should write a quick blog post about it?
12:53:45 <dankna> I don't feel it's as strong visually - as an amateur photographer I think about things like how the lines lead your eye
12:53:46 <kmc> might be a useful example
12:53:47 <monochrom> if what you do simplifies your code, your effort is not wasted
12:53:50 <chrisdone> kmc: Sounds fun!
12:53:51 <kmc> also, any way to make this more interesting?
12:54:04 <kmc> i was thinking of trying out this 'parallel-tree-search' library
12:54:05 <dankna> one sec though, talking to dylukes off-channel
12:54:06 <chrisdone> kmc: Make it faster? :p
12:54:08 <ehamberg> kmc: i'd love to read that. :)
12:54:45 <dankna> xplat: a concept that looks like a tree could work, but I'd make the green region larger and covering more of the frame
12:54:50 <dankna> xplat: and the e should be larger too
12:54:51 <dylukes> xplat: I see a tree. I don't see "Te" unless I'm looking for it.
12:55:08 <dankna> xplat: also, leaves needn't be green.  leaves can be yellow!
12:55:14 <dylukes> oh hm.
12:55:16 <dankna> xplat: which would let you use my original color scheme :)
12:55:17 <dylukes> I had an icon idea.
12:55:20 <dylukes> Maybe I'll try ti.
12:55:43 <dankna> yeah, you can try different names if you want.  for what it's worth, I have been thinking of pronouncing it "tay"
12:55:56 <dylukes> Put an accent on the 'e'!
12:55:58 <dylukes> Be fancy :P
12:56:13 <chrisdone> I move away from the mic to type in my editor.
12:56:39 <kmc> :t msum . map return
12:56:39 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [a] -> m a
12:56:49 <kmc> any name for that?
12:57:39 <djahandarie> @ty msum . fmap pure
12:57:40 <lambdabot> forall (m :: * -> *) a. (MonadPlus m, Applicative m) => [a] -> m a
12:58:02 <benmachine> :t maybe mzero return
12:58:03 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
12:58:05 <djahandarie> @ty Data.Foldable.msum . fmap pure
12:58:06 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Foldable.Foldable t, MonadPlus m, Applicative m, Functor t) => t a -> m a
12:59:06 <benmachine> you can get rid of that Functor constraint on t
12:59:14 <benmachine> using some sort of foldMap
13:03:44 <chrisdone> Annoyingly that lexer module isn't exported. All libraries have cool modules that they don't export.
13:05:42 <chrisdone> Ah, haskell-src does export the Lexer. As does, surprise surprise, haskell-lexer.
13:08:11 <ClaudiusMaximus> arrg.  i managed to install 'ad' with ghc-6.12.3 by specifying -fTemplateHaskell24 : but i can't install a package that depends on it because cabal chases dependencies and thinks 'ad' needs template-haskell==2.5.*
13:09:23 <benmachine> ClaudiusMaximus: maybe try a --constraint? or a --preference?
13:09:29 <benmachine> I can never remember the difference
13:10:22 <ClaudiusMaximus> benmachine: --preference didn't work, but --constraint seems to be working - thanks!
13:12:49 * hackagebot text-format 0.2.1.0 - Text formatting  http://hackage.haskell.org/package/text-format-0.2.1.0 (BryanOSullivan)
13:17:06 <xplat> dankna: it does seem a little more dull, and there's a tension between the size of the 'e' for readability and making it look like a fruit
13:18:26 <djahandarie> I think text-format needs some examples
13:18:29 <xplat> the other idea i had was an orange chainsaw or hedge trimmer with your original triangle behind it, but i don't really feel up to drawing something like that in inkscape
13:18:59 <dylukes> .__.
13:19:15 <ClaudiusMaximus> ...and now it's gone wrong, with a Gtk2HsSetup compile failure
13:19:28 <ClaudiusMaximus> is that solved yet?
13:19:47 <djahandarie> Oh wow, it's pretty simple to use
13:19:51 <xplat> (and if i did it probably wouldn't be recognizable :-7 )
13:20:00 <djahandarie> Not sure if I'd actually like to use it though...
13:20:26 <dankna> xplat: yeah I agree on both counts
13:21:37 <Eliel> I was looking for a way to convert Word8 into Char and I did figure out a way. It just feels way more complex than should be necessary. This works: let c = chr (toInteger . fromInteger) a. Is there a simpler way?
13:21:53 <Eliel> a would be of type Word8
13:22:41 <NemesisD> anyone work with wai/wai-extra? i'm having a hard time finding examples of how to work with a raw response body
13:22:59 <dylukes> @hoogle Word8 -> Char
13:23:00 <lambdabot> Data.ByteString.Internal w2c :: Word8 -> Char
13:23:00 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
13:23:00 <lambdabot> Prelude show :: Show a => a -> String
13:23:04 <monochrom> chr (fromIntegral a)
13:23:08 <dylukes> w2c looks promising.
13:23:10 <dylukes> @src w2c
13:23:11 <lambdabot> Source not found. Take a stress pill and think things over.
13:23:20 <dylukes> @src Data.ByteString.Internal.w2c
13:23:21 <lambdabot> Source not found.
13:23:24 <monochrom> except it doesn't do UTF-8
13:24:06 <dylukes> oh hm
13:24:14 <Eliel> I just need to get some bytestrings through haskelldb without postgresql puking on the result :)
13:26:28 <Eliel> I'm rather surprised ByteString doesn't seem to have a function to convert to and from String.
13:26:36 <Eliel> (if it does, I'm blind)
13:26:50 <djahandarie> pack and unpack
13:26:57 <Eliel> those give [Word8]
13:27:00 <c_wraith> you're not blind.
13:27:02 <monochrom> Data.ByteString.Char8 and Data.ByteString.Lazy.Char8
13:27:10 <c_wraith> there's information missing between bytestring and String
13:27:20 <monochrom> but then I detest them
13:27:21 <c_wraith> String is unicode.  bytestring is bytes
13:27:37 <djahandarie> Right. It's best to just use the text library.
13:27:39 <c_wraith> the missing information is "what encoding are the bytes in?"
13:28:06 <nihtml> :t chr
13:28:07 <lambdabot> Int -> Char
13:28:12 <Eliel> well, in this case, it's binary garbage base64encoded :)
13:28:28 <Eliel> so... shouldn't make problems.
13:29:23 <chrisdone> Alternatively, you can use Data.ByteString.UTF8 fromString and toString.
13:30:17 <djahandarie> Isn't text recommended rather than utf8-string?
13:30:27 <benmachine> djahandarie: depends on use somewhat
13:30:43 <monochrom> yes if string takes too much memory for you
13:30:45 <benmachine> strings are more convenient to the programmer, usually
13:30:52 <chrisdone> djahandarie: For quick translations in small things, I use utf8-string.
13:34:31 <chrisdone> Ah, like here:
13:34:33 <chrisdone> pid <- (>>= readMay) . fmap (toString) <$> getParam "id"
13:35:01 <Johnny> Hello
13:35:17 <Guest57442> Anybody here?
13:35:28 <Guest57442> No?
13:35:30 <tgeeky> can someone tell me why the example in RWH chapter 7 (file: ch07/toupper-lazy1.hs
13:35:38 <tgeeky> would fail to parse a dictionary with the error:
13:35:58 <tgeeky> "cmmitBuffer: invalid argument (characte is not in the code page)"
13:36:11 <tgeeky> with things spelled correctly, of course. UTF8 or something in the file?
13:36:21 <tgeeky> ref: code here http://book.realworldhaskell.org/read/io.html
13:36:22 <monochrom> probably. CHCP 65001
13:36:45 <tgeeky> invalid argument UTF-8 byte sequence
13:36:46 <monochrom> and windows-12xx should just die die die
13:36:50 * chrisdone changes that to pid <- (fmap toString >=> readMay) <$> getParam "id"
13:36:52 <Jafet> Error: you're using Windows; stop using Windows
13:37:12 <tgeeky> I could be doing RWH in linux, but my base OS has to be linux unless Nvidia wants to get their act together
13:37:20 <tgeeky> s/base os has to be windows/
13:37:23 <tgeeky> *sigh*
13:37:57 <monochrom> you could use linux in a virtual machine :)
13:38:03 <Jafet> Run linux on top with mesa
13:38:17 <tgeeky> monochrom: i have one running, but I am just using it for lambdabot for the moment
13:38:18 <NemesisD> man there is a real lack of sample code for warp servers that do something other than discard their input and print hello world
13:38:40 <tgeeky> monochrom: how do I undo whatever chcp.com 65001 did? :o
13:39:13 <tgeeky> because now it doesn't work at all
13:39:26 <monochrom> why do you want to undo it? it sets code page to utf-8 which is the preferred code page since 1998
13:39:33 <monochrom> or 1996
13:39:43 <tgeeky> monochrom: now the same code segment doesn't output anything at all
13:40:02 <monochrom> undoing it isn't an improvement anyway.
13:41:25 <monochrom> where can I find the "dictionary"?
13:41:58 <tgeeky> included in wolfram mathematica
13:42:01 <tgeeky> i can post it somewhere
13:42:12 <monochrom> eh? the program doesn't output to stdout. it writes to output.txt
13:42:22 <tgeeky> monochrom: correct
13:42:27 <tgeeky> it still gives that error message
13:42:49 <monochrom> then I really need the input file to discern its encoding
13:42:54 <tgeeky> ok
13:43:31 <Nordvind> why would a HOpenGL program minimize by itself, when run from terminal?
13:44:03 <Nordvind> works fine when run from file manager (nautilus)
13:45:28 <Nordvind> I used GLUT =)
13:56:40 <tgeeky> monochrom: sorry for the delay - dict.txt and output-lazy1.txt at http://www.d-rive.org/
13:58:45 <monochrom> it uses iso-5589-1
13:59:21 <monochrom> I don't know which windows code page does iso-8859-1, but you can choose encoding in ghc too
14:00:21 <monochrom> hSetEncoding inh latin1
14:02:16 <tgeeky> monochrom: and out, that worked, thanks, and thanks for the patience
14:03:07 <monochrom> inh and outh can use different encodings!
14:03:18 <tgeeky> monochrom: yeah, it was outh that was the problem, not inh
14:03:22 <tgeeky> evidently
14:06:51 <anicknamething> o_o
14:07:04 <kmc> ^____^
14:08:23 <acowley> The answers on the haskell SO are almost comically good.... except when there are no happy answers.
14:22:34 * roconnor is confused by Enumeratees
14:22:53 <kmc> well when an enumerator and an iteratee love each other very much
14:22:54 <benmachine> join the club
14:22:57 <ivanm> roconnor: I believe that's a common affliction
14:23:09 <roconnor> specifically I don't understand the type
14:23:10 <benmachine> the club >>= id
14:23:15 <kmc> snap
14:23:18 <kmc> :t ?the ?club >>= id
14:23:19 <lambdabot> forall t (m :: * -> *) b. (?the::t -> m (m b), ?club::t, Monad m) => m b
14:23:35 <roconnor> in particular I don't understand why (Step ai m b) occurs in the codomain
14:24:39 <roconnor> maybe I should give up for nw
14:28:37 <roconnor> The worst thing is that the Yesod book's chapter on enumeratees skips over why this type is the way it is
14:28:45 <roconnor> so frusterating
14:29:58 <ivanm> roconnor: there was a talk on iteratees in the monad reader last year IIRC
14:30:28 <ivanm> s/talk/discussion/
14:30:32 <roconnor> ah
14:31:07 <ivanm> but I think enumeratees have a different type/API
14:32:16 <tromp> @let evens = [4,10,16,30,60,66]
14:32:17 <lambdabot>  Defined.
14:32:38 <tromp> @let odds = [1,7,13,37,43,97]
14:32:39 <lambdabot>  Defined.
14:32:42 <roconnor> I think I vaguely understand interatees and enumerators
14:32:46 <c_wraith> tromp: those lists are missing some numbers
14:33:00 <tromp> > [e+o| e<-evens,o<-odds]
14:33:02 <lambdabot>   [5,11,17,41,47,101,11,17,23,47,53,107,17,23,29,53,59,113,31,37,43,67,73,127...
14:33:41 <tromp> @let primes =  [e+o| e<-evens,o<-odds]
14:33:43 <lambdabot>  Defined.
14:33:52 <tromp> i know:)
14:34:13 <tromp> > nub . sort $ primes
14:34:14 <lambdabot>   [5,11,17,23,29,31,37,41,43,47,53,59,61,67,73,79,97,101,103,107,109,113,127,...
14:37:03 <Evious> :t nub
14:37:04 <lambdabot> forall a. (Eq a) => [a] -> [a]
14:39:25 <mm_freak_> what is the exact name of the theoretical foundation that is haskell's type system and is there some page describing it?  i know that people usually talk about hindley-milner, but that is only about the type inference part…  i assume that haskell has some kind of a limited system F_omega type system
14:39:44 <tromp> @let primesT = 2 : sieve [3,5..]  where sieve (p:xs) = p : sieve [x | x<-xs, rem x p /= 0]
14:39:45 <lambdabot>  Defined.
14:39:54 <tromp> > take 22 primesT
14:39:55 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79]
14:40:14 <kmc> mm_freak_, for GHC Haskell look at System Fc
14:40:20 <mm_freak_> tromp: that is not a sieve
14:40:28 <kmc> it has "coercion kinds" to deal with gadts, type families, etc.
14:40:35 <tromp> > primes \\ (take 42 primesT)
14:40:36 <lambdabot>   [11,17,47,17,23,53,67,73,67,73,103]
14:40:51 <tromp> no, it's not; it's trial division
14:41:21 <tromp> > nub (sort primes) \\ (take 42 primesT)
14:41:22 <lambdabot>   []
14:41:34 <mm_freak_> kmc: does h2010 together with some extensions yield F_omega?
14:41:49 <kmc> not quite
14:41:56 <kmc> because type abstraction / type application are still implicit
14:41:58 <tromp> i just copied that from http://www.haskell.org/haskellwiki/Prime_numbers
14:42:13 <mm_freak_> kmc: so you need real type functions to get F_omega?
14:42:38 <kmc> "real type functions" is a separate issue
14:42:50 <kmc> System F has explicit type abstraction / application, and no type functions
14:43:00 <c_wraith> GHC's impredicativity support is also really limited still
14:43:12 <kmc> the point is in Haskell you write «map ord "abc"» and not «map Char Int ord "abc"»
14:43:25 <mm_freak_> ah, i see
14:43:51 <kmc> map = Λa. Λb. λ(f : a → b). λxs. …
14:43:58 <kmc> er λ(xs : [a])
14:44:19 <saati> what layout do you use for such characters?
14:44:23 <mm_freak_> but when you write (map :: (Char -> Int) -> [Char] -> [Int])) ord "abc", doesn't that give you the same result?
15:36:06 <dankna> okay so some hours ago I promised a GUI mockup "in five minutes"
15:36:07 <dankna> http://dankna.com/himitsu/split-bar-mockup.png
15:36:45 <dankna> direct your attention to the two thick horizontal divider bars
15:37:04 <dankna> these are draggable to reposition (dragging the bottome one creates a new thing), so they need to look "active", too.
15:37:20 <copumpkin> what'd you write that in?
15:37:26 <dankna> ObjC
15:37:38 <copumpkin> putting a himitsu in a 750-user channel isn't wise
15:37:40 <copumpkin> :)
15:37:42 <copumpkin> but it looks nice
15:37:47 <dankna> it's an unlistable directory :)
15:37:48 <dankna> thanks!
15:37:58 <dankna> more important than how it looks - does it serve its purpose :)
15:38:05 <copumpkin> I don't know
15:38:06 <copumpkin> what does it do?
15:38:25 <dankna> gives information (cursor position and line count) about the frame above it, and serves as a title bar for the frame below it
15:38:35 <dankna> it's clear which information is associated with which frame?  that was my biggest concern
15:38:55 <kmc> good filler text
15:38:57 <dankna> (and is why I went to all the work of drawing that bezier)
15:39:00 <dankna> kmc: thank you!
15:39:06 <copumpkin> I'd put a tiny bit of the white bar along the top of the gray bottom bit
15:39:08 <copumpkin> if that makes sense
15:39:12 <copumpkin> make it stick out a bit more
15:39:19 <dankna> hmm yes
15:39:21 <dankna> it makes perfect sense
15:39:30 <dankna> I had been considering the opposite, but your way works too
15:39:40 <copumpkin> you could do both
15:39:48 <dankna> true!
15:39:49 <copumpkin> make the gray extend along the bottom and the white extend along the top
15:39:50 <copumpkin> dunno :)
15:39:58 <thoughtpolice> dankna: what're you working on?
15:39:59 <dankna> well, clearly, I'll have to try it
15:40:09 <dankna> thoughtpolice: this is the structure editor for Haskell code, the Mac GUI for it
15:40:28 <thoughtpolice> 'structure editor for haskell code'?
15:40:35 <copumpkin> I'd love to have a nice native app for writing haskell in objc
15:40:40 <dankna> Peaker inspired me
15:40:42 <copumpkin> not the fact that it's in objc, mind you
15:40:45 <thoughtpolice> aaaahhh
15:40:45 <dankna> yes
15:40:50 <copumpkin> but the fact that it's mac-like :)
15:40:52 <thoughtpolice> i think i remember Peaker talking about his philosophy on this matter
15:41:02 <dankna> well, the best part is that the backend of it is in portable Haskell
15:41:09 <copumpkin> cool!
15:41:09 <dankna> so it can get multiple platform front-ends, including a terminal one
15:41:13 <dankna> yes :)
15:41:31 <dankna> I am working with dcoutts to get my changes to Cabal that let it build polyglot executables into the tree
15:41:37 <thoughtpolice> EMACS IS THE END ALL
15:41:39 <thoughtpolice> DO NOT RESIST
15:41:42 <dankna> so far it's been about a week and a half since I submitted the first round of patches
15:41:42 * thoughtpolice /borg
15:41:51 <dankna> I understand he's busy of course :)
15:42:07 <cmccann> pff emacs
15:42:10 <cmccann> ed is the standard editor
15:42:38 <dankna> Te (my editor, unless someone comes up with a great icon concept that only works if I change the name) aspires to be the one that people make jokes about :)
15:42:52 <thoughtpolice> dankna: ah, what else will the cabal changes allow you to build?
15:43:00 <ivanm> is there a function like mapM_ but reverses the order?  I'm using it within a State monad that contains a Map a [a] and I'm using it to add values to the lists... but I want the order in the lists to be the same as within the original list :s
15:43:16 <kmc> :t mapM_ ?f . reverse
15:43:17 <lambdabot> forall a (m :: * -> *) b. (?f::a -> m b, Monad m) => [a] -> m ()
15:43:23 <dankna> thoughtpolice: nothing else is written against them yet, but in principle, anything that has a mix of C-family languages and Haskell.
15:43:31 <ivanm> kmc: yeah, I'm using that atm; but surely there's a _better_ alternative... :/
15:43:35 <dankna> probably anything that's pure C-family, too, but that's hardly an important use-case.
15:43:36 <kmc> why would that be sure
15:43:45 <thoughtpolice> dankna: ah ok, i thought you had something more specific in mind. but that's awesome too :)
15:43:55 <dankna> thoughtpolice: oh, well my project that you see in the screenshot
15:44:02 <thoughtpolice> ah
15:44:04 <ivanm> kmc: OK s/surely/hopefully/
15:44:19 <kmc> ivanm, should there be a reversed version of every list function?
15:44:27 <kmc> what's wrong with (. reverse) as a way to say "do this in reverse"
15:44:37 <thoughtpolice> time to go home!
15:44:44 <ivanm> kmc: yeah, I suppose...
15:44:53 <kmc> there is at least one package on Hackage which contains only C code
15:45:07 <dankna> wow, really?  what is it?
15:45:10 <kmc> bindings-DSL
15:45:14 <ivanm> oh well, I suppose it's not like it's being used in a function that will be called often... (except when testing)
15:45:27 <dankna> thoughtpolice: oh right, and also I didn't mention that it builds .app bundles (yes I'm aware of cabal-mac)
15:45:36 <kmc> ivanm, why do you think (mapM_ f . reverse) will be slower than a hypothetical reverseMapM_?
15:45:44 <dankna> fascinating
15:46:06 <ivanm> kmc: reverse is O(n^2), isn't it?
15:46:25 <parcs> it's O(n)
15:46:43 <kmc> it just walks to the end of the list and starts feeding you elements as it unwinds its stack
15:46:50 <kmc> @src reverse
15:46:50 <lambdabot> reverse = foldl (flip (:)) []
15:46:53 <kmc> ;P
15:46:54 <ivanm> oh? fair enough then
15:47:01 <ivanm> I thought it was n^2 for some reason... :/
15:47:17 * kmc rants about asymptotic complexity
15:47:20 <kmc> also, one hopes it will fuse with mapM_
15:47:21 <parcs> :t let reverse (x:xs) = reverse xs ++ [x]; reverse [] = [] in reverse -- O(n^2)
15:47:22 <lambdabot> forall t. [t] -> [t]
15:47:31 <kmc> so that you don't generate an intermediate reversed list
15:47:42 <ivanm> parcs: yeah, that's pretty much what I was thinking it was :/
15:48:09 <thoughtpolice> dankna: ooo! sounds like a major plus IMO :)
15:48:35 <Eliel> one of the biggest annoyances when debugging my haskell code for type errors is that ghci doesn't load anything from the file if one function has a type error. Not too handy, considering it's the types of the other functions that are often the biggest clue as to what's wrong.
15:48:40 <kmc> > let reverse = go [] where { go ys (x:xs) = go (x:ys) xs; go ys [] = ys } in reverse "abcde"
15:48:41 <lambdabot>   "edcba"
15:48:57 <kmc> Eliel, yeah.  you can set the erroring value to "undefined"
15:49:01 <dankna> thoughtpolice: I think so!
15:49:08 <kmc> :t let f = undefined; x = undefined; y = f x in f
15:49:09 <lambdabot> forall a. a
15:49:22 <Eliel> kmc: I'm doing that, it just slows things down as I usually have to comment things out too.
15:49:26 <kmc> hmm, that's not what i expected
15:49:46 <kmc> mm right it specializes f independently
15:49:53 <kmc> :t let f = undefined + y; x = undefined; y = f x in f
15:49:54 <lambdabot>     Occurs check: cannot construct the infinite type: a = a1 -> a
15:49:54 <lambdabot>     Probable cause: `f' is applied to too many arguments
15:49:55 <lambdabot>     In the expression: f x
15:50:19 <geheimdienst> once again, my feeble understanding of typeclasses and stuff could not appease the gods of haskell: http://hpaste.org/47630 could you guys have a look? it should be self-explanatory
15:50:22 <ivanm> Eliel: yeah, it can be frustrating
15:50:29 <parcs> :t let f :: forall a. a; f = undefined + y; x = undefined; y = f x in f
15:50:30 <lambdabot>     Could not deduce (Num a) from the context ()
15:50:30 <lambdabot>       arising from a use of `+' at <interactive>:1:26-38
15:50:30 <lambdabot>     Possible fix:
15:50:31 <ivanm> geheimdienst: we have gods of haskell? :o
15:50:38 <Eliel> would be quite a good usability improvement to have it load what it can.
15:50:48 <ivanm> Eliel: IIRC, HBC used to do that...
15:51:08 <aavogt> Eliel: or even simpler (to implement) might be to load the same module when it last worked. But that might get confusing depending on what's changed
15:51:23 * hackagebot json-builder 0.2.1 - Data structure agnostic JSON serialization  http://hackage.haskell.org/package/json-builder-0.2.1 (LeonSmith)
15:51:31 <ivanm> geheimdienst: what does addUTCTime do?
15:51:31 <pikhq_> ivanm: Sure.
15:51:37 <geheimdienst> ivanm: they tend to show themselves in inscrutable messages on the screen, like "SpecConstr warning" and such
15:51:38 <pikhq_> :t zip`ap`tail
15:51:39 <lambdabot> forall b. [b] -> [(b, b)]
15:51:41 <Eliel> aavogt: less useful, especially when you're trying to refactor code :)
15:51:47 <ivanm> @quote zip`ap`tail
15:51:48 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
15:51:53 <ivanm> pikhq_: ^^ is that what you meant?
15:51:56 <pikhq_> Yup.
15:52:05 <ivanm> he's not a _haskell_ god though!
15:52:16 <geheimdienst> ivanm: add a Num and an UTCTime
15:52:21 <geheimdienst> @hoogle addUTCTime
15:52:21 <lambdabot> Data.Time.Clock addUTCTime :: NominalDiffTime -> UTCTime -> UTCTime
15:52:24 <cmccann> ivanm, who says the Aztecs didn't program in Haskell
15:52:41 <pikhq_> Who says we don't have all pantheons?
15:53:00 <dankna> zip`ap`tail - hahahahaa
15:53:18 <Evious> Wow, that's both useful and hardcore looking.
15:53:28 <pikhq_> 'Tis a classic.
15:53:32 <doserj> geheimdienst: the Enum instance is the problem
15:54:02 <kmc> > [0..9] :: [UTCTime]
15:54:03 <lambdabot>   Not in scope: type constructor or class `UTCTime'
15:54:18 <doserj> > [0..1]::[Pico]
15:54:19 <lambdabot>   [0.000000000000,0.000000000001,0.000000000002,0.000000000003,0.000000000004...
15:54:29 <geheimdienst> oh, i begin to see
15:54:42 <doserj> DiffTime does the same
15:54:50 <kmc> oh so it's not an infinite list, just 10^13 elements
15:54:52 <kmc> much better
15:55:58 <doserj> which arguably is a bug
15:56:33 <kmc> Enum on non-integral types is weird
15:56:39 <kmc> it's even worse on floating point types
15:56:50 <cmccann> everything is weird on floating point types
15:57:01 <kmc> > let x = 0/0 in x == x
15:57:01 <lambdabot>   False
15:57:04 <doserj> considering that the documentation says that "conversion functions threat it as seconds"
15:57:14 <pikhq_> And worse still on UTC time, which does not have a clear sequence in all cases.
15:57:38 <cmccann> > compare (0/0) (0/0)
15:57:39 <lambdabot>   GT
15:57:43 <pikhq_> Oh, wait, sorry, no. UTC time does.
15:57:47 <pikhq_> UNIX time does not.
15:59:01 <aavogt> Eliel, ivanm, I found this http://hackage.haskell.org/trac/ghc/ticket/1341
15:59:06 <geheimdienst> my understanding is that Pico (i.e. UTCTime and NominalDiffTIme) is fixed-point, not floating. i think of it as an integer + another integer limited to 12 places, stuck together with a dot
15:59:27 <geheimdienst> > 0 :: Pico + 1
15:59:27 <lambdabot>   Could not deduce (GHC.Num.Num
15:59:28 <lambdabot>                      ((+) Data.Fixed.Pico GHC...
15:59:34 <geheimdienst> > (0 :: Pico) + 1
15:59:35 <lambdabot>   1.000000000000
15:59:53 <geheimdienst> okay, so the fix would be to just not use [0..9], right?
16:00:02 <aavogt> instead you get the next possible Pico
16:00:05 <doserj> yep
16:00:20 <doserj> or loudly complain about the broken Enum instance :)
16:00:28 <doserj> (maybe someone will listen)
16:00:40 <aavogt> > map fromInteger [0 .. 9] :: [Pico]
16:00:41 <lambdabot>   [0.000000000000,1.000000000000,2.000000000000,3.000000000000,4.000000000000...
16:01:07 <Eliel> aavogt: pretty old.
16:01:13 <doserj> yep, that's one sign of it being broken
16:01:24 <geheimdienst> > ([0..9] :: [Integer]) :: [Pico]
16:01:24 <lambdabot>   Couldn't match expected type `Data.Fixed.Fixed Data.Fixed.E12'
16:01:25 <lambdabot>         agai...
16:01:39 <geheimdienst> > [0..9 :: Integer] :: [Pico]
16:01:40 <lambdabot>   Couldn't match expected type `Data.Fixed.Pico'
16:01:40 <lambdabot>         against inferred typ...
16:01:58 <geheimdienst> ah i see. the fromInteger was for converting Integer --> Pico
16:02:08 <geheimdienst> thanks aavogt
16:02:34 <copumpkin> tommd: how is crypto-api doing these days?
16:02:35 <aavogt> yes :: doesn't coerce types like some other languages
16:16:00 <tommd> copumpkin: well enough.
16:16:12 <copumpkin> can I use ECDSA and things like that in it?
16:16:20 <tommd> I've been busy but the API is stable, adopted by several packages, and fits my needs.
16:16:26 <tommd> I get very little community feedback.
16:16:44 <tommd> So if there are issues, do encourage people to ping me.
16:17:11 <tommd> I don't know of any ECDSA library with a crypto-api interface implemented
16:17:16 <tommd> but the classes do exist.
16:17:23 <copumpkin> ah
16:18:31 <tommd> For example, the "Signing" class exists.  I had tried to interest the hecc author (who's name escapse me right now) but he hasn't added to the package in a while afaik.
16:18:48 <copumpkin> @hackage hecc
16:18:48 <lambdabot> http://hackage.haskell.org/package/hecc
16:19:06 <tommd> Yeah, Marcel.
16:19:28 <tommd> I also encouraged him to use CryptoRandom instead of Random (via MonadCryptoRandom) but that just hasn't happened.
16:20:22 <tommd> Bus in 7 minutes, I should go.  Be back later tonight.
16:20:25 * tommd runs off
16:25:55 <periodic> hmm... if I wrote a program that has a fairly simple loop, and the statistics (+RTS -sstderr) shows 3.7 GB allocated in the heap, should I be worried?  Should I try to work with something like ST?
16:26:07 <periodic> Right now the internals of the loop are pretty simple.
16:26:23 <periodic> oh... wait... I just realized I'm using map a lot, which will allocate anyway...
16:26:28 <periodic> I should look at who is doing the allocations.
16:28:57 <hpc> GhC is optimized for allocating gigs and gigs of memory very rapidly
16:29:11 <hpc> that number by itself isn't that worrying
16:29:23 <periodic> It's still executing in ~ 1 second
16:29:52 <periodic> Right now I'm running with simple Integers where I will likely later have more complex data structures.
16:30:09 <periodic> I guess I'll cross that bridge when I come to it.
16:38:06 <parcs> any reason _not_ to use Data.List.Stream over Data.List?
16:40:24 <Saizan> concatMap, iirc
16:40:48 <djahandarie> Yeah.
16:41:26 <parcs> what about concatMap?
16:41:29 <djahandarie> Data.Vector uses Stream fusion and it usually does fine. I don't think concatMap is a big enough deal to break it.
16:41:40 <Saizan> in the sense that (nested?) concatMap's are optimized better by foldr/build fusion
16:47:44 <ivanm> what's Data.List.Stream?
16:48:24 <djahandarie> List functions written so that they can be fused with stream fusion
16:56:42 <hpc> (stream fusion is a rewriting technique that makes tight loops go hella fast)
16:58:18 <kfish> i thought there were already fusion rules for Data.List?
17:06:41 <joe6>  http://sprunge.us/VbiK any suggestions on what the type signature of this function should be?
17:07:26 <joe6>  http://sprunge.us/HFSY i am not able to get it right, this is my error
17:07:32 <parcs> Monad m => Bool -> m a -> m ()
17:08:30 <joe6> parcs: that worked. thanks.
17:08:34 <aavogt> @src when
17:08:35 <lambdabot> when p s = if p then s else return ()
17:08:52 <joe6> aavogt: that is awesome, thanks
17:08:57 <aavogt> I guess there's a difference in that you ignore the return value
17:09:07 <Peaker> when False = const (return ()) ; when True = id
17:09:11 <joe6> so unless?
17:09:15 <joe6> or not
17:09:58 <aavogt> joe6: no when. But sometimes the  a /= () in the type of the second argument
17:10:37 <Peaker> joe6: the reason you got a type error is because   "return ()"  cannot match a universal type "a", "return ()" is not polymorphic enough.  It is polymorphic enough to yield:  Monad m => m ()
17:10:51 <Peaker> @type void
17:10:52 <lambdabot> Not in scope: `void'
17:10:57 <Peaker> @type Control.Monad.void
17:10:58 <lambdabot> Not in scope: `Control.Monad.void'
17:11:28 <joe6> Peaker: ok, thanks. when seems to work
17:11:55 <Peaker> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html    <---  has a:       void :: Functor f => f a -> f ()
17:12:10 <Peaker> so instead of having (a >> return ())   you can just use: (void a)
17:12:32 <Peaker> though I'd just require the caller to do the (void a) in his context, so that the loss of return value is explicit at each call site
17:13:09 <joe6> this is what I have:  when timedout $ error "sraminput timedout"
17:13:15 <joe6> and that is exactly what I need.
17:13:24 <parcs> @hoogle timeout
17:13:25 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
17:13:25 <lambdabot> module System.Timeout
17:13:25 <lambdabot> Network.Socket RecvTimeOut :: SocketOption
17:13:36 <joe6> of System.USB
17:13:42 <joe6> it is TimeOut
17:13:44 <Peaker> joe6: since you're in a monadic context, why not use "fail" instead of "error"?
17:13:57 <Peaker> joe6: that way it will translate to a monadic exception that may be catch'able
17:14:05 <joe6> never used fail. will check what it does.
17:14:27 <joe6> ok, fail then.
17:14:29 <Peaker> joe6: error is a "pure exception" or "imprecise exception". It is very difficult to handle correctly -- so it is mostly meant to fail the entire program
17:14:34 <joe6> it seems to work.
17:14:37 <Peaker> joe6: (or never be evaluated/forced)
17:14:47 <Peaker> joe6: "fail" is a method of the Monad class, so implemented for each monadic type
17:14:49 <mm_freak_> .o(because 'fail' is a hack to handle pattern match failures…  i prefer not to use it)
17:15:12 <Peaker> mm_freak_: but "error" is even worse :P
17:15:25 <mm_freak_> yes
17:15:37 <Peaker> If there was a MonadFail subclass
17:15:41 <Peaker> that would be nice
17:15:56 <mm_freak_> you have MonadError and other exception classes
17:16:12 <Peaker> @src MonadError
17:16:13 <lambdabot> class (Monad m) => MonadError e m | m -> e where
17:16:13 <lambdabot>     throwError :: e -> m a
17:16:13 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
17:16:38 <Peaker> That's overly restrictive -- I don't want to require my user to only use monads in which he can catch the error
17:16:40 <mm_freak_> also many monads with some sense of no result are instances of Alternative
17:16:51 <Peaker> I want to make it *possible* to use the code with monads that make it possible to catch, but not a requirement
17:16:55 <mm_freak_> Maybe, Either e, [], etc.
17:17:05 <mm_freak_> > empty :: [Int]
17:17:06 <lambdabot>   Ambiguous occurrence `empty'
17:17:06 <lambdabot>  It could refer to either `Control.Applicative...
17:17:13 <mm_freak_> > Control.Applicative.empty :: [Int]
17:17:14 <lambdabot>   []
17:17:21 <Peaker> It's really tempting to say classes should have allowed just one method -- because so many multi-method classes are mistakenly multi-method
17:17:41 <hpc> :t Control.Applicative.empty
17:17:42 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a
17:17:45 <mm_freak_> Peaker: then you probably want ContT
17:17:49 <aavogt> Peaker: think of the type signatures
17:18:06 <Peaker> aavogt: Subclassing would make it sane in many cases
17:18:15 <mm_freak_> Peaker: and impossible in others
17:18:45 <Peaker> (Functor => Pointed => Applicative => Monad => MonadZero => MonadPlus)
17:18:53 <Peaker> mm_freak_: why impossible?
17:19:21 <mm_freak_> Peaker: do you know that all type classes can be rewritten to a hierarchy of classes?
17:19:21 <aavogt> one thing is you probably can't enforce that:
17:19:27 <Peaker> where ApplicativeZero could be the real method container and MonadZero just a convenience sub-class of both Monad and ApplicativeZero, same with MonadPlus
17:19:38 <Peaker> mm_freak_: what do you mean?
17:19:45 <aavogt>  class HasTwoMethods a where f :: (a -> Int, Int -> a) -- has two methods?!
17:19:45 <Peaker> aavogt: yeah, using tuples
17:19:59 <aavogt> or other types that do the same thing
17:20:06 <Peaker> aavogt: though there's a nuanced different between that and two methods -- of type quantification
17:20:12 <Peaker> difference*
17:20:39 <hpc> aavogt makes sense though
17:21:06 <joe6> is there some function that can split a Word16 into 2 Word8's (low byte and high byte)?
17:21:29 <mm_freak_> Peaker: there may be classes with two functions (please get rid of the word "method", it's stupid OOP slang), which you cannot split
17:21:34 <mm_freak_> because the methods depend on each other
17:22:03 <aavogt> they are called methods in the haskell report
17:22:08 <Peaker> mm_freak_: I think "method" is the formal name for that
17:22:18 <mm_freak_> aavogt: really?
17:22:23 <Peaker> mm_freak_: and it is not really a function, because it is a signature for multiple functions to implement
17:22:53 <Peaker> Classes and instances are also "OO slang" :)
17:23:02 <mm_freak_> Peaker: it's one function
17:23:09 <mm_freak_> return :: Monad m => a -> m a
17:23:12 <Peaker> With a different meaning, of course, just like "return", to mess with the imperativists
17:23:29 <Peaker> mm_freak_: a single function that has many different implementations
17:23:56 <mm_freak_> i don't see any difference
17:24:01 <hpc> Peaker: it's still a function, just quantified over different variables
17:24:15 <Peaker> mm_freak_: I guess methods are indeed functions too, but they are special kinds of functions, because they are defined so differently from functions
17:24:24 <Peaker> from normal functions, that is
17:24:30 <Rotaerk> methods aren't necessarily functions
17:24:35 <Rotaerk> but they can be
17:24:48 <joe6> @hoogle Word16 -> [Word8]
17:24:48 <lambdabot> Data.Data gmapQ :: Data a => (d -> u) -> a -> [u]
17:24:48 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
17:24:49 <lambdabot> Data.List genericReplicate :: Integral i => i -> a -> [a]
17:24:51 <Peaker> yeah, sloppy terms/thinking on my par there
17:24:56 <mm_freak_> aavogt: you're right
17:25:11 <Peaker> Haskell has been re-using OO terms with different meanings all over the place :)
17:25:14 <mm_freak_> they are indeed called methods in the report
17:25:37 <mm_freak_> Peaker: "class" is not an OOP term, although "instance" is
17:25:55 <mm_freak_> Rotaerk: when are methods not functions?
17:26:04 <parcs> > let f x = (x `shiftR` 8, fromIntegral (x :: Word16) :: Word8) in f 423
17:26:05 <lambdabot>   (1,167)
17:26:11 <geheimdienst> i'm using Control.Monad.guard. what does it mean when it tells me at runtime "user error (mzero)"?
17:26:30 <Rotaerk> classes are unnecessary for OO... but objects are crucial... and an object isn't an instance without a class
17:26:33 <hpc> @src guard
17:26:34 <lambdabot> guard True  =  return ()
17:26:34 <lambdabot> guard False =  mzero
17:26:42 <hpc> > mzero :: IO ()
17:26:43 <lambdabot>   Overlapping instances for Control.Monad.MonadPlus GHC.Types.IO
17:26:43 <lambdabot>    arising f...
17:26:55 <mm_freak_> geheimdienst: nothing related to 'guard'…  something is probably expecting a non-mzero value, and you give it an mzero
17:27:02 <Peaker> mm_freak_: "return" was also chosen especially as to confuse imperative programmers :)
17:27:06 <Rotaerk> mm_freak_, when it doesn't always return the same thing for a given input or it causes side effects
17:27:15 <aavogt> Peaker: can the tuple way actually give different results?
17:27:24 <mm_freak_> Rotaerk: there are no side effects in haskell (disregarding unsafe* stuff)
17:27:25 <geheimdienst> hm ...
17:27:26 <monochrom> "user error (mzero)" seems to be what IO's mzero does
17:27:45 <Rotaerk> mm_freak_, but OO "methods" extend beyond haskell
17:27:56 <geheimdienst> yeah. so guard doesn't work in IO, i guess
17:27:59 <Peaker> aavogt: I think that in the tuple case, maybe not.. in other cases, I think it might make the values in the tuple less polymorphic
17:28:02 <mm_freak_> Rotaerk: ah, so you're not talking about haskell =)
17:28:05 <Rotaerk> nope :P
17:28:14 <Peaker> aavogt: but I'm not an expert on type quantifications...
17:28:14 <hpc> geheimdienst: it does work, just not the way you hoped
17:28:25 <joe6> does this look ok: printf "%02x" ( fromIntegral (0x8888 :: Word16) :: Word8 )
17:28:29 <hpc> unless IO's 'fail' doesn't work either :P
17:28:45 <mm_freak_> geheimdienst: mzero in IO is analogous to Nothing in Maybe
17:28:51 <mm_freak_> Nothing is an exception
17:29:25 <Peaker> aavogt: I think it can be reduced to the question:   (forall a. (type involving a), forall b. (type involving b))    ===    (forall a b.  (type involving a, type involving b))
17:29:31 <hpc> you could potentially give an mzero value for all monads = fail "user error (mzero)"
17:29:39 <joe6> @hoogle shiftR
17:29:39 <lambdabot> Data.Bits shiftR :: Bits a => a -> Int -> a
17:29:45 <mm_freak_> anyway, if we had better names for some language constructs and library functions, programmers from the OOP world wouldn't be so confused
17:29:49 <hpc> and get mostly synonymous behavior
17:29:51 <magicman> @type catch
17:29:51 <mm_freak_> 'class' could be called 'family'
17:29:52 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
17:30:08 <geheimdienst> yeah ... if mzero is analogous to Nothing, i was hoping it'd do something like catMaybe
17:30:13 <geheimdienst> one can dream, i guess :)
17:30:19 <magicman> @type \a b -> catch a (\_ -> b)
17:30:20 <lambdabot> forall a. IO a -> IO a -> IO a
17:30:27 <mm_freak_> geheimdienst: perhaps you want MaybeT IO =)
17:30:29 <Peaker> > mzero :: Either String a
17:30:30 <lambdabot>   Overlapping instances for Control.Monad.MonadPlus
17:30:30 <lambdabot>                          ...
17:30:33 <magicman> (note: probably a bad idea as a mplus implementation >_>)
17:30:51 <hpc> what's the other half of the overlap?
17:30:57 <hpc> @calesignal
17:30:57 <Peaker> geheimdienst: there's a law that   mzero >>= ...   = mzero
17:30:58 <lambdabot> Unknown command, try @list
17:31:03 <mm_freak_> (each time someone writes this >_> smiley here, i ask myself, what combinator that would be)
17:31:22 <hpc> mm_freak_: the syntax-error combinator
17:31:23 <magicman> _ is not a valid operator character!
17:31:28 <Peaker> geheimdienst: and mzero is mplus's identity, allowing to catch mzero "exceptions"
17:31:43 <mm_freak_> > let (>_>) = (+) in 1 >_> 2
17:31:43 <lambdabot>   <no location info>: parse error on input `)'
17:31:52 <mm_freak_> ah, of course
17:32:07 <magicman> v_v, though.
17:32:13 <monochrom> I wonder what you thought guard would do.
17:32:57 <hpc> let _ x y = x + y -- I HAVE DEFINED ALL FUNCTIONS EVAR
17:33:00 <Peaker> > [1,2,3] `mplus` mzero
17:33:00 <lambdabot>   [1,2,3]
17:33:02 <aavogt> http://hpaste.org/47631 <-- the single method class question
17:33:47 <joe6> > shiftR 0x80 8
17:33:48 <lambdabot>   Ambiguous type variable `a' in the constraint:
17:33:48 <lambdabot>    `Data.Bits.Bits a'
17:33:48 <lambdabot>      a...
17:33:50 <geheimdienst> monochrom: i thought it maybe would end executing the current do block ...
17:33:57 <mm_freak_> monochrom: well, i would say it cancels the IO computation, and that's what it does, if you don't use exception handling…  so just like Nothing in Maybe
17:34:10 * geheimdienst shrugs
17:34:11 <joe6> > shiftR (0x80::Word8) 8
17:34:12 <lambdabot>   0
17:34:12 <mm_freak_> geheimdienst: "the current do block" is meaningless
17:34:24 <joe6> shouldn't that be 0x8?
17:34:25 <aavogt> there is a question of moving the quantification    (forall m. Monad m => Int -> m a, forall m. Monad m => a -> m Int) , but I think there's no difference
17:34:25 <mm_freak_> it is translated to combinator style
17:34:28 <monochrom> "return" shows that do-block boundaries are fragile
17:34:39 <cmccann> mm_freak_, if you really want emoticons in your Haskell code, go Unicode
17:35:10 <cmccann> elaborate shift-JIS emoticons should provide lots of material to work with
17:35:15 <monochrom> guard is just a library function. it can't possibly do a thorough syntactic analysis on its own steam
17:35:22 <hpc> if you want traditional C-ish block structure, use Cont
17:35:34 <parcs> joe6: no
17:35:42 <monochrom> use "when".
17:35:42 <parcs> > 0x80
17:35:43 <lambdabot>   128
17:36:07 <mm_freak_> use "goto"
17:36:30 <hpc> use Java
17:36:36 <joe6> sorry about that.
17:36:44 <joe6> parcs, braindead..
17:36:46 <hpc> (oh god don't quote me on that)
17:36:53 <joe6> parcs: me, I meant.
17:37:27 <parcs> joe6: :P
17:38:01 <mm_freak_> @remember <geheimdienst> monochrom: i thought it maybe would end executing the current do block ...  <monochrom> use "when".  <mm_freak_> use "goto"  <hpc> use Java
17:38:01 <lambdabot> Okay.
17:38:13 <monochrom> haha
17:38:23 <Peaker> aavogt: no difference apparently, since:
17:38:27 <Peaker> instance D a => C a where f = (g1, g2)
17:38:27 <Peaker> instance C a => D a where g1 = fst f ; g2 = snd f
17:38:31 <Peaker> aavogt: is allowed
17:39:56 <cmccann> hpc, isn't this channel logged? :] Looks like that's getting saved for posterity.
17:40:16 <hpc> cmccann: yeah, but who looks at logs :P
17:40:18 <hpc> @quote
17:40:19 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
17:40:57 <monochrom> this channel is logged by a computer with a very skewed clock (like off by 20 minutes)
17:41:26 <dankna> lol at the quote
17:42:04 <cmccann> hpc, Google I suppose
17:42:19 <hpc> so yeah, if anyone out there is bored enough to dredge through years and years of #haskell logs, the current time is 9:04 PM, eastern time
17:42:27 <hpc> you can thank me later, nameless futuredude
17:42:29 <cmccann> hpc, when Google's ranking algorithm finally attains sentience and conquers the world, it'll think of you as a Java fan
17:42:41 <hpc> :D
17:42:47 <mm_freak_> monochrom: there are in fact very weird time zones…  somewhere in the south of the philippines they have an offset of 10 minutes
17:42:49 <hpc> D:*
17:43:12 <mm_freak_> it's 3:05 AM here
17:43:39 <mm_freak_> thank me, futuredude, because my clock is actually correct
17:43:51 <HugoDaniel> :D
17:43:58 <dankna> futuredude would like to thank you, but time only works in one direction
17:44:12 <HugoDaniel> ahah
17:44:19 <hpc> heh
17:44:25 <mm_freak_> send me your thanks through a wormhole, futuredude, because my clock is actually correct
17:44:29 <ion> @instances Monoid
17:44:30 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
17:44:53 <hpc> 21:05 [freenode] -!- There is no such nick futuredude
17:44:54 <hpc> D:
17:44:56 <cmccann> dankna, not really, time is mostly directionless as far as most physics are concerned
17:45:16 <dankna> futuredude's wormholes are too busy with people's requests for stock tips and immortality serum.
17:45:24 <dankna> cmccann, yes, actually, I've heard that
17:45:37 <hpc> dankna: don't forget grandfather paradoxes
17:45:42 <dankna> ah yes, indeed so
17:45:48 <mm_freak_> @girl19
17:45:49 <lambdabot> LOL
17:45:49 <cmccann> lots of quantum stuff where things happen one way or the other only because in the future someone did something that depended on the outcome
17:45:53 <mm_freak_> lol
17:45:55 <hpc> (of the futurama kind, not the sci-fi thriller kind)
17:46:48 <mm_freak_> futuredude would have to pick a white hole, which is present a few hundreds of years ago
17:47:00 <mm_freak_> but i haven't received anything yet, so…  there is no futuredude
17:47:06 <mm_freak_> or he won't like me
17:48:50 <Peaker> They say Linq is monad comprehensions -- can anyone say what equivalences hold?   What are return and bind? What are all the extra things in Linq (order by, group by, ..)?
17:49:00 <dankna> actually, I just looked to my left and noticed a strange book that I hadn't seen before
17:49:02 <cmccann> Peaker, return doesn't exist
17:49:08 <cmccann> it can't, really
17:49:09 <dankna> it's titled "World Almanac and Book of Facts, 2123"
17:49:14 <dankna> I think futuredude likes me better
17:49:17 <mm_freak_> cmccann: quantum stuff with no causality happens everywhere in the universe, so somewhere in a parallel universe there is a language for practical programming, which is better than haskell
17:49:27 <joe6> need some help with updating a value in a record structure:  http://sprunge.us/CcNQ
17:49:27 <hpc> linq is that language that tries to be nothing but lists?
17:49:40 <cmccann> the type system in C# isn't expressive enough to describe return
17:49:41 <dankna> joe6: that's off-topic, ask .... oh!  this is #haskell
17:49:49 <dankna> lol, I thought this was -blah
17:50:16 <mm_freak_> dankna: so you are the futuredude
17:50:17 <Rotaerk> LINQ is just sequence transforms..
17:50:21 <mm_freak_> sorry, you will be
17:50:29 <cmccann> Peaker, anyway fmap and bind are called Select and SelectMany
17:50:45 <dankna> mm_freak_, perhaps!  it doesn't say who sent it.  it only says useful things like who's going to win the World Series every year, that sort of thing.
17:51:03 <Peaker> cmccann: I understand "return" cannot exist as a real function in C#, as it cannot get a C# type. But I thought it could exist as a special construct with special syntax -- one that does not have to get a C# type
17:51:23 <mm_freak_> Peaker: if you want a better approximation of monads, you should use F# instead of C#
17:51:26 <cmccann> but the nature of C# means that even so LINQ doesn't really correspond neatly to anything sensible in Haskell, I think
17:51:28 <mm_freak_> or, well, haskell
17:51:39 <hpc> dankna: if i could send one document back in time, it would possibly be a specifically engineered math-troll document
17:51:43 <Peaker> cmccann: what are all the extra things in Linq equivalent to?  Some subclasses of Monad?
17:51:43 <cmccann> Peaker, I'm sure it could but I don't think it does
17:51:48 <hpc> probably to the 1700s
17:51:58 <mm_freak_> cmccann: you can define monads in C#, but you lose all the features you get in haskell
17:52:06 <dankna> hpc: hahaha interesting thought
17:52:07 <Peaker> mm_freak_: I don't use C#, I am just curious
17:52:15 <mm_freak_> for example in C# you cannot write mapM, you can only write listMapM, maybeMapM, etc.
17:52:22 <dankna> hpc: hahaha maybe Fermat's Last Theorem was a time traveller having a joke
17:52:32 <hpc> :D
17:52:45 <hpc> i like how the theorem ended up being a huge pain in the ass
17:52:54 <cmccann> mm_freak_, you can define any monad you want, you just can't define the Monad type class as an interface
17:53:06 <cmccann> because there's no valid type for return
17:53:08 <parcs> joe6: try fixing spaces before and after the curly braces
17:53:10 <hpc> and used techniques that didn't even exist in Fermat's time
17:53:18 <acowley> Hey Peaker, I fixed the OpenCV code to work with OpenCV 1.1 from Ubuntu's apt repository
17:53:35 <joe6> parcs: that simple?
17:53:55 <mm_freak_> dankna: there is this guy, who will have sent our grand-grand-grandparents the factoring problem, while chatting with bruce schneier on a quantum computer
17:53:56 <dankna> indeed so, hpc
17:53:57 <parcs> hopefully :)
17:54:18 <dankna> mm_freak_, hah :)
17:54:25 <parcs> joe6: oh, never mind. i misnterpreted the paste
17:54:28 <joe6> parcs, nope that does not seem to be it.
17:54:33 <cmccann> Peaker, anyway the main complication is that LINQ works through OOP-style interfaces, which introduces subtyping stuff, which I think ends up closer to something like an existential type constructor that could be any monad
17:54:40 <mm_freak_> cmccann: that's the point
17:54:45 <hpc> dankna: ooh!
17:54:57 <hpc> dankna: send "seemingly impossible functional programs" to alan turing
17:55:06 <hpc> dankna: and send an intel spec sheet to church
17:55:06 <joe6> i am trying to update a field within a constructor within another constructor. Any thoughts on how I can do that?
17:55:24 <parcs> joe6: ctSetupMsg = { stslowindex = 0x90 } makes no sense.
17:55:30 <cmccann> mm_freak_, yeah, sorry, misread what you were saying
17:55:40 <dankna> haha nice haha
17:55:42 <parcs> maybe you meant ctSetupMsg = ctSetupMsg sraminput { stslowindex = 0x90 }
17:55:42 <mm_freak_> joe6: with record syntax
17:56:07 <joe6> i want to change the stslowindex value and keep the record the same.
17:56:33 <hpc> foo{bar=(bar foo){baz = modify (baz (bar foo))}}
17:56:48 <hpc> there's likely a less verbose way
17:56:59 <cmccann> Peaker, but other than the subtyping issues, lack of return, and hoop jumping needed for the expression tree generation I think all LINQ functionality is definable from just SelectMany
17:57:20 <joe6> something like this: let x = stlowwIndex $ ctSetupMsg sraminput = 0x90
17:57:26 <Peaker> acowley: cool
17:57:43 <mm_freak_> outer { outerField = (outerField outer) { innerField = newValue } }
17:58:03 <Peaker> cmccann: what about the "group by", "order by", stuff?
17:58:27 <Peaker> those don't seem to have a meaning in the context of some monads
17:58:49 <Peaker> (I guess they could always be considered the identity function in those cases, but yech)
17:58:55 <acowley> Peaker: the bug you discovered is buried deep. I never really found it as it goes away when debug symbols are left in the OpenCV libraries.
17:59:10 <ion> Does any package define Monoid instances for MaybeT m a and ReaderT r m a?
17:59:40 <ion> I’d like to get rid of my orphan instances.
17:59:45 <cmccann> Peaker, oh, I think some of that does actually depend on an additional interface
17:59:54 <cmccann> particularly the ordering stuff
18:00:13 <acowley> Peaker: what if the ordering can be provided by the data source?
18:00:26 <joe6> mm_freak_: that worked, thanks.
18:00:53 <mm_freak_> joe6: if you do that often, you may want to use a lens
18:00:58 <Peaker> acowley: you could put the symbols in a separate file?
18:01:20 <Peaker> acowley: Debian/Ubuntu often have "-dbg" packages for separate symbol files for existing libs (of which the symbols were stripped into the files)
18:01:55 <Peaker> yeah, so Linq seems to be a comprehension of some subclass of Monad
18:02:01 <acowley> Peaker: I don't know, and I really can't spend any more time on it. Linking with the v2.1 in the repository works, so I'm going to let it be for now
18:02:11 <Peaker> (though I think it can generalize to Monads if you only use the Monadic operations)
18:02:35 <cmccann> Peaker, yeah, I'm really not sure what it works out as
18:04:45 * hackagebot hsignal 0.2.2.1 - Signal processing and EEG data analysis  http://hackage.haskell.org/package/hsignal-0.2.2.1 (VivianMcPhail)
18:05:27 <c_wraith> Peaker: the Monad Comprehension extensions in an upcoming version of GHC include much of the other functionality of Linq
18:09:06 <joe6> when I get an error as this, *** Exception: Prelude.head: empty list , Is there a way of knowing where in the program that is happening?
18:10:21 <Peaker> c_wraith: GHC burrowing features from C#? Is this the end of times?
18:10:43 <acowley> Why do you need monad comprehensions to do what linq does?
18:10:45 <c_wraith> Peaker: it's ok.  They've been sanitized by going through a research paper translation phase :)
18:11:34 <Peaker> acowley: We don't have type-classes for the Linq operations, afaik
18:11:48 <Peaker> C#/Java have some advantages over Haskell in that arena, more polymorphic base libraries
18:11:52 <dolio> We will.
18:11:57 <lpsmith> is it possible to link to a module that isn't a member of the package you want to link from using Haddock?
18:12:57 <dolio> Linq isn't polymorphic, either.
18:13:12 <dolio> You can't write one expression that will work with multiple things.
18:13:12 <c_wraith> lpsmith: yes.  but I don't remember what rules haddock uses about when to make it a real link, vs when to give up.
18:13:25 <dolio> You'd have to copy and paste the same expression to use it with a different 'monad'.
18:13:30 <dolio> From what I hear.
18:14:04 <lpsmith> c_wraith: I tried writing "Data.Monoid" but the link ends up brokent
18:14:11 <cmccann> dolio, I think the lack of polymorphic return is the only reason for that, isn't it?
18:14:50 <dolio> I don't know what prevents it exactly.
18:14:55 <c_wraith> lpsmith: I thought that worked.  I dunno.
18:15:02 <cmccann> if anything I'd imagine LINQ to be too polymorphic, I don't think there's any guarantee you'll get back the same monad you started with :)
18:15:25 <dolio> They don't really have higher kinds, either, unless I'm mistaken.
18:15:34 <cmccann> dolio, correct
18:15:45 <cmccann> except without the "really"
18:15:59 <cmccann> that statement doesn't need hedging I think
18:16:06 <dolio> Well, edwardk was working on some hack last week...
18:16:14 <dolio> Translating a hack from Java.
18:16:27 <dolio> Which does similar stuff to higher kinds with reflection and casting.
18:16:29 <cmccann> oh, hacks are possible, I'm sure
18:16:30 <dolio> It's pretty evil.
18:16:48 <cmccann> either faking it with implementing your own dictionary passing, or just using reflection
18:17:04 <cmccann> and I don't know if using reflection is all that evil here.
18:17:42 <cmccann> I mean, the fact that reflection is possible by default already breaks everything you might want to assume about the behavior of polymorphic code
18:17:50 <lpsmith> c_wraith: ugh,  haddock isn't producing internal links anymore either
18:18:09 <dolio> Well, presumably there's instanceof.
18:18:14 <dolio> There is in Java.
18:18:19 <dolio> That breaks parametricity.
18:18:26 <lpsmith> like,  if I write 'function_in_same_module',  I get a non-linked identifier in a monotype font.
18:19:03 <lpsmith> Haddock is starting to show it's age, I'm afraid,  though the new default style is a big improvement over what we had before
18:19:16 <acowley> Lots of haskellers seem to really like reflection-style generics
18:21:46 <cmccann> dolio, actually I don't think so
18:21:56 <cmccann> that is, I don't think you can use it that way
18:23:23 <ion> If i have ‘{-# LANGUAGE TypeSynonymInstances #-} type Field env a = MaybeT (Reader env) a; instance Monoid a => Monoid (Field env a) where { mempty = return mempty; mappend = liftM2 mappend }’, does that result in an orphan instance, that is, does that affect everyone that imports my module and uses MaybeT (Reader r) a elsewhere?
18:23:57 <cmccann> if memory serves me you can only do that directly (i.e., without reflection) on things with a type known at compile time, not a parametric type
18:25:06 <acowley> but doesn't reflection on a type parameter open the door a bit too wide already?
18:25:11 <cmccann> well yeah
18:25:22 <cmccann> reflection breaks everything, of course
18:27:01 <cmccann> but the most part the C# team has done a good job of making sure things aren't any more broken than they're forced to be by the nature of the language
18:27:41 <acowley> I actually quite liked reflection when I was doing C# as it admits generic programming everywhere
18:28:26 <cmccann> so doing sensible things in your own code is likely to behave properly, even if you can't rely on external code to be sane, and can of course do all kinds of damage with reflection
18:28:58 <acowley> I had some pretty snazzy things for mapping C# objects onto microcontroller resources. The code's ultimate downfall was that nobody understood how it worked other than me, and so nobody extended it or even trusted it much
18:30:36 <acowley> Okay, now I've encountered another segfault in OpenCV 2.2, this time on Windows, that goes away if I do a RelWithDebInfo build.
18:30:45 <acowley> So now I'm getting suspicious about GHC again
18:31:06 <acowley> Also, realtime video processing on an Atom? Not so hot.
18:32:41 <dolio> Shocker.
18:33:19 <edwardk> cmccann: the highj hack is to use a type _<A,B> to represent type application.
18:33:35 <dolio> Yeah, that was something.
18:33:54 <cmccann> edwardk, hah, I vaguely recall trying something like that at one point myself
18:33:54 <edwardk> cmccann: you don't get 'kind safety', _<List,Int> is fine, but nothing prevents you from working with _<Maybe,Maybe>
18:33:56 <acowley> It's wild how asymmetrical low power systems are these days: decoding the video flies as it's almost certainly relying on specialized hardware, but then you hit the CPU and trip over your own feet
18:34:10 <dolio> edwardk: Can you type case on parametric arguments in C#?
18:34:39 <edwardk> dolio: of course
18:34:48 <edwardk> what s this parametricity of which you speak? =)
18:34:58 <ion> Does any common (FSVO common) module define an infix alias for mappend?
18:35:07 <dolio> It's a myth, obviously.
18:35:43 <dolio> edwardk: Incidentally, you're going to be missing out tomorrow.
18:35:53 <dolio> I'm going to do the pi and sigma adjunctions in Agda.
18:35:55 <cmccann> edwardk, I'm kind of afraid to ask why such code exists in the first place
18:36:00 <dolio> And show how they compose into product and exponential.
18:36:05 <edwardk> the "F-ing modules" talk at northeastern?
18:36:15 <edwardk> ah
18:36:36 <dolio> Oh, right. I didn't actually ask Paul or Runar if they were planning on going to that.
18:36:47 <edwardk> ion: there is one for (<>) from Semigroup. you could use that instead ;)
18:37:11 <edwardk> ion: I export (+) in Data.Monoid.Sugar in the 'monoids' package
18:37:30 * cmccann occasionally uses (++)
18:37:53 <acowley> I thought we were supposed to be agreeing on (<>)
18:38:04 <edwardk> (++) has the problem that its ambiguous, it could want to be mplus or it could want to be mappend, and it has a history as mplus =(
18:38:09 <ion> edwardk: Thanks
18:38:10 <dolio> We need <> for inequality.
18:38:20 <dolio> Because unequal things are either greater than or less than each other.
18:38:25 <edwardk> dolio: we have /=
18:38:42 <edwardk> acowley: we are. i just stole it for the Semigroup package ;)
18:38:44 <dolio> We'll never be Coq compliant that way.
18:38:49 <edwardk> er semigroups
18:39:07 <cmccann> just make some unicode operators
18:39:21 <cmccann> much tidier that way
18:39:32 <dolio> Works for scalaz, apparently.
18:40:31 <cmccann> edwardk, where has (++) been used as mplus, btw? I don't recall that
18:40:42 <edwardk> haskell 1.4
18:40:50 <cmccann> oh, ok
18:41:02 <cmccann> yeah, I'm obviously rather a newcomer to the language :)
18:41:07 <cmccann> lots of history I missed
18:41:09 <aavogt> > 98 - 1.4
18:41:10 <edwardk> you have to go pretty far back. it was a victim of the great monomorphism revolution of 98 ;)
18:41:10 <lambdabot>   96.6
18:41:29 <Saizan> dolio: do you have code/slides available for that pi and sigma adjunctions in Agda?
18:41:46 <dolio> I have code, but it's on my computer at work.
18:42:02 <cmccann> edwardk, yeah, I've only ever known the aftermath of that :P
18:42:17 <dolio> It's possible I've already done it. Although I expect not as nicely as the version I came up with for tomorrow.
18:42:37 <dolio> What I came up with is technically just a special case, but it works out really nicely.
18:42:57 <edwardk> i'll have to watch the webex
18:45:01 <acowley> dolio: will you make some version of the presentation public for we interested parties?
18:45:16 <dolio> I don't know that I'm at liberty to do that.
18:45:43 <edwardk> acowley: it also builds on top of the last 15-20 of these sessions
18:46:09 <edwardk> acowley: now i just need to talk him into giving a presentation on this topic at Boston Haskell, so I can record it for the internet ;)
18:46:19 <dolio> I can paste the code I'll be using as notes somewhere. The comments sort of explain everything.
18:46:29 <acowley> ah, well I'm sure you can synopsize it for me at hacphi so fast that I get a nose bleed
18:47:13 <dolio> http://code.haskell.org/~dolio/agda-share/html/DepCat.html
18:47:19 <dolio> It's a simpler version of that, essentially.
18:47:27 <acowley> has anyone ever had anything like this where a native library that works okay from C and C++ segfaults when called through GHC's FFI unless debug symbols are present? I'm pretty stumped.
18:47:46 <dankna> acowley: are the FFI calls declared "safe"?
18:47:52 <acowley> dankna: yes
18:47:54 <dankna> hm
18:48:04 <dankna> that's pretty weird
18:48:07 <acowley> dankna: it doesn't happen on OS X, but it does happen on Linux and Windows
18:48:18 <dankna> I've done a fair amount of cross-language stuff and no, I've never encountered anything quite like that
18:48:24 <acowley> gdb leads me to different dead ends on Linux and Windows with Release builds
18:48:32 <acowley> but Debug and RelWithDebInfo builds work fine
18:48:38 <dankna> I've even got a working medium-sized program that I'm messing with right now which works fine despite there being two separate GCs, one on each side of the FFI barrier!
18:49:20 <acowley> Hah, this code is hardcore C++ so it's probably got a GC in the templates :P
18:49:23 <dankna> hah I see
18:49:33 <cmccann> ah, C++ templates
18:49:34 <dankna> oh hey I know!
18:49:43 <cmccann> the most popular purely functional programming language
18:49:45 <dankna> you didn't call the C++ initializer code
18:49:45 <ben> I'm stealing that line
18:49:46 <dankna> that sets up the vtables
18:49:53 <acowley> dolio: thanks!
18:50:22 <dankna> or you forgot to initialize the C++ environment in some other fashion
18:50:29 <ivanm> cmccann: why, no IO at all?
18:50:49 <dankna> normally it's called by the "real" entry point generated by the C++ compiler at link-time, but GHC doesn't know how to do that
18:50:50 <acowley> dankna: what initializer code? If I write straight C and compile with gcc I don't have to do anything special
18:50:58 <dankna> acowley: that's correct, but C++ has initializer code
18:51:21 <dankna> acowley: I can't explain why the presence of debug symbols makes a difference, though
18:51:40 <cmccann> ivanm, I don't think so, though I wouldn't wager a large sum on it
18:51:41 <acowley> dankna: how is that code getting called from a C program?
18:51:47 <dankna> acowley: oh, hmm, right, I see what you're saying now.
18:51:59 <ivanm> cmccann: then what makes it pure?
18:52:03 <cmccann> C++ template metaprogramming is firmly in the territory of things Man Was Not Meant To Know
18:52:07 <dankna> acowley: is the library dynamically or statically linked, and does the behavior you see change depending on that?
18:52:25 <acowley> dankna: dynamic, and I haven't really tried static
18:52:41 <dankna> okay here's what I would do
18:52:51 <dankna> write a trivial C program that loads the library and does something that will crash in the case you're seeing
18:53:03 <cmccann> ivanm, I meant "I don't think so" in the sense of "I don't think you can do I/O with C++ template metaprogramming"
18:53:10 <acowley> dankna: in Linux, I set up a really small example of a C file that I could compile along with a main.c in GCC and it works fine, but a trivial main.hs leads to the segfault
18:53:11 <dankna> then once you've got it working with GCC, use GHC instead to link that C program
18:53:16 <cmccann> but I really wouldn't put it past C++ compilers to find a way
18:53:23 <dankna> and see if the resulting binary crashes
18:53:28 <acowley> dankna: ah, good idea!
18:53:30 <dankna> thanks :D
18:53:36 <dankna> please tell me how it turns out, as now I'm invested in this :)
18:54:13 <dankna> note that you may have to give GHC the -no-hs-main flag
18:54:45 * ski . o O ( `lwt', a library for light-weight cooperative threads in O'Caml, using a monadic interface : <http://caml.inria.fr/cgi-bin/hump.en.cgi?contrib=709>,<http://ocsigen.org/lwt/manual/> )
18:55:53 <dolio> OCaml doesn't need that academic monad stuff, bro.
18:56:56 <dolio> I'll stick with my first-class modules and equirecursive types.
18:58:00 <acowley> How come there isn't more widespread push for ML-style functors in Haskell?
18:58:09 <dylukes> ML-style functors?
18:58:38 <ivanm> is updateLookupWithKey the closest to a decomposition function in Data.Map ?
18:59:27 <acowley> dankna: ghc compiled and linked the .c files into a working executable in linux
19:00:19 <acowley> dankna: so what on earth is going on? Is GHC's generated hs-main breaking things?
19:00:36 <acowley> dylukes: parameterized modules
19:00:40 <dolio> Maybe someone can add them to UHC.
19:01:45 <dylukes> acowley: Example?...
19:01:48 <acowley> Using them in SML and in Racket is fantastic, and their omission is clearly felt in Haskell given how people kvetch about pains with swapping imports
19:01:52 <dolio> I doubt you could convince the big GHC names to work on them, since they've got a bunch of other more experimental stuff they're working on.
19:02:32 <dankna> acowley, oh weird.  my theory of course predicted the opposite.  hmm, it's got to be the generated hs-main yes :/
19:02:34 <cmccann> Haskell's current module system occupies something of a local maximum, in that by doing basically nothing they also do nothing wrong
19:02:45 <acowley> I wondered if it was partially cultural as they lead to kind of implicit arguments
19:02:51 <ion> Ah, GeneralizedNewtypeDeriving ftw. to avoid this orphan instance.
19:03:10 <acowley> dankna: I don't know anything at all about the generated hs-main, do you have any sense of what it's doing?
19:03:11 <cmccann> integrating a more sophisticated module system in Haskell would probably entail a lot more work to make sure it doesn't create new problems
19:03:22 <dylukes> sometimes I feel we just need a Haskell 2
19:03:27 <acowley> cmccann: I agree
19:03:29 <dylukes> To really… fix and redo things. :\
19:03:52 <dankna> acowley: no, I don't have a clue about that either.  it's also possible that it's the Haskell environment that needs to be initialized and isn't being, somehow.
19:03:56 <dolio> How type classes should interact with a better module system is also still an open question.
19:03:59 <dankna> although I'd think the fact that GHC is doing the linking would prevent that
19:04:00 <acowley> dylukes: think of replacing an import in Haskell with a specification of the types and types of values you depend on from those imports
19:04:11 <cmccann> and given that a lot of new features in Haskell are driven by research, I can see why "figure out how to bolt ML-style modules on" isn't really interesting
19:04:26 <ion> newtype Field env a = Field (MaybeT (Reader env) a) deriving (Functor, Applicative, Monad, MonadPlus, MonadReader env); instance Monoid a => Monoid (Field env a) where { mempty = mempty; mappend = liftM2 mappend }
19:04:40 <acowley> dankna: the segfaults are occurring in the native library, not GHC afaict
19:04:42 <ski> acowley : istr Scheme48 has them as well ?
19:04:53 <dankna> acowley: doesn't mean anything; they're runtime segfaults, they could be caused by anything
19:05:04 <ion> Whoops, mempty = return mempty
19:05:32 <acowley> ski: I didn't know that. Wherever first class modules may be found, there you will find beautiful abstractions that aren't really being used :)
19:06:08 <acowley> that's really my only issue with them, they encourage you to write interfaces for which you only ever write one implementation
19:06:18 <acowley> which isn't a technical complaint
19:06:27 * ski still has to figure out how Mercury can hide instances inside modules ..
19:06:56 <ivanm> ski: magic!
19:07:15 <dankna> acowley: I'm looking around the GHC trac to see if there's anything that seems relevant
19:07:58 <dankna> acowley: okay, that didn't lead to anything
19:08:01 <acowley> dankna: I can't see how the debug symbols could stop the C++ code from interfering with GHC's RTS, but I can just barely imagine that it is doing something to the stack that keeps the FFI from mangling things
19:08:26 <acowley> dankna: yeah, I've perused the trac with no success, and my test case involves this ridiculously enormous library that takes a long time to compile
19:08:30 <dankna> acowley: well, the dynamic linker might be noticing "hey this entry point never got called" and calling it, but if the debug symbols aren't present it can't guess which one it is.
19:08:42 <ski> acowley : well, i often write a polynorphic higher-order function which i'm only using once or twice, for sanity and separation of concerns ..
19:08:52 <dankna> what library is it, anyway?
19:08:55 <acowley> ski: yeah, and it is the same flavor as that
19:09:12 <ski> *nod*
19:09:14 <acowley> dankna: OpenCV 2.2. On Ubuntu, 2.1 is available via apt and doesn't cause any trouble
19:09:24 <dylukes> Okay.
19:09:25 <dankna> ahhh hmm
19:09:29 <dankna> okay, well, let me know if you figure it out
19:09:32 <dankna> dylukes: oh hi!
19:09:32 <dylukes> I think I decided what I'm going to play around with.
19:09:37 <dylukes> Time to get qemu working~
19:09:45 <dylukes> I want to play with kernel stuff for the next few weeks I think.
19:09:47 <dylukes> hey danka
19:09:53 <dankna> dylukes: http://dankna.com/himitsu/split-bar-mockup-3.png
19:09:59 <Saizan> type inference is more likely to work for an HOF than a functor though (do functors even have anything like inference in ML?)
19:10:11 <dylukes> dankna: hm...
19:10:18 <dylukes> It's not a BAD idea, but it's kind of "eclipse ugly"
19:10:20 <acowley> ski: so perhaps there is a technical point there. I often say that Haskell's syntax is optimized to parametric types, so you get the sanity benefits of them without paying anything in terms of source code complexity. First class modules tend to come with some syntactic and file management overhead.
19:10:20 <dankna> you have already lost your chance to talk me out of this UI, as I put too much effort into tweaking it =p
19:10:28 <dylukes> I think it could be done more elegantly...
19:10:30 <dankna> yeah I see what you mean
19:10:33 <dankna> well, how would you change it
19:10:48 <acowley> dankna: I honestly have no idea what to check out to proceed, though
19:10:53 <dylukes> Well, lets see,
19:11:04 <dylukes> I think you could use a slimmer horizontal bar *per file*
19:11:15 <dylukes> since well, the top bar here is already inconsistent with the bottom one
19:11:19 <acowley> dankna: for the time being I'm just going to stick to 2.1 on Linux, RelWithDebInfo on Windows, and hope someone else fixes it
19:11:24 <dylukes> if you split it I'd change the top to say "various files"
19:11:27 <dankna> acowley: you could open a ticket against GHC for it and say you're willing to do any tests they can suggest and report back.  I had success with that approach.
19:11:33 <dylukes> Or are these just multiple windows into the same buffer?
19:11:44 <dankna> they /might/ be into the same buffer, or they might be into different buffers
19:11:56 <acowley> dankna: yeah, perhaps that's the responsible thing to do
19:12:52 <dankna> dylukes: note that I could also change the appearance of the bottommost bar to be more consistent - for example I could have the tab-cut-out shape but with coloration in the lower-right portion which suggests "nothing here"
19:13:15 <dylukes> I think the big problem here is inconsistency.
19:13:20 <dylukes> a) Inconsistency with the system UI
19:13:24 <dylukes> b) Inconsistency within the window
19:13:26 <dankna> a) well tough
19:13:28 <dankna> b) fair concern
19:13:29 <dolio> Saizan: It can probably infer the transparent signature of a particular module.
19:14:18 <dankna> it's going to be inconsistent with the system UI, because it's stretching the window metaphor in a direction the system UI doesn't go
19:14:50 <parcs> what's the difference between setImports and loadModules in hint?
19:15:19 <dolio> Saizan: In general it's going to have the same problem as inferring arbitrary rank types.
19:16:07 <ski> acowley : mhm ..
19:16:16 <dankna> dylukes: I think when I get back to the appearance of it (I'm currently working on adding functionality to it, dragging out of new splits), I'll tweak the bottommost one as I described above, for greater consistency
19:16:21 <Saizan> dolio: yeah, that's why i'd expect it to require module arguments to be annotated
19:16:39 <dylukes> one second
19:16:43 <dylukes> I'm going to think about this on the plane
19:16:46 <dankna> okay!
19:17:50 <dolio> There are a couple (at least) papers now showing how you can desugar most fancy ML module features into System F or F_omega.
19:18:31 <dolio> So if you don't care about how ugly everything is, you can write all your well structured ML program in GHC with some extensions turned on.
19:19:03 <Saizan> oh, i've only seen cshan's one
19:19:25 <dolio> There's a talk going on tomorrow in the area that edwardk alerted us to.
19:19:29 <dolio> F-ing modules.
19:19:34 <Saizan> (i wish i were oleg so i wouldn't care how ugly everything is)
19:19:39 <dolio> Heh.
19:19:46 <dolio> There's a paper, too, if you search for that phrase.
19:19:47 <monochrom> haha f-y title
19:20:11 <aavogt> what does F stand for?
19:20:20 <monochrom> system F
19:20:21 <cmccann> nothing says "serious academic work" like gratuitous puns
19:20:32 <aavogt> right, but why did they pick that letter?
19:20:49 <dankna> it's a recursive acronym
19:20:50 <Saizan> heh, Dreyer
19:26:36 <Philippa> the earlier version of the F-ing modules talk I saw was good
19:27:41 <Philippa> dolio: yeah, the level of ugly gets pretty high though - starts with record encodings and gets worse from there
19:28:22 <Philippa> it also doesn't necessarily play well with Haskell modules - recursive dependencies get real vicious, for example
19:28:27 <Philippa> (and I've had a good legit use case for that)
19:28:51 <ski> ah, Rossberg
19:29:12 <aavogt> Philippa: you needed recursive module imports?
19:30:17 <ivanm> is updateLookupWithKey the closest to a decomposition function in Data.Map ?
19:31:58 * ski looks at <http://www.mpi-sws.org/~rossberg/f-ing/> -- is this the earlier version ?
19:32:03 <Saizan> ?type updateLookupWithKey
19:32:05 <lambdabot> Not in scope: `updateLookupWithKey'
19:33:43 <sm> yay haskell: "enabled me to whip up a B-News to C-News converter, a custom uucp, date parsers for every crazy date format ever used on Usenet, and suitible queue data structures in a rock solid, maintainable way, in 500 lines of code written over 12 hours. When I realized I also needed an A-News to B-News converter, I knew it was worth it to have done things right, because that took only 43 more lines, and worked 100% on the first run!"
19:34:08 <sm> http://kitenet.net/~joey/blog/entry/announcing_olduse.net/
19:38:43 <dankna> nice
19:42:40 <ClaudiusMaximus> ivanm: minViewWithKey might be closer?
19:44:43 <gwern> sm: I didn't know that project used haskell
19:45:00 <ivanm> ClaudiusMaximus: nah, I wanted a specific element
19:45:03 <ivanm> thanks anyway though
19:49:12 <mustelo> @pl \x -> f (g x) (h x)
19:49:12 <lambdabot> liftM2 f g h
19:53:12 <ivanm> what's annoying: a lot of the work I'm doing atm for graphviz is just because I was going to write a tutorial on the library and I figured "wouldn't it be easier if you could do _foo_" ...
19:53:12 <ivanm> :s
19:53:15 <Philippa> aavogt: yep. In exactly one module, but even so
19:57:06 <stepkut> so I need a name for a library that provides combinators which simultaneous describe how to parse and pretty-print a value.. any suggestions?
19:57:56 <sm> gwern: indeed! and I have been unable to resist.. now subscribed and caught up with all of usenet :)
19:59:41 <gwern> sm: what, the whole thing? :)
19:59:54 <sm> yeah!
19:59:57 <gwern> stepkut: 'party'
20:00:01 <parcs> @hoogle Int -> ByteString -> [ByteString]
20:00:02 <lambdabot> Prelude replicate :: Int -> a -> [a]
20:00:02 <lambdabot> Data.List replicate :: Int -> a -> [a]
20:00:02 <lambdabot> Data.ByteString drop :: Int -> ByteString -> ByteString
20:00:04 <gwern> pretty + parser
20:00:09 <gwern> get it
20:00:27 <stepkut> gwern: heh
20:00:58 <ddarius> dolio: If I remember correctly, monads are used in FFTW.
20:04:53 <dolio> Saizan, acowley: Here's something more like what I'll be using tomorrow, without the beginner stuff: http://hpaste.org/47632
20:08:58 <rudyl313> how would you find the kth order statistic of a list (kth smallest element)? I'm hoping for a linear time algorithm
20:11:00 <dolio> Oh, the F-ing modules paper uses F_omega, too.
20:11:08 <dolio> I guess that clears up my wonder about it.
20:17:35 <ClaudiusMaximus> rudyl313: personally i'd probably (last . take k . sort) unless it proved to be a bottleneck
20:18:18 <aavogt> ClaudiusMaximus: shouldn't it be    (!!k) . group . sort ?
20:18:19 <rudyl313> ClaudiusMaximus: I have an application that requires better performance... the sort would require O(nlogn)
20:18:31 <ClaudiusMaximus> aavogt: rather ((`safeGenericIndex` k) . sort)
20:18:32 <rudyl313> unless laziness does magic
20:19:07 <aavogt> the sort will traverse the whole list, but it doesn't have to properly order the last bit if you don't look
20:19:34 <ClaudiusMaximus> > let kth k input = let (seed, rest) = splitAt k input ; kth' state [] = last state ; kth' state (x:xs) = let state' = take k (sort (x:state)) in kth' state' xs in kth' (sort seed) rest in kth 10 "linear time for fixed k, afaict, still buggy for short inputs"
20:19:36 <lambdabot>   ' '
20:25:12 <ddarius> dolio: While you're there, prove that Set^I ~ Set/I.
20:26:33 <mustelo> @pl \x y -> f (g x) (h y)
20:26:33 <lambdabot> (. h) . f . g
20:27:25 <parcs> @hoogle timeout
20:27:26 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
20:27:26 <lambdabot> module System.Timeout
20:27:26 <lambdabot> Network.Socket RecvTimeOut :: SocketOption
20:27:34 <dolio> ddarius: I think I'm pushing the hour or so I have already.
20:27:40 <parcs> the Int is in microseconds, correct?
20:27:54 <dolio> And slice categories haven't been introduced.
20:32:13 <parcs> man, all of these functions that encode arbitrary units of time as Ints should use some meaningful newtype wrappers with Num instances normalized to seconds instead
20:34:59 <ddarius> parcs: Way to think small.
20:36:22 * ddarius lost Generator.
20:39:04 <ddarius> dolio: Couldn't the I argument of Δ be implicit?
20:41:14 <djahandarie> Maybe he's trying to draw a parallel with Π ?
20:41:40 <dolio> It can't be inferred in map-Δ, at least.
20:42:05 <dolio> So I just put it in everywhere, to make things uniform.
20:44:44 <deech> Hi all, is anyone in the Haskell community exploring web development using delimited continuations for control flow?
20:47:36 <deech> bos: A bunch of us in St. Louis are psyched about attending your workshop at Strange Loop. Thanks for doing it!
20:47:55 <bos> deech: cool!
20:49:12 <deech> bos: I've been trying to start a Haskell community in this town for years but it's pretty JVM heavy. Any pointers on how to break through would be appreciated.
20:52:08 <hpc> perhaps go at it from the angle that being able to compile a haskell program is a stronger argument for correctness than compiling a java program
20:52:17 <hpc> it's harder to miss bugs, etc
20:55:32 <deech> hpc: The language itself isn't as much the issue as an entire town running on the JVM. If you can't access Java libs it's a hard sell, Scala is starting to gain a foothold here for exactly this reason. I just feel like Haskell has something more to offer.
20:56:26 <cmccann> not being tied to java libs is a strong point in its favor but unfortunately that's probably a tough case to make :)
20:56:39 <hpc> POSIX?
20:56:46 <hpc> C libraries, happstack
20:57:06 <hpc> diagrams, snap
20:57:57 <hpc> and our core libraries are sooooooo much better
20:58:11 <deech> hpc: Yup, people are just now starting to become aware of happstack and Snap.
20:58:18 <hpc> fast sorts, and more data structures than you can even imagine
20:58:51 <hpc> holy crap, hackage has a bioinformatics section
20:58:59 <luite> is that bad?
20:59:05 <hpc> it's awesome
20:59:13 <hpc> a whole section
20:59:21 <deech> I am hoping bos will motivate more folks to start looking into it. Heck, Guy Steele told a room of St. Louis developers to learn Haskell.
20:59:27 <hpc> ooh, an interface to google's suggestions api
20:59:41 <hpc> harpy and llvm
20:59:48 <Axman6> deech: he's behind fortress right?
21:00:04 <hpc> the entire codec section is gold
21:00:10 <dolio> I thought fortress was dead now.
21:00:45 <Axman6> may well be
21:00:51 <hpc> and our concurrency libraries kick the shit out of java's
21:01:08 <deech> Axman6: yup, and he told us at the Strange Loop keynote last year that if he had to do it over he'd have used Haskell instead of trying to create a weird version of Fortran.
21:01:21 <Axman6> heh
21:02:20 <luite> hpc: to be fair, snap and diagrams aren't nearly as complete or mature as most of those java libraries
21:02:33 <Axman6> yeah i remember seeing a talk where he said something like "i wish we'd started with haskell and moved 1/10th the way toward {FORTRAN,what fortress is now} (i can't remember which), than starting with that and moving it 9/10ths the way toward haskell
21:03:12 <deech> Axman6: Yup that was at Strange Loop I posted that snippet to haskell-cafe.
21:03:19 <hpc> Axman6: i think that quote makes more sense with the fractions reversed
21:03:33 <hpc> rather move towards fortran from haskell, than go 1/10th backwards from fortran
21:03:50 <ClaudiusMaximus> i had a weird concurrency bug with gtk + opengl - i got the gtk concurrency right but apparently i was uploading textures from the wrong thread (guessing here) which led to garbage images...
21:03:54 <mzero> hpc - no that was his point
21:04:17 <Axman6> well the point was that he thought that haskell was almost exactly what he wished he'd come up with, but with some more of the fortranness
21:04:42 <Axman6> he was saying basically that he wished he'd started with Haskell
21:05:23 <ClaudiusMaximus> or in the wrong opengl context - not sure what happens when you create two gtkglext thingies
21:06:21 <deech> Axman6: One of the distinguishing features of Fortress was being to use real math operators in code. Haskell doesn't support that, maybe that's why Haskell only went 9/10ths of the way.
21:06:39 <hpc> what does that mean, real math operators?
21:07:26 <cmccann> as opposed to rational math operators, I guess?
21:07:31 <cmccann> or perhaps imaginary ones?
21:08:16 <Axman6> you can use things like ∑xs for the sum, and doing that can mean the sum in performed in parallel
21:08:32 <hpc> ah
21:08:47 <Axman6> but there's some other cool stuff that comes with that
21:08:55 <Axman6> deech: you got a link to that talk?
21:09:10 <cmccann> I think more languages should take syntactic inspiration from APL
21:09:21 <Axman6> i thought it was quite interesting (assuming it's the one that started with the worst program he ever wrote, on punch cards)
21:10:00 <deech> hpc: For instance, the real number symbol. Take a look at slide 29 of this talk (http://research.sun.com/projects/plrg/PLDITutorialSlides9Jun2006.pdf)
21:10:58 <deech> Axman6: http://www.infoq.com/presentations/Thinking-Parallel-Programming
21:11:09 <Axman6> that's the one. hpc ^^^
21:12:25 <Axman6> "object true extends Boolean..." scares me a little though
21:12:54 <ddarius> Why?
21:12:58 <Axman6> but i guess traits are somewhat like classes in haskell
21:13:14 <cmccann> I wouldn't worry too much until you get to "object FILE_NOT_FOUND extends Boolean"
21:13:27 <hpc> haha
21:13:30 <Axman6> heh
21:14:34 <cmccann> anyway, that just sounds like some variation on modeling ML-style sum types by each case being a subtype of an abstract parent type that represents the sum
21:14:46 <Axman6> things like this are kinda cool (let's see if i can paste it without breaking things...): opr |self| : R = √((self.re)2 + (self.im)2)
21:14:47 <cmccann> though I didn't look at the presentation so maybe not
21:14:58 <cmccann> isn't that how Scala does it, though?
21:15:02 <dolio> If they're anything like traits in Scala, they're either used like Java interfaces, or as the name of an algebraic type.
21:15:14 <dolio> Where the constructors are classes/objects that inherit from the trait.
21:15:19 <dolio> Which is what that looks like.
21:15:55 <dolio> Can't say I'm really a fan of all the subtyping there, though.
21:16:10 <Axman6> wikipedia mentions scala as an influence
21:16:17 * cmccann notes that "choose behavior based on subtype polymorphism, not with conditionals" approach in OOP then has an interesting parallel to "pattern matching, not conditionals" style in ML-ish languages
21:16:22 <deech> Also it seems as though Fortress has some sort of dependant typing since you can that function only takes natural numbers etc.
21:17:09 <ddarius> It doesn't take any special typing at all to do that.
21:17:17 <Axman6> well natural numbers are just a type aren't they?
21:18:41 <ddarius> dolio: You could also prove continuity of adjunctions and show some quick consequences.
21:18:49 <deech> Aren't natural numbers positive? By specifying that an argument is a number that's always 0 or greater aren't we declaring a dependant type?
21:19:12 <acowley> no
21:19:21 <hpc> it's a dependent type if we say it is an INTEGER greater than zero
21:19:30 <ddarius> No it isn't.
21:19:35 <hpc> eh?
21:19:52 <hpc> anyhoo, naturals are just a plain boring type
21:19:52 <acowley> hpc is correct, that would be a subset type
21:20:03 <hpc> type Nat = [()]
21:20:07 <ddarius> That doesn't make it a dependent type.
21:20:19 <dolio> ddarius: The stuff in that paste isn't all I'm presenting tomorrow. I'll probably be spending at least half the time just talking about how you write identity functions and stuff in Agda.
21:20:28 <acowley> I assume he is packaging constructive evidence of non-negativity in his type
21:20:34 <ddarius> That doesn't make it a dependent type.
21:20:36 <acowley> that evidence must refer to the value
21:21:27 <dolio> The adjunction stuff is just a more involved example that ties back to other things that have been talked about.
21:22:24 <shachaf> What's the standard way of getting GHC 7 in Ubuntu nowadays?
21:22:34 <deech> shachaf: Haskell Platform.
21:22:35 <hpc> shachaf: platform
21:22:51 <hpc> the apt version is still 6.12.something
21:24:18 <cmccann> I feel a lot better about the quality of haskell questions on Stack Overflow after spending some time looking through questions from elsewhere on the site
21:24:28 <shachaf> deech, hpc: But the Ubuntu link on the HP website just links to the APT page.
21:24:34 <shachaf> Or are you suggesting installing from source?
21:24:36 <acowley> cmccann: you've been on an SO tear lately
21:25:37 <cmccann> acowley, really? I was absent for a while but that's all
21:26:17 <cmccann> unless you mean taking out frustrations via applying moderation tools to poor quality stuff, which I've been doing a lot of lately
21:26:25 <acowley> It's seemed like it to me. You've been writing a lot of really fantastic, detailed answers.
21:26:38 <acowley> No, I meant it in a good way
21:26:48 <cmccann> acowley, haha that's just back to normal I think
21:27:08 <deech> shachaf: I've never used those. I always downloads the GHC binary and build Platform from source.
21:27:14 <acowley> I guess it just seems like a seesaw between dons and you
21:27:20 <ddarius> "I, of course, always write really fantastic, detailed answers when I deign to write at all."
21:27:30 <cmccann> I've messed around on the SO data site and out of users with more than like 50 answers or so I'm consistently near the top for both "length of answer" and "upvotes per answer"
21:27:57 <acowley> sometimes dons is everywhere and seems to have answers before the question has been fully posted
21:28:00 <cmccann> and no, I'll never catch up with dons
21:28:04 <sully> 00:42 < hpc> type Nat = [()]
21:28:11 <deech> cmccann: I've learned a lot from your answers.
21:28:20 <cmccann> I'm glad! that's why I write them :)
21:28:39 <sully> hpc: for an assignment I wrote for CMU's PL class, I just treated nats as unit lists and had the parser and pretty printer special case them...
21:28:43 <deech> cmccann: Hopefully someday I can pay it forward :)
21:28:50 <acowley> ddarius: why don't you think subset types with propositional evidence of some kind of property are dependent types? I may be misunderstanding something.
21:29:04 <sully> the assignment was hard enough that I didn't want the students to have to implement any more crap
21:29:11 <shachaf> sully: Surely type Nat = [forall a. a]?
21:29:37 <sully> (it was HM polymorphic type inference, and it just had a single list type constructor instead of full recursive types)
21:29:39 <ddarius> shachaf: Nope, but that's closer.
21:29:51 <cmccann> deech, I actually found that answering question on SO improved my own understanding of Haskell a great deal
21:30:04 <shachaf> ddarius: What is it, then?
21:30:35 <ddarius> What natural number does fix (undefined:) correspond to?
21:30:57 <acowley> I hate writing up long answers on SO as most every time I start to do so, someone else submits a good answer first
21:31:37 <shachaf> Ah, fair enough.
21:31:51 <cmccann> acowley, if you're after gaining rep then yeah, being fast and correct is better than being detailed overall
21:31:54 <shachaf> How would you express Nat in Haskell?
21:32:26 <ddarius> The closest would be data Nat = Z | S !Nat
21:32:35 <edwardk> schachaf: you can get close with data Nat = Z | S !Nat
21:32:38 <cmccann> acowley, the optimal technique for getting rep is a quick-draw minimally correct answer, that you then edit a couple times to add detail
21:32:40 <acowley> cmccann: it's not just that. Sometimes longer answers run the risk of rambling.
21:32:44 <deech> cmccann, acowley : But the good ones always float up.
21:32:49 <edwardk> schachaf: but you need to content yourself with the extra _|_
21:33:29 <cmccann> if you look at the edit history on answers, you can probably find examples of both myself and dons doing that :P
21:33:33 <shachaf> edwardk: You mean _|_ :: Nat?
21:33:49 <edwardk> yeah
21:34:09 <acowley> I just checked and my most popular answer was like three lines :P
21:34:11 <cmccann> deech, to some extent, the number of potential voters viewing a question drops of over time, and drops massively after an answer is accepted
21:34:44 <deech> cmccann: good point.
21:35:00 <cmccann> but really, it doesn't matter that much, after getting enough rep for most of the useful extra privileges it's just a high score table
21:36:32 <dolio> "Can this function be written in terms of fix?"
21:36:33 <dolio> Yes.
21:36:45 <cmccann> heh
21:36:49 <ddarius> acowley: A dependent type is when a type depends on a value.  Your "propositional evidence" is at the value level.  It's simply requiring that when you say x : { T | P }, the compiler can prove x : T and P(x).
21:39:15 <cmccann> the main thing I'm unhappy about with the haskell tag on SO is that there are a lot of detailed, educational answers that are valuable outside the scope of the question they're attached to, but get lost in the pile over time
21:39:16 <ddarius> Depending on what you can use for P, though, you may be able to recover dependent typing.
21:39:45 <ddarius> cmccann: You should see IRC.
21:40:22 <cmccann> I've considered trying to sift through some older questions and compile a list of interesting answers, or maybe just extract the answers and edit them into a stand-alone form that could be put on the haskell wiki or something
21:40:42 <cmccann> but there's a lot of material :(
21:41:07 <shachaf> There should be a "Stack Overflow but only for interesting things".
21:41:16 <cmccann> ddarius, yes, but the existence of things that are even less optimal does not improve my feelings about the situation :)
21:41:45 <ddarius> cmccann: Improving your feelings about the situation was not the goal of my statement.
21:42:22 <cmccann> ddarius, true. I suppose that was obvious.
21:42:25 <Axman6> what's wrong with using data Nat = Nat Integer?
21:43:00 <Axman6> as long as the Num instance avoids negative numbers you'd be fine, and you wouldn't waste all the space data Nat = Z | S !Nat does
21:43:08 <ddarius> Axman6: A lot of things.
21:43:41 <ddarius> The best answer would be to support Natural directly.  All of GMPs routines are actually built on a library of arbitrary precision naturals.
21:44:16 <Axman6> yeah, I've always wondered why there wasn't a Natural type that uses GMP
21:44:25 <byorgey> a natively-supported Nat type would be great.
21:45:10 <Axman6> because the inductive version is amazingly wasteful, at least in terms of space
21:45:40 <cmccann> though sometimes lazy inductive naturals can be useful!
21:47:00 <dolio> data Nat = Nat Integer has two extra bottoms, instead of one.
21:47:11 <dolio> And of course, infinitely many other extra values.
21:47:25 <acowley> ddarius: I disagree, iirc in Coq {x | P} is a type whose constructor takes an argument whose type is (P x).
21:49:36 <spetrea> acowley: usin Coq to prove stuff ?
21:49:42 <dolio> That's Coq.
21:49:47 <ddarius> acowley: There are other ways of slicing things.
21:49:48 <dolio> What's it like in Fortress?
21:50:00 <spetrea> Fortress, that stack based language ?
21:50:07 <acowley> spetrea: that's Factor
21:50:18 <spetrea> oh, forgot about it :(
21:50:21 <spetrea> anyway, just woke up
21:50:24 <Axman6> Integer also doesn't support infinity = S infinity
21:50:54 <Axman6> strange that infinity is actually one of the smallest naturtal values to represent in haskell that way (smallest Nat i mean)
21:50:55 <acowley> I guess I don't see how to think about a subset type whose type doesn't refer to a value
21:54:29 * hackagebot network 2.3.0.4 - Low-level networking interface  http://hackage.haskell.org/package/network-2.3.0.4 (BryanOSullivan)
21:58:30 * hackagebot hsignal 0.2.3 - Signal processing and EEG data analysis  http://hackage.haskell.org/package/hsignal-0.2.3 (VivianMcPhail)
22:04:31 * hackagebot authenticate 0.9.1.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.9.1.1 (MichaelSnoyman)
22:07:28 <tgeeky_> can anyone remember a paper that about random testing (like quickcheck, and I believe the page mentioned quickcheck on the first few pages) in another language (scala? ocaml?) with a pretty multilinear picture in the topleft of the first page?
22:07:51 <tgeeky_> i want to say the word 'boltzmann' was in the paper, but I can't find it :/
22:11:24 <tgeeky_> http://people.debian.org/~sthibault/graph-radial.pdf
22:11:27 <tgeeky_> that is quite pretty
22:12:05 <africastle> my god
22:12:42 <Axman6> what is it?
22:12:55 <Axman6> it's making my pdf viewer rage with its complexity
22:13:19 <cmccann> tgeeky_, good lord, a bunch of haskell packages seem to be condensing into some sort of black hole in the lower right
22:13:24 <Axman6> the haskell section is quite dense...
22:13:36 <dankna> !
22:14:06 * cmccann guesses that's due to more small packages with interdependencies
22:14:47 <tgeeky_> hehe
22:14:58 <tgeeky_> just some thing i stumbled upon searching for the above
22:15:08 <tgeeky_> cmccann: i think one of the blackholes is xmonad
22:15:21 <richcollins> I'm an OO programming trying to understand the practical utility of FP (one concept at a time).  Can anyone point me to a practical example where currying is useful?
22:15:27 <edwardk> hah i wonder where mine are in that
22:15:39 <ddarius> What is a "multilinear picture"?
22:15:46 <richcollins> I don't know haskell but I figured that this was the best place to ask
22:16:36 <dmwit> Do you mean partial application or turning a two-argument function into a function of one pair argument?
22:16:42 <ddarius> "graph-radial: it shows all the failed/dep-wait packages in a graph way. Learn your xfig zoom/unzoom commands (z/Z) to quickly browse in it. You mostly need to focus on big connected components. There is a color legend somewhere in the graph (graphviz doesn't let me choose where)."
22:16:43 <edwardk> oh thats all of debian
22:17:38 <edwardk> tgeeky: the pile of orange in the lower right appears to be the haskell packages
22:17:42 <dmwit> (richcollins, that question was aimed at you)
22:18:04 <richcollins> dmwit: The latter is fine
22:18:10 <richcollins> reading this http://msmvps.com/blogs/luisabreu/archive/2009/08/26/currying-in-javascript.aspx ...
22:18:12 <ddarius> richcollins: You probably use encodings of curried functions all the time in whatever OO language you use.  (Taken one way, you -constantly- use such encodings...)
22:18:54 <richcollins> ddarius: What do you mean by "encodings".  Can you give me an example?
22:20:08 <dmwit> richcollins: It's useful when you want to return or store multiple arguments to a function.
22:20:32 <dmwit> e.g. map (uncurry f) [(a1, b1), (a2, b2), (a3, b3)]
22:21:07 <dmwit> or: uncurry f (g x y z) -- when g takes three arguments, and returns both of f's arguments
22:21:10 <richcollins> dmwit: Any chance you can give me a simple real world example?
22:21:11 <dmwit> :t uncurry
22:21:12 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
22:21:56 <richcollins> preferably in a language other than haskell (as I don't understand the syntax).  Javascript would be fine :-)
22:22:03 <dmwit> richcollins: I just did "ack uncurry" in my programming directory. Here's a handful of results:
22:22:27 <dmwit> most p = uncurry (>) . join (***) length . partition p -- for checking whether most of the elements of a list satisfy a predicate
22:22:36 <shachaf> richcollins: Sometimes when people -- e.g., that article -- say "currying", they really mean partial application.
22:22:42 <dmwit> circle = uncurry (circle' `on` fromIntegral) -- in a game that I'm writing
22:22:51 <ddarius> shachaf: Depressingly often.
22:23:02 <richcollins> shachaf: I see
22:23:09 <dmwit> problem 27 = uncurry (*) maximalCoefficients -- from a solution to Project Euler
22:23:11 <ddarius> I don't know why dmwit is describing uncurrying though.
22:23:42 <richcollins> I've found great uses for first class functions in OO, I'm trying to understand which other techniques are useful as well
22:23:50 <dmwit> ddarius: ...good point
22:24:04 <ddarius> Currying (as in what curry does) is equivalent to supporting first class functions.
22:24:17 <richcollins> I just chose currying because it was an FP concept that I don't use
22:24:18 <dmwit> I think I'll stop giving examples of uncurry. =P
22:24:30 <richcollins> perhaps there are others that are more interesting
22:24:46 <dmwit> I don't have a single call to "curry" in my programming directory. =P
22:24:56 <dmwit> But then, most functions just take multiple arguments rather than tuples to begin with.
22:25:00 <dmwit> So that shouldn't be too surprising.
22:25:42 <cmccann> dmwit, and by "take multiple arguments" you mean "multiple arguments in curried form"
22:25:47 <cmccann> for sake of clarity
22:26:05 <dmwit> alright
22:26:21 <cmccann> in other words, explicit currying is not terribly useful in Haskell because almost everything is written that way by default
22:27:29 * ddarius doesn't understand the mystique around "currying" (with either meaning).  Partial application is just application.  Literally.  There is no difference.  Currying is a trivial (but essential) case of first class functions.  If you can use first class functions, you more than understand either of these.
22:28:51 <cmccann> ddarius, well, the mystique of currying reduces to that of partial application, because curried form tends to make partial application more convenient
22:29:06 <b930913> Is there anyone on who can try teach me haskell? I've tried with online tutorials for the past few weeks, but I just don't get it...
22:29:06 <cmccann> why partial application is a big deal though, I have no idea
22:29:30 <richcollins> cmccann: Are there other concepts from FP other than first class functions that I would find interesting as an OO developer?
22:30:03 <ddarius> There's an entire book on design patterns inspired by FP, and that's just a small selection of ideas.
22:30:27 <cmccann> richcollins, honestly? any and all. I don't think there's anything I've learned from Haskell that hasn't been useful to know when doing OOP, which is my day job
22:30:39 <mauke> b930913: do you know any other programming languages?
22:31:05 <b930913> mauke: Yes. Apparently that causes problems.
22:31:17 <mauke> b930913: which ones?
22:32:01 <b930913> VB, PHP, JS to name a few.
22:32:11 <b930913> You can see why I want to learn haskell :p
22:32:23 <cmccann> b930913, oh dear, that sounds dreadful
22:32:27 <mauke> JS is your best friend here
22:32:40 <richcollins> cmccann: Can you give me an example of something that you can do in FP that allows you to be more productive than you could in an OO language?
22:33:00 <mauke> b930913: is there a particular stumbling block?
22:33:02 <cmccann> richcollins, not at 2am with a mild headache, sorry :P
22:33:03 <richcollins> I certainly consider first class functions to be in this category, although many OO languages support them
22:33:06 <richcollins> cmccann: heh
22:33:16 <Axman6> b930913: which tutorials have you tried?
22:33:46 <cmccann> richcollins, but I can say that it's not really about specific techniques, it's about having an intuitive grasp of a wider range of concepts
22:34:05 <b930913> Axman6: Ones that come up when you google "haskell tutorial" :p
22:34:21 <cmccann> richcollins, programming is mostly about using abstraction; the wider your vocabulary of abstract concepts to draw from, the better off you'll be in any language
22:34:22 <Axman6> did that include LYAH?...
22:34:24 <Axman6> @where lyah
22:34:24 <lambdabot> http://www.learnyouahaskell.com/
22:34:36 <Axman6> which has now been made into a book
22:35:38 <kfish> a book!
22:35:44 <ddarius> a fig!
22:35:44 <b930913> mauke: I just can't get my head round the translation between "function inc(n){n=n+1;return n;}" and "n :: Integer -> Integer; n | n+1" (Or however it is.)
22:36:01 <b930913> Axman6: Yeah, I just tried that one.
22:36:06 <richcollins> cmccann: As long as you find ways to put those abstractions to productive use
22:36:39 <richcollins> cmccann: I don't find much use in Java's unboxing in Io for instance :-P
22:36:42 <mauke> b930913: it's "inc n = n + 1"
22:36:55 <b930913> mauke: See? :p
22:36:58 <mauke> b930913: and actually pretty close to "function inc(n
22:37:04 <mauke> b930913: and actually pretty close to "function inc(n) n + 1"
22:37:12 <mauke> but that only works in javascript, not ecmascript
22:37:35 <cmccann> richcollins, sometimes just knowing certain concepts will help you bridge a gap between other concepts, which has productive use even if the original inspiration isn't used directly
22:38:02 <Axman6> b930913: you need to understand that you're just describing algorithms. so the function inc takes a number n and adds one to it, fo inc n = n + 1
22:38:06 <b930913> It just seems too much prolog type.
22:38:08 <Axman6> so*
22:38:35 <mauke> inc = function (n) n + 1;  // javascript
22:38:43 <mauke> inc = \n -> n + 1  -- haskell
22:39:00 <Axman6> kfish: a real book!
22:45:05 <b930913> Can someone teach me how to solve http://www.newscientist.com/article/mg21028141.300-enigma-number-1648.html using haskell?
22:45:42 <mauke> I wouldn't know how to do it in any programming language except by using brute force
22:46:28 <b930913> mauke: So I guess I'll learn nested loops then?
22:46:56 <ion>  let inc = runIdentity . runReaderT ((+1) <$> ask) in inc 42
22:46:57 <ion> 43
22:47:14 <ion> That’s how you implement inc in Haskell.
22:47:18 <mauke> > asks (+1) 42
22:47:18 <lambdabot>   43
22:47:33 <pikhq> ion: XD
22:47:49 <b930913> mauke: Shouldn't this be easy and concise compared to other languages?
22:47:49 <pikhq> ion: Nice work, though.
22:48:06 <ddarius> That enigma problem would be a few lines of Oz for a not brute-force solution, though a brute-force solution would be like two lines of Haskell.
22:48:24 <mauke> b930913: I don't know
22:48:34 <mauke> this isn't very interesting as a programming problem
22:49:03 <b930913> mauke: But can you teach it?
22:49:08 <mauke> no
22:49:15 <mauke> I'd have to solve it first
22:51:55 <Axman6> b930913: adding numbers is going to be about the same in most programming languages. it's when you're writing more complex ideas that you want the language to be more useful
22:52:21 <Axman6> also, inc = (+1) works as well, which is easier than most other languages =)
22:52:26 * ddarius only uses useless languages for simple problems.
22:52:27 <b930913> $ ghci let enig = ["CINEMA", "ECZEMA", "EMMA", "ENEMA", "ENIGMA", "MAMMA", "STIGMA"]
22:52:31 <b930913> Is that right?
22:52:36 <Axman6> no
22:52:43 <Axman6> run ghci first, then enter that
22:52:53 <Axman6> ghci is an interactive interpreter
22:52:58 <Axman6> like lambdabot:
22:53:00 <Axman6> > 1 + 1
22:53:01 <lambdabot>   2
22:53:07 <Axman6> > 3^13345
22:53:08 <lambdabot>   152455899226156588141815320905649915720007218300872852647834501656678239682...
22:53:14 <b930913> > let enig = ["CINEMA", "ECZEMA", "EMMA", "ENEMA", "ENIGMA", "MAMMA", "STIGMA"]
22:53:15 <lambdabot>   not an expression: `let enig = ["CINEMA", "ECZEMA", "EMMA", "ENEMA", "ENIGM...
22:53:23 <shachaf> ddarius: Do you mean that when a problem is simple, you'll restrict yourself to a useless language, or that when you're using a useless language, you'll restrict yourself to simple problems?
22:53:28 <Axman6> you need an in if you want to use lambdabot like that
22:53:38 <Axman6> > let foo = 2 in 7 * foo
22:53:39 <lambdabot>   14
22:54:38 <ddarius> shachaf: The logical interpretation of my statement is "problem is simple => I use a useless language" which is closer to the former.
22:54:59 <b930913> So given "EMMA" is divisible by 9, how could we print all the possibilities?
22:55:12 <Axman6> eh?
22:55:25 <Axman6> in what world is a strong divisable by a number?
22:55:46 <ddarius> instance Num String where ...
22:55:46 <b930913> Axman6: If we assume [0-9] can be represented by letters.
22:56:01 <ddarius> Axman6: 9 isn't necessarily a number.
22:56:15 * Axman6 slaps you both and heads off
22:56:19 <ivanm> Axman6: you have Map Char -> Digit
22:56:22 <shachaf> instance IsString Float where ...
22:56:27 <ddarius> Axman6: That is the correct response.
22:56:36 <b930913> "consistently replacing digits with letters, with different letters used for different digits"
22:57:03 <Axman6> shachaf: D:
22:57:36 <mauke> > let select [] = []; select (x : xs) = (x, xs) : map (fmap (x :)) (select xs) in select "abc"
22:57:37 <lambdabot>   [('a',"bc"),('b',"ac"),('c',"ab")]
22:57:43 <ivanm> shachaf: you need an encoding there as well... ;-)
22:57:46 <Axman6> anyway, if EMMA is divisable by 9, then the repeated sum of the digits of EMMA should also give the digit for 9 right?
22:57:53 <mauke> @let select [] = []; select (x : xs) = (x, xs) : map (fmap (x :)) (select xs)
22:57:54 <lambdabot>  Defined.
22:58:18 <Axman6> > select "abc"
22:58:20 <lambdabot>   [('a',"bc"),('b',"ac"),('c',"ab")]
23:01:01 <b930913> Axman6: I think so.
23:01:29 <Axman6> b930913: are all those supposed to be divisible by 9?
23:01:50 <b930913> Axman6: Bar one.
23:01:57 <Axman6> lame, heh
23:02:00 <b930913> But we can put that aside for later.
23:02:05 <Axman6> ok, should still be possible
23:02:16 <Axman6> is this a project euler problem btw?
23:02:20 <Axman6> or something similar?
23:02:47 <ddarius> Axman6 fails to take his own advice.
23:02:48 <b930913> Axman6: No, it's the equivalent to a crossword in a newspaper.
23:03:07 <mauke> @let div9 xs = guard (sum xs `mod` 9 == 0)
23:03:08 <lambdabot>  Defined.
23:03:09 <Axman6> which advice?
23:04:26 <ddarius> [02:27] * Axman6 slaps you both and heads off
23:04:29 <mauke> > runStateT (do { a <- draw; m <- draw; div9 [m,a,m,m,a]; e <- draw; div9 [e,m,m,a]; n <- draw; div9 [e,n,e,m,a]; return () }) [0 .. 9]
23:04:31 <lambdabot>   [((),[0,2,5,7,8,9]),((),[0,1,2,5,8,9]),((),[0,2,4,5,8,9]),((),[0,1,4,5,7,9]...
23:04:52 <Axman6> :o
23:05:04 <Axman6> :t draw
23:05:05 <lambdabot> forall a. StateT [a] [] a
23:05:20 * b930913 doesn't get much of that.
23:05:25 <mauke> > runStateT (do { a <- draw; m <- draw; div9 [m,a,m,m,a]; e <- draw; div9 [e,m,m,a]; n <- draw; div9 [e,n,e,m,a]; c <- draw; i <- draw; div9 [c,i,n,e,m,a]; z <- draw; div9 [e,c,z,e,m,a]; return () }) [0 .. 9]
23:05:26 <lambdabot>   [((),[0,2,9]),((),[0,8,9]),((),[0,5,9]),((),[0,4,9]),((),[0,1,9]),((),[0,7,...
23:05:39 <Axman6> b930913: me either, i can see how it works, but ... well I'm impressed
23:05:52 <mauke> > runStateT (do { a <- draw; m <- draw; div9 [m,a,m,m,a]; e <- draw; div9 [e,m,m,a]; n <- draw; div9 [e,n,e,m,a]; c <- draw; i <- draw; div9 [c,i,n,e,m,a]; z <- draw; div9 [e,c,z,e,m,a]; g <- draw; div9 [e,n,i,g,m,a] }) [0 .. 9]
23:05:54 <lambdabot>   []
23:05:55 <b930913> I don't see how it works :(
23:05:58 <mauke> aww
23:06:13 <Axman6> b930913: if you're as new to haskell as you say you are, you're not supposed to :P
23:06:17 <b930913> mauke: Does that mean they don't all divide?
23:06:25 <Axman6> it's pretty advanced stuff
23:06:31 <mauke> b930913: it's a test if "stigma" is the solution
23:06:45 <b930913> mauke: Is it?
23:06:49 <mauke> no
23:07:03 <pikhq> mauke: That's pretty clever, BTW.
23:07:15 <mauke> Axman6: draw = StateT select
23:07:27 <Axman6> ah, cool
23:08:28 <ion> :t select
23:08:29 <lambdabot> forall t. [t] -> [(t, [t])]
23:08:43 <ekipan> it was @let'ed earlier
23:09:14 * b930913 still doesn't know haskell any better :(
23:09:24 <Axman6> you're not supposed to
23:10:01 <ddarius> > runStateT $ do [a,m,e,n,c,i,z,g] <- replicateM 8 draw;lift (msum $ map div9 [[e,m,m,a], [m,a,m,m,a], [e,n,e,m,a], [c,i,n,e,m,a], [e,c,z,e,m,a], [e,n,i,g,m,a]]
23:10:02 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
23:10:08 <ddarius> > runStateT $ do [a,m,e,n,c,i,z,g] <- replicateM 8 draw;lift (msum $ map div9 [[e,m,m,a], [m,a,m,m,a], [e,n,e,m,a], [c,i,n,e,m,a], [e,c,z,e,m,a], [e,n,i,g,m,a]])
23:10:08 <lambdabot>   Ambiguous occurrence `lift'
23:10:09 <lambdabot>  It could refer to either `Control.Monad.Trans....
23:10:20 <ddarius> > runStateT $ do [a,m,e,n,c,i,z,g] <- replicateM 8 draw;Control.Monad.Trans.lift (msum $ map div9 [[e,m,m,a], [m,a,m,m,a], [e,n,e,m,a], [c,i,n,e,m,a], [e,c,z,e,m,a], [e,n,i,g,m,a]])
23:10:21 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [((), [a])])
23:10:21 <lambdabot>    arising fro...
23:10:30 <Axman6> b930913: I'd recommend going back to LYAH and making sure you write out everything it tells you to, and you make sure you understand everything you've ewritten befote moving on
23:10:37 <ddarius> > flip runStateT [0..9] $ do [a,m,e,n,c,i,z,g] <- replicateM 8 draw;Control.Monad.Trans.lift (msum $ map div9 [[e,m,m,a], [m,a,m,m,a], [e,n,e,m,a], [c,i,n,e,m,a], [e,c,z,e,m,a], [e,n,i,g,m,a]])
23:10:39 <lambdabot>   [((),[8,9]),((),[6,9]),((),[7,8]),((),[6,8]),((),[6,8]),((),[6,7]),((),[7,8...
23:10:58 <ddarius> > flip evalStateT [0..9] $ do [a,m,e,n,c,i,z,g] <- replicateM 8 draw;Control.Monad.Trans.lift (msum $ map div9 [[e,m,m,a], [m,a,m,m,a], [e,n,e,m,a], [c,i,n,e,m,a], [e,c,z,e,m,a], [e,n,i,g,m,a]])
23:11:00 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
23:11:05 <ddarius> > flip execStateT [0..9] $ do [a,m,e,n,c,i,z,g] <- replicateM 8 draw;Control.Monad.Trans.lift (msum $ map div9 [[e,m,m,a], [m,a,m,m,a], [e,n,e,m,a], [c,i,n,e,m,a], [e,c,z,e,m,a], [e,n,i,g,m,a]])
23:11:07 <lambdabot>   [[8,9],[6,9],[7,8],[6,8],[6,8],[6,7],[7,8],[5,8],[5,7],[8,9],[6,9],[6,8],[6...
23:11:13 <b930913> Axman6:     ghci> let triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ]   I get stuck on.
23:11:38 <ddarius> :t div9
23:11:39 <lambdabot> forall a (m :: * -> *). (Integral a, MonadPlus m) => [a] -> m ()
23:13:38 * hackagebot MonadCatchIO-mtl 0.3.0.3 - Monad-transformer version of the Control.Exception module  http://hackage.haskell.org/package/MonadCatchIO-mtl-0.3.0.3 (DanielGorin)
23:15:56 <mauke> > [xs | xs@[a,c,e,g,i,m,n,s,t,z] <- permutations [0 .. 9], length (filter ((== 0) . (`mod` 9) . sum) [[m,a,m,m,a], [e,m,m,a], [e,n,e,m,a], [c,i,n,e,m,a], [e,c,z,e,m,a], [e,n,i,g,m,a], [s,t,i,g,m,a]]) == 6]
23:15:59 <lambdabot>   mueval-core: Time limit exceeded
23:16:06 <ion> > let not = fromMaybe True . (False <$) . guard in not False
23:16:08 <lambdabot>   True
23:17:11 <ddarius> mauke: It's not the sum.
23:17:23 <mauke> 'tis not?
23:17:40 <ddarius> EMMA -> 0113 e.g.
23:17:50 <ddarius> Or I guess 1223 I should say.
23:18:06 <mauke> what about it?
23:18:20 <ddarius> Ah, you're using Axman6's simplification.
23:18:30 <mauke> huh?
23:19:01 <mauke> and there are 24 possible assignments
23:19:45 <sipa> rgoeiemorgen
23:22:26 <mauke> enema
23:23:31 <b930913> mauke: Explain?
23:23:53 <mauke> explain what?
23:24:04 <b930913> mauke: How to do it.
23:24:11 <mauke> no
23:24:54 <b930913> Will anyone else teach me haskell?
23:25:39 <mauke> I don't think this is a good problem to teach haskell
23:26:12 * ddarius just doesn't think the ROI would be worth it this case.
23:26:16 <b930913> mauke: Pick a better problem?
23:26:43 <mauke> I haven't looked at it but how about the exercises in LYAH?
23:27:30 <ddarius> mauke: He already didn't read LYAH.  You should offer him another resource to not read.
23:28:47 <b930913> ddarius: I did read. I then got stuck.
23:29:11 <mauke> explain your stuckness
23:30:07 <b930913> "[07:33]	b930913	Axman6: ghci> let triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ] I get stuck on."
23:30:22 <mauke> yes
23:30:24 <mauke> explain your stuckness
23:30:44 <b930913> It seems a rather large leap from zip.
23:30:59 <b930913> What on earth is that doing?
23:32:11 <ekipan> > [ (a, b) | a <- [1..3], b <- [4..6] ]
23:32:12 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
23:32:24 <ion> For each c in [1..10]: for each b in [1..10]: for each a in [1..10]: (a,b,c) is added to the result
23:33:00 <mauke> b930913: but that's explained right on that page
23:33:17 <mauke> b930913: why are you stuck?
23:33:18 <ddarius> The notation is actually used extensively before zip is discussed.
23:33:55 <b930913> Can you go through each character/word and explain it?
23:34:14 <mauke> ok, "I'm a list comprehension" is a headline
23:34:24 <mauke> "I'm" is a contraction for "I am"
23:34:45 <mauke> wait, if you don't understand english, how am I going to explain this?
23:34:57 * ddarius refers back to his ROI comment.
23:49:33 <isomorphic> @type skipMany
23:49:34 <lambdabot> Not in scope: `skipMany'
23:49:51 <isomorphic> @type optional
23:49:52 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f (Maybe a)
23:50:23 <ddarius> Quinces are weird.
23:52:23 <isomorphic> So, I have a parser with a type signature that ends with ( )
23:52:35 <isomorphic> it's a parser that skips stuff - returning nothing
23:52:59 <isomorphic> .... should I be able to fmap something inside it to change it into Nothing?
23:53:35 <isomorphic> ie: Perhaps change () to Maybe String?
23:53:56 <opqdonut> fmap (const Nothing) ?
23:54:21 <ekipan> which is the same as (>> return Nothing)
23:54:30 <opqdonut> sure
23:55:06 <isomorphic> opqdonut: I had a crack at that - ghc complained :P - now that I know it should work, I'll keep trying :P
23:55:10 <isomorphic> thanks :)
23:55:26 <ClaudiusMaximus> might need a type signature to fix Nothing :: Maybe String
23:55:28 <opqdonut> the mentioned (>> return Nothing) is perhaps nicer
23:55:47 <opqdonut> :t Nothing -- what ClaudiusMaximus said
23:55:48 <lambdabot> forall a. Maybe a
23:56:06 <ddarius> > :t (Nothing <$)
23:56:06 <lambdabot>   <no location info>: parse error on input `:'
23:56:14 <ddarius> :t (Nothing <$)
23:56:15 <lambdabot> forall a (f :: * -> *) b. (Functor f) => f b -> f (Maybe a)
23:56:32 <isomorphic> the corresponding version would be pure `fmap` parser, yes?
23:57:37 <isomorphic> ie: I'm trying to get two separate parsers to both have a similar type - this one returns a string - so it'll be Just str
23:59:04 <ClaudiusMaximus> :t asTypeOf
23:59:05 <lambdabot> forall a. a -> a -> a
