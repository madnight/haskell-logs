00:54:43 <ion> Is there a nice way to do ‘foo >>= \c -> sequence [return c, bar c]’, that is, return a list of the result value of foo and the result value of bar applied to the result value of foo?
00:55:56 <ion> s/return/result in/
00:55:59 <c_wraith> @pl \c -> sequence [return c, bar c]
00:56:00 <lambdabot> sequence . liftM2 (:) return (return . bar)
00:56:09 <c_wraith> ...  ok, that's horrible.
01:10:14 <mjrosenb> mapM_ ($c) [return, bar]
01:10:35 * mjrosenb thinks that is equivalent
01:10:54 <mjrosenb> err \ c -> mapM_ ($c) [return, bar]
01:10:58 <mjrosenb> :t \ c -> mapM_ ($c) [return, bar]
01:10:58 <lambdabot> Not in scope: `bar'
01:11:15 <mjrosenb> :t let bar = return in \ c -> mapM_ ($c) [return, bar]
01:11:16 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m ()
01:11:29 <ion> Without the _
01:11:43 <mjrosenb> :t let bar = return in \c -> sequence [return c, bar c]
01:11:44 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m [a]
01:11:47 <mjrosenb> indeed.
01:12:22 <mjrosenb> and i bet sequence_ would do the same thing as with mapM_ :-p
01:12:59 <mjrosenb> @pl \ c -> mapM_ ($c) [return, bar]
01:13:00 <lambdabot> flip mapM_ [return, bar] . flip id
01:13:55 <mjrosenb> ...yeah, sometimes the lambda is nicer.
01:23:51 <shachaf> mjrosenb: (sequence_ .: sequence) ?
01:24:08 <shachaf> mjrosenb: What's the point of a return in a mapM_, anyway?
01:26:03 <mjrosenb> shachaf: this thought has come to mind
01:26:20 <shachaf> Oh, that was originally a sequence, not a sequence_.
01:26:33 <mjrosenb> shachaf: however, i guess we don't want to count on the monad laws holding :-p
01:26:44 <mjrosenb> that too.
01:27:24 <shachaf> @ty (sequence .: sequence)
01:27:25 <lambdabot> forall (m :: * -> *) a (g :: * -> *). (Monad m, Monad g, Functor g) => [g (m a)] -> g (m [a])
01:38:36 * mjrosenb wonders how well you could write an equiv function that would take two descriptions and say if it could prove that they are the same
01:48:08 <roconnor> is a prefix-free and a self-deliminating code the same thing?
01:48:25 <roconnor> maybe prefix-free is simply a type of self-deliminating code
01:48:43 <mjrosenb> self-deliminating?
01:49:18 <roconnor> mjrosenb: it means given a stream of bits you can tell where the data ends without an EOF marker or anything
01:49:24 <wjt> @hoogle m a -> m b -> m (a, b)
01:49:24 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
01:49:24 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
01:49:25 <lambdabot> Language.Haskell.TH strictType :: Q Strict -> TypeQ -> StrictTypeQ
01:50:16 <ion> :t liftM2 (,)
01:50:17 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
01:50:32 <mjrosenb> roconnor: ahh.
01:50:34 <wjt> oh, right. (rusty...)
01:51:02 <mjrosenb> > liftM2 (,) [1,2,3] "hel"
01:51:03 <lambdabot>   [(1,'h'),(1,'e'),(1,'l'),(2,'h'),(2,'e'),(2,'l'),(3,'h'),(3,'e'),(3,'l')]
01:51:08 <ion> Not quite the same as zip, though.
01:51:11 <mjrosenb> yeah, cross product.
01:51:19 <mjrosenb> s/cross/cartesian/
01:52:02 <fairy44> i have a problem building curl package with ghc 7, i'm getting Assembler errors like these: http://paste.org/pastebin/view/34715
01:52:13 <marnix> roconnor: https://secure.wikimedia.org/wikipedia/en/wiki/Prefix_code says "self-synchronizing codes, a subclass of prefix codes"
01:52:23 <ion> > liftA2 (,) (ZipList [0..2]) (ZipList [3..5])
01:52:23 <lambdabot>   No instance for (GHC.Show.Show
01:52:24 <lambdabot>                     (Control.Applicative.Zip...
01:52:28 <fairy44> any ideas on how to resolve this? or is there another package that does https?
01:53:04 <ion> > getZipList $ liftA2 (,) (ZipList [0..2]) (ZipList [3..5])
01:53:05 <lambdabot>   [(0,3),(1,4),(2,5)]
01:53:30 <roconnor> marnix: I think that self-synchronizing might be something different from self-deliminating
01:53:50 <mjrosenb> fairy44: what version of the curl package?
01:54:24 <fairy44>  1.3.6
01:54:42 <mjrosenb> roconnor: self-synchronizing means that if you start in the middle of a stream, you can determine when the next token starts?
01:55:26 <mjrosenb> because i do not think that prefix free codes have that property
01:55:39 <mjrosenb> fairy44: i'm trying to build it.  i'll see how it goes.
01:56:01 <fairy44> libcurl version is 7.21.6 (debian testing), amd64
01:56:30 <mjrosenb> fairy44: i *doubt* this has anything to do with libcurl, but i'll keep that in mind.
01:56:35 <mjrosenb> fairy44: what gcc version?
01:57:47 <fairy44> I am guessing 4.5 (4.4, 4.5, 4.6 are installed, /usr/bin/gcc points to 4.5) - is there a way to check which one ghc uses?
02:00:12 <mjrosenb> fairy44: i've heard that /usr/bin/ghc is just a shell script that will have that info, but I don't know.
02:00:52 <mjrosenb> hrmm, it would appear as if portage is attempting to build 1.3.7
02:02:19 <mjrosenb> 1.3.7 just built correctly
02:04:37 <fairy44> 64 bit too?
02:04:47 <fairy44> and which gcc and ghc?
02:06:35 <mjrosenb> The Glorious Glasgow Haskell Compilation System, version 7.0.3
02:06:38 <mjrosenb> gcc (Gentoo 4.5.2 p1.0, pie-0.4.5) 4.5.2
02:07:02 <fairy44> thanks
02:08:20 <mjrosenb> and the ebuild doesn't have anything fancy in it-- so we didn't patch the sources or anything
02:11:34 <fairy44> i forgot 'cabal update', now it installs 1.3.7 correctly -- v1.3.6 used -fvia-c which is buggy and deprecated
02:11:38 <fairy44> thanks for help :)
02:12:46 <mjrosenb> np.
02:13:05 * mjrosenb is in general, not a fan of cabal-install
02:15:24 <k0ral> hey guys, do you think it would be relevant to create a socat-like tool for zeromq ?
02:15:58 <mjrosenb> k0ral: what are socat and zeromq?
02:16:38 <k0ral> mjrosenb: socat is a commandline tool to use sockets
02:16:53 <k0ral> mjrosenb: zeromq is a high level socket-like library
02:17:20 * mjrosenb is in favor of more commandline tools
02:17:28 <mjrosenb> so socat is like netcat?
02:17:49 <k0ral> I don't know netcat
02:17:59 <fairy44> i think yes, but more general
02:18:10 <k0ral> wikipedia says: "Socat is a more complex variant of netcat"
02:18:15 <mjrosenb> more general than netcat?
02:18:17 <mjrosenb> :-o
02:18:33 * mjrosenb will need to try this out
02:18:44 <mjrosenb> netcat is one of the most useful things i have used
02:18:47 <ddarius> socat does encrypted connections as well and some other stuff
02:19:20 <mjrosenb> good to know if i ever want to test an https server
02:20:11 <mjrosenb> k0ral: cli interfaces should exist for every library.  i wholly recommend this project.
02:20:21 <k0ral> the thing is: zeromq has a library that is very easy to use: ~10 lines of code in most languages to read or write in a communication tube
02:21:07 <k0ral> so I'm wondering whether it's relevant to implement those 10 lines as a project; actually it would be 10 lines for reading, 10 lines for writing, 10 lines for publishing, 10 lines for subscribing...
02:21:09 <mjrosenb> so you are saying it will be very easy to write this interface.
02:21:39 <k0ral> so something closer to 100 lines actually
02:21:43 <mjrosenb> i mean, the original cat can be implemented as 10 lines of code.
02:21:51 <mjrosenb> it is still incredibly useful
02:22:10 <k0ral> yes, I'm also convinced such a tool would be really great
02:22:35 <k0ral> I was going to include it in another project, but instead it could be made an independent project
02:22:41 <mjrosenb> the fact that it is only going to be ~100 lines of code means it will be rather hard to get it wrong.
02:23:00 <ddarius> cat is useful because of the Unix "everything is a file" philosophy.
02:23:12 <mjrosenb> which is part of the unix philosophy, something that alot of beople have gotten away from.
02:23:17 <mjrosenb> *people
02:23:26 <k0ral> so true
02:23:38 <mjrosenb> stupid rsync, my lag is like 5 seconds
02:23:59 <k0ral> how do you think I should name such a project ?
02:24:11 <ddarius> http://www.dest-unreach.org/socat/doc/linuxwochen2007-socat.pdf
02:24:24 <fairy44> hs0cat ;)
02:24:48 <mjrosenb> mqcat?
02:24:53 <mjrosenb> zmqcat?
02:25:23 <k0ral> hs0cat would be confusing with socat
02:25:43 <k0ral> let's go for zmqcat
02:25:58 <ddarius> kumqat
02:26:08 <k0ral> kumqat ?
02:26:37 <k0ral> zmqat ?
02:28:52 <mjrosenb> ddarius: that sounds like a name collision with that new excercize regiment where you do squats with cucmbers over your eyes.
02:29:18 <k0ral> ^^
02:45:24 <roconnor> mjrosenb: ya, I didn't even know about self-synchronizing codes.  That sounds pretty awesome.
02:45:31 <roconnor> and a very strong property
02:47:39 <mjrosenb> roconnor: yeah, but as i said, i don't think prefix free codes have that property.
02:47:49 <roconnor> no not in general
02:48:06 <roconnor> but every self-syncronizing code must be prefix-free
02:48:31 <roconnor> so I guess it goes self-syncronizing c= prefix free c= self-deliminating
03:20:19 <roconnor> I just like to note that types are really awesome when refactoring code.
03:20:22 <roconnor> that is all
03:35:49 <ivanm> roconnor: awww, I was hoping for more info!
03:35:50 <ivanm> :p
03:36:16 <roconnor> :)
03:54:09 <robinhoode> @pl \x -> (x, x)
03:54:09 <lambdabot> join (,)
03:59:30 <joe6> i want to use a function with the name read, but the  ghci is confusing that with the Prelude read. Is there a way to hide that read function?
03:59:43 <joe6> i am not using it anywhere in my program, anyway.
04:00:23 <sepp2k> joe6: import Prelude hiding(read)
04:01:16 <sepp2k> Though apparently you have to do :m -Module first.
04:01:51 <joe6> import Prelude hiding (read)
04:01:57 <joe6> got it, thanks
04:02:02 <joe6> sepp2k: thanks
04:02:06 <sepp2k> np
04:04:28 <nihtml> :t join
04:04:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
04:04:47 <nihtml> @src join
04:04:47 <lambdabot> join x =  x >>= id
04:07:02 <xkb> I need to build a very simple JSON backend to use with JQuery -> what stack do I use?
04:07:17 <xkb> I kinda get lost in the forest of Yesod, Happstack etc.
04:10:48 <Entroacceptor> very simple sounds like happstack or snap
04:10:49 <Philonous> Is there a good text that explains what small-step, big-step, cpo and monad semantics of CBV and CBN are?
04:16:07 <k0ral> anyone could test something for me ?
04:16:21 <k0ral> I'm pasting code in hpaste
04:17:03 <opqdonut> Philonous: I'd recommend TAPL if you haven't read it yet
04:17:51 <k0ral> http://hpaste.org/47675
04:18:28 <k0ral> I tested the -rbrok mode and it doesn't work like expected
04:18:36 <k0ral> try the following:
04:19:10 <k0ral> launch "zmqat -req ipc:///tmp/backend OK"
04:19:34 <k0ral> then, in another console, launch "zmqat -rbrok ipc:///tmp/frontend ipc:///tmp/backend"
04:19:41 <Philonous> opqdonut: Uh, but does that even go into those topics? It only gives the reduction semantics of CBV lambda calculus, doesn't it?
04:20:03 <k0ral> and at last, launch in a third console "zmqat -req ipc:///tmp/frontend hello"
04:20:31 <k0ral> according to zeromq library, the first console should get the third console's request
04:20:43 <k0ral> but it doesn't happen to do anything
04:20:45 <opqdonut> Philonous: oh, sorry, I'm misremembering
04:20:53 <k0ral> did I do something wrong ?
04:20:54 <opqdonut> Philonous: I was thinking of this other book, just a sec
04:21:16 <opqdonut> Foundations for Programming Languages
04:21:20 <opqdonut> ( http://theory.stanford.edu/~jcm/books.html )
04:22:00 <opqdonut> chapts 5 and 7 should be of interest
04:22:57 <Philonous> opqdonut: That looks like a good book to read in any event. Thanks!
04:23:05 <opqdonut> you're welcome
04:23:43 <opqdonut> it was okay. some parts could've been more technical and some could've been more informal
04:23:57 <opqdonut> quite a lot of stuff for one book. took me about a year to go through it
04:26:38 <Philonous> Well, then I better get cracking
04:44:51 <k0ral> anyone ?
04:47:37 <chrisdone> Can someone change the link in the topic to this? http://hpaste.org/new/haskell
04:48:36 <ivanm> @type unfoldr
04:48:37 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
04:48:40 <haskelldude> hello everyone
04:48:41 <ivanm> @where ops
04:48:42 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
04:49:09 --- mode: ChanServ set +o mauke
04:49:10 --- topic: set to '["Paste code/errors: http://hpaste.org/new/haskell ", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin and spam issues: #haskell-ops"]' by mauke
04:49:20 <chrisdone> Cheers. :-)
04:49:26 <haskelldude> im still strugling to write my own HOF, without using Prelude functions... can some1 give me a hint? :)
04:49:47 <ivanm> chrisdone: what's the significance of the URL change?
04:49:53 <ivanm> defaults to Haskell as the formatting language?
04:50:00 --- mode: mauke set -o mauke
04:50:02 <ivanm> haskelldude: HOF == ?
04:50:09 <chrisdone> ivanm: And channel, yeah. Which follows nicely into channel announcements.
04:50:09 <ivanm> @all-dicts HOF
04:50:09 <ezyang> higher order fucntion
04:50:10 <lambdabot> No match for "HOF".
04:50:18 <haskelldude> HOF = higher order functions. sorry
04:50:28 <ivanm> chrisdone: you have hpaste bot back working?
04:50:30 <chrisdone> ivanm: (Working on that now.)
04:50:37 <ivanm> ezyang, haskelldude: duh :s
04:50:52 <ivanm> haskelldude: well, can you write your own version of map?
04:51:47 <haskelldude> ivanm: i need a new one...
04:51:59 <ivanm> OK, how 'bout filterOut ?
04:52:18 <jaspervdj> chrisdone: Cool to see you're attending CamHac :-)
04:52:32 <chrisdone> jaspervdj: You too. ;-)
04:52:52 <chrisdone> jaspervdj: Where are you staying?
04:53:37 <ski> haskelldude : what is your hof supposed to do ?
04:54:13 <jaspervdj> chrisdone: The Youth Hostel, it's the cheapest option but looks nice. Simon Meier is also staying there.
04:54:21 <haskelldude> ski: well im trying to write my own calculator to do operations like base conversion, etc...
04:54:50 <haskelldude> ivanm: how does that differ with foldr?
04:55:46 <ivanm> haskelldude: I just figured that if you had to write a HOF, any HOF, then a version of filter that takes out values that match the predicate would be straight-forward enough
04:57:03 <haskelldude> ivanm: so you recommend me to look into filter function and write my own similar to that?
04:57:11 <dankna> I just did an hpaste and it isn't showing up in-channel :(
04:57:32 <dankna> oh, he said it wasn't working yet
04:57:39 <dankna> http://hpaste.org/47676 if anyone wishes to see a limerick!
04:58:49 <ivanm> haskelldude: yes, if your goal is to just write any new HOF
04:58:54 <ski> haskelldude : do you want suggestions for hofs you can write, or what ?
05:00:07 <haskelldude> ski: yes pls :) can you? in the context of math functions?
05:00:09 <chrisdone> jaspervdj: Cool; what date(s) are you arriving/departing?
05:00:46 <chrisdone> dankna: Can't argue with that limerick.
05:01:19 <Feuerbach> by the way, is anyone here going to CEFP (an FP summer school in Budapest)?
05:01:19 <dankna> chrisdone: :D
05:05:40 <jaspervdj> chrisdone: Arriving on thursday 11, leaving sunday 14 (right after the hackathon), I'm going by car with some other folks
05:05:49 <BCoppens> with me! amongst others
05:05:51 <BCoppens> :p
05:06:54 <chrisdone> Haha. Okay.
05:11:04 <BCoppens> chrisdone: I remember we were supposed to meet you at BelHac too, no? :(
05:14:34 <chrisdone> BCoppens: Yeah, I had trouble booking flights as my UK cards were disabled for safety reasons while being sent over to me.
05:15:23 <BCoppens> ah :(
05:17:19 <chrisdone> BCoppens: Sorted now. ;-D
05:18:17 <BCoppens> chrisdone: well I now had trouble paying too: the verified by visa crap of my card had 'technical difficulties', so I had to let someone else pay it for me
05:18:54 <gavri> how do I take the two longest strings of an array? What I have now is:
05:18:58 <gavri> take 2 $ reverse $ sortBy (comparing length) ["one", "two", "three", "four", "five", "six", "seven"]
05:19:22 <gavri> it isn't optimal and doesn't read right
05:19:40 <gavri> of a list, I mean
05:21:40 <chrisdone> BCoppens: Me too. I tried booking with Travelodge and 3D secure (verified by visa/mastercard) just rejecting my italian card, and wouldn't register my UK debit card. What a pain in the nads.
05:21:42 <ivanm> gavri: an array or a list?
05:21:53 <ski> haskelldude : hm, i'm not sure what you mean by "math functions" (i consider all functions in haskell to be "math functions")
05:22:10 <BCoppens> chrisdone: yeah :(
05:22:11 <ivanm> > take 2 $ sortBy (flip compare `on` list) ["one", "two", "three", "four", "five", "six"]
05:22:12 <lambdabot>   Not in scope: `list'
05:22:19 <ivanm> > take 2 $ sortBy (flip compare `on` length) ["one", "two", "three", "four", "five", "six"]
05:22:20 <lambdabot>   ["three","four"]
05:22:22 <gavri> ivanm: a list
05:22:26 * ivanm obviously needs sleep
05:22:39 <ivanm> gavri: ^^
05:23:21 <gavri> ivanm: thanks. that solves the revrsing the list problem
05:23:55 <gavri> that still sorts the entire list though, when what I need is maximumTwoBy
05:24:04 <gavri> I'll have to write my own?
05:24:31 <ski> @src sortBy
05:24:31 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
05:24:42 <ski> gavri : it doesn't sort the whole list
05:25:42 <gavri> wait, is this some haskell laziness magic I'll never understand?
05:25:58 <gavri> that's seriously impressive
05:26:56 <gavri> to me anyway
05:28:03 <chrisdone> BCoppens: jaspervdj: I booked ‘De Vere University Arms’. Seemed to accept my italian card. Woopwoop.
05:28:18 <Axman6> gavri: if you only take the first elements of the list, then you don't need to sort the entire list, and using the right sorting algorithm means you can easily extract them
05:28:48 <dankna> it's not that magical :)
05:28:54 <Axman6> merge sort is one method that works very well (you only need O(n) comparisons to find the smallest element)
05:28:55 <dankna> it's just convenient!
05:40:19 <ezyang> Hmm, I've failed to install a package with Cabal properly. How odd.
06:09:24 <roconnor> @type last
06:09:24 <lambdabot> forall a. [a] -> a
06:09:29 <roconnor> :/
06:10:17 <ben> ?
06:10:22 <roconnor> not safe
06:10:41 <ClaudiusMaximus> http://www.haskell.org/hoogle/?hoogle=last+%2Bsafe
06:10:42 * roconnor uses listToMaybe . reverse instead
06:12:21 <dankna> nice trick, roconnor!
06:12:26 <dankna> I shall remember it
06:12:37 <roconnor> I solve all my problems wit listToMaybe
06:12:47 <dankna> yeah, Data.Maybe is a great little module
06:12:51 <ddarius> listToMaybe is a nice function.
06:12:57 <ddarius> A distributive law.
06:13:26 <roconnor> dankna: I also use listToMaybe . drop 98
06:13:53 <dankna> hah nice :D
06:14:08 <dankna> hm
06:14:20 <dankna> how the hell does LinkedIn know that I am vaguely connected to T Campbell?
06:14:38 <dankna> (one of the only people ever to make money as a webcomics /editor/, and not someone I know personally but only someone whose work I follow!)
06:15:04 <drdo> dankna: Put your tinfoil hat on!
06:15:10 <dankna> haha
06:16:25 <ddarius> Maybe T Campbell follows you.
06:16:31 <dankna> it's conceivable, I guess
06:16:44 <dankna> I'd be amazed if he were aware I exist :)
06:17:06 <dankna> oh!  I know.  we exchanged a round of email once a few years ago (I informed him that his reverse-DNS wasn't set up and I therefore couldn't receive his emails)
06:17:18 <dankna> LinkedIn offers to scan your mailbox for possible contacts when you join
06:18:46 <ddarius> And you let it?
06:19:19 <dankna> no, of course not, but he might have
06:26:38 <ski> dankna : that's not Taylor C., is it ?
06:27:02 <dankna> no, it's Tim Campbell, I believe, why?
06:27:36 <dankna> I have no idea who Taylor C. is, but you have made me curious :)
06:27:54 <ddarius> He's a Schemer that hung out here for a few years.
06:27:56 <dankna> oh cool
06:27:58 <dankna> but no
06:28:09 <dankna> I guess Tim goes by T because there's also an actor with that name
06:28:13 <ski> Taylor Campbell is Riastradh in #scheme, with several intersting things at <http://mumble.net/~campbell/>
06:28:16 <dankna> smart move - makes him much easier to google
06:28:22 <dankna> oh Riastradh, yes, I know him vaguely
06:28:28 <dankna> different person for sure though
06:28:50 <parcs> roconnor: there's also lastMay from the 'safe' package
06:30:00 <dankna> oh he's an author (the author?) of paredit!
06:30:12 <ski> the, yes
06:30:13 <dankna> paredit is good stuff and partial inspiration for my own thing
06:32:48 <ddarius> Structure editing: it will work out this time; really!
06:32:51 <roconnor> > False <= undefined
06:32:52 <lambdabot>   *Exception: Prelude.undefined
06:32:56 <roconnor> boo
06:33:07 <Veinor> > True >= undefined
06:33:07 * roconnor wants short circut <=
06:33:07 <dankna> ddarius: why do you feel it hasn't worked out in the past?  I think it has!
06:33:07 <lambdabot>   *Exception: Prelude.undefined
06:33:21 <roconnor> > undefined <= True
06:33:22 <lambdabot>   *Exception: Prelude.undefined
06:33:57 <roconnor> structured editing for code or for text?
06:34:06 <dankna> for code of course
06:34:15 <dankna> text in general has only very weak structure
06:34:19 <roconnor> yes
06:35:00 <ski> iirc, i saw some plugin for GF for Alfa, with structure editing wrt a grammar
06:35:17 <dankna> it's the future :D
06:35:30 * ddarius agrees with dankna on the last.
06:35:38 <dankna> heh, cool
06:35:57 <dankna> ddarius: I'm definitely curious what problems you feel it has (so I can avoid them or at least think about them) in existing incarnations.
06:37:46 <ddarius> dankna: My impression is that most programmers find structure editors awkward, limiting, and rigid, but the facts on the ground seem to be that there are very few popular structure editors and even fewer for popular programming languages despite people working on this since the '60s.
06:38:23 <dankna> that's fair enough
06:38:46 <dankna> well, I'd say that it's received only very limited attention
06:38:57 <dankna> I personally /love/ both paredit and nxml-mode (the latter is for XML)
06:39:06 <dankna> obviously what those have in common is that they're both very simple grammars
06:39:19 <ddarius> What problems do you view structure editors as solving?
06:39:47 <dankna> for me the biggest attraction is the ability to write simple scripts to perform custom refactoring operations, as I work
06:39:58 <dankna> also I freaking hate managing whitespace by hand
06:40:21 <dankna> and most of the style rules I wish I could have auto-applied pursuant to that need understanding of the full grammar to apply
06:41:10 <dankna> for example, I have a bunch of code in an old project that I showed off here a few days ago, and someone pointed out that if I used syb on it, I could eliminate half the lines.
06:41:17 <dankna> but it would be a lot of work to go through it and do that transformation.
06:41:39 <dankna> with a scriptable structure editor, I could write a script to do it for me.
06:42:12 <dankna> and then the structure editor would provide a handy diff saying "is this what you meant?" and waiting for my confirmation before actually committing the changes, of course
06:43:08 <dankna> it could also be useful for maintaining downstream dependencies - when you make breaking API changes, you could ship your upgrade with a set of scripts that the downstream programmer could apply (again, with confirmation before commit) to his own project
06:43:20 <dankna> that use-case just occurred to me
06:44:07 <dankna> also also, I view meta-code tools as the future of programming.  someday we may write programs that write programs, instead of writing programs directly :)
06:44:24 <aavogt> that problem needs some awareness of what a name means in a given context (shadowing for example)
06:44:25 <ddarius> We do that all the time today.
06:44:29 <byorgey> uh, don't we already do that?
06:44:37 <dankna> aavogt: yes, absolutely, it will haev that knowledge
06:44:43 <dankna> well, yes, haha
06:44:51 <dankna> but I mean routinely and without the kludge of a textual generation pass
06:45:00 <dankna> we have parser generators, for example
06:45:02 <dankna> and planners
06:45:12 <mightybyte> Do the parameters to type families have to be types of kind *?
06:45:17 <byorgey> mightybyte: no
06:45:41 <mightybyte> byorgey: Hmmm, is there a special syntax to signify that?
06:45:45 <dankna> but would't it be great if you could say (not in English, but somehow) "I am changing this underlying assumption" and it then finds a list of candidate places where the assumption might be violated, and maybe even suggests transformations on them?
06:46:18 <byorgey> mightybyte: it's probably necessary to use kind annotations, like   type family Foo (a :: * -> *) (b :: *) :: *
06:46:54 <mightybyte> byorgey: Ahhhh, I didn't know about that syntax.  Let me try that.
06:48:41 <dankna> ddarius: anyway, the fact that there are few of them doesn't in any way evidence that people don't like them - it evidences that they haven't had the chance to find out, by and large
06:52:02 <mightybyte> byorgey: Hmmm, it looks like that fixed one problem.  But my underlying problem is still there--which is that I can't get this code that worked before with associated type families to work with nonassociated type families.
06:52:57 <byorgey> mightybyte: is it self-contained enough to paste?
06:53:10 <mightybyte> Not really
06:53:21 <byorgey> associated type families are really just syntax sugar for normal type families so in principle it ought to be possible.
06:53:28 <mightybyte> Is there any difference with the way associated families work?
06:53:39 <mightybyte> byorgey: Yeah, that's what I thought.
06:54:13 <mightybyte> The general idea is that I had multiple different type classes with this type family Base (m :: * -> *) :: *
06:54:57 <mightybyte> And in my application I always end up making my data type an instance of several of these type classes.
06:55:16 <ezyang> Does 'network' have an interface for building query strings?
06:55:41 <mightybyte> ...so instead of writing "type Base ..." the same way every time for each of the type classes, I wanted to just write it once.
06:55:51 <dankna> ezyang: I don't believe so - why would it?  it's lower-level than that, it has no knowledge of http.
06:56:02 <Saizan> mightybyte: you've to change the classes too
06:56:14 <ezyang> Yeah, thought so. Is there a usual package to use, in that case?
06:56:14 <mightybyte> Saizan: In what way?
06:56:24 <ezyang> I know I can hack up one very quickly, but would rather not write extra code.
06:56:38 <Saizan> mightybyte: removing the "type Base m" from their definition
06:57:04 <mightybyte> Saizan: Yeah, I did that.
06:57:49 <Saizan> ezyang: HTTP
06:58:57 <mightybyte> I'm getting the dreaded "rigid type variable" error.
06:59:52 <ezyang> huh, which module?
06:59:57 <ezyang> mightybyte: Paste?
07:00:17 <mightybyte> ezyang: It's too involved.
07:00:39 <dankna> @hackage HTTP
07:00:39 <lambdabot> http://hackage.haskell.org/package/HTTP
07:00:45 <dankna> (haven't used it myself)
07:00:57 <ezyang> dankna: I'm surfing through the module meself, but I don't really see something for building query strings.
07:01:12 <dankna> hm
07:02:26 <Saizan> it has a Request type
07:02:43 <Saizan> and some stuff to deal with Form's
07:03:27 <Saizan> not sure if there's an API to render requests or only to perform them
07:05:19 <ezyang> looks like I want urlEncodeVars.
07:06:08 <Saizan> mightybyte: you could paste the code that's throwing that error and the types of the functions involved
07:23:42 <ski> dankna : i've been wanting "ship your upgrade with a set of scripts that the downstream programmer could apply" for some time ..
07:24:26 <ski> this could also be applicable to upgrading configuration files to new versions of a program
07:29:35 <dankna> ski: yeah!  exactly!
07:30:28 <dankna> and thank you for the suggestion, I have added it to my clip file of ideas to mention in future self-promotion, haha
07:31:05 <ski> hehe
07:55:43 <aavogt> dankna: http://code.haskell.org/~aavogt/XMonadConfigUpdater/ doesn't know about name shadowing. But I think I remember it doing something
07:56:01 <dankna> hmm I see
07:56:43 <Saizan> preflex: seen Phyx-
07:56:43 <preflex>  Phyx- was last seen on #haskell 7 days, 22 hours, 6 minutes and 39 seconds ago, saying: well, better hop to it.. thanks Saizan
07:58:01 <aavogt> I guess the main idea is to 'compile' to functions which are applied via syb to the syntax tree (from haskell-src-exts)
07:58:17 * dankna nods
07:58:59 <mjk> does the Writer is using to do? or can anyone give a example for using Writer?
08:00:00 <Lemmih> mjk: What?
08:00:36 <aavogt> > execWriter (tell [5])
08:00:37 <lambdabot>   [5]
08:01:01 <Twey> > execWriter $ tell 5 >> tell 6
08:01:02 <lambdabot>   Ambiguous type variable `w' in the constraints:
08:01:02 <lambdabot>    `GHC.Num.Num w'
08:01:03 <lambdabot>      ari...
08:01:09 <mjk> Lemmih: i am learning Writer, but i can't understand it, so i need some examples using Writer(Control.Monad.Writer)
08:01:13 <Twey> > (execWriter $ tell 5 >> tell 6) :: [Int]
08:01:14 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
08:01:14 <lambdabot>    arising from the literal `...
08:01:20 <Twey> Hrmph
08:01:35 <hpc> > (execWriter $ tell [5] >> tell [6]) :: [Int]
08:01:35 <lambdabot>   [5,6]
08:01:54 <hpc> > (execWriter $ tell 5 >> tell 6) 7
08:01:55 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:01:55 <lambdabot>    `Data.Monoid.Monoid a'
08:01:55 <lambdabot>  ...
08:02:12 <hpc> > (execWriter $ tell 5 >> tell 6) 7 :: Int
08:02:12 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
08:02:13 <lambdabot>    arising from a use of...
08:02:18 <hpc> pah
08:03:31 <Twey> > getSum $ execWriter (tell (Sum 5) >> tell (Sum 6)) (Sum 7)
08:03:32 <lambdabot>   Couldn't match expected type `Data.Monoid.Sum t'
08:03:32 <lambdabot>         against inferred t...
08:03:37 <aavogt> > (execWriter $ tell (Endo 5) >> tell (Endo 6)) `appEndo` 7 :: Int
08:03:37 <lambdabot>   5
08:03:38 <Twey> x.x
08:03:50 <aavogt> hpc: looking for that Monoid instance?
08:04:46 <aavogt> > getSum (execWriter (tell (Sum 5) >> tell (Sum 6))) (Sum 7)
08:04:47 <lambdabot>   11
08:05:34 <hpc> > (execWriter $ tell (5 :: Int -> Int) >> tell 6) 7
08:05:35 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
08:05:35 <lambdabot>    arising from a use of...
08:05:49 <hpc> b-b-b-but...
08:05:55 <hpc> oh right, Endo
08:05:56 <hpc> :(
08:09:06 <aavogt> @ty ala
08:09:07 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
08:09:32 <hpc> :t ala foldmap
08:09:32 <lambdabot> Not in scope: `foldmap'
08:09:46 <hpc> :t \c -> ala c foldMap
08:09:47 <lambdabot> Not in scope: `foldMap'
08:10:10 <ski> @type ala Data.Foldable.foldMap
08:10:11 <lambdabot> forall a m (t :: * -> *) b n' o'. (Data.Foldable.Foldable t, Monoid m, Newtype (t a -> m) (a -> m), Newtype n' o') => (((a -> m) -> t a -> m) -> b -> n') -> b -> o'
08:10:12 * hpc waits until he is awake to try anything else lol
08:10:26 <ski> @type (`ala` Data.Foldable.foldMap)
08:10:26 <lambdabot> forall n (t :: * -> *) o'. (Newtype n o', Monoid n, Data.Foldable.Foldable t) => (o' -> n) -> t o' -> o'
08:11:35 <hpc> :t foldMap
08:11:36 <lambdabot> Not in scope: `foldMap'
08:11:47 <hpc> :t Data.Foldable.foldMap -- argh
08:11:48 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
08:12:30 <hpc> :t (`ala` id)
08:12:31 <lambdabot> forall n o'. (Newtype n o') => (o' -> n) -> o' -> o'
08:13:33 <aavogt> so it doesn't look like you could use ala (or similar) to choose the Monoid instance used inside the writer at the level of the runWriter?
08:13:52 <ski> @let fM = foldMap
08:13:52 <lambdabot>  <local>:3:5: Not in scope: `foldMap'
08:13:59 <ski> @let fm = Data.Foldable.foldMap
08:14:00 <lambdabot>  Defined.
08:20:09 <Saizan> ?type runWriter
08:20:10 <lambdabot> forall w a. Writer w a -> (a, w)
08:24:17 <aavogt> Saizan: you won't be able to type   (tell 5), even if you decide later on to convert the   Writer Int a  -> Writer (Sum Int) a
08:26:59 <rvn_> Hmm, is there any way of using dot dot notation to build a list like [1, 2, 4, 8..]?
08:27:21 <aavogt> > map (2^) [1.. ]
08:27:22 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
08:27:31 <rvn_> Ok, thank you aavogt
08:27:35 <ski> > iterate (2 ^) 1
08:27:36 <lambdabot>   [1,2,4,16,65536,20035299304068464649790723515602557504478254755697514192650...
08:27:43 <ski> > iterate (2 *) 1
08:27:43 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
08:28:20 <gds> > [2,4,6..]
08:28:21 <lambdabot>   <no location info>: parse error on input `..'
08:28:24 <gds> Huh.
08:28:27 <parcs> > iterate (`shiftL` 2) 1
08:28:27 <lambdabot>   Ambiguous type variable `a' in the constraint:
08:28:28 <lambdabot>    `Data.Bits.Bits a'
08:28:28 <lambdabot>      a...
08:28:36 <aavogt> @type enumFromThen
08:28:36 <parcs> that would be wrong anyway
08:28:37 <lambdabot> forall a. (Enum a) => a -> a -> [a]
08:28:42 <gds> > [2,4,6,..]
08:28:43 <lambdabot>   <no location info>: parse error on input `..'
08:28:47 <gds> Ah well.
08:28:56 <rvn_> > [2, 4..]
08:28:58 <parcs> > iterate (`shiftL` 1) 1 :: [Int]
08:29:00 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
08:29:04 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
08:29:28 <aavogt> gds: it isn't allowed, since that syntax is short hand for that function (or enumFrom, enumFromThenTo.. or some other combinations)
08:29:48 <aavogt> @oeis 2,4,6
08:29:55 <lambdabot>  d(n) (also called tau(n) or sigma_0(n)), the number of divisors of n.
08:29:55 <lambdabot>  [1,2,2,3,2,4,2,4,3,4,2,6,2,4,4,5,2,6,2,6,4,4,2,8,3,4,4,6,2,8,2,6,4,4,4,9,2,4...
08:30:23 <Nimatek> > 1:[2,4..]
08:30:24 <lambdabot>   [1,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
08:30:59 * gds nods
08:34:42 <parcs> does the 'default' keyword only apply to Nums?
08:34:50 <aavogt> yep
08:35:18 <aavogt> parcs: but you can make your type an instance even if it doesn't have a sensible implementation
08:35:44 <ddarius> I recommend ignoring the defaulting mechanism.
08:41:17 <companion_cube> is there a way to generate a static library with ghc ?
08:43:21 <dankna> yes
08:43:31 <dankna> -o foo.a, I believe (or use Cabal)
09:04:29 <tgeeky> @tell edwardk can you post the example of modular arithmetic in 'implicit configurations' using [reflection] to hpaste, and @tell me? thanks!
09:04:30 <lambdabot> Consider it noted.
09:20:39 * hackagebot air 2011.6.12 - air  http://hackage.haskell.org/package/air-2011.6.12 (JinjingWang)
09:25:01 <dankna> http://dankna.com/himitsu/split-bar-bidirectional.png
09:25:09 <dankna> so I went ahead and implemented horizontal splits as well
09:25:21 <dankna> following criticism from people here the other day that it's not reasonable to leave them out
09:25:52 <dankna> (they're red because I haven't decided what they should look like, or how thick they should be, yet)
09:27:23 <NemesisD> i've got what might be a silly question about haskell's sorting algorithm in sortBy. right now i've got a list of comparators ordered in descending sort precedence. example: i'm sorting people first by age then height then weight, where age is the highest precedence
09:28:00 <aavogt> NemesisD: the instance Monoid Ordering  can help
09:28:03 <dankna> is Ord an instance of Monoid?
09:28:07 <dankna> er Ordering, not Ord
09:28:09 <NemesisD> if instead i dropped the first comparator and just sorted by height and weight, then later sorted by age, would the previously established ordering still hold?
09:28:17 <NemesisD> oh i've already got that solved with mconcat
09:28:29 <dankna> ah - that's a general issue with sorting semantics, not really Haskell-specific, but,
09:28:31 <dankna> yes.
09:28:37 <dankna> as long as the sort is "stable"
09:28:44 <dankna> "stable" means that it preserves the existing ordering in the case of ties
09:29:01 <dankna> and yes, I believe Haskell's sort function is stable
09:29:13 <NemesisD> excellent!
09:29:23 <NemesisD> thanks
09:29:25 <dankna> np!
09:30:57 <NemesisD> yeah i thought i was all clever implementing sort with precedence. came in here and was told i could just alias that whole function to mconcat
09:44:03 <ski> > sortBy (comparing snd `mappend` comparing fst) [(0,0),(0,1),(1,0),(1,1)]  -- dankna,NemesisD
09:44:04 <lambdabot>   [(0,0),(1,0),(0,1),(1,1)]
09:46:08 <ski> see Cale's comment at <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx> for more on this
09:48:39 <ski> > sortBy (comparing length `mappend` comparing (map toLower)) (words "The quick brown fox jumps over the lazy dog")
09:48:40 <lambdabot>   ["dog","fox","The","the","lazy","over","brown","jumps","quick"]
09:50:11 <ClaudiusMaximus> hey, how to optional dependencies with cabal?  i'm thinking of an ugly combination of flags, ghc options, and {-# LANGUAGE CPP #-}, but is there a better way?
09:51:57 <ClaudiusMaximus> basically i optionally want hmpfr, which requires integer-simple, which requires manually editing ghc build config and recompiling...
09:52:09 <dankna> ClaudiusMaximus, flags are the preferred approach
09:52:34 <dankna> hmm, it requires integer-simple?  interesting, why does it do that?
09:52:58 <ClaudiusMaximus> dankna: mpfr requires gmp, integer-gmp does weird things
09:53:06 <ClaudiusMaximus> dankna: i'm not an expert
09:53:10 <dankna> hmm, okay
09:54:05 <dankna> ClaudiusMaximus, it may be relevant to you to realize that Cabal actually checks every possible combination of flags to find one that works (is buildable)
09:54:14 <dankna> rather than static defaulting behavior
09:54:33 <dankna> you can explicitly mark a configuration as unbuildable, also, by putting Buildable: False in it, inside a conditional
09:54:58 <dankna> not sure how this applies to your situation exactly, or whether it does, just making sure you're aware of the features so you can apply them if they turn out to be appropriate.
09:55:22 <ClaudiusMaximus> right, but if hmpfr is not installable (because ghc has integer-gmp), i need to disable the code that uses hmpfr - that's what i'm thinking of LANGUAGE CPP for
09:55:33 <Saizan> the ugly part is when depending on which flag you need to change your source, then it's cpp-options: -DFOO in that branch and CPP time in the code
09:55:54 <dankna> yeah, indeed
09:56:08 <Saizan> (in that branch of the if/then/else in the .cabal)
09:56:43 <olsner> integer-gmp breaks other gmp-using code? maybe it should make sure that you can link your stuff to another, working, gmp then
09:57:11 <Jafet> This bug is pretty old and tired.
09:57:50 <ClaudiusMaximus> so i'm on the right track with cabal flags and cpp, thanks
09:57:57 <dankna> np
10:05:23 * edwardk waves hello.
10:05:23 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
10:05:56 <edwardk> @tell tgeeky i haven't bothered to work through that one in full in quite a while
10:05:56 <lambdabot> Consider it noted.
10:07:12 <edwardk> preflex: xseen cale
10:07:13 <preflex>  cale was last seen on freenode/#haskell 16 hours, 32 minutes and 38 seconds ago, saying: (f . g) x = f (g x) = 3*(g x) + 1 = 3*(9*x) + 1
10:07:34 <edwardk> preflex: xseen roconnor
10:07:34 <preflex>  roconnor was last seen on freenode/#haskell 3 hours, 33 minutes and 20 seconds ago, saying: yes
10:07:40 <dolio> How's Canada?
10:07:52 <edwardk> very canadian
10:08:17 <edwardk> they have a much more streamlined system of vending machines than we do. $2 coins, $2 soft drinks. brilliant. ;)
10:08:40 <edwardk> otherwise, pretty waterfalls and interesting conversation
10:08:59 <dolio> Isn't that expensive? Or did the Canadian dollar go way back down?
10:09:28 <edwardk> its still high
10:09:36 <edwardk> said streamlined, not cheap ;)
10:09:42 <dankna> haha yeah
10:10:46 <dolio> Canadian dollars are apparently worth more than US dollars again.
10:11:07 <dolio> By around 2 cents.
10:11:07 <dankna> slightly
10:11:11 <dankna> yeah, I just checked
10:11:11 <edwardk> trying to see if roconnor and cale want to wander down to the workshop for some or all of it
10:11:48 <edwardk> can't think of any other canadian #haskellers near hamilton, but they are also welcome
10:12:44 * hackagebot hashtables 1.0.0.0 - Mutable hash tables in the ST monad  http://hackage.haskell.org/package/hashtables-1.0.0.0 (GregoryCollins)
10:19:57 <aavogt> edwardk: on which topics?
10:24:46 * hackagebot mecha 0.1.1 - A constructive solid geometry (CSG) modeling language.  http://hackage.haskell.org/package/mecha-0.1.1 (TomHawkins)
10:26:16 <edwardk> aavogt: designing and implmenting domain specific languages: shallow/deep emebeddings, free monads, codensity monads, observable sharing, etc.
10:27:09 <edwardk> aavogt: monday through wednesday here at mcmaster. the first day and a half will be most of the meat of it though
10:27:25 <edwardk> after that its going to be a bit more applied
10:29:54 <edwardk> aavogt: didn't realize you were up at waterloo
10:32:06 <aavogt> it doesn't seem like I could apply those things on my internship (right now)
10:32:41 <edwardk> ah, would need to convince your employer?
10:33:04 <edwardk> basically its a how-to for building domain specific languages or specification languages.
10:35:07 <edwardk> fair nuff
10:37:02 <aavogt> hmm, maybe there's an application of DSLs in defining some of the inputs for these simulations (crystal plasticity)
10:37:39 <olsner> aavogt: hmm, aren't dsl:s applicable for *everything*?
10:37:58 <edwardk> we'll be talking about automatic differention, a DSL for some numerical smoothing tricks, and a few others
10:40:42 <tgeeky> back
10:40:42 <lambdabot> tgeeky: You have 1 new message. '/msg lambdabot @messages' to read it.
10:42:32 <tgeeky> edwardk: thanks anyway. What kinds of uses have you seen for tagged/reflections other than marking sanitized or unsanitized? Does it make sense to try marking quantities with dimensions using it?
10:42:52 <edwardk> tgeeky: reflection lets you build dictionaries from stuff in the environment.
10:43:31 <edwardk> tgeeky: so if you wanted to build a monad up from a given function and a given unit, that you built up by capturing stuff, reflection lets you do that.
10:44:02 <aavogt> edwardk: Do you have a link for the schedule etc.?
10:44:04 <edwardk> this is important for things like when you want to make a monoid out of tabulating transitions of some particular state machine
10:45:05 <k0ral> what is the meaning of <$> and from which module does it come from ?
10:45:08 <edwardk> aavogt: honestly, i don't have the official announcement in hand, i should be able to forward it to you tomorrow. (chris anand didn't forward it to me)
10:45:21 <edwardk> koral: fmap , and its exported by Data.Functor or Control.Applicative
10:45:26 <edwardk> (well, both)
10:46:21 <k0ral> it's fmap ?
10:46:24 <aavogt> thanks
10:47:04 <edwardk> figure 9-5. the first day and a half is going to alternate between me and wren going through slides and whiteboard material and some hands on stuff for folks in the workshop. the latter half of the second day is actually motivating a real world problem, and the third day is looking to be more or less tackling it as a group.
10:47:33 <edwardk> we may restructure the session a bit, to avoid burnout on the first day, but thats the current gist
10:48:26 <edwardk> there'll be some not-so-haskell specific DSL content in the afternoon of the first day as well.
10:48:27 <Skola_> pretty random question: armrests when coding, yes/no?
10:48:37 <edwardk> skola: they mostly get in the way ;)
10:49:02 <aavogt> Skola_: is there are correlation with language there?
10:49:36 <Skola_> yeah aavogt good question
10:50:19 <tgeeky> edwardk: could you see reflection being useful for: encoding the background ANSI colors into an Empty placeholder (or into a single Char)? That is, a placeholder which will have a background color when you put a character in it?
10:50:45 <edwardk> not sure i am parsing what you mean
10:52:01 <tgeeky> well, I'm imagining in a prettyp library, putting the "background color" attribute on the nullary constructor for the text type.
10:52:07 <tgeeky> http://hackage.haskell.org/packages/archive/mpppc/0.1.2/doc/html/Text-PrettyPrint-MPPPC-OneDim.html
10:52:14 <tgeeky> like in data Pretty s t
10:52:45 <tgeeky> so that the Color (one of the constructors) doesn't have a ConsoleLayer attribute
10:52:53 <tgeeky> but either there's color on the Empty
10:52:55 <tgeeky> (which is background)
10:53:06 <tgeeky> or there's color on the Printable s t, which are foreground
10:53:41 <edwardk> well, you can make something like
10:53:58 * ski wonders what "reflection" means in this context
10:54:05 <edwardk> ski: the reflection package on hackage
10:54:07 <tgeeky> ski: [reflection] package
10:54:14 <tgeeky> edwardk: the point of this is strange
10:54:17 <ski> @hackage reflection
10:54:18 <lambdabot> http://hackage.haskell.org/package/reflection
10:54:22 <edwardk> lifts terms into types
10:54:32 <tgeeky> the point of this is to have a ternary empty
10:54:41 <tgeeky> so that you could specify the background color for enclosures
10:54:42 <tgeeky> like
10:55:01 <edwardk> well, background colors tend to draw from a known set. so the example is less compelling
10:55:01 <tgeeky> (red)< (blue)...(/blue)(red)>
10:55:24 <edwardk> if you had something more 'open', like functions, etc. then reflection becomes more useful
10:55:44 <mightybyte> http://www.reddit.com/r/haskell/comments/hx9nv/haskell_gets_a_new_superfast_hash_table_library/
10:56:05 <c_wraith> But do we have a superfast jellyfish?
10:56:25 <mightybyte> Jellyfish are inherently slow
10:56:39 <ski> edwardk : when is this useful ?
10:56:43 <tgeeky> edwardk: one more question about applicability (I clearly don't quite understand what's going on here)
10:57:02 <tgeeky> edwardk: are you familar with the regular ADT boltzmann testing method?
10:57:17 <tgeeky> by Canou et al
10:57:22 <edwardk> ski: build some particular regular expression as a term. take that term, and reify it as a type, then you can make a monoid out of tabulating it.
10:57:34 <edwardk> but without the ability to reify it as a type, you can't make a Monoid instance for that
10:57:55 <edwardk> i use that particular monoid a lot
10:58:15 <tgeeky> reflection, you mean?
10:58:22 <ski> "tabulating" means ?
10:58:44 <ski> repeatedly parsing from a string using the regex, yielding a list of results ?
10:58:56 <edwardk> consider a state machine with 3 nodes, and edges labeled with Chars.
11:00:20 <edwardk> the 'empty tabulation is an array of 3 entries, 1 -> 1, 2 -> 2, 3 -> 3.         the tabulation for 'a' would be the nodes you go to given an 'a' as an input. 1 -> 2, 2 -> 2, 3 -> 3, for instance, if the edge from 1 -> 2 had an 'a' on it, and the others had loops to themselves labeled with 'a'.
11:00:53 <edwardk> you can compose these, to get the 'effect' of following a series of labels from a given source.
11:01:04 <ski> *nod*
11:01:23 <edwardk> now, if you use this on a traditional automaton, you can use it to make a monoid out of recognizing a regular expression.
11:01:35 <ski> (is this a deterministic automaton ?)
11:01:55 <edwardk> tabulating the state you'll end in from all given starting states
11:02:07 <edwardk> yes, you can do the same thing for non-deterministic, its just more work
11:02:54 <ski> so composition in the monoid corresponds to sequential composition of two regexen ?
11:03:10 <edwardk> then when you're done applying the monoid to your input string (however you chunked it up), you can just check the content of the tabulation of the start node, so see if you landed in a node that is flagged to accept. with that you can recognize regular expressions monoidally.
11:03:12 <edwardk> no
11:03:56 <edwardk> the monoid represents recognizing input _in_ a regex
11:04:31 <edwardk> the monoid is given by the regex, the members of it are tabulations of what the 'effect' on given states given a sequence of inputs.
11:04:41 <edwardk> no input corresponds to all states mapping to themselves.
11:05:06 <ski> mhm
11:05:07 <edwardk> an 'a' corresponds to chasing all of the 'a' edges, one step.
11:05:23 <edwardk> you can compose tabulations monoidally
11:05:26 <ski> ok, i think i get the type picture, roughly
11:05:35 <tgeeky> edwardk: last question re: this reflection (or probably more likely tagged) - would it be useful for this (a size-invariant quickcheck Gen generator for ADTs)
11:05:38 <tgeeky> http://genal.algo-prog.info/?p=syb_qc;a=tree;f=src;h=e74814dd95429bfb6a77bed07b0630ae75e6dc36;hb=public
11:05:39 <edwardk> but notice that it is a monoid that is predicated on the choice of some particular regex.
11:06:00 <edwardk> probably tagged
11:06:02 <chrisdone> mightybyte: Hey, nice work! Seriously sweet improvements. Interesting insights in Haskell optimization.
11:07:10 <tgeeky> edwardk: do you have recommendations for the order of learning/understanding the category-theory stuff that you've put into hackage?
11:07:10 <ski> so you (effectively) generate an existential, given a regex
11:07:22 <edwardk> tgeeky: start with semigroups, then semigroupoids
11:07:52 <edwardk> ski: reify :: a -> (forall s. Reifies s a => Tagged s w) -> w
11:08:03 <edwardk> then you can use reflect :: Reifies s a => Tagged s a
11:08:12 <edwardk> reify 2 reflect = 2
11:08:13 <ski> and `Tagged s w ~= w' ?
11:08:21 <edwardk> newtype Tagged s a = Tagged a
11:08:24 <ski> yes
11:08:43 <edwardk> reify 2 ((+) <$> reflect <*> reflect) = 4
11:08:49 <edwardk> but you can reify _any_ type a.
11:08:57 <tgeeky> edwardk: [request for papers/links], last q for today ;)
11:08:59 <edwardk> by dirty hackery
11:09:03 <chrisdone> mightybyte: Ah, btw, did you finish that web-routes stuf mentioned here? http://www.haskell.org/pipermail/web-devel/2010/000337.html
11:09:06 <Saizan> (so it's the State -> State monoid where each element is created by partially applying the transition function of the regex to some input?)
11:09:08 <edwardk> tgeeky: i've yet to write any. ;)
11:09:13 <tgeeky> edwardk: I mean others :o
11:09:21 <edwardk> saizan: exactly
11:09:25 <ski> edwardk : s/type/mono-type/, i assume ..
11:09:42 <tgeeky> edwardk: damn it. I hate when someone says that
11:09:43 <edwardk> ski: well, any term can be reified into a type this way.
11:09:54 <tgeeky> ski: the paper that it's based on is really interesting
11:09:59 <edwardk> tgeeky: there isn't much out there on semigroupoids
11:10:01 <tgeeky> I found the modular arithmetic example compelling
11:10:13 <edwardk> ski: the hack is quite simple
11:10:32 <tgeeky> ski: the code is pretty readable, even though it is doing things I don't understand :o
11:10:37 <edwardk> ski: you are comfortable with the fact that you can make a type for natural numbers and a typeclass for it that lets you make a toInt method for it right?
11:11:03 <ski> tgeeky : sorry, which paper that what is based on ?
11:11:06 <edwardk> so i could use reifyNat :: Int -> (forall s. ReifiesNat n => Tagged s w) -> w
11:11:19 <tgeeky> ski: it's listed in the docs of reflection... one of Oleg's papers
11:11:39 <edwardk> and make a reflectNat just by providing a couple of types, Z and S (or something more efficient)
11:11:43 <edwardk> so far so good?
11:11:58 <ski> edwardk : i probably haven't seen how to do that `toInt' .. but i can imagine one can do it (and i possibly could do it, if i tried)
11:12:24 <edwardk> data Z; instance RefiesInt Z where toInt = Tagged 0
11:12:37 <edwardk> data S n; instance ReifiesInt n => ReifiesInt (S n) where ...
11:12:47 <tgeeky> once you have the Nats in the type system, you use the reflect Nats (or Integers) as type-checked unsafe things
11:12:57 <edwardk> so far so good?
11:13:00 <ski> edwardk : so, operationally, `reifyNat' constructs a dictionary, with the same shape as the natural ..
11:13:04 <edwardk> yep
11:13:20 <edwardk> effectively it builds a dictionary with one slot in it, that holds a Tagged Int
11:13:35 <edwardk> and the tag is just newtype noise
11:13:46 <edwardk> so reflect is just reading that Int
11:13:48 <ski> *nod*
11:14:05 <edwardk> ok, next, i can do the same thing for lists of things I can reify
11:14:18 <edwardk> so now instead of just reifying ints, i can reify lists of ints, right?
11:14:19 <ski> so it acts a little bit like `Reader', in that it's referring to an enviroment
11:14:23 <edwardk> yep
11:14:35 <edwardk> but since the environment is a dictionary i can do things with it i can't do with reader
11:15:01 <tgeeky> edwardk: interjection: environment == scope of a function, dictionary = type lookup table?
11:15:22 <edwardk> tgeeky: dictionary = the structure passed around in the back end when you ask for Num Foo
11:15:39 <edwardk> it has a slot for (+), (-), (*), etc.
11:15:49 <tgeeky> ok
11:16:29 <edwardk> so, with the ability to reify a list of ints.. i can then reify anything i can turn INTO a list of ints, right?
11:16:37 <edwardk> (as long as i can get it back out)
11:16:42 <tgeeky> yes, and you can turn anything representable in binary into a list of ints
11:16:52 <edwardk> So we can reify anything Storable.
11:16:54 <tgeeky> including references
11:16:57 <ski> tgeeky : `environment' can be the things which are in scope. i meant it more generally as the "read-only state" that e.g. `Reader r' provides
11:17:10 <edwardk> And StablePtrs are storable
11:17:31 <tgeeky> it seems like you could use this to construct a number sieve
11:17:38 <tgeeky> by storing binary sieve words
11:17:57 * tgeeky shrugs... I always find myself lacking motivating examples
11:18:05 <edwardk> so i can take your term of type a. grab a StablePtr to it, store it, convert that to a list of type level ints, and build up a dictionary that takes that and undoes it, so the dictioary consists of a single tagged 'a'
11:18:44 <tgeeky> edwardk: what is the upside of that, other than getting the type system to check some things for you? optimization? clarifying unsafe ops?
11:18:49 <edwardk> but i can do a bit better, to avoid leaking the StablePtr, I can force that result, so the dictionary has one slot which is already evaluated to be the 'a' you gave, so i can then free the stablePtr.
11:19:00 <edwardk> tgeeky: you can write code you can't write without it
11:19:14 <tgeeky> edwardk: code that is starting down the path of dependent types?
11:19:18 <edwardk> yes
11:19:32 <tgeeky> it seems like even though it's messy, you can get pretty far?
11:19:37 <edwardk> you can only use them in 'nested contexts' because of the universal quantifier
11:19:47 <edwardk> but its basically a 'stack-disciplined' dependent type
11:20:02 <ski> (fun, BSOD)
11:20:11 <edwardk> what'd you miss? =)
11:20:52 <ski> well, only the box i sat at spontaneously rebooted, not my machine with the important stuff (like irc :)
11:21:25 <edwardk> ah
11:21:33 <ski> edwardk : can you reify lists of `a', provided you can reify `a', for any `a' ?
11:21:39 <tgeeky> edwardk: so an different wording from earlier re: background colors - if one were to specify a function for a large range of colors (say, the standard (r,g,b) specification), and then reify arbitrary color down into the much smaller set that ANSI allows (8 colors, 2 shades) without loss of generality?
11:21:40 <edwardk> yes
11:21:41 <ski> or is it monomorphic ?
11:22:01 <edwardk> the code i have implemented is monomorphic, but the idea works polymorphically
11:22:08 <ski> i see `ReifiesNums' but not `ReifiesList'
11:22:10 <ski> ok
11:22:31 <edwardk> there is no point in using ReifiesList basically, since its subsumed by the more general Reifies later.
11:22:35 <edwardk> so i implement the special case i need
11:23:17 <tgeeky> oh how long of a path I have ahead me *cringes*
11:25:11 <edwardk> anyways, its a horrible but useful hack
11:25:28 <edwardk> the stack discipline lets you think of it like staged computation
11:26:40 <ski> (tgeeky : you're relatively new to Haskell ?)
11:27:01 <tgeeky> ski: yes, and I have incredibly foolhardy ambition re: what I want to do with it
11:27:42 <edwardk> anyways the code there is basically the idea from oleg and ken shan's paper updated to work with more modern haskell compilers. theirs broke when they changed scope type variables, and then it broke again when they changed the inliner during the introduction of system Fc.
11:27:58 <edwardk> i've tried to keep it superficially the same anyways
11:28:06 <edwardk> modulo some renaming
11:28:08 <ski> it's the same interface ?
11:28:21 <tgeeky> yeah, it looks the same as it does in the paper
11:28:25 <tgeeky> rather, works the same
11:28:27 <tgeeky> it looks better
11:28:37 <edwardk> yeah, its been streamlined a bit
11:29:00 <ski> which paper is this ?
11:29:01 <tgeeky> i think I counted the number of times he said : don't be alarmed by (undefined :: s) expressions
11:29:01 <edwardk> the names for the typeclasses were changed to ReifiesFoo rather than ReflectFoo
11:29:02 <ski> whence ?
11:29:14 <edwardk> and i replaced all the undefined expressions with the use of Tagged
11:29:19 <tgeeky> http://hackage.haskell.org/packages/archive/reflection/0.3.5/doc/html/Data-Reflection.html
11:29:22 <tgeeky> the one listed at the top there
11:29:47 <ski> oh, i missed that
11:30:31 <edwardk> mainly because the typeclass indicates that s `Reifies` a  when read this way, otherwise its a nonsensical name
11:30:48 <ski> edwardk : i did wonder why class `ReifiesFoo' had an operation `reflectFoo'
11:30:53 * Saizan wonders if it'd be hard to implement this directly within ghc
11:31:04 <edwardk> ski: well, s reifies a, so we can reflect s to get an a.
11:31:36 <ski> hm, i suppose it makes sense, now that i think more on it
11:32:01 <tgeeky> i was thinking it was because
11:32:10 <tgeeky> you're installing a mirror at the undefined (bottom)
11:32:15 <tgeeky> which will give you back a value of type a
11:32:16 <ski> `ReifiesNat s' means that `s' is a type-level representation of a single `Nat'
11:32:34 <tgeeky> when you hit bottom :o
11:32:57 * ski doesn't see how bottoms enter the picture
11:33:02 <edwardk> reify takes an a, and yields a type s, that reifies a. you can reflect s to get the a.
11:33:02 <tgeeky> the original paper
11:33:11 <edwardk> http://stackoverflow.com/questions/5314884/what-reify-and-reification-means-in-the-context-of-functional-programming/5316014#5316014 might better describe the relationship
11:33:21 <edwardk> between the concrete and abstract domains involved
11:35:34 <ski> "More formally if you view reflection as a forgetful functor that takes you from a concrete domain to an abstract domain, then reification is, ideally, left adjoint to reflection." :)
11:35:59 <edwardk> i had to throw something in there ;)
11:36:19 <tgeeky> usually we can't access the dictionary for a class, in haskell, is this right?
11:36:24 <tgeeky> inspect it
11:36:36 <byorgey> right, not explicitly
11:36:44 <edwardk> tgeeky: you can inspect it easy. juse use the method or whatever thats in the dictionary ;)
11:36:46 <ski> hm, i haven't thought of forgetful functors as taking me from concrete to abstract .. i suppose it makes sense, though
11:36:49 <edwardk> _building_ one by hand is hard
11:37:50 <ski> sometimes i want to declare locally scoped types with `data' or `newtype' inside `let' or `where', possibly also giving instance declarations for them
11:38:12 <hpaste> TravisD pasted “Segfault” at http://hpaste.org/47688
11:38:48 <TravisD> Woah, I didn't expect the bot to do that for me! Does anyone know what might cause that segfault in ghci?
11:39:07 <edwardk> ski: of course the danger of local instances that close over some of the environment is that you may lose confluence of instance resolution. the stack discipline enforced by the quantifier in reflection keeps that from happening.
11:39:16 <ski> TravisD : thank chrisdone for that, who is probably hacking on this feature right now !
11:39:44 <TravisD> ski: It was surprising :)
11:40:18 <ski> (it's not unheard of. `lisppaste' does it too)
11:40:47 <ski> edwardk : what do you mean by "close over some of the environment" ?
11:41:20 <edwardk> foo x = … where instance Bar Baz where mempty = x
11:41:38 <edwardk> x is in the environment where the 'local' instance declaration is made
11:41:38 <ski> edwardk : i know we would need at least restrictions for MPTCs with FDs (and presumably for ATs, similarly), in conjunction with locally scoped instance
11:41:57 <edwardk> nah local instances blow away confluence of instance resolution
11:42:18 <edwardk> this is why they are 'infectious'
11:42:26 <ski> well, i'm talking about here only instances of types which are also locally declared in the same scope
11:42:31 <edwardk> you can't exclude instances from imports for the same reason
11:42:41 <edwardk> that would probably work
11:42:42 <ski> s/of/for/
11:42:52 <edwardk> that gives you the same stack discipline i give you with reflection
11:43:35 <ski> the point is that the local scope hides the instance, so we want to make sure there can't be two different instances of the same type
11:43:39 <edwardk> but it would complicate implementation i think
11:44:01 <ski> i'm not sure
11:44:23 <edwardk> because right now i can rely on the fact that all of the instances are known things, and so i can build up the instance _from nothing_ at each location where its used. the local one might not be available properly because it may need to capture part of the environment. not sure i see how it would get implemented.
11:44:28 <ski> well, you would need to construct some dictionaries at run-time, of course
11:44:40 <edwardk> sure. just need to make sure it gets every place its needed
11:44:41 <ski> but you need to do that with your `ReifiesFoo' too, i think
11:44:55 <edwardk> true
11:45:01 <edwardk> it should work
11:45:07 <edwardk> good look getting that one in ghc ;)
11:45:11 <edwardk> er good luck
11:45:32 <ski> what is probably harder is specifying some nice rules for the type system, to approximate the safe cases
11:46:59 <ski> i'm not sure what you mean by "i can build up the instance _from nothing_ at each location where its used"
11:47:30 <edwardk> i'll be back in a bit
11:47:35 <ski> np
11:48:10 <edwardk> (housekeeping here at the hotel, relocating to a cafe)
11:50:30 <byorgey> TravisD: what OS and what version of ghci?
11:50:50 <byorgey> that segfault is very surprising
11:51:14 <TravisD> byorgey: Mac OS, ghc version 6.10.4 installed via macports
11:51:43 <byorgey> hmm, I don't know much about ghc on Mac OS
11:51:49 <byorgey> but 6.10.4 is rather old
11:51:49 <TravisD> byorgey: I should also say that it works fine as long as there are no negative numbres
11:51:59 <TravisD> Ah, silly macports
11:52:08 <TravisD> are there prepackaged binaries?
11:52:14 <luite> oh macs don't support negative numbers ;)
11:52:20 <byorgey> haha
11:52:22 <TravisD> luite:  :P
11:52:36 <c_wraith> yes, the macports ghc install is broken
11:52:40 <TravisD> expressions like 1 − 2 result in −1 and no segfault
11:52:41 <c_wraith> solution: don't use macports
11:52:47 <cmccann> yes, steve jobs feels the user experience is improved by being more positive
11:52:52 <byorgey> TravisD: try http://hackage.haskell.org/platform/mac.html
11:53:16 <TravisD> c_wraith: That's irritating. Macports could be nice
11:53:21 <TravisD> byorgey: thanks
11:53:41 <c_wraith> you don't have to give up macports for other stuff, just ghc
11:54:02 * cmccann seems to recall hearing more than once about problems involving macports and haskell stuff
11:54:45 <cmccann> on the other hand I can't install the most recent haskell platform on my macbook either :[
11:54:56 <TravisD> Its irritating. haskell-mode.el depends on ghc (for some reason), so to uninstall the macports ghc I have to remove the macports haskell-mode.el!
11:55:07 <TravisD> It's
11:57:18 <TravisD> Anyways, thanks :) I was worried that I was making a terrible mistake
12:01:43 <termcap> TravisD: have you tried via homebrew? I just installed today and I have version 6.12.3
12:02:22 <TravisD> termcap: Is homebrew another package management system?
12:02:30 <termcap> TravisD: yes,  https://github.com/mxcl/homebrew
12:02:45 <termcap> infinitely better than macports
12:02:58 <TravisD> termcap: You might be my favourite person right now.
12:03:11 <TravisD> Does it compile from source or just distribute binaries?
12:03:13 <olsner> I don't quite get how it's different from macports, except being written in ruby instead of tcl and managed through git on github
12:03:56 <TravisD> olsner: If it is better maintained then that would be a big difference
12:04:28 <bytbox> TravisD: it does seem to be somewhat better maintained (at least, I have broken compile / config / dependency problems much less frequently than with m.p.)
12:05:15 <bytbox> TravisD: on the other hand, it also seems to have fewer available packages. (They don't bother to package individual haskell pacakages or python packages - they just tell you to use cabal/pip, and so on.)
12:05:28 <TravisD> ah
12:05:57 <TravisD> Lacking a good package manager is a serious reason to avoid MacOS for me :(
12:06:13 <frerich> olsner: Unlike Macports, Homebrew attempts to re-use the system-installed software (e.g. Perl) as much as possible.
12:07:54 <TravisD> frerich: Even when that software is outdated?
12:08:13 <olsner> I do wonder why and how starting over with homebrew was better than e.g. forking macports
12:08:16 <bytbox> TravisD: You can specifically tell homebrew to use a newer version
12:08:30 <mightybyte> chrisdone: I actually didn't do that hashtable.  That was gcollins.
12:09:13 <chrisdone> mightybyte: Ah, I thought you were gcollins.（　´_ゝ`）
12:09:40 <mightybyte> chrisdone: Nobody has done the web-routes thing for Snap yet.  Shouldn't be too hard though.
12:12:06 <TravisD> would it be wise to completely uninstall macports?
12:12:15 <bytbox> TravisD: yes
12:12:26 <TravisD> This is exciting!
12:12:44 <bytbox> TravisD: but first, just rename the macports directory to get it out of the way - to make sure it doesn't break anything major. (Didn't for me, but ya never know...)
12:13:11 <TravisD> bytbox: It's the weekend :) I'll live on the edge, a bit
12:13:27 <bytbox> TravisD: haha. Have fun then.
12:14:15 <TravisD> bytbox: Thanks
12:41:09 * hackagebot aeson-pretty 0.1 - JSON pretty-printing library and command-line tool.  http://hackage.haskell.org/package/aeson-pretty-0.1 (FalkoPeters)
12:44:10 * hackagebot zmqat 0.1.0 - A socat-like tool for zeromq socket library  http://hackage.haskell.org/package/zmqat-0.1.0 (koral)
12:44:10 <k0ral> zmqat is born :)
12:45:43 <byorgey> k0ral: congrats =)
12:45:55 <k0ral> thank you :)
12:47:16 <cmccann> byorgey, how's the new typeclassopedia stuff going? :]
12:47:44 <byorgey> cmccann: well, to be honest, I haven't touched it in several weeks =)
12:47:59 <cmccann> haha, fair enough
12:48:10 <byorgey> the current plan is to get out the Monad.Reader issue which is almost done
12:48:20 <byorgey> then I'm going to Oregon for a week
12:48:42 <byorgey> then after that I will put some work into getting the Typeclassopedia up as a per-paragraph-commentable web document
12:49:00 <byorgey> to make it easy for people to contribute while I update it
12:49:08 <cmccann> sounds like a good plan
12:49:39 <byorgey> so if you don't hear anything about it by the end of June feel free to bug me about it again =)
12:49:46 <cmccann> haha
12:49:54 <cmccann> I was mostly wondering what sort of contributions you needed, actually
12:50:28 <byorgey> ah, good question
12:50:35 <cmccann> I've been thinking about organizing some of the stuff I've written and it wondered if any of it would be useful to you
12:50:50 <cmccann> cleaned up and edited substantially but still
12:50:56 <byorgey> right, cool
12:51:29 <byorgey> well, at the macro level I need some better material about arrows, comonads, and monadfix
12:51:42 <byorgey> at the micro level I'd like to add a bunch more exercises
12:52:16 <byorgey> but that's not an exhaustive list, I'm sure there are things which would improve it a lot that I haven't even thougt of
12:52:25 <byorgey> what sort of stuff have you written?
12:52:57 <djahandarie> byorgey, you're only in Oregon for a week?
12:53:08 <cmccann> byorgey, as a concrete example something like this: http://stackoverflow.com/questions/3686133/#3687063
12:53:24 <cmccann> byorgey, that being something in the general area of "talking about the Arrow type class"
12:53:25 <byorgey> djahandarie: yeah, can't leave my pregnant wife here by herself for too long =)
12:53:44 <djahandarie> Ah, hehe, that's a good enough reason. :)
12:54:18 <byorgey> cmccann: cool, yeah, that sort of thing would be great
12:54:29 <cmccann> byorgey, obviously a very different format from what you'd need but a lot of material could be reworked maybe?
12:54:38 <byorgey> cmccann: yes, definitely
12:55:29 <cmccann> byorgey, this is also relevant and seemed to be the most popular thing I've done, but is on material you probably already have covered well: http://stackoverflow.com/questions/3242361/#3242853
12:57:33 <byorgey> cmccann: yes, a lot of that I already cover, but even so I think there are interesting tidbits in there that could be included
12:58:33 <ezyang> Ooh, interesting email to haskell-cafe. I wonder if we have a toy STG lying around. Shouldn't be too hard to implement...
12:59:31 <cmccann> byorgey, anyway the SO stuff is all under a CC license so technically you don't need my input to use it :] but figured I'd offer explicitly since I've been thinking about organizing it for my own purposes anyhow
13:00:33 <byorgey> cmccann: yes, thanks!
13:00:49 <byorgey> I wouldn't have even known about it, I don't really go on SO much
13:01:03 <cmccann> byorgey, yeah, that's kind of why I brought it up
13:01:14 <cmccann> other people have some great info there too
13:01:41 <cmccann> obviously most of it isn't really on-target for the typeclassopedia but a fair amount might be
13:03:07 <ezyang> Is there a name for the function \x -> [x]?
13:03:31 <dankna> hm
13:03:38 <dankna> @hoogle a -> [a]
13:03:38 <lambdabot> Prelude repeat :: a -> [a]
13:03:38 <lambdabot> Data.List repeat :: a -> [a]
13:03:39 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
13:03:43 <dankna> no :)
13:03:43 <ben> singleton?
13:03:44 <djahandarie> Not just for list, afaik.
13:03:52 <ben> @hoogle singleton
13:03:52 <lambdabot> Data.ByteString singleton :: Word8 -> ByteString
13:03:52 <dankna> @hoogle singleton
13:03:53 <lambdabot> Data.IntMap singleton :: Key -> a -> IntMap a
13:03:53 <lambdabot> Data.IntSet singleton :: Int -> IntSet
13:03:53 <lambdabot> Data.ByteString singleton :: Word8 -> ByteString
13:03:53 <lambdabot> Data.IntMap singleton :: Key -> a -> IntMap a
13:03:53 <ben> hm :<
13:03:54 <lambdabot> Data.IntSet singleton :: Int -> IntSet
13:03:57 <ezyang> Yeah, it's called singleton for most container types, but doesn't seem to be one for [a]
13:04:15 <cmccann> yeah, singleton is the standard name for equivalent functions on other container types
13:04:32 <ben> Probably because [x] is shorter than singleton x
13:04:37 <cmccann> if you're going to pick a name, that'd be a reasonable choice
13:04:47 <byorgey> it is named (:[])
13:04:52 <djahandarie> Monkey face? (:[])
13:04:52 <byorgey> the robot monkey operator
13:04:52 <cmccann> obviously there's also "pure" and "return" :]
13:05:04 <cmccann> but that's not what you're after
13:05:49 <ezyang> I wanted it for function composition, but it's OK, I found a better way :-)
13:05:55 <ezyang> maybeToList (fmap Description text)
13:06:46 <dankna> > ([]) 4
13:06:47 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
13:06:51 <dankna> > ([]) (4 :: Int)
13:06:51 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
13:06:55 <dankna> > (:[]) (4 :: Int)
13:06:56 <lambdabot>   [4]
13:07:29 <ezyang> How do I turn something like 2011-06-11T14:47:42Z into a CalendarTime?
13:07:29 <cmccann> dankna, don't confuse ([] :: [a]) with ([] :: * -> *)
13:07:34 <parcs> :t return :: a -> [a]
13:07:35 <lambdabot> forall a. a -> [a]
13:07:42 <ezyang> hehe, hehehe
13:07:49 <ezyang> yeah, return does the trick :-)
13:07:57 <dankna> ah, indeed
13:08:26 <dankna> > ([] :: a -> [a]) 4
13:08:27 <lambdabot>   Couldn't match expected type `a -> [a]'
13:08:27 <lambdabot>         against inferred type `[a1]'
13:08:32 <dankna> right, okay
13:08:36 <cmccann> :k []
13:08:37 <lambdabot> * -> *
13:08:39 <cmccann> :t []
13:08:40 <lambdabot> forall a. [a]
13:08:55 <cmccann> the two being completely different things, obviously
13:09:47 <cmccann> the special syntax for lists is one of those things that's actually kinda confusing in actual meaning for the sake of readability and doing what people usually mean in practice
13:12:36 <ezyang> Why do Haskell's date libraries suck so much :-(
13:14:05 <cmccann> why do date libraries suck so much in every language?
13:14:33 <dankna> I actually find the recent version of the "time" package pretty good.
13:14:34 <cmccann> the answer is that dates as a concept suck, they make no sense and are full of weird corner cases
13:14:35 <mjrosenb> cmccann: because you're getting into nlp land
13:15:12 <mjrosenb> like "i want a library that will extract the meaning of this wikipedia page", "why does this library suck so much?", etc.
13:15:49 <cmccann> dates are actually very difficult to get right, up there with other extremely tricky topics such as correctly handling Unicode or floating point arithmetic
13:16:06 <dankna> this is ture
13:16:12 <dankna> but I wouldn't go so far as to call them NLP
13:16:15 <dankna> *true
13:16:19 <cmccann> programming is a lot easier if you avoid working with dates/times, text, or numbers
13:16:34 <cmccann> I say stick to category theory, it's simpler
13:16:51 <TravisD> cmccann: Lol
13:16:54 <dankna> hahahaa
13:16:56 <dankna> nice trick that
13:17:02 <byorgey> ezyang: is there a specific reason you need to be using old-time instead of time?
13:17:12 <ezyang> I'm trying to use the 'rss' library, but it's using old-time.
13:17:18 <dankna> so uh
13:17:21 <ezyang> I'm complaining to the maintainer, and I think I'm gonna switch to 'feed' instead.
13:17:25 <dankna> yeah
13:17:29 <dankna> that was about to be my suggestion
13:17:30 <byorgey> ok.
13:17:46 <dankna> I also like how we have "old-locale" but no "locale"
13:18:26 <frerich> I'm trying to write a little game which involves players picking "chips" (which are initially covered). A small (simplified) code example is at http://hpaste.org/47690 - the problem I'm having is that the function which applies a Turn to a Game (and then returns a new Game) becomes really ugly, since updating the list of Players which belong to a came is very cumbersome. Does anybody know how to write the function commented with 'XXX
13:18:26 <frerich> Implement me' nicely, without using some other type than lists?
13:19:08 <ezyang> what are chips?
13:19:15 <ezyang> Can you change the types of your data types?
13:19:18 <frerich> ezyang: Just numbers, ints in my case.
13:20:03 <ezyang> Yeah, I suspect you may want to rethink your representation.
13:20:10 <frerich> ezyang: In principle, yes - I could use an array or something else. I'm just wondering whether there is anice way to update the [Player] field of the Game value so that the player with the given name has its "chips" field updated. I suspect a combination of list comprehensions and record syntax could work.
13:20:14 <ezyang> Are there arbitrary many players?
13:20:20 <frerich> Yes
13:20:30 <ezyang> frerich: You could probably use semantic editor combinators
13:20:51 <ezyang> though I'm not really how the "search for and update" bit would work.
13:20:56 <ion> @remember cmccann programming is a lot easier if you avoid working with dates/times, text, or numbers. I say stick to category theory, it's simpler
13:20:57 <lambdabot> I will remember.
13:21:06 <cmccann> :]
13:21:26 <hpaste> chrisdone pasted “Feed package doesn't let me get item content” at http://hpaste.org/47691
13:21:36 <ezyang> But that's exactly the sort of "I want to reach into the inside of this data structure and update this"
13:21:55 <frerich> Maybe something like [if name x == n then <new_player_value> else x | x <- players g] and the '<new_player_value>' part would use the update record syntax.
13:21:56 <ezyang> of course, it will be kind of inefficient.
13:22:01 * frerich is not sure that's even valid Haskell...
13:22:22 <frerich> hmm.
13:22:34 <byorgey> you could easily make a nice SEC for "search and update in a list"
13:22:53 <chrisdone> ezyang: If you switch to feed and figure out why I can't access the content from that item, let me know. :-)
13:22:55 <frerich> That's the first time I read the term "semantic editor combinator", let me read up a bit on that :-)
13:23:17 * hackagebot http-enumerator 0.6.5.3 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.6.5.3 (MichaelSnoyman)
13:23:22 <ezyang> chrisdone: h'ok
13:23:25 <byorgey> frerich: look on Conal Elliott's blog, I think it's the first google hit
13:23:29 <ezyang> though I'm not reading feeds, I'm just producing feeds.
13:23:33 <vitka> You can use IntSet for chips field.
13:24:15 <frerich> vitka: Well yeah I could use a different data structure. I was just curious whether there's an elegant way to do this "manipulate this single field hidden deeply in this list of values" job with plain lists.
13:24:36 <byorgey> @type let mapOnly p f = map (\x -> if p x then f x else x) in mapOnly
13:24:37 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> [a] -> [a]
13:24:44 <byorgey> frerich: something like that ^^
13:25:24 <edwardk> hrmm that short stratford paper on modeling train tracks with a DSL in Haskell, which showed up on Wadler's blog, makes a nice example for my automatic differentiation library
13:25:24 <frerich> byorgey, ezyang: Coolness, thanks for the pointer. I'm reading Conal Elliots blog article.
13:25:58 <byorgey> then you could write  (mapOnly ((==blah) . name) . modChips) foo
13:26:12 <frerich> Yes, that looks nice!
13:26:16 <vitka> Well, there are limits to every data structure. :P Lists are nice for rapid prototyping, but it's best to to get stuck in them.
13:26:18 <byorgey> where  modChips :: ([Int] -> [Int]) -> Player -> Player
13:26:25 <byorgey> and foo is whatever function updates the chips
13:26:58 <byorgey> edwardk: neat =)
13:27:42 <edwardk> you can replace Result with the normal AD type.
13:28:29 <edwardk> and you can use the naive gradient descent in the library to implement the approximate constraint fitting
13:32:01 <ion> ‘\x -> if p x then f x else x’ could be expressed much more clearly as follows: ‘fromMaybe <*> liftA2 (<$) f (guard . p)’.
13:36:31 <parcs> :t fromMaybe <*> liftA2 (<$) f (guard . ?p)
13:36:32 <lambdabot> forall b. (Show b, SimpleReflect.FromExpr b, ?p::b -> Bool) => b -> b
13:37:52 <ion> :t \p f -> fromMaybe<*>liftA2(<$)f(guard.p)
13:37:53 <lambdabot> forall b. (b -> Bool) -> (b -> b) -> b -> b
13:40:28 <shachaf> @pl \x -> if p x then f x else x
13:40:28 <lambdabot> join (liftM2 if' p f)
13:47:12 <parcs> :t join . liftM2 if'
13:47:13 <lambdabot> Not in scope: `if''
13:47:59 <ion> :t let if' a b c = if a then b else c in join .: liftM2 if'
13:48:00 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
13:48:16 <tamiko> :t D#
13:48:17 <lambdabot> Not in scope: data constructor `D#'
13:49:11 <tamiko> *mhm* To what value should D# (1.0## +## 0.0## *## 2.0##) evaluate?
13:49:26 <tamiko> (Or am I doing something wrong?)
13:50:41 <Ziphilt> I am trying to promote my little haskell project to "separated modules" status, and hierarchical modules in haskell are quite confusing me. looking at existing modules that do compile, i tried to model mine after it, putting proper module declarations, imports, folder hierarchies. it failed, so could someone please point me to a good explanation of how to do it?
13:50:59 <danharaj> Ziphilt: What are the errors you get?
13:51:35 <Ziphilt> Could not find module `PhysSim.Input': locations searched: PhysSim/Input.hs
13:51:53 <ion> ls -l PhysSim/Input.hs
13:52:29 <parcs> do you have "module PhysSim.Input where ..." specified in PhysSim/Input.hs?
13:52:46 <Ziphilt> does that always mean there is something wrong with the file at PhysSim/Input.hs, or could i have goofed up the module importing it?
13:52:49 <Ziphilt> yes, parcs
13:53:22 <danharaj> which directory are you trying to build from?
13:53:36 * Ziphilt facepalm
13:53:48 <Ziphilt> a directory much higher
13:53:51 <Ziphilt> brb
13:54:10 <ion> Thus my suggestion :-)
13:55:02 <Ziphilt> thanks ion, i was not thinking about the shell being the problem
13:55:27 <Ziphilt> that problem is solved, thanks those that just helped
14:14:01 <ezyang> Looks like 'rss' is abandoned.
14:31:26 * hackagebot vect 0.4.7 - A low-dimensional linear algebra library, tailored to computer graphics.  http://hackage.haskell.org/package/vect-0.4.7 (BalazsKomuves)
14:34:43 <maurer_> So, I was using an ffipkg based package, and suddenly, it will not install. Any ideas?
14:41:59 <mjrosenb> ffipkg?
14:44:54 <maurer_> ffipkg is a haskell package that takes in a C header file and automatically makes a set of haskell bindings
14:45:15 <maurer_> Then, you cover over the rough patches (e.g. allocation, etc.) in your own package, and just binds to the ffipkg created package
14:46:30 <TravisD> With the new version of ghci that segfault is gone, for those of you who might have been worried :)
14:57:29 <ddarius> Hinze finally published Typed Quote/Antiquote!
14:58:01 <djahandarie> Functional Pearl?
15:02:25 <luite> what do you guys do when debugging something deep in packages installed from hackage? in my own packages I usually try to make a smaller test case and call the functions directly from ghci, in imperative languages I'd just set a breakpoint in that module
15:03:18 <luite> but I have no idea how to quickly get to the internals of some package module, that may not be exported (or require data that's difficult to construct without having access to more of the implementation)
15:04:22 <ivanm> ddarius: what is it?
15:04:51 <chrisdone> luite: I usually end up loading that package in GHCi and then I have access to all the internals and make a test-case. E.g. I had a bug in HaskellDB’s postgres driver. Just loaded up the package, played with the internals a bit and fixed it.
15:04:55 <cmccann> luite, there's always the GHCi debugger
15:05:28 <cmccann> luite, and I wouldn't hesitate the grab the package itself and start digging
15:05:34 <cmccann> rather than only looking at what it exports
15:05:48 <ivanm> cmccann: you wouldn't hesitate at all? not even a little bit? :p
15:06:33 <cmccann> ivanm, if I think it would help, at least
15:06:45 <ivanm> not even bothering to try and contact the maintainer first?
15:06:47 <luite> chrisdone: hmm, importing the module doesn't do that right? or did you mean downloading the source, unpacking it and using those files?
15:06:49 <chrisdone> ivanm: I think he'd hesitate to press return on the “START” button, but then a bead of sweat would run down his forehead; he'd wipe it off and whack return. Then a progress bar would come up.
15:07:15 <ivanm> luite: yeah, that's what he's referring to
15:07:27 <ivanm> chrisdone: heh
15:07:29 <chrisdone> luite: The latter, yeah.
15:07:32 <luite> meh...
15:07:40 <ivanm> luite: cabal unpack <foo>
15:07:50 <luite> ivanm: I know, I've already done that far too often
15:07:52 <luite> but
15:07:57 <cmccann> ivanm, as often as not the problem is my own misuse of the library, so no
15:08:02 <ivanm> cmccann: heh
15:08:19 <cmccann> I operate on the assumption that most actively-maintained packages do what they do for a reason
15:08:49 <ben> legacy's a reason
15:08:50 <chrisdone> I have seven patched libraries in my lib/ dir in one project because I had to fix some things.
15:08:59 <ivanm> chrisdone: :o
15:09:00 <cmccann> and just digging into the code to see how it ticks is usually a good way to see what's going on
15:09:08 <ivanm> you pushing those patches upstream?
15:09:41 <luite> ivanm: but it's difficult to use those things in your own programs unless you overwrite the installed package
15:09:42 <chrisdone> Nah. I might do.
15:09:47 <cmccann> ben, it's a reason and not necessarily a bad one
15:10:02 <chrisdone> luite: Not with cabal-dev; it's trivial with that. Have you used it?
15:10:14 <ivanm> chrisdone: so you're just going to leave it to the next sucker to debug? :p
15:10:25 <cmccann> even if a library does something in a silly way for legacy reasons, it's better to work with it than against it if you're using it at all
15:10:33 <luite> chrisdone: not yet, I planned to. this might be a good opportunity :)
15:10:37 <chrisdone> ivanm: And I hope they spend all day debugging it like I did. :p
15:10:47 <ivanm> chrisdone: you evil bastard! :p
15:10:50 <chrisdone> Hahaha.
15:11:25 <tommd> So long as none of the patches are for my packages, I'm all for the NSMD (next sucker must debug) tactic.
15:11:38 <maurer_> In case anyone else is having trouble with ffipkg, it looks like gold does incorrect path relativizing on the linker scripts that ghc outputs for it
15:11:51 <maurer_> Switching to ld.bfd resolves the issue
15:12:20 <luite> but still things like "I want to see the arguments of function X the first time it is called" are still way too difficult for haskell :(
15:12:21 <chrisdone> cabal-dev is really a panacea for me with Haskell package management and my dev workflow.
15:12:25 <troppa> Hey how come Haskell is even harder than coq?
15:12:37 <troppa> I thought coq was hard, but Haskell is just mumbo jumbo
15:12:47 <troppa> Wtf ST monad?
15:12:58 <chrisdone> troppa: Like WHAT?
15:13:13 <troppa> Doesn't make sense
15:13:14 <chrisdone> S—T up in this?
15:13:24 <cmccann> troppa, yes it does
15:13:32 <troppa> No it doesn't
15:13:37 <troppa> I tried reading up on this
15:13:45 <cmccann> troppa, incorrect
15:13:45 <TravisD> Dont feed the troll!
15:13:49 <troppa> You know
15:13:49 <cmccann> you may have read, but didn't try
15:13:51 <cmccann> :)
15:13:52 <troppa> Category theory
15:13:58 <troppa> what. the. fuck?
15:14:06 <chrisdone> troppa: (☞ﾟヮﾟ)☞
15:14:14 <troppa> Stupid cocones and epimorfisms
15:14:16 <troppa> what?
15:14:20 <cmccann> sigh
15:14:22 <troppa> That was just confusing
15:14:25 <chrisdone> luite: Yeah, I guess.
15:14:28 <cmccann> the quality of trolls is really declining these days
15:14:51 <troppa> I was so frustrated that I just went out, pillaged and raped
15:15:03 <xplat> can't even segue naturally when people aren't picking up on the first subject enough
15:15:16 <luite> chrisdone: trying cabal-dev now :)
15:15:22 <chrisdone> :-)
15:15:25 <ivanm> chrisdone: what characters did you have after the first pointing hand?
15:15:30 <ivanm> I just see three boxes...
15:15:32 <troppa> seriosuly though
15:15:45 <troppa> graph homomorphisms was a little funny
15:15:58 <ivanm> troppa: what's so funny about graph homomorphisms?
15:15:58 <troppa> but that was just a little part of category theory
15:16:06 <chrisdone> ivanm: What client are you using? I would expect that your font would fall back to a base font for characters it can't render…
15:16:06 <ivanm> graphs are serious business!
15:16:07 <troppa> You know
15:16:12 <ivanm> chrisdone: xchat
15:16:17 <troppa> You have one graph
15:16:20 <chrisdone> Hm; me too.
15:16:23 <chrisdone> ivanm: What font?
15:16:28 <troppa> fold it in on itself
15:16:34 <troppa> and maybe you get another
15:16:38 <ivanm> chrisdone: DejaVu Sans Mono
15:16:39 <troppa> or well you do
15:16:48 <ivanm> troppa: and what's so funny about that? hmmmm?
15:16:52 <Peaker> troppa: what are you babbling about? :P
15:16:56 <chrisdone> ivanm: Weird. That's what I'm using.
15:17:03 <chrisdone> Peaker: Zhivago, is that you? ;-)
15:17:09 <troppa> and that graph preserves maps
15:17:10 <troppa> etc
15:17:26 <troppa> Anyways I'm not interested in all that bullshit math stuff
15:17:33 <ivanm> chrisdone: when I put it in my edit box down the bottom (which is using a different font I think) it works though
15:17:43 <ivanm> troppa: I still fail to see the humour in it
15:17:44 <Peaker> chrisdone: :-)
15:17:46 <TravisD> !grab troppa
15:17:55 <troppa> wtf?
15:17:57 <TravisD> Ah, no quoting bot :(
15:17:57 <Peaker> chrisdone: Zhivago could have destroyed #haskell in a week :)
15:18:14 <Peaker> troppa: how much Coq do you know?
15:18:30 <troppa> Enough to get by
15:18:48 <troppa> You'd think coq was hard
15:18:54 <troppa> but Haskell is much much harder
15:19:15 <troppa> Oh I suppose I should elaborate on "hard"
15:19:17 <xplat> the underlying graph of a category is transitive.  transitive graphs have no bridges.  this is why trolls always have problems with category theory.
15:19:25 <cmccann> xplat, hahahaha
15:19:41 <TravisD> rofl
15:19:43 <ivanm> troppa: may it be that you decided to grasp and understand all the infinite complexibilities of Haskell in one fell swoop, which is impossible unless you are a Simon, or called Oleg or dons ?
15:19:43 <ivanm> :p
15:19:46 <nihtml> :t iwords
15:19:46 <troppa> It's harder to do anything useful in it
15:19:47 <lambdabot> Not in scope: `iwords'
15:20:01 <troppa> Oh I have met dons
15:20:11 <troppa> I tried to steal my shoes
15:20:14 <troppa> that motherfucker
15:20:32 <ivanm> you're bitching about dons because for some strange reason you tried to steal your own shoes? :/
15:20:38 <Saizan> @remember xplat the underlying graph of a category is transitive.   transitive graphs have no bridges.  this is why trolls always have problems with category theory.
15:20:38 <lambdabot> It is stored.
15:20:40 <chrisdone> Peaker: Yeah, he had zero tolerance for stupidity, but was a nice and interesting guy otherwise. Much like Zmerdy or others, I guess.
15:20:42 <chrisdone> ivanm: http://i.imgur.com/X77n3.png
15:20:45 <ivanm> @remember troppa I tried to steal my shoes
15:20:45 <lambdabot> I will never forget.
15:20:56 <dankna> hahaha that's a nice quote
15:21:03 <Peaker> chrisdone: Zero tolerance not for stupidity exactly, but anything he *perceived* as wrong
15:21:05 <dankna> the bridges/trolls one
15:21:05 <troppa> Oh i meant dons
15:21:14 <troppa> dons is a thief
15:21:27 <ivanm> chrisdone: yeah, I saw that when I copy-pasted in the message box... >_>
15:21:34 <Peaker> chrisdone: He would also twist the truth and go to ridiculous lengths to not appear as having lost an argument :)
15:21:38 <ski> (chrisdone : Smerdyakov)
15:21:50 <troppa> I also am wary of galois
15:21:54 <chrisdone> ski: I meant Smerdy, heh. Don't know what I put a Z.
15:22:01 <troppa> I have heard what goes on in the showers there
15:22:11 <troppa> All that aside
15:22:22 <ivanm> chrisdone: maybe it's a locale issue...
15:22:31 <troppa> Why is Haskell useless? Are you really supposed to make programs with it?
15:22:41 * cmccann is starting to think troppa is a bot
15:22:46 <ivanm> troppa: obviously, we are, and you are not
15:22:55 <troppa> What?
15:23:00 <ivanm> there _is_ an inherent intelligence test within developing Haskell software...
15:23:01 <cmccann> the lack of coherence between statements sounds awfully ELIZA-ish
15:23:01 <ivanm> ;-)
15:23:05 <troppa> ivanm: that makes no sense
15:23:12 <chrisdone> Peaker: That's true enough. It's a shame people like that who are very effective at arguing tend to use that power to be over assertive, arrogant and nasty.
15:23:19 <ivanm> cmccann: nah, there does seem to be some kind of internal illogic to his statements
15:23:21 <troppa> Also I don't like that russian name
15:23:21 <dankna> no, he reacted correctly when he realized his pronoun mistake
15:23:31 <cmccann> hm, true
15:23:33 <djahandarie> troppa, I don't think it's useless. And people do make programs with it.
15:23:35 <ivanm> troppa: what Russian name?
15:23:40 <dankna> it might be that there's a bot component to him, but there's also some manual intervention
15:23:41 <troppa> ivan
15:23:48 <ivanm> I'm not Russian
15:23:55 <cmccann> then again, chatbots have improved since ELIZA
15:23:58 <troppa> Well that doesn't make it better
15:23:59 <xplat> troppa is funnier if you don't answer
15:24:11 <ivanm> cmccann: yeah, well, he's now racially profiling me
15:24:15 <ivanm> I doubt any bots are _that_ smart
15:24:17 <ddarius> troppa is funnier when he doesn't talk
15:24:19 <xplat> he gets so desperate for a response :)
15:24:20 <Peaker> chrisdone: Yeah, I think overall it's definitely not worth the extra expertise to have someone like that in any community/forum
15:24:47 <tommd> troppa: What is your name if you reverse the letters?
15:24:51 <cmccann> ivanm, nah, that's actually the sort of seemingly-relevant things that people like to program into chatbots to make them seem smarter than they are
15:24:53 <troppa> I made a few Haskell programs actually
15:25:06 <troppa> but the exception system is so stupid I refuse to make more
15:25:08 <ivanm> but he's now being a racist; can we please have an op kick him out of here?
15:25:21 <troppa> woah woah woah ivanm
15:25:29 <tommd> ANnd he's dissing extensible exceptions!
15:25:34 <troppa> having preferences is not the same as being racist
15:25:37 <chrisdone> Peaker: Erik Naggum was of similar ilk, I suppose (and Dijkstra to some degree). These kind of people get attention.
15:25:41 <troppa> wtf I thought you ppl were smart
15:25:44 <ivanm> I don't really care, but he may damage our reputation of friendliness
15:25:46 <chrisdone> Peaker: Agreed, worth the re expertise.
15:25:49 <cmccann> I mean, obviously there's enough knowledge about Haskell involved
15:26:01 <cmccann> so it'd have to be a chatbot designed specifically to troll #haskell
15:26:06 <cmccann> which would actually be incredibly hilarious
15:26:12 <cmccann> but probably more effort than anyone would expend
15:26:16 <Peaker> chrisdone: we have a guy like that at work -- people are afraid to voice objections or unclear things around him
15:26:36 <Peaker> chrisdone: so sometimes whole meetings are wasted on a wrong path -- because they don't want to get shouted at
15:26:54 <troppa> I find that Haskell is only fun with -XMagicHash and writing straight Core
15:27:06 <troppa> Otherwise just stupid boxing going on
15:27:12 <chrisdone> Peaker: Yeah, there's been one in every workplace I've been in. You have to speak to them in a special way, or not bother; most people don't bother. Yeah— it's a real waste of time.
15:27:13 <ben> boxing can be fun too
15:27:19 <Peaker> cmccann: But who put all the Haskell-specific rants into the troppa bot?
15:27:40 <cmccann> Peaker, I dunno, like I said it seems too specific
15:28:12 <cmccann> but the style of rambling with frequent subject shifts and disregard for context just seems really bot-like
15:28:22 * cmccann shrugs
15:28:36 <troppa> Your socks are rambling
15:28:48 <dolio> preflex: seen monochrom
15:28:48 <preflex>  monochrom was last seen on #haskell 19 hours, 37 minutes and 22 seconds ago, saying: haha
15:28:53 <chrisdone> How do you ignore someone in xchat?
15:28:57 <xplat> i theorise that somebody wants to write a new lambdabot plugin without doing any programming themselves
15:29:11 <troppa> lambdabot is stupid
15:29:19 <luite> chrisdone: great, this really helps for inserting Debug.Trace things into packages :)
15:29:20 <xplat> a la @protontorpedo
15:29:29 <chrisdone> luite: Haha. Great.
15:29:37 <troppa> Okay I have a challenge
15:29:44 <chrisdone> luite: I *love* cabal-dev ghci.
15:29:47 <ivanm> chrisdone: /ignore I think
15:29:57 <ivanm> chrisdone: also under the Window menu
15:30:08 <cmccann> ah well, it's either a surprisingly elaborate trolling bot or a human that failed a turing test
15:30:11 <troppa> I am really a hot woman, if any of you can produce a useful Haskell program in an hour or so you get to have your way with me
15:30:12 <cmccann> either way, pretty funny
15:30:18 <chrisdone> ivanm: I did /ignore troppa all. I guess that's sufficient.
15:30:21 <troppa> I feel pretty damn safe
15:30:30 <ivanm> chrisdone: I may join you
15:30:59 <troppa> category theory
15:31:05 <dolio> @where ops
15:31:05 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
15:31:14 <troppa> What the fuck is its relation to Haskell anyways
15:31:25 <troppa> might as well just dump that
15:31:40 <xplat> or maybe somebody on this channel is playing troppa so they can write the @troppa lambdabot plugin and get ops on lambdabot
15:31:51 <Cale> lol
15:31:52 <chrisdone> It's interesting how the channel becomes fairly quiet on weekends. I have the same results with my programming web site stats, programmers appear to have lives on the weekend, after all.
15:32:21 <cmccann> actually, the more that I think about it, writing a chatbot that trolls programming language communities sounds hilarious
15:32:42 <dankna> chrisdone: that /is/ pretty interesting
15:32:49 <Cale> troppa: The relationship between category theory and Haskell is that there is a category whose objects are Haskell types, and whose arrows are Haskell-defineable functions between them.
15:32:52 * dsouza wasn't aware of /ignore ... nice! :-)
15:33:08 <ddarius> Cale: What's its composition?
15:33:16 <dolio> Can we just get to the banning already?
15:33:29 <Cale> ddarius: Why, function composition of course :)
15:33:31 <dankna> @where ops please deal with this troll, troppa
15:33:31 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
15:33:41 * ski . o O ( .. or silencing )
15:33:46 <Cale> hmm
15:33:47 <dankna> have to summon them!
15:33:52 <troppa> lol Haskell folks can't do shit
15:33:54 <dolio> I already did.
15:33:56 <ddarius> dankna: That was already done.
15:33:59 <chrisdone> dolio: Haha. Cale’s all, “no, I must save the lost sheep! He just needs guidance!”
15:33:59 <dankna> oh, sorry
15:34:01 <dankna> I missed it
15:34:11 <dankna> I see it in scrollback now, owell
15:34:21 <Cale> chrisdone: Don't you know that #haskell policy is to feed trolls until they explode.
15:34:28 <chrisdone> Cale: Hahaha.
15:34:32 <ski> @quote feed.troll
15:34:32 <lambdabot> Cale says: Here [#haskell], we feed trolls until they explode.
15:34:33 <ddarius> Cale: Composition doesn't satisfy the identity law.
15:34:47 <cmccann> Cale, I'm still suspicious it's actually a bot
15:34:51 <troppa> I hate c++ why is Haskell using the llvm backend for code generation
15:34:54 <troppa> fuck it
15:35:02 <djahandarie> (Semigroupoid Theory?)
15:35:10 --- mode: ChanServ set +o monochrom
15:35:10 <Cale> troppa: There's *an* llvm backend for GHC, but you don't have to use it.
15:35:24 <Cale> There's also a native code generator
15:35:29 <troppa> monochrom: Fuck you dumbasss
15:35:33 <Cale> as well as a backend which compiles via C
15:35:33 --- mode: monochrom set +q *!*@gateway/web/freenode/ip.178.73.218.5
15:35:41 <parcs> i don't think it's a bot. troppa seems to be connected through freenode's webchat
15:35:43 --- mode: monochrom set -o monochrom
15:35:48 <chrisdone> Cale: I forgot about that; I've seen trolls get exhausted through the goodwill and exuberant teaching here. :-)
15:35:51 <dankna> that's a good point as well
15:35:53 <Cale> Okay, okay, we can mute him :)
15:36:11 <ben> Is llvm the default already?
15:36:14 <djahandarie> ben, no.
15:37:55 * cmccann saves the log from that for possible future reference in chatbot design
15:38:23 --- mode: ChanServ set +o monochrom
15:38:31 --- mode: monochrom set -q *!*@gateway/web/freenode/ip.178.73.218.5
15:38:37 --- mode: monochrom set -o monochrom
15:38:54 <dolio> Seriously, I've seen that, "I'm a hot woman and ..." line used at least half a dozen times before. That's not someone who's misguided but looking to learn.
15:39:42 <cmccann> dolio, canned lines like that are part of what made me think it was a bot
15:40:09 <dankna> yeah, I agree that it's not someone who deserves a chance, but it's the ops' decision.
15:40:32 <monochrom> it has repeatedly happened before
15:40:53 <cmccann> most of the seemingly-human features (variable pauses to indicate typing delay, occasional errors) are easily faked
15:40:57 <dankna> well, it's not frequent enough to be worth our time and effort really
15:41:00 <monochrom> I was just away, that's all
15:41:13 <dankna> beyond just muting or banning as it comes up
15:41:31 <monochrom> I should just write a bot that waits for that and ban or +q :)
15:41:32 <dolio> Well, I signaled you first, since I know you enjoy it so.
15:41:43 <ddarius> Someone can write a lambdabot plugin.
15:41:49 <monochrom> haha
15:41:59 <djahandarie> I would feel extremely insecure if lambdabot had op access in here
15:42:13 <djahandarie> @vixen Do you like being in power?
15:42:13 <lambdabot> yeah, i like
15:42:27 <dankna> @vixen do you like belgian waffles with fresh blueberry topping?
15:42:27 <lambdabot> yah, i like
15:42:34 <dankna> @vixen do you like things that you don't like?
15:42:35 <lambdabot> sure, i definitely don't hate
15:42:41 <dankna> huh
15:42:45 <dankna> haven't seen that response before
15:43:15 <cmccann> give lambdabot ops, hand out tempbans for making type errors in chat
15:43:19 <cmccann> that would be fun
15:43:24 <dankna> for two seconds or so :)
15:43:28 <cmccann> :]
15:43:43 * monochrom will never made a type error again
15:43:51 * monochrom will never made a type error again
15:43:59 <monochrom> (98 more lines to go)
15:44:04 <cmccann> haha
15:44:18 <chrisdone> I had my Emacs send out my type errors to Twitter once. Had to turn it off. :-P
15:44:32 <dankna> ah yeah, I remember that
15:44:33 <dankna> it was amusing
15:44:33 <cmccann> ahahahahahaha nice
15:45:16 <monochrom> did anyone seriously followed your type error tweets?
15:46:00 <monochrom> or did you just earn the respect of a lot of spam bots who tried to sell you debuggers? :)
15:46:56 <djahandarie> Frustrated with Haskell? Check out PHP! No more type errors!
15:47:24 <monochrom> damn, I made an English type error (tense in the case) afterall
15:50:04 <Peaker> no more type errors! frustrated clients instead!
15:52:04 <chrisdone> Sorry, was making a BLT. There were people who were already following me who got them, but I wouldn't say they were ‘following’ my errors. :-P
15:52:39 <chrisdone> Peaker: Some apps are in Drupal at work. It's amazing how slow that system is. Everything must be cached.
15:54:30 <zmv> uh
15:54:33 <zmv> 20:16 <       lambdabot> girls masturbate too you know... probably more than guys. we can do it anywhere discretely
15:54:43 <zmv> ok then
15:54:46 <chrisdone> vixen is cheeky.
15:55:15 <zmv> yup
15:55:16 <cmccann> to be fair that's less offensive than some of the things that @pl says
15:55:26 <zmv> lemme try it
15:55:41 <zmv> haha
15:55:51 <chrisdone> @pl \x y -> x * x + (y / x)
15:55:51 <lambdabot> ap ((.) . (+) . join (*)) (flip (/))
15:56:16 <djahandarie> @pl \a b c d e f -> f e d c b a
15:56:16 <lambdabot> flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id))))
15:56:26 <cmccann> nice
15:56:32 <zmv> hm.
15:57:38 <chreekat> Hi folks, my brain can't parse the definition of the MonadState class. What's the "| m -> s" do in "class Monad m => MonadState s m | m -> s where" ?
15:57:41 <chrisdone> ivanm: What are you working on these days?
15:58:00 <chrisdone> chreekat: That's called a functional dependency.
15:58:10 <chrisdone> http://www.haskell.org/haskellwiki/Functional_dependencies
15:58:21 <cmccann> chreekat, it means that for any instance, the type "m" uniquely determines the "s"
16:00:24 <cmccann> chreekat, e.g. if you have something like "State String" that's the m, there's only one possible state type, the "s", that makes sense
16:00:43 <cmccann> but the compiler can't figure that out on its own, so the functional dependency is there to tell it
16:00:54 <zmv> @yhjulwwiefzojcbxybbruweejw test, a.k.a why the hell does lambdabot have this thing?
16:00:55 <lambdabot> Exception: <<loop>>
16:01:28 <chreekat> ah, very cool
16:02:50 <Saizan> > fix show
16:02:51 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
16:02:53 <ddarius> cmccann: Without the functional dependency, nothing is forcing s to be String in that example.  It's not a matter of the compiler not being "smart enough."
16:03:35 <zmv> @protontorpedo
16:03:35 <lambdabot> so how do you use haskell tools to build large programs?
16:03:47 <zmv> heh.
16:04:21 <chrisdone> You build half of it and release several research papers.
16:04:58 <mm_freak_> lol
16:07:03 <mm_freak_> chreekat: i always found associated types to be easier to understand and work with
16:07:31 <ddarius> mm_freak_: Even before they existed?
16:07:46 <mm_freak_> all the usual monad transformer libraries have a variant using associated types instead of fundeps…  you recognize them by looking for the "-tf" prefix in the package names
16:08:20 <mm_freak_> ddarius: before i knew about them, i always wanted them =)
16:14:38 <chreekat> mm_freak_: ahh found it. yeah i kinda like that
16:17:12 <ben> > let (.) = (+) in 5.5
16:17:12 <lambdabot>   5.5
16:17:15 <ben> ಠ_ಠ
16:17:52 <monochrom> tokenizer is tricky
16:21:22 <ben> > length "\&x"
16:21:23 <lambdabot>   1
16:21:25 <ben> > '\&x'
16:21:26 <lambdabot>   <no location info>:
16:21:26 <lambdabot>      lexical error in string/character literal at chara...
16:21:29 <ben> :I
16:22:45 <ddarius> > length "\            \"
16:22:46 <lambdabot>   0
16:24:29 <zmv> @protontorpedo
16:24:29 <lambdabot> what makes haskell more fun than say clisp?
16:24:38 <zmv> lolwut
16:25:28 <mm_freak_> good question actually
16:25:39 <ben> the syntax, imo
16:26:07 <mm_freak_> i like the syntax, but i wouldn't list that as a point
16:26:18 <mm_freak_> i like the type system mostly
16:26:25 <Ziphilt> i have a very simple physics simulator, implementing gravity and springs. it uses Double precision. things are programmed so that no energy is lost; springs are perfectly elastic. the problem is, they gain energy over time. is this a rounding error building up or something?
16:27:04 <ben> seems likely?
16:28:12 <Ziphilt> well, are the FPUs of computers biased to round up?
16:28:22 <ivanm> chrisdone: trying to improve the user-experience of graphviz (should have it out by next weekend)
16:28:29 <ivanm> planar graphs and some generating algorithms for uni
16:28:50 <ivanm> and I should really get around to adding native Cabal support to paludis (avoiding it due to it being written in C++) :s
16:29:00 <mm_freak_> Ziphilt: they are usually biased to round down
16:29:50 <mm_freak_> Ziphilt: that could lead to the effect, if a divisor is rounded down, or when a positive value < 1 is squared and the like
16:29:58 <Ziphilt> ah
16:30:06 <mm_freak_> square-rooted, not squared
16:31:36 <Ziphilt> since my physics needs to have entropy added to be realistic anyway, this isn't much of a problem
16:32:41 <zmv> let's go again then.
16:32:42 <Ziphilt> but it is a bit amusing for a pair of masses attached by a spring to begin oscillating mildly and slowly get more energetic, to the point of spazzing and leaving the world
16:32:48 <zmv> @protontorpedo
16:32:48 <lambdabot> on the haskell site they compare haskell to a spreadsheet
16:32:57 <zmv> hahahahahahahahahahahaha
16:33:37 <Ziphilt> is that actually true, zmv?
16:33:45 <Ziphilt> i would hope not
16:33:46 <zmv> I don't think so.
16:34:03 <ddarius> So you're using a symplectic integrator?
16:34:29 <mm_freak_> that is indeed true
16:34:51 <mm_freak_> i have read somewhere that a spreadsheet is a form of declarative programming
16:35:06 <zmv> hm
16:35:31 <zmv> so, why the hell would somebody do *this* http://haskell.org/haskellwiki/index.php?title=Haskell&oldid=35991 ?
16:36:23 <mm_freak_> i rather wonder why it's still there…  i could imagine that search engines wouldn't like that
16:36:37 <ddarius> http://haskell.org/haskellwiki/Introduction
16:48:03 <stribor> guys how do i check if parsec is installed
16:49:12 <parcs> ghc-pkg list | grep parsec
16:49:33 <parcs> oh even ghc-pkg list parsec
16:51:57 <stribor> i have this package installed libghc6-parsec-dev
16:52:45 <stribor> yeah i just checked parsec is there
16:52:52 <benmachine> the ghc-pkg list thing will tell you which version you have
16:52:58 <benmachine> and whether it's a user or system install
16:53:11 <stribor> i have 2.1.0.1
16:54:28 <stribor> all i have is file with this..module Main where  import Parsec.....which i am trying to load with ghci
16:54:56 <stribor> error is this...Could not find module `Parsec':
16:56:23 <benmachine> stribor: the module is not called Parsec
16:57:04 <stribor> i got this from http://research.microsoft.com/en-us/um/people/daan/download/parsec/parsec.html
16:57:08 <benmachine> stribor: you probably want Text.Parsec or perhaps Text.ParserCombinators.Parsec
16:57:27 <stribor> First of all, import the library into your Haskell module:  module Main where  import Parsec
16:57:31 <ddarius> benmachine: The former only exists in Parsec 3
16:57:52 <benmachine> ddarius: oh, yes, I knew that but I missed where he said 2.1.0.1
16:58:21 <ddarius> stribor: That article was written for the original version of Parsec.  It mostly still applies, but the module names have changed.
16:59:03 <stribor> where can you find  new names
16:59:10 <ddarius> @hackage parsec
16:59:10 <lambdabot> http://hackage.haskell.org/package/parsec
17:00:59 <stribor> cant find this one eighter...import Text.Parsec.Prim
17:01:53 <ddarius> As I said, Text.Parsec is only in Parsec 3.
17:05:20 <Peaker> is "let v = f k x in v `seq` Tip k v"  equivalent to  "Tip k $! f k x" ?
17:05:59 <ddarius> Yes.
17:06:10 <ddarius> @src ($!)
17:06:11 <lambdabot> f $! x = x `seq` f x
17:06:33 <ddarius> Well, I guess if v is polymorphic they could be not shared.
17:06:42 <Peaker> I wonder why ezyang used the former notation in his blog post
17:06:52 <ben> @hoogle $!
17:06:52 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
17:07:27 <ddarius> It's even conceivable that they are semantically different if the two uses of v get instantiated to different types in the former.
17:07:35 <ddarius> In that sense, ($!) is safer.
17:07:38 <ben> I thought that was buried in some parallel module
17:08:07 <Peaker> in http://blog.ezyang.com/2011/06/pinpointing-space-leaks-in-big-programs/
17:12:29 <Peaker> Awesome blog post, btw :-)
17:12:39 <Peaker> Profiling graph output seems that much more useful now
17:14:45 <dons> yes, very good post.
17:17:58 <Peaker> I remember being baffled about the generic-ness of some of the names of the leaking things. Retainer profiling seems great
17:18:10 <Peaker> Can all of these profiles be generated in the same run?
17:18:21 <Peaker> Because you don't always have a deterministic run
17:19:52 <Peaker> I wonder if ezyang has great memory, or if he wrote everything he did as he went along
17:27:15 <ccc> quit
17:41:37 <zmv> @protontorpedo
17:41:38 <lambdabot> what does haskell do better than java perl or ruby?
17:41:44 <zmv> haha
17:41:48 <edwardk> preflex: xseen cale
17:41:49 <preflex>  cale was last seen on freenode/#haskell 2 hours, 5 minutes and 58 seconds ago, saying: Okay, okay, we can mute him :)
17:41:56 <edwardk> preflex: xseen roconnor
17:41:57 <preflex>  roconnor was last seen on freenode/#haskell 11 hours, 7 minutes and 53 seconds ago, saying: yes
17:47:18 <termcap> How can somebody with minimal previous coding experience, who has started looking into Haskell today contribute?
17:47:33 <edwardk> termcap: by learning everything you can
17:47:34 <benmachine> termcap: hang around here and be nice to people
17:47:54 <cmccann> termcap, think of something you want to do, try doing it, then when you get confused and stuck take extensive notes on why you did
17:48:26 <termcap> I've noticed that most projects tell non coders that they can work on documentation, but I couldn't find anything on the website
17:48:51 <cmccann> unfamiliarity with a subject is a resource that can be discarded, but rarely regained, and after getting used to something it's hard to remember which parts were confusing
17:49:17 <cmccann> and things that confuse newcomers usually could be improved in ways that would help everyone, in my experience (through better documentation, if nothing else)
17:49:17 <Cale> edwardk: hi
17:49:29 <edwardk> termcap: not that easy here. the java world winds up with large swathes of 'undocumentation' which can be figured out from the type signatures, but to write useful docs here in the haskell world usually requires rather extensive understanding of the problem domain in my experience
17:49:51 <edwardk> cale: btw- if you're not doing anything for the next few days you're welcome to actually come hang out for the workshop =)
17:50:03 <Cale> Workshop?
17:50:19 <edwardk> teaching a domain-specific languages workshop here at mcmaster from monday to wednesday
17:50:25 <Cale> ah, cool
17:50:27 <termcap> I see, I guess I'll just keep toying around and hopefully find something desirable to work on
17:50:44 <edwardk> wren was coming up to help out, but he is currently stuck at the border
17:50:49 <aavogt> termcap: write a monad tutorial!
17:50:53 <TravisD> termcap: Why not read a book? When you're done you'll have the skill-set to work on projects you care about
17:50:59 <cmccann> termcap, do you have any specific interests or goals?
17:51:17 <edwardk> termcap: have you looked at learn you a haskell or real world haskell yet?
17:51:33 <termcap> I'm reading through learn you a haskell and have just found two dozen short lessons
17:51:35 <cmccann> it usually helps to have something to aim for, even if it's arbitrary and chosen only for that purpose, just so long as it's something you enjoy
17:52:52 <parcs> termcap: why do you want to contribute to haskell?
17:53:07 <kmc> 'haskell' is not a specific thing one contributes to
17:53:22 <Botje> unless your name is simon
17:53:37 <termcap> parcs: I've been poking around various languages for a few months, and haskell just seems so elegant that it actually got me excited
17:54:13 <cmccann> termcap, it is, and it's a lot of fun to use
17:55:02 <Botje> I'm considering prototyping my gradual typing stuff in scala
17:55:11 <Botje> (interoperability with java is a requirement)
17:55:30 <Botje> any excuse is good to learn a new language >:)
17:55:33 <cmccann> termcap, but it still helps to have something a bit more focused in mind, to give you some direction
17:57:37 <termcap> cmccann: agreed. I'll get more familiar first and I'm sure something will come up. I was only curious if there was anything recommended where one could learn and 'help' at the same time
17:58:34 <cmccann> termcap, I still suggest taking notes on your experience, if it's not too troublesome
17:58:40 <benmachine>  < cmccann> termcap, think of something you want to do, try doing it, then when you get confused and stuck take extensive notes on why you did <-- I second this btw
17:59:09 <cmccann> Haskell has a lot of enthusiasts but few casual users, so it's hard to get data on sticking points for people who aren't already immersed in it
17:59:26 <cmccann> i.e., just restating the part benmachine quoted
18:00:06 <termcap> makes sense. I'll keep track and maybe one day it will be useful for somebody other than me
18:00:06 <benmachine> yeah
18:00:09 <cmccann> there are a lot of things that many of us take for granted that aren't simple and obvious to newcomers
18:00:30 <benmachine> well, in general, there's a problem that the people best suited to fix problems in documentation are the people least suited to spotting them :P
18:00:50 <cmccann> benmachine, that's exactly the problem, yes :)
18:01:42 <cmccann> but it's exacerbated when a community tends to contain mostly enthusiasts and newcomers, with little in between, which is the impression I get with Haskell
18:02:36 <cmccann> people seem to either quickly give up and stop using it, or get hooked and become knowledgeable enthusiasts very quickly, haha
18:04:58 <cmccann> termcap, also note that I phrased that as "when you get stuck". Haskell has a steeper learning curve than many other languages, so don't be embarrassed about asking for help :]
18:05:46 <edwardk> cmccann: haskell's difficulty curve looks kind of like eve's here http://www.mmocrunch.com/wp-content/uploads/2008/03/learningcurve.jpg ;)
18:05:52 <edwardk> but that is what makes it so much fun
18:05:53 <termcap> cmccann: luckily a close friend of mine is something of an enthusiast. Haskell was the first language he had to learn at Uni and never wanted to learn anything else afterwards
18:06:40 <cmccann> termcap, hahaha that's useful then :]
18:07:05 <termcap> edwardk: interesting that with great skill one is able to make time go backwards
18:07:20 <Axman6> termcap: I've been almost the same, though I do also love working in C.
18:07:51 <Cale> I'm not sure I agree necessarily... as a first programming language, Haskell's learning curve seems no steeper than most other languages'
18:08:28 <cmccann> Cale, actually I agree, but I tend to assume that I'm talking to people with prior programming experience
18:08:29 <Axman6> termcap: if you're new to Haskell, you'll find that this channel is probably your most valuable resource (with Cale being probably the best person to ask questions of :P)
18:08:30 <benmachine> it's not something that's easy to gather unbiased data on
18:08:32 <Cale> It's just that once you know an imperative programming language, learning more imperative programming languages is easy.
18:08:50 <benmachine> that's a fair point though
18:09:14 <cmccann> it's pretty rare for someone who's never programmed before to find Haskell first, and almost any other language will build up intuitions that are very counterproductive when learning Haskell
18:09:20 <Axman6> yeah, i feel that knowing an imperative language before learning haskell can make the learning curve steeper, because it not only involves learning, but also unlearning
18:09:31 <mm_freak_> is there a very compact alternative to Set?
18:09:44 <Axman6> mm_freak_: what are you storing in it?
18:09:44 <ddarius> Integer
18:09:49 <benmachine> Axman6: I'm not even sure that's true – but it's certainly steeper than learning more imperative languages
18:09:49 <mm_freak_> Axman6: strings
18:09:55 <mm_freak_> ddarius: very funny
18:10:03 <ddarius> mm_freak_: Integer is a bit set.
18:10:06 <mm_freak_> Axman6: Text strings actually
18:10:19 <benmachine> mm_freak_: compact in terms of memory usage?
18:10:20 <Axman6> @hackage text
18:10:21 <lambdabot> http://hackage.haskell.org/package/text
18:10:22 <ddarius> If you have a bijection between your elements and indices, you could use Integer as a set.
18:10:22 <mm_freak_> ddarius: i know, but it's very difficult to update Integer ;)
18:10:25 <mm_freak_> benmachine: yes
18:10:30 <cmccann> From the right perspective, Integer is a more compact alternative to pretty much every type
18:10:34 <termcap> I tried python right before (Learn Python The Hard Way is great BTW), but I found the lack of structure disorientating, once I got to objects it seemed to be more an excercise in memorising rules instead of it making sense
18:10:35 <ddarius> mm_freak_: You just and in a bit.
18:10:40 <ddarius> Er or in.
18:10:48 <rvn_> Gah, hpaste doesn't have a search feature unless I'm mistaken
18:10:59 <ddarius> set` = 1 `shiftL` index .|. set
18:11:13 <edwardk> cale: fair nuff. i'd rather have had a diagram where most of them taper off after a point and haskell stays on a constant slope, but this one was available ;)
18:11:20 <ddarius> @google site:hpaste.org haskell
18:11:21 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
18:11:25 <Axman6> termcap: you'll probably find initially that haskell feels a little like that, but once you understand why things are they way they are, it all feels very consistent
18:11:35 <cmccann> edwardk, I'm not even sure about that, really
18:11:36 <mm_freak_> i can decrease my memory by half by using ByteString instead of Text, but that's only partially helpful
18:11:44 <Axman6> @google "site:hpaste.org haskell"
18:11:46 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
18:11:48 <Axman6> :(
18:11:55 <benmachine> @google banana
18:11:56 <lambdabot> http://bananarepublic.gap.com/
18:11:56 <lambdabot> Title: Apparel, Handbags, Shoes and Accessories for Women and Men | Free Shipping on $5 ...
18:11:59 <mm_freak_> ddarius: but you've given me an interesting idea
18:12:01 <benmachine> oh
18:12:08 <benmachine> @google more than one word
18:12:09 <lambdabot> http://www.fuelyourwriting.com/more-than-one-word-com-with-brian-kessler/
18:12:10 <lambdabot> Title: More Than One Word (.com) With Brian Kessler | Fuel Your Writing
18:12:14 <mm_freak_> UArray Word64 Bool
18:12:17 <benmachine> blink blink
18:12:22 <Axman6> o.O
18:12:22 <mm_freak_> that's actually a very good idea, thanks =)
18:12:37 <mm_freak_> Axman6: i don't need to store the actual strings…  i just need an already-exists test
18:12:40 <benmachine> I wonder what the getHeader thing is about then
18:12:54 <mm_freak_> background: i'm importing 3 million strings from a file into a database
18:13:01 <mm_freak_> and i want to discard duplicates
18:13:02 <cmccann> edwardk, Haskell's actually simpler than many languages in many ways, it has more internal consistency about a lot of stuff
18:13:11 <cmccann> fewer weird ad-hoc rules to remember
18:13:18 <Axman6> mm_freak_: do you need there to be no false positives? because you could use a bloom filter
18:13:26 <ddarius> Haskell is simpler in a more inherent sense as well.
18:13:45 <benmachine> Axman6: which ones are false positives in this context, keeping some duplicates?
18:13:51 <mm_freak_> Axman6: false positives are not too bad, if there are not many…  and usually the set of duplicates is small in relation to the whole list
18:13:55 <benmachine> or presumably discarding non-duplicates
18:14:00 <edwardk> cmccann: that much is true
18:14:08 <benmachine> the latter sounds worse but easier to achieve
18:14:09 <mm_freak_> oh wait
18:14:13 <Axman6> mm_freak_: then a bloom filter may be very useful for you
18:14:20 <mm_freak_> false negatives would be ok, but false positives would be bad
18:14:27 <Axman6> ah ok
18:14:49 <cmccann> edwardk, being able to do very complicated things more easily in Haskell doesn't make the language itself complicated :]
18:14:52 <mm_freak_> if duplicates make it into the database, that's fine, but if legitimate entries are ignored, that's very bad
18:15:43 <Axman6> a bloom filter will always truthfully tell you if something has been inserted. but it may also tell you that something has been inserted when it hasn't
18:16:15 <benmachine> mm_freak_: so make your set more compact by deleting a bunch of things from it :P
18:16:18 <mm_freak_> well, i think, i will convert to ByteString for now
18:16:40 <edwardk> mm_freak: have you looked at storing tries? how long are your bytestrings?
18:17:00 <mm_freak_> edwardk: usually very short…  just user names and hostnames
18:17:08 <Axman6> I've got a tries package, but it's not particularly good...
18:17:21 <edwardk> mm_freak: try the bytestring-trie package
18:17:26 <mm_freak_> edwardk: thank you
18:17:43 <benmachine> are there more general tries?
18:17:47 <edwardk> it gives you big-endian patricia tries on bytestrings
18:17:51 <edwardk> benmachine: yes.
18:17:54 <edwardk> see representable-tries
18:17:59 <edwardk> or MemoTrie
18:18:03 <mm_freak_> or wait…  i get the whole thing into memory anyway…  is there an in-place sort for Vector or repa or something?
18:18:12 <mm_freak_> perhaps a fast repa sort would do the trick
18:18:16 <mm_freak_> then importing would be O(1)
18:18:24 <cmccann> isn't Data.IntSet a trie as well?
18:18:55 <edwardk> cmccann: yes, also a big endian patricia trie, but its limited to 32 or 64 bits in length ;)
18:19:17 <Axman6> which is ok if you're hashing isn't it?
18:19:36 <edwardk> yes
18:19:37 <Axman6> maybe you could use the new hashtable library by gcollins
18:19:39 <edwardk> Data.HashMap does that too
18:19:51 <Axman6> http://gregorycollins.net/posts/2011/06/11/announcing-hashtables
18:19:55 <edwardk> but its no more space efficient than usual
18:20:24 <edwardk> not that the bytestring tries are magically space efficient afaik
18:23:44 <TravisD> s there a function like this (a -> b -> c) -> [a] -> [b] -> [c] where the values in the resulting list come from applying the function (a->b->c) to all pairs of elements from [a] and [b]? (so, in particular, not zipWith)
18:24:20 <benmachine> TravisD: ap ought to do that
18:24:32 <benmachine> > ap (+) [1,2,3] [100,200,300]
18:24:33 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[a1]'
18:24:33 <mm_freak_> TravisD: use a ZipList
18:24:39 <mm_freak_> benmachine: no
18:24:41 * benmachine blink
18:24:46 <benmachine> I am being silly and tired
18:24:49 <benmachine> I meant liftM2
18:24:52 <mm_freak_> but Applicative can indeed do it for ZipList
18:24:56 <benmachine> > liftM2 (+) [1,2,3] [100,200,300]
18:24:57 <lambdabot>   [101,201,301,102,202,302,103,203,303]
18:25:08 <benmachine> mm_freak_: ZipList does zipWith, hence the name :P
18:25:21 <mm_freak_> benmachine: that code would work with ZipList, if you replace liftM2 by liftA2 ;)
18:25:52 <djahandarie> mm_freak_, his question sounded like he didn't want zipping, he wanted nondeterminism
18:26:06 <mm_freak_> oh lol
18:26:16 <mm_freak_> i totally overlooked that last part
18:26:19 <benmachine> TravisD: liftM2 from Control.Monad or liftA2 from Control.Applicative ought to do what you want?
18:26:29 <TravisD> Yes, I think so. Thanks!
18:26:30 <edwardk> @type zipWith
18:26:30 <benmachine> (use liftA2, it's cooler)
18:26:30 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
18:27:02 <edwardk> liftA2 is exactly what you need
18:27:13 <TravisD> Thanks everyone!
18:27:31 <TravisD> Applicative f means that f must be a function?
18:27:35 <benmachine> no
18:27:39 <holmak> @type liftA2
18:27:40 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
18:27:49 <benmachine> it means f must be a type which supports Applicative operations
18:27:57 <benmachine> f can be "list-of"
18:27:58 <Boxo> > iterate (\x -> (x*2)-1) 1
18:27:59 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:28:07 <benmachine> in fact f isn't a type
18:28:12 <benmachine> 'f a' is a type for all a
18:28:27 <benmachine> TravisD: a list comprehension might be simpler
18:28:36 <benmachine> if you haven't learnt about type classes yet
18:28:51 <TravisD> Alright :) I haven't yet
18:29:08 <benmachine> > [x + y | x <- [1, 2, 3], y <- [100, 200, 300]]
18:29:08 <lambdabot>   [101,201,301,102,202,302,103,203,303]
18:29:17 <benmachine> or you can do it with do-notation
18:29:34 <benmachine> > do x <- [1,2,3]; y <- [100,200,300]; [x + y]
18:29:35 <lambdabot>   [101,201,301,102,202,302,103,203,303]
18:29:49 <edwardk> @undo do x <- [1,2,3]; y <- [100,200,300]; [x + y]
18:29:49 <lambdabot> [1, 2, 3] >>= \ x -> [100, 200, 300] >>= \ y -> [x + y]
18:29:51 <benmachine> ^ in your real code you'd use newlines instead of semicolons
18:29:53 <edwardk> or that ;)
18:30:10 <edwardk> which can be simplified of course
18:30:30 <edwardk> > [1,2,3] >>= \x -> map (+x) [100,200,300]
18:30:31 <benmachine> edwardk: to, for example, liftM2 :P
18:30:31 <lambdabot>   [101,201,301,102,202,302,103,203,303]
18:30:34 <edwardk> yeah
18:30:39 <edwardk> @source liftM2
18:30:39 <lambdabot> liftM2 not available
18:30:53 <parcs> @src liftM2
18:30:53 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
18:31:06 <edwardk> @src liftA2
18:31:06 <lambdabot> liftA2 f a b = f <$> a <*> b
19:37:06 <haskelldude> how to create a simple text menu in haskell?
19:37:18 <Axman6> a GUI menu?
19:37:24 <haskelldude> not gui,
19:37:32 <haskelldude> just simple text menu,
19:37:42 <Axman6> you
19:37:50 <Axman6> you'll have to be more clear, sorry :\
19:38:48 <haskelldude> choices will be displayed on screen. ex: enter 1 to do functionX, 2 for functionY etc...
19:41:17 <Axman6> well, you can easily print out a list of strings, and read in a number...
19:41:44 <hpaste> haskellguy pasted “simple menu” at http://hpaste.org/47695
19:42:21 <Axman6> I'd use a case statement instead of lots of if statementsa
19:42:22 <Axman6> -a
19:42:45 <haskelldude> Axman6: pls advise me how to use the case
19:43:02 <Axman6> yep, give me a sec
19:43:20 <haskelldude> Axman6: cool :)
19:43:22 <Axman6> you should make your editor not use tabs, they break things
19:44:04 <haskelldude> then single whitespace instead of tab u recommend?
19:44:22 <ddarius> You can easily abstract so that you only need to write the structure.
19:44:44 <dankna> oh cool!  the hpaste bot is working again
19:45:26 <haskelldude> dankna: this was my first time to use hpaste :)
19:45:26 <hpaste> Axman6 pasted “simple menu 2” at http://hpaste.org/47696
19:46:45 <haskelldude> Axman6: thanks! its pretty neat!
19:46:48 <ddarius> displayMenu choices = do mapM_ displayChoice choices; choice <- getLine; maybe (putStrLn "Choice not found" >> displayMenu choices) id
19:47:00 <ddarius> :t let displayMenu choices = do mapM_ displayChoice choices; choice <- getLine; maybe (putStrLn "Choice not found" >> displayMenu choices) id in displayMenu
19:47:00 <lambdabot> Not in scope: `displayChoice'
19:47:19 <Axman6> hpaste: tabs are interpreted as 8 spaces wide in haskell, and this can cause problems. any decent editor can insert the right number of spaces instead of tab characters
19:47:35 <Axman6> uh, haskelldude, not hpaste >_>
19:47:52 <haskelldude> hehe
19:48:02 <Axman6> i don;t think i got the indentation right in that paste, the list should be indented
19:48:07 <ddarius> :t let displayChoice (selector, (description, _)) = putStrLn (select ++ " - " ++ description); displayMenu choices = do mapM_ displayChoice choices; choice <- getLine; maybe (putStrLn "Choice not found" >> displayMenu choices) snd; in displayMenu
19:48:08 <lambdabot> Not in scope: `select'
19:48:20 <ddarius> :t let displayChoice (selector, (description, _)) = putStrLn (selector ++ " - " ++ description); displayMenu choices = do mapM_ displayChoice choices; choice <- getLine; maybe (putStrLn "Choice not found" >> displayMenu choices) snd; in displayMenu
19:48:21 <lambdabot>     Occurs check: cannot construct the infinite type: b = IO b
19:48:21 <lambdabot>       Expected type: b
19:48:21 <lambdabot>       Inferred type: IO b
19:48:59 <ddarius> :t let displayChoice (selector, (description, _)) = putStrLn (selector ++ " - " ++ description); displayMenu choices = do mapM_ displayChoice choices; choice <- getLine; maybe (putStrLn "Choice not found" >> displayMenu choices) snd (lookup choice choices); in displayMenu
19:49:00 <lambdabot> forall b. [([Char], ([Char], IO b))] -> IO b
19:49:47 <ddarius> This allows you to focus only on the structure of the menu and readily allows nested menus.
19:50:26 * Axman6 thinks ddarius should use hpaste to his code can be read
19:53:13 <haskelldude> ddarius: its bit hard to get the code u hav entered. appreciate if u can use hpaste too...
19:56:11 <ddarius> http://hpaste.org/47697
20:05:27 <RonCol> do user defined data types (data Foo = this | that) have to go at that start of a file (using ghc(i) if it matters)? Can they be entered into the ghci prompt directly? Or is there something weird happining
20:05:59 <ddarius> They can be located anywhere in a file.  They can't be entered into GHCi.
20:06:01 <Axman6> ddarius: i sense that may be a useful, if simple, library
20:06:17 <ddarius> Also, data constructors must start with upper case letters.
20:06:24 <ddarius> Axman6: Who uses a text menu nowadays?
20:06:45 <Axman6> well, i don't use GUI menus...
20:06:53 <ddarius> Admittedly, nothing stops it from having a GUI driver as well.
20:07:26 <dankna> I use GUI menus
20:07:43 <dankna> indeed, I've got code for one on my to-do list, heh
20:07:49 <RonCol> ddarius cheers
20:08:25 <ddarius> I'd be surprised if there aren't a few libraries that do this on Hackage already either in regards to curses-like interfaces or with respect to text-based adventure games.
20:08:47 <dankna> indeed
20:08:50 <djahandarie> Who plays text-based adventure games nowadays?
20:08:55 <dankna> everybody :D
20:09:07 <RonCol> not enough people
20:09:42 <monochrom> who play text-based real-time strategies games?
20:09:51 <dankna> not enough people :)
20:09:54 <dankna> that sounds really interesting
20:09:56 <isomorphic> monochrom: ghci count?
20:10:01 <monochrom> haha
20:10:10 <monochrom> there is also text Doom
20:10:32 <dankna> yeah, there are periodic discussions on rec.arts.int-fiction along the lines of "I bet you can't make /this/ as a text game!"
20:10:39 <dankna> Marble Madness is one I remember fondly
20:11:17 <isomorphic> dankna: What's a good newsgroup provider?
20:11:26 <dankna> http://groups.google.com/
20:11:31 <dankna> I don't know anyone still using NNTP
20:11:31 <monochrom> newsguy.com is good
20:12:32 <ddarius> Did someone make a Marble Madness text game?
20:12:41 <haskelldude> Axman6: why you have used mapM instead of general map?
20:12:53 <Axman6> :t mapM
20:12:54 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
20:12:57 <Axman6> :t map
20:12:58 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:12:59 <isomorphic> dankna: Thanks - I didn't realise newsgroups were in there.
20:13:08 <dankna> yeah
20:13:12 <dankna> ddarius: yes.
20:13:23 <dankna> ddarius: it was short, sadly, having only the first level.
20:13:32 <Axman6> haskelldude: map putStrLn wouldn't do anything, it would just give a list of IO ()
20:13:39 <Axman6> :t map putStrLn
20:13:40 <lambdabot> [String] -> [IO ()]
20:13:56 <Axman6> :t mapM putStrLn
20:13:56 <lambdabot> [String] -> IO [()]
20:14:03 <Axman6> should really use...
20:14:07 <Axman6> :t mapM_ putStrLn
20:14:07 <lambdabot> [String] -> IO ()
20:14:23 * isomorphic checks out newsguy
20:14:26 <Axman6> you could also use putStrLn (unlines [...])
20:14:34 <haskelldude> got it :) thnx!
20:35:26 <hpaste> haskellguy pasted “base convert” at http://hpaste.org/47698
20:40:39 <haskelldude> how to convert an int to a char?
20:41:33 <parcs> :t chr
20:41:34 <lambdabot> Int -> Char
20:43:49 * hackagebot json-builder 0.2.2 - Data structure agnostic JSON serialization  http://hackage.haskell.org/package/json-builder-0.2.2 (LeonSmith)
20:45:12 <haskelldude> thanks but i need to get something like 1 => '1'
20:45:35 <haskelldude> with chr 1 i get '\SOH'
20:45:51 <parcs> :t \x -> chr (ord '0' + x)
20:45:52 <lambdabot> Int -> Char
20:47:39 <haskelldude> lambdabot: can u pls show how to apply?
20:47:44 <ddarius> @hoogle Int -> Char
20:47:44 <lambdabot> Data.Char chr :: Int -> Char
20:47:44 <lambdabot> Data.Char intToDigit :: Int -> Char
20:47:45 <lambdabot> Data.ByteString.Char8 index :: ByteString -> Int -> Char
20:48:07 <parcs> ah, intToDigit
20:48:19 <parcs> haskelldude: import Data.Char and use intToDigit
20:48:37 <haskelldude> thanks again! :)
20:48:40 <haskelldude> it works
20:50:32 <mjk> how to display chinese string? for example, let str = "й" putStrLn str
20:51:19 <mjk> winXP
20:51:38 <mjk> on windows console
20:51:42 <haskelldude> in wat applications do u guys use haskell?
20:53:11 <mjk> i am learning haskell, and i test that haskell can display chinese string
20:54:54 <parcs> > "先秦兩漢"
20:54:54 <lambdabot>   "\20808\31206\20841\28450"
20:55:00 <Cale> haskelldude: The company I work for is writing a game for iPhones and other mobile devices in Haskell.
20:56:52 <monochrom> ÖÐ¹ú is clearly not chinese
20:57:21 <monochrom> in windows console, make sure you "chcp 65001" to switch to utf-8 first
20:57:30 <mjk> monochrom: yes, it's not chinese string, but it's chinese character
20:57:42 <monochrom> you have to do this for every console instance
20:57:50 <mjk> no
20:57:55 <mjk> i try it
20:58:00 <monochrom> not chinese character either
20:58:20 <monochrom> and then, the console font has tons of limitations. it doesn't even do some math symbols
20:59:20 <monochrom> observe that in recent linuxes putStrLn "\20808\31206\20841\28450" will give you 先秦兩漢 just fine
20:59:42 <mjk> but i can't find somewhere to modify the  chcp, my console only has cp936
21:00:03 <monochrom> poor you
21:00:32 <monochrom> what does cp936 do anyway?
21:01:07 <mjk> codepage is cp936
21:01:22 <monochrom> oh it's almost gb 2312? well there is no haskell lib for that either
21:01:47 <monochrom> there are haskell libs that do gb 18030 but I doubt your os can do that
21:02:17 <mjk> which libs?
21:02:28 <monochrom> http://hackage.haskell.org/packages/archive/encoding/0.6.6/doc/html/Data-Encoding-GB18030.html
21:03:34 <monochrom> but even if you get gb 18030 to work, the console font still misses everything
21:04:29 <mjk> monochrom: thank you very much! i try to install Data.Encoding.GB18030
21:05:27 <monochrom> lucida console doesn't do chinese
21:06:03 <monochrom> courier new doesn't either
21:06:12 <monochrom> I'm sorry your experiment is doomed to fail
21:06:29 <djahandarie> What you say?!?!
21:07:02 <dankna> okay so terminology time
21:07:09 <dankna> wait
21:07:10 <dankna> never mind
21:07:38 <monochrom> you can pull your hair and argue philosophically whether the program is outputting the right code or not all you want, but the console font will just be shooting blanks for you
21:08:33 <monochrom> anyway if your os can't do utf-8 there is no reason it can do gb 18030.
21:11:14 <isomorphic> all this time I thought utf-8 was just ascii for hipsters
21:11:53 <dankna> heh
21:12:02 <fengshaun> lol
21:13:53 <dankna> wouldn't it be for anti-hipsters because hipsters only like old things and UTF-8 is newer
21:14:35 <isomorphic> yeah, but we're talking about utf-8 - it's not very well known, you probably haven't heard of it.
21:14:41 <dankna> haha
21:14:46 <isomorphic> :P
21:15:06 <dankna> but it is =p
21:15:08 <dankna> but oh well
21:17:55 <monochrom> oh well, XP seems to support GB18030
21:18:54 <isomorphic> http://uncyclopedia.wikia.com/wiki/Haskell
21:19:35 <mm_freak_> what's the best way to convert a number of seconds from Double to NominalDiffTime?
21:20:04 <isomorphic> @type diffUTCTime
21:20:05 <lambdabot> Not in scope: `diffUTCTime'
21:20:05 <monochrom> I suspect realToFrac
21:20:33 <mm_freak_> oh, thanks
21:20:38 <mm_freak_> didn't know that function
21:27:35 <isomorphic> ... okay, so, I'm browsing uncyclopedia
21:27:40 <isomorphic> it says:
21:27:46 <isomorphic> in the C article
21:28:02 <isomorphic> This program demonstrates how easy it is to implement random number generator
21:28:11 <isomorphic> This program demonstrates how easy it is to implement random number generator
21:28:22 <isomorphic> unsigned random() {}
21:28:22 <dankna> paste not working?
21:28:25 <dankna> hahah
21:28:26 <dankna> nice
21:28:30 <isomorphic> (copy rather)
21:43:57 * hackagebot nemesis 2011.6.12 - a Rake like task management tool  http://hackage.haskell.org/package/nemesis-2011.6.12 (JinjingWang)
22:45:21 <hpaste> haskelldude pasted “recursion” at http://hpaste.org/47699
22:45:59 <haskelldude> pls look into http://hpaste.org/47699
22:46:12 <haskelldude> some tiny recursion issue..
22:46:42 <ddarius> Woo, chrisdone has reimplemented the hlint functionality.
22:47:12 <ddarius> Look at the types of the operations you are using.
22:56:01 <edwardw> I'd like to install multiple versions of GHC and/or Haskell Platform and switch between them
22:56:11 <edwardw> what's the best practice to do so?
22:56:34 <ddarius> Just do it.
22:56:42 <edwardw> Oh, I'd like to do it on os x
22:56:50 <edwardw> but how?
22:56:56 <edwardw> I used to use stow
22:57:40 <edwardw> but since haskell platform for os x is distributed as a .pkg, i'm not sure stow can handle that
22:57:40 <Jafet> Install them in different places...
22:58:37 <Jafet> I suppose you would have multiple cabal worlds, too
22:59:13 <edwardw> yeah, that. so can cabal handle this?
22:59:49 <Jafet> Just have different worlds for each GHC.
22:59:56 <dankna> edwardw: it's like this
23:00:16 <dankna> edwardw: you don't even need to use stow, because the package installs a .framework, which is inherently versioned
23:00:23 <dankna> (it contains multiple subdirectories and symlinks and stuff)
23:00:56 <dankna> edwardw: the only thing where you need to be slightly careful is in the /usr/bin symlinks that the .pkg creates, which will always point to the version that the "Current" symlink inside the .framework points to.
23:01:37 <dankna> edwardw: you do need to be slightly careful with your ~/.cabal/config, making sure that it has $compiler in the install-dirs prefix path somewhere
23:02:01 <dankna> (I personally use "install-dirs global\n  prefix: /usr/local/cabal/$compiler")
23:02:19 <dankna> (by putting it in its own subdirectory of /usr/local/, it doesn't interfere with my stow packages)
23:02:46 <dankna> also, good for you for wanting to test this case; I was beginning to think I was the only one who cared about it
23:03:04 <edwardw> lol
23:03:28 <edwardw> dankna, thanks for sharing this. i'll go with haskell platform then
23:03:29 <dankna> note that mixing .framework GHCs and non-.framework GHCs is more difficult, so if you have any versions that you built yourself, you'll want to follow the directions in the source-tree README to build the actual .pkg and install from that
23:03:31 <dankna> np
23:04:56 <blackdog> i'm having a bit of a yesod problem - parseRoutes seems to break on yesod-examples
23:05:20 <blackdog> i get "parse error: incorrect indentation" on a quasiquoted value
23:07:57 <blackdog> it's a bit of a baffling error - does that mean that the actual code has an indentation error, or that the generated code does?
23:08:08 <dankna> fair question
23:08:12 <dankna> probably the actual?
23:08:21 <dankna> never used yesod, so can't be much help
23:11:56 <haskelldude> how to assign a value returned from a pure function, into a name in a IO program? (inside do)
23:12:12 <dankna> you have two choices
23:12:19 <dankna> foo <- return bar
23:12:22 <dankna> let foo = bar
23:12:38 <dankna> (this is not a "let expression" that needs an "in" part, but a "let statement" that's part of the do-notation)
23:12:39 <haskelldude> tried let foo = bar x y z
23:12:55 <dankna> should have worked; hpaste your entire do-block and I'll tell you why it didn't
23:14:35 <hpaste> haskelldude pasted “pure functions inside do” at http://hpaste.org/47700
23:15:25 <blackdog> well, that was colossally annoying. shifting it out to a file and using parseRoutesFile with the same thing seems to work.
23:15:32 <dankna> weird, blackdog
23:15:42 <dankna> haskelldude, what's the error message?
23:15:51 <haskelldude> dankna: i have omitted value assignments for num, base  and newbase
23:16:12 <haskelldude> Type error in application *** Expression     : convertToAny num base newbase *** Term           : newbase *** Type           : [Char] *** Does not match : Int
23:16:16 <dankna> I really wanted to see it exactly as it was in the real source, since the most likely problem is indentation
23:16:24 <dankna> well
23:16:33 <dankna> it's saying you got the parameters to convertToAny wrong
23:16:42 <dankna> which has nothing to do with the fact that it's inside a let-statement
23:16:55 <hpaste> haskelldude pasted “pure functions inside do” at http://hpaste.org/47701
23:17:22 <ddarius> haskelldude: Ugh, don't use Hugs.
23:17:47 <haskelldude> ddarius: hehe why's dat?
23:17:49 <dankna> :t convertToAny
23:17:50 <lambdabot> Not in scope: `convertToAny'
23:17:55 <dankna> @hoogle convertToAny
23:17:55 <lambdabot> No results found
23:17:59 <ddarius> Because Hugs sucks.
23:18:00 <dankna> this is a function you wrote?
23:18:04 <dankna> check its arguments, heh
23:18:48 <dankna> it's saying you're passing it a string when it wants an int
23:18:54 <haskelldude> dankna: ooops i figured it out, getLine returns strings! duh
23:18:59 <dankna> yes
23:20:44 <hpaste> Ron pasted “List Monad == List Comp?” at http://hpaste.org/47702
23:20:49 <RonCol`> Reading the haskell chapter in seven langs, it was talking about a list being a monad (which was confusingly circular, seing as it was wrapped in a list etc), and gave the cartesian example. Is he hinting/saying that this is how list comprhensions work?
23:21:09 <haskelldude> is "Last generator in do {...} must be an expression" caused by bad indentation?
23:21:30 <dankna> often
23:24:29 <chrisdone> haskelldude: Usually when you have a bind in the last expression. do { x; y; z <- … }
23:25:04 <chrisdone> (Er, the last statement.)
23:29:34 <haskelldude> chrisdone: i have num <- getLine as the last statement
23:30:34 <chrisdone> There's your problem. The last statement in a do expression must be an expression. http://www.haskell.org/onlinereport/exps.html#sect3.14
23:47:19 <haskelldude> is there a way to clear screen?
23:47:51 <shachaf> No. It's an impossible task, sadly.
23:48:02 <Jafet> With a degausser?
23:48:22 <chrisdone> Heh.
23:48:44 <shachaf> The screen-clearing problem is well known to be equivalent to the halting problem.
23:49:04 <haskelldude> O_O
23:49:24 <haskelldude> k no probs
23:49:43 <mjrosenb> haskelldude: clear what screen?
23:50:26 <chrisdone> haskelldude: One of the curses libraries will let you do that in a console.
23:51:00 <shachaf> haskelldude: Of course, it might be possible in particular cases, just like the halting problem. E.g. putStr "\ESC[H\ESC[J" might do it.
23:51:32 <mjrosenb> or if you want to do it manually, ^Zclear;fg
23:51:53 <Jafet> Even a Turing oracle will not let you clear screens! Whatever that means.
23:52:10 <shachaf> You could dump the program state into a file, reboot, and then resume.
23:52:37 <mjrosenb> just don't dump it into /tmp
23:53:09 <shachaf> Right, use /var/tmp.
23:54:55 <chrisdone> https://github.com/rstacruz/js2coffee
23:55:26 <chrisdone> I wonder if I can do the same thing but JS→HJScript, like https://github.com/chrisdone/amelie/blob/8c6a3dc0453cb5a5cda5efa643c42f05e50e378b/src/Amelie/View/Script.hs
23:56:50 <Jafet> Hmm
23:57:00 <Jafet> "JavaScript has always had a gorgeous object model at heart"
23:57:13 <Jafet> Then they show a bunch of code that looks like Python
