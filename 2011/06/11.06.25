00:00:31 <xarch_> what would the functor which turns a functor into an applicative functor would look like?
00:00:32 <lambdabot> xarch_: You have 1 new message. '/msg lambdabot @messages' to read it.
01:04:16 <iwtu> hi! I need a hint. What is a good way to define data structure Trie?
01:04:48 <Botje> how do you measure 'good'?
01:05:09 <Cale> iwtu: data Trie = Leaf | Branch (Map Char Trie)
01:05:13 <Botje> keystrokes? performance? carbon output? :)
01:06:23 <iwtu> Cale: why I need the Map?
01:07:02 <Cale> iwtu: What would you rather use?
01:07:05 <elliott> Cale: that Map seems like overhead
01:07:16 <elliott> Cale: well, if you are only handling binary data
01:07:19 <iwtu> Botje: Sorry, my mistake. let's start with any :)
01:07:25 <elliott> then I'd use a huge constructor :)
01:07:35 <elliott> since that basically mimics the C way of doing it
01:07:35 <Cale> Well, I'm assuming he wants a Trie of Char values.
01:07:42 <elliott> ofc an array may be less ugly to code with :P
01:07:43 <Botje> well, if you measure 'time to implement', Map is the fastest
01:07:48 <iwtu> Cale: correct
01:08:04 <Cale> A binary trie is the same thing as a binary tree.
01:08:16 <Botje> well, no, Data.Trie would be the fastest >:)
01:08:26 <iwtu> I want to programming Aho-Corasick. I did it in C++, now I want in Haskell
01:08:53 <Cale> iwtu: What structure did you use to represent the branching in C++?
01:10:20 <elliott> iwtu: btw http://hackage.haskell.org/cgi-bin/hackage-scripts/package/list-tries
01:10:21 <Botje> wow, that is one cool algorithm.
01:10:50 <iwtu> vector< map<char,int> > statues;
01:12:53 <littlebobby> I'm just taking a look at haskell right now and I already find it very amusing that in this channel all the lines so far are pretty... terse ;-)
01:16:28 <Botje> littlebobby: welcome aboard!
01:16:43 <iwtu> :)
01:17:41 <littlebobby> Botje, arrr, I hope that "haskell road to logic..." isn't too daunting for me. my lacking mathematical background makes me a little bit sad
01:17:48 <elliott> ?pl I'm just taking a look at haskell right now and I already find it very amusing that in this channel all the lines so far are pretty... terse ;-)
01:17:49 <lambdabot> (line 1, column 85):
01:17:49 <lambdabot> unexpected reserved word "in" or "i"
01:17:49 <lambdabot> expecting variable, "(", operator or end of input
01:17:53 <elliott> darn
01:18:34 <littlebobby> :-)
01:19:23 <Cale> iwtu: Basically, the Map is a cute way to represent the branching at each node. You could also just use an Array, but to represent all possible Char values, the arrays get kinda large.
01:20:35 <iwtu> list set with key? like std::map
01:20:43 <iwtu> ?
01:20:55 <Cale> Map is a finite map from keys to values.
01:21:26 <iwtu> yeah. it is pretty cool :)
01:23:23 <iwtu> I am not sure how to work with it. can you give me example how insert some word in the strucutre?
01:24:35 <sipa> @hoogle insert
01:24:36 <lambdabot> Data.HashTable insert :: HashTable key val -> key -> val -> IO ()
01:24:36 <lambdabot> Data.IntMap insert :: Key -> a -> IntMap a -> IntMap a
01:24:36 <lambdabot> Data.IntSet insert :: Int -> IntSet -> IntSet
01:26:00 <elliott> iwtu: did you see the list-tries library I linked, btw?
01:26:09 <elliott> it would save you implementing all the trie operations yourself
01:35:20 <iwtu> elliott: yes. But I think I need to practise :)
01:35:43 <elliott> :)
01:35:47 <iwtu> I am very familiar with Haskell yet but I like it :)
01:36:13 <iwtu> it seems to be a good exercise
01:37:53 <Botje> haskell strechtes the brain
01:37:59 <Botje> often to the point of skullsplosion :)
01:38:11 <ski> elliott : `@remember' ?
01:38:21 <elliott> ski: ?
01:39:44 <iwtu> I like it! :) But I will need a little help.
01:40:49 <ski> elliott : you `pl'ed a line of natural language above ..
01:41:07 <iwtu> in my logic insertTree (x:xs) Branch = Branch (Map x (insertTrie xs)
01:41:20 <iwtu> where am I wrong
01:41:23 <elliott> ski: it was intentional :-)
01:41:26 <elliott> I was trying to make it more terse.
01:41:37 <ski> aah
01:43:10 <ski> @hoogle k -> a -> Map k a -> Map k a
01:43:10 <lambdabot> Data.Map insert :: Ord k => k -> a -> Map k a -> Map k a
01:43:11 <lambdabot> Data.Map insertWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a
01:43:11 <lambdabot> Data.Map insertWithKey' :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a
01:43:35 <ski> iwtu : i think you possibly want to use `insert' ^
01:44:11 <ski> also, you don't want `insertTree (x:xs) Branch = ...' but `insertTree (x:xs) (Branch map) = ...'
01:45:57 <iwtu> I would like to program it. can you make me traversal over trie? I suppose it was enough to me to make a rest
01:47:25 <ski> well, you seemed to have a good start ..
01:47:46 <ski> (assuming you're pretty new to Haskell)
01:48:03 <iwtu> so insertTrie (x:xs) (Branch map) = Branch (map x insertTrie xs (Branch map) is correct?
01:48:27 <iwtu> ski your assumption is correct! :)
01:49:18 <ski> you have too many `map's and `Branch'es in the definiens
01:49:34 <ski> also, the order of the things there aren't quite right
01:49:36 <elliott> ski: please don't make people shadow map :(
01:50:00 <ski> elliott : heh, i didn't even notice :)
01:50:10 <elliott> that will lead to _fun_ type errors :)
01:50:25 <ski> well, not right now, i think
01:50:30 <iwtu> i have notice but it didn't look so odd :)
01:50:30 <ski>   insert :: Ord k => k -> a -> Map k a -> Map k a
01:51:05 <elliott> iwtu: suggest "m" instead of "map" :)
01:51:35 <ski> iwtu : ^ that means that the operation `insert' (a function) takes an argument of type `k' (which must have an ordering defined on it), an argument of type `a', an argument of type `Map k a', and returns a result of type `Map k a'
01:52:18 <ski> in your case, you have `Map Char Trie', so `k' will be `Char' and `a' will be `Trie'
01:52:28 <ski> so in your particular case, you get
01:52:46 <ski>   insert :: Ord Char => Char -> Trie -> Map Char Trie -> Map Char Trie
01:53:01 <ski> since we already know that `Char' is an ordered type, we can simplify this to
01:53:07 <ski>   insert :: Char -> Trie -> Map Char Trie -> Map Char Trie
01:53:33 <absence> is there a shorter way to express (a =<< b) in applicative form than (join $ a <$> b)?
01:54:00 <iwtu> I am not clear about Map. U understand Char, my type Trie but Map ...
01:54:02 <ski> so, you can call `insert' with a `Char' argument, a `Trie' argument and a `Map Char Trie' argument, getting back an updated `Map Char Trie'
01:54:23 <ski> iwtu : do you know about lists and tuples ?
01:54:44 <iwtu> I do
01:54:52 <elliott> absence: that isn't really applicative, it only works on monads because of join
01:54:59 <elliott> so... no
01:54:59 <ski> absence : not unless you define an operation doing that
01:55:02 <elliott> one monadic function, one applicative function
01:55:05 <elliott> not gonna get simpler than that
01:55:12 <elliott> ski: such an operation exists: (=<<)
01:55:43 <ski> hum .. oh, i was for some reason thinking on a different case :)
01:56:12 <ski> anyway, actually `(<$>)' is not idiomatic but functorial :)
01:56:40 <ski> iwtu : you can think of `Map Char Trie' as roughly an association list of type `[(Char,Trie)]'
01:56:57 <ski> iwtu : so a list of pairs, associating `Char's with `Trie's
01:57:00 <ski> @type lookup
01:57:01 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
01:57:49 <ski> is a standard function for searching an association list, given a "key" of type `a', returning (`Just') the first "value" of type `b' in a pair having that key (or `Nothing' if none exists)
01:58:12 <ski> iwtu : so `Map Char Trie' is basically like that, but more efficient (not using a list internally)
01:58:22 <ski> iwtu : does that make sense ?
01:59:01 <iwtu> insertTrie (x:xs) (Branch m) = Branch(m x (insertTrie xs ???) ?
01:59:13 <absence> ski: what does it mean that it's functorial but not idiomatic?
01:59:24 <iwtu> Map if a function?
01:59:41 <elliott> ski: i think you may be trying to introduce too many concepts at once to iwtu :p
02:00:29 <ski> absence : i used "functorial" as meaning "being an operation related to `Functor's" and "idiomatic" as meaning "being an operation related to idioms / `Applicative' functors" :)
02:01:26 <iwtu> can you program to insert and then I will ask? :)
02:01:32 <ski> iwtu : `Map' is not a function, `Map' is a *type*-function, just like `[]' (pronounced "list-of") and `Array' ("array, indexed by ..., of ...")
02:02:04 <ski> the declaration
02:02:06 <ski>   data Trie = Leaf | Branch (Map Char Trie)
02:02:15 <ski> means that there's two possible shapes for `Trie's
02:02:33 <ski> one shape is `Leaf', which is therefore just a constant `Trie'
02:02:46 <ski> the other shape is `Branch m', where `m' is an `Map Char Trie'
02:03:22 <ski> so, *if* `m' is of type `Map Char Trie', then `Branch m' "wraps" it into a new `Trie'
02:03:26 <iwtu> it's clear except `Brach m' but continue :)
02:03:56 <iwtu> clear except Map
02:04:02 <iwtu> continue
02:04:05 <ski> and when you write `insertTrie (x:xs) (Branch m) = ...' you're handling the case when the second argument to `insertTrie' was a `Trie' that was constructed like `Branch m'
02:05:05 <iwtu> just note. have the ` ' some meaing?
02:05:11 <ski> so, if you pass a `Trie' as second argument to `insertTrie', it will be pattern-matched with `Branch m', and if the matching succeeds (which happens if the `Trie' was not another case, i.e. `Leaf'), then `m' will become the `Map Char Trie', that this `Trie' was built from
02:05:31 <ski> i just use "`" and "'" to quote code
02:05:59 <ski> now, you've written
02:06:04 <ski>   insertTrie (x:xs) (Branch m) = Branch(m x (insertTrie xs ???)
02:06:36 <ski> the definiens (the right-hand-side) here is of the form `Branch (...)', so it is constructing a `Trie'
02:07:01 <absence> ski: ahh, i see what you mean. it's not really applicative style until there are more parameters with <*>
02:07:20 <ski> and if `Branch' is used to construct it, the argument of `Branch' must be a `Map Char Trie'
02:07:45 <ski> so the `...', i.e. your `m x (insertTrie xs ???' is *supposed* to be a `Map Char Trie', for this to work out correctly
02:07:51 <ski> iwtu : do you follow ?
02:08:07 <iwtu> wait a little
02:08:30 <iwtu> yeach, it is clear
02:08:32 <ski> absence : *nod*
02:08:34 <ski> ok
02:09:13 <iwtu> but I don't know how to right it. I have many thinks clear but I don't know to write them
02:09:14 <ski> iwtu : now, the trouble is that your `m x (insertTrie xs ???' actually is *not* a `Map Char Trie'
02:09:28 <ski> in fact, it's nothing at all, since it doesn't type-check :)
02:09:34 <ski> ok
02:09:42 <ski> let's take a step back, again, to
02:09:49 <iwtu> :D
02:09:56 <ski> insertTrie (x:xs) (Branch m) = Branch (..x..xs..m..)
02:10:20 <ski> do you agree that you want to construct a new `Branch'-shaped `Trie', in this case ?
02:10:35 <ski> (if not, the `Branch' to the right of `=' has to go, as well)
02:11:11 <iwtu> wait a bit. I am realizing what I want
02:11:17 * ski smiles
02:13:27 <iwtu> I have a Trie. To insert in the trie it means insert new char a trie to map if it does not exist
02:13:30 <iwtu> right?
02:14:24 <iwtu> if exits then just contine by existing branch
02:14:25 <ski> yes
02:14:55 <iwtu> I don't know how but I suppose that Map makes it
02:15:34 <ski> @hoogle k -> a -> Map k a -> Map k a
02:15:34 <lambdabot> Data.Map insert :: Ord k => k -> a -> Map k a -> Map k a
02:15:35 <lambdabot> Data.Map insertWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a
02:15:35 <lambdabot> Data.Map insertWithKey' :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a
02:15:39 <ski> @hoogle+
02:15:39 <lambdabot> Data.Map insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
02:15:39 <lambdabot> Data.Map insertWith' :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
02:15:39 <lambdabot> Data.Graph.Inductive.NodeMap delMapNode :: (Ord a, DynGraph g) => NodeMap a -> a -> g a b -> g a b
02:16:37 <iwtu> insertTrie (x:xs) (Branch m) = Branch (..x..xs..m..) so this is clear
02:16:44 <iwtu> but how to write it
02:18:35 <ski> yes, so `Branch (..x..xs..m..)' will be a `Trie' if you complete the `..x..xs..m..' to be a `Map Char Trie' which `Branch' can construct the `Trie' from
02:19:04 <ski> so, you need to decide what (new) `Map Char Trie' you want to compute
02:19:10 <ski> you already have
02:19:18 <ski>   x  :: Char
02:19:25 <ski>   xs :: [Char]
02:19:30 <ski>   m  :: Map Char Trie
02:19:33 <ski> to play with
02:19:49 <iwtu> to play :)
02:19:58 <ski> yeah :)
02:20:10 <ski> so, you have the first character, and a list of the rest of them, and you have the old `Map Char Trie'
02:20:12 <iwtu> Char must be x
02:20:28 <ski> yes, `x :: Char' means that `x' is a `Char'
02:21:08 <ski> you mentioned
02:21:13 <ski> <iwtu> I have a Trie. To insert in the trie it means insert new char a trie to map if it does not exist
02:21:16 <iwtu> we insertex x and now move to next step
02:21:16 <ski> <iwtu> if exits then just contine by existing branch
02:22:02 <ski> you must insert both a key of type `Char' and a value of type `Trie' into the `Map Char Trie'
02:22:13 <ski> that's how `Map's work
02:22:35 <iwtu> curious thatI can speak english. you undertand me for me reason...
02:23:16 <ski> (btw, you might want to consider again your type of `Trie's, to check that it seems ok to you)
02:23:41 <ski>   data Trie = Leaf
02:23:44 <ski>             | Branch (Map Char Trie)
02:24:41 <iwtu> how to continue by next branch?
02:24:54 <iwtu> that's problem I have
02:25:46 <iwtu> I cannont catch it
02:25:50 <ski> well, there's several operations on `Map's
02:26:19 <ski> e.g. if you look at <http://www.haskell.org/ghc/docs/latest/html/libraries/>, following `Data.Map' to <http://www.haskell.org/ghc/docs/latest/html/libraries/containers-0.4.0.0/Data-Map.html#v:lookup> e.g., you'll see descriptions for the
02:26:38 <ski> @hoogle Map k a -> k -> Maybe a
02:26:38 <lambdabot> Data.Map lookup :: Ord k => k -> Map k a -> Maybe a
02:26:38 <lambdabot> Data.Map (!) :: Ord k => Map k a -> k -> a
02:26:38 <lambdabot> Data.Map lookupIndex :: Ord k => k -> Map k a -> Maybe Int
02:26:42 <ski> operation
02:26:54 <ski> (`lookup', aka `(!)', i.e.)
02:27:37 <ski> so, you can use `lookup' to check which (if any) `Trie' is currently associated with a particular `Char' in your `Map Char Trie'
02:28:24 <ski> you can use e.g. `insert' to insert a new `Char', associated with a `Trie', into the `Map Char Trie'
02:28:32 <ski> so, you have some operations you can use
02:28:43 <ski> what you have to do is decide which to use, and in what order
02:28:57 <ski> and maybe you want to check some conditions
02:29:24 <ski> iwtu : so, you can continue to the next branch by using `lookup'
02:30:26 * ski figures iwtu is busy trying something out in the code :)
02:31:57 <Cale> Yeah, yeah, I should have thought that type through a little more
02:31:59 <iwtu> I am just thinking how to use lookup :)
02:32:06 <Cale> (perhaps)
02:32:39 <ski> iwtu : `lookup' will give you back an `Maybe a'. in your case `a' is `Trie', so a `Maybe Trie'
02:32:43 <ski> @src Maybe
02:32:43 <lambdabot> data Maybe a = Nothing | Just a
02:33:03 <ski> a `Maybe Trie' is either a `Nothing', or a `Just a' where `a' is a `Trie'
02:33:53 <ski> so, either you're getting a new `Trie' back (wrapped in `Just'), at the end of the branch "labeled" by the `Char', or there was no `Trie' there, and you get `Nothing'
02:34:13 <iwtu> It it returns Nothing I still have to insert and build a new branch
02:34:25 <ski> that seems likely, yes
02:35:34 <ski> consider that you want to represent a `Trie' containing the strings `"foo"', e.g.
02:35:47 <ski> how would that `Trie' look like ?
02:36:02 <ski> (just as an example, to have something concrete to think about)
02:36:04 <iwtu> is it very hard to program that? I think I am in phase that would be better examine the code and ask what won't clear
02:36:21 <ski> you can of course draw the `Trie' on paper, in a nice tree-picture
02:36:42 <iwtu> nice tree picture :)
02:36:58 <ski> iwtu : i'm not talking at the moment how to program anything -- just to imagine how a `Trie' could look like :)
02:37:19 <ski> so the string `"foo"' is actually a list of characters
02:37:25 <ski>   ['f','o','o']
02:37:32 <iwtu> 4 linear nodes :)
02:38:06 <ski> yeah, so should the `Trie' be a `Leaf'-shaped `Trie', or a `Branch'-shaped `Trie' ?
02:38:19 <iwtu> or 5 if I count the Leaf
02:38:24 <ski> (i mean the whole `Trie', here)
02:38:50 <iwtu> if it si trie so trie
02:39:10 <ski> well, the definition of the type of `Trie's
02:39:24 <ski>   data Trie = Leaf
02:39:25 <ski>             | Branch (Map Char Trie)
02:39:38 <ski> currently says that every `Trie' must be of one of two possible shapes
02:39:48 <ski> the `Leaf'-shape, or the `Branch'-shape
02:40:15 <ski> of course, if you don't like that, you can change the definition of the `Trie' type
02:40:31 <ski> but unless it's changed, that's what a `Trie' can be
02:41:01 <iwtu> I like definition this way. it is a quite naturally
02:41:35 <ski> iwtu : so i ask again, should the `Trie' containing just the string `"foo"' be a `Leaf'-shaped `Trie' (containing nothing more), or should it be a `Branch'-shaped `Trie' (containing a `Map Char Trie' inside) ?
02:42:37 <ski> iwtu : obviously, i'm just suggesting you to consider an example since i think it might help. if you already have some idea you want to think about or try out in the code for `insertTrie', you can think about that instead
02:42:53 <ski> i'm only suggesting what you might think of
02:43:38 <iwtu> I think that would be 5 nodes, 4 will have a trie and 5th leaf
02:43:50 <osfameron> morning
02:43:51 <ski> well, that sounds sensible
02:43:59 <iwtu> oh, 3 4
02:44:07 <osfameron> I've been thinking about zippers on *circular* lists - they seem problematic
02:44:11 <ski> eh, right :)
02:44:12 <iwtu> 4 nodes 3 has tries
02:44:45 <ski> right, three nodes for the three `Char'acters in the list (the string), and a final one to conclude the `Trie'
02:44:56 <Jafet> > cycle "Circular list ahead: "
02:44:57 <lambdabot>   "Circular list ahead: Circular list ahead: Circular list ahead: Circular li...
02:45:16 * osfameron googles and finds reference to SPJ's 2007 Oscon talk
02:45:46 <ski> osfameron : yes, zippers on circular structures are problematic (regardless of whether you have actual cyclic data, or only non-cyclic data *representing* cyclic values)
02:46:14 <ski> iwtu : so, is the first node a `Leaf' or a `Branch' ?
02:47:04 <osfameron> ski: is there a good alternative to them for cyclic structures?  for example, something as simple as a compass rose (north,east,south,west)
02:47:23 <osfameron> (obviously once you get to mutating a value, it gets even more complex)
02:47:51 <iwtu> of course Branch!
02:47:58 <ski> osfameron : well, in the case of a graph, you *could* use some spanning tree. but there has to be some way to make sure you can continue "around the cycles"
02:48:03 <iwtu> leaf is always on the end
02:48:09 <ski> (:
02:48:16 <ski> so, it looks like
02:48:19 <ski>   Branch (...)
02:48:27 <ski> where `...' is a `Map Char Trie'
02:48:38 <iwtu> I am quite despair. I know that the things are easy but sometimes I am like now. Stupid
02:48:40 <Jafet> You could turn all your links into STRefs…
02:48:57 <ski> yeah, that's an alternative, of course
02:49:34 <ski> iwtu : let's consider how the `...' there must look, for our particular, simple, example, ok ?
02:49:52 <osfameron> for the compass rose example (non-mutable) it might be simpler to do a tying-the-knot thing and just model as a doubly linked list
02:50:16 * ski isn't really sure what osfameron means by "compass rose"
02:50:23 <iwtu> ok
02:50:36 <osfameron> ski: ah, that's North, East, South, West
02:50:42 <ski> so, we want a `Trie' containing just `"foo"'
02:50:46 <ski> it must look something like
02:50:50 <ski>   Branch (...)
02:51:07 <ski> where `...' is a `Map Char Trie', describing all the branches from the first node
02:51:22 <ski> how many branches should the first node have, in this case ?
02:51:42 <Jafet> What kind of cyclic structure is denoted by a compass rose?
02:51:57 * ski hopes iwtu doesn't think these questions are *too* simple/stupid :)
02:52:02 <iwtu> Branch( Map 'f' (Branch Map 'o' (Branch Map 'o' Leaf)
02:52:12 <osfameron> Jafet: North -> East (turning 90 degrees) -> South -> West -> North -> ...
02:52:13 <ski> osfameron : i second Jafet's question
02:52:25 <ski> iwtu : well, something like that
02:52:33 <ski> but you can't use `Map' inside values and expressions
02:52:35 <Jafet> In other words, walking along a square lattice.
02:52:41 <ski> `Map' belongs in the types
02:52:51 <osfameron> sorry, that was the simplest example of a circular list that came to mine, I should've explained what I meant better ;-)
02:52:58 <ski> we don't actually know here how a `Map Char Trie' looks like
02:53:13 <Jafet> Oh, I thought you were referring to something like a torus.
02:53:16 <ski> so, we can imagine that it's actually a `[(Char,Trie)]', for concreteness sake
02:53:18 <Jafet> With a square lattice on it
02:53:33 <Jafet> I've seen a knot tied on that on haskell-ml
02:53:50 <ski> iwtu : so in `Branch (...)' the `...' should then be a list of pairs of `Char's and `Trie's, each pair representing a branch
02:54:02 <ski> iwtu : how many pairs should be in this list ?
02:54:19 <iwtu> 3
02:54:23 <Jafet> (It was an unbounded square grid, but you can change that to a torus and make a read-only zipper the same way.)
02:54:30 <ski> so, you're saying we should have
02:54:41 <ski>   Branch [ ... , ... , ... ]
02:54:42 <ski> then ?
02:54:57 <osfameron> what's a torus?
02:54:57 <ski> this will be a `Trie' with three branches from the first node
02:55:11 <elliott> Has anyone used Data.Attoparsec.Enumerator before?
02:55:25 <ski> osfameron : a circle, squared. a donut, a coffee cup
02:55:39 <Jafet> Where a rectangle's edges wrap to the opposite side, you can say it's the surface of a torus
02:55:48 <osfameron> ah ok
02:56:01 * hackagebot scrypt 0.2.0 - Stronger password hashing via sequential memory-hard functions.  http://hackage.haskell.org/package/scrypt-0.2.0 (FalkoPeters)
02:56:24 <ski> so, continuing this, each element should be a pair
02:56:29 <iwtu> I am not sure waht you mean
02:56:45 <iwtu> if you write the pair it would be clear
02:56:50 <ski>   Branch [(..,..),(..,..),(..,..)]
02:57:23 <ski> each first component of the pairs should be a `Char', and each second component should be another `Trie'
02:57:54 <ski> (representing the child node of the `Trie' tree that we reach if the follow the branch labelled by the `Char' in the first component of that pair)
02:57:55 <iwtu> like that Branch( Map 'f' (Branch Map 'o' (Branch Map 'o' Leaf)
02:58:25 <ski> again, you can't use `Map' here, in expressions ?
02:58:32 <ski> s/ ?//
02:58:49 <ski> `Map' lives in type-land, and doesn't visit value-land
02:59:35 <ski> you have to use the basic shapes that a `Map Char Trie' can be (or e.g. other function calls, returning such `Map Char Trie's)
02:59:50 <ski> so, let's say we write
03:00:03 <ski>   Branch [('f',..),('o',..),('o',..)]
03:00:11 <iwtu> insertTrie returns (Map Char Trie)
03:00:13 <ski> would this be right or wrong ?
03:01:03 <ski> (assuming that a `Map Char Trie' is just a list of pairs, i.e. a `[(Char,Trie)]')
03:01:30 <iwtu> right then
03:01:47 <ski> ok, so then you've got a `Trie' with a starting node
03:01:48 <Jafet> osfameron: data Zipper a = Tag a (Zipper a) (Zipper a); zcycle xs = let n = length xs; wrap i = i+n `mod` n; tags = map (\i -> Tag (xs!!i) (tags!!wrap (i-1)) (tags!!wrap (i+1))) [0..n-1] -- should work
03:01:57 <ski> this node has three distinct branches
03:02:06 <ski> one labelled with `f'
03:02:10 <ski> one labelled with `o'
03:02:17 <ski> and another labelled with `o'
03:02:21 <Jafet> (Where “work” is produces a true cyclic list zipper.)
03:02:36 <ski> then, each of these branches will need it's own sub-tree
03:02:47 <ski> i.e. three new `Trie's
03:02:54 <hpaste> absence pasted “are there better ways to express this function?” at http://hpaste.org/48303
03:03:01 <ski> iwtu : does that sound right ?
03:03:08 <osfameron> Jafet: ooo! I'll have to work through that to try to understand it
03:03:57 <Jafet> Er… in head tags
03:04:08 <iwtu> no always new Trie. Unless the key - char doesn't exist
03:04:13 <osfameron> Jafet: head tags?
03:04:35 <absence> oh.. what hpaste said :D http://hpaste.org/48303
03:04:52 <Jafet> let … in head tags
03:05:51 <ski> osfameron : the trouble with using (normal immutable) truly cyclic datastructures is that if you change one node, then the "same place" down some cycle will still look like the old version, unless you hunt down each and every "same place"
03:06:01 <osfameron> ski: yes indeed
03:06:23 <osfameron> ski: and also that if you go 100 times round in one direction, then you have a zipper of 100x uselessly repeated lists in the other direction
03:06:36 <ski> iwtu : so, i was pushing a little here, to see if you would notice anything wrong or not
03:06:47 <Jafet> No, you shouldn't
03:06:54 <ski> iwtu : in fact,  Branch [('f',..),('o',..),('o',..)]  is completely wrong :)
03:07:15 <Jafet> Zippers can be cyclic, too.
03:07:31 <ski> iwtu : if you would make such a `Trie', it would represent some number of words starting with `f', some number of words starting with `o', and some number of words starting with `o'
03:07:40 <osfameron> Jafet: but a generic zipper would have that problem wouldn't it?
03:07:50 <ski> iwtu : but you only wanted a single word here, starting with `f' only
03:08:10 <ski> iwtu : so, therefore, this `Trie' should have only one branch from the main node, not three different branches
03:08:13 <Jafet> Depends on which generic zipper, I guess
03:08:15 <ski> iwtu : do you agree ? :)
03:08:22 <iwtu> I had realized that but I was not user
03:08:27 <iwtu> *sure
03:09:07 <iwtu> I don't. Branch[ ...] is odd in all way
03:09:22 <ski> Jafet : yeah, but if you map over an infinite value which happens to be cyclic, you'll probably not get an actualy cyclic value back (unless you take pains to ensure it)
03:09:56 <Jafet> It's impossible to ensure it anyway
03:10:24 <Jafet> Without taking StablePtrs, that is
03:10:40 <iwtu> if i may please. try to make insert. Then I will think, ask something it could be ok
03:11:01 <ski> iwtu : well, for the sake of being able to think about this, we're imagining that a `Map Char Trie' has general shape `[(c0,t0),(c1,t1),...]' where `c0',`c1',&c. are `Char's, one for each branch, and `t0',`t1',&c. are the corresponding sub-`Trie's you reach by following the respective brancg
03:11:10 <ski> anyway
03:11:19 <ski> we don't want
03:11:21 <ski>   Branch [('f',..),('o',..),('o',..)]
03:11:22 <ski> here
03:11:26 <ski> but rather something like
03:11:30 <ski>   Branch [('f',..)]
03:11:45 <ski> i.e. a single `Branch' labelled with the `f' `Char'acter
03:11:59 <ski> and then `..' should be the sub-`Trie' that we reach after following `f'
03:12:13 <ski> so, we want to be able to follow `f', then `o', and then `o' again
03:12:34 <ski> so, `..' should be a `Trie' -- `Leaf' or `Branch (..)' ?
03:12:53 <ski> well, since we want to follow another branch again, it can't be `Leaf', so we get
03:13:03 <ski>   Branch [('f',Branch [('o',..)])]
03:13:08 <ski> doing this again, we get
03:13:19 <ski>   Branch [('f',Branch [('o',Branch [('o',..)])])]
03:13:32 <iwtu> wait please
03:13:42 <iwtu> try to follow my mind
03:13:47 * ski waits
03:13:53 <iwtu> :)
03:14:21 <iwtu> how do channel knows what ski is doing? :)
03:14:29 <iwtu> anyway
03:14:37 <ski> so, would you like to change something in the above, maybe ?
03:16:05 <iwtu> insertTree (x:xs) (Branch m y t) = if (x == y then insert xs t else ...
03:16:20 <iwtu> do you know what am I trying?
03:16:34 <iwtu> just can't write it
03:16:35 <ski> well, i can maybe figure out !
03:17:08 <ski> `Branch m y t' is an invalid pattern for a `Trie'
03:17:14 <iwtu> yeach
03:17:16 <ski> `Branch m' is valid
03:17:26 <iwtu> but try to abstract my thoughs
03:17:28 <iwtu> :)
03:17:31 <ski> if `Map Char Trie' actually *was* `[(Char,Trie)]'
03:17:34 <ski> then you could write
03:17:42 <iwtu> and I need write my thoughs :)
03:17:44 <ski>   insertTree (x:xs) (Branch [(y,t)]) = ...
03:18:00 <ski> though you'd probably want
03:18:11 <ski>   insertTree (x:xs) (Branch ((y,t):branches)) = ...
03:18:16 <iwtu> please, Map, no [] :D
03:18:19 <ski> instead, to allow for more than one branch
03:18:28 <ski> yeah, this is just an "if"
03:18:33 <ski> now, you can't do that
03:18:59 <ski> you have instead to use `insert' and `lookup' and `member' and the other operations on `Map's
03:19:02 <iwtu> you are destrying me. you are good at it. don't you know that? :D
03:19:13 <ski> hehe
03:19:32 <iwtu> if lookup is not Nothing
03:19:33 <ski> so, you're trying to compare your `Char' `x' with another `Char' `y'
03:19:46 <ski> you can't do that directly, since you can't get at `y' directly
03:19:51 <ski> yes
03:19:57 <iwtu> contine by branch (is "by" right preposioiton)?
03:20:08 <ski> `lookup' will compare with all the `y's for you, and if none match, you get `Nothing'
03:20:20 <ski> i think it sounds ok
03:20:44 <iwtu> iwtu beg ski to wait agein :)
03:20:52 * ski waits
03:21:00 * ski fetches some nice hot tea
03:22:15 <iwtu> if lookup retruns no Just c, then just contine by branch. If lookup returns Nothing, insert the c and continue by branch
03:22:38 <ski> (s/no/an/)
03:22:40 <iwtu> * if lookup returns Just a
03:22:42 <iwtu> :)
03:22:54 <ski> ok, sounds fine to me
03:23:02 <iwtu> so!
03:23:06 <ski> how will you check what `lookup' returns ?
03:25:00 <osfameron> aha.  spj's example of ring-of-windows in xmonad is basically shunting elements from the beginning to the end (or vice versa) as you move around
03:25:13 <osfameron> so would probably be better expressed using a dequeue
03:25:35 <Jafet> Yeah, zippers are mostly a novelty…
03:26:23 <osfameron> I'm sure I remember someone here suggesting that Zippers were actaully a *fundamental* concept in FP
03:26:32 <ski> osfameron : yeah .. but how to handle arbitrary graphs, with possibly many cycles, possibly sharing parts of their paths with each other ?
03:26:57 <ski> well .. maybe they could *become* one
03:27:16 <osfameron> ski: yeah.  in general, FP data structures don't like being cyclic do they?
03:27:24 <Jafet> In the same way that unicorns are fundamental to little girls
03:27:25 <ski> (or at least better understood)
03:27:31 <iwtu> insertTrie (x:xs) (Branch m) = if (m.lookup x  != Nothing) then insertTree xs m.second else insert xs n.second where n = m.insert x
03:27:39 <osfameron> hence the usual representation of graphs as adjacency list, instead of nodes and pointers
03:27:44 <elliott> Jafet: I don't consider zippers a novelty
03:27:45 <iwtu> did you catch my thoughs?
03:27:48 <ski> @hoogle lookup
03:27:49 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
03:27:49 <lambdabot> Data.HashTable lookup :: HashTable key val -> key -> IO (Maybe val)
03:27:49 <lambdabot> Data.IntMap lookup :: Key -> IntMap a -> Maybe a
03:28:05 <Jafet> The fact is, you can't have one now, so it's not fundamental in any literal sense
03:28:05 <iwtu> doesn't matter at the moment
03:28:10 <ski> iwtu : `m.lookup x' is bad, `lookup x m' is good (check the order of arguments just above)
03:28:14 <elliott> Jafet: For a start, the derivative of a type just _has_ to be an incredibly deep concept :-)
03:28:18 <elliott> Jafet: what do you mean can't have one now?
03:28:19 <iwtu> did  you catch?
03:28:23 <ski> iwtu : `!=' should be `/='
03:28:34 <osfameron> you can have a zipper on any Traversable structure can't you?
03:29:12 <iwtu> but did you catch? I wrote the though. Though was in the begging. Then we can write into the Haskell :)
03:29:33 <ski> iwtu : also, you'll have to replace `m.second' and `n.second' by something
03:29:49 <ski> iwtu : i'm sorry, i'm auto-correcting as i'm reading :)
03:30:16 <Jafet> elliott: sure it is. It's just a bit awkward to use for programming.
03:31:03 <ski> iwtu : but yes, it's more or less ok. still you have to fix the exact syntax for doing thing. *and* i think there's some additional things to fix, as well
03:31:16 <ski> iwtu : but it'll suffice to continue working on, i think :)
03:31:42 * iwtu works
03:32:00 <osfameron> Jafet: though zippers are the only real answer to "how do I use doubly linked lists in in pure FP?" (which is a valid question if you want something with the features of a doubly linked list)
03:32:05 <ski> of course `m.insert x' has to be corrected as well
03:32:06 <elliott> Jafet: I dunno, list and tree zippers are one of the most useful things in functional programming IMO
03:32:16 * iwtu iwtu thinks help command is very useful :P
03:32:35 <Jafet> Hm, can't remember the last time I needed a doubly-linked list for anything
03:32:57 * Jafet waits for the obligatory DLX salesperson
03:33:27 <ski> osfameron : btw, the "adjacency list"-representation is basically simulating a little imperative mutable memory, with pointers :)
03:33:55 <osfameron> ski: heh, I guess it is
03:34:01 <augur> Cale: i feel like the matroid/greedoid thing is related to greedy algorithms in the other direction -- if theres a greedy algo then its a greedoid, and which one is easy
03:34:07 <augur> but to construct the greedoid you have to first know the greedy algorithm
03:34:21 * osfameron likes the node representation much more, if you're working in a mutable language
03:34:36 <augur> you cant figure out the greedoid structure and from that work out the algo because the algo is almost explicit in the structure
03:34:43 <ski> elliott : yeah, derivatives correspond to one-(element-)hole contexts
03:35:00 <iwtu> ski: and what is type-funcion?
03:35:14 <Cale> augur: Well, it's a characterisation, it's not magic ;)
03:35:22 <augur> :P
03:35:30 <augur> folds are magic tho!
03:35:36 <ski> iwtu : consider e.g. the type `Int', which has values like `42' and `17'
03:36:03 <ski> iwtu : now consider the type `Maybe Int', which has values like `Just 42',`Nothing' and `Just 17'
03:36:07 <augur> folds : structural recursion :: ? : greedy algorithms
03:36:28 <elliott> <Jafet> Hm, can't remember the last time I needed a doubly-linked list for anything
03:36:32 <elliott> moving along a tape a la turing machine
03:36:43 <ski> iwtu : again, consider the type `Maybe (Maybe Int)' with values like `Nothing',`Just (Just 42)',`Just Nothing',`Just (Just 17)'
03:36:43 <elliott> a list zipper makes that incredibly elegant
03:36:52 <ski> iwtu : i think you get the picture
03:37:33 <ski> iwtu : given any type `t', the type `Maybe t' has basically the same values as `t', but wrapped in a `Just'-wrapper. also there's one additional value, the `Nothing' value
03:37:56 <ski> iwtu : `Maybe' itself is a type *function*, given any type `t' at all, it makes a new type `Maybe t'
03:38:33 <ski> iwtu : compare this with the type `Int' of integers, the type `[Int]' of lists of integers, the type `[[Int]]' of lists of lists of integers
03:39:00 <ski> iwtu : `[...]' is also a type function, that given any type `t', makes the type `[t]' of lists of elements of type `t'
03:39:50 <osfameron> elliott: heh, yes indeed
03:39:53 <iwtu> then it should be [] t, shoudn't?
03:39:54 <Jafet> elliott: try modifying the tape and watch your mut time drop off
03:40:01 <ski> iwtu : you can also note that `[[Int]]' is actually syntactic sugar for `[] ([] Int)', so you can say that this type function is really named `[]' (don't confuse this with the empty list *value* `[]', which just *happens* to be written in the same way
03:40:05 <ski> )
03:40:14 <jmcarthur> iwtu: that also works. the wrapping syntax is just sugar
03:40:22 <elliott> Jafet: eh?
03:40:25 <elliott> modifying the tape is easy
03:40:25 <ski> iwtu : yeah, `[] t', but since this is a very common case, it's nice to have the `[t]' sugar
03:40:36 <elliott> negate first element --> (xs,y:ys) -> (xs,not y:ys)
03:40:46 <osfameron> the one time I tried to implement a turing machine, I "invented" the zipper ;-)  only time I've ever done a "You could have invented <some clever FP construct>" ;-)
03:41:02 <ski> iwtu : you can also note that the type `(Char,Trie)' actually can be written like `(,) Char Trie', here `(,)' is another type function
03:41:23 <ski> iwtu : all clear ?
03:41:59 <iwtu> ski beg you to wait. I think I will be in a minute
03:42:09 * ski waits, fixes more tea
03:42:20 <jmcarthur> ski has broken tea
03:42:46 * Jafet breaks the no tea
03:43:20 <ski> > fix tea
03:43:21 <lambdabot>   yummy !
03:43:28 <nus> > fix ?tea
03:43:28 <lambdabot>   mueval-core: internal error: PAP object entered!
03:43:28 <lambdabot>      (GHC version 6.12.3 f...
03:43:42 <ski> that's interesting
03:43:47 * osfameron realises spj is saying "focusPrev" and not "focusFree".  For some reason I pronounce "prev" as "preh-v" instead of "preev" (but now that he says it, "preev" is more sensible)
03:44:41 <ski> osfameron : i was pondering how to do something similar to the (de)queue "shunting" of elements from one side of the cycle to the other, for general graphs ..
03:45:22 <osfameron> ski: even thinking about how much it would make my head hurt to try to figure that out, is making my head hurt ;-)
03:45:42 <ski> .. but it's not clear to me how to do this in a good way, in case several cycles share parts of their path
03:46:09 <ski> also do you shunt over all the cycle to the other side -- probably it's better to only shunt half of it over
03:46:49 <ski> ideally one should be able to traverse the graph, while modifying the contents of nodes, and even changing the graph topology, with cycles handled in a transparent fashion
03:47:03 <Jafet> elliott: but the evaluator has to allocate a new tag on every step
03:47:13 <iwtu> ski: can you give me a some exercise to be sure if I understand?
03:47:19 <osfameron> Jafet: what do you mean by a "tag" ?
03:47:49 <Jafet> The little thing you use to pull up a zipper
03:47:52 <elliott> Jafet: oh noes
03:47:55 <osfameron> ah
03:47:58 <ski> Jafet : i suspect you want uniqueness types here ?
03:48:08 <Jafet> Oh, I guess it's called the cursor.
03:48:10 <elliott> Jafet: that's a fact of haskell :P
03:48:17 <Jafet> elliott: it doesn't have to be!
03:48:23 <ski> iwtu : well, to make sure if you understand what ? :)
03:48:30 <osfameron> Jafet: you would just create a new tag, pointing at the existing left and right lists
03:48:31 <jmcarthur> Jafet: an imperative evaluator has to do basically the same thing, although it's more likely to be on the heap or in registers. with constructor specialization, ghc might actually get about the same thing
03:48:34 <elliott> Jafet: you can avoid it ... if you want your entire program to be a huge ball of pain
03:48:35 <ski> iwtu : how to call `insert' and `lookup' ?
03:48:53 <jmcarthur> *on the stack (not heap)
03:48:53 <ski> iwtu : how to check the result of `lookup', whether it's `Nothing' or `Just t' ?
03:49:00 <ski> iwtu : something else ?
03:49:25 <iwtu> ski: if I understand type function :)
03:49:31 <ski> (elliott : .. what's a fact of Haskell ?)
03:49:38 <Jafet> What do you mean by constructor specialization, jmcarthur?
03:49:39 <ski> iwtu : ah, ok
03:49:47 <elliott> ski: allocating constructors
03:49:58 <elliott> ski: when transforming data structures
03:50:11 <ski> iwtu : how many values does the type `Maybe (Maybe Bool,Bool)' have ?
03:50:50 <ski> (you can write that type like `Maybe ((,) (Maybe Bool) Bool)', if you want to see it in unsugared form)
03:51:01 * ski prefers honey to sugar
03:52:39 <jmcarthur> well okay, constructor specialization is unlikely to eliminate the new cons node i think
03:52:48 <jmcarthur> just the Zipper constructor
03:52:59 <jmcarthur> by constructor specialization i meant -fspec-constr
03:53:18 <iwtu> Bool, Just Bool, Nothing, (Just Bool, Bool), (Nothing, Bool), Just (Just Bool, Bool), Just (Nothing, Bool), Nothing
03:53:55 <ski> jmcarthur : .. the Melbourne Mercury compiler has some support for deciding at compile-time to reuse old nodes, when constructing new ones
03:54:04 <ski> @src Bool
03:54:04 <lambdabot> data Bool = False | True deriving (Eq, Ord)
03:54:15 <jmcarthur> ski: that sounds pretty nice
03:54:23 <ski> iwtu : the two possible values of the type `Bool' is `False' and `True'
03:55:03 <ski> iwtu : `Bool' itself is a *type*, so it can't be part of *values* in any type (in this case the type `Maybe (Maybe Bool,Bool)')
03:55:36 <ski> iwtu : but you've made a good start. you just need to replace each `Bool' with either `False' or `True', in all possible ways
03:55:40 <jmcarthur> for a second there i mixed up Jafet with JaffaCake and i was wondering why he was asking what constructor specialization was
03:56:06 <ski> iwtu : btw, you don't *need* to enumerate the values explicitly, if you don't want to. it's enough for me if you just tell the count of them
03:56:29 <iwtu> ski: thanks god you didn't give Int :P
03:57:08 <ski> iwtu : heh, that's why i *didn't* choose `Int' or any list-type :)
03:57:18 <absence> http://hpaste.org/48303 <- are there better ways to write this?
03:58:16 <ski> jmcarthur : "Compile-time garbage collection for the declarative language Mercury", Nancy Mazur, PhD. Thesis, 2004-05, <http://www.mercury.csse.unimelb.edu.au/information/papers.html#mazur-thesis>
03:58:50 <Jafet> Compile-time GC, the best kind of GC
03:59:28 <iwtu> ski: But it not clear. In imperative languge is a Bool type and True/False value
03:59:38 <ManateeLazyCat> Hi all. :)
03:59:43 <iwtu> ski: here is the type everything
03:59:50 <ski> absence : actually i've pondered this too, before :)
04:00:02 <ManateeLazyCat> Long time no see ....
04:00:12 <ski> @type join .: (<*>)
04:00:13 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Applicative m) => m (a1 -> m a) -> m a1 -> m a
04:00:19 <Jafet> jmcarthur: since I'm not JaffaCake, could you tell me where in the manual to find an explanation of -fspec-constr?
04:00:21 <ski> @type let infix 3 <*>>; (<*>>) = join .: (<*>) in \f x y z -> f <$> x <*> y <*>> z
04:00:21 <lambdabot> forall a a1 a2 (m :: * -> *) a3. (Monad m, Applicative m) => (a -> a1 -> a2 -> m a3) -> m a -> m a1 -> m a2 -> m a3
04:00:23 <jmcarthur> ski: ah i think i've seen that paper actually
04:00:37 <Jafet> “-fspec-constr: Turn on call-pattern specialisation.”
04:00:37 <jmcarthur> Jafet: i'm not sure it's even in the manual, actually
04:00:53 <ski> absence : if you use `(<*>>)' (better name ?) for the last argument, you can avoid the `join'
04:01:37 <ski> (and the `infix 3' was just a randomly chosen fixity declaration to avoid extra brackest. it should be chosen with some more case)
04:01:49 <ski> ehlo ManateeLazyCat
04:02:05 <jmcarthur> Jafet: the comments here are helpful http://www.haskell.org/ghc/docs/6.12.2/html/libraries/ghc-6.12.2/src/SpecConstr.html
04:02:19 <ski> iwtu : no, here in Haskell, `Bool' is also a type, and `True',`False' are its values
04:02:23 <ManateeLazyCat> ski: Hi, how are you? ;p
04:02:24 <ski> iwtu : it's no difference there
04:02:36 <absence> ski: is (.:) = fmap . fmap?
04:02:57 <ski> absence : actually, when i invented it, i defined it as `(.) . (.)'
04:03:09 <ski> @type let (.) = (Prelude..) in (.) . (.)
04:03:10 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
04:03:35 <ski> but then, via Cale's generalization of `(.)' to `fmap', `(.:)' automagically got generalized too
04:03:36 <iwtu> ski: ach. you were asked for values. then inresting the type itself is a value
04:04:13 <ski> absence : in this particular case, i'm only using the ordinary `(.) . (.)'-meaning, though, no `(.) = fmap' nonsense ;)
04:04:28 <ski> iwtu : no, i said the type is *not* a value
04:04:43 <absence> ski: what's the difference?
04:04:51 <ski> iwtu : you said `(Just Bool, Bool)', as if `Bool' was a value, which it's not
04:05:04 <ski> @type let (.) = (Prelude..) in (.) . (.)
04:05:04 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
04:05:08 <ski> @type (.) . (.)
04:05:08 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
04:05:13 <ski> absence : ^
04:05:41 <ski> > succ .: [Just 2,Nothing,Just 3]  -- the generalized version
04:05:43 <lambdabot>   [Just 3,Nothing,Just 4]
04:06:25 <ski> iwtu : i suppose it could be confusing that Haskell in some cases uses a bit similar syntax in types as in values
04:06:57 <ski> iwtu : e.g. consider the value `(42,False)'. this is a pair of two values `42' and `False'
04:07:34 <Jafet> jmcarthur: hah, so it's documented in the right place.
04:07:41 <absence> ski: ok.. i'm not sure i understand, but i'll play a bit with it :)
04:07:47 <ski> iwtu : contrast this with the *type* `(Int,Bool)' (which is the type of the value above), here `(Int,Bool)' means the *type* of values of the form `(n,b)' where `n' is an `Int' and `b' is a `Bool'
04:08:32 <ski> iwtu : it might be somewhat confusing to use the same `(..,..)'-notation for both values like `(42,False)', as well as their type `(Int,False)'
04:08:43 <absence> ski: but basically there's no way to avoid the join, and the "best" way is to hide it?
04:09:03 <ski> iwtu : in fact, in e.g. the language SML, one writes the type of the value `(42,false)' as `int * bool' instead
04:09:36 <ski> iwtu : the `*' there is used to suggest what is known as "cartesian product of sets", which is basically what the `(Int,Bool)' type is
04:09:49 <ski> iwtu : are you sufficiently confused, yet ? :)
04:10:40 <jmcarthur> absence: what join?
04:11:12 <jmcarthur> oh i didn't read back far enough
04:11:28 <iwtu> ski: maybe I am not good with words here I think I intuitively understand
04:11:35 * jmcarthur gives this a shot
04:12:10 <ski> ManateeLazyCat : i'm actually slightly irritated that `haskell-mode's `haskell-newline-and-indent' binding for `C-m'/`RET' "steps through" form feeds in my code, instead of pushing them to the next line
04:12:43 <iwtu> I have to go to lunch. I will return and make clear in expresseion, type, value in Haskell. If I may
04:13:49 <ski> ManateeLazyCat : as if that's not enough, i noticed that `fundamental-mode's `newline-and-indent' binding for `C-j' *eats* any form feeds after point but before the first of newline, non-white-space, end-of-buffer
04:13:51 <jmcarthur> absence: can any of getType, getIntData, and getItems commute, or are they stuck in that order?
04:14:00 <ski> iwtu : sure
04:14:29 <ski> (iwtu : it's possibly you need to time to think on these matters on your own)
04:14:36 <absence> jmcarthur: they have to occur in that order, as they're reading from the same file
04:14:41 <jmcarthur> ah okay
04:15:18 <iwtu> ski: thanks!
04:15:47 <jmcarthur> absence: i invented a set of combinators just for this case before, but i doubt lambdabot has them
04:15:55 <azaq23> ski: Regarding SML: Or to suggest the type theoretic concept of a product type by using *, which lies nearer conceptually, though cartesian product of course also applies
04:16:07 <ski> absence : `(<*>>) = join .: (<*>)' is short for `mf <*>> ma = join (mf <*> ma)', so `f <$> ma <*> mb <*>> mc' will become `join (f <$> ma <*> mb <*> mc)', just like you wanted
04:16:07 <jmcarthur> absence: bind2 :: (a -> b -> m c) -> m a -> m b -> m c
04:16:52 <jmcarthur> which would mean you could write  bind2 getItems getType getIntData
04:16:53 <ski> azaq23 : yeah. i actually prefer the ML's choice for writing tuple types to Haskell's choice
04:17:36 <jmcarthur> absence: but you can't get rid of the "monadness" here, so you will always have something like join or >>=
04:17:45 <jmcarthur> even if hidden behind another definition
04:17:47 <ski> azaq23 : it's irritating in Haskell because the nice notation for type *tuples* (*not* tuple types) is already used up for tuple types :/
04:17:53 <absence> ski: thanks for clarifying the code :)
04:18:29 <ski> absence : if you don't like `<*>>', i'm sure you can come up with a better name
04:18:36 <ski> (or at least i hope so ..)
04:18:46 <ManateeLazyCat> ski: Hehe, i hate it too, sorry, i can't help that. :) All my time on Linux Deepin (A Chinese Linux distribution)
04:19:03 <jmcarthur> :t join .: ap
04:19:04 <ski> ManateeLazyCat : so, you're also using form feeds in your code ?
04:19:04 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m (a1 -> m a) -> m a1 -> m a
04:19:23 * ski nods solemnly in lambdabot direction
04:20:16 <ManateeLazyCat> ski: actually, i have my own elisp code for haskell indent, code in haskell-mode is not smart enough.
04:20:29 <ski> absence : as jmcarthur noted, it's probably better to use `ap' rather than `(<*>>)' in the definition, to avoid carrying around more than one class constraint in the type signature
04:20:40 <ski> ManateeLazyCat : heheh :)
04:21:12 <ManateeLazyCat> ski: I will release new Linux Software Center few days later. It's written by Python (9762 lines)
04:22:04 <ManateeLazyCat> ski: Currently just support Debian system, i will port it to other Linux version, such as, Fedora, Gentoo, Arch etc.
04:22:56 <ManateeLazyCat> ski: http://www.ubuntusoft.com/wp-content/uploads/2011/05/Screenshot-%E6%B7%B1%E5%BA%A6Linux%E8%BD%AF%E4%BB%B6%E4%B8%AD%E5%BF%83.jpg
04:23:10 <ManateeLazyCat> ski: Above is my Linux Software Center
04:23:33 <absence> ski / jmcarthur: if the first action only takes one argument, i'd have to make a similar operator <$>> as well right?
04:23:50 <absence> since there would be nowhere to stick the <*>>
04:24:22 <ski> absence : "there's no way to avoid the join, and the \"best\" way is to hide it?" -- yes
04:24:38 <ski> jmcarthur : hehe, i've done `bindM2' and `bindM3' too ;)
04:26:05 <ski> ManateeLazyCat : ok. what does it do ? (and what does it do differently for what i assume is the "standard" "Linux Software Center" ?)
04:26:41 <dibblego> @type (.:)
04:26:42 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
04:26:56 <jmcarthur> absence: i don't think i understand the question
04:27:29 <ski> absence : hm
04:27:54 <ski>   f <$> ma <*> mb <*>> mc  = join (f <$> ma <*> mb <*> mc)
04:28:01 <absence> jmcarthur: replacing the last <*> with <*>> is only possible if there IS a <*>, which wouldn't be the case if getListData = join $ getItems <$> getType
04:28:05 <dibblego> I have an exercise related to this discussion
04:28:07 <ski>   f <$> ma <*>> mb  = join (f <$> ma <*> mb)
04:28:19 <jmcarthur> absence: in your case you could just say   getItems =<< getType
04:28:26 <ski>   f ??? ma  = join (f <$> ma)
04:28:40 <ski> @type \f ma -> join (f <$> ma)
04:28:41 <lambdabot> forall a (m :: * -> *) a1. (Functor m, Monad m) => (a -> m a1) -> m a -> m a1
04:28:56 <ski> which is just `(=<<)', so
04:28:57 <absence> jmcarthur: i know, but it sort of "sticks out" compared to the rest :) feels inconsistent
04:29:01 <ski>   f =<< ma  = join (f <$> ma)
04:29:01 <jmcarthur> that is, (=<<) is the version of bind* for functions of one argument
04:29:05 <ManateeLazyCat> ski: First, it have *best* UI that different with other Software Center. Second, it support, Full-text search, One-Click installtion, local deb install, software vote, software comment, multi-mirror, multi-protocol, multi-threaded download ... etc.
04:29:18 <ski> absence : so, no, in that case, you can just use `=<<' directly
04:29:33 <ski> @type (=<<)
04:29:34 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
04:29:36 <ski> @type join . ap
04:29:37 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
04:29:37 <lambdabot>     Probable cause: `ap' is applied to too few arguments
04:29:37 <lambdabot>     In the second argument of `(.)', namely `ap'
04:29:40 <ski> @type join .: ap
04:29:41 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m (a1 -> m a) -> m a1 -> m a
04:29:47 <fragamus> @type main
04:29:48 <lambdabot> Not in scope: `main'
04:29:55 <ManateeLazyCat> ski: It download software from multi-server, multi-protocol with multi-threaded, so it's much much fast than other software center, also faster than apt-get
04:30:08 <ski> absence : maybe `*<<' would be a better name for `<*>>', then ?
04:30:13 <ManateeLazyCat> ski: Ok, i need cook Chinese food, see you. :)
04:30:49 <jmcarthur> absence: you could just define bind1 if you don't like switching to an infix operator :P
04:31:39 <jmcarthur> i'm not convinced that i should like <*>> yet
04:31:48 <absence> ski: hm, good point
04:32:10 <ski> absence : does the descending sequence `f <$> ma <*> mb <*> mc *<< md', `f <$> ma <*> mb *<< mc', `f <$> ma *<< mb', `f =<< ma', `return f' look better to you ?
04:33:06 <absence> jmcarthur: i rather do like the infix ones. bindM is cute, but having to define one for each number of arguments, and specify the number of arguments when using it, feels wrong somehow
04:33:15 <ski> (and yes, i think `<$>' would better be names something else, like e.g. `$<' or something ..)
04:33:51 <dibblego> Data.Time is making me very sad, surely this is not it, surely?
04:34:01 <absence> ski: it's not perfect, but better :)
04:34:03 <jmcarthur> absence: on the one hand, i agree that it seems inelegant, but i always find myself using liftA* instead of (<$>) and (<*>) because it's so much easier to read
04:34:19 <ski> ManateeLazyCat : does it support multi-view, a la MVC ?
04:34:43 <jmcarthur> absence: also, this allows me to write some nicer point free definitions like    foo = bind3 bar
04:35:39 <jmcarthur> also, you are being just as explicit about the number of arguments when using (<$>) and (<*>) anyway
04:36:48 <absence> jmcarthur: point-free is a good uh .. point. i imagine it would look pretty bad with <*> etc
04:37:17 <ski> (jmcarthur : i think possibly in some cases with non-regular data types or GADTs, one might need the combinators .. but this is probably not very common, though)
04:37:28 <jmcarthur> @pl \ma mb mc -> join $ bar <$> ma <*> mb <*> mc
04:37:29 <lambdabot> ((((join . (bar <$>)) .) . (<*>)) .) . (<*>)
04:37:40 <ski> nice !
04:37:41 <absence> dear god in heaven :P
04:38:04 <jmcarthur> lol surely it could be better than that
04:38:40 <tarrasch> I've created yesod site using the scaffold. Now I want to build for production. I guess I should pass the production-flag to cabal. But `cabal configure/install -fproduction` doesn't seem to change anything.
04:38:49 <jmcarthur> ski: i've not come across such a case before, and i use GADTs a lot
04:39:03 <jmcarthur> but maybe i just use them in a more regular way than i think
04:42:18 <ManateeLazyCat> ski: No, it's not support MVC
04:42:18 <absence> jmcarthur: how are bind2 and bind3 defined?
04:42:18 <ManateeLazyCat> ski: It develop for mouse user, not geek. :)
04:42:18 <davidbe> tarrasch: I don't know, but yesod has it's own channel #yesod on freenode. (though I guess those who know are here too..?)
04:42:18 <Peaker> no reddit discussions in /r/haskell for quite a while, how come?
04:42:18 <jmcarthur> absence: bind2 f a b = do { x <- a ; y <- b ; f x y }
04:42:18 <tarrasch> davidbe, Ah, thanks
04:42:18 <jmcarthur> absence: just like liftM2, except without using return
04:42:18 <xarch_> is curryfication by default the best for point-free?
04:42:18 <Peaker> or: just like liftM2, but joined
04:42:22 <jmcarthur> right
04:42:35 <Peaker> but "bind2" is really flipped bind, 2
04:42:49 <Peaker> dnib2
04:43:05 <jmcarthur> i wish =<< had gotten the nice "bind" name instead of ">>="
04:43:12 <dibblego> me too
04:43:14 <jmcarthur> i tend to just call them both bind anyway
04:43:36 <jmcarthur> g2g
04:43:51 <Peaker> dnibbing has a nice ring to it :)
04:47:29 <absence> jmcarthur: thanks :)
04:48:02 <Peaker> What are Scala traits in Haskell speak?
04:48:26 <Peaker> Implicit arguments? If so, how are values to be passed chosen?
04:48:27 <companion_cube> Peaker: there is not equivalent
04:48:53 <companion_cube> traits are OO concepts, haskell has typeclasses
04:49:01 <companion_cube> no implicit arguments either
04:49:03 <Peaker> so what are traits in OO speak?
04:49:57 <companion_cube> traits are like interfaces (java speak) but with some implementation inside
04:50:03 <companion_cube> you should ask on #scala
04:50:31 <dibblego> Scala traits are like the data keyword
04:51:37 <Peaker> dibblego: I see use of universally quantified variables whose quantification is *inside* the trait
04:51:48 <dibblego> with RankNTypes enabled
04:51:49 <Peaker> so that makes them kind of like type-classes or GADTs or higher-ranked types
04:52:01 <dibblego> I say "like" very loosely
04:53:18 <Peaker> "case class" seems like GADT constructors?  But it seems to be an open-world rather than a closed-world?
04:53:18 <absence> bind is just a name used for >>=, not an actual function?
04:53:27 <Peaker> absence: yeah
04:53:53 <companion_cube> Peaker: case class are like algebraic types ("data" or gadt) with open world
04:53:54 <dibblego> case class is a conflation between open-world and a data constructor
04:54:07 <companion_cube> but you can have "sealed trait" as the union type
04:54:15 <companion_cube> which closes the definition tothe current file
04:55:02 <Peaker> reading http://etorreborre.blogspot.com/2011/06/essence-of-iterator-pattern.html -- and I know Functor/Pointed/Applicative/Monad and their relationships, and I'm still having trouble reading through Scala syntax
04:55:15 <Peaker> companion_cube: ah, cool, thanks
04:55:25 <dibblego> I wrote those type-classes
04:55:41 <ski> jmcarthur : *nod*
04:55:49 <ski> Peaker : s/dnib/extend/ :)
04:56:11 <ski> `(=<<)' is called "monadic extension" in some papers, iirc
04:56:14 <Peaker> dibblego: I'm having trouble figuring out which Applicative rises up from any Monoid..
04:56:22 <Peaker> dibblego: in that page
04:56:52 <ski> (`f =<< ma' has also been written as `f * ma', and as `f^* ma', i.e. `(f^*) ma')
04:57:15 <ski> ManateeLazyCat : heh, what does "mouse" have to do with it ? :)
05:02:12 <hpc> :t (f =<<)
05:02:12 <lambdabot> forall a (m :: * -> *) b. (Show a, SimpleReflect.FromExpr (m b), Monad m) => m a -> m b
05:17:07 <ski> osfameron : btw, i wondered which paper you were talking about before (link ?) ?
05:18:30 <osfameron> ski: I was looking at spj's "A taste of Haskell" OSCON 2007 video
05:18:59 <ski> and he's mentioning zippers or cyclic structures in that one ?
05:19:23 <osfameron> nope.  just a list, and he appends stuff to either end as required
05:19:48 <ski> ok (modelling a (de)queue ?)
05:19:51 <osfameron> he does mention "It's a window manager... how many windows have you got open?  10 or so?  the computer can cope with that ;-)"  or something along those lines
05:20:26 <osfameron> well, modelling a zipper on an infinite cycle, conceptually, but modelling it as if were a dequeue, yeah
05:20:38 <ski> *nod*
05:21:45 * erus` thinks ski should use /me instead of *action*
05:22:05 * ski nods solemnly
05:26:14 <ski> @type join .::: (<*>) .:: (<*>) .: (<$>)
05:26:14 <lambdabot> forall (m :: * -> *) a a1 a2 a3. (Monad m, Applicative m) => (a3 -> a2 -> a1 -> m a) -> m a3 -> m a2 -> m a1 -> m a
05:27:30 * ski thinks that has a certain elegance, in all its abstruse glory
05:28:17 <ski> absence,jmcarthur : ^ :D
05:29:40 <Peaker> @let result = (<<<) ; argument = (>>>)
05:29:41 <lambdabot>  Defined.
05:30:00 <Peaker> @let infixr 2 ~> ; (f ~> g) x = f >>> x >>> g
05:30:00 <lambdabot>  Defined.
05:30:25 <Peaker> @type  id ~> id ~> join  $  liftM2
05:30:26 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a2)
05:30:26 <lambdabot>     Probable cause: `liftM2' is applied to too few arguments
05:30:26 <lambdabot>     In the second argument of `($)', namely `liftM2'
05:30:48 <Peaker> @type (~>)
05:30:49 <lambdabot> forall (cat :: * -> * -> *) a b b1 c. (Control.Category.Category cat) => cat a b -> cat b1 c -> cat b b1 -> cat a c
05:31:40 <ski> @type (id ~> id ~> join) . liftM2
05:31:41 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
05:33:12 <ski> @type (result . result) join . liftM2
05:33:13 <lambdabot> forall a a1 a2 (m :: * -> *). (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
05:35:23 <Peaker> @type (result . result . result) join liftM2
05:35:24 <lambdabot> forall a a1 a2 (m :: * -> *). (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
05:35:34 <Peaker> Oh, it's 3 args! heh
05:35:49 <Peaker> @type id ~> id ~> id ~> join $ liftM2
05:35:49 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
05:36:02 <Peaker> I like that -- visually showing where the join is applied in liftM2's type
05:37:06 <ski> yeah, that's nice
05:37:27 <ski> you more or less traverse the type structure, down to the part which you want to modify
05:37:51 <Peaker> Can be named "visual SEC" perhaps :)
05:37:59 * hackagebot freekick2 0.1.2 - A soccer game  http://hackage.haskell.org/package/freekick2-0.1.2 (AnttiSalonen)
05:38:07 <Peaker> *** could get a symbol more similar to (,) to be a tuple's "visual SEC" :)
05:38:11 <ski> hm, i thought this *was* SECs ?
05:38:19 <ski> ah
05:38:38 <Peaker> ski: Yes, SECs whose type-traversal is visual by having a SEC component for each element in the type
05:38:47 <ski> well, imo, you'd like some kind of quoting and unquoting
05:39:10 <ski> this is basically treating morphisms in a category as variable objects
05:39:28 <Peaker> ~> for functions, *** for tuples, bimap for eithers, fmap for covariant type constructors, ...
05:40:06 <absence> ski: wow.. point-free applicative style?
05:40:19 <Peaker> In a structural editor, you could have a "SEC editor" that let you create a SEC by highlighting the part of the type you want to apply a function to :)
05:40:22 <ski> borrowing Scheme's quotation notation for a moment, if  f  is a morphism from  A  to  B
05:40:28 <absence> ski: or uh.. what is it? :D
05:40:46 <ski> then  ,f  is a "varying object", which varies from  A  to  B
05:41:29 <ski> given any other object  C  , you can of course form the categorical product of the (varying) object  ,f  and the object  C  :  ,f * C
05:42:05 <ski> (this is now an object which varies from  A * C  to  B * C  )
05:42:36 <ski> then, you quote this again to get back to a morphism from the varying object :  `(,f * C)  is now a morphism from  A * C  to  B * C
05:43:00 <ski> absence : what is what ? :)
05:43:14 <ski> Peaker : yeah :)
05:43:28 <ski> (did you understand my "variable object" idea ?)
05:43:46 <absence> ski: the elegant join .::: <*> etc thing
05:44:00 * hackagebot hogre 0.1.3 - Haskell binding to a subset of OGRE  http://hackage.haskell.org/package/hogre-0.1.3 (AnttiSalonen)
05:44:00 <Peaker> @type (.:::)
05:44:01 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
05:44:10 <ski> absence : it's `bind3'
05:44:31 <ski> @type join .::: (<*>) .:: (<*>) .: (<$>)
05:44:32 <lambdabot> forall (m :: * -> *) a a1 a2 a3. (Monad m, Applicative m) => (a3 -> a2 -> a1 -> m a) -> m a3 -> m a2 -> m a1 -> m a
05:44:49 <ski> @type \f ma mb mc -> join (f <$> ma <*> mb <*> mc)
05:44:50 <lambdabot> forall a a1 a2 (m :: * -> *) a3. (Applicative m, Monad m) => (a -> a1 -> a2 -> m a3) -> m a -> m a1 -> m a2 -> m a3
05:45:20 <absence> ahh right, bind3 = that. haha, that IS elegant
05:45:49 <ski> absence : Peaker's version is probably easier to grasp, and recall how to read, though :)
05:47:00 <Peaker> @hoogle (l -> l') -> (r -> r') -> Either l r -> Either l' r'
05:47:01 <lambdabot> No results found
05:47:41 <Peaker> @let inEither l r (Left v) = Left (l v) ; inEither l r (Right v) = Right (r v)
05:47:42 <lambdabot>  Defined.
05:47:51 <Peaker> @type id ~> (id *** id) ~> fmap id ~> inEither id id
05:47:52 <lambdabot> forall a b b' a1 (f :: * -> *) t t1. (Functor f) => (a -> (b, b') -> f a1 -> Either t t1) -> a -> (b, b') -> f a1 -> Either t t1
05:48:14 <Peaker> Visual SECs :)
05:50:04 <absence> ski: it's a more readable point-free join (liftM2 ...)?
05:50:43 <ski> absence : well, in the point-free version, yes
05:51:23 <ski> absence : but typically you will apply it to at least a couple of arguments, so in those cases, this version is probably unnecessarily complicated
05:51:30 <ski> (but i'm not sure)
05:51:35 <ski> @let inDrop :: Integral i => ([a] -> [a]) -> ([a] -> [a]); inDrop i f (splitAt i -> (front,back)) = front ++ f back
05:51:35 <lambdabot>   ViewPatterns is not enabled
05:51:56 <ski> @let inDrop :: Integral i => ([a] -> [a]) -> ([a] -> [a]); inDrop i f list = front ++ f back where (front,back) = splitAt i list
05:51:56 <lambdabot>  <local>:6:0:
05:51:56 <lambdabot>      Ambiguous constraint `Integral i'
05:51:56 <lambdabot>          At least one of...
05:52:04 <ski> @let inDrop :: Integral i => i -> ([a] -> [a]) -> ([a] -> [a]); inDrop i f list = front ++ f back where (front,back) = splitAt i list
05:52:04 <lambdabot>  <local>:6:122:
05:52:04 <lambdabot>      Couldn't match expected type `Int' against inferred type...
05:52:10 <ski> *sigh*
05:52:15 <ski> @let inDrop :: Integral i => i -> ([a] -> [a]) -> ([a] -> [a]); inDrop i f list = front ++ f back where (front,back) = genericSplitAt i list
05:52:16 <lambdabot>  Defined.
05:52:42 <ski> > inDrop 3 reverse "abcdefgh"
05:52:43 <lambdabot>   "abchgfed"
05:53:10 <ski> so `inDrop n' is a SEC which focuses on the rest of a list, after the first `n' elements
05:53:55 <Peaker> well, that's applying a function to part of a value that doesn't correspond to part of its type
05:54:21 <Peaker> and if it did, it would have to be inSplit... so I'm sorry, but I cannot grant you the Visual SEC trademark..
05:54:32 <ski> hm, maybe one'd like to ensure `inDrop n f . inDrop n g = inDrop n (f . g)', though
05:54:43 <ski> (at least in cases when both sides are defined)
05:55:10 <Peaker> > splitAt 100 "hello"
05:55:11 <lambdabot>   ("hello","")
05:55:23 <Peaker> ski: sounds to me like it should be ensured by your code already?
05:55:34 <ski> @let perDrops :: Integral i => i -> (a -> a) -> ([a] -> [a]); perDrops i f = inDrop i . map f
05:55:35 <lambdabot>  <local>:7:72:
05:55:35 <lambdabot>      Couldn't match expected type `[a]'
05:55:35 <lambdabot>             against in...
05:55:50 <ski> @let perDrops :: Integral i => i -> (a -> a) -> ([a] -> [a]); perDrops i = inDrop i . map
05:55:50 <lambdabot>  Defined.
05:55:56 <ski> Peaker : is that better ? :)
05:56:11 <ski> Peaker : well, consider
05:56:15 <Peaker> oh, it wouldn't be ensured if the drop WAS a partial drop, but then you made it less partial by changing the list to be non-empty
05:56:29 <absence> http://pastebin.com/W0rHnkhW <- can this be more concise?
05:56:30 <mauke> The paste W0rHnkhW has been copied to http://hpaste.org/48304
05:56:48 <ski> > (inDrop 5 reverse . inDrop 5 (++ "xyz")) "abc"
05:56:49 <lambdabot>   "abcxyz"
05:56:49 <Peaker> nice contribution by mauke :)
05:56:59 <ski> > inDrop 5 (reverse . (++ "xyz")) "abc"
05:57:01 <lambdabot>   "abczyx"
05:57:25 <ski> Peaker : so they don't agree always, with this definition
05:57:57 <Peaker> absence: not in a nice way, probably ($ can save parenthesis there)
05:58:18 <Peaker> ski: yeah I figured it out just before you wrote that :)
05:58:24 <ski> (btw, i didn't define an `inTake' because of similar problems with the modifier modifying the length of the prefix)
05:58:43 <absence> Peaker: ok, thanks
05:58:48 <ski> however, a `dropRight' would be just as fine as `drop'
05:59:17 <Peaker> ski: not sure how you can ensure that property then.. do you have an idea?
05:59:35 <Peaker> ski: except making drop behave like tail (partial if the list is too short)
05:59:57 <ski> Peaker : in case the list is shorter than `n' elements, in `inDrop n f', don't apply the function at all
05:59:59 <Peaker> or converting the drop result from a list to a list zipper
06:00:18 <ski> (since the "suffix starting at index `n'" doesn't exist, in this case)
06:00:44 <Peaker> ski: yeah, that's a simple solution :)
06:00:54 <ski> an alternative would be to make the function partial if the list is too short
06:01:45 <ski> then you'd at least get the equation sides to agree when they're both defined .. and i suspect in this case if one side is defined, then the other is defined (and then they're equal
06:01:49 <ski> )
06:02:16 <ski> (you could of course model the partiality with `Maybe', as well)
06:03:18 <ski> Peaker : anyway, `perDrops n' is "applying a function to part of a value that does" "correspond to part of its type"
06:03:42 <ski> (but since there can be elements of the list which are not changed, we can't change the type)
06:03:59 <ski> and `map' is of course the `perElement' SEC on lists
06:04:38 <ski> if we decide on some sensible way to handle the length of the prefix, we could do an
06:04:48 <Peaker> ski: it applies it only to part of the list, not the entire list..
06:05:11 <ski>   inSplitAt :: Integral i => i -> ([a] -> [b]) -> ([a] -> [b]) -> ([a] -> [b])
06:05:17 <ski> which can change the type
06:05:24 <ski> Peaker : *nod*
06:05:59 <ski>   perTakes_inDrop :: Integral i => i -> (a -> b) -> ([a] -> [b]) -> ([a] -> [b])
06:06:04 <Peaker> I guess it makes sense to apply stuff to parts of the value, and only sometimes correspond to parts of the type
06:06:18 <ski> would be safe wrt not changing length of prefix (corresponding to the `i' argument)
06:07:06 <ski> yeah, consider `perWindow :: (Window -> Window) -> (Workspace -> Workspace)', e.g.
06:10:11 <ski> @let perReverse :: ([a] -> [b]) -> ([a] -> [b]); perReverse = reverse ~> reverse
06:10:12 <lambdabot>  Defined.
06:11:10 <ski> > perReverse (perTakes_inDrop 2 toUpper id) "foobar"
06:11:11 <lambdabot>   "foobAR"
06:11:43 <ski> (obviously we also want laws like `perReverse id = id' to hold)
06:12:22 <ski> (in this case, that only holds for finite lists)
06:14:03 * ski ponders how this style of modifying parts of structures differs from lenses / functional references ..
06:15:21 * edwardk1 looks up at the mention of lenses
06:15:34 <ski> edwardk1 : playing with SECs
06:15:42 <edwardk1> ah
06:20:09 <foo-nix> twanvl, ping
06:26:39 <ManateeLazyCat> ski: Hehe, cook some beef, very good....
06:26:39 <mike-burns> This is my first Haskell anything in over a year; can I get a code review and maybe even comments on how other people have done it better? http://hpaste.org/48305
06:26:56 <ManateeLazyCat> ski: It's develop for people that know nothing about computer. :)
06:30:19 <ski> absence : i don't see any obvious embetterment
06:34:18 <ski> mike-burns : i'd write (note mismatched brackets)
06:34:26 <ski>   map head (verticalGrid n xs) == take (ceiling ((toRational $ length xs) / n))) xs
06:34:30 <ski> as
06:34:30 <ski>   map head (verticalGrid n xs) = take (ceiling (toRational (length xs) / n)) xs
06:34:51 <mike-burns> Oh, good catch.
06:34:54 <ski> > 16 `mod` 7
06:34:55 <lambdabot>   2
06:35:03 <ski> > - ((-16) `mod` 7)
06:35:04 <lambdabot>   -5
06:35:30 <ski> > 16 `div` 7
06:35:30 <lambdabot>   2
06:35:38 <ski> > - ((-16) `div` 7)
06:35:39 <lambdabot>   3
06:35:52 <ski> mike-burns : you could probably write instead
06:36:43 <ski>   map head (verticalGrid n xs) = take (- (- length xs) `div` n)) xs
06:37:08 <ski> mike-burns : rounding upwards .. i'm not sure which is clearest, though
06:37:14 <mike-burns> Yeah, not sure either.
06:37:21 <mike-burns> The toRational is ugly, but the ceiling makes it more clear.
06:37:34 <mike-burns> I wish there were a `div' that rounded up instead of truncated.
06:37:38 <ski> (you could of course define, or at least mention a variant of `div' which rounds upwards instead)
06:38:21 <mike-burns> In my quickcheck file that makes sense but I hope to keep that line of the docs short.
06:38:44 <ski> > (`div` 7) . [-10 .. 10]
06:38:46 <lambdabot>   [-2,-2,-2,-1,-1,-1,-1,-1,-1,-1,0,0,0,0,0,0,0,1,1,1,1]
06:39:01 <ski> `div' doesn't truncate, it always rounds to lower values
06:39:13 <ski> (`quot' truncates though, iirc)
06:39:24 <ski> > (`quot` 7) . [-10 .. 10]
06:39:26 <lambdabot>   [-1,-1,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1]
06:39:31 <ski> *nod*
06:40:13 <absence> ski: thanks for looking
06:40:20 <mike-burns> The docs for `div' say "integer division truncated toward negative infinity", but now I understand that this means rounding.
06:40:45 <mike-burns> "truncated toward negative infinity" is just rounding down, no?
06:41:06 <mike-burns> Well anyway, I understand what it does now.
06:41:12 <ski> ManateeLazyCat : ok :) i'd prefer an environment to scale/slide smoothly up and down in terms of customizability, though :)
06:41:26 <kaol> > (\n -> unfoldr (\a -> do guard (a /= []); return $ splitAt n a)) 2 [1..5]
06:41:27 <lambdabot>   [[1,2],[3,4],[5]]
06:41:27 <ski> mike-burns : yes
06:41:45 <mike-burns> I found division to be the hardest part of this code, by the way. The type system got in my way more than it helped.
06:42:31 <Jafet> mike-burns: yes, but “down” is more ambiguous than “towards negative infinity”.
06:42:50 <mike-burns> Hm, yes.
06:43:32 <ManateeLazyCat> ski: Yes, i don't use that software center too much, i prefer Emacs-style.
06:43:39 <ski> (mike-burns : btw, one reason i think it's better to use `=' rather than `==' in stating such specifications is that using `==' suggests that some kind of equality *check* is intended, while your function works just as well when the list elements are not comparable for equality (e.g. functions in general, or `IO'-actions)
06:44:11 <ski> )
06:44:30 <ManateeLazyCat> ski: I work for Linux Deepin for money, then spend other time on Haskell, unfortunately, it's long time leave Haskell world.
06:44:48 <mike-burns> Ah, I see what you're saying, ski .
06:44:48 <ManateeLazyCat> ski: I will back to gtk2hs project at 2010-07-02
06:45:04 * osfameron discovers that the reference-counting GC problem for cyclic data-structures mirrors the FP-sharing problem with same.
06:45:29 <dainanaki> Recently, I used a trace-like function in a piece of code that showed each evaluation step without putting the function in the IO monad. Does anyone know what I'm talking about? I can't remember where I found it.
06:45:36 <kaol> mike-burns: You're calling length in every iteration of horizontalGrid
06:45:47 <ManateeLazyCat> ski: I need to go, bye. :)
06:46:22 <ski> mike-burns : why "If the output would have one columns of data, that row is organized left-to-right in a row instead." ?
06:46:24 <mike-burns> kaol: Good catch. I'll move that out into a helper function?
06:46:46 <mike-burns> ski: I'm simulating the behavior from the  ls -C  command.
06:46:48 <kaol> Or you could use what I wrote as the last thing.
06:46:57 <kaol> > (\n -> unfoldr (\a -> do guard (a /= []); return $ splitAt n a)) 2 [1..5]
06:46:57 <lambdabot>   [[1,2],[3,4],[5]]
06:47:06 <mike-burns> kaol: yes, but I find that harder to read.
06:47:17 <kaol> Or something like that. You don't need length.
06:47:37 <kaol> Writing out the inner lambda as a helper function would make it easier to read.
06:47:46 <ski> mike-burns : why is what `ls -C' does preferable ?
06:47:53 <kaol> lambdabot kind of forced me to make it as a one liner
06:48:13 <mike-burns> ski: I wrote this so I can type implementing  ls  in Haskell.
06:48:15 <ski> kaol : s/a \/= []/not (null a)/
06:49:11 <ski> mike-burns : unless you have a good argument for this irregularity in how `verticalGrid', i think i'd try to handle that special case in the code implementing `ls'
06:49:29 <ski> s/, i think/ works, i think/
06:49:59 <mike-burns> Yeah I was thinking that just before I pasted here, too.
06:50:12 <ski> kaol : mike-burns wants the `transpose' of that, i think
06:50:25 <hpaste> absence pasted “can this be expressed using library functions?” at http://hpaste.org/48306
06:50:32 <dainanaki> So nobody knows about the evaluation tracer function that I'm talking about? For example, you could pass it (2 + (1 + 4)) and it would print (2 + (1+4)) => (2 + 5) => 7
06:50:37 <absence> http://hpaste.org/48306
06:51:02 <luite> argh why do so many haskell libs have to be extremely unfinished, or unmaintained, or both...
06:51:19 <ski> (mike-burns : imho, convenience exceptions should be encoded shallowly, not deeply in the system)
06:51:25 <ClaudiusMaximus> > let h 0 xs = h 1 xs ; h n [] = [] ; h n xs = let (ys, zs) = splitAt n xs in ys : h n zs ; v n = transpose . h n in [v n [1..5] | n <- [1..3]]
06:51:27 <lambdabot>   [[[1,2,3,4,5]],[[1,3,5],[2,4]],[[1,4],[2,5],[3]]]
06:51:36 <mike-burns> ski: I think I agree.
06:53:10 <mike-burns> ski: Ah, the BSD column command also works this way.
06:53:25 <ski> (e.g. it makes sense to not immediately find an occurance of the empty string between every character in your editor buffer, before you've had the time to incrementally enter a string to search for -- but the main programmatic interface to search (incrementally or not) should either find the empty string at every position, or outright disallow that case)
06:53:33 <mike-burns> It phrases it as "rows are filled before columns"
06:53:59 <mike-burns> But I see your point, too.
06:54:15 <mike-burns> Since this is in Data.List it makes no sense to follow what the command-line tools do.
06:55:01 <mike-burns> So I should either rename this module or move that edge case out.
06:55:19 <ski> @where stepeval
06:55:19 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
06:55:20 <ski> dainanaki : ^ ?
06:56:02 <dainanaki> ski: http://hackage.haskell.org/packages/archive/traced/2009.7.20/doc/html/Debug-Traced.html
06:56:08 <ski> ok
07:01:22 <dainanaki> Is there any way to auto detect the text encoding of a file? I'm on a mac and am trying to parse some files written on a windows machine a long while ago, and when I try to use parsec's parseFromFile function on them, I get an Illegal Byte Sequence exception.
07:01:24 <Peaker> why is Haskell reddit so quiet?
07:02:15 <Jafet> If there was, we wouldn't need encodings
07:02:48 <luite> I'm lookign for a wiki to store .lhs files, where it should be possible to protect individual pages and categories (for example everything in a single subdirectory) from editing, and it should be possible to access and modify the contents with javascript
07:02:51 <Peaker> there are reasonable heuristics to figure out UTF8 vs UTF16
07:02:57 <luite> would mediawiki be ok?
07:03:33 <Peaker> You can't really tell ASCII apart from UTF8 without reading the whole thing and seeing if it is all <128 code-points.. I guess heuristics can try to tell apart code-pages from UTF8, but code-pages are going extinct anyway
07:04:39 <Jafet> ASCII is UTF8, so there isn't any need
07:05:02 <Jafet> The fun is where some smart and foresighted people decided to invent code pages
07:05:03 <dainanaki> OK, so, the files in question are iso-8859-1
07:05:53 <dainanaki> how can I get the file read properly if I know the encoding?
07:06:32 <Jafet> Read it with a ByteString and convert it using Data.Text.Encoding
07:08:41 <dainanaki> I could be wrong, but iso-8859-1 isn't listed as one of the decodable options
07:09:43 <Jafet> If there isn't a library already, you could write it
07:10:04 <Jafet> That one's particularly easy because you just need to change byte x to code point x
07:17:37 <Peaker> Jafet: codepages are really old :)
07:17:44 <Peaker> Jafet: they made sense in those times
07:19:13 <Jafet> Chinese is really old
07:21:16 <absence> http://hpaste.org/48306 <- can this be expressed with library functions?
07:22:39 <Peaker> Jafet: Well, the computer distributors around the world needed a solution to their localization problem. Few needed a solution to their language communication problems
07:23:56 <monochrom> dainanaki: if you don't mind using String, look for System.IO.hSetEncoding and latin1
07:24:25 <Jafet> Thus, they invented the abomination that is big5
07:25:09 <dainanaki> OK, that seems like the easiest solution. I'm just trying to write a weekend project. Doesn't have to be very performant.
07:26:09 <Jafet> If you don't actually want to “detect” anything, but proceed straight through Latin-1
07:26:18 <Jafet> Without collecting $200
07:27:06 <dainanaki> All I'm trying to do is see what cpp files include what headers from a bunch of files. This is by no means something I'm going to fuss over any more than I have to.
07:28:03 <zygoloid> dainanaki: you could preprocess with -M
07:29:14 <monochrom> I was on a forum that insisted on using big5. so some chinese characters could contain \ or % basically escape characters for sql. the forum also used sql to store messages (who doesn't). the ensuing sql string injection was not funny. messages got truncated at the escape points. the forum admin just told us not to use the affected chinese characters, which included such common ones as "tears", "meal"...
07:30:10 <Jafet> “Tears” sounds appropriate
07:30:11 <zygoloid> i guess it's just as well Bobby Tables didn't use that forum
07:30:23 <dainanaki> zygoloid: but that would make it not much of a programming project.
07:31:03 <zygoloid> dainanaki: how're you going to deal with files which are conditionally-included, or #include FOO (where FOO is a macro) otherwise?
07:31:25 <Jafet> You could also pretend nothing exists other than the C standard's character set, which happens to be encoded in the same way as ASCII.
07:31:55 <Jafet> Then just read all your bytes and search for the C language's special characters encoded in ASCII
07:32:23 <Jafet> That works with pretty much any multi-byte encoding or code page out there
07:32:32 <dainanaki> zygoloid: I'm using this to make a visualization of the include dependencies of a 1.5 million LOC project, so I'm not worried about it being perfect, just good enough to show how things are more or less connected.
07:33:19 <ski> mike-burns : btw, your list-of-lists is column-of-rows (i.e. column-major), yes ?
07:34:42 <mike-burns> ski: Each sublist is a row.
07:34:53 <mike-burns> Are the function names backward?
07:35:00 <ski> right
07:35:05 <mike-burns> OK, great.
07:35:45 <ski> no, since that was the convention, the naming seems ok
07:36:02 <mike-burns> Whew.
07:36:36 <ski> (obviously `skips' could be computed using the `-'-trick, instead of using rationals and `ceiling')
07:37:48 <mike-burns> Yeah. Or I should define a divThatRoundsUp function.
07:38:11 <ski> first i thought that your `verticalGrid' could be written easily using `horizontalGrid' and `transpose'
07:38:36 <ski> then i realized that you'd need to divide the length of the list with `numColumns' to do that
07:38:45 <mike-burns> Yeah, I tried that too. It might be possible but it isn't easy.
07:39:18 <mike-burns> This all happened because I tried implementing  ls  in Haskell, and I honestly had no idea that the  -C  option was so weird.
07:39:20 <ski> mike-burns : yeah, it's probably nice if you define a `divCeil', even if you only define it inside the `where'
07:39:53 <ski> well, i suppose it makes some sense, of a sort
07:39:59 <mike-burns> Yeah it totally does.
07:40:15 <mike-burns> That said, I've changed my  ls  alias to pass -x now. Hah.
07:40:34 <ski> it's probably easier to follow through a long list of names vertically, only swapping horizontally seldom, instead of vice versa
07:40:48 * ski has no idea what `-x' does
07:41:02 <mike-burns> -x is the left-to-right sorting instead of top-to-bottom sorting.
07:41:14 <mike-burns> horizontalGrid.
07:41:40 <ski> ah, ok, so swap dimensions, grid, then transpose the grid
07:41:47 <mike-burns> Yeah.
07:42:06 * ski has a strange idea for a way to implement `verticalGrid' to try ..
07:43:28 <sjoerd_visscher> absence: replicateUntilM p = liftM (takeWhile (not . p)) . sequence . repeat
07:43:33 <ski> (so, in terms of SEC we talked about above, pseudo-code : `perTransposed grid' :)
07:43:54 <mike-burns> Heh. I'd like to see an implementation that uses transpose.
07:44:27 <mike-burns> There's also sliceHorizontal and sliceVertical from utility-ht. They might do this, maybe even better.
07:44:32 <ski> mike-burns : well, it's probably easy to do, but it seems unnecessarily costly to have to traverse the whole list to compute the length
07:44:54 <ski> (maybe this doesn't matter since we're already doing a non-local permutation, though, i dunno)
07:47:21 <Favonia> Hi everyone, with type families, it is possible to have a "default type" in a typeclass, as a "default implementation" for a function?
07:47:55 <Favonia> s/it is/is it/
07:50:33 * ski doesn't know
07:54:36 * ski notes that `verticalGrid' already computes length ..
07:58:47 <sjoerd_visscher> absence: never mind, it looks like that doesn't terminate
07:59:28 <droud> Wow, when did Haskell get so popular?  Lots of people in here.
08:00:19 <Peaker> droud: I doubt Haskell is as popular as the channel is big :-)
08:00:36 <Peaker> I think lots of people find Haskell interesting but don't make the leap of switching to use it
08:00:44 <Jafet> http://steve-yegge.blogspot.com/2010/12/haskell-researchers-announce-discovery.html
08:00:53 <droud> Peaker: Well, maybe its all the Project Euler folks looking for answers.  I know I would have gotten stuck long before I did if it weren't for Haskell.
08:01:17 <Nimatek> Jafet: lol
08:01:22 <droud> Peaker: It's a nearly impossible leap to make, it still hurts my head to make Haskell do anything real.
08:01:37 <Peaker> droud: It took me a few months of playing around to become comfortable
08:02:07 <Peaker> droud: I've only used Haskell for hobby projects but I'm already very comfortable with it.. I still have to twitch my head to read the super-condensed points-free atrocities, but I guess that's not possible otherwise :)
08:02:23 <Peaker> (there's a big temptation to ETA-reduce and points-free too much in Haskell)
08:02:56 <droud> Peaker: Have no idea what those optimizations are, I'm happy to get stuff to work though.
08:03:18 <droud> Peaker: I'd love to see some real code for doing network IO.
08:03:24 <Peaker> droud: basically replacing things like:  zipWith (+) xs (tail xs)   with   zipWith (+) `ap` tail
08:04:28 <hpaste> Peaker pasted “Simple iteratee-based echo server” at http://hpaste.org/48307
08:04:42 <mike-burns> I'm making Haskell do real stuff and it's fantastic!
08:04:47 <Peaker> droud: here's a network echo-server with iteratees
08:04:49 <mike-burns> I mean, I'm not being paid.
08:04:52 <droud> 1:1: Error: Use fewer imports
08:05:17 <Peaker> droud: that's just an hlint error, click it to reveal it wants me to use a single import Network.Socket with a big list of names, which I don't want to
08:05:28 <monochrom> using ap is way beyond eta-reduc
08:05:32 <mike-burns> Is there a faster way to concatenate two strings than (++) ?
08:05:47 <Peaker> monochrom: yeah I said "eta-reduce and points-free"
08:05:55 <Peaker> droud: This is the echo server itself: echoServer sock = runIteratee $ enumSocket chunkSize sock $$ iterSocket sock
08:06:02 <Peaker> droud: the reset is fluff that unfortunately isn't wrapped in a nice function
08:06:25 <Jafet> mike-burns: use Text instead
08:06:30 <parcs> Favonia: don't think so
08:06:37 <Peaker> for example, it could be nice to have a function that creates a listening, bound socket, and one that creates a forking acceptor on a listening socket -- perhaps one to fuse the two together
08:06:37 <mike-burns> Jafet: Oh right!
08:06:40 <monochrom> I don't normally use ap (of "r ->") when I point-free-ize
08:06:44 <droud> Peaker: I'm going to try it out, thanks!
08:07:40 <Peaker> droud: it takes a port number as a command line argument
08:08:23 <ski> (mike-burns : .. i hope you weren't calling `(++)' left-associatedly, at least ?)
08:08:24 <ion> mike-burns: If you need to use append a lot with general lists, also see difference lists and Data.DList.
08:09:24 <Jafet> http://hpaste.org/47434/difference_lists
08:09:39 <wli-needjob> Rank-ordered AVL trees are also an option.
08:10:05 <Jafet> Er, no
08:10:09 <Jafet> Just use Sequence
08:10:30 <ski> mike-burns : see Jafet's paste for why "calling `(++)' left-associatedly" is bad, in case you didn't know
08:10:31 <wli-needjob> Sequence has a convenient API already there, point.
08:10:39 <mike-burns> ski: Looking for that now!
08:10:49 <Jafet> More importantly, Sequence uses a finger tree, so you can cons and uncons
08:11:49 <wli-needjob> (AVL trees [unclear about libs actually implementing it] support O(lg(n)) split and join.)
08:11:56 <ski> (mike-burns : any such left-associated calls includes via recursion such as `foo .. = if .. then .. else foo .. ++ ..')
08:11:59 <Peaker> Why not change the DList library to be for any Monoid?
08:12:28 <bgamari> Can someone decipher this signature for me: create :: PrimMonad m => m (Gen (PrimState m))
08:12:54 <bgamari> It's from System.Random.MWC
08:12:54 <Jafet> Peaker: how do you know which is the best order for any Monoid?
08:13:10 <bgamari> and creates a generator
08:13:13 <Jafet> Eg. if you're using the monoid of integer multiplication, the best order is binary splitting
08:13:28 <bgamari> But the type of the function is not at all clear
08:13:37 <Peaker> Jafet: It doesn't reassociate for "best order", it just re-associates to the right
08:13:38 <wli-needjob> (split being to chop a tree into 2 pieces where one piece has all keys less than some value and another has all those greater, and join being uniting two trees whose keys in one tree are all less than some value and the other all greater)
08:13:58 <ski> bgamari : it's not a function, it's an `m'-action (no `->'s there, so no function)
08:13:59 <Jafet> Well, that happens to be the best order for the list monoid.
08:14:11 <Favonia> parcs: ski: sad to hear that. is it reasonable to have one then? for example I might want a default map type for every types... except maybe Int or ().
08:14:13 <Jafet> Okay, I see what you mean.
08:14:14 <Peaker> Jafet: and perhaps other monoids
08:14:36 <Jafet> If it's not the best order, though, I don't get why you'd want to use it for other monoids
08:15:02 <Peaker> Jafet: you might want to use it for other monoids for which it is the best order too.. e.g ListT
08:15:02 <ski> bgamari : it's an action that when run in an `m'-monad (for any `m' in class `PrimMonad', i think basically `IO' and `ST s' at least), will yield a value of type `Gen (PrimState m)'
08:15:15 <Peaker> you could call it RassocMappend, and also have BalancedTreeMappend
08:15:58 <Jafet> Monoid transformers!
08:16:02 <Peaker> :-)
08:16:12 <ski> bgamari : it probably accesses the global `StdGen' in `IO', and (allocates and) contructs a `Gen (PrimMonad m)' from that
08:16:56 <Peaker> RAssocMonoid could use: (Monoid m => m -> m) representation. For BalancedTreeMappend you might want (Monoid m) => [m] ? Though that's a bit less efficient, more intermediate values
08:22:37 <bgamari> ski: Ahhh, I see
08:23:37 <bgamari> ski: It looks like create just initializes the RNG from a default seed
08:24:31 <bgamari> ski: What exactly is s in Gen s?
08:25:13 <bgamari> I guess it's the type of the RNG state?
08:25:50 <bgamari> ski: And PrimState is?
08:27:44 <bgamari> I guess Control.Monad.State isn't in PrimMonad?
08:29:37 <ski> bgamari : i assume just `IO' and `ST s' are in `PrimMonad'
08:29:42 <ski> (docs should tell)
08:30:07 <ski> some monads built on those should also be possible to put in the class, i suspect
08:31:02 <ski> bgamari : presumably, `PrimState m' is just meant to abstractly refer to the underlying PRNG state that is used in the `m' monad
08:31:27 <ski> which probably is allowed to be implemented differently, for different monads `m'
08:34:52 <b0fh_ua> Hi! How to compare by second item in tuple? compare . snd seems not right solution?
08:34:55 <erus`> with record sytax
08:35:08 <erus`> can i modify an unknown
08:35:14 <ion> :t compare
08:35:15 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
08:35:18 <ion> :t comparing
08:35:19 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
08:35:23 <Peaker> droud: I'm curious about your progress :-)
08:35:34 <ion> :t (compare `on`)
08:35:35 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
08:35:57 <Peaker> could be nice if type variable names could be canonized
08:36:10 <Peaker> to more easily eye-compare types
08:36:23 <erus`> modifyB a b c = a {b c}
08:36:42 <erus`> > modifyB a b c = a {b c}
08:36:43 <lambdabot>   <no location info>: parse error on input `='
08:37:05 * wli-needjob has generally used Haskell more for scripting-like tasks where others might use perl than the higher-flown tasks generally described here. Sadly, most of what gets made use of in the language is easily-GC'd list and string processing (the latter of which isn't even one of Haskell's particularly strong points).
08:37:36 <erus`> > modifyB a b c = a {b = c}
08:37:37 <lambdabot>   <no location info>: parse error on input `='
08:38:20 <Peaker> erus`: you can use fclabels to generate "labels" for your record fields
08:38:31 <Peaker> erus`: then you can take a label as an argument and use it to set fields
08:43:25 <wli-needjob> In particular generating reports from logs of kernel crap or benchmark runs and doing statistical bullcrap on them.
08:43:58 <dainanaki> Is there an existing function to make all path separators in a FilePath unix style?
08:44:37 <bgamari> ski: Thanks
08:45:24 <ion> dainanaki: Based on what input?
08:47:31 <dainanaki> ion, I just have a file path that is either foo/bar or else foo\\bar.
08:47:52 <dainanaki> I want to normalize all of the foo\\bar type into foo/bar
08:47:52 <ion> % echo baz > 'foo\bar'; ls -l 'foo\bar'
08:47:52 <ion> -rw-r--r-- 1 ion ion 4 2011-06-25 19:18 foo\bar
08:47:56 <ion> What would you do with that file?
08:48:53 <dainanaki> check for its existence in a relative path.
08:49:54 <ion> Why are you getting paths with Windows™-style directory separators on something Unix-ish in the first place?
08:50:22 <dainanaki> parsing cpp files. not that odd to see windows style separators sometimes
09:10:50 <parcs> @hoogle normalise
09:10:51 <lambdabot> System.FilePath.Posix normalise :: FilePath -> FilePath
09:10:51 <lambdabot> System.FilePath.Windows normalise :: FilePath -> FilePath
09:11:39 <parcs> > normalise "\foo\bar"
09:11:40 <lambdabot>   Not in scope: `normalise'
09:12:12 <ion> ghci> normalise ("normalise" :: Language.English.British.String) :: Language.English.American.String
09:12:15 <ion> "normalize"
09:15:18 <dainanaki> On my system, it actually is normalize. Go figure. In any case, that doesn't do what I'm wanting
09:16:48 <dainanaki> argh
09:17:16 <dainanaki> I meant to say the function is named normalise.
09:19:01 <hpaste> “Mukesh Tiwari” pasted “SPOJ MAIN8_C” at http://hpaste.org/48308
09:22:47 <hpaste> “Mukesh Tiwari” annotated “SPOJ MAIN8_C” with “SPOJ MAIN8_C (annotation)” at http://hpaste.org/48308#a48309
09:29:02 <danharaj> hmm
09:29:14 <danharaj> if I want lazy search trees, finger trees are probably my best bet for implementation, huh?
09:31:42 <c_wraith> I don't know how well finger trees do in a lazy setting
09:31:57 <c_wraith> though, I guess it depends on if you can add/remove elements
09:32:13 <c_wraith> If you can't, and it's just an infinite search through pre-determined elements, of course it's fine
09:32:26 <c_wraith> (or not even infinite, I guess)
09:44:40 <absence> sjoerd_visscher: ah, thanks though :)
09:47:12 <absence> if i have a function f and an integer n, how can i get f . f . f . f if n = 4, f . f if n = 2, etc?
09:48:26 <pedro3005> absence, I think iterate does that
09:48:43 <pedro3005> :t iterate
09:48:44 <lambdabot> forall a. (a -> a) -> a -> [a]
09:49:13 <monochrom> > iterate f x !! 5
09:49:14 <lambdabot>   f (f (f (f (f x))))
09:49:36 <monochrom> \x -> iterate f x !! 5  or roll your own
09:50:05 <ddarius> If f is strict, that's a bad way of doing it.  It's also not a great way when f is non-strict.
09:50:17 <pedro3005> > (iterate (2*) !! 5) 1
09:50:18 <lambdabot>   Couldn't match expected type `[a]' against inferred type `t -> [t]'
09:51:06 <absence> that example ends up calling the function instead of returning f . f . f . f . f
09:51:12 <Tomsik> @pl \f -> f . f . f . f
09:51:13 <lambdabot> ap (.) (ap (.) (join (.)))
09:51:21 <Tomsik> not too good
09:51:42 <ddarius> absence: Hence monochrom lambda abstracting.
09:52:27 <pedro3005> > (iterate (2*) 1 !! 5)
09:52:28 <lambdabot>   32
09:52:29 <azaq23> > let p = iterate (*2) 1 !! 5 in p == 2^5
09:52:29 <lambdabot>   True
09:53:21 <absence> ah right :) thanks
09:53:28 <pedro3005> > let g f x n = iterate f x !! n in g (*2) 1 5 == 2^5
09:53:29 <lambdabot>   True
09:53:49 <absence> ddarius: you said it was not a great way, are there others?
09:53:59 <ddarius> Of course there are other ways.
09:54:16 <xil> Hi. I'm having some noob-ish problems I'm hoping someone could help me with. I have an OpenGL program that works fine with a function I have that just returns (0.0,0.0). That was a placeholder, though, and when I wrote the function to replace it all of a sudden the program doesn't work. It compiles and starts but it never get's to draw anything, it just gets stuck, and the only way to close it is to find the process and kill it. So
09:55:48 <monochrom> > foldl (.) id (replicate n f)
09:55:49 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
09:55:49 <lambdabot>         against inferred type ...
09:55:59 <monochrom> > foldl (.) id (replicate 5 f)
09:55:59 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
09:56:00 <lambdabot>    arising from a use of `...
09:56:10 <ddarius> (.) is non-strict.
09:56:12 <monochrom> oh, not showable
09:56:18 <Tomsik> @pl let z g n = if n == 0 then g else g . (z g (n-1)) in z
09:56:19 <lambdabot> fix (ap (ap . flip (if' . (0 ==))) . liftM2 (.) (.) . flip flip (subtract 1) . ((.) .))
09:56:22 <Tomsik> ghh
09:56:34 <monochrom> foldr or foldl (.) id (replicate 5 f)  as you wish
09:58:19 <absence> monochrom: thanks! i tried fold initially, but didn't think to use id as initial value
09:59:07 <sjoerd_visscher> instance Num (Endo a) where
09:59:07 <sjoerd_visscher>   fromInteger 1 = Endo id
09:59:07 <sjoerd_visscher>   Endo f * Endo g = Endo (f . g)
09:59:14 <sjoerd_visscher> plus5 = appEndo (Endo (+1) ^ 5)
09:59:40 <ddarius> > foldl' id x (replicate 4 f)
09:59:41 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> a
10:00:15 <ddarius> sjoerd_visscher: We should really generalize (^) to all monoids.
10:00:49 <ddarius> (And (^^) to all groups, but that would require having a group class.)
10:00:55 <sjoerd_visscher> ddarius: even better!
10:02:07 <tswett> Can hsplugins be gotten via cabal?
10:02:27 <mjo> Can't you use foldl1 and skip the id ?
10:02:39 <ddarius> mjo: No
10:02:48 <mjo> ddarius: Why not ? :)
10:03:00 <jmcarthur> http://hackage.haskell.org/packages/archive/monoids/0.2.0.3/doc/html/Data-Monoid-Combinators.html
10:03:05 <nus> xil, your message got cut at "... kill it. So"
10:03:05 <ddarius> > foldl (.) id [] 4
10:03:06 <lambdabot>   4
10:03:13 <ddarius> > foldl1 (.) [] 4
10:03:14 <lambdabot>   *Exception: Prelude.foldl1: empty list
10:03:19 <jmcarthur> replicate f 5   -- FTW!
10:03:39 <Peaker> @src foldl1
10:03:39 <lambdabot> foldl1 f (x:xs) = foldl f x xs
10:03:39 <lambdabot> foldl1 _ []     = undefined
10:03:39 <mjo> ddarius: Noted
10:03:45 <xil> So I would think there is something wrong in my function. This is what I have so far http://pastebin.com/QkBr49DP any ideas?
10:03:48 <mauke> The paste QkBr49DP has been copied to http://hpaste.org/48310
10:03:52 <Peaker> @src foldr1
10:03:52 <lambdabot> foldr1 _ [x]    = x
10:03:52 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
10:03:52 <lambdabot> foldr1 _ []     = undefined
10:08:30 <bgamari> ski: Seems the memory leakage problems are still quite pronounced
10:09:48 <c_wraith> bgamari: still working on that same simulator?
10:10:22 <bgamari> c_wraith: Yep
10:10:38 <bgamari> c_wraith: Still chewing up 30% of CPU time in the GC
10:10:53 <bgamari> and eating massive quantities of memory
10:11:10 <bgamari> Have you ever found looking at the produced Core code to be productive?
10:11:36 <c_wraith> I have little experience with it...  But it can sometimes be useful.  especially with the ghc-core program, which syntax-highlights it, etc
10:12:52 <bgamari> c_wraith: Cool, good to know
10:14:13 <xil> I've narrowed down my problem a bit. It appears to be with the tuples in the list, but I haven't the faintest clue what is wrong with them. When I replace them with (0,0) it seems to work
10:15:18 <bgamari> c_wraith: Is there anything in particular you would look for to diagnose a memory issue?
10:15:56 <c_wraith> bgamari: I'd be looking at the heap profile, to figure out what the memory is being used by.
10:16:23 <bgamari> c_wraith: Perhaps I'm using it wrong but it really hasn't been helpful
10:16:24 <xil> okay figured it out
10:16:37 <bgamari> cwillu_at_work: I know that the descriptor doing the allocation is :
10:16:47 <c_wraith> heh.  misfire. :)
10:16:52 <bgamari> c_wraith: And the objects are of type []
10:16:57 <Peaker> xil: you should make a little function: f x | x >= 0 = x - 2  | otherwise = x + 2
10:17:10 <Peaker> xil: (in two lines).. and use  comparing fst  instead of the lambda compare there
10:18:42 <xil> Peaker: aha, that would be a good way to do that, thanks. That's sort of my problem right now. I'm still very new to Haskell and am still figuring out better coding practices. The environment is just so weird still
10:18:58 <bgamari> c_wraith: The cost ceneter is (404) main
10:19:11 <bgamari> c_wraith: Is there any way to turn that into a more useful location?
10:19:12 <c_wraith> bgamari: where's your current code?
10:19:22 <c_wraith> bgamari: you can add SCC annotations.
10:19:50 <hpaste> “Ben Gamari” pasted “GC churn” at http://hpaste.org/48311
10:19:55 <bgamari> there
10:20:05 <bgamari> although perhaps github would make more sense at this point
10:21:20 <c_wraith> how long is fretEffs, anyway?  (rough estimate is fine)
10:21:24 <fasta> Can I reinstall all my packages somehow?
10:21:34 <fasta> (without writing a program myself which does that)
10:22:09 <bgamari> c_wraith: SCC?
10:22:14 <djahandarie> bgamari, it might be worth it to switch off of read to an actual parser, and off of lazy IO maybe also. Both of those are deathly slow.
10:22:14 <bgamari> c_wraith: 80000 points
10:22:45 <bgamari> djahandarie: Yeah, I see that in the profile, there's a few seconds of churning before the memory usage begins skyrocketing
10:22:53 <hpaste> PeakerFixes annotated “http://pastebin.com/QkBr49DP” with “http://pastebin.com/QkBr49DP (annotation)” at http://hpaste.org/48310#a48312
10:22:54 <mauke> The paste QkBr49DP has been copied to http://hpaste.org/48310
10:23:23 <monochrom> try "cabal install --dry-run world" for a preview. see if you like the preview list. if you like it, omit --dry-run to commit
10:23:35 <bgamari> djahandarie: But at this point I just want to get it not using gigabytes of memory
10:23:37 <c_wraith> bgamari: SCC annocations are cost center annotations...  They let you specify cost centers more specifically than just per function
10:23:41 <Peaker> xil: look at the annotation I added
10:23:44 <bgamari> djahandarie: parsing speed is the least of my worries
10:23:52 <djahandarie> Okay.
10:24:08 <bgamari> I gave up on switching away from System.Random as well, for the time being
10:24:08 <Peaker> xil: more lines, but I think it is more readable
10:24:49 <Peaker> System.Random has some serious laziness problems
10:25:47 <monochrom> the program uses replicateM (with Control.Monad.State.Lazy) to define a lazy list, and then consumes it by writing to files
10:26:45 <monochrom> while we know how to arrange the consumers so that the lazy list doesn't get stuck forever in memory, we still get a lot of list cells produced and garbage collected perpetually
10:27:03 <monochrom> doing away with the whole replicateM approach will solve this
10:27:38 <bgamari> monochrom: You think?
10:27:46 <monochrom> I think.
10:27:50 <bgamari> monochrom: Hmm
10:28:32 <monochrom> if you think there is fusion deforestation magic, yes there is fusion deforestation magic IF THE PLANETS ALIGN
10:28:32 <c_wraith> yeah, I just came to the conclusion that replicateM is the only thing allocating (:) constructors
10:28:53 <bgamari> Alright, excellent
10:29:20 <xil> Peaker: thanks! That's much much better. And that gives me a better idea of how to approach stuff like this in the future too. I really appreciate it
10:29:49 <c_wraith> What's funny is that the only reason you're using State at all is to use replicateM.  so if you get by without replicateM, you can avoid using State, too
10:30:07 <dylukes> Alright. byorgey, you still around?
10:30:07 <bgamari> I'll add an SCC to the evalState expression
10:30:17 <dylukes> I think I'm now in the mental state to actually go through and resolve the type issues I'm having
10:30:32 <Peaker> xil: sure, you're welcome :)
10:30:34 <dylukes> wait. whoops. I deleted it.
10:30:40 <dylukes> lemme rewrite what I had...
10:30:54 <monochrom> if you move to StateT Timestep IO (), you can preserve 95% of your current code
10:31:19 <Peaker> xil: on second thought I'd get rid of ox and oy and just put "move x" and "move y" inline in the pair list
10:32:06 <xil> Peaker: ah, even better, haha
10:33:08 <Peaker> xil: why do you do the move thing btw?
10:33:28 <bgamari> c_wraith, monochrom: Odd, I put an SCC at the evalState expression but it didn't show up in the profile
10:33:54 <monochrom> I personally disbelieve the profiler altogether
10:34:07 <bgamari> c_wraith, monochrom: but I then put an SCC in the join expression on the next line
10:34:16 <bgamari> which did show up
10:34:37 <bgamari> it seems this is where the explotion is occurring
10:35:19 <xil> okay another thing. I want get generate a list of lists of random numbers. What I do now is use randomRs to get an infinite list and then I wrote a function to go through it and group elements in groups of some fixed size. Is there possibly a better what to do that?
10:35:58 <monochrom> > catMaybes [Nothing, Just 1, Nothing, Just 2]
10:35:58 <lambdabot>   [1,2]
10:36:33 <monochrom> > join (***) catMaybes ([Nothing, Just 1, Nothing, Just 2], [Nothing, Just 1, Nothing, Just 2])
10:36:34 <lambdabot>   ([1,2],[1,2])
10:36:41 <dylukes> :t (***)
10:36:42 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
10:36:50 <dylukes> :t join
10:36:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:36:56 <dylukes> oh great, arrows.
10:37:01 <monochrom> > join (***) catMaybes ([Nothing, Just 1, Nothing, Just 2], [Nothing, Just 1, Just 3, Just 2])
10:37:01 <lambdabot>   ([1,2],[1,3,2])
10:37:08 <djahandarie> :t join (***)
10:37:09 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
10:37:21 <djahandarie> :t join (***) :: (b -> c) -> (b, b) -> (c,c)
10:37:25 <lambdabot> forall b c. (b -> c) -> (b, b) -> (c, c)
10:37:49 <djahandarie> Just being used as useful combinators for functions, rather than using them in their general sense.
10:38:01 <Peaker> @type randomRs
10:38:01 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
10:38:41 <Peaker> Is there a random generation function encapsulated in a State constructor so you can >>= the random generation seed plumbing?
10:39:19 <aavogt> @hackage MonadRandom
10:39:19 <lambdabot> http://hackage.haskell.org/package/MonadRandom
10:39:23 <bgamari> There's RandomMonad
10:39:32 <bgamari> Right, MonadRandom
10:40:16 <aavogt> or without using another library, you could just call randomIO
10:41:13 <bgamari> At some point I want to figure out how to use random-fu since I'll likely be using it for other projects in the future
10:41:37 <bgamari> but unless the random number generation is the source of my memory issues, I'd rather focus on the problem at hand for now
10:42:13 <cvic> hm, have you tried some profiling?
10:42:29 <bgamari> Yes, I just realized you can set arbitrary SCCs
10:42:34 <dylukes> bgamari: A pseudorandom number generator is deterministic. Generally you reseed it with R(n) to produce R(n+1).
10:42:41 <dylukes> The gist is always that you need to provide a new value each time.
10:42:58 <bgamari> which tracked the problem down to             (acceptorTs, donorTs) = {-# SCC "times" #-} join (***) catMaybes (unzip times)
10:43:05 <bgamari> dylukes: Yes, I know. And I do this
10:43:05 <dylukes> It'll never quite be as "easy" as in an imperative language unless you're using randomIO
10:43:20 <cvic> All you need is monads
10:43:23 <cvic> Haha
10:43:35 <cvic> What's SCC?
10:43:54 <aavogt> it shows up in a profile
10:44:13 <bgamari> dylukes: Fair enough, but the I think I have the random number generation figured out for now
10:44:23 <cvic> The SCC comments are for profiling.
10:44:24 <bgamari> cvic: A cost center
10:44:26 <cvic> Ah, interesting
10:44:30 <cvic> Yeah, googled it
10:44:32 <bgamari> aavogt: What does?
10:44:56 <fasta> Is there some good tool to find stack overflows now?
10:45:07 <bgamari> c_wraith, monochrom: Any ideas what might cause the join expression to explode in memory usage?
10:45:20 <dylukes> @src join
10:45:20 <lambdabot> join x =  x >>= id
10:45:31 <bgamari> c_wraith, monochrom: Or how to track down the issue further
10:45:31 <nus> bgamari, now you could roll your own catMaybes and unzip,  to put SCC on 'em
10:45:45 <dylukes> What's SCC out of curiosity?
10:46:03 <monochrom> join (***) catMaybe (unzip x y) produces more lists from lists
10:46:12 <bgamari> dylukes: It allows you to set an expression which the profiler will track
10:46:24 <dylukes> ah I see.
10:46:32 <dylukes> @src catMaybes
10:46:32 <lambdabot> catMaybes ls = [x | Just x <- ls]
10:46:35 <dylukes> oh god its TH.
10:46:35 <bgamari> monochrom: So why wouldn't this be lazy?
10:46:40 <dylukes> wait, no.
10:46:41 <dylukes> whew.
10:47:38 <monochrom> it is lazy
10:47:40 <nus> it is lazy. the string is where all consing happens
10:47:42 <Peaker> xil: you could use MonadRandom, and do something like:  randomSequence = do { n <- random ; replicateM n random }     and then:  replicateM someLength randomSequence
10:47:44 <aavogt> bgamari: an SCC
10:47:48 <monochrom> > "lazy" == "non-existent"
10:47:49 <lambdabot>   False
10:48:47 <nus> @src unzip
10:48:47 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
10:48:54 <bgamari> s/wouldn't this be lazy/would this force the allocation of millions of lists
10:49:14 <cvic> dylukes: good example http://stackoverflow.com/questions/5707250/optimizing-numerical-array-performance-in-haskell
10:50:25 <monochrom> with good probability you have a million creations and forgettions of list cells
10:50:28 <aavogt> bgamari: I didn't know about random-fu. It looks quite useful
10:50:37 <bgamari> aavogt: Indeed
10:51:39 <xil> Peaker: where does MonadRandom come into that?
10:51:44 <bgamari> monochrom: I just don't understand or even how to gain understanding of why this is the case
10:52:01 <Peaker> xil: randomSequence uses random generation as a monad ("do" block and replicateM)
10:52:44 <dylukes> Hm I haven't ever had to do code optimization.
10:52:46 <xil> Peaker: oh I thought by "MonadRandom" you meant a package called MonadRandom, so I looked it up, haha. Yeah so that would work for me, thanks again!
10:53:18 <monochrom> do you understand "foldl' (+) 0 (replicate 100 0)"?
10:53:18 <bgamari> dylukes: Somehow this is my first project and I'm already forced to look at Core to even get half-useable performance
10:53:28 * bgamari won't be buying a lottery ticket any time soon
10:53:51 <djahandarie> bgamari, that's because you had "fast" in your first project's description.
10:53:59 <Peaker> xil: though the name is "getRandomR" and not "random"
10:54:05 <bgamari> djahandarie: I suppose this is true
10:54:22 <bgamari> djahandarie: Although I didn't think runtime less than that of python would be considered "fast" ;)
10:54:25 <Peaker> xil: MonadRandom is indeed a package that provides a random generation monad -- so you don't have to manually chain the random generator state arg/result
10:54:27 <sjoerd_visscher> edwardk: do you already have something like this somewhere: https://gist.github.com/1046740, and if not, could it be useful?
10:54:30 <bgamari> I really do appreciate the help
10:55:05 <bgamari> monochrom: It should just give you a list of 100 0s, no?
10:55:17 <monochrom> no
10:55:19 <djahandarie> bgamari, going slower than python has honestly never happened to me.
10:55:24 <xil> Peaker: for an infinite list could I, instead of using replicateM n randomSequence, do sequence $ replicate randomSequence? Or does that strictly compute all of the calls to randomSequence?
10:55:44 <bgamari> monochrom: Oh, right, just 0
10:55:52 <Peaker> xil: replicateM n x = sequence (replicate n x)
10:55:56 <monochrom> replicateM and sequence (replicate ...) are same difference
10:56:34 <bgamari> djahandarie: Yeah, I seem to have a perfect storm of a difficult problem and little Haskell experience
10:56:44 <xil> I see....so I can't do infinite stuff with it
10:57:06 <Peaker> xil: replicateM is for finite sequences
10:57:09 <djahandarie> bgamari, I can do a pass on your code at some point later when I'm not busy, maybe I'll be able to fix it up.
10:57:15 <Peaker> @src repeatM
10:57:15 <lambdabot> Source not found. You type like i drive.
10:57:15 <monochrom> replicate produces one list cell, fold' consumes it, then replicate produces another list cell, then foldl' consumes it, ... 98 more of this
10:57:27 <bgamari> djahandarie: It would be appreciated if you could get a chance
10:57:35 <bgamari> monochrom: Right
10:57:39 <NPZimm> i have a very noob question about one of the examples in learn you a haskell, would anyone be willing to converse with me so that i don't pollute the channel?
10:57:42 <Peaker> xil: forever is basically replicateM infinite
10:57:49 <Peaker> @src forever
10:57:49 <lambdabot> Source not found. The more you drive -- the dumber you get.
10:57:56 <bgamari> monochrom: And I guess the list cell creations aren't optimized out
10:57:57 <monochrom> luckily no one else sees the list cells, so the list cells are promptly available for GC
10:58:01 <xil> Peaker: but would that be lazily processed?
10:58:21 <bgamari> monochrom: But my memory usage is still monotonically increasing in time
10:58:25 <Peaker> xil: actually it is more like replicateM_ infinite.. forever doesn't have a list result
10:58:34 <osfameron> NPZimm: you should always ask in channel, but use a pastebot for any code examples (hpaste.org as per /topic, for example)
10:58:36 <monochrom> oh then you're doing it wrong again
10:58:52 <bgamari> monochrom: It wouldn't be as bad if I was just battling 90% GC time
10:59:11 <Peaker> > sequence (repeat [0])
10:59:12 <lambdabot>   *Exception: stack overflow
10:59:16 <bgamari> monochrom: But yes, it seems I screwed up
10:59:29 <monochrom> in particular having separate save "donor.txt" donorTs and save "acceptor.txt" acceptorTs look suspicious
10:59:52 <xil> Peaker: I think it's too much for me right now, haha, but I'll use the finite version where applicable, thanks
10:59:56 <bgamari> I can go back to the combined save
11:00:36 <Peaker> xil: I am not sure if you can use sequence on the result of repeat in the random monad (though I *think* it should work with some monads at least)
11:02:28 <xil> Peaker: I'll probably try it some time with a monad or 2. The stuff I'm trying to do now uses a few monads that might be applicable, but I shouldn't be getting to that for a while. Thanks for all the help though!
11:02:48 <bgamari> monochrom: I thought we had realized yesterday that the cause of my problems was that I was compiling without optimizations due to -prof
11:02:49 <edwardk> sjoerd_vissher: i started one, i have versions of them for reader and store
11:03:01 <bgamari> monochrom: So can I really trust the heap profiling?
11:03:34 <monochrom> I compiled your yesterday code with -O or -O2, no profiling, so I know real causes yesterday
11:03:54 <sjoerd_visscher> edwardk: do you have use cases for them?
11:04:02 <bgamari> monochrom: Combining the saves in a single lambda iterating over with forM2_ doesn't help
11:04:32 <edwardk> sjoerd_visscher: the store one is quite compelling as a memoized experiment monad. so if you ask it to rerun a given experiment it'll give you the previously tabulated answer.
11:04:47 <monochrom> forM_ times $ \ (am, dm) -> do { maybe (return ()) (hPrint af) am; maybe (return ()) (hPrint df) dm }
11:04:52 <fasta> I get a Stack space overflow and Main.CAF is mentioned last. Does that mean that I have written down something like x=x at the top-level?
11:04:54 <edwardk> the state version is somewhat less compelling to me, because rarely do my state monads 'loop' back to a previous state.
11:04:59 <monochrom> where af, df are from openFile
11:05:23 <monochrom> your combined save yesterday was wrong as well
11:05:33 <bgamari> Ouch
11:05:42 <edwardk> sjoerd_visscher: http://hackage.haskell.org/package/comonad-extras has the first version i did, back based on MemoTrie instead of representable-tries
11:05:57 <edwardk> i need to upgrade it to work with representable-tries
11:06:41 <edwardk> that package also has a cute comonad for working in a zipper of some traversable
11:06:50 <sjoerd_visscher> why tries and not just any representable?
11:07:39 <edwardk> well, representable-tries is basically any representable-functor, just providing a type mapping from a to the suitable functor rather than making the user supply f.
11:07:53 <edwardk> that way the MemoStateT s m a has the same signature.
11:07:56 <bgamari> monochrom: Because I used catMaybes before iterating to write out?
11:08:16 <bgamari> :t maybe
11:08:17 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
11:08:36 <edwardk> i have the reader-based version of this for representable RepT f, but i also have (:->:) e which requires less thought to use ;)
11:08:42 <monochrom> not that simple
11:09:20 <edwardk> the equivalent of the latter would probably be build on the former though. so you're right
11:10:02 <fasta> Is there any tool which just shows me how my stack is filled with calls to functions?
11:10:44 <fasta> Alternatively, a tool which shows how functions are strict or lazy in their arguments would also be ok.
11:10:51 <char> \help
11:11:04 <wli-needjob> Not function calls, heap nodes. "The spine" is most often talked about.
11:11:23 <bgamari> monochrom: Care to elaborate
11:11:29 <fasta> wli-needjob: but ghc says my stack overflows.
11:11:39 <sjoerd_visscher> edwardk: btw, I really enjoyed your blogposts, thanks for those!
11:11:44 <bgamari> monochrom: Also,
11:11:44 <bgamari>     Couldn't match expected type `t0 -> t1 -> t2 -> m0 b0'
11:11:45 <bgamari>                 with actual type `()'
11:11:45 <bgamari>     In the first argument of `return', namely `()'
11:11:55 <wli-needjob> fasta: It's not a stack of function calls analogously to e.g. C.
11:12:28 <edwardk> sjoerd_visscher: i'm glad. =) i was writing up the proof of correctness at work, then decided that none of our competitors care about type theory, so decided to blog it instead.
11:12:33 <fasta> wli-needjob: so, I can just use heap profiling?
11:13:07 <wli-needjob> fasta: I'm not an expert with the tools... you'll have to hit up someone more knowledgeable here.
11:13:34 <fasta> wli-needjob: Oh, I am skilled with the old tools, apparently those are still in use.
11:15:10 <edwardk> i'm debating about doing a similar one on the free vector space monad, then improving it by taking its free monad so you can do importance sampling, when you use it for probability distributions, then i can show that if i take codensity of that i get hansei, but since its a free monad i can use this trick
11:15:29 <sjoerd_visscher> edwark: I was also playing with the adjunctions package, but found out that disappointingly adjunctions don't really offer anything beyond representables
11:15:32 <edwardk> giving a relatively cheap encoding for a probability monad
11:15:45 <edwardk> well, they offer a monad and a comonad
11:16:08 <bgamari> monochrom: Sorry, missing ;
11:16:12 <sjoerd_visscher> they are the monad and comonad we just discussed
11:16:21 <edwardk> and you can use them to sandwich an monad, yielding StateT and their ilk. keep in mind adjunctions
11:16:37 <edwardk> are not limited to being from Hask -> Hask
11:17:01 <edwardk> good point
11:17:07 <bgamari> monochrom: Your approach seems to work
11:17:15 <bgamari> monochrom: I no longer leak
11:17:36 <bgamari> monochrom: so why exactly was my approach leaking?
11:17:45 <bgamari> Using leak loosely
11:17:50 <dylukes> :t leak
11:17:51 <lambdabot> Not in scope: `leak'
11:18:10 <cvic> leaky abstractions
11:18:14 <sjoerd_visscher> edwardk: maybe you could add this function
11:18:15 <sjoerd_visscher> split :: Adjunction f u => f a -> (a, f ())
11:18:15 <sjoerd_visscher> split = rightAdjunct (flip leftAdjunct () . (,))
11:18:22 <edwardk> sjoerd_visscher: then your representable StateT and StoreT are basically a lighterweight version of http://hackage.haskell.org/packages/archive/adjunctions/1.0.0/doc/html/Control-Comonad-Trans-Adjoint.html and http://hackage.haskell.org/packages/archive/adjunctions/1.0.0/doc/html/Control-Comonad-Trans-Adjoint.html
11:18:31 <hpaste> monochrom pasted “how to grow a blow” at http://hpaste.org/48315
11:18:50 <monochrom> http://hpaste.org/48315 completely models the memory growth yesterday
11:18:56 <bgamari> monochrom: Thanks
11:18:57 <edwardk> i like that one
11:19:11 <sjoerd_visscher> edwardk: yeah, that's how I started out
11:19:18 <cvic> :t mapM_
11:19:19 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
11:19:20 <sam8> hi can I get some help on Int and Integer?
11:19:21 <sam8> http://hpaste.org/48314
11:19:26 <edwardk> that encapsulates the property that the left adjoint (in the Hask - Hask) case has exactly one slot in it
11:19:27 <monochrom> if you understand this model, your code yesterday was merely a beefed up disguise on steroid
11:19:29 <sam8> I want to get rid of fromIntegral
11:19:36 <bgamari> monochrom: Is there any clean way to split out times into two lists without exploding memory usage?
11:19:53 <edwardk> sjoerd_visscher: i'll probably roll all of these in
11:20:16 <monochrom> understand my model first
11:20:29 <bgamari> monochrom: Taking a look at it
11:21:06 <iwtu> ski: hi! have some time during tea break? :)
11:21:09 <cvic> :t fmap
11:21:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:21:16 <edwardk> sjoerd_visscher: there should also be a similar structure for corepresentables that yields something like http://hackage.haskell.org/packages/archive/adjunctions/1.0.0/doc/html/Control-Monad-Trans-Contravariant-Adjoint.html
11:21:23 <edwardk> feeling ambitious? =)
11:22:29 <sam8> what is the difference between fmap and map exactly?
11:22:42 <edwardk> map is limited to lists
11:22:42 <sjoerd_visscher> feeling bored, so I will take a look :)
11:22:45 <monochrom> fmap is more general
11:22:49 <wli-needjob> map is what fmap should be called.
11:23:34 <bgamari> monochrom: Ahh, I see
11:24:04 <bgamari> monochrom: So the positions of the two "current" items in the filtered lists are drifting apart?
11:24:11 <monochrom> yes.
11:24:19 <bgamari> That does make sense
11:24:25 <bgamari> and would certainly happen in my case
11:24:36 <bgamari> You are definitely right
11:25:21 <cvic> sam8: that's one complicated function
11:25:23 <monochrom> make sure your donorTs and acceptorTs are in sync. no matter whether you zip, unzip, or whatever
11:25:42 <sam8> yes... I'm trying to make it more readable...
11:25:44 <monochrom> or rather, your donorTs and acceptorTs consume times in sync
11:25:54 <cvic> sam8: you wrote it?
11:25:55 <bgamari> monochrom: Yep, definitely
11:26:05 <bgamari> monochrom: I underestimated the drift apparently
11:26:22 <sam8> yes... but haskell is my first functional language for me... so its difficult and made it really more complicated that it is supposed to
11:26:34 <cvic> no problem
11:26:34 <sam8> it works but...
11:26:43 <cvic> Yeah, it needs refactoring
11:27:05 <cvic> maybe split it in a few simpler functions
11:27:55 <bgamari> monochrom: Thanks for all of your help!
11:27:57 <sam8> perhaps... I'll try it
11:28:07 <monochrom> you're welcome
11:28:09 <bgamari> Especially considering the problem was ultimately my own fault
11:28:16 <bgamari> I owe you more than a few beers
11:28:40 <djahandarie> Heh.
11:28:42 <djahandarie> monochrom++
11:28:57 <monochrom> use the scientific method. extract a model so simple that it demonstrates the problem and cause beyond question
11:29:52 <hpaste> npzimm pasted “tree fold display problem” at http://hpaste.org/48317
11:30:19 <cvic> sam8: the Matlab version is insane!  http://www.apfloat.org/numberth.m
11:30:22 <NPZimm> so, the issue is that the display on that fold doesn't work
11:30:26 <NPZimm> and i can't figure out why
11:30:28 <NPZimm> its like
11:30:49 <bgamari> monochrom: Better yet, with your approach it only spends 2% of time in the GC
11:30:56 <sam8> yes... good thing about haskell is I can compress it and make it clean...
11:31:01 <cvic> Yep
11:31:04 <sam8> but it gets more difficult to read because it is compressed...
11:31:11 <monochrom> that's a nice side effect
11:31:13 <cvic> So... you initial code is allright
11:31:35 <NPZimm> Node 1 (Node 1 (Node 1 (Node 1 (Node 1 EmptyTree)etc. etc.
11:31:35 <cvic> esp. if it works
11:31:43 <NPZimm> it doesn't display the correct node numbers
11:32:02 <mauke> NPZimm: "display"?
11:32:09 <monochrom> oh, but huge memory footprint increases GC time, naturally
11:32:11 <cvic> *Mathematica, not Matlab, my bad
11:32:39 <NPZimm> i'm sorry mauke, i don't follow
11:32:40 <mauke> NPZimm: your main problem is that treeInsert is completely broken
11:32:45 <NPZimm> oh
11:32:46 <mauke> NPZimm: this has nothing to do with folds or displays
11:32:51 <NPZimm> excellent
11:32:53 <NPZimm> i figured
11:33:06 <NPZimm> but looking at learn you a haskell
11:33:09 <NPZimm> i can't figure out why
11:34:05 <NPZimm> oh man
11:34:10 <NPZimm> i'm a complete idiot.
11:34:11 <NPZimm> i now see it.
11:34:16 <absence> if i have a list of words (that is, [String]), is there a simple way to merge them into a single string with commas between them? i tried foldr, but then i got a comma at the end as well
11:34:32 <Eduard_Munteanu> :t intercalate
11:34:32 <lambdabot> forall a. [a] -> [[a]] -> [a]
11:34:36 <Eduard_Munteanu> :intersperse
11:34:40 <Eduard_Munteanu> :t intersperse
11:34:40 <lambdabot> forall a. a -> [a] -> [a]
11:34:44 <bgamari> monochrom: Sound advice
11:34:45 <monochrom> > intercalate ", " ["you", "are", "ingenious"]
11:34:46 <lambdabot>   "you, are, ingenious"
11:35:05 <absence> \o/
11:35:08 <absence> thanks
11:36:07 <cvic> the \o/ operator
11:36:23 <cvic> :t isPrime
11:36:24 <lambdabot> Not in scope: `isPrime'
11:37:13 <sam8> give me a sec
11:37:27 <sam8> oh wait...
11:37:33 <cvic> For what?
11:37:39 <sam8> isPrime :: Integral int => int -> Bool
11:37:54 <cvic> I'm looking at isPrime :: Integer->Bool atm
11:38:16 <absence> if i want it to skip empty strings in the list, is combining it with filter my best option?
11:38:32 <cvic> Ah, wait. Nvm
11:38:35 <cvic> http://www.haskell.org/haskellwiki/99_questions/Solutions/31
11:39:46 <monochrom> yes, filter
11:40:33 <monochrom> statistically, primality is very difficult
11:40:42 <parcs> > transpose [[1]]
11:40:43 <lambdabot>   [[1]]
11:41:52 <cvic> sam8: how about primroot?
11:42:16 <cvic> sam8: http://hpaste.org/47963 ?
11:42:33 <edwardk> the asymmetry of Free being in comonad-transformers is driving me insane. i think it needs to go back in free, which means making a free-fd and free-extras.
11:42:52 <edwardk> to house the class and the yoneda-rec version
11:42:56 <edwardk> respectively
11:43:46 <edwardk> then while i rejigger the downstream dependencies i can add sjoerd's representable state and store
11:43:49 <wli-needjob> Trying to figure out how to use HaskellForMaths' Gröbner basis bits.
11:43:56 <sam8> yes
11:44:09 <cvic> returns all primitive roots modulo a given positive prime integer p
11:44:11 <cvic> Ok
11:44:17 <edwardk> wli: i should have a replacement for them soon
11:44:31 <edwardk> wli: when the other things that compete for my time die down
11:46:26 <hpaste> “Stoyan Peev” pasted “Parser” at http://hpaste.org/48318
11:46:29 * wli-needjob has several bigger issues anyway: (1) numerical solution of resulting systems (2) semi-algebraic-ness due to inequality constraints (3) generating the systems in the first place.
11:46:45 <cvic> sam8: ntt.hs:27:14: Not in scope: `primroot'. Hm
11:46:49 <cvic> One last piece
11:48:00 <sam8> http://hpaste.org/48319
11:48:40 <cvic> thanks
11:50:05 <sam8> http://hpaste.org/48320
11:50:16 <sam8> I just can't find why this is Int Integer error
11:51:05 <sam8> w is Integer type
11:51:34 <monqy> :t (!!)
11:51:36 <lambdabot> forall a. [a] -> Int -> a
11:51:46 <cvic> hm, what' the error?
11:51:52 <parcs> > transpose [[1,2,3],[],[1,2,3]]
11:51:53 <sam8> oh... its problem with !!
11:51:54 <lambdabot>   [[1,1],[2,2],[3,3]]
11:51:59 <cvic> Ah
11:52:10 <sam8> !! must take an Int not Integer?
11:52:49 <monqy> you either want to convert n or use genericIndex
11:52:56 <monqy> :t genericIndex
11:52:57 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
11:54:05 <sam8> does genericIndex have to be imported?
11:54:23 <monqy> it's in Data.List
11:54:54 <agumonkey> tryhaskell.org is pure awesome for the lazy
11:55:09 <cvic> agumonkey: also, flash
11:55:58 * agumonkey does not compute
11:56:30 <chrisdone> agumonkey: Thanks. :-)
11:56:31 <lambdabot> chrisdone: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:56:31 <cvic> Ahh, snap
11:56:44 <cvic> agumonkey: forgot it's not made in flash
11:56:47 <cvic> So nvm
11:57:24 <agumonkey> too late, my brain melted down because of too many attempts to parse your sentence
11:57:49 <cvic> Flash Gordon!
11:58:13 <agumonkey> oh I just notice chris done name below the repl. ahh so many times i wish i could do something like this. kudos
12:00:39 <chrisdone> cvic: Flash? I 'ardly know you!
12:01:05 <agumonkey> consider this a compliment
12:01:10 <agumonkey> so cute it must be flash right ?
12:01:41 <cvic> it's been awhile since I've played in tryhaskell
12:01:44 <cvic> now it's just ghci
12:01:55 <agumonkey> early versions where different ?
12:02:11 <cvic> No. It never was made in Flash
12:02:40 <chrisdone> agumonkey: Does it help you grok Haskell any?
12:03:19 <erus`> in the newest futurama bender doubles himself. then his doubles double themselves
12:03:20 <cvic> sam8: ntt [1,2,3]   -> [6,3,1]
12:03:37 <erus`> making the pattern 1 3 7 13
12:03:57 <sam8> here let me post my change
12:04:02 <erus`> how can i make it a recursive func?
12:04:30 <sam8> http://hpaste.org/48321
12:04:35 <sam8> made some changes
12:04:46 <cvic> yep, same here
12:04:53 <hpaste> absence pasted “can this be made more concise?” at http://hpaste.org/48322
12:05:05 <absence> http://hpaste.org/48322
12:05:06 <agumonkey> I mostly contemplate the live tutorial side of it
12:05:43 <absence> (also, why doesn't hpaste provide a link when it announces a new post?)
12:05:44 * hackagebot kan-extensions 0.5.1 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-0.5.1 (EdwardKmett)
12:05:44 <agumonkey> but I already know a nano bit of haskell, I was only there to avoid installing ghc * shame * and I wish more language had this
12:05:51 <cvic> tryhaskell is great for people too scared to install ghc on their computers
12:05:53 <agumonkey> even though you mention ruby
12:06:18 <agumonkey> haskell platform is really huge , scary even for me
12:06:33 <cvic> Start small
12:07:06 <agumonkey> but there's something fundamental i don't understand
12:07:14 <cvic> monads?
12:07:24 <agumonkey> lol no that's easy obviously
12:07:24 <Nisstyre> yes
12:07:29 * cvic grins 
12:07:36 <agumonkey> haskell is so high level, how come the platform is so large ..
12:07:54 <agumonkey> I'd thought that all source code would fit into 50MB
12:08:08 <cvic> it's not only Haskell
12:08:50 <cvic> there's C
12:08:57 <agumonkey> don't blame it on C
12:09:04 <cvic> No?
12:09:23 <cvic> Well, I'm not blaming, just saying
12:09:35 <chrisdone> agumonkey: GHC comes with four versions of the same core libraries (static, dynamic, interpreted, profiled).
12:09:36 <lfppv> hi, a friend of mine is doubting that the binary relation {(1,1), (2,2)} is transitive
12:09:38 <agumonkey> I was just kidding, I don't know
12:09:43 <lfppv> who's right ?
12:09:45 <lfppv> me or him
12:09:46 <lfppv> ?
12:10:22 <agumonkey> thanks chris, i did not know that
12:10:23 <chrisdone> agumonkey: So you essentially get four copies of GHC. Ruby, comparatively, comes with just one copy.
12:10:28 <monochrom> you can try #math. but it is transitive
12:10:58 <monochrom> try to understand the true meaning of "for all ... if ..."
12:11:10 <lfppv> monochrom, i know, but him and some others are insisting that it is not, i'm im starting to doubt my sanity lol
12:11:19 <monochrom> {} is a transitive relation, too, to bring "forall ... if ..." to its extreme
12:11:22 <cvic> agumonkey: http://stackoverflow.com/questions/4858585/why-is-ghc-so-large-big
12:11:26 <cvic> There
12:12:04 <monochrom> throw {} at them and blog their flawed reasoning. may be fun
12:12:45 <monochrom> eventually, show them my http://www.vex.net/~trebla/homework/empty.html
12:13:07 <agumonkey> this chan rox
12:13:24 <monochrom> there is a risk of increasing your good-friend : bad-friend ratio
12:13:50 <cvic> #haskell is made of Awesome
12:15:03 <cvic> and zygohistomorphic prepromorphisms
12:15:07 <agumonkey> funny I got on tryhaskell after watching a blogpost about 'haskell.org redesign' thinking it lacked some ajax ghci ..
12:17:22 <monochrom> chrisdone: the lib file for ghci is the usual machine-code *.o files. so yes there are files dedicated for ghci, but not "interpreted"
12:17:46 <cvic> and I finally found a monad tutorial *I* can understand http://ertes.de/articles/monads.html
12:18:25 <erus`> is there a function like: 1111 -> "One thousand, one hundred and 11"
12:18:36 <agumonkey> cvic: you should also try monads in other languages , I found them inspiring
12:18:53 <parcs> monads cured my alcoholism
12:20:14 <monochrom> typically the third tutorial is the one you finally understand
12:21:50 <cvic> agumonkey: like Scala
12:22:08 <agumonkey> yeah
12:22:12 <agumonkey> and clojure, scheme
12:22:36 <agumonkey> haskell syntax and type system makes some stuff hard to notice
12:22:50 * cvic still has a problem with parentheses
12:22:59 <cvic> So no Lisp. Doctor's orders
12:23:25 <agumonkey> respect the elders
12:23:30 <agumonkey> brb
12:23:48 <cvic> Right
12:24:14 <c_wraith> haskell goes out of its way to avoid parens. :)
12:24:39 <cvic> With the aid of some syntactic sugar
12:24:48 <cvic> I like that
12:24:49 <monochrom> not very out. just a bit
12:24:56 <agumonkey> haskell is the only language allowed to despise lisp pseudosyntax, because the infix operator thing is really neat
12:24:57 <joe6> i have a Word8 value and I want to show the byte, not the ascii value (as show does). any suggestions, please?
12:24:58 <cvic> $ and .
12:25:06 <c_wraith> cvic: those aren't syntactic sugar.
12:25:11 <cvic> I know
12:25:11 <c_wraith> cvic: those are just normal functions
12:25:14 <chrisdone> monochrom: Good point.
12:25:14 <cvic> those are functions
12:25:16 <monochrom> haskell doesn't force you to use $ and . .  I don't use $
12:25:34 <monochrom> rather, the $ people go out of their way, yes
12:25:35 <chrisdone> Apparently the bars and shops are open all night tonight due to some Saint day in Trento. Gonna go check it out.
12:26:16 <cvic> there is more than one way to do it
12:26:33 <zmv> c'mon, parens are sexy
12:31:32 <joe6> how can I output or write to a file a Word8 without converting the value into an ascii value?
12:32:13 <ClaudiusMaximus> @hoogle hPutBuf
12:32:14 <lambdabot> System.IO hPutBuf :: Handle -> Ptr a -> Int -> IO ()
12:32:14 <lambdabot> System.IO hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
12:32:20 <monochrom> probably best to do it through bytestring's I/O routines
12:32:31 <ClaudiusMaximus> @hoogle withArrayLen
12:32:32 <lambdabot> Foreign.Marshal.Array withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
12:32:32 <lambdabot> Foreign.Marshal.Array withArrayLen0 :: Storable a => a -> [a] -> (Int -> Ptr a -> IO b) -> IO b
12:32:47 * hackagebot Win32-junction-point 0.0.1 - Support for manipulating NTFS junction points.  http://hackage.haskell.org/package/Win32-junction-point-0.0.1 (MichaelSteele)
12:32:54 <monochrom> yeah, through hPutBuf is good too
12:33:06 <joe6> ok, thanks.
12:33:19 <ClaudiusMaximus> not recommending that too much though, because withArrayLen keeps a hold of the whole list as it computes the length
12:33:55 <ClaudiusMaximus> if you know the length, you can write a replacement to withArrayLen, but if you get the length wrong your program might segfault
12:34:18 <absence> http://hpaste.org/48322 <- can this be made more concise?
12:34:41 <balor> Is there any way to tell cabal to fix all the broken packages?
12:38:28 <joe6> ClaudiusMaximus: ok, thanks.
12:40:28 <jmcarthur> absence: might be able to save a couple characters here and there, but the overall structure looks about as tight as it's going to get without writing other new functions to use
12:43:39 <hpaste> siracusa annotated “can this be made more concise?” with “can this be made more concise? (annotation)” at http://hpaste.org/48322#a48325
12:44:10 <siracusa> Not sure if this is better :-)
12:44:19 <jmcarthur> it's "clever" ;)
12:44:50 <danharaj> clever is bad
12:45:09 <danharaj> ingenious is better :p
12:45:30 <cvic> simple is better
12:46:55 <absence> jmcarthur: what other new functions would that be?
12:47:00 <absence> siracusa: very nifty ;)
12:49:17 <danharaj> I think I might try to learn emacs soon.
12:49:22 <danharaj> I'm getting sick of using my mouse when coding.
12:49:41 <danharaj> or better... is Yi in a good state yet?
12:49:55 <jmcarthur> absence: i've often wished there was something like this:  ordering :: a -> a -> a -> Ordering -> a
12:50:31 <hpaste> jmcarthur annotated “can this be made more concise?” with “can this be made more concise? (annotation)” at http://hpaste.org/48322#a48326
12:50:40 <cvic> danharaj: define "good state"
12:50:56 <jmcarthur> absence: not necessarily what i would do, but there's an alternative at least ^^
12:51:35 <jmcarthur> neither annotation is as straightforward as the original
12:52:49 * hackagebot string-qq 0.0.2 - QuasiQuoter for non-interpolated strings, texts and bytestrings.  http://hackage.haskell.org/package/string-qq-0.0.2 (AudreyTang)
12:52:59 <absence> jmcarthur: it's a cool idea :) probably worth it if there are lots of cases like this
12:53:00 <agumonkey> cvic : let's say 'good state' means not orphaned
12:54:08 <agumonkey> or maintained
12:54:39 <cvic> how about http://leksah.org/ ?
12:55:18 <agumonkey> Never used it, but it's to IDEish to me, not the emacs/vi way
12:55:25 <JuanDaugherty> vital
12:55:30 <JuanDaugherty> active
12:55:39 <JuanDaugherty> maintained
12:55:41 <xplat> the emacs/vi way is like the C++/C way
12:55:47 <agumonkey> hehe
12:55:49 <agumonkey> could be
12:56:02 <cvic> vi - Unix
12:56:10 <cvic> Emacs - anti-Unix
12:56:23 <agumonkey> c'mon they're both the same
12:56:29 <xplat> Emacs = lisp machine
12:56:30 <agumonkey> you can almost make vi as fat as emacs
12:56:42 <cvic> Well, Emacs is an OS that lacks a decent editor
12:56:50 <danharaj> I refuse to use leksah because it's based on GTK
12:56:51 <agumonkey> yeah we all know
12:56:53 <Nimatek> Ah the echo of the editor wars of olde.
12:56:55 <danharaj> and GTK is balls on windows.
12:56:56 <xplat> cvic: it's got viper
12:57:00 <joe6> any suggestions on how I can do this: http://pastebin.com/eWXW5RGy
12:57:01 <cvic> Haha, indeed
12:57:02 <SirFrancisDrake> I'm having a stupid effect with killThread http://hpaste.org/48327 if a thread doesn't output anything, it can't be terminated?
12:57:02 <mauke> The paste eWXW5RGy has been copied to http://hpaste.org/48328
12:57:26 <hpaste> absence annotated “can this be made more concise?” with “can this be made more concise? (annotation)” at http://hpaste.org/48322#a48329
12:57:48 <cvic> So Yi is dead? Damn..
12:57:52 <absence> is that considered clearer?
12:58:00 <jmcarthur> absence: that is a bit nicer
12:58:14 <jmcarthur> absence: my only question is why you uncurried it in the last two arguments?
12:58:22 <jmcarthur> i never understood that
12:58:33 <joe6> i am trying to output a list of bytes without converting to ascii values.
12:58:34 <hpaste> SirFrancisDrake annotated “killThread fail” with “killThread fail (annotation)” at http://hpaste.org/48327#a48330
12:59:01 <Saizan> SirFrancisDrake: try threadDelay rather than sleep
12:59:06 <joe6> this is the code. I am not sure how to convert the [Word8] to Ptr: http://pastebin.com/eWXW5RGy
12:59:06 <mauke> The paste eWXW5RGy has been copied to http://hpaste.org/48328
12:59:11 <jmcarthur> absence: also, i tend to like putting the "decider" argument as the last one. that usually allows me more opportunities to use the function in a point free way
12:59:34 <absence> jmcarthur: it's for mapping a [(String,String)]
13:00:04 <jmcarthur> absence: even then i would probably apply uncurry to the curried version instead of writing it uncurried in the first place. that's just my personal preference though
13:00:26 <absence> jmcarthur: how would that look? i'm not familiar with uncurry
13:00:55 <jmcarthur> absence: instead of  map (chooseDirection x)  it would be  map (uncurry $ chooseDirection x)
13:01:10 <jmcarthur> :t uncurry
13:01:11 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
13:01:14 <byorgey> preflex: seen acowley
13:01:15 <preflex>  acowley was last seen on #haskell 20 hours, 38 minutes and 50 seconds ago, saying: it's his arrows of outrageous fortune paper
13:01:36 <byorgey> @tell acowley yes, I'll be around
13:01:36 <lambdabot> Consider it noted.
13:01:48 <jmcarthur> for some reason it's common to pass things like bounds as tuples instead of separate arguments
13:01:57 <absence> jmcarthur: sorry, i was a bit quick. it's zipWith, not map: zipWith chooseDirection deciders names
13:02:16 <Twey> Because (x, y) looks like an interval :þ
13:02:19 <SirFrancisDrake> Saizan: cool! Thanks
13:02:29 <jmcarthur> absence: how did you come by the names list?
13:02:57 <absence> jmcarthur: it's hardcoded :s
13:03:01 <jmcarthur> absence: if at any point you used zip then you might have been able to say:   zipWith3 chooseDirection deciders leftNames rightNames
13:03:03 <jmcarthur> ah
13:03:08 <SirFrancisDrake> Saizan: but how does this work?
13:03:21 <Twey> Needs moar ZipList
13:03:29 <Saizan> SirFrancisDrake: threadDelay takes the argument in microseconds btw
13:03:41 <jmcarthur> absence: well, anyway, that with uncurry would be:   zipWith (uncurry . chooseDirection) deciders names
13:03:43 <Twey> An Int, in microseconds -.-
13:03:45 <jmcarthur> Twey: :)
13:04:09 <SirFrancisDrake> Saizan: yeah figured that after it increased the counter up to 15624 in several seconds :)
13:04:10 <Saizan> SirFrancisDrake: your problem is that sleep is a foreign call and GHC can't interrupt threads stuck in such calls iirc
13:04:54 <absence> jmcarthur: great! if i were to flip the decider argument last (probably not necessary in this case, but a nice tip for later anyway), would it be uncurry . flip chooseDirection?
13:05:21 <absence> jmcarthur: uh wait, i'm confusing myself :D
13:05:22 <jmcarthur> i don't think so
13:05:42 <danharaj> hmmm
13:05:50 <jmcarthur> with the argument reordering, zipWith3 would look even more appealing
13:06:12 <danharaj> it seems to me that in a way, zippers reify the stack of a multi-level pattern match on a recursive data structure.
13:06:25 <jmcarthur> danharaj: yes
13:06:29 <SirFrancisDrake> Saizan: the fact that printing a value makes a difference is somewhat confusing. Could it be because of some weird optimization by GHC?
13:06:56 <jmcarthur> danharaj: all it does is make the "call stack" an object that you can pass around or persist as you please
13:07:15 <danharaj> that makes me wonder if the RTS can provide a more efficient implementation of zippers than you can define.
13:07:18 <jmcarthur> well, it also allows you to control the unwinding and stuff if you want
13:07:33 <jmcarthur> i doubt it
13:07:42 <danharaj> at least maybe slightly more compact.
13:07:43 <erus`> how do i declare a type for Num -> String ?
13:07:43 <jmcarthur> you lose the purely functional aspect of it, making it no longer quite a zipper
13:07:46 <danharaj> maybe less copying.
13:08:05 <jmcarthur> erus`: Num a => a -> String
13:08:45 <erus`> gives me erus
13:08:49 <erus`> (lol)
13:08:50 <absence> jmcarthur: hm.. i have to do something with the uncurry, because zipWith (uncurry . chooseDirection) names deciders fails when i changed the parameters of chooseDirection to l r x, but i can't figure it out
13:08:58 <erus`> Could not deduce (Ord a) arising from a use of `>='
13:09:08 <danharaj> jmcarthur: Hmm. Maybe ephemeral zippers in the ST monad could be automatically derived and made super efficient.
13:09:17 <jmcarthur> erus`: then you also need to add an Ord constraint
13:09:20 <agumonkey> gotta move, this try haskell + irc session was a pleasure
13:09:23 <agumonkey> keep it pure
13:09:24 <agumonkey> bye
13:09:29 <danharaj> unsafePerformExit
13:09:40 <erus`> jmcarthur: how do i add both
13:09:44 <erus`> Num Ord a => ,,,
13:09:48 <jmcarthur> erus`: (Num a, Ord a) => ...
13:11:30 <Saizan> SirFrancisDrake: killThread can deliver the exception only when the thread happens to invoke GHC's RTS for some reason, and printing is probably one of those cases
13:11:47 <erus`> cheers
13:11:52 <Saizan> SirFrancisDrake: these are userland threads, btw
13:13:53 * hackagebot couch-hs 0.1.3 - A CouchDB view server for Haskell.  http://hackage.haskell.org/package/couch-hs-0.1.3 (PeterSagerson)
13:14:02 <SirFrancisDrake> Saizan: I see. Thanks a lot
13:15:51 <heatsink> Can you suggest a naming convention for sum-of-products types when each product is a separate type?
13:17:06 <heatsink> Since you end up needing three different identifiers for each type
13:17:22 <heatsink> data T = A1 A2 | B1 B2; data A2 = A3 Int Int; data B2 = B3 Int Int;
13:18:05 <absence> jmcarthur: ah, (uncurry chooseDirection) without the dot did the trick :)
13:19:57 <siracusa> heatsink: I'd use something like data T = TA A | TB B; data A = A Int Int; data B = B Int Int;
13:21:52 <jmcarthur> absence: oh sorry i missed you saying that earlier
13:23:50 <heatsink> I like that approach, siracusa.  Reusing the label that way helps keep track of the name.
13:25:18 <erus`> @t Int
13:25:18 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
13:25:28 <erus`> @ty Int
13:25:29 <lambdabot> Not in scope: data constructor `Int'
13:25:34 <hpc> :t I
13:25:35 <lambdabot> Not in scope: data constructor `I'
13:25:38 <hpc> :t I#
13:25:39 <lambdabot> Not in scope: data constructor `I#'
13:25:45 <hpc> @src Int
13:25:46 <lambdabot> data Int = I# Int#
13:25:56 <heatsink> @kind Int
13:25:57 <lambdabot> *
13:26:23 <erus`> hoogle has data::Int
13:42:18 <danharaj> fuck
13:42:30 <danharaj> I think I almost understand the relationship between zippers and delimited continuations
13:48:02 <sjoerd_visscher> edwardk: That was interesting! Check https://gist.github.com/1046740 at the bottom
13:56:32 <erus`> how do i package my Num to English string function on cabal?
13:57:49 <danharaj> hmm
13:57:55 <danharaj> I kind of wish GHC had or-patterns.
14:00:56 <jmcarthur> or-patterns?
14:02:42 <danharaj> jmcarthur: You can group patterns when matching so that they have the same right-hand side.
14:03:22 <dmoctezuma> danharaj: what are you trying to do?
14:04:21 <danharaj> dmoctezuma: Implementing Red-Black trees, I just have redundant definitions that could be made into one if I could Or-pattern.
14:05:52 <jmcarthur> danharaj: ah, yes, i have also kind of wanted that
14:06:57 <jmcarthur> danharaj: i also sometimes with that  foo a a = ...  would desugar to something like  foo a a' | a == a' = ...
14:07:01 <jmcarthur> *wish that
14:07:41 <jmcarthur> i could see somebody complaining that that could easily introduce uncaught errors though
14:08:55 <edwardk> sjoerd_visscher: =)
14:09:04 <danharaj> yeah that doesn't seem natural because it relies on the EQ instance, and pattern matching ought to be purely structural.
14:09:27 <danharaj> guards are for your icky computational checks :p
14:09:53 <jmcarthur> we already have other sugar that uses Eq in pattern matching
14:10:00 <edwardk> sjoerd_visscher: i'll add in something similar to those 3 in representable-functors.
14:10:03 <jmcarthur> e.g.  foo 0 = ...
14:10:23 <danharaj> I hate that part about Ints
14:10:38 <jmcarthur> all Nums, isn't it?
14:10:39 <danharaj> I never use it.
14:10:40 <danharaj> Is it?
14:10:45 <sjoerd_visscher> edwardk: cool! I'm now trying to implement callCC
14:10:46 <danharaj> I always use guards.
14:11:08 <jmcarthur> also,  foo "bar" = ...
14:11:22 <danharaj> ewww
14:11:22 <jmcarthur> not sure if that applies to all instances of IsString when using OverloadedStrings, though
14:11:24 <dmoctezuma> you can make your lib for or-pattern
14:11:38 <danharaj> dmoctezuma: Not really. You'd have to use Template Haskell.
14:13:33 <edwardk> sjoerd_visscher: =) i have a variant somewhere
14:14:00 <edwardk> you may have better luck if you observe that the inner most Cont in callCC is pointless
14:14:18 <edwardk> and actually overconstrains the type
14:14:23 <dmoctezuma> never heard about red- black trees but I should read about it
14:14:41 <stulli> While upgrading my system the haskell packages gave me an error: http://i.imgur.com/C7gYh.png Is it save to skip them?
14:15:23 <sjoerd_visscher> edwardk: I see you're using callCV :: w (w (w a -> a) -> b) -> b
14:15:28 <edwardk> sjoerd: label :: ((a -> r) -> Cont r a) -> Cont r a
14:15:33 <edwardk> sjoerd: no, not any ore
14:15:36 <danharaj> http://matt.might.net/articles/red-black-delete/
14:15:38 <edwardk> er not any more
14:15:43 <danharaj> Can someone tell me why the double black elimination case works?
14:15:47 <edwardk> that turned out to be the wrong encoding
14:15:53 <sjoerd_visscher> ah
14:15:55 <edwardk> i hpasted something better a while back
14:16:00 <edwardk> the callCV is ambiguous
14:16:09 <edwardk> there are 3 valid definitions for it, and the signature is wrong
14:16:23 <edwardk> to find the right meaning you need to take a detour through shift and reset and reformate it
14:16:36 <edwardk> i'll probably blog something on it soon now that i have the blogging bug again
14:16:50 <edwardk> re reformulate
14:16:54 <edwardk> er er
14:17:00 <danharaj> nevermind.
14:17:05 <danharaj> That only works at the root.
14:19:22 <sjoerd_visscher> I guess label would become ((a -> Value f) -> ContT f g a) -> ContT f g a in my case
14:19:34 <sjoerd_visscher> maybe an extra g somewhere
14:20:24 <sjoerd_visscher> (g (a -> Value f) -> ContT f g a) -> ContT f g a perhaps
14:21:30 <sjoerd_visscher> (g (f a) -> ContT f g a) -> ContT f g a even
14:22:04 <edwardk> well, consider that in your ContT f g,   a -> r   is f a
14:22:34 <edwardk> so i'm guessing (f a -> ContT f g a) -> ContT f g a
14:22:53 <edwardk> then the comonad, giving you the g wrapped around it.
14:22:57 <edwardk> ah
14:22:59 <edwardk> yeah you got it
14:23:41 <edwardk> http://hackage.haskell.org/packages/archive/adjunctions/1.0.0/doc/html/Control-Monad-Trans-Conts.html has a basic callCC
14:24:11 <sjoerd_visscher> ah, that'll help
14:24:23 <edwardk> it can probably be improved to be a callCCs with the ((w a -> ContsT r w m b) -> ContsT r w m a) -> ContsT r w m a
14:25:06 <edwardk> then improved one step further to get you the tighter: ((w a -> r) -> ContsT r w m a) -> ContsT r w m a — which translates into your ContT as you write
14:25:09 <edwardk> er wrote
14:25:56 <edwardk> i think i just had too many other things to do that day. if you look at the source there is a commented out version of it ;)
14:26:04 <sjoerd_visscher> that's g (f a) then instead of f (g a), g being the comonad
14:26:13 <edwardk> yeah
14:26:18 <edwardk> that way the inner arrow is cokleisli
14:26:48 <edwardk> you have a w full of continuations, that you are capturing.
14:29:42 <dainanaki> Has anyone used the Text.Dot module before?
14:30:45 <edwardk> Text.Dot ?
14:30:59 <dainanaki> it's just a little module for generating dot files.
14:31:03 <edwardk> ah
14:31:11 <edwardk> nope
14:31:22 <edwardk> nobody, ever. ;)
14:31:30 <dainanaki> i thought so :)
14:32:47 <dainanaki> I just find the Dot monad to be a little weird for some reason.
14:34:50 <edwardk> it looks like a state transformed writer monad. you have a counter of fresh ids and a bunch of graph elements being written out
14:35:05 <edwardk> i presume at least from looking at the signature of it
14:35:44 <JuanDaugherty> dot - word template?
14:36:10 <edwardk> the state parameter seems to only be used to make subgraphs
14:36:11 <dainanaki> no, dot files are what graphviz uses to generate diagrams.
14:36:16 <JuanDaugherty> ah
14:38:01 <dainanaki> I guess it just threw me off since I'm used to doing stuff like this with a writer/state stack.
14:39:49 <edwardk> one thing to note is that that stack is _also_ written by andy gill ;)
14:40:23 <dainanaki> you mean andy gill invented the writer/state stack in the first place?
14:43:08 <edwardk> yes
14:43:27 <edwardk> http://hackage.haskell.org/package/mtl-2.0.1.0 see Author ;)
14:43:49 <dainanaki> Well go figure.
14:44:00 <edwardk> we just patch up his code and keep repackaging it ;)
14:44:29 <dainanaki> hehe. andy gill, the stealth dons
14:44:34 <ddarius> The MTL is really old.
14:45:12 <dainanaki> it's a great idea though.
14:47:25 <sjoerd_visscher> callCC :: Corepresentable f => (w (f a) -> ContsT f w a) -> ContsT f w a
14:47:25 <sjoerd_visscher> callCC f = ContsT . corep $ \wfa -> coindex (runContsT (f wfa)) wfa
14:47:40 <edwardk> hah, so callCCs is doable =)
14:47:56 <sjoerd_visscher> can it be that simple? it doesn't even need anything from w
14:48:29 <edwardk> look at the difference between ContT and Cont
14:50:27 <sjoerd_visscher> how's that related?
14:50:51 <edwardk> in that nothing is needed from the monad
14:51:01 <edwardk> so i'm not surprised
14:51:11 <edwardk> same kind of thing happens in Discont as well
14:51:19 <sjoerd_visscher> ok
14:53:41 <ddarius> We should go through the libraries and try to find representations for all the functors.
14:54:03 <edwardk> i did a fair bit of that in the representable-tries package
14:54:43 <edwardk> That State# s -> (# a, State# s #)  — might be hard ;)
14:55:37 <ptrf> k
14:57:33 <edwardk> afk a bit playing boston tourguide
14:59:47 <chexxor> now, I'm just beginning to read the book on haskell
15:00:09 <chexxor> but how would one begin to solve a problem like the farmer crossing the river with 3 items
15:00:15 <chexxor> wheat, chicken, and wolf
15:00:46 <chexxor> http://tvtropes.org/pmwiki/pmwiki.php/Main/FoxChickenGrainPuzzle
15:01:42 <kmc> chexxor, which book?
15:01:55 <ddarius> kmc:
15:02:00 <chexxor> umm, it was the supplement to the big one, from haskell.org
15:02:08 <kmc> hi ddarius
15:02:10 <ddarius> kmc: -The- book.  There's only one.
15:02:11 <chexxor> the problem is unrelated to the book
15:02:27 <chexxor> a friend mentioned to me that he had to solve the problem when he was in college
15:02:43 <cheater_> chexxor, deontic logic
15:02:54 <ddarius> Brute force enumeration.
15:02:57 <chexxor> I'm looking for the book, it was a pdf
15:03:10 <chexxor> http://www.haskell.org/tutorial/
15:03:21 <kmc> ok
15:03:23 <ddarius> That, or just ask why a farmer is trying to transport a living fox.
15:03:31 <kmc> i happen to like the Gentle Introduction to Haskell but i don't think it's a good tutorial per se
15:03:41 <cheater_> yeah farmer with boat is a classical problem
15:03:41 <kmc> seems most people today start by reading LYAH or RWH
15:03:43 <kmc> @where LYAH
15:03:44 <lambdabot> http://www.learnyouahaskell.com/
15:03:45 <kmc> @where RWH
15:03:45 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:03:55 <cheater_> yeah lyah is great
15:04:00 <kmc> chexxor, you can solve problems like that by searching a tree of possibilities
15:04:12 <kmc> the Haskell standard library supports doing this with the list type
15:04:14 <sjoerd_visscher> chexxor: here's a solution https://code.goto10.org/svn/maximus/2009/boatman/BoatMan.hs
15:04:44 <kmc> sjoerd_visscher, nice, it outputs a dot grapH?
15:05:02 <chexxor> thanks, I'll check those resources out
15:05:06 <sjoerd_visscher> looks like it, Google found it
15:05:46 <chexxor> gosh, I would have a hard time trying to find a solution with OO, even
15:05:54 <kmc> chexxor, often described by the term "list monad"
15:05:58 <kmc> but don't get too hung up on the m-word
15:06:11 <chexxor> haha, I'll get to 'monad' eventually
15:06:20 <kmc> "monad" is the name of a generic API implemented by lots of different types
15:06:26 <kmc> for lists that API gives you nondeterministic search
15:06:37 <kmc> for other types the API gives you something totally different
15:06:55 <kmc> so using the "list monad" is not about understanding some ineffable monad concept
15:07:02 <kmc> just understanding what that API gives you in this particular case
15:09:05 <chexxor> crazy description
15:09:39 <chexxor> a monad is another word for an API?
15:09:52 <kmc> no
15:09:55 <kmc> "Monad" is a specific API
15:10:07 <chexxor> someone else wrote it?
15:10:27 <chexxor> "The Monad", which was written by Prof. Genius?
15:10:34 <kmc> ;P
15:10:51 <chexxor> it seems to be an idea, to me
15:10:57 <chexxor> like, a solution to a problem
15:11:04 <ujihisa> "a monad is a monoid in the category of endofunctors"
15:11:11 <chexxor> of how do you make a function have side-effects
15:11:13 <kmc> in Haskell you can use the (==) operator on any type which implements equality comparison
15:11:15 <chexxor> when there's only input and output
15:11:19 <kmc> you can use the (+) operator on any numeric type
15:11:29 <kmc> you can use the 'show' function on any type which implements serialization
15:11:34 <mauke> chexxor: no, it's not about side effects
15:11:36 <kmc> and you can use the (>>=) function on any monad
15:11:54 <kmc> IO is about effects.  IO is a monad, but it's not a typical monad
15:11:58 <chexxor> oh frick, I'm off on the wrong foot already, haha
15:11:59 <mauke> chexxor: it's much simpler/boringer
15:12:11 <kmc> and the monad-ness of IO is really irrelevant to how IO is handled in Haskell
15:12:36 <kmc> you could do the same things and not recognize that you're implementing this generic API
15:13:00 <chexxor> so, unless I'm looking for it, monads will be pretty invisible to me?
15:13:04 <kmc> no
15:13:06 <chexxor> they look like a normal function?
15:13:19 <kmc> comparing "monad" and "normal function" is nonsense
15:13:19 <mauke> no
15:13:24 <kmc> they aren't the same kind of thing
15:13:26 <chexxor> it's the scariest word of haskell so far
15:13:28 <mauke> Monad is a typeclass
15:13:38 <kmc> just don't worry about it for now
15:13:39 <mauke> just like Show, Eq, or Functor
15:13:43 <kmc> learn Haskell and it will all make sense later
15:13:47 <chexxor> is this explained in some of the tutorials you mentioned abocve?
15:13:51 <mauke> yes
15:13:54 <kmc> yes, LYAH and RWH both cover it
15:13:57 <Nimatek> They're like aliens that eat your brain.
15:14:06 <kmc> burritos that eat your brain?
15:14:11 <kmc> that's why i have to eat them first!
15:14:23 <chexxor> great, I'll take a look at those then
15:14:39 <chexxor> would you recommend that I put down this haskell.org/tutorial book I have?
15:14:49 <caleb_9> Would an easy way to explain it is to compare it with interfaces in OO world?
15:14:56 <mauke> preflex: quote duqicnk
15:14:56 <preflex>  <duqicnk> a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
15:15:06 <kmc> chexxor, if it's working for you, stick with it
15:15:23 <caleb_9> IT's just a specific interface that a type needs to implement to be a monad?
15:15:35 <mauke> yeah, basically
15:15:50 <kmc> but the comparison between Haskell type classes and, say, Java interfaces also causes a lot of trouble
15:15:57 <kmc> you really can't learn Haskell by analogy to familiar languages
15:16:09 <chexxor> haha, that's great
15:16:28 <chexxor> "Haskell is not something one can learn. It is something that one must become."
15:16:40 <monochrom> just yesterday or so I showed how Haskell's Maybe is not like Scala's Option
15:16:41 <Nimatek> Lol
15:17:07 <ddarius> Except it's a type constructor that implements it and it has methods that wouldn't make sense in a Java-like scenario.
15:17:07 <companion_cube> how so ?
15:17:26 <companion_cube> monochrom: what is the difference?
15:18:00 <monochrom> (Just (1 `div` 0) does not cause divergence in Haskell
15:20:11 <companion_cube> ok, but it's a difference between haskell and scala, not really between option types
15:20:49 <monochrom> that is probably not the end of their unlikeness
15:27:39 <monochrom> it also seems naive to sign it off as difference between "language"s
15:28:24 <monochrom> staying within haskell, "data X a = X0 | X1 a" is unlike "data X a = X0 | X1 !a"
15:28:39 <Philippa> kmc: the type class/interface comparison can be done better than it usually is
15:29:10 <Philippa> but yeah, it's a real pitfall if you get the naive version and only remember half of it
15:29:47 <Philippa> (IMO we should be teaching newbies how to do H98 type inference by hand pretty early on, using the idea of constraints: it makes type class extensions so much easier to get your head around)
15:30:38 <benmachine> I had an idea to do that
15:30:45 <monochrom> so now the divergence or non-divergence of (X1 (1 `div` 0)) cannot be said as "but that's a difference between haskell and haskell". it is between two option types
15:30:49 <benmachine> I actually had a program once that showed you how it typechecked a lambda expression
15:30:59 <benmachine> then I realised that type inference is scary
15:31:04 <benmachine> in the general case
15:32:47 <monochrom> I am slowly writing a tutorial on basic type inference by hand with equational constraints and unification (not necessarily calling it "unification")
15:33:53 <chexxor> cool, thanks all, I'm out to read some more tutorials, maybe switch to LYAH for a bit
15:35:01 <monochrom> in fact, why don't I show you the under-construction draft: http://www.vex.net/~trebla/haskell/typecheck.xhtml
15:37:29 <HugoDaniel> http://hpaste.org/48332  <- im having problems parsing json with aeson
15:37:35 <HugoDaniel> the bytestring types dont match
15:38:02 <HugoDaniel> attoparsec seems to require Data.ByteString.Internal.ByteString
15:38:16 <HugoDaniel> whats the difference between this and a normal bytestring ?
15:38:29 <HugoDaniel> why is "internal" exposed ?
15:38:31 <kmc> none afaik
15:38:40 <kmc> it's imported and re-exported by Data.ByteString
15:39:05 <kmc> and "Internal" is exposed because it's very useful for certain "yes, I know what I'm doing" tricks
15:39:17 <HugoDaniel> :/
15:39:22 <kmc> like converting between ByteStrings and buffers in a C library without copying data
15:39:31 <Igloo> Probably either BS is the Lazy version, or they are from different versions of the package
15:39:58 <kmc> i think it's generally good to expose the internals of a library, with sufficient warnings and disclaimers
15:40:53 <HugoDaniel> oh, its not lazy
15:40:54 <HugoDaniel> ok
15:49:34 <tsuraan__> does anybody know why hayoo doesn't have functions like (>>=) and (.&.) indexed?
15:49:44 <tsuraan__> wait, now it's working
15:49:48 <tsuraan__> bah, I'm crazy
15:49:58 <tsuraan__> no, I'm not crazy
15:50:19 <tsuraan__> if you type (>>=, it offers Monad.(>>=) under its completions, but if you type (>>=) it has no hits
15:51:44 <tsuraan__> so hayoo is a little crazy
15:58:06 <nihtml> !/n
15:58:10 <nihtml> sorry
16:05:26 <fxr> hoogle gives me what I want most of the times
16:11:55 <tsuraan> fxr: yeah, hoogle is definitely good.  I thought hayoo was better at searching for actual function names, but I'm not seeing that right now, so maybe I mis-remembered
16:13:56 <joe6> i have strings in this format: http://pastebin.com/r4wWgsrH . Any suggestions on how I can convert it to [Word8]?
16:13:58 <mauke> The paste r4wWgsrH has been copied to http://hpaste.org/48333
16:14:16 <fxr> actually I don't want to leave my emacs window
16:14:49 <siracusa> tsuraan: hayoo searches  the hackage database, hoogle only the base libraries, IIRC
16:15:06 <joe6> i am talking about the values "\ACK"
16:15:47 <kmc> joe6, there are many incompatible ways to represent Unicode text as byte sequences
16:16:10 <tsuraan> siracusa: which can be both good and bad.  good to know, though
16:16:15 <fxr> joe6: do you need just the strings or the character codes since they're escaped?
16:16:38 <kmc> > map (fromEnum :: Char -> Word8) "hi joe6"
16:16:40 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
16:16:40 <lambdabot>         against inferred type...
16:16:44 <joe6> i want to convert the char "\ACK" to Word8
16:16:46 <kmc> > map (fromIntegral . fromEnum :: Char -> Word8) "hi joe6"
16:16:48 <lambdabot>   [104,105,32,106,111,101,54]
16:16:49 <joe6> kmc, thanks.
16:16:54 <kmc> > map (fromIntegral . fromEnum :: Char -> Word8) "\ACK\ENQ\ETX"
16:16:56 <lambdabot>   [6,5,3]
16:17:14 <kmc> looks like some library has made a mistake, and is giving you Char (a Unicode text type) when it really should be Word8 to begin with
16:17:26 <joe6> kmc, exactly what I need. thanks. that is Language.C
16:17:41 <fxr> > Data.Char.ord '\ACK'
16:17:42 <lambdabot>   6
16:17:50 <fxr> like this?
16:18:16 <fxr> ah sorry, kmc is right.
16:18:29 <kmc> ord = fromEnum
16:18:36 <kmc> (except the former has a more specific type)
16:18:41 <kmc> so we're both right :)
16:19:46 <fxr> > map Data.Char.ord "\ACK\ENQ\ETX"
16:19:47 <lambdabot>   [6,5,3]
16:19:53 <fxr> yeah that's true
16:26:01 <joe6> > :t Data.Char.ord
16:26:02 <lambdabot>   <no location info>: parse error on input `:'
16:26:07 <joe6> :t Data.Char.ord
16:26:08 <lambdabot> Char -> Int
16:26:59 <joe6> > :t map (fromIntegral . fromEnum :: Char -> Word8) "hi joe6"
16:27:00 <lambdabot>   <no location info>: parse error on input `:'
16:27:04 <joe6> :t map (fromIntegral . fromEnum :: Char -> Word8) "hi joe6"
16:27:05 <lambdabot> [Word8]
16:48:47 <koninkje> A while back someone made a module hierarchy tree of all of hackage; anyone remember the url?
16:49:40 <aavogt> koninkje: this one http://donsbot.wordpress.com/2009/03/16/visualising-the-haskell-universe/ ?
16:50:08 <koninkje> no, it was like the haddock table of contents page
16:50:52 <koninkje> it might not have been *all* of hackage, but most of it
17:00:30 <hpaste> sebz pasted “selectivelyCompose” at http://hpaste.org/48334
17:00:54 <sebz> Is there a right way to do something like this?
17:03:04 <sebz> (\x -> y) where y=[something involving x]
17:03:35 <mauke> selectivelyCompose f x f'
17:03:42 <mauke> but that won't help you with f''
17:03:54 <chrisdone_> So, indeed. There was indeed partying in the streets and open bars still at 2:24AM in Trento. But I came back to do some more programming, because that's how I role.
17:04:09 <chrisdone_> Oh. “Roll”. :-(
17:04:11 <koninkje> sebz: as such, no, because x isn't in scope
17:04:52 <koninkje> sebz: though you can do (\x -> let y = ... in y) or (let x = y where y = ... in...)
17:05:08 <koninkje> or (let x = y ; y = ... in...)
17:06:13 <monqy> sebz: in your definition of f'', aren't you shadowing x? (I'm assuming the intention was to compare the argument with x)
17:06:31 <monqy> sebz: (or is a good way to do that what you want to know?)
17:08:15 <sebz> monqy: er maybe, I'm not sure what shadowing is... what I want to do is take in some f', and put out a function f'' which is f.f' when applied to x and f' otherwise
17:08:52 <koninkje> > let x = 5 in let x = 2 in x+x
17:08:53 <lambdabot>   4
17:09:17 <koninkje> sebz: ^ the inner let binding of x shadows the outer one
17:09:29 <sebz> got it, thanks
17:10:05 <siracusa> > let a = 10 in let а = 5 in a + а
17:10:06 <lambdabot>   15
17:10:22 <fxr> I wish one day hayoo and hoogle will output emacs-w3m friendly html.
17:11:00 <shachaf> @show let a = 10 in let а = 5 in a + а
17:11:01 <lambdabot> "let a = 10 in let \208\176 = 5 in a + \208\176"
17:11:02 <fxr> hoogle is readable but hayoo is very bad.
17:13:03 <hpaste> monqy annotated “selectivelyCompose” with “selectivelyCompose (annotation)” at http://hpaste.org/48334#a48335
17:13:36 <monqy> sebz: I tried doing a fairly direct translation, but it's probably not what you intended
17:17:18 <monqy> sebz: http://hpaste.org/48334#a48335 I tried doing a fairly direct translation from your old function, but it's probably still not what you intended
17:17:18 <hpaste> sebz pasted “selectivelyCompose” at http://hpaste.org/48336
17:17:46 <sebz> oh wow that's almost exactly what I just did
17:18:01 <monqy> right your second paste is what I sort of expected you were intending
17:18:50 <sebz> so, is this the idiomatic way of doing it? is there a more pointfree way?
17:19:26 <sebz> I'm guessing no because the argument needs to be equatable
17:21:30 <sebz> selectivelyCompose :: Eq a => (c -> c) -> a -> (a -> c) -> a -> c
17:40:27 <Kaidelong> @hoogle Either a a -> a
17:40:27 <lambdabot> Data.Either rights :: [Either a b] -> [b]
17:40:28 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
17:40:28 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
17:40:49 <Kaidelong> @hoogle Either a b -> (b -> a) -> a
17:40:50 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
17:40:50 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
17:40:56 <Kaidelong> ah
17:41:03 <kmc> :t either id id
17:41:04 <lambdabot> forall b. Either b b -> b
17:41:24 <kmc> that's kind of a cool example of unification / type inference
17:42:52 <Kaidelong> @ty either return id . fmap (\(n,x) -> replicate n x)
17:42:52 <lambdabot> forall a. Either a (Int, a) -> [a]
17:43:28 <Kaidelong> @ty map $ either return id . fmap (\(n,x) -> replicate n x)
17:43:29 <lambdabot> forall a. [Either a (Int, a)] -> [[a]]
17:43:39 <Kaidelong> @ty concatMap $ either return id . fmap (\(n,x) -> replicate n x)
17:43:40 <lambdabot> forall a. [Either a (Int, a)] -> [a]
17:43:42 <Kaidelong> there we go
17:43:51 <Kaidelong> prolog problem solved
17:44:20 <kmc> :t join either id
17:44:22 <lambdabot> forall c. Either c c -> c
17:46:22 <shachaf> Is there a standard solution/name for the issue where join (.) (:[]) doesn't type-check when (:[]) . (:[]) does?
17:47:49 <hpc> :t join (.) return
17:47:50 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
17:47:50 <lambdabot>       Expected type: a -> m a
17:47:50 <lambdabot>       Inferred type: a -> a
17:47:56 <hpc> :t join
17:47:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:48:32 <chrisdone_> :t join (.)
17:48:33 <lambdabot> forall a. (a -> a) -> a -> a
17:48:54 <shachaf> Well, (\x -> x . x) works too.
17:48:56 <chrisdone_> :t (:[]) . (:[])
17:48:57 <lambdabot> forall a. a -> [[a]]
17:49:20 <shachaf> I suppose the issue is that the argument of the lambda isn't polymorphic.
17:49:58 <chrisdone_> Yeah. It goes a -> [a] and then [a] -> [[a]], whereas it needs to be x -> x from join (.).
17:50:15 <shachaf> Right, but that's annoying.
17:51:05 <Saizan> you'd need a variation of join (.) that uses the fact that (:[]) is a natural transformation Id -> []
17:51:39 <hpc> i think impredictive types would work here?
17:51:54 <hpc> *impredicative
17:52:24 <kmc> :(
17:52:27 <Saizan> i don't think so
17:54:29 <chrisdone_> @src join
17:54:29 <lambdabot> join x =  x >>= id
17:54:40 <shachaf> Saizan: For example?
17:55:38 <shachaf> > let f :: forall l b. (forall a. a -> l a) -> b -> l (l b); f x y = x (x y) in f (:[]) 5 -- Hmm.
17:55:38 <lambdabot>   [[5]]
17:57:46 <shachaf> That's an awkward way to define it. Is there anything better that can be done?
17:58:49 <chrisdone_> Drop the forall l b. :-P
17:59:14 <shachaf> > let f :: (forall a. a -> l a) -> b -> l (l b); f x y = x (x y) in f Just 5
17:59:15 <lambdabot>   Just (Just 5)
17:59:21 <shachaf> Hooray.
17:59:45 <shachaf> Is there an f that can work for both, say, succ and Just?
18:03:19 <Saizan> f :: (forall a. f a -> f (g a)) -> f a -> f (g (g a)) would if f and g were allowed to be type families
18:07:08 <Saizan> this is clearly going down a pretty insane path :)
18:10:00 <aavogt> shachaf: use template haskell instead
18:10:28 <shachaf> :-(
18:10:47 <shachaf> All I want is to be able to say f x y = x (x y) and substitute it anywhere.
18:11:37 <Peaker> @type \x y -> x (x y)
18:11:38 <lambdabot> forall t. (t -> t) -> t -> t
18:16:31 <aavogt> f x = [| \y -> $x ($x y) |]
18:17:03 <aavogt> then     $(f [| (:[]) |]) 5   -- works as above
18:20:14 <Peaker> Paul Graham would approve
18:20:35 <shachaf> ?
18:24:05 <ccc>  /set irc.server.oftc.command "/msg nickserv identify rv2733"
18:25:50 <shachaf> ccc: That may or may not have been a joke, but if not, you should probably change your password.
18:38:15 <sebz> > pl \c m f x -> if c x then f x else m $ f x
18:38:17 <lambdabot>   <no location info>: parse error on input `\'
18:38:45 <sebz> did I do that right?
18:38:52 <azaq23> obviously not
18:38:54 <azaq23> @pl \c m f x -> if c x then f x else m $ f x
18:38:54 <lambdabot> (. (.)) . ap . (ap .) . liftM2 if'
18:39:04 <azaq23> > is an abbreviation for @run
18:39:05 <lambdabot>   Not in scope: `is'Not in scope: `an'Not in scope: `abbreviation'Pattern syn...
18:39:16 <azaq23> other commands are given using @
18:39:45 <sebz> oh thanks, I was following http://www.haskell.org/haskellwiki/Pointfree
18:40:50 <azaq23> that transcript is for the command line standalone version of pl
18:40:55 <sebz> @unpl (. (.)) . ap . (ap .) . liftM2 if'
18:40:56 <lambdabot> (\ l ag -> (\ aj ac -> (l >>= \ g -> aj >>= \ h -> return (if' g if')) >>= \ z -> ac >>= \ y -> return (z y)) >>= \ q -> (\ b c -> ag (b c)) >>= \ p -> return (q p))
18:41:12 <sebz> oh jesus
18:42:24 <azaq23> sebz: pl is only useful for simple expressions or up to a certain point, from then on it spits out the haskell version of a SKI calculus representation of your given expression
18:43:02 <sebz> azaq23: I see that now, thank you
18:44:05 <gbacon> anyone got a copy of Beautiful Code handy? I'm looking for the page numbers for simonpj's Beautiful Concurrency (which is chapter 24)
18:50:21 <ion> (if c x then id else m) (f x). Now, if you happen to be able to refactor the if expression to a separate function that gets called as ‘foo x’ you’ll have ‘foo x (f x)’ which is the same as (foo <*> f) x.
18:58:28 <sordina1> Is there a way to get cabal to install the depenencies of a local cabal package rather than just list the missing ones?
19:03:12 <Saizan> use "cabal install"
19:06:31 <danharaj> I don't like the explanation of zippers with one-hole contexts.
19:07:21 <danharaj> I like the way of looking at them as call stacks in a recursive pattern match
19:07:52 <Jafet> “That other day, it got caught in my one-hole context.”
19:09:34 <kmc> ouch
19:10:37 <koninkje> Does anyone know that this warning means? "mkUsageInfo: internal name?"
19:10:45 <kmc> context?
19:11:11 <koninkje> I'm compiling some code with GHC and it spews those out for a couple modules
19:11:17 <ion> koninkje: http://hackage.haskell.org/trac/ghc/ticket/3955
19:11:24 <ion> Just ignore it.
19:11:31 <koninkje> k, thanks
19:11:50 <kmc> heh, fun times
19:11:57 <koninkje> Any idea what it actually means though?
19:12:27 <koninkje> ah, nm
19:12:37 <danharaj> I'm curious how continuations and zippers are related, looking at them that way.
19:14:02 <sordina1> Thanks Saizan, I never tried that since I assumed I would have to cabal configure first. Silly me :D
19:16:32 <dagit> dan haraja
19:16:39 <dagit> Oops
19:17:30 <dagit> danharaj, oleg has a paper that shoes how they are related
19:21:14 <danharaj> Oleg is too smart for me to understand :[
19:22:53 * ddarius seriously needs to clean his electric.
19:24:14 <sbahra> Your electric?
19:27:07 <dibblego> Warning: Defaulting the following constraint(s) to type `Toaster' arising from the literal `electric'
19:27:44 <kmc> haha
19:29:20 <danharaj> hmm
19:29:32 <danharaj> How are red black trees supposed to perform on very ordered data?
19:29:49 <danharaj> From my cursory testing, they perform very very well
19:29:54 <danharaj> (in terms of balance)
19:30:12 <ion> Slightly on the bluish end of the spectrum.
19:30:24 <parcs> what does 'default ()' do?
19:30:25 <drdo> danharaj: rb trees are guaranteed to be well balanced for any input
19:30:40 <danharaj> drdo: worst case is twice as long as optimal
19:30:52 <othiym23> gbacon_: you still looking for that Beautiful Code cite?
19:30:55 <danharaj> deep*
19:31:00 <drdo> danharaj: sure
19:31:20 <danharaj> I am measuring much better than that, almost optimal on ordered input.
19:33:43 <othiym23> gbacon_: SPJ's chapter is pp. 385-406
19:34:36 <dibblego> I cannot have _10 as a valid data type name, what's the next best thing?
19:34:51 <othiym23> underscoreTen
19:34:59 <dibblego> boo
19:39:27 <anschelsc> Can anyone recommend a good tutorial for an intuitive understanding of arrows?
19:39:53 <anschelsc> I found Learn You a Haskell gave me a good idea of monads, but unfortunately it stopped there
19:40:44 <danharaj> arrows are not nearly as important as monads
19:41:07 <othiym23> I found Conor McBride's "Kliesli Arrows of Outrageous Fortune" both useful and groan-inducing
19:41:11 <danharaj> that's why they receive a lot less attention in pedaogical resources.
19:41:18 <anschelsc> danharaj: At the very least they seem to be involved in the more interesting-sounding GUI toolkits
19:41:23 <othiym23> I had to read it a couple times, though
19:41:59 <anschelsc> othiym23: I'll put it on my list.
19:42:06 <danharaj> anschelsc: Most gui toolkits in haskell are either very low level bindings in IO or experiments that are now abandoned.
19:42:58 <anschelsc> danharaj: how disappointing...does that mean I shouldn't try to do haskell GUIs?
19:42:59 <cmccann> anschelsc, arrows are things that act kinda like functions, that's most of the intuition you really need
19:43:19 <danharaj> anschelsc: Not at all. Haskell is great even when you're using an imperative library.
19:44:59 <anschelsc> danharaj: the small amounts of imperative programming I've done in haskell makes me yearn for the conciseness and clarity of scripting languages, which is a bad sign
19:45:30 <anschelsc> cmccann: So how are they different from functions, intuitively
19:45:43 <othiym23> anschelsc: also, http://blog.downstairspeople.org/2010/06/14/a-brutal-introduction-to-arrows/
19:45:55 <dibblego> I've not used a more concise imperative language than haskell -- do you know of another?
19:46:17 <ion> English
19:46:18 <cmccann> anschelsc, arrows-in-general aren't different from functions, because functions are an instance of Arrow
19:46:22 <othiym23> dibblego: Forth
19:46:55 <othiym23> alternately, VAX assembler
19:47:01 <anschelsc> dibblego: I don't want to start a flame-war by answering that question...
19:47:14 <danharaj> Flame wars don't really catch on here.
19:47:17 <dibblego> anschelsc: I'm just hoping to give you a different insight, not fight
19:47:26 <cmccann> anschelsc, but the main difference between arbitrary arrows and functions is that arrows, in general, can't be curried or applied the way functions can
19:47:31 <danharaj> Most people in this channel use another, or multiple languages in addition to haskell.
19:47:53 <cmccann> anschelsc, arrows tend to be used in a more "pipeline" style based on function composition
19:48:38 <anschelsc> cmccann: I guess that makes sense...when does that matter?
19:48:44 <danharaj> anschelsc: For example, the gui libraries you looked at probably were based on Functional Reactive Programming (Grapefruit, by any chance?) and one style of FRP is like in the library Yampa, which uses arrows.
19:49:27 <cmccann> anschelsc, what do you mean by "matter"? It's significant because you can use arrows for things that lend themselves to pipeline composition style, but either have extra structure or limitations
19:50:08 <anschelsc> cmccann: fair enough; I'm not sure myself what I mean.
19:50:25 <anschelsc> I think it's time for me to go offline and read a bit, thanks for the help
19:50:32 <cmccann> anschelsc, an easy and common example being arrows that represent a stream-processing state machine, where you can compose them but "apply" doesn't really work because the streams don't sync up easily
19:50:38 <cmccann> oops, ah well
19:51:10 <danharaj> He lost me at Haskell not being a concise imperative language :[
19:51:42 <ion> Who said that?
19:51:44 <dibblego> some people think imperative and functional programming do not coincide
19:51:50 <danharaj> [23:16] <anschelsc> danharaj: the small amounts of imperative programming I've done in haskell makes me yearn for the conciseness and clarity of scripting languages, which is a bad sign
19:52:01 <othiym23> if you're used to Perl or Python (less so Ruby), Haskell can feel less concise
19:52:10 <danharaj> Perl, I can agree with that.
19:52:19 <ion> Ah, missed that line.
19:52:30 <danharaj> Python, I do not know. I have not done more than cursory programming in Python.
19:52:42 <danharaj> Ruby, Ruby is one of the few languages I think is completely superfluous.
19:52:59 <cmccann> dibblego, I think it's more accurate to say that imperative programming is a first-class abstraction in Haskell
19:53:12 <othiym23> if you're coming to scripting from an OO background, Ruby feels very expressive
19:53:12 <danharaj> `IO a' is a type you can pass around.
19:53:25 <danharaj> er
19:53:27 <danharaj> value
19:53:29 <danharaj> type of values
19:53:39 * danharaj self-pedantication
19:53:40 <cmccann> whereas in an imperative language, you're embedded in the context and can't manipulate imperative computations as freely
19:54:19 <danharaj> The monad sugar is also great because you can usually create your own imperative DSL with a monad.
19:54:20 <cmccann> I would draw an analogy between e.g. function pointers in C vs. true first-class functions with lambda abstractions
19:54:31 <danharaj> And Haskell's laziness allows you to reify control structures as function values.
19:54:50 <danharaj> ifthenelse is a function in Haskell, it can't be in a strict language.
19:54:57 <danharaj> without being 'special'
19:55:12 <othiym23> ah, I thought of another extremely concise imperative language, but I think it makes dibblego's point: APL
19:55:19 <danharaj> APL is sexy
19:55:34 <danharaj> man we should have had this discussion when the guy was in here :p
19:55:35 <dibblego> I tend not to use these terms in teaching due to all this confusion
19:55:53 <othiym23> danharaj: but scripting languages have no compunction about tossing in special forms right and left -- that's part of how they derive their power
19:56:22 <othiym23> they're not regular / orthogonal / general, but they do have a lot of power given a restricted domain
19:56:24 <danharaj> othiym23: The beauty though is that Haskell let's *you* make the special forms. Making EDSL's is one of the most powerful paradigms of Haskell usage.
19:57:14 <kmc> not nearly to the degree of Lisp, though
19:57:17 <danharaj> True.
19:57:36 <kmc> Haskell strikes a delicate balance in a lot of ways
19:57:40 <danharaj> I can't stand lisp syntax though :p
19:57:40 <othiym23> danharaj: sure, but if all you care about is concision and the imperative style, you can get all of what you want out of, say, metaprogramming in Ruby
19:57:48 <ddarius> Macros are over rated in Lisp.
19:57:52 * cmccann should learn J, it's all about pointless style and includes built-in syntactic support for using the Applicative instance of ((->) t)
19:57:53 <danharaj> othiym23: I'm not sure you can get clarity at the same time though.
19:58:00 <kmc> danharaj, i really hate how nobody can discuss Lisp online without getting bogged down in trivial syntactic issues
19:58:00 <ddarius> cmccann: J is fun.
19:58:23 <danharaj> kmc: I am code dyslexic. I have a hard time reading other peoples' code in Haskell, which I adore as a language. The only code I can read easily is code I write.
19:58:27 <othiym23> danharaj: I would argue that DSLs and clarity are somewhat at odds with each other
19:58:35 * ddarius agrees with danharaj about Ruby being superfluous.
19:58:45 <kmc> omg parentheses! whatever
19:59:06 <danharaj> kmc: one of the things that made me choose Haskell over ML and Lisp is that I liked the syntax more.
19:59:26 <othiym23> getting up and running with Lisp macros makes you feel like a tiny god very quickly, even if it does result in a lot of write-only code
19:59:33 <kmc> yes
19:59:42 <dolio> Who said anything about parentheses?
19:59:51 <kmc> Haskell's DSLs are a bit more tame because you can't screw with syntax so much
20:00:03 <othiym23> unless you stir TH into the mix
20:00:10 <kmc> right
20:00:20 <danharaj> Too much TH makes code gaudy.
20:00:24 <ddarius> othiym23: Until recently, you were very limited with what you could do with TH, syntax-wise.
20:00:25 <kmc> which few people do, because TH is so painful
20:00:26 <danharaj> Like fine jewelry.
20:00:31 * cmccann finds lisp syntax to be an acquired taste, in the sense where if you choke it down long enough you start to like it a lot for some reason
20:00:48 * ddarius finds Lisp's syntax neither here nor there.
20:00:48 <kmc> i really think we need a metaprogramming mechanism for Haskell which is more powerful than CPP and less cumbersome than TH
20:00:53 <othiym23> coming from an OCaml background, where people reach for camlp4 all the time, it's interesting to see TH catching on more
20:00:56 <othiym23> sexps are sexy
20:01:10 <kmc> i like the idea of writing some modules in vanilla Haskell and some in Liskell with heavy metaprogramming
20:01:11 <cmccann> kmc, I just want a metaprogramming system for Haskell that's type safe :[
20:01:16 <zakwilson> I've heard that about beer too, but I can't remember ever not liking either.
20:01:24 <kmc> cmccann, really? i don't find that a big deal
20:01:41 <kmc> cmccann, by which you mean, the type of code-generating code implies the type of code it generates?
20:01:53 <ddarius> MetaOCaml was pretty sexy though.
20:01:56 <kmc> i don't care too much about that; either way it's resolved at compile time
20:02:00 <cmccann> kmc, by which I mean that if the metaprogram type checks, the code it generates will type check
20:02:03 <kmc> but i think TH is getting that soon
20:02:20 <kmc> there's a ghc wiki page about it
20:02:20 <cmccann> I think MetaOCaml is the prime example of what I'm talking about
20:02:36 <kmc> cmccann, what do you think are the practical benefits of that property?
20:03:02 <cmccann> kmc, metaprogramming-based libraries that are easier to use
20:03:29 <kmc> a library's code generators can throw "runtime" assertions and it's just as good to the user
20:03:49 <kmc> i think most of what TH is used for would never typecheck in that wy
20:03:50 <othiym23> the problem with MetaOcaml is that it's tough to use with JoCaml
20:04:07 <othiym23> OCaml makes me feel like I'm composing compilers sometimes
20:04:07 <ddarius> The join calculus is also pretty sexy.
20:04:15 <othiym23> like I need a compiler monad transformer
20:04:43 <othiym23> I think JoCaml is totally awesome
20:04:51 <othiym23> declarative concurrency is where it's at
20:05:12 <cmccann> kmc, I suspect that places where it would be useful people tend to use SYB-ish stuff or type-level metaprogramming instead, or just not bother at all
20:05:12 * ddarius doesn't believe the join calculus would fall under declarative concurrency.
20:05:30 <Saizan> i think it'd be cool to have declaration macros's type tell you what they are going to define
20:06:06 * ddarius thinks compile-time metaprogramming should be used with a light touch.
20:06:24 <cmccann> but in general, I tend to think that the more distance there is between writing a metaprogramming-based library and writing code that uses it, the more the standard arguments about the benefits of static types apply to the "run-time" of compiling the client code
20:06:35 <othiym23> ddarius: the way the join calculus is folded into JoCaml in practice is very much declarative
20:07:14 <ddarius> othiym23: "Declarative concurrency" often means "concurrency with no observable non-determinism."
20:09:13 <kmc> ddarius, I think the GHC devs call that parallelism, not concurrency
20:09:19 <kmc> and i've adopted their usage
20:09:22 <kmc> but i don't know which is "correct"
20:09:34 <kmc> i may also be missing another subtlety
20:09:43 <ddarius> kmc: No, you can have something that is distinctly concurrent and not parallel or non-deterministic.
20:09:58 <kmc> example?
20:10:32 <Cale> kmc: Like parallel, but where you only have a uniprocessor, I guess.
20:11:28 <othiym23> hmm... I'll have to think about where non-determinism creeps into JoCaml
20:11:32 <cmccann> kmc, I think the distinction I've seen Simon M. draw is that parallelism is doing parts of one conceptual thing at the same time, whereas concurrency is doing two conceptually distinct things in a way that doesn't have a linear ordering
20:13:08 <ddarius> Consider producer-consumer concurrency.  You have one process that produces an element, waits for it to be consumed, and continues, and you have a consumer.  You can write them as separate concurrent processes, nicely decoupling the code.  Run sequentially, the semantics of the program are a deadlock.  Since par annotations don't change semantics, this is not an example of them.  Yet, there is also no non-determinism.
20:13:19 <kmc> *nod*
20:13:25 <kmc> that makes sense
20:13:40 <kmc> more generally, i can make any concurrent system deterministic by restricting the scheduler enough
20:14:09 <kmc> if each thread gets 100 instructions at a time and they run in alphabetical order, there's no non-determinism
20:14:22 <cmccann> kmc, or just resort to cooperative multitasking
20:14:30 <kmc> but i think most programmers in such a model will think of it non-deterministically
20:14:48 <ddarius> You can devise a language where you can never write non-deterministic concurrent programs, and yet has (some) of these examples of situations that are genuinely concurrent.
20:15:09 <kmc> ddarius, i'm interested in how you can enforce determinism statically
20:15:32 <ddarius> kmc: The approach you describe doesn't (just) eliminate non-determinism, it also eliminates concurrency.
20:16:02 <kmc> why is it less concurrent than your lockstep producer / consumer example?
20:16:13 <ddarius> kmc: The same way you can enforce purity in Haskell statically.  Don't allow impure (observably non-deterministic) operations.
20:16:40 <kmc> but you allow message channels in some capacity
20:16:46 <kmc> what restrictions do you impose to make them deterministic?
20:16:54 <othiym23> that is my question as well
20:18:14 <ddarius> A "channel" for this case, is just a linked-list of single assignment cells.  Reading an unread cell blocks until it is written, and it is an error to write to it more than once (which can be handled in a couple of ways.)
20:18:31 * edwardk waves hello.
20:18:52 <kmc> ddarius, ok, sounds like GHC's implementation of Chan in terms of MVar
20:18:53 <kmc> hi edwardk
20:19:15 <ddarius> kmc: I described an implementation like that, yes, albeit with a different primitive than MVars.
20:19:34 <othiym23> ddarius: so where does Erlang fit into this scheme?
20:19:42 <edwardk> keegan, ddarius: looking to schedule another boston haskell, would either of you be up for giving a talk? =)
20:19:45 <ddarius> othiym23: Erlang is a concurrent language.
20:19:54 <ddarius> othiym23: Not a declaratively concurrent language.
20:20:09 <othiym23> what would you consider an example of a declaratively concurrent language?
20:20:33 <kmc> edwardk, when?
20:20:48 <edwardk> kmc: that is the nice part. i haven't scheduled it yet. you tell me =P
20:22:02 <kmc> haha
20:22:14 <ddarius> othiym23: Dataflow languages probably count, though, I'd say (otherwise) there aren't any languages geared to providing only declarative concurrency.
20:22:22 <kmc> i don't think i have anything to talk about this time
20:22:30 <kmc> but i'll let you know if i think of a topic
20:22:41 <edwardk> ddarius: maybe the bloom/boom stuff from hellerstein
20:22:57 <ddarius> kmc, othiym23: I recommend you read the relevant chapter of "Concepts, Techniques, and Models of Computer Programming."  You should be able to find a copy of the draft version online readily.
20:23:16 <othiym23> ddarius: let me restate myself, then: composing concurrency with very high-level language constructs is sexy ;)
20:23:30 <othiym23> ddarius: I've read it
20:24:06 <ddarius> (I suspect many logic languages can also be described as declaratively concurrent.)
20:24:51 <othiym23> I mean, I consider SQL a declarative language, and it gives you control over concurrency (albeit only implicitly or through metadata), but I wouldn't call it a declaratively concurrent language because the two aspects are mostly independent
20:25:55 <ddarius> kmc: To answer your earlier question, your scheme turns non-deadlocking situations into deadlock.
20:27:08 <ddarius> othiym23: The key thing is whether it would have the same semantics run sequentially.  If yes, then it can be called parallelism not concurrency.  If no, then it is concurrency.
20:27:50 <othiym23> ddarius: OK, having scanned through Haridi & van Roy's definition of declarative concurrency, I'd say that JoCaml makes it possible to write declaratively concurrent programs, but it doesn't restrict you to only writing declaratively concurrent programs
20:28:04 <ddarius> othiym23: So does any concurrent language.
20:28:09 <othiym23> yes
20:28:24 <ddarius> othiym23: Okay, by that logic, C is a purely functional language.
20:28:26 <othiym23> JoCaml gives you a nice set of combinators for modeling concurrency, though
20:28:37 <othiym23> ddarius: I'm no longer sure what we're arguing about
20:29:36 <othiym23> what I like about JoCaml is that I can think in terms of communicating concurrent / distributed processes instead of juggling mutexes and synchronization and service lookup and what-have-you
20:29:56 <othiym23> and separate out the bits that actually do the distribution / thread / process management
20:30:28 <ddarius> othiym23: That's just high-levelness.
20:32:16 <othiym23> also, that it allows me to model a much larger set of strategies for concurrent computation than something like Hadoop can handle, very concisely
20:32:31 <othiym23> it feels declarative to me, but I take your point, I should be more careful with my language
20:33:40 <ddarius> Hadoop is not meant for defining general strategies for concurrent computation, quite the opposite.
20:35:52 <othiym23> but that's how it's regarded at a lot of companies, in much the same way that Erlang is
20:41:17 <kmc> yeah, programming with explicit locks just seems painful now
20:41:28 <kmc> it doesn't help that the Linux kernel has about a dozen different kinds of locking
20:41:40 <kmc> and a big ol matrix of how they interact
20:42:14 <Saizan> fun
20:42:36 <othiym23> given how much of my time I've spent buried in tools that are designed exclusively to identify and elimintate threading problems, I've decided that low-level concurrency programming is only for kernel hackers and / or suckers anymore
20:43:16 <kmc> even a lot of the kernel stuff could be written in a correct-by-inspection way
20:43:28 <kmc> if we had a better systems language than C
20:43:29 <ddarius> othiym23: The point of Hadoop is that if you -can- (reasonably) express you concurrent computation within its "language," then it will make it scalable.  It deliberately restricts the language (and thus the [reasonably expressed] concurrent computations) to guarantee the scalability.
20:44:24 <othiym23> ddarius: sure. I'm just saying that people are torquing it (or, more often, their problem spaces) into shapes that diverge pretty far from MapReduce
20:45:57 <kmc> of course
20:46:21 <kmc> if you tell someone "here's 10,000 machines, but you can only program it in language X", they will find a way to simulate a Turing machine in language X and then solve the problem their own damn way
20:46:55 <ddarius> othiym23: If it's still scaling (and technically even if it is not) that suggests that the set of strategies for concurrent computation that it can handle is larger.
20:47:11 <edwardk> depends on how fast the machines are and what polynomial factor you lose encoding your turing machine ;)
20:47:21 * djahandarie would find a way to simulate a lambda calculus instead
20:47:29 <othiym23> edwardk has it, more or less
20:47:30 <ddarius> Just encode the GoL Turing Machine automaton.
20:48:22 <othiym23> the benefits of scaling by throwing more nodes at the problem yield diminishing returns, but these companies have already built this infrastructure out in The Cloud, so they're kinda stuck due to the sunk effort
20:49:05 <ddarius> Rationally, you don't continue down a bad path just because of sunk costs.
20:49:11 <othiym23> also, it's a leaky abstraction and not super efficient
20:49:25 <othiym23> I don't think rationality has anything to do with it
20:49:38 <ddarius> othiym23: That is probably the correct answer.
20:49:54 <kmc> ddarius, but you also don't abandon infrastructure which has value, even if it has flaws
20:50:01 <kmc> there's a sunk costs anti-fallacy as well
20:50:30 <ddarius> kmc: You do if it's costing you more than it's gaining you, and you have to include opportunity costs.
20:50:46 <kmc> workable if flawed projects get canceled at the last stage because someone doesn't like the necessary compromises, or they're sure that version n+1 will solve all those problems
20:51:12 <kmc> ddarius, right, you have to consider both sides of the equation; focusing unduly on either is an error, and both errors occur in practice
20:52:01 <othiym23> and often the people making the go / no go decisions aren't in a good position to understand the real costs involved, and don't necessarily trust the people who *do* understand the costs
20:52:06 <kmc> it's hard to do this right; chalking it all up to corporate irrationality is simplistic
20:52:07 <ddarius> If it's not costing you more than it's gaining you even after factoring in opportunity costs, then it was the right thing to do and you are hardly "stuck."
20:52:11 * othiym23 has not had super good luck with employers in this respect
20:52:17 <kmc> remember that there's *huge* variance on any new development project
20:52:25 <cmccann> kmc, people tend to systematically overestimate the value of assets they have, underestimate the value of assets they don't have, and SEVERELY overestimate the value of assets they used to have but lost
20:52:27 <kmc> risk aversion is economically rational, so you have to factor that in
20:52:31 <kmc> cmccann, yep
20:52:45 <kmc> actually i'm not sure about "underestimate the value of assets they don't have"
20:52:53 <kmc> i think we want what we can't have in part because we think it's better than it is
20:53:05 <kmc> there's shades of Blub there as well
20:53:38 <othiym23> kmc: that's what causes Second System Effect a lot of the time
20:54:01 <othiym23> and I would say that people both systematically overvalue and undervalue their existing systems
20:54:06 <cmccann> risk aversion is pretty much by definition irrational, otherwise it'd just be correct risk assessment. the problem is that naive calculation of risk fails to account for having a floor below which losses are unrecoverable
20:54:25 <cmccann> probability is a lot harder when you can't assume that stopping conditions are independent of intermediate results
20:54:35 <kmc> yeah
20:54:37 <othiym23> overvalue because they put up with too many problems, undervalue because existing systems encode a ton of implicit requirements that will be unsatisfied by replacing the system
20:54:42 <kmc> 'the market can remain irrational longer than you can remain solvent'
20:54:46 <cmccann> (actually given probability as a functor, I think this is roughly the difference between applicative and monad, heh)
20:54:52 <ddarius> cmccann: Indeed, a lot of "irrational" human behavior becomes more rational in view of more realistic analyses.
20:54:55 <kmc> cmccann, o_O
20:55:30 <ddarius> Furthermore, bounded rationality is a much harder problem.
20:55:54 <cmccann> ddarius, most "irrational" human is an intuitive kludge approximating the most sensible thing to do, whereas "rational" behavior tends to ignore critical details
20:56:20 <kmc> yep.  it's funny to compare which parts evolution figured out, vs. which parts humans figure out
20:56:27 <ddarius> cmccann: Analyses ignore critical details.  Rational behavior never ignores any relevant details.
20:56:27 <cmccann> being actually rational as in doing what is likely to get the best results is indeed "much harder"
20:56:42 <cmccann> ddarius, hence the scare quotes around rational there
20:56:44 <kmc> that's why rational behavior is impossible in practice
20:57:06 <kmc> i think professional software engineers grossly underestimate the difficulty and skill involved in making these sorts of business decisions
20:57:11 <kmc> or maybe just the ones who post on Reddit do
20:57:38 <cmccann> kmc, there's lots of research about just how bad people in general are at estimating the difficulty involved in anything
20:57:47 <othiym23> most "professional" software engineers just want to do what they want to do, and come up with justifications ex post facto
20:57:48 <ddarius> kmc: Internet people overall tend to underestimate the difficult and skill involved in making any decision.
20:57:49 <kmc> yep, and also their own competence :)
20:58:14 * cmccann finds it funny that often the most reliable estimate comes from ignoring all the "important" details and guessing based on how vaguely similar things worked out before
20:58:43 <kmc> "lol, those managers just write memos and go to meetings all day"
20:58:48 <othiym23> http://www.amazon.com/Facts-Fallacies-Software-Engineering-Robert/dp/0321117425
20:58:50 <kmc> "lol, those programmers just type numbers and curly braces all day"
20:59:17 <kmc> i know there's a few companies using internal prediction markets for estimating completion time, costs, etc
20:59:21 <kmc> i wonder how well it works for them
20:59:43 <thoughtpolice> i don't know about business decisions, but i can sure appreciate the difficulty of estimating things
21:00:09 <othiym23> I started a company last year, and we ran our dev process using scrum
21:00:25 <othiym23> we were scrupulous in our efforts to estimate things, and in tracking how much time we spent on things
21:00:27 <cmccann> kmc, anyway, it's almost certainly possible to do better than the baseline of intuitive kludges approximation rational behavior, but the habit of overextending limited analysis by pretending it's comprehensive as people often do isn't the way to go about it
21:00:42 <kmc> yeah
21:00:44 <othiym23> after having done things for six months, we looked to see what sort of correlation there was between our estimates and how long it took us to do things
21:00:59 <othiym23> the correlation was something like 0.012
21:01:02 <kmc> hehe
21:01:09 <kmc> that's really cool that you even bothered to check
21:01:13 <kmc> empiricism ftw
21:01:32 <cmccann> See also the "planning fallacy"
21:01:58 <othiym23> when you're not getting paid until money starts coming in from your finished product, you tend to care a whole lot more about being able to reliably forecast when things will be ready
21:03:17 <kmc> so what did you think were the valuable parts of scrum?
21:03:23 <othiym23> that book I linked to above is filled with empirical data saying that accurate estimation is almost impossible, especially if you've got a good team who aren't just doing the same things over and over again
21:03:32 <othiym23> 1. keeping horizons short
21:03:41 <kmc> my cynical impression is that "scrum" is some common sense agile-y things, but delivered by a highly-paid certified scrum guy
21:03:46 <othiym23> 2. assessing how effective the process is being every two weeks
21:04:35 <kmc> othiym23, so the companies with a bad team doing the same thing over and over are optimizing for predictability?
21:04:46 <othiym23> 3. keeping management overhead low (it took us about 6 hours every two weeks to do the planning, demo, and retrospective, plus it took me about 15 minutes of work a day to update the spreadsheet)
21:05:07 <othiym23> kmc: predictability over productivity, yeah
21:05:54 <othiym23> 4. we only gathered the metrics we thought were useful, but we came up with a lot of simple statistics that allowed us to track not only our velocity, but our momentum
21:06:18 <ddarius> From which you could calculate your mass?
21:06:29 <kmc> what kind of stats?
21:06:30 <othiym23> momentum turned out to be the most important measurement we had -- are we getting better at working with this code base fast enough to hit our dates with most of the features intact?
21:06:56 <cmccann> of course, if being able to make irrevocable business decisions well in advance is more important than total project time, optimizing for predictability may be the actual better choice
21:07:06 <othiym23> how many hours per story point, how many real hours of work we did per day, how many story points we could get done in a sprint -- really, really basic stuff like that
21:07:22 <othiym23> cmccann: yeah, but then you're screwed when you have to do something new
21:07:33 <kmc> story point?
21:07:47 <cmccann> othiym23, there are still quite a few businesses that don't, in general, need to do anything new ever
21:07:51 <cmccann> at least as far as software goes
21:08:21 <othiym23> kmc: estimation in some versions of scrum is done via a story point, which is an abstract and relative measure based on some vague handwavey notion of a given story's complexity
21:08:51 <othiym23> it turns out to be a useful feature that it's vague and handwavey in the larger scheme of things because it keeps you from spending years arguing about how long it's going to take to do everything
21:10:03 <othiym23> cmccann: Robert Glass would argue that the creative aspects of software engineering are significant more often than you'd think, and that creativity is where you can run into trouble with estimates
21:10:49 <ddarius> Ideally, designing software should be almost entirely creative.
21:10:53 <othiym23> cmccann: I think my canonical example would be deploying ERP software, which is always sold as a basically mechanical consulting effort, but which almost always results in huge cost overruns (which, you know, is often a feature rather than a bug for the vendors due to the huge consulting fees they rack up)
21:11:16 <othiym23> ddarius: I agree, and that's a large part of the appeal of using a language based on abstraction extraction (like Haskell)
21:11:44 <othiym23> but that's not really how enterprise software engineering management works
21:12:11 <othiym23> see e.g. the Rational Unified Process, which treats software engineering as a basically mechanical process
21:12:17 <cmccann> othiym23, yes, but the proportion of novelty to wheel-reinvention varies considerably, and if it's low enough then factors based on creativity fade below the level of other statistical noise
21:12:27 <cmccann> not that that's a GOOD way to do things, from a broad perspective
21:12:47 <ddarius> cmccann: othiym23's point is that it is still relatively high even in those cases.
21:13:28 <othiym23> all I know is that if my team at my last gig before my startup had been able to actually fix stuff correctly and then move on to other problems, we would have been orders of magnitude more productive
21:13:45 <othiym23> instead, we ended up stuck in operational hell a lot of the time
21:15:04 <othiym23> I woulda had to teach my coworkers how to use higher-level tools, and that would have been a challenge (they were good people, but Java was about as abstract as they could go, being largely ex-DBA types), but it was an effort just to pull our heads up enough to rebuild components that were clearly broken
21:15:06 <othiym23> anyway!
21:15:08 <othiym23> sorry to derail
21:15:59 <Jafet> Being paid to program sucks.
21:16:13 * cmccann jumps back to an earlier rail, then
21:16:14 <ddarius> It's better than being not paid.
21:16:31 <Jafet> Seems that it's usually worse
21:16:40 <ddarius> Jafet: Then refuse the money.
21:17:37 <Jafet> Be a lumberjack
21:17:41 <ddarius> Alternatively, be paid to do something else.
21:17:43 <ddarius> Yes.
21:17:49 <othiym23> you know, dealing with management and process sucks, but building stuff that people find useful and helpful is totally awesome
21:17:59 <othiym23> and the two things almost inevitably come as a package
21:18:00 <ddarius> othiym23: Yes.
21:18:05 <aspect> if management let you do that :-)
21:18:07 <cmccann> kmc, consider the list monad in the "poor man's nondeterminism" sense. Using only Applicative, the selection of results at each stage is causally independent of prior results. Using Monad, behavior at one stage can change the structure of following stages (including skipping them entirely)
21:18:48 <sshc> cmccann: Why would you consider it "poor man's"?
21:18:52 <cmccann> kmc, given a statistical interpretation then, an applicative expression produces a result based on the inputs as independent distributions, while monad allows conditional distribution
21:19:17 <aspect> I've had experiences in software where something useful and helpful is perceived as (potentially) making the client less dependent, so actively discouraged
21:19:18 <cmccann> sshc, because it introduces spurious ordering, and because it's very simple
21:19:34 <cmccann> sshc, neither of which implies it's bad, just simplistic
21:19:38 <othiym23> aspect: I'd argue that if you find yourself in a situation where you can't get through management to do useful stuff, it's up to you to either change your situation or circumstances
21:19:46 <othiym23> e.g. start prowling LinkedIn
21:20:07 <othiym23> also, that's why I'm not in enterprise software engineering anymore
21:20:41 <cmccann> enterprise software engineering, i.e. "the R&D department for The Daily WTF"
21:21:23 <othiym23> pretty much, yeah
21:21:31 <aspect> indeed.  My current plan is to take next year living in a cheaper environment on what I've managed to save and see how I go producing and marketing useful tools by myself
21:22:20 <aspect> maybe not the wisest idea, but I'll at least enjoy the year and return refreshed with some useful tools for myself :-)
21:22:32 <sshc> When is -fcse a problem for unsafePerformIO?  What exactly will cause GHC to "common-up" multiple uses of unsafePerformIO?  I'm trying to deliberately cause this to happen with unsafePerformIO with two top-level declarations with identical definitions with "newIORef" (with a NOINLINE pragma), but the result is still two distinct IORefs.
21:22:42 <othiym23> aspect: I think that's a great idea
21:22:47 <ddarius> Actually, my issues with my current, particular "enterprise software engineering" job have little to do with management (of myself), process, or technical details, but rather the "people" environment.
21:23:14 <kmc> cmccann, makes sense
21:23:49 <dolio> foo = f (unsafePerformIO (newIORef 5)) (unsafePerformIO (newIORef 5))?
21:24:06 <Jafet> “Lo! Men have become tools”
21:24:22 <ddarius> Jafet: Men were always tools.  Ask any woman.
21:25:31 <kmc> aspect, i've seen one group sabotage the efforts of another to improve a shared and very direct revenue stream
21:25:33 <Jafet> More interesting is foo = f bar bar where bar = unsafePerformIO (newIORef 5)
21:25:43 <kmc> because it would make the first group less important within the company
21:25:50 <sshc> dolio: More importantly, is -fcse never a problem when the unsafePerformIO is used in different top-level declarations, even if the declarations themselves are the same?
21:25:59 <kmc> and these were groups of ~20, at a company of fewer than 200 people total!
21:26:11 <aspect> kmc: it is indeed a wonderful industry we work in :/
21:26:14 <dolio> Jafet: That has already had CSE performed on it, so there's nothing for CSE to do.
21:26:19 <kmc> Jafet, I would entirely expect that one to share an IORef
21:26:31 <kmc> aspect, I'm not sure that even had anything to do with software, though
21:26:41 <othiym23> beats coalmining!
21:26:51 <ddarius> What a wonderful world we work in.
21:27:12 <ddarius> othiym23: I'm not keen on caves, so I'll agree with you there.
21:27:12 <dolio> sshc: I don't really know.
21:27:20 <ddarius> Though nowadays they just blow up mountains.
21:27:20 <kmc> my analysis of that situation is that the organizational lines were drawn on fundamentally the wrong axis
21:27:31 <kmc> they were hardware vs. software; they should have been production vs. R&D
21:27:48 <kmc> as a result, the hardware guys sabotaged hardware R&D by the ostensibly "software" guys
21:27:58 <sshc> Is there any documentation about how GHC does CSE?  I need to know whether it can affect different top-level declarations
21:28:04 <kmc> even though they sucked at hardware R&D themselves
21:28:22 <Jafet> f :: IORef Integer -> IORef Int -> IO()
21:28:27 <ddarius> sshc: Probably very little.
21:29:21 <othiym23> kmc: when companies develop discrete silos, it's hard to avoid that kind of infighting
21:29:34 <cmccann> kmc, ...I have to admit that "makes sense" is not the answer I expected to a random bit of abstract thinking about statistics and monads, haha
21:29:51 <kmc> cmccann, it does though :)
21:31:09 <cmccann> kmc, I would hope so, because it's correct as far as I know, but still!
21:31:23 <kmc> maybe i've spent too long in this channel ;)
21:31:38 * cmccann considers writing a monad tutorial explaining monads in terms of statistics, entropy, and the arrow of time
21:31:51 <ddarius> kmc: You have.
21:31:59 <kmc> i did really enjoy this digression into management, estimation, etc.
21:33:15 <kmc> othiym23, but how do you keep necessary division of responsibility from devolving into infighting?
21:33:46 <othiym23> kmc: you have to find some way of keeping everyone's eye on the fact that they're working towards a common goal
21:33:55 <othiym23> much like running any community, I guess
21:34:01 <kmc> yeah
21:34:09 <kmc> it makes me sad how much the word 'community' has become devalued
21:34:20 <ddarius> In a word, "leadership."
21:34:23 <cmccann> or, alternatively, by ensuring that any sub-group is rewarded proportionally to the degree which they benefit other groups
21:34:28 <kmc> now it just means any group of people, particularly a group you're trying to pander to
21:34:37 <kmc> but i think that hides an important question
21:34:51 <kmc> which is what you said: how do you get a group of people all on the same page?
21:35:08 <cmccann> which is roughly what the relationship is between separate companies, so it amounts to giving up on the benefits of a unified whole
21:35:22 <kmc> not in terms of agreeing on every decision, but agreeing on goals and vocabulary
21:35:35 <cmccann> kmc, start a cult
21:35:41 <cmccann> I think that's the only proven method, really
21:35:42 <othiym23> I think a lot of it comes down to keeping the organization as flat as possible and the budget as widely distributed as possible
21:35:51 <kmc> cmccann, i fear you've only rephrased the question
21:35:54 <othiym23> so you don't end up with subcompanies feeling like they're competing with each other for resources
21:36:14 <ddarius> Divide and conquer!
21:36:22 <ddarius> No freedom of assembly!
21:36:30 <othiym23> anyone who thinks that, say, the Scientologists aren't riven by a huge amount of infighting is being very idealistic in a very peculiar way
21:38:02 <kmc> yeah, there's a group who are basically to Scientologists as Protestants are/were to Catholics
21:38:26 <kmc> practicing dianetics outside the church
21:38:56 <edwardk> kmc: heretics!
21:39:14 * cmccann never said running a cult was EASY, just demonstrably more successful than anything else :]
21:39:19 <ddarius> Let them be taken by the Thetans.
21:39:24 <othiym23> even within the church, there's a ton of factionalism
21:39:26 <kmc> unfortunately "ensuring that any sub-group is rewarded proportionally to the degree which they benefit" directly contradicts "keeping... the budget as widely distributed as possible"
21:39:27 <cmccann> edwardk, SHUN THE UNBELIEVERS
21:39:33 <kmc> which sucks because they both sound like good advice individually
21:39:54 <cmccann> kmc, yes, they're deliberately incompatible
21:39:57 <othiym23> well, I think there's a competitive way to run an enterprise, and a coöperative way
21:40:00 <othiym23> you have to choose one
21:40:17 <cmccann> kmc, the competitive way as in my quote basically amounts to recreating the dynamic of the market as a whole
21:40:30 <othiym23> do you want hierarchy, or do you want a community of freewheeling experts?
21:41:01 <arlenik> Is there an errata for  'Learn You a Haskell' ?
21:41:18 <djahandarie> arlenik, the paper copy? Dunno.
21:41:32 <cmccann> the benefit of the competitive style is that it has much better worst-case behavior, but the downside is massive inefficiency vs. best-case cooperative style
21:41:53 <kmc> cmccann, yeah.  to some degree they're respectively compatible with different sizes of company
21:41:59 <kmc> and some companies really botch the phase transition
21:42:02 * hackagebot attempt 0.3.1 - Concrete data type for handling extensible exceptions as failures.  http://hackage.haskell.org/package/attempt-0.3.1 (MichaelSnoyman)
21:42:16 <kmc> i do wonder the overall importance of drawing organizational lines at "natural" points
21:42:23 <kmc> it seemed to be a major problem in the example i gave
21:42:27 <kmc> but there certainly were other problems
21:42:29 <cmccann> kmc, yes, and botched transitions usually result in tribalism and empire-building
21:42:53 <kmc> i'm not sure how to find the natural lines of division anyway
21:43:03 <cmccann> kmc, which happens to be the exact same result as when governments botch the transition
21:43:12 <kmc> heh
21:43:58 <kmc> big companies seem basically hopeless to me
21:44:07 <kmc> but i've never worked for a huge one, so maybe it gets better again at some scale
21:44:15 <othiym23> kmc: the natural lines of division are generally around people rather than what people do
21:44:17 <ddarius> kmc: I doubt it.
21:44:21 <cmccann> kmc, few organizations larger than ~200 people aren't hopeless, it's human nature
21:44:23 <ddarius> othiym23: Indeed.
21:44:27 <kmc> cmccann, ah, Dunbar's number?
21:44:39 <kmc> i'm sure there are individual groups at Google which operate basically as independent startups
21:44:41 <ddarius> I was thinking of just seeing what groups form, then drawing the lines around them.
21:44:45 <kmc> i doubt many of them do, though
21:44:54 <cmccann> if memory serves me Dunbar's number doesn't really hold up
21:44:59 <cmccann> scientifically, that is
21:45:09 <kmc> cmccann, the exact number, or the idea?
21:45:13 <arlenik> djahandarie: I'm readying it online.  Chapter 8, section type-parameters, `vectMult` and `scalarMult` are mixed up.
21:45:25 <cmccann> the exact number and how it was derived. The idea seems plausible enough to consider.
21:45:39 <kmc> yeah, i don't care if it's 100 or 200
21:45:46 <kmc> but it does seem to be somewhere around there
21:45:56 <kmc> othiym23, yeah.  often people get placed according to the skills they listed on their résumé when applying
21:46:05 <kmc> "oh, you did some VHDL in college.  you're a hardware guy now"
21:46:42 <othiym23> yeah, but beyond that, you don't want to choose managers based on silos, you want to see who they're working with, and build the hierarchy up that way
21:46:53 <cmccann> kmc, I also wonder if it's actually a feature of organizational dynamics involving independent agents in general, not tied to humans as such, but I don't have firm opinions either way
21:46:53 <djahandarie> arlenik, I don't see why there'd be an errata for the online version. :p Just send BONUS an email or something.
21:46:54 <othiym23> like, around projects rather than duties, and communities of interest within the company
21:46:58 <kmc> but it's easier to learn a new skill than to learn to deal with a group of people you don't like
21:47:05 <othiym23> I've seen some pretty big, pretty flat companies work well that way
21:47:44 <kmc> BONUS will fix errors in the online copy based on e.g. Reddit comments
21:47:52 <othiym23> Google is experimenting with all of this in a major way, but they're tough to use as a case study, because it's hard to say how well all this is working for Google-the-company instead of Google's employees
21:48:23 <arlenik> djahandarie: I figured if the online version has an error in it, then the paper copy too.  I'll email him, though.
21:48:38 <kmc> othiym23, what do you think are the interesting bits of experiment?
21:48:48 <ddarius> arlenik: The online version is quite a bit more malleable.
21:49:05 <ddarius> arlenik: But hasn't undergone the proofreading of the printed version.
21:49:36 <othiym23> kmc: allowing people to choose their projects, giving people the freedom to work on projects not directly tied to shipping code, letting the engineers control product management to a relatively large degree
21:50:54 <kmc> do you mean for example the 10% / 20% stuff?
21:51:26 <othiym23> yeah, that's part of it, but there's also just a culture of allowing a lot of speculative development
21:51:40 <othiym23> although I get the sense that that's diminishing over time
21:51:57 <kmc> that's quite inconsistently applied
21:52:04 <othiym23> yep
21:52:13 <othiym23> but that's part of how it's experimental
21:52:23 <kmc> the idea means nothing as written, because programmers are salaried and are judged on results, not hours on the clock
21:52:43 <ddarius> The more and larger products you have, the more people are going to be dedicated to simply maintaining them.
21:52:50 <kmc> "sure, take 20%, whatever.  the deadline for your real work is still next tuesday"
21:52:58 <kmc> so you get your 20% time but only if you work 120% as many total hours
21:53:07 <ManateeLazyCat> if-up.d/ scripts have no display when running, how to make if-up.d script have display? Someone know? :)
21:53:25 <kmc> some managers can schedule deadlines around the idea of discretionary time
21:53:35 <othiym23> kmc: my understanding is that Google is extraordinarily loose about deadlines given its size and scale
21:53:47 <kmc> i don't know how they are incentivized to do so, if at all
21:54:15 <kmc> the whole thing seems backwards to me, anyway -- shouldn't I just leave work early and hack for fun on my own time?
21:54:55 <othiym23> that's where the magical Google hiring process kicks in
21:55:15 <othiym23> they select for type A monomaniacs
21:55:19 <ddarius> From what I hear, Google employees just don't leave work.
21:55:23 <kmc> exactly
21:55:36 <othiym23> and then try to cosset them as much as possible in the office to keep them there
21:55:56 <kmc> and that includes convincing employees to do their hacking-for-fun in the office
21:56:09 <kmc> and then getting them to believe it's a great form of compensation
21:56:22 <othiym23> occasionally your hacking-for-fun project turns out to be something like Chrome, though
21:56:39 <othiym23> getting your pet project in front of millions of people who then use it every day has to be a serious egoboo
21:56:44 <kmc> yeah
21:56:53 <kmc> i'm not convinced the Google hiring process can be all that magical, anymore
21:57:02 <kmc> they just have too many employees and too much turnover to be all that selective
21:57:40 <othiym23> I know a dude who left IBM Watson for Google and went from doing some amazing computer vision stuff to working on their voice recognition stuff and is much, much happier at Google than he ever was at IBM, even though his work isn't nearly as important
21:58:18 <othiym23> yeah
21:58:37 <othiym23> I never really wanted to work for Google, and I really didn't want to go through their hiring process
21:58:57 <othiym23> it's so insanely awful that people who work there give up on recommending their friends to Google because it's embarrassing
21:59:04 <kmc> how so?
21:59:10 <djahandarie> Huh?
21:59:37 <kmc> mostly i've just heard that the bar is a lot lower than they want you to think
21:59:44 <othiym23> it depends
21:59:49 <ddarius> kmc: Of course it is.
22:00:00 <othiym23> if they want you for a specific skill you have, then it can be pretty easy to get in
22:00:22 <dibblego> so it is at IBM too
22:00:47 <othiym23> otherwise, you get asked a bunch of bullshit brainteaser questions and get hit with ridiculous programming problems that have no actual applicability or relevance to your actual skills as a developer
22:01:06 <kmc> ah, brainteasers :)
22:01:18 <othiym23> I have a friend who kept getting hit up by Google's recruiters because he has tons of mobile dev experience, and he kept getting shot down by the interviewers
22:01:24 <kmc> i ran many a brainteaser interview back at ye olde finance company
22:01:27 <kmc> they were fun
22:01:29 <othiym23> this was happening like every six months before he told them to go screw themselves once and for all
22:01:38 <kmc> probably produced zero useful hiring information
22:01:40 <kmc> but they were fun
22:02:30 <kmc> once you work in finance you will never stop hearing from finance recruiters.  in fact, anyone you meet in the finance industry will treat it as physically impossible that you'd leave and do something else
22:02:56 <othiym23> given that I may soon be working with a whole bunch of ex-quants, that's interesting to hear
22:03:04 <kmc> if you talk about leaving hedge fund X they will start mentioning a bunch of other funds and banks
22:03:09 <kmc> heh
22:03:09 <ddarius> "This is where the money is at.  Literally.  Why would you leave the money?  What do you mean you don't care about money?"
22:03:14 <kmc> exactly
22:03:36 <kmc> i think the assumption is a) lifestyle instantly increases to meet income; b) lifestyle can never decrease
22:03:55 <cmccann> kmc, empirically speaking that assumption is correct
22:04:10 <kmc> yeah
22:04:18 <ddarius> cmccann: Right up until the repo men come for the unpaid credit card bills.
22:04:37 <kmc> i think it's like drug addiction, in that there are some people who really have a pretty easy time avoiding it, but also that all the future addicts think they're one of those people
22:05:00 <othiym23> speaking as a lazy hacker from the West Coast of the US, I prize being able to roll into work at 10 every day over having a Z-series and a co-op on the UWS
22:05:02 * ddarius is one of those people.
22:05:10 <cmccann> ddarius, well yeah, I was taking it more in the sense of "most people will not willingly accept a reduction in lifestyle expenses"
22:06:06 <kmc> in finance it's even weirder because half+ of the money you're spending on that lifestyle is "bonus" which you might not even get
22:06:47 <othiym23> ha ha
22:06:51 <othiym23> "might not"
22:07:18 <kmc> at least for the quants it is pretty simple, make money for the firm and you make money for yourself
22:07:18 <othiym23> if the last 3 years have taught us anything, it's that those "bonuses" might as well be an inviolable covenant with the Lord
22:07:42 <kmc> othiym23, maybe at a big bank
22:07:57 <othiym23> or a hedge fund, or at one of the two or three remaining ibanks
22:08:04 <mbernstein> work for other people just sucks in general, it's just a sad byproduct of desire
22:08:06 <kmc> hedge funds explode and pay 0 bonus all the time
22:08:18 <mbernstein> i've thought about quitting my boring job that pays a ton for awhile because i'm bored as shit
22:08:21 <kmc> even more often, they fire individual traders by paying 0 bonus
22:08:27 <ddarius> mbernste1n: Do it.
22:08:33 <othiym23> mbernstein: I've done it a couple times now
22:08:36 <othiym23> I recommend it
22:08:44 <mbernstein> but i keep being realistic and saying hey - i can do whatever i want at work most of the time cause i get what i need to get done in 1/10th the time i have to do it
22:08:45 <mbernstein> so why worry?
22:08:57 <mbernstein> it's tough :)
22:09:02 <othiym23> my startup ended in wrack and ruin and I still had wayyyyyyy more fun than I'd had the preceding four years
22:09:12 <identity_> I quit my job, went back to the motherland and worked at sea
22:09:16 <identity_> That is how we vikings roll
22:09:20 <mbernstein> heh
22:09:20 <ddarius> mbernstein: Are you happy?  If so, keep on truckin'.  If not, then isn't that reason enough?
22:09:27 <cmccann> identity_, that is clearly the best option
22:09:31 <mbernstein> ddarius: I'm not super unhappy, but i'm not happy I guess?
22:09:37 <ddarius> identity_: Thinking about doing that minus the "mother land."
22:09:37 <identity_> Granted, it sucked copious amounts of male genitalia to be at sea and I do not recommend this
22:09:46 <identity_> But I did it
22:09:49 <mbernstein> I'm pretty much ambivalent
22:10:07 <mbernstein> I know I could be doing more interesting/important things, though
22:10:12 <identity_> I worked 780 hours over the course of two months or so and made crap all
22:10:25 <ddarius> mbernstein: Well, you can try this plan for a while and see how it goes, as long as you are pretty sure you can get back in about where you are now (pay/position-wise not necessarily the same place.)
22:10:26 <othiym23> mbernstein: I guess for me the thing is, if you're having fun outside of work, and your job supports your ability to do the things you want to do when you're not there, then that's fine
22:10:26 <cmccann> mbernstein, ambivalence about where you are in life is unhappiness you just haven't noticed yet :P
22:10:45 <othiym23> cuz, y'know, work sucks
22:10:51 <kmc_> cmccann, or it's contentment?
22:10:57 <mbernstein> ddarius: I'm just waiting til my wife finishes grad school mostly since I'm able to pay for it without loans
22:11:06 <kmc_> needing to always be searching for something better is also a disease
22:11:09 <ddarius> mbernstein: Okay.
22:11:13 <othiym23> but if it leaves you with enough excess energy / time / resources to do what you want on your private time, awesome
22:11:27 <kmc_> it's part of the lifestyle thing in fact
22:11:27 <mbernstein> ddarius: After that, I'm gone probably.  It's a risk assessment type of deal for me, although I don't think I'd be unemployed more than 2 weeks where I am (austin, tx - huge shortage of anyone competent heh)
22:11:40 <ddarius> kmc_: Contentment wouldn't be ambivalent.
22:11:49 <cmccann> kmc_, I don't read "ambivalent" as meaning "satisfied", but I agree otherwise
22:12:08 <mbernstein> my issue mostly is, there's no one to learn anything from where I am - at least not technically related
22:12:15 <ddarius> mbernstein: Austin was, I think, the only place in Texas I vaguely liked.  Which is probably not surprising.
22:12:30 <mbernstein> ddarius: It's the only place in Tx I like, so it works out well that I live here :P
22:12:34 <ddarius> @wn ambivalent
22:12:36 <lambdabot> *** "ambivalent" wn "WordNet (r) 2.0"
22:12:36 <lambdabot> ambivalent
22:12:36 <lambdabot>      adj 1: characterized by a mixture of opposite feelings or
22:12:36 <lambdabot>             attitudes; "she felt ambivalent about his proposal";
22:12:36 <lambdabot>             "an ambivalent position on rent control"
22:12:38 <lambdabot>      2: uncertain or unable to decide about what course to follow;
22:12:39 <kmc_> i think it's easy to paint someone who's content as "ambivalent" or even "depressed"
22:12:40 <lambdabot>         "was ambivalent about having children"
22:12:56 <mbernstein> Also, mortgages make you rethink that whole risk thing too :P
22:12:58 <kmc_> it's human nature never to be perfectly content
22:13:00 <ddarius> kmc_: Someone who's content, wouldn't have conflicting feelings.
22:13:09 <kmc_> we didn't get to where we are by kicking back and taking it easy
22:13:37 <kmc_> everyone has doubts sometimes
22:13:42 <othiym23> mbernstein: there are some amazing startups in Austin right now, too
22:14:01 <mbernstein> kmc_: I think there's a huge difference between being content solving hard problems and finding meaning in work vs. just slacking off and such.  You can be happy and work your ass off
22:14:25 <kmc_> true
22:14:26 <identity_> If you're perfectly content you are most likely closer to braindead than anything else
22:14:28 <mbernstein> othiym23: Which ones?  I've had one trying to poach me for 3 years (otherinbox), but none of them really have me wanting to go work there
22:14:31 <identity_> Vegetable, etc
22:14:33 <kmc_> that's not really what i was getting at though
22:14:47 <kmc_> our culture says that you're a depressed loser unless you're working for that bigger house and faster house and prettier wife
22:14:50 <kmc_> that's dumb
22:14:52 <kmc_> some people are happy
22:14:55 <othiym23> mbernstein: http://www.infochimps.com/ is the one I've had the most contact with
22:15:00 <kmc_> that doesn't mean having no doubts ever
22:15:03 <mbernstein> othiym23: yea, mrflip
22:15:07 <kmc_> faster car*
22:15:11 <kmc_> though i like the idea of a faster house
22:15:14 <mbernstein> othiym23: I know him heh, decent place yeah
22:15:15 <ddarius> Aw, I wanted a faster house.
22:15:23 <kmc_> motor home!
22:15:27 <kmc_> the true American status symbol
22:15:55 * ddarius considers different ways of parsing that last fragment.
22:16:20 <othiym23> mbernstein: I know their director of product, he's a good guy
22:16:52 <mbernstein> othiym23:  dennis?
22:17:02 <othiym23> mbernstein: yeah
22:17:10 <mbernstein> othiym23: infochimps got big really fast in the past year - I remember when it was flip and joe at our local ruby meetings, heh
22:17:15 * djahandarie watches mbernstein and othiym23 find out that they actually know each other in real life
22:17:20 <identity_> I decided that the only real way to be happy is to stop trying. I have therefore decided to return to Denmark and make it my mission to not be employed whilst, at the same time, drink as much beer possible at ridiculous hours and in stupid places.
22:17:26 <identity_> Benches, airports, benches, grocery stores
22:17:26 <identity_> etc.
22:17:28 <kmc_> :D
22:17:37 <copumpkin> the http library is surprisingly ugly for a "standard" library
22:17:39 <kmc_> http://www.youtube.com/watch?v=zwXjm64a3QE
22:17:49 <djahandarie> copumpkin, I have experience the same
22:17:49 <kmc_> copumpkin, is it worse than the regex libraries?
22:17:58 <djahandarie> We don't talk about those.
22:18:03 <othiym23> mbernstein: Dennis almost signed up to work with my startup and be our product / business dude, but thought that making actual money from a company with actual funding was a better idea
22:18:08 <othiym23> mbernstein: I think he chose wisely
22:18:09 <copumpkin> type Request_String = Request String
22:18:10 <identity_> copumpkin: Aye, it is. I think I remember it bugging out for me as well, but I don't remember why exactly
22:18:10 <copumpkin> wtf is that
22:18:18 <identity_> copumpkin: I know..
22:18:28 <ion> :-D
22:18:28 <copumpkin> AND
22:18:29 <identity_> An underscore in my beautiful haskell?
22:18:31 <identity_> Die, blasphemous whore
22:18:33 <copumpkin> pervasive strings
22:18:35 <copumpkin> AND
22:18:38 <cmccann> copumpkin, that is the best type synonym I have ever seen
22:18:41 <ddarius> copumpkin: It saves parentheses.
22:18:42 <kmc_> haha
22:18:49 <copumpkin> worse
22:19:08 <copumpkin> the show instance actually outputs the serialized headers (but no body) in a request
22:19:25 <ddarius> Does it have a Read instance?
22:19:31 <copumpkin> no
22:19:47 <copumpkin> and the only way to output the whole request to a stream is to use show
22:19:54 <copumpkin> and then ask for the body
22:20:01 <copumpkin> and send that
22:20:08 <othiym23> that's very Rubylike
22:20:20 <cmccann> copumpkin, terrifying
22:20:21 <othiym23> which is probably a grievously insulting thing to say about a Haskell module
22:20:21 <kmc_> blah
22:20:28 <ddarius> othiym23: Indeed.
22:20:44 <kmc_> my favorite thing about the HTTP package is the version number
22:20:51 <identity_> Aye, network.http bugged out for me
22:21:01 <copumpkin> if I didn't hate dealing with http idiosyncrasies, I'd be tempted to rewrite it
22:21:04 * ddarius actually has very little idea what is or isn't "ruby-like," but has a feeling that he doesn't want to find out.
22:21:10 <copumpkin> I like the idea of the browser module
22:21:15 <copumpkin> but it didn't work very well for me last I tried it
22:21:18 <ddarius> copumpkin: Use a different library?
22:21:26 <identity_> Google redirects to locale specific urls etc. Google.com -> google.dk when in denmark. When I'd simpleHTTP on "www.google.dk" it would hang indefinitely
22:21:34 <identity_> Never solved it and sigbjorn never replied
22:21:42 <othiym23> ddarius: oh, it's great fun -- look up monkeypatching and method_missing if you don't know about them already
22:21:57 <sanjoyd> Also, the names.
22:22:01 <ddarius> othiym23: I know about them.
22:22:23 * othiym23 actually loves Ruby
22:22:28 <copumpkin> ddarius: well, I don't need a full http library :) I need http-like header parsing and generation, and wanted to avoid duplicating work (and only have platform-able dependencies) but I guess I'll pass on that
22:23:19 <edwardk> i just wish it was easy to extend to wotk with other string reps
22:23:23 <ddarius> copumpkin: I.e. HTTP works well enough for you?
22:24:35 <copumpkin> not in a way that wouldn't make me feel icky
22:24:52 <ddarius> copumpkin: Then use a different library.
22:24:59 <copumpkin> I'm looking for one :P
22:25:05 <ddarius> I don't understand your previous response.
22:25:20 <shachaf> IE HTTP is probably worse than whatever HTTP library you can find for Haskell.
22:25:39 <shachaf> copumpkin: If all you need is HTTP-like header parsing and generation, you can look at all the HTTP server libraries as well as the clients.
22:25:49 <ddarius> Indeed.
22:26:10 <copumpkin> shachaf: I need HTTP header stuff minus network code
22:26:24 <copumpkin> or with significantly more flexible network code than is usually needed
22:27:37 * copumpkin will look
22:38:06 <dibblego> can I have a MPTC with 3 type parameters where two depend (fundep) on the other?
22:38:12 <kmc_> yes
22:38:20 <dibblego> how is it notated?
22:38:30 <dibblego> a -> x, b -> x ?
22:39:08 <kmc_> that means that a determines x, and b also determines x
22:39:08 <sanjoyd> What is MPTC?
22:39:09 <kmc_> individually
22:39:19 <kmc_> "a b -> x" means that a and b together determine x
22:39:22 <kmc_> sanjoyd, multi-param type class
22:39:22 <dibblego> right, how do I notated both a and b determine x?
22:39:58 <sanjoyd> ... and fundep is "functional dependency" I suppose?
22:40:24 <Saizan> yep
22:41:06 <dibblego> (a, b) -> x was my guess
22:42:17 <kmc_> not "a -> b -> x"? ;)
22:42:27 <dibblego> ah got it, a b -> x
22:42:44 <djahandarie> dibblego, seems like you missed kmc's message then :p
22:42:54 <dibblego> oh I did too, thanks!
22:45:26 <ddarius> Note, not that this is -that- useful, the nullary case is also allowed.
22:52:36 <danharaj> :t callCC
22:52:37 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
23:03:19 <danharaj> @src callCC
23:03:20 <lambdabot> Source not found. I've seen penguins that can type better than that.
23:03:28 <danharaj> I've seen faces prettier than that.
23:03:58 <shachaf> @ty callCC
23:03:59 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
23:04:21 <shachaf> @djinn ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
23:04:21 <lambdabot> f a b = a (\ c _ -> b c) b
23:05:29 <shachaf> @src Cont callCC
23:05:29 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
23:06:42 <kosmikus> isn't djinn nice :)
23:06:48 <danharaj> It's dark magic.
23:12:04 <danharaj> @djinn ((a -> (b -> r) -> r) -> (a -> r) -> r)
23:12:05 <lambdabot> -- f cannot be realized.
23:15:05 <kmc> danharaj, have you seen the proof of the Law of the Excluded Middle using callCC?
23:15:11 <danharaj> Nope.
23:15:52 <kmc> do you know how the Curry-Howard Isomorphism works generally?
23:16:15 <danharaj> vaguely.
23:16:34 <danharaj> What type does Excluded Middle correspond to in Haskell?
23:16:40 <kmc> Either (Not a) a
23:16:45 <kmc> type Not a = a -> Void
23:16:58 <kmc> {-# LANGUAGE EmptyDataDecls #-} data Void
23:17:16 <danharaj> forall a. a, more like.
23:17:32 <kmc> or «newtype Void = Void Void»
23:17:41 <kmc> anyway, "or" = "Either"
23:17:52 <djahandarie> callCC directly refers to classical logic. So djinn won't be able to do it (since it is intuitionistic).
23:17:55 <kmc> because «Either A B» is either a proof of A, or a proof of B
23:18:07 <shachaf> callCC is just Peirce's law.
23:18:10 <kmc> and a (non-monadic) callCC operator has type ((a → b) → a) → a
23:18:15 <kmc> which is Peirce's law
23:18:45 <kmc> and Peirce's law as an axiom is enough to give you classical logic
23:19:13 <kmc> so, we must be able to prove (Either (Not t) t) from ((a → b) → a) → a
23:19:22 <kmc> using continuations
23:20:12 <danharaj> hmm
23:20:54 <kmc> lem = callCC $ \k → ...
23:21:59 <kmc> need to produce something of type (Either (Not t) t)
23:22:15 <kmc> we don't have any 't' at this point, so we have to take the Left branch, meaning a function of type «t → Void»
23:22:35 <kmc> lem = callCC $ \k → Left (\v → ...)
23:22:57 <kmc> in other words, asserting the proposition 't' is false
23:23:10 <kmc> but what do we do if someone calls us out on that claim, by providing 't' as evidence?
23:23:18 <kmc> we use the continuation to go back in time and make the opposite claim!
23:23:25 <kmc> lem = callCC $ \k → Left (\v → k (Right v))
23:23:33 <danharaj> gah
23:23:37 <danharaj> it's like thinking with portals
23:23:45 <shachaf> Huh, that is a neat way of thinking about it.
23:24:09 <djahandarie> There is actually a little story about a devil and time travel using callCC.
23:24:27 <danharaj> so you don't have non-monadic callCC in Haskell, right?
23:24:38 <kmc> right
23:24:38 <danharaj> I mean, like you can't capture the continuation of the entire program.
23:24:50 <shachaf> @djinn (forall a b. a -> b) -> (forall a b. a -> b)
23:24:50 <lambdabot> f a = a
23:24:52 <shachaf> @djinn (forall a b. a -> b) -> (forall p q. p -> q)
23:24:53 <lambdabot> -- f cannot be realized.
23:25:08 <djahandarie> In terms of game theory you can think of it in terms of replaying a game and using the knowledge from the previous iteration.
23:25:09 <kmc> > let ccc :: ((a -> b) -> a) -> a; ccc = undefined in ccc $ \k -> Left (\v -> k (Right v))
23:25:11 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> b1)
23:25:11 <lambdabot>    arising from a use of ...
23:25:15 <kmc> :t let ccc :: ((a -> b) -> a) -> a; ccc = undefined in ccc $ \k -> Left (\v -> k (Right v))
23:25:16 <lambdabot> forall b b1. Either (b1 -> b) b1
23:25:53 <sanjoyd> [Noob question]: How is a liftM different from fmap?
23:25:57 <kmc> :t callCC $ \k -> return $ Left (\v -> k (Right v))
23:25:58 <lambdabot> forall b (m :: * -> *) b1. (MonadCont m) => m (Either (b1 -> m b) b1)
23:26:03 <sanjoyd> (Other than that I can fmap a Functor).
23:26:08 <kmc> sanjoyd, it's not
23:26:09 <djahandarie> sanjoyd, that's it.
23:26:09 <shachaf> sanjoyd: Different type class, same behavior.
23:26:19 <shachaf> Unless something is messed up.
23:26:20 <sanjoyd> kmc: djahandarie shachaf thanks! :)
23:26:26 <sanjoyd> shachaf: example?
23:26:29 <kmc> in the distant future Monad will be a subclass of Functor, and liftM will be an alias for fmap
23:26:33 <danharaj> any example is buggy code
23:26:34 <kmc> (as liftA is an alias for fmap)
23:26:39 <shachaf> instance Functor Foo where fmap = undefined
23:26:43 <kmc> right now it's messier for historical reasons
23:26:55 <danharaj> Bah! History never helped anyone.
23:28:05 <sanjoyd> kmc: because Monads existed before Functors?
23:28:21 <kmc> something like that
23:28:25 <sanjoyd> Okay.
23:28:46 <shachaf> Does the law of excluded middle make sense as a primitive for Cont?
23:28:48 * kmc thinks we should also rename fmap back to map
23:28:54 <shachaf> Or any others of the equivalents to it?
23:29:59 <kmc> i'm not sure.  the problem is that continuations are an 'effect', so the types don't tell you everything
23:30:45 <kmc> your blue portal might have type (T → ⊥) but that doesn't tell you anything about where the orange portal is
23:31:14 * djahandarie still doesn't understand how monads inside a language represent effects, as opposed to monads in the semantic model, which fairly clearly do represent effects.
23:31:54 <danharaj> if you can define it as a monad, you can embed it in the pure semantics, no?
23:32:46 <djahandarie> Why?
23:33:13 <danharaj> because you defined it within the language?
23:33:25 <sanjoyd> If bind and return are pure functions, shouldn't you be able to?
23:33:48 <djahandarie> danharaj, that sounded tautological to me.
23:33:49 <sanjoyd> I mean, isn't a Monad a set of a cleverly written typeclass and two higher order functions?
23:34:14 <danharaj> djahandarie: it should :p
23:34:23 <danharaj> @djinn ((a -> b) -> (a -> ((b -> r) -> r)))
23:34:23 <lambdabot> f a b c = c (a b)
23:34:46 <sanjoyd> What does djinn do?
23:34:50 <djahandarie> danharaj, I don't think the answer to my question is clear.
23:35:01 <danharaj> @djinn ((a -> (b -> r) -> r) -> a -> b)
23:35:01 <lambdabot> -- f cannot be realized.
23:35:20 <danharaj> djinn tries to find a function that satisfies the type you give it.
23:35:26 <sanjoyd> Oh, nice!
23:35:30 <danharaj> Yeah it's cool.
23:35:32 * sanjoyd tries.
23:35:37 <sanjoyd> @djinn a->a
23:35:38 <lambdabot> f a = a
23:35:45 <sanjoyd> @djinn [a]->a
23:35:46 <danharaj> congrats, you derived id.
23:35:46 <lambdabot> Error: Undefined type []
23:35:56 <danharaj> oh it might not know what lists are.
23:36:04 <djahandarie> No, it just doesn't support recursive types.
23:36:09 <sanjoyd> @djinn a->b->(a, b)
23:36:09 <lambdabot> f a b = (a, b)
23:36:18 <sanjoyd> This is really cool!
23:36:28 <djahandarie> It's typeclass support is also shoddy/non-existent.
23:36:36 <danharaj> :t foldr
23:36:37 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
23:37:00 <danharaj> @djinn ((a -> b -> b) -> b -> b) -> a
23:37:00 <lambdabot> -- f cannot be realized.
23:37:20 <ion> @. pl djinn a->b->(a,b)
23:37:20 <lambdabot> f = (,)
23:37:28 <sanjoyd> @djinn (a -> b -> b) -> b -> b -> a
23:37:29 <lambdabot> -- f cannot be realized.
23:37:37 <sanjoyd> This is weird.
23:37:52 <djahandarie> What?
23:38:00 <kmc> @djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
23:38:00 <lambdabot> f a b c = a (\ d -> b d c)
23:38:15 <kmc> it just derived (>>=) for the (Cont r) monad
23:38:28 <danharaj> I am putting a quantifier in the wrong place
23:38:51 <danharaj> @djinn (forall b. (a -> b -> b) -> b -> b) -> a
23:38:51 <lambdabot> -- f cannot be realized.
23:38:56 <sanjoyd> Yeah, especially since, at least for me, 25% of the work is getting the type signature and a function that satisfies the signature.
23:39:14 <shachaf> sanjoyd: Isn't that typically 100% of the work?
23:39:20 <kmc> @. djinn nixon
23:39:20 <lambdabot> Error: Undefined type Politics
23:39:28 <kmc> @. djinn nixon
23:39:29 <lambdabot> Error: Undefined type Scrubbing
23:39:47 <sanjoyd> shachaf: I
23:39:50 <sanjoyd> 'm still learning. :)
23:39:59 <sanjoyd> :t nixon
23:40:01 <lambdabot> Not in scope: `nixon'
23:40:32 <kmc> @. elite nixon
23:40:32 <lambdabot> 9O\/ERN/\/\3N7 enTERpriSe i5 th3 mOzt iNEfFI(I3N7 ANd CoStLy WaY Oph PR0DuCINg jobz.
23:40:33 <othiym23> I get the feeling that the source for lambdabot is a twisty set of passageways, all alike
23:40:39 <ion> @. pl djinn (a->b->c)->(a->b)->a->c
23:40:39 <lambdabot> f = ap
23:40:44 <ion> @djinn (a->b->c)->(a->b)->a->c
23:40:44 <lambdabot> f a b c = a c (b c)
23:40:48 <kmc> @. pl djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
23:40:48 <lambdabot> f = (. flip) . (.)
23:41:03 <ion> @. elite run cake
23:41:05 <lambdabot> ["0N3 18.25 0UNCe pAcKA9E ChocO|aTe c4kE MiX.","onE cAN PRepAREd (OcONuT PE...
23:41:18 <shachaf> .pldjinn++
23:41:25 <shachaf> Best command in lambdabot.
23:41:29 <kmc> oh i discovered lambdabot can do textual metaprogramming via @.
23:41:55 <ion> @. run run text "1+2"
23:41:56 <lambdabot>   3
23:42:01 <kmc> yep
23:42:21 <kmc> and @. run . run run
23:42:21 <kmc> etc
23:42:41 <shachaf> @@ @run @run @run text "text \"5\""
23:42:42 <lambdabot>   5
23:42:48 <kmc> @. run . run . run run 1
23:42:51 <lambdabot>   1
23:42:53 <kmc> how does @@ work?
23:42:56 <shachaf> @help @3
23:42:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:42:57 <danharaj> so how do I represent Lists by their folds and get djinn to derive head?
23:42:58 <shachaf> @help @
23:42:58 <lambdabot>  @ [args].
23:42:58 <lambdabot>  @ executes plugin invocations in its arguments, parentheses can be used.
23:42:58 <lambdabot>  The commands are right associative.
23:42:58 <lambdabot>  For example:    @ @pl @undo code
23:42:58 <lambdabot>  is the same as: @ (@pl (@undo code))
23:43:07 <kmc> ooh
23:44:18 <shachaf> @@ @run (@run text "(+)") (@run 1) (@run 2)
23:44:21 <lambdabot>   3
23:45:09 <sully> @help
23:45:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:45:13 <sully> @list
23:45:13 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
23:45:24 <ion> @@ @elite @help
23:45:24 <lambdabot>  HELP <cOm/\/\aNd>. 4SK for h3Lp 4 <c0mM4nD>. TRY 'LI$7' phoR A11 C0MmAnDz
23:45:48 <kmc> @. elite . elite nixon
23:45:49 <lambdabot> $UrE tHeRe 4RE di$Hon3z+ /\/\3N IN lo(4| G0V3RN/\/\eN7. 8U+ T|-|3Re ar3 DI5|-|oN3$+ mEN iN n4+ionA| 9O\/3RN/\/\eNT +00.
23:46:01 <kmc> @@ @elite @elite @elite @elite @elite @nixon
23:46:02 <lambdabot>  YoU |-|4\/E +0 ph4(3 7|-|3 P|-|4(+ 7|-|47 \/\/Ho13 Pr0813/\/\ iz r341|y 7|-|3 B14Xx5. +|-|3 X3y i$ 70 dI\/I53 4 $y5+3/\/\ +|-|4t Re(0NI53$ 7|-|i5 \/\/|-|I|e n07 4pP3aRiN9 +0...
23:46:06 <sanjoyd> If you squint hard enough ...
23:46:38 <ion> @@ @elite @elite @elite @elite @elite @djinn ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
23:46:38 <lambdabot>  P|-| 4 8 = 4 (\ ( _ -> 8 () 8
23:47:02 <ion> I love P|-|
23:47:08 <shachaf> @@ @(@run text "run") 5
23:47:08 <lambdabot> Plugin `compose' failed with: Unknown command: "@run"
23:47:09 <shachaf> Aw.
