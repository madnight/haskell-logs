00:15:06 <Mgccl> Are there ways to call a function by it's name (but stored as a string?)
00:15:27 <Mgccl> so say some function is f, then I want a function g, such that g "f" = f
00:15:28 <mauke> no
00:15:40 <shachaf> That would be evil.
00:16:06 <shachaf> @@ @run (@run text "(+)") 1 1
00:16:07 <lambdabot>   2
00:16:14 <shachaf> (As was just mentioned above.)
00:17:14 <Mgccl> cool! thanks
00:21:32 <Axman6> Mgccl: that only works in lambdabot
00:22:10 <osfameron> why
00:22:11 <Axman6> Mgccl: being able to do that is extremely unsafe (both in terms of type safety and security). it is not a feature any developer should be looking for in a language imo
00:22:54 <osfameron> Axman6: except for lambdabot, and other language experimentation tasks
00:23:03 <Axman6> sure
00:23:21 <Axman6> but lambdabot's creaters have gone a very long way to make sure doing so is safe
00:23:35 <shachaf> osfameron: lambdabot isn't Haskell. What it's doing is the equivalent of running your program, printing into a file, running GHC on the file, and then running the result.
00:23:49 <shachaf> Oh, you meant what lambdabot does in general.
00:24:02 * osfameron remembers desperately wanting eval/symbolic references etc, as a beginner programmer
00:24:26 <osfameron> they *are* useful, but very occasionally
00:24:51 <Mgccl> The reason I asked was because I'm parsing some file, which contain some strings, such that each string correspond to some function I wrote in Haskell.
00:25:02 <osfameron> i'm glad i had the need to use them by default beaten out of me ;-)
00:25:52 <osfameron> Mgccl: and why do you need to get at the actual *function* ?
00:28:59 <osfameron> Mgccl: eg, what are the functions for?
00:29:30 <Mgccl> I'm writing a latex to html converter, it be a pain to modify the source to add a line like ("\command", command) every time I add a new command
00:31:27 <osfameron> really?
00:31:53 <osfameron> you have to add the command, then just update the lookup table
00:32:23 <osfameron> much safer than allowing access to arbitrary functions
00:32:24 <Mgccl> -____- that's true...
00:33:07 <luite> well you could use hint or something similar to run those functions from specific "plugin" modules
00:33:17 <luite> that could actually be good for extensibility
00:33:48 <osfameron> what's hint?
00:34:06 <luite> it's what mueval uses (which in turn is used by lambdabot)
00:34:16 <luite> a higher level wrapper around the ghc api
00:34:47 <osfameron> ah
00:35:32 <luite> you don't run functions from the current haskell program with that, but you import some modules with hint, and then run a function within that context
00:53:59 <ddarius> You can also just use a lambda so that the addition to the lookup table and the function definition are in the same place.
00:54:29 * ddarius does not recall ever feeling a strong desire for eval.
01:06:30 <luite> ddarius: but then you'd still need to recompile the program if you want to add a conversion function for a specific command. I think that it would be useful to let the user add a file with "local" conversion functions that can be easily edited
02:07:19 <user17> hey, i'm doing (read: learning) some haskell (babysteps :P), but i already fail to understand how a variable is bound correctly; if i do 'num <- 32' i get a type error saying that 'num' needs a signature... but several tutorials state that haskell is well able to 'guess' fundamental types :/
02:07:25 <user17> what am i doing wrong :(
02:08:57 <Jafet> To bind a variable, you do “num = 32”.
02:09:37 <user17> parse error :|
02:09:40 <shachaf> user17: <- is used for executing an action and binding the result; you just want =.
02:09:54 <shachaf> You might need let num = 32, or let num = 32 in ..., depending on the context.
02:11:07 <user17> ohh
02:12:32 <fasta> How can I convert a Word8 representing a number in ASCII into a Word8 which is just a number directly using a library function?
02:13:00 <shachaf> Representing a digit?
02:13:07 <user17> what would the 'in' stand for? (being a little puzzled as i have seen the 'in' keyword in likely entirely unrelated situations in languages like lua, csharp, javascript, you name it :P)
02:13:08 <fasta> shachaf: yes
02:13:31 <fasta> user17: it comes from mathematical texts.
02:13:43 <othiym23> let ... in ... just means "let <these bindings apply> in <this expression>"
02:13:54 <shachaf> fasta: x - fromIntegral (ord '0') or something like that?
02:13:56 <fasta> user17: The Haskell School of expression explains this. Which book are you using?
02:14:16 <user17> fasta: learn you a haskell, and a few other online books
02:14:17 <fasta> shachaf: I had something better myself already. Never mind.
02:14:51 <shachaf> fasta: It's unlikely that there's a library function for it -- it's a bit of an odd operation in general.
02:14:57 <shachaf> What better thing do you have?
02:15:26 <fasta> shachaf: hmm, it is basically equivalent. I basically evaluated ord '0' by hand.
02:15:50 <shachaf> OK, sure. The compiler would probably do that for you anyway.
02:18:34 <fasta> shachaf: yes, but stuff like this should be in a library, imho.
02:18:42 <fasta> shachaf: it is trivial, but every program repeats it.
02:23:31 <JuanDaugherty> I take it 7.0.4 is no regression on 7.0.3
02:23:45 <JuanDaugherty> *?
02:24:05 <shachaf> JuanDaugherty: Is that a trick question?
02:24:12 <JuanDaugherty> (by the release notes)
02:24:21 <JuanDaugherty> shachaf, no it
02:24:24 <JuanDaugherty> s not
02:25:49 <JuanDaugherty> rather a request if anyone has upgraded to 7.0.4 and used experiencing any or not
03:42:39 <fasta> What is the meaning of f z@(Blah x) = writeArray x 1 0 >> foo z ?
03:43:13 <sipa> what in particular?
03:43:22 <fasta> I was under the impression that the array is updated before it is given to foo.
03:43:32 <fasta> It seems that my GHC does that wrong.
03:43:45 <fasta> If I add in an extra side-effect, it does work.
03:43:59 <fasta> E.g. putStrLn.
03:44:01 <ion> @hoogle writeArray
03:44:01 <lambdabot> Data.Array.MArray writeArray :: (MArray a e m, Ix i) => a i e -> i -> e -> m ()
03:45:15 <fasta> Commenting out a putStrLn in one place of my program changes the behaviour of another function.
03:45:30 <fasta> Long live functional programming. I don't think I have ever seen gcc do that before.
03:45:52 <fasta> I obviously don't use any unsafe operations.
03:45:59 <identity_> Good thing you aren't jumping to conclusions or anything
03:46:21 <fasta> identity_: I don't. I make an observation.
03:47:44 <fasta> identity_: good thing you didn't add any information to the channel, spammer.
03:47:44 <identity_> The above seems like you are frustrated and thus making a comparison between ghc and gcc(or Haskell and C), implying that Haskell is being stupid. If you are new to Haskell, it is fair to assume that you made an error, assuming that the library you are using has been used by enough people that it is unlikely to contain a fatal bug in a fundamental function
03:47:55 <identity_> I guess you are indeed frustrated
03:48:09 <fasta> identity_: I wrote more Haskell than most people.
03:48:16 <fasta> identity_: including you.
03:48:26 <identity_> That may very well be, thus the "If"
03:48:26 <fasta> identity_: do you have something else to add?
03:48:53 <identity_> But you don't know how much Haskell I've written, but it is not a lot on any scale, so I'll give you that one
03:49:07 <fasta> identity_: how many compiler bugs did you find in GHC?
03:49:25 <fasta> identity_: I have reasons to believe GHC is not heavingly great.
03:49:25 <identity_> Excuse me?
03:49:40 <othiym23> this conversation went sideways amazingly fast
03:49:43 <ion> fasta’s attitde goes up to eleven.
03:49:43 <fasta> identity_: I take that as zero.
03:49:46 <ion> attitude
03:50:11 <fasta> identity_: so, please, don't assume the next person you talk to doesn't know anything. Thank you.
03:50:12 <identity_> fasta: Did I ever imply that I had?
03:50:27 <identity_> fasta: No one was assuming anything but you, my angry friend.
03:50:36 <identity_> At any rate, why don't you paste some of your code and we can all take a look
03:50:45 <identity_> All the animals in this forest, as friends
03:50:48 <geheimdienst> fasta, could it be a timing issue? suppose one thread gets there faster due to not putStrLn'ing, therefore another thread changes behavior
03:50:52 <fasta> identity_: ok, if you like to fuck young children and rape lesbians, I don't think you are very nice.
03:50:53 <geheimdienst> or something like that?
03:51:08 <fasta> identity_: oh, hey, if it doesn't apply to you, I wasn't assuming anything.
03:51:15 <ion> Let’s stop feeding the troll.
03:51:16 <fasta> identity_: do you see how stupid that looks?
03:51:19 <identity_> ion: Aye
03:51:50 <fasta> geheimdienst: one reason is that the optimizer doesn't see writeArray as a side-effect.
03:51:59 <identity_> I'm going to leave the stage with a bang, though.
03:52:00 <identity_> 13:19 < fasta> identity_: I wrote more Haskell than most people.
03:52:00 <identity_> 13:19 < fasta> identity_: including you.
03:52:09 <identity_> 13:13 < fasta> What is the meaning of f z@(Blah x) = writeArray x 1 0 >> foo z ?
03:52:12 <identity_> 13:14 < sipa> what in particular?
03:52:15 <identity_> 13:14 < fasta> I was under the impression that the array is updated before it is given to foo.
03:52:26 <fasta> identity_: those are the correct semantics.
03:52:34 <identity_> ^ given to foo + >> + "I wrote more haskell than most"
03:52:57 <identity_> fasta: See the definition for (>>) and how in particular it does not 'give anything' to anything.
03:53:00 * identity_ bows
03:53:04 <identity_> I hope you solve your problem
03:53:17 <fasta> identity_: you really have no clue, have you?
03:53:38 <othiym23> :t (>>)
03:53:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
03:54:17 <othiym23> :t (>>=)
03:54:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
03:54:22 <JuanDaugherty> kids kids, behave
03:55:17 <fasta> geheimdienst: I am not even using threads, btw.
03:55:39 <othiym23> @src (>>)
03:55:39 <lambdabot> m >> k      = m >>= \_ -> k
03:55:49 <identity_> ^
03:55:53 <identity_> brb
03:56:25 <fasta> Haskell has gotten too popular. It feels like #java in here.
03:57:46 <trygvis> I know. people pop in on the channel shaking their fists at the compiler and stuff .. annoying
03:57:58 <JuanDaugherty> has been here for more than 5 years, seems about the same to me
03:58:09 <identity_> trygvis: touché
03:58:16 <identity_> JuanDaugherty: Wish I had been here that long
03:58:25 <JuanDaugherty> why?
03:58:44 <identity_> JuanDaugherty: Because it's the most awesome, close knit programming language community with the most helpful members I've ever been a part of
03:58:57 <JuanDaugherty> you're a child aren't you?
03:59:14 <identity_> What?
03:59:47 <trygvis> #haskell is by far the best (as in constructive) channel I've been in
03:59:55 <identity_> JuanDaugherty: I'm more than old enough to have been here 5 years ago
04:00:16 <fasta> JuanDaugherty: who cares about those 5 years? Would I be more awesome if I had been here longer?
04:00:50 <identity_> trygvis: That is exactly what I meant
04:00:54 <JuanDaugherty> fasta, did I say you would?
04:01:14 <fasta> JuanDaugherty: no, but you appeared to imply something with dropping your five years.
04:01:16 * JuanDaugherty doesn't use "awesome" anyway, I'm 57.
04:01:37 <fasta> JuanDaugherty: or do you always happen to drop random sentences in a channel without intending to make a point?
04:01:43 <trygvis> JuanDaugherty: you should. it's awesome! ;)
04:01:50 <identity_> ^
04:03:21 <othiym23> OK, so now *I'm* curious
04:04:05 <identity_> othiym23: About?
04:04:13 <trygvis> fasta: where you interested in solving your issue or did you just want to vent? I'd like to look at the code
04:04:30 <identity_> I invited him to paste the code too
04:04:42 <JuanDaugherty> fasta, I'm generally making a point. I'm not an academic, just an ordinary working class person. The point was that in the 5-6 years I've visited this channel didn't notice that much diff
04:05:00 <othiym23> if you've got a pattern capture like z@(Blah x), and you do two operations in sequence that refer to x and z independently, how could altering one affect the other in a pure language?
04:05:21 <identity_> othiym23: I's using a mutable array, it seems
04:05:24 <trygvis> identity_: I know, I'm hoping you'll solve the problem too. I'm probably too new to help much :)
04:05:49 <identity_> trygvis: Hah. I consider myself a lowly grasshopper in this den of zen masters
04:06:04 <fasta> There is no point. I will just solve it myself or write it in another way and hope the problem goes away. Thanks for your time, anyway.
04:06:05 <jmcarthur> othiym23: altering what?
04:06:26 <othiym23> jmcarthur: see fasta's code
04:06:37 <jmcarthur> othiym23: i think i came in too late for that
04:06:46 <trygvis> fasta: ok. then you're ending up as the spammer with nothing to bring to the channel
04:06:58 <othiym23> jmcarthur: f z@(Blah x) = writeArray x 1 0 >> foo z
04:07:10 <fasta> trygvis: so be it.
04:07:31 <jmcarthur> ah yeah that looks like a mutable array, so side effects are going to matter here
04:07:45 <jmcarthur> s/side //
04:07:46 <trygvis> too bad, I could have learned something from it
04:07:56 <othiym23> so z can be mutated through updates to x?
04:08:00 <othiym23> isn't that impure?
04:08:33 <fasta> othiym23: z has a _reference_ to x.
04:08:50 <fasta> othiym23: the reference is constant, and does not change.
04:09:03 <fasta> othiym23: it just happens that the data it is pointing at changes.
04:09:17 <kosmikus> do you have a complete minimal example for the "bad beahviour"?
04:09:29 <othiym23> fasta: yes, but that mutation is an impure operation, is it not?
04:09:44 <fasta> othiym23: notions of pure/impure are rather without meaning.
04:09:54 <identity_> :t writeArray
04:09:55 <lambdabot> Not in scope: `writeArray'
04:10:01 <identity_> @hoogle writeArray
04:10:01 <lambdabot> Data.Array.MArray writeArray :: (MArray a e m, Ix i) => a i e -> i -> e -> m ()
04:10:22 <fasta> othiym23: if you have mathematically modelled a mess, does it suddenly become pure?
04:11:21 <jmcarthur> othiym23: x is mutated. you can observe that mutation if you have z
04:11:32 <fasta> Algorithms that work without any kind of array indexing are generally called 'pure'. For the rest you can argue forever.
04:11:53 <othiym23> jmcarthur: ah, thanks
04:12:03 <othiym23> I'm not used to looking through bindings to references in Haskell
04:12:53 <hpaste> kosmikus pasted “writeArray” at http://hpaste.org/48340
04:13:07 <othiym23> I mean, outside of places where they're explicitly modeled as ST
04:13:10 <kosmikus> fasta: the paste behaves exactly as expected. I need more context ...
04:13:51 <fasta> kosmikus: I think you missed the part where I stopped asking for help on this problem.
04:14:29 <kosmikus> fasta: because it's more fun to you to offend everyone in the channel than to actually get your problem solved? ok then, fine with me ...
04:16:27 <fasta> kosmikus: no, because I already worked around it.
04:16:51 <jmcarthur> othiym23: presumably this is taking place in IO or ST or something
04:17:10 <kosmikus> fasta: also fine
04:17:57 <othiym23> jmcarthur: I guess I hadn't thought about pattern capture in this context, and sorta assumed on some level that something like a closure applied
04:18:04 <othiym23> which doesn't make sense now that I think about it
04:19:51 <jmcarthur> othiym23: to be precise, neither x's identity nor z actually change. the only thing that changes is what x is referring to, which you can only observe in IO (or ST or whatever we're in)
04:20:11 <jmcarthur> othiym23: pattern matching is always going to give you pure values, is what i'm getting at
04:20:19 <othiym23> jmcarthur: I follow you, I'm just a little tired
04:20:22 <othiym23> it's late where I am
04:20:24 <jmcarthur> alright :)
04:32:18 <dibblego> is there a library for creating lenses?
04:35:09 <othiym23> http://hackage.haskell.org/package/pointless-lenses / http://hackage.haskell.org/package/lenses ?
04:35:22 <dibblego> yeah just found out there are a zillion
04:35:44 <byorgey> dibblego: also fclabels, data-accessor
04:35:51 <dibblego> thanks
05:03:05 <_2easy> how can i determine the station id for weather plugin for xmobar?
05:06:13 <yoki> hi, does anybody know how to use gtk2hs : graphics.ui.gtk.printing + cairo + pango to do some textprinting
05:06:28 <yoki> my code is following http://pastebin.com/E3Ptq0fh, prints an empty page only :/
05:06:31 <mauke> The paste E3Ptq0fh has been copied to http://hpaste.org/48346
05:07:09 <JuanDaugherty> _2easy, are you in #xmonad?
05:07:40 <JuanDaugherty> (they might be able to make sense of your query)
05:07:59 <maloi> _2easy: http://www.rap.ucar.edu/weather/surface/stations.txt
05:09:49 <jaj> _2easy: it's the ITOA id
05:10:15 <jaj> _2easy: ehm ICAO
05:10:37 <jaj> _2easy: easiest is to query wikipedia, e.g.: http://en.wikipedia.org/wiki/JFK_airport ICAO: KJFK
05:12:44 * Eduard_Munteanu guessing... setting up some weather applet?
05:13:20 <jaj> Eduard_Munteanu: xmobar has a weather "applet"
05:17:08 <Eduard_Munteanu> Ah.
05:17:51 <Eduard_Munteanu> Regarding that I wonder if local weather stations have ICAO codes.
05:18:25 <jaj> Eduard_Munteanu: I used the nearest airport
05:19:17 <Eduard_Munteanu> jaj: well, here there's an airport station, but there's a closer one that's not tied to a particular airport, it's inside the city, AFAIK.
05:20:40 <jaj> Eduard_Munteanu: the weather plugin is fetching http://weather.noaa.gov/pub/data/observations/metar/decoded/${ICAO}.TXT
05:20:55 <jaj> so you can easily test if your station is available
05:21:51 <jaj> runInteractiveCommand ("curl " ++ defUrl ++ url ++ ".TXT")
05:22:09 <jaj> that could use some polish to use a haskell lib rather than the external curl command
05:22:40 <Eduard_Munteanu> Hrm... I don't think it has an ICAO code assigned.
05:22:53 <Eduard_Munteanu> It's just for local weather reporting purposes I think.
05:24:57 <jaj> Eduard_Munteanu: then the airport is your friend ;)
05:35:45 <develhevel> when i have a "Just "abc"" how to get the "abc" out from the Just?
05:37:47 <Yrogirg> with pattern matching?
05:38:16 <Yrogirg> getabc | Just x = x
05:38:16 <Yrogirg>              | Noting = error "error"
05:38:31 <develhevel> thx
05:40:27 <yoki> develhevel: also fromJust (Just "abc") or fromMaybe "" (Just "abc") may help
05:42:04 <Eduard_Munteanu> > fromJust Nothing     -- mind partiality
05:42:06 <lambdabot>   *Exception: Maybe.fromJust: Nothing
05:44:40 <hpc> which monoid instance does Maybe have?
05:44:49 <hpc> mempty = Nothing or mempty = Just mempty?
05:45:07 <hpc> > mempty :: Maybe String
05:45:08 <lambdabot>   Nothing
05:45:14 <hpc> nvm :P
05:46:58 <Tomsik> mempty =Just mempty? What?
05:47:08 <Tomsik> That doesn't sound like a ... sound monoid.
05:47:28 <hpc> the monoid laws still hold
05:48:01 <hpc> just, Nothing isn't mempty
05:48:22 <Tomsik> mempty `mappend Nothing would be what then?
05:48:27 <Tomsik> Nothing, yes?
05:48:27 <hpc> Nothing
05:48:34 <hpc> as the laws require
05:48:36 <Eduard_Munteanu> NaN :P
05:48:46 <Tomsik> Would the standard mappend be the right one?
05:49:00 <hpc> the instance would be
05:49:12 <hpc> instance Monoid x => Monoid (Just x) where
05:49:18 <hpc> mempty = Just mempty
05:49:40 <hpc> um, yeah it would be exactly the same mappend definition
05:49:54 <Eduard_Munteanu> (s/Just x/Maybe x/)
05:49:55 <hpc> er no
05:50:09 <hpc> mappend = liftA2 mappend
05:50:12 <hpc> or something like that
05:54:21 * Eduard_Munteanu wonders if one should be allowed to write stuff like    x :: Just 'a'
05:55:16 <Eduard_Munteanu> Obviously 'x' can only be something undefined.
05:55:46 <hpc> i think it would be neat to have a more prominent text type for string
05:55:59 <hpc> then x :: "Char"
05:56:07 <hpc> a "text of characters"
05:56:19 <hpc> x :: "Int" = a text of Ints
05:56:57 <hpc> wait, you couldn't nest those...
05:57:29 <Eduard_Munteanu> You kinda can define that in Agda, but it'd look sucky like    " Char "
05:57:54 <Eduard_Munteanu> (erm, you do have to use something else than '"' I think)
05:59:18 <Eduard_Munteanu> "_" : Set -> Set; " a " = List a            -- using something from Unicode
05:59:39 <hpc> ooh cool
06:00:35 <hpc> it still doesn't seem like you could nest them, but i suspect agda is typed strongly enough that figuring it out is easy
06:01:47 <Eduard_Munteanu> You can but not really nicely... say " (" Char  ") "
06:02:30 <Eduard_Munteanu> Just like with other mixfix operators.
06:02:34 <hpc> eesh
06:02:46 <Tomsik> hpc: a question is how long it'll compile :p
07:09:04 <develhevel> want to make "abc" the first letter Upper so i write: (toUpper $ head "abc") ++ (tail "abc") but this gives an error: Couldn't match expected type `[a0]' with actual type `Char'. how to fix it?
07:09:25 <yitz> develhevel: s/++/:/
07:10:06 <develhevel> yitz: dont understand
07:10:13 <yitz> change the ++ to :
07:10:35 <develhevel> thx
07:10:48 <Botje> develhevel: head "abc" :: Char
07:10:59 <Botje> since "abc" :: [Char] and head :: [a] -> a
07:11:04 <Botje> and ++ wants two [Char]
07:13:03 <develhevel> i understand it, thx
07:19:04 <Baughn> @hoogle fixM
07:19:04 <lambdabot> No results found
07:19:22 <Baughn> @hoogle (a -> m a -> m a
07:19:22 <lambdabot> Parse error:
07:19:22 <lambdabot>   --count=20 "(a -> m a -> m a"
07:19:22 <lambdabot>                              ^
07:19:24 <Baughn> @hoogle a -> m a -> m a
07:19:24 <lambdabot> Data.Graph.Inductive.Internal.Queue queuePut :: a -> Queue a -> Queue a
07:19:25 <lambdabot> Text.ParserCombinators.ReadP option :: a -> ReadP a -> ReadP a
07:19:25 <lambdabot> Data.Sequence (<|) :: a -> Seq a -> Seq a
07:20:15 <azaq23> @type mfix
07:20:16 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
07:20:18 <Baughn> @hoogle (a -> m a) -> m a
07:20:19 <lambdabot> Control.Monad.Fix mfix :: MonadFix m => (a -> m a) -> m a
07:20:19 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
07:20:19 <lambdabot> Control.Monad.Cont runContT :: ContT r m a -> (a -> m r) -> m r
07:20:24 <Baughn> ..right.
07:20:59 <azaq23> :)
07:21:30 <Baughn> Though that doesn't actually work. Hm.
07:21:38 <Baughn> ..I should probably not need to use fix when I just want the return /type/
07:21:39 <benmachine> hm?
07:22:58 <Baughn> ..silly me. I already turned on scoped type variables. :P
07:25:40 <dylukes> :\
07:26:11 <dylukes> I never really resolved what the best parsing library to use for network connections is
07:26:33 <dylukes> I tried using parsec with iteratees, but I never quite got it working...
07:27:14 <Baughn> Parsing library?
07:27:25 <Baughn> For a sane protocol, Cereal should do nicely..
07:27:44 <dylukes> "for a sane protocol"
07:27:50 <dylukes> I haven't seen a sane network protocol in years, if ever.
07:28:02 <benmachine> tried attoparsec?
07:28:14 <droud> dylukes: UDP is pretty sane.
07:28:18 <dylukes> er, I should say specifically, for a *stream* protocol
07:28:29 <dylukes> pretty run of the mill stuff
07:28:30 <droud> dylukes: I agree with you on stream protocols.
07:28:38 <dylukes> it's being used by a project I'm commissioned n
07:28:44 <dylukes> header, payload of variable length
07:28:52 <droud> dylukes: Should see the last protocol I whipped up, signed every packet.
07:28:58 <dylukes> heh
07:29:14 <develhevel> can map me provide a iterator or something? i have e.g. a list ["a", "bb"] and want to map in it, but i need the count in which it is. in a it would be 1 and in bb 2
07:29:15 <dylukes> I think the best policy with stream protocols is to run it through COBS or something comparable :P
07:29:23 <dylukes> makes it leagues easier to parse later.
07:29:29 * hackagebot nonlinear-optimization 0.3.4 - Various iterative algorithms for optimization of nonlinear functions.  http://hackage.haskell.org/package/nonlinear-optimization-0.3.4 (FelipeLessa)
07:29:34 <dylukes> Use null bytes to mark packet boundaries ^^
07:29:46 <Botje> develhevel: the usual approach is to zip your list with [1..]
07:30:08 <droud> dylukes: Null bytes are bad news, need real framing.
07:30:17 <dylukes> droud: ...?
07:30:36 <droud> dylukes: Check out SSP sometime for super simple protocol.
07:30:44 <dylukes> What's wrong with COBS/Null boundaries?
07:30:46 <droud> (simple serial protocol in fact)
07:31:42 <dylukes> http://www.stuartcheshire.org/papers/COBSforToN.pdf
07:31:55 <dylukes> it's quite the elegant solution :)
07:32:32 <dylukes> "COBS has the property that the byte value zero is never used as a code byte, nor does it ever appear in the data section of any code block. This means that COBS takes an input consisting of characters in the range [0,0xFF] and produces an output consisting of characters only in the range [1,0xFF]. Having eliminated all zero bytes from the data, a zero byte can now be used unambiguously to mark boundaries between packets."
07:32:34 <dylukes> tl;dr version
07:33:05 <develhevel> Botje: zip [1..] ["a","bb"] dont work
07:33:25 <hpc> > zip [1..] ["a","bb"]
07:33:25 <lambdabot>   [(1,"a"),(2,"bb")]
07:34:37 <develhevel> i'm so stupid
07:34:47 <hpc> ;)
07:34:54 <Baughn> dylukes: What's the efficiency of COBS for input consisting of many zeros?
07:36:01 <hpc> ♪ You need an index for your list♪
07:36:02 <dylukes> In terms of CPU or memory?
07:36:06 <hpc> ♪ You should zip it ♪
07:36:10 <Baughn> dylukes: Space
07:36:14 <dylukes> Baughn: It's all documented in that pdf
07:36:18 <dylukes> Baughn: Space is a 0x20 byte.
07:36:19 <dylukes> Not 0x00 ;)
07:36:21 <Baughn> ...
07:36:27 <Baughn> You know what I mean.
07:36:36 <dylukes> oh, one byte per 254
07:36:59 <Baughn> Ideally distributed, then. Nice.
07:37:08 <dylukes> it replaces each zero with an offset to the next one, so it'd convert all of the zeroes to 0x01, and then the last one to 0xFF, I believe?...
07:37:12 <dylukes> I forget the exact encoding protocol
07:37:21 <dylukes> last one might just become 0x01
07:37:32 <dylukes> Anyhow, the point is its consistent
07:37:41 <dylukes> hence, CONSISTENT Overhead Byte Stuffing
07:37:49 <develhevel> howto convert int so string?
07:37:54 <Baughn> show
07:37:57 <hpc> > show 5
07:37:57 <lambdabot>   "5"
07:37:59 <develhevel> thx
07:38:40 <hpc> the modules chapter of lyah has a fairly good index of common functions
07:40:36 <Draconx> dylukes, so what happens if one formerly-zero-byte gets corrupted?  The entire stream following that byte is destroyed?
07:41:07 <dylukes> It's a TCP stream,
07:41:19 <Baughn> Draconx: You *always* need corruption-proofing
07:41:19 <dylukes> one of the core guarantees is data integrity, if that fails then the stream is invalid and should be closed.
07:41:27 <hpc> if any byte gets corrupted, the whole packet gets resent
07:41:33 <dylukes> hpc: ^
07:41:33 <Baughn> Attempting to make a corruption-/resistant/ protocol is a madman's game..
07:41:42 <dylukes> TCP has managed pretty well.
07:41:42 <Draconx> dylukes, TCP's integrity guarantee is very weak.
07:41:46 <Baughn> (Or a streamer's, but..)
07:41:57 <dylukes> If it does get corrupted, close it.
07:41:59 <Draconx> Baughn, ok, so you need error correction it in addition to this encoding.
07:42:09 <Baughn> Draconx: Well yeah, but that's always the case
07:42:13 <dylukes> It's unlikely enough, but if it happens the simplest solution is to close it.
07:42:17 <Baughn> The bottom level of any protocol *must* be ECC
07:42:30 <dylukes> Erie Community College!?
07:42:36 <Baughn> Yes!
07:42:46 <hpc> extreme cat complaining?
07:42:48 <dylukes> I propose a new law of the internet
07:43:17 <dylukes> All Computer Science acronyms are necessarily the initials of a university.
07:43:45 <Eduard_Munteanu> With SCTP you can get datagrams.
07:44:24 <Eduard_Munteanu> And anyway, it's not difficult to implement your own message format for TCP
07:44:26 <Draconx> Baughn, well, the point was that this encoding has extremely bad properties because a single bit error can destroy the entire stream.  Contrast with not doing any encoding at all, where a single bit error destroys... a single bit.  Or UTF-8, where a single bit error destroys at most one code point.
07:45:32 <Eduard_Munteanu> Just send binary data and make sure to convert to/from network byteorder.
07:45:33 <Baughn> Draconx: Watch me reach new depths of uncaring.
07:45:45 <Baughn> Draconx: IMO, that's a /feature/. You're more likely to notice the corruption.
07:47:00 <dylukes> Draconx: In most stream protocols, destroying a single bit...
07:47:06 <dylukes> destroys the whole stream
07:47:08 <dylukes> :|
07:47:35 <dylukes> use UDP if you're okay with a single bit being corrupted imo
07:48:11 <Draconx> dylukes, both UDP and TCP use the same integrity check...
07:48:43 <dylukes> UDP has no ACKs or retransmission
07:48:51 <dylukes> so in other words, any integrity checks it performs are kind of superficial
07:48:55 <Draconx> it's not a very good one, and lets errors go undetected at an alarming rate.
07:49:14 <dylukes> out of curiosity, line and passage?
07:49:25 <Draconx> dylukes, it's a goddamn sum of the bytes.
07:49:50 <dylukes> well, no hash is perfect :|
07:50:03 <dylukes> you're trying to represent X data in >X space.
07:50:09 <dylukes> There will be duplicates.
07:50:21 <Draconx> dylukes, this is probably one of the worst possible hashes.
07:50:31 <dylukes> true, I'm sure a better one could be used >_>
07:50:32 <Draconx> other than a constant function, I guess.
07:50:51 <dylukes> probably used for speed? Idk.
07:50:52 <yitz> Draconx: const undefined is pretty bad
07:51:14 <Baughn> @hoogle unsafeInterleaveIO
07:51:14 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
07:51:31 <dylukes> so, original question
07:51:58 <dylukes> how does one use something like attoparsec with iterates or something,
07:52:04 <dylukes> for continuous incremental input, with multiple outputs
07:52:18 <dylukes> the problem i always had was that it only produces one "output", and you can't "restart' it.
07:53:36 <yitz> dylukes: you mean the parser produces a list as its output?
07:54:03 <Draconx> dylukes, if you're relying on TCP to detect errors, you're almost guaranteed to see single bit errors occasionally.  This is why it's important to discuss how your higher level protocol deals with this situation.
07:55:11 <dylukes> yitz: No, I mean say I have a network stream
07:55:26 <dylukes> I want to produce packet-isomorphic data structures continuously
07:55:38 <dylukes> I want to parse out data structures _as they come in_
07:55:48 <dylukes> I guess that could be accomplished by using a lazy infinite list.
07:55:53 <dylukes> :\
07:56:09 <yitz> dylukes: you would parse each packet as it comes in
07:56:14 <electronplusplus> Hi
07:56:20 <dylukes> yitz: Sure, easier said than done, now do it.
07:56:23 <dylukes> :)
07:56:33 <yitz> dylukes: i've done it many times :)
07:56:34 <electronplusplus> foldr (\x y<-x+2*y) 0 [1,2,3]
07:56:40 <dylukes> yitz: Do you have an example then?
07:56:45 <electronplusplus> can somebody explain me this crap?
07:56:47 <dylukes> That'd be helpful
07:56:49 <electronplusplus> the result is 17
07:57:00 <dylukes> electrogeek: do you know the concept of a fold?
07:57:09 <electronplusplus> no
07:57:11 <dylukes> It's basically a list reduction
07:57:14 <dylukes> heres a simpler one
07:57:20 <dylukes> foldr (+) 0 [1,2,3]
07:57:27 <dylukes> > foldr (+) 0 [1,2,3]
07:57:28 <lambdabot>   6
07:57:39 <electronplusplus> I've already done that
07:57:41 <dylukes> what this does is, it starts with 0 and the first list item
07:57:46 <dylukes> applies the operation
07:57:53 <dylukes> then it takes that result, and the second list item...
07:57:56 <dylukes> and applies the operation...
07:58:04 <dylukes> fold l/r indicates the direction of the fold
07:58:11 <nus> @src foldr
07:58:11 <lambdabot> foldr f z []     = z
07:58:11 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:58:28 <nus> that's most consise explanation of 'this crap'
07:58:29 <dylukes> @src foldl
07:58:30 <lambdabot> foldl f z []     = z
07:58:30 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:58:37 <hpc> foldr (+) 0 [1,2,3] = 0 + foldr (+) 1 [2,3] = 0 + 1 + foldr (+) 2 [3] ...
07:58:37 <parcs> no it's not
07:58:44 <hpc> = 0 + 1 + 2 + 3
07:58:48 <hpc> = 6
07:58:50 <yitz> dylukes: well, the attosplit package splits a lazy bytestring at boundaries determined by an attoparsec parser, and returns a lazy list of lazy bytestrings, for example.
07:58:58 <dylukes> hpc: add the parentheses for clarities sake
07:59:02 <nus> parcs, care to elaborate?
07:59:11 <dylukes> A right fold of [1..5] becomes
07:59:12 <dylukes>  1 + (2 + (3 + (4 + 5)))
07:59:16 <dylukes> a left old of [1..5] becomes
07:59:25 <dylukes> (((1 + 2) + 3) + 4) + 5.
07:59:25 <parcs> nus:  a person that doesn't already know what a fold does will think that nothing insightful of its definition
08:00:05 <yitz> electronplusplus: http://foldr.com/
08:00:11 <parcs> er, will find nothing insightful in *
08:00:15 <electronplusplus> sorry guys
08:00:20 <electronplusplus> the right expression is  foldr (\x y->x+2*y) 0 [1,2,3]
08:00:22 <yitz> electronplusplus: see also - http://foldl.com/
08:00:30 <develhevel> howto cut off the last two chars of a string?
08:00:45 <dylukes> :t drop
08:00:47 <lambdabot> forall a. Int -> [a] -> [a]
08:00:52 <dylukes> drop "hello" 2
08:00:55 <dylukes> drop 2 "hello"
08:01:00 <yitz> develhevel: init.init
08:01:00 <dylukes> > drop 2 "hello"
08:01:01 <lambdabot>   "llo"
08:01:06 <dylukes> oh right, that drops from the front
08:01:11 <dylukes> > init.init "hello"
08:01:12 <lambdabot>   Couldn't match expected type `[a]'
08:01:12 <lambdabot>         against inferred type `GHC.Types...
08:01:13 <yitz> > (init . init) "Hello"
08:01:15 <lambdabot>   "Hel"
08:01:17 <dylukes> there we go
08:01:19 <dylukes> whoops
08:01:36 <develhevel> great thx
08:01:36 <hpc> > init . init $ "hello" -- works too
08:01:38 <lambdabot>   "hel"
08:01:50 <dylukes> yitz: hm
08:02:29 <dylukes> I'll look through the source of that yitz
08:02:29 <dylukes> thanks
08:02:47 <yitz> dylukes: you might need something simpler:
08:03:02 <parcs> @type flip . join $ take . (-) n . length
08:03:02 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
08:03:03 <lambdabot>     Probable cause: `take' is applied to too many arguments
08:03:03 <lambdabot>     In the first argument of `(.)', namely `take'
08:03:17 <parcs> @type  flip . join $ take . (-) 2 . length
08:03:18 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
08:03:18 <lambdabot>     Probable cause: `take' is applied to too many arguments
08:03:18 <lambdabot>     In the first argument of `(.)', namely `take'
08:03:32 * hackagebot hgettext 0.1.20 - Bindings to libintl.h (gettext, bindtextdomain)  http://hackage.haskell.org/package/hgettext-0.1.20 (VasylPasternak)
08:03:35 <parcs> @type join $ take . (-) 2 . length
08:03:35 <lambdabot> forall a. [a] -> [a]
08:03:40 <yitz> dylukes: the parse function, when it succeeds, gives you a Success constructor that includes the rest of the bytestring, so you just recurse on that
08:03:51 <yitz> dylukes: that's really simple if you
08:03:52 <parcs> @type flip . join $ take . (-) . length -- okay, this should do it
08:03:53 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
08:03:53 <lambdabot>     Probable cause: `take' is applied to too many arguments
08:03:53 <lambdabot>     In the first argument of `(.)', namely `take'
08:04:29 <dylukes> yitz: mm, true
08:04:35 <yitz> you're using laziness.
08:04:55 <dylukes> yeah, I don't want to use laziness for input from the network though, it tends to delay errors until after they happen…
08:05:03 <kennym> hello, is it possible to write a program in Haskell and generate an executable for Windows which doesn't require the Haskell libraries to execute it?
08:05:04 <dylukes> brings about the same issues as lazy io using binary/cereal
08:05:10 <yitz> dylukes: right
08:05:13 <dylukes> kennym: The runtime is compiled in.
08:06:01 <kennym> dylukes: cool, thanks
08:06:22 <yitz> dylukes: if you feed attoparsice part of a packet, it will tell you that by giving you a Partial constructor with a continuation function to call when you've got more bytes to feed it.
08:06:41 <yitz> dylukes: (the strict version of attoparsec that it)
08:06:53 <hpc> kennym: incidentally, it's the opposite that's difficult - compiling a haskell program that uses libraries already provided
08:07:11 <hpc> though the situation has improved quite a bit
08:08:16 <kennym> hpc: due to what the opposite is difficult?
08:09:35 <hpc> various things; i don't do dynamic linking stuff so i don't know much more than what i just said :P
08:10:27 <kennym> hpc: me less ;)
08:10:28 <yitz> @pl let dropEnd n xs = take (length xs - n) xs
08:10:28 <lambdabot> (line 1, column 43):
08:10:28 <lambdabot> unexpected end of input
08:10:28 <lambdabot> expecting variable, "(", operator, ";" or "in"
08:10:45 <yitz> @pl dropEnd n xs = take (length xs - n) xs
08:10:45 <lambdabot> dropEnd = join . (take .) . flip ((-) . length)
08:11:10 <yitz> parcs: ^
08:11:47 <parcs> yitz: i was trying to do it point-free
08:12:11 <yitz> parcs: yes, lambdabot did that for you :)
08:13:33 <kennym> yitz: how do you use lambdabot ?
08:13:41 <yitz> @help
08:13:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:13:52 <yitz> @list
08:13:53 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:14:00 <kennym> yitz: thanks
08:14:05 <yitz> but that's out of date. it's gives you an idea though
08:14:49 <kennym> pretty obscure manual to me
08:14:57 <monochrom> dynamic linking does not excuse you from shipping huge lib files. it is not like ghc libs come with every windows, linux, and macos
08:15:25 <yitz> kennym: yeah, just gives you some things to try out here
08:15:33 <monochrom> also, on windows, ghc dynamic linking is still clumsy to use
08:15:44 <yitz> kennym: use @vixen to talk to her persona
08:15:57 <yitz> @vixen hey lambdabot, please talk to kennym
08:15:58 <lambdabot> you're so polite :)
08:16:44 <cmccann> monochrom, my experience has often been that on windows, ghc is clumsy to use in general :I
08:17:10 <monochrom> but windows enjoys winghci, not available elsewhere
08:17:14 <benmachine> "my experience has often been that [...] windows [...] is clumsy to use in general"
08:18:02 <cmccann> benmachine, not really, things on windows tend to work well if you use only the latest versions of only microsoft products
08:18:17 <yitz> cmccann: do find winghci more clumsy than, say, pythonwin?
08:18:19 <benmachine> shockingly, I don't meet your precondition :P
08:18:32 <cmccann> it goes downhill once you get to legacy crap, terrible third-party software, and half-assed ports of open-source software
08:18:59 <monochrom> ha ha half-assed ports of open-source software
08:19:19 <cmccann> yitz, I never used winghci much to be honest, and I don't remember why
08:19:28 <yitz> cmccann: that's not always true. during the time when vista was the latest, you were best off using legacy winxp.
08:19:30 <cmccann> other than deciding that I didn't care for it for some reason
08:19:55 <cmccann> yitz, okay that's true, that was a very poorly-handled transition
08:20:08 <iwtu> can I get value from Maybe type Just a? Can I get only a without Just?
08:20:43 <cmccann> anyway, please note that I do very little Haskell programming on windows, so maybe if I used stuff more often I'd like it more
08:20:44 <yitz> iwtu: best is to use maybe or fromMaybe
08:20:49 <yitz> @type maybe
08:20:50 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
08:20:51 <Nimatek> :t fromJust
08:20:52 <lambdabot> forall a. Maybe a -> a
08:20:55 <yitz> @type fromMaybe
08:20:56 <lambdabot> forall a. a -> Maybe a -> a
08:21:17 <nus> The most clumsy part of using ghc on windows is wrestling with mingw.
08:21:18 <kmc> iwtu, by pattern matching
08:21:21 <dmwit> Using fromJust is asking for trouble, so ignore Nimatek. =P
08:21:28 <yitz> iwtu: fromJust does exactly what you say, but then you get an error if the input is Nothing instead of Just.
08:21:38 <Nimatek> True. It's a dirty shortcut.
08:21:41 <kmc> :t case ?x of (Just y) -> "foo "++ y; Nothing -> "bar"
08:21:42 <lambdabot> (?x::Maybe [Char]) => [Char]
08:22:12 <kmc> :t \x -> case x of (Just y) -> "foo "++ y; Nothing -> "bar"
08:22:13 <lambdabot> Maybe [Char] -> [Char]
08:22:18 <iwtu> is any a clean solutionn? ;0
08:22:20 <yitz> > fromMaybe "graceful failure" Nothing
08:22:21 <lambdabot>   "graceful failure"
08:22:28 <kmc> iwtu, yes, pattern matching
08:22:33 <yitz> > fromMaybe "graceful failure" (Just "the answer")
08:22:34 <lambdabot>   "the answer"
08:22:38 <monochrom> use "fromMaybe undefined" for the best of both worlds
08:22:42 <kmc> fromMaybe and maybe are useful helper functions, but pattern matching is the fundamental construct
08:22:44 <kmc> @src maybe
08:22:44 <lambdabot> maybe n _ Nothing  = n
08:22:44 <lambdabot> maybe _ f (Just x) = f x
08:22:45 <dmwit> iwtu: Yes, pattern matching, fromMaybe, and maybe are all clean solutions.
08:22:48 <kmc> @src fromMaybe
08:22:48 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
08:23:04 <Twey> That's some oddly-formatted code
08:23:15 <Twey> fromMaybe = flip maybe id
08:23:38 <iwtu> what do you mean by pattern matching?
08:23:44 <kmc> see above
08:23:53 <kmc> anything using "case"
08:23:56 <dmwit> iwtu: case x of {...} is pattern matching
08:24:01 <kmc> or functions defined with multiple equations, like "maybe" is
08:24:09 <kmc> any Haskell tutorial will cover it
08:24:09 <yitz> kmc: you almost never need to go to that low level, fromMaybe and maybe are much nicer, and almost always what you need. then there are other nice combinators - catMaybes, etc.
08:24:25 <kmc> pattern matching is absolutely fundamental to the way Haskell works
08:24:34 <yitz> kmc: so is assembly language
08:24:35 <cmccann> the "maybe" function does everything pattern matching on a Maybe does, anyway
08:24:49 <yitz> kmc: i know i am not being fair
08:25:20 <yitz> kmc: actually pattern matching is very nice and powerful too, but i think it's almost always bad style for Maybe.
08:25:22 <cmccann> should also point out that do notation is nice for dealing with a bunch of Maybes in a row
08:25:32 <monochrom> you cannot avoid knowing pattern matching
08:25:34 <copumpkin> yitz: what if you have a "deep" pattern in maybe?
08:25:58 <yitz> cmccann: and the Monoid instance, etc. there are so many nice combinator tools
08:25:59 <copumpkin> yitz: things like maybe on lists can get rather mind-bending if you want to pattern match on two things at once
08:26:22 <monochrom> if you don't know pattern matching, you can't even use your own data types
08:26:28 <yitz> copumpkin: usually the Monad or Monoid instances are right for those situations
08:26:28 <cmccann> yitz, I find myself using fromMaybe, catMaybes, and do blocks the most often I think
08:26:42 <monochrom> whereas if you don't know assembly code, you can still use haskell fully
08:26:46 <copumpkin> yitz: for what, zip?
08:26:47 <kmc> i like how iwtu asked a simple question and now we're having a huge philosophical argument
08:26:48 <yitz> or even Applicative sometimes
08:27:01 <cmccann> kmc, that's kind of how #haskell works, isn't it
08:27:05 <kmc> yep
08:27:22 <cmccann> ask a simple question, get three simple answers and a half hour of abstraction golfing and philosophical debate
08:27:40 <yitz> iwtu: please ignore our philosophical discussion. we enjoy that here. but actually this is very simple. i hope we have gotten that across. :)
08:27:58 <kmc> for the record, my point in saying pattern matching is fundamental is just that iwtu will find an explanation in any half-decent tutorial and that understanding this explanation is important
08:28:17 <yitz> kmc: point taken
08:28:51 <nus> cmccann, the wiser would evaluate the input lazily (-:
08:29:46 <copumpkin> yitz: write f Nothing y = 5; f x Nothing = 7; f (Just x) (Just y) = x + y using maybe!
08:30:04 * cmccann is tempted to argue that "maybe" is more fundamental due to being the Church encoding, and that pattern matching is just a detail of Haskell rather than central to functional programming... but that's just getting silly
08:30:28 <ziman> pattern matching is fundamental for ghc because core uses just pattern matching :)
08:30:30 <monochrom> it's fundamentalists all the way down
08:30:46 <copumpkin> pattern matching saves you from having to figure out shit like the thing I wrote above
08:31:01 <iwtu> yitz: thanks! so can you give some good way to do it? :)
08:31:02 <iwtu> fromJust looks look but it's a dirty
08:31:21 * monochrom trolls. which one is more fundamental, turing machine or lambda calculus?
08:31:32 <cmccann> monochrom, trick question
08:31:33 <kmc> :t maybe (const 5) (\x -> maybe 7 (+x))
08:31:34 <lambdabot> forall a. (Num a) => Maybe a -> Maybe a -> a
08:31:34 <yitz> f x y  = fromMaybe 5 x + fromMaybe 7 y -- copumpkin can come up with something more challenging than that surely
08:31:37 <nus> All your fundamentals are belong tu us.
08:31:37 <cmccann> the answer is obviously SK calculus
08:31:44 <kmc> @pl maybe (const 5) (\x -> maybe 7 (+x))
08:31:44 <lambdabot> maybe (const 5) (maybe 7 . (+))
08:31:50 <monochrom> like there is an objective mathematical definition of "more fundamental"
08:32:01 <kmc> it's not that bad copumpkin ;)
08:32:11 <copumpkin> kmc: write zipWith using the list eliminator, I dare you :P
08:32:14 <companion_cube> monochrom: lambda calculus is more elegant, thus more fundamental
08:32:15 <iwtu> kmc: I learned in another language. Not sure what pattern matching means
08:32:33 <cmccann> iwtu, if you just want the value from the Maybe type, use "fromMaybe" and give it a default value to use when it's Nothing
08:32:33 <kmc> iwtu, how are you learning Haskell
08:32:50 <monochrom> by learning in another language :)
08:33:02 <yitz> monochrom: shush!
08:33:22 <kmc> iwtu, "pattern matching" refers to a specific Haskell feature, which any tutorial will explain
08:33:49 * cmccann thinks maybe iwtu means "another human language" and needs pattern matching translated, not explained
08:33:57 <kmc> did @pl just use the commutativity of (+)?
08:34:00 <yitz> iwtu: you write several different definitions for the same function. the one where the input matches the pattern is the one that is used.
08:34:05 <kmc> cmccann, since most of the tutorials are in English...
08:34:29 <cmccann> kmc, it gets taught in university courses as well
08:34:33 * cmccann shrugs
08:34:35 <kmc> oh, true
08:34:53 <iwtu> result is first that matches
08:35:02 <yitz> iwtu: yes
08:35:45 <iwtu> unlike Prolog
08:35:47 <yitz> @pl \x -> x + 5
08:35:47 <lambdabot> (5 +)
08:35:56 <yitz> @pl \x -> 5 + x
08:35:56 <lambdabot> (5 +)
08:36:08 <yitz> kmc: wow you're right, look at that!
08:36:47 <yitz> @vixen who taught you that addition is commutative?
08:36:47 <lambdabot> that's a good question, who?
08:36:54 <nus> @unpl (5 +)
08:36:54 <lambdabot> (\ a -> 5 + a)
08:36:57 <nus> @unpl (+ 5)
08:36:57 <lambdabot> (\ a -> a + 5)
08:38:03 <yitz> iwtu: oh, you know prolog? great! what other languages do you know?
08:38:16 <iwtu> and guys. I need little big help with syntax. I want to build a Trie
08:39:39 <cmccann> iwtu, did you have a specific question? or want general help? there are several implementations of tries in libraries that you could look at to see how they work.
08:40:18 <iwtu> cmccann: maybe it would be good practise to make it by myself
08:41:04 <ziman> have you tried building a binary tree?
08:41:15 <ziman> *tried to build
08:41:16 <cmccann> iwtu, sure, if you want to. Very basic tries are pretty simple if you're not too worried about serious optimization
08:42:02 <iwtu> ziman: yes :)
08:42:35 <iwtu> so, if it si pretty easy so no problem :)
08:42:58 <cmccann> iwtu, a basic trie isn't too different from a binary search tree
08:43:01 <iwtu> I will try something and show you the code, all right?
08:43:29 <sshc> http://hackage.haskell.org/trac/ghc/ticket/2095 — Disappointing to see where this went.
08:43:43 <Lemmih> @seen roconnor
08:43:43 <lambdabot> Unknown command, try @list
08:43:43 <preflex>  roconnor was last seen on #haskell 1 day, 15 hours, 38 minutes and 1 second ago, saying: *time
08:43:43 <cmccann> iwtu, go ahead. you can use hpaste to show people the code when you're ready
08:43:46 <yitz> iwtu: ok put it on hpaste when you have something
08:43:50 <yitz> @hpaste
08:43:50 <lambdabot> Haskell pastebin: http://hpaste.org/
08:45:02 <iwtu> yitz: yitz I messaged you. maybe it doesn't work.
08:48:30 <iwtu> data MyTrie = Leaf | Branch (Data.Map Char MyTrie)
08:48:46 <iwtu> how can I get key's value in Data.Map?
08:49:01 <kmc> iwtu, look at the Data.Map documentation
08:49:06 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/index.html
08:50:42 <iwtu> thanks. I didn't notice ! operator
08:50:50 <kmc> you probably want 'lookup'
08:50:57 <kmc> because ! will fail ungracefully if the key isn't in there
08:51:04 <iwtu> lookup has Just
08:51:10 <kmc> es
08:51:11 <kmc> yes
08:51:14 <kmc> that's a feature, not a bug
08:51:15 <ziman> you can also try
08:51:30 <ziman> @hoogle k -> Map k v -> Maybe v
08:51:31 <lambdabot> Data.Map lookup :: Ord k => k -> Map k a -> Maybe a
08:51:31 <lambdabot> Data.Map lookupIndex :: Ord k => k -> Map k a -> Maybe Int
08:51:31 <lambdabot> Data.Map (!) :: Ord k => Map k a -> k -> a
08:52:03 <kmc> iwtu, how were you planning to handle the 'character not found' case with (!)
08:52:28 <kmc> if you're using Map.member and then Map.(!), that's a classic case of Doing It Wrong
08:52:38 <kmc> just like «if xs == [] then head xs else ...»
08:52:44 <kmc> you should instead call 'lookup' and pattern-match
09:00:38 * hackagebot cpphs 1.12 - A liberalised re-implementation of cpp, the C pre-processor.  http://hackage.haskell.org/package/cpphs-1.12 (MalcolmWallace)
09:00:53 <hpaste> iwtu pasted “MyTrie” at http://hpaste.org/48350
09:02:26 <iwtu> is that correct insert?
09:02:33 <iwtu> and data type
09:02:38 * hackagebot polyparse 1.7 - A variety of alternative parser combinator libraries.  http://hackage.haskell.org/package/polyparse-1.7 (MalcolmWallace)
09:03:20 <kmc> iwtu, you're Doing It Wrong the way I said earlier
09:03:27 <kmc> using M.member and M.! together
09:03:36 <kmc> you should call M.lookup and pattern-match on the result instead
09:03:38 * hackagebot seclib 0.4 - A lightweight library for Information-flow security in Haskell  http://hackage.haskell.org/package/seclib-0.4 (AlejandroRusso)
09:04:35 <iwtu> can you fix it? maybe it can sound odd but it is the quickier way I learn
09:04:43 <kmc> not atm, i have to go
09:04:43 <cmccann> think of "Maybe a" as a combination of Bool and a, telling you either "No, there is no value" or "Yes, there is a value, and here it is"
09:04:47 <kmc> but someone else will help you
09:05:08 * cmccann actually needs to run in a moment as well :[
09:05:47 <iwtu> and but it's really cool to make trie in 2 lines. in c++ is not so trivial
09:07:50 <iwtu> please, I am pretty new in Haskell. can someone fix my code and tell me what was wrong?
09:08:34 <lfppv> hi
09:09:03 <lfppv> i want to create a function that evaluates the value of an expression, the function is defined as eval :: Expr a -> (a -> a) -> (a->a) -> a
09:09:08 <lfppv> but it says that i cant do this
09:09:16 <lfppv> cannot construct infinite type
09:09:33 <identity_> You're going to need to post code for us to solve that problem for you
09:09:55 <lfppv> data Expr a = P (Expr a) (Expr a) | S (Expr a) (Expr a) | V a
09:09:56 <lfppv> avaliar :: Expr a -> (a -> a) -> (a -> a) -> a
09:09:56 <lfppv> avaliar (V a) _ _       = a
09:09:56 <lfppv> avaliar (P esq dir) _ p = p (avaliar esq) (avaliar dir)
09:09:56 <lfppv> avaliar (S esq dir) s _ = s (avaliar esq) (avaliar dir)
09:10:01 <identity_> @hpaste
09:10:02 <lambdabot> Haskell pastebin: http://hpaste.org/
09:10:49 <lfppv> too late, sorry
09:11:55 <lfppv> so, why i can't do this?
09:12:33 <identity_> well, what I notice is that your functions p and s are of type (a -> a), but you're trying to apply them to (Expr a)
09:12:44 <lfppv> oh
09:12:48 <iwtu> yitz: may I? :)
09:12:58 <Eduard_Munteanu> Actually they're a -> a but you're giving them two arguments
09:13:04 <parcs> lfppv: because in your inner calls to avaliar you're forgetting about the other two parameters
09:14:21 <lfppv> parcs, ?
09:15:13 <identity_> oh, duh, yeah
09:15:21 <identity_> lfppv: avaliar 'takes 3 arguments'
09:15:39 <identity_> you're calling avaliar on one argument in your inner calls
09:16:09 <identity_> p (avaliar esq) (avaliar dir)
09:16:10 <Eduard_Munteanu> p :: a -> a;   s :: a -> a
09:16:30 <cmccann> iwtu, kmc was just suggesting that you use lookup and pattern match on the Maybe instead of using M.member and a conditional
09:16:39 * hackagebot HaXml 1.22 - Utilities for manipulating XML documents  http://hackage.haskell.org/package/HaXml-1.22 (MalcolmWallace)
09:17:18 <iwtu> why?
09:17:59 <cmccann> iwtu, because it's cleaner, easier to read, and more obviously correct mostly
09:18:20 <hpaste> ziman annotated “MyTrie” with “MyTrie (annotation)” at http://hpaste.org/48350#a48351
09:18:29 <cmccann> with a conditional you could e.g. get the clauses backwards and it wouldn't be obvious from the code
09:18:34 <kmc> actually those aren't even my main reason
09:18:46 <cmccann> kmc, thought you left :P
09:18:51 <kmc> i did.  i'm back
09:19:29 <ksf> any of the gtk2hs cracks around?
09:19:33 <erus`> anyone know of a voice recognition library for haskell?
09:19:41 <kmc> the main reasons are a) pattern matching is fundamental to how Haskell works, b) pattern matching generalizes to many other types besides Maybe
09:19:44 <ksf> manata doesn't seem to be there.
09:20:01 <kmc> you need to know it
09:20:37 <lfppv> parcs, so the function must be defined as (Expr a -> Expr a -> a)
09:20:44 <ksf> erus`, floss C libraries that'd be easy to bind are easy to find, the problem is the speech models.
09:21:28 <cmccann> kmc, ok fair points
09:21:41 <kmc> you can't learn Haskell without becoming comfortable with pattern matching
09:21:42 <ksf> they suffice to tell your box to call a phone number, but forget about actual speech recognition
09:21:43 <kmc> that's a simple contradiction
09:21:52 <parcs> lfppv: i don't know. i'm not sure what you intend your code to do
09:22:16 <cmccann> kmc, I was thinking more in terms of "why should anyone use pattern matching here" rather than "why should a beginner use pattern matching" I guess
09:22:21 <kmc> ok
09:22:38 <kmc> the points you raised are also important ones, of course
09:23:15 <subpy> 4Z3tY7y3
09:23:22 <kmc> cool password
09:24:50 <erus`> ksf: im just hoping to make a chess voice interface
09:24:58 <lfppv> parcs, forget it, i already solved
09:24:59 <erus`> so no full sentences :)
09:28:15 <ksf> erus`, try http://www.voxforge.org/
09:28:22 <ksf> they're doing speech models
09:28:44 <hpaste> iwtu annotated “MyTrie” with “MyTrie (annotation)” at http://hpaste.org/48350#a48352
09:28:52 <iwtu> thanks. first, i would be cool to have no only char. What I tried this I had an error
09:29:02 <ksf> you'll be able to talk to the engine of your choice via stdin/out
09:30:18 <ksf> the quickstart should already be sufficient to do what you want.
09:32:26 <scooty-puff> is there a way, when writing a compiler, to handle line and column number information transparently?
09:32:50 <scooty-puff> the ghc compiler lets it seep into the hs syn data structures, but i can't think of another way
09:34:01 <kmc> define 'transparently'
09:34:27 <iwtu> ziman: thanks. insert on leaf I need construct new trie
09:34:54 <scooty-puff> well, when i'm resolving names/scope, the ScopeT monad does not know about location
09:35:05 <scooty-puff> it just calls throwError "undefined ...", etc.
09:35:59 <scooty-puff> i hate that it may need to
09:36:33 <scooty-puff> by transparently, i guess i mean, maybe with a monad that provides the syntax data type, and provides accessors that push the location information, and rewraps errors maybe?
09:36:35 <scooty-puff> idk
09:38:15 <kmc> the only thing that comes to mind in this space is an old trick that SPJ (and probably many others) came up with
09:38:25 <cmccann> scooty-puff, wouldn't that fall under the general heading of annotating arbitrary trees
09:38:53 <kmc> data Exp self = Lit Int | Add self self
09:39:05 <cmccann> so you can hang various things off of it like source location with the main syntax tree parameterized in the random junk
09:39:13 <kmc> data SrcPos t = SrcPos Int Int t
09:39:26 <kmc> type Expr = Exp (SrcPos Exp)
09:39:31 <kmc> except, i screwed up the kinds somehow
09:39:46 <scooty-puff> hmm - had pretty close to that - just didn't parameterize properly for the subtypes
09:39:56 <kmc> i think this is what cmccann is talking about, and can probably explain better
09:39:57 <kmc> bbl again
09:40:01 <scooty-puff> (only parameterized the "identifier" or "name"
09:40:04 <scooty-puff> )
09:40:22 <cmccann> yeah, kmc's talking about a specific approach to what I meant
09:41:29 <scooty-puff> so a concrete example:
09:41:35 <scooty-puff> i currently have data constructor:
09:41:46 <scooty-puff> Decl a (Expr a)
09:41:52 <scooty-puff> for some Expr:
09:41:54 <cmccann> scooty-puff, you can make the structure polymorphic in its recursion in various ways, some examples being stuff like Tree a = Leaf | Branch (Tree a) (Tree a), Tree f = Leaf | Branch (f (Tree f) (Tree f)), or splicing in the recursive stuff completely like kmc's example
09:41:57 <scooty-puff> Var a | ...
09:42:21 <scooty-puff> hmm, i always forget that the type parameter can have kind greater than *
09:42:24 <scooty-puff> thanks for the help!
09:42:43 <cmccann> scooty-puff, there's lots of material about this out there, you can probably find better examples
09:42:49 <scooty-puff> ok
09:43:01 <scooty-puff> i'll try the wiki
09:43:08 * cmccann recalls Oleg doing something involving a zipper over a pre-existing structure to reconstruct a polymorphic version of out of thin air
09:44:41 <cmccann> scooty-puff, one example I do know of is in haskell-src-exts
09:45:09 <cmccann> it has a parameterized version of the AST that does it the way your current code does
09:45:38 <cmccann> the higher-kinded version is basically the same, it just lets you monkey with the structure instead of only hanging data off of it
09:46:48 <cmccann> and the extreme version is simply parameterizing everything in its recursive argument and then stitching the whole thing back together to reconstruct the recursive type, possibly with things spliced in
09:47:15 * cmccann actually can't find any straightforward examples and comparisons from googling, oddly
09:47:28 <ben> can I ask stupid questions about the enumerator package
09:47:36 <scooty-puff> i'll see if i can find the way oleg did it
09:47:41 <ben> I have been trying to wrap my head around it for days but it's not clicking
09:47:46 * hackagebot KdTree 0.1 - KdTree, for efficient search in K-dimensional point clouds.  http://hackage.haskell.org/package/KdTree-0.1 (IssacTrotts)
09:48:04 <cmccann> scooty-puff, hahaha that's probably not what you want, it's mostly for adding annotations to a pre-existing type you can't modify
09:48:15 <scooty-puff> o, ok
09:48:16 <cmccann> ben, stupid questions are always welcome
09:48:47 <hpaste> iwtu annotated “MyTrie” with “MyTrie (annotation) (annotation)” at http://hpaste.org/48350#a48353
09:49:09 <ben> I do not want to boil it down to a concrete "how do i do ___" question, but the general scheme to build an iterator is to start in the Continue step (wrapped in whatever monad), keep building up my own internal state while returning continuations to the enumerator all the time, and eventually yielding a single value?
09:49:11 <iwtu> what wrong wity type a?
09:49:32 <ben> Either when I feel I'm done or get EOF?
09:50:05 <ben> I am having trouble reading the type signature since they are all relatively similar
09:50:16 <ben> and I am not sure I understand how the monad instance or any of the combinators really work
09:50:53 <cmccann> ben, something like that, it's basically an incremental fold that does some steps and then returns either a value saying "all done" or one that takes more input
09:51:08 <ben> I thought I could with relative ease build an Enumeratee(?) that would take bytestring chunks of raw data and then act as a source of lines for another iteratee or whatever
09:51:10 <cmccann> I don't know the specific library well enough to speak about the details though :\
09:51:36 <ben> but I kind of got tripped up in all the cases I have to handle at each step and I am not really sure how to express this in the library's helper functions
09:52:22 <cmccann> ben, hmmm, I'm pretty sure that should be a straightforward application of the iteratees concept, but you'll probably need to ask someone who's used the enumerator package itself, sorry
09:52:40 <ben> Right, thanks :)
09:53:28 <Yrogirg> Hello! How do I make a type synonym with parameters, like type List = [a] ?
09:54:10 <cmccann> Yrogirg, like "type List a = [a]"?
09:54:12 <cmccann> or do you mean something else
09:54:40 <iwtu> so guys... :)
09:55:00 <Yrogirg> oh, wait, now I understand what I mean, thank you anyway
09:55:22 <osaunders> Can I load GHCi using the extensions and various options specified in a .cabal file?
09:55:48 <cmccann> iwtu, not sure what you're asking about
09:56:46 <iwtu> I can load it as module, because Not in scope: type variable `a'
09:57:58 <iwtu> *cannot
09:58:55 <cmccann> iwtu, oh, you need that to be a type parameter on MyTrie
09:58:56 <osaunders> iwtu: «data MyTrie =» should be data «data MyTrie a»
09:59:03 <cmccann> yeah, what osaunders said
09:59:26 <osaunders> I missed the equals on the second one I mentioned there
09:59:37 <osaunders> Basically a goes after the type name after data
10:00:36 <iwtu> sorry. my mistakes. thanks guys.. :(
10:04:58 <hpaste> iwtu annotated “MyTrie” with “MyTrie (annotation) (annotation) (annotation)” at http://hpaste.org/48350#a48354
10:05:32 <iwtu> I still cannot load the module
10:06:03 <scooty-puff> cmccann, its pastebin (sorry) - heres what i have now: http://pastebin.com/raw.php?i=UzeStzhx
10:06:06 <mauke> The paste UzeStzhx has been copied to http://hpaste.org/48355
10:06:20 <scooty-puff> had to thread it throughout, but at least its just some type threaded, vs. Located or whatever
10:07:10 <osaunders> iwtu: What does it say now?
10:11:54 <yitz> iwtu: one problem is that you need Ord a, not just Eq a, for the key to a Map.
10:12:26 <osaunders> Damn, this ticket is 3 years old :( http://hackage.haskell.org/trac/hackage/ticket/382
10:14:28 <yitz> iwtu: I think you want "insertMyTrie [] t = t" instead of Leaf
10:16:29 <yitz> iwtu: ah no, I see.
10:25:02 <yitz> insertMyTrie xs Leaf = foldr ins Leaf xs where {ins x t = Branch $ M.singleton x t} -- iwtu, is this correct?
10:33:32 <syntaxfree> avrdude is like one of those pissy roman gods who could get offended at anything and basically fuck up your wars.
10:34:18 <syntaxfree> the usual home cures for program-won't-upload aren't getting through today :/ help.
10:34:50 <identity_> Did you try hitting it, hitting it harder each time, for a few times?
10:35:16 <syntaxfree> dude, I tried sacrificing a goat to it.
10:35:16 <ksf> carthago must fall!
10:35:28 <identity_> syntaxfree: Ah, that was my next suggestion
10:35:32 <identity_> I'm all out then
10:36:33 <syntaxfree> now I have two breadboards and three servos screwed into a DVD box and goat blood everywhere and so many wires :'(
10:36:35 * ksf wants to expand clutterhs, but the bindings are so horrendeously outdated compared to gtk2hs that they should actually be semi-rewritten.
10:37:40 <syntaxfree> ksf: semi-rewrites are like the full pain of code maintenance + the full pain of writing from scratch anyway.
10:37:55 <syntaxfree> but more importantly, I can't program my arduino!
10:37:56 <ksf> dunno why nobody's using it, it's perfect for any kind of custom gui
10:38:09 <ksf> that is, not-vanilla-widget-toolkit uis.
10:38:57 <ksf> the rewrite isn't what's scaring me, it's whatever evil lurks behind GInitiallyUnowned
10:39:41 <ksf> clutterhs' object hierarchy isn't even autogenerated.
10:39:45 * syntaxfree pretends to be a girl to get attention, then cries for help
10:39:59 <syntaxfree> wait, gtk2hs = haskell?
10:40:08 <syntaxfree> MAN, I'M IN THE WRONG CHANNEL.
10:40:11 <ksf> and the gtk2hs build tools look like what you'd expect from ad-hoc build tools.
10:40:36 * ksf loathes gtk
10:40:44 <identity_> syntaxfree: you are, yes
10:42:29 <Eduard_Munteanu> ksf: it's quite alright, at least when used from Haskell.
10:42:37 <syntaxfree> qt looks almost right on the mac. the current Java app gui framework looks right, if they try it right.
10:42:59 <iwtu> osaunders: http://paste.pocoo.org/show/420364/
10:43:03 <Eduard_Munteanu> Unless you're hinting at the potential awesomeness of something like Grapefruit, but you might need a time machine for that.
10:43:07 <ksf> the only decent UI I ever did involved writing my own toolkit
10:43:20 <iwtu> that the loading problem
10:43:23 <syntaxfree> Eduard_Munteanu: well, one can always say "I hate binary computer, tri-state logic has so much to offer even in the classical (non-quantum) case"
10:43:28 <ksf> widget toolkits assume too much.
10:43:34 <syntaxfree> and still have an iPad or whatnot.
10:43:35 <Eduard_Munteanu> ksf: so you say X11 gives you a better API? :P
10:43:52 <ksf> I used j2me
10:43:55 <Eduard_Munteanu> Ah.
10:44:35 <ksf> a description of the actual ui in a bunch of nested Object arrays and then two interpreters on top of that.
10:44:52 <ksf> ...one to draw, one to dispatch touchscreen input.
10:44:54 <Eduard_Munteanu> Is GTK even an option there? :/
10:44:58 <ksf> no.
10:45:23 <ksf> the j2me menu system wasn't, either, as it's full-screen and doesn't work on a canvas.
10:45:32 <syntaxfree> I wouldn't want to be in UI programmers these days.
10:45:44 <ksf> there was fun to be had back in those days.
10:45:50 <iwtu> cmccann: can you see the problem? http://www.ms.mff.cuni.cz/~lachataa/cv_lachataa_new.pdf
10:45:58 <iwtu> sorry.
10:46:04 <syntaxfree> "Multi-touch" gestures have generated a whole set of expectatons of parallel responsiveness.
10:46:11 <iwtu> that's problem http://paste.pocoo.org/show/420364/
10:46:37 <ksf> like remembering what tiles are on the screen to do partial screen-updates squeeze more fps out of that abysmal graphic bandwidth.
10:46:46 <cmccann> iwtu, sorry, busy right now :[
10:46:52 <ksf> (~4 fps on whole-screen updates)
10:47:22 <ksf> luckily that didn't matter *too* much as the lcd behaved much like very, very laggy phosphor.
10:47:59 <iwtu> cmccann: :)
10:50:02 <iwtu>  cmccann solved, hope
11:03:57 <Phyx-> well, that's weird.. getting ld errors from ghc
11:04:55 <hpaste> electronplusplus pasted “Whre's the Bug?” at http://hpaste.org/48357
11:05:45 <Botje> electronplusplus: "return" isn't what you think it is.
11:05:58 <Botje> remove it and it should compile
11:06:13 <Botje> of course you might as well get rid of the if
11:06:27 <Botje> and just put the length [...] == 0 bit
11:07:04 <electronplusplus> Botje: it's a college problem to check is a list of bools is even or odd
11:07:29 <Botje> electronplusplus: i can see that
11:07:36 <Botje> you don't need the return in haskell
11:07:50 <electronplusplus> I hate haskell
11:07:54 <Phyx-> :O
11:07:58 <Phyx-> blasphamy
11:08:06 <electronplusplus> C is so perfect
11:08:08 <Botje> you probably mean you hate the way it is taught.
11:08:30 <electronplusplus> everything
11:08:38 <electronplusplus> It's kind of cool but
11:09:00 <_habnabit> But you don't get it.
11:09:24 <electronplusplus> I'm used to code in C style
11:09:26 <Nimatek> electronplusplus: Haskell is cool because what you tried to write would be " paridade xs = even $ length [ l | l <- xs, l] "
11:09:28 <_habnabit> Once it clicks, and you stop trying to write C with haskell syntax, you'll enjoy it more.
11:10:05 <Botje> paridade xs = even (filter id xs)
11:10:16 <identity_> You know what they say: Once you go monads, everything else is gonads
11:10:19 <Botje> :)
11:10:25 <olsner> paridade = even . filter id
11:10:36 <identity_> I wrote a single line of C++ to help someone out the other day, and I felt so dirty I had to shower
11:11:56 * hackagebot couchdb-enumerator 0.3.0 - Couch DB client library using http-enumerator and aeson  http://hackage.haskell.org/package/couchdb-enumerator-0.3.0 (JohnLenz)
11:13:02 <ddarius> > map (foldl' (/=) True) [[], [True], [True, False, False], [True, True], [True, False, False, True], [True, False, True]]
11:13:02 <lambdabot>   [True,False,False,True,True,True]
11:13:03 <electronplusplus> Nimatek: $ does what?
11:13:41 <Botje> make your code prettier
11:13:51 <Phyx-> heh
11:13:53 <Nimatek> electronplusplus: same as putting it in brackets
11:14:01 <electronplusplus> nice
11:14:16 <electronplusplus> that would be a fantastic answers for my exam tomorrow :)
11:14:46 <Phyx-> electronplusplus: it's a function with very low precidence, which operationally has the same effect as putting parenthesis around the expression in it's right hand side
11:15:12 <Phyx-> It's just application, ($) = \f x-> f x
11:15:49 <electronplusplus> A+ in the Exam == Android device+ #haskell
11:16:07 <Phyx-> @*@*@^#* what is wrong with ld
11:16:08 <lambdabot> Unknown command, try @list
11:16:18 <Botje> electronplusplus: take some time to read through learn you a haskell, regardless of whether you need it for your exam
11:16:39 <tippenein> learn you a haskell is great
11:16:41 <electronplusplus> I'm going to speed 6 hours today on it
11:16:45 * Phyx- votes for Real World Haskell
11:17:01 * cmccann suggests the gentle introduction
11:17:05 <electronplusplus> btw
11:17:07 <ddarius> electronplusplus: Why don't you spend 6 hours at a job instead, and just buy an Android device.
11:17:15 <electronplusplus> right now, what are you using Haskell for?
11:17:49 <electronplusplus> ddarius: i'm a future computer scientist
11:17:51 <Phyx-> ATM? to make a preprocessor
11:17:56 <luite> electronplusplus: for building a web site about haskell
11:18:04 <electronplusplus> LOL
11:18:06 <Botje> two compilers and most of project euler
11:18:51 <Phyx-> anyone have any idea why i'm getting the following linker error? "\cabal\Hs2lib-0.4.8\ghc-7.0.3/libHSHs2lib-0.4.8.a(NativeMapping.o):fake:(.text+0x66db): undefined reference to `__stginit_Hs2libzm0zi4zi8_WinDllziCodeGenziNative_'"
11:19:00 * cmccann most recently used Haskell to write a script to play a videogame for him, and to generate pretty pictures with math
11:19:24 <Phyx-> Oh
11:19:32 <Phyx-> heh..
11:19:33 <luite> cmccann: do you have examples of those pretty pictures with math?
11:19:56 <cmccann> luite, http://www.reddit.com/r/mathpics/comments/i1ri0/patterns_from_plotting_polynomial_roots_in_the/
11:20:18 <Eduard_Munteanu> ddarius shoves people to drop school? :P
11:21:02 <djahandarie> Yes, physically
11:21:16 <electronplusplus> delete :: Eq a ⇒ a → [a] → [a
11:21:26 <djahandarie> Oh god, unicode.
11:21:34 <electronplusplus> lol
11:21:41 <electronplusplus> utf-8
11:21:45 <ddarius> Eduard_Munteanu: I didn't say that.  If the goal is to get an Android device, even if it takes greater than 6 hours of work to get it, the difference is made up by the elimination of risk that you will get nothing.
11:21:56 <ddarius> Eduard_Munteanu: I push people to behave rationally.
11:22:01 <luite> cmccann: what exactly did you plot there?
11:22:09 <cmccann> unicode syntax in haskell is useless without being able to write lambdas with an honest-to-god lambda
11:22:16 <cmccann> luite, read the comments
11:22:31 <djahandarie> cmccann, and use a dot rather than an arrow, like God intended it?
11:22:43 <Eduard_Munteanu> ddarius: hm, fair point
11:22:50 <cmccann> djahandarie, that would be nice too, but the lambda is more important
11:23:15 <syntaxfree> someone pinged me?
11:23:19 <hpaste> electronplusplus pasted “Make it beautifull” at http://hpaste.org/48358
11:23:42 <identity_> electronplusplus: use guards
11:23:47 <_habnabit> read: "do my homework"
11:24:05 <electronplusplus> It not homework _habnabit
11:24:08 <electronplusplus> it's*
11:24:16 <electronplusplus> I've an exam tomorrow
11:24:30 <cmccann> luite, if you have more specific questions I can try to clarify, but the big comment covers most of it
11:24:54 <ddarius> It's his studying.  He's having other people do his studying to increase parallelism and get it over quicker.
11:25:41 <Phyx-> ddarius: how does he sync back the knowledge?
11:26:34 <hpaste> “Mukesh Tiwari” annotated “Whre's the Bug?” with “Whre's the Bug? (annotation)” at http://hpaste.org/48357#a48359
11:26:49 <luite> cmccann: are the different colors related to the degree of the corresponding polynomials?
11:26:51 <hpaste> electronplusplus annotated “Make it beautifull” with “Beautiful enough?” at http://hpaste.org/48358#a48360
11:26:57 <ksf> flags:
11:26:57 <ksf>         echo "" `pkg-config clutter-1.0 --cflags` | sed s/\ /\ -C\ /g > flags
11:26:57 <ksf> %.hs: %.chs flags
11:26:57 <ksf>         c2hs -o $@ `cat flags` $<
11:27:06 * ksf wins the daily evilness award.
11:27:43 * Phyx- taps the room, is this thing on
11:27:51 <cmccann> luite, no, density of roots
11:27:55 <lispy> Phyx-: ouch!
11:27:59 <lispy> Phyx-: and yes
11:28:07 <cmccann> luite, all the polynomials have the same degree
11:28:09 <electronplusplus> identity_: http://hpaste.org/48358#a48360
11:28:15 <olsner> ksf: you should make it so 'flags' doesn't change timestamp unless the contents change
11:28:17 <Phyx-> lol, sorry bout that and Hi lispy :)
11:28:41 <lispy> Phyx-: how's it going?
11:28:41 <ddarius> Phyx-: Concurrency is hard.  He's still in school.  Forgive him if he hasn't figured out the entire algorithm yet.
11:29:00 <Phyx-> lispy: good thanks, working on a few case studies for my manual. and you?
11:29:07 <lispy> ddarius: if I didn't know you better I wouldn't sense your sarcasm
11:29:09 <Phyx-> ddarius: lol
11:29:27 <hpaste> siracusa annotated “Whre's the Bug?” with “Whre's the Bug? (redundancy removed)” at http://hpaste.org/48357#a48361
11:29:33 <lispy> Phyx-: I should be doing work-work right now but I'm procrastinating here instead :)
11:29:56 <Phyx-> lispy: it is a sunday afterall :)
11:30:15 <lispy> yes, but time waits for no coder
11:30:35 * Phyx- will never complain about someone else's documentations ever again. This stuff is a lot of work
11:30:36 <dmwit> [l | l <- xs, l == True] === [l | l <- xs, l]
11:30:39 <lispy> preflex: seen pastorn
11:30:39 <identity_> Eduard_Munteanu: http://codepad.org/wR4LGLk2
11:30:40 <preflex>  pastorn was last seen on #haskell 6 days, 22 hours, 3 minutes and 29 seconds ago, saying: gwern: ^^^
11:30:44 <identity_> Your function doesn't quite work
11:30:59 <dmwit> foo `mod` 2 == 0 === even foo
11:31:04 <identity_> But in reality, you would just use filter
11:31:11 <Phyx-> lispy: hehehehe, I know all about that. But 2 more weeks and vacation \o/
11:31:18 <ddarius> Again, pardidade = foldl' (/=) True
11:31:23 <lispy> Phyx-: \o/
11:31:24 <dmwit> :t find
11:31:25 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
11:31:27 <identity_> > let del e xs = filter (/= e) xs in del 3 [2,3,3,4,5,3]
11:31:29 <lambdabot>   [2,4,5]
11:31:39 <dmwit> :t findAll
11:31:40 <lambdabot> Not in scope: `findAll'
11:31:43 <dmwit> :t findIndices
11:31:44 <lambdabot> forall a. (a -> Bool) -> [a] -> [Int]
11:31:57 <ddarius> "findAll" would be filter
11:32:06 <dmwit> Yes, I realized that shortly after asking for it. =P
11:39:35 <ben> it's blowing my mind that to feed stuff from an enumerator to an iteratee you say iteratee >>= enumerator instead of the other way around
11:40:03 <kmc> C O N T I N U A T I O N S
11:40:04 <danharaj> :t (=<<)
11:40:05 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
11:40:26 <kmc> sorry i really like that meme
11:40:32 <danharaj> it was a clever use
11:41:04 <danharaj> I still don't have an intuition for continuations :\
11:41:05 <cmccann> ben, if it helps, keep in mind that the whole deal with iteratees is that the data source is the "active" part, while the iterative loop is passive and only reacts to the data it's handed incrementally
11:41:36 <ben> cmccann: That makes it even worse, why is the active part at the right side of the "take the result from the computation on the left and then..." operator
11:42:03 <danharaj> ben: because monads are not 'take the result...'
11:42:24 <danharaj> >>= is substitution
11:42:48 <danharaj> in some monads it means 'take the result and substitute it...'
11:44:05 <ben> Oh dear, substitution? I've never thought of it that way.
11:44:24 <cmccann> ben, think about what it does with lists
11:44:35 <ben> Crazy things
11:44:39 <danharaj> with lists it subs in every element of the list
11:44:43 <ben> yeah
11:44:51 <cmccann> it takes elements from a list, uses them to generate a new list, then fills the new lists in place of the original elements, concatenating them down into a single list
11:45:51 <cmccann> IIRC substitution of elements of a structure actually ties pretty directly to the mathematical structures involved
11:45:56 <ben> That seems like a funny way of describing it
11:46:10 <cmccann> so unlike most "a monad is ____" things the substitution analogy tends to hold together pretty well
11:46:13 <danharaj> well you know how Monads are used to define DSL's?
11:46:24 <ben> "overloading the semicolon"
11:46:41 <kmc> monads are trees with grafting?
11:46:49 <danharaj> Botany!
11:46:53 <syntaxfree> another monad tutorial is born.
11:46:59 <kmc> that's one of the better "analogies" i've heard
11:47:03 <kmc> since it's not really an analogy
11:47:10 <kmc> (there's already a tutorial on that premise)
11:47:14 <syntaxfree> writing  a monad tutorial is a rite of passage. it's the "hello world' of the haskell world.
11:47:15 <cmccann> kmc, I think grafting trees is actually some sort of free monad
11:47:17 <danharaj> Isn't it exactly correct for free monads?
11:47:20 <danharaj> yeah.
11:47:23 <companion_cube> now i want to see how would C++ be with "operator;" overloading
11:47:28 <kmc> cmccann, damn you; i was just about to say that ;)
11:47:31 <cmccann> heh
11:47:47 <ben> okay mathchat
11:47:49 <kmc> you can write the free monad as a GADT
11:47:50 <ben> i'm outta here
11:47:53 <kmc> and i guess it looks like a tree
11:47:54 <ben> thanks for the help :)
11:48:04 <danharaj> I think explaining the Identity monad, then the List monad, then free monads is a good way of getting used to them.
11:48:08 <kmc> maybe you need something more
11:48:35 <cmccann> kmc, free monads are pretty simple, they're just nesting the functor inside itself
11:48:47 <cmccann> so if the functor can have multiple elements, you get a tree by definition
11:48:51 <kmc> lists are the free monoid but you need more than mempty and mappend to make them useful
11:48:54 <kmc> namely, you need (:)
11:49:03 <kmc> right ok
11:49:07 <kmc> there's a free monad for each functor
11:49:25 <Eduard_Munteanu> identity_: wait, why did you show me that?
11:49:35 <cmccann> kmc, that's because the elements of the free monoid are singleton lists, so you need something extra to work with values directly
11:49:41 <identity_> Eduard_Munteanu: What?
11:49:54 <identity_> Eduard_Munteanu: oh, meant to highlight electronplus
11:49:54 <kmc> hmm actually i lied
11:49:56 <Eduard_Munteanu> < identity_> Eduard_Munteanu: http://codepad.org/wR4LGLk2
11:49:57 <kmc> you don't need (:)
11:49:57 <identity_> or whatever his name was
11:49:59 <Eduard_Munteanu> Ah :)
11:50:06 <kmc> you just need those singleton lists
11:50:11 <cmccann> kmc, looking at it in terms of the free monoid (:) is just a shorthand for creating a singleton list, then appending it at the front
11:50:19 <kmc> x:xs = [x] `mappend` xs
11:50:19 <kmc> yeah
11:50:22 <identity_> Seems he left before I said it and I didn't notice, heh.
11:50:33 <danharaj> @djinn a -> ((a -> b -> b) -> b -> b)
11:50:34 <lambdabot> f a b = b a
11:51:16 <danharaj> @djinn a -> ((a -> b -> b) -> b -> b) -> ((a -> b -> b) -> b -> b
11:51:16 <lambdabot> Cannot parse command
11:51:30 <danharaj> @djinn a -> ((a -> b -> b) -> b -> b) -> ((a -> b -> b) -> b -> b)
11:51:31 <lambdabot> f a b c d = b (\ _ e -> e) (c a d)
11:51:40 <danharaj> Is that cons? o.o
11:51:55 <kmc> heh
11:52:05 <kmc> don't think you can make djinn give you cons
11:52:10 <kmc> it's free to say cons x xs = xs
11:52:17 <danharaj> that's true.
11:52:25 <danharaj> I have to specify that cons is injective
11:52:53 <cmccann> I think djinn tries to use all arguments when possible
11:53:17 <cmccann> but obviously you can't guarantee anything when there's more than one possible answer
11:53:25 <Eduard_Munteanu> @free (:)
11:53:26 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
11:53:57 <Eduard_Munteanu> @. free type (:)
11:53:58 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
11:54:13 <Eduard_Munteanu> Grr.
11:54:22 <Eduard_Munteanu> I always forget how to use it properly.
11:54:24 <danharaj> well let's see
11:54:38 <danharaj> c a d is folding with the singleton list, no?
11:56:22 <hpc> @free (:) :: a -> [a] -> [a]
11:56:22 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
11:56:31 <danharaj> I think djinn gave a function that ignores the rest of the list
11:57:45 <danharaj> :t f x xs g y = g x (xs g y)
11:57:47 <lambdabot> parse error on input `='
11:58:01 <hpc> :t let f x xs g y = g x (xs g y) in f
11:58:02 <lambdabot> forall t t1 t2 t3. t -> ((t -> t1 -> t2) -> t3 -> t1) -> (t -> t1 -> t2) -> t3 -> t2
11:58:37 <danharaj> :t (\(x :: a) xs (g :: (a -> b -> b)) (y :: b) -> g x (xs g y))
11:58:39 <lambdabot>     A pattern type signature cannot bind scoped type variables `a'
11:58:39 <lambdabot>       unless the pattern has a rigid type context
11:58:39 <lambdabot>     In the pattern: x :: a
11:59:05 <hpc> might wanna mess with that in your own ghci
11:59:09 <danharaj> yeah.
11:59:13 <hpc> :P
12:01:39 <danharaj> Why is the type more general than I expected.
12:03:25 <danharaj> @djinn (a -> c) -> ((a -> b -> b) -> b -> b) -> ((c -> b -> b) -> b -> b)
12:03:25 <lambdabot> f a b c d = b (\ e -> c (a e)) d
12:03:30 <danharaj> yay map?
12:10:06 <develhevel> howto convert string to int?
12:10:22 <sipa> read
12:10:35 <dmwit> reads
12:10:54 <sipa> > (read "25") :: Int
12:10:55 <lambdabot>   25
12:12:02 <dmwit> > (reads "error" :: [(Int, String)], reads "error" :: Int)
12:12:03 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:12:04 <lambdabot>         against inferred type ...
12:12:09 <dmwit> > (reads "error" :: [(Int, String)], read "error" :: Int)
12:12:10 <lambdabot>   ([],*Exception: Prelude.read: no parse
12:13:21 <Tomsik> > reads "1234" :: [(Int, String)]
12:13:22 <lambdabot>   [(1234,"")]
12:14:03 <dmwit> > reads "1234 and then an error" :: [(Int, String)]
12:14:04 <lambdabot>   [(1234," and then an error")]
12:14:22 <dmwit> > scanf "%d" "1234"
12:14:23 <lambdabot>   Not in scope: `scanf'
12:14:30 <dmwit> Ah well, that was too much to hope for. =P
12:14:36 <develhevel> ok thx, and when i convert it back to int i get from a 4: 4.0 how to get just a 4?
12:14:45 <develhevel> i convert back with show
12:15:04 <dmwit> Sounds like you're using show on a Double or Float.
12:15:18 <dmwit> Use floor, ceiling, or round first to get an Int.
12:15:25 <dmwit> > (show 4.0, show (round 4.0))
12:15:26 <lambdabot>   ("4.0","4")
12:15:35 <dmwit> > printf "%0.0f" 4.0
12:15:36 <lambdabot>   Ambiguous type variable `a' in the constraints:
12:15:36 <lambdabot>    `Text.Printf.PrintfType ...
12:15:42 <dmwit> > printf "%0.0f" 4.0 :: String
12:15:43 <lambdabot>   "4"
12:16:04 <develhevel> i make read onthx floor helped :)
12:17:23 <JuanDaugherty> http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html
12:21:26 <kmc> yes i'm definitely going to "make a strategic decision about what programming language should be adopted" based on some web search statistics
12:21:38 <dons> hehe
12:22:02 <ben> for the last few years of so I haven't seen the tiobe index mentioned without someone blowing up about how useless its methodology is
12:22:05 <ben> i'm disappoitned
12:22:29 <k0ral> oh, following a GHC upgrade, I'm told to unregister and reinstall all cabal packages
12:22:40 <JuanDaugherty> revealing nonetheless, more than 60% is java and dialects of C
12:22:44 <k0ral> I remember I had to do this once
12:22:57 <k0ral> is there a one-liner to do it ?
12:23:04 <dons> http://langpop.com/ ; https://github.com/languages/Haskell
12:24:38 <ben> Haskell is basically not present on craigslist
12:24:40 <ben> this must be rectified
12:25:22 <cmccann> dons, the discussion site results are pretty amusing there
12:27:20 <dons> doesn't have stackoverflow does it?
12:27:29 <dons> should include the language subreddits too :)
12:28:17 * osfameron reads an article about keyword arguments, and wonders why they seem to essentially not be needed in Haskell
12:28:18 <cmccann> dons, doesn't look like it has SO, which is probably really unfair to Scala
12:28:44 <osfameron> I suppose you get the same effect by designing better APIs (functions and combinator libraries)
12:28:52 <danharaj> isn't this one of the most active language channels on this network?
12:28:53 <ben> C++ still leads on ltu, that's amazing
12:29:12 <cmccann> danharaj, according to the site dons linked, yes
12:29:24 <cmccann> danharaj, a bit behind Python and just ahead of C++
12:29:26 <trygvis> ben: ltu?
12:29:32 <cmccann> Lambda the Ultimate
12:29:34 <danharaj> cmccann: And a better community than bouth ;)
12:29:36 <trygvis> ah
12:29:57 <ddarius> osfameron: You can pass a record to sort of get the effect, but really it's better to make small, composable pieces rather than a monolithic Make-My-Specific-Foo.
12:30:25 <cmccann> osfameron, also keyword arguments don't really mesh well with currying everything by default
12:31:01 <JuanDaugherty> kmc, absolutely agree, popularity doesn't mean shit
12:31:04 <ddarius> osfameron: E.g. instead of circle(center: (1,1), radius: 5, color: Green), have setColor Green (translate (1,1) (scale 5 unitCircle)).
12:31:08 <osfameron> ddarius: yeah.  I was thinking of functions as well as constructors, guess it applies to both
12:31:51 <osfameron> cmccann: yeah, that's a really interesting point
12:31:56 <kmc> JuanDaugherty, unfortunately it does matter
12:32:03 <kmc> popularity matters a lot business-wise
12:32:08 <kmc> but it's not the only thing which matters
12:32:10 <osfameron> I keep coming across things that mesh really well together in Haskell
12:32:19 <JuanDaugherty> but confirms my impression that a good part of the total haskel comm is here
12:32:31 <kmc> i more object to the use of search rankings as a proxy for popularity
12:32:35 <cmccann> popularity matters up to a point, it helps to have people writing lots of libraries and stuff
12:32:44 <osfameron> that might seem annoying/odd (coming from the programming background I came from) but that are absolutely essential when you put them together
12:32:53 <ksf> it shouldn't really be too hard to write gobjects in haskell, should it?
12:32:56 <kmc> maybe Perl has more searches because it's more confusing
12:33:00 <ddarius> JuanDaugherty: A good part of the active community, though the mailinglists have more people registered than come here, and not everyone here is registered.
12:33:14 <ksf> all the bits and pieces like layouting the structs etc are in place, there's just glue missing.
12:33:18 <danharaj> maybe people don't search Haskell as much because they can get their answers quickly on irc or stackoverflow :p
12:33:21 <ddarius> JuanDaugherty: I suspect there's a fairly significant "silent" community, because I keep seeing stuff come out of nowhere.
12:33:39 <kmc> i think "the community" can only be defined through shared communication.  the set of all people who use Haskell is not a "community"
12:33:43 * cmccann also gets the impression that the Haskell community has more actual activity per capita than other communities
12:34:07 <cmccann> in that we seem to get more people who are REALLY enthusiastic, and fewer who are just passively sorta interested
12:34:08 <ben> further, more actual activity per capital, I'd bet
12:34:10 <dons> we're super productive :)
12:34:11 <kmc> i'm really sick of how the word "community" has been devalued by politicians
12:34:11 <danharaj> cmccann: If that's the case it's because we have some truly prolific members.
12:34:17 * danharaj cough dons cough
12:34:52 <cmccann> danharaj, yes I think that dons is like 12% of the entire Haskell community, measured by aggregate output :P
12:34:59 <dons> i'm somewhat productive; but also i just spend a lot of time on things, and automating things.
12:35:02 <osfameron> danharaj: the stackoverflow point is also relevant to Perl - we have perlmonks and other forums already, so unsurprisingly, the "community" hasn't migrated over there wholesale
12:35:11 <dons> so you know, 10,000 hours over 7 years stuff.
12:35:15 <danharaj> osfameron: makes sense.
12:35:38 <cmccann> dons, you've also been pretty exclusively doing Haskell stuff for quite a while, right? that also helps
12:35:49 <cmccann> rather than having irons in the fire with other languages and such
12:36:22 <miasma> 10000 hours over 7 years sounds like a fulltime job
12:36:30 <cmccann> osfameron, I think it supports your argument that Scala also has a relatively large presence on SO vs. what you might expect otherwise
12:36:51 <ddarius> > 52*40*7
12:36:52 <lambdabot>   14560
12:37:18 <copumpkin> dons: any idea what's going on with the meetup?
12:37:31 <dons> hang on. let me fire up an smt solver...
12:37:42 <copumpkin> lol
12:38:00 <copumpkin> seems more like an optimizer
12:38:10 <copumpkin> and your objective function needs to give weight to each of us being there
12:38:13 <copumpkin> ;)
12:38:48 <kmc> hehe
12:38:56 <kmc> i used a SMT solver to get points at Nerd Pub Trivia
12:39:01 <copumpkin> oh yeah?
12:39:04 <kmc> i could have used a straightforward tree search, though
12:39:07 <kmc> will have to blog about that
12:39:14 <kmc> copumpkin, yeah, btw you all should come to the next one
12:39:16 <kmc> team #haskell
12:39:22 <kmc> http://www.nerdpubtrivia.com/
12:40:04 <copumpkin> kmc: oh, cool
12:40:26 <copumpkin> it doesn't way when the next one is though
12:44:56 <dsj36> hi all, I've got a haskell data structure question
12:45:05 <dsj36> I'm trying to build a dictionary from a set of strings
12:45:09 <dylukes> don't ask to ask :P
12:45:13 <dsj36> with efficient membership and prefix checking
12:45:15 <dsj36> :)
12:45:20 <danharaj> sounds like a trie
12:45:25 <dsj36> yeah I tried doing that
12:45:29 <dsj36> with the children as a list
12:45:32 <dsj36> but it's too slow
12:45:37 <dsj36> I was thinking of going for an array
12:45:39 <dylukes> radix tree?
12:45:58 <dylukes> Not really a good "functional" structure though
12:45:59 <dsj36> what's the idea behind that
12:46:06 <dylukes> it's just a condensed trie.
12:46:27 <dsj36> can you insert one at a time
12:46:35 <dylukes> It _is_ a trie though.
12:46:45 <dylukes> For what you're saying, an optimized trie sounds best :\
12:47:04 <dsj36> yeah
12:47:07 <dylukes> what's your implementation, maybe that's what's too slow?
12:47:12 <dsj36> it's the optimized part that gets me :)
12:47:26 <dylukes> I haven't ever implemented a trie, I should do that.
12:47:29 <dsj36> data PFTree = Node Bool [(Char, PFTree)]
12:47:35 <kmc> copumpkin, they're about once a month
12:47:43 <kmc> if at first you don't succeed, trie again
12:47:47 <copumpkin> I see
12:47:49 <copumpkin> cool
12:48:00 <dsj36> the bool signals whether a word ended on that node
12:48:03 <ddarius> dsj36: If you are getting actual Unicode code points, you probably want to use a Map, say, rather than a list of pairs.
12:48:36 <ddarius> dsj36: That's also a bad way of signalling the end, at least from a correctness standpoint.
12:48:48 <dsj36> what would you recommend?
12:48:57 <ddarius> Well, maybe not.
12:49:16 <JuanDaugherty> somebodies trie pkg i guess
12:49:29 <aavogt> what a data structure like    Map (Int,Int,Int) Unique, but allows you to more efficiently find the Uniques right next to one of interest?
12:49:44 <aavogt> *is
12:49:52 <kmc> k-d tree?
12:50:08 <dsj36> kd-tree for strings?
12:50:24 <kmc> i meant for aavogt
12:50:42 <dsj36> ah okay
12:51:00 <dsj36> yeah I'll definitely try replacing the lists with maps and see how that improves
12:51:32 <dsj36> thanks for the tips
12:52:08 <aavogt> kmc: using a mutable array for that data is roughly 5 times faster than Data.Map
12:52:29 <kmc> er, is your Int^3 space sparse or dense?
12:52:37 <kmc> if it's dense then yes a flat 3D array is fine
12:52:52 <ddarius> It would be slightly more efficient to unpack the bool.  It may or may not be more efficient to encode the bool into two constructors for the type.
12:52:52 <kmc> aavogt, did you try 3 nested IntMap?
12:52:54 <aavogt> it starts out dense, but then some points become uninteresting (so could be deleted)
12:53:04 <kmc> what's the range of those Ints?
12:53:24 <kmc> you could bake them into a single Int
12:53:26 <aavogt> no more than 1 - 100
12:53:32 <kmc> injectively, or as a hash
12:53:33 <kmc> oh, yeah
12:53:44 <trygvis> if I'm using Debug.Trace, is it a way to turn it off without removing all the trace statements?
12:53:56 <kmc> IntMap keyed on a*10000 + b*100 + c
12:54:09 <kmc> trygvis, replace them all with 'myTrace'
12:54:15 <trygvis> my test tool depend on the text from stdout which I'd like to run, just without the output
12:54:25 <kmc> then write 'myTrace = trace' or 'myTrace _ = id' according to taste
12:54:35 <trygvis> thanks
12:54:46 <ddarius> Debug.Trace should be writing to stderr.
12:55:02 <trygvis> it is, the test tools asserts stderr too
12:55:05 <aavogt> you could avoid the renaming if you just don't import Debug.Trace
12:55:19 <trygvis> clever!
12:55:30 <aavogt> (or do that qualified, if you need the original definition)
12:55:48 <ddarius> Or just have a MyTrace module.
13:00:45 <nand`> I'm new to Haskell (started two days ago) and am attempting to solve Euler Problem #5 recursively. So far, however, both solutions I tried, while giving the correct result, required significantly longer than 1 minute to compute (for comparison, an iterative implementation using nested for loops in C took about 3 seconds). I'm trying to figure out where my problem lies, and what I could do to solve it. Any hints/tips? Code: http://pastebin.com/rMCv0
13:01:02 <nand`> I think the root cause of the issue is that I'm recursing through 20 function calls for each iteration, but I don't know how to solve it any more efficiently
13:03:05 <dsj36> I think your link is bad: I don't see anything in the pastebin
13:03:29 <nand`> It works fine for me. I'll try pasting it again in case it got cut off: http://pastebin.com/rMCv03zu
13:03:31 <mauke> The paste rMCv03zu has been copied to http://hpaste.org/48366
13:05:13 <ddarius> mauke: Do you have some kind of script?
13:05:25 <aavogt> or is mauke just really dedicated/fast?
13:05:56 <shachaf> This is mauke's IRC client. It happens in a few channels.
13:06:27 <ksf> nand`, you're re-calculating everything all the time.
13:06:29 <shachaf> nand`: Brute force is against the spirit of that sort of problem.
13:06:35 <ksf> compare it with
13:06:59 <ksf> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
13:07:03 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:07:32 <aavogt> you have to know that numbers have unique prime factorizations
13:07:33 <ksf> ...which has the same complexity as an iterative solution: you only calculate each fib once
13:07:36 <nand`> ksf: But isn't that sort of the point? For each iteration in the sequence, I have to check against all 20 numbers all the time
13:07:59 <ksf> well.
13:08:14 <ksf> I don't know the problem, I just told you why your solution is slow.
13:08:24 <dsj36> nand`: Another way to look at it is to think why can't you just use 20 factorial as the minimal number that's divisible by 1 - 20
13:08:30 <nand`> shachaf: I don't know enough about mathematics to deduce the answer using pure reasoning. My initial thought was that it might be equivalent to the factorial of 20, since (1 * 2 * 3...n) is evenly divisible by all numbers from 1 to n
13:08:35 <nand`> but it appears that is not the smallest solution
13:09:20 <dsj36> `nand: you duplicate a bunch of factors. if it's divisible by 16, it's also divisible by 8, 4, and 2
13:09:23 <shachaf> nand`: Project Euler is probably about mathematics much more than programming; trying to do it through complete brute force is pointless.
13:09:23 <nand`> For example, the factorial of 10 is 3628800, but the smallest number divisible by all numbers up to 1 is 2520
13:09:43 <nand`> dsj36: But doesn't the disjunction in there stop execution as soon as a true condition is met?
13:09:47 <nand`> Or is this not true in Haskell?
13:10:06 <Nimatek> I just though.. semi-bruteforce:
13:10:07 <nand`> I was under the belief that True && f does not compute f
13:10:09 <Nimatek> > head [x | x <- [19*20,2*19*20..], and [x `mod` n == 0 | n <- [2..18]] ]
13:10:13 <lambdabot>   mueval-core: Time limit exceeded
13:10:17 <Nimatek> well almost :p
13:10:37 <ksf> > True && error "no."
13:10:39 <lambdabot>   *Exception: no.
13:10:44 <nand`> Oh
13:10:47 <ksf> > True || error "no."
13:10:48 <lambdabot>   True
13:10:58 <ksf> > False && error "no."
13:11:00 <lambdabot>   False
13:11:10 <nand`> There we go, then
13:11:30 <nand`> It isn't computing non-needed numbers since it stops execution as soon as it reaches a single False
13:12:35 <JuanDaugherty> http://www.haskell.org/haskellwiki/Euler_problems/1_to_10
13:12:51 <shachaf> JuanDaugherty: Come on, the point of this problem isn't to be given a solution.
13:13:09 <JuanDaugherty> > foldr1 lcm [1..20]
13:13:10 <lambdabot>   232792560
13:13:33 <danharaj> > error "derp" || True
13:13:35 <lambdabot>   *Exception: derp
13:13:47 <sshc> What extension do I need to define the type alias "type Foo = [a]", so that "Bar :: [a] -> Quux" is equivalent to "Bar :: Foo -> Quux"?
13:13:58 <cmccann> danharaj, (||) is not commutative in the presence of _|_ :[
13:14:10 <dmwit> sshc: I don't think you can.
13:14:18 <dmwit> No extension does that.
13:14:20 <Twey> sshc: Isn't that already the case?
13:14:35 <augur> what are some good papers on applying category theory to functional programming? like full on hardcore here are some applications stuff
13:14:37 <cmccann> sshc, do you mean without having the type variable "a" bound anywhere?
13:14:43 <Twey> Oh, because it's not bound
13:14:47 <dmwit> Twey: I hope not, or else there's something weird about type variable scoping.
13:14:52 <nand`> I guess I'll put the problem on hold until I understand more about how Haskell works internally and how to optimize, for now I'll just use the built-in function "lcm" then
13:14:55 <nand`> Did not know of its existence
13:14:57 <Twey> Okay :þ
13:15:09 <shachaf> nand`: No, don't use "lcm", that defeats the purpose.
13:15:16 <shachaf> nand`: This isn't really an issue of "knowing enough about mathematics". If you understand the problem you probably know enough to figure out with pencil and paper.
13:15:26 <ksf> augur, codensity?
13:15:29 <shachaf> At least write "lcm" yourself rather than using the library function.
13:15:37 <augur> ksf: you're codense :|
13:15:39 <augur> ksf: whats that now
13:15:41 <ksf> there's some rather categorical posts about it.
13:16:05 <nand`> shachaf: But I'm putting that on hold because all of my solutions require inane amounts of execution time
13:16:13 <ksf> augur, try http://comonad.com/reader/category/category-theory/
13:16:20 <JuanDaugherty> why don't they make clear that that the haskell solutions are just tries on that page?
13:16:47 <augur> ksf: this blog looks good :o
13:17:02 <shachaf> nand`: Well, if you don't understand how lcm works, you're not allowed to use it. :-)
13:17:10 <ksf> start with http://comonad.com/reader/2011/free-monads-for-less/
13:17:20 <ksf> ...or, rather, the paper he links in the beginning.
13:17:23 <shachaf> nand`: Just get a piece of paper and think about factors and prime numbers and what not.
13:17:31 <nand`> shachaf: I could implement it rather easily using Euclid's algorithm but that also defeats the purpose
13:17:51 <aavogt> unexpectedly using MonadRandom made my code run faster :)
13:17:51 <Mene> pl \a b c -> a*b+2+c
13:17:58 <shachaf> It doesn't if you understand the algorithm!
13:18:03 <augur> ksf: hmm
13:18:04 <shachaf> (And also why lcm is appropriate here.)
13:18:12 <augur> thanks to this blog i just realized something interesting
13:18:27 <JuanDaugherty> oh, sorry see that is correct
13:18:36 <augur> hylomorphisms are to their virtual structures as feynman diagrams are to virtual particles
13:18:50 <ksf> that sometimes abstract nonsensists just take what some hacker did and say it's abstract nonsense?
13:18:53 <JuanDaugherty> (the answer at euler was for 1..10)
13:19:00 <JuanDaugherty> > foldr1 lcm [1..10]
13:19:02 <lambdabot>   2520
13:19:22 <cmccann> augur, if you think that's interesting you should read some of John Baez's stuff
13:19:32 <augur> cmccann: i have and didnt understand it at all
13:19:32 <cmccann> since particle physics + category theory was basically his thing for a while
13:19:34 <ksf> 99% of all category theory was discovered by drawing random diagrams and then figuring out what they mean.
13:19:34 <cmccann> hahaha
13:19:47 <augur> ksf: lol
13:20:03 <dylukes> ksf: If you extrapolate category theory into three dimensions, what's inside the objects?
13:20:05 <cmccann> ksf, kind of like how any sufficiently polymorphic haskell function that type checks does something useful, even if you don't know what
13:20:08 <dylukes> Do the objects have finite boundaries?
13:20:18 <dylukes> (that should keep the CT guys busy for a while >.>)
13:20:30 <cmccann> dylukes, wrong direction, you extend it by adding more arrows between arrows
13:20:33 <ddarius> dylukes: There are already higher dimensional categories.
13:20:33 <cmccann> then arrows between those arrows
13:20:41 <dylukes> This sounds like Kierkegaard.
13:20:47 <cmccann> basically it's arrows all the way up
13:20:49 <dylukes> The self is the relation between the self and the self, etc.
13:20:55 <Mene> > pl \a b c -> a*b+2+c
13:20:56 <lambdabot>   <no location info>: parse error on input `\'
13:21:04 <Mene> >pl \a b c -> a*b+2+c
13:21:20 <magicman> @pl \a b c -> a*b+2+c
13:21:21 <lambdabot> ((+) .) . flip flip 2 . ((+) .) . (*)
13:21:30 <dylukes> pl does what?
13:21:37 <ksf> something pointless.
13:21:41 <ddarius> @help pl
13:21:41 <lambdabot> pointless <expr>. Play with pointfree code.
13:21:48 <dylukes> heh...
13:21:50 <Mene> http://www.haskell.org/haskellwiki/Pointfree#Tool_support
13:21:58 <Mene> @pl \a b c -> a*b+2+c
13:21:59 <cmccann> dylukes, rewrites functions to have no variable bindings basically
13:21:59 <lambdabot> ((+) .) . flip flip 2 . ((+) .) . (*)
13:21:59 <shachaf> @pl \d e k l s u y -> d y l u k e s
13:22:00 <lambdabot> ((((flip . (flip .)) .) .) .) . flip . ((flip . ((flip . (flip .)) .)) .) . flip . ((flip . (flip .) . flip) .) . flip
13:22:16 <ksf> @pl \a c b -> a*b+2+c
13:22:16 <lambdabot> flip . ((+) .) . flip flip 2 . ((+) .) . (*)
13:22:22 <Mene> ^^
13:22:24 <dylukes> @pl \a b c d -> d c b a
13:22:24 <lambdabot> flip (flip . (flip .) . flip (flip . flip id))
13:22:24 <ksf> @pl \b c a -> a*b+2+c
13:22:25 <lambdabot> flip . ((+) .) . flip flip 2 . ((+) .) . (*)
13:22:26 <cmccann> it's a tool for automatically making your code more elegant
13:22:33 <dylukes> "more elegant"
13:22:34 <ksf> @pl \b a c -> a*b+2+c
13:22:34 <lambdabot> ((+) .) . flip flip 2 . ((+) .) . (*)
13:22:35 <cmccann> yes
13:22:40 <ksf> @pl \c a b -> a*b+2+c
13:22:40 <lambdabot> flip (flip . ((+) .) . flip flip 2 . ((+) .) . (*))
13:22:43 <cmccann> where elegance is defined as being point-free
13:22:44 <ksf> @pl \c b a -> a*b+2+c
13:22:44 <dylukes> point free can be more elegant sometimes, or usually
13:22:45 <lambdabot> flip (flip . ((+) .) . flip flip 2 . ((+) .) . (*))
13:22:51 <dylukes> that definition of elegant is tenuous...
13:22:55 <shachaf> Lambda is the least elegant feature of Haskell.
13:23:06 <cmccann> dylukes, yes, I'm joking :P
13:23:20 <cmccann> especially since @pl tends to produce absolutely horrendous pointfree expressions in some cases
13:23:24 <shachaf> It's worse than the Num hierarchy or records or whatever you (dis)like.
13:23:27 <Mene> elegant+ readable-
13:23:44 <dylukes> the Num hierarchy .__.
13:23:47 <dylukes> *shivers*
13:23:55 <dylukes> definitely, if theres ever a Haskell 2, that needs to be fixed
13:24:02 <dylukes> as well as the Monad/Applicative/Functor one...
13:24:15 <dylukes> Comonads/etc could be stdlib'd...
13:24:16 <dylukes> etc
13:24:24 <aavogt> the situation isn't so bad
13:24:30 <ksf> @pl \g a t e m a n -> n a m e t a g
13:24:30 <dylukes> it's still quite awkward.
13:24:31 <lambdabot> const . (((const .) .) .) . flip (flip . ((flip . (flip .)) .) . flip flip id . ((flip . (ap .)) .) . flip (flip . (flip .) . flip (flip . flip (join id))))
13:24:33 <cmccann> more important than fixing hierarchies is making it less impossible to refactor such hierarchies
13:24:46 <cmccann> otherwise it'll still suck when the next version gets something else wrong
13:24:54 <dylukes> aggressive deprecation
13:24:54 <dylukes> gogogo
13:25:00 <dmwit> Hm, the Haskell encoding.
13:25:12 <ksf> we could make a library out of those.
13:25:20 <dmwit> encode plaintext = "?pl \a b c ... z -> " ++ intercalate " " plaintext
13:25:38 <ksf> that'd be flipgfedcba
13:25:52 <monochrom> haha great encoding :)
13:26:15 <cmccann> dmwit, I expect not all phrases would be well-typed though
13:26:17 <augur> ksf: do you know anything good on optimization problems, and when problems are necessarily or unnecessarily optimization problems?
13:26:19 <dmwit> decode ciphertext = eval $ "(" ++ ciphertext ++ ") (\"a\" ... \"z\")"
13:26:30 <ksf> augur, codensity is an optimisation
13:26:31 <dmwit> cmccann: hm, that's true
13:26:36 <augur> ksf: :o
13:26:41 <ksf> his three blog posts are about that.
13:26:48 <augur> ksf: im reading the first now
13:26:54 <ksf> refactors a monad so that all binds bind to the right.
13:27:14 <augur> im just trying to understand the nature of optimization problems in a general way
13:27:39 <dmwit> cmccann: Ah, I was thinking of this, anyway:
13:27:41 <augur> sort of like.. figuring out ways to describe them abstractly, and ways to know when something is actually an optimization problem or not
13:27:44 <ksf> that's... NP complete, I think.
13:27:48 <shachaf> @@ @pl @run let abc = intercalate " " $ map (:[]) ['a'..'z'] in text $ "\\" ++ abc ++ "->" ++ reverse abc
13:27:51 <lambdabot>  (line 1, column 81):
13:27:53 <lambdabot> unexpected end of input
13:27:55 <lambdabot> expecting white space or simple term
13:28:00 <dmwit> encode stuff = "?pl \func a b c ... z -> func " ++ intercalate " " stuff
13:28:14 <augur> ksf: sort of in the same way you can talk about when something is and isnt a fold, and describe folds abstractly, etc.
13:28:21 <dmwit> cmccann: ...which *is* always well-typed
13:28:24 <shachaf> @@ @pl @run let abc = intercalate " " $ map (:[]) ['a'..'z'] in text $ "\\" ++ abc ++ "->" ++ reverse abc -- Hmm.
13:28:26 <lambdabot>  (line 1, column 81):
13:28:28 <lambdabot> unexpected end of input
13:28:30 <lambdabot> expecting white space or simple term
13:28:31 <shachaf> It works in /msg.
13:28:33 <ksf> augur, try http://scholar.google.de/scholar?cluster=12354344616245364257&hl=de&as_sdt=0&as_vis=1
13:28:35 <sam2> is newtype a keyword?
13:28:40 <shachaf> It is.
13:28:45 <dmwit> sam2: yes
13:28:50 <shachaf> It declares a new type.
13:28:53 <sam2> what exactly does it do?
13:29:16 <sam2> I am a little confused about making new types
13:29:20 <sam2> so...
13:29:22 <dmwit> ?pl \func a b c d e f g h i j k l m n o p q r s t u v w x y z -> d m w i t i s d e a d
13:29:26 <lambdabot> const (const . const . ((const .) .) . ((const .) .) . ((const .) .) . (((const .) .) .) . (((const .) .) .) . (((const .) .) .) . ((((const .) .) .) .) . ((((const .) .) .) .) . ((((const .) .) .) .
13:29:26 <lambdabot> ) . ((((const .) .) .) .) . ((((const .) .) .) .) . ((((((const .) .) .) .) .) .) . ((((((const .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((
13:29:26 <lambdabot> const .) .) .) .) .) .) .) . flip ap id . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . flip (flip . (flip .) . ((flip
13:29:26 <lambdabot> .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . join (flip . (flip .) . ((flip .) .) . (((flip
13:29:26 <lambdabot> .) .) .) . ((((flip .) .) .) .) . ((flip .) .) . (((flip .) .) .) . flip ap id . (flip .) . ((flip .) .) . (((flip .) .) .) . ((flip .) .) . flip . (flip .))))
13:29:28 <lambdabot> optimization suspended, use @pl-resume to continue.
13:29:33 <dmwit> Oh dear, I'm sorry.
13:29:36 <cmccann> hahahaha
13:29:49 <augur> ksf: my main mental analogy is that theres this literature on dependent types and constructing types from descriptions in such a way that you can define fold once and for all and you get it for every type automatically
13:29:51 <ksf> @pl-resume
13:29:52 <dmwit> sam2: "data" is the most common way of making new types.
13:29:55 <sam2> data something = something Int
13:29:56 <sam2> for instance
13:29:57 <lambdabot> const (const . const . (((const . const . const) .) .) . (((const .) .) .) . (((const .) .) .) . (((const .) .) .) . ((((const .) .) .) .) . ((((const .) .) .) .) . ((((const .) .) .) .) . ((((const
13:29:57 <lambdabot> .) .) .) .) . ((((const .) .) .) .) . ((((((const .) .) .) .) .) .) . ((((((const .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .)
13:29:57 <lambdabot> .) .) .) . join . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .)
13:29:57 <lambdabot>  . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . join (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .
13:29:57 <lambdabot> ) .) .) . ((flip .) .) . (((flip .) .) .) . join . (flip .) . ((flip .) .) . (((flip .) .) .) . ((flip .) .) . flip . (flip .))))
13:29:59 <lambdabot> optimization suspended, use @pl-resume to continue.
13:30:05 <dmwit> sam2: Try "data Something = Something Int" instead. =)
13:30:12 <sam2> right
13:30:13 <djahandarie> dmwit, you're dead now!
13:30:13 <parcs> @type flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip
13:30:14 <augur> ksf: and im curious if there are similar models for optimization
13:30:19 <sam2> so data is the same thing is newtype?
13:30:22 <dmwit> sam2: Concrete type constructors and value constructors must be capitalized.
13:30:22 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) b1. (Functor f, Functor f1) => f1 ((f (a -> b) -> a -> f b) -> b1) -> f1 b1
13:30:26 <dmwit> sam2: No, they are different.
13:30:32 <augur> sam2: data lets you define recursive types
13:30:37 <dmwit> sam2: newtype's can have only one constructor and one argument to that constructor.
13:30:44 <augur> newtype just lets you wrap an old type in a tag so you can treat it different
13:30:49 <shachaf> @wiki Newtype
13:30:49 <lambdabot> http://www.haskell.org/haskellwiki/Newtype
13:30:54 <dmwit> sam2: Also, a newtype is strict; it doesn't introduce a new bottom element.
13:31:01 <ksf> @. unpl pl \a b c d e f g h i j k l m n o p q r s t u v w x y z -> d m w i t i s d e a d
13:31:04 <parcs> @type flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip
13:31:05 <lambdabot>  Parse error at end of input
13:31:14 <augur> iinm newtype is just a type synonym with a constructor
13:31:15 <ksf> @help .
13:31:19 <lambdabot> thread killed
13:31:19 <lambdabot> . <cmd1> <cmd2> [args].
13:31:19 <lambdabot> . [or compose] is the composition of two plugins
13:31:19 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
13:31:19 <dmwit> augur: newtype can create recursive types, too, can't it?
13:31:28 <augur> dmwit: can it?
13:31:28 <dmwit> e.g. newtype Foo a = Foo (a, Foo a)
13:31:34 <shachaf> newtype Foo = Foo Foo
13:31:43 <augur> oh i see
13:31:54 <cmccann> yes, newtypes can be recursive
13:32:00 <ksf> @. unpl pl \a b c d e f g h i j k l m n o p q r s t u v w x y z -> d m w i t
13:32:01 <sam2> then Foo becomes a type?
13:32:03 <augur> well, its kind of a type synonym still
13:32:03 <lambdabot>  Parse error at end of input
13:32:11 <ksf> huh?
13:32:17 <cmccann> pop quiz, what does "newtype T = T T" represent, and what happens if you pattern match on a value of that type
13:32:17 <augur> just one for a type you didnt otherwise have a name for! :P
13:32:31 <dmwit> cmccann: It represents Void.
13:32:36 <ksf> @. @unpl @pl \a b c d e f g h i j k l m n o p q r s t u v w x y z -> d m w i t
13:32:36 <augur> cmccann: it represents a nonstandard model of the naturals.
13:32:36 <lambdabot> Plugin `compose' failed with: Unknown command: "@unpl"
13:32:36 <dmwit> When you pattern match, it infinite-loops.
13:32:40 <augur> or integers
13:32:49 <edwardk> cmccann: it is only inhabited by bottom. makes a nice void type on compilers that aren't ghc 6.12.1
13:32:55 <cmccann> dmwit, only if you recurse on the pattern match
13:32:59 <shachaf> Like GHC 7.0?
13:33:02 <cmccann> it works just fine if you only pattern match one layer
13:33:05 <edwardk> pattern matching just gets you the next layer ;)
13:33:08 <augur> dmwit: theres a nonstandard model of integers thats like that
13:33:16 <dmwit> cmccann: ...oh, wow, that's subtle.
13:33:18 <dmwit> And awesome.
13:33:27 <cmccann> where "layer" in this case means that it just ignores the argument essentially
13:33:33 <edwardk> dmwit: Data.Void is implemented that way
13:33:36 <cmccann> dmwit, yes, it surprised me at first too
13:33:37 <sam2> ok... so what does newtype Foo = Foo Foo do?
13:33:43 <dmwit> The correct answer is "nothing happens when you pattern match on it", which is, frankly, amazing.
13:33:44 <augur> sam2: we just told you!
13:33:51 <augur> :P
13:33:53 <sam2> sorry... there was so much going on...
13:33:57 <augur> well i did. its a nonstandard model of integers!
13:34:13 <edwardk> augur: no. you'd need a Z case.
13:34:14 <shachaf> dmwit: For example, if you derive Show, it can be shown perfectly well as "Foo (Foo ..."
13:34:22 <augur> edwardk: not in the nonstandard models
13:34:27 <monochrom> f (T x) = (). then f undefined works just fine
13:35:48 <cmccann> augur, anyway I don't think the newtype I gave represents the naturals, because it's not actually recursive
13:36:01 <augur> cmccann: let me find you this paper by boolos
13:36:20 <augur> cmccann: he talks about non-standard models where numbers are infinite towers of succ
13:36:34 <shachaf> As contrasted with data Foo = Foo !Foo, for instance.
13:36:36 <cmccann> you're probably thinking of "data T = T T" which represents some number of T constructors either terminated by _|_, or infinite
13:36:47 <augur> cmccann: maybe
13:36:56 <augur> whats the difference between that and newtype T = T T??
13:37:12 <infinity0> guys, any idea what this error means:
13:37:15 <infinity0> gitit: /usr/share/gitit-0.8/data/default.conf: hClose: user error (Pattern match failure in do expression at libraries/base/System/Event/Thread.hs:83:3-10)
13:37:19 <augur> given that they both have only one constructor
13:37:28 <dmwit> augur: For data, "undefined" and "T undefined" are distinguishable.
13:37:32 <dmwit> augur: For newtype, they're not.
13:37:33 <edwardk> i'm not sure i grok the connection between the newtype T = T T and nonstandard integer models. you can't distinguish between them. the usual non-standard model stuff would just start from some new base case as i understand it
13:37:34 <cmccann> augur, the newtype constructor is a compile-time fiction
13:37:54 <edwardk> data T = T T i can see
13:37:56 <augur> oic
13:38:05 <cmccann> edwardk, I think the data version is what he was thinking of
13:38:09 <edwardk> ah
13:38:16 <augur> edwardk: sorry, i didnt realize the finer points
13:38:21 <cmccann> the fact that newtype doesn't actually work the same way is the subtle and surprising point that I was trying to make :]
13:38:30 <ryant5000> is anyone able to run GLUT in GHCi on Linux?
13:38:32 <dmwit> cmccann++
13:38:48 <dmwit> ryant5000: Paste some sample code to try, and I'll try it.
13:38:49 <edwardk> to get Data.Void to build on ghc 6.12.1 i had to add a check for that and use data Void = Void !Void instead ;)
13:39:06 <gwern> > 70 / 1.5
13:39:07 <cmccann> edwardk, oh that reminds me, I had GHC hang on me compiling Data.Void the other day
13:39:09 <lambdabot>   46.666666666666664
13:39:10 <edwardk> as suggested by mauke
13:39:14 <augur> cmccann: i dont get the distinction then honestly but ok :D
13:39:18 <edwardk> cmccann: what version?
13:39:27 <dylukes> arghghghg
13:39:31 <dylukes> I actually *can't compile haskell*
13:39:32 <dylukes> because of this
13:39:33 <dylukes> https://gist.github.com/1047976
13:39:39 <edwardk> cmccann: and what compiler?
13:39:40 <dmwit> augur: For the newtype version, the case match in "case undefined of (T x) -> foo" gets erased!
13:39:40 <cmccann> edwardk, an older one, forget which exactly, and it only happened with optimizations active
13:39:42 <ryant5000> dmwit: do { getArgsAndInitialize ; createWindow "Test" }
13:39:43 <dylukes> happens whenever I try to link in base.
13:39:52 <ryant5000> dmwit: you'll need Graphics.UI.GLUT
13:39:53 <dmwit> augur: To just "foo[undefined/x]".
13:39:59 <edwardk> cmccann: i may have to reissue it with explicitly disabled optimizations
13:40:01 <cmccann> edwardk, I think it was GHC 6.12-ish but I'm not sure, it was on a different machine than I'm using right now
13:40:04 <augur> dmwit: hmm
13:40:05 <augur> i see
13:40:08 <augur> odd
13:40:21 <dmwit> ryant5000: Window 1
13:40:26 <ryant5000> hm
13:40:30 <ryant5000> did you need any switches for that?
13:40:34 <dmwit> nope
13:40:40 <edwardk> cmccann: ah, well, the flip from newtype to data for 6.12.x should fix that case then, if you encounter it again, lemme know and i'll do more to disable optimization
13:40:50 <ryant5000> dmwit: what OS are you on? i'm on Ubuntu 11.04
13:40:58 <edwardk> heya ryant5000, ltns
13:40:59 <augur> what does this mean: class MonadFree f m | m -> f where
13:41:06 <augur> whats the | m -> f doing?
13:41:06 <hpaste> dmwit pasted “full glut transcript” at http://hpaste.org/48372
13:41:19 <ryant5000> edwardk: yeah, although i've seen a lot of your commits to hackage :)
13:41:24 <edwardk> augur: that is a functional dependency, tells the compiler there is only one choice of f for each choice of m.
13:41:26 <cmccann> edwardk, I just unpacked the cabal package and installed it after building with no optimizations, on the assumption that Data.Void isn't doing a lot of heavy computation
13:41:26 <dmwit> ryant5000: Arch, Linux 2.6.39
13:41:35 <ryant5000> dmwit: ah
13:41:45 <augur> edwardk: ???
13:41:48 <dmwit> ryant5000: Notably, the window does not appear until I exit ghci (then it flashes and disappears).
13:42:04 <dmwit> Dunno whether that's expected behavior or not.
13:42:14 <cmccann> edwardk, I can look into it if you want but sounds like it's probably the same thing you're already aware of
13:42:23 <ryant5000> dmwit: yeah, that's not too surprising
13:42:23 <edwardk> augur: class Foo a b | a -> b  — makes it a compile time error if you try to say instance Foo Int Int — instance Foo Int Double
13:42:33 <augur> edwardk: oh i see
13:42:38 <dmwit> (I've never used GLUT.)
13:42:40 <edwardk> augur: in exchange for that once the type system has infered the type of the first argument there, it can infer the second
13:42:44 <ryant5000> dmwit: i think we've found the issue: just needed a "-lglut" on the command line
13:42:57 <edwardk> augur: so in that case the type of m, can be used to determine the type of f.
13:43:22 <ksf> dmwit, try to use freeGLUT if available.
13:43:30 <edwardk> instance MonadFree f (Free f) — since the fundep flows from Free f  to f, says that given that you know that m = Free f, you know that f = this particular choice of f. ;)
13:43:32 <ksf> the original thing is a fossil.
13:43:34 <dmwit> ksf: I'm not interested in using GLUT, either.
13:43:43 <ksf> it's a wonder it hasn't bitrotted, yet.
13:43:53 <augur> edwardk: wink wink nudge nudge
13:43:54 <dmwit> I am, however, willing to test other people's code if they're worried that they're the only one having trouble. =)
13:43:56 <ryant5000> dmwit: thanks for trying it out; maybe it's a difference between ghc 6 and 7 that the -l is needed, or maybe my GLUT is dynamically linked and yours is statically linked or something
13:43:56 <augur> o.o;
13:44:00 <ksf> dmwit, good for you.
13:45:23 <ksf> ryant5000, ghci problems aren't unheard of when using display libraries
13:45:28 <dmwit> indeed
13:45:42 <cmccann> augur, btw edwardk is probably the best person to ask about category theory stuff, since you were talking about that earlier :P
13:45:44 <dmwit> Threading is all wonky in ghci.
13:45:45 <ksf> if in doubt, just compile.
13:45:55 <augur> edwardk: so it seems!
13:46:01 <augur> him and ddarius are like CT gurus
13:46:07 <augur> edwardk: whats codensity? :D
13:46:15 <edwardk> cale: heh, it turns out that horrible 'use an array as a function' hack i used a couple of years back made for a useful stack overflow response. ;) http://stackoverflow.com/questions/6482970/is-it-possible-to-emulate-a-function-using-your-own-data-type/6485001#6485001
13:46:18 <augur> i mean, whats the gist of it
13:46:41 <edwardk> augur: it right associates binds. at least when applied to a functor from hask -> hask
13:47:12 <edwardk> augur: if you want a more category theoretic treatment you need to wander back to the 70s
13:47:38 <edwardk> augur: i believe i provided links to dubuc's thesis in my original kan extensions article
13:47:52 <cmccann> edwardk, is that hack related to the scary nonsense McBride used to fake idiom brackets in Haskell? Or was that something else entirely
13:48:13 <edwardk> cmccann: pretty sure something else entirely
13:48:21 <augur> mcbride is never scary nonsense! :|
13:48:22 <augur> :(
13:48:37 <edwardk> the fake idiom bracket bit wasn't that bad. relied on a couple of instances that didn't overlap
13:49:00 <edwardk> but then its still using classes to get application, so in some sense yes
13:49:06 <cmccann> my main complaint about the fake idiom brackets is that the result didn't look quite pretty enough to justify the weirdness
13:49:12 <edwardk> yeah
13:49:26 <edwardk> i don't actually _like_ the solution i presented there, just indicated it was possible ;)
13:49:42 <cmccann> whereas going all out with some of oleg's scary overlapping tricks could make things look really neat as long as you don't look behind the curtain
13:50:01 <ddarius> Density is covered in "Basic Concepts of Enriched Category Theory" which is definitely something someone interested in category theory should read at some point.
13:50:06 <edwardk> cmccann: yeah, i have a version of that trick in my ad library, for variadic gradient
13:50:18 <edwardk> so you can do things like vgrad (*) 1 2    and get back [2,1]
13:50:34 * cmccann nods
13:50:37 <iwtu>  hi guys. I need help with make list of words from Trie
13:50:56 <edwardk> but sadly, the way type inference works in ghc means i had to give up the quantifier that i use to provide safety from infinitesimal confusion =(
13:51:20 <edwardk> > filterM (const [True,False]) "Trie"
13:51:21 <lambdabot>   ["Trie","Tri","Tre","Tr","Tie","Ti","Te","T","rie","ri","re","r","ie","i","...
13:51:24 <edwardk> there =)
13:51:38 <cmccann> edwardk, I got kinda tired of a lot of silly type hackery in GHC
13:51:57 <augur> edwardk: i like your blog btw.
13:51:59 <ddarius> edwardk: That was worth it?
13:52:03 <cmccann> so much of it is just workarounds for things that sensibly expect dependent types or plain type-level functions or whatnot
13:52:05 <augur> all of these recursion schemes look interesting
13:52:08 <edwardk> cmccann: yeah, i rather prefer to do stuff that is more obviously correct =)
13:52:33 <edwardk> ddarius: the trie joke or the stackoverflow bit?
13:53:06 <edwardk> augur: they turn out to be largely a colossal waste of time, but every once in a while, you find a use for knowing them
13:53:20 * cmccann implemented a fair amount of System F with limited type inference and algebraic data types at the type-level in GHC before realizing the whole thing was stupid
13:53:26 <edwardk> augur: and thanks =)
13:53:33 <cmccann> that and it was hilariously slow to evaluate anything
13:53:37 <cmccann> but mostly just stupid
13:53:43 <augur> edwardk: im continuously looking for interesting things that CT lets you understand in programming
13:54:06 <ksf> it's rather the other way round for me.
13:54:21 <ddarius> edwardk: Removing the quantifier.
13:54:21 <edwardk> ddarius here is a pretty good gold mine for actual category theory. I'm just a hack who enjoys applying it.
13:54:21 <ksf> I tolerate the lingo, and then grok the lingo through CS.
13:54:41 <augur> edwardk: and the whole levitation thing is interesting
13:54:44 <ksf> though all probably limited to CCCs, at least.
13:55:07 <augur> edwardk: and so im always interested in seeing other things that are as general but similarly insightful
13:55:14 * cmccann still owes ddarius for an off-hand remark that introduced him to a thoroughly enjoyable and remarkably sensible bit of mathematics
13:55:25 <edwardk> ddarius: ah. losing the quantifier makes a more convenient gradient function, but the risk is if you use vgrad on a computation that computes a derivative itself you may get perturbation/sensitivity confusion.
13:55:31 <ddarius> cmccann: Which bit of mathematics is that?
13:55:41 <ben> i've been failing at iteratees for so long that i've entirely forgotten what i started out trying to do
13:55:42 <DukeDave> I can't believe this hasn't come up before: How do I apply a function (a->a) to an a multiple times?
13:55:57 <cmccann> ddarius, clifford algebra as making a hell of a lot more sense than usual ways of working with vectors and such
13:56:06 <edwardk> augur: gentle art of levitation, conor's stuff? or did i blog about it some time?
13:56:06 <cmccann> like, cross product, wtf even is that
13:56:09 <ddarius> Ah yes, geometric algebra.
13:56:10 <ben> DukeDave: iter?
13:56:13 <augur> edwardk: conors stuff
13:56:25 * ddarius <3 geometric algebra.
13:56:27 <ben> ate
13:56:30 <edwardk> cmccann: geometric algebra is a lot of fun
13:56:31 <ben> > take 10 $ iterate (+1) 5
13:56:31 <ben> [5,6,7,8,9,10,11,12,13,14]
13:56:31 <cmccann> aren't iterates just a free monad of something or other? :]
13:56:32 <lambdabot>   [5,6,7,8,9,10,11,12,13,14]
13:56:34 * ddarius <3 David Hestenes and E. T. Jaynes.
13:56:38 <augur> edwardk: i learned a lot about the nature of catamorphisms from his ornamental algebras paper
13:57:00 <edwardk> cmccann: i have two versions of my thesis. the version where i use geometric algebra, which is short and sweet, and the version where i assume the audience is an idiot, which is 10x longer.
13:57:12 <cmccann> it's really remarkable how much more sense a lot of stuff makes from the geometric algebra perspective
13:57:21 <ddarius> cmccann: Indeed.
13:57:29 <cmccann> like quaternions for rotations, which always seemed bizarre to me
13:57:31 <ben> I'm going to jump out of the window the next time someone starts an explanation with "___ is just a ___"
13:57:37 <DukeDave> ben: Aha, thanks! Hoogle turned up something in Data.Sequence, which seemed a bit much!
13:57:39 <augur> edwardk: it seems like a very interesting and deep fact that you can define types in such a way that catamorphisms just fall out for all of them for free
13:57:52 <DukeDave> ben++
13:57:55 <ddarius> cmccann: If you haven't, you should also read Jaynes' stuff, which is linked to from Hestenes' page, though can also be found readily via Google.
13:58:11 <cmccann> ben, those usually aren't explanations, for what it's worth
13:58:27 <ben> Yeah, I realise :)
13:58:33 <edwardk> augur: yeah. a lot of his ornamented algebra, or algebraic ornaments, i forget which, are just the fact that you can build a cofree comonad instead of tie the knot with mu or nu.
13:58:33 <cmccann> ddarius, already familiar with it to some extent, albeit indirectly from other sources
13:58:49 <edwardk> augur: you may find the blog post i wrote on Reflecting on Incremental Folds to be useful
13:59:14 <edwardk> augur: another is the older "Rotten Bananas" post, which talks about catamorphisms on data types where the variable occurs in negative position.
13:59:17 <augur> edwardk: ill check it out. do you know of other deep unifying ideas?
13:59:23 <cmccann> ddarius, and yes, it gives me the same sort of feeling of "hey, everything fits together sensibly this way"
13:59:33 <edwardk> augur: kan extensions =)
13:59:40 <parcs> DukeDave: if efficiency matters, consider creating the recursive function yourself. iterate builds up a list of size n
13:59:52 <augur> edwardk: in 2000 words or less, what do kan extensions provide insight into? :p
14:00:01 <ben> is there an enumator package support group
14:00:06 <ben> i feel so dumb about this
14:00:10 <ddarius> edwardk: You should check out Emily Riehl's article on weight (co)limits.
14:00:22 <ben> do i just post on stackoverflow and hope that someone breaks it down
14:00:31 <edwardk> augur: "All concepts are Kan extensions" in the words of Saunders Mac Lane. ;)
14:00:39 <cmccann> ben, it's worth trying, or asking the haskell-cafe mailing list
14:00:39 <ddarius> augur: The title of the last chapter in "Categories for the Working Mathematician" is "All Concepts are Kan Extensions"
14:00:40 <augur> edwardk: O_O
14:00:43 <augur> what does that mean D:
14:00:53 <cmccann> I think the library's author is active in both places, but I'm not certain
14:00:53 <augur> FREGE IS NOT HAPPY
14:01:12 <ddarius> augur: It just means that every (1-)categorical idea is an instance of a Kan extension, more or less.
14:01:14 <edwardk> augur: it means that they pop up everywhere, once you know how to look
14:01:14 <augur> btw who was shocked to find that frege was a raving lunatic nazi type
14:01:18 <augur> wtf is that, seriously
14:01:27 <edwardk> but in particular, ddarius beat me to the punchline
14:01:37 <augur> ddarius: i wish i understood that :D
14:01:43 <augur> im reading edwardk's post now tho
14:01:43 <augur> so
14:01:48 <JuanDaugherty> frege? sounds wrong
14:01:54 * cmccann was interested to find out recently that Mac Lane didn't coin the term "monad", despite having heard a couple times that he did
14:01:56 <JuanDaugherty> maybe you're thinking heidegger
14:02:02 <augur> JuanDaugherty: no, frege
14:02:05 <edwardk> augur: most of the stuff that you cover in Mac Lane's categories for the working mathematician turns out to be an instance of a Kan extension.
14:02:22 <edwardk> augur: and the ONLY reason i say most is that the second edition added some discussion of 2-category theory
14:02:24 <JuanDaugherty> he predeceased the NS though
14:02:28 <augur> JuanDaugherty: he even tried to use his work to optimize the expulsion of jews from germany
14:02:35 <edwardk> augur: there is a reason why they are the last chapter =)
14:02:38 <augur> JuanDaugherty: no certainly, but he was crazy antisemitic
14:02:45 <augur> JuanDaugherty: http://en.wikipedia.org/wiki/Gottlob_Frege#1924_Diary.2C_Nazism.2C_and_antisemitism
14:02:49 <ksf> some german philosopher of that time, sadly don't remember the name, answered, asked to sign his pledge to the fuehrer, "sorry, no, I can't do that, the german it's written in is too abysmal"
14:03:28 <edwardk> ddarius: bookmarked the paper on weighted (co)limits
14:03:36 <augur> edwardk: CftWM is extremely math-oriented tho, for obvious reasons
14:03:42 <augur> and i dont know most of the math it covers
14:03:49 <augur> so its all opaque to me :(
14:04:04 <edwardk> augur: yes, but it is worth working through what you can and coming back once you have more math to the parts you can't
14:04:11 <edwardk> most of the math is in the examples
14:04:37 <sam3> Hi, when we want to declare types
14:04:46 <edwardk> in general category theory is a unifying framework for stitching together a bunch of seemingly disparate examples, so that make sense
14:04:52 <sam3> we usually do... data Type = Type Int
14:05:00 <augur> edwardk: the problem is that the math is useless for my pursuits. groups, rings, etc. have no bearing as far as i can tell on what i work on. only the type-theory stuff and maybe lattice stuff is relevant
14:05:07 * cmccann bought a copy of TTT from a local used bookstore
14:05:12 <sam3> but does just declaring: data Type
14:05:13 <cmccann> though yes, I know it's available online
14:05:15 <sam3> do anything?
14:05:19 <edwardk> augur: dunno. i got a job because of knowing Monoids. ;)
14:05:28 <augur> edwardk: you're not a linguist ;)
14:05:31 <edwardk> augur: we used them to make a pretty insane speedup to some real world code.
14:05:39 <jmcarthur> sam3: yes, it makes a type whose only value is bottom. it requires an extension to be valid haskell though
14:05:46 <augur> edwardk: sure. but i bet group theory isnt relevant much
14:05:48 <edwardk> augur: yes, but koninkje is and he uses lots of category theory
14:06:08 <edwardk> augur: and i did dabble in your field for quite a while.
14:06:08 <sam3> what does it mean when only value is bottom?
14:06:12 <cmccann> groups strike me as the sort of thing that might show up all over the place, even far away from "math"
14:06:14 <jmcarthur> sam3: it's not uncommon to use empty data types like that just to create tags to use with GADTs
14:06:16 <cmccann> albeit not as much as monoid
14:06:30 <augur> edwardk: what kind of stuff does koninkje do?
14:06:38 <jmcarthur> sam3: it means the only possible value of the type is nontermination or an error
14:07:25 <sam3> hm... just one sec
14:07:32 <augur> or wheres his website?
14:07:42 <edwardk> augur: he is a computational linguist, with an emphasis on the linguistics side. trying to drag more category theory into the field to describe plausible models of language cognition, rather than purely abstract models that throw out any attempt at modeling reality (*cough* most of chomsky's later stuff)
14:07:58 <sam3> http://hpaste.org/48375
14:08:04 <sam3> I have this code...
14:08:13 <augur> chomsky's later stuff isnt bad, its just hard to discuss properly
14:08:15 <sam3> then how do you declare a T12 type?
14:08:25 <augur> this is a problem with much of chomskyan linguistics
14:08:42 <augur> its abstract but also horribly fuzzy
14:08:47 <sshc> @hoogle unGetChan
14:08:49 <edwardk> augur: i don't know that he blogs too much about this stuff, but he pops on here regularly, and came up to McMaster to help me out with the DSL workshop I did a couple of weeks back.
14:08:49 <lambdabot> Control.Concurrent.Chan unGetChan :: Chan a -> a -> IO ()
14:08:50 <jmcarthur> sam3: your "data T12" line does that. try using -XEmptyDataDecls if the compiler isn't allowing it
14:08:55 <sshc> "Put a data item back onto a channel, where it will be the next item read. "
14:09:12 <augur> edwardk: i dont care about language cognition, i just care about the properties of language, so im ok with the chomskyan abstractness
14:09:16 * cmccann knows nothing about linguistics aside from what he picked up reading Language Log :[
14:09:23 <sshc> Can this be used to put a value on the opposite end of the Chan even if it was never taken from the Chan in the first place?
14:09:25 <augur> i just with chomskyans new more about programming and formal anything
14:10:32 <edwardk> cmccann: i worked at the Linguist List for a couple of years
14:10:44 <augur> edwardk: did you now
14:10:47 <jmcarthur> sam3: or is your question really "how do you create a value of type T12?"?
14:10:50 <augur> interesting.
14:10:58 <sam3> um... yes
14:11:01 <edwardk> cmccann: and my wife was a computational linguist before she left the field to find an actual job ;)
14:11:18 <jmcarthur> sam3: the answer to that is to used undefined, error, or a recursive expression that doesn't terminate
14:11:19 <cmccann> edwardk, haha
14:11:24 <jmcarthur> *use undefined
14:11:32 <augur> edwardk: we should talk some time. im currently working on understanding derivationality. my main thesis is that derivational = is an induction principle of some sort
14:11:38 <sam3> if I just have the code... then can I declare T12 in prompt?
14:11:45 <sam3> oh... is that not possible?
14:11:51 <jmcarthur> sam3: undefined :: T12
14:12:04 <jmcarthur> or   let x = x :: T12
14:12:23 <edwardk> i'm mostly a mathematician/statistician who likes linguistic problems, and who borrows your vocabulary for dealing with parsing problems
14:12:41 <sam3> hm... I see
14:12:49 <sam3> let me just test some codes out
14:12:49 <jmcarthur> sam3: value (undefined :: T12) == 12,  for example
14:13:01 <augur> edwardk: i would say im a wannabe mathematician who finds certain linguistics problems really interesting
14:13:15 <jmcarthur> sam3: or   let x = x :: T12 in value x == 12
14:13:20 <augur> edwardk: not that i know any math :D
14:13:20 <cmccann> in theory, the nice thing about parsing computer languages is that you can redefine the language to make it more tractable to interpret
14:13:24 <sam3> I'm not fully understanding the undefined :: T12 part...
14:13:30 <cmccann> in practice the nice thing about natural languages is that computer languages include C++ and perl
14:13:43 <edwardk> cmccann: yep
14:14:01 <edwardk> cmccann: well, yep to the former anyways ;)
14:14:12 <augur> edwardk: ive recently become convinced that computational complexity is the wrong way to think about language and instead we should be thinking about it more .. i dont know. more fold-y-ly :P
14:14:25 <jmcarthur> sam3: undefined (which is a way to write bottom) is the only possible value of type T12. the type annotation is necessary because the compiler can't infer it for you (since undefined is polymorphic and the value function is also polymorphic)
14:14:41 <augur> that is to say, language is probably built more by having certain computational structures that are tangential to complexity hierarchies
14:15:04 <jmcarthur> *bottom (which one way to write is using the undefined value)
14:15:31 <cmccann> edwardk, I dunno, are there any natural languages that potentially require solving the halting problem to parse
14:15:43 <cmccann> I guess there probably are, really, but oh well
14:15:57 <edwardk> augur: well, i'm more of the camp that its nice to talk about things in terms of the closest fitting abstraction. like i don't mind talking about CFGs, TIGs, TAGs, etc. but i find that when folks try to say, take a CFG with bounded recursion and model it as a regular language they are being really really dumb.
14:16:01 <jmcarthur> sam3: in haskell, all types have at least one value: nontermination
14:16:15 <jmcarthur> sam3: since T12 has no terminating values, its only value is nontermination
14:16:16 <edwardk> augur: you may have one, but you are ignoring all the structure that makes it learnable
14:16:30 <augur> edwardk: i dont even know what thats even about, honestly
14:16:51 <jmcarthur> sam3: "bottom" is probably a more precise way to say that though, since it's arguable that "undefined" is in some way different from nontermination because it makes your program crash
14:17:08 <jmcarthur> sam3: but then again, nontermination is kind of like crashing, too
14:17:14 <gwern> > 2.34 * 16.35
14:17:15 <lambdabot>   38.259
14:17:16 <sam3> hm.. I think I'm slowly getting it
14:17:29 <edwardk> augur: so induction strikes me as potentially the wrong tool, because it by construction will admit infinite recursion in your grammar, and eventually native speakers start just looking at you like you are an idiot for trying to make 2n+1 occurences of the word 'buffalo' into a sentence.
14:17:45 <edwardk> its a useful abstraction but you need to moderate it
14:18:04 <augur> edwardk: oh sure, that might be true
14:18:09 <hpc> "undefined" implies to me that something hasn't been given a definition; "bottom" implies that the definition it has is shit :P
14:18:21 <jmcarthur> sam3: if haskell didn't allow you to write expressions that may not terminate then it would be impossible to work with values of type T12 because there would be none
14:18:27 <augur> edwardk: but i think that its plausible to say that thats a limit of the brains size, not its design
14:18:34 <edwardk> augur: one use of category theory in linguistics you might find interesting are 'combinatory categorical grammars'
14:18:39 <augur> edwardk: like, real computers fail that too, right
14:18:47 <augur> im well aware of CCGs :)
14:18:49 <ksf> of language, design, too.
14:18:53 <augur> i wrote half the wikipedia article for it!
14:18:57 <edwardk> hah
14:19:05 <ksf> you english native speakers have wholly unimpressive nesting skills.
14:19:07 <augur> i also wrote a bunch of articles on less known formalisms
14:19:12 <edwardk> koninjke = wren thornton, http://llama.freegeek.org/~wren/pubs/ccgjp_nasslli2010.pdf
14:19:14 <augur> such as the one on head grammar
14:19:29 <jmcarthur> > cycle "buffalo "
14:19:30 <lambdabot>   "buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo bu...
14:19:43 <augur> edwardk: but i mean, sure humans cant handle complex nesting etc. thats fine
14:20:00 <augur> edwardk: neither can computers, they just have a larger tolerance, right
14:20:12 <augur> doesnt mean we cant model computers as if they can
14:20:30 <augur> that actually relates to a fundamental flaw i find in much of the ideas on complexity that come up
14:20:46 <augur> often complexity is just a limit on memory, not a constraint on the kinds of processes involved
14:21:07 <edwardk> like i said, you need to use induction to learn any realistic grammar, but you probably need to do so in terms of some kind of ever increasing cost
14:21:30 <augur> i'd love to read something on a different complexity hierarchy that factors out memory concerns and talks about complexity of the processes involved
14:21:49 <jmcarthur> i prefer to think of computers as giving us a limited way to play with our idealized languages rather than pretending our languages actually model the computer in any meaningful way
14:22:14 <edwardk> personally i just steal tools for linguistics for parsing nicely behaved languages in the computer. ;)
14:22:23 <augur> thats why i like this discussion of types of recursion, because it seems to be an orthogonal hierarchy based on the nature of the computation, not how it interacts with memory
14:22:24 <edwardk> then i use lots of math to pull it off.
14:22:56 <edwardk> and i'm not above using hacks to pull it off.
14:23:02 <sshc> Can 'unGetChan' be used to put a value on the opposite end of the Chan even if it was never taken from the Chan in the first place?
14:23:06 <augur> edwardk: :)
14:23:24 <augur> edwardk: oh this is great, this link you gave me
14:23:29 <hpc> sshc: try it!
14:23:37 <augur> edwardk: i have wonderful data that is a problem for a CG account of ellipsis
14:23:57 <jmcarthur> even better than "try it" is "look at the code"
14:24:12 <jmcarthur> just because it works once doesn't mean it will work in all cases
14:24:19 <hpc> even more betterer is "both"
14:24:20 <edwardk> i used to sell an online lip syncing engine that used all sorts of perception hacks, and some cheap gaussian mixture models, for instance to compete with the folks who were trying to parse out trigrams, etc.
14:25:13 <edwardk> augur: he gave a talk on it at some linguistics workshop recently. oh, nasslli. that was where those slides came from, nevermind.
14:25:13 <edwardk> augur: it being the ccg stuff, not my lipsyncing crap ;)
14:25:25 <augur> :p
14:25:42 <sshc> Seem sso,looking at the code
14:27:51 <dons> ?pl \x y-> uncurry f (k x y)
14:27:51 <lambdabot> (uncurry f .) . k
14:28:16 <edwardk> augur: anyways, i thought the bit down around p24/27 about the fine tuning of the calculus and the fact that the two approaches to the rules agree in turn with the different sets of native speaker judgments, seemed to indicate to me that he is on the right track
14:28:44 <augur> edwardk: well sure but every good linguistic theory will have that sort of property
14:28:52 <edwardk> augur: yeah
14:28:54 <augur> edwardk: even chomsky's stuff
14:29:07 <edwardk> augur: sure
14:29:17 <ben> Okay, pretend I have an enumerator Enumerator producing a bunch of Bytestrings, maybe Data.Enumerator.Binary.enumFile, and I want to use an Iteratee taking Strings, and I want to squeeze something inbetween that splits the chunks of bytestreams into a sequence of lines. Am I building an Enumeratee or what is going on?
14:29:19 <edwardk> augur: just enjoyed it particularly much in this case ;)
14:29:24 <augur> what i dont like about CCG is that its so powerful that the ways you need to constrain it are .. odd
14:29:41 <augur> edwardk: so like steedmans method is to let languages differ on the combinators they have
14:30:17 <edwardk> i've mostly been looking at stealing it as an evaluation strategy for computational things ;)
14:30:28 <augur> an evaluation strategy?
14:30:52 <edwardk> it provides an interesting compromise for partial evaluation, because you can look under a lambda for a different box.
14:31:07 <dylukes> CCG?
14:31:10 <augur> edwardk: oh also there are some very interesting facts about things like sluicing that suggest that non-transformational models are wrong
14:31:36 <edwardk> dylukes: yeah. (or were you looking for a definition?)
14:31:43 <augur> edwardk: where things are required to have properties depending on things that _arent in the sentence_
14:31:43 <dylukes> I have no clue what it is
14:31:53 <augur> (syntactic things, i mean)
14:31:59 <edwardk> dylukes: "Combinatory Categorical Grammars"
14:32:14 <dylukes> no clue what that is haha
14:32:22 <augur> dylukes: directional function application for syntactic types
14:32:28 <dylukes> still no clue
14:32:39 <edwardk> augur: it isn't perfect, its just a formalism that has some properties i can steal for other purposes.
14:32:42 <sam3> I have this code...
14:32:43 <sam3> http://hpaste.org/48380
14:32:49 <sam3> I'm not sure why the error...
14:32:51 <edwardk> augur: remember, i'm not a linguist. i just married one.
14:32:56 <augur> edwardk: ;)
14:33:16 <augur> edwardk: so sluicing is like when you say stuff like "i met someone but i dont know who"
14:33:31 <augur> ~ "... but i dont know who i met"
14:33:39 <edwardk> *nods*
14:34:09 <augur> in german, the "who" has to be marked for the case that it would have had if it were the direct object of "met"
14:34:58 <edwardk> augur: Did you read chung chieh shan's stuff on delimited continuations for language semantics for dealing with something similar?
14:35:00 <augur> which looks really like it started next to "met", and then moved out, and the "i met" was then deleted
14:35:20 <augur> i know of shans work, but i havent seen it applied to syntactic issues
14:35:24 <augur> only semantic ones
14:35:30 <edwardk> fair nuff
14:35:48 <augur> but he got the continuations from barker anyway ;p
14:36:14 <edwardk> that and from the fact that he wanders around with oleg all the time =P
14:36:14 <augur> transformations are actually just continuation transformations!
14:36:35 <augur> i bet oleg could implement shan in the type system of haskell.
14:36:43 <edwardk> i'm pretty sure he did.
14:36:46 <augur> :D
14:37:01 <augur> edwardk: but yeah, its really hard to explain the case facts of sluicing if you dont have a transformational account
14:37:27 <augur> edwardk: there are also languages where binding of certain sorts requires syntactic identity, and transformations make that beautifully simple
14:39:14 <edwardk> i only stumbled on CCGs from the fact that I spent some time exploring TAGs in the context of monoidal parsing, and then rediscovered them from talking to wren
14:40:05 <augur> ill have to talk to him some time
14:40:07 <edwardk> natural languages are a mess. ;)
14:40:10 <augur> koninkje_away: we should talk some time!
14:40:17 <augur> edwardk: they are, but theyre interesting in how theyre messy
14:40:34 <augur> it seems like theres something beautiful going on, its just complicated but its scale
14:41:07 <edwardk> sure, but i can get a decent 80% parse or translation just by firing all you linguists and loading up on statisticians. ;)
14:41:19 <cmccann> edwardk, isn't that how Google does it?
14:41:29 <edwardk> cmccann: yeah, which is why they suck for certain languages
14:41:30 <augur> edwardk: ofcourse, but so what
14:41:42 * cmccann seems to recall google being full of people who do statistical AI stuff
14:41:47 <augur> you can get to 80% on anything with statistics
14:41:57 <edwardk> augur: true nuff
14:42:04 <augur> the problem with that, edwardk, is that you dont understand whats going on
14:42:16 <augur> you get 80% accuracy with 0% understanding
14:42:32 <augur> if you had a blackbox oracle parser that worked 100% it doesnt mean you understand anything
14:43:05 <augur> thats why NLP is engineering not science
14:43:16 <augur> oracles are great for engineers
14:43:21 <augur> they're shit for scientists
14:43:23 <edwardk> for 100% i'd happily live in ignorance. at 80% i'm still happy you guys are out there fighting the good fight. ;)
14:43:32 <augur> edwardk: ofcourse you would
14:43:38 <augur> but ignorance isnt the goal of science
14:43:50 <danharaj> We do what we must because we can.
14:43:56 <danharaj> For the good of all of us except the ones who are dead.
14:43:59 <augur> danharaj: other way arond
14:44:03 <augur> we do what we can because we must
14:44:09 <danharaj> Clearly you're not thinking with portals.
14:44:12 <cmccann> augur, it's a quote :P
14:44:13 <augur> which makes it all the more darker
14:44:18 <augur> cmccann: i know
14:44:29 <davpla> we do doodly do doodly do
14:44:37 <augur> oh i guess _i_ have it backwards D:
14:44:55 <davpla> what me must muddily muddily must
14:44:58 <augur> hm, that makes it less dark
14:44:59 <augur> anyway!
14:45:11 <augur> edwardk: david deutsch actually hammers hard on this point in fabric of reality
14:45:13 <davpla> til we bust bodily bust bodily bust
14:45:24 <augur> where he talks about oracles for science and how they would be utterly useless for doing science
14:45:35 <edwardk> augur: *shrug* once this waxes philosophical i tune out ;)
14:45:42 <augur> edwardk: theories are the tools you use to devise new questions
14:45:57 <augur> theories tell you which questions make sense to ask and which dont
14:46:07 <augur> if you just had an oracle, it might be able to answer any question you pose it
14:46:11 <augur> but which questions do you ask?
14:46:31 <iwtu> how nice tell to ghci in order to data M a = Leaf | V (M a) (M a) was in Eq and Ord typeclass?
14:46:33 <augur> for an engineer the questions are fixed: whats the structure of this sentence, lets say
14:46:50 <augur> but for a linguist the questions arent known
14:47:26 <augur> thats sort of the big problem i have with oracles. youre poking around in the dark
14:47:39 <hpaste> Hartmut pasted “wai-handler-devel problem” at http://hpaste.org/48381
14:49:37 <edwardk> i guess i'm somewhat jaded, because i haven't been all that terribly impressed with the linguistics community's ability to find answers, let alone questions. maybe that was a consequence of the particular linguistic ghetto i found myself in, but i've since turned back to those evil black box tools you so deride
14:49:43 <iwtu> ski: osfameron ziman cmccann i have made http://paste.pocoo.org/show/420596/
14:49:50 <edwardk> in the meantime i hope you guys make progress
14:50:38 <edwardk> and i'll keep stealing notes from linguists to find new classes of grammars i can parse. ;)
14:50:54 <augur> edwardk: what answers are you looking for that we're not finding?
14:51:35 <augur> also keep in mind, edwardk, that your statistical methods are built on top of non-statistical models
14:51:42 <dons> this was surprisingly tricky to get right, http://stackoverflow.com/questions/6486199/how-to-set-strictness-in-list-comprehension  if anyone wants to have a look
14:51:47 <augur> and all linguistic models are statistical, we just dont talk about the stats
14:51:50 <dons> not sure if i overlooked something, or if ghc is doing it wrong.
14:52:19 <edwardk> dons: tricky
14:54:17 <edwardk> augur: we've gotten pretty far off topic. we should probably move this to pm or #haskell-blah or some such
14:54:42 <augur> edwardk: you -> haskell blah!
14:57:31 <ddarius> dons: You probably first need to desugar the list comprehension, then follow the reports desugaring of pattern batching with the additions that bang patterns add.
14:58:34 <ddarius> Of course, tehre is probably a way to do it much more nicely without doing that.
14:58:48 <ryant5000> is there any way to 'mapException' polymorphically?  I'd like to wrap all exceptions in another exception for debugging purposes
15:02:22 <danharaj> ah, so you can't attach a where clause to a particular guard, huh?
15:02:35 <danharaj> That's annoying, since I'm using patternguards so I have some names bound in one guard but not the others.
15:02:40 <edwardk> ryant5000: what keeps you from catching an arbitrary SomeException?
15:03:52 <ryant5000> edwardk: oh, i suppose that works; i haven't used the new exception library before
15:03:56 <ddarius> dons: So, is the original expression equivalent to map (\(!e1, !e2) -> f e1 e2) (zip l1 l2) ?
15:04:29 <edwardk> ryant5000: i think simon marlow gave a talk back at icfp06 on the topic, there should be a paper associated with that
15:04:49 <ryant5000> edwardk: ah, cool; i'll have to take a look
15:05:08 <ddarius> Incidentally
15:05:10 <ddarius> @src uncurry
15:05:10 <lambdabot> uncurry f p = f (fst p) (snd p)
15:07:36 <ddarius> So, I'd think zipWith (\(x, y) -> x `seq` y `seq` f x y) l1 l2 would work, which is basically your uncurry version with an inlined, stricter uncurry.
15:12:13 <ddarius> Actually, I think the magic needs to be that the pattern is refutable before we get to the body of the lambda.
15:14:00 <ddarius> > let fibs = 0 : 1 : zipWith' (+) fibs (tail fibs); zipWith' f l1 l2 = zipWith k l1 l2 where k (x,y) | x `seq` y `seq` True = f x y in fibs !! (10^6)
15:14:00 <lambdabot>   Occurs check: cannot construct the infinite type:
15:14:01 <lambdabot>    b = (b -> t, b -> t)
15:14:31 <ddarius> > let fibs = 0 : 1 : zipWith' (+) fibs (tail fibs); zipWith' f l1 l2 = zipWith k l1 l2 where k x y | x `seq` y `seq` True = f x y in fibs !! (10^6)
15:14:32 <lambdabot>   *Exception: stack overflow
15:15:47 <iwtu> is any way to put typeclass in my own type definition?
15:15:51 <ddarius> @undo [f x y | (x,y) <- zip l1 l2]
15:15:51 <lambdabot> concatMap (\ (x, y) -> [f x y]) zip l1 l2
15:16:16 <ddarius> That looks not quite right.
15:16:47 <ddarius> I think GHC is doing something wrong here.
15:17:10 <Phyx-> edwardk: sorry, was afk for a bit, mostly safe kinds. I'm basically trying to measure how much overhead my library adds when it exports functions
15:18:04 * ksf wants package-internal exports.
15:18:40 <ddarius> Actually, I guess GHC is right, but it is subtle.
15:18:52 <Phyx-> edwardk: and ghc specific yeah
15:18:55 <ksf> ...that don't get haddocked and are only visible to modules in the same package.
15:20:09 <DukeDave> Erm, I don't suppose there's a clever way to 'map' a function over the elements of a tuple?
15:20:14 <ddarius> > [True] >>= return . not
15:20:17 <ezyang> DukeDave: No.
15:20:18 <lambdabot>   mueval-core: Time limit exceeded
15:20:20 <ddarius> > [True] >>= return . not
15:20:22 <lambdabot>   [False]
15:20:26 <ksf> DukeDave, yes!
15:20:30 <ksf> a very clever way.
15:20:36 <ksf> some might say too clever.
15:20:39 <ksf> it's called HList.
15:20:51 <ezyang> ksf: Does HList have static length guarantees? :-o
15:20:57 <ezyang> I was thinking you'd have to use TH or something.
15:21:00 <cmccann> HLists aren't tuples though
15:21:07 <ksf> HLists are records.
15:21:12 <cmccann> they're nested pairs, give or take
15:21:29 <ksf> ezyang, they can, if you want to.
15:21:45 <ddarius> Oh, what's happening is subtly correct.
15:22:14 <ddarius> And isn't too relevant to bang patterns, though bang patterns do give a nice syntax to explain it.
15:22:42 <DukeDave> Hehe, okay
15:23:11 * DukeDave walks quietly away
15:23:25 * Phyx- ropes DukeDave back in
15:23:57 <ddarius> You have the monad law, m >>= \x -> return (f x) <=> liftM f m, but that says nothing about m >>= \!x -> return (f x), so we can't simplify to map.
15:24:44 <ddarius> The concat in the concatMap (i.e. (>>=)) forces the binding when it flattens the list which is what gives the streaming behavior.
15:25:07 <joe6> >  take 8 . iterate $ 0
15:25:08 <lambdabot>   Couldn't match expected type `[a]'
15:25:08 <lambdabot>         against inferred type `a1 -> [a1]'
15:25:31 <joe6> >  take 8 . iterate $ (0 :: Word8)
15:25:32 <lambdabot>   Couldn't match expected type `[a]'
15:25:32 <lambdabot>         against inferred type `a1 -> [a1]'
15:26:00 <joe6> i am trying to pad a list with 0, to make its' length 8
15:26:07 <joe6> is this the correct way to do it.
15:26:09 <joe6> >  take 8 . iterate $ (0 :: Word8)
15:26:10 <lambdabot>   Couldn't match expected type `[a]'
15:26:11 <lambdabot>         against inferred type `a1 -> [a1]'
15:26:26 <ddarius> > let fibs = 0 : 1 : zipWith' (+) fibs (tail fibs); zipWith' f l1 l2 = zip l1 l2 >>= \(x,y) -> x `seq` y `seq` [f x y] in fibs !! (10^6)
15:26:27 <hpaste> electronplusplus pasted “Mixing list” at http://hpaste.org/48384
15:26:30 <lambdabot>   mueval-core: Time limit exceeded
15:26:37 <ddarius> > let fibs = 0 : 1 : zipWith' (+) fibs (tail fibs); zipWith' f l1 l2 = zip l1 l2 >>= \(x,y) -> x `seq` y `seq` [f x y] in fibs !! (10^5)
15:26:38 <lambdabot>   259740693472217241661550340212759154148804853865176965847247707039525345435...
15:26:41 <ddarius> > let fibs = 0 : 1 : zipWith' (+) fibs (tail fibs); zipWith' f l1 l2 = zip l1 l2 >>= \(x,y) -> x `seq` y `seq` [f x y] in fibs !! (10^6)
15:26:45 <lambdabot>   mueval-core: Time limit exceeded
15:26:58 <ddarius> > let fibs = 0 : 1 : zipWith' (+) fibs (tail fibs); zipWith' f l1 l2 = zipWith k l1 l2 where k x y | x `seq` y `seq` True = f x y in fibs !! (10^5)
15:27:00 <lambdabot>   259740693472217241661550340212759154148804853865176965847247707039525345435...
15:27:04 <electronpluspl-1> partir 3 [1,2,3,4,5,6,7,8] should output [[1,2,3],[4,5,6],[7,8]]
15:27:30 <iwtu> hi guys. I have a error: No instance for (Ord a) inspite of I have deriving Ord http://paste.pocoo.org/show/420627/ . have any idea what's wrong?
15:27:41 <electronpluspl-1> but I can't do [take n xs] ++ partir n drop n xs
15:29:14 <iwtu> electronpluspl-1: what should the partir do?
15:29:22 <electronpluspl-1> receives a list
15:29:30 <electronpluspl-1> and break into a sublists
15:29:44 <electronpluspl-1> but i don't know how to mix it
15:29:44 <Saizan> iwtu: the type signatures are wrong
15:30:18 <Saizan> iwtu: insertMyTrie :: Ord a => [a] -> MyTrie a -> MyTrie a; traversalMyTrie :: Ord a => MyTrie a -> [[a]]
15:30:24 <ddarius> dons: I'm pretty sure the problem with your first examples is the use of let.  You are turning a refutable match (the match on (,)) into an irrefutable match.
15:30:50 <iwtu> cannot it derived type a from MyTrie?
15:31:13 <Saizan> you have Ord (MyTrie a) only if given Ord a
15:31:22 <iwtu> electronpluspl-1: break into sublist by?
15:31:48 <iwtu> Saizan: I am not sure I understand
15:31:49 <nkpart> hey, anyone know if hackage 2.0 is still being worked on?
15:32:01 <electronpluspl-1> partir 5 "abdefghijkl" = ["abde" ,"fghij" ,"kl" ].
15:32:15 <electronpluspl-1> iwtu:
15:32:41 <iwtu> electronpluspl-1: by length?
15:32:45 <electronpluspl-1> yes
15:32:52 <ddarius> My version using (>>=) works in GHCi.
15:33:00 <osfameron> is a haskell zipper defined for an empty list?
15:33:05 <iwtu> so "abcde" I suppose :)
15:33:25 <electronpluspl-1> yes
15:33:48 <electronpluspl-1> partir a xs = [take a xs] ++ partir a (drop a xs)
15:33:58 <electronpluspl-1> it would be something like this :P
15:34:36 <osfameron> aha, it is.  but cursor isn't a total function
15:34:44 <joe6> iwtx, check out splitEvery of Data.List.Split
15:34:49 <osfameron> I was wondering if it'd return a Maybe
15:34:57 <ddarius> That said, the original posters second example should be equivalent to that.
15:34:58 <osfameron> (for Data.List.Zipper)
15:35:20 <joe6> anyone knows why this does not work >  take 8 . iterate $ (0 :: Word8)
15:35:26 <Saizan> iwtu: deriving Ord will create a typeclass instance like "instance Ord a => Ord (MyTrie a) where ..." which needs the (Ord a) context to compare the Map a (MyTrie a) field of your Branch constructor
15:35:28 <ddarius> :t iterate
15:35:29 <lambdabot> forall a. (a -> a) -> a -> [a]
15:35:38 <ddarius> I'm betting GHC knows.
15:35:59 <joe6> oh, thanks.
15:36:43 <electronpluspl-1> any ideas iwtu ?
15:37:07 <ddarius> joe6: You want [0 :: Word8 ..] (also written as enumFrom (0 :: Word8) ?
15:37:20 <kmc> > enumFrom (0 :: Word8)
15:37:22 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
15:37:27 <kmc> > drop 250 $ enumFrom (0 :: Word8)
15:37:28 <lambdabot>   [250,251,252,253,254,255]
15:38:19 <kmc> > iterate (const 0)
15:38:20 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> [a])
15:38:20 <lambdabot>    arising from a use of...
15:38:25 <kmc> > iterate (const 0) 5
15:38:26 <lambdabot>   [5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
15:39:16 <ddarius> > iterate 0 5
15:39:17 <lambdabot>   [5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
15:40:13 <kmc> ;P
15:40:16 <kmc> bad lambdabot
15:40:40 <electronpluspl-1> some help  http://hpaste.org/48384
15:40:48 <ddarius> Ooohh, okay.  The original poster's example translates to zip l1 l2 >>= \(x,y) -> [x `seq` y `seq` f x y].
15:40:51 <ddarius> All is clear now.
15:41:27 <ddarius> dons: I recommend my zip l1 l2 >>= \(x,y) -> x `seq` y `seq` [f x y] version then.
15:41:41 <iwtu> electronpluspl-1: wait a second
15:42:05 <dons> ddarius: well spotted.  yes, the list comp desugaring complicates it
15:42:58 <dons> or as augustuss says, its a fluke of the strictness analysis that the one with bangs works in the first place.
15:43:02 <iwtu> Saizan: why this way?
15:43:21 <iwtu> electronpluspl-1: do you know syntax (x:xs) ?
15:43:28 <electronpluspl-1> sure
15:43:29 <mornfall> Is there a way to add a class constraint on a type family?
15:43:37 <electronpluspl-1> Im' trying to use take and drop
15:43:43 <electronpluspl-1> using recursion
15:43:49 <Saizan> iwtu: because that's how typeclasses work
15:45:11 <electronpluspl-1> iwtu: done :)
15:45:11 <iwtu> Saizan: it seems reasonable to me if I use type a in data type with has to be Ord, then all a will be Ord, don't it?
15:45:34 <iwtu> electronpluspl-1: what's problem? :)
15:45:47 <electronpluspl-1> I'm a noob :P
15:45:58 <hpaste> electronplusplus annotated “Mixing list” with “Mixing list (annotation)” at http://hpaste.org/48384#a48385
15:45:59 <iwtu> electronpluspl-1: superb!
15:46:23 <electronpluspl-1> can you explain me why the take needs a pair of [] ? iwtu
15:47:28 <iwtu> electronpluspl-1: what output do you need?
15:47:42 <electronpluspl-1> ["dad","asd","s"]
15:47:43 <Saizan> iwtu: deriving Ord doesn't imply that you'll always use MyTrie for types that have an Ord instance, it's more flexible this way
15:47:48 <electronpluspl-1> something like that
15:48:17 <nostrand> how do i compile for profiling support with GHC 7? i used "ghc -O2 --make flib -prof -auto-all -caf-all -fforce-recomp" but it gives me the error: "ost RTS options are disabled. Link with -rtsopts to enable them"
15:48:28 <electronpluspl-1> the prelude function take already returns a list
15:48:39 <iwtu> so a list. What are elements of the list?
15:48:39 <electronpluspl-1> I don't know why I must put into brackets
15:48:41 <kmc> nostrand, add '-rtsopts- to your ghc options
15:48:51 <kmc> "-rtsopts"
15:48:52 <kmc> sorry
15:49:03 <electronpluspl-1> in a list... numbers, chars...
15:49:15 <electronpluspl-1> partir :: Int -> [a] -> [[a]]
15:49:15 <electronpluspl-1> partir a [] = []
15:49:15 <electronpluspl-1> partir a xs = [take a xs] ++ partir a (drop a xs)
15:49:31 <iwtu> Saizan: really? so why I deriving?
15:49:32 <nostrand> kmc: oh thanks, thought i tried that ><
15:49:37 <kmc> electronpluspl-1, you want (:) not (++)
15:49:43 <kmc> or maybe not?
15:49:44 <electronpluspl-1> : fails
15:49:52 <electronpluspl-1> I want to insert in the end
15:50:11 <iwtu> kmc not
15:50:12 <electronpluspl-1> with : I get an error for infinite lists
15:50:13 <kmc> anyway [x] ++ y is better written x : y
15:50:22 <iwtu> electronpluspl-1:
15:50:43 <kmc> :t let partir a [] = []; partir a xs = take a xs : partir a (drop a xs) in partir
15:50:44 <lambdabot> forall t. Int -> [t] -> [[t]]
15:50:49 <electronpluspl-1> prog.hs:89:0:
15:50:49 <electronpluspl-1>     Occurs check: cannot construct the infinite type: a = [a]
15:50:50 <electronpluspl-1>     When generalising the type(s) for `partir'
15:50:51 <electronpluspl-1> iwtu:
15:51:03 <iwtu> electronpluspl-1: once again. what are the elements of the list :)
15:51:06 <electronpluspl-1> using the : instead of ++
15:51:20 <electronpluspl-1> elements?
15:51:34 <geheimdienst> > 5 : [3,7]
15:51:35 <lambdabot>   [5,3,7]
15:51:49 <geheimdienst> > [2,5] ++ [3,7]
15:51:50 <lambdabot>   [2,5,3,7]
15:51:58 <Saizan> iwtu: so that you don't have to write out the implementation of the instance yourself
15:52:26 <Saizan> iwtu: "deriving" doesn't mean the same as in some OO languages
15:52:45 <iwtu> Saizan: oh... so is something what implies it?
15:53:03 <Saizan> iwtu: what do you mean?
15:53:19 <iwtu> electronpluspl-1: are you here? any problem?
15:53:31 <iwtu> Saizan: I want to declare that I alway
15:53:48 <kmc> if i write «data Foo = Bar Int deriving (Show)» that is the same as writing «data Foo = Bar Int; instance Show Foo where { show (Bar n) = "Bar " ++ show n }»
15:53:52 <kmc> basically
15:54:04 <Saizan> iwtu: there's no way in standard haskell to do that
15:54:05 <electronpluspl-1> iwtu: you question is... weird
15:54:08 <kmc> it just tells the compiler to write the instance for you
15:54:13 <roconnor> Lemmih: email'd
15:54:18 <kmc> it is no different than writing the instance yourself
15:54:20 <ddarius> dons: What augustss is talking about is true, but not exactly related.  This is a half-way strict zipWith'.  It forces the passed in elements before doing the cons, not the result.  It is not a fluke of strictness analysis that this works for the fibs example.
15:54:22 <iwtu> Saizan: I want to declare that if I use a in MyTrie, it will be always instance of Ord
15:54:23 <electronpluspl-1> the elements in the list could be anything
15:54:44 <iwtu> no!
15:54:46 <electronpluspl-1> I ask why I should use [] in the return of take function
15:54:48 <ddarius> (Well, technically the use of seq does allow the bad operational behavior, but replacing them with pseqs would correct that.)
15:54:56 <iwtu> list is homogene data structure
15:55:24 <iwtu> what are element of list in you case? :)
15:55:58 <iwtu> electronpluspl-1: ^ your case
15:56:06 <electronpluspl-1> I don't know
15:56:24 <electronpluspl-1> It's from a simple college exam xD
15:56:40 <iwtu> electronpluspl-1: do you know what type is "hello" ?
15:56:46 <electronpluspl-1> String
15:57:00 <electronpluspl-1> the same as [Char]
15:57:11 <iwtu> electronpluspl-1: > :t String
15:57:23 <electronpluspl-1> ok
15:57:29 <iwtu> > :t String
15:57:30 <lambdabot>   <no location info>: parse error on input `:'
15:57:45 <iwtu> how use the lambabot?
15:58:13 <iwtu> electronpluspl-1: and what is [] ?
15:58:24 <electronpluspl-1> empty list
15:58:43 <Saizan>   :t String doesn't make sense
15:58:43 <iwtu> and what is [Char] ?
15:58:46 <Saizan> :t "hello"
15:58:47 <lambdabot> [Char]
15:59:07 <iwtu> Saizan: ah! :)
15:59:07 <electronpluspl-1> a list of Char elements
16:00:26 <iwtu> electronpluspl-1: so what are elemetns of your desired output? :)
16:00:27 <Lemmih> roconnor: That is one impressive Main module (:
16:00:52 <roconnor> heh
16:00:55 <dobblego>  :t String is a type-checking error
16:01:08 <electronpluspl-1> a list with little lists inside
16:01:12 <roconnor> Lemmih: please don't take this as an indication of the type of code I would release
16:01:32 <iwtu> electronpluspl-1: simply just lists :)
16:01:48 <electronpluspl-1> yeeeesss......
16:01:52 <iwtu> electronpluspl-1: that's why you need []
16:02:15 <electronpluspl-1> oh that makes sense
16:02:29 <electronpluspl-1> and a second ago I was thing in killing you xD
16:02:40 * hackagebot nonlinear-optimization 0.3.5 - Various iterative algorithms for optimization of nonlinear functions.  http://hackage.haskell.org/package/nonlinear-optimization-0.3.5 (FelipeLessa)
16:03:05 <electronpluspl-1> thinging* iwtu
16:03:06 <iwtu> electronpluspl-1: please don't. I really enjoy life :)
16:03:12 <electronpluspl-1> lol
16:04:52 <iwtu> btw, does anyone know Aho-Corasick algorithm?
16:05:12 <kmc> no murdering people in #haskell, it's off topic
16:05:30 <monochrom> but eating is fine
16:05:45 <tsuraan> is there an infix function for "flip (<$>)" ?  It looks like Control.Applicative has (<**>), but that's not quite it
16:05:56 <iwtu> I not sure how to implement the failure function. Is not very ekological to copy trie all the time
16:06:13 <Lemmih> roconnor: How am I supposed to send you patches when you don't use revision control?
16:06:32 <sully> diff
16:06:37 <roconnor> one day I will use revision control
16:07:34 <iwtu> electronpluspl-1: it is a good channel. Really. People are helpful and don't deserve killing or eating
16:07:43 <electronpluspl-1> lol
16:07:45 <copumpkin> roconnor, Lemmih: we need purecoin channel :)
16:08:35 <Lemmih> copumpkin: I'm totally game for that.
16:08:50 <kmc> @remember iwtu [#haskell] is a good channel. Really. People are helpful and don't deserve killing or eating
16:08:50 <lambdabot> Okay.
16:08:52 <copumpkin> I've been playing with a websocket client for mtgox
16:09:04 <copumpkin> but unfortunately I started playing with it when it was down
16:09:04 <kmc> DID SOMEONE SAY BITCOINS?!?!?!?!
16:09:10 <monochrom> no
16:09:12 <copumpkin> and it's still down
16:09:17 <copumpkin> kmc: BYTECOINS
16:09:24 <copumpkin> I HAVE EIGHT TIMES MORE THAN YOU
16:09:26 <monochrom> textcoins
16:09:28 <kmc> i have purestrain bitcoins
16:09:36 <copumpkin> mine are 99.9999% pure
16:09:45 <copumpkin> only the best shit
16:09:45 <monochrom> unicodecoins
16:10:04 <iwtu> failure function in Aho-Corasick? I have got a MyTrie :P
16:10:20 <kmc> anyone invent qbitcoins yet?
16:10:41 <gwern> kmc: I did, but when my counterparty got it, they had collapsed to regular bitcoins
16:10:47 <kmc> sucks bro
16:10:59 <gwern> he left feedback accusing me of scamming him :(
16:11:42 <iwtu> < :t "hello"
16:11:58 <iwtu> > :t "hello"
16:11:59 <lambdabot>   <no location info>: parse error on input `:'
16:11:59 <kmc> :t "hello"
16:12:01 <lambdabot> [Char]
16:12:03 <Lemmih> >:o "hi"
16:12:36 <iwtu> kmc Aho-Corasick failure funcion? :P
16:12:49 <fxr> wohoo, emacs 23 has multisession yayy
16:13:52 <iwtu> but guys. I am really interting how works trees or something where is very useful pointer in imperative programing in Haskell
16:14:30 <gwern> fxr: multisession?
16:14:44 <gwern> fxr: multisession as in emacs --daemon or as in session-mode?
16:14:53 <kmc> iwtu, with GHC, all your data structures have pointers behind the scenes
16:14:56 <iwtu> because build a new tree all the time does not like good idea
16:14:58 <kmc> if you have [Maybe Int]
16:15:06 <dmwit> iwtu: Build a new tree all the time is fine idea.
16:15:17 <kmc> that's a linked list (pointers) of cells with pointers to 'Maybe' cells which have pointers to 'Int' cells which have actual machine ints
16:15:31 <kmc> the nice thing is, data is immutable, so you can share between versions
16:15:35 <iwtu> dmwit: it doesn't waste time, performance and memory?
16:15:44 <kmc> iwtu, if you write sorted tree insert in the naive way
16:15:52 <dmwit> iwtu: Depends.
16:15:53 <kmc> then your new tree ends up sharing most of its nodes with the old tree
16:16:01 <dmwit> iwtu: You can write good algorithms and you can write bad algorithms.
16:16:04 <fxr> gwern: as in emacs --daemon
16:16:08 <dmwit> (as usual with any language)
16:16:09 <kmc> it happens automatically and it's a very general nice property of how Haskell works
16:16:32 <dmwit> iwtu: But Haskell's immutability makes sharing very, very easy and saves a lot of work compared to what you might naively expect.
16:16:34 <sully> allocation is pretty cheap
16:16:36 <monochrom> have you ever shared a mutable tree between several threads?
16:16:43 <kmc> with immutable data there is almost no reason to deep copy ever
16:17:27 <kmc> yes, allocation in GHC is much much cheaper than a typical C malloc
16:17:46 <kmc> it's just incrementing a pointer
16:17:50 <kmc> you pay for it later with GC, though
16:18:27 <iwtu> cause I try fibbonacci sequence do it in recursive way to be sure if Haskell share some data structute but first 100 members of the sequence is a big problem that way
16:18:35 <fxr> now, what I need iz antialiased ttf fontz
16:18:46 <Cale> Yeah, the reason we like immutable tree structures for things which would normally be mutable flat structures is that (a) the interface becomes pure and (b) updates can still be done in log time/space, because you typically only revise a path of the tree from the root to whatever node you updated (and perhaps a constant factor swath around that for balancing)
16:18:52 <monochrom> naive fibonacci coding shares nothing, even in haskell
16:18:58 <kmc> iwtu,  the naive recursive fibonacci sucks and it's nothing to do with haskell or fp
16:19:01 <kmc> it's just a bad algorithm
16:19:14 <kmc> you can however fix that with memoization
16:19:20 <kmc> http://hackage.haskell.org/package/data-memocombinators
16:19:27 <kmc> http://hackage.haskell.org/package/MemoTrie
16:19:29 <monochrom> "f x = blahblah" is a great way to forbid sharing of "f 5"
16:19:29 <Cale> Functions are not automatically memoised in Haskell, because that would mean that you could never GC anything.
16:19:58 <kmc> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
16:19:59 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:20:04 <iwtu> show me the beauty of  immutability in Haskell :)
16:20:07 <monochrom> in fact criterion depends on it fundamentally to ensure repeated computation happens for benchmarking
16:20:23 <Cale> iwtu: Testing comes to mind.
16:20:57 <kmc> the beauty of immutability (in any language): lock-free concurrency, testing, debugging, knowing what the hell your code does
16:21:13 <dobblego> "readability"
16:21:13 <monochrom> reliable almost-instant-critical-section concurrency
16:21:14 <Cale> iwtu: In an imperative language, when you want to test something, you need to create some situation (by mutating the state of the world), then call the procedure you're interested in testing, and then inspect the resulting new world to see if the desired effect happened.
16:21:21 <copumpkin> Lemmih: what made you decide to make an interface to that exchange in particular?
16:21:32 <Lemmih> copumpkin: What?
16:21:34 <geheimdienst> kmc: i'd say that list was in increasing order of importance
16:21:40 <Cale> and often this involves making a copy of some things before calling the procedure so you can compare the result after
16:21:46 <dobblego> just a few weeks ago, 5 developers stood around 5 lines of code (a loop) and tried explaining to each other what it does -- none of them got it right -- I seized the moment
16:21:56 <Cale> With pure functions and immutable data, that doesn't come up.
16:22:08 <copumpkin> Lemmih: oh, mybitcoin.com
16:22:13 <kmc> BITCOIN BITCOIN BITCOIN
16:22:14 <copumpkin> I thought it was an exchange but it doesn't loook like one
16:22:17 <copumpkin> kmc: exactly
16:22:20 <kmc> have u herd of bitcoin?!?!?
16:22:32 <kmc> "an easy to use interface with large navigation buttons"
16:22:40 <monochrom> hahaha
16:22:42 <kmc> yeah, I always thought the main problem with Bitcoin was that the buttons aren't big enough
16:22:52 <copumpkin> lol
16:22:57 <Eduard_Munteanu> I too wonder what this new interest in btc is...
16:23:07 <iwtu> Cale: can you show me some code? for example in Haskell and C++,C, Java?
16:23:14 <Cale> We have a library called QuickCheck, which supplies random data to a given function and tries to see if it can find inputs which make the function False.
16:23:35 <iwtu> Cale: it is really the fastest way to understand things
16:23:41 <Cale> @check \xs -> reverse (reverse xs) == (xs :: [Integer])
16:23:42 <lambdabot>   "OK, passed 500 tests."
16:23:58 <Cale> (this is just applying the quickCheck function from that library)
16:23:58 <Eduard_Munteanu> kmc: but u know confluecne?!!1
16:24:02 <parcs> > read "()"
16:24:03 <lambdabot>   ()
16:24:03 <kmc> iwtu, write a binary tree class in Java.  now make it so that insertion doesn't mutate the old copy but shares most of its storage
16:24:10 <kmc> now make that API feel natural in Java
16:24:21 <Cale> So, if reverse here was destroying the original list xs
16:24:31 <Cale> (updating it with a new list)
16:24:38 <Cale> then this test wouldn't quite mean the same thing
16:24:42 <kmc> that's 4 lines of Haskell code
16:24:43 <kmc> in fact it's the most naive implementation of a binary tree
16:24:43 <kmc> you get sharing for free
16:24:58 <Lemmih> copumpkin: I'm using mybitcoin because I don't yet have a Haskell bitcoin implementation with an acid-state backend. (:
16:25:18 <Cale> This test would always pass of course, even with a broken implemenetation of reverse, if reverse edited the original list
16:25:22 <copumpkin> Lemmih: ah :)
16:25:25 <kmc> BREAKING NEWS: Internet still cannot shut up about Bitcoins
16:25:26 <kmc> Film at 11
16:25:28 <gwern> @wn aceldama
16:25:29 <lambdabot> No match for "aceldama".
16:25:32 <Cale> Yes?
16:25:38 * copumpkin feels kmc has an issue here :P
16:25:40 <gwern> kmc: hey, bitcoins are cool
16:25:49 <kmc> a million bitcoins isn't cool
16:25:55 * roconnor was researching using acid-state as a backend
16:26:07 <dobblego> http://functionaljava.googlecode.com/svn/artifacts/3.0/javadoc/fj/data/TreeMap.html
16:26:14 <Lemmih> roconnor: It's not really a perfect match.
16:26:30 <gwern> kmc: actually, a million is cool since you can't have a billion...
16:26:35 <roconnor> Lemmih: for wallet data or for block data?
16:26:42 <Lemmih> roconnor: I was thinking of at least storing the keys with acid-state.
16:26:52 <roconnor> ok
16:26:57 <roconnor> I haven't even thought about that
16:27:27 <geheimdienst> dobblego: nice link
16:27:45 <dobblego> ta
16:27:50 <iwtu> I have not clear how does it work and where is the power
16:28:03 <Peaker> geheimdienst: repeat the link?
16:28:44 <sam2> Can someone help me with this code?
16:28:45 <sam2> http://hpaste.org/48380
16:28:57 <iwtu> kmc: so all type are immutable and share in function?
16:29:13 <Eduard_Munteanu> <Parse error>
16:29:14 <kmc> all values are immutable
16:29:17 <kmc> (that's what a value is)
16:29:19 <geheimdienst> one thing to be said for that kind of interface is it lets you say stuff like tree.set(firstThing, 42).set(secondThing, 23).set...
16:29:26 <geheimdienst> Peaker: http://functionaljava.googlecode.com/svn/artifacts/3.0/javadoc/fj/data/TreeMap.html
16:29:30 <kmc> there are mutable things in Haskell; they are not values
16:29:34 <kmc> best not to worry about them now
16:30:01 <sully> kmc: iorefs aren't values...?
16:30:24 <Eduard_Munteanu> IORefs are immutable ;)
16:30:26 <kmc> the reference cell itself is not a value
16:30:32 <kmc> it's "named" by a value
16:30:44 <kmc> that value always refers to the same cell, but the contents of that cell vary over time
16:31:22 <iwtu> and what recursive fibbonaci fails?
16:31:29 <sully> hm, yeah, I guess that's true
16:31:43 <kmc> iwtu, «fib n = fib (n-1) + fib (n-2)» fails just because it duplicates a bunch of work
16:31:49 <kmc> fib 10 = fib 9 + fib 8; fib 9 = fib 8 + fib 7
16:31:54 <kmc> you compute «fib 8» twice
16:32:06 <iwtu> btw, for fun if you mentioned stupid algorithms. Have you heard about sleepsort?
16:32:11 <kmc> yes
16:32:25 <iwtu> :)
16:33:11 <hpaste> monochrom pasted “thread-safe container example” at http://hpaste.org/48388
16:33:24 <geheimdienst> i feel this is a good time to mention shlemiel the painter's algorithm
16:33:39 <iwtu> what exactly `=' doeas? I have figured out let m = ... m is not a good idea
16:33:48 <kmc> no, it's a fine idea
16:34:06 <Eduard_Munteanu> iwtu: it does nothing, it's just a definition
16:34:13 <Axman6> iwtu: = is like = in mathematics
16:34:14 <kmc> "let x = y" just says that x is a local name for the expression y
16:34:16 <monochrom> http://hpaste.org/48388 is thread-safe concurrent almost-instant-critical-section update of a balanced binary search tree
16:34:16 <iwtu> it doen't work in MyTrie
16:34:24 <Axman6> > let x = 1 + 2 in x
16:34:25 <lambdabot>   3
16:34:37 <Eduard_Munteanu> > 1 + 2
16:34:38 <lambdabot>   3
16:34:39 <Axman6> x is the name of the expression 1 + 2
16:34:39 <kmc> iwtu, http://hpaste.org/48389
16:34:49 <monochrom> you just take an ordinary balanced binary search tree and slap a TVar or MVar on it
16:34:54 <kmc> when you construct a new Node, you point back into either the whole tree 'l' or the whole tree 'r'
16:35:05 <monochrom> no extra work necessary because the tree is immutable
16:35:05 <kmc> any decent Haskell tutorial will cover "let"
16:35:21 <monochrom> or rather, the trees throughout history
16:35:29 <Axman6> monochrom: you'll get much better performance using IORefs and atomicModifyIORef
16:35:33 <kmc> yes it's nice to have people motivate why the language is worth learning
16:35:41 <monochrom> yeah
16:35:41 <kmc> but we've given several examples
16:36:04 <kmc> unfortuantely there's more stuff to learn before the examples will fully make sense
16:37:14 <sam2> can someone help with declaring types???
16:37:19 <kmc> yes
16:37:21 <monochrom> but I write an STM transaction anyway because perhaps the set is just part of a larger thing. you see I don't even atomically in case you want to do something else alongside
16:37:25 <sam2> I have this code...
16:37:32 <sam2> Not sure why its not working...
16:37:33 <sam2> let x = x :: T103 in value x
16:37:37 <sam2> oops
16:37:44 <sam2> http://hpaste.org/48380
16:37:47 <kmc> let x :: T103; x = x in value x
16:38:04 <iwtu> kmc I think I get it
16:38:06 <Axman6> monochrom: i think you accidently the verb D:
16:38:20 <kmc> but that works too
16:38:23 <kmc> ok, that's not your question
16:38:46 <sam2> I get error when I'm trying to do show
16:38:56 <kmc> sam2, in standard Haskell the 'q' in the second line of your instance is unrelated to the 'q' in the first line
16:39:01 <kmc> they are both free variables
16:39:10 <kmc> so you can turn on GHC's ScopedTypeVariables extension
16:39:33 <kmc> instance forall q. (IntegerAsType q) => Show (Zq q) where ...
16:39:44 <kmc> or you can play tricks to get them to be the same
16:40:03 <kmc> show v@(Zq x) = show x ++ " mod " ++ show (value v)
16:40:04 <Axman6> don't you just need (Show q, IntegerAsType q) => Show (Zq q)?
16:40:28 <kmc> or maybe it's just show (value x)
16:40:29 <sam2> I'm confused...
16:40:35 <Axman6> you're being too clever for your own good kmc :P
16:41:02 <iwtu> there http://paste.pocoo.org/show/420627/ I can do let m = insertMyTrie "foo" Leaf but then let m = insertMyTrie "pizet" m doesn't work
16:41:11 <Axman6> sam2: i think you can fix it with: instance (Show q, IntegerAsType q) => Show (Zq q) where show x = ...
16:41:25 <parcs> > let ~(!(_)) = undefined in x
16:41:26 <lambdabot>   x
16:41:48 <monochrom> ! is redundant there
16:42:12 <kmc> lazy strict pattern
16:42:13 <kmc> i like it
16:42:13 <sam2> I get the same error apparently...
16:42:16 <monochrom> ~(x, !y) would be more interesting
16:42:20 <kmc> sam2, did you try what i said?
16:42:24 <iwtu> and why is allocation much much more cheaper than in C?
16:42:49 <electronpluspl-1> [ if(odd x) then (-x) else x | x<-[2..11]]
16:42:53 <electronpluspl-1> > [ if(odd x) then (-x) else x | x<-[2..11]]
16:42:54 <lambdabot>   [2,-3,4,-5,6,-7,8,-9,10,-11]
16:42:58 <kmc> iwtu, because you don't have a free list, you just allocate after the last bit of heap you used, and let garbage pile up
16:43:06 <kmc> then later you garbage-collect it all
16:43:10 <kmc> GHC's GC is generational
16:43:11 <electronpluspl-1> what if I don't want to use the else statement?
16:43:18 <kmc> it makes the assumption that there are many short-lived objects
16:43:22 <electronpluspl-1> How do I say that then is over?
16:43:22 <Eduard_Munteanu> Compared to the *standard* C allocation routines.
16:43:29 <kmc> if objects become longer lived, they are moved to another heap which is checked less frequently
16:43:32 <sam2> um... do I write for all q?
16:43:46 <kmc> sam2, try it without ScopedTypeVariables
16:44:05 <kmc> show (Zq x) = show x ++ " mod " ++ show (value x)
16:44:05 <monochrom> > case ((), undefined) of (x,!y) -> x
16:44:06 <lambdabot>   *Exception: Prelude.undefined
16:44:16 <monochrom> > case ((), undefined) of (x,y) -> x
16:44:16 <lambdabot>   ()
16:44:17 <kmc> doesn't 'x' already have the type you need?
16:44:20 <monochrom> yeah :)
16:44:32 <iwtu> electronpluspl-1: you have to always use the `else' statement
16:44:33 <kmc> sam2, if you wanted to be a bit more explicit you could say (undefined `asTypeOf` x)
16:44:36 <kmc> where
16:44:47 <kmc> asTypeOf :: a -> a -> a; asTypeOf y x = y
16:45:16 <iwtu> kmc: and why the `let' doesn't work in my case?
16:45:25 <kmc> which let
16:45:32 <electronpluspl-1> iwtu: always? or are you saying always using comprehension lists?
16:45:39 <kmc> i didn't see your code?
16:45:54 <danharaj> http://stackoverflow.com/questions/6487632/bentley-ottmann-algorithm-in-haskell
16:45:55 <danharaj> halp :[
16:46:31 <iwtu> kmc: http://paste.pocoo.org/show/420627/
16:47:36 <kmc> i don't see any 'let'
16:48:45 <kmc> if you paste on hpaste, it will give you coding usggestions
16:48:54 <iwtu> electronpluspl-1: In Haskell is everything an expression and every expression has to be a value. You if you use `if .., then ' then you have to use `else' in order to have some value
16:49:18 <electronpluspl-1> function _ is the same as function [_], right?
16:49:20 <kmc> iwtu, last line:  [x:xs | (x,y) <- M.assocs m , xs <- traversalMyTrie y]
16:49:20 <sam2> kmc, I'm not really sure why this doesn't even work
16:49:22 <sam2> http://hpaste.org/48390
16:49:28 <kmc> better than using fst and snd
16:49:51 <monochrom> function _ is not the same as function [_]
16:50:11 <kmc> sam2, what did you type at the GHCi prompt?
16:50:18 <augur> :|
16:50:20 <kmc> it's complaining that what you typed at the prompt had ambiguous type
16:50:22 <augur> edwardk has abandoned me!
16:51:03 <sam2> isn't it supposed to define show?
16:51:09 <fxr> do you use emacs with ttf fonts, if so, which fonts do you like most?
16:51:14 <kmc> sam2, what did you type at the GHCi prompt?
16:51:15 <kmc> it's complaining that what you typed at the prompt had ambiguous type
16:51:28 <monochrom> evidently, in (Zq x), x's type is not guaranteed to be an instance of Show
16:51:30 <kmc> "Error:     In a stmt of an interactive GHCi command"
16:51:32 <sam2> I typed Zq 4
16:51:37 <sam2> Zq 4
16:51:48 <augur> hey peeps
16:51:49 <augur> hows life
16:52:02 <sam2> I'm not sure how I define it as T12 or T103
16:52:11 <kmc> Zq 4 :: Zq T103
16:52:14 <kmc> just type that
16:52:26 <sam2> oh.. it worked...
16:52:35 <monochrom> the line "show (Zq x) = show x" is already erroneous. it does not matter how you use it
16:52:49 <kmc> btw i don't think the constraint on your newtype will be very useful
16:53:03 <monochrom> this is not python where a function's validity is only checked at call sites
16:53:05 <kmc> could be wrong
16:53:23 <kmc> monochrom, it's OK because the component always has type "Integer" no matter w hat q is
16:53:26 <kmc> q is a phantom type parameter
16:53:33 <sam2> this wouldn't work??
16:53:34 <sam2> show (Zq x) = show x ++ " mod " ++ (show (value (undefined :: q)))
16:53:41 <kmc> i already explained that too
16:53:52 <sam2> yes... but I was confused... I apologize
16:53:59 <kmc> it's ok
16:54:01 <monochrom> oh, sorry
16:54:07 <kmc> if you use 'q' in the 'instance' line
16:54:10 <Axman6> sam2: why not use x instead of undefined :: q?
16:54:15 <kmc> that 'q' has nothing to do with any 'q' on the next line
16:54:27 <kmc> as far as GHC is concerned, they're totally unrelated variables which happen to have the same name
16:54:29 <iwtu> http://codepad.org/YUN4335W now I don't see problem but in ghci let m .. let n .. let m makes trouble
16:54:32 <kmc> it's a little silly yes
16:55:15 <kmc> (show (value x)) or, if you want to be more explicit and safe, show (value (undefined `asTypeOf` x))
16:55:23 <kmc> i gave the definition of asTypeOf before
16:55:34 <kmc> did that make sense, and if not, which particular part?
16:55:52 <Axman6> iwtu: are you using let m = ... m ...? if you are, then you're using the same m, leading to an infinite loop
16:56:06 <kmc> it might not be an infinite loop
16:56:11 <iwtu> Axman6: why?
16:56:17 <kmc> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
16:56:18 <lambdabot>   not an expression: `let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)'
16:56:21 <kmc> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
16:56:22 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:56:33 <iwtu> probably it is
16:56:33 <kmc> iwtu, "let" is not assignment.  you're not giving a new value to an old variable
16:56:34 <monochrom> > let m = () : m in m
16:56:34 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
16:56:38 <kmc> variables have one value now and forever
16:56:46 <kmc> they can however be defined recursively
16:56:48 <Axman6> in that case it is an infinite loop, because it's trying to pattern match on something which is being defined, which means it must be evaluated to figure out which constructor it is
16:56:56 <monochrom> it is the only way I can write recursion, so why not
16:57:05 <Axman6> and to evaluate it, it needs to pattern match on itself again, and so on
16:57:24 <electronpluspl-1> iwtu: http://oi56.tinypic.com/15phfyh.jpg
16:57:45 <monochrom> (c)
16:57:48 <Axman6> what you have is let m = insert "pizzet" m -> let m = insertMyTrie "pizzet" (insertMyTrie "pizzet" m) -> let m = insertMyTrie "pizzet" (insertMyTrie "pizzet" (insertMyTrie "pizzet"))
16:57:50 <kmc> (e)
16:58:03 <monochrom> haha
16:58:07 <electronpluspl-1> from portuguese to english: "What type has the same meaning as the following Haskell type?"
16:58:12 <electronpluspl-1> iwtu:
16:58:22 <kmc> electronpluspl-1, we are not going to do your homework for you
16:58:32 <electronpluspl-1> kmc: not homework :\
16:58:41 <sam2> kmc: did you mean    show (Zq x) = show x ++ " mod " ++ (show (value x))
16:58:42 <electronpluspl-1> I have an exam tomorrow
16:58:44 <kmc> we are not going to do your exam for you either
16:58:48 <kmc> sam2, probably
16:58:52 <iwtu> electronpluspl-1: man I hardly know English... but this is clear  in any langue :P try :P
16:58:58 <othiym23> fxr: I use Consolas in Emacs, same as in everything else, with antialiasing turned on, and I love it
16:59:10 <sam2> apparently
16:59:12 <electronpluspl-1> kmc: that's a question that comes every single year in this exam
16:59:19 <kmc> you can test it in GHCi
16:59:25 <sam2>     Could not deduce (IntegerAsType Integer)
16:59:29 <kmc> or just think about how function application works
16:59:30 <Axman6> electronpluspl-1: do you know what the type f :: (a -> b) -> c -> a -> b means?
16:59:31 <iwtu> electronpluspl-1: ok, it is right associative
16:59:38 <monochrom> I don't care whether it is an exam or not
16:59:45 <electronpluspl-1> Axman6: no
17:00:05 <monochrom> but I applaud for posting the verbatim question
17:00:37 <monochrom> other people do a lot of damage by "rephrase the question in your own words so as to show you are clueless"
17:00:53 <Axman6> electronpluspl-1: ok, well it says f is a function which takes a frunction from a to b (the (a -> b) part), and a c, and an a and returns a b
17:01:30 <Axman6> now does f in the question take another function as an argument?
17:01:31 <iwtu> electronpluspl-1: do you understand meaning of space in Haskell?
17:01:40 <Axman6> o.O
17:01:56 <monochrom> the meaning of space is pretty deep in haskell actually :)
17:02:04 <electronpluspl-1> iwtu: space?
17:02:09 <Clint> outer space
17:02:24 * Axman6 has no idea what either of you are on about
17:02:30 <iwtu> monochrom: let say just for separarint arguments :P
17:02:48 <monochrom> "from the authors of Real World Haskell... a new book for the next generation of programmers... Deep Space Haskell" :)
17:03:06 <iwtu> monochrom: :D
17:03:30 <electronpluspl-1> Axman6: no, it doesn'r
17:03:34 <electronpluspl-1> doesn't*
17:03:37 <iwtu> electronpluspl-1: do you know any other language? wich?
17:03:49 <Axman6> electronpluspl-1: ok, so it can't be A can it?
17:03:50 <electronpluspl-1> C, C++, java, Pascal, Javascript, PHP, etc
17:04:16 <electronpluspl-1> no
17:04:18 <Axman6> (a)*
17:04:21 <Axman6> ok
17:04:28 <kmc> electronpluspl-1, you get a hug for not saying "C/C++"
17:04:36 <Axman6> and do you understand what the type f :: (a,b) -> a means?
17:04:43 <ksf> what do you think, in gobject-based bindings, should I make non-classed objects newtypes with a bunch of ReadWriteAttrs instead of simple ADTs with Storable instance?
17:04:53 <evaryont> I'm missing something, but I don't know what: `dbusCommand :: String => String => String -> String` -- should be a function that takes 3 string parameters and returns a string. I get "Type constructor `String' used as a class" as an error. :-/
17:04:55 <iwtu> hi guys. can I help him?
17:05:02 <iwtu> :P
17:05:06 <electronpluspl-1> Axman6: no
17:05:16 <Axman6> electronpluspl-1: do you know what a tuple is?
17:05:17 <evaryont> iwtu: you can help me, if you want :D
17:05:21 <electronpluspl-1> Axman6: yes
17:05:33 <dmwit> evaryont: Use (->) instead of (=>).
17:05:35 <monochrom> "dbusCommand :: String => String => String -> String" is very wrong
17:05:46 <evaryont> monochrom: I figured that :P
17:05:48 <ksf> monochrom, not if there were a typeclass named String.
17:05:57 <iwtu> wait wait wait. don't confused that gut
17:06:03 <iwtu> *guy
17:06:07 <Axman6> electronpluspl-1: so can you see that (a,b) is the type of a tuple with an a in the first place, and a b in the second?
17:06:17 <monochrom> ksf, have you tried?
17:06:27 <ksf> indeed I have.
17:06:29 <evaryont> dmwit: ah, thanks!
17:06:32 <iwtu> I don't know much about haskell but I know how the brain learn
17:06:35 <monochrom> with two =>'s, no less
17:06:37 <electronpluspl-1> Axman6: yes
17:06:44 <ksf> monochrom, more, even.
17:06:55 <ksf> it's the same as writing a (,,,) list
17:07:00 <iwtu> electronpluspl-1: so, the quiz question?
17:07:03 <Axman6> electronpluspl-1: ok, so now cany you see that f :: (a,b) -> a takes a tuple with an a and a b, and returns an a?
17:07:26 <monochrom> and it is a zero-parameter type class?
17:07:27 <fxr> othiym23: thanks, will try it now. Actually I don't like Monaco ttf.
17:07:34 <Axman6> can*
17:07:40 <ksf> monochrom, now you're getting into meaningless detail.
17:08:04 <evaryont> dmwit: now I get a new error, hah. calling the function within another one, it gets me a "No instance for `(Num String)'" - code: foo :: String -> String ; foo x = dbusCommand "a" "b" (">" + x)
17:08:11 <electronpluspl-1> Axman6: it returns the same type of a , i suppose
17:08:12 <monochrom> well I commented on exactly "dbusCommand :: String => String => String -> String"
17:08:20 <monochrom> and you did too
17:08:28 <ksf> evaryont, try ++
17:08:31 <ksf> :t (+)
17:08:32 <byorgey> evaryont: + is for adding numbers, ++ is for concatenating strings
17:08:32 <lambdabot> forall a. (Num a) => a -> a -> a
17:08:33 <ksf> :t (++)
17:08:34 <lambdabot> forall m. (Monoid m) => m -> m -> m
17:08:41 <ksf> @slap cale
17:08:42 * lambdabot pulls cale through the Evil Mangler
17:08:54 <byorgey> :t Prelude.(++)
17:08:56 <lambdabot> Not in scope: data constructor `Prelude'
17:09:00 <iwtu> electronpluspl-1: want to understand? I can tell you in simple way :P
17:09:00 <Axman6> evaryont: (+) is for adding numbers
17:09:03 <byorgey> :t P.(++)
17:09:04 <lambdabot> Not in scope: data constructor `P'
17:09:07 <ksf> :t (Prelude..)
17:09:08 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
17:09:11 <ksf> :t (Prelude.++)
17:09:11 <evaryont> byorgey: ooh yeah >.<
17:09:12 <lambdabot> forall a. [a] -> [a] -> [a]
17:09:14 <electronpluspl-1> iwtu: say it
17:09:16 <electronpluspl-1> lol
17:09:25 <iwtu> electronpluspl-1: or I go to sleep :)
17:09:39 <electronpluspl-1> iwtu: fart it out
17:09:41 <ksf> byorgey, don't worry, that's probably the second most ugly part of haskell syntax.
17:09:57 <Axman6> electronpluspl-1: so, from that, you should be able to see that f in your example doesn't take in a tuple does it?
17:10:05 <byorgey> yeah, I can never remember which way it was supposed to be, especially after there was a proposal to change it
17:10:15 <electronpluspl-1> Axman6: no, it doesn't
17:10:25 <Axman6> so it can't be (d)
17:10:34 <Axman6> what about (b)?
17:11:04 <electronpluspl-1> more likely, I think
17:11:04 <iwtu> electronpluspl-1: allright. I have no idea what exactly the Axman6 wants to say but listen to him. I go sleep
17:11:18 <electronpluspl-1> Thanks anyway iwtu :)
17:11:19 <iwtu> good night everyone! :)
17:11:21 <Axman6> electronpluspl-1: why? it's got a tuple in the type doesn’t it?
17:11:38 <evaryont> yay it compiles! thanks, yet again, #haskell :P
17:11:50 <electronpluspl-1> hmm you're right.... A or C
17:13:00 <electronpluspl-1> Axman6: I think it's A
17:13:15 <Axman6> electronpluspl-1: yeah, they're the two most likely. the answer is (c), and I'll show you why. In haskell, functions don't have to take all their arguments at the same time like they do in C or Java.
17:13:20 <kmc> electronpluspl-1, how many weeks into the course is this exam?
17:13:32 <electronpluspl-1> kmc: 7 hours
17:13:43 <kmc> how's that worK?
17:13:50 <electronpluspl-1> fine so far
17:14:03 <Axman6> electronpluspl-1: a function with typo f :: a -> b -> c is actually f :: a -> (b -> c), because you can give it an a, and you'll get back a function that takes a b, and returns a c
17:14:03 <electronpluspl-1> kmc: you're from USA, right?
17:14:07 <kmc> yes
17:14:30 <electronpluspl-1> portuguese college is a shit compared to usa college
17:14:53 <kmc> they expect you to know Haskell after 7 hours?
17:14:56 <electronpluspl-1> for example: I can miss non-pratical classes
17:15:22 <Axman6> :t let f :: String -> Int -> String; f str int = str ++ " " ++ show int in f
17:15:23 <lambdabot> String -> Int -> String
17:15:29 <Axman6> :t let f :: String -> Int -> String; f str int = str ++ " " ++ show int in f "Hello"
17:15:30 <lambdabot> Int -> String
17:15:37 <Axman6> :t let f :: String -> Int -> String; f str int = str ++ " " ++ show int in f "Hello" 7
17:15:38 <lambdabot> String
17:16:03 <Axman6> > let f :: String -> Int -> String; f str int = str ++ " " ++ show int in f "Hello" 7
17:16:05 <lambdabot>   "Hello 7"
17:16:20 <Axman6> > let f :: String -> Int -> String; f str int = str ++ " " ++ show int in map (f "Hello") [1..10]
17:16:21 <lambdabot>   ["Hello 1","Hello 2","Hello 3","Hello 4","Hello 5","Hello 6","Hello 7","Hel...
17:16:28 <kmc> you can miss classes in most american schools too
17:17:11 * monochrom is not sure why there is much to explain or justify in x->y->z being x->(y->z). it is the same question as "why" x/y/z is (x/y)/z. there is no why. there is just a social consensus on omitting parentheses
17:17:21 <kmc> electronpluspl-1, so the class literally started 7 hours ago? or do you mean you had 7 hours of lecture so far?
17:17:46 <electronpluspl-1> 10 weeks course but I've just started learning 7 hours ago
17:17:56 <kmc> why so recent?
17:17:56 <Axman6> electronpluspl-1: most universities don't have compulsory lectures. they expect students to be adult enough to know that they're only hurting themselves by not going to lectures
17:18:13 <kmc> Axman6, or, to decide the lectures actually aren't worth the time in which case, why should the school force you to go?
17:18:18 <sam2> I changed my code to this... http://hpaste.org/48391
17:18:24 <kmc> if you get more out of reading at home, you should do that
17:18:25 <Axman6> kmc: that soo
17:18:42 <sam2> it says Could not deduce (IntegerAsType Integer)
17:18:50 <kmc> yes
17:18:51 <Axman6> i get a lot more out of lectures than i ever have reading (being dyslexic tends to make you that way)
17:18:59 <kmc> the thing inside the Zq constructor is an Integer
17:19:00 <kmc> maybe you want
17:19:07 <kmc> show x = show (value x)
17:19:09 <kmc> or more likely
17:19:19 <kmc> show v@(Zq x) = show x ++ " mod " ++ show (value v)
17:19:23 <kmc> do you know how @-patterns work?
17:19:33 <ksf> does it make sense to use a 2x2 matrix for top-left x y, bottom-right x y?
17:19:34 <sam2> no... how does @ work?
17:19:39 <Axman6> oh i know what's wrong there, why do you have the newtype containing an Integer?
17:19:47 <kmc> the pattern x@p matches the same things as the pattern p
17:19:54 <kmc> but it also binds the variable 'x' to the whole thing matched
17:19:59 <ksf> the good thing is that I would safe code the bad thing is that I could enrage you math nerds.
17:20:02 <kmc> you need to call 'value' on the Zq, not the Integer
17:20:08 <kmc> Axman6, phantom type parameter to set the modulus
17:20:39 <monochrom> > case (1,True) of v@(x,y) -> show x ++ " " ++ show v
17:20:40 <lambdabot>   "1 (1,True)"
17:20:50 <Axman6> then show (value x) won't work, there's no instance for TypeAsInteger Integer
17:21:07 <kmc> right, you need to call 'value' on the Zq value, not the thing inside
17:21:09 <sam2> instance (IntegerAsType q) => Show (Zq q) where
17:21:09 <sam2> ?
17:21:22 <kmc> that line is fine
17:21:31 <kmc> read what we said above
17:21:33 <Axman6> sam2: that's fine, but the x there is an Integer
17:21:42 <kmc> if it doesn't make sense, please tell us why and we'll try to clarify
17:22:03 <Axman6> what you were doing originally will work, if you use ScopedTypeVariables i think (is that the right name?)
17:22:22 <kmc> it's not necessary though
17:22:23 <Axman6> kmc: my apologies
17:22:30 <Axman6> no?
17:22:36 <kmc> the argument to 'show' already has the right type, doesn't it?
17:22:48 <kmc> (i was talking to sam2 just now)
17:23:09 <monochrom> kmc: I observed a strange behaviour of many beginners in math channels. if someone's explanation doesn't work, the asker doesn't follow up, the asker just pretends the explanation never happened. I still don't understand why
17:23:17 <Axman6> the argument to show is something of type (TypeAsInteger q) => Zq q, but the x is always an Integer
17:23:18 <kmc> indeed
17:23:34 <kmc> oh, hmm
17:23:41 <kmc> yeah, it's not that simple
17:23:48 <Axman6> so, i think you do actually need scoped type variables
17:23:57 <ezyang> monochrom: Maybe they think that the comment was for another conversation?
17:24:20 <kmc> instance (IntegerAsType t) => IntegerAsType (Zq t) where value (Zq x) = value x
17:24:23 <monochrom> evidently not with a heavy dose of "<kmc> asker: ..."
17:24:29 <Axman6> because you need to use something of type q to be able to use `value`, and the only way to do that is with undefined :: q
17:24:30 <kmc> or just change 'value' to take "Zq a" instead of 'a'
17:24:53 <kmc> or even just write a function
17:25:22 <monochrom> or alternatively with a heavy dose of "... Zq ..."
17:25:29 <Eduard_Munteanu> The explanation might be too complex, so they pretend it didn't happen so a simpler one comes up. They don't want to understand it, they want another one. Anyway, that's my guess.
17:25:35 <kmc> asZq :: Zq a -> a -> Integer; asZq (Zq x) y = value y
17:25:41 <kmc> then you use "asZq v undefined"
17:25:44 <Eduard_Munteanu> s/so/hoping/
17:25:50 <kmc> so you can play these tricks to avoid ScopedTypeVariables
17:25:53 <kmc> but it does make the code uglier
17:26:04 <sam2> so much stuff going on so fast... I'm trying to read and understand...
17:26:20 <Axman6> show v@(Zq x) = show x ++ " mod " ++ show (value y) where Zq y = Zq undefined `asTypeOf` v
17:26:26 <Axman6> hmm, no
17:26:27 <monochrom> you have 4GB of RAM. use it for scroll buffer
17:27:27 <Axman6> show v@(Zq x) = show x ++ " mod " ++ show (value (fromZq v)) where fromZq :: Zq a -> a; fromZq _ = undefined
17:27:36 <Axman6> bingo?
17:29:17 <Axman6> kmc: does that look right?
17:29:33 <kmc> maybe
17:29:36 <kmc> let's try it :)
17:30:29 <Peaker> monochrom: sentences beginning with "you have 4GB of RAM" are the reason we have Wirth's law :-)  http://en.wikipedia.org/wiki/Wirth's_law
17:30:57 <kmc> better yet let's let sam2 try it
17:31:15 <Axman6> well, the file loads...
17:32:09 <Axman6> and works fine =)
17:32:29 <sam2> um... it works...
17:32:35 <sam2> but give me some time to think through
17:32:56 <Axman6> the important part is the type of fromZq
17:33:19 <HugoDaniel> hmm
17:33:22 <kmc> yeah, think i like your solution better than any of mine Axman6
17:33:38 <Axman6> took long enough though =)
17:33:39 <HugoDaniel> is there an easy way to do this: Maybe [a] -> [a]  ?
17:33:44 <kmc> though maybe there's a more general design issue though
17:33:50 <HugoDaniel> when Nothing just returns []
17:33:51 <Axman6> :t maybe
17:33:51 <kmc> :t fromMaybe []
17:33:52 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:33:53 <lambdabot> forall a. Maybe [a] -> [a]
17:34:16 <sam2> what does semicolon do in haskell?
17:34:17 <Axman6> > maybe [] id Nothing
17:34:18 <lambdabot>   []
17:34:28 <Axman6> > maybe [] id (Just [1,2,3])
17:34:29 <lambdabot>   [1,2,3]
17:34:32 <ddarius> sam2: It's just syntax.  It separates one syntactic construct from another.
17:34:42 <ddarius> I.e. nothing.
17:35:03 <kmc> sam2, spaces and newlines are syntactic sugar for braces and semicolons
17:35:36 <sam2> I see...
17:35:55 <kmc> one nice property of Haskell's whitespace sensitive syntax is that it's optional
17:35:57 <sam2> still trying to digest Axman6
17:36:08 <kmc> no don't eat him
17:36:24 <Axman6> D:
17:36:27 <Axman6> ow
17:36:32 <kmc> om nom nom
17:36:33 <monochrom> I think he's already eaten
17:37:07 <xman6> :O
17:37:22 <sam2> for the last time... what does @ mean?
17:37:32 <kmc> the pattern x@p matches the same things as p
17:37:39 <kmc> but it also binds x to the whole thing matched
17:37:45 <Peaker> one unnice property of Haskell's whitespace sensitive syntax is that it's optional... Larger and more complex syntax (that virtually no one uses anyway)
17:37:48 <xman6> > let f xss@(x:xs) = (x,xs,xss) in f [1,2,3]
17:37:50 <lambdabot>   (1,[2,3],[1,2,3])
17:38:00 <kmc> Peaker, I use parts of it frequently
17:38:10 <Peaker> kmc: which parts?
17:38:16 <kmc> do x <- y; f x
17:38:16 <xman6> > let f x@(Just _) = x in f (Just 7)
17:38:17 <lambdabot>   Just 7
17:38:25 <xman6> > let f x@(Just _) = x in f Nothing
17:38:26 <lambdabot>   *Exception: <interactive>:3:4-19: Non-exhaustive patterns in function f
17:38:28 <kmc> not literally such, i would use fmap or (>>=), but cases do come up
17:38:49 <kmc> also let x :: t; x = foo
17:38:55 <HugoDaniel> thanks :)
17:38:57 <kmc> if i have a bunch of them as boilerplate
17:39:02 <kmc> and each one is short individually
17:39:13 <ddarius> I am very glad that indentation is optional.
17:39:20 <kmc> occasionally i use let-in-do with braces
17:39:21 <Peaker> kmc: well, semicolons are a special case...
17:39:30 <Peaker> kmc: for example, Python has semicolons but not {}
17:39:52 <Peaker> kmc: (yet it's indentation based syntax is not considered "optional")
17:40:20 <kmc> i think for the benefit of code-generating tools we should keep optional layout
17:40:25 <kmc> also for the benefit of blind programmers
17:40:49 <Peaker> we have  blind Haskell programmers?
17:40:52 <ddarius> Yes.
17:41:03 <ddarius> I've personally interacted with at least two.
17:41:05 <kmc> there's some code in Hackage which uses non-layout for this reason, i think
17:41:22 <monochrom> there is one on haskell-cafe. he complains about general unicode because his text-to-speech software assumes iso-8859-1
17:41:23 <Peaker> could be nice to have translators to/from layout syntax
17:41:39 <Peaker> monochrom: yet another reason to hate on unicode (I hate it too)
17:41:47 <Peaker> (well, in the context of code's textual representation)
17:41:50 <danharaj> unicode hates blind people
17:41:51 <monochrom> I hate iso-8859-1
17:42:19 <kmc> one nice property of Go is that there's a universally (?) respected source canonicalizer
17:42:20 <monochrom> but in email human text?
17:42:26 <Peaker> code should use ascii, not iso-8859-1
17:42:34 <kmc> there is an official One True Indentation Style for Go
17:42:49 <Peaker> kmc: heh, good luck with that :)
17:42:51 <othiym23> non-Latin characterset programmers vehemently disagree with you, Peaker
17:42:56 <Peaker> kmc: people will diverge it, IMO
17:42:59 <kmc> maybe
17:43:01 <kmc> we'll see
17:43:13 <kmc> mostly people use whatever style they learn first, or whatever the project already uses
17:43:25 <kmc> which means that if you start off with a strong norm
17:43:28 <kmc> it might not diverge
17:43:39 <Peaker> othiym23: programmers naming their things in non-English make API's that are unusable to those who don't speak English.. but they must speak English to use the vast amounts of libraries that exist
17:43:56 <Peaker> othiym23: I think when we get rid of the silly textual representation of code -- we can have multiple names in different languages for every symbol
17:44:09 <Peaker> but until then, let's stick to ascii English so we can at least cooperate on code
17:44:18 <othiym23> Peaker: I don't think that holds universally, e.g. look at the history of Ruby
17:44:23 <othiym23> not that Ruby got it right, either
17:44:55 <Peaker> othiym23: It's pretty terrible, IMO, that there are API's that do what a programmer needs them to do, but he cannot use them because the names are in a foreign language.. It is sad that textual programming makes it so
17:46:06 <othiym23> Peaker: as someone who's written code with graphical 4GLs, they're not the solution, either
17:46:20 <Peaker> othiym23: Yes, I don't propose graphical as the anti-thesis, but structural
17:46:26 <othiym23> but yeah, it would be nice if language standards were expressed in terms of ASTs, and we all got to choose our own front-ends
17:46:59 <Peaker> othiym23: AST's are a representation of ASG's similarly to how concrete syntax is a representation of ASG's
17:47:02 <Peaker> of AST's, that is
17:47:17 <JuanDaugherty> everybody working in a serious technical discipline in this time is expected to at least read English
17:47:21 <Peaker> othiym23: so we really want to edit ASG's with an editor that can render it to your favorite AST/textual representation
17:48:44 <JuanDaugherty> but logograms like in chinese are the goal
17:48:52 <othiym23> JuanDaugherty: not necessarily in the life sciences
17:49:11 <JuanDaugherty> no I meant in programming
17:49:19 <othiym23> air enough
17:49:29 <othiym23> *fair
17:49:35 <othiym23> but the life sciences are pretty technical ;)
17:49:57 <JuanDaugherty> i.e. the logograms in programming
17:51:04 <kmc> JuanDaugherty, i learned the other day that the Longsoon processor errata are only in Chinese
17:51:10 <othiym23> I just had a mental image of Unicode being extended to encode single glyphs of C's keywords
17:51:14 <othiym23> it wasn't a pretty image
17:51:19 <kmc> haha
17:51:30 <kmc> TI-83 BASIC has tokenized keywords like that
17:51:44 <ddarius> Unicode already has APL's operators, no?
17:51:47 <kmc> so all I have to do is convince the Unicode committee that the TI-83 character encoding falls within their domain of universal compatibility
17:51:49 <kmc> it does ddarius
17:52:23 <kmc> there are a bunch of silly glyphs in Unicode 6 apparently because Japanese mobile phone companies keep adding them
17:52:37 <kmc> like "outline of Japan" is now a Unicode character
17:52:49 <kmc> and three diffreent kinds of alien space monster
17:52:51 <othiym23> don't forget the three separate icons for the Japanese postal service
17:53:00 <othiym23> and the trademarked JIS glyph
17:53:15 * othiym23 might have spent too much time learning about oddities of CJKV character encodings
17:53:19 <kmc> haha
17:53:41 <kmc> V, eh
17:53:47 <kmc> are han characters used in Vietnam enough for that to matter?
17:53:54 <kmc> or is it just about encoding all the craaaaazy diacritic marks?
17:53:57 <JuanDaugherty> should we be sort of close to being able, in principle, to recompile all of hp using the literal say google translation into chinese?
17:54:03 <JuanDaugherty> *shouldn't
17:54:12 <kmc> that would be a fun experiment JuanDaugherty
17:54:19 <othiym23> kmc: classical Vietnamese uses a specialized subset of the hanja, yes
17:55:10 <othiym23> much like most literature students in Korea have to learn a thousand or so characters to read pre-hangul classical Korean texts
17:55:21 <kmc> ok
17:55:24 <kmc> makes sense
17:55:56 <othiym23> and they're all slightly different from one another, which is one of the reasons why Han unification is still a sore subject with academics across Asia
17:57:31 <JuanDaugherty> need programming language though rather than natural language translator such as one mentioned
17:58:31 <JuanDaugherty> which nobody ever does because English is universally accempted
17:58:58 <othiym23> JuanDaugherty: I don't know if you remember, but they tried to make C localizable back in the early 90s
17:59:04 <othiym23> or rather, they did, but almost nobody used it
17:59:41 <Axman6> sam2: did you figure out why that code workd yet?
17:59:44 <Axman6> works*
17:59:56 <JuanDaugherty> well c itself is super simple so musta been stdlib oder
18:00:01 <Saizan> what's the point of an ALIEN MONSTER character?
18:00:03 <Peaker> programming language localization may be a misguided attempt even if we did have structural editing infrastructure allowing the same code ASG to be assigned multiple names -- makes collaboration that much harder, and requires extra translation work to keep up with code changes
18:00:27 <othiym23> Saizan: hysterical raisins, as are most of the really weird characters that come from various JIS character sets
18:00:51 <othiym23> Peaker: I think that events have demonstrated the truth of that assertion
18:00:57 <sam2> I see how the code works... thanks Axman6
18:01:11 <sam2> but I'm still not quite sure why my original code did not work...  :(
18:01:40 <othiym23> JuanDaugherty: they were going for having all the core syntactic constructs in the language be translatable to e.g. Chinese, along with early multibyte character support for comments and variable names
18:04:17 <Saizan> too bad that i can't find a glyph for it
18:06:04 <dylukes> I don't think it's too hard for a language to just allow a pragma to replace keywords
18:06:09 <dylukes> put a set of those in a header file,
18:06:16 <dylukes> bam, instant user-customizeable localization package
18:06:18 <dylukes> :\
18:06:31 <dylukes> yes, it would make code more confusing if used incorrectly, though
18:07:03 <danharaj> is the idea of a lingua franca that abhorrent?
18:08:02 <Peaker> danharaj: כלל וכלל לא
18:08:43 * shachaf wonders whether irssi can be made to handle RTL text.
18:09:40 <Peaker> danharaj: That means "Not at all" :)
18:10:00 <dylukes> danharaj: I don't think so personally.
18:10:04 <dylukes> But, I don't really care.
18:10:09 <dylukes> Either way, its a different set of symbols
18:10:13 <dylukes> as long as I can enter them, works for me
18:10:25 <dylukes> in something like Haskell, keywords are almost inconsiquential
18:10:26 <Peaker> let's add another cartesian multiplier to the big code fragmentation mess the world already has :-)
18:10:31 <dylukes> "data", "class", and "instance"
18:10:32 <dylukes> :\
18:10:35 <dylukes> "type"
18:10:40 <dylukes> "newtype" once in a while
18:10:43 <shachaf> Haskell should use symbols for everything.
18:10:49 <dylukes> I wouldn't be abject to that.
18:11:05 <shachaf> Words should be reserved for the user.
18:11:24 <Peaker> shachaf: do you really believe that?
18:11:41 <ddarius> "case", "of", "where", "let", "in", "do", "module", "qualified", "import", "as"
18:11:43 <dobblego> are there any instances that override the default (>>)?
18:11:44 <Peaker> The way these ASG nodes are rendered to the screen should be in the user's viewing preferences
18:11:51 <shachaf> Peaker: No, not really. :-)
18:12:18 <danharaj> names tend to be inconsequential in my code too
18:12:22 <danharaj> other than top-level bindings in modules
18:12:27 <ddarius> dobblego: I don't think so.
18:12:34 <dylukes> ddarius: meh
18:13:03 <shachaf> What's the point of having (>>) as part of the type class? Just efficiency?
18:13:04 <Peaker> Default methods that are less powerful than other methods (not useful to define the instance with) are a silly way to implement specialization optimizations
18:13:20 <Peaker> shachaf: it is a pretty weird/bad way to implement "efficiency"
18:13:36 <dobblego> still, where is such an implementation that is more efficient?
18:13:37 <shachaf> Yes. That's the only justification I've heard for it, though.
18:13:39 <dylukes> Just semantics maybe.
18:13:50 <dylukes> weird nonetheless
18:14:14 * shachaf wonders what "semantics" means.
18:14:40 <Cale> The study of meaning
18:14:57 <shachaf> In dylukes's context in particular.
18:15:10 <Peaker> dobblego: I can imagine a fast Applicative parser that builds automatons for parsing.. and has a monad instance that degrades it back to backtracking.. In that case (>>) could have an implementation that gives the Applicative performance
18:15:31 <dylukes> are applicatives "faster" than monads?
18:15:35 <dylukes> I've never heard that before :\
18:15:44 <Peaker> dylukes: An Applicative parser can be faster than a Monadic parser
18:15:47 <ezyang> They have less restrictions.
18:15:54 <shachaf> Applicatives are so fast, man.
18:16:09 <dylukes> Peaker: I believe it CAN.
18:16:15 <dylukes> But I mean, what would make them inherently faster?
18:16:17 <Cale> Not inherently, obviously.
18:16:18 <dylukes> Are they even?
18:16:33 <Cale> It's just a typeclass :P
18:16:50 <shachaf> Cale: A *fast* typeclass.
18:16:55 <Cale> lol
18:16:59 <Peaker> dylukes: Well, the Applicative combinator builds a value where all of the "f a" values have a pre-known "f" there, so all parsing "effects" are known ahead of time -- meaning you can build an efficient parsing machine to parse larger texts
18:17:07 <augur> hey cale
18:17:12 <Cale> hi!
18:17:24 <Cale> But the fact that the typeclass is more restrictive can leave some additional runtime optimisations open
18:17:35 <Peaker> dylukes: the Monadic combinator builds values where the "m a" that are being composed together depend on "runtime results" of the parser, so you cannot do a buildup of a fast parser ahead of time
18:17:48 <augur> howsit goin cale guy
18:17:54 <shachaf> Functor is even faster than Applicative.
18:18:08 <danharaj> C is faster than Functor
18:18:08 <danharaj> wait
18:18:51 <shachaf> C/C++ is even faster than C.
18:18:52 <Cale> Note that (<*>) :: f (a -> b) -> f a -> f b, both of whose parameters are values of a user-controlled datatype
18:18:54 <shachaf> preflex: seen kmc
18:18:54 <preflex>  kmc was last seen on #haskell 23 minutes and 30 seconds ago, saying: makes sense
18:19:04 <Cale> While with (>>=) :: m a -> (a -> m b) -> m b
18:19:11 <shachaf> Oh, just a bit too early.
18:19:14 <Cale> the second parameter is a function, and hence opaque
18:19:19 <Peaker> dylukes: the nice thing about Applicative is that you can "statically" know all of the effects that will be applied before any of them are.. with Monads you don't
18:19:35 <dylukes> hm I see.
18:19:44 <dylukes> Why is that exactly :\?
18:20:22 <Cale> Well, for the reason I just outlined
18:20:24 <Peaker> dylukes: because (<*>) composes two known effects together..  (>>=) composes a known effect with an "unknown" effect (that depends on the result of executing the first effect)
18:20:37 <dylukes> mmk.
18:20:45 <dylukes> But then, if you're using say, Parsec
18:20:48 <Cale> Functions are opaque in Haskell
18:20:51 <dylukes> and you use only applicative form,
18:20:53 <dylukes> do you gain that
18:20:58 <Cale> no
18:21:10 <Peaker> dylukes: alternatively, using the join definition of Monads,  join makes it possible to compose the effect of the outer "m" in (m (m a)) with the inner "m", despite the inner "m" depending on executing the effect of the outer "m"
18:21:14 <Cale> Well... maybe
18:21:19 <dylukes> ...
18:21:20 <Cale> If you use the Applicative typeclass
18:21:21 <Peaker> dylukes: because Parsec sucks in that regard :-)
18:21:23 <Cale> only
18:21:38 <dylukes> I bet it uses Monad internally though :O
18:21:39 <dylukes> :P*
18:22:09 * cmccann likes ZipList as a fun example of the applicative instance being much more efficient than the monad instance
18:22:14 <Peaker> btw, if you do Applicative composition with potentially infinite recursion to describe a recursive grammar, that won't work either
18:22:25 <shachaf> cmccann: There's no monad instance for ZipList.
18:22:26 <ddarius> I believe the Applicative instance does just use the monadic functions, but it has been considered implementing something that exploits the Applicativeness.  I don't know if this has been done though.
18:22:48 <cmccann> shachaf, there's a possible monad instance but only if the lists are the same length
18:22:51 <cmccann> but nobody would ever use it
18:22:54 <dylukes> I need to go read on all the co- stuff
18:22:58 <Peaker> I am speculating that fast Applicative parsers have recursion/fix combinators of their own -- and disallow using Haskell recursion to define recursive grammars
18:23:14 <dylukes> It's simple to say "the dual is when you reverse all the arrows"
18:23:17 <dylukes> but… I don't know
18:23:26 <dylukes> that seems deceptively simple, with a *lot* of interesting results...
18:23:28 <ddarius> You reverse all the 1-cells.
18:23:29 <dylukes> >.>
18:23:32 <Peaker> can anyone shed light on whether a fast applicative parser can work with recursively defined applicative compositions?
18:25:20 <cmccann> shachaf, the hypothetical monad instance for ZipList is the same as the monad instance for infinite streams, btw
18:25:35 <cmccann> i.e., data Stream a = Cons a (Stream a)
18:25:36 <Peaker> I guess something like:  afix :: ApplicativeFix f => (f a -> f a) -> f a       though it confusingly has a similar type to an ordinary fix on the Applicative value (but makes the recursion non-opaque to the instance)
18:26:31 <shachaf> Not f (a -> a) -> f a?
18:27:34 <Peaker> well, imagine you want to define a recursive grammar
18:28:06 <Peaker> you need a fixpoint on the parser, not on the parsed value
18:28:19 <Peaker> shachaf: how would the function you gave be different from "fmap fix"?
18:29:30 * shachaf was only going by analogy to mfix/(>>=)/(<*>).
18:29:43 <shachaf> I suppose it doesn't make much sense. :-)
18:29:51 <ddarius> :t mfix
18:29:52 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
18:31:34 <Peaker> wouldn't be right for Applicative -- exposing the "runtime" to compile-time
18:32:02 <Peaker> it's just a non-opaque "fix" on applicative values
18:35:52 <shachaf> @ahoy jlewis
18:35:53 <lambdabot> "jlewis"
18:36:02 <shachaf> Oh, you were just rejoining.
18:36:05 * jlewis waves at shachaf
18:36:15 <jlewis> yes - how are you? still at rethink?
18:36:54 <shachaf> Yes.
18:47:27 * elliott files his first GHC bug
18:49:48 <elliott> ...and discovers it's wrong seconds later
18:50:40 <shachaf> elliott /= elliottt?
18:50:46 <elliott> indeed.
18:50:52 <cmccann> shortly thereafter, GHC files a bug against elliott
18:51:09 <elliott> shachaf: I have quite a nice life, though, with people assuming I'm that elliottt guy and _also_ Conal
18:51:39 * shachaf imagines Conal Elliottt.
18:52:06 <cmccann> given how consistently people put the wrong number of "t"s in Conal's last name I'm not surprised
18:52:38 <elliott> cmccann: similar problems i too have :(
18:53:04 <elliott> how come nobody ever messes it up for the elliotts with /other/ numbers of letters?
18:53:06 <shachaf> I imagine you would, ellio.
18:54:29 <elliott> shachaf: I'm going to put you in prison :(
18:54:36 * cmccann once remarked that Conal could avoid sampling errors by defining his name over continuous "t" but he didn't seem to go for it, alas
18:55:01 <shachaf> etltliot: You wouldn't do that, would you?
18:55:09 <elliott> shaff: Maybe I would.
18:55:19 <elliott> What's that, sachaf?
18:55:47 <shachaf> > intercalate "t" (map (:[]) "elliott")
18:55:48 <lambdabot>   "etltltitotttt"
18:55:59 * elliott cries
18:56:16 <elliott> > intercalate "t" (map pure "elliott")
18:56:18 <lambdabot>   "etltltitotttt"
18:56:19 <elliott> Fixed your monkey there.
18:56:23 <shachaf> > "ellio" ++ fix ('t':)
18:56:26 <lambdabot>   "elliottttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttt...
18:56:35 <elliott> I kind of wish pure was called wrap. Is that a bad thing to wish?
18:56:40 <kmc> > iterate (intercalate "t") "kvm"
18:56:41 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
18:56:41 <lambdabot>         against inferred ty...
18:56:58 <kmc> :t intersperse
18:56:59 <lambdabot> forall a. a -> [a] -> [a]
18:57:03 <shachaf> > iterate (intercalate "t" . map pure) "kvm"
18:57:05 <lambdabot>   ["kvm","ktvtm","ktttvtttm","ktttttttvtttttttm","ktttttttttttttttvtttttttttt...
18:57:28 <Cale> elliott: I think it's a little petty to actually wish it, but that would also be a reasonable name too, I suppose.
18:57:48 <shachaf> > "elliott" >>= (\x -> ['t',x,'t'])
18:57:49 <lambdabot>   "tettlttlttittottttttt"
18:57:59 <elliott> Cale: It's just that I wish "return" didn't exist and/or was named something else, and "pure" is a bit weird to write everywhere rather than return.
18:58:04 <Cale> You could also wish that it was called return
18:58:19 <Cale> and that Monad was a subclass of Applicative
18:58:20 <shachaf> "wrap" encourages monads-as-containers.
18:58:26 <shachaf> Well, applicatives-as-containers.
18:58:30 <Cale> singleton ;)
18:58:32 <kmc> @let tortilla = return
18:58:34 <lambdabot>  Defined.
18:58:35 <elliott> shachaf: Does it?
18:58:37 <kmc> @let guacamole = (>>=)
18:58:38 <lambdabot>  Defined.
18:58:48 <elliott> shachaf: One reason I like it is the symmetry with extract from comonads.
18:58:53 <Cale> unit would be a decent name too
18:58:56 <elliott> Or, well, copointeds, looking at the last category-extras.
18:59:11 <cmccann> yeah, "unit" would be nice
18:59:17 <cmccann> except that there's a bunch of other things that would be useful for, too
18:59:23 <elliott> Oh, it's in Comonad itself now it seems in the comonad package.
18:59:27 <Cale> I really don't mind 'return' as a name as much as some people seem to.
18:59:31 <kmc> let's name return "curry", in honor of Haskell Curry
18:59:37 <Cale> lol
18:59:42 <elliott> Cale: I just dislike it when I'm using it outside of do notation usually.
18:59:48 <elliott> "map return xs"? That's just stupid.
19:00:00 <shachaf> "return" is a slightly annoying name.
19:00:00 <elliott> (Also confusing, at least IMO.)
19:00:01 <kmc> @let schönfinkelize = curry
19:00:02 <lambdabot>  Defined.
19:00:03 <Cale> Well, return x is the action which does nothing except to return x
19:00:13 <danharaj> rather
19:00:16 <elliott> Cale: What an imperative view of evaluation :)
19:00:28 <shachaf> Cale: Sure, but that's not why it's named that, is it?
19:00:30 <Cale> elliott: Evaluation has nothing to do with it
19:00:38 <Cale> shachaf: I think it is...
19:00:55 <shachaf> I thought it was just so you could write imperative-looking like f x = do { ...; ...; return blah }
19:01:03 <shachaf> g/g l/g programs l/
19:01:16 <Cale> well, maybe that was also an inspiration, though it's obviously not equivalent to the imperative return
19:01:29 <Cale> (which is like calling the current continuation)
19:01:41 <Cale> (for a call/cc wrapped around every function body implicitly)
19:01:43 <elliott> Cale: Functions "returning" something is verbspeak. :p
19:01:52 <Cale> elliott: Who said they were functions
19:01:55 <elliott> (Albeit harmless verbspeak.)
19:02:01 <elliott> Cale: Fair enough.
19:02:10 <Cale> return is a function
19:02:17 <Cale> but return x probably isn't
19:02:17 <shachaf> data Null a = Null
19:02:20 <Cale> (though it could be)
19:02:36 <shachaf> instance Monad Null where return = const Null
19:02:49 <elliott> Cale: Still, return x = [x]... I'm not sure [x] is an "action that returns x".
19:03:06 <shachaf> elliott: In what sense isn't it?
19:03:06 <elliott> That terminology only seems to sit well in an imperative-ish monad.
19:03:13 <Cale> A list returns an element of itself, nondeterministically
19:03:26 <elliott> shachaf: It's a subjective feeling, nothing I could actually articulate.
19:03:29 <kmc> > flip runCont id . callCC $ \return -> do { return 3; return 4 }
19:03:31 <lambdabot>   3
19:03:41 <shachaf> elliott: How would you feel about "computation" instead of "action"?
19:03:42 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- return 7; return (x,y,z)
19:03:44 <lambdabot>   [(1,4,7),(1,5,7),(2,4,7),(2,5,7),(3,4,7),(3,5,7)]
19:03:57 <kmc> return :: a -> m b
19:03:58 <kmc> :)
19:04:14 <elliott> shachaf: That seems less accurate, in that "computation" doesn't really mean anything.
19:04:20 <elliott> (It implies "thunk" to me more than anything else.)
19:04:22 <shachaf> [a] is an action that can return multiple values nondeterministically.
19:04:25 <elliott> (Or, well, "unevaluated value'.)
19:04:39 <elliott> kmc: ouch :)
19:04:45 <Cale> elliott: "computation" and "action" are both common names for values of type  m t  for some monad m and type t
19:04:52 <elliott> yeah, that's the thing, "return" is a perfectly good name for a continuation :P
19:05:00 <elliott> Cale: I don't see the former much.
19:06:07 <shachaf> "continue" is a good name for a continuation.
19:06:52 <Cale> k is a pretty good name too
19:07:07 <Cale> for some reason :)
19:07:09 * shachaf wonders why k and not c.
19:07:21 <Cale> Obviously continuations are German.
19:07:37 <elliott> shachaf: it reminds me of "klass" used in some languages where class is a keyword
19:07:42 <elliott> kontinuation
19:07:55 <elliott> kontinüation
19:08:11 <ddarius> Let's say it's "k" for "Kolmogorov."
19:09:53 <shachaf> «"Where did Kolmogorov come into it?" I hear you cry.»
19:13:13 <hpaste> bar pasted “foo” at http://hpaste.org/48392
19:13:37 <elliott> thanks bar
19:13:40 <elliott> my life is changed forever
19:14:00 <ion> That information will be very useful.
19:15:39 <elliott> ion: it has revolutionised philosophy and science already
19:17:07 <ion> Bar should get a Nobel prize in physics.
19:18:10 <shachaf> Physics? That contribution warrants a Nobel prize in mathematics!
19:20:25 <elliott> shachaf: A Nobel prize in Nobel prizes, even.
19:20:35 <elliott> Best Nobel prize in the history of the universe.
19:27:33 <ion> Nobel prizes should be taken away from previous recipients and given to bar.
19:38:57 <shachaf> Can a function :: ((a -> b) -> b) -> a be written with callCC?
19:43:50 <elliott> shachaf: you mean unrestricted, or the Cont monad?
19:44:04 <elliott> I think Oleg did that, actually :-)
19:44:25 <shachaf> I mean given callCC :: ((a -> b) -> a) -> a
19:44:31 <shachaf> Or in the Cont monad, sure.
19:44:36 <elliott> http://okmij.org/ftp/Computation/lem.html
19:44:48 <elliott> NOT NOT A -> A
19:44:48 <elliott> We are now ready to demonstrate the proof term for the proposition NOT NOT A -> A.
19:44:49 <elliott>      > h :: (forall m. Monad m => ((a -> m F) -> m F)) -> a
19:44:57 <elliott> Close enough, right?
19:45:05 <shachaf> Ah, so he did.
19:45:06 <shachaf> Yes.
19:45:13 <shachaf> @karma+ oleg
19:45:14 <lambdabot> oleg's karma raised to 9.
19:50:46 <ddarius> @djinn (((a -> b) -> a) -> a) -> Not (Not a) -> a
19:50:46 <lambdabot> -- f cannot be realized.
19:51:17 <Luke1> is there a way to bind a data constructor to a variable in a pattern match?
19:51:34 <shachaf> @djinn (((a -> b) -> a) -> a) -> ((p -> q) -> p) -> p
19:51:34 <lambdabot> -- f cannot be realized.
19:53:26 <Veinor> shachaf: what were you expecting?
19:53:42 <kmc> > let f = Just in f 3
19:53:42 <shachaf> Veinor: id, maybe?
19:53:43 <lambdabot>   Just 3
19:53:48 <kmc> Luke, is that what you mean?
19:53:51 <shachaf> @djinn (forall a b. ((a -> b) -> a) -> a) -> ((p -> q) -> p) -> p
19:53:52 <lambdabot> -- f cannot be realized.
19:54:07 <Veinor> id wouldn't work for the same reason that you can't realize a -> b
19:54:23 <ion> :t undefined :: a -> b
19:54:23 <Veinor> that second one should work though
19:54:24 <lambdabot> forall a b. a -> b
19:54:26 <Veinor> ion: :P
19:54:58 <Luke> kmc: a data constructor can be matched and following fields bound with (Constructor a b c) -- is there a way to bind the constructor?
19:55:09 <ddarius> Djinn doesn't understand higher-rank types.
19:55:22 <shachaf> @ty let ccc :: ((a -> b) -> a) -> a; ccc = undefined; foo :: (forall a b. ((a -> b) -> a) -> a) -> ((p -> q) -> p) -> p; foo x = x in foo
19:55:23 <lambdabot> forall p q. (forall a b. ((a -> b) -> a) -> a) -> ((p -> q) -> p) -> p
19:55:31 <shachaf> Oh. :-(
19:55:32 <kmc> Luke, as a function?
19:55:36 <Luke> kmc: or say "I don't care what the constructor was, just bind the fields"
19:55:38 <kmc> not really
19:55:40 <Luke> kmc: yes
19:55:45 <kmc> you're getting into Data.Data territory there
19:55:52 <kmc> and the "scrap your boilerplate" papers
19:55:55 <kmc> > toConstr (Just 3)
19:55:56 <lambdabot>   Just
19:56:01 <dylukes> ddarius: I'm like djinn then :(
19:56:02 <Luke> ah
19:56:10 <kmc> > let (===) = (==) `on` toConstr in [Just 3 === Just 4, Just 3 === Nothing]
19:56:10 <lambdabot>   [True,False]
19:56:15 <Axman6> :t toConstr
19:56:16 <lambdabot> forall a. (Data a) => a -> Constr
19:56:23 <Luke> kmc: I don't want to go there. What about a way to
19:56:35 <kmc> Luke, as for binding fields without the constructor,
19:56:46 <kmc> you can make a type with multiple constructors which each use record syntax
19:56:51 <kmc> and use an overlapping set of names
19:57:44 <ion> > (\(toConstr -> a) -> a 42) (Just 43)
19:57:44 <Luke> kmc: maybe a better way of explaining it is: unwrapping the field, doing something to it, then rewrapping it in the type constructor it had
19:57:45 <lambdabot>   Couldn't match expected type `t1 -> t'
19:57:45 <lambdabot>         against inferred type `Data....
19:57:59 <kmc> Luke, SYB can do that
19:58:04 <kmc> or just define the appropriate function for your type
19:58:09 <kmc> possibly that function is fmap
19:58:15 <shachaf> ion: It's not the same Just.
19:58:16 <shachaf> @ty toConstr (Just 5)
19:58:16 <kmc> > map (fmap succ) [Just 3, Nothing]
19:58:16 <lambdabot> Constr
19:58:17 <lambdabot>   [Just 4,Nothing]
19:58:21 <Luke> kmc: fmap is probably what I want. thanks
19:58:29 <Luke> perfect
19:58:32 <Luke> thanks
19:58:37 <ion> yeah
19:58:38 <kmc> :t fmap
19:58:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:58:45 <ddarius> :t (.:)
19:58:46 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
19:58:48 <kmc> GHC can derive Functor instances with the DeriveFunctor (?) extension?
19:58:50 <ddarius> Excellent.
19:59:02 <ddarius> > succ .: [Just 3, Nothing]
19:59:03 <lambdabot>   [Just 4,Nothing]
19:59:26 <kmc> > succ <$> [Just 3, Nothing`
19:59:27 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:59:27 <kmc> > succ <$> [Just 3, Nothing]
19:59:28 <lambdabot>   No instance for (GHC.Enum.Enum (Data.Maybe.Maybe t))
19:59:29 <lambdabot>    arising from a use ...
19:59:39 <kmc> err, right
19:59:53 <shachaf> > succ .: [Just 3, Nothing]
19:59:54 <lambdabot>   [Just 4,Nothing]
19:59:59 <shachaf> Er.
20:00:04 * shachaf reads above.
20:00:16 <kmc> > (fmap . fmap) succ [Just 3, Nothing]
20:00:18 <lambdabot>   [Just 4,Nothing]
20:00:28 <shachaf> > fmap fmap fmap succ [Just 3, Nothing]
20:00:29 <ddarius> > (succ .) . [Just 3, Nothing]
20:00:29 <lambdabot>   [Just 4,Nothing]
20:00:30 <lambdabot>   [Just 4,Nothing]
20:02:41 <Jafet> I prefer (.)(.) succ
20:03:48 <shachaf> You mean (.)(.)(.) succ?
20:04:09 <dobblego> I use ∘∘ in scala
20:04:45 <kmc> ∘_∘
20:04:54 <kmc> dobblego, do you use it in Haskell too?
20:04:58 <dobblego> no
20:05:18 <Jafet> shachaf: when I become an astronaut, someday
20:05:21 <dobblego> mostly because its type-inference is better, so the case is not so compelling
20:19:21 <ddarius> http://www.eecs.usma.edu/webs/people/okasaki/hw02postfix.pdf
20:20:39 <Cale> cool, when did that paper come out?
20:21:57 <Cale> I've seen that trick around for quite some time
20:22:20 <tensorpudding> haskell email servers
20:22:45 <ddarius> The paper's quite old.  I read it many ago.
20:22:46 <tensorpudding> oh wait, not that postfix
20:23:25 <ddarius> Though, Ralf Hinze finally published a paper that generalizes this to LR grammars if I recall correctly.  That paper has been available unpublished for several years as well.
20:27:19 <elliott> > let foo f (x::Int) = f x in (let x = 9 in foo x x)
20:27:20 <lambdabot>   9
20:27:22 <elliott> how come this is not a type error?
20:27:25 <elliott> hmm
20:27:29 <elliott> oh wait, x doesn't necessarily get unified there
20:28:05 <Jafet> :t let x = 9 in x
20:28:06 <lambdabot> forall t. (Num t) => t
20:28:17 <kmc> :t let 8 = 9 in ?x
20:28:18 <lambdabot> forall t. (?x::t) => t
20:28:38 <elliott> Jafet: righ
20:28:39 <elliott> t
20:28:44 <Cale> > 9 9
20:28:45 <lambdabot>   9
20:28:50 <elliott> I know that
20:28:54 <elliott> I'm just trying to come up with an example of when (f x x) and (let y = x in f y y) aren't equivalent
20:28:58 <elliott> I'm pretty sure there is one, but that's not it
20:29:08 <kmc> equivalent operationally or denotationally?
20:29:31 <Cale> Should be equivalent in every way, if x and y are always variables
20:29:42 <elliott> Cale: for non-variable x
20:29:52 <elliott> kmc: as in, one is a type error and the other is not.
20:30:01 <elliott> hmm, maybe with gadts...
20:30:32 <Cale> (+) (product [1..100]) (product [1..100]) will be twice as slow as let y = product [1..100] in (+) y y
20:30:49 <elliott> That's irrelevant, I'm talking type-wise.
20:30:58 <Cale> oh, typewise...
20:31:09 <Cale> I can't think of how they'd ever be different
20:31:20 <Cale> er, hmm
20:31:27 <elliott> I'm thinking in terms of unification, but I'm not sure how to get it to go
20:31:39 <Cale> Well, maybe with the 'let should not be generalised' thing we have now
20:31:45 <ddarius> Cale: Yes.
20:32:05 <elliott> > let foo (f :: forall a. a -> a) (x::Int -> Int) = f x in foo id id
20:32:06 <lambdabot>   Overlapping instances for GHC.Show.Show
20:32:06 <lambdabot>                              (GHC.T...
20:32:08 <shachaf> Monomorphism restriction?
20:32:12 <elliott> > let foo (f :: forall a. a -> a) (x::Int -> Int) = f x in foo id id `seq` ()
20:32:13 <lambdabot>   ()
20:32:17 <elliott> > let foo (f :: forall a. a -> a) (x::Int -> Int) = f x in (let blah = id in foo blah blah `seq` ())
20:32:18 <lambdabot>   ()
20:32:26 <parcs> lambdabot is not a good test candidate..
20:32:34 <elliott> laziness trumps goodness
20:32:39 <elliott> (haskell motto)
20:32:41 <Cale> > let { f :: Integer -> Int -> Integer; f x y = x + fromIntegral y } in let x = 9 in f x x
20:32:42 <lambdabot>   18
20:32:47 <elliott> parcs is right though
20:32:52 <Cale> That fails in newer GHCs
20:32:57 <elliott> lambdabot has every extension :P
20:33:01 <elliott> hmm well, it has a bunch of instances
20:33:05 <elliott> dunno what language extensions it actually has on
20:33:14 <Cale> Because let isn't being generalised anymore
20:33:29 <ion> elliott: It doesn’t have ViewPatterns. It would be nice if it did.
20:33:29 <Cale> (kinda sad, but it's reasonable for some technical reasons)
20:33:39 <Cale> However...
20:33:51 <Cale> > let { f :: Integer -> Int -> Integer; f x y = x + fromIntegral y } in let { x :: (Num a) => a; x = 9 } in f x x
20:33:52 <lambdabot>   18
20:33:57 <Cale> should still work
20:34:05 <parcs> > let f (pred -> x) = x in f 10
20:34:06 <lambdabot>   9
20:34:10 <elliott> Cale: isnt let not being generalised only with some extension on
20:34:11 <Jafet> Are where-bindings still generalised?
20:34:13 <elliott> like gadts or
20:34:22 <Cale> elliott: No, it's by default now
20:34:33 <elliott> ;.;
20:34:39 <elliott> rest in piece, let generalisation
20:34:53 <Jafet> Goodnight sweet type inference
20:35:11 <kmc> Cale, in 7.2?
20:35:16 <parcs> lambdabot doesn't have recursive do notation, or arrow syntax, at least
20:35:37 <Cale> where is treated the same as let
20:35:44 <Cale> So it's not generalised either
20:35:54 <Cale> in 7.0.x
20:36:13 <danharaj> at where's the spj paper that explains why they did it?
20:36:17 * hackagebot attempt 0.3.1.1 - Concrete data type for handling extensible exceptions as failures.  http://hackage.haskell.org/package/attempt-0.3.1.1 (MichaelSnoyman)
20:36:21 <danharaj> I'm pretty sure it's called "Let should not be generalized"
20:36:45 <Jafet> Oh, I never noticed it!
20:36:51 <Cale> or you could look up the http://research.microsoft.com/en-us/um/people/simonpj/papers/constraints/let-gen.pdf
20:36:57 <Cale> er, edit fail
20:37:11 <Cale> I was going to say, you could look up the epic paper on the new type system
20:37:44 <Cale> http://haskell.org/haskellwiki/Simonpj/Talk:OutsideIn
20:38:07 <Cale> Section 4.2
20:38:32 <elliott> scary :(
20:47:15 <thoughtpolice> Cale: no, IIRC I believe MonoLocalBinds is *only* turned on iff you turn on GADTs - but it's also possible to say 'NoMonoLocalBinds' and 'GADTs' - that isn't guaranteed to work though, IIRC
20:47:47 <kmc> are there plans to make NoMonoLocalBinds the global default in the future?
20:48:22 <thoughtpolice> i haven't heard anything about that, but i couldn't tell you, honestly.
20:49:37 <kmc> (er, i meant MonoLocalBinds)
20:51:06 <thoughtpolice> Cale: yeah, it's only enabled if you turn on GADTs - http://hpaste.org/48394
20:52:35 <thoughtpolice> Cale: and yeah, same behavior with a recent-ish GHC HEAD (built from a few weeks ago, current HEAD build is broken on OS X :( )
20:53:22 <Jafet> By the way, Cale, when will lambdabot use ghc7 for mueval?
20:53:57 <Cale> thoughtpolice: Well, when I was testing, I didn't have GADTs turned on...
20:54:04 <Cale> huh
20:54:14 <thoughtpolice> yeah, i was pretty sure it's only turned on with GADTs
20:54:31 <thoughtpolice> i believe I answered a question or two on g-h-u concerning this, and it was confusing people because things would work, then they'd hit -XGADTs, and things would stop working :)
20:54:41 <Cale> ah
20:54:42 <thoughtpolice> (with no other changes)
20:55:14 <kmc> yeah... language extensions are Subject To Breakage, but we come to rely on them as language features
20:55:17 <kmc> plus they're just so cool ;)
20:55:34 <thoughtpolice> my theory is generally just "people tend to rely on anything the compiler will allow them to rely on"
20:55:35 <kmc> i kind of wish Haskell' moved faster, though there are some good reasons to be slow
20:55:43 <thoughtpolice> (for better or very, very much worse)
20:56:02 <kmc> thoughtpolice, sure, half of the popular languages don't even try to make a distinction between language and implementation
20:56:38 <Cale> oh, okay, I was testing incorrectly, my thing was actually failing because of MR
20:56:57 <thoughtpolice> kmc: no joke
20:57:31 <kmc> Cale, the Dreaded Monomorphism Restriction?
20:57:45 <Cale> yeah, I always forget about the MR
20:58:09 <DigitalKiwi> !seen glguy
20:58:38 <DigitalKiwi> gah
20:58:47 <DigitalKiwi> didn't there used to be a bot that had that here? :/
20:59:01 <thoughtpolice> lambdabot: @seen glguy
20:59:01 <lambdabot> Unknown command, try @list
20:59:08 <thoughtpolice> preflex: seen glguy
20:59:09 <preflex>  glguy was last seen on #haskell 24 days, 11 hours, 29 minutes and 43 seconds ago, saying: ?src (.)
20:59:41 <DigitalKiwi> thoughtpolice: thanks
21:00:22 <thoughtpolice> DigitalKiwi: np
21:00:55 <DigitalKiwi> i haven't talked to him in a while :(
21:36:59 <kmc> it's quiet
21:37:01 <kmc> too quite
21:37:14 <kmc> @quote
21:37:15 <lambdabot> ski_ says: unique among types, 'Void -> X' has its own charm. tourists should definitly pay a visit.
21:37:25 <kmc> @quote
21:37:25 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
21:37:30 <kmc> @quote
21:37:31 <lambdabot> Fanael says: yeah, C++ templates are a large step in the right direction, if the "right direction" means back.
21:37:37 <kmc> ice burn
21:37:47 <thoughtpolice> @quote C++
21:37:48 <lambdabot> haskell says: wow am I in the wrong chat maybe?
21:37:54 <thoughtpolice> ^^ he sure is
21:39:01 <kmc> @quote C\+\+
21:39:02 <lambdabot> kmc says: you see a lot of Rubyists who associate static typing with C++ lunacy or Java's kingdom of nouns, and thus refuse on principle to have any idea what their programs do before they run
21:39:02 <lambdabot> them
21:39:16 <kmc> oh look, it's me saying something inflammatory
21:39:22 <kmc> oh look, it's me saying something inflammatory
21:39:23 <kmc> @quote C\+\+
21:39:24 <lambdabot> gwern says: downard funargs problem? upwards? maybe c++ will invent a 'sideways funarg problem'
21:39:29 <kmc> @quote C\+\+
21:39:29 <lambdabot> kmc says: you see a lot of Rubyists who associate static typing with C++ lunacy or Java's kingdom of nouns, and thus refuse on principle to have any idea what their programs do before they run
21:39:30 <lambdabot> them
21:39:32 <kmc> sigh
21:40:47 <kmc> > iterate (In . Just) (In Nothing)
21:40:49 <lambdabot>   [In Nothing,In (Just (In Nothing)),In (Just (In (Just (In Nothing)))),In (J...
21:41:02 <elliott> ?quote kmc
21:41:03 <lambdabot> kmc says: "<killing-joke> ah, yes, but my 'happy' she is broken"  <--- how not to talk to your gynecologist
21:44:13 <kmc> @djinn ((a -> ((b -> r) -> r)) -> ((a -> r) -> r)) -> ((a -> r) -> r)
21:44:14 <lambdabot> f a b = a (\ c _ -> b c) b
21:45:28 <xil> hello. I have a question about efficiency and Haskell's laziness. If I have a list "ls" onto which I want to map some function "f", but I also want to first filter out 1 element according to predicate "p", then my question is this: Will the function "map f . filter p" applied to "ls" run in approximately "n" or "2n" time, if "n" is the length of the list? Would it be more worth it for me to write my own function that simultaneously
21:46:11 <kmc> n = 2n, asymptotically
21:46:28 <kmc> maybe we can talk about whether (map f . filter p) is slower than (map f) or (filter p) alone
21:46:36 <kmc> and by how much
21:46:43 <pikhq> xil: It will run in O(n) time, because O(n) = O(cn) for any non-zero constant c.
21:47:10 <kmc> xil, GHC can transparently optimize such things into a single traversal
21:47:11 <xil> pikhq: that I know, but I'm curious about actual run time, not Big O
21:47:14 <kmc> it doesn't always work
21:47:24 <kmc> if you're curious about actual run time, the best thing is to benchmark
21:47:28 <kmc> Criterion is a great library for doing so
21:47:41 <xil> kmc: that is exactly what I was looking for, thank you
21:48:02 <thoughtpolice> i don't think GHC will be able to fuse that particular code into a single traversal, but in other cases, it can reduce multiple traversals into single one (e.g. map f . map g = map (f . g) will always happen, etc)
21:48:17 <thoughtpolice> benchmarks first, of course :)
21:48:22 <kmc> xil, see also the paper "lists to streams to nothing at all" and the library http://hackage.haskell.org/package/stream-fusion
21:49:33 <xil> thank you all, that is what I was looking for =]. I appreciate it
21:49:43 <kmc> :t \f p -> foldr (\x xs -> if p x then f x : xs else xs)
21:49:44 <lambdabot> forall a a1. (a -> a1) -> (a -> Bool) -> [a1] -> [a] -> [a1]
21:49:54 <kmc> @pl \x xs -> if p x then f x : xs else xs
21:49:55 <lambdabot> join . ap ((.) . if' . p) ((:) . f)
21:49:55 <shachaf> pikhq: Even for negative constants?
21:50:03 <pikhq> shachaf: BAH
21:50:34 * shachaf has a great algorithm that runs in O(-n^2) time.
21:50:49 <kmc> you and your pathological counterexamples
21:51:10 <shachaf> Everything in this channel is pathological.
21:51:12 <hpaste> wli pasted “Remez.lhs” at http://hpaste.org/48395
21:51:48 <morolin> shachaf: how can something run in O(-n^2) time?  It gives you the answer before you run it?
21:51:51 * wli-needjob has trouble adding new points to the linear programs to refine the approximation.
21:51:58 <shachaf> morolin: Continuations.
21:52:48 <kmc> temporal loop logic
21:52:48 <morolin> shachaf: ?
21:53:17 <kmc> if you have a time machine with consistency semantics, you can solve NP-complete problems in polynomial time
21:53:41 <kmc> @hoogle asTypeOf
21:53:42 <lambdabot> Prelude asTypeOf :: a -> a -> a
21:53:48 <kmc> it's in Prelude?!?
21:53:56 <thoughtpolice> yep
21:54:05 <shachaf> kmc: Speaking of which, that callCC->LEM thing you mentioned yesterday is really neat.
21:54:30 <morolin> kmc: oic
21:55:32 <wli-needjob> Extremization of the deviation needs better methods so as to (1) add more points at each step (2) more reliably find extrema esp. not infinite looping in extremum search like it is now.
21:56:17 <kmc> shachaf, yeah, it's the cheekiest proof ever
21:56:32 <thoughtpolice> something to do with pierce's law i assume?
21:56:36 <kmc> "A is false!  oh, you found a proof... well as I've been saying all along, A is true"
21:56:52 <kmc> thoughtpolice, yep, proving Law of the Excluded Middle using continuations
21:57:00 <kmc> callCC's type is Peirce's Law
21:57:11 <kmc> i can give the proof again, it takes only a moment
21:57:18 <thoughtpolice> kmc: yeah, i ran across that on wikipedia the other day. the connection between call/cc, pierce's law and the LEM was neat
21:57:33 <thoughtpolice> kmc: go for it :>
21:57:43 <shachaf> Scumbag LEM: Promises you a Void, travels back in time and gives you your own a back.
21:57:47 <thoughtpolice> (i only understand it in a vaguely hand-wavy way, and i only gave it a cursory glance)
21:58:03 * shachaf can't believe he resorted to that. Ridiculous.
21:58:04 <kmc> so LEM is «Either (Not a) a»
21:58:24 <kmc> type Not a = a → ⊥
21:58:31 <kmc> where ⊥ is some empty type
21:58:38 <ddarius> @djinn-add class LEM a where em :: Either (Not a) a
21:58:45 <kmc> a (non-monadic) callCC operator has type ((a → b) → a) → a
21:58:56 <ddarius> @djinn (EM a) => ((a -> b) -> a) -> a
21:58:56 <lambdabot> Error: Class not found: EM
21:59:02 <kmc> and we know Peirce's Law is enough to give us classical logic
21:59:02 <ddarius> @djinn (LEM a) => ((a -> b) -> a) -> a
21:59:02 <lambdabot> f a =
21:59:03 <lambdabot>     case em of
21:59:03 <lambdabot>     Left b -> a (\ c -> void (b c))
21:59:03 <lambdabot>     Right d -> d
21:59:28 <kmc> so we must be able to prove LEM with continuations
21:59:32 <kmc> lem = callCC $ \k → ...
21:59:52 <kmc> now we have to produce «Either (Not t) t», and we have no t, so we produce (Not t), i.e. t → ⊥
22:00:00 <kmc> lem = callCC $ \k → Left (\v → ...)
22:00:16 <wli-needjob> Aha, it's getting hung up on a degenerate case.
22:00:20 <kmc> in other words, asserting that t is false
22:00:33 <kmc> but if someone calls us out on that claim, by providing some v :: t
22:00:41 <kmc> then we use the continuation to go back in time and make the opposite claim
22:00:49 <kmc> lem = callCC $ \k → Left (\v → k (Right v))
22:01:12 <kmc> @pl \k -> Left (\v -> k (Right v))
22:01:13 <lambdabot> Left . (. Right)
22:01:57 <kmc> :t let callCC :: ((a -> b) -> a) -> a; callCC = callCC in callCC (Left . (. Right))
22:01:58 <lambdabot> forall b b1. Either (b1 -> b) b1
22:02:00 <ddarius> fmap Left (cofmap Right)
22:02:16 <shachaf> cofmap?
22:02:29 <kmc> contravariant functors?
22:02:39 <ddarius> class ContraFunctor f where cofmap :: (b -> a) -> f a -> f b
22:02:49 <dobblego> s/ContraFunctor/Contravariant
22:03:17 <ddarius> dobblego: Do you rename Functor Covariant?
22:03:52 <dobblego> no
22:04:46 <thoughtpolice> kmc: ah, that makes a bit of sense. neato! what'd you link shachaf too if you don't mind? i ran across this but any reading on it would be neat
22:05:04 <kmc> i just explained it here like so
22:05:05 <shachaf> thoughtpolice: kmc just outlined it in IRC like now.
22:05:08 <kmc> i didn't have a link :/
22:05:47 <thoughtpolice> ah, ok
22:06:18 <shachaf> There's http://okmij.org/ftp/Computation/lem.html , though.
22:06:43 <kmc> woah
22:06:57 <thoughtpolice> i think wouter said it best - "oleg? oh, he's like the tony hawk of functional programming"
22:06:58 <ddarius> Tim Newsham has a similar article about these sorts of things.
22:07:06 <kmc> :t Left . (. Right)
22:07:07 <lambdabot> forall b b1 b2 a. (Either a b2 -> b1) -> Either (b2 -> b1) b
22:07:39 <thoughtpolice> "We specifically avoid call/cc, which is overrated." <- nice intro too
22:07:40 <shachaf> Oh, right, I saw that article in TMR at one point.
22:10:38 <shachaf> Ah, they don't need Cont, indeed, just exceptions.
22:10:43 <kmc> this proof makes me feel a lot worse about the Law of the Excluded Middle
22:10:47 <kmc> i'm not sure if that's fair or not
22:11:01 <kmc> it is indeed possible to prove something reasonable by unreasonable means
22:11:03 <triliyn> Logic is coherent without LEM, isn't it?
22:11:36 <kmc> triliyn, yep, constructivist logic lacks LEM or any equivalent axiom, and is "just as good"
22:11:52 <shachaf> Sure, you just can't do proofs by contradiction.
22:11:55 <kmc> and those sorts of logics are the ones that come out of type systems (cf Curry-Howard Isomorphism)
22:12:02 <shachaf> kmc: "just as good" by what measure? :-)
22:12:12 <kmc> unless your type system allows continuations
22:12:38 <Cale> Well, you can do proofs by contradiction to prove doubly-negated things
22:12:50 <kmc> shachaf, well, i don't want to say they're consistent, because an interesting logic (classical or constructivist) can't prove its own consistency
22:12:57 <nus> shachaf, by beliefjoules (-;
22:13:48 <shachaf> Cale: Well, sure. And you can even take Not (Not a) -> a as an axiom in order to be able to use those double-negated things. :-)
22:14:04 <shachaf> Can you do Not (Not (Not a)) -> Not a in intuitionistic logic?
22:14:11 <kmc> is it reasonable to read Cont as a modal operator for "classically provable"?
22:14:19 <Cale> yes
22:14:28 <kmc> @djinn (((a -> Void) -> Void) -> Void) -> (a -> Void)
22:14:29 <lambdabot> f a b = void (a (\ c -> c b))
22:14:35 <ddarius> For propositional logic (and I think for first order logic too) intuitionistic and classical logic are mutually embeddable.
22:14:40 <Cale> Classical logic is embedded into intuitionist logic by double negation
22:14:45 <kmc> 'void' is ex falso?
22:15:06 <shachaf> void :: Void -> a
22:15:19 <kmc> yeah
22:16:19 <tekknolagi> /msg NickServ identify beverly1
22:16:32 <dmwit> tekknolagi: better change your password
22:16:39 <tekknolagi> oh, fuck.
22:16:41 <shachaf> /msg nickserv identify hunter2
22:16:52 <kmc> pick something stronger next time ;)
22:17:18 <shachaf> The strongest password is JL3S*$wnaA8
22:17:20 <shachaf> Better use that.
22:17:25 <ion> /msg NickServ identify OaHyocomJujRedhysEvEshOunifyaHetEncegNebsucserOdcakCyxrokDyd
22:17:39 <kmc> shachaf, any password is stronger if you put thirteen 'Z's at the end
22:17:45 <kmc> nad no harder to remember
22:17:50 <kmc> (Z because it comes last in brute-forcers, right?)
22:17:51 <tekknolagi> how do i change my password?
22:17:57 <kmc> so i'll go with JL3S*$wnaA8ZZZZZZZZZZZZZ
22:17:58 <shachaf> > fix (replicate 13 'Z'++)
22:18:01 <lambdabot>   "ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ...
22:18:04 <Kaidelong> but many places don't let you have a password that is "too long"
22:18:07 <ion> /msg nickserv help
22:18:13 * shachaf wonders why he bothered with the replicate 13 there.
22:18:18 <nus> somebody, ghost tekknolagi already (-;
22:18:23 <tekknolagi> ghost?
22:18:28 <kmc> Don't Be A Dick ™
22:18:29 <shachaf> Like Pacman.
22:18:31 <Kaidelong> > fix ('Z':)
22:18:32 * ddarius buffer overflows the password field.
22:18:33 <lambdabot>   "ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ...
22:18:34 <morolin> Kaidelong: most of them do that transparently, if they do it, much to my chagrin
22:18:45 <thoughtpolice> kmc: we have forced password changes at work. conclusion: always append another '1' to the end of my password every 6 months
22:18:50 <shachaf> kmc: Is that another one of your design patterns?
22:18:51 <kmc> tekknolagi, you can change it by msging nickserv probably
22:18:58 <kmc> or by joining the ops channel and asking them?
22:19:03 <kmc> shachaf, no doubt
22:19:04 <ion> /msg nickserv help
22:19:19 <tekknolagi> what is the account key?
22:19:28 <kmc> nfc
22:20:12 <Kaidelong> now I know why the GHOST command makes nickserv identify who is responsible for the boot
22:20:18 <nus> thoughtpolice, your admin isn't bofh enough, some use pam_cracklib
22:20:23 <Kaidelong> I always wondered
22:20:57 <kmc> heh Kaidelong
22:20:59 <tekknolagi> what should i do
22:21:05 <tekknolagi> if i lost my account key?
22:21:15 <ion> You don’t need a “key” to change your password.
22:21:37 <thoughtpolice> nus: :P
22:22:32 <tekknolagi> ion: i did /msg NickServ SETPASS tekknolagi (my_old_password) (my_new_password)ion: i did /msg NickServ SETPASS tekknolagi (my_old_password) (my_new_password)
22:22:34 <tekknolagi> oops
22:22:35 <tekknolagi> ion: i did /msg NickServ SETPASS tekknolagi (my_old_password) (my_new_password)
22:22:52 <tekknolagi> but it says "invalid account key for tekknolagi"
22:23:19 <shachaf> tekknolagi: You don't use your old password for setpass.
22:23:30 <tekknolagi> shachaf: what do you use?
22:23:35 <tekknolagi> and please no one GHOST me
22:23:42 <ion> Had you looked at the help text for setpass you’d have seen “To set a new password if you know the current password, use SET PASSWORD instead of SETPASS.”
22:25:14 <tekknolagi> whew
22:25:15 <tekknolagi> changed it
22:25:20 <tekknolagi> thank you all for not ghosting me
22:25:24 <tekknolagi> i appreciate it
22:25:38 <ddarius> The secret to usable software is not discoverability, not documentation, not consistency; it's preview and undo.
22:26:04 <tekknolagi> to all a good night
22:56:01 <dobblego> newtype Cokleisli a w b = C (w a -> b); instance Comonad w => Comonad (Cokleisli a w) where ... is it?
22:58:24 <dobblego> !seen edwardk
23:00:08 <ddarius> dobblego: The first method would be extract :: Comonad w => (w a -> b) -> b.  There's no way to manufacture a (w a) value.
23:00:39 <dobblego> hmm yes
23:01:10 <Mgccl> Are there ways to be concise and not use multiple map? for example I use 2 maps for sum first 2 item in a list. map sum (map (take 2) list)
23:01:26 <dobblego> @type (.:)
23:01:27 <dmwit> map (sum . take 2) list
23:01:27 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
23:01:33 <dmwit> ?free map
23:01:35 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
23:01:40 <dobblego> oh wait yeah, compose (.) instead
23:01:48 <ddarius> dmwit: Then set h, say, to id.
23:02:48 <dmwit> Yeah, but you don't get (map id = id) for free.
23:02:52 <dmwit> That you have to prove.
23:02:54 <dmwit> Not that it's hard.
23:03:02 <ddarius> Well, $map id = id is free
23:03:02 <fengshaun> Mgccl: what are you exactly trying to do?  Sum up the first two elements of a list?
23:03:14 <ddarius> So pretend I said g instead of h.
23:03:15 <dmwit> ddarius: Why?
23:03:29 <dmwit> Don't you have to look at the implementation (not just the type)?
23:03:51 <ddarius> $map is a specific function, namely the functorial action of [].
23:03:54 <dmwit> e.g. (map' f xs = map f xs ++ map f xs) has the right type, but doesn't have map id = id.
23:04:10 <dmwit> err... doesn't have map' id = id, I mean
23:04:16 <Mgccl> (summing the first 2 item in the list), where all the lists are in a larger list
23:04:23 <Mgccl> and thanks, I see how to do this now :D
23:04:26 <kmc> Mgccl, map f (map g x) ≡ map (f . g) x
23:04:49 <ddarius> Or more generally, fmap f . fmap g = fmap (f . g)
23:05:17 <kmc> in fact GHC will perform this optimization on its own, but doing it yourself produces nicer to read code
23:06:00 <ddarius> @free fst
23:06:00 <lambdabot> f . fst = fst . $map_Pair f g
23:10:37 <Cale> http://upload.wikimedia.org/wikipedia/commons/thumb/f/f2/Natural_transformation.svg/250px-Natural_transformation.svg.png
23:13:21 <wli-needjob> Hmm, how do you respond to an hpaste?
23:14:22 <shachaf> wli-needjob: There should be an "Annotate" link in the top right?
23:15:12 <hpaste> wli annotated “Remez.lhs” with “Remez.lhs (annotation)” at http://hpaste.org/48395#a48396
23:15:38 <wli-needjob> shachaf: It was hidden, had to scroll to the right.
23:16:18 <Cale> ah, because that paste has super-long lines :)
23:16:34 <Cale> That is something to think about with the design
23:16:51 <ivanm> @ask edwardk do you recall which question of mine you answered "yes" to 3 days ago? :p
23:16:52 <lambdabot> Consider it noted.
23:17:22 <elliott> Is there any way to use the hOpenGL binding without having your entire program within IO?
23:17:33 <ddarius> Cale: Simply don't right align anything.
23:17:58 <ddarius> elliott: The same way you write any program without having the entire thing be in IO.
23:18:16 <elliott> ddarius: um, it's not that simple, because hOpenGL operates primarily with (IO a) callbacks.
23:18:22 <Cale> elliott: Put the part of your program which actually draws stuff on the screen in IO, have the part of your program which decides what to draw not be in IO.
23:18:37 <Cale> IO things can use non-IO things
23:18:40 <elliott> Cale: Except that OpenGL pretty much inverts that by calling your program rather you calling it.
23:18:40 <ddarius> elliott: So does Gtk2hs and practically all GUI libraries.
23:18:44 <Cale> as part of their definition
23:18:59 <elliott> And sure, but I can't runBlah every single time a callback is called.
23:19:04 <Cale> ???
23:19:11 <elliott> If it was (MonadIO m) => ... then it would be fine.
23:19:12 <Cale> I don't understand
23:19:20 <Cale> Why are you transforming the IO monad here?
23:19:26 <elliott> Cale: My program fits a monad stack with IO at the bottom.
23:19:29 <Cale> :(
23:19:32 <elliott> That's hard to use in an OpenGL callback.
23:19:42 <elliott> (Not all of my program, of course; but the parts that interact with the world.)
23:19:48 <Cale> Monad transformers applied to IO make me sad
23:20:07 <elliott> I seem to recall lambdabot using one ;-)
23:20:10 <ddarius> Indeed, there are very few monadic effects not already captured by IO.
23:20:15 <Cale> I didn't write lambdabot
23:20:24 <elliott> Well, I'd like to use STM.
23:20:27 <Cale> sure
23:20:32 <Cale> atomically
23:20:36 <Cale> :t atomically
23:20:37 <lambdabot> Not in scope: `atomically'
23:20:44 <Cale> :t Control.Monad.STM.atomically
23:20:45 <lambdabot> Couldn't find qualified module.
23:20:49 <Cale> err
23:20:52 <ddarius> @hoogle atomically
23:20:52 <lambdabot> Control.Exception data NestedAtomically
23:20:53 <lambdabot> Control.Exception NestedAtomically :: NestedAtomically
23:20:53 <lambdabot> Control.OldException NestedAtomically :: Exception
23:20:56 <Cale> :t Control.Concurrent.STM.atomically
23:20:57 <lambdabot> Couldn't find qualified module.
23:21:08 <elliott> It's in Control.Monad.STM.
23:21:21 <Cale> yeah, thought so
23:21:32 <elliott> Still, I'm not sure what you're saying -- don't use the Reader monad at all, just use IORefs and never write to them? That really sounds anti-Haskelly to me.
23:21:33 <Cale> anyway, it's  STM a -> IO a
23:21:43 <Cale> Use function parameters
23:21:49 <Cale> instead of ReaderT over IO
23:21:55 <elliott> So, ?unmtl on my whole program?
23:22:04 <Cale> kinda
23:22:05 <elliott> That's... kind of ridiculous; by that argument monads shouldn't be used at all.
23:22:11 <Cale> ???
23:22:13 <elliott> Just transform them into the equivalent functions.
23:22:14 <Cale> You're using a monad
23:22:30 <elliott> Yes, but how on earth is passing around a parameter everywhere superior to using the Reader monad? That's what it's for.
23:22:34 <elliott> (Reader was just an example.)
23:22:46 <Cale> You don't have to lift things
23:23:02 <Cale> and it's more natural to use higher order actions
23:23:09 <elliott> I still don't know what your objection is to monad transformers over IO.
23:23:10 <mgsloan> anyone know off hand if implicit parameters work with quasiquoters / TH expansions? :D
23:23:15 <shachaf> Cale: Does Iteratee ByteString IO a make you sad?
23:23:27 <elliott> From my perspective you basically seem to be telling me to write my whole program in an uglier, more difficult style, because ...
23:23:33 <Cale> shachaf: Well, iteratees make me sad for a different reason
23:23:33 <mgsloan> (as in parameters to the compile-time expansions, not parameters to the results)
23:23:38 <Cale> But not for this reason
23:23:40 <elliott> What's wrong with iteratees?
23:24:08 <Cale> They seem like kind of an ugly solution to the problem that they solve.
23:24:26 <dobblego> the way they solve it is brilliant
23:24:27 <Cale> And granted, the problem they solve is kind of ugly to begin with.
23:24:39 <elliott> I've found using iteratees very convenient and pretty.
23:24:49 <elliott> I can't think of a way to make it less "ugly" without removing any of the fundamental properties.
23:25:04 <shachaf> Is there no reasonable way to do "catch" with Iteratee?
23:25:06 <dobblego> I've managed to get monadic iteratees into a regular Java web application in production
23:25:20 <dobblego> by not using Java of course (since no Monad)
23:33:19 <elliott> I wonder if the OpenGL binding could be modified to use MonadIO...
23:34:12 <Saizan> MonadIO is not enough for APIs that take callbacks
23:36:51 <danharaj> opengl doesn't take callbacks though
23:37:00 <danharaj> GLUT does
23:37:12 <elliott> I was referring more to begin/end
23:37:24 <elliott> True that GLUT is the one taking actual callbacks.
23:37:26 <danharaj> begin/end are deprecated, they shouldn't be used.
23:37:55 <danharaj> ... windows update is memory leaking all over my computer, thrashing my memory.
23:37:56 <danharaj> I'll be right back.
23:38:01 <elliott> <danharaj> begin/end are deprecated, they shouldn't be used.
23:38:04 <elliott> huh? really?
23:38:09 * ddarius isn't sure what iteratees provide that Java-style wrappers, like BufferedReader, don't.
23:38:10 <elliott> I was unaware that they were replaced
23:38:21 <ddarius> Deprecated /= replaced.
23:38:25 <dobblego> ddarius: composition
23:38:25 <danharaj> Yeah, they were deprecated in OpenGL 3.0 and officially 'removed' in OpenGL 4.0
23:38:46 <danharaj> The standard way of doing things now is via shader programs and buffer objects
23:38:56 <elliott> danharaj: Oh, well to hell with that. :)
23:40:11 <ddarius> dobblego: What's an example of something that is easy with iteratees that would be difficult with Java-style wrappers that also implement, what C# calls, IEnumerable?
23:41:04 <thoughtpolice> elliott: well, re: iteratees, i've said this a few times, but one thing is they shift you from is lazy IO where you get natural incremental computation over a stream to composing chunk processors that work over parts of a stream at a time. dolio (IIRC) has formulated this a bit better than i can
23:41:25 <elliott> thoughtpolice: i... like iteratees
23:41:26 <thoughtpolice> i like the natural looking incremental approach which is similar to what we see in processing other streams that aren't backed by IO, even if it's a "theoretical abomination"
23:41:28 <elliott> dunno who you meant o talk to
23:41:41 <thoughtpolice> elliott: 01:55 < elliott> What's wrong with iteratees?
23:41:51 <elliott> yes, asked at Cale, who said he disliked iteratees
23:42:01 <elliott> oh, hmm
23:42:09 <Saizan> elliott: thoughtpolice is exposing why he doesn't like them
23:42:13 <elliott> thoughtpolice: well I consider lazy IO a really irrelevant alternative
23:42:27 <elliott> you just can't use it, full stop, because your memory usage will be unacceptable, and your program will be unpredictable
23:42:33 <elliott> does anyone _actually_ use it? like, not in a toy script?
23:42:59 <dobblego> ddarius: type >@> = Iteratee in out; safeHead :: e >@> Maybe e; drop :: Int -> (e >@> ()) safeHead >>= \h -> drop >>= f h
23:43:15 <dobblego> s/ safeHead/; safeHead
23:43:26 <thoughtpolice> now all that said I do think iteratees solve a problem, and they are good if your domain is particularly I/O heavy, but frankly you can do lots of things in plenty of domains that aren't super heavy with I/O, and iteratees are probably overkill there
23:49:39 <ivanm> in graphviz, does anyone think it would be a problem if I made it a requirement that all subgraphs and clusters _must_ have an identifier (and automatically added one to anonymous ones when being parsed) ?
23:51:23 <ddarius> dobblego: In pseudo-C# terms: var h = safeHead(s); drop(n, s); f(h);  safeHead(s) { case s.Next() of Nothing -> return Nothing; Just x -> return (Just x) }; drop(n, s) { for(int i = 0; i < n; ++i) { s.Next() } }
23:51:55 <dobblego> ddarius: I should have said peek, not head (do not advance the iteratee)
23:51:59 <dobblego> sorry
23:52:10 <ddarius> That's easier, then it's s.Current
23:52:45 <dobblego> but drop does advance the iteratee
23:53:01 <ddarius> dobblego: Hopefully, otherwise it would seem a bit silly.
23:53:26 <ddarius> At any rate, you haven't yet demonstrated an advantage to me.
23:53:40 <dobblego> I don't know how you mean you'd implement that
23:54:00 <dobblego> how does safePeek not advance the iteratee?
23:55:11 <ddarius> dobblego: Can you look arbitrarily far ahead?  If so, how does that work with networking?  Either way, I can certainly implement a wrapper that allows that.
23:56:00 <dobblego> ddarius: sure, you can look as far ahead as you like, if you're prepared to spend it
23:56:40 <dobblego> I can't think of a way of achieving composition without just reinventing some form of iteratee
23:57:29 * hackagebot text 0.11.1.2 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.1.2 (BryanOSullivan)
23:57:45 <ddarius> How was the code I wrote less compositional than your example.  I can easily throw a s => on the front to make it a function.
23:58:26 <dobblego> I haven't seen the code for \k n -> liftM2 k safePeek (drop n)
23:59:26 <ddarius> (k, n, s) => var h = safePeek(s); var l = drop(n, s); k(n, l)
23:59:36 <ddarius> (Probably, k(n, l, s)
23:59:37 <ddarius> )
23:59:45 <dobblego> how does your safePeek look?
