00:01:20 <dankna> for anyone following my continuing saga, taking a nap and redoing my code to use (IOUArray Double, IOUArray Double) instead of IOArray (Complex Double) knocked off another 80%ish
00:01:32 <dankna> I suspect the redoing of the code helped more than the nap, but both were essential :)
00:02:58 <luite> hehe
00:03:23 <shachaf> dankna: Is there no unboxed Complex array?
00:03:34 <dankna> that is correct
00:04:01 <dankna> and if it's possible to write one without modifying the array package, it's not clear to me how
00:04:06 <shachaf> Apparently there's a Data.Vector.
00:04:15 <shachaf> http://hackage.haskell.org/packages/archive/vector/0.7.0.1/doc/html/Data-Vector-Unboxed.html
00:04:16 <dankna> I also achieved further performance boosts by not using Data.Complex
00:04:28 <dankna> which apparently does an unnecessary exp on the zero real component
00:04:38 <dankna> hmm, yeah, someone mentioned that a while back
00:05:00 <dankna> I'll look into that once I have performance at an acceptable level
00:05:51 <shachaf> dankna: (Which apparently also lets you implement your own instances easily.)
00:06:37 <dankna> yeah, I see that
00:06:52 <dankna> at this moment I'm more interested in removing abstractions than adding them :)
00:06:59 <dankna> but I will definitely give it a look at some point
00:07:11 * shachaf wonders what dankna is doing in this channel.
00:07:15 <dankna> hahaha
00:07:17 <dankna> point taken
00:07:27 <dankna> but I've always said I don't believe in functional programming /per se/
00:07:38 <dankna> I believe in a discipline/idiom/thing I call "useful programming"
00:07:46 * shachaf once again wonders what dankna is doing in this channel.
00:07:59 <dankna> writing Haskell code, what else?
00:08:20 <dankna> though it may not have been intended as such, I find ghc a powerful tool for this "useful programming" :)
00:08:41 <dankna> one of the tenets of which is that powerful tools are where you find them, haha
00:09:31 <dankna> sweet, I'm down to less than a second of runtime.  time to turn up the input parameters.
01:05:06 <adrake> how can I reasonably parse a string to an integer while allowing for failure when outside of the IO monad?
01:05:29 <adrake> (i.e. "read" but returning Nothing instead of calling error)
01:05:48 <tchabinka> hi all
01:06:31 <wyksztalcioch> anybody here?
01:06:33 <adrake> I can catch an exception in the I/O bits, but I was kind of hoping to leave my parsers out of the I/O monad
01:06:41 <adrake> wyksztalcioch, hi :)
01:07:07 <wyksztalcioch> hi adrake :)
01:07:15 <wyksztalcioch> i'm total newbie, and i have a little problem - anyone can help me?
01:07:27 <identity_> adrake: reads
01:07:59 <quicksilver> adrake: never ever catch the error from 'read'. Use 'reads' instead, IO or otherwise.
01:08:06 <identity_> > reads "[3, 4]" :: [([Int], String)]
01:08:07 <lambdabot>   [([3,4],"")]
01:08:17 <quicksilver> wyksztalcioch: yews, there are almost always people here to help, just ask your question.
01:08:22 * shachaf wonders why there still isn't a standard function that returns a Maybe.
01:08:26 <identity_> > reads "[3, 4]" :: [([Char], String)]
01:08:27 <lambdabot>   []
01:08:34 <identity_> see, on failure, an empty list is returned
01:08:41 <adrake> identity_, that works, thanks, I was hoping for something a little cleaner from the stdlib
01:08:53 <adrake> but I guess that's good enough :)
01:09:10 <wyksztalcioch> quicksilver - ok, now i just solved my problem :)
01:09:12 <wyksztalcioch> thx
01:09:25 <identity_> Not sure if you're implying that it isn't clean or not from the stdlib, both, or not clean and from the stdlib. If it's the last one, then I agree
01:09:29 <identity_> The type signatures get ugly
01:09:42 <identity_> But it is reasonably clean as you still won't ahve to deal with exceptions
01:10:07 <quicksilver> the type signatures don't necessarily get ugly.
01:10:19 <quicksilver> in fact, quite often you can do without them entirely because something else in your code fixes the type.
01:10:20 <adrake> identity_, I was implying it was not as clean as it could be for something in the stdlib that seems relatively common
01:10:27 <identity_> aye
01:10:31 <identity_> oh, yeah
01:10:31 <adrake> (my code happens to fix the type, so it's a very small nuisance)
01:10:36 <identity_> I didn't have to explicitly do that stuff
01:10:46 <quicksilver> adrake: if I need it, I normally define readMaybe
01:10:49 <identity_> > reads "[3, 4]" :: ReadS [Int]
01:10:50 <lambdabot>   Couldn't match expected type `Text.ParserCombinators.ReadP.ReadS
01:10:50 <lambdabot>           ...
01:10:52 <identity_> eh
01:11:12 <adrake> :P
01:11:27 <quicksilver> readMaybe x = case reads x of [(v,"")] -> Just v; _ -> Nothing
01:11:29 <identity_> oh
01:11:30 <identity_> nvm
01:13:42 <identity_> adrake: Haskell doesn't always hand you complete solutions for every small problem out there. It's more like a lot of small blocks that can be neatly composed into sexier stuff.
01:13:57 <adrake> identity_, I'm aware
01:16:13 <quicksilver> nonetheless, readMaybe should be in the standard library.
01:16:27 <identity_> I agree
01:16:47 <quicksilver> it's defined independently in a million modules on hackage
01:17:17 <quicksilver> it's just one of these things which is such a minor thing that nobody can be bothered to fix it :)
01:17:30 <identity_> @hackage readMaybe
01:17:31 <lambdabot> http://hackage.haskell.org/package/readMaybe
01:17:34 <identity_> meh
01:17:37 <identity_> quicksilver: I believe you
01:19:34 <quicksilver> identity_: the most 'canonical' attempt is in the 'Safe' package I guess.
01:19:52 <quicksilver> (where it's called 'readMay' because characters are *so* expensive and saving two is *so* worthwhile ;)
01:19:58 <identity_> hahah.
01:20:07 <identity_> That shortcut makes no sense
01:20:08 <quicksilver> http://hackage.haskell.org/packages/archive/safe/latest/doc/html/Safe.html
01:20:12 <identity_> s/shortcut/abbreviation/
01:20:19 <identity_> readMay..
01:20:21 <identity_> meh.
01:42:42 <kuraj> http://pastebin.com/LiUSNSSz can someone help me with making the "recursive" function recursive?
01:42:45 <mauke> The paste LiUSNSSz has been copied to http://hpaste.org/48066
01:42:51 <kuraj> nooo
01:42:55 <kuraj> i hope google doesn't index these
01:43:06 <kuraj> anyway..
01:43:13 <kuraj> im really struggling with that one
01:43:53 <kuraj> it produces a nested structure which stands for all solutions to a problem
01:43:55 <erus`> > let f x = f x in f 2
01:43:59 <lambdabot>   mueval-core: Time limit exceeded
01:44:55 <kuraj> but it places a single ship on the grid out of a list, and the next step i want to acheive is to concat that list with a list of results that come from adding the next ship to the results
01:45:03 <erus`> wtf is a singleton ship?
01:45:16 <kuraj> a ship that consists of a single piec
01:45:18 <kuraj> piece*
01:46:26 <kuraj> mkShipList produces ships (lists of tuples) out of a numeric list; index of list denotes how many pieces it holds and value determines how many of those will exist
01:46:42 <frerich> A downside of being exposed to Haskell is that I get really unpopular with my colleagues.
01:46:46 <kuraj> the code is pretty ugly
01:47:01 <frerich> I recently suggestet a 'map' function for some JavaScript code (to get rid of tons of loops) and I didn't make friends.
01:48:14 <adrake> pylint yells at you for using python's built in map and filter functions, much to my dismay
01:49:20 <kuraj> .. what the fuck did i write
01:49:48 <osfameron> what was the derivation of "monad" again (the name, I mean)
01:49:49 <osfameron> ?
01:50:04 <osfameron> (I seem to remember it has a different etymology than the philosophical "monad"?)
01:50:46 <kuraj> warm fuzzy thing
01:50:58 <osfameron> ;-)
01:51:47 <shachaf> adrake: Wow, it actually does.
01:52:02 <shachaf> Is there any justification behind that?
01:52:15 <adrake> shachaf, they want you to use list comprehensions instead
01:52:42 <adrake> iirc map is [f(x) for x in y], and filter is [x for x in y if f(x)]
01:53:24 <frerich> adrake: I think those two examples already nicely show how much more readable names like 'map' and 'filter' are in comparison with comprehensions.
01:53:26 <shachaf> Hooray for introducing needless variable names!
01:53:39 <adrake> seriously
01:53:41 <shachaf> @unpl map f y
01:53:41 <lambdabot> map f y
01:53:48 <shachaf> You have much to learn, lambdabot.
01:53:52 <adrake> haha
01:54:14 <shachaf> Does it complain about reduce too?
01:55:56 <quicksilver> osfameron: "sounds a bit like Monoid"
01:56:03 <quicksilver> osfameron: (as far as I know, that's as deep as it goes)
01:56:30 <int-e> adrake: [f x | x <- y] and [x | x <- y, f x] are perfectly valid Haskell code.
01:56:55 <adrake> shachaf, it doesn't appear to whine about reduce
01:57:12 <adrake> shachaf, I can't say I've ever tried to do use in python, though
01:57:15 <adrake> er
01:57:18 <adrake> use that
01:57:34 <adrake> int-e, it's true, but like their python equivalents, neither is as concise as map or filter
01:58:22 <osfameron> quicksilver: heh, yes, that's what I remember - presumably the suffix "-ad" has a certain connotation too?
01:58:57 * hackagebot repa-bytestring 2.0.0.4 - Conversions between Repa Arrays and ByteStrings.  http://hackage.haskell.org/package/repa-bytestring-2.0.0.4 (BenLippmeier)
02:00:07 <Cale> monoid + triad
02:00:38 <Cale> (triad was one of the original names for it, since it's (T,eta,mu))
02:01:01 <Cale> They were also known as "triples" and "the standard construction" :)
02:01:23 <Cale> until someone invented a decent enough name :P
02:01:34 <quicksilver> http://english.stackexchange.com/questions/30654/where-does-the-term-monad-come-from
02:01:51 <quicksilver> appears to reproduce material from an email on the categories mailing list which I vaguely remember reading.
02:02:18 <osfameron> presumably the coiner of "monad" was aware of the philosophical usage of the term too, and felt it was suggestive too?
02:02:53 <quicksilver> possible, but who knows.
02:03:13 <quicksilver> I have found the thread
02:03:18 <quicksilver> I wonder if cat has an archive
02:03:25 <identity_> It was definitely chosen because it rhymes with "gonad"
02:03:42 <identity_> In order for category theory wizards to go "oh monads gonads" when arguing
02:04:46 <quicksilver> identity_: unfortunately it doesn't rhyme with gonad, so that theory falls at the first hurdle.
02:05:03 <quicksilver> bah gmane is made of fail.
02:05:07 <osfameron> it doesn't?
02:05:34 <osfameron> mow-nad, gow-nad.  or moh-nad?
02:07:18 <quicksilver> osfameron: http://www.mta.ca/~cat-dist/archive/2009/09-4
02:07:29 <quicksilver> osfameron: browser search for 'where does the term'
02:07:50 <quicksilver> "mon-ad" rhymes with "gone bad"
02:08:37 <shachaf> That's an odd sense of the word "rhyme" in any pronunciation I can think of.
02:09:07 <erus`> i wish the haskell reddit had more posts in a day
02:09:20 <erus`> is there a good haskell news source?
02:10:00 <shachaf> @where planet
02:10:00 <lambdabot> http://planet.haskell.org/
02:10:18 <shachaf> If there isn't enough news, go make some news.
02:11:17 <quicksilver> Cale: I don't think triad was ever a widespread term, and the posts in that thread back me up on that
02:11:32 <quicksilver> Cale: I think it was an experimental alternative to triple which never really caught.
02:12:09 <osfameron> be the clown porn^W^Whaskell news you want to see in the world!
02:12:58 * hackagebot hack2-handler-snap-server 2011.6.21 - Hack2 Snap server handler  http://hackage.haskell.org/package/hack2-handler-snap-server-2011.6.21 (JinjingWang)
02:13:39 <osfameron> quicksilver: thanks, interesting page.  I like the backstabbing and the gossip
02:14:04 <dabblegoo> what is a good trivial example of mutual recursion?
02:14:41 <theorbtwo> a x = b x + 1; b x = a x + 1
02:14:49 <theorbtwo> Not a useful one, but a trivial one.
02:16:22 <osfameron> theorbtwo: that doesn't terminate though
02:17:20 <ion> Termination is orthogonal to mutual recursion.
02:17:34 <quicksilver> dabblego: mutual recursion is never essential; typical examples are natural structural functions over mutually recursive data types.
02:18:03 <quicksilver> trees which contain annotations which may contain other trees, say.
02:19:21 <dabblego> quicksilver: do you have a small example that you would use for demonstration?
02:27:38 <dabblego> I can only think of larger ones
02:28:50 <osfameron> dabblego: what's this for?
02:28:57 <dabblego> demonstration :)
02:31:53 <erus`> my chess code is ugly :(
02:32:09 <erus`> lots of duplication
02:32:58 <quicksilver> dabblego: not really, no. It's hard to come up with a mutually recursive data structure which is well-motivated and small.
02:33:26 <dabblego> yeah I might give it a miss, never mind, thanks
02:35:03 <Eduard_Munteanu> Hrm, I wonder if any mutually recursive structure/function can be reduced to normal recursion.
02:35:45 <quicksilver> Eduard_Munteanu: yes, it can.
02:35:56 <quicksilver> Eduard_Munteanu: that's what I meant by 'mutual recursion is never essential'
02:36:01 <identity_> explicitly stating the type signature of a combination of reads and an IO function, all lifted into IO because it's in a transformer monad results in one ugly type signature =(
02:36:08 <Eduard_Munteanu> But not like recursion can be trivially reduced to iteration by simulating a stack.
02:36:12 <Eduard_Munteanu> Not in that sense.
02:36:39 <quicksilver> we apparently have a different perspective.
02:36:58 <quicksilver> I would say that reducing mutual recursion to single recursion is much simpler than reducing recursion to iteration.
02:37:18 <Eduard_Munteanu> Ah, I see.
02:37:22 <quicksilver> it's just inlining (and possibly renaming)
02:39:54 <Eduard_Munteanu> Still, I'd guess tail recursion makes it easier for mutual recursion too.
02:41:07 <Eduard_Munteanu> (Say, the transformation is trivial if you need only O(1) additional space/time to make it explicit.)
02:44:34 <Algo> does haskell support non-green threads?
02:45:16 <Defiance> Algo:forkIO
02:45:25 <Defiance> forkOS*
02:45:42 <Defiance> Ahh, crap - excuse me ;)
02:46:05 * hackagebot hack2-handler-warp 2011.6.21 - Hack2 warp handler  http://hackage.haskell.org/package/hack2-handler-warp-2011.6.21 (JinjingWang)
02:46:09 <Defiance> Algo: forkOS is a proper OS thread.
02:47:05 * hackagebot hack2-contrib 2011.6.21 - Hack2 contrib  http://hackage.haskell.org/package/hack2-contrib-2011.6.21 (JinjingWang)
02:48:07 <Defiance> Algo: and run with -threaded
02:49:05 * hackagebot maid 2011.6.21 - A simple static web server  http://hackage.haskell.org/package/maid-2011.6.21 (JinjingWang)
02:49:18 <solrize> are adt's the reason haskellers don't care about subtyping?
02:49:34 <solrize> that and type classes
02:52:12 <dabblego> solrize: you can have ADTs in languages with subtyping, even Java
02:52:49 <osfameron> you'd probably implement the ADTs *using* subtyping, even
02:52:59 <osfameron> at least, that's what I'm playing with using Perl
02:52:59 <dabblego> type-classes give you that implicit conversion though
02:53:11 <dabblego> pfft, church-encode!
02:54:04 <dabblego> in Java, it is possible to create a type, for which you can control the subclasses using a little-known language trick, giving you the ability to provide closed sum ADTs
02:55:57 <solrize> dabblego, yeah, what i was asking was more like "hmm, java has subtypes, why doesn't haskell?".  and was asking whether "haskell has adt's and typeclasses so it doesn't need subtypes"
02:56:02 <osfameron> dabblego: "implicit conversion" ?
02:56:30 <dabblego> osfameron: not having to pass an explicit dictionary
02:57:12 <dabblego> data Eq a = Eq { (==) :: a -> a -> Bool } {- explicit -} class Eq a where (==) :: a -> a -> Bool {- implicit -}
02:57:50 <Algo> Defiance: Thanks :-]
02:58:33 <osfameron> dabblego: sorry, I don't understand what you're showing me there
02:58:49 <zygoloid> dabblego: i wouldn't call that conversion.
02:59:09 <zygoloid> implicit evidence passing, certainly
02:59:28 <dabblego> zygoloid: I am currently using a language for which the distinction is not there
02:59:30 <zygoloid> (though even that is an implementation technique)
02:59:53 <zygoloid> dabblego: you're also currently communicating with haskellers :)
03:00:13 <dabblego> I apologise for my incomplete context switch
03:02:54 <int-e> solrize: that's true to some extent. it doesn't solve the expression problem (e.g., http://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt )
03:03:45 <int-e> I guess that's an open sum. hmm.
03:04:19 <solrize> int-e hmm thanks
03:04:27 <solrize> open sum = row type?
03:07:09 <int-e> not sure what you mean by row type. ADTs give you sum types, Expr = Const Int | Plus Expr Expr | Times Expr Expr ... but they are closed in the sense that you have to fix the set of alternatives when declaring the type. what I mean by an open sum is something similar, but with the possibility to add new alternatives later on. (something that in OO you can do very easily)
03:07:52 <opqdonut> no you can't
03:08:15 <opqdonut> inheriting code that is not your own is often hard or next to impossible, and interfaces are about as limited as haskell type classes
03:08:40 <Maxdamantus> Is the determining of the type of something like Set.empty considered "polymorphism" other than in the sense of parametric polymorphism?
03:08:52 <Maxdamantus> (or `show`)
03:09:10 <int-e> by having an interface Expr, with subclasses Const, Plus, Times ... of course you'll have to put pretty much you'll ever want to do with such types into the Expr interface, and implement the functionality for each subclass.
03:10:01 <opqdonut> int-e: and that is actually doable using type classes too
03:10:07 <solrize> int-e yeah, a sum type where you an add new constructors is what i think is the same as a row type
03:10:18 <opqdonut> (but not very pretty, of coursE)
03:10:22 <Maxdamantus> I've thought of "polymorphism" in something like Java as taking into account the concept of static versus dynamic type, which doesn't appear to exist in Haskell's type system.
03:10:30 <erus`> @hoogle sqrt
03:10:30 <lambdabot> Prelude sqrt :: Floating a => a -> a
03:10:39 <erus`> how to integer sqrt?
03:11:16 <int-e> opqdonut: I wasn't saying it's not possible to achieve this in Haskell (or even that it's hard) - my point was that ADTs alone won't allow you to do this.
03:11:41 <Eduard_Munteanu> Maxdamantus: types == static types   in Haskell
03:12:15 <Maxdamantus> Indeed.
03:12:19 <Eduard_Munteanu> And dictionaries *kinda* fill in the role for RTTI.
03:12:24 <opqdonut> int-e: yeah I didn't read the context
03:12:53 <Maxdamantus> So Haskell is only polymorphic in the parametric sense?
03:13:45 <quicksilver> Defiance, Algo : forkOS is not a "proper OS thread".
03:14:05 <solrize> erus`, floor . sqrt   ?
03:14:06 <Eduard_Munteanu> You can simulate ad-hoc polymorphism using typeclasses and newtypes, you just have to do your own dispatch manually
03:15:03 <Eduard_Munteanu> Erm, scratch that, it isn't really ad-hoc polymorphism.
03:15:11 * Eduard_Munteanu bbl
03:15:39 <solrize> what's ad-hoc polymorphism?  something different from type classes?
03:16:08 <Maxdamantus> if you look at Java, you'll see that ArrayList<T> is also a List<T>
03:16:08 <Eduard_Munteanu> solrize: C++-style overloading
03:16:15 <Maxdamantus> I think that's ad-hoc.
03:16:48 <Maxdamantus> So you can treat the data as one of many types.
03:16:52 <Eduard_Munteanu> (for example)
03:16:54 <solrize> hm
03:16:55 <zygoloid> solrize: ad-hoc polymorphism is where the operation is not uniform in the type of the value
03:17:12 <solrize> zygoloid, that sounds like type classes
03:17:42 <Defiance> quicksilver: I see, http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#v:forkOS - Is there a way to do proper OS level threads?
03:17:56 <zygoloid> solrize: a function which takes (Eq a => a) is not ad-hoc, since it can't choose whether or not to apply (==) based on the type
03:18:02 <solrize> forkOS is OS level threads
03:18:29 <int-e> Maxdamantus: that List<T>, ArrayList<T> example is still perfectly parametric - in Haskell, you could have a superclass  class List l e => ArrayList l e where ... (note: this is not really a sane design for such containers in Haskell, imho)
03:18:34 <Defiance> solrize: Documentation says otherwise
03:19:06 <solrize> zygoloid, right, but somewhere there's an Eq instance declaration for any type the function receives, which can do something specific to that type
03:19:24 <Maxdamantus> int-e: but you can ignore the type.
03:19:28 <quicksilver> solrize: no, it is not.
03:19:41 <Maxdamantus> int-e: in Java 4, where there is no parametricity iirc .. ArrayList is still a List.
03:20:03 <Maxdamantus> class Foo {} class Bar extends Foo {} .. a Bar is a Foo.
03:20:07 <quicksilver> Defiance: you control the number of actual capabilities with the -N RTS flag.
03:20:32 <Maxdamantus> int-e: in Haskell you don't have that afaicto
03:21:00 <Maxdamantus> Foo :: T1 .. Foo :: T2
03:21:07 <quicksilver> Defiance: there are a few things you can do to persuade the scheduler to work a certain way; mostly described on that page you already linked to.
03:21:14 <quicksilver> Defiance: not sure what your actual objective is?
03:21:17 <Maxdamantus> s/Foo/foo/g
03:21:17 <zygoloid> solrize: yeah. i'm not sure whether there's consensus here, but i'd personally say that type class methods use ad-hoc polymorphism, and all other functions use parametric polymoprhism.
03:21:24 <solrize> Defiance, see the section above, on bound threads
03:23:38 <solrize> hmm ok
03:23:43 <int-e> Maxdamantus: yeah, right, since what you really do is abstract over some interface. so to model that abstraction in Haskell, you end up with an existential type, which is not Haskell98.
03:24:31 <int-e> (nor Haskell2010)
03:24:31 * hackagebot dtd-text 0.1.1.1 - Parse and render XML DTDs  http://hackage.haskell.org/package/dtd-text-0.1.1.1 (YitzGale)
03:25:43 <Maxdamantus> Mmm .. interesting.
03:25:50 <Defiance> quicksilver: Ahh I thought so - was just curious. Cheers.
03:27:39 <sirhug> hello, how can i do reorder of execution in a monad? is it possible?
03:27:46 <int-e> Maxdamantus: and then it works. if you have  data FooInst where FooInst :: Foo a => a -> FooInst and data BarInst where BarInst :: Bar a => a -> BarInst, with class Foo a => Bar a, then you can take a BarInst and convert it to a FooInst.
03:27:51 <identity_> sirhug: care to give us an example?
03:28:39 <sirhug> identity_: i tryed to do it, but i couldnt, some like integer priority indexed IO actions which gets executed in that order
03:29:13 <Jafet> @google whenever programming language
03:29:14 <lambdabot> http://www.dangermouse.net/esoteric/whenever.html
03:29:14 <lambdabot> Title: DM's Esoteric Programming Languages - Whenever
03:29:15 <identity_> Sort them by the integers and sequence
03:29:18 <identity_> :t sequence
03:29:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
03:29:54 <sirhug> yeah, but i want to do it automatically in the monad, is this possible, i cant see the pattern
03:30:25 <identity_> let actions = [(1, "action1"), (2, "action2")] in sequence $ sortBy (comparing fst) actions
03:30:29 <identity_> f
03:30:32 <Jafet> I didn't know that monads have insides
03:30:34 <identity_> > let actions = [(1, "action1"), (2, "action2")] in sequence $ sortBy (comparing fst) actions
03:30:34 <lambdabot>   No instance for (GHC.Base.Monad ((,) a))
03:30:35 <lambdabot>    arising from a use of `e_11122'...
03:30:57 <identity_> I have no idea what the error is telling me
03:31:09 <identity_> oh
03:31:14 <quicksilver> sirhug: you want to design a monad such that "a << b" doesn't necessarily run 'a' first, but runs the highest priority one first?
03:31:27 <identity_> > let actions = [(1, "action1"), (2, "action2")] in sequence . map snd $ sortBy (comparing fst) actions
03:31:28 <lambdabot>   ["aa","ac","at","ai","ao","an","a2","ca","cc","ct","ci","co","cn","c2","ta"...
03:31:29 <sirhug> yes
03:31:33 <identity_> huh.
03:31:37 <quicksilver> sirhug: I doubt that makes esne.
03:31:39 <identity_> oh yeah, I don't grok the list monad properly
03:31:47 <identity_> @src sequence
03:31:47 <lambdabot> sequence []     = return []
03:31:48 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
03:31:48 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
03:31:50 <quicksilver> sirhug: { do x <- a; b x; c x; }
03:32:05 <sirhug> i thought in monads i could alter the order of execution
03:32:09 <quicksilver> sirhug: even if "a" is lower priority, its value is needed for b and c to run
03:32:34 <sirhug> oh thats right
03:32:54 <quicksilver> you could design a combinator which does what you want
03:32:57 <quicksilver> it just wouldn't be <<
03:33:05 <quicksilver> it would be, a combinator of your own design.
03:33:10 <sirhug> but using raw actions? i mean no >>= just >>
03:33:18 <quicksilver> a `doTheseInPriorityOrder` b
03:33:34 <Jafet> I don't see a need to reorder execution when when lazy evaluation already provides an order that always works
03:33:34 <quicksilver> "no >>= just >>" is not "raw actions".
03:33:55 <quicksilver> Jafet: !@
03:34:03 <quicksilver> Jafet: there are lots of reasons to want to choose the order of execution.
03:34:07 <sirhug> ok what i mean is no functions which return actions
03:34:14 <quicksilver> Jafet: earnMoney before spendMoney!
03:34:24 <quicksilver> this has nothing to do with lazy evaluation.
03:34:29 <Jafet> Use the credit card transform!
03:34:35 <quicksilver> in fact lazy evaluation is quite irrelevant to "order of execution".
03:34:51 <quicksilver> sirhug: I think you're just making up words and wanting them to mean what you want them to mean.
03:34:51 <identity_> winLottery >> forever spendMoney
03:35:01 <Jafet> Well ok, lazy evaluation only works for pure Monads.
03:35:18 <sirhug> maybe, i have not a solid base on haskell
03:35:19 <quicksilver> sirhug: you can absolutely define a combinator which combines things according to some priority metric.
03:35:31 <quicksilver> sirhug: but that will not be >> for any sane monad I don't think.
03:35:51 <quicksilver> Jafet: that's not really true either; in a pure setting there can still be cases where order matters.
03:37:18 <sirhug> some time ago i think i saw a tutorial on making a monad with delayed execution but i cant find it, is taht possible?
03:37:35 <identity_> a pure monad? I don't think so
03:37:41 <sirhug> delayed, i mean with "suspend"
03:38:05 <sirhug> well i cant remember well, i wish i could find it again
03:38:15 <identity_> Is it possible to delay the execution of IO actions using threadDelay-ish functions? yes
03:39:30 <sirhug> i think it were no IO actions, just a different monad
03:41:27 <nus> Control.Monad.Run ?
03:42:40 <sirhug> how can you suspend a computation in there?
03:44:43 <wyksztalcioch> i have file with text "5.", i want read only "5", so i make "number <- hGetLine handle putStrLn $ init number"
03:44:50 <wyksztalcioch> why it print "5."?
03:45:51 <zygoloid> sirhug: (hint) start with this: data Suspend a = Return a | Wait (Suspend a)
03:46:40 <sirhug> uh thanks!
03:47:10 <sirhug> wyksztalcioch: what happens if you putStrLn withouth init thing
03:47:43 <sirhug> i bet it has more chars
03:49:02 <wyksztalcioch> sirhug: thx - in file i have one space after .
03:49:29 <identity_> wyksztalcioch: init "abc" gives you all but the last element. hGetLine may read the newline or a space like you said
03:49:39 <identity_> if the number is always single digit, you just want head instead of init
03:51:57 <quicksilver> takeWhile isDigit, perhaps.
03:52:04 <identity_> that works as well
03:52:06 <wyksztalcioch> it may be few digits, so i need init
03:52:08 <quicksilver> > takeWhile isDigit "1234...asd.ads.asfd.asfas."
03:52:08 <lambdabot>   "1234"
03:52:15 <identity_> wyksztalcioch: then use quicksilver's solution
03:54:13 <wyksztalcioch> ok, i'm think it would be fine
04:38:50 <Andi> I tried the Haskell web console in firefox, and it seems to be broken...
04:39:08 <benmachine> Andi: in what sense broken
04:39:19 <Andi> I have to type the commands twice to get the correct output.
04:39:32 <Eduard_Munteanu> It's too lazy I guess :P
04:39:40 <Eduard_Munteanu> It needs prodding.
04:39:44 <Andi> The first time i write the command, I get the output from the last command I wrote..
04:39:47 <benmachine> yeah it happens to me
04:39:48 <benmachine> too
04:39:53 <Andi> :)
04:39:56 <Andi> I see
04:40:26 <benmachine> @tell chrisdone tryhaskell seems to be giving the output of the command before the one you just input, it's very odd
04:40:27 <lambdabot> Consider it noted.
04:41:37 <Andi> > "hello" => 1 > "hello" => "hello"
04:41:38 <lambdabot>   <no location info>: parse error on input `=>'
04:42:27 <Eduard_Munteanu> > ("hello", 1 > "hello", "hello")
04:42:28 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
04:42:28 <lambdabot>    arising from the literal ...
04:42:34 <Eduard_Munteanu> @more
04:42:56 <Eduard_Munteanu> @vixen More!
04:42:56 <lambdabot> Math is hard. Let's go shopping.
04:43:19 <Eduard_Munteanu> Anyway...
04:43:21 <Eduard_Munteanu> :t (>)
04:43:22 <lambdabot> forall a. (Ord a) => a -> a -> Bool
04:43:22 <ben> iteratees are hard. let's write code in ruby.
04:44:20 <Eduard_Munteanu> So what you did implies the literal '1' has the same type as the literal "hello" in that context
04:44:36 <Eduard_Munteanu> s/'//
04:45:19 <Andi> hm... Now it is working differently.. I hitted reset and did the same thing once more, and it seems ok
04:45:24 <Eduard_Munteanu> Which isn't true since by default GHC doesn't know how to treat strings as numbers.
04:45:51 <quicksilver> benmachine: it would be a good deal more interesting if it gave the output of the one after :)
04:45:55 <Eduard_Munteanu> Further the types must match anyway.
04:46:01 <benmachine> quicksilver: :)
04:46:08 <Andi> :)
04:47:59 <benmachine> @tell chrisdone oh, it's working again now, please excuse the interruption
04:47:59 <lambdabot> Consider it noted.
04:54:22 <exeter> isArticle (Article _ _ _ _ _ _ _)  = True <- is there a way to make it more compact?
04:54:58 <ion> isArticle (Article {}) = True
04:55:00 <exeter> by using a synonim or something?
04:55:08 <exeter> thanks ion
04:55:15 <exeter> what are {} exactly?
04:55:17 <exeter> oh
04:55:18 <exeter> I see
04:55:19 <exeter> thanks
04:57:00 <Eduard_Munteanu> You might want to try record syntax anyway.
04:57:07 <ion> It would be nice if there were implicit isX functions just like that for data definitions by default.
04:57:16 <quicksilver> sometimes, yes, ion.
04:57:43 <quicksilver> sometimes I even want a parallel data type which is a simple enumeration with the same number of constructors
04:57:54 <quicksilver> data Foo = Foo A B C | Bar D E
04:58:00 <quicksilver> data Foo_Cons = FooC | BarC
04:58:14 * Eduard_Munteanu can think of a macro or TH accomplishing that
04:58:22 <quicksilver> ion: Data.Derive can generate 'is' functions, anyhow.
04:58:31 <ion> quicksilver: Thanks, i’ll take a look.
04:59:14 <quicksilver> http://hackage.haskell.org/packages/archive/derive/latest/doc/html/src/Data-Derive-Is.html#makeIs
04:59:26 <quicksilver> (the only documentation of this particular one is in the comments, but it's natural enough)
05:01:59 <saml> so i'm learning haskell again
05:03:00 <aavogt> Eduard_Munteanu: what is a macro that is not TH?
05:04:14 <Eduard_Munteanu> aavogt: I mean CPP stuff
05:06:44 <exeter> mhhhhhhhhh, and is there a way to take only to write (Article _ artQ _ _ _ _ _) more elegantly? Like Art { artQ } ?
05:07:09 <aavogt> what's the definition of Article?
05:07:12 <quicksilver> exeter: define the type using record notation in the first place.
05:07:12 <opqdonut> exeter: yes, Article {artQ = artQ}
05:07:21 <opqdonut> exeter: if Article is a record with field artQ
05:07:25 <quicksilver> then it will be Article {q=artQ} or simething.
05:10:33 <Eduard_Munteanu> I'm not sure, does plain (Article {}) work if it wasn't defined by record syntax in the first place?
05:11:02 <zygoloid> Eduard_Munteanu: yup
05:11:08 <exeter> thanks
05:11:14 <exeter> indeed record syntax is more tidy
05:11:32 <zygoloid> > case Just {} of Just {} -> ()
05:11:32 <lambdabot>   ()
05:12:00 <Eduard_Munteanu> Ah.
05:15:55 <joe6> @seen dcoutts
05:15:55 <lambdabot> Unknown command, try @list
05:15:55 <preflex>  dcoutts was last seen on #ghc 1 hour, 21 minutes and 10 seconds ago, saying: tibbe: right
05:16:06 <joe6> dcoutts, with this fix, I can use ghci and llvm :  http://sprunge.us/YKXQ
05:16:38 <joe6> dcoutts, not sure if you had seen my earlier message.
05:16:45 <roconnor> any semi standard infix symbols for (flip ($)) and (flip (.))?
05:16:46 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
05:17:37 <roconnor> @tell copumpkin No worries; I was just trying to give out tasks 'cause you asked about them.
05:17:37 <lambdabot> Consider it noted.
05:21:23 <exeter> ok, this is more difficult =)
05:21:35 <exeter> { artTitle = title } works
05:21:36 <exeter> but
05:21:42 <exeter> is it possible to make something like:
05:21:49 <exeter> {  Just artCreaDate = summ  } ?
05:22:16 <aavogt> the pattern is on the right
05:23:13 <aavogt> Article { artCreaDate = Just summ }   -- should match when the artCreaDate isn't Nothing
05:23:47 <tcard> I have a data structure that I would like to declare differently depending on the architecture: essentially use Word64 when 64bit and Word32 otherwise.
05:24:03 <exeter> avvogt,  `title' is not a (visible) field of constructor `Article' <- if I write temToUList deep a@(Article { title = artTitle }) = etc. etc.
05:24:18 <exeter> doh, sorry I didn't read your second line
05:24:19 <tcard> Anybody have advice about the best way to do this?  (Template Haskell?)
05:24:35 <exeter> thanks aavogt
05:26:06 <shachaf> tcard: CPP?
05:27:45 <aavogt> tcard: doesn't just using Word accomplish that?
05:28:13 <stelleg> is there a way to access private data declarations in modules?
05:28:17 <stelleg> for example
05:28:25 <tcard> shachaf: "#if WORD_SIZE_IN_BITS < 64" ?  It caused a parse error, so I don't know how to use it... Know of a reference?
05:28:42 <tcard> aavogt: hmmm, I have not tried that!  I will check!
05:28:43 <shachaf> tcard: {-# LANGUAGE CPP #-}
05:28:52 <shachaf> And then there's what aavogt said. :-)
05:28:57 <tcard> shachaf: thank you!  I will try it too!
05:29:19 <Eduard_Munteanu> Isn't Word already what you want?
05:29:49 <tcard> Eduard_Munteanu: It sounds like it. :)
05:30:24 <aavogt> one thing is Word might not be guaranteed to have 32 bits
05:31:01 <aavogt> the report at least discusses that Int has a minimum of 30 bits or so
05:32:40 <tcard> aavogt: thanks for checking; I will keep that in mind
05:35:14 <quicksilver> however if you have a Word32 type
05:35:17 <quicksilver> then Word will be 32 or 64 bit
05:35:23 <quicksilver> based on currently existing haskell platforms ;)
05:37:04 <tcard> aavogt, Eduard_Munteanu: Word indeed behaves exactly as what I want.  Thanks again!
05:40:28 <xkb> "Word indeed behaves exactly as what I want.  Thanks again!" <= now that's a classic quote!
05:40:41 <xkb> (thinking of the product, instead of the function)
05:40:45 <ben> heh
05:40:55 <xkb> eh type
05:41:37 * tcard shudders
05:41:38 <xkb> that's what you get, when your busines card says "architect"
05:42:17 * confound rolls to disbelieve
05:42:25 <erus`> whats
05:42:38 <erus`> Is there a fixed size array type ?
05:42:52 <erus`> Data.Array doesnt have length
05:42:57 <erus`> and i dont wanna wrap it
05:43:04 <joe6> any suggestions on how I can fix this error: LLVM.hs:8:14: Unsupported extension: TypeNaturals
05:43:46 <tcard> erus`: how about bounds?
05:43:54 <aavogt> joe6: find a newer / different compiler which supports that
05:44:18 <erus`> tcard: i guess i have to write a wrapper function
05:44:31 <joe6> aavogt: i am already on GHCi, version 7.0.4: http://www.haskell.org/ghc/  :? for help
05:44:34 <joe6> aavogt: is there something better than that?
05:44:48 <luite> use a ghc from the future
05:45:16 <tcard> erus`: the Array.bounds function gives "the bounds with which an array was constructed" (which is length)
05:45:34 <erus`> tcard: and a start value
05:45:39 <erus`> which will be zero :/
05:45:55 <aavogt> joe6: http://hackage.haskell.org/trac/ghc/ticket/4385
05:47:35 <joe6> aavogt: ok, thanks
05:48:41 <Eduard_Munteanu> OMG closed time loops!!!11 :P
05:49:55 <aavogt> erus`: with Data.Array, you're allowed to index from 1
05:50:08 <erus`> what is this? lua?
05:50:40 <erus`> i might contribute a fixed length, optimized array type
05:50:40 <aavogt> > listArray (1,3) "abc"
05:50:41 <lambdabot>   array (1,3) [(1,'a'),(2,'b'),(3,'c')]
05:53:12 <aavogt> Data.Array is more likely to be slow from copying the whole array when you could get away with destructively updating a piece of it
05:55:31 <Egbert9e9> maaan, quickcheck is extremely cool
05:57:17 <dcoutts> joe6: I don't see from that log that you're loading the llvm package in ghci
05:58:17 <erus`> how do i get a stacktrace before an exception?
05:58:41 <joe6> dcoutts, what do you mean? :m +LLVM.Core?
05:59:26 <dcoutts> joe6: that brings the module into scope, it does not load the object code (& dependent libs like llvm) for the package into memory
05:59:31 <joe6> dcotts, previously, it used to fail with some linker error.
05:59:44 <dcoutts> joe6: it's not loading it at all
05:59:50 <dcoutts> joe6: see "Loading package base ... linking ... done."
06:00:19 <dcoutts> that's it loading the object code for the base package, if you see that work for llvm you're ok
06:00:20 <joe6> dcoutts: like this, you mean:  http://sprunge.us/RDgR
06:00:22 <Defiance> erus`: This might be helpful http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
06:00:41 <roconnor> the transformers package claims it can be used with monads-fd; but the monads-fd package doesn't exist; presumably it is the mtl 2?
06:00:42 <joe6> dcoutts:  http://sprunge.us/HdXP
06:00:59 <dcoutts> joe6: ok, that's fine then
06:01:07 <joe6> dcoutts: the full startup:  http://sprunge.us/URRd
06:01:50 <joe6> dcoutts: in addition to compiling llvm-gcc from source, I also built llvm with --enable-shared. I am not sure if that helped.
06:02:21 <dcoutts> joe6: was it the same llvm version or a different one?
06:02:25 <dcoutts> as previously
06:02:37 <joe6> same
06:03:00 <joe6> llvm 2.9 and the latest git/darcs version of the haskell bindings
06:03:07 <joe6> and llvm-gcc 4.2
06:03:52 <dcoutts> strange
06:03:54 <joe6> the problem seems to be the libstdc++.so.6 . it messed up everything else on my system and until I renamed it, I could not use the system.
06:04:21 <joe6> i heard that it will go away and will be replaced with the lastest llvm.
06:04:26 <joe6> s/heard/read/
06:05:34 <joe6> after I removed the llvm-gcc from the apt and installed llvm-gcc from source
06:07:14 <joe6> dcoutts, Btw, I want to analyse the contents of an llvm bitcode file. I cannot seem to get far with the castModuleValue. Any suggestions?
06:07:24 <joe6> is the llvm-parser a good idea?
06:07:57 <joe6> the llvm-pretty module wants theh TypeNaturals extension, which is not part of the stable ghc build.
06:09:55 <dcoutts> joe6: sorry, I'm not actually that familiar with the LLVM api, I was just working on the ghci linker to try and fix loading llvm a few weeks ago
06:10:39 <joe6> oh, ok.
06:13:18 <Maxikq> hello, i've got some problem with designating types, could anyone help?
06:13:27 <hpaste> Maxikq pasted “Types” at http://hpaste.org/48076
06:16:09 <HugoDaniel> what powers the haskell wiki ?
06:16:12 <HugoDaniel> mediawiki ?
06:16:47 <osfameron> is there a standard name for a function to "mutate" the nth element of a list?
06:16:56 <osfameron> (I mean, with appropriate copying etc.)
06:17:11 <HugoDaniel> http://www.haskell.org/haskellwiki/HaskellWiki:About
06:17:59 <roconnor> osfameron: not that I'm aware of
06:18:26 <Maxikq> please help me with types, i've got exam tomorrow ; p
06:18:46 <osfameron> roconnor: gosh.  I know you probably don't want to be doing it (except with a Zipper probably) but it feels like a surprising omission, for completeness's sake ;-)
06:19:09 <Defiance> osfameron: I have wanted to do this a few times - I've usually used splitAt + some stitching.
06:19:10 <roconnor> osfameron: arrays are not good for random access
06:19:17 <roconnor> osfameron: I'd rather !! be removed ;)
06:19:24 <opqdonut> roconnor: you mean lists
06:19:26 <roconnor> *list are not got for
06:19:28 <roconnor> ya
06:19:29 <roconnor> sorry
06:19:57 <osfameron> heh, indeed.  *but* it's a good thing to show in my pure-fp-book stuff (to people who don't yet get data-sharing)
06:20:07 <osfameron> so I'm implementing it in Perl, but wasn't sure what *name* to give it ;-)
06:20:28 <Defiance> mutateNth?
06:20:40 <erus`> how do i map over a Data.Array?
06:21:16 <osfameron> Defiance: I was thinking mutateAt, as most of the other List.* functions that do something on nth position are *At
06:21:28 <osfameron> except "mutate" makes it sound like you're mutating ;-)
06:21:46 <osfameron> cloneModifyingAt is horrible though...
06:21:46 <ben> updateAt?
06:21:54 <osfameron> yay! ben++
06:21:56 <Defiance> osfameron: ahh yes, at is better
06:22:05 <Defiance> :)
06:22:08 <ben> I dunno, drop isn't named "cloneDroppingUntil" either :)
06:22:26 <osfameron> true
06:22:58 <osfameron> modifyAt could work too, as a simple name
06:23:09 <erus`> @hoogle map Data.Array
06:23:09 <lambdabot> Data.Array.MArray mapArray :: (MArray a e' m, MArray a e m, Ix i) => (e' -> e) -> a i e' -> m (a i e)
06:23:22 <roconnor> modifyAt should take a function, not a new value.
06:23:31 <osfameron> Maxikq: what have you tried to far?
06:23:38 <osfameron> :t flip flip
06:23:39 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
06:23:48 <roconnor> I'd use setAt or writeAt; though updateAt is also fine
06:23:57 <ben> :t flip
06:23:58 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
06:24:10 <ben> goddamnit, lambdabot prelude
06:24:20 <ben> @src flip
06:24:20 <lambdabot> flip f x y = f y x
06:24:22 <osfameron> ah, "modify" has a particular connotation in prelude naming?
06:24:34 <Maxikq> look at my hpaste
06:24:36 <roconnor> but modifyAt n l f = updateAt n l (f (l!!n))
06:24:40 <Maxikq> http://hpaste.org/48076
06:25:10 <osfameron> Maxikq: I already looked at the paste, now I'm asking you to expand on what you tried, and where you're stuck
06:25:41 <ben> I suspect he tried writing down an equation for flip flip and then deriving its type
06:25:43 * roconnor isn't sure which transformation in a dual adjuction is the unit and with is the counit.
06:26:10 <Maxikq> i've been trying to do that in way which i described in my hpaste, i've reach that flip flip = b c a , and i don't know what to do next
06:26:58 <Maxikq> in my theory i should start writing from b, and b :: (a->b->c) etc. and it starts wrong, because it should be b->(...
06:28:03 <hpc> :t flip flip
06:28:03 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
06:28:11 <hpc> :t flip
06:28:11 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
06:28:34 <ben> flip :: (a -> b -> c) -> b -> a -> c, hope this helps
06:28:50 <Maxikq> so here i stuck, this way of resolving types problem works for all my examples, only this one doesn't work
06:31:23 <Maxikq> i don't know how to reach something starting from b->(... from this signature, could any one write first steps relate to my hpaste?
06:32:05 <ben> Type of flip is something -> b -> c, so surely something applied to flip will result in a type starting with b?
06:33:54 <Maxikq> something2 applied to something->b->c wouldn't be (something2 -> b ->c) ?
06:35:39 <Defiance> :t flip undefined
06:35:40 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f b
06:36:06 <Defiance> Not the most useful..
06:36:31 <Defiance> flip undefined :: b -> a -> c
06:36:32 <ben> well, if you have f :: Int -> Char, and you apply and Int to it, you get a Char back
06:36:35 <ben> an*
06:38:28 <varnie> Hi. could you say how to force this function to accept [a] but not [IO a]? http://hpaste.org/48080
06:38:48 <ibid> IO a is an a
06:38:50 <varnie> I am newbie in  Haskell and don't get some its basics
06:39:17 <ibid> sort of, you're asking how to make a function to accept everything but not buckets of everything
06:39:29 <varnie> so, "myRndSelect::[a]->t->IO a" is correct?
06:39:54 <ibid> but now that i look at your hpaste, i must say i don't understand your question :-)
06:40:05 <dabblego> if you have a value of the type [IO a] (call it x) and you wish to run a function on [a], you can use this: sequence x >>= \thelistofa -> ...
06:40:27 <ibid> but yeah, [a] should be correct but you're missing a "return"
06:40:39 <hpaste> ben pasted “flip flip” at http://hpaste.org/48081
06:40:52 <ibid> varnie: you probably just need to add "return" to the last line
06:41:01 <ben> Maxikq: I'm not sure that is rigorous enough but that's how I convince myself that flip flip :: b -> (a -> b -> c) -> a -> c
06:41:07 <ibid> and then the list can be [a]
06:41:11 <varnie> thanks, that worked
06:41:30 <ibid> varnie: sorry about my first lines, i shouldn't joke before reading the hpaste :-P
06:41:37 <varnie> no problem:)
06:42:00 <Maxikq> ben: thanks
06:42:27 <ibid> (you don't use count for anything, though)
06:42:46 <ben> return $ surely
06:43:11 <varnie> and now I want to change to to return a list [IO a]...
06:43:47 <varnie> smth like "return  (xs !! index) : myRndSelect xs (count-1) " but surely that's wrong
06:44:09 <varnie> I don't understand "return"...
06:44:24 <ibid> what you need to understand about return is that it's misnamed
06:44:27 <Botje> return takes a value of type a and returns an IO a
06:44:35 <ibid> the name suggests the wrong things
06:44:45 <Botje> varnie: take a look at the definition of mapM
06:44:48 <Botje> @src mapM
06:44:48 <lambdabot> mapM f as = sequence (map f as)
06:44:52 <Botje> ah bugger
06:44:55 <Botje> @src sequence
06:44:55 <lambdabot> sequence []     = return []
06:44:56 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
06:44:56 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
06:45:11 <Botje> see how sequence uses itself in a do block? you should do that as well
06:52:28 <varnie> how to apply sequence to [a] but not [IO a]?
06:53:11 <ion> What is your input and what do you want as output?
06:53:38 <varnie> I am trying to write myRndSelect::[a]->Int->[a]
06:53:57 <varnie> so, it would take list of smth, a count and return count items of the list randomly
06:54:20 <varnie> myRndSelect "abcde" 2 would produce, say, "ea"
06:54:26 <ion> You’d also need a random seed for it to be pure. Or is it ok for the function to return the same value every time for the same set of parameters?
06:55:03 <varnie> no, it should produce different results each time
06:55:23 <parcs> Loading package wxcore-0.12.1.7 ... linking ... ghc: /home/patrick/.cabal/lib/wxcore-0.12.1.7/ghc-7.0.2/HSwxcore-0.12.1.7.o: unknown symbol `__dso_handle'
06:55:48 <parcs> that's the error i get when trying to load the wx package through ghci
06:56:32 <parcs> has anyone experienced this before?
06:57:50 <jeltsch> Where can I see on the web what’s in the Haskell Platform? What version of Cabal, for example? Also for older versions of the platform.
06:58:15 <dcoutts> jeltsch: the platform wiki has that info I think
06:58:20 <parcs> hmm, maybe i should upgrade to 7.0.4
06:58:38 <jeltsch> Is this linked to from the Haskell Platform homepage?
06:58:55 <erus`> is there a quick way to reverse an Array?
07:00:58 <jeltsch> I thought that there is a meta package called haskell-platform on HackageDB that specifies the dependencies, but there seems to be no such thing. :-(
07:01:18 <ion> varnie: Using the MonadRandom package, one could do: ghci> let randomItems :: RandomGen g => Int -> [a] -> Rand g [a]; randomItems n xs = replicateM n ((xs !!) <$> getRandomR (0, len-1)) where { len = length xs } in evalRandIO (randomItems 5 [0..42])
07:01:22 <ion> [28,10,31,40,12]
07:01:38 <Botje> erus`: create a new one that points to elements of the old one?
07:02:27 <jeltsch> dcoutts: Alas, I cannot find that information on the Haskell Platform wiki.
07:03:05 <jeltsch> Maybe, this should be added to the Haskell Platform website. Info about package versions, also for older releases.
07:03:21 <jeltsch> I need a Haskell Platform that contains Cabal < 0.10
07:05:54 <jeltsch> The link to the Haskell Platform 2011.2.0.0 on http://hackage.haskell.org/platform/linux.html is broken. :-(
07:10:27 <matthiasgorgens> I have a module where i want to export a type but no constructor for it.
07:10:30 <matthiasgorgens> what's the syntax?
07:10:36 <dino-> jeltsch: oof, it is broken
07:10:39 <Botje> Foo(...), iirc
07:10:45 <matthiasgorgens> It seems like i can control what constructors I export, but how do I handle the types?
07:10:50 <matthiasgorgens> are they always exported?
07:10:51 <sipa> Botje: that'd export all constructors
07:11:00 <Botje> then i remembered wrong :/
07:11:01 <wjt> module ( Foo ) where data Foo = Bar | Baz
07:11:09 <sipa> just Foo()
07:11:15 <sipa> if you want no constructors exported
07:11:32 <matthiasgorgens> ok.
07:11:33 <matthiasgorgens> thanks.
07:11:54 <matthiasgorgens> now that i know what to look for, i can actually find the information in http://www.cs.auckland.ac.nz/references/haskell/haskell-report-1.4-html/modules.html ;o)
07:12:43 <dino-> jeltsch: That whole directory isn't working either: http://hackage.haskell.org/platform/2011.2.0.0/
07:13:27 <dino-> But curiously the other (older) ones are.
07:13:28 <jeltsch> Does HP 2011.2.0.0 contain GHC 7?
07:13:42 <dino-> That I don't know
07:14:32 <matthiasgorgens> sipa, how do i re-export import from another module?  Is my guess to put (module subModule) into the export list right?
07:16:22 <jeltsch> dino-: Okay, http://www.haskell.org/pipermail/haskell-cafe/2011-March/090082.html says it does ship with GHC 7. So probably it also contains Cabal 0.10 then, which is too new for me.
07:16:47 <jeltsch> Doesn’t work with the second-newest version of Gtk2Hs.
07:17:01 <jeltsch> And the newest version of Gtk2Hs doesn’t contain soegtk.
07:17:03 <jeltsch> Weird!
07:27:19 <lebedev> Hello! I quite often have to deal with a problen on converting String to ByteString. Usually I turn on pragma OverloadedStrings and it helps me write f = "END" :: B.ByteString. But how can i solve this problem: (f = "END" ++ replicate 77 ' ') :: ByteString?
07:28:15 <lebedev> "END" ++ replicate 77 ' ' has type String
07:28:18 <Twey> lebedev: There's a ‘replicate’ in Data.ByteString; use that one instead
07:28:42 <Twey> Then you need to use something other than (++), like mappend or concat
07:28:55 <Twey> (concat from Data.ByteString, that is)
07:29:13 <Twey> lebedev: This is why we generally import Data.ByteString qualified
07:29:21 <tekknolagi> > replicate 3 [0, 1, 2]
07:29:22 <lambdabot>   [[0,1,2],[0,1,2],[0,1,2]]
07:29:29 <tekknolagi> > replicateM 3 [0, 1, 2]
07:29:30 <lambdabot>   [[0,0,0],[0,0,1],[0,0,2],[0,1,0],[0,1,1],[0,1,2],[0,2,0],[0,2,1],[0,2,2],[1...
07:29:36 <tekknolagi> > replicateM 2 [0, 1, 2]
07:29:37 <lambdabot>   [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]
07:29:45 <Twey> f = "END" `mappend` B.replicate 77 ' '
07:31:11 <tekknolagi> in what module is replicateM?
07:31:27 <Twey> tekknolagi: Control.Monad
07:31:33 <Twey> Most of the *M functions are in there
07:31:33 <ion> @hoogle replicateM
07:31:34 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
07:31:34 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
07:31:34 <tekknolagi> thanks
07:32:17 <zenzike> I'd like to convert a CUChar -> Char, and I'm wondering what the best way to do that is in versions of GHC<7 where castCUCharToChar was introduced. How would you normally perform such a conversion?
07:32:34 <ion> :t (++) --does lambdabot replcate ++ with mappend, btw?
07:32:35 <lambdabot> forall m. (Monoid m) => m -> m -> m
07:32:51 <ion> replcate? Hah. Nice brain typo.
07:33:20 <Twey> Looks like
07:33:47 <ion> (for “replace”, that is)
07:34:05 <tekknolagi> how would i map replicateM to the array [2..3] , replicating [0, 1]
07:34:06 <tekknolagi> ?
07:36:35 <ion> What’s your precise input and what do you want as output, precisely?
07:37:12 <tekknolagi> i'd like the input to be [0, 1] as the choices for the replicating, and the combinations in 2s, 3s
07:37:13 <tekknolagi> so
07:37:42 <tekknolagi> [[0,0],[0,1],[1,0],[1,1]], and [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
07:37:45 <Twey> lebedev: It's usually considered impolite to private-message people without their consent.  Unless there's something top-secret you want to keep from everyone else, please talk in the channel — that way everybody else can contribute and/or learn, too.
07:38:23 <tekknolagi> ion: is there a way to do that succinctly?
07:38:41 <ion> > (replicateM 2 [0,1], replicateM 3 [0,1])
07:38:42 <lambdabot>   ([[0,0],[0,1],[1,0],[1,1]],[[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1]...
07:39:16 <tekknolagi> ion: what if i want to have all the combinations in one array, and in any range of lengths i want...?
07:40:12 <tekknolagi> so mapping it
07:42:16 <ion> > concat . map (flip replicateM [0,1]) $ [2,3]
07:42:17 <lambdabot>   [[0,0],[0,1],[1,0],[1,1],[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1...
07:42:23 <varnie> why the following function implementation doesn't work correct?
07:42:24 <varnie> http://hpaste.org/48085
07:42:31 <ion> > concatMap (flip replicateM [0,1]) $ [2,3]
07:42:32 <lambdabot>   [[0,0],[0,1],[1,0],[1,1],[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1...
07:42:40 <magicman> > [2,3] >>= replicateM [0,1]
07:42:41 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
07:42:41 <lambdabot>         against inferred type ...
07:42:45 <magicman> Awww
07:42:49 <saml> > [2,3] ++ [0.1]
07:42:51 <lambdabot>   [2.0,3.0,0.1]
07:43:04 <magicman> > [2,3] >>= flip replicateM [0,1]
07:43:06 <lambdabot>   [[0,0],[0,1],[1,0],[1,1],[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1...
07:43:26 <saml> varnie, what's the error?
07:43:37 <varnie> " Exception: Prelude.(!!): index too large"
07:43:41 <varnie> I get it from time to time
07:44:03 <saml> you nkow randomR might generate too large index
07:44:04 <saml> r
07:44:16 <saml> r is genearted by randomR ... so,
07:44:20 <saml> :type randomR
07:44:38 <varnie> here it is:
07:44:38 <varnie> randomR :: (RandomGen g, Random a) => (a, a) -> g -> (a, g)
07:44:44 <magicman> (xs !! length xs) gives that error
07:45:00 <magicman> Because 0-indexed lists.
07:45:01 <lebedev> There is another problem. I can't write B.replicate 77 ' ', because ' ' has type Char, but B.replicate  requires type Word8
07:45:13 <varnie> how to work around that?
07:45:34 <magicman> By generating a random value between 0 and length - 1.
07:45:41 <magicman> Or between 1 and length, and then subtract 1.
07:45:52 <Ferdirand> lebedev: (fromIntegral.ord) ?
07:45:53 <ion> varnie: You’re manually putting both replicateM-like and State-like logic into the function. It might be clearer if you used e.g. MonadRandom as i suggested in my code example.
07:46:22 <varnie> ion, I appreciate your code, but I am far from monads stuff (to say the truth), I am still learning.
07:47:10 <Twey> lebedev: You can use fromIntegral (ord ' ') instead
07:47:17 * hackagebot xmlhtml 0.1.5.1 - XML parser and renderer with HTML 5 quirks mode  http://hackage.haskell.org/package/xmlhtml-0.1.5.1 (GregoryCollins)
07:47:19 <ion> Well, your code is already monadic, you’re just inlining the monad manually. :-P
07:47:41 <varnie> yes, but your code is difficult for me at this moment.
07:49:51 <varnie> good bye.
07:52:26 <erus`> walking a game tree for 4*4 chessboard with 4 pawns either side is taking ages
07:52:31 <erus`> 3*3 took no time at all
07:53:00 <erus`> used up all my ram too
07:54:03 <mjo> What's MonadRandom ?
07:55:20 <parcs> it's a type class for monads with RNG functionality
07:55:38 <erus`> well that killed my box
07:56:06 <mjo> parcs : :)
07:56:59 <ion> Essentially a RandomGen g => StateT g wrapper for randomR and friends.
07:58:06 <erus`> anybody got a really quick machine in here?
07:58:50 <Botje> mine does infinite loops in 2.5 seconds
07:59:30 <erus`> https://github.com/tm1rbrt/haskell/blob/master/pawns/pawns.hs run this but change line 96 to 4
07:59:31 <ion> Mine does (!!) in O(n/2) time.
08:05:48 <Botje> is it supposed to spit out a number eventually?
08:05:55 * d7 hrrms
08:05:59 <Botje> it's at 600 MB of ram and still growing
08:06:06 <d7> Hakyll is slowly blowing my mind. Maybe I just really don't get arrows the way i thought I did.
08:08:13 <d7> Or maybeI was just too tired last night. Oooohhhh.
08:08:28 <Botje> and it hit one GB
08:08:52 * Botje kills it
08:11:04 <Botje> erus`: maybe walking the _entire_ search space isn't such a good idea
08:11:50 <kakos> Completely unrelated to Haskell, but does anyone know of a good alternative to Dropbox that is free and, preferably, encrypted on the server side?
08:12:10 <Botje> dropbox is also encrypted
08:12:26 <Botje> the keys are just right next to the dropboxes :)
08:12:56 <d7> kakos: With as good a client?
08:13:09 <kakos> d7:  Ideally
08:13:33 <d7> kakos: There are many alternatives that are not as good in terms of the client; I'd say most of the value is delivered by a client with many developer hours invested in working out platform idiosyncrasies.
08:14:32 <kakos> d7: Shame.  As much as I like the client, it's kind of outweighed by the fact that their security model seems to be run by brain dead monkeys.
08:14:40 <thoughtpolice> if only there was a FUSE for windows. then sshfs could effectively work i guess :)
08:15:00 <d7> kakos: yes, well.. that seems to be a common problem
08:15:18 <erus`> Botje: anything less isnt perfect play
08:15:18 <d7> kakos: Wasn't MtGox using salted MD5 for passwords? And they're ostensibly a monetary exchange.
08:15:31 <parcs> kakos: tarsnap
08:15:36 <parcs> oh, free
08:15:39 <parcs> never mind
08:15:50 <d7> parcs: Does tarsnap do what dropbox does?
08:15:56 <d7> parcs: I was under the impression it did not.
08:16:09 <parcs> d7: not sure, my mind labels them in to the same category
08:16:13 <thoughtpolice> "Tarsnap is a secure online backup service for BSD, Linux, OS X, Solaris, Cygwin, and can probably be compiled on many other UNIX-like operating systems. "
08:16:20 <d7> parcs: Tarsnap makes backups. For that, on OSX, I use Arq
08:16:57 <d7> Dropbox actually does as-close-to-realtime-as-possible multi-actor synchronization.
08:17:04 <d7> And actually, it could be a lot better.
08:17:08 <kakos> d7: Didn't MtGox just get fucked recently?
08:17:12 <d7> kakos: Yes.
08:17:16 <d7> kakos: On a variety of levels.
08:17:23 * tibbe wishes that Haskell functions were more polymorphic instead of using lists.
08:17:38 * kakos doesn't even know what MtGox is, precisely.
08:17:56 <d7> tibbe: How does the expression go? Every non-list datastructure contains a half-broken, buggy, underspecified implementation of a list? ;0
08:18:14 <tibbe> heh
08:18:18 <d7> kakos: It was a public exchange for bitcoin currency.
08:18:26 <kakos> d7: Only bitcoin currency?
08:18:44 <Tomsik> tibbe: like which ones?
08:18:45 <JuanDaugherty> yes
08:18:47 <d7> kakos: it allowdd translation into more conventional currency, albeit at a limited rate.
08:19:01 <d7> kakos: But it only did trades on bitcoin
08:19:18 <JuanDaugherty> not translation, exchange
08:19:35 <d7> kakos: Which is to say, it took everything nobkakos: Which is to say, it took everything good and noble and interesting about bitcoin and destroyed it so that green-visored speculators could make high-frequency bitcoin trades.
08:19:38 <d7> Doh
08:19:47 <d7> Oh irccloud, your ctl-k is so broken.
08:19:48 <JuanDaugherty> mostly dollars and a few lesser real currencies
08:20:01 <bfig_> are bitcoins real at the moment?
08:20:05 <bfig_> ie, working currency?
08:20:11 <kakos> d7: There's something good about bitcoin?  I guess it is a good source of inevitable schadenfreude.
08:20:12 <d7> bfig_: I got tipped a bunch in bitcoin and turned it into real dollars.
08:20:12 <JuanDaugherty> they think so
08:20:22 <d7> kakos: Currency is itself sort of a problem.
08:20:45 <d7> bfig_: Someone gave me like $10 in bitcoins back in january. I cashed out for much more before gox died.
08:20:48 <JuanDaugherty> it's as real as SL or any other non-state money
08:21:05 <bfig_> d7, tipped? in a physical context (ie restaurant)?
08:21:07 <d7> JuanDaugherty: It's as real as state money, except that it's not illegal to ignore it in some laces. :)
08:21:17 <kmc> are we talking about bitcoin again
08:21:18 <kmc> sigh
08:21:21 <d7> bfig_: I helped some people with scala. I wasn't expecting compensation, but they gave me some bitcoins.
08:21:25 <kakos> d7: It has it's issues, which is why you need to have some authority making reactionary adjustments to keep it stable.  Bitcoins model of currency inflation is doomed to fail
08:21:39 <d7> kmc: We were talking about the deplorable state of modern service security.
08:21:44 <d7> kmc: Gox is topical.
08:21:54 <kmc> i have a Haskell question
08:21:55 <bfig_> kakos, all model of inflation are doomed to fail eventually
08:21:55 <tibbe> Tomsik, more or less any function that takes a list but isn't a list data structure function (like map, sequence,e tc
08:22:15 <JuanDaugherty> should say non - something, capitalist, establishment, since banks, corporations, hedged funds etc. create money but it's consider real at least till there's a panic
08:22:28 <JuanDaugherty> *considered
08:22:32 <d7> kmc: I agree tho, discussions of bitcoins viability are painful to endure YET AGAIN.
08:22:39 <kmc> it's off topic anyway
08:22:42 <kmc> but i do find it interesting
08:22:48 <d7> kmc: Especially when I hear people say things like, "I want bitcoin to have 2PC the way ACH does." ;)
08:22:53 <bfig_> d7, is there a device to move bitcoins physically? like cards or mobile wireless devices?
08:22:54 <monochrom> are we talking about haskell again? :)
08:22:59 <kmc> so i wrote a little code to go between ByteString and Data.Vector.Storable
08:23:03 <kakos> Sorry for the tangent, guys.
08:23:04 <d7> monochrom: Yes.
08:23:24 <kmc> does this already exist on Hackage
08:23:28 <kmc> and if not, should i upload it?
08:23:28 <d7> What value does the function instance of arrows bring to the table besides some shorthands for tuples?
08:23:33 <JuanDaugherty> kakos, you should be, funny how it matches your nick
08:23:55 <kmc> it's not very much code but it might be useful since it's full of unsafeBlah stuff some people don't want to touch
08:24:12 <d7> I've been playing with Hakyll and I'm trying to wrap my head around the use of arrows.
08:24:22 <d7> Esp since I've yet to really see WHY he went with arrows. :)
08:24:33 <kmc> d7, what value does the [] instance of Monad bring, besides some syntax for lists?
08:24:48 <kmc> if you manage to write some Arrow-generic code, it's nice if you can use it with functions
08:24:54 <d7> kmc: Ahh
08:25:03 <d7> kmc: I was wondering if there was some glorious thing I was unaware of.
08:25:15 <kmc> the difference between Monad and Arrow is that there are lots of useful Monad-generic functions
08:25:22 <d7> kmc:  Like, "Oh, you mean you don't know? Well then all your code becomes 20% shorter and we think it's easier to read."
08:25:28 <kmc> and very few Arrow-generic functions
08:25:36 <kmc> right, I don't think many people would say that about Arrow
08:25:40 <kmc> it's kind of a failed abstraction
08:26:02 <kmc> the class is at once too general and too specific
08:26:02 <Tomsik> tibbe: if you're talking about prelude functions, look at Control.Monad and Data.Traversable
08:26:04 <d7> It seems like its real utility is its original conception.
08:26:12 <hpaste> bwr pasted “Simplify Function” at http://hpaste.org/48086
08:26:13 <kakos> JuanDaugherty: What matches my nick?
08:26:24 <kmc> each type class is an API which can be implemented by different types
08:26:30 <d7> Which is to say, having cheap/static annotations on computations for early bailout.
08:26:43 <kmc> is that what Arrows do?
08:26:44 <tibbe> Tomsik, right, so we have abstracted some of the places, but lists appear as a concrete data type in too many places still
08:26:55 <d7> kmc: That is what the original paper used them for.
08:27:04 <bwr> I would really appreciate it if someone took a look at my tiny little example function and told me if there was a way to simplify it or at least point me in the right direction
08:27:07 <d7> kmc: It's surely not the only way to solve the problem.
08:27:09 <JuanDaugherty> kakos: cacophony.
08:27:20 <bwr> oh right. the function is at http://hpaste.org/48086
08:27:21 <kakos> Ah, yes
08:27:21 <d7> kmc: What I just can't figure out why Hakyll used arrows. :)
08:27:27 <kmc> any thoughts about ByteString <-> Vector.Storable?
08:28:07 <d7> kmc: Translation functions are a thankless business. But I think what you are doing is the lambdagod's work.
08:28:21 <kmc> hehe
08:28:23 <kmc> it's simple code
08:28:50 <djahandarie> Is lambdagod related to lambdabot?
08:28:57 <kmc> because they are both ForeignPtrs to raw byte arrays
08:29:13 <kmc> which means you can convert between them with no copy
08:29:47 <d7> bwr: Why are you writing then immediately re-reading? :)
08:30:25 <tibbe> what's Chris Done's nick?
08:30:29 <bwr> d7: it is an example
08:30:31 <zygoloid> tibbe: chrisdone
08:30:32 <Twey> tibbe: chrisdone
08:30:41 <tibbe> @seen chrisdone
08:30:41 <lambdabot> Unknown command, try @list
08:30:42 <preflex>  chrisdone was last seen on #haskell 1 day, 6 hours, 35 minutes and 1 second ago, saying: Has anyone done PDF editing in Haskell?
08:30:48 <d7> bwr: I mean, there are cheaper ways to take several "m a" and combine the internal a's more easily.
08:30:59 <d7> bwr: <$> and <*> come to mind
08:31:05 <k0ral> is there a haskell binding for gecko, the browser engine ?
08:31:14 <bwr> d7: ok I'll take a look at those. thanks
08:31:28 <d7> bwr: Also I think strefs are functors so..
08:31:48 <kmc> d7, what's the instance look like?
08:31:53 <Silvah> k0ral: why on Earth would you want that?
08:31:56 <Twey> tibbe: He only comes online every so often.  If you want him, it's best to email him.
08:32:00 <kmc> reference cells are covariant on read, and contravariant on write
08:32:01 <d7> kmc: It isn't?
08:32:09 <d7> kmc: My bad then.
08:32:12 <kmc> so they're not ordinary Haskell Functors
08:32:14 <kmc> d7, not that I see
08:32:19 <kmc> i kind of expect this bytestring <-> storable vector code is already buried in some package on Hackage
08:32:23 <d7> kmc: They're Applicatives tho, right?
08:32:25 <k0ral> Silvah: developing a browser, I must consider every alternative
08:32:32 <kmc> d7, no, that would imply that they're Functors
08:32:35 <d7> Huh
08:32:36 <Twey> Why are they not Functors?
08:32:39 <d7> Epic fail on my part.
08:32:46 <d7> Oh geez, fire alarm. :\
08:32:52 <kmc> Twey, because reference cells are covariant on read and contravariant on write
08:32:59 <Twey> Oh, right
08:33:05 <Silvah> k0ral: use WebKit.
08:33:18 <kmc> to turn (IORef a -> a -> IO ()) into (IORef b -> b -> IO ()) you need (b -> a) not (a -> b)
08:33:39 <kmc> i kind of expect this bytestring <-> storable vector code is already buried in some package on Hackage
08:33:40 <tibbe> Twey, will do. wanted to bounce some ideas about abstracting HTML/CSS with him.
08:33:41 <kmc> but i couldn't find it
08:33:43 <k0ral> Silvah: I'm already using it, but I wish there was kind of alternatives
08:33:47 <k0ral> Silvah: can't find any
08:33:49 <kmc> so maybe there's value in me uploading it, in a place where i would have found it ;)
08:35:33 <copumpkin> yrlnry: so what's the use case?
08:37:15 <yrlnry> copumpkin:  <yrlnry> I want a command that will try to commit the current index onto a different branch.  It would do this by committing the current index, switching branches, attempting to cherry-pick the new commit, switching back to the original branch, and then resetting the head to its original position.
08:37:31 <yrlnry> <wereHamster> what would be the use case for that?
08:37:32 <copumpkin> yrlnry: you don't want that.
08:37:39 <copumpkin> I'm telling you, you don't want it!
08:37:40 <yrlnry> Oh, good one!
08:37:43 <copumpkin> you may think you want it
08:37:44 <copumpkin> but you don't
08:37:48 <yrlnry> :-)
08:38:22 <yrlnry> "If you think you want that, you don't understand Git."
08:38:30 <copumpkin> if you think you want that, you're a terrible person
08:38:36 <yrlnry> Hitler wanted that too.
08:38:44 <copumpkin> and I will make sure to correct your question a few more times before giving you the information you seek in a dismissive way
08:38:48 <yrlnry> "Just a simple matter of shell scripting," he said, and look what happened.
08:41:54 <wyksztalcioch> i have a list of list of int, two value and i must find fild, which have common border and have this value - how can i make it smart? I don't want iterate on every column and row and check all field around
08:44:43 <wyksztalcioch1> lag :/
08:45:37 <kmc> i think i've needed yrlnry's git command before
08:45:46 <copumpkin> kmc: no you didn't
08:45:49 <kmc> haha
08:46:08 <copumpkin> no you haven't is a more correct response, though
08:46:16 * copumpkin kicks himself
08:46:25 <kmc> wyksztalcioch1, it's not really a Haskell question... if you can find a good algorithm for this problem then we can probably help you implement it in Haskell
08:46:39 <kmc> i'll think about the algorithm
08:46:39 <copumpkin> fild?
08:48:02 <kmc> wyksztalcioch1, a simple way that's probably good enough:  if you're looking for A and B, make a list of every coordinate where A appears, and a list for B.  then loop through the two lists and see if any pair of coordinates are adjacent
08:48:38 * edwardk waves hello.
08:48:41 <kmc> that's actually worse in terms of asymptotic complexity, but maybe better irl
08:50:47 <zygoloid> wyksztalcioch1: i'd write a simple linear pass to check the 1d case and map it over your 2d case and its transpose
08:53:58 <matthiasgorgens> Data.Time is useful for calendar time and leap seconds.  what do I use if I just want to measure the time between to events?
08:54:30 <quicksilver> matthiasgorgens: getCurrentTime ?
08:54:32 <quicksilver> (called twice)
08:54:52 <quicksilver> I call getCurrentTime twice and use diffUTCTime on the two times.
08:54:59 <matthiasgorgens> quicksilver, I guess that works in practices.
08:55:05 <matthiasgorgens> (in theory it uses leap seconds.)
08:57:15 <wyksztalcioch1> @zygoloid: i generete now all pair and check it - it one (no too long) line
08:57:15 <lambdabot> Unknown command, try @list
08:58:09 <kmc> http://hackage.haskell.org/packages/archive/rdtsc/1.2.0.0/doc/html/System-CPUTime-Rdtsc.html
08:58:21 <kmc> not actually a good idea unless you really need it
08:58:28 <kmc> but it's cool this library exists :)
08:59:19 <kmc> if only GHC had a RDTSC in-line primop
08:59:51 <copumpkin> not all backends can support it :(
09:00:39 <kmc> true
09:00:51 <kmc> are there existing architecture-dependent primops?
09:01:17 <dmwit> +#
09:02:25 <NemesisD> is there ever a good reason to re-export functions from an imported module?
09:02:30 <kmc> yes
09:02:39 <NemesisD> is it to avoid circular dependencies?
09:03:12 <kmc> if i'm writing a package 'foo' then I probably have a module named Foo which imports Foo.Types, Foo.Parser, Foo.Frobnicate etc., and re-exports the most useful stuff
09:03:13 <benmachine> for convenience?
09:03:26 <NemesisD> oh ok
09:23:14 <los> How do I concat a list of [Maybe String] into a single Maybe String?  It seems like there ought to be a way that doesn't involve a long list of >>=
09:23:33 <mauke> concat how?
09:23:42 <kmc> do you want to drop all the Nothings and concat the rest?
09:23:43 <mjo> catMaybes ?
09:23:54 <monochrom> @type catMaybes
09:23:55 <lambdabot> forall a. [Maybe a] -> [a]
09:23:57 <mauke> that would give you a String
09:24:04 <kmc> f [Just "x", Nothing, Just "y"]  -- is this (Just "xy") or Nothing?
09:24:05 <monochrom> concat . catMaybes
09:24:18 <kmc> > fmap concat . sequence $ [Just "x", Nothing, Just "y"]
09:24:20 <lambdabot>   Nothing
09:24:27 <kmc> > concat . catMaybes $ [Just "x", Nothing, Just "y"]
09:24:29 <lambdabot>   "xy"
09:24:29 <copumpkin> :t concat . concatMap maybeToList
09:24:30 <lambdabot> forall a. [Maybe [a]] -> [a]
09:24:31 <los> kmc, it should be Nothing
09:24:41 <copumpkin> oh
09:24:43 <dmwit> :t sequence
09:24:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:24:46 <kmc> then: fmap concat . sequence
09:24:49 <dmwit> :t mconcat
09:24:50 <lambdabot> forall a. (Monoid a) => [a] -> a
09:25:08 <mauke> :t msum
09:25:09 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
09:25:20 <dmwit> > msum [Just "x", Nothing, Just "y"]
09:25:21 <lambdabot>   Just "x"
09:25:31 <kmc> heh, yet another possible result
09:25:32 <dmwit> fmap concat . sequence seems best
09:25:51 <kmc> @djinn [Maybe String] -> Maybe String
09:25:51 <lambdabot> Error: Undefined type []
09:25:53 <kmc> :/
09:26:05 <monochrom> if you want one single Nothing to cause a global Nothing, you need >>=, and sequence is just a lot of >>='s
09:26:12 <los> I agree fmap concat . sequence seems like the best way to go
09:27:40 <jrope> what does it mean to have a typeclass class (SomeMonad m) => AnotherSomeMonad m t | m -> t where
09:27:58 <los> thx all
09:28:02 <kmc> means for any type 'm' there can be only one type 't'
09:28:07 <kmc> that's what the "| m -> t" part means
09:28:12 <kmc> it's called a "functional dependency"
09:28:49 <kmc> your names don't really make sense to me, though
09:28:50 <jrope> ok, is there somewhere I can read more about it?
09:28:56 <kmc> yes, the GHC manual
09:28:59 <copumpkin> nobody knows what it means!
09:29:01 <kmc> or you can google "haskell functional dependency"
09:29:05 <copumpkin> there was a large thread about them recently
09:29:10 <copumpkin> showing all the oddities in how they're implemented :P
09:29:16 <kmc> jrope, why do you have a class named "SomeMonad"?
09:29:18 <jrope> I just made them up, not real names
09:29:23 <kmc> why did you pick those names?
09:29:39 <monochrom> because they are burritos
09:29:39 <jrope> just to demonstrate the syntax
09:29:41 <kmc> nom
09:29:45 <kmc> ok, whatever
09:30:04 <copumpkin> jrope: I think what got kmc interested was that it might indicate a misunderstanding of monads
09:30:06 <copumpkin> that was my reaction
09:30:33 <jrope> maybe, I was looking at snap-auth
09:30:36 <monochrom> I silently ignore the meanings of suggestive names
09:31:22 <kmc> need a name for this library which isn't wretchedly boring
09:31:28 <monochrom> "class Not'a'type'class f => Not'another'type'class f" is just fine with me
09:31:54 <jrope> which has class (MonadAuth m) => MonadAuthUser m t | m -> t where
09:32:18 <copumpkin> ah
09:32:23 <kmc> fair enough
09:32:32 <kmc> here 'm' is a monad
09:32:34 <copumpkin> SomeMonadTransformer m => SomeOtherMonadTransformer m t | m -> t
09:32:41 <copumpkin> or a class of monads
09:32:58 <kmc> and MonadAuth is an extra interface it implements, above and  beyond the normal Monad interface
09:33:10 <copumpkin> I guess it isn't a transformer either
09:33:50 <mauke> class Genocide template => Where template birth | template -> birth where
09:34:03 <kmc> class Class klass
09:34:20 <copumpkin> is class a reserved word?
09:34:28 <kmc> yes
09:34:31 <mauke> :-[
09:34:37 <benmachine> > let class = "copumpkin" in 0
09:34:37 <lambdabot>   <no location info>: parse error on input `class'
09:34:44 <copumpkin> boo
09:34:52 <zygoloid> copumpkin: does it change colour in your text editor? ;-)
09:35:00 <copumpkin> I don't trust text editors
09:35:02 <kmc> class (Spam m) => Eggs m t
09:35:07 <copumpkin> I use a magnetized needle
09:35:20 <kmc> > let as = 3 in as
09:35:21 <lambdabot>   3
09:35:27 <benmachine> I use copumpkin
09:35:27 <kmc> but emacs and vim highlight it!
09:35:38 <zygoloid> i don't trust needles. i just resolve my wavefunction to a state where the universe is as i desire
09:35:42 <copumpkin> I hate shitty syntax highlighter parsers
09:36:03 <benmachine> copumpkin: I was going to say write a better one but I think you did
09:36:07 <kmc> zygoloid, too much haskell
09:36:12 <kmc> (or too much dope)
09:36:16 <kmc> (or not the right balance of the two)
09:36:20 <copumpkin> benmachine: it was shitty in a different way though
09:36:29 <benmachine> copumpkin: did you hate it
09:36:58 <copumpkin> benmachine: yeah
09:37:04 <copumpkin> benmachine: I'll fix it at hac phi
09:37:09 <copumpkin> well, fix the underlying agda machinery
09:37:17 <benmachine> heh ok
09:42:39 <d7> Ooohhhh
09:42:51 <d7> I think I am starting to get why Hakyll used arrows.
09:50:28 <parcs> d7: where does it use arrows? in the tutorial i only see the use of the >>> operator
09:51:46 <d7> parcs: Compilers are arrows.
09:51:53 <d7> parcs: Where I mean his compiler type
09:52:06 <d7> And I see now why he wanted to do it
09:52:35 <parcs> ah..
09:52:47 <d7> Assembled arrows can build up a list of files that they need to produce somehting. And if the produced file is newer than the things they use to produce the result, they are nops.
09:53:40 <gwern> parcs: you need things like &&& if you want to do custom parsing or feed in new variables to substitute into the html
09:54:11 <gwern> parcs: for example form my hakyll.hs: '                 >>> requireA "templates/sidebar.markdown" (setFieldA "sidebar" $ arr pageBody) ' <-- notice the arr as well as the >>>
09:55:15 <matthiasgorgens> lambdabot: help
09:55:42 <matthiasgorgens> How do I transform a NominalDiffTime (from Data.Time) into a float?
09:56:32 <matthiasgorgens> oops, forget it. :o)
09:57:39 <matthiasgorgens> hmm, or, not.
09:59:15 <matthiasgorgens> hmm, I'm actually interested in DiffTime.
09:59:15 <drdo> 1^(-1) Why does this throw an exception?
09:59:47 <matthiasgorgens> probably because negative numbers are not allowed as exponents for ^?
09:59:52 <benmachine> use ^^
09:59:58 <drdo> matthiasgorgens: No shit, the question is why
10:00:09 <benmachine> ^ is designed to work on things with no concept of division
10:00:11 <benmachine> like matrices
10:00:28 <matthiasgorgens> Though matrices have a concept of 1.
10:00:31 <benmachine> actually matrices do have a concept of division
10:00:33 <benmachine> but shh
10:00:43 <benmachine> hmm
10:00:48 <parcs> gwern, d7: i see. thanks
10:00:51 <matthiasgorgens> but if ^ has to work on stuff that doesn't know about division and doesn't know about 1,
10:00:52 <benmachine> gaussian integers, they'll do
10:00:56 <matthiasgorgens> then that'st the right thing to do.
10:01:04 <benmachine> matthiasgorgens: ^ knows about 1
10:01:07 <benmachine> > 7^0
10:01:08 <lambdabot>   1
10:01:16 <parcs> drdo: ^ is a relatively fast implementation of exponentiation
10:01:27 <benmachine> so is ^^
10:01:34 <benmachine> but ^^ works with negative indices
10:01:43 <benmachine> it's purely about the typesig
10:01:44 <gwern> parcs: in my specific example, I transclude the 'sidebar.markdown' into my 'default.html' with a $sidebar$ parameter. but how does hakyll know what HTML $sidebar$ should evaluate to? that's what the requireA and setFieldA are about
10:01:44 <matthiasgorgens> oh, the instance of (^) for Integers knows about 1.
10:02:00 <parcs> benmachine: oh, my mistkae
10:02:19 <matthiasgorgens> Does anybody know whether there's anything you can do to DiffTime from Data.Time to make it into a `normal' number that you can do arithmetic on.
10:02:19 <benmachine> matthiasgorgens: (^) is implemented in terms of the methods of Num, and an instance of Num has fromInteger
10:02:20 <matthiasgorgens> ?
10:02:22 <benmachine> so has a 1 of sorts
10:02:32 <benmachine> matthiasgorgens: isn't it already one?
10:02:53 <benmachine> you can already add, divide, multiply them
10:03:12 <matthiasgorgens> oh, but I'd like to do diffSize / diffTime = currentDownloadSpeed.
10:03:23 <matthiasgorgens> and diffSize and diffTime have different types.
10:03:41 <drdo> So what's the function without the Integral constraint?
10:04:12 <benmachine> drdo: huh?
10:04:24 <benmachine> oh right I see
10:04:25 <matthiasgorgens> drdo, look for **.
10:04:25 <benmachine> um
10:04:30 <benmachine> there are three exponentiation functions
10:04:55 <benmachine> one works with nonnegative integer indices, one of them works with any integer index, and one of them works with a floating index
10:05:00 <benmachine> :t (^)
10:05:01 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
10:05:02 <benmachine> :t (^^)
10:05:03 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
10:05:04 <benmachine> :t (**)
10:05:05 <lambdabot> forall a. (Floating a) => a -> a -> a
10:05:08 <parcs> looks like (^^) is implemented in terms of (^), actually:
10:05:11 <parcs> @src (^^)
10:05:11 <lambdabot> x ^^ n      =  if n >= 0 then x^n else recip (x^(negate n))
10:05:17 <benmachine> parcs: yep
10:07:48 <matthiasgorgens> ah, toRational does it.  though it seems a bit silly.
10:07:55 <matthiasgorgens> (since I want to go to float afterwards.)
10:11:58 <drdo> log(-1) = NaN , what's the name of the log function that works properly?
10:12:21 <dmwit> eh?
10:12:23 <parcs> heh
10:12:36 <monochrom> there are infinitely many
10:12:36 <parcs> drdo: what is log(-1) supposed to evaluate to?
10:12:55 <dmwit> > log (-1) :: Complex Double
10:12:56 <lambdabot>   0.0 :+ (-3.141592653589793)
10:13:12 <drdo> parcs: I was expecting i*pi
10:13:18 <dmwit> drdo: WFM ;-)
10:13:21 <monochrom> that is from the famous "e^(i pi) = -1"
10:13:53 <drdo> dmwit: What does that mean? :P
10:14:03 <dmwit> drdo: log (-1) works for me
10:14:13 <dmwit> (...and gives i*pi)
10:14:20 <drdo> oh
10:15:06 <monochrom> it means you should go complex
10:15:28 <monochrom> real world haskell is not enough. you have to go complex world haskell
10:17:07 <drdo> thanks guys
10:18:40 * hackagebot authenticate 0.9.1.6 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.9.1.6 (MichaelSnoyman)
10:34:47 * hackagebot attoparsec-iteratee 0.3.0 - An adapter to convert attoparsec Parsers into blazing-fast Iteratees  http://hackage.haskell.org/package/attoparsec-iteratee-0.3.0 (GregoryCollins)
10:43:37 <wyksztalcioch> why i can make ((1,1),(2,2)):[] but i can't map (\h -> map (h:) []) [((5,5),(6,6))] -> it gives me [[]], not [((5,5),(6,6))]
10:44:05 <kmc> map f [] = []
10:44:11 <kmc> > map (error "totally bogus function") []
10:44:12 <lambdabot>   []
10:44:55 <kmc> map (unsafePerformIO . fireTheMissiles) []
10:44:59 <wyksztalcioch> ok, thx
10:45:30 <kmc> do you understand why map f [] = []?
10:46:11 <monochrom> > map putStrLn []
10:46:12 <lambdabot>   []
10:46:58 <kmc> > map putStrLn ["abc", "def"]
10:46:59 <lambdabot>   [<IO ()>,<IO ()>]
10:52:18 <ezyang> Ugh. Why doesn't 'sum [1..100000]' do something reasonable in GHCI, again?
10:52:51 <monochrom> I get 5000050000 promptly. is that reasonable?
10:53:06 <ezyang> It uses lots of memory though.
10:53:21 <ezyang> you might need more zeroes.
10:53:24 <Saizan> sum is defined with foldl
10:53:48 <dolio> There's a rewrite rule to a strict accumulator version that can't fire in ghci.
10:53:51 <Saizan> there are rewrite rules for Int and Integer to fix that, but they don't fire in ghci
10:54:04 <saml> hey do you guys still use monad transformer?
10:54:14 <monochrom> sometimes
10:54:18 <ezyang> OK, so the problem is polymorphism.
10:54:51 <dolio> The problem is that foldl' isn't in the Haskell 98 report.
10:54:53 <Saizan> the problem is foldl' not being in the haskell report, hence not in sum
10:55:05 <kmc> saml, sometimes, why?
10:55:05 <ezyang> But that would change the semantics of sum, no?
10:55:22 <Saizan> the current semantics are not useful
10:55:31 <ezyang> Sure, you can argue that.
10:55:33 <saml> i don't see Writer, Reader monad
10:55:37 <ezyang> Agh, we really need to overhaul Prelude.
10:55:48 <dolio> What would it change?
10:56:27 <dolio> The only semantics it would change are when _|_ + n is not necessarily _|_, I think.
10:56:34 <monochrom> "Writer" is now an abbreviation of "WriterT ... Identity" in mtl-2. similarly for others
10:56:47 <ezyang> right, for strict + no change in semantics.
10:57:06 <ezyang> It would be interesting if GHC could take advantage of that sort of information, but of course that doesn't help GHCi.
10:58:12 <Tomsik> Maybe there should be strictness annotations in standard classes
10:58:21 <Tomsik> like (+) being strict
10:58:45 <monochrom> authors of Peano number types would hate that
10:59:01 <dolio> They might not really care.
10:59:25 <dolio> Well, I suppose you could arrange situations where they would.
10:59:30 <Tomsik> Honestly, who defines own Num instances? And ones that are non-strict?
10:59:41 <saml> is there practical guideline on how to construct haskell program?
10:59:43 <monochrom> authors of Peano number types
11:00:02 <saml> do i need to know Control.*  ?
11:00:07 <Saizan> authors of vector spaces, ..
11:00:16 <companion_cube> saml: Control.Monad is your friend
11:00:21 <monochrom> for example http://hackage.haskell.org/package/peano-inf
11:00:28 <ezyang> Tomsik: It's generality no one needs. But it is generality.
11:00:29 <kmc> saml, what aspect?
11:01:14 <kmc> saml, there are some useful modules under Control.*
11:01:26 <kmc> the distinction between Control.* and Data.* is not very strong
11:01:34 <kmc> that's what you get for using a lazy, functional language :)
11:02:07 <Tomsik> But wouldn't that offer some optimisation possibilities?
11:02:10 <Saizan> ezyang: my point is that if you have a lazy (+) you probably want foldr for sum, and since the Prelude is already geared toward the strict (+) case it should go all the way
11:03:02 <ezyang> I suspect foldl can be reasonable in the case of a non-strict combining function: it doesn't cause big stack space usage.
11:03:33 <Saizan> though Num alone doesn't have this bias
11:04:12 <ezyang> foldr is great for laziness on the spine. foldl can still get you laziness in elements.
11:04:31 <ezyang> It's generally hard to be spine-lazy without also causing big stack usage.
11:04:40 <ezyang> (in absence of fusion.)
11:05:31 <Saizan> if your combining function is lazy enough to exploit the laziness of foldl in the elements it wont' use stack with foldlr
11:05:38 <Saizan> s/foldlr/foldr/
11:06:00 <Saizan> (assuming we flip it, of course)
11:06:39 <ankitsingh> i am getting confused with the concept learned with respect to foldr and foldl. Flipping it reverses the chain
11:07:38 <monochrom> the relation between foldr, foldl, flip works for finite lists only
11:07:58 <monochrom> it is a great pedagogic tool for eager languages
11:08:14 <monochrom> it breaks down for haskell
11:08:33 <ezyang> Saizan: Ah yes, we are assuming commutativity, aren't we.
11:09:08 <ezyang> That's not necessarily a legitimate assumption, after all, we are allowed to returna  different result type.
11:09:13 <Saizan> ezyang: also, foldl will still use heap to allocate the nested applications
11:09:16 <ezyang> I've gotta run.
11:10:00 * hackagebot gps 0.6 - For manipulating GPS coordinates and trails.  http://hackage.haskell.org/package/gps-0.6 (ThomasDuBuisson)
11:10:23 <Saizan> in fact, if we weren't so paranoid about stack, this wouldn't even be a discussion :)
11:10:30 <Saizan> (as opposed to heap)
11:11:08 <Saizan> ezyang: flipping it is to keep the types matching
11:11:32 <Saizan> foldl takes a (b -> a -> b) while foldr a (a -> b -> b)
11:11:51 <monochrom> use "+RTS -K42" to waive stack limits
11:13:58 <ankitsingh> flip  takes (a -> b -> c) -> b -> a -> c  based on which one can not be sure if flip will work perfectly unless the set is finite
11:14:29 <ankitsingh> for making commutative property to work for foldr and foldl
11:16:03 <Saizan> foldl f z xs <= foldr (flip f) z xs, where here can be reduced to either they are equal or foldl f z xs is undefined and foldr (flip f) z xs isn't
11:16:18 <Saizan> s/where here/where <= here/
11:20:29 <ankitsingh> thanks for this info which shows that it is not commutative. I still need to look into it as coming as functional language programming still looks to be awkward to me but brings me back to my college days as it reminds me of ring theory  and set theory concept
11:21:35 <Saizan> heh, that's not true
11:21:39 <Saizan> > foldl f z [a,b,c,d]
11:21:40 <lambdabot>   f (f (f (f z a) b) c) d
11:21:45 <Saizan> > foldr (flip f) z [a,b,c,d]
11:21:46 <lambdabot>   f (f (f (f z d) c) b) a
11:21:53 <Saizan> sorry :)
11:22:23 <Saizan> it's true if f is commutative
11:22:52 <Saizan> maybe? i should just stfu
11:22:58 <ankitsingh> thanks again :)
11:23:56 <companion_cube> how do you get those symbolic results on fold ?
11:24:00 <companion_cube> @src f
11:24:01 <lambdabot> Source not found. Do you think like you type?
11:24:20 <monochrom> by the "simple-reflect" package
11:24:42 <companion_cube> seems awesome
11:26:50 <kmc> it's basically a hack
11:26:52 <kmc> but a cool / fun one
11:28:00 <csis> Do Haskell and Prolog have anything in common ? This is my first contact with Haskell, this channel, never even read about it but I have the will to go after it after exams.
11:28:17 <monochrom> they both use ascii
11:28:24 <ben> They're both scary to C programmers
11:28:30 <csis> That's good :)
11:28:42 <csis> ben, I don't think so.
11:28:43 <dino-> Do they have the "style" of pattern matching in common?
11:28:47 <monochrom> they both have funny rules on lowercase and uppercase
11:29:04 <ben> csis: Maybe I hang out with the wrong C programmers :)
11:29:09 <monochrom> they both assign a special meaning to _
11:29:27 <Nimatek> C programmers are fearless. They use their own blood and other bodily fluids to glue together some functionality.
11:29:31 <wyksztalcioch> i've got question about list comprehetion - i want write program, which check which numbers are prime, i want write sth like it [x| x <- [1..100] and forall y <- [1..x] mod x y \= 0]
11:29:50 <wyksztalcioch> and i don't know how implement forall y <- [1..x]
11:29:54 <kmc> :t all
11:29:55 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:29:59 <mauke> I wouldn't use list comprehensions
11:30:01 <Kaidelong> well that's horribly inefficient, but you could do something like this
11:30:43 <Saizan> foldl f z (reverse [a,b,c,d]) <= foldr (flip f) z [a,b,c,d] -- this is valid
11:31:05 <Kaidelong> [x | x <- [1..100], all ((0 /=) . mod x) [1..x]]
11:31:08 <kmc> csis, no, they're not very similar.  though, Haskell is a pretty good language for logic programming, as far as languages with no "built-in" support go
11:31:09 <dino-> monochrom: Is this where Erlang gets that upcase for variable names from?
11:31:16 <Kaidelong> > [x | x <- [1..100], all ((0 /=) . mod x) [1..x]]
11:31:18 <lambdabot>   []
11:31:20 <dino-> upcase first letter
11:31:29 <monochrom> I don't know erlang. perhaps.
11:31:29 <Kaidelong> oh of course
11:31:42 <Kaidelong> > [x | x <- [1..100], all ((0 /=) . mod x) [1..(x-1)]]
11:31:43 <lambdabot>   [1]
11:31:49 <kmc> csis, it's easy to write a backtracking tree search in Haskell, and then to parallelize it across many cores
11:32:03 <Saizan> dino-: probalby, erlang started as a prolog EDSL, no?
11:32:12 <wyksztalcioch> Kaidelong: and how better?
11:32:14 <dino-> Saizan: Yes, exactly what I was thinking.
11:32:27 <Kaidelong> wyksztalcioch: you only need to do trial division up to the square root
11:32:32 <Kaidelong> but apparently I did something wrong
11:32:41 <Kaidelong> > [x | x <- [1..100], all ((0 /=) . mod x) [2..(x-1)]]
11:32:43 <lambdabot>   [1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
11:32:48 <Kaidelong> there we go!
11:33:05 <companion_cube> neat
11:33:31 <c3l> I dont understande why your first attempt failed
11:33:31 <dino-> Now I've noticed that there seems to be the multiple-function-definitions camp of pattern matching (Haskell, Erlang) and the one function but you put a case as the first statement for matching (OCaml, Scala) and I wonder if that's a Prolog-ism too.
11:34:37 <c3l> oh, nvm
11:34:40 <monochrom> you forgot the very original ml. it does multiple equations
11:34:47 <olsner> dino-: my prolog code usually does the pattern matching as multiple "function" definitions
11:34:49 <Kaidelong> > 5 `mod` 1
11:34:49 <lambdabot>   0
11:35:01 <wyksztalcioch> Kaidelong: thx
11:35:24 <monochrom> I think every mathematician wants to write multiple equations
11:35:48 <sipa> > let primes = [ x | x <- 2:(map (\x -> 1+x*2) [1..]), all ((0 /=) . mod x) $ takeWhile (\y -> y*y<x) primes ] in primes
11:35:52 <lambdabot>   mueval-core: Time limit exceeded
11:38:46 <Nimatek> > let primes = sieve [2..] where sieve (x:xs) = x : sieve [n | n <- xs, n `mod` x /= 0] in take 100 primes
11:38:47 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
11:39:37 <dino-> olsner: ok, thanks
11:39:52 <Kaidelong> > [1,7..100]
11:39:53 <lambdabot>   [1,7,13,19,25,31,37,43,49,55,61,67,73,79,85,91,97]
11:40:00 <dino-> monochrom: Interesting, this was in ML and then sort of dropped in OCaml. I wonder why.
11:40:11 <shachaf> > nubBy(((>1).).gcd)[2..]
11:40:13 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
11:40:34 <kmc> what's a good name for a library which has one purpose: converting between ByteString and Data.Vector.Storable?
11:40:52 <monochrom> vectorize
11:41:33 <kmc> in attempting to solve this problem i discovered that "bytestring" is an anagram of "tryst binge"
11:42:13 <fowlmouth> lol
11:42:33 <d7> kmc: There is an image macro for that.
11:42:36 <d7> kmc: http://bit.ly/kpS7ue
11:42:50 <Twey> kmc: Interesting.
11:43:29 <Twey> d7: For ‘tryst binge’ or for discovering amusingly tangential anagrams?
11:43:37 <d7> Twey: The later
11:43:45 <Twey> What is the anagram here?
11:43:48 <d7> Twey: Chuckle, sip of port, sneer, etc. :)
11:45:36 <shachaf> > anagrams "bytestring"
11:45:37 <lambdabot>   ["Be Trysting","Begin Tryst","Binge Tryst","Being Tryst","Besting Try","Bet...
11:46:04 <d7> Begin Tryst
11:46:16 <d7> Mission Accepted.
11:46:20 <Twey> d7: Ah, right :þ
11:46:23 <Twey> Haha!
11:46:31 <Twey> /join #haskell-tryst
11:46:48 <monochrom> tristan and isolde
11:46:50 <shachaf> @vixen Begin Tryst
11:46:51 <lambdabot> I will NOT be ignored...
11:47:32 <csis> So, lambdabot is written in Haskell ?
11:47:37 <monochrom> yes
11:48:13 <csis> Where can I look at its internals ?
11:48:23 <kmc> http://hackage.haskell.org/package/lambdabot
11:50:39 <shachaf> @version
11:50:39 <lambdabot> lambdabot 4.2.2.1
11:50:39 <lambdabot> darcs get http://code.haskell.org/lambdabot
11:50:42 <d7> I am sorry to drop this in here, but really
11:50:46 <d7> http://stackoverflow.com/questions/3847108/what-is-the-haskell-response-to-node-js
11:51:10 <thorkilnaur> > (log (-1) :: Complex Double, log ((-1) :+ 0) :: Complex Double, (-1) :: Complex Double)
11:51:11 <lambdabot>   (0.0 :+ (-3.141592653589793),0.0 :+ 3.141592653589793,(-1.0) :+ (-0.0))
11:51:36 <thorkilnaur> drdo, ^
11:51:37 <saati> d7: i think haskell does not do blocking i/o so the question is kinda irrelevant
11:52:53 <d7> saati: The response is, "Have fun with your continuation passing style that we all decided was a pain in the ass 25 years ago."
11:53:03 <kmc> afaik, Haskell does not specify much about blocking vs non-blocking IO
11:53:09 <kmc> but GHC implements non-blocking IO
11:54:10 <d7> Haskell's concurrency primitives are pretty advanced.
11:54:19 <kmc> GHC's are
11:54:22 <kmc> none of that is in standard Haskell
11:54:23 <d7> Sorry
11:54:34 <d7> To compare them to node.js monotone insistence on a single paradigm is pretty unfair for Node.
11:54:42 <kmc> with GHC you can spawn hundreds of thousands of threads and have them all block on IO, and this is translated to something much more efficient at the OS layer
11:54:52 <kmc> namely, lightweight green threads + asynchronous IO calls
11:55:03 <kmc> the same thing you get with node, without turning your code inside out to get it
11:55:24 <d7> kmc: What does worry me is that that claim of "much more efficient" was evaluated before we started getting into the world of the newer linux pthreads implementations.
11:55:43 <d7> kmc: I've got apps running with literally thousands of real OS-provided threads. They run great.
11:56:13 <d7> It's sort of a myth that a modern server gets bogged down by medium-volume threads; at least with modern linux distributions.
11:56:16 <kmc> with GHC you can manage 100,000 threads on a modest machine
11:56:43 <kmc> thousands vs. hundreds of thousands
11:56:48 <kmc> i would call that "much more efficient"
11:57:07 <d7> kmc: Actually
11:57:14 <d7> kmc: 100k isn't at all hard to reach
11:57:32 <kmc> i'm interested in the other half of that equation
11:57:41 <kmc> if all those 100k threads do blocking calls to read(2)
11:57:52 <kmc> how does that stack up vs. a single use of epoll(2)
11:57:59 <d7> Yes, that's what worries me.
11:58:10 <d7> There is this idea that a lot of high-end scalability people I know are discussing
11:58:16 <d7> that the OS might be better able to schedule that sort of work
11:58:42 <d7> I haven't seen much data backing up anyone's assertions just yet
11:58:49 <kmc> *nod*
11:59:10 <kmc> it is kind of funny to duplicate scheduler, IO logic, etc. at both the OS and language runtime levels
11:59:12 <d7> but I think the idea that you MUST use epoll for performant servers is largely an outdated concept, even for extremely wide expected sets.
11:59:15 <d7> Yeah
11:59:26 <kmc> but the OS makes fewer assumptions
11:59:40 <kmc> GHC's scheduler and IO manager can use lots of details about how GHC implements Haskell
12:00:23 <gigabytes> hello. I want to know if all the elements of a list produce the same results when applied to a function. Of course I can do "all (\x -> x == func (head list)) (map func (tail list))". But if instead I do something like map (\x -> func x == func (head list)), is GHC smart enough to factor out the "func (head list)" call instead of repeat it on every invocation of the mapped function?
12:01:27 <d7> kmc: In any event, Haskell can do real task parallel execution. Node.js will only simulate that for the forseeable future
12:02:19 <d7> kmc: Unfortunately, the people who are really bullish on Node are not so bullish in understanding how concurrent software works, so explaining to them why having this discussion is the professional equivalent of "Why are you hitting yourself? *slap* Stop hitting yoursef" is difficult.
12:05:33 <kmc> gigabytes, let y = func (head list) in all (\x -> func x == y) (tail list)
12:05:56 <kmc> gigabytes, GHC may or may not optimize your version
12:06:10 <kmc> "head" and "tail" are also a poor substitute for pattern matching
12:06:16 <gigabytes> kmc: yes I know that's the way. I was specifically courious about ghc
12:06:26 <gigabytes> is there a way to inspect what ghc is actually doing?
12:06:28 <dmwit> case map func list of [] -> True; (x:xs) -> all (x ==) xs
12:06:39 <copumpkin> gigabytes: you can ask ghc-core
12:06:44 <copumpkin> or just ghc directly
12:06:56 <copumpkin> you can tell it somehow (look in the man page) to dump the simplifier steps
12:07:02 <kmc> ghc -ddump-simpl
12:07:09 <gigabytes> ok, thanks
12:07:20 <copumpkin> gigabytes: it doesn't look like regular haskell
12:07:26 <copumpkin> it does sort of superficially
12:07:30 <copumpkin> but many things are different
12:07:55 <gigabytes> copumpkin: it doesn't look like, or it isn't actually regular haskell?
12:08:05 <copumpkin> it actually isn't
12:08:07 <copumpkin> it's called GHC core
12:08:10 <gigabytes> ok
12:08:14 <copumpkin> it's sort of similar to haskell
12:08:20 <copumpkin> but is more explicit for some things
12:08:24 <copumpkin> like type application and abstraction
12:09:07 <kmc> it's an intermediate language GHC produces
12:09:28 <kmc> and many optimizations are done at that stage
12:09:32 <ray24> is there a famous haskell read-through that everyone must do?
12:09:34 <kmc> you can also look at the generated assembly code
12:09:56 <kmc> ray24, read-through?
12:10:11 <ray24> A walkthrough of haskell basics
12:10:14 <ray24> a read-through
12:10:24 <kmc> a book?
12:10:27 <kmc> a tutorial?
12:10:35 <ray24> The bible of haskell
12:10:38 <ray24> is there not?
12:10:41 <kmc> my answer is "no", different people learn from different resources
12:10:46 <kmc> LYAH and RWH are both popular
12:10:48 <kmc> @where LYAH
12:10:48 <lambdabot> http://www.learnyouahaskell.com/
12:10:49 <kmc> @where RWH
12:10:49 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:10:56 <kmc> other people have learned from other things
12:11:03 <ray24> thanks, that's all the information I need for now.
12:15:55 <Phantom_Hoover> WHAT HAVE YOU DONE TO LAMBDABOT YOU SICK BASTARDS
12:20:32 <ben> is the enumerator package winning the iteratee popularity contest?
12:20:41 <kowey> hello #haskell! We at Functional Brighton meetup just ran through Project Euler 1 in Haskell, Scheme, JavaScript, Python... now what? :-)
12:21:07 <kowey> (I think we're all kind of tired, and more Project Euler might elicit an "ugh")
12:21:48 <tekknolagi> how would I go about mapping a replicateM to an array?
12:21:51 <tekknolagi> what i want to do is
12:22:13 <tekknolagi> have replicateM applied to [0,1] for every element in [2..4]
12:22:35 <tekknolagi> so: (replicateM 2 [0,1], replicateM 3 [0,1], ...)
12:22:37 <Cale> kowey: You're looking for assignments? :)
12:22:39 <tekknolagi> how would i do that?
12:23:05 <Cale> tekknolagi: You mean list, not array (Haskell has arrays too, they're different)
12:23:06 <kowey> we're looking for something else to do before we run off to the pub, in say 30 minutes
12:23:22 <tekknolagi> Cale: yes, yes. how would I do that?
12:23:27 <Cale> tekknolagi: map (\n -> replicateM n [0,1]) [2..4]
12:23:40 <kowey> so I think a fun problem for beginning FP (or a polyglot crowd, eg. I speak Haskell, you speak Scala) to work on
12:23:49 <tekknolagi> > map (\n -> replicateM n [0,1]) [2..4]
12:24:27 <kowey> (hmm, maybe not polyglot so much as multi-monoglot)
12:24:55 <tekknolagi> Cale: could I join all those sub arrays into one array of sub arrays?
12:25:06 <tekknolagi> i.e. instead of [[[0,0],[0,1],[1,0],[1,1]],[[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]],[[0,0,0,0],[0,0,0,1],[0,0,1,0],[0,0,1,1],[0,1,0,0],[0,1,0,1],[0,1,1,0],[0,1,1,1],[1,0,0,0],[1,0,0,1],[1,0,1,0],[1,0,1,1],[1,1,0,0],[1,1,0,1],[1,1,1,0],[1,1,1,1]]]
12:25:07 <Cale> Yeah, I mean, I can give you combinatorial sorts of problems to try, but I'm not sure if that's too close to PE sorts of things :)
12:25:07 <tekknolagi> i'd have
12:25:34 <tekknolagi> [[0,0],[0,1],[1,0],[1,1],[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1],... so on
12:25:42 <Cale> kowey: A good problem is finding the number of ways to write a number n as a sum of (nondecreasing) positive integers.
12:25:55 <Cale> (or constructing the list of all ways to do that)
12:26:01 <Tyr42> tekknolagi:  concatMap?
12:26:15 <tekknolagi> Tyr42: is that in Control.Monad?
12:26:36 <Tyr42> http://haskell.org/hoogle/?hoogle=concatMap
12:26:42 <kowey> Cale: thanks! hmm, maybe we should try one of these unix tools, /me looks
12:26:45 <tekknolagi> also for some reason, my ghci doesn't understand ":find"
12:26:45 <Tyr42> takknolagi:  Data.List
12:26:55 <Cale> kowey: Those are good too :)
12:27:16 <Cale> kowey: Like a word count :)
12:27:56 <Tyr42> @hoogle concatMap
12:28:36 <kowey> Cale: looks like the consensus is pub!
12:28:43 <kowey> but maybe next time, thanks!
12:29:10 <Tyr42> how to I get lambdabot to hoogle?
12:29:25 <csis> lambdabot is not here
12:29:27 <Cale> is lambdabot down again?
12:29:29 <Cale> ah
12:29:31 <djahandarie> Tyr42, you were correct, it's just busted.
12:29:41 <Tyr42> ok, thanks
12:30:43 <c3l> why isnt sqrt defined to take any real number as an argument? now it only takes Floating.
12:31:08 <Cale> c3l: Floating is a typeclass which includes Complex Double, for instance.
12:31:19 <Cale> > sqrt ((-1) :+ 0)
12:31:27 <lambdabot>   0.0 :+ 1.0
12:31:28 <c3l> Cale: but not integers
12:31:34 <Cale> right
12:32:17 <Cale> The square root of an integer generally isn't an integer.
12:32:28 <c_wraith> :t sqrt
12:32:33 <lambdabot> forall a. (Floating a) => a -> a
12:32:39 <c3l> sure, but that doesnt mean that the square root of an integer isnt defined!
12:32:45 <c_wraith> note that the argument type and the return type are the same type
12:33:42 <Cale> Yeah, but it's a typing concern. Rather than defining some complicated multiparameter typeclass to specify which type the results are in for which domain, they went with the simple solution of demanding the same type.
12:33:49 <c3l> the domain and range of a function doesnt have to be equal? or is that common in haskell, just looking at it mathematically it doesnt make sense to me
12:34:10 <Cale> and that just means that you have to lift the argument to an appropriate type for the result beforehand
12:34:32 <Cale> c3l: It makes sense in the context that Haskell 98 only had single parameter typeclasses and no associated types.
12:35:00 <c3l> annoying, but ok. thank you :)
12:35:34 <Tyr42> I do find sqrt to be annoying to use
12:35:43 <Cale> And I think it makes sense from a simplicity of working with it point of view. You could theoretically be very careful, putting sqrt in its own typeclass and using associated types to express which codomain corresponds to which domain
12:35:48 <c3l> but, if they type system is so great as I read everywhere, why is something as simple as this problematic?
12:35:49 <Tyr42> I end up with fromIntegral everywhere
12:35:50 <Cale> like:
12:35:51 <ben> Someone add n*k patterns to the standard so that we can define sqrt (x*x) = x
12:36:02 <Cale> class Sqrt a where
12:36:13 <Cale>   type SqrtRange a
12:36:23 <Cale>   sqrt :: a -> SqrtRange a
12:36:31 <Cale> But this is its own annoying mess :)
12:36:46 <Cale> You'll end up with some really fun type signatures :)
12:37:06 <Cale> (particularly if this becomes the common design style for the entire prelude)
12:37:10 <c_wraith> generally, you don't want to actually *use* sqrt anyway
12:37:33 <c3l> well its not just sqrt, its (**), from which I assume sqrt is defined
12:37:33 <Tyr42> I would use a truncated sqrt that works on integers
12:37:50 <c_wraith> usually your problem can be solved more cleanly working in the whatever-squared domain
12:38:10 <Tyr42> How about for things like only checking for divisors up to the square root?
12:38:41 <c_wraith> check that the trial number squared is less than the n
12:39:43 <Cale> c3l: There are three types of exponentiation
12:39:55 <Cale> c3l: corresponding to three definitions from mathematics
12:40:00 <Cale> :t (^)
12:40:00 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
12:40:03 <Cale> :t (^^)
12:40:03 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
12:40:05 <Cale> :t (**)
12:40:06 <lambdabot> forall a. (Floating a) => a -> a -> a
12:40:54 <Cale> The first works with an arbitrary numeric base (anything we can multiply), and a positive integer exponent.
12:41:21 <Cale> The second allows negative integer exponents, but requires a base type capable of representing fractions.
12:41:35 <Cale> and the third is defined in terms of log and exp
12:42:03 <Cale> and so needs something like a floating point or computable real/complex type
12:43:51 <Cale> The common assumption here is that the type of result from an exponentiation operation is the same as the type of the base.
12:45:06 <Cale> Which, while it generally doesn't work out that way set theoretically (looking at restrictions of the exponentiation operation on the reals), is a pretty reasonable assumption in terms of how the results are computed.
12:46:11 <Tyr42> c_wraith: It's less work to do something like : [2..sqrt n], as you only sqrt once, instead of squaring a bunch of times
12:47:43 <c3l> ah. what I was thinking of was basically letting (**) be defined as (Num a, Floating b) => a -> b -> b.
12:48:25 <Cale> c3l: Suppose that a is a type of functions having a numeric codomain, or square matrices, for example.
12:48:32 <Cale> How does that work out? :)
12:49:55 <c3l> Cale: I don't understand
12:50:29 <dolio> What is the pi-th root of [[0,1],[1,0]]?
12:50:40 <Cale> (as a double? :)
12:51:57 <dolio> Yes, that part is even worse, I suppose.
12:52:19 <dolio> Because the inverse should be (**pi), but it doesn't yield the right type.
12:54:14 <Cale> It is possible to define real exponents of a square matrix, but they're square matrices (typically)
12:55:31 <c_wraith> clearly, exponentiation should be a three-parameter typeclass. :)
12:56:40 <c3l> oh.. well I guess the annoying, very specific types are hard to get around then. But I still think its ugly that (**) cannot take integers! but I feel I have to little knowledge to keep on argumenting =)
12:57:01 <Cale> c3l: But you can fromIntegral the integers and then it's no longer a problem :)
12:57:13 <c3l> Cale: I shouldnt have to :)
12:57:29 <Cale> c3l: It's also good in that it makes you aware that you're turning an Integer (which is an exact number) into, say, a Double (which is approximate), and you may lose precision.
12:57:36 <c3l> the function should do that for me
12:58:08 <Cale> There are lots and lots of potential bugs associated with automatic numeric conversions.
12:59:39 <c3l> but if the function domain includes integers, I would be aware of that fact. but yes, I buy the argument. I think I can relax and live with fromIntegral from now on. thanks
13:03:30 <DukeDave> Hey everyone, how do I get cabal to just get the source of a package? E.g. darcs clone?
13:03:54 <Saizan> cabal unpack
13:04:02 <Saizan> not really related to darcs
13:04:03 <DukeDave> Do I just have to gunzip the "(Cabal source package)" from Hackage?
13:04:53 <DukeDave> Saizan: Wonderful! Didn't spot it in the list, I assumed fetch did that
13:04:56 <DukeDave> Saizan++
13:07:03 <ray24> Duke is cool
13:11:06 <DukeDave> Wow, can you really use → instead of ->   ?
13:11:13 <DukeDave> Is that just a ghc thing?
13:19:48 <MrPico> no enendi nihue
13:20:08 <kmc> DukeDave, think so
13:20:34 <kmc> you can't use λ for \ because λ is a lower-case letter
13:20:43 <ben> Isn't there an operator lambda somewhere in unicode?
13:20:48 <MrPico> no me diga!
13:20:50 <Cale> We could however use something like the mathematical lambda
13:21:08 <ben> 𝜆 does that look right
13:21:14 <kmc> it looks kinda crap in my font
13:21:16 <kmc> but it is a lambda
13:21:39 <MrPico> lambda tu abuela ctm
13:21:51 <Eduard_Munteanu> I just see a tall rectangle
13:21:57 <kmc> MrPico, are you lost?
13:22:00 <Eduard_Munteanu> Maybe I should try to update my DejaVu fonts
13:22:01 <ben> My console font does not have a symbol for it either.
13:22:19 <dino-> Mine either
13:22:20 <Eduard_Munteanu> Hrm, yeah
13:22:31 <Cale> A problem is that it's (intentionally) italic, so the long stroke of the lambda is basically vertical
13:22:39 <MrPico> kmc, sacoe'huea
13:22:49 <Eduard_Munteanu> It shows up in Firefox, maybe the mono font doesn't have it
13:22:57 <Cale> MrPico: What language are you speaking?
13:23:14 <MrPico> from Mars
13:23:32 <Eduard_Munteanu> Is that 'map succ english' or something? :)
13:23:48 <Twey> Spanish…
13:23:57 <ion> 𐎍 U+1038D UGARITIC LETTER LAMDA
13:24:07 <Eduard_Munteanu> > map pred "sacoe'huea"
13:24:08 <lambdabot>   "r`bnd&gtd`"
13:24:09 <ion> 𐎍x → x+1
13:24:11 <Cale> Is that just Spanish?
13:24:23 <MrPico> todos son unos hueas (from Mars spea}king)
13:24:32 <ben> \ for lambda isn't exactly a typographic masterpiece either
13:24:42 <Twey> Just netslang, I think
13:24:48 <Eduard_Munteanu> Agda takes the unicode lambda fine, though.
13:25:00 <drdo> What's the trouble with just using regular unicode lambda?
13:25:02 <ion> I’d be happy with λ being made equivalent to \
13:25:20 <Eduard_Munteanu> <kmc> you can't use λ for \ because λ is a lower-case letter
13:25:37 <Cale> "no enendi nihue" and "sacoe'huea" seem weird :)
13:25:38 <ion> It’s not as if using a non-English language in code is generally a good idea.
13:25:48 <Twey> And you can't use : to start datatypes because : isn't an uppercase letter OH WAIT.
13:25:48 <drdo> Eduard_Munteanu: You can't use - either because it's the binary subtraction function, right? Wait...
13:25:49 <kmc> ion, nice cultural imperialism there
13:25:52 <ben> Well surely you could specialcase it in the grammar
13:25:58 <ion> kmc: Yeah, i’m Finnish.
13:26:12 <Eduard_Munteanu> I suppose UnicodeSyntax could do it though.
13:26:21 <ion> kmc: Let’s collaborate on a project, shall we? All my variable names and comments are in Finnish.
13:26:26 <ben> and piss off the handful of greek coders, or maybe physics people who go all-out on one-letter variables
13:26:44 <danharaj> What's wrong with one-letter names?
13:26:50 <Cale> Nothing
13:26:52 <kmc> ion, English is not the most popular language in the world
13:26:57 <kmc> i agree that it's the de facto standard for programming
13:26:58 <kmc> today
13:27:08 <Eduard_Munteanu> 'static inline void f()' looks odd, that's wrong :P
13:27:09 <kmc> in 50 years i expect to be reading comments in Mandarin
13:27:12 <kmc> (or probably failing to do so)
13:27:15 <ion> Haskell exists today for programming today.
13:27:25 <kmc> ion, so it should deliberately avoid features that will be useful in the future?
13:27:26 <ben> danharaj: I'd call it 'wavelength' or something, but someone might go with a lambda there because that's what they do on paper
13:27:32 <kmc> unicode variable names are useful now and will  become more useful
13:27:43 <danharaj> ben: fair enough
13:27:47 <Eduard_Munteanu> kmc: it probably is the most popular non-native language, isn't it?
13:28:07 <danharaj> English is increasingly the second language of choice in many parts of the world.
13:28:11 <danharaj> Including big places like India.
13:28:12 <Eduard_Munteanu> It's not like Chinese is going to take over :)
13:28:24 <k0ral> hey guys, I'd like to include a shell script in a cabal package, I thus use data-files section but the scripts happen to be installed as non executable
13:28:37 <k0ral> do you know how I could turn them executable ?
13:28:37 <kmc> i'm not sure how we got from "English is pretty popular" to "Haskell should have features to deliberately hurt people who do not want to use English"
13:28:38 <Cale> Mandarin doesn't seem like it would be that hard to learn. I'd have to get used to speaking/listening tonally. Learning Chinese characters is not much harder than learning to spell English words though.
13:28:46 <ion> How many of you expect using lambda as a letter to exceed the need for the lambda-the-\-construct as a Haskell use case in the future?
13:29:10 <Cale> I totally don't mind using \ for lambda
13:29:24 <Cale> and would rather type \ than λ
13:29:33 <Nimatek> logographic languages are fail by default.
13:29:39 <danharaj> I wouldn't mind if you could do latex-esque things like \lambda for special characters.
13:29:39 <drdo> Cale: Why would you rather type \ than λ ?
13:29:47 <danharaj> and have your editor prettify them.
13:29:49 <Cale> drdo: \ is one keypress for me
13:29:49 <ben> A haskell IDE could replace all the non-char/string-literal \ with lambdas
13:29:50 <kmc> hmm... does Vector.Storable assume its elements are aligned, wrt the machine's alignment rules?
13:30:01 <Eduard_Munteanu> Cale: I'm not sure about that. I definitely know the Greek letters, or at least most of them, still reading and pronouncing whole words is quite problematic.
13:30:01 <drdo> Cale: λ is one keypress with a modifier for me
13:30:02 <Cale> drdo: For λ I have to switch my keyboard back and forth
13:30:03 <kmc> this could be a problem for zero-copy ByteString -> Vector conversion
13:30:05 <drdo> Not that hard
13:30:10 <Cale> Still.
13:30:14 <drdo> I have λ as AltGr-l
13:30:25 <drdo> and Λ with shift
13:30:36 <kmc> i type it with Compose
13:30:37 <Cale> It's not hard for me either, but it's more annoying to type than \ and lambdas are pretty important
13:30:39 <Eduard_Munteanu> I assume it's easier to learn to read a language in Latin script.
13:30:45 <ben> kmc, how does that work?
13:30:58 <kmc> how doesn't it work?
13:31:05 <ben> No, I mean
13:31:07 <drdo> Cale: It's mostly about looking pretty, there's not much pratical advantage to having λ over \
13:31:09 <ben> What buttons does that involve pressing?
13:31:11 <kmc> oh, i have a custom XCompose file
13:31:19 <Cale> I consider it a *little* bit of a shame that lambdas need an initial delimiter, and we can't get by with just the arrow
13:31:25 <kmc> http://mainisusuallyafunction.blogspot.com/2010/10/typing-mathematical-characters-in-x.html
13:31:29 <Cale> But it makes sense when you think about multiparameter things.
13:31:34 <kmc> in C# it works that way
13:31:36 <kmc> x => x+1
13:31:42 <Cale> \ looks pretty enough :P
13:31:47 <ben> x, y => x+y?
13:31:53 <ben> or (x, y)?
13:32:03 <drdo> I don't like the idea of using => for that
13:32:21 <Cale> Could we reasonably get by with  x y -> x + y
13:32:48 <ben> You'd have to use parens if you wanted x (y -> x + y), I suppose
13:32:54 <ben> pretending that typed.
13:32:55 <Cale> (i.e. eliding the lambda, and making -> have maximal munch to the right and left)
13:32:59 <Cale> right
13:33:11 <Cale> There might be weird cases though
13:33:25 <ben> Honestly even if we can convince the parser to accept it, it will probably end up looking pretty confusing
13:33:27 <Twey> (a b -> c d -> e f)
13:33:32 <Twey> Munch left?
13:33:33 <Cale> especially where -> occurs elsewhere in the syntax
13:33:48 <ben> withWhatever $ x -> do something with x
13:33:54 <ben> would that parse?
13:34:08 <Cale> Good question
13:34:53 <Cale> Probably not, as $ isn't valid in a parameter
13:35:02 <Cale> er
13:35:09 <Cale> I mean, it probably wouldn't be a problem
13:35:19 <Cale> So yes, it would parse?
13:35:23 <ben> Great :)
13:35:54 <Cale> We certainly want it to parse :)
13:36:06 <ben> I'm never sure with making up syntax because I assume I can conceivably come up with intuitive rules to disambiguate it but inadvertently destroy some desirable properties of the grammar
13:36:07 <Cale> If we were going to do this to the syntax
13:36:15 <ben> which is what I suspect happened to C++ at some point or other.
13:36:24 <Cale> One thing which currently bothers me is that the $ is required there even though we have the initial \ delimiter
13:36:36 <Cale> Why can't we write   withWhatever \x -> ...
13:36:43 <c_wraith> yeah, \ and do are in the same syntactic oops there.
13:36:47 <ion> cale: I’d love that, too.
13:36:57 <ion> And withWhatever do …
13:37:10 <c_wraith> both of them cannot be used as arbitrary expressions, syntactically.
13:38:00 <Cale> Another thing that I really want is case sections
13:38:20 <Cale> (case of ...) should be equivalent to (\fresh -> case fresh of ...)
13:38:26 <Twey> Yes
13:38:30 <Twey> Case sections would be nice
13:38:45 <Cale> Particularly nice on the right side of >>=
13:39:15 <Cale> getThing >>= case of ...
13:39:15 <Twey> Maybe auto-lambdas like in Clojure :þ
13:39:38 <ion> That would alleviate the lack of multiple pattern matches and bodies per lambda.
13:39:52 <Cale> yeah
13:39:52 <Twey> # %2 * %1 ≈ \x y -> y * x
13:40:06 <Cale> Oh, those % things are awful :)
13:40:17 <Cale> Mathematica does similar nonsense :)
13:40:40 <Twey> It's nice when you want a quick lambda and don't really care about the names
13:40:45 <c_wraith> seem really ambiguous in a language with a more concrete syntax anyway
13:40:54 <Twey> Also good for case: # case %1 of …
13:41:18 <ben> Nemerle had a magical _ there
13:41:22 <Twey> I'd actually kind of like to lose the #
13:41:30 <Twey> ben: Yeah, same concept, but allows for multiple parameters
13:41:35 <ben> Yeah
13:42:11 <Cale> Mathematica has # (which is equivalent to #1) and #n for each integer n to refer to the nth parameter of an implicitly constructed function, which is end-delimited by &
13:42:19 <ben> I wonder whether I'm smart enough to figure out why I can't say "withWhatever \x -> ..." from the online report
13:42:29 <Cale> So you can write things like #1 + #2& [x,y] for x + y
13:43:03 <Twey> That feels a little bit weird
13:43:08 <Twey> It doesn't mark the beginning?
13:43:11 <Cale> Right
13:43:26 <Twey> I'd rather mark beginning and end
13:43:41 <Twey> It's just I only marked the beginning because that's how Haskell's \ works
13:43:41 <Cale> If you want to delimit the beginning, you can use parens
13:43:48 <ben> (or rather why it's necessarily so)
13:43:54 <kmc> i think we should talk about what's really important
13:43:56 <Twey> Parens *and* &?
13:43:58 <kmc> lexical syntax of multi-line comments
13:44:00 <Cale> yeah
13:44:04 <Cale> (#1 + #2 &)[x, y]
13:44:12 <Twey> I guess that's not horrible
13:44:20 <Twey> But I would rather mark the beginning than the end
13:44:24 <Twey> Lets you know what's coming up
13:44:36 <kmc> Haskell and OCaml both have nestable multi-line comments, but differ in a subtle way
13:44:53 <Twey> Meh, multi-line comments are a luxury ;)
13:45:07 <kmc> namely whether {- "-}" -} is well-formed
13:45:24 <kmc> and whether {- " -} is well-formed
13:45:33 <ben> Hm
13:45:43 <ben> Just disallow -} in string literals ;)
13:45:47 <Twey> Why wouldn't it be well-formed?
13:45:48 <kmc> good plan
13:45:51 <Twey> Oh
13:45:52 <Twey> That's why
13:45:56 <Twey> Silly me
13:46:11 <kmc> OCaml lexes the inside of a comment, in order to exclude end-comment delimiters inside string literals
13:46:18 <kmc> but that means it gets unhappy at an unterminated string literal inside a comment
13:46:46 <copumpkin> lol
13:48:46 <ben> Maybe we should have multiline comments based on indentation
13:49:28 <kmc> i prefer a language where any alphanumeric character is a comment
13:49:49 <ben> Like bf?
13:50:05 <kmc> yes
13:50:21 <ben> But then how are you gonna draw ascii art in your comments
13:50:27 <ben> without those all-important -s and >s
13:50:28 <kmc> i once had to find two brainfuck programs which have the same md5sum and produce two particular distinct outputs
13:50:39 <ben> heh
13:50:54 <kmc> ben, you just have to make the code around them immune to the side effects of your ASCII art
14:00:43 <Cale> kmc: I guess that's "easy" FSVO easy.
14:01:12 <trygvis> is the person working on darcs-fastconvert around here?
14:01:36 <trygvis> I'm wondering how useful it is
14:02:02 <Cale> (because of the nature of comments) :)
14:02:31 <ion> Hmm. The comment construct is useless in Haskell, too.
14:02:34 <ben> So why is foo \x -> x not possible? Why can't a lambda be that kind of expression? :(
14:03:12 <ion> > let this_adds_two_numbers_together = () in 42 + 1
14:03:13 <lambdabot>   43
14:03:54 <Ziphilt> i know it is disagreeable to haskell compilers to bind the same argument/parameter twice, as in foo x x = ... however, i would like part of the pattern matching to check that they are equal, and skip to the next pattern if they are not equal. is there an extension that allows me to do this without explicit case or if blocks?
14:04:13 <mauke> what's wrong with guards?
14:04:32 <Ziphilt> oh, forgot about them >_>
14:05:09 <acowley> foo x ((== x) -> True) = x * 2
14:05:19 <mauke> haha
14:05:34 <acowley> you need {-# LANGUAGE ViewPatterns #-} for that
14:05:38 <ion> Erlang does that, btw. eq(X, X) -> True; eq(_, _) -> False.
14:05:48 <Ziphilt> acowley: that is very interesting, thanks
14:05:48 <ben> Can the "-> True" be omitted somehow?
14:06:04 <mauke> foo x y | x == y
14:06:10 <ben> I mean so that foo x (== x)  would work
14:06:20 <ben> Does not seem syntactically ambiguous
14:06:22 <acowley> perhaps a TH-generated pattern could be tolerable
14:06:41 <parcs> ben: foo $ \x -> x
14:06:49 <Cale> I've seen "nonlinear patterns" given consideration. I'm not sure why we ended up without them. I guess it makes certain kinds of mistakes while editing code harder to catch.
14:06:52 <acowley> to replace repetitions with the ViewPattern
14:07:14 <acowley> Cale: I think that's just it
14:07:40 <mauke> ben: it's completely ambiguous
14:07:44 <acowley> The guard syntax is the right answer to the problem. If you're not also doing something interesting when the parameters are different, what are you doing?
14:08:24 <ben> mauke, can't there just be a rule that goes "if it's not a valid pattern, it's a view pattern with implicit -> True"?
14:08:45 <mauke> that's semantically ugly
14:09:11 <mauke> ben: would you allow 'f x x = x'?
14:09:34 <acowley> it would be neat if you could do something like that by bringing some TH into scope for an entire module
14:09:40 <ben> I wouldn't change that it's not allowed
14:09:46 <ion> Why not allow that?
14:10:01 <mauke> ben: it's not a valid pattern, so would the second x become a function call?
14:10:08 <ion> Assuming the second x in the pattern matches against the previous one
14:10:23 <ben> I was going for making the abuse of view patterns as guards slightly more compact
14:10:28 <stepkut> if I am using {-# LANGUAGE CPP #-}, is there someway to specify that I want the --noline option passed to cpphs ?
14:10:53 <ben> and I figured the x there would be a valid pattern in itself, just not while looking at the entire equation. welp.
14:10:58 <acowley> stepkut: perhaps with an OPTIONS_GHC stanza?
14:11:26 <stepkut> hmm
14:12:17 <fragamus> OK, I have some high level musings I want to run by you guys
14:12:31 <fragamus> Consider a monad transformer stack
14:13:32 <fragamus> Each transformer manages something, such as random number generator manages some state used to produce the next random number
14:14:27 <fragamus> nothing gets in or out of that layer unless the designer of the monad transformer says so
14:15:07 <fragamus> so we can thing of these layers as separate and independent
14:16:11 <fragamus> now lets say we have, somewhere in our stack a proper version of ListT
14:21:40 <fragamus> and let's say we have a do construct with the following x <- [1..100]
14:22:01 <Cale> (or some equivalent to that, obviously that's not going to typecheck on its own)
14:22:32 <fragamus> yeah, maybe you can give a better example
14:22:44 <dmwit> x <- lift [1..100]
14:22:47 <Cale> But get to the end of your sentence :)
14:22:55 <fragamus> I am like cro-magnon man trying to understand monads
14:23:14 <Cale> I would say try not to focus too hard on monad transformers at all
14:23:50 <fragamus> they are vital to my life
14:23:58 <acowley> sorry
14:24:02 <kmc> it's sort of a fool's errand to "understand monads"
14:24:06 <Cale> They're convenient sometimes, but I wouldn't start out on a library saying "I'm gonna make this thing a monad" as one of my core assumptions when designing it.
14:24:07 <kmc> just understand how each type works
14:24:38 <ion> Yes. You should start saying “I’m gonna make this thing a monad transformer”.
14:24:43 <Cale> Monad transformers are a good way to accelerate the construction of a wide variety of monadic libraries, but they're not like a solution in themselves.
14:24:56 <ben> I thought I "got" monad transformers once, but now hopelessly confused whenever I consider the order of the transformer stack.
14:25:10 <Cale> Design your library first (type signatures and such), then decide if it's a monad, and whether you can use monad transformers effectively.
14:25:13 <kmc> i would understand transformers by applying them out
14:25:13 <fragamus> I tend to think that it is rare to make a new monad, except by combining existing monad transformers
14:25:22 <Cale> (to construct that monad)
14:25:26 <kmc> @unmtl StateT s (ReaderT r []) a
14:25:32 <Cale> I don't think it's that rare
14:25:40 <kmc> fragamus, i used to think that.  now i almost exclusively write new monads and avoid transformers
14:25:42 <lambdabot> s -> r -> [(a, s)]
14:25:48 <ben> well, >>= of Iteratees also blew my mind :(
14:25:53 <kmc> the transformers don't really save you much code
14:25:55 <kmc> and can make things ugly
14:26:20 <kmc> whether or not i build it with existing transformers, i usually wrap my custom monad in a newtype and provide only a few "primitives" for use by the rest of code
14:26:32 <Cale> also, the optimiser sucks at optimising monad transformers away, so if performance is important, monad transformers can be bad.
14:26:39 <ion> @unmtl MaybeT (Reader r) a
14:26:39 <lambdabot> r -> Maybe a
14:26:41 <acowley> yeah, kmc's approach is, I think, much nicer
14:26:45 <ion> @unmtl ReaderT r Maybe a
14:26:45 <lambdabot> r -> Maybe a
14:26:57 <fragamus> I wrote, with great pain, a StateList monad only to discover that I didn't need to
14:27:03 <Cale> But you shouldn't even set out to construct a monad at all. Just notice when the library you're writing has a monad in it.
14:27:05 <fragamus> but it was a good exercise
14:27:29 <Cale> Design your library without prejudices like that, and I think you'll end up with better results.
14:27:31 <acowley> Haskell should only hurt a little
14:27:42 <hvr> kmc: btw, how do handle 'impedance adaptations' between different monads?
14:27:44 <fragamus> I needed StateList, so I wasn't out looking for trouble, I had trouble already
14:28:00 <hvr> kmc: like between ErrorT and Maybe
14:28:04 <kmc> hvr, poorly
14:28:05 <Cale> hvr: The same way you handle impedance adaptations between different libraries?
14:28:10 <kmc> :t either mzero return
14:28:11 <lambdabot> forall a b (m :: * -> *). (MonadPlus ((->) a), Monad m) => Either a b -> m b
14:28:23 <Cale> It's like "how do I use different libraries with each other"
14:28:26 <kmc> :t either return mzero
14:28:27 <lambdabot> forall a (m :: * -> *) b. (Monad m, MonadPlus ((->) b)) => Either a b -> m a
14:28:27 <Cale> You just do :)
14:28:33 <kmc> blah
14:28:35 <kmc> that's not what i meant
14:28:44 <Cale> and you take care of whatever conversions between types of data are required.
14:28:46 <hvr> Cale: well yeah.. I was just hoping for some trick to keep the do-syntax nicer
14:28:46 <kmc> :t maybe mzero return
14:28:48 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
14:29:20 <Cale> hvr: Generally you'll be working in one monad or the other, and rarely, you'll be constructing computations in one monad using computations in another.
14:29:31 <Cale> But yeah, it's not usually something which comes up all that often.
14:29:45 <lfppv> hi
14:30:08 <Cale> hi!
14:30:28 <lfppv> suppose that i have a function named insert that inserts an element X into a list XS on the right place, example, X = 2, XS = [1,3,4,5,6], insert 2 [1,3,4,5,6] = [1,2,3,4,5,6]
14:30:41 <Cale> lfppv: sure
14:30:47 <lfppv> now i need to create a function insertion sort
14:30:48 <Cale> > insert 2 [1,3,4,5,6]
14:30:48 <lambdabot>   [1,2,3,4,5,6]
14:30:54 <Cale> okay
14:30:58 <lfppv> how i do it using just insert ?
14:31:22 <Cale> lfppv: Well, there's the low-brow way, using direct recursion, and there's a high-brow way using higher order functions :)
14:31:22 <lfppv> isort :: Ord a => [a] -> [a]
14:31:33 <lfppv> Cale, direct recursion please
14:31:36 <Cale> okay
14:32:02 <Cale> So, to insertion sort the empty list, we don't have to do much at all
14:32:06 <Cale> so  isort [] = []
14:32:07 <lfppv> yes
14:32:13 <Cale> and if the list is nonempty
14:32:25 <Cale> isort (x:xs) = ... something in terms of isort xs ...
14:32:32 <Cale> What should we do?
14:32:36 <Cale> isort xs will be a sorted list
14:32:47 <Cale> we just need to put x into it in the right place
14:32:50 <identity_> Haskell wizards, I have a question about reading/writing files. I have a threaded application which is intended to run for a long time at once, gathering data to a file. This is the only application that will be writing to it. I was thinking about writing another application to expose the contents of this file(the stats, if you will) to the public, or just make it accessible on the web. Will I have problems with file locking if only one app is 
14:32:57 <Cale> which happily is exactly what insert does
14:33:29 <ion> identity: if only one app is$
14:33:30 <ben> identity_, you appear to have gotten cut off around "if only one app is"
14:33:42 <lfppv> isort (x:xs) = isort (insert x xs)
14:33:44 <identity_> oh.
14:33:46 <Cale> nope
14:33:53 <identity_> ..  is writing to it and the
14:33:54 <identity_>                    others are only reading?
14:33:55 <lfppv> right, it will never stop
14:34:05 <Cale> treat  isort xs  as a thing which you won't break up
14:34:07 <ion> identity: Turn on your client’s functionality that splits long lines.
14:34:15 <ben> ion, where does irssi do that?
14:34:17 <Cale> and which is already constructed
14:34:23 <Cale> don't think about how it's constructed
14:34:29 <Cale> It's just the sorted version of the rest of the list
14:34:30 <ion> ben: Irssi comes with splitlong.pl.
14:34:38 <sam2> I have a question about haskell
14:34:41 <sam2> I have an int
14:34:48 <Cale> what do we want to do to  isort xs  in order to build  isort (x:xs)?
14:34:48 <sam2> can I cast this to a double?
14:34:51 <parcs> identity_: is this on linux?
14:34:57 <Cale> sam2: fromIntegral
14:34:58 <identity_> parcs: Yes
14:35:08 <parcs> you'll be okay
14:35:09 <identity_> parcs: But the docs seem to talk as if it's platform independent
14:35:18 <Cale> sam2: fromIntegral will turn any integer-like number into any type of number at all
14:35:26 <sam2> I believe fromIntegral changes to more general type?
14:35:37 <sam2> hm... I see
14:35:54 <sam2> also...
14:36:00 <sam2> I wanted to debug my code...
14:36:02 <lfppv> Cale, we can take X and put in in the right place
14:36:09 <sam2> so if I want to print out a variable
14:36:16 <sam2> how should I do it in haskell?
14:36:17 <kmc> sam2, Debug.Trace
14:36:28 <kmc> sam2, but a better style of debugging is to try your functions in ghci
14:36:37 <kmc> if one function gives the wrong answer, test the functions it uses
14:36:58 <ion> QuickCheck can also help.
14:37:19 <ion> “Oh, only these inputs break it. That must mean…” etc.
14:37:21 <sam2> how can I use these checks?
14:37:33 <kmc> RWH has a chapter about QuickCheck
14:37:38 <Cale> lfppv: which is...
14:37:46 <sam2> oh ok.. let me take a look
14:37:46 <Cale> lfppv: insert x (isort xs)
14:37:53 <ion> IIRC RWH uses the older QuickCheck syntax, though.
14:38:06 <ion> Or something like that. Haven’t looked at it for ages.
14:38:27 <acowley> sam2: GHCi can debug, too
14:38:41 <lfppv> Cale, yea
14:39:21 <sam2> I'm just totally new to haskel... how can I use the debugger?
14:39:26 <stepkut> how do I put, > {-# LANGUAGE TemplateHaskell, TypeOperators, OverloadedStrings #-}, in a haddock comment. It doesn't show up..
14:39:42 <acowley> sam2: http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/ghci-debugger.html
14:41:42 <Cale> sam2: hmm, I can probably get you a tutorial, but honestly, as someone who has written Haskell code for about 10 years or so, I don't find much occasion to use it myself. The way that you should get bugs out of your Haskell programs is *usually* by breaking things down into smaller parts until you can isolate the problem, and testing things separately by typing expressions in ghci and using quickcheck to automate some
14:41:42 <Cale> testing of properties you want to hold.
14:41:51 <d7> What does TypeOperators do?
14:42:23 <parcs> allows the defining of operator-like types (:+:)
14:42:37 <acowley> Cale is absolutely right, but watching code step can be helpful (particularly when you're getting started!)
14:43:55 <kmc> i still use Debug.Trace a lot
14:44:04 <Cale> Yeah, the ghci debugger doesn't really give you a great intuition for it though... what would be ideal is something where you can watch reductions take place in expression form.
14:44:17 <kmc> let's say i'm giving a "what's Haskell and why should i care" talk
14:44:18 <Cale> There have been some debuggers in that style in the past
14:44:25 <ni_> hi I'm trying to write a haskell to C++ converter
14:44:28 <kmc> i know people have done things like this before
14:44:33 <Cale> ni_: A compiler?
14:44:42 <kmc> are there slides / talk notes you recommend i look at
14:44:47 <kmc> or particular topics i should cover
14:44:53 <dabblego> kmc: how much time do you have?
14:44:58 <shachaf> kmc: Maybe "A Taste of Haskell"?
14:44:59 <acowley> I use Debug.Trace a lot, too
14:45:22 <ni_> I need to convert haskell to C++
14:45:31 <ni_> huge code base
14:45:43 <ion> I think LLVM can output C.
14:45:44 <dabblego> I gave a "very very beginner introduction to haskell" recently (and have part 2 next week) over 90 minutes to 45 people -- I have the resulting source file, it is underwhelming, but the discussion was important
14:45:45 <lfppv> Cale, damn, that was obvious... like, we have for example [3,7,1,8,2], then isort does insert 3 (insert 7 (insert 1 (insert 8 (insert 2))))
14:45:46 <Botje> the best of luck to you
14:46:06 <ni_> because C++ is easy to understand
14:46:16 <dabblego> I also have a "course" that has been refined over years of teaching groups of 3-7 and hitting the usual barriers
14:46:16 <thoughtpolice> LLVM can output C, but the C output is a bit nerfed in some ways (I think it's deprecated, mostly unmaintained and doesn't handle certain constructs)
14:46:26 <kmc> dabblego, 1-2 hrs
14:46:27 <Cale> lfppv: there should be an empty list somewhere near the end of that, but yes
14:46:29 <lfppv> Cale, i actually have done other sorts like merge sort, and i was having trouble with this... it must be because its past midnight and i'm sleeping
14:46:37 <kmc> shachaf, good suggestion, thanks
14:47:11 <dabblego> kmc: https://bitbucket.org/dibblego/bfpg/src/a2e940cd0ab6/M20110524/Actual.hs
14:47:14 <Cale> ni_: The C++ which your Haskell compiler outputs *probably* won't be easy to understand.
14:47:17 <lfppv> Cale, yes, in the end we insert 2 in [], it gets [2], then insert 8 [2], it gets [2,8], and so on...
14:47:22 <dabblego> that was 90 minutes to 45 beginners
14:47:34 <ben> The only thing in C++ that stumped as much as the typical haskell library does was boost.asio
14:47:36 <dabblego> kmc: https://bitbucket.org/dibblego/haskell-course/ this is several months
14:47:38 <shachaf> kmc: Possibly other talks of SPJ's, too.
14:47:48 <kmc> haha, if you think C++ is easy to understand then you do not understand C++
14:47:51 <shachaf> He tends to be good at that sort of thing.
14:47:59 <ni_> it will be easier than reading martian which is what haskell is
14:48:02 <lfppv> kmc, i agree haha
14:48:06 <kmc> the gap between "C++ you know when you leave university" and "C++ used in the real world" is insane
14:48:10 <kmc> ni_, you're basically just trolling
14:48:21 <kmc> join #haskell, tell them how stupid haskell is
14:48:25 <ni_> yes lol sorry just teasing
14:48:25 <kmc> i bet that's a lot of entertainment for you
14:48:28 <Cale> ni_: and really, C++ is not that easy to understand. Haskell is a *much* easier language to understand from an objective standpoint. I don't think anyone really *knows* C++ in the sense of having a facility with all the odd corners of the language. There are a lot of complicated interactions which go on there.
14:48:29 <ni_> i love haskell
14:49:15 <ben> I love haskell too. It just does not feel like making it easy for me.
14:50:18 <acowley> Haskell makes two super-important things easy: polymorphism and composition
14:50:38 <Cale> ben: I think part of it is that Haskell libraries have a lot more potential to be like new small programming languages in and of themselves. But things generally get easier over time :)
14:50:50 <ben> Cale, yeah, that's definitely it
14:50:57 <Cale> The fact that you can often rely on type signatures to work out the sensible way to put things together is pretty key.
14:51:06 <ben> iteratees are a bigger deal than yet another object-oriented xml parsing library
14:51:17 <dabblego> speaking of, I gave a 45 minute talk on parametricity yesterday -- went well
14:51:40 <Cale> Oh, also, I dislike Iteratees, but I can't deny that they result in really practical efficiencies.
14:51:43 <acowley> did you actually go through proofs?
14:51:51 <dabblego> yes, small ones
14:52:14 <acowley> Good going! That can be pretty hairy as you get away from id.
14:52:24 <dabblego> we didn't go too far from id :)
14:52:29 <acowley> most people don't!
14:52:33 <ben> Cale, it just feels like compositing IO with other things should be easier than it is without lazy IO or iteratees, and iteratees seem like the lesser evil to me as a beginner
14:52:34 <kmc> dabblego, so what do you think did and didn't work well in your haskell overview talk?
14:53:08 <Cale> ben: Lazy IO isn't that evil for small programs at least.
14:53:12 <acowley> I think iteratees are a bit of a hard sell to an imperative programmer audience.
14:53:18 <Cale> (which is most of what you'll probably write as a beginner)
14:53:30 <Cale> Lazy IO can be kinda evil in production settings.
14:53:35 <thoughtpolice> i think iteratees are fine for certain use cases, but frankly there are plenty of domains where you don't need extensive IO support and the chunkwise processing that iteratees give you. in many cases they may be a bit too much even
14:53:54 <dabblego> kmc: when you are discussing a topic, and you need to monitor the audience's attention -- if your tact is failing, then have a backup plan -- there are so many different ways of explaining the basics, that this shouldn't be too hard -- try to get questions, mostly so you know if you are on the right track (who cares about the answer!?)
14:54:09 <Cale> acowley: But the imperative audience has really low standards. They'd be happy with the direct non-lazy IO noncompositional solution.
14:54:27 <dabblego> we use iteratees in production
14:54:41 <ben> Cale: But I do not want to learn to write beginner programs, I want to be able to write all the cool crazy stuff I see people post about :)
14:54:43 <Cale> So just point them as Data.ByteString and Data.Text (the non-lazy versions), and they'll be happy :)
14:54:47 <ben> lazy IO seems like getting into the wrong habit there
14:54:50 <thoughtpolice> OTOH, lazy io can work for a surprising number of programs, you just have to follow a rule. and that rule is to never close a handle backed by lazy I/O. :P that sounds like a cop out, and maybe it is, but i think you can get by in a lot of things with just that.
14:54:50 <ni_> That's right we are not lazy!!!
14:54:52 <dabblego> but in scala, not haskell
14:54:55 <acowley> Cale: Yeah, I just mean that lazy IO *is* somewhat compelling, while iteratees look like a lot of hoops compared to just stringing together imperative faff.
14:55:06 <ben> (Maybe instead there should be a nicer dumb frontend for iteratees for "feels like lazy IO" use cases?)
14:55:27 <Cale> acowley: oh, sure
14:55:32 <dabblego> kmc: I think "learning how to teach haskell" is at least as challenging as "learning haskell" -- it fascinates me equally
14:56:06 <kmc> i think iteratees are not well enough developed yet
14:56:12 <Cale> Iteratees are totally practical, but I feel like they're lacking a certain amount of mathematical elegance that I've come to expect of things in Haskell.
14:56:20 <thoughtpolice> also i believe it was dolio (?) who i mentioned it to, and i think he felt similar, but there is definitely a brain mismatch when going from lazy I/O to iteratees. it is very nice to treat I/O pipes like other lazy streams, because you can write programs over them in a simple, compositional manner that work effectively. OTOH, with iteratees, you're not really composing standalone transformations - you are composing chunk processors t
14:56:44 <Cale> There's something about all descriptions of them which feels a bit like data Bool = False | True | FileNotFound
14:56:45 <c_wraith> thoughtpolice: that got chopped after "chunk processors"
14:56:51 <thoughtpolice> the libraries tend abstract this out a bit with operators, but nonetheless I can't help but feel a bit more clunkly
14:57:00 <copumpkin> thoughtpolice: you got truncat
14:57:05 <thoughtpolice> c_wraith: the rest was "that work over chunks of data at a time"
14:57:11 <thoughtpolice> but it's fine without that last bit too :P
14:57:37 <acowley> A tricky aspect of teaching Haskell is balancing out the things aficionados find interesting with things your audience already cares about.
14:58:14 <dabblego> Cale: I predict someone will discover a useful iteratee model that will turn out to correspond to something mathematical
14:58:24 <acowley> People who are into Haskell talk about the identity function a lot. You don't see that so much in other conversations :/
14:58:35 <thoughtpolice> but if I/O correctness is necessary, and you want some good idea on the runtime characteristics of your programs (which may be easier to understand with fine-grained, individual chunk processors than lazy computations) i think iteratees are a good solution. just maybe too much for a lot of things
14:58:38 <edwardk> dabblego: its just the codensity monad of the free monad of an indexed store comonad. what is the problem?
14:58:43 <acowley> hahaha
14:58:47 <acowley> just in time!
14:58:53 <devinus> can anybody tell me what the best Haskell mode for vim is out there? i'd like to bookmark it so i can try it out later
14:59:00 <devinus> Haskell package*
14:59:02 <dabblego> edwardk: we have been waiting for you, that was the problem!
14:59:05 <edwardk> i'm actually using that as our IO type here at clarifi as well ;)
14:59:07 <devinus> vim package* i mean :/
14:59:16 <thoughtpolice> devinus: http://projects.haskell.org/haskellmode-vim/
14:59:19 <kmc> edwardk, :D
14:59:36 <thoughtpolice> that's the main one i'm aware of
15:00:37 <Martty> what the hell is security domain separation?
15:01:42 <edwardk> dabblego: to make the above more precise, if you start with data Susp i o r = Susp o (i -> r) -- which is obviously a functor (and its just the indexed store comonad)
15:01:49 <acowley> edwardk: I use newtype T m a = T { m (a, T m a) } a lot
15:02:18 <companion_cube> is it like... type level cons ?
15:02:19 <edwardk> acowley: that one can be built with Codensity (GEndo m)  ;)
15:02:34 <edwardk> where GEndo m a = GEndo (m a -> m a)
15:02:50 <acowley> edwardk: My problem with codensity is that I don't get it well enough
15:02:53 <edwardk> and yields a nice continuation passing style version of LogicT
15:03:07 <acowley> edwardk: so I use the type I showed, and its Functor and Applicative instances
15:03:13 <edwardk> *nods*
15:03:31 <edwardk> it is a fairly direct implementation the price is the fact that the >>= for that monad is horrendous
15:03:37 <edwardk> in terms of its computational cost
15:03:40 <edwardk> codensity fixes that
15:03:49 <acowley> I never use the monad instance becasue it didn't make sense to me!
15:03:55 <acowley> In fact, I don't define one
15:04:01 <edwardk> have you seen LogicT?
15:04:07 <acowley> yes
15:04:12 <edwardk> look at the type of msplit
15:04:24 <edwardk> its basically your operation with an extra Maybe sandwiched in
15:05:22 <edwardk> dabblego: to finish the thought, you can take the free monad of that cheesy little functor to make something that you can use to model an iteratee (just set o to ())
15:05:24 <acowley> I couldn't see the use of a Maybe in there
15:05:43 <edwardk> acowley: the Maybe version of it models a list monad transformer basically
15:05:54 <edwardk> that way you can have an empty list or you can "peel off one answer"
15:06:29 <acowley> Right. I have streams.
15:06:36 <acowley> that was the issue
15:06:51 <edwardk> flipped around into continuation passing style and turned with all of the oleggy types stripped off it, the type of LogicT is forall r. (a -> m r -> m r) -> m r -> m r
15:06:57 <edwardk> which is Codensity (GEndo m)
15:07:01 <acowley> The type I gave is the core type for sensor data in my robotics code
15:07:07 <edwardk> sure. then dropping the Maybe makes sense
15:07:28 <acowley> edwardk: do you have some ellucidating text on codensity somewhere? My ignorance really irks me
15:07:53 <edwardk> acowley: some, i introduce it somewhat accidentally in a writeup on kan extensions
15:07:59 <joe6> any suggestions on how to fix this:  http://sprunge.us/WTRL
15:08:19 <edwardk> http://comonad.com/reader/2008/kan-extensions/
15:08:58 <edwardk> but the layman interpretation is that Codensity f a is (forall r. ContT r f a) -- the quantifier just makes sure you can't use callCC.
15:09:11 <edwardk> and lets you use any old r you want.
15:09:34 <acowley> ah, found it: msplit is in MonadLogic
15:09:34 <acowley> edwardk: thanks
15:10:05 <acowley> it seems like movement to limit the utility of a monad instance
15:10:12 <edwardk> another way to think about it is that if you have a monad m, and you work instead with Codensity m, then what Codensity is responsible for doing is 'right-associating every use of >>= you use, and fusing together all the fmaps.
15:11:16 <edwardk> so if you fmap over the resulting monad, then fmap again, it'll enforce 'fmap fusion', and if you use (f >>= g) >>= h -- it'll reassociate any use of the underlying monad's bind into f >>= (\x -> ... >>= ...)
15:11:21 * hackagebot stdata 0.0.1 - Structure Data Library  http://hackage.haskell.org/package/stdata-0.0.1 (DavidDarais)
15:11:26 <acowley> joe6: can you put code on hpaste?
15:12:01 <acowley> edwardk: which is just what I needed when doing a search through an infinite tree
15:12:23 <edwardk> yep
15:12:35 <edwardk> it ensures we only build the tree once
15:12:36 <acowley> edwardk: dammit, I wish I had asked you for tips when perf. was disappointing
15:13:00 <acowley> I was quite proud of the code as it dealt with the infinite part quite well
15:13:06 <edwardk> the idea is that generally free monads can be slow because you wind up retraversing the 'bulk' of the tree and rebuilding exactly what you got before
15:13:29 <edwardk> if you use codensity to build it you only build the tree once, (and can walk it lazily and productively with an interpreter)
15:13:56 <edwardk> and 'tree' here can include functions, etc. pretty much anything
15:14:01 <ben> (now i feel very stupid for finding *iteratees* hard to understand)
15:14:09 <acowley> This is great. I can read your Kan extension article with a mind to codensitize (:D) my search code
15:14:28 <edwardk> ben: lets play with that suspension type for a sec.
15:14:41 <edwardk> newtype Susp i o r = Susp o (i -> r)
15:14:49 <edwardk> that is a functor, clearly
15:15:12 <edwardk> it can represent 'yielding' a value of type o, and needing a value of type i to complete a computation.
15:15:41 <edwardk> one way to encode asymmetric coroutines or iteratees is to use enough extra structure to make that a monad
15:16:05 <ben> Right
15:16:16 <acowley> edwardk: are you coming to hacphi?
15:16:18 <edwardk> newtype Iterator i o r = Pure a | Susp o (i -> Iterator i o r)
15:16:21 <edwardk> acowley: yep
15:16:26 <acowley> awesome!
15:16:29 <ben> Where's the a from?
15:16:33 <edwardk> but we can take Iterator apart into simpler pieces
15:16:33 <ben> Is that an o?
15:16:34 <edwardk> er
15:16:36 <edwardk> Pure r
15:16:42 <ben> oh ok
15:17:10 <edwardk> its not quite an iteratee (there is some machinery for dealing with the unparsed residue)
15:17:20 <edwardk> but close enough for expository purposes. =)
15:17:29 <edwardk> now, lets look at Free
15:17:39 <edwardk> data Free f a = Pure a | Free (f (Free f a))
15:17:44 <edwardk> and apply it to Susp i o
15:17:53 <edwardk> Free (Susp i o) a ~ Iterator i o a
15:18:09 <joe6> acowley: ok, thanks.
15:18:22 <edwardk> we just factored out the 'separate Pure constructor' and the fact that we recurse in on ourself instead of use a directly
15:18:45 <joe6> acowley: http://pastebin.com/s4jMHeUS
15:18:46 <mauke> The paste s4jMHeUS has been copied to http://hpaste.org/48100
15:18:48 <edwardk> it makes Susp i o, which was just a functor into a monad for free. by giving it a place to hold values and to recursively hold copies of itself
15:19:12 <joe6> acowley, error : http://pastebin.com/xAGBRyT8
15:19:14 <mauke> The paste xAGBRyT8 has been copied to http://hpaste.org/48101
15:19:26 * hackagebot stdata 0.0.2 - Structure Data Library  http://hackage.haskell.org/package/stdata-0.0.2 (DavidDarais)
15:19:45 <ben> Free looks suspiciously like fix, for types
15:19:49 <copumpkin> preflex: seen jmcarthur
15:19:50 <preflex>  jmcarthur was last seen on #haskell-blah 5 days, 20 hours, 30 minutes and 58 seconds ago, saying: i missed the awesome music theory conversation :\
15:19:51 <ben> or maybe like a list
15:19:54 <ben> I'm not sure what's going on there
15:20:03 <edwardk> with that you can have a monad for dealing with coroutines, define a nice little yield method: yield :: o -> Free (Susp i o) i
15:20:07 <edwardk> ben: its very very close
15:20:17 <edwardk> in fact, if you get rid of Pure it IS fix for types.
15:20:37 <edwardk> newtype Mu f = Mu (f (Mu f))
15:20:45 <edwardk> is type level fix
15:21:00 <ben> So it's free with the option to terminate?
15:21:02 <ben> err
15:21:02 <ben> fix
15:21:03 <edwardk> Mu f ~ f (f (f (f ... )))
15:21:13 <edwardk> Free f a = a + f (a + f (...))
15:21:23 <ben> oh
15:21:27 <edwardk> we can also define Cofree f a = a * f (a * f (...))
15:21:34 <ski> ben : if you define `(f <+> g) a = f a + g a', then `Free f a = a + (f . Free f) a' so `Free f = Identity <+> (f . Free f)' which looks a bit like `List a = () + (a * List a)', yes
15:21:43 <acowley> joe6: do you really want "const ShowPlaceholder"?
15:22:07 <ben> oh dear
15:22:20 <joe6> acowley: this is part of the Language-c source. I am just trying to use that file.
15:22:21 <edwardk> then the issue with using free is that free tends to be inefficient when you use it as a monad, because the left associated binds require retraversal of the tree.
15:22:30 <edwardk> so codensity fixes that
15:22:44 <edwardk> which is similar to the way that the real iteratee implementations use continuation passing style
15:22:55 <joe6> acowley: i am not sure what the ramifications are, if I remove that.
15:22:57 <edwardk> they cps transform to make the binds cheaper asymptotically
15:23:06 <ski> if `m' is a monad, `Codensity m' is an isomorphic monad
15:23:10 <sam2> hi
15:23:11 <acowley> joe6: I'm sorry, I misunderstood what it was doing
15:23:12 <sam2> in haskell
15:23:16 <edwardk> ski: not quite
15:23:25 <edwardk> there is an embedding into Codensity m
15:23:29 <edwardk> Codensity m can be bigger
15:23:32 <sam2> is there a mod function that always gives you positive remainders when modding negative values?
15:23:35 <ski> hm
15:23:55 <edwardk> Codensity of reader is actually isomorphic to state. ;)
15:23:58 <sam2> or do I have to define it ?
15:24:06 <ski> oh .. right
15:24:19 * ski must be confusing this with a somewhat similar situation
15:24:34 <edwardk> sam2: quot
15:24:35 <parcs> edwardk: is what you're discussing part of category theory?
15:24:51 <ski> parcs : it's category theory, applied to Haskell
15:25:15 <edwardk> sam2: quot/rem and div/mod form a matched pair
15:25:18 <joe6> any suggestions on how to fix this: http://pastebin.com/XB9TSWq6
15:25:19 <mauke> The paste XB9TSWq6 has been copied to http://hpaste.org/48103
15:25:25 <edwardk> sam2: so i meant rem most likely
15:25:27 <ski> edwardk : ah .. i meant to say that `Free m' is an isomorphic monad
15:25:37 <joe6> which gcc = /usr/lib/ccache/gcc
15:25:41 * ski is not sure why `Codensity' crept in there instead
15:25:41 <sam2> Oh I see let me try it
15:25:45 <edwardk> ski: Free m has more structure too =)
15:26:06 <joe6> and I do not know why the system complains about -- gcc: error: : No such file or directory
15:26:06 <edwardk> ski: there does exist a retraction for lifting your monadic action from m a to Free m a though
15:26:11 <ski> edwardk : yeah, i'm probably confused there too. but that's at least what i meant to express ;)
15:26:13 <sam2> hm... it still seem to give me negative values
15:26:23 <acowley> mod gives positive values
15:26:37 <edwardk> acowley: i wasn't sure which was which
15:26:42 <sam2> if I put -5 `mod` 10
15:26:45 <sam2> it gives me -5
15:26:58 <ski> > (-5) `mod` 10
15:26:59 <lambdabot>   5
15:27:04 <acowley> edwardk: luckily an exhaustive search is reasonable :)
15:27:11 <edwardk> acowley: ;)
15:27:13 <sam2> oh...
15:27:15 <sam2> I see...
15:27:18 <ski> sam2 : what you said is parsed as `- (5 `mod` 10)'
15:27:21 <acowley> sam2: syntax for negatives in Haskell is tricky
15:27:36 <sam2> wow... didn't know that... thanx
15:27:40 <c_wraith> heck, if there's anything I've learned in here, it's that exhaustive searches of infinite spaces can be fast. :)
15:28:17 <edwardk> parcs: there is a category theoretic foundation. right kan extensions are a notion from category theory. codensity monads come from them and are category theoretic. free monads are adjoint to a forgetful functor that takes some monad to just its functor component, so yeah, you could say its all category theory, just very applied.
15:28:41 <ski> (edwardk : .. looking at `Free f = Identity <+> (f . Free f)', it should be obvious that `Free m' can't be isomorphic to `m' for monads `m')
15:28:46 <acowley> joe6: CTranslUnit is not a Functor?
15:29:06 <edwardk> there is a nice obvious way to get back at least
15:29:20 <joe6> acowley, no idea. I am still trying to figure out this module.
15:29:21 <edwardk> flatten (Pure a) = pure a; flatten (Free as) = as >>= flatten
15:29:27 <edwardk> s/pure/return/
15:29:40 <acowley> joe6: it does have Pretty instance
15:29:43 <ski> edwardk : so, can we make an `ToMonad' such that `ToMonad f' is always a monad, and `ToMonad m' is isomorphic to `m' for any monad `m'
15:30:15 <edwardk> what can i assume about f? =)
15:30:24 <acowley> joe6: so you can show . pretty it
15:30:28 <ski> well, if you need to, that it's a functor
15:30:36 <edwardk> then sadly, no.
15:30:42 <edwardk> you just have the free construction
15:30:59 <edwardk> codensity is pretty good though
15:31:04 <ski> (it'd be nice if it didn't require it to be a functor, but you can fix that with `Yoneda' or `CoYoneda')
15:31:05 <joe6> acowley, let me try that.
15:31:09 <edwardk> you can always lift a monadic action from m into Codensity m
15:31:17 <edwardk> and given m is a monad you can run it and get an m back out
15:31:22 <edwardk> so its good enough
15:32:08 <ski> so, can you do an abstract-data-type trick to ensure you don't use any more power than that `m' is a monad in `Free m' ?
15:32:51 <edwardk> ski: well the quantifier on Codensity keeps you from using callCC, but technically nothing prevents you from using Codensity reader like state.
15:33:19 <edwardk> but then forall r. (a -> s -> r) -> s -> r _is_ cps'd state.
15:34:13 <ski> @unmtl ContT o (Reader s) a
15:34:14 <lambdabot> (a -> s -> o) -> s -> o
15:34:15 <edwardk> and what would prevent you from inspecting m?
15:34:56 <edwardk> you'd need to ensure that you only broke it down with a monad-algebra rather than a f-algebra
15:35:03 <edwardk> i can't enforce that in haskell
15:35:13 <edwardk> since its a test that your algebra obeys the monad laws
15:35:45 <ski> i'm not sure which algebra you're referring to, now
15:35:58 <edwardk> one way to model a free monad is to put it in elimination form.
15:36:18 <edwardk> this is weirich and washburn's encoding that i mentioned in the rotten bananas post on my blog.
15:36:24 <edwardk> its another way to build a free monad.
15:36:38 <edwardk> Free f a = (f a -> a) -> a
15:36:52 <edwardk> now pure = const
15:37:17 <ski> hm, interesting
15:38:04 <ski> ah, right .. this is foldy
15:38:05 <edwardk> you can also define a iteration form or limited-type catamorphism for a free monad either in the traditional form or the elimination form presented by weirich and washburn
15:38:07 <edwardk> yeah
15:38:22 <edwardk> given an f-algebra i'll give you its carrier
15:38:40 <ski>   cata :: Functor f => (f a -> a) -> (Mu f -> a)
15:38:48 <edwardk> to make that only be isomorphic to a monad m, you'd have to check that you can only give a monad-algebra
15:38:56 <ski>   flip cata :: Functor f => Mu f -> ((f a -> a) -> a)
15:39:26 <edwardk> yeah, so you can represent a closed with newtype Mu f = Mu (forall a. (f a -> a) -> a)
15:39:28 <edwardk> then cata is trivial
15:39:43 <edwardk> a closed term i mean
15:39:56 <edwardk> cata (Mu m) f = m f
15:40:04 <edwardk> or cata f (Mu m) = m f
15:40:24 <edwardk> its kind of inconvenient though =)
15:40:34 <edwardk> the free monad is much more conducive to pattern matching
15:40:59 <edwardk> but the construction can be more expensive, so i tend to use codensity of free
15:41:14 <edwardk> that said you could legitimately work with codensity of an elimination form i guess
15:41:49 <edwardk> (forall r. (a -> f r -> r) -> f r -> r)
15:42:10 <edwardk> er i got that wrong
15:42:26 <edwardk> (forall r. (a -> (f r -> r) -> r) -> (f r -> r) -> r)
15:42:28 <edwardk> there =)
15:42:29 <ski> *nod*
15:43:26 <ski> hm .. i think i'll have to play with this elimination form, to understand it better
15:44:07 <ski> e,g, `Free (Bool ->)'
15:45:03 * ski is particular doesn't see how `join' will work
15:45:49 <kuraj> can anyone recommend a good article on understanding typing?
15:45:50 <ski> (also, how can it be a functor, with `a' used invariantly ?)
15:46:01 <dmwit> kuraj: What part?
15:46:05 <dmwit> Type inference?
15:46:08 <dmwit> Type checking?
15:46:13 <dmwit> Dependent types?
15:46:19 <ski> Algebraic data types
15:46:21 <ski> ?
15:46:22 <kuraj> ive got exercises, like... determine the type of (.)(.)(.)
15:46:33 <kuraj> and such
15:46:36 <ski> ok, so type inference
15:46:41 <dmwit> The keyword to look for is "Hindly-Milner type inference".
15:46:48 <dmwit> Also: unification.
15:46:54 <dmwit> probably a good prerequisite
15:47:08 <cmccann> it's "Hindley" btw
15:47:09 <aavogt> there are programs to find those answers
15:47:12 <kuraj> ah good ol unification
15:47:21 * ski thinks about this as running a Prolog program
15:47:44 <ski> s/Hindly/Hindley/
15:48:21 <sully> if you are interested in how it can be implemented, I wrote an assignment on it last semester :P
15:48:26 <ski> kuraj : you start with the three atomic subexpressions
15:48:52 <ski>   (.) :: (b0 -> c0) -> (a0 -> b0) -> (a0 -> c0)
15:49:01 <ski>   (.) :: (b1 -> c1) -> (a1 -> b1) -> (a1 -> c1)
15:49:01 <kuraj> yep
15:49:09 <ski>   (.) :: (b2 -> c2) -> (a2 -> b2) -> (a2 -> c2)
15:49:28 <ski> these being monomorphic instances of the polymorphic type signature of `(.)'
15:49:49 <ski> think of all the `a0',`a1',`a2',`b0',&c. as logic variables, which can be unified
15:50:13 <ski> now, the first subexpression, `(.)(.)'
15:50:34 <ski> the type of the second expression there is unified with the argument type of the first
15:50:46 <ski> and the type of the whole is the result type of the first, so
15:50:52 <edwardk> ski: good question. when i was using it before i was using it in an invariant context.
15:51:07 <ski>   b0 -> c0  =  (b1 -> c1) -> (a1 -> b1) -> (a1 -> c1)
15:51:19 <ski>   (.)(.) :: (a0 -> b0) -> (a0 -> c0)
15:51:29 <ski> now, a similar application gives
15:51:42 <ski>   a0 -> b0  =  (b2 -> c2) -> (a2 -> b2) -> (a2 -> c2)
15:51:56 <ski>   (.)(.)(.) :: a0 -> c0
15:52:10 <ski> kuraj : so the type of the whole expression is `a0 -> c0'
15:52:29 <ski> kuraj : what's left is actually performing those two unifications, and maybe some simplification
15:52:51 <kuraj> ok hold on for a second.
15:54:03 <ski> edwardk : maybe you want to `CoYoneda' the whole thing ?
15:54:13 <edwardk> mebbe
15:54:32 * ski is fond of `CoYoneda' for constructing functors :)
15:54:38 <edwardk> i haven't actually used the elimination form for free as anything other than the ExpFunctor case
15:54:43 <edwardk> =P
15:54:53 * ski is wary of `ExpFunctor'
15:54:59 <edwardk> http://comonad.com/reader/2008/rotten-bananas/ this was the last time i used it
15:55:14 <edwardk> its just a functor from the category of embedding projection pairs over hask to hask
15:55:49 <ski> "embedding projection pairs" being "retract situations", or what ?
15:57:21 <edwardk> i need to be able to section cata f in the case where i don't have a functor, but instead have something where things occur in both positive and negative position
15:57:34 <edwardk> by sectioning cata f  with place i need cata f . place = id
15:58:08 <edwardk> i can do that with the elimination for by letting place ignore the algebra and just give back the answer.
15:58:14 <edwardk> er with the elimination form
15:58:26 <edwardk> and in the fegaras/sheard (free monad) encoding, by using Pure.
15:59:36 <edwardk> so there is a retract situation, but i need cata f to retract my place ;)
15:59:49 * ski . o O ( `place :: ?? => a -> Mu f' )
16:00:34 <edwardk> ski: this is for a restricted notion of catamorphism  cataFS :: ExpFunctor f => (f a -> a) -> Rec f a -> a
16:00:53 <edwardk> so 'a' is tied up in the type
16:01:06 <edwardk> once you quantify over the a you get something Mu'ish
16:01:17 <ski> existential ?
16:01:33 <edwardk> universal. existential would be for construction
16:01:46 <edwardk> weirich and washburn called the existential version 'Dia' IIRC
16:02:26 <edwardk> they use it in their approximation of Nu, but in the exponential case here, with stuff in both positive and negative position Mu and Nu don't coincide.
16:02:42 <edwardk> heya jmelesky
16:02:45 <edwardk> er jmcarthur
16:02:53 <jmcarthur> hyello
16:03:05 <jmelesky> i'll say "hello", too :)
16:03:20 <jmcarthur> hello jmelesky :D
16:03:27 <edwardk> hi jmelesky =)
16:03:46 * jmcarthur is in NYC now :o
16:04:16 <edwardk> woo
16:04:22 <edwardk> for good or visit?
16:04:25 <jmcarthur> for good
16:04:30 <edwardk> nice. where'd you land?
16:04:40 <fragamus> so if i have something like do x <- lift [0..99]; put x
16:04:44 <jmcarthur> st george area
16:04:53 <jmcarthur> easy to get to the ferry, which drops me off at work
16:05:03 <jmcarthur> or will next week at least
16:05:04 <edwardk> next time i get down there i'll have to look you up
16:05:30 <fragamus> and i have StateT as outermost, then the state will be 99 at the end
16:06:06 <jmcarthur> edwardk: going to hac phi?
16:06:07 <ski> `StateT s []' ?
16:06:08 <fragamus> but if i have State as innermost, then i have a list of states right?
16:06:12 <edwardk> ski: coyoneda won't help. to _use_ it you'd need to be able to define a functor. just puts off the problem ;)
16:06:16 <edwardk> jmcarthur: definitely
16:06:22 <jmcarthur> then i'll see you then for sure
16:06:26 <edwardk> so are dolio and copumpkin at last check
16:06:30 <jmcarthur> yep
16:06:35 <edwardk> so we'll descend upon it en masse.
16:06:38 <jmcarthur> haven't met them yet
16:06:43 <copumpkin> jmcarthur: you in NYC yet? I'll be there next week
16:06:51 <jmcarthur> copumpkin: yep
16:07:02 <copumpkin> maybe we can meet up with dons_ too
16:07:11 <copumpkin> he might be afraid of horses though
16:07:16 <ski> edwardk : elaborate on "define a functor" ?
16:07:19 <jmcarthur> *sigh*
16:07:54 <ski> @unmtl StateT s [] a
16:07:54 <lambdabot> s -> [(a, s)]
16:08:12 <ski> fragamus : in that case, you get a list, each containing a final state
16:08:47 <ski> fragamus : if you want to stack in other order, you have to say what monad transformer you want to use for lists
16:09:15 <fragamus> yes a proper implementation of ListT
16:09:53 <edwardk> as i see it to actually take advantage of CoYoneda for f you'd need to be capable of supplying an instance of Functor on f anyways in order to lower it back down to f a from CoYoneda f a
16:10:04 <ski> fragamus : just to clarify, with `StateT s []', you won't get "i have StateT as outermost, then the state will be 99 at the end"
16:10:19 <ski> edwardk : not necessarily
16:10:26 <edwardk> you may not have the instance lying around, but you'd have to have enough information that you could have
16:10:27 <ski> edwardk : consider `CoYoneda IORef'
16:10:33 <edwardk> hrmmm
16:10:42 <edwardk> nice example
16:10:44 <djahandarie> Oh, edwardk, copumpkin, jmcarthur, xplat, etc. if any of you aren't already planning on sharing hotel rooms / want to share hotel rooms for Hac Phi I'm up for it :)
16:10:52 <edwardk> i'm game
16:11:04 <edwardk> when are you getting down there?
16:11:10 <djahandarie> Not a clue
16:11:26 <edwardk> i was leaning towards heading down a little early
16:11:45 <edwardk> i've spent the last couple of years sitting around harassing dmwit and byorgey on the day before ;)
16:11:53 <shachaf> djahandarie: Am I going?
16:11:59 <djahandarie> I've been harassing byorgey for the past week
16:11:59 <ski> fragamus : so, maybe we should ask : what result do you *want* here ?
16:12:05 <edwardk> djahandarie: =)
16:12:14 <djahandarie> shachaf, yes!
16:12:16 <ski> fragamus : or are you just considering different cases, to understand them better ?
16:12:37 <edwardk> ski: that is a really nice example =)
16:12:53 <shachaf> djahandarie: Ooh, now you've done it.
16:12:57 <djahandarie> edwardk, I don't mind being there early.
16:13:03 <ski> edwardk : it's the example that made me invent `CoYoneda' (calling it something else)
16:13:14 <edwardk> djahandarie: sounds good. we'll figure out.
16:13:43 * shachaf doesn't yet know if his father will be in the US around HacPhi.
16:13:47 <edwardk> i'm just going to wander down on the train, not sure what your transportation plans are
16:13:58 <djahandarie> amtrak probably
16:14:00 <shachaf> If he is, it'd be silly to miss him.
16:14:02 <edwardk> yeah
16:14:13 <djahandarie> shachaf, he can come too!
16:14:31 <edwardk> send me an email reminding me and i'll finalize my travel plans
16:14:44 <edwardk> and we can work out the details from there
16:14:49 <shachaf> djahandarie: I'll be sure to tell him.
16:14:59 <sam2> I have a problem with a code...
16:15:01 <sam2> http://hpaste.org/48112
16:15:12 <sam2> It keeps telling me that len is not in scope...
16:15:18 <djahandarie> edwardk, okay, I probably will when I get back home in a few days. I don't feel like planning a trip when I'm in the middle of a trip :p
16:15:18 <HugoDaniel> hello
16:15:29 <Xaratas> hi, i have an exec function for one parameter, how can i "upgrade" it to a tuple of 3?
16:15:32 <sam2> it worked fine and then... it just suddenly doesn't work...
16:15:35 <shachaf> Boston ~ PHL, right?
16:15:42 <ski> fragamus : so, if you want a `ListT', i assume you want something like `newtype ListT f a = MkListT (f (ListCellT f a)); data ListCellT f a = Nil | Cons a (ListT f a)'
16:15:43 <edwardk> sam2: its not. in  p = head [x| x <- fmap ((+1) . (*len)) [1..], isPrime x]
16:15:46 <Xaratas> at the moment i use an extra function
16:15:50 <Xaratas> exec3 :: (Script Value, Script Value, Script Value) -> (String, String, String)
16:15:50 <Xaratas> exec3 (a, b, c) = (exec a, exec b, exec c)
16:15:53 <edwardk> let makes it available to the zipWith
16:15:57 <roconnor> anyone recall a blog post from this year that was about an assignement to make java interfaces to a game of tic-tac-toe where illegal moves were statically ruled out by the type system?
16:16:16 <dabblego> roconnor: yes mine
16:16:17 <edwardk> djahandarie: just shoot me the email to remind me, and we can follow up later. ;)
16:16:25 <roconnor> dabblego: link!
16:16:55 <dabblego> http://blog.tmorris.net/understanding-practical-api-design-static-typing-and-functional-programming/
16:17:04 <dabblego> http://hackage.haskell.org/package/TicTacToe
16:17:44 <hpaste> edwardk annotated “sam” with “sam (annotation)” at http://hpaste.org/48112#a48113
16:18:01 <edwardk> sam: you probably wanted something closer to that above. i didn't type check it though.
16:18:39 <edwardk> you're trying to access len in w and p where it isn't in scope.
16:18:53 <dabblego> roconnor: also https://bitbucket.org/dibblego/haskell-course/src/tip/TicTacToe/
16:19:31 <edwardk> foo = let bar = ... in ... only makes bar available inside of the ...'s, let is an expression. where is tied to the statement, and can't see inside the let expression.
16:20:56 <edwardk> i should run. later all
16:23:09 <Xaratas> anyone could tell me how to write this without an extra function name? if haskell had real overloading it would be given…
16:23:38 <dabblego> Xaratas: type-class
16:23:55 <spetrea> I shaved my head http://i.imgur.com/MIqkW.jpg
16:24:08 <dabblego> me too! but it's because my SO accidentally took a chunk out of it
16:25:17 <ddarius> spetrea: That's not shaved.
16:25:40 <dabblego> it's velcro
16:25:45 <spetrea> ddarius: ok lol
16:25:49 <roconnor> dabblego: thanks; I'm looking for some inspiration to capture some of my invariants by the type system.
16:26:07 <dabblego> roconnor: me too at the moment, but using scala :(
16:26:13 <roconnor> dabblego: but I see it is still possible to play in an illegal move.
16:26:15 <hpaste> dankna pasted “Slow is relative...” at http://hpaste.org/48114
16:26:21 <dabblego> roconnor: oh?
16:26:35 <roconnor> You just don't get a board resulting from it.
16:26:37 * hackagebot newtype-th 0.1 - Provides a template haskell deriver for use with Control.Newtype.  http://hackage.haskell.org/package/newtype-th-0.1 (MichaelSloan)
16:26:37 <dankna> see the profiling output snippet at the bottom of that paste
16:27:05 <dabblego> roconnor: ah yeah, that would be quite difficult -- a friend is attempting that with Coq -- no idea how he is going
16:27:07 <dankna> I was expecting that moving my indexing into the worker function instead of passing a closure would allow better optimization, as it did for the output handler
16:27:28 <dankna> but for the input handler that doesn't appear to be the case, and, as you can see, it's my largest cost-center so I want to deal with it
16:27:42 <roconnor> dabblego: my first attempted solution to your puzzle was to provide a type for every possible legal tic tac toe board position.
16:27:54 <aavogt> you can make differently filled boards have different types
16:27:54 <roconnor> dabblego: and then use fundeps to relate them by moves
16:28:11 <roconnor> basically moving the entire game into the type system. :D
16:28:21 <roconnor> but I never worked it out
16:28:23 <dabblego> roconnor: yeah, I'm keen to see how to do it with dependent types
16:28:36 <djahandarie> I figure it'd be much nicer with dependent types.
16:29:34 <djahandarie> mgsloan, nice!
16:29:39 <roconnor> dabblego: do you have a moment to hear out my problem?  If not no worries.
16:29:50 <dabblego> roconnor: I'm actually working at the moment sorry
16:29:53 <byorgey> mgsloan++
16:29:55 <roconnor> no problem
16:30:03 <djahandarie> mgsloan++
16:30:04 <roconnor> dabblego: thanks for the link!
16:30:10 <dabblego> roconnor: no worries mate, enjoy
16:43:10 <scooty-puff> i'm having some trouble with universal quantification (terminology?)
16:43:24 <scooty-puff> i defined a type to use a type variable s similar to ST s a
16:43:59 <scooty-puff> i.e. runCodeT :: forall m i a. (forall s. CodeT s m () i a) -> m a
16:44:33 <scooty-puff> that signature compiles just fine, but i can't seem to compose functions involving (forall s. CodeT s m i j a) at all
16:44:34 <hpaste> Xaratas pasted “Simulate Overloading” at http://hpaste.org/48115
16:44:49 <scooty-puff> nor can i reference the major class that CodeT implements instead of CodeT
16:45:26 <Xaratas> dabblego: i could not get it to work with this class, how to get a possible tuple at the return value?
16:48:08 <ski> scooty-puff : `runCodeT' is an operation with a  rank-2 type
16:48:13 <ski> scooty-puff : what concrete code do you have problems with ?
16:48:26 <scooty-puff> just a sec, uploading to github, will post link at the particular line
16:50:30 <hpaste> aavogt annotated “Simulate Overloading” with “Simulate Overloading (annotation)” at http://hpaste.org/48115#a48116
16:50:33 <scooty-puff> https://github.com/sonyandy/jfuck/blob/master/Language/Brainfuck/Compiler.hs#L33
16:50:40 <scooty-puff> ski, that is where the error is
16:51:01 <scooty-puff> https://github.com/sonyandy/jfuck/blob/master/Control/Monad/Code.hs defines the monad instance
16:51:11 <edwardk> ski: looks like in the non-exponential case the elimination form for Free is uglier.
16:51:23 <edwardk> (forall r. (a -> r) -> (f r -> r) -> r)
16:51:24 <scooty-puff> https://github.com/sonyandy/jfuck/blob/master/Language/Brainfuck/Emitter.hs is the use of the class
16:52:12 <ski> edwardk : ok, so `a -> r' looks like the base case
16:52:21 <aavogt> Xaratas: it's probably a better choice to write/find another class to apply a function to all components of a tuple
16:54:12 <scooty-puff> ski: let me know if theres any information that could help - i'm not having much luck with it
16:54:13 <ski>   data Free f a = Pure a | JoinIncl (f (Free f a))
16:54:40 <c_wraith> @free id
16:54:41 <lambdabot> f . id = id . f
16:54:52 <ski> scooty-puff : hm, your first link gives me a completely empty document ..
16:54:59 <scooty-puff> o, thats no good
16:55:18 <ski> (might be some javascript silliness, maybe ?)
16:55:59 <scooty-puff> https://github.com/sonyandy/jfuck/blob/master/Language/Brainfuck/Compiler.hs#L33
16:56:11 <scooty-puff> guess thats prob the same link.. (i tried logging out and getting the link again)
16:56:16 <scooty-puff> probably
16:57:15 <ski> ok, the latter links works ok, and if i skip the `#L33', the first works as well
16:57:50 <hpaste> scooty-puff pasted “Universal Quantification” at http://hpaste.org/48117
16:57:52 <Xaratas> thanks aavogt
16:58:08 <scooty-puff> thats the error message i'm getting
16:58:57 <scooty-puff> i have tried more specific types in Emitter.hs, but without much success
16:59:02 <ski> where (/ to what) is `Code' defined ?
17:00:16 <scooty-puff> in Control.Monad.Code, its defined as:
17:00:30 <scooty-puff> type Code s = CodeT s (ConstantPoolT Version)
17:01:09 <scooty-puff> CodeT is:
17:01:24 <hpaste> scooty-puff pasted “CodeT” at http://hpaste.org/48118
17:01:54 <joe6> just curious, why would the definition be this:  http://sprunge.us/gPNh
17:01:59 <ski> if you have problems composing `(forall a. ..a..) -> ...', you could try enabling `ImpredicativeTypes'
17:02:13 <scooty-puff> ok
17:02:53 <scooty-puff> i assume in Compiler.hs?
17:03:02 <joe6> or, I should be asking when something is declared as http://sprunge.us/gPNh, and I have 'x :: CTranslUnit' . How can I do "show x"?
17:03:10 <ski> yeah
17:04:18 <acowley> joe6: where did you get that definition?
17:04:35 <acowley> not here, apparently: http://hackage.haskell.org/packages/archive/language-c/0.3.2.1/doc/html/src/Language-C-Syntax-AST.html#CTranslUnit
17:04:47 <joe6> acowley: Language.C.Syntax.AST
17:05:14 <joe6> acowley: oh.
17:05:23 <acowley> that also has CTranslUnit as a datatype
17:05:24 <joe6> i got it from the darcs repository.
17:05:38 <joe6> the one you have is so different.
17:06:07 <scooty-puff> hmm, no luck - tried giving emit or more specific type as well, to no avail
17:07:34 <joe6> acowley, i got it from the repo. Can I derive "show" on a type?
17:07:42 <acowley> well, in any case, the idea is that that you have a type CTranslUnit, and a data constructor CTranslUnit
17:07:49 <acowley> you don't need to
17:08:04 <acowley> the type synonym has all the instances of that which it synonimizes!
17:08:07 <scooty-puff> ski, will impredicative types do anything in ghc 7?
17:08:09 <joe6> how can i do show on x where x :: CTranslUnit
17:08:25 <ski> scooty-puff : i'm not sure
17:08:32 <joe6> acowley, but, show x is not working
17:08:47 <acowley> joe6: same code as last time?
17:08:57 <joe6> acowley, this is what I get:  http://sprunge.us/PVQY
17:09:19 <joe6> acowley, thanks to your suggestion, I was able to figure out that I can use show . pretty to see the code.
17:09:22 <ski> scooty-puff : `forall s. Code s () i0 a0' is `forall s. CodeT s (ConstantPoolT Version) i0 a0', which you appear to try to match with `m () () (Label m ())' from `emit'
17:09:47 <joe6> acowley: but, pretty is massaging the output and I want to see the definitions.
17:09:51 <acowley> joe6: are you sure you're using the version of that library you think you're using?
17:09:53 <joe6> hence, I am looking to see if show will work.
17:10:07 <acowley> because the definition you pasted doesn't have a Pretty instance, while the hackage version does
17:10:16 <scooty-puff> i have since changed that to [Command] -> (forall s. Code s () () ()) - with the other necessary adjustments
17:10:17 <acowley> while your definition has a Show instance and the hackage version doesn't
17:10:29 <joe6> acowley, I am using the repo version, 0.4.1. The version linked to, by you, is 0.3.2.1
17:10:52 <joe6> acowley:  darcs get http://code.haskell.org/language-c
17:10:52 <ski> scooty-puff : assuming `m = CodeT s', we're trying to match (modulo the `forall') `m (ConstantPoolT Version) i0 a0' with m () () (Label m ())', which doesn't seem to work, since `(ConstantPoolT Version)' doesn't match `()'
17:11:02 <acowley> well, I spoke to soon, I don't know if the newer version has a Pretty instance
17:11:11 <ski> scooty-puff : oh .. hm
17:11:12 <joe6> acowley: it does.
17:11:37 <joe6> acowley: but, I want to use show. not pretty, as pretty is massaging the output and I want to see the raw definition.
17:11:38 <scooty-puff> my first thought was that i was letting s escape its scope
17:11:59 <scooty-puff> (so now it returns unit)
17:12:00 <acowley> joe6: I don't see the Pretty instance in http://code.haskell.org/language-c/src/Language/C/Syntax/AST.hs
17:12:09 <ski> (`i' ?)
17:12:18 <scooty-puff> yeah, i'm not so good with names
17:12:24 <scooty-puff> so for CodeT s m i j a
17:12:27 <indeterminate> about how comfortable would someone want to be with haskell before braving SICP with it instead of scheme?
17:12:39 <joe6> acowley, the pretty is in language.Pretty
17:12:41 <kmc> i think a lot of things would not translate very easily
17:12:50 <scooty-puff> m is the transformed monad, s it the universial quantifier (terminology?), i and j are the input and output types
17:12:50 <joe6> acowley, the pretty is in language.C.Pretty
17:12:53 <acowley> joe6: yep, you're right
17:13:07 <kmc> scooty-puff, it's the universally-quantified thing... the quantifier is "forall" itself
17:13:07 <scooty-puff> as for an indexed monad
17:13:09 <ski> scooty-puff : `s' is just a type argument
17:13:13 <kmc> i don't have a good name for the 's' variable
17:13:18 <kmc> some people call it "the state thread"
17:13:23 <ski> *nod*
17:13:36 <acowley> joe6: so back to the code you pasted earlier, why are you fmapping a function over the ast?
17:13:56 <joe6> acowley, this is the definition:  http://sprunge.us/TeJj in the repo. Is there any way to get show to work on x::CTranslUnit
17:14:02 <joe6> acowley: forget about that code.
17:14:16 <joe6> acowley:  I found that code in their examples
17:14:18 <acowley> okay, what's the error when you just try to show a CTranslUnit?
17:14:28 <joe6> acowley: and, it does not seem to do what it is supposed to.
17:14:36 <scooty-puff> the state thread is to ensure Labels don't escape the CodeT thread - were i to want to allow use of a type class context instead of the CodeT type, i imagine i would need to add this state thread to the type class
17:14:40 <joe6>  http://sprunge.us/eUWS
17:14:48 <joe6> acowley, the error:  http://sprunge.us/eUWS
17:15:44 <joe6> acowley: you know what, I think I have the wrong version installed.
17:16:07 <joe6> I think the cabal install language-c has the 0.3.2.1 installed and not the repo version that I checked out.
17:16:18 <acowley> I agree!
17:16:20 <joe6> acowley: that explains the error.
17:16:55 <joe6> acowley: thanks for the help. It gets easier to debug when there is someone knowledgeable to bounce ideas off.
17:17:02 <kmc> anyone know, when creating a Vector.Storable from a raw ForeignPtr, if I should worry about alignment?
17:17:27 <acowley> joe6: glad I could help!
17:17:43 <acowley> kmc: I never have
17:17:52 <kmc> and you do this kind of thing?
17:17:56 <acowley> I do
17:17:57 <kmc> cool
17:18:03 <kmc> are you by any chance converting from ByteString?
17:18:14 <kmc> also, what architecture?
17:18:21 <kmc> x86 is usually fine with misaligned loads (they might be slower)
17:18:30 <kmc> but some other chips will choke and die
17:19:01 <kmc> i guess i should see if the Vector code has alignment-aware allocation in the first place
17:19:06 <kmc> ideally, you'd want to be cache-aligned too
17:19:21 <kmc> this came out of a project to parse MATLAB files
17:19:30 <kmc> which have packed numeric data
17:19:41 <danharaj> hey, is case in Haskell the same as case in GHC core? As in, does case force evaluation?
17:19:48 <kmc> no
17:19:51 <kmc> > case undefined of _ -> ()
17:19:53 <lambdabot>   ()
17:20:03 <acowley> kmc: clever traversal code will often handle unaligned starts of buffers specially before getting to aligned stretches
17:20:11 <kmc> 'case' in Haskell forces as much or as little as it needs to, to resolve the given patterns
17:20:16 <kmc> acowley, yeah, makes sense
17:20:27 <kmc> danharaj, so it can force nothing, or force more than whnf
17:20:36 <danharaj> ah ok.
17:20:38 <kmc> in Core nested patterns are disallowed (i think?) and so it will only force to whnf
17:20:41 <kmc> and always does so
17:21:08 <kmc> it's still fair to say that 'case' is the fundamental forcing construct in Haskell, though
17:21:08 <acowley> kmc: I have ByteString to Vector code on github you can check out and tell me if it's wrong
17:21:13 <kmc> and 'let' the fundamental allocating construct
17:21:14 <acowley> but github isn't loading for me at the moment
17:21:19 <kmc> acowley, ah, i was just wondering if you were using some lib for it
17:21:20 <joe6> acowley: just wanted to let you know that the show is working now.
17:21:24 <kmc> because i couldn't find one
17:21:31 <kmc> it's only like 4 lines of code but i think it's useful enough to package
17:22:03 <kmc> given that users of ByteString and Vector should not be expected to know anything about ForeignPtr etc
17:22:15 <danharaj> kmc: Is `where' treated the same as `let'?
17:22:25 <kmc> danharaj, they're both lazy in the same way
17:22:29 <scooty-puff> ski: so i'm leaning towards giving up and removing the s type and letting it sometimes not be correct - from the look of it, getting it to type check will be difficult
17:22:36 <kmc> the differences are mostly syntactic
17:22:53 <ski> > case () of () -> x where x = ()
17:22:53 <acowley> kmc: I have several versions of it
17:22:53 <acowley> basically, whether or not the bytes are copied
17:22:53 <lambdabot>   ()
17:23:24 <ski> scooty-puff : it's hard for me to say what to do, since the code is complicated, with lots of things i don't know about
17:23:46 <danharaj> kmc: ah ok. So using let's and case's properly makes it easier to reason about the actual execution of my code?
17:23:50 * ski wonders whether Core `case' supports `where' on the branches
17:24:02 <scooty-puff> when working with ST, and you have multiple operations in that monad that are to be composed
17:24:04 <scooty-puff> do you write:
17:24:05 <kmc> danharaj, I guess so?  I'm not sure what you'd mean by using them improperly
17:24:13 <scooty-puff> SomeType -> ST s SomeOtherType
17:24:15 <scooty-puff> or:
17:24:24 <scooty-puff> SomeType -> (forall s. ST s SomeOtherType)
17:24:35 <kmc> does not matter
17:24:40 <danharaj> kmc: Well, using too many nested cases sounds like a recipe for making code harder to read :p
17:24:41 <ski> i'd probably write the former
17:25:04 <kmc> in GHC Haskell, (A -> forall a. F a) is roughly equivalent to (forall a. A -> F a)
17:25:14 <kmc> it's not quite equivalent in the theoretical System F setting, but Haskell hides those details
17:25:19 <scooty-puff> ok
17:25:29 <kmc> putting 'forall' to the *left* of -> is the special thing
17:25:32 <kmc> (forall s. ST s a) -> a
17:26:20 <scooty-puff> ok, that makes sense
17:26:35 <acowley> kmc: https://github.com/acowley/roshask/blob/master/Ros/Core/Util/BytesToVector.hs
17:26:49 <acowley> kmc: it's scary dirty code, but I think it's okay
17:27:05 <acowley> kmc: though I don't think I use most of it,
17:27:11 <acowley> sooo I'm not sure how okay
17:27:45 <danharaj> So what exactly is the spine of a data structure?
17:28:20 <acowley> I was experimenting with a bunch of that kind of conversion, and ended up with those varieties.
17:28:34 <kmc> danharaj, well, the spine of a list is all its (:) constructors
17:28:42 <acowley> danharaj: the constructors around recursion
17:30:25 <ski> (scooty-puff : fyi, `forall a. F a -> A' is `(exists a. F a) -> A')
17:30:52 <danharaj> So does the spine of `data BTree = Leaf a | Branch (BTree a) (BTree a) | Nil' consist of just Branch?
17:31:02 <scooty-puff> i need to lookup what semantics go with exists..
17:31:16 <ski> danharaj : all the branches down to the leaves, i'd say
17:31:35 <acowley> danharaj: I think I'd include the Leafs as spine terminators
17:31:47 <acowley> but to make it spine strict would involve annotating the Branch variant
17:31:56 <ski> danharaj : `forceSpine (Leaf _) = (); forceSpine (Branch l r) = seq (forceSpine l) (forceSpine r)'
17:32:44 <ski> oh, you had a `Nil' as well, so `forceSpine Nil = ()'
17:33:46 <danharaj> So the spine is basically the tree of constructors of a value.
17:33:48 <acowley> or, .... | Branch !(BTree a) !(BTree a) | ...
17:33:51 <danharaj> without the gooey bits.
17:33:57 <acowley> yes
17:34:00 <acowley> no goo
17:34:46 <ski>   foldBTree (\() -> ()) (\() () -> ()) () . fmap (const ())
17:37:12 <acowley> Is the SpecConstr warning going to go away soon?
17:39:22 <parcs> it's been hidden by default in ghc head
17:39:48 <scooty-puff> ski: if it means anything, https://github.com/sonyandy/jfuck/blob/master/Hello.hs compiles cleanly
17:39:55 <scooty-puff> but i think i'm going to giv eup
17:39:57 <scooty-puff> *give up
17:40:24 <Cale> scooty-puff: What's going on?
17:40:56 <scooty-puff> i cannot get https://github.com/sonyandy/jfuck/blob/master/Language/Brainfuck/Compiler.hs
17:40:58 <acowley> parcs: do you know if they also raised the default limit?
17:40:58 <scooty-puff> to compile
17:41:01 <scooty-puff> it gives:
17:41:10 <scooty-puff> http://hpaste.org/48117
17:41:12 <scooty-puff> as the error
17:41:16 <scooty-puff> i have since updated:
17:41:28 <scooty-puff> https://github.com/sonyandy/jfuck/blob/master/Language/Brainfuck/Emitter.hs
17:41:30 <parcs> acowley: i'm not sure
17:41:46 <scooty-puff> to use a particular type (Code) instead of the constrained type variable it currently uses
17:42:17 <scooty-puff> Cale, i can paste the current error
17:42:38 <scooty-puff> http://hpaste.org/48118 is the type of CodeT, Code is a type synonym of it
17:43:18 <parcs> acowley: it seems that the default limit is (still?) 3
17:43:37 <acowley> parcs: I'm pretty confused about the limit, actually
17:45:38 <Cale> scooty-puff: okay, first thing, rewrite without using (.)
17:45:43 <Cale> scooty-puff: and no $ either
17:46:03 <Cale> scooty-puff: Just because there are higher-rank types around, and unification is weird with those
17:46:20 <scooty-puff> ok, i'll let you know where that gets me
17:46:25 <Cale> scooty-puff: So in particular, this emit . optimize thing
17:46:41 <Cale> It looks like maybe it's getting hung up on (.) making things less polymorphic
17:46:46 <scooty-puff> ok
17:46:58 * hackagebot stdata 0.0.3 - Structure Data Library  http://hackage.haskell.org/package/stdata-0.0.3 (DavidDarais)
17:51:47 <scooty-puff> Cale, (please mind the caps) THANK YOU!
17:52:12 <Cale> scooty-puff: Did that work?
17:52:17 <scooty-puff> replaced it with let x = ...; x' = ...; etc. in runPut x'''
17:52:18 <scooty-puff> yep
17:52:23 <Cale> okay, cool
17:52:35 <Cale> Yeah, you have to be careful in a similar way around runST
17:53:07 <scooty-puff> could i define a local def of (.) that includes the correct "forall"s?
17:53:29 <Cale> because when something demands a value of polymorphic type, and you pipe that through a lambda (which (.) is), it's bound to a (locally) monomorphic type, even if that's a type variable, and type variables can never be instantiated with polytypes in GHC.
17:53:49 <scooty-puff> ok
17:55:19 <acowley> that seems unfortunate
17:55:42 <Sunhay_> hey guys, i need some help. im trying to install hakyll 2.3.1 but i recieve an error saying that zlib-0.5.3.1 isnt installed (but zlib is installed)
17:55:45 <acowley> is it necessary that the quantification is lost, or is it just the current implementation?
17:56:01 <Sunhay_> this is via caba
17:56:04 <Sunhay_> cabal*
17:56:10 <ski> so does `ImpredicativeTypes' not work for this, atm ?
17:57:42 <acowley> Sunhay_ that's a very old hakyll!
17:59:02 <edwardk> ski: around?
17:59:27 <scooty-puff> thanks for the help ski, Cale
17:59:43 <edwardk> a couple of observations about that elimination form for Free from earlier. if we start with the newtype Rec f a = (f a -> a) -> a elimination form
17:59:51 <edwardk> then the one I used earlier is just Yoneda (Rec f)
17:59:59 <edwardk> which is a functor thanks to Yoneda.
18:00:30 <parcs> does ghc evaluates polymorphic numeric literals during runtime or compile time?
18:00:34 <JuanDaugherty> edwardk, do you mean Stefan Ljungstrad?
18:00:42 <edwardk> JuanDaugherty: yeah
18:01:09 <JuanDaugherty> he's in prolog but marked away
18:01:12 <edwardk> ah
18:01:26 <edwardk> been playing with free monads
18:01:26 <Sunhay_> acowley: heh, yeah =D. i remember having this problem before but i got it working after some quick help from this channel
18:02:56 <acowley> Sunhay_: what zlib do you have? 0.5.3.1 is current
18:03:14 <edwardk> the part that is interesting to me is that if we use that Free f a ~ Yoneda (Rec f) a observation, then we might be able to use that to use something cheaper for Codensity (Free f) a, which is Codensity (Rec f) a
18:03:21 <edwardk> and potentially derive the same benefits
18:03:39 <edwardk> because Codensity (Yoneda f) a is just a more expensive Codensity f a in my experience
18:03:47 <Sunhay_> acowley: zlib-1.2.5-3.fc15.i686
18:04:49 <ski> edwardk : ACK
18:04:52 <edwardk> but i may not have enough room in the type to fit it
18:05:07 <edwardk> ski: letting you catch up =)
18:06:15 <edwardk> so the question is can we get by with (forall r. (a -> (f r -> r) -> r) -> (f r -> r) -> r) as a better free monad
18:06:37 <ski> edwardk : `Codensity . Yoneda = Codensity' ?
18:06:56 <edwardk> well, Codensity 'lets you fuse fmaps and >>='s and Yoneda lets you fuse fmaps
18:07:03 <ski> *nod*
18:07:06 <edwardk> so it theoretically offers no extra power
18:07:41 <edwardk> if so this might offer a more efficient encoding of janis voightlaender's asymptotic improvement of free monads paper
18:08:53 <edwardk> the monad comes for free for Codensity (Rec f)
18:08:58 <ski> (JuanDaugherty : i'm also in here, and marked away)
18:09:03 <edwardk> so i just need a cheap lift :: Free f a -> Codensity (Rec f)
18:09:10 <JuanDaugherty> yeah must a missed it here
18:09:49 <edwardk> yeah
18:11:05 <JuanDaugherty> I keep thinking there should be a collision on that nick but forgot you would have claimed it
18:11:27 <Sunhay_> acowley: got it, i just needed to instal zlib-devel =D
18:13:36 <ski>   lift (Pure a      ) c k = c a k
18:13:37 <ski>   lift (JoinIncl fma) c k = k (fmap (\ma -> lift ma c k) fma)
18:14:14 <ski> edwardk : is that good enough ?
18:14:18 <edwardk> the question is whether or not that will be reasonably fast
18:14:31 <edwardk> going to test it in a bit
18:15:15 <edwardk> working on the MonadTrans instance first
18:15:30 <edwardk> lift :: m a -> Codensity (Rec m) a
18:15:33 <ski> (maybe you should make a local definition with `c' and `k' as nonlocals ..)
18:16:08 <ski> hm .. or can we use polymorphic recursion ?
18:16:33 <edwardk> you can use polymorphic recursion. the quantifier is there for your benefit ;)
18:16:48 <ski> yeah, i meant : is there any point in doing so ?
18:17:01 <ski> (and will it give the same results ?)
18:17:23 <edwardk> well, the previous lift was just
18:17:29 <edwardk> lift m = Codensity (m >>=)
18:17:44 <edwardk> using the >>= from Free
18:18:04 <ski> which we could fuse, probably getting something like the above ?
18:18:40 <edwardk> likely
18:20:05 <cmccann> edwardk, you might be interested in http://stackoverflow.com/questions/6433703
18:20:58 <cmccann> (cf. my answer if it's not immediately obvious why)
18:21:10 * hackagebot couch-hs 0.1.0 - A CouchDB view server for Haskell.  http://hackage.haskell.org/package/couch-hs-0.1.0 (PeterSagerson)
18:21:28 <edwardk> cmccann: =)
18:21:34 <ben> Oh, the compiler actually assumes the monad laws hold in optimisations?
18:21:40 <edwardk> ben: no
18:22:27 <edwardk> ben: no use of the monad laws is made by the compiler
18:22:28 <edwardk> (except perhaps to motivate some of the choices in how do notation desugars)
18:22:35 <edwardk> but its just motivation for the translation they use
18:23:29 <cmccann> edwardk, it hadn't actually occured to me before that return was unnecessary for do syntax
18:24:21 <ski> @undo do () <- x; y
18:24:22 <lambdabot> x >>= \ a -> case a of { () -> y; _ -> fail ""}
18:24:25 <edwardk> cmccann: yeah, i use that in a scheme library i have somewhere around here
18:24:43 <edwardk> cmccann: which actually was part of what motivated my bind class
18:24:52 * cmccann nods
18:26:32 <ddarius> do-notation is almost trivial.
18:26:52 <edwardk> i'm rather liking the streamlined codensity free
18:27:39 <scooty-puff> Cale, i may have missed it (had change locations), but is there a plan to allow (.) instead of explicit let's in the future?
18:30:37 <edwardk> the fmaps that result seem to appear in the same places they would when i use the normal free monad
18:38:10 <edwardk> the next observation is that the only use i make of the (f r -> r) seems to be to pass it through unmolested. so it may turn out that you get the same performance out of the naively constructed Yoneda (Rec f)  that you do out of Codensity (Rec f)
18:38:23 <edwardk> unless i missed something, which is likely
18:40:16 <sam5> Can I get some help with a code?
18:40:22 <sam5> http://hpaste.org/48123
18:41:11 <sam5> I get the Integer int error
18:41:32 <mauke> the what?
18:42:20 <sam5> http://hpaste.org/48123
18:42:47 <sam5> it seems that go is outputting Int type
18:42:59 <sam5> I tried fromIntegral...
18:43:09 <edwardk> ski: hrmm, given the type above, whats the lowering from that to Free f a?
18:43:19 <ski> sam5 : i think this will be better if you replace `length' with `genericLength'
18:43:36 <ski> edwardk : which type ?
18:43:48 <ski> `forall r. (a -> (f r -> r) -> r) -> (f r -> r) -> r' ?
18:43:52 <edwardk> yeah
18:43:54 <sam5> what exactly is the difference?
18:43:56 <edwardk> to Free f a
18:44:01 <ski> @type length
18:44:02 <lambdabot> forall a. [a] -> Int
18:44:04 <sam5> between length and generic length
18:44:04 <ski> @type genericLength
18:44:05 <lambdabot> forall b i. (Num i) => [b] -> i
18:44:32 <ski> sam5 : `length' gives an `Int', while `genericLength' gives any `Integral' type you like, such as `Integer'
18:44:37 <mike-burns> I'm facing some Int Integer Integral Rational hatred right now, too.
18:44:42 <sam5> Oh...
18:45:02 <ski> sam5 : i think you can probably remove `fromIntegral', if you use `genericLength' instead
18:45:05 <mike-burns> Is there a benefit to having Real, Integral, etc. all separated? Are there actual bugs caught by this?
18:45:24 <mauke> mike-burns: how do you unify them?
18:45:44 <ski> @src Real
18:45:45 <lambdabot> class  (Num a, Ord a) => Real a  where
18:45:45 <lambdabot>     toRational      ::  a -> Rational
18:46:10 * ski isn't sure what `Real' is for ..
18:46:34 <ddarius> ski: It's was to win the award for most ludicrously named class.
18:46:35 <mauke> keeping it real, yo
18:46:48 <ddarius> ski: It's for realToFrac
18:46:55 <ddarius> @src realToFrac
18:46:56 <lambdabot> realToFrac = fromRational . toRational
18:47:48 <mike-burns> I only notice that there's a whole type hierarchy when I use (/) , and the only thing I'd like the compiler to catch me on for (/) is division by zero. Which it doesn't do.
18:47:55 <mike-burns> So, yeah. That's my complaint.
18:47:59 <mike-burns> Back to hacking.
18:48:07 <mauke> there's no type hierarchy
18:48:56 <luite> it depends on the type, / with Rational will give an exception
18:49:49 <ski> edwardk : is `lower frob = frob (const . Pure) JoinIncl' bad ?
18:50:10 * ski isn't sure what effect `const' will have, there
18:50:13 <edwardk> nah, thats the one i just constructed basically
18:50:22 <mauke> did you mean: pure . Pure
18:50:30 * ski grins
18:51:39 <ddarius> mike-burns: Read this thread: http://www.haskell.org/pipermail/haskell-cafe/2007-June/027092.html  I enjoyed the upshot which I saw coming a mile away.
18:52:20 <ski> edwardk : if we want an isomorphism, then i suppose `const' in there will be bad
18:52:25 * mike-burns reads!
18:52:55 <edwardk> well, the const i think is safe. remember we enlarged. we went from Yoneda (Rec f) a to Codensity (Rec f) a
18:53:04 <ddarius> byorgey: You may find a younger you interesting as well.
18:53:10 <edwardk> so coming back down there should be wiggle room
18:53:39 <ski> yeah, but i'm worrying this is only a retract situation
18:54:02 <smoge> what's the best editor to start haskell?
18:54:15 <mike-burns> Hah, OK, Brent learns a lesson in the end.
18:56:48 <ski> smoge : not sure about best, which editors are you faimilar with ?
18:57:08 <parcs> smoge: emacs is probably the most integrated with auxiliary tools
18:57:32 * ski has heard about people using lots of editors
18:57:57 <mike-burns> Like, six editors open at once?
18:57:59 <luite> where integrated means bunch of stuff hacked together so that it just barely works ;p
18:58:40 <ski> mike-burns : i haven't heard about that, but i wouldn't be surprised ..
19:03:02 <ski> hm, i suppose the `const' just ignores the `k', one way around
19:03:17 <edwardk> *nods*
19:03:36 <edwardk> next one: wrap :: f (CF f a) -> CF f a where CF is the quantified type above ;)
19:03:49 <edwardk> assuming Functor f
19:04:09 * ski is only half-awake, explaining why this takes time
19:04:18 <edwardk> the const looks fine to me
19:04:56 * ddarius has possibly had notepad, wordpad, Word, Visual Studio, and vim all open at once, but that's only 5.
19:05:41 <luite> wordpad and notepad? o_O?
19:05:48 <mauke> I hear you can run vim in an emacs buffer
19:05:54 <smoge> I like emacs
19:06:04 <smoge> I miss some 'help' integration
19:07:21 <ski>   wrap fma c k = k (fmap (\ma -> ma c k) fma)  -- more or less the same as the `JoinIncl' case of `lift', it seems
19:07:40 <ddarius> Here's a tip:  If you're going to buy ripe fruit, eat it.
19:08:16 <ski> hehe
19:08:46 <luite> unless you like fruit flies
19:09:14 * ski idly wonders why (it seems like) most people eats unripe bananas
19:09:16 <luite> but last time I did that "experiment" the results were boring, all my fruit flies had red eyes
19:09:46 <luite> and I didn't knwo what other variations to look for
19:10:04 <dainanaki> Could someone walk me through compiling an objective-c file into a .o file and then using functions from it with Haskell's FFI? I have a function declared as void test_func () that does obj-c things inside and I want to call it in a Haskell program, but it's giving me issues
19:13:15 <ddarius> dainanaki: No.
19:13:37 <dainanaki> More specifically, I'm getting the following error: "Loading object (static) test_objc.o ... ghc: test_objc.o: Bad magic. Expected: feedface, got: feedfacf."
19:13:40 <copumpkin> dainanaki: export a C interface (wrapper) to the objc module
19:14:23 <copumpkin> or enjoy learning about the objc ABI and runtime internals :)
19:14:36 * ddarius likes ABIs and runtime internals.
19:14:43 <copumpkin> I do too :) most people don't
19:15:32 <ddarius> The Itanium seemed like it would lead to some interesting and nice ABIs.
19:17:29 <dainanaki> Well, the function declaration is just a c function that happens to use obj-c inside the definition. I don't understand how get ghc to compile it and link it in an hs file or else to compile the .m file with gcc and then get ghc to link it.
19:18:43 * ddarius compiles all his .c files with ghc.
19:20:32 <dainanaki> that doesn't really help though
19:20:51 <ddarius> Who said anything about helping?
19:21:16 <ddarius> I think I recall suggesting despairing above.
19:22:33 <sam5> Can I get some help?
19:22:45 <sam5> it says I get a parse error on the third line
19:22:46 <sam5> http://hpaste.org/48124
19:22:52 <sam5> 2nd line
19:23:01 <dainanaki> you forgot a backtick
19:23:16 <dainanaki> it should be `fntt`
19:23:39 <luite> nah you shouldn't use backticks in function names :)
19:23:57 <aavogt> use apostrophe ' instead
19:24:01 <sam5> oh... I meant to use aposrophe...
19:24:03 <dainanaki> well there are more than a few errors
19:24:05 <sam5> oops
19:24:29 <aavogt> > (`succ` 1)
19:24:29 <lambdabot>   Overlapping instances for GHC.Show.Show ((t -> t1) -> t1)
19:24:29 <lambdabot>    arising from a...
19:25:56 <ski> > (0 `succ`)
19:25:56 <lambdabot>   1
19:26:29 <sam5> I just have a general questions
19:26:32 <sam5> question
19:26:42 <sam5> with what do you write haskell code?
19:26:58 <pikhq_> Emacs and vim are popular choices.
19:26:58 <sam5> I use textwrangler... but I keep getting indentation messed up...
19:27:06 <sam5> oh I see
19:28:08 <ski> sam5 : either don't use tabs for indentation, or only use tabs for indentation and break line after layout-introducing keywords
19:28:45 <ski> then line stuff up :)
19:29:03 <sam5> hm... I'll try
19:29:09 <sam5> I always pasted it in hpaste
19:29:15 <sam5> and then fixed the indentation haha
19:30:44 <ski> btw, i would lift `(***)',`deinterleave' and `pairs' out of that `where'
19:31:13 <ski> sam5 : did you try removing `fromIntegral', yet ?
19:31:43 <sam5> um... let me try
19:32:29 <sam5> yes it worked without fromIntegral
19:32:37 <ski> btw `fmap ((+1) . (*n)) [1..]' can be written as `fmap (+1) [n , 2*n ..]' can be written as `[n + 1 , 2*n + 1 ..]'
19:32:44 <ski> i'm not sure which you prefer
19:32:56 <ski> (though i would use `map' instead of `fmap', i think)
19:34:10 <hpaste> aavogt pasted “tictac” at http://hpaste.org/48127
19:34:29 <aavogt> roconnor: ^^
19:34:36 <sam5> wow thanks ski
19:34:37 <ski> does `fntt' stand for anything in particular ?
19:34:41 <sam5> I never knew you could do that
19:34:57 <sam5> fast number theoretic transform
19:35:14 <sam5> trying to code this for research in cryptography
19:35:25 <sam5> but I am just starting to use the language... so its hard...
19:35:45 * ddarius huggles NTTs.
19:37:06 <ski> hm, `xs' and `ks' inside `go' is the same length, right ?
19:37:38 <sam5> yes
19:38:18 <sam5> I actually have it finished up now... but can I ask you for some advice?
19:38:20 <ski> so `zipWith (flip ($)) (xs ++ xs) (fmap f ks ++ fmap g ks))' is the same as `zipWith f ks xs ++ zipWith g ks xs'
19:38:46 <sam5> http://hpaste.org/48128
19:39:34 <sam5> hm.. I see...
19:39:38 <sam5> one problem is...
19:39:57 <ski> and then `zipWith (flip ($)) (ys ++ ys) (..that above..)' becomes `zipWith3 f ks xs ys ++ zipWith3 g ks xs ys'
19:42:14 <ski> hm  fntt'  preserves length, right ?
19:42:22 <sam5> yes
19:42:39 <ski> or, hm
19:43:06 <ski> no, it can't be called on lists with odd length, (apart from singleton lists, which is a base case)
19:43:29 <ski> `pairs' will ignore the last element, if odd-lengthed
19:43:52 <sam5> ya... that's the property... it only works with lists of powers of two
19:44:11 <ski> well, it also works with lists of length zero
19:44:36 <ski> > logBase 2 0
19:44:37 <lambdabot>   -Infinity
19:44:52 <sam5> a problem that I have... is that I had to create a helper function
19:45:12 <sam5> and have to calculate p twice...
19:45:26 <sam5> I want to mod the final output with p...
19:45:44 <sam5> but I can't do it in the same function because the function is recursive
19:45:48 <ski> but assuming you only call it with even-lengthed lists, then `ys' and `zs' has the same length, and `xs' double that, so why use `genericLength' twice ?
19:45:56 <sam5> and dividing by p messes the calculations
19:46:49 <ski> hm, i think that passing `[0 ..]' for `ks' would work just fine
19:46:50 <sam5> because in order to calculate p
19:47:04 <sam5> I have to know the length of the list...
19:47:34 <sam5> since I'm calculating p in both outer and helper function... I calculated length on both...
19:47:58 <ski> well, computing `len' is unnecessary, at least
19:48:38 <ski> sam5 : did you rewrite `go' as i suggested, yet ?
19:48:55 <sam5> I"m trying... thanks so much
19:49:35 <ski> hm, btw
19:50:08 <ski> does it matter in which order `go' puts the result elements ?
19:50:53 <sam5> yes...
19:50:55 <sam5> that matters
19:51:29 <sam5> I'm trying to change the go code like you suggested...
19:51:41 <sam5> but its a little confusing for me
19:51:53 <ski> hm .. i might try to adapt the code to work on perfectly balanced trees
19:52:08 <ski> i'm not sure whether that will improve efficiency, though
19:52:20 <ski> (but it could be nice, as an exercise)
19:53:19 * ski ponders how to slice perfectly balanced trees
19:53:42 <sam5> oh... I changed it now...
19:54:03 <sam5> http://hpaste.org/48130
19:54:15 <sam5> is there like a constant variable type in haskell?
19:54:26 <ski> i'm not sure what you mean
19:54:29 <sam5> a variable when defined once, doesn't change...
19:54:34 <Axman6> all values in haskell are constant
19:54:39 <sam5> oh right...
19:54:44 <sam5> this is functional programm...
19:55:12 <ski> sam5 : now, i might unfold `f' and `g' into `go'
19:55:18 <ski> or at least put them in a `where'
19:55:33 <ski> (to make the whole thing easier to grasp)
19:55:45 <mike-burns> So I'm trying to use the ioctl package to get the size of the current terminal. ... and I'm not quite sure how to do this: http://hpaste.org/48129
19:56:16 <mike-burns> Any advice or assistance reading docs or anything?
19:56:37 <ski> sam5 : anyway, you can replace `[0..len-1]' by `[0 ..]' (so no need to compute `len')
19:56:57 <kmc> all values in any language are constant
19:57:15 <mike-burns> There was one language which let you change values.
19:57:19 * mike-burns searches Google.
19:57:24 <ski> sam5 : and i would put `ks = [0 ..]' inside `go' (or unfold it even)
19:57:41 <kmc> the difference is that variables are names for values in Haskell, and names for reference cells in most other languages
19:58:05 <kmc> (really in Haskell they are names for expressions which might or might not be values, i.e. might or might not be in normal form)
19:58:18 <aavogt> > let x = [[1]] in    do x <- x; x <- x; return x
19:58:19 <lambdabot>   [1]
19:58:37 <ski> > let x = [[1]] in    do x <- x; x
19:58:38 <lambdabot>   [1]
19:59:02 <aavogt> if you never un-nest scopes the difference between name shadowing and destructive update doesn't affect reasoning about the program results
19:59:03 <ski> @. pl undo do x <- x; x
19:59:03 <lambdabot> join x
19:59:23 <ray24> Can someone recommend me a reliable haskell textbook?
19:59:28 <ray24> Please
20:00:13 <ski> aavogt : `do x <- [2]; let {f y = x * y}; x <- [3,4]; return (f x)'
20:00:34 <mike-burns> ray24: I know someone who learned from "Haskell: The Craft of Functional Programming".
20:00:42 * ski did
20:00:50 * mike-burns did, too.
20:01:07 <mike-burns> (But this person I know got hired based on things she learned in that book.)
20:01:12 <ray24> Is that person a professional haskell?
20:01:13 <Axman6> sam5: i think you can make uninterleve more efficient by using a lazy pattern match: uninterleve [] = ([],[]), uninterleve (x:y:xs) = let ~(ys,zy) = uninterleve xs in (x:ys,y:zs)
20:01:13 <ray24> now*
20:01:21 <ray24> I want to be really good at haskell within 2 months from now
20:01:29 <ray24> I'm also studying C++ and bash all at once
20:01:39 <Axman6> you're doing it wrong then
20:01:41 <mike-burns> ray24: She's a pro Erlang-er now, but she did the interviews and initial work in haskell.
20:01:43 <aavogt> ski: I guess that qualifies as that vague un-nesting scopes :)
20:01:53 <ray24> what do you mean Axman6
20:02:04 <ski> Axman6 : `unzip' isn't already doing that ?
20:02:06 <ray24> I haven't begun my study yet. I'm planning it out right now
20:02:23 <Axman6> you're likely to confuse yourself trying to learn three really very different languages at once
20:02:41 <ray24> So what would be the best idea?
20:02:54 <ray24> I get so many different answers.. dont know which one to begin with
20:02:56 <ski> ray24 : start learning ?
20:02:56 <Axman6> also, trying to 'learn a language' in 2 months won't make you a good programmer. it takes time to become a good programmer
20:03:24 <mike-burns> ray24: Pick a project, pick a language, and do it.
20:03:25 <Axman6> there's a hell of a lot more to being a programmer than knowing the language
20:03:35 <ski> ray24 : <http://norvig.com/21-days.html>
20:03:40 <Axman6> if you want to learn haskell, start with lyah:
20:03:43 <Axman6> @where lyah
20:03:43 <lambdabot> http://www.learnyouahaskell.com/
20:04:04 <Axman6> @src unzip
20:04:04 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
20:05:36 <luite> bah annoying PostTcType :(
20:06:09 <ski> > (head . fst . unzip) [(a,b) | a <- [2 ..] | b <- [2,1 ..]]
20:06:11 <lambdabot>   2
20:08:01 <mike-burns> No guesses about how to use the ioctl package, eh? Or an alternative way to find the width of the current terminal?
20:08:22 <aavogt> @hackage ipprint
20:08:23 <lambdabot> http://hackage.haskell.org/package/ipprint
20:08:31 <ray24> Is lambdabot is a bot?
20:08:42 <ray24> Oh yes, it is
20:08:43 <luite> good guess :p
20:08:56 <aavogt> mike-burns: ^^ that package figures out terminal widths somehow
20:09:05 * mike-burns dives in!
20:09:33 <Cale> echo $COLUMNS
20:09:51 <mike-burns> Cale: That only works if the user does   export COLUMNS
20:09:56 <mike-burns> aavogt: You've done it! yes!
20:09:59 <mike-burns> Thank you!
20:10:09 <Cale> My terminal sets that variable automatically somehow
20:10:27 <mike-burns> Cale: Yes, but non-shell programs don't have access to $COLUMNS unless you export it.
20:10:31 <Cale> hm
20:16:31 <inter> This is marginally related to Haskell, but does anyone know how to generate pretty-printed output to the console in Curry (using the PAKCS or Muenster compilers)?
20:37:09 <joe6> any suggestions on how I can make this better: http://pastebin.com/EMCV2r8U
20:37:11 <mauke> The paste EMCV2r8U has been copied to http://hpaste.org/48132
20:37:53 <joe6> the patterns are nested too long. I am not sure if there are better ways to represent such pattern matching.
20:41:32 <joe6> cleaned up the warninigs: http://pastebin.com/rp3rwVa7
20:41:34 <mauke> The paste rp3rwVa7 has been copied to http://hpaste.org/48133
21:10:09 <hpaste> auvergne pasted “gtkimageviewer” at http://hpaste.org/48134
21:10:31 <auvergne> hi
21:10:58 <auvergne> confused about transformers/readers in the very last line of the thing i've just pasted
21:12:20 <auvergne> ghc says Couldn't match expected type `Control.Monad.Trans.Reader.ReaderT                                   (GHC.Ptr.Ptr EKey) IO ()'                with actual type `StateT Viewer IO ()'
21:15:50 <ski> auvergne : could you annotate the paste with the whole error message ?
21:17:54 <hpaste> auvergne annotated “gtkimageviewer” with “gtkimageviewer (annotation)” at http://hpaste.org/48134#a48135
21:18:07 <hpaste> auvergne annotated “gtkimageviewer” with “gtkimageviewer (annotation)” at http://hpaste.org/48134#a48136
21:18:33 <auvergne> ok
21:19:35 <ski> hm, this is a different error from what you said above
21:19:37 <auvergne> oh, and i see the pastebin has identified some warnings.  that's nice of it
21:20:29 <auvergne> ski:  let me just make a new post... it might have been a different compile or something
21:20:53 * ski wonders why auvergne is matching in binds there, instead of using a `case'
21:21:27 <edwardk> i'm thinking we didn't add any power with Codensity (Rec f) to what we had with Yoneda (Rec f)
21:21:29 <hpaste> auvergne pasted “gtkimageviewer(with error)” at http://hpaste.org/48137
21:21:58 <ski> also, i don't see you calling `return' in there ..
21:22:03 <edwardk> all uses of the f algebra just pass along the one they are given
21:22:03 * ski looks at the new paste
21:22:22 <auvergne> ski:  because i'm pretty naieve about haskell, probably
21:22:26 <auvergne> and spelling
21:22:51 <dmwit> StateT and gtk don't mix well.
21:22:54 <auvergne> if i comment out the last 3 lines, it works
21:23:10 <ski> auvergne> :t tryEvent
21:24:12 <auvergne> yeah, i did that... it might be useful to notice that the EventM is a synonym for ReaderT (Ptr t) IO a
21:24:46 <auvergne> then :t tryEvent
21:24:50 <auvergne> tryEvent :: EventM any () -> EventM any Bool
21:24:54 <auvergne> makes more sense
21:25:53 <auvergne> dmwit:  how to handle this problem, then?  i'm open to not using stateT
21:26:11 <dmwit> IORef
21:26:19 <auvergne> it seems like the thing is really about how readerT and stateT work together
21:26:21 <ski> auvergne : yeah. so `tryEvent' can't (directly) be applied to `StateT Viewer IO'-actions
21:26:30 <dmwit> Nope.
21:26:38 <dmwit> It's about how callbacks and StateT fail to work together.
21:27:01 <ski> auvergne : what is `tryEvent' doing ?
21:27:12 <ski> also, why are you using it here ?
21:27:28 <dmwit> tryEvent takes a possibly exception-throwing event and turns it into a non-exception-throwing event (but returning a Bool telling whether an exception would have been thrown).
21:27:36 <auvergne> i'm just following the example at http://projects.haskell.org/gtk2hs/docs/gtk-docs-0.11.0/Graphics-UI-Gtk-Gdk-EventM.html
21:27:37 <dmwit> No idea why he's using it here, though.
21:27:52 <dmwit> Eh, "0" <- eventKeyName is why.
21:27:56 <dmwit> That's a partial pattern.
21:28:06 <dmwit> tryEvent will return False instead of crashing when it doesn't match.
21:28:12 <ski> dmwit : yeah, but why not a `case' instead ?
21:28:28 <dmwit> This is more convenient.
21:28:30 <dmwit> No other reason.
21:28:43 <auvergne> dmwit:  that actually does work..  the whole thing runs except the last three lines
21:29:19 <ski>   tryEvent :: EventM a b -> EventM a (Either SomeException b)  -- hmm
21:29:52 <auvergne> ... going to look at IORef...
21:30:28 <ski> auvergne : are you open to not using `tryEvent' ?
21:31:35 <auvergne> of course.
21:31:51 <auvergne> let me make the case edit and see what happens
21:32:11 <ski> could `eventKeyName' possibly raise an exception ?
21:32:20 <ski>   Yoneda (Rec f) a  =  forall b. (a -> b) -> Rec f b  =  forall b. (a -> b) -> (f b -> b) -> b
21:32:24 <ski>   Codensity (Rec f) a  =  forall b. (a -> Rec f b) -> Rec f b  =  forall b. (a -> (f b -> b) -> b) -> (f b -> b) -> b
21:32:59 <dmwit> No, eventKeyName will not raise an exception.
21:33:05 <dmwit> But the error here has nothing to do with tryEvent.
21:33:13 <dmwit> It has to do with showNextImage, which is not a ReaderT.
21:33:15 <ski> so, you could run it once, and then `case' on the results
21:33:21 <ski> thereby avoiding the use of `tryEvent'
21:33:32 <dmwit> Yes, you could.
21:33:35 <dmwit> But why bother?
21:33:53 <dmwit> Ooooh, I see.
21:33:56 <dmwit> Yes, that would be better.
21:34:01 <dmwit> But it still wouldn't fix his error.
21:34:33 <ski> `eventKeyName' is in `EventM t' ?
21:35:06 * ski assumed it was also in `StateT Viewer IO'
21:37:25 <edwardk> @hpaste
21:37:26 <lambdabot> Haskell pastebin: http://hpaste.org/
21:37:36 <ski> edwardk : and in topic
21:37:41 <ski> (with auto-announce)
21:37:50 <hpaste> edwardk pasted “Yoneda (Rec f) ~ Free f” at http://hpaste.org/48138
21:38:33 <edwardk> ski: so far so good, now i just need to prove that the Yoneda (Rec f) version effectively right associates all of the binds
21:39:24 <ski> edwardk : i was just pondering how to do bind :)
21:39:35 <edwardk> for the Yoneda or Codensity?
21:39:46 <ski> for `Yoneda (Rec f)'
21:40:19 <edwardk> ah, its basically the same as the Reader instance in monad-ran
21:40:39 <ski> `YF' ?
21:41:02 <edwardk> "yoneda free" just so i had something to call it while hacking around
21:41:27 <ski> sorry, "it" being `YF' ?
21:41:36 <edwardk> yeah
21:41:58 <edwardk> @hpaste
21:41:59 <lambdabot> Haskell pastebin: http://hpaste.org/
21:42:25 <hpaste> edwardk annotated “Yoneda (Rec f) ~ Free f” with “Yoneda (Rec f) ~ Free f (annotation)” at http://hpaste.org/48138#a48139
21:42:41 <auvergne> *revisits the yoneda lemma
21:42:51 <edwardk> i added an annotation with the codensity version, but it never uses the extra plumbing.
21:43:46 <edwardk> auvergne: in category theory it says some pretty deep things about hom-sets. in haskell it says the fairly obvious fact that for a Functor f, forall b. (a -> b) -> f b   and f a are isomorphic.
21:45:01 <edwardk> ski: the main thing the CF version gained was that the functor and monad instances were the cheap codensity ones
21:45:27 <edwardk> but YF still avoids using the underlying bind
21:46:23 <ski> the `Functor' instances are the same, if you eta-reduce
21:46:33 <edwardk> yeah
21:46:54 <edwardk> thats because Ran is always a functor and YF is still a right kan extension
21:54:23 <auvergne> edwardk:  this seems like the type of thing that should be in a standard library or on hackage.
21:55:10 <auvergne> this being the thing that you've pasted
21:55:34 <edwardk> auvergne: i have yoneda and codensity in hackage
21:55:57 * ski wonders about `RULES' for types ..
21:56:10 <edwardk> the yoneda free version above is something i only just realized was convenient, and i'm trying to prove whether or not it offers the same asymptotics as Codensity (Free f) a
21:56:55 <edwardk> itll depend on whether or not left binds are expensive in YF or not
21:57:44 <edwardk> auvergne: it may wind up out in the kan-extensions package though
22:00:46 <edwardk> this type came up because forall o i r. (a -> r) -> (o -> Method o i -> (i -> r) -> r) -> r — would be a nice way to represent IO
22:01:05 <auvergne> but you think i could use it to hack out the keybindings?  or is IORef still the way to go?
22:01:11 <edwardk> much nicer than expanding out Codensity (Free f)
22:02:23 <edwardk> no idea. i wasn't tuned in for that conversation ;)
22:03:00 <auvergne> hmm, what about this then:  what does it mean for things to be isomorphic in haskell?
22:03:38 <edwardk> usually that you can find functions f :: a -> b, and g :: b -> a such that f and g are inverses
22:03:39 <auvergne> b/c there is this disconnect between my understanding of math and my understanding off haskell ...  like,
22:03:54 <edwardk> so f . g = id and g . f = id
22:04:13 <ski> that's the traditional definition of `isomorphic'
22:04:19 <edwardk> yeah
22:05:09 <ski> auvergne : two isomorphic types will describe the same values, but can represent them differently, so that one is more efficient than the other (in at least some circumstances)
22:06:09 <auvergne> like monads, i guess you could write something that's a haskell monad that doesn't obey either identity or associativity
22:06:40 <ski> by `identity' and `associativity', do you mean the usual monadic laws ?
22:06:45 <auvergne> yeah
22:06:52 <ski> ok, so it's not a monad
22:07:03 <edwardk> it seems the only power the Codensity (Rec f) machinery gives you is freedom to shuffle the elements in the tree by swapping around or eliminating slots of the 'f' since you know the f involved, and an f algebra, you can only tweak the f r you are given before handing it to the other algebra by duplicating, removing or reshuffling elements.
22:07:06 <auvergne> not according to a math book
22:07:35 <auvergne> but it could be in the monad typeclass somehow
22:07:38 <edwardk> auvergne: lots of classes comes with laws you are required to check manually
22:07:38 <ski> not according to haskell, either
22:07:47 <edwardk> auvergne: if you want that, write agda ;)
22:08:50 <edwardk> so i'm pretty comfortable that Codensity (Rec f) is not the right tool
22:17:10 <hpaste> auvergne annotated “gtkimageviewer(with error)” with “gtkimageviewer(with error) (annotation)” at http://hpaste.org/48137#a48140
22:17:16 <auvergne> ack, i totally confused edwardk with dmwit b/c xchat highlights their names the same way...
22:17:45 <Jafet> rst
22:17:55 <auvergne> ski:  i'm not sure if this is what you meant about using case or not...
22:18:29 <edwardk> =)
22:18:31 <auvergne> dmwit:  i'm not sure how/where you meant to use IORef
22:18:58 <auvergne> edwardk:  what you're doing is much more interesting than all of this
22:19:25 <auvergne> but debug mode is turned on, and i want this to work, dammit
22:19:26 <ski> auvergne : basically, yes, though you presumably want a branch for `"0"' as well
22:19:36 <ski> auvergne : and do you really need `tryEvent', now ?
22:20:05 <auvergne> difficult to answer that:  there are two things:
22:20:09 * ski whispers `CoYoneda IORef' into auvergne's ear
22:21:05 <hpaste> auvergne annotated “gtkimageviewer(with error)” with “gtkimageviewer(with error) (annotation)” at http://hpaste.org/48137#a48141
22:21:24 <auvergne> ski: those are the types
22:21:46 <auvergne> the third argument to on should be a callback
22:22:34 <auvergne> if i replace "$ tryEvent $ do" with "$do", it doesn't work b/c of that
22:22:49 <auvergne> as is, it doesn't work with the same error as before
22:22:59 <ski> mhm
22:24:21 <ski> well, only changes the monadic result type from `()' to `Bool'
22:24:30 <ski> s//`tryEvent'/
22:25:53 * ski wonders why hlint is spewing nonsense, there
22:27:14 <ski> auvergne : anyway, it seems like using `on', the callback can be called at any time
22:27:32 <ski> how do you pass the `Viewer' state to it ?
22:27:51 <ski> (currently you aren't. i'm wondering what you'd *like* to do)
22:28:11 <ski> have you defined `keyPressEvent' ?
22:29:08 <auvergne> no, there is much i haven't figured out... i'll add that to the pastebin, though
22:31:31 <hpaste> auvergne annotated “gtkimageviewer(with error)” with “gtkimageviewer(with error) (annotation)” at http://hpaste.org/48137#a48142
22:55:08 <auvergne> ski:  thanks for all your help.  i think i can get it work, but i've got to get some sleep.  i'll go ahead an finish off the annotations with the latest miss, though.
22:55:14 <hpaste> auvergne annotated “gtkimageviewer(with error)” with “gtkimageviewer(with error) (annotation)” at http://hpaste.org/48137#a48144
23:04:09 <mwc> I'm pretty drunk, so you'll have to bear with mean. Here's the best endorsement for Haskell I can offer: "when you're face-numbingly drunk, and faced with working on either a project in Haskell or a project in any other language, even a drunk knows to choose Haskell."
23:04:19 * mwc goes to drunkenly stagger through an attoparsec module
23:05:31 <byorgey> a pretty ringing endorsement if I ever heard one.
23:05:59 <mwc> The true purpose of static typing is to keep drunken coding on the rails, so to speak
23:06:11 <identity_> mwc: Your'e not the first one to like Haskell when drunk. As a newbie, I first started to grok monads after a few pints of guinness
23:06:22 <identity_> Same with transformers
23:07:37 <k0ral> hi, how can I make files included in data-files section in cabal package executable ?
23:08:08 <mwc> k0ral: don't. If they're shell scripts, what happens if somebody tries to use them on windows?
23:09:27 <k0ral> mwc: why shouldn't I ? the project doesn't even work on Windows so I don't really care about this OS
23:10:00 <mwc> Cabal is targeted towards making haskell modules work anywhere, what you're trying is sort of out of its mandate
23:10:41 <mwc> s/modules/packages/
23:11:43 <k0ral> mwc: that doesn't make sense to me
23:11:53 <k0ral> mwc: my project doesn't even compile on Windows
23:12:38 <k0ral> mwc: anyway, is there another way to get extra files executable ?
23:12:57 <kfish> also you should avoid using mixed case in any filenames, for people using VAX/VMS
23:13:04 <mwc> Not sure. Maybe a hook in the distribution phase?
23:13:29 <k0ral> that's ok for the case, I never use upper cases
23:13:41 <mwc> kfish: is the VMS file system case insensitive? Because Mac OS X will also have that problem unless you set an esoteric option during disk formatting
23:14:07 <kfish> newer openvms will support mixed case but store in all upper case
23:14:25 <kfish> but really i was just trolling, on the topic of legacy operating systems like windows
23:14:32 <mwc> How the hell does someone become an expert on motherfucking VMS?
23:14:51 <k0ral> I understand there is no way using cabal packaging system, so it requires additionnal treatment after installed, which is exactly what I don't want
23:15:10 <kfish> mwc :-)
23:15:33 <mwc> k0ral: well, you can set simple hooks to do it with crap Distribution.Simple
23:15:56 <mwc> if you're only supporting Unix/POSIX/GNU/Linux/Whateverthefuck then a simple chmod shouldn't be too unreasonable
23:17:15 <k0ral> that's exactly what I want
23:17:23 <k0ral> thank you
23:18:11 <mwc> You want to make what-I-assume-are-sh-scripts executable after installation?
23:18:20 <k0ral> yes
23:18:36 <mwc> Why are you distributing part of your program as a sh script?
23:19:06 <mwc> I mean, it may have been slightly less masochistic to write it in intercal
23:19:58 <mwc> Alternatively, if you need a high level binding to some functionality that isn't already on hackage, mention it here and by next week you should have five or six competing implementations of it on hackage
23:20:03 * mwc glares at iteratee IO
23:20:41 <k0ral> because the application should do only one thing but do it well, then it requires external scripts to do extra jobs; most users expect such jobs to be performed while my application won't, so I'm giving examples of shell scripts to do them
23:21:34 <mwc> it would further the cause of haskell world domination if you wrote some sort of monadic API instead ;P
23:23:00 <k0ral> I'm afraid I can't see what you mean by monadic API, if you have any link I should read about the topic, I would be glad to, that sounds interesting
23:23:19 <mwc> haha, sorry, a lame joke I'm afraid
23:23:28 <k0ral> oh :)
23:24:21 <k0ral> actually, there are some missing bindings on hackage but I hardly think 5/6 people will commit into it as I tell you
23:24:30 <mwc> Out of curiosity, what are you writing?
23:24:42 <k0ral> look for hbro in hackage
23:24:57 <k0ral> for example, there is no JavascriptCore binding
23:25:49 <mwc> look at yi, why extend your app with js whn you can extend it with glorious haskell
23:26:17 <k0ral> because the world has decided this javascript crap will be everywhere
23:26:43 <k0ral> and I don't want to "extend" my app with js
23:27:08 <k0ral> there are just some jobs that can only be performed with js
23:27:15 <mwc> why then do you concern yourself with javascriptcore bindings?
23:27:47 <k0ral> well, giving people the ability to execute custom javascript on for any webpage
23:27:52 <k0ral> -on
23:29:11 <k0ral> but if you have suggestions, I would be glad to hear them
23:29:58 <k0ral> maybe hackage isn't that verbose about the project, projects.haskell.org/hbro would be more relevant, though under construction
23:45:06 * hackagebot simple-sendfile 0.1.0 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.1.0 (KazuYamamoto)
23:55:02 <shaleh> I am trying to get a heap profile from my small app. I have compiled it like so: ghc -O2 -o myapp --make main.hs -prof -auto-all -rtsopts -fforce-recomp. When I run it as './myapp +RTS -hc'  I get a myapp.hp which is not useful data in it -- just lots of zeroes. Same when I use other -h options. What am I missing?
23:55:21 <shaleh> for this app it runs fast enough, I am just trying to learn how the tools work.
23:55:41 <theclaw> hi
23:56:42 <shaleh> DATE "Wed Jun 22 00:22 2011"
23:56:42 <shaleh> SAMPLE_UNIT "seconds"
23:56:42 <shaleh> VALUE_UNIT "bytes"
23:56:42 <shaleh> BEGIN_SAMPLE 0.00
23:56:43 <shaleh> END_SAMPLE 0.00
23:56:43 <shaleh> BEGIN_SAMPLE 0.00
23:56:43 <shaleh> END_SAMPLE 0.00
23:56:54 * mwc smacks shaleh 
23:57:14 <mwc> shaleh: ye gods man, pastebin!
23:57:16 <shaleh> ah bah. the room is quiet and it was 7 lines
23:57:58 <mwc> Don't worry about it, being yelled for spamming 6 lines in an otherwise empty room is an IRC right of passage
23:58:12 <shaleh> (-:
