00:00:42 * frerich2 tries to decide whether the use of return type polymorphism in the regex package is incredibly cool or one of these  funky-but-makes-code-hard-to-read things.
00:03:08 <Eduard_Munteanu> Actually, having a Haskell uzbl-like browser would be neat.
00:03:17 <Eduard_Munteanu> Imagine the customization ;)
00:03:18 * hackagebot hamlet 0.8.2.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.8.2.1 (MichaelSnoyman)
00:04:14 <Eduard_Munteanu> (I mean, like in xmonad)
00:09:02 <cheater_> what?
00:12:39 <Eduard_Munteanu> what what?
00:18:34 <k0ral> Eduard_Munteanu: I'm working on that
00:18:57 <k0ral> it's called hbro
00:19:49 <ivanm> please tell me the name is not in part based upon the cringingly annoying "bro" term used far too often...
00:20:08 <k0ral> bro_wser
00:20:15 <ivanm> *phew*
00:20:19 <Eduard_Munteanu> :)
00:20:32 <Eduard_Munteanu> Good thing we cleared out the name part, that's what mattered :P
00:20:32 <shachaf> ivanm: Don't worry, bro. We don't use that term in this channel.
00:20:40 <ddarius> @fresh
00:20:40 <lambdabot> Haed
00:20:48 <ivanm> @slap shachaf
00:20:48 * lambdabot karate-chops shachaf into two equally sized halves
00:21:02 <Eduard_Munteanu> Heh, I didn't know about that @fresh plugin
00:21:32 <ketil> Isn't 'cabal fetch' supposed to download stuff for me?  Or does it have some other function?  (It refuses to get a library due to incorrect dependencies; I wanted to download the library so I could fix it)
00:22:00 <ivanm> ketil: yeah, but I think it gets all deps as well
00:22:01 <Saizan> ketil: try cabal unpack
00:22:04 <ivanm> so you can install offline, etc.
00:22:12 <ivanm> Saizan: dammit, you beat me to it! :p
00:22:34 <Saizan> cabal fetch --no-dependencies , also
00:22:54 <ketil> Ah, and then it puts it in the current dir, while I was searching under .cabal :-)
00:23:25 <ketil> (and with an old datestamp, so it didn't show up at the bottom of an ls -ltra)
00:23:26 <ketil> :-)
00:24:04 <Saizan> fetch will just download the tarball and leave it under .cabal/packages/... unpack also untars it
00:26:23 * hackagebot egison 0.1.2.2 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-0.1.2.2 (SatoshiEgi)
00:35:56 <ketil> Hm.  New problem: I have installed my own version of a library, and now want to install another which depends on it.  But in spite of the correct version being installed, it refuses, since it still (re)checks the dependencies of the first library.  Any way around that?
00:37:07 <ketil> I guess I can just run 'runhaskell Setup bla bla'
00:37:51 <ivanm> ketil: bump the version of your copy
00:37:59 <ivanm> e.g. add an extra digit to the end
00:50:15 <ivanm> @hoogle (a -> Bool) -> [a] -> Maybe (a, [a])
00:50:16 <lambdabot> No results found
00:50:21 <ivanm> @type find
00:50:23 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
00:50:35 <ivanm> does anyone know of a variant of find that also removes that value from the list?
00:51:00 <mauke> :t delete
00:51:01 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
00:51:09 <mauke> span
00:51:13 <ivanm> mauke: yeah, I could use deleteBy
00:51:25 <ivanm> but I was hoping there would be one already like it somewhere
00:51:58 <ivanm> @pl \p as -> fmap (flip (,) $ deleteBy p as) $ find p as
00:51:59 <lambdabot> ap (ap . ((fmap . flip (,)) .) . deleteBy) find
00:52:27 <ivanm> mauke: though yeah, using span would probably be nicer
01:00:27 * hackagebot egison 0.1.2.3 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-0.1.2.3 (SatoshiEgi)
01:23:29 * hackagebot waitfree 0.1.5 - A wrapping library for waitfree computation.  http://hackage.haskell.org/package/waitfree-0.1.5 (YoichiHirai)
01:33:40 <EnglishGent> hi! I'm trying to get haskell-mode working with emacs under Windows - when I try to start the interpreter I get 'Spawning child process: invalid argument' - does anyone have any ideas? thanks for any help :)
01:41:27 <ivanm> EnglishGent: is ghc installed?
01:41:33 <ivanm> is ghci in your environment Path?
01:41:56 <EnglishGent> hi ivan - yes ghc is installed
01:42:07 <EnglishGent> re: Path - do you mean Path in windows? or something else?
01:42:14 <ivanm> yes, the windows Path
01:42:18 * EnglishGent checks the windows one
01:42:18 <ivanm> I think that's what emacs uses
01:42:58 <EnglishGent> ah - I thought set-haskell-program-name was for specifying the path
01:43:28 <dixie> who uses skytreebird nickname?
01:43:57 <ivanm> EnglishGent: hmmmm, might work
01:44:00 <dixie> Do you know email for him? I would like to send thanks for wxhaskell build documentation PDF :-)
01:44:04 <ivanm> not too sure hwo emacs works under windows though
01:44:13 <ivanm> dixie: it's not in the PDF?
01:44:19 <ivanm> @google wxhaskell pdf
01:44:21 <lambdabot> http://www.haskell.org/haskellwiki/WxHaskell
01:44:21 <lambdabot> Title: WxHaskell - HaskellWiki
01:44:29 <EnglishGent> yes - it's in the path
01:44:32 <EnglishGent> (just checked)
01:44:45 <dixie> ivanm: there is only nickname :(
01:45:03 <ivanm> EnglishGent: can you do M-x term and run ghci ?
01:45:26 <EnglishGent> ah! just fixed it - you must *not* set the full path when setting haskell-program-name
01:45:31 <ivanm> heh
01:45:44 <EnglishGent> but just set it to ghci
01:45:52 <EnglishGent> thanks for your help anyway - it was appreciated!
01:46:04 <EnglishGent> (and it did help! you made me think about the path) :)
01:46:25 <ivanm> no worries ;-)
01:46:51 <ivanm> EnglishGent: I think it defaults to ghci anyway, so you may not even need it at all (unless you want to pass extra parameters)
01:47:30 <EnglishGent> well I might... after all .. ghc has more flags than the United Nations :)
01:49:30 <EnglishGent> (I've just gotten a new job doing C# coding ... and I'm setting up the work machine... I think it says something about me that I regard the top two priorities as 'get emacs working' & 'get haskell working'
01:49:41 <EnglishGent> we'll met to C# / visual studio later :)
01:49:45 <EnglishGent> s/met/get
02:22:44 <ivanm> can anyone think of a better module name{,space} than Data.GraphViz.Types for the different implementation of Dot graphs in graphviz?
02:36:23 <o-_-o> byorgey: Are you around ?
02:38:30 <ivanm> preflex: seen byorgey
02:38:31 <preflex>  byorgey was last seen on #haskell 8 hours, 29 minutes and 35 seconds ago, saying: Iso: nice =)
02:51:13 <sordina> Is there an environment variable or config file I can use to add -L/usr/lib to ghc by default? I've tried setting PATH and LD_LIBRARY_PATH.
02:52:08 <ivanm> sordina: for haskell libs?
02:52:39 <ivanm> or C libs?
02:52:52 <sordina> I believe this is related to cairo.
02:52:55 <sordina> Undefined symbols: _locale_charset
02:53:26 <sordina> If I add -L/usr/lib it works, but without it ghc --make fails.
02:53:41 <scrappy_doo> good morning
02:57:53 <ivanm> sordina: sounds like the cairo lib wasn't built properly to me...
02:58:09 <ivanm> (the Haskell cairo lib that is, if indeed it's due to cairo)
03:00:04 <sordina> ivanm: Why would you suspect that?
03:00:21 <ivanm> because it should know where to find the C libs
03:00:54 <ivanm> ghc-pkg describe cairo
03:01:15 <ivanm> also do a ghc-pkg check to see if there's anything obvious
03:03:01 <sordina> Thanks ivanm. Should there be any particular config option I'm looking for?
03:04:07 <ivanm> umm... the directory listing of include-dirs
03:10:23 <sordina> ivanm: I updated extra-lib-dirs and it worked :D
03:12:38 <sordina> Thanks again!
03:13:15 <ivanm> sordina: updated it in what?
03:27:39 <accel> is one of the authors of RWH teaching a course at stanford next year?
03:29:13 <ivanm> I think bos might be
03:31:38 <damg> is it possible to reexport all identifiers but a few from an imported module? Specifying a hundred of constructors is no fun
03:32:06 <ivanm> don't think it's possible to say "export all constructors except these ones"
03:32:26 <ivanm> just Foo(..) to export all of them
03:33:14 <damg> that's probably what I needed, thank you ivanm
03:54:42 <jaspervdj> preflex: seen chrisdone
03:54:43 <preflex>  chrisdone was last seen on #haskell 2 days, 36 minutes and 39 seconds ago, saying: What's the function equivalent of [a,b…n]?
03:54:53 <jaspervdj> kstt: ^
03:57:25 <o-_-o> preflex: seen byorgey
03:57:26 <preflex>  byorgey was last seen on #haskell 9 hours, 48 minutes and 32 seconds ago, saying: Iso: nice =)
03:57:43 <byorgey> hi o-_-o
03:57:50 <o-_-o> hey byorgey
03:57:56 <byorgey> let's see if we can figure out your compile error
03:58:13 <o-_-o> byorgey: http://hpaste.org/47502/diagramslib_compile_error
03:58:28 <o-_-o> byorgey: sorry to get on your nerves :-)
03:58:33 <byorgey> o-_-o: no worries =)
03:58:47 <byorgey> o-_-o: what versions of diagrams-core and diagrams-lib do you have?
03:58:59 <byorgey> did you get them both from darcs?
03:59:11 <o-_-o> byorgey: Yes
03:59:24 <o-_-o> byorgey: I got them from patch-tag
03:59:36 <byorgey> o-_-o: and have you done a recent 'darcs pull' on both?
04:00:36 <o-_-o> byorgey: I did
04:09:59 <develhevel> what does the . operator do?
04:09:59 <Entroacceptor> @src .
04:09:59 <lambdabot> (f . g) x = f (g x)
04:09:59 <lambdabot> NB: In lambdabot,  (.) = fmap
04:09:59 <develhevel> where is the difference to $?
04:09:59 <Entroacceptor> @src $
04:09:59 <lambdabot> f $ x = f x
04:09:59 <Entroacceptor> the (.) combines two functions
04:10:04 --- topic: '["Paste code/errors: http://hpaste.org", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin and spam issues: #haskell-ops"]'
04:10:04 --- topic: set by monochrom!monokrom@toronto-hs-216-138-220-146.s-ip.magma.ca on [Sat Mar 26 17:29:19 2011]
04:11:49 <wferi> Hi! Is there a way to persuade the text.xhtml package to output UTF-8 encoded strings?
04:12:31 <wferi> I mean, UTF-8 encoded octet sequences, instead of replacing all accented characters with HTML entities?
04:13:53 <develhevel> is therefore a function: (\x y -> [x,y])
04:14:59 <byorgey> develhevel: you just wrote it =)
04:15:11 <byorgey> develhevel: (no, it doesn't already exist in the standard libraries)
04:16:07 <o-_-o> sudo cabal update
04:16:08 <o-_-o> Downloading the latest package list from hackage.haskell.org
04:16:08 <o-_-o> cabal: does not exist
04:16:11 <o-_-o> what is wrong here ?
04:16:18 <o-_-o> I've set the proxy and things
04:17:01 <o-_-o> argh...nevermind
04:17:05 <o-_-o> stupid sudo
04:24:34 <develhevel> have a question aobut a function, i have a list of integers ans a (Int, String) list. now i want to filter all the elements from the [(Int,String)] which fst are in the list of ingeters
04:25:43 <ivanm> @type \ lst -> filter (flip elem lst . fst)
04:25:44 <lambdabot> forall a b. (Eq a) => [a] -> [(a, b)] -> [(a, b)]
04:25:47 <ivanm> develhevel: ^^
04:26:05 <byorgey> ivanm: develhevel hadn't even asked a question yet!
04:26:08 <byorgey> =)
04:26:21 <ivanm> byorgey: yeah, bot sick of waiting!
04:26:22 <ivanm> :p
04:26:45 <ivanm> can anyone think of a better module name{,space} than Data.GraphViz.Types{,.*} for the different implementation of Dot graphs in graphviz?
04:27:31 <hpc> i would have Data.GraphVis.*graphtype*
04:27:49 <ivanm> hpc: I have a class they're all based on...
04:27:50 <hpc> it doesn't really belong in Types unless it really is just data/instances
04:27:52 <develhevel> ivanm: thx
04:28:03 <hpc> ah
04:28:18 <hpc> i suppose it could go either way then
04:28:35 <ivanm> hpc: well, it helps differentiate them from the other modules that way
04:29:31 <develhevel> how can give me a small example with the (.) operator? i know what it is but cant use it
04:29:55 <ivanm> > show . length .  filter even $ [1..10]
04:29:57 <lambdabot>   "5"
04:29:58 <mauke> > map (sqrt . abs) [-3 .. 2]
04:30:00 <lambdabot>   [1.7320508075688772,1.4142135623730951,1.0,0.0,1.0,1.4142135623730951]
04:30:27 <develhevel> which of a . b is executet first?
04:30:42 <ivanm> b
04:30:49 <ivanm> @src (.)
04:30:49 <lambdabot> (f . g) x = f (g x)
04:30:49 <lambdabot> NB: In lambdabot,  (.) = fmap
04:30:55 <ivanm> develhevel: ^^
04:31:03 <mauke> a
04:31:08 <ivanm> so "f . g . h $ x" == f (g (h x))
04:31:27 <ivanm> mauke: in terms of applications on the value I think he means
04:31:33 <ivanm> not in terms of result and evaluation
04:34:44 <hpc> develhevel: suppose you have a calculator program, that evaluates lines as mathematical expressions
04:35:12 <hpc> develhevel: so you read in a line, then you split it into individual tokens, then read the tokens, evaluate the expression, and show it
04:35:45 <hpc> calc = show . evaluate . map read . splitIntoTokens
04:39:08 <develhevel> hpc: okay
04:39:12 <sordina> ivanm: in $HOME/.cabal/config
04:39:40 <ivanm> sordina: huh...
05:11:36 <damjan> I'm trying to build pandoc-1.6, but it fails here http://hpaste.org/47555/building_pandoc_fails
05:54:57 * EnglishGent sees byorgey & waves
05:55:06 * EnglishGent going through the Typeclassopedia at the moment :)
05:55:33 <byorgey> hi EnglishGent =)
05:56:25 <byorgey> EnglishGent: let me know if there are any sections that are confusing, or you have any suggestions for improvement
05:56:33 <byorgey> I'm working on a second edition
05:56:39 <EnglishGent> I will be more than happy to :)
05:57:16 * EnglishGent is putting effort into learning Haskell - I've even convinced a couple of friends to join me in making the effort :)
06:00:51 <byorgey> EnglishGent: awesome, learning something in a group is always more fun =)
06:01:18 <EnglishGent> agreed! :)
06:05:35 <EnglishGent> one observation - I do wish haskell had names for more of the operators - it makes them difficult to talk about when speaking aloud (I'm a novice, maybe it does & I dont know them)
06:06:00 <EnglishGent> like the way we have both 'bind' & '>>='
06:06:36 <EnglishGent> the former is considerably easier to say than 'right angled bracket, right angled bracket, equals"
06:06:38 <EnglishGent> :)
06:07:08 <EnglishGent> (directly relevant to group learning I think)
06:08:26 <sipa> @let plus = (+)
06:08:27 <lambdabot>  <local>:14:0:
06:08:27 <lambdabot>      Multiple declarations of `L.plus'
06:08:27 <lambdabot>      Declared at: <loca...
06:08:31 <sipa> @let adder = (+)
06:08:32 <lambdabot>  Defined.
06:08:37 <sipa> > adder 5 3
06:08:38 <lambdabot>   8
06:09:22 <EnglishGent> hi sipa
06:09:57 <EnglishGent> and yes - I know you could define them - but I meant *standard* names - so I can talk with any Haskell guru & we both know what the other means
06:10:02 <byorgey> EnglishGent: true.  There are different opinions on this issue (some would say "you should not pronounce operators" -- but as you note it is almost impossible to avoid when leaning in a group!)
06:10:23 <ben> Maybe we should take away the syntax to define operators as anything but synonyms for functions with proper names.
06:12:17 <byorgey> operators with standard names that I know of:  >>= "bind",  <$> "fmap",  <*> "ap",  . "dot" or "compose"
06:12:39 <byorgey> and really those are the only ones you need ;-)
06:12:59 <sipa> '$' apply
06:13:15 <ben> '++' doubleplus? ;)
06:13:20 <byorgey> hehe
06:13:20 <sipa> append
06:14:17 <EnglishGent> indeed ben! doubleplus good! :)
06:15:38 * sipa was born that year
06:15:53 <byorgey> > let newspeak = [1,9]; good = [8,4] in newspeak ++ good
06:15:54 <lambdabot>   [1,9,8,4]
06:16:36 <EnglishGent> on a serious note - I think that would be a good idea (taking away syntax to define operators as anything but synonyms) - but that's coming very much from having the novice pov
06:17:17 <ben> I have a novice pov too, I'm a slow learner :)
06:17:33 * byorgey personally does not think that would be a good idea
06:17:56 <Entroacceptor> yeah, makes stuff too verbose
06:17:59 <Entroacceptor> and it
06:18:10 <byorgey> now in addition to learning some operators you have to remember which names correspond to each one in case someone uses the name instead of the operator, or vice versa
06:18:13 <Entroacceptor> 'd be a technical fix to a social (psychological?) problem ;)
06:18:33 <ben> Entroacceptor: Okay, then make it a hlint option :)
06:18:55 <Entroacceptor> (http://avdi.org/devblog/2009/01/30/haskell-operators/ is still one of my favourites)
06:19:18 <Entroacceptor> but TBH, I'm still a total newbie myself, and I don't have problems with learning the operators
06:19:41 <Entroacceptor> but everybody I actually talk to thinks Haskell is stupid, anyway
06:19:59 <EnglishGent> a hlint option sounds good to me - it doesnt break existing code & still helps to address the problem
06:20:05 <ben> I don't have any real-life acquaintances who are interested in talking about haskell operators either, yeah.
06:20:45 <Tomsik> <*> is not a synonym of ap AFAIK
06:20:49 <byorgey> EnglishGent: you can easily define custom hlint suggestions
06:20:52 <Tomsik> <*> is from applicative and ap is from monad
06:21:10 <Tomsik> :t ap
06:21:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
06:21:15 <Tomsik> :t <*>
06:21:16 <lambdabot> parse error on input `<*>'
06:21:20 <Tomsik> :t (<*>)
06:21:21 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
06:21:24 <byorgey> Tomsik: yes, technically it is not a synonym, but I still think <*> ought to be pronounced 'ap' =)
06:21:29 <Entroacceptor> oh, and maybe because of studying physics
06:21:42 <Entroacceptor> you write down formulas, don't talke about them
06:21:43 <byorgey> it is morally a synonym for things which are monads.
06:22:44 <ben> Entroacceptor: Where, if I may ask?
06:22:59 <ben> I'm studying physics in Karlsruhe. I'm not very good at it.
06:23:06 <Entroacceptor> in Hamburg
06:23:09 <Tomsik> I dunno, I've talked quite a bit about all these things to people, but never actually had to pronunce things like <$> <*> ++ or $
06:23:12 <ben> Neat
06:23:52 <Tomsik> It seems that there's always a blackboard around or a wordy explanation is better
06:24:30 <Entroacceptor> always carrying some paper with you helps, too :)
06:24:59 <EnglishGent> not in my case Tomsik - my friends & I have wound up having several discussions on Haskell over the phone
06:25:16 <EnglishGent> at which point the lack of synonyms for operators becomes more problematic :|
06:25:39 <Entroacceptor> EnglishGent: maybe something like Gobby would help?
06:25:51 <Entroacceptor> (multiplayer text-editor)
06:25:52 <ben> I was considering suggesting that :))
06:34:27 <EnglishGent> good idea Entroacceptor :)
06:34:35 <EnglishGent> (gotta go for a bit - rl meetings)
06:34:35 <Entroacceptor> emacs is starting to scare me ;) http://rudel.sourceforge.net/backends.html
06:45:06 <hqm42> Hi! I just tried to cabal install yesod and got the following error:  Yesod/Auth.hs:233:10:     Not in scope: type constructor or class `Message'
06:45:50 <hqm42> while building yesod-auth-0.5.0
06:46:13 <hqm42> what can i do to fix this?
06:48:27 <harlekin> How can I print a &nbsp; character using happstack-heist? Simply typing it produced the escaped variant &amp;nbsp; but I cannot find a way to un-escape it.
06:49:25 <harlekin> I am using the Text.XmlHtml library to generate Heist Splices.
06:55:36 <wjt> around half of the links on http://snapframework.com/docs/ are broken due to the 'docs/' part of the path being replicated. I guess the Yesod folks have a point when it comes to checking links at compile time :)
06:57:41 * hackagebot SVGPath 1.0.3 - Parsing the path command of SVG  http://hackage.haskell.org/package/SVGPath-1.0.3 (TillmannVogt)
07:02:42 * hackagebot collada-types 0.2 - Data exchange between graphic applications  http://hackage.haskell.org/package/collada-types-0.2 (TillmannVogt)
07:04:32 <Cale> wjt: lol
07:05:02 <copumpkin> wjt: nice
07:07:42 * hackagebot collada-output 0.5 - Generate animated 3d objects in COLLADA  http://hackage.haskell.org/package/collada-output-0.5 (TillmannVogt)
07:08:48 <Cale> wjt: It seems to have been fixed :)
07:08:59 <Cale> er, wait, no
07:09:09 <Cale> Weird.
07:09:10 <wjt> Cale: it's to do with whether or not you have a trailing slash on http://snapframework.com/docs/ or not
07:09:16 <Cale> aha
07:09:29 <wjt> Cale: (being discussed on #snapframework)
07:14:44 * hackagebot triangulation 0.2 - triangulation of polygons  http://hackage.haskell.org/package/triangulation-0.2 (TillmannVogt)
07:22:21 <applicative> ghc head has a working -fllvm on OS X, how pleasing
07:23:07 <applicative> the illustrations dons uses on http://donsbot.wordpress.com/2010/02/21/smoking-fast-haskell-code-using-ghcs-new-llvm-codegen/ are even more insanely fast
07:23:36 <applicative> almost as fun as MonadComprehensions !!
07:24:05 <kmc> maybe now people will stop saying that monads are incomprehensible
07:24:56 <applicative> indeed.
07:25:14 <applicative> or maybe, the bracket comprehend them, but we don't
07:25:24 <Axman6> has someone finally written the one true tutorial? :O
07:25:25 <dolio> Is llvm's logo a robot dragon?
07:25:37 <zygoloid> it's a dragon, not a robot
07:25:42 <Axman6> well it's a dragon anyway
07:25:56 <zygoloid> it's a metallic wyvern
07:25:56 <applicative> "The LLVM logo is a stylized wyvern (a kind of dragon)."
07:26:03 <dolio> So it's a dragon robot?
07:26:09 <kmc> jeez guys, how could you not know it's a wyvern
07:26:25 <applicative> never heard of a wyvern, i'd guess they dont exist
07:26:26 <dolio> Are you sure it's not a wyrm?
07:26:47 <kmc> "A wyvern or wivern is a legendary winged reptilian creature with a dragon's head, the hindquarters of a snake or lizard with two legs or none, and a barbed tail. "
07:27:03 * applicative proposes to be the first on the block to use she idiom brackets with monadcomprehensions
07:27:08 <kmc> oh snap
07:27:32 <dolio> Heh, dons is calling it "the shootout." :)
07:27:39 <applicative> i see, sort of a chimera made of imaginary parts
07:27:46 <applicative> whats the shootout
07:28:47 <kmc> http://shootout.alioth.debian.org/ ?
07:29:07 <applicative> is that the one dolio meant?  we all call that a shootout
07:29:16 <kmc> i dunno
07:29:37 <dolio> The guy who runs it doesn't like it to be called a shootout.
07:29:52 <kmc> then he probably shouldn't have picked that domain?
07:29:58 <dolio> Probably.
07:30:15 <osfameron> ;-)
07:31:22 <applicative> whats wrong with a shootout? too violent?
07:31:31 <dolio> I think that's his complaint, yes.
07:31:46 * hackagebot revdectime 0.1.1 - A French revolutionary decimal time (metric) clock  http://hackage.haskell.org/package/revdectime-0.1.1 (KamilStachowski)
07:31:57 <applicative> a peacenik.  i admire that.  i'd rather worry about actual shootouts though
07:32:05 <flux> wellmanneredintellectualdisourceonlanguageimplementationperformance.alioth.debian.org might've worked better.
07:32:07 <applicative> whats this about the French revolution??
07:32:21 <hpc> nobody ever expects the french revolution!
07:32:24 <hpc> wait...
07:32:39 <applicative> it should be TerrorTime
07:33:04 <sipa> Stop! TerrorTime!
07:42:11 <applicative> here's a retarded question: if I am using -fllvm am I likely to get more agreeable results if the libraries I import were also compile by llvm?
07:42:43 <applicative> i guess the answer is, if the libraries were faster with -fllvm, yes, otherwise not
07:43:27 <dolio> What does agreeable mean?
07:44:08 <applicative> i was thinking of speed, but it made no sense I think
07:44:41 <dolio> Yeah, I don't think there's any magic that happens if you link together two llvm-generated things.
07:45:15 <applicative> yeah, that came to me.  i was thinking first about something like whole program compilation
07:45:25 <dolio> You'd probably need to feed llvm both of them together to make something extra happen.
07:45:32 <applicative> if the llvm can see the whole damn mess, maybe it can do better
07:46:15 <applicative> it seems to be kind of brainy.
07:46:20 <zygoloid> to get magic to happen you need llvm ir in the .o files, and then you need to link with a linker (like gold) which can invoke llvm to do lto
07:46:38 <zygoloid> (i have no idea whether ghc is set up to do any of that stuff, though)
07:47:06 <dolio> It'd be cool if it were.
07:47:18 <applicative> what is  lto ? pardon ignorance of linking etc
07:47:23 <zygoloid> link-time optimization
07:47:52 <applicative> i see.  what is ir, the stuff it goes by to optimize linking?
07:48:24 <dolio> Intermediate representation.
07:49:38 <applicative> so it can look at that and rethink what it compiled, so to speak, in connection with what's in the new thing its linking
07:50:10 <iwtu> Hi. I need a little help. I have the following task. make function which takes list of numbers and a number and returns aritmethic expression that evalutes to the given number. In aritmethic expression is consist of some subset or permutaion byt the given list. I know how to generate permutanions and subsets but I have the trouble to connect it together
07:50:44 <dolio> Yes. I actually can't say I've seen that before.
07:50:46 <applicative> I take it that things like the {-# INLINE f #-} involves leaving code that only the ghc can understand in the library?
07:50:49 <iwtu> this litte help :)
07:51:08 <dolio> That's not a bad idea for some hybrid between separate compilation and whole-program optimization.
07:51:33 <Tomsik> @where MaybeT
07:51:34 <lambdabot> I know nothing about maybet.
07:51:51 <benmachine> Tomsik: MaybeT is in transformers, I think
07:52:01 <dolio> Yes, inline pragmas put something GHC can work with in the .hi files, I believe.
07:52:04 <benmachine> (plus there are separate but now largely redundant packages for it now)
07:52:16 <applicative> iwtu clever problem.
07:52:32 <dolio> So that when it compiles modules depending on other modules, it can pull in the definitions.
07:52:35 <applicative> Its in the .hi files of course
07:53:19 <dolio> I guess there's really no GHC link time where it could go the extra mile.
07:53:28 <dolio> By the time you link, you're probably at the llvm level.
07:54:16 <Tomsik> I've got f :: a -> IO b and x :: Maybe a is there a pointfree way to get IO (Maybe b) ?
07:54:26 <Tomsik> I can't seem to get the types to work
07:54:50 <applicative> zygloid, does ld or whatever do anything like that for C code, what golden does?
07:55:40 <applicative> well, maybe -fllvm will incline me to figure this out, all of it obvious to better educated people, no doubt
07:56:26 <applicative> iwtu, what operations can you use? + = * ?
07:56:34 <applicative> + - * rather
07:56:57 <zygoloid> applicative: if you build using clang or llvm-gcc or dragonegg, and use -flto or -O4 or -whopr, and link with one of those flags, and use gold, and have the llvm plugin, then you get whole-program optimization for C :)
07:57:03 <applicative> iwtu: or rather iwtu
07:57:51 <applicative> i see. but it doesn't have to rewrite the previously linked files?
07:58:01 <zygoloid> (alternatively, build using a suitably-recent g++ under similar circumstances)
07:58:01 <applicative> the previosly compiled files, I mean
07:58:26 <scree> :t Data.Traversable.mapM
07:58:27 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
07:58:32 <iwtu> applicative: yes. The operators are + - *
07:58:34 <scree> Tomsik: ^^^
07:58:40 <zygoloid> i don't understand the question :) which 'it' and which previously linked files?
07:59:07 <iwtu> applicative: But I suppose the operators are not big deal
07:59:24 <scree> > let { f x = return (x + 1); y = Just 4 } in mapM f y
07:59:25 <lambdabot>   Couldn't match expected type `[a]'
07:59:25 <lambdabot>         against inferred type `Data.Mayb...
07:59:30 <Tomsik> Thanks!
07:59:37 <scree> > let { f x = return (x + 1); y = Just 4 } in Data.Traversable.mapM f y
07:59:38 <lambdabot>   No instance for (GHC.Show.Show (m (Data.Maybe.Maybe a)))
07:59:38 <lambdabot>    arising from a ...
07:59:38 <applicative> zygloid, I just meant, I might have been compiling things all week, now I compiles something new that uses the old libraries,
07:59:50 <Nibble> hello
08:00:03 <iwtu> Nibble: hello :)
08:00:22 <scree> actually, lambdabot won't like the IO type so I'll give up on trying to make that work
08:00:23 <Nibble> is this tail-call-optimized? f x = f (x-1) + f (x-2) I think not
08:00:40 <yrlnry> It can't be, because there is no tail call.
08:00:42 <kmc> it doesn't have a tail call
08:00:58 <kmc> well, the call to (+) is a tail call
08:01:06 <kmc> but that's probably not what you meant
08:01:07 <flux> wouldn't the compiler be permitted to rewrite it into one?
08:01:13 <kmc> how?
08:01:17 <Tomsik> scree: well, it worked in ghci, so it's okay :)
08:01:17 <yrlnry> A tail call is when the last thing a function does before returning is to call some other function (perhaps itself) and return the return value of that function.
08:01:20 <flux> it could add an accumulator for an internal function
08:01:26 <flux> because it's just summing numbers
08:01:28 <erus`> > map (+5) [1..5]
08:01:29 <lambdabot>   [6,7,8,9,10]
08:01:40 <kmc> flux, sure, but that would be a deep optimization
08:01:44 <phao> Hey, in haskell, you create new objects instead of keep modifying existing ones. Doesn't that make programs slower?
08:01:47 <scree> Tomsik: yes, in the second one Lambdabot was just complaining it didn't know which monad to use
08:02:05 <kmc> phao, sometimes.  but do note that the new objects are mostly made of pointers back into the old ones
08:02:10 <erus`> >let f(x) = x * x - 1 in map x [1..10]
08:02:12 <Nibble> phao: is some cases yes, but the nature of haskell allows some optimizations
08:02:16 <Nibble> ^what kmc said
08:02:18 <erus`> >let f(x) = x * x - 1 in map f [1..10]
08:02:21 <erus`> > let f(x) = x * x - 1 in map f [1..10]
08:02:21 <lambdabot>   [0,3,8,15,24,35,48,63,80,99]
08:02:25 <kmc> i could also say "in C/Java/whatever you deep-copy objects because they might mutate.  doesn't that make programs slower"
08:02:31 <applicative> iwtu: somehow the obvious starting point is a data type  data Expr a = Lit a | Plus (Expr a)  (Expr a)  | Times (Expr a)  (Expr a) | ... then an interpreter.  But one needs another control for searching
08:02:35 <kmc> phao, also, there are plenty of ways to use mutable state in Haskell if you need it
08:02:36 <zygoloid> phao: haskell implementations have /very very fast/ memory allocation
08:02:42 <dolio> How is it going to rewrite a function that branches into two paths at each point into an accumulator?
08:03:13 <dolio> Other than realizing that one path is going to contain the other, which is very non-trivial.
08:03:28 <yrlnry> You can put half the branches into an accumulation without a lot of cleverness.
08:03:34 <Nibble> well, then how can I parallise it?
08:03:35 <phao> kmc, yes, you need deep copy, but if you needed a deep copy in haskell, it'd be as fast/slow
08:03:46 <Nibble> that should be easy since they are not dependant of each other
08:03:59 <phao> kmc, I was talking about the practice of creating a lot of intermediate objects that will be throwed away
08:04:08 <scree> any optimization to a single loop requires knowledge of the structure of the integers
08:04:25 <iwtu> applicative: thanks I didn't realize that. Make a new data type sounds like really good start point. Thanks :)
08:04:29 <kmc> but you don't need to copy as much, if you are not modifying values in place
08:04:45 <applicative> phao, when you 'create' 1 : oldlist, you just make a pair of a cell for 1 and a pointer to oldlist
08:04:48 <kmc> which is a matter of style, not language, but it's a style Haskell heavily favors and most other languages discourage
08:05:01 <kmc> indeed, that's why you can say "let xs = 1 : xs"; it makes a cell with a pointer to itself
08:05:18 <kmc> phao, GHC has a generational garbage collector for this reason
08:06:00 <kmc> and heap allocation is just a matter of incrementing a pointer.  nowhere near as expensive as typical malloc()
08:06:01 <iwtu> applicative: may I ask? what is Lit in that Expr?
08:06:12 <phao> right
08:06:25 <phao> I don't understand garbage collection
08:06:29 <phao> but thanks
08:06:41 <applicative> iwtu, it is just the representation of 1 2 3.  It could be Int, actually.
08:06:52 <phao> last question... why you said that copying is needed more often when you're modifying objects?
08:06:55 <iwtu> applicative: thanks. It has supprised me you understand my basic English :)
08:07:05 <kmc> phao, someone might need the old value still
08:07:08 <kmc> especially in a concurrent setting
08:07:13 <applicative> iwtu: i hadn't noticed anything odd about your English
08:07:18 <benmachine> phao: also, deforestation can reduce copying
08:07:18 <phao> ok
08:07:20 <kmc> pure functional datastructures are *fantastic* for concurrent programming
08:07:45 <kmc> that's why clojure favors them, even though the language overall allows unrestricted side effects
08:08:44 <phao> I thought of some ways that functional programming could go very well concurrent programming
08:08:45 <adnam> T_T error report says ghc kernel panicking me
08:08:48 <phao> but I never did concurrent programming
08:08:59 <adnam> wow, what grammar
08:09:06 <kmc> fp also goes great with parallel-but-not-concurrent programming
08:09:07 <applicative> phao, as benmachine says, often none of these structures are built anyway. a long chain of functions from As to Bs to Cs to Bs can often dispense with the actual construction of a B or a C
08:09:12 <Axman6> phao: it's very easy in haskell
08:09:17 <kmc> that is, evaluation on multiple cores, without explicitly mucking with threads
08:09:22 <iwtu> applicative: so the number I suppose. I didn't know what preposition I should use after verb evaluate :)
08:10:05 <benmachine> iwtu: incidentally, have you heard of RPN? I think it might make your expression-evaluation problem easier
08:10:18 <phao> kmc, I did some stuff with parallel programming in scheme, but very ltitle
08:10:28 <phao> I like scheme a lot, and I pretty much done only fp code in it
08:11:05 <applicative> iwtu: Oh, I know why I started with Expr a = Lit a | Plus (Expr a) (Expr a) ... rather than Expr = Lit Int | Plus Expr Expr | ...
08:11:33 <iwtu> benmachine: yes I heard about RPN. good point :)
08:11:58 <benmachine> applicative: surely you mean Integer :P
08:12:11 <iwtu> applicative: are you native english speaker if I may ask?
08:12:12 <applicative> iwtu: I was thinking you would use some random representation of variables sort of like data Variable = X | Y | Z | W and then interpret an Expr Variable with a map
08:12:19 <applicative> iwtu: yes
08:12:34 <dolio> Does it make it easier?
08:13:37 <applicative> iwtu, if the numbers are big you should use Integer, Int is the machine 'integers'
08:13:44 <applicative> > maxBound :: Int
08:13:45 <lambdabot>   9223372036854775807
08:14:26 <iwtu> applicative: so it is a really good news for my english. thanks for encougraging me :) Thanks. Numbers are good for Int.
08:14:56 <applicative> > maxBound :: Integer
08:14:57 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
08:14:57 <lambdabot>    arising from...
08:15:08 <applicative> ^^^ no maximum for Integers
08:15:09 <dolio> > maxBound :: Int32
08:15:10 <lambdabot>   2147483647
08:16:01 <iwtu> applicative: I am not quite sure why I need teh variable data type
08:16:19 <applicative> iwtu, making a data type representing a grammar for Plus Minus, etc.is  easy, and then an evaluator function, but there are other pieces of your problem that might need more
08:16:35 <iwtu> and constructors... I know data type constructors. Does Haskell have any others constructors?
08:17:13 <applicative> no, sometimes we speak of the name of a type as a type constructor, e.g Maybe a = Just a | Nothing
08:17:35 <applicative> Just and Nothing are data constructors, Maybe a type constructor, I think that's the lingo.
08:18:56 <iwtu> applicative: so no other constructors?
08:19:04 <Nibble> is there a hackage package that allows me to check if number is prime?
08:19:14 <applicative> iwtu: it's part of the problem that each of the numbers you are given can only be used once
08:19:35 <applicative> iwtu:  I don't think the word "constructor" is used in any other way but those
08:20:40 <parcs> Nibble: 'primes', perhaps
08:21:08 <iwtu> applicative: sure, the one number from list can be use just once. because constructor is well know word from OOP
08:21:41 <iwtu> applicative: thanks for ensure
08:22:06 <applicative> i don't know any oop language besides javascript but for us a constructor is somethiing arising in a type definition.
08:22:29 <applicative> data Moo = Baah | Woof | Quack Int
08:23:01 <Nimatek> That's totally different from what is meant by 'constructor' in OOP.
08:23:01 <applicative> every Moo is constructed by Baah or Woof or by completing Quack with an Int
08:23:28 <iwtu> applicative: my second idea was I had build a aritmethic tree. Thanks for advice. I'll make a decision :)
08:24:06 <applicative> iwtu, yes, the data type I was imagining is a tree type.  the constructors Plus Minus Times make then nodes
08:24:55 * hackagebot SVGFonts 0.4 - Fonts from the SVG-Font format  http://hackage.haskell.org/package/SVGFonts-0.4 (TillmannVogt)
08:24:58 <applicative> iwtu: the problem will be to find all the trees that have leaves from a given class
08:25:32 <scrappy_doo> good morning
08:25:46 <iwtu> applicative: so I have to generate all possible trees from all possible subsets
08:25:52 <applicative> good morning scrappy_doo, what are your intended and expected types
08:26:30 <applicative> iwtu right so we need some further idea
08:27:02 <scrappy_doo> applicative expected is WorkingCode, actual is AnnoyingPITB
08:27:38 <applicative> scrappy_doo: put it on hpaste.org and our brainy friends will tell you whats wrong
08:28:01 <kmc> applicative, i like the idea of "what are your intended and expected types" as a generic greeting
08:28:03 <kmc> for people on the street and such
08:28:20 <iwtu> applicative: I will try it by myself. I will let you know in case of big problems :)
08:28:49 <Nibble> hmm
08:28:54 <Nibble> there must be a better way to do this
08:29:13 <applicative> NIbble, to test form 'primality'?
08:29:26 <applicative> for primality
08:29:26 <Nibble> applicative: no
08:29:45 <Nibble> an algorithm, it looks a lot like fibonacci's sequence
08:29:49 <scrappy_doo> I want to catch a SomeException but exclude one or more types (in this case UserInterrupt) from (some) processing.
08:29:50 <applicative> iwtu: good luck
08:30:37 <iwtu> applicative: good luck too :)
08:31:55 <Nibble> and it is fibonacci's sequence
08:32:03 <Nibble> this makes it a whole lot easier
08:33:20 <Feuerbach> scrappy_doo: try to cast it to UserInterrupt, and if it succeeds (returns 'Just'), do nothing
08:34:25 <applicative> Nibble, I am a very skillful haskeller, and can help you implement this sequence :)
08:36:06 <Nibble> applicative: no need, someone already did
08:36:30 <Nibble> applicative: I should have recognized it before... fibonacci's sequence... it is the definition of it
08:36:35 <Nibble> which means, hackage has it
08:36:54 <Nibble> instead of taking about 4h to calculate it on this machine, it now took something like 0.00001 sec
08:37:39 <Nibble> now I need a way to find the middle element in a list
08:37:46 <Nibble> (if there are two, both of them)
08:40:35 <benmachine> I got the fibonacci sequence as an interview question once
08:40:45 <benmachine> I showed them the scanl one and they were all, wat
08:40:45 <benmachine> good times
08:41:04 <applicative> @type scanl
08:41:05 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
08:41:47 <Cale> > fix ((0:) . scanl (+) 1)
08:41:48 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:42:06 <kmc> haha
08:42:13 <applicative> lets break that down a bit...
08:42:28 <monochrom> see my http://www.vex.net/~trebla/haskell/scanl.xhtml for more
08:42:52 <applicative> > let fibs = 0 : scanl (+) 1 fibs in fib
08:42:52 <lambdabot>   Not in scope: `fib'
08:42:53 <applicative> > let fibs = 0 : scanl (+) 1 fibs in fibs
08:42:54 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:46:06 <applicative> that's one lazy fibs list
08:46:39 <applicative> what is the best way for Nibble to find the middle member(s) of a list? the obvious one seems cludgy
08:48:15 <Nibble> applicative: splitAt (length `div` 2) xs and some magic involving putting em together
08:48:28 <Nibble> but that must be the cludgy way XD
08:48:35 <ziman> what's the difference between Data.Array(.Unboxed) and Data.Vector(.Unboxed)? When should I pick which of the two?
08:48:53 <ziman> are there any guidelines?
08:49:07 <jmcarthur> ziman: Array allows you to index with any instance of Ix. Vector has fusion.
08:49:21 <jmcarthur> ziman: Vector also has a much richer library
08:49:42 <isomorphic> Nibble: i've seen people do that sort of thing with tails - it looks clean, but obviously you depend on the optimizer
08:49:58 <jmcarthur> ziman: So, if you are just going to be using Int indices, I would almost always go with Vector.
08:50:24 <jmcarthur> ziman: And if the only reason you are considering Array is for multidimensional arrays, maybe consider Repa (but it's newer and potentially confusing, so that choice is up to you).
08:51:51 <ziman> I see, thanks. I want to create a pixmap and perform statistical operations on it so I'll go with Vector.
08:52:50 <applicative> > let middle xs = case (length xs `quotRem` 2) of (n, 1) -> [xs !! n] ; (n, _) -> [xs !! n - 1, xs !! n] in middle [1,2,3,4,5,6]
08:52:50 <lambdabot>   [3,4]
08:53:53 <Nibble> applicative: honestly, that almost looks worse than my version
08:54:00 <Nibble> but it is shorter
08:54:14 <applicative> yeah, its the kludgy one i meant.  i see how tails might improve it
08:54:41 <isomorphic> applicative: actually, I misread the question - so ignore tails for my part :P
08:55:23 * isomorphic wonders whether haskell pattern matching can be done in a 'greedy' way
08:57:59 * hackagebot jmacro 0.5.1 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.5.1 (GershomBazerman)
08:58:51 <Nibble> but really, I don't see why there isn't a library function for this
09:01:07 <scrappy_doo> Feuerbach thanks
09:14:22 <isomorphic> Nibble: how about something like(iterate (tail . init)) [1,2,3]
09:14:40 <isomorphic> I haven't sorted out the types, but I'm trying stuff like
09:15:03 <isomorphic> until (\x -> length x < 3) (iterate (tail . init)) [1,2,3]
09:15:36 <Nibble> isomorphic: im not sure, but that method would be interesting since it is a lot cleaner
09:16:13 <isomorphic> yeah, it's just my lack of familiarity with types that's the issue :/
09:16:18 <ClaudiusMaximus> wow, some 70% of the time taken by my code to test  (read . show = id)  for my libqd bindings is taken up by fromRational
09:16:25 <isomorphic> I've got a type [[a]] coming out of iterate
09:16:45 <isomorphic> I need to get the one that's got a length strictly less than 3
09:17:45 <isomorphic> > filter (\x -> length x < 3) (iterate (tail . init) [1,2,3])
09:17:46 <lambdabot>   [[2]*Exception: Prelude.tail: empty list
09:17:50 <isomorphic> (sort of)
09:18:12 <isomorphic> happy with it terminating with an exception if it prints the result ;)
09:19:39 <zygoloid> > let mid xs = go xs xs where go xs [] = take 2 xs; go (x:xs) [_] = [x]; go (x:xs) (_:_:ys) = go xs ys in (mid [], mid [1], mid [1,2], mid [1,2,3], mid [1,2,3,4], mid [1..100])
09:19:39 <lambdabot>   ([],[1],[2],[2],[3,4],[51,52])
09:20:23 <benmachine> zygoloid: I was thinking something like that
09:20:25 <benmachine> it's cute
09:20:27 <benmachine> is it a foldr? :P
09:20:36 <lunaris> Abusing the semantics of drop over tail, I got:
09:20:40 <lunaris> last $ takeWhile (not . null) $ iterate (drop 1 . init) [1..11]
09:20:43 <lunaris> > last $ takeWhile (not . null) $ iterate (drop 1 . init) [1..11]
09:20:44 <lambdabot>   [6]
09:20:47 <lunaris> > last $ takeWhile (not . null) $ iterate (drop 1 . init) [1..12]
09:20:49 <lambdabot>   [6,7]
09:20:55 <benmachine> init is slow though, isn't it?
09:20:58 <zygoloid> are these init-based approaches not O(n^2)?
09:21:10 <lunaris> I wasn't going for efficiency sorry :)
09:21:18 <lunaris> Also
09:21:27 <lunaris> takeWhile/iterate becomes an unfoldr doesn't it?
09:21:29 <lunaris> *Stares*
09:21:42 <zygoloid> > last $ takeWhile (not . null) $ iterate (drop 1 . init) [1..1000000]
09:21:46 <lambdabot>   mueval-core: Time limit exceeded
09:21:50 <KirinDave> So this is finding the median of a list?
09:22:01 <KirinDave> Or just the middle?
09:22:07 <zygoloid> > let mid xs = go xs xs where go xs [] = take 2 xs; go (x:xs) [_] = [x]; go (x:xs) (_:_:ys) = go xs ys in mid [1..1000000]
09:22:08 <lambdabot>   [500001,500002]
09:22:49 <dmwit> > until (\xs -> case xs of [_,_] -> True; [_] -> True; _ -> False) (tail . init) [1..10]
09:22:51 <lambdabot>   [5,6]
09:22:58 <lunaris> zygoloid: Thanks for crushing me :P
09:23:34 <zygoloid> lunaris: sorry :)
09:24:06 <zygoloid> since you need to retain O(n) elements anyway, length and (!!) doesn't seem so bad
09:24:15 <lunaris> Indeed.
09:24:59 <shapeless> Is there a way to create stand-alone graphical executables on windows with haskell that just consist of one .exe-file? Because all the GUI-bindings demand their corrsponding runtime. I know the win32-package, but it is crappy and not well documented. Is there a way to get around this?
09:27:10 <mightybyte> :t (fmap .) . (. const)
09:27:11 <lambdabot> forall a b (f :: * -> *) a1 b1. (Functor f) => ((b1 -> a1) -> a -> b) -> a1 -> f a -> f b
09:28:23 <sm> shapeless: you should be able to compile a single static executable that contains gtk or wx or opengl(ut), I would think
09:29:18 <shapeless> sm: so you think it is possible to wrap all dlls and runtime files into a single file? How is that done?
09:29:31 <sm> it's more or less the default, with ghc
09:30:24 <shapeless> sm: yeah? I was not aware of this. Are there certain options that have to be set?
09:30:51 <Eduard_Munteanu> shapeless: you could just distribute the .dlls it needs next to the .exe
09:30:58 <Eduard_Munteanu> shapeless: -static
09:30:59 <sm> I mean, the libs part. Runtime files are handled in one of several ways
09:31:38 <sm> if you really need a single.exe, the file-embed package may be useful
09:31:53 <shapeless> Eduard_Munteanu: The point is not having to distribute other files.
09:32:18 <Eduard_Munteanu> Yeah, -static is default anyway I think
09:32:33 <Eduard_Munteanu> But only does it for Haskell libs.
09:33:45 <sm> have you looked at existing haskell gtk apps, like leksah ? do they all come bundled with a separate gtk dll ?
09:35:20 <Nibble> Solution: Install linux
09:36:20 <sm> not very useful if you'd like to sell a game made in haskell Nibble
09:36:25 <monochrom> the antitrust lawsuit against microsoft should have required windows to bundle with gtk dll :)
09:37:17 <dolio> Run linux in your web browser using a javascript emulator.
09:38:29 <ion> > let mid xs = snd $ foldl' (\acc x -> case acc of (ys, [a,b]) -> (ys, [b]); ((y:ys), as) -> (ys, as++[y])) (xs, []) xs in mid [0..99999]
09:38:30 <lambdabot>   [49999,50000]
09:39:12 <shapeless> sm: I believe that they are using the .nsi from http://code.haskell.org/leksah/leksah/win32/leksah.nsi that states that gtk gets copied into the installation directory. For me this is no option.
09:39:22 <shapeless> and i wont use linux ;)
09:41:08 <shapeless> ok, my search will go on. Thank you guys. I will have to stick with java ;(
09:42:45 <Twey> shapeless: Haha, Java
09:43:26 <sm> shapeless: what about file-embed that I mentioned
09:44:45 <sm> as a last resort you could have your exe extract the necessary gui lib files so it (or a spawned process) can run
09:45:02 <shapeless> sm: I do see the use in embedding files that will be needed at runtime and will be requested by the program, but this is no way to "inline" dlls so windows will find them when trying to load.
09:45:28 <shapeless> sm: you were faster. Of course, but that feels over complicated.
09:45:47 <earthy> windows feels overcomplicated.
09:46:03 <sm> yeah. But some such cost might be worth the benefit of using haskell
09:46:27 <shapeless> sm: probably not ;(
09:47:02 <Nimatek> If you like Java, move on to Scala.
09:48:33 <shapeless> Nimatek: Of course, Scala is great. But it is not widely supported. My teammates will not be able to support is, they have no FP background.
09:48:51 <Nimatek> shapeless: And Haskell is?
09:49:21 <shapeless> Nimatek: from college?
09:49:28 <Twey> earthy: Windows is overcomplicated
09:49:57 <sm> "Do not attempt to statically link those Gtk dlls with your .exe to make a single movable .exe. That's not how it works, Gtk+ expects to be able to dynamically load some dlls like themes and bitmap decoders and in any case Gtk+ needs a few other data files."
09:50:03 <benmachine> Twey: as is life in general
09:50:29 <Twey> shapeless: I would be surprised if a Uni Haskell course taught enough to actually be able to use the language in the real world.
09:50:37 <shapeless> sm: i have read this too, its from the mailing list, isnt it?
09:50:44 <Nimatek> shapeless: You said your teammates have no FP background.. but they know Haskell?
09:50:51 <shapeless> Twey: Why not?
09:50:51 <sm> yes
09:50:59 <sm> in 2009, at least
09:51:14 <shapeless> Nimatek: Broken parts that could be stuck together, I believe ;)
09:51:27 <Nimatek> shapeless: Ah :)
09:51:54 <Twey> shapeless: Because uni Haskell courses tend to a) be rather short, b) cover only the very basics and treat it like something horrifically complicated, and c) be several years out of date
09:51:57 <sm> if you're serious, it's well worth asking the gtk and wx maintainers.. there are a few wizards out there doing surprising things with gui apps now and then
09:52:07 <Twey> … actually, s/Haskell //
09:52:48 <Twey> But Haskell worse than most, as it tends to be a single ‘Functional Programming’ (or worse, ‘Other Programming Languages’) module in a larger CS course
09:53:05 <sm> shapeless: can I ask why a zipped set of files is no good ? just curious
09:53:13 <benmachine> my cambridge CS friends tend to whine about the amount of ML they get made to do
09:53:16 <benmachine> loooosers
09:53:31 <Nibble> benmachine: you got friends? :O
09:53:39 <benmachine> ...touché
09:54:18 <sm> shapeless: it does appear to be possible with opengl(ut),
09:54:45 <ziman> If I enable profiling for libraries in ~/.cabal/config, will profiling be disabled in builds not using ghc -prof ?
09:54:52 <shapeless> sm: Because the ones that will use that have three brain modes: eat, sleep, work. If something can go wrong, it will.
09:55:17 <sm> gotcha
09:55:51 <dcoutts> ziman: you will get profiling libs in addition to normal ones
09:56:12 <ziman> dcoutts, thanks much!
10:01:45 <shapeless> sm: indeed, but gl does not provides more than pixels and lines, does it? Everyone tells that there are so many libs on hackage, just not the one I need. (but therefor 7 json parsers)
10:03:22 <sm> I've heard talk of opengl-based widgety libs
10:03:44 <sm> I wasn't sure how much widgetry your app needs
10:06:19 * hackagebot bash 0.1.3 - Bash generation library.  http://hackage.haskell.org/package/bash-0.1.3 (JasonDusek)
10:07:57 <Eduard_Munteanu> Hm, any stuff that goes nicely with Hakyll you'd recommend?
10:08:30 * Eduard_Munteanu is feeling lazy about writing the CSS and designing all that stuff.
10:09:57 <sm> shapeless: my last desperate try, I think. How about a rich web gui served by your app.
10:10:45 <sm> embedded in an app frame with http://hackage.haskell.org/package/wai-handler-webkit or, assuming that's too non-standard (seems likely), launching in the browser with http://hackage.haskell.org/package/wai-handler-launch
10:11:29 <sm> that's the route I've gone
10:11:46 <Eduard_Munteanu> Hm, Blaze looks interesting.
10:11:53 <shapeless> sm: Its something I ever wanted to do, but all solutions sound like overkill. I hoped for an *easy* way. But the package seems interesting. Nice to know.
10:13:19 <sm> I wish it was easier too.
10:13:35 <sm> Eduard_Munteanu: you might be able to use hamlet/lucius/julius/cassius with hakyll
10:14:10 <Eduard_Munteanu> Heh @ those names :)
10:16:37 <Eduard_Munteanu> I'm more interested in setting up a layout for the page though.
10:16:47 <Eduard_Munteanu> I intend to write the actual content in something like LaTeX.
10:17:00 <shapeless> what about markdown?
10:17:04 <sm> ah.. couldn't you steal a layout from cssgarden or something
10:17:25 <Eduard_Munteanu> Yeah, or Markdown, but texified pages sound interesting.
10:17:29 * monochrom doesn't see how a java program requires less third-party runtime than a gtk program
10:18:05 <Eduard_Munteanu> sm: I'll probably do that to get started but it's no fun :)
10:18:25 <sm> I think pandoc's markdown allows embedded LaTeX
10:18:55 <wyfrn> hey everybody ... is there a way in HDBC to auto commit a query?
10:21:29 <Eduard_Munteanu> BlueprintCSS looks interesting. Any thoughts?
10:21:40 <Eduard_Munteanu> There's a binding on Hackage.
10:23:00 <kevinqcs> http://hpaste.org/47562/binary_mode_and_text_mode, anybody please help me with this?
10:23:30 <kevinqcs> I'm confused why openBinaryFile works, and openFile fais.
10:24:31 <shapeless> Eduardo_Muntenanu; blueprint is nice for typography or grids, but in my opinion not better or easier than css. Of course, that depends on your requirements.
10:25:00 <monochrom> because openFile treats string as real unicode text and does encoding
10:25:17 <Eduard_Munteanu> shapeless: nah, I'm just putting together a blog.
10:25:24 <Eduard_Munteanu> On Github.
10:25:26 <Guest_> hey
10:25:35 <Eduard_Munteanu> Guest_: hi
10:26:10 <kevinqcs> monochrom: I don't quite understand.
10:26:20 <shapeless> Eduardo_Munteanu: I believe that css and html still is more simple.
10:26:26 <monochrom> do you know what is unicode?
10:26:30 <kevinqcs> monochrom:  you mean encoding like unicode ?
10:26:50 <kevinqcs> I know unicode, but I thought haskell doesn't deal with unicode.
10:26:54 <Guest_> could somebody help me with some basic haskell?
10:27:14 <Eduard_Munteanu> Guest_: not if you don't ask :)
10:27:30 <Guest_> :)
10:27:35 <kevinqcs> if I read a file containing some unicode character, then all it prints is some "\" string
10:27:41 <Eduard_Munteanu> Usually on IRC you ask the question upfront, you're not interrupting or anything :)
10:27:49 <Guest_> ah okay :)
10:28:20 <xkb> hi
10:29:29 <byorgey> hi xkb
10:29:45 <monochrom> I guess I'll just refer you to http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/System-IO.html#g:23
10:30:09 <Guest_> I'm a beginner at Haskell and I was just trying to write a function to do powers, e.g. power 2 4 = 16, here's what I got (which works):   power bas pow iniBas = if pow == 0 	then 1   	else bas * (power (iniBas) (pow-1) iniBas).             Is there a way to do this without having a parameter for the initial base?
10:30:18 <kevinqcs> monochrom: Thanks, I'll check that.
10:30:54 <shapeless> Guest_: power 1 bas = bas
10:31:21 <xkb> I was checking out hs-twitter, and I was wondering how that callback mechanism works
10:31:36 <xkb> using the setUpdateInterval function
10:31:49 <byorgey> Guest_: what is the iniBas parameter for?
10:31:50 <Guest_> shapeless: not sure what you mean
10:31:54 <xkb> I want to feed the output of a twitter stream to a websocket
10:32:02 <byorgey> Guest_: it does not seem to be used, I think if you just take it out it will still work
10:32:44 <byorgey> shapeless: Guest_'s base case seems fine to me
10:32:59 <shapeless> byorgey: yes, i was mistaken
10:33:47 <Eliel> is there an ECDSA haskell implementation hidden somewhere? I can't seem to find one.
10:33:50 <Guest_> byorgey: you're right, it works without it hehe
10:33:51 <lpsmith> guest:  iniBas never changes,  and therefore bas never changes in your recursive step,  except for maybe the first step
10:34:21 <SyntaxNinja> Simon Peyton Jones and Simon Marlow receive SIGPLAN Programming Languages Software Award for their work on GHC!  http://bit.ly/kcYqaG
10:34:23 <SyntaxNinja> :)
10:34:59 <lpsmith> byorgey: both bas and iniBas are used, but not in a very interesting way.   If you have the initial condition that bas = iniBas,  they are duplicated variables.
10:35:13 <shapeless> Guest_: bas == iniBas, just drop it and substitute iniBas with bas.
10:35:18 <Guest_> ah, i think i might have been thinking that bas itself was changing, before i found this way to do it
10:35:21 <byorgey> lpsmith: right, that's what I meant.
10:35:36 <Eduard_Munteanu> x^0 = 1    x^n = x * x^(n-1)
10:35:56 <Guest_> thanks guys :)
10:35:58 <byorgey> Guest_: yes, there is another style where you pass along an extra parameter which is "accumulating" the answer, and at the end you just return it.
10:36:07 <byorgey> Guest_: but the way you have done it is preferred.
10:36:24 <Guest_> byorgey: that's what i tried first, i think the iniBase was left over from that :D
10:36:34 <byorgey> Guest_: right, makes sense =)
10:36:34 <Eduard_Munteanu> In any case, when in doubt, you could define a helper function that takes any extra parameters you need.
10:37:05 <Eduard_Munteanu> And the actual function calls (having the desired number of params) that helper.
10:37:07 <Guest_> Eduard_Munteanu: a helper function?
10:37:17 <Eduard_Munteanu> You don't need it here.
10:38:41 <Eduard_Munteanu> I mean something like   f n = f' n 0    where f' n k = ...     when you really need some initialization.
10:39:14 <Eduard_Munteanu> (for example)
10:39:36 <Guest_> ah okay
10:43:25 <Lemmih> Eliel: A binding to crypto++ would be nice.
10:53:49 <shapeless> What do I do when I get a panic error from ghci but the error is not reproducible?
10:54:59 <Cale> shapeless|afk: Delete your temporary files. *.hi *.o
10:55:31 <shapeless|afk> Cale: I just opened and closed it while missing some keys on the keyboard.
10:56:24 <shapeless|afk> Oh, i can reproduce it, sorry.
10:57:18 <c_wraith> heh.  If it hasn't yet been posted here:  http://corp.galois.com/blog/2011/6/7/sigplan-programming-languages-software-award.html
10:58:17 <c_wraith> (maybe "in case it hasn't yet..." is better phrasing)
10:58:48 <Saizan>  /win 12
10:58:54 <Cale> shapeless|afk: How are you causing it?
10:59:26 <c_wraith> also, what version of GHC?  I can panic ghci reliably on 6.x
10:59:57 <c_wraith> (the large BCO thing wasn't handled properly in ghci until ghc 7)
11:05:44 <inter> This isn't Haskell-related, but is it correct that the (context-free) language {ab^nc^n : n >= 0} U {b,c}* is not deterministic?
11:06:12 <inter> sorry, {a}{b^nc^n : n >= 0} U {b,c}*
11:06:29 <byorgey> inter: what do you mean by "not deterministic"?
11:06:52 <dolio> That language is context free?
11:06:58 <lpsmith> yes
11:07:03 <inter> cannot be accepted by a deterministic PDA
11:07:16 <lpsmith> I had the same thought though, dolio
11:07:17 <c_wraith> uh.
11:07:21 <byorgey> looks like it could be accepted by a determinstic PDA to me
11:07:21 <dolio> Oh, right. It's a^nb^nc^n that's a problem.
11:07:59 <lpsmith> right,  you can do something like   X -> bXc | epsilon
11:08:07 <c_wraith> I could have sworn there's no computability difference between deterministic and non-deterministic automata
11:08:24 <lpsmith> but that's not true of PDA, IIRC
11:08:36 <dschoepe> c_wraith: at least for finite automata
11:08:41 <inter> You're right, my mistake.
11:09:12 <inter> (there is a difference between the language accepted by deterministic and nondeterministic PDAs)
11:09:51 <dschoepe> s/at least/only/
11:10:22 <lpsmith> dschoepe: there is no difference between deterministic and non-deterministic turing machines :)
11:10:43 <dolio> No computability difference.
11:10:51 <lpsmith> right :)
11:10:53 <dschoepe> lpsmith: oh right, but there is one for PDAs, as inter said
11:11:06 <c_wraith> huh.  Interesting
11:11:26 <saati> what is a pda? (google gives no relevant answers)
11:11:33 <lpsmith> pushdown automata
11:11:34 <c_wraith> push-down automata
11:11:36 <inter> public display of affection?
11:11:43 <dschoepe> saati: http://en.wikipedia.org/wiki/Pushdown_automaton
11:11:59 <saati> ah, stack automata
11:12:13 <lpsmith> So if a very powerful alien offered you one of two objects,  either a halting oracle or a non-deteriministic turing machine,  which one would you take?
11:12:41 <c_wraith> Dunno.  Which one is tougher to carry with me?
11:12:45 <c_wraith> And faster?
11:13:33 <lpsmith> hah
11:13:48 <c_wraith> Simple computational power isn't the only consideration!
11:14:02 <byorgey> I guess it depends whether you want to be famous for solving longstanding open problems, or breaking everyone's crypto =)
11:14:44 <saati> can't you use one to create the other?
11:14:52 <lpsmith> saati: no
11:15:14 <hpc> i think i would ask the aliens if i can have both blueprints in lieu of a physical machine
11:15:33 <c_wraith> hpc: sure, but they're both made from unobtanium
11:15:38 <hpc> who needs the object itself when the design of it will probably yield more answers
11:15:46 <hpc> c_wraith: that's no fun :P
11:16:22 <lpsmith> I dunno, I'd have a hard time accepting the halting oracle,  because how would you ever know it worked correctly?
11:16:46 <c_wraith> Man, my tattoo would be no fun at all with a halting oracle.
11:16:49 <hpc> > oracle {do "halt if you work correctly"}
11:16:50 <lambdabot>   <no location info>: parse error on input `do'
11:16:53 <hpc> :D
11:16:59 <ben> Can't you ask them for a FTL spaceship or a free-energy machine?
11:17:02 <c_wraith> Solving it is a simple application of the halting problem.
11:17:28 <hpc> ben: ask for a portal gun, then you get both
11:17:55 <lpsmith> hpc: unfortunately introducing a halting oracle create a device who's halting problem is itself undecidable.
11:17:55 <dolio> saati: You can emulate an NTM on a TM with exponential blowup, so if an NTM could solve the halting problem for TMs, that would imply that TMs could.
11:18:13 <zong_sharo> http://paste.pocoo.org/show/402296/ <- can i still be qualified as a sane person?
11:18:16 <ben> hpc: I'm not convinced the portal gun does not simply have a very powerful battery that is drained to offset all the impulse "conservation" gimmicks you perform
11:18:49 <benmachine> lpsmith: how much of a problem is that in practice, though?
11:19:01 <zong_sharo> i'm kinda concerned about
11:19:08 <benmachine> surely you can do most things without an oracle
11:19:56 <monochrom> but you can't do most things without a sun :)
11:22:24 <lpsmith> benmachine: I dunno.  But the point of the halting oracle is that you could ask it things such as "is there a proof of the Riemann Hypothesis" etc,  things we aren't likely going to be able to do with a good partial solution to the halting problem anytime soon.
11:22:34 <Cale> ben: Given that portals exist, the battery could even be elsewhere.
11:22:44 <inter> Hmm, here's the question I was getting at: I don't think there is a strong LL(1) grammar that generates {a}{b^nc^n : n >= 0} U {b,c}*. I guess my earlier question was misdirection. But maybe I should ask this somewhere else.
11:23:16 <benmachine> lpsmith: well yes, I mean, you can do stuff without an oracle, and then you can use the oracle to reason about it :)
11:23:26 <benmachine> lpsmith: I'm basically wondering how often we would need an oracle oracle
11:23:28 <inter> In any case, the existence of a machine that decides the halting problem produces a contradiction.
11:23:37 <kmc> yeah, i like the weapon from Glasshouse (?) where you put one end of a portal on a hand-held gun device, and drop the other end into a convenient star
11:23:49 <lpsmith> benmachine: oh
11:23:51 <benmachine> inter: but once we've got a contradiction we can prove that everyone is happy
11:24:30 <benmachine> inter: is that still true if it can't decide its own halting problem as it were?
11:24:34 <ben> kmc: I don't want to hold that hand-held device
11:24:42 <lpsmith> benmachine: that might be a problem with > oracle {do "halt if you work correctly"}
11:24:54 <benmachine> lpsmith: not the only problem :P
11:25:12 <kmc> ben, just be careful which way you point it
11:25:13 <inter> Presumably, that's why the RAND Corporation has devoted so much effort to the construction of a halting oracle.
11:26:58 <lpsmith> inter,  how would the existence of a halting oracle produce a contradiction? :)
11:27:25 <maurer_> I mean, you can always make a halting oracle with the possible solution states of "no", "yes", and "fuck you"
11:27:36 <lpsmith> lol
11:27:47 <maurer_> And then just try to reduce the "fuck you" state to as small a fraction of programs you care about as is possible.
11:27:51 <lpsmith> but then it wouldn't be a halting oracle.
11:28:00 <maurer_> Sure, but it would serve a similar purpose :P
11:28:03 <lpsmith> but yes, that would be a practical partial solution
11:28:52 <byorgey> we already have such practcial partial solutions.
11:29:02 <byorgey> they are called things like "The Agda Type Checker".
11:29:28 <dolio> Nah, it's the termination checker.
11:29:31 <lpsmith> maurer: but it also seems likely that many of the programs that theory people would be most interested in getting an answer to would result in a "fuck you" state
11:29:48 <byorgey> sorry, right, not the type checker per se.
11:29:52 <inter> The typical solution is to show that the existence of a decision procedure for some harder language produces a contradiction, then show that if there is a solution to the halting problem we can solve the harder language.
11:29:54 <lpsmith> for example,  Collatz or the Riemann hypothesis
11:30:11 <maurer_> lpsmith: True.
11:30:27 <maurer_> lpsmith: However, you could certainly make it as a code-quality tool.
11:30:28 <dolio> Dude, Collatz is solved. Didn't you hear?
11:30:41 <dolio> Now you can just say "loops".
11:32:12 <lpsmith> lol
11:32:25 <dolio> And you can optimize things better if you program your compiler to recognize encodings of the Collatz conjecture that people have inserted into their code.
11:32:37 * hackagebot time-recurrence 0.5.2 - Generate recurring dates.  http://hackage.haskell.org/package/time-recurrence-0.5.2 (ChrisHeller)
11:32:44 <dmwit> So, at the risk of sounding ultimately gullible... is collatz really solved
11:32:47 <dmwit> ?
11:33:00 <olsner> dmwit: yes, maybe :)
11:33:05 <dolio> Someone produced a paper to that effect. I haven't followed up on it.
11:33:16 <kmc> some guy on arXiv?
11:33:18 <lpsmith> dmwit: there is a recent paoer,  but I haven't looked at it.
11:33:22 <kmc> some guy on arXiv proves P=NP about every week
11:33:40 <lpsmith> people say it's a serious effort
11:33:47 <kmc> people also patent perpetual motion machines
11:33:47 <c_wraith> kmc: from a former research assistant of Collatz himself, I think
11:33:54 <kmc> ok, that sounds more legit then
11:33:56 <shachaf> kmc: The same one each week?
11:34:00 <kmc> shachaf, maybe
11:34:29 <dmwit> http://mathlesstraveled.com/2011/06/04/the-collatz-conjecture-is-safe-for-now/ =/
11:36:58 <c_wraith> dmwit: hmm.  That's unfortunate.  But that criticism makes me cry about the paper.
11:40:43 <inter> Does the Collatz conjecture have any practical significance?
11:41:26 <olsner> my CS intro course used it as an example to demonstrate that the halting problem is indeed a tricksy beast
11:43:41 <inter> Yeah, it's ubiquitous in recursion and computability theory textbooks.
11:58:45 <joe6> does ghci run on hurd?
12:00:27 <Cale> Does anything run on hurd? ;)
12:01:13 <hpc> does hurd run?
12:01:29 <mercury^> Cale: I hurd they recently got ed to run.
12:01:51 <copumpkin> see, my mind may be in the gutter, but hurd is a terrible name
12:02:04 <mercury^> The upside is that you can ed files on an ftp server now.
12:02:10 <hpc> yo dawg, i hurd you like gnu...
12:02:13 <Cale> Actually, I want to change my troll now, I heard that Duke Nukem Forever is going to run on it when it comes out any day now.
12:02:15 <mercury^> Oh wait, you can do that with linux too.
12:03:01 <jrk_> http://darcswatch.nomeata.de/repo_http:__code.haskell.org_X11.html
12:03:08 <shapr> Will anyone here be at OSCON in Portland?
12:03:18 <jrk_> can someone give me a hint why the xscreensaver bindings were rejected?
12:03:47 <jrk_> i could not find an email or so about it..
12:04:02 <jrk_> maybe my google-fu is not strong enough :)
12:07:31 <lpsmith> http://hpaste.org/47564/specconstr
12:08:20 <lpsmith> i find that oddly amusing ^
12:09:15 <copumpkin> that message has been around for a few releases now
12:09:16 <copumpkin> not sure why
12:10:22 <lpsmith> yeah,  it'd be nice if I could figure out how to supress that message.  1910 messages is a bit much,  makes it hard to see the rest of the compilation output
12:10:50 <lpsmith> and it seems to be just that one module that has the issue
12:14:04 <lpsmith> I think I have an idea of what it means
12:24:35 <jrope> hi, does anyone know if the haskelldb project is still active?
12:25:16 <shapr> jrope: As far as I know it is still active.
12:25:26 <napping> lpsmith: what does it mean? Does that count decrease as it recurses or something like that?
12:26:22 <jrope> are there any good resources for learning about it, I read the paper on the haskelldb site but would like to get more info
12:27:13 <jrope> or if there are other (better?) alternatives to haskelldb
12:28:45 <napping> I think it's the only (Haskell) library trying for that sort of typed database access.
12:29:07 <flazz> if i have a function f :: b -> Bits a, is there a way to determine things about the return type (like bitSize)?
12:29:48 <tsuraan_> is there a good way to write a combination of Data.ByteString.foldl and Data.ByteString.span that lets you split a bytestring into two while having your splitter function keep track of its history?
12:29:56 <mm_freak> flazz: that type signature doesn't really make sense
12:29:58 <shapr> jrope: The HaskellDB mailing list is the best way to ask question.
12:29:59 <mm_freak> Bits is a type class
12:31:07 <jrope> ok, thanks, wasn't sure if I should go with haskelldb or use hsql instead.
12:32:07 <napping> flazz: a type like (Bits a) => b -> a promisies to return a result in *any* instance of Bits that you ask for
12:33:05 <dmwit> flazz: Yes, use the ScopedTypeVariables extension.
12:34:02 <shapr> jrope: haskelldb can use hqsl
12:34:05 <shapr> er, hsql*
12:36:15 <jrope> yeah, I wanted a higher level db interface, I'll have to read some more and figure out if haskelldb is what I really want.
12:41:37 <druveen> hi
12:45:40 <ion> Is there a way to automatically export all fclabels lenses defined by mkLabels?
12:47:14 <druveen> how move to step7
12:47:33 <napping> hello. what step7 ?
12:47:41 <druveen> in tutorial
12:47:54 <Lajla> Most descriptive.
12:48:45 <druveen> i am newto this i am going through  "Try Haskell in your browser"
12:49:33 <druveen> i have gone throught lesson1 and i am stuck at lesson 2  step 6
12:51:07 <monochrom> don't you just enter (28,"chirs") ?
12:51:30 <druveen> ya i entered it
12:52:00 <druveen> next step is not comming..
12:53:53 <druveen> > (28 , "chir­s") => (28,"chirs")
12:54:35 <napping> maybe something is stuck. Try typing in step7
12:54:50 <napping> (works for me)
12:55:16 <druveen> thanks step7 works
13:04:27 <Jeanne-Kamikaze> hi
13:05:20 <Jeanne-Kamikaze> the profiler here shows what looks like decent memory usage http://codelink.info/~jeanne/stats.ps, however top shows an ever increasing usage ?
13:06:48 <napping> What increases in top?
13:07:03 <napping> Also, is that just when you are collecting stats?
13:07:08 <Jeanne-Kamikaze> RES
13:07:20 <c_wraith> well, what does the program do?  the ghc heap profiler only knows about the GHC heap.
13:07:35 <Jeanne-Kamikaze> it shows two spinning cubes
13:07:39 <c_wraith> if your program allocates a lot of stuff in the C heap via the FFI, that won't be seen by the profiler.
13:07:45 <Jeanne-Kamikaze> oh
13:07:57 <c_wraith> sounds likely to be the problem..
13:08:05 <Jeanne-Kamikaze> I actually use newArray
13:08:06 <c_wraith> Failing to release surfaces, or the like?
13:08:12 <Jeanne-Kamikaze> to pass matrices to opengl
13:08:26 <napping> and freeArray?
13:08:28 <Jeanne-Kamikaze> no, it's not even that fancy
13:08:29 <Jeanne-Kamikaze> no :D
13:08:30 <Jeanne-Kamikaze> no free
13:08:36 <napping> ah, that's probably it
13:08:43 <Jeanne-Kamikaze> hang on, I'm gonna throw myself out the window right now
13:08:51 <RichardBarrell> Stop!
13:08:51 <Evious> Any recommendations on a linear algebra library for GL stuff?
13:08:52 <c_wraith> fits with your name :)
13:08:54 <RichardBarrell> You can't do that!
13:09:16 <Evious> It's all fun and games until somebody actually follows through on the threat.
13:09:19 <Evious> Then we're witnesses :(
13:09:20 <RichardBarrell> You need to rename yourself to Jeanne-Autodefenestration first.
13:09:26 <RichardBarrell> "Kamikaze" is just the wrong word.
13:11:19 <lpsmith> napping:  if you spend some time studying ghc core,  you'll notice that GHC will massage function definitions, even recursive ones,  to try to avoid pattern maching
13:14:47 <lpsmith> e.g. if you have a function    f (x:xs) (y:ys) = g x (f xs (y:ys)) ++ g y (f (x:xs) ys);  f _ _ = [],    ghc will convert that into three or more mutually recursive functions,     f0 (x:xs) (y:ys) = g x (f2 ys y ys) ++ g (f1 x xs ys),  f1 x xs (y:ys) = ...,  and f2 (x:xs) y ys = ...
13:16:34 <fxr> @seen sclv
13:16:34 <preflex>  sclv was last seen on #haskell-blah 242 days, 5 hours, 43 minutes and 2 seconds ago, saying: i think its a bit more straightforward still
13:17:52 <lpsmith> napping: that's what I suspect it's related to, somehow.
13:20:01 <kapper> Is there a nice way to apply a function to every pair of a list? For ex. some summing function applied to [1,2,3,4] would return [3,7]?
13:21:08 <gwern> kapper: what would this function do to odd length lists?
13:21:38 <kapper> Throw an exception i guess. The input should always be even.
13:22:09 <gwern> kapper: how horrid. wouldn't you rather work on [(a,a)] rather than [a]?
13:22:52 <RichardBarrell> You want to write a partial function from [a] to [(a,a)], then feed the result of that into map or foldr or anything else.
13:23:03 <wjt> Laney: yo, i don't suppose you have a 7.0.4rc1 .deb kicking around just waiting for you to upload to experimental? :)
13:23:18 <RichardBarrell> Or, as gwern points out, better yet change whatever is producing the [a] in the first place so that it produces [(a,a)] instead.
13:23:55 <RichardBarrell> If you can't or don't want to do that then it's easy enough to write.
13:24:34 <benmachine> :t let adjacents (x:y:xs) = (x,y):adjacent xs; adjacents [] = []; adjacents _ = error "I hate you :("
13:24:45 <RichardBarrell> > let { pairUp [] = []; pairUp (e1:e2:es) = (e1, e2) : es; }
13:24:46 <benmachine> @botsnack
13:24:53 <kapper> Maybe : ) The function is supposed to take pairs of vectors, and calculate their cross-product. So the input should be something like [(3,4), (8,7), (1,2), (4,4)]. Then it should return two crossproducts, between the first two and the second two.
13:25:10 <RichardBarrell> > let { pairUp [] = []; pairUp (e1:e2:es) = (e1, e2) : es; } in pairUp [1,2,3,4]
13:25:15 <benmachine> 20:11:53 -!- lambdabot [~lambdabot@li85-105.members.linode.com] has quit [Ping timeout: 250 seconds]
13:25:37 <RichardBarrell> If lambdabot wasn't dead then she'd be all "Syntax error" and "[(1,2), (3,4)]" right now.
13:25:43 <benmachine> :P
13:26:32 <RichardBarrell> Also she'd be throwing a type error because I wrote ((e1, e2) : es) when I should have written ((e1, e2) : pairUp es)
13:26:42 <kapper> Should i work with the structure of the list as you propose insted? F.ex. [[(2,3),(4,4)],[(3,3),(2,3)]] instead?
13:26:59 <benmachine> kapper: sublists?
13:27:15 <benmachine> err that was an incomplete question
13:27:20 <benmachine> kapper: why sublists?
13:27:25 <monochrom> "pairs of vectors" look like [ ((3,4), (8,7)), ((1,2), (4,4)) ] to me
13:27:47 <kapper> To group the vectors in pairs of two?
13:28:28 <kapper> Yeah, maybe more like monochrom says... I'm pretty new with this Haskell stuff...
13:28:53 <kapper> So tuples of tuples i guess that is?
13:29:06 <RichardBarrell> Yes.
13:29:50 <Nibble> Yo dawg
13:29:53 <Nibble> I heard you like tuples
13:29:56 <RichardBarrell> If you know in advance exactly how many things will fit into a specific place in your data structure then you should use a tuple or a "data" type with that fixed number of parameters.
13:29:59 <Nibble> so we put a tuple in your tuple
13:30:04 <DukeDave> Zomg, darcs 'just worked' over my proxy, good work everyone :)
13:30:04 <roconnor> > 2^256
13:30:06 <Nibble> so you can fst while you fst
13:30:18 <Nibble> Zomg, darcs 'just ate all my ram'
13:30:23 <RichardBarrell> Nibble: the joke is funnier if you leave it at "Yo dawg". Subtlety helps.
13:30:39 <monochrom> Yo dawg ate my darcs
13:30:59 <Nibble> RichardBarrell: lolno
13:31:12 <RichardBarrell> Brevity helps more. "lolno" is a good start.
13:31:18 <kapper> Aight', cool.
13:31:53 <monochrom> abstraction helps. just say "dawg tuple fst" and we know how to expand it
13:32:25 <RichardBarrell> > yo dawg = let dawg = yo dawg in dawg -- the y combinator has a certain ring to it.
13:32:45 <Nibble> alright, this is more stupid that abelian grapes
13:33:16 <RichardBarrell> True.
13:39:13 <nyingen> can anyone explain the use of the terminology 'inner' and 'outer' in Enumeratees?
13:41:13 <DukeDave> Hmm, I just grabbed HRay from darcs, GHC (with --make) is complaining about a missing module called "HRayParser". There is a file called "HRayParser.y" in the same directory, which appears to contain Haskell-esque stuff, but presumable isn't scanned by GHC. What do?
13:41:54 <c_wraith> DukeDave: .y indicates it's a grammar file for some other tool.  I don't actually know offhand what the grammar generator is.  I'd guess Happy
13:42:06 <ulfdoz> maybe yacc.
13:42:44 <c_wraith> DukeDave: anyway, you need to run the right tool on the .y file to generate a .hs file
13:43:06 <c_wraith> DukeDave: look at how the cabal file does things
13:43:24 <c_wraith> actually, just use cabal-install is probably the correct answer anyway
13:43:41 <DukeDave> c_wraith: Good timing, I was just looking at the cabal file
13:44:05 <DukeDave> This is just on the limit of my understanding of the Haskell build system world
13:44:31 <ulfdoz> Don't you have gmake? *scnr*
13:44:36 <ulfdoz> msbuild.exe
13:44:39 <ulfdoz> mvn.bat
13:44:41 <RichardBarrell> If you aren't using cabal-install then you should be using Setup.hs
13:44:57 <DukeDave> The cabal file doesn't seem to mention anything special :|
13:45:05 <koninkje> @seen edwardk
13:45:06 <preflex>  edwardk was last seen on #haskell 21 hours, 59 minutes and 20 seconds ago, saying: just changes the question to P ?= QPP ?= NP
13:45:16 <RichardBarrell> Otherwise you're trying to build the package in a different manner than the author did when s?he packaged it up for Hackage.
13:45:20 <parcs> nyingen: the outer a is what gets fed, the inner a is what gets outputted
13:47:22 <parcs> so an Enumeratee Int ByteString m b gets fed some Ints and outputs some ByteStrings
13:48:14 <DukeDave> Is there a good explanation of the relationship between darcs, cabal and hackage anywhere?
13:48:38 <c_wraith> DukeDave: darcs is almost entirely unrelated.  cabal, cabal-install, and hackage are the interesting ones.
13:49:28 <nyingen> parcs: ok, so suppose I'm trying to read a file line-by-line, buffering the lines until some token is seen
13:49:43 <DukeDave> c_wraith: Yeah, I've used darcs a fair bit, but never touched cabal
13:49:59 <c_wraith> DukeDave: cabal contains the Cabal library, which is used for managing configuration of a build environment.  cabal-install (confusingly) contains the "cabal" binary, which downloads and installs packages from hackage, which is a giant public repo
13:50:11 <c_wraith> DukeDave: cabal-install can also be used as a local build system
13:50:23 <c_wraith> DukeDave: and at this point, most haskell projects do use it
13:50:32 <c_wraith> @hackage cabal-install
13:50:41 <c_wraith> ..  right, lambdabot crashed.  *sigh
13:50:54 <nyingen> parcs: Enumerator.Text has 'enumFile' which enumerates the file into a list of lines, and then I need an Enumeratee to buffer the lines, and feed the resulting sets-of-lines to an inner Iteratee?
13:52:12 <parcs> nyingen: sounds about right
13:54:02 * DukeDave could probably be reading the cabal docs right about now
13:55:27 <DukeDave> c_wraith: Thanks :)
13:55:38 <parcs> nyingen: i'd use Data.Enumerator.List.mapAccum to create the proper Enumeratee
13:58:26 <nyingen> parcs: ok, I'll try that
13:58:52 <nyingen> it would be nice if there were a tutorial that analyzed some useful Enumeratees
13:59:23 <nyingen> the existing tutorials seem to build them up from unclearly related concepts, skipping steps in the process
14:03:56 <nyingen> parcs: I'm not sure mapAccum will work, since the Enumeratee isn't supposed to pass anything to the Iteratee until the end-of-record token is seen
14:04:39 <mm_freak> nyingen: if n is the maximum line length and t is the length of your token, then your approach uses O(n) memory, while the optimal approach uses O(t) memory
14:06:20 <nyingen> mm_freak: we would be talking a difference of 50 characters versus 3 characters, but what's the optimal approach?
14:07:05 <mm_freak> nyingen: search for your token in the raw stream
14:07:56 <mm_freak> but that's only optimal in terms of memory…  if you want optimum in time, then given you use a buffer of b bytes, you will need about b+t bytes memory
14:10:13 <parcs> nyingen: use Maybe
14:21:53 * ddarius <3 Euler.
14:24:13 <ezyang> Whooooo. http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/89952
14:25:06 <ehamberg> wow! :)
14:25:49 <Evious> Success evasion unsuccessful :)
14:26:01 <ivanm> ezyang: dammit, there was something I was meaning to ask you about what you wrote in one of your blog posts...
14:26:03 <ehamberg> yeah. mission failed. :)
14:26:07 <ivanm> but now that I can, I forget what :s
14:26:13 <ulfdoz> congratulations, they deserve it.
14:26:24 <ezyang> ivanm: well, @tell me when you remember :-)
14:26:41 <ezyang> We'll be returning to our regular GHC programming... after I finish exams.
14:27:12 <EvilMachine> hello guys. i'm not getting monads again. ;)
14:27:38 <c_wraith> that's ok.  You don't need to get monads. :)
14:27:53 <EvilMachine> i have the plan, to make it possible, to use strings in a do notation. one string (in quotes) per line.
14:28:01 <EvilMachine> feels like a monad
14:28:10 <EvilMachine> but i guess it isn't
14:28:24 <EvilMachine> since strings lack a parameter or something. ;)
14:28:35 <c_wraith> > do { "foo" ; "bar" }
14:28:39 <ivanm> ezyang: something that _does_ come to mind: which font do you use for your blog?
14:28:41 <c_wraith> ...  lack of lambdabot, still
14:28:53 <c_wraith> anyway, that would result in "bbbaaarrr"
14:29:07 <ivanm> because anytime I view it on a *nix machine, the different letters have different heights, which is a tad annoying :s
14:29:07 <EvilMachine> c_wraith: oh, it's builtin? nice
14:29:11 <ezyang> Ahhh, you can figure that out yourself
14:29:18 <Evious> This may be a useful example: http://hackage.haskell.org/packages/archive/shpider/0.1.1/doc/html/Network-Shpider-Pairs.html
14:29:27 <EvilMachine> yep, pasted it into ghci
14:29:28 <c_wraith> EvilMachine: not built in.  But list is already a monad.  And strings are a list.
14:29:34 <EvilMachine> i left out one detail:
14:29:34 <saati> what happened with lambdabot?
14:29:41 <ivanm> preflex: seen lambdabot
14:29:41 <preflex>  lambdabot was last seen on #haskell 3 hours, 12 minutes and 55 seconds ago, saying:   <no location info>: parse error on input `do'
14:30:01 <ezyang> it appears to be constantia, palatino, "times new roman"
14:30:15 <EvilMachine> i want the strings to have newlines between them, and on the "run" function, i want to reflow the text to a fixed width with a function i already have
14:30:25 <ezyang> so maybe Linux doesn't work well with it? News to me.
14:30:35 <ivanm> could be
14:30:51 <ivanm> the first two are the new fonts in Vista, aren't they?
14:30:59 <EvilMachine> c_wraith: maybe a mod of the list monad?
14:31:30 <shachaf> EvilMachine: Why are you so keen on it being a monad?
14:31:35 <c_wraith> EvilMachine: you probably don't want a monad.
14:31:43 <ivanm> sounds more like a pretty-printer...
14:31:44 <shachaf> Just use a list of strings, or something.
14:32:03 <ivanm> or use "...\<newline>\..." for split strings
14:32:28 <EvilMachine> shachaf: actually, i don't care. i just think it's nicer to use when you can use do notation
14:32:42 <EvilMachine> ivanm: a bit. yeah. :)
14:32:57 <ivanm> why is do-notation "nicer" ?
14:33:07 <EvilMachine> ivanm: why isn't it?
14:33:13 <EvilMachine> ;)
14:33:15 <ivanm> it _is_ nicer when you use a custom Monad to simulate an imperative language with a DSL
14:33:24 <EvilMachine> lol
14:33:28 <ivanm> EvilMachine: you can't chain functions together as neatly
14:33:47 <ivanm> but you just seem to be going "I like do-notation, so how can I abuse it to do something?"
14:34:23 <EvilMachine> i just have a bunch of functions for various output modules (think sections). and those mainly consist of outputting lines of text by calling small "widget" functions.
14:34:43 <EvilMachine> but i want one line in the code to be one line in the output module functions
14:34:50 <EvilMachine> for overview
14:34:55 <Evious> Could you do what you need with a run::String->String and an infix "++ with a newline in between" operator?
14:35:22 <EvilMachine> and i don't want to always have to prepend the printStrLn. that should be implicit inside the do thing
14:35:40 <EvilMachine> Evious: i think yes
14:36:02 <EvilMachine> the run would do the reflow thing at the end
14:36:09 <ivanm> Evious: str1 `joinLines` str2 = str1 ++ "\n" ++ str2
14:36:17 <ivanm> EvilMachine: seriously, use a pretty-printing library
14:36:38 <EvilMachine> ivanm: that's serious overkill for my uses
14:36:48 <EvilMachine> ivanm: i want to have less to write. not more. ^^
14:37:20 <ivanm> EvilMachine: there already _are_ pretty-printing libraries
14:37:30 <EvilMachine> ivanm: i know
14:37:48 <Volt_> ezyang: On the subject of fonts, this is how your blog looks on my Mac. http://i.imgur.com/Z7tkD.png
14:37:48 <Volt_> Note the dates in the comments. Everything else seems fine. No idea why it happens and never investigated it though.
14:38:15 <ezyang> That's... really strange.
14:39:40 <acowley> So, I have a C function that I can call from a C main (everything compiled and linked with GCC) that will segfault when called from Haskell via FFI. Rebuilding the C library takes approximately 10 years, so I want to minimize how many times I have to do that. Advice?
14:40:24 <EvilMachine> ivanm: all i need is to make the "do" notation "automagically" apply "unlines" (or my version of it) to the lines in it. i won't ever need more.
14:40:35 <acowley> gdb shows the segfault happening in a linked native library, but, again, the same function works when compiled and linked with gcc.
14:40:51 <EvilMachine> ivanm: as far as i know "do" just works on monads, right?
14:41:31 <tgeeky> What is the "most correct" way to introduce a datatype for "AtomicNumber". It should have deriving (Eq, Show, Enum, Bounded) - but not the same Bounded as Int. It should be like 1 | 2 | 3 | .. | 120
14:41:34 <EvilMachine> ivanm: or is it so simple that it just transforms it into ">>" and ">>=" etc, no matter what.
14:42:44 <ivanm> EvilMachine: you _can_ do some kind of RebindableSyntax for your own definition of the Monad type-class... but yeah, it just uses >>= and >>
14:43:22 <ivanm> so unless you wrap each String in a newtype such that >> = ++ (but lifted), you're out of luck
14:43:23 <parcs> EvilMachine: is it your intention to be able to build a list of strings?
14:43:24 <acowley> tgeeky: a newtype around Int
14:43:36 <ivanm> which is why I suggest a pretty-printer
14:43:53 <parcs> EvilMachine: never mind, i forgot to scroll down :P
14:43:54 <EvilMachine> parcs: nope
14:43:55 <ivanm> tgeeky: you may need/want the GeneralizedNewtypeDeriving extension to be able to derive Enum and Bounded
14:43:57 <EvilMachine> parcs: :)
14:44:02 <ivanm> oh, I mean just for Enum then
14:44:15 <EvilMachine> ivanm: then i will do the newtipe wrapping. :)
14:44:36 <ivanm> EvilMachine: in which case, it's just as easy IMHO to use a pretty printing library
14:44:42 <ivanm> as it will do the reflowing for you
14:45:08 <ivanm> whereas you would still need to somehow manually do a "reflow" function on the result of your Monad
14:45:38 <tgeeky> ivanm: thinking about it, I really don't want people to be able to do +, -, *, and negate, etc... to them
14:46:25 <tgeeky> it could just as well be:
14:46:30 <EvilMachine> ivanm: i already have the reflow function here. it's also a special one.
14:46:39 <ivanm> tgeeky: then don't derive Num!
14:46:50 <EvilMachine> ivanm: not just pure reflow. but additional functionality.
14:47:00 <ivanm> @src Monad
14:47:12 <EvilMachine> ivanm: already done. ;)
14:47:13 <ivanm> oh, right, no bot
14:47:41 <ivanm> EvilMachine: I don't recall if >> is a class method, or defined solely in terms of >>=
14:47:54 <parcs> it's a class method
14:48:27 <parcs> well, it's a class method with a default definition
14:48:32 <EvilMachine> ivanm: i will never drag in a whole library, just for one functionality. let alone learn the whole syntax, just to make sense of it. and then still have to write more code than what i have to do now. ^^
14:48:48 <EvilMachine> ivanm: http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#Monad
14:49:18 <Peaker> It's a little bit arbitrary that say (>>) is a class method, but "sequence" or "join" is not.  I think we should have the simplest/most-fundamental as class methods only.  For "optimization", we can make specialization pragmas?
14:49:34 <acowley> tgeeky: the one thing you may want to do is offer smart constructors for newtype'ed Int. These would be like, fromInt :: Int -> Maybe MyNum
14:49:38 <benmachine> Peaker: I always thought that
14:49:58 <benmachine> or rewrite rules in the extreme case
14:50:03 <ivanm> EvilMachine: seriously, I think you're doing it the wrong way
14:50:20 <Peaker> yeah, cluttering fundamental things with optimization concerns...
14:50:35 <ivanm> from experience, it can be a real PITA to do things "properly" down the track rather than a quick`n`dirty solution up-front
14:50:37 <EvilMachine> ivanm: because i want to save me the work of learning a whole pretty printer library, that still won't do what i want? ;)
14:51:11 <ivanm> what _actually_ are you doing?
14:52:15 <ivanm> because passing around Strings like you say you're doing sounds rather hacky
14:54:29 <EvilMachine> ivanm: dude, this is just a small program for personal use *only*, that i do not ever want to make into a big thing. :)
14:55:24 <EvilMachine> ivanm: as i described: i have multiple functions called renderXYZ, where XYZ is the name of a section an a console text output.
14:56:31 <EvilMachine> ivanm: each renderXYZ is supposed to be used in do notation
14:56:50 <Evious> EvanCarroll, don't worry about optimizing syntax too much, it's not worth the effort. As tempting as it may be.
14:57:02 <EvilMachine> ivanm: and each line in each renderXYZ function is supposed to be one line of text output. but the string only
14:58:07 <acowley> EvilMachine: it really sounds like ivanm's advice is dead on
14:58:48 <Evious> If I spent as much time writing actual code, as optimizing syntax when I was learning Haskell, I'd be a lot better off :p
14:59:08 <roconnor> how fast is the union of two Maps?
14:59:30 <EvilMachine> ivanm: when doing "runRendering "Section XYZ" 80 renderXYZ", I want to get a section with the title "Section XYZ: ", and the lines, reflowed to 80 chars width, but with the title in the front of it, making it 80 columns in *total*
15:00:42 <EvilMachine> acowley, ivanm: ok, then show me a pretty printer lib that allows me to do this by *just* importing it, and using its types and run function. nothing more
15:00:49 <ivanm> EvilMachine: text "Section XYZ:" <+> text "here is some text that is multiline and reflows but in the same columns"
15:00:51 <acowley> roconnor: depends on argument order I believe, but it's linear
15:01:07 <ivanm> EvilMachine: you have to use the combinators
15:01:20 <roconnor> acowley: so I might as well fold over a list
15:01:43 <acowley> roconnor: I would think so
15:01:46 <EvilMachine> ivanm: and it doesn't conform *at all* to my requirements. since it neither uses do notation, nor is it free of the need to use other functions.
15:01:51 <roconnor> acowley: I have a list of data, and I want to add it to several trees
15:01:56 <roconnor> er several maps
15:01:59 <ivanm> but for the most part it'll be text to convert your String, <+> to join them with a space inbetween, and depending on the lib something like $$ to vertically separate them
15:02:07 <EvilMachine> ivanm: if i can leave the "text" and "<+>" out, i'll take it.
15:02:08 <acowley> yeah, it's frustrating that you can't reuse parts of the tree structure
15:02:11 <ivanm> EvilMachine: why are you so damned obsessed with do notation?
15:02:32 <acowley> roconnor: there are probably tree structures other than maps that can be more clever about hanging subtrees
15:02:32 <EvilMachine> ivanm: it's the whole point!
15:02:36 <EvilMachine> ivanm: ^^
15:02:56 <roconnor> acowley: well maybe not a lot of tree
15:03:03 <acowley> EvilMachine: but it seems like you're trying to do something normal while standing on one foot
15:03:04 <roconnor> usually only 1
15:03:07 <ivanm> so you would rather do something the wrong way because you want it for some arbitrary reason rather than using a library that is better suited for what you actually _need_ ?
15:03:09 <roconnor> on occasion 2
15:03:13 <roconnor> :D
15:03:20 <EvilMachine> ivanm: seriously, why are you completely ignoring the point of the requiremnt i described?
15:03:25 <roconnor> in principle arbitrarily many
15:03:34 <ivanm> EvilMachine: your "requirement" seems to be rather arbitrary
15:03:45 <ivanm> why do you _need_ to use do blocks?
15:03:48 <EvilMachine> ivanm:  i am a *human being*, dammit!
15:03:54 <Evious> Do notation is far more powerful than what you need. How do you intend to use <-?
15:04:09 * ivanm is also human, last time he bothered to check
15:04:11 <EvilMachine> ivanm: and for human beings, having some visually sensible structure is not at all arbitrary
15:04:19 * ddarius  doesn't believe EvilMachine 
15:04:21 <EvilMachine> ivanm: i'm sorry. i don't want to get in a fight with you
15:04:34 <acowley> roconnor: what about using fingertree?
15:04:43 <acowley> err
15:04:45 <EvilMachine> ivanm: let's both calm down and not attack each other, ok? :)
15:04:55 <acowley> that's not really a drop-in replacement
15:04:59 <ivanm> EvilMachine: foo <+> bar <+> baz
15:05:00 <erus`> do do notation!
15:05:09 <ivanm> you can line them up however you need
15:05:41 <roconnor> acowley: it's okay.  Map will do for now.
15:05:54 <roconnor> I have plans to replace it with HashMap sometime
15:06:04 <roconnor> but this stuff isn't where my code is slow right now
15:06:07 <roconnor> so it isn't so important
15:06:35 <EvilMachine> ivanm: i need one line per string. and i want to hide as much away in automation as possible. i don't want to write boilerplate concatentaion or text operators each time. that's all. :)
15:06:51 <EvilMachine> ivanm: doesn't even have to be do notation
15:07:04 <EvilMachine> ivanm: just avoiding to write the same thing over and over
15:07:05 <benmachine> EvilMachine: what about lists, and commas
15:07:16 <EvilMachine> ivanm: because that's deeply wrong to my programmer mind. :)
15:07:33 <roconnor> ivanm: maybe I should just store the closure :D
15:07:38 <EvilMachine> benmachine: yeah, that's my plan b. :)
15:07:43 <ivanm> EvilMachine: in that case, soemthing like "cat [foo, bar, baz]" would work
15:07:51 <benmachine> EvilMachine: it works pretty well as a plan A :P
15:07:54 <benmachine> just sayin'
15:07:57 <joe6> is there something to set in haskell to set the priority of a process that I am starting from haskell?
15:07:58 <EvilMachine> benmachine: ;)
15:07:59 <acowley> EvilMachine: that's fine, but you should at least appreciate that what you're trying to do is deeply wrong to all the other programmer minds on #haskell?
15:08:10 <ivanm> roconnor: hmmm?
15:08:21 <benmachine> acowley: I think that's a bit harsh
15:08:29 <ivanm> joe6: use nice when you run it! ;-)
15:08:34 <benmachine> we're not the judgemental sort
15:08:36 <joe6> i am usin createProcess to start it.
15:08:37 <acowley> sorry, I didn't mean it harshly
15:08:43 <joe6> ivanm, yes, renice
15:08:47 <acowley> I meant that we're not objecting for stylistic reasons
15:09:24 <EvilMachine> acowley: why do you say, that the core principle of programming (to never write the same thing twice, but make a re-usable function out of it) is deeply wrong? and to all here too?
15:09:33 <roconnor> ivanm: instead of storing the list of things I want to insert I could store flip (foldr Data.Map.insert) myList
15:09:35 <joe6> ivanm, gotit. thanks
15:09:50 <ivanm> roconnor: but why are you telling _me_? weren't you talking to acowley?
15:09:51 <EvilMachine> acowley: it's ok.
15:09:59 <roconnor> ivanm: ah oops
15:10:01 <roconnor> sorry
15:10:09 <ivanm> EvilMachine: then write a function that does it for you based upon <+>, etc.
15:10:23 <ivanm> but consider this: a pretty-printing library _is_ the re-usable implementation of what you want
15:10:29 <acowley> EvilMachine: I think what you're doing is a tradeoff between minor irritants: you're annoyed by the syntactic boilerplate, everyone else is annoyed by the use of a more complex abstraction than is needed.
15:10:30 <ivanm> roconnor: heh, np
15:10:36 <EvilMachine> ivanm: that's what i had trouble with, when i came in, basically. :)
15:11:05 <EvilMachine> acowley: then let's combine our both ideals. but no compromises! :)
15:11:14 <ivanm> acowley: especially when we already have usable abstractions
15:11:16 <ddarius> Looking back at Isaac's nomination statement to SIGPLAN, he had 499 words.  He could have added 'Glorious.'
15:11:35 <ivanm> ddarius: I thought they were trying to be more humble nowadays...
15:11:47 <acowley> EvilMachine: the way most of us have found a way around compromises is for certain pieces of syntax to be invisible
15:12:03 <acowley> it's like lisp/scheme programmers and parentheses
15:12:13 <dbpatterson> what is the easiest way to sleep in a program for a couple hundred milliseconds (I want to artificially induce a delay for web responses for user interface testing)?
15:12:19 <ddarius> ivanm: http://www.haskell.org/ghc/docs/7.0-latest/html/users_guide/index.html
15:12:43 <EvilMachine> acowley: yeah, i *hate* the parentheses mess in lisp. :)
15:12:48 <monochrom> "threadDelay 1000" sleeps 1 microsecond
15:12:52 <EvilMachine> acowley: extremely inelegant
15:12:56 <monochrom> sorry, 1 millisecond
15:13:01 <EvilMachine> acowley: for such a otherwise elegant language
15:13:15 <acowley> ultimately syntax is all about compromises: you can't optimize for every possible usage
15:13:21 <ivanm> monochrom: I thought the Int for threadDelay was how many milliseconds to sleep
15:13:29 <ivanm> so shouldn't your statement sleep for 1s?
15:13:29 <acowley> it's microseconds
15:13:41 <ivanm> oh, right, duh
15:13:50 * ivanm hasn't done much unit stuff for a while
15:14:08 <acowley> In Haskell we use different symbols for kinds of "application" at different types. The most common variety gets the best symbol (whitespace)
15:14:37 <luite> don't use the System.Posix sleep function :)
15:14:41 <EvilMachine> acowley: :)
15:14:46 <ivanm> luite: why not?
15:14:48 <joe6> ivanme, but I get "permission denied"
15:15:08 <ivanm> joe6: with the same user that ran it?
15:15:14 <parcs> EvilMachine: what exactly do you want to do again?
15:15:18 <luite> ivanm: because it doesn't sleep on the threaded runtime
15:15:28 <luite> ivanm: it's interrupted by the SIGALRM signals
15:15:36 <ivanm> parcs: he wants to have a Monad that does ++ in between String statements
15:15:38 * EvilMachine doesn't dare to explain it again to parcs. ;)
15:15:40 <ivanm> luite: ahhhh
15:15:41 <luite> the non-threaded version will sleep, but can also be interrupted
15:15:57 <ivanm> EvilMachine: aren't you using more boilerplate by wrapping each String with the constructor for your newtype?
15:16:06 * mux wonders: ListZipper or pointedlist ?
15:16:07 <dbpatterson> monochrom et al: thanks!
15:16:08 <luite> that difference can make some hard to track down difference of someone uses a different runtime :)
15:16:14 <joe6> ivanm, I start a process from haskell and then use "sudo renice -10" currently.
15:16:15 <ivanm> mux: for?
15:16:18 <acowley> OverloadedStrings?
15:16:26 <mux> ivanm: well for a list zipper :-)
15:16:31 <Laney> wjt: fraid not
15:16:31 <ivanm> acowley: ssshhhhh! don't encourage him!
15:16:38 <ivanm> mux: I'm a fan of data-clist
15:16:40 <Laney> waiting for the migration to shake itself out
15:16:41 <joe6> ivanm, i am t rying to put this into the haskell script now, so I do not hawe to worry with running the renice manually.
15:16:49 <EvilMachine> acowley: how do we get to plan b list solution to something that is elegant from your p.o.v., while also doing away with the commas? :)
15:16:52 <ivanm> but that's because it also has an empty case, rather than requiring me to use Maybe everywhere...
15:17:06 <acowley> ivanm: benmachine made me feel bad, so now I have EvilMachine's back on this crusade :)
15:17:08 <mux> ivanm: I don't want a ring
15:17:14 <benmachine> acowley: :P sry
15:17:23 <ivanm> mux: doesn't pointedlist use a ring?
15:17:37 <mux> ivanm: it provides both circular and non-circular lists
15:17:38 * ddarius doesn't know what EvilMachine is going on about but suggests that he read Okasaki and Hinze.
15:17:44 <ivanm> acowley: "bah!" to you then!
15:17:45 <ivanm> ;-)
15:17:52 <ivanm> mux: oh, right, forgot it had two variants
15:17:52 <benmachine> acowley: from what little I bothered to read, it sounds to me like ivanm was saying a sensible thing
15:17:56 <EvilMachine> ivanm: not more, since with a pretty printer, i'd also have to do the wrapping. but i want to write it only once. at a single place.
15:18:02 <benmachine> I just don't like people being presciptivist about it
15:18:09 <ivanm> EvilMachine: pretty-printers do the wrapping for you at the end
15:18:17 <ivanm> you say how many columns you want, and it does it
15:18:36 <EvilMachine> ivanm: "text" is what i considered a wrapping function, in your above example. :)
15:18:56 <ivanm> but you also get the "columns" for free: text "foo" <+> (text "bar" $$ text "baz") will have two columns with a space inbetween
15:19:06 <ivanm> and bar and baz will be on top of each other
15:19:33 * benmachine hugs acowley
15:19:35 <ivanm> EvilMachine: note that using a pretty-printer should also give you better performance rather than using ++ everywhere on Strings
15:19:54 <EvilMachine> ivanm: actually, i don't. since i would still have to do "lines", prepend each line by white space of the length of the title, except the first, where i would prepend the title itself.
15:20:18 <EvilMachine> ivanm: anyway, i already have a nice function doing the wrapping and prepending in one step
15:20:23 <ivanm> EvilMachine: pretty printers do that _for you_
15:20:41 <mux> I have absolutely no idea if that's really feasible, but I'd really like some rewrite rules for: hPut (x ++ y) => hPut x >> hPut y
15:20:44 <ivanm> and then make sure the entire thing fits into your specified number of columns
15:20:50 <EvilMachine> ivanm: a mod of a wrapping function out of some simple pretty printing from some other project.
15:21:05 <ddarius> mux: Those aren't equivalent.
15:21:09 <benmachine> mux: sometimes rules like that seem sensible but don't work if e.g. x is infinite
15:21:12 <ivanm> EvilMachine: e.g. have a look at the source for Data.GraphViz.Attributes; the Attributes data type is generated using a pretty-printer
15:21:18 <EvilMachine> ivanm: how would i do that prepend thing then?
15:21:33 <Itkovian> dcoutts: Did I read that right? Congrats are in order?
15:21:48 <ivanm> EvilMachine: you have title <+> textBlock
15:21:58 <ivanm> Itkovian: what did dcoutts do?
15:22:16 <mux> benmachine: well in that case we could care less about x being infinite; both not terminating due to trying to append a string to an infinite one, or trying to do I/O with an infinite string seems equally bad to me
15:22:38 <EvilMachine> ivanm: why doesn't it fill you with disgust, to pull in whole GraphViz, for such a simple functionality? it's like buying a factory, so you can cut a piece of paper in four parts. ^^
15:22:38 <mux> but as I said, I don't know if that's feasible, and I really mean I'm not claiming it's even sensible
15:22:41 <Itkovian> ivanm: I read "Duncan passed his D.Phil viva today. The thesis will be online soon (in case you want to know far more than is healthy about stream fusion)." (via WellTyped)
15:22:42 <benmachine> mux: well, actually appending a string to an infinite one terminates in a sense :P
15:22:53 <mux> yeah :-)
15:22:56 <ivanm> EvilMachine: huh?
15:22:58 <Itkovian> So I am assuming that would be Duncan Coutts
15:23:03 <acowley> well
15:23:10 <EvilMachine> ivanm: maybe i should get a framework too? and use its factoryFactory factory. ;)
15:23:14 <ivanm> EvilMachine: I'm not suggesting you use graphviz...
15:23:14 <acowley> I implemented EvilMachine's monad, and I only used undefined twice
15:23:16 <benmachine> Itkovian: yes it's him
15:23:22 <Itkovian> Awesome.
15:23:28 <ddarius> It's the case that xs ++ ys = xs when xs is infinite so hPut (xs ++ ys) = hPut xs >> hPut ys would indeed hold.
15:23:34 <ivanm> EvilMachine: I'm suggesting you look at the result of me using a pretty-printer to generate some of its code
15:23:36 <EvilMachine> ivanm: what happen?
15:23:55 <EvilMachine> acowley: what happen? somebody set up us the monad? ;)
15:23:58 <benmachine> ddarius: yes I thought it might, but I didn't know exactly how hPut worked
15:24:14 <ivanm> Itkovian: ahhhh
15:24:20 <EvilMachine> ivanm: i'd do that
15:24:43 <ddarius> benmachine: I think there is a hPut function, but it doesn't take a String, so presumably hPutStr h (xs ++ ys) is what is intended.
15:25:02 <mux> yeah, that was only pseudo-code
15:25:10 <acowley> EvilMachine: I didn't do your line wrapping logic, http://hpaste.org/47572/a_bad_idea
15:25:20 <benmachine> ddarius: ah. so why are they not equivalent? is hPutStr not implemented as repeated hPutChar?
15:25:49 <benmachine> (I was under the impression that at least in principle it could be)
15:26:12 <monochrom> hPutStr is not implemented as repeated hPutChar in ghc
15:26:24 <wjt> Laney: aww well, my snap adventure can wait a few days
15:26:59 <EvilMachine> acowley: looking at the name, you also didn't change it so that it also follows your ideals, right? :)
15:27:51 <acowley> EvilMachine: I'm all about the mixed message
15:28:02 <parcs> i only used a single undefined: http://paste.pocoo.org/show/402474/
15:28:07 <EvilMachine> acowley: i'm not getting a mixed one though. ^^
15:28:39 <EvilMachine> acowley: thanks anyway. but now you all made me feel bad for using it
15:29:10 <EvilMachine> acowley: no idea why. looks like a really tiny piece of code for the usefulness it delivers
15:29:28 <acowley> EvilMachine: I think someone asked a similar question on haskell-cafe not that long ago. All the old-time haskellers didn't care about the per-line symbol noise, while the questioner was insistent on wanting pure whitespace ala do notation.
15:30:09 <ddarius> EvilMachine: Again, read Okasaki/Hinze.
15:31:32 <EvilMachine> ddarius: this is the first time you're writing me (i checked). don't think i'll fall for the "again" ^^
15:32:18 <ddarius> EvilMachine: [18:47] * ddarius doesn't know what EvilMachine is going on about but suggests that he read Okasaki and Hinze.
15:32:20 <ddarius> Check harder.
15:32:30 <acowley> ddarius: "read Okasaki/Hinze" is a rather heavyweight answer to pretty much any question even if good answers may there be found :/
15:32:44 <ddarius> acowley: Actually, both are pretty readable authors.
15:33:01 <EvilMachine> acowley: what i really don't understand, is why (in your experience) nobody seems to care about writing the same thing over and over again, filling it with lots of repetitive boilerplate stuff?
15:33:09 * monochrom doesn't know what the next question in #haskell is, but suggests reading the ghc user guide
15:33:19 <acowley> I agree, but both have written quite a lot and most of it requires quite a lot of thought
15:33:20 <ddarius> monochrom: Damn straight.
15:33:25 <monochrom> hehehe
15:33:31 <ddarius> acowley: Yes.
15:33:37 <aavogt> which do haskellers detest more, runIO or unsafePerformIO?
15:33:45 <aavogt> @ty runIO
15:33:45 <osfameron> 1st chapter of Okasaki's Functional datastructures wasfairly readable, even for a non-mathematician
15:33:47 <monochrom> darn, I suggested wrong :)
15:33:47 <acowley> haskellers do not detest
15:34:03 <aavogt> well runIO :: IO a -> Q a
15:34:08 <aavogt> for compile-time IO :)
15:34:20 <monochrom> oh, I don't think anyone detests runIO
15:34:27 <osfameron> the later chapters seemed to be mostly interested in explaining amortized costs, and rather lost me (I don't think I ever worked out what an amortized cost was)
15:34:32 <acowley> Okasaki's book only gets to be a slower read when you're trying to follow the analysis of some of the later structures
15:34:37 <ivanm> EvilMachine: OK, looks like I was slightly wrong; trying to do an example for you, and I can't seem to get it to properly take a long string and wrap it :s
15:34:51 <monochrom> probably because no one tried to use it yet
15:35:07 <acowley> EvilMachine: We do avoid boilerplate, see Template Haskell
15:35:07 <ddarius> Plenty of people have used it.
15:35:41 <monochrom> then no one has detested it
15:35:51 <ivanm> then again, I'm not exactly using it properly...
15:35:52 <aavogt> there's lots of boilerplate when writing template haskell though
15:35:53 <acowley> EvilMachine: in general, one either accepts list syntax as relatively minimal, then runs some sort of mconcat on the list, or learn to read things like <*> as clever commas
15:35:53 <ddarius> monochrom: Why would one?
15:36:46 <aavogt> ddarius: what order is specified for the evaluation?
15:37:17 <EvilMachine> acowley: when I see "text 1 <+> text 2 <+> text 3 <+> text 4" i immediately think of making it "fold1 (<+>) [text 1, text 2,text 3,text 4]" and then "fold1 (<+>) $ map text [1,2,3,4]"
15:37:19 <aavogt> for the Q [Dec] splices, they are sensibly from top-down, but the  ExpQ ones?
15:37:38 <geheimdienst> :t fold1
15:37:51 <geheimdienst> > 42
15:38:02 <EvilMachine> acowley: yet, you all seem to want me to write "text 1 <+> text 2 <+> text 3 <+> text 4", because for some reason "fold1 (<+>) $ map text [1,2,3,4]" is supposed to be evil.
15:38:05 <EvilMachine> :(
15:38:08 <erus`> @hoogle IO Int
15:38:14 <geheimdienst> cale: you around? lambdabot has been helping herself to catnip again
15:38:30 <aavogt> do you know the associativity of <+>?
15:38:36 <ddarius> class Ln a where ln :: a -> String; instance Ln String where ln = id; instance Ln b => Ln (String -> b) where ln s x = s ++ '\n':ln x; foo = ln "foo" "bar" "baz"
15:38:55 <erus`> @hoogle randomIO
15:39:14 <monochrom> System.Random
15:39:32 <EvilMachine> acowley: and i'd do "nice = fold1 (<+>) $ map text" anyway
15:39:33 <ivanm> EvilMachine: http://hpaste.org/47573/sample_for_evilmachine
15:39:35 <EvilMachine> :)
15:40:05 <EvilMachine> ivanm: a example you can live with? :)
15:40:09 <ivanm> yup
15:40:17 <ivanm> I forgot some of the combinators already did what I wanted
15:40:23 <erus`> how can i get n items from randomIO?
15:40:32 <monochrom> run it n times
15:40:33 <ivanm> note that I could have taken the align and put it inside document rather than defining $$
15:40:44 <ivanm> erus`: replicateM
15:41:14 <EvilMachine> ivanm: oh boy. what's that "text" and "$$" doing there, on each line??
15:41:41 <ivanm> EvilMachine: so, text :: Text -> Doc
15:41:43 <EvilMachine> ivanm: looks messy
15:41:48 <EvilMachine> ivanm: wrappers again
15:41:51 <ivanm> and $$ is used for "here are two separate subsections I want to join"
15:41:58 <EvilMachine> ivanm: boilerplate
15:42:01 <ivanm> EvilMachine: you have to have a wrapper for your  monad version, don't you?
15:42:23 <ivanm> EvilMachine: but if you install wl-pprint-text and then run that, you'll see that all the blahs get nicely wrapped and formatted
15:42:37 <EvilMachine> ivanm: having to write "text" and "$$" more than once, is a FAIL in terms of abstracting common stuff (boilerplate) out. :)
15:42:47 <ivanm> you can use a list of Strings if you want
15:42:59 <ddarius> , is boilerplate!
15:43:07 <ivanm> EvilMachine: the point is, rather than using String throughout, you use Doc
15:43:27 <monochrom> maybe "text" is too much wrapper but $$ is not boilerplate. computer cannot possibly know whether you want $$ or <+> or whatever there
15:43:43 * ivanm contemplates an IsString instance for Doc where fromString = fillSep . map text . words
15:43:56 <aavogt> it could assume one if you put nothing there
15:44:02 <EvilMachine> ivanm: so another layer on top for no reason? it's not more efficient to have one more layer, and it is more code to write that e.g. acowley's solution. sorry.
15:44:05 <monochrom> if I write "a+b+c" you don't complain that "+" is boilerplate and I am writing it twice
15:44:15 <EvilMachine> that=than
15:44:19 <ivanm> monochrom: ZOMG! boilerplate!!!
15:44:31 <ddarius> monochrom: sum [a,b,c]
15:44:37 <periodic> monochrom: obviously you write foldr 0 (+) [a,b,c]
15:44:43 <ivanm> where's acowley's solution?
15:44:44 <monochrom> because another day I may want to write "a-b*c" instead
15:44:46 <ddarius> periodic: No you wouldn't.
15:45:00 <periodic> ddarius: you are correct.
15:45:19 <periodic> I haven't written any haskell for over a month. :(
15:45:19 <ddarius> periodic: You'd write foldl' (+) 0 [a,b,c]
15:45:25 <EvilMachine> monochrom: but if i have to write "addPrepare a `plus` addPrepare b `plus` addPrepare c `plus` addPrepare d", which is ivanm's suggestion, i *definitely* do. ^^
15:45:41 <periodic> ddarius: in this case foldr and foldl' don't net much of a difference, right?
15:46:06 <ddarius> periodic: For 3 elements, no.  foldr is potentially slightly more defined.
15:46:18 <ivanm> EvilMachine: you can always use a list-based variant
15:46:28 <ddarius> @hoogle hsep
15:46:29 <ivanm> in this case, align . vsep . map text
15:46:39 <parcs> :t text
15:46:44 <ivanm> parcs: no bot
15:46:45 <aavogt> String -> Text
15:46:52 <aavogt> Doc
15:47:13 <monochrom> "text" is from a pretty-printer library. find it in the haskell platform
15:47:22 <acowley> EvilMachine: http://hpaste.org/47574/less_bad
15:47:30 <parcs> found it :)
15:47:31 <periodic> ddarius: suppose if I were doing a long list or a generated list, foldr would have to scan to the end before it could begin summing, right?
15:47:38 <ivanm> monochrom: well, I was actually using the wl-pprint-text version.... ;-)
15:47:52 <monochrom> nice
15:47:52 <acowley> that doesn't look so much worse than the monad variant, and you could use some TH if you really wanted to optimize
15:48:05 <parcs> maybe there should be an IsString instance for Doc ?
15:48:10 <parcs> to avoid text boilerplate
15:48:19 <ivanm> acowley: what's ala ?
15:48:27 <ivanm> parcs: I just said that up above :p
15:48:34 <parcs> oh
15:48:54 <ivanm> but IMHO that's very rarely useful, as you generally don't have that many static Strings (at least in my experience)
15:49:32 <EvilMachine> ivanm: http://hpaste.org/47575/simple_wraptext_with_pretitle my current text wrapper
15:49:44 <acowley> ivanm: it's just a way of getting at newtype functionality. It's from McBride, maintained by djahandarie.
15:49:45 <EvilMachine> ivanm: modified from Distribution.Simple.Utils.wrapText
15:50:31 <ddarius> acowley: See my solution.
15:51:00 <ddarius> ivanm: Your instance would be wrong anyway.
15:51:10 <ivanm> EvilMachine: wow, that looks inefficient... :p
15:51:14 <ivanm> ddarius: oh? why?
15:51:29 <ivanm> because of dealing with newlines?
15:51:40 <EvilMachine> ivanm: i just took it from there. don't blame me. ;)
15:51:49 <ddarius> Why the heck do you compose with identity?!
15:52:02 <ivanm> EvilMachine: this is what I said earlier: using combinators with Doc is more efficient than using ++ repeatedly
15:52:09 <ivanm> ddarius: where?
15:52:37 <aavogt> concatMap (map ((\s -> s) . unwords)
15:52:54 <ddarius> ivanm: Re your instance, your definition is not the expected one and likely very often not the desired one.
15:52:55 <nihtml> hmmm
15:53:02 <EvilMachine> ivanm: i think we are talking about differen efficiencies here
15:53:22 <EvilMachine> ivanm: in my case, writing efficiency stomps execution efficiency
15:53:27 <ivanm> ddarius: oh, the IsString for Doc? *shrug* what would you suggest?
15:54:01 <ddarius> ivanm: text obviously.
15:54:01 <EvilMachine> ivanm: because right now, version 1 of my code, of which the haskell version is version 2, is written in bash.
15:54:02 <nihtml> why do you use (\s -> s), aavogt?
15:54:17 <aavogt> it's from EvilMachine's paste
15:54:33 <EvilMachine> ivanm: and weren't it for calling qalc 100 times in a loop, it would already be fast enough. :)
15:54:38 <ivanm> ddarius: sure, if you don't want it to re-flow what you have
15:55:00 <ddarius> ivanm: If I want it to do that, I'll tell it to.
15:55:34 <ivanm> ddarius: *shrug* wouldn't it be better for it to do the "right thing" ?
15:55:53 <ivanm> as just now when doing the example for EvilMachine, I thought just using text _did_ go and replace spaces, newlines, etc.
15:56:18 <ddarius> ivanm: The "right thing" is for it to do what you tell it to.
15:56:21 <EvilMachine> what drugs is jaspervdj using, when he thinks prozac is for pussies?? crystal meth with a dash of lsd? ;)
15:56:47 <geheimdienst> ddarius: that sounds like the road to assembly
15:56:56 * ddarius huggles assembly.
15:57:09 <ddarius> geheimdienst: A lot of Haskell style is about being explicit.
15:57:26 <ddarius> geheimdienst: This is a semantic difference, not just an implementation detail.
15:58:07 <ivanm> ddarius: except that for starters, text can choke if you have newlines in the String
15:58:19 <EvilMachine> ddarius: pfft. assembly... C-x M-c M-butterfly! ;)
15:58:28 <ddarius> EvilMachine: Pfft emacs.
15:58:59 <EvilMachine> ddarius: what if i run emacs in this: http://bellard.org/jslinux/ (warning, this is the programming equivalent of goatse to Haskell programmers!)
15:59:13 <ddarius> EvilMachine: It's still emacs.
15:59:37 <EvilMachine> ddarius: i meant: would you rip all your hair out and stab your eyes in horror? ;)
15:59:42 <geheimdienst> ivanm: could you put your IsString instance in an extra module? people who want the extra magic would import that, and purists would stick to the basic module
16:00:06 <ivanm> geheimdienst: yeah; I'm not saying I'm going to do it _right now_
16:00:13 <ddarius> geheimdienst: That's usually a horrible solution.
16:00:27 <EvilMachine> ddarius: "That's usually a horrible solution.
16:00:31 <EvilMachine> oops
16:00:37 <ivanm> but I'm thinking of writing a new class-based pretty-printing library with a new-ish API (since some people whinged about current ones using <+>, etc.)
16:00:59 <geheimdienst> ddarius: *shrug* propose something else
16:01:00 * EvilMachine assignes "That's usually a horrible solution." to a shortcut. ;)
16:01:12 <ddarius> geheimdienst: I propose to do nothing.
16:01:22 <ddarius> Mission accomplished.
16:01:40 <EvilMachine> ivanm: don't. have a beer of your choice from me, and all is forgotten. :)
16:02:06 <ivanm> EvilMachine: I do not imbibe!
16:02:14 <ivanm> and I'm not doing this for _you_!
16:02:20 <ivanm> (lispy proposed it to me!)
16:02:32 <EvilMachine> ivanm: i'm just trying to be nice. :(
16:02:40 <ivanm> heh
16:02:40 <ivanm> np
16:02:52 <nyingen> can we buy beer with Bitcoins yet?
16:02:53 <EvilMachine> ivanm: have i started a endless bloody feud? ;)
16:03:15 <ivanm> nah
16:03:21 <EvilMachine> nyingen: don't get me started on Bitcoins. I might stab somebody. ^^
16:03:26 <ivanm> feuds take too much effort!
16:03:40 * ddarius kindly offers cirrhosis and dying brain cells.
16:03:45 <osfameron> even endless bloody feuds are manageable with laziness
16:04:11 <EvilMachine> ivanm: don't think i'd move a hand. i'll have bionic servants!
16:04:22 * EvilMachine now goes back on topic. :)
16:06:21 * EvilMachine is going to write a paper, using psychology based on neurology based on biochemistry based on physics, that mathematicians are not humans.
16:06:36 * EvilMachine is then building a bomb shelter
16:18:25 * hackagebot xhtml-combinators 0.3 - Fast and easy to use XHTML combinators.  http://hackage.haskell.org/package/xhtml-combinators-0.3 (AlasdairArmstrong)
16:20:32 <robinhoode> He needs a top-hat.. http://www.bracha.org/Site/Home.html
16:21:23 <robinhoode> He needs to be trolling in style..
16:22:50 <monochrom> @bots
16:24:48 <shachaf> Cale/lispy: lambdabot is dead, by the way.
16:34:59 <parcs> > text "Hello World!"
16:35:05 <lambdabot>   Hello World!
16:35:15 <thom_logn> Hello. new-ish question here. By "running in the monad" they are speaking of a function with the monadic sig withing a series of funcs composed with bind?
16:35:29 <thom_logn> er, within
16:35:33 <monochrom> I think yes
16:35:45 <geheimdienst> sounds about right
16:35:59 <dibblego> thom_logn: it's loose terminology, but it usually means that yes
16:36:08 <thom_logn> Woo! That phrase has mystefied me for months
16:36:47 <monochrom> I don't usually speak like that, indeed. I just show actual code, rather than describe with flowery words.
16:37:10 <thom_logn> LOL A lot of google results use the phrase :)
16:38:14 <dibblego> same, not a fan of anti-concrete
16:38:55 <ddarius> Don't withhold your munificence from us, monochrom.
16:39:01 <thom_logn> So part of the power of monads seems to be (when you eventually "get it") is you are sort of programing at the level of types, not functions per se?
16:39:50 <dibblego> thom_logn: this is how I explain monads http://blog.tmorris.net/what-does-monad-mean/
16:39:58 <c_wraith> thom_logn: Not really.  It's just a convenient abstraction that covers a lot of different use cases.
16:40:07 <monochrom> not at the level of types. but different from plain functions, yes
16:40:17 <c_wraith> type-level programming is quite a bit different from that.
16:40:26 <tgeeky> ok, say I have a set of data types to represent the periodic table, and I have an external data file that I can parse which has all the data for it. How do I actually fill in the data types automatically? Using template haskell?
16:40:29 <thom_logn> ah
16:41:53 <wmoss> Hey, I was wondering if anyone knew of a concurrent connection pool. I couldn't fine anything on hackage.
16:42:31 <c_wraith> wmoss: I've written 3 different strategies for them.  It's honestly something so simple no one has bothered putting on hackage.
16:42:41 <thom_logn> going to watch that video now. one other random Q: What do you have if you have a functor that doesn't obey the identity law? is that an arrow or something?
16:43:13 <wmoss> c_wraith: Yeah, I hear that...I just figured I might as well not reinvent the wheel if I didn't have to
16:43:53 <dibblego> thom_logn: an endomorphism perhaps
16:44:04 <tgeeky> for instance, my data type so far has:
16:44:30 <tgeeky> Isotope (P 1) Nothing Nothing "H" "Hydrogen"
16:44:47 <tgeeky> and I have a table of:
16:44:56 <tgeeky> Isotope (P 7) Nothing Nothing "N" "Nitrogen"
16:44:58 <tgeeky> and so on
16:45:25 <tgeeky> (Nothing Nothing) being the # Neutrons and # Electrons, which I don't care about yet
16:45:27 <geheimdienst> tgeeky: so you want to read that table at runtime?
16:45:47 <tgeeky> geheimdienst: or compile time, but I want to export the module with all the defs included
16:46:07 * BMeph wonders why you'd need to keep separate track of the electrons...
16:46:16 <geheimdienst> compile time sounds easier to me :)
16:46:18 <tgeeky> BMeph: because it allows for Ions too
16:46:26 <tsuraan_> is there some way to exit a fold[lr] before reaching the end of the list/bytestring that you're iterating over?
16:46:40 <tsuraan_> aside from throwing an exception, I guess
16:46:44 <dibblego> tsuraan_: r/yes l/no
16:46:50 <BMeph> tgeeky: Well, why not just have the charge? ;þ
16:47:05 <dibblego> > head $ foldr (:) [] [4..]
16:47:06 <lambdabot>   4
16:47:18 <tgeeky> Berengal: I don't want to store any Floating data yet
16:47:36 <tgeeky> BMeph: i don't want to store any Floating data, yet... I just want names, abbreviations, and numbers
16:47:49 <tgeeky> but no matter, how do I populate this? Template Haskell? Is there something else obvious I'm missing?
16:47:54 * BMeph is now wondering what Floating has to do with ions...
16:47:57 <tgeeky> I am generating the data with Mathematica
16:48:04 <tgeeky> BMeph: storing partial charge
16:48:25 <BMeph> tgeeky: ?
16:48:25 <tsuraan_> dibblego: that's weird; I don't think I understand what it means to fold from right to left...
16:48:27 <tgeeky> I could just ignore electrons and have an Ion variant with +1
16:48:39 <harlekin> I am using happstack-heist, and I have <post><postname /></post>. However, in the splice bound to the post tag I am using getParamNode to get what's inside the post-tag. However, postname doesn't get evaluated. Shouldn't it be?
16:48:40 <dibblego> tsuraan_: you mean foldl?
16:49:17 <tsuraan_> dibblego: I thought foldl started at the beginning and foldr started at the end, but since you can foldr on an infinite list, that must be wrong
16:49:21 <parcs> > foldr (+) x [f, g, h]
16:49:22 <lambdabot>   f + (g + (h + x))
16:49:29 <parcs> > foldl (+) x [f, g, h]
16:49:30 <lambdabot>   x + f + g + h
16:49:36 <BMeph> tgeeky: How would you get "partial charge" on an ion?
16:49:38 <parcs> >_>
16:49:39 <dibblego> tsuraan_: that's a bit of a simplification
16:49:45 <geheimdienst> tgeeky: the data will be about 100-120 short lines. is there any problem with taking vim and editing that table once and for all?
16:50:02 <tgeeky> geheimdienst: nope, I'll do it that way... though it is a little longer
16:50:04 <dibblego> tsuraan_: foldl is very much like a loop in an imperative language, while foldr k z replaces all (:) with k and [] with z
16:50:34 <geheimdienst> (related: check out vim's block edit mode, if you're not already aware of it. or the emacs equivalent, i'm sure there is one)
16:50:46 <tgeeky> BMeph: I concede. I could store things in terms of 1 = e.
16:51:33 <tsuraan_> dibblego: so if you're folding a function over a bytestring, is there any way for that function to indicate that it wants the folding to stop?
16:51:49 <BMeph> tgeeky: Holy crikeys, don't tell me you're thinking of storing things by Coulombs?!? I'd weep for you if you were.... =8*0
16:51:54 <aavogt> http://hpaste.org/47576/are_these_valid does somebody have suggestions for these monad instances?
16:52:13 <tgeeky> BMeph: I didn't want to store anything about charge or antyhing else yet, because I'm just using this to demonstrate a pretty-printer.
16:52:18 <dibblego> tsuraan_: there will be combinators for it e.g. take 5 will "stop" after 5 elements
16:52:25 <tgeeky> BMeph: and I don't want to handle arithmatic precision
16:52:34 <aavogt> here X is from xmonad (ie. it is  ReaderT r (StateT s IO))
16:52:47 <tsuraan_> but if only the function being folded knows when to stop, you're out of luck?
16:53:54 <dibblego> tsuraan_: I don't think you're out of luck, but if you could be more precise, maybe more specific help can be provided
16:54:28 * BMeph nudges dibblego, and "coughs" *logical functions* ;)
16:54:50 <BMeph> Excuse me, must be a summer cold coming on... ;þ
16:54:58 <tsuraan_> ok, what I really want is a version of Data.ByteString.span where rather than taking a function of (Word8 -> Bool) it takes a function like foldl/foldr does, so I can keep some state along with me
16:56:12 <tsuraan_> I wrote one myself, where the function's signature is (a -> Word8 -> Maybe a), but my fold has to use Data.ByteString.uncons to get the first byte of the bytestring, and it builds the first bytestring as a [Word8] and then does a reverse and a pack, and it's really slow :(
16:56:20 <BMeph> tgeeky: Okay, I'll quit harassing you now. ;)
16:57:01 <tgeeky> BMeph: I still don't know what the best way to load this is. I could fix the Haskell->Mathematica link
16:57:01 <kmc> tsuraan_, you can fold to determine the split index, and then call splitAt
16:57:09 <tgeeky> BMeph: or... *shrugs*
16:57:33 <tsuraan_> kmc: I thought of that, but I don't know how to get the fold to stop running, so it just folds over the entire bytestring
16:57:53 <aavogt> > let take_ k = foldr (\a (n,as) -> -> if n > k then (n,as) else (n+1, a:as)) (0,[]) in take_ 5 [1..]
16:57:56 <lambdabot>   <no location info>: parse error on input `->'
16:58:02 <aavogt> > let take_ k = foldr (\a (n,as) -> if n > k then (n,as) else (n+1, a:as)) (0,[]) in take_ 5 [1..]
16:58:04 <lambdabot>   *Exception: stack overflow
16:58:13 <geheimdienst> tgeeky: i think simple copy-pasting is justified in this case. it's pretty static data. it's not like you need to have it automated so you can re-export it tomorrow ...
16:58:30 <tgeeky> geheimdienst: well, the isotope table is pretty big :o
16:58:37 <tgeeky> I guess once I have it in the right format... :o
16:59:50 <kmc> tsuraan_, maybe laziness will save you
16:59:59 <tsuraan_> kmc: yeah, I was just thinking that
17:00:20 <tsuraan_> kmc: maybe I want to return a list of all the index values in the bytestring?
17:00:34 <tsuraan_> I'll see if I can do that
17:01:13 <tsuraan_> I just keep thinking that the ByteString.fold is going to run to completion no matter what I do, but that isn't how it works.  going to go crazy :)
17:01:27 <geheimdienst> «case x' of Just (s, x'') | WSF y <- f x'' -> y s» what's that, a view pattern?
17:01:33 <kmc> pattern guard
17:01:39 <geheimdienst> thanks
17:01:52 <aavogt> that feature should be in h2010
17:02:04 <kmc> isn't it?
17:02:20 <c_wraith> that's so much better an idea than fail...
17:02:22 <aavogt> ghc-7 doesn't complain about them anymore
17:02:33 * cmccann enjoys using guards on bindings for non-functions
17:02:48 <cmccann> e.g. let foo | x > 5 = ...
17:02:54 <kmc> yeah, that can be convenient
17:03:12 <cmccann> for some reason it always surprises me that it works
17:03:49 <ddarius> > let foo | foo = False | otherwise = True in foo
17:03:53 <lambdabot>   mueval-core: Time limit exceeded
17:03:56 <cmccann> haha
17:04:24 <c_wraith> so, we get lambdabot back, and the first thing you do is throw an infinite loop at her? :)
17:04:38 <cmccann> > fix error
17:04:40 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
17:04:57 <cmccann> much better
17:05:02 <kmc> :D
17:05:04 <kmc> ♥ that
17:05:23 <luite> it's exceptions all the way down
17:05:28 <cmccann> possibly the most self anti-documenting expression possible
17:05:36 <cmccann> "oh, I have an error, better fix it"
17:05:41 <cmccann> oooooops
17:06:11 <tsuraan_> if a fold returns (a, [b]), then because tuples contents are lazy you can just do a head on the list part of the tuple, and the fold will only run long enough to generate that first value, right?
17:06:47 <tsuraan_> evaluating the the a part of the (a,[b]) would force full evaluation of the fold, but the [b] part is as lazy as I need it to be?
17:07:05 <kmc> evaluating the 'a' part will not necessarily force full evaluation
17:07:18 <kmc> i mean, what if a = [c]
17:07:22 <tsuraan_> right
17:07:42 <tsuraan_> in my case a is Word32, so evaluating that will force the full fold, right?
17:07:59 <kmc> that depends on the function you're folding
17:08:26 <kmc> > foldr (\_ _ -> 3) 0 [1..]
17:08:26 <lambdabot>   3
17:08:40 <kmc> remember that you're forcing the (,) constructor as well
17:09:03 <aavogt> @let take_ k xs = foldr (\a b n -> if n >= k then [] else a:b (n+1)) (const []) xs 0
17:09:16 <kmc> if you want to take apart a pair without immediately forcing the (,) constructor, you can use an "irrefutable" pattern-match
17:09:19 <aavogt> > take_ 3 "hello"
17:09:24 <parcs> hmm, did lambdabot die again? :(
17:09:37 <lambdabot>  thread killed
17:09:38 <kmc> > case undefined of (x,y) -> "ok"
17:09:47 <thom_logn> it's feeling much better
17:09:51 <lambdabot>   thread killed
17:09:54 <kmc> urk
17:09:54 <lambdabot>   "*Exception: Prelude.undefined
17:09:56 <kmc> > case undefined of ~(x,y) -> "ok"
17:09:58 <lambdabot>   "ok"
17:10:06 <kmc> > case undefined of ~(x,y) -> x
17:10:07 <ddarius> > foldr (\_ _ -> ((),[])) undefined (undefined:undefined)
17:10:22 <tsuraan_> I've never seen that
17:10:31 <lambdabot>   thread killed
17:10:32 <lambdabot>   thread killed
17:10:37 <tsuraan_> poor lambdabot
17:11:12 <tsuraan_> so the "~(x,y) -> x" gives x without forcing the (,)?
17:11:28 <kmc> it forces the (,) when you force x
17:11:36 <c_wraith> but not before, which is the handy party
17:11:39 <c_wraith> err, part
17:11:49 <kmc> the pattern ~p matches anything
17:12:03 <Peaker> It's almost as if Haskell has unlifted type products
17:12:08 <kmc> if you later force one of the variables bound by p, it will go back and do the pattern match
17:12:08 <parcs> does anyone know how to fix this dependency error when attempting to use hint: http://paste.pocoo.org/show/402530/
17:12:13 <kmc> and error out ungracefully if it fails
17:12:19 <c_wraith> Peaker: that's unpossible!
17:12:29 <kmc> > case Nothing of (Just x) -> 0; Nothing -> 1
17:12:33 <lambdabot>   mueval-core: Time limit exceeded
17:12:36 <kmc> what
17:12:42 <kmc> > case Nothing of (Just x) -> 0; Nothing -> 1
17:12:43 <lambdabot>   1
17:12:45 <kmc> > case Nothing of ~(Just x) -> 0; Nothing -> 1
17:12:46 <lambdabot>   0
17:12:48 <kmc> > case Nothing of ~(Just x) -> x; Nothing -> 1
17:12:49 <lambdabot>   *Exception: <interactive>:(3,0)-(4,21): Irrefutable pattern failed for patt...
17:12:54 <Peaker> it should measure CPU time or resource use rather than wall clock time
17:13:36 <tsuraan_> that's really weird
17:13:37 <Peaker> Why isn't that a syntax error?  Irrefutable Just match contradicts any other pattern match, doesn't it?
17:13:46 <aavogt> parcs: your ghc install looks broken
17:14:02 <kmc> Peaker, that's not really a syntactic issue
17:14:09 <Peaker> kmc: it could be
17:14:12 <kmc> it's not a syntax error to have overlapping patterns in general, even unreachable ones
17:14:14 <aavogt> template-haskell-2.5.0.0-957162165c2e6480a35f6d14f7e5220f is supposed to come with the compiler
17:14:21 <kmc> GHC can warn about those, but i wouldn't call it a "syntax warning"
17:14:25 <tsuraan_> ghci does complain about overlapping patterns there
17:14:26 <Peaker> kmc: irrefutable pattern match could have exclusiveness in case
17:14:27 <kmc> the program's AST is perfectly well-formed
17:14:36 <Peaker> or even its own case syntax
17:14:41 <kmc> that syntax would be "let"
17:14:47 <ddarius> kmc beat me to it
17:14:49 <kmc> > let Just x = Nothing in 0
17:14:50 <lambdabot>   0
17:14:51 <kmc> > let Just x = Nothing in x
17:14:52 <lambdabot>   *Exception: <interactive>:3:4-19: Irrefutable pattern failed for pattern Da...
17:14:58 <BMeph> Irrefutable matches always match, by definition. ;)
17:15:05 <Peaker> does it ever make sense to have a refutable pattern match alongside any other pattern match in a case?
17:15:14 <ddarius> BMeph: A follower of Boole I see.
17:15:15 <Peaker> (or in a function definition)
17:15:22 <kmc> s/alongside/before/, then no
17:15:36 <kmc> and s/refutable/irrefutable/, or did i totally misinterpret
17:15:39 <BMeph> ddarius: No, I just know what the word "irrefutable" means. ;þ
17:15:42 <Peaker> so it could/should be disallowed syntactically
17:15:47 <aavogt> Peaker: you can put the ~ inside a pattern, where otherwise you'd end up with some nested case and let
17:15:48 <kmc> shrug
17:15:53 <Peaker> kmc: yeah, I meant irrefutable
17:16:04 <Peaker> aavogt: ah, I see
17:16:18 <kmc> you propose to complicate the grammar of the language for something that compilers can implement as a separate warning anyway
17:16:19 <aavogt> > case Just undefined of Just (~ (a,b) ) -> a
17:16:20 <lambdabot>   *Exception: Prelude.undefined
17:16:23 <aavogt> > case Just undefined of Just (~ (a,b) ) -> 5
17:16:25 <lambdabot>   5
17:16:56 <c_wraith> for a more useful use of irrefutable pattern matches, take a look at
17:16:57 <BMeph> BBL; windoze is sleeping on the job again... :p
17:16:58 <c_wraith> @src unzip
17:16:58 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
17:17:12 <kmc> good one
17:17:16 <c_wraith> that irrefutable match is *really* important
17:17:21 <aavogt> > case Just undefined of Just (~(~(~ (a,b))) ) -> 5 -- extra emphasis?
17:17:22 <lambdabot>   5
17:17:36 <tsuraan_> so my idea is this, but it doesn't work: "head $ snd $ foldr (\x (s,l) -> (s+1,x:l)) (0, []) [1..]"
17:18:21 <aavogt> > case Just undefined of Just (~ ~ ~ ~ ~ (a,b) ) -> 5 -- parens unnecessary
17:18:22 <lambdabot>   5
17:18:23 <tsuraan_> is it because I'm evaluating the pair?
17:18:33 <kmc> did you try «~(s,l) -> ...»
17:18:51 <tsuraan_> that does work
17:19:04 <tsuraan_> but I don't see why
17:19:24 <ddarius> > let ~ ! ! ! ! ! !x  = 3 in 1
17:19:26 <lambdabot>   <no location info>: parse error on input `!'
17:19:35 <tsuraan_> take 10 $ snd $ foldr (\x ~(s,l) -> (s+1,x:l)) (0, []) [1..]
17:19:41 <thom_logn> so if the sig of a monad is  ma -> (a -> mb) -> mb does that mean the next function it is chained with sig is m b -> (b -> c) -> m c?
17:19:41 <tsuraan_> > take 10 $ snd $ foldr (\x ~(s,l) -> (s+1,x:l)) (0, []) [1..]
17:19:42 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
17:20:41 <tsuraan_> > 2 .&. 3
17:20:43 <lambdabot>   Ambiguous type variable `a' in the constraint:
17:20:43 <lambdabot>    `Data.Bits.Bits a'
17:20:43 <lambdabot>      a...
17:20:50 <tsuraan_> > 2 .&. 3 :: Int
17:20:51 <lambdabot>   2
17:20:55 <ddarius> let r@Google.com = undefined in 1
17:21:51 <thom_logn> does my Q make sense?
17:22:48 <geheimdienst> thom_logn: do you have a concrete example?
17:23:10 <thom_logn> LOL no, that's why I'm asking the question :)
17:23:22 <aavogt> thom_logn: are you distinguishing  ma from (m a)?
17:23:27 <thom_logn> don't know what I'd google to find an answer
17:23:37 <thom_logn> no, lack of space was typo
17:24:38 <thom_logn> So far I've imagined all the functions in the chain had the same sig, just realizing that's not true and looking for examples
17:24:42 <geheimdienst> i think the signature m a -> (a -> m b) -> m b means that given the two arguments, you get an m b. you can put it into any function that takes one. a function of type m b -> (b -> c) -> m c is fine, for example
17:24:52 <aavogt> and the second type is  m b -> (b -> m c) -> m c?
17:26:06 <tsuraan_> > take 10 $ snd $ foldr (\x ~(s,l) -> if (x .&. 1) == 1 then (s+1,x:l) else (s+1,(x*2):l)) (0, []) [1..]
17:26:07 <aavogt> the difference is just return, though that means your "chained with" doesn't translate to something a single haskell function does
17:26:08 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:26:08 <lambdabot>    `Data.Bits.Bits a'
17:26:08 <lambdabot>      ...
17:26:25 <tsuraan_> > take 10 $ snd $ foldr (\x ~(s,l) -> if (x .&. 1) == 1 then (s+1,x:l) else (s+1,(x*2):l)) (0 :: Int, []) [1..]
17:26:26 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:26:26 <lambdabot>    `Data.Bits.Bits a'
17:26:26 <lambdabot>      ...
17:27:04 <tsuraan_> heh.  works in ghci.  I think that's exactly what I need, so thanks a ton!
17:27:11 <tsuraan_> crazy new syntax to try to understand :)
17:27:19 <thom_logn> meaning the monad's "return" is polymorphic and that is works?
17:27:42 <aristid> @src foldrM
17:27:43 <lambdabot> Source not found. :(
17:29:15 <thom_logn> ah, okay, that is how assignment in do blocks work, by returning different types
17:33:59 <aavogt> thom_logn: all the m are the same
17:45:47 <dankna> :t Fix
17:45:48 <lambdabot> Not in scope: data constructor `Fix'
17:45:55 <dankna> @hoogle Fix
17:45:57 <lambdabot> module Control.Monad.Fix
17:45:57 <lambdabot> Data.Function fix :: (a -> a) -> a
17:45:57 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
17:49:29 <thom_logn> what a strange function
17:49:52 <dankna> the only winning move is not to play?
17:50:14 <thom_logn> heh
17:50:26 <thom_logn> you must be an old timer
17:50:32 <dankna> afraid so
17:50:33 <cmccann> :t fmap fix return
17:50:34 <lambdabot> forall a. a -> a
17:51:00 <thom_logn> me too, trying to learn haskell is making me feel even older
17:51:19 <dankna> you'll get there
18:12:41 <conquistador> @help
18:12:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:12:42 <ivanm> I have a bunch of QC properties that take in a value first which is used just to set which instance should be tested
18:13:28 <ivanm> how can I write a function that takes in said properties and applies them to a hard-coded list of said instances?
18:13:29 <conquistador> @run 1 *2
18:13:31 <lambdabot>   2
18:13:33 <ivanm> (specifically the type sig)
18:13:43 <ivanm> > text "hi conquistador"
18:13:44 <lambdabot>   hi conquistador
18:14:02 <ivanm> having "> " at the beginning is an alias for @run
18:14:17 <ddarius> ivanm: The issue being that it will instantiate the property to different types?
18:14:33 <sm> yay, sigplan award
18:14:39 <conquistador> ivanm++
18:15:24 <ivanm> ddarius: yeah
18:15:33 <ivanm> do I need a forall or something?
18:20:34 <ivanm> i.e. I'm doing something like: testProp prop = [quickCheckResult . prop $ (undefined :: Int), quickCheckResult . prop $ (undefined :: Double)]
18:20:53 <ddarius> :t let f :: (forall n. Num n => n -> Bool) -> Bool; f g = g (3 :: Integer) in f (> 0)
18:20:54 <lambdabot>     Could not deduce (Ord n) from the context (Num n)
18:20:54 <lambdabot>       arising from a use of `>' at <interactive>:1:78-80
18:20:54 <lambdabot>     Possible fix:
18:21:10 <ddarius> :t let f :: (forall n. Num n => n -> Bool) -> Bool; f g = g (3 :: Integer) in f (== 0)
18:21:11 <lambdabot> Bool
18:21:16 <ddarius> > let f :: (forall n. Num n => n -> Bool) -> Bool; f g = g (3 :: Integer) in f (== 0)
18:21:17 <lambdabot>   False
18:21:31 <ivanm> ta
18:22:38 <ivanm> which extension do I need for that?
18:23:36 <ddarius> > let f, g :: (forall n. Num n => n -> Bool) -> Bool; f k = k (3 :: Integer); g k = k (0 :: Double); test x = x == 0 in map test [f, g]
18:23:37 <lambdabot>   Cannot match a monotype with `(forall n.
18:23:37 <lambdabot>                                 (G...
18:23:57 <ddarius> Expected as much.
18:26:38 <ddarius> > let fs :: (forall n. Num n => n -> Bool) -> [Bool]; f k = [k (3 :: Integer), k (0 :: Double)]; test x = x == 0 in fs test
18:26:38 <lambdabot>   The type signature for `fs' lacks an accompanying bindingNot in scope: `fs'
18:26:48 <ddarius> > let fs :: (forall n. Num n => n -> Bool) -> [Bool]; fs k = [k (3 :: Integer), k (0 :: Double)]; test x = x == 0 in fs test
18:26:48 <lambdabot>   [False,True]
18:30:04 <aavogt> ivanm: you could use -XTemplateHaskell instead
18:30:16 <ivanm> aavogt: why?
18:32:25 <aavogt> because it looks more direct than using continuations containing Rank2Types
18:32:54 <ddarius> Using an actual existential would probably be more sensible.
18:33:04 <ivanm> you mean I should define TH code to define what I want?
18:33:17 <isomorphic> incidentally - the -X options to ghc - do they enable deviations from Haskell98?
18:33:20 <ivanm> or just use the TH extension?
18:33:28 <ivanm> isomorphic: yes
18:33:30 <ivanm> they're extensions
18:33:39 <ivanm> some of them have made it into haskell2010
18:33:45 <ivanm> most are GHC-specific
18:35:01 <ivanm> I wish -Wall was smarter... I have an internal module that defines some types, which are then re-exported from several other modules; -Wall keeps bitching about them though :@
18:35:43 <ivanm> aavogt, ddarius: so what are you suggesting I use/do ?
18:36:14 <isomorphic> ivanm: thanks :)
18:37:40 <mjrosenb> should there be any problems using unsafePerformIO to parse command line arguments?
18:37:42 <dankna> :t maybe
18:37:43 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:37:48 <dankna> :t fromMaybe
18:37:49 <lambdabot> forall a. a -> Maybe a -> a
18:38:28 <ddarius> mjrosenb: http://neilmitchell.blogspot.com/2011/05/cmdargs-fighting-ghc-optimiser.html
18:40:55 <tsuraan_> in the profile for my program, main
18:41:05 <tsuraan_> *main's entry count is 2.  is that normal?
18:41:40 <dankna> no, I don't think so
18:42:04 <isomorphic> mjrosenb: Out of curiosity, what is the benefit in your case of wanting to use unsafePerformIO?
18:43:11 <tsuraan_> it's sort of strange: MAIN has entry count of 0, main has entry count of 2.  maybe it's ok, since they average out to 1 :)
18:43:34 <aavogt> ivanm: like this http://hpaste.org/47578/ivanm ?
18:44:29 <mjrosenb> isomorphic: i want each unit of my project to have a separate verbosity level
18:44:44 <mjrosenb> isomorphic: and rather than having *every* function take its verbosity level as an argument
18:44:56 <mjrosenb> or *every* function be in the IO monad
18:44:56 <aavogt> that way you can use the   testAtTypes "function" without deciding on a class
18:45:04 <ivanm> aavogt: ts is hard-coded in, so having it specified in a list isn't strictly necessary
18:45:24 <ddarius> @google haskell implicit configurations
18:45:26 <lambdabot> http://www.cs.rutgers.edu/~ccshan/prepose/p1214-kiselyov.pdf
18:45:26 <lambdabot> Title: Functional Pearl: Implicit Configurations
18:45:32 <mjrosenb> i want to parse the verbosity level out of the command line, and store it in a variable in each module.
18:45:48 <ivanm> also, that would entail yet another module for the TH splice definition :/
18:46:04 <mjrosenb> ddarius: is that for me or someone else?
18:46:09 <ivanm> since this function isn't exposed, I think using Rank2Types will suffice
18:46:12 <ivanm> thanks anyway though
18:46:26 <aavogt> it's one separate module for the testAtTypes definition
18:46:40 <ivanm> hmmm... though what's the difference between Rank2Types, RankNTypes, etc. ?  Which do I need just for forall ?
18:46:41 <ddarius> mjrosenb: You.
18:46:51 <ivanm> aavogt: I'm already up to 27, and it takes long enough to compile as-is ;s
18:46:55 <ddarius> Though there's a Hackage library which captures the idea already.
18:47:03 <ddarius> @hackage reflect
18:47:03 <lambdabot> http://hackage.haskell.org/package/reflect
18:47:31 <ddarius> @hackage reflection
18:47:31 <lambdabot> http://hackage.haskell.org/package/reflection
18:47:35 <mjrosenb> ddarius: ddarius that seems to be a 404
18:47:54 <isomorphic> mjrosenb:  Your question? http://stackoverflow.com/questions/6076129/a-way-to-avoid-a-common-use-of-unsafeperformio
18:48:01 <ddarius> Edward's insane abuse of StablePtr's is ingenious.
18:48:13 <aavogt> sometimes you can get away without a separate module if you use the functions for making an ExpQ  all in the same splice
18:48:14 <ivanm> ddarius: albeit insane? :p
18:49:09 <ivanm> aavogt: I thought you couldn't define such a function to create a splice and use it in the same module :s
18:49:25 <ivanm> here's what I have atm anyway: http://paste.pocoo.org/show/402553/
18:50:05 <ddarius> @remember augustss So JHC has bad code. GHC had a lot of that a long time ago, and they have slowly been converting to the pure way. It's the only sensible way.
18:50:05 <lambdabot> Nice!
18:51:17 <mjrosenb> isomorphic: i do not want to modify them.  it is just going to be an Int, not an MVar Int or anything like that, but looks similar.
18:52:15 <aavogt> http://hpaste.org/47579/ivanm2 ivanm
18:52:51 <ivanm> ahhh, I get you
18:53:02 <ivanm> won't work for me, as I use that function a few times: http://paste.pocoo.org/show/402553/
18:53:49 <aavogt> ivanm: you can put most of your module in between the [d|  |]
18:54:07 <ivanm> because that's not hacky at all, is it? :p
18:54:33 <aavogt> nope
18:55:53 <ddarius> You don't want to replace a common, widely implement extension with one rarely used, GHC-specific extension?
18:56:24 <ivanm> ddarius: hmmm?
19:00:05 <aavogt> ddarius: I'm guessing that library probably won't run with other haskell implementations
19:02:20 <ddarius> aavogt: What library?
19:02:58 <aavogt> graphivz in this case, but that probably applies to most of hackage
19:09:32 <ivanm> aavogt: well, this is only for the test suite
19:09:50 <ivanm> otherwise, I use MPTCs + FDs and also FlexibleInstances
19:09:56 <ivanm> I think that's about it
19:11:46 <ddarius> Rank2Types are more widely supported than functional dependencies or FlexibleInstances.
19:27:01 <dolio> More widely supported than flexible instances?
19:27:08 <dolio> Do JHC and UHC not have them?
19:30:01 <ivanm> *sigh* and it turns out there's one case I can't do that, as the resulting props would have different types
19:31:31 <ivanm> dolio: are JHC and UHC actually usable?
19:32:04 <dolio> Depends what you want to use them for. But they have higher rank types.
19:32:13 <dolio> I suppose Hugs may not have flexible instances either.
19:32:35 <dolio> I can't remember if HBC has rank-2 types.
19:33:09 <ddarius> dolio: I'm pretty sure HBC supports ST.
19:33:15 <ddarius> As does Hugs.
19:33:48 <ddarius> I think even NHC has rank-2 types.
19:34:08 <ivanm> so why wasn't it proposed for haskell' if it's so widely implemented?
19:34:14 <dolio> I wouldn't have guessed that.
19:34:40 <dolio> I imagine it's been proposed.
19:35:18 <ddarius> It should have been proposed for Haskell 1.4.
19:36:16 <ddarius> But possibly because rank-n types are less widely implemented and rank-2 is slightly arbitrary.
19:36:45 <isomorphic> Haskell 1.4 > Haskell 2010?
19:36:54 <dolio> 1.4 predates 98.
19:36:55 <ivanm> isomorphic: nah, it predates 98
19:37:09 <dolio> I'd rather have rank-n, certainly.
19:37:18 <isomorphic> Ah, so Haskell 1.4 < Haskell 2010 < Haskell' ?
19:37:39 <dolio> Although another problem is that you'd have to settle on what sort of annotations you actually want to require to achieve type inference.
19:37:45 <ivanm> isomorphic: haskell' is the process for getting new versions of the standard out
19:37:51 <dolio> There are a lot of schemes with different trade offs.
19:37:56 <ivanm> haskell2010 is the first fruit of haskell'
19:38:20 <isomorphic> thanks :)
19:39:19 <dolio> GHC's scheme has some things it can't get right without making arbitrary decisions that won't work if you make some innocuous-looking changes...
19:40:04 <dolio> Whereas HMF (if I'm remembering correctly) can get them right all the time, but it requires more inconvenient annotations elsewhere.
19:40:22 <ddarius> Similar issues about how to resolve functional dependencies are one of the reasons why they weren't standardized earlier.
19:41:16 <dolio> Yeah, well, it's good that GHC's fundeps weren't standardized way back, since they did some weird stuff.
19:41:42 <ddarius> That wasn't the only reason.
19:42:58 <dolio> They seem to have tweaked them in 7 to work a little more to my liking.
19:43:05 <dolio> Probably to move them closer to type families.
19:43:54 <ddarius> The work on type families led to a formal understanding of functional dependencies, so they should be much more rational and consistent now.
19:44:26 <dolio> You can no longer have overlapping instances for a functional dependency unless the specific instance gives you the same result as the general one along the functional dependency, for instance.
19:46:17 <c_wraith> that restriction.... makes a lot of sense.
19:47:41 <dolio> Yes.
19:48:37 <dolio> That essentially separates the issue....
19:49:23 <dolio> Where overlapping the implementation of an instance is okay (relatively speaking), since it's just confusing.
19:50:18 <dolio> While overlapping the type computational component of the fundep is either unsound, or requires you to pretend fundeps don't actually mean what they're supposed to mean.
20:08:30 <\yrlnry> When I @list lambdabot, it says "http://code.haskell.org/lambdabot/COMMANDS".  That page mentions a "seen" command,  but lambdabot ignores "seen" and replies with " Unknown command, try @list" to "@seen".
20:08:50 <\yrlnry> How do I use @seen?
20:09:30 <Martty> @seen dons
20:09:30 <preflex>  dons was last seen on #ghc 1 hour, 9 minutes and 19 seconds ago, saying: heh
20:09:31 <lambdabot> Unknown command, try @list
20:09:40 <Martty> it works with preflex not lambdabot
20:10:00 <\yrlnry> Thanks.
20:10:04 <hellertime> I just tried installed in yesod using cabal, and it fails building yesod-auth, bummer.
20:10:08 <\yrlnry> @seen byorgey
20:10:08 <preflex>  byorgey was last seen on #haskell 8 hours, 40 minutes and 31 seconds ago, saying: sorry, right, not the type checker per se.
20:10:08 <lambdabot> Unknown command, try @list
20:10:20 <byorgey> hi \yrlnry
20:10:38 <\yrlnry> That is what I get for trying to politely transact my bot business offchannel.
20:11:15 <byorgey> =)
20:11:18 <\yrlnry> Hi brent. I wanted to remark that  iwas surprised at the strong negative response attracted by your article about the Collatz nonproof.
20:12:05 <\yrlnry> Then I saw you wrote an apology., so perhaps you were less surprised than I was.
20:12:11 <byorgey> \yrlnry: a large portion of the traffic I got was coming from links on various German fora
20:12:19 <byorgey> so I think there was some nationalism involved =)
20:12:20 <\yrlnry> I noticed that too.
20:12:30 <\yrlnry> I was wondering if it was just a cultural difference.
20:12:57 <\yrlnry> Or maybe Opfer got his homies to come and flame you.
20:13:42 <byorgey> I'm not sure.  I was a bit surprised too.  But I wrote the apology because I realized that whatever the motivation behind the reactions, I had been a bit harsh and it was worth apologizing for.
20:13:53 <byorgey> hehe, maybe =)
20:14:24 <isomorphic> byorgey: which was your article?
20:14:57 <byorgey> isomorphic: http://mathlesstraveled.com/2011/06/04/the-collatz-conjecture-is-safe-for-now/
20:15:28 <isomorphic> ah yes - I did see that one.
20:15:40 <isomorphic> linked from reddit I think
20:17:30 <byorgey> oh, was it?  Perhaps it was linked in a comment on another reddit thread
20:19:48 <\yrlnry> Now I can't remember how I got there.
20:19:50 <isomorphic> Ah.
20:20:16 <isomorphic> There's probably some sort of psychologist that would have a neat word for the different reactions people had to your article
20:20:34 <byorgey> heh, I would be interested to hear it =)
20:20:56 <isomorphic> So, my reaction...
20:21:04 <isomorphic> (completely unscientific)
20:21:19 <isomorphic> Some people tend to read something like that and think of the logic being attacked
20:21:27 <\yrlnry> I I got there from the link at the bottom of http://www.johndcook.com/blog/2011/06/01/collatz-3n-1-conjecture-solved/
20:21:28 <isomorphic> some people tend to think of the person being attacked
20:22:06 <byorgey> \yrlnry: ah, yes, I was just about to suggest that
20:22:10 <\yrlnry> No, I didn't.  I'm mystified.
20:22:15 <byorgey> hehe
20:22:20 <isomorphic> at least, that's a division I've noticed
20:22:54 <\yrlnry> Oh, yes.  I went from John D. Cook to mathexchange, and then a comment of Yuval Filmus links to your article.
20:23:03 <byorgey> isomorphic: yes, and I think it tends to correlate with mathematical experience.
20:23:22 <byorgey> \yrlnry: ah, right
20:23:27 <\yrlnry> People often read criticism of programming system X, and feel personally attacked themselves.
20:23:54 <isomorphic> byorgey: i'll go slightly different - it correlates with fields where evaluating truth is relatively inexpensive
20:23:56 <\yrlnry> It often seems to me that they have allied themselves with the Tribe of X, and an attack on X is an attack on their tribe and therefore on their person.
20:24:14 <isomorphic> where evaluating truth is expensive, people use reputation as a proxy
20:24:30 <\yrlnry> In what field is evaluating truth inexpensive?
20:24:42 <isomorphic> (in what i'm saying evaluating 'truth' in mathematics is cheap)
20:24:43 <byorgey> \yrlnry: that's exactly what happens.  programming languages aren't just software, they are cultures/communities.
20:25:04 <isomorphic> compare that with evaluating truth in something more humanities based, and all of a sudden we care very much who is saying what
20:26:04 <\yrlnry> I wonder if your claim has any content at all.  How would you show that "evaluating truth" in something more humanities based is "more expensive" than in mathematics?
20:26:05 <isomorphic> (not sure if I'm making sense - humanities were never my strong point ;))
20:26:07 <byorgey> \yrlnry: I find myself doing it too, and try to stop myself when I notice.
20:26:17 <\yrlnry> It seems to me that a plausible argmuent could be made the opposite.
20:27:01 <isomorphic> \yrlnry: yes, that's an interesting phenomena
20:29:40 <ddarius> \yrlnry: @seen used to work for lambdabot, but it was rife with issues so it was removed.  If you don't want lambdabot to respond you can do 'preflex: seen yrlnry'.
20:30:49 <isomorphic> \yrlnry: it's really unfortunate, because to be honest, programming seems to attract such a diverse group of interesting people
20:31:33 <\yrlnry> ddarius:  I didn't even know preflex existed.
20:31:54 <isomorphic> \yrlnry: compare it with many other industries - they're way more parochial and have a different ethos
20:32:28 <isomorphic> ie: I don't imagine there's an IRC channel with people giving out accounting advice
20:32:41 * ddarius wonders what field attracts a diverse group of boring people.
20:33:43 <isomorphic> relatedly - I want to return every line calculated in a monad - what's the usual way of doing that?
20:33:56 <isomorphic> return [calc1 ++ calc2 ++ calc3] ?
20:34:35 <Axman6> why the []'s?
20:34:45 <isomorphic> ddarius: audit?
20:34:45 * ddarius likes how the first comment on byorgey's blog post ends with "arrogant from the start to the beginning."  Should we interpret that as not arrogant?
20:34:47 <dankna> ddarius: sports
20:35:02 <isomorphic> \yrlnry: what's the opposite?
20:35:08 <byorgey> ddarius: hehe, I think someone made another comment to that effect =)
20:35:10 <isomorphic> *argument?
20:35:37 <\yrlnry> the opposite of what?
20:35:44 <isomorphic> so, a mathematical proof can be at least verified using a theorem prover
20:35:53 <isomorphic> you have a set of axioms
20:36:03 <isomorphic> and if you all choose the same axioms, you get the same answers
20:36:08 <isomorphic> assumptions up front
20:36:15 <isomorphic> deductive reasoning from there
20:36:19 <\yrlnry> maybe in your fantasy universe.  I would like to visit there sometime.
20:36:31 <\yrlnry> Are all the mathematicians out of work?
20:36:48 <isomorphic> the pattern I've noticed in what I'd call "humanities" is that deductive reasoning doesn't fly
20:37:21 <isomorphic> instead, loosely, you see something more inductive, with lots of smaller propositions militating to some sort of argumentative truth
20:37:46 <isomorphic> for those arguments, falsity is always just an extra proposition away
20:38:18 <isomorphic> ... unless of course, you've considered *everything*
20:38:19 <isomorphic> that's why I say truth is expensive
20:38:29 <isomorphic> What would be an example of a mathematical truth that is difficult to verify?
20:38:57 <ddarius> Cognitive psychology ho!
20:38:58 <dmwit> Any unsolved problem yields such.
20:38:59 <isomorphic> dankna: watching televised sport
20:39:20 <dankna> hm, yes
20:39:21 <dmwit> e.g. probably one of "collatz is true" or "collatz is false" is a mathematical truth that is difficult to verify
20:39:58 <dankna> actually, they're both difficult to verify at the present time.  note that the concept of "difficult" implies that the context includes to whom and when.
20:40:30 <dankna> if I personally were shown a proof of one of them, and the proof were in fact correct, I would still find it difficult to verify, because I don't know that kind of math.
20:40:48 <dankna> but presumably if an expert ... what branch of math is this?  number theory? ... number theorist were shown the same proof, it would be easy for him to verify.
20:41:14 <gwern> 'The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics. '
20:41:24 <dankna> ah - yes, that
20:41:30 <dankna> that was an interesting example indeed
20:41:34 <ddarius> dankna: Probably discrete math, and you are probably closer to it than most mathematicians.
20:41:34 <dankna> the proof was too large for human eyes
20:41:44 <dankna> ddarius: hmmm, if it's discrete math you may be right
20:41:53 <ddarius> Collatz is a toy.
20:42:47 <isomorphic> \yrlnry: I don't understand.  You seem to be arguing for hard to verify mathematical truths
20:42:47 <dankna> wasn't there a similar situation with the sphere-packing problem?  they proved that the one everyone knows is optimal (sorry, Vonnegut) but had to examine millions of special cases to do so, making it very difficult for other topologists (?) to verify.
20:43:09 <gwern> isomorphic: there must be long proofs for every short proof
20:43:11 <isomorphic> \yrlnry: i'm thinking I'd much rather implement a system for verifying a mathematic proof than, say, something sociological
20:43:32 <dankna> that's a point.
20:43:36 <gwern> *theorems with long proofs for every theorem with a short proof
20:43:52 <dankna> sci-fi author Gordon R. Dickson had a society that constructed formal proofs of theorems in sociology, based on their advanced understanding of it
20:44:03 <dankna> but I'd say we're centuries away from that if ever :)
20:44:09 <megachad> Hi, I've just started haskell with LYAH, but whenever I compile and run a program (say http://hpaste.org/47580/askfornumber) from the bash terminal, I get a blank line then when I input something it will actually display what it should (in this case ask me for the number). Is there any fix for that?
20:44:32 <dankna> :t forceOutput
20:44:33 <lambdabot> Not in scope: `forceOutput'
20:44:39 <dankna> :t hFlush
20:44:39 <lambdabot> Not in scope: `hFlush'
20:44:42 <dankna> :t hForceOutput
20:44:42 <lambdabot> Not in scope: `hForceOutput'
20:44:44 <dankna> huh
20:44:46 <dankna> @hoogle force
20:44:47 <lambdabot> Control.Parallel.Strategies force :: NFData a => a -> a
20:44:47 <lambdabot> Control.Parallel.Strategies sforce :: NFData a => a -> b -> b
20:44:49 <dankna> @hoogle flush
20:44:49 <lambdabot> System.IO hFlush :: Handle -> IO ()
20:44:52 <dankna> there we go
20:45:06 <dankna> megachad: hFlush stdout after printing the prompt.  normally it's flushed only after a newline.
20:45:21 <megachad> hey thanks, I will try it now
20:45:23 <dankna> sure
20:45:47 <dankna> heh he didn't stick around to see if it worked :)
20:45:50 <mauke> it's somehow heartwarming to see "standard" programming problems pop up in #haskell
20:46:06 <dankna> it is!
20:46:08 <mauke> you could have this same problem in C or Perl
20:46:11 <dankna> yep
20:46:19 <Axman6> dankna: he'll be back when he realised he has no idea how to use it...
20:46:29 <dankna> it is a good back-of-the-envelope measure of our broadening appeal :)
20:46:35 <dankna> Axman6: hehe hope not
20:46:53 <Axman6> s/ed/es
20:46:56 <mauke> maybe I should ask \yrlnry to extend http://perl.plover.com/FAQs/Buffering.html
20:47:02 <ddarius> mauke: Isn't the goal not to have "the same problems as C or Perl"?
20:47:17 <mauke> the explanation is good but the solution obviously doesn't work in Haskell :-)
20:47:38 <dankna> ddarius: well, in this case I think the underlying abstraction is a good one that's worth keeping even though there's a known point of confusion that it causes.
20:47:38 <mauke> ddarius: but they're the right problems to have!
20:47:41 <dankna> mauke: I think you should :)
20:52:13 <dankna> gahhhhh whose idea was it to have a keyboard shortcut for "print every document that's open, without confirmation"
20:53:05 <ddarius> dankna: Yours apparently.
20:53:44 <dankna> no, my idea was to accidentally hit it, if you can call that an idea
20:53:46 <gwern> that's a shortcut?
20:54:03 <dankna> yeah, it's a shortcut to running to the printer (on the other side of the house) and pulling the tray out ><
20:54:12 <gwern> interesting choice of shortcut
20:54:26 <dankna> quite
20:54:33 <gwern> not an operation I would have given such a short encoding
20:54:48 <dankna> indeed so
21:00:37 <mauke> ... huh. how DO you read a file line by line in Haskell?
21:00:47 <mauke> I've actually never done that
21:01:09 <dolio> @type getLine
21:01:11 <lambdabot> IO String
21:01:24 <mauke> yeah, that's like 25% of the answer
21:01:31 <gwern> nah, that's stdin, not a file handle
21:01:36 <mauke> hGetLine
21:02:28 <mauke> :t try
21:02:29 <lambdabot> Not in scope: `try'
21:02:46 <ivanm> isn't it just liftM lines . readFile ? :p
21:02:54 <djahandarie> :t catch
21:02:55 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
21:03:05 <mauke> ivanm: that reads everything at once
21:03:23 <ivanm> did you see that ":p" at the end of my statement?
21:03:35 <mauke> not sure, I ignore those
21:04:25 <mauke> ok, the question is: should I use 'try' at every step or 'catch' around the whole thing?
21:04:45 * isomorphic has dodgy internet
21:05:32 <ivanm> @hoogle isEOF
21:05:32 <lambdabot> System.IO isEOF :: IO Bool
21:05:32 <lambdabot> System.IO.Error isEOFError :: IOError -> Bool
21:05:32 <lambdabot> System.IO.Error isEOFErrorType :: IOErrorType -> Bool
21:05:42 <ivanm> mauke: I would say around the whole thing
21:06:01 <gwern> @wn consarn
21:06:03 <lambdabot> No match for "consarn".
21:06:21 <mauke> isEOF is an abomination
21:06:42 <ivanm> why?
21:06:56 <mauke> because it's conceptually wrong
21:07:19 <mauke> Haskell's IO follows the C model
21:07:36 <mauke> but isEOF is not the same as feof()
21:07:43 <ivanm> mauke: so you're soing to use iteratees then?
21:08:15 <mauke> ivanm: no
21:08:44 <dankna> @wn consarnation
21:08:45 <lambdabot> No match for "consarnation".
21:08:45 <mauke> isEOF actually reads a character from the handle, then pushes it back into the buffer
21:08:49 <dankna> @wn contarnation
21:08:49 <lambdabot> No match for "contarnation".
21:08:55 <dankna> @wn tarnation
21:08:55 <lambdabot> No match for "tarnation".
21:08:58 <dankna> hm
21:09:47 <isomorphic> maybe a higher order function
21:09:54 <isomorphic> @wn isAbomination
21:09:55 <lambdabot> No match for "isAbomination".
21:10:19 <mauke> hmm
21:10:25 <mauke> isEOF is also "unsafe"
21:10:45 <mauke> it's like using null and then head/tail later instead of just pattern matching
21:11:24 <aavogt> does somebody know where to get the ByteStrings suitable for this http://hackage.haskell.org/packages/archive/dwarf/0.23/doc/html/Data-Dwarf.html ?
21:11:33 <aavogt> specifically the parseDwarfInfo
21:12:00 <dankna> package "bytestring" module Data.ByteString
21:12:07 <dankna> you've never used it before?  it's an important package
21:12:26 <dankna> (I checked the links and it appears it wants those and not the ones from Data.ByteString.Lazy, which come from the same package and have the same name)
21:12:31 <aavogt> I mean I get a runtime error
21:12:36 <dankna> oh, that's odd
21:12:39 <dankna> hpaste the error
21:12:54 <dankna> oh I see what you're saying
21:13:06 <dankna> looks to me like you have to use an ELF or Mach-O parser to get the sections out
21:13:46 <dankna> possibly http://hackage.haskell.org/package/elf ?  it's by the same author
21:13:57 <aavogt> the input is supposed to be what you get from    objdump -Wi   -Wa  -Wo, but the formatting is wrong I guess
21:14:06 <luite> is it possible with hint or the GHCI api to use a different prelude?
21:14:20 <dankna> luite: interesting question.  possibly?
21:14:30 <dankna> I'd think the API could do it, but I'm not really sure how
21:14:32 <luite> I can't really find it
21:14:43 <aavogt> dankna: thanks, I'll try using that
21:14:45 <isomorphic> mauke: just catching up on the log - would "interact" help?
21:14:48 <dankna> aavogt: g'luck
21:14:51 <isomorphic> (doing IO)
21:14:53 <mauke> isomorphic: not at all
21:14:57 <gwern> luite: maybe load the noimplicitprelude LANGUAGE?
21:17:19 <luite> gwern: it's not a real "prelude" then, because every module must import it
21:17:30 <luite> perhaps my question was wrong :)
21:17:43 <gwern> you can specify alternate preludes or no prelude at all, iirc
21:17:49 <gwern> so there must be a way to do it in the ghc api
21:17:57 <luite> hmm ok
21:18:06 <ddarius> :t try . hGetLine
21:18:07 <lambdabot> Not in scope: `try'
21:18:07 <lambdabot> Not in scope: `hGetLine'
21:18:20 <ddarius> :t Control.Exception.try . System.IO.hGetLine
21:18:20 <lambdabot> forall e. (GHC.Exception.Exception e) => GHC.IO.Handle.Types.Handle -> IO (Either e String)
21:18:23 <gwern> I don't recall loading Prelude explicitly when setting up mueval, so that implies prelude is loaded by default. so there must be someway to unload it
21:18:32 <gwern> I would expect that to be an extension
21:18:45 <bos> @pl \a -> fmap (const a) (Just "foo")
21:18:45 <lambdabot> flip fmap (Just "foo") . const
21:18:47 <luite> oh hint can unload everything by doiang a rest
21:18:49 <luite> doing
21:18:56 * gwern checks
21:18:58 <luite> reset
21:19:41 <gwern> oh, turns out I do load Prelude explicitly after the reset
21:19:48 <gwern> how about that
21:20:38 <gwern> mystery - solved!
21:20:56 <luite> yeah but the problem is that say my active module is MyModule, and MyModule has an import OtherModule, then OtherModule can't use the symbols in the new prelude
21:21:56 <gwern> well... doesn't that make sense? if the OtherModule was typechecked against the old prelude, you can't monkeypatch a new prelude on it
21:22:19 <ddarius> We should get rid of files and such and have everything be a channel.
21:22:34 <gwern> haha. yes, let's be like erlang. modules are a silly abstraction
21:22:35 <luite> gwern: oh I only want the new module for files loaded from source
21:22:41 <luite> the new prelude
21:23:07 <luite> so I don't want to monkeypatch, I just want ghc to typecheck against my new prelude when loading haskell source :)
21:23:37 <gwern> but the source your loading doesn't want the new prelude
21:23:44 <luite> it does! honest!
21:24:01 <gwern> hm, I guess you would do something like define your Prelude and then use the importas extension...
21:24:10 <gwern> luite: if it did, it'd say so explicitly! no means no!
21:24:17 <gwern> *could
21:24:36 <luite> importas extenion?
21:25:17 <gwern> luite: importas is a dirty little extension which lets you pick which package you import module FOo from if a bunch of packages all define the same module name
21:25:39 <gwern> eg transformers vs mtl, I think is the most common case where 2 packages define the same module name
21:25:52 <luite> oh right... but that means messing with the source of SomeOtherModule
21:26:29 <mauke> dankna: http://mauke.dyndns.org/tmp/hsfb.html - I've done the first step (i.e. s/Perl/Haskell/g) but the second part needs a rewrite :-)
21:26:35 <luite> which I wanted to avoid, because parsing and then prettingprinting messes up line numbers
21:26:38 <dankna> mauke: hmm
21:27:05 <dankna> yes, I see.  we don't have the "hot" concept
21:27:28 <ddarius> :t hSetBuffering
21:27:29 <lambdabot> Not in scope: `hSetBuffering'
21:27:30 <mauke> easy to invent, though
21:27:36 <ddarius> :t System.IO.hSetBuffering
21:27:37 <lambdabot> GHC.IO.Handle.Types.Handle -> GHC.IO.Handle.Types.BufferMode -> IO ()
21:27:42 <gwern> luite: inserting one line and then doing '-1' is hard?
21:27:43 <dankna> @hoogle BufferMode
21:27:44 <lambdabot> System.IO data BufferMode
21:27:47 <mauke> hotPutStr h s = hPutStr h s >> hFlush h
21:27:54 <dankna> @google haskell BufferMode
21:27:56 <lambdabot> http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/System-IO.html
21:27:56 <lambdabot> Title: System.IO
21:28:03 <mauke> messing with BufferMode is a Bad Idea™
21:28:15 <dankna> is it?
21:28:18 <mauke> yes
21:28:21 <Axman6> why?
21:28:33 <dankna> where can I buy these Bad Ideas??
21:28:39 <mauke> if you set a handle to NoBuffering, it will do a write(2) for every single byte
21:28:40 <Axman6> aren't there times where line buffering can cause problems?
21:28:43 <dankna> oh, yeah
21:28:43 <aavogt> dankna: success http://hpaste.org/47581/load_dwarf_info
21:28:44 <dankna> I see
21:28:45 <luite> gwern: the -1 isn't the hard part, but inserting the line reliably is :)
21:28:48 <dankna> aavogt: grats :)
21:29:11 <gwern> luite: I hear after the first time you go insane parsing with generics and haskell-src-exts, it's quite pleasant really
21:29:29 <luite> gwern: but haskell-src-exts doesn't preserve line numbers
21:29:30 <aavogt> quite true gwern
21:29:31 <mauke> this 1) isn't what a "hot filehandle" does, and 2) destroys every shred of efficiency
21:29:50 <luite> gwern: you can have it output line pragma's, but they're not accurate
21:29:54 <ddarius> gwern: Wouldn't the only people that would know that be insane?
21:30:06 <gwern> ddarius: that's very racist of you
21:30:17 <dankna> mauke: okay.  so the question is, do we just not mention hSetBuffering at all, or do we mention it and explain the pitfall?
21:30:32 <dankna> mauke: it seems like it's useful if you set it to BlockBuffering Nothing
21:30:38 <dankna> (see http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html )
21:30:47 <luite> if haskell-src-exts preserved layout I wouldn't have asked this question :)
21:31:00 <dankna> yeah, we really need a good generator for layout-preserving parsers
21:31:13 <dankna> Joy was going to have that feature before I got frustrated with it :)
21:31:27 <mauke> dankna: I think it should be mentioned but hFlush should come first
21:31:33 <dankna> mauke: makes sense to me
21:31:34 <aavogt> luite: there is layout information in Language.Haskell.Exts.Annotated, but I recall something about the conversion not being that exact
21:31:49 <luite> aavogt: at least the line number pragma's it outputs are not exact
21:31:55 <aavogt> or maybe it was about keeping the comments
21:31:59 <dankna> it's why for Te I'm taking the "code is a database" approach, heh
21:32:05 <luite> it's usually only a few lines difference, but it's annoying for error messages
21:33:43 <luite> maybe there's a better parse mode or somethign, haskell-src-exts has about 2 million functions
21:34:37 <gwern> I think I would poke about more in the ghc api to see whether you can load your prelude as the Prelude or not for sure
21:40:26 <luite> gwern: trying that. I've already patched hint to allow me to poke directly with the ghc internals anyway :)
21:44:00 <ddarius> If I wanted to read from the serial port, say, i.e. the appropriate character device, how would I do that in Perl?
21:44:03 <gwern> really, I just look straight at ghci when I want to see whether I can do soemthing or not
21:44:07 <gwern> [D[D[C
21:47:04 <dankna> http://hpaste.org/47583/naming_of_specificwindow
21:47:22 <dankna> not sure whether this is a good naming convention - I'm worried about both the type constructor SpecificWindow and the data constructors for it
21:47:30 <dankna> also not sure whether it's a good design at all
21:47:50 <dankna> note that these window IDs are all UUIDs under the hood but I'm hiding that fact
21:48:16 <dankna> (the reason there's only the ID and the project fields in these types is that all the actual information is stored in the database)
21:48:26 <dankna> (albiet usually in the memory copy of it)
21:50:36 <pjpj> hello, i've a haskell newbie question: the "do" expression is evaluated sequentially isn't it?
21:51:13 <dankna> more or less, yes
21:51:34 <dmwit> nooo
21:51:49 <dmwit> (>>=) is a lazily evaluated function like any other
21:51:58 <dankna> each statement (yes, we use the term statement rather than expression in this situation) inside the do expression is evaluated, if at all, in sequence.  it depends on the monad though, because really the monad defines the rules of what it means.
21:52:10 <dankna> you can think of monads as defining what it means to do one operation "after" another.
21:52:20 <blackh> pjpj: Each line in do syntax is dependent on the one before it, but the order of evaluation is not necessarily sequential.
21:52:45 <dankna> I guess it would be possible to write a Backwards monad :D
21:53:01 <dankna> although it couldn't do backwards name-binding, but.
21:53:02 <blackh> dankna: It *is* possible to write a monad to make your program run backwards in general.
21:53:08 <dankna> heh okay
21:53:48 <pjpj> so the Maybe monad would be one that does it sequentially: eg-- foo = do
21:53:49 <pjpj>     x <- Just "abc"
21:53:49 <pjpj>     y <- Just "def"
21:53:49 <pjpj>     Just (show x ++ y)
21:54:04 <pjpj> whould compute x first then y?
21:55:39 <blackh> dankna: http://hpaste.org/47584/backwards_monad
21:56:01 <dankna> ooh nifty
21:56:29 <ion> Is there a way to create orphan instances that are *only* present in the same module and nothing that imports it?
21:56:35 <Axman6> pjpj: do notation is just sugar for the normal monad functions. things may run sequentially or not depending on the monad
21:57:09 <Axman6> in the IO monad, it's basically there to define the sequence that things happen, the state monad is similar
21:57:10 <blackh> pjpj: That code would evaluate x first then y, but only because of the way String is implemented as a list of chars:  You have to evaluate the string in order.
21:57:35 <blackh> pjpj: If you returned (x,y) then you couldn't predict what order they would be evaluated in.
21:58:01 <aavogt> ion: you could write a new class that behaved exactly the same as the old one which is only used in your 'same module'
21:58:38 <blackh> dankna: AFAIK, Haskell is the only language that allows you to run your program backwards. :)
21:58:42 <pjpj> goodness, haskell is complicated
21:58:55 <dankna> blackh: hehe yeah
21:59:11 <blackh> pjpj: Haskell isn't complicated.  You just have to think a bit differently.
21:59:21 <dankna> no, I'm going to go out on a limb here and say Haskell is complicated :D
21:59:29 <dankna> but you can ignore the complexity most of the time, when starting out
21:59:31 <Axman6> pjpj: that code basically turns into something like: case Just "abc" of Just x -> (case Just "def" of Just y -> return (x++y); Nothing -> Nothing); Nothing -> Nothing
21:59:51 <Axman6> i shall make a paste, because that's hard to see...
22:00:07 <pjpj> running programs backward sounds complicated to me.
22:00:28 <Philippa> being able to do complicated things doesn't mean the language is complicated
22:00:33 <blackh> dankna: I think every language is complicated.  IMHO Haskell is more complex than your average language, but not by much.
22:00:36 <Philippa> it means it's simple enough you can manage to do them
22:01:02 <Axman6> pjpj: http://hpaste.org/47585/maybe_monad
22:01:09 <Philippa> (try turning a C program inside out or running it backwards...)
22:02:04 <blackh> Philippa: You put it so well!
22:02:30 <pjpj> ok, maybe i should have said haskell is powerful instead of complicated.  anyway thanks for you help here. i've got to go.
22:02:46 <Axman6> pjpj: that paste pretty clearly shows how the Maybe monad is useful for situations with failure, as soon as something returns Nothing, Nothing is returned, without computing anything else
22:02:53 <dankna> okay, see you round hopefully, pjpj
22:03:21 <Philippa> pjpj: it *is* sequential if you're doing IO. I'm guessing that's the one you really care about right now
22:03:38 <Philippa> (sorry, I missed the scrollback - would've said that sooner if I'd seen the original question)
22:04:10 <Axman6> Philippa: would you say State is sequential too? i said it was earlier, but I'm not completely sure now
22:04:21 <Philippa> Axman6: Lazy or Strict?
22:04:48 <Axman6> well i guess lazy since it's usually what people mean when they say the State monad
22:05:24 <Philippa> and guys: check why the newbie's asking a question like that first. If they're trying to get their head around IO, telling them that it's good enough for now, that there's more for things-that-aren't-IO /and leaving it there/ until they respond is a good idea
22:05:51 <Axman6> well, it was a question specifically about the Maybe monad
22:06:13 <aavogt> blackh: can this be made to work with reverseT http://hpaste.org/paste/47584/backwards_monad_annotation#p47586 ?
22:06:31 <Philippa> it was refined there, yeah
22:06:36 <blackh> I suppose when you're new to Haskell you feel you need to understand what order things are happening in.  Then after a while you learn to let .... go............. ahhhhhhhhhhhhhh
22:06:46 <Philippa> but backwards monads came in before Maybe on my screen at least
22:07:00 <Philippa> blackh: sometimes the order's part of the problem domain too
22:07:37 <blackh> aavogt: I don't think so.  It only works where the evaluation can be done backwards.  The IO monad has lots of strict stuff that will break it.
22:09:31 <aavogt> I guess it works in a way if you define the ioref first
22:09:41 <blackh> aavogt: In theory, if your code logically can run backwards, and it has no unnecessary strictness, it should work.  But reasoning that out can be a bit tricky!
22:10:14 <blackh> aavogt: I think the print =<< readIORef r is problematic, because that is very strict.
22:10:54 <blackh> ...and for my next trick... I will run my code INSIDE OUT!
22:10:59 <dankna> what does that even mean
22:11:15 <aavogt> blackh: there's a <<loop>> even without that line
22:11:33 <aavogt> the problem is it seems you can't use an IORef before defining it with newIORef
22:11:44 <blackh> aavogt: I am not at all surprised.  newIORef is strict too.
22:12:33 <blackh> aavogt: Try with a lazy state monad.
22:13:02 <Philippa> blackdog: inside out is easy, use delimited continuations. Oleg showed off doing it with a parser ages back, you get an incremental parser by feeding it an appropriate input stream
22:13:16 <Philippa> blackh, even
22:13:26 <Philippa> it's been done with Parsec 3, too
22:29:55 <Azverkan> are there any good references for optimizing Parsec3 parser performance
23:01:39 <mjrosenb> Philippa: you have a link for that?
23:36:05 <periodic> I'm trying to figure out if Yampa is what I want it to be...
23:36:28 <periodic> In all the docs I see information about Event sources and Signal Functions, but I don't see quite how they fit together.
23:36:59 <periodic> I wanted a framework for doing some simulations of discrete events, where one event might queue other events to happen at a later time.
23:37:13 <periodic> Any thoughts?
23:39:09 <periodic> I guess what I imagine is something along the lines of actors with a global event queue (just to keep things simple for now and not have to worry about linking and subscribing)
23:43:05 <ivanm> Yampa is a reactive library, isn't it?
23:46:08 <develhevel> when i'm working with the FFI and C, a int* is equal to Ptr CInt, but what is equal with int&
23:46:29 <ion> Isn’t int& C++?
23:46:33 <Axman6> that's a C++ thing isn't it?
23:46:35 <Axman6> so nothing
23:47:44 <develhevel> my quesion is, that i want to use the FFI to call C functkion, but what do i do then i have a int&? when i have a int* i use as a type Ptr CInt
23:48:02 <Twey> develhevel: You export a version from C++ that uses int*
23:48:24 <Twey> Haskell's FFI does not support C++
23:48:32 <Axman6> there's no such thing as int& in C develhevel
23:48:33 <Twey> (I don't know of anything that does >.>)
23:48:49 <ivanm> Twey: is SWIG for C or C++ ?
23:48:52 <Axman6> Twey: C++ compilers find it hard enough supporting C++ :P
23:48:54 <dankna> C++ doesn't have a standard ABI on most (all?) platforms, so it's difficult to support such things.
23:48:56 <Twey> SWIG is cross-language, I think
23:49:20 <Twey> Yeah, site says it supports C and C++
23:49:42 <develhevel> okay, i understand. so there is no possibility to use int&?
23:50:07 <Twey> develhevel: Not directly
23:50:10 <Axman6> no, it's not a C construct
23:50:23 <Twey> You have to write a wrapper function in C, and export that instead.
23:50:52 <develhevel> okay, thx guys
23:50:58 <Twey> Er, that was poorly phrased
23:51:16 <Twey> You have to write a wrapper function in C++, exporting a C-compatible interface (‘extern "C"’ or so)
