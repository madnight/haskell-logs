00:01:44 <Saizan> edwardk: discussing denotational semantics with roconnor i was thinking that StateT PartsOfTheWorldIControl (Free OI) would be a decent model, though for concurrency we need dynamically created automatons to start running together making the FFI type more complex i suspect
00:03:07 <edwardk> well, recall, the ffi type here is just a way to run internally for a bit before yielding control back to the runtime, so concurrency works fine with it.
00:07:02 <Guest35572> in type signature: the "context" can be a lot of `<className> <typeVar>`, like `Eq a`. but there are more complex cases: in Parsec `(Stream s Identity t) =>` and in llvm `(sth.,,, IsSized a sa, IsSized b sb, sa :>: sb) =>` I can sense the meaning but I don't know the syntactic structure of it.
00:07:18 <Saizan> it works fine with a simple "ffi_forkIO :: FFI (IO ()) ThreadId" for implementation purpouses, but it doesn't mix well with making e.g. MVar's heap explicit in the model
00:07:54 <danharaj> edwardk
00:07:56 <danharaj> I want to hit you
00:08:02 <danharaj> for your ScottFree pun.
00:08:17 <edwardk> =)
00:08:19 <Saizan> ah, ScottFree was chopped too for me :P
00:08:32 <edwardk> going back to fix
00:09:21 <edwardk> how is it now?
00:10:03 <Saizan> still chopped
00:10:04 <Guest35572> need help, please:)
00:11:01 <danharaj> so edwardk, you've gone one step forward in giving a sane denotational semantics to IO I see?
00:11:28 <roconnor> conal will want to see this
00:12:31 <Saizan> Guest35572: classes can have more than one type argument
00:12:49 <Saizan> Guest35572: and you can have infix class names like (:>:)
00:13:21 <edwardk> danharaj: more or less
00:13:30 <edwardk> roconnor: =)
00:14:04 <danharaj> I'll always be an operational semantics kind of guy.
00:14:09 <danharaj> Heck, the way I do math is operational.
00:14:20 <danharaj> Shoving objects through functions and seeing what happens.
00:15:29 <Guest35572> Saizan:can it be split to two parts of <classname> and <typevar> ?
00:16:18 <Saizan> Guest35572: <className> <type1> ... <typeN> where N is the arity of the class
00:16:50 <Saizan> danharaj: i like the last line here http://semantic-domain.blogspot.com/2011/06/constructive-lift-monad.html
00:17:03 <dobblego> edwardk: do you happen to know if Applic f => Applic (Iter e f) is possible where Applic is (<*>) without pure?
00:17:59 <Saizan> Guest35572: FlexibleContexts is what allows whole types rather than just type variables as arguments to classes in a context
00:18:17 <develhevel_> do anybody know how to read a XMLTree from a xml file in haskell?
00:18:31 <edwardk> dobblego: probably not
00:18:45 <Saizan> develhevel_: HXT has readDocument, iirc
00:18:51 <dobblego> edwardk: why do you say that? I was erring on probably so
00:19:15 <edwardk> dobblego: but i haven't proven it. i just recall the applicative being a mess
00:19:34 <dobblego> the Applicative is obviously easy given Monad f =>
00:19:44 <edwardk> yes,.
00:19:55 <dobblego> I know the same holds for Applicative (StateT s f)
00:20:00 <dobblego> it requires Monad f =>
00:20:03 <dobblego> but that is obvious
00:20:07 <edwardk> but you said given Apply =)
00:20:13 <dobblego> er yeah that too
00:20:17 <dobblego> s/Applicative/Apply
00:21:36 <Guest35572> Saizan:thanks, I will see some FlexibleContexts
00:21:55 <develhevel_> Saizan: there is my problem, i do "let a = readDocument [withValidate no] file" and then want to run "getXPath "//" a" i get the error:Expected type: XmlTree. Actual type: IOStateArrow s0 b0 XmlTree
00:21:58 <Saizan> you can write Applicative f => Applicative (StateT s f), right?
00:22:02 <edwardk> dobblego: have you read the 3 blog posts i put up today? the third ended talking about something very iteratee-like
00:22:10 <erus`> i cant take the web frameworks in haskell
00:22:23 <erus`> everything is toooooo different
00:22:32 <Saizan> develhevel_: what's the type of getXPath ?
00:23:08 <edwardk> saizan: try sometime
00:23:34 <edwardk> saizan: note the difference between s -> m (a, s) and m (s -> (a, s)) and s -> (m a, s)
00:23:47 <edwardk> the latter two are applicative compositions
00:24:20 <develhevel_> Saizan: getXPath :: String -> Text.XML.HXT.DOM.TypeDefs.XmlTree -> Text.XML.HXT.DOM.TypeDefs.XmlTrees
00:24:39 <edwardk> there are other instances that it seems like you should be able to define using just applicative, when you start playing with MaybeT, etc. but they yield the different answers than ap.
00:25:12 <edwardk> in fact, the monads for which they break are precisely the monads for which monadtrans needs access to the underlying return.
00:25:34 <Saizan> develhevel_: runX $ a >>> arr (getXPath "//") -- this should work
00:25:44 <edwardk> for things that transform using just (>>=) the applicative wins up being compatible. but eitherT, maybeT, listT all break subtly
00:26:27 <Saizan> not so subtly, even :)
00:26:44 <edwardk> they also happen to be the cases that make you take the 'funny' monadplus definition. so they are in some sense very different from the 'bind' transformers.
00:27:04 <Saizan> throwError () >> launchMissiles -- oops
00:27:11 <edwardk> yeah
00:27:57 <develhevel_> Saizan: works perfekt, thx
00:31:19 <Saizan> i'm pretty sure i had something like Applicative f => Applicative (StateT s f), i guess it was just ReaderT s (WriterT s f) instead
00:33:41 <edwardk> saizan: i've been tripped up by that one too =)
00:34:28 <erus`> happstack-state-0.5.0.4 depends on network-2.3.0.2 which failed to install.
00:35:53 <Saizan> erus`: look in the backlog, there should be a reason for network failing to install too
00:37:04 <erus`> cabal: The package has a './configure' script. This requires a Unix compatibility toolchain such as MinGW+MSYS or Cygwin.
00:37:17 <erus`> why would they do that...
00:38:47 <Saizan> erus`: do you have network installed at all? "ghc-pkg list network"?
00:39:01 * edwardk &
00:39:17 <Saizan> if not, you want the haskell platform rather than just ghc, if yes you want to convince cabal to use that one :)
00:39:37 <erus`> nope
00:39:45 <erus`> i installed the haskel platform
00:39:51 <erus`> has something fucked it up?
00:40:07 <Saizan> what's the output of ghc-pkg list network ?
00:42:23 <erus`> warning, broken pkgs
00:43:04 <erus`> haskell ion windows... what a nightmare
00:44:07 <jadrian> I was looking at "parameterised notions of computation" by Atkey
00:44:44 <Saizan> @where sicp
00:44:45 <lambdabot> The Wizard book : "Structure and Interpretation of Computer Programs" at <http://mitpress.mit.edu/sicp/> by Hal Abelson,Gerald Jay Sussman with Julie Sussman, videos at <http://swiss.csail.mit.edu/
00:44:45 <lambdabot> classes/6.001/abelson-sussman-lectures/>
00:44:54 <jadrian> do you know of any other approaches to work with parameterised monads ?
00:45:25 <jadrian> I was looking for something slightly more general
00:46:21 <Saizan> jadrian: http://lambda-the-ultimate.org/node/4273
00:46:33 <jadrian> thank you saizan
00:47:23 <jadrian> oh looks interesting
00:47:57 <jadrian> in my case the monad multiplication defined by Atkey, turns out to be too restrict
00:48:02 <Saizan> erus`: http://www.vex.net/~trebla/haskell/sicp.xhtml <- this is a good read on managing cabal packages
00:48:59 <jadrian> I only need a single parameter in the monad (a Set) and I want the result of  the monad multiplication to return  the union of both sets as a result
00:49:55 <Saizan> multiplication is basically bind?
00:50:05 * Saizan doesn't remember the terminology of the paper
00:50:17 <jadrian> multiplication is join
00:50:19 <jadrian> mu
00:50:43 <erus`> why does network build with a ./configure script?
00:51:45 <jadrian> so in the paper monads are of the form  T(S1,S2,A) and the multiplication (join) is   mu: T(S1,S2, T(S2,S3, A)) -> T(S1,S3, A)
00:53:25 <quicksilver> jadrian: "I want the result of  the monad multiplication to return  the union of both sets as a result"
00:53:38 <quicksilver> jadrian: I don't understand how this makes sense.
00:53:44 <quicksilver> "both" sets? there aren't two sets.
00:53:53 <quicksilver> In a monad multiplication you have a set of sets, not two sets.
00:54:42 <Saizan> join:: m s1 (m s2 a) -> m (union s1 s2) a ?
00:56:24 <jadrian> quicksilver: well in this framework it doesn't really...   I have a family of monads T_S where the indexes are sets S,   so for each monad I have an eta_S  and mu_S,   I also have an operation  mu_{S1,S2}  : T_S1(T_S2(A)) -> T_{S1 U S2}  A
00:56:58 <quicksilver> oh.
00:57:08 <jadrian> quicksilver: so I was wondering if there is some already defined notion of parameterised monad where this fits
00:57:13 <quicksilver> you want the indices to union, you're not saying that the monad itself was a set.
00:57:40 <jadrian> quicksilver: right,  so if anything the monad is parameterised by a set
00:58:34 <quicksilver> it seems entirely plausible that you can make a general theory of monads indexed by the objects of a monoidal category
00:58:50 <quicksilver> there is something called 'monoidal indexed monads' or something.
00:58:57 <quicksilver> but, I can't point you to details.
00:59:15 <jadrian> quicksilver: sounds interesting, I'll try and find that
01:00:41 <jadrian> quicksilver: to give you an idea of why I want this, the sets could represent, for instance, potential exceptions
01:01:05 <jadrian> quicksilver: so it could work to interpret annotated types
01:01:49 <quicksilver> makes sense.
01:02:19 <quicksilver> you're right that that is not really the same as the paper you were talking about earlier.
01:02:28 <quicksilver> at least I'm fairly sure it isn't.
01:03:32 <jadrian> yeah it really isn't
01:13:15 <Saizan> in that paper join is m i j (m j k a) -> m i k a ?
01:13:40 <nic_> can this be used on DWave One
01:13:53 <quicksilver> Saizan: yes. It's domino-composition join
01:13:56 <osfameron> reading Planet Haskell is always interesting.  I barely understand any of it (for example Edward Kmett's current series on optimizing free monads) but it's fascinating to watch people doing clever things, from a safe distance ;-)
01:14:11 <quicksilver> Saizan: the motivating example is a state monad whose state type changes between operations
01:14:43 <Saizan> quicksilver: so, it seems like with primitives like throw :: e -> m i (singleton e U i) a it seems like you'd get the same effect
01:15:00 <quicksilver> still domino-composition and set-union are both monooids so maybe there is a unifying idea
01:16:07 <Saizan> yeah, m and Endo m are pretty similar when when m is a monoid
01:18:48 * quicksilver spent a whole term learning representation theory
01:18:55 <quicksilver> can't actually remember much of it.
01:24:51 <xarch> hi
01:36:49 <kstt> not a fascinating question, but that requires haskell experience so I'll ask anyway : How easy, in your exerience, is it do deploy an haskell network application (a daemon) on windows ? I have absolutly zero experience with this OS, but some of our customers have windows servers and I'm considering Haskell for the next project.
01:36:56 <kstt> limiting the dependencies at deploy time to the strict minimum (ideally none, with everything statically linked into a binary) is appreciable
01:37:27 <jadrian> Saizan: yes that works, but you get a family of type signatures indexed by i for each term, or in my case a family of interpretations for each type... but yes, it would be a possible hack if I really really wanted to use that notion of parameterised monad... and yeap maybe both concepts can be unified
01:39:22 <quicksilver> kstt: GHC always used to compile completely statically, deployment was just cpying an EXE where you wanted it to go.
01:39:31 <quicksilver> kstt: (I don't really know much about windows either, I'm afraid)
01:39:41 <quicksilver> kstt: I know recent GHCs support dynamic linking but I think it's optional.
01:40:06 <kstt> quicksilver: how about librairies that are bindings, through FFI, to C dynamic librairies ?
01:40:27 <quicksilver> then you'd need to copy those DLLs somewhere they could be found I suppose.
01:41:13 <erus`> how can i catch ctrl-c ?
01:41:36 <kstt> quicksilver: I tried recently to move a binary from a linux box to an other and things didn't work. IIRC, it was dynamically linked against libs at various paths that was not available on the target OS.
01:42:18 <Botje> erus`: ctrl-c sends SIGINT
01:42:20 <kstt> quicksilver: but that show my tiny understanding of linking process. I'm sure there is a way to link against, say, DLLs in "current" directory (./).
01:42:27 <quicksilver> kstt: right. On linux dynamic linking is the norm and also different distributions vary in annoying ways.
01:42:42 <erus`> Botje: how do i catch that?
01:42:46 <quicksilver> kstt: I don't think this is such an issue in windows - I think the standard DLLs are always in a standard place.
01:43:08 <quicksilver> erus`: System.Posix.Signals, or something.
01:45:13 <erus`> is there a way to show which imports are/arnt being used?
01:48:00 <quicksilver> -fwarn-unused-imports
01:48:09 <quicksilver> but it used to get confused by certain kinds of repeated imports
01:48:13 <quicksilver> not sure if it still does
01:51:18 <erus`> cheers
01:51:49 <sheyll> hi
01:51:58 <sheyll> wazzup with gtk3hs??
01:52:04 <sheyll> :)
01:52:12 <sheyll> does it exist?
01:52:23 <sheyll> And what about gtk2hs?? is is still maintained?
01:53:36 <erus`> when i do cabal install happstack-auth it fucks up my happstack install and i have to reinstall it
01:53:42 <erus`> because of the network pkg
01:58:38 <gienah> erus`: probably better to ask in #happs
02:01:10 <gienah> I wonder what work is being done on happstack-auth, an obvious idea would be to use the authenticate package that michael nicely wrote for us
02:01:22 <gienah> oops wrong channel sorry
02:15:54 <JuanDaugherty> anybody familiar with Bjorge Langefors work, know of anything similar but more recent?
02:18:18 <JuanDaugherty> *borge
02:19:39 <JuanDaugherty> **Börje
02:49:37 <JuanDaugherty> or similarly, like Barwise and Seligman's Information Flow
02:54:31 * hackagebot uuagc 0.9.38.4 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.38.4 (ArieMiddelkoop)
03:09:21 <jadrian> jadria
03:09:23 <jadrian> opss
03:13:49 * hackagebot hack2-handler-mongrel2-http 2011.6.24 - Hack2 Mongrel2 HTTP handler  http://hackage.haskell.org/package/hack2-handler-mongrel2-http-2011.6.24 (JinjingWang)
03:45:57 <ajnsit> Hi all
03:46:50 <ajnsit> I've been learning haskell on and off, to the point that I understand things like Monads, Applicative etc. Arrows are still a bit of a mystery to me but I'm getting there
03:47:07 <ajnsit> what would you recommend I learn next?
03:49:48 <benmachine> ajnsit: I'd say find something you want to do, and learn whatever you need to do it
03:50:11 <Nimatek> Hm. Number.CReal is epically slow compared to python's decimal.
03:50:29 <benmachine> Nimatek: that's arbitrary precision for you :P
03:51:20 <ajnsit> benmachine, the thing is that I really don't have that much of an intuitive understanding of Haskell yet.. I can't look at a problem and realise what abstract concepts need to be applied to it
03:51:27 <Nimatek> benmachine: decimal delivers the required precision instantly, where Haskell's Double returns 'Infinity' and CReal stalls the cpu.
03:53:11 <quicksilver> python.decimal is fixed precision though.
03:53:33 <quicksilver> it's more like Data.Fixed.
03:53:41 <quicksilver> fixed but user-configurable, I mean.
03:53:57 <Nimatek> quicksilver: Ah, interesting.
03:54:18 <benmachine> ajnsit: well, maybe you need some experience building stuff
03:54:34 <benmachine> ajnsit: and hanging around in here listening to what people say :P
03:56:23 <ajnsit> benmachine, True.. I used to log in to this channel more frequently earlier.. It seems to have gotten quieter
03:57:02 <benmachine> ajnsit: there are probably patterns. I was away from here for a long time because of exams, I imagine many people are the same
03:59:13 <JuanDaugherty> ajnsit, there's no way to tell what the complement of "things like Monads, Applicative, etc>" is
03:59:23 <ajnsit> benmachine, the channel strength is still the same though :) I remember a channel from some time back which rewarded unique utterances and penalised repeating things.. So saying something like "Hi" could *mute* a person for 10 minutes..
03:59:26 <JuanDaugherty> s/>/./
03:59:59 <benmachine> ajnsit: #xkcd-signal?
04:00:04 <Botje> #xkcd.. yes, that
04:00:09 <benmachine> I tried that out once, it was odd
04:00:30 <ajnsit> benmachine, that's the one! I was trying to remember the name
04:03:25 <ajnsit> JuanDaugherty, yeah I guess I was hoping that someone more experienced would have a clear answer to that question!
04:03:28 <JuanDaugherty> Nimatek, CReal stalls the cpu?
04:03:48 <JuanDaugherty> ajnsit, someone with access to your memory
04:04:29 <ajnsit> JuanDaugherty, probably what I should have asked "what can I do to improve my understanding of Haskell"
04:04:38 <JuanDaugherty> same deal
04:05:14 <ajnsit> JuanDaugherty, know any good sources to read which build up on Applicative?
04:05:24 <benmachine> ajnsit: build up in what sense?
04:05:31 <shvelo> hey
04:05:42 <ajnsit> benmachine, I mean use Applicative in an idiomatic way
04:05:57 <benmachine> what have you already reaD?
04:05:59 <benmachine> read.
04:06:08 <benmachine> shvelo: hay
04:06:34 <shvelo> haskell is cool :D
04:06:44 <ajnsit> benmachine, well nothing substantial yet.. what do you recommend
04:07:01 <benmachine> @where typeclassopedia
04:07:01 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
04:07:06 <benmachine> I gotta go
04:07:08 <benmachine> have fun with that
04:07:34 <ajnsit> benmachine, okay so I already read the typeclassopedia.. and loved it :)
04:08:06 <ajnsit> I have already read LYAH too
04:08:16 <ajnsit> I guess Real World Haskell is the next step?
04:08:39 <JuanDaugherty> ajnsit, Applicative Programming with Effects
04:10:26 <ajnsit> JuanDaugherty, thanks! I'll look it over
04:10:33 <Nimatek> JuanDaugherty: Yeah, depending on the size of the number.
04:12:20 <Egbert9e9> is there a module with similar capabilities to Image Magick?
04:13:12 <JuanDaugherty> you mean a haskell wrapper for IM?
04:13:26 <JuanDaugherty> wrapper/binding
04:13:31 <Egbert9e9> convert original.jpeg -resize 50% resized.jpeg
04:14:05 <Egbert9e9> JuanDaugherty: that or some unrelated implementation to I
04:14:06 <Egbert9e9> IM
04:14:29 <JuanDaugherty> oh, yeah there's prolly something that can create thumbnails, which is what that usually is
04:14:34 <Egbert9e9> there are all those functional images but they seem too CS to me <_<
04:15:02 <JuanDaugherty> why don't you just use IM then?
04:15:34 <Egbert9e9> i could, but i want to know my way around haskell
04:15:41 <JuanDaugherty> got it
04:15:46 <Egbert9e9> oh well, there's System.Process
04:22:28 <ski> quicksilver : heh, how can you recall when i suggested that syntax ?
04:22:37 <quicksilver> ski: I found it in an IRC log :)
04:23:07 * ski thinks he's probably talked about disjunctive patterns on and off for some years
04:23:36 <quicksilver> just think, if you'd invested that energy into writing a patch instead of talking? ;)
04:24:17 * ski has yet to attempt patching GHC
04:24:51 <ski> (also, istr i've pondered using colliding syntax for positional variants)
04:25:11 <ski> (or, hm, at least probably colliding)
04:30:31 * hackagebot uuagc 0.9.38.5 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.38.5 (ArieMiddelkoop)
04:33:32 * hackagebot CSPM-Frontend 0.7.4.4 - A CSP-M parser compatible with FDR-2.91  http://hackage.haskell.org/package/CSPM-Frontend-0.7.4.4 (MarcFontaine)
04:34:32 * hackagebot CSPM-CoreLanguage 0.3.0.0 - Definition of a FDR-compatible CSP core-language.  http://hackage.haskell.org/package/CSPM-CoreLanguage-0.3.0.0 (MarcFontaine)
04:35:34 * hackagebot CSPM-FiringRules 0.4.0.0 - Firing rules semantic of CSPM  http://hackage.haskell.org/package/CSPM-FiringRules-0.4.0.0 (MarcFontaine)
04:35:36 * hackagebot CSPM-ToProlog 0.4.0.0 - some modules specific for the ProB tool  http://hackage.haskell.org/package/CSPM-ToProlog-0.4.0.0 (MarcFontaine)
04:35:38 * hackagebot CSPM-Interpreter 0.5.1.0 - An interpreter for CSPM  http://hackage.haskell.org/package/CSPM-Interpreter-0.5.1.0 (MarcFontaine)
04:36:32 * hackagebot CSPM-cspm 0.5.6.0 - cspm command line tool for analyzing CSPM specifications.  http://hackage.haskell.org/package/CSPM-cspm-0.5.6.0 (MarcFontaine)
04:38:19 <ajnsit> what is FDR-2.91?
04:39:41 <ajnsit> never mind got it
04:41:57 <JuanDaugherty> wow, nice
04:42:18 <JuanDaugherty> (i.e. the CSPM update)
04:43:09 <erus`> whats the easiest way to create a stateful variable?
04:43:17 <erus`> like a global variable
04:43:39 <int-e> why do you want to do that?
04:43:55 <erus`> I need a database of users
04:44:06 <erus`> but i have a thread for each new socket
04:44:17 <erus`> so i cant pass it as an arg
04:44:47 <ClaudiusMaximus> i think you can?
04:44:52 <int-e> if the database can change, you can store it in an MVar, for example (which then you can pass as an argument to each thread)
04:45:20 <erus`> yeah it changes
04:46:08 <ClaudiusMaximus> ah, yes- you can pass the MVar containing the state to the thread, but passing the state would get out of date  (see also: atomicModifyIORef, STM)
04:47:14 <erus`> i only need to use it like an sql db
04:47:28 <erus`> for looking up passwords and such
04:47:36 <ClaudiusMaximus> debugging is fun - i wrote    phase z / 2 * pi   instead of   phase z / (2 * pi)  -- oops
04:48:01 <quicksilver> that sounds like what mvars are for.
04:50:51 <erus`> ClaudiusMaximus: thatl learn ya
04:51:25 <ClaudiusMaximus> erus`: :)
04:51:38 <erus`> can i set default line endings to windows somehow?
04:51:56 <JuanDaugherty> hot damn looks like the update for CSPM is working
04:52:03 <JuanDaugherty> *upgrade
04:52:24 <erus`> windows telnet needs \r\n :|
04:52:35 <quicksilver> all telnet needs \r\n
04:52:37 <JuanDaugherty> ewww
04:52:45 <quicksilver> that is the correct sequence in network protocols
04:53:09 <quicksilver> or am I mixing it up with something else?
04:53:19 <erus`> hPutStrLn isnt putting the \r bit
04:53:51 <erus`> define my own i guess
04:54:13 <quicksilver> just use hPutStr
04:54:16 <quicksilver> and put the \r\n explicitly
04:54:23 <erus`> quicksilver: yeh just wrote that
04:54:35 <erus`> telnetLn h m = hPutStr h $ m ++ "\r\n"
04:58:21 <JuanDaugherty> (FTR CSPM upgrade didn't work nor did cabal update and install of it)
04:58:24 <erus`> I'm making a bitcoin bank with a telnet interface
04:58:30 <erus`> for ultimate security
04:59:12 <JuanDaugherty> O_o
04:59:39 <amsl> JuanDaugherty is not amused.
05:01:10 <JuanDaugherty> about, CSPM? no, but I'm not ticked off about or nuthin
05:01:34 <JuanDaugherty> s/about,/amsl/
05:03:22 <amsl> Were you making that face at the bitcoin bank telnet interface for ultimate security remark?
05:03:28 <JuanDaugherty> yeah
05:03:45 <amsl> I presume it was a joke?
05:04:39 <JuanDaugherty> CSPM did install without error the first time, he probably just pushed some broken stuff and will be fixing
05:16:01 * JuanDaugherty had a permissions conflict which restall installing CSPM fixed.
05:16:07 <JuanDaugherty> *reinstall
05:18:25 <erus`> is there a built in way to handle backspaces in strings?
05:19:10 <saml> \b ?
05:19:13 <saml> > '\b'
05:19:17 <lambdabot>   mueval-core: Time limit exceeded
05:19:17 <erus`> no like
05:19:27 <erus`> remove the \b and the char before it
05:19:52 <saml> i don't know.
05:20:16 <quicksilver> no.
05:20:50 <erus`> oh god im gonna have to write some ugly fold
05:21:24 <saml> > let f a:_:'\b':xs = a:xs; f _:'\b':xs = xs; f "" = "" in f "hello\bworld"
05:21:26 <lambdabot>   <no location info>: Parse error in pattern
05:22:55 <exlevan> let f a:_:'\b':xs = a:f xs, to begin with
05:23:11 <hpc> also parens
05:23:16 <saml> :_P
05:23:29 <lunaris> I was thinking you could play a zipWith trick.
05:23:37 <lunaris> As usual for me, probably not efficient.
05:24:00 <ski> > let performBackspace = loop [] where loop acc [] = reverse acc; loop (_:acc) ('\b':s) = loop acc s; loop acc (c:s) = loop (c:acc) s in performBackspace "foo\b\brob"
05:24:00 <lambdabot>   "frob"
05:24:01 <saml> > let f (a:_:'\b':xs) = a:f xs; f (_:'\b':xs) = f xs; f "" = ""  in "hello\bworld"
05:24:02 <lambdabot>   "hello\bworld"
05:24:22 <ski> saml : try calling `f', at least :)
05:25:07 <exlevan> > '\' `elem` "hello\bworld"
05:25:08 <lambdabot>   <no location info>:
05:25:08 <lambdabot>      lexical error in string/character literal at chara...
05:25:55 <hpc> > "hello\bworld"
05:25:57 <lambdabot>   "hello\bworld"
05:26:12 <saml> we are all stupid
05:26:32 <saml> need a proper parser
05:26:39 <saml> please write template haskell version
05:28:46 <saml> > let f (a:_:'\b':xs) = a:f xs; f (_:'\b':xs) = f xs; f ('\b':[]) = ""; f (x:[]) = x:""; f (x:xs) = x:f xs; f "" = ""  in f "hello\bworld"
05:28:47 <lambdabot>   "hellworld"
05:28:53 <exlevan> yay
05:28:55 <saml> i did it. i r so smart. now i use haskell
05:29:05 <exlevan> enjoy your hellworld
05:29:26 <saml> this is beautiful OOP
05:30:29 <saml> i'm sure there is a bug. how would you expose the bug?
05:30:34 <saml> show me QuickCheck stuff
05:31:20 <ski> saml : now try passing it `"foo\b\brob"'
05:31:55 <saml> darn. u so smart
05:31:58 * ski idly wonders how saml could think that is OOP
05:32:21 <saml> i thought of each pattern as different Java Class object
05:32:29 <saml> and obj.f()
05:32:34 <ski> > let f (a:_:'\b':xs) = a:f xs; f (_:'\b':xs) = f xs; f ('\b':[]) = ""; f (x:[]) = x:""; f (x:xs) = x:f xs; f "" = ""  in f "foof\b"
05:32:35 <lambdabot>   "foo"
05:32:54 <saml> if we use frp, it's easy, right?
05:33:17 <ski> i have no idea why FRP would be appropriate here
05:33:57 <ski> the patterns are not really similar to classes or objects at all ..
05:34:15 <ski> (in fact, pattern-matching is more or less the dual of method-dispatching)
05:34:22 <saml> i think they are the same. pattern matching .. runtime method dispatching
05:34:32 <osfameron> what does "dual" mean?
05:34:43 <saml> opposite of solo?
05:34:55 <ski> osfameron : the "same" concept, in the opposite category
05:35:20 <osfameron> ah.  and is OOP the "opposite category" to FP ?
05:35:33 <ski> in this case, the duality is that between categorical products, and categorical coproducts
05:35:39 * osfameron thinks of OOP multiple dispatch as being quite similar to FP pattern matching
05:35:45 <ski> osfameron : not directly
05:35:59 <ski> consider this
05:36:07 <osfameron> ah, so is "co-" really "the opposite of" ?
05:36:35 <ski> (no, "co-" means "same concept, but in the opposite category")
05:36:55 <ski> we have an abstract type `Shape'
05:37:00 <osfameron> so "co-" is just the prefix form of "dual" ?
05:37:06 <ski> more or less, yes
05:37:43 <ski> a `Shape' can be any of a `triangle', a `rectangle', an `ellipse', and possibly more variants
05:37:47 <osfameron> ok
05:37:58 <ski> this is some possible ways to *construct* `Shape's
05:38:01 <george_z0rwell> What does $= mean? I keep seeing it pop up in OpenGL-related code
05:38:31 <ski> now, we also want some *properties* on `Shape's
05:38:45 <ski> like `circumference',`area'
05:39:50 <ski> so, we have (at least) 3 possible variants, each of which should have an implementation for each of the two (or more) properties
05:40:03 <ski> so that's 3 * 2 special cases we have to implement
05:40:13 <osfameron> ok
05:40:28 <ski> what one typically does in OO is to say `3 * 2 = 2 + 2 + 2'
05:40:48 <osfameron> hmm?
05:40:52 <ski> i.e. group all the property implementations together for each variant shape
05:40:56 <osfameron> oh, that each special case is implemented in each class
05:41:17 <ski> so, one class implements `area' and `perimeter' for `triangle'
05:41:28 <ski> one class implements them for `rectangle', &c.
05:41:31 <osfameron> ah, and in FP you'll have area Triangle = ..., area Square = ..., etc.
05:41:37 <ski> yeah
05:41:47 <ski> so FP typically does `3 * 2 = 3 + 3'
05:42:08 <quicksilver> george_z0rwell: it's an operator for setting chunks of state in the IO monad.
05:42:19 <ski> so, in "OO", it's easy to add a new variant shape, but it's hard to add (or modify) a property, since you have to modify all the classes
05:42:24 <quicksilver> george_z0rwell: it works on IORefs but it's mainly used in OpenGL for various bits of the OpenGL state machine.
05:42:37 <george_z0rwell> quicksilver: Is there a page for this somewhere? Hoogle has nothing.
05:42:56 <ski> while in "FP", it's the other way around, it's easy to add more properties (= pattern-matching functions), but harder to add more variants (needs to modify every pattern-matching function)
05:42:57 <saml> > let f [] s = s; f ('\b':xs) [] = f xs []; f ('\b':xs) (y:ys) = f xs ys; f (x:xs) s = f xs (x:s); g s = reverse (f s "")  in g "foo\b\brob"
05:42:59 <lambdabot>   "frob"
05:43:06 <quicksilver> george_z0rwell: http://hackage.haskell.org/package/StateVar
05:43:07 <saml> i did it. i get haskell badge
05:43:13 <george_z0rwell> I'll look up IORef though, that's probably a good start, cheers
05:43:32 <george_z0rwell> Oh hey, that's it. Thanks!
05:43:43 <osfameron> ski: though... in some cases, in OO it won't be so hard, due to inheritance of default implementations.  Whereas in FP you really *do* need to write a variant pattern match for each type, don't you?
05:43:54 <osfameron> but ok, so are those 2 approaches "categories" then?
05:43:55 <ski> osfameron : this is basically the duality between working with record types (~= classes, in this context), and working with variant types (algebraic data types are variant types where each constructor can carry more than one part)
05:44:01 <saml> are you still talknig about OOP?
05:44:17 <ski> osfameron : yeah, this is a comparision between "FP" and "OO"
05:44:27 <ski> in actuality, there's more things that differ
05:44:32 <saml> you can do inheritance this way:  data Foo = Base | Derived Foo
05:44:43 <ski> OO typically has subtyping
05:44:51 <osfameron> are "FP" and "OO" categories then?
05:45:03 <ski> and yes, commonly implementation inheritence
05:45:17 <aavogt> saml: that won't be productive for infinite input
05:45:34 <saml> aavogt, then how would you do it?
05:45:41 <ski> you could easily imagine adding inheritance for variant types as well (maybe it should be called "coinheritence", though)
05:45:48 <saml> is there automatic way of transforming left folds to right folds?
05:46:09 <ski> (and logicians and mathematicians often uses coinheritence, to reuse old proofs, jsut adding another case to the induction)
05:46:18 <hpc> saml: there's an implementation of foldr using foldl, if that counts?
05:46:28 <osfameron> is there a coinheritance language extension for haskell?
05:46:51 <ski> aavogt : it can't really be, if you allow arbitrarily many `\b's to cancel out previous characters
05:47:06 <saml> why do you make it so complicated?  can't you guys just make it work like D-Wave?
05:47:57 <ski> osfameron : no. there was an experimental language called O'Haskell. and there's an offspring of that called Timber .. i don't recall if it has coinheritence, though .. it has subtyping for both record and variant types for sure, though
05:48:21 * hpc imagines O'Haskell is an irish name
05:48:27 <saml> \b is like serial protocol like midi
05:48:45 <saml> \b changes state
05:49:01 <osfameron> ski: given that there are language extensions for almost any useful concept (if only proof of concept for PhD papers) that would suggest that coinheritance hasn't been found as useful a concept as its dual is in OO?
05:49:19 <saml> what is coinheritance?
05:49:55 <osfameron> saml: I've just googled D-Wave, and I have to say I've never heard the metaphor "As easy as quantum computing!" ;-P
05:49:57 <saml> it says joint inheritance
05:50:20 <quicksilver> osfameron: there have been quite a few papers about OO in haskell; O'Haskell was an actual language extension; OOHaskell is a exploration of what you can do using haskell98.
05:50:25 <osfameron> saml: ski's just been explaining it to me above
05:50:29 <saml> and inheritance is property assing at the owner's death
05:50:48 <quicksilver> osfameron: there is also the practical experience of all the people who've bound OO libraries to haskell.
05:50:54 <quicksilver> osfameron: (see wxWidgets, GTK, etc)
05:51:05 <quicksilver> who have chosen different ways to model the inheritance.
05:51:05 <osfameron> saml: but, to regurgitate what I've understood, "coinheritance" would be inheritance for variant types (as per FP), as opposed to record types (OO)
05:51:25 <quicksilver> Out of all of this work, nothing has emerged which people appear to find compelling for practical programming in haskell.
05:51:56 <saml> thanks osfameron . i noticed i don't even understand what inheritance is in programmming
05:52:06 <saml> so there's work to do quicksilver !
05:52:36 <osfameron> quicksilver: that's interesting.  I suppose even in OO, the recent resurgence of traits etc. are suggesting that implementation inheritance isn't all either
05:52:38 <Saizan> ski: would you say type families are an example of coinheritance?
05:52:49 <osfameron> but it's had a good run of usefulness nonetheless
05:53:14 <osfameron> so... co-concepts aren't necessarily as equally powerful/applicable as the concept in the dual ?
05:53:24 <ski> Saizan : not at all, afaiu (maybe it can be used to model it in some way, i dunno)
05:53:27 <quicksilver> osfameron: my informal observation from my own experience is that implementation inheritance seems to be a fairly good model of GUI widgets, and a fairly bad model of pretty much anything else.
05:53:51 <osfameron> quicksilver: heh
05:53:56 <beate> Hi there! I wondered what's the best way to parse the syntax and semantics of programs written in a very simple C-like language? parsec? alex? Any suggestions are highly appreciated!
05:53:57 <quicksilver> osfameron: but then, I can only speak for the programs that I have bothered to understand deeply.
05:54:24 <quicksilver> osfameron: still it can't be a coincidence that all the convincing examples are GUI widgets. This car/vehicle or person/employee rubbish is daft.
05:55:02 <Saizan> ski: but you can extend them to handle more cases (i.e. more types) later
05:55:20 <ski> osfameron : these papers by Erik Poll explains coinheritence <http://www.cs.ru.nl/E.Poll/papers/index.html>,<http://www.cs.ru.nl/E.Poll/papers/kyoto97.pdf>,<http://www.cs.ru.nl/E.Poll/papers/cmcs00.pdf>,<http://www.cs.ru.nl/E.Poll/papers/ita01.pdf>,<>
05:55:37 <jmcarthur> osfameron: i'm not sure that one could prove *or* disprove this: forall x. is_useful(dual(x)))
05:56:03 <jmcarthur> usefulness changes with time
05:56:05 <hpaste> fryguybob pasted “Random element” at http://hpaste.org/48256
05:56:11 <jmcarthur> as we discover other things, etc.
05:56:24 <ski> Saizan : yeah, but coinheritence is about first having subtyping, so you can say one type extends another, and then to be able to extend functions pattern-matching on the first type to one pattern-matching on the new, larger, type
05:56:26 <fryguybob> Is http://hpaste.org/48256 reasonable?
05:56:34 <ski>   data BW = Black | White
05:57:01 <ski>   data Color > BW = Red | Green | Blue | Yellow | Cyan | Magenta
05:57:06 <osfameron> ski: thanks
05:57:14 <ski> is a silly subtyping example for variant types
05:57:16 <kapper> Can anybody help get Gnuplot working? Trying the Demo.hs, I kep getting this:  Could not find module `Paths_gnuplot'
05:57:51 <ski> so if you have a funtion with signature `frob :: BW -> Foo', coinheritance will let you extend that to handle the full `Color' type
05:57:59 <Saizan> ski: ah, true, we don't have enough kinds
05:58:17 <ski> it's not about kinds, afai see it
05:58:27 <ski> you wouldn't need more kinds for subtyping
05:58:33 <Saizan> well, i'm lifting everything a level up
05:58:58 <Saizan> so subtyping is subkinding, since type families are pattern matching on types, not values
05:59:06 <ski> (you would need a "row" kind, for row polymorphism, which can achieve somewhat similar things as subtyping, but that's still another thing)
05:59:24 <ski> oh
05:59:40 <ski> well, in that sense, type functions are (generally) partial functions
06:00:13 <ski> so, *open* partial functions
06:01:06 <ski> (one has to distinguish between adding more cases to an already existing type/kind, and adding more cases, making a *new* type/kind (which becomes a supertype/superkind to the old one))
06:01:08 <absence> is there a more elegant way to express "concat <$> sequence (map someMonadFunc someList)"? (that is, convert [IO [a]] to IO [a])
06:01:25 <hpc> :t flip
06:01:28 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
06:01:48 <hpc> hmm
06:02:00 <hpc> :t mapM
06:02:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
06:02:12 <hpc> :t mapM id
06:02:13 <lambdabot> forall (m :: * -> *) b. (Monad m) => [m b] -> m [b]
06:02:16 <ski> Saizan : if you want, you could check those Poll papers, as well
06:02:32 <hpc> absence: fmap join . mapM id?
06:02:38 <hpc> :t fmap join . mapM id
06:02:39 <lambdabot> forall a (f :: * -> *). (Functor f, Monad f) => [f [a]] -> f [a]
06:02:47 * ski doesn't really recall which of them contained the most (from this POV) interesting discussions, but it should be in those, at least
06:04:03 <jmcarthur> :t fmap join . sequence
06:04:04 <lambdabot> forall a (f :: * -> *). (Functor f, Monad f) => [f [a]] -> f [a]
06:04:47 <quicksilver> absence: I'd write it concat $ mapM someMonadFunc someList
06:04:58 <quicksilver> absence: concatMapM has occasionally been proposed.
06:05:04 <quicksilver> fmap concat, sorry
06:05:18 <hpc> :t concatMap
06:05:19 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
06:05:48 <ski> @type foldr (liftM2 (++)) (return [])
06:05:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m [a]] -> m [a]
06:05:56 <absence> ahh, i had forgotten all about mapM :) thanks
06:06:20 <jmcarthur> the thing that sucks about applying fmap concat to the result is that it has to perform all the actions before it can begin concatenating
06:06:56 <ski> jmcarthur : `unsafeInterleaveIO' to the rescue ?
06:07:07 <jmcarthur> that would be a hacky way to circumvent that, yeah
06:07:28 <ski> (otherwise you can't really get around it, i think)
06:07:32 <jmcarthur> sure you can
06:07:51 <jmcarthur> sequence $ concatMap someMonadFunc someList
06:07:59 <ski> well, you can of course keep an accumulator
06:08:02 <jmcarthur> err
06:08:05 <jmcarthur> oh that won't work
06:08:11 <jmcarthur> yeah you'd have to do your own recursion i think
06:08:19 <jmcarthur> or some sort of fold at least
06:08:38 <ski> you can't cons the result until both `action' and `actions' have been run
06:08:41 <jmcarthur> there's no really nice way to do it
06:09:07 <ski> hm .. i wonder whether tail-call-modulo-cons could be made to handle this kind of thing nicely
06:09:10 <Saizan> to do what, precisely?
06:09:33 <jmcarthur> Saizan: concatMapM, basically
06:10:24 <jmcarthur> :: Monad m => (a -> m [b]) -> [a] -> m [b]
06:10:49 <jmcarthur> i guess there isn
06:10:51 <jmcarthur> oops
06:11:10 <Saizan> yeah, but if (fmap concat . mapM f) doesn't qualify you must have some other requisite in mind
06:11:23 <jmcarthur> i guess there isn't *really* any harm in the earlier proposed version because the result must have the full list anyway
06:11:56 <jmcarthur> i'm sorry, i've been learning some ocaml today and my mind is in weird places concerning effects
06:15:01 <ski> osfameron : in particular categories, a concept and its dual may behave "differently" .. e.g. in the category of groups, all epimorphisms are regular, but not all monomorphisms are regular (epi is the dual concept to mono)
06:16:05 <ski> jmcarthur : well, it depends on where (in which category) you ask the question. e.g. the dual concept to exponentials are coexponentials, but in the category of sets, all coexponentials are trivial, which makes it boring to consider there
06:16:05 * osfameron should look at learning cat theory
06:16:11 <osfameron> or at least take TaPL out of the library again
06:16:23 <ski> roughly "exponentials" is "function types"
06:16:40 <ski> and "coexponentials" is often called "subtraction types"
06:17:09 <ski>   curry   :: (a -> (b,c)) -> (a -> (b -> c))
06:17:26 <jrick> so I'm trying to insatll gtk2hs on windows 7 and had to manually unpack the cairo package to fix a bug. after changing that it builds and installs correctly, but when I go back to build the rest of gtk it tries to build a broken cairo again, how can I fix this?
06:17:29 <ski>   cocurry :: (Either a b -> c) -> (a -> (b >- c))
06:17:48 <hpc> type a >- b = a -> b?
06:17:51 <ski> no
06:18:25 <ski> er, sorry, i mistyped above
06:18:32 <dcoutts> jrick: do a micro version bump on your modified cairo
06:18:36 <ski>   curry   :: ((a,b) -> c) -> (a -> (b -> c))
06:18:43 <dcoutts> jrick: e.g. append a .1 or .$date
06:18:50 <ski>   cocurry :: (a -> Either b c -> ((a >- b) -> c)
06:18:53 <ski> that's corrected
06:18:57 <jrick> dcoutts: ok, I'll give that a try
06:19:08 <ski> (s/Either b c/Either b c)/)
06:19:13 <hpc> ski: and what is (>-)?
06:19:33 <ski> so, given a function from `a' to `Either b c', where we think of `b' as a type of exceptional results
06:19:33 <hpc> i remember seeing that notation before, but can't remember what it is
06:19:39 <hpc> ah
06:19:43 * hackagebot happstack-server 6.1.5 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.1.5 (JeremyShaw)
06:19:44 <ski> `cocurry' gives us a function from `a >- b' to `c'
06:19:58 <ski> which just returns a `c' already
06:20:32 <ski> if the former would have raised an exception of type `b', then the latter function instead calls the "exception handler" of type `b' which is embedded inside the `a >- b' argument
06:20:32 <hpc> i think you got the parens wrong on cocurry
06:20:38 <ski> yeah
06:20:42 <ski>   cocurry :: (a -> Either b c) -> ((a >- b) -> c)
06:21:05 <ski> so a value of type `a >- b' consists of a value of type `a', and a *continuation* of type `b'
06:21:19 <ski> it's basically the context of a function call
06:21:32 <ski> if you have a call `..(f x)..'
06:21:43 <ski> then the context to the call to `f' consists of the argument `x' of type `a'
06:22:08 <ski> and the continuation `..(<hole>)..' of type `b' (meaning that it accepts a result of type `b' from the call)
06:22:23 <ski> symbolically :
06:22:34 <ski>   call :: (a -> b) -> (a >- b) -> Void
06:24:22 <ski> osfameron : btw, no "FP" and "OO" here wouldn't (necessarily) be different categories, just different styles of coding inside a (possibly) single category
06:25:12 <jrick> dcoutts: thanks, that seems to have worked. now to just figure out why all the other packages fail too...
06:25:16 <ski> another assymetry between dual concepts in the category of sets is subobjects vs. quotient/factor objects
06:25:48 <ski> the category of sets has what is called a "subobject classifier", but it doesn't have a "quotient/factor object classifier"
06:26:25 <ski> this basically means that if you have a set `A', and a subset `S' of `A', then you can describe `S' by a function from `A' to `2' (i.e. `Bool')
06:26:37 <ski> so you can describe subsets by characteristic functions
06:27:14 <absence> is join and concat the same for a list?
06:27:25 <Saizan> yes
06:27:36 <hpc> @src concat
06:27:37 <lambdabot> concat = foldr (++) []
06:27:41 <hpc> @src [] join
06:27:41 <lambdabot> Source not found. Just what do you think you're doing Dave?
06:27:46 <hpc> humbug
06:27:59 <ski> but if you have a set `A', and a quotient/factor set `F' of it (i.e. you have added some equivalence relation to `A', to identify some values in it), then there is no way to describe such factor objects by functions from a "quotient/factor object classifier" `FC' to `A'
06:29:12 <absence> is it preferable to use join because it's more general, or concat to make the specific type visible?
06:29:34 <ski> absence : i would probably use `concat', if i'm using lists
06:30:03 <ski> (so the reader can see at a glance that this is on lists, rather than some arbitrary monad, which the user has to infer which it is)
06:30:22 <ski> though if you later want to generalize, it might be better to use `join'
06:30:22 <Saizan> join is more appropriate only if you're using them to model non-determinism
06:31:02 <hpc> i prefer to use join, even when dealing with strings that i am obviously concatenating
06:31:20 <hpc> it reminds me that i can use other monadic tricks too
06:31:34 * ski has used `do'-notation, to generate a string for pretty-printing something
06:31:39 <hpc> like 'objects >>= show'
06:31:51 <absence> so in the end it's a matter of taste
06:33:11 <osfameron> heh, I'm now in correspondance with the artist who drew the background image for my slides on Haskell
06:33:22 <osfameron> they're great pictures, and he's an interesting, possibly slightly bonkers, guy
06:34:46 <ski> > do (name,values) <- [("foo",[0,1,2]),("bar",[3,4])]; name `mplus` do {value <- values; "\t" `mplus` show value} `mplus` "\n"
06:34:47 <lambdabot>   "foo\t0\t1\t2\nbar\t3\t4\n"
06:37:51 * hackagebot couchdb-enumerator 0.2.1 - Couch DB client library using http-enumerator and aeson  http://hackage.haskell.org/package/couchdb-enumerator-0.2.1 (JohnLenz)
06:42:44 <sam9> I have a question about a code
06:42:54 <sam9> rootpower :: Integer -> Integer -> [Integer]
06:43:02 <sam9> rootpower root length = take (fromIntegral length) (iterate (root*) 1)
06:43:10 <sam9> is there a simpler way than putting fromIntegral?
06:43:23 <ski> @type genericTake
06:43:24 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
06:43:32 <sam9> oh I see...
06:43:35 <sam9> a simple solution
06:43:43 <mauke> or change the type to use Int
06:43:58 <ski> (basically, the `genericFoo' is what `foo' *should* have been)
06:45:56 * ski . o O ( `t < Branch l t  =  t =< l \/ t =< r; Branch l r =< t  =  l < t /\ r < t' )
06:52:10 <erus`> how do i catch sexceptions?
06:52:38 <ski> @hoogle catch
06:52:39 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
06:52:39 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
06:52:39 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
06:52:50 <RichardBarrell> You want the Control.Exception one.
06:53:34 <ski> if you're in control, you could also alternatively use `Either e' or something similar
06:54:42 <erus`> i have a telnet server with logins and registrations :D
06:54:58 <erus`> send me your bitcoins
06:55:25 <Clint> you now have all of my bitcoins
06:55:27 * ski misses the telnet interface to the library ..
06:56:39 * lispy used to run a starwars (ascii art version) on his telnet port
06:56:48 <lispy> star wars movie*
06:57:12 <lispy> I forget which one but I think it was "A New Hope"
06:57:19 * ski once saw a football match cast on telnet
06:57:20 <sam9> types Integer and Int is keep confusing me...
06:57:22 <sam9> http://hpaste.org/48257
06:57:26 <ski> (live)
06:57:58 <hpaste> erus` pasted “beautiful code” at http://hpaste.org/48258
06:58:07 <erus`> look at the mess
06:58:31 <Kaidelong> sam9: Integer is arbitrarily percise, Int's percision depends on the machine, but is always finite
06:58:56 <Kaidelong> actually the same is true of Integer, technically, but hand-wavily it is arbitrarily precise in that it is limited only by available memory
06:59:19 <ski> sam9 : `genericTake'
06:59:30 <Kaidelong> > 450^39 :: Integer
06:59:31 <lambdabot>   298736327172458152676544483269194739277736516669392585754394531250000000000...
06:59:35 <Kaidelong> > 450^39 :: Int
06:59:36 <lambdabot>   -6270399914241425408
06:59:46 <ski> sam9 : why `100', btw ?
06:59:53 <quicksilver> Kaidelong: if you overflow Int it will wraparound. If you overflow Integer you will drive your machine deep into swap until it grinds to a halt or kills the process.
07:00:02 <quicksilver> Kaidelong: this is some kind of operational difference ;)
07:00:14 <ski> you can't overflow `Integer'
07:00:19 <ski> (that's the point of it)
07:00:29 <quicksilver> no, but you can exceed the capability of your machine to process
07:00:35 <Kaidelong> ski: but you can overflow your machine unless it, itself has infinite memory
07:00:35 <quicksilver> which is what i was trying to say.
07:00:38 <sam9> I just wanted to try up to numbers as big as 100
07:00:42 <sam9> because some numbers don't have roots
07:00:48 <sam9> so it will go to infinite
07:01:22 <ski> sam9 : can't you do an upper bound based on `num' ?
07:01:30 <Kaidelong> @ty take
07:01:30 <lambdabot> forall a. Int -> [a] -> [a]
07:01:35 <Kaidelong> there's the problem
07:01:35 <ski> @type genericTake
07:01:36 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
07:02:00 <Kaidelong> GHC needs its own prelude
07:02:15 <Kaidelong> because genericTake really should not be neccessary
07:02:17 <ski> Kaidelong : yeah, third time sam9 is told that :)
07:02:35 <quicksilver> well, Integer is *so much* slower than Int
07:02:50 <Kaidelong> so {#- SPECIALIZE ... #-}
07:02:52 <sam9> I don't quite understand (Integral i) => i -> [a] -> [a]
07:03:00 <quicksilver> that there is some pragmatic justification for having various prelude functions based on it
07:03:04 <sam9> aren't I just taking a number and output a number?
07:03:12 <Kaidelong> @instances-importing Integral
07:03:12 <lambdabot> Int, Integer
07:03:13 <sam9> why take a number and array array?
07:03:24 <ski> s/array/list/
07:03:31 <sam9> I mean why is there two lists?
07:03:40 <Kaidelong> yeah arrays allow efficient random access but not efficient tails
07:03:45 <ski> sam9 : `take' and `genericTake' both takes a number and a list, and returns a list
07:03:46 <lispy> sam9: the last list is the returned type
07:04:02 <sam9> then what is the middle list?
07:04:10 <lispy> input
07:04:16 <Kaidelong> @ty genericTake
07:04:17 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
07:04:21 <Kaidelong> @ty genericTake 504923
07:04:22 <lambdabot> forall a. [a] -> [a]
07:04:23 <lispy> > genericTake 10 [1..100]
07:04:24 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
07:04:25 <b0fh_ua> Hi. I want to convert Floating into Num, how should I do that?
07:04:40 <quicksilver> realToFrac, b0fh_ua
07:04:46 <quicksilver> although it doesn't do everything you asked.
07:04:47 <Kaidelong> @ty genericTake 405948 "e040390e9409"
07:04:48 <lambdabot> [Char]
07:04:49 <sam9> I tried genericTake and it worked but I just want to learn why i 0> [a] -> [a] works...
07:05:02 <lispy> ?hoogle (Floating a, Num b) => a -> Num b
07:05:03 <lambdabot> Warning: Unknown type Num
07:05:03 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
07:05:03 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
07:05:13 <lispy> oops
07:05:16 <lispy> ?hoogle (Floating a, Num b) => a -> b
07:05:17 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
07:05:17 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
07:05:17 <lambdabot> Data.List genericLength :: Num i => [b] -> i
07:05:19 <Kaidelong> sam9: because Integer satisfies the "Integral" constraint
07:05:38 <edwardk> preflex: xseen kmc
07:05:38 <preflex>  kmc was last seen on freenode/#haskell 8 hours, 43 minutes and 6 seconds ago, saying: > text . reverse . show $ [LT .. GT]
07:05:47 <b0fh_ua> quicksilver: okay, I want to get square root from Int, then convert it back to Int
07:05:50 <Kaidelong> the "(Integral i) => i" means "any type i that satisfies the integral constraint"
07:05:56 <quicksilver> b0fh_ua: ah well that's a different question.
07:06:03 <quicksilver> b0fh_ua: there is no lossless way to do that
07:06:15 <quicksilver> b0fh_ua: you have to choose between round, ceiling and floor
07:06:29 <sam9> Kaidelong so i is not considered an input?
07:06:40 <Kaidelong> i is the type of the first argument
07:06:50 <sam9> oh...
07:06:54 <b0fh_ua> well, not sure
07:06:58 <Kaidelong> additionally, the type is constrained
07:07:02 <sam9> then i -> [a] -> [a]?
07:07:04 <ski> sam9 : i think you want `[1 .. num-1]' rather than `[1..100]'
07:07:08 <b0fh_ua> no instance for (RealFrac Int)
07:07:11 <Kaidelong> even though it looks likt it is a free variable "i"
07:07:13 <ski> (or maybe `[0 .. num-1]' .. hm)
07:07:27 <Kaidelong> the (Integral i) => in front means i has to be a bit special]
07:07:53 <sam9> you are right ski I think [1..num-1]
07:08:02 <sam9> its meaningless testing numbers bigger than num itself
07:08:22 <sam9> so when I write (Integral i) => i -> [a] -> [a]
07:08:23 * ski ponders whether there are any primitive roots, in module `1'
07:08:35 <b0fh_ua> aha, got it
07:08:45 <quicksilver> > round . sqrt $ 34
07:08:47 <sam9> then I'm saying take i that is Integral type
07:08:49 <lambdabot>   mueval-core: Time limit exceeded
07:08:51 <sam9> ??
07:09:06 <Kaidelong> that is the type of all functions which take an arbitrary i of the integral type, a list of any type, and return a list of any type
07:09:11 <Kaidelong> @ty genericTake
07:09:12 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
07:09:16 <Kaidelong> @ty genericDrop
07:09:16 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
07:09:27 <sam9> I see
07:09:28 <ski> i suppose `0' is a primitive root modulo `1' ?
07:10:13 <sam9> hm.. that's actually a good question...
07:10:20 <sam9> but 0 is not considered prime...
07:10:33 * ski considers zero a prime ..
07:10:43 <sam9> is it a prime?
07:10:48 <Kaidelong> but zero can be evenly divided by arbitrary numbers
07:10:59 <absence> is it possible to use the contents of a list as functino parameters? e.g if i have [a b c], can i somehow call f a b c?
07:11:00 <Tomsik> 0 is divisible by many more things than 1 and 0
07:11:17 <ski> it satisfies `forall a,b. 0 | a*b => 0 | a \/ 0 | b' :)
07:11:23 <mauke> absence: only manually
07:11:56 <Kaidelong> zero and one do not have two factors
07:12:11 <Kaidelong> prime means exactly two prime factors I think
07:12:15 <mauke> that means they can't be used in two-factor authentication
07:12:18 <Kaidelong> err
07:12:21 <Kaidelong> two factors
07:12:26 <mauke> WHICH RULES OUT ALL COMPUTERS
07:12:27 <Kaidelong> one is one
07:12:30 <edwardk> tomsik: depends on what field you are in. ;)
07:12:32 <Kaidelong> and the other is the prime itself
07:12:36 <mauke> oh god what have I done
07:13:05 <Tomsik> edwardk: one does not say "a prime number" in other fields. It's prime polynomials for example, but not numbers.
07:13:13 <edwardk> =)
07:14:00 <ski> well, primality is `forall p. prime p <=> (p | 1 => False) /\ (forall a,b. p | a*b => p | a \/ p | b)'
07:14:54 <ski> so in the trivial ring, zero is not a prime (since it divides the multiplicative unit)
07:15:01 <sam9> http://hpaste.org/48259
07:15:18 <ski> (and of course it's not, in non-division rings)
07:16:45 <saml> :t genericLength
07:16:46 <lambdabot> forall b i. (Num i) => [b] -> i
07:17:01 <absence> mauke: manually as in typing it out, or using e.g. fold?
07:17:05 * ski discovers sam9 is not saml
07:17:19 <ski> absence : as in manually typing it out
07:17:22 <edwardk> or samy
07:17:25 <lispy> and saml is probably not SAML
07:17:40 <ski> (you could probably do a `Printf'-like hack ..)
07:17:43 <lispy> http://en.wikipedia.org/wiki/Security_Assertion_Markup_Language
07:17:51 <saml> saml is Scaling Asynchronous ML
07:18:08 <saml> your primeroot function is so difficult to read i don't know what's going on
07:18:37 <ski> (edwardk : bahra ?)
07:18:40 <edwardk> ski: are you sure? you might not have taken a large enough sampl
07:19:07 <edwardk> ski: yeah
07:19:41 <edwardk> ski: i wrote up that tighter free monad
07:19:48 <Saizan> edwardk: btw, i forgot earlier, the type of walk lacks an argument
07:19:59 <edwardk> woops. fixing
07:20:16 <ski> edwardk : and is it better to use the `Yoneda'-`Free'-version ?
07:21:54 <hpaste> “Ben Gamari” pasted “IO typing error” at http://hpaste.org/48260
07:22:00 <edwardk> ski: yeah
07:22:14 <bgamari> Could someone give me a handing figuring out a     Couldn't match expected type `IO a0' with actual type `a1 -> c0'
07:22:23 <bgamari> On this code, http://hpaste.org/48260
07:22:35 <edwardk> Yoneda (Rec f) ~ Free f, but has faster binds in exchange for more painful repeated pattern matching
07:22:36 <bgamari> It seems that ghc's error message is woefully inadequate here
07:22:37 <edwardk> but then free is just about construction for the most part
07:22:40 <Botje> bgamari: can you annotate the paste with the full error?
07:22:41 <ski> sam9 : just like before, `take' wants `Int', so can't promise to work with any `Integral' `i' type
07:23:01 * hackagebot random-fu 0.1.4 - Random number generation  http://hackage.haskell.org/package/random-fu-0.1.4 (JamesCook)
07:23:06 <edwardk> so if you only need to build it, better to build it using the Yoneda (Rec f) representation then convert
07:23:10 <mux> bgamari: isn't mkStdGen in IO?
07:23:19 <mux> that would explain your error
07:23:23 <hpaste> “Ben Gamari” annotated “IO typing error” with “IO typing error (annotation)” at http://hpaste.org/48260#a48261
07:23:31 <ski> edwardk : the pain being static or dynamic ?
07:23:31 <shapr> :type mkStdGen
07:23:37 <bgamari> Botje: Done
07:23:44 <Kaidelong> @ty mkStdGen
07:23:45 <lambdabot> Int -> StdGen
07:23:46 <shapr> lambdabot: @type mkStdGen
07:23:46 <lambdabot> Int -> StdGen
07:23:51 <shapr> bah
07:23:52 <mux> well, my bad
07:24:14 <bgamari> mux: No worries
07:24:17 <mauke> :t t
07:24:17 <lambdabot> Expr
07:24:25 <edwardk> pain being that it is cps'd. so like any of these fusion hacks it may redo a lot of work
07:24:33 <Kaidelong> @hoogle IO StdGen
07:24:34 <lambdabot> Did you mean: :: IO StdGen /count=20
07:24:34 <lambdabot> No results found
07:24:50 <bgamari> Is it just me or does the error message greatly underdetermine the cause of the error
07:24:58 <Botje> bgamari: why not write forM_ (zip donorTs acceptorTs) $ \(a, d) -> do ... ?
07:25:07 <bgamari> It's a deeply nested statement yet it did little more than point me to the line number
07:25:12 <ski> bgamari : `forM_ . uncurry zip (donorTs, acceptorTs) (\a d -> ...)' looks bad
07:25:13 <mux> you just need to remove the dot after forM_, me thinks
07:25:15 <Botje> (also, shouldn't that be d, a?)
07:25:23 <mux> or replace it wiht a $
07:25:24 <bgamari> Botje: Beginner
07:25:24 <ski> bgamari : `zip' doesn't want three arguments
07:25:48 <bgamari> ski: This is true
07:26:07 <bgamari> Botje: ski, fixed
07:26:12 <edwardk> heya copumpkin
07:26:19 <ski> @hoogle forM2
07:26:19 <lambdabot> No results found
07:26:23 <Botje> does it produce a different type error?
07:26:34 <copumpkin> hi edwardk
07:26:43 <bgamari> Botje: Bah, it produces no type error
07:26:46 <bgamari> Botje: Thanks
07:26:49 <Botje> :)
07:26:52 <Botje> no problem
07:26:55 <bgamari> Not really sure what was wrong with the first form
07:27:05 <ski> @let forM2_ :: Monad m => [a] -> [b] -> (a -> b -> IO c) -> IO (); forM2_ as bs = forM_ (zip as bs) . uncurry
07:27:06 <lambdabot>  <local>:1:0:
07:27:06 <lambdabot>      Ambiguous constraint `Monad m'
07:27:06 <lambdabot>          At least one of th...
07:27:07 <bgamari> I'm still a little irked by the poor error message though
07:27:09 <Botje> 'uncurry zip (donorTs, acceptorTs)' is nonsense
07:27:15 <ski> @let forM2_ :: Monad m => [a] -> [b] -> (a -> b -> m c) -> m (); forM2_ as bs = forM_ (zip as bs) . uncurry
07:27:17 <lambdabot>  Defined.
07:27:17 <Botje> bgamari: it's a perfectly cromulent error message
07:27:46 <Botje> bgamari: you should read it as 'you gave me too few or too many arguments'
07:27:50 <ski> bgamari : using that, you can say `forM2_ donorTs acceptorTs $ \donorT acceptorT -> ...'
07:28:01 * hackagebot satchmo 1.9.1 - SAT encoding monad  http://hackage.haskell.org/package/satchmo-1.9.1 (JohannesWaldmann)
07:28:03 * hackagebot satchmo-backends 1.9.1 - driver for external satchmo backends  http://hackage.haskell.org/package/satchmo-backends-1.9.1 (JohannesWaldmann)
07:28:09 <Botje> ski: ooh, sexy
07:28:29 <edwardk> bgamari error msgs in haskell are hard. type inference flows both way in hindley milner so it can be hard to pick out exactly what caused types to fail to unify
07:28:41 <bgamari> ski: Ahhh, that's true. Excellent
07:28:50 <edwardk> usually they at least point you to the area and give the types
07:29:02 <ski> Botje : as exercise, define a vararg version of it :)
07:29:04 <absence> ski: i'm experimenting in order to learn and have made a function cc a b = a b so that i can write ((ff `cc` 1) `cc` 2) `cc` 3, which works fine. why doesn't foldl cc ff [1,2,3]?
07:29:06 <bgamari> edwardk: Fair enough
07:29:25 <bgamari> Are there any general approaches to homing in an the actual issue?
07:29:28 * ski still wants type error slicing ..
07:29:30 <quicksilver> ski, bgamari : There is already zipWithM isn't there? Admittedly that's the opposite way around?
07:29:32 <Botje> ski: brr :P
07:29:35 <quicksilver> @hoogle zipWithM
07:29:35 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
07:29:35 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
07:29:35 <lambdabot> Data.Generics.Twins gzipWithM :: Monad m => GenericQ (GenericM m) -> GenericQ (GenericM m)
07:29:52 <zygoloid> bgamari: add type annotations
07:30:01 <quicksilver> I tend to use zipWithM and stifle my mild annoyance at the order being wrong.
07:30:06 <ski> quicksilver : yeah, i seemed to recall i'd seen something like this somewhere ..
07:30:12 <quicksilver> but I can see the attraction to forM2.
07:30:16 <bgamari> zygoloid: alright, that's what I've been doing so far
07:30:18 <bgamari> Thanks
07:30:38 <quicksilver> bgamari: splitting your functions into smaller functions helps, too
07:30:43 <Kaidelong> definitely
07:30:47 <quicksilver> (and that helps for other things like testing and code reuse)
07:30:51 <bgamari> quicksilver: True
07:30:56 <ski> bgamari : `Couldn't match expected type `IO a0' with actual type `a1 -> c0'' means that you're either passing too many or too few arguments to a function (basically)
07:31:02 <byorgey> absence: that won't work with foldl because the type at each point in the fold is different
07:31:15 <Kaidelong> ski: except the types are all different
07:31:21 <bgamari> In fact, if anyone has a better way to write both of these arrays out to files without killing laziness I'm all ears
07:31:23 <Kaidelong> a0, a1, and c0 have nothing to do with one another
07:31:31 <Kaidelong> so it is a deeper problem than a forgotten argument
07:31:32 <byorgey> absence: if you look at the type of foldl you'll see that the intermediate results must all have the same type as the final result.
07:31:46 <absence> byorgey: ah, right! thanks
07:31:51 <Kaidelong> oh well
07:32:02 <Kaidelong> I suppose c0 can unify with IO a0, in fact
07:32:06 <byorgey> absence: and by the way, cc is already defined, it is called ($)
07:32:08 <Kaidelong> so perhaps it is a forgotten argument
07:32:12 <erus`> a thunk is the noise one makes when pulling the cork out of a wine bottle
07:32:18 <ski> Kaidelong : i'm pretty sure GHC usually just displays whatever information it has currently inferred, as opposed to all there is to say about `a0',`a1',`c0' (meaning they could be the same)
07:32:37 <Kaidelong> yeah I just realized
07:32:41 <bgamari> Moreover, it seems that the GC is still eating 25% of my runtime
07:32:46 <byorgey> absence: and ((ff `cc` 1) `cc` 2) `cc` 3 == ff 1 2 3,  but perhaps you already knew that
07:32:51 <ski> Kaidelong : this is why type error slicing would be a good thing to have
07:32:52 <Kaidelong> if the argument it missing, GHC might not have enough information to determine the type of c0
07:33:41 <ski> Kaidelong : with type error slicing you get a listing of the exact program locations that have contributed to the error : at least one of the locations must change to remove the problem, and no irrelevant location is indicated
07:33:44 <Kaidelong> it still looks wrong though
07:33:58 <Kaidelong> why would it be mismatched against c0
07:34:29 <Kaidelong> when the type on the right hand side should be either IO a or a -> IO b
07:34:47 <quicksilver> ski: type error slicing is strictly high in information content
07:34:58 <quicksilver> ski: but I'm pretty sure it doesn't help the "newbie-friendliness" quotient much
07:35:04 <ski> (btw, it would be good if GHC displayed logic variables differently from skolems)
07:35:07 <quicksilver> ski: still, it would be good to have.
07:35:10 <quicksilver> ski: yes, that oto.
07:35:11 <quicksilver> too.
07:35:34 <ski> (e.g. display logic variables like `_a',&c.)
07:36:14 <byorgey> ski: that's a good idea.  And probably wouldn't be hard to implement.
07:36:46 <ski> quicksilver : i'm sure it would take some practice to be able to use and interpret type error slicing, but at least it should be easier not to search down the wrong part of the program, due to the error being discovered in one place, and the other contributing places not being reported
07:39:09 <quicksilver> skolem variables in red, logic variables in blue.
07:39:38 <quicksilver> successive error slices in shades from Ochre to Taupe.
07:39:53 <ski> (quicksilver : i mean, with some experience on interpreting type errors, you usually get an idea of what to look for, but it would be an improvement to get a bound on the contributing locations -- instead of randomly adding more type signatures and see if the displayed location changes)
07:40:08 * ski grins
07:41:22 <quicksilver> ski: I normally either spot them quickly or throw the program away and never look at it again ;)
07:41:33 <quicksilver> euch.. don't touch that it has type errors.
07:41:35 <ski> (btw, O'Caml displays logic variables like  '_a  )
07:42:01 <d7> So, http://www.iai.uni-bonn.de/~jv/mpc08.pdf seems really interesting.
07:42:03 <shapr> o hai edwardk
07:42:09 <d7> but, I confess
07:42:15 <d7> I do not know what the codensity monad is
07:42:22 <d7> and I'm having trouble finding a good writeup on it
07:42:32 <d7> Does anyone have one to recommend? Google is not being helpful.
07:43:08 <ski> d7 : `newtype CoDensity f a = MkCodensity (forall b. (a -> f b) -> f b)'
07:43:53 <ski> d7 : i think edwardk has some blog post on them
07:45:18 * ski wonders what a more sensible name for `MkCoDensity' would be ..
07:45:45 <d7> The McCodensity is back this year!
07:45:56 <ski> i suppose the inverse might be called `lowerBind'
07:46:27 <ski> so maybe `newtype CoDensity f a = UnLowerBind {lowerBind :: forall b. (a -> f b) -> f b}' or something like that ?
07:47:17 <ski> d7 : `Codensity' is used to effectively right-associate uses of `(>>=)'
07:47:36 <edwardk> i have about 3-4 posts that talk about codensity by now, in some fashion
07:48:12 <edwardk> Kan Extensions used it as Ran f f. then the Free Monads for Less series uses and eventually replaces Codensity.3
07:48:26 <ski> d7 : you may speak to the edwardk himself, for more obscuration of the concept
07:48:50 <edwardk> ski: hahahhahaa
07:49:09 <d7> edwardk: I was just looking for an introduction to it.
07:49:25 <d7> I can read the type signature, but I'm not to where I can really understand its intent.
07:49:39 <edwardk> d7: did you start with the free monads for less post?
07:49:40 <ski> d7 : "right-associate uses of `(>>=)'"
07:50:09 <d7> edwardk: Yes
07:50:22 <edwardk> d7: if you work with Codensity m instead of m. then lift in any individual m computation that you want to use. then Codensity m will take care of reassociating all of the uses of >>= to the right. it does so by >>= to the entire continuation, effectively.
07:50:39 <ski> d7 : `(act >>= frobnicate) >>= mumble' is typically inefficient, for similar reasons `(foo ++ bar) ++ baz' is
07:51:25 <d7> But this assumes that act and frobnicate don't significantly change things, right?
07:51:31 <edwardk> technically (f >>= g) >>= h is only inefficient if your monad doesn't do a lot of normalization in the join.
07:51:34 <edwardk> for instance its fine for Maybe
07:52:02 <d7> For example if you were editing a tree with a zipper and one of those functions adds a ton of nodes in, subsequent runs might miss it.
07:52:13 <ski> well, rechecking for `Nothing' every time after we've hit `Nothing' isn't very good
07:52:22 <edwardk> d7: it assumes that >>= doesn't reduce the structure much. if >>= just grows a tree or builds a bigger list, then you need to go right.
07:52:49 <d7> Well I've been playing at porting cgrand's enlive framework to haskell so I can use it with Hakyll
07:53:04 <ski> (d7 : .. i'm not sure what you have in mind by "change things")
07:53:14 <d7> And one of the big problems with enlive's approach is that it requires mutiple scans over an html document's node tree.
07:53:17 <edwardk> even so, left associated binds on Maybe are less damning (asymptotically) than they are for other monads.
07:53:37 <quicksilver> edwardk: do you really mean >=> ?
07:53:38 <ski> edwardk : because of no contraction, i'd gather ..
07:53:40 <edwardk> the asymptotic improvement comes from avoiding retraversal of a common core
07:54:04 <edwardk> quicksilver: well, the right associated form in question is a bit uglier. so association in the sense of the monad law.
07:54:05 <quicksilver> edwardk: (f >>= g) >>= h and f >>= (g >>= h) will not normally simultaneously type-check.
07:54:14 <ski> hm, well there's that as well, yes
07:54:27 * ski ponders whether contraction enters the picture
07:54:40 <edwardk> quicksilver; yes. i presumed the form of the monad law. (f >>= g) >>= h become f >>= \x -> g x >>= h
07:55:15 <edwardk> quicksilver: its prettier with Kleisli composition i agree, but i didn't want to introduce an incidental concept in the post.
07:55:27 <bgamari> Does anyone have any ideas why the previous code (http://hpaste.org/48260) would be allocating [] objects heavily in step with : ?
07:55:33 <quicksilver> edwardk: ok good, I wasn't criticising just trying to understand :)
07:55:38 <edwardk> ski: contraction being the renormalization done by bind or join?
07:56:15 <d7> So Codensity TravelBTree would work and potentially turn multiple scans into one pass
07:56:17 <edwardk> ski: then yes. this is why codensity is a win when building _free_ monads, but not always a win otherwise. in a free monad, there is _no_ possibility of gaining anything from a left associated bind.
07:56:17 <ski> edwardk : contraction being duplication of work
07:56:21 <d7> Of course I don't expect magic
07:56:36 <ski> edwardk : by which i was thinking about `mplus' for e.g. lists
07:56:40 <edwardk> d7: it is magic ;)
07:56:53 <bgamari> As far as I can tell, acceptorTs and donorTs should be evaluated fully lazily
07:56:57 <d7> For example, in c1 >>= c2, if c1 eats half the tree, c2 can't go back and undo that?
07:57:39 <d7> Because, ahhh
07:57:57 <d7> It seems to me like if that really works the way I am imagining it might, you might as well weld codensity onto the travel monads.
07:57:58 <ski> d7 : i'm not sure which monad you have in mind here .. a state monad ?
07:58:15 <d7> ski: I was thinking about http://www.haskell.org/haskellwiki/Zipper_monad
07:58:31 <d7> ski: I dunno if when I say "enlive templating" or "DFT" that means anything to you
07:58:46 <d7> But it's a really awesome way of doing templating if you can make it performant, and web work is near and dear to my heart.
07:59:42 <d7> It has many of those buzz-properties FP folks love, like "composability", which are sorely lacking in other html generation techniques which don't require all parties to work in the source language.
08:00:00 <ski> d7 : nah, never heard
08:00:14 * ski hasn't seen this `Travel' before
08:00:50 <d7> ski: Step 1, parse the document into a tree of nodes. Step 2, apply successive functions which scan the tree looking for nodes of interest and replacing them with programmer content.
08:01:03 <d7> ski: It lets you use fully formed and valid html documents as your template sorce
08:01:06 * ski can't really see the point of this `Travel' monad ..
08:01:49 <ski> i mean `Travel' is just an alias of `State' .. and afaict, there's no quotienting going on either
08:02:31 <ski> d7 : anyway, `CoDensity' is useful for e.g. expression/tree monads, where the monadic computation *is* a tree
08:02:53 <d7> ski: it sounds like that fits my domain well. I just need to see if I can wrap my head around it
08:03:02 <ski> e.g. `data Expr var = Var var | Lit Integer | Add (Expr var) (Expr var)'
08:03:07 <d7> If I could write a version of dft that is not dog slow for large input templates, that'd be a big deal
08:03:27 <ski> what is "DFT" ?
08:03:42 <d7> ski: The templating algorithm I explained above.
08:03:47 <d7> ski: "Designer-friendly templates."
08:04:06 <edwardk> d7: if you read the second post i wind up replacing codensity for that purpose.
08:04:13 <d7> edwardk: Oh?
08:04:18 <d7> edwardk: I should soldier on then?
08:04:23 <edwardk> d7: definitely
08:04:30 <edwardk> part 1 was stating the problem ;)
08:04:30 <ski> d7 : this is templates for generating things like HTML forms ?
08:04:35 <d7> ski: Yes.
08:04:39 <d7> ski: Well whole documents.
08:04:43 <edwardk> part 2 solves the problem, part 3 puts that machinery to work
08:04:50 <ski> d7 : yeah .. just a common example
08:04:58 <d7> ski: Applications like Hakyll and Snap need fast html generation
08:05:31 <d7> But if you could describe your templates as a source document and a series of successive HtmlTree -> HtmlTree transformations... I think that's the ultimate method.
08:05:42 <d7> Lets you work with real html and mock data and real javascript
08:06:00 <d7> but also lets the programmer work at a level of abstraction from the template and reuse transformers.
08:06:01 * ski thinks zippers probably make better comonads than monads
08:07:24 <d7> edwardk: Ty for your time.
08:07:26 <d7> ski: you too.
08:07:39 <d7> It's take your dog to work day. I gotta make that happen. :)
08:08:34 * ski idly finds it strange to call `turn-on-haskell-doc-mode' to turn `haskell-doc-mode' *off*
08:08:36 <edwardk> ski: they do. i have one somewhere
08:09:21 <ski> d7 : sorry .. make what happen ?
08:09:33 <d7> ski: Dog to work
08:09:44 <ski> as in a real dog ?
08:13:00 <d7> yes
08:13:31 * byorgey must have missed the memo
08:13:45 * ski was thinking it might have been some kind of saying
08:13:48 <byorgey> just as well, it would have been difficult to find a dog
08:14:11 * ski could send a memo to byorgey ..
08:14:19 <byorgey> "you can take your dog to work, but you can't pick your friend's nose"
08:15:16 <erus`> a girl who sleeps with many men is a slut but a guy who does the same is gay
08:15:27 <monochrom> haha
08:16:13 * hackagebot flexible-defaults 0.0.0.1 - Generate default function implementations for complex type classes.  http://hackage.haskell.org/package/flexible-defaults-0.0.0.1 (JamesCook)
08:22:56 <Clint> when using c2hs, how should i set a string constant required by the foreign library?
08:25:49 <albertid> What is the preferred way to define Arbitrary instances for  type synonyms? (for QuickCheck)
08:26:13 <JuanDaugherty> Clint, it's c2hs not hs2c, so should be straightforward.
08:27:20 <Clint> JuanDaugherty: i put it in a #c block and that did not work
08:28:13 * ski sometimes would like to write `Frob :: Foo <- Bar <- Baz' ..
08:31:41 * JuanDaugherty concludes that erus' was an official troll.
08:36:17 <Saizan> albertid: a type synonym can't have an instance that differs from the one of its definition
08:36:37 <Saizan> albertid: you can use forAll though
08:38:41 <byorgey> @package stunts
08:38:41 <lambdabot> http://hackage.haskell.org/package/stunts
08:38:55 <byorgey> ^^^ there is a banked track in the world that I don't know how to get into
08:41:39 <luite> haha stunts
08:42:02 <byorgey> pretty fun though =)
08:42:43 <byorgey> as far as I can tell, the point is to drive around an indestructible car and do crazy stuff
08:43:08 <luite> like the original game?
08:43:22 <byorgey> apparently, I never played the original game
08:44:23 <luite> hmm let's see how installing on windows goes :)
08:53:41 <earthy> the original game was fun
08:54:00 <earthy> I should still have it somewhere... might actually run in DosBox
08:57:19 <albertid> Saizan, thanks, I'll read about it
08:58:52 <bgamari> Does anyone have any ideas why my previous code (http://hpaste.org/48260) would be allocating [] objects heavily in step with (:) ?
08:58:57 <bgamari> As far as I can tell, acceptorTs and donorTs should be evaluated fully lazily
08:59:43 <bgamari> But when I replace the code outputting them to a file with "forM_ donorTs print" the GC time goes way down
09:00:26 <hpaste> “Ben Gamari” pasted “GC churn” at http://hpaste.org/48266
09:00:45 <bgamari> so it seems that something is causing the laziness to disappear
09:01:13 <bgamari> The code I'm now working with is http://hpaste.org/48266
09:01:36 <bgamari> Unfortunately I can't get the profiler to give me anything useful about the cause of the allocations other than they are coming from step
09:05:52 <hpaste> dsfd pasted “yyy” at http://hpaste.org/48267
09:06:25 <hpaste> asfd annotated “yyy” with “yyy (annotation)” at http://hpaste.org/48267#a48268
09:07:15 <hpaste> earga annotated “yyy” with “yyy (annotation) (annotation)” at http://hpaste.org/48267#a48269
09:18:32 <sshc> Under what optimization levels is -fcse enabled?
09:19:57 <parcs> sshc: -O
09:21:39 <plat0> Is there a "best" constraint solver library?  I want to solve finite domain constraints (or integer domain constraints that reduce to finite ones).
09:22:26 * hackagebot simple-rope 0.1 - Memory-efficient strings with concatenation and splitting.  http://hackage.haskell.org/package/simple-rope-0.1 (EugeneKirpichov)
09:32:52 * ski irritably wonders why `newline-and-indent' eats his form-feeds ..
09:33:38 <ski> (.. while `haskell-newline-and-indent' doesn't eat it, but expectedly crosses it)
09:35:47 <ski> (s/expectedly/unexpectedly/)
09:38:34 <bgamari> No one has any idea why the memory usage of http://hpaste.org/48266 would explode?
09:38:38 <bgamari> Or is it just lunch time
09:40:09 <zygoloid> bgamari: at a guess, too much laziness in the State monad
09:40:27 <zygoloid> (insert obligatory complaint about use of (!!) and length here)
09:40:32 <malcolmw> bgamari: t+1 closures
09:41:11 <malcolmw> In step
09:42:02 <bgamari> zygoloid: Yeah, I actually started off keeping (cycle fretEffs) in the state and pulled fst fretEffs on every iteration
09:42:21 <bgamari> zygoloid: But I thought that might be causing my memory issues
09:42:40 <bgamari> I'd love to go back to cycle fretEffs, but first I want to figure out what is going on
09:42:43 <bgamari> malcolmw: Eh?
09:43:48 <malcolmw> let t' = t+1 in seq t' blah
09:44:35 <malcolmw> will calculate the increment at each step, instead of leaving the increment unevaluated each time
09:45:12 <bgamari> malcolmw: But if that is the problem, why would it behave fine if I don't try zipping donorTs and acceptorTs together
09:46:53 <malcolmw> The t+1 are all in the acceptorTs
09:48:06 <Saizan> ?type state
09:48:07 <lambdabot> forall s a. (s -> (a, s)) -> State s a
09:49:38 <bgamari> malcolmw: Yes, however I still fail to see how just computing acceptorTs works without memory explosion
09:49:58 <bgamari> malcolmw: It's only when I try to use both acceptorTs and donorTs that things go awry
09:50:28 <zygoloid> bgamari: you build a big list of pairs. you then split them into two big lists.
09:51:49 <zygoloid> i'd imagine the big list of pairs is being retained while you're writing out one of the split pieces
09:52:32 <zygoloid> hmm, maybe not. i'm not sure i've correctly inferred the types of your variables :)
09:52:51 <bgamari> heh, yeah, I could probably use more type declarations
09:53:39 <bgamari> but I really don't see why anything needs to be retained other than a few Timestep values
09:54:01 <bgamari> The two big lists should be lazily evaluated as I write them out
09:54:21 <bgamari> nowhere do I require that any of these lists are fully present
09:54:31 <bgamari> that I can see
09:54:51 <bgamari> but I'm apparently wrong
09:56:40 <malcolmw> When you have a single (fst b) everything will be fine, but with two (fst b), one of them will retain the whole b whilst the other is lazily consuming it
09:56:51 <ski> `unzip' ?
09:57:52 <bgamari> ski: eh?
09:58:36 <bgamari> good point
09:59:05 <bgamari> although then you have to unpack the values from Mayb
09:59:09 <zygoloid> bgamari: if you're not using acceptorTs, that code should be suitably lazy
09:59:17 <Saizan> bgamari: are you compiling wiht -O2, btw?
09:59:23 <bgamari> Saizan: Yep
10:00:36 <monochrom> I compile with "ghc -O --make" your program verbatim and it doesn't grow in memory (stays 8M throughout and finishes in half a minute). ghc 7.0.3
10:01:24 <monochrom> or is it because I'm just 32-bit?
10:01:29 <bgamari> monochrom: Ahh, sorry. The version I uploaded has the bad parts commented out
10:01:38 <monochrom> > 32158972315 > 2^32
10:01:38 <lambdabot>   True
10:01:42 <bgamari> zygoloid: Why would you saw this?
10:01:49 <bgamari> s/saw/say/
10:02:13 <bgamari> monochrom: In main comment out the forM_ donorTs print
10:02:32 <bgamari> monochrom: and uncomment the forM2_ to the end of the block
10:03:11 <hpaste> “Ben Gamari” pasted “More GC churn” at http://hpaste.org/48271
10:03:27 <bgamari> ^^ This is the code I am currently working with
10:04:15 <monochrom> yeah you should try not to be a moving target
10:04:26 <bgamari> I apologize
10:04:45 <bgamari> malcolmw: Why would you say that only one of the fsts will lazily consume the list?
10:05:00 <edwardk> preflex: xseen kmc
10:05:01 <preflex>  kmc was last seen on freenode/#haskell-blah 15 minutes and 4 seconds ago, saying: delayed metadata write sounds like a great way to lose data
10:07:51 <kmc> hi edwardk
10:09:42 * hackagebot random-source 0.3 - Generic basis for random number generators  http://hackage.haskell.org/package/random-source-0.3 (JamesCook)
10:09:44 * hackagebot rvar 0.2 - Random Variables  http://hackage.haskell.org/package/rvar-0.2 (JamesCook)
10:11:44 <malcolmw> Ah, different code
10:12:48 <bgamari> For the record, I just tried the following to no avail
10:12:49 <bgamari>         let (a,d) = unzip $ fst b
10:12:49 <bgamari>         let donorTs = catMaybes d
10:12:49 <bgamari>         let acceptorTs = catMaybes a
10:13:12 <bgamari> Is there a better way to do the catMaybes?
10:13:32 <bgamari> Ahh, map
10:13:44 * hackagebot random-fu 0.2 - Random number generation  http://hackage.haskell.org/package/random-fu-0.2 (JamesCook)
10:14:08 <tommd> The random landscape on Hackage is a little scary (and poorly organized)
10:15:40 <bgamari> How does one write a type declaration in a do-block
10:15:48 <tommd> You don't.
10:15:58 <bgamari> does one have to do let a = asdfa :: type-decl
10:16:04 <tommd> "type X = Y" is a top level declaration.
10:16:08 <tommd> Oh, a type signature!
10:16:10 <bgamari> I'm sorry
10:16:12 <bgamari> yes
10:16:23 <tommd> do x <- y :: IO Int
10:16:25 <tommd> Something like that?
10:16:32 <tommd> or let x = z :: t
10:16:35 <tommd> both work.
10:16:45 <ski>   let foo :: Blah
10:16:45 <bgamari> Well, I was hoping one could separate the signature from the let statement
10:16:46 <ski>       foo = ..blah..
10:16:49 <bgamari> Ahh
10:16:53 <bgamari> excellent
10:17:13 <ski> it's just like in ordinary `let' (and `where')
10:17:33 <tommd> Yes, very _do_ able.
10:18:08 <bgamari> Thanks!
10:18:14 <bgamari> malcolmw: Any ideas?
10:19:32 <monochrom> I think it's just the long list b being held on to despite trying to use it in smart ways
10:20:23 <bgamari> monochrom: And how does one work around this?
10:20:37 <bgamari> I was really hoping haskell would allow me to write what I meant
10:20:59 <bgamari> But every time I try it seems to misunderstand, leaving me with few debugging options
10:21:08 <malcolmw> Have you tried let fstb = fst b in ... to share the tuple projection?
10:23:48 <bgamari> malcolmw: Trying as we speak
10:23:51 <bgamari> malcolmw: Doesn't look promising
10:24:30 <bgamari> it seems strange to me that a pure functional compiler might not recognize that two (fst b) expressions weren't the same thing
10:25:29 <djahandarie> bgamari, it can recognize it. It's just that always doing that optimization can cause memory issues.
10:25:35 <malcolmw> It's  called common subexpression elimination (CSE) and often it introduces space leaks rather than curing them
10:26:02 <malcolmw> GHC has a CSE pass, but it is usually turned off
10:26:19 <djahandarie> It's on in -O2, so I wouldn't say that?
10:26:24 <monochrom> @src replicateM
10:26:24 <lambdabot> replicateM n x = sequence (replicate n x)
10:26:27 <djahandarie> It's just a dumb CSE pass
10:26:33 <monochrom> @src sequence
10:26:33 <lambdabot> sequence []     = return []
10:26:33 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:26:33 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
10:26:50 <c_wraith> also, fst is a strictly strinking function...  it's something that could be CSE'd safely
10:26:56 <c_wraith> but GHC doesn't know that
10:27:31 <djahandarie> Removing the extra binding in       let a = b in ... let c = b in ....        is the only CSE it does AFAIK
10:27:45 <djahandarie> I could be wrong here, I haven't actually investigated it in detail
10:27:49 <monochrom> I think it is replicateM aka sequence
10:27:50 <edwardk> fst is a bit magic though, as a field accessor it gets forwarded by gc and stuff, so cse'ing there in and of itself doesn't do much ;)
10:27:58 <bgamari> malcolmw, djahandarie: Ahh
10:28:36 <bgamari> Thanks
10:28:39 <bgamari> Any other ideas?
10:29:47 <luite> any idea what can cause: waitForProcess: does not exist (No child processes) when doing readProcess "/bin/ls" ["/"] []  in a chroot? the /bin/ls file exists and is readable, chmod 755
10:31:15 <bgamari> Is getting efficient haskell code really this difficult or did I just pick a poor project to implement?
10:31:49 <c_wraith> bgamari: it's not that difficult.  There are just a few things you need to keep in mind.  It's not bad when you have some experience with it.
10:32:23 <bgamari> Alright, that's good to hear
10:32:41 <bgamari> I was beginning to be quite worried
10:33:03 <bgamari> I've been working on this damn thing for two days and even with IRC help have been unable to even beat python
10:34:02 <djahandarie> bgamari, have you read the profiling section in Real World Haskell?
10:34:04 <c_wraith> huh.  given how slow cpython is, that suggests you're probably doing something asymptotically worse than you'd expect.
10:34:30 <bgamari> djahandarie: I've worked through it
10:34:36 <thoughtpolice> djahandarie: i think so too. GHC is particularly conservative about doing CSE because of sharing and always has been.
10:34:52 <mauke> luite: are you ignoring any signals?
10:35:00 <bgamari> djahandarie: The profiler has told me that there are [] objects being created in step
10:35:11 <bgamari> djahandarie: But unfortunately that doesn't bring me much closer to an answer
10:35:23 <bgamari> c_wraith: Definitely true. I just have no idea what
10:35:41 <c_wraith> bgamari: have you posted the code somewhere?
10:35:42 <bgamari> c_wraith: I even know that just evaluating one of the lists I'm generating works fine
10:35:55 <bgamari> c_wraith: http://hpaste.org/48271
10:36:22 <bgamari> c_wraith: It's only when I try using both donorTs and acceptorTs that things go downhill
10:36:22 <c_wraith> oh, well.  System.Random is *really* slow.  That's one clear problem.
10:36:33 <luite> mauke: hmm, good call, I'm ignoring SIGCHLD in the parent process (the parent of the process that sees this exception), are the signal handlers copied to the child when forking?
10:36:39 <bgamari> c_wraith: It's fast enough though I suspect
10:36:46 <c_wraith> (or at least, the StdGen type it uses is really slow)
10:36:57 <bgamari> c_wraith: The real problem is I'm spending half the time in the GC cleaning up []s
10:37:14 <bgamari> c_wraith: And my memory using is still higher than it should be
10:37:20 <bgamari> usage*
10:38:04 <c_wraith> hmm.  I can never remember the argument order.
10:38:08 <c_wraith> :t runState
10:38:09 <lambdabot> forall s a. State s a -> s -> (a, s)
10:38:09 <monochrom> I have looked at the core code. b or fstb is held on to, despite attempts at using it smartly
10:38:10 <edwardk> preflex: xseen vaspervdj
10:38:10 <preflex>  Sorry, I haven't seen vaspervdj
10:38:18 <edwardk> preflex: xseen jaspervdj
10:38:18 <preflex>  jaspervdj was last seen on freenode/#haskell 20 hours, 54 minutes and 46 seconds ago, saying: edwardk: Hi!
10:38:19 <c_wraith> :t evalState
10:38:20 <lambdabot> forall s a. State s a -> s -> a
10:38:27 <luite> mauke: great, removing the ignore handler fixed it. thanks, I completely forgot about this signal handler :)
10:38:29 <bgamari> I really do appreciate the help
10:38:48 <c_wraith> bgamari: since you never use the final state, you could replace the call to runState with a call to evalState
10:38:57 <c_wraith> bgamari: then you wouldn't need to use fst on it everywhere
10:38:59 <bgamari> c_wraith: That's been done
10:39:11 <c_wraith> oh.  got a more recent version of the code, then? :)
10:39:15 <bgamari> heh
10:39:16 <bgamari> one sec
10:39:26 <jaspervdj> edwardk: right here :-)
10:39:54 <hpaste> “Ben Gamari” pasted “Yet more GC churn” at http://hpaste.org/48272
10:39:54 <jaspervdj> edwardk: We were supposed to meet in an hour, right? But now would be fine for me as well, if you're up for it
10:40:01 <bgamari> There it is
10:40:48 <pedro3005> http://paste.pocoo.org/show/418349/ why is this so slow?
10:41:25 <edwardk> ah i think we miscalculated the time difference
10:41:52 <tgeeky> anyone have a reference or recommendation for a "forensics" linux bootcd?
10:42:03 <c_wraith> bgamari: do you ever have cases where both elements of the tuple are Just or both are Nothing?
10:42:05 <edwardk> let me do a quite meeting, and then i'll call
10:42:13 <djahandarie> bgamari, kill the length in the second step case
10:42:23 <bgamari> c_wraith: Yes, there will be cases
10:42:30 <djahandarie> That will asymptotically destroy you assuming effs is long ever
10:42:37 <c_wraith> bgamari: nevermind.  I see that.  oh, you're using length?  yeah, length is O(n)
10:42:44 <bgamari> Alright
10:42:52 <bgamari> Suggested approach?
10:43:02 <bgamari> I used to carry around fretEffs in my state
10:43:02 <c_wraith> Calculate the length initially, then track it
10:43:23 <bgamari> and unpack it one element at a time
10:43:33 <c_wraith> Ouch, you're using !! in that same line...
10:43:34 <bgamari> eff:effs = fretEffs
10:43:47 <c_wraith> This really begs for a different approach
10:43:50 <bgamari> Yeah, I thought that this unpacking was a cause of my performance issues
10:44:01 <djahandarie> Seems like you should be using Vector
10:44:12 <thoughtpolice> FWIW, strictfying your 't' arguments with bang patterns also reduced the GC time by about 5% for me (from 23% -> 18%)
10:44:50 <thoughtpolice> i never like it when I see things like "t' = t + 1" sitting around un-strictified when they clearly should be. :)
10:45:01 <bgamari> Ideally I'd like to use cycle to generate my fretEffs, since I want periodic boundary conditions on time
10:45:18 <djahandarie> bgamari, just try switching to Vector. ! and length there are O(1).
10:45:22 <c_wraith> I don't see what it is you're doing clearly enough to suggest an approach that doesn't involve indexing and length - or even see if one exists.
10:45:25 <djahandarie> And its fusion will do better here.
10:46:32 <bgamari> c_wraith: I'm just trying to cycle through the values of effs
10:46:45 <jaspervdj> edwardk: Sure, give me a call when you're ready
10:46:47 <thoughtpolice> yeah, if the laziness isn't required, i suspect an unboxed 'Vector Double' should do much better here.
10:47:06 <bgamari> thoughtpolice: Good to know
10:47:15 <bgamari> thoughtpolice: About the strictification
10:47:18 <c_wraith> bgamari: *oh*!
10:47:23 <c_wraith> bgamari: yes, you can use cycle
10:47:40 <c_wraith> bgamari: and yes, you should be passing around the current list
10:47:51 <bgamari> c_wraith: And carry about effs in the state, letting effs' = rest effs in step?
10:47:55 <c_wraith> and that would free you from both indexing and lengths
10:48:16 <bgamari> Good, that was my first thought
10:48:26 <Egbert9e9> if i have an IO Bool, how do i case / guard it?
10:48:27 <c_wraith> yeah.  It's actually exactly the same thing as carrying around a pointer into a circularly linked list
10:48:41 <bgamari> but also seemed like it might be penalizing my performance
10:48:42 <c_wraith> (assuming you use cycle to generate it - cycle actually does create a circular linked list)
10:48:45 <bgamari> c_wraith: excellent
10:48:59 <Egbert9e9> i mean, how do i case / guard a bunch of (a -> IO Bool) predicates?
10:49:20 <bgamari> c_wraith: but either way, I'm fairly certain this isn't the cause of my GC issues
10:49:41 <c_wraith> bgamari: yeah, but one thing at a time.
10:49:42 <Egbert9e9> if else then becomes quite convoluted
10:49:43 <djahandarie> bgamari, don't get focused on fixing GC issues. Fix the data structure issues.
10:50:01 <bgamari> I'll have a new version up momentarily
10:50:05 <c_wraith> :t whenM
10:50:06 <lambdabot> Not in scope: `whenM'
10:50:12 <thoughtpolice> bgamari: things like the strictification of accumulators like that is a fairly common idiom that is applied to fix problems like that. generally speaking you get to a point where you can just "see" certain constructs are inefficient, and you just do not write your code that way :P
10:52:01 <thoughtpolice> this seems to be, for better or worse, how many people combat the issue of "space leaks" and whatnot, but it's not always that pretty/simple ofc. even GHC has its occasional space leakage :)
10:53:08 <c_wraith> :t let whenM p x = p >>= \p' -> if p then x else return () -- Egbert9e9: this isn't in the standard libraries, but it's a one-liner, and makes the kind of code you're asking for much cleaner
10:53:09 <lambdabot> <no location info>:
10:53:09 <lambdabot>     not an expression: `let whenM p x = p >>= \p' -> if p then x else return ()'
10:53:12 <hpaste> “Ben Gamari” pasted “Still more GC churn” at http://hpaste.org/48273
10:53:28 <c_wraith> :t let whenM p x = p >>= \p' -> if p' then x else return () in whenM -- Egbert9e9: this isn't in the standard libraries, but it's a one-liner, and makes the kind of code you're asking for much cleaner
10:53:28 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
10:53:29 <bgamari> c_wraith, djahandarie: There it is
10:53:34 <c_wraith> sorry it took me two tries :)
10:53:41 <Egbert9e9> c_wraith: thanks!
10:55:03 <c_wraith> bgamari: now, are you using t anywhere anymore?  I don't see any place that is, offhand
10:55:27 <bgamari> c_wraith: Yep, in the value returned by step
10:55:37 <bgamari> c_wraith: Line 36
10:55:48 <c_wraith> I really wish hpaste showed line numbers
10:55:49 <c_wraith> :)
10:55:51 <bgamari> c_wraith: Ultimately it's the ts that I care about
10:56:09 <djahandarie> @ask chrisdone What happened to the line numbers on hpaste?
10:56:09 <lambdabot> Consider it noted.
10:57:21 <c_wraith> bgamari: are you sure?  It's just incrementing it by one each time, in all three cases.  You don't need the rest of what's going on there to pre-calculate the end result
10:58:19 <c_wraith> bgamari: and you're never using it except to pass it on to the next step
10:59:26 <bgamari> c_wraith: Look again at the definition of step when the SystemState is DExcited or AExcited
10:59:30 <c_wraith> bgamari: oh, I'm wrong.  there's a case where you're not incrementing
10:59:55 <bgamari> I return a value of ((Nothing, Just t), (effs, Ground, t', g''))
11:00:04 <bgamari> Note the Just t
11:00:18 <c_wraith> in any case, t is a space leak, as thoughtpolice mentioned above
11:00:18 <bgamari> Meaning a photon was emitted at time t
11:00:25 <bgamari> I collect these
11:00:39 <bgamari> Working on figuring out the strictification syntax as we speak
11:01:05 <bgamari> GHC seems to think that ! is out of scope
11:01:10 <djahandarie> {-# LANGUAGE BangPatterns #-}
11:01:19 <c_wraith> the simplest way is to add a {-# LANGUAGE BangPatterns #-} pragma at the top of your file
11:01:33 <c_wraith> and then, where t is in an argument list, change it to !t
11:02:14 <bgamari> Sadly I already have the pragma
11:03:05 <c_wraith> bgamari: that error message makes it sound like you're using ! in an expression, not a pattern
11:03:13 <bgamari> Ahh
11:03:17 <bgamari> Yes, I see
11:03:44 <bgamari> Much better, thanks
11:05:29 <thoughtpolice> yeah, when I strictified t i got a GC reduction of like 5% or so. that's actually fairly large, IIRC the RTS told me that introduced 5 less major garbage collections, which is rather significant
11:05:50 <thoughtpolice> of course i don't think it actually changed the runtime too much, just made the GC churn much less
11:05:52 <bgamari> Still very slow though
11:05:54 <bgamari> Yep
11:06:16 <djahandarie> Does the profiling say what function is taking up the most time?
11:06:31 <bgamari> Still spending 56% of runtime in GC
11:06:50 <bgamari> Yep, both runtime and allocs are all in step
11:07:05 <bgamari> 80% of the total in both case
11:07:06 <bgamari> s
11:07:46 <thoughtpolice> what version of GHC are you using btw? with 7.0.4 on x86_64 linux, '+RTS -s' tells me that only 20% or so is spent in the GC
11:08:08 <thoughtpolice> the mutator has a running time of about 11s, while the GC takes a running time of about 2.5s
11:08:15 <bgamari> 7.0.3 on x86_64
11:08:32 <bgamari> wow, hmm
11:08:32 <thoughtpolice> at -O2 ?
11:08:33 <djahandarie> bgamari, try taking a look at the heap profile and see if anything looks wrong.
11:08:43 <bgamari> Yep
11:08:55 <djahandarie> -funbox-strict-fields is also worth a try
11:09:03 <bgamari> thoughtpolice: Yes. Yet my last run took 2 min 35 s
11:09:13 <bgamari> so something seems very very wrong
11:09:33 <thoughtpolice> hm, very strange
11:09:37 <djahandarie> If you have -prof on that disables all optimizations.
11:09:45 <bgamari> Ouch, seriously?
11:09:47 <djahandarie> Yes.
11:10:07 <bgamari> Well, that would definitely explain it
11:10:11 <djahandarie> Which makes it impossible to profile the optimized version, which is annoying.
11:10:20 <c_wraith> it does make the profiler somewhat less useful for tracking down performance problems in optimized code, yes
11:10:27 <bgamari> Yep, that is annoying indeed
11:10:37 <bgamari> Much better, now we're down to 13 seconds
11:10:43 <bgamari> Which is much more reasonable
11:10:51 <Egbert9e9> where do i set the ghc module directory paths?
11:10:54 <c_wraith> that's...  huge.  way to go, optimizer!
11:10:59 <Egbert9e9> wai,t i can google that
11:11:14 <bgamari> Compiling with -rtsopts shouldn't affect performance, correct?
11:11:16 <thoughtpolice> djahandarie: -funbox-strict-fields doesn't really do much in this case. there aren't any strict data constructors, and GHC will already try to unbox the tuples if possible by default i think
11:11:20 <thoughtpolice> bgamari: no
11:11:26 <c_wraith> Egbert9e9: usually, that's taken care of by using cabal as your build tool
11:11:27 <bgamari> Still spending 21% of time in GC
11:11:35 <bgamari> but that's probably reasonable, eh?
11:11:50 <c_wraith> Egbert9e9: well, cabal-install is the name of the package, cabal is the name of the binary it builds
11:11:57 <djahandarie> That's fine. Try switching to a faster RNG.
11:12:02 <Egbert9e9> c_wraith: where should i throw my common functions i use everywhere?
11:12:07 <djahandarie> Don't be adverse to using libraries that other people write.
11:12:08 <c_wraith> bgamari: This is the point where I suspect not using StdGen will help. :)
11:12:13 <thoughtpolice> yeah, i'd say try a package like 'mws' for a fast RNG
11:12:19 <thoughtpolice> mws is really really fast, IIRC
11:12:24 <bgamari> c_wraith, djahandarie: Excellent. Any suggestions?
11:12:28 <bgamari> sure thing
11:12:37 <bgamari> I was looking at random-fu in the past
11:12:38 <c_wraith> mws also has better statistical properties.
11:12:48 <dcoutts> c_wraith: I'm finally going to do some renaming! The cabal package will provide the cabal program :-)
11:12:51 <bgamari> it looks very nice and has a nice assortment of distributions
11:12:57 <bgamari> which is very useful in my case
11:13:04 <bgamari> Any thoughts on it?
11:13:13 <c_wraith> dcoutts: does this mean there will be packages named Cabal and cabal?
11:13:26 <dcoutts> c_wraith: no, there will be cabal-lib and cabal
11:13:37 <c_wraith> dcoutts: oh, that's much better
11:13:52 <djahandarie> bgamari, I have experience with mersenne-random, and it is fast.
11:14:04 <djahandarie> But I think that's what random-fu uses.
11:14:16 <bgamari> djahandarie: Excellent
11:14:16 <dcoutts> c_wraith: the only wrinkle is that there will be the legacy package Cabal
11:14:20 <thoughtpolice> bah
11:14:24 <thoughtpolice> it's not "mws"
11:14:28 <thoughtpolice> it's "mwc-random"
11:14:29 <thoughtpolice> my bad
11:14:29 <edwardk> that reminds me that i keep thinking about building a nice list monad that cheats and uses stablenames to check to see after a bind what it can preserve sharing on for subsequent binds
11:14:30 <thoughtpolice> http://hackage.haskell.org/package/mwc-random
11:14:51 <djahandarie> Ah, mwc is probably faster than mersenne
11:14:57 <bgamari> thoughtpolice: Ahh good. I thought either me or google were going crazy
11:14:58 <djahandarie> And it apparently is :)
11:15:02 <monochrom> @src filter
11:15:02 <lambdabot> filter _ []     = []
11:15:02 <lambdabot> filter p (x:xs)
11:15:02 <lambdabot>     | p x       = x : filter p xs
11:15:02 <lambdabot>     | otherwise = filter p xs
11:15:04 <thoughtpolice> c_wraith: re: statistical properties, anything by bryan is going to be high quality. i'd bet at least a dollar ;)
11:15:20 <c_wraith> thoughtpolice: yep.  pretty safe bet :)
11:18:09 <djahandarie> bgamari,      mwc <- create; n <- uniform mwc :: IO Double;     is how you'd use it, I believe.
11:18:14 <bgamari> Is there a clever way to do the following:
11:18:44 <bgamari> t :: (Int, Int)
11:18:57 <bgamari> (a,b) = t
11:19:07 <bgamari> a' = map f a
11:19:09 <bgamari> b' = map f b
11:19:21 <bgamari> t' = (a', b')
11:19:48 <mauke> bgamari: (0 :: Int) :: [Int]
11:19:48 <bgamari> I want t'
11:21:01 <mauke> :t join (***) (map ?f)
11:21:02 <lambdabot> forall a b. (?f::a -> b) => ([a], [a]) -> ([b], [b])
11:21:02 <bgamari> mauke: Fails in ghci with,     Couldn't match expected type `[Int]' with actual type `Int'
11:21:11 <mauke> bgamari: exactly
11:21:16 <mauke> that's what your code does
11:21:18 <bgamari> Yes
11:21:33 <mauke> bgamari: if 'a' is an Int, what does 'map f a' do?
11:21:33 <bgamari> Oh, my bad
11:21:49 <djahandarie> I suspect he wants f a and f b, no map.
11:21:52 <bgamari> forget the maps
11:21:53 <bgamari> yes
11:22:02 <mauke> :t join (***) ?f
11:22:03 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a, ?f::a b c) => a (b, b) (c, c)
11:22:20 <bgamari> In the case I actually want t = ([Int])
11:23:26 <djahandarie> :t join (***) ?f :: (?f :: (b -> c)) => (b, b) -> (c, c)  -- in case you aren't familiar with arrows
11:23:27 <lambdabot> forall b c. (?f::b -> c) => (b, b) -> (c, c)
11:24:03 <djahandarie> > join (***) (+1) (10, 20)
11:24:04 <lambdabot>   (11,21)
11:24:38 <bgamari> What exactly is (***)
11:24:38 <ski> (djahandarie : i'd `n :: Double <- uniform mwc')
11:24:53 <djahandarie> bgamari, it's from Data.Arrow
11:25:11 <ski>   (***) :: Arrow ar => ar a0 b0 -> ar a1 b1 -> ar (a0,b0) (a1,b1)
11:25:16 <djahandarie> bgamari, it just a combinator for 'function-like things'. And a function happens to be a function-like thing, of course.
11:25:25 <djahandarie> It just happens to do what we want here.
11:25:34 <ski>   (***) :: (a0 -> b0) -> (a1 -> b1) -> ((a0,b0) -> (a1,b1))  -- the most common instance used
11:25:43 <bgamari> alright, cool
11:25:58 <mauke> > (f *** g) (x, y)
11:25:59 <lambdabot>   Ambiguous type variable `c' in the constraints:
11:25:59 <lambdabot>    `GHC.Show.Show c'
11:25:59 <lambdabot>      a...
11:26:06 <mauke> > (f *** g) (x, y) :: (Expr, Expr)
11:26:07 <lambdabot>   (f x,g y)
11:26:18 <mauke> > (f &&& g) (x, y) :: (Expr, Expr)
11:26:20 <lambdabot>   (f (x,y),g (x,y))
11:27:16 <djahandarie> bgamari, I meant Control.Arrow, sorry.
11:28:36 <bgamari> djahandarie: No worries, hoogle figured it out
11:38:50 <bgamari> djahandarie: Concerning MWC, how would one shoehorn this into my existing structure
11:39:17 <bgamari> djahandarie: I already have a state monad, step
11:40:30 <bgamari> djahandarie: So I'm not really sure how one would use PrimMonad
11:41:03 <djahandarie> bgamari, you don't, you just use IO.
11:41:11 <thoughtpolice> bgamari: don't worry about PrimMonad, it's a type class
11:41:12 <djahandarie> (Or ST if you want to make it pure again)
11:41:13 <thoughtpolice> you can just use IO
11:41:45 <bgamari> Currently I explicitly carry about the RNG state in Timestep
11:41:50 <bgamari> So step is pure
11:42:33 <bgamari> To use IO I'd need to pull out the random numbers in main, no?
11:42:39 <bgamari> and somehow pass them to step
11:42:54 * bgamari is afraid this is where his ignorance of monads will truly come to light
11:43:16 <kmc> you don't have to understand monads to use IO
11:43:36 <kmc> "Monad" is a generic API implemented by lots of unrelated types
11:43:47 <kmc> you can understand how to use the IO type concretely, without worrying about how those operations generalize
11:44:02 <kmc> and the general interface *is* really general, so there's not a lot you can say about it in general
11:44:15 <kmc> http://www.haskell.org/haskellwiki/Introduction_to_IO
11:44:24 <thoughtpolice> well, in order to generate a new random value (of uniform distribution,) you just need the special 'RNG state' and then you need to call 'uniform' on it. example: given the docs, you can say something like "withSystemRandom (\x -> uniform x)" which will generate a single random number (withSystemRandom initiates the PRNG seed via /dev/urandom or whatnot)
11:44:41 <kmc> @pl (\x -> uniform x)
11:44:42 <lambdabot> uniform
11:44:59 <thoughtpolice> naturally, i'm just trying to make the fact that uniform works over the RNG state perfectly clear
11:46:23 <thoughtpolice> bgamari: so you could just do something like wrap your 'main' function in 'withSystemRandom' - say, 'main = withSystemRandom $ \rng -> do ....' -- then you'll have to pass the 'rng' around in order to generate random values
11:46:35 <kmc> :)
11:47:03 <thoughtpolice> bgamari: of course, 'uniform' occurs in IO, so you will need to shuffle things around a bit, but you don't necessarily have to make all of your code inside IO - you just will likely need to refactor it a bit
11:47:27 <kmc> yeah, the typical pattern of a Haskell program is an outer IO layer which calls an inner layer of pure functions
11:47:33 <thoughtpolice> bingo
11:47:35 <bgamari> alright, let me digest that for a bit
11:47:38 <kmc> you can call a pure function from IO -- it's just that the result ends up in IO
11:47:40 <bgamari> That's very helpful
11:47:56 <bgamari> This is definitely where I've been stuck in the past
11:47:59 <kmc> *nod*
11:48:06 <bgamari> Thanks!
11:48:09 <kmc> It's a common sticking point
11:48:14 <kmc> i can give more advice about understanding IO if you like
11:48:30 <thoughtpolice> bgamari: it's cool. when I started haskell (so long ago now it feels) i put *everything* in IO for a while. you inevitably get to the point where it's easier and easier to seperate pure/non-pure code, and know what kind of code would be better pure or not, etc
11:48:47 <thoughtpolice> luckily haskell is an excellent imperative language, so, things went better than expected, to say the least.
11:48:48 <monochrom> @src zip
11:48:48 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
11:48:48 <lambdabot> zip _      _      = []
11:49:34 <bgamari> kmc: It would be appreciated
11:49:48 <kmc> ok
11:49:55 <kmc> well the key idea is that evaluation and execution are distinct processes
11:50:03 <kmc> evaluation is what happens when you apply a function to arguments and demand the result
11:50:06 <kmc> it's a pure computational process
11:50:30 <kmc> sometimes the result of evaluation is a value of type (IO T) for some T
11:50:35 <kmc> that's an "IO action"
11:50:45 <kmc> it's a description of how someone *could* perform IO to produce a value of type T
11:50:56 <kmc> but no IO has yet been performed at the time of evaluation
11:51:12 <kmc> that description could get executed multiple times in the future, producing a diffreent result each time, or it might get discarded and never executed
11:51:19 <kmc> the only IO action which is actually executed is the one you name 'main'
11:51:33 <kmc> but you can build IO actions by gluing together other IO actions, with (>>=) or the "do" syntax
11:51:44 <kmc> so main can call some functions and get IO actions from them
11:51:45 <bgamari> fair enough
11:51:47 <kmc> and glue it all together
11:52:20 <kmc> this is actually really powerful
11:52:28 <kmc> we can invent new control flow patterns, concurrency patterns, etc
11:52:33 <kmc> as pure functions which manipulate IO actions
11:52:50 <kmc> and it's easy to reason about when the effects will occur
11:53:05 <kmc> you can do things like send IO actions between threads in a message channel
11:53:13 <kmc> (this is used for example by the GTK bindings)
11:55:16 <bgamari> wow
11:55:44 <kmc> so yeah, Haskell is the world's best imperative programming language :D
11:55:47 <bgamari> Yeah, I've read what a few books and blogs have to say about the matter
11:56:10 <kmc> (that said, you can play the same tricks in most languages, but it's trickier and people tend to deem it "not worth it")
11:56:12 <bgamari> Until you're forced to use them though, I think they remain a bit mysterious
11:56:15 <bgamari> sure
11:56:18 <kmc> yeah, fair enough
11:56:38 <kmc> it's hard to say, because Haskell's treatment of IO seems so natural and obviously correct once you've used it for a long time
11:58:51 <bgamari> I can believe this. Some day I hope to get to that point
12:01:56 <bgamari> So I currently have a function stateStep :: State Timestep (Maybe Int, Maybe Int)
12:02:11 <bgamari> Would the correct approach here be something like,
12:02:28 <bgamari> Oops. Let me rephrase
12:02:51 <bgamari> I currently have step :: Timestep -> ((Maybe Time, Maybe Time), Timestep)
12:03:19 <bgamari> Do I want to pass a random Double in Timestep
12:03:33 <bgamari> To get the random from IO to where it is needed
12:03:40 <bgamari> well, that doesn't work either actually
12:03:42 <bgamari> hmm
12:04:00 <bgamari> Are we sure that step doesn't need to be in IO?
12:04:17 <bgamari> Afterall, it requires different numbers of random numbers depending upon SystemState
12:04:30 <kmc> note that one approach to randomness is to generate an infinite list of random numbers in "main" and then pass it to your pure function
12:04:54 <parcs> > guard False :: Either String a
12:04:55 <lambdabot>   Overlapping instances for Control.Monad.MonadPlus
12:04:55 <lambdabot>                          ...
12:05:45 <monochrom> bgamari: I wonder if you must absolutely do a zip on donorTs and acceptorTs. presumably you just want "dump donorTs into one file" and "dump acceptorTs into another file", right?
12:06:09 <bgamari> kmc: I've noticed that System.Random has a randoms function which does just this
12:06:56 <bgamari> kmc: It seems to do so recursively
12:07:12 <bgamari> I guess I could mapM an infinite list to do this in MWC?
12:07:26 <bgamari> monochrom: That's right
12:07:39 <monochrom> zip is causing the memory growth
12:07:48 <bgamari> monochrom: I think that problem has been solved now
12:07:59 <bgamari> monochrom: I don't believe they are zipped anymore
12:08:30 <monochrom> right, the memory growth versions used zip, and that was the cause
12:08:43 <bgamari> monochrom: Very possible
12:09:03 <monochrom> well, a combination of zip and two lazy lists that are not quite in sync
12:09:36 <bgamari> monochrom: yep
12:10:19 <bgamari> Now I unzip the ([Time], [Time]) I get back from stateStep
12:10:39 <bgamari> And catMaybes each of these lists
12:12:04 <monochrom> more accurately, a combination of zip, two sublists of the same lazy list, but the two sublists are not in sync
12:13:19 <Eren> functional programming really amazes me while the time goes by :)
12:13:32 <monochrom> zip waits for both sublists to emit a cons cell. one sublist emits earlier. while we wait for the other sublist, part of the main list must be held onto
12:14:03 <Eren> I learned some keywords such as referentially transparent, memoization, caching and normal order
12:14:16 <Eren> and these techniques are purely awesome!
12:14:56 <monochrom> for example, suppose one sublist's first cons cell is the main list's first cons cell, but the other sublist's first cons cell corresponds to the main list's 1000000th cell... then there will be a time 1000000 cells of the main lists are held in memory
12:15:52 <monochrom> (after the other sublist finds its first cons cell, those 1000000 cells can be freed. but that comes later)
12:19:18 <robinhoode> How widely used is hs2c? Not seeing a lot of documentation on it..
12:19:46 <c_wraith> err.  hsc2hs?
12:21:34 <robinhoode> Hmm.. Maybe I'm mistaken.. I thought there was a tool for doing some semi-automatic conversion between Haskell and C or something to that effect.
12:21:41 <robinhoode> I know Lispers do that kind of thing a lot..
12:22:39 <Twey> robinhoode: ghc has a -fvia-c option that will compile to C
12:25:21 <maloi> is there a way to use a function infix withou backticks? like ++ does it?
12:25:45 <shachaf> Sure, just call it ++.
12:25:55 <shachaf> Or any name which is made up of symbols rather than letters.
12:26:14 <c_wraith> maloi: it's a syntactic thing.  operator characters create infix operators.
12:26:15 <monochrom> @let x ♥ y = x ++ " loves " ++ y
12:26:16 <lambdabot>  Defined.
12:26:24 <monochrom> > "me" ♥ "haskell"
12:26:25 <lambdabot>   "me loves haskell"
12:26:28 <monochrom> like that
12:27:18 <maloi> that's really cool, thanks
12:27:32 <monochrom> > рutStrLn ("me" ♥ "haskell")
12:27:33 <lambdabot>   Not in scope: `
12:27:39 <monochrom> heh, erased
12:27:47 <c_wraith> > let x <? = x `isPrefixOf` y in "foo" <? "foobar"
12:27:47 <lambdabot>   <no location info>: parse error on input `='
12:27:56 <c_wraith> err, oops
12:28:01 * kmc ♥ monochrom's example
12:28:03 <c_wraith> > let x <? = y `isPrefixOf` y in "foo" <? "foobar"
12:28:03 <lambdabot>   <no location info>: parse error on input `='
12:28:04 <monochrom> moar parameters
12:28:09 <c_wraith> wow, I fail
12:28:17 <c_wraith> > let x <? y = x `isPrefixOf` y in "foo" <? "foobar"
12:28:18 <lambdabot>   True
12:28:19 <kmc> but you can't use <3 as an operator :/
12:28:36 <kmc> funny how many of the things that make Haskell nice to use are nothing to do with FP or crazy types or whatever
12:28:45 <kmc> just little arbitrary restrictions that they got rid of
12:28:51 <kmc> like defining your own infix operators
12:28:56 <shachaf> @ohai kmc
12:28:56 * lambdabot ♥ kmc
12:29:01 <kmc> awwww
12:29:02 <monochrom> well sml had that too
12:29:12 <kmc> many C++ DSLs use operator overloading but they can't define new operators or adjust precedence, so it's terrible
12:29:33 <monochrom> but haskell further lets you define == for your own types
12:30:02 <monochrom> in fact + too. look how awful those sml's and ocaml's +, .+, ...+ are
12:32:13 <absence> can i have cabal rebuild all the setup-config files?
12:33:22 <copumpkin> dons, jmcarthur: I'll be in NYC monday and tuesday evenings (although I'll be busy until 8 or so on tuesday evening), if you guys want to meet up at some point
12:34:24 <edwardk> c++ dsls are fine as long as the behavior you want is just like the behavior of one of the built in types… or are willing to live with bizarre syntax like boost spirit
12:35:18 <monochrom> onoes, what have we started
12:35:28 <monochrom> kmc do you have another haskell lib to upload? :)
12:35:38 <kmc> not yet :/
12:36:43 <bgamari> kmc: Alright, still having trouble wrapping my head around this
12:36:59 <bgamari> I could very well pass an infinite array of random numbers to step
12:37:12 <bgamari> but then extracting them is quite messy
12:38:03 <c_wraith> bgamari: not worse than the way you're pulling a value off of the list of effs each step
12:38:15 <bgamari> I suppose this is true
12:39:08 <morolin> Hey, #haskell, I'm about to start to learn Haskell, because I want a new functional programming language under my belt.  Are "simple language interpreter" and "fractal generator" good learning projects?
12:39:28 <copumpkin> morolin: sure, I approve
12:39:29 <hpc> morolin: yes, and maybe
12:39:30 <edwardk> a simple language interpreter is a great way to learn haskell
12:40:00 <morolin> Awesome.
12:40:04 <maloi> I ♥ that i can define operators like ♥ :)
12:40:06 <shachaf> A simple fractal generator can be nice too.
12:40:22 <hpc> haskell is remarkably good at interpreters and dsls
12:40:55 <morolin> A friend recommended "Learn You a Haskell Like Great Good" as a good starting point (I know some functional programming language (wrote about 2 pounds of Ocaml a few years back)), is this a good one?
12:41:10 <hpc> lyah++
12:41:12 <d7> It is
12:41:15 <shachaf> It's generally recommended around here, along with Real World Haskell.
12:41:21 <hpc> it is the best way to learn
12:41:22 <monochrom> simple language interpreter is excellent
12:41:26 <d7> It has the only coherent and helpful introduction to monads I've ever seen.
12:41:40 <hpc> rwh is more of a reference
12:41:40 <d7> LYAH makes them seem obvious
12:41:51 <morolin> Awesome.  Both of my questions answered as Haskell Platform finished building.  =D
12:42:02 <morolin> <3 ya'll
12:42:23 <hpc> shouldnt you use a binary version of the platform?
12:42:34 <hpc> or is that just ghc?
12:42:54 <morolin> GHC you need the binary of, since (as far as my reading got me) it's needed to bootstrap building the Haskell Platform
12:42:56 <d7> Like, "Duh, of course. Monads, why wouldn't everyone want these?
12:43:26 <morolin> d7: Ok, that's excellent.  Part of why I wanted to get back into functional programming is a lot of the conceptual theory stuff is becoming relevant to me.
12:43:35 <morolin> So knowing why a Monad is useful is great. =D
12:44:03 <monochrom> the new kids prefer Applicative, which is more general than Monad
12:44:14 <kmc> "Monad" is a generic API
12:44:19 <copumpkin> I liked applicative before it was cool
12:44:21 <kmc> implemented by different types
12:44:25 <copumpkin> oh wait, I don't think I did
12:44:30 <kmc> it's only useful because it lets you write code which works for all those different types
12:44:37 <kmc> separately, some of those types are individually useful
12:44:39 <copumpkin> I liked liking things before they were cool, before it was cool
12:44:47 <kmc> IO is useful for doing IO, [] is useful for nondeterminism, Maybe is useful for error handling
12:44:58 <kmc> but none of those three statements is particularly a statement about monads
12:44:58 <d7> morolin: I've come to the opinion that learning haskell will make you a better programmer period
12:45:10 <kmc> even though you access all three features through the "Monad" interface
12:45:16 <morolin> d7: Well, technically I'm a hardware designer, not a programmer, I just tend to program a lot
12:45:41 * kmc is refining this speech and will eventually program it into lambdabot
12:45:50 <d7> Honestly, learning haskell has probably made me better at most mental tasks. I actually 2 kyu ranks in go during the process (which is  a good thing)
12:46:00 <kmc> haha
12:46:02 <morolin> d7: nice
12:46:24 <d7> monochrom: You can have a preference between the two?
12:46:29 <hpc> you actually 2 kyu ranks?
12:46:34 <morolin> Ok, well, time for me to get a'reading.  I'll be lurking in here until I have more questions.
12:46:37 <kmc> i accidentally 2 kyu ranks
12:46:38 <monochrom> they now have kyu ranks for Go programmers too?  <duck>
12:46:42 <aristid> has somebody used Control.Monad.Exception? the error handling world in haskell is rather complex *sigh*
12:46:46 <d7> hpc: I went from 16 to 14k
12:46:53 <kmc> aristid, what package?
12:46:55 <tromp> i'm stuck at 2d
12:47:03 <aristid> kmc: http://hackage.haskell.org/packages/archive/control-monad-exception
12:47:06 <d7> "stuck"
12:47:12 <d7> Man, that is plenty good.
12:47:28 <augur> are there any good papers on the maaaaagic of catamorphisms, induction principles, etc/
12:48:17 <tromp> but prolly not good enough to beat computer end of this year
12:48:43 <byorgey> oh man, really?  I remember when 12k was good enough to beat a computer.
12:48:53 <monochrom> the Applicative "Lam <$> parse'var <*> parse'expr" is more succint than the Monadic "v <- parse'var; e <- parse'expr; return (Lam v e)"
12:49:02 <aristid> augur: it's magic!
12:49:05 <augur> aristid: :)
12:49:06 <tromp> they now play at 4d level on kgs
12:49:06 <thoughtpolice> christ, i haven't played go in so long. my kyu was crazy low
12:49:09 <augur> aristid: read my wip paper? :D
12:49:10 <monochrom> that is why the new kids prefer Applicative
12:49:13 <thoughtpolice> but damn, 4d is pretty good :/
12:49:19 <kmc> > map length ["Lam <$> parse'var <*> parse'expr", "v <- parse'var; e <- parse'expr; return (Lam v e)"]
12:49:20 <lambdabot>   [32,49]
12:49:24 <aristid> augur: um... *whistle* it's in my stack somewhere :D
12:49:26 <tromp> 5d at blitz
12:49:33 <augur> aristid: no no my new paper
12:49:38 <tromp> on a 26 core machine
12:49:41 <augur> aristid: http://wellnowwhat.net/linguistics/AlgebraicSyntax.pdf
12:49:41 <monochrom> kmc, don't count characters, count tokens
12:50:02 <aristid> augur: there's a new one? lol
12:50:19 <augur> aristid: there were three last we talked. this is a fourth. something more interesting and relevant :)
12:50:56 <thoughtpolice> tromp: wow, i didn't know computers were that good. i remember that one a year or two ago beating a go champion, but ISTR it had like a 9-stone advantage which is rather insane
12:51:21 <aristid> augur: yeah sounds interesting. much more general appeal than "Determiner Sharing and Non-Constituent Coordination"
12:51:33 <augur> ;)
12:51:37 <aristid> augur: but beware, next thing you'll know, you're writing pop-sci books
12:51:41 <luite> what techniques to the best computer go programs use?
12:51:50 <tromp> they still need 7handicap against top pros
12:51:50 <augur> aristid: and rollin' in the dough!
12:52:01 <identity_> How does one do a parallel list comprehension without ParallelListcomp?
12:52:06 <tromp> monte carlo tree search
12:52:30 <luite> ah that's what I read about a year ago or so :)
12:52:46 <kmc> identity_, using 'zip'
12:52:50 <aristid> augur: actually i have only 3 in the linguistics folder (including this new one). i must have missed one of the others?
12:52:55 <byorgey> identity_: I don't think you can.  Why do you ask?
12:52:56 <hpc> identity_: monad comprehensions and a parallel list type?
12:53:09 <c_wraith> identity_: you could look at the implementation for it.
12:53:10 <augur> aristid: yeah, but dont worry, its crap
12:53:25 <identity_> kmc: I guess that's what I'd ahve to do yeah
12:53:28 <byorgey> actually, I think parallel monad comprehensions are going into GHC too
12:53:28 <identity_> thanks guys
12:53:41 <aristid> augur: lol
12:53:58 <byorgey> so at some point you will be able to do it with ParallelMonadComprehensions or whatever instead of ParallelListcomp
12:54:05 <kmc> what's the syntax for that?
12:54:07 <thoughtpolice> tromp: that's moving forward. but yeah computers are getting good now. what's the highest dan you can have again? i know you start at 30k, but i think the dan doesn't go up so far does it?
12:54:15 <luite> but my kyu is higher than my iq, so I don't really know much go ;p
12:54:18 <thoughtpolice> (like i said i haven't played go in like 2 years)
12:54:25 <byorgey> kmc: the syntax for parallel monad comprehensions?
12:54:29 <kmc> yeah
12:54:33 <kmc> err
12:54:35 <byorgey> kmc: the same as the syntax for parallel list comprehensions
12:54:37 <kmc> dumb question
12:54:40 <augur> aristid: im not kidding. its a paper i had no interest in writing because there was nothing to write about. this is a problem with linguistics, the ideas are so poorly formulated that its difficult to honestly write a paper
12:54:41 <kmc> i was thinking "parallel do"
12:54:47 <aristid> augur: that's the nice thing about computer languages: we KNOW that we can formalize them successfully
12:54:49 <kmc> don't know what that would mean in general
12:55:03 <aristid> (about page 1 of the newest paper)
12:55:05 <augur> lots of people write peoples but they do it by sacrificing honest commitment to knowledge
12:56:12 <aristid> hmm i think you should insert some punctuation there somewhere
12:56:26 <hpaste> “Stoyan Peev” pasted “Parsing” at http://hpaste.org/48277
12:56:29 <augur> aristid: ?
12:56:42 <aristid> augur: i don't understand the last statement
12:56:57 <augur> aristid: thats because its jibberish!
12:57:14 <augur> *lots of people write papers but they do it by sacrificing honest commitment to knowledge
12:57:51 <aristid> ok that makes more sense
12:57:54 <augur> :)
12:59:05 <aristid> augur: i think there's a big pressure on academics to write papers, so sacrificing his commitment to knowledge is probably the least bad option for the individual academic
12:59:22 <augur> aristid: its worse than that
13:00:30 <augur> linguistics have so embraced fuzzy, vague notions that its often impossible to even ask questions because there is no real perspective
13:01:20 <aristid> and because formalization is eschewed, it's hard to get out of that?
13:01:34 <augur> pretty much.
13:01:48 <augur> there are a million little ideas, each of them somewhat fuzzy
13:02:06 <augur> and theres no coherent whole, so the result is that everything is couched in a million maybes
13:06:36 <augur> aristid: and the million little ideas are often stated without reference to a larger picture, so that sometimes they end up being uninterpretable
13:08:00 <aristid> augur: like your Determiner Sharing paper, which is also presented without context?
13:08:11 <augur> aristid: :P
13:08:19 <augur> touche!
13:08:32 <augur> but pretty much, yes.
13:08:46 <augur> and i didnt like having to write it that way
13:09:55 <aristid> augur: i don't like chomsky.
13:10:31 <augur> chomsky has a lot of really interesting things to say
13:10:56 <augur> he just also has some unfortunately overwhelming effects on the discipline he's spawned
13:11:43 <aristid> augur: your current paper seems to be more essay than paper. not that that's bad
13:12:20 <augur> well, the introduction is more essay than paper. but thats because the intro is mostly trying to convince people that there might be something to this whole algebraic/programmatic stuff
13:12:34 <augur> but what do you mean, in case im not understanding
13:13:47 <aristid> oh, i'm still on page 2
13:13:52 <aristid> so that might be the reason
13:13:55 <augur> yeah, its a long intro :)
13:14:07 <augur> the whole thing is like 15 pages right now and im probably only about half done
13:14:16 <dylukes> Hey guys.
13:14:18 <augur> once youre out of the intro, its less wordy
13:14:19 <aristid> augur: 17 pages.
13:14:24 <augur> 17 pages!
13:14:38 <dylukes> Any idea why my Applicative instance doesn't work here?
13:14:38 <dylukes> https://gist.github.com/1045641
13:14:39 <dylukes> in pure...
13:14:40 <acowley> I got a paper review that said I should have included a monad tutorial
13:14:43 <acowley> and it wasn't ironic
13:14:45 <dylukes> .let me paste the type error too.
13:14:51 <augur> acowley: ahahaha
13:14:57 <byorgey> augur: if you want to convince people to a point of view which is not mainstream, beginning with a long rant is probably not the way to go.
13:14:58 <augur> well, my paper includes an agda tutorial
13:15:01 <dylukes> there, appended it
13:15:04 <dylukes> also
13:15:05 <dylukes> http://cl.ly/7vpD
13:15:05 <dylukes> :D
13:15:06 <augur> AND a catamorphisms/induction principle tutorial
13:15:09 <aristid> acowley: what was the paper about?
13:15:15 <augur> byorgey: possible :)
13:15:18 <acowley> My Haskell robotics framework
13:15:26 <augur> byorgey: i'd welcome any feedback!
13:15:48 <dylukes> byorgey: I took your advice, type families are nicer. Still unable to define my Applicative instance though D:
13:16:07 <dylukes> I'm puzzling out vreverse still. That one will be a challenge.
13:16:24 <dylukes> oh wait.
13:16:49 <dylukes> I could fold the flipped constructor.
13:16:56 <dylukes> Wait. Would that work >_>?
13:17:01 <acowley> In any case, I'm going to talk to a huge crowd of roboticists about Coq and Haskell in separate presentations, and I don't expect it to be pleasant
13:17:23 <aristid> acowley: they will surely love the name of Coq :D
13:17:23 <augur> acowley: unpleasant how?
13:17:36 <byorgey> dylukes: no, it wouldn't
13:17:46 <byorgey> dylukes: because the intermediate results would all have different types
13:17:51 <acowley> aristid: I don't know how I'm going to handle that. I think there will be a faint french flag in the background of my slide template.
13:17:56 <ski> augur : s/what usually needs to be say/what usually needs to be said/, p. 2
13:18:07 <dylukes> Hm it actually checks correctly.
13:18:07 <byorgey> dylukes: your implementation of pure is wrong.
13:18:07 <aristid> acowley: don't be so fearful :)
13:18:12 <dylukes> Wait, no.
13:18:15 <dylukes> byorgey: how do I fix it ?
13:18:21 <augur> i find the most unpleasant thing is peoples unwillingness to look at things from different perspectives. honestly, if you give me any crazy idea, with an example of how it works, ill buy it.
13:18:32 <augur> ski: <3
13:18:39 <nus> robocoq
13:18:45 <thoughtpolice> @faq can you implement crazy ideas with haskell?
13:18:46 <lambdabot> The answer is: Yes! Haskell can do that.
13:18:46 <byorgey> dylukes: see http://conal.net/blog/posts/doing-more-with-length-typed-vectors/
13:18:47 <aristid> nus: :D
13:18:57 <dylukes> what
13:18:58 <acowley> augur: Comparing the Coq work with existing approaches is proving very difficult as I just don't know the answer, and the Haskell work annoys some C++ people just by being different
13:19:00 <dylukes> what's wrong with my pure*
13:19:18 <byorgey> dylukes: what's the type of pure supposed to be?
13:19:35 <acowley> aristid: I gave a 10-min λ calculus tutorial at a robotics talk before. I'm not afraid!
13:19:40 <augur> acowley: yep, thats it: annoying-because-its-different
13:19:45 <augur> i like different!
13:19:45 <thoughtpolice> acowley: is it just a talk about formal methods/FP
13:19:46 <thoughtpolice> ?
13:19:47 <augur> i seek different!
13:19:54 <augur> and am always disappointed :(
13:19:55 <dylukes> byorgey: It's just a -> f a
13:19:58 <dylukes> for some applicative
13:20:01 <dylukes> so...
13:20:02 <dylukes> a -> Vec n a
13:20:04 <byorgey> dylukes: right
13:20:19 <byorgey> dylukes: that means it is supposed to be able to produce a Vec of *whatever length the caller of pure wants*
13:20:28 <byorgey> dylukes: but your version always produces a singleton Vec
13:20:35 <dylukes> ah... I see the issue.
13:20:37 <acowley> thoughtpolice: No, it's an approach to type checking scripts by inferring dependent types for primitive actions such that we can enforce physical constraints of the system
13:21:16 <c_wraith> acowley: your type checker proves that you're not making robot arms move faster than they're designed to?  What fun is that?
13:21:22 <byorgey> dylukes: anyway, that blog post I linked has a discussion of exactly this issue and some approaches to getting around it.
13:21:27 <acowley> thoughtpolice: The usual way of doing this is to write down transition rules that supposedly do the right thing, and let a model checker find a working solution.
13:21:36 <dylukes> interesting, thanks.
13:21:55 <thoughtpolice> byorgey: she and pi types work :P it's not the prettiest ofc
13:22:07 <acowley> c_wraith: I also reject some programs that result in buildings that topple over
13:22:14 <acowley> c_wraith: so you get to stay alive! :)
13:22:25 <thoughtpolice> acowley: oh, really cool sounding :)
13:22:30 <c_wraith> acowley: this doesn't sound like a fun system for building deathtraps at all.
13:22:39 <ski> augur : p. 3 s/where it was possible state/where it was possible to state/
13:22:55 <augur> ski: <3
13:23:21 <acowley> c_wraith: it's funny. My wife and I build a robotic gingerbread house every year, and the nephews/niece love it but always want it to tear itself apart at the end ("Faster! Faster! Faster!")
13:23:34 <ski> augur : oh, s/theoritcal/theoretical/ above that
13:23:53 <byorgey> robotic gingerbread house! o.O
13:24:01 <c_wraith> acowley: the one time I played with lego mindstorms robots, I accidentally programmed it to destroy the plates that were sitting on the table next to it.
13:24:03 <augur> ski: <3 <3
13:24:06 <acowley> well, it has some sensing and actuation
13:24:31 <byorgey> like, if you poke a gumdrop it flaps its shingles at you?
13:24:44 <c_wraith> (and then, after the destruction was complete, spin in a circle and play victory music.  It was the most surreal thing ever)
13:24:52 <acowley> this year the kids got little tokens representing presents that each had different colored wrapping paper. When placed on a sensor underneath an icing christmas tree, a different gingerbread figure and disco lighting scheme spun into view through the window of hte house
13:25:11 <byorgey> woah
13:25:45 <dylukes> byorgey: :(
13:25:50 <acowley> I do not code those in Coq, btw
13:25:51 <dylukes> sadly, its not type checking properly
13:25:56 <dylukes> its the same
13:26:00 <byorgey> dylukes: what isn't?
13:26:07 <dylukes> lemme repaste...
13:26:19 <acowley> c_wraith: the Roomba's use of music is pretty awesome, too
13:26:54 <acowley> c_wraith: the sad song it plays when it gets itself tangled up in cables is ingenious as it tends to defuse some of your anger at its incompetence.
13:26:58 <dylukes> the first solution it provides
13:27:00 <dylukes> lemme try the second one
13:27:54 <dylukes> im kind of on a bus too, its a bit inconvenient
13:27:58 <dylukes> ill come back about it later alright?
13:27:59 <byorgey> dylukes: which is the first solution?  The one with the IsNat class?
13:28:04 <byorgey> dylukes: ok.
13:28:08 <dylukes> mm yeah
13:28:13 <dylukes> i'm going to read it more thoroughly too
13:28:24 <dylukes> I see this specific type error a lot, so I'd love to learn how to avoid it later.
13:28:37 <byorgey> I was about to say, there's no way you could have read and understood that whole blog post in the past 5 minutes =)
13:28:45 <ski> augur : i'm wondering if you maybe should say something about what the purpose of a type checker is
13:28:53 <augur> ski: ok
13:30:28 <bgamari> What exactly is Control.Monad.Primitive.PrimState?
13:30:59 <bgamari> Or for that matter a PrimMonad?
13:31:22 <ski> augur : i object technically to "Curly braces in definitions make an argument implicit" :)
13:32:16 <augur> ski: should i add "in type signatures"? :P
13:32:49 <ski> augur : imo, curly braces *always* makes an (otherwise) implicit argument explicit
13:33:15 <augur> ski: mm.. but in a type signature they TELL agda that its implicit
13:33:19 <augur> its not making it explicit at all
13:33:59 <ski> if you write `foo {X} ... = ...', you're claiming that if you pass the (otherwise implicit) argument `X' explcitly to `foo', also providing arguments `..', the result is defined to be `..'
13:34:23 <acowley> I thought it let you refer to the implicit argument, not that it is passed explicitly
13:34:24 <augur> ski: yes, but if you write {x : X} -> Y you're claiming that x is implicit
13:34:41 <ski> augur : well, type signatures are a bit different, yes. (i was assuming the clause was referring to the left-hand-sides of definition clauses)
13:34:56 <augur> no no i meant in signatures, so ill clarify that
13:35:28 <ski> augur : well, i'd say that you express the concept of functions with a specific implicit argument, with that
13:35:51 <ski> so that values in this type will be functions with (ordinarily) implicit arguments
13:36:19 <hpaste> “Ben Gamari” pasted “Typing confusion” at http://hpaste.org/48278
13:36:41 <hpaste> “Ben Gamari” annotated “Typing confusion” with “Typing confusion (annotation)” at http://hpaste.org/48278#a48279
13:36:47 <augur> ski: yea
13:36:54 <ski> augur : p. 5, "the length treated as an argument" misses a verb
13:37:08 <bgamari> kmc, c_wraith: Can someone explain what my misunderstanding is here
13:37:32 <augur> ski: <3
13:37:42 <bgamari> http://hpaste.org/48278
13:37:43 <augur> mm so does anyone have any good papers on how awesome catamorphisms and induction principles are
13:38:12 <ski> augur : i hope the intended audience knows what bound/dummy variables and free variables are
13:38:16 <bgamari> It seems the type parameter of PrimState is wrong
13:38:41 <ski> augur : awesome for what ?
13:39:23 <acowley> byorgey: will you be on campus next week?
13:40:13 <augur> ski: awesome for anything!
13:40:35 <augur> ski: i hope so too. unfortunately god only knows with theoretical linguists
13:40:45 <kmc> bgamari, did you want "rands <- mapM ..." instead of "let rands = mapM ..."?
13:41:17 <kmc> if i write « do { let x = putStr "hi"; return () } » then no string is printed
13:41:30 <kmc> all i've done is make a new local name "x" for some IO action
13:41:59 <kmc> the IO action does not get executed unless it's part of the IO action which makes up 'main'
13:42:19 <bgamari> Ahh, true
13:42:45 <bgamari> Now I need to somehow extract the rand values from rands as a [Double], however
13:44:46 <ski> augur : i'm not sure about the "awesome" part, but "Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire" by Erik Meijer,Maarten Fokkinga,Ross Paterson in 1991 at <http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.125> talks some about catamorphisms, iirc
13:44:48 <dainanaki> hello everyone, been scratching my head for a day or so now… I'm trying to parse include statements only out of a c file, and I have a parser that works for one include statement, but I am having a hard time figuring out how to get the parser to ignore everything in the file that doesn't apply (anything not an #include <…>).
13:45:07 <augur> ski: yeah, no, ive read that, and its a nice introduction to what they are
13:45:08 <dainanaki> how can I do this exactly?
13:45:26 <augur> im just really interested in some really interested uses of them
13:45:31 <bgamari> kmc: kmc?
13:45:43 <ski> augur : maybe another angle is that catamorphisms are related to compositionality in semantics of languages
13:46:06 <augur> stuff like "hey look, these things that we have here and here and over there, theyre all the same concept deep down, with just very subtle changes, how cool is that"
13:46:07 <augur> or whatever
13:46:14 <augur> ski: id read that!
13:46:19 <acowley> People use these kinds of things all the time but don't always call them that
13:46:31 <ski> augur : e.g. when one is searching for truth-functional semantics for various logic, one is really looking for folds
13:46:53 <augur> ski: god a paper or two? :D
13:47:29 <ski> augur : e.g. it's commonly said that there are truth-functional semantics for classical propositional logic, but not for classical modal propositional logics
13:47:31 <acowley> The Haskell robotics paper I mentioned earlier makes explicit use of metamorphisms!
13:48:06 <ski> augur : but if you change your notion of "truth-value", you can usually make the semantics "truth-functional" anyway
13:48:39 <ski> augur : sorry, i'm not sure about papers. this is stuff i've just absorbed, and have no idea what is a good source
13:49:03 <augur> k :)
13:49:57 <ski> augur : but e.g. in intensional semantics, one can make the interpretation of terms (and propositions) dependent on a "current world", such as time or location e.g.
13:51:10 <ski> augur : if we say that `Bool' is our semantic domain of ordinary truth-values, we can now say that `World -> Bool' is a new notion of truth-values, truth-values dependent on a current-world
13:51:54 <augur> possible worlds are bollocks!
13:52:02 <augur> :p
13:52:03 <ski> hehe
13:52:07 <hpaste> “Ben Gamari” annotated “Typing confusion” with “Typing confusion (annotation)” at http://hpaste.org/48278#a48281
13:52:08 <ski> why do you say that ?
13:52:17 <augur> theyre just obnoxiously problematic for natural language semantics
13:52:31 <ski> (i probably both agree and disagree that they're bollocks :)
13:53:42 <bgamari> Does someone mind looking at the annotation mentioned above and tell me how to resolve the basic typing problem therein?
13:53:54 <bgamari> In particular, I have
13:53:54 <bgamari> main = withSystemRandom $ \rng -> do rands <- mapM uniform [rng | x <- [1..]] let initialState = (cycle fretEffs, Ground, 0, rands)
13:54:28 <bgamari> s/let/; let/
13:54:37 <ski> bgamari : where does the error occur ?
13:54:53 <bgamari> The let initialState
13:55:10 <bgamari> As the last element of that tuple needs to be [Double]
13:55:34 <ski> and that is the error message (at least the first line would be helpful)
13:55:34 <bgamari> Whereas I think rands is in a monad
13:55:56 <bgamari>    Couldn't match expected type `StateT
13:55:56 <bgamari>                                     s0 Data.Functor.Identity.Identity a0'
13:55:56 <bgamari>                 with actual type `[a1]'
13:55:56 <bgamari>     Expected type: State s0 a0
13:55:56 <bgamari>       Actual type: [a1]
13:56:04 <ski> the question "is `rands' a monad ?" is illformed
13:56:08 <ski> only types can be monads
13:56:16 <ski> (`rands' is not a type)
13:56:28 <ski> hm
13:56:54 <bgamari> ski: Perhaps I should have said, rands is of type Monad m => m a ?
13:57:28 <ski> it's common to say that `rands' is an action
13:57:37 <ski> though in this case, i don't think it is an action
13:57:49 <bgamari> it's an action which generates a list of Doubles, no?
13:58:11 <ski> bgamari : i actually think the error you get comes from `evalState (replicate n stateStep) initialState'
13:58:29 <ski> `replicate blah bloh' is a list, not a `State s'-action
13:58:48 <ski> maybe you wanted `replicateM' instead of `replicate' ?
13:59:20 <bgamari> Yep
13:59:23 <bgamari> It seems I did
13:59:28 <bgamari> I suppose that might make sense
13:59:33 <bgamari> doh
13:59:34 <ski> hm
13:59:37 <bgamari> Stack space overflow: current size 8388608 bytes.
13:59:45 <ski> or maybe there's more type errors lurking ?
14:00:23 <bgamari> Well, not that the compiler caught
14:01:34 <bgamari> but something definitely isn't right
14:02:02 <ski> (stylistically, i'd say `save :: FilePath -> [Time] -> IO ()')
14:02:23 <bgamari> Wow, even setting n=10 causes a stack space overflow
14:02:27 <bgamari> ski: Good to know
14:02:31 <bgamari> will be changed shortly
14:02:48 <bgamari> I figured there had to be a type for paths
14:03:17 <monochrom> @quote monochrom Kripke
14:03:17 <lambdabot> monochrom says: There are truths, damn truths, and Kripke structures.
14:03:29 <Saizan>  mapM uniform [rng | x <- [1..]] looks bad if you're using IO or standard ST, might work with lazy ST though
14:04:16 <bgamari> Saizan: Is there a better way to produce a (lazy) infinite list of random numbers?
14:04:47 <bgamari> What exactly is ST?
14:04:58 <ski> bgamari : actually, looking at `rands <- mapM uniform [rng | x <- [1..]]' looks bad
14:05:32 <bgamari> Yeah, that makes sense
14:05:41 <bgamari> Unfortunately that was all I could come up with
14:06:31 <ski> Saizan : lazy `IO' ?
14:06:32 <ski> bgamari : `ST' is a way to write algorithms/computations which are pure, but which internally use mutation
14:06:49 <ski> bgamari : so you can allocate reference cells and arrays, and mutate them to your heart's content, then returning a final result
14:07:22 <ski> @type System.Random.MWC.uniform
14:07:23 <lambdabot> Couldn't find qualified module.
14:07:26 <ski> hmpf
14:07:27 <bgamari> ski: Similar to Control.Monad.State?
14:07:38 <Saizan> ski: might work too
14:07:40 <absence> is there a program that can convert do syntax into applicative, similar to pointfree?
14:08:10 <ski> bgamari : in some ways, yes, but `ST' is typically implemented as actual mutation by the implementation. also `ST' allows you to dynamically allocate new pieces of state, of any type
14:08:19 <bgamari> Ahh
14:08:26 <Saizan> absence: there's @undo, but it'll use >>=
14:08:34 <mrd> has anyone successfully used the plugins library with ghc7?
14:08:42 <kmc> bgamari, look at IORef and then STRef
14:08:44 <monochrom> http://hackage.haskell.org/package/mwc-random/
14:09:10 <absence> Saizan: ah, and there's nothing that will convert >>= etc into applicative?
14:09:10 <dainanaki> is there an easy way to just skip a line in parsec?
14:09:19 <kmc> absence, you can't convert (>>=) to applicative in general
14:09:26 <kmc> Applicative is a weaker / more general class than Monad
14:09:39 <kmc> bgamari, should be reasonably clear how IORef works
14:09:51 <bgamari> kmc: I see
14:09:59 <kmc> bgamari, ST is similar except that you can run a "closed universe" of stateful computations and get back a pure result
14:10:24 <bgamari> kmc: Any ideas concerning how I might generate an infinite list of random numbers?
14:10:25 <kmc> the corresponding operation in IO is unsafe, because a compiler can't prove that your IO computation is a "closed universe"
14:10:35 <absence> kmc: hmm, so applicative being more general does not mean it's a superset of monads?
14:10:41 <bgamari> kmc: My current approach is
14:10:41 <bgamari> main = withSystemRandom $ \rng -> do rands <- mapM uniform [rng | x <- [1..]]
14:10:56 <kmc> but GHC implements ST the same way as IO, at runtime
14:11:02 <bgamari> but the compiler apparently tries to evaluate this
14:11:03 <kmc> the safety checks are a compile-time feature only
14:11:13 <bgamari> causing a stack overflow
14:11:18 <bgamari> at least that's my understanding
14:11:26 <kmc> bgamari, right.  are you using mwc-random?
14:11:29 <ski> bgamari : i think `unsafeInterleaveIO' might be what you want ..
14:11:30 <bgamari> yes
14:12:08 <kmc> bgamari, yeah, i don't think that API provides a way to get an infinite list of random numbers
14:12:13 <ski> bgamari : btw `[rng | x <- [1..]]' is simpler written as `repeat rng'
14:12:19 <kmc> without using somewhat dodgy tricks
14:12:32 <bgamari> ski: Just the name gives me shivers
14:12:41 <kmc> yeah, that's a design feature :)
14:12:42 <bgamari> kmc: Yes, I saw repeat
14:13:35 <ski> bgamari : and then `mapM uniform (repeat rng)', adding `unsafeInterleaveIO', could be written as `interleavedRepeatIO (uniform rng)', if one defines `interleavedRepeatIO' suitably
14:13:38 <bgamari> kmc: Scratch the above
14:13:59 <bgamari> kmc: Perhaps there would be a better way to structure my algorithm in that case?
14:14:09 <ski> bgamari : imo `unsafeInterleaveIO' doesn't deserve the part "unsafe"
14:14:18 <bgamari> ski: Fair enough
14:14:30 <ski> bgamari : but i'm not yet sure this is actually what you want to do, here
14:14:42 <kmc> ski, it lets you observe evaluation order
14:14:46 <bgamari> ski: Although they say that the IO action must be side-effect free
14:14:54 <bgamari> ski: Which the type system presumably can't check
14:15:01 <kmc> right
14:15:02 <bgamari> ski: So it seems it might be unsafe
14:15:08 <kmc> ST is the domain of checkable side-effect-free mutation
14:15:09 <bgamari> By at least one definition
14:15:32 <kmc> bgamari, right, unsafe* functions usually imply that you have an extra proof obligation that is usually handled by the compiler
14:16:04 <ski> kmc : only upto `IO'
14:16:06 <bgamari> kmc: Yep
14:16:13 * ski blames it all on `IO' :)
14:16:19 <c_wraith> I think ST could be used for certain FFI things that are externally pure, as well - but no one's made a pattern of doing so yet.
14:16:26 <kmc> c_wraith, *nod*
14:16:34 <kmc> i have seen other libraries which use the same rank-2 type trick
14:16:37 <bgamari> kmc: It seems to me that passing an infinite list of randoms may not be the correct approach for me
14:16:42 <kmc> i think ezyang had a SMT solver DSL which worked that way
14:16:46 <ski> bgamari : don't confuse `unsafePerformIO' with `unsafeInterleaveIO'
14:17:11 * kmc ponders writing Hdis86.ST
14:17:28 <bgamari> ski: Oops, guilty as charged
14:17:29 <kmc> udis86 is an unusually well-behaved C library in terms of encapsulating state
14:17:34 <copumpkin> ezyang: dude, that's so deep
14:17:46 <ezyang> lol
14:17:54 <c_wraith> kmc: like, all state is explicitly stored in a struct you can allocate however many you want of
14:17:56 <c_wraith> ?
14:17:58 <kmc> yes
14:18:12 <kmc> and the middle layer of my FFI to it has a Haskell type which corresponds to this struct
14:18:20 <kmc> so i could just shove a 's' type parameter in
14:18:23 <kmc> and allow its use with ST
14:18:38 <danharaj> hmm
14:18:45 <kmc> will have to think more about this
14:18:46 <c_wraith> Yeah, that seems like it would preserve all of ST's guarantees
14:18:53 <kmc> thanks for the idea c_wraith
14:19:14 <danharaj> Should I be wary of implementing deletion in a red black tree via zippers in the naive manner?
14:19:17 <ski> bgamari : ok, i'm assuming `withSystemRandom' is not mutating the system PRNG, and that `uniform rng' just specifies which (mutating) `rng' each `uniform' call should use
14:19:24 <danharaj> Or perhaps I can be tricky to save some copying.
14:19:49 <ski> bgamari : so then calling `uniform rng' repeatedly should mutate that generator (and nothing else should be affected)
14:20:31 <bgamari> ski: But is there not a better way to structure the algorithm to avoid such things?
14:21:14 <ski> bgamari : `interleavedRepeatIO :: IO a -> IO [a]; interleavedRepeatIO act = unsafeInterleaveIO $ do val <- act; vals <- interleavedRepeatIO act; return (val:vals)'
14:21:23 <ski> bgamari : there could be
14:21:54 <c_wraith> kmc: you could even fit in freeze/thaw type operations for allowing the state to escape from ST, if desired.
14:22:58 <ski> (c_wraith,kmc : .. iirc, lua is managing its state in a giant struct as well)
14:23:03 <kmc> nice
14:32:51 <pickels> Hello, I was always curious about Haskell and I was wonder if somebody knows a good video? Like a presentation from a conference would be nice.
14:35:19 <acowley> pickels: if you want to learn the language yourself, take a look at http://learnyouahaskell.com/
14:35:56 <pickels> acowley, thanks but I am more looking for a general overview of the language.
14:36:29 <acowley> As for videos, there is this series: http://channel9.msdn.com/Shows/Going+Deep/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1
14:37:21 <pickels> acowley, that's great I love Erik Meijer videos. Thanks!
14:40:19 --- topic: '["Paste code/errors: http://hpaste.org/new/haskell ", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin and spam issues: #haskell-ops"]'
14:40:19 --- topic: set by mauke!~mauke@p3m/member/mauke on [Sat Jun 11 05:12:19 2011]
14:40:19 --- names: list (clog rudyl313 Beetny tauntaun eddayyy ClaudiusMaximus yuriks jemjem dons vdvluc siplux pickels trin_cz ccc zmv kyagrd dilinger SyntaxNinja piotr__ MeCooL Jeanne-Kamikaze zodiak csis mrsolo geheimdienst mxweas scree monqy hepyml kaf3ii Chaze hape01 MoALTz tgeeky n0tk acowley mjo augur homie path[l] lokydor_ fxr morolin quicksilver edon asobrasil gehmehgeh mwc dbpatterson Tomsik gniourf_gniourf Jafet Younder dclinton fengshaun Spockz jystic shaleny roconnor)
14:40:19 --- names: list (perspectival dolio snarkyboojum nathanfh mrd drosophy5lum danharaj aweber ceii_ mv-- jorgeb siracusa carlocci kish_ mun djh_ brachiel vikramverma pikhq c_wraith twanvl tensorpudding neilk_ corruptmemory ujihisa Eduard_Munteanu iFire smadgeprime plat0 pedro3005 RageOfThou Kaidelong enthymeme kmc msieradzki_ sidek em djbeau ISF dimmy josephholsten RayNbow jimmy1980 albertid nus ismtrn copumpkin ChilliX guampa sepp2k1 THC4k ksf [[zzz]] barshirtcliff nighty^)
14:40:19 --- names: list (peterhil PhilRod pi8027 dschoepe mbernstein brodo iskren Dahak ]OLI[ raichoo akosch moshee jutaro Arafangion Nimatek alip yell0 waterlaz gemelen janbanan The_third_man sheyll m4k3r tomh rothwell xarch_ Vorpal ior3k Pathin H2S04 dobblego [mth] JaffaCake jaspervdj sonnym insomniaSalt japcu hackagebot Veid exlevan amsl ExtraSpice dleslie k0ral scm noam sbahra hiredman vpetro kaito_ ps-auxw DasIch_ neurocyte aristid Nisstyre drosophy3lum drosophy2lum davean saati)
14:40:19 --- names: list (frerich dreixel Pewpewarrows poindontcare ulfdoz fowlmouth ousado__ Draconx theorbtwo krainboltgreene fran wli-needjob tavelram dino- wagle cubi amiri dual haus perlite obbele djahandarie nazgjunk Apocalisp drosophy1lum Zephyrus OscarZ Dashkal Demolithion maloi finnomenon electrogeek npoektop yrlnry drosophyllum benmachine tridactyla TheMoonMaster inr jmcarthur nannto__ ezrakilty drmegahertz Nereid dankna cizra2 Jaak ziman mauke deggis waqf setmeaway robinbb)
14:40:19 --- names: list (vegai sanjoyd Guest42893 cjay tew88 copton int-e jix dMazz lunaris majoh Lemmih wires blackrai1|sh vili_ Zeiris_ savy miasma adnam hc QtPlatypus erikde DrSyzygy whoops bradwright liesen tafryn rntz dibblego Bleadof peoro mike-burns Gracenotes cynick dmwit otto_s Cale dju andersk _mpu DukeDave olsner Modius TML orbitz jabirali bqf kelvie_ Philippa `0660 zmoazeni ormaaj Bwild danr anders^^ Gunni Laney Nshag Boney shutdown_-h_now thetallguy1 ezyang tlockney_)
14:40:19 --- names: list (PreciousMetals MasseR Raku^ armence_ araujo jimmyjazz14 callen dogmaT rakete d7 yottis finnrobi taruti sShintah Baughn earthy Astro gerard0 cheshire-cat brett drhodes sbok SimonRC jcapper ixzkn george_z0rwell novas0x2a|laptop Jonno_FTW Intensity towynlin_ jlewis mercury^ Snufsen n00p Niedar audunska julmuri preflex Botje aspect twem2 chr1s_ lrandall gentz stepnem theclaw thetallguy tessier hpc RSchulzM EEVIAC jd10 pantski hammi rerntzdb Cthulhon| djanatyn)
14:40:19 --- names: list (fihi09` snr pastorn Starfire zomg flux absence aleator janne ion Gilly Nightwolf AnAdorableNick brixen adrake uu1101 BrianHV quuxman rattboi sirpengi zaero stepkut jedai nniro lambdabot cncl dsouza sunnavy Raynes Utkarsh robinsmidsrod hanDerPeder Vq Fuco c3l LeNsTR dcoutts_ freeformz appamatto hzh_ digicyc smly- cwillu_at_work hiato gbeshers mlh arnihermann Harbinger idoru lusory Will| ski kakos owain hamishmack tamiko duairc_ _1amzave dom1 twofish eZet flori)
14:40:19 --- names: list (joni6128 Obfuscate parcs chitragupt raxas Guest34074 dom96 sohum pesco_ skaar_ Clint pranq_ ybit3 takamoron norm2782 rby_ arw__ saurik_ ville mattam twn Arnar EvanCarroll jaj ccasin byorgey flazz tsuraan__ etabot ddarius brisbin Liskni_si helgikrs noj bezik andrewsw trez eyck erg PHO_ CosmicRay untwisted davidL dropdrive plimsoll stroan noddy inimino kloeri ve ozzloy zenzike szbalint ttvd_ impl hellige schroedinbug osfameron Cronecker periodic Igloo ian_mi)
14:40:19 --- names: list (mrdomino Vulpyne johs legov kpal cyanoacry jrick osoleve bremner` kosmikus levitation[A] Zol hydo freiksenet integral monokrome Octal jml Twey mokus reacocard guerrilla helino dumael shepheb seats dRbiG drogoh karld thirsteh klugez ido ibt zygoloid Veinor pr dixie Sunhay mux silex poucet felher mrshoe luite bd_ absentia saiam tswett gereedy Saizan sully vinc wolverian rwbarton dorkitude Belgarion_ koala_man zakwilson Aisling scsibug_ KitB _erik_ @ChanServ)
14:40:19 --- names: list (stuartmackie sgronblo c1de0x jonafan quaestor Aestas Ornedan Maxdamantus dionoea Mitar hhulkko fabjan mike1703 MacCoaster_ incandenza hvr ttblrs_ And[y] sajkr shachaf matthew-_ _main_ Innominate sipa wjt Bassetts ben CindyLinz flippo edenc willb thoughtpolice snorble identity_ ts00000 Eelis bl4ck wyfrn gdsx drbean Draggor erk ahihi2 emias mornfall neurogeek||m tomaw ptrf magicman mortberg idnar henr_k solarus dqd bs338 solidsnack ehamberg flamingspinach)
14:40:19 --- names: list (petanqk jlaire blomqvist gds FDFlock mikegerwitz naota [mth]_ Cerise tjweir_ srcerer tromp aculich aavogt hpaste geekounet mjrosenb gf3 lokydor __class__ tomku peddie ernst zaphar_ps monochrom jlouis jbauman mafs avocado suiside etpace kalivha aiko miloshadzic confound burp` ahf ChongLi hyko gbacon_ lukish_ Boxo lpsmith holgr_ nominolo sordina1 nlogax profmakx samek arkx aninhumer subpy ngochai deavid opqdonut DustyDingo milli ToRA companion_cube geekosaur)
14:40:19 --- names: list (piksi Cover|Work jayne mietek smop adnap milkpost maurer_ Ke Draconx|Laptop Martty koninkje_away daed dcolish ivan carrbs1 burp_ lispy lsthemes naneau xiphiasx damjan Cadynum Urchin palmje Eliel eno politik yahooooo kaol McManiaC alpounet robbert spetrea houeland qz aa_ _habnabit Lajla lomeo dcoutts felipe_ edwtjo StoneToad wto kbar tyler-iphone SonicvanaJr pettter almostsix Derander pingveno epdtry JHoglund nihtml akahn hgolden trygvis sshc liw tommd)
14:40:19 --- names: list (thorkilnaur bignose ibid ihckt andelf Ferdirand ray comak manawy caligula fasta jrk_ ricky Evious marienz OnionKnight matthiasgorgens xale Nanar obcode jyyou stepcut tomh- Muad_Dibber zorzar joeytwiddle wtetzner kalven nimred kniu robinhoode welterde MK_FG mikeg jrockway alexsdutton)
14:40:19 -adams(freenode.net)- [freenode-info] channel trolls and no channel staff around to help? please check with freenode support: http://freenode.net/faq.shtml#gettinghelp
14:40:44 <rudyl313> Are there an date types in haskell that are instances of Read, so that I can go =>   read "2011-06-23" :: DateType ?
14:41:12 <shachaf> You probably want to use reads, at least, in case the format is invalid.
14:41:27 <shachaf> Is there a reason it has to be called read and not, say, strptime?
14:43:04 <ddarius> Why would you want to strip time?
14:43:36 <acowley> Trying to make an instance when it's not needed is an interesting trap many of us fall into at some point
14:44:38 <rudyl313> alright. well whats the standard type to use when representing a date (without a specific time attached)?
14:45:24 <rudyl313> my end goal is to be able to read csv data... in which dates are in the string form shown above... and be able to insert them into a mysql db using HDBC
14:45:54 <rudyl313> I just need an intermediate type to be able to call "toSql" on
14:50:06 <augur> is there a name for when a greedy algorithm suffices to find a global extrema?
14:50:53 <ski> i'm not sure, but possibly "sound" could be used here
14:50:58 <ezyang> Monotonic function?
14:51:04 <acowley> monotone
14:51:15 <acowley> hmm, that's not quite right
14:51:54 <monochrom> there is a name longer than "the greedy algorithm suffices"
14:52:10 <acowley> convex functions lend themselves to such approaches
14:52:29 <monochrom> something about "has the subproblem blah blah mathy word property"
14:52:48 <acowley> yeah, I'd go with "mathy word property" and see if a reviewer notices
14:52:58 <rudyl313> "convex" optimization problems are problems where no local minima exist for the cost function
14:53:05 <rudyl313> only a global minimum
14:53:07 <acowley> right
14:53:07 <augur> convex is what #math says
14:53:36 <augur> so im curious about how this applies to more structured optimization domains
14:53:44 <augur> where theres no clear function being computed
14:53:54 <rudyl313> augur: example?
14:53:57 <acowley> you find a convex approximation
14:54:31 <monochrom> oh, there is "satisfies an exchange lemma", because you state and prove an exchange lemma to prove that the greedy algorithm suffices
14:55:18 <augur> rudyl313: well, suppose you have trees with n leaf nodes and you want the ones that are optimally balanced
14:55:39 <augur> bintrees, say
14:55:46 <augur> its not clear what the dimensions are that you'd define convexity over
14:56:20 <augur> i mean, to know whether or not it were infact convex
14:56:42 <augur> its probably _not_ but thats not the point
14:56:56 <rudyl313> augur: well you have to define a quantity
14:56:59 <acowley> Oh, that gets into the usefulness of measures
14:57:04 <rudyl313> as apposed to a subject notion
14:57:15 <rudyl313> like "optimally balanced"
14:57:26 <rudyl313> can that be expressed as a cost?
14:57:32 <augur> rudyl313: probably!
14:58:21 <acowley> but, it's not continuous. There is work done on search algorithms that deals with this
14:58:32 <rudyl313> then you need to figure out the domain of the input to the problem
14:58:41 <rudyl313> can the input instances be expressed as vectors
14:58:49 <rudyl313> in some N-dim space
14:59:07 <augur> i doubt that
14:59:19 <rudyl313> well whats the input to the problem?
14:59:25 <rudyl313> a particular tree?
14:59:34 <augur> n, surely
14:59:39 <augur> the number of leaf nodes
14:59:52 <augur> i mean, you could maybe take as input the set of n-leaf-node bintrees
15:00:12 <rudyl313> ok yeah
15:00:24 <rudyl313> that makes sense... the set of all n-left-node trees
15:00:41 <rudyl313> and then you have some cost computed for each instance in the set
15:00:49 <rudyl313> which indicates how well balanced the tree is
15:00:54 <augur> right
15:01:16 <ski> (augur : you're mentioning "BHK", wondering if there's any need of explaining more what that is)
15:01:25 <rudyl313> I'm trying to think about how a tree could be represented as a vector
15:01:27 <augur> ski: possibly.
15:02:22 <ski> (i'm not saying that you should. i'm just saying that you should consider whether it would be helpful or distracting)
15:02:27 <augur> rudyl313: thats the question i guess --- do you need to represent these things as vectors, or is there a version of greedy=optimal that doesnt require such a description
15:03:46 <rudyl313> augur: right... btw, convexity ensures that all minimum seeking algorithms will converge to global minimum .. greediness is not required
15:04:23 <rudyl313> i.e. all ways down the hill lead to the bottom, not just the fastest
15:04:31 <augur> ok
15:04:31 <rudyl313> as long as there's one bottom to the hill :P
15:04:38 <augur> yeah yeah
15:04:50 <augur> im more interested in greedy algos tho ;P
15:04:57 <augur> just because of the sort of problems im looking at
15:05:00 <Cale> "down the valley" might be a better analogy :)
15:05:31 <rudyl313> Cale: agreed
15:06:58 <rudyl313> augur: I guess another question is ask is .. is there such a thing as "closeness" between trees... and is it well defined?
15:07:13 <rudyl313> i.e. can you say tree A is closer to tree B than tree C
15:08:00 <ski> rudyl313 : you can probably define topologies on them, at least
15:08:09 <Cale> Problems for which greedy algorithms work and matroids are in close correspondence with one another.
15:08:23 <Cale> http://en.wikipedia.org/wiki/Matroid#Greedy_algorithms
15:08:53 <augur> Cale: well past that ;p
15:09:06 <ski> e.g. for trees with elements at nodes, but not at leaves, you could for each tree associate an open set of all trees which you can get by replacing the leaves of the original tree with new trees
15:09:17 <Cale> (and then there are of course greedoids :)
15:11:22 <augur> or just take as a simpler example
15:11:31 <augur> subsets of X, where X is a set of naturals
15:11:36 <augur> and the goal is to maximize the sum
15:11:47 <augur> obviously the answer is X itself
15:12:05 <augur> but thats not the point; the point is, what is the shape of that space such that you can say whether its convex or not
15:12:12 <mike-burns> Anyone know of a sample app using  cabal test  with QuickCheck2? I'd like to learn from some examples.
15:13:12 <ski> augur : 3.1.2 is wrong, you're missing `inl' and `inr' in the definiens
15:13:50 <Cale> augur: Oh, so you're trying to extend the notion of convexity to not-as-geometric domains?
15:13:54 <augur> ski: 3.1.2?
15:14:11 <ski> augur : `dist-*-+'
15:14:36 <Cale> augur: Well, in that case, there's an easily convex extension, where you adjust the problem a bit...
15:14:40 <augur> Cale: no, im trying to figure out what the relevant notion is for greedy=optimal in a combinatorial setting :)
15:15:29 <augur> ski: ahh yes thank you
15:16:01 <augur> ski: i didnt actually construct these interactively :p
15:16:08 <ski> i gathered :)
15:16:36 <Cale> Rather than taking subsets, that is functions X -> {0,1}, generalise to functions X -> [0,1], and then you have an appropriate notion of convex combinations :)
15:16:59 <Cale> (but that's not really the way you wanted to go with that question)
15:17:19 <Cale> You know about matroids and greedoids?
15:17:55 * ski . o O ( "Greedoid Prime" )
15:19:19 <monochrom> Greed Lantern
15:19:26 <augur> Cale: i only sort of grasp them. i get what they are up to the exchange property
15:19:58 <augur> Cale: its more that i cant really see how they'd be used to describe an actual problem
15:20:24 <ski> augur : in the first part of `not+-*not', you're both missing a formal parameter in the definition equation or the type of `?_0' is wrong
15:20:33 <augur> :D
15:20:37 <augur> probably both!
15:20:50 <monochrom> "down the valley" would be gradient descent
15:21:02 <augur> ski: dont worry about those, im going to go through and verify them
15:21:39 * ski wishes Agda2 had message-dispatching syntax ..
15:22:01 <augur> why?
15:22:49 <ski>   not+-*not not-X+Y = (\ x -> ...) , (\ y -> ...)
15:22:54 <ski> is a bit clumsy, imo
15:23:16 <augur> ski: possible.
15:23:38 <ski>   pi_0 (not+-*not not-X+Y) x = ...
15:23:39 <ski>   pi_1 (not+-*not not-X+Y) y = ...
15:23:44 <ski> would be nicer, imo
15:23:46 <augur> im certainly full of clums.
15:24:07 <augur> ski: sure but you cant define things that way
15:24:14 <augur> not in agda, anyway
15:24:18 <ski> i know
15:24:29 <ski> my point is that you should be able to do it :)
15:25:02 <ski> (it's a completely natural extension of writing `f x = ..x..' instead of `f = \ x -> ..x..')
15:25:35 <mustelo> if I'm in a MaybeT IO, what's the right way to interface with things that are of type a -> Maybe b?
15:26:28 <drosophy6lum> is there a pattern to capture the last element of a list? (x:xs:y)?
15:26:39 <ski>   MaybeT (return (frob foo))  -- should work, mustelo
15:26:46 <ski> drosophy6lum : there isn't
15:26:54 <ski> (unless you use view patterns)
15:26:55 <mustelo> ski: right, that's what I was afraid of
15:27:01 <drosophy6lum> thnks
15:27:35 <Cale> drosophy6lum: The reason there isn't is because it's not required that lists have a last element, and it can take arbitrary amounts of computation to decide whether or not they do (which is unlike most pattern matches)
15:27:45 <ski> mustelo : you could easily define `liftMaybe :: Monad m => Maybe a -> MaybeT m a'
15:27:46 <augur> ski: you just want to write things coinductively!
15:27:54 <augur> well take your destructors and GO HOME >|
15:28:14 <cheater__> augur: that's some destructive criticism.
15:28:26 <Cale> Well, that's a little mis-stated
15:28:44 <Cale> (since it can take arbitrary amounts of computation to find if a list is empty or not)
15:28:47 * ski threatens augur with some destruction
15:28:52 <augur> :X
15:30:14 <monochrom> patterns correspond to data type definitions only, not to "conceptual" decompositions like "get the last item of the list", "get the smallest key in the tree" etc
15:30:16 <ski> (.. as to which destruction, i'm not sure. maybe the destruction of very small houses made of cheese would suffice ?)
15:30:25 <Cale> monochrom: Yeah, that's a good way to put it
15:30:32 <augur> ski: mm cheese
15:31:00 <Cale> and the decomposition of a data structure in that way is unique
15:31:17 * ski is for endowing patterns with more computational power
15:31:24 <ski> power to the patterns, i say !
15:31:48 <augur> Cale: so is your suggestion that the space of subsets forms a sort of greedoid?
15:31:55 <augur> or something like that?
15:32:03 <Cale> yeah
15:32:20 <augur> could you sketch a very simple example explaining the exchange stuff?
15:32:25 <Cale> In fact, rather directly
15:32:35 <augur> just so i can see how it factors into the notion of greedoid
15:32:49 <Cale> Okay, so we have the obvious set system here
15:32:51 <monochrom> so if you think there is a pattern for "conceptually" getting the first item of a list, it is just an accident of "data [a] = [] | a:[a]". patterns support the RHS of that only
15:33:07 <Cale> Where our collection of subsets of X is just the power set of X
15:33:26 <ski> augur : btw, all these `(!!!!)' in the paper .. are they supposed to be there in the final version ?
15:33:40 <augur> ski: no, they're just for me to remember where to put in-text citations :)
15:33:57 <augur> im not in the habit of building up my citations as i write
15:34:08 <augur> my train of thought would be broken if i did that
15:34:15 <ski> i see
15:34:16 <Cale> and obviously in that case we're satisfying the exchange property trivially
15:34:33 <Cale> and now we just have to look at the weight function
15:34:51 <augur> Cale: ok.. is there a version that has a non-trivial use of the exchange property?
15:35:09 <augur> just something that shows why its part of being a greeoid
15:35:24 <Cale> Well, I dunno... let's look at a more interesting problem, like finding a maximal spanning tree in a graph.
15:35:31 <augur> ok
15:36:15 <Cale> It's worth noting that the set of forests in a graph is a matroid
15:36:42 <Cale> That is, where you consider a set of edges independent iff it doesn't have a cycle
15:36:47 <augur> ok lets do that, since matroids have exchange as well, no?
15:36:50 <Cale> yes
15:37:02 <Cale> (greedoids are a generalisation)
15:37:06 <identity_> When is Haskell adding something that lets me just define the types for my functions and then make them all = undefined, and then it just knows what to do?
15:37:13 <Cale> lol
15:37:13 <identity_> Compile and it wrote the code for me
15:37:16 <identity_> Surely haskell can do this
15:37:28 <shachaf> identity_: Oleg did that.
15:37:35 <augur> ofcourse oleg did
15:37:37 <identity_> Most of the time the types describe the functions' functionality anyway
15:37:50 <identity_> shachaf: I heard Oleg counted to infinity.
15:37:52 <identity_> Twice.
15:37:52 <augur> oleg did everything with types
15:37:56 <Cale> In Soviet Russia, the functions write YOU!
15:38:06 <shachaf> http://okmij.org/ftp/Haskell/de-typechecker.lhs
15:38:19 <shachaf> And of course there's @djinn.
15:38:55 <ski> identity_ : the program is `main :: IO ()', what does it do ?
15:38:58 <zmv> Cale: In Soviet Russia, Haskell does not understand YOU!
15:39:01 <zmv> :P
15:39:06 <othiym23> couldn't you just write a little pattern matcher that reads type signatures and spits out the free theorems that correspond?
15:39:07 <augur> Cale: ok so with the forests, what is the ground set and what are the independent sets?
15:39:16 <Cale> The ground set is the set of edges
15:39:19 <augur> ok
15:39:19 <identity_> ski: For any proper programmer, changeWorld
15:39:19 <kmc> othiym23, sure, lambdabot has it as a plugin
15:39:28 <Cale> and a set of edges is independent iff it has no cycles
15:39:32 <Cale> (i.e. it is a forest)
15:39:33 <monochrom> (in soviet russia, matroids optimize you)
15:39:36 <augur> ok
15:40:03 <Cale> Note that the empty set of edges has no cycles
15:40:09 <augur> is there a general notion of independence that lets you determine specific notions for different kinds of structures?
15:40:09 <Cale> That any subset of a forest is a forest
15:40:16 <ski> drosophy6lum : btw, with view patterns you can say `last -> x'
15:40:20 <identity_> monochrom: Lies. Optimization implies that someone is inferir. Communism doesn't allow for anything but equality
15:40:22 <Cale> and now the augmentation property is kinda interesting
15:40:27 <identity_> Everyone may be slow, but everyone is equally slow.
15:40:36 <Cale> augur: That's what matroids are :)
15:40:47 <ski> > (\(last -> x) -> x) [0,1,2]  -- drosophy6lum
15:40:48 <lambdabot>   2
15:40:56 <augur> oh, so matroids define independence?
15:40:57 <augur> i see
15:41:01 <Cale> augur: The definition of a matroid is a generalisation of linear independence
15:41:01 * identity_ goes back to unsmellify his code
15:41:38 <augur> ok. so if you can fit something into the matroid mold then youre defining the notion of independence
15:41:52 <augur> so i take it for graphs theres only one definition of independence thats admissible?
15:42:04 <augur> or are there many, and cycle-less-ness just happen to be one of them?
15:42:09 <monochrom> (a matroid is like a monad)
15:42:14 <augur> stop it
15:42:17 <augur> :|
15:42:24 <augur> Matroids are like space soups
15:42:38 <Cale> To see that this set of forests forms the independent sets of a matroid, we need that if A and B are two forests, and A has more edges than B, then there exists an edge in A which is not in B, but which when added to B still gives a forest.
15:42:40 <augur> ~@_@~
15:42:55 <Cale> Cycle-less-ness just happens to be one of them
15:42:57 <augur> Cale: ok
15:43:08 <Cale> Every vector space is a matroid
15:43:26 <Cale> and there are other matroids derived from graphs as well
15:44:06 <augur> Cale: so for the forests, firstly, does the B+{a} have to be a proper superset of B
15:44:09 <augur> oh yes ofcourse
15:44:14 <augur> because a isnt in B
15:44:16 <augur> ok right
15:44:46 <ski> augur : 4.0 "what a what a"
15:45:00 <ski> er, 4.1 that is
15:45:20 <augur> ski: what
15:45:28 <ski> exactly
15:45:36 <augur> ski: no i mean i dont see this
15:45:46 * ski peers quizzingly at augur
15:46:22 <ski>   Before diving into derivationality, it is important to explain what a what a catamorphism is
15:47:08 * ski is not sure of how to interpret `| F { P }', btw
15:47:16 * aristid is not happy with error handling in haskell.
15:47:36 <augur> Cale: hmm
15:47:43 <ski> aristid : more `Either exn' ?
15:47:51 <aristid> ski: no, that is not nice either
15:48:06 <augur> ski: aha, my source file had them on different lines so text search didnt work :)
15:48:17 <ski> aristid : heh, maybe what we want is coexponentials :)
15:48:21 <aristid> it seems like the best way currently is to use SomeException everywhere
15:48:26 <augur> Cale: so i think i see how this is true for forests
15:48:32 <aristid> but then you never quite know WHICH exceptions might be thrown
15:49:18 <ski> (augur : some of the earlier things i reported were displayed with a line break in the middle ..)
15:49:27 <aristid> but given that IO uses SomeException internally, you can't really know anyways, so using something stricter makes little sense
15:49:37 <augur> ski: what which
15:49:50 <aristid> if you are doing IO at some point, that is
15:50:00 <augur> ski: where is this | F { P } thing?
15:50:02 <ski> aristid : for non-`IO' things, i try to use more or less `Either'
15:50:05 <aristid> if you're not doing I/O, Either may often cut it
15:50:18 <ski> augur : 4.0 Derivationality
15:50:19 <aristid> but then it gets annoying when you want to have multiple kinds of errors
15:50:55 <Cale> augur: okay, so a nice thing about matroids: if (E,F) is any matroid (with underlying set E, and family of independent sets F), and w is any weight function on E, extended to F by summing weights of elements in each set, then any greedy algorithm for (E,F,w) will construct a maximum weight element of F.
15:51:00 <augur> ski: oh i see. yeah thats me thinking i could do something with lhs2tex that i cant actually do :)
15:51:03 <ski> aristid : yeah, subtyping could be nice, here
15:51:08 <aristid> there's Control.Monad.Exception, but it's quite complex. so you're tempted to use something like Attempt
15:51:27 <aristid> and Attempt is basically Either SomeException
15:51:48 <tsuraan__> how do you know what kind of exception something throws?  like (read "" :: Int) gives an exception, but what kind?
15:51:52 <aristid> (but with a fancy GADT. don't ask me why they didn't simply use SomeException)
15:52:01 <kmc> tsuraan__, don't catch that exception, use "reads" instead
15:52:08 <kmc> tsuraan__, the answer is that you can't, without reading the source code
15:52:10 <Cale> Where we really need to say what we mean by "greedy algorithm" here, but it's just the obvious thing of starting with the empty set, and adding elements of maximum weight while ensuring that our current choice is a member of F.
15:52:14 <aristid> > reads "" :: [(Int, String)]
15:52:15 <lambdabot>   []
15:52:16 <kmc> exceptions in GHC Haskell are not represented in the type
15:52:29 <tsuraan__> kmc: ok, crazy
15:52:36 <aristid> kmc: iirc there was an evil GHC way to catch pure exceptions
15:52:38 <augur> Cale: extended to F meaning each F is weighted as well
15:52:46 <kmc> aristid, catch + unsafePerformIO?
15:52:52 <kmc> the 'spoon' library does that
15:53:03 <Cale> tsuraan__: The exception which read throws isn't meant to be caught. Use reads if you want to handle failure better.
15:53:04 <kmc> but it's the sort of thing you do when you're stuck with a poorly design library and no other options
15:53:10 <aristid> .oO(my shpoon is too big)
15:53:10 <tsuraan__> for IO things (socket work, file IO, etc), it is normal to use the tryJust (guard . isFoo) pattern though, right?
15:53:21 <kmc> sounds good
15:53:32 <Cale> augur: yeah, by saying that a subset S of E gets w(S) = sum over s in S of w(s)
15:53:32 <aristid> @hoogle tryJust
15:53:32 <lambdabot> Control.Exception tryJust :: Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
15:53:33 <lambdabot> Control.OldException tryJust :: (Exception -> Maybe b) -> IO a -> IO (Either b a)
15:53:33 <lambdabot> Control.Exception.Base tryJust :: Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
15:53:52 <aristid> oh, that's an interesting function
15:53:53 <augur> Cale: ok. are there any nice little tutorials on this sort of thing, do you know?
15:54:05 <Cale> Well, Wikipedia covers this quite nicely :)
15:54:17 <augur> Cale: sure, if you understand the math!
15:54:20 <augur> i need PICTUREs man
15:54:22 <augur> pictures!
15:54:31 * ski thinks greedy algorithms are probably about commiting early
15:54:38 <aristid> who was behind http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/ again?
15:55:14 <ski> > (reads :: ReadS Int) "12xy"  -- aristid,tsuraan__
15:55:15 <lambdabot>   [(12,"xy")]
15:55:40 <HugoDaniel> hi
15:55:59 <aristid> ski: the kind of subtyping provided by the Exception system is not good enough, is it?
15:56:00 <Cale> augur: Well, let me know what you find, I could stand to know more about matroids myself.
15:56:14 <tsuraan__> ski, kmc thanks!
15:56:14 <ski> aristid : Haskell has no subtyping
15:56:17 <augur> Cale: will do
15:56:25 <augur> thank you for making them somewhat clearer!
15:56:51 <Cale> augur: One thing which I've found really lacking in all presentations of matroids I've seen is the usual categorical/algebraic approach of talking about the homomorphisms we're interested in up-front.
15:57:17 <aristid> ski: Exception provides a hierarchy of exception types anyways
15:57:22 <aristid> ski: in a rather confusing way
15:57:35 <Cale> (you'll notice that the wikipedia page oddly doesn't even mention matroid homomorphisms)
15:57:36 <kmc> Haskell has no subtyping, but I think it's fair to say that Exception implements dynamic types with subtyping on top of GHC's type system
15:57:48 <identity_> Given a function in StateT Foos IO a, function :: (Foos -> OneFoo) -> StateT Foos IO a, I want to pass it the record function, and then use that record function (Foos -> OneFoo) to modify the Foos record with put like you would do normally. I know this isn't possible since it's not named the same, but how can I get around this?
15:58:13 <kmc> identity_, i don't totally understand the question, but you might want to look at the 'fclabels' package
15:58:17 <absence> http://stackoverflow.com/questions/3336235/haskell-would-do-notation-be-useful-for-contexts-other-than-monads/3338953#3338953 <- is the <*> bar <*> baz syntax legal haskell or part of the applicative do proposal? i can't get it working, but i'm not sure if i'm doing it wrong or have misunderstood
15:58:22 <Cale> Though, curiously enough, it talks about isomorphic matroids without defining that notion.
15:58:36 <identity_> kmc: Hmm
15:59:43 <Cale> absence: it's legal Haskell
15:59:50 <identity_> Looks like what I need, but trying to do this in standard haskell, so to speak
15:59:53 <identity_> I'll whip up a pastebin
16:00:00 <Cale> er, except that the first <*> was meant to be <$>, I think
16:00:08 <acowley> I mistype "show" as "shoe" a lot for some reason, I say we add it to the Prelude
16:00:10 <Cale> well, maybe not
16:00:33 <Cale> :t \f x y -> f <*> x <*> y
16:00:34 <lambdabot> forall (f :: * -> *) a a1 b. (Applicative f) => f (a -> a1 -> b) -> f a -> f a1 -> f b
16:00:36 <kmc> acowley, i have an alias 'git rabes' for 'git rebase'
16:00:46 <kmc> err 'git rabies'
16:00:50 <Cale> :t \f x y -> f <$> x <*> y
16:00:51 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
16:01:04 <acowley> kmc: I like it!
16:01:26 <Cale> :t (\x y -> ?quux y 1234 x) <*> ?bar <*> ?baz
16:01:27 <lambdabot> forall a a1 b t t1. (?quux::a -> t1 -> t -> a1 -> b, Num t1, ?bar::t -> a, Applicative ((->) t), ?baz::t -> a1) => t -> b
16:01:33 <augur> Cale: what on earth is a matroid homomorphism
16:01:52 <monadic> What version of haddock is required for the style used by the ghc-7.0.3 docs? I see 2.9 works but I'm wondering is 2.7 would work as well (as it isn't hardmasked like 2.9 on my system)
16:01:53 <lambdabot> monadic: You have 1 new message. '/msg lambdabot @messages' to read it.
16:02:11 <kmc> :t ?i ?n ?c ?e ?p ?t ?i ?o ?n
16:02:12 <lambdabot> Top level:
16:02:12 <lambdabot>     Occurs check: cannot construct the infinite type:
16:02:12 <lambdabot>       t = t1 -> t2 -> t3 -> t4 -> t5 -> t -> t6 -> t7 -> t8
16:02:23 <Cale> augur: Well, a natural thing would be to extend what vector space homomorphisms are. The preimage of any linearly independent set under a linear transformation is linearly independent.
16:02:36 <augur> @_@
16:02:42 <augur> i dont understand what that means
16:02:42 <augur> :D
16:02:48 <augur> thats ok tho
16:02:49 <acowley> think about it!
16:02:52 <kmc> :t ?j ?e ?r ?k ?c ?i ?t ?y
16:02:53 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7. (?y::t6, ?t::t5, ?i::t4, ?c::t3, ?k::t2, ?r::t1, ?e::t, ?j::t -> t1 -> t2 -> t3 -> t4 -> t5 -> t6 -> t7) => t7
16:02:55 <hpaste> identity_ pasted “OMG NEED HALP(read: labels and something)” at http://hpaste.org/48287
16:03:02 <Cale> augur: Okay, I'll say it slower:)
16:03:05 <identity_> @ kmc and someone else
16:03:05 <augur> :p
16:03:11 <parcs> hmmm
16:03:11 <augur> Cale: im not foreign!
16:03:17 <Cale> If V and W are vector spaces and T: V -> W is a linear transformation
16:03:18 <parcs> yesod should make use of implicit params
16:03:27 <Cale> and S is a subset of W which is linearly independent
16:03:27 <identity_> If I can get past this by doing something differently, please do explain
16:03:28 <parcs> i mean, it uses every other language extension out there
16:03:52 <Cale> Then the preimage of S under T, specifically T^(-1)(S) = {v in V: T(v) in S}
16:03:59 <Cale> must be a linearly independent set
16:04:04 <augur> i see
16:04:04 <augur> o
16:04:05 <augur> ok
16:04:28 <Cale> And so we can extend that idea to matroids in general
16:04:53 <Cale> By taking a matroid homomorphism M -> N to be a function on the underlying sets such that the preimage of any independent set is independent.
16:05:24 <Cale> Note how this is extremely similar to the definition of a continuous function in topology
16:05:35 <Cale> (preimages of open sets are open)
16:05:37 * ski noted this
16:05:46 <augur> Cale: if only i knew something about topology!
16:06:13 <absence> Cale: shouldn't this work then? (\x y -> return $ y ++ x) <*> getLine <*> getLine
16:06:26 <Cale> Topologies are another kind of families of subsets satisfying some properties
16:06:34 <augur> Cale: :P
16:06:48 <identity_> Anyone have a hint re. my paste?
16:06:59 <augur> i need to see things in type-like terms otherwise they dont make sense to me. all of this mathy stuff is beyond me for now
16:07:00 <augur> :\
16:07:25 * ski . o O ( "One must always topologize." -- M. H. Stone )
16:08:20 <ski> absence : what about it ?
16:08:42 <djahandarie> (Does that ". o O (" thing have some semantic meaning?)
16:09:05 <augur> djahandarie: thought bubble
16:09:13 <Cale> absence: Yeah, I dunno, they're using the function applicative there. I think the guy got the translation a bit wrong
16:09:14 <djahandarie> Oh man
16:09:15 <ski> djahandarie : the idea is that it will lead the thoughts to a "thought bubble"
16:09:18 <Cale> return (\x y -> y ++ x) <*> getLine <*> getLine
16:09:20 <Cale> works
16:09:22 <Cale> as does
16:09:28 <Cale> (\x y -> y ++ x) <$> getLine <*> getLine
16:09:49 <identity_> djahandarie: I didn't see it either. I thought the dot was for spacing and o O was supposed to be like the emoticon "o.O"
16:10:20 <djahandarie> Heh, yeah. And I've seen it used like 30 times and never figured it out. Sure makes sense now though.
16:10:27 <identity_> Indeed
16:10:29 <absence> ski: it doesn't work. says it can't match types
16:10:56 <ski> absence : yeah, the `return' is in the wrong place, as Cale noted
16:11:51 <absence> ah sorry, i'm a bit slow tonight :)
16:11:56 <absence> Cale: thanks
16:12:01 <identity_> identity_ pasted “OMG NEED HALP(read: labels and something)” at http://hpaste.org/48287
16:12:13 <identity_> ^ Someone dazzle me with haskell magic
16:12:23 <identity_> I'm pretty much stuck until I get this part done
16:12:28 <elliott> Is there a way in a TH quasiquoter to parse the string as Haskell into TH data types?
16:12:32 <elliott> Or do I have to use haskell-src-meta or similar?
16:12:33 <Cale> absence: To your credit, the original post only barely typechecks, and as a translation of syntax is extremely dubious.
16:12:54 <elliott> identity_: Haskell records cannot do this, unfortunately.
16:13:12 <identity_> elliott: Yeah, I know that much. I was wondering if someone had some solution
16:13:13 <elliott> identity_: You will either need to pass in a setter function, or use fclabels, lenses, data-accessor, or one of the other available better-record-system packages.
16:13:22 <identity_> elliott: Alright, thanks.
16:13:24 <acowley> identity_: this is why record syntax is such a sore spot
16:13:37 <elliott> identity_: You can bundle (Foos -> OneFoo, OneFoo -> Foos -> Foos) as one type and define them for first and second if you don't want to pull in a dependency.
16:13:49 <elliott> Personally I recommend fclabels if you run into this problem more than once.
16:13:58 <elliott> It's a shame the record system is so lame.
16:13:59 <identity_> acowley: It is indeed. I ran into this problem earlier this month, and thought about it as I was thinking the design up for this application and was hoping to avoid it. Then I 'designed' my way into this corner. :/
16:14:23 <ski> identity_ : you must replace `Foos -> OneFoo' by `Lens Foos OneFoo', where `Lens' is probably called something else in `fclabels',`data-accessor'
16:14:27 <acowley> identity_: I've run into it several times over the years, but never felt motivated enough to use something like fclabels
16:14:30 <elliott> identity_: The alternative packages are easy to use, BTW; you just prepend/append _ to all of your field names, then "mkLabels [''MyType]" at the top level, or similar.
16:14:36 <elliott> skaar_: :-> in fclabels.
16:14:36 <identity_> elliott: Alright, thanks a lot. And acowley, and ski, and kmc
16:14:48 <identity_> elliott: Ah.
16:14:54 <elliott> skaar_: Accessor in Data.Accessor, it seems.
16:15:04 <ski> Cale : Philippa's post ?
16:15:07 <identity_> I'll grok it, was just hoping to avoid pulling in a dependency & wasting more time on this than necessary
16:15:21 <absence> Cale: the original posted code only works if quux is pure, right?
16:15:24 <Cale> ski: The guy who cited Philippa's post
16:15:48 <Cale> (edward got the translation wrong, I think)
16:16:14 <elliott> identity_: I tend to use it whenever I have more than two records in a program. :p
16:16:14 <Cale> absence: If it's in the function applicative
16:16:39 <Cale> absence: because (<*>) :: m (a -> b) -> m a -> m b
16:16:59 <Cale> absence: So if the first parameter is a function directly, then m = (e ->) for some e
16:17:16 <identity_> elliott: I think I'll do something that will smell miles away, keep me up at night and then use fclabels later. My application kind of needs to have the 'released' feature soon.
16:17:24 <identity_> at least "released for testing"
16:17:49 <elliott> Sure thing, although it'd only add a few lines to your code... well, and change all your accessor uses, I suppose :)
16:18:07 <identity_> elliott: Aye. I have a good number of data structures
16:18:13 <ski> Cale : actually, i'm doubting Philippa's original post, looking closely at the example
16:18:30 <Cale> oh, yes
16:18:43 <Cale> I immediately doubt it too, looking at it :)
16:18:44 <acowley> elliott: I'm always wary of things that add implicit identifiers to my code
16:18:52 <elliott> identity_: FWIW, I tend to avoid using records anyway, in terms of smaller "factored" types
16:18:55 <elliott> But obviously that does not always work
16:18:59 <Cale> because the translation makes the same mistake
16:19:04 <elliott> acowley: I treat the prefix _ as syntax
16:19:05 <identity_> elliott: Indeed
16:19:15 <elliott> acowley: It's "import ABetterRecordSystem" :P
16:19:18 <acowley> elliott: yeah, that's the right way to think about it, but it requires training!
16:19:27 <Cale> (of using the function applicative)
16:19:34 <elliott> I'll do nearly anything for decent record fields
16:19:34 <acowley> I've been trained by Scheme macros to be suspicious of these things
16:20:01 <ski> Cale : it ought to translate into `pure (\a b -> foo a b) <*> f <*> g *> h'
16:20:10 <identity_> Is there anything in the works to fix the record system? Is it even possible to fix it for what I tried to do to work without any other, possibly more vast modifications?
16:20:12 <adr21> is there any good tutorial about MySQL database manipulation?
16:20:19 <elliott> acowley: You could always define all the :-> values yourself :-D
16:20:25 <augur> Cale: do you have any suggested reading on algebraic approaches to programming problems? something other than just "here are some algebraic widgets"?
16:20:48 <ski> (Cale : presumably Atkey and edwardk noticed this, since they implemented it, though :)
16:21:03 <acowley> elliott: I wonder if some kind of IDE like feature that could expand the TH macro into a popup on mouseover would help
16:21:23 <elliott> acfoltzer: I dunno -- TH is a very large axe, and it's sort of a last resort IMO
16:21:35 <Cale> ski: Would that be the same Atkey whose name was used as a pun in Conor's paper? :)
16:21:35 <acowley> that way you could see the generated code when wanted
16:21:36 <acfoltzer> hmm?
16:21:38 <elliott> acfoltzer: Most uses of it tend to be indicators in flaws of the language, in my experience
16:21:46 <acfoltzer> I agree, but I think you have the wrong nick :)
16:21:52 <elliott> Oops, sorry :)
16:21:57 <elliott> acowley: acfoltzer: But when there is such a flaw and there's no other convenient correction, I can stomach it
16:21:59 <elliott> ...
16:22:01 <elliott> Wow, I suck.
16:22:07 <augur> elliott: couldve told you that
16:22:11 <elliott> acfoltzer: Swear I'm not trying to antagonise you :)
16:22:12 <augur> <3
16:22:17 <acfoltzer> haha np
16:22:32 <Cale> (Or, I think it was Conor's...)
16:22:37 <acowley> it was
16:22:50 <Cale> There was a funny pun involving Atkey and "at key".
16:22:52 <acowley> it's his arrows of outrageous fortune paper
16:22:57 <Cale> yeah yeah
16:23:08 <ski> Cale : dunno. the thread says Robert Atkey. implemented it in Camlp4
16:23:38 * augur pokes Cale :P
16:23:40 <Cale> cool, yeah, it's the same guy
16:23:45 <Cale> augur: oh, right
16:23:47 <augur> :p
16:24:11 <augur> sokay, things have picked up, and you're not obligated to reply.
16:24:16 <Cale> augur: Well, I just learned a lot of these things on their own, without any reference to programming, and then the applications to programming sort of become apparent on their own
16:24:27 <augur> hm
16:24:41 <Cale> http://personal.cis.strath.ac.uk/~conor/Kleisli.pdf
16:27:40 <ski> augur : for `listrec', you might want to swap names of `X' and `Y', or rename `x' and `xs' to `y' and `ys'
16:27:50 <augur> ski: ok
16:28:03 <elliott> Going to re-paste this since I got into that records discussion immediately after :)
16:28:04 <elliott> <elliott> Is there a way in a TH quasiquoter to parse the string as Haskell into TH data types?
16:28:04 <elliott> <elliott> Or do I have to use haskell-src-meta or similar?
16:29:19 <augur> ski: im uniformly fixing that throughout
16:29:39 <kmc> elliott, i think haskell-src-meta exists for precisely that purpose
16:29:47 <kmc> i'm not sure how you'd do it in a way that's not functionally equivalent
16:29:52 <ski> augur : where did `*' in `* :: * :: []' come from ?
16:30:05 <elliott> kmc: Yeah... but it involves using a possibly-incomplete grammar :(
16:30:09 <augur> ski: good question. i meant to ensure i had that :D
16:30:09 <elliott> esp. when considering GHC extensions
16:30:12 <kmc> yeah :/
16:30:17 <elliott> kmc: It would be nice if TH provided access to the compiler's parser.
16:30:21 <kmc> *nod*
16:30:24 <kmc> GHC API does, i think
16:30:26 <kmc> but it's not pretty
16:30:38 <elliott> kmc: I doubt it returns in the form of TH data types, either :)
16:30:44 <kmc> right, you have to translate
16:30:51 <kmc> though that translation already exists to some degree in GHC
16:31:02 <kmc> you can reify value declarations, can't you?
16:31:10 <kmc> what quasiquoter are you trying to write?
16:31:23 * kmc thinks the state of metaprogramming in Haskell is promising but so frustrating
16:32:19 <elliott> kmc: Idiom brackets. Unfortunately http://hackage.haskell.org/packages/archive/applicative-quoters/0.1.0.1/doc/html/src/Control-Applicative-QQ-Idiom.html from applicative-quoters seems to be broken with recent GHC, and besides, it doesn't allow infix or anything.
16:32:29 <elliott> I want [i| ("foo","bar") |] to work.
16:32:39 <elliott> So basically I need a Haskell parser :)
16:36:13 <ski> augur : i see you at least mention later that `*' is supposed to have type `One'
16:36:40 <augur> ski: im fixing that
16:36:41 <ski> btw on page 14, there's a type which extends well into the margin
16:37:03 <augur> also, yeah, theres a lot of stuff that goes into margins :p
16:37:04 * edwardk waves hello
16:42:15 * ski reflects the wave
16:42:23 <ezyang> Is it possible to generate all valid statements of higher-order logic? (sort of take axioms and search through all constructions from them)
16:42:24 <roconnor> edwardk: so your claim is that Yoenda Rec is better than Codensity?
16:43:05 <edwardk> for working with free monads at least
16:43:15 <roconnor> ah
16:43:26 <augur> ezyang: you mean is higher-order logic complete?
16:43:59 <ezyang> Erm, not quite.
16:44:14 <monochrom> certain details of the logic may matter
16:45:10 <monochrom> but if you bet "no" you are likely to win
16:45:13 <jmcarthur> ezyang: are you asking if it is countable?
16:45:27 <ezyang> As in, can I write a program that writes a stream of statements, such that for any valid statement in HOL, it appears in this stream.
16:45:49 <ezyang> jmcarthur: Yeah, I think so.
16:46:16 <ezyang> Or, is the problem of formula validity in HOL Turing recognizable? (it's known to be undecidable)
16:46:49 <edwardk> roconnor: I figured you'd get a chuckle from the store command being the basis upon which I built the example :)
16:47:07 <Cale> ezyang: I would be extraordinarily surprised if it wasn't.
16:47:09 * ski idly wonders how "Turing recognizable" differs from "computably enumerable"
16:47:28 <ezyang> Turing recognizable = recursively enumerable.
16:47:31 <Cale> ezyang: You could enumerate all strings of symbols, and check if the string of symbols is a proof in HOL, and see what statement it proves.
16:47:32 <ski> ah, ok
16:48:13 <monochrom> someone once told me "there are statements in 2nd order logic true but unprovable". I said "whoa, that's crazy, how is it true if you don't have a proof". he enlightened me: "satisfied by all models, yet no proof". I think if even 2nd-order logic suffers this, higher-order is hopeless
16:49:04 <Cale> I kinda dislike that particular use of the word "true"
16:49:14 <dylukes> monochrom: what?
16:49:24 <Cale> I'd rather say "satisfied by all models" when I meant that particular notion of truth.
16:49:33 <monochrom> yeah, but "valid" may very well be again "satisfied by all models"
16:49:37 <dylukes> .____.
16:49:48 <Cale> Or yeah, "valid" is okay
16:49:55 <ezyang> OK, it sounds like we can get provably true statements, but not unprovably true ones.
16:50:03 <elliott> kmc: I might just not use a quasiquoter altogether... :/
16:50:08 <elliott> haskell-src-meta gives really ugly errors
16:50:09 <monochrom> dylukes: you're looking at "true but crazy" :)
16:50:09 <Cale> I just don't like "true but unprovable"
16:50:21 <dylukes> *sigh*
16:50:28 <monochrom> hehe
16:50:31 <elliott> I might use $(idiom [| ... |])... no, that's just so ugly.
16:50:34 <ski> Cale : heh, i've always had the same reaction to that
16:50:41 <dylukes> I've decided programming or trying to understand #haskell while moderately lovesick is hopeless.
16:50:45 <dylukes> So instead I'm updating GHC.
16:50:59 <dylukes> this could take a while~
16:51:04 <Cale> A statement is true iff there is a proof of it.
16:51:05 <monochrom> I agree I don't like to say "true" for it
16:51:07 <dylukes> hopefully 7.0.4 includes the fixes on OS X...
16:51:14 <Cale> (as far as I'm concerned)
16:51:14 <dylukes> I know they're marked as fixed in the 7.2.1 milestone
16:51:26 <tsuraan__> sort of strange, the exception raised when you try to openFile a directory doesn't match IO.isIllegalOperation, nor any other filter in that module that I can see
16:51:44 <dylukes> Oh, question
16:51:50 <dylukes> how do I totally delete all cabal packages?
16:51:55 <dylukes> delete .cabal and .ghc?
16:52:04 <tsuraan__> dylukes: that's what I always do :)
16:52:17 <dylukes> mmk
16:52:29 <dylukes> fffff
16:52:33 <dylukes> ghc installed in like 2 minutes
16:52:35 <dylukes> wait
16:52:37 <dylukes> 26 seconds
16:52:39 <dylukes> madness D:
16:52:47 <tsuraan__> must not be a Gentoo user
16:52:54 <monochrom> because it's just copying files
16:53:06 <ezyang> An unrelated debate we've been having is whether or not we can do this for ZFC.
16:53:09 <edwardk> dylukes: welcome to the future
16:53:24 <dylukes> well, there are a couple linker errors in 7.0.3
16:53:38 <dylukes> because of the way clang/llvm-gcc on 10.6.6 and 10.7 handle unwinding....
16:53:38 <monochrom> I think all first-order things like ZFC and PA are pretty safe
16:53:44 <dylukes> ZFC? PA?
16:54:08 <monochrom> maybe not PA
16:54:22 <monochrom> nevermind, I don't know
16:54:23 <elliott> ZFC safer than PA?
16:54:28 <elliott> that's a new one
16:54:32 <monochrom> haha
16:54:39 <dylukes> ZFC?
16:54:39 <roconnor> what can we do for ZFC? =)
16:54:48 <elliott> dylukes: you know, as in set theory
16:54:48 <ski> "Truth is evidenceability." ~ Per Martin-Lö
16:54:50 <ski> f
16:54:54 * roconnor is trying to prove Z is inconsistent
16:54:55 <dylukes> elliott: Nope, I dont TT_TT
16:54:58 <monochrom> ZFC says "ask what you can do for the set!"
16:55:10 <kmc> elliott, you can also do your preprocessing outside GHC
16:55:13 <kmc> with haskell-src-exts
16:55:23 <kmc> and -pgmF
16:55:24 <kmc> like 'she' does
16:55:52 <elliott> kmc: ew... and besides, doesn't haskell-src-exts give basically the same errors?
16:55:55 <kmc> maybe
16:56:11 <elliott> * roconnor is trying to prove Z is inconsistent
16:56:20 <elliott> even without the FC? my, we're ambitious! :P
16:56:26 <roconnor> yep
16:56:27 <othiym23> dylukes: Zermelo-Fränkel set theory
16:56:38 <kmc> i didn't know Fränkel had an umlaut
16:56:40 <kmc> cool guy
16:56:42 <roconnor> though if I end proving ZF incosistent, I'll be satified.
16:56:53 <elliott> kmc: that's basically how you determine coolness really
16:56:56 <elliott> othiym23: Fraenkel isn't it
16:57:09 <elliott> roconnor: Oh, I thought you meant Dijkstra's Z.
16:57:14 <elliott> Here I was trying to make a hilarious pun...
16:57:16 <othiym23> kmc: maybe he doesn't -- my internal copywriter automatically contracts <consonant>ae<consonant> to ä
16:57:25 * ski reads about Zermelo *Type* Theory in "Practical Foundations of Mathematics" by Paul Taylor
16:57:33 <Cale> roconnor: You should be more secretive about it. That's even more crankish than trying to prove P = NP.
16:57:33 <roconnor> elliott: I mean Zermelo set theory.
16:57:44 <roconnor> Cale: I guess
16:57:55 <elliott> roconnor: Good luck with that :p
16:58:07 <roconnor> thanks!
16:58:20 <elliott> roconnor: Why not try Peano Arithmetic first, it's a simpler system to start with.
16:58:32 <ski> (roconnor : i think augustss is also hoping ZF to be inconsistent)
16:58:39 <roconnor> the more powerful the system the easier it is to prove inconsistent.
16:58:40 <ski> elliott : hahaha !
16:58:41 <edwardk> Well proving that Zermelo himself was inconsistent would still be funny.
16:58:58 <elliott> edenc: :D
16:59:06 <roconnor> I think it is likely that PA is consistent.
16:59:08 <elliott> roconnor: I see my sense of humour is failing terribly.
16:59:10 <roconnor> and even sound.
16:59:13 <elliott> Possibly I have none.
16:59:15 <Cale> OBVIOUSLY NOT
16:59:36 <Cale> PA is totally inconsistent, what with its "infinitely" many numbers
17:00:08 <dylukes> Okay.
17:00:13 <ski> (someone channeling Wildberger ?)
17:00:13 <Cale> lol
17:00:16 <dylukes> Unless someone has a better idea,
17:00:18 <roconnor> Gentez's proof of the consistency of PA is pretty compelling.
17:00:22 <dylukes> I'm going to make my current short term goals
17:00:25 <mauke> Penny Arcade?
17:00:29 <dylukes> a) Getting through some amount of TaPL
17:00:35 <dylukes> b) Implementing all of R5RS
17:00:53 <elliott> R5RS has some fun corners, I hope you're ready to start over a few times
17:01:02 <dylukes> Eh, sure.
17:01:04 <kmc> why not R6RS
17:01:08 <Cale> dylukes: Goal b is a funny thing to do after goal a
17:01:08 <dylukes> any specific ones I should look out for in advance?
17:01:10 <elliott> kmc: R6RS sucks :)
17:01:11 <dylukes> R5RS is simpler.
17:01:15 <dylukes> Cale: ?
17:01:17 <ski> why not read R7RS ?
17:01:22 <Cale> TaPL is all about types
17:01:22 <othiym23> kmc: because R6RS came from the same minds that brought the world Java 5 and the C++ "standard"
17:01:22 <dylukes> As I said "unless someone has a better idea"
17:01:27 <kmc> why not Scheme 9000
17:01:31 <Cale> Scheme is essentially untyped
17:01:37 <elliott> dylukes: CALL-WITH-CURRENT-CONTINUATION's interaction with DYNAMIC-WIND, although you can implement a safe call/cc and dynamic-wind on top of an unsafe one in Scheme, so it's not a show-stopper.
17:01:37 <monochrom> time to troll with "if you can code up an inconsistency in PA you can sleep with me. I fill pretty safe lol" :)
17:01:39 <kmc> ok, i didn't know people had such strong feelings about R6RS
17:01:41 <edwardk> ski: which part of wildberger?
17:01:50 <roconnor> edwardk: your model of IO is still non-concurent?
17:01:59 <elliott> dylukes: Also, remember that there are _no_ reserved words.
17:02:03 <dylukes> elliott: Well, theres also that I don't quite know "enough lisp"
17:02:13 <elliott> Scheme is not Lisp
17:02:14 <ski> edwardk : i only vaguely recall bits of his set theory rant (haven't read anything else, yet)
17:02:17 <othiym23> kmc: it's basically a different animal than R[1..5]RS, is the slightly less judgey answer
17:02:18 <kmc> monochrom, haha.  i remember those
17:02:18 <dylukes> I meant scheme, my bad.
17:02:23 <ski> Scheme is *a* Lisp
17:02:23 <roconnor> actually I think Matin-Loef type theory is also consistent.
17:02:25 <dylukes> Maybe i should start with one of the older specs?
17:02:29 <dylukes> ski: I know, I know.
17:02:31 <elliott> dylukes: Oh, and syntax-rules and associated things are really tricky to get right.
17:02:32 <roconnor> *Martin
17:02:34 <monochrom> oops, s/fill/feel/
17:02:42 <kmc> Real Programmers ™ use unhygenic macros
17:02:43 <dylukes> elliott: So, what would you recommend instead?
17:02:52 <kmc> i dun need no computr tellin me what ter do
17:02:55 <dylukes> A relatively "useful" but simple language without too many corner  cases would be nice.
17:02:57 <elliott> Invent your own? I'm not telling you not to, I'm just saying it might not be as easy as you think :)
17:03:07 <edwardk> rock nor: concurrency is fine. That is entirely the domain of the external ffi coroutine driver. Nothing says you can't be evaluating many copies of IO simultaneously. No "real world"
17:03:13 <dylukes> I thought about the matrix thing kmc btw, not really feeling it exactly.
17:03:16 <kmc> ok
17:03:24 <dylukes> Definitely interesting for another time, but it's not my main focus.
17:03:31 <kmc> like i said, it depends on how you feel about focusing your energy on low-level backend optimization
17:03:32 <dylukes> Plus I lack a lot of knowledge in terms of linear algebra.
17:03:34 <othiym23> dylukes: I've been toying with the idea of making an interactive version of The Little Schemer for iOS, and if I did that, I'd probably stick with R4RS
17:03:36 <roconnor> edwardk: but isn't the free monad a tree like structure?
17:03:44 <kmc> othiym23, have fun getting it rejected from the App Store
17:03:45 <elliott> dylukes: Did you know? R5RS' MAP can either: Be tail-recursive (not overflow stack on a large list); interact properly with CALL-WITH-CURRENT-CONTINUATION; or iterate over the list once; pick two.
17:03:49 <edwardk> Er roconnor: damn iPad autocorrect
17:03:54 * monochrom hugs Kripke's multiple real worlds :)
17:04:02 <othiym23> kmc: there are two R5RS interpreters on the App Store already ;p
17:04:06 <elliott> i.e., to work on lists of arbitrary length and interact properly with call/cc, you must go over the list twice (by using REVERSE at the end).
17:04:13 <elliott> This isn't #scheme, so I'll stop now.
17:04:16 <othiym23> I found that kind of surprising, but there you have it!
17:04:19 <kmc> othiym23, interesting.  why'd they reject Scratch, then?
17:04:45 <kmc> Apple is really inconsistent... if you develop for their platform, then you are at the mercy of their whim
17:04:51 <kmc> they can erase entire startups with a click of a button
17:04:53 <othiym23> kmc: because both Scheme implementations are sealed-universe -- there's no way to write interface code or I/O from outside the app's sandbox
17:05:03 <kmc> and Scratch wasn't so?
17:05:07 <Cale> Apple is the new Microsoft
17:05:27 <Cale> (only worse)
17:05:28 <othiym23> kmc: either that or their implementations are so bareboned that the app reviewers simply didn't recognize what they were looking at
17:05:28 <elliott> Microsoft have never created walled gardens.
17:05:34 <Cale> Yeah
17:05:40 <kmc> Cale, they're a lot worse -- MS always tried to give developers lots of freedom content-wise, as long as they were locked into the MS platform
17:05:41 <edwardk> roconnor: the model is that the os pumps the free monad, receiving ffi commands. Nothing is inherently non concurrent. I can be evaluating several such free io structures at the same time.
17:05:41 <kmc> yeah
17:05:43 <elliott> Apple aren't the new Microsoft, they're... the new Apple.
17:05:50 <monochrom> and Microsoft is the new IBM, and IBM is the new DEC, and DEC is the new, I don't know, Data General?
17:05:52 <elliott> I don't think this kind of lock-in has ever really succeeded before.
17:05:58 <othiym23> elliott: exactly
17:05:58 <kmc> IBM is the old everything
17:05:59 <edwardk> Er s/os/rts/
17:06:11 <elliott> IBM is the new IBM, which is also the old IBM
17:06:23 <kmc> > map succ "HAL"
17:06:24 <lambdabot>   "IBM"
17:06:29 <roconnor> edwardk: so I guess the run type system can consume multiple branches of the tree?
17:06:35 <roconnor> *time
17:06:45 <zmv> hm
17:06:49 <monochrom> kmc wins
17:06:49 <zmv> > map succ "IBM"
17:06:51 <lambdabot>   "JCN"
17:06:51 <edwardk> Different trees.
17:06:59 * zmv googles "JCN" :P
17:07:04 <othiym23> anyone who thinks that Microsoft never created walled gardens doesn't really remember Microsoft Live, or even further back, Sidewalk
17:07:14 * othiym23 pours one out for sf.sidewalk.com
17:07:15 <kmc> nope, i don't remember either of those
17:07:27 <edwardk> Nothing says you have one io tree
17:07:27 <edwardk> But yeah I guess forkio would give you different branches
17:07:28 <kmc> also presumably Windows for Phone is some kind of walled garden
17:07:37 <kmc> if only because carriers won't put up with otherwise
17:07:44 <elliott> othiym23: those aren't software gardens
17:08:04 <othiym23> elliott: no, but they are walled ;)
17:08:07 <othiym23> are / were
17:08:16 <Cale> edwardk: You're talking about something pretty close to my view of how the IO monad works.
17:08:39 <othiym23> and XBox Live is a pretty closed system, albeit with a dev-friendly review process
17:08:41 <edwardk> Cale: yep. Did you see the post?
17:08:48 <Cale> Which post?
17:09:02 <edwardk> The 3 parter on command.com
17:09:08 <Cale> command.com?
17:09:11 <kmc> haha
17:09:15 <edwardk> Er comonad.com
17:09:22 <kmc> all this talk of Microsoft
17:09:23 <jmcarthur> heh
17:09:24 <edwardk> F)$:); autocorrect
17:09:24 <monochrom> hahaha
17:09:32 <zmv> haha command.com
17:09:39 <monochrom> you are locked in to microsoft :)
17:09:54 <edwardk> Hah the last 5 years of conditioning
17:10:03 <kmc> i will register autoexec.bat as soon as someone else pays ICANN 200 grand or whatever for the .bat TLD
17:10:18 <othiym23> whoever owns command.com is definitely not doing enough with it
17:10:50 <kmc> i like that symbolics.com is basically just a squat, but even the squatters have some respect for the history of the domain
17:11:18 <kmc> anyway bbl
17:11:23 <dylukes> www.an.us isn't owned I don't think.
17:11:25 <dylukes> :\
17:11:54 <mauke> autoexeb.cat
17:12:08 <dylukes> I want a .out domain
17:12:08 <dylukes> a.out
17:12:10 <dylukes> :)
17:12:12 <edwardk> Cale: the third part of it should make you happy
17:12:15 <elliott> Man, the Exp constructor distinguishes infix applications and regular, gross :(
17:12:28 <dylukes> elliott: ?
17:12:39 <elliott> see http://hackage.haskell.org/packages/archive/template-haskell/2.5.0.0/doc/html/Language-Haskell-TH-Syntax.html#t:Exp
17:12:42 <wli-needjob> ld.so
17:13:16 <jmcarthur> how long has the free package been defunct?
17:13:45 <edwardk> It'll probably undefunct soon unless I can get Ross to let me move free into transformers
17:13:53 <edwardk> The asymmetry is getting to me
17:14:16 <edwardk> Anyways I'm now in new Hampshire. So I need to go be social for a while
17:14:34 <edwardk> Anyways since command-transformers 1.7
17:14:43 <edwardk> I'll bbiab
17:14:43 * ski grins
17:15:56 <c_wraith> command?
17:17:03 * ski is still trying to grasp `c-command'
17:17:39 <Cale> edwardk: Cool, I do like it :)
17:18:41 <identity_> If had some Haskell threads running and ctrl+c'd my application, does ThreadKilled get thrown to them?
17:18:56 <identity_> (i.e. can I catch that to handle ctrl+c in that manner?)
17:18:58 <hpaste> electronplusplus pasted “Whre's the Bug?” at http://hpaste.org/48289
17:19:13 <dpratt71> anyone here familar with "Denotational design with type class morphisms" (author Conal Elliot)?
17:19:17 <Cale> edwardk: I wonder if it would be worthwhile to have some sort of pragma to instruct GHC to adopt a Church encoding for some types, given that it seems to help performance in some cases.
17:19:30 <electronplusplus> cool bot :D
17:19:41 <Cale> electronplusplus: The bug is that you used tabs
17:19:43 <identity_> electronplusplus: what is the error?
17:19:45 <identity_> parse error?
17:19:49 <identity_> Think it's your indentation
17:19:56 <electronplusplus> indentation? :\
17:20:10 <Cale> electronplusplus: Configure your editor to convert tabs to spaces, and then make sure that the lines inside the do block all line up
17:20:15 <ski> augur : i'm not sure what all the clauses of `cc-help' is trying to express ..
17:20:21 <electronplusplus> damn :(
17:20:24 <Cale> So the n in name <- ... should line up with the p in putStr ...
17:20:29 <augur> ski: ok
17:20:40 <augur> ski: also, night. send me stuff in /msg plox
17:20:51 <ski> ok
17:21:05 <cmccann> speaking as someone who almost always prefers tabs for indentation, just use spaces in Haskell
17:21:06 <ski> apart from that, i've reached the end of the draft
17:21:13 <azaq23> indentation = the characters you put before commands so they are grouped together instead of using {}, if you confuse tabs / spaces, this may look more or less ok, but the parser can't group things together
17:21:18 <azaq23> electronplusplus
17:21:24 <elliott>     Warning: Pattern match(es) are overlapped
17:21:24 <elliott>              In an equation for `transform':
17:21:24 <elliott>                  transform (TH.AppE f x) = ...
17:21:24 <elliott>                  transform (TH.InfixE (Just x) op (Just y)) = ...
17:21:24 <elliott> How is that even possible?
17:21:42 <Cale> elliott: lol
17:21:55 <elliott>   | AppE Exp Exp                       -- ^ @{ f x }@
17:21:56 <elliott>   | InfixE (Maybe Exp) Exp (Maybe Exp) -- ^ @{x + y} or {(x+)} or {(+ x)} or {(+)}@
17:21:59 <elliott> That does not look possible. What is going on.
17:22:15 <Cale> yeah, they're totally different constructors, I have no idea how they're supposed to overlap
17:22:36 <elliott> Cale: I'm scared that some horrible magic makes InfixEs look like AppEs to pattern matchers to make it easier
17:22:56 <hpaste> electronplusplus pasted “And now?” at http://hpaste.org/48290
17:23:09 <ski> electronplusplus : if you're chosing to use tabs for layout, you should make sure to : (a) *only* use tabs for layout; (b) always break line after the layout-introducing keywords, i.e. `where',`let',`of',`do'
17:23:13 <Cale> electronplusplus: Now it doesn't line up
17:23:22 <gwern> one thing I've recently noticed is that spam seems to have stopped on hawiki
17:23:22 <elliott> Cale: It seems unlikely though
17:23:27 <gwern> maybe I finally banned enough accounts
17:23:44 <hpaste> Cale annotated “And now?” with “And now? (annotation)” at http://hpaste.org/48290#a48291
17:24:39 <electronplusplus> Cale: thanks :)
17:24:47 <electronplusplus> I was aware of such problem
17:24:51 <electronplusplus> wasn't*
17:24:56 <hpaste> Cale annotated “And now?” with “And now? (annotation) (annotation)” at http://hpaste.org/48290#a48292
17:25:43 <elliott> Cale: heh, the overlap was actually that I had a general case first
17:25:48 <elliott> and it complained about the two non-general cases for some reason
17:25:52 <elliott> maybe it was showing _what_ was overlapping
17:25:53 <Cale> elliott: interesting
17:25:55 <Cale> ah
17:25:57 <Cale> yeah, maybe
17:26:07 <ski> sounds like a bug, imo
17:26:40 <joe6> i have 4 - 5 modules in a directory that I want to use in a haskell script in a different directory. What is the best approach? Change the search path of ghc or make a cabal file with the modules?
17:27:03 <joe6> can one cabal file install different modules? or, should I package it up as a MyLibrary?
17:27:17 <joe6> or, just create symlinks?
17:28:17 <cmccann> joe6, I've used symlinks for random hacky stuff at times, particularly when doing lots of hacking on a "library" used by several quick and dirty programs
17:29:10 <cmccann> anything more serious than that and I'd probably use cabal
17:30:21 <joe6> cmccann, they are my modules and probably will not change much. but, cabal seems to be the most professional approach.
17:30:41 <monochrom> identity_: I think ctrl-c causes UserInterrupt to the main thread, and that's it
17:30:50 <monochrom> main thread = the thread that runs main
17:31:15 <elliott> Applicative functors don't have join, do they?
17:31:20 <identity_> monochrom: Alright, but what about the other threads? Doesn't the main thread send threadkilled to them or something?
17:31:24 <ski> elliott : right
17:31:35 <elliott> ski: so idiom brackets aren't actually for idioms at all really :/
17:31:54 <ski> elliott : of course they are. "idiom" = "applicative functor"
17:31:55 <Cale> elliott: What???
17:32:07 <elliott> don't idiom brackets have an implicit join?
17:32:10 <Cale> no
17:32:10 <ski> no
17:32:15 <elliott> oh, thought they did
17:32:30 <elliott> so it's actually join (| putStrLn getLine |)
17:32:35 <mauke> if they did, they'd be monazzle
17:33:18 <monochrom> identity_: no
17:33:36 <elliott> mauke: :D
17:33:53 <Cale> (| f u_1 u_2 ... u_n |) translates to  pure f <*> u_1 <*> u_2 <*> ... <*> u_n
17:33:59 <elliott> that's kind of a shame though, since they're mostly useful in the situations where you need join imo
17:34:06 <Cale> what?
17:34:13 * ski smiles
17:34:19 <Cale> They're *only* useful in cases where you *don't* need join.
17:34:22 <Cale> That's kinda the point.
17:34:32 <elliott> err, right, my implementation must be broken
17:34:42 <elliott> i am making myself confused :)
17:34:45 <cmccann> though it would be useful to have something similar that did include join
17:34:51 <cmccann> though that would have a more imperative flavor I guess
17:35:01 <cmccann> could use layout to write things on separate lines
17:35:02 <elliott> 1 Motivation
17:35:02 <elliott> Using Control.Applicative you could write:
17:35:02 <elliott> f <$> x <*> y
17:35:02 <elliott> Since f is not a pure function, it's f :: x -> y -> m c. The correct form would be
17:35:02 <elliott> join $ f <$> x <*> y
17:35:02 <elliott> But maybe some type-class hackery can be used to eliminate the join.
17:35:06 <elliott> --[[Idiom brackets]]
17:35:10 <cmccann> would look sorta like imperative code, which would be amusing
17:35:19 <ski> elliott : i have a very rough sketch of a kind of "bracket" that generalizes from idioms to allowing monadic computations
17:35:30 <cmccann> I don't know if anyone would actually use that sort of syntactic sugar though :]
17:35:39 <elliott> my "go-to" use of idiom brackets is e.g. writing a parser
17:35:44 <Cale> cmccann: I can't tell if you're trolling...
17:35:44 <elliott> (| MyCon expr expr |)
17:35:49 <elliott> where expr is a parser
17:35:58 <Cale> cmccann: or just new :)
17:36:11 <Cale> (probably trolling ;)
17:36:17 <cmccann> Cale, :[
17:36:25 <cmccann> No appreciation for sarcasm
17:36:39 <djahandarie> IRC is great for sarcasm.
17:37:20 <absence> when converting a =<< b to applicative form, is join $ a <$> b the shortest it can be written?
17:37:59 <Cale> The trouble with sarcasm is that in order for it to really be effective, the listener has to know what the speaker knows. Otherwise, it's indistinguishable from ignorance.
17:39:05 <identity_> @quote Cale The trouble with sarcasm is that in order for it to really be effective, the listener has to know what the speaker knows. Otherwise, it's indistinguishable from ignorance.
17:39:05 <lambdabot> No quotes match. I've seen penguins that can type better than that.
17:39:09 <identity_> meh
17:39:13 <identity_> how do you add a quote?
17:39:15 <ski> @type let infix 3 <*>>; (<*>>) = join .: (<*>) in \f x y z -> f <$> x <*> y <*>> z
17:39:16 <lambdabot> forall a a1 a2 (m :: * -> *) a3. (Monad m, Applicative m) => (a -> a1 -> a2 -> m a3) -> m a -> m a1 -> m a2 -> m a3
17:39:18 <identity_> That was too profound not too quote it
17:39:19 <elliott> identity_: ?remember
17:39:24 <Cale> You @remember
17:39:24 <cmccann> Cale, I thought I was being heavy-handed enough in describing do notation to make it obvious, but oh well :T
17:39:25 <identity_> every bit of irc wisdom must be kept
17:39:31 <elliott> Cale: that is sort of the point of sarcasm though :)
17:39:36 <identity_> @remember Cale The trouble with sarcasm is that in order for it to really be effective, the listener has to know what the speaker knows. Otherwise, it's indistinguishable from ignorance.
17:39:36 <lambdabot> Okay.
17:39:44 <identity_> @quote sarcasm
17:39:45 <lambdabot> Cale says: The trouble with sarcasm is that in order for it to really be effective, the listener has to know what the speaker knows. Otherwise, it's indistinguishable from ignorance.
17:40:20 <cmccann> Cale, also after spending the last year and a half explaining Haskell stuff to people on Stack Overflow I've gotten a little too used to people recognizing me in passing, heh
17:41:19 <Cale> cmccann: Stack overflow has sort of snuck up on me. I didn't really see the point in it initially since we already had so many popular forums for Haskell questions, but it's become quite popular on its own somehow.
17:41:53 <cmccann> Cale, mostly because it's gone to some effort to provide a more focused environment for Q&A
17:42:00 <dmwit> I recently started on Stack Overflow.
17:42:05 <dmwit> It's kind of fun in its own way.
17:42:06 <Cale> Well, the mailing lists sort of do that too.
17:42:10 <ski> elliott : you don't need `join' for `(| MyCon expr expr |)', though ..
17:42:22 <djahandarie> Mailings lists are also a pain in the ass and from the early 90s.
17:42:28 <Cale> Though they have the problem that people will go off on crazy tangents at the drop of a hat.
17:42:32 <cmccann> Cale, nah, that's my point. SO actively discourages arbitrary discussions and topic drift
17:42:34 <mauke> preflex: ? sarchasm
17:42:35 <preflex>  factoid not found
17:42:50 <cmccann> Both culturally and technically, e.g. by making long conversations awkward in the site's interface
17:42:51 * tswett figures out how hscurses works.
17:42:58 <Cale> We also used to have a wiki which people actually used as a wiki
17:43:22 <jmcarthur> absence: what do you mean by "converting to applicative form"?
17:43:23 <Cale> MediaWiki is a great way to discourage any form of direct interaction between people
17:43:37 <Cale> Because everyone automatically thinks of wikipedia and its rules.
17:43:43 <Cale> :/
17:43:44 <cmccann> SO is very nice for a very limited kind of thing, and actively useless otherwise, which is nice in a way
17:43:58 <ski> Cale : i preferred MoinMoin. even though it sometimes became a bit unstructured
17:44:01 <Cale> yeah
17:44:03 <Cale> me too
17:44:43 <Cale> We used to have a really thriving community of questions and responses going on the moinmoin wiki, and that sort of went away with the mediawiki for some reason.
17:44:46 <elliott> Cale: Hmm, I still don't see why idiom brackets are not useful when using join
17:45:07 <ski> elliott : they can be
17:45:16 <Cale> elliott: Because they're a syntax for applicative functors, where join is impossible.
17:45:25 <Cale> (or at least, not generally possible)
17:45:26 <elliott> Cale: Yes, but all monads are applicative functors.
17:45:29 <Cale> Sure
17:45:30 <elliott> So why is "join (| ... |)" never useful?
17:45:39 <Cale> It can be, sure.
17:45:43 <elliott> OK, sure.
17:45:53 <elliott> Just <Cale> They're *only* useful in cases where you *don't* need join.
17:45:56 <elliott> read differently to me
17:45:59 <Cale> I mean, (| ... |) on its own is useless if you need join
17:46:07 <elliott> Right
17:46:19 <elliott> I might define [m| ... |] === join [i| ... |]
17:46:23 <hpaste> electronplusplus pasted “Oh Fuck my Life” at http://hpaste.org/48293
17:46:25 <tswett> Uh, note to self: it's not very easy to play with hscurses in GHCi.
17:46:32 <elliott> Although I'd need a longer name since i is just an alias for idiom :)
17:46:40 <elliott> "mona"???
17:46:41 <elliott> Mona brackets.
17:46:47 <jmcarthur> tswett: haha
17:47:11 <hpaste> Cale annotated “Oh Fuck my Life” with “Oh Fuck my Life (annotation)” at http://hpaste.org/48293#a48294
17:47:42 <cmccann> Cale, anyway, SO is best for clearly defined, single topic question+answer material that doesn't need a lot of discussion or exploration to figure out, vs. more conversational stuff on IRC/mailing lists, more expository type stuff like wikis tend to acquire, etc.
17:48:00 <Cale> electronplusplus: General good-style rule: the 'then' and 'else' should always line up if they're on different lines.
17:48:02 <cmccann> Cale, having seen you in here often enough you seem to prefer a more conversational style so I don't know if you'd find SO very appealing
17:48:20 <tswett> "Initialize the screen."  "Done."  "How big is the screen?"  "Boonk."  "Uh... get me a fresh prompt."  "Boonk."  "What's 3?"  "Boonk."  "^C."  "Done."  "Now what's 3?"  "Boonk."
17:48:29 <ski> elliott : consider a syntax where you can write `<| MyCon {| expr |} {| expr |} |>' as well as `<| let x = {| foo |} in bar x {| baz |} |>'
17:48:31 <Cale> cmccann: It's weird how it doesn't let you do stuff until you have enough points.
17:48:34 <electronplusplus> Thanks a lot Cale the college slides are a huge piece of shit :\
17:49:01 <elliott> ski: Ideally, I would like to handle that last one
17:49:03 <Cale> electronplusplus: It'd also be valid to start the do on the same line as the =
17:49:16 <Cale> electronplusplus: But everything has to move as a block
17:49:36 <hpaste> Cale annotated “Oh Fuck my Life” with “Oh Fuck my Life (annotation) (annotation)” at http://hpaste.org/48293#a48295
17:49:42 <Cale> (like that)
17:49:44 <ski> elliott : the latter would be translated to `foo >>= \x -> bar x <$> baz', basically
17:50:05 <elliott> ski: _oh_, I see
17:50:10 <elliott> ski: now that would be a pain :)
17:50:22 <elliott> *Control.Applicative.Brackets Control.Monad> :t [i| (,) getLine getLine |]
17:50:22 <elliott> <interactive>:1:4: Not in scope: data constructor `GHC.Unit.(,)'
17:50:25 <elliott> ugh, that doesn't even make sense :(
17:50:29 <ski> elliott : why would it be a pain ?
17:50:46 <elliott> ski: I just mean from a purely TH point of view, to implement it
17:51:38 <cmccann> Cale, mostly that's to reduce the amount of noise produced by people who don't contribute to the site, most of the day-to-day stuff is unlocked very quickly
17:51:52 <Cale> cool
17:53:17 <Cale> electronplusplus: The golden rule of Haskell indentation is that if one thing is part of something else, it should start on a deeper column, and if two things are both part of the same thing (they are siblings), then they should start in the same column.
17:53:21 <elliott> Ugh... [i| [i| read getLine |] + 9 |] doesn't parse for obvious reasons.
17:53:25 <elliott> I think this is not a productive route.
17:53:35 <electronplusplus> Cale: I suppose that exists a GUI editor with syntax check for haskell
17:53:48 <elliott> electronplusplus: emacs
17:53:54 <Cale> electronplusplus: We could do a lot better in that regard
17:53:57 <electronplusplus> hat emacs
17:54:01 <electronplusplus> hate*
17:54:02 <elliott> hat emacs?
17:54:09 <Cale> There's an emacs mode, I guess.
17:54:12 <elliott> you'll lose out on haskell-mode then :)
17:54:21 <ski> elliott : it's sad how it's hard to make composable/nestable brackets ..
17:54:28 <Cale> But even haskell-mode in emacs doesn't really work the way I'd like it to
17:54:29 <elliott> ski: it fails here only because of quasiquote syntax
17:54:38 <elliott> Cale: flymake works quite well, btw
17:54:42 <elliott> for seeing errors in Haskell code as you type
17:54:45 <Cale> I *hate* the way that it forces you to type the beginning of your line before pressing tab sometimes.
17:54:55 <Cale> (if you want it to get the indentation right)
17:54:55 <ski> elliott : yeah. in Lisps, this is a common thing to do
17:54:56 <elliott> Cale: you could use a different indentation mode
17:54:59 <electronplusplus> why not brackets? :( like in C
17:55:07 <Cale> Yeah, I usually just turn off the smart indentation.
17:55:13 <Cale> When I was using it.
17:55:16 <elliott> electronplusplus: you can use brackets for many things, e.g. do notation
17:55:27 <elliott> the reason layout syntax exists is because it's a lot more readable and pretty
17:55:33 <electronplusplus> you mean like {-- comment
17:55:37 <mauke> electronplusplus: you're free to use brackets everywhere
17:55:37 <Cale> electronplusplus: You can use braces and semicolons for anything you can use layout for.
17:55:39 <elliott> erm?
17:55:42 <elliott> no, that is unrelated.
17:55:44 <elliott> and it is {- not {--
17:55:57 <ski> Cale : i noticed a few hours ago that `haskell-newline-and-indent' treats form feeds strangely ..
17:56:11 <ski> (as does `newline-and-indent', though, in another way)
17:56:20 <Cale> do { x <- getChar; if x == '\n' then return [] else do { xs <- getLine2; return (x:xs) } }
17:56:41 <electronplusplus> nice :)
17:56:56 <electronplusplus> that you make my life easier during the exam
17:56:57 <ski> @undo do { x <- getChar; if x == '\n' then return [] else do { xs <- getLine2; return (x:xs) } }
17:56:57 <lambdabot> getChar >>= \ x -> if x == '\n' then return [] else getLine2 >>= \ xs -> return (x : xs)
17:57:00 <Cale> But nobody writes like that, since it's prettier to read properly indented brace-free syntax
17:57:12 <ski> @. pl undo do { x <- getChar; if x == '\n' then return [] else do { xs <- getLine2; return (x:xs) } }
17:57:12 <lambdabot> ap (flip if' (return []) . ('\n' ==)) ((`fmap` getLine2) . (:)) =<< getChar
17:57:15 <elliott> electrogeek: It's really ugly, better to get used to writing layout syntax.
17:57:20 <elliott> Don't run away from unfamiliarity :)
17:57:22 <elliott> sorry, electronplusplus
17:57:26 <electronplusplus> lol
17:57:44 <ski> @karma {
17:57:44 <lambdabot> { has a karma of -4
17:57:48 <elliott> :(
17:57:51 <elliott> {++ {++ {++ {++ {++
17:57:53 <elliott> ?karma {
17:57:53 <lambdabot> { has a karma of 1
17:57:55 <elliott> poor {
17:58:00 <elliott> i've nothing against it
17:58:13 <Cale> It is however convenient if you're writing a program to generate a bit of Haskell code (and don't want to use one of the libraries for that), that you don't have to worry about layout.
17:58:15 <dmwit> {--
17:58:16 <dmwit> I do!
17:58:26 <dmwit> Nasty, squirrely little things.
17:58:39 <zmv> @karma C
17:58:40 <lambdabot> C has a karma of 4
17:58:51 <mauke> preflex: karma {
17:58:51 <preflex>  {: -4
17:58:57 <mauke> hah
17:58:59 <Cale> C++
17:59:03 <Cale> @karma C
17:59:03 <lambdabot> C has a karma of 4
17:59:07 <elliott> mauke: :(
17:59:07 <Cale> ^^ special case ;)
17:59:08 * ski idly wonders whether anyone else uses form feeds in Haskell source ..
17:59:09 <zmv> ...
17:59:11 <elliott> mauke: why does it not listen to me
17:59:13 <mauke> preflex: karma C
17:59:13 <preflex>  C: 169526
17:59:16 <mauke> elliott: it does
17:59:21 <elliott> Cale: C has a positive karma forevermore?
17:59:23 <elliott> injustice
17:59:29 <elliott> ?karma- C
17:59:29 <lambdabot> C's karma lowered to 3.
17:59:30 <Cale> @karma- C
17:59:30 <lambdabot> C's karma lowered to 2.
17:59:35 <Cale> @karma+ C
17:59:35 <elliott> ?karma- C
17:59:35 <lambdabot> C's karma lowered to 1.
17:59:35 <lambdabot> C's karma raised to 2.
17:59:38 <elliott> it can keep the one point
17:59:38 <Cale> lol
17:59:39 <elliott> aww
17:59:41 <zmv> zomg
17:59:47 <ski> elliott : we need to talk more about c-minus-minus, clearly
17:59:48 <elliott> mauke: haha wow
17:59:50 <elliott> your bot really likes C
17:59:54 <zmv> C-- FTW
17:59:58 <mauke> preflex: karma C++
17:59:58 <preflex>  C++: -56
17:59:58 <elliott> ski: Don't you mean C--?
18:00:00 <elliott> ?karma C
18:00:00 <lambdabot> C has a karma of 2
18:00:06 <elliott> Cale: i find these special-cases disturbing
18:00:17 <elliott> mauke: C++--?
18:00:22 <mauke> yes
18:00:26 <Cale> I FIND YOUR LACK OF FAITH IN SPECIAL CASES DISTURBING
18:00:27 <elliott> a common thing to say
18:00:44 <mauke> that was people specifically de-karma-ing C++.
18:01:12 <ski> oh no -- a special case !
18:01:22 <elliott> mauke: must be in a really C++ hater channel to get that many
18:01:27 <mauke> wait, I think I'm in the wrong joke
18:01:34 <elliott> wat
18:01:45 <cmccann> who's on first, now?
18:02:01 <jmcarthur> @karma foo
18:02:02 <lambdabot> foo has a karma of 1
18:02:06 <mauke> elliott: i.e. any non-##c++ channel
18:02:10 <jmcarthur> > let foo = 1 in foo-- test
18:02:10 <lambdabot>   1
18:02:13 <jmcarthur> @karma foo
18:02:13 <lambdabot> foo has a karma of 0
18:02:22 <mauke> preflex: karma i
18:02:22 <preflex>  i: 1771
18:02:30 <jmcarthur> > text "foo++"
18:02:31 <lambdabot>   foo++
18:02:32 <jmcarthur> @karma foo
18:02:33 <lambdabot> foo has a karma of 0
18:02:46 <elliott> mauke: yeah :P
18:02:54 <elliott> high signal right now eh
18:03:04 <mauke> preflex: karma signal
18:03:04 <preflex>  signal has no karma
18:03:36 <mauke> now all that's left is another round of nickometer
18:03:38 <cmccann> there's pretty much only one reason anyone likes C++, I think
18:04:14 <zmv> ONE *WHOLE* REASON?
18:04:17 <elliott> cmccann: Insanity? Employment?
18:04:21 <cmccann> elliott, Stockholm syndrome
18:04:24 <cmccann> ;]
18:04:31 <elliott> Both!
18:05:01 <elliott> I find C++'s template system actually provides for a nice alternative to Sudoku; you pick a random task and set about implementing it in C++ templates.
18:05:11 <elliott> Usually a simple functional programming template.
18:05:16 <elliott> Very difficult :-)
18:05:59 <mauke> did you know: ghc typeclasses are prolog
18:06:10 <cmccann> without backtracking
18:06:43 <zmv> hmm
18:06:56 <cmccann> prolog is to ghc typeclasses as C is to brainfuck
18:06:59 <elliott> mauke: Well, sort of :P
18:07:04 <fxr> I have written this sentence on a job application form today which asks "describe yourself": "I am is a data type which has a type variable represented by am."
18:07:19 <elliott> mauke: You have to split every application you pattern-match upon into another predicate
18:07:49 <fxr> I think it's getting harder and harder to find a real job...
18:08:05 <elliott> fxr: i wonder why :)
18:09:48 * ski . o O ( `data So : Bool -> Set where Oh : So True' )
18:10:06 <fxr> coz I'm not interested in their methodologies, ah btw if there is.
18:10:12 <elliott> the best constructs are based on puns
18:10:38 <mauke> preflex: seen God
18:10:38 <preflex>  God was last seen on ##c++ 1 year, 264 days, 2 hours, 36 minutes and 6 seconds ago, saying: I don't really know either actually
18:11:10 <fxr> anybody seen the Parsing with Derivatives work?
18:11:37 <ski> where ?
18:12:05 <fxr> @google matt might parsing with derivatives
18:12:06 <lambdabot> http://matt.might.net/articles/parsing-with-derivatives/
18:12:06 <lambdabot> Title: 18 Yacc is dead: An update 269
18:14:18 <fxr> I just wanted to ask if this work just tries to introduce a new data structure of some kind to gain some performance benefit or are there any formal background somewhere which I cannot see.
18:14:51 <fxr> anyways, interesting work even it's in hackage
18:14:55 <fxr> @hackage derp
18:14:55 <lambdabot> http://hackage.haskell.org/package/derp
18:15:02 <ski> fxr : heh. i've read a little by antimirov on derivatives of regular languages
18:16:39 <ski> btw, the full specification is `[| d S \ d R |] = { w1 | exists w0. w0 \in S /\ (w0 ++ w1) \in R }'
18:16:48 <fxr> even there is a lecture video given at stanford.
18:18:28 <ski> (s/in S/in [| S |]/,s/in R/in [| R |]/)
18:22:17 <fxr> i wonder there's a connection between set theory and this work.
18:23:39 <ski> how do you mean ?
18:24:21 <fxr> he starts defining regular languages by introducing unit, empty and singleton
18:24:40 <fxr> which corresponds to set families
18:25:19 <ski> how ?
18:26:07 <fxr> anyway, gotta investigate more, I'm in a very early stage to throw ideas about it.
18:26:30 <ski> if "empty" corresponds to an empty family
18:26:40 <ski> and "unit" to a family with one member
18:26:49 <ski> what does "singleton" correspond to ?
18:27:52 <fxr> nope, empty corresponds to an empty set, unit corresponds to a set which holds an empty set, a singleton holds a non empty set
18:27:53 <cmccann> ski, something like a unit, except it's unhappy about being alone
18:28:03 <ski> anyway, i think there's a similarity between the regular constructions, and derivatives, and kripke semantics
18:28:41 <ski> fxr : that sounds strange .. why discriminate the empty set like that ?
18:29:06 <ski> hm
18:29:23 <ski> i suppose i might see what you're aiming for
18:29:41 <ski> `{}',`{[]}',`{[x]}'
18:30:27 <fxr> exactly, empty is the terminator like object I guess, and others for the Monoidal structure.
18:30:28 <ski> then "singleton" means a set having a single singleton list
18:31:00 <ski> (as opposed to singleton sets containing other lists)
18:31:17 <identity_> If I can only catch all exceptoins with "SomeException" how can I create a function that catches an exception and tells me which one it was so that I may discover what is crashing my thread?
18:31:32 <ski> generally `[x]' would be any irreducable element in the monoid
18:31:40 <ski> (i think)
18:37:35 <fxr> hmm D_c L = { w : cw E L } which means derivative of language L with respect to c is computed by matching every string in L whose first letter is 'c' and choping out 'c', yielding a new set.
18:38:47 <fxr> hence D_f {foo, frak, bar} = {oo, rak}
18:38:52 <ski> *nod*
18:40:01 <ski> and `D_{fo,fr} {foo, frak, bar} = d {fo,fr} \ d {foo, frak, bar} = {o,ak}'
18:40:40 <ski> (generalizing to the case of taking the derivative of one language wrt another)
18:42:17 <fxr> and with kleene star D_f {foo,bar}* = {oo} . {foo,bar}*
18:43:21 <ski> hm, i think `R |-> d S \ d R' is left adjoint to `T |-> S o T'
18:43:34 <ski> does that sound sensible ?
18:44:00 <ski> hm
18:44:12 <fxr> hmm I think Im not feeling confortable with your notation.
18:44:34 <ski> `d R \ d S' ?
18:45:01 <fxr> nope '|->'
18:45:14 <ski> that's just a "mapsto" arrow
18:45:25 <ski> `\x -> ..x..' in Haskell
18:46:34 <ski> hm no .. it can't be a left adjoint either
18:46:36 <ski> :/
18:46:39 <fxr> I wonder why D_f {foo,bar}* = {oo} . {foo,bar}*
18:48:01 <fxr> the dot is for the concatenation
18:48:11 <ski> `(foo + bar)^*' is the same as `1 + (foo + bar) * (foo + bar)^*'
18:48:33 <ski> we have rules
18:49:01 <ski>   d S \ d (R0 + R1)  =  d S \ d R0  +  d S \ d R1
18:51:23 <ski>   d S \ d (R0 * R1)  =  (d S \ d R0) * R1  <=  not (0 =< R0) /\ prime S
18:51:25 <ski> (i think)
18:51:39 <ski> well, we have for sure
18:52:21 <ski>   d (S0 * S1) \ d R  =  d S1 \ d (d S0 \ d R)
18:53:46 <ski>      d f \ d (f*o*o + b*a*r)^*
18:54:05 <ski>   =  d f \ d ((f*o*o + b*a*r) * (f*o*o + b*a*r)^*)
18:54:28 <ski>   =  (d f \ d (f*o*o + b*a*r)) * (f*o*o + b*a*r)^*
18:54:43 <ski>   =  (d f \ d f*o*o + d f \ d b*a*r) * (f*o*o + b*a*r)^*
18:55:09 <ski>   =  ((d f \ d f)*o*o + (d f \ d b)*a*r) * (f*o*o + b*a*r)^*
18:55:19 <ski>   =  (1*o*o + 0*a*r) * (f*o*o + b*a*r)^*
18:55:28 <ski>   =  (o*o + 0) * (f*o*o + b*a*r)^*
18:55:42 <ski>   =  o*o * (f*o*o + b*a*r)^*
18:56:43 <ski> to derive this, we must know that `f' is prime, and that `0' is not less than any of `f',`b',`f*o*o',`b*a*r',`(f*o*o + b*a*r)'
18:57:45 <ski> oh .. also that `d f \ d b  =  0', because `f' and `b' are distinct primes
18:57:46 <fxr> aha, yes I guess it's clear now, first we have no language which contains the empty string, we have single character languages which contain one character each and empty languages which contains no strings at all.
19:10:40 <sshc> Is there a quasi-quoter that doesn't require its variables to be in scope?
19:14:15 <ski> fxr : hm, istr `[| E_S R |] = { w1 | forall w0. w0 \in [| S |] => (w0 ++ w1) \in [| R |] }' being defined as well ..
19:15:52 <scooty-puff> is there a standard way to make alex support utf8?
19:16:08 <scooty-puff> i saw the stuff in the ghc lexer, but wasn't sure if there's maybe a better way
19:21:09 <zmv> @protontorpedo
19:21:10 <lambdabot> can haskell be used to develop databases?
19:21:13 <zmv> haha
19:21:36 <Cale> @protontorpedo
19:21:37 <lambdabot> syntax ur runing my high
19:21:39 <Cale> @protontorpedo
19:21:40 <lambdabot> what is so good about continuations/
19:21:46 <shachaf> @vixen what is so good about continuations/
19:21:46 <lambdabot> i dunno, what about?
19:21:58 <shachaf> @vixen can haskell be used to develop databases?
19:21:58 <lambdabot> church is my favourite computer scientist.
19:22:04 <shachaf> Useless.
19:22:08 <Cale> @keal
19:22:09 <lambdabot> someone needs to write a boids for haskell that emulates humans going on and off topic
19:22:11 <Cale> @keal
19:22:12 <lambdabot> i changed my user od
19:22:15 <Cale> @keal
19:22:15 <lambdabot> i dont really eat vegetables unless cheese is a vegetable
19:22:24 <shachaf> @vixen i dont really eat vegetables unless cheese is a vegetable
19:22:24 <lambdabot> i don't either
19:22:32 <Cale> @keal
19:22:33 <lambdabot> i suggest you tear apart a 20q and plug it with the alg
19:22:41 <Cale> Good ol' keal
19:22:44 <Cale> @keal
19:22:44 <shachaf> @vixen i suggest you tear apart a 20q and plug it with the alg
19:22:45 <lambdabot> If something takes a lot of effort to do, it probably ain't worth doing.
19:22:45 <lambdabot> today's 24hour project was supposed to be logical overloading using plegm method
19:23:06 <Cale> @keal
19:23:07 <lambdabot> need to plan a fieldtrip to Frederick B. Mancoff of Freescale Semiconductor
19:23:22 <Cale> He was a really entertaining troll.
19:23:47 <shachaf> @Cale
19:23:47 <lambdabot> Unknown command, try @list
19:23:59 <Cale> @quote Cale
19:24:00 <lambdabot> Cale says: A small category is a monad in the 2-category of spans of sets.
19:26:27 <ski> Keal seemed mostly confused
19:27:01 <cmccann> someone should take the channel logs, sort by user, then run a markov chain algorithm for each and put that in lambdabot
19:27:13 <cmccann> so that imitations of anyone can be produced as needed
19:27:16 <mauke> preflex: quote-count Cale
19:27:16 <preflex>  Cale has 4 quotes
19:27:19 <Cale> I think he honestly had some sort of mental condition. One time I talked to him when he was on meds and he made a lot more sense and was embarrassed about the stuff he said when he wasn't.
19:27:40 <cmccann> that's kinda :(
19:27:55 <mauke> preflex: be Cale
19:27:56 <preflex>  There should be a website called "Static Equilibrium or Not" where you rate pictures according to whether you think the depicted objects are in static equilibrium.
19:28:01 <ski> istr he mentioning schizophrenia
19:28:03 <cmccann> haha
19:29:05 <ski> preflex: be sarahbot
19:29:06 <preflex>  no quotes found for sarahbot
19:29:39 <mauke> preflex: be PoppaVic
19:29:39 <preflex>  I already know you and I can commo, and you MIGHT commo with my sibs - and (trust me) they are far more strange - to ##C
19:30:03 <elliott> poppavic :(
19:30:18 <elliott> i'm trying to forget him
19:30:50 <mauke> preflex: be PoppaVic
19:30:51 <preflex>  timing has no bearing on dick, until you start to learn who and when does what to whom.
19:32:08 <kmc> preflex, be preflex
19:33:27 <preflex>  no quotes found for preflex
19:33:55 <kmc> preflex, be lambdabot
19:33:56 <preflex>  no quotes found for lambdabot
19:34:01 <kmc> @quote preflex
19:34:02 <lambdabot> preflex says: god was last seen on ##c++ 96 days, 6 hours, 19 minutes and 16 seconds ago, saying: I don't really know either actually
19:34:05 * cmccann wonders if "no quotes found for preflex" is a quote
19:34:32 <mauke> fountainofdoubt.jpg
19:34:45 <jaj> looks like god has forsaken us
19:34:56 <Cale> @quote @quote
19:34:56 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
19:35:02 <mauke> preflex: quote kmc
19:35:02 <preflex>  <kmc> i'll show you my Coq if you show me yours
19:35:08 <Cale> @quote me
19:35:09 <lambdabot> me says: trololololo
19:35:15 <kmc> as i recall I was trolling HaskellLove at the time
19:35:19 <kmc> trying to get him to change his name to CoqLove
19:35:20 <djahandarie> preflex, quote mauke
19:35:20 <preflex>  <mauke> I used to have a 0 char solution, but then they fixed the judge program :-(
19:35:29 <jaj> kmc: haskelllove?
19:35:43 <kmc> yep
19:35:51 <mauke> preflex: quote-count kmc
19:35:51 <preflex>  kmc has 6 quotes
19:36:30 * cmccann has yet to see a discussion of Coq that didn't involve at least two juvenile puns
19:36:37 <mauke> preflex: quote kmc 0
19:36:37 <preflex>  <kmc> C++ programmers have this cognitive dissonance where they realize that compile-time metaprogramming is powerful but they don't see that templates are an awful implementation of same.  and so it's all "templates are useful because x,y,z" instead of "templates are useful despite x,y,z"
19:36:52 <sam2> can someone help me??
19:36:53 <sam2> http://hpaste.org/48298
19:36:57 <mauke> preflex: quote kmc 1
19:36:57 <preflex>  <kmc> C++'s "typename" keyword is basically INTERCAL's "please"
19:37:03 <sam2> I get type erros but I cannot find why...
19:37:30 <kmc> it thinks 'n' is a list
19:37:38 <Cale> sam2: What's the type of rootpower?
19:37:55 <Cale> oh
19:38:00 <mauke> sam2: what's the type of fntt'?
19:38:03 <Cale> heh, yeah, ifntt produces a list
19:38:07 <Cale> in the first two cases
19:38:11 <Cale> but in the third
19:38:16 <Cale> you have it producing a number?
19:38:25 <kmc> sam2, btw "p = head $ filter isPrime [n+1, 2*n+1..]"
19:38:40 <kmc> or "Just p = find isPrime [n+1, 2*n+1...]"
19:39:45 <sam2> what does filter do again?
19:39:47 <kmc> :t filter
19:39:49 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
19:39:52 <kmc> @src filter
19:39:52 <lambdabot> filter _ []     = []
19:39:53 <lambdabot> filter p (x:xs)
19:39:53 <lambdabot>     | p x       = x : filter p xs
19:39:53 <lambdabot>     | otherwise = filter p xs
19:40:08 <kmc> filter p xs = [x | x <- xs, p x]
19:40:33 <kmc> (the list comprehension is defined in terms of 'filter')
19:40:37 * ski wants type tuples and kind polymorphism ..
19:40:52 <kmc> ski, UHC has kind polymorphism
19:41:08 <ski> @undo [x | x <- xs, p x]
19:41:08 <lambdabot> concatMap (\ x -> if p x then [x] else []) xs
19:41:13 <djahandarie> And GHC might at some point. It's semi-planned at least.
19:41:24 <djahandarie> (There is a planned feature that should make it fairly painless.)
19:41:34 <kmc> which?
19:41:41 <djahandarie> byorgey, typekinds.
19:41:46 <elliott> I just want datakinds.
19:41:48 <djahandarie> byorgey's*
19:41:56 <kmc> hrm
19:42:00 <kmc> what's a typekind
19:42:04 <elliott> And then automatic, silent derivation of datakinds from data.
19:42:07 * cmccann just wants to be able to use everything term-level at the type level
19:42:10 <elliott> Then she will be obsolete.
19:42:14 <elliott> Can I have that? Pretty please?
19:42:21 <djahandarie> kmc, have you played with SHE?
19:42:28 <elliott> djahandarie: oh, are datakinds coming???
19:42:32 <ski> elliott : that's what she said
19:42:37 <kmc> elliott, what about her fake aspect-oriented programming
19:42:45 <kmc> typekinds = datakinds?
19:42:47 <djahandarie> elliott, no.
19:42:49 <elliott> kmc: I mean -- all the features of she anyone sane uses :)
19:43:11 <djahandarie> kmc, elliott, it's a different solution to the same problem.
19:43:25 <elliott> djahandarie: Got a link?
19:43:54 <kmc> surely you're not implying that conor mcbride is in any way not sane
19:43:58 * cmccann once wrote most most of a type-level interpreter for System F, with limited support for data structures and such
19:44:12 <elliott> kmc: Sorry; I'll refrain from complimenting him.
19:44:29 <elliott> cmccann: Now just port GHC...
19:45:21 <djahandarie> elliott, see http://byorgey.wordpress.com/2010/07/19/typed-type-level-programming-in-haskell-part-iii-i-can-haz-typs-plz/ and http://byorgey.wordpress.com/2010/08/05/typed-type-level-programming-in-haskell-part-iv-collapsing-types-and-kinds/
19:45:46 <djahandarie> http://www.cis.upenn.edu/~byorgey/talks/typetype-HIW-20101001.pdf has slightly more technical detail
19:46:02 <elliott> djahandarie: "Conor McBride's SHE" intentionally breaking cheap puns is illegal :(
19:46:20 <elliott> all sentences that she appears in must be formulated to be grammatically correct with the other meaning of she
19:46:45 <elliott> djahandarie: ok, so this is basically automatically lifting data to datakinds?
19:46:49 <djahandarie> Yes.
19:46:54 <elliott> djahandarie: that's exactly what I want :)
19:47:01 <elliott> djahandarie: For all standard types too, etc.?
19:47:34 <djahandarie> "Lifting" is somewhat of a misnomer. The type and kind levels are collapsed entirely.
19:47:38 <elliott> Right.
19:47:45 <elliott> Oh, I have seen this pdf before.
19:47:49 <elliott> So is this actually confirmed for mainline GHC?
19:48:02 <djahandarie> Yes, but the main work on it hasn't really started.
19:48:10 <elliott> Wonderful.
19:48:35 <djahandarie> But I hear that the gears are starting to turn.
19:48:50 <elliott> It'd be nice if that became standard Haskell too, but now I'm dreaming.
19:49:09 <elliott> Although I have a feeling anything GHC does could get standardised with only a little bit of bloodshed.
19:49:10 <djahandarie> Let's make Functor a superclass of Monad before that happens. :)
19:49:37 <elliott> djahandarie: Not until we have a nice way to declare superclasses with subclasses, and a way for subclasses to give defaults for superclass values.
19:49:48 <elliott> ...and THEN we should fix the bloody numeric classes.
19:50:26 <djahandarie> I agree, but I'd rather be inconvenienced than have a broken hierachy.
19:50:54 <elliott> djahandarie: Well, I think there are already proposals for doing that sort of thing.
19:51:14 <elliott> djahandarie: And it'd break so much code if the change was made without that, and none at all if it was made with it.
19:51:27 <elliott> djahandarie: But hey... maybe by Haskell 2100 we'll have all the things we want. Until we think of a new thing.
19:51:29 <djahandarie> Yeah. I skimmed over a mailing list conversation about this awhile back and decided I didn't want to get involved.
19:53:11 <elliott> djahandarie: So wait, are functions automatically lifted with this typekind scheme?
19:53:20 <elliott> I should just read the pdf :)
19:53:32 <djahandarie> No.
19:53:56 <elliott> So all lifting involves an explicit rewrite of the function? It'd be nice to have a deriving-esque declaration for functions...
19:59:40 <hpaste> god pasted “Jesus” at http://hpaste.org/48301
19:59:58 <elliott> thanks god
20:00:29 <djahandarie> Heh.
20:01:51 <kmc> o_O
20:10:05 <xil> hi. Is there a way to do `mod` on floating point numbers? I could have sworn I once did something like that, but I can't find it now
20:11:17 <elliott> ?hoogle fmod
20:11:17 <lambdabot> Network.HTTP.Headers HdrIfModifiedSince :: HeaderName
20:11:22 <elliott> huh
20:12:01 <xil> ah there's mod'
20:12:06 <xil> which is the generalized version
20:12:10 <xil> thank you
20:12:28 <siracusa> :t mod'
20:12:29 <lambdabot> forall a. (Real a) => a -> a -> a
20:12:30 <elliott> djahandarie: um, are you sure that functions are not automatically lifted?
20:12:32 <elliott> I see
20:12:33 <elliott>   append :: LOL m a -> LOL n a -> LOL (plus m n) a
20:13:35 <djahandarie> elliott, there are a number of issues with doing that
20:13:47 <elliott> right, it is in the blog post though :)
20:14:01 <djahandarie> Yes, and rightfully refered to as "fantasy code" :p
20:14:24 <elliott> I'd use some syntax like (^plus m n) -- or at least have a declaration like
20:14:29 <elliott> deriving family Plus <= plus
20:14:29 <elliott> :p
20:14:47 <djahandarie> The major problem is that you don't want to lift a nonterminating function
20:15:14 <elliott> Well, sure... but is that really such a hard pill to swallow? Plenty of extensions let you do that easily
20:15:31 <djahandarie> The general idea behind it so far is to just do the obvious conversion of a function to a type family, and let GHC's existing stupid termination checker handling.
20:15:36 <elliott> There's not much difference between a program that takes an hour to typecheck and a program that takes forever to typecheck, so I don't see it as very relevant
20:15:55 <elliott> I wonder if GADTs and the like will be lifted
20:15:58 <elliott> That'll be, uh, interesting
20:16:03 <djahandarie> No, GADTs are way too complicated.
20:16:07 <elliott> Awww
20:16:08 <djahandarie> It isn't planned to do that yet.
20:16:19 <elliott> One day we'll just get -XDependentTypes and all this will be over with
20:16:22 <kmc> GADK
20:16:52 <elliott> still waiting for kind-level programming
20:25:25 <sshc> I have a question for those who know about template haskell: why would "[hs| 3 |]", where "hs" is exported by http://hackage.haskell.org/packages/archive/haskell-src-exts-qq/0.4.0/doc/html/Language-Haskell-Exts-QQ.html , expand to "haskell-src-exts-1.10.2:Language.Haskell.Exts.Syntax.Lit (haskell-src-exts-1.10.2:Language.Haskell.Exts.Syntax.Int 3)" instead of a ExpQ?
20:25:45 <elliott> hmm, how does that package differ from haskell-src-meta?
20:25:53 <elliott> oh wait
20:25:55 <elliott> it's the opposite
20:30:17 <sshc> Oh, maybe I could use that to convert haskell-src-exts ADT to template-haskell ADT
20:30:27 * sshc reads documnetation
20:30:41 <tgeeky> speaking of these things
20:30:42 <elliott> sshc: It's useful for parsing Haskell in quasiquotations, which turns out to suck because the error messages are bad and you can't nest quasiquotations
20:30:45 <sshc> Oh, hey, this is maintained by benmachine :)
20:30:59 <elliott> Is there an equivalent of IORef/STRefs that use Ints as the references
20:31:00 <elliott> oops
20:31:01 <tgeeky> is it possible to get quasiqoting defined on the tail end of the expression:
20:31:03 <elliott> Is there an equivalent of IORef/STRefs that use Ints as the references?
20:31:06 <elliott> It's OK if it only works in IO or similar.
20:31:08 <tgeeky> like [| ... |here]?
20:31:32 <elliott> I suppose I could use those fast IO-only hash tables to do it, but that has an unnecessary hashing step
20:31:45 <elliott> Although maybe Int has hash = id
20:32:01 <sshc> elliott: "It's useful for parsing…" What's "it" referring to here?
20:32:06 <elliott> sshc: haskell-src-meta
20:32:19 <Algo> how's haskell with parallelism?
20:32:27 <elliott> Algo: excellent
20:32:39 <tgeeky> Algo: .9 * n-cores
20:32:58 <tgeeky> or is that 1.9. I forget!
20:32:58 <elliott> I'd say it's more sqrt(1/cores) * Chaitin's constant
20:33:09 <elliott> + 9
20:33:40 <tgeeky> damn. you nerds! blessed art thou!
20:33:54 <tgeeky> so, quasiquoting and post-| syntax, possible?
20:34:05 <tgeeky> [| ... blah blah ... |here]?
20:34:08 <elliott> no
20:34:16 <tgeeky> implementable?
20:34:20 <elliott> you mean if you hack up GHC?
20:34:23 <tgeeky> yes
20:34:23 <elliott> sure
20:34:27 <elliott> don't see why not
20:34:28 <elliott> well
20:34:31 <elliott> except that [| starts splices
20:34:36 <elliott> infinite lookahead, yay!
20:35:13 <tgeeky> luckily i'll have a strict limit on how many tokens can be inside | .. |
20:35:34 <sshc> elliott: If 'hs' is a quasi quoter, how can "[hs| 3 |]" possibly expand to "Language.Haskell.Exits.Syntax.Lit foo" instead of "Q Expr"?
20:35:53 <Algo> elliott: What's that eq. you mentioned?
20:35:59 <elliott> Algo: ?
20:36:05 <tgeeky> Chaitin's constant
20:36:08 <sshc> (I'm using "hs" so that I can use variables whose names don't need to already be in scope (they will be soon after it is expanded))
20:36:08 <elliott> tgeeky: what's it for?
20:36:15 <Algo> elliott:  sqrt(1/cores) * Chaitin's constant
20:36:16 <elliott> sshc: I'm not sure I understand the question
20:36:26 <elliott> Algo: You mean what's Chaitin's constant?
20:36:49 <sshc> elliott: [| 3 |] expands to a value of type ExpQ (alias of Q Exp)
20:36:51 <elliott> http://en.wikipedia.org/wiki/Chaitin's_constant; it's the probability that a random program in a specified Turing-complete language will halt
20:36:58 <Algo> elliott: what is being calculated with the abovementioned equation
20:36:58 <elliott> sshc: quasiquotations can expand to any type they want
20:37:03 <sshc> elliott: [hs| 3 |], in the same context, should do the same?
20:37:09 <elliott> Algo: it's just a joke re: tgeeky
20:37:15 <elliott> sshc: nope
20:37:23 <elliott> sshc: as said, quasiquotations can expand to any type they want
20:38:03 <sshc> Oh.
20:38:25 <tgeeky> elliott: parsing documents with explicit text blocks
20:38:32 <sshc> elliott: Then are you aware of a way to quote something without requiring that the names already be in scope?
20:38:54 <elliott> sshc: I am not sure I understand. [foo| ... |] can expand to _literally_ any expression, and ... can be _literally_ any string (that does not include "|]").
20:38:59 <elliott> The quasiquoter is given the string as a parameter.
20:39:11 <elliott> [foo| ()ASDI)(WE<\<\<\<\ |] could expand to (99.0 >>= qwerty).
20:39:21 <Algo> elliott:  Oh, I see. tgeeky hehe... explain the joke?
20:40:34 <Algo> why is haskell more verbose than python
20:40:54 <sshc> elliott: Ah, okay.
20:41:14 <elliott> Algo: It isn't.
20:41:15 <elliott> Next question?
20:41:36 <sshc> elliott: Then is there a quasy quoter than behaves just like the default quoter (at least for expressions) but does not require variable names to be in scope?
20:42:12 <sshc> elliott: Specifically, I'm creating a top level decleration by passing a QExpr to a function that generates the Q [Dec]
20:42:27 <elliott> sshc: Try haskell-src-meta, but be aware that it uses a separate parser, and so may not handle some expressions, and its error messages suck. Additionally, you will not be able to quote any code with |] in it.
20:42:29 <elliott> So nesting is out.
20:42:37 <sshc> But the declaration hasn't be expanded yet.  I still need to refer to the names in the QExp
20:43:09 <sshc> Okay.  I've been searching for an answer for a while.  Thanks!
20:43:23 <elliott> sshc: Basically I think you should find another solution :)
20:44:15 <sshc> elliott: Wait, how do you suggest I try haskell-src-meta ?
20:44:26 <elliott> ?
20:44:31 <elliott> By installing it? :p
20:45:01 <sshc> elliott: Are you suggesting I use it to convert the expanded "[hs| foo |]", which expands to haskell-src-exts ADTS?
20:45:27 <Algo> What would I not want to use Haskell for?
20:45:39 <tgeeky> launching the missles
20:45:41 <elliott> Algo: Things you don't want to write.
20:45:43 <elliott> sshc: See http://hackage.haskell.org/packages/archive/haskell-src-meta/0.4/doc/html/Language-Haskell-Meta-Parse.html.
20:45:48 <elliott> sshc: You can make a trivial quasiquoter using parseExp
20:46:09 <Algo> elliott: how about high performance scientific computing?
20:46:19 <elliott> haskell s = case parseExp s of Left e -> error e; Right x -> return x
20:46:27 <elliott> With appropriate quasiquoter wrapping
20:46:28 <tgeeky> Algo: rather good place for that
20:46:33 <elliott> Algo: Sure, Haskell can do that.
20:46:42 <elliott> ?faq
20:46:43 <lambdabot> The answer is: Yes! Haskell can do that.
20:46:45 <kmc> @faq Can Haskell do high-performance scientific computing
20:46:46 <lambdabot> The answer is: Yes! Haskell can do that.
20:47:05 <kmc> Algo, it's possible to write very fast Haskell code (using GHC, the standard compiler) but it takes a lot of knowledge to do so
20:47:09 <elliott> Algo: It might even be a fairly good language to use, if you're allergic to Fortran.
20:47:16 <elliott> :p
20:47:21 <kmc> idiomatic code is usually not that fast
20:47:22 <elliott> (Being allergic to C is implicit.)
20:47:34 <kmc> though much better  than you'd expect if you come from the world of Python, Ruby, etc
20:47:37 <tgeeky> I get chives.
20:47:51 <elliott> kmc: Well, idiomatic code can be fast.
20:48:02 <elliott> kmc: It can involve specifically structuring your idiomatic code in a certain way, though :)
20:48:05 <sshc> elliott: I think I may be misunderstanding quasiquoters.  [| 3 |] expands to a value that has the type "Q Exp".  I expected [hs| 3 |] to expand to a value that has the type "Q Exp", too.
20:48:14 <kmc> Haskell provides a good range between "get the code written quickly" and "spend many hours optimizing the critical parts"
20:48:17 <elliott> sshc: The two syntaxes are basically unrelated.
20:48:18 <sshc> elliott: But does the latter actually expand again to the expression?
20:48:30 <elliott> sshc: What the latter does depends entirely on the behaviour of the hs quasiquoter.
20:48:34 <Algo> elliott: in high performance scientific computing, one has to utilize infiniband, if you don't, you fail
20:48:35 <elliott> I have never used the package; I cannot speak for its behaviour.
20:48:36 <kmc> elliott, yeah, but anyway you need a lot of knowledge
20:48:50 <elliott> You could easily have [qoop| asdfq |] :: IO (ST (Int,Float)).
20:49:03 <kmc> other than the kind error ;P
20:49:07 <elliott> It is literally just an application of a transformer from a string to an expression (or even a pattern or type -- quasiquoters can be used in multiple concepts).
20:49:12 <elliott> multiple contexts
20:49:24 <elliott> Algo: Are you a troll or a bot?
20:49:33 <Algo> elliott: No, I'm not
20:49:39 <tgeeky> can't he be both?
20:49:46 <elliott> tgeeky: It was a non-exclusive or.
20:49:46 <Algo> One has to also utilize gpus
20:49:55 <elliott> Algo: you need to be web scale. Haskell isn't web scale.
20:49:55 <kmc> you can do that from Haskell
20:50:22 <sshc> Okay, I understand.  I was mistaken.
20:50:52 <Algo> elliott: Web scale... meaning?
20:51:07 <kmc> Algo, http://hackage.haskell.org/package/cuda http://hackage.haskell.org/package/accelerate http://www.reddit.com/r/haskell/comments/dl3iv/nikola_array_computations_embedded_in_haskell/
20:51:24 <kmc> Algo, also read about "data parallel haskell".  there's a good talk on it by SPJ as well
20:51:38 <elliott> Algo: Web scale means ready for Web 3.0.
20:53:05 <sshc> elliott: To clarify any misunderstanding, the goal is to quote an expression, like [| 3 + n |], *except* 'n' doesn't need to be in scope ('n' will be declared immediately after the expression is expanded; it needs to be expanded before GHC expands the Q [Dec]).  How do you suggest I do this?
20:53:13 <kmc> i'm not sure i accept all of Algo's premises though
20:53:17 <elliott> sshc: I suggest you find a way not to do that.
20:53:30 <elliott> sshc: I'm honestly not sure if it can be done with TH without using a separate Haskell parser.
20:53:36 <elliott> i.e. haskell-src-meta.
20:53:50 <kmc> many tasks would qualify as 'high-performance scientific computing' and still not require particularly fast inter-node communication
20:54:03 <kmc> prototypically, monte carlo simulation
20:54:10 <kmc> you don't need infiniband for such tasks
20:54:39 <elliott> kmc: But infiniteband and GPUs are web scale :(
20:54:44 <kmc> ;P
20:54:49 <Algo> kmc: Which ones?
20:54:50 <kmc> 'infiniteband' lol
20:54:57 <kmc> Algo, i just named one
20:55:15 <kmc> rather, a large class of them
20:55:25 <kmc> if you're doing monte carlo simulations and each one fits within a node
20:55:30 <kmc> they do not particularly need to talk to each other
20:55:34 <kmc> you just accumulate some statistics later
20:56:12 <kmc> you might still need thousands of nodes
20:56:15 <kmc> because you want a large sample size
20:56:19 <kmc> but they don't have to talk to each other
20:56:36 <Algo> kmc: yeah i guess only some need it but w/o it, it won't catch on in that domain
20:56:48 <kmc> true
20:57:04 <kmc> i don't know any way to use Haskell with infinband, other than TCP over IP, which is obviously non-optimal
20:57:18 <kmc> however it shouldn't be that hard to implement
20:58:02 <kmc> Algo, there are mpi bindings on hackage by the wya
20:58:04 <kmc> way*
20:58:26 <kmc> Algo, what's the context? why are you interested in Haskell, Infiniband, etc?
20:58:29 <Algo> kmc: Neat, thanks
20:58:57 <Algo> kmc: Just a lil' curious about Haskell that's all
20:59:09 <kmc> :)
20:59:21 <kmc> it's a very cool language
20:59:28 <Algo> Yeah, agreed
21:03:03 <pedro3005> ok I'm sure I'm doing something dumb
21:03:17 <pedro3005> > foldl (\x acc -> if (mod x 2) == 0 then x + acc else acc) 0 [1..10]
21:03:18 <lambdabot>   10
21:03:40 <pedro3005> but why doesn't this equal to 2 + 4 + 6 + 8?
21:03:56 <kmc> :t foldl
21:03:58 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
21:03:59 <parcs> the accumulator is thee first parameter
21:04:04 <kmc> you have the args backwards
21:04:09 <kmc> > foldl (\acc x -> if (mod x 2) == 0 then x + acc else acc) 0 [1..10]
21:04:10 <lambdabot>   30
21:04:34 <pedro3005> ah lol
21:10:00 * ski . o O (let ((let '`(let ((let ',let)) ,let))) `(let ((let ',let)) ,let))
21:20:33 <MaskRay> How does runST's type signature prevent a reference (STRef s a) from one thread being used in another thread?
21:21:03 <elliott> MaskRay: It binds the s "differently".
21:21:23 <elliott> Basically there is no way to unify (STRef s0 a) with (STRef s1 a) from another thread.
21:21:57 <MaskRay> i.e. runST's type signature prevent such usage: runST (newSTRef 0)
21:22:22 <Eduard_Munteanu> Yes, it will complain the 's' escapes.
21:22:25 <ski> using an `STRef s0 a' in an `ST s1'-action will ensure that `s0' is equal to `s1'
21:23:13 <ski> and you can only run `runST' on a polymorphic action of type `forall s. ST s a'
21:23:32 <MaskRay> runST (newSTRef True) has such type signature: (forall s. ST s (STRef s Bool)) -> STRef s Bool
21:23:45 <ski> having two actions of types `ST s0 a' and `ST s1 b' where `s0' and `s1' are fully general, except that they are equal doesn't suffice
21:25:00 <MaskRay> ski: because the last `s' escapes the scope of `forall s'?
21:25:03 <ski> MaskRay : `forall s. ST s a' doesn't match `forall s. ST s (STRef s Bool)', since `STRef s Bool' depends on `s' (`a' in `forall s. ST s a' doesn't depend on `s')
21:25:26 <ski> MaskRay : you could express the failure to match in that way, yes
21:25:54 <MaskRay> ski: you mean one type variable should not depend on another?
21:26:14 <ski> it can't depend on another, no
21:26:35 <ski> Haskell has only explicit dependencies, at both expression and type level
21:26:58 <ski> (the implicit parameters extension is an exception to this, though)
21:27:35 <Eduard_Munteanu> But they're still explicit dependencies.
21:27:37 <ski> MaskRay : the only way a type `tau' can depend on a type variable `a' is for the type variable `a' to actually occur (freely) in `tau'
21:27:37 <kmc> (s0 ~ s1) => (ST s0 a, ST s1 a)
21:29:16 <MaskRay> ski: can you come up with an example to illuminate that?
21:29:25 <ski> `Maybe a' depends on `a'
21:29:27 <ski> `a' depends on `a'
21:29:31 <ski> `(a,b)' depends on `a'
21:29:40 <ski> `forall a. (a,b)' doesn't depend on `a'
21:29:48 <ski> `(b,b)' doesn't depend on `a'
21:30:58 <ski> MaskRay : do you know Leibniz notation for derivatives ?
21:32:02 <MaskRay> ski: no. i am reading  Lazy Functional State Threads and can't understand section 2.4 (about runST (newVar Bool))
21:32:48 <Eduard_Munteanu> df/dx, in case you don't know how that's called.
21:33:20 <ski> Eduard_Munteanu : actually, `d y / d x' :)
21:34:26 <Eduard_Munteanu> Erm, I meant in the sense of d / dx * f(x) = f'(x)
21:35:08 <Eduard_Munteanu> Sure y would be a general way to say f applied to its argument.
21:37:05 <ski> (.. i really dislike that people are taught to write nonsense like `d f / d x')
21:37:49 <MaskRay> perhaps i need to skip this section
21:38:04 <ski> MaskRay : what is it that you don't understand ?
21:38:55 <Eduard_Munteanu> ski: why? It's quite normal to write stuff like   df = \partial f / \partial x * dx + \partial f / \partial y * dy ...
21:39:15 <Eduard_Munteanu> So if it makes sense there, why not here...
21:39:27 <elliott> It's not like Leibniz notation makes much sense anyway.
21:40:46 <ski> Eduard_Munteanu : it is a part of confusing a function with the value of the function at a specific input
21:40:48 <MaskRay> ski: `forall s. ST s a' doesn't match `forall s. ST s (STRef s Bool)'
21:41:38 <ski> Eduard_Munteanu : afaiac, `d <expr> / d <var>' is a macro for `D (\<var> -> <expr>) <var>'
21:42:26 <deech> Hi all, I have an OO Javascript GUI library (Qooxdoo) for which I want to write Haskell bindings. I've never done anything like this before and Gtk2HS is the only other project I can find that has done this. Is their design worth copying or is there a better way?
21:42:35 <elliott> ski: do you also object to f+g for the obvious?
21:42:43 <ski> MaskRay : the way to think about `s' in `forall s. ST s (STRef s Bool)' is that in some sense, `s' doesn't really exist outside of the `forall s. ...'
21:42:44 <elliott> it strikes me as merely abstraction.
21:42:47 <Eduard_Munteanu> ski: in a sense dy / dx isn't really consistent too, since the derivate should be a function.
21:43:03 <Eduard_Munteanu> s/too/either/
21:43:10 <ski> MaskRay : note that `forall s. ST s (STRef s Bool)' is the *same* type as `forall t. ST t (STRef t Bool)', e.g.
21:43:18 <elliott> deech: Unless you have an FFI to a Javascript implementation which runs Qooxdoo or a Haskell to Javascript compiler, you will have to generate code that uses the UI library rather than using it directly...
21:43:20 <MaskRay> ski: is it because `a' should be a rigid type but `forall' provides a polymorphic one?
21:43:35 <elliott> Qooxdoo looks like an in-browser thing. So you don't have an FFI unless you want to create a browser extension or something.
21:43:44 <elliott> And I don't think there is any maintained Haskell -> JS compiler now that Yhc is dead.
21:44:07 <elliott> So I'd say you don't have any opportunity of using qooxdoo from anything but, say, Javascript or Coffeescript or similar.
21:44:36 <deech> elliott: I was thinking more along the lines of simply having Haskell code generate Javascript the same way Yesod uses Haskell to generate HTML.
21:44:39 <ski> MaskRay : assume that we try to match `forall s. ST s (STRef s Bool)' with `forall s. ST s a', yielding the solution `a = STRef s Bool'
21:45:03 <elliott> deech: Right.
21:45:18 <elliott> deech: Well, you won't be able to write your logic in Haskell at all, so your client-side logic will be awkward.
21:45:27 <elliott> Unless you're doing absolutely everything via AJAX?
21:45:32 <ski> MaskRay : now, since `forall s. ST s (STRef s Bool)' is the same type as `forall t. ST t (STRef t Bool)', and since `forall s. ST s a' is the same type as `forall t. ST t a', we should get the same result if we match these alternate spelling forms of the two types
21:45:33 <MaskRay> ski: so we can rewrite the type signature `(forall s. ST s (STRef s Bool)) -> STRef s Bool' as `(forall t. ST t (STRef t Bool)) -> STRef s Bool' and the last `s' in the latter is not specified?
21:45:57 <ski> MaskRay : allowing that match would give us `a = ST t Bool'
21:46:14 <deech> elliott: Yes I want to do everything via AJAX. This is what Qooxdoo was meant for. I was wondering how to design a nice Haskell wrapper around a very OO library.
21:46:26 <ski> MaskRay : but `a = ST s Bool' and `a = ST t Bool' are completely different type assignments
21:46:39 <elliott> deech: I'd say that can only get so nice since there's an inherent impedance mismap.
21:46:55 <elliott> deech: You could make a low-level library then build a more declarative UI description language on top, or you could just bite the bullet and do it Gtk2Hs style.
21:47:02 <Eduard_Munteanu> MaskRay: contrast forall s a. ST s a   with    forall s. ST s a
21:47:31 <ski> MaskRay : if e.g. we know `s = Int' and `t = Double', then allowing this would allow us to prove `Int = Double', generally it would allow us to convert from any type to any other type, breaking type checking
21:48:03 <deech> elliott: Ah, you've confirmed my suspicions that Gtk2Hs is about as elegant as it gets when mixing functional and OO.
21:48:05 <Eduard_Munteanu> (assuming no implicit quantification)
21:48:15 <ski> Eduard_Munteanu : `d f(x) / d x' is not a function. `x |-> d f(x) / d x' is a function
21:49:02 <MaskRay> ski: i see
21:49:02 <ski> elliott : i consider `f + g' a case of overloading (i'm not really happy about it, but i accept it, yes)
21:49:18 <elliott> deech: Well, I'm no expert in the field, but I've looked briefly at Gtk2Hs and it seems to make the best of a bad situation.
21:49:25 <elliott> ski: It's just a higher-order instance. :)
21:49:29 <Eduard_Munteanu> ski: yep, but it's also not uncommon to write   f'(x_0) = (df / dx)(x_0)
21:49:39 <elliott> deech: HOC is ugly as all sin for instance (old Objective-C/Cocoa binding).
21:50:33 <ski> MaskRay : so, because `s' doesn't "exist" outside `forall s. ...' in `forall s. ST s (STRef s Bool)', it is impossible to match that with `forall s. ST s a', since doing so would make `a' into a type which contained `s', now outside of any binder (like `forall' or `exists')
21:51:21 <deech> elliott: Hmmm... sounds like I'm going to have to endure some ugliness :). Maybe Oleg's "Haskell Overlooked Object System" can help.
21:51:48 <elliott> deech: Personally, I'd just make a low-level "un-Haskelly" binding, then build a nice declarative UI builder on top that uses the low-level library.
21:51:58 <elliott> But that's more work, of course, and further from the native library.
21:52:21 <Eduard_Munteanu> wxHaskell might also be nice to have a look at, since it binds to C++ code. (AFAIK)
21:52:36 <ski> Eduard_Munteanu : iiuc, it is in some cases possible to define some kind of derivatives over function spaces, with expressions `d F(f) / d f', this i think is quite fine
21:52:36 <deech> elliott: Will do. Thanks for the input!
21:52:50 <MaskRay> ski: i think this topic is related to rank-n types. could you suggest an article on it?
21:53:06 <ddarius> ski: Yes, that's the calculus of variations.
21:53:09 <elliott> deech: No problem :)
21:53:26 <Eduard_Munteanu> That sounds interesting.
21:54:33 <Eduard_Munteanu> I wonder what one needs on the underlying set... a normed vector space is enough?
21:55:17 <Eduard_Munteanu> Wait, it needs to be complete too I guess.
21:55:53 <elliott> <Eduard_Munteanu> wxHaskell might also be nice to have a look at, since it binds to C++ code. (AFAIK)
21:55:58 <elliott> gobject is arguably a nicer object system than c++
21:55:58 <elliott> :P
21:56:16 <Eduard_Munteanu> Yeah, I don't use wxHaskell :)
21:57:41 <ddarius> Eduard_Munteanu: Hence Banach spaces.
21:58:24 <Eduard_Munteanu> Yeah. I guess that's enough, no caveats there.
21:58:44 <ski> Eduard_Munteanu : in the `f + g' case, we're defining (e.g.) a derived abelian group structure on indexed families. i don't see why it would be natural to only "raise" one side of `d y / d x' to functions, though
22:00:10 <Eduard_Munteanu> I see.
22:01:42 <Eduard_Munteanu> Well, maybe another way to look at it is  D f t = (d / dt) f   essentially regarding d/dt as an operator
22:02:10 <xil> hi again. Is it possible to have nested guards? I'm getting a parse error but I believe I saw some code once that had nested guards such that the nested levels were just indented further
22:02:19 <ski> (similarly, i think saying  D (x^2)  or  (x^2)'  is nonsense, while  D sin x^2  is just fine (provided you interpret the applications left-associated as in Haskell))
22:02:25 <Eduard_Munteanu> (kinda fits in with  d^n f / (d x)^n)
22:02:40 <ski> Eduard_Munteanu : `d / d t' is a binding construction, it's not a first-class value
22:02:47 <ddarius> Either d/dx is a binding construct "taking" an expression, thus df(t)/dt, another expression, or use D f, taking a function to a function.
22:03:04 <ddarius> (or more generally to a field of linear transformations)
22:03:20 <ski> Eduard_Munteanu : compare with how `\x -> ' (or mathy `x |-> ') cannot be said to be a function
22:04:14 <Eduard_Munteanu> Admittedly   D f t   isn't nice either since variables might be renamed, no?
22:04:19 <Eduard_Munteanu> s/might/can/
22:04:33 <ski> Eduard_Munteanu : no bound variables in `D f t' :)
22:04:52 <ski> you can of course say `D (\x -> ..x..) t' if you like
22:05:03 <Eduard_Munteanu> Yeah.
22:05:06 <ski> (or `D (x |-> ..x..) t' with a more mathy notation)
22:05:21 <ddarius> Which is basically what Structure and Interpretation of Classical Mechanics does.
22:05:37 <Eduard_Munteanu> Can't we basically lift a function into an "expression space"?
22:06:20 <Eduard_Munteanu> say   lift('f(t)') makes it clear it's not an application but just spelling it out with those variable names.
22:06:26 <ski> Eduard_Munteanu : that is a meta-language notion
22:07:42 <ski> semantically speaking, `f(x)' and `x |-> f(x)' in some sense refers to the "same" semantic object, but syntactically they are very different -- and with good reason
22:08:22 <ski> `f(x)' focuses on the result value on evaluating the expression, while `x |-> f(x)' focuses on the function as a value in itself
22:09:04 <ski> this difference is similar to the difference between a pair of expressions `e0',`e1', and the expression `(e0,e1)'
22:09:06 * ddarius doesn't see them as referring to the same semantic object at all.
22:09:17 <ddarius> One refers to f, the other to its result.
22:09:33 <ski> note the "in some sense" :)
22:09:36 <Eduard_Munteanu> ddarius: the first one has x free
22:09:51 <ddarius> I still wouldn't consider them the same.
22:09:52 <Eduard_Munteanu> If that's the case it's quite similar.
22:10:45 <Eduard_Munteanu> (the second one has 'x' free as well, but only to the left of '|->')
22:10:51 <ski> given e.g. a categorical semantics, we have that `[| Gamma,x : tau_0 |- f(x) : tau_1 |]' is *isomorphic* to `[| Gamma |- (x |-> f(x)) : tau_0 -> tau_1 |]'
22:11:17 <ski> which is what i meant by "in some sense the \"same\""
22:11:49 <ski> Eduard_Munteanu : the `x' to the left of `|->' is a binding occurance
22:12:13 <Eduard_Munteanu> Ah, like in a lambda you mean.
22:12:36 <ski> yes, i use `x |-> ..x..' just like a lambda abstraction
22:12:39 <ddarius> It's just a different notation for lambda.
22:12:44 <ski> *nod*
22:13:48 <ddarius> (also like in integrals, series, derivatives, products, unions, intersections, sequences, ...)
22:14:43 <Eduard_Munteanu> That makes me wonder if there is a sort of "co" lambda calculus syntax where those aren't binding but actual free variables. Looks like lambdas "choose" variable names, not callers.
22:14:49 <Eduard_Munteanu> Maybe it's not terribly useful though.
22:15:15 <ski> (btw, the difference between "total derivative" and "partial derivative" is due to allowing variables to depend on other, and the resulting ambiguity on when the dependency is resolved)
22:15:53 * Eduard_Munteanu is unsure about total derivatives, generally speaking...
22:16:12 <Eduard_Munteanu> I remember there are quite a few different notions of those.
22:17:20 <ski> Eduard_Munteanu : yes, if you want to allow general patterns `<pat>' in `<pat> |-> <expr>' then you either need a convention for establishing which variables in `<pat>' (and `<expr>') are to be bound by the abstraction, or you need to have an explicit annotation telling which variables are bound
22:17:26 <ski> (afaiui)
22:20:46 <DukeDave> I have [(a,a)] and I want to filter based on a, but when there is a match I would like to return the other a to the matched one. I'm thinking there might be a clever monad plus way to do it?
22:21:36 <Eduard_Munteanu> Now that you mention it, say I mean    f = \a b -> g (a + b)  where  g = \(a + b) -> a + b + 1       while something like f = \t u -> ...  wouldn't work.
22:21:56 <DukeDave> So: "Does the fst match? Yes return snd, no return mzero; does snd match? Yes return fst, no return mzero; return mzero.
22:22:39 <Saizan> DukeDave: [ b | (a,b) <- xs , match a ] ?
22:23:17 <DukeDave> Saizan: Yes, I want to return a if (match b)
22:23:33 <DukeDave> *Yes but I
22:23:56 <Saizan> oh, i see
22:24:19 * hackagebot hack2-handler-mongrel2-http 2011.6.25 - Hack2 Mongrel2 HTTP handler  http://hackage.haskell.org/package/hack2-handler-mongrel2-http-2011.6.25 (JinjingWang)
22:24:21 <DukeDave> The list is a list of edges in a directed graph you see, and I want to return the vertex the edge points to
22:24:40 <DukeDave> But each edge could be incoming or out going
22:24:47 <Saizan> with more mplussing it should work
22:24:49 <Eduard_Munteanu> Isn't that like returning them swapped if the whole thing matches, mzero otherwise?
22:25:16 <ski> Eduard_Munteanu : assume `y = g x', making `y' a variable dependent on `x', then consider `d f (x,y) / d x'
22:25:26 <DukeDave> Eduard_Munteanu: Well I don't want the matched component of the tuple, I want the 'other' one
22:25:55 <DukeDave> Something :: [(a,a)] -> a -> [a]
22:26:30 * DukeDave thinks he needs to use 'guard'
22:27:41 <Eduard_Munteanu> ski: chain rule?
22:27:49 <ski> Eduard_Munteanu : if we're interpreting this as a total derivative, that means that we interpret `d f (x,y) / d x' as `d (let y = g x in f (x,y)) / d x', i.e. `d f (x,g x) / d x', meaning that "contributions to `y' via `x' are counted", so `d y / d x' are not treated as zero per definition
22:28:55 <Eduard_Munteanu> Ah.
22:29:44 <ski> Eduard_Munteanu : if we're instead interpreting this as a partial derivative, that means that we interpret `d f (x,y) / d x' as `let y = g x in d f (x,y) / d x' where the `y' in the body of the `let' is *not* dependent (on `x'), so now `d y / d x' is zero, inside that body. this is commonly written as `(d f (x,y) / d x) |_{y = g x}'
22:32:05 <Eduard_Munteanu> How's this usually dealt with in math notation? I suspect by introducing a parametrization of f describing the intended path and working with that, no?
22:32:11 <ski> Eduard_Munteanu : if we're creating type derivations for these two interpretations of `d f (x,y) / d x', we'll note that they differ in the order they apply two inference rules, but only one of them (the one introducing the `d ... / d x' construct) is leaving any trace in the expression being typed. the other rule (the "fix the dependency now/here"-rule) only affects whether the free variables of the expression are being considered to be depend
22:33:39 <Eduard_Munteanu> Hm, interesting way to put it.
22:34:18 <ski> Eduard_Munteanu : i'm not fully sure, but afai have seen, there's only notations for the two extremesm, fully total (using `d') resp. fully partial (using a "di"/"de"-symbol). as soon as you introduce more than a single dependency between variables, there are intermediate stages
22:34:33 <ski> (total wrt this variable and partial wrt that, &c.)
22:35:31 <Eduard_Munteanu> I'm not sure I've seen stuff like df(x,y)/dx   (total 'd'), at least not commonly.
22:35:54 <ski> Eduard_Munteanu : glad you like it. i've labourishly figured it out myself :)
22:35:57 <Eduard_Munteanu> Usually they go around that and use the differential.
22:36:15 <Eduard_Munteanu> ski: neat... do you blog? :)
22:36:30 <ski> i don't
22:36:34 <ski> (i IRC)
22:36:44 <Eduard_Munteanu> Heh.
22:37:36 <DukeDave> Well I got it, but it ain't pretty:
22:37:39 <DukeDave> >[(2,3), (4,2), (1,5)] >>= (\x -> (if 2 == fst x then return $ snd x else if 2 == snd x then return $ fst x else mzero))
22:37:48 <DukeDave> > [(2,3), (4,2), (1,5)] >>= (\x -> (if 2 == fst x then return $ snd x else if 2 == snd x then return $ fst x else mzero))
22:37:49 <lambdabot>   [3,4]
22:41:22 <ski> Eduard_Munteanu : generally, the thing to look out for in `d <expr> / d <var>' wrt total/partial derivatives is : for any variables occuring (literally and freely) in `<expr>', if they are dependent on `<var>', then should we count "contributions from `<var>' to the whole derivative" via *this* variable or not ?
22:41:43 <NemesisD> anyone know the legalities of using the haskell logo or a variation thereof in a website layout (a blog, to be specific)
22:41:44 <ski> (and variable dependency is of course reflexive and transitive)
22:42:46 <ski> > [(2,3), (4,2), (1,5)] >>= \(x,y) -> if 2 == x then return y else if 2 == y then return x else mzero
22:42:47 <lambdabot>   [3,4]
22:45:11 <ski> DukeDave : what if there's a pair `(2,2)' in the list. do want to get `2' two times, then ?
22:45:53 <fragamus> :t lift
22:45:54 <lambdabot>     Ambiguous occurrence `lift'
22:45:54 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
22:45:54 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
22:46:09 <ski> @type Control.Monad.Trans.lift
22:46:09 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Error.MonadTrans t, Monad m) => m a -> t m a
22:46:17 <ski> @type Control.Monad.Logic.lift
22:46:18 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Logic.MonadTrans t, Monad m) => m a -> t m a
22:46:34 <fragamus> uh which one is the one i mean?
22:46:35 <ski> @type Control.Monad.Error.lift
22:46:36 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Error.MonadTrans t, Monad m) => m a -> t m a
22:46:50 <ski> fragamus : uh, i dunno. which of them do you mean ?
22:46:54 <ski> ;)
22:46:54 <DukeDave> ski: Well, such an occurrence would erroneous in my case, so I don't really care :)
22:47:23 * ski wonders why there's ambiguity, above ..
22:47:43 <DukeDave> ski: But I do like your version more
22:47:51 <ski> DukeDave : well, the above is a simplification (more or less) of what you wrote
22:47:58 <fragamus>   lift $ print (x,y)
22:48:00 <DukeDave> ski++
22:48:07 <fragamus> which one is that ^^^
22:48:45 <ski> > [z | (x,y) <- [(2,3), (4,2), (1,5)] , (2,z) <- [(x,y),(y,x)]]
22:48:46 <lambdabot>   [3,4]
22:48:51 <ski> that's yet another way
22:49:22 <identity_> ski: ooh, nifty
22:49:30 <ski> presumably what you want to use instead of `2' is a variable, which requires using a guard there, so
22:49:40 <ski> > [z | (x,y) <- [(2,3), (4,2), (1,5)] , (w,z) <- [(x,y),(y,x)] , w == 2]
22:49:40 <lambdabot>   [3,4]
22:50:12 <ski> this version with `[(x,y),(y,x)]' will generate `n' two times if you're looking for `n' and there's an `(n,n)' in the list
22:50:13 <Eduard_Munteanu> > let toList (x,y) = [x,y] in filter (filter (2 == . toList)) [(1,2), (2,2), (1,1)]
22:50:14 <lambdabot>   <no location info>: parse error on input `.'
22:50:19 <ski> (unlike the previous versions)
22:50:22 <Eduard_Munteanu> > let toList (x,y) = [x,y] in filter (filter ((2 ==) . toList)) [(1,2), (2,2), (1,1)]
22:50:23 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
22:50:23 <lambdabot>         against inferred type ...
22:50:29 <Eduard_Munteanu> Ah crap :)
22:50:38 * Eduard_Munteanu needs sleep
22:53:25 <ski> > catMaybes ((`map` [(2,3), (4,2), (1,5)]) $ \(x,y) -> if 2 == x then Just y else if 2 == y then Just x else Nothing)
22:53:26 <lambdabot>   [3,4]
22:53:42 <ski> DukeDave : ^ a small variation on the earlier version
22:57:32 <DukeDave> ski: Ah yes :)
23:38:13 <ski> > [isControl,isMark,isPrint,isPunctuation,isSeparator,isSpace] `flip` '\SP'
23:38:14 <lambdabot>   [False,False,True,False,True,True]
23:39:53 <elliott> > [isControl,isMark,isPrint,isPunctuation,isSeparator,isSpace] '\SP'
23:39:54 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
23:40:00 <elliott> hmm
23:40:03 <elliott> :t (`flip`)
23:40:04 <lambdabot> parse error on input `)'
23:40:07 <elliott> darn :)
23:40:13 * ski grins
23:40:42 <ski> @type (flip . flip) flip
23:40:43 <lambdabot> forall a (f :: * -> *) b. (Functor f) => f (a -> b) -> a -> f b
23:40:51 <elliott> Caleskell strikes again
23:41:06 <elliott> oh wait, in this case you are actually using caleskell :)
23:41:09 <ski> actually, i'm to blame for that one :)
23:41:12 <elliott> ... caleskell strikes again
23:41:25 <ski> (i suggested that one as an addition)
23:42:01 <elliott> ski: bah, you're just a member of the bureaucratic Caleskell Committee
23:42:17 * sanjoyd just found this: http://www.haskell.org/haskellwiki/Real_World
23:42:19 <elliott> dedicated to making sure every Haskell type signature has at _least_ one kind declaration
23:42:23 <ski> me bureaucratic ?
23:42:58 <ski> heh, what do you even mean by that ? :)
23:43:09 <elliott> as in "forall ...  (f :: * -> *)"
23:43:31 <ski> oh
23:43:54 <ski> like how `forall a. [a] -> Int' is really short for `forall (a :: *). [a] -> Int' ?
23:43:59 <elliott> yeah :-)
23:44:11 <elliott> :t map
23:44:11 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
23:44:13 <elliott> :t (.)
23:44:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:44:16 <elliott> :t flip (.)
23:44:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
23:44:25 <elliott> hmm, was expecting a more fun result
23:44:27 <elliott> :t (.flip)
23:44:27 <lambdabot> forall b (f :: * -> *) a b1. (Functor f) => ((a -> f b1) -> b) -> f (a -> b1) -> b
23:44:35 <elliott> there we go, clarity of caleskell revealed
23:44:45 <ski> hahaha
23:45:59 <ski> actually i think when it outputs types it should omit the kind signatures for the quantified type variables, when they can be inferred from the occurances in the type expression (including using defaulting to `*', as usual)
23:46:29 <elliott> ski: we'll need a lot more of them with typekinds!
23:46:56 <dibblego> is there a more useful library than time?
23:47:22 <elliott> dibblego: <snark>old-time</snark>
23:47:25 <elliott> ...<snark>
23:47:52 <elliott> can't leave the snark off for too long.
23:47:52 <ski> also, i think it shouldn't display `forall's at all, unless you've (either implicitly or explicitly) enabled `ExplicitForall', or you're using some feature like `Rank2Types' or `RankNTypes' or `PolymorphicComponents' where outputting `forall' is required for correctness (and only then in those places)
23:48:02 <dibblego> surely someone has thought to themselves, "this is nonsense, let me fix it"
23:48:08 <elliott> wow, I have never even heard of PolymorphicComponents before
23:48:12 <elliott> dibblego: yes, you just have, go fix it :D
23:48:20 <dibblego> dammit, I'm busy
23:48:54 <dibblego> I'll just make a type-class and defer it
23:49:06 <elliott> i've found the time package to be a wee bit inconsistent-feeling and overengineered, personally
23:49:09 <Enigmagic> dibblego: i got about 10% of the way there :P
23:50:02 <ski> elliott : `PolymorphicComponents' is what exactly enables e.g. such shining gems such as `newtype Yoneda f a = UnLowerBind (forall b. (a -> b) -> f b)'
23:50:16 <elliott> ski: doesn't RankNTypes enable that?
23:50:21 <ski> it's also enabled by `Rank2Types' and `RankNTypes'
23:50:25 <elliott> or ExistentialQuantification. I just turn extensions on until the compiler accepts my code...
23:50:30 <elliott> this usually ends badly
23:50:39 <ski> no, `ExistentialQuantification' is something else
23:50:43 <elliott> right
23:50:48 <elliott> I meant RankNTypes
23:51:47 <ski>   newtype CoYoneda f b = forall a. LiftFMap (a -> b) (f a)  -- is `ExistentialQuantification'
23:52:04 <elliott> right
23:52:05 <elliott> wrong side :)
23:52:50 <ski> `CoYoneda IORef' is interesting in that it's a functor
23:53:27 <ski> (well, `CoYoneda f' is a functor for any type function `f', but seeing as `IORef' is not a functor, that's an interesting example)
23:53:47 * cmccann just adds {-# LANGUAGE AndTheKitchenSinkToo #-} at the top of every source file
23:54:43 <Snark> elliott, what?
23:55:23 * ski peers curiously at Snark
23:56:12 <elliott> Snark: not my fault your name is a word
23:56:46 <elliott> Is there a tool available to count the number of packages that depend on a certain package in Hackage?
23:56:53 <elliott> It'd be useful to decide between two alternative packages to do the same thing.
23:58:15 <cmccann> there's a site somewhere that shows reverse dependencies for Hackage
23:58:16 <cmccann> with counts
23:59:42 <ski> <http://hackage.haskell.org/trac/hackage/ticket/576>
