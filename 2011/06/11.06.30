00:24:22 <houeland> Are there any good HTTP libraries that can do persistent connections correctly, preferably pipelining as well?
00:42:19 <Phyx-> lol, IE flags ghc as unsafe
00:42:47 <Phyx-> default actions are "Do not run this program" and "Delet file"
00:43:38 <Saizan> you mean the installer?
00:43:42 <Phyx-> yeah
00:44:42 <Phyx-> It's probably because i'm on a windows server atm and the ghc installer isn't signed
00:47:07 <Arafangion> Isn't that /normal/?
00:47:40 <Phyx-> I don't run into it that often, since I rarely download unsigned files on that machine
00:49:57 <Phyx-> lol, cabal won't install on 7.0.4
00:50:04 <Phyx-> minor version change in base
00:51:08 <Phyx-> can you override the base dependency via the commandline? or do i have to unpack and edit the file?
00:53:28 <Phyx-> odd.. the dependency is just base < 4
00:53:47 <Jafet> What
00:53:59 <Jafet> Which cabal(-install) are you attempting to install?
00:54:17 <Phyx-> 1.10.2 i think, just latest on hackage
00:54:35 <Phyx-> but it failed saying couldn't satisfy base == 4.3.0.0
00:54:55 <Phyx-> but calling it again and it's installing :/
00:57:10 <Jafet> What are the dependencies listed in the cabal file, I wonder?
00:57:41 <Phyx-> it says
00:57:43 <Phyx-> Library build-depends:   base       >= 2   && < 5,
00:57:55 <Phyx-> but when i try to install i get
00:58:09 <Phyx-> setup.exe: At least the following dependencies are missing:
00:58:10 <Phyx-> base ==4.3.0.0, process ==1.0.1.4
00:59:07 <Jafet> What's the output of ghc-pkg list?
00:59:25 <Jafet> Perhaps your packages are broken somewhere
00:59:41 <Phyx-> for base 4.3.1.0 and process 1.0.1.5
00:59:48 <Phyx-> it's a brand new install
00:59:53 <Phyx-> literally 5 mins old
01:00:07 <Phyx-> ghc-pkg check returns nothing
01:00:12 <Jafet> 10 minutes, but right
01:00:28 <Phyx-> details :P
01:01:54 <Phyx-> the package i really want to install says
01:01:55 <Phyx-> There is no available version of ghc that satisfies >=6.12 && <7.0 || >=7.0.2
01:02:37 <Saizan> do you have another installation of ghc, perhaps?
01:02:37 <Jafet> Wait… isn't GHC always distributed with Cabal?
01:02:50 <Jafet> Cabal is 1.10.2, but cabal-install is 0.10.2.
01:03:02 <Jafet> You're installing the latter, I presume.
01:03:52 <Phyx-> Jafet: I didn't check the version of cabal that comes with ghc, but cabal-install can't be installed easily because it requires network
01:04:01 <Phyx-> Saizan: I have multiple, but only 1 on my path
01:04:05 <Saizan> if cabal calls setup.exe with base == 4.3.0.0 when you have 4.3.1.0 there's something fishy
01:04:37 <Saizan> Phyx-: maybe you changed your path only for your current shell but cabal sees another?
01:06:04 <Saizan> try passing the ghc path explicitly: cabal install -w /path/to/ghc foo
01:06:08 <Phyx-> Saizan: no, I changed it globally. just opened a new cmd prompt and it's correct in the default. Doesn't cabal install just invoke the ghc-pkg on your path? which in my case picks the right 7.0.4 install
01:06:22 <Saizan> yes, it does
01:06:56 <Phyx-> i'll just dl the prebuild cabal-install
01:07:57 * hackagebot explicit-sharing 0.9 - Explicit Sharing of Monadic Effects  http://hackage.haskell.org/package/explicit-sharing-0.9 (SebastianFischer)
01:08:01 <Phyx-> that seems to do just fine :)
01:12:08 <Phyx-> question, does Cabal have a depth to which it'll resolve dependencies? It often seems to failed on the dependencies of a dependency
01:12:28 <Phyx-> which i just install with a seperate cabal install call and resume the previous one
01:23:12 <Saizan> afaik it doesn't have a depth limit, but the dependency solver is incomplete
01:23:30 <Saizan> it won't backtrack
01:23:43 <Phyx-> ah
01:24:08 <ivanm> is there any way of "knowing" when a data-structure is the bottleneck of an algorithm?
01:24:21 <ivanm> or does it come down to trying a different data structure and comparing results?
01:24:33 <dankna> profiling can give you clues
01:24:37 <dankna> it always comes down to intuition
01:24:57 <ivanm> yeah, that's what I figured
01:25:04 * dankna nods
01:25:14 <ivanm> except that in my case, testing with another data structure would require me to construct a new one :p
01:28:26 <sebz> Is there a standard reference for coalgebra?
01:31:47 <solistic> I'm looking for a function (f :: Text -> Text), with (f "&lt;a href=\"url\"&gt;name&lt;/a&gt;" == "<a href=\"url\">name</a>")
01:31:57 <solistic> say it reverts html escaping
01:32:11 <solistic> is there something around?
01:34:54 <Botje> @hayoo decode
01:34:54 <lambdabot> Unknown command, try @list
01:35:14 <ivanm> solistic: "reverts" ?
01:35:20 <ivanm> you mean un-escape?
01:35:25 <ivanm> if so, there are a few around
01:35:27 <ivanm> @where hayoo
01:35:27 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
01:35:34 <ivanm> ^^ have a look for unescape, etc.
01:35:34 <Botje> there's a decodeHtml in Web.Encodings
01:35:48 <ivanm> but AFAIK it's all String -> String (unless blaze has one now)
01:42:24 <solistic> ivanm: thx, I'll try a search
01:43:22 <solistic> Botje: ah, Web.Encodings works with StringLike, thx
02:05:47 <mauke> byorgey: well, it's working as designed :-)
02:09:16 <frerich> Is there anybody from the FH Wedel here?
02:25:58 <ivanm> does list fusion even fire for cases like: do { let foo = map bar xs; return $ map baz foo } ?
02:40:33 <shachaf> ivanm: Why wouldn't it? map
02:41:14 <ivanm> just wasn't sure if it was defined to work across >>= and >>
02:41:43 <shachaf> ivanm: There's no >>= there.
02:42:20 <ivanm> isn't >> defined in terms of >>= by default?
02:42:23 <ivanm> @src (>>)
02:42:24 <lambdabot> m >> k      = m >>= \_ -> k
02:42:29 <shachaf> There's no (>>) there either.
02:42:44 <ivanm> huh? it's a do-block!
02:42:49 <shachaf> @undo do { let foo = map bar xs; return $ map baz foo }
02:42:50 <lambdabot>  Parse error at "}" (column 49)
02:42:52 <mauke> and?
02:43:08 <shachaf> @undo do { let { foo = map bar xs }; return $ map baz foo }
02:43:08 <lambdabot> let { foo = map bar xs} in return $ map baz foo
02:43:26 <ivanm> oh, because of let de-sugaring
02:49:57 <Koterpillar> How can I see the (be it in GHCi or otherwise) the "stack" of the currently executing expression? Something like: (map odd [1,2,3]) = (odd 1):(map odd [2,3]) = true:(map odd [2,3]) = ... ?
02:54:52 <railk_> Is there a discussion somewhere of getters (or whatever you call them) vs pattern matching for ADTs? I'm dealing with some Haskell that uses a lot of pattern matching, and it seems very brittle (changes to the types require changes wherever there is pattern matching)
02:56:04 <mauke> @google expression problem
02:56:05 <lambdabot> http://en.wikipedia.org/wiki/Expression_problem
02:56:05 <lambdabot> Title: Expression problem - Wikipedia, the free encyclopedia
03:13:30 <ivanm> OK, doing a (length xs `seq` xs) seems to make the runtime slightly shorter and use less memory (all that happens to xs after that is a length . mapMaybe foo)
03:33:06 <ivanm> is the "maximum residency" stuff outputted with +RTS -sstderr the maximum amount of memory used at any particular moment?
03:59:26 <roconnor> what is necessary to export to enable record updating?
03:59:36 <roconnor> a la foo{bar = baz}
04:05:25 <hpc> because bar needs to be in scope?
04:22:59 <ivanm> the constructor might need to be as well, dont' recall
04:27:30 <ClaudiusMaximus> hm, my RWS with a DList ended up eating my rams and OS killed some random things...  switching to RSWT IO and s/tell/liftIO.putStr/ seemed to fix it (constant space memory usage instead of 3GB+), but it feels dirty
04:30:50 <hpc> try using String instead of DList and see what happens?
04:31:30 <ClaudiusMaximus> that was just as bad...
04:34:08 <ClaudiusMaximus> anyway, using liftIO i got a working* rot13 in boolfuck, around 74MB big, which my interpreter can barely handle - plenty of room to optimize my compiler though    (*) though at EOF it just keeps spewing newlines...
04:34:22 * hackagebot mancala 0.1 - Simple mancala game.  http://hackage.haskell.org/package/mancala-0.1 (JulianaLucena)
04:35:22 * hackagebot xml-enumerator 0.3.4 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.3.4 (MichaelSnoyman)
04:45:16 <develhevel> have a problem: need a function, which make the following: it gets a list of strings, then it runs throw all the strings and create a new list, with each string, but then it is already in the list, it renames it. how to realise this? recursive? so i must have acess to the already created list
04:45:53 <mauke> define "rename"
04:47:59 <develhevel> it checks if the name already exists (all lower chars) and then rename it with putting a 2 on the end(foo will be foo2 if already exists)
04:48:52 <mauke> what if foo2 already exists?
04:49:50 <byorgey> mauke: it's designed to copy annotations on an hpaste which was automatically copied from pastebin into a new hpaste?
04:50:11 <mauke> byorgey: no
04:50:36 <develhevel> mauke: this could not happen, i only need avoid "foo" and "Foo"
04:51:24 * hackagebot http-enumerator 0.6.5.5 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.6.5.5 (MichaelSnoyman)
04:52:24 * hackagebot uuagc 0.9.38.6 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.38.6 (ArieMiddelkoop)
04:52:41 <mauke> develhevel: how do you know it can't happen?
04:52:51 <mauke> byorgey: fortunately that's not what happened
04:53:47 <develhevel> onlyi have a new better solution :)
05:04:25 * hackagebot mime-mail 0.3.0.1 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.3.0.1 (MichaelSnoyman)
05:04:54 <lysgaard> Is there a standard fprint for Haskell? I want to print 1, 2, 3 as 001, 002, 003.
05:05:24 <Botje> > printf "%03d %05d" 1 2 :: String
05:05:25 <lambdabot>   "001 00002"
05:05:28 <Botje> like that?
05:05:40 <lysgaard> Botje: Exactly! =)
05:05:57 <Botje> it's in Text.Printf
05:10:51 <geheimdienst> so what's the public opinion on CmdArgs? i can't decide whether to be scared by the hackish syntax or impressed by the elegance http://hackage.haskell.org/packages/archive/cmdargs/0.7/doc/html/System-Console-CmdArgs-Implicit.html
05:13:26 * hackagebot yesod-json 0.1.1.1 - Generate content for Yesod using the aeson package.  http://hackage.haskell.org/package/yesod-json-0.1.1.1 (MichaelSnoyman)
05:16:03 <BleuM937> G'day
05:25:28 * hackagebot warp 0.4.1.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-0.4.1.1 (MichaelSnoyman)
05:29:46 <aavogt> geheimdienst: I like it, but then I've only had simple uses of it (parsing arguments once), so there weren't any problems with the fact it uses unsafeperformio
05:30:25 <geheimdienst> sounds good. thanks for the opinion :)
05:31:33 <aavogt> does it still has limitations that you parse the flag   --bar-x=5     for data Foo = Foo { bar :: Bar }; data Bar = Bar { x,y,z :: Int }?
05:34:01 <geheimdienst> dunno, i haven't used it yet. i was planning to, but got a little uneasy because it's so unconventional
06:09:32 <fasta> Is there a GPGPU library which has actually been used by someone with success?
07:12:24 <hpaste> “Ben Gamari” pasted “Type classes confusion” at http://hpaste.org/48555
07:12:42 <bgamari> How exactly would one fix the above?
07:13:09 <bgamari> The compiler thinks the e type variable in the instance is different from the e in the return value of the signature of value
07:13:14 <bgamari> I think
07:13:33 <Saizan> and it's quite right
07:13:39 <Botje> bgamari: have you read the functional dependencies paper?
07:13:49 <Botje> this is a perfect use case for it
07:14:03 <Saizan> or for type families
07:14:04 <bgamari> Nope
07:14:09 <bgamari> Looking
07:17:43 <matthiasgorgens> Is there a library function to read a string as a hexadecimal number?
07:17:56 <mauke> @index readHex
07:17:56 <lambdabot> Numeric
07:17:57 <bgamari> Botje: So the class declaration should be something like, class Iter i e | i -> e where
07:18:02 <bgamari> ?
07:18:02 <matthiasgorgens> thanks.
07:18:09 <Botje> bgamari: indeed
07:18:23 <Botje> uh, wait
07:18:32 <Botje> yes.
07:18:55 <Botje> i think so, at least
07:20:59 <matthiasgorgens> mauke, hmm, readHex gives a ReadS Int.  Now I have to convert that to a function that's String -> Int.
07:21:26 <mauke> matthiasgorgens: what do you do if the string doesn't start with a hex number?
07:22:30 <matthiasgorgens> mauke, throwing an exception would be fine.
07:22:47 <matthiasgorgens> (I'm just replacing a parser that's written by hand, and that uses digitToInt.
07:22:53 <matthiasgorgens> So conserving that behaviour would be ok.)
07:23:42 <mauke> and if there's garbage after the number?
07:24:38 <matthiasgorgens> in the case i have at hand, there's effectively a (filter isHexDigit) before that.
07:24:49 <matthiasgorgens> so there's no garbage.
07:25:53 <mauke> readHex' s = case readHex s of [(n, "")] -> n; _ -> error $ "readHex: bad " ++ show s
07:26:48 <erus`> can i do something like data gameRating = Lose | Draw | Score x | Win deriving (Ord)
07:26:50 <erus`> ?
07:27:06 <Eduard_Munteanu> erus`: 'x'?
07:27:07 <benmachine> erus`: GameRating needs to begin with an uppercase letter
07:27:13 <benmachine> oh, and that
07:27:30 <erus`> Score Int i mean
07:27:42 <benmachine> (plus, it's allowed to derive Ord and not Eq but it's a little strange)
07:28:30 <erus`> so i could rate chess boards with a 'Score Int' if unfinished and a Win | Lose | Draw if they are
07:28:40 <erus`> then sort so that Lose < Score x < Win
07:28:52 <benmachine> mm
07:29:14 <benmachine> are all scores better than all draws?
07:29:16 <Botje> erus`: Either Int GameRating sounds more logical then
07:29:41 <matthiasgorgens> mauke, thanks!
07:29:42 <benmachine> Botje: I'm not sure I see the advantage
07:29:50 <erus`> Score 0 == Draw effectivly
07:30:35 <erus`> then i can minimax very easily
07:30:37 <Botje> benmachine: it encodes the finished / unfinished state of the game more explicitly, i feel
07:30:55 <Botje> but i don't know what erus` intends to do with the code of course
07:31:35 <benmachine> Botje: I think your way is only useful if you use GameRating elsewhere alone
07:31:44 <benmachine> otherwise it just adds a layer of indirection
07:34:35 <dankna> @hoogle Double -> Double -> Double
07:34:35 <lambdabot> Prelude atan2 :: RealFloat a => a -> a -> a
07:34:35 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
07:34:35 <lambdabot> Prelude max :: Ord a => a -> a -> a
07:34:38 <dankna> hm
07:34:49 <dankna> @hoogle (RealFloat a) => a -> a -> a
07:34:50 <lambdabot> Prelude atan2 :: RealFloat a => a -> a -> a
07:34:50 <lambdabot> Prelude asTypeOf :: a -> a -> a
07:34:50 <lambdabot> Data.Complex mkPolar :: RealFloat a => a -> a -> Complex a
07:34:59 <dankna> @hoogle (RealFloat a, RealFloat b) => a -> b -> a
07:35:00 <lambdabot> Prelude atan2 :: RealFloat a => a -> a -> a
07:35:00 <lambdabot> Prelude const :: a -> b -> a
07:35:00 <lambdabot> Data.Function const :: a -> b -> a
07:35:05 <dankna> okay, I give up
07:35:12 <dankna> how do I raise something to a non-integral power?
07:35:27 <benmachine> dankna: **
07:35:30 <dankna> oh!
07:35:32 <dankna> thanks :)
07:35:34 <benmachine> @type (**)
07:35:35 <lambdabot> forall a. (Floating a) => a -> a -> a
07:35:50 <dankna> gotcha
07:36:24 * edwardk waves hello.
07:36:31 * benmachine waves edwardk 
07:37:10 <edwardk> hrmm, does anyone have any good references for constructive probability theory?
07:38:16 <edwardk> I've found some stuff by Shafer and other stuff Weatherson, but thats about it
07:38:25 <edwardk> er stuff by
08:01:44 <d7> I guess I have to patch redis-0.11
08:01:53 <d7> AFAICT, its pubsub support is insufficient.
08:03:06 <d7> Is there one iteratees library to rule them all, these days?
08:30:43 <ajnsit> Does cabal always download the latest version of a package-a (assuming that we are simply doing cabal install package-a) or will it download an older version if its downloaded package list has not been updated recently?
08:32:42 <Jafet> It will use the most recent package list it has, and try to use the latest version of a package on that list.
08:33:06 <Jafet> …at least, that's the least magical thing I can think of.
08:34:15 <ajnsit> Jafet, hmm it would be pretty simple to first check if a package is the latest before downloading it
08:34:33 <ajnsit> but I guess that would make dependencies complicated
08:35:16 <ajnsit> with the current situation however, the OCD in me compels me to *always* do a cabal update before doing a cabal install
08:35:39 <ajnsit> and even then I keep thinking about race conditions
08:40:26 <Twey> ajnsit: Doesn't help race conditions that much :þ
08:42:58 <gwern> if anyone has any ideas about ways to archive websites: http://www.reddit.com/r/Internet/comments/idcyz/what_archiving_services_are_there_for_websites/
08:44:06 <cheater_> download the internet
08:45:57 <gwern> cheater_: no, just the parts I care abpout
08:46:34 <gwern> cheater_: I did try mirroring each site but the disk requirements was way too much for me. better to just mirror a few especially important sites and then rely on per-page archiving
08:47:11 <gwern> I figure mirroring every site I visit or use would probably take around 10-20 terabytes, so I'll have to wait a few years before I can do that
08:48:10 <|Lupin|> hello, there
08:48:32 <|Lupin|> @seen koral
08:48:33 <lambdabot> Unknown command, try @list
08:48:33 <preflex>  Sorry, I haven't seen koral
08:49:35 <cheater_> why on earth would you do that gwern
08:49:46 <gwern> cheater_: which part?
08:49:53 <cheater_> mirror whole sites
08:50:03 <cheater_> i mean ok i have a documents dir with a lot of saved articles and shit
08:50:07 <cheater_> but like.. come on
08:50:12 <cheater_> whole sites? why?
08:50:54 <cheater_> unless you're like a dedicated archivist or something
08:50:55 <gwern> cheater_: well, often you don't know what you want. for example, a guy recently died and his site went offline. I had archived one page because I used it as a ref, and as I was making a PDF version to host on my site and maintain the reference, I realized he had written a lot of interesting things which weren't available elsewhere
08:51:31 <gwern> cheater_: as it is, I can only stare at the index file and wonder whether the missing pages would have been useful for my own essay
08:51:32 <cheater_> yeah, that doesn't happen often enough to actually matter though
08:51:38 <cheater_> generally things that are worth knowing are known
08:52:11 <benmachine> cheater_: look at it the other way around - disk space is pretty cheap nowadays
08:52:20 <benmachine> why wouldn't you archive all the text you get your hands on?
08:52:34 <cheater_> he just said it's too expensive for him
08:53:05 <gwern> cheater_: and in my own areas of expertise, such as Evangelion research, something like half of my sources are dead or copies in archives. so it's not the truth that things worth knowing are known
08:54:02 <Jafet> gwern: wait a few years? You know you'll never catch up.
08:54:19 <Jafet> When people invent finer hard disks, they'll invent more extravagant media.
08:54:30 <Gracenotes> okay. I thought Java's date/time library was bad
08:54:33 <Gracenotes> but Python? what the hell?
08:54:37 <cheater_> you mean neon genesis evangelion?
08:54:38 <Gracenotes> *bashes head against wall*
08:54:59 <olsner> Gracenotes: enjoy your herp derpes :)
08:55:31 <kmc> all datetime libraries everywhere suck ass
08:55:35 <kmc> i'm still not sure why
08:55:35 <gwern> cheater_: yeah
08:56:02 <gwern> Jafet: I think I am catching up. I could not afford to do this sort of thing 6 years ago
08:56:06 <Gracenotes> I just want to take this one type, with certain semantic meaning related to a point in time, and convert it to another type with near-equivalent meaning
08:56:38 <Jafet> Well, I guess if you archive older media…
08:56:42 <cheater_> gwern, what are you researching
08:56:43 <Gracenotes> how many fracking functions do I have to call to do this?
08:56:55 <monochrom> perhaps datetime itself is a mess
08:56:58 <Jafet> kmc: the domain sucks ass
08:57:15 <Jafet> Popes and emperors invented it, what do you expect
08:57:29 <gwern> Jafet: indeed, most content by semantics is older media. videos just take up a lot of space, they don't convey very much
08:57:49 <Gracenotes> if it exists in real life, it should be model-able by a sane type system with enough thought
08:57:58 <gwern> cheater_: I research everything. connections are unexpected and I can't afford to be picky. my main interest are out-of-universe materials like interviews
08:58:15 <monochrom> no, the trouble is, it also exists in social life
08:58:24 <cheater_> gwern, ok
08:58:36 <monochrom> i.e., whenever humans are involved, there is politics, and it gets messy
08:59:51 <Jafet> Video encoders seem to be really inappropriate for cel animation
09:00:47 <Gracenotes> okay. found two functions which do what I want. One of which is very similarly named to a function which does the opposite of what I want, the other one of which is named the exact same as a function from another module which is only vaguely related
09:00:55 <Gracenotes> \o/
09:01:44 <Jafet> If you keep at it, your intellect might just be cut out to be a politician.
09:01:58 <Jafet> (Pun unintended)
10:00:45 <ClaudiusMaximus> mm, using a saner algorithm reduced my haskell-generated rot13 boolfuck implementation from 75MB to 30kB - seems nested ifs 8 levels deep is more efficient than trying to do arithmetic and comparisons...
10:01:13 <djahandarie> "haskell-generated rot13 boolfuck" sounds scary
10:01:33 <ClaudiusMaximus> :)
10:02:36 <kmc> ClaudiusMaximus, what about a table of some sort?
10:03:24 <ClaudiusMaximus> kmc: hold on, i'll paste..
10:05:26 <hpaste> ClaudiusMaximus pasted “boolfuck rot13” at http://hpaste.org/48557
10:07:18 <bgamari> How does one do something like the following?
10:07:18 <bgamari> data (Num v, Iter it (Datum v)) => ShiftedIter it = ShiftedIter it v
10:07:29 <bgamari> Where v is inferred from the type of it
10:07:46 <bgamari> Currently this gives me
10:07:47 <bgamari> corr.hs:63:11: Not in scope: type variable `v'
10:08:58 <bgamari> seems kind of like a functional dependency
10:09:07 <bgamari> but these only apply to type classes
10:11:19 <benmachine> bgamari: hmm, sounds tricky. TypeFamilies would be able to do it, I think
10:11:33 <hpaste> scooty-puff pasted “Comonad Located” at http://hpaste.org/48558
10:12:00 <scooty-puff> can anyone help me define access or mutate without combine (see the paste above)?
10:12:50 <bgamari> benmachine: Thanks!
10:13:32 <benmachine> bgamari: the idea would then be you'd have data ShiftedIter it = ShiftedIter it (IterType it)
10:13:50 <benmachine> where IterType is a type family
10:24:23 <Cale> scooty-puff: should be impossible
10:24:37 <Cale> scooty-puff: (at least, using *only* the stuff available from comonad)
10:25:00 <scooty-puff> what type class would you recommend adding?
10:25:28 <Cale> because it involves the mappend for Span, and the instance of Comonad here doesn't rely on the particulars of Span at all (it would work for an arbitrary type)
10:25:41 <Cale> (and in particular, it doesn't use the monoid instance)
10:26:45 <mjrosenb> i take it that (a->) is a Monad, but not a MonadPlus?
10:27:00 <Cale> true
10:27:25 <mjrosenb> :(
10:27:47 <mjrosenb> i guess it could be special cased if the result of the function is a monoid?
10:27:59 <Cale> Except that it can't.
10:28:15 <Cale> :t mplus
10:28:17 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
10:28:27 <Cale> It's totally polymorphic in the type a
10:28:36 <Cale> You want Monoid
10:28:43 <Cale> :t mappend
10:28:44 <lambdabot> forall a. (Monoid a) => a -> a -> a
10:28:57 <Cale> There's an instance Monoid a => Monoid (e -> a)
10:29:26 <kmc> . o O ( class (forall a. Monoid (m a)) => MonadPlus m where { } )
10:29:39 <Cale> sortBy (comparing length `mappend` compare) (words "Here is a list of words to sort first by length and then alphabetically")
10:29:42 <Cale> > sortBy (comparing length `mappend` compare) (words "Here is a list of words to sort first by length and then alphabetically")
10:29:43 <lambdabot>   ["a","by","is","of","to","and","Here","list","sort","then","first","words",...
10:30:08 <Cale> > sortBy (comparing length ++ compare) (words "Here is a list of words to sort first by length and then alphabetically")
10:30:10 <lambdabot>   ["a","by","is","of","to","and","Here","list","sort","then","first","words",...
10:30:38 <mjrosenb> Cale: well, i can do it, but only  for special reasons :-p
10:31:40 <mjrosenb> i'm saying from a category theory point of view.
10:32:29 <Cale> Well, I'm not entirely sure what a MonadPlus is supposed to be from a category theory point of view. (It's something nonstandard, whatever it is)
10:32:58 * mjrosenb had always assumed it was sort of like the union of monad and monoid.
10:33:09 <mjrosenb> for some definition of "union"
10:34:08 <kmc> what does MonadPlus add to the Kleisli category of a monad?
10:35:08 <mjrosenb> kmc: i have no clue what the Kleisli category of a monad is.
10:35:23 <Cale> Well, you get a monoid operation on arrows
10:35:35 <Cale> (at least)
10:36:35 <kmc> mjrosenb, for any monad M, consider the functions of the form (a -> M b)
10:36:38 <kmc> we can "compose" these:
10:36:39 <kmc> :t (<=<)
10:36:40 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
10:36:48 <Cale> mjrosenb: If C is a category and T is a monad on C, then the Kleisli category for T has the same objects as C, but the arrows A ~> B in the Kleisli category are arrows A -> TB in C
10:37:03 <kmc> and we have an "identity" return :: a -> M a
10:37:17 <kmc> the monad laws state that ((a <=< b) <=< c) = (a <=< (b <=< c))
10:37:20 <kmc> and (a <=< return) = a
10:37:24 <kmc> and (return <=< a) = a
10:37:59 <kmc> in other words, we have something that "looks like" function composition, with an associative operator and an identity for that operator
10:38:03 <kmc> that's a category
10:39:05 <kmc> newtype Kleisli m a b = Kleisli (a -> m b)
10:39:33 <kmc> instance (Monad m) => Category (Kleisli m) where { id = Kleisli return; Kleisli f . Kleisli g = Kleisli (f <=< g) }
10:39:34 <Cale> So you could say that in the case of MonadPlus, the Kleisli category is enriched over the category of monoids, but that's not quite the whole story depending on what you interpret the laws of MonadPlus to be
10:39:48 <kmc> Cale, what does it mean to enrich a category over another?
10:40:33 <hpaste> scooty-puff annotated “Comonad Located” with “Comonad Located (annotation)” at http://hpaste.org/48558#a48559
10:40:35 <Cale> An enriched category is defined similarly to a category, but where the Hom sets are replaced by objects of another category (other than Set)
10:40:50 <Cale> http://en.wikipedia.org/wiki/Enriched_category
10:41:18 <Wut> what is this ?
10:41:39 <Cale> This is a channel for discussion about the programming language Haskell and related topics.
10:41:56 <Wut> ty :)
10:43:05 <Eduard_Munteanu> kmc: that's offtopic here, ##categorytheory :P
10:43:59 <kmc> ;P
10:44:06 <Cale> If you take the non-negative real numbers R+, you can turn them into a category according to their ordering (a preorder category), and make it a monoidal category by addition (with 0 as the identity). Categories enriched over (R+,+,0) are something pretty close to metric spaces
10:44:56 <kmc> sorry, what are the objects and arrows of the category R+?
10:45:51 <Cale> The objects are nonnegative real numbers, there is exactly one arrow x -> y whenever x <= y
10:46:19 <Cale> (and no arrows otherwise)
10:46:59 <Cale> actually, we can just use R, even
10:48:26 <kmc> ok
10:48:32 <Cale> So now in our enriched category, instead of a set of arrows between two objects, we have a real number
10:49:59 <Cale> and we have, for each object A, an arrow 0 -> Hom(A,A), giving that the distance from A to itself is nonnegative
10:51:04 <Cale> and we have for any three objects A,B,C, an arrow Hom(B,C) (x) Hom(A,B) -> Hom(A,C), but of course (x) = + here, so this says  Hom(B,C) + Hom(A,B) <= Hom(A,C)
10:51:10 <Cale> which is the triangle inequality ;)
10:51:24 <Eduard_Munteanu> I'm not sure, what does an arrow look like? It has a dom and cod and additionally an object from another category?
10:52:08 <Cale> In our enriched category, we're replacing not the arrows, but the *sets* of arrows, with objects from another (monoidal) category
10:52:23 <kmc> Cale, it has to be a monoidal category?
10:52:39 <Cale> yeah
10:52:50 <Eduard_Munteanu> So the other category has to have Ob(M) a plain set?
10:52:55 <Cale> Because instead of id_A being an element of a set of arrows
10:52:59 <Eduard_Munteanu> (wait no)
10:53:07 <Eduard_Munteanu> In fact objects must be sets?
10:53:14 <Cale> it's now an arrow I -> Hom(A,A)
10:53:25 <Cale> (in the monoidal category we enriched over)
10:53:51 <Cale> and instead of composition being a function Hom(B,C) x Hom(A,B) -> Hom(A,C)
10:53:57 <|Lupin|> pls, is somebody aware of an HTML parsing library written in Haskell or for which Haskell bindings exist ?
10:54:05 <Cale> we need a replacement for Cartesian product
10:54:13 <Eduard_Munteanu> |Lupin|: HaXML, HXT, ...
10:54:25 <|Lupin|> not a tagsoup kind, something which gives access to all te information contained in the HTML page
10:54:27 <Cale> So we let it be the operation on objects for our monoidal category
10:54:28 <Eduard_Munteanu> also Tagsoup
10:54:39 <Cale> (for which I is the identity)
10:54:41 <augur> i vaguely remember hearing about monads where you can imagine information flowing "backwards" from the future
10:54:45 <augur> does this sound familiar to anyone?
10:54:45 <Eduard_Munteanu> |Lupin|: ah, in that case HXT is quite powerful, you can even do XPath lookups
10:54:48 <Cale> augur: sure
10:54:52 <augur> !
10:54:54 <augur> do tell :)
10:54:54 <Cale> augur: backwards state monad
10:54:56 <kmc> |Lupin|, did you search on http://hackage.haskell.org/packages/archive/pkg-list.html
10:54:59 <augur> :O
10:55:06 <Cale> Just write the state monad, but get it wrong
10:55:18 <augur> Cale: lol
10:55:24 <augur> harder said than done!
10:55:31 <augur> ill give it a try: fffff
10:55:32 <Cale> newtype BState s a = BS (s -> (s,a))
10:55:34 <augur> did i get it wrong?
10:55:34 <augur> :D
10:55:43 <augur> ;)
10:55:50 <Cale> runBState :: BState s a -> s -> (s,a)
10:55:57 <augur> being wrong is easy, being wrong in the right way is a difficult
10:56:10 <Cale> nah, there's only one good way to be wrong :)
10:56:16 <augur> :)
10:56:24 <Cale> instance Monad (BState s) where
10:56:26 <augur> well im reading some blog about this now so
10:56:30 <|Lupin|> kmc: yes, I am doing this
10:56:37 <Cale>   return v = BS (\s -> (s,v))
10:56:41 <|Lupin|> thanks for the htx suggestion !
10:56:57 <Cale> now, for >>=
10:57:04 <Cale> normally we'd have this:
10:57:48 <Cale> x >>= f = BS (\s -> let (s',v) = runBState x s; (s'',w) = runBState (f v) s' in (s'',w)
10:57:53 <Cale> That's the normal state monad
10:58:21 <Cale> but we can make a mistake here and get the s's mixed up
10:58:39 <Cale> x >>= f = BS (\s -> let (s'',v) = runBState x s'; (s',w) = runBState (f v) s in (s'',w)
10:59:01 <augur> hmm
10:59:14 <augur> ok ill have to first make sure i grok state first
10:59:17 <augur> then ill toy around with this
10:59:20 <Cale> This is a perfectly good definition and it'll satisfy the monad laws, but it's not the state monad as we know it, the state is flowing in the opposite direction :)
10:59:41 <Cale> Oh, in that case, I ought to have explained the definition of the State monad a bit better
10:59:48 <augur> no no
11:00:05 <augur> i roughly get state, but i dont use it so i need to make sure its intuitive first so im reading
11:00:18 <augur> i just wanted a pointer to something with time travel :P
11:03:43 <Cale> So in this reversed state monad, do x <- get; put v; return x will return v as its result.
11:04:30 <Cale> do x <- get; put (0:x); return x
11:04:38 <Cale> will produce an infinite list of 0's
11:05:11 <c_wraith> doesn't that work with lazy state, too?
11:05:18 <Cale> not like this
11:05:22 <c_wraith> oh, you're right
11:05:33 <|Lupin|> okay, till son folks, thanks for the good pointers !
11:05:42 <benmachine> http://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
11:07:52 <benmachine> the State/RState isomorphism is cute
11:07:59 <benmachine> you can have your state going all over the place :P
11:10:29 <Codex_> If I have (Int,Int)->Color, how can I create a function ()->Bitmap ?
11:11:32 <copumpkin> what would you want () -> Bitmap for?
11:11:33 <Codex_> (it's supposed to call the first function several times and store only the Colors.
11:11:38 <Cale> Codex_: What type is Bitmap?
11:11:54 <shachaf> type Bitmap = (Int,Int) -> Color
11:12:00 <copumpkin> () -> X is the same as X
11:12:02 <Codex_> you can decide how to represent Bitmap, but I don't want it to store the whole function
11:12:10 <copumpkin> under some fairly good assumptions
11:12:49 <copumpkin> ah
11:12:52 <ion> @djinn () -> a
11:12:53 <lambdabot> -- f cannot be realized.
11:13:04 <ion> @djinn () -> a -> a
11:13:04 <lambdabot> f _ a = a
11:13:23 <Cale> const myBitmap
11:13:25 <Cale> should do
11:13:40 <scree> @djinn (() -> a) -> a
11:13:41 <lambdabot> f a = a ()
11:13:56 <Cale> but there shouldn't be much need for that
11:14:24 * shachaf was (kind of) joking about the type, in case he's being taken seriously.
11:14:26 <Cale> oh, shachaf answered, not you
11:14:31 <Codex_> The reason I asked about this is because I have trouble creating enough function calls and collect results of several function calls to same data structure.
11:14:41 <scooty-puff> is there a version of Applicative that doesn't include pure?
11:14:50 <copumpkin> scooty-puff: Apply, by edwardk
11:14:58 <scooty-puff> copumpkin, thanks
11:15:06 * edwardk looks up
11:15:19 <joe6> is there a simple way of seeing what haskell is sending to the shell? http://pastebin.com/VwVyGLwF
11:15:20 <mauke> The paste VwVyGLwF has been copied to http://hpaste.org/48561
11:15:27 <djahandarie> edwardk, do you see the sky?
11:15:36 <joe6> i am trying to use system.Process.readProcess
11:15:37 * shachaf knew that the answer was "by edwardk", though he wasn't sure what it was.
11:15:38 <edwardk> ceiling tiles actually
11:15:55 <djahandarie> :-(
11:16:10 <joe6> and the same command runs file from the shell prompt.
11:16:12 <fxr> anyone uses google+?
11:16:15 <Cale> joe6: You put all the args in one arg
11:16:26 <shachaf> Codex_: You'll have to say more about what a Bitmap is if you're not satisfied with the function.
11:16:41 <Cale> joe6: You want readProcess "..." ["-p", "18...", "-c", "snsr.hex"]
11:16:44 <joe6> i tried that. do you mean like this:  x <- readProcess "/usr/local/bin/gpdasm -p 18f4455 -c snsr.hex" [] []
11:16:52 <Codex_> shachaf: it could be [[Color]] or something.
11:16:53 <joe6> Cale, ok.
11:17:00 <joe6> Cale, will try that.
11:17:25 <shachaf> A list seems much less appropriate for a bitmap. :-)
11:17:37 <joe6> Cale , thanks that did te trick
11:17:38 <NihilistDandy> fxr: I know some people who do, and I'm trying to land an invite
11:17:41 <Cale> joe6: What you were doing is the equivalent of  /usr/local/bin/gpdasm " -p 18f4455 -c snsr.hex"
11:17:43 <Cale> in bash
11:17:46 <joe6> s/te/the/
11:18:03 <Cale> (and you can see the command in the error message there)
11:18:33 <joe6> Cale, that makes sense.
11:18:43 <joe6> Cale, I was not sure of what that was.
11:19:56 <fxr> NihilistDandy: hmm it seems that they're not accepting new users even we have invitation.
11:20:08 <Cale> Codex_: well, how you do that almost entirely depends on the represention of Bitmap
11:20:16 <NihilistDandy> fxr: They're locked down for the moment
11:20:31 <Cale> Codex_: aside from wrapping the thing with 'const' to eat the () parameter
11:20:43 <Cale> (or using lambda)
11:21:07 <fxr> NihilistDandy: how can I get an invitation, so that I can try it out when they ready?
11:21:35 <Cale> With that list type, you might have \x -> [[ f i j | j <- [1..100]] | i <- [1..100]]
11:21:41 <benmachine> fxr: wait
11:21:45 <benmachine> and come back later
11:21:46 <Cale> or whatever
11:21:49 <benmachine> seems to be general consensus
11:22:01 <fxr> yeah I guess so
11:22:46 <Codex_> cale: you mean \f?
11:22:51 <Codex_> cale: or \x?
11:23:13 <shachaf> conal likes representing images as that sort of function (though I think he prefers it continuous rather than discrete).
11:23:40 <Cale> \x
11:23:50 <Cale> x = ()
11:23:54 <Codex_> oh right
11:24:12 <shachaf> (What's the point of the () again?)
11:24:15 <Codex_> I was already thinking of ((Int,Int)->Color)->Bitmap kind of function
11:24:36 <Cale> Yeah, there's no reason to introduce the () here
11:24:39 <conal> shachaf: right -- continuous. for much improved simplicity, composability, and amenability to tractable reasoning.
11:24:39 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
11:25:30 <bahamas> does installing the haskell platform require a lot of resources? i'm running make but after 'Linking Setup ...' is printed, my computer is really crawling
11:25:46 <mjrosenb> Cale: oh, did you see the question I asked you yesterday?
11:25:52 <Codex_> the () was originally there just to make it a function
11:26:00 <Cale> mjrosenb: I don't think I did...
11:26:17 <luite> conal: did you make any progress with the client side interactive graphics?
11:26:32 <benmachine> conal: what exactly do we mean by continuous here?
11:26:49 <mjrosenb> Cale: ahh, it was something along the lines of "did you have an exampl of using haskell in a vaguely oo-ish way by implementing a simple (possibly asteroids-like) game?
11:26:51 <shachaf> type Image a = (Real,Real) -> a, I think?
11:27:00 <bahamas> i'm on ubuntu, if that makes a difference
11:27:08 <benmachine> shachaf: Reals are tricky :P
11:27:11 <conal> luite: not yet. i'm pursuing a couple of directions. haven't gotten there yet.
11:27:32 <afleckenstein> bahamas: I installed it yesterday and it didn't take terribly long
11:27:37 <benmachine> you can't compare Images for equality, presumably?
11:27:40 <Cale> mjrosenb: I had a sketch of such a thing in my old wiki, but the hard drive that was on is semi-dead, and I've yet to try to extract it.
11:27:50 <conal> benmachine: in the sense of defined over a continuum (continuous domain)
11:27:54 <Cale> (It wasn't a very large example, and a real game would need a lot more details)
11:27:59 <afleckenstein> bahamas: (on ubuntu too)
11:28:03 <bahamas> afleckenstein: how much RAM do you have?
11:28:04 <conal> shachaf: yes, for instance.
11:28:06 <benmachine> conal: so just rational co-ordinates wouldn't satisfy you?
11:28:19 <mjrosenb> Cale: i was more interested in whatever style was being used as opposed to the actual game
11:28:40 <afleckenstein> bahamas: 4GB I think
11:28:42 <mjrosenb> Cale: is there anything in specific i should search for if i want to find similar examples?
11:28:52 <conal> benmachine: rational would miss sqrt, trig, etc, which are very useful for graphics
11:29:08 <bahamas> afleckenstein: i have 512. that's why i was asking about the resources
11:29:13 <bahamas> MB, that is
11:29:17 <benmachine> conal: sure, but Reals are scary :(
11:29:23 <hpaste> scooty-puff annotated “Comonad Located” with “Comonad Located (annotation) (annotation)” at http://hpaste.org/48558#a48564
11:29:28 <shachaf> Nothing less than the uncomputable reals will do!
11:29:39 <benmachine> shachaf: :P even the computable reals are scary tbh
11:29:42 <luite> conal: ok :) I've been working on the relatively boring low-level bits of my site, so I haven't been able to give it much thought either
11:29:56 <afleckenstein> bahamas: well, with 512 (MB, not GB :P) you can't ask for much, can you?
11:30:06 <luite> but I hope to get to the more interesting (graphics) bits later this summer
11:30:11 <conal> luite: ah.
11:30:36 <mjrosenb> bahamas: "free -m"  will tell you how much ram is free / swap is being used
11:30:48 <mjrosenb> bahamas: and top will let you sort the processes by memory usage.
11:32:07 <bahamas> mjrosenb: yeah, it seems i don't have much free memory. i probably should close everything when i try to run make again
11:33:56 <Cale> mjrosenb: I don't know. The basic idea is easy though. Instead of representing game objects using a sum type of different possible objects (and the data associated with each), represent them using a record consisting of whatever functions you need to be able to perform on game objects (like drawing them to the screen, updating them with a given time delta, and whatever other interactions can happen in your game)
11:33:58 <roconnor> trig isn't that useful for graphics ^_^
11:34:12 <roconnor> usually it is a sign of a mistake
11:35:58 * hackagebot mime-mail-ses 0.0.0 - Send mime-mail messages via Amazon SES  http://hackage.haskell.org/package/mime-mail-ses-0.0.0 (MichaelSnoyman)
11:36:07 <benmachine> hmm, I wonder if there are "nice" ways of representing algebraic numbers
11:36:59 <ClaudiusMaximus> i made a module for Q[sqrt(5)] at one point, but that's a small subset..
11:37:15 <benmachine> ClaudiusMaximus: yeah, I've done similar things
11:37:31 <narens> MonadRandom question: I have a function (randPick) that randomly picks a value x, and then recurses to generate a random value based on x and so on. Now, this should return an infinite list of numbers lazily but ghc doesn't generate any output if i generate these using liftM (result:) (randPick result)... and I have to end up using a normal fold where I run evalRand at each iteration. Is this is the only way to do it?
11:37:53 <benmachine> but as I recall it, even Q[sqrt(2),sqrt(3),sqrt(5),...] still isn't all algebraics
11:38:29 <ClaudiusMaximus> mm, i don't know the definition, but i imagine it to be closed under roots?
11:38:47 <benmachine> well, algebraics are solutions of polynomials
11:38:48 <luite> no, you can't make all algebraics with radicals
11:39:10 <benmachine> and yes, roots, even nth roots, won't get you all of them
11:39:18 <benmachine> possibly algebraics are overkill
11:39:18 <luite> that's why we can't have a "quadratic formula" for the quintic
11:39:42 * benmachine remembers reading about 'constructible numbers' and wonders if they are interesting
11:39:47 <benmachine> can't trisect angles with them though :/
11:40:03 <narens> anyone?
11:40:07 <benmachine> but maybe you don't need to trisect arbitrary angles
11:40:37 <ClaudiusMaximus> origami can do more than compass+straightedge afaik
11:40:47 <benmachine> ClaudiusMaximus: yes you can trisect with origami, I've heard
11:40:51 <ClaudiusMaximus> narens: foldM perhaps?
11:40:55 <benmachine> narens: can you hpaste the code?
11:41:37 <ClaudiusMaximus> @hoogle iterateM
11:41:38 <lambdabot> No results found
11:41:45 <ClaudiusMaximus> @hoogle whileM
11:41:45 <lambdabot> No results found
11:42:15 <ClaudiusMaximus> :t iterate (f =<<) . return
11:42:16 <lambdabot> forall (m :: * -> *) b. (Show b, SimpleReflect.FromExpr (m b), Monad m) => b -> [m b]
11:42:39 <benmachine> :t iterate (?f =<<) . return
11:42:39 <lambdabot> forall (m :: * -> *) b. (?f::b -> m b, Monad m) => b -> [m b]
11:43:01 <ClaudiusMaximus> :t sequence . iterate (?f =<<) . return
11:43:02 <lambdabot> forall (m :: * -> *) a. (Monad m, ?f::a -> m a) => a -> m [a]
11:43:14 <narens> ClaudisuMaximus: All i want is unfoldM, but it doesn't generate output unless i evaluate it... let me write a short piece of code that illustrates my problem... back in a few mins
11:45:00 <joe6> is there a built-in function to do: (\(x,y) -> [x,y])
11:45:31 <benmachine> joe6: no, it's not something that you often need to do ime
11:45:45 <benmachine> :t uncurry (:) . return
11:45:46 <lambdabot> forall a. (Monad ((,) a)) => [a] -> [a]
11:45:50 <benmachine> oops
11:45:58 <copumpkin> that would be a horrible function
11:46:01 <benmachine> :t uncurry (:) . second return
11:46:01 <lambdabot> forall a. (a, a) -> [a]
11:46:16 <benmachine> :t uncurry (:) . fmap return
11:46:17 <lambdabot> forall a. (a, a) -> [a]
11:46:39 <benmachine> :t uncurry (:) . fmap (:[])
11:46:40 <lambdabot> forall a. (a, a) -> [a]
11:46:49 <joe6> benmachine: ok, thanks.
11:47:06 <EEVIAC> > sequence [fst,snd] (3,5)
11:47:07 <lambdabot>   [3,5]
11:47:18 <benmachine> EEVIAC: sneaky :)
11:47:30 <EEVIAC> yeah hehe that's a nice one
11:50:48 <copumpkin> > flip [fst, snd] (3, 5)
11:50:50 <lambdabot>   [3,5]
11:50:53 <edwardk> @type sequence fst snd
11:50:54 <lambdabot>     Couldn't match expected type `[m a]'
11:50:54 <lambdabot>            against inferred type `(a1, b) -> a1'
11:50:54 <lambdabot>     In the first argument of `sequence', namely `fst'
11:51:05 <edwardk> @type sequence [fst, snd]
11:51:06 <lambdabot> forall a. (a, a) -> [a]
11:51:10 <edwardk> hah
11:51:53 <benmachine> copumpkin: nice!
11:52:04 <copumpkin> that's using Cale's funky flip though
11:52:07 <benmachine> sure
11:52:16 <benmachine> but I haven't seen a sensible use for it until now
11:52:21 <benmachine> @type flip
11:52:22 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
11:52:27 <hpaste> naren pasted “monadrandom” at http://hpaste.org/48566
11:52:41 <danharaj> o.O
11:52:42 <narens> ClaudiusMaximus: there is the sample code
11:52:45 <danharaj> @src flip
11:52:45 <lambdabot> flip f x y = f y x
11:52:54 <edwardk> @type flip
11:52:54 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
11:53:05 <narens> ClaudiusMaximus: It just seems to go into a inf loop
11:53:13 <edwardk> flip f a = fmap ($a) f
11:53:23 <danharaj> that's clever
11:53:30 <danharaj> Thinking with portals etc.
11:55:02 <edwardk> a few more ramblings about using comonads as monad transformers
11:57:44 <Cale> That one isn't mine... istr it was ski who came up with it
11:57:55 <Cale> (?)
11:58:37 <copumpkin> ah
12:00:57 <fxr> it seems nobody uses yi-editor these days...
12:00:59 <benmachine> narens: are you using the seed afterwards?
12:01:15 <narens> benmachine: yea, using evalRandIO
12:01:40 <narens> benmachine: the only way to get to work is to use normal unfold and run evalRand each time and pass the new generator to the next iteration
12:01:41 <benmachine> narens: if you generate an infinite list of random numbers at any point, the value of the seed in following statements will be undefined
12:01:55 <benmachine> narens: I've got this to work
12:02:07 <benmachine> ghci> evalRand (take 10 <$> fix (liftA2 (:) getRandom)) s
12:02:07 <benmachine> [1784732097,974908114,1358239359,-1582824993,-876023438,7449650,588130203,-1420536714,2082565672,2106319893]
12:02:19 <benmachine> (s is some StdGen)
12:02:22 <benmachine> oh, dinner
12:02:27 <benmachine> someone else can explain to you how that works :P
12:06:18 <danharaj> edwardk: I was wondering about yesterday's example of Two a = T a a and the function swap (T x y) = T y x. Is (extend swap) in this case the same as duplicate?
12:06:47 <copumpkin> ezyang: no GADTs 4 u
12:06:52 <ezyang> :-( :-(
12:07:05 <copumpkin> ezyang: so you aren't a convert yet?
12:07:10 <copumpkin> to the ML ways
12:07:21 <ezyang> Everyone refers to me as "the Haskeller"
12:07:24 <copumpkin> lol
12:07:26 <danharaj> Wait it isn't.
12:07:28 <copumpkin> you and jmcarthur ?
12:07:31 <danharaj> But it feels close.
12:07:55 <danharaj> > duplicate [1,2..]
12:07:55 <lambdabot>   Not in scope: `duplicate'
12:08:13 <copumpkin> list isn't a comonad
12:08:17 <ezyang> jmcarthur's not near me deskwise, so I don't actually interact with him much.
12:08:35 <copumpkin> aww
12:08:55 <danharaj> duplicate = extend id. right.
12:10:32 <danharaj> edwardk: What I think I'm trying to ask is. Sometimes with a comonad you have sister functions to extract, like for Two a, it's swap, and for streams, it's tail. How are they involved in the comonadic structure?
12:11:22 <Cale> The same way that get and put are involved in the monadic structure of the State monad (i.e. not really involved)
12:11:58 * wli discovered that Brent's exponential search has half a dozen cases at each step not covered by the poor descriptions of it.
12:12:27 <copumpkin> ezyang: there you go
12:12:29 <copumpkin> oleg did it first
12:12:40 * byorgey apologizes on behalf of the other Brent
12:13:25 <djahandarie> danharaj, was it you who was working on that Haskell IDE?
12:13:31 <danharaj> djahandarie: nope.
12:13:36 <djahandarie> Hm...
12:13:42 <djahandarie> Was it dankna? Can't remember
12:13:47 <cheater_> yeah might be him
12:14:00 <c_wraith> all you people whose names start with d
12:14:02 <djahandarie> This would be even more confusing if I wasn't me
12:14:04 <danharaj> Cale: But, for example, duplicate for streams is equal to (xs, tail xs, tail^2 xs, ...), no?
12:14:08 <c_wraith> yes, exactly
12:14:36 <dankna> was me
12:14:45 <Cale> danharaj: Oh, sure.
12:15:23 <danharaj> Cale: It feels like head and tail define the comonad together.
12:16:14 <danharaj> and for Two a, duplicate xy = T xy (swap xy)
12:16:44 <linduxed> when dealing with 2d points, should i define a type named point, or should i just run with pairs? (tuples)
12:17:15 <Cale> But head and tail are pretty structural things about lists. It's hard to do much without implicitly involving them somehow.
12:17:28 <linduxed> the type would in my mind be nothing more than "data Point = Point (Double, Double)"
12:17:47 <linduxed> it feels... unnecessary somehow
12:18:09 <Cale> linduxed: Or  data Point = Point Double Double
12:18:26 <danharaj> linduxed: If you want to define instances for algebraically manipulating points without 'polluting' (,), then you could make a new data type.
12:18:43 <danharaj> Also, if you want to distinguish between Points and Vectors.
12:19:01 <Cale> It's not strictly necessary, but it can be good to distinguish pairs of Doubles which are intended to be interpreted as points from pairs of Doubles which aren't geometrically related like that.
12:19:51 <linduxed> Cale: hmmm, i think i'll run with it for safetys sake then
12:21:05 <danharaj> Cale: If I demand a signature of (w a -> a, w a -> w a), and tell you to make a comonad out of it, what other conditions do I have to demand of the two functions so that your most generic solution is to produce the Streams comonad?
12:21:09 <danharaj> (or something isomorphic)
12:28:55 <danharaj> Cale: Actually I suppose I'm thinking about the structure of Stream as a final coalgebra and trying to reason about its comonadic structure from that.
12:43:27 <joe6> any suggestions on how I can fix this: error: http://pastebin.com/1K1hktcP, guilty code: http://pastebin.com/mw6F46f9
12:43:30 <mauke> The pastes 1K1hktcP mw6F46f9 have been copied to http://hpaste.org/48568 http://hpaste.org/48569
12:43:34 <joe6> I am using Test.HUnit
12:43:53 <linduxed> just out of curiosity, is there something like gofmt for haskell?
12:43:58 <joe6> mauke, your script even works with multiple pastes
12:44:15 * hackagebot aeson 0.3.2.9 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.3.2.9 (BryanOSullivan)
12:44:24 <kmc> linduxed, not afaik
12:44:32 <kmc> but hlint will give some style suggestions
12:44:36 <NihilistDandy> What about hlint? Or ar you looking for something more automated?
12:44:42 <NihilistDandy> Derp, kmc beat me to it.
12:44:44 <kmc> and some editors have automatic indentation
12:44:53 <linduxed> kmc: i'm so jealous of gofmt, it seems like such a nice tool
12:44:58 <kmc> yeah
12:45:03 <linduxed> kmc: i'd love to have it for python too
12:45:05 <kmc> the tools exist to write something like gofmt for Haskell
12:45:15 <danharaj> demand is low
12:45:16 <kmc> haskell-src-exts might already have a pretty-printer
12:45:22 <byorgey> it does.
12:45:36 <kmc> haskell style varies
12:46:05 <kmc> i would be unhappy if my code were massaged to look like "median" haskell style
12:46:13 <kmc> i think most other people would too
12:46:18 <linduxed> kmc: but i'd like to see a tool like gofmt for haskell because i have NO style
12:46:29 <NihilistDandy> linduxed: Use haskellmode-emacs
12:46:34 <linduxed> kmc: i'm too new to the language so it looks dreadful
12:46:41 <linduxed> NihilistDandy: i use vim
12:46:45 <joe6> i think I need something that can return [m c] instead
12:46:47 <NihilistDandy> _-_
12:46:50 <kmc> in particular i get really annoyed at the "chunks of code indented super far to the right because of a long name" style
12:46:59 <kmc> i never let the length of a name dictate the indentation of subsequent lines
12:47:07 <joe6> something similar to zipWithM, but with a signature of [m c]
12:47:23 <kmc> linduxed, i wrote up a few of my style guidelines in http://mainisusuallyafunction.blogspot.com/2010/10/tour-of-real-toy-haskell-program-part-1.html
12:47:26 <NihilistDandy> linduxed: There's a haskellmode-vim, too, I think, but I never liked it
12:47:42 <linduxed> kmc: yeah it's the same for me, if there's a where or let coming, i do a newline right there and indent
12:47:52 <kmc> cool :)
12:48:09 <linduxed> NihilistDandy: well I just got motivated to look around some for haskell tools
12:48:14 <linduxed> for vim that is
12:48:31 <NihilistDandy> Well, a link, then: http://projects.haskell.org/haskellmode-vim/
12:49:24 <NihilistDandy> Not sure if it has everything you need, but it's a start
12:52:03 <byorgey> @type zipWithM
12:52:04 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
12:52:20 <byorgey> joe6: that's just zipWith
12:52:26 <byorgey> @type zipWith
12:52:27 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
12:52:33 <byorgey> replace 'c' with 'm c'
12:53:39 <joe6> oh, yeah.
12:53:43 <joe6> byorgey: thanks.
12:53:54 <joe6> byorgey: facepalm.
12:54:00 <byorgey> joe6: hehe =)
12:54:01 <joe6> byorgey: thanks a lot.
12:54:03 <byorgey> sure
12:59:10 <lispy> http://www.reddit.com/r/haskell/duplicates/idkd7/hac_pdx_ii_a_portland_haskell_hackathon_july_2224/
12:59:41 <edwardk> danharaj: i'm back
12:59:48 <edwardk> danharaj: duplicate = extend id
13:00:24 <edwardk> In the future all comonads are comonad transformers....
13:07:29 <tommd> dons: Did you manually run hackage2hwn for the frontpage h.o recent packages list?
13:07:40 <tommd> Or was that a daemon somewhere that died months ago?
13:22:25 <KitB> kitC: Oi what's going on here? :P
13:24:18 <kmc> looks like the rate of hackage uploads has plateaued in the past year or so
13:24:26 <kmc> after pretty steady growth
13:25:13 <kmc> cool, a C++ parser
13:25:58 <Eelis> kmc: where?
13:26:04 <kmc> LibClang
13:26:07 <Eelis> oh
13:26:29 <kmc> not only is it a C++ parser, but it's (bindings to) a C++ parser that lots of people work on and use
13:26:32 <kmc> so it probably actually works
13:26:38 <Eelis> yeah, i'm familiar with Clang
13:26:39 <kmc> parsing C++ is roughly the most hellish task in all of programming
13:26:43 <Eelis> i am well aware
13:26:46 <kmc> :)
13:32:32 <c_wraith> Wait, I thought parsing perl was also kind of bad....  Though for reasons that parsing it without executing it is undecidable
13:32:40 <Clint> is there a ghc version of perl Language::Haskell?
13:33:04 <kmc> what is that?
13:33:13 <Clint> Language::Haskell - Perl bindings to Haskell
13:33:19 <kmc> what does that mean
13:33:28 <kmc> parser and pretty-printer for Haskell code?
13:33:33 <Clint> no
13:33:36 <Clint> embedded haskell interpreter
13:33:46 <lispy> ghci-api
13:33:47 <Clint> http://search.cpan.org/~autrijus/Language-Haskell-0.01/lib/Language/Haskell.pm
13:33:57 <kmc> ok
13:34:03 <kmc> via hugs
13:34:33 <Clint> lispy: perl bindings?
13:34:38 <kmc> so you're asking about perl bindings for the GHC API?
13:35:08 <lispy> Clint: I thought you wanted a ghc version of an embedded haskell interpreter.
13:35:14 <lispy> Clint: I don't think I understand what you want
13:35:29 <kmc> i am not aware of any Perl bindings to the GHC API
13:35:35 * lispy is perl illiterate
13:35:40 <kmc> i was confused by the idea of "bindings to a language"
13:35:47 <Clint> what i really want is a method of calling pandoc functions from perl, without exec'ing the pandoc binary
13:35:51 <kmc> but i think it makes sense now
13:36:19 <kmc> Clint, ah.  why don't you want to exec pandoc?
13:36:26 <lispy> Clint: you can use the FFI to export Haskell functions to be callable by C then you can have the perl bind to the C?
13:36:28 <Clint> performance sucks
13:36:52 <lispy> Haskell<->C<->Perl
13:36:58 <Clint> lispy: can i do that without intruding into all the pandoc files?
13:37:21 <Younder> Does Haskell support SWIG?
13:37:26 <kmc> yeah; you can write a module which imports Pandoc and foreign exports stuff
13:37:38 <kmc> Younder, not afaik
13:38:00 <kmc> Clint, do you know why the performance sucks? is it just the start-up time for the pandoc binary?
13:38:15 <kmc> Clint, piping any kind of rich data through C is annoying
13:38:47 <kmc> i might instead start up a persistent Haskell process and talk JSON (or whatever) over a socket (or pipe or whatever)
13:38:59 <kmc> or even generate Read-able values for Pandoc structures in Perl
13:39:01 <kmc> and just send them over
13:39:07 <kmc> though performance of 'read' usually sucks too
13:39:14 <kmc> Clint, what are you trying to do with pandoc?
13:39:25 <Clint> no, i don't have any numbers on perl startup or pandoc startup.. the profiling was all in the perl functions
13:39:41 <Clint> i have need to render pandoc's variant of markdown from within ikiwiki
13:39:53 <Clint> and unfortunately nothing else understand's pandoc's variant
13:40:04 <kmc> and spawning the pandoc binary is too slow
13:40:05 <kmc> fair enough
13:40:06 <Clint> so i am using an ikiwiki plugin to call pandoc
13:40:17 <kmc> can you solve this with caching?
13:40:24 <kmc> does it render on every page view or just on edits?
13:40:30 <Clint> just on edits
13:40:33 <kmc> are your pages huge for some reason?
13:40:35 <Clint> but there are dependency trees
13:40:41 <Clint> there are tons and tons of footnotes
13:40:50 <kmc> ok
13:41:17 <kmc> on my system converting a modest markdown file to html with pandoc takes less than 0.1 sec realtime
13:41:28 <shachaf> Huge pages!
13:41:39 <kmc> :D
13:41:50 <kmc> Clint, do small pages render quickly?
13:41:55 <kmc> that would indicate that it's not just startup time
13:42:13 <kmc> if the computation pandoc's performing is slow, a lower-overhead interface won't help
13:42:48 <kmc> there are a few "generic" ways to make Haskell programs faster, though
13:42:49 <Clint> i don't know.. it's hard to profile things in smaller units
13:43:06 <kmc> since your pandoc invocation will be short-lived, it shouldn't bother garbage collecting at all
13:43:24 <Clint> we could try the caching or the persistent daemon.. i thought the perl bindings might be the easiest place to start
13:43:34 <kmc> so maybe something like "pandoc -i foo.text -o foo.html +RTS -A400M" will improve performance
13:44:03 <kmc> those all sound harder that figuring out if the interface overhead is the problem in the first place
13:44:18 <Clint> where can i read about those last two options?
13:44:35 <kmc> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#setting-rts-options
13:45:49 <Clint> thanks
13:46:03 <joe6> is there a better way of writing this: http://pastebin.com/uiKHCjG8  where nothingToZeros is http://pastebin.com/jvpKaexk
13:46:06 <mauke> The pastes uiKHCjG8 jvpKaexk have been copied to http://hpaste.org/48574 http://hpaste.org/48575
13:47:16 <Clint> is there an easy way to find the default allocation area size?
13:47:53 <kmc> it's on the page i linked
13:48:10 <Clint> wow, and i read that too
13:48:14 * Clint sighs.
13:49:08 <Botje> :t maybe
13:49:08 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:49:10 <Botje> joe6:  ^^
13:49:39 <Botje> you can replace catMaybes . map nothingToZeros with map (maybe "0000" id)
13:50:34 <joe6> Botje, that is cool. Thanks.
13:51:00 <kmc> ;t flip maybe id
13:51:05 <kmc> :t flip maybe id
13:51:06 <lambdabot> forall a. a -> Maybe a -> a
13:51:08 <kmc> :t fromMaybe
13:51:09 <lambdabot> forall a. a -> Maybe a -> a
13:51:17 <Botje> hah
13:51:17 <kmc> :t map (fromMaybe "0000")
13:51:18 <lambdabot> [Maybe [Char]] -> [[Char]]
13:51:20 <Botje> didn't know about that one :)
13:51:36 <Botje> kmc++ # new tricks!
13:52:19 <joe6> kmc, thanks.
13:52:39 <augur> Cale: your definition is giving me a scope error :(
13:52:47 <augur> its telling me s' isnt in scope
13:53:16 <danharaj> edwardk: Still there?
13:54:16 <benmachine> @djinn a -> Maybe a -> a
13:54:16 <lambdabot> f a b =
13:54:16 <lambdabot>     case b of
13:54:16 <lambdabot>     Nothing -> a
13:54:16 <lambdabot>     Just c -> c
13:54:28 <benmachine> @djinn a -> b -> a
13:54:28 <lambdabot> f a _ = a
13:54:47 <benmachine> I like how it tries to use the second argument even though it doesn't really need to
13:55:04 <augur> Cale: oh, i think i typed it wrong i guess
13:55:16 <benmachine> @djinn a -> Maybe a -> Either a a
13:55:16 <lambdabot> f a b =
13:55:16 <lambdabot>     case b of
13:55:16 <lambdabot>     Nothing -> Left a
13:55:16 <lambdabot>     Just c -> Left c
13:55:30 <benmachine> hm. fair enough
13:55:56 <augur> ah yes i did hmm
14:14:16 <eyu100_> @djinn a
14:14:16 <lambdabot> -- f cannot be realized.
14:14:20 <eyu100_> @djinn a -> a
14:14:20 <lambdabot> f a = a
14:14:33 <eyu100_> @type gfoldl
14:14:34 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall d b. (Data d) => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
14:14:41 <eyu100_> @djinn forall (c :: * -> *) a. (Data a) => (forall d b. (Data d) => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
14:14:41 <lambdabot> Cannot parse command
14:14:49 <eyu100_> @type runST
14:14:50 <lambdabot> forall a. (forall s. ST s a) -> a
14:14:57 <eyu100_> @djinn forall a. (forall s. ST s a) -> a
14:14:57 <lambdabot> Error: Undefined type ST
14:15:03 <eyu100_> @djinn forall a. (forall s. IO s a) -> a
14:15:03 <lambdabot> Error: Undefined type IO
14:15:16 <eyu100_> @djinn forall a. (forall s. s a) -> a
14:15:17 <lambdabot> -- f cannot be realized.
14:16:19 <hape01> Hi, I installed a minute ago some libraries on my ubuntu now cabal configure says "The following installed packages are broken because other packages they
14:16:22 <hape01> depend on are missing. These broken packages must be rebuilt before they can
14:16:24 <hape01> be used.
14:16:32 <hape01> and it shows a long long list............. what can I do? please help
14:16:55 <hape01> Everything is: "is broken due to missing package"
14:16:55 <danharaj> That sounds uncharacteristic, could you post the list of broken packages on hpaste.org?
14:17:12 <hape01> danharaj: yes I do!
14:17:14 <danharaj> and also the packages you installed?
14:17:50 <hpaste> Hartmut pasted “broken packages” at http://hpaste.org/48576
14:19:05 <NihilistDandy> hape01: Do you have extra-lib-dirs set in your .cabal/config?
14:19:50 <hape01> NihilistD: No, I haven't extra-lib-dirs set
14:20:38 <hape01> danharaj: I cant remember the packages. I thought I did just a "cabal configure" after I added the libicu-dev to ubuntu.
14:20:42 <NihilistDandy> I had a similar problem where cabal couldn't find the libraries in .cabal/lib, and adding that seemed to fix it
14:21:23 <hape01> NihilistD: that is interesting
14:21:26 <danharaj> hape01: Can you run ghc-pkg list and see if you have multiple copies of enumerator installed?
14:22:17 <hape01> danharaj: Yes I have:  enumerator-0.4.7
14:22:20 <hape01> sorry
14:22:29 <hape01> AND:  enumerator-0.4.10
14:22:50 <NihilistDandy> ghc-pkg hide enumerator-0.4.7 and try again?
14:22:55 <danharaj> well hold on a minute
14:23:08 <danharaj> if they had the same version, one would have hid the other.
14:23:19 <danharaj> I wonder why enumerator-0.4.10 got hidden...
14:23:24 <danharaj> (Wait, is it hidden?)
14:23:24 <hape01> ghc-pkg check
14:23:29 <hape01> brings tons of errors
14:23:40 <hape01> e.g. There are problems in package wai-0.3.2: dependency "network-2.3.0.2-8877dc2d14b1a0cbb5cd791e40f45e7d" doesn't exist
14:23:46 <danharaj> ah, could you annotate your paste with that too?
14:23:57 <hape01> I do
14:24:13 <danharaj> I'm sorry I don't have a straight answer right now, I don't use ubuntu.
14:24:57 <NihilistDandy> hape01: Did you install the Haskell Platform?
14:24:59 <hape01> Now the annoations in hpaste.org are done
14:25:05 <NihilistDandy> Wait, nevermind
14:25:16 <NihilistDandy> You must have, cabal being there, and all
14:25:22 <hpaste> Hartmut annotated “broken packages” with “broken packages (annotation)” at http://hpaste.org/48576#a48577
14:25:29 <benmachine> NihilistDandy: not necessarily
14:26:24 <mgccl> what does =<< mean? I saw it in main = xmonad =<< somestuff
14:26:25 <hape01> NihilistD: Yes I did months ago
14:26:26 <danharaj> hape01: One final annotation, can you add the output of ghc-pkg list?
14:26:36 <NihilistDandy> ^^
14:26:38 <danharaj> mgccl: It's >>= with arguments flipped.
14:26:41 <danharaj> :t <<=
14:26:42 <lambdabot> parse error on input `<<='
14:26:46 <benmachine> :t (=<<)
14:26:46 <danharaj> shut up lambdabot :(
14:26:46 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
14:27:30 <benmachine> mgccl: it's a way to feed monadic values to functions returning results in a monad
14:28:08 <hpaste> Hartmut annotated “broken packages” with “broken packages (annotation)” at http://hpaste.org/48576#a48578
14:28:30 <NihilistDandy> Oh, wait, no, it wasn't extra-lib-dirs... I just uncommented the install-dirs user section
14:28:43 <mgccl> thanks... it's actually a function lol, I thought it's some language construct like "="
14:28:57 <hape01> :-)
14:30:42 <NihilistDandy> On an unrelated note, does anyone else use docidx? https://github.com/gimbo/docidx.hs
14:30:44 <danharaj> mgccl: Language constructs in other languages are often just functions in Haskell. It's not as extreme as Lisp but it's very nice. It allows you to write your own mini-languages inside of Haskell.
14:30:57 <danharaj> hape01: Did NihilistDandy solve your problem?
14:32:50 <NihilistDandy> It's an awesome little script
14:39:53 <hape01> danharaj: No I am stuck
14:46:12 <Cale> hape01: It looks like something replaced many of your packages, but not all of them?
14:47:03 <hape01>  Cale: Yes indeed.
14:47:11 <Cale> hape01: Perhaps by recompiling them... the versions which are installed probably have different hashes attached to them (which would explain why it's complaining, e.g. that persistent-0.5.1 is missing, despite the fact that you have a version of it installed)
14:47:54 <hape01>  Cale: Ok, that means I make a list of packages, and make for any: cabal xxxx clean, cabal install ?
14:48:19 <hape01> Cale: Is this the right way of doing a "bulk" recompile?
14:48:36 <hape01> or do I "cabal install --reinstall"?
14:49:03 <Cale> Yeah, you might just consider blowing away ~/.ghc and the stuff under ~/.cabal (except maybe your config file) and just install stuff as you need it.
14:49:24 <hape01> Cale: Ah thanks! Good idea
14:49:34 <Cale> Well, technically, you shouldn't have to get rid of anything under ~/.cabal
14:49:51 <hape01> No matter how long it last to recompile :-)
14:50:18 <Cale> Yeah, it might save some time to keep ~/.cabal seeing as you have a lot of packages
14:50:37 <hape01> Ok
14:50:42 <Cale> It'll still need to reinstall them, but perhaps it won't have to actually rebuild *everything* then. :)
14:52:48 * hackagebot case-insensitive 0.2.0.2 - Case insensitive string comparison  http://hackage.haskell.org/package/case-insensitive-0.2.0.2 (BasVanDijk)
14:53:04 <Cale> hape01: I actually don't let ubuntu handle my ghc installation, which helps a bit with that.
14:53:35 <Cale> (I just install the generic linux binary, and then cabal-install, and install all packages as user from there)
14:53:48 <hape01> Cale: Some day I will understand whats going on, not yet ....
14:54:41 <drbean> Cale: Not Haskell Platform?
14:56:10 <Cale> drbean: I don't have a good reason why, but I tend not to.
14:56:17 <Phyx-> Cale: same here
14:56:33 <Phyx-> i just do vanilla installs + cabal-install
14:56:47 <Cale> cabal-install makes it easy enough to get the packages you need anyway
14:56:59 <Cale> and the only difference with HP is that it comes with some packages
14:57:52 <Phyx-> and network, which under windows atleast needs a posix environment to compile
14:57:55 <Phyx-> but a minor annoyance
15:00:01 <hape01> Cale: I have big confindence! purging all the ~/.ghc/ packages was a very good idea - as it seems to be well now (he is reinstalling a lot now) !! Thank you - even it is not finished yet - this could be fine now :-)   :-)
15:00:33 <Cale> hape01: great :)
15:03:09 <roconnor> the haskell report doesn't seem to tell me what is needed to be exported to have record updates work/not work.
15:09:31 <hape01> Cale: Finished! YOU saved my day.
15:17:07 <geheimdienst> > map show [0..9] ++ map (("F" ++) . show) [1..12]
15:17:08 <lambdabot>   ["0","1","2","3","4","5","6","7","8","9","F1","F2","F3","F4","F5","F6","F7"...
15:17:17 <geheimdienst> any ideas how to shorten this? ^^
15:22:49 <dylukes> Currently, I think the apocalypse will come in the form of a collective sentience of all ARM embedded devices. There are a lot of RISCy puns I'm going to make if that comes to pass.
15:32:16 <joe6> is there a better way of writing this: http://pastebin.com/V6v682Sd and the function usage is : http://pastebin.com/zDjwi3C8
15:32:19 <mauke> The pastes V6v682Sd zDjwi3C8 have been copied to http://hpaste.org/48580 http://hpaste.org/48581
15:33:10 <dylukes> mauke: For a second I thought you were a bot.
15:33:15 <dylukes> That would be a convenient lambdabot function
15:33:18 <dylukes> auto-repasting
15:33:32 <joe6> mauke, i think it is one of his scripts
15:33:34 <c_wraith> that is a bot function.  it's just happening on his main acount
15:33:34 <dylukes> I can throw together another bot to do that in the mean time if you'd like :|
15:33:46 <shachaf> dylukes: mauke is a bot doing exactly that.
15:33:51 <dylukes> make is a bot D:?
15:34:05 <dylukes> if so, he's got the best AI I've ever seen :P
15:34:18 <c_wraith> many people use IRC clients that can perform botlike functions without interfering with their use for chatting, too
15:34:41 <shachaf> My IRC client is a bot.
15:34:54 <shachaf> It responds to queries sent by the IRC server, like PING.
15:35:55 <c_wraith> * Ping reply from shachaf: 1.19 second(s)
15:36:02 <c_wraith> I think you could have type the response that quickly :)
15:36:06 <c_wraith> *typed
15:36:08 <shachaf> I meant IRC ping, not CTCP ping.
15:36:21 <dylukes> http://cl.ly/859y
15:36:22 <dylukes> :O
15:36:23 <dylukes> nan!?
15:36:31 <c_wraith> I'm sure your client responds to CTCP ping automatically, as well
15:36:44 <shachaf> That's true.
15:37:12 <shachaf> That's some serious window shadow, dylukes.
15:37:58 <dylukes> OS X has quite a bit of window shadow.
15:38:06 <dylukes> It's pretty diffuse on screen.
15:38:11 <dylukes> I barely notice it.
15:38:13 <shachaf> http://f.cl.ly/items/45000O3I031W1g0n2v0h/Image%202011.06.30%207:10:00%20PM.png
15:38:25 <dylukes> Yeah, on screen it's not very noticeable.
15:38:35 <dylukes> except when on top of a white window >.>
15:38:54 <dylukes> and, its only that strong for the active window heh
15:39:14 <dylukes> http://f.cl.ly/items/0t131f0y1m2n133T2n16/Image%202011.06.30%207:12:45%20PM.png
15:39:15 <dylukes> see?
15:39:48 <shachaf> Can you delete those screenshots now? :-)
15:39:57 <dylukes> sure?
15:40:14 <dylukes> done and done
15:40:18 <dylukes> why delete btw?
15:40:40 <shachaf> FSVO "done". The web server still has them.
15:40:44 * shachaf will give it time.
15:41:00 <dylukes> the web server will purge them in a bit.
15:41:17 <dylukes> the actual direct link (http://api.cld.me/859y/Image_2011.06.30_7_10_00_PM.png) is gone
15:41:22 <dylukes> as is http://cl.ly/859y
15:41:31 <dylukes> the only one that still exists in the internal storage, f.cl.ly
15:41:37 <dylukes> that purges regularly for files that are marked deleted.
15:41:41 <dylukes> mark and sweep invalidation.
15:43:06 <roconnor> @botsnack
15:43:06 <lambdabot> :)
15:51:53 <shachaf> Does "join (***)" have a nicer name (for (->), of course)?
15:52:09 <hpc> :t join (***)
15:52:10 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
15:52:19 <hpc> :t (&&&)
15:52:20 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:52:57 <Twey> shachaf: Not AFAIK
15:53:34 <Twey> ‘fmap (id *** id)’ maybe
15:53:59 <hpc> that's not nicer ;)
15:54:10 <benmachine> :t fmap (id *** id)
15:54:10 <lambdabot> forall b b' (f :: * -> *). (Functor f) => f (b, b') -> f (b, b')
15:54:30 * benmachine tries to work out how this is the same thing
15:54:41 <hpc> :t id *** id
15:54:42 <lambdabot> forall b b'. (b, b') -> (b, b')
15:54:57 <hpc> fmap (id *** id) = fmap id = id
15:55:01 <hpc> it's not even remotely close
15:55:22 <Twey> Er
15:55:29 <Twey> I meant fmap (id &&& id).  Sorry.
15:55:36 <benmachine> :t fmap (id &&& id)
15:55:37 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f (a, a)
15:55:46 <benmachine> that doesn't sound like the same thing either :P
15:55:46 <hpc> oh, much better :P
15:55:47 <nihtml> :t (&&&)
15:55:48 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:56:40 <Twey> > (.) (id &&& id)
15:56:40 <lambdabot>   Overlapping instances for GHC.Show.Show (f a -> f (a, a))
15:56:40 <lambdabot>    arising from a...
15:56:46 <Twey> :t (.) (id &&& id)
15:56:46 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f (a, a)
15:56:51 <Twey> :t join (***)
15:56:52 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
15:57:04 <Twey> No, it's not
15:57:17 <Twey> That's because I read the original question as being (***), too.  >.>
16:08:15 <ivanm> I have a function generateMobiles that produces a list of data
16:08:53 <ivanm> I then call mapMaybe on it (which rejects most of the data) and for the sake of testing I currently just return the length of the final list
16:09:24 <ivanm> so why is it that if I first do length ms `seq` ms from the result of generateMobiles before doing the mapMaybe the program is a little faster and uses a lot less memory? :/
16:09:57 <benmachine> ivanm: odd.
16:11:16 <ivanm> definitely
16:12:02 <Saizan> i'd suspect retaining issues in generateMobiles's thunks
16:12:31 <Peaker> hmm.. I thought Haskell2010 added TH?
16:12:33 <aavogt> ivanm: maybe forcing the length earlier lets ms get garbage collected earlier?
16:12:40 <ivanm> could be
16:12:51 <Saizan> Peaker: hah, no
16:13:11 <ivanm> profiling suggests that most of the memory usage comes from the mapMaybe bit though :/
16:14:12 <Saizan> heap profiling?
16:14:53 <Peaker> hmm... fclabels' mkLabels makes code that is not -Wall safe??
16:15:21 <c_wraith> it explicitly doesn't create type signature declarations for the labels
16:15:37 <c_wraith> Is there something else it does that -Wall complains about?
16:15:53 <Peaker> I think it does make type signatures as of some newer version
16:15:58 <Peaker> it complaints about shadowing
16:16:03 <c_wraith> oh.  funny.
16:16:06 <ivanm> Saizan: actually, you're right, heap profiling suggests un-released thunks within sub-functions of generateMobiles
16:16:55 <ivanm> the length ms `seq` ms also suddenly makes my usage of Put incrementally outputting data rather than all at the end :/
16:17:09 <dons> tommd: i manually ran it a couple of times, after the captcha was added
16:19:03 <ivanm> is the problem from what I'm doing in the Main file maybe? http://code.haskell.org/~ivanm/dangd/Main.hs
16:19:50 <ivanm> I've also tried testing it with "let c = length $ generateUndirectedDangDs d' n'" instead of the "c <- ..."
16:21:16 <ivanm> if it matters, generateMobiles is a recursive tree generation function
16:22:44 <Peaker> So many people keep asking about adding lifters to all code that uses a monad stack... Are Monad Transformer Tutorials emphasizing the newtype'ing and naming of lifters/ops for monad stacks enough?
16:23:04 <Peaker> on second thought, s/So many/At least some :-)
16:24:19 <Saizan> ivanm: err, i think the problem is probably inside generateMobiles
16:24:34 <ivanm> yeah....
16:25:07 * ivanm wonders if the error is possibly in his data structure rather than in the code directly...
16:28:06 <ivanm> Saizan: could it be because within the data structure that I'm using I have "foldr f" a few times that I should switch to "foldl' (flip f)" ?
16:29:52 <Saizan> ivanm: i can't tell with so little context
16:30:02 <ivanm> fair enough
16:30:51 <ivanm> from heap profiling, the biggest memory usage is in createBSubMobile in http://code.haskell.org/~ivanm/dangd/Data/Graph/Planar/DangD.hs
16:51:35 <joe6> i am trying to compose these functions and I am not sure how to do it: http://pastebin.com/F36s3esd
16:51:37 <mauke> The paste F36s3esd has been copied to http://hpaste.org/48582
16:52:49 <joe6> i can ilst out all the arguments and then just call them. but, I am curious on why I cannot compose them.
16:56:36 <Saizan> joe6: composition only handles one argument
16:57:18 <Saizan> \x -> TestLabel "writeProgramMemoryToBank1: " . writeProgramMemoryToSram 0x200 x  <- that would typecheck
16:58:34 <joe6> Saizan, oh, ok. Thanks.
17:51:05 <kaaaaaaahhhhnnnn> ?
18:21:15 <seafood> A quick question to the room. Composition has type (b -> c) -> (a -> b) -> (a -> c). Is there a function for composing a 1-ary function with a binary function? i.e. has type (c -> d) -> (a -> b -> c) -> (a -> b -> d). I know I can write my own but just wondering if there is a standard one.
18:21:39 <mauke> :t (.)(.)(.)
18:21:40 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
18:21:52 <NihilistDandy> @hoogle (c -> d) -> (a -> b -> c) -> (a -> b -> d)
18:21:52 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
18:21:53 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (d -> r') -> a -> r
18:21:53 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (d -> r') -> a -> r
18:21:59 <mauke> :t (.)(.)(.) :: (c -> d) -> (a -> b -> c) -> (a -> b -> d)
18:22:00 <lambdabot> forall c d a b. (c -> d) -> (a -> b -> c) -> a -> b -> d
18:22:58 <seafood> mauke: Thanks. That's it.
18:23:03 <xenocryst> I'm trying to represent a simple, directed graph. What's a good package?
18:24:55 <ivanm> xenocryst: fgl
18:25:07 <xenocryst> ivanm: sweet, thanks!
18:25:10 <ivanm> and graphviz for visualisation
18:25:34 <ivanm> there's also Data.Graph in containers, but it's very limited
18:26:26 <xenocryst> ivanm: I'm trying to solve a pretty simple thing and I don't think I'll need too much heavy lifting. I'll check out Data.Graph too
18:38:53 <ddarius> Antoine Dufour, why are you so ridiculous? http://www.youtube.com/watch?v=YQlyHbu0zz4 </off-topic>
19:10:10 <ivanm> preflex: seen sw17ch
19:10:11 <preflex>  sw17ch was last seen on #haskell 35 days, 4 hours, 35 minutes and 13 seconds ago, saying: fmap gorgonzola prosciutto
19:11:01 <NihilistDandy> lol
19:15:51 * Eduard_Munteanu wonders why ddarius isn't in -blah :D
19:16:05 <Eduard_Munteanu> A lot of sensible offtopic going on in there.
19:19:03 <augur> Cale!
19:19:05 <augur> backwards state just loops :(
19:24:08 <ivanm> when making NFData instances if you have an algebraic type with just constructors do you still have to list each one separately? (I'm guessing you do, just wanting to make sure)
19:26:43 <augur> oh i see why
19:26:48 <augur> i mean, i dont see why but i see why
19:27:24 <mauke> http://mauke.dyndns.org/stuff/haskell/posi.hs - probably unrelated
19:28:03 <copumpkin> ivanm: ?
19:28:33 <ivanm> copumpkin: if I have data Foo = Bar | Baz, when making the NFData instance do I have to do rnf Bar = (); rnf Baz = () ?
19:28:42 <ivanm> I would think so, but just making sure
19:28:52 <copumpkin> I'd think not, but dunno if GHC tries to be clever
19:28:53 <ivanm> (or is GHC smart enough/is there a better way?)
19:29:03 <copumpkin> one pattern match is enough for it to force it to whnf
19:29:07 <copumpkin> unless it's ~
19:29:10 <ivanm> because if you just used rnf = const (), then it won't force it, etc.
19:29:17 <ivanm> hmm... true
19:29:17 <copumpkin> oh yeah, not that
19:29:18 <NihilistDandy> I don't know how or when my browser's default plain text font got set to Inconsolata, but I am pleased
19:29:27 <copumpkin> f Nothing = (); f _ = () should be fine though
19:29:45 <copumpkin> I'd guess, unless it reasons about it being effectively a constant function (but then the other case would fail too)
19:30:08 <ivanm> what happens if there's exactly one constructor that isn't Nullary? use that one for explicit pattern matching and then the rest Should Work? :p
19:30:23 <copumpkin> it doesn't really matter which one you pick
19:30:30 <copumpkin> for it to be able to determine which constructor to call
19:30:36 <copumpkin> it needs to force the input to whnf
19:30:44 <ivanm> yeah, but if it isn't nullary then you need to force it's sub-values
19:30:48 <copumpkin> oh, sure
19:32:02 <ivanm> hmmm.... why doesn't deepseq have a version of $!?
19:32:07 <ivanm> * $! ?
19:42:44 <Jafet> Why not $!!?
19:42:50 <Jafet> @src ($!)
19:42:50 <lambdabot> f $! x = x `seq` f x
19:46:22 <ivanm> yeah, that's what I've just defined and am using
19:46:56 <ivanm> hayoo doesn't report it as being used
19:47:45 <augur> is there a evaluation mode with stepping?
19:48:01 <tsuraan> is anybody here familiar with the cereal library?  I'm parsing a binary protocol where I have a few different chunks of data to parse out, and the best thing I can think of using cereal is nested invocations of getTwoOf.  Is that sane, or is there a better way?
19:48:16 <Eduard_Munteanu> augur: you can do something like that in ghci
19:48:22 <augur> Eduard_Munteanu: awesome, how? :D
19:48:51 <mauke> builtin debugger
19:48:52 <tsuraan> i.e. to get four word16be out of a bytestring, I'd do getTwoOf (getTwoOf word16be word16be) (getTwoOf word16be word16be).  that works, but it seems wrong
19:48:55 <Eduard_Munteanu> Grr, lemme remember...
19:48:56 <Eduard_Munteanu>    :step <expr>                single-step into <expr>
19:49:58 <augur> oh but you have to have break points
19:52:51 <vash> would it be easier to start with scheme instead of haskell?
19:53:12 <augur> vash: depends on your goals
19:53:30 <augur> scheme has very little built it; its intentionally minimalist to show you a lot of ground-up stuff
19:53:54 <augur> but that makes it hard to get all the way to some interesting high level stuff
19:54:05 <ezyang> Anyone used FRP to do incremental computation?
19:54:18 <augur> whereas haskell is high level enough to get to that interesting stuff quickly, but you dont see the guts of why things work
19:54:23 <augur> you see different sorts of guts
19:54:45 <vash> I just want to get my feet wet within the functional programming world
19:54:56 <augur> vash: do haskell.
19:55:30 <vash> okay thanks... coming from straight c this should be an experience
19:55:59 <Jafet> There are worse languages to come from, so don't worry too much
19:56:02 <Jafet> @where lyah
19:56:02 <lambdabot> http://www.learnyouahaskell.com/
19:56:17 <d7> Hmm
19:56:18 <augur> vash: tip for coming from c: everything is function calls that return values.
19:56:24 <augur> keep that in mind
19:56:34 <hpaste> KirinDave pasted “It breaks” at http://hpaste.org/48583
19:57:11 <hpaste> KirinDave pasted “It breaks” at http://hpaste.org/48584
19:57:23 <hpaste> KirinDave pasted “It breaks” at http://hpaste.org/48585
19:57:34 <d7> Can anyone help me fix this?
19:57:34 <Jafet> </3
19:57:41 <Eduard_Munteanu> augur: anyway, what are you hoping to get out of stepping?
19:57:48 <d7> (sorry, I didn't realize it was shouting to the room :\)
19:57:51 <Eduard_Munteanu> I think it's not terribly useful for debugging.
19:57:59 <augur> Eduard_Munteanu: an understanding of these backwards state monads
19:58:17 <augur> im going through conal's post and its hard to grok where things are going
19:58:22 <vash> hmm thanks for that tip...  I guess i'll check out learnyou and then realworld
19:58:23 <Eduard_Munteanu> Maybe you can try Debug.Trace stuff.
19:58:32 <Eduard_Munteanu> *stuff first.
19:58:41 <augur> Eduard_Munteanu: maybe!
19:58:44 <Eduard_Munteanu> @hoogle trace
19:58:44 <lambdabot> Debug.Trace trace :: String -> a -> a
19:58:45 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
19:58:45 <lambdabot> module Debug.Trace
19:58:53 <augur> vash: lyah is a good starting point.
19:59:18 <Eduard_Munteanu> augur: which post is that? /me might find it interesting :)
19:59:30 <augur> http://conal.net/blog/posts/adding-numbers/
19:59:33 <Eduard_Munteanu> Thanks.
20:00:04 <gfarfl> d7: I think you're missing a return type in your type signature
20:03:56 <d7> gfarfl: No, Enumerator is a type over a -> b
20:04:58 <d7> err, type alias over a -> b.
20:05:06 <d7> What confuses me is why it is saying "s0".
20:05:46 <d7> Do I have it totally wrong?
20:06:53 <d7> I guess i don't get how to keep the recursion going.
20:10:37 <vash> ah ... are monads really as difficult as people claim? I know that's probably a bit off
20:10:50 <d7> vash: No.
20:11:09 <d7> vash: http://learnyouahaskell.com/chapters has all you need to know to get started.
20:13:05 <vash> right I was just reading around seeing what people had to say about the language
20:13:22 <vash> I'm reading lyah right now well I guess I'll come back if I get stuck.. thanks!
20:15:12 <d7> vash: Monads are not difficult in the sense that they're actually pretty obvious in the basic case.
20:15:25 <Eduard_Munteanu> vash: don't! Come back anyway! :)
20:15:36 <d7> vash: But that doesn't mean each individual instance of monad and their sundry uses will be obvious.
20:19:52 * edwardk1 waves hello.
20:20:04 <edwardk1> comonad transformers given just a comonad http://comonad.com/reader/2011/a-product-of-an-imperfect-union/
20:20:33 <edwardk1> trying to rapidly make up for the last year or so of not posting ;)
20:21:11 <copumpkin> edwardk1: you accidentally a word
20:21:21 <copumpkin> "The key observation is that by in one case we would up with something "
20:21:29 <edwardk1> ah
20:21:41 <d7> Man, I am only making this worse...
20:22:01 <edwardk1> 's what i get for not sticking around and getting you to proofread this one =)
20:22:09 <copumpkin> :P
20:22:11 <copumpkin> I left pretty early too
20:22:13 <edwardk1> d7: hah, i have a fun monad, just don't know what its good for yet ;)
20:22:26 <augur> Eduard_Munteanu: oh man, this circular programming crap is so hard to follow
20:22:27 <augur> :(
20:23:12 <edwardk1> augur: clearly you need more codensity
20:23:20 <d7> edwardk1: Can it help me write this enumerator?
20:23:22 <augur> edwardk1: shut your face
20:23:24 <copumpkin> edwardk1: you also have a weird formatting issue where some text turned monospace after your comonad coproducts
20:23:26 <augur> :|
20:23:27 <d7> edwardk1: That'd be a really good monad.
20:23:36 <edwardk1> d7: enumerator?
20:23:52 <d7> Oh wait.
20:23:54 <d7> I got it.
20:24:00 <d7> Hell yes!
20:24:08 <edwardk> copumpkin: hrmm, looking
20:24:39 <Eduard_Munteanu> "In the last few posts, I've been talking about how we can derive monads and monad transformers from comonads. Along the way we learned that there are more monads than comonads in Haskell."   -- neat, I suppose I need to catch up with your posts
20:24:50 <edwardk> fixed
20:25:22 <copumpkin> you also have "we'l"
20:25:53 <Eduard_Munteanu> augur: yeah, I skimmed a bit through it, will read it more thoroughly later.
20:26:00 <edwardk> text search doesn't find that one. where is it?
20:26:01 * copumpkin gotta sleep
20:26:03 <alfa_y_omega> comonads = mutual monads?
20:26:13 <copumpkin> "I use scary air-quotes around braid"
20:26:16 <edwardk> alfa: nah, the categorical dual of monads
20:26:17 <Eduard_Munteanu> alfa_y_omega: mm, nope
20:26:18 <copumpkin> that sentence
20:26:18 <edwardk> ah
20:26:34 <copumpkin> the parenthesis could also use some closing
20:27:14 <edwardk> fixed both
20:27:22 <NihilistDandy> Great, another blog whose backlog I must consume. :P
20:27:43 <edwardk> NihilistDandy:  =)
20:27:57 <djahandarie> NihilistDandy, don't worry, it'll be a fast read
20:28:06 <Eduard_Munteanu> edwardk: btw, is extract/extend/duplicate your terminology or you didn't invent it?
20:28:16 <Eduard_Munteanu> I see Wikipedia uses those.
20:28:23 <edwardk> Eduard_Munteanu: i inherited it
20:28:25 <djahandarie> It's not
20:28:30 <alfa_y_omega> if monads and comonads are pair then are there the same for transformers's pair?
20:28:36 <edwardk> i stole it from zednenem's original category-extras.
20:29:00 <Eduard_Munteanu> Oh. I thought that was your code.
20:29:00 <dobblego> alfa_y_omega: yes there are comonad transformers
20:29:02 <c_wraith> is there a paper out there on the original implementation of the threaded runtime?
20:29:09 <alfa_y_omega> aka are there monad's transformers and comonad's transformers?
20:29:15 <NihilistDandy> The best part of Haskell is that 80% of module names can be turned into clever blog titles.
20:29:17 <edwardk> alfa_y_omega: comonads are what you get when you run the arrows backwards on the definition of a monad. there are comonad transformers
20:29:24 <edwardk> i have a package full of them on hackage
20:29:27 <kmc> are there comonad cotransformesr?
20:29:42 <edwardk> compare the comonad-transformers package's members to those in transformers
20:29:44 <dobblego> class ComonadTrans f where lower :: Extend g => f g a -> g a
20:29:46 <djahandarie> kmc, no
20:29:47 <Eduard_Munteanu> @remember NihilistDandy The best part of Haskell is that 80% of module names can be turned into clever blog titles.
20:29:47 <lambdabot> It is stored.
20:29:48 <alfa_y_omega> are equivalent both transformers?
20:29:50 <Eduard_Munteanu> Heh, you asked for it :)
20:29:51 <edwardk> kmc: technically comonadtransformers lower
20:30:00 <edwardk> alfa_y_omega: yeah
20:30:03 <d7> edwardk: I was working on getting this right: http://hpaste.org/48586
20:30:08 <d7> I think got it.
20:30:27 <NihilistDandy> Eduard_Munteanu: The honor is all mine :D
20:30:35 <edwardk> d7: looks clean at least =)
20:30:35 <Eduard_Munteanu> Wait, you use 'lower' as a dual to 'lift'?
20:30:39 <edwardk> Eduard_Munteanu: yeah
20:30:48 <edwardk> lower :: Extend w => t w a -> w a
20:30:59 <d7> edwardk: Well supposedly Iteratees save a lot of code. :D
20:31:08 <edwardk> you can throw away 'part' of a comonadic context. instead of lift a simpler monad into a larger monad
20:31:40 <edwardk> Extend is a superclass of comonadthat supplies just the extend/duplicate and not the extract functionality
20:31:53 <edwardk> turns out that all interesting comonad transformers can be done with just that
20:32:11 <edwardk> on the other hand there are some monad-transformers that wouldn't be bind-transformers
20:32:21 * dobblego is on the no point/copoint crusade
20:32:39 <djahandarie> dobblego, why?
20:32:42 <d7> edwardk: I'm just happy that I realized that since Enumerator a m b is a type alias over a function, I could leverage that to make it cleaner. This is a big deal to me. :)
20:32:45 <Eduard_Munteanu> I wonder, would there be any connection between 'lift'/'lower' in (co)monad transformers and the distributivity law when combining monads and comonads?
20:32:57 <edwardk> those tend to be the ones that are ill behaved with regards to monadplus laws, etc.
20:33:01 <alfa_y_omega> is composition of monad's transformer and comonad's transformer, or vicersa, equal to identity transformer?
20:33:05 <dobblego> djahandarie: because it rules out some useful data structures, particularly in transformer version
20:33:07 <edwardk> Eduard_Munteanu: yes!
20:33:20 <Eduard_Munteanu> Oh? Did you blog about it? :)
20:33:24 <edwardk> the connection is subtle though
20:33:30 <edwardk> not per se
20:33:31 <Eduard_Munteanu> Ah.
20:33:51 <Eduard_Munteanu> I was hoping one could extract lift/lower from a general distributivity law.
20:34:25 <edwardk> if you have an adjunction f -| g from Hask -> Hask, then the the right adjoint g is 'Distributive' nd the left adjoint f is (usually) Traversable
20:34:43 <edwardk> actually, it can always be traversable. i need to add that code actually
20:35:01 <djahandarie> dobblego, oh, you mean using semigroupoids and friends?
20:35:14 <edwardk> traversable is a distributive law, distributive is the one that goes the other way
20:35:27 <edwardk> @type Data.Traversable.sequence
20:35:28 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
20:35:28 <dobblego> djahandarie: yes, pretty much
20:35:44 <Eduard_Munteanu> Oh, hrm.
20:35:52 <NihilistDandy> This is my favorite diagram on all of wikipedia: http://en.wikipedia.org/wiki/File:Magma_to_group2.svg
20:35:53 <djahandarie> Okay, well, then yes, appropriate model for the structure :)
20:36:06 <edwardk> but like with the comonad transformer case, that we don't need all the crap we need to make traversable work on the monad side, there we can get by with just a Functor rather than a Comonad.
20:36:21 <edwardk> er s/comonad transformer/distributive/
20:36:34 <alfa_y_omega> how to convert a monad m to a comonad com ?
20:36:35 <edwardk> see the distributive package on hackage
20:36:55 <edwardk> alfa_y_omega: you can't do so directly, no such general construction exists.
20:37:06 <edwardk> every monad is a comonad on the dual category and vice versa
20:37:11 <djahandarie> edwardk, have you been following the homotopy type theory stuff, btw?
20:37:16 <edwardk> djahandarie: a bit
20:37:23 <djahandarie> Pretty neat
20:37:30 <edwardk> i work with dolio and copumpkin so its hard to avoid at the office some times ;)
20:37:34 <djahandarie> Haha
20:38:08 <djahandarie> I wish I knew more about it
20:38:08 <edwardk> alfa_y_omega: i have some really old slides introducing comonads one sec.
20:38:16 <alfa_y_omega> edwardk, i confused terms
20:38:26 <alfa_y_omega> i'll reformulate it again
20:38:43 <djahandarie> I feel like I've wasted the opportunity to annoy the hell out of mike shulman with questions about it in the past two and a half weeks :p
20:39:05 <copumpkin> djahandarie: then take more advantage of him :)
20:39:21 <alfa_y_omega> how to convert the category of its associated (co)monad m to co-category of its associated monad(co) m'?
20:39:45 <djahandarie> copumpkin, well, I did at least get him to prove that the extra triangle isn't needed for braided monoidal categories
20:39:47 <edwardk> alfa_y_omega: you might find these helpful http://comonad.com/haskell/Comonads_1.pdf
20:39:48 <alfa_y_omega> well, the category isn't explicited in some functions.
20:40:01 <djahandarie> copumpkin, but now I need to figure out how the hell to do that proof in Agda :<
20:40:31 <Eduard_Munteanu> alfa_y_omega: mostly because it's always Hask
20:40:33 <copumpkin> djahandarie: lol, well, can you state it? :P
20:41:22 <edwardk> alfa_y_omega: while every monad in haskell is a comonad on hask^op, that insight doesn't turn out to be all that useful most of the time. though there are also comonads on hask.
20:41:35 <djahandarie> copumpkin, well, he drew some crazy diagram
20:41:38 <edwardk> the latter are what i've been talking about on my blog
20:41:51 <djahandarie> I can pretty much convert it into hom reasoning but I'm not sure it's going to go so smoothly
20:42:28 <edwardk> diagrams are easy to translate. the commuting squares are just foo . bar = baz . quux ;)
20:42:41 <Eduard_Munteanu> NihilistDandy: hm, nice
20:42:53 <edwardk> then you stitch together those proofs to make bigger diagrams
20:42:57 * Eduard_Munteanu remembers some old books here call magmas groupoids
20:43:54 <NihilistDandy> Eduard_Munteanu: I use that diagram whenever I need to explain differences between structures to someone. Flow charts make everything so simple. :D
20:45:47 <Eduard_Munteanu> (and as I found out some time ago, some English old books call categories monoidoids :D)
20:46:02 <edwardk> monoidoid is always fun when i trip over it =)
20:46:15 <djahandarie> copumpkin, http://althack.org/braided.jpg
20:46:31 <djahandarie> copumpkin, he proved that the triangle with a ? in it commutes by the rest of the diagram commuting
20:46:45 <copumpkin> fun
20:46:56 <kmc> Eduard_Munteanu, I'd actually have had an easier time learning what a category is if they were still called that
20:47:04 <djahandarie> kmc, same.
20:47:09 <kmc> to me a category is basically a "typed monoid"
20:47:20 <djahandarie> If I ever write "Learn you a category theory" I'm going to at least mention that name
20:47:35 <sanjoyd> kmc: how is it a typed monoid?
20:47:39 <sanjoyd> It has two kinds of objects, right?
20:48:17 <kmc> sanjoyd, focus on the morphisms / arrows / whatever you want to call them
20:48:26 <edwardk> sanjoyd: we usually ignore the objects
20:48:34 <kmc> they have an associative binary operation, and identity, but not necessarily inverses
20:48:36 <kmc> so they're like a monoid
20:48:48 <kmc> but you can't apply the operation to just any two arrows
20:48:53 <kmc> they have to have "compatible types"
20:49:07 <edwardk> sanjoyd: a monoid is just a category with one object, where the 'arrows' are your original monoidal values.
20:49:07 <sanjoyd> Oh, okay.
20:49:22 <Eduard_Munteanu> kmc: hm, nice
20:49:30 * sanjoyd just started reading category theory.
20:49:41 <sanjoyd> Goes well with my morning coffee. :)
20:49:47 <sanjoyd> Any suggestion for texts?
20:49:57 <djahandarie> I have still not found a good intro ct text
20:49:57 <Eduard_Munteanu> sanjoyd: why isn't ##categorytheory on autojoin there? :P
20:49:58 <danharaj_> A category is a monoidoid
20:50:06 <djahandarie> danharaj_, a little late there
20:50:10 <danharaj_> pff
20:50:17 <Eduard_Munteanu> :)
20:50:18 <danharaj> in my reference frame, you're the late one
20:51:01 <danharaj> but I don't think there's an intro to CT text
20:51:08 <djahandarie> There are plenty
20:51:10 <danharaj> because category theory is a unifying language for advanced ideas.
20:51:24 <alfa_y_omega> edwark, i'm reading your pdf, there's a new comment from me for you
20:51:27 <copumpkin> not at the angle that most programmers approach it from
20:51:32 * sanjoyd is reading A Gentle Introduction to Category Theory - A calculational approach
20:51:56 <djahandarie> danharaj, I don't really think that makes it complicated.
20:52:01 <edwardk> category theory sees lots of applications in programming that don't require a lot of deep mathematical background to start to see
20:52:32 <alfa_y_omega> (.) :: (b->c) -> (a->c) -> (a->c)   and (.') :: (a->c)->(b->c)->(a->c) are equivalent
20:52:36 <edwardk> lots of folks grok Functor and Monad without ever spending time staring at a category
20:52:59 <danharaj> Yeah but if they grok it, it's because they're working at a fairly advanced level of programming.
20:53:00 <edwardk> is there one too many 'c's in there?
20:53:11 <djahandarie> Well, you aren't really working with categories very much with Haskell's Functor and Monad
20:53:27 <alfa_y_omega> err, a->b, not a->c
20:53:37 <alfa_y_omega> (.) :: (b->c) -> (a->b) -> (a->c)   and (.') :: (a->b)->(b->c)->(a->c) are equivalent
20:53:41 <edwardk> djahandarie: i'm not claiming you are. i'm just saying that you don't have to be a die hard mathematician to get some benefit from the ideas.
20:53:46 <Eduard_Munteanu> :t (>>>)
20:53:47 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
20:53:48 <edwardk> sure
20:53:53 <edwardk> (.) and flip (.)
20:54:12 <edwardk> the slides flip around the definition of monad to make it clear which arrows should be flipped
20:54:15 <djahandarie> edwardk, I don't think that's the most convincing argument that category theory is easy, if that's what you were trying to say.
20:54:38 <alfa_y_omega> but the class Category doesn't recognizes the  (.'), the equivalent to (.)
20:54:40 <Eduard_Munteanu> I think it depends a lot on the examples you choose.
20:54:58 <edwardk> not saying its easy, but i am saying i don't by the conventional wisdom that you need to be steeped in homology before it becomes relevant to your life as a mathematician either.
20:55:02 <Eduard_Munteanu> Sure, considering what MacLane chose, maybe it's not really approachable.
20:55:38 <edwardk> @type (<<<)
20:55:39 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
20:55:45 <edwardk> @type (>>>)
20:55:45 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
20:55:53 <edwardk> they just give them different names =P
20:56:08 <danharaj> edwardk: Certainly having a knowledge of basic topology and algebra is required to make it palatable if you're going at it from a math point of view. And if you're going at it from a computer science point of view, a basic knowledge of type theory and functional programming seems essential.
20:56:47 <Eduard_Munteanu> Algebra is pretty much needed, usually.
20:56:49 <alfa_y_omega> @type (.)
20:56:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:56:59 <Eduard_Munteanu> @type (Prelude..)
20:57:00 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
20:57:03 <edwardk> danharaj: when teaching the latter i usually try to impart a little bit of category theory as folks learn type theory
20:57:24 <edwardk> @type (Control.Category..)
20:57:24 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
20:57:25 <djahandarie> danharaj, why would those be required?
20:58:33 <danharaj> djahandarie: Because CT is fairly abstruse unless you're already comfortable with examples of categories, just not in the language of CT.
20:58:33 <edwardk> i agree that having a deep mathematical maturity helps a whole hell of a lot
20:59:12 <djahandarie> danharaj, I think that's only becuase people suck at explaining it.
20:59:41 <mustelo> at the most basic level, if you don't care about rigor, you won't care about CT
20:59:43 <edwardk> but i do think the current way its taught is largely to blame. the computational world is a wonderful place to see a lot of those scary ideas in action. you can't do everything, but you can cover a lot of ground, and build intuition
20:59:44 <NihilistDandy> Set's not a deeply unfamiliar category, even for undergrads.
20:59:57 <augur> are there any time-travelling monads that _dont_ depend on circular definitions?
20:59:57 <augur> x.x
21:00:00 <NihilistDandy> They just don't know it's a category
21:00:21 <danharaj> Well Set is nice, but having Set and Top to compare is really nice.
21:00:41 <edwardk> augur: ultimately you need to get the answer flowing the 'wrong way' so there will be some circular definition somewhere
21:00:50 <augur> edwardk: :(
21:00:51 <Eduard_Munteanu> Pos is also approachable if you know a bit of algebra.
21:00:55 <augur> circular definitions are so hard to grok
21:01:12 <edwardk> circular definition: see circular definition.
21:01:14 <ivanm> does profiling with -hc consider functions that are from other libraries?
21:01:20 <Eduard_Munteanu> Heh.
21:01:21 <alfa_y_omega> uncurry, permutate, curry, XD
21:01:25 <NihilistDandy> danharaj: True, but as a base, Set is the most commonly approachable category. It's an incomplete picture, but it's a sketch, at least
21:01:28 <djahandarie> danharaj, I 100% understand what a dagger symmetric monoidal closed category is and I don't know crap about quantum mechanics.
21:01:29 <NihilistDandy> Relations are easy
21:01:45 <augur> edwardk: is there a nice exposition on when circular definitions arent obnoxious? because i know its possible to accidentally try to eat your cake and have it too with them
21:01:46 <edwardk> and Hask is just a nice constructive-ish applied Set
21:01:48 <alfa_y_omega> combinatoric explosion, XD
21:01:57 <Saizan> edwardk: re your comment on bido: do you have some shareable example that makes use of a (co)monad over a [co]kleisli category?
21:02:06 <NihilistDandy> edwardk: Yup yup :D
21:02:26 <Eduard_Munteanu> augur: mm, maybe it helps as an exercise, have you seen doubly-linked lists in Haskell?
21:02:28 <danharaj> djahandarie: certainly once you understand what a category is, learning new ones isn't as hard. The initial step is difficult because you have to take a very high altitude view of things.
21:02:32 <edwardk> Saizan: i have some code lying around that builds an imperatively memoized store comonad over kleisli IO for instance.
21:02:35 <augur> edwardk: no
21:02:37 <augur> er
21:02:39 <augur> Eduard_Munteanu: no
21:02:41 <Eduard_Munteanu> augur: or more generally stuff done by "tying the knot"?
21:02:48 <djahandarie> danharaj, a category itself is an extremely simple structure.
21:02:53 <augur> probably not, Eduard_Munteanu
21:03:06 <edwardk> also, my reactor machinery has an observable monad that is a comonad over the kleisli category of my task monad
21:03:08 <alfa_y_omega> category is forgotting to Curry of lambda calculus.
21:03:14 <djahandarie> danharaj, and people can learn monoids just fine, so categories are no big deal.
21:03:31 <danharaj> djahandarie: People can grok monoids quickly because they know so many examples of monoids.
21:03:49 <danharaj> But then again, it took thousands of years before the concept of a monoid was derived from the first example of one :)
21:03:56 <Eduard_Munteanu> augur: http://www.haskell.org/haskellwiki/Tying_the_Knot#Migrated_from_the_old_wiki
21:04:01 <djahandarie> Okay, but if they grok them in any reasonable sense then a category is just a step away.
21:04:11 <edwardk> but in general, having the computational world, partial orders, linear transformations, and set, you can provide a lot of nice 1-category-theoretic examples
21:04:23 <Saizan> edwardk: i was curious to see how it worked out syntactically
21:04:27 <edwardk> including showcasing pretty much every technique in mac lane
21:04:48 <edwardk> Saizan: i'll need to dredge up the laptop it was on, so i'll probably be tomorrow at the earliest
21:04:54 <edwardk> er it'll
21:05:20 <edwardk> i also don't have nice 'categorical' comonads in anything i want to build on any more =)
21:05:50 <Saizan> no rush :)
21:06:29 <Saizan> so you're abandoning Comonad's ?:)
21:06:30 <danharaj> How much of GHC's type system can you capture by describing the category Hask?
21:06:38 <edwardk> alfa_y_omega: actually the lambda calculus has a lot of structure as categories go
21:06:58 <edwardk> depends on what category Hask you define ;)
21:06:59 <djahandarie> danharaj, all of it?
21:07:12 <danharaj> djahandarie: What are GADTs in Hask?
21:07:18 <edwardk> just need to find a category for which the typing judgments are the internal language of the category ;)
21:07:19 <alfa_y_omega> lambda calculus was untyped when it was born
21:07:37 <alfa_y_omega> categories are types's dependent
21:07:51 <danharaj> untyped lambda calculus is just simply typed lambda calculus over one type.
21:08:03 <Eduard_Munteanu> danharaj: plain functors I think
21:08:15 <edwardk> you can make a category with one type just like you can make an 'untyped' lambda calculus of one type
21:08:24 <alfa_y_omega> later, Curry invented the curry and uncurry transformers
21:08:34 <edwardk> alfa_y_omega: nah that was shoenfinkel
21:08:48 <Eduard_Munteanu> Note not all extensions would bear a relation with the type system, or one that makes a fundamental difference.
21:09:36 <kmc> danharaj, no it's not
21:09:43 <danharaj> kmc: what you say.
21:09:44 <augur> Eduard_Munteanu, edwardk, Saizan: im teaching some friends haskell, and ive made an outline of topics. can i get your opinions? http://workflowy.com/shared/248d87b9-95d8-3a49-3cb5-a003eb328d9c/
21:09:49 <kmc> untyped lambda calculus allows lots of things that aren't allowed in any STLC
21:09:50 <alfa_y_omega> the (.) could be uncurried, permuted the order of the parameters and then to be curried by changed the order of the parameters
21:09:54 <kmc> like recursion ;P
21:10:21 <danharaj> kmc: You just have to say (A -> A) = A
21:10:34 <alfa_y_omega> (.) f g and (.') g f are equivalent
21:10:39 <kmc> that's not a rule of STLC though
21:10:49 <edwardk> augur: a lot of focus on recursion schemes fairly early
21:10:53 <djahandarie> danharaj, I don't think GADTS affect much. You get System F with an internal full subcategory of a effective topos. System F_c adds some crazy stuff which certianly has not been worked out yet, but I don't see any fundamental reason it can't.
21:11:00 <djahandarie> certainly*
21:11:07 <Eduard_Munteanu> augur: your friends are patient :P. I mean, with all those recursion schemes your pushing :)
21:11:21 <augur> edwardk: i can swap orderings
21:11:32 <augur> im not really fixed on the ordering of the topics
21:11:35 <Eduard_Munteanu> *you're
21:11:36 <augur> except the first one :)
21:11:38 <kmc> if you add a typing judgement «Γ ⊢ e : (A → A)» ⇒ «Γ ⊢ e : A» then it's a new type system
21:11:49 <alfa_y_omega> there are two classes of (.) for two parameters f and g
21:11:53 <alfa_y_omega> it's 2! = 2
21:11:54 <edwardk> kmc: true
21:12:06 <Eduard_Munteanu> I guess it depends a lot on their background and interests.
21:12:16 <danharaj> kmc: fair enough. all the machinery stays the same though, IIRC
21:12:22 <augur> Eduard_Munteanu: linguistic semantics for one, plt for the other
21:12:22 <alfa_y_omega> there are six permutation's classes of (.) for three parameters f, g, h, it's 3!=6,
21:12:32 <alfa_y_omega> and so on for higher number of parameters.
21:12:36 <Eduard_Munteanu> If they're linguists and don't know much about programming (as you said), it's not going to be easy.
21:13:18 <augur> well the linguist knows a little bit of sicp-type stuff, and knows a good amount about classical logic
21:14:04 <Eduard_Munteanu> Ah, if they handle some math alright, then I suppose it's not that bad.
21:14:16 <alfa_y_omega> if many permutations so applied to many graph's arrows then you'll find a better graph's simplification, but it will be computationally costous.
21:14:37 <augur> i mean, i can reorder things, i just wrote stuff up as they came to mind, not as i thought they should be ordered
21:15:07 <Eduard_Munteanu> augur: is this supposed to work them up to understand your Agda stuff?
21:15:25 <Eduard_Munteanu> If so, maybe the computational aspects are less relevant.
21:15:28 <augur> if i move the recursion schemes after type systems, ill move the functor/fixed-point to after recursion schemes
21:15:32 <edwardk> day 1.) hello world. day 2.) codensity
21:15:40 <Eduard_Munteanu> :)
21:15:41 <augur> edwardk: diaf kthx
21:15:51 <edwardk> =)
21:16:12 <augur> Eduard_Munteanu: eh. no, not so much. its mostly just to get them thinking computationally ;p
21:16:24 <alfa_y_omega> a stupid heuristic is applying permutations of 2-window, 3-window, 4-window and 5-window.
21:16:25 <augur> edwardk: seriously, why is codensity so awesome.
21:16:33 <edwardk> beat on things in a rather first order recursive programming sense for a while
21:16:43 <edwardk> augur: i just wrote 5 blog posts on the topic ;)
21:16:44 <augur> edwardk: ?
21:16:54 <augur> first order recursive programming sense?
21:17:06 <augur> yeah i know you wrote 5 blog posts on the topic, but none of them make any sense!
21:17:15 <sanjoyd> Okay, I still am not clear on why runST (newSTRef 0) is a type error.
21:17:20 <alfa_y_omega> 5-window is 5! = 120 ordering cases
21:17:25 <sanjoyd> > runST (newSTRef 0)
21:17:26 <lambdabot>   Inferred type is less polymorphic than expected
21:17:26 <lambdabot>    Quantified type variable...
21:17:42 <edwardk> e.g. have them write sum (x:xs) = x + sum xs; sum [] = 0 — kinda stuff until they are sick of it for a couple of days, then once they feel the pain of the repetition, foldr (+) 0 will seem like magic
21:17:43 <augur> edwardk: http://a3.twimg.com/profile_images/1283001030/37398_433625455338_553770338_6342890_6118382_n.jpg << you?!
21:17:47 <augur> with the goatee?!
21:17:59 <Eduard_Munteanu> sanjoyd: that's   runST $ do {a <- newSTRef 0; return a}
21:18:01 <edwardk> and then catamorphisms follow from that when you want to do the same thing over more general shapes
21:18:12 <edwardk> thats me
21:18:15 <augur> crazy
21:18:48 <augur> edwardk: were meeting once a week for like 2 hours, so itll have to be assigned problems but sure
21:18:52 <Eduard_Munteanu> sanjoyd: so 's' ends up in the result type
21:18:56 <edwardk> the irony here is that I was explaining codensity when that that picture was taken =)
21:19:08 <augur> edwardk: die in a bigger fire
21:19:24 <augur> i feel like ive just been hardcore pranked
21:19:25 <augur> :(
21:19:26 <augur> <3
21:19:30 <Eduard_Munteanu> Heh.
21:19:51 <NihilistDandy> edwardk: Your mustache is awesome
21:20:01 <augur> thats a goatee, NihilistDandy
21:20:17 <NihilistDandy> I thought I saw a curl on the end of the mustache. Must just be an artifact.
21:20:21 <Eduard_Munteanu> Not to be confused with a goatse
21:20:25 <NihilistDandy> Oh, well
21:20:25 <sanjoyd> Eduard_Munteanu: yes, but why is that a type error?
21:20:26 <alfa_y_omega> i've a new stupid but interesting question, what are used the monads for?
21:20:39 <Eduard_Munteanu> :t runST
21:20:40 <lambdabot> forall a. (forall s. ST s a) -> a
21:20:44 <Eduard_Munteanu> :t newSTRef
21:20:45 <lambdabot> forall a s. a -> ST s (STRef s a)
21:21:11 <Eduard_Munteanu> sanjoyd: your 'a' in runST type ends up being STRef s something
21:21:13 <augur> edwardk: so do YOU think the ordering of topics is off?
21:21:22 <edwardk> http://www.facebook.com/photo.php?fbid=10150212860110339&set=a.10150212860105339.347067.553770338&type=1&theater might be a better picture (if it pulls up)
21:21:45 <Eduard_Munteanu> sanjoyd: but 's' can't escape. Do you understand how that inner forall works?
21:21:51 <edwardk> i think the recursion scheme stuff is too much too soon
21:21:56 <augur> look at you
21:21:57 <edwardk> they really need to grok the types first
21:22:00 <augur> you're like a real proper adult
21:22:05 <NihilistDandy> edwardk: We have similar tastes in just about everything
21:22:08 <edwardk> gee thanks ;)
21:22:39 <edwardk> i keep the long hair because it makes my wife happy =P
21:22:47 <sanjoyd> Eduard_Munteanu: not very well, except that the ST s a expression cannot assume anything about the type of s.
21:22:52 <augur> edwardk: a fire upon the deep \o/
21:23:02 <augur> dead like mee! \o/
21:23:09 <joe6> t
21:23:10 <NihilistDandy> Flaming Lips and Industrial was all I needed
21:23:24 <NihilistDandy> :D
21:23:35 <augur> clearly NihilistDandy and i are on the same page here
21:23:46 <edwardk> heh
21:23:50 <augur> facebook link? follow back to userpage.
21:23:54 <NihilistDandy> lol
21:23:57 <NihilistDandy> Truth
21:24:10 <NihilistDandy> I'm ekmett stalking, yo
21:24:14 <c_wraith> sanjoyd: it means that s has to be polymorphic in the ST s a portion of the expression.  But since the a is monomorphic, since it's also in the return value, it means that the type of a cannot depend on the type of s
21:24:18 <augur> oh man look at those floor to ceiling blackboards at upenn
21:24:25 <augur> edwardk: you gonna hacphi this year?
21:24:27 <edwardk> i'm pretty easy to stalk. my name isn't exactly hard to find on google ;)
21:24:29 <edwardk> yeah
21:24:34 <augur> awesome
21:24:40 <augur> dankna and i are making a speech synth for it
21:24:42 * sanjoyd reads the type signatures carefully again.
21:24:58 <edwardk> i'll probably hack on a new typeclassopedia with byorgey
21:25:04 <alfa_y_omega> edwardk, i'll help you to correct a little
21:25:14 <edwardk> i also want to sit down and work on some constructive probability theory with gershom
21:26:35 <edwardk> and i'd like to actually ship something for dealing with piecewise hermite-pade approximation over my ad library.
21:26:42 <edwardk> so hac phi will be pretty busy =)
21:26:44 <alfa_y_omega> edwardk, don't use simple arrows for the class Category, use the logic axiomatic notation, it's another kind of arrows, for (.)
21:27:20 <alfa_y_omega> (a->b)   and   (b->c)  then consequently  (a->c) for (.)
21:27:46 <alfa_y_omega> not so  (.) :: (b->c) -> (a->b) -> (a->c)
21:27:47 <edwardk> alfa_y_omega: i'm not sure where you're going with this (.) thing
21:28:17 <edwardk> @type (.)
21:28:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:28:24 <edwardk> @type (Prelude..)
21:28:25 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:28:30 <alfa_y_omega> because it could expressed of another form and is equivalent  (.) :: (a->b) -> (b->c) -> (a->c)
21:28:35 <Eduard_Munteanu> @type uncurry (Prelude..)
21:28:36 <lambdabot> forall b c a. (b -> c, a -> b) -> a -> c
21:28:36 <NihilistDandy> On an unrelated note, has anyone read Smullyan's "To Mock a Mockingbird"?
21:28:45 <edwardk> alfai didn't define Category. its in Control.Category =P
21:28:55 <edwardk> alfa: i used it just to describe something else
21:29:00 <edwardk> and provided the definition inline
21:29:12 <Eduard_Munteanu> alfa_y_omega: (.) is just like the math notation for function composition
21:29:17 <Saizan> sanjoyd: my personal suggestion is to learn a bit of System F where type abstraction and type application are explicit, then it's just a matter of 's' not being in scope when you have to provide a type to use for the 'a' type argument of runST
21:29:18 <alfa_y_omega> @type curry
21:29:19 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
21:29:21 <augur> edwardk: whats an inline definition, btw
21:29:23 <augur> ive seen this around
21:29:25 <edwardk> and (.) is perfectly fine
21:29:27 <Eduard_Munteanu> (f o g)(x) = f(g(x))
21:29:34 <augur> this {#!@#@#$ INLINE ... #$!@#$} thing
21:29:38 <edwardk> augur: i mean that i supplied the definition inline in the slides so that people could see it
21:29:51 <edwardk> augur: not in any technical sense ;)
21:29:59 <augur> well what is it in a technical sense :P
21:30:14 <augur> cause ive seen these flags on hackage
21:30:18 <augur> and i dont know what they mean
21:30:21 <Eduard_Munteanu> Actually looking at it from the scope perspective is simpler, I suppose.
21:30:24 <edwardk> oh those
21:30:25 <alfa_y_omega> don't use one kind of arrows
21:30:29 <augur> im sure theyre in the docs but thatd require i go to the docs
21:30:35 <edwardk> those are hints to the compiler to inline the definition when it can
21:30:40 <augur> oic
21:30:42 <alfa_y_omega> use at least two kind of arrows, the functional arrow and the logic arrow
21:30:50 <edwardk> if the body isn't recursive it'll do what it can
21:30:59 <augur> alfa_y_omega is clearly not a correspondencist
21:31:42 <alfa_y_omega> the logic arrow is the line of the consequent
21:31:48 <Eduard_Munteanu> @vixen What do you think about (.) ?
21:31:48 <lambdabot> i do occassionally, i guess
21:31:53 <alfa_y_omega> and commas too
21:31:54 <edwardk> alfa_y_omega: i use the hook arrows as the arrows in the category, i use the -> to represent the transformation. Monads in Haskell conflate the two terribly. the ones in those slides show how you can split them apart so you can deal with categories in which not every monad is strong.
21:32:27 <edwardk> you can read the (a `hook` m b) -> (m a `hook` m b) as a judgment
21:32:35 <edwardk> but i have to represent it with a haskell arrow type
21:32:49 <mustelo> @hoogle (a -> b -> c) -> (d -> a) -> (e -> b) -> d -> e -> c
21:32:50 <lambdabot> No results found
21:33:00 <Eduard_Munteanu> Oh, I think alfa_y_omega is talking about edwardk's blog post
21:33:00 <mustelo> what am I looking for here?
21:33:16 <edwardk> Eduard_Munteanu: i sent a link to some ancient comonad slides
21:33:22 <Eduard_Munteanu> Ah.
21:33:37 <edwardk> http://comonad.com/haskell/Comonads_1.pdf as an entry point to the 'what is a comonad' discussion
21:34:09 <edwardk> he apparently has taken umbrage at my use of the stock Control.Category definition ;)
21:35:06 <alfa_y_omega> i'll define the mine own Logic.Category in axiomatic form: 1. the identity axiom. 2. the composition axiom.
21:35:20 <mustelo> given a binary function and two unary functions, is there a predefined combinator that will give me a binary function back which runs inputs through the two unaries first?
21:35:52 <wli> `on`
21:35:53 <alfa_y_omega> i won't define directly the only functional arrows, but a functional arrow and a logic line of consequent (aka logic arrow)
21:36:30 <Saizan> after a little of Agda you're pretty used to (->) being the logic arrow :)
21:36:31 <alfa_y_omega> the control will decide the optimal permutation
21:36:33 <edwardk> alfa_y_omega: that wasn't a suitable presentation for the target audience at the time
21:36:43 <mustelo> wli, kind of, but I want to pass two different unary functions in, one for each arg
21:37:39 <edwardk> alfa_y_omega: besides i was taking an existing presentation that the audience was familiar with and unmunging it
21:38:02 <alfa_y_omega> control and logic are separated
21:38:05 <edwardk> it is kinda hard to do so when you go and make up a whole host of vocabulary then they have to some how see what they are use to seeing through your eyes
21:38:20 <edwardk> alfa_y_omega: i'm well aware
21:38:28 <alfa_y_omega> haskell as written had its own control's programmer
21:38:43 <alfa_y_omega> the mine is logic, the control is explored by the CPU.
21:39:05 <alfa_y_omega>  err, /control's programmer/programmer's control/
21:39:10 <dolio> The true insight to be gained from edwardk's recent blog posts is that codenisty isn't actually awesome at all.
21:40:14 <edwardk> alfa_y_omega: in haskell the line blurs. you have full exponentials. so you can see arrows as objects, and that haskellers don't usually distinguish the logical and computation arrows because for instance with monad, every monad (even functor) in haskell is strong, and so you can represent the mapping in terms of the arrows of the category itself
21:40:35 <edwardk> so we don't need to disambiguate between arrows, exponential, and logic arrows
21:40:44 <Eduard_Munteanu> (Apparently edwardk makes some sense of what alfa_y_omega said :D)
21:40:48 <edwardk> they are the same thing in this setting in a well-defined and rigorous way
21:41:12 <alfa_y_omega> edwardk, you didn't read the permutation cases when the number of parameters is passed to the functions.
21:41:18 <edwardk> in other settings it is worth belaboring that point
21:42:02 <Saizan> dolio: because it's too large?
21:42:05 <alfa_y_omega> my notation, (a->b), (b->c), (c->d), (d->e)  |=  (a->e)
21:42:11 <edwardk> in agda we do that kind of thing all the time. still the same arrow ;)
21:42:24 <alfa_y_omega> i won't replace the commas by functional arrows
21:42:40 <edwardk> alfa_y_omega: sure, but i'm not in the business of writing my own language for my slide decks
21:42:42 <edwardk> ;)
21:43:00 <Eduard_Munteanu> alfa_y_omega: but it's pretty much equivalent if you read (->) as right-associative
21:43:30 <edwardk> and i don't see the point in establishing the distinction, because often you WANT the power to use the strength
21:43:44 <dolio> Saizan: Because (forall r. (a -> r) -> (f r -> r) -> r) _is_ the free monad over f at a, and codensity offers no asymptotic improvements over it.
21:44:13 <edwardk> saizan: yeah
21:44:19 <edwardk> saizan: too large at least in that case
21:44:32 <edwardk> saizan: codensity is a perfectly good monad for other things
21:47:00 <edwardk> given f -| g : Hask -> Hask, g is a Monad, and Codensity g a ~ g . f. Codensity is a monad transformer provides an lifting from g into g . f. putting your code into continuation passing style, but preventing access to the continuation, while enlarging you enough to give you access to your left adjoint
21:47:13 <edwardk> er Codensity f ~ g . f
21:48:41 <Saizan> dolio: ah, i was a few posts later :)
21:49:01 <d7> How do you take two iteratees and compose them serially?
21:49:14 <d7> Like if I want to say drop 3, head
21:49:20 <Axman6> depends on the package
21:49:30 <edwardk>  dolio: yeah the current arc starts pretty much cold turkey from Free Monads for Less
21:49:31 <d7> Data.Enumerator
21:49:36 <edwardk> er s/dolio/Saizan/
21:51:09 <d7> Axman6: I can't figure out how to do it.
21:51:26 <Axman6> d7: go read michael snoyman's articles introducing the enumerator package, they're very good
21:51:27 <Saizan> as a story Free Monads for Less doesn't have a great ending ".. and the best thing is to use the standard church encoding you'd derive from the datatype"
21:51:44 <d7> I am reading them
21:51:47 <d7> They don't talk about this.
21:51:54 <d7> Of if they do, I don't understand it.
21:52:16 <edwardk> saizan: the goal was to take voightlaender's free monad improvement and get it with a smaller type
21:52:28 <edwardk> saizan: and more importantly to make it so i could stand to look at our IO monad ;)
21:53:05 <edwardk> saizan: a secondary goal was to show that these codensity and yoneda things are pretty close to what you wind up with when you cps transform crap by hand
21:53:27 <edwardk> to demystify them a bit
21:53:53 <edwardk> Saizan: you make it through part 3 yet?
21:56:36 <Saizan> edwardk: ah, yes, forgot about that
21:58:23 <Saizan> though post 3 is more about what you can do with free monads than getting them for less
21:58:45 <edwardk> well, in my case i needed them cheap. so that doing n operations wasn't O(n^2)
22:02:40 <edwardk> also trying to use forall r. (a -> (forall i. (i -> r) -> (Throwable -> r) -> FFI i -> r) -> (Throwable -> r) -> r) -> (forall i. (i -> r) -> (Throwable -> r) -> FFI i -> r) -> (Throwable -> r) -> r is less palatable that the more yoneda'ish version ;)
22:03:28 <edwardk> forall r. (a -> r) -> (forall i. (i -> r) -> (Throwable -> r) -> FFI i -> r) -> (Throwable -> r) -> r
22:03:43 <Saizan> edwardk: where's that from?
22:04:34 <edwardk> i mentioned the type we actually use is slightly different than the version in the paper. the former is what you'd get if you Codensity (Rec Foo)'d our internal IO type. the latter is what you get from Yoneda (Rec Foo)
22:06:51 <edwardk> (forall r. (a -> Free YieldFFI r) -> Free YieldFFI r) — for data YieldFFI a where YieldFFI :: (i -> a) -> FFI i -> YieldFFI a is slightly cleaner than the former
22:07:02 <edwardk> but as i demonstrated is bigger than it needs to be
22:11:24 * edwardk &
22:11:38 <Saizan> edwardk: http://www.e-pig.org/epilogue/?p=914
22:12:33 <ivanm> @ask edwardk since when was backgrounding the same as quitting? :p
22:12:33 <lambdabot> Consider it noted.
22:13:27 <d7> Oh.
22:13:40 <d7> You don't compose iteratees serially except in special cases. :\
22:30:22 <liruohao> ?
22:30:31 <ajnsit> Hi all. The category-extras package is marked as obsolete on hackage. What is the replacement? http://hackage.haskell.org/package/category-extras-0.53.5.
22:33:14 <Eduard_Munteanu> ajnsit: it has been split into multiple packages.
22:33:36 <ajnsit> Eduard_Munteanu, which ones?
22:33:55 <Eduard_Munteanu> IIRC, edwardk wanted to make a metapackage to bring all of them in.
22:34:01 <Eduard_Munteanu> I'm not sure.
22:34:09 <Eduard_Munteanu> Try searching for the stuff you need.
22:34:32 <ajnsit> Eduard_Munteanu, okay thanks!
22:35:16 <djahandarie> ajnsit, see http://github.com/ekmett/ for a decent list of them.
22:35:28 <djahandarie> With other stuff too, of course :)
22:55:48 <sanjoyd> Saizan: I think I got it: there is no value for a that can unify (Λ a . ((Λ s . ST s a) -> a)) with (Λ t . ST t (STRef t) -> (STRef t)); since t is bound in a separate "scope".
22:57:21 <Saizan> sanjoyd: big lambdas aren't part of types, did you mean ∀ instead?
22:57:32 <sanjoyd> Saizan: yes, sorry.
22:59:33 <sanjoyd> Anyways, thanks Saizan, Eduard_Munteanu and c_wraith.
22:59:47 <c_wraith> sanjoyd: yes, sounds like you've figured it out :)
22:59:58 <mk> how does haskell handle truly random numbers?
23:00:30 <c_wraith> mk: truely random values can only come from IO
23:00:32 <sanjoyd> I guess you could read them off /dev/urandom.
23:00:45 <earthy> mk: in IO or a restricted monad encapsulating IO
23:01:02 <Eduard_Munteanu> Only /dev/random is truly random
23:01:12 <earthy> eduard: if that
23:01:24 <mk> makes sense, thanks
23:01:25 <c_wraith> Eduard_Munteanu: don't use /dev/random unless you like opening your system to free Denial of Service attacks
23:01:59 <Eduard_Munteanu> Well, not exactly DoS, but it's eating up precious entropy.
23:02:04 <earthy> c_wraith: perfect for getting a simple seed
23:02:21 <sanjoyd> Get one of those USB random sources?
23:02:37 <c_wraith> Eduard_Munteanu: no, DoS.  did you know a simple TCP syn flood will exhaust the entropy pool /dev/random reads from?
23:03:02 <Saizan> sanjoyd: what i meant is that given runST :: forall a. (forall s. ST s a) -> a, foo :: forall s. STRef s Int you'd have to call it like: runST [STRef s Int] (Λ s . foo [s]) <- but the 's' given in the second argument is not in scope in the [STRef s Int] type application
23:03:06 <Eduard_Munteanu> Oh, for sequence numbers? Hm.
23:03:08 <mk> c_wraith: I assume you mean in code that an attacker can trigger?
23:03:18 <mk> wait, maybe you don't
23:03:57 <mk> c_wraith: any reason that isn't fixed?
23:04:30 <Eduard_Munteanu> mk: well I suppose it's either that or predictable TCP sequence numbers
23:04:45 <c_wraith> mk: I don't know.  I don't know of anyone who doesn't use /dev/urandom for anything resembling public services anymore
23:05:17 <Saizan> what's the problem with predictable TCP sequence numbers?
23:05:17 <Enigmagic> i still use /dev/zero for my random numbers :\
23:05:18 <Eduard_Munteanu> Well, gpg for example will only use /dev/random
23:05:21 <Eduard_Munteanu> And with good reason.
23:05:37 <mk> Saizan: I can pretend to be you if I time it right
23:05:44 <Eduard_Munteanu> Yeah ^
23:06:09 <c_wraith> Eduard_Munteanu: I think you should study the "theory" underlying /dev/random a bit before you decide it's better than /dev/urandom
23:06:33 <sanjoyd> Saizan: yes, I got that intuition - that the inner `s' is /bound/; but I don't know the mathematical verbiage to state it correctly.
23:06:43 <Eduard_Munteanu> I didn't decide it was better, just truly random ;)
23:07:03 <Eduard_Munteanu> (as in every bit of it is random)
23:08:12 <c_wraith> Eduard_Munteanu: that's my point.  you have *no clue* if any bit from /dev/random is actually random, because there's no solid theory underlying gathering entropy.  There are only heuristics that seem ok
23:09:17 <mk> what's there to the theory, aside from one is more random, and the other is as less-random as it is fast?
23:09:29 <Eduard_Munteanu> Ah, fair point. Though keystrokes timing is pretty much random (compared to a PRNG), and not easily susceptible to outside "noise" or interception.
23:10:29 <c_wraith> I'm just saying, a crypto-based system will produce far better results if an attacker is controlling 50% of your assumed entropy, compared to just returning that assumed entropy directly
23:12:00 * hackagebot svm-simple 0.1.0 - Medium level, simplified, bindings to libsvm  http://hackage.haskell.org/package/svm-simple-0.1.0 (VilleTirronen)
23:12:19 <Eduard_Munteanu> Yeah.
23:12:24 * Eduard_Munteanu has to go, though.
23:12:25 <Eduard_Munteanu> o/
23:12:28 <c_wraith> later
23:12:33 <mk> seeya
23:12:42 <c_wraith> amusingly, I've gotta go too :)
23:13:37 <aleator> Another hackage-package out. If anyone wishes to comment on it (svm-simple) I'd be happy receive criticisms
23:23:05 <Enigmagic> aleator: i'll try to look at it tomorrow, you can also check out my liblinear bindings for training (using iteratees) here: https://github.com/NathanHowell/liblinear-enumerator/blob/master/src/Data/LibLinear.hs
23:23:53 <ivanm> aleator: one comment: actually say what libsvm _is_ in your description
23:24:25 <ivanm> aleator: you also say "changes in version 0.0.1" despite it being 0.1.0 (and not having previous releases)
23:24:47 <ivanm> personally, I'm not a big fan of "let's put the Changelog in the .cabal description" approach, but I guess it's more viewable than having a separate file
23:31:50 <aleator> ivanm: Ah. Thats a mistake. Will fix.
23:34:17 <aleator> Enigmagic: This sounds like an opportunity to co-operate, since liblinear is almost same as libsvm.
23:34:49 <aleator> There is also gpu-libsvm which is almost the same interface.
23:38:02 <Enigmagic> aleator: definitely, maybe shoot me a mail? nathan@alphaheavy.com ... i'm just about to head to bed
23:38:57 <aleator> Enigmagic: Ok. I'll do that. Nighty!
