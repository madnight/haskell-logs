00:00:11 <adrake_> can we just be honest and call hlint hgolf?
00:01:34 <shachaf> lambdabot needs an @hlint plugin.
00:01:48 <sully> shachaf: it's called @pl
00:01:56 * sully ducks
00:02:35 <adrake_> @pl \ c -> LeftApp c slot
00:02:35 <lambdabot> flip LeftApp slot
00:02:41 <adrake_> wow, hlint beat out @pl
00:05:18 <shachaf> @pl \f g (x,y) -> (f x,g y)
00:05:18 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
00:06:22 <shachaf> What's the shortest piece of code that, when fed to @pl, produces the longest piece of code?
00:06:32 <shachaf> I suppose that's two variables to optimize.
00:06:42 * shachaf is looking for the R-pentomino of @pl.
00:11:30 <Jafet> I suspect you can make the ratio arbitrarily large
00:11:40 <Jafet> Not sure about the rate of growth, though
00:11:51 <shachaf> Right, that seems reasonable.
00:12:09 <shachaf> So I suppose I should ask what the biggest increase you can get under N characters is for some small N.
00:12:42 <adrake_> How about what pattern of code, when generated in linearly increasing sizes and fed to @pl, produces the largest size expansion function?
00:12:54 <adrake_> s/largest/most rapidly growing/
00:13:14 <shachaf> "pattern of code"?
00:13:54 <Jafet> An algorithm that, given a parameter N, produces an expression of size N
00:14:18 <Jafet> That causes pl, in theory, to produce an optimized output of size ???
00:14:23 <shachaf> Ah.
00:15:01 <shachaf> I was specifically hoping for a small piece of code, though, not an asymptotically ideal one. :-)
00:18:55 <Taejo> I have a Set (Int, Int) or Set (Double, Double) and I want to view it or save it as an image. What's a nice library to do something like that?
00:19:21 <osfameron> as an image?
00:20:23 <osfameron> Taejo: quick google suggests http://vis.renci.org/jeff/2009/02/03/introducing-hieroglyph-purely-functional-visualization-on-top-of-cairo/ ?
00:21:46 <luite> I don't think hieroglyph sees much development these days... diagrams may be an alternative, but is not for bitmaps
00:22:25 <osfameron> does diagrams have stuff to visualise haskell datatypes?
00:22:45 <ion> When defining Arbitrary instances for QuickCheck, the following is a very common pattern. Is there a nice abstraction for it? shrink (Foo a b c) = concat [ Foo <$> shrink a <*> [b] <*> [c], Foo <$> [a] <*> shrink b <*> c, Foo <$> [a] <*> [b] <*> shrink c ]
00:23:05 <Taejo> osfameron: I'm thinking of it as a set of pixels: I don't want a datatype visualisation
00:23:24 <ion> whoops, the c in the middle item chould have been [c]
00:23:30 <Taejo> diagrams isn't really a good fit
00:23:31 <osfameron> Taejo: ah, so a scattergraph?
00:23:51 <Taejo> osfameron: essentially yes
00:23:52 <luite> osfameron: hmm, nto sure what you mean. maybe you're thinking about something like vacuum?
00:24:29 <osfameron> luite: well, I'd asked Taejo to clarify ;-)  originally I thought he meant a visualisation of a Data.Set, e.g. a graphic showing the contents of a data-structure
00:24:43 <Taejo> sorry for being unclear
00:24:45 <luite> Taejo: if you don't have millions of points, then diagrams should be ok
00:25:00 <erus`> people who use configure scripts in cabal projects should have their wife and children raped infront of them, then be shot
00:25:01 <luite> you can make a small circle for each item
00:26:01 <Taejo> luite: it's not a great fit -- it's a fractal I'm trying to render, rather than a chart -- but I guess it'll work for now
00:28:18 <Taejo> the pgm library on Hackage might be what I'm after
00:28:41 <Jafet> @pl \a b c d e f g h i -> i h g f e d c b a -- shachaf
00:28:45 <lambdabot> flip (flip . ((flip . ((flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .)) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) .
00:28:45 <lambdabot> flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . flip (flip . (flip .) . ((flip .) .) . flip (flip . (flip .)
00:28:45 <lambdabot>  . flip (flip . flip id)))))))
00:28:45 <lambdabot> optimization suspended, use @pl-resume to continue.
00:28:52 <luite> Taejo: or maybe Codec-Image-DevIL
00:29:01 <luite> that has an easy function to write an array to an image fil
00:29:11 <Jafet> n parameters seems to require n(n-1)/2 flips.
00:39:46 <Jafet> This one might be exponential
00:40:02 <Jafet> @pl \(a:b:c:d:e:x) -> e:d:c:b:a:x
00:40:05 <lambdabot> ap (flip ap tail . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . flip flip tail . ((flip . (flip .) .
00:40:06 <lambdabot> ((ap .) .)) .) . flip flip head . (flip .) . ((flip .) .) . ((((.) .) .) .) . (((flip ((.) . (:)) .) .) .) . ((flip ((.) . (:)) .) .) . (flip ((.) . (:)) .) . flip ((.) . (:)) . (:) . head) tail
00:40:06 <lambdabot> optimization suspended, use @pl-resume to continue.
00:40:18 <Jafet> But I don't know.
00:42:49 <Jafet> Actually, it's probably quadratic.
00:45:36 <erus`> does haskell platform come with a database?
00:48:48 <osfameron> erus`: heh, http://hackage.haskell.org/platform/ is very coy about what it actually contains
00:49:03 <osfameron> and http://hackage.haskell.org/platform/contents.html just points to a hackage index
00:49:56 <erus`> it could be called MonadDataBase or something non obvious
00:50:29 <tibbe> erus`, I don't think so, mysql-simple is a good package for talking to MySQL
00:51:06 <erus`> tibbe: i would prefer a self hosted database if one is available
00:51:34 <tibbe> erus`, like sqlite?
00:51:44 <tibbe> erus`, there are sqlite bindings, but I haven't tried them
00:51:46 <tibbe> check Hackage
00:58:27 <dankna> direct-sqlite is written by me and is quite good if I say so myself :)
00:58:30 <dankna> it's basic though
00:59:24 <erus`> i did cabal install
00:59:29 <erus`> how do i uninstall
00:59:54 <Eduard_Munteanu> erus`: you can't. You can only 'hide' the package.
01:00:07 <erus`> wdf
01:00:32 <erus`> i did it on a snap project
01:00:46 <erus`> did it add it to path or move the executable?
01:01:10 <Eduard_Munteanu> Use 'ghc-pkg hide'
01:01:46 <Eduard_Munteanu> If you want to get rid of it completely you'll have to remove the cabal and ghc prefixes
01:03:21 <erus`> i dont even know the package name :|
01:03:25 <erus`> it should be 'web'
01:03:51 <luite> ghc-pkg list
01:07:02 <erus`> it moved the exe to the cabel directory
01:07:15 <erus`> what a perlaver
01:07:42 <erus`> ok snap is too big
01:07:46 <luite> that's what cabal install does
01:07:47 <erus`> back to happstack
01:07:53 <luite> snap is actually quite small
01:08:04 <erus`> creates a million files
01:08:08 <erus`> and a cabal project
01:08:43 <luite> erus`: making a cabal project is a good idea anyway
01:27:29 * osfameron doesn't like webapp "scaffolding" in general
01:27:56 <osfameron> though agree that making a standard project installation is probably a good default
01:43:04 <erus`> @hoogle UTCtime -> String
01:43:04 <lambdabot> Did you mean: UTCTime -> String /count=20
01:43:05 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
01:43:05 <lambdabot> Prelude show :: Show a => a -> String
01:48:00 <erus`> how do i get the current time?
01:49:02 <erus`> found it
01:55:21 <hpaste> erus` pasted “doesnt work :(” at http://hpaste.org/48191
01:56:05 <hpaste> erus` annotated “doesnt work :(” with “doesnt work :( (annotation)” at http://hpaste.org/48191#a48192
01:56:28 <erus`> can anyone see why this doesnt work please
01:58:19 <Botje> you probably need to lift getClockTime to that ServerPartT IO type
01:58:54 <erus`> how does one do that
01:59:29 <Botje> ah
01:59:31 <Botje> liftIO :)
01:59:43 <Botje> t <- liftIO getClockTime
01:59:58 <Botje> because ServerPartT IO is an instance of MonadIO
01:59:59 <erus`> @hoogle liftIO
02:00:00 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
02:00:26 <erus`> thanks Botje
02:00:35 <albertid> Hi, I wrap a callback function into an IORef so that I can keep a state (https://github.com/lordi/scalehs/blob/master/Main.hs "makeCallback"). I'm a newbie to StateT and IORefs, so my question is if it is possible to implement this without IORef?
02:00:50 <erus`> i didnt know do notation needed all statements to be a specific type
02:01:24 <erus`> it sucks a bit
02:01:56 <Botje> do notation is just a notation
02:02:04 <Botje> behind the scenes it's all >>=
02:02:13 <Botje> and >>= requires both sides to belong to the same monad
02:02:21 <erus`> i dont understand all those >>=s
02:02:53 <erus`> blissfully ignorant
02:02:57 * hackagebot darcs-beta 2.7.98.1 - a distributed, interactive, smart revision control system  http://hackage.haskell.org/package/darcs-beta-2.7.98.1 (FlorentBecker)
02:03:07 <Botje> @unpl do { t <- getClocktime; putStrLn "hi"; ok "the time is foo" }
02:03:07 <lambdabot> do { t <- getClocktime; putStrLn "hi"; ok "the time is foo"}
02:03:10 <Botje> uh
02:03:14 <eikke> erus`: >>= is just a function like any other
02:03:14 <Botje> @undo do { t <- getClocktime; putStrLn "hi"; ok "the time is foo" }
02:03:15 <lambdabot> getClocktime >>= \ t -> putStrLn "hi" >> ok "the time is foo"
02:03:22 <Botje> erus`: this is what you wrote in your paste
02:05:19 <albertid> @undo do { x <- get; put (transform e x)}
02:05:19 <lambdabot> get >>= \ x -> put (transform e x)
02:05:27 <miasma> hmm, i have a small design related question. when using type classes, is it good idea to often keep them minimal and cram functionality into free functions? in this case i just think some functions should be conceptually related, but i'd probably only make a single instantiation of the type class
02:09:37 <frerich> miasma: I don't think type classes are the right way to 'group' functions. Modules are for that. Type classes allow you to express requirements on types when writing function signatures (i.e. of polymorphic functions).
02:10:21 <miasma> frerich: i thought so too, but type classes kind of can be misused for the purpose
02:12:39 <quicksilver> miasma: if you only ever make a single instance of the class, it should not be a class.
02:12:46 <quicksilver> typeclasses are for overloading.
02:12:57 <quicksilver> they're not a useful modularity or general abstraction tool.
02:13:18 <miasma> ok. and thanks
02:17:31 <miasma> quicksilver: not a general abstraction tool, but surely you can express abstractions with them when composing the functionality into many classes and adding dependencies between them
02:18:24 <quicksilver> not sure without a little more context.
02:18:38 <quicksilver> classes are a property of types
02:18:56 <quicksilver> the point of them is to uniformly (polymorphically) overload code over diferent types which have something in common
02:25:35 <miasma> for example if you have type classes for comparing numbers and checking for equality, you can pass it kind of polymorphically to a function requiring only part of the functionality. e.g. in Java they would use the interface / class abstraction for this
02:28:58 <quicksilver> yes.
02:29:15 <quicksilver> and the point there is that many types support equality.
02:29:21 <miasma> sure
02:58:27 * hackagebot graph-rewriting-ski 0.5.6 - Two implementations of the SKI combinators as interactive graph rewrite systems  http://hackage.haskell.org/package/graph-rewriting-ski-0.5.6 (JanRochel)
03:16:58 <benmachine> miasma: having functions that take concrete types instead of typeclass-constrained type variables is useful for inference
03:17:11 <benmachine> and useful for the reader of the type signature, imo
03:29:55 <erus`> I have bitcoins :)
03:31:54 <JuanDaugherty> u haz nuthin
03:34:53 <Blarumyrran> erus`, I have street cred
03:35:25 <erus`> well i have 0.001 bitcoins
03:36:36 <Blarumyrran> Some people use their computers to fund research of new medicines that save lives
03:36:57 <Blarumyrran> Some people use their computers as servers that make the lives of thousands of people better
03:37:04 <Blarumyrran> Some people... generate bitcoins
03:37:07 <erus`> i didnt mine my coins
03:37:16 <erus`> so i do none of the above
03:37:21 <Blarumyrran> Ah, okay
03:37:31 * osfameron mined for a couple of days - I have 0.01 bitcoins!  woot!
03:37:34 <Blarumyrran> 0,001 sounded like something one would gain by mining
03:37:39 <arw__> Blarumyrran: some poeple print money and some guard banks.
03:37:40 <osfameron> then the miner fell over, and I couldn't be bothered to restart it
03:38:24 <arw__> Blarumyrran: and some run seti@home...
03:38:59 <Blarumyrran> What's wrong with seti@home?
03:41:16 <Blarumyrran> It's the only Civilization wonder that you can really be a part of
03:41:43 <arw__> Blarumyrran: *g*
03:45:59 <Blarumyrran> arw__, sorry, what does *g* mean? It's hard to google that
03:47:21 <quicksilver> Blarumyrran: grin
03:52:26 <nihtml> @pl (\_ x -> x+1)
03:52:27 <lambdabot> const (1 +)
03:53:57 <sipa> @pl (+1)
03:53:58 <lambdabot> (1 +)
03:54:05 <sipa> ah
04:07:08 <JuanDaugherty> unh uh, haskell is a "Civilization Wonder" you can be part of. Really.
04:07:50 <JuanDaugherty> SETI is kina dumb ass
04:09:15 <cheater_> why
04:09:29 <JuanDaugherty> the way they go about it looking for EM signals
04:09:30 <Martty> creedenzo clear agua revival
04:10:15 <cheater_> how would you do it better JuanDaugherty
04:11:49 <JuanDaugherty> well I start by taking the fact that speed of light/EM signals is constant seriously and that others are also aware of said fact
04:11:54 <JuanDaugherty> *I'd
04:24:46 <Botje> except it's not, it depends on the medium :]
04:32:23 <ben> would it be fair to say that all haskell io is technically asynchronous since >>= is only installing callback handlers for when the io finishes
04:32:57 <benmachine> ben: not reeeeeallly. nothing happens while you're waiting for it to finish
04:33:10 <benmachine> (unless you forked threads, but then that's obviously async)
04:33:21 <ben> well the rts could schedule someone else running on a single os thread
04:33:41 <JuanDaugherty> how would it do that?
04:33:46 <ben> i mean i'm trying to come up with an anology to the async-io-with-event-loop thing that everybody else is doing
04:33:54 <benmachine> well, that presumes the existence of someone else, surely
04:33:58 <JuanDaugherty> or rather who else?
04:34:09 <benmachine> which is what I meant by forked threads, I didn't mean OS threads
04:34:13 <JuanDaugherty> because the who is you
04:34:58 <Botje> ben: the haskell TS actually does something clever when it's about to do a blocking I/O call
04:35:41 <Botje> it translates it into a non-blocking call and goes to do something else
04:35:42 <JuanDaugherty> although gc and  the like would be candidates if haskell used
04:37:46 <ben> we're just hiding our event loop in the threading engine...?
04:42:43 * hackagebot aosd 0.2.0 - Bindings to libaosd, a library for Cairo-based on-screen displays  http://hackage.haskell.org/package/aosd-0.2.0 (DanielSchuessler)
04:44:22 <ben> hayoo has gotten quite a bit faster since i last used it, it's great now
04:44:34 <eikke> bos: something along those lines, yes. the "Scalable I/O Event Handling for GHC" by tibbe and bos is worth a read, as well as http://www.slideshare.net/tibbe/a-scalable-io-manager-for-ghc and some blog posts by tibbe
04:45:34 <eikke> s/the/the paper/
04:48:06 <JuanDaugherty> bos? did you mean ben?
04:48:27 <ben> I clicked the link either way
04:48:31 <ben> though I'm pretty sure i've seen it before
04:52:44 * hackagebot hakyll-contrib 0.0.0.3 - Extra modules for the hakyll website compiler  http://hackage.haskell.org/package/hakyll-contrib-0.0.0.3 (JasperVanDerJeugt)
04:59:03 <tibbe> ben: any questions?
05:00:16 <ben> No :)
05:01:57 <Blarumyrran> Good people of #haskell, I'm a newbie and I have a question! I have a program that goes something like, "forever do x <- getLine". How do I add lines gotten this way into a list?
05:02:25 <mauke> you don't
05:02:30 <mauke> "forever" doesn't stop
05:02:42 <Blarumyrran> uh
05:02:55 <zygoloid> @type lines <$> getContents
05:02:55 <lambdabot> IO [String]
05:03:17 <Cadynum> can anyone give some hints how to get accelerators with gtk2hs working? they dont even appear to work for me in the actionmenu demo coming with the source
05:03:53 <jaj> well, you could run the forever in a seperate thread and add it's content to an STM value
05:04:08 <Blarumyrran> let's say that in that "do", after the getLine, I want to do something with all the inputted lines so far
05:04:22 <Blarumyrran> how do I do that
05:04:36 <Blarumyrran> I wouldn't want to get into multithreading; I'd imagine it isn't needed
05:04:43 <mauke> keep an accumulator or something
05:04:47 <tibbe> Blarumyrran, loop lines = do line <- getLine; loop (line : lines)
05:04:59 <ben> but now it's backwards D:
05:05:07 <tibbe> yes
05:05:17 <tibbe> you'll have to reverse it in the end
05:05:17 <quicksilver> backwards is just a perspective.
05:05:30 <quicksilver> it's still a list of all the inputted lines so far
05:06:17 <Blarumyrran> tibbe, thanks
05:07:15 <tibbe> Blarumyrran, the reason I prepend the line is that lists, [], are linked lists
05:07:18 <tibbe> so it's more efficient
05:16:37 <Peaker> tibbe: why not replicateM someNumber getLine ?
05:17:24 <tibbe> Peaker, well, he can do something with the lines now
05:17:28 <tibbe> Peaker, if he wanted to
05:17:34 <tibbe> I'm not sure what he want to do in the end
05:18:38 <ben> maybe he wants an iteratee~
05:32:44 <parcs> iteratees are always the answer
05:37:33 <quicksilver> I thought that was smarties.
05:39:18 <zygoloid> smarties only have the answer. presumably they have iteratees
05:40:41 <quicksilver> excellent.
05:40:44 <quicksilver> is that what's in the blue ones?
05:40:49 <ketil> gal_bolle, eh, do you by any chance speak any Scandinavian language? :-)
05:40:54 <zygoloid> yeah. that's why they were banned for so long
05:41:15 <zygoloid> iteratees make children hyperactive
05:41:57 <frerich> Hyperactivity is a built-in feature on children.
05:48:09 <gal_bolle> ketil: not at all, why?
05:48:28 <ketil> gal_bolle means "mad bun" in Norwegian :-)
05:50:23 <Twey> Haha
05:51:23 <trygvis> :)
05:51:52 * hackagebot hakyll 3.2.0.3 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.0.3 (JasperVanDerJeugt)
05:54:52 * hackagebot hakyll-contrib 0.0.0.4 - Extra modules for the hakyll website compiler  http://hackage.haskell.org/package/hakyll-contrib-0.0.0.4 (JasperVanDerJeugt)
06:04:19 <gienah> \o/
06:05:19 <ben> vov
06:09:21 <NiCROS> Anyone know why I would be getting this.  http://pastebin.com/QqAsjJJF
06:09:23 <mauke> The paste QqAsjJJF has been copied to http://hpaste.org/48203
06:16:48 <gienah> NiCROS: I don't really know, maybe you could try checking the pkg consistency with: ghc-pkg check
06:17:55 * hackagebot uuagc 0.9.38.3 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.38.3 (ArieMiddelkoop)
06:31:14 <koala_man> what are some things you can do with static typing that dynamic types don't allow? (ie that fails if you remove all the type info from a correct program)?
06:31:23 <koala_man> I can just think of functions that are polymorphic on their output type
06:31:29 <quicksilver> nothing.
06:31:42 <quicksilver> if you erase all types from a statically typed program you have a working dynamically typed program
06:31:53 <quicksilver> just, one that is guaranteed not to go wrong in a certain sense.
06:31:57 <Martty> you have a text file that doesnt compile probably
06:32:26 <Twey> Dispatch on type
06:32:57 * hackagebot warp 0.4.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-0.4.1 (MichaelSnoyman)
06:32:59 <koala_man> quicksilver: if you have a function like =~ that returns different things based not on the input but on the excepted output, it'll break
06:33:13 <quicksilver> koala_man: that's not really anything to do with static types.
06:33:20 <quicksilver> that's do with the typeclass resolution system.
06:33:29 <quicksilver> you certainly can do something like that in a dynamic system if you choose to.
06:33:53 <osfameron> there are lots of features of haskell-like static typing that make it more likely that you'd want to do that, of course
06:33:55 <koala_man> Twey: you do have multiple dispatch in dynamic languages
06:33:58 <quicksilver> certainly typeclasses are not a feature of most static type systems.
06:34:18 <quicksilver> the simply typed lambda calculus can be translated to the untyped lambda calculus
06:34:30 <quicksilver> and the program will remain semantically the same.
06:35:07 <koala_man> quicksilver: how would you implement a dynamic function to do that?
06:35:55 <quicksilver> koala_man: by passing dictionaries around.
06:36:01 <quicksilver> which is one possible way to implement typeclasses.
06:36:14 <quicksilver> (in fact, the way that GHC implements them in general, although it can eliminate them in some cases)
06:36:16 <osfameron> what do you mean by passing dictionaries around?
06:36:17 <koala_man> a dictionary of what?
06:36:41 <quicksilver> the method instances of the type.
06:37:31 <quicksilver> for example, the Eq dictionary for Bool is (eq_bool x y = case (x,y) of (True,True) -> True; (False,False) -> True; _ -> False)
06:38:30 <osfameron> oh, like a vtable ?
06:38:49 <osfameron> why do you have to pass them around?  i.e. as opposed to looking them up as needed?
06:39:15 <quicksilver> you don't have to, osfameron
06:39:21 <quicksilver> it's just one possible implementation of typeclasses.
06:39:50 <quicksilver> however it does mean you don't need to pollute every single value with a morass of vtable (like C++ does)
06:40:00 <quicksilver> and it means you don't need a global lookup table of every type in your program
06:40:09 <zygoloid> it's not as simple as 'just erase all types' though
06:40:13 <quicksilver> (which is a bit of a pain with separate compilation)
06:40:35 <osfameron> ah ok.  I'd have thought this would be one of the few places that a global lookup table actually made sense ;-)
06:40:42 <quicksilver> maybe it does.
06:40:47 <quicksilver> JHC uses a global lookup table.
06:40:58 <quicksilver> but then again, JHC doesn't do separate compilation.
06:41:54 <koala_man> quicksilver: so for =~, would this mean passing in a dictionary that implicitly tells the function to return a bool, string or list of string depending on what you want out?
06:42:33 <zygoloid> or returning a thing which contextually converts to one of those depending on how it's used
06:43:01 <Saizan> isn't the return type a parameter of the typeclass too?
06:43:02 <quicksilver> koala_man: an explanation of the hideous network of overloading that is =~ is not something I will attempt in this IRC channel :)
06:43:18 <koala_man> haha
06:43:19 <quicksilver> it is a particularly vicious example (some might say pathological).
06:43:29 <Saizan> so first you decide what the result type should be, then you know which dictionary to use
06:48:44 <Eliel> @pl (\s -> (*) (a s) (b s))
06:48:45 <lambdabot> liftM2 (*) a b
06:49:07 <Eliel> for some reason, that works even if there's no monad involved. Why?
06:50:02 <wjt> Eliel: because there's an instance Monad ((->) r)
06:50:56 <Eliel> ah, thank you
06:57:37 <kaf3ii> strange, "snd $ runState (forever get) 0" fails to evaluate as expected, but in monad-mersenne-random "snd $ runRandom (forever getBool) (pureMT 0)" seems to evaluate
07:03:06 <kaf3ii> ah, used seq now and acts as excepcted, ignore me.. .
07:03:50 <digimmortal> is there any way to get latest Haskell Platform installed on Ubuntu 11.04 without compiling it myself?
07:07:56 <JuanDaugherty> digimmortal, I didn't have any problem on debian and they're pretty similiar FWIU
07:08:57 <digimmortal> JuanDaugherty: am I supposed to add some debian repository for this?
07:10:12 <JuanDaugherty> digimmortal, I don't use the apt stuff for this
07:10:26 <zenzike> I have a case statement for a type data Foo = Bar | Baz | Fee | Foe, and it happens that the output should be the same for Bar / Baz, and for Fee, Foe. Is there syntax for grouping multiple -> cluases in a case?
07:11:49 <thoughtpolice> no, i don't think it's possible to have multiple pattern alternatives in the same pattern matching clause (be it case statements or pattern matching in any context)
07:12:23 <zenzike> thoughtpolice: thought not. seems like a useful thing to have.
07:13:14 <quicksilver> it isn't possible, but it is suggested occasionally.
07:13:24 <thoughtpolice> i think what you're talking about is "option patterns" which are in sml/nj, and i think there's a ticket for them in the GHC bug tracker. one thing i remember was that it was hard to decide what syntax to use, because haskell is already syntactically pretty 'full'
07:13:26 <quicksilver> SPJ said once there wasn't a really good reason it wasn't.
07:13:45 <thoughtpolice> but that was about the only impedement in terms of practicality, IIRC. otherwise totally doable
07:14:42 <quicksilver> http://hackage.haskell.org/trac/ghc/ticket/3919
07:15:01 <thoughtpolice> ah wait, "or patterns"
07:15:02 <thoughtpolice> my bad
07:15:12 <zenzike> quicksilver: ah, thanks.
07:15:41 <mietek> Does anyone here work at Barclays London?
07:16:00 <quicksilver> you could use | anywhere except at pattern top-level.
07:16:07 <quicksilver> at top level you'd collide with guards.
07:16:28 <quicksilver> by requiring parentheses (which are already legal in patterns) you could deal with that case I *think*.
07:16:45 <quicksilver> foo (Bar | Baz) = 0; foo (Fee | Foe) = 1;
07:16:59 <quicksilver> seems fairly intuitive to me. And is currently illegal, so no collision.
07:18:16 <quicksilver> ski suggested the same syntax in February 2010. So I'm in good company.
07:21:03 * hackagebot sphinx 0.4.0.2 - Haskell bindings to the Sphinx full-text searching deamon.  http://hackage.haskell.org/package/sphinx-0.4.0.2 (GregWeber)
07:40:06 * hackagebot snap-core 0.5.1.4 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.5.1.4 (GregoryCollins)
07:43:06 * hackagebot snap-server 0.5.1.2 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.5.1.2 (GregoryCollins)
07:43:08 * hackagebot snap 0.5.1.2 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.5.1.2 (GregoryCollins)
07:46:13 <iwtu> just trying
08:02:13 * hackagebot snap-server 0.5.1.3 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.5.1.3 (GregoryCollins)
08:03:12 * hackagebot snap 0.5.1.3 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.5.1.3 (GregoryCollins)
08:07:30 <iwtu> hi. can anyone help to compose an expression?
08:08:07 <ben> (.) can help
08:11:00 <iwtu> ben, hope it is clear what I wish http://codepad.org/74zWR2vS
08:11:17 <iwtu> ben, but not see a problem
08:11:32 <ion> @vixen Should one ask metaquestions?
08:11:33 <lambdabot> nevermind about that
08:11:40 <iwtu> i see
08:12:16 <Eduard_Munteanu> ion: isn't that a metametaquestion?
08:12:45 <ion> You’re trying to do y:ys but ys is drawn from vyraz xs, resulting in ys :: Char
08:12:47 <balor> How do I set a flag in a cabal build?  ie. can I "cabal install foo --flag bar=true"?
08:13:38 <dcoutts> balor: it's documented in the --help output
08:14:16 <dcoutts> it's --flags=feature or --flags=-feature  (or --flags="feature1 -feature2")
08:14:28 <iwtu> I dont see a problem :( http://codepad.org/FHYpM5cd
08:15:02 <ion> See above.
08:15:18 <balor> dcoutts: thanks.  Should have looked there rather than online
08:16:06 <dcoutts> balor: yeah, sorry, I'm still rewriting the user guide to document this stuff
08:17:16 * hackagebot bullet 0.2.2 - A wrapper for the Bullet physics engine.  http://hackage.haskell.org/package/bullet-0.2.2 (CsabaHruska)
08:23:05 <iwtu> ion I see. can you give me hint how to solve it? hope it is clear what I wish
08:24:21 <kstt> is there a plan for proper heterogeneous lists in haskell ? I'm thinking of a list of types that are instances of typeclasses. IOW, no "[ Box x, Box y ] :: Box a" but "(| a, b |) :: Foo a, Bar a => (|a|)".
08:24:46 <kstt> should I put [ ] around "Box a"
08:25:05 <kstt> errr..... "I should have" ...
08:25:26 <ion> iwtu: What’s a specific example of input and the specific desired output?
08:25:30 <Jafet> > [1, "1"] :: [Show a => a]
08:25:31 <lambdabot>   Couldn't match expected type `a'
08:25:31 <lambdabot>         against inferred type `[GHC.Types....
08:25:37 <dolio> That isn't an appropriate type for it.
08:25:37 <dolio> But the answer is no.
08:26:58 <dolio> The type would be something like [exists a. (Foo a, Bar a) *> a].
08:27:13 <dolio> But only UHC has first class existentials to my knowledge, and they don't work with type classes.
08:27:47 <kstt> I don't like much the various workarounds I see in haskell database interfaces to pass arbitrary number of arguments to SQL requests
08:28:47 <kstt> dolio: do you see a theorical showstopper in the concept of "Foo a, Bar a => (|a|)"
08:28:48 <kstt> ?
08:29:28 <Jafet> dolio's type looks more sensible
08:29:31 <dolio> The quantification is in the wrong place.
08:29:54 <kstt> ok, agreed
08:30:05 <scree> kstt: so, are you aware of workarounds such as "data Showable = forall a . Show a => Showable { unShowable :: a }"?
08:30:13 <Jafet> Doesn't HList allow class constraints?
08:30:43 <ben> iwtu: A list comprehension returning a list is of type [[a]], you're trying to prepend chars to a list of strings
08:30:47 <kstt> scree: "Showable" is "Box" in my previous example, right ?
08:31:09 <iwtu> ion I have operator + -  * and my desired output for vyraz [1,2,3] is alll posibilities with operators in between. ['1','+', '2', '+',3], ['1','+',2,'*','3'], ...
08:31:10 <dolio> Yes. Except Box shouldn't really have a parameter.
08:31:28 <Jafet> kstt: the constraints have to be attached to the wrapper type
08:31:32 <scree> kstt: I don't think it can be (though I don't understand your Box): Showable has no type argument, whereas your Box does
08:32:19 <dolio> kstt: Existentials of the form I wrote have been considered for inclusion in GHC, I think, but the verdict was that they're too complicated in conjunction with everything else.
08:32:32 <kstt> scree: indeed, the type argument was a mistake. I was thinking of the existantial type trick you mentioned indeed.
08:34:22 <ben> iwtu: your types don't match up with that
08:35:18 <iwtu> ben, yes. Actually I can't figure out how to do that
08:35:39 <ben> you're starting with [1,2,3], right? That's [Integer] or something
08:35:54 <rvn_> I've just been watching a Google TechTalk on Google Go and how one of the slides states that 'You can be productive or safe, not both.'
08:36:00 <rvn_> It made me chuckle.
08:36:13 <dankna> hah, nice
08:36:58 <rvn_> One thing that has always struck me about Haskell is how productive you can be...
08:37:14 <iwtu> ben I can start with ['1','2','3'] ...
08:37:38 <ben> And you're generating a list of strings, right, not a list of Char
08:38:18 <ben> http://codepad.org/6DKSThNj does that look about right
08:38:22 <ben> i'm not sure how i got there but it typechecks
08:39:19 * hackagebot stunts 0.1.1 - A revival of the classic game Stunts (LambdaCube tech demo)  http://hackage.haskell.org/package/stunts-0.1.1 (CsabaHruska)
08:41:01 <iwtu> ben thanks a log. I am not very clever today. How easy...
08:41:48 <ben> I'm not the best guy with list comprehensions D:
08:42:29 <matthiasgorgens> What's the right point-less code to do: IO (Maybe a) -> (a -> IO (Maybe b)) -> IO (Maybe (Maybe b))
08:43:14 <matthiasgorgens> (I'm just struggling with the fmaps..)
08:43:20 * hackagebot Stomp 0.1 - Client library for Stomp brokers.  http://hackage.haskell.org/package/Stomp-0.1 (VitaliyRukavishnikov)
08:43:35 <ksf> you sure about that IO (Maybe (Maybe b))?
08:43:38 <Eduard_Munteanu> Hm, do you really wan,,,
08:43:49 <Eduard_Munteanu> Dang :)
08:44:04 <ksf> otherwise, it's already pretty close to >>=
08:44:04 <iwtu> ben, ion thanks. I have to go. bye :)
08:44:20 <ben> bye
08:44:38 <matthiasgorgens> ksf, yes.
08:44:43 <ksf> of course, there's two different possible outcomes: didn't run the action or action returned nothing.
08:45:11 <ksf> (or action returned just, of course)
08:45:20 <matthiasgorgens> IO (Maybe a) is actually a (readMVar something)
08:45:33 <matthiasgorgens> and (a -> IO (Maybe b)) is getProcessExitCode.
08:45:39 <joe6> is there a smarter way of writing this: http://pastebin.com/Sakxfn5u
08:45:41 <mauke> The paste Sakxfn5u has been copied to http://hpaste.org/48211
08:47:06 <ksf> :t \ m -> m >>= maybe (return Nothing)
08:47:07 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (Maybe a1 -> a1 -> m (Maybe a)) -> Maybe a1 -> m (Maybe a)
08:47:39 <ksf> erm.
08:47:50 <ksf> yes. first thing, get rid of that "Maybe b".
08:47:54 <ksf> that's equivalent to b.
08:48:16 <ksf> and then I utterly failed pointless.
08:48:20 <matthiasgorgens> ok.
08:48:24 <ksf> :t \m f -> m >>= maybe (return Nothing) f
08:48:25 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => m (Maybe a1) -> (a1 -> m (Maybe a)) -> m (Maybe a)
08:48:30 <matthiasgorgens> I guess I'll just write it with points, then.
08:49:04 <ksf> I don't think there's a particularily readable pl-version.
08:49:17 <ksf> @pl  \m f -> m >>= maybe (return Nothing) f
08:49:17 <lambdabot> (. maybe (return Nothing)) . (>>=)
08:49:52 <matthiasgorgens> Oh, I guess I could just give an instance for Monad (\x -> IO (Maybe x))
08:50:01 <matthiasgorgens> then >>= would do the trick.
08:50:05 <joe6> is there a smarter way of writing this function: http://pastebin.com/D7Tn8jXc
08:50:07 <mauke> The paste D7Tn8jXc has been copied to http://hpaste.org/48212
08:50:13 <ksf> that's, basically, ErrorT.
08:50:17 <matthiasgorgens> Yes.
08:53:04 <zygoloid> mauke: is that a script?
08:53:12 <mauke> yes
08:54:14 * zygoloid likes :)
08:54:18 <joe6> mauke, that is a very cool script. very helpful. good job.
08:58:05 <yitz> joe6: there are many ways to write it, but to me your code looks very clear and readable.
08:59:58 <joe6> yitz, ok, thanks.
09:16:24 * hackagebot crypto-api 0.6.2 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.6.2 (ThomasDuBuisson)
09:30:53 <tommd> Is e-mail address verification broken on trac.haskell.org?
09:50:28 <xil> hi. How do I run a compiled haskell file in linux if I compiled with "ghc -package GLUT fNEAT.hs -o fNEAT.o"?
09:50:44 <ben> ./fNEAT.o I suspect
09:50:51 <xil> I tried that, didn't work
09:50:54 <tommd> xil: It should have produced a binary in the local directory
09:51:02 <tommd> xil: run "ls" - do you see a binary?
09:51:14 <xil> wait...I did chmod +x fNEAT.o, should I not have?
09:51:17 <xil> there is a binary there
09:51:48 <tommd> it should be executable already, so that shouldn't be needed.  But why are you calling it ".o" - it should actually be a binary (executable), not just an object file
09:52:08 <Nimatek> "I run for office and win! I am Treasurer!" dem Jews.
09:52:13 <tommd> what does it say when you run ./fNEAT.o?
09:52:56 <xil> oh I just picked an extention because I wanted it to just be fNEAT but there is already a folder with that name and the compiler complained. When I do ./fNEAT.o it says permission denied, and if I chmod +x then it says "cannot execute binary file"
09:53:05 <Lemmih> xil: What version of GHC are you using? You might need --make if you're using an older version.
09:54:08 <xil> latest version. But actually I just tried compiling again but this time with the .bin extension and now I'm getting errors...I wasn't before
09:54:15 <xil> so that could have been the problem
09:54:15 <tommd> Anyone here in or near Portland and want a Hackathon?
09:55:53 <xil> well these errors are related to GLUT. Someone wouldn't happen to be familiar with it? I'm getting undefined references to a bunch of GLUT stuff
09:57:03 <parcs> ~]\
09:57:05 <parcs> =
09:57:13 <parcs> damn keyboard..
10:01:51 <tommd> xil: Do you have the needed GLUT libraries (c libraries)?
10:02:25 <tommd> I'd first try to determine where the references are supposed to come from (probably the c libraries), then find out if you already have them.
10:03:09 <tommd> if you have them then check that GHC is linking them properly (right directory?) , if not then just install your distros dev package (??-dev or ???-devel usually)
10:03:36 <xil> tommd: let me see.....Thing is, I installed from Arch packages, so I would think it would appropriately deal with dependencies and such, but I know I can't always rely on that
10:05:15 <xil> tommd: okay so I'm not exactly sure about how to go about this. Could I pastbin you the error? There are only about 6 or 8 undefined references
10:05:59 <tommd> go for it
10:06:19 <xil> tommd: http://pastebin.com/9igxAGsm
10:06:21 <mauke> The paste 9igxAGsm has been copied to http://hpaste.org/48215
10:10:49 <tommd> xil: Those functions (at least, the ones I looked for) live in libglut.so
10:10:57 <tommd> xil: Do you have libglut.so anywhere?
10:11:02 <tommd> locate libglut.so
10:11:15 <tommd> If not, then pacman -S freeglut
10:11:19 <tommd> and run "sudo ldconfig"
10:12:02 <tommd> if so, then still run "sudo ldconfig" and next time compile with verbosity turned up (flag: -v)
10:12:35 <tommd> Then look to see if the correct linker flag is included (-lglut I figure)
10:13:07 <tommd> If it isn't, then some package wasn't setup right (glut) if it is, and the build still doesn't work, then I'm at the limit of what I can do over IRC.
10:13:35 <identity_> programming with only one monitor is terrible. Now I know how the kids in the third-world countries must feel :(
10:13:46 <tommd> lol
10:15:48 <drosophyllum> @tommd => pacman? Ive been considering switching from ubuntu to  arch. What do you like about it?
10:15:48 <lambdabot> Unknown command, try @list
10:17:35 * hackagebot bindings-bfd 1.0.0 - Bindings for libbfd, a library of the GNU `binutils'  http://hackage.haskell.org/package/bindings-bfd-1.0.0 (MichaelNelson)
10:17:56 <tommd> @drosophyllum I haven't used Arch in over a year, I'm probably not the person to ask.  I did like it for how simple everything was. ex: if you don't like dbus.. don't install dbus, it isn't forced on you - very little comes "in the box"
10:17:56 <lambdabot> Unknown command, try @list
10:18:37 <identity_> tommd: why not go hardcore with gentoo?
10:18:49 <identity_> Don't like gentoo? Don't compile it! Doesn't get more barebones than that
10:18:50 <tommd> drosophyllum: OTOH, it didn't do any package signing and many nitch projects I wanted weren't already packaged (even on their 2nd tier packaging repo)
10:19:53 <kmc> irc ≠ twitter
10:20:08 <xil> tommd: I have several versions of libglut.so. I have the plain version and also libglut.so.3 and .so.3.9.0 and freeglut is installed
10:20:13 <tommd> identity_: No real reason.  I'm not quite so into building and playing with the various distros as I used to be, that's about all.  My time is more limited than it once was.  Something about havingbabybuyinghouseworkingtowardaphdgoingbroke causes time to fly by.
10:20:22 <drosophyllum> I did go with gentoo, its nice but sometimes i found it annoying to have to wait for things to compile
10:20:40 <identity_> tommd: So my brother tells me
10:20:51 <kmc> i don't have a baby, a house, or a phd but i also don't care as much as i used to
10:20:54 <kmc> debian works fine for me
10:21:19 <kmc> i'd rather spend my hacking time making something cool
10:21:27 <kmc> instead of learning a new package manager with basically the same flaws
10:21:42 <kmc> that said i'm interested in NixOS, because it seems like it's actually different
10:21:46 <tommd> But pacman is different... it doesn't verify the packages!
10:21:49 <kmc> in the way Haskell is actually different
10:22:06 <tommd> kmc: I've considered that one - could you blog about it if/when you try it?
10:22:12 <kmc> sure
10:22:37 <kosmikus> kmc: just try it .. it's cool :)
10:22:51 <identity_> kmc: :| DIFFERENT? Are you insane? Why would you do anything different? change is bad! IPv4 is fine, serial communication was more than fast enough for everything and so on.
10:22:55 <identity_> Change is bad.
10:23:05 <thoughtpolice> also: 640k of RAM.
10:23:08 <identity_> ^
10:23:14 <tommd> It's fitting that your name is identity...
10:23:17 <Favonia> kmc: i am intersted in "the flaw"... do you mind explaining about it?
10:23:32 <kmc> shrug
10:23:36 <kmc> i don't have a particular flaw in mind
10:23:37 * hackagebot snap-server 0.5.1.4 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.5.1.4 (GregoryCollins)
10:24:02 <tommd> @quote+ identity_ Change is bad.
10:24:03 <lambdabot> No quotes for this person. :(
10:24:04 <monochrom> 640MB of RAM is enough for my linux
10:24:25 <identity_> tommd: I don't get what you mean by my nick fitting
10:24:27 <identity_> do explain
10:24:38 <tommd> > id 5
10:24:39 <lambdabot>   5
10:24:42 <identity_> ah
10:24:44 <identity_> yeah, like that
10:24:44 <tommd> huh, the argument didn't change.
10:24:57 <identity_> actually, that is where my nick came from
10:24:58 <identity_> IIRC
10:25:09 <identity_> > argument didn't change
10:25:10 <lambdabot>   Not in scope: `argument'Not in scope: `didn't'Not in scope: `change'
10:25:13 <identity_> Sounds like my mother
10:25:18 <identity_> Or any woman I've been with
10:25:27 <identity_> wow. I was not implying that I've been with my mother
10:25:37 <identity_> I'm going to sit in a corner now.
10:25:48 <drosophyllum> lol
10:25:53 <tommd> Time to work.
10:26:34 <monochrom> haha
10:32:44 <xil> tommd: oh sorry I missed the other things you said. So I did those things and when I run with -v I get the expected huge mess. I can't be sure that -lglut isn't there but I don't see it. I do see -lGL and -lGLU though
10:34:00 <tommd> xil: if you pipe it through a grep then you should see glut (or not): "ghc -v ... | grep -i glut"
10:35:54 <xil> tommd: actually already tried that. The output I see appears not to pipe. I did "ghc -v ... >> temp" just to be sure and when I did "cat temp" it just output "[1 of 1] Skipping  Main             ( fNEAT.hs, fNEAT.o )"
10:36:29 <tommd> xil: If this proves to be the issue I would suggest you get the Haskell glut source (cabal unpack GLUT), edit the .cabal file and add to the "extra-libraries:" line an entry of "glut".  If there is no "extra-libraries:" line then add one.
10:36:46 <tommd> You can use HOpenCV's .cabal file as an example of a package with an "extra-libraries:" entry.
10:37:15 <tommd> xil: That's because the verbosity goes to stderr
10:37:39 <tommd> xil: ghc -v ... 1>tmp 2>&1 ; grep -i glut tmp
10:38:25 <tommd> xil: or just ghc -v ... 2>&1 | grep -i glut
10:38:35 <ben> can a 64bit build of ghc generate 32bit elf executables?
10:40:07 <kmc> probably not; each build of GHC has hardcoded in various places the layout of certain structures
10:40:45 <ben> right, cheers
10:41:00 <kmc> you could ask in #ghc to see if they know a way
10:41:09 <xil> okay, so there is "extra-libraries: glut" and when I do the fixed pipe I don't get anything, haha. So what if I recompile from cabal? I saw on a forum somewhere that someone recompiled from source and it worked. I never did anything cabal related, just Arch, so maybe that's the problem? I would ask how to do the cabal stuff though. I don't know anything about cabal
10:41:25 <xil> @tommd ^
10:41:26 <lambdabot> Unknown command, try @list
10:41:39 <xil> tommd: ^
10:48:03 <xil> tommd: okay I did a "cabal install GLUT" and that seems to have fixed it. I would think then that the Arch package was compiled before they added the glut extra library? Or maybe the libglut.so I had was in the wrong place? Either way now it works, haha. Thank's for the help! I appreciate it
10:48:06 <tommd> xil: Just "cabal install" when in the directory of "glut" (if you have it unpacked) or just "cabal install GLUT" and it will download/unpack automatically
10:48:21 <tommd> xil: Glad it worked.
10:48:29 <tommd> xil: You should mention this issue in #haskell-arch
10:48:47 <tommd> that isn't the right channel... I thought they had one.
10:48:59 <tommd> well, there is a maintainer who should know about this if you can find him.
10:49:59 <xil> tommd: if I do I'll tell him
10:50:42 <DukeDave> Am I really correct in thinking there's is no compliment to concat, which specifies the length of the internal lists?
10:50:50 <DukeDave> foo :: Int -> [a] -> [[a]]
10:51:21 <DukeDave> splitAt returns a tuple
10:51:25 <tommd> what you want is a "chunk" function
10:51:36 <parcs> @hackage split
10:51:37 <DukeDave> tommd: That's a good word for it
10:51:37 <lambdabot> http://hackage.haskell.org/package/split
10:51:41 <tommd> dukedave: There is a lists package (can't recall it's exact name) that has this, among other, functions.
10:52:08 <DukeDave> parcs++
10:52:22 <DukeDave> tommd: Thanks, there is! parcs got it
10:52:27 <tommd> great
10:52:34 <tommd> When in doubt, #haskell it out.
10:53:13 <DukeDave> :t splitEvery
10:53:14 <lambdabot> Not in scope: `splitEvery'
10:53:32 <DukeDave> :t Data.List.splitEvery
10:53:33 <lambdabot> Not in scope: `Data.List.splitEvery'
10:53:47 * DukeDave never knows what lambabot has imported :|
10:53:53 <tommd> You can tell lambdabot to import non-base modules, but I don't recall how or know which packages it has installed.
10:54:07 <tommd> s/non-base/uncommon
10:54:47 <DukeDave> tommd: Ah well. And yes, I really don't know how everyone isn't using Haskell with this channel being so wonderful
10:59:39 <parcs> @girl19
10:59:40 <lambdabot> LOL
10:59:59 * djahandarie raises eyebrow
11:00:10 <parcs> @yhjulwwiefzojcbxybbruweejw
11:00:10 <lambdabot> "\""
11:00:29 <parcs> @brain
11:00:30 <lambdabot> Zort!
11:07:18 <mgccl> can currying be used for the 2nd argument of the function? for example I have a function f x y. can I produce a function that is like f _ y, and then I apply x on it to get f x y?
11:07:41 <arw__> yes. try flip . something
11:08:07 <shachaf> mgccl: Also, that's not currying, it's partial application.
11:08:32 <shachaf> You can also express it with a section as (`f` y), or with a lambda as (\x -> f x y).
11:08:52 <kmc> also it's not partial application, it's application [/pedantic]
11:08:58 <kmc> (just kidding, i never turn off pedantic mode)
11:09:49 <shachaf> kmc: What does "partial application" mean, if not returning a function?
11:09:56 <mgccl> I see, thanks. :D this place is so helpful. new to Haskell. xD
11:10:11 <kmc> i'd say that in the most technical and pedantic sense, there are no partial applications in Haskell
11:10:21 <kmc> every function takes one argument, so there's no way to partially fulfill that
11:10:28 <monochrom> > (`map` [True,False]) not
11:10:28 <lambdabot>   [False,True]
11:10:51 <kmc> is there a typeclass-overloaded containers interface which generalizes over Map, IntMap, etc?
11:11:11 <monochrom> no, but if you go edison, there is
11:14:59 <lispy> theorbtwo: my kind is clearly better?  Is that some sort of racisum?
11:15:23 * lispy can't spell
11:15:35 <lispy> preflex: seen pastorn
11:15:36 <preflex>  pastorn was last seen on #haskell 3 days, 21 hours, 46 minutes and 47 seconds ago, saying: gwern: ^^^
11:22:01 <ukl> hello.  I'm playing around with repa, but I fail at the following: I'm basically trying to foldAll a DIM3-array but I need the indices of the elements.  At the moment I'm trying to construct this using traverse, but it doesn't seem obvious to me if that's a possible way at all..
11:23:30 <hpaste> mal pasted “Why this error?” at http://hpaste.org/48217
11:23:59 <maloi> uhh that's cool :)
11:24:04 <kmc> you probably mean (x:xs) not [x:xs]
11:24:14 <danharaj> How much copying does using a Zipper use? It seems like there should be very little copying, just pointers to sub-values of the value being Zipper'd, so something like C*N words for a small C, if the Zipper holds on to N contexts.
11:24:15 <maloi> damn
11:24:30 <kmc> the pattern [p] matches a list of exactly one element, if that element matches 'p'
11:25:34 <hpaste> maloi annotated “Why this error?” with “Why this error? (annotation)” at http://hpaste.org/48217#a48218
11:25:43 <maloi> now i get this error
11:26:41 <kmc> can you think about it for a few minutes?
11:26:51 <maloi> i do :)
11:26:56 <kmc> ok
11:27:03 <monochrom> x ++ [s] ++ (my_join s xs)
11:27:06 <monochrom> obviously
11:27:20 <monochrom> > "my_join xs" == "my_join s xs"
11:27:20 <lambdabot>   False
11:27:42 <k0ral> I'm looking for the equivalent of signal::notify in glib's haskell binding
11:28:01 <maloi> monochrom: thanks but why can't he complain about funtion not found or something like that
11:28:15 <k0ral> to asynchronously trigger a callback when an object's attribute changes
11:28:24 <k0ral> can't find how it is done in the haskell's binding
11:28:25 <confound> because that's not the error
11:28:26 <monochrom> it is not "function not found"
11:28:36 <k0ral> could someone give me a hint please ?
11:28:49 <ukl> the issue I'm struggling with is that the lookup function argument of traverse is of type (sh -> a) but the function that produces the elements of the resulting array is of type "sh' -> a", so it doesn't know about the origin arrays shape so it cannot reduce it...
11:29:13 <ukl> I'm pretty confused.  Any example of traverse where the shape changing function is not "id" would be very appreciated
11:29:21 <maloi> monochrom: ok
11:29:30 <kmc> maloi, if you've defined (f x y) then it's perfectly valid to call (f x)
11:29:34 <kmc> it returns a function which takes the y
11:29:53 <maloi> i have to think  about this
11:30:09 <kmc> that's why we write types like (A -> B -> C), which is shorthand for (A -> (B -> C))
11:30:19 <kmc> you pass the A argument and get back a function, which takes the B argument
11:30:33 <maloi> yes
11:31:13 <maloi> i'm not sure i understand this right for now
11:31:24 <maloi> but thank you
11:31:30 <kmc> ok, we can help you understand :)
11:31:33 <monochrom> you called my_join wrongly
11:33:03 <maloi> i i think i understamnd now
11:36:28 <maloi> so if i cal my_join 1 it call my_join with one "argument" und want's to return a function ([[a]] -> [a])
11:37:14 <maloi> sorry for my grammar :/
11:40:10 <Botje> you learn by doing :)
11:40:34 <maloi> i'm doing right now :D
11:48:57 <maloi> is there an advantage in doing x ++ s:(my_join s xs) instead of x ++ [s] ++ (my_join s xs)?
11:49:34 <tromp> no
11:50:09 <tromp> actually, there may be
11:50:17 <kmc> possibly a tiny performance difference
11:50:22 <kmc> probably it gets optimized out by a decent compiler
11:50:25 <tromp> is ++ right associateive?
11:50:33 <Botje> it's infixr
11:50:50 <Botje> so yes :)
11:50:50 * hackagebot swish 0.3.2.1 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.3.2.1 (DouglasBurke)
11:50:55 <tromp> then difference is negligable
11:51:03 <maloi> ok so as a newbie i don't have to think about it
11:52:44 <tromp> not in this case
11:58:39 <balor> So I rm -rf'ed my ~/.cabal Is there a "better" way of trying to purge everything installed?
11:59:02 <balor> Given that removing ~/.cabal doesn't seem to purge things
11:59:14 <parcs> also remove ~/.ghc
11:59:34 <DukeDave> Erm, I have [Bool] and [a], I would like to zip them such that all (False,a) pairs are removed. I'm thinking of something using catMaybes, but I can't quite formulate it. Does anyone have any ideas?
11:59:35 <balor> great, thanks
11:59:58 <applicative> balor, I take it you have a copy of cabal itself outside of ~/.cabal/bin ....
12:00:49 <balor> applicative, yes.  A system installed one that my user doesn't touch
12:01:32 <kosmikus> DukeDave: try zipping, then filter
12:01:35 <DukeDave> The purpose is to randomly remove a certain fraction of items from a list, using this:
12:01:35 <DukeDave> keepOneIn n = getRandomRs (0::Int,n-1) >>= return . map (==0)
12:02:07 <DukeDave> kosmikus: Oh yes, that would be simpler, I don't know why I didn't think of that
12:02:08 <balor> DukeDave, [foo | (foo, True) <- zip a b] ?
12:02:22 <DukeDave> balor: Ah, also clever
12:03:08 <DukeDave> balor: I didn't know you could match like that, I'd been doing [foo | (foo, keep) <- zip a b, keep]   :D
12:04:03 <Botje> it's pattern matching as usual :)
12:04:59 <tommd> DukeDave: It works because pattern match failures call "fail", which is set to [] for the list monad.
12:05:28 <DukeDave> Isn't that clever :)
12:05:48 <yrlnry> A bit too clever.
12:06:08 <tommd> Be wary! The powers that be have been known to change the definition of "fail" for very basic types (grumble grumble, Either, grumble)
12:06:35 <tommd> Not that they'll change it for list... that would be foolish...
12:07:34 <parcs> tommd: how has it changed?
12:08:48 <tommd> parcs: It used to be 'fail = Left' (for Either String) but was changed to error in base 4, iirc.
12:08:55 <tekknolagi> testing Pidgin IRC
12:09:14 <stephanmg> bye.
12:09:16 <tommd> Err no, that's mtl I gues
12:09:17 <tommd> guess
12:11:48 <tommd> Right, now I seem to be remembering.  It was moved into base and changed at the same time.
12:13:56 * hackagebot sphinx 0.4.0.3 - Haskell bindings to the Sphinx full-text searching deamon.  http://hackage.haskell.org/package/sphinx-0.4.0.3 (GregWeber)
12:14:32 <w3rs> :t \f g x -> f (g x) x
12:14:33 <lambdabot> forall t t1 t2. (t1 -> t -> t2) -> (t -> t1) -> t -> t2
12:15:20 <w3rs> does anybody know commonly used function like above
12:15:31 <w3rs> ?
12:15:46 <Botje> that's join in the (r ->) monad, no?
12:15:50 <Botje> uh
12:15:52 <Botje> >>=
12:16:00 <Botje> @src >>= ((->) r)
12:16:00 <lambdabot> Source not found. The more you drive -- the dumber you get.
12:16:12 <siracusa> @pl \f g x -> f (g x) x
12:16:12 <lambdabot> flip flip id . liftM2
12:16:16 <parcs> @src ((->) r) (>>=)
12:16:16 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
12:16:23 <Botje> i can never get that one right :(
12:16:25 <parcs> :t ap . flip
12:16:26 <lambdabot> forall a b a1. (a -> a1 -> b) -> (a1 -> a) -> a1 -> b
12:16:34 <shachaf> @src (->) (>>=)
12:16:34 <lambdabot> f >>= k = \ r -> k (f r) r
12:17:10 <w3rs> thank. people
12:17:57 <siracusa> :t ap
12:17:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:18:56 * hackagebot sphinx 0.4.0.4 - Haskell bindings to the Sphinx full-text searching deamon.  http://hackage.haskell.org/package/sphinx-0.4.0.4 (GregWeber)
12:19:52 <Wanttolearn> Hi.Im 12 years old and I wish to learn Haskell, is there any book with the title Haskell for idiots. :P
12:20:14 <parcs> Wanttolearn: go outside, socialize instead
12:20:22 <Wanttolearn> ahahah
12:20:25 <monochrom> no, but there is "learn you a haskell for great good"
12:20:39 <Wanttolearn> I need something really easy to start
12:20:48 <Wanttolearn> Thanks.:)
12:21:04 <tommd> Wanttolearn: "Learn you a Haskell for Great Good" will take you from zero.  If you think you know how to program already, then perhaps Real World Haskell will work for you.
12:21:23 <Wanttolearn> Its my first language
12:21:26 <tommd> Wanttolearn: and people here have been known to spend large amounts of time one-on-one working through issues and understanding.
12:21:37 <Wanttolearn> Hmm
12:21:42 <Wanttolearn> How so
12:22:04 <kmc> parcs, when I was 12 i did not know many people worth socializing with.  also they had this 8 hour per day block of mandatory government-enforced socializing
12:22:09 <tommd> Well, say you wonder how "liftM (take 1) getArgs" works
12:22:09 <danharaj> How did you find out about Haskell?
12:22:24 <kmc> parcs, so i think spending free time on the computer and becoming incredibly skilled in a fulfilling, lucrative field is a reasonable use of time
12:22:55 <vegai> kmc: but not *all* free time
12:22:56 <Wanttolearn> I have read every intro from sheme ocaml c c++ all scriptiing langauges
12:23:10 <Wanttolearn> and have to conclusion haskell is the ebst
12:23:19 <tommd> Wanttolearn: Also, there are Haskell user groups spread around - if you are physically located near any of them then go see what they have to offer.
12:23:43 <Wanttolearn> Im locaten nowhere any haskell location
12:23:47 <Wanttolearn> near
12:23:59 <Wanttolearn> noone even know about haskell
12:24:02 <tommd> If you say so.
12:24:06 <Wanttolearn> :)
12:24:25 <danharaj> @where zipper
12:24:25 <lambdabot> http://www.haskell.org/haskellwiki/Zipper
12:24:26 <tommd> Even places like WhiteFish Montana have Haskllers (periodically).
12:24:56 <vegai> Wanttolearn: are you really 12 and if so, do you find Haskell difficult?
12:25:03 <tommd> But in general, this map is accurate for where Haskellers are: http://www.haskellers.com/
12:25:05 <Wanttolearn> Yes and no
12:25:19 <Wanttolearn> And yes im 12
12:26:01 <DukeDave> Wanttolearn: This is a nice place to start: http://tryhaskell.org/
12:26:04 <vegai> so you already know some?
12:26:15 <Wanttolearn> no.Nothing on my country
12:26:24 <Wanttolearn> no haskellers
12:26:32 <Wanttolearn> :/
12:26:32 <vegai> know some haskell, that is?
12:27:15 <Wanttolearn> just started I have gonne throgh try haskell
12:27:21 <Wanttolearn> its very well done
12:27:25 <Wanttolearn> like tryruby
12:27:32 <nus> Wanttolearn, what, no haskellers at all in Republika Srpska?
12:27:39 <Wanttolearn> no
12:28:00 <Wanttolearn> not even books
12:28:00 <HugoDaniel> :)
12:28:41 <sm> hey all.. can anyone think of library, any language, providing a rdbms- or other db-like api to a structured flat file ? I'm looking for examples to follow
12:28:59 <Wanttolearn> So what should I try for after tryhaskell that is on my level
12:29:03 <Wanttolearn> :)
12:29:13 <tommd> learn you a haskell
12:29:27 <tommd> Or start your own Haskell project.
12:29:44 <kmc> the author of LYAH is from two countries over
12:29:47 <Wanttolearn> ?
12:29:55 <kmc> @where LYAH
12:29:56 <lambdabot> http://www.learnyouahaskell.com/
12:30:35 <Wanttolearn> Well Slovenia is very far away. :)
12:31:11 <develhevel> need help with HXT, i search for a id and want to get its children names in a list, but all in one request e.g. i have a parent a and two children c1 and c2. so i get [(a,c1),(a,c2)] but i want [(a,[c1,c2])]. my request looks like: "getAttrValue "id" &&& (getChildren >>> getAttrValue "id")"
12:32:38 <vegai> I wonder if a zedshawian "Learn Haskell the Hard Way" would be a good idea
12:32:39 <rozgo> NICK rozgo
12:34:37 <Wanttolearn> ?
12:34:52 <shapr> !
12:34:56 <shapr> Wanttolearn: o hai
12:35:06 <Wanttolearn> :)
12:35:11 <Wanttolearn> so any recommendation
12:35:26 <kmc> read LYAH
12:35:57 <Wanttolearn> Ok.Thanks:)
12:36:01 <shapr> and ask questions here!
12:36:05 <Wanttolearn> ok
12:36:11 <Wanttolearn> Thanks for the help
12:36:16 <Wanttolearn> and your time
12:36:17 <Wanttolearn> :)
12:36:18 <shapr> Wanttolearn: Or you could try each of the options for an hour or two, and see what works best for you.
12:36:19 <kmc> yeah, there are always people here to help
12:36:25 <kmc> i recommend looking at RWH also
12:36:27 <kmc> @where RWH
12:36:28 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:36:30 <kmc> see which books suits you
12:36:37 <Wanttolearn> Ok.:)
12:36:41 <identity_> hmm. Functions with complex types whose signature you divide up into multiple lines, do you just put the next -> Foo on the next line at normal indentation level, or do you indent so that it matches the :: in the function name?
12:37:04 <kmc> identity_, I never let the width of a name on line n determine the indentation on line n+1
12:37:13 <kmc> so i'd say
12:37:14 <kmc> foo
12:37:15 <kmc>   :: A
12:37:17 <kmc>   -> B
12:38:03 <saml> > 1/0 == 1/0.0
12:38:05 <lambdabot>   True
12:38:05 <hpaste> identity pasted “complex type indentation level” at http://hpaste.org/48220
12:38:24 <identity_> kmc: which one?
12:38:30 <kmc> neither
12:38:44 <hpaste> kmc annotated “complex type indentation level” with “complex type indentation level (annotation)” at http://hpaste.org/48220#a48221
12:38:55 <identity_> Oh
12:38:56 <identity_> I like that
12:38:57 <kmc> never let the width of a name on line n determine the indentation on line n+1
12:39:07 <kmc> this is just my rule, feel free to follow it or ignore it
12:39:11 <kmc> i even ignore it occasionally
12:39:27 <kmc> it makes refactoring easier
12:39:37 <kmc> it makes your code look nicer and more consistent
12:39:57 <kmc> it avoids the tradeoff between wasting huge amounts of left margin and using excessively short names
12:40:04 <identity_> yeah
12:40:17 <identity_> Consistency is the single best thing to maintain to make code look good
12:40:19 <kmc> i use this for all the layout constructs
12:40:29 <kmc> it looks great for "do"; somewhat less awesome for "let"
12:40:37 <kmc> really sucks for multi-decl let-inside-do
12:40:40 <identity_> Let is annoying
12:45:09 <DukeDave> Is there a nicer way of formatting something like this:         m >>= \x > (1,'a', x)
12:45:22 <mike-burns> Name the second argument to (>>=)
12:45:42 <mike-burns> It'll look nicer.
12:45:43 <kmc> with -XTupleSections:  m >>= (1,'a',)
12:45:52 <DukeDave> Sorry, some thing like:    m >>= \x > return (1,'a', x)
12:46:10 <kmc> m >>= (\x -> return (f x))  ≡  fmap f m
12:46:10 <DukeDave> kmc: Ah I wondered if you would do that
12:46:44 <kmc> fmap (\x -> (1, 'a', x)) m
12:46:52 <kmc> fmap (1,'a',) m
12:47:02 <kmc> or even:  (1,'a',) <$> m
12:47:03 <identity_> kmc: that is sexy
12:47:45 * DukeDave dies
12:47:50 <DukeDave> This channel, sometimes :)
12:47:53 <DukeDave> kmc++
12:49:30 <identity_> DukeDave: awesomest programming language irc community on earth bro.
12:49:50 <DukeDave> identity_: True dat ;)
12:51:00 * hackagebot happstack-server 6.1.4 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.1.4 (JeremyShaw)
12:53:35 <smadgeprime> does anybody have any information about the pdx-func study group?
12:59:01 <maurer_> Hey, anyone here using the gentoo haskell overlay?
12:59:25 * maurer_ just switched to gentoo, and is wondering if it will be possible to use portage, or if I should just continue using cabal + manual ghc
13:00:47 <kmc> maurer_, nice
13:01:21 <develhevel> can anybody help me with this XML question http://stackoverflow.com/questions/6460154/haskell-hxt-help-getting-a-list-of-elements
13:02:13 <ksf> maurer_, yes
13:02:19 <maurer_> kmc: The overlay has built ghc successfully in the past for me, but now encounters errors.
13:02:28 <ksf> I'm only using the overlay for "system" stuff, though.
13:02:35 <maurer_> err, ksf
13:02:53 <ksf> well, no, I think you meant kmc
13:02:58 <monochrom> develhevel: I'll test it in a moment: ... &&& arrL (getChildren >>> isElem >>> getAttrValue "name")
13:03:19 <maurer_> k* Would you guys advise debugging the ebuild, building manually, or masking and waiting to fix it?
13:03:26 <ksf> maurer_, the ghc build should work.
13:03:39 <monochrom> it takes forever to test because I don't even remember the modules to import
13:03:41 <ksf> if not, drop by on @gentoo-haskell, they're going to love to hear about a bug.
13:03:51 <maurer_> ksf: k
13:04:05 <ksf> #, not @
13:04:12 <develhevel> monochrom: would be more than nice if it works
13:07:41 <monochrom> sorry, it is not arrL, it is listA
13:08:25 <monochrom> it works. ... &&& listA (getChildren >>> isElem >>> getAttrValue "name")
13:09:44 <develhevel> monochrom: you made my day :) thank you very much
13:25:20 <parcs> in wxhaskell, how does one retrieve the input inside a textEntry ?
13:25:36 <parcs> i see no correspnding attribute instance for this type..
13:26:24 <sam5> hi
13:26:29 <sam5> I just wanted to double check
13:26:32 <parcs> hmm, maybe it's the 'text' attribute
13:26:38 <sam5> if haskell had any built in check for primes
13:27:04 <parcs> yep, it is. never mind
13:27:12 <gwern> sam5: no. we have an entire page on the wiki of dozens of implementations, though
13:27:38 <gwern> of sieve of eratosthenes alone, IIRC
13:27:39 <gwern> (primality testing tends to be one of those things where everyone needs something different...)
13:27:50 <sam5> hm.. I see
13:28:04 <sam5> so I do have to download sources right?
13:28:22 <sam5> I just wanted to double check because some math programming languages come with it
13:28:53 <gwern> some languages hardwire a lot of things. batteries included is a double-edged philosophy
13:29:29 <sam5> yes... I have been learning haskell for two weeks but it seems that its the best language for doing math
13:29:42 <sam5> it really makes it easy for me to think mathematically as I program
13:29:57 <kmc> most mathematicians would find it laughably absurd to speak of any programming language being good for doing math
13:30:30 <cafesofie> why?
13:30:30 <sam5> perhaps
13:30:36 <ddarius> We can disregard most mathematicians.
13:30:42 <kmc> i do not condone this view
13:30:54 <Nimatek> Because math is a lot more powerful and expressive than programming.
13:31:01 <kmc> Haskell is not that great for actually doing math, i.e. formalizing propositions and proving them
13:31:04 <kmc> there are other languages for that
13:31:11 <kmc> Haskell is great for applying math, though
13:31:18 <sam5> I used to do matlab for writing math programs
13:31:47 <sam5> I have to think mathematically, then think programming perspective to code it
13:31:49 * ddarius makes a philosophy that has countably many edges.
13:32:08 <sam5> but haskell... I would define it as I would define math
13:32:32 <ddarius> As a formal game of symbols?  Me too.
13:33:08 <dobblego> what is the adjective to describe two functions that are equivalent, in that each element of the domain maps to the same element in codomain, ignoring the fact that the two functions may be implemented differently in their body?
13:33:28 <ddarius> (Actually, I am not a Formalist, though I'm even less a Platonist.)
13:33:44 <ddarius> dobblego: "equal"
13:33:49 <drosophy1lum> I agree with you.... being able to express my thoughts in such a mathematical manner is very nice
13:34:03 <Codex_> hmm, I have slightly intreresting question: Has anyone got a full pullback working on a computer? Is it possible?
13:34:11 <dobblego> ddarius: there is a description of the type of equality -- I've just forgotten
13:34:16 <ash_> i thought there was a proof that said you cant formally prove two different functions are the same, but i could be wrong...
13:34:18 <shachaf> dobblego: Extensional?
13:34:24 <dobblego> shachaf: yay! thanks
13:34:47 <shachaf> ash_: It's not very difficult to prove that (\x -> (\y -> y) x) is the same as (\x -> x).
13:34:58 <Codex_> I keep hitting the wall when implementing one, end up using boolean stuff instead of the real thing
13:35:51 <develhevel> monochrom: do you know if it is possible to make a if expression in a XML query like: "... >>> if getName == "foo" then ...
13:37:00 <monochrom> there are ifA and ifP
13:37:40 <monochrom> ifA (hasName "foo") x y   is probably what you want
13:38:07 * hackagebot digestive-functors-happstack 0.1.0.1 - Happstack backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-happstack-0.1.0.1 (JasperVanDerJeugt)
13:40:07 * hackagebot hbro 0.5.3 - A suckless minimal KISSy browser  http://hackage.haskell.org/package/hbro-0.5.3 (koral)
13:41:27 * edwardk waves hello.
13:41:27 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
13:41:34 <edwardk> preflex: xseen jaspervdj
13:41:35 <preflex>  jaspervdj was last seen on freenode/#haskell 1 day, 5 hours, 50 minutes and 48 seconds ago, saying: k0ral: dist/build/autogen will generate a file called Paths_xxx.hs, which exports a getDataFileName function
13:42:02 <k0ral> huh ?
13:42:20 <edwardk> @tell ivanm yes.
13:42:20 <lambdabot> Consider it noted.
13:42:21 <k0ral> fake highlight -_-'
13:43:27 <xplat> ghc7's more complete import statement in ghci has changed my life
13:44:00 <jaspervdj> edwardk: Hi!
13:44:46 <identity_> xplat: do elaborate
13:44:48 <identity_> or link me
13:44:56 <identity_> does qualified work now?
13:44:57 <identity_> in ghci
13:45:05 <tommd> It has since 7.0 I thought
13:45:24 <identity_> ah
13:45:30 <tommd> 7.0 line fixed import in GHCi to have everything (I think that includes package imports, but those didn't work when I tested with an rc)
13:45:31 <identity_> <- only running 6.12.3 =(
13:45:37 <tommd> wow
13:45:44 <identity_> Writing code on a shell
13:45:45 <tommd> Stone age like gopher
13:46:03 <tommd> err, gofer
13:46:10 <identity_> it's debian, I think, so the repo's platform is older than time itself
13:46:32 <identity_> and when I tried compiling ghc 7.x I believe glibc was too old
13:46:34 <tommd> identity_: I'm running debian too but have installed the 7.0.3 binary from GHC HQ - works like a champ.
13:46:50 <identity_> tommd: Yeah, see above
13:46:53 <identity_> it didn't on this shell etc
13:47:01 <tommd> yeah, yeah
13:47:16 <identity_> at any rate, the issues that 6.12.3 might have don't interfere
13:47:39 <krainboltgreene> What are the more modern, up to date, haskell web frameworks out there?
13:47:44 <krainboltgreene> Well supported as well.
13:48:01 <identity_> krainboltgreene: I think happstack is the most used one, afaik
13:48:04 <identity_> maybe snap
13:48:11 <identity_> I've only really taken a look at happstack
13:48:13 <xplat> one thing though -- how do i turn on string overloading in ghci?
13:48:14 <companion_cube> some people talk about yesod, afaict
13:48:23 <krainboltgreene> Hmm, I'll check them out.
13:48:24 <identity_> xplat: OverloadedStrings extension
13:48:27 <krainboltgreene> Thanks identity_
13:49:09 <xplat> yesod seems to be fast and contain a wide variety of tools
13:49:15 <identity_> forgot about yesod
13:56:08 * hackagebot happstack-hsp 6.2.0 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-6.2.0 (JeremyShaw)
13:59:56 <ash_> shachaf: isn't that the halting problem?
14:00:30 <shachaf> ash_: To prove that two specific functions are extensionally equal?
14:00:36 <ash_> ya
14:00:57 <kmc> it's equivalent in difficulty anyway
14:01:14 <ash_> well, assuming you dont know the implementation anyway
14:01:42 <shachaf> kmc: In general, but not for the specific functions I gave with a known implementation.
14:01:43 <kmc> oh, i was thinking if you do
14:02:38 <parcs> @hoogle evaluate
14:02:38 <lambdabot> Control.Exception evaluate :: a -> IO a
14:02:38 <lambdabot> Control.OldException evaluate :: a -> IO a
14:02:38 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
14:03:59 <parcs> why is this in Control.Exception ?
14:04:50 <kmc> because the use case is, you have some expression whose evaluation might throw an exception
14:04:58 <kmc> you want to make sure said evaluation happens inside a particular "catch"
14:05:33 <monochrom> yeah, evaluation is intended for causing exceptions to happen
14:05:46 <kmc> but if you have an exception thrown on evaluation, then you've kind of lost already at good design
14:06:07 <monochrom> s/evaluation/evaluate/
14:06:24 <parcs> oh
14:06:36 <parcs> i should probably use seq, then
14:07:12 <kmc> use seq if you need one evaluation to cause another
14:07:13 <parcs> @src evaluate
14:07:14 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:07:18 <kmc> use evaluate if you need execution to cause evaluation
14:07:35 <kmc> i've used 'evaluate' outside an exception context
14:07:44 <monochrom> seq usually works, but mind this corner case: http://article.gmane.org/gmane.comp.lang.haskell.cafe/88120/
14:07:49 <parcs> hmm, i think need the latter
14:08:15 <kmc> yeah, pseq has an extra operational guarantee of ordering
14:08:21 <kmc> which in particular matters when used with 'par'
14:08:31 <bos> do any of the cabal-dev authors hang out here?
14:11:13 <tekknolagi> lol
14:11:17 <tekknolagi> since this is noy python :)
14:11:23 <tekknolagi> not*
14:13:11 * hackagebot unordered-containers 0.1.4.0 - Efficient hashing-based container types  http://hackage.haskell.org/package/unordered-containers-0.1.4.0 (JohanTibell)
14:16:42 <Twey> More efficient than GHC's?
14:17:08 <joe6> curious, if there is a better way of writing this code? or, if it is part of a standard library: http://pastebin.com/vUGyJnd0
14:17:10 <mauke> The paste vUGyJnd0 has been copied to http://hpaste.org/48233
14:17:35 <joe6> bos, are you the guy with the hackage modules? bos@serpentine.com?
14:17:58 <bos> joe6: what?
14:19:05 <joe6> bos, i use a hackage module whose author goes by the name "bos". wasn't sure if it was you..
14:19:19 <bos> propbably
14:19:27 <Twey> joe6: Have you considered using a list instead?
14:19:56 <joe6> bos, the llvm modules correct?
14:20:12 <bos> joe6: among others
14:20:25 <joe6> bos, I use them quite a bit. Good job. Just wanted to thank you.
14:20:31 <bos> cheers
14:20:36 <Twey> toBytes :: Num a => a -> [a]; toBytes = reverse . map (`mod` 256) . takeWhile (> 0) . iterate (/ 256)
14:21:15 <joe6> Twey, thanks. I want to use a tuple as i would not have to worry about the list length and all that.
14:21:44 <Twey> joe6: You can always pad the list out to whatever size you desire
14:21:55 <Twey> If you use tuples you're going to end up with a lot of redundancy.
14:21:59 <joe6> Twey, i think my version is more comprehensible. it could be an issue with my comprehensibility too.
14:22:05 <tromp> i'd iterate flip shiftR 8 instead of /256
14:22:29 <tromp> btw, shiftR has unfortunate argument order
14:22:58 <fragamus> why isn't there some effort to clean up haskell's little quirks
14:23:09 <tromp> :t (/)
14:23:10 <lambdabot> forall a. (Fractional a) => a -> a -> a
14:23:16 <fragamus> like genericBlah
14:23:40 <Twey> joe6: You're probably wrong
14:23:40 <tromp> > 3 / (4::Int)
14:23:41 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
14:23:41 <lambdabot>    arising from a use o...
14:23:54 <fragamus> and I think there's some problem with monad not being a functor or something
14:23:55 <tromp> can't use / anyway...
14:24:10 <Twey> fragamus: genericBlah are second-class citizens for performance reasons
14:24:17 <joe6> Twey, about comprehensibility? or, is the code doing something that it is not supposed to?
14:24:29 <Twey> The typeclasses are going to be fixed at some point, I believe
14:24:29 <fragamus> ah, I thought it was to support legacy code
14:24:33 <Twey> joe6: Comprehensibilit
14:24:33 <Twey> y
14:24:47 <Twey> fragamus: Nah, setting length = genericLength wouldn't break very much
14:24:55 <tromp> the default shld be generic
14:25:00 <Twey> Maybe a couple of things, but they should have given better type signatures in the first place
14:25:01 <fragamus> antici
14:25:10 <fragamus> pation
14:25:11 <tromp> rename std length to prematureOptimizedLength
14:25:22 <joe6> Twey, makes sense.
14:25:33 <joe6> Twey, yes, they should have better type signatures.
14:25:41 <shachaf> And rename Int to PrematureOptimizedInt, for that matter. And Integer to Int.
14:25:41 <Twey> joe6: I was talking to fragamus
14:25:48 <joe6> oh, ok.
14:26:12 <Twey> fragamus: Is that a Germanilatinisation of ‘we ask’?
14:26:46 <fragamus> you mean antici...
14:26:55 <fragamus> ...pation?
14:27:12 <ddarius> Twey: The answer is clearly, "no."
14:28:00 <Twey> Apparently
14:29:18 <kmc> it's true that Int can be *much* faster than Integer, due to unboxing
14:29:26 <kmc> the difference is probably larger than a C program who uses bignum libraries would expect
14:30:04 <shachaf> kmc: Hmm, I suppose that's true.
14:30:15 <parcs> i'm trying to make a column of wx widgets fill all horizontal space. is there something more proper than 'column 25 $ map hfill $ [ .. ]' ?
14:30:23 <kmc> i still think Integer should be the only one in the Prelude, though
14:30:52 <drdo> kmc: Why?
14:31:04 <ash_> whats wrong with type classes? someone said they are getting fixed?
14:31:28 <c_wraith> Superclass equality constraints are getting fixed.
14:31:28 <kmc> drdo, because Integer is the semantically nicer type.  Int is a fine optimization which you can import
14:31:36 <kmc> much like ByteString or Data.Text
14:31:41 <c_wraith> But what's the context, ash_ ?
14:31:54 <ddarius> ash_ is getting fixed.
14:31:56 <kmc> people should know that Data.Text exists, but beginners should probably start with String because it's simple and maximally lazy
14:31:57 <xplat> i guess it makes sense to only have Integer in the prelude if you only have String in the prelude
14:31:59 <drdo> kmc: functions like (!!) require Int for example
14:32:08 <kmc> drdo, right, the proposal would involve fixing that
14:32:18 <kmc> possibly by generalizing the types of those functions
14:32:28 <kmc> set length = genericLength, etc
14:32:32 <ash_> "Twey> The typeclasses are going to be fixed at some point, I believe"
14:32:51 <kmc> and use SPECIALIZE or whatever to make Int still fast, behind the scenes
14:33:36 <dainanaki> Hey everyone, in RWH it claims that regexes can return a result :: [String], but ghci tells me this isn't an instance of RegexContext. What's the deal?
14:34:09 <Twey> kmc: That's a nice idea
14:34:31 <kmc> the deal is that the state of regex in Haskell is awful
14:34:37 <Twey> :t (=~)
14:34:38 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
14:34:49 <kmc> i will let someone else explain because i will just get pissed off at how terrible it is
14:34:54 <Twey> This uses MPTCs now?
14:35:12 <Twey> I don't know, I prefer Parsec to regexen in Haskell
14:35:44 <c_wraith> well, that's to be expected with that library
14:35:47 <dainanaki> I just have a *really* simple expression that I need to find. Parsec felt a bit like overkill
14:36:06 <kmc> there is some non-terrible regex API
14:36:07 <c_wraith> if it's really simple, the parsec code should be really simple
14:36:08 <kmc> but i don't remember where
14:37:54 <dainanaki> alright, well I'll just do parsec. not worth wasting any more time on.
14:37:59 <dainanaki> thanks.
14:44:06 <ash_> this might sound like a silly question but is quasiquoting the same as a lisp macro?
14:46:11 <identity_> When writing build-depends in one's cabal file, how do I know which min version to put down for mase?
14:46:15 <identity_> base*
14:46:28 <kmc> ash_, vaguely related concepts
14:46:43 <kmc> "quasiquoting" is a Lisp feature that helps you construct macros (but is not required for doing so)
14:46:59 <kmc> it's also a GHC Haskell features which allows you to define and use new concrete syntax in a Haskell program
14:47:16 <ash_> they both just seemed like compile time expansion with partial evaluation
14:47:21 <kmc> it's also sometimes used to refer to the GHC Haskell feature in which you quote ordinary Haskell syntax
14:47:28 <kmc> the latter two are part of Template Haskell
14:47:36 <kmc> there's no partial evaluation really
14:47:52 <kmc> some expressions are evaluated completely, at compile time, to yield syntax trees which are then spliced into the program's source code
14:48:27 <parcs> identity_: use the major version number of the version you've tested your app with
14:48:59 <identity_> parcs: alright. Thanks
14:57:48 <krainboltgreene> Of the 3 web frameworks suggested 1 had a screencast (yesod), another had a very very small snippet (happstack), and another actually put effort into their landing page (snap). What a strange setup.
14:59:05 <identity_> I just linked a C#/C/C++ programmer(and a relative newbie at that) some haskell code.
14:59:19 <kmc> good that they're a newbie
14:59:27 <kmc> easier to learn Haskell if you don't know anything else
14:59:30 <identity_> well
14:59:34 <olsner> identity_: ... and you now need help cleaning up the exploded head from your keyboard?
14:59:42 <identity_> I meant to follow up with a line from him
14:59:44 <identity_> but now I can't find it
14:59:47 <identity_> olsner: basically
14:59:58 <identity_> he said somethiing along the lines of "dude this language is FUCKED"
15:00:12 <identity_> pasted some line with some nifty applicative functor + transformer magic
15:00:14 <identity_> and he goes
15:00:16 <identity_> WTF IS CATMAYBES
15:00:45 <thoughtpolice> a very serious disease amongst cats, obviously!
15:01:00 <krainboltgreene> That's when a cat pretends that he wants in your lap.
15:01:05 <identity_> I couldn't resist and replied "maybe it's a cat LOLOL"
15:01:11 <krainboltgreene> And then sits down and stares at you.
15:01:27 <identity_> then I tried to explain to him how Maybe replaced NULL or ARBITRARY_ERROR_CONSTANT in C/C++
15:01:35 <identity_> (so to speak)
15:01:39 <identity_> He didn't really get it
15:01:50 <thoughtpolice> you'd be surprised at how large a number of people "don't get it"
15:01:56 <identity_> Aye
15:02:01 <thoughtpolice> "the only people who complain about NULL pointers are ones who don't know what they're doing! at all!"
15:02:03 <identity_> I didn't get the necessity at first either
15:02:23 <identity_> but when the rigidness of the type system (and how beautiful it is to have such a type system) sets in, then Maybe is like "duh..."
15:02:30 <thoughtpolice> "um, this is just about making sure - statically - that you can never forget about null pointers, essentially"
15:02:41 <thoughtpolice> "YOU DO NOT KNOW WHAT YOU ARE DOING OBVIOUSLY"
15:02:44 <identity_> lol
15:02:45 <thoughtpolice> :(
15:03:05 <identity_> thoughtpolice: that's when you go matrix on them and explain .. "No.. Friend. There *are* no null pointers."
15:03:23 <identity_> "wat r u syaing haskell doesn't have pointers?? noooob language"
15:03:32 <krainboltgreene> How easy is it, in Haskell, to make a DSL?
15:03:46 <krainboltgreene> I realize that's an odd question.
15:04:26 <kmc> people often use Haskell for domain-specific languages
15:04:38 <kmc> you have less control over syntax than in, say, Lisp
15:04:41 <kmc> (at the same level of effort)
15:04:48 <kmc> but it's overall a very good choice
15:04:54 <olsner> I think that making a DSL is pretty much always trivial (in any language), the question is mostly how good that DSL becomes (better in haskell than anything else, of course :P)
15:05:20 * hackagebot web-routes-th 0.20.4 - Support for deriving PathInfo using Template Haskell  http://hackage.haskell.org/package/web-routes-th-0.20.4 (JeremyShaw)
15:05:31 <olsner> I mean: at the most basic level, you can just use utility functions and say that that's a simple DSL
15:06:19 <thoughtpolice> krainboltgreene: the DSL approach is rather popular in the haskell community (like many others) but it's hard to say how "easy" it is - but especially for embedded domain specific language, it's quite nice, because you can do things like use the type system to enforce properties in DSL itself (essentially the object languages gets to hijack the type system of the metalanguage - in this case, haskell)
15:07:05 <thoughtpolice> krainboltgreene: but there are lots of examples! there are very good DSLs out on hackage you can look at. some of them include: yices-painless, sbv, atom, and a lot of others. i think there's a whole category on hackage even
15:08:37 <krainboltgreene> Interesting. l I was watching the Yesod screen cast and the "view" and "model" language were...well, they didn't seem to be very trivial. So I was wondering if that was a cause of the developer, culture, or language.
15:08:59 <thoughtpolice> hm, apparently there isn't a DSL section. but looking through hackage for "DSL" or "domain specific language" turns up a ton of things ranging from hardware description languages, to SMT solvers, to all sorts of things
15:09:54 <kmc> Haskell programmers certainly have a tendency to think of libraries as DSLs
15:10:06 <krainboltgreene> I'm a ruby developer professionally, and so I'm always dealing with at least 4 DSLs in every project.
15:10:09 <kmc> the distinction between the two is murky
15:10:25 <kmc> ah yes
15:11:33 <kmc> i expect Haskell's DSLs are more manageable than the typical Ruby DSL
15:11:38 <kmc> by being more declarative and less imperative
15:11:56 <kmc> i like it when something looks like a DSL and produces a totally first-order value which you can then manipulate before "running" it or whatever
15:12:05 <kmc> because then you get easy metaprogramming for the DSL, using Haskell as a meta-language
15:14:15 <krainboltgreene> Very interesting.
15:14:22 <krainboltgreene> Thanks for the information, kmc.
15:15:00 <kmc> :)
15:16:54 <edwardk> ruby dsls can be pretty nice simply because you can overload pretty much anything
15:19:14 <aavogt> kmc: metaprogramming haskell in haskell isn't very simple, did you have an example of a DSL/library whose intermediate values are easy to manipulate?
15:20:47 <kmc> can't think of a great example atm
15:20:57 <quotemstr> Say we have a record with five fields and we update the first. Do most Haskell implementations copy the whole record and change the first in the new copy, or do they arrange for the old and new versions to share structure?
15:21:09 <ash_> kmc: would parsec count?
15:21:28 <kmc> quotemstr, they would implement each field as a pointer, and copy only the pointers
15:21:58 <kmc> if you have immutability and garbage collection then you can ~always copy a pointer instead of doing a deep copy
15:22:16 <kmc> aavogt, from various compiler projects etc i've found it useful to have a "builder monad" which looks like you're imperatively spitting out code, but then you can capture the result and do further processing
15:22:35 <krainboltgreene> I'm starting to understand what people are saying on this channel. Geeze.
15:22:51 <kmc> aavogt, especially wrt. managing fresh names
15:23:25 <kmc> ash_, no; once you build a parser with Parsec, you can't really inspect it
15:23:32 <quotemstr> kmc: I'm not even talking about the deepness of the copy. Of course we can use shallow copies.
15:23:45 <quotemstr> But all the fields in a given record are grouped together, even if the pointed-to values are not.
15:24:03 <kmc> quotemstr, i think once you have shallow copies then the two alternatives you gave are the same
15:24:20 <quotemstr> kmc: It depends on whether the record is implemented as a list or a solid block.
15:24:25 <kmc> ah
15:24:27 <kmc> GHC uses a sold block
15:24:29 <quotemstr> kmc: If a record is a list, the tails can be shared.
15:24:30 <kmc> solid*
15:24:31 <quotemstr> Ah, I see.
15:24:41 <c_wraith> But most records are small.
15:24:49 <kmc> and you want fast access to arbitrary fields
15:25:02 <quotemstr> Also, does GHC ever use mutation instead of a copy-and-modify operation? Of course, it'd have to prove that the "old" value is dead.
15:25:07 <kmc> but if you are considering a record of 10,000 fields, you might want to use IntMap instead ;)
15:25:31 <c_wraith> quotemstr: only if you use one of the mutable cell types.  GHC does no inference of linear/unique types
15:25:57 <c_wraith> (I can never remember whether linear or unique is what's desired)
15:26:14 <quotemstr> c_wraith: Is it even something a sufficiently clever compiler could do?
15:26:54 <aavogt> in a way that happens when ghc figures out     map f . map g  = map (f . g)
15:27:02 <aavogt> deforestation or whatever that's called
15:27:02 <quotemstr> dd
15:27:17 <c_wraith> quotemstr: I should clarify.  It can often figure out that a tight recursive loop doing numeric calculations can be done in place.
15:27:47 <c_wraith> quotemstr: but that's distinct from using a complex data structure in a linear way, which it can't detect
15:28:07 <kmc> and if you use a type like Int, and GHC can infer strictness, it will avoid allocating any closures in that tight numeric loop
15:28:13 <kmc> by unboxing the Ints
15:29:42 <c_wraith> quotemstr: as for whether it's theoretically possible...  Yes, but it seems very limited.  Are you going to have to implement different algorithms for your data structure in the case it's being used linearly?  These aren't things that can often be derived from the persistent data structure algorithm definitions.
15:32:26 <dylukes> Someone should get an resoling together in which types are values of their values.
15:32:43 * kmc blinks
15:33:05 <dylukes> esolang*
15:33:09 <dylukes> damn autocorrect, :P
15:33:24 <kmc> still, what does that mean
15:33:38 <aavogt> quotemstr: HList's records are implemented as lists apparently
15:34:45 <dylukes> kmc: hm, well for example
15:34:47 <dylukes> say you had
15:34:57 <dylukes> data Widget a where
15:35:04 <dylukes> Foo :: Int -> Foo Int
15:35:14 <dylukes> Foo :: Int -> Widget Int*
15:35:20 <dylukes> Bar :: Bool -> Widget Bool
15:35:32 <dylukes> Foo and Bar construct values of type Widget a,
15:35:41 <dylukes> and then you could use those values to construct the type Widget a
15:35:49 <dylukes> somehow.
15:35:59 <dylukes> the values of the type are the type constructors.
15:36:03 <dylukes> oh god paradoxes gogogo
15:36:22 <kmc> if you write that GADT in GHC Haskell
15:36:38 <kmc> and hand me a Foo (respectively Bar), I can use that to force some other value to have type Int (respectively Bool)
15:36:47 <kmc> is that what you mean?
15:37:15 <gusto> what editors do you ppl use to write haskell code?
15:37:30 <kmc> vim, emacs, whatever
15:37:34 <Nimatek> vim
15:37:43 <kmc> there's not like a One True Haskell Editor
15:37:43 <gusto> so vim is the most popular, OK
15:37:44 <luite> mostly emacs
15:37:50 <kmc> gusto, haha, sample size much?
15:37:52 <gusto> ow, emacs there
15:37:57 <Nimatek> microsoft word
15:38:00 <gusto> hehe
15:38:02 <kmc> NOTEPAD.EXE
15:38:05 <gusto> yes
15:38:07 <kmc> EDLIN
15:38:08 <gusto> of course
15:38:17 <kmc> DEBUG.COM
15:38:22 <gusto> i was just curious so i posed this question
15:38:42 <Nimatek> I think Kate is decent, too.
15:38:47 <gusto> of course
15:38:51 <gusto> gedit as well
15:39:18 <ash_> echo " " >> /path/to/file
15:40:12 <dylukes> I use emacs and textmate.
15:40:16 <dylukes> oh question,
15:40:28 <dylukes> is there a haskell-input yet, for use with -XUnicodeSyntax? :\
15:41:10 <parcs> yep
15:41:39 <parcs> @google roelvandijk emacs haskell unicode input method
15:41:41 <lambdabot> http://www.haskell.org/haskellwiki/Unicode-symbols
15:41:41 <lambdabot> Title: Unicode-symbols - HaskellWiki
15:42:54 <dylukes> kmc: so no, what I meant was
15:43:09 <dylukes> somehow making the kind of a type its values (non-deterministically)
15:43:18 <dylukes> As some sort of bullshit impossible to use confusing language.
15:46:09 <dylukes> parcs: Hrm. I like Agda's input mode :|
15:46:17 <dylukes> Maybe I should just use that for Haskell too >_>
15:46:22 <kmc> i like using the Compose key for unicode
15:46:29 <dylukes> Compose key?
15:47:50 <kmc> yes
15:48:20 <kmc> http://mainisusuallyafunction.blogspot.com/2010/10/typing-mathematical-characters-in-x.html
15:51:09 <hpaste> yuriks pasted “hinclude.hs” at http://hpaste.org/48237
15:51:14 <Cale> Ugh, the night before last, I tripped over the open dishwasher in the dark (trying to get to the lamp on the counter), smashed my face into the tile floor and scraped up my arms pretty good. RDY TO FEEL BETTER NOW KPLZTHX.
15:51:57 <Cale> At least I didn't break any teeth, though I can't eat anything solid :P
15:52:42 <c_wraith> ouch
15:53:56 <Cale> heh, "main is usually a function"
15:54:09 <c_wraith> did you find the blog named that?
15:54:30 <Cale> Well, kmc just linked to his blog named that
15:54:30 <c_wraith> I had to play with gcc for a while after finding that.  Great way to write a very short segfaulting program!
15:55:16 <identity_> gah, what was the function called where you would basically do something like: foo (openFile "file") hClose $ \handle -> ...
15:55:20 <identity_> ?
15:55:41 <kmc> withFile
15:55:43 <kmc> :t withFile
15:55:44 <lambdabot> Not in scope: `withFile'
15:55:46 <kmc> maybe?
15:55:50 <identity_> Hmm
15:55:53 <kmc> yes
15:55:55 <kmc> :t bracket
15:55:56 <lambdabot> Not in scope: `bracket'
15:56:04 <identity_> ah, indeed
15:56:14 <identity_> oh, withFile exists as well
15:57:12 <yuriks> identity_: it's withFile
15:57:35 <Cale> He's thinking of bracket, but withFile does the same thing as bracket with those args.
16:04:14 <kelseyhightower> I have a silly question, do all main functions have to output something? How simple can the main function be?
16:04:25 <kmc> 'main' is not a function in Haskell
16:04:28 <kmc> it can be any IO action
16:04:33 <kmc> it can be the do-nothing IO action, "return ()"
16:04:47 <kmc> it doesn't even have to have result type (); any other result value will be ignored
16:05:20 <kelseyhightower> kmc: thanks
16:06:23 <hpaste> yuriks pasted “hinclude.hs” at http://hpaste.org/48238
16:06:48 <yuriks> any comments on how to improve my code?
16:06:56 <Cale> It would be interesting to accept  main :: [String] -> IO a
16:07:13 <identity_> yuriks: did you hlint it?
16:07:17 <Eduard_Munteanu> Or at least -> IO Int
16:07:27 <Eduard_Munteanu> That'd be conservative enough.
16:07:37 <yuriks> (it processes files in the current directory processing include directives (recursively) and outputting to ./output/)
16:07:55 <identity_> yuriks: processHtmlFile, withFile readMode $ \handle -> do ... indent next line looks neater
16:08:00 <identity_> skipping the parentheses
16:08:06 <yuriks> identity_: no, I'll take a look. Though I'm looking more at style suggestions
16:08:40 <djahandarie> Cale, perhaps of interest to you: http://hpaste.org/48041 Mainly just a reiteration of roconnor's argument and dolio's code.
16:08:41 <Cale> yuriks: Looks fine to me. One idiom you might like to adopt is using  withFile ... $ \handle -> do ...
16:09:00 <yuriks> indeed
16:09:02 <Cale> yuriks: which removes the need for that awkward closing paren
16:09:02 <kmc> main = getArgs >>= main'
16:09:06 <identity_> yuriks: Ah. Well, all my indents are 4 spaces. Except for the cases in the case expression, those are indented 2 spaces, and the code inside them 2 more spaces
16:09:25 <yuriks> identity_: not *that* kind of style :P
16:09:41 <identity_> yuriks: WHAT DO YOU WANT FROM ME :(
16:09:51 <yuriks> identity_: stuff like the $ \handle ...
16:09:52 <identity_> (see withFile suggestion)
16:09:57 <yuriks> yeah, thanks
16:10:01 <identity_> everything else is fine IMO
16:10:22 <identity_> Except using underscores in your variable names
16:12:08 <Cale> oh, ouch, tabs
16:12:27 <Cale> Please configure your text editor to convert tabs to spaces automatically
16:12:29 <yuriks> I only use tabs for indentation :P, as you can see alignment is done with spaces
16:12:41 <Cale> mixing tabs and spaces is even worse
16:12:47 * tabs hits various pastebins and editors for over 9000 damage. 
16:12:53 <Cale> Just don't do it :P
16:13:02 * various_pastebin died.
16:13:42 <yuriks> Cale: why the hate on being able to actuallyg configure how you want the code to look?
16:14:00 <identity_> yuriks: Tabs fuck up *everywhere*
16:14:12 <Cale> Because it doesn't matter how much things are indented, but it *does* matter how things line up vertically.
16:14:28 <identity_> what editor are you using? vim with smart indenting and spaces=tabs and so on and you indent with tab but it gets converted to spaces
16:14:28 <yuriks> and that's why you use spaces for aligning things
16:14:37 <monochrom> you could misconfigure how the code look and get a parse error
16:14:50 <yuriks> identity_: vim, and yes I know how to configure it
16:14:53 <kelseyhightower> kmc: does -no-hs-main give me the same results as "return()" ?
16:15:08 <Cale> The distinction between a tab and space character is not visible in most editors (though they show up bright red in mine)
16:15:35 <Cale> So it's really bad for collaboration.
16:15:59 <dainanaki> hey all, I'm a bit rusty on parsing things. I have a parsec parser that I want to simply return a list of occurrences of a succeeding string and ignore everything else in the file. How can I get it to ignore everything that fails and stop parsing at eof?
16:16:13 <fragamus> :t runListT
16:16:14 <lambdabot> Not in scope: `runListT'
16:16:31 <Cale> You invariably end up with some lines having spaces and some having tabs, and the whole thing ends up being a confusing mess, and looking wrong in some editors which don't have 8 space tabs.
16:16:31 <kmc> kelseyhightower, no, it will give you a program which fails to link, unless you include a C file or something else which defines a 'main' function
16:16:44 <kmc> kelseyhightower, what's the context of this question?
16:17:18 <kelseyhightower> Just learning, I have been using ghci so far, now moving on the .hs source files
16:17:33 <Cale> Obviously, so long as the program is still correct, one can replace all the tabs with enough spaces to align to multiples of 8 columns, but it's better to do this earlier :)
16:17:35 <Eduard_Munteanu> Cale: did you set up vim to highlight tabs? :)
16:17:38 <monochrom> dainanaki: as long as you don't call "eof" it will behave like that. for example parseTest (many my'parser)
16:17:38 <Cale> yes
16:17:39 <kmc> -no-hs-main is for pretty specialized situations
16:17:49 <Cale> autocmd ColorScheme * highlight TrailingWhitespace ctermbg=darkgreen guibg=darkgreen
16:17:49 <Cale> autocmd ColorScheme * highlight UnwantedWhitespace ctermbg=red       guibg=red
16:17:49 <Cale> autocmd Syntax * syntax match UnwantedWhitespace /\t/ containedin=ALL
16:17:49 <Cale> autocmd Syntax * syntax match TrailingWhitespace /\s\+$/ containedin=ALL
16:18:18 <yuriks> Cale: most editors I've seen DO have visible tabs/indentation. I've been formatting code like this for years and never had the issues you're saying
16:18:33 <identity_> yuriks: .. really?
16:18:35 <yuriks> but then. I tend to beat code formatting discipline into people until they learn :P
16:18:36 <identity_> o.o
16:18:40 <Cale> Well, most editors have the option, but it's turned off by default.
16:18:50 <identity_> I've heard this stuff so many times it's not even funny
16:18:51 <kelseyhightower> kmc: Ok, so I will stick with using a basic main
16:18:51 <hpaste> fragamus pasted “ListT” at http://hpaste.org/48239
16:18:56 <Eduard_Munteanu> ':set list' is also useful to spot indentation issues.
16:18:57 <Cale> It's easiest just not to ever use the tab character
16:19:06 <wli> This is usually a non-issue apart from where people screw with whatever the convention is.
16:19:08 <identity_> Cale: also, thanks for that. Can you pastebin that somewhere so I can retrieve it more easily?
16:19:15 <kmc> kelseyhightower, if you write "main = return ()" then it mostly doesn't matter what the rest of your program says
16:19:25 <fragamus> hey, I see a definition for runListT' but where is runListT defined ^^^
16:19:25 <Cale> I think that tab characters should be considered a lexical error by the compiler and outright rejected.
16:19:33 <Cale> sure
16:19:35 <dainanaki> monochrom: that doesn't work. I want it to ignore everything else except portions that match the parser.
16:19:36 <kmc> fragamus, probably the ListT package
16:19:46 <identity_> :hoogle runListT
16:19:51 <identity_> eh
16:19:56 <identity_> @hoogle runListT
16:19:57 <lambdabot> Control.Monad.List runListT :: ListT m a -> m [a]
16:20:06 <fragamus> :t runListT
16:20:07 <lambdabot> Not in scope: `runListT'
16:20:16 <hpaste> Cale pasted “highlight bad whitespace” at http://hpaste.org/48240
16:20:19 <kelseyhightower> kmc: lets say in my program I want to run product [1,2,3] and not print anything
16:20:20 <Cale> http://hpaste.org/48240
16:20:26 <monochrom> oh you have a prefix that you want to skip, not just a suffix to skip
16:20:37 <kmc> kelseyhightower, what's the point of that?
16:20:44 <kmc> kelseyhightower, in Haskell values are only evaluated when they're needed
16:20:51 <kmc> if the top-level instruction is "do nothing" then nothing will be needed
16:20:54 <kmc> and nothing will happen
16:21:04 <monochrom> then it depends. you have to write a parser to recognize what you want to skip
16:21:05 <Cale> kelseyhightower: You could write   main = product [1,2,3] `seq` return ()
16:21:21 <dainanaki> specifically, I want to parse out all the include files in a cpp source and ignore all of the code.
16:21:24 <kmc> Cale is right but i expect it's not really what you're asking for
16:21:27 <fragamus> but I am not importing Control.Monad.List and yet it is defined
16:21:41 <fragamus> runListT is a mystery
16:21:50 <kmc> kelseyhightower, there is no point evaluating a Haskell function unless you want the result.  functions never have side effects
16:22:07 <dainanaki> i have an include file parser that recognizes individual includes properly, but I don't know how to simply ignore everything else
16:22:16 <kmc> exceptions would include something like "i'm benchmarking 'product' and don't want output to interfere with my results"
16:22:25 <kmc> or "i'm testing whether product ever throws an error"
16:22:34 <kmc> or "i'm just typechecking my code and don't intend to run it"
16:22:59 <monochrom> agda!
16:23:33 <monochrom> also "i'm testing ghc"
16:23:42 <kelseyhightower> So, main is for IO such as writing files, just assigning the output of a function to a var does nothing because it is not used?
16:23:49 <dobblego> data WhatIsThisThingCalled a = W (Endo [a]) (Endo[A]) -- for efficient cons/snoc
16:23:51 <identity_> monochrom: in soviet russia, ghc tests you!
16:23:52 <kmc> "the heat is out at my house and i'm trying to use my computer as a space heater"
16:23:53 <identity_> (i had to)
16:24:12 <kmc> kelseyhightower, yep.  moreover you can't notice whether or not it runs
16:24:22 <kmc> i mean how can you tell whether the computer evaluated "product [1,2,3]" and threw out the result
16:24:24 <kmc> versus doing nothing
16:24:30 <kmc> you can only tell through "side channels" like timing or heat
16:24:39 <monochrom> efficient cons and snoc sounds like doubly-ended queue
16:24:43 <kmc> there's no way product itself could print anything
16:24:48 <kmc> applying a function can't cause IO to happen
16:24:56 <kmc> (unless you cheat and break the rules)
16:25:00 <identity_> kelseyhightower: The very thing about laziness is not evaluating anything that doesn't need evaluation. And don't evaluate anything further than it needs to be evaluated at any given time
16:25:07 <identity_> Unless told otherwise
16:25:33 <kmc> Haskell programs are not about "do this, do that"... they're about equations which describe function outputs in terms of the inputs
16:26:02 <kmc> if i'm writing a math proof I will not tell the reader "compute the product of 1,2,3.  now forget it.  let us never speak of this again"
16:26:50 <dainanaki> hehe
16:27:06 <Cale> kelseyhightower: another way to put it is that 'let' makes definitions but doesn't cause evaluation, while 'case' is the primitive that induces things to be evaluated (and other forms of pattern matching which translate into case)
16:27:25 <kmc> kelseyhightower, in Haskell it's important to distinguish between evaluation and execution
16:27:33 <kmc> see http://www.haskell.org/haskellwiki/Introduction_to_IO
16:27:41 <kmc> evaluating a function application can't have any side effects
16:27:42 <kelseyhightower> kmc:	I see your point, I need to think about this different. If I want to test my functions, I need to do some IO
16:27:50 <kmc> but it can return a description of effects which you can perform later
16:27:53 <kelseyhightower> like print the results
16:27:56 <kmc> kelseyhightower, sure, like "main = print (product [1,2,3])"
16:27:57 <Cale> When you pattern match on an expression, you need to distinguish which of the data constructors it is made from, and that induces the expression to be evaluated.
16:28:32 <Cale> kelseyhightower: You can also test that your functions satisfy certain equational rules on random data.
16:28:52 <Cale> @check \xs -> product xs == product (reverse xs)
16:28:53 <lambdabot>   "OK, passed 500 tests."
16:29:00 <kmc> @check \n -> product [1,n] == n
16:29:01 <lambdabot>   "OK, passed 500 tests."
16:29:10 <kmc> @check \n -> product [n,n] < 50
16:29:11 <lambdabot>   "Falsifiable, after 14 tests:\n-10\n"
16:29:38 <monochrom> @check (==)
16:29:38 <lambdabot>   "OK, passed 500 tests."
16:29:42 <monochrom> hehe
16:30:00 <kmc> @check \xs -> xs == reverse xs
16:30:02 <lambdabot>   "OK, passed 500 tests."
16:30:04 <Cale> Yeah, due to aggressive defaulting, the type of (==) gets coerced to () -> () -> Bool
16:30:32 <kelseyhightower> nice
16:30:50 <Cale> @check \xs -> xs == reverse (xs :: [Int])
16:30:51 <lambdabot>   "Falsifiable, after 6 tests:\n[-1,2]\n"
16:30:54 <kmc> kelseyhightower, reasoning about substituting equals for equals is one of the most powerful aspects of using Haskell
16:31:05 <kmc> it's largely the reason we go to all this trouble
16:31:49 <Cale> @check \xs -> reverse (reverse xs) == (xs :: [Int])
16:31:50 <lambdabot>   "OK, passed 500 tests."
16:32:12 <Cale> btw, this is the QuickCheck library doing the work here
16:32:20 <ion> @check \(xs :: [Integer]) -> xs == reverse xs
16:32:20 <lambdabot>   Parse error in pattern at "->" (column 20)
16:32:34 <hpaste> “Ben Gamari” pasted “GC churn” at http://hpaste.org/48241
16:32:36 <fragamus> http://www.haskell.org/haskellwiki/ListT_done_right
16:32:46 <bgamari> The profiler seems to indicate that there are a lot of lists being created/destroyed in my code (http://hpaste.org/48241)
16:32:47 <ion> @check \((id :: [Integer] -> [Integer]) -> xs) -> xs == reverse xs
16:32:47 <lambdabot>   Parse error at "->" (column 34)
16:32:48 <fragamus> where is runListT defined?
16:32:50 <kelseyhightower> thanks you guys are really helpfull
16:32:59 <ion> No view patterns? :-P
16:33:03 <Cale> It gives you a polymorphic function called quickCheck which uses a little typeclass magic to determine how to randomly generate parameters for a function and check that the result is True in every case it tests
16:33:13 <bgamari> Yet I don't seem to create any explicitly
16:33:27 <bgamari> Anyone have any ideas looking at the code? http://hpaste.org/48241
16:33:44 <fragamus> http://www.haskell.org/haskellwiki/ListT_done_right
16:33:45 <bgamari> I suspect it might be the maps
16:33:52 <fragamus> where is runListT defined? ^^^
16:33:53 <ion> Perhaps it’ll work if you paste the link for the fourth time within two minutes.
16:34:01 <bgamari> But in principal they should be evaluated lazily, no?
16:34:07 <bgamari> principle*
16:35:34 <Cale> bgamari: Yes, though note that the 'b' pair of lists will be computed completely by the end of saving donor.txt, and be in memory until acceptor.txt is written.
16:35:48 <ion> :t \((`asTypeOf` undefined :: [Integer]) -> xs) -> xs == xs
16:35:49 <lambdabot> parse error on input `::'
16:36:04 <bgamari> Cale: Hmm, true
16:36:16 <ion> :t \((`asTypeOf` (undefined :: [Integer])) -> xs) -> xs == xs
16:36:17 <lambdabot>     Illegal view pattern:  ((`asTypeOf`
16:36:18 <lambdabot>                              (undefined :: [Integer])) -> xs)
16:36:18 <lambdabot>     Use -XViewPatterns to enable view patterns
16:36:28 <bgamari> Cale: So I guess I should write both files simultaneously?
16:36:44 <Cale> bgamari: Possibly...
16:36:58 <Cale> That's a little awkward to have to do, but it might help.
16:37:22 <bgamari> Cale: Any better ideas?
16:37:39 <Cale> Are both of the files really large?
16:37:58 <sm> is there an easy to flip the order with sortBy (comparing f) ... ?
16:38:03 <bgamari> They will be of equal length and likely large
16:38:12 <Cale> sm: flip (comparing f)
16:38:51 <sm> right you are, thanks! I thought I tried that
16:39:15 <bgamari> Cale: It's a (crude) monte carlo simulation so you want to run it for large numbers of iterations
16:40:26 <ion> How about setting -XViewPatterns in lambdabot? :-)
16:41:07 <bgamari> Cale: No ideas?
16:41:25 <Cale> bgamari: Yeah, I think that's your best bet then.
16:41:33 <bgamari> Cale: Alright, so be it
16:41:45 <Cale> It might be worth structuring things a bit to write 2 files at once.
16:42:01 <dainanaki> I'm still having a hard time figuring out how to only parse header includes using parsec and ignoring the rest.
16:43:24 <bgamari> Cale: Considering my experience with Haskell, I doubt I have the ability to do anything but zipping donorTs and acceptorTs together and mapMing over that with a Monad which writes both
16:43:34 <bgamari> Cale: Would you structure this differently?
16:44:17 <Cale> That sounds about right to me :)
16:44:39 <Cale> :t uncurry zip
16:44:40 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
16:45:08 <Cale> :t forM . uncurry zip
16:45:09 <lambdabot> forall (m :: * -> *) b a b1. (Monad m) => ([a], [b1]) -> ((a, b1) -> m b) -> m [b]
16:45:40 <Cale> btw, "monad" refers to the type, so the monad you'll be using is definitely IO :)
16:46:15 <Cale> :t forM_ . uncurry zip -- as you don't care about the results
16:46:16 <lambdabot> forall (m :: * -> *) b a b1. (Monad m) => ([a], [b1]) -> ((a, b1) -> m b) -> m ()
16:46:21 <dolio> @check \xys -> (uncurry zip . unzip $ xys) == xys
16:46:22 <lambdabot>   "OK, passed 500 tests."
16:47:59 <Cale> bgamari: I'm a little worried though, that you'll have trouble lazily zipping this up, because to compute the final state list, you have to do the whole computation
16:50:05 <bgamari>  Cale: But it doesn't need the whole state list until the end of the file
16:50:19 <bgamari> Cale: At which point hopefully the GC would have started disposing of the earlier elements
16:50:22 <bgamari> Cale: No/
16:51:29 <bgamari> ?
16:51:45 <aavogt> @check \xys -> xys == reverse xys
16:51:45 <lambdabot>   "OK, passed 500 tests."
16:54:56 <drosophy1lum> is the reason you cant match against a global variable in a case because it wouldnt be pure/free-of-side-effects?
16:55:45 <mauke> no, the reason is that you can't match against variables
16:57:06 <drosophy1lum> why? it deosnt violate referential transparency?
16:57:41 <c_wraith> No
16:57:44 <mauke> what would it do?
16:57:47 <c_wraith> Not unless the global is mutable somehow
16:58:12 <c_wraith> and since you can't pattern-match against mutable cells anyway...
16:58:57 <monochrom> it violates the desired meaning of the pattern that only has a variable, i.e., case blahblah of var ->
16:59:01 <aavogt> @type do v <- newIORef 5; case v of v -> return v
16:59:02 <lambdabot> Not in scope: `newIORef'
16:59:14 <ion> ghci> let x = 42 in case 43 of ((==x) -> True) -> "oh yeah"; _ -> "oh no"
16:59:14 <ion> "oh no"
16:59:37 <identity_> Using Error/ErrorT, >>= would work like it works with maybe, right? As in, the first error propagates down the chain, right?
16:59:45 <monochrom> if I write "case Just 5 of var -> ...", I want to use "var" to refer to "Just 5" when I'm in the "..." body
16:59:48 <identity_> or >> rather
17:00:03 <c_wraith> identity_: correct, but thanks to laziness, It doesn't actually propogate the chain, it just stops
17:00:18 <identity_> c_wraith: Not sure what you mean there
17:00:19 <monochrom> this is consistent with the function definition version: "f var = ..." and then someone calls "f (Just 5)"
17:00:25 <identity_> implementation detail, you mean?
17:00:48 <parcs> identity_: it short circuits the operation once an error is encountered, like with the Maybe monad
17:00:59 <monochrom> you are proposing that if "var" exists as a name in the outer scope, then suddenly this behaviour changes to comparison
17:01:05 <c_wraith> identity_:  It's not an implementation detail of ErrorT
17:01:08 <identity_> hmm
17:01:20 <identity_> well
17:01:23 <c_wraith> identity_: because for ErrorT, it means the rest of the computation won't be run
17:01:31 <c_wraith> and if it was ErrorT over IO, that will matter
17:01:35 <identity_> same with >> ?
17:01:38 <c_wraith> yes
17:02:04 <identity_> I see
17:02:06 <identity_> Thank you
17:02:45 <c_wraith> a correct implementation of (>>) is going to behave the same as x >> y = x >>= \_ -> y
17:03:16 <identity_> ah, yes, of course
17:03:21 <ion> drosophy1lum: See my message above.[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~
17:03:22 <drosophy1lum>  Not unless the global is mutable somehow
17:03:22 <drosophy1lum> 20:28 < c_wraith> and since you can't pattern-match against mutable cells anyway...
17:03:29 <ion> whoops, lag effects
17:03:37 <fowlmouth> can someone explain to me what a "monad" is
17:03:51 <ion> @quote monad
17:03:51 <lambdabot> Duqicnk says: a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
17:03:55 <c_wraith> fowlmouth: many of us could.  But you're best off just not caring about it.
17:04:07 <fowlmouth> word, i can accept that
17:04:10 <monochrom> it is a very useful type class
17:04:18 <ash_> how does one go form IO [String] to [String] ?
17:04:24 <c_wraith> fowlmouth: learn how to do what you want.  "Monad" is just an abstraction for a pattern that will make sense to you after you get used to it in action.
17:04:34 <mauke> fowlmouth: it's a type constructor T together with three operations, return, fmap, and join
17:04:51 <ion> Monad is an applicate functor with one more functionality. :-P
17:04:57 <monochrom> (const "hi") goes from IO [String] to [String]
17:05:05 <mauke> this doesn't really explain anything but there's not much to understand anyway
17:05:26 <c_wraith> ash_: you don't.  What you do is life your function that takes a [String] into IO.
17:05:33 <c_wraith> err, *lift
17:06:20 <aristid> i wish transformers/mtl had something like MonadLib's InBase, especially with the [] base monad (it doesn't, does it?)
17:06:25 <fowlmouth> cool
17:06:30 <aristid> -InBase+BaseM
17:06:41 <ion> > {- drosophy1lum: Also, -} let x = 42 in case 43 of y | y == x -> "oh yeah"; _ -> "oh no"
17:06:42 <lambdabot>   "oh no"
17:06:45 <fowlmouth> ive been reading tutorials and the syntax is wild (coming from ruby)
17:07:04 <aristid> lovely: instance BaseM [] [] -- Defined in MonadLib
17:07:13 <identity_> fowlmouth: it's wild like a woman in bed
17:07:16 <identity_> the good kind
17:07:29 <c_wraith> ash_: however, there's a syntactic sugar for doing all that called do notation.  It lets you treat a value of type IO [String] as if it was just of type [String], using the <- operator.
17:07:43 <dobblego> fowlmouth: http://blog.tmorris.net/what-does-monad-mean/
17:07:44 <identity_> it's not wild like a bloody grizzly bear running towards you as you switch your focus between your two broken legs and the bear
17:07:57 <mauke> .oO( QWOP )
17:08:18 <monochrom> no, ruby is the one with the wild syntax
17:08:42 <fowlmouth> its usually pretty readable to me
17:08:55 <fowlmouth> much better than php at least
17:08:59 <monochrom> everything is readable to me
17:09:17 <fowlmouth> is there a site dedicated to haskell programs
17:09:30 <identity_> in what way?
17:09:35 <parcs> hackage.haskell.org :)
17:09:38 <identity_> http://hackage.haskell.org
17:09:39 <monochrom> you can try haskell.org
17:10:29 <fowlmouth> ty ill be quiet for a while
17:11:16 <hpaste> ash_ pasted “IO [String] Error” at http://hpaste.org/48242
17:12:12 <fowlmouth> ^ that thing is awesome
17:12:38 <c_wraith> @tell chrisdone hpaste could use some line numbers
17:12:39 <lambdabot> Consider it noted.
17:13:09 <c_wraith> ash_: change the return type of port to IO FilePath
17:13:46 <c_wraith> ash_: then you'll need to change the type of openPort, too
17:13:48 <ash_> then openSerial complains it wanted a FilePath not an IO FilePath
17:13:59 <ash_> :-\ i didnt write openSerial
17:14:07 <c_wraith> you don't need to change it.
17:15:03 <mauke> ash_: do you happen to know javascript?
17:15:09 <ash_> sure
17:15:15 <hpaste> c_wraith annotated “IO [String] Error” with “IO [String] Error (annotation)” at http://hpaste.org/48242#a48243
17:15:24 <monochrom> openPort = port >>= \p -> openSerial p defaultSerialSettings { commSpeed = CS9600 }
17:15:31 <monochrom> or use do-notation again
17:15:33 <azaq23> openSerial attempts to use port, but port is an IO action which describes how to get a FilePath describing the port
17:15:43 <mauke> ash_: then you may want to learn about >>= and why it's async
17:16:01 <c_wraith> also, calling that type FilePath is horrible.  It's a String, not a FilePath.  Sadly, those are the same type.
17:16:03 <mauke> IO 2: callback harder
17:16:23 <monochrom> just delete "port :: FilePath" altogether
17:16:34 <ash_> c_wraith: I noticed that as well, but again, just following the types that were in the various functions i was using
17:16:54 <c_wraith> ash_: FilePath is defined as type FilePath = String
17:16:58 <monochrom> actually "/dev/tty.blabblah" is a FilePath alright
17:17:03 <c_wraith> ash_: so the two types are fully equivalent
17:17:17 <c_wraith> And interchangeable
17:17:57 <ion> c_wraith: What should FilePath be like instead?
17:18:06 <ion> A bytestring?
17:18:22 <c_wraith> ion: an opaque type.  Details may vary depending on the system.
17:19:00 <ash_> thanks, that got it working
17:19:57 <int80_h> how do I embed a " in a String
17:20:11 <azaq23> > "\""
17:20:11 <lambdabot>   "\""
17:20:21 <monochrom> > text "I am \"monochrom\""
17:20:22 <lambdabot>   I am "monochrom"
17:20:32 <ion> > '"':""
17:20:33 <lambdabot>   "\""
17:20:47 <c_wraith> ion: it could even have multiple representations internally.  One for "do the right thing with unicode for this platform" and another for "use this sequence of bytes, regardless of whether that's a valid thing for this platform or not"
17:20:57 <ion> c_wraith: True
17:21:00 <mauke> > "\32"
17:21:01 <lambdabot>   " "
17:21:01 <monochrom> heh ion wins
17:21:06 <mauke> > "\34"
17:21:06 <lambdabot>   "\""
17:22:50 <int80_h> when I do this in ghci
17:23:01 <int80_h> let test1 = "Here's an embedded \"Cookie: jsjsjs\""
17:23:03 <int80_h> I get this
17:23:08 <c_wraith> > show $ show ""
17:23:09 <lambdabot>   "\"\\\"\\\"\""
17:23:12 <int80_h> "Here's an embedded \"Cookie: jsjsjs\""
17:23:20 <c_wraith> > fix show
17:23:21 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
17:23:28 <drosophy1lum> > let x = 42
17:23:29 <lambdabot>   not an expression: `let x = 42'
17:23:52 <mauke> int80_h: I don't get anything
17:23:54 <ion> > iterate show ""
17:23:55 <lambdabot>   ["","\"\"","\"\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\...
17:23:56 <c_wraith> int80_h: that's because ghci shows everything by default.  try testing with "putStrLn test1" after that
17:24:01 <ash_> int80_h: how are you printing the value?
17:24:11 <mauke> ghci doesn't show let bindings
17:24:27 <int80_h> ash_: I just type the name of the binding in ghci
17:24:27 <c_wraith> mauke: I'm assuming he's testing with either "test1" or "print test1"
17:24:39 <int80_h> yeah I typed test1
17:24:45 <mauke> int80_h: what did you expect?
17:24:47 <c_wraith> use "putStrLn test1"
17:24:51 <ash_> use putStrLn
17:25:37 <int80_h> thanks :)
17:25:39 <int80_h> :q
17:25:42 <int80_h> \q
17:26:02 <ion> > text . concat . iterate show $ ""
17:26:09 <lambdabot>   mueval-core: Time limit exceeded
17:26:09 <lambdabot>  mueval: ExitFailure 1
17:26:10 <ion> text is strict?
17:26:12 <ion> > concat . iterate show $ ""
17:26:13 <c_wraith> yes
17:26:21 <lambdabot>   mueval-core: Time limit exceeded
17:26:28 <c_wraith> huh.  concat should not be strict
17:26:39 <ion> > concat . iterate show $ ""
17:26:44 <lambdabot>   mueval-core: Time limit exceeded
17:26:51 <ion> > take 20 . concat . iterate show $ ""
17:26:55 <lambdabot>   "\"\"\"\\\"\\\"\"\"\\\"\\\\\\\"\\\\\\\"\\"
17:27:08 <c_wraith> ok, lambdabot's just dying
17:27:41 <nihtml> @src iterate
17:27:42 <lambdabot> iterate f x =  x : iterate f (f x)
17:27:50 <parcs> > text "Here's an embedded \"Cookie: jsjsjs\""
17:27:52 <lambdabot>   Here's an embedded "Cookie: jsjsjs"
17:27:56 <mauke> > iterate f x
17:27:57 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
17:28:13 <ion> > fix f
17:28:14 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:28:14 <lambdabot>    `GHC.Show.Show a'
17:28:14 <lambdabot>      a...
17:28:19 <nihtml> #src fix
17:28:25 <nihtml> @src fix
17:28:26 <lambdabot> fix f = let x = f x in x
17:28:32 <c_wraith> I love that definition.
17:28:32 <nihtml> oh
17:28:34 <ion> > fix (f :: Expr -> Expr)
17:28:36 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
17:28:57 <parcs> did freenode just have a huge lag spike?
17:29:11 <c_wraith> I should play with vacuumLazy and the couple alternate definitions of fix
17:29:21 <c_wraith> Just to re-create why that's the more efficient definition
17:31:18 <nihtml> i dont understand, is fix useful?
17:31:27 <c_wraith> not really.
17:31:40 <c_wraith> Can it do stuff productive?  yes.
17:31:43 <mauke> nihtml: is recursion useful?
17:31:50 <c_wraith> Is it ever the clearest way to do it?  doubtful
17:32:01 <parcs> fix is useful for point-free recursion
17:32:03 <c_wraith> > fix $ (0:) . scanl (+) 1
17:32:05 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:32:14 <c_wraith> that's everyone's favorite opaque example of using fix.
17:32:20 <parcs> err, anonymous recursion i think is the term
17:32:42 <nihtml> oh ok
17:32:58 <identity_> c_wraith: .....
17:33:00 <identity_> the fuck.
17:33:07 <c_wraith> but yes, fix is just a combinator for anonymous recursion.
17:33:21 <identity_> @src fix
17:33:21 <lambdabot> fix f = let x = f x in x
17:33:23 <c_wraith> You never have to name the function to have it call itself
17:33:29 <parcs> > fix (\fac n -> if n == 0 then 1 else n * fac (n -1)) 10
17:33:31 <lambdabot>   3628800
17:33:39 <nihtml> i didnt understand how it can be used, thanks.
17:34:08 <ion> ‘let f x = … f … in f 42’ is equivalent to ‘fix (\f x -> … f …) 42’
17:34:33 <mauke> modulo types
17:35:06 <ion> yeah
17:40:39 <identity_> It is possible to catch ThreadKilled like any other exception, right? To clean up and et cetera
17:42:41 <ash_> if your using cabal to build an executable, is there an easy way to run it?
17:42:54 <identity_> like any other executable
17:43:37 <ehamberg> cabal install && myApp or cabal build && dist/build/myApp/myApp
17:43:52 <ehamberg> the first requires you to have ~/.cabal/bin in your PATH.
17:44:09 <ash_> ya, i have that in my path, i just didn't want to do install if i was still developing it
17:44:29 <ehamberg> then method #2, or use cabal-dev install :-)
17:53:31 <identity_> any way to tell lambdabot to use extensions?
17:53:54 <identity_> nvm, ghci can do it
17:58:25 <raadad_> hi guys
17:58:28 <raadad_> :D
17:58:34 <raadad_> scala or haskell>?
17:58:46 <raadad_> is there a implementation of haskell that runs in the JVM
17:59:29 <lispy> ?tell danharaj re: zippers and copying.  I'm not sure.  I would recommend you check the ICFP papers about zippers.  They might talk about copying behavior.
17:59:30 <lambdabot> Consider it noted.
17:59:58 <amacleod> If I want to get started with Haskell on Windows, is the HaskellPlatform installer linked to from HaskellWiki the best thing to get?
18:00:31 <lispy> amacleod: Yes, you want the Haskell Platfrom.  Can you show me the link?  I'll tell you if you have the most recent one
18:01:02 <amacleod> it's tagged 2011.2.0.1
18:01:18 <lispy> http://hackage.haskell.org/platform/windows.html
18:01:23 <lispy> that looks right
18:01:25 <amacleod> http://lambda.galois.com/hp-tmp/2011.2.0.1/HaskellPlatform-2011.2.0.1-setup.exe
18:01:35 <amacleod> That's where I downloaded it.
18:01:39 <lispy> cool
18:02:10 <lispy> you'll be ready to rock 'n roll
18:02:21 <pillowrice> Suppose I have an array of functions [f1,f2,f3,...] and I want to find [f1(x),f2(x),f3(x),...] --- how's that done?
18:02:23 <amacleod> :-D
18:02:44 <lispy> pillowrice: looks like zipWith
18:02:48 <azaq23> > map ($ 4) [(* 2), (+ 5)]
18:02:49 <lambdabot>   [8,9]
18:02:50 <amacleod> On Ubuntu, it's easy: apt-cache search haskell; apt-get install ghci
18:02:56 <amacleod> (or ghc, I forget)
18:03:13 <lispy> :t repeat
18:03:16 <lambdabot> forall a. a -> [a]
18:03:22 <mauke> pillowrice: sequence
18:03:34 <lispy> > zipWith [f, g, h] (repeat x)
18:03:35 <lambdabot>   Couldn't match expected type `a -> b -> c'
18:03:36 <lambdabot>         against inferred type `[...
18:03:41 <lispy> > zipWith [f, g, h] (repeat x) :: [Expr]
18:03:42 <lambdabot>   Couldn't match expected type `a -> b -> c'
18:03:43 <lambdabot>         against inferred type `[...
18:03:48 <aavogt> zipWith id
18:03:58 <pillowrice> i don't think zipWith is what I want
18:04:06 <pillowrice> at least I don't know how to use it in that way
18:04:11 <mauke> > sequence [f, g, h] x
18:04:12 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:04:12 <lambdabot>    `GHC.Show.Show a'
18:04:12 <lambdabot>      a...
18:04:16 <mauke> > sequence [f, g, h] x :: [Expr]
18:04:17 <lambdabot>   [f x,g x,h x]
18:04:20 <aavogt> > zipWith id [f, g, h] (repeat x):: [Expr]
18:04:21 <lambdabot>   [f x,g x,h x]
18:04:31 <lispy> oh, i didn't realize sequence would do it.  Must bo the reader monad...
18:04:33 <azaq23> > map ($ x) [f, g, h] :: [Expr]
18:04:34 <lambdabot>   [f x,g x,h x]
18:04:45 <pillowrice> mauke: thanks. where can i read about sequence?
18:04:50 <lispy> aavogt: oh, then zipWith ($) would work too
18:05:02 <aavogt> id is more general
18:05:15 <pillowrice> lispy: aha!
18:05:17 <lispy> :t zipWith id
18:05:18 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
18:05:27 <lispy> pillowrice: but I like the one azaq23 typed
18:05:31 <azaq23> Isn't it a bit silly to use (repeat x) for this?
18:05:42 <lispy> pillowrice: no intermediate list of x to fuse
18:06:03 <lispy> azaq23: perhaps, but ghc should optimize out the list of xs
18:06:23 <lispy> (I say that without checking of course)
18:06:34 <aavogt> lispy: the list (repeat x) should exist, it just doesn't take up much space
18:06:51 <amacleod> Out of curiosity, why does ghci say "Prelude" as its prompt?
18:07:09 <amacleod> Will I ever get to "Adagio" or "Overture"? :-P
18:07:33 <aavogt> that would be your program
18:07:36 <maurer_> amacleod: Prelude is the name of the module that is always automatically loaded
18:07:50 <maurer_> amacleod: Look at the Report for its definition
18:07:54 <pillowrice> aavogt: hmm, I actually want to use multiple arguments, but this sort of thing doesn't seem to work
18:08:01 <lispy> amacleod: heh.  That's because the standard set of definitions available to haskell programs is known as the Prelude (you should study it) and ghci is telling that it is in scope
18:08:32 <pillowrice> aavogt: e.g., I was hoping map ($ 1 2) [ (+) , (-) ] would be equivalent to [1 + 2, 1 - 2]
18:08:36 <maurer_> amacleod: You can disable prelude with  -XNoImplicitPrelude
18:08:54 <aavogt> probably the cleanest for that situation would be    map (\f -> f 1 2)
18:09:04 <amacleod> Okeydoke.  Seems like "Prelude" is its name because it comes before anything that I'm typing into ghci.
18:09:05 <mauke> pillowrice: no, that's equivalent to [(+) (1 2), (-) (1 2)]
18:09:31 <pillowrice> mauke: :-( ok
18:09:41 <pillowrice> mauke: is there a way to get the expression I'm after?
18:09:53 <mauke> what's wrong with aavogt's solution?
18:09:54 * hackagebot GLFW-b 0.0.2.7 - GLFW bindings  http://hackage.haskell.org/package/GLFW-b-0.0.2.7 (BrianLewis)
18:10:00 <amacleod> > :t ($ 1 2)
18:10:01 <lambdabot>   <no location info>: parse error on input `:'
18:10:02 * lispy cheers at Brian Lewis!
18:10:13 <amacleod> > t: ($ 1 2)
18:10:15 <lambdabot>   The section `GHC.Base.$ 1 2' takes one argument,
18:10:15 <lambdabot>  but its type `[SimpleRefl...
18:10:34 <pillowrice> mauke: oh, nothing. i didn't understand it until just now :-)
18:11:49 <mauke> > map (($ 2) . ($ 1)) [(+), (-)]
18:11:51 <lambdabot>   [3,-1]
18:12:53 <mauke> > sequence (sequence [(+), (-)] 1) 2
18:12:54 <lambdabot>   [3,-1]
18:13:31 <pillowrice> thanks, that seems to work
18:14:51 <pillowrice> can i convert a tuple into a list?
18:15:19 <Clint> depends on the types
18:15:46 <mauke> manually
18:16:53 <amacleod> let pairToList p = [fst p, snd p]
18:17:26 <pillowrice> ok, new question. I have a list of maps (f1,f2,f3) and I now want to find (f1 x y,f2 x y f3 x y)
18:17:34 <pillowrice> so the same as before, but with lists instead of tuples
18:19:57 <amacleod> Is it possible to get ghci to tell me all the type classes of a type?
18:20:02 <mauke> pillowrice: what?
18:20:18 <pillowrice> oops, i am confusing myself, sorry
18:20:33 <Draconx> amacleod, the instances?  :info.
18:20:54 <pillowrice> the new question is: I have a tuple of maps (f1,f2,f3) and I now want to find (f1 x y,f2 x y f3 x y); so it's the same as the first question but with *tuples* instead of *lists*
18:21:08 <mauke> pillowrice: do it manually
18:21:12 <amacleod> Draconx, exactly what I wanted.  Thanks :)
18:21:18 <mauke> the "size" of a tuple is part of the type
18:21:29 <mauke> you can't abstract over it
18:21:39 <pillowrice> hm, ok
18:22:38 <amacleod> How about the reverse?  I'm curious about Fractional.  Can I tell ghci to show me a list of all currently-known instances of Fractional?
18:23:43 <azaq23> amacleod: :info Fractional ;)
18:23:58 <amacleod> How terribly elegant!
18:24:47 <pillowrice> thanks for all the help!
18:24:54 <amacleod> So, Rational isn't an instance of Fractional?
18:25:18 <mauke> @src Fractional
18:25:18 <lambdabot> class  (Num a) => Fractional a  where
18:25:18 <lambdabot>     (/)             :: a -> a -> a
18:25:18 <lambdabot>     recip           :: a -> a
18:25:18 <lambdabot>     fromRational    :: Rational -> a
18:25:22 <mauke> totally is
18:25:48 <mauke> :t 1.0
18:25:49 <lambdabot> forall t. (Fractional t) => t
18:25:56 <mauke> > 1.0 :: Rational
18:25:57 <lambdabot>   1 % 1
18:26:04 <amacleod> Ok.  I didn't know that fromRational with the type Rational -> a meant Rational was an instance of Fractional.
18:26:16 <mauke> it doesn't
18:26:39 <azaq23> Rational is Rational = Ratio Integer, Ratio is in Data.Ratio. ghci will only show you the instances in your current scope
18:26:50 <azaq23> There is an instance instance (Integral a) => Fractional (Ratio a)
18:26:51 <amacleod> oh, hmm.
18:27:21 <azaq23> fromRational is just a converter function in the Fractional class
18:28:01 <amacleod> So what is it I'm getting when I say (5 :: Rational) / 3   ?
18:28:23 <mauke> five thirds
18:28:27 <azaq23> > (5 :: Rational) / 3
18:28:28 <lambdabot>   5 % 3
18:29:13 <amacleod> So is Rational a type, a type constructor, or a type class? (or more than one of these?)
18:29:20 <kmc> a type
18:29:28 <kmc> you can see it's on the right hand side of :: there
18:29:33 <kmc> if you can write (x :: t) then t is a type
18:29:38 <azaq23> @src Rational
18:29:38 <lambdabot> type Rational = Ratio Integer
18:29:41 <mauke> all types are type constructors
18:29:55 <parcs> > 5 % 3
18:29:56 <lambdabot>   5 % 3
18:29:57 <amacleod> mauke, good to know.
18:30:01 <kmc> Ratio is a type constructor, you can see that it's applied to another type
18:30:07 <parcs> % is the data constructor there
18:30:11 <kmc> amacleod, i don't agree with mauke
18:30:15 <mauke> parcs: no, it isn't
18:30:17 <kmc> parcs, not really, you can't pattern-match on (%)
18:30:35 <amacleod> kmc, is this a common disagreement among Haskellers?
18:30:37 <parcs> :t (%)
18:30:38 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
18:30:54 <mauke> parcs: % is clearly a lowercase symbol
18:31:09 <parcs> oh right, it's not prefixed with :
18:31:11 <kmc> to me "Int is a 0-ary type constructor" smells like "3 is a 0-ary function" which is a common statement, and pretty useless if not outright wrong
18:31:29 <kmc> amacleod, the problem is that we frequently want to talk about "types or type constructors"
18:31:46 <kmc> so the distinction gets blurred for the sake of brevity
18:31:53 <amacleod> kmc, the issue being that Int can only construct values of one type, which is Int?
18:32:05 <mauke> no, Int can't construct values
18:32:11 <kmc> no, it's not about constructing values
18:32:19 <mauke> type constructors construct types
18:32:20 <amacleod> Right.  I realized after I said it that I was at the wrong level.
18:32:25 <Jafet> :k Int
18:32:26 <lambdabot> *
18:32:26 <kmc> the issue is that "Maybe" isn't a type, nothing can have type "Maybe"
18:32:32 <Jafet> :k Maybe
18:32:33 <lambdabot> * -> *
18:32:36 <kmc> "Maybe Int" is a type; the type constructor has been applied to another type
18:32:40 <amacleod> But something could have a type Maybe Int.
18:32:47 <kmc> types are "types or type constructors" of kind *
18:32:54 <amacleod> Maybe is the equivalent of Scala's Option[_], right?
18:32:56 <kmc> type constructors are "types or type constructors" of other kind
18:33:09 <ddarius> kmc: No, Int is a type constructor like Nothing is a data constructor.
18:33:49 <azaq23> amacleod: Regarding scala Option, yes, though I'm not sure about the [_] notation there. But Maybe is Option (with data constructors Some and None) in Scala
18:33:55 <kmc> amacleod, i guess? generally i advise against learning Haskell by analogy to other languages
18:33:58 <kmc> but yes i think it's pretty close
18:34:25 <monochrom> I don't know Scala
18:34:46 <amacleod> Yeah, just looking for something familiar. :)
18:35:11 <monochrom> it is usually futile
18:35:20 <amacleod> Usually.. but Option is pretty simple.
18:36:04 <monochrom> "Just (div 1 0)" is allowed in Haskell. there is no corresponding thing in Scala
18:36:09 <identity_> If I wanted to stack ErrorT, IO and state, what order would I do it in? ErrorT (StateT MyType IO ()) SomeType?
18:36:18 <amacleod> So Maybe is a type constructor, and Maybe Int is a type, whose data constructors would be... Just x, and Nothing?
18:36:23 <identity_> Eh
18:36:24 <kmc> yeah
18:36:25 <identity_> missing a parameter there
18:36:35 <ddarius> monochrom: Scala does have some kind of "lazy" and "call-by-name" parameter passing conventions.
18:36:38 <kmc> @unmtl ErrorT e (StateT s IO) a
18:36:38 <lambdabot> s -> IO (Either e a, s)
18:36:41 <amacleod> monochrom, well, that's more because Haskell is lazy and Scala is strict, isn't it?
18:36:49 <monochrom> not with Scala's Some
18:36:52 <ddarius> monochrom: True.
18:36:59 <monochrom> so it's futile
18:37:20 <amacleod> Heh, here be my lesson: even for the seemingly simplest things, there are differences that make analogy futile.
18:37:34 <ddarius> monochrom is just ardently anti-analogy.
18:37:47 <amacleod> Just like nihilists believe in Nothing.
18:37:52 <monochrom> you need "data Option a = Some !a | Nothing" to regain your much desired resemblance
18:38:09 <amacleod> It'll be a little confusing for me because Scala's Nothing is a type (uninhabited, I believe) at the bottom of the type lattice.
18:38:28 <amacleod> What's the bang in Some !a mean?
18:38:38 <monochrom> and then it will still break because Haskell doesn't have subtyping or subclassing or extensible blah like Scala does
18:39:29 <amacleod> I have a feeling that I'll see Scala as "all tainted with Java" after I begin properly learning Haskell. :)
18:39:42 <kmc> yep
18:40:00 <identity_> kmc: A bit confused. I don't add the third parameter to StateT inside ErrorT e (StateT s IO) a?
18:40:04 <identity_> the parentheses, that is
18:40:11 <identity_> oh, never mind
18:40:13 <identity_> obviously don't
18:40:17 <identity_> much like I don't write (IO ())
18:40:47 <kmc> yep, the argument to a monad transformer has kind (* -> *)
18:40:56 * hackagebot elf 0.26 - Parser for ELF object format.  http://hackage.haskell.org/package/elf-0.26 (ErikCharlebois)
18:40:58 <ddarius> amacleod: I suspect you'll see that after properly learning Scala.
18:41:21 <kmc> ooh new elf
18:41:23 <amacleod> ddarius, oh, I do.  It's just hard to actually see the taint for what it is when you're in the midst of it.
18:42:25 <azaq23> amacleod: The bang means that x is always strict instead of lazy when used in in Some x
18:42:51 <amacleod> Ah, okay.
18:43:18 <ddarius> It doesn't make sense to say "x is [..] strict"
18:43:33 <ddarius> Some x gets translated (with the bang) to Some $! x
18:43:47 <kmc> nothing in Haskell is "unconditionally evaluated"
18:43:52 <kmc> (except for perhaps 'main')
18:44:00 <kmc> you can only add rules of the form "when you evaluate x, evaluate y first"
18:44:56 <amacleod> Under what realistic circumstances would I want to do that?  Laziness seems pretty excellent (almost magically delicious).
18:45:16 <kmc> it is delicious
18:45:29 <ddarius> amacleod: Evaluate foldl (+) 0 [1..10] by hand in call-by-name order.
18:45:30 <monochrom> when you want to control costs
18:45:38 <ddarius> Or read Okasaki.
18:45:54 <ddarius> (Actually, do both.)
18:45:55 <kmc> amacleod, if you know you'll force the result eventually, and want to use less memory in the meantime
18:45:57 <monochrom> including when you want higher costs
18:46:07 * amacleod defers reading Okasaki till later.
18:46:20 <kmc> like ddarius said, if i'm summing [1..10] I don't want to build a thunk that says (1+(2+(3+(...))))
18:46:25 <kmc> and then force it all at once
18:46:34 <kmc> i want to say "if you force the result at all, just do the damn addition in place"
18:46:42 <kmc> which GHC will, at appropriate optimization level
18:46:48 <kmc> @src foldl'
18:46:48 <lambdabot> foldl' f a []     = a
18:46:48 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
18:47:06 * kmc ponders whether that seq should be a pseq
18:47:10 <ddarius> Yes.
18:47:14 <monochrom> it should be pseq
18:47:16 <amacleod> What's pseq?
18:47:17 <ddarius> Virtually all uses of seq should be pseq.
18:47:34 <kmc> amacleod, (pseq x y) evaluates the same as y, but evaluates x first
18:47:37 <monochrom> haven't you seen my example? :) http://article.gmane.org/gmane.comp.lang.haskell.cafe/88120/
18:47:53 <kmc> the result of evaluating x is not directly used, but might have been previously shared
18:48:02 <monochrom> I almost have to cite it again every week. I already cited it twice today :)
18:48:05 <kmc> above, we force a', which also appears in (foldl' f a' xs)
18:48:08 <ddarius> monochrom and I share a hobby of finding noddy counterexamples.
18:48:22 <ddarius> monochrom: Just put it in the topic.  Because people read the topic.
18:48:30 <monochrom> ha ha ha
18:48:30 <amacleod> foldl' is the "do it in place" version of foldl?
18:48:47 <kmc> amacleod, not quite, but if you want GHC to figure out how to do your fold in place, you should use foldl'
18:48:52 <kmc> however there's nothing there which explicitly says "in place"
18:49:26 <kmc> it's just a fold where forcing the result, at all, forces the whole computation, including forcing the accumulator at each step
18:49:30 <azaq23> when I say, "x is always strict when used in Some x", I mean that, if Some x is evaluated, x is first completely evaluated / evaluation of x is forced, which should be correct - I thought that expression would be clear
18:49:54 <kmc> thus avoiding the problem «sum [1..100] = (1+(2+(3+...(99+100)...)))»
18:50:01 <ddarius> Note that foldl' and foldl are semantically different.  So relying on GHC to magically optimize one to the other is, in many cases, relying on GHC to make an unsound "optimization" which it won't do.  Sometimes you need the seqs so that it is semantically sound for GHC to make these kinds of optimizations.
18:50:19 <kmc> right, sometimes you actually do want lazy numbers!
18:50:28 <kmc> if i'm summing inductively-defined naturals
18:50:39 <ddarius> kmc: In that case you'd likely want to use foldr.
18:50:42 <kmc> (that might be okay anyway, because seq only forces to whnf)
18:50:43 <kmc> yes
18:50:51 <kmc> it is rare to want foldl
18:50:53 <Nimatek> Hmm, is there a haskell library for arbitary precision floats?
18:51:12 <ddarius> I think foldl should be gotten rid of and replaced with foldl'.
18:51:17 <kmc> usually you either want foldr (lazy, non tail-recursive, incrementally productive) or foldl' (accumulator strict, tail-recursive, all-at-once)
18:51:20 <ddarius> If someone -really- wants foldl, they can define it.
18:51:47 <ddarius> Nimatek: There's a few packages that provide things like that.
18:52:06 <amacleod> foldl f a [] = a
18:52:17 <Nimatek> ddarius: Like which ones, for example?
18:52:59 <monochrom> CReal in package "numbers"
18:53:05 <amacleod> hmm
18:53:12 <Nimatek> monochrom: Thanks, I'll check it out.
18:53:35 <kmc> CReal is not "floating point" though
18:53:43 <kmc> Nimatek, what are your requirements
18:53:58 <kmc> there are lots of different approaches to the general problem of "representing real numbers in a computer"
18:53:59 <ddarius> @hackage hmpfr
18:54:00 <lambdabot> http://hackage.haskell.org/package/hmpfr
18:54:01 <Jafet> CReal isn't really arbitrary precision, it is full precision
18:54:03 <monochrom> I am free to interpret it my way
18:54:13 <kmc> this is because the real numbers are fucking insane
18:54:21 <kmc> not a reasonable thing to think about, let alone represent in a computer
18:54:47 <Nimatek> kmc: I need to estimate numbers with the digits going into the tens of thousands, Doubles just return 'Infinity' there.
18:54:55 <kmc> you could use Rational
18:55:23 * ddarius wonders what one would do with 10,000 digits of precision.
18:55:43 <ddarius> That's far more precision than any physical task could require.
18:55:55 <Nimatek> I'm playing with projecteuler problems :)
18:56:53 <monochrom> there are smarter and computationally cheaper solutions to all project euler problems
18:57:09 <amacleod> In ghci, have I got to put pattern-matched function definitions all on one line?
18:57:19 <monochrom> also I agree with #python on "NO PROJECT EULER"
18:57:36 <ddarius> amacleod: No.
18:58:06 <amacleod> I think the type of foldLeft is (b -> a -> b) -> b -> [a] -> b.  Is that correct?
18:58:15 <ddarius> :t foldl
18:58:16 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
18:58:28 <amacleod> Heh.. I reversed the letters, cool.
18:58:47 <Nimatek> monochrom: It's not problematic computationally, but it does require large numbers
18:58:52 <Jafet> @hoogle (b -> a -> b) -> b -> [a] -> b
18:58:53 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
18:58:53 <lambdabot> Data.List foldl :: (a -> b -> a) -> a -> [b] -> a
18:58:53 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
18:59:22 <monochrom> file:///usr/local/haskell-platform-2011.2.0.1/share/doc/ghc/html/users_guide/interactive-evaluation.html has how to enter multi-line things in ghci. look for ":{"
18:59:47 <ddarius> Or ":}" if you're less morose.
18:59:53 <monochrom> heh
19:00:50 <amacleod> In haskell, how do I say what in Lisp would be (foldLeft f (f a x) xs)?
19:01:02 <ddarius> foldl f (f a x) xs
19:01:13 <ddarius> Or if you really want, (foldl f (f a x) xs)
19:01:28 <kmc> amacleod, see my previous statement about analogies :)
19:01:43 <amacleod> Hm, ok.  Wonder why I got a parse error, then.  Maybe I phrased the pattern wrong.
19:01:46 <kmc> we were just talking about foldl, and how you probably want foldl' or foldr instead
19:02:08 <amacleod> kmc, I was just trying to define foldl as an exercise.
19:02:53 <ddarius> foldl is sin
19:03:09 * amacleod commits his original Haskell sin.
19:03:31 <mike-burns> Is there a sample project I can follow that uses `cabal test' with QuickCheck 2?
19:03:37 <mike-burns> Or am I not supposed to use those?
19:03:42 <amacleod> let foldLeft f a (x:xs) = foldLeft f (f a x) xs
19:06:06 <Jafet> foldl f z = foldr (flip f) z . reverse
19:06:22 <Jafet> (Exercise: write reverse as a foldr.)
19:06:38 <amacleod> @t flip
19:06:39 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
19:06:43 <amacleod> @type flip
19:06:44 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
19:08:18 <amacleod> @type foldr
19:08:19 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
19:09:21 <azaq23> @src flip
19:09:22 <lambdabot> flip f x y = f y x
19:09:39 <amacleod> hmm. I don't know the syntax for function literals yet.
19:09:57 <azaq23> > (\a b -> a + b) 2 3
19:09:58 <lambdabot>   5
19:10:12 <amacleod> Ah.. backwhack for lambda.
19:11:43 <Jafet> > (λx → x) 42
19:11:44 <lambdabot>   Pattern syntax in expression context:
19:12:22 <mauke> people! stop being so obsessed with lambda
19:12:51 <mauke> the greek letter lambda is an imperfect approximation of the symbol \
19:13:06 <amacleod> Why couldn't they just get it right in the first place?
19:13:06 <monochrom> sml and ocaml do it right by just calling it (sml) "fn x => ..."
19:13:37 <Jafet> @remember mauke the greek letter lambda is an imperfect approximation of the symbol \
19:13:37 <lambdabot> Good to know.
19:13:47 <monochrom> oh heh
19:13:55 <sully> monochrom: and then sml gets it wrong by not letting you curry arguments to them
19:14:07 <sully> monochrom: you have to write "fn x => fn y => ..."
19:14:29 <amacleod> If I want to say that I expect both parameters of my anonymous function to be lists, how should I do that?
19:14:44 <monochrom> let the types figure it out
19:14:56 <amacleod> But I got an error. :(
19:15:15 <Jafet> Yup, the types figured out that there was an error
19:15:23 <monochrom> if the computer knows you want them to be lists, you will just get another error
19:15:28 <amacleod> apparently so.
19:50:16 <amacleod> let append a [] = [a]; append a (x:xs) = x : (append a xs); reverse a = foldr append [] a
19:50:23 <amacleod> Is that yucky?
19:50:51 <mauke> yes
19:51:17 <amacleod> Thought so.  Hints on how to do it less yuckily?
19:51:20 <mauke> append x xs = xs ++ [x]
19:51:27 <mauke> but that looks really slow
19:51:44 <amacleod> Yeah, it's awful.  It walks the list every time through the foldr.
19:51:53 <amacleod> Or, well, the remainder of the list.
19:51:53 <mauke> @src reverse
19:51:54 <lambdabot> reverse = foldl (flip (:)) []
19:52:05 <ddarius> Also superfluous parentheses.
19:52:21 <amacleod> Yeahbut.. the contortion exercise was to implement reverse as foldr.
19:52:31 <amacleod> ddarius, x:append a xs is good enough?
19:52:38 <ddarius> Yes.
19:53:10 <amacleod> 'cause x:append doesn't make sense, since you can't : something to the front of a function?
19:53:55 <mauke> no, that's irrelevant
19:54:13 <mauke> function application binds tighter than operators
19:54:38 <amacleod> I see.
19:54:42 <kmc> > 1 : map succ [10,20]
19:54:43 <lambdabot>   [1,11,21]
19:56:42 <kmc> :t map : map ($) [map]
19:56:43 <lambdabot> forall a b. [(a -> b) -> [a] -> [b]]
19:57:01 <amacleod> What's ($)?
19:57:06 <mauke> @src ($)
19:57:06 <lambdabot> f $ x = f x
19:57:08 <kmc> function application
19:57:20 <kmc> a typical use is (f (g (h x))) ⇒ (f . g . h $ x)
19:57:26 <kmc> it's also useful in operator sections, e.g.
19:57:31 <kmc> > map ($ 5) [pred, succ]
19:57:31 <lambdabot>   [4,6]
19:58:01 * amacleod feels his mind reaching for a Scala analogy and slaps his mind's wrist.
19:58:40 <kmc> my weird example is easier to understand if you see that ($) is a type-constrained version of "id"
19:58:42 <amacleod> So $ is an operator, much like + or -?
19:58:45 <kmc> yes
19:58:49 <kmc> it has low precedence
19:58:54 <kmc> infixr 0 $
19:59:01 <kmc> scala analogies are probably better than most
19:59:10 <kmc> tbh, we don't get that many people who know scala and not haskell
19:59:15 <kmc> but i have a feeling that is fast changing
20:00:03 <amacleod> I came to Scala from Python and some Java with a smattering of Scheme (and much C in the past).
20:00:07 <aavogt> there aren't any sections in scala and you need to be explicit about partial application
20:00:41 <aavogt> so to mix notation:  map (_ $ 5) [pred, succ]
20:01:09 <Cale> > (*2) 5
20:01:10 <lambdabot>   10
20:01:12 <amacleod> aavogt, List(pred, succ).map { _.apply(5) }
20:01:15 <Cale> > map (*2) [1..10]
20:01:16 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
20:01:35 <Cale> > map ($ 5) [id, (+2), (*2), (^2), (2^)]
20:01:36 <lambdabot>   [5,7,10,25,32]
20:02:21 <amacleod> > map (\x map ($ x) [pred, succ]) [1..4]
20:02:22 <lambdabot>   <no location info>: Parse error in pattern
20:02:32 <amacleod> oh, forgot the ->
20:02:37 <amacleod> > map (\x -> map ($ x) [pred, succ]) [1..4]
20:02:39 <lambdabot>   [[0,2],[1,3],[2,4],[3,5]]
20:02:45 <kmc> @pl \x -> map ($ x)
20:02:45 <lambdabot> map . flip id
20:03:05 <kmc> @pl \x -> map ($ x) [pred, succ]
20:03:06 <lambdabot> flip map [pred, succ] . flip id
20:03:14 <kmc> > map (flip map [pred, succ] . flip id) [1..4]
20:03:16 <lambdabot>   [[0,2],[1,3],[2,4],[3,5]]
20:03:33 <amacleod> ah, pl for pointless.
20:03:37 <kmc> yep :)
20:03:45 <kmc> amacleod, have you seen the full lambdabot tour yet?
20:04:06 <amacleod> kmc, no.  I'm familiar with things like @ tell and such from hanging out in #scala.
20:05:00 <kmc> @djinn (a -> b) -> Maybe a -> Maybe b
20:05:01 <lambdabot> f a b =
20:05:01 <lambdabot>     case b of
20:05:01 <lambdabot>     Nothing -> Nothing
20:05:01 <lambdabot>     Just c -> Just (a c)
20:05:19 <kmc> @quote _pizza_
20:05:20 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
20:05:24 <kmc> @. elite nixon
20:05:24 <lambdabot> aNY L4DY WH0 iz FIR57 1ady LIK3z0rz BEin9 Firz7 L4DY. I DoN'7 C4r3 \/\/|-|At TH3Y $aY, th3Y |ike I+.
20:05:40 <amacleod> @. elite zippy
20:05:41 <lambdabot> Plugin `compose' failed with: Unknown command: "zippy"
20:05:41 <kmc> @vixen Haskell or Scala?
20:05:41 <lambdabot> church is my favourite computer scientist.
20:06:28 <kmc> @faq Can Haskell determine the satisfiability of Boolean formulae in polynomial time?
20:06:29 <lambdabot> The answer is: Yes! Haskell can do that.
20:06:46 <kmc> @yhjulwwiefzojcbxybbruweejw
20:06:47 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
20:06:57 <amacleod> O_o
20:07:07 <kmc> @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
20:07:07 <lambdabot>   Hello World!
20:07:19 <amacleod> Is that some kind of SK stuff?
20:07:24 <kmc> that last one is Brainfuck
20:07:30 <amacleod> The one before it, I mean.
20:07:36 <kmc> that's a specific command name
20:07:53 <kmc> the oldtimers can give you more context
20:08:09 <kmc> lambdabot used to save the value she's printing in a variable named 'v'
20:08:23 <amacleod> You have just landed where we ignite efriti for zeitgeist or jollies cause b...
20:08:23 <kmc> but you could use that variable within your expression and weird things would happen
20:08:31 <kmc> so it was renamed to yhjulwwiefzojcbxybbruweejw
20:08:37 <kmc> @yhjulwwiefzojcbxybbruweejw
20:08:38 <lambdabot> Exception: <<loop>>
20:08:40 <kmc> @yhjulwwiefzojcbxybbruweejw
20:08:40 <lambdabot> "\"#$%&'()*+,\""
20:08:42 <kmc> @yhjulwwiefzojcbxybbruweejw
20:08:42 <lambdabot> "\"#$%&'()*+,\""
20:08:44 <kmc> @ghc
20:08:44 <lambdabot> ghc says: Kind signature on data type declaration has non-* return kind
20:08:54 <kmc> @protontorpedo
20:08:55 <lambdabot> is there an oo db in haskell?
20:09:33 <kmc> @oeis 14, 23, 28, 33, 42, 51
20:09:34 <lambdabot>  Numbered stops in Manhattan on the Lexington Avenue subway.
20:09:34 <lambdabot>  [8,14,23,28,33,42,51,59,68,77,86,96,103,110,116,125]
20:09:45 <amacleod> @help oeis
20:09:46 <lambdabot> oeis <sequence>. Look up a sequence in the Online Encyclopedia of Integer Sequences
20:10:13 <amacleod> @oeis 36, 24, 36
20:10:15 <lambdabot>  usigma(n) = sum of unitary divisors of n (divisors d such that gcd(d, n/d)=1).
20:10:15 <lambdabot>  [1,3,4,5,6,12,8,9,10,18,12,20,14,24,24,17,18,30,20,30,32,36,24,36,26,42,28,4...
20:15:02 <danharaj> hmm, so zippers seem to be the persistent equivalent to pointers, which would suffice for ephemeral structures.
20:15:02 <lambdabot> danharaj: You have 1 new message. '/msg lambdabot @messages' to read it.
20:15:07 <danharaj> ooh I'm popular.
20:16:52 <ion> :t yhjulwwiefzojcbxybbruweejw
20:16:53 <lambdabot> Not in scope: `yhjulwwiefzojcbxybbruweejw'
20:16:56 <ion> @yhjulwwiefzojcbxybbruweejw
20:16:57 <lambdabot> "\"#$%&'()*+,\""
20:17:56 <ion> > yhjulwwiefzojcbxybbruweejw
20:17:57 <lambdabot>   Not in scope: `yhjulwwiefzojcbxybbruweejw'
20:18:00 <ion> kmc: It seems that cannot be used in an expression. Did i misunderstand something?
20:23:32 <kmc> ion, lambdabot no longer works this way
20:28:01 <danharaj> hmmm
20:28:08 <danharaj> Suppose you had a search tree
20:28:52 <danharaj> given a zipper that points at an empty spot in the search tree, you could construct the zipper in such a way that it carries around the inequality constraint on whatever you could put in that position.
20:29:26 <danharaj> This would allow you to implement an insert operation that respects the order invariant.
20:29:34 <danharaj> (insert w.r.t. a zipper)
20:31:19 <kmc> hmm
20:31:21 <kmc> carries around how?
20:32:09 <danharaj> well, it would depend on the type of the ordering I guess. For most it would not be practical. But for example, integers, the constraint would be an upper and lower bound.
20:32:18 <danharaj> (practical or even computable, I suppose)
20:32:45 <edwardk> back to blogging. finally.
20:33:06 <fxr> REPA is damn fast
20:33:23 <danharaj> Repa is damned fast when you use it right :p
20:33:26 <edwardk> http://www.reddit.com/r/haskell/comments/i7sy0/free_monads_for_less_part_1_of_3_codensity/?already_submitted=true
20:33:36 <danharaj> if you make a mistake with sharing it can explode into a mess.
20:33:44 <edwardk> now to get the rest of it formatted
20:35:26 <fxr> http://stackoverflow.com/questions/6444716/how-to-write-nested-loop-problem-using-parallel-strategies-in-haskell see the comparison with the parListchunk...
20:36:27 <danharaj> that's more list processing being slow :)
20:37:03 <fxr> I think it's because of those intermediate tails...
20:37:17 <danharaj> ah hm... I wonder how you can maintain multiple zippers on the 'same tree' with minimal copying on mutation.
20:38:03 <edwardk> danharaj: oleg has a writeup on that
20:38:10 <kmc> finger trees?
20:38:28 <danharaj> edwardk: Does it involve type hackery beyond my ken?
20:38:28 <edwardk> danharaj: you can also work with multi-hole zippers. the derivative of a derivative.
20:38:54 <edwardk> maybe. iirc it was in the writeup for zipperfs
20:39:06 <danharaj> edwardk: Hmm. I wonder how that would work if you want to represent zippers as lists of contexts.
20:39:15 <danharaj> Instead of the straight derivative representation.
20:39:34 <edwardk> well, that is just a tweak on the output of the derivative rep
20:40:44 <danharaj> hmmm I suppose I should learn what a delimited continuation is too.
20:41:06 <monochrom> you will like it :)
20:41:41 <edwardk> danharaj: heh, i'll be writing a blog post on them soon
20:41:55 <danharaj> I'm basically trying to find out how to efficiently support the "twiddle some pointers in a data structure" style of algorithm.
20:42:22 <danharaj> Zippers seem nice for single pointers, provided the contexts store only a couple of words per level of context.
20:43:33 <danharaj> I don't like the name Zipper, either. I call them Cursors in my code, because I think of them as pointers.
20:44:01 <edwardk> danharaj: there is some benefit to using the common vernacular, in case anyone else has to read your code ;)
20:44:09 <danharaj> bah screw them.
20:44:27 <Cale> danharaj: IntMap :)
20:44:35 <danharaj> Cale: Hm?
20:45:12 <Cale> Pointers are keys of a big IntMap which is system memory
20:45:26 <edwardk> yeah
20:45:27 <Cale> You can use an IntMap in Haskell which takes its place :)
20:45:48 <danharaj> Cale: When I used to use C++ I thought of pointers as the random access iterators associated with array objects.
20:48:10 <danharaj> I suppose that's the highest level I ever thought in C++ :p
20:49:46 <Cale> Yeah, depending on the level of performance you need, you can use one or another sort of integer-indexed structure with fast updates of some sort to model pointer-twiddly algorithms. Of course, there's also ST.
20:50:31 <danharaj> Well when I say efficient, I merely desire a cut-down on the amount of copying done. I do not want to throw away persistence all the time.
20:52:08 <danharaj> But yeah, at some point I want to figure out how I can use ST for crazy psycho C style pointer rape.
20:53:06 <monochrom> ST has no C style pointer rape because it lacks p+5
20:53:37 <danharaj> minus pointer arithmetic :\
20:53:39 <Cale> Yeah, the difference between references and pointers is that you can do arithmetic on pointers.
20:53:49 <danharaj> pah, you can only do arithmetic within the bounds of an array.
20:54:11 <danharaj> (or a structure I guess)
20:54:50 <monochrom> and not even Pascal style because there is no "free"
20:55:15 <sshc> Is there an equivalent to creating a name with 'foo where the name doesn't already need to be declared or in scope?  (For example, the name might be used to provide a declaration with that name, rather than adding onto and using an existing declaration's name)
20:55:32 <monochrom> more like SML style but I don't know whether you know SML
20:56:01 <danharaj> It may very well be SML style. For me, the pointers I want are just positions in a data structure, and in ST I would like to use them to do in-place updates.
20:59:33 <danharaj> I've never written anything in SML
20:59:42 <danharaj> The syntax puts me off from learning.
21:00:16 <monochrom> SML syntax is not too different from Haskell syntax
21:00:44 <danharaj> yeah but it's... 'noisier' I guess?
21:02:43 <monochrom> the extra "fun" and "val" buy you freedom of layout
21:03:09 <danharaj> there's also the punctuation on type variables that I can't stand for some irrational reason
21:03:19 <danharaj> and the way type constructors go after the variable
21:03:27 <kmc> syntax is a silly reason to avoid a language... but i am guilty of this as well
21:03:40 <monochrom> the ' in 'a buys you freedom of uppercase and lowercase
21:03:46 <danharaj> kmc: I program for fun, so if it ain't fun, I won't do it. I am a terrible person... probably.
21:03:52 <kmc> :D
21:03:55 <danharaj> Screw freedom.
21:04:09 <monochrom> freedom gives me the fun you want
21:04:19 * Rotaerk puts danharaj in cuffs.
21:04:20 <kmc> as i see it, the main reason to use SML or OCaml over Haskell is that it's easier to understand the performance characteristics of your code
21:04:32 <kmc> the alternative solution is to learn more about the performance characteristics of GHC... a lot more
21:04:43 <danharaj> kmc: As I am learning.
21:04:53 <monochrom> frankly, getting "data my'type A = ctor A | zil" rejected is not my idea of fun
21:05:09 <danharaj> It might be my old C++ habits reemerging, but I am making stuff so I can make games, and my mindset for making games is that they are soft real-time.
21:05:21 <danharaj> So I am paranoid about laziness and the GC
21:05:43 <kmc> haskell is used for lots of soft realtime stuff
21:05:46 <kmc> but yeah, you do need to take care
21:05:49 <danharaj> yeah, by people smarter than me.
21:05:53 <kmc> some games use Haskell game logic + C++ rendering loop
21:06:09 <danharaj> it's the logic I'm afraid of! The opengl bindings are fairly lightweight.
21:06:36 <kmc> but GHC's RTS might decide to do a stop-the-world GC pass just when you need to render that next frame
21:06:49 <danharaj> yeah, that's an issue...
21:06:53 <danharaj> Is there a way to circumvent that?
21:07:07 <djahandarie> Yes
21:07:10 <djahandarie> Rewrite the GC
21:07:11 <kmc> run the render loop in an external thread written in C or such
21:07:16 <danharaj> ah
21:07:31 <danharaj> so I can't just mark a section of code as "fuck you run this, no GC for you"?
21:07:45 <kmc> what if it delays just before that section?
21:07:58 <danharaj> can I limit the time spent on GC?
21:08:04 <kmc> don't think so
21:08:15 <Rotaerk> hmm is it not possible to build a GC that is asyncronous
21:08:25 <Rotaerk> i.e. doesn't get in the way of the main thread
21:08:27 <kmc> it is; there are all kinds of approaches
21:08:36 <danharaj> I don't want to rewrite one of the most arcane pieces of GHC :\
21:08:41 <kmc> some involve custom hardware and/or kernel module
21:08:56 <kmc> i would love to see a realtime GC for GHC
21:09:03 <danharaj> I would love to see GHC run as an OS
21:09:11 <kmc> as i understand it, what it has now is a pretty good but fundamentally non-realtime GC
21:09:11 <danharaj> (or did galois already do that)
21:09:13 <kmc> @where House
21:09:13 <lambdabot> http://programatica.cs.pdx.edu/House/
21:09:34 <kmc> yeah, there's HaLVM
21:09:44 <kmc> which lets you run GHC Haskell code directly under the Xen hypervisor
21:10:08 <danharaj> I bet you could enable some completely sweet ass optimizations when you don't have a C kernel oppressing you.
21:10:13 <kmc> maybe
21:10:20 <kmc> but that C kernel is doing a lot of important, tricky shit
21:10:41 <kmc> it's a common sentiment here that every piece of software should be rewritten in Haskell
21:11:05 <djahandarie> All the interfacing with Xen is done in C anyways for HaLVM.
21:11:27 <kmc> what puzzles me are the people who want to write an OS in Haskell but want it to have the same 40-year-old UNIX semantics
21:11:38 <kmc> to me the cool opportunity there is to define richly-typed system call interfaces, filesystem, etc.
21:11:48 <danharaj> gross
21:11:55 <danharaj> I mean the UNIX sentiment
21:12:16 <sshc> Is there a cleaner equivalent to creating a name with 'foo where the name doesn't already need to be declared or in scope?  (For example, the name might be used to provide a declaration with that name, rather than adding onto and using an existing declaration's name).  (Besides just  mkName "foo")
21:12:20 <danharaj> Unix is a piece of shit compared to what could be done in a language that can express abstractions higher than a memory address.
21:12:20 <kmc> wouldn't even be that hard to implement a POSIX layer on top of that
21:12:27 <kmc> (not inherently harder than implementing POSIX in general, i mean)
21:12:51 <wli-needjob> Haskell would probably not be ideal for writing kernels, but it is true that C has serious deficiencies. Programming languages should be devised for systems programming with greater modularity and abstraction.
21:12:59 <kmc> yep
21:13:12 <kmc> what we need is C++, but not terrible
21:13:26 <danharaj> Haskell would be a totally kickass systems language. Hell, the RTS is like a tiny little VM already.
21:13:38 <bjornbm> D?
21:13:56 <danharaj> D is promising in ways.
21:14:20 <wli-needjob> Large runtimes are highly problematic for systems programming.
21:14:20 <kmc> danharaj, but what computer system isn't a tiny little VM, really ;)
21:14:32 <danharaj> kmc: you raise a nice point :p
21:14:47 <danharaj> I just wonder how efficient you could make a Haskell RTS if you didn't have to fight with C code for system resource attention.
21:15:02 <ddarius> kmc: Ones that are large WMs.
21:15:07 <ddarius> s/WM/VM/
21:15:44 <kmc> the Linux kernel alone implements a dozen things which are obviously VMs and probably hundreds which look that way if you squint
21:16:05 <danharaj> VM's are obviously monads.
21:16:06 <danharaj> duh.
21:16:08 <kmc> danharaj, it is true that GHC is duplicating things at the RTS layer which the OS already does
21:16:16 <kmc> thread scheduling, memory management, async IO
21:16:46 <wli-needjob> I would say which are fundamental tasks of operating system kernels, not "which the OS already does."
21:17:13 <wli-needjob> The trouble with such large runtimes is that by the time you've reimplemented the runtime for your architecture you've already written an OS kernel.
21:20:00 <dobblego> http://paste.pocoo.org/show/417958/ is this possible?
21:20:21 <wli-needjob> Or if not a whole one, such a substantial fraction of one that you've really screwed things up.
21:22:49 <benmachine> dobblego: I suspect yes
21:22:58 <dobblego> me too, I think it's juts me
21:23:39 <benmachine> dobblego: one problem is you don't have any way of combining inputs
21:24:04 <dobblego> not sure what you mean
21:24:17 <benmachine> well
21:24:22 <benmachine> hmm
21:24:27 <dobblego> you mean implementations of type-classes for Input?
21:24:36 <edwardk> bah. reddit is in readonly mode. i can't  post my article =(
21:24:59 <benmachine> dobblego: well, in the case of Done a i >>= f, the natural thing to do is f a
21:25:09 <benmachine> dobblego: in which case you might get Done a' i'
21:25:20 <benmachine> in which case I want to say, Done a' (i ++ i')
21:25:21 <benmachine> or something
21:25:26 <djahandarie> edwardk, oh, neat series
21:25:34 <benmachine> or possibly I'm doing this wrong
21:25:41 <dobblego> yeah it's Cont case that is puzzling
21:25:50 <edwardk> djahandarie: next time i reinvent IO ;)
21:26:03 <djahandarie> I saw Apocalisp tweet something about that
21:26:14 * ddarius considers the design of a zero function device.
21:27:26 <djahandarie> edwardk, something like http://hpaste.org/48041 ?
21:27:33 <edwardk> djahandarie: i was going to write it was one monolithic article, but i figured it'd work better broken into parts
21:28:27 <edwardk> similar but different. we're actually using the version i'm going to describe here at clarifi for our little haskell-like language.
21:28:44 <edwardk> the version there suffers ever-increasing slowdown.
21:29:06 <djahandarie> Codensity would probably solve that, right?
21:29:10 <edwardk> it takes O(n^2) to perform n actions in the naive free monad given there
21:29:25 <wli-needjob> Are there any libs out there for numerically solving simultaneous systems of polynomial equations?
21:29:28 <edwardk> djahandarie: yes, the other problem is the closed world of functions
21:29:38 <edwardk> djahandarie: and i just showed that codensity is bigger than you need
21:30:30 <benmachine> dobblego: I think the following typechecks:   Cont k >>= f   = Cont (((f =<<) =<<) . k)
21:30:41 <benmachine> couldn't vouch for its correctness necessarily
21:30:48 <edwardk> going to go spend anhour or so with my wife before she falls asleep, then i'll come back and finish formatting the third part
21:30:53 <dobblego> benmachine: it might, but I suspect it is off
21:31:01 <benmachine> dobblego: why?
21:31:17 <dobblego> benmachine: because it has only Monad f => in the type signature
21:31:25 <benmachine> so?
21:31:40 <benmachine> what else would it have?
21:31:46 <dobblego> Iter e f
21:32:02 <dobblego> if the Done case was the same, I could conclude it was off for sure, it's only an initial suspicion
21:32:05 <dobblego> lemme look
21:33:57 <dobblego> come to think of it, you might well be onto it! thanks
21:34:28 <dobblego> except it doesn't type-check, I need a break
21:35:38 <benmachine> you're telling me
21:35:50 * benmachine has been up for n hours for some unduly large n
21:35:58 <kmc> chype tek
21:36:13 <benmachine> uh-huh
21:36:38 <kmc> typechecker is great for catching "awake too long to program"
21:36:41 <kmc> and "too drunk to program"
21:36:45 <benmachine> :P
21:37:08 <monochrom> and generally all newbie wishes
21:37:19 * hackagebot loli 2011.6.24 - A minimum web dev DSL in Haskell  http://hackage.haskell.org/package/loli-2011.6.24 (JinjingWang)
21:37:30 <benmachine> now there's a name
21:37:40 <djahandarie> -_-
21:38:02 <kmc> "No instance for (Num (a -> a)) arising from a use of `+'.  Possible fix: sleep it off, come back when you're sober"
21:38:20 <kmc> it's more helpful than the existing suggestion, anyway!
21:38:20 * hackagebot miku 2011.6.24 - A minimum web dev DSL in Haskell  http://hackage.haskell.org/package/miku-2011.6.24 (JinjingWang)
21:39:34 <dobblego> I think I have it
21:41:08 <Jafet> Those packages have great documentation.
21:41:43 <djahandarie> I had seen miku and moe, but I just saw loli
21:41:48 <djahandarie> This guy sure has a strange naming sense
21:42:27 <Jafet> One can only hope his code is not written like this http://uguu.org/sources.html
21:42:41 <dobblego> http://paste.pocoo.org/show/417971/
21:42:43 <danharaj> heh
21:42:47 <danharaj> Hackage is an open forum.
21:42:52 <dobblego> the problem was my music, changed song, bam
21:43:33 <kmc> that would be the best
21:43:55 <robinhoode> Ugh.. I need to get out of this stupid web developer bullshit.. My brain is turning into mush.
21:48:06 <monochrom> hackage doesn't build docs all that often.
21:50:08 <djahandarie> Every night, I think.
21:52:15 <Saizan> it's a bit anticlimatic that all this optimizing free monads boils down to the church encoding
21:52:30 <dolio> preflex: seen edwardk
21:52:31 <preflex>  edwardk was last seen on #haskell 21 minutes and 43 seconds ago, saying: going to go spend anhour or so with my wife before she falls asleep, then i'll come back and finish formatting the third part
21:53:39 <monochrom> I see, older versions of loli and miku have docs built, but the docs say nothing
21:55:40 <RayNbow`TU> newtype Free f a = Pure a | Free (f (Pure f a))  -- is it just me or are there some errors in this? ( http://comonad.com/reader/2011/free-monads-for-less/ )
21:56:34 <RayNbow`TU> (it couldn't be a newtype because it has more than 1 constructor and secondly, I think the latter "Pure" should be "Free" instead)
21:57:15 <monochrom> "newtype" and "|" are in conflict
21:57:17 <dobblego> agree
21:57:49 <djahandarie> RayNbow`TU, correct on both accounts.
21:57:53 <monochrom> as for constructor names, you are free to use type names again. data X = X
22:00:55 <kmc> ghc -cpp -Dnewtype=data
22:01:24 <monochrom> you win
22:01:28 <dolio> RayNbow`TU: Yes. Codensity should also be quantifying over r, not a.
22:02:22 <RayNbow`TU> dolio: I wasn't that far into the blog post yet :p
22:03:14 <djahandarie> I totally skipped over all the definitions :p
22:09:34 <QinGW> :t Int
22:09:35 <lambdabot> Not in scope: data constructor `Int'
22:09:50 <QinGW> :t Char
22:09:51 <lambdabot> Not in scope: data constructor `Char'
22:10:26 <NemesisD> hate to cross-post but does anyone in here use hakyll?
22:12:34 <RayNbow`TU> :k Int
22:12:35 <lambdabot> *
22:14:24 <kmc> :k (->)
22:14:25 <lambdabot> ?? -> ? -> *
22:19:18 <QinGW> @hoogle Int
22:19:18 <lambdabot> module Data.Int
22:19:18 <lambdabot> Text.Read Int :: Integer -> Lexeme
22:19:18 <lambdabot> Text.Read.Lex Int :: Integer -> Lexeme
22:20:09 <QinGW> [LT .. GT]
22:22:13 <kmc> > [LT .. GT]
22:22:14 <lambdabot>   [LT,EQ,GT]
22:22:44 <kmc> > text . reverse . show $ [LT .. GT]
22:22:44 <lambdabot>   ]TG,QE,TL[
22:24:07 <QinGW> hehe
22:25:24 <amorphid> hi there Haskell aficionados.  question, are they people on here that want jobs programming in Haskell that can't find one?  I'm considering using Haskell for a project, but I'm afraid of not being able to find Haskell developers.
22:27:38 <danharaj> ah, what's that website where you can find haskell devs again?
22:27:47 <Saizan> haskellers.com ?
22:27:58 <danharaj> Too obvious, but correct.
22:28:40 <amorphid> danke, I'll check it out
22:29:39 <Saizan> anyhow, i don't think it'll be a problem to find haskell devolepers, but it depends on the details of the offer of course
22:33:31 <danharaj> :t foldl
22:33:32 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:33:33 <danharaj> :t foldr
22:33:34 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:34:59 <danharaj> @src foldl
22:35:00 <lambdabot> foldl f z []     = z
22:35:00 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:35:49 <danharaj> > foldl (+) 2 [1]
22:35:50 <lambdabot>   3
22:36:21 <danharaj> Man, I know I'm tired when I forgot how foldl works.
22:37:02 <amorphid> Saizan, thanks.  Just curious :)
22:55:22 <edwardk> heya dolio
23:05:02 <develhevel> who can help me navigating back in XML http://stackoverflow.com/questions/6464263/howto-navigate-back-in-haskell-with-hxt-in-a-xml-document ? perhaps you monochrom ?
23:06:11 <Botje> there wouldn't happen to be a "parent", woud there?
23:07:00 <develhevel> Botje: do you mean me?
23:09:49 <Botje> jah
23:11:55 <frerich2> develhevel: I think it sounds like a job for XPath
23:15:07 <edwardk> k. finally got all 3 parts up
23:15:47 <develhevel> frerich2: do you know hot to use it in the HXT?
23:16:26 <frerich2> develhevel: I know XPath, but I didn';t use the xpath package for hxt. Anyway, check http://hackage.haskell.org/package/hxt-xpath
23:19:24 <develhevel> frerich2: could you say me how a xpath command would look like for this job?
23:19:29 <frerich2> develhevel: Sure
23:19:37 <frerich2> develhevel: Let me add something to that stackoverflow question...
23:20:04 <develhevel> ok
23:22:07 <frerich2> develhevel: Ok, I added some more comprehensive answer.
23:22:26 <develhevel> thx
23:23:07 <frerich2> develhevel: XPath is a very concise notation for extracting information out of XML documents, it seems like a good tool for this job. However, I can't tell you from the top of my head ow the hxt-xpath API looks like for evaluating such statements.
23:23:24 <frerich2> develhevel: Usually you have some sort of 'evaluateXPath' statement which takes a string with the XPath statement and some XML node.
23:23:39 <Nisstyre> frerich2: what's your opinion on css selectors?
23:23:47 <Nisstyre> can they do most of the same things xpath can for html?
23:24:18 <frerich2> Nisstyre: I don't know anything about them, I only heard that became rather powerful. But then, more recent XPath (or XQuery) versions are quite sophisticated by now as well.
23:24:25 <Nisstyre> mhmm
23:24:40 <Nisstyre> I ask because I've seen them in some html parsers and they're talked about as if they can do the same things
23:24:49 <sohum> is there such a thing as a two-way map? or, what's the normal way to handle the situation where you want two representations of the same data to be isomorphic and O(1) translatable to the other?
23:24:52 <Nisstyre> just differently
23:25:00 <develhevel> frerich2: i will have a look on the api, thank you very mich
23:25:02 <develhevel> much
23:25:05 <frerich2> I only had to implement the XPath interpreter for some web component ("WebKit") and at that point, XPath 1.0 was still the de-facto standard.
23:25:10 <Nisstyre> sohum: are you talking about zip() ?
23:25:41 <sohum> Nisstyre: as in, zip :: [a] -> [b] -> [(a,b)]?
23:25:52 <Nisstyre> yes
23:26:21 <sohum> not ... really. If I have an a, finding its corresponding b is O(n) in the length of the items
23:26:27 <sohum> *number of items
23:26:48 <Nisstyre> sohum: yeah...but n is only 2 elements long
23:26:52 <Nisstyre> right?
23:27:21 <Nisstyre> I don't really understand what you're asking :P
23:27:22 <ziman> sohum, how about keeping just two Maps?
23:27:27 <Nisstyre> I just thought of zip()
23:27:43 <sohum> Nisstyre: no, it isn't. I have *many* instances of said data, and...
23:27:52 <Nisstyre> ah okay
23:27:55 <sohum> ziman: hm. that feels space-leaky
23:28:29 <Nisstyre> sohum: could you write an example?
23:28:37 <Nisstyre> I'm curious
23:28:39 <ziman> sohum, why? Maps do not leak space, afaik.
23:28:59 <sohum> Nisstyre: Having two maps, one a -> b and one b -> a is semantically what I want
23:29:06 <sohum> ziman: no, sorry, leak was the wrong word
23:29:15 <sohum> ziman: but I'd be storing the data twice, then, right?
23:29:30 <Nisstyre> sohum: so... like a chain?
23:29:33 <frerich2> sohum: A crazy idea: how about having one map like [(a,b)] and the reverse is actually a map [(b,b->a)] or something like that. I don't know whether that helps much, but the idea is that the reverse lookup just stores functions which yield the original value.
23:29:40 <frerich2> sohum: Instead of storing the 'a' twice.
23:29:43 <Nisstyre> is the result of the first map being used in the second?
23:30:14 <ziman> sohum, yes and no. The leaves will be probably shared; the inner nodes need to be different anyway.
23:30:42 <sohum> Nisstyre: nup. it's just a lookup table and a reverse lookup table, really
23:30:52 <Nisstyre> okay
23:31:06 <sohum> ziman: hrrm. okay then, I'll trust in the compiler :p
23:31:31 <ziman> sohum, are the values Ints?
23:31:37 <ziman> or something larger?
23:32:00 <Nisstyre> won't they not get stored anyway?
23:32:28 <Nisstyre> as in, evaluated
23:32:44 <frerich2> I think I would just have two maps under the assumption that the language will share data as much as possible.
23:32:48 <Nisstyre> don't see how memory usage is ever a problem
23:32:50 <frerich2> And only bother if it turns out to be false.
23:32:53 <nus> sohum, what do intend to gain by keeping two isomorphic representations of the data?
23:32:59 <sohum> ziman: Int and Set {record of a bunch of small int-like things}
23:33:07 <nus> sohum, s/do/do you/
23:34:39 <gfarfl> sohum: There's a Data.Bimap on hackage
23:34:52 <gfarfl> sohum: looks like it does what you want
23:35:05 <sohum> nus: the representations have different properties. the Ints are something like a unique id for the records
23:35:15 <sohum> gfarfl: ah! thank you
23:36:50 <gfarfl> sohum: however, skimming the source, it looks like it uses 2 maps internally
23:36:57 <ziman> sohum, if your memory constraints are tight, note that bimap is two maps in implementation, it's just a convenience module
23:37:59 <sohum> gfarfl: mmm, but the assumption then is that the authors have already run into whatever issues I'd have encountered in trying to implement one myself
23:38:18 <ziman> you might be better off with an IntMap and a different structure for mapping Set (...) -> Int — but until you try this, that would be premature optimization, I'd say
23:38:23 <sohum> ziman: they're not *tight*, it just didn't make sense to waste it when I thought I would be wasting it
23:39:33 <Saizan> edwardk: your blog could benefit by a layout with a larger central column :)
23:39:44 <edwardk> saizan: hah
23:39:53 <edwardk> saizan: did i avoid cropping anything at least?
23:41:38 <Saizan> edwardk: no, part 3 has Iterator and RSIterator cropped, and there was something else in the previous ones
23:42:48 <edwardk> ah
23:42:53 <edwardk> i forgot to fix those
23:43:27 <edwardk> fixed those two
23:43:37 <edwardk> lemme know if anything else gets chopped
23:46:47 <Saizan> RSIterator is still chopped for me, less than before though, i guess the font matters
23:46:59 <edwardk> hah
23:49:08 <Saizan> ah, IO too
23:49:32 <edwardk> k
23:50:25 <edwardk> updated
23:52:26 <Saizan> i'm afraid IO's type is too long too, though if it's just me i can live with that :)
23:52:47 <edwardk> lol
23:53:50 <edwardk> try now
23:54:30 <Saizan> now it fits :)
23:54:35 <erus`> @hoogle x -> IO x
23:54:36 <lambdabot> Control.Exception evaluate :: a -> IO a
23:54:36 <lambdabot> Control.OldException evaluate :: a -> IO a
23:54:36 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
23:55:39 <Saizan> fun how Fix OI is complete automatons while Free OI a is slices of them which you can compose
23:57:31 <edwardk> =)
23:58:28 <edwardk> yeah Fix (Yield i o) is basically a Moore machine.
23:58:47 <Saizan> yep
23:59:19 <edwardk> and isomorphic to Cofree ((->)i) o
23:59:43 <develhevel_> do somebody know how to get a XMLTree in the HXT to perform a XPath on it?
