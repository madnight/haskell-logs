02:11:28 --- topic: '["Paste code/errors: http://hpaste.org/new/haskell ", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin and spam issues: #haskell-ops"]'
02:11:28 --- topic: set by mauke!~mauke@p3m/member/mauke on [Sat Jun 11 05:12:19 2011]
02:28:24 <zenzike> does anybody happen to know if there's a way to set up/tear down before/after a criterion benchmark? I have some code that I'd like to run before and after a benchmark, but that shouldn't contribute to the timings.
02:33:03 <redfire> Hello
02:33:39 <redfire> I have a student project where I need to represent closures thanks to LLVM
02:34:13 <redfire> I took a look at the LLVM backend of GHC but I didn't find anything about them
02:35:07 <redfire> So I would like to know at which step closures disapear (lambda lifting or other stuff) in the compiling chain
02:35:44 <o-_-o1> .
02:37:13 * hackagebot miku 2011.6.15 - A minimum web dev DSL in Haskell  http://hackage.haskell.org/package/miku-2011.6.15 (JinjingWang)
02:41:56 <koala_man> dibblego:
02:57:51 <Eduard_Munteanu> redfire: you might want to try #ghc too
02:58:25 <Eduard_Munteanu> Or look into some papers related to GHC
02:58:28 <Eduard_Munteanu> @where stg
02:58:28 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
03:02:00 <Eduard_Munteanu> @where+ "Implementing Lazy Functional Languages on Stock Hardware: The Spineless Tagless G-machine", Simon Peyton Jones: http://research.microsoft.com/apps/pubs/default.aspx?id=67083
03:02:00 <lambdabot> Nice!
03:02:25 <redfire> Eduard_Munteanu: Thanks :-)
03:02:33 <Eduard_Munteanu> The previous didn't work.
03:02:45 <lysgaard> Does there exist some map like structure that stores it's values on disk?
03:03:21 <Eduard_Munteanu> redfire: see page 23
03:03:43 <Eduard_Munteanu> (the book, not document page number, in case they don't match)
03:03:59 <zygoloid> lysgaard: a "file system". :)
03:04:34 <Eduard_Munteanu> A mmaped Data.Map :)
03:05:11 <Eduard_Munteanu> (not sure if that works though, joking)
03:06:55 <zygoloid> lysgaard: there's such a thing described here: http://tinyurl.com/6gk27nk
03:07:30 <Eduard_Munteanu> Map on disk :))
03:10:33 * hackagebot instant-generics 0.3.1 - Generic programming library with a sum of products view  http://hackage.haskell.org/package/instant-generics-0.3.1 (JosePedroMagalhaes)
03:11:36 <erus`> whats a good data type to store poker hand values?
03:12:01 <DukeDave> Is there a nicer way to phrase this:
03:12:02 <DukeDave> updateRef ref dx dy dz = modifyIORef ref (\(Vertex3 x y z) -> (Vertex3 (x+dx) (y+dy) (z+dz)))
03:12:29 <erus`> data HandValue = Pair value kicker1 k2 k3 | TwoPair value k1 k2 ... liek that?
03:16:14 <Twey> miku doesn't build :-\
03:16:39 <DukeDave> erus`: Looks good to me?
03:17:00 <erus`> can i still derive enum ?
03:17:10 <erus`> so that pair < twopair?
03:17:46 <DukeDave> Good question :)
03:18:59 <Eduard_Munteanu> DukeDave: you could remove some paranthesis from there... updateRef ref dx dy dz = modifyIORef ref $ \(Vertex3 x y z) -> Vertex3 (x+dx) (y+dy) (z+dz)
03:19:46 <DukeDave> erus`: But you might want to define Ord yourself, so you can ensure Pair 3C 3H > Pair 2C 2H, for example
03:20:18 <erus`> ah ok
03:21:12 <erus`> DukeDave: how can i check which type a hand is now?
03:21:24 <erus`> like hand == TwoPair or the eqv.
03:21:37 <Eduard_Munteanu> erus`: pattern-matching
03:22:18 <Eduard_Munteanu> f (Pair ...) = ...
03:22:24 <Eduard_Munteanu> f (TwoPair ...) = ...
03:22:39 <Eduard_Munteanu> (replacing '...' suitably)
03:22:43 <erus`> ok
03:23:15 <Eduard_Munteanu> You can also pattern-match using case expressions.
03:23:30 <zygoloid> erus`: the derived Ord will order the constructors in the order you wrote them
03:23:34 <Eduard_Munteanu> case p of Pair ... -> ... ; TwoPair ... -> ...
03:23:38 <koala_man> what are some sweet (and maybe even practical) things in haskell that are painful or impossible in non-functional languages?
03:24:03 <ASKidwai> Hello
03:24:19 <zygoloid> erus`: (so deriving Ord for that type should do exactly what you want)
03:24:21 <ASKidwai> shpuld I learn haskell or C?
03:24:33 <Eduard_Munteanu> koala_man: maybe this, http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/ , but I have to ponder on it myself
03:24:36 <zygoloid> ASKidwai: that depends on why you want to learn a programming language.
03:24:52 <ASKidwai> I want to make programs for the PSP
03:25:41 <Eduard_Munteanu> C enjoys better adoption on different platforms, so if that's a problem...
03:25:58 <zygoloid> ASKidwai: you should probably learn one of the languages supported by the pspsdk
03:25:59 <Eduard_Munteanu> I don't know about PSP though.
03:26:04 <Eduard_Munteanu> Yeah ^
03:26:13 <ASKidwai> it has C and C++
03:26:26 <ASKidwai> but I want a firm base for my programming
03:26:51 <ASKidwai> I don't want some shoddy program created by me
03:27:01 <zygoloid> unless there already exists a haskell compiler which can target the psp, learning won't /directly/ help you. but it's great for learning (a certain way) to think about programming.
03:27:21 <ASKidwai> so is assembly as well?
03:27:24 <Eduard_Munteanu> Not that C teaches the wrong things.
03:27:54 <Eduard_Munteanu> Somewhat, though I don't think it's the best thing to start with.
03:27:59 <Eduard_Munteanu> (asm I mean)
03:28:06 <zygoloid> haskell is good for learning to think about, and with, abstractions. psp development probably requires you to be able to see through abstractions more than haskell encourages.
03:28:09 <Eduard_Munteanu> C at least gives you something manageable.
03:28:38 <ASKidwai> so I should start C?
03:29:15 <ASKidwai> I thought haskell was a dead language but seeing the members here, I am pleasantly surprised
03:29:20 <Eduard_Munteanu> If you take PSP development as a main goal (and stick to it by the time you learn a language), probably. :)
03:29:21 <zygoloid> learn C for PSP development, and learn Haskell to make you a better programmer :)
03:29:37 <Eduard_Munteanu> It's well alive and kicking ;)
03:29:55 <zygoloid> (warning: learning Haskell is liable to make you like programming in C less)
03:30:10 <ASKidwai> ^^ I thought so ^^
03:30:27 <Eduard_Munteanu> (well it's probably the "most" alive of its kind, at least wrt to research and public awareness, I think)
03:30:32 <ASKidwai> so as a first programming language, i should take?
03:30:45 <ASKidwai> it's kind meaning?
03:31:12 <Eduard_Munteanu> Functional-style languages.
03:31:13 <ASKidwai> tbh, I know Lua but it doesn't count as a real programming language
03:31:27 <ASKidwai> C is also functional type
03:31:30 <Eduard_Munteanu> I think it does, at least a bit.
03:31:33 <Eduard_Munteanu> No.
03:31:33 <ASKidwai> or is it imperative?
03:31:38 <Eduard_Munteanu> The latter.
03:31:44 <ASKidwai> k
03:31:49 <ASKidwai> I hated OOP though
03:31:51 <Eduard_Munteanu> Imperative, procedural.
03:31:55 <eddayyy> if you want to be a better programmer, haskell is the way to go
03:32:04 <ASKidwai> I tried CPP for some time, it was too annoying
03:32:11 <eddayyy> if you want to program PSP things quickly, C / ASM is the way to go
03:32:52 <ASKidwai> ^^ yeah. but most people recommend starting on the PC so for the PC, which language should I choose?
03:33:25 <Eduard_Munteanu> Haskell and C teach you different things anyway.
03:33:30 <ASKidwai> btw, are there any compilers for haskell in ubuntu?
03:33:35 <Eduard_Munteanu> Sure.
03:33:38 <Eduard_Munteanu> @where platform
03:33:38 <lambdabot> http://hackage.haskell.org/platform/
03:33:53 <Eduard_Munteanu> The package manager might also provide it directly.
03:34:01 <ASKidwai> ok
03:34:03 <ASKidwai> thanks
03:34:11 <zygoloid> apt-get install ghc6 :)
03:34:11 <ASKidwai> any good tuto for it?
03:34:18 <Eduard_Munteanu> @where lyah
03:34:18 <lambdabot> http://www.learnyouahaskell.com/
03:34:19 <ASKidwai> bye for now
03:34:33 <ASKidwai> but in the words of Arnie
03:34:36 <ASKidwai> I'll be back
03:42:11 <solistic> Is anybody aware of a method to get the path to the current executeable, similar to $0 in a shell script?
03:42:38 <solistic> ^ within a running haskell process, of coures
03:43:25 <DukeDave> solistic: http://haskell.org/ghc/docs/latest/html/libraries/base/System-Environment.html
03:43:52 <nschoe> getCurrentDirectory ?
03:44:12 <roconnor> I don't suppose it is possible to signal a running haskell program to dump it's heap size on the next major GC?
03:44:37 <solistic> DukeDave: what do you mean?
03:45:06 <solistic> nschoe: I think this is whap pwd prints, right?
03:45:19 <DukeDave> solistic: Sorry, I thought getProgName was what you wanted
03:45:36 <nschoe> solistic: and isn't it what you want?
03:45:36 <DukeDave> But that only returns the "leafname", apparently
03:45:41 <solistic> nschoe: no, but I may give this a try: http://hackage.haskell.org/package/executable-path
03:46:08 <nschoe> solistic: Just to say: I am definitely no expert, I just thought it and maybe it could help you, pardon me if I'm wrong.
03:46:30 <yitz> preflex: seen ibid
03:46:30 <preflex>  ibid was last seen on #haskell 19 days, 2 hours, 47 minutes and 24 seconds ago, saying: frerich: yes
03:47:03 <DukeDave> Can anyone give me a good reason why there isn't a:
03:47:03 <DukeDave>     instance Num a => Num (Graphics.UI.GLUT.Vertex3 a)
03:47:52 <roconnor> DukeDave: you cannot take the absoulte value of a vector and get a vector.
03:47:58 <roconnor> @type abs.
03:47:59 <lambdabot> parse error (possibly incorrect indentation)
03:48:01 <roconnor> @type abs
03:48:01 <lambdabot> forall a. (Num a) => a -> a
03:48:17 <solistic> nschoe: No, I want to find some file relative to the current executeable, I think the current working directory does not help with that
03:49:35 <DukeDave> roconnor: Ah, erm, oh, I would just have called abs on the components
03:49:53 <nschoe> solistic: yes I think I understood my error in here. Current dir is not the one the program is in. What about getProgName? Does it just return "myprog" or "/paht/to/myprog" ?
03:49:57 <DukeDave> But I can see that might be a little misleading
03:50:31 <solistic> nschoe: just myprog
03:51:20 <nschoe> solistic: erf. I'm sorry I don't know then :/ Did you try the executable-path lib you showed before?
03:52:36 <solistic> nschoe: yes, and, just as I feared, it does not work with runhaskell
03:53:04 <nschoe> solistic: Did you try to compile the program then run it?
03:53:57 <roconnor> DukeDave: also fromInteger is dubious
03:54:18 <roconnor> DukeDave: actually * is also dubious, but you might use the standard cross product
03:54:19 <solistic> nschoe: No, but im most certain that this will work, but I do not like this for test suites.., and I need it within my test suite to find some resource
03:54:29 <roconnor> or maybe you'd use pointwise multiplication; I dont' know :D
03:54:34 <hpaste> “Sanjoy Das” pasted “Hashtable`” at http://hpaste.org/47838
03:54:53 <ClaudiusMaximus> solistic: there is Paths_pkgname getDataFileName if you're using cabal and installing data files with it
03:55:18 <sanjoyd> Hi! Can I get some review on this: http://hpaste.org/47838
03:55:19 <solistic> ClaudiusMaximus: no, I'm runing it with runhaskell...
03:55:26 <nschoe> solistic: Hum, I'm sorry, but I'm not competent enough for this problem. I'm really just a Haskell newbie.
03:55:31 <roconnor> ... waits for his program to run out of heap
03:56:06 <ASKidwai> Hello
03:56:07 <solistic> nschoe: never mind, I'm almost certain, that this can only possibly work if you provide this functionality with ghc
03:56:12 <ASKidwai> I'm back
03:56:18 <sanjoyd> Except I should probably add a HashKey typeclass
03:56:36 <nschoe> solistic: so.. you're stuck?
03:56:56 <solistic> nschoe: you'd need two code paths, one for compiled executeables and one for executeables that are run with runhaskell
03:57:24 <nschoe> :/
03:57:52 <solistic> nschoe: well, currently I use a wrapper shell script that passess in `dirname $0`, but with this I can not use test-framework...
03:58:43 <nschoe> solistic: would not that be easier if you compiled and did your tests, even if it is a pain in the neck?
03:59:14 <solistic> nschoe: I just thougt, ill put the path in the environment, not beautiful but works..
03:59:27 <solistic> nschoe: s/ill/i'll
03:59:44 <nschoe> solistic: yeah you could do that too^^
04:00:39 <Eduard_Munteanu> Why do you need the path anyway?
04:03:03 <nschoe> "That, my friend, is the right question" ^^
04:03:50 <sanjoyd> What does this mean: "(All instance types must be of the form (T t1 ... tn) where T is not a synonym."
04:03:52 <sanjoyd> ?
04:04:57 <Eduard_Munteanu> sanjoyd: you're not allowed to declare/define type synonyms as instances of classes (without an extension)
04:05:03 <DukeDave> roconnor: Yes, I can see now that in many ways a Number is not a Vector :D
04:05:14 <Eduard_Munteanu> For example    type List a = [a]
04:05:31 <sanjoyd> Oh, okay.
04:05:32 <Eduard_Munteanu> You can't make List an instance of something.
04:05:39 <DukeDave> I just wanted to use (+) without the compiling becoming upset about Prelude.(+)
04:05:45 <Eduard_Munteanu> Unless you use the TypeSynonymInstances extension
04:05:47 <Eduard_Munteanu> (IIRC)
04:05:51 <sanjoyd> So instead of instance foo String I should do "instance foo [Char]"?
04:06:30 <Eduard_Munteanu> Yeah. Or enable that extension, or use a newtype if abstraction really matters.
04:07:28 <sanjoyd> Okay, now I get "All instance types must be of the form (T a1 ... an) where a1 ... an are *distinct type variables*, and each type variable appears at most once in the instance head."
04:07:54 <sanjoyd> Basically I have a typeclass HashKey hk, which has one function hash :: Int->hk->Int
04:08:13 <sanjoyd> How do make String an instance of this class, and implement a hash method?
04:08:34 <solistic> Eduard_Munteanu: I want to call a built executeable from my test suite
04:09:35 <solistic> Eduard_Munteanu: it is under dist/build/myprog/myprog relative to my project root
04:10:22 <roconnor> DukeDave: you mean you can see in many ways a Vector is not a Number.
04:10:37 <roconnor> (A number is a 1 dimensional vector)
04:10:48 <solistic> Eduard_Munteanu: And I want to call it from tests/Main.hs, where Main.hs is run with runhaskell
04:11:25 <solistic> Eduard_Munteanu: Any idea how I could do this without knowing the path to Main.hs?
04:11:53 <Eduard_Munteanu> sanjoyd: how are you declaring the instance?
04:13:11 <sanjoyd> Eduard_Munteanu: never mind, got it.
04:13:22 <dAnjou> hi, i have a tiny stupid question :P: i can set the prompt in ghci with `:set prompt "foo > "` but how can i set it permanently? (ubuntu 11.04 + gnome2)
04:13:33 <sanjoyd> Eduard_Munteanu: did an instance (HashKey hk) => HashKey [hk] where ...
04:13:35 <Eduard_Munteanu> solistic: if this is a test suite, aren't you already running Cabal or make from a known dir?
04:13:54 <sanjoyd> Eduard_Munteanu: so now I just show how to treat Char as a HashKey and Haskell does the rest. :)
04:14:14 <Eduard_Munteanu> sanjoyd: that doesn't seem right
04:14:22 <twanvl> dAnjou: put that line in ~/.ghci
04:14:30 <sanjoyd> Eduard_Munteanu: why?
04:14:44 <ichernev> hello
04:14:51 <Eduard_Munteanu> sanjoyd: look at Show for example
04:15:05 <sanjoyd> @src Show
04:15:05 <lambdabot> class  Show a  where
04:15:06 <lambdabot>     showsPrec :: Int -> a -> ShowS
04:15:06 <lambdabot>     show      :: a   -> String
04:15:06 <lambdabot>     showList  :: [a] -> ShowS
04:15:25 <Eduard_Munteanu> @src Show Char
04:15:25 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
04:15:37 <Eduard_Munteanu> Bah.
04:15:44 <dAnjou> twanvl: thank you very much
04:15:47 <solistic> Eduard_Munteanu: not currently, i just run it with runhaskell
04:15:49 <sanjoyd> Eduard_Munteanu: but wherever I hash a value, I don't want to differentiate between a list or a specific value.
04:16:03 <sanjoyd> As in, I want to be able to say (hash foo).
04:16:20 <sanjoyd> Not do a case expression thing, and do a hash or a hashList based on it.
04:16:24 <Eduard_Munteanu> sanjoyd: sure you do. Don't you want to hash integers, or strings or...?
04:17:07 <ichernev> so I have 4 functions: A1 B1 and A2 B2. A1 and A2 receive the same args, but return different ones, both of which belong to a class C. Then B1 accepts the ouput of A1 and B2 accepts the output of A2, and they produce the same result. Is there any way to put all of these in an array? Sometimes I'll want to use only A1/A2 and then conv to string & print, but other tmes I may have to pass the output to B? and then print the result
04:17:18 <hpaste> “Sanjoy Das” pasted “Hashtable`” at http://hpaste.org/47840
04:17:30 <sanjoyd> Eduard_Munteanu: just pasted my code ^
04:17:38 <DukeDave> roconnor: I can see many ways in which I should have a coffee before talking on #haskell :)
04:17:44 <Eduard_Munteanu> You could have an instance (HashKey hk) => HashKey [hk] though.
04:17:53 <sanjoyd> Eduard_Munteanu: yes, that is what I'm doing.
04:18:00 <sanjoyd> Sorry if I meant otherwise.
04:18:41 <sanjoyd> Eduard_Munteanu: also, other suggestions for improving my code are welcome. :)
04:19:03 <Eduard_Munteanu> Ah, sure, it works but it's not just an instance for String.
04:19:20 <sanjoyd> Did not get you.
04:19:50 <sanjoyd> Is String not an instance of HashKey? It should be, right? Since Char is, and I've said if x is an instance, so is [x].
04:22:08 <nschoe> Hum, has anyone used HaskellNet.SMTP lib to send emails within a Haskell program? I've been struggling with that, and came with this: http://hpaste.org/47841 . I included the response code and message I got, everything seems to happen well but when I check my inbox no mails in it :/
04:22:19 <Eduard_Munteanu> It's not a specific instance for String, I mean. That's what you initially asked for.
04:22:20 <nschoe> Had anyone an idea how to solve this?
04:22:44 <sanjoyd> Eduard_Munteanu: no, it is not. I was not able to do a "instance HashKey String".
04:23:18 <Eduard_Munteanu> sanjoyd: instance HashKey [Char] where ...
04:23:24 <sanjoyd> Eduard_Munteanu: does not work.
04:23:39 <sanjoyd> 17:07 <sanjoyd> Okay, now I get "All instance types must be of the
04:23:39 <sanjoyd>                 form (T a1 ... an) where a1 ... an are *distinct
04:23:39 <sanjoyd>                 type variables*, and each type variable appears at
04:23:39 <sanjoyd>                 most once in the instance head."
04:24:01 <erus`> can someone write me a haskell snippet to mine bitcoins?
04:24:16 * hackagebot simple-sendfile 0.0.2 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.0.2 (KazuYamamoto)
04:24:32 <sanjoyd> Another thing, say I have some code "foo x = lookupHash (makeHash list) x", will every invocation to foo run makeHash, or can I expect GHC to intelligently figure out that makeHash remains constant, and cache the value?
04:24:37 <Eduard_Munteanu> [Char] is basically the same kind as Char, so if you can write the latter...
04:24:53 <sanjoyd> I don't understand kinds very well.
04:25:04 <benmachine> sanjoyd: FlexibleInstances is one of the less controversial extensions
04:25:20 <Eduard_Munteanu> TypeSynonymInstances is more specific
04:25:49 <sanjoyd> Anyways, not using an extension actually solved a more general problem for me.
04:25:59 <benmachine> yes but if you want to have an instance for String then FlexibleInstances is more correct
04:26:03 <sanjoyd> (And I learned a little something - this is anyways a learning exercise).
04:26:11 <sanjoyd> benmachine: I also want one for a char.
04:26:30 <benmachine> it's a bug that you can declare instances for String without FlexibleInstances
04:26:37 <sanjoyd> benmachine: and now that I have one for a char, I'll automatically have one for a [String], [[String]] and so on.
04:26:42 <benmachine> and it will be fixed for the next release
04:26:55 <sanjoyd> benmachine: of course, if it were some other typeclass I'd be more interested in those extensions.
04:27:00 <benmachine> sanjoyd: yes, your way of doing it is sensible, I'm just commenting :)
04:27:04 <nschoe> Any idea? Just to say: I've checked the settings on my phone, and I use this SMTP serveru, with this port, and the "need log in" checkbox is checked and the Id is the full address like I put. So basically I did the same things and even get a "Auth successfull" after the sendCommand (AUTH LOGIN ) command...
04:27:11 <nschoe> The mail is just not delivered.
04:27:23 <nschoe> oOps sorry for underline :/
04:28:22 <benmachine> nschoe: at a guess, SMTP protocol error? like wrong headers or something?
04:28:31 * benmachine doesn't know SMTP very well
04:29:20 <Eduard_Munteanu> I guess I don't see the point for GHC complaining about that. :/
04:30:00 <nschoe> benmachine: Probably, but I have checked the response code after each "sendCommand" and it looked good. Dont know SMTH either, but I basically rewrote the code for "sendMail": http://hackage.haskell.org/packages/archive/HaskellNet/0.2.5/doc/html/src/Network-HaskellNet-SMTP.html#sendMail I just added the LOGIN part. So I truly don't get what is wrong.
04:30:19 <ichernev> can I have a list of things that share the same class, but not the same type? I'm only going to call class defined functions on them
04:30:31 <Eduard_Munteanu> Wait, I kinda do. :)
04:31:04 <Eduard_Munteanu> Since you could have instances for [a], Char, and [Char].
04:35:36 <parcs> ichernev: yes, using existential quantification
04:37:30 <ichernev> parcs: can you please be more specific
04:38:07 <ichernev> parcs: like forall?
04:39:33 <parcs> ichernev: yeah: data X = forall a. Enum a => X a
04:40:36 <ichernev> parcs: but I somehow need type, not data.
04:41:45 <ichernev> lets say I have 2 functions which receive the same input and return something of class Show. I want to put these in an array and based on user input choose which one to call (and the result I'll just "show")
04:42:45 <mux> data Showable = forall a. Show a => a
04:42:52 <mux> then you should be able to have a list of Showable
04:43:06 <parcs> ichernev: you need to wrap the input in something like X
04:44:32 <ichernev> mux: parcs, ok this is getting interesting :)
04:46:07 <ichernev> but this data type Showable has no constructors? it is somewhat different than "data" types I have currently seen
04:46:20 <parcs> that was a typo i think
04:46:30 <parcs> it needs a constructor
04:46:37 <ichernev> should be => Showable a
04:48:14 <ichernev> and  this is different than data (Show => a) Showable a = Showable a
04:48:51 <hpc> you mean data (Show a) => ...?
04:49:07 <ichernev> yes
04:49:38 * yitz quickly waves hello to edwardk, before he does
04:49:52 <ichernev> I mean -- is this what you are talking about very different from normal data types with constraints
04:51:44 <benmachine> ichernev: if you're just going to show it anyway, why not just store strings?
04:52:14 <ichernev> benmachine: lets say its not that easy
04:52:19 * hackagebot netlines 1.0.0 - Enumerator tools for text-based network protocols  http://hackage.haskell.org/package/netlines-1.0.0 (ErtugrulSoeylemez)
04:52:35 <benmachine> ichernev: well then you can use existentials, but I'm just trying to point out that sometimes there is an easier way :)
04:52:41 <benmachine> e.g. using partially applied functions
04:53:21 <benmachine> ichernev: if by normal data types with constraints you mean data Foo a => Bar a = Baz a
04:53:25 <benmachine> then yes it is very different
04:54:02 <benmachine> those kinds of contexts are sufficiently useless that they are going to be removed from the next version of Haskell
04:54:20 * hackagebot ihttp 0.3.0 - Incremental HTTP iteratee  http://hackage.haskell.org/package/ihttp-0.3.0 (ErtugrulSoeylemez)
04:54:32 <ichernev> what do you mean by partially applied function
04:54:51 <ichernev> I have to either print the type or pass it to another function
04:55:01 <ichernev> which will return a string
04:55:03 <benmachine> ichernev: well, say you wanted a list of objects you were eventually going to call shows on
04:55:08 <benmachine> shows :: a -> String -> String
04:55:16 <benmachine> you could store 'shows thing' instead of 'thing'
04:55:21 <benmachine> and have a list of [String -> String]
04:55:37 <Peaker> @type shows
04:55:39 <lambdabot> forall a. (Show a) => a -> String -> String
04:55:49 <Peaker> It could use DList Char
04:56:08 <benmachine> Peaker: it could.
04:57:20 * hackagebot ismtp 4.0.1 - Advanced ESMTP library  http://hackage.haskell.org/package/ismtp-4.0.1 (ErtugrulSoeylemez)
04:58:23 <ichernev> I have to go now, I'll try things out and tell you the results after that. Thanks for the info!
05:04:10 <joe6> this is the code:  http://sprunge.us/HVMR and this is the error:  http://sprunge.us/WRLj . Any suggestions on what I could be missing? The line number is the "$ stacks" of the return statement
05:10:54 <benmachine> joe6: indent all those operators further than the return
05:16:14 <joe6> benmachine: ok, thanks.
05:18:16 <ezyang> Hello all, I need some theory help on fixpoints.
05:18:49 <ezyang> The classic way to calculate the fixpoint of some set of equations is to initialize everything to 'bottom', and then repeatedly apply the transformation function until you reach a constant value.
05:19:59 <ezyang> Suppose I have a fixpoint calculation that involves multiple functions which feed into each other. Am I guaranteed to find the least fixed point if I do some sort of scheduling of the evaluations, so that if an input of a function changes, I always evaluated eventually, but not immediately?
05:20:07 <Peaker> would fix (1:)  ever complete computation that way?
05:20:25 <ezyang> I get to assume a finite domain :-)
05:22:32 <quicksilver> ezyang: depends if your function is monotone continuous and depends if your domain is complete.
05:23:12 <quicksilver> ezyang: a lot of the 'point' of the fixed-point semantics of recursive functions is doing the work to make those conditions apply, so that least fixed points always exist and are unique.
05:24:24 * hackagebot arbtt 0.6.1 - Automatic Rule-Based Time Tracker  http://hackage.haskell.org/package/arbtt-0.6.1 (JoachimBreitner)
05:25:04 <magicman> @hoogle insertWithM
05:25:05 <lambdabot> No results found
05:25:36 <ezyang> Assume a complete domain, and monotone continuous functions.
05:25:46 <mm_freak> is there a ready-made daemon framework for haskell, which makes it easier to maintain daemons?
05:25:55 <mm_freak> i.e. starting, stopping, signalling, etc.
05:26:02 <ezyang> Basically, what's not clear to me, is if I can swap out one particular algorithm for calculating a fixpoint with another, and what do I have to prove in that case.
05:26:21 <mm_freak> up to now i'm using killall, which isn't very clean/safe
05:27:20 <hpc> mm_freak: perhaps you could look for a way to get the PID of processes you spawn
05:27:29 <hpc> then use kill
05:29:41 <mm_freak> hpc: sure, i just thought, there may be something ready-made
05:30:02 <quicksilver> ezyang: well it's kind of clear, with the right assumptions. If can't go on forever (finite domain), it can't loop (monotone) so it must reach a fixed point, no?
05:30:17 <magicman> mm_freak: There's http://hackage.haskell.org/package/direct-daemonize and http://hackage.haskell.org/package/hdaemonize which may be of interest to you.
05:30:28 <mm_freak> magicman: oh, thanks
05:31:06 <zenzike> is there any difference between "case foo of bar -> x; foo -> z" and "case foo of bar -> x; _ -> z"? I'm seeing it in some code I'm looking at, and wondering if it's just a stylistic thing
05:31:46 <ezyang> but will it be the least fixed point? :-/
05:31:53 <edwardk> zenobia_: are bar and foo in the case alternatives lowercase variables or placeholders for stuff?
05:32:17 <edwardk> case foo of bar -> x; … = let bar = foo in x ;)
05:32:35 <mm_freak> magicman: great, hdaemonize does exactly what i need…  thanks a lot
05:32:37 <zenzike> bar is some placeholder, but foo will be some variable
05:32:43 <hpc> zenzike: the '_' in the pattern means "it can be anything, and we don't want to give it a name"
05:33:13 <zenzike> hpc: yep, I'm aware of that, but I don't see what is gained by using foo as a case match, rather than _
05:33:17 <edwardk> the _ case is just saying ignore the variable
05:33:37 <edwardk> explicit Foo is better if you might add cases later.
05:33:42 <zenzike> (I'd always use _, I'm just seeing code that uses foo ..)
05:33:50 <edwardk> that way you can know the pattern match wasn't updated from the warnings
05:33:57 <edwardk> _ will just eat all remaining cases
05:34:04 <hpc> zenzike: it helps make code structure more obvious, sometimes
05:34:23 <hpc> "case foo of True -> 1; _ -> 0" vs "case foo of True -> 1; False -> 0"
05:34:27 <edwardk> in general there is no cost to this.
05:34:51 <edwardk> hpc: in general a simple case on constructors is dispatched by evaluating and then dispatching on the tagbits
05:34:51 <zenzike> edkwardk:  yes, but in this case the "foo" is both in the "case foo" part and the "foo ->" part
05:35:09 <hpc> edwardk: i mean to the programmer, not the compiler ;)
05:35:41 <edwardk> zenzike: so foo is just another name binding for foo shadowing the outer foo?
05:36:12 <zenzike> edwardk: it's the same variable in both the case and the (last) match parameter
05:36:25 <zenzike> it seems to me like using _  is exactly the same
05:36:26 <hpc> zenzike: perhaps you could paste the whole function for us?
05:36:43 <edwardk> then both are going to compile to the same thing anyways, internally ghc would compile it as something like case foo as x of …  and then use the x binding
05:36:46 <zenzike> oh, what I wrote initially is a faithful account of what it looks like
05:37:00 <edwardk> (core cases are a little funny)
05:37:08 <edwardk> so there is no difference other than style
05:37:39 <zenzike> edwardk: thanks. I was jut checking that there wasn't some kind of strictness condition or something that made them subtly different
05:38:27 <edwardk> nah, if the other pattern needs the outermost constructor evaluated, it is going to desugar to an identical rep
05:38:43 <edwardk> (or even if not, actually)
05:39:32 <zenzike> edwardk: thought so. I find the "foo ->" match horrible, "_ ->" seems clearer to me :-)
05:44:21 <benmachine> shadowing is the devil
05:44:36 <benmachine> actually it isn't, but it's kind of complicating things, usually unnecessarily
05:46:44 <hpc> shadowing is fine until suddenly it isn't
05:46:58 <hpc> i personally like being able to use 'id' as a variable for identifiers
06:06:08 <lispy> hello
06:06:35 <lispy> hpc: So import that qualified :)
06:06:46 <lispy> import qualified Prelude ( id )
06:07:00 <lispy> might want to add as P actually
06:07:25 <lispy> I ran into a similar issue with exp recently
06:07:29 <lispy> :t exp
06:07:30 <lambdabot> forall a. (Floating a) => a -> a
06:12:23 <erus`> people tell me to prototype a compiler/interpretter in haskell first and then write it in something else
06:12:29 <erus`> why not just write it in haskell?
06:12:46 <Axman6> why not indeed
06:12:56 <Axman6> seems like far more work than in necessary
06:16:07 <erus`> im gonna write the next php
06:16:32 * hackagebot haskore 0.2.0.2 - The Haskore Computer Music System  http://hackage.haskell.org/package/haskore-0.2.0.2 (HenningThielemann)
06:20:08 <varnie> greetings. I have the simple question - when I supply a negative integer value to my function accepting "Int" it spits en error. how can I solve that?
06:20:40 <lispy> varnie: What does your function look like?
06:20:46 <Axman6> probably by wrapping it in brackets
06:20:48 <lispy> varnie: is it failing a pattern match?
06:20:49 <varnie> it looks like: myRepli::[a] -> Int -> [a]
06:20:51 <Axman6> > show -1
06:20:52 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
06:20:52 <lambdabot>    arising from the literal ...
06:20:54 <Axman6> > show (-1)
06:20:55 <lambdabot>   "-1"
06:21:06 <varnie> and here's its declaration I just wrote:
06:21:07 <varnie> myRepli x times
06:21:08 <varnie> 				| times < 0 = error "negative values don't supported"
06:21:08 <varnie> 				| otherwise = concat [x | i <- [1..times] ]
06:21:22 <varnie> it doesn't work when we'll try myRepli "abc" -1
06:21:24 <Axman6> s/don't/aren't
06:21:32 <Axman6> you need (-1)
06:21:34 <ski> varnie : `myRepli "abc" (-1)'
06:21:46 <lispy> varnie: You shouldn't use tabs in Haskell source
06:21:49 <varnie> and what about my func implementation, whether or not it is correct?
06:22:09 <lispy> varnie: http://urchin.earth.li/~ian/style/haskell.html
06:22:16 <varnie> Axman6, thanks for your corrections, I'll pay attention to them. (my mother language isn't English)
06:22:44 <Axman6> varnie: i figured that :) I hope i came across as being helpful, and not rude
06:22:56 <varnie> okay, I'll fix the layout.
06:23:42 <erus`> is '-' still a function when one does (-10) ?
06:24:01 <lispy> erus`: no
06:24:01 <Axman6> no
06:24:09 <Axman6> > (-5) 6
06:24:09 <lambdabot>   -5
06:24:13 <Axman6> heh
06:24:17 <Veinor> caleskell!
06:24:18 <lispy> bad example :)
06:24:22 <ski> erus` : yes
06:24:24 <Axman6> aye -_-
06:24:29 <ski> > let x = 10 in (- x)
06:24:30 <lambdabot>   -10
06:24:33 * Axman6 pokes Cale in the eye again
06:26:52 <erus`> can I inpack an array ?
06:26:56 <erus`> unpack*
06:27:13 <ski> meaning ?
06:27:21 <erus`> like > someFuncThatTakes3Args $ unpack some3ItemArrat
06:27:34 <merijn> The opposite of push is named pop, is there a name for the opposite of append?
06:27:57 <lispy> http://www.haskell.org/haskellwiki/Unary_minus
06:28:01 <opqdonut> merijn: prepend?
06:28:01 * ski thinks the opposite of "push" is "pull"
06:28:03 <erus`> merijn: init?
06:28:09 <lispy> So I guess unary minus is negate and we also have binary minus
06:28:10 <opqdonut> oh, nvm
06:28:11 <ski> merijn : `stripPrefix' ?
06:28:17 <lispy> And the parser picks between them
06:28:43 <ski> ("pop" being the operation which discards the top-level element of the stack)
06:28:45 <merijn> ski: Not haskell specific function, but in general data structure terms
06:28:58 <ski> merijn : that's what i was talking about, yes
06:29:23 <ski> @type stripPrefix
06:29:23 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe [a]
06:29:26 <merijn> ski: I don't think "stripPrefix" qualifies as a generic term for that :p
06:29:37 <ski> merijn : sorry, that was re "pull"
06:30:06 <ski> anyway, it wasn't clear if you wanted the converse of "append" or (left or right) inverse
06:31:16 <merijn> ski: To rephrase less ambiguously "Push is to append as pop is to..."
06:32:08 <ski> by "append", do you mean `(++ items)' or `(items ++)', for a given list of `items' ?
06:32:29 <merijn> The latter
06:32:55 <ski> (ok, i would call that "prepend" as in "prepend this list of items to the given list")
06:33:59 <merijn> Now I'm confused. "append [] a = [a]; append l a = l ++ [a]"
06:34:34 <merijn> Silly me thinking this would be a simple question :p
06:35:04 <Axman6> the first case is unnecessary isn't it?
06:35:20 <merijn> Axman6: I guess
06:35:22 <ski> there, i think `append l' is the function that *prepends* the list `l' to whatever list you pass as input
06:35:42 <Axman6> not really, you don't pass a list as input
06:35:46 <merijn> l :: [A], a :: A
06:36:14 <ski> merijn : yeah, my internal typechecker told me that
06:36:36 <ski> (so replace the input item with a singleton list)
06:36:48 <ski> my point : if you write `foo ++ bar', then `(++ bar)' is the function which *appends* `bar'
06:36:49 <merijn> I would say you append a to l, not prepend l to a. But I guess that's open to interpretation
06:37:15 <ski> while `(foo ++)', i.e. `(++) foo' is the function which *prepends* `foo'
06:37:42 <ski> to me "prepend" means to add something to the beginning/start
06:37:54 <ski> so "append" must then be to add to the end
06:38:17 <merijn> In a language without currying that distinction is useless, though
06:38:32 <ski> well, english has currying
06:39:28 <ski> if `foo ++ bar' is read as "given `foo', append `bar' to it", "append" works like a transitive verb, which together with a noun phrase on the right forms a verb phrase
06:39:50 <Peaker> never thought about natural languages having currying :)
06:40:18 <ski>   append :: VerbPhrase <- NounPhrase
06:40:20 <ski> where
06:40:23 <merijn> Anyhoo, ignoring the interesting semantic discussion for now, I'm still no closer to figuring out how to name this function :p
06:40:36 <ski>   type VerbPhrase = NounPhrase -> Sentence
06:40:37 <ski> so
06:40:49 <ski>   append :: (NounPhrase -> Sentence) <- NounPhrase
06:42:07 <ski> (where `A <- B' is the type of functions that when applied to an expression of type `B' on the right forms an expression of type `A'; while `A -> B' is the type of expressions that when applied to an expression of type `A' on the left forms an expression of type `B')
06:42:16 <ski> merijn : i'm not sure either
06:42:39 <ski> merijn : do you want this operation to take two lists; or a count of elements to remove, and a list ?
06:43:47 <ski> merijn : in the first case, i might call it "subtraction from the left" and write it as `foo >-> bar'
06:43:50 <merijn> ski: I'm just removing a single element from a list. i.e. using push/pop for adding/removing a single element at the front and append/?? for doing so at the end of the list
06:44:37 <Botje> you could use a variant of init
06:45:23 <varnie> is it possible to find index of some item from a list?
06:45:34 <ski> @type findIndex
06:45:35 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
06:45:39 <ski> @type findIndices
06:45:40 <lambdabot> forall a. (a -> Bool) -> [a] -> [Int]
06:45:48 <merijn> Botje: This isn't even haskell code, but since I mostly hang out here I just ask any generic CS questions here :p
06:46:11 <Botje> for lack of a better word, call it unappend :P
06:46:56 <benmachine> deppend
06:46:58 <benmachine> >_>
06:47:44 <hpc> lispy: sorry, afk for a bit; RE: importing id qualified, my point was that if i don't need to use the identity function, i can usually safely use 'id' as an identifier; the way it gets used in code is sufficiently obvious that it is never confused with identity
06:47:51 <ski> merijn : hm, i thought what you wanted was a list-analogoue of the single-element operation "pop" -- but now it sounds like you want an analogoue of "pop" that operates on the end of the sequence
06:48:24 <merijn> :w
06:48:41 * merijn pretends that is a weird new smiley
06:49:10 <benmachine> it's :v but sticking out its tongue
06:49:29 <ski> (merijn : so, which of those two do you want ?)
06:49:33 <lispy> hpc: ah
06:49:59 <merijn> ski: The latter, i.e. pop on the end of a sequence
06:50:52 <ski> merijn : the best i can think of are Botje's "init" suggestion, and "remove-last"
06:51:05 <benmachine> in python, push and pop operate on the end iirc
06:51:18 <benmachine> in perl the ones that operate on the beginning are called shift and unshift
06:51:43 <ski> benmachine : but is that single-linked lists, or arrays ?
06:51:44 <zygoloid> > let (remove-last) xs = init xs in (remove-last) [1,2,3,4,5]
06:51:45 <lambdabot>   [1,2,3,4]
06:51:52 <benmachine> ski: arrays probably
06:51:58 <benmachine> zygoloid: :P
06:51:59 <merijn> ski: Arrays
06:52:37 <benmachine> > let remove–last xs = init xs in remove–last [1,2,3]
06:52:38 <lambdabot>   <no location info>: Parse error in pattern
06:52:40 <benmachine> aw
06:52:55 <benmachine> > let (remove–last) xs = init xs in (remove–last) [1,2,3-2]
06:52:56 <lambdabot>   [1,2]
06:53:01 <hpc> they are "arrays"
06:53:08 <erus`> 	| isTwoPair cards /= Nothing = fromJust $ isTwoPair cards      -- This is one of my guards. is this bad? i feel like it is
06:53:25 <hpc> i assume perl and python use cleverer data structures than simple arrays, so the many primitive operations are as efficient as possible
06:53:27 <ski> erus` : `isJust' is better
06:53:35 <ski> erus` : pattern-matching is evenbetter
06:53:37 <frerich> byorgey : You got quoted in the popular german 'Spiegel' magazine.
06:54:36 <ski> erus` : using `isJust', you are not relying on havin an `(==)' (or `(/=)') on the contents of the `Maybe Foo'
06:54:54 <benmachine> erus`: can we see the rest of the function clause?
06:55:02 <erus`> yeah i will paste
06:55:15 <hpc> :t (~~)
06:55:16 <lambdabot> Not in scope: `~~'
06:55:26 <ski> erus` : using pattern-matching, you merge the `isJust' and `fromJust' into a single operation, which both human and computer readers can more readily see won't give an error at run-time
06:55:38 * hpc is sort of tempted to make a class for matching constructors
06:55:46 <hpaste> erus` pasted “make poker hand” at http://hpaste.org/47845
06:55:55 <hpc> (~~) :: Something a => a -> a -> Bool
06:56:18 <erus`> hpaste just posted the rest of the function
06:56:23 <hpc> Nothing ~~ Nothing = True, Just{} ~~ Just{} = True, _ ~~ _ = False
06:57:19 <ski> erus` : how is `isTwoPair' defined ?
06:57:26 <erus`> ski: i havnt written it yet
06:57:38 <ski> ok, what is the intended semantics of it, then ?
06:57:48 <erus`> check if a hand has a pair
06:58:04 <erus`> and return a (Maybe Hand)
06:58:19 <hpc> so isTwoPair :: Hand -> Maybe Hand?
06:58:31 <ski> erus` : instead of `5 /= length cards', and later `sorted!!0',`sorted!!1',&c. you should just match on a list with five elements
06:58:34 <hpc> and if it doesn't have a pair, returns Nothing
06:58:45 <hpc> if it does have a pair, returns Just (the parameter)
06:58:48 <hpc> ??
06:58:52 <Saizan> hpc: :: [Card] -> Maybe Hand
06:58:56 <hpc> ah
06:59:26 <hpc> oh, there's a paste
07:00:00 <erus`> i dont like it because im calling the function twice
07:00:05 <Saizan> = msum [isRoyalFlush cards, ... , isTwoPair cards , Just $ HighCard ...]
07:00:11 <erus`> but that might be a fear i have learned from C
07:00:19 <ski> erus` : hm, well ok `sorted' is not the same variable as `cards', but you should still match `sorted' on a list of five elements, since you know it will have that length
07:00:33 <ski> erus` : you don't like *what* ?
07:00:52 <sshc> I wonder what the most portable way to define a polymorphic definition that returns the number of arguments of a function is
07:00:55 <benmachine> hpc: Data can match constructors
07:01:00 <benmachine> (but may be overkill)
07:01:20 <erus`> ski: calling a function in the guard then calling it again in the body
07:01:26 <ski> sshc, what is the number of arguments of `foldr' ?
07:01:43 <hpc> benmachine: extraordinary overkill :P
07:01:52 <ski> erus` : you can avoid what by giving a name to the repeated expression, in your `where'
07:02:22 <ski> erus` : but it is even better to pattern-match on `isTwoPair cards'
07:02:42 <hpc> ski: there's a useful inductive definition of "number of arguments"
07:02:43 <benmachine> erus`: is it necessarily sensible to represent your cards as a list of cards here? if it always has exactly five elements, can't you just give those five cards as parameters?
07:02:49 <benmachine> or make an ADT with five fields?
07:03:02 <erus`> good point
07:03:18 <hpc> ski: let numargs (a -> b) = 1 + numargs b
07:03:18 <benmachine> erus`: just a thought :)
07:03:24 <ski> (or use a quintuple)
07:03:24 <xplat> sshc: how many arguments does '.' have?
07:03:29 <hpc> if we can't match against (a -> b), it has zero args
07:03:43 <benmachine> hpc: but you can give as many arguments as you like to id
07:03:59 <ski> hpc : so `foldr' has infinitely many arguments, then ?
07:04:07 <hpc> :t foldr
07:04:08 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:04:11 <benmachine> > id id id id id id id id id id id id id id id
07:04:12 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
07:04:12 <lambdabot>    arising from a use of `...
07:04:15 <benmachine> oh um
07:04:17 <benmachine> > id id id id id id id id id id id id id id id ()
07:04:18 <lambdabot>   ()
07:04:27 <ski> hpc : you can match the final `b' with `a0 -> b0', then you can match `b0' with `a1 -> b1', &c.
07:04:49 <benmachine> ski: maybe you only define numargs for monomorphic functions?
07:04:51 <xplat> the only thing you can say about a polymorphic function is that it has a certain minimum number of arguments before it could possibly become a nonfunction
07:04:55 <benmachine> *monomorphic types
07:05:01 <monochrom> @type id id id
07:05:02 <lambdabot> forall a. a -> a
07:05:21 <hpc> what benmachine said
07:05:22 <ski> benmachine : so not defined for `map', then ?
07:05:22 <ski> @type map
07:05:23 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:05:36 <hpc> instead of id :: a -> a, you can pass id :: (() -> ()) -> () -> ()
07:05:46 <lunaris> sshc: Perhaps stupid, but this is valid Haskell 98:
07:05:54 <hpc> or map :: (() -> ()) -> [()] -> [()]
07:06:03 <xplat> but a lot of functions are polymorphic.  for example, (+)
07:06:06 <ski> xplat : in general, yes. not for `map', though
07:06:10 <benmachine> anyway, as everyone knows, numArgs :: (a -> b) -> Integer; numArgs = const 1
07:06:13 <benmachine> :P
07:06:14 <hpaste> lunaris pasted “Counting arguments” at http://hpaste.org/47846
07:06:40 <lunaris> But you have to compose with Result so that it has a clue what it's doing.
07:06:40 <hpc> in any event, numargs is like length, folding in reverse, on an (x -> y) list, instead of a (y:x) list
07:06:47 <hpc> er, (x:y) list
07:06:52 <lunaris> e.g. count (Result . length) == 1
07:06:56 <xplat> ski: okay, i should in particular say 'a type with a variable at the end of its right spine of ->s'
07:06:59 <lunaris> Or count ((Result .) . lookup) == 2
07:07:17 <benmachine> lunaris: that's kind of silly; you're encoding the argument count in how you compose the function with Result
07:07:23 <ski>   data ArgumentCount = Zero | Succ ArgumentCount | Arbitrary
07:07:34 <lunaris> benmachine: Thanks for the criticism.
07:07:36 <lunaris> :)
07:07:56 * ski suspects hpc meant that by "useful inductive definition"
07:07:56 <lunaris> Like I said, stupid.
07:07:58 <hpc> ski: data ArgumentCount = Exactly Nat | AtLeast Nat
07:08:04 <benmachine> lunaris: fair enough :P
07:08:05 <lunaris> But I do love type class tricks.
07:08:09 <ski> hpc : yeah, same thing.
07:08:11 <hpc> ski: yeah, close enough
07:08:17 * benmachine wonders if the printf trick is relevant here
07:08:24 <hpc> benmachine: probably
07:08:39 <lunaris> benmachine: That's what I was doing, effectively.
07:08:51 <lunaris> The Result newtype could be alleviated by writing instances for Int, String, Char etc.
07:08:57 <benmachine> ah
07:09:00 <lunaris> Which is essentially what printf and friends do.
07:09:01 <hpc> ski: by "useful" i really just meant not (everything is zero arguments || everything is one argument)
07:09:05 <hpc> :P
07:09:05 <benmachine> yes I suppose that makes sense
07:09:17 <ski> (hpc : i actually have used that type, as the type which you get if you freeze a potentially partially instantiated natural number, in my logic programming embedding in Haskell)
07:09:21 <lunaris> It's just another way of dodging the fact that instance C a encompasses all inductive instances too (damn you type variables!)
07:10:24 <xplat> but you can never find this out by type reflection because type reflection can't encode the 'function/not a function' distinction.  unless you use overlapping instances and probably every other evil typeclass instancing extension in the book.
07:11:25 <ski> anyway, how are you going to *use* this "number of argument" information, *in* your program ?
07:11:27 <xplat> and you probably don't actually want to do that.  they're considered evil for a reason.
07:11:48 <ski> where would it be useful to call `numArgs' ?
07:12:31 <ski> (and calling it just to print the result out to the user doesn't count)
07:13:28 <monochrom> what? 7.0.4 already!
07:14:29 <hpc> ski: it might be useful theoretical knowledge for designing DSLs
07:15:31 <Saizan> xplat: oh, it's not that evil! but polymorphic result types make it not so practical
07:16:34 <Saizan> ski: if the length is expressed as a gadt it's somewhat useful :) http://code.haskell.org/~Saizan/Uncurry.hs
07:17:52 <erus`> haskell is a joy sometimes
07:18:02 <xplat> Saizan: i meant things like OverlappingInstances that you would need to write numArgs.  not so much numArgs itself, although the version you can write is because it returns a subtly wrong answer.
07:19:02 <xplat> (well, or at the very least it returns an answer that doesn't mean what you would think and depends on the context where you call it)
07:19:53 <ski> erus` : so, have you removed the use of `fromJust' and `(!!)', yet ?
07:20:18 <erus`> yeah
07:20:36 <erus`> ooo i will pattern match instead of fromJust
07:20:49 <Saizan> xplat: so you think that returning 2 for (id :: (Int -> Int) -> Int -> Int) is wrong?
07:21:16 <erus`> ski: can I do that in a gaurd?
07:21:43 <ski> erus` : well, you *can* .. but i would probably use a `case' (or a helper function), instead
07:22:31 <ski> > let f m | Just x <- m = x | otherwise = 0 in map f [Just 2,Nothing,Just 3]
07:22:32 <lambdabot>   [2,0,3]
07:22:35 <hpaste> erus` pasted “updated makeHand” at http://hpaste.org/47847
07:23:16 <ski> erus` : next time, annotate the original paste with updates
07:23:33 <erus`> ah ok
07:23:46 <benmachine> ski: this does actually look like a reasonable use case for pattern guards imo
07:24:34 <ski> erus` : as i said before, `foo /= Nothing' is better written as `isJust foo'
07:25:19 <erus`> but you said dont use fromJust either
07:25:45 <ski> i said that instead of checking a boolean `isJust foo', and then extracting the component with `fromJust foo'
07:26:14 <ski> you just match `foo' on a pattern `Just x', so if that match succeeds, `x' is the component to use in place of `fromJust foo'
07:26:32 <erus`> wont it throw an exception?
07:26:37 <hpc> case foo of (Just x) -> x; Nothing -> therestoftheblahblah
07:26:40 <xplat> Saizan: the problem is that it will always return the minimum bound for a polytype, and the minimum bound depends on how much is known about the type of the argument when numArgs is called
07:26:47 <ski> you can either do a `case foo of Just x -> ..x..; Nothing -> ...'
07:27:12 <ski> or you can use a pattern-guard, i.e. `| Just x <- foo  = ..x..'
07:27:25 <ski> if the match fails, it will just try the next guard, then
07:28:42 <Saizan> xplat: or you can make it require a the result type to be monomorphic enough
07:28:53 <Saizan> s/a//
07:29:04 <ski> xplat : hm, you could code a version of `numArgs' in lambdaProlog, which handles polymorphic types
07:29:39 <ski> (because you can match on expressions with bound variables in them, in lambdaProlog)
07:30:06 <ski> erus` : all clear ?
07:31:38 <xplat> Saizan: how do you write the base case for such a numArgs?  find all the types in your program other than (->) and write cases for them to return 0?
07:31:45 <erus`> | Just x <- foo = ..x..
07:31:51 <erus`> how does that work
07:32:14 <ski> this is a pattern guard that will try to match the expression `foo' with the pattern `Just x'
07:32:31 <benmachine> erus`: you might not have seen it in tutorials because it's quite a recent feature
07:32:37 <ski> if the match succeeds, `x' gets a value, this guard is committed to, and `..x..' is evaluated
07:32:47 <ski> if the match fails, the next guard (or equation) is tried
07:33:01 <Saizan> xplat: no, you use OverlappingInstances to write an IsFunction t bool typeclass
07:33:24 <xplat> Saizan: then you can't require the result type to be monomorphic
07:34:06 <Saizan> xplat: sure you can, a IsFunction t bool context won't be discharged until you can tell for sure if t is a function type or not
07:34:26 <xplat> there's no instance you can write, even with OverlappingInstances, that matches all type constructors except for (->) but doesn't match a bare variable
07:34:41 <Saizan> no single one
07:34:49 <Saizan> but a pair of them have exactly that effect :)
07:34:57 <xplat> which pair?
07:35:13 <Saizan> class IsFunction t b | t -> b
07:35:13 <Saizan> instance (b ~ HTrue) => IsFunction (a -> c) b
07:35:13 <Saizan> instance (b ~ HFalse) => IsFunction a b
07:36:12 <Saizan> you must not turn on IncoherentInstances though
07:36:22 <xplat> er.  okay, maybe i reckoned without the new kind of constraint that came with GADTs.  i can't honestly tell if that would work or not.
07:36:54 <Saizan> before TypeFamilies there was the TypeCast hack
07:39:04 <edwardk1> yeah its a bit tricky to get work now
07:39:53 <erus`> ski: can you point me to some docs for that patternmatching in guards please
07:40:30 <copumpkin> omg an edwardk
07:40:38 <edwardk> heya
07:40:57 <edwardk> btw- you're famous. i've been touting your agda category theory lib all week
07:41:03 <copumpkin> oh yay!
07:41:04 <copumpkin> thanks
07:41:13 <tgeeky>  /internet/ famous, even
07:41:17 <copumpkin> lol
07:41:23 <edwardk> internationally famous.
07:41:30 <edwardk> i was actually touting it in person ;)
07:41:36 <tgeeky>  /inter/[net,nationally] famous.
07:42:08 <ski> erus` : GHC User's Guide - 7.3.Syntactic extensions - 7.3.5.Pattern guards <http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#pattern-guards>
07:42:09 <copumpkin> edwardk: did anyone know agda there?
07:42:44 <benmachine> internetionally
07:42:49 <benmachine> how is that not a word
07:42:52 <benmachine> it is now
07:42:55 <tgeeky> benmachine: defined!
07:42:56 <tgeeky> lol
07:42:59 <edwardk> yes. jacques carette was here
07:43:12 <tgeeky> though I suppose it's implicit, unless you're in a dictatorship
07:43:28 <edwardk> we've been talking tiny theories for a couple of days now. its been pretty good. he has basically the same class breakout as kata in a little language of his own
07:43:41 <benmachine> aw, internetional already has google results
07:43:45 * benmachine denied neologism
07:46:33 <erus`> > 1 == 1 == 1
07:46:34 <lambdabot>   Precedence parsing error
07:46:34 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
07:46:50 <erus`> tut tut
07:46:53 <erus`> C++ can do that
07:47:10 <benmachine> erus`: does it get it right?
07:47:16 <mauke> no
07:47:16 <benmachine> what do you get for 0 == 0 == 0?
07:47:26 <mauke> false
07:47:51 <benmachine> mauke: could you overload operator== to return some weird object such that it did work?
07:48:05 <mauke> not in this case
07:48:07 <benmachine> (not that you'd want to but :P)
07:48:09 <mauke> 0 :: int
07:48:10 <saati> erus`: only
07:48:14 <xplat> not the standard one from Eq
07:48:21 <parcs> yeah it can
07:48:31 <parcs> if you create Num instance for Bool
07:48:41 <saati> so c++ can do that because it can't differentiate booleans from integers
07:49:02 <benmachine> parcs: what could possibly go wrong
07:49:02 <ben> it can, it just doesn't want to
07:49:06 <benmachine> ben: quite :P
07:49:15 <xplat> oh, i guess that depends what you mean by 'work'
07:49:41 <benmachine> (although + being || and * being && kinda make sense... not much you can do about abs/negate though)
07:50:10 <parcs> negate is not
07:50:22 <xplat> + should be xor, negate and abs should be id
07:50:30 <xplat> * should be &&
07:50:31 <mauke> Perl doesn't really care about your types but it thinks 0 == 0 == 0 is a syntax error
07:50:32 <monochrom> c++, set theory, and untyped lambda calculus can't differentiate booleans from integers :)
07:50:56 <benmachine> xplat: I suppose that works
07:51:03 <benmachine> signum = const 1?
07:51:18 <parcs> @src Num
07:51:19 <lambdabot> class  (Eq a, Show a) => Num a  where
07:51:19 <lambdabot>     (+), (-), (*)           :: a -> a -> a
07:51:19 <lambdabot>     negate, abs, signum     :: a -> a
07:51:19 <lambdabot>     fromInteger             :: Integer -> a
07:51:30 <benmachine> fromInteger = (/= 0)
07:51:41 <ben> (-) = (+)?
07:51:54 <benmachine> ben: you use the default definition, so yes
07:52:09 <benmachine> (because negate = id)
07:52:10 <xplat> benmachine: signum = id also
07:52:20 <benmachine> xplat: oh, yes, that also works
07:52:40 <xplat> fromInteger = odd
07:52:58 <ben> hm
07:53:15 <hpc> perhaps negate = not
07:53:34 <benmachine> hpc: but negate is supposed to produce an additive inverse
07:53:39 <hpc> x - y = x + not y
07:53:48 <hpc> ah
07:53:56 <benmachine> hpc: that's how I interpret it anyway
07:54:09 <benmachine> I don't think there are formal laws for Num
07:54:12 <hpc> imo, not is better than id
07:54:21 <benmachine> but imo a - a = 0 should be true
07:54:23 <hpc> it gives you SOMETHING to do with it
07:54:34 <hpc> benmachine: ah, good point
07:55:11 <hpc> (-) = xor?
07:55:26 <benmachine> (-) = (+) = xor
07:55:27 <benmachine> :P
07:55:31 <hpc> :P
07:55:43 <benmachine> you are effectively forming the group Z/2Z
07:55:47 <benmachine> the ring
07:55:57 <erus`> how can i get the next enum in an enum?
07:56:04 <benmachine> erus`: succ?
07:56:10 <benmachine> > succ 'x'
07:56:11 <lambdabot>   'y'
07:56:15 <xplat> then not = (1-)
07:56:15 <erus`> perfect
07:56:50 <xplat> and (||) = (*) `on` (1-)
07:57:06 <benmachine> xplat: 1 - that, surely?
07:57:18 <xplat> benmachine: er, yes, that was nor :)
07:59:15 <benmachine> there are several packages on hackage for static blogs
07:59:32 <benmachine> anyone know of ones that are non-static? (i.e. support comments)
07:59:34 <benmachine> preferably CGI
07:59:51 <benmachine> hmm, bamboo might but it looks scary
07:59:52 <hpc> benmachine: Network.CGI is included in the platform, iirc?
07:59:53 <benmachine> any others?
07:59:55 <xplat> any WAI ones can be run as CGI
08:00:08 <hpc> (i remember it being kind of shitty though
08:00:20 <benmachine> hpc: ...yes? I can write CGI apps but I want someone to have done it for me :P
08:00:38 <hpc> ah
08:01:14 <hpc> i made one for my site (http://hpc.dyndns-web.com:8000/) but it sucks
08:01:39 <parcs> you should probably just use disqus
08:01:55 <parcs> (with a static blog)
08:02:01 <benmachine> parcs: I considered it but I dunno
08:02:13 <benmachine> it seemed slightly overengineered, not open-source, and not haskell :P
08:02:17 <hpc> disqus is terrible; comment systems shouldn't require javascript
08:02:22 <benmachine> that too
08:02:37 <hpc> and they definitely shouldn't require third-party javascript
08:02:43 <benmachine> or third-party cookies
08:03:05 <hpc> i can't count the number of sites i avoid just because i can't read the comments without allowing disqus.com scripts
08:08:39 <ezyang> If I'm doing profiling, and it seems on successive runs GHC picks a random function to assign 100% runtime to, what does that mean?
08:09:24 <c_wraith> how long is the total execution time?
08:09:58 <c_wraith> the profiler is sample-driven.  I could see that behavior if only one sample is ever taken.
08:10:38 <ezyang> pretty fast.
08:10:41 <ezyang> hmm'kay.
08:10:58 <c_wraith> You can change the sampling frequency, I believe
08:11:06 <c_wraith> (don't ask me what the option is)
08:11:36 <ezyang> I thought that was for space profiling...
08:12:04 <monochrom> all sampling schemes enjoy the Nyquist limitation :)
08:16:22 <iskren> I cannot solve my type problem :( I have a function A that operates on a specific type AT. I also have a function B that operates on BT, but otherwise the functions A and B are the same. So they both call a function C that can operate on any type (both AT and BT) (the function C is passed to A and B). How do I put these two functions in an array :)
08:16:49 <mauke> you don't
08:16:53 <iskren> The idea is that the function C can vary based on user input. And the functions A and B can also vary (I have several implementations)
08:16:55 <mauke> how would that make sense?
08:17:20 <iskren> mauke, do you want me to explain in detail the setup?
08:18:47 <sm> iskren: one way is to use a typeclass. Make A and B instances of it, and C accept it
08:19:01 <iskren> sm, I already did this
08:19:33 <sm> oh, I missed the last part
08:19:34 <iskren> the problem comes when I want to basically have an index on both the functions implementing C and the functions implementing A
08:19:51 <ski> iskren : if you really want to put `A' and `B' together in a collection, you can use existentials
08:19:52 <iskren> so the user says I want 2nd implementation of this and 3rd implementation of that
08:20:05 <iskren> but I can really type the type :)
08:20:13 <ski> iskren : but i think we need to look at your code to tell better
08:20:14 <iskren> cant**
08:20:14 <erus`> is there a function to check if all elements in a list are equal?
08:20:33 <erus`> in the platform
08:20:59 <erus`> @hoogle [] -> Bool
08:20:59 <lambdabot> Did you mean: [a] -> Bool /count=20
08:20:59 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
08:21:00 <lambdabot> Network.BufferType buf_isEmpty :: BufferOp a -> a -> Bool
08:21:10 <iskren> erus`, the function the is the closest you can get
08:21:13 <sm> erus`: I don't think so
08:21:30 <iskren> it crashes if the elements are not all the same :)
08:21:47 <ski> erus` : you can use `\xs -> and (zipWith (==) xs (tail xs))'
08:21:48 <siracusa> :t group
08:21:49 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
08:21:58 <lunaris> erus`: f xs = and $ zipWith (==) xs (tail xs)
08:22:02 <lunaris> Ah damn you ski.
08:22:15 * ski blesses lunaris
08:22:33 <sm> all ((==) (head l)) l  ?
08:22:51 <ski> sm : works. except not for the empty list
08:23:16 <lunaris> :t and . (zipWith (==) <$> id <*> tail)
08:23:17 <lambdabot> forall a. (Eq a) => [a] -> Bool
08:23:22 <lunaris> Looks right.
08:23:28 <lunaris> (?)
08:23:29 <sm> ski: the empty list works too (laziness)
08:23:40 <sm> same l = all ((==) (head l)) l
08:23:46 <ski> sm : oh, you're right
08:23:58 <ski> @type and . (zipWith (==) `ap` tail)
08:23:59 <lambdabot> forall a. (Eq a) => [a] -> Bool
08:24:12 * lunaris blesses ski
08:24:37 <ski> @type (<$> id)
08:24:37 <lambdabot> forall a b. (a -> b) -> a -> b
08:25:19 <ski> (sm : and it works for the same reason the `tail xs' isn't forced in my version ..)
08:26:12 <HalfWayMan> erus`: (== 1) . length . nub   ;)
08:27:31 <lunaris> Ignoring the empty list: null . tail . nub
08:27:33 <test123978456> hi
08:27:34 <lunaris> I'll stop now.
08:27:53 <test123978456> how can i enable flags in haskell? Interpeter said that i should enable -XNamedFieldPuns
08:27:58 <test123978456> and i don't know how
08:28:05 <lunaris> {-# LANGUAGE NamedFieldPuns #-}
08:28:11 <lunaris> At the top of your .hs file
08:28:19 <lunaris> Or ghci -XNamedFieldPuns MyFile.hs
08:28:33 <test123978456> thanks a lot ;)
08:28:38 <lunaris> No worries.
08:28:56 <ski> test123978456 : or `:set -XNamedFieldPuns' inside GHCi ..
08:29:08 <lunaris> http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/ghc-language-features.html#options-language for more information
08:29:36 <ski> (lunaris : note that  foo `ap` bar  is basically the same as  foo <*> bar  )
08:29:36 * lunaris cries out in anguish as ski continues to 1up.
08:29:38 <test123978456> ok, thanks so much ;)
08:29:55 <lunaris> ski: Yea, I know; I write first and typecheck/optimise later
08:29:57 <lunaris> ski: Or never.
08:30:00 <lunaris> *sigh*
08:30:17 * ski is reminded of the old Platform shooter games Turrican
08:30:48 * int-e reads "platform" and thinks of something quite different ... why would one shoot it? :)
08:31:12 <iskren> ook, so here is the repo: http://ripc:8112/file/tip . You can have a look into Main.hs to get an idea of what I want to "automate" (by putting in array or similar)
08:31:30 <iskren> http://iskren.info:8112/file/tip << sorry
08:33:40 <ski> iskren : the commented out lines ? or the expressions of code actually in `main' ?
08:34:12 <iskren> well you can see the difference in the commented lines
08:34:24 <iskren> the idea is that there are 3 "analysis" (the qualified imports)
08:34:41 <iskren> and 3 "fixpoint algorithms" -- RoundRobin, Worklist, Recursive
08:35:26 <iskren> all analysis export a function "performAnalysis" that needs a fixpoint algorithm, (a program) and returns a "state" -- that is the result of the analysis
08:36:03 * democracy ***GENERAL STRIKE 6/15, 6/22, 6/29/11***SOLIDARITY***
08:36:04 <iskren> this "state" is member of StateCls (this may not be commited yet) and can be printed (with a function pretty)
08:36:07 <ski> (fyi, plural of "analysis" is "analyses")
08:36:31 <iskren> ski, thanks, I'll fix that :)
08:37:22 <DukeDave> Is there anyone in here who know how Haskell libraries make there way into the Ubuntu repos?
08:37:42 <iskren> so the user can specify which analysis he wants and which algorithm and I want to "combine" these 2 functions and print the result basically
08:37:53 <ski> iskren : what is the respective types of the `performAnalysis' functions ?
08:38:02 <DukeDave> I rather fancied getting my hands on haskell-utility-ht, but it isn't available :(
08:38:09 <DukeDave> https://launchpad.net/ubuntu/+source/haskell-utility-ht
08:38:44 <iskren> ski, performAnalysis :: (FixPointAlgorithm CarrierAE) -> Program -> StateAE  ---
08:39:03 <iskren> CarrierAE and StateAE are specific to AvailableExpression analysis, the other analysis have their own types
08:39:40 <iskren> but the Carrier is the main type, the state is just (State carrier) (this is another type)
08:39:46 <ski> iskren : and how is the "fixpoint algorithms" specified ? as one or another constructor of a type `data Foo = RoundRobin | Worklist | Recursive' ? or by passing one of three already constructed algorithm values, of some type, which type ?
08:39:47 <osfameron> DukeDave: probably an ubuntu staffer/volunteer creates/maintains the packages.  Perhaps you're better off asking on #ubuntu or one of their forums?
08:40:36 <ski> iskren : that's the type of one of the `performAnalysis's, what is the types of the others ?
08:40:47 <iskren> ski, there is a string in the input file :) but the important point is how can I put all fixpointalgs in an array that I can index
08:41:18 <DukeDave> osfameron: Thanks, I'm just trying to get my foot in the door, but I don't want to pester anyone :)
08:41:22 <iskren> performAnalysis :: (FixPointAlgorithm CarrierTLV) -> Program -> StateTLV <-- this is for the 2nd analysis
08:41:30 <ski> iskren : do you want to put the three `performAnalysis' functions in a single array ?
08:41:48 <iskren> performAnalysis :: (FixPointAlgorithm CarrierIA) -> Program -> StateIA <-- this is the last analysis
08:41:50 <ski> iskren : or do you want to put the three "fixpoint algorithms" in a single array ?
08:41:53 <osfameron> DukeDave: http://packages.ubuntu.com/oneiric/haskell/ links to various packages of which http://packages.ubuntu.com/oneiric/haskell/ghc suggests that the current maintain is "Ubuntu Developers" i.e. the mailing list
08:41:56 <ski> iskren : or maybe both of those ?
08:42:03 <iskren> ski, ideally both
08:42:11 <iskren> ski, by array I mean:
08:42:29 <iskren> [("RoundRobin", roundRobin), ("Worklist", worklist), ...]
08:42:38 <iskren> so given the name I can fetch the algorithm
08:42:39 * ski assumes "array" here means some kind of collection, probably a finite map of some kind
08:42:54 <iskren> well, I'll use lookup
08:43:24 <ski> iskren : what is the type of `roundRobin', and `worklist', (and one more ?) ?
08:43:32 <iskren> recursive
08:43:53 <iskren> type {- Carrier c => -} FixPointAlgorithm c = (Analysis c) -> Program -> (State c) -> (State c)
08:43:54 <NemesisD> hi all. i'm trying to figure out an algorithm: distributions :: [Bucket] -> [Thing] -> [[(Bucket, [Thing])]], it generates all the possible ways the entire list of things can be distributed out to the buckets. i wrote a similar algorithm a little while ago except it allows for the possibility that < 100% of the list of things is distributed
08:44:23 <iskren> it gets an analysis, a program and a initial state and returns the final state
08:44:28 <NemesisD> is there anything not so obvious that i'm missing that could help me out, perhaps with the list as a monad?
08:44:39 <iskren> the point here is that it works for all "c" (for all Carriers)
08:44:57 <DukeDave> osfameron: Hmm, I guess I'll just create a bug on the package, at least that is non-invasive and traceable. Thanks.
08:45:25 <ski> iskren : btw, s/(Analysis c)/Analysis c/, s/(State c)/State c/ .. you don't need the brackets there
08:45:47 <osfameron> DukeDave: that looks like it's the correct protocol yeah.  If no joy, it looks like https://wiki.ubuntu.com/MOTU/Teams/UncommonProgrammingLanguages/Haskell has some contact details
08:45:53 <lunaris> I'm interjecting randomly here, but is this not the place for a GADT?
08:45:56 <iskren> ski, this is my first (real) haskell project, and I had bad luck with missing brackets ;-)
08:46:24 <lunaris> data Algorithm where Algorithm :: Carrier c => FixPointAlgorithm c -> Algorithm
08:46:39 <lunaris> analyses :: [(String, Algorithm)]
08:48:19 <iskren> lunaris, I don't quite understand this type :)
08:48:48 <iskren> this is like a class (because it has functions), but a data?
08:49:09 <ski> it's not like a class at all
08:49:11 <benmachine> NemesisD: does sound like a job for the list monad, yes
08:49:15 <ski> another way to write it is
08:49:31 <benmachine> or possibly a list comprehension
08:49:42 <ski>   data Algorithm = forall c. Carrier c => Algorithm (FixPointAlgorithm c)
08:50:16 <NemesisD> benmachine: yeah i'm trying the lc route right now but my brain keeps steering me to the previous solution i came up
08:50:19 <NemesisD> with*
08:50:23 <benmachine> heh
08:50:38 <iskren> ski, ok this looks better. What about the "performAnalysis" function
08:50:56 <ski> iskren : so `roundRobin,worklist :: Carrier c => FixPointAlgorithm c' ?
08:51:06 <iskren> because I managed putting the fixpoint algorithms in one array by adding a bunch of "extensions" to the compiler
08:51:32 <iskren> ski, yes, but they don't care about the c, as long as it is Carrier
08:51:38 <iskren> (they just pass it around)
08:51:39 <ski> iskren : btw, what lunaris suggested is known as an "existential data type" (i just mentioned another way to write the same type definition)
08:51:58 <ski> iskren : so e.g. `roundRobin' works for *any* carrier `c', then ?
08:52:06 <iskren> ski, exactly
08:52:20 <iskren> ski, as opposed to the individual analyses, that work with one specific carrier
08:52:38 <ski> (as opposed to `roundRobin' wanting to work with a *particular* carrier `c', while `worklist' wants (possibly) *another* particular carrier `c')
08:52:41 <iskren> like the available expressions carrier or the interval analysis carrier
08:52:43 <ski> yes
08:53:04 <ski> iskren : so, all your fixpoint algorithms works with every carrier ?
08:53:16 <iskren> ski, yes
08:53:26 <ski> so
08:53:27 <iskren> the algorithms can be freely interchanged
08:53:49 <iskren> but the analyses require specific type (their type)
08:53:51 <ski> [("RoundRobin", roundRobin), ("Worklist", worklist), ...]  ::  [(String,forall c. Carrier c => FixPointAlgorithm c)]
08:54:08 <iskren> ski, yes. That would work :)
08:54:24 <ski> but i think this direct syntax will not work anymore, since they removed impredicativity
08:54:36 <iskren> I used this flag already
08:54:37 <ski> you can instead encode `forall c. Carrier c => FixPointAlgorithm c' into a new datatype
08:54:57 <ski> (or does impredicativity still work ?)
08:55:10 <ski> anyway, if you want/need to wrap, you can define
08:55:15 <iskren> ski -- you mean this: data Algorithm = forall c. Carrier c => Algorithm (FixPointAlgorithm c)
08:55:21 <ski> no
08:55:23 <ski> i mean
08:55:27 <iskren> but this is a wrap...
08:55:46 <ski>   data GenericFixPointAlgorithm = GFPA (forall c. Carrier c => FixPointAlgorithm c)
08:55:54 <ski> this is very different from
08:56:08 <ski>   data SomeFixPointAlgorithm = forall c. Carrier c => SFPA (FixPointAlgorithm c)
08:56:15 <iskren> hihihi ... I guess I'm completely lost in the typesystem then :)
08:56:22 <ski> (which is just a renaming of lunaris' `Algorithm' type)
08:56:49 <DukeDave> osfameron: Well, bug is on, I'm not sure if it's related to the GHC 6.12 transition" mentioned on the page you linked.
08:57:16 <iskren> ski, and now I can use the Generic thing for the array type
08:57:22 <ski> iskren : use `SomeFixPointAlgorithm' when you have algorithms like `roundRobin' that only works for particular carriers, but you still want to put several such with different carriers in the same list/array/whatever
08:57:26 <gwern> so, with 'getArgs', how are quotes handled? eg if I do './foo bar baz "quux man"', and getArgs gives me (a:b:c:_), is c="quux" or c="quux man"?
08:57:48 <ski> iskren : in your case, you had generic algorithms, so i think you want `GenericFixPointAlgorithm' instead
08:57:56 <iskren> all algorithms (roundrobin, worklist, recursive) work with all carriers, so they are all generic
08:58:26 <ski> gwern : it ought to be the latter, but i don't remember which it is
08:58:35 <iskren> but I should use this GenericFixPointAlgorithm whenever I want to create the structure, not where the algorithms are defined
08:59:10 <ski> iskren : yes, you use it when you want to put generic algorithms into some data structure, without having to decide at this point which carrier to use
08:59:39 <ski> iskren : that way, when you unwrap the `GenericFixPointAlgorithm' later, you can at *that* point (or later still, if you want) decide which carrier to use
09:00:08 <ski> ok ?
09:00:09 <dixie> Do you anybody have good exapmle how ot use bytestring with parsec3? I can not find "string" parser which work with bytestring :-(
09:00:51 <benmachine> dixie: what do you mean by "string" parser?
09:01:10 <c_wraith> he means the function "string"
09:02:54 <ski> iskren : btw, to define `GenericFixPointAlgorithm' you'll need the `PolymorphicComponents' language extension
09:02:58 <iskren> ski, I'm trying to compile it now, but I have other issues :)
09:03:32 <ski> (but if you already have `Rank2Types' or `RankNTypes', then that suffices)
09:04:33 <iskren> ski, yep, I had that
09:04:42 <benmachine> looks to me like 'string' ought to work with ByteString
09:04:45 <iskren> so what about the analyses
09:04:45 <ski> iskren : anyway, you wanted to put the `performAnalysis' functions into a list/array -- and *here* the issue is different
09:05:07 <ski> iskren : the analyses aren't generic, they each onyl work with a particular carrier
09:05:08 <iskren> yes, because each analysis has fixed carrier
09:05:19 <ski> iskren : so *here* you want to use an "existential data type"
09:05:29 <ski> iskren : i.e. you want to have
09:05:35 <iskren> but the returned (State carrier) is of class StateCls and can be "pretty"-ed (to string)
09:06:47 <ski>   [TrulyLiveVariables.performAnalysis,AvailableExpressions.performAnalysis,IntervalAnalysis.performAnalysis] :: [exists c. Carrier c *> FixPointAlgorithm c -> Program -> State c]
09:06:50 <ski> or something like that
09:07:25 <iskren> ski, this is nice :)
09:07:29 <ski> iskren : yes, you could convert `State c' to a `String', which doesn't mention `c' anymore, but that doesn't help with the `FixPointAlgorithm c' argument
09:07:42 <ski> now
09:07:44 <ski>   [exists c. Carrier c *> FixPointAlgorithm c -> Program -> State c]
09:08:06 <ski> is pseudo-code, not actual Haskell (maybe it works in LHC compiler, i'm not sure)
09:08:21 <ski> in GHC, you have to make a new datatype containing `exists c. Carrier c *> FixPointAlgorithm c -> Program -> State c'
09:08:29 <ski> (and in Hugs as well)
09:08:31 <gwern> @pl runCommand x >> return ()
09:08:32 <lambdabot> runCommand x >> return ()
09:08:38 <gwern> @pl foo x = runCommand x >> return ()
09:08:39 <lambdabot> foo = (>> return ()) . runCommand
09:08:58 <ski> and the way to do that is to define it like
09:09:32 <ski>   data SomePerformAnalysis = forall c. Carrier c => WrapPerformAnalysis (FixPointAlgorithm c -> Program -> State c)
09:09:41 <ski> or, if you prefer, there's an alternative syntax
09:09:47 <ski>   data SomePerformAnalysis
09:09:48 <ski>     where
09:09:58 <dixie> benmachine: I mean something like: string "sometoken"
09:09:58 <iskren> what about  WrapPerformAnalysis -- this is the constructor?
09:10:07 <ski>     WrapPerformAnalysis :: Carrier c => (FixPointAlgorithm c -> Program -> State c) -> SomePerformAnalysis
09:10:07 <lunaris> iskren: Precisely.
09:10:13 <dixie> benmachine: what is available for String
09:10:13 <benmachine> dixie: it looks to me like that should work fine if you import Text.Parsec.ByteString
09:10:14 <ski> yes
09:10:16 <dixie> @hooogle string
09:10:17 <lambdabot> Text.Parsec.Char string :: Stream s m Char => String -> ParsecT s u m String
09:10:17 <lambdabot> Text.ParserCombinators.ReadP string :: String -> ReadP String
09:10:17 <lambdabot> Text.ParserCombinators.Parsec.Char string :: Stream s m Char => String -> ParsecT s u m String
09:10:26 <Nimatek> :t (>>)
09:10:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
09:11:05 <iskren> ski, well this data with were syntax looks more foreign ...
09:11:11 <iskren> where**
09:11:21 <lunaris> iskren: You're just listing the types of the constructors explicitly.
09:11:39 <lunaris> For example, one could write:
09:11:43 <lunaris> data Maybe a wher
09:11:47 <lunaris>   Nothing :: Maybe a
09:11:50 <lunaris>   Just :: a -> Maybe a
09:11:58 <iskren> yes, but I havent seen a data with where, only a instance and class
09:12:15 <iskren> isnt this like a class?
09:12:18 <ski> no
09:12:30 <ski> it's just another syntax for declaring ordinary data types
09:12:39 <dixie> benmachine: compiler complains  Couldn't match expected type `ByteString' with actual type `[Char]'
09:12:42 <dixie> :(
09:12:43 <ski> it's just that using this syntax is sometimes more flexible
09:12:48 <nschoe_> Hey, anyone know how I can get the current timestamp in Haskell please?
09:12:53 <benmachine> dixie: you still give a String to 'string' but it can parse ByteString input
09:13:02 <benmachine> nschoe_: have a look at Data.Time
09:13:03 <ski> i.e. you can define types using this syntax that you can't define with the ordinary syntax
09:13:08 <dixie> import Text.Parsec as PR
09:13:09 <dixie> import Text.Parsec.ByteString.Lazy
09:13:18 <iskren> ski, I see, because you can specify the constructor's type better
09:13:27 <lunaris> nschoe_: Data.Time.Clock?
09:13:44 <dixie> benmachine: I use OverloadedStrings extension. But I can try pack explicitly
09:13:49 <lunaris> :t getCurrentTime
09:13:50 <lambdabot> Not in scope: `getCurrentTime'
09:13:57 <lunaris> :t Data.Time.getCurrentTime
09:13:58 <lambdabot> IO time-1.1.4:Data.Time.Clock.UTC.UTCTime
09:14:04 <nschoe_> benmachine: Yeah I'm on it at this moment. But there are just too many things here. I don't know which one to use. I just need to get the time, add a number of seconds to it then store it back. What is the simplest to use for that purpose?
09:14:04 <ski> iskren : yes, specifically, because you can use something else that type variables as type arguments of the result type of a constructor
09:14:08 <benmachine> dixie: no I mean, you *should* still give a String to 'string'
09:14:25 <nschoe_> lunaris: yeah that is what I wanted to use, but how to add 30 seconds to it?
09:14:40 <benmachine> nschoe_: if you're doing a timeout, there are easier ways, btw
09:14:40 <ski> iskren : however, in your case, you don't need to do this (i think). in your case, it's just an alternative (some think prettier) way of writing an "existential data type"
09:14:54 <lunaris> nschoe_: addUTCTime
09:15:01 <lunaris> :t Data.Time.addUTCTime
09:15:02 <lambdabot> time-1.1.4:Data.Time.Clock.UTC.NominalDiffTime -> time-1.1.4:Data.Time.Clock.UTC.UTCTime -> time-1.1.4:Data.Time.Clock.UTC.UTCTime
09:15:15 <dixie> benmachine: I think it complain about return type :( http://hpaste.org/47850  sorry for confusion
09:15:16 <lunaris> And NominalDiffTime is an instance of Num
09:15:33 <nschoe_> benmachine: TWell that's it yeah. I want to store the timestamp, check regularly if we reached the time, then do smth accordingly. There is a better way of doing this?
09:15:37 <benmachine> dixie: you don't want the pack there
09:15:42 <lunaris> So you should get away with passing it 30
09:15:55 <iskren> ExistentialQuantification or GADT
09:16:19 <benmachine> nschoe_: well, I think the usual way would be to fork a thread, have it wait 30 seconds, then notify the main program
09:16:32 <benmachine> via an async exception or an MVar or some such
09:16:34 <kmc> GADTs basically implies ExistentialQuantification
09:16:36 <nschoe_> lunaris: it is addUTCTime that poses me some problems indeed. How to build a NominalDiffTime?
09:16:59 <iskren> ski, by existential data type you mean the data + where syntax?
09:17:04 <kmc> i hate all datetime libraries in all languages
09:17:05 <benmachine> nschoe_: NominalDiffTime is in the Num class, so you can just write a literal number
09:17:07 <d7> I'm told that RWH has a very out-of-date section on using Parsec.
09:17:13 <benmachine> kmc: I hate the concept of time
09:17:14 <kmc> iskren, "data Foo where" syntax is the GADT syntax
09:17:20 <nschoe_> benmachine: Hum, I can't do that may, because I need to be able to add extra seconds whenever I want to the timer: ideally we will never reach the date.
09:17:21 <d7> Is there a better, more modern explanation?
09:17:29 <kmc> it can be used to write normal algebraic types or various fancier things, including existential data types
09:17:39 <nschoe_> benmachine: oh? Just write "30" as it is?
09:17:40 <lunaris> nschoe_: NominalDiffTime is an instance of Num.
09:17:54 <iskren> kmc, what does GADT stand for?
09:17:56 <kmc> to write an existential you just create a constructor which uses a type variable not mentioned in its return type
09:17:58 <benmachine> nschoe_: I think it might be in picoseconds, I'm not sure
09:17:59 <kmc> generalized algebraic data type
09:18:01 <benmachine> experiment
09:18:06 <kmc> if you google GADT you should find some good examples
09:18:10 <nschoe_> lunaris: yeah, sorry I'm not very good at this, does this mean I can just write a number instead?
09:18:11 <kmc> the GHC manual has a decent example
09:18:26 <kmc> data Exists f where { Witness :: f a -> Exists f }
09:18:37 <kmc> since 'a' is not mentioned in 'Exists f', it's an existential type
09:18:45 <lunaris> nschoe_: You can write a number, use +, -, * and abs.
09:18:48 <nschoe_> benmachine: yeah, I'll try it. Anyway, given the fact that I can modify the counter, do you think there is still a better way of doing what I'm trying to do?
09:18:52 <lunaris> (And signum, but nobody likes signum)
09:18:56 <nschoe_> lunaris: okay thanks,I'll try this right now
09:19:23 <benmachine> nschoe_: I'm not sure, it depends a little on how precise it needs to be and in what ways you modify the counter
09:19:24 <iskren> kmc, about this "Exists" -- can you give me an example using it (I mean what is the idea)
09:19:40 <benmachine> nschoe_: but since the way you're doing it now will definitely work, may as well stick to that
09:19:43 <kmc> that's just an example of using GADTs
09:20:05 <kmc> i don't have a handy example of why the Exists type is useful
09:20:20 <benmachine> nschoe_: if your requirements were a bit simpler I'd recommend System.Timeout
09:20:27 <kmc> but there are other useful existential types
09:21:14 <nschoe_> benmachine: I don't know this. I'll take a look, I need to be able to modify the timeout. Say there are 3 hours left. I need to be able to say "now there are 3 hours and 12 minutes left".
09:21:38 <kmc> like GHC's extensible exception type:  data SomeException where { SomeException :: (Exception e) => e -> SomeException }
09:21:44 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/Control-Exception.html
09:21:46 <benmachine> nschoe_: yeah, I'm going to say stick with the Data.Time method, but I thought I'd let you know of possible alternatives
09:21:54 <kmc> iskren, why are you interested in existential types
09:22:23 <nschoe_> benmachine:  yeah right. I'll give it a shot anyway. Thank you!
09:22:29 <kmc> do you have a use case in mind?
09:22:33 <nschoe_> lunaris: thanks you too, it worked well.
09:22:35 <d7> kmc: I had always wondered how SomeException worked.
09:22:47 <lunaris> nschoe_: No problem. I suck at Haskell.
09:23:04 <nschoe_> lunaris: xD
09:23:18 <lunaris> ¬_¬
09:23:31 * benmachine hugs lunaris 
09:24:02 * lunaris watches his pity detector explode
09:26:18 <benmachine> lunaris: that was a hug of solidarity not pity :P
09:26:31 <kmc> <3 hugs
09:26:36 <nschoe_> Hum, worry to ask again, but according to http://www.haskell.org/ghc/docs/7.0.3/html/libraries/time-1.2.0.3/Data-Time-Clock.html#t:UTCTime UTCTime is an instance of Show, yet ghc complains when I tried to display it. Am I going crazy or did I just miss smth?
09:26:36 <lunaris> The bailiffs took my solidarity detector last week.
09:27:01 <lunaris> nschoe_: You're not showing a monadic value are you?
09:27:09 <lunaris> Like IO UTCTime or similar.
09:27:13 <benmachine> nschoe_: oh, possibly you're hitting a weird bug that I saw the other day
09:27:19 <benmachine> nschoe_: try :i UTCTime and then do it again
09:27:20 <benmachine> see what happens
09:27:24 <nschoe_> lunaris: nope took care of extracting it.
09:27:29 <nschoe_> benmachine: ok.
09:27:32 <iskren> kmc, did you just join? I was talking to ski and lunaris about that for maybe an hour
09:27:37 <kmc> yeah, i did
09:27:40 <kmc> feel free to ignore me :)
09:28:21 <nschoe_> benmachine: Well that' weird: :i UTCTime gives me an instance for Eq and Ord only.
09:28:23 <iskren> kmc, the setup is rather complicated (at least for me). You can have a look http://iskren.info:8112/file/tip/Main.hs for a start :)
09:28:38 <benmachine> nschoe_: that IS weird, and not what I remember seeing; what did you import?
09:28:49 <iskren> ski, lunaris I coded the arrays and it compiled, now I'll test the code to use them :)
09:28:57 <nschoe_> andI checked: ghc -- version gives me 7.0.3: the same as the documentation I'm watching.
09:29:04 <nschoe_> Under ghci I did :m + Data.Time.Clock
09:29:11 <lunaris> iskren: Good stuff.
09:29:19 <benmachine> nschoe_: ah, import Data.Time
09:29:38 <benmachine> nschoe_: the Show instance is (bizarrely) defined in Data.Time.LocalTime.LocalTime, apparently
09:29:44 <nschoe_> benmachine: hum okay. Can I ask what the difference is?
09:29:50 <nschoe_> benmachine: oh, okay then. Thanks.
09:30:11 <benmachine> nschoe_: I have no idea why :) they should be in the same place
09:30:24 <ski> iskren : "by existential data type you mean the data + where syntax?" -- no i mean the *concept* "existential data type" -- which can either be defined like `data SomeFoo = forall x. WrapFoo (Foo x)', or like `data SomeFoo where WrapFoo :: Foo x -> SomeFoo'
09:30:31 <nschoe_> benmachine: okay. Worked like a charm btw. Thank you again^^
09:30:37 <benmachine> np :)
09:30:56 <ski> iskren : those are two alternate syntices for defining an instance of the same concept : existential data type
09:31:38 <ski> iskren : "ExistentialQuantification or GADT" -- the former if you use the "normal `data' type syntax, using `forall'"; the latter if you use the syntax with `where'
09:31:49 <lunaris> Syntices, now there's a word.
09:33:37 <ski> (well, saying "syntaxes" or "indexes" or "regexes" or "redexes" *feels* wrong)
09:33:39 <iskren> ski, I think I got it now :)
09:34:41 <iskren> so the difference between the wrappings of the algorithms and the analyses is that the forall was moved outside of the constructor definition
09:35:05 <ski> (at least i know there's precedent with "indices" (dicrete (i.e. modulo `n') logarithms in Gauss' Diqvistiones Arithmeticae)
09:35:07 <iskren> and one is called existential (when forall is outside) and the other is just RankNType (of flexible components)
09:35:35 <lunaris> Alas, syntaxes is correct.
09:35:36 <ski> iskren : when the `forall' is inside, you might call that a "universal data type"
09:35:55 <iskren> yes, universal vs existential
09:36:28 <ski> iskren : with the `forall' inside, the code which unwraps the datatype gets to choose which type to use for `c', so the contents have to be generic
09:37:20 <ski> iskren : with the `forall' outside (i.e. a "existantial data type") the code which *wraps* gets to decide which `c' to use, and the unwrapper can't decide anything at all, it just has to accept using whatever type `c' happens to be
09:37:36 <ski> (so there the *unwrapper* has to be generic / work for all types `c')
09:38:23 <ski> so, presumably if you pick an element from the `performAnalyses' list, and an element from the `fixPointAlgorithms' list
09:38:53 <ski> the first element will decide which `c' is to be used, and will tell the second element, when you combine them, that it wants to use that type
09:39:04 <ski> iskren : do you understand ?
09:39:05 <benmachine> ski: -ex pluralises to -ices fine, but -ax I'm less sure about
09:39:18 <ski> benmachine : ok
09:39:24 <benmachine> lunaris: 'correct' is a mutable concept :P
09:39:38 * ski doesn't really know very much about latin declensions
09:39:46 <benmachine> ski: oh, neither do I
09:40:00 <benmachine> (I like syntaces, but I don't claim it's correct as such)
09:40:33 * ski considers emulating that, instead of "syntices"
09:40:56 * geheimdienst just uses the most regular forms possible *shrug*
09:41:07 <benmachine> I think the meaning is clear in both cases so you should just use whichever you like :)
09:41:24 <benmachine> geheimdienst: I like to use expressions that are aesthetically nice
09:41:33 <benmachine> where possible
09:41:39 <ski> there's also the option of using the old english `-en' instead
09:41:44 <benmachine> yes that too
09:42:12 <benmachine> I never liked that as much but I'm fine with other people using it :P
09:42:29 <benmachine> I think I'd prefer 'syntaxen' to 'syntaxes' at least
09:42:36 <inter> Are taxes tices? Are faxes fices? And syntaxes are neither syntices nor of Latin origin!
09:42:41 <kmc> death and syntaxes
09:42:42 <ski> benmachine : so you say "regices" ?
09:42:54 <ski> (and "redices" ?)
09:43:07 <kmc> the plural of "redex" is "radishes"
09:43:32 <iskren> ski, the teoretical stuff -- yes, but I have to see it running first :)
09:44:38 <ski> iskren : anyway, using universal and existential data types, you should be able to use `lookup' on association lists (and upgrade to `Map's if you want to)
09:45:10 <benmachine> ski: no, one regex is enough :P
09:45:41 <ski> there is an alternative of actually GADT types, which will require using what i tentatively call `Map1's ..
09:45:44 <benmachine> (that is to say I've never thought about it because I don't use those words much)
09:46:31 <ski> (a `Map1 key value' is basically an association list `[exists index. (key index,value index)]', though is probably implemented more efficiently)
09:46:45 <geheimdienst> ... solved with a regex. now you have two problemices.
09:47:15 * hackagebot archiver 0.4 - Archive supplied URLs in WebCite & Internet Archive  http://hackage.haskell.org/package/archiver-0.4 (GwernBranwen)
09:48:42 <benmachine> geheimdienst: :D
09:50:59 <inter> Apparently syntax is derived from the 3rd decl. fem. noun συνταξις, which makes its plural συνταξεις if I remember my Greek correctly. Not that anyone cares.
09:51:41 * benmachine ponders... a mathematician has n problems, and says, I know, I'll use induction, now he has n+1 problems
09:51:50 <homie> lol
09:52:06 <benmachine> inter: the letters are pretty but I don't know how they work
09:52:45 <benmachine> approximately syntaxis and syntaxes?
09:52:58 <inter> Basically yeah
09:53:59 <homie> what does it mean to max the equalizers ?
09:55:00 <ski> benmachine : that's the wrong direction. induction is just structural recursion, so it should go from `n+1' to `n'
09:56:22 <NemesisD> benmachine: would you be able to help me out with that algorithm we were discussing earlier? i've been hitting it with a stick all morning and i'm starting to get diminishing returns
09:56:50 <monochrom> the mathematician does have one more problem if he/she tries induction. a suitable induction hypothesis is hard to find
10:02:27 <iskren> ok, I got to the following: http://iskren.info:8112/file/6374adfc18aa/Main.hs (error http://fpaste.org/gdrk/)
10:02:51 <iskren> it somehow didn't like the way unwrap the algorithm/optimizer
10:04:13 <ski> iskren : oh, you have `performOptimization' operations, which you haven't told about :)
10:05:05 <iskren> ski, I didn't want to scare you :-P
10:05:08 <ski> assuming each `performOptimization' also works on a particular carrier type (specifically the same carrier type as the `performAnalysis' in the same module operates on)
10:05:16 <iskren> aaah
10:05:21 <iskren> I guess I should wrap them together
10:05:22 <iskren> :)
10:05:25 <ski> you need to do an existential wrapping only once, not twice
10:06:10 <ski> if you say `(exists x. Ana x,exists x. Opt x)', (which is effectively what you're doing), it won't know for sure that the two `x's in there are the same type
10:06:11 <iskren> yes, but you said that the type is determined by the wrapper, and at "wrapper" we have the same types for c, so it should work then?
10:06:21 <ski> you have to do `exists x. (Ana x,Opt x)'
10:06:28 <ski> i.e.
10:06:35 <iskren> I mean -- I understand the fix
10:06:57 <ski> iskren : yes, the type is determined by the wrapper
10:06:58 <iskren> but it is not 100% clear to me why it does not see (the compiler) that the types are the same (because it is one type only)
10:07:16 <ski> which means that the unwrapper has to be prepared for *any* type `c' (in class `Carrier')
10:07:33 <NemesisD> i figured it out!
10:07:55 <benmachine> ski: I considered doing it that way around, I wasn't sure which was funnier
10:07:57 <iskren> ahaa, and in the universal case the unwrapper can choose
10:07:59 <ski> so, if you unwrap two times (one time for `SomeAnalizer' and one time for `SomeOptimizer') the unwrapper has to be prepared for the case the the two `c's are different
10:08:06 <ski> yes
10:08:09 <benmachine> ski: the 'right' way around lacks schadenfreude :P
10:08:11 <NemesisD> i guess you just have to hit a problem with sticks and list comprehensions for a while and it will just work
10:08:32 <benmachine> NemesisD: heh, congrats
10:08:35 <ski> since you *can* put different `x's in `(exists x. Ana x,exists x. Opt x)', the unwrapper has to be prepared for that possibility
10:08:46 <ski> and therefore it can't just assume that they are the same type
10:08:54 <benmachine> NemesisD: list comprehensions are very similar to do notation, I find the latter easier to work with
10:09:55 <ski> iskren : every time you unwrap an existential, the unwrapped type `x' acts like if it was a new fresh type, unequal to every existing type in the system
10:10:34 <ski> iskren : this is because the compiler can't know at compile-type which type you're going to get, so it's going to assume that it's non-equal to every other type
10:11:15 <ski> iskren : do you see the picture ?
10:11:55 <ski> benmachine : "considered doing it that way around" -- "it" being ?
10:12:02 <hpaste> NemesisD pasted “fullDistributions” at http://hpaste.org/47853
10:12:10 <benmachine> ski: oh, sorry, the induction joke
10:12:19 <ski> ah
10:12:28 <NemesisD> my solution is pretty nasty though
10:12:31 * benmachine picks up conversations with 13 minute gaps and assumes everyone will know what is going on
10:12:36 * ski was reminded of bar induction
10:12:56 <benmachine> bar?
10:12:57 <ski> benmachine : don't worry, i sometimes do that for hours-old conversations
10:13:11 <benmachine> :)
10:13:50 <iskren> ski, now that you explained it like that -- yes. But I still get the same error. Let me paste the code
10:14:35 <pgavin> @pl \a _ -> f a b
10:14:36 <lambdabot> const . flip f b
10:14:38 <benmachine> NemesisD: interesting, I think when I tried to do it I inducted on the items instead of the buckts
10:14:41 <benmachine> *buckets
10:14:57 <benmachine> (I didn't keep my attempt I'm afraid)
10:15:02 <iskren> http://fpaste.org/72Ci/ << here is the main and the error at the bottom
10:15:08 <NemesisD> benmachine: hmm thats an interesting approach
10:15:29 <benmachine> NemesisD: I did something like, for each item, put it in every bucket
10:15:43 <benmachine> I mean
10:15:49 <benmachine> hm
10:15:53 <benmachine> I will write it up again, sec
10:16:21 <joe6> what is the size of Int?
10:16:23 * hackagebot wxdirect 0.12.1.4 - helper tool for building wxHaskell  http://hackage.haskell.org/package/wxdirect-0.12.1.4 (EricKow)
10:16:34 <joe6> > sizeOf Int
10:16:35 <lambdabot>   Not in scope: `sizeOf'Not in scope: data constructor `Int'
10:16:35 <benmachine> joe6: see: maxBound, minBound
10:16:44 <joe6> benmachine: thanks
10:16:44 <benmachine> > maxBound :: Int
10:16:45 <lambdabot>   9223372036854775807
10:16:53 <benmachine> lambdabot has quite a big Int
10:16:55 <iskren> ski, thanks very much for the explanation! I'm sorry I'm so slow, but really these concepts need time to be assimilated. I've been reading a lot about haskell, but when you start coding its completely different :) I was so lucky not to get into those type problems in the beginning. I would have written the whole thing in C maybe :)
10:16:55 <pgavin> the standard defines it as at least 29 bits or something
10:16:57 <benmachine> yours may be smaller
10:17:03 <benmachine> pgavin: yeah something like that
10:17:31 <joe6> is there something simple to get just the last byte of an Int?
10:17:35 <ski>   barInduction : {A : Set} -> {P : List A -> Bool} -> {_ : (as : Nat -> A) -> (n : Nat) * P (take n as) == True} -> {Q : List A -> Set} -> {_ : (as : List A) -> P as == True -> Q as} -> ((as : List A) -> ((a : A) -> Q (as ++ Cons a Nil)) -> Q as) -> Q Nil
10:17:39 <ski> benmachine : ^
10:17:41 <pgavin> > 123454 `mod` 256
10:17:42 <lambdabot>   62
10:18:01 <joe6> pgavin: ok, thanks
10:18:09 <pgavin> > 123456 .&. 255
10:18:09 <lambdabot>   Ambiguous type variable `a' in the constraint:
10:18:10 <lambdabot>    `Data.Bits.Bits a'
10:18:10 <lambdabot>      a...
10:18:24 <pgavin> > (123456 .&. 255) :: Int
10:18:24 <lambdabot>   64
10:18:41 <pgavin> .&. will be better
10:18:43 <pgavin> faster
10:18:59 <benmachine> ski: how does * operate on types?
10:19:00 <Botje> stronger!
10:19:32 <ski> iskren : well, unfortunately `C' doesn't have `forall' and `exists', you have to use `void *', and keep track for yourself what you meant, and which should be the same type
10:19:51 <ski> benmachine : `A * B' is Haskell's `(A,B)'
10:20:12 <ski> benmachine : `(a : A) * P a' is simultaneously `exists a : A. P a'
10:20:31 <pgavin> ski: came in late, what language is that?
10:20:41 <ski> pgavin : Agda2-ish
10:20:57 <pgavin> hmm
10:20:58 <pgavin> interesting
10:21:10 <ski> (Agda2 doesn't have built-in existentials / dependent products. you can built it as a datatype, though)
10:21:32 <pgavin> can we have inductive types in haskell plz
10:21:33 <pgavin> rofl
10:22:01 <joe6> pgavin: ok, thanks
10:22:06 <ski> pgavin : of course. that's what `data' basically is (apart from the bottoms that creep up around every corner)
10:22:11 <pgavin> erm
10:22:14 <pgavin> inductive families
10:22:16 <pgavin> they call them
10:22:17 <benmachine> so we take a list predicate which is true of some prefix of any infinite list, and... I'm lost a bit
10:22:26 <iskren> ski, i'm not saying C is better, I'm saying that haskell has a pretty steep learning curve (or I just know C better :))
10:22:42 <tiffany> C has endless syntax ;___;
10:23:01 <ski> benmachine : we could really replace `Q' with `P' .. but it's somewhat more general to assume that `Q' need not be decidable
10:23:03 <pgavin> ski: like, it would be nice to do: type ArrayOfFiveInts = Array 5 Int
10:23:32 <kmc> that's Coming Soon ™ in GHC
10:23:36 <kmc> type-level natural numbers
10:23:43 <pgavin> I asked for it earlier
10:23:46 <kmc> but you can fake it today
10:23:50 <pgavin> but I was told it should be a library thing
10:23:51 <pgavin> I know
10:24:00 <pgavin> @hackage tfp
10:24:00 <lambdabot> http://hackage.haskell.org/package/tfp
10:24:04 <pgavin> that's mine
10:24:11 <tiffany> http://shootout.alioth.debian.org/u64q/which-programming-languages-are-fastest.php?gcc=on&gpp=on&go=on&ghc=on&python3=on&calc=chart
10:24:13 <ski> benmachine : anyway, we ask for `Q' to hold in every case that `P' holds, so if `Q' is `P', this certainly holds
10:24:13 <tiffany> :o
10:24:27 <kmc> anyone used Haskell for processing g-code or other CNC tasks?
10:24:33 <ski> benmachine : the `P' is basically used as a "base case" for `Q'
10:24:43 <benmachine> hm ok
10:25:07 <ski> benmachine : to start, consider a *decidable* predicate on an *infinite* stream
10:25:23 <benmachine> ski: I think you overestimate me :P
10:25:26 <ski> benmachine : how is it possible for this to be decidable ?
10:25:38 <iskren> should I use any fancy syntax to get the type from the analyzer/optimizer and tell the fixpoint that it should use it?
10:25:45 <ski> benmachine : the answer is : because the predicate only ever looks at a finite prefix of the infinite stream
10:26:05 <ski> benmachine : otherwise there would be cases in which it didn't terminate (and so wan't decidable)
10:26:13 <tiffany> 4% [5 ghc6 2161621/68.4MB 3%]                                                                                                19.0kB/s 58min 0s
10:26:15 <tiffany> ;_;
10:26:30 <benmachine> ski: ah, okay
10:26:33 <benmachine> that makes sense
10:26:35 <pgavin> tiffany: apt?
10:26:39 <tiffany> aptitude
10:26:44 <pgavin> maybe change repos
10:26:56 <tiffany> meh, my connection is almost always this slow
10:26:58 <ski> benmachine : so, assume that we can somehow ask the predicate for how large prefix of the stream it has looked at
10:27:02 <pgavin> tiffany: sry :/
10:27:12 <ski> benmachine : (this prefix is a (finite) list, btw)
10:27:17 <benmachine> ski: mmhm
10:27:58 <ski> benmachine : so, if we take *any* other stream with the same prefix, the predicate is bound to give the same result on this other stream as it did on the first stream
10:28:07 <benmachine> right
10:28:24 * hackagebot wxcore 0.12.1.7 - wxHaskell core  http://hackage.haskell.org/package/wxcore-0.12.1.7 (EricKow)
10:29:35 <ski> (formally this means that the predicate is *continuous* wrt to the Baire topology on the infinite streams, and the discrete topology on the result booleans)
10:30:05 <ski> benmachine : so, let `P as' mean that the original predicate holds for *every* stream with `as' as prefix
10:30:35 <benmachine> ski: right
10:31:06 <ski> so, say e.g. that we're talking about streams of natural numbers
10:31:41 <ski> say that we know `P (as ++ [0])', as well as `P (as ++ [1])',`P (as ++ [2])',&c.
10:32:07 <ski> so `P' holds for every extension of the list `as', with every possible natural number
10:32:19 <benmachine> right
10:32:26 <ski> then, surely `P as' also holds
10:32:33 <benmachine> yes
10:33:01 <ski> so, if we can prove this for every list `as', that if it holds for every extension of `as', it holds for `as'
10:33:16 <ski> then bar induction gives us that `P []' holds
10:33:21 <benmachine> ah ok
10:33:42 <ski> which means that the original decidable predicate on *streams* hold for *every* stream
10:33:47 <benmachine> right yes
10:33:47 <tiffany> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=gpp :<
10:33:59 <ski> so, this is a way to prove that some decidable predicate holds for every stream
10:34:20 <ski> benmachine : this is the basic motivation of the `barInduction' axiom
10:34:33 <benmachine> axiom?
10:34:37 <ski> (then there's some generalization of what i said in there as well)
10:34:58 <ski> yes, it can't be proved assuming just intuitionistic logic
10:35:08 <benmachine> oh, ok
10:35:18 <ski> it relies on us believing "every function is computable"
10:35:21 <benmachine> aha
10:35:35 <benmachine> do we believe that?
10:35:49 <ski> (as opposed to "we can't prove that there is an uncomputable function", which is the case in intuitionistic logic)
10:35:55 <ski> benmachine : depends on mood :)
10:35:58 <benmachine> heh
10:35:59 <monochrom> every intuitionistically defined function is computable
10:36:04 <benmachine> monochrom: mm
10:36:10 <Kaidelong> so to make an accumulating mean, data Mean a = Mean Int a, you do addToMean (Mean n acc) x = Mean (n+1) (acc+(x/n)) ?
10:36:22 <benmachine> ...surely that's just 'every defined function is definable'
10:36:23 <ski> @where impossible
10:36:23 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
10:36:27 <Kaidelong> more a math question than a haskell question
10:36:36 <Kaidelong> but I figure someone could point out if I got it wrong
10:36:49 <benmachine> Kaidelong: acc+x, surely?
10:36:53 <benmachine> then you divide by n at the end
10:37:00 <benmachine> or wait
10:37:00 <ski> benmachine : those ^ ideas by Escardo relies on bar induction (or at least something similar), for the proof on the meta-level that they terminate
10:37:07 <benmachine> you want it to work as you go along
10:37:16 <Kaidelong> yeah, this is for a monte-carlo simulation
10:37:23 <benmachine> Kaidelong: my instinct is you want /(n+1)
10:37:32 <NemesisD> benmachine: btw that algorithm helped bring my program out of NP-complete status. for N = 17, with profiling before it took 167.22 secs (8361 ticks @ 20ms), now it takes 0.00 secs (0 ticks @ 20ms)
10:37:36 <Kaidelong> yes, you're right
10:37:36 <benmachine> Kaidelong: consider before you've collected anything and you've got n = acc = 0
10:37:42 <Kaidelong> thanks
10:37:54 <benmachine> NemesisD: ...k :P
10:39:21 <ski> iskren : yeah, Haskell (explicitly) introduces some new concepts -- but after you know these concepts, you can think about them when you code in C, as well (and write types with `forall' and `exists' in comments)
10:39:47 <ski> iskren : "should I use any fancy syntax to get the type from the analyzer/optimizer and tell the fixpoint that it should use it?" -- it should suffice if you unpack the `ShowFoo' type, and in the same scope unpack the generic type
10:40:35 <ski> benmachine : btw, <http://eom.springer.de/b/b015220.htm> has some info on bar induction
10:42:19 <ski> (iskren : and then try to pass the fixpoint algorithm to the analysis)
10:42:19 <iskren> ski, I did, but http://fpaste.org/72Ci/ << it fails with the same error
10:43:29 <ski> iskren : btw, just so you know, if you want to, you can curry `WrapAnalizerOptimizerPair'
10:44:36 <ski> s/Analizer/Analyzer/
10:45:33 <ski> look at line 97-98
10:45:38 <ski>   (analyzer, optimizer) = case jLookup analysisName analysisMap of
10:45:45 <ski>     WrapAnalizerOptimizerPair (a, o) -> (a, o)
10:45:51 <ski> you can't do it this way
10:47:13 <ski> the code combining an `performAnalyzer' with a `fixpointAlgorithm' (and then with an `performOptimizer', i assume) has to be inside the `case' here
10:47:39 <Kaidelong> addMeans (Mean 0 _) x = x; addMeans x (Mean 0 _) = x; addMeans (Mean n1 acc1) (Mean n2 acc2) = Mean (n1+n2) ((n1*acc1+n2*acc2)/(n1+n2))
10:48:25 <ski> iskren : the "secret" type `c' is only "visible" inside the branch in the `case' there, where you have unwrapped it -- you can't write an expression as the branch which mentions the type `c'
10:48:41 <Kaidelong> instance (Num a) => Monoid (Mean a) where mempty = (Mean 0 0); mappend = addMeans
10:48:56 <ski> iskren : so, every (explicit) reference to `c' must have disappeared, by the time that `case' returns
10:49:32 <iskren> ski :) I got that
10:50:24 <ski> iskren : `optRes' and `strRes' have types not mentioning the `c', you could could return a pair of them, if you want
10:50:36 <ski> but it looks like you only want to return `strRes'
10:50:40 <jonkri> i have a pretty large state loop that i want to clean up a little bit. the function that processes the internal events has the type "(MonadIO m, ClientState s m) => (InternalEvent s m) -> (StateT (State s m) m) (Maybe CE.SomeException)". what i'm thinking about is making it pure and instead return a list of actions to perform along with the modified state. i'm thinking this way i could make unit tests. does this sound good?
10:52:07 <Kaidelong> @ty (/)
10:52:08 <lambdabot> forall a. (Fractional a) => a -> a -> a
10:52:12 <Kaidelong> whoops
10:52:17 <ski> jonkri : if it works, it sounds fine, i think
10:52:18 <Kaidelong> so that instance wouldn't work
10:52:58 <ski> iskren : so, do you have an idea of how to rewrite it, or should i have a go ?
10:53:03 <hpaste> jonkri pasted “State” at http://hpaste.org/47854
10:53:26 <iskren> ski, I'm just trying that now. I'll keep you in touch :)
10:53:46 <jonkri> that's my state... does it look to you like it should be devided into different states perhaps, which are all operated on using different, completely separate functions
10:55:21 <iskren> ski, I think I stumbled in a different problem -- how should I state that all cariers have a State type (State c) and this state type implements the class StateCls where you can find a pretty function (to convert it to string)
10:56:03 <iskren> or I should make the pretty function part of the Carrier class ?
10:56:28 <iskren> like class Carrier c where pretty :: (State c) -> String
10:58:42 <iskren> wow... this made it compile :D
10:59:04 <tiffany> I must read this haskell tutorial
10:59:12 <tiffany> but I'm still in that morning-bleh mood
10:59:15 <tiffany> ;w;
10:59:54 * Kaidelong contemplates whether or not his MPI-based monte carlo simulation will merit unsafePerformIO
11:00:07 <Kaidelong> oh something I can actually ask
11:00:24 <Kaidelong> nm, it just hit me that the answer is yes
11:00:55 <Kaidelong> @hoogle b -> c a -> [a]
11:00:56 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
11:00:56 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
11:00:56 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
11:01:15 <Kaidelong> @ty evalRand
11:01:15 <lambdabot> forall g a. (RandomGen g) => Rand g a -> g -> a
11:01:28 <Kaidelong> err hmm
11:01:42 <iskren> ski, it worked!!!!
11:01:42 <Kaidelong> need one that generates a stream of results instead
11:01:47 <ski> iskren : hm, maybe `instance Carrier c => StateCls (State c) where ...' ?
11:01:49 <Kaidelong> @ty evalRands
11:01:50 <lambdabot> Not in scope: `evalRands'
11:02:29 <iskren> ski, hm, this last syntax is not entirely clear to me
11:02:50 <iskren> I mean -- the State is always the same (given a carrier) so I can put the pretty function in the Carrier class
11:04:55 <benmachine> @ty runRang
11:04:56 <lambdabot> Not in scope: `runRang'
11:04:57 <benmachine> @ty runRand
11:04:58 <lambdabot> forall g a. (RandomGen g) => Rand g a -> g -> (a, g)
11:05:42 <benmachine> :t let rands x = (:) <$> x <*> rands x
11:05:43 <lambdabot> <no location info>:
11:05:43 <lambdabot>     not an expression: `let rands x = (:) <$> x <*> rands x'
11:05:46 <benmachine> :t let rands x = (:) <$> x <*> rands x in rands
11:05:46 <lambdabot> forall (f :: * -> *) a. (Applicative f) => f a -> f [a]
11:05:58 <andreas__> Hi I'm having trouble setting a breakpoint in ghci in a module A that is loaded by my main module B, where A is an lhs file (named A.lhs). I'm using a command like ":break A 7". It works if A is a plain haskell file, but fails if it is a literate haskell file. Does anyone know a workaround for this?
11:06:00 <benmachine> :t let rands x = (:) <$> x <*> rands x in evalRand rands
11:06:01 <lambdabot>     Couldn't match expected type `Rand g a'
11:06:01 <lambdabot>            against inferred type `f a1 -> f [a1]'
11:06:01 <lambdabot>     In the first argument of `evalRand', namely `rands'
11:06:07 <benmachine> :t let rands x = (:) <$> x <*> rands x in evalRand . rands
11:06:08 <lambdabot> forall g a. (RandomGen g) => Rand g a -> g -> [a]
11:06:08 <DukeDave> Hey gang, I've just changed a type synonym into a data type, and after trying for a while it hasn't brought me the elegance I was expecting. I've added a couple of notes on here, if anyone could suggest anything :)
11:06:08 <DukeDave> https://github.com/dukedave/FuzzyHaskell/commit/db287a50feda0f190217ec95efb0ffad1cf93bfc
11:06:22 <andreas__> I'm using ghci 7.0.1
11:06:48 * Kaidelong thinks he will use RVar instead of MonadRandom
11:06:57 <kmc> DukeDave, the short answer is "no"
11:07:05 <kmc> there is nothing in the type of LookAtMatrix that says it has three data fields
11:07:27 <kmc> but you can write your own analogue of uncurry3 once, and use it elsewhere
11:07:47 <Kaidelong> so long as the distribution is uniform, different machies sampling the same places shouldn't be a problem, right?
11:08:05 <benmachine> DukeDave: you could change lookAt to take  a
11:08:07 <benmachine> er
11:08:10 <benmachine> a LookAtMatrix
11:08:11 <kmc> or change lookAt to take a LookAtMatrix (except it's probably a library function isn't it)
11:08:14 <benmachine> instead of three arguments
11:08:47 <kmc> also why do you have these explicit "INLINE" annotations?
11:10:06 <kmc> DukeDave, you can rewrite one of your lines as
11:10:08 <kmc> where updateCenter (LookAtMatrix eye center up) = LookAtMatrix eye (center `add` centerDelta) up
11:10:11 <kmc> or:
11:10:32 <kmc> where updateCenter (LookAtMatrix { eye = e, center = c, up = u }) = LookAtMatrix e (c `add` centerDelta) u
11:10:37 <kmc> (using the record deconstruction syntax
11:10:38 <DukeDave> benmachine: kmc: Yeah, lookAt is in Graphics.UI.GLUT
11:10:42 * hackagebot hbro 0.4.6 - A suckless minimal KISSy browser  http://hackage.haskell.org/package/hbro-0.4.6 (koral)
11:10:56 <kmc> or (with GHC's NamedFieldPuns extension)
11:11:08 <kmc> where updateCenter (LookAtMatrix { eye, center, up }) = LookAtMatrix eye (center `add` centerDelta) up
11:11:13 <kmc> or (with GHC's RecordWildCars extension)
11:11:17 <kmc> RecordWildCards*
11:11:23 <kmc> where updateCenter (LookAtMatrix { .. }) = LookAtMatrix eye (center `add` centerDelta) up
11:11:26 <benmachine> what about updateCenter lookAtMatrix{ center = c } = lookAtMatrix{ center = c `add` centerDelta }
11:11:42 <kmc> oh, yeah
11:12:06 <ion> updateCenter = modL center (add centerDelta)
11:12:08 <kmc> except it would be more like:  updateCenter m@(LookAtMatrix { center = c }) = m { center = c `add` centerDelta }
11:12:17 <benmachine> oh, yeah
11:12:21 <ski> iskren : hm, i suppose
11:12:27 <kmc> DukeDave, also, if you're using records a lot, you might want to look at the 'fclabels' or 'lenses' or 'data-accessor' packages
11:12:41 <ski> iskren : btw, s/(State c) -> String/State c -> String/ :)
11:12:43 <ion> My example used fclabels.
11:12:44 <iskren> ski, you can take a look at the final version: http://iskren.info:8112/file/tip
11:12:46 <benmachine> what about updateCenter matrix = matrix{ center = center matrix `add` centerDelta }
11:12:51 <kmc> that too
11:13:02 <kmc> DukeDave, hope we haven't overloaded you with info ;)
11:13:11 <benmachine> (writing matrix three times to update it once, woo)
11:13:44 <ion> With modL, you get to write it zero times to update it once. :-)
11:15:04 <ski> iskren : hm, i wouldn't use the word `Any' in `AnyFixPointAlgorithm'
11:15:33 <ski> iskren : using that makes it sound like you should expect any (carrier) type inside
11:15:42 <ski> @type all
11:15:43 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:15:44 <ski> @type any
11:15:45 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:15:57 <ski> `any' is basically a synonym for `exists' or `some'
11:17:05 <Kaidelong> so hmm, here's my idea of how I'm going to do the monte carlo. Each machine samples a common uniform distribution of uniform distributions, picking a specific one determined by their rank. They each calculate a monoid value, and are arranged into a binary tree structure in which parent nodes mappend the results of their children
11:17:07 <iskren> so just FixedPointAlgorithm?
11:17:21 <iskren> can I have data with the same name as type?
11:17:35 <ski> well, `GenericFixedPointAlgorithm' i think has the right sound to it
11:17:54 <iskren> but generic makes it feel that there is a nongeneric one, no?
11:18:02 <Kaidelong> so if you want a 2000 sample monte carlo simulation for 20 machines each can run 100 samples
11:18:26 <Kaidelong> not going to implement any kind of load balancing since either that makes things much more complicated or you lose determinism
11:18:38 <ski> iskren : regardless of whether you use `data',`newtype' or `type' you define a type (giving it a name, i.e.)
11:20:29 <ski> iskren : btw, i would uncurry `WrapAnalyzerOptimizerPair (analyzer, optimizer)' into `WrapAnalyzerOptimizerPair analyzer optimizer', but that's just a matter of taste
11:21:46 <ski> iskren : btw, you might change `import qualified TrulyLiveVariables' to `import qualified TrulyLiveVariables as TLV', so that you can say `TLV.performAnalysis' instead of `TrulyLiveVariables.performAnalysis'
11:21:46 <iskren> ski, you mean in the definition or?
11:22:10 <ski> both in the definition of the type and in the wrappings and unwrapping, yes
11:22:11 <iskren> where do I uncurry it
11:22:23 <ski> but it's just a matter of which you think is prettiest
11:22:31 <iskren> aaah so I just make it get 2 args ... I see :) I'm stupid
11:22:53 <iskren> oh, yes, import name shortening will help :)
11:23:52 <ski> in `main' i would replace `getContents >>= (\inp -> ..inp..)' by `getContents >>= \inp -> ..inp..' (and then possibly using `do'-syntax instead)
11:24:56 <ski> iskren : if you want, you can define an unwrapper function for `WrapFixPointAlgorithm'
11:25:12 <ski> so that you don't need to `case' explicitly on that, at least
11:25:47 * ski wonders where `AnyFixPointAlgorithm' is defined
11:26:31 <ski> ah `FixPointAlgorithmBase'
11:26:44 <ski> well, you could replace
11:26:46 <ski>   data AnyFixPointAlgorithm = WrapFixPointAlgorithm (forall c. Carrier c => FixPointAlgorithm c)
11:26:50 <ski> with e.g.
11:27:12 <ski>   data GenericFixPointAlgorithm = WrapFixPointAlgorithm {runFixPointAlgorithm :: forall c. Carrier c => FixPointAlgorithm c}
11:27:26 <ski> (or s/run/instantiate/ if you want to be truly verbose)
11:27:34 <ski> that will automatically define a function
11:27:35 <iskren> ski, and this unwrapping makes sense only for the algorithm right?
11:27:46 <ski>   runFixPointAlgorithm :: GenericFixPointAlgorithm -> (forall c. Carrier c => FixPointAlgorithm c)
11:27:50 <ski> for you
11:27:52 <ski> i.e.
11:28:00 <ski>   runFixPointAlgorithm :: Carrier c => GenericFixPointAlgorithm -> FixPointAlgorithm c
11:28:06 <iskren> yeah, I've been using this syntax for other things in the program
11:28:15 <iskren> its neat :)
11:28:35 <DukeDave> kmc: ion: Just reading up on fclabels, looks very interesting, I'll get back to you :)
11:28:50 <ski> iskren : yeah, you can't define an unwrapping function for existentials (at least not for components/fields mentioning the existentially quantified type variable)
11:29:08 <iskren> ski, about the do syntax in the main function -- can I use = in do? because I'm very foreign to monads :)
11:29:19 <ski> the reason is the same as the reason you got errors with your inital `WrapAnalizerOptimizerPair (a, o) -> (a, o)' unwrapping attempt
11:29:23 <jonkri> is there someway that i can have an IQ data type which is basically "IQRequest | IQResponse" without having to come up with any new type constructor names? http://hpaste.org/47855
11:29:42 <ski> iskren : btw, i would change from `data' to `newtype' in `GenericFixPointAlgorithm' -- not a big change, but slightly more efficient
11:30:07 <ski> jonkri : you can use `=' inside `let' inside `do'
11:30:22 <ski> er, s/jonkri/iskren/
11:30:50 <ski> (stop having "kr" in both your nicks at the time ! :)
11:31:05 <ion> skri
11:31:25 <k0ral> which commandline arguments parser would you recommend ? I've heard of getOpts, parseArgs and some others
11:31:37 * ski can't recall an `R' combinator in the SKI-combinator calculus
11:31:38 <kmc> cmdargs is good
11:32:17 <iskren> ski, but I have only one =, how would a let inside do help?
11:32:31 <iskren> I mean -- is it going to be better?
11:32:45 <k0ral> kmc: what's the benefits of using cmdargs instead of getOpts ?
11:32:46 <ski> iskren : then i'm not sure what you meant
11:33:15 <ski> iskren : you have `main = getContents >>= (\inp -> ..inp..)'
11:33:53 <ski> iskren : this can be rewritten to `main = do inp <- getContents; ..inp..' -- where instead of `;' you typically break the line, aligning on the next line
11:34:17 <iskren> ski, that is what I get with the let in do: http://fpaste.org/eNwU/
11:34:30 <ski> iskren : so, which `=' where you referring to by "about the do syntax in the main function -- can I use = in do?" ?
11:34:33 <kmc> k0ral, what's this 'getOpts'? i don't see it on hackage?
11:34:58 <iskren> ski, I have the (maybe wrong idea) that you can mix <- and = in do, and the = should work as in let, but I'm wrong maybe
11:35:05 <ski> iskren : indent the `in' at least on more space .. or remove the `in'
11:35:19 <k0ral> kmc: without the -s
11:35:26 <k0ral> kmc: my bad
11:35:46 <ski> iskren : in `do', you can't use `=' (but you can use it inside `let' inside `do')
11:36:09 <iskren> ski, but I thought the in should be alligned with the let, no?
11:36:18 <iskren> removing it is best, I didn't know you can do that :)
11:36:42 <ski> @undo do x <- foo; let {y = f x}; bar x y
11:36:42 <lambdabot> foo >>= \ x -> let { y = f x} in bar x y
11:37:26 <ski> iskren : so you can put a separate `let'-command, inside a `do', and it scopes over all the remaining commands (and the final expression), just like `x <- foo'-like commands do
11:37:56 <iskren> ski, nice :) that was what my brain was trying to recollect :)
11:38:03 <Peaker> maybe It could be nice if "let" was implicit by "=" in "do"
11:38:13 <Peaker> So you'd have "<-" and "=" as more similar
11:38:17 <Peaker> (syntactically)
11:38:28 <ski> iskren : but since you can use any expression as a command, you can *also* use `let ... in ...', inside a `do', but you have to make sure you don't reach back to the same column as `let' started at, until the whole `let'-`in' has ended
11:38:44 <kmc> Peaker, i think it's a feature, not a bug, to emphasize the difference between evaluation and execution
11:39:04 <ski> iskren : otherwise `do' will get confused and think you're starting another command inside the `do' (in your case `in putStr strRres' is an invalid command, in `do')
11:39:24 <iskren> ski, aha, so a let inside do is either a hack (without an in) or a normal let/in
11:39:48 <Peaker> kmc: but the emphasis costs extra syntactic clutter that seems redundant
11:39:55 <ski> Peaker : well, we could have that as a shorthand .. but we still need `let' for mutually recursive bindings
11:39:57 <iskren> because the missing in is somewhat special for do, right?
11:40:11 <ski> (well, i suppose `rec' could be used for this, hm ..)
11:40:39 <ski> iskren : if you think of the whole of `do'-syntax (sugar) as a hack, then yes :)
11:41:11 <iskren> wow, I learned so much haskell in the last few hours
11:41:26 <kmc> :D
11:41:47 <kmc> yeah, let-in-do is a special syntactic variant
11:41:49 <iskren> but I just don't understand why can't you "export" the existential type out of the case ... I mean -- why can't haskell figure that out
11:42:03 <iskren> kmc, let-in-do-without-in :)
11:42:08 <kmc> right
11:42:13 <kmc> do { x; let a = y; z }  ≡  do { x; let a = y in do { z } }
11:42:48 <ski> @undo do { x; let {a = y}; z }
11:42:49 <lambdabot> x >> let { a = y} in z
11:42:52 <iskren> kmc, I think you can go without the final do
11:42:59 <ski> @undo do { x; let {a = y} in do { z } }
11:43:00 <lambdabot> x >> let { a = y} in z
11:43:01 <kmc> if 'z' is only a single statement, yes
11:43:06 <kmc> in general it might be a sequence of statements
11:43:36 <ski> iskren : consider the very simple
11:43:57 <ski>   data Showable = forall a. Show a => WrapShowable a
11:44:08 <ski> the type signature for the constructor `WrapShowable' is
11:44:17 <ski>   WrapShowable :: Show a => a -> Showable
11:44:42 <ski> iskren : what would the type signature for the deconstructor/unwrapper `unwrapShowable' be ?
11:45:30 <iskren> ski, well, as you said, it will return a "new" type somewhat
11:45:34 <ski> yes
11:45:36 <c_wraith> Showable -> forall a. Show a => a
11:45:37 <ski> morally, we want
11:45:42 <ski> c_wraith : no
11:45:58 <ski>   unwrapShowable :: Showable -> exists a. Show a *> a
11:46:11 <iskren> ski, but this is not pure haskell ...
11:46:26 <ski> the caller doesn't get to decide which type `a' to use, as would be the case with c_wraith's version
11:46:40 <c_wraith> ski, my version uses a rank-2 type.  the caller doesn't get to decide
11:46:58 <ski> the callee decides, based on what type is inside the argument of type `Showable'
11:47:29 <ski> c_wraith : `Showable -> forall a. Show a => a' is equivalent to `forall a. Show a => Showable -> a' (in fact GHC will internally rewrite it into that)
11:47:41 <ski> iskren : so, the problem with
11:47:43 <ski>   unwrapShowable :: Showable -> exists a. Show a *> a
11:47:51 <ski> is that this is only pseudo-haskell
11:48:04 <ski> to encode this in haskell, we need to invent a new type for `exists a. Show a *> a'
11:48:07 <ski> so that we get
11:48:14 <ski>   unwrapShowable :: Showable -> Showable2
11:48:33 <ski> or we could reuse the same type `Showable' instead of making a new equivalent type `Showable2'
11:48:42 <ski> the point is that this gets us nowhere, in this case
11:48:52 <iskren> you mean the Sowable2?
11:49:11 <ski> yeah, we have the exact same problem with `Showable2' as with `Showable'
11:49:17 <ski> those being defined as
11:49:26 <ski>   data Showable = forall a. Show a => WrapShowable a
11:49:29 <ski>   data Showable2 = forall a. Show a => WrapShowable2 a
11:49:35 <ski> so it's basically the same type
11:50:17 <ski> iskren : you see how the problem is just recreated again ?
11:50:36 <iskren> well, the actual problem is that we cannot write the "pseudo haskell" as I see it
11:50:55 <ski> the only way to sensibly make the `a' type "escape" is to use an `exists'
11:50:56 <iskren> because if we could, we would write the unwrapping function ourselves
11:51:17 <ski> but to qactually encode that in current Haskell (with extensions), we need to invent a new type, exactly like the one we had (or reuse the old type)
11:51:25 <ski> yes
11:51:30 <ski> what we actually *can* do is start with
11:51:32 <ski>   unwrapShowable :: Showable -> exists a. Show a *> a
11:51:42 <ski> then rewrite this to the equivalent
11:52:07 <ski>   callWithUnwrappedShowable :: Showable -> ((exists a. Show a *> a) -> b) -> b
11:52:24 <erus`> what are some reasons NOT to use haskell in industry?
11:52:34 <ski> so, instead of returning the value, we call a callback (a continuation function) with it, and then we return whatever that returns
11:52:43 <ski> now, we can rewrite
11:52:44 <ski>   callWithUnwrappedShowable :: Showable -> ((exists a. Show a *> a) -> b) -> b
11:52:48 <ski> to the logically equivalent
11:52:57 <iskren> this was complicated
11:53:02 <ski>   callWithUnwrappedShowable :: Showable -> (forall a. Show a => (a -> b)) -> b
11:53:04 <ski> or simply just
11:53:07 <soulthreads> erus`, fear of suppirting this.
11:53:08 <ski>   callWithUnwrappedShowable :: Showable -> (forall a. Show a => a -> b) -> b
11:53:25 <ski> and *this* we can write in haskell (with extensions, specifically `Rank2Types')
11:53:42 <erus`> haha
11:53:50 <ski> iskren : this is the best approximation we can have in current Haskell, for unwrapping existential data types
11:54:28 <iskren> is this going to change in the future? I mean to have exists like a keyword (like forall)
11:54:38 <ski> iskren : i know some experimental compilers for Haskell actually allow `exists' as a keyword .. but sadly *not* in the return type of a function (which is what we want here)
11:54:38 <lunaris> Unlikely.
11:54:46 <iskren> and you don't have to type *> .. just =>
11:54:57 <ski> btw, `*>' is different from `=>'
11:55:28 <ski> (`*>' is just pseudo-code here, but it has a different meaning than `=>')
11:56:04 <Eduard_Munteanu> ski: I thought they merely accepted exists as an alias for foralls in existentials
11:56:08 <Kaidelong> erus`: lots of reasons, one is finding haskell programmers can be hard, but this is starting to change. Another is that there may be no existing or too many "standard" ways to use haskell in some particular niche, as opposed to something like Java or PHP where there is a consensus on how to accomplish something no matter how terrible
11:56:19 <ski> if you have an operation of type `IsFoo a => Bar a', this means that if *you* provide an instance of `IsFoo' for `a', then the operation will give you an `Bar a'
11:56:47 <ski> iskren : but if you have an operation of type `IsFoo a *> Bar a', then it means that *that* operation is providing the instance of `IsFoo' for `a'
11:56:48 <Kaidelong> but until relatively recently there wasn't one true way to do serialization, for example
11:57:15 <Kaidelong> also there is no one web framework
11:57:16 <iskren> ski, what about the Bar a then
11:57:23 <Peaker_> erus`: this is my take on the problems with Haskell today: http://www.reddit.com/r/haskell/comments/hezgk/haskell_singularity_approaching/c1uwd75
11:57:31 <ski> Eduard_Munteanu : the one i heard about allowed `(exists a. ..a..) -> ...', interpreting it as `forall a. (..a.. -> ...'
11:57:56 <ski> Eduard_Munteanu : so i think you could have type synonyms expanding to `exists a. ..a..', as long as you only used them in argument positions in function types
11:59:02 <ski> iskren : consider `frob0 :: forall a. IsFoo a => Bar a' -- here you (the caller) chooses the type `a', and you also provide the instance `IsFoo a', and you get back an `Bar a'
11:59:17 <iskren> ski, I now understood the "callback" stuff and the transformation of exists to forall
11:59:31 <ski> iskren : now `frob1 :: forall a. IsFoo a *> Bar a' -- here you (the caller) chooses the type `a', and the operation itself will provide the instance `IsFoo a' *and* you get back an `Bar a'
12:00:29 <iskren> but if the caller chooses a type that does not support IsFoo .. how can the operation provide the instance
12:00:41 <ski> iskren : in that case one may wonder how the heck the operation can provide an instance `IsFoo a', for any type `a' that *you* choose .. presumably it uses a "catch all" `instance IsFoo a where ..'
12:01:31 <ski> iskren : then `frob2 :: exists a. IsFoo a *> Bar a' -- here the operation will decide the type `a', and now *you* have to provide the instance `IsFoo a' to be able to get back an `Bar a'
12:01:33 <iskren> where all functions in the IsFoo are undefined or something
12:02:19 <ski> (not necessarily, there could be a single sensible implementation that works for all types .. but then one wonders why to use a class in the first place)
12:03:00 <ski> iskren : this `frob2' case, it's also strange, since you have to construct an instance `IsFoo a' for a type `a' which you know nothing about
12:03:08 <iskren> the frob2 is unclear. How can I provide an instance for something that the compiler chooses ... I mean, this is like void * but hidden very well :)
12:03:34 <iskren> by "me" you mean the compiler at the calling site right?
12:03:39 <ski> sorry, s/frob2 :: exists a. IsFoo a *> Bar a/frob2 :: exists a. IsFoo a => Bar a/
12:03:49 <ski> iskren : yes, the caller of the operation
12:04:13 <iskren> but this is decided runtime, not compile time, or?
12:04:18 <ski> iskren : the final case is `frob3 :: exists a. IsFoo a *> Bar a', in this case the operation both provides the type `a', the instance `IsFoo a', and the value of type `Bar a'
12:04:29 <ski> yes, the operation can decide at runtime
12:04:32 <ski> you can have
12:04:53 <ski>   frob :: Bool -> exists a. IsFoo a *> Bar a
12:05:08 <ski> and it will select the type it uses depending on the value of the boolean
12:05:34 <ski> now, the four cases i listed above are just the four simplest ways to use these
12:05:53 <ski> the two middle cases here were pretty degenerated, not very interesting
12:06:09 <ski> it's more interesting to combine `forall' and `exists' and `=>' and `*>' in the same operation
12:06:12 <ski> like
12:06:55 <ski>   frob :: forall a. C a => F a -> exists b. D a b *> G a b
12:07:44 <ski> this operation, given any type `a', in class `C', and a value of type `F a', will produce a type `b' (which type it is can depend both on the type `a' and which value of type `F a' was passed)
12:08:07 <ski> and it will provide an instance of `D a b' for us (the caller), together with some value of type `G a b'
12:08:55 <iskren> so all the new types that are returned are somewhat handled by the compiler, I cannot deal with them in a more straight forward way
12:09:10 <iskren> and why can't I use exists and *>... is it considered complicated?
12:09:22 <ski> the only thing you (the caller) will know about `b' is that `D a b' (for the `a' you used in the call) holds
12:09:53 <iskren> and all such new type creations must be filtered through a case
12:10:11 <ski> (a) `exists' and `*>' syntax is not implemented .. you can express mostly the same thing with "existential data types", even though it's clunkier
12:10:41 <ski> (b) yes, adding full support for `exists' (and `*>') would complicate the type-checker
12:10:53 <ski> probably noone knows of a good way to do it, yet
12:11:12 <iskren> to do the type-checker or to introduce exists and *>
12:11:26 <ski> (a way might be discovered to make it work in a reasonable way, so we might get this in future versions)
12:11:51 <ski> to change the type-checker to correctly handle the introduced `exists' and `*>' :)
12:12:22 <ski> consider you writing the code
12:12:39 <ski>   foo False = ("abc",id)
12:13:11 <ski>   foo True  = (False,show :: Bool -> String)
12:13:19 <ski> which type should be inferred for `foo' ?
12:13:27 <ski> the one we might have in mind in this case is
12:13:45 <ski>   foo :: Bool -> exists x. (x,x -> String)
12:14:11 <ski> but consider now instead
12:14:17 <ski>   foo False = "abc"
12:14:24 <ski>   foo True  = False
12:14:32 <ski> we might now have in mind
12:14:40 <ski>   foo :: Bool -> exists x. Show x *> x
12:15:07 <iskren> well, for those cases I guess the programmer should provide the type signature ...
12:15:07 <ski> so that each result here will carry with it the `Show x' instance, so that we can `show' the result of the function
12:15:19 <ski> but the type-inferencer could just as well infer
12:15:25 <ski>   foo :: Bool -> exists x. Eq x *> x
12:15:26 <ski> or
12:15:29 <ski>   foo :: Bool -> exists x. Ord x *> x
12:15:30 <ski> or
12:15:38 <ski>   foo :: Bool -> exists x. (Ord x,Show x) *> x
12:15:40 <ski> &c.
12:15:43 <iskren> why not just exists x. *> x
12:15:51 <ski> because that's useless
12:15:55 <ski> if you have
12:15:59 <ski>   foo :: Bool -> exists x. x
12:16:03 <ski> you might as well have
12:16:05 <ski>   foo :: Bool -> ()
12:16:31 <ski> if you have `exists x. x' you can do nothing with the `x' inside, since you have no idea what type it is
12:16:58 <ski> if you have `exists x. (x,x -> String)' you can at least pass the first part as argument to the second part, since you know that's the same type
12:17:11 <iskren> I see... but the user providing the signature seems like a good solution, I mean -- this is complicated already, why should the type-checker understand it for himself
12:17:26 <ski> if you have `exists x. C a *> x' you can apply all the methods of class `C' to the `x'
12:17:54 * hackagebot fix-imports 0.1.1 - Program to manage the imports of a haskell module  http://hackage.haskell.org/package/fix-imports-0.1.1 (EvanLaforge)
12:18:00 <eddayyy> is there a way of forcing a value to UTF-8 encoding?
12:18:08 <ski> iskren : yes, especially since that is already required in some other cases (polynorphic recursion, which is in Haskell98 ; and GADTs, which is an extension)
12:18:37 <ski> iskren : but someone needs to figure out a nice reasonable way for the type-checker to do this :)
12:18:54 <iskren> even with user defined type?
12:19:04 <ion> eddayyy: A value? Such as (42, Just True)?
12:19:05 <ski> i'm not sure what you mean ?
12:19:39 <eddayyy> ion: no, a bytestring sorry, i'm not sure what encoding its currently in but I'm getting a decodeUtf8 error whilst converting some data to JSON
12:20:16 <ion> If you knew what encoding it uses currently, you could convert it to UTF-8.
12:20:38 <ski> iskren : so, i'm waiting and hoping for someone to do this in a later version :)
12:20:43 <eddayyy> ion: Cannot decode byte '\x88': Data.Text.Encoding.decodeUtf8: Invalid UTF-8 stream
12:20:46 <iskren> ski, I mean -- if this case is already complicated, the user specifying the type would still complicate the type checker, because it would have to check it nevertheless ?
12:20:56 <ski> iskren : meanwhile, we have to make ado with the "existential data type" wrappings
12:20:58 <eddayyy> ion: is there a way to find out what encoding thats in?
12:21:55 <ski> iskren : yes it would complicate the type-checker, but it should be simpler to *check* a type signature with `exists' in it, than to *infer* it (at least i hope so)
12:22:23 <iskren> aha, so even checking it is complicated, I see :)
12:22:44 <ski> iskren : well, you're welcome to ponder how to check it :)
12:22:46 <iskren> well, the type-checker is remarkable already :)
12:23:28 <ski> iskren : i know that Mercury has `exists' (they call it `some'), but i'm not aware of the details of how they do it, and whether they have any large restrictions in how you can use it
12:23:42 <Saizan> type systems where the existential quantifier has a corresponding data constructor are fairly well known, though i think the annotation should be enough
12:24:23 <iskren> hm, I thought GHC is the best :)
12:24:36 <iskren> having everything one can imagine :)
12:24:39 <tiffany> How many haskell compilers are there?
12:24:52 <Saizan> what's a bit fishy is that the runtime representation of True :: Bool and True :: exists a. Show a *> a would differ
12:25:35 <ion> eddayyy: Where did the bytestring come from?
12:25:43 <ski> iskren : Mercury is a separate language <http://www.mercury.csse.unimelb.edu.au/>, which has borrowed Haskell's type-classes
12:25:44 <parcs> tiffany: ghc, jhc and uhc. there's hugs, but that's an interpreter
12:25:52 <tiffany> which is fastest?
12:25:55 <tiffany> ghc I'm guessing?
12:26:01 <parcs> yep
12:26:11 <ski> iskren : <http://www.mercury.csse.unimelb.edu.au/information/doc-latest/mercury_ref/Existential-types.html>
12:26:27 <eddayyy> ion: a password salt / hash making function
12:26:49 <parcs> hmm there seems to be a bit more than those that i recognized: http://www.haskell.org/haskellwiki/Implementations
12:26:52 <ski> @where implementations
12:26:52 <lambdabot> <http://www.haskell.org/haskellwiki/Implementations>. Also see `GHC',`Hugs',`Helium',`UHC',`DDC',`LHC',`JHC',`YHC',`NHC',`HBC',`UHC',`YaleHaskell',`Brisk'
12:27:04 <Eduard_Munteanu> parcs: I'd rather say "there's Hugs, but it's rotten and smelly already" :)
12:27:11 <parcs> haha
12:27:48 <parcs> it's only 5 years old
12:27:53 <Eduard_Munteanu> Helium isn't exactly Haskell though.
12:27:55 <ski> Eduard_Munteanu : well, Hugs' "restricted type synonym" extension is nice (also it has TREX, i.e. light-weight extensible records)
12:28:22 <ion> eddayyy: Ah, so it’s not text content. You might want to e.g. base64-encode it.
12:28:56 <ddarius> Since we can encode existentials with higher rank types (especially given impredicative types) there are no real new complications.
12:29:24 <eddayyy> ion: hmm why?
12:29:30 <eddayyy> ion: my knowledge of encoding is the sux
12:29:51 <iskren> eddayyy, because it doesn't follow any encoding -- it is just a list of octets , you don't want to treat that as text :)
12:29:53 <ski> Eduard_Munteanu : <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.3.5>
12:30:23 <Eduard_Munteanu> Hrm, I didn't know about those, interesting.
12:30:30 <eddayyy> ion: I randomly guessed and decoded as Utf16LE, and now it works... however i'm not sure it hasn't destroyed the original bytestring...
12:30:31 <ion> eddayyy: UTF-8 is an encoding of text. If you have raw data of some kind, you’ll want to convert it to text one way or another. Base64 is one way to do it.
12:30:39 <Saizan> ddarius: existential wrappers and their higher-rank encodings already differ in how they interact with OverlappingInstances :\
12:30:43 <Eduard_Munteanu> I didn't see Hugs as a place for innovation...
12:30:43 <iskren> eddayyy, when you say encoding most of the time you mean text (human). And this salt/hash stuff is returning raw bytes (I suppose) and base64 is one way to convert "raw bytes" to text characters (ASCII)
12:30:53 <ion> eddayyy: UTF-16 is another text encoding.
12:31:09 <ddarius> Saizan: I blame OverlappingInstatces.
12:31:38 <ddarius> Eduard_Munteanu: It was a place originally, given the name.
12:31:54 <Saizan> ddarius: that's too easy to do!
12:31:55 <eddayyy> iskren, ion: so a good way to go would be to encode whatever this raw data is to base64, and be done with it
12:31:56 <eddayyy> ?
12:32:08 <Eduard_Munteanu> ddarius: I was under the impression existentials are related but somewhere fundamentally different from rank-2/n types
12:32:17 <eddayyy> i guess at least this gives me a guarantee that its not breaking the data in some way
12:32:18 <iskren> eddayyy, if you want some text out of it to send through JSON that should work
12:32:37 <kmc> Eduard_Munteanu, they're related by a continuation-passing transform
12:32:45 <iskren> eddayyy, I think base64 for raw bytes for JSON is pretty standart technique
12:33:00 <eddayyy> iskren: yeah i just never realised why i used it until now hehehhh :D
12:33:16 <Saizan> Eduard_Munteanu: exists a. C a *> ... ~~ forall r. (forall a. C a => ... -> r) -> r
12:33:19 <kmc> «∃a. T a»  ↔  «∀r. (∀a. T a → r) → r»
12:33:28 <ion> eddayyy: Base64 encoding results in ASCII text, and ASCII is a subset of UTF-8, so you can safely treat that as UTF-8 text.
12:33:59 <Eduard_Munteanu> Saizan: but does that hold for existential *data*types too?
12:34:01 <eddayyy> ion: wow awesome, that makes perfect sense
12:34:09 <eddayyy> ion: thanks alot it works now :)
12:34:37 <Saizan> Eduard_Munteanu: yes
12:35:04 <ddarius> The only benefit of local existentials (i.e. the ones in data types) is that they avoid the need for impredicativity.
12:35:18 <kmc> is it fair to say that the fold of an existential data type has a higher-rank type?
12:35:31 <kmc> is that the same as the CPS i described?
12:35:38 <Eduard_Munteanu> I remember TAPL said something like existentials contain type representations of the stuff being stored there.
12:36:02 <kmc> what does that mean?
12:36:11 <ski> kmc : should be rank-2, unless you use higher-rank inside the arguments of the constructor, i think
12:36:50 <Eduard_Munteanu> Anyway, isn't this related to our previous discussion of Agda vs Haskell existentials? If that were true, then a Sigma type would be "just as existential" as the Haskell stuff.
12:37:05 <Eduard_Munteanu> erm, just as useful
12:37:31 <Saizan> Eduard_Munteanu: that's just a peculiarity of the syntax used in TAPL, types can still be erased, because these existentials can be defined within System F
12:37:34 <Eduard_Munteanu> But ddarius and koninkje (IIRC) said the Agda stuff has some limitations.
12:37:36 <ddarius> Sigma types are not more or less useful that existential types.
12:37:45 <ddarius> They are just different.
12:37:54 <Eduard_Munteanu> Ah, yeah.
12:38:07 <Eduard_Munteanu> But it prevents abstraction, that's what I was hinting to.
12:38:33 <ddarius> It doesn't prevent it, it just doesn't provide it, by construction.
12:39:32 <Eduard_Munteanu> I see. And my understanding is higher rank polymorphism is just like that, no?
12:39:58 <Eduard_Munteanu> vs forall/exists in datatypes
12:40:31 <Saizan> higher-rank polymorphism is enough to define haskell-like existentials
12:41:10 <Saizan> also called "weak sums", while Agda's Sigmas are also known as "strong sums"
12:41:20 <ddarius> Eduard_Munteanu: No, neither are like (dependent) sigma/pi types at all.
12:42:50 <Eduard_Munteanu> Hrm, so then can I get Haskell-like existentials in Agda, say if I take the \forall r. (\forall a. a -> r) -> r    approach?
12:43:04 <ddarius> Not using pi types.
12:43:14 <ddarius> You can using polymorphic types.
12:43:53 <Eduard_Munteanu> Yeah, that's what I mean, without Agda's \exists which is just a sigma.
12:44:37 <Saizan> the problem in Agda is that you might be able to return 'a' itself depending on what 'r' is
12:45:13 <Eduard_Munteanu> Hm... yeah, there's no "existentially quantified variable escapes" red flag there.
12:46:17 <Eduard_Munteanu> But if the two are equivalent, then Haskell somehow prevents that when using the higher-rank polymorphism approach?
12:46:34 <dixie> benmachine: I think it complain about return type :( http://hpaste.org/47850  sorry for confusion
12:46:36 <Saizan> that check is still there, 'r' can't mention 'a', but if r = Set ..
12:46:41 <dixie> oops
12:47:49 <Eduard_Munteanu> Interesting.
12:49:13 <roconnor> So are bytestrings pinned in memory?
12:49:24 <c_wraith> roconnor: I think the answer to that is "sometimes"
12:49:28 <roconnor> :/
12:49:48 <Eduard_Munteanu> Still, I'm a bit confused, if I use something like   a, r : Set   then should I be able to recover Haskell semantics wrt existentials?
12:50:18 <Eduard_Munteanu> I mean, get proper abstraction.
12:50:19 <Saizan> i think so
12:51:21 <Eduard_Munteanu> Neat, thanks. So Agda won't be able to tell types match, instead of the whole "escapes" thingy.
12:52:15 * Eduard_Munteanu also did the existential <-> forall form equivalence proof as an exercise some time ago, but wasn't sure how it all fit together
12:54:06 <ski> Saizan : but if you return `a' itself, how much can you do with it ?
12:54:46 <pingveno> Is it possible to write imperative code in Haskell?
12:54:50 <Cale> pingveno: yes
12:54:52 <pingveno> (For evil people)
12:55:14 <Cale> In fact, it makes a pretty good imperative language, generally.
12:55:40 <Cale> because IO actions are first class, for example, so you can easily write your own control structures to suit your situation.
12:55:48 <merijn> pingveno: Not just for evil people
12:55:51 <ddarius> And by that, Cale mostly means that most imperative languages make bad imperative languages.
12:55:58 <Cale> haha, yes
12:56:00 * ski . o O ( <http://ncatlab.org/nlab/show/evil> )
12:56:10 * pingveno hasn't learned Haskell yet, so he wouldn't know.
12:56:16 <pingveno> It's on my TODO list.
12:56:28 <ski> pingveno : start today ?
12:56:30 <Cale> ski: haha!
12:56:46 <merijn> pingveno: I was going to write a compiler for an imperative language with haskell like type checking. But after thinking about it I realized I would just be reinventing Haskell's IO monad so I gave up and just continued writing haskell instead :>
12:57:22 <rohit> hey
12:57:53 <pingveno> merijn: I'm tempted to ask further questions, but I'll probably just sound like a n00b
12:58:05 <Cale> pingveno: We're n00b-friendly here :)
12:58:08 <Saizan> ski: at that point you can define proj1 : exists a. a -> Set; and proj2 : (x : exists a. a) -> proj1 x
12:58:38 <pingveno> Cale: n00b / (1 << 100)
12:58:48 <Saizan> ski: and then "let x = True :: exists a. a in proj2 x :: Bool"
12:58:54 <kakos> merijn: I once started working on a language called YC, which was to be to functional programming what C++ was to OO programming.
12:59:04 <ski> Saizan : i assume `exists a. a -> Set' is `(exists a. a) -> Set' there
12:59:22 <Saizan> ski: yep, sorry
12:59:29 <merijn> pingveno: I've seen people trying to troll on purpose here and giving up because people kept being friendly and helpful. I'm sure people will survive beginner questions :p
12:59:38 <merijn> kakos: An abomination?
12:59:49 <kmc> haha
13:00:04 <kakos> merijn: More or less.
13:00:06 <ski> Saizan : hm, i see. so if you know nothing about the value `x' of type `exists a. a', then `proj2' should be harmless -- if on the other hand you know something about `x' ..
13:00:20 <kakos> merijn: I'm not working on it anymore because of its nature as an abomination
13:00:37 <pingveno> merijn: Unfortunately, there's a difference between "beginner" and "read a few pages of Learn You A Haskell"
13:01:27 <ski> pingveno : would you like some pointers to tutorials/books ?
13:01:33 <Saizan> ski: yeah
13:01:33 <merijn> pingveno: The latter is already significantly past beginner :p
13:01:33 <tiffany> I was kind of wondering what kind of language haskell would be from the introduction in that
13:01:37 <pingveno> Reading through some Haskell code as well, but that doesn't really count.
13:01:46 <kakos> Learn You a Haskell For Great Good is actually really good.
13:01:47 <ski> pingveno : ah, i see you've already found LYAH :)
13:01:52 <tiffany> and then when I started getting further into that book, I realised how epic this language is
13:02:10 <merijn> Beginner is coming here asking confused questions about how get stuff out of IO and saying that everything is so much easier in PHP :p
13:02:16 <tiffany> I love how everything's a function
13:02:19 <tiffany> it's awesome :D
13:02:31 <merijn> tiffany: Except of course not everything is a function :>
13:02:40 <tiffany> well yeah
13:02:44 <tiffany> everything's like, an expression
13:02:51 <Cale> yeah, that's truer :)
13:02:53 <tiffany> idk, it's awesome :3
13:02:55 <Cale> Everything is a value
13:02:58 <Cale> (almost)
13:03:02 <merijn> Everything is a value, it's just that expressions and functions are first class values :p
13:03:12 <kmc> lots of things aren't first-class and aren't values in Haskell
13:03:13 <pingveno> I still haven't really done much with IO...
13:03:25 <Cale> kmc: shhhh :)
13:03:28 <Cale> hehe
13:03:28 <copumpkin> types aren't values in haskell!
13:03:30 <copumpkin> the horror!
13:03:37 <kmc> indeed
13:03:38 <ski> merijn : expressions aren't values. expressions evaluate to values
13:03:38 <Cale> Indeed, and patterns aren't values!
13:03:42 <kmc> copumpkin is, like, so over Haskell
13:03:42 <pingveno> A few uses of <- in xmonad configuration files doesn't count
13:03:45 <merijn> copumpkin: My pet peeve
13:03:46 <Cale> and typeclasses aren't values
13:03:53 <thoughtpolice> modules aren't first-class, either. :(
13:03:55 <ski> copumpkin : it's more irritating that you can't abstract over patterns
13:03:58 <merijn> I want my dependent types dammit :<
13:04:23 <pingveno> Is <- usage in xmonad.hs usually interacting with an IO monad?
13:04:41 <kmc> it's interacting with the X monad, usually
13:04:48 <Cale> pingveno: I think it's mostly a monad which has a little extra stuff, but is built on top of IO
13:04:50 <Cale> yeah
13:04:52 <kmc> which is built from the IO monad and ReaderT and StateT transformers
13:04:52 <merijn> pingveno: <- is syntactic sugar for interacting with any monad (the Xmonad in this case :p)
13:04:53 <Eduard_Munteanu> They are a bit, in the STLC at the type-level
13:04:54 <ski> pingveno : iirc, they have a monad of their own (called `XMonad' ?), which incorporates `IO'
13:04:59 <kmc> it's just called X
13:05:03 <ski> ok
13:05:04 <Cale> I don't use Xmonad, but I understand that it literally has a monad named X in it :)
13:05:15 <kmc> it's not "an IO monad", by the way... there is only one IO monad, it is the type named "IO"
13:05:22 * dependentpumpkin looks smug
13:05:29 <tiffany> does haskell have classes? I never really read of the table of contents and I'm not very far into this :p
13:05:34 <kmc> a monad is just a type supporting a certain API
13:05:37 <Cale> kmc: You could say "an IO monad" to mean any monad with an instance of MonadIO :)
13:05:40 <merijn> tiffany: Not in the OO sense
13:05:41 <thoughtpolice> dependentpumpkin: quickly, to the agda-mobile! i hear it has a haskell FFI, so we can still be practical while mocking from an ivory tower
13:05:42 <kmc> tiffany, it does not have classes in the sense of Java or Python
13:05:42 <dependentpumpkin> tiffany: it has things called classes, but they're nothing like what you're expecting
13:05:45 <dependentpumpkin> lol
13:05:59 <ddarius> ski: If Bondi did the newer dynamic pattern calculus stuff and wasn't based on ML syntax, it would be amazing (not that it isn't amazing)
13:06:02 <kmc> you can do OOP in Haskell but it's done with ordinary data and functions, much more powerful and simpler imo
13:06:03 <Cale> in which case, he's right :)
13:06:09 <ski> tiffany : it has "type classes", which are very different from "classes" in class-based OO languages
13:06:17 <kmc> "type classes" are kind of like interfaces, but they're also notoriously over-used by beginners
13:06:20 <tiffany> classes in the sense of "MilkJug" can have the method "Pour" and the value "Milk"
13:06:32 <pingveno> learnThisSummer(random.choice([scala, haskell]))
13:06:38 <kmc> MilkJug would just be a data type with two values, one of which happens to be a function
13:06:43 <merijn> tiffany: But mostly you want either records or polymorphism and Haskell has more convenient solutions then class for both
13:06:46 <Eduard_Munteanu> Yeah, there is a bit of similarity with OO classes.
13:06:49 <ski> ddarius : <http://www-staff.it.uts.edu.au/~cbj/patterns/> ?
13:06:53 <parcs> tiffany: haskell doesn't have what you call methods, either
13:07:01 <tiffany> :d
13:07:02 <merijn> tiffany: You can have a Milk type with a Pour record which happens to be a function
13:07:03 <Cale> You can do what I consider to be the central essence of OO in Haskell, but it doesn't include some things that people naturally associate with OO
13:07:06 <Eduard_Munteanu> But the encoding of OO classes doesn't stop there.
13:07:07 <Cale> like inheritance
13:07:16 <dependentpumpkin> tiffany: haskell is a completely different language from most others
13:07:20 <tiffany> mm
13:07:20 <dependentpumpkin> so concepts don't really carry over
13:07:32 <ddarius> ski: Yes that stuff, though one of the newer papers is only available from Delia Kesner's site.
13:07:32 <dependentpumpkin> you're used to thinking in objects and classes
13:07:40 <dependentpumpkin> and it doesn't really fit the way you do things in haskell
13:07:40 <ddarius> (Even though it was coauthor with Barry Jay.)
13:07:45 <ski> tiffany : "type classes" are somewhat similar (but only somewhat) to "interfaces" in Java and C#
13:07:50 <c_wraith> pumpkin, shouldn't you be co-, making you a codependentpumpkin in this case?
13:07:51 <tiffany> I like to think as programming lower level than it really is
13:07:57 <tiffany> which usually ends up bad
13:08:04 * c_wraith starts wondering what codependent types would be like
13:08:19 <Cale> The central defining feature of OOP, in my eyes, is that values are distinguished from each other by how they respond to each of a set of "messages"
13:08:22 <merijn> c_wraith: You just hurt my brain :(
13:08:24 <ddarius> @quote codependent
13:08:24 <lambdabot> No quotes match. Are you on drugs?
13:08:28 <kmc> hehe
13:08:30 <Eduard_Munteanu> OO is a subset of that, in Haskell you get to do your own arbitrary dispatch. If you want you can also think of capabilities instead of objects.
13:08:31 <tiffany> .-.
13:08:46 <dino-> It's all ok though. you could put the pour function in a module MilkJug. If what you're after here is namespacing and exposing/not-exposing functionality.
13:08:48 <pingveno> Totally random and off topic question: Does anyone know of a Freenode channel about ergonomics?
13:08:49 <kmc> tiffany, I think it's best to approach Haskell as a totally different world, and find the parallels to other languages only once you're confident with the Haskell side
13:09:15 <kmc> a lot of people hear "type classes are like Java interfaces" and end up writing code which uses way too many type classes
13:09:20 <Cale> Yeah, just forget that you already know how to program :)
13:09:23 <kmc> ;)
13:09:27 <kmc> i recommend booze
13:09:28 <dino-> Encapsulation: not exclusive to OO
13:09:31 <pingveno> kmc: Is reading Haskell code a good start?
13:09:35 <kmc> maybe?
13:09:42 <kmc> read a little and write a little
13:09:46 <merijn> pingveno: If it is well written :p
13:09:46 <kmc> don't read a ton before you write any
13:09:49 <tiffany> haskell code is mindrape :x
13:09:54 <ski> c_wraith : types like `(cont k : A) + ..k..' where `k' is a continuation of type `A'
13:09:59 <Peaker_> kmc: I think Haskell's stdlibs use far too few typeclasses
13:10:08 <c_wraith> booze is good for haskell programming.  So long as you test when sober...  If it compiles and passes some cursory tests when you're sober, the haskell code written when you were drunk is probably good. :)
13:10:08 <kmc> the thing is, Java gives you very few options for abstraction.  Haskell has analogues of some of them, but it also has other mechanisms you wouldn't see in Java
13:10:12 <roconnor> well, my program definitely runs in less memory with [Word8] instead of ByteStrings.
13:10:16 <dino-> kmc: That's why I try to avoid the typeclass <-> interface analogy, too. :(
13:10:16 <Cale> tiffany: Especially the fun things we play with around here :)
13:10:20 <roconnor> (in particular spots)
13:10:21 <merijn> pingveno: The best way is to install GHC, open the interactive interpreter (ghci) and start reading "Learn You a Haskell" and experiment as you go
13:10:25 <Cale> Like   fix ((0:) . scanl (+) 1)
13:10:29 <kmc> so if you translate Java thinking to Haskell, you use an awkward subset of Haskell
13:10:34 <Cale> > fix ((0:) . scanl (+) 1)
13:10:34 <pingveno> I remember a professor at my school trying to teach the CS 16x classes in Haskell.
13:10:36 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:10:40 <pingveno> There was not much rejoicing.
13:10:58 <merijn> pingveno: That's because people are unambitious :p
13:11:01 <pingveno> No one has let him touch the 16x classes since then.
13:11:06 <dino-> pingveno: bah
13:11:14 <kmc> what is CS 16x?
13:11:17 <merijn> pingveno: I've learned more from hanging out here for a year then I did in 4 years of formal CS education :>
13:11:21 <thoughtpolice> c_wraith: i can definitely trust the code i write while drunk moreso if it's written in haskell, yes
13:11:22 <ddarius> roconnor: If your bytestrings are really small, lists are more space-efficeint.
13:11:23 <pingveno> 161, 162, 163
13:11:34 <kmc> I'm not sold on Haskell being a good choice for beginners, even if they're willing to cleanse their mind of external thought blah blah
13:11:40 <pingveno> merijn: It was more that he gave them 0 help in learning Haskell.
13:11:41 <kmc> I think it's still a pretty big language as languages go
13:11:52 <c_wraith> thoughtpolice: the one library I have on hackage with many users outside my company was mostly written while drunk. :)
13:11:55 <thoughtpolice> roconnor: i think bytestrings have an overhead of 20 bytes per ByteString, iirc
13:12:07 <pingveno> He just kinda expected everyone to magically learn it because, hey, it's easy for him.
13:12:07 <thoughtpolice> c_wraith: and which one was that? :P
13:12:15 <Peaker_> kmc: The value side of Haskell is pretty tiny.. The type side a little big maybe
13:12:19 <c_wraith> thoughtpolice: lrucache
13:12:31 <Cale> pingveno: I think some people like to do that because most people don't know Haskell and so it gives a level playing field for the students, except that with Haskell, it sort of gives an advantage to the non-programmers, I think.
13:12:36 <kmc> Peaker_, well, there's much more syntax than, say, Scheme
13:12:38 <tiffany> the thing I wonder about most programming languages is why are they all so much slower than C/C++?
13:12:47 <kmc> they're not
13:12:51 <Peaker_> kmc: That's more because Scheme is super-tiny than because Haskell is big :)
13:12:53 <merijn> kmc: I agree, I prefer python for beginners. Because it is more "conventional" while the community still encourages good habits (first class functions, not everything has to be a class, etc)
13:12:55 <kmc> first of all, languages don't have speed
13:12:57 <kmc> implementations do
13:13:11 <monochrom> scheme is too small. lacks pattern matching
13:13:12 <pingveno> I take that back on all of the 160's
13:13:20 <pingveno> It was just 163.
13:13:25 <ddarius> kmc: Actually, I'd say that syntax of Scheme and Haskell are about comparable, and most of the "excess" in Haskell is rather superficial.
13:13:27 <tiffany> well yeah
13:13:31 <tiffany> http://shootout.alioth.debian.org/u64q/which-programming-languages-are-fastest.php?gcc=on&gpp=on&go=on&ghc=on&python3=on&yarv=on&calc=chart
13:13:36 <kmc> tiffany, if the question is "why does most Python or Ruby code run slowly" then the answer is that Python and Ruby are usually run through terrible interpreters
13:13:45 <kmc> but there are good interpreters for Lua and Javascript
13:13:47 <dino-> Haskell big? huh, coming from where I came from it looked so small and focused.
13:13:52 <kmc> and good JIT VMs for Java
13:13:53 <Peaker_> tiffany: GC is an example feature that can have a performance cost that C and C++ can avoid paying because they don't have it. But it costs you in safety/reliability and programmer difficulty
13:13:57 <kmc> and good compilers for Haskell and ML
13:13:58 <thoughtpolice> tiffany: some language implementations are really fast. mlton is pretty fast, GHC is pretty fast, luajit is really fast, stalin scheme is really fast (R4RS modulo eval only though)
13:14:11 <companion_cube> is MLton still used ?
13:14:17 <kmc> such that cleverly written Haskell or ML or Java code gets pretty close to C, and is less buggy and easier to write
13:14:19 <Peaker_> C and C++ also expose the cost model of the underlying system better than other languages (indirections are expensive and are explicit in C)
13:14:20 <ski> monochrom : how about Racket ?
13:14:27 <monochrom> I don't know racket
13:14:30 <pingveno> Remember, Haskell is easier for experienced programmers than for a relatively experienced programmer.
13:14:36 <Cale> tiffany: Mostly because C is old, so 1) its best implementations are quite good and 2) is does not provide much abstraction over the standard machine model, and hence allows clever humans to easily use/abuse details of how the machine works.
13:14:40 <tgeeky> can someone take a look at the [Facts] package, and tell me what the purpose of making these things instantiate [Data, Typeable]...?
13:14:43 <Peaker_> kmc: it's easier to make C code fast than Haskell code fast.. But harder to get it correct
13:14:44 <tgeeky> http://hackage.haskell.org/packages/archive/Facts/0.1.2/doc/html/Facts-Geography-Countries-UnitedStates.html
13:14:58 <c_wraith> tgeeky: so they can be used with syb
13:15:01 <kmc> tgeeky, it lets you do "generic programming" over them.  see "Scrap Your Boilerplate" papers / docs and the "syb" library
13:15:10 <kmc> and the base modules Data.Data and Data.Typeable
13:15:13 <ddarius> tgeeky: You pretty much always want to derive Data and Typeable.
13:15:17 <kmc> Typeable also lets you do other things, like dynamic typing
13:15:18 <thoughtpolice> companion_cube: there was a release last year after a 3 year haitus or so. SML as a language is codified, i.e. dead, so it mainly sees maintenance. but MLton still produces pretty fast programs (it shows off better for large programs as oppsoed to small ones, cuz MLton does tons of fancy whole-program optimizations)
13:15:21 <tiffany> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=gpp
13:15:32 <tiffany> It's nice that haskell can get things done in 1/3 the code
13:15:33 <Peaker_> Linus Torvalds had a rant I mostly agree with about how GC encourages "pointer chasing" which is becoming more and more expensive with hardware advancements
13:15:40 <pingveno> The Shootout is now full of fail.
13:15:48 <tiffany> really?
13:15:49 <kmc> Linus Torvalds has a lot of rants
13:15:55 <copumpkin> pingveno: OMG YOU CALLED IT THE SHOOTOUT
13:15:57 <Cale> tiffany: and that's messy low-level Haskell code in a lot of cases
13:15:58 * copumpkin shoots pingveno 
13:15:58 <pingveno> Or did its maintainer add back in alternative implementations?
13:15:58 <Peaker_> kmc: some of them are interesting/useful
13:16:13 <tgeeky> ok, then additional question. He sets up a bijection between (StateAbbreviation, StateName) - but I'm doing a periodic table, I have a ... tri-jection? Of (Atomic#, ElementAbbrev, ElementName)?
13:16:13 <ski> monochrom : Racket was called DrScheme before, it's an implementation of Scheme (and more), with pattern-matching (and more)
13:16:17 <tiffany> The 434 byte DeCSS implementation is pure mindrape
13:16:22 <tiffany> seroiusly
13:16:24 <Cale> tiffany: It's usually a good deal shorter than that, at practical amounts of effort to obtain speed :)
13:16:25 <pingveno> Note the complete lack of PyPy.
13:16:26 <Peaker_> GC sure is nice on the programmer side -- but I can't help but dislike it on the operational/machine side
13:16:32 <tgeeky> so I just implement that with a series of bijections?
13:16:38 <monochrom> scheme plus pattern matching is just about right
13:16:39 <pingveno> LuaJIT? Gone.
13:16:48 <tiffany> I wonder why ASM isn't on here...
13:16:51 <thoughtpolice> companion_cube: but for example, mlton compiles itself (something like, 300-400k lines) in little under an hour in ~1.5-2gb of RAM, which is pretty damn good i'd say considering the entire program is in scope at the time of optimization
13:16:52 <ddarius> tiffany seems to have a predilection for mindrape.
13:17:04 <Cale> tiffany: I've written Haskell programs that were easily 10 times shorter than the equivalent C code would be (and where if I'd tried to write the program in C, I'd never have finished it myself)
13:17:11 <pingveno> There's another problem with the Shootout: The examples are highly contrived.
13:17:28 <Peaker_> tiffany: C makes it really easy to inline ASM where it is useful, so it is not a huge boost in performance to use ASM over C, but C is much higher/nicer to use
13:17:32 <nus> @where berp
13:17:32 <lambdabot> I know nothing about berp.
13:17:39 <ben> Is there a cleverer way to say nums <- fmap (map read) getArgs :: IO [Int]?
13:17:45 <roconnor> ddarius: Hmm, some are 4 bytes and 1 byte, but most are arounc 72 bytes.
13:17:54 <merijn> tiffany: I saw a full IP stack implemented in less then 140 chars (i.e. small enough to fit in a tweet :p)
13:17:55 <Peaker_> ben: I prefer:  (fmap . map) read getArgs
13:18:01 <companion_cube> interesting, thoughtpolice. i wish the coders of mlton could contribute to the ocaml compiler to make it fast too
13:18:04 <tiffany> o.o
13:18:07 <roconnor> ddarius: I was thinking of switching to UArray Word8
13:18:09 <Peaker_> @where SEC
13:18:09 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
13:18:19 <ddarius> roconnor: Why?
13:18:20 <Peaker_> ben: because it is a special case of SECs ^^
13:18:31 <ski> Peaker_ : what do you think about region inference ?
13:18:33 <Cale> In particular, one of the larger Haskell projects that I did was a pipeline scheduler and register allocator for PPC+Altivec assembly, which came to around 1200 lines total, but would easily have been a 50k line C program.
13:18:34 <roconnor> ddarius: I'm worried that the bytestrings are getting pinned and fragmenting my heap
13:18:35 <tiffany> http://en.wikipedia.org/wiki/Illegal_prime#The_first_illegal_executable_prime_number <-- that is epic win
13:18:44 <ben> I was thinking of map read -> nums <- getArgs but I wasn't sure where to put the type signature
13:19:11 <Peaker_> ski: I have only read Oleg's paper about implementing regions with polymorphic phantom types, iirc, which was interesting but I'm doubtful the idea can replace GC altogether (I haven't thought about it enough, though)
13:19:46 <ben> Peaker_: Wait what is SEC
13:19:53 <Peaker_> ben: See @where SEC above
13:20:06 <ski> Peaker_ : the ML Kit compiler uses region inference. the original version had no GC at all, but it was added to be able to reclaim memory allocated in (e.g.) the top-most region
13:20:13 <Cale> tiffany: Yeah, though the fact that it's on Wikipedia and Wikipedia doesn't seem to be in any trouble for distributing it makes the illegality of the number questionable :)
13:20:14 <ben> Oh dear I missed that, sorry
13:20:26 <kmc> lots of laws aren't enforced
13:20:43 <Peaker_> ski: Cool!  How does it do the equivalent of dynamic allocations in C?
13:20:46 <Cale> Unenforced laws are not really laws. :P
13:20:46 <ddarius> Unenforced laws are not laws.
13:20:56 <tiffany> I don't know, being arrested for having a prime number on your HDD sounds pretty silly
13:21:05 <Peaker_> ski: I guess if you have cheap user threads, you can arrange for all allocations to be in "regions"
13:21:05 <kmc> most laws are not enforced as hard as possible
13:21:12 <tiffany> or even better, having the number of which prime it is
13:21:13 <kmc> if i get away with murder does that prove murder is legal?
13:21:14 <Peaker_> But I'm not sure
13:21:23 <ddarius> tiffany: A movie is just a number on your HDD.
13:21:28 <tiffany> :P
13:21:35 <Cale> A lot of numbers are prime. I have enough music on my computer that probably many of the songs correspond to prime numbers in at least some encoding.
13:21:46 <ddarius> kmc: Just because you get away with it doesn't mean the law isn't enforced.
13:22:10 <ski> Peaker_ : it infers in which region it should allocate stuff. the region in which it allocates something doesn't have to be the newest region, which is how it differs from ordinary stack-allocation
13:22:14 <kmc> it seems an arbitrary distinction -- if someone, somewhere, was once busted for something, then the law exists, otherwise it doesn't really?
13:22:43 <ddarius> Peaker_: Pure region systems tend to have problems.  Fluet's thesis describes a system with more flexibility.
13:23:28 <ddarius> kmc: It doesn't matter that the law was once enforced.  Presumably many old laws that are no longer enforced were enforced at one point.
13:23:29 <tiffany> It's pretty epic how CSS is in itself flawed
13:23:38 <tiffany> In order for it to be of any use it has to be useless
13:23:38 <ddarius> tiffany: Not really.
13:23:53 <tiffany> "In addition, structural flaws in CSS reduce the effective key length to only around 16 bits, allowing for CSS to be compromised in less than a minute by brute-force with a 450 MHz processor;[3] because a 450 MHz processor is the official minimum computational requirement for playing an unencrypted DVD-compliant MPEG-2 videostream, this effectively means that any computer that can decode a DVD entirely in software can also crack a CSS-encrypted DVD."
13:23:54 <dino-> Peaker_: oo, thanks for that SEC url (and thanks conal)  Reminds me of figuring out the type of (flip id)
13:24:31 <kmc> epic
13:24:47 <Peaker_> ski: but what if you have allocations that have lifespans with overlaps?   A<----B<===>A====>B ?
13:25:00 <Cale> tiffany: Well, this is a fundamental property of such schemes. They have to be flawed because you have to be able to play the media in some device. Anything which can be observed can be copied.
13:25:26 <Cale> It's a fundamental property of information
13:25:30 <ddarius> kmc: One aspect of the issue is that laws are rarely repealed, so there has to be some (other) mechanism for retiring obsolete laws.
13:25:36 <merijn> Cale: Not if you have homomorphic encryption!
13:25:47 <dino-> Cale: Oh I know this one: Information wants to go on vacation
13:25:57 <iskren> I want to use HUnit in my project, but I put all tests in one file and that makes me export things from modules I wouldn't normally export. Is the solution to define the tests inside each module, and export only the test structure, and in the testing file import all test structures and test them?
13:26:06 <tiffany> cale: This isn't the same, this is a cryptographic cypher with 40 bits of encryption, flawed so it only protects 16
13:26:09 <Cale> merijn: homomorphic encryption will let you transform information without being able to observe it
13:26:26 <tiffany> this brings its usefulness to near nothing because it's encrypting something that requires a processor that can crack it in under a minute
13:26:27 <Cale> tiffany: Yeah, so it's more broken than broken :)
13:26:31 <copumpkin> Cale: not very practically for now :P
13:26:32 <ddarius> kmc: Really, ultimately the system has human components in nearly every place.  Those humans can, and in many cases, do exercise their judgement.
13:26:36 <merijn> Cale: Oh yeah, bollocks
13:26:43 <joe6> are there any functions such as fst, snd, for a list? the head for the first element, the second = head . tail, the third = head . tail . tail
13:26:50 <koala_man> why don't they just set up viewing booths in video rental stores. you rent a stall, leave all your equipment and clothes outside, and watch the movie on their hardware with two security guards watching
13:26:53 <kmc> :t (!! 5)
13:26:53 <lambdabot> forall a. [a] -> a
13:27:05 <joe6> kmc, ok, thanks.
13:27:06 <Cale> tiffany: But even if it was a perfectly designed cryptographic system, it would still be flawed, because everyone who bought a DVD player would implicitly have the decryption key.
13:27:07 <kmc> koala_man, they have viewing booths in... some... video rental stores
13:27:19 <kmc> and yes, taking off your clothes is a common part of the procedure
13:27:38 <kmc> not sure about having two big men in uniforms in the booth with you
13:27:43 <kmc> but you can probably find the right video store for that
13:27:57 <monochrom> ha ha ha
13:27:58 <koala_man> awesome
13:28:00 <Nimatek> You have to pay extra for the 'two men in uniform'
13:28:12 <ski> iskren : an alternative is to create "shadow modules" behind each module, i.e. each module `Foo.Internal' has an associated module `Foo.Test'. `Foo.Internal' exports everything, then you make a wrapper `Foo' module which reexports from `Foo.Internal' the things you want to have public
13:28:23 <Cale> (and so would be able to decrypt the DVD simply by playing it)
13:28:49 <ddarius> Cale: Yes, DRM is a losing battle.
13:28:52 <iskren> ski, hm, this is an overkill for my purposes
13:29:12 <Cale> ddarius: I'm amazed that people even bother to attempt it
13:29:22 <Cale> How hard is this to understand?
13:29:37 <iskren> Cale, oh, people always attend stupid things (if they are backed by law)
13:29:47 <monochrom> very hard when money is at stake
13:30:30 <ski> Peaker_ : i don't recall
13:30:48 <pedro3005> what was that function that took a function a -> b -> c and a tuple (a, b) and evaluated f a b ?
13:30:52 <dino-> Cale: It's so much more than this logic, I think. It's knee-jerk fear of technology and more.
13:30:53 <kmc> :t uncurry
13:30:53 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
13:30:58 <pedro3005> thanks
13:31:13 <ddarius> I think it's the "customers" rather than the technology corporations involved that don't understand.
13:31:20 <kmc> DRM is not a "losing battle", the goal is just to make it harder and more expensive to crack each new format
13:31:22 <dino-> Terror that they can't stop this train any more than the railroad industry could stop automobiles (though I think they tried to)
13:31:41 <merijn> Cale: Do you live in the same world as me? In my world people still routinely get "1+1+1+1+1+1+1*0" wrong in facebook questions, seems a bit optimistic to assume they will understand why DRM will never work
13:32:09 <monochrom> choose your facebook friends carefully
13:32:30 <dino-> btw, allow me to take this moment to make every Kindle owner here feel guilty: you are part of the problem. I'm sorry, but it's true.
13:32:35 <merijn> monochrom: If I had a "no stupid" policy I wouldn't have many friends left :p
13:32:41 <ddarius> monochrom: All my facebook friends have been chosen by consultations with tea leaves.
13:32:46 <ben> @pl \x -> f x >> g x
13:32:46 <lambdabot> liftM2 (>>) f g
13:32:49 <ddarius> merijn: Is that a problem?
13:33:16 <c_wraith> kmc: but it doesn't work.  everything still only needs to be cracked once - and then the cracked version is better than the uncracked version
13:33:38 <sm> kmc: re your earlier overuse of type classes comment, when is it appropriate to use them ?
13:33:54 <Saizan> DRM would be scary if they managed to lock hardware so that it won't play DRM-free content
13:33:55 <kmc> sm, i don't have a simple guideline
13:34:00 <kmc> you have to weigh it against the alternatives
13:34:09 <merijn> ddarius: I still haven't forfeited my worldly possessions and give up my live to study the LC, so for now it is :p
13:34:09 * sm is considering using one
13:34:20 <kmc> just think "how would i do this without type classes"
13:34:21 <Cale> merijn: I usually assume that if people are going to spend hundreds of thousands or millions of dollars designing a system, they'll consider whether it's actually feasible.
13:34:22 <luite> Saizan: they have been doing that to some extent with blu-ray players
13:34:32 <merijn> Cale: Silly, silly optimist
13:34:37 <kmc> classes are mostly just sugar for passing around some functions (or other stuff) implicitly
13:34:44 * sm is already doing it without typeclasses and figures remembering one function name would be better
13:34:52 <dino-> Saizan: I kind of disagree. I think that it's quietly alongside open content makes it insideous. Easy for masses to just kind of shrug and accept.
13:34:55 <monochrom> @quote monochrom school
13:34:56 <lambdabot> monochrom says: some kind of lazy evaluation is already known to highschool kids. teachers tell you that in a*(b+c), "evaluate b+c first", right? well, I challenge you to take 0*(389238493+97283748)
13:34:56 <lambdabot> and find one single student who faithfully evaluate 389238493+97283748 first.
13:34:58 <kmc> ah, i tend to avoid using them merely to consolidate names
13:34:59 * ddarius agrees with merijn.
13:35:03 <kmc> only if the things so named are also deeply related
13:35:17 * ddarius agrees with kmc here too.
13:36:15 <luite> c_wraith: depends on what exactly is cracked. if you break the whole system (unlocking all current and future content), then yes. but recent systems have been built to be updatable. updated keys and new BD+ programs could make new blu-ray disks uncopyable for months
13:36:40 <sm> I'm considering a Matchable class so I can do x `matches` matcher instead of m `matchesTransaction` t, m `matchesPosting` p, ....
13:37:12 <merijn> luite: Yes, but so far (on average) the people trying to crack the systems seem smarter then the people designing them
13:37:43 <monochrom> some good people among the designers probably dliberately sabotage the design
13:38:10 <merijn> monochrom: There's also that, yes
13:38:30 <ddarius> monochrom: Nah.  I have more faith in stupidity.
13:38:45 <c_wraith> well, and from a theoretical standpoint, the (stated) design goals are impossible.  So there's always an error - there must be.
13:39:13 <monochrom> what? don't attribute to benevolence what can be explained by incompetence? :)
13:39:19 <ddarius> monochrom: Exactly.
13:42:16 <luite> c_wraith: I don't think they are impossible in a practical sense. even though users must have access to decryption keys in some form, you can have physical security that makes it extremely difficult to get to them. And if your system is designed to quickly allow blacklisting keys for future content, then extracting the key from one device (or smart card, trusted platform module etc...) might not be worth the effort
13:42:44 <roconnor> mmm, these UArrays are working very very well!
13:43:22 <adimit> Man, the iteratee package could've stood to be a little less of a continuation-fest.
13:43:25 <roconnor> With a 128M limit on the heap I think I can go as far as I got with 512M heap using ByteStrings.
13:43:55 <adimit> roconnor: nice results :-)
13:44:20 <roconnor> I wish I could unerstand why I'm getting such poor performace with ByteStrings
13:45:03 <adimit> roconnor: memeroy-wise? tibbe recently posted something about memory performance on -cafe.
13:45:07 <adimit> (and his blog.)
13:45:13 <roconnor> my best guess is that the buffers in ByteStrings are pinned and fragmenting my heap
13:45:41 <roconnor> but this is based on very little evidence
13:46:06 * roconnor conjectures that ByteStrings are not designed to be long lived.
13:46:17 <c_wraith> roconnor: why don't you ask people who'd actually *know*, like edwardk, tibbe, or dons?
13:46:30 <adimit> -cafe might be the right place.
13:46:41 * ddarius doubts edwardk would know off the top of his.
13:47:04 <ddarius> + head
13:47:08 <c_wraith> ddarius: well, he knows quite a bit about GC details due to his work with Text.  That should carry over
13:47:11 <adimit> My superstitious assumption: don't ever use Bytestrings if you want to actually keep them around.
13:48:19 <roconnor> adimit: oh BTW, my experiment with (pack . unpack) didn't yeild and obvious differences from copy
13:48:27 <roconnor> thank goodness
13:48:51 <adimit> roconnor: thanks for letting me know. Now i'm even more puzzled why BS' performance is so far away from expectations.
13:48:57 <tibbe> roconnor: what's the issue? :)
13:49:10 <roconnor> adimit: and it looks like GHC is going to get pached to include bytestrings usage in the heap profile (at least for -hT)
13:49:19 <adimit> roconnor: now's your chance. Strike fast!
13:49:28 <digitteknohippie> suggestion to haskellers...add the haskell equivalent to the C example here: http://en.wikipedia.org/wiki/GTK%2B#GTK.2B_hello_world (cos why should C pinch all the limelight on wiki page for gtk)
13:49:42 <digitteknohippie> i challenge thee!  XD
13:50:03 <monochrom> yawn hello world
13:50:13 <roconnor> tibbe: With a 128M limit on the heap I think my program using UArray Word8's will go as far as I got with 512M heap using ByteStrings.
13:50:29 <c_wraith> haskell gtk isn't very interesting anyway.  It looks almost the same as C gtk
13:50:32 <roconnor> tibbe: where this Word8 Arrays are being stored for very long lifetimes.
13:50:32 <monochrom> even I have a more interesting example: http://www.vex.net/~trebla/haskell/gtk-interact.xhtml
13:50:43 <monochrom> that is, even I, a theorist
13:50:54 <roconnor> tibbe: my conjecture is that the Buffer held by Bytestrings are getting pinned and fragmenting my heap.
13:50:54 <tibbe> roconnor: size of the arrays?
13:51:03 <roconnor> tibbe: most on the order of 72 element
13:51:11 <roconnor> tibbe: a few smaller at around 4 or 1
13:51:24 <tibbe> roconnor: I don't remember of the top of my head when allocation switches to "big object" allocation
13:51:48 <tibbe> roconnor: ByteString also has a higher overhead than UArray by ~3 words per array
13:51:53 <tibbe> so if you have lots of small ones...
13:51:56 <monochrom> I am so tired of hello world examples, I now name my toy examples goodbye word
13:52:00 <monochrom> s/word/world/
13:52:01 <roconnor> tibbe: ya but we are talking about a 4x difference in heap size
13:52:15 <tibbe> roconnor: right
13:52:20 <tibbe> roconnor: so it depends on arrays size
13:52:27 <tibbe> but I think you might be right
13:52:37 <roconnor> I say most, are about 72 bytes
13:52:41 <tibbe> let me check the source quickly
13:52:42 <roconnor> maybe 70% of them.
13:52:43 <tibbe> right
13:52:47 <tibbe> 64-bit machine?
13:52:49 <roconnor> but I'm sort of estimating
13:52:52 <roconnor> 32-bit OS
13:52:55 <tibbe> ok
13:53:03 <roconnor> (found out recently his machine actually is 64 bit :(
13:53:04 <tibbe> 30 the extra overhead is only 24 bytes per array
13:55:10 <roconnor> tibbe: even [Word8] was giving me better performace, though I didn't measure how much.
13:55:26 <roconnor> but quite a bit
13:55:32 <tibbe> roconnor: what's the benchmark?
13:55:39 <pedro3005> ok, what's the non-stupid way to do:
13:55:44 <pedro3005> num :: Char -> Int
13:55:44 <pedro3005> num 'z' = 26
13:55:44 <pedro3005> num n = (num $ succ n) - 1
13:55:50 <roconnor> tibbe: um .. this program I'm writing.
13:55:58 <joe6> i have something like this:  http://sprunge.us/AhLK and am wondering if you have any suggestions on how I can make it better
13:56:00 <roconnor> not very scientific, I know.
13:56:33 <joe6> > printf "%02x" z
13:56:34 <lambdabot>   No instance for (Text.Printf.PrintfArg SimpleReflect.Expr)
13:56:34 <lambdabot>    arising from ...
13:56:41 <joe6> > printf "%02x" 'z'
13:56:42 <lambdabot>   Ambiguous type variable `a' in the constraints:
13:56:42 <lambdabot>    `GHC.Show.Show a'
13:56:42 <lambdabot>      a...
13:57:08 <monochrom> > Data.Char.digitToInt 'z'
13:57:09 <lambdabot>   *Exception: Char.digitToInt: not a digit 'z'
13:57:43 <tibbe> 2^12 * 8 / 10
13:57:52 <tibbe> that's the limit for large object allocation
13:58:03 <roconnor> tibbe: I should double check but IIRC when running with +RTS -S, with bytestrings at the time of death it was reporting half my heap lost to fragmentation.
13:58:14 <tibbe> roconnor: so about 3k bytes
13:58:29 <tibbe> roconnor: are the bytestrings pinned?
13:58:34 <tibbe> roconnor: I think they always are
13:58:36 <roconnor> I have no idea
13:58:42 <monochrom> num c = ord c - ord 'a' + 1
13:58:46 <tibbe> roconnor: they must be as they are ForeignPtrs
13:58:48 <monochrom> > ord 'a'
13:58:49 <lambdabot>   97
13:58:55 <roconnor> that is what I'm guessing, but I cannot read GHCism
13:58:57 <roconnor> :)
13:58:58 <monochrom> you can constant-fold ord 'a' to 97
13:58:59 <tibbe> roconnor: allocating pinned memory can definitely lead to fragmentation
13:59:23 <roconnor> which would explain the increase in peformace with UArrays and even [Word8]
13:59:29 <tibbe> roconnor: right
13:59:39 <tibbe> roconnor: well, there is performance and then there is memory usage
13:59:41 <roconnor> also I obsever the two methods die differently
13:59:51 <pedro3005> maybe just find the index of c in ['a'..'z'] + 1?
13:59:55 <roconnor> sure, I should have said memory use instead of performance.
14:00:07 <pedro3005> I only plan to use 'a' through 'z'
14:00:16 <roconnor> when the bytestring program dies it is a quick death
14:00:19 <tibbe> roconnor: if you could send an email describing your observations/question to the GHC mailing list I might find the time to give a better answer (or someone else will)
14:00:48 <roconnor> but when the [Word8] and UArray die it is a slow lingering death which a attribute to the GC running like mad trying to squeeze every bit out of the heap.
14:01:01 <monochrom> searching through ['a'..'z'] takes 26 steps plus a lot of branching
14:01:07 <roconnor> tibbe: if you say bytestrings are pinned and can fragement the heap, then I'm happy
14:01:26 <roconnor> I'll double check the reported heap fragmentation with +RTS -S and consider the mystery solved.
14:01:45 <tibbe> roconnor: they're definitely pinned as they are implemented using ForeignPtrs, and ForeignPtrs are pinned so they can be passed to C
14:02:03 <roconnor> tibbe: and UArrays are unpinned, right?
14:02:10 <tibbe> roconnor: I don't quite remember the details of how pinned memory is allocated by the GC, but typically pinned memory lead to fragmentation
14:02:13 <tibbe> roconnor: yes
14:02:16 <roconnor> good
14:02:30 <tibbe> (since they are based on ByteArray#s which are unpinned by default)
14:02:49 <tibbe> so UArray Word8 or an unboxed Vector might be your best bet
14:03:12 * roconnor adds a note to his stackoverflow answer that ByteArrays are pinned and could potentially lead to lots of unused heap due to fragmentation.
14:03:28 <roconnor> tibbe: what is an unboxed Vector?
14:03:35 <roconnor> I thought that was UArray Word8
14:03:38 <tibbe> roconnor: ByteStrings are pinned, not ByteArrays
14:03:42 <tibbe> sec
14:04:03 <tibbe> roconnor: http://hackage.haskell.org/packages/archive/vector/0.7.0.1/doc/html/Data-Vector-Unboxed.html
14:04:15 <tibbe> roconnor: the vector package is becoming the standard array package
14:04:22 <roconnor> oh
14:04:28 <tibbe> "standard"
14:04:32 <roconnor> what is the advantage over UArray?
14:04:32 <tibbe> it has been seriously tuned
14:04:47 <tibbe> there's also vector-algorithms which has efficient implementations of sort at all
14:04:52 <tibbe> some speed benefit
14:04:58 <tibbe> and IMHO a better API
14:05:10 <roconnor> ah I see
14:05:15 <roconnor> this would be more suitable
14:05:28 <tibbe> 0-based indexing
14:06:09 <roconnor> tibbe: what about bytestring vs vector?
14:06:18 <roconnor> what advanteages to bytestrings have?
14:07:17 <tibbe> roconnor: it can be passed to C
14:07:41 <tibbe> the feeling of the API is a bit different, ByteString feel like a String type while Vector feels like an Array type
14:07:50 <tibbe> but Vector Word8 is pretty much a ByteString
14:08:02 <tibbe> there might be some difference in performance in places
14:08:23 <tibbe> if you want to do I/O with your byte array then ByteString is generally better
14:09:05 <roconnor> ok
14:09:40 <roconnor> oh, my 128MB heap UArray program just passed the mark the 512M heap ByteString program did :D
14:11:30 <joe6> is there a better way of doing this:  http://sprunge.us/ObEh
14:13:01 <tibbe> roconnor: http://www.haskell.org/haskellwiki/Performance/GHC#Memory_allocation_and_arrays
14:13:44 <tibbe> roconnor: ByteStrings are generally better for bigger things, say >1kb
14:13:51 <joe6> compiling version:  http://sprunge.us/fjLX
14:13:53 <roconnor> oh wow
14:14:29 <roconnor> tibbe: and Vector doesn't have such restrictions
14:14:34 <tibbe> no
14:14:53 <tibbe> roconnor: it's not the bytestring performs terribly for smaller sizes, but there's a larger risk of fragmentation
14:15:01 <tibbe> (although you should double check this with Simon M)
14:15:14 <roconnor> right
14:15:47 <roconnor> heh, now that I've given 512MB to my UArray code, it is running very smoothly
14:16:07 <tibbe> roconnor: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC/Pinned
14:16:11 <tibbe> roconnor: :)
14:16:26 <tibbe> "This means that using pinned objects may lead to memory fragmentation, since a single pinned object keeps alive the whole block in which it resides."
14:17:12 <roconnor> http://stackoverflow.com/questions/5306717/how-should-i-interpret-the-output-of-the-ghc-heap-profiler/6354722#6354722
14:17:38 <roconnor> It turns out that ByteString is a compound nightmare for heap profiling.
14:17:44 <roconnor> 1) it doesn't show up in the heap profile
14:18:13 <roconnor> 2) when working with substrings of bytestrings the original buffers are kept, leading to space leaks
14:18:23 <roconnor> 3) the memory is pinned and can fragment your heap
14:19:08 <roconnor> not that I know for sure that timbod's original code used bytestrings
14:19:17 <dakrone> I'm having a problem following the monad tutorial, I am expecting MkStdGen to be in scope here so I can test this: http://pastie.org/2074553
14:19:22 <dakrone> what am I doing wrong?
14:19:56 <roconnor> but this was the same behavour I observed in my code: program runs out of heap but the heap profile is 10x smaller than the size of the heap.
14:20:14 <monochrom> mkStdGen
14:20:28 <monochrom> this is the problem with camel case
14:21:12 <tibbe> roconnor: the heap profile should be fixed
14:21:22 <roconnor> :)
14:21:29 <tibbe> roconnor: the holding on to the buffer is common in other languages as well e.g. Java Strings uses it
14:21:34 <roconnor> though JaffaCake said it might only work for -hT
14:21:40 <tibbe> but it's something to be aware of
14:21:45 <roconnor> ya
14:21:55 <dakrone> monochrom: gah, silly mistake, thanks for catching it
14:22:05 <roconnor> you especially need to be aware if it when the heap usage is invisible =)
14:26:19 <tibbe> roconnor: yeah, the things you mentioned compound to make things worse
14:29:01 <roconnor> =)
14:30:51 <roconnor> @free head
14:30:52 <lambdabot> f . head = head . $map f
14:51:05 * MeCooL Hi
14:57:57 <mjrosenb> what does @free do?
14:58:16 <ski> gives theorems for free
14:58:30 <ski> @free reverse :: [a] -> [a]
14:58:31 <lambdabot> $map f . reverse = reverse . $map f
14:58:40 <nihtml> win 7
14:58:41 <nihtml> sorry
14:58:46 <shachaf> @free cast :: a -> b
14:58:46 <lambdabot> g . cast = cast . f
14:59:35 <copumpkin> excellent
15:00:12 <ski> @free listToMaybe :: [a] -> Maybe a
15:00:13 <lambdabot> $map_Maybe f . listToMaybe = listToMaybe . $map f
15:00:23 <ski> @free concat :: [[a]] -> [a]
15:00:23 <lambdabot> $map f . concat = concat . $map ($map f)
15:01:37 <c_wraith> @free bird :: (a -> b) -> [a] -> [b]
15:01:37 <lambdabot> g . h = k . f => $map g . bird h = bird k . $map f
15:02:18 <ski> mjrosenb : "Theorems for free!" by Philip Wadler in 1989-09, at <http://homepages.inf.ed.ac.uk/wadler/topics/parametricity.html#free>
15:06:48 <juliekitn> are there explanations available anywhere for the exercises in Jones & Lester's _Implementing Functional Languages_?
15:22:51 <int80_h> so I install yesod via cabal, now I want to replace the latest stable yesod-forms with the latest yesod-forms form the repository. How can I do this in a way that I can reverse it if I botch it?
15:23:23 <dcoutts> int80_h: cabal install has flags --prefix and --package-db
15:23:38 <dcoutts> these let you install into some local location, and register into a local package db
15:25:25 <int80_h> dcoutts: thanks!
15:27:39 <fragamus> http://hpaste.org/47860
15:27:46 <fragamus> WTF^^^
15:30:18 <aavogt> fragamus: what type is iterateUntil?
15:30:49 <fragamus> @type iterateUntil
15:30:49 <lambdabot> Not in scope: `iterateUntil'
15:31:08 <aavogt> anyways, this might typecheck:  m <- maxdev; n <- iterateUntil (\x -> abs x < m) snag_normal_sigma sigma
15:31:32 <aavogt> but maybe that's not what you intend
15:32:12 <fragamus> lemme see
15:32:46 <fragamus> BTW i got iterateUntil from Control.Monad.Loops
15:34:51 <fragamus> iterateUntil :: Monad m => (a -> Bool) -> m a -> m a
15:42:46 <fragamus> maxdev is not a function, it is a Float
15:42:55 <fragamus> http://hpaste.org/47860
15:43:21 <fragamus> iterateUntil :: Monad m => (a -> Bool) -> m a -> m a
15:51:31 <aavogt> fragamus: how about  n <- iterateUntil (\x -> abs x < maxdev) (snag_normal_sigma sigma) ?
15:51:39 <c_wraith> So, a guy I know wrote a small application in haskell, and wants to distribute it to windows users (people who won't ever compile something of their own).  He's concerned that he's technically violating all of the BSD3 licenses unless he includes hundreds of extra copyright notices.
15:53:25 <ddarius> So put in hundreds of copyright notices.
15:55:01 <fragamus> aavogt: yes that helped!
15:55:02 <Eduard_Munteanu> c_wraith: is it for internal company use?
15:55:13 <c_wraith> no, it's for public distribution
15:55:31 <c_wraith> ddarius: that's quite difficult, with the current state of the world.
15:56:01 <c_wraith> ddarius: perhaps if cabal could dump out a list of all the copyright holders for your dependencies (direct and transitive)
15:56:01 <aavogt> perhaps cabal could / alread has features for that
15:56:23 <c_wraith> But the fact is, you can easily depend on 100 libs indirectly
15:56:35 <dcoutts> we've had some patches towards this
15:56:38 <c_wraith> and many claim to be BSD3 licensed but don't contain an actual copyright statements
15:56:54 <c_wraith> like, say, the RTS
15:57:01 <dcoutts> been through one round of patch review, but currently seems to be stalled
15:57:13 <dcoutts> current patches focus on license checking
15:57:22 <dcoutts> but licence gathering would be the next step
15:57:23 <c_wraith> The RTS claims to be BSD licensed, but it doesn't say who the copyright holders are
15:57:37 <c_wraith> making it *really* hard to credit them as its license requires
15:58:11 <dcoutts> c_wraith: there's a file there somewhere, I found it for a project where I needed to gather all the licenses
15:58:37 <Draconx> c_wraith, ianal, but without any license statement from the copyright holder(s), it's hard to imagine that could be construed as having a license.
15:58:58 <dcoutts> c_wraith: oh it's just the LICENSE file that comes with ghc
15:59:27 <c_wraith> still, he was complaining about the many, many packages on hackage that have nonsensical license information
16:00:05 <c_wraith> the authors clearly intend them to be usable, but the current state is technically short of that
16:02:35 <houeland> Hi, c_wraith's friend is me. You can see my result with bunching together copyright notices at http://www.houeland.com/kol/docs/copyright
16:02:51 <c_wraith> oh, hey, didn't realize you followed here. :)
16:03:01 <c_wraith> If I had, I would have told you to ask about it yourself :)
16:03:07 <houeland> It contains many copies of the GHC license, primarily because of unclear licenses on those packages
16:03:19 <houeland> But the main point is that it ends up being long :p
16:03:55 <dcoutts> houeland: yup, really wants automation
16:04:04 <dcoutts> I thought the same last time I had to do that
16:04:19 <Draconx> houeland, this happens when you have hundreds of different licenses that all require their text to be reproduced in its entirety.
16:04:51 <osfameron> @src intersperse
16:04:51 <lambdabot> intersperse _   []     = []
16:04:51 <lambdabot> intersperse _   [x]    = [x]
16:04:51 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
16:05:03 <dcoutts> Draconx: mm, good point, the GPL and LGPL are slightly better that way, since you only need one copy for N packages using them
16:05:13 <houeland> dcoutts: Many of the cabal license entries are just wrong though
16:05:39 <dcoutts> houeland: you mean the license files or the BSD3/LGPL/etc labels in the .cabal files?
16:06:03 <dcoutts> or that the two are not consistent
16:07:39 <houeland> That they have BSD3 labels pretty much regardless of whether it's BSD, MIT, BSD with the binary reproduction clause removed, BSD with an extra line added that's not part of the restrictions, etc.
16:08:35 <dcoutts> mm, though I guess that's not a problem for just concatenating them all
16:10:19 <jonkri> if data IQ = IQReq IQRequest | IQRes IQResponse, IQRequest and IQResponse being records, and i case an IQ value and want to pattern match against the Request (or Response) record to a "variable", how can i do that?
16:11:04 <houeland> Yeah, what I did was hiding all packages for ghc and adding them manually until it compiled, then ghc-pkg dot for dependencies and using cabal to download all of them and fetching LICENSE files. It would be nice to have that bit automated, and knowing that I didn't screw it up
16:11:41 <houeland> Still have to read through them all though, and discover things like my program not being able to claim that it's the FFI specification
16:11:44 <dcoutts> houeland: if you feel like writing patches I can point you to the design we were thinking of
16:11:59 <dcoutts> houeland: yeah, that one is odd :-)
16:24:39 <dirrt> cls
16:29:19 <hpaste> fragamus pasted “The continuing adventures of fragamus” at http://hpaste.org/47861
16:29:51 <fragamus> yes, I did that ^^^
16:31:26 <houeland> dcoutts: Sure, at least I could take a look at it and provide feedback, having just gone through this process
16:31:35 <fragamus> I'm finding it very hard to comprehend what the compiler is trying to tell me
16:31:57 <fragamus> I think its trying to say "You suck"
16:32:58 <jmcarthur> fragamus: n has type Float, but sigma has type a. that is, your type signature is telling the compiler that you want to accept any type that is an instance of Floating and multiply it with a Float, which you can't do, at least not without some sort of conversion
16:33:32 <jmcarthur> fragamus: snag_clipped seems to be the same issue
16:34:01 <c_wraith> agh, is there a simple way to tell vacuum to turn its entire result into a graph?
16:34:03 <fragamus> ok lemme see...
16:35:44 <c_wraith> ok, I just found nameGraph
16:35:48 <c_wraith> things are getting better now
16:36:51 <c_wraith> the pipeline I wanted is...  ppDot . nameGraph . vacuum
16:37:53 <fragamus> mass migration^^^
16:39:35 <fragamus> hey I solved my problem by deleting my type signatures on the two functions that had errors.
16:40:26 <c_wraith> fragamus: now load that module in ghci, and see what it thinks the types of those functions are
16:40:39 <c_wraith> fragamus: and see if you can figure out why ghci thinks that
16:41:04 <fragamus> ok
16:42:48 <fragamus> snag_clipped :: RandomGen g => Float -> Float -> Float -> RandT g (State ([Int], [Int], [Int])) Float
16:43:08 <fragamus> makes perfect sense
16:43:19 <fragamus> I need haskell boot camp
16:43:27 <fragamus> where do i go for that
16:43:45 <hpc> @where lyah
16:43:55 <hpc> D:
16:44:00 <hpc> well, learnyouahaskell.com
16:44:35 <hpc> and then to make it a boot camp, just lock yourself inside :P
16:44:47 <fragamus> ok
16:47:33 <ocharles> Is there anything in prelude that is something like String -> Maybe Int ? (I want to parse a string to an integer, but just get Nothing if it can't be parsed)
16:47:45 <ocharles> I see "read" and "reads", so I think I might have to roll my own
16:48:23 <aavogt> ocharles: write it in terms of reads
16:49:00 <hpc> @pl \x -> case reads x of [(y,"")] -> Just y; _ -> Nothing
16:49:12 <Axman6> lambdabot!
16:49:15 <hpc> ... i feel so lost without λbot
16:49:31 <aavogt> maybe the reason readMaybe doesn't exist is because there's choice whether you want to consume all input, or pick the first of multiple parses
16:49:58 <ocharles> oh, reads is different than what I thought
16:50:05 <ocharles> I thought it was about providing a default if the read failed
16:50:10 <ocharles> I see that's not the case
16:50:19 <hpc> aavogt: or if you want an answer if there is exactly one parse, which might leave unconsumed input
16:50:50 <hpc> ocharles: in any event, what i tried to @pl up above is probably what you want
16:50:54 * ocharles nods
16:50:58 <ocharles> I'm going to check that out now
16:50:59 <ocharles> thanks!
16:51:03 <aavogt> how is that supposed to @pl anyways?
16:51:07 <hpc> it says "return the read if we have exactly one result, and it consumed all input"
16:51:17 <hpc> aavogt: hell if i know, but i tried anyway ;)
16:53:43 <fragamus> @type flatten
16:53:44 <aavogt>   (\x -> guard (null (drop 1 x)) >> guard ([""] == fmap snd (take 1 x)) >> listToMaybe (fmap fst x)) . reads -- is probably even more ugly when you @pl the x
16:54:28 <fragamus> what did you guys do to my beloved lambdabot
16:55:20 <benmachine> aavogt: how about guard ([""] == fmap snd (take 2 x)), subsuming the ambiguity check
16:55:35 <benmachine> actually don't take any at all
16:55:53 <benmachine> [""] == fmap snd x should be the right amount of lazy
17:09:39 <dibblego> what is the relationship between Maybe and fromMaybe? there seems to be some kind of isomorphism going on
17:09:52 <hpc> :t fromMaybe
17:10:03 <hpc> argh
17:10:04 <aavogt> a -> Maybe a -> a
17:10:33 <hpc> dibblego: fromMaybe Nothing = join?
17:10:48 <dibblego> hmm yes
17:11:34 <ben> :t join
17:11:42 <ben> oh, right
17:12:07 <benmachine> fromMaybe x = maybe x id
17:12:17 <benmachine> maybe is the catamorphism for Maybe
17:12:28 <dibblego> yeah
17:13:01 <ben> gosh, where's that homomorphism for dummies book
17:13:21 <dibblego> @type \n j -> fromMaybe n . fmap j
17:13:48 <aavogt> ?ty maybe
17:15:09 <benmachine> maybe :: b -> (a -> b) -> Maybe a -> b
17:15:53 <hpc> benmachine's server must be really busy
17:15:59 <hpc> ;)
17:16:04 <benmachine> :P
17:49:18 <shachaf> snap: ?
17:49:29 <shachaf> ?: snap
17:49:44 <shachaf> Oh.
17:49:51 <shachaf> Oh, the bot is dead.
17:50:24 <hpc> long live the bot
17:50:43 <fragamus> > 9^9
17:51:16 <fragamus> @type head
17:51:26 <shachaf> Oh, the other bot is also dead.
17:51:34 <shachaf> preflex: seen Cale
17:51:35 <preflex>  Cale was last seen on #haskell 4 hours, 17 minutes and 19 seconds ago, saying: merijn: I usually assume that if people are going to spend hundreds of thousands or millions of dollars designing a system, they'll consider whether it's actually feasible.
17:51:56 <Cale> oh
17:53:31 <shachaf> @ahoy ivant
17:53:39 <lambdabot> "ivant"
17:54:20 <fragamus> > 9^9
17:54:27 <lambdabot>   387420489
17:54:29 <harrison> does ghc do multicore yet?
17:55:20 <hpc> has "multicore" been verbed yet? ;)
17:55:38 <hpc> harrison: GHC has a very fast threaded runtime
17:55:46 <byorgey> harrison: http://community.haskell.org/~simonmar/par-tutorial.pdf
17:58:10 <harrison> for years i waited for john reppy's "manticore" multicore ML to be ready
17:58:56 <harrison> anybody here interested in coding renderers"
17:58:58 <harrison> ?
17:59:22 <harrison> opengl - tracer hybrids, that sort of thing?
18:34:38 <danharaj> how do you guys handle floating point equality when you want to add a tolerance of epsilon?
18:36:10 <lispy> danharaj: I haven't really needed that in Haskell
18:36:36 <lispy> danharaj: in C-based languages I just did the obvious thing with <=
18:37:29 <lispy> if( y - epsilon < x && x < y
18:37:31 <lispy> oops
18:37:41 <lispy> if( y - epsilon < x && x < y + epsilon ) -- this sort of thing
18:38:04 <shachaf> abs (x - y) < epsilon?
18:38:17 <danharaj> lispy: I'm debating whether I should do it. I have to decide how to handle incidence tests for my geometry library.
18:41:14 <Axman6> i think shachaf's way is more useful, it ensures that the value you're testing is more likely to be in the range of epsilon (y - epsilon maybe be equal to y, turning the whole test into x == y)
18:41:56 <danharaj> lispy: Here's another question you might be able to answer. If I use Doubles for my geometry, will I take a performance hit in the shaders?
18:42:29 <lispy> danharaj: shaders need GLDouble and CDouble, right?
18:42:55 <Axman6> abs for double is just equivalent to abs x = x & 0x7FFFFFFF right/ (assuming ieee-754)
18:42:58 <Axman6> ?*
18:42:59 <lambdabot> Maybe you meant: . ? @ v
18:43:07 <lispy> Axman6: interesting.  floating point has so many nuances.  I guess what you're saying kind of depends on the epsilon
18:43:45 <Axman6> lispy: i don't think it does, if epsilon is large, then that will always work, and i think it always works when it's very small too
18:43:46 <danharaj> lispy: Probably. I'm wondering if double arithmetic is slower on contemporary graphics hardware.
18:44:01 <danharaj> lispy: Beyond that I have to debate the merits w.r.t. cache coherency, memory usage, etc.
18:44:16 <lispy> danharaj: int on the gpu is an illusion, IIRC
18:45:00 <lispy> danharaj: I read somewhere that most of the graphics cards don't really have an int type in the hardware.  I think the red book was claiming that
18:45:13 <danharaj> lispy: What about Floats vs. Doubles?
18:45:28 <lispy> benchmark :)
18:45:40 <danharaj> That'll only tell me about my card :p
18:45:56 <lispy> Yeah :(  I don't know the answer though
18:46:06 <danharaj> ah well, I'll find out eventually.
18:47:44 <danharaj> I feel kind of silly writing "ePSILON"
18:47:57 <danharaj> But I need to make it eye-catchy.
18:49:27 <danharaj> Geometry is such a pain in the ass. So many special cases, ugly formulas, precision issues.
18:49:30 <danharaj> shoot me in the face
18:52:45 <Axman6> danharaj: i think only recent GPU's even have proper support for Double, and Float is still faster iirc. Things like OpenCL are changing this though
18:53:17 <danharaj> Axman6: Good to know.
18:53:18 <Axman6> modern GPU's implement FP following the IEEE-754 standard too, they used not to (because close enough was good enough)
18:59:55 <lispy> danharaj: I guess you could use the unicode codepoint for epsilon
19:00:09 <lispy> danharaj: it would be shorter and probably standout
19:00:41 <lispy> http://www.fileformat.info/info/unicode/char/3b5/index.htm
19:01:23 <lispy> and my screen setup doesn't understand utf-8...
19:01:30 <lispy> yay, for screen...
19:13:14 <danharaj> lispy: heh that's too hardcare for me.
19:13:30 <benmachine> ε
19:13:34 <danharaj> since I'm really mostly interested in doing order comparisons, I just wrote a function epCmp
19:44:33 <rpglover64> I have a question about an unintuitive behavior in cabal
19:44:58 <rpglover64> namely, I've installed QuickCheck-2.4.1.1
19:45:32 <rpglover64> when I try to "cabal install species", it recompiles QuickCheck-2.4.1.1
19:46:14 <parcs> > logBase 91996043 2
19:46:15 <lambdabot>   3.779993996387921e-2
19:46:24 <parcs> what
19:46:30 <byorgey> rpglover64: what is the output of  'ghc-pkg list QuickCheck' ?
19:46:59 <rpglover64>    QuickCheck-2.4.1.1
19:47:03 <rpglover64> gah
19:47:10 <byorgey> > 91996043**(3.779993996387921e-2)
19:47:11 <lambdabot>   2.0
19:47:29 <byorgey> > logBase 2 91996043
19:47:30 <lambdabot>   26.455068472478477
19:47:40 <rpglover64> it appears installed
19:47:57 <byorgey> rpglover64: does it appear in multiple places? are there any other versions?
19:48:00 <rpglover64> no
19:48:01 <rpglover64> and no
19:48:06 <rpglover64>    QuickCheck-2.4.1.1
19:48:14 <byorgey> hmm, and what version of cabal?
19:48:20 <rpglover64> okay; pasting multiple lines doesn't work :(
19:48:35 <rpglover64> cabal-install version 0.10.2
19:48:40 <rpglover64> using version 1.10.1.0 of the Cabal library
19:48:49 <byorgey> ok.
19:49:38 <byorgey> rpglover64: and the install of QuickCheck-2.4.1.1 is not marked "broken"?
19:49:49 <rpglover64> byorgey: by the way, I'm reading your species paper for a seminar tomorrow, which is why I'm trying to install the library
19:49:59 <byorgey> rpglover64: cool =)
19:50:21 <rpglover64> no, and ghc-pkg check produces no output
19:51:11 <byorgey> hmm, I am not sure what the problem is then
19:51:17 <rpglover64> :(
19:51:43 <rpglover64> Ah, well...
19:51:53 <byorgey> if only dcoutts were here
19:51:58 <byorgey> but he is probably asleep
19:52:05 <Jafet> Perhaps you asked for different build options.
19:52:30 <rpglover64> i have profiling enabled by default, if that matters
19:52:31 <rpglover64> ?
19:53:25 <Jafet> It shouldn't.
19:53:33 <rpglover64> i didn't think it would
19:53:54 <Jafet> Are QuickCheck and species now both user packages?
19:54:22 <rpglover64> i think so (if I understand what you mean by user packages)
19:55:26 <Jafet> They would appear in the ~/.ghc world when you examine ghc-pkg list.
19:55:53 <Jafet> Perhaps you have multiple user worlds, or multiple ghc versions, or some other complication?
19:56:06 <rpglover64> i don't think so
19:56:21 <rpglover64> I recently wiped my cabal directory and started over
19:56:53 <rpglover64> i only have two repositories show up for ghc-pkg list (one of them is system, and one of them is mine)
19:57:35 <rpglover64> I'm running osx, if that makes a difference (but I can't see why it would)
19:58:39 <byorgey> it sounds like a cabal bug/infelicity to me.
20:01:06 <hpaste> rpglover64 pasted “Cabal frustration” at http://hpaste.org/47863
20:02:39 <rpglover64> it seems to be attempting to reinstall quickcheck because of the template-haskell version (at the top), and failing because it thinks there's something weird with TH.hi
20:02:54 <luite> yeah you shouldn't reinstall template-haskell
20:03:19 <luite> looks like it's caused by outdated dependencies in species and np-extras
20:06:29 <luite> rpglover64: it will probably work if you downgrade to ghc 6.12
20:07:16 <rpglover64> that's nice to know
20:07:23 <luite> or if you update the dependencies, fix the compile errors and send byorgey a patch ;)
20:07:52 <byorgey> yeah, I have attempted that a couple times now but it's rather tricky
20:08:02 <byorgey> not just a matter of upping a few version numbers
20:08:04 <luite> I noticed
20:08:19 <rpglover64> i was going to say... I don't think i have a firm enough grasp of reality for that
20:31:24 * byorgey is slowly going insane from unhealthy quantities of TH hacking
20:31:48 <copumpkin> quick, come to agda
20:32:13 <djahandarie> I've skillfully avoided any contact with TH
20:32:27 <djahandarie> Actually, I should probably add some to my newtype package to make writing instances less dumb
20:32:39 <byorgey> djahandarie: where are you staying?
20:33:56 <djahandarie> I'm at PDX airport right now, but I'll eventually be in Smith as far as I know
20:36:08 <confound> pdx airport is pretty nice as airports go
20:36:08 <byorgey> djahandarie: ah cool, see you when you get here, I'm in Smith 308
20:36:44 <byorgey> djahandarie: though I may be in bed by the time you arrive.
20:36:50 <djahandarie> :-) I'll probably get there at 12 so I odn't want to wake you up
20:36:51 <djahandarie> Haha, yes.
20:37:04 <byorgey> ok, see you tomorrow then =)
20:40:13 * BMeph prefers being picked up at PDX to SEA, no contest.
20:42:49 <davidL> byorgey: the Smith building in downtown PDX?
20:43:19 <byorgey> davidL: no, on the campus of University of Oregon in Eugene
20:43:33 <davidL> oh :)
20:44:09 <byorgey> visiting PDX would be fun but I don't think I'll be able to make it up there
20:46:37 <shachaf> byorgey: You're in Eugene?
20:46:59 <byorgey> shachaf: yep
20:47:13 <BMeph> Visiting PDX was much more useful to me when my wife lived in WA. Now that we're both in CA, it's rare. :)
20:47:25 <byorgey> shachaf: for http://www.cs.uoregon.edu/Activities/summerschool/summer11/
20:47:40 <shachaf> Oh, you too.
20:58:51 <dolio> copumpkin: So, there seems to be some question about how reliable btrfs is.
20:59:11 <dolio> I don't know if is ready to entrust an important, portable 750GB porn collection to.
21:00:12 <tensorpudding> with a collection like that, you wouldn't trust it to any filesystem
21:00:21 <tensorpudding> you'd keep backups
21:00:23 <tensorpudding> redundancy
21:34:12 <dmwit> Hm, that reminds me. I should do a backup.
21:42:08 <kapil> hi
21:43:51 <Axman6> hello
21:55:16 <c_wraith> huh.  the release of 7.0.4 kinda caught me by surprise.
21:55:26 <c_wraith> I didn't know another point release was coming
21:57:53 <luite> I installed the release candidate last week so it didn't really surprise me :p
22:01:43 <luite> was the import qualified functionality added to ghci recently?
22:04:13 <c_wraith> ghc 7.0.1, IIRC
22:05:46 <luite> ah ok, I was wondering why hint used a temporary module for qualified imports when it could also be done directly with GHC.setContext :)
22:08:43 <luite> temp files don't really work well when you chroot the process while the interpreter is running :)
22:09:00 <c_wraith> heh
22:09:04 <c_wraith> true
22:09:33 <arw_> is there a library to create sunrpc servers and clients? hackage says 'no', but perhaps i've looked for the wrong keywords.
22:13:07 <shachaf> Hackage says 'no', but my heart says 'yes'
22:13:33 <dibblego> anyone using doc-review package?
22:13:35 <arw_> :)
22:19:42 <taotree> are there some useful tools to track down application freezes?
22:20:00 <taotree> I'm trying to track down why my opengl application is freezing. I have a bunch of print calls in the do block where it's hanging and the line after the last print that shows in the console is an opengl translate call.
22:20:19 <taotree> The interesting thing is that if I change the value in the call to a constant, it doesn't stop there
22:36:55 * hackagebot gdiff-ig 0.1.1 - Generic diff for the instant-generics library  http://hackage.haskell.org/package/gdiff-ig-0.1.1 (JosePedroMagalhaes)
22:36:57 * hackagebot instant-generics 0.3.2 - Generic programming library with a sum of products view  http://hackage.haskell.org/package/instant-generics-0.3.2 (JosePedroMagalhaes)
23:00:59 <dibblego> the answer is no, because it doesn't work
23:06:04 <taotree> ?
23:08:40 <taotree> so I figured I could backtrack up the chain and realized I could try deepseq... and now I'm two functions back up and it's hanging on the deepseq call
23:10:49 <CakeProphet> any idea why I would get this error when installing lambdabot from cabal: http://hpaste.org/46397/lambdabot_install_failure
23:11:03 <luite> taotree: are you sure you don't have some infinite thing there?
23:11:22 <taotree> luite, I'm guessing I do, but... I'm spending a lot of time trying to track it down
23:11:35 <taotree> luite, that's why I was asking about tools/methods to track this kind of thing down
23:12:35 <luite> hmm, I usually use Debug.Trace in those situations, that's not terribly sophisticated of course :)
23:13:20 <taotree> I started there, but... the problem is apparently far away from where it was finally freezing
23:13:35 <taotree> and so I'm having a hard time tracking it back
23:14:05 <luite> you could run with profiling and hope that the space or time profile data gives you some hints
23:29:16 <taotree> hmm... there's an IORef involved and 2 threads. I wonder if that has anything to do with it
