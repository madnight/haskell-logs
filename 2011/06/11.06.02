00:28:15 <cch`> hi, may qualified import a module in ghci
00:30:22 <shachaf> cch: You have my permission.
00:30:31 <shachaf> And GHC's permission too, if you're using >=7.
00:40:52 <k0ral> hum
00:41:10 <k0ral> in hackage, my package has a "Build failure" line
00:41:26 <k0ral> with missing dependencies in the log
00:42:05 <k0ral> wtf ?
00:42:07 <kfish> k0ral, missing haskell packages or C libraries
00:42:18 <kfish> ?
00:42:23 <k0ral> haskell packages
00:42:27 <k0ral> webkit + zeromq
00:42:55 <kfish> are newer versions of those available than your .cabal file allows?
00:44:04 <k0ral> it allows any
00:49:42 <ManDay> Can someone explain what is so huge about ghc? It's a freaking 106 Megabytes, why?!
00:51:18 <Saizan> http://stackoverflow.com/questions/4858585/why-is-ghc-so-large-big
00:53:31 <ManDay> Yeah, wtf.
00:53:33 <ManDay> Thanks Saizan
01:01:41 <k0ral> could one please remind me what is the right way to implement the equivalent of a #define in C, for simple constants ?
01:03:04 <Saizan> foo = .. ?
01:04:24 <k0ral> yes but it doesn't benefit from strong typing
01:04:48 <k0ral> the thing is: I'd like to define boolean constants
01:04:58 <ziman> what do you mean, could you show an example?
01:05:01 <k0ral> if I use a foo = True; bar = False
01:05:12 <k0ral> and I have a fun :: Bool -> whatever
01:05:23 <k0ral> it's ok to do fun foo of fun bar
01:05:37 <k0ral> but I have another fun2 :: Bool -> whatever
01:05:39 <ziman> -or- fun bar?
01:05:57 <k0ral> yes "or" sorry
01:06:12 <k0ral> and I don't want to be able to do fun2 foo either fun2 bar
01:06:26 <k0ral> since foo and bar are semantically incompatible with fun2
01:06:35 <k0ral> I should make a new type, right ?
01:06:43 <ziman> and what feature of #define would help you in this case?
01:06:44 <k0ral> data Foo = foo | bar
01:06:53 <k0ral> ziman: forget about #define
01:06:56 <ziman> I'd newtype, too.
01:07:05 <k0ral> but
01:07:16 <k0ral> now I can't do fun foo either foo bar
01:07:25 <k0ral> since foo expects a Bool (and that cannot be changed
01:07:26 <k0ral> )
01:07:57 <ziman> (or use some descriptive data PacketOptions = FoldPacket | DoNotFoldPacket instead of using a boolean flag)
01:08:13 <k0ral> ziman: actually that's what I meant :)
01:08:27 <k0ral> but fun still expects a bool
01:08:28 <ziman> I guess that's your data Foo :)
01:08:57 <ziman> well, then you're stuck with Bool unless you make a wrapper around fun and use that instead
01:09:43 <k0ral> hmmm
01:09:46 * ski . o O ( `data Bool = False | True | EOF' )
01:10:57 <k0ral> a case of wrapping function... is quite heavy, I mean if I have hundreds of other situations where I want to give a sense to my boolean values
01:11:20 <k0ral> that means creating hundreds of wrapping functions
01:11:44 <ziman> so you want a symbolic "term" that expands to a boolean value
01:12:19 <ski> (it sounds like k0ral maybe want something similar to how Pascal treats type definitions ..)
01:12:21 <ziman> but is usable with only a single function?
01:14:56 <k0ral> not necessarily a single function
01:15:39 <k0ral> say it's a data Foo
01:16:00 <k0ral> then I'd like it to be both usable when a function expects a Foo or a Bool
01:16:19 <k0ral> something like a derived type from Bool
01:16:40 <k0ral> in haskell derived types are made with classes right ?
01:17:07 <k0ral> there should be a Bool class
01:17:31 <osfameron> what other types would implement a Bool class?
01:17:46 <k0ral> every customized types that consist of 2 parts
01:18:17 <k0ral> data X = X | Y
01:18:22 <k0ral> hmmmm
01:18:26 <k0ral> data X = x | y
01:18:42 <azaq23> you could simply "give sense" to your booleans by using a type directive; you create just a type synonym for bool and use it to describe the top level flags as well as the functions, but type them using the synonym
01:18:52 <azaq23> this doesn't enforce the constraint though
01:18:52 <shachaf> k0ral: Your first capitalization was correct.
01:19:03 <shachaf> But what's the point of this? What could you do with that class?
01:19:33 <k0ral> I could create functions of this kind: (Bool a) => a -> whatever
01:19:34 <ziman> but nothing would stop you from doing: readPacket GiveTheCatTheOtherFood (using unrelated flags)
01:19:47 <ziman> what is the difference from saying giveTheCatTheOtherFood = False ?
01:19:55 <k0ral> and then the user could make a semantic type instead of using True/False
01:20:20 <shachaf> k0ral: What's the point of the Bool class, then?
01:20:24 <azaq23> type ReadPacket = Bool; readPacketFlag :: ReadPacket; readPacketFlag = True; fun :: ReadPacket -> ...; fun readPacketFlag
01:20:27 <k0ral> well, in some functions you only impose a Bool (as a cass), in others you can impose a Foo
01:20:31 <shachaf> If the type has a different meaning, the function shouldn't be treating it as a Bool.
01:20:42 <shachaf> "cass"?
01:20:51 <k0ral> class*
01:21:06 <shachaf> Oh.
01:21:09 <shachaf> Can you name such a function?
01:21:54 <k0ral> shachaf: which function ?
01:22:07 <shachaf> One that would get a "Bool class" argument.
01:22:16 <shachaf> That's not really what type classes are for.
01:22:33 <k0ral> fun :: (Bool a) => a -> whatever
01:22:51 <k0ral> fun2 :: Foo -> whatever
01:23:01 <k0ral> instance Bool Foo ...
01:23:02 <ski> k0ral : if you have two separate `Bool'-like types, there need not be any canonical isomorphism between them ..
01:23:21 <shachaf> k0ral: Can you give an *example* of such a function?
01:23:34 <shachaf> Not its type. What's the point having it accept (Bool a) => a instead of just Bool?
01:24:02 <k0ral> because then the user is free to implement his own Bool type and still use it with fun
01:24:12 <k0ral> I'm in a case where I use a webkit API that has 3 Bool arguments
01:24:24 <k0ral> fun True False True isn't really easy to understand
01:24:36 <k0ral> while fun CaseSensitive Forward Incremental
01:24:37 <k0ral> is
01:24:46 <k0ral> if I could create my own Bool-like type
01:24:56 <osfameron> you could just use type-synonyms?
01:24:58 <k0ral> and feed it to fun without having to wrap around fun
01:25:00 <k0ral> could be great
01:25:10 <osfameron> type CaseSensitive = Bool
01:25:12 <shachaf> Just use some function :: Foo -> Bool
01:25:43 <ski> k0ral : if i implement `data SugarOption = SugarPlease | IllTakeItBlack' and `data Direction = TurnLeft | TurnRight', then what does it mean to pass `TurnRight' to your function ? the same as passing `False' ? the same as passing `True' ? the same as passing `SugarPlease' ? the same as passing `IllTakeItBlack' ?
01:25:49 <k0ral> will I still have to use True and False as values of CaseSensitive ?
01:25:55 <ziman> well, that's a (in this sense) deficiency of the design of the library
01:26:17 <k0ral> shachaf: well, that's kind of a wrapper, if I create many Foo-like functions, that's getting heavy
01:26:17 <ziman> either use caseSensitive = True or create a wrapper for fun, I'd say.
01:26:40 <shachaf> k0ral: See what ski said.
01:26:58 <k0ral> I'm reading
01:27:15 <ski> k0ral : in the `fun CaseSensitive Forward Incremental' case, a record could be used. but i agree that we'd really want light-weight records (not having to declare a new type just for this)
01:27:20 <finnomenon> hi
01:27:50 <ski> hello, finnomenon
01:28:24 <k0ral> well, in the case of the webkit API, yes it would be the same to use TurnRight, False or IllTakeItBack
01:28:34 <ski> k0ral : though it may be that for some of those arguments, it may be better to create a new type, which might later have more than two options
01:28:41 <k0ral> because it lets the choice of which implementation of the Bool class to use
01:29:02 <k0ral> but your function could either let this choice to the user, or enforce it
01:29:06 <ski> k0ral : why should `TurnRight' correspond to `IllTakeItBlack' rather than `SugarPlease' ?
01:29:30 <ski> why is one such translation preferred to the other ?
01:29:35 <k0ral> because it's the right side :)
01:31:09 <dobblego> new library, no dependencies yet, I need MonadTrans and Identity -- where should I get them from?
01:31:59 <Saizan> mtl?
01:32:45 <dobblego> does mtl have Identity?
01:35:08 <ski> k0ral : btw, note that `False' is declared before `True' in `Bool
01:35:10 <ski> @src Bool
01:35:10 <lambdabot> data Bool = False | True deriving (Eq, Ord)
01:42:56 <c_wraith> > toEnum 0 :: Bool
01:42:57 <lambdabot>   False
01:43:09 <c_wraith>  @src lies again! :)
01:44:12 <osfameron> lies?
01:44:53 <k0ral> ski: a different implementation would then be needed
01:45:19 <ski> c_wraith : hm ?
01:45:22 <k0ral> anyway, I now know what I'm looking for doesn't exist :)
01:45:34 <ski> k0ral : a different implementation of what ?
01:46:10 <k0ral> Bool
01:46:17 <c_wraith> ski: it should derive Enum, too :)
01:46:42 <k0ral> if it's a class anyway it's not implemened like a type
01:46:55 <ski> well, deriving `Enum' is functionally the same as writing the (correct) implementation by hand
01:47:32 <ski> k0ral : i'm not sure i understand you. a different implementation of `Bool' would be needed for *what* ?
01:51:39 <k0ral> ski: ^^ for what I described a long long time ago, in a galaxy far away
01:52:09 <k0ral> scroll up
01:53:36 <ski> more than 50 minutes ago ?
01:54:11 <k0ral> at 10:42
01:54:20 <k0ral> hmmm
01:54:22 <osfameron> in every timezone!
01:54:25 <k0ral> in my timezone
01:54:33 <k0ral> 30 minutes ago exactly
01:54:47 <Nereid> :o
01:55:26 <Nereid> Pieter Hofstra - Types, Groupoids, and Homotopy
01:55:26 <Nereid>  
01:55:27 <Nereid> This talk will be an exposition of the recently uncovered connections between homotopy theory and type theory. In particular, I will discuss how type theory can be used to generate a class of algebraic structures called ML-complexes, and how these structures can be viewed as models of homotopy types.
01:55:44 <Nereid> I will attend this talk. :o
01:56:25 <solrize> what's that subject about?  i couldn't make any sense of it
01:56:29 <solrize> there's a blog about it
01:56:35 <Nereid> what subject?
01:56:38 <solrize> homotopy types
01:56:45 <Nereid> I have no idea!
01:56:48 <Nereid> guess that's why I'm going to this talk
01:57:03 <Nereid> part of a topology seminar here
01:58:02 <Nereid> anyway
01:58:05 <Nereid> time to sleep
01:58:34 <solrize> http://homotopytypetheory.org/
02:00:07 <Nereid> well
02:00:13 <Nereid> http://math.ucalgary.ca/news-events/events/workshop/ats-potsi-meeting
02:00:54 <Nereid> bye
02:01:02 <osfameron> I think "homotopia" is also a gay culture festival here in Liverpool
02:01:13 <solrize> lol
02:01:26 <merijn> osfameron: Stupid gay people stealing math terms!
02:01:41 <osfameron> they might be gay mathematicians?
02:01:58 <merijn> Apparently the lambda is also a gay symbol, which could get confusing in the vicinity of theoretical CS conferences :>
02:06:00 <solistic> Is anybody aware of ready-to-use VirtualBox images with haskell-platform-2011.2.0.1 installed (preferably a debian-base linux)?
02:06:54 <Jafet> That sounds pretty easy to make yourself
02:07:31 <solistic> Jafet: sure, but I'd not do it if it readily available
02:08:20 <ski> k0ral : ok, so you're referring to `fun CaseSensitive Forward Incremental' .. is it conceivable that the types containing `Forward' resp. `Incremental' could be augmented to have more than two values in the future ? if so, you should definitely use a new type, instead of `Bool'
02:08:30 <Jafet> I doubt anyone bothers to host a file that size if it's that easy to make
02:09:09 <ski> k0ral : i'm still not sure why you want them to be in a `Bool' class -- what are the operations on `Bool' that you want to reuse on these types ? `not' ? `(&&)' and `(||)' ?
02:09:20 <k0ral> ski: well, it's conceivable, though very unlikely
02:09:53 <ski> Nereid : "part of a topology seminar here" <- and where is that ?
02:10:20 <shachaf> ski: Presumably fromBool and toBool.
02:10:20 * ski notes an U of Calgary link ..
02:10:23 <k0ral> ski: do you often ask questions and give answers by yourself in the meantime ? :)
02:10:51 <ski> k0ral : sometimes. did i do it above ?
02:11:01 <k0ral> && and || are not compulsory though
02:11:19 <ski> i'm more wondering if they are meaningful/sensible in your case
02:11:28 <k0ral> well, not is certainly
02:11:45 <k0ral> && and || are optional, they kind of give a priority
02:11:48 <ski> so maybe you want a `class Opposite a where opposite :: a -> a' ?
02:12:10 <k0ral> well, you just changed the name
02:12:18 <ski> no
02:12:40 <k0ral> it should enforce the presence of only 2 alternative values
02:12:48 <ski> i didn't include any `(&&)'- or `(||)'- like operations, nor any `fromBool' or `toBool'
02:12:51 <k0ral> which opposite doesn't
02:13:16 * ski thought that maybe that would be an advantage :)
02:13:24 <k0ral> && and || should be optional so you did right by not including them
02:13:52 <ski> if they're not in the class, then a function `foo :: Opposite a => a -> ...' can't use them at all
02:14:16 <ski> (so they might as well not exist, as far as `foo' is concerned)
02:14:27 <k0ral> well, aren't there kind of optional members in a class ?
02:14:31 <ski> no
02:14:47 <ski> however, you *could* do a sub-class, that includes the "optional" members
02:15:00 <k0ral> with monads, don't you find a lot of operators that aren't enforced by the Monad class ?
02:15:15 <ski> you're thinking of members with default implementations
02:15:21 <k0ral> ah
02:15:22 <ski> aren't you ?
02:15:32 <k0ral> I suppose I am
02:15:44 <k0ral> that could be the same in a Bool class
02:16:12 <ski> how would you make a default implementation of an `(&&)'-clone, using only `opposite' (or whatever is *
02:16:16 <k0ral> a || operator would give priority to one of the alternatives, a && to the other
02:16:17 <ski> not* optional in the class)
02:16:18 <ski> ?
02:16:45 <shachaf> This whole thing is an abuse of type classes.
02:17:00 <k0ral> why so ?
02:17:11 * ski thinks probably so, but is not sure
02:17:11 <k0ral> I think it makes sense
02:17:33 <shachaf> k0ral: First you should be clear on what you're actually proposing. :-)
02:17:43 <k0ral> everything that has 2 alternatives should have an operator to switch from one to another, to give priority to one or another
02:17:49 <shachaf> The closest thing to what you're asking for (I think) would be a class IsBool with fromBool and toBool.
02:17:55 <k0ral> these are elegantly implemented with not && and ||
02:18:09 <k0ral> not really
02:18:27 <k0ral> I think of a polymorphic type that shouldn't need any cast
02:18:29 <shachaf> Yes it is. Using those two you can implement any Bool function.
02:19:01 <ski> k0ral : i don't see how "an operator to switch from one to another" would "give priority to one or another" ..
02:19:10 <shachaf> How do you decide which one is Falsey and which one is Truey?
02:19:17 <k0ral> ski: you misunderstood me
02:19:34 <k0ral> not is the operator that switch from one to another
02:19:41 <k0ral> && and || give priorities
02:20:24 <k0ral> shachaf: you wouldn't need to bother
02:20:36 <k0ral> if functions are properly written
02:20:50 <k0ral> they should accept instances of a Bool class when relevant
02:21:07 <ski> the "Falsey" one is the one which is an identity to the `(||)'-like operation :)
02:21:26 <k0ral> and the current "Bool" type would be an instance of the class
02:21:31 <shachaf> ski: Yes, that was the question. :-)
02:21:45 <ski> anyway, i think you really want named arguments / light-weight records, re your `fun CaseSensitive Forward Incremental' case
02:21:46 <Jafet> We should just write a prelude with dynamic scoping
02:22:33 <merijn> Jafet: eww
02:22:42 <Jafet> On types!
02:22:48 <ski> (possibly defining a new type in cases which could sensibly have more than two choices)
02:22:53 <merijn> Even most Lispers think dynamic scoping is a stupid idea by now
02:23:05 <k0ral> actually, I've given up the idea of changing my code, I will just stick with a sequence of True/False as function arguments and put in comments what they mean
02:23:17 <k0ral> I'm discussing it with you because I find it still interesting
02:24:22 <ski> hm the "no-implicit prelude" thing is basically doing dynamic scoping on the syntax level
02:24:50 <Jafet> GHC also has dynamic scoping on value bindings
02:25:01 <quicksilver> ski: no more so than 'import' is dynamic scoping
02:25:07 <Jafet> Not on type variables though, whatever that means
02:25:09 <quicksilver> (which is to say 'yes, in a way')
02:25:32 <quicksilver> cancel that.
02:25:35 <quicksilver> it's still lexical, surely?
02:25:40 <quicksilver> it doesn't pollute modules you call.
02:26:00 <merijn> quicksilver: import is not dynamic scoping...
02:26:31 <merijn> quicksilver: Not in a language with proper namespacing like Haskell anyway...
02:26:55 <quicksilver> no, that's why I said 'cancel that' :P
02:26:58 <shachaf> Implicit parameters are kind of dynamic scoping.
02:27:42 <merijn> quicksilver: Good, I'm not going crazy then :)
02:27:48 <ski> quicksilver : if you say `let (>>=) = .. in do x <- a; do y <- b; f x y' vs. `do x <- a; let (>>=) = .. in do y <- b; f x y', the outer `do' will unhygienically catch the local definition of `(>>=)' in the former case, but not in the latter case, no ?
02:28:32 <shachaf> (<<=) <- ...
02:29:06 <shachaf> s/</>/g
02:29:10 <shachaf> Grr, no.
02:29:16 <ski> quicksilver : it's dynamic scoping, on the "macro-expand" level .. i recall PLT Scheme^W^WRacket actually has support for doing macros which use dynamic scoping on the macro level
02:29:17 <merijn> ski: Why? The first let influencing both do's is expected behaviour, no?
02:29:49 <merijn> As far as I can read that the two do's are part of a single expression inside the "in", no?
02:30:00 <ski> merijn : `(>>=)' is not syntactically referred to by the `do'-expression
02:30:50 <ski> merijn : compare with `let ?x = 0 in f (g 42)' vs' `f (let ?x = 0 in g 42)', where `f' (and `possibly `g') uses `?x' as an implicit parameter
02:30:50 <merijn> That is a problem with the semantics/implementation of the sugaring then, not the scoping
02:30:59 <quicksilver> ski: hmm interesting.
02:31:14 <ski> the "desugaring" of the `do' is basically a macro-expansion
02:33:18 <jkramer> Ahoy
02:34:03 <jkramer> Is there a regex lib for Haskell that also allows string replacements instead of only matching?
02:34:20 <ski> quicksilver : <http://blog.plt-scheme.org/2008/02/dirty-looking-hygiene.html> talks some about dynamic scope on the macro-expansion level
02:34:27 <ski> in Racket, i.e.
02:34:39 <ski> (specifically, the "syntax parameters")
02:36:41 <ski> merijn : btw, note that i was claiming that "semantics/implementation of the sugaring" effects dynamic scoping, at the expansion-level :)
02:37:04 <ski> shachaf : hehe :)
02:37:53 <quicksilver> ski: this *kind* of thing is what makes me jumpy about macros in general. However I'm not experienced enough with them to have mature opinions.
02:37:56 <shachaf> jkramer: Apparently #haskellers are no good at regexps.
02:38:28 <merijn> #haskellers just write proper parsers :>
02:39:08 <Jafet> shachaf: explain pugs!
02:39:28 <jkramer> I don't want to parse anything, I just want to remove some pieces of text from another piece of text :)
02:39:45 <shachaf> Jafet: No one else has managed to, as far as I know...
02:40:27 <Jafet> hackage has a purported sed clone
02:41:49 <ski>   The basic idea is a change of perspective: instead of (unhygienically) binding individual occurrences of `it' whenever `aif' is used, you define it once as a thing in its own right : a special context-dependant piece of syntax.
02:41:53 <ski>   Outside of an `aif' form, `it' has no meaning: we simply make `it' throw a syntax error. Uses of `aif' provide a meaning for `it' by locally changing its meaning (its expansion) to something useful: the binding that holds the result of evaluating the condition expression. (\"Locally\" means within a piece of syntax, so the new meaning is valid in a lexical-scope.)
02:42:22 <jkramer> Jafet: Do you know the package name?
02:42:31 <jkramer> Ah, found it
02:42:33 <jkramer> hsed :)
02:42:33 <ski> this means that `it' basically behaves like an implicit parameter `?it' in GHC, but on the *syntax/macro-expansion* level
02:44:03 <ski> quicksilver : *hygienic* macros are a very nice concept. the above post though talked about what we might call "syntax effects" (side-effects, in this case dynamic scope, on the (abstract) syntax level)
02:44:30 <jkramer> The regex' I want to use are not too complicated though, maybe there's an easier way to do it. They're all of the form "\d+ foo" and "bar \d+"
02:45:48 <ski> quicksilver : typically, when you want a macro, you usually want a *hygienic* macro (don't believe Common Lispers who claim unhygienic ones, using `gensym' to kludge some aspects of hygience, painfully, are as good or better, for most uses :)
02:46:30 <ski> jkramer : matching on text is a kind of parsing ..
02:49:05 * ski str reading somewhere about regular expression patterns for Haskell ..
02:49:23 <Eduard_Munteanu> What, really? :)
02:49:37 <ski> possibly it was unimplemented, i'm not sure
02:49:43 <ski> it was some paper i saw
02:49:54 <jkramer> ski: The problem is that I need to be kind of flexible. I'm trying to migrate a perl script to haskell that read several regex' from a db and applies them to the input, so the regex could be virtually anything
02:50:17 <jkramer> But I think I could just use regex-pcre and use the match offest returned to remove the matched substring manually
02:50:36 <quicksilver> regex-pcre has all the tools you need to implement replacements
02:50:44 <quicksilver> you just don't quite get the replacement as a built-in
02:50:54 <ski> you could imagine things like (made-up syntax) `foo ("a" ++ replicate n "b" ++ s ++ "!") = ..n..s..' maybe
02:51:08 * Eduard_Munteanu thinks    s/Just \"\([a-z]+\)\"/Just \"--\1--\"/g   stuff :P
02:51:15 <jkramer> Yup, that's what I just figured. :)  IO (Either WrapError (Maybe (Array Int (MatchOffset, MatchLength)))) should be enough information for removing the matches
02:51:25 <Eduard_Munteanu> That'd be some horrific fun.
02:52:01 <Eduard_Munteanu> (well, that'd sed stuff, but still)
02:52:17 <jkramer> Hrm, any ideas why this is IO? Because it's using the external pcre lib?
02:52:55 <ski> jmcarthur : hm, beware that quite possibly, Perl's "regexp" (actually irregular) are not fully compatible with whatever Haskell regexp library you use
02:53:01 <Eduard_Munteanu> Or mutable arrays.
02:53:57 * ski pondered making a saner syntax for "dependent regexps", a while ago
02:56:54 <quicksilver> ski: hygienic is an interesting example of choosing your jargon deliberately to have 'emotional' subtexts
02:57:02 <quicksilver> ski: I wonder if there is a word for that practise.
02:57:33 <ski> (where you could specify `"a"^n ++ "b"^n', which would bind the variable `n', e.g. and also do stuff like `"foo" ++ (" " ++ (nonSpace^(_ + 1)) @ (bar i) )^(i < n) ")"' which would bind an array `bar' of size `n')
02:57:48 <Eduard_Munteanu> quicksilver: I'd think it is a particular case of strawmanning.
02:58:06 * ski thinks of "loaded wording"
02:58:40 <zygoloid> ski: interesting, i've been pondering a syntax for regexp-style pattern matches on arbitrary ADTs
02:59:02 <ski> quicksilver : anyway, afaik the term "hygienic macros" is accepted both by defenders and accusers
03:04:09 * ski str <http://synthcode.com/scheme/irregex/> supporting some matching on depth in trees, but it appears it's not in that link, at least
03:05:12 <ski> zygoloid : `<irregex 0> @ <irregex 1>' would obviously match the same string on both `<irregex 0>' and `<irregex 1>' (binding variables from both)
03:05:18 <Eduard_Munteanu> What's that 'str' thingy you keep saying?
03:05:25 <ski> "seem to recall"
03:05:28 <Eduard_Munteanu> Ah.
03:05:33 <ski> cf. "istr"
03:06:33 <iwtu> hello! :) I use vim like Haskell editor but it has really annoying indentatio problem. Have you guys ever met this thing?
03:07:13 <Eduard_Munteanu> iwtu: you should probably use soft tabs, if that's what you mean.
03:07:25 <Eduard_Munteanu> You want to know how to set it up?
03:08:14 <iwtu> Eduard_Munteanu: not yet :)
03:08:35 <Eduard_Munteanu> Or just describe your particular problem.
03:08:41 <merijn> Hold on, I'll paste the relevant part of my .vimrc
03:08:43 <iwtu> it solves a new line after where
03:09:17 <iwtu> merijn: thanks in advance :)
03:09:23 <merijn> vim soft tab settings: http://dpaste.com/549588/
03:09:38 <merijn> oh, typo
03:10:03 <merijn> shiftwidth should probably be 4, changed it to 2 for working on a legacy code base which use 2 space indents :p
03:10:41 <Eduard_Munteanu> I also use that autoloading stuff to deal with different indentation conventions.
03:11:22 <Eduard_Munteanu> like    au BufNewFile,BufRead *.hs source ~/vimrc/agda-utf8
03:11:31 <iwtu> merijn: and if I want shiftwidth 4 for other languages? :)
03:11:36 <Eduard_Munteanu> ^
03:11:40 <ski> (hm, found "trx: Regular-tree expressions, now in Scheme" at <http://shivers.com/~shivers/scheme04/tmp/scheme04/article/03-trx.pdf> by Olin Shivers,Ilya Bagrak, at least)
03:12:25 <Eduard_Munteanu> I also use it to differentiate between projects with such different conventions.
03:12:28 <merijn> iwtu: I use shiftwidth=4 for everything except my entire day is now spent working on a codebase which uses 2 space indents so I changed it to 2 temporarily
03:12:48 <Eduard_Munteanu> e.g.  au BufNewFile,BufRead */qemu-kvm/* source ~/vimrc/qemu
03:13:03 <merijn> iwtu: There is probably some spiffy way to set it like Eduard_Munteanu is showing, but I normally just have it hard set to 4
03:13:09 <ski> zygoloid : what kind of patterns do you want to use on arbitrary ADTs ("Algebraic ...", right ?) ?
03:13:24 <Eduard_Munteanu> (so you can also match paths)
03:13:54 <iwtu> merijn: Oh now I've understood. Sorry for my bad english. Eduard_Munteanu thanks too!
03:14:01 <ski> zygoloid : ones based on arbitrary contexts around a sub-expression ? or also things like composition and kleene star of contexts ?
03:19:06 <buzl> :( ihr könnt steine schmeißen ab jetzt
03:25:59 <cnJamesDeng> Does anyone know resiziable (dynamic) vector?
03:28:42 <jkramer> Yay, built my own incomplete sed with pcre \o/ http://paste.pocoo.org/show/399369/
03:28:52 <jkramer> And it's featuring shachaf :)
03:53:17 * ski wonders why jkramer bracketed the patterns in the `case' in `main' ..
03:55:16 <roconnor> cnJamesDeng: mutable or immutable?
03:55:34 <roconnor> cause I'm not sure how much sense resizable makes for immutable structures
03:55:47 <cnJamesDeng> mutalbe of course
03:56:04 <roconnor> of course
03:56:31 <cnJamesDeng> ArrayRef seems to support dynamic array, but it fail to install.
03:56:44 <roconnor> not knowing what you are doing, I'd recommend avoiding doing it that way.
03:57:26 <ski> jkramer : i might use `listToMaybe' instead of that matching in `replace' ..
03:57:58 <cnJamesDeng> I want to read tuples for a matrix, indicating row, col, val, and construct the whole matrix.
03:58:33 * ski also wonders why jkramer is doing fixpoint-iteration
03:59:23 <ski> (also, presumably you want `putStr' rather than `putStrLn' ?)
04:00:46 <ski> @pl \x f -> fix f x
04:00:46 <lambdabot> flip fix
04:00:51 <ski> @pl \x f -> fix (flip f) x
04:00:52 <lambdabot> flip (fix . flip)
04:01:55 <jkramer> ski: Can't install hlint because my ghc setup is broken again, also I was just testing if pcre works the way I expected it to, no need to optimize anything here :)
04:02:45 <ski> > let named x f = fix (flip f) x in named 5 $ \n loop -> if n == 0 then 1 else n * loop (n - 1)
04:02:47 <lambdabot>   120
04:03:36 <ski> jkramer : i was more thinking about cleaning up, rather than optimizing ..
04:04:42 <jkramer> Still I'm never going to look at that code again, I just wanted to test regex-pcre :)
04:04:59 <jkramer> Gotta fix my ghc install first anyway :(
04:05:06 <ski> hm, what does "pcre" stand for ?
04:05:15 <quicksilver> perl compatible regular expression
04:05:16 <jkramer> perl compatible regular expressions
04:05:19 <merijn> ski: Perl Compatible Regular Expressions
04:05:20 <jkramer> First \o/
04:05:21 <ski> ah
04:05:23 <merijn> damn
04:05:37 <ski> (jkramer : not on this side :)
04:05:39 <merijn> Which is to say "not regular expressions" :p
04:05:41 <jkramer> Pff
04:05:54 <quicksilver> merijn: they're hardly unique there - POSIX re isn't regular either.
04:05:56 <ski> irregular expressions
04:06:17 <Eduard_Munteanu> cnJamesDeng: don't you know the size of the matrix beforehand?
04:07:00 <jkramer> Is ghc 7 usable by now?
04:07:11 <merijn> jkramer: It's the default for Haskell Platform
04:07:36 <jkramer> Yeah, but last time I checked almost all packages failed to install with it, and people here told me to use 6.12 instead :)
04:08:46 <Saizan> it probably wasn't in the haskell platform then?
04:09:28 <Saizan> anyhow, i've found most things building fine on ghc-7
04:09:31 <jkramer> Probably, I can't really remember. I gave up when not even cabal was able to install :)
04:10:17 <jkramer> Are there binaries of the platform for non-deb/rpm-based distributions?
04:10:24 <jkramer> I.e. tar.bz2s? :)
04:10:45 <Eduard_Munteanu> Mm, you mean universal / statically-linked binaries
04:10:46 <jkramer> Or do I need to use the ghc binary and compile the platform?
04:10:49 <dcoutts> no, just source
04:10:50 <jkramer> Yup
04:10:59 <jkramer> Hrm, ok
04:11:24 <jkramer> Good thing I have 4 days off, lots of time to compile on my netbook :)
04:11:36 <Saizan> arch is non-deb/rpm and still has a haskell-platform in the repos
04:17:24 <k0ral> how safe is the use of -fno-warn-unused-do-bind for ghc ?
04:20:52 <mekeor`> k0ral: i dunno, but maybe they can help you in #ghc
04:21:02 <parcs> it serves as a tool to help against space leaks
04:21:19 <develhevel> what is the name for it when i have a funktion like (foo :: Int -> IO Int) and make (test <- foo 1) whats the name of the (<-)? is it a unpack/pack?
04:21:22 <jkramer> I got a question about laziness
04:21:23 <parcs> read the bug report on its implementation: http://hackage.haskell.org/trac/ghc/ticket/3263
04:21:23 <jkramer> length $ map (const $ succ 1) [1..1000]
04:21:34 <merijn> develhevel: It's called "bind"
04:21:43 <jkramer> Will length evalation the list to 1000x 2 or 1000x (const $ succ 1) ?
04:21:48 <jkramer> *evaluate
04:21:55 <merijn> develhevel: The non-syntactic sugar version is ">>="
04:21:59 <merijn> :t (>>=)
04:22:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
04:22:38 <k0ral> thank you, I'll keep the warnings then
04:23:19 <parcs> jkramer: http://stackoverflow.com/questions/578063/what-is-haskells-stream-fusion
04:24:04 <ski> develhevel : the `<-' in a `do'-expression is syntactic sugar, expanding as
04:24:07 <merijn> develhevel: Actually, (>>=) is the thing that is called bind, but do/<- turn into that, like so: "do test <- foo 1; someFunc foo"  "foo 1 >>= \x -> someFunc x"
04:24:17 <ski> @undo do x <- f y; g x
04:24:17 <lambdabot> f y >>= \ x -> g x
04:25:03 <ski> @undo do x <- f; y <- g x; h x y
04:25:03 <lambdabot> f >>= \ x -> g x >>= \ y -> h x y
04:25:36 <ski> that reads as `f >>= (\x -> g x >>= (\y -> h x y))'
04:26:26 <develhevel> okay thx
04:27:20 <jkramer> parcs: I don't really get it
04:29:46 <jkramer> What I really want to know is if the list elements are evaluated or not.
04:30:08 <jkramer> But I guess not, since the elements aren't really used anywhere
04:30:32 <McManiaC> can someone tell me why those instances are overlapping? there is no "MonadIO m" given for "String -> String"?! http://hpaste.org/47347/overlapping_instances
04:35:16 <Jafet> jkramer: length (map f xs) == length xs
04:36:26 <Jafet> If you used a debugger, you'd find that only the list structure of xs would be evaluated, and f would never be evaluated
04:36:51 <jkramer> Cool, thanks
04:38:13 <Jafet> ghci> import Debug.Trace; let xs = map (\x -> trace "f" $ succ x) $ map (\x -> traceShow x x) $ [1..100]; length xs; xs;
04:39:27 <zygoloid> ski: well, i'd like to see how powerful it's possible to make it. but certainly things like Just _:*(Nothing:as) would be interesting.
04:44:56 <zygoloid> f (Left a | Right (a, 0)) = a (would give f :: Num a => Either b (b, a) -> b)
04:45:46 <Jafet> Mmm regexp
04:46:41 <alpounet> zygoloid, reminds me of polymorphic variants in OCaml
04:48:16 <zygoloid> stripLeadingZeroes (a@((0:)*) as) = (length (a []), as)
05:13:34 <kuraj_> can anyone explain how the std length predicate works under the lid?
05:13:46 <kuraj_> i mean is the implementation available somewhere
05:13:52 <duairc> @src length
05:13:53 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
05:13:59 <kuraj_> oh well
05:14:13 <kuraj_> i have a couple of those
05:14:49 <kuraj_> "head $ 1 : loop", "fst (1, loop)", "length [loop, loop, loop]" where loop :: a and loop = loop
05:15:02 <kuraj_> and i have to explain why those actually compute and dont fall into a loop
05:15:11 <kuraj_> but i cant come up with a specific answer for each of those
05:15:28 <kuraj_> i mean, it all comes to the fact that haskell is lazy, right
05:15:51 <mun_> when one says a logical theory T is stronger than a logical theory S, does that mean T has fewer satisfiable models than S? if so, does that also mean that there are fewer sentences derivable from S than from T?
05:15:55 <duairc> kuraj_: http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/src/GHC-List.html#length
05:16:04 <kuraj_> the first two are fairly easy to deduce but the length one got me stumped
05:16:29 <Saizan> ugh, that length source is ugly
05:16:36 <kuraj_> thank you duairc
05:17:35 <Saizan> length = foldl' (+1) 0 -- a bit better :), but the easier to work with is probably length [] = 0; length (x:xs) = 1 + length xs
05:17:50 <kuraj_> well i do know the foldl implementation
05:17:51 <Saizan> they are denotationally equivalent
05:18:00 <kuraj_> i see
05:18:23 <kuraj_> so it comes down to the fact that haskell doesnt even need to know what loop is
05:18:35 <kuraj_> to determine the length of [loop, loop, loop]
05:18:51 <Saizan> yep, the element, "x", is completely ignored
05:18:55 <Aune> What is a closure? I don't know if I'm being stupid or not, but I can't see any conceptual difference between lisp closures and partial application as is done in Haskell.
05:19:14 <kuraj_> and Saizan, this just reminded me of something I'd do in Prolog
05:19:19 <kuraj_> :P
05:20:25 <LeNsTR> http://hackage.haskell.org/package/mime-mail
05:20:26 <Saizan> Aune: "closure" usually refers to a fairly low-level implementation detail of first-class functions
05:20:35 <LeNsTR> is there other packages for send mail?
05:21:05 <kuraj_> Saizan: how come i can simply use (+1) as the first argument of foldl'?
05:21:12 <kuraj_> my implementation looked like this:
05:21:24 <kuraj_> length' foldl f 0 where f acc _ = acc + 1
05:21:46 <Aune> Saizan, maybe Im using the wrong word here.
05:22:00 <kuraj_> length' = *
05:22:31 <Saizan> kuraj_: heh, i was wrong, sorry, i should have said foldl' (\acc _ -> acc + 1) 0
05:22:57 <kuraj_> i see
05:23:17 <kuraj_> uhh
05:23:25 <kuraj_> how do i interrupt in ghci
05:23:37 <Saizan> C-c
05:23:51 <kuraj_> what?
05:23:56 <kuraj_> (i'm using windows)
05:23:59 <Saizan> ctrl+c
05:24:10 <kuraj_> doesnt work
05:24:34 <kuraj_> neither does ctrl+z or ctrl+pause
05:25:00 <Saizan> sometimes it's unresponsive
05:25:09 <kuraj_> well now i have these
05:25:49 <kuraj_> length ones; sum ones; last ones; where ones = 1 : ones
05:26:05 <kuraj_> and i have to determine whether these will loop indefinitely or cause a stack overflow
05:26:42 <kuraj_> i can determine that by noticing my PC failing at performance..but that probably isnt a satisfying answer :D
05:26:57 <jkramer> All will overflow, since all those functions will have to evaluate all elements of the infinte list
05:27:02 <kuraj_> length ones looks like it will just loop.. because it will just add up to the integer
05:27:04 <Saizan> mh, that's fairly sensitive to the precise details of the implementation
05:27:17 <kuraj_> i dont see how length utilizes a stack though
05:27:41 <kuraj_> and in fact it didn't crash my computer
05:27:54 <Twey> @src length
05:27:54 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
05:27:56 <jkramer> length (x:xs) = 1 + length xs
05:27:58 <Twey> o.@
05:28:03 <jkramer> Just a guess :)
05:28:06 <Twey> Yeah
05:28:11 <Saizan> no
05:28:13 <kuraj_> jkramer if this is true then it will just loop
05:28:19 <Twey> length [] = 0; length (_ : xs) = 1 + length xs
05:28:23 <Twey> No?
05:28:51 <Saizan> if it's defined like that it'll stack overflow, but the sane definition is not like that
05:29:26 <Twey> Will it?  I thought Ints were strict and it got optimised
05:29:59 <Saizan> length = length' 0 where length' acc [] = acc; length' !acc (x:xs) = length' (acc+1) xs
05:30:12 <kuraj_> what the hell
05:30:44 <Twey> I was of the understanding that the naïve version got translated into something like that anyway when compiled with optimisations
05:30:48 <Saizan> they are strict, but ghc won't transform non-tail recursion into a tail one
05:30:57 <Twey> Oh
05:31:19 <kuraj_> Saizan : what you just said was actually very helpful
05:31:44 <kuraj_> i guess the answers to these are really non trivial
05:31:51 <kuraj_> and i will have to discuss it with my supervisior
05:32:22 <Saizan> "last ones" should be straightforward
05:32:32 <Aune> From Wikipedia: "In computer science, a closure (also lexical closure, function closure or function value) is a function together with a referencing environment for the nonlocal names (free variables) of that function."
05:32:49 <kuraj_> Saizan: last ones clearly looks like it would cause a stack overflow
05:33:19 <Saizan> kuraj_: why do you think so?
05:33:32 <kuraj_> .. or does it
05:34:01 <Aune> But if we only have non-mutable variables then this ought to be the same as partially applying the function at the creation of the closure and passing it on, or am I wrong?
05:34:08 <dankna> dcoutts: ping
05:34:25 <kuraj_> do i understand right that in order to access the tail of a list, haskell needs to continue chopping off heads until there is only one element left?
05:34:33 <Twey> Yes
05:34:35 <dankna> kuraj_: yes.  that's how linked lists work.
05:34:40 <Twey> That's how singly-linked lists work
05:34:50 <dankna> yeah, rather
05:35:00 <kuraj_> yeah - i wasnt sure whether haskell implements singly or doubly linked lists
05:35:10 <Twey> You can always use a different data-structure, of course: Seq will allow you to access the last element
05:35:28 <Twey> IIRC Seq is a doubly-linked list
05:35:28 <kuraj_> i guess
05:35:46 <Saizan> Seq is a finger-tree
05:35:56 <Twey> Oh
05:35:59 <kuraj_> so it's basically the same way it works in prolog, except that it has nicer functions for operating on lists available OOTB
05:36:04 <Twey> >.>
05:36:12 <Twey> kuraj_: It has to be, if they're to be lazy
05:36:18 <Saizan> doubly linked lists are not that great if immutable, you get no sharing
05:36:29 <Twey> kuraj_: You can't link to the tail end of a potentially infinite list
05:36:31 <kuraj_> i guess you have a point
05:36:52 <kuraj_> ok
05:37:06 <kuraj_> sum ones does cause a stack overflow
05:37:08 <kuraj_> apparently
05:38:20 <kuraj_> and i dont quite get why; one would think it works exactly the same way as length except instead of adding 1 to the accumulator it adds value of head$ones instead
05:39:02 <Saizan> Aune: you could implement partial application by splicing in the body of the function the values of the given arguments, but that's not how e.g. GHC implements it, since it's more efficient to have a closure, immutability means you don't have to care much about how they are implemented though
05:40:26 <Saizan> kuraj_: stack or heap overflow?
05:40:39 <kuraj_> either
05:40:58 <Saizan> they are fairly different
05:41:33 <kuraj_> yes, but i have to determine, whether the expression a) stops, b) loops infinitely, c) diverges (either on the heap or stack)
05:41:36 <ben> i only noticed ballooning memory usage before I got desperate and shot the process :>
05:41:47 <ben> @source sum
05:41:48 <lambdabot> sum not available
05:42:18 <Aune> Saizan, Ok... Hmmm. I think I have to ponder this for a while. I think that what I'm really wondering is, what exactly is "continuation passing style".
05:42:54 <erus`> how can i do bitboards with haskell?
05:43:08 <Saizan> erus`: Data.Bits ?
05:43:09 <erus`> CInt64 or something?
05:43:29 <Saizan> Data.Word has Word types
05:43:31 <ben> There's Data.Word and it's Word64
05:43:34 <ben> its
05:44:53 <ben> Why is sum defined as foldl (+) 0 ad not foldl'
05:45:38 <Saizan> Aune: in short, continuation passing style is when instead of plainly returning a result, you take a callback to call with that result instead
05:46:04 <kuraj_> ok guys
05:46:13 <kuraj_> your help is very much appreciated :) i'm off for today
05:46:16 <Saizan> ben: historical reasons, basically when writing down the standard they didn't bother to specify foldl'
05:47:21 <ben> What is it gaining anyone? How would you notice if it was silently changed to foldl'?
05:47:52 <ben> I suppose if you wrote a crazy Num instance, welp
05:48:10 <Saizan> exactly
05:48:37 <Aune> Saizan, I think I was a bit premature in asking that question, Im going to try to read through the wikipedia article again. I'll be back later ^^
05:48:45 <ben> I'm trying to think of a way to set it up so that sum ones > 10 does not diverge :v
05:49:02 <Saizan> but i think it'd be a fairly no-brainer if anyone was willing to make a libraries@ proposal
05:49:07 <jkramer> @source fold'
05:49:07 <lambdabot> fold' not available
05:49:13 <jkramer> @source foldl'
05:49:13 <lambdabot> foldl' not available
05:49:21 <Saizan> @src foldl'
05:49:21 <lambdabot> foldl' f a []     = a
05:49:21 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
05:49:22 <ben> jkramer: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#foldl%27
05:49:26 <ben> oh, dear
05:49:37 <ben> I didn't notice I had spelled that the wrong way. Cheers.
05:59:49 <roconnor> ezyang: *ping*
06:06:59 <Jafet> ben: (sum ones :: Nat) > 10
06:08:29 <ben> Where do I get a reference implementation of Nat from?
06:08:43 <Jafet> It's an easy exercise to write
06:10:31 <erus`> has anyone ever heard of a language that has an operator '%' that does something like '$' in haskell
06:10:47 <erus`> i think i might have dreamt it :/
06:11:04 <Jafet> http://hpaste.org/47352/nat_again
06:11:11 <erus`> you know you need to get out more when you start inventing programming languages in your dreams
06:12:00 <Jafet> Use some more programming languages, to crush your dreams
06:12:00 <develhevel> i have a [(String, (String, String))] and i have implemented a function, when the first String is empty, it should be deletet, isn't there a for something? its like map with deliting items
06:12:22 <ben> Sounds like you could do that with a fold
06:12:22 <Jafet> develhevel, filter
06:12:31 <ben> Or look at where someone does it with a fold. Whoops.
06:12:48 <Jafet> Yeah, yeah, everything can be done with a fold
06:13:16 <ben> Fine, do it with a map of a function a -> Maybe a and then use catMaybes. >:[
06:15:13 <develhevel> Jafet: could you tell me how the filter function sohuld look like? (fst . not . "") ?
06:15:56 <Jafet> (\(str, _) -> ...)
06:18:57 <develhevel> Jafet: (\(str, _) -> str /= "") gives an error
06:20:05 <erus`> how do i make a new data type with named members? so i can access each member without having to write a function todo that?
06:21:52 <merijn> erus`: data Foo = Foo { bar :: Int, baz :: Bool}
06:22:08 <erus`> ah perfect
06:22:10 <erus`> thanks
06:22:41 <develhevel> Jafet: found it :-)
06:22:54 <merijn> erus`: The only catch being that bar/baz are just converted into normal functions and are thus subject to having a unique name (as all functions of course are)
06:23:32 <merijn> erus`: Which means that given that definition of Foo I can't define "data Something = Something {bar :: Int}" (bar will already be in use)
06:23:40 <merijn> Or for that matter any function named bar
06:23:41 <azaq23> develhevel: fst . not . "" doesn't make sense, as "" isn't a function and not :: Bool -> Bool (not connected with Eq and /=)
06:23:42 <erus`> ok no probs
06:25:00 <azaq23> s/not connected/'not' isn't connected/
06:27:43 <merijn> It's not possible to reify (am I using that right?) arbitrary strings on the type level, right? I'm writing a compiler and wanted to encode the types in the AST in haskell's type system
06:28:24 <dankna> well
06:28:29 <merijn> Oh wait, maybe I can do it with type level naturals
06:28:34 <erus`> merijn: i have quite a large data type (16 members). When i need to modify a single member and retur the result i have to rebuild the whole type (does that make sense) its very verbose
06:28:35 <dankna> I suppose you could make type-level characters
06:28:59 <azaq23> merjin: What you want is dependent typing; haskell / ghc extensions doesn't offer this, but GHC has a specific extensions for type level natural numbers.
06:29:20 <develhevel> why "filter (\(str, _) -> str /= "") [("a", "b",("a","b")), ("c","d")]" dont work?
06:29:21 <merijn> azaq23: I know I want dependent types :p
06:29:23 <dankna> did that extension make it in?  I thought it was still to be committed
06:29:33 <merijn> dankna: I thought it was in
06:29:38 <dankna> hmm
06:29:51 <merijn> Any link to details about that extension?
06:29:57 <dankna> yeah one sec, trying to find it
06:30:16 <dankna> http://hackage.haskell.org/trac/ghc/ticket/4385 appears to be the ticket but it's still loading for me
06:30:55 <dankna> looks like you could compile against the patch in the expecation that it'll make it in in a pretty similar form
06:30:57 <dankna> but it's not in yet
06:31:09 <merijn> The source language has types which essentially are unions of tags (which are strings), but its trivial to associate the tags with naturals internally and then use type level naturals...
06:31:10 <dankna> the discussion there also links to http://hackage.haskell.org/trac/ghc/wiki/TypeNats
06:31:21 <dankna> yeah, that's what I'd do
06:32:09 <merijn> If they're not in yet I might stick with checking the types myself instead of encoding them fully in the Haskell type
06:33:14 * dankna nods
06:34:13 * roconnor writes a function returning Bool and feels icky
06:34:33 <Twey> roconnor: Why?  :þ
06:34:42 <Twey> Needs more MonadPlus?
06:35:23 <roconnor> because the proper thing to do is to split the input into Either invalidData validData
06:35:32 <roconnor> otherwise the type learn nothing from your Bool test
06:35:46 <roconnor> I don't know how to explain myself very well
06:35:46 <Twey> So why did you return Bool instead?
06:35:59 <Twey> No, I understand
06:36:01 <roconnor> because I don't know how to write a type to capture this invarient
06:36:06 <Twey> Ah
06:36:29 <roconnor> maybe I should use a new type wrappar newtype ValidType = ValidType RawType
06:36:47 <roconnor> but this first version is throw away code, so it is alright ...
06:36:48 <roconnor> right?
06:36:57 <roconnor> everyone throws away their first implementation ...
06:37:01 <Twey> Heh
06:37:20 <Twey> Haskell seems to be much more prone to throwing away and redesigning than other languages I've encountered
06:38:06 * roconnor is tempeted to return Maybe () instead of Bool
06:38:32 * roconnor gives into temptation.
06:38:38 <applicative> Maybe () is much cooler.  I think the information content is the same.
06:39:35 <roconnor> @undo do {() <- foo; return 7}
06:39:35 <lambdabot> foo >>= \ a -> case a of { () -> return 7; _ -> fail ""}
06:39:39 <roconnor> @undo do {_ <- foo; return 7}
06:39:40 <lambdabot> foo >>= \ _ -> return 7
06:39:46 <ben> well, there's one more place to stuff undefined into
06:39:47 <roconnor> good to know
06:40:25 <roconnor> I usually only consider total values when writing code.
06:41:00 * applicative does too, but then it turns out they aren't total ...
06:41:11 <roconnor> applicative: the nice thing about Maybe () is that I can use Map.lookup, and guard etc.
06:41:20 <roconnor> applicative: sounds like an error.
06:41:43 <applicative> Oh that's true, more options are around.
06:42:30 <roconnor> @undo do {foo; return 7}
06:42:31 <lambdabot> foo >> return 7
06:42:37 <applicative> even though its obvious, i was much affected by R. Harper's tirades against Bool
06:42:55 <isomorphic> Could somebody help me translate an error from ghc?  I've pasted the code (including the error) at http://hpaste.org/47353/takes_one_argument
06:43:01 <roconnor> > do {() <- Nothing; return 7}
06:43:02 <lambdabot>   Nothing
06:43:06 <roconnor> > do {_ <- Nothing; return 7}
06:43:07 <lambdabot>   Nothing
06:43:25 <roconnor> ah
06:43:26 <roconnor> good
06:43:30 <ben> How far would you get just making a Monad instance for bool that always passes undefined to >>=
06:43:33 <roconnor> > do {Nothing; return 7}
06:43:34 <lambdabot>   Nothing
06:43:52 <roconnor> that's awsome.  I can just put my foo :: Maybe () into the middle of a do block
06:43:54 <roconnor> @type guard
06:43:55 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
06:44:01 <roconnor> I guess that is what guard does
06:44:25 <applicative> isomorphic, what is Gen is it a function type?
06:44:27 <isomorphic> I am surprised it tells me that the type of the first argument has no arguments - since I've specifically told it the type is haystackWithNeedle ::  String -> Gen [Tag String]
06:44:36 <roconnor> maybe I should make it polymorphic over MonadPlus instead of Maybe
06:44:55 <dolio> ben: Not very far.
06:44:57 * applicative hasn't been using quickcheck
06:45:00 <isomorphic> applicative: it's a Generator for Test.QuickCheck
06:45:20 <applicative> isomorphic, yes, but that's why it doesn't need any more arguments
06:45:30 <applicative> the function it is complaining about is '$'
06:45:38 <ion> haystackWithNeedle :: String -> Gen [Tag String]
06:45:42 <ion> haystackWithNeedle needle :: Gen [Tag String]
06:46:12 <applicative> ^^^ like ion says
06:46:31 <applicative> so " haystackWithNeedle needle $ foo " is nonsense
06:47:31 <isomorphic> So.. It should be haystackWithNeedle $ foo ?
06:47:40 <applicative> sioraiocht has too many nicks.  rtharper put fear in his heart.
06:47:55 <sioraiocht> lol?
06:48:00 <applicative> isomophic, yes, at worst youll get a new error
06:48:52 <applicative> sioraiocht: sorry, just the connection with my neighbor professor robert harper, high-class haskell-basher, again.
06:48:59 <sioraiocht> yes
06:49:01 <sioraiocht> people love to confuse us
06:49:09 <sioraiocht> though I've been quite fond of python recently
06:49:45 <applicative> those people won't mistake you for Mr Types
06:49:55 <dolio> The middle initial is different.
06:50:03 <stulli> isomorphic: Where does \haystack come from? Maybe you need >>= instead of $?
06:50:05 <isomorphic> applicative: I'm a bit lost - what I mean to do is pass a string to a generator - am I doing that wrong?
06:50:44 <isomorphic> stulli: the plan was for haystack to come from the (haystackWithNeedle needle)
06:50:48 <isomorphic> but I'm still very much learning ;)
06:51:05 <isomorphic> >>= looks hopeful
06:53:30 <stulli> isomorphic: So locateSubstring is of type 'String -> [Tag String] -> String' ?
06:54:14 <McManiaC> http://hpaste.org/47354/whitespacerecords__recordvalu *want*
06:54:15 <McManiaC> :D
06:54:20 * hackagebot iteratee 0.8.5.0 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.5.0 (JohnLato)
06:54:28 <ben> What's [::] ?
06:54:44 <applicative> parallel array?
06:54:58 <ben> cheers
06:55:49 <applicative> isomorphic, (haystackWithNeedle needle) :: Gen ..., so maybe you should be doing  do needly <-  haystackWithNeedle needle ; then something
06:56:24 <applicative> isomophorphic, forgive me father, it has been one year since I last used quickcheck
06:56:49 <isomorphic> stulli: actually, it was  'String -> [Tag String] -> Bool', but your type inference was spot on - I've corrected this code to reflect the Bool typ
06:57:47 <isomorphic> applicative: gosh, don't be apologetic - all of this is very helpful! It's about the process
06:59:39 <applicative> McManiaC: you're out of control!
07:00:03 <applicative> McManiaC:  what is whitespace records, I'm not seeing what I might have guess
07:00:07 <applicative> guessed
07:01:05 <applicative> I see, whitespace doesn't mean no curly brackets
07:02:19 <McManiaC> applicative: only no ','
07:02:19 <McManiaC> :D
07:02:29 <McManiaC> it's just an idea which I really like
07:02:45 <McManiaC> might be something to hack on :D
07:03:39 <applicative> McManiaC: is it possible to build a ghc with the monad comprehensions?
07:03:49 <McManiaC> yes, it's in HEAD
07:04:42 <joe6> what is monad comprehension?
07:05:15 <isomorphic> applicative: is this vaguely what you had in mind?  Incidentally, GHC hates my rendition ;)         -- do haystack <- haystackWithNeedle needle ;   True == locateSubstring needle haystack
07:06:31 <applicative> isomorphic (True == ..) wont be a 'monadic' value, it would just be a Bool.
07:06:50 <isomorphic> applicative: spotted that - have added a return
07:06:57 <isomorphic> (thanks!)
07:07:04 <applicative> in general thoughh True == x is the same as x
07:07:22 <isomorphic> ah - yes, good point
07:07:29 <applicative> so it's maybe :   return $ locateSubstring needle haystack
07:08:02 <applicative> which shows the whole thing is an fmap, by the way:  fmap (locate subString needle) (haystackWithNeedle needle)
07:08:23 <applicative> or:  locate subString needle <$> haystackWithNeedle needle
07:08:41 <isomorphic> applicative: your namesake?
07:09:30 <applicative> isomorphic: yes, i was into <$> when i first appeared here, now a long time ago :) i'm thinking of changing to yoneda or frege or something
07:10:11 <isomorphic> well, in that spirit, I'll keep my name the same
07:11:26 <Mathnerd314> but isomorphic to /what/, that's the question
07:12:18 <isomorphic> Mathnerd314: I'd missed that :P
07:12:31 <applicative> isomorphic, not that it matters, but your previous function doesn't need do either:  haystackWithNeedle needle = concat <$> [tagStrings, tagTextElement needle, tagStrings]
07:13:01 <isomorphic> applicative: the code review is helpful :)
07:13:37 <erus`> @hoogle [a] -> Data.Word
07:13:37 <lambdabot> Parse error:
07:13:37 <lambdabot>   --count=20 "[a] -> Data.Word"
07:13:37 <lambdabot>                         ^
07:13:41 <applicative> do notation might be clearer, but that ^^^ doesn't seem like it's tending to point free madness
07:13:43 <erus`> @hoogle [] -> Data.Word
07:13:43 <lambdabot> Parse error:
07:13:43 <lambdabot>   --count=20 "[] -> Data.Word"
07:13:43 <lambdabot>                        ^
07:14:10 <erus`> @hoogle [is there built in function to get a work from list of bits?
07:14:10 <lambdabot> Parse error:
07:14:10 <lambdabot>   --count=20 "[is there built in function to get a work from list of bits?"
07:14:10 <lambdabot>                                                                          ^
07:14:18 <erus`> whoops
07:14:20 <isomorphic> applicative: that looks way better
07:14:39 <merijn> What is the relation between inductive families and GADTs (i.e. what are the differences/similarities)? Or are they completely different and am I an idiot for not seeing that?
07:15:16 <applicative> intuitively you want to concatenate them but they're not strings, but string-related things
07:15:28 <applicative> but there's somethign wrong with the def I just gave, just a sec
07:16:21 <isomorphic>  concat <$> [tagStrings, tagTextElement needle, tagStrings]?
07:16:37 <dolio> merijn: Inductive families have small indices (a type T). GADTs have large indices (kinds).
07:16:46 <applicative> yeah, i'm mistaking a list of Gens for a Gen of a list
07:16:52 <byorgey> merijn: they are quite similar. The main difference (which is quite a big difference) is that GADTs are not dependent.
07:17:01 <byorgey> what dolio said.
07:17:28 <dolio> The latter are somewhat more dubious from a foundational standpoint.
07:17:29 <merijn> byorgey: Yeah, that's what I figured
07:18:25 <merijn> dolio: That means that if you are working in something like ECC (infinite hierarchy of kinds which all embed the lower hierarchies) then inductive families are a superset of GADTs, right?
07:18:54 <dolio> It depends on whether large indices are allowed.
07:19:27 <dolio> Large indices are arguably impredicative.
07:19:54 <dolio> So if you're suspicious of that, you'd probably rule them out.
07:20:18 <applicative> is the defense of GADTs that the space of Haskell types isn't so big?
07:20:22 <isomorphic> hrmm.. applicative - it type checks okay as you wrote it
07:20:24 <applicative> i guess it's still impredicative
07:20:45 <dolio> Haskell with GHC extensions is impredicative all over.
07:20:46 <Yrogirg> hello! how do I update all the installed packages from cabal?
07:20:55 <dolio> So the defense is that we don't care.
07:20:56 <isomorphic> wait check that.
07:21:05 <applicative> isomorphic, maybe it's okay, i haven't got clear on my worry yet. I'm easily confused about f (m a) and m (f a) -like things...
07:21:43 <byorgey> Yrogirg: I don't know of a good way.  The 'cabal upgrade' command should not be used as it often leads to problems.
07:21:47 <isomorphic> applicative: well thanks, the doubt is oddly pedagogical
07:22:14 <dcoutts> byorgey, Yrogirg: there's a new cabal world target, but it's not great yet
07:22:38 <merijn> dolio: I'm not smart enough to feel suspicious about impredicativity (is that even a word?) :p
07:23:32 <applicative> isomophic, certainly something like liftM2 (++) (liftM2 (++) tagStrings tagTextElement needle) tagStrings would typecheck, though it's ugly. Its the list I made that has me worried/
07:23:34 <dolio> merijn: Well, the gist is that it's a type of circularity, but not one that's known to be vicious.
07:23:59 <dolio> So, we know that Set : Set lets you write loops.
07:24:15 <dolio> And there are actually certain levels of impredicativity that let you do the same.
07:24:40 <applicative> merijn, the expression is due to Poincare
07:25:01 <dolio> But, there are systems that ride the line very closely, and no has found a way to write an infinite loop in them.
07:25:46 <aristid> dolio: but not proven that it's impossible either?
07:25:48 <dolio> However, one might be suspicious that we simply haven't found the problem with the seemingly consistent impredicative systems yet.
07:26:11 <dolio> It depends what you mean by that.
07:26:25 <applicative> the difficulty with something like impredicativity is that it looks like it's the source of contradiction in some places, so it must be bad period, even where there's no contradiction.
07:26:35 <applicative> it is the 'bad company' argument, as they call it.
07:26:42 <dolio> There are strong normalization proofs of the calculus of constructions.
07:27:04 <merijn> On completely unrelated note, does it matter whether I write "Maybe Expr Bool" vs "Maybe (Expr Bool)" (i.e. are these the same type or not)
07:27:14 <dolio> But they probably require an impredicative theory. Like set theory.
07:27:17 <ski> merijn : different
07:27:28 <applicative> only the latter will typecheck, surely
07:27:31 <merijn> Bollocks
07:27:36 <ski> merijn : the former is `(Maybe Expr) Bool'
07:28:00 <applicative> in other words it might as well be Bool Bool
07:28:21 <ski> (in ML you could write that as `bool expr option', though ..)
07:28:52 <merijn> I can already feel my parenthesis allergy...
07:29:16 <applicative> merijn, I don't the ML is the answer to that....
07:29:44 <ski> (merijn : try switching to round brackets, instead ? ;)
07:31:37 <applicative> dolio, set theory is impredicative from one point of view, but the usual thought is, one works with a prior conception of the domain, V, so what does it matter if you isolate a set with for all x ....
07:32:13 <merijn> oh, better solution
07:32:17 <applicative> but if it a question whether something has actual content to begin with, then impredicativity makes things seem sort of hopeless.
07:32:38 <merijn> Just turn "Maybe (Expr Bool)" into "Expr Bool" and just parse empty expressions as true :p
07:33:39 <applicative> I dimly remember Goedel saying we can reason 'impredicatively' if we have a prior conception of the domain and reason classically, but where we are 'constructing' the domain it is out.
07:33:46 <ski> merijn : what are you doing ?
07:34:31 <applicative> merijn, how about type BoolExpr = Expr Bool
07:34:54 <dolio> If you want to use set theory as a foundational theory, I don't see how you can use that excuse.
07:34:56 <ski> (the characterizations of constructions in category theory, usually by adjunctions, are impredicative, so they're only specifications, not implementations)
07:35:20 <applicative> then foo :: Int -> Maybe BoolExpr
07:35:46 <merijn> ski: Writing a compiler, some actions have an optional guard. If the guard is true or there is no guard the action gets executed. So it's just as easy to remove the Maybe and have the parser insert a constant true when it parses no guard
07:35:56 <applicative> dolio, I think I agree, I don't totally understand the impredicativity quesion, especially with type theory.
07:36:35 <ski> @hoogle optional
07:36:35 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
07:36:35 <lambdabot> Text.Parsec.Combinator optional :: Stream s m t => ParsecT s u m a -> ParsecT s u m ()
07:36:35 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
07:36:46 <dolio> Anyhow, my larger point was: you can prove the normalization of CoC, but only by using a system whose consistency/normalization is probably even more dubious if you're actually concerned about the possibility that CoC might not be kosher.
07:36:55 <applicative> part of the charm of moderne type theory is that it brings up all these old questions from the turn of the century that the apotheosis of set theory swept under the carpet
07:37:56 <applicative> those slides of Coquand about 'homotopy type theory' were especially pleasing for being so historical, like Per M-F himself. All these riddles about extentionality reducibility etc
07:38:27 <ski> which slides ?
07:38:32 <applicative> hmmm
07:38:36 <dolio> And if you have a type theory with Type : Type, it can prove its own strong normalization.
07:38:59 <dolio> And probably even in a way that isn't trivially detectable as vicious.
07:39:08 <isomorphic> Hrmm - I have a function that returns a Bool - locateSubstring :: String -> [Tag String] -> Bool  -  should this satisfy the Gen Prop type, or is GHC right to whine?
07:39:41 <isomorphic> (re: http://hackage.haskell.org/packages/archive/QuickCheck/2.4.1.1/doc/html/Test-QuickCheck-Property.html#t:Testable)
07:39:55 <ski> is `Tag String' in class `Arbitrary' ?
07:39:56 <applicative> ski http://www.cse.chalmers.se/~coquand/equality.pdf   very nice, i drew diagrams all over my copy.
07:40:42 <isomorphic> ski: not yet - should I make an instance/
07:40:46 <isomorphic> instance?*
07:41:19 <applicative> dolio, yes that's what I was wondering, impredicativity doubts seem to be independent of things like strong normalizability
07:41:37 <ski> if `locateSubstring' is a property you want to check, then you probably want a way to randomly generate `Tag String's, yes
07:41:56 <ski> presumably you will have an `instance Arbitrary a => Arbitrary (Tag a)' ..
07:42:55 <isomorphic> oh - well, It's possible that I'm skinning that cat a different way
07:43:02 <isomorphic> (although to be honest, I'm not sure)
07:43:24 <isomorphic> I have a function haystackWithNeedle ::  String -> Gen [Tag String]
07:43:30 <isomorphic> I think I'm using it for that purpose
07:43:34 <ski> how are you trying to use `locateSubstring' ?
07:43:54 <isomorphic> prop_LocateSubstring needle = locateSubstring needle <$> haystackWithNeedle needle
07:44:17 <isomorphic> Idea being to make a haystack with the needle in it, then find the needle
07:45:21 <isomorphic> The plan is that prop_LocateSubstring :: String -> Gen Prop
07:45:32 <dolio> applicative: Well, there's no ultimate reason to think that a predicative system is any better, since you can only prove they're kosher by resorting to a system that you're less sure about.
07:46:02 <dolio> But since paradoxes rely on self-reference of various sorts, systems that try to have as little of that as possible seem safer.
07:46:27 <ski> isomorphic : i suppose that alone doesn't require the `Arbitrary' instance for `Tag' ..
07:46:33 <applicative> dolio, i guess, but I don't think a consistency proof is of interest.  The question is whether one is expressing content, actual thoughts. or just making 'ideal propositions' in Hilbert's sense
07:46:57 <isomorphic> ski: Yeah, fundamentally, I'm thinking that a Prop and a Bool are in a loose sense, the same
07:47:04 <applicative> and thus in this context making a machine for calculating that yields deterministic results, but that you dont understand
07:47:12 <dolio> That isn't my question, usually.
07:47:42 <applicative> dolio, but i think i wasn't the classical doubt despite the salience of contradiction in that period.
07:48:15 <applicative> it was whether we were actually defining anything when we defined impredicatively, or just making up names
07:49:12 <isomorphic> (I actually have other test functions that return Bools and type check fine - this one is a bit weird)
07:49:13 <applicative> if you have prior confidence in the content of the system, and think you have a clear conception of the range of variables, etc etc., then it seems silly to worry;
07:49:41 <erus`> how can coerce an Int into a Data.Word64?
07:49:57 <ski> isomorphic : hm, are you sure you want `Gen Prop' rather than `Prop' ?
07:49:57 <applicative> but where you think you are constructing everything by degrees, the quantifiers used in the impredicative definition will so to speak mean something different later.  that's a bit crude
07:50:45 <newbie```> hello everyone
07:50:53 <applicative> hey newbie``` !
07:51:18 <applicative> where's your error statement??
07:51:19 <newbie```> can somebody help me with transforming a small piece of OOP in C++ into Haskell ?
07:51:29 <isomorphic> ski: Good point.  I just tried Prop only - no go.   But then I knocked off the type signature on prop_LocateSubstring entirely and let it make up it's own mind - turns out it satisfied it - somehow?
07:51:56 <applicative> isomorphic: but what is the type signature ghci offers you?
07:52:09 <Eduard_Munteanu> newbie```: sure but it might not make sense to use the same style/approach in Haskell
07:52:22 <newbie```> i don't need the same style
07:52:30 <ski> @type (<$>)
07:52:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:52:39 <newbie```> just same functionality
07:52:56 <isomorphic> applicative: prop_LocateSubstring :: String -> Test.QuickCheck.Gen.Gen Bool
07:53:00 <Eduard_Munteanu> Ok.
07:53:21 <applicative> newbie```: what are the inputs and outputs, so to say.
07:53:40 <applicative> isomorphic, oh but isn't String -> Gen Bool what you called it?
07:54:03 <newbie```> here is the code http://pastebin.com/h2t3FtXF
07:54:05 <mauke> The paste h2t3FtXF has been copied to http://hpaste.org/47356/c
07:54:17 <ski> hehe
07:54:19 <applicative> mauke, are you a bot?
07:55:07 * applicative thinks, where's a haskell c++ parser when you need it
07:55:36 <Eduard_Munteanu> newbie```: that'd be just a datatype in Haskell.
07:55:41 <ski> newbie``` : that doesn't really solve a real problem, it just shows simple (implementation) inheritance in C++
07:56:02 <newbie```> i am a begginer in haskell
07:56:07 <newbie```> and i try to understand these things
07:56:08 <Eduard_Munteanu> Oops, I missed B.
07:56:35 <isomorphic> applicative: No, I had Gen Prop - so, it makes sense now :/
07:56:49 <applicative> Oh i see, left over from before you changed to a Bool
07:56:57 <newbie```> ski, yes i need to replicate the functionality in haskell
07:57:00 <Eduard_Munteanu> Yeah you really need more than that to decide what's best to use.
07:57:18 <Eduard_Munteanu> It does illustrate something in C++, but not necessarily in Haskell.
07:57:38 <applicative> what is the result of calling main? Im a C++ moron
07:57:39 <ski> newbie``` : it doesn't really make much sense to try to convert that to haskell. you might instead start with something resembling a real problem, in terms of an application domain, and ask how to do that in haskell
07:57:58 <newbie```> it illustrates classes and overloading in haskell
07:58:01 <newbie```> and i need that
07:58:16 <ski> classes in Haskell are not really that much related to classes in C++
07:58:17 <Eduard_Munteanu>   objB.printX_A(); -- would result in garbage
07:58:21 <ski> they are different concepts
07:58:53 <ski> also, that paste doesn't illustrate overloading in C++ at all
07:59:06 <Eduard_Munteanu> The only relation is class constraints in typeclass definitinos, which somewhat mimicks inheritance.
07:59:08 <newbie```> inheritance sorry not overloading
07:59:43 <ski> applicative : iirc, both `void' and `int' are acceptable ..
07:59:45 <isomorphic> newbie```: have you looked at any of the Haskell tutorials?
08:00:06 <newbie```> i was reading this http://www.haskell.org/haskellwiki/OOP_vs_type_classes
08:00:40 <Eduard_Munteanu> You can do some OOP with classes in Haskell, but you're more likely going to do so with datatypes which contain functions.
08:00:53 <Eduard_Munteanu> I think Cale had something on that.
08:01:03 <ski> s/functions/functions or actions/
08:01:09 <roconnor> @unmtl StateT s Maybe a
08:01:10 <lambdabot> s -> Maybe (a, s)
08:01:31 <Eduard_Munteanu> Yeah.
08:01:38 <isomorphic> newbie```: Oh, I see.
08:01:41 <Eduard_Munteanu> And existentials but let's not get into that now. :)
08:01:51 <stulli> Is there any benefit in using Int over Integer? Is it more efficient?
08:01:52 <ski> existentials are fun :)
08:02:11 <Axman6> newbie```: data A = A Int deriving Show; data B = B Int deriving Show;...
08:02:19 <Eduard_Munteanu> stulli: yes it is
08:02:29 * hackagebot typehash 1.4.0.2 - Create a unique hash value for a type.  http://hackage.haskell.org/package/typehash-1.4.0.2 (LennartAugustsson)
08:02:45 <Axman6> newbie```: if you are new to haskell, you would be strongly advised to forget everything you know about programming already, especially OOP
08:02:47 <ski> Axman6 : that `B' doesn't include `A' ..
08:03:06 <Axman6> oh, missed that
08:03:15 <Axman6> data B = B A Int
08:03:22 <Eduard_Munteanu> stulli: Integers are arbitrarily-sized integers, and it's implemented by calls to GMP
08:03:22 <ion> Don’t use Int instead of Integer just for the sake of efficiency that may not be relevant at all. Also, if you need an integer value of certain size, use WordN and IntN instead of Int.
08:03:28 <isomorphic> newbie```: I really like http://learnyouahaskell.com/
08:04:12 <Axman6> isomorphic: replicating already provided code that uses int...
08:04:12 <silver_> analogy between type classes and OOP classes never crossed my mind for some reason
08:04:38 <Axman6> me either
08:04:39 <newbie```> i know basics of haskell but i have a vew home assignments in my functional programming class where i need to do things like this
08:04:51 <silver_> because I thought about OOP classes as types, so type class is something more generic
08:04:52 <applicative> here's a paste http://pastebin.com/qUzyBEgi
08:04:54 <mauke> The paste qUzyBEgi has been copied to http://hpaste.org/47357/hello
08:04:59 <applicative> haha
08:05:06 <Axman6> newbie```: if they're functional programming assignments, you do not need to do things like that
08:05:10 <applicative> that wit mauke.
08:05:10 <isomorphic> Axman6: s:/isomorphic/ion
08:05:12 <Eduard_Munteanu> Well people keep saying there is no semblance, but there is some. First the name, then the inheritance-like thingy, which is enough to confuse people :)
08:05:21 <Axman6> yeah
08:05:37 <stulli> Eduard_Munteanu: Thanks, that's exactly what i wanted to know.
08:05:37 <ski> @where oop
08:05:38 <lambdabot> <http://community.schemewiki.org/?object-oriented-programming>
08:05:49 <newbie```> really that is how my assignments looks like
08:05:57 <newbie```> i know it's stupid
08:05:59 <applicative> shouldn't it have said "I know nothing about oop"
08:06:01 <isomorphic> Eduard_Munteanu: that's a good point
08:07:10 <isomorphic> newbie```: composition of functions is probably something to consider
08:07:31 <erus`> how can i print unicode symbols to the console?
08:07:35 <isomorphic> newbie```: so, in Haskell, you can chain together functions to make new functions
08:07:37 <newbie```> any good resource for that ?
08:08:03 <Eduard_Munteanu> newbie```: the problem with those assignments is they rely on what exactly the teacher is expecting, rather than an objective end.
08:08:19 <applicative> erus` you mean inside ghci?
08:08:27 <newbie```> i know
08:08:34 <erus`> yeah
08:08:39 <erus`> or windows cmd prompt
08:09:15 <Eduard_Munteanu> newbie```: f (g x) == (f . g) x
08:09:21 <Eduard_Munteanu> :t (.)
08:09:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:09:28 <Eduard_Munteanu> Forget that.
08:09:32 <ion> :t (Prelude..)
08:09:32 <Eduard_Munteanu> :t (Prelude..)
08:09:33 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:09:33 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:09:33 * ski . o O ( s/==/=/ )
08:10:04 <Eduard_Munteanu> I meant extensional equality instead of something definitional :)
08:10:49 <applicative> with the windows cmd prompt it's a windows comd prompt matter, surey. but ghci evaluates '?' to '\8857' and "?" to "\8857"
08:11:16 * applicative thinks my unicode is not appearing to me....
08:11:20 <Eduard_Munteanu> > '\8857'
08:11:21 <lambdabot>   '\8857'
08:11:34 <Jafet> erus: http://www.joelonsoftware.com/articles/Unicode.html
08:11:36 <Eduard_Munteanu> > '\65'
08:11:36 <lambdabot>   'A'
08:12:19 <ski> > "\88\&57"
08:12:20 <lambdabot>   "X57"
08:12:25 <applicative> erus` but inside ghci if I do putStrLn "?" or putStrLn "\8857" I get the character.  Do you just get a blank space or whatever
08:13:00 <erus`> *** Exception: <stdout>: hPutChar: invalid argument (character is not in the code page)
08:13:50 <applicative> erus` hmm.  That is annoying.  Is there a better terminal, can you use ghci in "powershell'
08:14:02 <Jafet> Yeah, you'd better learn about Unicode.
08:14:08 <erus`> aha
08:14:12 <katjapp_> hey! is there any chat room like this for java?
08:14:14 <applicative> I dont know how much scope there is for making cmd promt rational
08:14:22 <erus`> Jafet: i know about unicode thanks
08:14:31 <erus`> just not winblows
08:14:35 <companion_cube> katjapp_, maybe #java ?
08:14:43 <applicative> Jafet, the question is how to get ghci to render it on windows
08:15:00 <ski> katjapp_ : /join ##java
08:15:24 <erus`> it works in powershell
08:15:27 <zmv> hahahahaha java
08:15:28 <erus`> yey :)
08:15:28 <Jafet> Using winghci?
08:15:43 <applicative> katjapp_: they'll probably just be mean, why not stay with us? we don't hate our language
08:16:05 <zmv> he's gone
08:16:09 <Jafet> Or to "cmd.exe" (whichever of the numerous versions you have)?
08:16:24 <zmv> let's see what is ##java like
08:16:33 <applicative> is winghci a separate console from cmd.exe?
08:17:14 <zmv> lol
08:17:23 <zmv> ##java is half of the size of #haskell
08:17:33 <katjapp> I cannot enter java room because I have to be invited
08:17:46 <kutsurak> Is there anyone here that has experience with haskell in gentoo please?
08:17:51 <adimit> katjapp: you have to be identified.
08:18:08 <n00p> Well, what do you expect? Java is less than half as logical.
08:18:09 <Jafet> Also, I wonder if courier new supplies every character, because I get the feeling that the terminals on Windows can't use multiple fonts at once
08:18:10 <Silvah> > (766 `div` 2) `compare` 365
08:18:11 <lambdabot>   GT
08:18:49 <Silvah> > 766 / 365
08:18:49 <lambdabot>   2.0986301369863014
08:18:58 <n00p> The only people who program in Java are those who wish to end up with arthritis. That might also explain why there aren't as many Java programmers who use IRC.
08:19:17 <adimit> they're busy typing?
08:19:20 <katjapp> adimit:do you mena I have to be registered?
08:19:29 <adimit> katjapp: to freenode, yes.
08:19:46 <zmv> you know, some weeks ago, a dude at school brought "Java: The Essential Guide" or something like that
08:20:06 <Cale> newbie```: Do you honestly want to print values from uninitialised memory in Haskell?
08:20:10 <zmv> It could kill somebody if thrown hard enough, it weighed some 5 kilos.
08:20:37 <adimit> zmv: I love my 900+ pages C++ *in a nutshell*. O'Reilly, I think.
08:20:38 <Cale> newbie```: Because your C++ code prints the x_A field of objB which is unset.
08:20:45 <Silvah> Cale: heh, is it possible?
08:21:04 <zmv> adimit: yeah, I just plain translated the title to english
08:21:15 <katjapp> adimit:I havent seen any register button
08:21:39 <Cale> Silvah: I guess so with the ffi
08:21:42 <Jafet> adimit: the new C++ specification has about 1300 pages
08:21:44 <adimit> katjapp: irc does not have buttons. look at http://freenode.net/faq.shtml
08:21:50 <ski> katjapp : try `/msg NickServ help register'
08:22:02 <newbie```> Cale: i need to add an output something like "value is not set"
08:22:18 <Silvah> ...and then enjoy sending your password in *raw text* over and over.
08:23:06 <adimit> Silvah: use auto joins w/ your client. Also, freenode pwds are just a  formality anyway …
08:23:09 <zmv> Silvah: as long it's not the same as your bank account password :P
08:23:22 <Jafet> My passwords love being sent in plaintext over and over
08:23:44 <erus`> any ideas how i can intersperse an element every Nth item in a list?
08:23:48 <zmv> I use SSL, therefore, I don't care.
08:23:55 <isomorphic> Doesn't Freenode let you use SASL?
08:23:56 <ben> No problem, just set a hash of your actual password as your irc password. :)
08:24:00 <zmv> Ok, I was bleffing, plain text all over the way.
08:24:09 <Silvah> adimit: using auto joins will still leave the passwords being sent in plaintext.
08:25:07 <adimit> Silvah: oh yes, certainly. IRC isn't, and never was intended to be, a sophisticated piece of technology.
08:25:21 <dankna> actually, I rather think it was intended to be sophisticated
08:25:23 <dankna> hence the "relay"
08:25:29 <adimit> in fact, it's ridiculously primitive. I remember implementing a client in Prolog, and it wasn't even difficult
08:25:38 <dankna> notice how the relay design actually increases the load on each server rather than decreasing it
08:25:44 <Cale> erus`: intercalate [x] . map (take n) . takeWhile (not . null) . iterate (drop n)
08:25:47 <dankna> because somebody didn't quite understand that the Internet does routing for you
08:26:15 <zmv> adimit: that's why it's sophisticated. because it's simple.
08:26:15 <adimit> dankna: well, from the user's point of view, it's actually quite trivial to just telnet into an irc server w/o any client.
08:26:16 <wagle> if haskell is referentially transparent, why is there beta-substitution?  ie let x = 1 in let f = (\y . x) in (\x . f 2) is not equal to let x = 1 in (\x . (\y . x) 2)
08:26:23 <Cale> newbie```: What is it that you're *really* trying to do? :)
08:26:24 <adimit> zmv: not buying it.
08:26:26 <dankna> adimit: I agree, and that's a nice feature, which Jabber lacks
08:26:33 <Jafet> dankna: it didn't route very well back then
08:26:34 <zmv> adimit: neither am I.
08:26:36 <Igloo> dankna: What are you suggesting instead? All clients talking directly to each other?
08:26:39 <dankna> Jafet: hmmmmm.... maybe
08:26:46 <dankna> Igloo: all clients talking to a single server
08:27:00 <Jafet> dankna: email and news also worked on relays
08:27:05 <dankna> Igloo: then we wouldn't have netsplits ><
08:27:26 <isomorphic> dankna: you read my mind
08:27:31 <Axman6> wagle: uh, isn't it obviously not equal?
08:27:41 <Cale> wagle: What?
08:27:42 <byorgey> wagle: substitution must be 'capture-avoiding'
08:27:51 <erus`> Cale: actually all i have todo is split an array into a sub array every Nth element
08:27:51 <dankna> Jafet: yeah - that's where the design was inspired from, obviously.  but if there was no continuous internet connection, it wouldn't work at all!  the server-server protocol uses TCP/IP!
08:27:52 <Cale> wagle: You didn't substitute correctly
08:27:52 <Igloo> dankna: Nothing to stop people running IRC networks with a single server
08:27:53 <byorgey> wagle: that substitution has captured the free variable x
08:28:01 <byorgey> wagle: which is not how substitution actually works
08:28:01 <dankna> Igloo: yeah, but somehow nobody does it ><
08:28:15 <Cale> erus`: An array or a list?
08:28:33 <wagle> my point is that substitution is not referentially transparent
08:28:35 <Jafet> dankna: but those servers are run on university networks, not random people's dial-up modems
08:28:36 <erus`> spliteEvery 2 [1..] = [[1,2],[3,4],[5,6]...
08:28:38 <monochrom> you should always rename things to avoid name clashes
08:28:44 <erus`> like that. and i mean list
08:29:03 <wagle> i did say not equal
08:29:11 <dankna> Jafet: yeah - but the relay design /does not decrease load/
08:29:17 <dankna> Jafet: so I fail to see how that makes a difference
08:29:27 <Cale> erus`: splitEvery n = map (take n) . takeWhile (not . null) . iterate (drop n)
08:29:34 <isomorphic> dankna: perhaps the local servers were made with a view to latency
08:29:37 <Axman6> wagle: take it up with Church
08:29:45 <dankna> isomorphic: well, that's the best justification I've seen, yes
08:30:01 <byorgey> wagle: you are right that naive, textual substitution does not preserve behavior.
08:30:02 <Axman6> ur turing
08:30:03 <Axman6> or*
08:30:08 <erus`> > splitEvery 4 [1..10] where splitEvery n = map (take n) . takeWhile (not . null) . iterate (drop n)
08:30:09 <lambdabot>   <no location info>: parse error on input `where'
08:30:12 <Jafet> dankna: load? We're sending little packets of text
08:30:13 <byorgey> wagle: but that is not usually what we mean when we talk about substitution.
08:30:23 <Jafet> One IRC message fits a typical MTU
08:30:23 <dankna> Jafet: it adds up
08:30:29 <Cale> erus`: 'where' is part of declaration syntax, you want 'let'
08:30:37 <byorgey> wagle: although it's true that this important detail is usually left out when discussion referential transparency.
08:30:44 <Cale> > let splitEvery n = map (take n) . takeWhile (not . null) . iterate (drop n) in splitEvery 4 [1..10]
08:30:45 <lambdabot>   [[1,2,3,4],[5,6,7,8],[9,10]]
08:30:46 <dankna> Jafet: you do have to remember that the protocol existed at a time when 300 baud was fast
08:31:01 <erus`> cheers Cale
08:31:07 <isomorphic> I'm pretty sure when IRC was invented most transmission was still done over stone tablets
08:31:11 <Cale> erus`: Also see the split package on hackage
08:31:13 <Jafet> And you want it to be distributed, dankna? No central server?
08:31:25 <Cale> http://hackage.haskell.org/packages/archive/split/0.1.4/doc/html/Data-List-Split.html
08:31:25 <wagle> very important detail, since context matters, hence why not let it matter in other ways?
08:31:30 <jmcarthur> wagle: (\x -> f x) y   means the same thing as  f y. it's not "changing" anything to perform that application.
08:31:38 <dankna> Jafet: no, that isn't what I said at all.  sorry if I communicated poorly.  I want it to be /one/ central server!  not a dozen of them that are constantly getting netsplit from each other!
08:31:49 <Jafet> wagle: the confluence of lambda calculus is pretty cool
08:31:53 <jmcarthur> maybe i don't understand your point
08:31:59 <Jafet> It's how we can say terms are equivalent to each other
08:32:36 <Jafet> Hm wait, didn't read your code
08:32:39 <isomorphic> dankna: if things had evolved with just one server, I sort of wonder if we'd have things like NickServ
08:32:48 <dankna> isomorphic: it's an interesting question, yes
08:33:02 <kutsurak> Is there anyone here that has experience with haskell in gentoo please?
08:33:03 <wagle> referential transparency is supposed to mean "context doesnt matter"...  but here context matters..
08:33:29 <isomorphic> kutsurak: what exactly are you trying to do?
08:33:29 <jmcarthur> in a syntactic sense
08:33:31 <Axman6> wagle: but you've made an invalid substitution
08:33:57 <byorgey> wagle: no, it's not that the context matters.  It's just a detail that arises from the way we textually represent lambda abstractions.
08:33:58 <Axman6> variable names are just there for the programmer
08:33:58 <wagle> Axman6: substitution depends on contxt
08:34:14 <kutsurak> isomorphic: I would like to install haskell-platform and I'm wondering if it's better to unmask it or, intall the haskell overlay.
08:34:17 <jmcarthur> Axman6: i'm thinking that's wagle's point. he's saying that the syntactic context sensitivity of substitution makes it not RT
08:34:19 <wagle> war is peace, qed.
08:34:26 <Cale> wagle: It doesn't mean "context doesn't matter", it means that if you substitute a function with one that is equal to it in the sense that they have the same results, then the meaning of the program is unchanged.
08:34:38 <isomorphic> kutsurak: Ah- sorry, can't help :/
08:34:42 <monochrom> use de Bruijn numbering. then context doesn't matter when you substitute.
08:34:45 <jmcarthur> wagle: it's only because we name variables with letters. other notations don't necessarily have the same issue
08:34:53 <kutsurak> Thanks anywyay :)
08:34:56 <Axman6> the syntax of lambda expressions and the mathematical idea behind them aren't perfectly matched. we have to give names where they are not necessarilly needed, except for us to understand the,
08:35:00 <Axman6> m*
08:35:09 <Jafet> wagle: if you object to the traditional representation, you might like de Bruijn notation
08:35:23 <wagle> jmcarthur: ok
08:35:35 <Cale> Yeah, your problem with substitution goes away if we look at the actual graphs which those expressions represent.
08:35:40 <Axman6> yeah, i was going to bring up de Bruijn, but I'm not very familiar with it
08:35:41 <Jafet> Er, stereo
08:35:49 <isomorphic> kutsurak: if it helps, you'll end up using cabal to manage haskell packages - so you'll probably want as little managed by gentoo as possible
08:36:15 <wagle> but haskell doesnt use the de Bruijn notation, but i suppose that's a minor detail (no sarcasm intended)
08:36:29 <Cale> wagle: You're thinking too syntactically
08:36:47 <Cale> wagle: Referential transparency has nothing to do with the names of variables
08:36:58 <wagle> Cale: no, thats why i called it a minor detail
08:36:59 <dolio> monochrom: Yes it does.
08:37:02 <monochrom> but haskell doesn't say textual substition either
08:37:09 <wagle> ok
08:37:23 <monochrom> haskell only says do something correct
08:37:31 <kutsurak> isomorphic: I see. I have not used cabal yet, because it's a bit complicated to install in Gentoo. Thanks again.
08:37:59 <dcoutts> emerge cabal-install should work
08:38:13 <wagle> i want to worry about context when making substitutions, hence finding a precedent was interesting
08:38:22 <dolio> \(\\ 1)0 --> \\0 is wrong
08:38:28 <wagle> (not in haskell)
08:38:45 <isomorphic> kutsurak: you might want alex, happy, and ghc (if they're packaged separately)
08:38:45 <Cale> newbie```: Anyway, did you still need help? I wasn't quite sure what you were actually trying to accomplish with your C++ code.
08:38:49 * ski idly wonders why wagle wants to worry ..
08:39:03 <Cale> (it just prints out some values, one of which is uninitialised memory, so I'm not sure how to translate that...)
08:39:19 <wagle> ski: because i want to program in non-RT languages
08:39:38 <kutsurak> dcoutts: It's masked, but I think I'll just try to unmask it. Thanks.
08:39:43 <Axman6> wagle: i believe the context means the state of variables, textual context, if you hadn't picked that up
08:39:45 <Jafet> How does ghc for gentoo work? Download the binary to 2-stage bootstrap from source?
08:39:46 <wagle> "think like a compiler thats correct
08:39:56 <wagle> "
08:40:45 <dcoutts> Jafet: yep
08:40:48 <kutsurak> Jafet: Not sure to be honest, because I installed ghc a few months ago, and did not pay much attention.
08:41:20 <dcoutts> kutsurak: oh you just mean ~amd64 keyword, not package.mask
08:42:05 <kutsurak> actually ~x86. I am not sure why, since in the haskell wiki it says it should be unmasked...
08:43:04 <dolio> wagle: Have fun programming exclusively in SK combinators.
08:43:14 <wagle> i guess i was claiming that lexical context is similar to other sorts of context
08:44:04 <monochrom> no, just translate haskell to SK combinators
08:44:42 <dolio> He can't, if he's worried about a language where he has to think about capture-avoiding substitution.
08:44:45 <wagle> translate fortran to SK combinators...  8)
08:46:21 <wagle> i wrote a system of scheme macros once that carefully constructed lexical scopes..  hygiene came along and removed lexical scoping..
08:46:59 <newbie```> Cale:  i pmed you
08:48:17 <Eduard_Munteanu> newbie```: you're better off asking questions here rather than in private
08:48:27 <newbie```> ok
08:48:31 <ski> wagle : that sounds strange ..
08:49:22 <Eduard_Munteanu> (Of course, unless there's good reason, like say knowing Cale IRL)
08:49:49 <ski> .. since the raison d'etre of hygiene is to *preserve* lexical scoping, in presence of macros
08:49:52 <newbie```> i got it
08:50:31 <wagle> (as of circa 2003) in meta ml, you can't input the string "\x . x" and output the identity function
08:51:06 <ski> why would you input a *string* in MetaML ?
08:51:23 <wagle> ski: hygiene prevents you from constructing your own lexical scopes
08:51:36 <ski> as i recall it, you can do `eval <fn x => x>' and get back an identity function
08:52:03 <ski> wagle : can you elaborate on that ?
08:52:11 <wagle> hence the string..  you can't see if ahead of time
08:52:25 <joe6> i have :t map controlTxn2Test = map controlTxn2Test :: [Device] -> [ControlTransaction -> Test], and I want to put a sleep between each action. something similar to intersperse, but with a sleep
08:52:28 <ski> (typically hygiene prevents you from making non-lexical references to identifiers)
08:52:31 <joe6> on a list of actions
08:52:40 <roconnor> making code perfect is time consuming
08:52:52 <joe6> basically, intersperse an action
08:52:57 <joe6> roconnor: so very true.
08:53:08 <osfameron> though making code buggy takes time too ;-)
08:53:10 <wagle> i hit tim with this in person in 2003, and he didn't dispute it..  thought it kinda irrelevant though
08:53:37 <roconnor> it's the worst part of Haksell. :P  Knowing that my code could be so much better no matter how much better I make it.
08:53:43 <ski> @quote stark
08:53:43 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
08:53:57 <joe6> roconnor: so very true again.
08:54:07 <ski> wagle : as much as possible, avoid passing strings around ..
08:54:15 <wagle> i don't think i could explain well in irc..  but i'll see if i can think of a way
08:54:25 <roconnor> with C code, I'm just happy when it works at all
08:54:54 <ski> wagle : maybe what you're after is reading a string (or whatever) into a piece of code, providing an environment to resolve free identifiers with ?
08:56:08 <joe6> something like an intersperseM
08:56:18 <ski> joe6 : is `Test' an action ?
08:56:58 <joe6> ski http://sprunge.us/IBRY
08:57:09 <joe6> ski i am using the Test.HUnit library
08:57:31 <joe6>  http://sprunge.us/MbZf
08:57:39 <joe6> the Assertion is IO ()
08:58:19 <joe6> ski, do you have any ideas?
08:59:27 <wagle> ski: i need to write this up in a paper or something, but considering the de Bruijn and SK forms is interesting
09:00:08 <dolio> preflex: seen lispy
09:00:08 <preflex>  lispy was last seen on #haskell 10 hours, 26 minutes and 51 seconds ago, saying: hmm
09:00:32 <wagle> the point of the "\x . x" string is that hygiene will keep you from making the two x's the same identifier
09:00:48 <ski> joe6 : `before act (TestList tests) = TestList (TestCase act : tests); before act test = TestList [TestCase act,test]' might work ..
09:01:21 <joe6> ski, this is more like what I have:  http://sprunge.us/dWaJ
09:01:25 <ski> wagle : i'm not sure how you mean
09:01:27 <varnie> please help me to understand what does it mean?
09:01:28 <varnie> "-- file: ch09/BetterPredicate.hs
09:01:28 <varnie> equalP' :: (Eq a) => InfoP a -> a -> InfoP Bool
09:01:28 <varnie> equalP' f k w x y z = f w x y z == k"
09:01:39 <varnie> where:
09:01:40 <joe6> ski, ok. thanks.
09:01:41 <varnie> -- file: ch09/BetterPredicate.hs
09:01:41 <varnie> type InfoP a =  FilePath        -- path to directory entry
09:01:41 <varnie>              -> Permissions     -- permissions
09:01:41 <varnie>              -> Maybe Integer   -- file size (Nothing if not file)
09:01:41 <varnie>              -> ClockTime       -- last modified
09:01:42 <varnie>              -> a
09:01:44 <varnie> pathP :: InfoP FilePath
09:01:52 <ski> wagle : are you talking about making e.g. a `syntax-case' macro converting the string to a piece of syntax ?
09:02:16 <KirinDave> I just learned about template haskell.
09:02:23 <KirinDave> Blew my mind that it exists.
09:02:44 <ion> varnie: That’s about 500 % of a reasonable amount to paste directly to IRC.
09:03:08 <varnie> I am sorry. I'll won't repeat it.
09:03:15 <varnie> I won't*
09:03:39 <lispy> How should check if my ghc wants to generate 32bit vs. 64bit code?
09:03:57 <lispy> ghc +RTS --info lists ("Word size", "64")
09:04:02 <lispy> Do you think that's the line I care about?
09:04:12 <lispy> I see lots of things that mention x86_64
09:04:18 <wagle> i havent seen scheme in 15 years, last saw metaml 8 years ago, so i am more talking about metaml is its blind admiration of "hygiene" without seeing a big picture that I have a hard time conveying in nice pithy soundbites (my own failing)
09:04:21 <Eduard_Munteanu> lispy: use 'file' on the output? :)
09:04:23 <lispy> Maybe I should ask on SO so that dons will answer my question :)
09:04:30 <lispy> Eduard_Munteanu: hmm
09:05:00 <Eduard_Munteanu> or readelf, or such stuff
09:06:01 <isomorphic> varnie: Try pasting it to hpaste.org, then paste a link into the channel
09:06:18 <varnie> okay, I'll try. thanks
09:06:22 <Eduard_Munteanu> @where hpaste
09:06:22 <lambdabot> http://hpaste.org/
09:07:05 <ski> wagle : in general i think hygiene is a very good thing, just like side-effect-freeness. however i think it can be reasonable in some cases to break it. an example of side-effects at the macro stage is <http://blog.racket-lang.org/2008/02/dirty-looking-hygiene.html>
09:08:05 <varnie> here is my question: http://hpaste.org/47360/any_help
09:08:44 <varnie> I don't understand the last two lines of that code snippet. please shed some light on it if you please.
09:10:47 <ben> You mean you do not understand why they are identical?
09:10:54 <ben> I mean lines 13 and 17
09:11:11 <varnie> I yes, and moreover, I don't get what stands for f k w x y z there
09:11:54 <varnie> let's focus on the lines 16 and 17. could you say, what is f there? what is k, what is w etc?
09:12:54 <varnie> I thought that "f k w x y" are FilePath, Permissions, Maybe Integer, ClockTime and a. am I correct?
09:13:04 <ben> I don't quite think so
09:13:10 <ben> f is apparently an InfoP a, meaning a function FilePath -> Permissions -> Maybe Integer -> ClockTime -> a
09:13:16 <Eduard_Munteanu> Look at the second InfoP...
09:13:19 <Eduard_Munteanu> Not the first.
09:13:39 <ben> k is an 'a', so the type of the result of giving f all the arguments it wants
09:13:40 <Eduard_Munteanu> Expand that InfoP Bool inline in the type.
09:14:00 <varnie> okay, and what about "w x y z"?
09:14:02 <Eduard_Munteanu> And remember (->) is right-associative. Then you can remove paranthesis.
09:14:29 <ben> well, w, x, y and z get applied to f, so you can tell what they are from the type of f
09:14:51 <varnie> equalP' takes a function and an 'a'.
09:15:06 <ben> I kinda disagree with hlint there, I like theversion in line 13 better than 17 ;)
09:15:06 <varnie> where from we have there all these "w x y z"?
09:15:19 <monochrom> f k w x y z is intended to be read as ((((f k) w) x) y z)
09:15:32 <nathanfh> ben: I agree. It seems more like how a human would think of it.
09:15:37 <Eduard_Munteanu> varnie: in the first one?
09:15:46 <varnie> in the second one, on the line 17
09:15:58 <varnie> equalP' takes a function and an 'a'.
09:16:03 <ben> varnie: equalP' takes the function and the 'a', yes, but the result is just another function that takes w, x, y, z
09:16:06 <varnie> it is okay.
09:16:10 <varnie> but later I gets confused
09:16:16 <nathanfh> So f is the InfoP a, a function of type FilePAth -> Permissions -> Maybe Integer -> Clocktime -> a
09:16:27 <ben> saying "it's a function that takes x and returns a function that takes y" is rather similar to saying "it's a function that takes x and y"
09:16:28 <Eduard_Munteanu> equalP' :: (Eq a) => InfoP a -> a -> FilePath -> Permissions -> ... -> Bool
09:16:30 <ben> thanks to currying I guess
09:16:58 <wagle> ski: thanks for the url..
09:17:18 <lispy> Okay, here is what I'm trying to do: http://stackoverflow.com/questions/6217406/how-can-i-detect-if-ghc-is-set-to-generate-32bit-or-64bit-code-by-default
09:17:25 <varnie> if it takes only a function and an 'a' why it there're "w x y z" on the left side of a "="?
09:17:32 <nathanfh> the w, x, y, and z are the arguments to the function. i.e. the FilePath, Maybe INteger, what have you.
09:17:52 <ben> varnie: it's a tricky way to use currying to remove the lambda from the equation in line 13
09:17:58 <varnie> so, it takes a function, an 'a' and 3 arguments to the function
09:17:58 <ben> it happens to work out to the same thing
09:17:59 <varnie> correct?
09:18:20 <ben> Well,four
09:18:24 <varnie> ops, even 4, yes
09:18:29 <varnie> I misread it
09:18:40 <ben> And the result immediately applies the four arguments to f, and compares what it gets with k
09:19:04 <ben> So when you call equalP from line 13 with two arguments, your result is a function that still needs four arguments before it calls f and does its thing
09:19:06 <varnie> yes, now I see :)
09:19:13 <wagle> ski: the idea of hygiene was well worth kohlbecker's phd, but i'm still grumpy that he devoted a chapter to misstating my position and then imagining he disputed me
09:19:17 <ben> And when you call equalP' with two arguments, you're still left with a function that needs four more arguments.
09:19:30 <varnie> this code snippet is from "real world Haskell" book by the way
09:19:36 <ben> It did seem familiar :)
09:19:57 <varnie> and it is stated there that the last one version of 'equalP' is better than the previous one
09:20:29 <varnie> but I don't agree with it
09:20:39 <ben> Which chapter is it again?
09:20:40 <ski> wagle : i'm not sure what your positions is ..
09:20:50 <varnie> Chapter 9
09:21:08 <varnie> in the middle of it
09:21:10 <wagle> ski: yeah, i know..  sorry about that
09:21:48 <wagle> the "\x.x" thing was supposed to be enlightening, but its not
09:21:57 <ben> varnie: Really seems like a matter of taste :)
09:22:52 <varnie> thanks for the help
09:22:58 <nathanfh> equalP' is simpler, equalP is easier to read for humans.
09:23:13 <varnie> same for me
09:23:32 * wagle needs to read the modern macro literature and see if his point is still missing
09:23:37 <ben> Maybe they just wanted to drive home the point that partial application is everywhere
09:23:45 <nathanfh> I think the point is to encourage you to start thinking more in terms of currying and partial application.
09:23:59 <monochrom> "type InfoP a = ... -> ... -> ... -> ..." is just a lot of smoke screen
09:24:34 <nathanfh> Is there a difference in efficiency, or does ghc optimize that away?
09:25:05 <Jafet> ghc does treat functions differently depending on the declaration arity
09:25:17 <Jafet> I believe the difference goes all the way to STG
09:25:22 <ben> :O
09:25:26 <lispy> preflex: seen pastorn
09:25:26 <preflex>  pastorn was last seen on #haskell 5 days, 14 hours, 19 minutes and 31 seconds ago, saying: MaskRay: then just do it?
09:25:27 <nathanfh> It seems like there'd by one extra thunk in equalP, but I'm just starting to grok how evaluation works in detail.
09:25:30 <ben> I thought it only came into play w.r.t. the monomorphism restriction
09:25:52 <wagle> mandatory hygiene destroyed a project I was working on that was really interesting..  years later, the guy i just crushed in an internet go game turned out to be eugene, so I figure I've been avenged
09:26:01 <monochrom> "f x = let z=... in \y -> ..." and "f x y = let z=... in ..." may get compiled into different code
09:26:06 <ben> wagle: well done
09:27:02 <nathanfh> I'm coming around to RWH's view on the matter, then.
09:27:03 <monochrom> but there is no "let" in this example
09:28:08 <ben> Is that observably different or just an implementation detail?
09:28:28 <monochrom> can be observably different if you observe time and memory
09:29:41 <monochrom> especially if you use f in a loop, it affects how much "z=..." is stored for reuse or thrown away for recalculate
09:29:47 <ben> ah
09:30:12 <ben> gosh, that sounds tricky to get right.
09:30:13 <monochrom> some people call time-memory issues implementation details
09:30:41 <monochrom> "the denotational semantics says they are so equal!"
09:30:57 <wagle> only if a compiler CAN switch between the two forms?
09:31:02 <monochrom> but the denotational semantics is so ignorant
09:31:43 * wagle starts seeing a difference
09:32:24 <monochrom> the worst part is that those people just say "semantics" instead of "denotational semantics", as though there is only one holy semantics, and operational semantics is not a semantics
09:32:54 <ben> I'm not entirely aware of the semantics to begin with, so I am just gonna trust you on that one.
09:33:17 <wagle> neat..  there's a difference because haskell allows currying
09:33:57 <solrize> http://hackage.haskell.org/trac/ghc/ticket/4798 zomg they are turning haskell into lisp
09:33:58 <wagle> but wait
09:34:12 * wagle decides to stop thinking out loud
09:34:50 <pikhq_> wagle: BTW, currying is nothing special, and every language with closures can do it.
09:35:05 <monochrom> an optimizing compiler may or may not move around the "let", too, in hope of giving you a more efficient program in some sense
09:35:05 <ben> But it does not look nice!
09:35:21 <pikhq_> wagle: The *distinction* is between languages where currying is the normal means of doing multi-variable functions and those where it isn't.
09:35:46 <dolio> That isn't a language issue, necessarily.
09:36:17 <pikhq_> The language has some influence over it (which one's syntactically cleaner), but yeah, most of it is just what's common practice.
09:36:18 <wagle> pikhq_: i was thinking that currying put in a observable gap in between argument evaluations
09:36:19 <dolio> ML has a culture of uncurried definitions, as I recall.
09:36:50 <wagle> but i rescinded that idea with my "but wait"
09:37:21 <pikhq_> wagle: Currying is nothing more than doing multi-variable functions by making all functions a function of a single argument, that return another function.
09:37:31 <pikhq_> You can even do this in C if you're sufficiently perverse.
09:37:39 <cheater_> how
09:37:47 <pikhq_> cheater_: First, you manually implement closures.
09:37:48 <cheater_> SMC?
09:38:00 <pikhq_> As I said, "if you're sufficiently perverse".
09:38:02 <glguy> Why does the hsc2hs that comes with a compile which ignores -#include and INCLUDE pragmas include them in its output?
09:38:02 <cheater_> do you implement closures with SMC?
09:38:07 <jmcarthur> the closure has to be another argument though, doesn't it?
09:38:17 <cheater_> another argument? huh?
09:38:33 <Jafet> Well, you have to manually implement application, too
09:38:36 <glguy> "Warning: -#include and INCLUDE pragmas are deprecated: They no longer have any effect" What purpose does this warning serve?
09:38:45 <Jafet> When you're done, you're not really writing C anymore
09:38:50 <jmcarthur> Jafet: ah that would be another way. just make the whole thing an interpreter
09:39:04 <pikhq_> Jafet: I've done it. It's not *that* bad, oddly enough, if you use a GCC extension or two.
09:39:08 <Jafet> You can also do it by CPS-transforming everything
09:39:18 <pikhq_> Well, except that you need to manually close, and you *really* want to use Boehm GC for it.
09:39:19 <Jafet> Which is what I'm experimenting with in some new C++ code
09:39:28 <sioraiocht> bah, I always forget, if I precompose f with the function g, is this f . g or g . f?
09:39:35 <pikhq_> Much easier in C++, especially with C++0x.
09:40:41 <wagle> sioraiocht: (f . g) x == (f (g x))
09:40:57 <sioraiocht> wagle: yes, but I forget which is precomposition and which is postcomposition =p
09:41:42 <dKc> how to wrote in haskell function which returns reverse list?
09:42:00 <monochrom> do you mind using one from the library?
09:42:08 <monochrom> > reverse [True, True, False]
09:42:08 <wagle> sioraiocht: i guess i don't know what "precompose" etc mean
09:42:09 <lambdabot>   [False,True,True]
09:42:34 <monochrom> if you want to learn to write it yourself, first you have to understand recursion
09:42:40 <glguy> ?src (.)
09:42:40 <lambdabot> (f . g) x = f (g x)
09:42:40 <lambdabot> NB: In lambdabot,  (.) = fmap
09:43:11 <dKc> hey, isn't it just
09:43:19 <dKc> let fun n | reverse n ?
09:43:31 <monochrom> no, wrong syntax
09:43:42 <dKc> hmm...
09:43:46 <monochrom> fun n = reverse n
09:43:55 <ben> or fun = reverse? :>
09:44:02 <dKc> <interactive>:1:6: parse error on input `='
09:44:16 <monochrom> at the prompt? let fun n = reverse n
09:44:18 <dKc> why i have that error?
09:44:30 <monochrom> because the prompt is different
09:44:47 <monochrom> "fun n = reverse n" is for source code file
09:44:50 <dKc> oh thanks!
09:45:03 <scrappy_doo> hello haskellers :)
09:45:27 <dKc> how to exit from promt?:)
09:45:31 <wagle> i assume dKc needs to write his own reverse function?
09:45:33 <monochrom> :quit
09:46:47 <dKc> wagle: yeah, but how?
09:46:55 <Jafet> raiseSignal sigKILL
09:46:58 <ben> @src reverse
09:46:58 <lambdabot> reverse = foldl (flip (:)) []
09:47:01 <ben> easy!
09:47:37 <dKc> hmm...folfdl is function too
09:47:50 <dKc> but if i would like to write it
09:47:55 <dKc> without any more functions?
09:47:58 <Jafet> @src foldl
09:47:58 <wagle> dKc: what is the reverse [1,2,3]?
09:47:59 <lambdabot> foldl f z []     = z
09:47:59 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:47:59 <dKc> only recorsion
09:48:04 <dKc> 3,2,1
09:48:11 <wagle> []?
09:48:13 <dKc> wagle: 3,2,1
09:48:28 <wagle> reverse[]?
09:48:28 <dKc> [3,2,1]
09:48:36 <dKc> []
09:48:49 <wagle> reverse [1]?
09:49:10 <dKc> 1
09:49:28 <pastorn> lispy: hello
09:49:36 <wagle> how do you construct the list [1] from 1?
09:49:39 <Jafet> I think that's enough samples for quickspec
09:49:59 <scrappy_doo> I'm having a prob w/Control.Concurrent.threadDelay on GHCi.  It works on the command line but not in code compiled from a src file. ???
09:50:03 <dKc> let rev [] | []
09:50:36 <dKc> how do you construct the liost [1] from 1?
09:50:40 <dKc> list*
09:51:12 <wagle> ok...  whats the reverse of a list with an element in it?
09:51:19 <wagle> oops
09:51:52 <dKc> element in it
09:51:56 <dKc> soo
09:52:07 <dKc> otherwise i have to
09:52:10 <dKc> call fun
09:52:11 <dKc> with
09:52:20 <dKc> n-1?
09:52:45 <wagle> fun (x : xs) = ?
09:53:07 <wagle> fun (x : []) = ?
09:53:19 <byorgey> scrappy_doo: paste the code that doesn't work?  hpaste.org
09:53:28 <dKc> hmm, what's a ':'?
09:54:08 <djahandarie> 1:[]   ==   [1]
09:54:12 <djahandarie> It's how you build lists.
09:54:21 <djahandarie> (And due to pattern matching, also how you break down lists.)
09:54:35 <Jafet> Is this homework?
09:54:37 <wagle> (1 : (2 : (3 : []))) == (1 : (2 : [3])) == (1 : [2, 3]) = [1,2,3]
09:54:54 <dKc> yeah, it is for add to list ok
09:56:10 <djahandarie> dKc, yes, but it happens to be how the concept of a 'list' is defined in the first place.
09:56:39 <djahandarie> When GHC (the haskell compiler) sees [1,2,3] it turns it into 1:2:3:[] before proceeding any further.
09:56:56 <djahandarie> So the [1,2,3,4] notation is just some extra syntax to make life easier.
09:57:57 * hackagebot text 0.11.1.1 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.1.1 (BryanOSullivan)
09:58:11 <djahandarie> Basically, when doing anything with lists at all, you work with two things: the empty list, and the : operator (which is called 'cons').
09:58:32 <djahandarie> All other list functions (reverse, foldl, etc.) are written in terms of those two things.
10:00:21 <scrappy_doo> byorgey:  Working on it.
10:01:02 <dKc> what is doing here?
10:01:05 <dKc> f :: (a -> b -> b) -> [a] -> b -> [(a,b)]
10:02:38 <djahandarie> dKc, there is definitely going to be a lot happening in the definition of that function. I'd recommend starting with something simpler.
10:04:01 <djahandarie> Try defining the function 'map'.    map :: (a -> b) -> [a] -> [b]
10:05:23 <dKc> is thereois some function to return the average from 6,5,4 ?
10:07:08 <djahandarie> Not in the standard library, but it's very easy to write using other functions from the standard library.
10:07:49 <Jafet> const 5
10:09:06 <kaini> @pl \c -> ord c - ord 'A' + 1
10:09:06 <lambdabot> (1 +) . subtract (ord 'A') . ord
10:09:42 <ben> @pl \a -> map (/ (sum a)) a
10:09:43 <lambdabot> map =<< flip (/) . sum
10:10:13 <djahandarie> Why does @pl prefer =<< rather than >>=?
10:11:12 <kaini> @pl \c -> 1 - ord 'A' + ord c
10:11:12 <lambdabot> ((1 - ord 'A') +) . ord
10:11:19 <Jafet> Don't you?
10:12:32 <djahandarie> I normally use >>=.
10:14:07 <ben> @src =<<
10:14:08 <lambdabot> f =<< x = x >>= f
10:15:11 <djahandarie> @ty flip (>>=)
10:15:13 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
10:15:21 <djahandarie> @ty ($)
10:15:22 <lambdabot> forall a b. (a -> b) -> a -> b
10:15:53 <djahandarie> @ty (>=>)
10:15:54 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
10:16:02 <djahandarie> @ty (Prelude..)
10:16:03 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
10:16:24 <djahandarie> Oops, wrong one. :p
10:16:29 <djahandarie> @ty (<=<)
10:16:30 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
10:23:01 <tromp> > (1 - exp (-2)) / 2
10:23:02 <lambdabot>   0.43233235838169365
10:23:14 <jmcarthur> =<< is superior!
10:23:52 <jmcarthur> well, and <=< is awesome too
10:24:10 <jmcarthur> >>= and >=> are lame
10:25:07 <djahandarie> jmcarthur, what if I like flipped function application and composition?
10:25:57 <jmcarthur> then you are lame :P
10:26:24 <dKc> what means '::' in haskell?
10:26:55 <monochrom> a punctuation to separate identifiers from types
10:28:14 <varnie> I am sorry asking such question, but where can I find the list of commands available here?
10:28:21 * djahandarie wonders what sort of terrible teacher tried to teach dKc lists without teaching him about types first.
10:28:32 <jmcarthur> @list
10:28:32 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:28:44 <monochrom> an untyped sort of terrible teacher
10:28:51 <varnie> thanks a million!
10:30:48 <Jafet> Well, giving haskell homework to someone who doesn't seem to know a thing about it
10:31:07 <varnie> @ty (Prelude..)
10:31:08 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
10:31:22 <varnie> @babel
10:31:23 <lambdabot>   bzzt.
10:31:28 <varnie> @babel test
10:31:28 <lambdabot>   bzzt.
10:31:31 <djahandarie> varnie, the Prelude. is only really neccesary because lambdabot has its own definition of (.)
10:31:43 <djahandarie> You can test stuff with   /msg lambdabot   by the way
10:32:01 <Jafet> cabal install lambdabot
10:32:11 <Jafet> (no, that doesn't quite work)
10:33:04 <varnie> thanks, it works:)
10:33:19 <erus`> @bf ++++++++++++++++++++++++++++++++++++++++.....
10:33:20 <lambdabot>   (((((
10:33:27 <erus`> hurrr
10:38:43 <kaini> Assuming I've an application that handles incoming messages and changing some internal state. I use a data State = State ... (in a MVar) for this purpose - that's working fine.
10:38:43 <kaini> But now the application is supposed to switch into an completely different "mode" at some point.
10:38:43 <kaini> My first idea was to do data State = StateA ... | StateB ... and let the handleMessage function pattern match against the current state and handle accordingly.
10:38:43 <kaini> But this variant forces me to write the whole program in a single big module. What is the preffered way to implement such a behaviour?
10:39:21 <scrappy_doo> byorgey:  It looks like the time I gave threadDelay was too big for an Int32.
10:40:25 <scrappy_doo> Is there a simple way to sleep for more than 2^31 microseconds, or do you have to fake it with multiple calls to threadDelay?
10:40:44 <scrappy_doo> I mean for the program to sleep...
10:41:35 <Jafet> threadDelayLonger :: Word64 -> IO ()
10:41:47 <Jafet> Well you might as well make it Integer
10:44:35 <monochrom> I use multiple calls. there is a small lib on hackage that does it
10:44:43 <mm_freak> scrappy_doo: right now you'll have to fake it, and you can't fake it very precisely
10:45:18 <varnie> is this the official Haskell IRC channel?
10:45:23 <monochrom> yes
10:45:26 <mm_freak> if the amount of time is not much larger, you can use multiple calls and take into account that you lose a few milliseconds
10:45:26 <scrappy_doo> Rockin'!  That's better than nothing :)
10:46:18 <mm_freak> scrappy_doo: if the amount of time is much larger, you should use Data.Time.Clock in combination with a well factored sleeping time
10:47:00 <mm_freak> for example, if you need to wait days, you should wake up like every minute and see if the intended number of days has passed
10:47:36 <tarrasch> I work and compile+build on my home 32Ubuntu system. That produces a 32-bit binary. My server runs 64-bit Ubuntu, and I want the server to run my programs compiled on the 32-bit system. Is that possible? Or any other solutions?
10:48:32 <monochrom> I think it just works
10:48:56 <proq> tarrasch: you can pass args to gcc to tell it what arch to build for
10:49:05 <tarrasch> monochrom, I can just run a 32-bit binary on the 64-bit system
10:49:15 <tarrasch> proq, not ghc?
10:49:34 <scrappy_doo> mm_freak thanks.  I just need the program to wait for times on the order of an hour or so.  It doesn't have to be exact.
10:50:45 <mm_freak> scrappy_doo: then just use two calls to threadDelay, but if you don't use the threaded RTS you should probably calculate the remaining time for the second call
10:51:40 <varnie> I have a question regarding Ninety-Nine Haskell Problems. How can one be sure his solution is correct?
10:51:48 <Eduard_Munteanu> > 2^32 / 10^6
10:51:49 <lambdabot>   4294.967296
10:52:08 <Eduard_Munteanu> > 60 * 60
10:52:09 <lambdabot>   3600
10:52:24 <Eduard_Munteanu> So it should be enough.
10:53:08 <Eduard_Munteanu> :t threadDelay
10:53:08 <lambdabot> Not in scope: `threadDelay'
10:53:23 <Eduard_Munteanu> Oops, Int.
10:53:49 <Eduard_Munteanu> > 2^31 / 10^6
10:53:49 <lambdabot>   2147.483648
10:54:12 <Eduard_Munteanu> (since it's signed)
10:54:40 <varnie> where can I learn what this or that GHC.Base function does?
10:56:31 <saati> @hoogle GHC.Base
10:56:32 <lambdabot> package base
10:56:32 <lambdabot> package regex-base
10:56:47 <saati> hmm so, http://hackage.haskell.org/package/base
10:56:58 <varnie> I mean, some function description or whatever. for example, I stumbled across "const" function and am out ot idea what does it do?
10:57:47 <saati> use hoogle, http://www.haskell.org/hoogle/?hoogle=const
10:58:31 <tarrasch> varnie, try hoogle if you haven't already :)
10:58:56 <varnie> and, if I already interrupted you, could you describe why this function (I am about "const") is even exist?
10:59:13 <scrappy_doo> mm_freak don't worry, I'll just break the interval into manageable pieces.
10:59:16 <varnie> it takes two args and returns the first of them
11:00:36 <monochrom> I try to open a file and do stuff. if there is an exception, I print out something, I don't care what exception it is
11:01:05 <monochrom> catch (openFile "blah" ReadMode >>= ...) (\e -> putStrLn "blah")
11:01:11 <monochrom> but that is the same as
11:01:21 <monochrom> catch (openFile "blah" ReadMode >>= ...) (const (putStrLn "blah"))
11:02:33 <Saizan> but that won't typecheck
11:02:57 <monochrom> it will or will not typecheck depending on my "..."
11:03:04 <Jafet> Just add a defaulting rule for SomeException
11:03:26 <monochrom> and depending on which "catch"
11:03:47 <tarrasch> varnie, are you kidding? It's really useful!
11:03:55 <Jafet> There's only one, once you mask the other out in your .ghci
11:04:25 <Jafet> @index IOError
11:04:26 <lambdabot> System.IO.Error, Prelude
11:04:43 <varnie> tarrasch, I am a completely newbie
11:04:51 <monochrom> @type Prelude.catch
11:04:52 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
11:05:31 <Jafet> varnie: as monochrom said, it's useful to construct trivial functions for functions that expected more complicated functions
11:06:11 <tarrasch> varnie, look at this, a guy wants a "password-function", that takes a string, say "abcde" and turns it into "*****" (same length): http://stackoverflow.com/questions/5371675/finding-and-replacing-words-in-a-text-file-output/5371871#5371871
11:06:29 <mm_freak> scrappy_doo: the more pieces you have, the less precise the timing will be
11:06:30 <tarrasch> varnie, the solution uses the const function.
11:06:35 <monochrom> that's a case of map (const '*')
11:06:45 <roconnor> how do I safe the output of Debug.Trace.trace to a file?
11:06:49 <mm_freak> scrappy_doo: remember that time passes between the individual threadDelay calls
11:06:53 <monochrom> you're welcome to write (\x -> '*') if you like
11:06:54 <roconnor> *save*
11:07:43 <adimit> roconnor: your only option is to redirect std input.
11:07:51 <tarrasch> exactly, `map (const '*')` is nicer than `map (\x -> '*')`, I think
11:07:59 <adimit> alternatively you could define your own function to write to a file using unsafePerformIO.
11:08:11 <Jafet> @src trace
11:08:11 <lambdabot> trace string expr = unsafePerformIO $ do
11:08:11 <lambdabot>     hPutStrLn stderr string
11:08:11 <lambdabot>     return expr
11:08:13 <adimit> Look at the definition of trace in Debug.Trace for inspiration.
11:08:19 <monochrom> I thought of suggesting a map (const blah) example too, but I didn't think someone would actually use it
11:08:24 <Jafet> So, just redirect stderr
11:08:57 <adimit> *std err. Man, what a mistake in my statement, sorry.
11:09:18 <tarrasch> monochrom, there are a lot more uses than that too :)
11:09:25 <Jafet> Well, if redirecting the input causes your program to not cause errors
11:09:28 <Jafet> As it usually does
11:09:57 <adimit> … that'd be beside the point :-P
11:10:21 <roconnor> I did 2>&1 but still no go
11:10:24 <Jafet> That pesky stdin, always causing trouble
11:10:32 <Jafet> roconnor: that merges stderr and stdin
11:10:38 <tarrasch> > let encrypt = ('*'<$) in encrypt "mypassword"
11:10:39 <lambdabot>   "**********"
11:10:40 * Jafet slaps adimit
11:10:46 <roconnor> yes I wanted to save both stderr and std out
11:10:50 <Jafet> That merges stderr and stdout
11:10:54 <roconnor> but I keep getting stuff dumped to the console still
11:10:58 <djahandarie> tarrasch, seems lossy.
11:11:18 <tarrasch> djahandarie, lossy?
11:11:18 <monochrom> the order of "> file" and "2>&1" is important
11:11:34 <tarrasch> ah, you mean it's hard to decrypt :p
11:12:10 <monochrom> this is why some people use "&> file" where available
11:12:43 <Jafet> It's just one-time-pad encrypted with the pad being zipWith (xor `on` fromEnum) (repeat '*') m
11:13:02 <monochrom> this is also why I took a proper unix course and eventually TAed it
11:13:43 <roconnor> monochrom: gah
11:13:55 <roconnor> unix is retarded
11:13:58 <roconnor> monochrom: thanks
11:14:09 <Jafet> No, the problem is that it's smarter than you
11:14:14 <roconnor> monochrom++
11:15:54 <scrappy_doo> mm_freak ha ha.  I don't even care about seconds, much less microseconds :)  I just want to download a web page periodically.
11:16:17 <varnie> is my understanding correct that "const ('*')" returns a partially applied function?
11:17:00 <monochrom> yes
11:17:00 <kaini> @type const '*'
11:17:01 <lambdabot> forall b. b -> Char
11:17:16 <c_wraith> varnie: That's one interpretation.  Another is just that it returns a function of type a -> Char, and the implementation really doesn't matter.
11:17:40 <monochrom> there are multiple correct understandings
11:19:46 * roconnor makes use of the fact that (error "Foo") can take as man extra parameters as you want
11:20:12 <scrappy_doo> Unix is like democracy:  It's the worst operating system in the world, except for all the other ones.
11:21:45 <Jafet> Looks like base implements const the straightforward way
11:22:05 <varnie> how can I see its source?
11:22:07 <Jafet> Well, it won't gain anything either way
11:22:35 <saati> @src const
11:22:36 <lambdabot> const x _ = x
11:25:30 <roconnor> is there a pure haskell implementation of ripemd-160?
11:33:15 <mustelo> is there an easy way to take a function say a -> b -> c and promote it to [a] -> [b] -> c using the head of each argument?
11:35:10 <c_wraith> :t liftM2
11:35:10 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:35:24 <c_wraith> that's not the one to do it
11:35:49 <c_wraith> well, actually, it is
11:36:10 <c_wraith> :t head .: liftM2 (+)
11:36:11 <lambdabot> forall a1. (Num a1) => [a1] -> [a1] -> a1
11:36:22 <c_wraith> However, that breaks if either list is empty
11:36:30 <mustelo> sure, as expected
11:36:40 <varnie> gotta go, good bye
11:36:41 <Saizan> > (`on` head)
11:36:42 <lambdabot>   Overlapping instances for GHC.Show.Show
11:36:42 <lambdabot>                              ((a ->...
11:36:46 <c_wraith> just be aware the .: isn't a standard lib function
11:36:47 <Saizan> :t (`on` head)
11:36:48 <lambdabot> forall c a. (a -> a -> c) -> [a] -> [a] -> c
11:36:55 <c_wraith> oh, that's what I really wanted
11:37:08 <Saizan> restricted type though
11:37:29 <mustelo> where is on defined?
11:37:38 <Saizan> Data.Function
11:39:10 <mustelo> thanks Saizan
11:39:35 <Jafet> @pl \f -> liftM2 f head head
11:39:35 <lambdabot> flip (flip liftM2 head) head
11:39:41 <mustelo> are there any generalizations to, say a -> a -> a -> c?
11:40:24 <luite> who's the admin of the haskell wiki? I was wondering what's the location of the api, or if it could be made available if it isn't already
11:40:54 <Jafet> :t \f -> liftM4 f head head head head
11:40:55 <lambdabot> forall a1 r. (a1 -> a1 -> a1 -> a1 -> r) -> [a1] -> r
11:41:07 <Jafet> Erm
11:44:52 <shurane> how would i pronounce/say '=<<'?
11:46:01 <adimit> probably reverse bind or so.
11:46:03 <luite> shurane: dnib, or pu!q
11:46:50 <jmcarthur> shurane: i think of (=<<) as a kind of "apply" operation
11:47:02 <jmcarthur> shurane: and (<=<) as a kind of "compose" operation
11:47:37 <Jafet> dcoutts, in case you're interested, I rebuilt my cabal docs without reinstalling: http://hpaste.org/47364/kludge_what_kludge
11:47:42 <jmcarthur> in contexts where i don't need to differentiate (=<<) from ($) and (<=<) from (.), i might just use that terminology. when i need to be more specific, i don't know what to call it
11:48:34 <jmcarthur> i'd just say "bind" for (=<<), really. i don't like (>>=) enough to give it such a nice name ;)
11:48:37 <byorgey> does anyone know of a monoid coproduct construction that is already in a package on Hackage somewhere?
11:48:52 <Jafet> (=<<) is ($) with the identity monad
11:49:07 <byorgey> it would be easy enough to write my own but I'd rather not duplicate effort
11:49:24 <jmcarthur> byorgey: what does the construction look like?
11:49:46 <jmcarthur> trying to wrap my head around "monoid coproduct"
11:49:54 <byorgey> jmcarthur: elements of m+n are lists of alternating ms and ns
11:50:04 <byorgey> the identity is the empty list
11:50:28 <byorgey> composition is concatenation of lists + possible reduction of the two elements at the boundary if they are from the same monoid
11:50:40 <jmcarthur> hmm, i know of no such thing
11:51:07 <byorgey> the 'monoids' package seemed an obvious place to look but it doesn't seem to have anything for coproducts
12:09:55 <ski> byorgey : hm, is that `type MonoidSum m n = Either (SwapList m n) (SwapList n m); data SwapList b a = Nil | Cons a (SwapList a b)'  ?
12:10:42 <byorgey> ski: yes
12:19:18 * hackagebot splot 0.1.19 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.1.19 (EugeneKirpichov)
12:24:47 <chrisdone> λ> conn <- connectAmelie
12:24:47 <chrisdone> λ> query_ conn "select created,title,content,id from paste order by id desc limit 1" :: IO [(ZonedTime,Text,Text,Integer)]
12:24:47 <chrisdone> [(2011-06-02 21:39:14.372318 +0200,"Example","Hello, Bryan!",46622)]
12:25:01 <chrisdone> bos: Tada! Using your existing library made this so easy. :-D
12:34:46 <chrisdone> bos: How did you benchmark mysql-simple?
12:36:25 <adimit> are there any examples of using iteratee's convStream, or, more generally, examples where an iteratee is used to map many stream chunk elements to fewer items inside an iteratee?
12:37:27 <adimit> so basically, you want to join up elements from the input stream to form another stream of bigger, but fewer elements… I hope it's kinda clear what I mean.
12:38:43 <lee_> Guys, I have a question about idiomatic haskell design
12:38:58 <c_wraith> go ahead and ask.  you'll get plenty of opinions :)
12:39:05 <c_wraith> (some of us might even agree)
12:39:14 <lee_> I've got this bytestring I need to parse
12:39:47 <lee_> right now, I'm doing all my work in the State (Maybe ByteString) monad rather than passing the bytestring into each of my fcns
12:40:02 <lee_> (and passing it out with the return value as part of a tuple)
12:40:33 <kmc> greetings
12:40:53 <kmc> anyone have a good example of using LogicT?
12:41:06 <lee_> I like how it makes my functions' code simpler, but I;m unsure about the "hidden argument" feature
12:41:20 <lee_> OTOH, it seems much like a limited version of the IO monad
12:41:44 <c_wraith> It's really not anything like IO.  It really is just "hidden argument and return values"
12:41:57 <c_wraith> IO allows true mutation.  State just hides passing a value around
12:41:59 <dafis> not even really hidden
12:42:39 <bos> chrisdone: tested it with my application
12:42:43 <lee_> OK, I think I see the difference, there c_wraith
12:43:09 <kmc> State can be implemented in a couple lines of pure standard Haskell
12:43:21 <kmc> IO can't be implemented without special support from your Haskell implementation
12:43:31 <kmc> it is, for all standard purposes, built-in
12:44:57 <lee_> Cool.  That makes me feel a bit more like I've made the right design decision...still a Haskell newbie
12:45:09 <c_wraith> lee_: if it makes your code simpler to express, no one will object to using State.  It's not impure, it's not immoral, it's not whatever you might be worried about :)
12:45:11 <byorgey> kmc: here's a simple example of using LogicT: http://byorgey.wordpress.com/2011/02/24/enumerating-linear-inhabitants/
12:45:21 <dafis> lee_: yes, using State was the right decision
12:45:40 <kmc> thanks
12:46:05 <kmc> in some cases though it's clearer to write out the state-passing explicitly
12:46:53 <lee_> kmc, in this case, I tried that ... it was clear for many functions, but for a couple of them, it got pretty ugly
12:46:59 <kmc> *nod*
12:47:08 <Saizan> if you ever get to s'' it's time to switch to State
12:47:09 <kmc> so you're probably getting a feel for where State does and doesn't help
12:47:26 <adimit> lee_: one thing you might want to consider if you are actually parsing, is to use a parsing monad. look into polyparse for something simple, parsec for something powerful, and uu-parselib if you enjoy seeing pieces of your brain stuck to a nearby wall.
12:47:30 <chrisdone> bos: Ah, okay. I mean, got any numbers? It's certainly fast enough for my purposes, I was just curious. Thought you might've done some specific stress-tests.
12:47:33 <kmc> the problem with naming variables like "s''" is that there's a huge potential for typos, and it's likely that s'' has the same type as s and s'
12:47:53 <bos> chrisdone: just compared app performance between HDBC and mysql-simple
12:48:03 <chrisdone> λ> do t <- getCurrentTime; titles :: [(ZonedTime,Text,Integer)] <- query_ conn "select created,title,id from paste order by id desc"; getCurrentTime >>= return . (`diffUTCTime` t)
12:48:04 <chrisdone> 0.673696s -- about 17K rows. Seems alright.
12:48:13 <chrisdone> bos: Ahh. I'll do that.
12:50:21 <roconnor> whats the maximum length of a strict bytestring?
12:50:34 <adimit> roconnor: whatever you can fit into memory, iirc.
12:50:59 <dafis> roconnor: maxBound :: Int
12:50:59 <bos> roconnor: whatever can be indexed by an Int and not make your computer die
12:51:01 <c_wraith> well, it uses an Int as an offset and an Int as a length
12:51:10 <roconnor> the length is stored at the beginning of a strict bytestring
12:51:15 <c_wraith> I don't know if ByteArray# has an intrinsic length limitation
12:52:28 <monochrom> only architecture's limitation
12:54:32 <roconnor> ah, in cereal the length of bytestrings are always serialized to 64 bit even on 32-bit systems.
12:54:37 <roconnor> that is good
12:54:46 <chrisdone> bos: I like this error message in formatMany: _ -> error "foo"
12:54:47 <roconnor> untill we move to 128-bit processors :/
12:54:47 <chrisdone> :P
12:55:47 <kmc> the popular AMD64 processors aren't even 64-bit!
12:55:51 <bos> chrisdone: eh, oops :-)
12:56:01 <kmc> /proc/cpuinfo says "address sizes   : 36 bits physical, 48 bits virtual"
12:56:15 <adimit> read error "this should never happen!" (but it always does.)
12:57:13 <dafis> _ -> error "I screwed up, but I blame you anyway"
12:57:16 <chrisdone> bos: https://github.com/chrisdone/pgsql-simple — Still a WIP (some incomplete bits commented out or marked FIXME), but might be interesting to see how I'm re-using your stuff.
12:57:51 <bos> chrisdone: nice!
12:57:54 <roconnor> I don't understand why anyone would use binary over cereal.  I don't understand what is wrong with the Haskell Platform people.
12:58:08 <monochrom> my theory is that you got scammed by a dishonest computer seller
12:58:41 <roconnor> my intel centrio says: address sizes   : 36 bits physical, 48 bits virtual
12:58:47 <roconnor> an I'm on a 32-bit system
12:59:18 <roconnor> Linux krile 2.6.37.6 #1 SMP Mon Apr 25 15:03:05 UTC 2011 i686 GNU/Linux
12:59:24 <kmc> that must be a 64-bit chip though
12:59:34 * hackagebot fix-imports 0.1.0 - Program to manage the imports of a haskell module  http://hackage.haskell.org/package/fix-imports-0.1.0 (EvanLaforge)
12:59:40 <roconnor> I've been using i686 all this time for no reason?
12:59:52 <roconnor> I should upgrade
13:00:16 <roconnor> model name      : Intel(R) Core(TM)2 Duo CPU     U9400  @ 1.40GHz
13:00:29 <dafis> address sizes   : 36 bits physical, 48 bits virtual <-- pentium 4
13:01:05 <kmc> yeah, some P4's have EM64T
13:01:34 <kmc> x86_64 code is not universally better than i686, but it's better for most users
13:01:44 <monochrom> I have a "model name: Intel(R) Celeron(TM) CPU 1066MHz" "address sizes	: 36 bits physical, 32 bits virtual"
13:02:03 <kmc> that sounds like a 32-bit chip (i.e. no long mode) which supports PAE
13:02:14 <monochrom> yeah
13:02:25 <monochrom> 10 years old
13:02:48 <roconnor> I'm not yet convinced I have a 64 bit processor
13:03:05 <monochrom> address bus may be lesser than data bus
13:03:17 <dafis> I'm pretty sure mine's 32-bit
13:03:30 <kmc> roconnor, i'm told the "lm" flag in cpuinfo stands for "long mode" i.e. 64-bit capable
13:03:58 <roconnor> :O
13:04:16 <roconnor> I should totally switch to 64 bit mode!!
13:04:21 <roconnor> I had no idea
13:04:38 <dafis> kmc: and how would one use that, just install a 64-bit OS?
13:05:08 <kmc> you'll need a 64-bit kernel and 64-bit userspace programs to take advantage
13:05:16 <chrisdone> bos: So when you're using fold with mysql, it literally asks the server for another row each time you run fetchRow? From what I understand of the postgres protocol this isn't possible, it sends everything in one go (and I see nothing about limiting/resuming/staggering results). I still might implement fold as delaying the /parsing/ of the rows (e.g. 20K results) should be a speed gain.
13:05:22 <kmc> on some architectures (SPARC) you want to keep a 32-bit userspace where possible
13:05:45 <kmc> 64 bit is slower because pointers are twice as big!
13:05:58 <kmc> but on x86, long mode also doubles the number of general-purpose registers
13:06:03 <kmc> which usually makes up for that -- but ymmv
13:06:18 <dafis> I should try, I think
13:06:25 <olsner> if you could use long mode with 32-bit pointers that should be win/win
13:06:50 <olsner> for stuff that doesn't need to use more than 4GB of memory that is
13:06:50 <chrisdone> bos: (Of course, one could implement staggering with limit/offset /within/ the SQL query text, but that's a different level of abstraction…)
13:09:09 <kmc> of virtual memory, yes
13:10:02 <kmc> part of the benefit of having more virtual address space than you know what to do with is that you can use memory-mapped I/O for all your files
13:10:45 <mustelo> is there a more compact way of writing (\x -> x *** x) ?
13:11:00 <monochrom> (***)
13:11:08 <ben> really
13:11:09 <kmc> join (***)
13:11:09 <monochrom> sorry, no
13:11:19 <mustelo> :t join
13:11:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:11:29 <olsner> @ty (liftM2 (***), join (***))
13:11:30 <lambdabot> forall (a :: * -> * -> *) b c b' c' (m :: * -> *) (a1 :: * -> * -> *) b1 c1. (Arrow a, Monad m, Arrow a1) => (m (a b c) -> m (a b' c') -> m (a (b, b') (c, c')), a1 b1 c1 -> a1 (b1, b1) (c1, c1))
13:11:56 <olsner> hmm, lift didn't seem quite right there
13:11:58 <chrisdone> :t flip $ flip join
13:11:59 <lambdabot> forall b a. (a -> a -> b) -> a -> b
13:12:24 <mustelo> thanks, join is what I was looking for
13:13:00 <chrisdone> Good old flip$flip is like a de-reader-monadifier.
13:13:28 <kmc> olsner, also your OS kernel will typically take a good chunk of that 4GB space
13:13:45 <kmc> the Linux kernel takes 1GB by default, so userspace can't map more than 3GB on a 32-bit system
13:14:29 <kmc> you can configure a kernel which gives userspace the full 4GB but it has about a ballpark 20% performance penalty
13:15:44 <chrisdone> The LFE or something like that?
13:16:02 <chrisdone> Extended thingie support.
13:16:07 <kmc> ?
13:16:17 <roconnor> booo: http://yellowgrass.org/issue/NixOS/68
13:17:25 <chrisdone> kmc: I'm on 32-bit and I can only claim 3.2GB. From what I read at the time I could get the full 4GB by running the kernel compiled with special support that extends pointers to support more. Ubuntu server edition has it by default. I can't remember the name.
13:17:50 <monochrom> in case of ubuntu server, that's PAE
13:18:02 <kmc> that doesn't extend pointers
13:18:09 <chrisdone> Ahhh, PAE. Haha. I remembered it as "LFE", somehow.
13:18:11 <kmc> it extends the physical address space but not the virtual
13:18:12 <chrisdone> Ah, what does it do?
13:18:13 <ddarius> It changes the way they are interpreted.
13:18:28 <ddarius> @google pentium address extension
13:18:29 <lambdabot> http://en.wikipedia.org/wiki/Physical_Address_Extension
13:18:29 <lambdabot> Title: Physical Address Extension - Wikipedia, the free encyclopedia
13:18:32 <kmc> so each process can still only map that ~3GB
13:19:08 <chrisdone> Ohhh. But they're not all necessarily accessing the same physical locations?
13:19:20 <kmc> correct
13:19:24 <monochrom> it is A21 all over again
13:19:29 <kmc> that's a property of virtual memory in general
13:19:29 <roconnor> whew, this haskell project I'm writing is up to 884 lines!
13:19:31 <monochrom> err, A20
13:19:51 <kmc> two processes accessing the same virtual address will get mapped to different physical addresses
13:19:55 <ddarius> A20 was just silly.
13:20:07 <kmc> PAE just increases the number of possible physical addresses
13:20:16 <kmc> that's an easier change than increasing the virtual address space
13:20:28 <chrisdone> Neat.
13:20:34 <kmc> which would affect every user program that uses pointers
13:20:50 <kmc> while increasing physical addresses only affects code that screws with page tables, which is usually just the kernel
13:22:15 <kmc> userspace only getting 3GB by default on 32-bit x86 Linux is a different issue
13:22:48 <kmc> that's a software design choice, not a property of the hardware
13:23:09 <kmc> the kernel reserves the top 1GB for its own use, and maps that into every process's address space
13:23:29 <kmc> that way a system call does not incur the overhead of switching page tables, flushing the TLB, etc.
13:23:59 <chrisdone> Ah, I don't know anything about page tables.
13:24:25 <kmc> "overhead of switching the virtual -> physical mapping" then
13:25:14 <kmc> the fact that users control the memory map in which kernel code executes has exciting security implications, viz http://blog.ksplice.com/2010/04/exploiting-kernel-null-dereferences/
13:27:09 <ddarius> chrisdone: You should learn about page tables.
13:29:33 <chrisdone> ddarius: Recommend a source in particular?
13:29:52 <kmc> http://pdos.csail.mit.edu/6.828/2010/
13:30:48 <ddarius> @google intel architecture manuals
13:30:49 <lambdabot> http://www.intel.com/products/processor/manuals/
13:30:49 <lambdabot> Title: Intel® 64 and IA-32 Architectures Software Developer's Manuals
13:31:21 <kmc> the 6.828 labs are fun
13:31:54 <kmc> in Lab 2 you will learn how to manage page tables and by Lab 4 you're using them for nontrivial things (e.g., copy-on-write fork)
13:33:50 <sam7> I have a question about haskell
13:34:16 <arcatan> please ask
13:34:22 <sam7> data Ternary = 0 | 1 | 2 deriving (Show)
13:34:41 <sam7> how can we say so that it knows 0 1 2 are integers?
13:34:45 <kmc> you can't
13:35:00 <kmc> the type can't be both Integer and Ternary
13:35:02 <kmc> each value has one type
13:35:07 <sam7> so can we not make a type that consists only of 0, 1, or 2?
13:35:08 <kmc> also, data constructors have to start with an upper-case letter
13:35:26 <kmc> data Ternary = Zero | One | Two; instance Num Ternary where ...
13:35:35 <sam7> oh...
13:35:38 <byorgey> sam7: that is a reasonable thing to want, but you cannot express it directly in Haskell
13:35:40 <sam7> I see...
13:35:59 <sam7> then if you write
13:36:04 <sam7> data Ternary = Zero | One | Two
13:36:18 <byorgey> it would massively complicate the type system.  For suppose I write a function that takes an Integer and is supposed to return something of type {0,1,2}
13:36:22 <sam7> then can we define each one as an integer? or is it no possible?
13:36:31 <kmc> what does "define as an integer" mean?
13:36:33 <byorgey> the typechecker now has to do some fancy math to know that the function has the right type
13:36:40 <kmc> if you want to use the literal "2" in your code, that's fine
13:36:50 <kmc> because that's interpreted through fromInteger, which is a Num type class method
13:37:07 <ddarius> byorgey: Pssh, surely you can solve the halting problem with elementary school math.
13:37:27 <sam7> hm...I see..
13:37:45 <sam7> alright~! Thanx for all the help
13:38:26 <byorgey> ddarius: well, of course, *I* can.
13:40:04 <chrisdone> ddarius: Good idea, I've never looked at the Intel manuals.
13:40:11 <monochrom> you can solve diophantine equations with elementary school math
13:41:03 <monochrom> and a lot of time
13:42:24 <c_wraith> I thought solving diophantine equations was undecidable, in general.
13:42:39 <monochrom> therefore it needs a lot of time
13:43:16 <lee_> Is there a cleaner way to express "liftM2 (*) (Just byteSize) $ liftM fromIntegral y"
13:44:23 <monochrom> liftM (\x -> x * fromIntegral y) (Just bytesize)
13:44:50 <monochrom> > (* fromIntegral 10) 11
13:44:51 <lambdabot>   110
13:45:01 <monochrom> oh, (* fromIntegral y) then
13:45:24 <solrize> wait wut
13:45:29 <solrize> :t (* fromIntegral)
13:45:30 <lambdabot> forall a b. (Integral a, Num b) => (a -> b) -> a -> b
13:45:42 <monochrom> read it as (* (fromIntegral y)) please
13:46:14 <solrize> why did lambdabot parse it that way?
13:46:24 <monochrom> because haskell98 requires it
13:46:41 <monochrom> aexp -> (qop infixexp) is very nice
13:46:50 <kmc> lambdabot's giving that type to (* fromIntegral) because it has a Num (a -> b) instance
13:46:51 <monochrom> > (* 3 + 4) 7
13:46:52 <lambdabot>   The operator `GHC.Num.*' [infixl 7] of a section
13:46:52 <lambdabot>      must have lower prece...
13:48:52 <monochrom> > (+ 3 * 4) 7
13:48:53 <lambdabot>   19
13:48:59 <lee_> thanks, monochrom
14:02:50 <ior3k> it looks like heroku now supports clojure apps... anyone know if, by chance, they support haskell too?
14:04:09 <ior3k> I couldn't find anything about it
14:04:18 <erus`> java AND haskell?
14:04:25 <erus`> AND (ruby?)
14:05:57 <ior3k> and node.js
14:06:04 <ior3k> but I don't know about haskell :)
14:06:25 <parcs> it doesn't "support" it; heroku just provides shell access which can be used to run virtually any executable
14:06:49 <ior3k> parcs: right, I guess that's what I wanted to know, if it's possible to use haskell on the new stack
14:07:05 <ior3k> heroku used to be pretty restrictive
14:07:23 <parcs> i don't see why not. just compile a static executable and run it locally
14:08:30 <ior3k> parcs: nice, I didn't know about shell access, thanks for the info
14:11:31 <Mkman> Hey!
14:12:16 <EgadBlargl> Hi all.  I've got a program snippet at http://pastebin.ca/2073868 (hpaste.org is down?) that tries to use map entirely for side-effects -- anyone mind taking a look and telling me where I'm going so terribly wrong?
14:12:37 <monochrom> hpaste is up
14:12:39 <sm> ior3k: oh! exciting. I've been summoning haskell support
14:12:44 <ben> if I use modifySTRef r (+1) a lot of times in the strict ST monad, do I build up a ton of x+1 thunks inside the ref until I eventually print the value or whatever anyway?
14:12:49 <acowley> I suppose the program is trying to use map entirely for side-effects
14:12:54 <acowley> s/program/problem
14:13:13 <acowley> have you looked at mapM and mapM_?
14:13:35 <EgadBlargl> monochrom: Oh, it must just not be working from my connection.
14:13:42 <EgadBlargl> acowley: I have not, I'll go look them up right now.
14:14:14 <acowley> EgadBlargl: where are you trying to generate side-effects from map here?
14:14:31 <monochrom> map doesn't do side effects
14:14:40 <acowley> It looks like you just want to mapM_ runCfg xs
14:14:54 <monochrom> yeah
14:15:00 <EgadBlargl> Sorry, they were mostly snipped out.  The function that map calls (runCfg) does a bunch of putStrLn's at the end.
14:16:03 <EgadBlargl> acowley, monochrom: Indeed, that works.  Thanks a bunch.  I'll have to read a bit more so I can figure this stuff out on my own.  Thanks again!
14:16:16 <stulli> After downloading a file my umlauts are mangled (TÃ¼rkei instead of Türkei) when i print it with putStrLn. Does anybody know whats the issue here?
14:16:45 <Twey> Looks like your file is in UTF-8 but your terminal is set to use Latin-1
14:17:10 <stulli> Twey: If i use curl from command line everything os fine
14:17:22 <acowley> ben: the documentation for Control.Monad.ST says it is strict in the state though not in the values stored in the state
14:17:27 <stulli> also i can do putStrLn "äöü" without any issues
14:17:33 <Twey> Of course you can
14:18:25 <acowley> Anyone up for helping me test some software?
14:18:55 <acowley> It requires a native library (OpenCV), so it would probably be easier for Linux/OS X.
14:18:56 <monochrom> the issue is encoding issue. given the information so far
14:22:42 * sm nods, encoding for sure
14:26:20 <sm> see the occult sigils ? very characteristic.
14:27:36 <stulli> Twey, monochrom: $LANG is set to en_US.UTF-8 and urxvt has no special setting in .Xresources. Where else could i look? I'm a bit lost as i don't even understand the underlying problem.
14:27:51 <sm> stulli: you could try writing it (rather than printing). And curl -O the same file, and compare. That would remove terminal settings from consideration
14:27:52 <monochrom> your source code?
14:29:57 <sm> also consider using functions from http://hackage.haskell.org/package/utf8-string
14:31:04 <stulli> monochrom: http://darcsden.com/stulli/couchnews/browse/couchnews.hs#L-108 line 108 and 69
14:31:38 <ben> jeez there ought to be a simpler way than x <- readSTRef r; let x' = f x in x' `seq` writeSTRef r x'
14:32:38 <ddarius> ben: It's called abstraction.
14:32:49 <acowley> ben: something like "modifySTRef (f $!) r" might be enough for your case
14:32:54 <c_wraith> well, you can simplify that latter part to writeSTRef $! f x
14:33:13 <ben> cheers
14:33:48 <ddarius> readSTRef r >>= (writeSTRef $!) . f
14:33:50 <ddarius> +r
14:34:00 <monochrom> then curlGetString probably does decoding wrong
14:35:06 <stulli> Well, thats unfortunate. I tried it with HTTP.Simple aswell and it also fails
14:35:14 <monochrom> but you can save it by passing through Codec.Binary.UTF8.String.decodeString from utf8-string
14:35:33 <monochrom> yes, HTTP.Simple also does decoding wrong
14:36:20 <sm> can you share the url ?
14:36:35 <monochrom> both libraries were written around 2000 when it was cool to assume everyone used iso-latin-1, and not improved since
14:36:53 <monochrom> hackage.haskell.org/package/utf8-string
14:37:26 <monochrom> where 2000 was like a decode after Unicode appeared
14:38:16 <ben> heh
14:38:39 <monochrom> s/decode/decade/
14:39:28 <stulli> monochrom: Thank you very much, using decodeString solved the problem.
14:39:32 <monochrom> the chinese government had a law that says all computers sold in china beginning in 2000 must support gb18030, which is a bijection of unicode
14:40:20 <monochrom> in practice that meant all OSes must fully support unicode anyway
14:41:14 <stulli> makes sense for china
14:42:21 <monochrom> (in theory you could fork a version of your OS to do gb18030 for china, and another version to do ascii-only, but why would you do that, it would be a maintenance nightmare. if you support gb18030 you may as well support unicode all out)
14:54:17 <dadsasfgds> http://www.snowlinux.de/ Snowlinux
14:54:47 <monochrom> it is not Slow Linux? :)
14:57:53 <Twey> I don't understand why people keep making all these distributions that are basically all the same
14:58:10 <monochrom> not invented here
14:58:33 <monochrom> also programmers are customization freaks
14:59:16 <stulli> No Haskell Linux yet?
15:00:39 <djahandarie> stulli, no Linux distro, but people have tried making full OSes with it.
15:02:44 <shachaf> djahandarie: Well, there was Linspire...
15:02:54 <djahandarie> There's also a Linux distro which uses ideas like purity and versioning in its package manager, but doesn't actually use HaskellcOcOcOcOcOcOcOcOcOcOcOcOcOcOcOcOcOcOcOcOcOcOcOc[C[COcOcOc .
15:03:11 <dankna> cat on keyboard?
15:03:18 <monochrom> what is the cOc doing there?
15:03:18 <mauke> literal arrow keys
15:03:27 <monochrom> but the said distro is nixos
15:03:45 <djahandarie> No, my connection dropped and some garbage apparently got inserted.
15:03:47 <djahandarie> That wasn't typed.
15:03:57 <dankna> ah okay
15:04:07 <monochrom> oh fun, like "$%#%$##(*&*( NO CARRIER"? :)
15:05:23 <djahandarie> Heh, that's probably a little too outdated
15:05:41 <monochrom> +++ATX
15:05:53 <ion> X?
15:06:02 <monochrom> was it X for hanging up?
15:07:11 <monochrom> ATH0 then
15:10:03 <monochrom> there was once a dial-up ISP with its modems configured incorrectly, i.e., not enough waiting after "+++" to enter command escape mode
15:10:36 <monochrom> so, suppose I post a message in a newsgroup or an email to you with the string "+++ATH", and you read it
15:10:54 <ion> They should have been configured to ignore +++ entirely.
15:11:09 <monochrom> well, that string goes through the ISP's modem, and the modem honours the command and hangs up. that disconnects you
15:11:11 <ion> Also, i have to send +++ATH0 outwards, so you have to get me to send it.
15:11:42 <ion> It’s “my” modem that was generally the one being attacked.
15:11:59 <monochrom> I did post such a message to the ISP's local newsgroup and have multiple users reproduce the problem. it was fun.
15:12:05 <ion> nice
15:12:38 <monochrom> their sysadmin boneheadedly denied it, despite multiple users confirmations
15:13:42 <monochrom> indeed, properly done ISPs all disabled +++ on their side. there is simply no use of it.
15:21:25 <ion> There’s no use for it on the client’s side either. The modem is more properly told to disconnect with the DTR line.
15:45:25 <Taslem> I was thinking. Wouldn't it make more sense to pass output back from the 'main' (or elsewhere) function by sending them in a structure like a linked list/other lazy structure?
15:45:52 <kmc> main is not a function
15:46:28 <Taslem> It's an expression, which is the same as a function with 0 arguments in the lambda calculus.
15:46:46 <shachaf> Taslem: There is no such thing as a function with 0 arguments in the lambda calculus.
15:47:00 <shachaf> By definition a function takes an argument, otherwise it's not a function.
15:47:04 <Taslem> I suppose that's true.
15:47:50 <Taslem> Anyways, why is it that Monads are used for output rather than something like sending a stream of output commands?
15:48:03 <kmc> the fact that IO is a monad is mostly irrelevant here
15:48:11 <shachaf> Taslem: The fact that the type IO is an instance of -- what kmc said.
15:48:16 <Twey> Taslem: Same thing
15:48:25 <acowley> Taslem: you can find papers about the evolution of main
15:48:41 <kmc> what matters is that IO works by gluing together IO actions with this operator (>>=)
15:48:52 <kmc> the fact that the operator (>>=) generalizes to types other than IO is irrelevant
15:49:03 <djahandarie> (Also, an expression can have any type, it's not limited to non-(->) types.)
15:49:20 <kmc> so the question is "why do IO by passing continuations, rather than returning a lazy list"
15:49:31 <Twey> Error-handling?
15:49:35 <kmc> and that's a nice meaty question, because laziness subsumes continuations in a lot of other domains
15:50:12 <shachaf> You don't even need (>>=) -- you could just do it by passing the continuations directly.
15:50:14 <kmc> and indeed Haskell used to do IO this way
15:51:06 <kmc> one problem is that it is hard to keep a lazy list of inputs and a lazy list of output synchronized
15:51:16 <kmc> easy to read too far ahead and deadlock the program
15:51:32 <kmc> Taslem, if you do want to program in that style, you can use
15:51:33 <kmc> :t interact
15:51:34 <lambdabot> (String -> String) -> IO ()
15:51:40 <kmc> main = interact f
15:51:43 <Peaker> Taslem: The approach of having   main :: [Response] -> [Request]    was used -- but you really want to abstract that away with a type like (IO a) for sanity :)
15:52:21 <Taslem> Hm. I see.
15:52:21 <Peaker> Taslem: IO and (>>=) enforce causality of effects/values,  a response->request list processor does not
15:52:37 <mjrosenb> > -2 `mod` 10
15:52:38 <lambdabot>   -2
15:52:53 <Taslem> Couldn't you use sentinels/etc. for that?
15:52:56 <mjrosenb> > (-2) `mod` 10
15:52:58 <lambdabot>   8
15:53:07 <mjrosenb> what kind of parsing magic is going on there?
15:53:21 <kmc> > - (2 `mod` 10)
15:53:22 <lambdabot>   -2
15:53:28 <Taslem> - has lower precedence is all.
15:53:35 <kmc> lower than `mod`, which can be declared btw
15:53:46 <Taslem> Lowest precedence, isn't it?
15:53:46 <acowley> Haskell discourages you from using negative numbers
15:53:49 <kmc> Taslem, you could probably patch up the lazy-list approach
15:53:59 <kmc> but the abstract IO action approach is *really* elegant
15:54:03 <kmc> once you understand it
15:54:13 <mjrosenb> so even though there is no lhs, - is really an infix operator?
15:54:14 <kmc> you get the full power of imperative programming
15:54:18 <kmc> not some clunky compromise
15:54:26 <kmc> but you get it embedded in a functional language in a principled way
15:54:34 <dolio> - is special cased in the grammar.
15:54:46 <Twey> - is a horrible wart.
15:54:56 <shachaf> kmc: "principled"?
15:54:58 <shachaf> @get-conal
15:54:58 <lambdabot> Unknown command, try @list
15:55:08 <kmc> shachaf, moreso than the popular alternatives
15:55:28 <Taslem> Oh, yehah. Something I've always thought of as curious. How exactly does Haskell produce a syntax tree when parsing?
15:55:44 <Taslem> Because there's a couple ways of doing it and none of them seem to have the same effects as Haskell.
15:55:47 <acowley> shachaf: it is forever caught in its type, but that type doesn't limit expressivity.
15:56:04 <dolio> Taslem: What do you mean?
15:56:06 <Peaker> Taslem: sentinels? What do you mean?
15:56:10 <kmc> Taslem, that's an implementation detail
15:56:25 <kmc> the Haskell language spec describes a grammar, but doesn't tell you how you have to implement that grammar
15:56:45 <Taslem> Peaker: For each output, a corresponding value could be placed in input to maintain causuality.
15:57:30 <Peaker> Taslem: you could still build a request list that depends on responses from the future?
15:58:18 <Taslem> Peaker: The purest way of looking at it doesn't work. Instead, programs would be instructed to drop all of the inputs until they reach one of those values.
15:58:47 <kmc> Taslem, do you think this would be better than the way IO is done in Haskell today?
15:58:50 <Peaker> Taslem: what's the advantage?
15:59:16 * hackagebot timeplot 0.3.7 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.3.7 (EugeneKirpichov)
16:00:40 <Taslem> I guess the only advantage would really be a form of IO that remains pure in the sense that the IO being sent out could be stopped or changed. It would also let functions reorder the output that the functions they call perform.
16:00:55 <Peaker> You could think of an impure program as an alternating sequence of:   action, computation, action, computation, ...  where each is allowed to depend on the previous ones.   (>>=) :: IO a -> (a -> IO b) -> IO b         captures that nicely -- sandwiches an:   action,  computation that sees its result, and another action that gets to depend on the computation, into one action... repeatedly sandwiching these results in the long interlaced sequence
16:01:24 <dolio> That sounds like a nightmare to me.
16:01:42 <kmc> Taslem, but you can already implement that reordering
16:01:43 <dolio> If foo :: [Response] -> [Request]...
16:01:46 <kmc> just return [IO a] instead of IO [a]
16:01:54 <kmc> then when you want to finalize the order, use
16:01:54 <Peaker> Taslem: it seems you want to make   (IO a)  less opaque -- but for that you must remember it also contains computations (aka turing complete black boxes) in between actions that *determine the next actions*
16:01:55 <kmc> :t sequence
16:01:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:02:10 <dolio> Then 'main in = tail (foo in)' blows up.
16:02:31 <acowley> oh boy, pandoc won't install because I have two copies of directory-1.1.0.0
16:03:10 <Peaker> Taslem: so you must use a less opaque type like [IO a] as kmc suggested, if you want to have more re-ordering options. Of course that adds power on the receiver end at the expense of the sender end -- which now cannot make his action list's actions depend on previous inputs
16:03:16 <Taslem> From what I know about the IO monad, the output sent is essentially produced when the IO functions are called (e.g. putStrLn), whereas only when they were finally actually sent and returned by main could they modify future input.
16:06:15 <Peaker> I wonder if it useful to say: Applicative computations (f b) are isomorphic to a list of effects [f a] as well as a compositor: [a] -> b  (where 'a' is some useless sum type of all the computations used within).. I guess it may be useful if you never need the 'b'
16:06:28 <Peaker> Taslem: I don't think I understand what you said there
16:06:37 <kmc> the output is not sent when the function is called
16:06:41 <kmc> calling putStrLn just returns an "IO action"
16:06:50 <kmc> which is an inert, opaque description of some IO which *could* be performaned
16:06:53 <kmc> performed*
16:07:04 <Taslem> I know. But there's no way to prevent that, is there?
16:07:09 <kmc> to prevent what?
16:07:46 <kmc> err, got to go
16:07:47 <kmc> sorry
16:07:48 <kmc> ttyl all
16:09:27 <Peaker> Taslem: I'm not following what you're trying to say... if you're unsatisfied with Haskell IO, you're not alone... It is basically a way to make Haskell's type system type-check imperative programs pretty directly.  Those who want to move from imperative to functional dislike this as a "solution", but everyone agrees it is a good temporary workaround
16:10:40 <Peaker> You could say Haskell's IO type is just an "imperative programming DSL" within the functional paradigm, showing how it is just a small subset
16:12:02 <SpinDoctor> i have haskell-related mac question ... I'm trying to look at a bunch of sample Haskell files and some have extension .ghci.  These are just text files, but I can't view them in Cover Flow or Quick Look.  Does anyone know how to tell Quick Look to just treat them as text files?
16:14:35 <geheimdienst> SpinDoctor: have you tried selecting a .ghci file, hitting apple-i and setting the application to open it? possibly that will teach quicklook
16:14:52 <danharaj> can someone explain the type of atomicModifyIORef to me?
16:14:55 <danharaj> :t atomicModifyIORef
16:14:56 <lambdabot> Not in scope: `atomicModifyIORef'
16:15:09 <danharaj> IORef a -> (a -> (a, b)) -> IO b
16:15:13 <solrize> sounds like a thread-safe modifyioref
16:15:24 <acowley> SpinDoctor: This sounds like a pain http://hints.macworld.com/article.php?story=20071028184428583
16:15:32 <dolio> You get an a, you provide a new a, and a result b to return.
16:15:34 <acowley> But it lets you avoid changing a file type's association
16:16:48 <dolio> If r contains 97, then atomicModifyIORef r (\n -> (n+1, chr n)) will modify r to contain 98, and the IO action will yield 'a'.
16:16:51 <SpinDoctor> geheim: yes, i tried that.  it was "no application", so I changed it to use Aquamacs - that's what the .hs files are set to - but didn't work.   The output from the file command just says they are text files.
16:17:16 <danharaj> dolio: ah ok. I have to wonder why modifyIORef doesn't have the same type.
16:17:45 <dolio> It's somewhat less necessary.
16:17:45 <SpinDoctor> acowley:  ha!  I just pulled up that same page before you posted it, thought I'd give it a try ;)
16:17:51 <dolio> Although it'd still be convenient.
16:18:51 <solrize> is there a way to "select" on mvars?  i.e. i have empty mvars m1,m2,m3,m4 and want to sleep until one of them becomes non-empty
16:20:08 <c_wraith> Not really.  That's the case STM is made for.
16:20:39 <solrize> hmm.  STM doesn't use MVars I guess.
16:20:47 <acowley> you can forkIO a waiter on each of them as the event manager uses select under the hood
16:21:04 <solrize> acowley, yeah, i was hoping to avoid that
16:21:10 <c_wraith> STM has TMVars
16:21:19 <acowley> solrize: why?
16:21:19 <solrize> i'm going to have 100's of concurrent threads doing this
16:21:33 <c_wraith> ...  You say that as if hundreds of threads are a big deal. :)
16:21:35 <acowley> that's still probably fine
16:21:36 <solrize> :)
16:21:58 <monochrom> 100's of thread may or may not be as hogging as you think
16:22:15 <c_wraith> But really, STM is *designed* for the case of "want to have transactions that potentially involve hundreds of mutable cells"
16:22:23 <solrize> the blocked mvars in general won't be waiting for i/o
16:22:30 <acowley> just try writing a select function yourself that forkIOs a thread for each given MVar and see if it works out for you
16:22:40 <solrize> yeah, STM sounds like the simplest approach
16:32:53 <solrize> http://hpaste.org/47372/mvar_select   does this look sort of reasonable for an mvar approach?  is readMVar atomic?
16:33:01 <c_wraith> readMVar is not atomic
16:33:32 <dmwit> What does "atomic" mean?
16:33:33 <solrize> i guess what i did was bogus i don't really need to pass the woken-up mvar through
16:33:46 <dmwit> It won't read bits of a value from one write and bits from another write, if that's what you mean.
16:33:52 <solrize> atomic meaning readMVar doen't have a rae conditio
16:33:57 <solrize> race condition
16:34:07 <c_wraith> there's no way to distinguish between two MVars of the same type, anyway
16:34:14 <c_wraith> So yeah, returning an MVar is a bit silly
16:35:34 <acowley> Maybe just, mapM_ forkIO $ map (readMVar >=> putMVar c) ms
16:35:36 <c_wraith> readMVar consists of a take and a put, as two different actions.  a different thread may put in between them, causing it to block after the take succeeds
16:36:24 <solrize> http://hpaste.org/47373/mvar_select_annotation
16:36:52 <dmwit> mapM_ (forkIO . wait c) ms
16:36:57 <solrize> c_wraith, yeah, that's what i meant.  so i have to put in some hack to distinguish which mvar was woken up
16:37:54 <Peaker> readmvar seems problematic -- why not peek inside the var non-blockingly if it has a value?
16:38:39 <c_wraith> simonM said they were considering changing readMVar to do that
16:39:12 <solrize> oops meant to use take that time
16:39:45 <solrize> http://hpaste.org/47374/mvar_select_annotation_anno
16:40:54 <dmwit> But this is so silly.
16:41:05 <Peaker> is there a hashtable-based memoization thingie hidden behind unsafePerformIO somewhere?
16:41:06 <dmwit> Instead of having a bunch of mvars, why not have just one that all the threads you're selecting from write to?
16:41:10 <c_wraith> the thing is, what you want to do is just "mconcat . map readTMVar" with STM and TMVar
16:41:51 <dmwit> Let the thread manager do the selection for you.
16:41:53 <solrize> dmwit there is a different thread writing to each mvar
16:41:53 <dmwit> That seems much saner.
16:41:59 <dmwit> solrize: Yes.
16:42:06 <dmwit> solrize: Just give them all the same mvar to write to.
16:42:47 <c_wraith> actually, this operation is *really* painful unless they're writing to a Chan
16:43:00 <c_wraith> because otherwise you have to kill all the other threads
16:43:04 <solrize> hmm, so they would have to send something through the mvar saying where the wakeup came from, which i guess is ok
16:43:05 <c_wraith> as part of the cleanup
16:43:23 <c_wraith> One more reason STM is a good idea hear
16:43:38 <dmwit> solrize: I mean, you could send something saying where it came from, but why do you need that? What is the bigger picture here?
16:43:54 <solrize> i think using one mvar gets messy since the other threads would have to be alerted whether to write to it or not
16:44:07 <dmwit> solrize: What are you talking about?
16:44:15 <solrize> dmwit i'm figuring out how to simulate an array processor,  http://greenarrays.com
16:44:19 <dmwit> One thread writes to it, and the others block, because the mvar is full.
16:45:00 <solrize> there are 144 cpu nodes on that chip in a rectangular lattice, each node has 4 communication ports (1 on each side) that it communicates to its neighbors through
16:45:03 <solrize> each port is like an mvar
16:45:07 <c_wraith> err, takeTMVar, in the STM case.  whatever.
16:45:54 <solrize> and the node can block waiting for any subset of the 4 ports
16:46:12 <dmwit> hm
16:46:32 <solrize> i.e. there's "wait for <bit mask>" instruction
16:46:43 <c_wraith> Please just use STM.  Make your life reasonable. :)
16:46:50 <dmwit> Okay, I understand now why this complicates things.
16:47:20 <solrize> c_wraith, you're probably right, mvars were just the first thing i thought of.  :)
16:48:01 <dmwit> So, it still doesn't seem that bad.
16:48:07 <dmwit> Each node gets 2^4 mvars.
16:48:21 <dmwit> Then, when a node sends, it writes to multiple mvars.
16:48:32 <dmwit> To block on a subset, you choose the appropriate one of those mvars to read from.
16:49:29 <solrize> they may do a version with diagonal connections (8 ports per node)
16:50:40 <dmwit> Let each node have a Map from (Set Direction) to (MVar a). Only allocate as many MVar's as there are blocking patterns.
16:50:47 <dmwit> Any sane program probably won't have that many.
16:51:55 <solrize> also with 2^4 mvars per node, a sending node might block improperly from writing to an mvar that some other node wrote
16:52:03 <dmwit> Well, anyway, that's one idea. Select is not such a bad idea, either. I'm becoming convinced. =)
16:52:17 <solrize> and a cpu simulator can't know in advance what the user program is going to do
16:53:17 <dmwit> For the first objection, tryPutMVar seems relevant. I don't understand the second objection.
16:53:37 <dmwit> Ah... now I understand the second objection.
16:53:38 <roconnor> > floor (2^30*sqrt(2)::CReal)
16:53:39 <lambdabot>   1518500249
16:53:40 <dmwit> Yes, that's a problem.
16:55:59 <roconnor> > 0x5a827999
16:56:00 <lambdabot>   1518500249
16:56:19 <solrize> c_wraith, do you still think STM is the best approach?
16:56:47 <c_wraith> Honestly, I quit paying attention after my last comment :)
16:56:58 <solrize> np :)
16:57:08 <monochrom> try STM first. then see if it is fast enough
16:57:35 <c_wraith> This seems like the kind of domain where STM does well.  Lots of non-overlapping transactions in flight concurrently
17:00:05 <solrize> hmm
17:00:15 <solrize> ok i will read the stm docs ;)
17:00:18 <solrize> thanks
17:01:29 <monochrom> look for "orElse"
17:01:37 <solrize> actually my select function is no good, it leaves piles of zombie threads around if i call it more than once
17:03:33 <solrize> stm is in hackage, not the stdlib?  i didn't realize that
17:03:40 <c_wraith> solrize: didn't I say something about cleaning up the threads being a nightmare? :)
17:04:06 <c_wraith> fortunately, STM is actually very pleasant to use.
17:04:23 <monochrom> if you install the haskell platform, you have stm
17:04:36 <monochrom> but yeah not in ghc per se
17:05:34 <Teslah> Does anyone know of any simple Yampa examples?
17:06:03 <acowley> is cleaning up the threads really a nightmare? It's not just "mapM_ killThread ts"?
17:06:14 <monochrom> in the spirit of "greater tokyo", "greater boston", "greater toronto" etc, I personally consider the haskell platform to be "greater stdlib"
17:08:03 <c_wraith> acowley: You need to have the list of threadIds, and know when to kill them.  Not totally trivial.
17:08:07 <solrize> oh cool, i didn't realize hp included hackage stuff
17:08:40 <acowley> c_wraith: his select had the threadIds and a synchronizing MVar to know when one thread produced a value
17:08:41 <solrize> i think with mvars, rather than trying to kill those threads, i'd have a long-running port listener
17:09:08 <solrize> and just leave all the threads running/blocking rather than forking new ones on every select
17:09:26 <solrize> i could even use a Chan
17:09:47 <blackdog> damn, i really wish there was a jvm backend for haskell. looks like you can deploy arbitrary jvm stuff on heroku now
17:10:01 * blackdog really likes not running his own servers
17:10:10 <solrize> learn you a scala for great bad
17:12:21 <blackdog> solrize: it seems like an odd form of laziness
17:12:46 <solrize> scala?
17:13:48 <blackdog> learning scala in order to deploy on heroku
17:14:08 <solrize> heh
17:14:10 <solrize> yeah
17:14:11 <blackdog> scala's one of those languages... if i really had to use the jvm, i'd be grateful it exists
17:14:22 <blackdog> but i'd rather use haskell any day of the week.
17:14:23 <Balahla> Need help. I just can't get gtk2hs installed on my Windows XP. I dunno what to do...
17:14:39 <solrize> hmm, i've thought scala looked interesting except for that icky jvm part
17:14:43 <dibblego> I use haskell and scala in my job; scala is an awful contrast to step down to
17:15:50 <Balahla> I'm almost giving up Haskell for a simple gui application. thinking about use Clojure...
17:16:14 <dibblego> I'm most resentful that I am fighting scala at this moment, where no such fight is required in haskell
17:16:15 <acowley> Balahla: tried wx?
17:16:15 <ben> nemerle? :>
17:16:18 <Balahla> I'm very sad about that, since love haskell
17:16:18 <parcs> gtk2hs is a pain to install, and haskell isn't very special in the graphics department
17:16:20 <solrize> Balahla, i've never gotten gtk2hs to work either
17:16:41 <luite> gtk2hs isn't that terrible anymore
17:16:52 <luite> at least not on linux or windows, don't know about mac
17:16:57 <solrize> dibblego, i'd be interested if you wrote a blog post or something about scala from a haskeller perspective
17:17:12 <dibblego> solrize: I did, http://stackoverflow.com/questions/5099585/what-kind-of-things-are-easy-in-haskell-and-hard-in-scala-and-vice-versa
17:17:15 <monochrom> Balahla: http://search.gmane.org/search.php?group=gmane.comp.lang.haskell.cafe&query=gtk+windows may help
17:17:33 <ben> does code using gtk2hs look like ideomatic haskell?
17:17:41 <monochrom> there is something about staying with ghc 6.12.3
17:17:59 <monochrom> looks like idiomatic IO haskell
17:18:07 <solrize> dibblego, looking, thanks
17:18:25 <luite> the more haskell I see, the less I beleive that there is a single "idiomatic haskell"...
17:18:42 <monochrom> I have a medium example at http://www.vex.net/~trebla/haskell/gtk-interact.xhtml
17:20:05 <blackdog> luite: i think it's more standardised than scala, though
17:20:28 <dibblego> "idiomatic scala" is a euphemism for "the extent of my java hangover"
17:21:20 <blackdog> dibblego: what's interacting with java code like?
17:21:24 <dibblego> easy
17:21:32 <blackdog> do you just treat it as the IO monad or something similar?
17:21:35 * hackagebot husk-scheme 3.0 - R5RS Scheme interpreter program and library.  http://hackage.haskell.org/package/husk-scheme-3.0 (JustinEthier)
17:21:45 <dibblego> yes we have written IO in scala, but it is not widely used (yet)
17:21:52 <blackdog> i have conceptual trouble with it - if i have a pure function, how can i call java functions with confidence?
17:21:55 <dibblego> otherwise, it's all bets are off
17:22:02 <dibblego> by praying
17:22:04 <blackdog> it's like being mostly virginal
17:22:07 <luite> blackdog: dunno, the main thing I see is that there are so many ways of doing things, that look totally different.
17:22:16 <blackdog> or only a bit pregnant
17:22:24 <dibblego> I agree, and more and more scala users are starting to as well, but probably not to the extent that you and I might
17:22:30 <dmwit> blackdog: Haskell has unsafePerformIO.
17:22:34 <blackdog> luite: they seem to be on an ascending path of a kind, though
17:22:39 <luite> blackdog: like the usual strict io, lazy io, iteratee io, cps io
17:22:50 <luite> and for concurrency at least as many
17:22:58 <luite> and that's just the "low level" things
17:23:34 <blackdog> dmwit: sure. but at least when you use a package that presents a pure interface, there's a proof obligation on the library author
17:23:49 <blackdog> if you call a java library, then it may not even be clear what it promises to do
17:23:57 <dibblego> having unsafePerformIO is very different to not having safePerformIO
17:25:28 <dibblego> Runar Bjarnason implemented IO/IORef, ST/STRef for Scala
17:26:11 <dibblego> I am currently using iteratees for database access in Scala -- I intend to wrap the existing Java database library (JDBC) with IO, then iteratees on top
17:26:16 <blackdog> dibblego: it would be hard to enforce a rule that you only talk to java code through IO, wouldn't it?
17:26:23 <blackdog> maybe i'm fretting unnecessarily
17:26:25 <dibblego> yes, you have to "volunteer"
17:26:31 <dibblego> no, you aren't -- it's very warranted
17:26:44 <dibblego> but you are alone (with me and a few others) in this apprehensio
17:26:50 <erikde> :-)
17:27:02 <dmwit> Is there an XML parser that preserves location information (i.e. that reports non-essential white-space)?
17:27:02 <dibblego> think of the people who come by here and ask "how do I get t out of IO t?"
17:27:04 <blackdog> i'll continue to wear the hairshirt then;)
17:27:13 <dibblego> those people, given Scala, wouldn't ever arrive at that question
17:27:23 <ivanm> dibblego: because scala uses purity by contract rather than by types?
17:27:31 <dibblego> it uses purity by lol
17:27:32 <dmwit> Specifically, one where I can make roundtripping through the parse/pretty-print phase be the identity?
17:27:36 <ivanm> dibblego: heh
17:27:45 <dibblego> the suggestion that scala encourages functional programming is laughable
17:27:48 <ben> (What's a hairshirt?)
17:27:53 <aristid> dmwit: i think xml-enumerator by default preserves everything
17:28:02 <ivanm> ben: a famous paper by SPJ "Wearing the hair shirt"
17:28:10 <dmwit> thanks
17:28:11 <ivanm> refers to all the "hard parts" of Haskell: Monads, etc.
17:28:17 <ivanm> @google wearing the hair shirt
17:28:18 <lambdabot> http://en.wikipedia.org/wiki/Cilice
17:28:18 <lambdabot> Title: Cilice - Wikipedia, the free encyclopedia
17:28:22 <ivanm> umm... no
17:28:25 <ivanm> @google wearing the hair shirt simon peyton jones
17:28:26 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-retrospective/HaskellRetrospective.pdf
17:28:26 <lambdabot> Title: Wearing the hair shirt Wearing the hair shirt
17:28:26 <blackdog> http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-retrospective/
17:28:48 <blackdog> ivanm: #haskell, where your questionsa are answered in glorious stereo
17:28:54 <djahandarie> @google tackling the awkward squad
17:28:55 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf
17:28:55 <lambdabot> Title: Tackling the Awkward Squad: monadic input/output, concurrency, exceptions, and f ...
17:28:57 <djahandarie> Is another nice paper.
17:29:27 <dmwit> "Cilice" is actually quite relevant.
17:29:36 <ben> English is not my first language, I assume the hair shirt is a metaphor for something uncomfortable that you voluntarily accept?
17:29:46 <dmwit> Yes.
17:29:46 <ivanm> ben: yup
17:29:50 <ivanm> more stereo!
17:29:56 <ben> I see, cheers :)
17:30:26 <solrize> ben, Cilice explains what it is literally
17:30:33 <solrize> http://en.wikipedia.org/wiki/Cilice
17:30:45 <djahandarie> @quote Cale fugue
17:30:45 <lambdabot> No quotes match. Where did you learn to type?
17:30:48 <djahandarie> Damn
17:30:51 <ivanm> @quote fugue
17:30:51 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
17:30:52 <ben> I did not want to assume that was all there is to it :)
17:30:57 <djahandarie> Ah, it was monocrhom...
17:31:05 <ivanm> @quote metastereo
17:31:05 <lambdabot> lambdabot says: omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
17:32:34 <dmwit> Well, now we know there's at least one meta-metastero quote being @remembered.
17:32:39 <ben> I was about to say.
17:33:12 * dmwit introduces impredicative stereos
17:33:25 <ivanm> dmwit: wouldn't it only be meta-meta-stereo if it was being said by multiple people at the same time?
17:33:43 <dmwit> Any comment about metastereo comments is meta-metastereo.
17:33:49 <dmwit> "meta" means "about", basically
17:33:50 <ben> No, it's meta-(meta stereo), not meta-meta stereo
17:34:06 <ben> :)
17:34:20 <ivanm> ben: heh
17:34:22 <olsner> ben: is that a meta-meta comment?
17:34:33 <ben> Can we just say it's an untyped comment
17:34:41 <ivanm> dmwit: yeah, I know... but didn't meta-stereo come about because people talked about stereo in stereo?
17:36:58 <solrize> http://hpaste.org/paste/47373/mvar_select_annotation_anno#p47379   fwiw
17:38:44 <solrize> i guess that's still no good i have to be able to turn listeners on and off separately.  STM here i come.
17:38:55 <dmwit> solrize: I had another idea, if you're interested.
17:39:03 <solrize> sure
17:39:14 <dmwit> Let each node have four MVars (one for each direction).
17:39:21 <solrize> ok
17:39:24 <dmwit> The content of this MVar is another MVar for neighbors to write to.
17:39:35 <solrize> ok
17:39:38 <solrize> yeah, hmm
17:39:43 <dmwit> When you want to block on a subset of directions, allocate a fresh MVar and stuff it in those MVars.
17:39:57 <dmwit> (But don't touch the other directions.)
17:40:04 <solrize> hmm
17:40:13 <dmwit> When you want to send, read the node's MVar for that direction, and write to the MVar you get out.
17:41:04 <Balahla> Hey guys! What about this? "Currently, there is a bug that prevents you to install gtk on the version 2011.2.0.0 of the Haskell Platform. You must use an older version of the platform (2010.2.0.0 works)."
17:41:14 <Balahla> I took it from: http://deltadiaz.blogspot.com/2011/03/on-windows-how-to-install-gtk.html
17:41:23 <monochrom> yes, it is right
17:42:10 <Balahla> I've tried countless times to install...
17:42:12 <ben> http://hpaste.org/47381 <- what's a better way to count how often each letter appears in a text file? i feel this program is somewhat abusive
17:42:12 <solrize> dmwit yeah that sounds like it should work
17:42:16 <solrize> thanks
17:42:39 <solrize> ben, yucch!
17:42:55 <ben> yucch indeed
17:43:12 <c_wraith> that STRef is doing approximately nothing for you...
17:43:18 <c_wraith> well, that use of it.
17:43:18 <dmwit> accumArray
17:43:24 <monochrom> if you use Data.Map, you don't need ST
17:43:31 <solrize> can't you do a fold over the file?
17:44:06 <dmwit> :t \s -> accumArray (+) 0 ('a', 'z') . flip zip 1
17:44:07 <lambdabot> forall t e. (Num e, Num [e]) => t -> [Char] -> Array Char e
17:44:08 <ben> It seemed kinda wrong to rebuild most of the map every time I just want to increase the counter
17:44:19 <dafis> ben: accumArray, filter isAlpha, map toUpper
17:44:28 <scooty-puff> is there a MonadLogic or MonadPlus instance that can work in the face of MonadFix-like recursion?
17:44:32 <dmwit> :t \s -> accumArray (+) 0 ('a', 'z') (zip s (repeat 1))
17:44:33 <lambdabot> forall e. (Num e) => [Char] -> Array Char e
17:44:43 <dmwit> ben: That one-liner looks like "count" to me.
17:44:55 <dmwit> Though maybe you should throw a (map toLower s) in front of that zip or something.
17:45:18 <dafis> dmwit: he counts upper case
17:45:29 <dmwit> ('A', 'Z'), then
17:45:47 <dmwit> I doubt his preference for upper-case is fundamental.
17:45:48 <dafis> and a filter isAlpha
17:45:58 <ben> accumArray looks like cheating.
17:46:04 <dafis> probably not, one of two natural choices
17:46:15 <dmwit> Doesn't accumArray do the filtering already?
17:46:18 <dafis> ben: why cheating?
17:46:56 <dmwit> Oh, crap, also, this accumArray doesn't really handle all alphabetic characters.
17:47:02 <dafis> dmwit: I'm not sure, but I think it might throw an error on a nonexistent index
17:47:06 <dmwit> Unicode is the future, and I still haven't gotten used to it.
17:47:39 <monochrom> insertWith is like accumArray. there is also insertWith'
17:47:43 <ben> dafis: My original goal was to come up with a concise haskell-y way to do it, I'm not convinced accumArray doesn't just do some imperative magic internally.
17:47:52 <ben> much like I ended up doing, I suppose
17:47:57 <c_wraith> accumArray does imperative magic internally.
17:48:00 <c_wraith> It just does it *well*
17:48:09 <dafis> ben: but only one STArray
17:48:10 <ben> I figure it's most of the point of the array module
17:48:28 <ben> dafis: Yeah, let's pretend I need unicode letters for the sake of the argument :>
17:48:29 <monochrom> fromListWith is even closer to accumArray
17:48:36 <dmwit> ben: You're already using ST anyway...
17:49:03 <ben> dmwit: Oh,I'm not saying that my solution is better by any means
17:49:12 <ben> It's just that looking at accumArray does not enlighten me
17:49:23 <c_wraith> :t M.fromListWith
17:49:24 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> M.Map k a
17:49:44 <c_wraith> yeah, looks like fromListWith also makes it a one-liner
17:50:15 <dafis> ben: foldl' (\m c -> insertWith' (+) c 1 m) empty . map toUpper . filter isAlpha
17:50:26 <c_wraith> though it's certainly not strict in the values, which is annoying
17:51:04 <monochrom> yeah, foldl' and insertWith' in case you are dissatisfied with fromListWith
17:51:05 <dmwit> :t foldb
17:51:06 <lambdabot> Not in scope: `foldb'
17:51:08 <dmwit> bleh
17:51:10 <c_wraith> :t M.fromListWith (+) . flip zip (repeat 1) . filter isAlpha
17:51:11 <lambdabot> forall a. (Num a) => [Char] -> M.Map Char a
17:51:25 <c_wraith> whoops, forgot the toUpper
17:52:04 <ben> Apparently I started out with the preconception that manipulating a map is not something I want to do every time I read a new character
17:52:18 <ben> I'm still trying to wrap my head around the fromListWith solution
17:52:32 <dmwit> :t let foldb :: (a -> a -> a) -> [a] -> [a] in \s -> foldb (M.unionWith (+)) [M.singleton (toUpper c, 1) | c <- s, isAlpha c]
17:52:32 <lambdabot>     The type signature for `foldb' lacks an accompanying binding
17:52:33 <lambdabot> Not in scope: `foldb'
17:52:33 <c_wraith> just look at the source for fromListWith
17:52:44 <dmwit> :t let foldb :: (a -> a -> a) -> [a] -> [a]; foldb = undefined in \s -> foldb (M.unionWith (+)) [M.singleton (toUpper c, 1) | c <- s, isAlpha c]
17:52:45 <lambdabot>     Couldn't match expected type `M.Map k a'
17:52:45 <lambdabot>            against inferred type `a1 -> M.Map (Char, t) a1'
17:52:45 <lambdabot>     In the expression: M.singleton (toUpper c, 1)
17:53:01 <dmwit> :t let foldb :: (a -> a -> a) -> [a] -> [a]; foldb = undefined in \s -> foldb (M.unionWith (+)) [M.singleton (toUpper c) 1 | c <- s, isAlpha c]
17:53:01 <lambdabot> forall a. (Num a) => [Char] -> [M.Map Char a]
17:53:08 <ben> Oh, I see.
17:53:11 <monochrom> > Map.fromListWith (+) [('k', 4), ('b', 2), ('k', 5)]
17:53:12 <lambdabot>   Not in scope: `Map.fromListWith'
17:53:18 <monochrom> > M.fromListWith (+) [('k', 4), ('b', 2), ('k', 5)]
17:53:18 <lambdabot>   fromList [('b',2),('k',9)]
17:53:27 <monochrom> that is what fromListWith does
17:53:31 <ben> Cheers
17:54:10 <hpc> fromList = fromListWith const?
17:54:21 <monochrom> so you need [('k', 1), ('b', 1), ('k', 1)] which is zip "kbk" (repeat 1) for mere counting
17:57:09 <Taslem> I have a Haskell program with apparently deep recursion. There ae a couple functions which recursively call each other.
17:57:26 <Taslem> However, suspension hangs, it looks like it's an infinite recursion.
17:58:00 <Taslem> The problem is that I've imported Debug.Trace and added a trace "X" $ to every one of their lines, and it doesn't show looping at all... It just stops.
17:58:18 <monochrom> try to prove termination. the attempt will reveal what goes wrong
17:58:40 <Taslem> What exactly do you mean?
17:59:56 <monochrom> I mean try to prove termination, and you will get stuck, and the point of getting stuck points out why you have an infinite loop
18:00:15 <Taslem> Well, but that's not the whole problem.
18:00:32 <Taslem> The other problem is that it's hanging, but I should be getting a steady stream of output from the trace calls.
18:00:41 <c_wraith> that's a silly assumption
18:00:47 <Taslem> Why?
18:01:00 <Taslem> Every single one of the expressions in these functions has a trace call.
18:01:05 <c_wraith> > let x = x in x
18:01:09 <lambdabot>   mueval-core: Time limit exceeded
18:01:14 <Taslem> Every single one of the expressions in these functions has a trace call.
18:01:23 <c_wraith> If you were to trace that, you would get exactly one trace output line
18:01:33 <Taslem> I don't think so.
18:01:37 <c_wraith> try it
18:01:53 <Taslem> Just di. I'm right.
18:01:56 <dafis> Taslem: depending on how exactly the trace calls look, they might only produce output the first time they're reached
18:02:00 <Taslem> It produces a constant stream...
18:02:11 <Taslem> What circumstance would prevent it from being shown?
18:02:15 <Taslem> I've never seen that before...
18:02:26 <dmwit> It doesn't produce a steady stream here.
18:02:37 <mjrosenb> > f a
18:02:39 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:02:39 <lambdabot>    `GHC.Show.Show a'
18:02:39 <lambdabot>      a...
18:02:40 <dmwit> main = trace "foo" main -- this just prints "foo" once, and then hangs.
18:02:45 <mjrosenb> > f x
18:02:46 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:02:46 <lambdabot>    `GHC.Show.Show a'
18:02:46 <lambdabot>      a...
18:02:50 <mjrosenb> > f 1
18:02:51 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:02:51 <lambdabot>    `SimpleReflect.FromExpr ...
18:02:59 <Taslem> > let f x = trace "s" (f x) in f 3
18:03:00 <lambdabot>   Not in scope: `trace'
18:03:09 <c_wraith> that's not what I said.
18:03:18 <c_wraith> *Main Debug.Trace> let x = trace "x" x in x
18:03:18 <c_wraith> x
18:03:18 <c_wraith> ^CInterrupted.
18:03:19 <ski> > f x :: Expr
18:03:19 <lambdabot>   f x
18:03:27 <c_wraith> I waited quite a long time
18:03:34 <ski> > (f x :: Expr -> Expr) 0
18:03:35 <lambdabot>   f x 0
18:03:40 <dmwit> A long time -- entire seconds!
18:03:43 <c_wraith> yes
18:03:47 <mjrosenb> ahh
18:03:51 <mjrosenb> > f x :: Expr
18:03:53 <lambdabot>   f x
18:03:56 <c_wraith> for a computer, seconds are very far apart. :)
18:04:00 <dmwit> indeed
18:04:02 <monochrom> Taslem: here is a counterexample: http://hpaste.org/47382/one_trace
18:04:06 <ben> How much heap allocation is it gonna require to insertWith' into a map with n keys?
18:04:07 <ski> > foldr f x [a,b,c] :: Expr
18:04:08 <lambdabot>   f a (f b (f c x))
18:04:20 <mjrosenb> scanl f 1 [x,y,z] :: [Expr]
18:04:20 <c_wraith> ben: a fair amount
18:04:29 <mjrosenb> > scanl f 1 [x,y,z] :: [Expr]
18:04:30 <lambdabot>   [1,f 1 x,f (f 1 x) y,f (f (f 1 x) y) z]
18:04:37 <ben> How comes it is so much faster than my silly ST example then? :)
18:04:40 <c_wraith> ben: O (log n), generally
18:04:45 <Taslem> monochrom: That isn't a counteraxmple for me...
18:04:51 <dmwit> ben: Reading and writing STRef's isn't free.
18:04:52 <ski> > scanl1 f [x,y,z]
18:04:53 <lambdabot>   [x,f x y,f (f x y) z]
18:05:07 <Taslem> monochrom: At least, the 'u' by itself isn't. These functions are totally pure.
18:05:08 <c_wraith> ben:  because the ST example had that same O(log n) factor for lookups
18:05:23 <monochrom> u is totally pure
18:05:40 <Taslem> And when run produces many traces, not one.
18:05:46 <drhodes> what if Taslem make his data constructors strict, would that force the trace to be evaluated?
18:05:47 <dmwit> u is pure... modulo trace =P
18:06:04 <dmwit> Taslem: Just paste your contentious code already.
18:06:07 <ben> dmwit: It seems like it should be relatively free! What is the actual cost?
18:06:23 <monochrom> Taslem: here is an improved counterexample: http://hpaste.org/paste/47382/one_trace_annotation#p47383
18:06:30 <Taslem> http://hpaste.org/47384/t
18:06:33 <ben> c_wraith: I'm amazed the lookup is significant compared to allocating memory to make a new map.
18:06:33 <monochrom> one "trace" then hangs
18:06:50 <Taslem> Oh, I see. That's good.
18:06:54 <c_wraith> ben: allocating in GHC is *fast*.  The entire memory system is designed for it.
18:07:12 <c_wraith> ben: mutating is actually slow in GHC, because of the impact it has on the memory system.
18:07:29 <ben> Hm.
18:07:44 <ben> In the least-"how was i supposed to know that" way possible, what should I have been reading to be aware of that? :)
18:08:32 <c_wraith> it's kind of a secret.  Most of what I know, I picked up from the recent paper on experimental multi-core allocation systems for future versions of GHC. :)
18:08:50 <dafis> Taslem: (l,s) = trace "CD" $ parseLiteral s
18:08:53 <dafis> loop
18:09:02 <c_wraith> ben:  http://community.haskell.org/~simonmar/papers/local-gc.pdf
18:09:03 <dafis> probably
18:09:09 <ben> Thanks
18:09:12 <Taslem> Yes, that is. Conflicting var names.
18:09:40 <c_wraith> don't be afraid of the fact that it's formatted as a research paper.  The Simons both produce quite readable papers.
18:09:44 <ben> I guess I should just keep reading papers written by people named Simon in order to attain enlightenment.
18:09:57 <c_wraith> It helps :)
18:10:01 <ben> I've looked at a few before, they seem very readable. :)
18:10:56 <solrize> http://en.wikipedia.org/wiki/Simon_and_Simon
18:12:07 <ben> I'm gonna set up ghci to play http://www.youtube.com/watch?v=IDhz_mVcVCQ when I start it up. That'll help, I bet.
18:13:26 <ben> (The fromListWith solution's memory usage balloons until a stack overflow eventually :3)
18:13:34 <ben> (Doesn't look like there's a knob to turn to make it stricter?)
18:13:49 <c_wraith> yeah, fromListWith is just not going to do the job for you, in this case.
18:13:57 <monochrom> no, so you should use foldl' and insertWith'
18:14:09 <ben> Yeah
18:14:15 <c_wraith> The fact that there's no value-strict version of Data.Map is annoying.
18:14:31 <hpc> write one
18:14:35 <hpc> Data.Map.Strict
18:14:49 <c_wraith> Heh.  I've been toying with ideas for it.
18:15:00 <c_wraith> Except in the context of my lrucache package
18:15:21 <monochrom> fromListWith already uses foldl' but still insertWith
18:15:23 <ben> There is so much to learn until I am going to feel comfortable making all the necessary design choices to writing actual applications in haskell :(
18:15:24 <c_wraith> It's really difficult to share code efficiently.
18:16:51 <parcs> c_wraith: why don't you use another container such as Data.HashMap.Strict?
18:17:30 <c_wraith> parcs: the context is "providing versions of lrucache that are both strict an non-strict in the value"
18:17:40 <c_wraith> parcs: such that whatever backing store I use doesn't matter.
18:18:22 <monochrom> it should be easy to steal the Data.Map code and just add one more bang in "data Map k v = ..."
18:18:56 <monochrom> so easy that I won't do it, ha!
18:19:00 <c_wraith> Yes, but then you're not sharing code..
18:19:04 <c_wraith> You're duplicating it.
18:19:07 <c_wraith> So ew.
18:19:37 <c_wraith> Also, doing the whole thing properly would allow a large de-duplication effort.  Most of the foo' functions in Data.Map would go away.
18:20:01 <dmwit> Map Key Int# -- ;-)
18:40:50 * hackagebot accentuateus 0.9.4 - A Haskell implementation of the Accentuate.us API.  http://hackage.haskell.org/package/accentuateus-0.9.4 (MichaelSchade)
18:56:40 <synonymous> If I have functions
18:56:40 <synonymous> f :: a -> b -> c -> d
18:56:40 <synonymous> g :: [d] -> [e]
18:56:40 <synonymous> foo a1 b1 c1 = g $ zipWith3 f a1 b1 c1
18:56:40 <synonymous> Can I simplify foo to something similar to the following:
18:56:40 <synonymous> foo = g $ zipWith3 f
18:56:41 <synonymous> ?
18:58:05 <parcs> ((g .) .) . zipWith3 f
18:58:26 <shachaf> @pl foo a1 b1 c1 = g $ zipWith3 f a1 b1 c1
18:58:26 <lambdabot> foo = ((g .) .) . zipWith3 f
19:00:31 <parcs> :t (.::)
19:00:31 <lambdabot> Not in scope: `.::'
19:00:40 <Axman6> shachaf: you can, but don't
19:00:43 <Axman6> uh, synonymous
19:01:29 <synonymous> parcs, shachaf: Heh not sure which one's simpler, but thanks
19:01:37 <synonymous> Axman6: agreed
19:01:41 <parcs> synonymous: check out the functors package
19:01:53 <parcs> it has the useful .: and .:: operators
19:02:05 <Axman6> :t (.::)
19:02:06 <lambdabot> Not in scope: `.::'
19:02:09 <Axman6> :(
19:02:37 <synonymous> shachaf: what's does the pl command to?
19:04:27 <synonymous> parcs: i will, thanks
19:04:48 <nihtml> pl is pointless command
19:06:13 <isomorphic> synonymous: http://www.haskell.org/haskellwiki/Pointfree
19:06:31 <synonymous> isomorphic: yup reading it already
19:07:13 <lispy> ezyang: ping?
19:07:40 <lispy> preflex: seen ezyang
19:07:41 <preflex>  ezyang was last seen on #haskell 1 day, 4 hours, 46 minutes and 4 seconds ago, saying: GHC Haskell, at least.
19:07:47 <lispy> ah hmmm
19:10:37 <synonymous> parcs: which package exactly were you talking about? would you have a link?
19:11:04 <parcs> @hackage functors
19:11:04 <lambdabot> http://hackage.haskell.org/package/functors
19:11:22 <lispy> I need to build both dynamic and static libraries on osx.  I seem to recall having an issue with this last time where if you build both then you really end up with one of the two.  It was something like, both endup static or both endup dynamic.
19:11:26 <lispy> Anyone know how this works?
19:12:27 <parcs> you mean through cabal?
19:12:40 <lispy> I have to use a makefile for this
19:12:53 * hackagebot GLFW-b 0.0.2.6 - GLFW bindings  http://hackage.haskell.org/package/GLFW-b-0.0.2.6 (BrianLewis)
19:12:59 <lispy> Cabal/GHC have bugs that work together to make it so I can't use cabal
19:13:22 <lispy> That was fast, I sent BrianLewis a pull request about 10 minutes ago :)
19:14:20 <dafis64bit> Shit! All those years, I've had a 64-bit machine and never knew. Why didn't they brag about it, it was not quite an everyday thing when I bought this box, aargh
19:14:43 <lispy> I think I have to do this weird thing where I build the .a and the .dylib in different dirs and then make sure that ghci looks in a different place than ghc.
19:14:54 <dmwit> Hm, I'm trying to watch some files with hinotify, and it only seems to be catching the first change to the file.
19:15:07 <tg_> dafis64bit: with my luck, they'll come out with a 65 bit machine the day after
19:15:10 <dmwit> Has anybody else used hinotify (successfully)?
19:15:17 <lispy> dmwit: nope :(
19:15:34 <dmwit> lispy: Oh dear. Does that mean you've used it unsuccessfully?
19:15:39 <lispy> Nope
19:15:44 <dmwit> oh, phew
19:15:47 <lispy> It means I've never even tried it
19:15:48 <dmwit> There's still hope, then. =P
19:15:53 <lispy> Sorry for the ambiguity :)
19:15:54 <tg_> nope
19:16:08 <tg_> sounds like tripwire
19:17:53 <tg_> Is that like a giant karaoke machine? Not really. Would you like to see our giant karoake machine? Not really.
19:21:15 * lispy has to leave now
19:21:37 <lispy> If anyone has experience with this dual library building for the sake of ghci on osx, please ?tell lispy about it
19:21:39 * lispy waves
19:22:50 * dafis64bit goes back to 32 bits until there's enough time to do a complete reinstall, sigh
19:23:03 <Balahla> Hey guys! I've got to install gtk2hs!
19:23:10 <Balahla> It worked!
19:23:44 <Balahla> Guess what? It is not just the Platform version issue.
19:24:16 <Balahla> The problem was (also) that I was updating Cabal.
19:26:02 <dmwit> Haha, I figured it out.
19:26:33 <dmwit> hinotify doesn't spawn new threads for each action, and the action I passed it was blocking, so it never got back to the inotify loop.
19:26:37 <dmwit> That seems like a bug.
19:32:53 * ddarius hates it when he experience reality out of chronological order.
19:33:41 <djahandarie> How does that work?
19:33:50 <djahandarie> (Besides a large amount of drugs...)
19:35:36 <ddarius> It just happens sometime.  Probably more often than I notice.
20:13:54 <Jafet> Re: value strictness in data structures, wouldn't it work to make them strict by default? data List a = Nil | Cons {-# UNPACK #-} !a (List a); data Unstrict a = Unstrict a; type StrictList a = List a; type NonstrictList a = List (Unstrict a)
20:14:47 <ivanm> Jafet: so using unstrict would get you spine-strict but value-lazy ?
20:15:08 <Jafet> Uh List isn't spine-strict
20:16:05 <ddarius> Jafet: Yes, that would work.
20:16:27 <ddarius> But UNPACK doesn't work with polymorphic components.
20:16:35 <Jafet> Good point though, perhaps that could also be parametrizeable: data List a spine = Nil | Cons !a !(spine (List a))
20:16:46 <ddarius> (Unless things have changed since lastt I looked, which was a long time ago.{
20:16:59 <Jafet> ddarius: how polymorphic?
20:17:24 <ivanm> oh, mis-understood how UNPACK works
20:18:15 <Jafet> ddarius: do you mean things like List (Ctx a => a)
20:18:30 <ddarius> No, I mean the UNPACK pragma you wrote does nothing.
20:18:51 <Jafet> Oh. That's a shame
20:19:20 <Jafet> (It would also explain why the last program I wrote used more memory than I thought)
20:19:53 <jmcarthur> i wish UNPACK meant the structure would be specialized for different type parameters when possible
20:42:49 <romildo> Hi.
20:43:45 <romildo> Is there a function in the Haskell libraries to repeatedly apply a function to some data while a condition is met?
20:44:07 <ddarius> :t until
20:44:08 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
20:44:52 <ivanm> romildo: head . dropWhile (not . p) . iterate f
20:45:10 <ivanm> ddarius: oh, didn't know about until :s
20:45:13 <ivanm> @index until
20:45:13 <lambdabot> Prelude
20:45:16 <ivanm> huh...
20:45:29 <ivanm> I guess I can stop using iterate like I currently do then... >_>
20:45:32 <ivanm> @src until
20:45:33 <lambdabot> until p f x | p x       = x
20:45:33 <lambdabot>             | otherwise = until p f (f x)
20:46:11 <romildo> ddarius, thanks
20:46:39 <dmwit> ?src while
20:46:39 <lambdabot> Source not found. My brain just exploded
20:46:51 <dmwit> while p = until (not . p)
20:48:24 <tsuraan_> I'm almost sure I read a thread on cafe recently that was discussing a data.bits implementation for bytestring.  does that sound familiar to anybody? I'm not having any luck finding it
20:50:08 <ivanm> doesn't sound that familiar...
20:50:43 <ivanm> and searching for "data.bits bytestring" sans quote in gmail doesn't bring anything likely up
20:50:53 <tsuraan_> yeah, not for me either :-/
20:51:09 <tsuraan_> I wonder where I saw it.  must be going crazy
20:51:22 <ivanm> IIUC, would that make sense? doesn't Data.Bits work on a single "bit" ?
20:51:41 <tsuraan_> I think it's for ordered collections of bits
20:51:58 <tsuraan_> it defines implementations for Int and Integer
20:52:23 <tsuraan_> heck, Integer isn't even bounded, is it?  I wonder how rotate works there
20:52:51 <tsuraan_> nm, the docs says it's the same as shift for unbounded types
20:53:27 <Axman6> how have i never seen until before now
20:53:44 <ivanm> hmmm.....
20:54:13 <dmwit> :t M.insert
20:54:14 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
20:54:21 <dmwit> :t uncurry M.insert
20:54:22 <lambdabot> forall a b. (Ord a) => (a, b) -> M.Map a b -> M.Map a b
20:54:26 <dmwit> :t foldr
20:54:27 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:54:47 <ivanm> > let collatz = let step n = if even n then n`div`2 else 3*n+1 in until (==1) step 53
20:54:47 <lambdabot>   not an expression: `let collatz = let step n = if even n then n`div`2 else ...
20:54:58 <ivanm> > let collatz = let step n = if even n then n`div`2 else 3*n+1 in until (==1) step in collatz 53
20:54:58 <lambdabot>   1
20:55:13 <ivanm> > let collatz = let step n = if even n then n`div`2 else 3*n+1 in until (==1) step in collatz 847243
20:55:13 <lambdabot>   1
20:55:16 <ivanm> :D
20:55:19 <Axman6> :t \f -> uncurry . uncurry f
20:55:20 <lambdabot> forall a b c a1 b1. (a1 -> b1 -> a -> b -> c) -> (a1, b1) -> (a, b) -> c
20:55:20 <ivanm> @botsnack
20:55:20 <lambdabot> :)
20:55:35 <Axman6> :t uncurry . uncurry
20:55:36 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> ((a, b1), b) -> c
20:56:10 <ivanm> @pl \((a,b),(c,d)) -> f a b c d
20:56:10 <lambdabot> uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . f))
20:56:17 <ivanm> @pl \f ((a,b),(c,d)) -> f a b c d
20:56:17 <lambdabot> (`ap` snd) . (. fst) . (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .)
20:56:30 <ivanm> OK, no nice nested uncurry stuff happening there... :s
21:11:18 * hackagebot wai-app-file-cgi 0.2.1 - File/CGI App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.2.1 (KazuYamamoto)
21:13:18 * hackagebot mighttpd2 2.2.1 - A classical web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.2.1 (KazuYamamoto)
21:20:20 <tsuraan_> is there a page that documents all the ST-related modules?  I've found Control.Monad.ST and Data.STRef so far, but I'm wondering if I'm missing things
21:20:41 <Axman6> there's also Data.Array.ST i believe
21:20:45 <Axman6> that's about it though i think
21:20:56 <tsuraan_> ok
21:24:24 <Axman6> :t (=>>)
21:24:25 <lambdabot> Not in scope: `=>>'
21:24:47 <dibblego> (w a -> b) -> w a -> w b
21:25:19 * hackagebot representable-functors 0.4.4 - Representable functors  http://hackage.haskell.org/package/representable-functors-0.4.4 (EdwardKmett)
21:26:20 * hackagebot representable-tries 0.3.7 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-0.3.7 (EdwardKmett)
21:27:49 <ivanm> tsuraan_: and then individual libraries that might use ST (e.g. mwc-random)
21:29:02 <tsuraan_> is there some way to get hoogle to give functions that use ST?
21:29:24 <tsuraan_> just typing ST into the field gives a lot of junk (but also some good stuff)
21:30:12 <Jafet> @hoogle ST s a
21:30:13 <lambdabot> Did you mean: :: ST s a /count=20
21:30:13 <lambdabot> module System.Mem.StableName
21:30:13 <lambdabot> module Foreign.StablePtr
21:30:46 <tsuraan_> cool
21:30:57 <tsuraan_> @hoogle :: ST s a
21:30:57 <lambdabot> Control.Monad.ST fixST :: (a -> ST s a) -> ST s a
21:30:58 <lambdabot> Control.Monad.ST.Lazy fixST :: (a -> ST s a) -> ST s a
21:30:58 <lambdabot> Data.STRef readSTRef :: STRef s a -> ST s a
21:31:19 <tsuraan_> well, the page gave quite a few more hits.   Thanks!
21:55:09 <minsa> test
21:55:32 <NemesisD> i'm looking for some guidance on the "right" way to set up test suites. Should i keep tests in modules that mirror the structure of the project?
21:56:15 <NemesisD> i.e. to test MyLib.Foo, i create a module Test.MyLib.Foo which exports a tests array, main imports it and runs them with HUnit
21:57:08 <ivanm> *shrug* depends on how you want it
21:57:23 <ivanm> I tend to have all my testing stuff for graphviz in Data.GraphViz.Testing for example
21:57:34 <ivanm> but that's because everything else is within that module namespace
21:59:49 <NemesisD> ivanm: and from the root do you keep that in Data/GraphVis/Testing/FooTests.hs ?
21:59:58 <ivanm> yup
22:00:14 <ivanm> some people like to have src/ tests/ etc. sub-folders
22:00:24 * hackagebot wai-app-file-cgi 0.2.2 - File/CGI App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.2.2 (KazuYamamoto)
22:00:36 <ivanm> I tend not to, but that's because my code typically all falls within the same module namespace *shrug*
22:00:38 <NemesisD> ivanm: yeah thats what i'm used to in other languages, wasn't sure if that would be a problem since the directories would not match the module name
22:00:47 <ivanm> (the exception being various helper scripts, etc. for dev purposes)
22:00:51 <aavogt> ivanm: how do you deal with testing things that are internal (subject to change)?
22:01:11 <NemesisD> yeah i usually have everything under one namespace module too
22:01:13 <ivanm> NemesisD: well, in your .cabal file you can specify which directory your source is in, etc.
22:01:38 <ivanm> aavogt: well, almost all of graphviz is exposed
22:01:46 <ivanm> the only things that aren't are helper functions, etc.
22:02:05 <aavogt> right, what do you do if there's a direct way to test those pieces?
22:02:14 <ivanm> and the test suite is currently built _with_ the library itself; you can't just get the sources and build it yourself using an installed graphviz
22:02:43 <ivanm> aavogt: currently, the test-suite is primarily to ensure that parse . print == id
22:03:05 <ivanm> all using QC
22:03:41 <ivanm> as well as another script I run that is used just to ensure that it can parse "real world" Dot code
22:04:22 <NemesisD> hmm. yeah i remember last i looked at cabal's test suite, they had only basic support for testing based on stdio exit code
22:05:02 <ivanm> oh, the inbuilt stuff?
22:05:11 <ivanm> yeah, I haven't looked into porting my stuff over to that yet
22:05:23 <ivanm> but IMHO no-one else who isn't hacking on graphviz itself should be running the test suite
22:05:28 <ivanm> it takes long enough as it is :s
22:12:01 <NemesisD> ivanm: do you name your testing modules the same as the modules you're testing or if you're testing Foo, is the module Testing.FooTests
22:19:24 <ivanm> no, I have one overall test suite for the entire project
22:20:51 <accel> I can grab the environemnt varaible with 'homeDir <- getEnv "HOME" '; Question: is there a wya to change this so it's evaluated at compile time, rather than execution time?
22:21:36 <mauke> whoa. why?
22:21:50 <accel> because if I do it at compile time, it's a single STRING
22:21:56 <accel> rather than a bunch of IO() all over the place
22:22:03 <accel> s/STRING/String/
22:24:11 <ion> homeDir is a single String.
22:25:57 <dankna> um, you really, really don't want to do it at compile-time
22:26:01 <accel> why not?
22:26:07 <dankna> because the semantics are different
22:26:11 <accel> ?
22:26:11 <dankna> if the current user changes
22:26:13 <dankna> or the machine changes
22:26:18 <dankna> or the directory layout changes
22:26:18 <accel> that's fine
22:26:21 <dankna> it will return the old value
22:26:25 <accel> that's okay
22:26:34 <dankna> I try not to rush to judgement but I find it hard to conceive of a program for which that behavior is okay
22:26:40 <accel> I just want to have homeDir :: String
22:26:45 <accel> in the file, so I can use it in othe rparts of the code
22:26:50 <accel> instead o ahving to pass it around all the time
22:27:07 <dankna> well, of course there's unsafePerformIO
22:27:11 <dankna> which will do it at runtime
22:27:20 <accel> was it built to solve similarly ugly problem?
22:27:24 <dankna> mind you, you could do it at compile-time with Template Haskell
22:27:34 <dankna> no, honestly, this is not an ugly problem - get used to having to pass it around, is my advice
22:27:41 <dankna> use a monad if you must
22:28:07 <dankna> or
22:28:11 <dankna> if doing it at compile-time is okay
22:28:16 <dankna> then so is doing it at author-time :)
22:28:22 <dankna> homeDir = "/Users/dankna/"
22:28:37 <accel> I have a Mac and linux box
22:28:37 <dankna> (note that this won't work on your machine, because that's /my/ home directory, but you said that was fine :D)
22:28:47 <accel> I don't want to have to change it every time I switch machines
22:28:51 <dankna> O_o
22:28:55 <accel> if there's a way to say
22:28:58 <accel> homeDir = $HOME
22:29:00 <accel> I would be happy :-)
22:29:07 <dankna> yes, well, learn Template Haskell if you really insist
22:29:15 <dankna> you can run arbitrary IO from a template expression
22:29:23 <dankna> you have to put it in a separate module though
22:30:35 <dmwit> unsafePerformIO seems best here
22:30:44 <dmwit> homeDir = unsafePerformIO (getEnv "HOME")
22:31:05 <dankna> I already suggested that, he didn't seem enthused ^^'
22:31:14 <dankna> but yeah
22:34:05 <accel> dmwit , dankna : thanks :-)
22:34:28 <dankna> sure
22:34:54 <shachaf> accel: Use CPP and -DHOME=$HOME
22:37:55 <Jafet>   vc-+
22:51:34 * hackagebot json-builder 0.0 - Data structure agnostic JSON serialization  http://hackage.haskell.org/package/json-builder-0.0 (LeonSmith)
22:56:51 <dankna> hmm
22:57:09 <dankna> it would be handy to be able to throw an exception from Haskell that would cross the FFI boundary arbitrarily many times ><
22:57:25 <dankna> (if I'm calling Haskell from ObjC, from Haskell, from Objc, etc)
22:57:34 <dankna> not easy to arrange though, I think I won't worry about it for now
22:57:59 <dankna> I guess I could put every foreign export through a wrapper that potentially returns an exception instead of processing things normally
22:58:00 <dankna> but yeah
23:25:02 <dmedvinsky> hey guys
23:31:51 <pusherman> I am having trouble installing hint. The error messages says it requires ghc >6.6 which shouldn't be a problem given ghc 7.02 is currently installed so. Any ideas?
23:35:31 <Jafet> pusherman: too many. Post the build log.
23:37:16 <pusherman> Jafet: http://pastebin.com/03bCuePH
23:37:18 <mauke> The paste 03bCuePH has been copied to http://hpaste.org/47389/httppastebincom03bcueph
23:37:29 <Jafet> All hail maukebot
23:37:45 <NemesisD> question for you guys, comparePrec :: [(a -> a -> Ordering)] -> (a -> a -> Ordering). it takes a list of comparators and combines them into one, where the order in the list is the precedence
23:37:58 <NemesisD> what would the expected behavior be for an empty list. undefined or EQ?
23:38:32 <Jafet> pusherman: so your system has exactly one ghc, and it is at 7.0.2?
23:38:33 <roconnor> I wish I could specialize data types like I can functions.  when do we get supero?
23:39:12 <pusherman> Jafet: yes, I ran ghc --version to double check a thousand times
23:39:17 <mauke> NemesisD: mempty
23:39:31 <mauke> NemesisD: comparePrec = mconcat
23:39:56 <Jafet> Isn't that begging the question
23:40:07 <Jafet> I don't see which instance to use
23:40:40 <NemesisD> mauke: i don't quite think it is mconcat, won't mconcat return the last non EQ in the list?
23:40:44 <pusherman> Jafet: Just checking my vision. Is possible the cabal thinks GHC is some earlier version?
23:41:16 <Jafet> pusherman: if you have multiple GHCs, and it isn't using the one you think it is
23:41:22 <mauke> > sortBy (comparing length ++ compare) $ words "mauke: i don't quite think it is mconcat, won't mconcat return the last non EQ in the list?"
23:41:24 <lambdabot>   ["i","EQ","in","is","it","non","the","the","last","don't","list?","quite","...
23:41:50 <shachaf> That's neat.
23:42:34 <Jafet> @type (++)
23:42:35 <lambdabot> forall m. (Monoid m) => m -> m -> m
23:42:54 <Jafet> @instances Monoid
23:42:54 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
23:43:26 <NemesisD> dag burnit it is mconcat
23:43:39 <NemesisD> i felt so clever
23:44:03 <shachaf> mauke++
23:45:43 <Jafet> pusherman: at a guess, look at the versions in ghc-pkg list
23:47:06 <Jafet> Oh, it uses both the (->) and Ordering instances
