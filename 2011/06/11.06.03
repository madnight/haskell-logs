00:09:47 <lpsmith> ok, I have a question
00:10:37 <Jafet> I have a question regarding your question
00:10:57 <lpsmith> Why is it that I can pop into ghci,  and write "Data.Aeson.toJSON [1..10]" and get an answer,  whereas "Data.Json.Builder.toBuilder [1..10]" and get a type error
00:11:36 <lpsmith> now,  I can write "toBuilder ([1..10] :: [Integer])" just fine
00:12:16 <lpsmith> it doesn't make any sense to me;  I've tried adding IncoherentInstances to the language options, to no avail.
00:12:54 <ion> What are the types of toJSON and toBuilder?
00:13:47 <lpsmith> ion:   file:///home/lpsmith/.cabal/share/doc/ghc-7.0.3/aeson-0.3.2.6/html/Data-Aeson.html#t:ToJSON
00:13:59 <lpsmith> toBuilder is similar
00:14:45 <lpsmith> the issue is related to the fact that we both have   instance ToJSON a => ToJSON [a]    and instance ToJSON [Char]
00:15:00 <lpsmith> although Bryan has an instance ToJSON Char while I do not.
00:17:15 <Jafet> What's the type error, ambiguity?
00:18:32 <lpsmith> Jafet: http://hpaste.org/47390/incoherent_type_error
00:19:49 <lpsmith> Now,  unless the change didn't take and I wasn't loading the module I thought I was loading
00:20:03 <lpsmith> I tried adding Incoherent Instances to the module and it didn't work
00:20:12 <Jafet> And where is Data.Json
00:20:40 <lpsmith> http://hackage.haskell.org/package/json-builder
00:23:30 <Jafet> I would think that declaring the instances with OverlappingInstances is sufficient
00:25:39 <Jafet> Did you just copy this pragma http://hackage.haskell.org/packages/archive/aeson/0.3.2.6/doc/html/src/Data-Aeson-Types.html
00:26:46 <lpsmith> I have everything except incoherent instances, rank2types, and derivedatatypable
00:27:37 <lpsmith> http://hackage.haskell.org/packages/archive/json-builder/0.0/doc/html/src/Data-Json-Builder.html
00:27:47 <mustelo> @pl \x -> (> x) . f . g $ x
00:27:48 <lambdabot> flip (>) `ap` (f . g)
00:30:48 <lpsmith> Well, clearly the problem is that I didn't get the right module loaded for whatever reason
00:31:05 <lpsmith> It's working now when I change it to IncoherentInstances
00:31:15 <lpsmith> I'll have to ponder why that's necessary
00:34:38 <Jafet> Something to do with the fact that your instances are polymorphic
00:35:10 <Jafet> So depending on which instances are in scope, ghc might pick different ones, thus incoherent
00:36:28 <lpsmith> well, not just that,  but the example is somewhat polymorphic
00:36:37 <lpsmith> Namely it's a list of Nums
00:37:34 <lpsmith> But Char isn't a Num, but I know the GHC type system doesn't take that into account, though my understanding why is a little shaky.
00:38:03 <lpsmith> It works fine if I nail down the type to a list of Integers,  or any other specific Num
00:38:11 <merijn> Is the parsec tutorial at http://legacy.cs.uu.nl/daan/parsec.html still mostly accurate? That one seems to be for parsec2, but I can't find any for parsec3
00:40:46 <lpsmith> merijn: IIRC, yes.  Though I knew parsec 2,  and don't recall having any problem with Parsec 3.  The code was very easy to convert.
00:41:05 <lpsmith> but I'm not sure I can really answer your question,  as I lack the perspective
00:41:38 <lpsmith> parsec3 has usable haddocks,  which parsec was lacking for quite a while
00:43:19 <lpsmith> oh,  I feel a little silly.  I know why I was loading the wrong module now
00:44:11 <lpsmith> IncoherentInstances sounds a little scary though
00:44:20 <lpsmith> much more scary than UndecidableInstances :)
00:46:44 <ion> {-# LANGUAGE IncoherentLanguage #-}
00:46:45 <ion> <?php
00:46:51 <lpsmith> lol
00:47:38 <Axman6> {-# LANGUAGE EmbeddedPerl #-}
00:54:25 <mustelo> @pl \f g x -> f x (g x)
00:54:25 <lambdabot> ap
01:01:46 <erus`> whats a nice way to create a map of something -> Int
01:01:52 <erus`> just a function with gaurds?
01:05:09 <merijn> erus`: Is something a datatype?
01:05:32 <erus`> yes   data Piece = Pawn | Rook | King         etc
01:05:47 <erus`> I'm mapping Pieces to their relative pawn values
01:05:58 <erus`> im using a case at the moment
01:06:00 <merijn> erus`: For simple datatypes (like the one you jus said) you can derive Enum
01:06:08 <merijn> And then use "toEnum" and "fromEnum"
01:06:14 <merijn> > fromEnum 'a'
01:06:15 <lambdabot>   97
01:06:42 <erus`> merijn: and then data Piece Pawn = 1 | Rook = 5 ?
01:07:41 <merijn> erus`: If you derive it I think it's just from 1 up to number of constructors. You can also specify your own Enum instance but then you'd just end up writing a function with guards as you originally said
01:08:03 <erus`> merijn: i need to write my own then
01:08:04 <osfameron> does Enum refuse to work if any of your constructors are parametrized?
01:08:18 <erus`> because its not 1.. its 1, 3, 3, 5, 9
01:08:24 <Jafet> type BB = Word64
01:08:25 <ddarius> You can't derive it.  You can still make an instance.
01:08:43 <merijn> osfameron: You can make it work with parameterized constructors, just not derive
01:09:08 <Jafet> erus`: why would you do that? Piece values are just crude approximations.
01:09:15 <merijn> erus`: I'd just write a function then (unless someone here has a more brilliant plan)
01:09:24 <Jafet> Make it a function called crudePieceValue and call it from your evaluator
01:09:24 <osfameron> fair enough
01:09:25 <erus`> Jafet: I have to start somewhere
01:09:40 <erus`> i need a function to rate a board
01:09:42 <roconnor> what's the fastest way to compute the reciprocal of x modulo p?
01:09:45 <Jafet> Well, you're misusing Enum, that's what
01:09:52 <erus`> im not using enum...
01:10:13 <Jafet> Oh, someone else proposed it
01:10:19 <Jafet> Well, don't misuse it
01:10:27 <mustelo> @pl \x -> f (g x) $ h (i x)
01:10:27 <lambdabot> liftM2 f g (h . i)
01:10:43 <Jafet> erus`: a function works fine.
01:10:47 <c_wraith> roconnor: x ^ (p - 2)
01:10:57 <c_wraith> assuming p is prime
01:11:11 <Jafet> If you were designing a fast program with five hundred chess pieces, you could use an Array
01:11:18 <c_wraith> that's from fermat's little theorem, which is a ^ (p - 1) = 1, mod p
01:11:22 <Jafet> And make your function look it up from there
01:11:29 <erus`> cool
01:11:33 <roconnor> c_wraith: ....
01:11:35 <Jafet> c_wraith: pfft, just factorize p and it'll work everywhere
01:11:48 <roconnor> c_wraith: why have I been using the extended gcd algorithm all this time/
01:12:09 <c_wraith> extended gcd is more flexible
01:12:21 <c_wraith> That trick only works for inverse :)
01:12:41 <mustelo> also gcd works mod n where n is not necc prime
01:13:08 <Jafet> roconnor: you can derive the solution by observing that the gmp developers have been spending much more time on this problem than you
01:13:22 <roconnor> I haven't looked at gmp
01:13:37 <Jafet> That is, if you're willing to rebuild your ghc with a custom binding, or somehow ffi out to gmp
01:15:31 <roconnor> @type (^)
01:15:32 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
01:15:59 <Jafet> Is p supposed to be large?
01:16:33 <roconnor> a bit less than 2^256
01:17:54 <Jafet> gmp would beat anything if you added its extgcd directly to integer-gmp and rebuilt ghc, but saying that's a bit unportable is an understatement
01:19:04 <Jafet> At that size, though, ffi to a C library might lose
01:19:07 <lpsmith> roconnor: you don't need the full egcd algorithm,  simple code analysis can wipe out some of your variables
01:19:19 <lpsmith> you need a half-extended gcd algorithm
01:19:29 <lpsmith> but you probably know that :)
01:19:40 <roconnor> no I don't know
01:19:57 <Jafet> Pah, it's just trivial constant factors
01:20:05 <k0ral> how can I launch another app in haskell without making it a child of the current one (ie independent of the "parent")
01:20:07 <k0ral> ?
01:21:04 <ManateeLazyCat> @type runCommand
01:21:05 <lambdabot> Not in scope: `runCommand'
01:21:15 <ManateeLazyCat> :t runCommand
01:21:17 <lambdabot> Not in scope: `runCommand'
01:21:33 <ManateeLazyCat> Forgot lambdabot syntax again.
01:21:34 <roconnor> c_wraith: boo, it's slower
01:21:38 <roconnor> ;(
01:21:48 <c_wraith> well, are you doing the mod on each multiplication?
01:21:52 <c_wraith> If not, of course it's slower
01:22:11 <ManateeLazyCat> k0ral: Use function `runCommand`
01:22:22 <k0ral> ManateeLazyCat: ^^ thank you, trying it right now
01:22:25 <ManateeLazyCat> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/process-1.0.1.2/System-Process.html
01:22:30 <ManateeLazyCat> k0ral: ^^^^^
01:22:36 <Jafet> runCommand lets it run concurrently, but it's still a child process
01:22:50 <Jafet> (otherwise you couldn't wait on it...)
01:22:51 <k0ral> so it's not what I'm looking for
01:22:59 <lpsmith> roconnor: http://hpaste.org/47391/halfextended_euclidean_algori
01:23:06 <k0ral> I want to spawn a new process totally independent from the current one
01:23:10 <lpsmith> there may well be better approaches thouhg
01:23:13 <roconnor> c_wraith: yes I do a mod on each multiplication.  otherwise it won't terminate in my lifetime :D
01:23:22 <k0ral> if I exit the current one, I want the created one to keep going
01:23:22 <ManateeLazyCat> k0ral: So add `nohup` before your command.
01:23:53 * ManateeLazyCat pasted "runExternalCommand" at http://paste2.org/get/1449352
01:23:57 <ManateeLazyCat> k0ral: Looks above
01:24:00 <k0ral> hmmmm is it the right way to do it ? isn't there a builtin function in haskell ?
01:24:07 <k0ral> looking :)
01:24:47 <ManateeLazyCat> k0ral: You can use `runExternalCommand` launch any command in child process, but child process won't kill when parent process exit.
01:25:03 <Jafet> I wonder if binary extgcd would be faster
01:25:18 <roconnor> lpsmith: what is half about that?
01:25:35 <ManateeLazyCat> k0ral: runExternalCommand is function in Manatee project, i used to it launch external program. :)
01:25:45 <k0ral> ManateeLazyCat: nice project btw
01:26:04 <k0ral> I've looked at some parts of your code to take example of
01:26:29 <lpsmith> roconnor: you aren't computing b
01:26:33 <Jafet> roconnor: it doesn't calculate the coefficient for n
01:26:39 * ManateeLazyCat I'm busy on a Python project (https://github.com/manateelazycat/deepin-software-center).
01:26:52 <Jafet> Doesn't save much, though, since the quotRem stays
01:27:08 <lpsmith> true
01:27:32 <Jafet> Maybe I'll try a haskell binary gcd later
01:27:33 <ManateeLazyCat> k0ral: AFAIK, if you want spawn new process and don't kill by parent process, nohup is only way. :)
01:27:43 <k0ral> ManateeLazyCat: why the use of printf instead of String concatenation (++) ?
01:27:53 <lpsmith> Jafet: yeah I was wondering the same,  if binary egcd would be good
01:27:56 <Jafet> (Is there any non-academic Integral that isn't a Bits?)
01:28:16 <ManateeLazyCat> k0ral: I'm lazy, i don't want type so much (++)
01:28:21 <Jafet> This will all be moot once the ghc developers fix the gmp ffi issue though
01:28:41 <ManateeLazyCat> k0ral: Just code style, you can modified it with your style (++). ;p
01:28:53 <k0ral> ManateeLazyCat: so there is no algorithmic reason like it would take more time using (++), right ?
01:29:21 <Jafet> (++) is constant time!
01:29:22 <ManateeLazyCat> k0ral: Well, if you have many string need connect, perhaps printf is better style.
01:29:31 <Jafet> Well, usually
01:29:41 <opqdonut> Jafet: well there's Peano/Nat
01:29:51 <k0ral> Jafet: what ?
01:30:00 <ManateeLazyCat> :t printf
01:30:01 <k0ral> I read it was O(n)
01:30:02 <lambdabot> forall r. (PrintfType r) => String -> r
01:30:06 <k0ral> with respect to the left operand
01:30:59 <Jafet> It allocates O(n) conses when you actually take n items from the first operand, but it's easy to see that you can't do any better for [a]
01:31:28 <Jafet> However, it is O(1) space and constant time to whnf
01:31:41 <ManateeLazyCat> k0ral: IMO, printf give you cleaner code.
01:32:00 <k0ral> ManateeLazyCat: cleaner is rather subjective
01:32:17 <k0ral> ManateeLazyCat: I'm more concernd about performance issues
01:32:23 <k0ral> concerned*
01:32:36 <ManateeLazyCat> k0ral: Yes, as i said, it's just style, you can choose any style you like. :)
01:32:39 <Jafet> Look, the overhead of the system opening a new process is going to dwarf you building a little string to run it
01:33:03 <lpsmith> I am really not liking IncoherentInstances
01:33:06 <Jafet> ...probably.
01:33:17 <k0ral> Jafet: I'm not talking about this case precisely, I'm talking in general
01:33:43 <Jafet> Well, I already gave you the complexity of (++). It's optimal for joining strings together
01:33:53 <k0ral> wonderful then
01:34:15 <Jafet> If you want performance, you use Text or ByteString
01:34:17 <roconnor> lpsmith: I more or less have been droping a variable.  But I'm interested in the fact that your loop is tail recursive.
01:34:21 <erus`> @hoogle toUpper
01:34:22 <lambdabot> Data.Char toUpper :: Char -> Char
01:36:49 * ManateeLazyCat IMO, (++) performance improvement is insignificant for practical project, except you use it many many times. :)
01:38:13 <roconnor> xgcdMod                        EcDsaSecp256k1        71.0   61.8
01:38:31 <roconnor> as I suspect, 71% of my time in my extended gcd algorithm.
01:39:13 <lpsmith> well, I haven't spent a great deal of time tweaking my code
01:39:16 <lpsmith> for performance
01:39:17 <roconnor> :)
01:39:28 <k0ral> ManateeLazyCat: your snippets work like a charm, thank you again
01:39:30 <lpsmith> so I can't promise mine will do muc if any better
01:39:47 <ManateeLazyCat> k0ral: You're welcome! :)
01:40:19 <erus`> how does chess checkerboard work
01:40:38 <erus`> colour = index / 8 `mod` 2 == 0
01:40:41 <erus`> doesnt work :(
01:41:08 <lpsmith> roconnor: though if you come by some practical performance improvements for modinv/egcd,  I'm definitely interested in them
01:41:27 <roconnor> how do I enable bang patterns?
01:47:37 * hackagebot hbro 0.4.2 - A suckless minimal KISSy browser  http://hackage.haskell.org/package/hbro-0.4.2 (koral)
01:49:21 <roconnor> lpsmith: your code is slightly faster than mine. :)
01:54:48 <gienah> roconnor: {-# LANG BangPatterns #-}
01:55:52 <roconnor> ugh, I have to do a reciprocal on every elliptic curve operation.
01:58:44 <Jafet> erus`: number a checkerboard and see for yourself
02:00:14 <Jafet> The curves people choose for real-life systems are those that make this operation cheap
02:00:23 <Jafet> (among other things)
02:00:49 <roconnor> Jafet: how do you make reciprocals cheap?
02:01:39 <roconnor> sure the curves are nice so I add 0's in places, but everything is dominated by the call to reciprocal
02:02:39 <Jafet> By, for example, choosing a field modulo p=2^n-k
02:03:20 <roconnor> that hasn't been done here :(
02:03:40 <Jafet> (which I think is the basis for curve25519)
02:04:00 <roconnor> I have curve EcDsaSecp256k1
02:04:19 <roconnor> my field is F_p where p = 2^256 - 2^32 - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1
02:04:31 * ManateeLazyCat I hate Google close Translate API !
02:05:37 <lpsmith> roconnor: https://github.com/lpsmith/NumberTheory/commit/1bf1f512ded037317e4cb8a30b61dc1a049d0319
02:05:50 <lpsmith> you can read some of my bad code and laugh :)
02:05:53 <Jafet> That's looks like it's designed to be fast on 32-bit systems and above
02:06:31 <Jafet> Err not quite 32, since the 33rd bit is off
02:06:40 <lpsmith> but yeah,  if some people want to collaborate on a good NumberTheory-type package,  it's missing on Hackage
02:07:41 <lpsmith> high quality implementations of a nice collection of basic number-theory algorithms
02:08:05 <Jafet> I wonder what mm_freak uses
02:09:23 <merijn> Parsec makes writing a compiler so easy it feels like cheating to use it >.>
02:10:17 <Jafet> Write a C++ compiler
02:10:40 <merijn> Jafet: I'm not tired of life quite yet
02:11:00 <erus`> write a self hosting haskell compiler
02:11:40 <merijn> Easy, just make the compiler be "id" and call GHC :D
02:11:45 <roconnor> lpsmith: I don't know why you don't do (a - c*q) `mod` n
02:12:05 <roconnor> lpsmith: without that mod `mod` the size of your inverse would seem to explode
02:12:35 <erus`> im going to generate a complete game tree for chess
02:12:38 <ManateeLazyCat> merijn: lol :)
02:12:47 <erus`> i need to buy more hard drives
02:12:52 <ManateeLazyCat> > id "GHC"
02:12:53 <lambdabot>   "GHC"
02:13:00 <ManateeLazyCat> See ?
02:13:01 <merijn> erus`: uh...
02:13:05 <lpsmith> roconnor: you might be right
02:13:11 <roconnor> whew
02:13:14 <roconnor> at least I'm not crazy
02:13:22 <merijn> erus`: You know that the number of possible chess boards is bigger then the number of atoms in the universe, right?
02:13:32 <merijn> erus`: So you might want to invent a new storage medium, while you're at it
02:13:39 <lpsmith> I haven't touched this code in a while,  and I haven't thought about number theory deeply in even longer
02:13:45 <erus`> yeah but il use compression or something
02:14:01 <erus`> zip it as I go
02:14:25 <Jafet> Now, now, I want erus` to drive down the price of my new hard drives.
02:14:52 <lpsmith> roconnor: I'm wondering if this is doable in egcd;  if it's not, that might be part of the reason why
02:14:53 <merijn> erus`: Speaking of which, I have a universal compression algorithm for sale! Guaranteed to produce output smaller then its input!
02:15:20 <erus`> does it beat 7z ?
02:15:23 <cizra2> merijn: Let's team up, it'd fit nicely with my perpetuum-mobile based quantum computer.
02:15:26 <lpsmith> but clearly that is an acceptable thing to do with modinv
02:15:29 <merijn> cizra2: :)
02:15:35 <cizra2> erus`: any time. The algorithm is simple:
02:15:39 <adnam> i have one too, it's guaranteed to halve the size of its input
02:15:41 <cizra2> erus`: first 7z, then run merijn's
02:15:47 <lpsmith> roconnor: are you sure the inverse actually explodes in size?
02:15:53 <varnie> hello.
02:15:54 <merijn> cizra2: And this program I just came up with which checks whether my code terminates or not :)
02:15:56 <erus`> merijn's is destructive
02:16:01 <varnie> could you help me with a little problem: http://hpaste.org/47392/mistake
02:16:08 <cizra2> erus`: Since merijn's algo is guaranteed to produce smaller output than input, it's gotta be better
02:16:16 <erus`> you guys found the higgs bison?
02:16:26 <merijn> erus`: Yeah, I probably should have added "reversible" compression >.>
02:16:39 <cizra2> merijn: Bah, I invented that LONG ago. My program checks whether it _itself_ terminates. If it terminates, it terminates. If not, well, I haven't found out yet.
02:16:55 <merijn> cizra2: Hey, that means my algorithm becomes a fixpoint compressing everything into 0 storage space, I only just realized that :>
02:17:16 <cizra2> merijn: I thought that was obvious?
02:17:17 <Jafet> What if you give your algorithm the empty string
02:18:10 <merijn> Jafet: Then it punches you in the face :)
02:18:20 <merijn> cizra2: It is, but that doesn't mean I though of it :p
02:18:33 <cizra2> Jafet: It produces a string with negative length and proves an unified field theory
02:18:45 <varnie> I don't get what's wrong with my code.
02:19:45 <Jafet> Ah, so that's how you do quantum physics in haskell
02:20:03 <cizra2> varnie: Pastebin links are not intriguing. Give us something that would make it interesting to follow that link!
02:20:19 <merijn> On unrelated note, GADT question: "I :: Int -> Expr Int" (to borrow an example) can just be pattern matched like "I Int" would, right? i.e. "foo (I n) = n*2" or something
02:20:24 <varnie> okay, I am trying to perform "Transform a list, possibly holding lists as elements into a `flat' list by replacing each list with its elements (recursively). "
02:20:47 <cizra2> Oh, that was a tricky on.
02:20:49 <merijn> varnie: So you're just trying to write a flatten function
02:20:55 <varnie> yes, exactly.
02:21:04 <cizra2> @src flatten
02:21:04 <lambdabot> Source not found. The more you drive -- the dumber you get.
02:21:16 <erus`> anyone in here ever attempted a chess ai?
02:21:34 <Jafet> I reached 3 ply and gave up
02:21:45 <merijn> varnie: You're data type is not a list
02:21:52 <merijn> varnie: Your data type is a tree
02:21:58 <Jafet> Unfortunately, ghc doesn't expose a first-bit-set instruction.
02:22:24 <lpsmith> Jafet, roconnor:  if either of you come up with a better (half) extended euclidean algorithm,  I am very interested it in incorporating it into this code:
02:22:28 <varnie> so, how to make it a list then?
02:22:38 <lpsmith> http://github.com/lpsmith/NumberTheory
02:22:43 <Jafet> varnie: if myFlatten x :: [a], and myFlatten xs :: [a], how do you expect to pass them to (:)?
02:22:46 <Jafet> :t (:)
02:22:47 <merijn> varnie: "data List a = Empty | Cons (List a)"
02:22:47 <lambdabot> forall a. a -> [a] -> [a]
02:23:03 <Jafet> :t (++)
02:23:04 <lambdabot> forall m. (Monoid m) => m -> m -> m
02:23:07 <erus`> Jafet: is that white, black, white    or     (white, black) * 3 ?
02:23:07 <lpsmith> roconnor: I'll have to explore your mod n idea later.   It is *way* past my bedtime
02:23:16 <varnie> I have to think about it, thanks by the way!
02:23:18 <Jafet> :t (Prelude.++)
02:23:18 <lambdabot> forall a. [a] -> [a] -> [a]
02:23:35 <merijn> varnie: Your current version "Elem a" has one a and "List" has a list of "List a" as arguments (so you end up with a tree)
02:23:50 <Jafet> erus`: http://en.wikipedia.org/wiki/Ply_(game_theory)
02:24:37 <erus`> Jafet did you try selecting specific branches to search or anything?
02:25:18 <Jafet> Well, 30000 positions per second is pretty terrible either way
02:27:48 <erus`> did you think up your own leaf rating system?
02:28:02 <erus`> do i mean branch
02:28:48 <merijn> erus`: Did you do any other game trees before trying the chess one?
02:29:04 <k0ral> what is the shortest way of constructing a Set ?
02:29:39 <erus`> merijn nothing finished
02:30:03 <Jafet> k0ral: in inches?
02:30:04 <sioraiocht> k0ral: Set.empty?
02:30:23 <k0ral> siracusa: I mean a non empty set; I have n elements I want to build a Set from
02:30:24 <sioraiocht> k0ral: depends, what form is the data in that you want to put into the set?
02:30:33 <sioraiocht> k0ral: I know, sorry, was being a bit cheeky ;)
02:30:34 <k0ral> Jafet: ?!
02:30:35 <merijn> erus`: Why not try tic-tac-toe first? Much simpler rules, smaller tree, known to be solvable and humanly checkable :p
02:31:00 <erus`> because im allready 450 lines into my chess one now :|
02:31:03 <Jafet> :t Data.Set.fromList
02:31:04 <lambdabot> forall a. (Ord a) => [a] -> S.Set a
02:31:22 <Jafet> merijn: it doesn't indicate that your algorithm performs badly
02:31:23 <erus`> but you are right
02:31:29 <merijn> erus`: Oh well, once you solve chess you can move on to the really hard games :)
02:31:31 <Jafet> Well, maybe if you did gomoku
02:31:45 <sioraiocht> k0ral: as Jafet said, I would use fromList
02:31:53 <sioraiocht> unless you don't want to write it out to a list in the first place
02:31:55 <k0ral> Jafet: I would have liked not going through lists for performance purposes but fine
02:32:06 <Jafet> Performance? What performance
02:32:13 <sioraiocht> k0ral: you don't have to, where is the data coming from
02:32:15 <sioraiocht> a file or...?
02:32:23 <k0ral> it's hardcoded
02:32:49 <k0ral> I suppose lists are more than satisfying in this case
02:33:22 <Jafet> Don't imagine performance issues. Find them with a profiler
02:33:40 <Jafet> If you know what data it is, rearrange it and use fromAscList.
02:34:02 <merijn> k0ral: Rule number one of programming: It is fast enough until you have extensive profiler logs proving differently
02:34:30 <Axman6> or they kill your job on the supercomputer
02:34:41 <k0ral> Jafet, merijn: I don't like coding without thinking about performance
02:34:50 <merijn> k0ral: My biggest handicap in coding is that I tend to invest to much time thinking about how to do something efficiently when it really doesn't matter
02:35:20 <k0ral> merijn: well, I'd rather that way rather than people never thinking of it at all
02:35:24 <Axman6> merijn: i don't think that's necessarilly a bad thing. if you think about it a lot, you tend to start to write fast things the first time
02:35:27 <merijn> It stops me from writing code at all while the idiots writing crappy code actually produce useful things. Major advantage of Haskell, stops me from worrying about performance so much since its harder to visualize :>
02:35:37 <Axman6> and you also end up understanding the problem much more deeply
02:35:50 <merijn> Axman6: It is a bad thing if the end result is not writing code at all
02:36:00 <merijn> Axman6: Crappy code is better then no code
02:36:02 <Axman6> what you need to learn though is to know when the amount of work isn't worth it
02:36:03 <Jafet> k0ral: well, you're wasting your time if you don't know what the real performance issues are.
02:36:05 <k0ral> merijn: well, you said "if"
02:36:07 <merijn> s/then/than
02:36:17 <k0ral> merijn: I'm not falling into that "if"
02:36:37 <Jafet> k0ral: I didn't say to not think about performance. I said to find out the actual facts about performance, rather than imagining them in your head
02:36:39 <merijn> k0ral: No, you're just wasting time you could be spending on getting it done quicker ;)
02:36:55 <varnie> merijn, I don't understand how to create some list instance having that data type
02:37:07 <k0ral> merijn: and crappy code isn't really better than no code, since in the end you may have to recode lots of things because of performance issue, while dealing with such problems at first time make you gain time
02:37:22 <varnie> for example, a list with values 1, 2, [3,4]
02:37:28 <merijn> varnie: Oh, I'm an idiot. I typo'ed my example >.>
02:38:03 <merijn> varnie: Should be: "data List a = Empty | Cons a (List a)", then you'd write "Cons 1 (Cons 2 (Cons 3 (Cons 4 Empty)))"
02:39:27 <Jafet> Rebindable syntax should do something for tuples and lists
02:39:34 <Jafet> But I'm not sure what
02:39:44 <merijn> varnie: Compare the similarity with this (fictional) haskell list implementation: "data [a] = [] | (:) a [a]"
02:40:48 <synonymous> how do I load a precompiled object code into GHCi?
02:41:57 <Jafet> I've loaded the source filename and the basename, both work
02:42:07 <Jafet> Loading the interface file name probably works too
02:43:19 <synonymous> Jafet:
02:43:19 <synonymous> Prelude> :load Reproduce.o
02:43:19 <synonymous> target `Reproduce.o' is not a module name or a source file
02:43:44 <Axman6> :load foo.hs or :load Foo
02:44:01 <Axman6> ghci will search for compiled code if you do that
02:44:05 <Axman6> i think
02:44:24 <synonymous> that's closer, let me check
02:45:27 <Jafet> It needs an interface file anyway
02:45:44 <synonymous> Axman6: you're quite right
02:45:57 <synonymous> Jafet: hi file?
02:46:13 <Axman6> hello file indeed!
02:46:15 <Jafet> .hi extension
02:46:25 <synonymous> )
02:49:10 <erus`> pawns cant take kings backwards can they?
02:49:27 <erus`> holy shit i think i dreamed that.... my dreams are getting really wierd
02:50:09 <Axman6> the closest would ne en passant right?
02:50:55 <erus`> yeah i guess
02:50:58 <Jafet> Take kings backwards? Sounds dirty
02:57:13 <erus`> Jafet: how large were your board states / snapshots ?
02:58:10 <Jafet> array ((0, 0), (7, 7)) Piece
03:00:37 <erus`> not using bitboards?
03:00:52 <Jafet> Like I said, no bit-counting instructions
03:01:08 <Jafet> If I went to the trouble to get those, I might as well be doing it in gcc
03:01:11 <erus`> yeah but still must be quicker
03:01:49 <erus`> did you have pawn, pawnUnmoved, pawnEnpassant types?
03:01:53 <Jafet> You can thread an STUArray with backtracking.
03:02:20 <Jafet> What would they do as types?
03:02:36 <erus`> i mean data
03:02:45 <erus`> how did you keep track of enpassant?
03:03:56 <Jafet> Maybe Position
03:05:49 <Jafet> There's no need to keep track of whether pawns have moved
03:09:42 <isomorphic> has anybody successfully used Cabal's detailed-1.0 test type?
03:10:07 <erus`> Jafet: if its their first turn they can jump
03:10:13 <dcoutts> isomorphic: I doubt it, not yet, it's not in any released version, and we're still playing with the interface.
03:10:29 <erus`> in chess 360 they wont allways be on rank 2
03:10:43 <Jafet> Okay.
03:10:56 * dcoutts notes that for this reason there is no detailed-1.0 test type, only detailed-0.9
03:11:06 <Jafet> I tried to think about supporting variants, but it became hairy.
03:11:13 <isomorphic> dcoutts: thanks.  What do you recommend for now?  exitcode-stdio-1.0?
03:11:20 <dcoutts> isomorphic: yes
03:11:41 <erus`> Jafet: also you have to keep track wether rooks and kings have moved for castling
03:11:43 <k0ral> type myType = [(([String], String), (String -> IO ()))] gives me a malformed type error
03:11:56 <k0ral> where am I wrong ?
03:12:09 <Axman6> becayse types must start with capital letters
03:12:13 <Axman6> u*
03:12:16 <k0ral> ahhhh
03:12:16 <Axman6> try MyType
03:12:41 <k0ral> error message could be improved :)
03:13:13 * k0ral is still doing noob mistakes
03:14:49 <Axman6> indeed, file a bug!
03:15:19 <merijn> Better yet, submit a patch :>
03:15:47 <roconnor> gcd takes log(n)/log(phi) steps?
03:15:52 <roconnor> typically?
03:16:55 <Jafet> The Euclidean algorithm has something like that as a worst case
03:17:14 <Jafet> Of course, each step is nontrivial
03:17:50 <Jafet> erus`: er, what's chess 360? Never heard of it
03:18:44 <erus`> chess 960*
03:19:37 <Axman6> synonymous: are you one of Manuel's students?
03:20:06 <Jafet> Chess 960 doesn't randomize pawns, so you must be implementing a variant of that variant
03:21:17 <synonymous> Axman6, yes I am
03:21:33 <Axman6> you should come along to AusHac next month =)
03:21:48 <Axman6> it's being help in the CSE building
03:22:13 <synonymous> oh yes i will
03:22:52 <Axman6> http://tinyurl.com/AusHac2011 if you're looking for more info
03:22:55 <erus`> bugger i didnt research that enough :P
03:25:16 <erus`> saves me 16 bytes
03:25:35 <synonymous> Axman6: thanks for the link. i'll certainly be there..
03:25:37 <Jafet> Counting bytes in haskell is futile...
03:25:55 <Axman6> synonymous: make sure you sign up then! (also tell your friends to come along too!)
03:27:35 <synonymous> Axman6: i'm afraid I don't have any oz friends who are into functional programming) the ones i had were all french)
03:27:50 <Axman6> oh well... invite them too!
03:27:58 <Axman6> we've got at least one person coming from overseas
03:28:01 <synonymous> Axman6: they went back already...
03:32:02 <Kaidelong> @djinn Either a a -> a
03:32:02 <lambdabot> f a =
03:32:02 <lambdabot>     case a of
03:32:02 <lambdabot>     Left b -> b
03:32:02 <lambdabot>     Right c -> c
03:32:31 <Kaidelong> @. pl djinn Either a a -> a
03:32:32 <lambdabot> (line 3, column 12):
03:32:32 <lambdabot> unexpected ">" or "-"
03:32:32 <lambdabot> expecting variable, "(", operator or end of input
03:32:38 <Kaidelong> oh
03:32:43 <Kaidelong> right, multiline output
03:33:10 <Kaidelong> and not really appropriate
03:33:38 <Kaidelong> @pl f a = case a of {Left b -> b; Right c -> c}
03:33:38 <lambdabot> (line 1, column 17):
03:33:38 <lambdabot> unexpected "{"
03:33:38 <lambdabot> expecting variable, "(", operator or end of input
03:34:32 <Kaidelong> I suppose since it is a pattern match you have to have this unless it is implemented elsewhere
03:36:54 * hackagebot hbro 0.4.3 - A suckless minimal KISSy browser  http://hackage.haskell.org/package/hbro-0.4.3 (koral)
03:39:37 <jesse_> hi
03:40:25 <k0ral> how do packagers do have the line "Distributions" displayed in hackage ?
03:40:39 <k0ral> I can't see any field in the cabal file that is related to it
03:41:30 <dcoutts> k0ral: that info is supplied by the distros themselves, not by package authors
03:42:30 <k0ral> you mean hackage checks by itself if a package exists in those distros ?
03:42:39 <dcoutts> no, the other way around
03:42:52 <dcoutts> the ditros upload lists of packages they have
03:43:06 <k0ral> what's the protocol ?
03:43:25 <dcoutts> do you want to add another distro?
03:43:36 <k0ral> no, I'm wondering how it works
03:44:02 <k0ral> because it seems odd to me
03:44:09 <dcoutts> there's a big text file, one package per line
03:44:12 <k0ral> how can hackage guess which package is the right one ?
03:44:25 <k0ral> there may be homonyms
03:44:44 <dcoutts> mapping package name to latest version packaged by the distro + a url for the distro package
03:44:45 <k0ral> and I noticed some "Distributions" lines give the wrong version number
03:44:48 <dcoutts> there's no guessing
03:44:58 <dcoutts> that's because they only package older versions
03:45:09 <ddarius> Someone is having trouble with "the simplest thing that could possibly work."
03:45:18 <isomorphic> dcoutts:  Is there a particular way in which multiple testcases in exitcode-stdio-1.0 should be chained together to allow for either exitSuccess or exitFailure?
03:45:34 <k0ral> dcoutts: I mean the distro package was up-to-date actually
03:45:48 <k0ral> how often is that list uploaded with distros ?
03:45:57 <dcoutts> k0ral: if the distro does in fact package a later version, then it means the info is out of date
03:46:04 <k0ral> do you mean you've been to several distros to ask them for such upload ?
03:46:05 <dcoutts> k0ral: the distro chooses when to update the list
03:46:19 <dcoutts> something like that, yes
03:46:24 <dcoutts> they came to us actually
03:46:37 <k0ral> which distros are doing this currently ?
03:47:08 <dcoutts> isomorphic: exitcode-stdio-1.0 just has one overall result, usually you declare the thing a success if all tests passed and a failure if any failed.
03:47:30 <dcoutts> isomorphic: the detailed test type will be able to report which tests failed
03:47:51 <dcoutts> isomorphic: though of course for exitcode-stdio-1.0 you can spit out whatever you like on stdout/stderr
03:48:29 <dcoutts> k0ral: I think arch, debian, gentoo. I'd have to go look to be sure though.
03:48:52 <isomorphic> dcoutts: thanks :)
03:50:17 <k0ral> dcoutts: I saw fedora too
03:50:27 <k0ral> dcoutts: thank you for your answers
03:50:30 <dcoutts> np
04:06:10 <erus`> guidelines ghci is awesome
04:06:24 <erus`> test as you go
04:09:45 <isomorphic> dcoutts: should "cabal test" force a rebuild of the Main-Is referred to under a Test Suite declaration?
04:10:19 <Twey> What is Guidelines GHCi?
04:10:45 <dcoutts> isomorphic: it doesn't, it relies on you running cabal build first. Arguably it should be more make-like and bring it up to date first.
04:23:23 <dropdrive> You guys should try to do this, it might be interesting!  http://news.ycombinator.com/item?id=2615096
04:26:30 <Jafet> Languages don't have performance
04:27:03 <merijn> Language performance is a useless metric
04:27:29 <merijn> The only useful metric is programmer+language performance and on a utility scale, not on a time/space scale
04:28:16 <merijn> I might be able to write super fast C, but if I can write extremely slow Python in a fraction of the time I'll probably still win out on the utility scale
04:33:30 <tgeeky> merijn: If you work for: [LWL, CERN, DoD, NASA, University of ___, ...], then language performance (by itself, and from the perspective of the organization) *is* a valid scale
04:33:35 <tgeeky> but your point is well taken
04:34:20 <dropdrive> merijn: That may be true for you, but it's pretty short-sighted to assume that the opposite extreme doesn't hold for plenty of people.
04:35:21 <merijn> tgeeky: No it is not, it is just that at huge scale the tiny fractions start making better impact on the programmer utility scale
04:35:30 <augur> hmm
04:36:01 <merijn> tgeeky: If you need to solve Google scale problems, then investing time to safe 1s of a query which runs a gazillion time has a different impact on the utility scale :p
04:36:03 <augur> anyone know of any relational program calculation literature that discusses things like conjunctive specifications?
04:36:30 <tgeeky> augur: I don't even know if that sentence makes sense :O
04:36:34 <augur> :P
04:36:37 <tgeeky> hehe
04:36:41 <tgeeky> relational...
04:36:54 <augur> as opposed to functional
04:38:52 <tgeeky> merijn: what I was getting at, is that CERN *mandates* the use of a language for certain kinds of work (writing code which will be combed over LHC collision datasets) in a particular [language,framework] because they can't afford to care about the programmer+ component on a utility scale
04:39:30 <tgeeky> merijn: that may be a bad choice, but they do it
04:40:20 <tgeeky> it won't take long to guess which language it is :)
04:40:29 <Egbert9e9> gtk's treeview scares the hell out of me. it's haddock page is HUGE
04:40:48 <Egbert9e9> its
04:41:18 <cheater__> augur: read up on deontic logic?
04:41:21 <tgeeky> Egbert9e9: it really is
04:41:33 <augur> cheater__: no what
04:41:35 <tgeeky> Egbert9e9: rewrite the docu for that page, split it up
04:41:40 <tgeeky> Egbert9e9: and submit a docu-patch
04:41:49 <Egbert9e9> tgeeky: but but but, i don't even know treeview O_O
04:42:03 <tgeeky> Egbert9e9: fantastic way to learn it, then
04:42:03 <merijn> hmm, there is no convenient way to update a record, right? i.e. I have to write "updateFoo (Foo {foo = m, bar = n}) = Foo {foo = m, bar = newValue}"?
04:42:09 <Egbert9e9> O_O
04:42:46 <tgeeky> Egbert9e9: seriously! learn what all of those things do, work with your own examples, become good at it, split the doc up into smaller pieces as you saw fit based on your experience
04:42:48 <Egbert9e9> tgeeky: you're crazy, i like you!
04:42:50 <tgeeky> Egbert9e9: everyone wins!
04:43:01 <dobblego> what is the category theory book that gets good raps because it is more approachable than say, Pierce?
04:43:21 <ClaudiusMaximus> merijn: updateFoo f@Foo{bar = n} = f{bar=newValue}  is slightly more convenient
04:43:23 <Egbert9e9> tgeeky: where do i even begin?
04:43:31 <Egbert9e9> oh, right. there's that hpaste example
04:43:38 <Egbert9e9> let me seeeee
04:43:55 <cobol2121> Conceptual Mathematics?
04:44:09 <tgeeky> Egbert9e9: the source has some splitting in the export list, that might make a good start to organizing all of those methods
04:44:39 <Egbert9e9> tgeeky: no, i mean, where do i begin in understanding it?
04:44:39 <augur> dobblego: awodey's book isnt bad
04:44:52 <augur> dobblego: i would follow along with the catsters too tho
04:44:55 <Egbert9e9> there's this: http://hpaste.org/47316/gtk_table_start
04:44:58 <dobblego> that's the one thanks!
04:44:59 <cobol2121> dobblego, http://www.amazon.com/Conceptual-Mathematics-First-Introduction-Categories/dp/052171916X
04:45:04 <tgeeky> [Constructors (2), Methods (11ty-billion), Attributes (infinity-8), Signals (8), Deprecated (10)]
04:45:04 <augur> cheater__: whats deontic logic
04:45:13 <dobblego> cobol2121: cheers
04:45:17 <tgeeky> Egbert9e9: yeah, find an example (hpaste, some app that uses treeview)
04:45:25 <tgeeky> and make it more and more complicated until you understand it
04:45:33 <augur> cheater__: i mean in this context
04:45:36 <tgeeky> Egbert9e9: in you can't find one, ask someone here to write enough to get you started
04:46:06 <Egbert9e9> tgeeky: i already have an app i want to implement using treeview. it's this youtube playlist downloader... i guess i should do something a lil bit moer productive, right?
04:46:21 <tgeeky> Egbert9e9: no, learning is the 2nd most productive thing you can do
04:46:46 <Egbert9e9> tgeeky: i already have the commandline youtube playlist downloader. it doesn't have commandline flags but still it works
04:47:00 <tgeeky> Egbert9e9: good start, then
04:47:06 <tgeeky> Egbert9e9: get a "hello world" gtk app
04:47:14 <Egbert9e9> i have one, not using treeview
04:47:27 <Egbert9e9> it's pretty cool, using glade
04:47:39 <tgeeky> Egbert9e9: get a tree, to treeview, then let's get ya started
04:47:50 <Egbert9e9> uh.. uhm.. lets see
04:48:48 <Egbert9e9> tgeeky: this is exciting. i've never written any gui app
04:48:56 <tgeeky> Egbert9e9: damn right!
04:49:03 <Egbert9e9> :-D
04:49:12 <gal_bolle> where can I find the instance for (Data.String.IsString [Char])? I tried importing Data.String(), but to no avail (i'm using -XOverloadedStrings and trying to do length '"abcde"')
04:49:29 <tgeeky> usually it's easy to find haskell things which are built using some library, but i am having some trouble with treeview
04:50:09 <tgeeky> gal_bolle: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-String.html#t:IsString
04:50:14 <Egbert9e9> tgeeky: thing is, i'm using youtube-dl with rawSystem
04:50:15 <erus`> when using && is the left side allways evaluated first?
04:50:38 <Egbert9e9> tgeeky: (rawSystem "youtube-dl" ["--flags"])
04:50:39 <tgeeky> @src (&&)
04:50:39 <lambdabot> True  && x = x
04:50:39 <lambdabot> False && _ = False
04:50:55 <tgeeky> erus`: looks like it
04:50:56 <zygoloid> erus`: that is not the correct question :)
04:51:31 <erus`> zygoloid: ?
04:51:31 <tgeeky> Egbert9e9: ok, you'll probably not find a tree inside youtube videos
04:52:00 <Egbert9e9> i've kinda sorta got threading working. what it does is take a playlist code, download the html, chop the video code list, turn it into a list and show it on this label widget
04:52:03 <zygoloid> 'evaluated first' is not a notion which applies to the pure fragment of haskell.
04:52:09 <tgeeky> gal_bolle: fromString is the only function in the default instance
04:52:18 <Egbert9e9> tgeeky: but treeview does tables, too
04:52:23 <Egbert9e9> tgeeky: for some strange reason
04:52:34 <Egbert9e9> as in, tables are a subset?
04:52:42 <tgeeky> Egbert9e9: dunno, never used gtk
04:52:46 <Egbert9e9> O_O :-D
04:53:17 <Egbert9e9> okay, so there's a subset of treeview which is a table without.. uh.. how do you call treeing?
04:53:52 <tgeeky> hehe
04:53:54 <zygoloid> erus`: an implementation is at liberty to evaluate the right-hand side first, or in parallel, or interleaved, so long as the result is False if the left-hand side is False (even if the right-hand side does not terminate)
04:53:56 <tgeeky> can't think of something better of treeing
04:54:45 <tgeeky> Egbert9e9: this http://www.haskell.org/haskellwiki/Gtk2Hs/Tutorials/TreeView
04:54:53 <tgeeky> claims to be a TreeView tutorial
04:55:00 <Egbert9e9> it's not a tutorial o-o
04:55:10 <tgeeky> yeah, it looks more like an example
04:55:19 <erus`> zygoloid: so it's bad practise?
04:55:28 <tgeeky> tgeeky: leksah probably uses TreeView
04:55:35 <tgeeky> tgeeky: you're an idiot!
04:55:39 <Egbert9e9> tgeeky: are you hinting me that i should turn it into one?
04:55:43 <tgeeky> Egbert9e9: leksah probably uses treeview
04:55:45 <tgeeky> Egbert9e9: no
04:55:55 <Egbert9e9> never got leksah working
04:55:58 <tgeeky> Egbert9e9: you should be able to delete it
04:56:01 <Egbert9e9> some dependency problem, i think
04:56:04 <tgeeky> Egbert9e9: you don't need to, you just need the source
04:56:27 <gal_bolle> tgeeky: http://hpaste.org/47393/cant_find_instance_isstring_s is what I have, with ghc's answer
04:56:51 <zygoloid> erus`: no. it is reasonable to assume that there will be no significant runtime cost from evaluating the right-hand side of (&&) if the left-hand side evaluates to False
04:57:03 <Egbert9e9> wait a sec
04:57:49 <tgeeky> gal_bolle: from here:
04:57:49 <zygoloid> erus`: (in practice it short-circuits in exactly the same way as in other languages)
04:57:49 <erus`> but i have if (A) && (WILL CRASH IF A IS FALSE) then ...
04:57:50 <tgeeky> http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/type-class-extensions.html
04:58:33 <tgeeky> gal_bolle: you'll want to see the small example
04:58:44 <tgeeky> gal_bolle: you'll want to have your overloaded string type (MyString, in this case)
04:58:56 <tgeeky> gal_bolle: write a short IsString for it (just like that one)
04:59:04 <zygoloid> erus`: unless you hit an implementation bug, or veer of into unsafe*/ffi, pure haskell code shouldn't crash
04:59:16 <gal_bolle> I don't have an overloaded string type (yet)
04:59:40 <tgeeky> gal_bolle: ah, then you are an egg without a chicken, so to speak
04:59:46 <zygoloid> erus`: it can, however, bottom out (via non-termination or various other exceptions), and such failures will not be propagated to the result of (&&) if the LHS is False
05:00:06 <gal_bolle> not sure i get what that means…
05:00:42 <zygoloid> erus`: consider: (some complex expression which the compiler can prove terminates) && False. that can be optimized to 'False' (the RHS) without evaluating the LHS at all.
05:01:55 <merijn> erus`: In any sane language (i.e. the only one I know which does not do this is VisualBasic) the logical opertors (&& and ||) short-circuit, which means that right hand side is not evaluated if the result can be determined from the left hand side alone
05:02:07 <gal_bolle> tgeeky: problem solved: I need more type annotations
05:03:34 <zygoloid> erus`: put another way, the denotational semantics of (&&) are the same as the denotational semantics of the operational model "evalute LHS, then evaluate RHS if LHS is True". but the operational semantics of it need not be the same as that.
05:03:36 <tgeeky> gal_bolle: ok
05:03:55 <tgeeky> gal_bolle: hpaste solution, for posterity
05:04:25 <zygoloid> (so it acts "as if" it evaluates the LHS first, but the compiler need not implement it that way, and with 'unsafePerformIO'-style tricks, you can sometimes observe it being implemented differently)
05:12:26 <Egbert9e9> tgeeky: sorry, insanely annoying ecryptfs problems that plague this novice ubuntuer's installation
05:12:49 <tgeeky> :(
05:15:25 <Egbert9e9> well, i think it's ecryptfs. might be something else. it makes irssi not find the log files when i'm not sshing to my always-on-home-computer and my digital memory gets huge holes when i'm not logged in because of that
05:58:05 <merijn> @hoogle m (n (m a)) -> n (m a)
05:58:05 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
05:58:06 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
05:58:06 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
06:01:51 <physicist> hi
06:02:01 <finnomenon> hi
06:02:14 <finnomenon> are you a real physicist?
06:02:32 <merijn> I have "data Program = Prog {definition :: [Def], signatures :: [Sig]}" and a "[Program]" which I want to reduce to a single Program by appending the lists of all Program's together, any handy existing combinators?
06:06:26 <lunaris> merijn: Define an instance Monoid and then use mconcat or foldMap id?
06:06:51 <merijn> :t mconcat
06:06:52 <lambdabot> forall a. (Monoid a) => [a] -> a
06:07:34 <lunaris> i.e. instance Monoid Program where { mempty = Program { definition = [], signatures = [] }; mappend p1 p2 = Program { definition = definition p1 `mappend` definition p2, signatures = signatures p1 `mappend` signatures p2 } }
06:07:48 <lunaris> (Excuse syntax errors)
06:07:54 <lunaris> (You'll need Data.Monoid)
06:13:24 <isomorphic> So, I am trying to use the new Cabal Test Suite code, specifically exitcode-stdio-1.0 - I have a function which attempts to (1) create [Assertion], and then (hopefully) execute these actions (since they're just IO ()) - and then determine if the resulting IO () is empty (HUnit guarantees that the resulting IO () will be empty unless a test fails) ...
06:13:50 <merijn> lunaris: Got it, thanks :)
06:13:59 <isomorphic> Unfortunately, it doesn't work - see http://hpaste.org/47398/check_if_io_is_empty
06:14:38 <erus`> is there a many to one data type in the prelude?
06:14:44 <erus`> like a tree structure
06:15:29 <isomorphic> Error is in relation to the variable l -  Expected type: [[a0]] -       Actual type: [Assertion]
06:16:00 <isomorphic> the plan is for sequence to evaluate the list l - and then check the result for null
06:16:27 <isomorphic> how should I be checking the contents of an IO () for emptiness?
06:16:38 <isomorphic> (null isn't the right tool, I gather)
06:17:16 <ben> I'm not sure I understand the question. IO () is an IO action that produces (), it doesn't 'contain' anything in either way
06:17:50 <ben> Is this some tricky new IO representation business
06:18:32 <ezyang> It may have side effects.
06:18:36 <Zao> The way to get the result of executing an IO action is to execute the IO action.
06:18:48 <Twey> isomorphic: The only ‘contents’ it can potentially be said to have (though that's a rather stretched metaphor) is ()
06:19:11 <Twey> You don't need to check () for anything.  It's ().  You know exactly what it is already.  :þ
06:19:24 <Zao> The only naively observable results of IO () is that when performed, you get an ().
06:19:51 <isomorphic> Okay - so my issue really stems from the HUnit documentation
06:19:52 <Zao> You need auxillary external knowledge to capture whatever side effects it performs.
06:20:02 <Zao> fireZeMissiles :: IO ()
06:20:09 <isomorphic> type Assertion = IO ()
06:20:16 <Zao> You need a decent missile net :)
06:20:24 <isomorphic> When an assertion is evaluated, it will output a message if and only if the assertion fails.
06:20:42 <isomorphic> So, I'd like to evaluate my assertions and figure out whether they'd give output
06:20:52 <isomorphic> does that make sense?
06:21:58 <isomorphic> Ie: Turn a list of a Assertions into a single bool indicating whether any assertion failed
06:22:28 <Zao> Not naively.
06:22:42 <Zao> You need support from "HUnit" for that.
06:24:37 <isomorphic> My idea is to treat them as IO actions - some of them will produce no output, and some will. So, given a list of [IO a], how would I determine if any of the IO actions are non-empty?
06:25:00 <flux> isomorphic, you cannot really know what an IO does without evaluating it
06:25:22 <flux> (s/evaluating/running/)
06:25:45 <flux> isomorphic, you could maybe have your own object that allows injecting IO events in, and that kind of injection marks it 'has action'
06:26:08 <isomorphic> flux, okay, that's what I figured. I'm happy to run them; but then after running all of them, how can I tell if any of them produced an action?
06:26:25 <flux> isomorphic, not really
06:26:38 <flux> I guess in principle you could use OS-specific hooks but that is wayyy hacky
06:26:52 <isomorphic> flux, Right, I guess that's what I needed to know...
06:27:05 <isomorphic> thanks.
06:49:03 <Phyx-> I have a weird problem.. with the commented line uncommented this code works, without it, somehow it does something weird.. http://pastebin.com/KNqp8jMs
06:49:06 <mauke> The paste KNqp8jMs has been copied to http://hpaste.org/47400/httppastebincomknqp8jms
06:49:08 <Phyx-> anyone got an idea?
06:50:08 <Twey> Phyx-: ‘Does not work’ is not a valid description of a problem, &c.
06:51:21 <Phyx-> Twey: e.g. only the first of the extensions is enabled. the rest are seemingly ignored
06:52:11 <Phyx-> i should also probably say that the code is being called through FFI
07:00:28 * Phyx- hears a pin drop
07:02:42 <Saizan> are you sure you're calling it with the same list of extensions each time?
07:03:34 <Phyx-> i'm checking the list i'm passing to the function, it contains them all. when it was logging, it also showed that all the extensions i expect were enabled
07:04:54 <Phyx-> Context is a StablePtr so i can't actually see what's in it. But I guess i could export a haskell function that dumps the content
07:07:22 <Saizan> did you try loading some code that used those extensions when logging was enabled?
07:09:09 <Phyx-> Saizan: yup, that's how i know that only the first was being loaded
07:10:18 <Phyx-> for instance, enabling TemplateHaskell & TypeFamilies doesn't enable TypeFamilies
07:10:33 <Saizan> i wanted to be sure you did the same test with and without the writeFile
07:10:35 <Phyx-> atleast not right away, a second call does eventually
07:10:46 <Phyx-> yeah, I'm loading the same file
07:11:27 <Phyx-> i'm loading http://pastebin.com/UQTAinFm
07:11:29 <mauke> The paste UQTAinFm has been copied to http://hpaste.org/47401/httppastebincomuqtainfm
07:11:30 <Saizan> maybe it's related to concurrency?
07:12:59 <Phyx-> Saizan: I'm thinking that too, but the Context is locked. I'm using a semaphore to only allow one thing to use it at a time. Which is why I'm rather confused,
07:15:42 <Phyx-> i'll export the function that dumps the ExtensionFlags and see if it has both, if it does then the bug must be in my c# code
07:20:45 <Phyx-> linking & packing..
07:25:25 <Phyx-> oh man. I just accidently threw away the wrong file
07:25:38 <Phyx-> and I didn't put it in source control yet
07:25:40 <Phyx-> *cries*
07:30:15 <sm> Phyx-: emacs user ? there are ways..
07:31:18 <sm> morning all
07:31:45 <boolcrap> hi
07:32:01 <Phyx-> sm: not emacs no, and I deleted the file from disk and excluded it in visual studio, so it's not even in my undo buffer anymroe
07:32:25 <sm> rats
07:32:27 <Twey> There are undelete tools for Windows
07:32:34 <sm> well your next version will be better
07:33:02 <MasseR> I'm reading the haskellwiki tutorial about quasi quotes, and I'm wondering what's the difference between expression and a pattern? ExpQ and PatQ in the example seems to be the same verbatim
07:33:32 <Phyx-> Twey: if the data wasn't already overwritten
07:33:33 <Phyx-> sm: hehee
07:33:59 <Twey> MasseR: In something like ‘foo (x:xs) = bar’, "foo (x:xs)" is a pattern and "bar" is an expression
07:34:12 <Twey> They're treated differently
07:34:58 <erus`> I wanna map over a list, but i only wanna map until i hit a certain value. how can i do that?
07:35:10 <osfameron> erus`: takeWhile ?
07:35:19 <Twey> MasseR: http://hackage.haskell.org/packages/archive/template-haskell/2.4.0.1/doc/html/Language-Haskell-TH-Syntax.html#t:Pat
07:35:46 <MasseR> Thanks
07:36:34 <erus`> perfect
07:38:41 <sm> I spend more time wrestling with tools and dependencies than on my code. Is that the norm ?
07:38:56 <erus`> yeah its haskell
07:39:01 <erus`> sdl doesnt even work on windows
07:39:36 <Phyx-> hmm.. I seem to have killed visual studio...
07:41:16 <sm> ghc 6.12 will always require containers 0.3 and 7.0 will always require 0.4, is that right ?
07:42:12 <MasseR> Oh the wiki about QQ is outdated. The QuasiQuoter data type has changed
07:42:30 * hackagebot hscolour 1.18 - Colourise Haskell code.  http://hackage.haskell.org/package/hscolour-1.18 (MalcolmWallace)
07:45:52 <fxr> I wish I have package revision history or a changelog for each package in Hackage website this year.
07:46:13 <sm> +1
07:50:37 <temoto> @type map
07:50:38 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:51:01 <temoto> Could you remind the type of another, applicative (instead of list) map?
07:52:32 <yrlnry> @type fmap
07:52:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:52:42 <yrlnry> Note that Applicative is a subclass of Functor,.
07:53:21 <temoto> Thanks.
07:53:31 <yrlnry> Welcome.
07:55:27 <sm> how do I reset my ghc/cabal installation again ? I don't want to just erase .ghc and .cabal in case of losing key ghc core package info, my cabal config etc.
07:55:55 <dcoutts> sm: core packages are installed globally, not in the per-user package db
07:56:08 <sm> ah good, don't have to worry about .ghc then
07:56:11 <dcoutts> sm: you could rm ~/.ghc/$yourarch
07:56:19 <dcoutts> oh, and ghc version
07:57:01 <temoto> I'm trying to explain where rank-2/N polymorphism could be useful and leaning towards something like fmap . read. Maybe someone has better ideas?
07:57:35 <sm> in .cabal I think I'll rm -rf ~/.cabal/{lib,logs,packages,share,world}, keeping bin and config
07:58:05 <dcoutts> sm: you can leave packages, that's just downloaded tarballs
07:58:11 <dcoutts> similarly logs
07:58:25 <dcoutts> sm: really, only thing worth deleting is lib and share
07:59:24 <sm> packages has 250M of ancient versions, I think I'll nuke it
07:59:35 <sm> ok. What's world, out of interest ?
07:59:51 <dcoutts> the world file is there to keep a record of what you wanted to install, e.g. to help in the "I just upgraded ghc, how to I get all my packages back" use case
08:00:03 <dcoutts> or for the "how do I upgrade all my packages" case
08:00:27 <dcoutts> answer, cabal install world, however it will not really work well until the new solver is integrated
08:01:08 <dcoutts> because it's often impossible to simultaneously install everything while picking just one version of each package
08:01:33 <dmwit> Oh, cool!
08:01:41 <dmwit> I didn't know about "cabal install world".
08:02:04 <sm> I see, somewhat like dpkg --get-selections
08:02:34 <dcoutts> dmwit: aye, I'm not really going to advertise it until it works well
08:02:47 <sm> I wondered today if cabal install should list the install plan and wait for confirmation by default, like apt-get
08:03:07 <dmwit> cabal install --dry-run =P
08:03:13 <sm> for anything complex, I always want to add --dry
08:03:23 <dcoutts> aye, there's an argument that it should be interactive by default
08:03:42 <dcoutts> I'd be happy to hear opinions on that
08:03:44 <dmwit> I like non-interactive-by-default.
08:04:06 <dmwit> Is there an option to make it interactive?
08:04:11 <dmwit> Oh, there's --dry-run.
08:04:17 <dmwit> So, yeah, I think it's fine as-is.
08:04:28 <dmwit> Just like make install.
08:05:06 <kenjin22011> .
08:05:24 <sm> dmwit: that means once you install a few complex apps, there's a high risk that any given install/upgrade will quietly break your installed dependencies, causing heartache for newcomers and regulars trying to do other stuff
08:05:46 <dcoutts> sm: but there's other approaches to that than interactivity
08:05:46 <merijn> Can I use record syntax with datatypes which have more then one constructor?
08:05:54 <dcoutts> merijn: yes
08:06:01 <merijn> dcoutts: Thanks
08:06:05 <dcoutts> dmwit: right, it's always been non-interactive, but there are case where it might help
08:06:32 <sm> ok, other solutions could help. This one just seems simple and follows precedent
08:06:45 <kenjin1> .
08:06:54 <dcoutts> dmwit: we could make some bits interactive with a flag, and let people put it in their ~/.cabal/config but it's a bit of a cop-out, few people will do it
08:07:25 <dcoutts> dmwit: the real decision is whether we make it interactive by default (with an opt-out) or leave it as is
08:08:06 <NemesisD> hi all. when trying to install hunit i get "cannot satisfy -package Cabal-1.10.1.0: Cabal-1.10.1.0-.... is unusable due to missing or recursive dependencies: process-1.0.1.5
08:08:22 <NemesisD> i have installed process-1.0.1.5 though
08:08:42 <sm> I don't always remember to check what's happening with dry, and my experience is every couple of days I will find I can't build something or other and have to spend a half hour or three cleaning things up
08:09:24 <sm> and I'm pretty handy with ghc-pkg/cabal by now
08:09:28 <dcoutts> sm: I've got another plan for that, but this margin is too small to write it
08:09:37 * dcoutts disappears
08:09:41 <sm> :)
08:10:04 <sm> dcoutts++
08:13:02 <NemesisD> it seems as though i may have a global and user package for process. which should i unregister?
08:13:37 <byorgey> probably user
08:14:43 * sm reinstalls 75 packages without breaking a sweat
08:14:55 <NemesisD> and so it begins. that breaks Cabal-1.8.0.6, when i cabal --version, it reports 1.10.1.0, so is it safe to unregister user's process and cabal packages?
08:16:30 <byorgey> NemesisD: I'd imagine so.
08:17:22 <byorgey> unregistering user packages should always be safe, you just might have to reinstall some things
08:25:15 <monochrom> not always, but yes assuming common practice
08:26:10 <Saizan> it won't break the packages installed globally
08:27:18 <monochrom> sorry, it is always safe
08:39:53 <finnomenon> do any of you know of a trustworthy site similar to drugbuyers.com ?
08:40:04 <Zao> finnomenon: Hello, troll.
08:40:10 --- mode: ChanServ set +o pumpkin
08:40:13 <finnomenon> wrong channel :(
08:40:14 <finnomenon> sorry
08:40:37 <pumpkin> it looked like a disguised attempt at advertising that site
08:41:14 <Zao> Who needs drugs when they have Haskell?
08:41:22 --- mode: copumpkin set -o copumpkin
08:41:25 <ezyang> "I can see... forever!"
08:41:37 <finnomenon> it is/(was?) a site that compared online pharmacies
08:41:38 <osfameron> the come down from haskell is rough though :-(
08:41:47 <finnomenon> I'm still trying to get into haskell
08:42:02 <osfameron> which reminds me... I should resurrect Monadwars...
08:42:13 <finnomenon> I was going to start by building a blog with yesod, but I'm having trouble installing it with cabal
08:48:17 <Lemmih> finnomenon: There's always the Silk Road Market.
08:49:09 <finnomenon> I'm not looking for drugs drugs. I was trying to see if an online pharmacy was legitimate
08:50:00 <finnomenon> when I try to install yesod with cabal I get exitfailures for file-embed and language-javascript
08:50:17 <Lemmih> finnomenon: The real error message should be higher up.
08:51:39 <finnomenon> http://pastebin.com/njB2Zgsb
08:51:42 <mauke> The paste njB2Zgsb has been copied to http://hpaste.org/47403/httppastebincomnjb2zgsb
08:52:22 <finnomenon> that's the error I get
08:52:22 <Saizan> you need a different version of ghc to install that version of file-embed
08:53:03 <finnomenon> I will try installing a newer one, thank you
08:57:13 <k0ral> there is a difference between versions x.0 and x, isn't there ?
09:00:40 * hackagebot hbro 0.4.4 - A suckless minimal KISSy browser  http://hackage.haskell.org/package/hbro-0.4.4 (koral)
09:04:53 <monochrom> there is a difference between version x.0 and version x
09:05:50 <k0ral> I suppose I should always append a ".0" at the end of versions
09:06:34 <k0ral> at least when it's a "short" version like "1"
09:06:38 <Jafet> > "1" ++ cycle ".0"
09:06:40 <lambdabot>   "1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0....
09:06:45 <monochrom> following the recommended versioning scheme, you should at least have 3 numbers in every version number, e.g., 4.0.0
09:06:51 <lee_> Hey, does anyone know a way to display a POSIXTime that shows days, hours, minutes, etc?
09:07:21 <lee_> "show value" gives a big integer followed by an s for seconds
09:07:34 <k0ral> monochrom: I followed the recommended but in case I fell into 4.0.0 I used to write 4, which I realize is wrong
09:08:14 <lee_> Wouldn;t be a lot of work to write but sure seems like reinventing the wheel
09:08:28 <monochrom> actually the recommended scheme doesn't exactly say you must have 3 numbers present, just assigns meanings to those 3 numbers, but then you will find yourself eventually having all 3 anyway
09:09:01 <monochrom> i.e., eventually you will end up with 4.15.785 even if you began with 4 a long time ago
09:09:25 <Phyx-> Saizan: still here? I added a function so I could read the values in the Context, and when I do read them, they'll all there and it works, without reading them it doesn't. It seems like a weird evaluation but or something. Context is a StablePtr (IORef [ExtensionFlag])
09:10:10 <monochrom> so 4 alone is not wrong, it's just unusual
09:10:30 <k0ral> monochrom: the thing is, if I use "4", people won't be able to write dependencies like " == 4.*"
09:10:35 <Phyx-> Saizan: the code i use to update it is in http://pastebin.com/qrN2DWg6
09:10:38 <mauke> The paste qrN2DWg6 has been copied to http://hpaste.org/47404/httppastebincomqrn2dwg6
09:11:00 <k0ral> (although I hardly think about people using my library...)
09:11:17 <Phyx-> heh, mauke is copying every paste?
09:11:32 <k0ral> (...which is an empty set)
09:11:36 <Twey> Is mauke now half-pastebot?
09:11:48 <fxr> uh, what happened to monads-fd package
09:12:00 <Twey> What's the {- @@ … @@ -} syntax about?  I've seen that a bit lately
09:12:19 <Phyx-> Twey: pragmas for my tool
09:12:25 <Twey> Ah
09:12:47 <Cale> What does your tool do?
09:12:50 <Phyx-> same with -- @@
09:13:03 <monochrom> "== 4.*" will successfully pick 4, in fact
09:13:19 <monochrom> ">= 4.0" is the one not picking 4
09:13:31 <k0ral> ah ?
09:13:56 <Phyx-> Cale: generates from a haskell file a static lib, along with the c/c++/c# structures and functions to call the haskell functions, all the marshalling information etc in
09:14:03 <k0ral> what about ">= 4.0 AND <= 4.0" ? (can't remember the syntax of AND...)
09:14:18 <monochrom> cabal install --dry-run --constraint='Agda == 2.2.10.*' Agda  gets you Agda 2.2.10
09:14:49 <k0ral> actually I can answer my own question
09:14:55 <k0ral> since you said 4.0 > 4
09:15:14 <monochrom> >= 4.0 && <= 4.0 will not pick 4
09:15:17 <k0ral> but this is an unexpected behavior having == 4.* matching "4"
09:15:35 <monochrom> hehehe
09:15:42 <lpsmith> can anybody explain what's going on here:  http://hpaste.org/47405/incoherent_type_error
09:16:24 * ski wonders if it would have been better to have a specified non-comment syntax for pragmas, like in Mercury
09:16:48 <Twey> Nah.  Why bother?
09:16:49 <quicksilver> lpsmith: ghci has different defaulting behaviour, I think, is what you're seeing.
09:16:54 <Phyx-> ski: I still need it to be compilably by ghc
09:17:01 <Twey> Phyx-: Not you
09:17:03 <Twey> Just in general
09:17:03 <Phyx-> oh
09:17:18 <lpsmith> quicksilver: hmm, is there a link for details?
09:17:33 <quicksilver> unfortunately I do not recall the details.
09:17:42 <quicksilver> Is it that ghci has extended-defaulting on by default?
09:18:11 <lpsmith> is there {-# LANGUAGE ExtendedDefaulting #-} ?
09:18:18 <quicksilver> adding a type signature to something will fix it, although I'm not familiar with Data.Aeson
09:18:23 <Phyx-> this is driving me nuts...
09:18:34 <lpsmith> quicksilver: yes it will.
09:18:43 <quicksilver> if, as your filename suggests, Data.Aeson uses IncoherentInstances then I hope I never do become familiar with it.
09:18:51 <lpsmith> hah!
09:18:57 <lpsmith> yes it does
09:19:05 <ski> Twey : well, it might be irritating to have lots of tools each abusing comments for pragmas, each in their own way
09:19:39 <monochrom> I am not convinced that incoherent instance is robust against minor changes in compiler
09:19:41 <lpsmith> ski:  I was at a haskell meetup about a week ago;  and nobody in the room had ever heard of Mercury.  Well, except one.
09:20:29 <lpsmith> and me
09:20:30 <quicksilver> find . -name '*.hs' | xargs egrep -l '(Incoherent|Overlapping)Instances' | xargs rm
09:20:34 <monochrom> or perhaps overlapping instance
09:20:39 <djahandarie> Mercury? The DVCS?
09:20:46 <ski> no
09:20:54 <djahandarie> Oh, that's Mercurial anyways
09:21:00 * djahandarie wonders what Mercury is
09:21:11 <Saizan> Phyx-: i suspect something is reading from the IORef out of your lock
09:21:24 <Silvah> djahandarie: http://www.mercury.csse.unimelb.edu.au/ probably.
09:21:32 <ski> djahandarie : <http://www.mercury.csse.unimelb.edu.au>
09:21:44 <djahandarie> Ah, I see.
09:21:46 <monochrom> mercury is a logic programming language and not kludgy like prolog
09:22:07 <ski> (also #mercury)
09:22:16 <Phyx-> Saizan: i
09:22:24 <Saizan> Phyx-: i'm not of much help :)
09:22:45 <scree> quicksilver: that would have the effect of deleting large chunks of ghc I guess
09:22:53 <Phyx-> Saizan: i'll audit the entire file then, but what's killing me is that doing somekind of I/O action on it makes it work.
09:23:36 <kmc> GHC has "annotations" in addition to pragmas
09:23:44 <kmc> annotations are arbitrary Haskell expressions
09:23:51 <monochrom> doing some I/O or doing some allocation changes thread scheduling
09:25:21 <mercury^> Oh. I thought someone was interested in me. ☹
09:25:21 <Phyx-> but it's all on 1 thread. unless i'm being bitten by some kind of lazyness, e.g. the value is not really written out to the IORef then..
09:25:33 <lpsmith> ahh yes, ExtendedDefaultRules will "fix" my example.
09:25:41 <mjrosenb> @src join
09:25:42 <lambdabot> join x =  x >>= id
09:25:46 <kmc> funny, i was just doing some logic programming
09:25:49 <kmc> maybe this is a sign :)
09:25:55 <mjrosenb> oh god, that does work :(
09:25:58 <djahandarie> mercury^, I'm interested!
09:26:19 <mercury^> Aww, thanks. =)
09:26:37 <Saizan> Phyx-: that shouldn't happen unless there's some unsafePerformIO/InterleaveIO in the mix
09:26:38 <lpsmith> Mercury has a repl
09:26:45 <Twey> ski: *shrug* Just have a convention that pragmas are introduced by {- <symbol> … pragma … <symbol> -} or -- <symbol> … pragma …
09:26:49 <lpsmith> err,  *does not have a repl
09:26:56 <lpsmith> Mercury needs a repl
09:27:01 <Twey> Which is basically what happens/has happened anyway
09:27:01 <zygoloid> mercury^: > 1 + 1
09:27:16 <mercury^> zygoloid: 2
09:27:25 <zygoloid> lpsmith: :p
09:27:26 <ski> lpsmith : it has a procedural debugger, which to some extent can be used as a rppl
09:27:33 <Twey> mercury^: > exitFailure
09:27:44 <mercury^> Twey: 1
09:27:50 <Twey> Hehe
09:30:03 <Phyx-> Saizan: There is... in the marshalling code for arrays/lists.
09:31:24 <ski> lpsmith : <http://www.mercury.csse.unimelb.edu.au/information/doc-latest/mercury_user_guide/Interactive-query-commands.html>
09:35:03 <aristid> preflex: seen yitz
09:35:03 <preflex>  yitz was last seen on #haskell 2 days, 10 hours, 25 minutes and 41 seconds ago, saying: aavogt: true, it's certainly not as fundamental as a fold or filter. but it's an extremely powerful tool.
09:38:16 <kmc> is there any advantage to the Logic monad over [], if i'm not using any of the MonadLogic functions?
09:39:33 <ski> i suspect `mplus' is still fair
09:39:37 <c_wraith> I think the traversal order allows you to bind an infinite list
09:39:43 <c_wraith> ...  usefully
09:40:26 <ski> (kmc : ooi, what LP were you doing ?)
09:41:42 <kmc> solving kakuro puzzles
09:46:51 <lpsmith> ski: thanks
09:47:06 <lpsmith> kmc:  yes
09:47:49 <lpsmith> kmc,  one I know of is that the logic monad doesn't share values,  which can easily lead to large space leaks
09:48:36 <Phyx-> it'll take a few days work, but I think I can ditch every single unsafePerformIO... (bout 3 calls)
09:53:01 <Phyx-> and it'll save me from getting chased by people with pitchforks
09:54:07 <ski> > logicToList (listToMonadPlus [0 ..] `mplus` listToMonadPlus [-1,-2 ..])
09:54:08 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
09:54:19 <ski> > let ma0 `mplus` ma1 = listToMonadPlus [True,False] >>- \b -> if b then ma0 else ma1 in logicToList (listToMonadPlus [0 ..] `mplus` listToMonadPlus [-1,-2 ..])
09:54:20 <lambdabot>   [0,-1,1,-2,2,-3,3,-4,4,-5,5,-6,6,-7,7,-8,8,-9,9,-10,10,-11,11,-12,12,-13,13...
09:54:22 <Phyx-> well, better hop to it.. thanks Saizan
09:55:00 <ski> so it seems that for some reason `mplus' on `Logic' isn't fair
09:56:56 <jmcarthur> i was under the impression that if it was fair then it would violate a law or something
09:57:14 <ski> hm. could be, i suppose
09:57:48 <jmcarthur> but wait... what isn't fair about the above result?
09:58:01 <jmcarthur> oh i misread it
09:58:09 <ski> it never reaches the negative solutions in the first example
09:58:12 <jmcarthur> yeah
09:58:37 <ski> (you could be more accurate by saying that it's not complete)
09:59:05 <ski> (`any (< 0)' will terminate on the latter, but not on the former)
09:59:25 <Jafet> @hackage control-monad-omega
09:59:25 <lambdabot> http://hackage.haskell.org/package/control-monad-omega
09:59:52 <jmcarthur> Warning: Omega is only a monad when the results of runOmega are interpreted as a set; that is, a valid transformation according to the monad laws may change the order of the results. However, the same set of results will always be reachable.
10:00:12 <ski> oh, right
10:00:20 <ski> yeah, that's probably the issue
10:00:28 <Jafet> "Omega is only a monad when the results of runOmega are interpreted as a set [..]" bah I got the subwoofer
10:00:36 <ski> or, hm
10:00:49 <kmc> my first kakuro solver used Yices
10:00:52 <kmc> which is... overkill
10:00:57 <Jafet> Heh
10:01:05 <kmc> but i had to write it in limited time
10:01:20 <ski> which monadic law would that break (if `mplus' was fair) ?
10:02:15 <Jafet> That depends on what the monad is, doesn't it
10:02:16 <ski> @let let mplusLogic :: Logic a -> Logic a -> Logic a; ma0 `mplusLogic` ma1 = listToMonadPlus [True,False] >>- \b -> if b then ma0 else ma1
10:02:16 <lambdabot>   Parse error: ;
10:02:20 <ski> @let mplusLogic :: Logic a -> Logic a -> Logic a; ma0 `mplusLogic` ma1 = listToMonadPlus [True,False] >>- \b -> if b then ma0 else ma1
10:02:21 <lambdabot>  Defined.
10:03:23 <ski> > logicToList ((listToMonadPlus [0,3 ..] `mplus` listToMonadPlus [1,4 ..]) `mplus` listToMonadPlus [2,5 ..])
10:03:25 <lambdabot>   [0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,...
10:03:32 <ski> > logicToList (listToMonadPlus [0,3 ..] `mplus` (listToMonadPlus [1,4 ..] `mplus` listToMonadPlus [2,5 ..]))
10:03:33 <lambdabot>   [0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,...
10:03:43 <ski> hm
10:04:27 <b0fh_ua> Hi! I have list of functions [(a->b)] and I want to apply them to single argument a and get [b]. How can I do that with map?
10:04:58 <Jafet> map (\f -> f a)
10:05:08 <b0fh_ua> and w/o lambda?
10:05:14 <b0fh_ua> aha
10:05:15 <ski> > map ($ (pi / 2)) [cos,sin,tan]
10:05:16 <lambdabot>   [6.123233995736766e-17,1.0,1.633123935319537e16]
10:05:18 <b0fh_ua> map ($)
10:05:28 <b0fh_ua> thanks a lot
10:05:43 <b0fh_ua> may be you could explain how ($) works?
10:05:51 <Jafet> @src ($)
10:05:51 <lambdabot> f $ x = f x
10:05:58 <b0fh_ua> nice
10:06:01 <ski> > [cos,sin,tan] `flip` (pi/4)
10:06:03 <lambdabot>   [0.7071067811865476,0.7071067811865475,0.9999999999999999]
10:06:11 <djahandarie> lol
10:06:19 <djahandarie> Nice use of Functor flip
10:06:41 <djahandarie> :t flip
10:06:42 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
10:06:51 <Jafet> :t id
10:06:52 <lambdabot> forall a. a -> a
10:06:56 <Jafet> Sigh
10:07:03 <ski> > ($ (pi / 4)) . [cos,sin,tan]
10:07:04 <lambdabot>   [0.7071067811865476,0.7071067811865475,0.9999999999999999]
10:07:20 <djahandarie> > Just cos `flip` (pi/4)
10:07:22 <lambdabot>   Just 0.7071067811865476
10:07:33 <ski> Jafet : what did you expect ? :)
10:08:06 <djahandarie> ski, maybe Control.Category.id
10:08:23 <djahandarie> Who needs those pesky functions anyways? :)
10:09:54 <ski> lenses form a category
10:11:37 <KirinDave> So I was thinking I'd like to build a markdown->html conversion in haskell for my next teach-myself-haskell project
10:11:50 <KirinDave> But I gotta confess I go no idea where to even start.
10:12:05 <KirinDave> I think I'd use Text for representating data, maybe? And parsing markdown isn't impossible.
10:12:24 <KirinDave> But I was wondering if anyone could recommend a project or two that has approachable code
10:12:29 <b0fh_ua> Couldn't match expected type forall b. [[b]]'
10:12:30 <KirinDave> So I could get an idea of how to structure things
10:12:38 <b0fh_ua> with actual type [[b]]
10:12:41 <b0fh_ua> what does it mean?
10:12:54 <ski> b0fh_ua : are you doing higher-rank code or what ?
10:13:09 <Jafet> @quote generalisation
10:13:09 <lambdabot> ksf says: ...premature generalisation is the root of all procrastination.
10:13:21 <Jafet> @quote benmachine generalisation
10:13:21 <lambdabot> benmachine says: unsafeCoerce is just a generalisation of id
10:13:34 <monochrom> haha
10:14:38 <kmc> KirinDave, pandoc is well-regarded
10:14:45 <kmc> and contains a markdown->html converter
10:15:06 <kmc> in fact it's one of the best structured text converter programs, even if you don't care that it's written in Haskell ;)
10:16:00 <kaini> @src gcd
10:16:01 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
10:16:01 <lambdabot> gcd x y = gcd' (abs x) (abs y)
10:16:01 <lambdabot>    where gcd' a 0  =  a
10:16:01 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
10:16:13 <b0fh_ua> ski: http://pastebin.com/My5nZE9P
10:16:14 <mauke> The paste My5nZE9P has been copied to http://hpaste.org/47407/httppastebincommy5nze9p
10:16:15 <b0fh_ua> like that
10:16:21 * ski cringes at `gcd'
10:16:38 <monochrom> take away "s :: [[b]]"
10:16:39 <kmc> mauke, nice, you copy pastes automatically?
10:17:02 <monochrom> indeed "s :: [[b]]" is where the "forall b. [[b]]" part comes from
10:17:10 <b0fh_ua> yeah
10:17:11 <b0fh_ua> thanks
10:17:21 <ski> b0fh_ua : or `s :: [[Integer]]'
10:18:13 <ski> though, you don't use `s' so you can remove `s@' (and the brackets) from `s@(...) = ..'
10:18:21 <ski> or even better, use `take 3'
10:18:53 <ski> .. or i suppose the list is always having length three
10:19:07 * ski ponders
10:19:23 <djahandarie> Use Vec!
10:19:42 <djahandarie> (If there was a nice Vec package, that is...)
10:23:40 <mm_freak> first public non-commercial yesod website is online =)
10:24:00 <mm_freak> +my
10:27:29 <kmc> mm_freak, which website?
10:27:41 <mm_freak> kmc: http://coder.mx/
10:27:48 <mm_freak> 574 lines of haskell code
10:27:55 <mm_freak> not counting the hamlet/lucius templates
10:28:13 <kmc> cool
10:28:34 <mm_freak> it uses pandoc/markdown for rendering
10:28:48 <kmc> excellent
10:28:53 <kmc> i ♥ markdown
10:29:01 <mm_freak> me too
10:29:32 <luite> is it better than wordpress? :p
10:29:42 <roconnor> lpsmith: I've switch to using projective coordinates, so now I don't need to divide so often
10:29:43 <mm_freak> next step is to add RSS and separate routes for stylesheets
10:29:50 <Balahla> Need help: Yesterday I installed gtk2hs and ran an example. All was OK.
10:29:59 * hackagebot xine 0.0.0.4 - Bindings to xine-lib  http://hackage.haskell.org/package/xine-0.0.0.4 (JoachimFasting)
10:30:07 <mm_freak> luite: dunno…  compare the features/LoC ratios =P
10:30:34 <Balahla> This morning, I changed nothing on the pc. I tried to run an example again and... Loading package gio-0.12.0 ... can't load .so/.DLL for: libgio-2.0-0 (addDLL: could not load DLL)
10:30:47 <luite> does pandoc solve the compatibility issues with markdown and lhs somewhow?
10:30:59 <mm_freak> luite: lhs?
10:31:04 <mm_freak> literate haskell?
10:31:11 <luite> yes
10:31:14 <mm_freak> yes, it does
10:31:18 <mm_freak> it has a literate haskell mode
10:31:21 <Balahla> WTF!? I was using the same pc and the same configuration I used last night...
10:31:51 <luite> mm_freak: how do you make a level 3 heading in a markdown lhs file with pandoc?
10:31:55 <kmc> what's the issue luite?
10:32:26 <kmc> Balahla, maybe you had some LD_LIBRARY_PATH environment var set in your previous terminal?
10:32:44 <luite> kmc: tht one ^^^  , and the problem that > is used for both source code and lock quotes in bird style lhs
10:32:55 <Balahla> I used winghci both times...
10:33:10 <luite> block quotes
10:33:26 <bos> preflex: seen snoyberg
10:33:27 <preflex>  snoyberg was last seen on #haskell 191 days, 5 hours, 13 minutes and 33 seconds ago, saying: a preliminary search implies this has to do with gcc, any thoughts on how to fix this?
10:33:31 <mm_freak> luite: oh, good question
10:33:36 <luite> ugh my irc is extremely laggeby because I'm downloading an ubuntu iso
10:34:38 <luite> mm_freak: lhs sees those # in the first column as preprocessor directives
10:34:47 <Jafet> Balahla: do not deny the change within yourself. Or your filesystem, or something
10:35:00 * hackagebot attoparsec-text 0.8.5.1 - Fast combinator parsing for texts  http://hackage.haskell.org/package/attoparsec-text-0.8.5.1 (BryanOSullivan)
10:35:02 <luite> or at least ghc does :)
10:35:18 <lpsmith> roconnor: cool.  Though it'd still be nice to improve modinv and the other number-theoretical algorithms.
10:35:30 <roconnor> :)
10:35:46 <luite> mm_freak: I had hoped to use lhs as the "document type" for my own website, but I might reconsider because of these issues
10:36:09 <Jafet> Balahla: so where did ghc expect to find the file, and is it there
10:37:55 <luite> mm_freak: let me know if you find a workaround :)
10:38:07 <Balahla> libgio-2.0-0.dll and libglib-2.0-0.dll are in I:\GTK\bin. I:\GTK\bin is at PATH...
10:42:15 <mm_freak> luite: well, you can of course choose to use only level 1 and level 2 headings and tell pandoc to render them as <h3> and <h4>, for example
10:42:28 <mm_freak> luite: i always use <h1> for the site title only and <h2> for the resource title
10:42:38 <mm_freak> those are rendered automatically by the main template
10:43:00 <mm_freak> <h3> can be used by the document to use sectioning and <h4> for subsectioning
10:48:55 <luite> mm_freak: only two heading levels is a bit limited for longer documents :(
10:52:09 <Egbert9e9> where was i a few hours ago?
10:52:17 <m4k3r> lol?
10:54:03 <hellertime> I think I might be abusing the type system too much with this one: http://hpaste.org/47408/unifying_types
10:54:22 <hellertime> any ideas on how to proceed?
10:54:45 <kmc> the first thing that jumps out is class Scheduleable b where { toSchedule :: b -> [a] }
10:54:49 <fragamus> @type fromList
10:54:50 <lambdabot> forall a (m :: * -> *). (MonadRandom m) => [(a, Rational)] -> m a
10:54:53 <kmc> where does 'a' come from?
10:55:14 <kmc> you're saying that if an instance (Schedulable T) exists, then a value of type T can be converted to *any* type of list
10:55:36 <kmc> so i can say toSchedule :: T -> [Char] and elsewhere toSchedule :: T -> [([Bool], Int)]
10:55:49 <mm_freak> luite: it's a start, until you found a useful solution
10:56:24 <hellertime> ah. that isn't my intent. the type of list should be constrained... can that be hinted to the type checker?
10:56:49 <kmc> maybe you want:  class Scheduleable b where { toSchedule :: b a -> [a] }
10:56:56 <kmc> instance Schedulable YearlyPeriod
10:56:59 <kmc> not (YearlyPeriod a)
10:57:09 <kmc> anyway that's the local fix
10:57:18 <kmc> the bigger question is... what are you trying to accomplish here
10:57:33 <kmc> there's probably a simpler way
10:57:41 <kmc> over-using type classes is a common mistake in Haskell
10:58:53 <kmc> how about:  data Yearly; data Monthly; newtype Schedule p a = MkSched [a]
10:59:04 <kmc> so you can write (MkSched [1,2] :: Schedule Yearly Int)
10:59:12 <kmc> or (MkSched [1,2] :: Schedule Monthly Int)
10:59:23 <hellertime> hmm.
10:59:53 <kmc> alternately using the GADTs extension: data Yearly; data Monthly; data Schedule p a where { MkYearly :: [a] -> Schedule Yearly a; MkMonthly :: [a] -> Schedule Monthly a }
11:00:19 <kmc> that's nice because it forbids nonsense things like Schedule Int Int
11:00:34 <hellertime> I see, yeah I was trying to carry the information in the name, rather than as a parameter...
11:00:49 <hellertime> that could work, and be a hell of a lot simpler
11:03:07 <hellertime> kmc: I hope I understood what you're saying :) I'll play around with this some more
11:05:09 <kmc> sure, feel free to ask more questions if you run into trouble :)
11:05:27 <kmc> as an intro to GADTs i like the GHC manual itself: http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt
11:06:46 <hellertime> i'm sure I will. I sort of jumped into a project with only limited knowledge of this language.
11:07:47 <hellertime> I keep feeling that I've got the hang of it, then I get to a point and realize that I could simplify my functions ever further... and it goes and goes
11:07:55 <kmc> *nod*
11:08:37 <merijn> ok, I need help with dark typing voodoo
11:08:57 <merijn> I'm trying to encode the type system for an AST in Haskell's type system
11:09:07 <merijn> I have something like this: http://hpaste.org/47409/i_want_dependent_types
11:09:11 <kmc> hellertime, maybe focus first on getting the program working at all, and then on encoding more correctness in the types
11:09:17 <kmc> the latter is a more advanced topic, generally
11:09:38 <merijn> I think I really want dependent types, but lacking those is something like this possible in Haskell?
11:09:48 <hellertime> kmc: agreed.thought I tend to walk into the deep end alot!
11:10:03 <Peaker_> merijn: what are you trying to do there?
11:10:18 <kmc> is a value of type Type supposed to represent an object-language type?
11:10:22 <Peaker_> enumerate an open set as a closed set?
11:10:41 <kmc> then it would be "Func :: Type a -> Type b -> Type (a -> b)"
11:10:59 <kmc> or, to be more consistent with the previous stuff, "data Fun a b;  ... Func :: Type a -> Type b -> Type (Fun a b)"
11:11:10 <hellertime> kmc: what I'm doing is building a little declarative language ontop of haskell functions, to generate recurring dates, and I want the types to carry scope to prevent odd contexts like "Months in a Week"
11:11:24 <merijn> kmc, Peaker_: I'm (trying to) write a compiler for a statically typed Javascript dialect. I wanted to see if I could encode the typing info of the input language in the AST
11:11:32 <Peaker_> GADTs make phantom types so common... It seems a bit as if the use of "real" types in phantom types' positions is misleading
11:12:35 <Peaker_> merijn: why do you need a GADT here?  Why not something like:  data Type = Undefined | Null | Boolean | Str | Number | Func Type Type | ... ?
11:13:15 <Peaker_> merijn: The AST itself may be useful as a GADT, not sure the Type is
11:13:49 <merijn> Peaker_: Yeah, I know I can do it that way, but as I said I wanted to see if I could encode the typing inside haskell's type system. But I think that may not be achievable without dependent types
11:13:53 <Peaker_> I guess maybe it is... hmm :)   merijn so why not use what kmc suggested?
11:14:13 <Peaker_> merijn: why not start with the AST encoding, rather than the type encoding?
11:14:29 <merijn> Peaker_: I already have a basic AST encoding
11:15:00 <merijn> kmc: Hmm, I think that might be what I tried to do, I'll have to try
11:17:44 <kaini> @src divMod
11:17:45 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
11:19:08 <Peaker_> merijn: And now you want to parameterize each AST node by some Haskell type?
11:19:25 <Peaker_> merijn: not sure why you want dependent types for  Func :: Type a -> Type b -> Type (a -> b)
11:20:15 <Saizan> i've never seen anyone managing to embed a language supporting polymorphism that way
11:20:37 <merijn> Peaker_: Yeah, that seems to work. The initial idea I came up with would be to have a type level list, but that of course isn't possible.
11:20:58 <merijn> Saizan: I'm not ruling out this will prove impossible and show me to be clinically insane :>
11:21:03 <Peaker> merijn: list of what?
11:21:11 <ezyang> Nothing wrong with type level lists :-)
11:21:15 <merijn> s/out/the option that/
11:21:24 <merijn> Peaker: A type level list of types :p
11:21:31 <kaini> @src pred
11:21:31 <Peaker> merijn: but there are just 2?
11:21:31 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
11:21:49 <merijn> Peaker: This way it ends up encoding functions by currying
11:22:20 <merijn> Which ends up as close enough for emulating a fixed list of input parameters
11:25:30 <lpsmith> it would be nice if I could easily search hackage for packages that use a given language extension
11:25:50 <bos> http://www.serpentine.com/blog/2011/06/03/attoparsec-0-9-a-major-release/
11:25:58 <bos> ^^^ read on, folks
11:26:55 <dolio> Huh, attoparsec didn't have try before?
11:27:24 <Peaker> I want an Applicative parsing library that doesn't do backtracking but optimized automata
11:28:28 <Peaker> bos: that seems to explain how he chose speed over correctness
11:28:49 <Peaker> you could already factor out the char 'f' for efficiency before, couldn't you?
11:29:02 <c_wraith> Not completely
11:29:14 <c_wraith> the <|> combinator would still hold backtracking information
11:29:28 <c_wraith> this change removes that being the automatic behavior
11:29:47 <Peaker> makes my case for optimized automata more compelling
11:29:52 <Peaker> can have more speed and elegance
11:30:03 <c_wraith> also, bos is the author of attoparsec :)
11:30:28 <dolio> There's nothing incorrect about try.
11:30:54 <Peaker> dolio: it seems "incorrect" to me that <|> "leaks" left parser failure state to the right parser
11:31:04 <ben> If I understand that blog post correctly, the parser without try used to do the right thing and now doesn't, and needs try to be correct
11:31:42 <ddarius> It's not wrong versus right, it is a legitimate design choice for <|> to be asymmetric.
11:31:43 <Peaker> bos: maybe add a new "efficient" <|> that is fast, and have the old <|> be backwards compatible and "try" always?
11:32:18 <ddarius> In fact, this is one of the key choices for PEGs.
11:32:25 <Peaker> ddarius: it seems like more complex semantics to have parsers that fail still change the parse state
11:32:51 <Peaker> I never really liked monadic parsers anyway :-)
11:33:52 <ddarius> If you are thinking at the level of "changing parse state" then I would look elsewhere for the complexity.
11:34:17 <monochrom> call it <| or |>
11:34:45 <ddarius> monochrom: Usually </> is used.
11:35:10 <Peaker> ddarius: when would it be useful semantics for <|> to partially parse and then give up, and then continue parsing via the right parser?  It seems to make parsers less composable because now the left parser cannot be treated as an opaque parser, you need to know the details of its potential parse failures
11:35:40 <c_wraith> indeed, non-backtracking choice is non-composable.
11:35:41 <Peaker> It seems like it would be useful only if left side immediately fails to parse..
11:36:03 <dolio> It doesn't keep parsing. It's an error.
11:36:21 <Peaker> dolio: if the left parser parsed a bit, then failed, doesn't it continue parsing via the right-parser?
11:36:29 <dolio> No.
11:36:46 <c_wraith> "parse failed" and "this didn't match" are different states.
11:37:04 <ben> 'At this point, the left branch will fail because it cannot match 'o' against the input of "i". The <|> combinator will switch to executing the right branch, but it will not reset the input. At this point, the right branch will attempt to match 'f' against an input that is still "i", and will thus fail.'
11:37:05 <Peaker> dolio: From the link: """The left branch will succeed on its first match against 'f', so the input will become "i" after 'f' has been consumed. At this point, the left branch will fail because it cannot match 'o' against the input of "i". The <|> combinator will switch to executing the right branch, but it will not reset the input. At this point, the right branch will attempt to match 'f' against an input that is still "i", and will thus fail"""
11:37:29 <dolio> Well, that's very odd behavior.
11:37:39 <Peaker> this means that the right side parser needs to be aware of left-side parser failure mods
11:37:46 <dolio> It's not what Parsec does, for instance.
11:37:57 <ddarius> Well, I'll agree that -that- behavior is wrong.
11:38:06 <ddarius> Or at least highly confusing.
11:38:09 <dolio> If the left side commits by parsing something, and then fails, then the whole expression should be a parse error.
11:38:29 <Peaker> it would be nice if it continued to the right side *iff* the left parser failed immediately..
11:38:44 <dolio> Yes, that is how Parsec works.
11:38:59 <Peaker> I thought parsec back-tracked?
11:39:10 <dolio> It only backtracks if you use try.
11:39:23 <dolio> Otherwise you either fail immediately, or commit to a branch.
11:39:56 <kmc> once input is consumed it's not un-consumed
11:40:07 <kmc> but "try" modifies a parser so that, if it fails, it consumes no input
11:40:07 <bos> the new behaviour of attoparsec is pretty much the same as parsec.
11:40:12 <bos> before, it was not.
11:40:38 <dolio> Was the quoted part the old behavior?
11:40:39 <ddarius> bos: Perhaps you described it incorrectly, or poorly worded that paragraph?
11:42:07 <bos> ddarius: which bit?
11:42:26 <ddarius> [15:03] <ben> 'At this point, the left branch will fail because it cannot match 'o' against the input of "i". The <|> combinator will switch to executing the right branch, but it will not reset the input. At this point, the right branch will attempt to match 'f' against an input that is still "i", and will thus fail.'
11:43:20 <bos> ddarius: i guess i don't understand which part of that is unclear. can you tell me?
11:43:49 <ddarius> bos: If it means what it reads like, then it is definitely not the behavior of Parsec.
11:43:50 <dolio> Why would it enter the second branch with input "i"?
11:44:21 <bos> dolio: because char 'f' succeeded and consumed input on the left
11:44:42 <Peaker> bos: if the left side failed after consuming input, the right side of <|> isn't tried, the entire parser fails (Just tested)
11:44:46 <dolio> In parsec, if that happened, and the left branch failed, the composite parser would fail.
11:44:57 <dolio> The right side wouldn't even be checked.
11:45:28 <bos> oh, now i'm confused.
11:45:30 <Peaker> runParser ((char 'f' >> char 'a') <|> (char 'f')) () "" "fi"      yields Left
11:45:49 <Peaker> bos: only if the left side fails immediately without consuming input in parsec, then the right side of <|> is used, apparently
11:45:57 <bos> Peaker: ah
11:46:33 <Peaker> has anyone implemented context-free automatas in Haskell?
11:47:04 <ddarius> bos: With your semantics, parse (choose (map char "abcd")) "abcd" would succeed.
11:47:43 <bos> ddarius: interesting point.
11:48:17 <bos> well hmm.
11:48:17 <ddarius> \c -> char c >> eof (probably)
11:48:54 <bos> i wonder what to do about that.
11:48:56 <monochrom> I use "atomic" to think about this. char 'f' is atomic. char 'f' >> char 'a' is not atomic. try (char 'f' >> char 'a') is atomic again
11:49:22 <ddarius> monochrom: That's a reasonably good way of thinking about it.
11:49:36 <ddarius> It explains the lexeme parsers.
11:50:06 <monochrom> "software transaction parser"!
11:50:18 <Twey> ‘Atomic’ meaning that it either all succeeds or all fails, with no possibility of it partially succeeding?
11:50:29 <ddarius> Both of which also suggest that you don't "large" (arbitrarily recursive) parsers in a try.
11:50:43 <ddarius> +want
11:50:59 <bos> would be interesting to represent that via types.
11:51:01 <jmcarthur> hmm... it would be cool if atomicity was in the type system the way it is with, say, STM.
11:51:04 <jmcarthur> beat me
11:51:28 <ddarius> It should be pretty easy to do that.
11:51:57 <Peaker> Monadic/Applicative composition needs to get rid of atomicity -- or you could wrap everything before composing it "non-atomically"
11:52:13 <ddarius> You wouldn't be able to use the normal monadic operators though.
11:52:28 <Peaker> ddarius: you could with some type-class hackery/phantom types
11:52:44 <ddarius> Peaker: Yes, you could use the semantics, you just couldn't use (>>=).
11:52:54 <roconnor> are there ways of taking polynomials in multiple variables and produce an optimal expression with sharing that has the fewest products?
11:52:58 <Peaker> ddarius: I think you could
11:53:02 <ddarius> This is similar to indexed monads and such.
11:53:22 <jmcarthur> >>= could take two non-atomic actions and create another non-atomic action
11:53:33 <roconnor> and can GHC do this for me, kthxs
11:53:42 <Peaker> char 'f' :: Parser a Char  -- "a" can be instantiated to "Atomic" or "Composable".    instance Monad (Parser Atomic) ....
11:54:02 <Peaker> that way    char 'f'  can be used as an atomic parser, or as a composable one and directly used with (>>=)
11:54:03 <ddarius> You'd want Atomic >> Atomic = NonAtomic
11:54:20 <Peaker> instance Monad (Parser Composable) ...   above there
11:54:21 <jmcarthur> yeah i wouldn't want >> having an implicit try around the whole thing
11:55:01 <Peaker> the atomic parsers could have a polymorphic phantom type that can be either atomic or not.  (>>=) can require composable parsers and yield a composable parser specifically
11:55:23 <Peaker> I think this would work non-disruptively
11:55:34 <Peaker> (allow existing combinators to be used similarly, but still have types mark things as atomic or not)
11:55:51 <dolio> Joining two atomic parsers in sequence generates a non-atomic parser.
11:55:58 <ddarius> (Also, technically, (>>) would have more finesse than that, e.g. return () >> return () should still be atomic.)
11:56:33 <dolio> Yes. And p >>= return is presumably as atomic as p.
11:56:53 <ddarius> Peaker: You're going to have some operations that want specifically atomic parsers to work properly, and that will specialize the types of some of these parsers in ways that will make that not work.
11:57:16 <Peaker> ddarius: example?
11:57:56 <ddarius> Peaker: You may have a parser parameterized by lexing combinators where you want all the lexing combinators to be atomic.
11:58:58 <monochrom> "atomic" means that "atomic'parser <|> blah" if anything goes wrong with atomic'parser we will go with blah
12:00:07 <ddarius> Anyway, presumably one of the points of this exercise, would be to statically check the condition monochrom just mentioned.
12:00:08 <monochrom> "non-atomic" means that "non'atomic'parser <|> blah" if a non-empty prefix is accepted by non'atomic'parser we will not consider blah
12:00:44 <monochrom> and thus I succeed in not talking about consuming input and unconsuming input
12:01:08 <ddarius> monochrom: You've only changed words.
12:02:11 <monochrom> darn
12:02:39 <ddarius> monochrom: Or you've seriously underspecified "atomic," though you could correct that with a (more) complete axiom system for it.
12:03:03 <monochrom> perhaps underspecifying is good
12:03:42 <ddarius> I didn't just say "underspecified."
12:04:27 <monochrom> I think in this case even seriously underspecifying is good
12:04:38 <roconnor> will GHC optimize let z = 0 in a + z*b into a for Integers?
12:04:39 <ddarius> The problem is: is atomic'parser >> return 3 atomic?  You could claim that your definition characterizes that, but then all you've done is changed words, because the condition is whether it consumes input or not.
12:04:51 <ddarius> roconnor: Probably.  You can find out.
12:05:11 <monochrom> ah that needs to be covered, yes
12:11:10 <bos> well, i seem to have given myself an awkward headache with this change.
12:14:55 <Saizan> bos: now the documenation for string makes sense, at least :)
12:15:03 <bos> true
12:30:26 <lee_> how does one do a monadic if, as in 'if (condition) then (actions >>= return) else (actions >>= return)
12:30:47 <kmc> what's wrong with what you said?
12:30:58 <kosmikus> lee_: there's nothing special about using if in a monadic context
12:31:00 <kmc> also, "x >>= return" is equivalent to "x"
12:31:01 <monochrom> what's wrong: ">>=return" is redundant
12:31:39 <monochrom> if x>y then putStrLn "hi" else writeFile "blah" "hi"
12:31:47 <monochrom> I do that all the time
12:32:02 <lee_> I'm having trouble getting it to work...must just have a type error in the (actions)
12:32:11 <monochrom> or indentation
12:32:14 <Jafet> But remember kids, put your longer clause after else do
12:32:15 <Twey> You also don't need brackets around them.
12:32:15 <roconnor> I had sharing subexpressions by hand >:(
12:32:38 <lee_> could be, monochrom
12:32:45 <monochrom> you should share subexpressions by hand. until compilers are smarter than you
12:33:00 <Jafet> Until you buy more RAM
12:35:36 <roconnor> monochrom: they are smarter than me
12:36:32 <lee_> was indeed indentation, thks again all
12:38:17 <Jafet> It still doesn't work right because they're not smarter than monochrom
12:39:03 <monochrom> over my dead body!
12:40:24 <lee_> not like to share...I failed code reuse in kindergarten
12:40:49 <Jafet> I failed due to laziness
12:43:07 <b0fh_ua> Hi. I'm trying to understand how co-recursion works. I tried to implement prime numbers filtering like this: http://pastebin.com/WuTPBrJL - but it hangs on "take 7 primes". What am I doing in wrong way?
12:43:09 <mauke> The paste WuTPBrJL has been copied to http://hpaste.org/47412/httppastebincomwutpbrjl
12:44:43 <Jafet> b0fh: all
12:45:16 <Jafet> all blocks until it reaches the end of the list. There is no end to that list.
12:45:41 <b0fh_ua> okay, so I should use any then?
12:45:54 <monochrom> any is something else entirely
12:46:11 <Jafet> Wouldn't it be easier to make sure your list ends somewhere
12:46:20 <monochrom> you should give an explicit "take" when you implement isPrime, rather than relying on x*x<n
12:46:46 <b0fh_ua> so any doesn't short-circuit?
12:47:02 <monochrom> any is based on ||
12:47:19 <monochrom> not even the right logical operator
12:48:01 <Twey> Hmph.  What's a nice, non-horrifically-verbose option-parsing library that will allow me to parse out some options and leave the rest for later processing?
12:49:21 <bos> Twey: cmdargs
12:49:43 <b0fh_ua> monochrom: isPrime n = all ( /= 0) . map (n `mod`) . takeWhile (\x -> x * x < n) $ primes
12:49:46 <b0fh_ua> like that
12:50:09 <b0fh_ua> but why [n `mod` x | x <- primes, x*x < n] doesn't work?
12:50:31 <azaq23> > and $ [False] ++ repeat True
12:50:33 <lambdabot>   False
12:50:41 * roconnor notices the more he uses Maybe () over Bool, the less he uses guard
12:51:08 <djahandarie> You use Maybe () ? What about the extra bottom?
12:51:13 <monochrom> > [ n | n <- [0..], n<10 ]
12:51:17 <lambdabot>   mueval-core: Time limit exceeded
12:51:20 <roconnor> djahandarie: Somehow I survive
12:51:26 <monochrom> > takeWhile (< 10) [0..]
12:51:27 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
12:51:39 <djahandarie> roconnor, :p
12:51:40 <monochrom> is why one doesn't work and the other works
12:51:43 <Twey> bos: CmdArgs allows dismissing some options?
12:51:56 <bos> dismissing?
12:52:09 <Twey> Returning the options that have not been used for later parsing
12:52:12 <Twey> I tried using that first and didn't see a way
12:53:02 <bos> yeah, don't think you can do that.
12:53:07 <bos> seems like an odd thing to need to do.
12:53:12 <Twey> Not really
12:53:29 <Twey> It's common practice in a library that uses some common arguments
12:53:46 <roconnor> hmm apparently I can use 0 as a pattern
12:53:50 <roconnor> ... what does that mean?
12:53:56 <Twey> E.G. GUI libraries usually suck up a --display or --geometry argument
12:53:58 <kmc> x | x == 0
12:54:11 <roconnor> kmc: that only applies to numeric literals?
12:54:15 <kmc> yes
12:54:27 <kmc> for example GHC's runtime system sucks up arguments ;)
12:54:35 <monochrom> actually, a better pair of examples:
12:54:40 <Jafet> > let !0 = 1 in ()
12:54:40 <lambdabot>   *Exception: <interactive>:3:4-9: Non-exhaustive patterns in pattern binding
12:54:55 <monochrom> > [ n | n<-[0,1,0], n<1 ]
12:54:56 <lambdabot>   [0,0]
12:55:06 <kosmikus> roconnor: you generally can use literals as patterns
12:55:07 <monochrom> > takeWhile (< 1) [0,1,0]
12:55:07 <lambdabot>   [0]
12:55:33 <roconnor> kosmikus: what other literals?
12:55:39 <kosmikus> roconnor: characters, strings
12:55:50 <Peaker> any chance Haskell' will replace String=[Char] with String=Text?  And replace the list-specific operations with more polymorphic ones that could work on Text and other containers?
12:55:52 <roconnor> well, those only have one type
12:56:00 <kosmikus> roconnor: floats
12:56:02 <Peaker> [Char] is a bad bad type :-(
12:56:07 <roconnor> though I didn't know about strings
12:56:09 <Twey> > let f 0 _ = 1; f _ m = m in (f 0, f 1)
12:56:10 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
12:56:10 <lambdabot>    arising from a use of `...
12:56:13 <Twey> >.>
12:56:19 <Twey> > let f 0 _ = 1; f _ m = m in (f 0 2, f 1 2)
12:56:20 <lambdabot>   (1,2)
12:56:23 <kosmikus> roconnor: what's the problem with patterns having more than one type?
12:56:24 <Twey> roconnor: ^
12:56:24 <roconnor> > f "hi" = True in f "hi"
12:56:25 <lambdabot>   <no location info>: parse error on input `='
12:56:29 <roconnor> > let f "hi" = True in f "hi"
12:56:30 <lambdabot>   True
12:56:35 <kmc> integer literals as patterns are special though
12:56:42 <Twey> roconnor: You've never encountered this before?  o.@
12:56:47 <roconnor> kosmikus: it is less clear what they mean when you stick them in patterns
12:56:47 <Twey> Or am I misunderstanding something here?
12:56:52 <kmc> character literals work because characters are notionally 0-ary constructors
12:56:57 <kmc> data Char = 'a' | 'b' | ...
12:57:15 <roconnor> kmc: right, but 0 works even on any type declared as Num
12:57:22 <kmc> and string literals work because they're sugar for lists of chars, which is sugar for (:) and [], which are data constructors
12:57:29 <roconnor> ah of course
12:57:35 <roconnor> I guess I did know about strings
12:57:36 <kmc> it's only the numeric literals that actually generate a call to (==)
12:57:57 <Twey> Is this why Eq is in Num?
12:58:01 <kosmikus> kmc: probably string literals work like int literals when used with OverloadedStrings? (haven't tried it)
12:58:07 <kmc> maybe
12:58:24 <kosmikus> now I have. yes they do.
12:59:28 <kosmikus> roconnor: but ok, I see your point. I hadn't realized it might be confusing, but actually, it is.
13:01:00 <roconnor> kosmikus: I was using where I thought I was using an Integer, so no big deal
13:01:14 <roconnor> but then I realized it wasn't an Integer, but a newtype wrapped Integer :O
13:05:28 <kosmikus> roconnor: :)
13:09:45 <Twey> bos: Also, CmdArgs is horrific
13:10:51 <Twey> http://hackage.haskell.org/packages/archive/cmdargs/0.7/doc/html/System-Console-CmdArgs-Implicit.html#g:3 x.x
13:11:25 <kmc> yeah the Implicit stuff is pretty frightening
13:13:09 <bos> Twey: hee hee!
13:18:18 <Twey> I think I might have to learn OptParse
13:18:35 <Twey> Or else write my own parser… I'm trying to decide which one would be more overkill >.>
13:18:57 <bos> OptParse is a pain
13:20:08 <kmc> you can use the Explicit module of CmdArgs
13:20:32 <Twey> kmc: I don't think that handles my use-case either
13:21:07 <Twey> I also looked at ParseArgs, which is nice but… as far as I can tell, also doesn't allow returning unused arguments
13:34:15 <roconnor> algorithmic improvements took my runtime from 1m14s to 15s
13:34:22 <danharaj> nice
13:34:32 <roconnor> there are two ways to deal with a function taking 71% of your code
13:34:35 <djahandarie> Algorithms ftw
13:34:39 <roconnor> 1) optimize the hell out of it
13:34:45 <danharaj> 2) get rid of it
13:34:46 <roconnor> or 2) don't call it as much
13:35:08 <monochrom> "optimize the caller, not the callee"? :)
13:35:13 <roconnor> I changed it from calling reciprocal hundreds of thousands of times to hundreds of times
13:35:21 <danharaj> :o
13:35:22 <monochrom> "don't optimize us, we'll optimize you" :)
13:35:48 <kmc> :t msum . map return
13:35:48 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [a] -> m a
13:35:59 <roconnor> I haven't started into the stupid GHC UNPACK pragma stuff yet :D
13:36:26 <merijn> The only way to deal with optimization problems is the same as the one dealing with bugs :p
13:36:29 <merijn> Deleting code :p
13:36:45 <monochrom> the only way to win is not to code
13:37:02 <merijn> monochrom: I think that way you still lose
13:37:07 <roconnor> Ah there we go.  Now sha256 is taking more time than than EcDSA verification.
13:37:14 <djahandarie> :t Data.Foldable.msum . fmap return
13:37:16 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Foldable.Foldable t, MonadPlus m, Functor t) => t a -> m a
13:39:57 <acowley> What's a good practice for including example code in a caballed project? I have a source file that is useful to compile and run, and it would be neat to include a generated haddock for it along with the package, but not install the example as a library.
13:45:45 <syntaxfree> lambdabot: hi there.
13:49:20 <byorgey> acowley: well, you can list it in Extra-source-files to include it in the tarball
13:49:23 <lambdabot> syntaxfree: hey.
13:49:26 <byorgey> but that won't generate haddock for it
13:49:32 * hackagebot diagrams-core 0.2 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-0.2 (BrentYorgey)
13:49:41 <acowley> byorgey: yeah, that's what I tried, and it's better than not including it
13:50:06 <acowley> byorgey: really what I want is to include a literate haskell file with the docs
13:50:08 <albertid> acowley, I'm just a haskell beginner but repa for example created a second package for that, http://hackage.haskell.org/package/repa-examples
13:50:33 * hackagebot diagrams-lib 0.2 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-0.2 (BrentYorgey)
13:50:35 * hackagebot diagrams-cairo 0.2 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-0.2 (BrentYorgey)
13:50:44 <acowley> albertid: yeah, I had seen that. It's certainly an option.
13:50:56 <acowley> albertid: but I feel like examples aren't treated right by cabal
13:51:10 <acowley> err, that should be cabal-install I suppose
13:51:25 <acowley> I think examples should be runnable, but also easily inspectable
13:51:35 <bos> ddarius: monochrom: you might be amused to know that the fix i made to fix up the semantics of <|> in attoparsec regresed performance to an unacceptable degree.
13:51:43 <albertid> acowley, I've been searching for example / tutorial code with a lot of packages with no success
13:51:46 <acowley> the inspectable part suggests haddock to me, while cabal-install is in the other direction and somewhat hides the source
13:51:48 <monochrom> hehehe
13:51:50 <bos> so i ended up canning those changes.
13:51:54 <bos> sigh,
13:52:10 <bos> so glad i wrote a blog post about it all, so my error could be found quickly.
13:52:14 <acowley> albertid: yeah, it's one of our biggest problems as a community
13:52:24 <jmcarthur> there was an error? oh noes
13:53:18 <davidL> bos: is that what caused my performance issue?
13:53:44 <bos> davidL: i don't know.
13:53:55 <bos> davidL: what version of attoparsec were you using?
13:54:09 <davidL> 0.8.6.1
13:54:12 <Peaker> I want parser automatons..
13:55:08 <Peaker> that way we can have "back-tracking" behavior virtually for free (if we use Applicative and recursive combinators, without monadic ones)
13:55:32 <Peaker> I think it's probably the most compelling example of an Applicative-that's-not-a-Monad
13:56:20 <acowley> Okay, easier (hopefully) question: can I exert any control at all over the order of the modules listed on a haddocked package's main content page?
13:56:22 <syntaxfree> lots of new people around here.
13:57:27 <acowley> as to my earlier question, it is already on SO, and I had already voted it up
13:57:37 <acowley> I am consistent
14:00:16 <cheater_> augur, deontic logic is exactly the kind of logic that talks about relations
14:00:28 <augur> cheater_: er?
14:00:45 <cheater_> if x has to be >=2 and x has to be =< 2.2 then x is around 2 somewhere.
14:00:50 <cheater_> etc etc
14:00:57 <kmc> syntaxfree, aren't there always? :)
14:00:57 <augur> the only deontic logic i know of talks about should and should not
14:01:03 <cheater_> ya.
14:01:06 <augur> ..
14:01:17 <cheater_> wait, what were you talking about?
14:01:18 <augur> yeah you're going to have to explain to me how these two relate
14:01:20 <cheater_> maybe i misunderstood
14:01:37 <augur> because the only deontic logic i know of is completely unlike what you're talking about
14:01:39 <syntaxfree> isn't deontic logic supposed to be about duty or something?
14:01:59 <syntaxfree> j/k.
14:02:03 <cheater_> ok
14:02:05 <augur> syntaxfree: yes
14:02:09 <cheater_> so what were you talking about augur
14:02:12 <augur> that is basically what its about, syntaxfree
14:02:16 <monochrom> acowley: only thing to control that order is names
14:02:20 <cheater_> hello augur
14:02:21 <augur> well, ought-ness not duty, but
14:02:23 <cheater_> earth to augur
14:02:29 <augur> cheater_: chill the fuck out dude
14:02:31 <kmc> http://plato.stanford.edu/entries/logic-deontic/
14:02:32 <roconnor> > replicate 3 =<< "abc"
14:02:33 <lambdabot>   "aaabbbccc"
14:02:35 <cheater_> lol
14:02:44 <syntaxfree> deontic = de-ontic.  deontic ethics is basically a system of ethics that's invariant to the actual matters at hand. that's why "deontic" brings ethics to mind.
14:03:12 <syntaxfree> ontos/ontic = "things". as in "ontology", etc.
14:04:50 <byorgey> actually ontos/ontic = "being"
14:04:53 <syntaxfree> > replicate 7 =<< "zzz"
14:04:55 <lambdabot>   "zzzzzzzzzzzzzzzzzzzzz"
14:05:17 <syntaxfree> > replicate 21 'z'
14:05:18 <lambdabot>   "zzzzzzzzzzzzzzzzzzzzz"
14:05:58 <Egbert9e9> tgeeky: what was i supposed to do again with treeview? i want to make sense out of it
14:07:41 <cheater_> augur, so are you gonna tell us :D
14:07:57 <augur> im thoroughly disinclined to tell you now, cheater_
14:08:27 <cheater_> bummer
14:08:29 <cheater_> maybe one day
14:12:36 * hackagebot free 0.2.2 - Haskell 98 monads for free  http://hackage.haskell.org/package/free-0.2.2 (EdwardKmett)
14:15:36 * hackagebot free 0.2.3 - Haskell 98 monads for free  http://hackage.haskell.org/package/free-0.2.3 (EdwardKmett)
14:19:37 * hackagebot kan-extensions 0.2.2 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-0.2.2 (EdwardKmett)
14:20:43 <roconnor> @type zip5
14:20:45 <lambdabot> forall a b c d e. [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]
14:20:48 <kmc> edwardk seems to have undercut my "Haskell 98 monads, $3.95" deal
14:22:25 <geheimdienst> 2 monads $6.95 and we'll throw in a free burrito
14:24:51 <edwardk> kmc: damn. if I'd known I could have gotten away with charging...
14:25:03 <kmc> Hackage needs a micropayments system
14:25:06 <kmc> using bitcoin, of course
14:25:11 <edwardk> blech
14:25:44 <djahandarie> kmc, I thought those were only good for buying drugs illegally?
14:25:58 <dmwit> They also seem to be a pretty good investment.
14:26:04 <bos> i can't imagine what drug dealer would be stupid enough to take bitcoins.
14:26:05 <kmc> they're also good for dodgy currency speculation... yeah, what dmwit said
14:26:08 <dmwit> Price has doubled in two weeks.
14:26:36 <ezyang> "I am not a currency speculator!"
14:26:37 <kmc> bos, why is it actually risky?
14:26:48 <bos> kmc: it's a ponzi scheme.
14:26:54 <Peaker> Hmm.. There's a Zip class in some packages and in conal's code:  class Zip f where zip :: f a -> f b -> f (a, b)        but why not use   liftA2 (,)  and an Applicative constraint instead?
14:27:00 <djahandarie> bos, there's this thing called 'silkroad' which is pretty much entirely drug trade with bitcoins.
14:27:04 <Peaker> what's the difference between Zip and Applicative + liftA2 (,) ?
14:27:10 <Peaker> @type liftA2 (,)
14:27:10 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
14:27:17 <kmc> bos, how so? (-blah?)
14:27:34 <dmwit> It's not a ponzi scheme. But it definitely is very risky.
14:27:36 * bos isn't very interested in talking about it.
14:27:48 <dmwit> Perhaps #bitcoin would be a good channel to talk about it in. =)
14:28:15 <Peaker> Haskell question ^^^ :-)
14:28:50 <djahandarie> Peaker, because more things are Zip than are Applicative.
14:28:51 <dmwit> Not all Applicative instances do a zip.
14:28:58 <acowley> Peaker: do any Zip instances do anything interesting?
14:29:31 <acowley> dmwit: why wouldn't all Applicatives be a Zip?
14:30:35 <Peaker> djahandarie: example?
14:30:52 <byorgey> [a] -> [b] -> [(a,b)]   -- how many implementations of this can you think of?
14:31:15 <Peaker> byorgey: ZipList and [] Applicative instances are two interesting ones.. there are infinite more uninteresting ones
14:31:18 <djahandarie> Peaker, fwiw, 'Apply' in semigroupoid provides Applicative-like f a -> f b -> f (a, b), and Zip in keys provides Zip-like stuff. Looking at instances there might be interesting
14:31:42 <byorgey> Peaker: indeed.
14:32:04 <byorgey> Peaker: I expect every instance of zip  will be the liftA2 (,) for some Applicative
14:32:17 <byorgey> but depending on the laws you want to hold for zip, not every Applicative will give you a zip.
14:34:04 <byorgey> Peaker: actually, there's an article in the Monad.Reader coming out soon which should help shed some light on this =)
14:34:19 <bos> @pl (a -> Maybe b) -> [a] -> Maybe [b]
14:34:20 <lambdabot> (line 1, column 4):
14:34:20 <lambdabot> unexpected ">"
14:34:20 <lambdabot> expecting variable, "(", operator or ")"
14:34:29 <bos> @hoogle (a -> Maybe b) -> [a] -> Maybe [b]
14:34:29 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
14:34:29 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
14:34:29 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
14:36:04 <djahandarie> (For example, <*> on lists is not a zip, zip on lists is.)
14:37:05 <acowley> What Zip laws are there? They don't seem be documented alongside the Zip class.
14:39:04 <byorgey> you probably want laws like   fmap fst (zip fa fb) == fa  and similarly for snd
14:39:25 <acowley> and those would not be consequences of applicative laws?
14:39:33 <acowley> given liftA2 (,)?
14:39:52 <byorgey> > fmap fst (liftA2 (,) [1,2,3] [4,5,6])
14:39:53 <djahandarie> > fmap fst (liftA2 (,) [1,2,3] [3,4,5])
14:39:53 <lambdabot>   [1,1,1,2,2,2,3,3,3]
14:39:54 <lambdabot>   [1,1,1,2,2,2,3,3,3]
14:39:57 <byorgey> hahah
14:40:07 * byorgey high-fives djahandarie 
14:40:11 <djahandarie> :p
14:40:13 <mustelo> @pl \x -> f (g x) (h x)
14:40:13 <lambdabot> liftM2 f g h
14:40:24 <acowley> geese guys, you don't have to shout! :)
14:40:38 <acowley> I choose ZipList
14:40:44 <Peaker> byorgey: but such a law assumes Functor instance -- I'd think if Zip had any point to it -- it would be for cases that cannot have Functor/Applicative instances
14:41:07 <djahandarie> I think Zip requires Functor.
14:41:15 <acowley> it does
14:41:24 <byorgey> Peaker: I don't think so.  I think assuming a Functor instance is quite reasonable.
14:41:36 <acowley> but I don't mind saying that it could use something more than the zero documentation it currently has
14:41:47 <byorgey> documentation++
14:41:53 <djahandarie> acowley, problem is that edwardk wants to move it out of that package eventually and just hasn't
14:41:56 <Peaker> byorgey: so the Zip class is Applicative + a law restriction?
14:41:58 <djahandarie> So he's probably avoiding it entirely
14:42:04 <djahandarie> Peaker, no, Applicative has pure.
14:42:06 <acowley> djahandarie: documentation can be moved, too
14:42:37 <Peaker> Applicative would be nicer as a subclass of Pointed + Ap
14:42:39 <acowley> the problem with having no documentation is that the reader ends up relying too heavily on suggestive names
14:42:41 <djahandarie> Peaker, 'Apply' is Applicative sans pure, and 'Zip' is Applicative sans pure with different laws.
14:42:51 <Peaker> (that actually defined the methods). Then I could say Ap and people wouldn't bug me about pure :)
14:43:11 <Peaker> Ah
14:43:32 <djahandarie> So, Haskell-wise, Apply and Zip are the same thing.
14:43:36 <Peaker> djahandarie: do the laws of zip or Apply imply one another?
14:43:45 <djahandarie> Nope.
14:44:04 * edwardk looks up
14:44:45 <edwardk> acowley: Zip only has meaning once i know the key exists, they the laws would relate to the other classes in that module.
14:44:50 <acowley> If anyone gets a chance, please do try out https://github.com/acowley/HOpenCV and let me know if it only compiles on machines I administer. If you have a webcam or a video file, then the VideoFunhouse example in the src/Examples directory is a good test
14:45:20 <acowley> edwardk: I think you just confused me more
14:45:30 <edwardk> acowley: did you look at Data.Key?
14:45:32 <acowley> yes
14:45:41 <acowley> oh
14:45:55 <edwardk> Zip lets you merge two containers so that elements with the same key get put together.
14:45:55 <acowley> well, byorgey's specialized version of that is a useful start
14:46:46 <edwardk> Zip is guaranteed to have those semantics even when the Applicative is different (like with [a])
14:47:20 <acowley> why don't you need a monoid constraint somewhere?
14:47:31 <edwardk> how could I?
14:47:40 <acowley> well you said elements with the same key get put together
14:48:03 <acowley> or did you just mean paired together?
14:48:04 <edwardk> yes, but i can't constrain it so that it is a monoid. that would be a constraint on f a, not f
14:48:13 <edwardk> paired. zip :: f a -> f b -> f (a, b)
14:48:32 <acowley> Right, I see
14:48:32 <edwardk> er.. zip :: Zip f =>
14:48:32 <anti-hero> have you guys seen this ? it's an amazing documentary called "Near Science" by some guys who wrote an automatic scientific paper generator called SCIGen and then presented it at a conference :) it's pretty amusing -> http://pdos.csail.mit.edu/cgi-bin/scividredirect.cgi?file=near_science_high.avi
14:48:38 <pedro3005> @hoogle permutations
14:48:38 <lambdabot> Data.List permutations :: [a] -> [[a]]
14:48:56 <Peaker> edwardk: but if you want ZipList semantics, why not use the newtype? Sounds nicer than making a copy-class (or similar class) just for a semantics that can be had with the original general class
14:49:04 <edwardk> the Zip class provides zap, which is basically just zipWith id, and looks more like ap / <(>
14:49:19 <djahandarie> Peaker, guarentees? Applicative doesn't guarentee it, Zip does
14:49:20 <edwardk> Peaker: because I provide Zip instances for LOTS of types
14:49:29 <acowley> Is <(> a quarter section of a tuple?!
14:49:34 <edwardk> also Zip doesn't assume the existence of pure.
14:49:34 <Peaker> acowley: I'm compiling it now -- getting some C header deps
14:49:35 <djahandarie> Albeit, Haskell isn't guarenteeing shit but we can pretend it is.
14:49:40 <edwardk> for instance you can Zip IntMaps
14:49:42 <djahandarie> edwardk, neither does Apply ;)
14:49:42 <geheimdienst> > let (<(>) = 42 in x
14:49:43 <lambdabot>   <no location info>: parse error on input `='
14:49:47 <geheimdienst> > let (<(>) = 42 in 42
14:49:49 <lambdabot>   <no location info>: parse error on input `='
14:49:55 <acowley> Peaker: yes, it needs OpenCV
14:50:01 <edwardk> djahandarie: Zip is Apply with (unstated) laws related it to the behavior of the Key
14:50:06 <edwardk> er relating
14:50:17 <Peaker> acowley: Yeah, I see, just need to do it manually because cabal-install isn't integrated with Ubuntu :-)
14:50:24 <edwardk> in particular Zip is useful when you have things like memo-tries.
14:50:33 <djahandarie> edwardk, also getting rid of the normal monoidal laws, no?
14:50:34 <edwardk> or representable-functors
14:50:43 <acowley> Peaker: Is there is a good way of me doing anything to make it easier?
14:50:57 <acowley> unstated laws are the best kind of laws
14:51:02 <acowley> wait, no, worst
14:51:03 <Peaker> acowley: maybe give an apt-get install line to run as a prerequisite?
14:51:05 <edwardk> well, zipWith (<>) forms a semigroup
14:51:15 <Peaker> I forget what representable functors are
14:51:16 <edwardk> so you have the associativity anyways
14:51:35 <edwardk> f is representable if it is isomorphic to (->) x    — for some x.
14:51:49 <pedro3005> @hoogle power set
14:51:50 <lambdabot> No results found
14:51:52 <Peaker> acowley: hmm.. I installed all the cv-related "-dev" packages from Ubuntu, and I still get "Missing C libraries: opencv_core, opencv_imgproc, opencv_highgui"
14:52:04 <djahandarie> edwardk, something isn't clear to me here. Apply and Zip seem orthogonal.
14:52:05 <pedro3005> is there a haskell function for the set of all subsets?
14:52:15 <pedro3005> but with lists
14:52:28 <acowley> Peaker: the installation instructions on OpenCV's website are fairly detailed, so I didn't want to oversimplify them in an unhelpful way
14:52:40 <edwardk> the most obvious representable functor, is of course (->) x itself. but you can also have stuff like data Pair a = Pair a a — where Pair is representable by Bool, since Bool -> a and Pair a have the same amount of information
14:53:43 <edwardk> djahandarie: Apply isn't constrained to have 'zippy' semantics, but it is constrained to be compatible with Applicative if its present. Zip is constrained to be 'zippy' and is freely allowed to have a completely different Applicative/Apply instance  floating around. This is why I have both Zip and Apply
14:54:43 <djahandarie> edwardk, but is a Zip instance always a potentially valid Apply instance?
14:54:47 <edwardk> > map (tail . inits) $ tails [1,2,3,4]
14:54:48 <lambdabot>   [[[1],[1,2],[1,2,3],[1,2,3,4]],[[2],[2,3],[2,3,4]],[[3],[3,4]],[[4]],[]]
14:54:56 <edwardk> djahandarie: yes
14:55:14 <edwardk> er thats not all subsets, all substrings
14:55:35 <Peaker> acowley: I'm pretty sure OpenCV successfully installed and it still complains
14:55:36 <acowley> Peaker: did you do something like what is described here? https://help.ubuntu.com/community/OpenCV
14:55:48 <acowley> Peaker: those are libraries in the extra-libraries section of the .cabal file
14:56:29 <edwardk> :t filterM (const [True,False])
14:56:30 <lambdabot> forall a. [a] -> [[a]]
14:56:34 <acowley> Peaker: I have them setting in /usr/local/lib, but I always install from source because I'm ornery
14:56:43 <edwardk> > filterM (const [True,False]) [1,2,3,4]
14:56:44 <lambdabot>   [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4...
14:56:46 <edwardk> better
14:57:15 <Peaker> acowley: I've got the packages mentioned there
14:57:45 <acowley> Peaker: this person seems to have encountered the same trouble http://tech.groups.yahoo.com/group/OpenCV/message/77262
14:58:14 <Peaker> I wonder how cabal-install tries to find these libs
14:58:25 <tromp> @src filterM
14:58:25 <lambdabot> Source not found.
14:58:49 <acowley> Peaker: if you have those libs, then maybe just an --extra-lib-dirs will help?
14:58:54 <edwardk> tromp: http://byorgey.wordpress.com/2007/06/26/deducing-code-from-types-filterm/
14:59:40 <Peaker> acowley: ah.. I see, I have "opencv" but not "opencv_core" in pkg-config
15:00:03 <acowley> Peaker: I wonder if it's a version issue? I know they moved things around a bit in recent years
15:00:14 <tromp> thx, edwardk
15:00:38 <Peaker> acowley: I'm guessing it is a "pkg-config" issue...
15:00:39 <acowley> if you're up for hacking, you can change the .cabal file to have opencv in the extra-libraries section, and remove the individual libraries listed there
15:01:16 <acowley> I think that would mean you have 2.1 rather than 2.2
15:01:39 <acowley> which is probably when they moved things around
15:01:39 <Peaker> Yeah I have 2.1
15:02:08 <Peaker> acowley: ah, it's my friend's package (Noam Lewis) originally?
15:02:14 <acowley> I think Willow took over maintainership a bit before that, and starting with 2.2 they've been trying to rationalize the big hairball
15:02:23 <Peaker> A few days ago, he had a daughter born!
15:02:35 <acowley> Peaker: Yes! I started with Noam's original package a year or two ago
15:02:51 <Peaker> he kinda gave up on Haskell I think :-(
15:02:54 <acowley> Peaker: the original doesn't cover much of OpenCV, and I've done drastic things to the interface
15:03:47 <edwardk> hrmm. there are haskell opencv bindings? i should have looked a long time ago! i've been off using it in objective c for a while now.
15:04:37 <acowley> edwardk: mine are probably weirder than anyone else's! :P
15:04:45 <acowley> edwardk: I'm in the midst of writing up a blog post describing them
15:05:01 <Peaker> acowley: changing it to just "opencv" complains still, despite pkg-config finding it
15:05:05 <edwardk> was having fun toying with viewpoint dependent 3d on the ipad, since i have a known screen size and known relative camera position. same with my macbook air camera.
15:05:10 <acowley> edwardk: they've served me well for a couple projects, so I thought I should publicize my fork a little
15:05:42 <acowley> Peaker: is it a path issue? does --extra-lib-dirs not help?
15:05:50 <edwardk> the ipad is nice in that regard (well, so it the air) that i can fall back on the accelerometer to guess relative motion when the viewer goes off out of camera range
15:05:58 <acowley> edwardk: do you track the yaw of the head at all or just translation?
15:06:16 <Peaker> acowley: I'm not sure how cabal decides a library isn't there
15:06:32 <acowley> we're doing something in the lab where we map head movements onto the head of a robot being teleoped via kinect
15:06:39 <edwardk> working to track yaw so i can add stereoscopic 3d
15:07:01 <edwardk> but i haven't come up with a nice way to shade off-axis stereoscopic 3d
15:07:02 <Peaker> kinect has depth-vision, why stereoscopic?
15:07:09 <conal> Peaker: about Zip vs Applicative, i've forgotten exactly, but I can guess a couple of reasons for Zip: when there's no 'pure', and when liftA2 (,) isn't what I want, as with [].
15:07:48 <acowley> conal: today's solution of picking a newtype with an Applicative that meets your needs isn't *that* painful though, is it?
15:07:52 <Peaker> conal: ah, that's what people said so far -- though Applicative minus pure is Apply, and there's the ZipList for these semantics.. Is it a good idea to make new classes rather than newtypes for desired instance semantics?
15:08:30 <acowley> edwardk: you mean for specular highlights and such?
15:09:10 <jamy23> what nic of ghci bot?
15:09:18 <conal> ah. there was some discussion i hadn't read.
15:09:22 <acowley> Peaker: I assume cabal is looking for the lib in the usual places
15:09:26 <conal> acowley: don't know. and i guess 'pure' is still an issue.
15:09:32 <jamy23> :h
15:09:55 <Peaker> acowley: I guess it's a version mismatch -- cause strace shows cabal is trying to build some /tmp c file
15:10:01 <dbpatterson> is there a function that can do: Monad m => (a -> b -> m c) -> m a -> m b -> m c?
15:10:17 <Peaker> acowley: I'll try installing opencv2.2
15:10:26 <acowley> Peaker: thanks, and sorry it's such a nuisance
15:10:27 <conal> Peaker: no i doubt i'd make a new class if i knew of an existing suited one. hadn't heard of Apply when i needed Zip way back.
15:10:27 <edwardk> sorry, i meant anaglyph stereoscopy, red-green glasses and the like
15:10:36 <Peaker> @type ((join .) .) . liftM2
15:10:37 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
15:10:39 <edwardk> if i wan't to use those on the off-axis display i need the yaw
15:10:50 <djahandarie> I think I would define it as   Apply f => Zip f  and just let Zip be a laws typeclass.
15:10:55 <djahandarie> Though people seem to hate those.
15:11:00 <dbpatterson> Peaker: thanks
15:11:04 <Peaker> acowley: they still use svn heh
15:11:37 <acowley> djahandarie: especially when the laws are unstated :)
15:11:45 <djahandarie> acowley, yes, especially then. :p
15:12:16 <acowley> edwardk: does that work well? I've never tried it and have always been suspicious. It works sort-of-okay with print, and I feel like I'd just get a headache from it on a monitor
15:12:52 <jamy23> @hello
15:12:52 <lambdabot> Maybe you meant: help tell
15:12:54 <edwardk> acowley: my problem is the lag means i need to use a fairly shallow 3d depth. i find if you look at something like a computer monitor or ipad, anything more than a 'couple inches deep' swims really badly.
15:13:02 <dbpatterson> Peaker: any reason why this isnt in a standard library? Is it a strange thing to do? (seems like just making bind work with multiple arguments)
15:13:02 <acowley> edwardk: since the face is so large in your images, interocular distance should be pretty accurate for head yaw
15:13:06 <jamy23> @help
15:13:06 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:13:27 <acowley> edwardk: what's the lag due to? image capture?
15:13:27 <jamy23> @help list
15:13:27 <lambdabot> list [module|command]
15:13:27 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
15:13:42 <edwardk> acowley: yeah. i only did a couple of mockups. i haven't actually had it running live. so i'm not sure how bad it'll be.
15:14:12 <edwardk> acowley: image capture is pretty decent, but once you go out of frame i need to rely on accelerometer data which is updated far less frequently.
15:14:16 <acowley> I would hope that the imager hardware is close enough to the rest of the system that you won't see weird buffering lags like you sometimes get with USB cams
15:14:36 <edwardk> and the initial wavelet pass to find the head can be slow. its pretty easy to follow the head once you find it though.
15:15:11 <acowley> you might try other approaches to that
15:15:23 <acowley> you don't really need haar features
15:15:25 <edwardk> what i want is for the effect to be more or less 'invisible. you pick up the pad and it just works.
15:15:27 <edwardk> yeah
15:15:29 <acowley> the face is just the big thing in the foreground
15:15:42 <edwardk> it was just a way to bootstrap it. once i find the face its easy to keep track
15:16:22 <edwardk> acowley: remember i also have the user using the screen as a touch surface. so there is also a lot of foreground motion from hands passing in front of the camera, etc.
15:16:38 <Peaker> dbpatterson: liftM2 is very close, you just want to join again
15:16:44 <edwardk> (if they go landscape its particularly bad, since it usually sits right under their right hand)
15:16:55 <acowley> edwardk: ah, right
15:16:55 <Peaker> (>>=) is liftM, then join..   what you want is liftM2, then join
15:17:09 <acowley> edwardk: I'd still go for an eye detector
15:17:12 <Peaker> acowley: I hate cmake :)
15:17:21 <edwardk> that is probably a good idea.
15:17:22 <Peaker> acowley: "cmake install" lies about installing to /usr/local and does nothing
15:17:22 <acowley> Peaker: it was designed to be hated
15:17:26 <edwardk> i'm no expert in opencv.
15:17:49 <edwardk> last time i had to do head tracking i used correlation in a stereo camera and guessed that the nose was the thing closest to the camera. ;)
15:18:10 <jamy23> .j
15:18:18 <acowley> Peaker: I just faithfully followed their installation instructions http://opencv.willowgarage.com/wiki/InstallGuide
15:18:30 <acowley> edwardk: kinect makes that even easier :)
15:18:32 <edwardk> that was good enough for me to set up the intrepid guys with basic head tracking for their holographic computer display systems, and we already had the stereoscopic cameras for video chat anyways
15:18:33 <edwardk> yeah
15:18:34 <Peaker> acowley: bah, "make ; make install" works. Why does "cmake ; cmake install" makes the impression of working but does nothing?
15:18:35 <jamy23> #d
15:18:40 <edwardk> kinect makes me smile
15:18:48 <acowley> Peaker: as I said, cmake was designed to be hated
15:19:06 <acowley> edwardk: you should've seen the reactions of all the stereo guys here
15:19:13 <acowley> edwardk: like my adviser and buddies
15:19:16 <edwardk> hah. i can imagine
15:19:22 <acowley> they were like kids
15:19:27 <jamy23> @let linux = "the open source operation system"
15:19:28 <lambdabot>  Defined.
15:19:44 <edwardk> i just wish it was in a known position relative to the screen. headtracking, etc. becomes SO easy
15:19:48 <Peaker> acowley: where does that install guide say how to install it to /usr/local?
15:20:11 <Peaker> cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D BUILD_PYTHON_SUPPORT=ON ..   <-- only mention of /usr/local and does not actually touch /usr/local
15:20:35 <edwardk> on the ipad, etc. it is a pretty easy sell, because its usually a single user kind of deal. on a television, etc. head tracking is less of a win because it makes observers kinda sick
15:21:17 <edwardk> i was mostly just having fun with it, and trying to pretend to still be a 3d guy ;)
15:22:18 <acowley> edwardk: I've seen youtube videos of the effect on the iPad as well as the old Wii stuff, and it looks really cool
15:22:46 <edwardk> all of the ipad stuff i've seen just assumes a static viewer and uses the accelerometer.
15:22:53 <acowley> Peaker: I'm looking
15:22:58 <edwardk> which is pretty 'swimmy'
15:23:19 <Peaker> oh, cmake just builds a Makefile for "make"? wow
15:23:28 <Peaker> build systems never cease to get suckier
15:23:32 <acowley> Peaker: in the directory I built these, I have a cmake_install.cmake file that mentions /usr/local
15:23:50 <Peaker> acowley: I am "make"ing now, so it'll probably work
15:24:00 <edwardk> except for this one http://ipad2guide.com/head-tracking-for-ipad-glasses-free-3d-display.html/
15:24:00 <Peaker> there's a whole lot of code being built in there!
15:24:02 <acowley> edwardk: http://www.youtube.com/watch?v=bBQQEcfkHoE
15:24:09 <acowley> edwardk: same thing I think
15:24:27 <edwardk> yeah. this was when i kinda got bored with it. coz someone else did it. ;)
15:24:44 <acowley> Peaker: the upside to a kitchen sink library is that it includes the kitchen sink, the downside is construction delays
15:24:45 <edwardk> they try to make it a bit too deep still though. you can see it wobble.
15:25:00 <acowley> edwardk: they released an app that got pretty mixed reviews
15:25:14 <acowley> edwardk: I think they lose the track fairly often as you suggested
15:25:23 <acowley> I don't have an iPad so haven't tried it
15:25:56 <edwardk> Sounds about right.
15:26:04 <acowley> everytime I try to convince myself I should have one, I search to see if I could use it for some wacky robotics thing via e.g. bluetooth and come away frustrated
15:27:17 <edwardk> i was just looking at doing something with the headtracking and accelerometer for controls but then the accelerometer was soo laggy it kinda made me sad
15:27:30 <acowley> that's kind of weird
15:27:49 <acowley> they're usually a super-responsive sensor
15:28:32 <acowley> If you have a db9 connector on your ipad, I can lend you a fancy accelerometer you could plug in
15:29:18 <acowley> It's an older one of these: http://www.microstrain.com/3dm-gx1.aspx
15:29:32 <Peaker> acowley: what package does linux/videodev.h come from?
15:29:56 <edwardk> just downloaded it. they lose track quite a bit more than i do, but overall. its pretty close.
15:30:48 <acowley> Peaker: http://tech.groups.yahoo.com/group/OpenCV/message/79758
15:30:58 <edwardk> well, if i do anything i'd want to be able to ship it. trying to sell everyone an extra db9 connector and accelerometer sounds like an exercise in frustration ;)
15:31:12 <acowley> apparently v4l moved out of the kernel and is causing some trouble
15:31:40 <acowley> edwardk: I think it only cost like $3k
15:31:46 <edwardk> one thing i do a heck of a lot better than they do is deal with backlighting. yegods they are terrible at that.
15:31:52 <edwardk> hah
15:31:55 <acowley> edwardk: how is the lag?
15:32:32 <edwardk> kind of like when i switch from haar to tracking, its swimmy but thats mostly an artifact of the fact that they are trying to make the 3d about 2x as deep as it should go.
15:32:44 <acowley> for embedded things we have an imager with a DMA to the processor which is great
15:32:45 <edwardk> the 3d effect is a bit exaggerated as a result.
15:33:19 <edwardk> in general its better to underestimate head motion than overestimate. an understated effect looks good. an overstated one makes you nervous and a little sick to your stomach
15:33:48 <mustelo> can I build lambdabot locally? I'm getting weird compile errors about .sizes not being constant
15:33:49 <acowley> Peaker: I guess this post is relevant? http://tech.groups.yahoo.com/group/OpenCV/message/80478
15:34:11 <acowley> edwardk: head-tracking understeer
15:34:22 <acowley> edwardk: it might spoil the physicality of the effect though
15:34:35 <edwardk> yeah. thats okay though
15:34:45 <acowley> edwardk: it's like with touch-based interfaces, there's a difference between more tangible interfaces and gesture interfaces
15:34:48 <edwardk> i actually do intentionally understeer a bit ;)
15:35:19 <edwardk> e.g. if you're looking about 45 degrees on i only pan about 37.
15:35:25 <acowley> I can't believe what a pain OpenCV is to install. I must turn off my brain altogether when I do it so I don't remember the process.
15:35:46 <edwardk> acowley: its worse building it somewhere its not meant to go, like for an iphone =P
15:36:58 <edwardk> i originally had hoped to be able to do pretty deep 3d scenes with it. like use it for a first person shooter where you have to duck out of frame to literally not be hit. and then tie your accuracy to how much of you was in frame. but the swim was too much
15:37:24 <Peaker> acowley: people ought to create apt repos for this stuff or github forks.. every single person manually editing this file is silly
15:37:30 <Peaker> acowley: if it was on github rather than svn...
15:37:44 <acowley> Peaker: is the fix not in their svn?
15:37:51 <Peaker> I don't know
15:37:58 <acowley> Peaker: Willow Garage still uses SVN a lot it seems
15:38:14 <Peaker> bad sign :P
15:38:21 <acowley> Peaker: this post http://tech.groups.yahoo.com/group/OpenCV/message/80478 suggested to me it was fixed in SVN, which isn't super-helpful to you at the moment
15:38:32 <acowley> yeah, but they're good people
15:39:16 <acowley> the CEO had the decency to nod and smile when I told him about my Haskell bindings to ROS
15:39:26 <acowley> it was very comforting
15:41:25 * acowley is afk for 5 min.
15:42:56 <Peaker> acowley: it's building now
15:43:12 <Peaker> acowley: it's built
15:46:31 <Peaker> acowley: Examples/PerfTest gets a segfault
15:47:02 <Peaker> OK, all examples get seg faults
15:47:48 <Peaker> In cvCreateCameraCapture (maybe because I have no camera?), and in cv::createMorphologyFilter
15:51:46 <acowley> Peaker: the Closing example segfaults, too?
15:52:00 <acowley> Peaker: VideoFunhouse can be used without a camera by passing a video file on the command line
15:52:41 <acowley> oh
15:53:04 <acowley> yes, I suppose Closing isn't working due to the createMorphologyFilter
15:53:14 <acowley> perhaps a busted dynamic link?
15:54:15 <roconnor> ah, zipWith (!!) ... that is a new one for me.
15:54:38 <acowley> "otool -L" on the executable shows the associated .dylibs on OS X
16:01:46 <acowley> Dealing with Ubuntu upgrades is indeed a hassle. If you wait a couple months for things to settle down, there's only a couple more months until the next upheaval.
16:02:55 <roconnor> debuging hash functions isn't easy
16:03:13 <kmc> heh
16:03:16 <kmc> you can run the LTS instead
16:03:25 <kmc> or use Debian ;)
16:03:26 <acowley> roconnor: checking with two input values isn't sufficient?
16:03:42 <roconnor> my implementation produces the wrong hash ...
16:03:45 <acowley> as long as you're sure your choice of inputs really is random
16:03:48 <acowley> oh
16:03:53 <acowley> then you only need one input
16:03:57 <roconnor> :)
16:04:28 <acowley> I implemented a hash like that recently and it worked first try. It was a glorious day, but taught me nothing of debugging such things.
16:04:43 <roconnor> :D
16:07:40 <kmc> if you're inventing a hash ex nihilo, then it's hard to convince yourself it's a good hash
16:07:53 <kmc> especially if an adversary can pick the inputs
16:07:58 <roconnor> I'm trying to implement ripemd-160
16:09:41 <acowley> I wish Haddock's Synopsis slide-out did something intelligent with long types
16:10:40 <monochrom> yeah
16:12:26 <sm> me too
16:18:32 <fragamus> @type getRandomR
16:18:33 <lambdabot> forall a (m :: * -> *). (MonadRandom m, Random a) => (a, a) -> m a
16:19:44 <fragamus> @type length
16:19:45 <lambdabot> forall a. [a] -> Int
16:19:52 <acowley> sigfpe's tweet "I was hoping that rewriting...in Agda would make things easier" deserves a troll response
16:20:13 <monochrom> haha
16:29:04 <Peaker> acowley: all the cv stuff seems to be linked to 2.2 correctly
16:30:40 <acowley> Peaker: that createMorphologyFilter problem seemed pretty fundamental to me
16:31:04 <acowley> Peaker: I think it's just a basic component of the library
16:31:47 <acowley> Peaker: I'll assume it's my fault, but I need to figure out a way to debug it
16:32:12 * hackagebot HFuse 0.2.4 - HFuse is a binding for the Linux FUSE library.  http://hackage.haskell.org/package/HFuse-0.2.4 (MaximTreskin)
16:32:14 * hackagebot debian 3.55 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.55 (MarcoSilva)
16:34:14 <Peaker> acowley: I just manually build opencv 2.2 so it's likely there's a problem there
16:34:21 <Peaker> acowley: maybe you can send me a small C program to test that?
16:35:23 <acowley> Peaker: will do, just a sec
16:36:00 <fragamus> @type modify
16:36:01 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
16:42:46 <acowley> Peaker: how shall I send this to you?
16:44:14 <Peaker> hpaste?
16:45:18 <acowley> Peaker: www.seas.upenn.edu/~acowley/Peaker/OpenCVTest.tar.gz
16:45:18 * hackagebot mysql 0.1.1.2 - A low-level MySQL client library.  http://hackage.haskell.org/package/mysql-0.1.1.2 (BryanOSullivan)
16:45:43 <acowley> I wanted to include a Makefile and sample image to keep things simple
16:48:59 <Peaker> acowley: I had to remove the -arch option
16:49:04 <Peaker> (not recognized in local g++)
16:49:13 <acowley> but then it worked?
16:49:22 <Peaker> acowley: yeah, seems to work
16:49:48 <acowley> I suppose that's good (i.e. my problem)
16:51:13 <acowley> are you on a 64-bit OS?
16:54:06 <Peaker> acowley: nope
16:54:17 <Peaker> i686
16:55:11 <kmc> does anyone have an example of a logic programming problem where mzero and fair msum aren't enough for (efficient) solution?
16:55:14 <Eduard_Munteanu> Don't trust iStuff :P
16:55:43 <kmc> i'm looking at the MonadLogic class and wondering when in particular i'd need (>>-) or 'ifte'
16:56:25 <acowley> Peaker: then I'm a bit perplexed at the segfault. If ldd is telling you that all the libraries are linked in to the executable properly, and the libraries themselves are functional, and there isn't any confusion caused by differently sized CInts...
16:56:53 <acowley> I think I have an 11.04 VM at home that I actually haven't tried installing this on
16:56:59 <acowley> so I'll give that a whirl when I get a chance
17:07:58 <monochrom> nice, 7.0.4 release candidate
17:08:14 <kmc> what's new
17:08:20 <monochrom> bug fixes
17:08:49 <monochrom> and slightly newer Cabal lib
17:11:09 <acowley> New Cabal scares me
17:11:22 <acowley> although I guess a new compiler means reinstalling everything anyway
17:17:42 <dmwit> acowley: cabal install world
17:17:43 <dmwit> =)
17:18:48 <acowley> is that really a thing?
17:19:00 <dmwit> yep
17:19:07 <dmwit> Just learned about it early this morning.
17:19:40 <acowley> Google doesn't seem to know about it. Though at least I wasn't directed to a 10 year old page with bad advice that would break my installation.
17:20:14 <acowley> I usually rely on some of my larger libraries that are a reasonable simulation of "everything"
17:20:19 <finnomenon> you can specify how recent you want the  results in google returns to be
17:20:41 <finnomenon> -in
17:20:50 <dmwit> Google knows about it here.
17:21:00 <acowley> my Google is ignorant
17:21:58 <acowley> The best I get is a bug report about it
17:22:15 <acowley> I guess to have bugs you must exist
17:22:35 <acowley> I should search for bug reports on more things I wish existed
17:22:41 <finnomenon> did you turn safe search off?  some find haskell highly erotic
17:23:11 <acowley> It's set to moderate filtering
17:23:14 <roconnor> oh, my hash was working; just endieness issues
17:23:16 * roconnor sighs
17:24:10 <acowley> endian issues are awesome. I love it when the output looks reasonable but somehow, "off".
17:24:51 <acowley> on the bright side, my bing is ignorant, too
17:24:56 <acowley> maybe it's my ethernet port
17:28:30 <monochrom> "cabal install world" is fairly new
17:28:57 <monochrom> also undocumented. google cannot find undocumented secrets
17:29:26 <monochrom> maybe wolfram alpha can calculate it from source code :)
17:32:59 <kmc> does that reinstall everything?
17:35:05 <roconnor> boo endienness
17:41:58 <monochrom> hmm, it may reinstall everything
17:43:26 <acowley> "may"
17:44:05 <HugoDaniel> :D
17:47:03 <ddarius> acowley: Just always use palindromic endianness.
17:47:24 <ddarius> (And if you run across a middle endian machine, then God have mercy on you.)
17:48:05 <hpc> ddarius: um, wut
17:49:26 <acowley> that might be genius
17:54:33 * hackagebot casui 0.3 - Equation Manipulator  http://hackage.haskell.org/package/casui-0.3 (EtienneLaurin)
17:54:44 <djahandarie> Programming via. faith.
18:07:34 <diegoviola> hi
18:07:38 <diegoviola> anyone knows Yi?
18:07:41 <diegoviola> the editor
18:07:44 <diegoviola> is it like vim?
18:08:39 <gienah> diegoviola: yi can be configured to have a subset of vim or emacs key bindings
18:10:23 <gienah> diegoviola: the neat thing about yi is it has an incremental haskell parser so it can understand the code better than emacs haskell modes. I'm not sure what the vim haskell mode is like, the emacs one does not really understand the haskell indentation.
18:10:25 <diegoviola> interesting
18:12:53 <diegoviola> how can i try Yi please?
18:13:04 <hpc> i think you can cabal install it
18:13:11 <gienah> diegoviola: you might want to look at how we patch yi on gentoo: https://github.com/markwright/gentoo-haskell/tree/master/app-editors/yi
18:14:04 <gienah> diegoviola: oops that was my fork, I mean here: https://github.com/gentoo-haskell/gentoo-haskell/tree/master/app-editors/yi
18:19:57 <gienah> diegoviola: another possibility is maybe you can install it from github: https://github.com/yi-editor/yi or if that doesn't work, fork it, patch it, then install it :-)
18:26:14 <diegoviola> thanks guys
18:26:15 <diegoviola> i will
18:26:19 <diegoviola> i always wanted to try haskell
18:26:33 <diegoviola> it looks like a great language
18:26:52 <diegoviola> I currently write Ruby code
18:33:46 <kmc> diegoviola, yi is notoriously hard to get set up
18:34:15 <kmc> few of us use it
18:34:34 <diegoviola> i wonder why that is?
18:34:38 <kmc> i say this not to disparage yi, just suggesting that if you want to learn Haskell, don't get hung up on this one thing
18:35:00 <diegoviola> ok
18:36:41 <diegoviola> i looked into Yi because some guy suggested me, he told me Vim and Emacs are too stuck in the past
18:36:51 <diegoviola> not progressing much
18:37:43 <gienah> diegoviola: I hope this is the correct location for the vim haskell mode: http://code.haskell.org/~wwolff/haskellmode/
18:39:51 <gienah> at least that is where we install it from on gentoo, on advice from someone who submitted an ebuild in #gentoo-haskell there is another page which gives a different location here: http://projects.haskell.org/haskellmode-vim
18:57:38 <drdo> fact n = product [1..n], Why would this ever cause a stack overflow?
18:59:17 <Martty> > let fact n = product [1..n] in fact 50000
18:59:21 <lambdabot>   334732050959714483691547609407148647791277322381045480773010032199016802214...
19:01:21 <drdo> i get a stack overflow here when trying it with 999999
19:02:18 <monochrom> because it first builds an internal expression tree (...(1*2)*3*...
19:02:50 <monochrom> then it dives into that tree to compute the numerical answer, but diving into a tree uses stack
19:03:33 <drdo> why would it do that?
19:03:52 <monochrom> foldl1' (*) [1..n] is a re-coded foldl1 to forbid building up a deep tree. it forces a numerical answer every once in a while
19:04:23 <monochrom> because ghc and hugs use lazy evaluation
19:04:56 <djahandarie> drdo, are you asking why product is defined like that, or the technical details of why product's definition leads to the tree being built?
19:05:30 <monochrom> (and yeah product is written to still allow lazy evaluation)
19:05:57 <drdo> http://hpaste.org/47418/pfact
19:06:13 <drdo> Why is this way way faster than the version with foldl' ?
19:06:21 <drdo> It doesn't even seem to be running in parallel
19:07:42 <drdo> pfact 999999 takes around 7sec here, but the foldl' one i haven't even bothered to let finish, it runs for over a minute at least
19:09:09 <monochrom> perhaps something to do with (...(1*2)*3)...) is not a good order to multiply, even if eagerly
19:09:17 <djahandarie> drdo, fact is faster than pfact for me.
19:09:23 <djahandarie> In GHCi.
19:09:30 <drdo> i ran it compiled
19:09:50 <djahandarie> Wait, no, pfact gets faster once the numbers get larger
19:10:20 <drdo> pfact seems to use a lot more memory
19:10:27 <drdo> but it runs way faster
19:10:32 <drdo> and i can't figure out why
19:10:51 <monochrom> multiplication is not constant time
19:10:55 <drdo> i know
19:11:11 <drdo> that's why i wrote alternate
19:11:12 <monochrom> different orders of multiplying takes different times
19:11:23 <monochrom> you have found a slightly better order
19:11:43 <drdo> so that both halves get about the same work
19:11:56 <drdo> but it doesn't look like it's running in parallel anyway
19:12:06 <monochrom> foldl' does (...(1*2)*3...) which is the worst order ever
19:12:19 <monochrom> no, no parallelization needed
19:12:37 <drdo> monochrom: why is that order worst?
19:12:58 <monochrom> I haven't done the analysis. I have only seen it.
19:13:52 <dolio> That isn't the worst order, is it?
19:14:20 <dolio> foldr's order would probably be slightly worse.
19:15:11 <monochrom> actually pproduct is probably the best order ever
19:15:28 <drdo> monochrom: why?
19:15:38 <monochrom> ((1*2)*(3*4))*((5*6)*(7*8))
19:15:50 <monochrom> again, I have only seen an analysis that says so
19:15:55 <drdo> monochrom: that's not the order pproduct does
19:16:11 <drdo> it's (1*3*5*7)*(2*4*6*8)
19:16:20 <dolio> It isn't that, either.
19:16:47 <monochrom> ((1*5)*(3*7))*((2*6)*(4*8))
19:16:50 <dolio> ((1*5)*(3*7))*((2*6)*(4*8)), no?
19:17:56 <monochrom> anyway they say doing it like a balanced binary tree is best or close to best
19:18:17 <monochrom> and don't forget to bring in FFT eventually
19:18:32 <drdo> I just wrote that to play around with par
19:18:42 <dolio> You could probably do slightly better by arranging to have it biased toward more elements at the beginning being grouped together.
19:18:53 <monochrom> you can change par to pseq and you may get the same speed
19:18:54 <dolio> But that'd probably take more work to arrange than it would save.
19:19:11 <djahandarie> I killed the parallel annotations and it's faster
19:19:16 <monochrom> hehe
19:23:22 <drdo> djahandarie: it's the same here, with or without annotations
19:26:15 <djahandarie> Nice, I just made GHC build a segfaulting program
19:29:53 <conal> New blog post: http://conal.net/blog/posts/a-third-view-on-trees/
20:26:50 <kmc> man, people use IRC over IPv6
20:26:53 <kmc> y'all are so cool
20:28:34 <tsanhwa> IPv6 is a viable way reaching freenode in China
20:30:26 <kmc> cool
21:05:29 <ddarius> monochrom: Using naive multiplication, an m-bit number multiplied by an n-bit number takes O(nm) operations and produces an mn-bit output.  So, the linear product of N b-bit numbers takes Sum_{i=1}^N ib^2 = b^2 N(N+1)/2 steps.  The balanced binary tree approach takes Sum_{i=1}^{lgN} N 2^(-i) (2^(i-1)b)^2 = b^2 N Sum_{i=1}^{lgN} 2^(i-2) = b^2 N(N-1)/2 steps, so Nb^2 fewer.
21:06:08 <ddarius> Using a blgb multiplication produces less of a difference but I believe it does still produce a discrepancy.
21:47:34 <handygandy> Is there a way I can download all the issues of monad reader at one time?
21:47:58 <ddarius> Use wget.
21:49:07 <ddarius> (Above I meant an m+n-bit output)
21:50:42 <djahandarie> ddarius, he obviously meant in Haskell!
21:52:56 <ddarius> You can use wget in Haskell.
21:52:56 <djahandarie> Also, maybe http://code.haskell.org/~byorgey/TMR/TMR.zip includes all of them? Dunno
22:16:42 <Luke_> can anyone tell me what's going on here in the mouseBindings function argument list? http://xmonad.org/xmonad-docs/xmonad/src/XMonad-Config.html
22:17:12 <mauke> pattern matching
22:17:20 <Luke> not sure what the record syntax is doing
22:17:22 <Luke> mouseBindings (XConfig {XMonad.modMask = modMask}) = ...
22:17:28 <Luke> where does the unqualified modMask come from?
22:17:44 <mauke> nowhere
22:17:47 <mauke> it's being bound here
22:18:03 <Luke> bound to what's in XMonad.modMask?
22:18:32 <mauke> yes
22:19:02 <Luke> is there a way to use that record syntax to make function clauses for each alternation of an ADT which is a member of the record?
22:19:24 <Luke> i guess just put the expected value on the right of the (=) in this case
22:19:31 <Luke> cool - thanks
22:29:14 * hackagebot plot 0.1.3.2 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.1.3.2 (VivianMcPhail)
22:30:44 <KirinDave> I gotta get in on this xmonad stuff
22:30:54 <KirinDave> But I don't have a machine I could make a primary linux machine...
22:31:19 <kmc> virtual machine?
22:31:45 <kmc> you should be able to run xmonad on Windows or Mac OS X too
22:32:00 <kmc> but on those operating systems, most windows are not part of the X Window system
22:32:02 <kmc> typically
22:32:41 <Veinor> all of my linux machines are headless
22:35:46 <djahandarie> Everyone I've met offline is headless.
22:39:17 <KirinDave> kmc: I use an SSD because I do so much scala programming
22:39:47 <KirinDave> kmc: But space is pretty limited
22:39:56 <KirinDave> Maybe I should just get a cheap non-portable.
22:40:09 <kmc> ah, i have a SSD as well, but also several TB on a fileserver accessible by sshfs
22:40:25 <KirinDave> Would you run a vm over that?
22:40:25 <kmc> also, why do you need a SSD for scala programming? isn't RAM cache good enough?
22:40:26 <KirinDave> Ouch.
22:40:32 <KirinDave> kmc: No, it is not
22:40:36 <n00p> That's the worst reason to buy an SSD I've ever heard.
22:40:43 <KirinDave> n00p: Oh?
22:40:50 <KirinDave> n00p: Run sbt compile on a non-trivial project
22:40:52 <kmc> KirinDave, maybe if you're running Windows 7 with all the bells and whistles and useless shiny bits
22:40:54 <KirinDave> and then tell me that.
22:41:02 <n00p> Buy an SSD because you have a laptop and you want the battery to last longer, or if you drop it you don't want the HD to die...
22:41:04 <kmc> but nearly all the software i use would fit in my 4GB RAM
22:41:10 <KirinDave> n00p: It's not better for battery life.
22:41:22 <n00p> KirinDave: Less moving parts, less heat.
22:41:44 <KirinDave> n00p: It's not significantly more energy efficient. Sorry.
22:41:49 <kmc> KirinDave, what's wrong with running a VM over a network filesystem?
22:41:54 <KirinDave> kmc: Slow.
22:41:59 <kmc> the latency is comparable to a spinning platter drive
22:42:06 <KirinDave> kmc: Haha.
22:42:12 <KirinDave> kmc: For screen draws?
22:42:18 <kmc> erm, you misunderstand
22:42:25 <kmc> we were talking about storage and sshfs
22:42:25 <KirinDave> Ah
22:42:27 <kmc> not something like vnc
22:42:39 <n00p> KirinDave: Which results in more heat? Reading from or writing to an SSD?
22:42:40 <KirinDave> Ahh, I see what you mean.
22:44:10 <kmc> also "screen draw"?  when i run a VM i usually ssh to it, I don't interact with the console
22:44:14 <n00p> KirinDave: Once you understand that, you'll understand which parts of the operation of an SSD require as much energy as a hard drive's spinning platter.
22:44:17 <kmc> but we were talking about xmonad, originally
22:44:18 * hackagebot json-builder 0.0.1 - Data structure agnostic JSON serialization  http://hackage.haskell.org/package/json-builder-0.0.1 (LeonSmith)
22:44:41 <KirinDave> n00p: I mean this in the nicest possible way: you're being incredibly tedious. Go argue with google.
22:44:48 <KirinDave> n00p: Lots of tests have been run that bear this out.
22:45:03 <kmc> KirinDave, you're kind of being a dick as well
22:45:07 <kmc> but whatever
22:45:09 <KirinDave> n00p: Actual measurements of ssds installed in machines: they do not show better power consumption.
22:45:12 <n00p> KirinDave: I once owned an SSD, and I did my research prior to owning one, you fool.
22:45:22 <KirinDave> kmc: I said "I gotta get in on this xmonad stuff"
22:45:23 <kmc> SSD is a great purchase, there are plenty of reasons for it
22:45:46 <KirinDave> kmc: So a headless display would sort of render that interest difficult to realize. :)
22:45:52 <kmc> i know
22:45:52 <kmc> i said that a minute ago
22:45:53 <n00p> KirinDave: Once you understand how an SSD's controller works, you'll realise the same idea can be used for winchester drives to achieve the same (or faster) speeds, for less money and larger capacity.
22:46:26 <kmc> uh, no
22:46:36 <kmc> platter drives will never get anywhere close to SSD for random access latency
22:47:12 <n00p> If you have enough of them, it won't matter.
22:47:37 <KirinDave> That is fascinating.
22:47:40 <kmc> right
22:48:03 <KirinDave> I hope they get small enough that we can have many in the average laptop or tablet.
22:48:04 <n00p> What's 20 milliseconds matter when your drives are numerous enough to cope with the processors capability and more?
22:48:24 <kmc> if all you care about is random access latency, you can buy one SSD, or a rack full of 10k RPM drives which consumes a monstrous amount of power and sounds like a washing machine full of ball bearings
22:48:44 <KirinDave> n00p: Well 20ms might matter if user interface is gated on it
22:48:46 <kmc> and costs more -- the underlying technology is literally 100 times slower
22:48:51 <n00p> KirinDave: Did you buy your SSD because you wanted to put it in a laptop or tablet, or because you wanted to do something stupid like "make your scala faster"?
22:48:59 <KirinDave> n00p: Or if you're doing something like network infrastructure.
22:49:02 <kmc> anyway this discussion is the height of retardation
22:49:05 <kmc> enjoy
22:49:32 <KirinDave> I am with kmc.
22:49:42 <n00p> KirinDave: If you have 20 drives, it's 20ms each drive.
22:49:45 <KirinDave> n00p: Make my scala *compiles* faster.
22:49:53 <KirinDave> There is a difference.
22:49:54 <n00p> KirinDave: That's a retarded reason.
22:49:57 <KirinDave> Why?
22:49:57 <flux> apparently a finnish university uses SSD devices on their proxy machines. they wear out every 6 months, but it's fast.
22:50:06 <n00p> KirinDave: Because your RAM is better at that.
22:50:07 <vnab> is there a function that takes in a list of indices and a list of elements and returns the list of elements with those indices? For example function [1,3,5] ['a', 'b', 'c', 'd', 'e'] == ['a', 'c', 'e']
22:50:23 <KirinDave> n00p: But I do not have enough RAM to hold the average scala project I work on entirely in memory.
22:50:27 <vnab> maybe a smart way of using filter?
22:50:31 <KirinDave> n00p: So it's not really an option.
22:50:40 <KirinDave> n00p: Have you see jarbloat, man?
22:50:48 <n00p> KirinDave: Then get a processor with more L2 cache memory. That would also significantly speed things up.
22:50:53 <KirinDave> n00p: Oh I did
22:50:59 <KirinDave> All of that paled to the SSD upgrade.
22:51:19 <n00p> Did you try a RAID of SAS winchester drives?
22:51:28 <mauke> vnab: map ("abcde" !!) except that's pretty slow
22:51:39 <KirinDave> No, that would be impractical for my use case.
22:51:44 <KirinDave> I tend to work exclusively on laptops.
22:52:02 <flux> n00p, why would you use a RAID of SAS winchesters instead of an SSD?
22:52:23 <KirinDave> flux: I was afraid to even ask that questoin.
22:52:37 <n00p> KirinDave: Then your reason is more relevant to your laptop than to your Scala.
22:52:47 <KirinDave> n00p: No.
22:52:59 <vnab> Thanks mauke, exactl what i was looking for
22:53:18 <KirinDave> n00p: This conversation is not only ridiculous, it doesn't belong in #haskell.
22:53:26 <KirinDave> I'm sorry I even mentioned it.
22:54:19 <n00p> flux: Presumably because I want fast access to my database, and large capacities that aren't available as single drives.
22:55:24 <vnab> is there a Maybe version of (!!)?
22:55:47 <mauke> vnab: Maybe a -> Int -> a?
22:56:32 <vnab> uhh something like [a] -> Int -> Maybe a
22:56:48 <mauke> @hoogle [a] -> Int -> Maybe a
22:56:49 <lambdabot> Prelude (!!) :: [a] -> Int -> a
22:56:49 <lambdabot> Data.List (!!) :: [a] -> Int -> a
22:56:49 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
22:56:55 <mauke> lambdabot: wrong!
22:56:59 <n00p> KirinDave: Just one more question... If your use case was related to desktops, would you have tested a RAID of SAS winchester drives as an option?
22:57:22 <gienah> vnab: yes in pkg safe
22:57:28 <KirinDave> n00p: Irrelevant question. I don't use desktops.
22:57:42 <n00p> KirinDave: The answer is "yes" or "no".
22:58:01 <flux> n00p, so if you didn't require larger capacities than 400GB, you could juse use one SSD. or maybe a raid of them.
22:58:02 <KirinDave> n00p: Incorrect. The answer is what I gave you.
22:58:10 <mauke> n00p, KirinDave: this conversation is now off-topic. please continue in another channel
22:58:21 <KirinDave> mauke: Thank you.
22:58:54 <n00p> KirinDave: That wasn't a valid answer to my question, you retard. It was a "yes or no" question, as anyone with intelligence equating to that of a smart dog can tell. I'm done here.
22:59:03 --- mode: ChanServ set +o mauke
22:59:03 --- mode: mauke set +q $a:n00p
22:59:06 <hydo> jesus...
22:59:18 <maurer_> mauke++
22:59:29 <hydo> mauke++
22:59:53 --- mode: mauke set -o mauke
23:00:09 <gienah> vnab: http://community.haskell.org/~ndm/safe/
23:00:26 <vnab> gienah: thanks!
23:01:12 <gienah> vnab: function is called: atMay
23:51:09 <lpsmith> I've got a small haddock question
23:53:43 <lpsmith> ok,  let's say I have a module Foo which exports some abstract types,  but I want to allow people to muck around in the internals of the module if I really want to.  So I put that stuff in a publically visible Foo.Internal.
23:54:19 <lpsmith> And haddock comments from Foo.Internal appears in the haddock comment for Foo,  which re-exports the types abstractly.
23:54:38 <lpsmith> But I'd really like two different comments to appear,  one for the abstract type,  and one for the concrete type.
23:55:39 <lpsmith> is this possible at all with Haddock?
23:59:02 --- mode: ChanServ set +o mauke
23:59:02 --- mode: mauke set -q $a:n00p
23:59:52 --- mode: mauke set -o mauke
