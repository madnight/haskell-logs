00:11:39 <bytbox> I can't get hashed-storage to build: "The type signature for `xlate64' lacks an accompanying binding" (in Storage/Hashed/Utils.hs)
00:11:49 <bytbox> equivalent error message for 'xlate32', as well
00:12:48 <bytbox> any ideas what might be going wrong?
00:14:19 <c_wraith> well, that error message means that there are type signatures provided for those two names, but no implementations.
00:14:26 <c_wraith> Which is very odd, if it built on hackage
00:14:30 <bytbox> c_wraith: very
00:15:01 <c_wraith> The next-most common thing I can think of is, maybe there's some template haskell that's supposed to spit out implementations for those, but failing for you for some reason.
00:15:14 <bytbox> I'll take a look
00:15:28 <bytbox> (I'm using a development version of ghc, so i guess that might be related)
00:15:43 <c_wraith> that could be related, yes
00:16:54 <bytbox> c_wraith: ah, no. It's cpp
00:17:13 <c_wraith> bytbox: but still something at compile-time.  Well, that explains building in some places but not others.
00:17:19 <bytbox> Two possible definitions are provided, and they are surrounded by #ifdef LITTLEENDIAN and #ifdef BUILDENDIAN
00:17:27 <bytbox> Now I just get to fix it
00:20:38 <adimit> Is there a version of (!!) that returns Maybe instead of error'ing?
00:20:50 * hackagebot asn1-data 0.5.1 - ASN1 data reader and writer in RAW, BER, DER and CER forms  http://hackage.haskell.org/package/asn1-data-0.5.1 (VincentHanquez)
00:20:55 <shachaf> @hoogle [a] -> Int -> Maybe a
00:20:55 <lambdabot> Prelude (!!) :: [a] -> Int -> a
00:20:55 <lambdabot> Data.List (!!) :: [a] -> Int -> a
00:20:55 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
00:21:20 <shachaf> @ty \n -> listToMaybe . drop n
00:21:21 <lambdabot> forall a. Int -> [a] -> Maybe a
00:22:34 <adimit> shachaf: cute.
00:22:59 <adimit> thanks :-)
00:28:33 * adimit votes for the inclusion of (!?) :: [a] -> Int -> Maybe a into Data.List
00:29:00 <Tomsik> cats!?
00:29:20 <Tomsik> "What is this I don't even"?!1
00:29:24 <adimit> Wait, I think (‽) is better even.
00:30:10 <adimit> which GHC, incidentially, accepts as an operator.
00:30:40 <Jafet> > wtf!!1
00:30:41 <lambdabot>   "lol"
00:30:55 <adimit> > wtf!!2
00:30:56 <lambdabot>   "*Exception: Prelude.undefined
00:31:12 <adimit> :-(
00:31:13 <Tomsik> "you bastards"!!1
00:31:34 <Tomsik> If only you could cut the quotation marks away
00:34:58 <Jafet> @let wtf = undefined: concatMap (\n -> text "lol" : replicate (n-1) undefined) (iterate (*10) 10)
00:34:58 <lambdabot>  Defined.
00:35:04 <Jafet> > wtf!!11
00:35:05 <lambdabot>   lol
00:35:44 <gienah> adimit: atMaybe in safe
00:36:45 <gienah> adimit: s/AtMaybe/atMay/ http://hackage.haskell.org/packages/archive/safe/0.3/doc/html/src/Safe.html#atMay
00:41:03 <adimit> gienah: thank you! Curious that hoogle didn't catch it.
00:41:33 <adimit> Hayoo does thoug.h
01:22:39 <pillowrice> I'm just starting out with haskell. I have a list of positive integers which happens to be strictly increasing. How can I determine if a given integer is in my list?
01:24:00 <pillowrice> the list is infinite, if that makes a difference
01:24:36 <opqdonut> there's no library function (that I'm aware of) that works like that
01:24:47 <shachaf> @ty \n -> (==n) . head . takeWhile (<=n)
01:24:48 <lambdabot> forall a. (Ord a) => a -> [a] -> Bool
01:24:52 <opqdonut> but you can either write a recursive function that goes through the list
01:25:00 <opqdonut> or use something like takeWhile
01:27:24 <pillowrice> opqdonut: ah, takeWhile seems to be what I was after. Thanks!
01:32:10 * hackagebot http-enumerator 0.6.5.4 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.6.5.4 (MichaelSnoyman)
01:40:11 * hackagebot authenticate 0.9.1.4 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.9.1.4 (MichaelSnoyman)
01:47:48 <jonkri> how do you usually transfer the copyright, or getting "joint ownership", for patches contributing to your (copyleft) open source projects? a contributor agreement?
02:56:52 <albertid> hi, is it possible to pattern-match for "55" in the following data structure?
02:56:54 <albertid> Cons {messageChannel = Channel {fromChannel = 0}, messageBody = Voice (NoteOn (Pitch {fromPitch = 55}) (Velocity {fromVelocity = 92}))}
02:57:17 <Twey> Yes, you've pretty much just done it :þ
02:57:26 <Twey> Just s/55/someVariable/
02:57:38 <albertid> hehe ah
02:58:03 <Twey> Though using record syntax is probably unnecessary for all of those — they don't look like they're structures that are likely to change
02:58:31 <Twey> f Cons { messageBody = Voice (NoteOn (Pitch pitch)) } = pitch
02:58:46 <albertid> yep
02:58:48 <albertid> thanks
02:58:58 <Twey> You're welcome
03:04:50 <lpsmith> NLP gone amusingly wrong:  Was Orwell, the small lazy functional programming language first released in 1984 by Philip Wadler an instance of communist (a socialist who advocates communism)?
03:05:07 <lpsmith> http://www.trueknowledge.com/q/was_orwell_a_communist
03:25:02 <maurer_>  /win 15
03:25:30 <shachaf> maurer_: Alt-t.
03:33:52 <accel> what's haskell's equiv for rails? i.e. a hsakell framework for rapid prototyping of web apps
03:34:32 <luite> there are a few projects that aim te be something like that, but nothing that is as complete
03:35:10 <maurer_> shachaf: Sorry.
03:35:21 <shachaf> maurer_: ?
03:35:46 <maurer_> shachaf: You responded Alt-t, so, uh.
03:35:48 * hackagebot tls-extra 0.3.1 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.3.1 (VincentHanquez)
03:36:04 <Tomsik> Yesod is pretty working, seems to me
03:36:15 <Tomsik> At least it worked for me
03:52:30 <Reaganomicon> Does GHCI's :? not accept arguments? I thought passing it a command name would give you a pseudo-manpage of that command.
03:52:47 <Reaganomicon> Or am I mixing this up with another repl?
03:53:47 <Axman6> i don't believe ghci has ever done that
04:13:18 <JHoglund> What is a queue made up of? I'm looking for a short word describing the inviduals in a queue, are they called queuers?
04:19:36 <mauke> elements
04:39:23 <siracusa> "queuees" :-)
04:43:31 <luite> queuescent entities
04:47:59 <mauke> queueties
05:08:19 <wjt> andy: but i will bring it
05:08:49 <wjt> (grr. undead ssh connection across suspend/resume strikes back)
05:53:17 * hackagebot url-generic 0.1 - Parse/format generic key/value URLs from record data types.  http://hackage.haskell.org/package/url-generic-0.1 (ChrisDone)
06:01:31 <k0ral> could someone try to install and use hbro to play a flash video and tell me if it freezes ?
06:05:52 <melle_> Hi all, assuming there are some CS-students/experts here... Currently working on my thesis, but I'm running into an issue with formal notation. How do I refer to the first (or second) element of a 2-tuple? Google only returns results related to programming languages...
06:06:21 <melle_> So basically, i want to write down fst/snd in a formal manner :)
06:09:47 <dumael> melle_: projectleft, project right is what I learned from Category theory.
06:11:05 <arw_> melle_: don't know, most just defined a tuple t to be (t_1, t_2) or (t', t'') and then used t_{1,2} or t'
06:11:12 <melle_> dumael, thanks, plugging it into google for a quick ref
06:12:07 <melle_> arw_, in this case this isn't possible, since i want to refer to a function which results in a specific tuple
06:12:15 <chridi> melle_: with pi?!
06:12:20 <chridi> as a projection
06:12:44 <melle_> chridi, yeah was thinking about the same, but i think its too specific since its related to relational algebra
06:13:00 <chridi> hm.. okay.. then.. define it ;)
06:13:18 <melle_> chridi, that would be my last option :)
06:15:01 <melle_> dumael, googling for projectleft/projectright doesn't return any relevant results, do you have a ref?
06:16:29 <dumael> melle_: give me a few moments.
06:17:04 <melle_> dumael, np, thanks for the effort!
06:18:09 <siracusa> melle_: π_i or proj_i for i=1,2 is the usual (formal) way to do it
06:18:18 <wang_> omg!
06:18:50 <dumael> melle_: http://www.google.com/search?client=opera&rls=en&q=category+theort+porject+left&sourceid=opera&ie=utf-8&oe=utf-8&channel=suggest#hl=en&sugexp=cmsp&pq=category%20theory%20project%20left&xhr=t&q=category+theory+%22project+left%22&cp=30&pf=p&sclient=psy&safe=off&client=opera&hs=sCJ&rls=en&channel=suggest&biw=1440&bih=733&source=hp&aq=f&aqi=&aql=&oq=category+theory+%22project+left%22&pbx=1&bav=on.2,or.r_gc.r_pw.&fp=c5b8c32898a7d5b2
06:19:17 <dumael> the spelling should auto correct ;_;
06:19:34 <melle_> dumael, thanks i'll look into it
06:19:51 <dumael> The first two PDFs mention project left/ project right.
06:20:31 <melle_> siracusa, from my understanding \Pi_1 was introduced by Codd in conjunction with the relational model... is it really that general?
06:21:20 <siracusa> At least in category theory it is commonly used
06:21:50 <siracusa> melle_: See http://en.wikipedia.org/wiki/Product_(category_theory)
06:24:32 <ddarius> I seriously doubt Edgar Codd is the originator of that notation.
06:24:48 <Nimatek> Typical conversation between functional programmer and an imperative programmer: http://ompldr.org/vOTR0cA
06:24:54 <melle_> siracusa, ok, convinced me i'll use that one
06:24:54 <Nimatek> +a
06:25:33 <melle_> siracusa, thanks!
06:25:43 <siracusa> No problem
06:27:38 <melle_> dumael, looks like those operators were originally introduced by a prof. from my uni, however since I'm not familiar with them I'll go for the other projection operator, thanks anyway!
06:29:22 <ddarius> Incidentally, fst/snd is arguably more formal than π_1/π_2.
06:31:27 <dumael> melle_: no worries.
06:48:39 <sepp2k> Is there a more straight forward way to create native code using the llvm bindings than writing the bitcode to a temporary file with writeBitcodeToFile and then invoking llvmc on it?
06:57:37 <ddarius> I'm pretty sure there is.
06:59:21 <Reaganomicon> I notice a bunch of packages require unix-2.x, but when I try to install unix it vomits errors all over the place, claims it can't find HsUnix.h. I can't tell if it's a problem with the package or with cygwin or something else entirely.
07:01:45 <parcs> unix is probably not intended to work with cygwin
07:03:19 <Reaganomicon> Well they say: The package is not supported under Windows (except under Cygwin).
07:09:36 <parcs> hmm don't know how i missed that
07:11:16 <parcs> Reaganomicon: if you find no answers here maybe you should ask your question on the haskell-cafe mailing list
07:12:59 <Reaganomicon> I'll dig a bit and do that, cheers parcs
07:13:41 <albertid> A program of mine does have correct output when I run it in ghci, but not when I run it after linking. Does anyone have a hunch? https://github.com/lordi/scalehs/blob/master/Main.hs
07:16:33 <joe6> i have an enum datatype, but I do not want the enum values assigned to the different values to be 0..x, but a specific value that I choes.
07:16:39 <joe6> s/choes/choose/
07:16:46 <joe6> is there such a datatype?
07:17:30 <merijn> joe6: Sure, just manually implement the Enum instance?
07:17:42 <joe6> oh, ok.
07:17:48 <joe6> would that be hard?
07:18:06 <merijn> joe6: No, potentially a bit cumbersome depending on what you want
07:18:17 <merijn> joe6: You know how to create instances of typeclasses?
07:18:23 <joe6> yes
07:19:05 <parcs> wouldn't that be a misuse of Enum?
07:19:14 <merijn> parcs: I dunno? Would it?
07:19:27 <parcs> i think so
07:20:37 <joe6> ok, will just assign some dummy values for the values that I do not need.
07:22:46 <parcs> you probably don't need a class at all for what you're trying to do. just define a function YourDataType -> Int
07:24:33 <albertid> my question is obsolete
07:28:54 <mietek> SpecConstr
07:28:54 <mietek>     Function `a_s2Mv{v} [lid]'
07:28:54 <mietek>       has six call patterns, but the limit is 1
07:28:54 <mietek>     Use -fspec-constr-count=n to set the bound
07:28:55 <mietek>     Use -dppr-debug to see specialisations
07:28:59 <mietek> Huhwhat?
07:29:56 <mietek> I have no idea what this mean
07:29:58 <mietek> means*
07:30:29 * hackagebot shaker 0.5.1 - simple and interactive command-line build tool  http://hackage.haskell.org/package/shaker-0.5.1 (AnthoninBonnefoy)
07:30:36 <parcs> it's a debug message that is intended for advanced debugging
07:30:52 <parcs> you can safely ignore it
07:30:53 <mietek> Should I be worried about this?
07:30:59 <mietek> Ah, hm
07:32:01 <Saizan> it's saying "this function might be specialized further, but we're not doing more specializations at this point"
07:32:14 <Saizan> s/might/could/
08:05:01 <gwern> hm. has Conway's Life ever been implemented using comonads?
08:05:09 <gwern> I feel sure I've seen it before but google is not tyrning up anything
08:09:32 <mdeboard> Are list comprehensions the appropriate way to approximate the behavior of nested for loops in imperative languages?
08:09:41 <mdeboard> imperative/OO
08:09:53 <mdeboard> I ask not knowing how to do so in list comp
08:09:54 <hpaste> yaxu pasted “let in ghci” at http://hpaste.org/47979
08:10:22 <parcs> mdeboard: it's one way.
08:10:27 <parcs> there's also forM
08:11:00 <yaxu> hi all, I can't seem to do more than one let assignment at once in ghci, in what way am I being stupid?
08:11:03 <mdeboard> Trying to get hoogle working :P
08:11:06 <parcs> :t sequence [ print (x * y) | x <- [1..10], y <- [1..10] ]
08:11:07 <yaxu> (see above paste)
08:11:07 <lambdabot> IO [()]
08:12:05 <parcs> :t forM_ [1..10] $ \x -> forM [1..10] $ \y -> print (x * y)
08:12:06 <lambdabot> IO ()
08:13:23 <parcs> yaxu: that example works for me
08:13:34 <dafis> yaxu: for me too
08:14:44 <parcs> mdeboard: with the list-comprehension method, you build up a list of actions, then you call sequence to run the list of actions sequentially
08:14:48 <dafis> yaxu: which ghc version?
08:15:08 <yaxu> dafis: 6.12.1
08:15:45 <yaxu> ok that's quite old, thanks all
08:16:24 <dafis> yaxu: I get the same parse error with 6.12.3
08:16:59 <parcs> yaxu: try `let x = 2; y = 3 in x + y`
08:17:05 <dafis> yaxu: so get yourself a 7 or use semicolons
08:17:26 <yaxu> parcs: aye that works
08:17:47 <yaxu> dafis: will upgrade, cheers
08:22:03 <dafis> yaxu: go directly for 7.0.4 then
08:24:20 <yaxu> dafis: current platform supports 7.0.3 though?
08:24:51 <dafis> yaxu: think so, which OS?
08:25:10 <yaxu> debian testing
08:28:36 <yaxu> oh, latest haskell platform is in debian testing, so upgrading will be easy :)
08:29:43 <schlicht> Hey, i'm a Haskell newbie and have a quick quesiton. I pasted some Code ( http://pastebin.com/46GkAYvE ). Why cant i just use the function l on 3? If i do that i get Couldn't match expected type `t -> Int' against inferred type `Lala Int'
08:29:44 <mauke> The paste 46GkAYvE has been copied to http://hpaste.org/47983
08:30:44 <Botje> l isn't a function, it is a wrapper around a function
08:31:14 <Botje> so you have to unpack it first by pattern matching on Lal, as you do there
08:31:22 <schlicht> ahh okay :)
08:31:31 <schlicht> Thanks!
08:35:54 <schlicht> Can i unpack it without pattern matching?
08:37:16 <parcs> nope, at one point or another it must be unpacked with pattern matching
08:37:54 <schlicht> Alright, thanks.
08:39:24 <Ferdirand> well, you could hide the pattern match behind a record declaration
08:40:26 <parcs> it may be hidden but it's still done
08:43:36 <mike-burns> What's the more idiomatic way to write this expression. It produces a list of the three functions applied to the number 4:
08:43:38 <mike-burns> fmap (\z -> z 4) [(+1),(+2),(+3)]
08:44:09 <dafis> ma p ($ 4)
08:44:13 <mike-burns> Thank you.
08:44:14 <dafis> map*
08:44:38 <identity_> > map ($ 4) [(+1), (+2), (+3)]
08:44:38 <lambdabot>   [5,6,7]
08:44:49 <merijn> mike-burns: Also, watch this magic:
08:44:57 <parcs> > [(+1),(+2),(+3)] <*> [1]
08:44:58 <dino-> :t ($)
08:44:58 <merijn> @pl fmap (\z -> z 4)
08:44:58 <lambdabot> fmap ($ 4)
08:44:58 <lambdabot>   [2,3,4]
08:44:58 <lambdabot> forall a b. (a -> b) -> a -> b
08:45:06 <dafis> > map (flip id 4) [(+1),(+2),(+3)]
08:45:07 <lambdabot>   [5,6,7]
08:45:21 <mike-burns> Oh I like the <*> more.
08:45:34 <merijn> dafis: That only works with lambdabots numbers as functors, right?
08:45:44 <parcs> > [(+1),(+2),(+3)] <*> [1, 2, 3]
08:45:45 <lambdabot>   [2,3,4,3,4,5,4,5,6]
08:45:52 <dafis> merijn: no, that works everywhere
08:45:59 <merijn> :t flip
08:46:00 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
08:46:03 <merijn> :t flip id
08:46:03 <lambdabot> forall a b. a -> (a -> b) -> b
08:46:07 <identity_> :T (<*>)
08:46:11 <identity_> :t (<*>)
08:46:12 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:46:34 <ziman> > 1 6
08:46:35 <lambdabot>   1
08:47:08 <parcs> merijn: id :: a -> a so if you substitute a with, say, b -> c you get id :: (b -> c) -> b -> c and so flip id :: b -> (b -> c) -> c
08:47:33 <merijn> parcs: Ah, right
09:00:48 <ziman> > (liftM2 (+) 7 return) . 5
09:00:49 <lambdabot>   No instance for (GHC.Show.Show (f (m a)))
09:00:49 <lambdabot>    arising from a use of `M578885...
09:02:20 <Veinor> @hoogle Char -> Int
09:02:21 <lambdabot> Data.Char digitToInt :: Char -> Int
09:02:21 <lambdabot> Data.Char ord :: Char -> Int
09:02:21 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
09:15:04 <k0ral> let's try again: someone got 5 minutes to test something for me ?
09:15:23 <vitka> ...depends.
09:15:59 <dafis> what do you want to have tested?
09:16:26 <k0ral> very simple:
09:16:37 <k0ral> get and install hbro via cabal
09:16:47 <k0ral> load any webpage that contains a flash video
09:16:48 <dafis> what's hbro?
09:16:55 <k0ral> a browser
09:17:19 <k0ral> and tell me if it freezes when you play the video
09:18:49 <MHD> I have this interestin idea of a Self-balancing Binary Tree with an "any" node
09:19:04 <MHD> To use as a set, that is.
09:19:44 <copumpkin> are there good libraries for making interactive prompts in haskell?
09:20:00 <dafis> k0ral: will certainly take longer than five minutes :)
09:20:12 <gwern> copumpkin: like lambdashell?
09:20:21 <dafis> (lots of dependencies to install)
09:20:48 <copumpkin> gwern: well, I mean an abstract library for a command-line app that wants to accept commands and provide output to them
09:21:04 <copumpkin> shellac looks like that
09:21:23 <k0ral> dafis: didn't realize this
09:21:25 <gwern> oh, it was shellac I was thinking of. what lambdashell uses
09:22:07 <k0ral> dafis: I'll understand if you don't want to bother
09:22:41 <dafis> k0ral: well, installing already
09:23:12 <copumpkin> thanks :)
09:23:51 <dafis> k0ral: zeromq failed to install :(
09:24:19 <dafis> (missing C library or header zmq)
09:25:37 <k0ral> dafis: oh yes, it requires zmq to be installed as a library
09:25:55 <dafis> what the heck *is* zmq?
09:26:05 <gwern> high perofmrnace low level kind of networking, iirc
09:26:10 <k0ral> a high-level socket IPC system
09:26:15 <k0ral> lol
09:26:17 <geheimdienst> message queue thingy
09:26:25 <k0ral> I consider it as high level
09:26:41 <k0ral> compared to bare sockets system
09:26:46 <k0ral> maybe I'm quite biaised
09:26:56 <k0ral> biased*
09:27:08 <dafis> zypper didn't find any zmq
09:27:14 <ddarius> braised*
09:27:16 <k0ral> zeromq
09:27:24 <k0ral> is the actual name
09:27:34 <k0ral> no, biased
09:27:50 <dafis> that neither :(
09:28:04 <k0ral> zypper ? which distro is that ?
09:28:05 <cmccann> gwern, "perofmrnace"?
09:28:16 <dafis> k0ral: openSuSE (11.3)
09:28:27 <gwern> cmccann: this is IRC. ye cannae expect perfect spelling like some dominie!
09:29:03 <k0ral> dafis: I guess there is no package for it
09:29:06 <cmccann> gwern, I'm just impressed that you managed to mistype it like that
09:29:09 <k0ral> dafis: don't bother any longer
09:29:21 <dafis> k0ral: nope, sorry though
09:29:29 <k0ral> dafis: no problem
09:29:29 <gwern> cmccann: transposition errors are the most common in fast typists
09:29:35 <k0ral> dafis: I'll just cry alone :)
09:29:45 <dafis> cry me a river
09:30:18 <geheimdienst> cmccann: check www.icanhascheezburger.com , they seem to be very much in need of your services as a proofreader ;-)
09:30:29 <cmccann> gwern, the interesting part is that the letters from each half of the keyboard are in the correct order
09:30:54 <gwern> cmccann: well, again, that makes sense. each hand is typing correctly, they just aren't interleaved correctly
09:31:10 <dafis> k0ral: there is one, just not in the repos I have listed
09:31:32 <k0ral> dafis: back in ?
09:31:47 <dafis> k0ral: think so
09:32:50 <cmccann> gwern, it does indeed make sense, it's just an interesting demonstration of the perils of doing output from two different threads :)
09:33:33 <k0ral> dafis: 10 minutes installing, 30s testing... hope you won't be too much disappointed :s
09:34:09 <k0ral> cmccann: but single-threaded typing is soooo painful
09:37:02 <dafis> k0ral: cabal resumed
09:38:48 <dafis> k0ral: setup: The pkg-config package webkit-1.0 version >=1.1.15 is required but it
09:38:48 <dafis> could not be found.
09:39:04 <k0ral> hmmm ?!
09:39:25 <dafis> apparently yet another missing foreign lib
09:39:42 <k0ral> ah
09:39:49 <k0ral> libwebkit or something similar
09:40:50 <dafis> k0ral: sorry, but that's enough installs for me for today
09:42:02 <k0ral> dafis: no problem
09:45:51 * hackagebot diagrams-core 0.3 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-0.3 (BrentYorgey)
09:45:53 * hackagebot diagrams-lib 0.3 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-0.3 (BrentYorgey)
09:45:55 * hackagebot diagrams-cairo 0.3 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-0.3 (BrentYorgey)
09:47:48 <k0ral> guys, is it a good thing to gather all data types definitions in a single file imported by all others ?
09:48:14 <k0ral> because I currently have spread them over the source files and I have cross dependencies problems
09:49:31 <Twey> k0ral: Often
09:49:37 <Twey> Yes, that's why it's usually done
09:49:54 <siracusa> I'm using haskeline and having trouble printing an infinite String via outputStr. Is there a way to make haskeline output a string lazily?
09:50:35 <k0ral> Twey: thank you :)
09:53:52 * hackagebot snap-core 0.5.1 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.5.1 (GregoryCollins)
09:55:52 * hackagebot snap-server 0.5.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.5.1 (GregoryCollins)
09:55:54 * hackagebot snap 0.5.1 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.5.1 (GregoryCollins)
10:00:50 <siracusa> Or, as putStr works, to restate my question: Is it harmful to mix outputStr and liftIO putStr in haskeline?
10:11:02 <augur> anyone know why i might be getting an error from cabal when installing lhs2tex?
10:11:24 <dcoutts_> does the error message suggest anything?
10:12:27 <augur> http://hpaste.org/47987
10:13:04 <dcoutts_> setup: kpsewhich command not found
10:13:36 <augur> how do i fix that? x.x
10:13:57 <parcs> install texlive
10:13:59 <Eduard_Munteanu> It's from kpathsea
10:14:03 <dcoutts_> augur: not the most helpful, really it ought to say that it needs kpsewhich
10:14:22 <Eduard_Munteanu> See if your distro has a pkg for that.
10:14:56 <dcoutts_> augur: not the most helpful error message I mean
10:14:57 <augur> how would i go about either installing texlive or checking for this pkg in the distro
10:15:15 <Eduard_Munteanu> *sigh* :)
10:15:19 <augur> :P
10:15:25 <augur> cabal doesnt have these things
10:15:29 <augur> what a pain
10:15:34 <dcoutts_> augur: it's a ditro package we're talking about
10:15:37 <dcoutts_> not a cabal one
10:15:40 <Eduard_Munteanu> Because it's not a Haskell package.
10:15:44 <augur> ok then!
10:16:35 <Eduard_Munteanu> @google kpathsea
10:16:36 <lambdabot> http://www.tug.org/kpathsea/
10:16:36 <lambdabot> Title: Kpathsea - TeX Users Group
10:17:10 <augur> hmm hmm
10:18:51 <augur> yeah, see
10:19:00 <augur> im on a mac, so
10:19:45 <augur> who designs a path searching library and then only distributes it with another library
10:19:47 <augur> thats stupid
10:20:24 <Botje> it's a part of a lot of tex distributions
10:20:30 <Botje> texlive, for example
10:21:03 <augur> i have mactex installed
10:21:14 <augur> ill see if i can replace it with texlive somehow
10:22:21 <identity_> Bah
10:22:32 <identity_> Parallelism in Haskell is hard to grok
10:22:36 <identity_> strategies et al, anyway
10:26:13 <dcoutts_> identity_: tell me more, we're interested in making it more accessible
10:26:57 <identity_> dcoutts_: Well, it's just that I reallly don't understand lazy evaluation(like WHNF and all that) well enough.
10:27:02 <identity_> It's really hard to say to be honest
10:27:24 <identity_> I just need to get to trying to write some parallel code
10:30:30 <dcoutts_> identity_: so you were starting from looking at the haddock docs? or some other tutorial?
10:31:56 * hackagebot void 0.5.4 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.4 (EdwardKmett)
10:32:10 <identity_> dcoutts_: Reading simon's tutorial
10:32:11 <identity_> new one
10:32:41 <augur> man, mactex is a huge thing isnt it
10:32:42 <augur> wtf
10:33:18 * edwardk waves hello.
10:33:56 * hackagebot hbro 0.5.1 - A suckless minimal KISSy browser  http://hackage.haskell.org/package/hbro-0.5.1 (koral)
10:35:17 <xplat> augur: tex is pretty huge in general these days
10:35:27 <augur> crazy
10:35:32 <augur> why?
10:35:35 <merijn> augur: Only like 5-10GB I think? :p
10:35:40 <augur> 1.5 gigs :P
10:35:42 <xplat> i was shocked when livetex first came out
10:35:52 <augur> why the hell is it so big
10:35:54 <augur> wtf is going on
10:35:58 <merijn> On the upside I've never had to go onto CTAN to download anything :>
10:36:20 <Botje> tex still uses intermediary files, that says enough i think
10:36:24 <merijn> tex, latex, xetex, xelatax, fifteen billion other things for including images and lord knows what
10:36:31 <edwardk> representing polynomials is hard. lets go shopping
10:36:53 <merijn> Botje: And yet still no one has written something better then the original TeX (still in Pascal!)
10:37:06 <xplat> i always just assumed it contains 40 hours of pr0n somewhere
10:37:35 <merijn> If I had a time machine I would go back in time and tell Knuth "in 40 years this will still be the de facto CS publishing standard, are you sure you don't want to add a little bit better diagnostics to the error messages"?
10:38:05 <augur> from what ive seen of actual tex code, instead of latex, its horrendously cryptic
10:38:09 <augur> and incredibly low level
10:38:11 <edwardk> merijn: and risk him buckling under the pressure? i'd say not
10:38:22 <xplat> if you went back in time 40 years to do that you would return to find you had never been born
10:38:35 <xplat> so i wouldn't advise it
10:38:37 <merijn> xplat: Small price to pay! :p
10:38:47 <Botje> merijn: i rather like docbook.. it puts semantics before presentation
10:39:30 <merijn> Yes, but sometimes I just want to control presentation, screw the semantics
10:40:49 <Botje> then it should be visibly different from the semantics :)
10:42:23 <xplat> also, defining presentation in terms of semantics probably shouldn't be done by macro expansion ...
10:44:26 <cmccann> edwardk, so I finally noticed the other day that it looks like you've been busy disassembling the monolithic monster that was category-extras
10:47:24 <kstt> hey, I'm using a reader monad to thread an evaluator state. I have a list of "bindings" (key, value). I can mapM over the list to evaluate the value in the current context of bindings. However, I'd like to allow a binding n+1 to reference the binding n. Therefore, mapM does not look suitable for that. Should I foldM over it ? Some ideas ?
10:47:46 <edwardk> cmccann: yeah i've broken out just about everything from it
10:48:21 <MHD> kstt: Why not use a different structure than a list? Or write your own snippet to do what you want?
10:49:08 <cmccann> edwardk, I guess that's why you seem to have about five hundred github repos
10:49:16 <edwardk> cmccann: hahaha
10:49:49 <edwardk> i've put a few packages out there =)
10:49:58 <kstt> MHD: I think the list is okay. What I really want is to evaluate each element in my list with a monadic (reader) action, and populate the reader state as I'm going.
10:50:00 <cmccann> edwardk, is there an outline/overview of the new packages anywhere? descriptions of what's where and all
10:50:24 <kstt> I could do that easily recusively, but I'm looking for a combinator
10:50:27 <augur> hmm
10:50:34 <edwardk> not yet. i went over them with byorgey towards getting a new typeclassopaedia done, but we've both been pretty busy since.
10:50:34 <MHD> kstt: I'll reccomend fold then.
10:50:37 <augur> texlive utiliy tells me i have kpathsea installed
10:51:20 <edwardk> cmccann: i posted something to reddit enumerating a list of what the broken out packages were a few months ago, but they've evolved since then
10:51:57 <cmccann> edwardk, I missed that since I was busy and not doing any haskell stuff for a while, which is also why I just now noticed that you'd broken them out at all
10:52:15 <edwardk> http://www.reddit.com/r/haskell/comments/fvabx/greenfield_haskell/c1j0kju is a reasonable subset of them
10:52:38 <sbahra> Hi edwardk
10:52:59 <edwardk> the only major change since then is that free/cofree were merged into comonad-transformers
10:53:03 <edwardk> heya samy, ltns
10:53:24 <sbahra> Yeah, it's been busy with the relocation.
10:53:43 <edwardk> where'd you move?
10:53:47 <cmccann> edwardk, ooooh nice, actually that whole reddit post looks interesting
10:53:51 <sbahra> NYC.
10:54:07 <augur> this is obnoxious. where is cabal looking for this that it cant find it
10:54:16 <edwardk> ah nice. i'll have to look you up next time i wander down there.
10:54:31 <dcoutts_> augur: it'll just be looking on the $PATH
10:54:38 <dcoutts_> augur: ie if you can run it, so can cabal
10:54:55 <sbahra> edwardk, please do. :-)
10:55:03 <augur> hmm
10:56:25 <edwardk> Been spending the last couple of days playing around with extending my automatic differentiation library to emit chebyshev polynomial approximations as well as taylor series, and to emit pade approximants and chebyshev-pade approximants.
10:56:49 <augur> so how do i check that i can run kpathsea
10:57:29 <dcoutts_> augur: type kpsewhich on the command line
10:57:39 <augur> doesnt work
10:58:05 <dcoutts_> ok, then it's not installed or not installed correctly
10:58:12 <augur> >_<
10:58:18 <augur> damn you texlive utility!
10:58:22 <dcoutts_> augur: once you can run kpsewhich then cabal will be able to do so too
10:58:40 <cmccann> edwardk, would you (or possibly byorgey, transitively) be interested in me taking a stab at explaining any of it?
10:59:11 <edwardk> but i can't find a nice common representation for the various polynomial bases, some extend cleanly to higher dimensional cases,  chebyshev, power, factorial, etc. some to a lesser extent: like newton, and some require pretty complete reworking as you enlarge the space: legendre, bernstein, lagrange, etc.
10:59:16 <cmccann> edwardk, I've written enough stuff about Haskell at this point that I'm thinking about organizing it for better presentation anyway, so new material would be no big deal
10:59:17 <djahandarie> 15:22 - comonad [~functor@zygohistomorphic-prepromorphism.endofunctor.org] has joined #haskell
10:59:20 <djahandarie> lol
10:59:43 <edwardk> cmccann: feel free. you're also welcome to submit patches with docs to the github repos
11:00:04 <edwardk> hah
11:00:10 <augur> dcoutts_: found the bin!
11:00:23 <augur> its in /usr/texbin
11:00:38 <augur> now i suppose i should change my $PATH
11:00:43 <djahandarie> @remember comonad - comonad [~functor@zygohistomorphic-prepromorphism.endofunctor.org] has joined #haskell
11:00:44 <lambdabot> I will remember.
11:00:54 <dcoutts_> augur: yeah, at least temporarily to be able to install
11:01:10 <edwardk> and i'd ideally like to be able to recycle the polynomial representation once i build pade approximants with them, which means somehow figuring out a nice general purpose pade approximant construction approach that doesn't care about change of basis
11:02:50 <edwardk> then there is the ancillary goal of being able to produce a nice multivariant polynomial representation over different bases that i'd be willing to work with, and the fact that multivariant pade approximants are kind of messy
11:02:57 <cmccann> edwardk, my only concern is that I'm pretty shaky on the math so I'm worried about introducing subtle errors. :[ It won't be much help if proofreading and correcting anything I write takes more time than writing it.
11:02:57 <joe6> any suggestions on how I can modify this code:  http://sprunge.us/hPhW
11:03:13 <joe6> and i am trying to use it as:  http://sprunge.us/fNZj
11:03:44 <edwardk> cmccann: i'm willing to take the time to proofread, just less willing to take the time to spend a lot of time formatting out haddocks ;)
11:04:09 <cmccann> edwardk, heh, fair enough
11:06:01 * cmccann really wishes he'd had some sort of useful mathematical education
11:06:30 <ddarius> cmccann: That's something within your ability to change.
11:06:33 <merijn> cmccann: #haskell has that effect on people :p
11:06:33 <JuanDaugherty> it's one of those things you can teach yourself if you're sufficiently motivated and intelligent
11:06:49 <merijn> JuanDaugherty: It's difficult to do solo, though
11:06:52 <cmccann> it's not motivation or ability, it's free time available :P
11:06:56 <ddarius> merijn: Why?
11:07:10 <cmccann> it's just not the top of my list of things to do
11:07:35 <merijn> ddarius: No one who can help you verify that you are actually understanding things correctly
11:07:36 <JuanDaugherty> merijn, for some people I guess. I think of math as inherently indivdualistic.
11:07:39 <cmccann> I'm more wishing I'd learned this stuff back when I had more time, instead of all the stuff I wasted time on, heh
11:08:07 <merijn> I often read things but then I'm not sure whether I got it or things got jumbled together in my brain
11:08:29 <merijn> JuanDaugherty: Really? I always think of math as the opposite :)
11:08:37 <cmccann> merijn, the nice thing about learning math via applications to programming is that lack of understanding usually manifests quickly as broken code :P
11:08:39 <ddarius> merijn: That's what proofs and exercises are for.
11:08:40 <merijn> I can only do math with others :>
11:09:03 <gwern> @seen zooko
11:09:03 <preflex>  zooko was last seen on #darcs 8 days, 19 hours, 55 minutes and 32 seconds ago, saying: This is for backup, right? There is the "tahoe backup" command which is really good for that.
11:09:03 <lambdabot> Unknown command, try @list
11:09:06 <ddarius> Heck, nowadays you have things like Coq to tell you when you're wrotg.
11:09:20 <merijn> A correct proof != understanding
11:09:46 <merijn> I'll take a vague intuition over a correct but un-understandable proof any day
11:10:05 <ddarius> merijn: Yes, but if you can produce a correct proof -and- feel that you understand, then you probably do.  Whereas if you feel that you understand, but can't produce a correct proof, then you probably don't.
11:10:10 <gwern> @quote theorem.*important
11:10:10 <lambdabot> AlanPerlis says: The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to
11:10:10 <lambdabot> mathematics.
11:10:14 <ddarius> And if you don't feel you understand, then you probably don't.
11:10:46 <Veinor> gwern: haha
11:11:10 <JuanDaugherty> merijn, yes really. True the truths of mathematics must be verified socially but the work tends to be highly individual, committees like Bourbaki notwithstanding
11:11:40 <JuanDaugherty> and I found a decent undergrad math education entirely sufficient
11:11:43 <merijn> Hell, I could follow and check several algebra proofs when I was following that class. But I never understood why any of it was useful until someone pointed at Monoid and how list is a monoid
11:11:53 <JuanDaugherty> (as a basis)
11:12:12 <ddarius> merijn: Understanding something and knowing why it may be useful are orthogonal.
11:12:27 <ddarius> (For example, it may not be useful.)
11:12:41 * cmccann is prone to pathological autodidactism and really doesn't understand the idea of learning as a group activity :T
11:13:21 <merijn> cmccann: In my experience the best way to learn is to surround yourself with people smarter then you :p
11:13:37 <cmccann> ddarius, I think the history of mathematics demonstrates that anything that works is useful, even if it's not obvious how
11:13:44 <ddarius> In my experience the best way to learn is to learn to learn and practice learning.
11:14:30 <cmccann> merijn, I find that useful mostly as a reminder to not slack off :P
11:15:00 <ddarius> cmccann: Maybe pre-20th century.  Anyway, if no-one currently knows if something is useful, it still doesn't mean no-one understands it.
11:15:01 <merijn> Slacking off has produced some of my deepest understandings :)
11:15:07 <augur> yay yay yay
11:15:09 <augur> lhs2tex!
11:15:11 <joe6> any suggestions on how I can fix this:  http://sprunge.us/HbPh
11:15:49 <cmccann> ddarius, yes, I wasn't disputing the assertion of orthogonality
11:16:01 <joe6> i am not able to get it to parse NorthEast correctly, it reads it as North.
11:16:19 <bonobo123> joe6:
11:16:21 <hpaste> matt pasted “test” at http://hpaste.org/47990
11:16:38 <mdeboard> Can anyone tell me why the above paste is failing?
11:16:54 <bonobo123> joe6: parser whole word, then check which ne you got
11:17:05 <bonobo123> one*
11:17:20 <augur> uh ok.. so now the question is how do i use lhs2tex
11:17:27 <Botje> mdeboard: you need to do something with the result of makeCombos
11:17:29 <bonobo123> I mean up to a whitespace or non-letter character
11:17:31 <augur> oh i see
11:17:50 <mdeboard> Botje: Ah, ok. Like putStr or whatnot?
11:18:22 <Botje> yes
11:18:32 <joe6> bonobo123: it is actually part of  http://sprunge.us/cCBS
11:18:33 <Botje> or print :)
11:18:59 <joe6> I probably need stringToEnum
11:19:21 <bonobo123> help. my ghc +RTS -hc -RTS isn't working as expected... produced .hp file does not contain any useful information
11:19:28 <ddarius> At any rate, I would recommend learning things that you think might be applicable to what you want to do.
11:19:42 <mdeboard> Botje: Oh, yay. My first haskell function. Thanks.
11:19:53 <bonobo123> joe6: you try strings from list, try any string, then do lookup
11:21:18 <bonobo123> where did the -hT flag go?
11:21:36 <vilhelm_s> When I try to cabal install category-extras, it fails with "Duplicate instance declarations" (paste here: http://hpaste.org/47991). Anyone know what this is about?
11:21:51 <edwardk> vilhelm_s: category-extras has been split up and retired
11:22:02 <vilhelm_s> Oh, what should I use?
11:22:08 <edwardk> in particular those instances were for Either, and have ben folded into base since it was written
11:22:09 <mdeboard> My next question is, now that that function is working, how do I go about processing the output (a list of ~ 3000 5-char strings) with another function? In Python, for example, I'd use a couple of nested for loops, and call th efunction every time through the inner for loop. But in Haskell I oughtn't do that. What'st he alternative? List comprehensions?
11:22:12 <edwardk> depends on what parts you need
11:22:19 <edwardk> what are you wanting to use out of it?
11:22:19 <vilhelm_s> Braided, Symmetric
11:22:23 <edwardk> 'categories'
11:22:27 <vilhelm_s> Thanks!
11:22:33 <edwardk> that contains just the categories from category-extras
11:23:31 <cmccann> edwardk, nice timing with that, looks like you really do need that overview I asked about ;]
11:23:33 <mdeboard> Traversable ~= iterable?
11:23:56 <edwardk> cmccann: =)
11:24:13 <edwardk> mdeboard: you probably want just foldable. traversable is more like 'refillable' ;)
11:24:36 <edwardk> foldable lets you get the contents out. traversable lets you put other contents in in the process.
11:25:08 <mdeboard> I'll be honest the official docs for Foldable are impenetrable
11:25:19 <gwern> @ask zooko http://themonetaryfuture.blogspot.com/2011/05/bitcoin-timing-is-everything.html?showComment=1306860158361#c6958602700376442348 is interesting and I plan to quote you; or do you have a longer reply you'd prefer me to quote?
11:25:19 <lambdabot> Consider it noted.
11:25:23 <gwern> @flush
11:25:30 <edwardk> mdeboard: Foldable just gives you generalized foldr.
11:25:32 <edwardk> @type foldr
11:25:32 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:25:38 <edwardk> @type Data.Foldable.foldr
11:25:39 <lambdabot> forall a b (t :: * -> *). (Data.Foldable.Foldable t) => (a -> b -> b) -> b -> t a -> b
11:25:46 <cmccann> Traversable is more a generalized version of mapM/sequence/etc.
11:25:51 <edwardk> and a ton of combinators that otherwise work on lists now work on your type.
11:26:33 <edwardk> Traversable lets you refill, an 'f a' into a new 'f b', using applicative or monadic actions. if you just need to touch all the elements monadically, you an use foldable's mapM_, etc.
11:26:35 <edwardk> @type mapM
11:26:36 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
11:26:39 <edwardk> @type mapM_
11:26:40 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
11:26:50 <edwardk> @type Data.Traversable.mapM
11:26:51 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
11:26:54 <edwardk> @type Data.Foldable.mapM_
11:26:55 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Foldable.Foldable t, Monad m) => (a -> m b) -> t a -> m ()
11:27:23 <joe6> is there a stringToEnum function? I have an enum of Mon | Tue | Wed and I get a string of "Mon","Tue" or "Wed". I am trying to convert the string to Enum
11:27:37 <joe6> I could list out all the enum data and then do a pattern match
11:27:49 <edwardk> the key difference between foldable and traversable is that traversable lets you build new 'f's with different types in them. this lets us have things like sets be foldable, but not traversable.
11:27:50 <joe6> but, am curious if there is a smarter way of doing better.
11:29:23 <parcs> joe6: read ?
11:30:15 <mdeboard> edwardk: So, I need to think about a mapping function that does "take 1 foo" as argument 1, my whole list as arg 2 and the monad I want to oh god my brain
11:30:19 <joe6> parcs, let me try read.
11:30:22 <edwardk> joe6: read ?
11:30:50 <edwardk> mdeboard: what do you want to do?
11:30:55 <chrisdone> Anyone used the web-routes package?
11:31:39 <hpaste> mdeboard pasted “lev” at http://hpaste.org/47992
11:31:49 <djahandarie> edwardk, your Braided and Symmetric seem awfully... underconstructed
11:32:00 <edwardk> djahandarie: ?
11:32:09 <mdeboard> edwardk: feed output of makeCombos into levenshtein, comparing every 5-char string to every other one
11:32:39 <edwardk> djahandarie: symmetric is just a contract that braid . braid = id
11:32:47 <edwardk> djahandarie: braid is pretty minimal ;)
11:33:06 <djahandarie> edwardk, why is there no class (Monoidal k p) => ?
11:33:07 <edwardk> arguably one should have Category k, and Bifunctor p
11:33:20 <edwardk> http://hackage.haskell.org/packages/archive/categories/0.55.2/doc/html/Control-Category-Monoidal.html
11:33:27 <edwardk> that?
11:33:27 <djahandarie> Braiding without actually referencing to the Monoidal Bifunctor doesn't make much sense
11:33:31 <djahandarie> Yes
11:34:04 <edwardk> i had some things i needed to braid that weren't all the way to monoidal ;)
11:34:31 <djahandarie> Weird, like what?
11:34:47 <edwardk> well, a lot of stuff just gives me http://hackage.haskell.org/packages/archive/categories/0.55.2/doc/html/Control-Category-Associative.html
11:35:26 <edwardk> consider that Either is not 'Comonoidal' in the sense of that package
11:35:31 <edwardk> but (,) is Monoidal
11:36:02 <edwardk> arguably i should require Associative k p as a superclass of Braided k p
11:36:15 <edwardk> but i can still braid Either
11:36:59 * djahandarie goes to lunch
11:38:47 <edwardk> added the Associative constraint at least
11:39:03 * hackagebot categories 0.56.0 - categories from category-extras  http://hackage.haskell.org/package/categories-0.56.0 (EdwardKmett)
11:39:52 <mdeboard> edwardk: I've got a list that looks like this: ["abcde", "fghij", "klmno", "pqrst"]. I've got a function, levenshtein::String->String->Int. My aim is to execute "levenshtein list!!0 list!!0 && levenshtein list!!0 list!!1 && levenshtein list!!0 list !!2 && ... levenshtein list!!3 list!!3". I am stumped on how to perform this computation programmatically in Haskell. (I've written this out in Python, but the functional
11:39:53 <mdeboard> approach is hurting me.)
11:41:30 <edwardk> mdeboard: ok. going to look at it now =)
11:42:16 <parcs> edwardk: let list = ["abcde", "blah", "etc"] in levenshtein <$> list <*> list
11:42:20 <edwardk> so you want to walk over the list twice, and compare everything to everything else?
11:42:22 <parcs> oops, mdeboard ^
11:42:39 <edwardk> then you can use parcs answer above. note it'll compare the diagonal as well
11:42:47 <mdeboard> edwardk: Yeah.
11:42:53 <Eduard_Munteanu> @where platform
11:42:53 <lambdabot> http://hackage.haskell.org/platform/
11:42:55 <mdeboard> parcs: Isn't that still an O(n^2) solution?
11:43:06 <mdeboard> shit I don't care
11:43:09 <edwardk> mdeboard: yes, to a O(n^2) question ;)
11:43:11 <mdeboard> I'll optimize later
11:43:24 <mdeboard> Is it just irrefutably O(n^2) to compare each?
11:43:37 <mdeboard> Yeah I guess that makes sense.
11:43:39 <edwardk> n items you need to compare to n items. yes
11:44:05 <mdeboard> Why the angle brackets, parcs?
11:44:12 <edwardk> there is a whole school of phylogeny algorithms used to try to hierarchicalize distance metric trees like this
11:44:14 <mdeboard> Sorry, I'm obv a total newcomer
11:44:48 <cmccann> mdeboard, angle brackets meaning <$> and <*>?
11:44:50 <edwardk> there is also a way to memoize the internal structure of levenshtein
11:44:59 <mdeboard> Yeah, why the angle brackets around $ and *
11:45:03 <mdeboard> @ cmccann
11:45:15 <cmccann> because those are what the operators are called :]
11:45:22 <parcs> :t (<*>)
11:45:22 <cmccann> cf. Control.Applicative
11:45:22 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
11:45:24 <parcs> :t (<$>)
11:45:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:45:33 <mdeboard> :t ($)
11:45:34 <lambdabot> forall a b. (a -> b) -> a -> b
11:45:40 <mdeboard> ah
11:45:54 <edwardk> mdeboard: you can also use liftM2 levenshtein
11:45:59 <cmccann> but in this case doing f <$> xs <*> xs for some function f and list xs applies f to the cartesian product of the list with itself
11:46:06 <cmccann> i.e. all possible pairs of elements
11:46:18 <cmccann> > (,) <$> [1,2,3] <*> [1,2,3]
11:46:19 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
11:46:26 <edwardk> mdeboard: the <$> and <*> approach is the more idiomatic way to lift some pure computation into an applicative functor. list is an applicative functor for dealing with nondeterminism
11:47:32 <identity_> Just the fact that you can say something like "list is an applicative functor for dealing with nondeterminism" makes haskell cooler than any other language :P
11:47:44 <edwardk> identity: =)
11:47:53 <cmccann> :t join . liftA2
11:47:54 <lambdabot> forall b c (f :: * -> *). (Applicative f) => (b -> b -> c) -> f b -> f c
11:47:55 <cmccann> :]
11:50:44 <edwardk> does anyone know any good references for rational approximation theory?
11:50:54 <mdeboard> Hrm, "<interactive>:1:30: Not in scope: `<$>'"
11:51:02 <edwardk> (i tried in #math and received a series of blank stares)
11:51:03 <identity_> mdeboard: Control.Applicative
11:51:09 <identity_> @index (<$>)
11:51:09 <lambdabot> bzzt
11:51:09 <mdeboard> ah thx
11:51:11 <edwardk> mdeboard: import Control.Applicative
11:51:17 <Cale> identity_: Well, apart from Agda and other futuristic things at least :)
11:51:28 <identity_> Cale: Don't rain on my fanboy parade
11:51:30 <mdeboard> is there an @index-like tool for ghci? I tried :hoogle "<$>" but it came up nil
11:51:45 <identity_> mdeboard: should work fine
11:52:01 <edwardk> i really wish haskell had agda's context 'holes'. would be so much nicer to work back and forth with the compiler.
11:52:02 <identity_> mdeboard: use parentheses
11:52:17 <cmccann> identity_, no worries, Agda was written in Haskell so Haskell receives the coolness transitively
11:52:19 <identity_> :hoogle (<$>)
11:52:24 <identity_> cmccann: Ah, very well
11:52:27 <mdeboard> identity_: Ah thanks
11:53:14 <identity_> I should have stayed in school. So rusty at math. Even having a hard time remembering basic trig
11:54:19 <edwardk> identity: then start here http://www.youtube.com/user/njwildberger and relearn it without sin and cos, and all that stuff ;)
11:54:27 <drdo> identity_: that has nothing to do with school :)
11:54:40 <identity_> edwardk: Well, not *that* rusty :P
11:54:49 <mdeboard> I took trig again this spring after not taking it for ten years. I loved it
11:54:51 <edwardk> well, he goes pretty deep
11:54:55 <identity_> drdo: Not necessarily, but I was referring to the fact that if I had stayed I would been using it more regularly
11:55:03 <ddarius> There's little reason to bother learning "trigonometry" as normally taught.  Just remember the Euler formula and all the crazy trig identities are immediate.
11:55:07 <identity_> instead of letting it slip
11:55:20 <edwardk> that is a course on rational trigonometry, which replaces sins and cosines with normal algebraic functions, by working with squared angles and distances.
11:56:04 <edwardk> i mostly survived on a solid linear algebra foundation, and an understanding of the dot product to make up for never taking trig
11:56:45 <mdeboard> Chebyshev polynomials, de Moivre's theorem & Euler formula are enough shorthand to do well. Those are big bites though.
11:56:46 <ddarius> Rational trigonometry is probably a better way to do trigonometry, but, as Wildberger says, sin/cos are more about circles rather than triangles, so rational trigonometry is not an alternative to understanding what sin/cos are really talking about.
11:56:57 <edwardk> yeah
11:57:20 <edwardk> i mostly like it because it lets me stay analytic as long as possible.
11:57:31 <identity_> edwardk: Well, thanks for the link anyway. I'll probably spend some time watching that
11:57:44 <ddarius> sin and cos are analytic.
11:58:00 * ddarius purposely misinterprets Ed's statement.
11:58:00 <edwardk> touche
11:58:56 <edwardk> i mostly started mining his material for information on spread polynomials
11:59:28 <ddarius> edwardk: I actually like the Math Foundation series.  The Math History series is also enjoyable.
11:59:33 <edwardk> as i was thinking about using spread polynomials to smooth a pade approximant over an interval rather than the usual chebyshev polynomials
12:00:10 <edwardk> they are easily interconverted, but the [0,1] range of the spread polynomials fit better with my usecase
12:00:44 <mdeboard> edwardk, parcs, cmccann: Thanks, I've got it working, and even wrote a list comprehension to boot. I've been working on this all weekend. Thanks.
12:00:56 <edwardk> =)
12:01:01 * ddarius rarely uses list comprehension syntax.
12:01:04 <edwardk> happy to help
12:01:08 <cmccann> mdeboard, you're welcome :]
12:02:39 <edwardk> ddarius: do you know any good sources for information on multivariate chebyshev polynomials, and their ilk?
12:02:49 <mdeboard> ooh, ooh, I know this one.
12:03:50 <mdeboard> Well, you probably mean besides wolfram
12:04:24 <bobby> 'sup
12:04:31 <identity_> mdeboard: what are you working on, out of curiosity?
12:04:37 <int80_h> hiy
12:05:11 <bobby> 17blue
12:05:19 <mdeboard> identity_: Just an experiment. I wrote some small algorithmic scripts in Python and decided to try to use them as an exercise to learn a little about Haskell  by translating
12:05:32 <identity_> ah
12:05:58 <edwardk> mdeboard: well, i've been playing with representing lots of different polynomial bases in haskell and wanting to extend things nicely to the multivariate case. for polynomials this isn't that bad, except for the fact that some bases are a pain in the butt to extend
12:06:01 <ddarius> edwardk: Not off the top of my head.
12:06:07 <mdeboard> edwardk: When you said parcs' method will calculate diagonals as well, what did you mean, there?
12:06:21 <int80_h> where is the default location for a local install of haddock docs?
12:06:25 <cmccann> mdeboard, that it generates all pairs, including duplicates
12:06:30 <mdeboard> ahh
12:06:31 <edwardk> mdeboard: when you stated the problem you skipped computing the levenshetein distance of any string with itself
12:06:32 <mdeboard> ergo memoizaiton
12:07:08 <edwardk> for [x,y,z] you skipped [(x,x),(y,y),(z,z)]
12:07:12 <cmccann> mdeboard, recall my example
12:07:14 <cmccann> > (,) <$> [1,2,3] <*> [1,2,3]
12:07:15 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
12:07:32 <mdeboard> right
12:07:51 <mdeboard> Well, I only skipped mentioning it to avoid premature optimization
12:07:59 <mdeboard> now that it works, I want to optimize. :P
12:08:16 <edwardk> you can of course fix this. [ levenshtein x y |(m,x) <- zip [1..] xs, (n,y) <- zip [1..] y, m /= n]
12:08:28 <edwardk> but then you probably want to include in the result, what the strings are
12:08:52 <edwardk> er zip [1..] ys
12:08:52 <mdeboard> Right, I'm rewriting the lev function to do that
12:09:26 * cmccann notes that the "all pairs without duplicates" is the difference between the two possible applicative instances for the lists
12:09:47 <edwardk> ddarius: so it seems you picked up a new used bookstore up the hill from you.
12:10:26 <trygvis> howdy! are there any tools to automatically organize imports on a set of .hs files?
12:12:14 <mdeboard> xs/ys syntax, is that "current instance" ? Or, like, "the rest of x"
12:12:19 <mdeboard> i.e. tail
12:12:27 <mdeboard> in general, I Mena
12:12:28 <Cale> mdeboard: It's plural
12:12:28 <mdeboard> mean*
12:12:34 <Cale> It's just a convention :)
12:12:41 <mdeboard> Right, but what does the convention indicate
12:12:44 <Cale> xs is like the plural of x
12:12:49 <ddarius> That it is a list.
12:12:52 <mdeboard> ok
12:12:55 <mdeboard> @ ddarius
12:13:00 <int80_h> Cale: where is the default location for a local install of haddock docs?
12:13:18 <Cale> ~/.cabal/share/doc/index.html
12:13:20 <Cale> ?
12:13:29 <int80_h> hmm I looked there
12:13:34 <int80_h> I'll look again
12:14:10 <Cale> At least, that's where the cabal-generated documentation is on my machine
12:14:39 <Cale> Do you have   documentation: True   in your ~/.cabal/config ?
12:14:43 <int80_h> hmm I just tried to get cabal to explicitly install haddock docs for Yesod. It claimed it was already installed
12:14:54 <Cale> --reinstall
12:14:54 <int80_h> ooh checking
12:15:50 <int80_h> documentation false!
12:15:52 <Cale> Yeah, I find it mildly upsetting that generating documentation isn't the default behaviour, because I always end up rebuilding several packages on a fresh install to get documentation built right, and it's a bit of a hassle.
12:15:56 <int80_h> thanks I will change and reinstall
12:16:31 <Cale> Another thing which can be quite annoying is rebuilding everything as soon as you need profiling.
12:16:48 <Cale> You might also want  library-profiling: True
12:17:13 <Cale> which should build the profiling versions of everything you install alongside the normal ones
12:27:52 <mdeboard> wow so by not excludiing dupes the number of extra calculations is... 2 * length list?
12:28:50 <edwardk> length list actually. you also compare each item twice. so you do more work than is strictly necessary since the response is symmetric
12:29:08 <edwardk> levenshtein a b == levenshtein b a
12:43:14 * hackagebot scrypt 0.1 - Stronger password hashing via sequential memory-hard functions.  http://hackage.haskell.org/package/scrypt-0.1 (FalkoPeters)
12:45:54 <parcs> neat scrypt binding
12:52:16 <joe6> is there a better way of doing this: appendFile fileName . flip (++) "\n" . intercalate "\n" $ content
12:52:34 <joe6> the intercalate does not put the trailing newline.
12:55:05 <parcs> appendFile fileName (unlines content) >> appendFile fileName "\n"
12:56:11 <joe6> parcs, that is pretty cool.
12:56:13 <joe6> thanks
12:56:25 <cmccann> why not (++ "\n") instead of using flip?
12:56:26 <geheimdienst> map (++ "\n") content ...?
12:56:51 <parcs> @hoogle appendFile
12:56:52 <lambdabot> Prelude appendFile :: FilePath -> String -> IO ()
12:56:52 <lambdabot> Data.ByteString appendFile :: FilePath -> ByteString -> IO ()
12:56:52 <lambdabot> System.IO appendFile :: FilePath -> String -> IO ()
12:57:55 <parcs> > unlines ["hello","there"]
12:57:55 <lambdabot>   "hello\nthere\n"
12:57:57 <parcs> oh
12:58:14 <parcs> then it's just appendFile filePath (unlines content) :P
12:59:05 <parcs> @src unlines
12:59:05 <lambdabot> unlines = concatMap (++ "\n")
12:59:17 * hackagebot tls 0.7.1 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.7.1 (VincentHanquez)
13:00:57 <joe6> parcs, yes, got it.
13:01:11 <joe6> unlines is so much more comprehensible than intercalate
13:01:23 <joe6> cmccann: thanks.
13:30:17 <gwern> @hoogle readdir
13:30:17 <lambdabot> No results found
13:30:47 <pastorn> @hoogle FilePath -> IO [FilePath]
13:30:47 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
13:30:48 <lambdabot> System.Console.Editline.Readline filenameCompletionFunction :: String -> IO [String]
13:30:48 <lambdabot> System.Console.Editline.Readline usernameCompletionFunction :: String -> IO [String]
13:30:55 <pastorn> gwern: ^^^
13:33:02 <gwern> pastorn: that doesn't help me. darcs-graph's compilation is failing on readdir, not those others
13:33:36 <gwern> I think it comes from System.Posix.Internals...
13:37:20 <geheimdienst> gwern, i'd try hayoo. hoogle doesn't know about platform-specific unixy things
13:42:03 <mike-burns> Looking into parsing command-line arguments. Is cmdargs the recommended package?
13:42:21 <mike-burns> I need to know the ordering of the command-line args, too.
13:45:42 <mike-burns> For example, if I were writing the `ls' command I'd want   ls -A -a   to go with the -a instead of te -A .
13:45:55 <mike-burns> Is there a way to make cmdargs do that for me?
13:57:41 <dino-> mike-burns: If I understand what you're asking for, I use System.Console.GetOpt
13:58:23 <dino-> Good examples of usage in the API docs as well.
13:58:30 <mike-burns> I'll give that a try. Thanks, dino- .
14:06:04 <d7> Yeesh
14:06:15 <d7> Writing a http proxy is turning out to be a huge pain in my ass.
14:06:53 <d7> Gotta completely translate Snap's custom HTTP request stuff into something spoken by HTTP.Enumerator
14:07:20 <albertid> writing interfaces is boring
14:07:37 <d7> And tedious. Don't forget tedious.
14:07:44 <ddarius> albertid: So don't do it.
14:07:56 <Botje> outsource it to china!
14:11:03 <albertid> there should be "quickface", a interface generator ala quicktest
14:14:23 <d7> Maybe part of the problem is I just don't get all the libraries HTTP.Enumerator is talking about yet.
14:14:34 <d7> Like, Failure.
14:16:12 <dafis> gwern: readDirStream calls readdir(2)
14:16:25 <dafis> System.Posix.Directory
14:19:55 <albertid> d7, is it just two data structures you need to transform eventually or is there some more logic involved?
14:21:12 <gwern> dafis: that looks quite painful to use
14:21:22 <gwern> @hoogle FilePath -> [FilePath]
14:21:22 <lambdabot> System.FilePath.Posix splitDirectories :: FilePath -> [FilePath]
14:21:22 <lambdabot> System.FilePath.Windows splitDirectories :: FilePath -> [FilePath]
14:21:22 <lambdabot> System.FilePath.Posix splitPath :: FilePath -> [FilePath]
14:23:15 <d7> albertid: Well it's actually lots of data structures
14:24:42 <gwern> ffs, darcs-graph doesn't even call readDir!
14:24:46 <d7> albertid: I need to convert Snap.Internal.Http.Types.Requests into Network.Http.Enumerator.Requests
14:24:51 <gwern> dammit dons
14:25:01 <d7> albertid: And also the result types back.
14:25:18 <d7> albertid: So for example, the headers are subtly different
14:25:25 <d7> albertid: And the request methods are different.
14:25:43 <albertid> d7, I see, so its also functions
14:26:01 <d7> Maybe Snap has some rad way of doing this I don't know of
14:26:51 <albertid> maybe you can try to get the raw request, and parse it again with Http.Enumerator...
14:27:09 <albertid> but that wouldn't be so nice because it will be parsed by snap and by you
14:27:09 <d7> albertid: I don't think I can do that easily
14:27:13 <d7> Yeah
14:27:20 <d7> And also Snap is an enumerator framework
14:27:35 <d7> So it's kinda hard to snag that data from inside their own enumerator
14:31:09 <d7> Ah, it'd probably be easier to write an attoparsec-enumerator into a request directly, then modify that and send it back out
14:31:23 <d7> Rather than muck about with a translation layer
14:42:33 <int80_h>     Could not find module `Yesod.Form.Core':
14:42:33 <int80_h>       It is a member of the hidden package `yesod-form-0.1.0.1'.
14:42:44 <int80_h> how do I use ghc-pkg to expose that?
14:43:01 <int80_h> Yesod.Form.Core...couldn't get the syntax quite right
14:43:57 <geheimdienst> int80_h: i guess you're trying to "cabal build" something which has "import Yesod.Form.Core" in the .hs file, but is missing "build-depends: yesod-form" in the .cabal file
14:44:46 <int80_h> geheimdienst: I'm using ghc --make
14:45:18 <int80_h> not cabal build
14:45:55 <int80_h> also, runhaskell
14:46:55 <geheimdienst> try "ghc-pkg list yesod-form". i think that will tell you if it's hidden ... not really sure
14:47:03 <monochrom> ghc-pkg expose yesod-form
14:47:15 <monochrom> but I wonder why it was hidden
14:48:00 <int80_h> monochrom: still getting same error
14:48:13 <int80_h> it's yesod.form.core that is hidden
14:48:32 <int80_h> oh wait I see the problem
14:48:41 <geheimdienst> Yesod.Form.Core is a module name, yesod-form is a package name
14:51:12 <monochrom> perhaps you have too many versions of yesod-form. the newer version has no Yesod.Form.Core
14:51:37 <monochrom> the older version is ignored if you have a newer version and you merely ghc --make
14:52:04 <monochrom> write a *.cabal file to hand-pick versions
14:52:08 <geheimdienst> the sad thing is, i ran into "member of a hidden package" errors before, but i can't recall how i fixed them
14:52:16 <aa_> which web framework?
14:53:09 <monochrom> or get rid of multiple versions altogether
14:53:36 * hackagebot Transhare 0.9 - A library to apply transformation to containers so as to maximize sharing of unchanged subcomponents.  http://hackage.haskell.org/package/Transhare-0.9 (ChrisKuklewicz)
14:54:03 <geheimdienst> shouldn't "ghc-pkg list" have shown it if he had multiple versions installed ...
14:54:21 <monochrom> yes
14:56:24 <hpaste> Alan1 pasted “string to number” at http://hpaste.org/47999
14:57:06 <Alan1> How do I change this to do what I want
14:57:35 <Alan1> I have been trying reverse
14:59:47 <Saizan> foldr multAdd  0 (reverse ds) <- should work
14:59:59 <Saizan> but it's better to use foldl' at this point
15:00:25 <Saizan> > foldl' (\s d -> d + 10*s) 0 [1,2,3,4
15:00:25 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:00:27 <Saizan> > foldl' (\s d -> d + 10*s) 0 [1,2,3,4]
15:00:28 <lambdabot>   1234
15:00:42 <confound> right, just change the * 10
15:05:23 <dino-> > read "1234" :: Int
15:05:24 <lambdabot>   1234
15:05:55 <dino-> If your data is coming from a string.
15:07:15 <confound> yeah, seemed like a high possibility of xy
15:07:37 <Alan1> form_number_front [1, 2, 3, 4] should return the number 1234;
15:07:37 <Alan1> form_number_front [ ] returns 0
15:08:58 <confound> that's what saizan's solution did
15:14:53 <bignose> is there a style guide for Haskell code that most programmers conform to?
15:17:45 <Boney> bignose: not that I'm aware of.
15:18:15 <Boney> I've certainly seen different programmers have different styles.
15:18:37 <Boney> for instance I prefer:  exp where var = value
15:18:39 * hackagebot aosd 0.1 - Bindings to libaosd, a library for Cairo-based on-screen displays  http://hackage.haskell.org/package/aosd-0.1 (DanielSchuessler)
15:18:51 <Boney> where as I see people use:  let var = value in exp
15:19:12 <neilk_> On StackOverflow, someone suggested there were a number of different styles from different schools
15:19:42 <Boney> bignose: Can I ask, why are you interested in Haskell, has twb been prodding you? :-)
15:20:23 <confound> for example, the French school features a lot more slashing motions than the Italian school, and doesn't emphasize dodging as much
15:21:18 <neilk_> http://stackoverflow.com/questions/6398996/good-haskell-source-to-read-and-learn-from
15:21:42 <neilk_> I have to say this is one of the more scary answers, and was more likely to repel a newbie who was just looking for something to learn from
15:22:16 <Alan1> They are promoting Haskell as an up and coming language at Georgian College in Barrie
15:23:34 <Cale> neilk_: Eh?
15:24:01 <scooty-puff> when you write large enough libraries, do you find yourself defining tons of monads?
15:24:04 <confound> it's not like the answer says "read all these before writing any haskell"
15:24:09 <scooty-puff> or at least newtype's of the standard ones?
15:24:32 <Cale> scooty-puff: tons of? Probably not?
15:24:40 <Cale> Are you finding yourself doing that?
15:24:48 <neilk_> Cale: The questioner is looking for good examples, not to become some kind of expert at telling apart the various styles. It would be better IMO to give them one style to learn first.
15:24:51 <Cale> Maybe one or two?
15:24:55 <scooty-puff> well, maybe not tons, but its a relatively small project and so far 3 major ones
15:25:20 <scooty-puff> one for code generation, one for namespace/scope handling, and probably one more soon
15:25:22 <albertid> I like it how the stackoverflow posts lists all these people. like they were jazz players and their programs were their songs
15:25:27 <Cale> scooty-puff: Well, that's one way to organise things. It's nice to recognise monads where they crop up, but usually I don't set out to define a monad.
15:25:35 <scooty-puff> ok
15:25:36 <ben> I found the "read code by certain people" links pretty useless since I didn't want to dig through someone's CV just to find some code
15:25:41 <scooty-puff> they seem to help simplify things a lot
15:26:10 <scooty-puff> or at least make sure i have a good idea of what i'm doing, but makes me wonder if i'm trying to write maybe in an OO manner with a functional language
15:26:12 <Cale> neilk_: All of those are fairly decent examples
15:27:03 <neilk_> Cale: I didn't say they were bad, I said it was not tailored to what that person wanted to know.
15:27:10 <Cale> Maybe they could have been labelled a little differently (with the names of the programs being linked to rather than the names of the universities where they were written)
15:27:28 <Cale> But I think they're all good packages of code to learn from.
15:27:58 <ben> I suppose I'd have prefered links to actual code
15:28:02 <ben> maybe even with commentary on the style??
15:28:09 <ben> rather than to packages, authors, grad schools
15:28:38 <luite> ooh my goal is now to one day make it to dons' list of "certain people" ;)
15:28:39 <benmachine> commentary would have been nice yes
15:28:41 * hackagebot aosd 0.1.1 - Bindings to libaosd, a library for Cairo-based on-screen displays  http://hackage.haskell.org/package/aosd-0.1.1 (DanielSchuessler)
15:30:44 <slack1256> i want to take the most of lazy evaluation on haskell
15:30:58 <slack1256> there is any tutorial specific on taking advantage of that?
15:31:20 <slack1256> pretty difficult to not force evaluation if you come from an imperative world
15:32:01 <slack1256> i am always using seq or Parallel.Strategies, i want to avoid that and embrace laziness
15:32:10 <benmachine> slack1256: I don't think laziness is the most important thing about haskell
15:32:13 <Cale> slack1256: Well... hmm. Start by just using lists a little more.
15:32:18 <drdo> slack1256: you only force strict evaluation as an optimization, that's not something you should worry at first
15:32:22 <Cale> (in a lazy way)
15:32:27 <drdo> *worry about
15:32:34 <ddarius> luite: You'd probably have to make a time machine.
15:33:18 <slack1256> benmachine: but it's here, so better take advantage of it :-)
15:33:33 <luite> ddarius: one day, newbies will ask for great examples of haskell 2020 code :p
15:33:33 <Cale> Laziness is kinda important
15:33:56 <benmachine> Cale: sure, but I think types and abstraction are sort of more important
15:34:02 <Cale> Actually, one paper which is really good if you want to understand how lazy evaluation can be helpful is "Why Functional Programming Matters"
15:34:06 <slack1256> Cale: i'm always using lists, only one time i have used Data.Sequence, but List are good for all
15:34:09 <ddarius> luite: Yes, but dons probably won't consider you one of his "certain people" even if you do produce some.
15:34:12 <geheimdienst> luite: "main = do what i mean ; EOF"
15:34:26 <Cale> slack1256: Lists take the place of imperative loops.
15:34:26 <Twey> Most of the abstractions are only possible thanks to laziness, though.
15:34:41 <ddarius> luite: Many of the people listed were in the Haskell community before Haskell existed.
15:34:48 <benmachine> Twey: this is possibly true, or they're at least far more convenient with laziness
15:34:55 <slack1256> Cale: by peyton johns right?
15:35:05 <Twey> E.G. monads would not be nearly as useful if strict.
15:35:13 <Cale> slack1256: by Hughes
15:35:18 <Cale> http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf
15:35:23 <Twey> And the whole IO thing would not work at all.
15:36:12 <slack1256> Cale: thanks, i will start reading it right now
15:36:21 <Cale> It's not in Haskell, but an earlier language called Miranda which Haskell was the opensource clone of. :)
15:36:56 <ddarius> Cale: I wouldn't describe it as that, though that was sort of the original idea after David Turner said no.
15:36:59 <luite> ddarius: aw don't destroy my dreams:(
15:37:08 <ddarius> luite: Make a time machine.
15:37:10 <slack1256> Cale: yeah, miranda is also lazy, one of the reasons why haskell it is also, plus if you are lazy you must make your functions pure
15:37:46 <ddarius> luite: Alternatively, you could change your name to Simon Marlow, say.
15:38:38 <drdo> slack1256: why?
15:38:45 <geheimdienst> man, he put a concise, clear example of actual code right there in the package description. he should get a medal for that http://hackage.haskell.org/package/aosd-0.1
15:38:45 <drdo> (the second part)
15:39:19 <quaestor> I have quite a large number, which I read from a file, and from that number, I compute a set of parameters, some of which are relatively big as well (large lists). I want to store those parameters in a record for later use. How do I fill that record without getting stack overflows?
15:39:23 <Cale> I just realised that the version I linked to has different typesetting than the version I read myself. I'm not sure of the differences otherwise, but http://www.cse.chalmers.se/~rjmh/Papers/whyfp.pdf is the version directly linked on Hughes' site.
15:40:20 <ddarius> Twey: Nothing about the IO monad or monads requires laziness.
15:40:54 <ddarius> Twey: About the only notable difference would be you wouldn't want (>>).
15:41:10 <Cale> quaestor: Is it possible to have a look at your code? Probably you're doing something which is conceptually a foldl, but needs to be a foldl'
15:42:01 <Cale> quaestor: Stack overflows happen in Haskell when a very large (deeply nested) expression composed of strict functions is evaluated.
15:42:08 <quaestor> Cale: well, I think the problem is that I have one huge "let ... in" construct, because most values depend on earlier ones
15:42:21 <quaestor> but I don't know how to solve it in another way
15:42:31 <Cale> for example, consider  foldl (+) 0 [1,2,3]
15:42:35 <Cale> @src foldl
15:42:35 <lambdabot> foldl f z []     = z
15:42:35 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:42:42 <Cale> Here's how it reduces:
15:42:46 <Cale> foldl (+) 0 [1,2,3]
15:42:53 <Cale> -> foldl (+) (0 + 1) [2,3]
15:42:59 <Cale> -> foldl (+) ((0 + 1) + 2) [3]
15:43:06 <Cale> -> foldl (+) (((0 + 1) + 2) + 3) []
15:43:11 <Cale> -> ((0 + 1) + 2) + 3
15:43:41 <Cale> Up to here, we've had no need of the stack, since the outermost function (foldl) was able to pattern match and reduce each time.
15:43:54 <Cale> But the parameter being accumulated got "large"
15:44:06 <Cale> (if the list were millions of elements, it would be, anyway)
15:44:22 <quaestor> yes, I can see that
15:44:40 <Cale> and now, when we start evaluating that expression outermost-first, we find we need to put things on a stack to find a reducible subexpression of it
15:45:01 <Cale> (...) + 3 can't evaluate without knowing its first parameter
15:45:06 <Cale> and then (...) + 2 can't either
15:45:12 <Cale> but finally 0 + 1 can
15:45:28 <Cale> oh, hpaste.org :)
15:45:34 <Cale> http://hpaste.org/new
15:46:19 <quaestor> http://hpaste.org/48000
15:46:52 <Cale> So, there's nothing in there which immediately jumps out at me as stack overflow causing
15:47:22 <Cale> But of course, there are a lot of defined functions there which might be recursive and generate large expressions somehow.
15:47:23 <scree> quaestor: I think it must be ipr = let pr' = reverse (tail pr) in (head pr) : pr'\
15:47:34 <sanjoyd> From where can I get the source to the Haskell libraries?
15:47:45 <drdo> hackage
15:47:54 <scree> quaestor: but as Cale says, it's hard to say without seeing the function bodies
15:48:18 <ddarius> sanjoyd: There isn't one "set" of libraries.  Everything on Hackage that has Haddock documentation will also have links to the source.
15:48:32 <sanjoyd> ddarius: thanks.
15:48:47 <sanjoyd> I guess I'll start by looking at cabal's command lines.
15:48:49 <quaestor> scree: I tried substituting those lists at the end by constant [1]
15:48:53 <quaestor> scree: still no success
15:49:01 <scree> quaestor: ah, fair enough
15:49:15 <scree> quaestor: have you tried binsearching on the offending line?
15:49:28 <Cale> quaestor: Any of this obviously recursive? Are you using iterate and !! anywhere?
15:51:56 <scree> quaestor: btw, your earlier comment seems to suggest you think the problem is related to the fact that you have 25 or so sequential definitions, or try to fill a large record.  This is not the problem
15:52:20 <quaestor> Cale: scree: the problematic line is already " mm = nextPowerOf2 logn :: Int"
15:52:47 <Cale> Okay, let's look at your definition of nextPowerOf2
15:52:53 <quaestor> I guess this means that the imLog function causes the problems
15:52:57 <Cale> also imLog
15:53:10 <Cale> How big is nN?
15:53:12 <quaestor> imLog is from the haskell report :)
15:53:20 <Cale> What?
15:53:21 <quaestor> nN is about half a million
15:53:36 <ddarius> quaestor: So is foldl.
15:53:41 <quaestor> ddarius: ;)
15:54:09 <Cale> Are you sure?
15:54:12 <roconnor> @seen copumpkin
15:54:12 <lambdabot> Unknown command, try @list
15:54:12 <preflex>  copumpkin was last seen on #haskell-blah 2 hours, 32 minutes and 11 seconds ago, saying: np
15:54:20 <copumpkin> yo roconnor
15:54:33 <roconnor> hey, I'm about done with the ICFP contest now
15:54:33 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
15:54:38 <Cale> What Haskell Report is it in?
15:54:39 <ddarius> copumpkin should have said, "yo ro'"
15:54:42 <sanjoyd> What does this mean: class (Monad m) => MonadState s m | m -> s where ?
15:54:45 <copumpkin> yo ro
15:54:46 <sanjoyd> Specifically, the pipe?
15:54:53 <roconnor> you want a copy of my work in progress bitcoin client?
15:55:06 <copumpkin> roconnor: sure :) did you see what happened to mtgox today btw?
15:55:08 <quaestor> Cale: http://hpaste.org/diff/48000/48001
15:55:18 <Cale> sanjoyd: the part after the pipe is a functional dependency, it says that for any m there is at most one s for which there is an instance MonadState s m
15:55:19 <roconnor> ya, viric let me know.
15:55:25 <roconnor> I know i shouldn't find it funny, but ...
15:55:36 <Cale> sanjoyd: (and hence that once m is known, s can be inferred by looking up the instance)
15:55:43 <ddarius> copumpkin: Unfortunately the future of my previous statement is not the past of my previous statement.  I mean, if you want to believe in such antiquated notions as past and future.
15:56:12 <sanjoyd> Cale: how is it looked up?
15:56:23 <sanjoyd> Cale: any links where I can read more about this?
15:56:45 <copumpkin> :)
15:56:51 <Cale> http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/type-class-extensions.html#functional-dependencies
15:56:57 <sanjoyd> Cale: thanks.
15:57:03 <roconnor> copumpkin: how do I send it to you?
15:57:12 <Cale> quaestor: weird. Maybe from one of the old ones.
15:57:15 <copumpkin> roconnor: up to you :P email?
15:57:40 <quaestor> Cale: yes, I found that on a mailing list
15:58:32 <Cale> quaestor: Probably the problem is that if x is very large indeed, then the log can actually be large enough that this doDiv thing will accumulate gigantic expressions
15:58:41 <Cale> In particular, it doesn't evaluate l
15:58:42 <roconnor> copumpkin: do you have bitcoin installed?
15:59:10 <Cale> So it'll build up an expression like (...(((l+1)+1)+1)...)+1
15:59:27 <Cale> Try adding {-# LANGUAGE BangPatterns #-} to the top of your file
15:59:28 <quaestor> sounds reasonable
15:59:48 <Cale> and replacing  doDiv x l = ...  with  doDiv x !l = ...
15:59:49 <copumpkin> roconnor: yeah
15:59:53 <Cale> dinner
16:02:51 <roconnor> copumpkin: sent
16:03:05 <roconnor> copumpkin: there is no manual, so you will have to ask me how to drive the thing.
16:03:29 <quaestor> Cale: enjoy your meal :)
16:06:02 <EvilMachine> heyo. how can i do what is obviously intended here: let printf' f = (++" <<<") . (">>> "++) . printf f in (printf' "%02.0f" 22.7) ++' ': (printf' "%02.0f:%02.0f" 6.0 33.0)
16:06:53 <benmachine> EvilMachine: sounds tricky; I'd say don't use printf
16:06:54 <geheimdienst> > let printf' f = (++" <<<") . (">>> "++) . printf f in (printf' "%02.0f" 22.7)
16:06:55 <lambdabot>   ">>> 23 <<<"
16:07:01 <EvilMachine> is this because of the monomorphism restriction?
16:07:09 <benmachine> oh, I guess it's not that tricky
16:07:10 <benmachine> ignore me :P
16:07:13 <EvilMachine> geheimdienst: i know.
16:07:24 <EvilMachine> geheimdienst: i want to keep the flexible argument list.
16:07:28 <EvilMachine> benmachine: i know. ;)
16:07:35 <ddarius> EvilMachine: Why don't you just use one printf call?
16:07:37 <geheimdienst> oh, i see
16:07:43 <geheimdienst> you can leave off the "f"
16:07:53 <geheimdienst> > let printf' = (++" <<<") . (">>> "++) . printf in (printf' "%02.0f" 22.7)
16:07:54 <lambdabot>   Couldn't match expected type `t1 -> t'
16:07:54 <lambdabot>         against inferred type `[GHC....
16:07:59 <geheimdienst> ... or maybe you can't
16:08:07 <copumpkin> roconnor: wow, impressive
16:08:19 <copumpkin> looks like the output of tail -f debug.log on my current client
16:08:23 <ddarius> geheimdienst: Indeed.  You can't make your own wrappers around printf that behave like printf (without essentially reimplementing it.)
16:08:34 <EvilMachine> geheimdienst: the reason i didn't leave it off, was because in the actual code, i do something with the f. forgot to remove it. :)
16:08:59 <EvilMachine> ddarius: ohoh
16:09:25 <geheimdienst> ddarius: i wonder why the above code worked, though
16:09:50 <EvilMachine> ddarius: what do you mean with one printf call? i just wrote the above code, to show that the first one works, but the second not. only when both are there is the problem triggered. :
16:09:54 <EvilMachine> :)
16:10:00 <copumpkin> roconnor: so what's missing?
16:10:07 <ddarius> geheimdienst: Because it simply specialized to the particular case.
16:10:10 <EvilMachine> geheimdienst: because it becomes PrintfArg
16:10:29 <EvilMachine> let printf' f = (++" <<<") . (">>> "++) . printf f in (printf' "%02.0f" 22.7) ++' ': (printf' "%02.0f:%02.0f" 6.0 33.0)
16:10:30 <ddarius> EvilMachine: printf ">>> %02.0f <<<"
16:10:34 <EvilMachine> oops
16:10:36 <ddarius> That's the whole point of printf.
16:10:44 <EvilMachine> geheimdienst: printf' :: PrintfArg a => String -> a -> [Char]
16:10:55 <roconnor> copumpkin: handleing of other hash types
16:11:10 <geheimdienst> > let printf' f = (++" <<<") . (">>> "++) . printf f in (printf' "%02.0f" 22.7) ++' ': (printf' "%02.0f:%02.0f" 6.0 33.0)
16:11:11 <lambdabot>   Couldn't match expected type `t -> [GHC.Types.Char]'
16:11:11 <lambdabot>         against inferr...
16:11:18 <roconnor> copumpkin: oh and there is a moderately serious bug that the output scripts need to remain unparsed until use.
16:11:28 <roconnor> copumpkin: probably other small problems
16:12:02 <xplat> > let dist = abs .: (-) in concat $ (zipWith (fmap . dist) <*> tail . tails) [1,5,7,18]
16:12:03 <lambdabot>   [4,6,17,2,13,11]
16:12:06 <roconnor> copumpkin: and more opcodes need to be implemented; though it isn't really as pressing.
16:12:26 <EvilMachine> ddarius: lol. because the actual code doesn't use those ">>> " things, but a function that does some special work on the string. :)-
16:12:34 <roconnor> copumpkin: when I move everything into modules, I was going to try to go over the whole thing carefully
16:13:04 <EvilMachine> ddarius: i'm interested in your reimplementing point.
16:13:38 <EvilMachine> ddarius: i only have two cases. one with one parameter and one with two (hours and minutes). maybe it makes sense to just make two functions.
16:13:53 <EvilMachine> ddarius: like printf1' and printf2'
16:14:00 <ddarius> EvilMachine: printf is not a single function, and if you want to have the same "varargs" ability, you also need to implement your superPrintf as not a single function.
16:14:11 <ddarius> EvilMachine: That would work.
16:14:45 <EvilMachine> ddarius: yeah, because i am not interested in re-implementing a whole library for a small functionality. :)
16:15:16 <copumpkin> roconnor: I see, cool. Are you using any revision control right now?
16:15:31 <ddarius> Revision control is for the weak.
16:15:36 <roconnor> ... not yet ... I know I know.
16:15:53 <roconnor> I was seriously going to use it, once I move stuff into modules :P
16:16:06 <roconnor> it was so small in the beginning ....
16:16:40 <roconnor> then it grew to 1,000 lines of code!!
16:18:00 <EvilMachine> ddarius: assembler is for the weak. real programmers use C-x M-c M-butterfly! :P
16:18:26 <ddarius> Real programmers don't use emacs.
16:18:46 <EvilMachine> ddarius: i guess you haven't read http://xkcd.com/378/
16:18:51 <ddarius> EvilMachine: I have.
16:19:09 <ddarius> Though, real programmers don't read xkcd.
16:20:24 <geheimdienst> cause they are too busy pulling their hair out over what change broke everything, given that they don't use version control?
16:20:29 <EvilMachine> ddarius: you know that's wrong. (they do just feel the raw electric ethernet signals on their tongue though. :P)
16:20:29 <geheimdienst> ;)
16:20:53 <confound> ethernet tastes delicious
16:21:01 <Cale> quaestor: Any luck? Did that solve the problem or is there more?
16:21:36 <quaestor> Cale: I replaced the imLog function by a simple log2 function
16:21:39 <EvilMachine> confound: a bit sour though. could use more savoriness (is that a word?)
16:21:49 <copumpkin> roconnor: it's a pretty impressive effort :) now just use accelerate and start GPU mining ;)
16:21:56 <quaestor> this shifted the overflow a few lines further
16:22:11 <quaestor> it is now at "log2 1 = 0
16:22:11 <quaestor> log2 n = 1 + log2 (n `div` 2)
16:22:20 <quaestor> log2 1 = 0
16:22:20 <quaestor> log2 n = 1 + log2 (n `div` 2)
16:22:22 <quaestor> argh
16:22:25 <roconnor> copumpkin: ^_^
16:22:25 <quaestor> sorry
16:22:37 <roconnor> copumpkin: I've been working on it for a few weeks
16:22:48 <confound> savor fair
16:22:49 <quaestor> Cale: logm = 1 + log2 (mM * mm * 2^(2*u))
16:23:09 * EvilMachine thinks: ethernet tastes almost, but not quite, entirely unlike sourdough bread. :P
16:23:11 <copumpkin> #haskell-bitcoin :)
16:23:14 <quaestor> I also already tried using the bangpattern on log2
16:23:17 <copumpkin> roconnor: what's your goal with it, anyway?
16:23:38 <roconnor> to understand now bitcoin works
16:23:48 <luite> will you sell the program for bitcoin?
16:23:52 <EvilMachine> roconnor: it doesn't work. ;)
16:23:53 <roconnor> but now my goal is to make a semi-formal specfication
16:24:25 <EvilMachine> roconnor: seriously, bitcoin physically can not work.
16:24:31 * copumpkin sighs
16:24:54 <luite> where can I find the current exchange rate for bitcoin? apparently it's not on yahoo
16:25:05 <copumpkin> bitcoinwatch.com
16:25:06 <roconnor> EvilMachine: good thing it isn't physical
16:25:13 <copumpkin> luite: but it's not really up to date
16:25:19 <copumpkin> the exchanges have mostly halted
16:25:19 <roconnor> btw, I have no bitcoins
16:25:25 <roconnor> so I don't really have a stake in any of this
16:25:35 <EvilMachine> roconnor: exactly. it isn't. so it's also not a actual worth.
16:25:47 <copumpkin> EvilMachine: that's kind of naive
16:26:08 <roconnor> EvilMachine: I'm in #haskell-blah if you want to talk about it.
16:26:13 <Cale> quaestor: Okay, so we could fix this in a couple ways. It's funny that the numbers you're working with are actually large enough that computing logarithms can stack overflow :)
16:26:19 <EvilMachine> roconnor: agreed
16:26:39 <zygoloid> luite: https://support.mtgox.com/entries/20208066-huge-bitcoin-sell-off-due-to-a-compromised-account-rollback
16:27:03 <Cale> quaestor: We could do the traditional thing and use an accumulating parameter (being careful to force its evaluation as we go)
16:27:59 <Cale> quaestor: log2' 1 m = m; log2' n m = m `seq` log2' (n `div` 2) (m+1)
16:28:16 <Cale> quaestor: and then  log2' n = log2' n 0
16:28:30 <Cale> Actually, kinda chose the wrong parameter order there :P
16:28:54 <luite> copumpkin: this seems strange, they say that market cap is 65967000 USD, or 73355304 EUR? do they track orders in currencies separately?
16:28:54 <Cale> log2' m 1 = m; log2' m n = m `seq` log2' (n `div` 2) (m+1);  log2 = log2' 0
16:29:29 <zygoloid> you need to reverse the parameters in the recursive call too
16:29:55 <Cale> quaestor: Another way would be to construct a list, and then use either foldl' or some carefully tuned function like length to crunch it down.
16:30:13 <zygoloid> log2' m n = (log2' $! m+1) (n `div` 2)
16:30:35 <Cale> sure, can do that too :)
16:30:46 <Cale> or use a bang pattern again
16:30:59 <zygoloid> but definitely reverse the arguments :)
16:31:22 <quaestor> okay, let me try that
16:32:09 <Cale> oh, right
16:32:11 <Cale> oops :)
16:33:33 <joe6> i have a .c file and i am trying to get this line from "static const char * const wordlist[] = { "", "8", "", "824", "4", "1", "6", "65", "1428", "", "a", "5", "56", "", "", "9", "2", "", "241" };" list into haskell so that I can process it with Haskell.
16:34:07 <joe6> i can get the .c file processed with: parseMyFile "../../staging/test.c" >>= printMyAST
16:34:08 <luite> joe6: it's a Ptr CString
16:34:14 <luite> oh
16:34:36 <joe6> i cannot find any tutorial-like stuff for language.c
16:35:21 <bignose> Boney: interested in Haskell because suddenly the Debian maintainers of Haskell packages have got a whole lot more active; a bunch of useful packages have flooded into Wheezy.
16:36:10 <bignose> Boney: so, since learning Lisp requires too much investment, I'm interested in Learning Me A Haskell to get functional programming in my brain.
16:36:11 <Cale> subtract 1 . genericLength . takeWhile (/= 0) . iterate (`quot` 2)
16:36:19 <Cale> ^^ this should also work well
16:36:37 <Boney> bignose: Nice.
16:37:00 <joe6> this is the code: http://pastebin.com/rqME3GFD
16:37:11 <Boney> Well enjoy haskell, The type system is awesome, but I could do without the lazyness (makes debugging/profiling hard)
16:37:19 <bignose> heh
16:37:47 <monochrom> there are sml and ocaml with awesome type systems too, and eager
16:37:50 <joe6>  http://sprunge.us/ATUE
16:38:11 <bignose> Boney: I'm saddened by the prevalence of ugly camelCaseNames everywhere
16:38:15 <Boney> monochrom: yep.
16:38:24 <monochrom> I use oleg'case :)
16:38:27 <Boney> bignose: ogh, yeah, ai gree.
16:38:34 <Boney> I agree.
16:38:41 <bignose> so I was wondering if people expect that, or if nicer TitleCaseNames and lower_case_with_underscores would be breaking conventions.
16:38:53 <ben> I like camel case :( I can't stand TitleCase for values :(
16:39:07 <bignose> ben: I like the naming conventions in Python
16:39:11 <monochrom> why I refuse camel case: http://uncyclopedia.wikia.com/wiki/ZomboCom
16:39:15 <bignose> TitleCase for classes. I don't know if that applies in Haskell.
16:39:20 <Cale> quaestor: you might also try that one if you like :)
16:39:22 <quaestor> Cale: actually, I don't really understand what's going on here. With the accumulating parameter it doesn't produce a stack overflow, yet it runs forever...
16:39:23 <joe6> luite, how can i drill down from CTranslUnit  to the const definition
16:39:26 <ben> bignose: close enough, and yeah
16:39:41 <joe6> i can just use parsec, but, I think it is better in the long run to be able to parse the c file with language-c
16:39:46 <luite> joe6: yeah sorry I thought that you were just including a .c file with the ffi
16:39:48 <monochrom> haskell type class names are forced to be capitalized anyway, so people do MyTypeClass
16:39:49 <Cale> quaestor: Are you passing in a negative value by accident? Did you take the broken version that I accidentally edited badly?
16:39:55 <bignose> ben: and lowercasenames, or lower_case_with_underscores, for names bound to instances.
16:40:01 <quaestor> Cale: no, I tested it in ghci
16:40:05 <monochrom> also type name such as MyDataType
16:40:09 <joe6> anyone used language.c before?
16:40:41 <Cale> quaestor: I had the arguments to log2' in the wrong order in the recursive call because I forgot to switch them
16:41:04 <Cale> quaestor: try this one: log2 = subtract 1 . genericLength . takeWhile (/= 0) . iterate (`quot` 2)
16:41:08 <bignose> monochrom: well, that's complaining about TitleCase, not camelCase
16:41:22 <Cale> (genericLength is in Data.List)
16:41:30 <bignose> TitleCaseNames are at least consistent, so I have no complaint.
16:41:51 <bignose> my hatred of camelCaseNames is that they wobble up and down *inconsistently*.
16:41:53 <ion> newtype Floating a => Base { fromBase :: a }
16:42:03 <ion> logBase :: Floating a => Base a -> a -> a
16:42:04 <ion> ;-)
16:42:11 <bignose> a big difference in readability.
16:42:33 <bignose> Boney: my first interaction with Haskell was earlier this morning
16:42:44 <Cale> Note: the (`quot` 2) there is because otherwise the thing hangs on (-1), because (-1) `div` 2 = (-1)
16:42:48 <Cale> > (-1) `div` 2
16:42:48 <lambdabot>   -1
16:42:52 <Cale> > (-1) `quot` 2
16:42:52 <lambdabot>   0
16:42:56 <bignose> Boney: and quickly led to a bug report that ‘ghci’ segfaults immediately on PowerPC :-(
16:43:05 <identity_> let's say I want to call hPutStrLn on two different handles with the same text.. wasn't there some nifty way to do this?
16:43:07 <Boney> ah,
16:43:07 * roconnor finds unsafePerformIO is used way too often
16:43:09 <bignose> thus ends my first attempt at using Haskell
16:43:20 <quaestor> Cale: that looks nice :) i'll try it in a sec
16:44:14 <mike-burns> identity_: flip $ hPutStrLn "the text"
16:44:27 <mike-burns> Hm, that's not right.
16:45:29 <ion> mapM_
16:45:33 <identity_> meh, tis all good
16:45:36 <identity_> I could do that yeah
16:47:38 <ion> ((>>) `on` flip hPutStrLn "foo") stdout blah ;-)
16:49:38 <gwern> > 39 - 18
16:49:38 <lambdabot>   21
16:49:56 <c_wraith> > x - y
16:49:57 <lambdabot>   x - y
16:50:38 <ion> > ((x-) - (-y)) z
16:50:39 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr
16:50:39 <lambdabot>                           ...
16:50:51 <ion> > ((x-) - (+y)) z
16:50:51 <lambdabot>   x - z + negate (z + y)
16:52:26 <quaestor> Cale: I found the problem. It's rather a facepalm thingy. Some of my parameters should be "Int" so that I can later use them with take and drop and such things, and some have to be "Integer" due to the size. In the offending line, the result of a multiplication was 0... and obviously, log2 0...
16:52:57 <Cale> quaestor: aha
16:53:42 <Cale> quaestor: I *hate* Int for that reason. It should be banished from the Prelude.
16:53:56 <Cale> It's good that we have it available of course.
16:54:02 <Cale> It just shouldn't be the default for anything.
16:54:14 <identity_> Cale: you want integer instead?
16:54:17 <Cale> Yep
16:54:18 <identity_> for everything that uses int, that is
16:54:20 <identity_> ah
16:54:25 <identity_> There is no performance penalty?
16:54:28 <cmccann> Cale, I've thought for a while that using Int instead of Integer should be regarded as an optimization
16:54:34 <Cale> There is a performance penalty of course.
16:54:39 <cmccann> and not used unless the performance is needed
16:54:45 <cmccann> cf. "premature optimization blah blah"
16:54:47 <Cale> But there's a correctness penalty to using Int
16:55:03 <quaestor> Cale: but thanks anyway, the new logarithm inplementation is certainly a huge performance boost :)
16:55:20 <identity_> Cale: how so?
16:55:35 <Cale> > product [1..1000] :: Int
16:55:36 <ion> If you *really* need an integer of certain size you probably want IntN/WordN anyway.
16:55:36 <lambdabot>   0
16:55:38 <Cale> ^^
16:55:44 <identity_> huh
16:55:46 <identity_> :t product
16:55:46 <lambdabot> forall a. (Num a) => [a] -> a
16:55:50 <cmccann> the Int type aren't actually integers
16:55:52 <Cale> > product [1..1000] :: Integer
16:55:53 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
16:55:55 <cmccann> they're integers modulo something or other
16:56:37 <Cale> Yeah, they're integers modulo 2^n for some n which is up to the implementation, but must be at least 30
16:57:44 <Cale> Well, Int and Word *do* have a place in some programs which have to run fast on multiple architectures and where one knows that the numbers will never be very large.
16:57:45 <cmccann> of course, a lot of prelude functions that take Int arguments actually want natural numbers which is another issue
16:57:54 <quaestor> ion: I haven't heard about IntN/WordN, is this available in standard haskell?
16:57:55 <Cale> Sure
16:58:08 <Cale> That's a stickier issue because of the way that Num works of course.
16:58:10 <cmccann> and many of them could also stand to take any Integral instance instead of a specific type
16:58:12 <ion> :t (Data.Int.Int32, Data.Word.Word64) -- quaestor
16:58:12 <lambdabot> Not in scope: data constructor `Data.Int.Int32'
16:58:12 <lambdabot>     Not in scope: data constructor `Data.Word.Word64'
16:58:16 <ion> meh
16:58:29 <Eduard_Munteanu> Or where scaling with the word size is reasonable and expected.
16:58:36 <ion> :i (Data.Int.Int32, Data.Word.Word64)
16:58:43 <quaestor> ah, okay, I thought you really meant N as in _arbitrary_ N
16:58:59 <ion> @info Data.Int.Int32
16:58:59 <lambdabot> Data.Int.Int32
16:59:17 <Cale> lambdabot isn't actually ghci :)
16:59:27 <Eduard_Munteanu> (e.g. it makes sense in the case of file descriptors as in C)
16:59:59 <ion> Yeah, and :t was wrong in the first place, and :i (tuple) would have been wrong as well. I blame inadequate blood coffeine content.
17:00:07 <zztr> i tried adding the haskell wiki search in firefox and got this error
17:00:09 <zztr> Firefox could not download the search plugin from:
17:00:09 <zztr> http://haskell.org/haskellwiki/opensearch_desc.php
17:00:52 <zztr> anyone with access to the haskell.org site here?
17:01:20 <byorgey> zztr: works fine for me
17:01:46 <zztr> byorgey: in firefox?
17:02:32 <byorgey> zztr: yes
17:03:02 <zztr> when i go to that page it says "there is currently no text in this page..."
17:05:23 <Eduard_Munteanu> "There is currently no text in this page, you can search for this page title in other pages or edit this page."
17:05:47 <Eduard_Munteanu> Now I'm not sure what byorgey meant by "works fine".
17:05:55 <Eduard_Munteanu> The page certainly loads :)
17:06:11 <Eduard_Munteanu> I'd say it works fine too.
17:06:18 <byorgey> by "works fine" I mean when I go to haskell.org I get the normal Haskell site.
17:06:19 <zztr> heh, yes it does. it thinks it's a wiki page that doesn't exist
17:06:39 <djahandarie> haskell.org works fine for me too
17:06:48 <benmachine> I get what I expect too
17:06:57 <zztr> oh i get the normal haskell site too. but I can't add the wiki search to my list in firefox
17:07:02 <djahandarie> Though I'm on the exact same connection as byorgey so I think I may just be skewing the data :)
17:07:05 <djahandarie> Ah
17:07:22 <Eduard_Munteanu> I think you have to add it as a smart bookmark
17:07:37 <Eduard_Munteanu> Or are you getting an addon made by someone else?
17:08:00 <byorgey> djahandarie: actually I am in Seattle
17:08:16 <zztr> i can do it myself but the thing is, this is in the head tag of the wiki site:
17:08:18 <zztr> <link rel="search" type="application/opensearchdescription+xml" href="/haskellwiki/opensearch_desc.php" title="HaskellWiki (English)" />
17:09:28 <zztr> this metadata tells firefox to give a prompt at the bottom of the search dropdown that says, Add "HaskellWiki (English)"
17:09:39 <zztr> choosing that option leads to the error message i posted above
17:10:29 <djahandarie> byorgey, you move quickly
17:10:33 <zztr> so someone with access to the wiki should either remove that broken link tag from the head, or fix the search plugin
17:11:04 <djahandarie> edwardk, why is ##categorytheory not on autojoin for you btw? :p
17:20:47 * ddarius doesn't have ##categorytheory on autojoin.
17:22:36 <Eduard_Munteanu> ddarius most certainly should :)
17:22:49 <djahandarie> ddarius, well, I guess you're just able to remember to join unlike edwardk
17:23:24 <cmccann> obviously because edwardk spends a lot of time working with comonads, where join doesn't work
17:23:33 <Eduard_Munteanu> Heh.
17:23:48 <djahandarie> Thankfully he's using a coirc client.
17:24:11 <Eduard_Munteanu> I guess he can join in the opposite category then :P
17:24:54 <nus> hmm, what would be dual to ##cateogorytheory ?-)
17:25:42 <Eduard_Munteanu> ##categorytheory, as per Awodey
17:26:02 * Eduard_Munteanu remembers he says CT = CT^* :)
17:27:20 <Eduard_Munteanu> (as in if you take the dual of all category axioms)
17:37:08 <jimmy_the_ask> hey
17:37:21 <jimmy_the_ask> could You please teach me how to calculate types?
17:37:26 <jimmy_the_ask> for example (.)(.)
17:37:30 <jimmy_the_ask> :t (.)(.)
17:37:31 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
17:38:37 <jimmy_the_ask> i understand how to calculate :t (.)
17:38:48 <jimmy_the_ask> but have no idea how to do it with (.)(.)
17:38:50 <jimmy_the_ask> and so on
17:39:50 <hpaste> Evi1M4chine pasted “Huge data URL” at http://hpaste.org/48002
17:43:42 <ion> :t (Prelude..)
17:43:43 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
17:44:26 <Alan1> Evi1M4chine: try -> http://is.gd/uXjCFQ
17:45:21 <Alan1> Evi1M4chine: if that was a valid URL
17:45:32 <ion> Let’s say f = (.); g = (.) to make it clear which one i’m talking about.
17:45:38 <ion> f :: (b -> c) -> (a -> b) -> a -> c
17:45:56 <ion> g :: (i -> j) -> (h -> i) -> h -> j
17:46:13 <ion> Now, in f g, g is the parameter to f of type (b -> c).
17:48:22 <jimmy_the_ask> err, i don't get YOur last line
17:48:23 <ion> Let me make some implicit parentheses explicit. g :: (i -> j) -> ((h -> i) -> h -> j)
17:48:49 <ion> Perhaps a simpler example would be helpful here.
17:49:00 <EvilMachine> Alan1: opps, i wanted that to go to #haskell-blah
17:49:05 <ion> :t (+)
17:49:05 <lambdabot> forall a. (Num a) => a -> a -> a
17:49:07 <EvilMachine> -p
17:49:47 <ion> The a is a type variable that is filled in based on what you apply (+) to.
17:50:05 <jimmy_the_ask> ok, i know the type of (+) it gets two parametrs of the same type and returns the same type as a result
17:50:27 <ion> (or other kinds of type inference)
17:50:53 <ion> In f, (b -> c) is a parameter that is a function from any b to any c.
17:51:08 <ion> g is a function from (i -> j) to ((h -> i) -> h -> j)
17:52:21 <jimmy_the_ask> ok
17:53:04 <ion> A moment
18:00:54 <hpaste> ion pasted “(.) (.)” at http://hpaste.org/48003
18:01:05 <ion> jimmy_the_ask: ↑
18:01:25 <jimmy_the_ask> thanks, i'll read
18:01:47 <ion> The first parameter of f, (b -> c), gets filled in by the entire type of g.
18:02:04 <ion> Therefore b gets to mean (i -> j) and c gets to mean ((h -> i) -> (h -> j))
18:02:23 <identity_> I'm writing some code that is pretty much a state machine. It receives input over the network, and depending on the input, I may need to disconnect a client early or continue if it's valid, but I'm trying to avoid becoming a series of staircasing when (...) $ do (next line indented even further)
18:02:29 <identity_> Any hints?
18:02:40 <ion> The type of f g is (a -> b) -> a -> c with the above type variable substitutions.
18:03:20 <ion> identity: The Error monad perhaps.
18:03:24 <jimmy_the_ask> err, wait please, why f g :: (a -> b) -> a -> c
18:03:51 <jimmy_the_ask> nvm
18:03:57 <ion> (+) :: a -> a -> a
18:04:00 <ion> (+) x :: a -> a
18:04:06 <ion> x fills the first a
18:04:23 <ion> Similarly, g fills the first (a -> b) here.
18:04:35 <ion> Sorry, the first (b -> c)
18:07:51 <jimmy_the_ask> damn i still don't get it...
18:08:56 <ion> Let’s try (.) show instead of (.) (.)
18:09:02 <ion> (.) :: (b -> c) -> (a -> b) -> a -> c
18:09:20 <ion> show :: (Show showee) => showee -> String
18:10:17 <ion> When you apply (.) to show, the first parameter of type (b -> c) is show. The remaining type is (a -> b) -> a ->c.
18:10:28 <ion> But b gets filled in as Show showee => showee and c gets filled in as String.
18:10:44 <ion> So instead of (.) show :: (a -> b) -> a -> c,
18:11:06 <ion> you have (.) show :: Show showee => (a -> showee) -> a -> String
18:12:01 <ion> It’s exactly the same with (.) (.), but instead of Show showee => showee you have the more complicated type (i -> j) and instead of String you have the even more complicated type ((h -> i) -> (h -> j)).
18:18:51 <jimmy_the_ask> wait, (a -> b) -> a -> c == showee -> String ?
18:19:12 <ion> Let’s put it this way…
18:19:53 <ion> The type of the (.) in (.) show becomes:
18:20:19 <ion> (.) :: Show showee => (showee -> String) -> (a -> showee) -> a -> String
18:20:44 <ion> as Showee => showee -> String fills (b -> c) and the other bs and cs are substituted with the same values.
18:21:17 <ion> Thus, (.) show :: Show showee => (a -> showee) -> a -> String
18:24:51 <jimmy_the_ask> err, could I still can't see it, maybe i'll try to show you how i wanna solve it step-by-step and You will find mistake , ok?
18:25:08 <ion> ok
18:25:38 <jimmy_the_ask> f = (.) :: (b->c) -> (a->b) -> a -> c
18:25:56 <jimmy_the_ask> g = show :: showee -> String
18:26:20 <jimmy_the_ask> wanna find type of:  f g :: (x -> y) -> x -> z
18:26:35 <jimmy_the_ask> x = b -> c
18:26:47 <ion> no
18:26:59 <ion> That was with (.) (.), not with (.) show
18:27:08 <ion> g :: showee -> String
18:27:19 <ion> f’s first parameter :: b -> c
18:27:47 <jimmy_the_ask> do You mean that  f g :: (x -> y) -> x ->  is wrong?z
18:28:01 <ion> x = b -> c is wrong in this case.
18:28:31 <ion> b :: showee, c :: String
18:28:42 <Cale> jimmy_the_ask: It's worth pointing out that (.) in lambdabot has been generalised (so that it's fmap).
18:28:44 <ion> Sorry, better pseudosyntax. b = showee, c = String
18:28:58 <Cale> (In case any of the type signatures it gave you were confusing)
18:29:00 <jimmy_the_ask> but wait, if f g :: (x -> y) -> x -> z  then f :: (x->y)
18:29:21 <ion> (+) :: a -> a -> a: (+) takes two numbers and returns the sum.
18:29:38 <ion> (+) 1 :: a -> a: (+) 1 takes *one* number and returns the sum of it and 1.
18:29:55 <ion> (+) 1 2 :: a: (+) 1 2 is just the sum of 1 and 2.
18:29:57 <Cale> If f g :: t, then all we know is that f :: s -> t, and g :: s for some type s
18:30:15 <ion> (.) :: typeoffirstparam -> typeofsecondparam -> typeofresult
18:30:27 <ion> (.) firstparam :: typeofsecondparam -> typeofresult
18:30:42 <ion> (.) firstparam secondparam :: typeofresult
18:30:49 <Cale> jimmy_the_ask: To put it another way, if f :: a -> b, and x :: a, then f x :: b
18:31:30 <Cale> and whenever we see f x, f must be a function, and x must be the type of its parameter
18:32:13 <Cale> Well, that was awkwardly stated, the type of x must match the parameter type for f
18:32:38 <jimmy_the_ask> err, so maybe first please show me the example of using (.) show
18:33:01 <jimmy_the_ask> it should have two parametrs, right?
18:33:34 <Cale> (.) show is the same as (show .), and is the function which when applied to a function f, gives the composite  show . f
18:33:42 <Cale> yeah?
18:33:42 <ion> The first parameter of (.) has type (b -> c). If we use show as the first parameter, the polymorphic type (b -> c) is substituted with the less polymorphic type of show, Show showee => showee -> String.
18:34:06 <ion> In the type of (.), all the bs get substituted with Show showee => showee and all the cs get substituted with String.
18:34:34 <ion> fully polymorphic (.) :: (b -> c) -> (a -> b) -> a -> c
18:34:57 <ion> version that accepts show or equivalent: (.) :: Show showee => (showee -> String) -> (a -> showee) -> a -> String
18:35:26 <ion> When we apply (.) to show, the type inference restricts the (.) to that type.
18:35:47 <ion> We could write is manually as well:
18:35:59 <ion> :t ((.) :: Show showee => (showee -> String) -> (a -> showee) -> a -> String) show
18:36:00 <lambdabot> forall showee a. (Show showee) => (a -> showee) -> a -> String
18:36:12 <ion> s/manually/explicitly/
18:36:24 <Cale> if you want to see how, we could generate the type equations and perform unification by hand
18:36:42 <jimmy_the_ask> ok, i get that (showee -> String) -> (a -> showee) -> a -> String
18:37:12 <jimmy_the_ask> but how did you get (a -> showee) -> a -> String?
18:37:58 <ion> :t (+)
18:37:59 <lambdabot> forall a. (Num a) => a -> a -> a
18:38:02 <ion> :t (+) 2
18:38:03 <lambdabot> forall t. (Num t) => t -> t
18:38:05 <ion> :t (+) 2 3
18:38:06 <lambdabot> forall t. (Num t) => t
18:38:24 <Cale> jimmy_the_ask: because that first thing is the type of (.) alone in the expression
18:38:36 <Cale> jimmy_the_ask: and we're computing the type of (.) show
18:38:42 <jimmy_the_ask> ouch, i see it now :)
18:40:55 <jimmy_the_ask> damn and i understood (.)(.) aswell :)
18:40:59 <jimmy_the_ask> thanks a lot :)
18:45:42 <jimmy_the_ask> what if i want to calculate :t (.)(.)(.) - the same way? i need to check :t (.)(.) and (.) ?
18:48:14 <jimmy_the_ask> (.)(.) :: (a -> i -> j) -> a -> (h -> i) -> h -> j  and (.) :: (r -> s) -> (( p -> r) -> p -> s)
18:49:31 <jimmy_the_ask> r = a-> i -> j   and s = a -> (h -> i) -> h -> j   right?
18:50:37 <Cale> You should be unifying the other way around
18:50:46 <Cale> since (.) is the parameter to (.)(.)
18:50:57 <Cale> It's really ((.)(.))(.)
18:51:59 <Cale> So the parameter to (.)(.) has type (a -> i -> j), and we need to unify that with (r -> s) -> (p -> r) -> (p -> s)
18:52:03 <jimmy_the_ask> a = r->s       i =p -> r         j = p->s  ?
18:52:08 <Cale> yep
18:52:41 <Cale> and so the result has type  a -> (h -> i) -> h -> j, with that choice of a,i,j
18:53:32 <jimmy_the_ask> (r -> s) -> (h -> p -> r) -> h -> p -> s
18:53:34 <Cale> (r -> s) -> (h -> (p -> r)) -> h -> (p -> s)
18:53:35 <identity_> Why do people keep messing around with stuff like (.)(.) if I may ask.. Is there some point to it?
18:53:37 <Cale> yeah
18:53:47 <Cale> and yes, you can remove the parens like that
18:53:57 <jimmy_the_ask> awesome :)
18:54:00 <jimmy_the_ask> thanks a lot for help
18:54:04 <Cale> identity_: It's a decent example here to make sure he understands how to check types :)
18:54:07 <jimmy_the_ask> it looks i did understand that ;)
18:54:14 <identity_> Cale: Ah. Check types in which way?
18:54:14 * cmccann figured (.)(.) was mostly useful for avoiding points
18:54:52 <jimmy_the_ask> ok, gotta go (i't 4:20 am here), thanks a lot and bye ;)
18:55:23 <identity_> cmccann: I am but a man, so every time someone draws (.)(.) I can't help but think of boobs or a man's eyes who is looking at boobs
18:55:27 <Cale> identity_: Or infer them, I suppose.
18:55:38 <Cale> If you can infer the type of (.)(.)(.) on your own, it's a good sign that you understand how types work.
18:55:49 <identity_> hmm
18:55:54 <identity_> I should probably do that at some point
18:56:16 <parcs> the next step is to infer the type of fmap fix return
18:56:26 <identity_> :t fmap fix return
18:56:26 <lambdabot> forall a. a -> a
18:56:30 <shachaf> Cale: Aha, so *that's* the reasoning behind making lambdabot's (.) more complicated.
18:56:32 <identity_> :(
18:56:35 <ion> @tell jimmy_the_ask http://hpaste.org/48004
18:56:35 <Cale> Or even just  fmap fmap fmap
18:56:35 <lambdabot> Consider it noted.
18:56:47 <identity_> :t fmap fmap fmap
18:56:48 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
18:56:54 <Cale> Which I think might actually be easier than (.) (.) (.)
18:57:10 <Cale> (and you could get the answer for (.) (.) (.) by specialising it :)
18:58:30 <ion> identity: Seen Total Recall? (.)(.)(.)
18:58:59 <identity_> ion: Nope. Your reference eludes me
18:59:25 <ion> I guess i won’t spoil it any further. Go and watch it some time. :-)
18:59:44 <hpaste> fxr pasted “huge memory usage” at http://hpaste.org/48005
19:00:37 <fxr> I wonder if I can optimize the memory usage of this lfsr implementation: http://hpaste.org/48005
19:00:39 <fxr> any ideas?
19:01:40 <Cale> fxr: Well... does Control.Monad.State.Strict help at all?
19:03:08 <Cale> apparently not
19:03:12 <fxr> sure not
19:03:32 <Cale> Let's see what this program is doing :)
19:03:35 <fxr> I wonder if my recursion eats all of my memory or not...
19:03:39 <ion> Btw, using Control.Arrow one can implement nextState as modify (clock *** (+1)). Not a response to your problem, just another way to say the same thing.
19:04:30 <fxr> it just runs an LFSR, until it repeats itself.
19:05:15 <fxr> I'm basically trying to modify a Word32 with some boolean operations.
19:05:29 <Cale> oh, you're only using the IORef version
19:05:40 <fxr> nope, I tried both versions
19:05:51 <fxr> both eats all the memory
19:07:02 <Cale>     effect (lfsr, p) = let c' = clock lfsr
19:07:02 <Cale>                            p' = p+1
19:07:02 <Cale>                         in c' `seq` p' `seq` (c',p')
19:07:05 <Cale> ^^ do that :)
19:07:14 <fxr> oh strictness...
19:07:38 <Cale> actually, I'm pretty sure that's more than required...
19:08:14 <Cale> yeah, c' isn't needed because that's already being evaluated
19:08:27 <fxr> I'm not sure this modification gives me any memory benefit.
19:08:55 <Cale> all the memory was spent on an expression which looked like (...(((0+1)+1)+1)...)+1
19:09:04 <fxr> hmm
19:09:42 <Cale> Because you never look at the p component, but keep transforming it by sticking on another +1
19:09:59 <Cale> so it just builds up to be huge
19:10:44 <ion> Has anyone written a debugging tool for Haskell that automatically detects huge thunks?
19:10:47 <Cale> This seems like an insane way of computing this though.
19:10:55 <ion> and tells where they came from
19:10:59 <Cale> (way more imperative than it needs to be in either case)
19:11:37 <fxr> hmm, any better way to carry a counter?
19:12:11 <Cale> Well, what are we doing here? We're iterating clock on the initial lfsr
19:12:33 <ion> :t iterate
19:12:34 <Cale> and we're looking for the initial lfsr in the results
19:12:34 <lambdabot> forall a. (a -> a) -> a -> [a]
19:12:55 <fxr> cale, btw it runs in constant memory now.
19:13:04 <Cale> length . takeWhile (/= initial) . tail . iterate clock $ initial
19:14:27 <danharaj> whatcha guys talking about?
19:14:59 <Cale> danharaj: Brute force checking the period of an LFSR
19:15:24 <danharaj> what's an LFSR?
19:15:31 <ion> Linear feedback shift register
19:15:35 <Cale> Linear feedback shift reg...
19:15:36 <fxr> Cale, thank you.
19:15:36 <Cale> yes
19:16:06 <guerrilla> hmm, i have ListZipper installed via cabal install --global but ghc can't seem to find Data.List.Zipper.. suggestions?
19:16:18 <djahandarie> Cale, you only had two letters left!
19:16:18 <ion> --global? *shiver*
19:16:23 <Cale> main = print . length . takeWhile (/= initial) . tail . iterate clock $ initial
19:16:25 <guerrilla> ion: bad idea?
19:16:52 <guerrilla> this worked fine on ubuntu, but it doesn't seem so on fedora...
19:16:58 <djahandarie> guerrilla, have you seen http://www.vex.net/~trebla/haskell/sicp.xhtml ?
19:17:23 <ion> You’re trampling all over the filesystem where nothing else than the package manager should touch (in a way that’s not trivial to revert).
19:17:32 <guerrilla> djahandarie: hey. and no i haven't
19:17:41 <djahandarie> Hi. :)
19:17:42 <guerrilla> ion: ok. anyway to un-do what i did with cabal?
19:17:56 <djahandarie> guerrilla, yes, by deleting everything!
19:18:03 <Cale> guerrilla: On ubuntu, I always install things as user as well.
19:18:09 <Cale> Oh, it's not that bad...
19:18:35 <Cale> It's all under the ghc directory in /usr/lib iirc.
19:18:40 <djahandarie> (~/.ghc is all that is really needed I think. I usually do ~/.cabal too so I'm not sure.)
19:18:44 <guerrilla> djahandarie: hardly :P but yeh, i'll mv the /usr/lib dirs out of the way
19:18:47 <Cale> But it's been a long time since I installed anything globally using cabal
19:18:48 <ion> And perhaps /usr/local/bin etc. or something like that.
19:18:56 <guerrilla> ion: yeah cpphs is there
19:18:56 <djahandarie> Oh, not sure where the global stuff goes
19:19:16 <mike-burns> Is there something like printf but which takes a list, perhaps even a list of String, instead of this variable number of arguments thing? Alternatively, how do I pass a list to Text.Printf printf ?
19:19:20 <Cale> But it trashes your ghc installation, which sucks.
19:19:35 <shachaf> @source Text.Printf
19:19:35 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
19:19:44 <Cale> (which is why I install things as user, easier to reset just the stuff I added)
19:20:12 <ion> > concat ["foo", "bar", "baz"]
19:20:13 <lambdabot>   "foobarbaz"
19:20:13 <guerrilla> Cale: i see. i wonder why in the world ghc stuff installed in /usr/local if its part of fedora...
19:20:21 <Cale> mike-burns: heh...
19:20:57 <Cale> mike-burns: you could almost just revert to using concat :)
19:21:02 <Cale> and show
19:21:24 <cmccann> or perhaps unwords
19:21:27 <shachaf> Oh, it doesn't export spr and UPrintf. :-(
19:21:31 <Cale> /usr/local is fair game for things that get installed locally to the system and not as part of the distribution
19:22:09 <mike-burns> I want the %25s functionality of printf ... guess I'll write that myself.
19:22:09 <ion> Even for /usr/local i use stow.
19:22:23 <guerrilla> ok, anyway.. i fixed that.. but it still doesnt find Data.List.Zipper after a user install of ListZipper
19:22:35 <ion> whatsitsname has that functionality. Something with text. :-)
19:23:41 <Saizan> guerrilla: ghci -v ?
19:24:05 <Saizan> (i.e. does it say anything about ListZipper when you start it that way?)
19:24:21 <guerrilla> 1sec
19:24:24 <guerrilla> need to grep out of this mess
19:24:34 <co_dh> greeting guys, I'm a little bit frustrated , because in all job post, they are asking OO and Design Pattern ,  how a functional mind survive in a OO world?
19:24:58 <guerrilla> Saizan: ok that was useful. seems my quickcheck is broken :P
19:25:25 <ddarius> I have a hard time imagining a job posting requiring "design patterns" expertise.
19:25:34 <ddarius> You should learn OO.
19:25:36 <gienah> co_dh: I probably won't be much help since I'm unemployed :-)
19:26:09 <gienah> co_dh: maybe try creating a startup :-)
19:26:15 <mike-burns> FP and OO can co-exist in your brain fairly well.
19:26:18 <parcs> that doesn't make you employed ;)
19:26:19 <mike-burns> It's just knowing things.
19:26:25 <co_dh> I know OO a lot, and hate it :(
19:26:52 <mike-burns> It's just a paradigm. Use it to solve some problems, use something else for others.
19:27:05 <mike-burns> Like how you don't throw monads at everything.
19:27:28 <ddarius> To be clear, my comment to learn OO wasn't that you should to get a job, but that you should do it regardless of that.
19:27:29 <ion> I do!
19:27:32 <ion> > return "Hello world"
19:27:33 <lambdabot>   No instance for (GHC.Show.Show (m [GHC.Types.Char]))
19:27:33 <lambdabot>    arising from a use ...
19:27:34 <co_dh> I tend to think in functional way , not OO , which cause trouble with coworkers. It's like I'm an alien .
19:27:40 <Saizan> the obligatory disclaimer about most design patterns being there to cope with flaws of languages of the time rather than OO in general might help :)
19:28:10 <gienah> like the visitor pattern
19:28:35 <mike-burns> This is all true, but is a separate issue from OO.
19:29:00 <ddarius> co_dh: If you have the expertise, what's the problem?  Look for a job you think you'd like.  This is probably not going to hinge on whether they use OO or not.
19:29:44 <gienah> heh you could write functional programming code in C++ template metaprogramming (I'm not really sure if it helps to stay employed though)
19:29:51 <co_dh> ddarius: The problem is :  the way you think is different, and the code is hard for others to grasp.
19:30:17 <mike-burns> FP and OO go hand-in-hand very well, outside of Java.
19:30:20 <co_dh> most programmer hates C++ template metaprogramming.
19:30:34 <mike-burns> Thinking in pure OO and thinking in FP aren't too far off.
19:30:57 <parcs> co_dh: why do you hate OO?
19:31:13 <co_dh> mike-burns: is there good OO paper in Haskell? I guess when C++ mix with OO ,the result is bad.
19:31:15 <ion> What jobs have you do pure OO?
19:31:16 <mike-burns> The actual issue is that some languages don't optimize tail calls.
19:31:37 <gienah> co_dh: its just like haskell (sort of in a twisted way): http://bartoszmilewski.wordpress.com/2009/10/21/what-does-haskell-have-to-do-with-c/
19:31:48 <ddarius> co_dh: I'll tell you a secret.  Everyone's code is hard for everyone else to grasp.
19:31:59 <mike-burns> ion: None, but which have you do FP!
19:32:01 <shachaf> Often s/else//
19:32:14 <co_dh> parcs: I see many problem can be solved with functional more easily than OO . or I guess I'm simple minded, that only 1 paradigm can exists in my brain :(
19:32:23 <ddarius> gienah: Actually, one of the first Haskell programs I wrote converted a small Haskell-like language to C++ templates.  It was actually trivial to do.
19:32:28 <ion> I’ve been wishing for a GHC extension that lets me say “either do this as a tail call or error out if it’s not possible” when doing a function call.
19:33:01 <ddarius> ion: That doesn't make any sense.
19:33:10 <Cale> ion: What's a tail call? ;)
19:33:21 <Cale> GHC isn't a strict evaluator
19:33:33 <ddarius> Cale: That's not really relevant.
19:33:45 <Cale> So it doesn't use a stack in the same way that strict language implementations often do.
19:33:47 <ddarius> (or alternatively, there's is plenty of strictness in the Haskell language.)
19:33:51 <gienah> ddarius: that's neat
19:34:44 <co_dh> gienah: the problem is : functional C++ programming is not welcomed by the OO world.
19:34:48 <ion> Let me rephrase. “Do TCO for this call. If that fails, bail instead of doing something that adds a stack frame.”
19:34:53 <mike-burns> co_dh: Have you read SICP? There's a chapter in there on OO that's rather functional.
19:34:55 <Cale> ion: What is TCO?
19:35:10 <Cale> ion: In the context of the STG machine
19:35:10 <ddarius> ion: The problem isn't your wording.
19:36:05 <ddarius> ion: Have you programmed in a language like C or Java or C++?
19:36:10 <co_dh> mike-burns: I've read SICP. I guess I'll reread it.
19:36:26 <gienah> co_dh: you could write some open source software projects, my guess is it doesn't matter which programming language, and publish them on github
19:36:52 <Cale> ion: If you get a stack overflow from a GHC program, it means something completely different from if you get a stack overflow in a typical strict evaluator.
19:36:53 <cmccann> a tail call is when the recursive call evaluates to the tail of a list so that the result is lazy, right? :]
19:36:56 <co_dh> gienah: thanks , that's a good advice, I should try.
19:37:07 <ddarius> cmccann: It has nothing to do with lists.
19:37:14 <cmccann> ddarius, it was a joke
19:37:23 <Cale> ion: The stack in GHC is more like a set of case expressions which are waiting for their scrutinees to be sufficiently evaluated to pattern match.
19:37:25 <ion> Wait. Haha. Sorry for the confusion. I meant to say “GCC”, not “GHC”. I only now realized the typo.
19:37:35 <Cale> OH!
19:37:38 <Cale> hahaha
19:37:42 <cmccann> that makes a bit of a difference, yes
19:38:00 <ddarius> ion: The correct thing for GCC to do is to support tail calls everywhere.
19:38:01 <gienah> co_dh: sometimes I see job ads where they ask for a substantial open source software project
19:38:13 <ddarius> s/tail calls/tail call optimization/
19:38:20 <mike-burns> Yeah, we mostly look at open source work.
19:38:26 <mike-burns> But we do OO.
19:38:31 <shachaf> ion: Isn't that what "return" does?
19:38:39 <ion> ddarius: I still want the code not to compile if it’s being fed to anything – GCC or not – that doesn’t support tail calls everywhere.
19:38:49 <Cale> Yeah, it shouldn't even have to think about whether to TCO, GCC should just not push stack frames ever for tail calls.
19:39:19 <pikhq> Isn't that GCC's actual behavior?
19:39:30 <ddarius> shachaf: http://lambda-the-ultimate.org/node/472#comment-3576
19:39:33 <pikhq> I mean, I've certainly *seen* it not push stack frames for tail calls.
19:39:50 <ski> pikhq : it can't always do it
19:40:03 <co_dh> I think GCC is a little off-topic :)
19:40:24 <mike-burns> This printf thing is still frustrating me.
19:40:31 <mike-burns> That's all.
19:40:41 <Cale> ski: Why not?
19:41:24 <ion> co_dh: GCC is quite relevant. There’s FFI which may involve writing some amount of C along with your Haskell code for instance.
19:41:31 <ski> Cale : if you take the address of an automatic variable, C guarantees that'll stay valid until the block exits
19:42:11 <ion> (Of course LLVM is the future. :-P
19:44:20 <mike-burns> Hmmm, can I use ($) to make my list in a format that printf can take ...
19:44:38 * mike-burns really doesn't want to re-write/copy-paste.
19:44:45 * ski wonders what mike-burns is doing
19:44:59 <Cale> ski: ah, I suppose that would be a problem, yeah
19:45:11 <co_dh> mike-burns: yes, what are you trying to do ? implement printf in haskell? that will need dependent type.
19:45:22 <ion> mike-burns: What’s a real example of the input and the output you want?
19:45:27 <Cale> co_dh: It doesn't need dependent types
19:45:34 <mike-burns> Text.Printf exists, but I have a list of strings.
19:45:43 <co_dh> Cale : can you show me?
19:45:43 <cmccann> nah, printf just needs silly type class voodoo
19:45:48 <Cale> Text.Printf
19:45:48 <ski> mike-burns : list of format strings, or what ?
19:46:02 <ski> @type Text.Printf.printf
19:46:02 <lambdabot> forall r. (PrintfType r) => String -> r
19:46:10 <mike-burns> printf "%-25s\t%-25s" ["/tmp", "/etc"]
19:46:13 <mike-burns> That's what I want.
19:46:24 <mike-burns> I can generate that format string easily.
19:46:26 <Cale> mike-burns: You could always just pattern match them
19:46:32 <Cale> and then pass them in as normal parameters
19:46:37 <mike-burns> I don't know the size of the list.
19:46:53 <Cale> Then how should you know what your format string should be?
19:46:56 <ski> mike-burns : are you generating the format string programatically ?
19:47:05 <mike-burns> ski: Yes.
19:47:11 <Cale> I think printf is probably just a bad fit for this.
19:47:24 * ski thinks this probably can be done
19:47:26 <Cale> Or at least, at that point in the code...
19:47:28 <ddarius> It doesn't really add too much value in this case.
19:47:37 <cmccann> mike-burns, if the format string is the same thing for each argument, you can map printf with the single part over the string list
19:47:39 <mike-burns> I'm open to other ways to do %-25s .
19:47:41 <cmccann> then concat the results or whatever
19:47:56 <mike-burns> cmccann: oh, that's so obvious it just might work.
19:48:00 <co_dh> Cale : you are right , my ignorance :)
19:48:03 <ddarius> It is, however, somewhat annoying that Text.Printf is pretty much complete non-composable or reusable.
19:48:10 <ddarius> s/complete/completely/
19:48:22 <mike-burns> ddarius: I simply can't imagine a case where I'd be writing Haskell and want a variadic printf.
19:48:30 <mike-burns> ... which makes this all the more frustrating.
19:48:35 <Cale> mike-burns: You could just apply printf "%-25s" to each of the strings individually, and then manipulate them without further printfs :)
19:48:47 <cmccann> Cale, isn't that what I just suggested :P
19:48:50 <mike-burns> Cale: Yeah, cmccann just suggested that. Trying it now.
19:48:58 <Cale> yes, sorry :)
19:49:09 <co_dh> Does Text.Printf has static type safe ? I mean, if I say: printf "%s abc" (3 :: Int) , will it pass?
19:49:10 <Cale> I looked away for a moment to understand what %-25s meant
19:49:24 <mike-burns> co_dh: It'll compile but error at runtime.
19:49:42 <Cale> co_dh: It'll fail at runtime
19:50:09 <ion> ghci> Text.PrettyPrint.NCol.asColumns [[text "/tmp", text "foobar"], [text "/etc", text "baz quux"]]
19:50:12 <ion> /tmp      /etc
19:50:15 <ion> foobar    baz quux
19:50:41 <mike-burns> Text.PrettyPrint, eh?
19:50:51 <mike-burns> Actually that's exactly what I want.
19:51:11 <mike-burns> Hot diggity.
19:52:06 <co_dh> ddarius:  what in your mind is a composable printf ?
19:52:07 <ski> mike-burns : does `printfList :: PrintfType r => String -> [String] -> r; printfList fmt ss = loop ss (printf fmt) where loop :: (forall r. PrintfType r => r) -> [String] -> (forall r. PrintfType r => r); loop k [] = k; loop k (s:ss) = loop (k s) ss' work ?
19:52:19 <guerrilla> ok, thanks everyone. i fixed it all :)
19:52:32 <shachaf> Is there a standard TH version of printf that's type-safe?
19:52:34 <guerrilla> program compiles again :)
19:52:48 <ddarius> shachaf: There's a preexisting version, if that's what you mean.
19:53:01 <ski> mike-burns : er, s/loop ss (printf fmt)/loop (printf fmt) ss/
19:53:11 <mike-burns> ski: I'd try that but now I'm going down a Text.PrettyPrint path thanks to ion .
19:53:16 <shachaf> I suppose by "standard" I mean "in the standard library", and as accessible as Text.Printf is. :-)
19:53:31 <ski> ok
19:53:59 <parcs> the printf-mauke package contains a TH-based printf
20:03:24 <codnik> pastorn: hi there
20:03:33 <gienah> @google "Fun with type functions"
20:03:34 <lambdabot> http://www.haskell.org/haskellwiki/Simonpj/Talk:FunWithTypeFuns
20:03:34 <lambdabot> Title: Simonpj/Talk:FunWithTypeFuns - HaskellWiki
20:03:45 <gienah> this paper has a typed printf and sprintf
20:05:17 <co_dh> gienah: nice :)
20:23:05 <tgeeky> is that new?
20:24:09 <Axman6> is what new?
20:24:17 <tgeeky> sorry, didn't see how long ago it was posted
20:24:19 <tgeeky> FunWithTypeFuns
20:26:22 <rata_> hi
20:26:51 * ivanm waves idly in rata_'s general direction
20:26:51 <preflex>  ivanm: you have 1 new message. '/msg preflex messages' to read it.
20:27:02 <ivanm> wait, preflex records messages as well now? :o
20:27:27 <tgeeky> ion: I'm working on a way of doing that ("n-col" pretty printing, with some extra sugar on top) that has a lot of implicit structure
20:27:55 <ivanm> aavogt: h-u is now in github along with all other gentoo-haskell stuff; I don't really have anything to do with it anymore though, you'll have to talk to slyfox about it
20:28:52 <tgeeky> ion: though my approach is quite different than anything I've seen so far.
20:29:17 <ivanm> preflex: seen aavogt
20:29:17 <preflex>  aavogt was last seen on #xmonad 1 day, 21 hours, 47 minutes and 53 seconds ago, saying: you can kill gnome-panel; gnome-panel
20:29:31 <ivanm> @tell aavogt sorry about the late reply; h-u is now in github along with all other gentoo-haskell stuff; I don't really have anything to do with it anymore though, you'll have to talk to slyfox about it
20:29:31 <lambdabot> Consider it noted.
20:29:32 <tgeeky> ivanm: I thought preflex was just a fork-ish thing of lambdabot?
20:29:36 <ivanm> tgeeky: nope
20:29:41 <ivanm> completely different implementation
20:29:49 <ivanm> if it was a fork, would we really need it?
20:30:40 <tgeeky> touche, but I noticed the main functions preflex seems to be used for (@seen) is exactly the thing commented out from \bot
20:31:08 <tgeeky> ivanm: though the wiki does say "preflex is the name of a lambdabot with more commands/plugins enabled"
20:31:54 <ivanm> it does? then the wiki is wrong...
20:32:02 <tgeeky> wouldn't be the first time
20:32:10 <tgeeky> is the source for preflex available?
20:32:16 <ivanm> you'll have to ask mauke
20:33:06 <ivanm> so the polynomial package on hackage provides a way of doing single-dimension polynomial functions; how can I do 2D? Poly (Poly Int) or something ?
20:34:59 <tgeeky> surely something in NumericPrelude?
20:36:04 <ivanm> huh, didn't think to check that
20:36:09 <ivanm> never used it before though...
20:36:18 <ivanm> MathObj.Polynomail says it's for a single indeterminate
20:36:57 <ivanm> I'm also not a big fan of the T/C approach :s
20:37:05 <tgeeky> ;)
20:37:19 <mzero> anyone know how to achieve non-blocking character input via hscurses?
20:38:50 <jfmiller28> Good Evening (PDT) all.
20:39:29 <jfmiller28> I'm trying to work out some dependencies.  In particular the LLVM bindings.
20:40:18 <ivanm> tgeeky: HaskellForMaths seems to have a multivariate polynomial implementation though...
20:40:24 <tgeeky> mzero: don't even know if that make sense
20:40:25 <jfmiller28> I get "No instance for (Applicative (StateT CGMState IO))" when trying to install 0.9.1.2
20:40:29 <tgeeky> ivanm: lol. i forgot about that, too.
20:40:33 <om-foxy> I'm having trouble `cabal install`ing `ghc-paths` with ghc 7.1.20110612.  Is this a known problem?
20:40:44 <ivanm> jfmiller28: for which package?
20:40:56 <ivanm> om-foxy: probably not updated for 7.1 yet
20:40:57 <mzero> well....   I should be able to set    noDelay stdScr True    then call getch  and get -1 if there is no key
20:40:58 <tgeeky> mzero: does non-blocking mean asychronous?
20:41:05 <jfmiller28> icanm llvm
20:41:14 <mzero> it 1/2 works... but my program just dies after a few seconds if that getch is in my drawing loop
20:41:15 <augur> anyone familiar with lhs2tex?
20:41:18 <jfmiller28> ivanm llvm
20:41:24 <ivanm> om-foxy: any particular reason for using a pre-release?
20:41:32 <ivanm> augur: I used it a couple of times a few years back...
20:41:37 <augur> :P
20:41:40 <mzero> tgeeky - no, it is a non-blocking is a mode of input in ncurses
20:41:44 <om-foxy> ivanm: thanks, is {- LANGUAGE CPP -} deprecated in 7.1
20:41:52 <mzero> it is not asynchronous
20:41:53 <tgeeky> mzero: ah, ok, did not know it was available
20:42:03 <augur> are you familiar enough to know how to get [] to work correctly in %format's?
20:42:04 <om-foxy> ivanm: I'm working on a ghc feature.
20:42:04 <ivanm> jfmiller28: which GHC?
20:42:09 <mzero> right - it is there, but calling getch repeatedly causes death...
20:42:21 <ivanm> om-foxy: ahh fair enough; I doubt {-# LANGUAGE CPP #-} is deprecated, but some details may have changed
20:42:23 <jfmiller28> 6.12.3
20:42:26 <ivanm> augur: nope ;)
20:42:28 <mzero> there are like a dozen input/output flags to set, and I though someone might know the magic combo
20:42:31 <shachaf> mzero: Well, it's *kind of* asynchronous.
20:42:37 <shachaf> Depending on how you use it, I suppose.
20:42:40 <ivanm> jfmiller28: I think you need 7.0
20:43:02 <tgeeky> mzero: try getting more than one character, and use the recursing of those calls to add delays?
20:43:43 <mzero> what I see is that I set up noDelay mode, then I call getch ... for the first few 100 times I get -1... then the program dies
20:43:44 <tgeeky> ... if that makes sense? ;o
20:44:23 <jfmiller28> ivanm: assuming there is not a package for my version of Ubuntu with 7.0 yet, what is my upgrade path for installing from source?
20:44:35 <tgeeky> mzero: random search result: http://paste.lisp.org/display/23657
20:44:40 <ivanm> jfmiller28: you can probably get a pre-built binary
20:45:00 <ivanm> otherwise, get the source, build it, install it, uninstall 6.12.3 then re-build all packages you had built with 6.12.3
20:45:08 <ivanm> (the uninstallation is optional)
20:45:54 <mzero> ah -  i can take the forkIO approach.... okie-dokey... off to try that
20:46:04 <tgeeky> mzero: glad my random googling helped lol
20:46:14 <jfmiller28> ivanm: http://www.haskell.org/ghc/download_ghc_7_0_4 tells me to get haskell-platform; http://hackage.haskell.org/platform/linux.html sais I need GHC 7.0.3 first.  Infinite loop
20:47:34 <ivanm> jfmiller28: yeah, ignore the platform
20:47:45 <ivanm> 7.0.4 just came out recently with some bugfixes
20:47:56 <ivanm> you can then go and install the platform source later on if you want
20:48:24 <ivanm> doing a source install for the platform involves getting ghc first by hand anyway
20:48:47 <ivanm> and for by-hand *nix installs, you get GHC first and then build everything else in the platform afterwards
20:50:19 <jfmiller28> ivanm: Thanks.  tarball is d/l'ing
20:50:25 <ivanm> np
20:52:20 <ivanm> preflex: seen mokus
20:52:21 <preflex>  mokus was last seen on #haskell 1 year, 156 days, 15 hours, 17 minutes and 48 seconds ago, saying: koein37: i often find myself searching for haskell code by typing fragments of the program that i remember even when i don't remember the name of the soucre file or maybe even the project
20:52:33 <jtannen1> out of curiousity/concern for personal scheduling, how long would it take to go through http://learnyouahaskell.com/
20:52:45 <ivanm> wow... I think that's the longest idle time I've seen of someone that still frequents the channel...
20:52:50 <danharaj> What module should I use if I need a priority queue?
20:52:52 <luite> learn you a haskell in 24 hours
20:52:58 <ivanm> luite: heh
20:53:01 <mzero> D'oh - figured it out --- had nothting to do with ncurses -- I had something else feeding stdin to that process... silly me!
20:53:14 <oqueijinho> jtanneni: I've been taking my time in the evenings for a couple of weeks, and I'm half-way through
20:53:14 <ivanm> danharaj: I think there was a mention of one recently on the libraries list, in a thread started by ezyang
20:54:08 <luite> jtannen1: you can probably read at least the first half fairly quickly, but to really "get" haskell, you'll have to use it for a while
20:54:14 <danharaj> ivanm: Got a link?
20:54:22 <ivanm> sure, in my gmail inbox :p
20:54:25 <jtannen1> I know python already; I guess I should have said that
20:54:26 <mzero> jtannen1 - highly variable .. I did it in under 10 hours...
20:54:28 <danharaj> :p
20:54:29 <ivanm> @google haskell priority queue ghc
20:54:31 <lambdabot> http://hackage.haskell.org/package/pure-priority-queue
20:54:31 <lambdabot> Title: HackageDB: pure-priority-queue-0.14
20:54:40 <ivanm> OK, not what I was looking for...
20:54:57 <danharaj> ugh I really hate grabbing dependencies from Hackage.
20:55:13 <shachaf> danharaj: Isn't that what cabal-install is for?
20:55:15 <mzero> jtannen1 - then you're in for a very very fun mind-bending time! Enjoy it!
20:55:17 <luite> jtannen1: knowing python might help a little, but not very much, because of the differences
20:55:32 <danharaj> shachaf: I have no guarantee that the library doesn't suck (they tend to suck) and I have no guarantee there is still a maintainer.
20:55:47 <ivanm> danharaj: wait, they're talking about priority _search_ queues...
20:55:53 <shachaf> Oh, "grabbing" in the sense of "using".
20:55:54 <jtannen1> I can't wait :3 but it's 12:30am now, so I guess it will have to wait for me
20:56:27 <oqueijinho> jtannen1: for what it's worth, the print copy is 360 pages. it's a full book
20:56:30 <ivanm> danharaj: this seems to talk about a _verified_ library: http://code.google.com/p/priority-queues/
20:56:44 <jtannen1> ah, that's a good perspective
20:56:47 <ivanm> but it hasn't been touched since 2010, so YMMV :s
20:56:50 <augur> ok perhaps a more answerable question for people who code with emacs
20:57:20 <augur> can i put modes into a key command or something?
20:57:25 * danharaj grabs his copy of Okasaki and opens up a blank file
20:57:30 <augur> so i can turn on and off haskell mode?
20:57:33 <danharaj> If you want to hack in Haskell you must first invent the universe.
20:57:37 <shachaf> augur: @faq surely applies here.
20:57:44 <augur> shachaf: does it!
20:57:51 <augur> @faq haskell mode
20:57:51 <lambdabot> The answer is: Yes! Haskell can do that.
20:57:55 <augur> aha!
20:58:21 <oqueijinho> augur: you can always Meta-x and type haskell-mode
20:58:35 <augur> aha lemme try this
20:58:37 <oqueijinho> augur: you could bind it to a key, but you probably won't use it that much
20:59:00 <ivanm> danharaj: pqueue looks OK as well
20:59:40 <ivanm> augur: why not just have the mode activate as soon as you load/save a file with the specified extension?
20:59:47 <ivanm> or are you doing haskell-hacking in a non-haskell file?
20:59:54 <augur> ivanm: that one.
21:00:00 <ivanm> ahhhh
21:00:04 <ivanm> what kind of file may I ask?
21:00:16 <augur> well, agda actually :p
21:00:39 <augur> but its mostly tex
21:01:00 <ivanm> there are a few ways of doing tex+haskell in emacs
21:01:08 <ivanm> invariably they all suck at some point though
21:01:16 <augur> ofcourse :P
21:01:18 * ivanm wonders if emacs-24 has new multi-mode stuff...
21:02:17 <danharaj> ivanm: It looks decent. I wish GHC came with a more comprehensive set of data structures, or even better the standard library included more data structures.
21:03:20 <identity_> [A
21:03:45 <identity_> eh, Sorry, ircing on my phone
21:04:00 <ivanm> hmmm, I might have to dig-up my markdown multi-mode stuff and try using https://github.com/tarao/multi-mode-util in it instead of my own hacked-up solution for using multi-mode
21:06:55 <lispy> danharaj: What datastructures would you add?
21:07:40 <ivanm> lispy: _everything_! :p
21:07:50 <ivanm> though I would prefer that Data.Graph was removed from containers
21:08:24 <danharaj> lispy: A min/max heap that requires constant time to retrieve the min element would be nice.
21:08:48 <luite> what's wrong with having thsoe things in separate packages?
21:08:57 <ivanm> does anyone know if David Amos (that does Haskell for maths) hangs around here?
21:08:58 <ivanm> hey edwardk
21:09:12 <ivanm> luite: agreed; reduces maintainer work
21:09:28 <ivanm> though I suppose the disadvantage is that we get 10 duplicate implementations of uncertain quality
21:09:51 <danharaj> luite: I'd rather depend on a standard or implementation library than a library off of hackage that is questionably maintained and has 9 knock-offs to choose from.
21:10:11 <danharaj> Data structures are so basic.
21:10:21 <ivanm> O RLY?
21:10:29 <luite> dunno about that :)
21:10:45 <ivanm> danharaj: I've done two different implementations of graph-like structures in the past few months
21:10:50 <ivanm> both of which have completely different APIs
21:11:20 <luite> but I think it's not a problem of packages per se, but rather with the current hackage implementation
21:11:38 <danharaj> ok. *some* data structures are basic.
21:11:40 <luite> where you cannot really see how much each package is used, open issues, etc
21:14:12 <zuserm> Is there anyway to make (on) from Data.Function more polymorphic, so you could do things like ((<*>) `on` ZipList) ?
21:14:29 <ivanm> @type (<*>)
21:14:30 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
21:14:36 <danharaj> :t on
21:14:37 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
21:14:57 <ivanm> zuserm: you could write your own...
21:15:00 <edwardk> heya ivanm
21:15:04 <ivanm> wait, how would that work?
21:15:12 <ivanm> the function on the right only returns a certain type...
21:15:28 <ivanm> nvm, I see what you mean
21:15:49 <zuserm> I was thinking maybe using RankNTypes maybe?
21:15:49 <ivanm> @src on
21:15:50 <lambdabot> (*) `on` f = \x y -> f x * f y
21:16:11 <ivanm> @type \ f g x y -> f (g x) (g y)
21:16:12 <lambdabot> forall t t1 t2. (t1 -> t1 -> t2) -> (t -> t1) -> t -> t -> t2
21:16:23 <ivanm> zuserm: yeah, I don't think that'd work
21:16:25 <zuserm> You obviously can't in Haskell98
21:16:50 <ivanm> zuserm: maybe use liftM2/liftA2 instead?
21:16:51 <edwardk> and in the higher order case its hardly a simplification you need some type to tell it what the 'template' is for ZipList
21:17:03 <ivanm> @type liftM2 (<*>) ZipList ZipList
21:17:04 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
21:17:04 <lambdabot>       Expected type: [a -> b]
21:17:04 <lambdabot>       Inferred type: [a]
21:17:14 <ivanm> bah
21:17:57 <ivanm> @type \f -> liftM2 (<*>)  f f
21:17:57 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
21:17:58 <lambdabot>       Expected type: m (f a)
21:17:58 <lambdabot>       Inferred type: m (f (a -> b))
21:18:07 <ivanm> yeah, didn't think so
21:18:36 <ivanm> edwardk: you wouldn't happen to have any recommendations on a library to do 2D polynomials with, would you? :p
21:18:54 <edwardk> the irony is that right now as we speak i'm writing a polynomial library =P
21:19:31 <ivanm> edwardk: heh
21:19:35 <edwardk> i'm currently trying to find a nice recurrence to allow direct multiplication of spread polynomials
21:19:36 <ivanm> there's a few on hackage already
21:19:39 <edwardk> yes
21:19:43 <edwardk> none do what i need
21:19:47 <ivanm> dammit, the reverse hackage server is down atm :@
21:19:50 <edwardk> so as usual, i'm stuck rolling my own
21:20:00 <ivanm> edwardk: that doesn't sound familiar _at all_!
21:20:16 <ivanm> I'm currently using the polynomial library for 1D
21:20:17 <edwardk> i need to compute pade-chebyshev approximants from the taylor series i can get from my ad package
21:20:28 <luite> is it possible to derive Show for a type and all its "dependencies", instead of deriving them all individually?
21:20:33 <ivanm> thinking about using HaskellForMaths, but I'm not that sure about its reliability, etc.
21:20:39 <ivanm> luite: don't think so...
21:20:48 <ivanm> there's stand-alone deriving if that helps though
21:20:58 <edwardk> but i want to also handle multivariate polynomials, so i want to use the machinery i developed in ad for dealing with higher rank tensors to encode multivariate polynomials.
21:21:01 <luite> yeah I'm already using that, but it looks that I have to derive more than 20 types
21:22:21 <luite> or is there another way to output data structures for debugging purposes, without a Show instance?
21:22:26 <ivanm> luite: use some TH machinery maybe? :/
21:22:34 <ivanm> luite: create a custom a -> String function ?
21:22:45 <luite> hehe that's even more work :p
21:22:52 <ivanm> edwardk: lemme guess: it will be unusable by the common Haskeller? :p
21:22:52 <luite> it's for some GHC internal types in the typechecker
21:23:00 <luite> which usese lots of types for some reason :p
21:23:13 * ivanm wonders why...
21:23:22 <edwardk> ivanm: anyways, i like mokus, and the polynomial library is pretty close to usable, but i want easy change of basis, etc.
21:23:41 <edwardk> and i'd like to be able to work with them polymorphically and behind typeclasses.
21:23:47 <ivanm> edwardk: heh, "basis" is one of the things I never got in my math classes :p
21:24:03 <edwardk> plus the endianness machinery he encodes in the term belongs at the type level
21:24:14 <ivanm> edwardk: would "Poly (Poly Int)" suffice for bivariate polynomials do you think?
21:24:20 <edwardk> no
21:24:28 <ivanm> *sigh* didn't think so...
21:24:40 * hackagebot aosd 0.1.2 - Bindings to libaosd, a library for Cairo-based on-screen displays  http://hackage.haskell.org/package/aosd-0.1.2 (DanielSchuessler)
21:24:44 <edwardk> there is a traditional encoding though, one sec.
21:25:22 <luite> edwardk: does your polynomial library have efficient encoding for sparse polynomials?
21:25:30 <ivanm> so the only two libraries that seem to have working implementations then: np-extras by byorgey (but numeric-prelude hasn't been updated to ghc-7 yet) and HaskellForMaths
21:25:40 <edwardk> at least for use shoe-horning multivariate polynomials into univariate polynomials for multiplication
21:25:44 <edwardk> luite: yes
21:26:11 <edwardk> luite: currently i have both [a] and 'IntMap a' where the int indexes into an appropriate basis
21:26:31 <ivanm> maybe I should work out if this multivariate approach would work on paper first before I try to code it... >_>
21:26:49 <ivanm> (I've got two different generating functions, and am looking at combining them into one)
21:27:09 <edwardk> ah, you want a multivariate generating function?
21:27:22 <edwardk> what for?
21:27:58 <edwardk> luite: though, most of my polynomials are going to be in dense form, because i'll be using them for pade approximants
21:28:06 <luite> I used multivariate generating functions in haskell last year, for counting graphs of some shape
21:28:14 <ivanm> so the stuff I'm working on at uni atm is an algorithm for generating certain planar graphs
21:28:15 <edwardk> luite: and they'll be generated based on some taylor series
21:28:19 <luite> but those were very spares, and rather large
21:28:22 <luite> sparse
21:28:34 <luite> 20 variables, a few million terms
21:28:43 <luite> so not terribly easy to work with :)
21:28:50 <ivanm> when creating them, two different types of vertices are used in a tree-like structure: black and white
21:29:07 <ivanm> the counting argument my algorithm is based upon has a GF for the number of black vertices
21:29:23 <ivanm> I've adapted it for the number of white vertices, and I was planning on using it to reduce the search space
21:29:39 <ivanm> but just using the two of them will result in (w,b) pairs that are impossible
21:30:07 <edwardk> ivanm: *nods* you are of course aware of the uses of generating functions to describe the number of possible arrangements of k values in an ADT, etc?
21:30:12 <ivanm> if I can do a multivariate GF, I'm hoping that that way I can generate up-front all (w,b) pairs that are possible, and thus avoid going into useless search-spaces
21:30:19 <zuserm> edwardk: I'm writing a lens library after watching your talk on them. I've been calling it paremetric-lenses becasue you could use them with a parametric state monad.
21:30:28 <ivanm> edwardk: heh, never come across them before this, so no :p
21:30:35 <edwardk> zuserm: indexed state?
21:30:54 <edwardk> ivanm: one sec. lemme dig up a blog post
21:31:00 <ivanm> ta
21:31:01 <zuserm> maybe probably?
21:31:11 <edwardk> http://comonad.com/reader/2008/generatingfunctorology/
21:31:40 <edwardk> i have a multivariate generating function for dealing with the codata case around here somewhere
21:31:50 <luite> ah Wilf :)
21:32:00 <edwardk> luite: note the functor, not function ;)
21:32:03 <zuserm> parametric state monad is what I was it called on A Neighborhood of Infinity
21:32:07 <luite> I know
21:32:10 <edwardk> =)
21:32:36 <edwardk> zuserm: i have a package of indexed (co)monads that'll find its way onto hackage relatively soon
21:33:03 <edwardk> zuserm: yeah, the indexed name had slight precedence, so i've stuck with that terminology
21:33:13 <ivanm> edwardk: not sure I follow what you're doing there :s
21:33:53 <edwardk> ivanm: consider list as List a = 1 + (a * List a)
21:34:07 <ivanm> OK
21:34:12 <edwardk> then keep expanding, and gather the terms in terms of the number of 'a's
21:34:18 <edwardk> you get a generating function.
21:34:20 <ivanm> I think _now_ I see what you mean...
21:34:34 <ivanm> though where does the 1/(1-x) bit come from?
21:34:44 <zuserm> edwark: on the other hand ilenses is less fun to say then plenses
21:34:52 <ivanm> didn't help that I thought "[x]" was referring to singleton lists... :p
21:35:05 <edwardk> its holonomic as well
21:36:01 <luite> ivanm: the species introduction by byorgey may be interesting if you want to see how generating functions and haskell interact
21:36:04 <edwardk> well, do whatever plenses you i guess ;)
21:36:25 <ivanm> gah, 1/(1-x) is the actual sum for |x| < 0, isn't it...
21:36:28 <hpaste> “John F. Miller” pasted “LLVM Link Error” at http://hpaste.org/48010
21:36:34 <ivanm> luite: oh? where's this?
21:36:38 <edwardk> |x| < 0 ?
21:36:39 <edwardk> =)
21:36:45 <luite> hehe
21:36:45 <ivanm> s/0/1
21:36:52 <edwardk> and yes
21:36:57 <ivanm> @tell chrisdone yay for hpaste bot being back!
21:36:57 <lambdabot> Consider it noted.
21:37:03 <luite> well it's a formal series
21:37:11 <jfmiller28> Ok, now that everything is up to date  anyone have a gues at why LLVM will not link?
21:37:12 <edwardk> the formal power series of course doesn't concern itself with piddly things like having a radius of convergence of course
21:37:24 <luite> ivanm: hmm let me find it
21:37:41 <ivanm> edwardk: so where does the y come from in the Tree case? the sub-trees = y ?
21:37:55 <edwardk> which is nice. and there is of course the little theorem that says if you do a bunch of computations via formal power series and get back to one with a radius of convergence, you could have gotten there and stayed in normal power series all the way
21:38:01 <edwardk> ivanm. yeah.
21:38:12 <ivanm> what, what's mu again?
21:38:13 <ivanm> @src mu
21:38:14 <lambdabot> Source not found. Do you think like you type?
21:38:14 <edwardk> think how you'd write it without recursion in the type, using just Mu.
21:38:22 <edwardk> newtype Mu f = Mu (f (Mu f))
21:39:07 <ivanm> *sigh* Mu always confuses me....
21:39:09 <edwardk> then you can take data Tree a = Tip a | Bin (Tree a) (Tree a) — and turn it into data Tree x y = Tip x | Bin y y
21:39:17 <edwardk> and use Mu (Tree x)
21:39:18 <luite> Veid: http://www.cis.upenn.edu/~byorgey/papers/species-pearl.pdf
21:39:18 <ivanm> so you're solving y = 1 + x * y * y ?
21:39:19 <luite> oops
21:39:22 <luite> ivanm
21:39:23 <djahandarie> ivanm, type-level fix.
21:39:25 <ivanm> luite: heh
21:39:31 <edwardk> so that you get y = 1 + x * y * y.
21:39:33 <edwardk> yes
21:39:43 <Veid> What what
21:39:43 <ivanm> djahandarie: right, but there's a reason I don't use fix as well :p
21:39:51 <ivanm> edwardk: OK, that makes a lot more sense to me
21:39:59 <djahandarie> Ah.
21:40:08 <edwardk> or rather in the version i gave above y = x + y * y
21:40:16 <edwardk> (i assume i gave the other in the article)
21:40:52 <ivanm> edwardk: though did you notice that you had '<pre lang="haskell">' in there? :p
21:41:17 <edwardk> i changed out the haskell formatter i was using at some point. guess that left a dangling bit of mess in this article
21:41:53 <ivanm> edwardk: though I fail to see anywhere there about implementation of a multivariate polynomial....
21:42:51 <edwardk> ivanm: i said i had one, i didn't say i blogged it there ;)
21:43:00 <ivanm> ahhh, thought you said that you did
21:43:01 <edwardk> its been a couple years since i worked it out
21:43:13 <edwardk> but you can generalize what was done there to handle codata
21:43:26 <edwardk> which requires a multivariate generating function
21:44:55 <rata_> how would you write a fn (f :: Map a b -> Maybe Int) to find the first value in a Data.Map that matchs a pattern?
21:45:07 <rata_> (first in a non-strict way)
21:45:43 <ivanm> what do you mean "matches a pattern" ?
21:45:44 <edwardk> Data.Foldable.toList  — then use an appropriate function on lists. ;)
21:45:53 <ivanm> and what is the Int for?
21:46:02 <ivanm> edwardk: Data.Map already provides a toList ...
21:46:08 <rata_> ivanm: to report an error
21:46:39 <ivanm> rata_: which question is that an answer to? :p
21:46:51 <edwardk> i'm aware. =P
21:47:08 <rata_> hahahaha... to the second one
21:47:11 <ivanm> you're just a fan of Foldable then I take it?
21:47:29 <ivanm> rata_: is the Int meant to be the index or something?
21:47:34 <edwardk> that and he only mentioned the value, not the key
21:47:34 <ivanm> or an error ID?
21:47:55 <ivanm> edwardk: M.elems !
21:48:10 <edwardk> ivanm: *twitch* first order *twitch* ;)
21:48:19 <ivanm> hmmm?
21:48:40 <rata_> ivanm: it's an id, but not an error id
21:48:50 <rata_> it's part of the error msg
21:50:30 <rata_> ivanm: to the first question: by "matches a pattern" I mean something like "data D = A Int | B String" then "g (A x) = x; g _ = ... -- continue searching"
21:50:51 <ivanm> so you want to do pattern matching?
21:50:56 <edwardk> just foldMap (\a -> First $ if p a then Just whatever else Nothing) yourMap
21:51:05 <ivanm> @hoogle First
21:51:05 <lambdabot> Data.Monoid newtype First a
21:51:05 <lambdabot> Data.Monoid First :: Maybe a -> First a
21:51:05 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
21:51:56 <edwardk> foo = foldMap $ \a -> case a of A x -> First (Just x); else mempty
21:52:25 <rata_> myMap is an instance of Foldable? that's the reason I can use foldMap?
21:52:32 <edwardk> yes
21:52:50 <edwardk> there is a Foldable instance on Map m
21:53:40 <ivanm> edwardk: would you have happened to recall what implementation you used for multivariate GFs?
21:54:06 <edwardk> i rolled one myself. they aren't hard
21:54:42 <ivanm> Map (X,Y) Int or something?
21:54:56 <edwardk> multivariate polynomial multiplication just needs integer partitioning
21:55:08 <rata_> and foldMap uses just the values of the map?
21:55:12 <edwardk> rata: yeah
21:55:14 <luite> ugh 50 standalone deriving Show instances later and still pages of errors....
21:55:19 <ivanm> luite: lol
21:55:28 <edwardk> rata; you can use my keys package if you need the key as well, it provides foldMapWithKey
21:56:08 <ivanm> edwardk: why integer partitioning?
21:56:50 <augur> anyone familiar with lhs2tex, is it possible to define a new keyword?
21:57:00 <ivanm> hmmm..... if I do my own implementation, then I can probably do some extra hacks in like how to remove powers higher than needed...
21:57:10 <ivanm> preflex: seen kosmikus
21:57:10 <preflex>  kosmikus was last seen on #haskell 6 days, 17 hours, 51 minutes and 59 seconds ago, saying: accel: it's not quick, because it makes use of inefficient ++, and it's not quicksort as an algorithm
21:57:11 <edwardk> usually in the univariate case you need to go through the coefs a_k b_(n - k)  to figure out the coef for c_n
21:57:51 <edwardk> in the multivariate case you need to go through the various variables in the ways that sum to the right counts
21:58:03 <edwardk> so not just 2 at a time usually
21:58:22 <ivanm> ahhhh, right
21:58:29 <ivanm> to collect terms
21:59:10 <ivanm> I might just fudge around and use the HaskellForMaths implementation then
21:59:57 <ivanm> and see about using a better one later on
22:00:21 <edwardk> you can also just use an Int * Int memotrie
22:00:53 <kosmikus> ivanm: hmm?
22:01:08 <ivanm> kosmikus: augur wanted help with lhs2tex
22:01:18 <augur> what hi hello
22:01:35 <ivanm> edwardk: why a memotrie?
22:01:43 <kosmikus> augur: you cannot really define a new keyword, but you can just change the formatting of any token to look like a keyword
22:01:53 <augur> hey hello. how would i do that?
22:02:20 <edwardk> ivanm: easy to accumulate into
22:02:24 <augur> or more specifically, in agda mode it looks like a slightly bold mathbf is used for keywords, but i have no idea how to get that
22:02:37 <kosmikus> augur: %format foo = "\textbf{foo}"
22:02:41 <kosmikus> oh, Agda mode
22:02:45 <augur> yeah
22:02:55 <augur> er not mathbf, sorry, a slightly bold mathsf
22:03:20 <ivanm> edwardk: never having even seen MemoTrie (I assume you mean conal's package?) before, or used anything like it, I'm not quite sure what you mean by that :/
22:03:33 <kosmikus> augur: in Agda mode, %format foo = "\Keyword{foo}" should work
22:03:39 <edwardk> i really mean representable-tries, but nm ;)
22:04:00 <augur> kosmikus: hm!
22:04:01 <augur> awesome
22:04:17 <kosmikus> augur: I have to get breakfast :) Will be online again in half an hour or so.
22:04:53 <augur> thank you kosmikus! <3
22:04:57 <ivanm> edwardk: oh, one of _your_ crazy packages! :p
22:05:02 <edwardk> =P
22:05:25 <edwardk> they are perfectly sane packages, they are just written by a crazy person, there is a difference. ;)
22:05:41 <ivanm> with a noticeable disdain for documentation? :p
22:06:03 <edwardk> if it was hard to write it should be hard to understand… or something, actually i just haven't gotten around to it
22:06:38 <edwardk> ivanm: a representable functor is one that is isomorphic to a function from x.
22:06:55 <edwardk> ivanm: i give two combinators for working with them. tabulate :: (x -> a) -> f a
22:07:00 <ivanm> so you're suggesting I use the HasTrie instance for Map (Int,Int) Int or something?
22:07:00 <edwardk> and index :: f a -> x -> a
22:07:05 <edwardk> which are inverses
22:07:28 <ivanm> where are these combinators? they're not in Data.Functor.Representable.Trie ...
22:07:28 <edwardk> no, i'm suggesting you can use (Int, Int) :->: coefficient
22:07:37 <edwardk> they are up in representable-functors
22:08:03 <ivanm> *sigh* can you get your package straight for once?
22:08:06 <edwardk> more over, each representable-trie is also traversable (and traversableWithKey) and admits a notion of adjust which lets you tweak a single entry
22:08:10 <edwardk> i did
22:08:17 <edwardk> representable-tries USES representable-functors
22:08:18 <ivanm> first you say memo-trie, then representable-trie and now representable-functors; make up your mind! :p
22:08:23 <ivanm> oh...
22:08:33 <edwardk> representable-tries gives you the easier (:->:) type
22:08:43 <edwardk> (Int, Int) :->: a
22:08:51 <edwardk> or even Int :->: Int :->: a
22:09:07 <ivanm> and where's :->: from?
22:09:22 <ivanm> is that in the monadic interface in representable-tries?
22:09:26 <edwardk> http://hackage.haskell.org/packages/archive/representable-tries/0.5.0.1/doc/html/Data-Functor-Representable-Trie.html
22:10:04 <ivanm> ahhh, missed that somehow...
22:10:23 <edwardk> you can tabulate to build it or just start one with pure 0, and then use adjust from the keys package to update it element-by-element
22:11:02 <ivanm> can you give me an example please?
22:12:12 <edwardk> foo = index $ adjust (+1) 12 $ pure 0
22:12:17 <ivanm> I'm trying to work out what it all does... and whilst I could probably bash my way through to figuring it out from what you've given me, I'm not even sure if this approach would work to justify wasting time on it :p
22:12:26 <edwardk> gives you a function that is 0 everywhere except at 12, where it is 1
22:12:39 <edwardk> until you index it it is a bit tree like structure
22:12:48 <ivanm> ahhhhhhh........
22:13:11 <ivanm> where is index from?
22:13:18 <edwardk> http://hackage.haskell.org/packages/archive/keys/0.3.0/doc/html/Data-Key.html
22:13:22 <edwardk> where adjust also lives
22:13:36 <edwardk> and (:->:) is an instance of both.
22:14:04 <edwardk> Representable ((:->:) a) implies Indexable
22:14:29 <ivanm> so in this case the (adjust (+1)) is the "f a" and the 12 is the "Key f" ?
22:14:30 <danharaj> hrm
22:14:41 <edwardk> and HasTrie a gives you Adjustable ((:->:)a), Representable ((:->:)a)
22:15:09 <edwardk> adjust (+1) 12 :: Num a => (:->:)Int a -> (:->:) Int a
22:15:14 <danharaj> It would be nice if Haddock could tell you what associated types are in a module. like, what is `Key []' in the Keyed instance for [].
22:15:18 <edwardk> f = (:->:) Int    here
22:15:21 <ivanm> ahhhh
22:15:35 <edwardk> danharaj: Int
22:15:40 <edwardk> danharaj: but yes =)
22:16:18 <ivanm> trying to work out why you used $ twice, that's all :p
22:16:42 <ivanm> edwardk: if I have Int co-efficients, what m do you recommend I use? Identity?
22:16:43 <copumpkin>   abs = error "borked numerical tower"
22:16:44 <danharaj> edwardk: Is there a reason why you chose to use associated types instead of FunDeps and MultiParamTypeClasses?
22:16:45 <copumpkin> nice
22:16:48 <edwardk> pure 0 built the (:->:) Int Int, adjust changed it, then index gave back a function
22:17:08 <ivanm> copumpkin: where's that?
22:17:11 <edwardk> danharaj: yes, most operations don't care about the key type, so it would clutter up a lot of type signatures
22:17:20 <copumpkin> in one of edwardk's pastes on github
22:17:28 <edwardk> copumpkin: =)
22:17:44 <danharaj> edwardk: Ah. Good reason. Too bad it makes the documentation a little less clear. But maybe that's Haddock's fault :p
22:17:49 <copumpkin> at least it isn't abs :: Num a => a -> Int, right
22:17:52 <copumpkin> oh wait
22:17:52 <edwardk> copumpkin: still trying to figure out the right recurrence for spread polynomials
22:17:54 <copumpkin> that was signum
22:17:59 <copumpkin> signum :: Num a => a -> Int
22:18:12 <edwardk> danharaj: it is, sadly.
22:18:20 <edwardk> @type signum
22:18:21 <lambdabot> forall a. (Num a) => a -> a
22:18:23 <copumpkin> edwardk: I see
22:18:27 <edwardk> signum doesn't go to Int
22:18:29 <copumpkin> edwardk: I was referring to the shitty scala numeric one
22:18:29 <edwardk> consider Complex
22:18:32 <edwardk> it is phase there
22:18:36 <edwardk> yeah
22:18:37 <copumpkin> yeah, I know
22:18:40 <edwardk> scala's is just asinine
22:18:40 <copumpkin> I was just mocking scala
22:18:49 <edwardk> because it is even worse
22:19:14 <luite> ivanm: yay it works, almost 100 lines of instances
22:19:22 <ivanm> luite: :o
22:19:25 <luite> and the file now takes two million years to compile
22:19:40 <ivanm> luite: so now you should ask the simons why those types don't derive Show to start with! :p
22:20:02 <luite> hehe there's already an Outputable type
22:20:10 <luite> but that hides too many internals
22:20:23 <edwardk> copumpkin: basically what that file is was me playing around with trying to extract commonalities from a bunch of different orthogonal polynomial bases
22:20:27 <luite> unless I missed something, which is actually quite likely :p
22:20:35 <ivanm> edwardk: is there any easy way to do something like "set all co-efficients of x^n where n > some constant to be 0" ?
22:20:37 <edwardk> so i can figure out a nicer encoding
22:20:49 <copumpkin> edwardk: ah
22:20:53 <edwardk> just initialize the whole thing to 0, then copy over the ones you want ;)
22:21:29 <ivanm> edwardk: heh, probably won't work...
22:22:10 <edwardk> cutoffAt m f = tabulate $ \n -> if n > m then 0 else index f n
22:22:15 <ivanm> edwardk: to create the GF, I have a series of recursive functions, so I plan on just repeatedly applying the rules until a fixed-point is reached for the terms I care about
22:22:37 <edwardk> ah
22:22:45 <ivanm> e.g. W_{d-2} = x * (1+W_0)^(d-1)
22:23:08 <ivanm> OK, cabal-install wants to upgrade array for some reason...
22:23:09 <edwardk> the better option would probably be to tabulate the answers separately rather than mutate
22:23:52 <ivanm> well, I was hoping to be able to just do x * ...
22:24:33 <edwardk> foo * bar = tabulate $ \ (n,m) -> [ index foo (i,j) * index bar (n - i, m - j) | i <- [0..n], j <- [0..m] ]
22:24:41 <Cale> ivanm: I don't know the context of your question, but you can work in the ring R[x]/<x^c> where c is the least term you're not interested in.
22:24:51 <edwardk> er -> sum
22:25:15 <edwardk> foo * bar = tabulate $ \ (n,m) -> sum [ index foo (i,j) * index bar (n - i, m - j) | i <- [0..n], j <- [0..m] ]
22:25:21 <Cale> (also I really wish that people would use the term generating series rather than generating function .____.)
22:25:31 <ivanm> Cale: I'm wanting to do multivariate GFs
22:25:43 <ivanm> Cale: hey, I'm using the terminology from the paper I'm basing my work on! :p
22:25:43 <edwardk> sorry cale, wilf pushed the world in the other direction ;)
22:25:49 <edwardk> you're on your own there ;)
22:26:19 <Cale> Waterloo is the other way around :)
22:26:49 <edwardk> world goes one way, waterloo goes another, why am i not surprised? =)
22:27:16 <Cale> I don't understand why you'd want to push things more in that direction, it's a total misnomer isn't it?
22:27:42 <Cale> I mean, I guess all formal power series are technically functions from the natural numbers
22:28:20 <ivanm> Cale: so edwardk is trying to convince me to write a multivariate polynomial library using his weird (and supposedly wonderful) packages :p
22:28:28 <edwardk> no, not really
22:28:33 <edwardk> i just said it wasn't hard =P
22:28:46 <Cale> Don't do that, write a monoid ring library
22:28:57 <Cale> and then use the monoid of bags to get multivariate polynomials :)
22:28:57 <ivanm> *sigh*
22:29:05 <edwardk> i'm already writing a polynomial library. mostly because i want nice pade approximants out of my ad library
22:29:14 <Cale> easy peasy
22:29:20 <ivanm> considering this is one small thing I'm wanting to be able to act as an optimisation for the algorithm I actually care about...
22:29:32 <danharaj> Cale: Have a favorite priority queue library?
22:29:34 <ivanm> I have the sneaking suspicion both of you are leading me astray! :p
22:29:41 <Cale> danharaj: I dunno, psqueue?
22:29:46 <ivanm> edwardk: when can we expect this to be available?
22:29:51 <edwardk> danharaj: does it have to be a priority search queue?
22:29:54 <edwardk> or just a heap?
22:29:58 <Cale> psqueue is the only one that I've used
22:30:19 <Cale> I don't know if that's technically dumb and the search features make it slow or something :)
22:30:41 <edwardk> http://hackage.haskell.org/packages/archive/heaps/0.2/doc/html/Data-Heap.html is a brodal okasaki heap with a containers-like api
22:30:42 <Cale> (but I found the searching convenient in my application anyway)
22:30:54 <danharaj> edwardk: I think I can get away with just a heap but knowing of a psq would be useful.
22:31:10 <edwardk> main advantage is O(1) heap merge
22:32:00 <Cale> You'll also probably find my fingertree-psqueue package, but I don't see how it could be better than PSQueue. It's more of an example/exercise in fingertree than a real package.
22:32:17 <ivanm> edwardk: so when do you expect to have your polynomial library available for all and sundry to use?
22:32:18 <danharaj> mm
22:32:30 <edwardk> ivanm: shortly after i get bored with it ;)
22:32:32 <danharaj> Who do I lobby in order to get heaps included in Containers?
22:32:33 <ivanm> heh
22:32:59 <edwardk> fingertree-psqueue is about 10x slower than PSQueue, but is fair, and iirc, supports merges
22:33:09 <ivanm> edwardk: is there at least a working implementation available on github or something? this package of mine isn't likely to be published any time soon...
22:33:28 <edwardk> danharaj: there was a lobby at one point to get one added, it failed
22:33:45 <danharaj> :o why did it fail? Heaps seem to be a fundamental tool in the box.
22:34:05 <edwardk> ivanm: not yet, i'm currently seeking very different functionality than what you want, so its kinda silly for you to build on top of right now
22:34:22 <ivanm> oh, OK
22:34:23 <luite> edwardk: do you have some benchmark results available somewhere?
22:34:27 <danharaj> Certainly it deserves to be in Containers more than Graph ;p
22:34:49 <edwardk> luite: not convenient. the guy who was petitioning (iirc it was louis wasserman) had a bunch
22:34:52 <edwardk> i piggybacked on his
22:34:59 <ivanm> edwardk: do you really think it's worth my time trying to create a new one rather than using the one in HaskellForMaths?
22:35:12 <edwardk> i haven't looked at haskellformaths
22:35:14 <edwardk> can't say
22:35:30 <ivanm> edwardk: ezyang was also trying to get a PSQ into containers or something I think so he could use it in GHC...
22:36:10 <edwardk> yeah he wanted the one broken out that is in the guts of the ghc scheduler though
22:36:14 <edwardk> which is a bigger deal
22:36:20 <edwardk> because that one is intentionally very monomorphic
22:37:29 <edwardk> ivanm: the haskellformaths stuff here doesn't look too bad
22:37:36 <edwardk> seems sufficient for your needs at any rate
22:38:01 <ivanm> ta
22:38:21 <ivanm> unlike some people, I prefer not to re-invent the wheel if not necessary :p
22:38:40 <edwardk> i do too. i just find it necessary more often than most ;)
22:38:44 <co_dh> I'm a wheel invertor
22:38:50 <nus> edwardk, re Pade-Chebyshev, see if this makes any sence: http://translate.google.com/translate?hl=en&ie=UTF8&prev=_t&sl=auto&tl=en&u=http://duds.susu.ru/ibryeva_ol/Ibryaeva-05a.pdf
22:38:53 <edwardk> besides i write haskell for fun
22:39:03 <danharaj> Sometimes I feel like I use a different gauge track than the rest of the world.
22:39:05 <luite> edwardk's wheels are usually more general :p
22:39:26 <ivanm> luite: and monadic in nature!
22:39:32 <ivanm> or co-monadic, take your pick
22:40:00 <edwardk> danharaj: russian? =)
22:40:04 <co_dh> edwardk: where is your haskell code repo?
22:40:16 <edwardk> co_dh: for polynomials? i don't have one up yet
22:40:24 <nus> hahah, google translated Toeplitz as 'greenhouses'
22:40:27 <co_dh> for category theory
22:40:31 * ivanm tries to work out if it's possible with HaskellForMaths to remove unneeded terms
22:40:34 <edwardk> co_dh: github.com/ekmett
22:40:40 <edwardk> co_dh: there are a lot of little repos there
22:40:58 <danharaj> edwardk: :p Anyway. I think I'll use your heap library, provided that equisitely succinct dependency list stays that short. :p
22:40:59 <edwardk> co_dh: most of them are category-theoretic
22:41:00 <co_dh> got it, thanks
22:41:09 <edwardk> danharaj: hahaha
22:41:14 <luite> does anyone know how to typecheck an expression "expr :: T" with the GHC API, where the type T might not be in scope, but I do have a TypeRef.Type for T?
22:41:37 <ivanm> edwardk: I may follow your suggestions and implement a new one down the track; but to see if this works (since I have to make sure the math is right) I'll just use HaskelLForMaths
22:41:43 <edwardk> danharaj: ack, no pointed instances, no semigroups, what ever will i do!
22:41:53 <danharaj> Some people play code golf with their haskell. I play dependency golf :p
22:43:49 <edwardk> danharaj: i had some fun putting that one together. i doubt many people will need group :: Heap a -> Heap (Heap a) — but i liked it ;)
22:44:16 <danharaj> edwardk: How many people can honestly say they needed intercalate from Data.List?
22:44:18 <danharaj> :p
22:44:41 <edwardk> me. it pained me, not to add it to heaps ;)
22:45:25 <danharaj> heh. I noticed you don't have a toAscList function?
22:45:28 <co_dh> how many people here make living with haskell?
22:45:36 <ivanm> edwardk: actually, with your approach, how would you generalise it to work for an unspecified number of variables? "(Num a) => Int :->: a" or something? (though I think that would prevent you from defining convenience values like x, y, etc.)
22:45:51 <edwardk> danharaj: Data.Foldable.toList will do that
22:45:57 <danharaj> ah ok.
22:45:57 <edwardk> the Foldable gets them out in heap order
22:46:09 <ivanm> co_dh: define "living"; I use Haskell for my "job", but it's not the point of my "job" (I'm a PhD student)
22:46:23 <edwardk> ivanm: [Int] :->: a i guess
22:46:41 <danharaj> the other Containers structures have `elems' and `toAscList', if you want to mirror their interfaces.
22:46:41 <ivanm> hmmm.....
22:47:06 <ivanm> edwardk: so yeah, you definitely couldn't provide values like x, y, etc. without knowing how many variables you're using
22:47:07 <edwardk> (Int :->: Int) :->: Int ?
22:47:24 <edwardk> yeah
22:47:24 <ivanm> unless you do a _lot_ of under-the-hood manipulation
22:47:55 <edwardk> one of the other approaches i've been exploring is based on my vector space monad machinery
22:48:31 <edwardk> if we define a monad for newtype Linear p a = Linear [(p,a)] — we can can view that as a linear sum of the basis vectors a.
22:48:31 <co_dh> edwardk: what is a codensity? any link or paper ?
22:48:43 <c_wraith> @src Codensity
22:48:43 <lambdabot> Source not found. :(
22:48:48 <edwardk> co_dh: check the kan extension articles on my blog. i give links there
22:48:59 <jfmiller28> ivanm: Thanks for the help.  It's working now. :)
22:49:11 <ivanm> jfmiller28: np; what was the issue though?
22:49:19 <ivanm> IIRC, all I said was "upgrade ghc" :p
22:49:29 <co_dh> edwardk:  I think I'm not smart enough to understand kan extension :( ..
22:49:41 <edwardk> co_dh: they aren't as scary as they sound
22:49:58 <jfmiller28> ivanm: see http://stackoverflow.com/questions/6406067/haskell-llvm-binding-linker-error
22:49:58 <edwardk> http://comonad.com/reader/2008/kan-extensions/
22:50:35 <edwardk> co_dh: there are 2 further articles that go in deeper
22:51:46 <edwardk> anyways, if you build a vector space out of the standard power basis. and another out of the various other polynomial bases, then i can do all my polynomial calculation in my simple vectorspace/probability/quantum computation monad.
22:52:38 <edwardk> i wind up with newtype T = T Int — for the chebyshev polynomial basis of the first kind. and then just have to instantiate cup and cap functions for it for the inner product
22:53:45 <mzero> OH My!  the ICFP contest logo this year is a two-step quine!
22:54:02 <mzero> the .png logo is.... executable!!!!!!
22:54:24 <edwardk> mzero: hah
22:56:24 <mzero> 13  ICFP 2011 repos on github!
22:56:39 <edwardk> the problem this year was cute
22:57:06 <co_dh> edwardk:  may I ask you that what u do to make a living?
22:57:36 <edwardk> co_dh: i write tools that make quants' lives easier
22:58:01 <co_dh> quant developers ? hedge fund?
22:58:23 <edwardk> nah, clarifi, we sell tools to quants at those hedgefunds basically
22:59:17 <edwardk> before that i was in defense, before that i was hiding in academia collecting degrees, and before that i was crashing and burning with the rest of the dot-coms
22:59:18 <co_dh> great , is category theory useful in quants ? or it just help you understand mathematics?
23:00:09 <co_dh> lol.
23:00:11 <edwardk> occasionally. its pretty well understood around the office. dolio, copumpkin, apocalisp and pchiusano all work here
23:00:15 <rata_> edwardk: where is your keys package?
23:00:21 <edwardk> rata: hackage =)
23:00:33 <edwardk> http://hackage.haskell.org/package/keys
23:00:40 <rata_> thanks
23:01:11 <edwardk> rata: its arguably my least broken out package, but then importing all those classes separately would be a pain in the butt
23:01:21 <edwardk> so i haven't decided how i want to clean it up
23:02:12 <edwardk> danharaj: i remember now why i needed type families.
23:02:55 <edwardk> danharaj: all right adjoint functors are representable. representable functors have a representation. i choose that to be the key, if i had made it a type class argument in keys, i wouldn't have been able to get rid of the spurious argument to adjunction
23:03:12 <edwardk> danharaj: which _really_ don't care about the choice of representation
23:03:20 <ivanm> edwardk: OK, actually trying to use HaskellForMaths suddenly tempts me to go implement your ideas after all... >_>
23:03:29 <edwardk> hahahaha
23:03:46 <ivanm> e.g. the fact that there are no included MPoly -> [...] functions
23:03:46 <luite> yay got a Hetzner server for my (haskell-related) website \o/
23:03:47 <edwardk> i'll probably try a version on top of the simple vectorspace monad
23:03:56 <ivanm> luite: what's a Hetzner server?
23:04:08 <luite> ivanm: the hosting provider that also hosts projects.haskell.org
23:04:14 <ivanm> ahhhh
23:04:33 <edwardk> mostly because i want to use Codensity (Free (Linear Double)) T — as a polynomial some time.
23:04:59 <ivanm> edwardk: so it's a trade-off in time... do I try and cludge what I want out of HaskellForMaths (which will probably be faster) or write a new library (which will take longer but will hopefully be cleaner)
23:05:28 <edwardk> don't know all your constraints. ;)
23:05:31 <ivanm> because HaskellForMaths has a _lot_ of cludges in it now that I'm actually trying to use it...
23:05:43 <luite> ivanm: they have cheap dedicated servers with good hardware (which is probably why the code.haskell.org admins chose it :) )
23:05:51 <edwardk> work out the generating function on paper
23:05:58 <edwardk> why do you need it to manifest as such in code?
23:06:10 <ivanm> edwardk: main constraint is time, and that I have a lot of other packages that I want to hack on (e.g. I was originally planning on getting a new release of graphviz out last weekend, but havne't finished it yet)
23:06:12 <edwardk> once you have the generating function you can use it to write more efficient code
23:06:44 <ivanm> edwardk: OK, for a given `d', there will be d-1 generating functions (for i=0...d-2)
23:06:47 <edwardk> especially if the resulting generating function is nicely holonomic you can just write down the recurrence formula then
23:06:57 <ivanm> the `d' is a parameter to the program
23:07:08 <ivanm> I have recurrence equations on how to generate the GF
23:07:29 <ivanm> but AFAICT it doesn't immediately lead to a nice solution for any given `d'
23:07:37 <edwardk> okay, then turn it inside out into a data structure, build it lazily, and go ;)
23:07:53 <edwardk> sounds blechy
23:08:35 <ivanm> heh, the whole point of using the GFs is to cut-down the search space so as not to try and generate non-existant values in my highly-recursive algorithm (as it's initially a tree-like structure)
23:10:19 <ivanm> oh, and even better: all but the i=d-2 terms use a function h, which requires partitioning (i+2) into r=1..i+2 values non-zero values, and multiplying the respective recurrence polynomials
23:10:45 <edwardk> getting blechier by the minute ;)
23:10:49 <ivanm> yup!
23:11:34 <ivanm> but my supervisor suggested this approach (admittedly without him knowing how blechy it is), rather than trying to generate the value and then saying "oh, there aren't any of that size, record that value and don't try it again"
23:11:49 <Cale> edwardk: btw, generatingfunctionology is a terrible book, I just have to say :P
23:11:58 <edwardk> true
23:12:41 <ivanm> Cale: for a terrible book it seems to be recommended as _the_ book for generating functions...
23:12:51 <Cale> Let's take a beautiful correspondence between operations on sets and algebraic operations, and obscure it to the point where nobody will ever get the big picture.
23:13:23 <Cale> I guess it's free, but still :(
23:13:32 <edwardk> btw- who was it that pasted the nice russian chebyshev-pade paper?
23:13:49 <ivanm> edwardk: nus
23:14:08 <edwardk> ah
23:14:15 <Cale> ivanm: Unfortunately, I don't really know of any books which are simultaneously good, widely available and introductory.
23:14:20 <rata_> how can I make a fn like "\a b -> threeArgsFn $ twoArgsFn a b" point-free?
23:14:23 <ivanm> edwardk, Cale: if you're interested in what I'm doing, the GFs are from section 6.1 on p19 of http://arxiv.org/abs/1007.1292
23:14:23 <Cale> You can get any two of those.
23:14:38 <rata_> "threeArgsFn . twoArgsFn" doesn't work for me
23:14:51 <edwardk> rata: you probably shouldn't =)
23:14:59 <rata_> why?
23:15:00 <edwardk> that said you can define … = (.).(.)
23:15:04 <ivanm> rata_: where are the other arguments coming from?
23:15:07 <edwardk> and use threeArgsFn … twoArgsFn
23:15:17 <edwardk> but you lose your audience fast ;)
23:15:22 <ivanm> you're only providing threeArgsFn with one argument there that I can see...
23:15:23 <rata_> hahahaha
23:15:31 <edwardk> another encoding is fmap fmap fmap threeArgsFn twoArgsFn
23:15:48 <edwardk> that is also sure to break your readership
23:15:50 <ivanm> edwardk: yeah, I saw that used in some code and thought it was just a placeholder until the writer got around to finishing it :p
23:15:59 <rata_> mmmm... maybe it's better to keep it so
23:16:43 <edwardk> rata: yeah, i don't generally use point free when its not obviously plumbing one argument through
23:17:01 <Cale> oh, so you're computing Stirling numbers?
23:18:08 <Cale> That is a terrible derivation of the formula for the Bell numbers, btw.
23:18:18 <ivanm> Cale: is that to me?
23:18:21 <Cale> yeah
23:18:29 <ivanm> I have nfi what I'm computing :p
23:18:48 <ivanm> I've converted that counting argument to a generating algorithm
23:19:27 <ivanm> but it was suggested that to help prune the search-space that I use the provided GF (which I _think_ I've converted into a multivariate one)
23:19:53 * hackagebot hack2 2011.6.20 - a Haskell Webserver Interface (V2)  http://hackage.haskell.org/package/hack2-2011.6.20 (JinjingWang)
23:19:55 * hackagebot hack2-contrib 2011.6.20 - Hack2 contrib  http://hackage.haskell.org/package/hack2-contrib-2011.6.20 (JinjingWang)
23:20:11 <Cale> The Bell numbers count the number of set partitions. A set partition is a set of nonempty sets, so you immediately get the decomposition U (*) (U \ {0}) which by the star composition lemma and the fact that unordered sets have e.g.s. e^x, gives the exponential generating series e^(e^x - 1)
23:20:17 <ivanm> so for a specified d, I'm trying to create all the GFs for the different values of i for that d, and then get as many terms as needed
23:20:25 <Cale> None of that algebraic b.s. required :P
23:20:53 * hackagebot miku 2011.6.20 - A minimum web dev DSL in Haskell  http://hackage.haskell.org/package/miku-2011.6.20 (JinjingWang)
23:21:19 <ivanm> I'm not sure if it's stirling numbers... >_>
23:21:52 <Cale> What are you trying to compute?
23:21:53 * hackagebot hack2-handler-happstack-server 2011.6.20 - Hack2 Happstack server handler  http://hackage.haskell.org/package/hack2-handler-happstack-server-2011.6.20 (JinjingWang)
23:22:14 <ivanm> Cale: generating all d-angulations of girth d with a specified number of vertices
23:23:05 * ivanm reads through the description of stirling numbers on wikipedia, and realises he's forgotten what cycles, etc. are and other related terminology :s
23:24:17 <Cale> What you're trying to enumerate sounds a lot harder to enumerate than the stuff that this paper is enumerating, unless there's some easy decomposition I'm not seeing.
23:24:41 <Cale> oh, blah, I'm looking at the wrong thing
23:24:45 <ivanm> heh
23:25:03 <ivanm> I was trying to work out what you were talking about :p
23:25:07 <ivanm> what were you reading?
23:25:42 <Cale> I'm not sure, I have way too much stuff open :{
23:26:16 <Cale> The bell numbers stuff was about g.f.ology
23:26:58 <ivanm> want me to give you the link that I was referring to again?
23:27:38 <Cale> I found the right thing now :)
23:27:42 <ivanm> heh
23:27:53 <Cale> So 6.1 Counting rooted d-angulations of girth d.
23:28:15 <ivanm> yup
23:28:48 <ivanm> crash course in what they're talking about:
23:28:58 <ivanm> a mobile is a tree composed of white and black nodes
23:29:30 <ivanm> black nodes have either edges to white nodes, or trailing half-edges called buds, and apart from the marked leaf have d of these edges/buds
23:31:13 <edwardk> falling asleep on you, sorry ivanm.
23:31:22 <edwardk> going to go catch a few zs
23:31:44 <ivanm> a white node has full edges from black nodes (with in-degree 1) and fractional edges (that is two directed edges pointed in opposite directions, sum of indegrees of two directions is 1) with indegree i < 1; total in-degree of d/(d-2)
23:31:50 <ivanm> edwardk: heh, thanks anyway
23:31:58 <ivanm> I should be heading off home soon-ish anyway...
23:32:54 <rata_> thank you all guys
23:32:58 <rata_> see you
23:34:25 <Cale> ivanm: So you're trying to take these generating series expansions, and run the decompositions which constructed them in reverse to recover the actual set of d-angulations?
23:34:34 <ivanm> right, and I've done that
23:34:36 <ivanm> and it's slow
23:34:40 <Cale> nice
23:34:47 <Cale> well, not the part about it being slow
23:35:01 <ivanm> AFAICT, the major reason it's so slow is that a lot of time is spent looking at invalid (i,w,b) triples
23:35:40 <ivanm> where w = number of white nodes to have in that mobile, etc.
23:36:04 <Cale> Yeah, the funny thing about combinatorics is that the algorithmic complexity of the generating series expansions for things are rarely discussed.
23:36:20 <ivanm> so my supervisor suggested I use those generating functions to work out which (i,b) values are valid, and I converted those GFs to work out which (i,w) are valid, but figured I might as well make a bivariate GF to check for valid triples
23:38:29 <ivanm> so my plan is to compute enough of the various GFs for the specified d up to the overall number of required white and black nodes until a stable solution is reached
23:38:39 <ivanm> just trying to work out how to do so now...
23:39:25 <ivanm> specifically, how to do the fixed point bit
23:39:49 <ivanm> I figure I need to do a Polynomial -> [[Int]] or something
23:40:00 <ivanm> anyway, time to go home and have dinner
23:40:33 <Cale> Interesting
23:40:39 <Cale> see you around
23:41:03 <ivanm> Cale: oh, did you happen to look through my planar graph API?
23:41:14 <Cale> I think I did
23:41:19 <Cale> eventually :)
23:41:27 <ivanm> heh
23:41:29 <ivanm> what did you think?
23:41:35 <Cale> The first time you linked me to something where the site was down
23:41:49 <Cale> I don't remember having any objections to it :)
23:41:54 <ivanm> oh, I think I changed the URL because I accidentally got it mixed up with the darcs repo
23:43:06 <ivanm> copumpkin suggested I find some way of hiding the inverse edges, but I don't think that'll work in practice (as they're useful in practice, and some re-ordering functions may not preserve the "even is real, odd is edge" convention that happens to be true atm)
23:43:47 <ivanm> I need to write some re-labeling functions and some proper serialisation/deserialisation support (have a hacky planar_code implementation atm) then I'll release it
23:43:52 <ivanm> anyway, I'm off
23:58:00 <juhp> no small haskell-platform-2011.2.0.1.tar.gz I guess?
