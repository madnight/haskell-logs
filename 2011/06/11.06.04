00:02:53 <blackdog> so, any haskellers doing the codejam tonight?
00:05:51 <AtnNn> blackdog: I am
00:06:36 <blackdog> AtnNn: good stuff. reckon you'll do it in haskell?
00:06:43 <AtnNn> yes
00:07:03 <blackdog> i always intend to do it in haskell, but it's occasionally easier to hack it up
00:07:10 <blackdog> still, last round was two haskell programs
00:08:16 <AtnNn> http://code.atnnn.com/projects/codejam/repository/show/2011
00:15:16 <blackdog> AtnNn: was that freecell solution fast enough for the big input?
00:15:38 <blackdog> i got paranoid and started bringing in number theory... prime factors of 100 and whatnot
00:16:07 <AtnNn> yes, it ran very fast
00:17:38 <AtnNn> solve is O(1)
00:18:38 <AtnNn> what did you try instead?
00:19:22 <fragamus> what is cabal install world
00:19:25 <blackdog> solve there is O(n), isn't it?
00:19:59 <blackdog> because you do construct the list [1..n]
00:20:19 <AtnNn> only if n < 100
00:20:40 <AtnNn> and n usually >> 100
00:21:12 <blackdog> oh, right. hm. how does that logic work then?
00:22:02 <blackdog> minus the parsing code, i had https://gist.github.com/1007703
00:23:47 <AtnNn> iirc, if n > 100 then d can be 100 and any P_D is possible
00:26:20 <mornfall> Well, O(n) when n < 100 is O(1) :)
00:27:30 <AtnNn> mornfall: exactly! I would tell my teachers the same thing about n < 2^32
00:27:35 <blackdog> AtnNn: oh, damn. i totally missed that insight.
00:27:38 <Jafet> Not O(100)??
00:27:45 <mornfall> Jafet: Same thing.
00:27:50 <mornfall> O(100) = O(1)
00:27:55 <mornfall> That's the whole point of O, afterall.
00:28:00 <mornfall> AtnNn: :)
00:28:04 <blackdog> for instance, completely solving chess is an O(1) problem.
00:28:06 <Jafet> Clearly the RHS has a bigger-O
00:28:28 <mornfall> AtnNn: If you bring 2^32 in as a fundamental limit, you can as well treat your computer as a DFA.
00:28:35 <Jafet> > let (!a, !b) = (0, a + 1) in (a, b)
00:28:38 <lambdabot>   mueval-core: Time limit exceeded
00:28:43 <mornfall> And not bother with complexity at all. ;)
00:29:15 <blackdog> tibbe: i told you the rubyists broke the hell out of barley?
00:29:27 <blackdog> managed to extract a bus error...
00:29:33 <mornfall> Jafet: Big O eats constants for breakfast. No matter how big. :)
00:29:37 <tibbe> blackdog: interesting :)
00:29:47 <tibbe> blackdog: perhaps in Snap (the underlying web server)
00:30:02 <tibbe> blackdog: I'm afraid I haven't been able to contribute to barley the last few months
00:30:08 <tibbe> blackdog: you should report it to mzero
00:30:14 <tibbe> (Maek)
00:30:17 <tibbe> Mark*
00:30:22 <blackdog> yep, have already
00:30:30 <blackdog> https://github.com/harvinius/barley-breakdown :)
00:30:32 <tibbe> thanks
00:30:38 <tibbe> I'm afraid I have to run
00:34:47 <lpsmith> a haskell program is a turing machine though
00:35:03 <lpsmith> it' just gets approximated by a rediculously large DFA
00:37:15 <AtnNn> it's rediculously large, but it fits in my pocket
00:37:22 <mornfall> blackdog: You can probably think of a way to generalise chess.
00:37:54 <blackdog> mornfall: true. just making the point that O(1) problems can be hell of hard.
00:37:56 <mornfall> AtnNn: It wouldn't if you printed it out in the cicrles and arcs format. :)
00:38:24 <mornfall> blackdog: Of course. It can be arbitrarily hard, too.
00:39:13 <AtnNn> I find go less arbitrary and easier to generalise
00:41:24 <mornfall> The first googol^(googol^googol) primes is even less arbitrary, and prolly much harder, problem that lives in O(1).
00:41:52 <mornfall> You can build a googol tower as high as you please.
00:42:40 <mornfall> You can invoke Ackermann.
00:52:18 <lpsmith> Why isn't the namespace for typeclasses distinct from the namespace for types?
00:53:07 <lpsmith> A minor annoyance,  but one that's bothered me for a long time
01:23:01 * hackagebot json-builder 0.1.0 - Data structure agnostic JSON serialization  http://hackage.haskell.org/package/json-builder-0.1.0 (LeonSmith)
01:50:09 <vdab> can someone explain the question posed here: http://www.haskell.org/pipermail/beginners/2011-February/006425.html
01:50:17 <vdab> it's basically saying how
01:50:26 <vdab> state is recognized as a constructor
01:50:31 <vdab> but "State" is not
01:51:59 <mjk> I want to install gtk2hs on my pc(Win XP sp3, haskell plotform 2011.2.0.1, gtk+ has been installed on my pc), but can't do, why?
01:54:17 <mjk> gtk2hs error: <built-in>:0:4: lexical error (UTF-8 decoding error)
01:54:25 <mjk> can anyone help me?
01:54:48 <mjk> Chinese Win XP
01:57:41 <Philonous> vdab: Apparently he had a function "state" in scope, but the constructor "State" (with uppercase S) was not
02:00:00 <vdab> Philonous: I don't understand how State is not in scope when Control.Monad.State is imported
02:02:19 <silver> may be it isn't exported in the Control.Monad.State
02:04:28 <Philonous> vdab: The State Monad seems to be realised as a Transformer over Identity now, so instead of State  you'd use (StateT . (Identity .) )
02:04:36 <ion> http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/src/Control-Monad-Trans-State-Lazy.html#state
02:06:16 <Philonous> vdab: My guess is, that's what state does.
02:09:58 <Philonous> Oh, somehow I managed to ignore ion's link, so zes, that's exactly what state is.
02:10:06 <Philonous> yes*
02:26:53 <nanomad> Forgive the noob question, how can i "print" an IO [String] ?
02:27:13 <sipa> you can't
02:27:13 <ion> print =<< [it]
02:27:20 <nanomad> ion, ty
02:27:20 <ion> print =<< it, that is
02:27:32 <sipa> :t it
02:27:33 <lambdabot> Not in scope: `it'
02:27:40 <Veinor> or if you're in the IO monad, print
02:27:48 <ion> print =<< return ["foo", "bar"]
02:28:13 <Jafet> Do you really want to print an IO [String]? Most people just want to print a [String].
02:28:17 <nanomad> I keep forgetting the "drop" operator
02:28:21 <Jafet> > return [""]
02:28:22 <lambdabot>   No instance for (GHC.Show.Show (m [[GHC.Types.Char]]))
02:28:22 <lambdabot>    arising from a us...
02:28:28 <Jafet> > return [""] :: IO [String]
02:28:28 <lambdabot>   <IO [[Char]]>
02:28:51 <nanomad> Well, I've got a function that reads from file a bunch of strings, so for debug i would like to print them
02:29:30 <Jafet> do strings <- iostrings; print strings;
02:29:52 <sipa> an IO String is a "program" that calculates a list ofStrings
02:30:10 <sipa> you don't want to print this program
02:30:22 <sipa> + []
02:30:48 <ion> :t (>>=)
02:30:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:30:59 <ion> In this case, IO a -> (a -> IO b) -> IO b
02:31:13 <ion> or, IO [String] -> ([String] -> IO ()) -> IO ()
02:31:37 <ion> You have an action that results in a list of string and you have another action that would take a list of strings such as
02:31:41 <ion> :t print
02:31:42 <lambdabot> forall a. (Show a) => a -> IO ()
02:32:08 <nanomad> exactly
02:32:18 <ion> You can combine them into a new action with iostrings >>= print, or print =<< iostrings, or do iostrings <- action; print iostrings
02:32:45 <nanomad> so using =<< is the right way
02:36:04 <ion> Again, a brainfart. I should have said: do strings <- iostrings; print strings
02:36:14 <ion> where iostrings :: IO [String] and strings :: [String]
03:12:18 <Tasser> can I define functions inside ghci?
03:13:35 <Jafet> Yes.
03:13:57 <Tasser> Prelude> fib 1 = 1
03:14:00 <Tasser> <interactive>:1:7: parse error on input `='
03:14:30 <Jafet> You should pretend that ghci exists inside a do-syntax block.
03:14:41 <serras> you should do something like
03:14:52 <serras> fib = \x -> case x of ...
03:14:52 <Jafet> Thus normally you use a let-binding
03:15:30 <Jafet> > let { fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2); } in map fib [1..10]
03:15:31 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
03:16:11 <Tasser> wow. oke
03:19:02 * roconnor wishes double was part of Num
03:19:41 <Jafet> > [1 :: Double, 1 :: Num a => a]
03:19:42 <lambdabot>   [1.0,1.0]
03:19:43 <roconnor> actually
03:19:52 <roconnor> heh
03:19:57 <roconnor> I mean double x = x*x
03:20:05 <Tasser> > fib = 0 : 1 : zipWith fib (tail fib)
03:20:06 <lambdabot>   <no location info>: parse error on input `='
03:20:11 <roconnor> maybe I wish it were part of Monoid.
03:20:22 <Tasser> > let { fib = 0 : 1 : zipWith fib (tail fib) }
03:20:23 <lambdabot>   not an expression: `let { fib = 0 : 1 : zipWith fib (tail fib) }'
03:20:27 <Tasser> hm.
03:20:29 <Jafet> That's normally written x+x.
03:20:30 <roconnor> so that we could have a fast ^ operation on monoids
03:20:34 <roconnor> er yes
03:20:36 <roconnor> x+x
03:20:43 <roconnor> how about mappend x x
03:20:52 <b0fh_ua> Hi! Can somebody please explain how to get i-th inversion table (in lexicographical order) for given set of items? I implemented rebuilding of permutation by it's table in Haskell, however not sure that I understand how to get for example 100-th of permutation
03:21:26 <b0fh_ua> 100-th inversion table I meant
03:21:51 <Xethron> Message from Anonymous - A99 OpESR - http://goo.gl/2oat4
03:22:03 <Jafet> > let mtimes a 0 = mempty; mtimes a 1 = a; mtimes a n | even n = join mappend (mtimes a (div n 2)) | odd n = mappend (mtimes a (n-1)) a; in mtimes "abc" 5
03:22:03 <lambdabot>   "abcabcabcabcabc"
03:22:28 <Jafet> > let mtimes a 0 = mempty; mtimes a 1 = a; mtimes a n | even n = join mappend (mtimes a (div n 2)) | odd n = mappend (mtimes a (n-1)) a; in mtimes succ 1000 0
03:22:29 <Tasser> what's the syntax problem with  http://sprunge.us/CcgQ
03:22:29 <lambdabot>   Ambiguous type variable `a' in the constraints:
03:22:29 <lambdabot>    `Data.Monoid.Monoid a'
03:22:29 <lambdabot>  ...
03:22:41 <Jafet> Perhaps not
03:23:17 <Jafet> Tasser: doesn't look like a syntax problem
03:23:29 <Jafet> Tasser: check the type of zipWith.
03:26:19 <Tasser> where's the documentation you usually use?
03:27:45 <Tasser> oh.
03:28:34 <Jafet> Mine? It's at http://localhost/home/jafet/.cabal/share/doc/
03:30:32 <Jafet> @google haskell hierarchial libraries
03:30:33 <lambdabot> http://www.haskell.org/ghc/docs/7.0.3/html/libraries/
03:30:34 <lambdabot> Title: Haskell Hierarchical Libraries
03:31:08 <Tasser> :-)
04:08:41 <kingping> printStrLn "hello"
04:10:23 <Twey> putStrLn
04:10:25 <k0ral> putStrLn*
04:10:30 <Twey> And hi ;)
04:18:06 <ion> Is there a shorter/prettier way to do join $ foo <$> bar <*> baz, or join (liftM2 foo bar baz), or do a <- bar; b <- baz; foo a b?
04:18:33 <Veinor> @pl \foo bar -> do {a <- bar; b <- baz; foo ab }
04:18:33 <lambdabot> (line 1, column 16):
04:18:33 <lambdabot> unexpected "{"
04:18:33 <lambdabot> expecting variable, "(", operator or end of input
04:19:01 <Jafet> ion: if you write it
04:19:02 <Veinor> @pl \bar baz -> join $ foo <$> bar <*> baz
04:19:02 <lambdabot> ((join . (foo <$>)) .) . (<*>)
04:19:13 <Jafet> That's pretty short by itself
04:19:15 <parcs> @src liftM2
04:19:15 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
04:19:41 <Veinor> i feel like there is a shorter way to do it though
04:20:38 <Jafet> If foo, bar and baz are large, I tend to use comprehension syntax
04:20:41 <Jafet> Better layout
04:21:16 <Veinor> @hoogle (a -> b -> c) -> m a -> m b -> m c
04:21:16 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:21:16 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
04:21:16 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
04:21:24 <Veinor> @hoogle (a -> b -> m c) -> m a -> m b -> m c
04:21:24 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
04:21:24 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
04:21:24 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
04:22:17 <nanomad> Is there anything equivalent to map/filter for arrays?
04:22:29 <Jafet> :t \foo bar baz -> join $ liftM2 foo bar baz
04:22:29 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
04:22:55 <Jafet> nanomad: what kind of array?
04:23:08 <nanomad> UArray
04:23:43 <nanomad> actually, forget filter, i do not need it (beside it would be pointless with arrays)
04:24:04 <Jafet> Just use elems and arrayList.
04:24:23 <Jafet> Or it might be listArray.
04:25:34 <nanomad> Jafet, tha'ts arrayList
04:25:50 <nanomad> err..listArray
04:26:10 <Veinor> nanomad: amap?
04:27:37 <mjk> can gtk2hs install on haskell platform 2011.2.0.1?
04:28:32 <nanomad> mjk, yes
04:29:22 <nanomad> ghc-pkg list | grep gtk
04:29:22 <nanomad>     gtk-0.12.0
04:29:22 <nanomad>     gtksourceview2-0.12.2
04:29:38 <mjk> nanomad: but when I execute "cabal install gtk2hs-buildtools", it will give error:"<built-in>:0:4: lexical error (UTF-8 decoding error)"
04:30:09 <mjk> my pc: Chinese WinXP sp3
04:30:20 <nanomad> mjk, that's might be it. I'm on linux
04:30:43 <mjk> oh
04:31:06 <nanomad> mjk, i just recompiled it to be sure and it worked
04:31:27 <mjk> need recompile it?
04:31:54 <mjk> nanomad: I have installed gtk+ on my machine
04:35:36 <nanomad> mjk, did u follow this guide: http://www.haskell.org/haskellwiki/Leksah_Installation
04:36:41 <kingping> Here, http://learnyouahaskell.com/for-a-few-monads-more, is said that ((((a ++ b) ++ c) ++ d) ++ e) ++ f associates to the left, instead of to the right and that "This is inefficient because every time it wants to add the right part to the left part, it has to construct the left part all the way from the beginning!"
04:36:47 <kingping> Here's my guess: it's more expensive to append growing list to the short ones every time until the resulting list is constructed, i. e. ((((a ++ b) ++ c) ++ d) ++ e) ++ f works from the right, stargin off from ef, than returning def, than cdef until we get abcdef as its result.
04:36:55 <mjk> nanomad: I refer to http://code.haskell.org/gtk2hs/INSTALL
04:37:33 <mjk> and i will visit the website that you said
04:38:48 <nanomad> mjk, maybe you will only need the step that says install utf-8
04:38:52 <nanomad> mjk, but IDK
04:39:28 <mjk> nanomad: maybe
04:39:39 <mjk> nanomad: i will try it
04:43:47 <k0ral> is it a good habit to list only the needed elements of a module one imports instead of just importing the whole module ?
04:44:07 <k0ral> will it change the final size of the executable/library ?
04:44:57 <adnam> i think it's good, that way it's easier to see where an imported item comes from
04:45:48 <k0ral> how about my second question ?
04:47:25 <adnam> i'm not sure, should be easy to test
05:01:04 <Tasser> is there something like 'last eval result' in ghci?
05:01:47 <ezyang> it.
05:02:41 <ezyang> (as in, the variable named 'it')
05:04:26 <McManiaC> http://hpaste.org/47425/recordvalues__donotation if that isn't lovely…
05:04:27 <McManiaC> :D
05:05:11 <Tasser> ezyang, oh, thanks
05:06:07 <ezyang> heh, classy.
05:06:44 <scree> k0ral: btw http://hackage.haskell.org/trac/ghc/wiki/Commentary/CodingStyle for example disagrees with adnam
05:23:33 <Tasser> what's the difference between fromIntegral :: (Num b, Integral a) => a -> b and fromIntegral :: Integral -> Num ?
05:24:39 <Jafet> Tasser: Integral is not a type. It is a type class.
05:24:59 <Jafet> Integer is a type, which is an instance of Integral.
05:25:05 <Jafet> @where lyah
05:25:05 <lambdabot> http://www.learnyouahaskell.com/
05:25:14 <Tasser> so it's a design decision?
05:26:16 <Jafet> Do you have alternatives in mind?
05:27:13 <Tasser> Why not use the same Syntax for types and typeclasses?
05:28:47 <Silvah> Tasser: why use the same syntax for types and typeclasses?
05:29:48 <Tasser> because imo typeclasses are just another pattern you can match against
05:29:51 <Jafet> Hmm, here's a type signature I wrote recently
05:29:57 <Jafet> sp :: forall a id w s. (Show a, Ord id, Ix id, Num id, Num w, Ord w, MArray (STArray s) (Maybe (w, id)) (ST s), MArray (STArray s) Bool (ST s)) => Graph id a w -> (Node id a w -> Node id a w -> Maybe w) -> Array (id, id) (Maybe (w, id))
05:30:18 <Jafet> Type classes are not types. Sometimes you'll see them called contexts or constraints.
05:31:05 <parcs> Tasser: using your notation, how can you differentiate between a function (Num a, Num b) => a -> b and Num a => a -> a ?
05:31:14 <Silvah> Jafet: woah, nice type sig.
05:32:10 <Tasser> parcs, hm, oke.
05:52:29 <tokyo534> http://sexier.com/services/directlinkhandler.ashx?WID=125269233270&LinkID=1080&promocode=BCODEL0000021_opera&cid=8
05:52:29 <tokyo534> 			
05:53:46 <Cale> tokyo534: wtf dude
05:54:03 <Zao> I'll pass.
05:54:08 --- mode: ChanServ set +o Cale
05:54:14 <Jafet> Who needs that when we have lambdabot
05:54:15 --- mode: Cale set +b *!*@79.100.251.47
05:54:15 --- kick: tokyo534 was kicked by Cale (tokyo534)
05:54:17 <Zao> Especially as the URL includes some kind of Opera promo code.
05:54:19 --- mode: Cale set -o Cale
05:54:51 <Jafet> @vixen do you strip before executing?
05:54:51 <lambdabot> maybe. do you?
06:07:31 <nodetree> hi
06:08:03 <ok7> i need some help with the first line of this code: http://hpaste.org/47429/test
06:08:18 <ok7> zipwith should take 3 arguments
06:08:32 <ok7> i see (++) and one argument after it
06:08:47 <ok7> i dont understand it
06:09:58 <dbpatterson> what is the error?
06:10:07 <ok7> no error
06:10:09 <ok7> this code works
06:10:15 <Twey> ok7: It's not fully applied
06:10:21 <Jafet> ok7: actually, all functions in Haskell have one argument!
06:11:10 <Jafet> (f x y) applies f to x to produce a function, which gets applied to y.
06:11:34 <ok7> okk.. which is the input I guess
06:11:46 <dbpatterson> ok7: the third argument is the result of applying the rest of the line (basically)
06:12:15 <ok7> the third argument is the input. am i right?
06:12:59 <Jafet> There, interact indirectly supplies the last parameter.
06:13:02 <ok7> FYI: this is someone's code for google code jam qualifier problem
06:13:31 <ok7> thanks Jafet
06:13:32 <dbpatterson> ok7: well, there is a whole chain of functions that are composed (that's the . ) - so first lines is called, then tail, then that map, and then your partially applied (that is missing one argument, so takes one argument) zipWith function
06:14:29 <Twey> ok7: Imagine the argument being pushed onto the end and ‘shunting’ all the functions back into one another.  (f . g . h) x → (f . g) (h x) → f (g (h x))
06:14:53 <Twey> The only difference is that in this case ‘f’ is created by applying a function to another argument
06:15:17 <Twey> Or two, actually
06:15:27 <Twey> So it's (f a b . g . h) x → (f a b . g) (h x) → f a b (g (h x))
06:15:41 <Twey> So you can see that when fully applied, f gets all three of its arguments
06:15:54 <dbpatterson> Twey: nice arrows :)
06:16:00 <Twey> Thank you
06:16:32 <Jafet> ok7, here is a more "traditional" way to write the same code: http://hpaste.org/paste/47429/test_annotation#p47430
06:19:42 <theorbtwo> Sadly, those arrows aren't actually valid haskell.
06:19:54 <Twey> They are with -XUnicodeSyntax
06:20:02 <theorbtwo> Though, I suppose, one can define a (→) (->)
06:20:13 <theorbtwo> Twey: Oh, cool, didn't know you could do that.
06:20:14 <Jafet> Type operators can't be infix
06:20:30 <Jafet> Not sure if there's an extension for that
06:20:47 <theorbtwo> Jafet: Hm.  Interesting.
06:20:49 <Twey> -XInfixTypeOperators
06:20:50 <Twey> :þ
06:20:53 <Twey> But they must start with :
06:21:02 <ok7> I also want to know how the $ after the interact makes a difference
06:21:05 <Twey> → is special-cased by -XUnicodeSyntax
06:21:06 <Jafet> Function arrows are magic there
06:21:10 <ok7> i know it delays function aplication
06:21:11 <Twey> Yeah
06:21:22 <Twey> ok7: It's just a trick to avoid bracketing stuff
06:21:23 <ok7> what does it mean for interact
06:21:32 <Twey> foo $ bar ≈ (foo) (bar)
06:21:50 <Jafet> ok7: the entire right side of the $ is a function, which is given as a parameter to interact. See my rewritten version.
06:22:54 <ok7> hmmm
06:22:57 <ok7> thanks!!
06:23:17 <Jafet> Also, diving into people's competition golf courses like this is probably not the best way to learn Haskell... perhaps you want to start with a text
06:23:18 <Twey> Sorry, it's not -XInfixTypeOperators, just -XTypeOperators
06:23:34 <Jafet> @hoogle (:->)
06:23:35 <lambdabot> No results found
06:23:38 <ok7> a text??
06:23:41 <ok7> ok
06:23:43 <Twey> @where rwh
06:23:43 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
06:23:45 <ok7> u mean textbook
06:23:46 <Twey> Like this one
06:23:49 <Twey> @where lyah
06:23:49 <lambdabot> http://www.learnyouahaskell.com/
06:23:51 <Twey> Or that one
06:23:59 <ok7> i am reading www.learnyouahaskell.com
06:24:06 <ok7> ya
06:24:06 <Twey> Good-ho
06:24:12 <ok7> :)
06:25:21 <ok7> Jafet: I had solved that problem myself.. so I'm trying to see how it is solved with Haskell.. That's helpful i think
06:28:39 <handygandy> Is there a way I can download all the issues of monad reader at one time?
06:30:22 <Jafet> All the ones published so far, you mean?
06:30:42 <handygandy> Jafet: Yes.
06:32:19 <Jafet> Most of them seem to be linked here http://www.haskell.org/haskellwiki/The_Monad.Reader/Previous_issues
06:44:35 <blackdog> AtnNn: Good luck!
06:51:17 <dbpatterson> is there a function f such that f [\_ → "b",\_ → "c"] ["a", "a"] would be ["b","c"]? ie, f :: [a→b] → [a] → [b], where it applies each function in turn?
06:52:04 <basti_> i think so.
06:52:56 <osfameron> map ($.) or somesuch?
06:55:43 <hpc> :t scanl succ
06:55:43 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
06:55:44 <lambdabot>     Probable cause: `succ' is applied to too many arguments
06:55:44 <lambdabot>     In the first argument of `scanl', namely `succ'
06:55:47 <hpc> :t scanl
06:55:48 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
06:56:03 <dbpatterson> @type map (($) .)
06:56:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => [f (a -> b)] -> [f (a -> b)]
06:56:34 <hpc> that would be id
06:56:41 <dbpatterson> yeah.
06:58:32 <hpc> @hoogle (a -> a) -> a -> [a]
06:58:33 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
06:58:33 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
06:58:33 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
06:59:10 <hpc> @let foo = iterate (succ .) id 'a'
06:59:10 <lambdabot>  <local>:8:6:
06:59:10 <lambdabot>      Couldn't match expected type `Char -> t'
06:59:10 <lambdabot>             again...
06:59:22 <hpc> :t iterate (succ .) id
06:59:23 <lambdabot> forall a. (Enum a) => [a -> a]
06:59:54 <hpc> > zipWith ($) (iterate (succ .) id) ['a','a']
06:59:56 <lambdabot>   "ab"
07:00:08 <hpc> > zipWith ($) (tail $ iterate (succ .) id) ['a','a']
07:00:09 <lambdabot>   "bc"
07:00:18 <Twey> Haha, I just banner-blindness'd the HaskellWiki registration CAPTCHA.
07:00:18 <hpc> > zipWith ($) (tail $ iterate (succ .) id) "abcdefg"
07:00:20 <lambdabot>   "bdfhjln"
07:00:42 <dbpatterson> :t zipWith ($)
07:00:43 <lambdabot> forall b b1. [b -> b1] -> [b] -> [b1]
07:00:50 <dbpatterson> that'll work :)
07:01:08 <hpc> ah
07:01:36 <hpc> i thought you also wanted something that would turn "aa" into "bc" :P
07:05:38 <dbpatterson> haha, no, simpler than that. I just wanted to apply a bunch of different functions to the same thing. so zipWith ($) listOFuncs $ repeat myObj works
07:06:59 <Jafet> map ($x) fs
07:07:16 <hpc> or that
07:07:24 <hpc> :t \fs x -> map ($ x) fs
07:07:25 <lambdabot> forall a b. [a -> b] -> a -> [b]
07:07:31 <hpc> :t flip
07:07:32 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
07:07:46 <Jafet> No, no!
07:09:59 <dbpatterson> hmm, that is simpler. :)
07:18:49 <Twey> > zipWith ($) (iterate (succ .) succ) "aaaaaa"
07:18:51 <lambdabot>   "bcdefg"
07:21:06 <rtharper> is there a way to make criterion out benchmarks in a table/csv/something I don't have to manually copy/paste into a table? =p
07:21:25 <kingping> Why (\xs -> (["0"]++) (["1"]++xs)) ((\xs->["2"]++xs) []) is more effective than ((["0"]) ++ ["1"]) ++ ["2"] ?
07:22:02 <Twey> What… is that?
07:22:28 <Jafet> rtharper: write a program using the criterion library that does that?
07:22:47 <Twey> Did you mean to write: ["0", "1", "2"]?  >.>
07:22:53 <rtharper> Jafet: weren't you a troll in wowuidev?
07:23:11 <Jafet> What
07:23:13 <kingping> Twey: That was a continuation of my previous question on difference lists.
07:23:23 <Twey> Ah
07:23:33 <kingping> Twey: Which are described here http://learnyouahaskell.com/for-a-few-monads-more
07:23:34 <rtharper> Jafet: sorry, might be thnking of someone else
07:24:05 <rtharper> ah yes, I definitely was, sorry about that, Jafet ;)
07:24:08 <Jafet> I don't think I want to be associated with WoW or UI dev, or both
07:24:21 <Jafet> Even as a troll
07:26:26 <Jafet> kingping: due to the structure of lists, (xs ++ ys) allocates (length xs) conses when you evaluate all of the list.
07:26:47 <Jafet> (Think a moment why that has to be true.)
07:27:02 <kingping> <-- stupid
07:27:05 <kingping> But let me think.
07:27:35 <Jafet> Keep in mind the (pseudo-Haskell) construction of a list: data [a] = [] | a : [a]
07:31:37 <ckop64> Hello, I'm a noobie, so please be easy on me. I'm using xmonad, and I'd like to run dmenu with some parameters, which is bound to super+p. where do I put the ` to make the parameters recognised?
07:32:21 <ezyang> ckop64: Try #xmonad; you're more likely to get a good answer there.
07:32:42 <ckop64> here is the relevant part of my xmonad.hs: http://pastebin.com/PXVjTXgq
07:32:45 <mauke> The paste PXVjTXgq has been copied to http://hpaste.org/47432/httppastebincompxvjtxgq
07:33:00 <ckop64> ezyang: I'll check there.
07:35:12 <Jafet> kingping: hm, thought long enough?
07:35:41 <kingping> Jafet: :) Not sure, does it have to reevaluate the length each time it opens a bracket?
07:36:43 <Jafet> We call the structure of the list the spine, and it does have to re-evaluate that.
07:38:38 <kingping> Jafet: (Probably not going to understand what the spine is at the right moment) Does that mean it evaluates length 3 times while trying to evaluate ((["0"]) ++ ["1"]) ++ ["2"]  ?
07:39:21 <kingping> Once for X ++ ["2'], then for ["0"] ++ ["1"], finally for ["0","1"] ++ ["2"].
07:39:45 <Jafet> It doesn't need to evaluate ["2"] at all.
07:39:48 <Jafet> @src (++)
07:39:48 <lambdabot> []     ++ ys = ys
07:39:48 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
07:39:48 <lambdabot> -- OR
07:39:48 <lambdabot> xs ++ ys = foldr (:) ys xs
07:40:13 <Jafet> ys is never touched, but it has to evaluate all of xs.
07:40:52 <blackdog> where do i get showFFloat from?
07:41:37 <blackdog> oh, Numeric. duh.
07:43:06 <kingping> Jafet: So, if we're using difference lists, we somehow cheating, trying to avoid recalculating the length on each appending?
07:45:23 <Jafet> kingping, perhaps a trace is in order: http://hpaste.org/47434/difference_lists
07:45:50 <Jafet> trace (...) x just magically prints the first message, and then returns x.
07:48:41 <Jafet> And a more detailed trace: http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=%28%28%28[1]+%2B%2B+[2]%29+%2B%2B+[3]%29+%2B%2B+[4]%29+%2B%2B+[5]
07:49:37 <Jafet> Notice that the first element takes the most steps to "pull out", due to the nested calls to (++)
07:50:08 <aninhumer> Jafet: ucam.org host? guessing you are/were at Cambridge?
07:50:10 <kingping> Jafet: Thank you. I think I'm going to spend 3-10 days to get that all.
07:50:41 <Jafet> If I'd been at cambridge, I'd have much better things to do than hang around here all day
07:50:52 <Jafet> stepeval is by benmachine
07:51:03 <aninhumer> Oh I see
07:52:05 <aninhumer> Heh, I have better things to be doing than hanging around here, given it's exam term, and yet...
07:53:03 <ben> aw, it does not produce a humorous expansion of 'fix error'
07:54:36 <Jafet> Errors are impure!
07:56:04 <opqdonut> hmm, stepeval is a bit broken
07:56:13 <opqdonut> "let cycle xs = xs ++ cycle xs in take 3 (cycle (fix (1:)))
07:56:20 <opqdonut> " leaks a variable "x"
07:56:29 <applicative> hm stepeval only has prelude functions?  maybe foldl' would be good for illustration
07:58:04 <Jafet> I'm not sure if benmachine still works on it much
07:58:14 <opqdonut> okay, even "take 3 (fix (1:))" is broken :)
07:58:35 <opqdonut> yeah he might not
07:58:38 <Jafet> But yes, it's rather delicate
07:58:54 <Jafet> I could demonstrate via the ghci debugger, but I don't know how to use that myself
07:59:29 <opqdonut> the ghci debugger is powerful but there's something off in the way it represents the computation
08:01:48 <applicative> hm, the github repo was updated in january, no so long aho
08:01:50 <applicative> ago
08:02:47 <applicative> yipe, stepeval has lots of Data.Generics.
08:05:33 <kingping> Is 4:[2,1,3] much faster than [2,1,3] ++ [4] ?
08:06:20 <applicative> in that case, it could hardly be, but 4:[1..1000000] might be better than [1..10000000]++ [4]
08:06:32 <Peaker> kingping: ignoring some corner considerations (both are small enough that it doesn't matter, if they are constants they may be compiled to constants), yes.
08:06:45 <n00p> kingping: Is "The cat in the hat" much faster than "The hat on the cat"?
08:08:01 <opqdonut> kingping: actually, if it's just a _single_ (++) it doesn't matter. but repeatedly prepending is better than repeatedly appending
08:08:30 <Jafet> kingping: since Haskell is non-strict, the time it takes to compute a result usually depends on how much of the result you use.
08:09:47 <monochrom> traversing 4:[2,1,3] takes fewer steps than traversing [2,1,3] ++ [4]
08:10:07 <monochrom> indeed even if you only traverse a prefix of either
08:10:17 <Jafet> In a lisp, for example, 4:[2,1,3] is indeed faster (in the sense that it allocates less) than [2,1,3] ++ 4. This is because they use applicative-order evaluation (wow, a keyword) to reduce expressions to normal form (yay another keyword)
08:13:10 <kingping> While haskell uses call by need evaluation I guess.
08:13:25 <kingping> And allocates thunks or something..
08:13:43 <kingping> If no strict eval is being used.
08:13:45 <Jafet> Nope, Haskell uses call-by-name. But every practical implementation like GHC optimizes it to call-by-need.
08:16:21 <Jafet> Well, "call-by-name" can mean an evaluation strategy (as opposed to call-by-value) or an implementation of that strategy (which includes call-by-need)
08:16:31 <Jafet> I meant the former
08:16:47 <cwb> Is it a problem that the Error monad does not adhere to the  MonadPlus "laws" even though it is an instance of MonadPlus? What are the monadplus laws communicating if adherence to them isn't critical?
09:06:20 <robertosucks> http://www.pastie.org/2018817
09:06:32 <robertosucks> Why the first one equals the second one?
09:06:54 <robertosucks> by the way i am studing High Order Function by the Learn you Haskell
09:07:03 <shurane> okay, so "Learn You A Haskell for Great Good" feels a little slow for me; I think i've come across a lot of the ideas in the first few chapters. The cool thing I learned is about partially applied functions, but... is there another faster guide I could look at? Or does this one get faster?
09:11:26 <robertosucks> someone can help me please?
09:12:10 <zmv> shurane: Real World Haskell.
09:12:29 <zmv> shurane: it gets way faster imho
09:13:01 <shurane> robertosucks: I think that's related to partially applied functions. Have you looked at the signature for 'compare'?
09:13:19 <shurane> er, or currying.
09:14:24 <robertosucks> compare :: Ord a => a -> a -> Ordering
09:14:48 <robertosucks> receives two numbers and compare them
09:15:42 <blackdog> AtnNn: there?
09:18:17 <robertosucks> shurane, i did
09:19:40 <blackdog> AtnNn: think i managed a shirt - #991 :)
09:20:15 <shurane> yeah, but when you do 'compareWithHundred = compare 100', you've already given it one argument.
09:20:26 <shurane> I wouldn't be good enough to explain it, though...
09:20:55 <robertosucks> shurane, yes but i am not giving the second one
09:21:23 <shurane> yeah, so it's partially applied, right? now if you give it one more argument, it'll return something
09:23:11 <robertosucks> so if i do
09:23:26 <robertosucks> onemore :: Int -> Int
09:24:31 <robertosucks> onemore = plus a
09:24:54 <robertosucks> then ((onemore 1)1)
09:24:58 <robertosucks> will return 2 ?
09:25:27 <opqdonut> > let onemore = (+) 1 in (onemore 1)
09:25:28 <lambdabot>   2
09:25:33 <opqdonut> > let onemore = (+) 1 in (onemore (onemore 1))
09:25:34 <lambdabot>   3
09:25:47 <Zao> @type (+) 1
09:25:48 <lambdabot> forall t. (Num t) => t -> t
09:26:01 <Zao> robertosucks: Your code will not type check.
09:26:22 <Zao> let onemore = (+) 1 in (onemore 1) 1
09:26:37 <opqdonut> or did you mean something like "onemore a = (+) a" ?
09:27:00 <opqdonut> since then ((onemore 1) 1) == ((+) 1) 1 == (+) 1 1 == 2
09:27:07 <robertosucks> opqdonut, plus is a function that i write to sum 2 numbers
09:27:25 <opqdonut> yeah that function is actually called "(+)"
09:28:21 <robertosucks> ok
09:28:27 <robertosucks> so that will work?
09:28:28 <zmv> > let plus a b = a + b
09:28:29 <lambdabot>   not an expression: `let plus a b = a + b'
09:28:41 <zmv> crap
09:28:59 <opqdonut> @let plus = (+)
09:29:00 <lambdabot>  Defined.
09:29:20 <zmv> yeah
09:29:46 <arcatan> is there somewhere some tutorial/guide for cabal test?
09:34:52 <chridi> im trying to write a parser for vcards... just to get a bit further with haskell
09:35:20 <chridi> i did something like this: http://hpaste.org/47436/vcard_parser
09:35:28 <chridi> but i have the feeling i could do this better
09:36:29 <serras> chridi: from my experience, i've gained a lot of understanding of haskell by learning to use parsec
09:36:54 <serras> chridi: you could try to write the parser using that library
09:38:32 <blackdog> is there something better than "length . takeWhile ..." ?
09:38:46 <MasseR> I'm testing template haskell. I have defined something like foo x = let t = (return $ ConE (mkName x)) in [|bar (undefined :: $x)|]
09:38:59 <MasseR> And I'm trying to call foo from another module with a variable, but I get stage restriction errors
09:39:04 <MasseR> bar x = $(foo x)
09:39:08 <chridi> serras: looks like a nice parser generator.. thanks.. :)
09:39:56 <chridi> but i wonder if i could express this "add a letter to the head of this string and leaf the rest like it is" in a data somehow better
09:40:10 <MasseR> However, for example baz = $(foo "Int") works
09:40:46 <serras> chridi: you mean just to add a letter before the entire string?
09:41:39 <chridi> yes...  and just leave the rest like it is
09:41:58 <shurane> zmv, whoa the online version allows commenting per paragraph? so weird...
09:42:02 <shurane> useful too
09:42:15 <serras> chridi: strings are just list of chars, so you can just use  't' : rest_of_string
09:42:15 <companion_cube> what is Exception.block ? i have trouble finding recent documentation on exceptions...
09:42:35 <zmv> suiside: huh?
09:42:44 <chridi> serras: the problem is with this data types
09:43:01 <chridi> serras: http://hpaste.org/47436/vcard_parser here in line 51
09:43:27 <shurane> zmv: of real world haskell, that is
09:43:31 <chridi> ah.. 54
09:43:49 <chridi> aaaaah.. i meant shurane xD sry
09:44:06 <zmv> shurane: oic
09:44:11 <serras> chridi: i think i don't fully understand the question :(
09:44:20 <AtnNn> blackdog: I did not compete
09:46:22 <blackdog> AtnNn: oh. fair enough.
09:47:00 <blackdog> still bashing my brain out on an efficient solution to one of them... currently it involves computing primes up to about 500 billion, so i'm probably Doing It Wrong
09:47:12 <chridi> serras: okay... ill ask again later.. have to go xD
09:53:54 <roconnor> How do I use the UNPACK pragma?
09:54:39 <Saizan> data Foo = Bar {-# UNPACK #-} !Int ..
09:54:47 <roconnor> that's all
09:55:06 <Jafet> localhost/usr/local/share/doc/ghc/html/users_guide/pragmas.html#unpack-pragma
09:55:47 <roconnor> I don't have a /usr directory
09:56:30 <roconnor> I guess that made things a bit faster
09:57:10 <Jafet> Heh
09:57:10 <roconnor> does foldl' fuse with zipWith ?
09:57:31 <companion_cube> how can i just ignore an exception and continue as if it was never thrown ?
09:57:53 <roconnor> companion_cube: what sort of exception?
09:57:55 <Jafet> :t Control.Exception.catch
09:57:55 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> (e -> IO a) -> IO a
09:58:00 <companion_cube> any
09:58:12 <Jafet> That's a bad idea... but you can do it
09:58:15 <roconnor> > throw "test" :: Either String String
09:58:16 <lambdabot>   Not in scope: `throw'
09:58:29 <Jafet> > fail "test" :: Either String a
09:58:30 <lambdabot>   Overlapping instances for GHC.Base.Monad
09:58:30 <lambdabot>                              (Data...
09:58:39 <Jafet> @slap lambdabot
09:58:39 * lambdabot jabs lambdabot with a C pointer
09:59:48 <monochrom> you can catch any exception and handle it, but that is still not ignore or continue. there is no way
09:59:55 <roconnor> COST CENTRE                    MODULE               %time %alloc
09:59:56 <roconnor> shaStep                        SHA256                21.8   21.8
10:00:03 <roconnor> is it bad when the time is equal to the alloc?
10:00:45 <Jafet> For SHA-2 256, maybe.
10:01:12 <Jafet> Oh, he said continue
10:01:27 <Jafet> I don't know what it means to continue, so I suppose I just ignored that bit
10:02:31 <Jafet> The cryptohash package is as fast as it gets, but I think it uses C.
10:02:39 <monochrom> exception handling is more like "plan B" then "nothing to look, move along"
10:02:44 <monochrom> s/then/than/
10:03:21 <Jafet> Except no one in the room has a plan B, so they all look quietly at the floor and pass it along
10:03:30 <monochrom> heh
10:03:38 <Eelis> if i have something like   (foldl' f a x, foldl' g b x)  where x evaluates to some huge (but finite) list that i really don't want to have in memory all at once, is GHC smart enough to "merge" the folds?
10:04:02 <monochrom> no
10:04:05 <BMeph> Eelis: ...are you? ;
10:04:09 <roconnor> Do I have to switch to a stupid STArray for managing my hashing state?
10:04:30 <Eelis> BMeph: it seems pretty straightforward to write a variant of foldl' that keeps two accumulators, yeah
10:04:41 <Eelis> is that the usual solution?
10:04:45 <monochrom> yes
10:04:50 <Eelis> ugh. very well. thanks
10:05:18 <Jafet> Eelis: someone suggested `par` but I tried it and it didn't seem to work
10:05:27 <Eelis> Jafet: i think that's totally different
10:05:27 <Jafet> But you could still try it
10:05:57 <applicative> Eelis, 'x' is the same in both?
10:06:06 <Jafet> In the ideal hippy love world, evaluating them would let x be GCed. Or one would think
10:06:08 <Eelis> applicative: yeah, it's a variable bound to the big list
10:06:12 <monochrom> if you par and you +RTS -N and the timing is right and the planets align and ... then it may work out
10:06:56 <blackdog> Eelis: i think that would be semantically bogus anyway. if f converged and g didn't, and you only looked at the first element of the tuple, making the transformation you suggest would make a previously converging expression diverge.
10:07:31 <BMeph> Eelis: Think of it this way: f (g x z) (g y z) has to be "broken down" at least twice before you get pieces that could be relatable. It's possible, but it isn't the usual routine.
10:07:51 <Eelis> blackdog: hmm
10:08:51 <Jafet> roconnor: stupid? Seems natural, given that the hash functions are all specified that way
10:09:13 <Jafet> Probably STUArray ... Word32, too
10:09:30 <Eelis> BMeph: i don't see why you're applying f to the result of g there
10:09:49 <Jafet> Or if the state is small enough that you can just pass around a ton of parameters in a tuple
10:10:03 <Jafet> And let ghc unbox it
10:10:11 <monochrom> probably BMeph's f is Eelis's (,) and BMeph's g is Eelis's foldl'
10:10:21 <Eelis> oh...
10:10:56 <monochrom> this is why we should all use de Bruijn numbering to talk to each other
10:11:24 <Eelis> not needlessly using the same variable names would go a long way ;)
10:11:42 <Eelis> (i also had an f and a g)
10:14:28 <roconnor> Jafet: I'd rather use foldl'
10:14:44 <applicative> not sure how to make a memorable quote from "M?colleague Bob Atkey once memorably described the capacity to put up with de Bruijn indices as a Cylon detector, the kind of reverse Turing Test that the humans in Battlestar Galactica invent, the better to recognize one another by their common inadequacies."
10:15:37 <roconnor> Jafet: why can't foldl' work?
10:15:57 <Jafet> roconnor: er, work for what? I don't know how you're implementing it.
10:16:26 <jaspervdj> preflex: seen chrisdone
10:16:26 <preflex>  chrisdone was last seen on #haskell 1 day, 20 hours, 37 minutes and 23 seconds ago, saying: ddarius: Good idea, I've never looked at the Intel manuals.
10:17:24 <roconnor> Jafet: http://hpaste.org/47438/shastep
10:18:01 <applicative> let gf (x,y) z = (g x z, f y x) then foldl' that?
10:18:29 <Jafet> It seems that Eelis wants to avoid that
10:18:44 <applicative> Jafet, why?
10:19:05 <Jafet> Dunno, ask him (if so)
10:19:10 <applicative> it would accept the giant list lazily, i would think
10:20:27 <applicative> Eelis: what are the types of f and g?
10:21:15 <applicative> or maybe this was a question of principle, not a particular problem
10:21:30 <Jafet> He wants magic; don't we all?
10:21:42 <applicative> foldl' is better than magic
10:22:20 <Jafet> roconnor: any time you deal with lists like that -> allocation, loads of allocation
10:22:38 <roconnor> the lists ought to be fused away
10:22:59 <roconnor> afterall, lists is just a nice way of writing a for loop, isn't it?
10:23:04 <Jafet> Notice that you're doing m++.. on every iteration
10:23:43 <applicative> it might be better to make a strict pair type for eelis' problem
10:23:47 <Jafet> And in each of them you drop from m four times
10:23:56 <roconnor> Jafet: I think you are misreading that
10:24:06 <roconnor> ws goes into the zipWith
10:24:18 <roconnor> it is half the contents of the list being folded
10:24:26 <Jafet> That doesn't get "fused" away, nothing makes it get "fused" away
10:25:01 <roconnor> but since ws is circularly defined, I can see why it has trouble being fused away ...
10:25:22 <roconnor> ... but the code is so elegant like that.
10:25:23 <thoughtpolice> whoa! since when did hpaste get the power of hlint?
10:25:25 <Jafet> The fact is that (++) rebuilds m, by walking through parts of it four times, and then tacks something on to it
10:25:26 <thoughtpolice> that's awesome
10:25:39 <Jafet> That is... not good for performance.
10:25:40 <roconnor> Jafet: again, ++ isn't execute each loop
10:25:52 <Peaker> Jafet: 4 times?
10:26:05 <roconnor> foldl' f h (m ++ foo) doesn't execute ++ per loop
10:26:15 <Jafet> It executes per shaStep?
10:26:37 <roconnor> true
10:26:45 <roconnor> I guess I could lift that away.
10:27:28 <Jafet> You originally asked for foldl'/zipWith – I don't know about that, sorry
10:28:17 <Jafet> I'd have to look at the base code, or core
10:28:28 <roconnor> I guess that is appropriate
10:29:00 <roconnor> m is only 16 items long
10:29:51 <roconnor> why does awesome haskell code need to be so slow :(
10:30:45 <Jafet> It's a sign that there's an even awesomer version out there
10:31:36 <roconnor> maybe
10:31:37 <Peaker> roconnor: GHC isn't magical enough
10:31:55 <roconnor> but that awesomer version better not be just be using STUArray
10:32:14 <Jafet> I don't find anything wrong with STUArray
10:32:31 <Peaker> my "vision" is that our IDE will expose a transparent rather than opaque optimization process -- interactively manipulate the code into its optimized counterpart by applying a myriad of optimizations from any library you wish, seeing the results of doing so as you go
10:32:35 <Jafet> Except all the higher rank typing
10:32:51 <roconnor> Jafet: it's a lot of overhead to write just to do a foldl'
10:33:12 <roconnor> its' hard to beat 6 the succinctness of 6 characters
10:33:21 <Jafet> Well, I'm more used to cps anyway
10:33:34 <roconnor> CPSing is an interesting idea
10:35:34 <mm_freak> roconnor: awesome haskell code doesn't need to be slow
10:35:45 <mm_freak> in fact, "awesome" haskell code isn't
10:36:02 <roconnor> mm_freak: I love my circular definition of ws.
10:36:05 <roconnor> I don't want to lose it
10:36:50 <mm_freak> roconnor: i haven't seen your code
10:37:04 <roconnor> http://hpaste.org/47438/shastep
10:37:15 <mm_freak> but i've seen you use (++) in a fold, which is certainly far from "awesome" ;)
10:37:33 <roconnor> for goodness sake it isn't in the fold
10:37:37 <Peaker> Awesome Haskell code is generally slower than ugly Haskell code optimized for performance
10:37:38 <mm_freak> ugh
10:37:43 <roconnor> well it is in a fold, but it isn't in the inner fold.
10:37:53 <Peaker> (but that may change if we have even more awesome compilers)
10:37:53 <mm_freak> Peaker: not true, unless you write low level code
10:37:56 <roconnor> Peaker: good point
10:38:13 <Peaker> mm_freak: example point: augustuss's ugly-hash
10:38:17 <roconnor> just look at the shootout at tell me that awesome haskell code is as fast as ugly imperitive code
10:38:19 <mm_freak> of course you should just use ByteString/Text where appropriate
10:38:27 <mm_freak> if you invent them yourself, then yes, you'll be screwed
10:39:24 <roconnor> removing ++ has had a only a tiny effect.\
10:39:24 <mm_freak> roconnor: i don't really care about the shootout, but i see my programs processing a lot of data quickly
10:39:29 <mm_freak> and they aren't ugly to read
10:39:47 <roconnor> mm_freak: are you using a lot of STUArrays?
10:39:52 <mm_freak> none
10:40:02 <mm_freak> i'm using regular immutable data structures
10:40:08 <roconnor> hmm
10:40:11 <mm_freak> ByteString and Text mostly
10:40:31 <roconnor> I spend all my time allocating memory and then tossing it away immediately
10:40:34 <roconnor> I think
10:40:44 <roconnor> COST CENTRE                    MODULE               %time %alloc
10:40:45 <roconnor> shaStep                        SHA256                21.9   21.4
10:40:47 <mm_freak> are you implementing SHA in haskell?
10:41:03 <roconnor> mm_freak: SHA looks beautiful in haskell
10:42:02 <mm_freak> well, i would use UArray for that
10:42:07 <mm_freak> UArray Int Bool
10:42:14 <roconnor> ws = m++zipWith4 smallSigma (drop (blockSize-2) ws) (drop (blockSize-7) ws)
10:42:15 <roconnor>                               (drop (blockSize-15) ws) (drop (blockSize-16) ws)
10:42:18 <roconnor> how awesome is that?
10:42:49 <mm_freak> one UArray contains 512 bits, the block size of SHA
10:43:02 <mm_freak> adressing those bits is an O(1) operation
10:43:29 <roconnor> sha2 operates on 8 Word32s
10:43:44 <roconnor> I have an unboxed unpacked type of 8 Word32s
10:43:53 <roconnor> should be even better than a UArray
10:44:06 <mm_freak> yes, but it takes the incoming data in blocks of 512 bits, IIRC
10:44:22 <roconnor> blocks of 8 Word32s
10:44:22 <Peaker> m ++ zipWith4 smallSigma (map part [2,7,15,16]) where part n = drop (blockSize-n) ws ?
10:44:25 <mm_freak> UArray is about as unpacked, unboxed as you can get ;)
10:44:41 <roconnor> Peaker: that's is better :)
10:44:57 <roconnor> mm_freak: except that the size isn't known at compile time
10:45:17 <mm_freak> anyway, if you want performance, get rid of the list operations
10:45:42 <roconnor> mm_freak: and use what instead?
10:46:02 <mm_freak> a better list structure, e.g. an iteratee
10:46:04 <mm_freak> or a vector
10:46:17 <xQj> hello, my question: what marks the end of a function in haskell
10:46:19 <roconnor> those are all strict
10:46:29 <roconnor> aren't they?
10:46:42 <mm_freak> the strictness question doesn't make much sense for iteratees
10:46:54 <mm_freak> each iteratee decides itself how "strict" it is…  or how much data it demands
10:47:10 <roconnor> How will iteratee help me here?
10:47:13 <Peaker> xQj: End of syntactic region... (\x y z -> ....)       is ended by ).  f x y = ....   is ended by indentation/newline...
10:47:15 <mm_freak> xQj: in source code or what do you mean?
10:47:28 <xQj> yes
10:47:36 <mm_freak> then see Peaker's answer
10:47:40 <xQj> okay
10:47:41 <xQj> ty
10:47:50 <mm_freak> haskell is layout-based, so indenting less will end your function definition
10:48:01 <Peaker> less or equal
10:48:08 <mm_freak> roconnor: well, SHA is a stream processor
10:48:11 <Peaker> well, equal to the func def indent
10:48:48 <mm_freak> true
10:49:58 <roconnor> mm_freak: that's why I use lazy lists
10:50:04 <mm_freak> roconnor: i don't know the structure of SHA out of my head, but as soon as you introduce non-fusable lists, you give up performance
10:50:36 <roconnor> ah Iteratee is CPSed
10:50:39 <Peaker> iteratees are a cool concept implemented with confusing names
10:50:56 <mm_freak> actually the names are not at all confusing, once you understand their motivation
10:51:25 <Peaker> mm_freak: much moreso than Consumer, Transformer, Producer
10:51:27 <mm_freak> just like you have an employer and employee, you have an iterator and iteratee
10:51:51 <mm_freak> Peaker: that's not quite right, because in the iteratee concept all of them are iteratees
10:52:04 <mm_freak> transformers and producers are iteratees
10:52:15 <sepp2k> Using FFI, how can I use a function pointer whose type (including the function's arity) I don't know until runtime?
10:52:38 <thoughtpolice> sepp2k: you can't, you'll need to use something like libffi.
10:52:41 <Jafet> That's a good question; how can you?
10:53:00 <mm_freak> sepp2k: well, if the cases are fixed you can just cast the pointer in haskell
10:53:11 <thoughtpolice> sepp2k: http://hackage.haskell.org/package/libffi
10:53:13 <mm_freak> :t castPtr
10:53:14 <lambdabot> Not in scope: `castPtr'
10:53:48 <sepp2k> mm_freak: Thanks, but they aren't.
10:53:51 <sepp2k> thoughtpolice: Thanks.
10:53:53 <mm_freak> roconnor: the 'iteratee' library is CPSed
10:54:02 <mm_freak> roconnor: see the 'enumerator' library
10:54:13 <mm_freak> personally i find it much easier to understand and work with
10:55:09 <thoughtpolice> i also like david's formulation/naming in iterIO, although iterIO is somewhat 'large' as it doesn't split out the dependencies
10:55:22 <mm_freak> i found that a good rule of thumb is:  don't use lists, unless you only use bird-style morphisms on them
10:55:26 <mm_freak> i.e. folds and unfolds
10:55:27 <thoughtpolice> (OTOH, it's complete and you can do some cool stuff out of the box. i like it.)
10:55:59 <mm_freak> yeah, iterIO is a great idea, although i has too many dependencies for an iteratee library
10:56:23 <mm_freak> i → it
10:56:43 <thoughtpolice> well, it's still it's first release. i think david has plans to split it out anyway, he just released it as it was because it was useful
10:57:07 <thoughtpolice> (i.e. the openssl/zlib/attoparsec deps are the 3 main things i think)
10:59:32 <Peaker> mm_freak: Enumerator is not an iteratee
10:59:38 <Peaker> mm_freak: Enumerator could be named Producer
10:59:49 <Peaker> Iteratee could be Consumer
11:00:51 <mm_freak> Peaker: look at its definition
11:01:15 <mm_freak> type Enumerator a m b = Step a m b -> Iteratee a m b
11:01:49 <mm_freak> it basically takes an iteratee and results in an iteratee
11:08:13 <k0ral> scree: thank you (a bit late :) )
11:21:20 <roconnor> mm_freak: with iterartees I wouldn't need to block my data in to 16 Word32 or 64 Word8s?
11:21:33 <mm_freak> roconnor: you can
11:21:42 <mm_freak> but you don't need to
11:21:47 <mm_freak> the input type can be freely chosen
11:27:51 <roconnor> heh, switching from foldl' to runST makes things a little slower
11:28:01 <roconnor> I actually find that comforting
11:28:34 <roconnor> I guess the allocations are not coming from where I thought they were
11:29:21 <roconnor> mm_freak: I'll look into this interatee thing later.  From what little I know it sounds like it would be a good fit for this.
11:29:49 <Jafet> Hmm. Did you add more cost centers?
11:30:08 <roconnor> oh, that might be a good idea
11:30:19 <roconnor> though with -O2, things get pretty funky pretty fast
11:30:30 <mm_freak> roconnor: as said i don't know the structure of SHA, so iteratees may not be a good fit
11:30:40 <roconnor> :D
13:40:52 --- topic: '["Paste code/errors: http://hpaste.org", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin and spam issues: #haskell-ops"]'
13:40:52 --- topic: set by monochrom!monokrom@toronto-hs-216-138-220-146.s-ip.magma.ca on [Sat Mar 26 17:29:19 2011]
13:41:04 <monochrom> turing machines are slower than g-machines
13:41:35 <monochrom> so slow that complexity people consider polynomial time to be fast :)
13:49:19 <morricone> hi, I just created a new workspace and module in leksah. But when I'm compiling it I get a warning: http://hpaste.org/47442/module_prelude_deprecated
13:50:04 <morricone> I'm using Gentoo btw
14:03:46 <red_now> Uso lo script  [[[ SpyScript ]]] Vers. 4.9.8
14:04:45 <danharaj> is there a standard way to name the identity functor?
14:07:18 * hackagebot mybitcoin-sci 0.1 - Binding to mybitcoin.com's Shopping Cart Interface.  http://hackage.haskell.org/package/mybitcoin-sci-0.1 (DavidHimmelstrup)
14:07:20 * hackagebot mybitcoin-sci 0.2 - Binding to mybitcoin.com's Shopping Cart Interface.  http://hackage.haskell.org/package/mybitcoin-sci-0.2 (DavidHimmelstrup)
14:07:43 <Peaker> danharaj: Identity?
14:08:09 <danharaj> Peaker: I meant like if I want to use Identity for a parameter in, say, a type class.
14:08:14 <danharaj> Or do I have to use a wrapper?
14:08:25 <Cale> danharaj: It's commonly 1_C or id_C or just 1 or id whenever it's obvious which category is being discussed.
14:08:40 <Cale> Oh, in Haskell specifically, there's Identity
14:09:10 <Cale> There is no type constructor T for which T a = a
14:09:30 <Cale> only one for which the constructed type is isomorphic
14:09:33 <Cale> ones*
14:09:33 <danharaj> that's slightly annoying.
14:09:45 <danharaj> It wouldn't hurt if it were added as an extension, would it? :p
14:10:43 <Cale> It might.
14:10:53 <saen> Hi there, does anyone know a function with a type definition like this  (a -> b) -> (a -> b -> c) -> a -> c ?
14:11:29 <Cale> :t (<*>)
14:11:30 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:12:01 <danharaj> @pl (\f g x -> (g x) (f x))
14:12:02 <lambdabot> flip ap
14:12:10 <Cale> :t \f g x -> (f <*> g) x
14:12:11 <lambdabot> forall a b t. (Applicative ((->) t)) => (t -> a -> b) -> (t -> a) -> t -> b
14:12:16 <danharaj> (ap is <*>)
14:12:19 * hackagebot mybitcoin-sci 0.3 - Binding to mybitcoin.com's Shopping Cart Interface.  http://hackage.haskell.org/package/mybitcoin-sci-0.3 (DavidHimmelstrup)
14:12:38 <saen> ah ok, my ghc tells me it s not in scope?
14:12:47 <danharaj> it is in Control.Applicative
14:12:52 <danharaj> which comes with GHC.
14:12:56 <saen> Nice thanks a lot
14:18:17 <conal> oh, nice. two flattrs on http://conal.net/blog/posts/a-third-view-on-trees/
14:20:05 <mikeg> dons: I think the doc for ByteString.Lazy.Char8.snoc is wrong: "Similar to cons, this function performs a memcpy." And I think the complexity, too. See the non-char8 interface to compare
14:31:27 <saen> Hi there again, I ve got another typedefinition (a -> (a,b)) -> a -> [b] for which I can t really see a purpose
14:32:41 <saen> Someone's got an idea?
14:35:13 <byorgey> saen: that looks like some sort of unfold
14:35:21 <danharaj> Yes that looks like an unfold for an infinite list.
14:35:43 <byorgey> saen: if you have a way to take a 'seed value' of type a and generate from it a data value b and another seed a, you can iterate it to generate an infinite list of b's from a seed
14:35:45 <saen> hmm
14:35:59 <danharaj> the first argument is a machine that takes a seed, produces a new seed, and a value.
14:36:05 <Twey> Not necessarily an infinite list
14:36:13 <Twey> The stop condition could be encoded in the a or the b
14:36:27 <Twey> Or the combination of both
14:36:40 <danharaj> Twey: Not if it's polymorphic. The only thing it could do is produce an infinite list or a finite list of some fixed length.
14:36:42 <byorgey> Twey: no, any function of that type must generate either an infinite list or a list of some determined length that does not depend on the a's or b's
14:36:55 <Twey> Oh, right, for any a/b… yeah
14:38:46 <byorgey> @type \f -> map snd . iterate (f . fst) . f
14:38:47 <lambdabot> forall a b. (a -> (a, b)) -> a -> [b]
14:39:28 <saen> wow thanks you're really fast ^^
14:39:39 <byorgey> > let unfold f = map snd . iterate (f . fst) . f in unfold (\a -> (a+2, a)) 1
14:39:41 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
14:40:03 <saen> primes :D
14:40:14 <luite> hehe that list does include all odd primes ;p
14:40:14 <byorgey> not exactly =)
14:40:15 <saen> no
14:40:21 <diabolix> 15?
14:40:27 <saen> 9
14:40:29 <saen> ^^
14:41:07 <byorgey> you could write the list of all primes as an unfold but it probably wouldn't be very efficient
14:41:11 <diabolix> does anyone actually use Yi? it looks interesting, but it seems to be abandoned.
14:42:01 <applicative> what looks abandoned about it?  there was a new hackage version a couple weeks ago, no?
14:42:03 <ion> @djinn (a -> (a, b)) -> a -> [b]
14:42:03 <lambdabot> Error: Undefined type []
14:42:28 <diabolix> applicative: oh, I must be looking at an abandoned page for it then.
14:45:02 <applicative> https://github.com/yi-editor/yi last activity 10 days ago.  I do think activity is periodic
14:45:56 <ben> Is Yi usable on Windows? I wanna see if I can make a non-programmer enjoy Haskell but i want to minimise the commandline bits.
14:47:35 <ion> How about Leksah?
14:48:24 <diabolix> Personally I have a hard time calling anything that uses gtk cross platform.
14:48:39 <mornfall> Well, Leksah is ... complex. IIRC, anyway.
14:48:40 <Peaker> ion: my multiple attempts to use Leksah never turned out well
14:48:52 <Peaker> seems very buggy
14:49:38 <applicative> ben, winghci doesn't seem to include an editor, unfortunately.  I don't know how well it's been kept up.
14:49:56 <ben> ah
14:52:40 <applicative> it would be nice if something like that was included in the windows haskell platform, with a simple haskell-conscious editor.
14:53:31 <diabolix> notepad++ isn't bad if your stuck on windows. I can't speak for its haskell integration, I'm guessing you wan't build integration.
14:54:11 <saen> when I used windows I used also notepad ++, and a makro to run a file via a shortcut
14:54:17 <saen> that s quite comfortable
14:54:20 <applicative> diabolix, yeah, I was thinking more of people without programming experience.
14:54:35 <ben> That's probably as close as it is going to get.
14:54:44 <ben> Cheers.
14:55:15 <applicative> notepad++ doesnt seem to readily configurable. I was trying to find a way to make pandoc readily usable by non programmers on windows.
14:55:20 <zmv> notepad++
14:55:23 <zmv> ewwwwww
14:55:50 <Peaker> notepad++ doesn't handle system verilog files very well.. or maybe just doesn't indent nicely. You press <return> and the cursor is at column 0
14:56:02 <luite> what editor features do you need for pandoc?
14:56:08 <applicative> some of the windows knowledgeable haskellers dont seem to mind notepad++ so much.
14:57:07 <applicative> luite, well, some easy way to call pandoc and automatically view an html rendering , or a pdf rendering via latex.  then the usual pile of key bindings for the markdown syntax
14:57:38 <ezyang> I used notepad++ when I was on Windows. Granted, never for pandoc
14:57:39 <luite> oh I didn't even know that there was a usual pile of key bindings for that
14:57:52 <ezyang> but now I vim everything. You can do vim on Windows...
14:58:05 <ben> I use vim on windows. But I do not wish to inflict it on other people.
14:58:07 <ezyang> (same with emacs, if that's how you swing)
14:58:10 <applicative> textmate is fairly friendly for nonprogrammers, and it is easy to train someone to use the  pandoc tmbundle
14:58:43 <saen> you can always run a batch trough notepad++ and give it a filepath
14:58:50 <saen> that should be enough for everything
14:59:01 <applicative> but i was defeated trying to make a similar arrangement on windows.
14:59:53 <applicative> one thing one does in textmate and emacs is run the whole file through pandoc -r markdown -w markdown, for immediate tidying
15:00:13 <diabolix> sublime text seems to have haskell integration.
15:01:17 <diabolix> altho it doesn't seem to deal with multiple file projects out of the box.
15:01:19 <applicative> maybe what would be best is to get texlive to include pandoc
15:01:58 <applicative> then one could write markdown in their editor, make the .tex and fiddle
15:02:10 <applicative> but their editor is hideous, whatever its called
15:02:56 <applicative> there it is, texshop
15:03:38 <diabolix> sublime text actually seems tolerable, but I'll have a hard time convincing my fingers that it isn't vim.
15:03:59 * Zao pets texworks
15:06:49 <applicative> hm, texworks, didn't notice it.  I wonder if it could be configured to permit composition in markdown, etc
15:07:07 <diabolix> is there a cli tool that will format haskell code?
15:07:15 <HairyDude> http://hpaste.org/47446/stream_fusion_broken <- correct if you compile without optimisations, but if you say -O2 it says 0
15:10:14 <Botje> HairyDude: you are aware those thinhs don't fit in an Int?
15:10:30 <HairyDude> ... why did I say Int? bleh
15:10:54 <Botje> oh wait, you grab each digit separately
15:10:57 <Botje> nvm
15:11:14 <applicative> HairyDude: i get 40824 with -O2 is that wrong?
15:11:22 <HairyDude> that's correct
15:12:16 <HairyDude> thing is, it works with Ints if you turn optimisation off
15:12:23 <applicative> i get the same result converting to integer
15:12:44 <Peaker> HairyDude: there's digitToInt   instead of read . return
15:12:56 <Peaker> @check liftA2 (==) digitToInt (read . return)
15:12:56 <lambdabot>   "*Exception: Char.digitToInt: not a digit '\1065163'
15:13:02 <HairyDude> Peaker: thanks
15:13:14 <Peaker> @index digitToInt
15:13:14 <lambdabot> Data.Char
15:14:18 <applicative> oh i see, int was okay, it was only dealing with the separate digits
15:15:24 <HairyDude> for reference, this is ghc 6.12.3 and stream-fusion 0.1.2.3
15:16:04 <applicative> oh, i'm using ghc 7.0.3 but the same stream fusion version
15:16:46 <applicative> Oh I see Botje had already noticed why Int was okay
15:19:15 <applicative> HairyDude: are you just starting using haskell?  If so, very swank use of unfoldr...
15:20:01 <Peaker> I don't like unfoldr
15:20:30 <Peaker> conal: oh, btw, I remember you liked discussing the "most lazy definitions" of common functions.. did you ever consider a lazier foldl?
15:21:03 <HairyDude> nah, been haskelling for years
15:21:06 <conal> Peaker: no, i haven't.
15:21:25 <diabolix> is there a sane way to invoke ghc like an interpreter with a #! at the top of the file?
15:21:33 <HairyDude> runhaskell
15:21:53 <saen> what s this hiding in the import statement for?
15:22:12 <applicative> what's wrong with unfoldr, Peaker?
15:22:28 <conal> Peaker: the idea intrigues me, though, since foldl is so very non-productive.
15:22:43 <Peaker> conal: consider:  foldl cons nil [] = nil ; foldl cons nil xs = cons (init xs) (last xs)
15:22:56 <Peaker> (That's O(N^2) but someone figured out a way to do the equivalent in O(N) when I asked)
15:23:10 <Peaker> oops, missing recursion there :)
15:23:29 <Peaker> foldl cons nil [] = nil ; foldl cons nil xs = cons (foldl cons nil (init xs)) (last xs)
15:23:55 <Peaker> conal: lazier because if "cons" doesn't need its arguments to be somewhat productive, then it can yield a result even in infinite cases
15:24:06 <conal> Peaker: yeah. cool.
15:24:25 <Peaker> When "reverse" is then defined in terms of this foldl,  you can actually do:  length . take 10 $ reverse [1..]
15:24:34 <HairyDude> in what sense is foldl unproductive?
15:24:40 <conal> Peaker: is there also a def of foldl via reverse & foldr?
15:24:58 <Peaker> conal: reverse is defined in terms of foldl, typically
15:25:11 <conal> Peaker: nice example.
15:25:37 <conal> Peaker: really? not reverse via foldr?
15:26:10 <conal> cons -> cons and nil -> second list
15:26:19 <Peaker> conal: well, I think it is because in terms of foldr it requires the O(N) snoc operation, N times (also yielding O(N^2))
15:26:32 <HairyDude> > foldl (\y x -> x:y) "" "12345"
15:26:33 <lambdabot>   "54321"
15:26:38 <jmcarthur> > let reverse = foldl (flip (:)) [] in reverse "abcdef"
15:26:40 <lambdabot>   "fedcba"
15:27:15 <Saizan> foldr (:) xs = (++xs)
15:27:15 <conal> Peaker: oh, weird. my brain replaced "reverse" with "append" in your remark about reverse & foldl.
15:27:15 <HairyDude> so reverse = foldl (flip (:)) []
15:27:23 <Peaker> > foldr (\x y -> y ++ [x]) "" "12345"
15:27:25 <lambdabot>   "54321"
15:28:58 <applicative> HairyDude: but foldl fails for infinite lists
15:29:07 <applicative> > foldr (:) [] [1..]
15:29:07 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:29:17 <HairyDude> so anyway, my stream fusion bug is not reproducible in latest ghc, right?
15:29:18 <Peaker> Found the O(N) lazy foldl definition: lfoldl f z xs = foldr (flip f) z (relist xs (reverse xs))
15:29:19 <applicative> > foldl (flip (:)) [] [1..]
15:29:27 <lambdabot>   mueval: ExitFailure 1
15:29:27 <lambdabot>  mueval-core: Time limit exceeded
15:29:29 <HairyDude> applicative: you can reverse infinite lists now?
15:29:30 <Peaker> relist (_:pat) ~(x:xs) = x:relist pat xs
15:29:30 <Peaker> relist []      []      = []
15:29:54 <Peaker> @let relist (_:pat) ~(x:xs) = x:relist pat xs ;  relist []      []      = []
15:30:00 <lambdabot>  Defined.
15:30:09 <Peaker> @let lfoldl f z xs = foldr (flip f) z (relist xs (reverse xs))
15:30:10 <lambdabot>  Defined.
15:30:14 <applicative> HairyDude: I was just thinking through what conal meant by calling foldl 'unproductive'
15:30:19 <Peaker> @let lreverse = lfoldl (flip (:)) []
15:30:20 <lambdabot>  Defined.
15:30:33 <danharaj> > foldr (\x y -> y ++ [x]) [] [1..]
15:30:33 <Peaker> > map (const ()) $ lreverse [1..]
15:30:37 <lambdabot>   mueval-core: Time limit exceeded
15:30:39 <lambdabot>   mueval: ExitFailure 1
15:30:39 <lambdabot>  mueval-core: Time limit exceeded
15:31:12 <Peaker> > map (const ()) $ lreverse [1..]
15:31:14 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
15:31:20 <Peaker> yay!
15:33:00 <Peaker> it is a bit funny though, because the lazy reverse is defined in terms of lazy foldl, in terms of non-lazy reverse, in terms of non-lazy foldl
15:33:51 <danharaj> if there were a distinction between data and codata in Haskell, things would be cleaner.
15:35:16 <applicative> then we'd have to have real data! yick!
15:36:01 <joeyh_> I did caught an exception with IO.try, and if I try to putStrLn (show e) , my program sometimes exits nonzero.. why?
15:36:10 <joeyh_> if I don't do anything with e, it continues.. most puzzled
15:36:32 <Saizan> maybe the exception value throws an exception when eveluated?
15:36:42 <dolio> People use recursion that isn't obviously structural all the time in Haskell, though.
15:36:44 <Saizan> s/an/another/
15:36:54 <joeyh_> maybe.. it's the error "hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)"
15:37:12 <Saizan> ah, that's hard to catch with try
15:37:16 <joeyh_> ah is it
15:37:32 <dolio> That seems like it'd be an issue, especially since there'd be no means for proving that your non-obvious recursion is actually okay.
15:38:43 <dolio> And some stuff is right-out.
15:38:47 <dolio> Forget about tying the knot.
15:38:56 <dolio> If you care about that.
15:39:58 <danharaj> point taken
15:40:24 <Saizan> you'd tie the know with codata, no? though i think data would end up being different only if evaluated eagerly
15:41:04 <dolio> It depends what we're proposing.
15:41:05 <Saizan> *knot
15:42:18 <Saizan> joeyh_: try putting an exception handler around the putStrLn (show e), so you'll know if the exception is raised by forcing e
15:42:45 <dolio> If you have general recursion, what's the data codata distinction mean?
15:43:16 <danharaj> data is guaranteed to be finite?
15:43:19 <HairyDude> Agda distinguishes between data and codata, it has termination and productivity checkers that inevitably have to be turned off occasionally
15:43:56 <dolio> How is it guaranteed to be finite?
15:44:15 <danharaj> right.
15:44:27 <HairyDude> "data" is just shorthand for "initial algebra of some strictly positive functor" or something like that
15:44:35 <dolio> If I have 'data' naturals, and I define 'n = Suc n', what is that?
15:44:48 <Peaker> HairyDude: I was under the impression that heroic Agda developers manage to convince their compilers of their heroism every time :-)
15:44:59 <danharaj> dolio: not even a value.
15:45:08 <danharaj> so I guess data should not have bottoms.
15:45:14 <HairyDude> Peaker: well, frequently, and well-founded induction helps.
15:45:43 <HairyDude> dunno if there is such a thing as co-wellfounded coinduction or whatever :)
15:47:06 <Saizan> danharaj: but from where do you derive that? the definitions for data and codata that work in a total language coincide in a language with general recursion
15:47:41 <danharaj> Saizan: Could we live with general recursion being only possible with codata?
15:47:57 <danharaj> I suppose then there would need to be very rich types to make data useful.
15:48:14 <HairyDude> danharaj: if you tried, type checking would be undecidable, cos you need to solve the halting problem
15:48:22 <dolio> What does '(v, n) = f n x y z' do?
15:48:32 <dolio> Does it depend on whether pairs are codata?
15:48:46 <dolio> Or is it whether pairs and the types of v and n are codata?
15:48:53 <Saizan> HairyDude: i don't see how that follows
15:48:55 <danharaj> I'm going to drop it because it was an idle comment that makes no sense under scrutiny :p
15:49:53 <HairyDude> Saizan: I guess you could restrict data to certain induction operators, but I don't think it would be as complete as you'd like.
15:50:04 <HairyDude> s/induction/recursion/
15:53:35 <Saizan> fix :: forall a. Codata a => (a -> a) -> a  :)
15:54:19 <HairyDude> ah, right.
15:54:21 <Saizan> fortunately the function space counts as Codata
15:55:24 <HairyDude> well that wouldn't guarantee productivity, so I'm not sure if that would really be codata as such. not quite au fait with what exactly "codata" means tbh.
15:57:01 <Saizan> my point was to allow partially defined values as haskell is doing now
15:58:27 <HairyDude> my point is that if codata must be productive (not sure on this point), then if you define a class Codata with fix as a method, "Codata" would be a misnomer.
15:58:47 <Saizan> codata must be productive only in a total language
15:58:55 <HairyDude> right.
15:59:13 <HairyDude> so "codata" is a programming term, not a theoretical one?
15:59:21 <Saizan> if we take codata to mean "final coalgebra of some functor"
15:59:56 <Saizan> then haskell's [a] is perfectly fine codata, but also perfectly fine data!
16:00:27 <HairyDude> Haskell's type system corresponds to an inconsistent logic though, cos it has bottoms.
16:00:35 <Saizan> it's both the initial algebra and the final coalgebra of \X -> 1 + AxX
16:00:45 <Saizan> yeah
16:01:05 <Saizan> i'm not using haskell as a logic to prove this
16:01:11 <dolio> Function spaces are not codata by that definition, though.
16:01:12 <Saizan> it's a metatheorem
16:02:43 <Saizan> dolio: i think they are isomorphic to, at least
16:02:55 <HairyDude> I guess bottom counts as data then, since \X -> 1 * X has an initial algebra in Haskell
16:03:16 <HairyDude> I mean a nonempty one
16:03:50 <Saizan> bottom is a value
16:03:59 <HairyDude> yeah, a data value, I mean
16:05:06 <dolio> What is the datatype that is isomorphic to [Int] -> [Int]?
16:05:13 <dolio> And what value of it encodes id?
16:05:16 <HairyDude> to rephrase, the least fixpoint of \X -> 1 * X is data, but is empty in a total language
16:05:52 <HairyDude> dolio: it's a memo tree
16:06:22 <dolio> > id [1..]
16:06:23 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
16:06:44 <HairyDude> dolio: Int -> a is isomorphic to [a], for example
16:07:03 <HairyDude> s/Int/Integer/ obviously
16:07:03 <dolio> No, it isn't. It's isomorphic to Stream a.
16:07:04 <Saizan> dolio:  the functor would be: \x -> IntxX + IntTrie X
16:07:16 <HairyDude> ... yes, you're right :)
16:07:39 <Saizan> \X -> IntxX + IntTrie X
16:08:29 <Saizan> well, that'd work for Stream Int -> Stream Int, [Int] -> [Int] needs something more
16:09:58 <dolio> And how do you encode functions that way?
16:10:47 <HairyDude> http://www.haskell.org/haskellwiki/Memoization
16:11:16 <dolio> HairyDude: His type isn't even a normal memo trie.
16:12:48 <HairyDude> the memo trie for [Int] -> [Int] would be I think the greatest fixpoint of \X -> [Int] * Stream X
16:13:04 <Saizan> yeah, you can't write "tabulate" in haskell for my type
16:13:38 <Saizan> but it works as a stream transducer
16:13:42 <applicative> "Thanks to LazyEvaluation, we can even memoise an infinite domain, though we lose constant time lookup."
16:14:03 <HairyDude> the domain has to be algebraic, but it can definitely be infinite
16:14:46 <applicative> do list types count as 'algebraic'?
16:14:49 <HairyDude> yes
16:14:50 <Saizan> if you get the IntxX side that Int goes in front of the stream, if you get the IntTrie X side you consume an Int from the input
16:16:50 <dolio> Anyhow, I'm not sure how it's isomorphic if you can't witness the isomorphism.
16:17:50 <Saizan> that's why i'm studying continuity axioms :)
16:17:59 <HairyDude> you can, that's why you can use it to memoize functions
16:18:30 <kamaji> Could someone explain to me how to make this function tail-recursive? http://pastebin.com/AyjEtF16
16:18:33 <mauke> The paste AyjEtF16 has been copied to http://hpaste.org/47450/httppastebincomayjetf16
16:19:13 <HairyDude> primes is already tail recursive
16:20:00 <kamaji> it eats 40% of my memory though
16:20:41 <kamaji> doesn't that usually mean it isn't?
16:21:17 <mauke> no
16:21:39 <dolio> HairyDude: How are you going to tabulate all the values of [Int] into your trie, including the infinitely long ones?
16:21:48 <HairyDude> using length means you evaluate the whole of xs, that might be your problem if you're generating all of them
16:21:55 <HairyDude> dolio: simple, you don't :)
16:22:04 <dolio> You have to, if you want to read them back out.
16:22:14 <HairyDude> dolio: the infinite cases aren't algebraic
16:22:47 <applicative> kamaji what's 'dividedByAny'?
16:22:47 <HairyDude> dolio: so I guess [a] is not algebraic for any a, but if you count only finite values it is.
16:22:47 <dolio> Then [Int] -> [Int] is not codata. QED.
16:22:49 <kamaji> HairyDude: how could I fix that? 1.6GB seems like a lot for a simple call to length
16:23:00 <kamaji> applicative: returns true if p is divided by any element of ps
16:23:12 <Saizan> dolio: no, it's just that HairyDude choose the wrong proof :P
16:23:58 <HairyDude> kamaji: your test is length xs >= n, you could write a function that stops early if the answer is True
16:24:40 <kamaji> HairyDude: it's trying to find the 10001th prime, it's for project euler
16:24:41 <HairyDude> having said that... you append it to the start of another list, so probably that's not your problem either. hmm
16:24:49 <kamaji> yeah
16:25:01 <kamaji> i'll paste the dividedByAny code, but I don't see why it would be that
16:25:23 <kamaji> I did an annotation http://hpaste.org/paste/47450/httppastebincomayjetf16#p47451
16:25:26 <Saizan> kamaji: both appending to a list and taking its length are O(n), which is bad especially if done repeatedly
16:26:16 <kamaji> Saizan: ah ok, is there a better way to do it?
16:26:27 <HairyDude> modAll x ys = map (x `mod`) ys
16:27:22 <parcs> :t map . mod
16:27:23 <lambdabot> forall b. (Integral b) => b -> [b] -> [b]
16:27:40 <BMeph> :t map . flip mod
16:27:41 <lambdabot> forall a. (Integral a) => a -> [a] -> [a]
16:27:50 * BMeph WINNNNNNNNNNNNS!
16:28:06 <kamaji> well i'm lost :P
16:28:48 <HairyDude> also dividedByAny x ys = any (\y -> x `mod` y == 0) ys
16:28:53 <HairyDude> any from Data.List
16:29:24 <kamaji> aw...
16:30:03 <kamaji> well it doesn't speed it up, hehe
16:30:14 <HairyDude> I love how rich Haskell's basic libraries are
16:30:48 <HairyDude> yeah, I was just suggesting a couple of things that makes your code shorter, but not quicker :)
16:31:15 <kamaji> It's so much nicer :D
16:31:51 <HairyDude> last is also O(1), btw
16:31:57 <HairyDude> er, O(n)
16:32:03 <kamaji> oh I see
16:32:08 <kamaji> damnit
16:32:29 <Saizan> > let primes = 2:[ x | x <- [3,5..], p <- takeWhile (\p -> p*p <= x) primes, x `mod` p /= 0] in primes !! 1001
16:32:29 <lambdabot>   393
16:32:38 <HairyDude> smartarse :P
16:33:05 <HairyDude> my implementation was a kind of lazy sieve, takes about 30 seconds to come up with the answer
16:33:15 <kamaji> oh *that's* how you do prepending
16:34:18 <kamaji> Saizan: wait, what does that do?
16:34:28 <HairyDude> huh, why didn't I think of only considering odd numbers
16:35:23 <Saizan> kamaji: it defines primes as the infinite list of primes and then takes the 1002th element
16:35:43 <kamaji> Saizan: I think the answer is wrong?
16:35:50 <Saizan> or 1001th if the head is 0th
16:35:54 <c_wraith> the answer is definitely wrong
16:36:04 <c_wraith> there's no way the 1002nd prime < 1002
16:36:21 <HairyDude> haha
16:36:32 <Saizan> i'm rusty, but it's something like that :P
16:37:08 <Saizan> oh
16:37:12 <erus`> how can i generate pi lazy styleee?
16:37:14 <Saizan> > let primes = 2:[ x | x <- [3,5..], p <- takeWhile (\p -> p*p < x) primes, x `mod` p /= 0] in primes !! 1000
16:37:14 <lambdabot>   393
16:37:22 <Saizan> nah
16:37:50 <HairyDude> let primes = 2:[ x | x <- [3,5..], let p = takeWhile (\p -> p*p <= x) primes, all (\y -> x `mod` y /= 0) p] in primes !! 1001
16:37:55 <HairyDude> > let primes = 2:[ x | x <- [3,5..], let p = takeWhile (\p -> p*p <= x) primes, all (\y -> x `mod` y /= 0) p] in primes !! 1001
16:37:56 <lambdabot>   7933
16:38:11 <HairyDude> > let primes = 2:[ x | x <- [3,5..], let p = takeWhile (\p -> p*p <= x) primes, all (\y -> x `mod` y /= 0) p] in primes !! 10001
16:38:13 <lambdabot>   104759
16:38:17 <HairyDude> bingo
16:38:24 <danharaj> I forget, which applicative instance is defined for []? The monad one or the zip one?
16:38:42 <c_wraith> monad
16:38:46 <HairyDude> the one where (<*>) = ap
16:38:53 <danharaj> whose idea was that.
16:38:54 <HairyDude> so, monad
16:40:17 <Peaker> danharaj: Applicative instance must always be compatible with the Monad one
16:40:27 <danharaj> Peaker: lame.
16:40:43 <Peaker> danharaj: On the contrary, it would be lame if it was not guaranteed that  <*> = ap
16:41:17 <HairyDude> kamaji: what that does is: take 2 as prime, then filters the odd numbers starting with 3 on whether it's divisible by all primes less than or equal to its square root
16:41:18 <Peaker> danharaj: The ZipList newtype and instances is already defined -- and there are nice functions to work with newtypes
16:42:07 <kamaji> HairyDude: ok, going through it... :D
16:42:45 <kamaji> oh it's 3 lines...
16:42:52 <Saizan> i'm so tired i managed to take a cartesian product where i wanted a filter..
16:43:21 <jmcarthur> umm
16:43:27 <jmcarthur> go to sleep
16:43:27 <c_wraith> what time is it in italy?
16:43:40 <kamaji> (oh no.. it's not)
16:43:44 <Saizan> 2am
16:45:28 <HairyDude> it's efficient because it doesn't construct or traverse any unnecessary lists
16:45:59 <Peaker> Saizan: Andrea is a guy or girl's name in Italy?
16:46:20 <Saizan> Peaker: mostly guy
16:46:22 * HairyDude points to Andrea Bocelli
16:49:16 * BMeph points at Drew Barrymore. Not because she's named "Andrea"; he just likes pointing at her. ;þ
16:49:44 * Saizan points at prime sieves http://www.haskell.org/haskellwiki/Prime_numbers 
16:51:17 <kamaji> Saizan: I am so there
16:53:53 <Peaker> http://hpaste.org/46966/sieve_of_eur_with_st_unboxed  a simple imperative solution in ST
17:03:47 * BMeph is still waiting for someone to try getting anything useful out of an STFUArray... ;)
17:05:27 <zaltekk> i've recently started using xmonad as a replacement for scrotwm, and it has gotten me interested in haskell. i'm looking for some advice on where to start.
17:05:46 <zaltekk> i am currently debating if i should grab Programming in Haskell(seems really short) or Real World Haskell. or look elsewhere.
17:05:58 <zaltekk> I am not new to programming, but I am new to functional programming.
17:05:58 <Cale> zaltekk: You might try Learn You A Haskell
17:06:08 <geheimdienst> zaltekk: great :) welcome to the world's bestest language. most people recommend LYAH
17:06:10 <geheimdienst> @where lyah
17:06:10 <lambdabot> http://www.learnyouahaskell.com/
17:06:10 <ehamberg> zaltekk: Learn You a Haskell is a great starters guide.
17:06:26 <Cale> zaltekk: Also, don't be afraid to ask questions here
17:06:42 <zaltekk> okay. is it what you'd recommend to a senior year CS student? or just to everyone?
17:07:13 <geheimdienst> i think the normal route is to check RWH (real world haskell) after you have had some getting your feet wet. i don't think it makes a good beginner's book
17:07:58 <Peaker> Also, if you're a "hands on" guy, just solving Euler problems after learning basic syntax can be productive
17:08:29 <geheimdienst> ... or messing with your xmonad config :)
17:09:51 <zaltekk> i'm usually not. although i think this experience will be different.
17:11:07 <zaltekk> i just built ghc 7.0.3 and then built the haskell platform. and used cabal to install Yi. so i think that's a majority of what i'll need
17:11:28 <pastorn> zaltekk: yi? you seem pretty serious :)
17:11:40 <zaltekk> it looked like there wasn't proper Vim support
17:11:43 * pastorn is fine with gvim
17:11:52 <pastorn> zaltekk: what's *proper*
17:11:59 <pastorn> i have my syntax, that's all i need
17:12:04 <zaltekk> stuff seemed unmaintained
17:12:10 <pastorn> *syntax highlulzing*
17:12:25 <zaltekk> and i wasn't sure what the deal with the indention plugins were needed for. probably because i haven't learned the language :P
17:12:43 <zaltekk> err...there should be a / in the first sentence
17:12:45 <pastorn> zaltekk: just set it to force TAB=4*space
17:12:47 <applicative> is that true about vim?  seems there's a lot of vim users in this crowd...
17:12:48 <pastorn> which is convention
17:13:05 <zaltekk> right. it seemed to imply you wanted different levels for different things
17:13:07 <zmv> lol
17:13:15 <zaltekk> i've gotten to like 2spaces, but i know 4 is more common
17:13:15 <applicative> tabs dont exist in haskell. they are a menace...
17:13:27 * pastorn nods
17:13:37 <geheimdienst> zaltekk: i'm a vim user and i'm fine with http://projects.haskell.org/haskellmode-vim/
17:13:45 <Peaker> I hate 2spaces in languages like C, which require page-ful functions routinely
17:13:57 <Peaker> but in Haskell, functions are so short, that 2-spaces is enough
17:14:01 <zaltekk> well, i do use 4 spaces in C
17:14:07 <pastorn> zaltekk: you want yi so that you can see your errors while you write them, right?
17:14:07 <zaltekk> but for most dynamic languages I use 2
17:14:23 <Peaker> pastorn: yi has "flymake" for Haskell automatically?
17:14:32 <zaltekk> pastorn: i thought it would be a shortcut for getting an editor setup for the time being
17:14:35 <pastorn> Peaker: it's called "incremental parsing"
17:14:46 <Peaker> pastorn: sounds hard
17:14:51 <pastorn> zaltekk: just use gvim + filetype detection
17:14:57 <pastorn> Peaker: it's a doctorate project
17:15:02 <zaltekk> and as i mentioned, i didn't see an omnifunc for haskell
17:15:05 <applicative> what does that mean, flymake?
17:15:08 <Peaker> pastorn: In my view, it is also unneeded
17:15:55 <Peaker> applicative: it's an emacs mode that runs a command on your current file after every edit (and when switching buffers), then highlights positions emitted by that command
17:15:57 <pastorn> zaltekk: all I use is gvim with the plugin for haddock comments (so that i can generate HTML docs from my comments)
17:16:00 <zaltekk> pastorn: geheimdienst: i saw the "haskellmode" thing, and wasn't sure how it would benefit me. it integrates the compiler somehow? is it just syntax checking?
17:16:04 <Peaker> applicative: typically a command like "check syntax"
17:16:14 <pastorn> zaltekk: do you know how to use vim?
17:16:27 <Peaker> applicative: but it can be a full-blown compilation
17:16:28 <applicative> every edit?  seems a bit much
17:16:33 <zaltekk> pastorn: i'm no expert. but i use it for everything else i write.
17:16:39 <Peaker> applicative: well, I guess it can "skip frames" if needed
17:16:41 <pastorn> I've found that my biggest efficiency boost was starting to use visual block
17:16:43 <zaltekk> pastorn: and Vimperator for FF4 :P
17:16:47 <Peaker> applicative: I haven't used it but people say its awesome
17:16:56 <geheimdienst> zaltekk: i use it for highlighting and indentation, nothing special ... works pretty well
17:17:30 <zaltekk> geheimdienst: i'll probably just setup makeprg and the error thing so that I can do :make to check my code when i please
17:17:34 <Peaker> Java has got nice IDE support.. Haskell IDE support could be even better more easily (the language is more amenable to static analysis, and more simply)
17:17:51 <Peaker> I know developers who choose C#/Java over Haskell just because of IDE support :-(
17:18:01 <pastorn> Peaker: lolfail
17:18:08 <kamaji> wahahaha, I just did euler problem 8 by inspection :D
17:18:20 <pastorn> japcu: hello :)
17:18:20 <Peaker> pastorn: why? I think it's an important concern
17:18:33 <applicative> funny, euler 8 was just being discussed
17:18:39 <Peaker> pastorn: A good IDE makes programming far more pleasant...
17:18:47 <kamaji> applicative: it was?
17:18:51 <Peaker> (a good language too, but in a different way)
17:18:53 <zaltekk> what are these Euler problems you guys have spoken of? does he have something to do with calc and logs? i can't remember =/
17:18:53 <pastorn> Peaker: i have a friend working with C#, he says his job is to write stuff and then get rid of any red lines... If all read line's are gone you've done good
17:19:04 <kamaji> zaltekk: www.projecteuler.net
17:19:05 <BMeph> @where euler
17:19:05 <lambdabot> http://projecteuler.net
17:19:13 <BMeph> zaltekk: ^_^
17:19:35 <Cale> Euler was a mathematician, had nothing to do with Project Euler though.
17:19:39 <geheimdienst> Peaker: i agree. there's definitely value in not having to spend hours on gluing together lots of badly-fitting puzzle pieces ... this editor, that plugin, that weird shell script ...
17:19:44 <applicative> oh yeah, http://hpaste.org/47446/stream_fusion_broken HairyDude was using it to illustrate something
17:19:51 <zaltekk> oh, okay. maybe that's why i was confused by the references
17:19:52 <mauke> euler invented everything
17:19:54 <zaltekk> looks interesting.
17:20:08 <Peaker> geheimdienst: and it's fun to get a completion box for almost everything you do (that you can ignore or use)
17:20:24 <Peaker> geheimdienst: the completion box is a quick reminder of what options are available, instead of opening a separate doc in a web browser
17:20:27 <applicative> zaltekk: people make fun of it, but its a good supply of 'finger exercises' for beginning haskell, i'd think
17:20:34 <Cale> Project Euler is a bunch of math problems all of whose solutions are numbers.
17:20:48 <applicative> usually about 9 digits...
17:21:01 <Peaker> pastorn: the red lines are really sort of "TDD" based on static types
17:21:13 <japcu> hi pastorn, this is a busy channel I must say
17:21:18 <Peaker> pastorn: TDD (especially that based on sound types rather than unsound unit tests) is nice
17:21:21 <zaltekk> pastorn: do you have omnicompletion in vim?
17:21:37 <pastorn> zaltekk: <C-n>?
17:21:40 <Peaker> pastorn: I like the "getting rid of red lines" part :)
17:21:47 <pastorn> Peaker: :)
17:21:48 <zaltekk> ^x^o
17:21:58 <zaltekk> idk what ^n does
17:22:43 <Peaker> HairyDude: btw, instead of that foldr, why not just:  map (take 5) . tails  ?
17:22:44 <zaltekk> it'll show the possible completions in a dropdown you can cycle through with ^o and ^p. it also brings up the scratch window with the prototype of the functions
17:23:13 <zaltekk> it's really useful for when you know how a function works but forgot the order of the parameters
17:23:23 <Peaker> HairyDude: or:  filter (not . null . drop 5) . map (take 5) . tails
17:23:23 <zaltekk> or forgot the exact name
17:23:47 <pastorn> zaltekk: like netbeans does?
17:23:53 <pastorn> (for javadoc)
17:23:57 <zaltekk> pastorn: sure. it's very similar.
17:24:04 <zaltekk> it was added in 7.x
17:24:22 <zaltekk> but there isn't native support for haskell. i was wondering if it was available from somewhere(i haven't come across it yet)
17:24:50 <pastorn> zaltekk: parsing haskell isn't exactly a trivial task...
17:25:23 <zaltekk> pastorn: it's for library functions.
17:25:41 <zaltekk> there is a different hotkey for completion of identifiers
17:25:44 <pastorn> zaltekk: for one thing you can have functions stated as both prefix - "f x y" - and infix - "x `f` y"
17:26:08 <pastorn> zaltekk: lots of haskell library funcions are called stuff like "<|>"
17:26:27 <papermachine> Did Monad.Reader 18 ever get published?
17:26:41 <zaltekk> right.
17:26:54 <zaltekk> well, i have one more question then. and i'll probably get directed somewhere to read about it.
17:27:31 <pastorn> zaltekk: and then werther your expression "x <|> y <?> z" typechecks depends on the types of x, y and z (obviously) and how tight the operators <|> and <?> binds, and this their fixity can be set when declaring them
17:27:59 <pastorn> s/and this their/and their/
17:28:01 <zaltekk> how is interaction with say, the OS handled non-imperatively?
17:28:08 <pastorn> no
17:28:12 <pastorn> you use do-notation
17:28:35 <pastorn> wc path = do { content <- readFile path; return (length content) }
17:28:49 <zaltekk> before when i had looked at some functional stuff i remember wondering "how can I make a _real_ application with this?"
17:29:15 <pastorn> zaltekk: once you start thinking in compositions it's not gonna be that difficult...
17:29:30 <zaltekk> compositions are some form of modularity?
17:29:34 <pastorn> zaltekk: and when you realize what should be wrapped in IO and what shouldne't
17:29:41 <pastorn> zaltekk: sort of...
17:30:04 <zaltekk> I assume that at some level it ends up being haskell calling C?
17:30:18 <danharaj> haskell is compiled to native assembly
17:30:23 <danharaj> or it can be interpreted
17:30:24 <pastorn> zaltekk: IO functions are all functions that needs to go outside of the threads allocated space in order to return
17:30:25 <zaltekk> not in that way, danharaj
17:30:52 <pastorn> zaltekk: for example all OpenGL functions are IO
17:31:04 <zaltekk> pastorn: right. i guess i'm not exactly sure how to ask what i want to know =/
17:31:07 <pastorn> zaltekk: any database interaction as well as printing and reading text from the prompt is
17:31:39 <zaltekk> i don't understand how a functional way of asking for input or writing output would work. but i'm sure i'll figure it out soon enough.
17:31:42 <dankna> well, in the sense that the system libraries are written in C, yes, in a sense you're calling C
17:32:09 <applicative> did zaltek suggest our compiler just calls C ??
17:32:12 <pastorn> zaltekk: it's similar to other languages... if you've seen that stuff in python or ruby or whatever you won't be surprised
17:32:24 <pastorn> zaltekk: though laziless will surprise you
17:32:31 <pastorn> *laziness
17:32:33 <zaltekk> dankna: right. and someone writes some code to patch together haskell and the underlying system libs
17:32:40 <Cale> zaltekk: We have values which represent actions that could be performed in order to produce a result, along with a bunch of functions for combining those actions (and some imperative-ish looking syntax sugar)
17:32:46 <zaltekk> anyway, i'll stop asking dumb questions and go find that book.
17:32:49 <dankna> zaltekk: yes.  though not you, hopefully, as it already exists.
17:32:50 <Cale> zaltekk: For example,  getLine :: IO String
17:32:56 <dankna> no it's not a dumb question, it's an interesting one
17:33:04 <Cale> zaltekk: Is an IO action which if performed, would produce a string.
17:33:09 <dankna> I think I understand what you're getting at - how do you think of IO operations in non-imperative terms
17:33:26 <dankna> the answer is sort of "you allow yourself to think imperatively for a little while"
17:33:34 <kmc> they are imperative terms
17:33:35 <zaltekk> dankna: yeah. i don't thing i've grokked the thought process yet
17:33:35 <applicative> how do you think about the things people do without telling them to do them?
17:34:02 <kmc> the IO type is an imperative language embedded within Haskell
17:34:03 <dankna> zaltekk: you'll get there!  it takes practice
17:34:06 <zaltekk> *think
17:34:49 <pastorn> zaltekk: i've found wikibooks to be quite straight-forward on many haskell subjects
17:34:52 <zaltekk> the web framework (the name escapes me...I believe it starts with a Y) looks very interesting to me
17:34:54 * edwardk waves hello.
17:34:57 <kmc> hi edwardk!
17:34:59 <dankna> it's also the case that you can wrap these imperative sub-programs in functional ways - for example, I was looking at a program a few weeks ago that has a type [(Key, IO ())]
17:35:02 <zaltekk> and i think that's where i'll look after learning a bit
17:35:07 <dankna> which is read "list of pairs of keys and IO actions"
17:35:07 <yitz> hi edwardk
17:35:28 <Cale> zaltekk: A nice thing about this way of doing things is that since IO actions are first class values, we can pass them around to functions that combine them in various ways without any fear that things accidentally run too early. So it's easy to write your own control structures for IO, for instance.
17:35:28 <kmc> yeah, "imperative" and "functional" are not mutually exclusive
17:35:33 <yitz> zaltekk: yesod?
17:35:39 <zaltekk> yitz: yes, that's it.
17:35:41 <dankna> in other words, that datatype represented keybindings
17:36:26 <zaltekk> how portable is ghc?
17:36:26 <japcu> zaltekk: you might be interested in http://book.realworldhaskell.org/
17:36:44 <zaltekk> japcu: yeah, i've come across that link and saved it already :)
17:37:03 <kmc> zaltekk, http://hackage.haskell.org/trac/ghc/wiki/Platforms
17:37:13 <dankna> GHC itself is written in about 75% Haskell and 25% C (the compiler is 100% Haskell, the runtime engine is 100% C.  to a first approximation.)  both parts of it are actually quite portable.
17:37:30 <dankna> the Haskell part makes very few assumptions about the platform it's running on, so that's quite nice.
17:37:32 <kmc> however building GHC as a cross-compiler is a bitch and a half
17:37:40 <dankna> though obviously it has to know a lot about the platform it's targetting.
17:37:42 <pastorn> zaltekk: it runs on win/mac/linux and on x86 (32/64), sparc and even a little bit on arm
17:37:51 <dankna> yes heh.  I need to get off my rear and work on that more :)
17:38:00 <kmc> the RTS is not 100% C, some of it is Cmm or assembly
17:38:02 <applicative> danka, wait you're forgetting the evil mangler!
17:38:06 <kmc> some of it is Cmm that is auto-generated from Haskell code
17:38:07 <dankna> kmc: ah yeah, that's true
17:38:15 <kmc> (the fast-apply stubs)
17:38:18 <dankna> applicative: oh yeah, haha, so I am
17:38:26 <zaltekk> ah cool, mips and mipsel are on the list
17:38:32 <yitz> applicative: oh noes that still exists?
17:38:43 <kmc> there are other hidden dependencies -- for example, GHCi requires an ELF or PE executable format
17:38:49 <zaltekk> i just recently got a new toy that runs mips
17:38:49 <kmc> because GHCi contains a custom dynamic linker
17:38:54 <kmc> zaltekk, what toy?
17:39:02 <applicative> yitz, dunno, don't have to deal with getting the right perl, now that we have the haskell platform....
17:39:09 <kmc> zaltekk, by the way, JHC is another Haskell complier, which produces portable C
17:39:14 <zaltekk> kmc: a router with a 400mhz mips and 64mb of ram
17:39:31 <kmc> and Hugs is a portable Haskell interpreter
17:39:35 <zaltekk> it is where my irc client is running
17:39:38 <applicative> zaltekk, while you are collecting tutorials, add tibbe's http://www.slideshare.net/tibbe/highperformance-haskell
17:39:43 <kmc> cool
17:39:59 <pastorn> btw, is anyone porting ghc to haiku?
17:40:25 <dankna> not that I'm aware
17:40:49 <pastorn> maybe erlang is a better fit than haskell, but still
17:41:35 <BMeph> pastorn: For porting to Haiku, you mean?
17:41:45 <danharaj> pastorn: shouldn't you be working on your gsoc ;)
17:41:50 <applicative> funny, there's suprisingly recent discussion of ghc on haiku
17:44:28 <pastorn> danharaj: i've been doing for a bunch of work already today
17:44:36 <pastorn> i might be blogging in a few days on this
17:44:53 <luite> what are you working on?
17:48:00 <ClaudiusMaximus> is there a guide somewhere on porting Haskell OpenGL apps from GLUT to GTK?  or even a library to make it easier?
17:48:27 <dankna> ugh
17:48:29 <dankna> I wish there were, but no
17:49:01 <BMeph> Fun: "cBWindow :: Maybe (Ptr BWindow -> IO ()) -> BWindowDispatch a -> BRect -> CString -> WindowType -> [Window_flag] -> Window_workspace -> IO (Ptr BWindow)"
17:50:03 <ClaudiusMaximus> dankna: k, i need to port suchly soon, hopefully i can document it a bit
17:50:12 <dankna> indeed
17:50:41 <luite> what's a good binary ipc data format?
17:51:04 <kmc> thrift?
17:53:16 <luite> hmm, was thinking of something lower level, just the data format, not a full rpc thing
17:53:41 <kmc> does it need to be cross-language?
17:53:48 <luite> nope all haskell
17:54:00 <kmc> how about 'binary' or 'cereal'
17:57:08 <HairyDude> does stream-fusion do cross-module optimization?
17:57:38 <kmc> GHC does cross-module inlining, so i expect it does in at least those cases
17:57:47 <HairyDude> awesome
17:58:37 <luite> kmc: hmm good idea. do you know which one is faster?
17:58:46 <kmc> no luite
17:58:52 <kmc> i don't think there's a huge difference
17:59:01 <kmc> the main difference is how they handle errors, and lazy vs. strict bytestring
17:59:26 <parcs> does dynamic linking inhibit cross-module optimization, then?
17:59:56 <kmc> no
18:00:02 <kmc> not to my knowledge
18:00:43 <kmc> when GHC is compiling module M, if it thinks f will be inlined by some of M's users, it will write Core bytecode for f into the file M.hi
18:00:54 <kmc> the .hi files need to be present at compile-time, whether or not you are linking dynamically
18:00:56 <HairyDude> so haskell programs benefit from link-time inlining?
18:01:09 <kmc> it's not link-time
18:01:30 <HairyDude> how do you optimise use of dynamic libraries, then?
18:02:02 <kmc> to compile against a dynamic lib you need its .hi files
18:02:09 <kmc> (same as a static lib)
18:02:19 <luite> the compiler includes some code in the interface files, enough to inline things
18:02:39 <HairyDude> so if the core changes, you can't link against the updated library?
18:02:49 <kmc> iirc, if you upgrade a dynamically linked library you still need to recompile its users
18:03:03 <kmc> the dynamic library is named by a hash of its interface file contents
18:03:12 <luite> ghc doesn't really care about binary compatibility :)
18:03:13 <HairyDude> right, so the only benefit you get is shared object code
18:03:17 <Eduard_Munteanu> Uh.
18:03:41 <Eduard_Munteanu> So you're saying that even the .so number doesn't get bumped, you must still recompile? :/
18:03:51 <kmc> i think so Eduard_Munteanu
18:04:01 <kmc> i read as much, but i haven't used this feature myself
18:04:21 <pastorn> luite: i'm rewriting "OpenGL"
18:04:26 <kmc> the C-level ABI of a Haskell library is a much less well-defined thing than the C-level ABI of a C library
18:04:52 <HairyDude> so suppose the GHC runtime is dynamically linked, if it changes all Haskell programs have to be rebuilt
18:05:00 <Eduard_Munteanu> Doesn't it vaguely follow the platform ABI?
18:05:07 <luite> pastorn: to what? :p
18:05:30 <kmc> Eduard_Munteanu, does the platform ABI say how thunks, partial-application closures, or algebraic sums are represented? ;P
18:05:43 <dankna> HairyDude: it's always the case that when a Haskell dependency changes, its dependants need to be rebuilt.
18:05:47 <kmc> HairyDude, yes -- I'm not sure you can dynamically link the RTS anyway
18:05:52 <pastorn> luite: to something containing documentation and no fixed functionality functions
18:06:14 <Eduard_Munteanu> kmc: well I'd expect all those to boil down to some rather basic C interface somehow.
18:06:34 <Eduard_Munteanu> Or in other words...
18:06:50 <flazz> i have 'Ord k =>' ... on almost every function, what can i do to just have an abstract type where Ord (or anything else) is implied, like a type or data declaration?
18:06:51 <Eduard_Munteanu> Does the output of GHC violate the platform ABI in any way?
18:06:54 <luite> pastorn: ah good :)
18:07:02 <kmc> yes -- my point is that the details of exactly how are complicated, and subject to change based on a number of factors
18:07:26 <kmc> that's independent of the question of whether compiled Haskell code looks like compiled C code, which is what you're talking about
18:07:49 <pastorn> what's an "ABI"?
18:08:19 <Eduard_Munteanu> pastorn: basically calling conventions etc.
18:08:28 <Eduard_Munteanu> Application Binary Interface.
18:08:59 <kmc> flazz, using the GADTs extension:  data OrdList a where { MkOrdList :: (Ord a) => [a] -> OrdList a }
18:09:58 <Eduard_Munteanu> That's what the platform ABI means. But for an application it also means the way you talk to it (what structs you pass etc.)
18:10:20 <flazz> GADT is the only way? nothing like 'type Symbol = a where Ord a' ?
18:10:39 <HairyDude> how do you get fusion on the list monad?
18:10:54 <HairyDude> hide [] in the prelude?
18:11:35 <kniu> question about type inference:
18:11:44 <kmc> flazz, wouldn't 'a' have to appear on the left-hand side too?
18:11:49 <kniu> the inferred type is supposed to be as polymorphic as possible, right?
18:11:58 <kmc> flazz, or is your type trying to be existential as well?
18:12:19 <Eduard_Munteanu> There's   data (Ord a) => Symbol a = ...   but I don't know if it ever worked
18:12:19 <kmc> kniu, in standard Haskell, yes.  with some extensions that is no longer guaranteed
18:12:37 <kniu> kmc, do those extensions include ExplicitForAll?
18:12:48 <kmc> don't think so
18:12:58 <kmc> isn't ExplicitForAll purely syntactic
18:13:00 <flazz> kmc: can i just make a new class 'Symbol a' such that Symbol is the union of other classes?
18:13:01 <kniu> then I think I might have found a bug in the GHC type inference engine.
18:13:16 <kmc> cool, can i see? :D
18:13:55 <kniu> hold on, I need to reformulate my code so that the problem is clear.
18:14:05 <kmc> flazz, class?
18:14:13 <flazz> kmc: typeclass
18:14:29 <kmc> i don't understand what you mean
18:14:37 <kmc> how would it look in code
18:15:03 <HairyDude> class Foo a, Bar a => Baz a
18:15:04 <Eduard_Munteanu> It might work with GeneralizedNewtypeDeriving, but I'm not sure.
18:15:23 <flazz> i want a typeclass Symbol, such that Symbol a implies Ord a and Show a
18:15:25 <flazz> something like that
18:15:44 <kmc> class (Ord a, Show a) => Symbol a
18:15:49 <kmc> no "where" clause, no body
18:15:57 <flazz> kmc: that is it?
18:16:08 <kmc> yes -- but you'll probably need some instances
18:16:53 <flazz> thanks, i'll work with it!
18:17:42 <HairyDude> so, there is a Control.Monad.Stream which suggests that stream-fusion implements fusion on the list monad, but there's no indication of how to use it
18:19:09 <kmc> the API looks the same as Control.Monad
18:19:18 <kmc> stream fusion is supposed to be transparent
18:19:33 <Eduard_Munteanu> HairyDude: have you seen Data.List.Stream?
18:19:50 <HairyDude> *sigh* yes, I'm using it already
18:19:58 <kmc> these modules are the same as the standard ones, but with more rewrite rules
18:20:18 <Eduard_Munteanu> Also, Data.Stream.
18:20:33 <kmc> Data.Stream looks like the stuff used to implement those rewrite rules
18:20:38 <HairyDude> so what do you do, just hide Functor, Monad and whatever monad-related functions you use?
18:20:43 <Eduard_Munteanu> Transparent yeah, but it can break silently :)
18:21:06 <Eduard_Munteanu> No, why?
18:21:13 <kmc> HairyDude, it's re-exporting the standard Functor and Monad classes
18:21:22 <HairyDude> oh, I see
18:21:33 <HairyDude> so all it provides is rewrite rules
18:22:59 <kmc> well the rewrite rules are defined for the functions in that module
18:23:06 <kmc> if you import both modules, the rules won't apply to the other one
18:23:25 <kmc> it will become more clear if you read  the source
18:25:56 <HairyDude> hang on... should I be using Stream instead of [] ?
18:26:44 <kmc> no
18:27:07 <parcs> "/window right"
18:27:09 <parcs> "/window left"
18:27:55 <kmc> the way stream fusion works is, they have these functions stream :: [a] -> Stream a, unstream :: Stream a -> [a]
18:28:28 <kmc> and they transform for example «map f» into «unstream . mapS f . stream»
18:28:39 <Eduard_Munteanu> Hrm, if these are rooms, how come you get from one to another through windows? :P
18:28:40 <applicative> HairyDude, it seems they have just added some rules for foldM and foldM_ in particular
18:29:07 <kmc> so the stream type is used only internally
18:29:14 <kmc> read the doc at the top of http://hackage.haskell.org/packages/archive/stream-fusion/0.1.2.3/doc/html/Data-List-Stream.html
18:29:25 <kmc> or, read the paper
18:32:16 <kniu> urgh
18:32:16 <applicative> HairyDude, I think the view of the knowledgeable is that Data.Vector gives a better illustration of stream fusion ideas.
18:32:19 <kniu> the bug is hard to replicate
18:32:48 <kniu> it's embedded deep in my actual application, but trying to extract the relevant parts doesn't actually cause the error.
18:34:09 * HairyDude looks at Data.Vector
18:39:53 <kniu> gah
18:40:09 <kniu> fuck it, I'll just use the whole thing as the example.
18:41:58 <kniu> http://hpaste.org/47453/try_to_compile_this
18:42:10 <kniu> kmc, try it and tell me what you see
18:47:26 <kmc> oh, defaulting is another exception to the most-general-type rule
18:47:30 <kmc> but i don't think that's what's going on here
18:47:58 <kmc> this is a lot of code
18:48:12 <kniu> I just want to make sure I'm not missing some subtlety of the Haskell type system.
18:48:13 <kmc> surely you can cut it down, by removing some cases of Expr for example
18:48:30 <kniu> I got angry and just select all -> copy -> paste
18:48:58 <kmc> fair enough, but i bet we could be more helpful if you cut it down
18:49:15 <kniu> okay, I'll try.
18:49:17 <kmc> did you try to understand the error that GHC gives without the signature?
18:50:04 <kmc> are you compiling with -Wall?
18:50:54 <kniu> kmc, no
18:52:55 <kniu> kmc, as far as I can tell, the problem is that on use the type of the case_ function suddenly got specialized even though it shouldn't have been.
18:53:21 <kniu> Without using case_, the type of that function is the same as the annotation.
18:59:54 <applicative> tough code kniu.
19:00:55 <applicative> there is an asymmetry where case_ CaseStmt :: Parser [Stmt] -> Parser Stmt but case_ Case :: Parser Expr -> Parser Expr
19:01:16 <applicative> those are the two uses you make of case_
19:01:34 <kniu> applicative, yes
19:01:40 <kniu> but how would that be a problem?
19:03:32 <applicative> its hard to isolate, as you said ... case_ expr and rexpr are all depending on each other.
19:04:26 <kniu> yeah.
19:05:52 <kniu> I was trying to "rewrite" everything with stuff like "data A = ...; foo c y = c A y" but no matter what I did it wouldn't result in the same type error.
19:10:00 <kmc> why are you using NoImplicitPrelude
19:11:23 <kniu> kmc, because I redefined ($) for left-associativity.
19:11:40 <kniu> There's some cruft in there, I know.
19:12:13 <kmc> isn't it enough to import Prelude hiding(($))
19:12:58 <kniu> I guess.
19:14:00 <kmc> also you're missing signatures in other places
19:14:13 <kmc> maybe putting those in would help
19:17:23 <kmc> you're using a lot of 'try'
19:18:42 <kniu> kmc, how to avoid?
19:19:32 <kmc> you don't need it when there's no chance of the first parser consuming some input and then failing
19:19:41 <kmc> and you don't need it if you can left-factor the grammar
19:20:12 <kmc> instead of «try (string "ab") <|> string "ac"» write «string "a" >> (string "b" <|> string "c")»
19:20:40 <kmc> otherwise, maybe you can replace «try a <|> try b <|> ... <|> try z» with «msum $ map try [a, b, ..., z]»
19:20:46 <kmc> the repetition adds a lot of noise to the code
19:20:55 <kniu> :t msum
19:20:55 <kmc> anyway i'm having some success cutting down your example code
19:20:56 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
19:21:02 <kniu> huh
19:21:11 <kniu> :i <|>
19:21:19 <kniu> :t (<|>)
19:21:21 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
19:21:37 <tsanhwa> is it possible to add the module that is installed after ghci is started
19:22:53 <kmc> :t asum
19:22:54 <lambdabot> Not in scope: `asum'
19:23:07 <kmc> :t Data.Foldable.asum
19:23:09 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Foldable.Foldable t, Alternative f) => t (f a) -> f a
19:32:14 <The_Ice[home]> tsanhwa: are you asking about :m +Data.Char?
19:33:22 <kniu> @hoogle asum
19:33:23 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
19:40:00 <kmc> kniu, http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/other-type-extensions.html#typing-binds
19:40:44 <kmc> kniu, i have a reduced version of your code which works iff i use -XRelaxedPolyRec
19:42:00 <kmc> anyway, that links to some stuff which i believe is relevant here
19:42:37 <applicative> kniu, it also seem to work if you get rid of 'NoMonomorphismRestriction' . In any case, it infers the type you supplied
19:43:07 <kmc> see also this thread: http://www.haskell.org/pipermail/haskell-cafe/2010-April/075852.html
19:43:55 <kniu> oh wow
19:43:56 <kniu> thanks guys
19:44:12 <kmc> i think this thread explains it quite well
19:44:37 <applicative> the remark of ross paterson?
19:45:00 <kmc> i was pretty shocked when i saw the example in the first message
19:48:51 <dolio> Not very surprising.
19:49:22 <dolio> It's an obfuscated of polymorphic (mutual) recursion.
19:49:32 <dolio> Obfuscated example, even.
19:50:49 <lee_> Is there a solution to the following dilemma: I have a module that exports x, y, z which depend on a, b, c...yet I'd like to put quickcheck test for a,b,c in blah_test.hs not blah.hs
19:50:51 <dolio> @type let f x = f () in f
19:50:52 <lambdabot> forall t. () -> t
19:51:20 <dolio> It isn't possible to infer most general types when polymorphic recursion is involved.
19:51:45 <dolio> @type let f x = f (x, x) in f
19:51:46 <lambdabot>     Occurs check: cannot construct the infinite type: t = (t, t)
19:51:46 <lambdabot>       Expected type: (t, t) -> t1
19:51:46 <lambdabot>       Inferred type: t -> t1
19:52:30 <kniu> hackage is being slow
19:53:36 <kniu> Parsec seems to abide by the "zero, one or infinity" rule.
19:54:18 <kmc> what rule is that?
19:54:28 <kmc> dolio, why isn't it theoretically possible?
19:54:50 <kniu> http://en.wikipedia.org/wiki/Zero_One_Infinity
19:55:17 <applicative> klodolph example is a little easier to think about f = id where _ = g ; g = id where _ = f
19:55:35 <dolio> I don't know if I have an answer for that. But Hindley-Milner rides very close to the line.
19:56:10 <tsanhwa> The_Ice[home]: I mean, if I install a package after ghci is started, then when I want to load the newly installed module I have to restart ghci
19:56:25 <dolio> The types you get in that example are the result of doing HM inference. If you want more general types for polymorphic recursion, you need to be able to add signatures telling it the more general types.
19:56:36 <tsanhwa> The_Ice[home]: I wonder if I can just load the new module without restarting ghci
19:56:46 <dolio> Because HM will either infer the wrong ones, or blow up with an occurs check.
19:56:46 <ClaudiusMaximus> dankna: (or anyone else who'd like to look/comment): http://hpaste.org/47454/glut_gtk_wrapping (with an example as an annotation)
19:56:53 <dankna> looking
19:57:04 <dankna> oh hey, that could be much worse!
19:57:15 <dankna> I approve
19:57:30 <applicative> dolio, it will infer the more general types if you strike the signature in the where clause, or maybe that's part of what youre saying
19:58:18 <applicative> wait, but the most general type is the same either way, okay
19:59:45 <dolio> applicative: The general problem is that if HM won't detect that something can be generalized if you use it at a concrete type as a part of its own definition.
20:00:24 <dolio> And I don't think it's possible to do in general.
20:00:34 <tsanhwa> is there such a typeclass that abstracts operations on dictionary like data structurs, such as Map, hashtable ? operations such as insert, lookup, etc.
20:01:04 <dolio> ML just doesn't allow polymorphic recursion. Haskell allows you to write a type signature to get it to work.
20:02:26 <applicative> is it still polymorphic recursion if I strike the subordinate signature in the where clause?
20:02:32 * applicative is still a bit muddled
20:02:50 <diegoviola> hi
20:03:51 <diegoviola> why is haskell great, why should i learn it? i do currently know Ruby. I don't mean to troll, I'm just interested to learn a new language.
20:03:54 <applicative> hi diegoviola
20:03:55 <dolio> applicative: I don't know that the example in that e-mail is actually polymorphic recursion, since the functions don't really call each other. But it's the same problem that makes polymorphic recursion infeasible.
20:04:30 <diegoviola> i heard a lot about haskell
20:04:42 <applicative> yes I was trying to find something without the ' _ '
20:05:24 <applicative> diegoviola: haskell is very beautiful.
20:05:34 <diegoviola> applicative: i see
20:05:51 <dolio> @type let f _ = undefined where _ = y 5 ; y x = undefined where _ = f x in (f, y)
20:05:52 <lambdabot> forall t a. (Num t) => (t -> a, Expr)
20:05:53 <diegoviola> beautiful is also why i decided to learn Ruby.
20:06:06 <applicative> diegoviola, and you can get people like dolio to explain things to you on #haskell
20:06:17 <diegoviola> nice!
20:06:24 <dolio> @type let f _ = undefined where _ = y (5 :: Int) ; y x = undefined where _ = f x in (f, y)
20:06:25 <lambdabot> forall a. (Int -> a, Expr)
20:06:29 <diegoviola> how to start with haskell?
20:06:30 <dolio> That's odd.
20:06:34 <dolio> Oh.
20:06:47 <diegoviola> i'm new to functional languages
20:06:55 <mauke> preflex: ? lyah
20:06:55 <preflex>  http://learnyouahaskell.com/
20:07:00 <diegoviola> ty
20:07:03 <dolio> @type let { f _ = undefined where { _ = y (5 :: Int) } ; y x = undefined where { _ = f x } } in (f, y)
20:07:04 <lambdabot> forall a a1. (Int -> a, Int -> a1)
20:07:04 <applicative> mauke are you here?
20:07:04 <lee_> what preflex said
20:07:17 <Axman6> diegoviola: do you know ay other programming languages?
20:07:17 <mauke> applicative: no, I'm over there
20:07:17 <dolio> @type let { f _ = undefined where { 6 = y (5 :: Int) } ; y x = undefined where { _ = f x } } in (f, y)
20:07:18 <lambdabot> forall a t. (Num t) => (Int -> a, Int -> t)
20:07:22 <Axman6> any*
20:07:25 <diegoviola> Axman6: Ruby
20:07:34 <diegoviola> Axman6: I also did something with bash scripts, etc
20:07:35 <Axman6> well, forget everything you know about ruby ;)
20:07:46 <dolio> @type let { f _ = undefined where { 'c' = y 'd' } ; y x = undefined where { _ = f x } } in (f, y)
20:07:46 <diegoviola> Axman6: and php (which I prefe to forget)
20:07:47 <lambdabot> forall a. (Char -> a, Char -> Char)
20:07:55 <applicative> mauke, with this new cross post to hpaste thing 'you' do, I can never tell
20:08:01 <kmc> diegoviola, http://tryhaskell.org/
20:08:02 <diegoviola> prefer*
20:08:06 <diegoviola> kmc: ty
20:08:32 <kmc> Haskell is a functional language but it's not a *typical* functional language
20:08:36 <kmc> it has many unique properties
20:08:40 <mauke> applicative: it's not easy! I have a highlight on pastebin.com and have to copy/paste between irc and my browser all the time
20:08:56 <Eelis> kmc: what would you say /is/ a typical functional language?
20:09:06 <HairyDude> a strict, impure one
20:09:11 <Eelis> ml?
20:09:15 <kmc> Scheme or ML or something
20:09:24 <Eelis> i see, interesting
20:09:28 <diegoviola> how does Haskell compares to Erlang, Lisp, Scheme and other functional languages please?
20:09:30 <kmc> i mean you can divide the categories fine enough so that your language is typical of its category
20:09:32 <tgeeky> most used is... Excel (SPJ says so!) or C
20:09:37 <kmc> diegoviola, there's no simple answer to that question
20:09:48 <kmc> diegoviola, but Haskell has static type checking, while the three you listed don't
20:10:05 <diegoviola> interesting
20:10:06 <kmc> a main advantage of Haskell is that the compiler helps you find many mistakes
20:10:07 <pikhq> diegoviola: Just comparing Haskell to Erlang, Lisp, or Scheme individually would be a pretty drawn-out answer.
20:10:11 <Eelis> i've come to functional programming via type theory, so it's the impure/untyped functional programming languages that seem atypical to me
20:10:14 <dolio> kmc: Anyhow, if I had to explain why it isn't possible to get this to work, it's because it's not generally safe to generalize the types of things until you've finished checking a definition, or a set of mutual definitions.
20:10:27 <applicative> diegoviola: in haskell programming is 80% thinking about types.
20:10:27 <HairyDude> heehee, C as a functional language
20:10:33 <kmc> diegoviola, if your Haskell code compiles, there is a good chance it is correct
20:10:42 <pikhq> The thing is, though there's many things Erlang, Lisp, and Scheme have in common that Haskell does not, each one of those languages has many unique properties.
20:10:45 <dolio> And before you generalize, unification variables are vulnerable to being monomorphized.
20:10:59 <dolio> Or triggering the occurs check.
20:10:59 <pikhq> (okay, well, actually, not "Lisp and Scheme", because Scheme is a Lisp)
20:11:01 <diegoviola> kmc: nice
20:11:03 <HairyDude> I keep wishing Excel was more than zeroth order.
20:11:06 <applicative> diegoviola, it's like a puzzle sometimes getting them to snap together...
20:11:22 <diegoviola> interesting
20:11:23 <HairyDude> even first order would make it vastly more powerful.
20:11:33 <tgeeky> HairyDude: it's a stretch of an argument, but: http://conal.net/blog/posts/the-c-language-is-purely-functional/
20:11:42 <HairyDude> I know, I've read it
20:11:46 <tgeeky> ok
20:11:48 <diegoviola> is there libraries for interfacing with databases, web frameworks, etc?
20:11:50 <pikhq> Aaah, that blog post. The one that amused me enough to start learning Haskell.
20:11:56 <kmc> diegoviola, static typing is generally associated with horrible verbose code, a la Java, but Haskell has type inference and is very expressive in other ways... your code can be shorter than Python etc, but also vastly safer
20:11:57 <tgeeky> I think the spirit is acceptable, even if I disagree :o
20:12:17 <kmc> diegoviola, yes, there's thousands of libraries freely available
20:12:18 <applicative> diegoviola, often people complain that types are restrictive, but in haskell they are like the ground you walk on
20:12:19 <diegoviola> kmc: great
20:12:21 <mustelo> @pl \(x, y, z) -> [f x, f y, f z]
20:12:22 <lambdabot> (line 1, column 7):
20:12:22 <lambdabot> unexpected ","
20:12:22 <lambdabot> expecting letter or digit, operator or ")"
20:12:22 <lambdabot> ambiguous use of a non associative operator
20:12:24 <kmc> http://hackage.haskell.org/packages/archive/pkg-list.html
20:12:34 <diegoviola> applicative: perfect, thanks
20:12:38 <HairyDude> tgeeky: I think CPP being functional is not much of a stretch :)
20:12:40 <diegoviola> thanks guys, I will learn Haskell.
20:12:48 <kmc> types are meant to be restrictive, they are for restricting you from writing incorrect programs
20:13:04 <dolio> They aren't just restrictive, though.
20:13:05 <applicative> diegoviola: good luck
20:13:09 <diegoviola> applicative: thanks
20:13:12 <pikhq> HairyDude: Oh, CPP itself is quite certainly functional. Very idiosyncratic, but functional.
20:13:13 <tgeeky> HairyDude: I never actually wrote CPP myself - I did a great deal of work in C for the 2.4 kernel, and then stopped with C
20:13:26 <dolio> CPP isn't functional, I think.
20:13:34 <HairyDude> types are a corset, they keep your code where you want it and stop it being where it's not supposed to be
20:13:40 <pikhq> Though it's also not TC.
20:13:48 <tgeeky> HairyDude: sounds like what I've read
20:13:48 <applicative> kmc if you think of them like parts of speech, grammar, it's hard to see how they are restrictive
20:13:58 <tgeeky> HairyDude: in Haskell, though, I see types as liberating, not restraining
20:14:01 <dolio> That blog post is wildly disingenuous, really.
20:14:08 <diegoviola> I really want to learn what functional programming is like, it seems like you can express a lot of things and keep the code shorter and elegant, with functional programming.
20:14:30 <HairyDude> Haskell is the world's premier imperative language. =)
20:14:32 <tgeeky> HairyDude: which makes sense, honestly - when you start from the more strongly typed side of *using types* in practice, one ought to expect getting type inferrence being a liberating experience
20:14:51 <applicative> HairyDude, even Professor Harper agrees with that
20:15:05 <applicative> ....but ML is the best functional language...
20:15:09 <HairyDude> the sentiment isn't original to me, don't remember who I got it from though
20:15:16 <pikhq> diegoviola: The really big thing with functional languages (and this is nothing unique to Haskell) is that it is very, very easy to abstract things.
20:15:18 <HairyDude> lies
20:15:22 <applicative> it is a quotation from simon p j
20:15:27 <tgeeky> applicative: I think the word 'best' is banned from use in comparing computer languages
20:15:35 <diegoviola> pikhq: nice
20:15:43 <applicative> i think 'best' is best banned, yes
20:16:17 <tgeeky> applicative: from many other things too.
20:16:25 <tgeeky> For instance, the best ice cream is Americone Dream.
20:16:42 <tgeeky> if there are 719 people in here, then there are 700 who disagree with me :o
20:16:53 <tgeeky> and 100 freaks of nature who don't like ice cream!
20:17:00 <HairyDude> pikhq: did you know category theory (whence monads) is nicknamed "abstract nonsense"?
20:17:02 <diegoviola> it's also easier to think in terms of functions I think, my brain for some reason likes func(foo(bar())), etc
20:17:13 <applicative> tgeeky there are no doubt plenty of freaks of nature in here
20:17:14 <pikhq> HairyDude: Yes, I am.
20:17:26 <pikhq> HairyDude: Thing is, programming is the art of abstraction.
20:18:01 <pikhq> So abstract nonsense is entirely applicable.
20:18:07 <tgeeky> pikhq: is that reversable?
20:18:09 <HairyDude> well, good refactoring / program structure is the art of abstraction.
20:18:15 <pikhq> tgeeky: I know not.
20:18:16 <tgeeky> The art of abstraction is programming?
20:18:23 <tgeeky> The abstraction of art is programming?
20:18:27 <holmak> Cabal won't compile my code due to some kind of circular dependency from the ghc package, could anyone tell me what I've done wrong? -- I posted the error on hpaste.org
20:18:27 <tgeeky> no that one isn't right
20:18:42 <HairyDude> music is like programming in some ways
20:18:44 <tgeeky> pikhq: finding programming abstractions surely is an art
20:18:54 <holmak> http://hpaste.org/47456
20:18:58 <tgeeky> we should have an anonymous /agere /disagree command :o
20:19:19 <pikhq> HairyDude: I can't quite place what those ways are, though.
20:19:29 <monochrom> holmak: you have too many packages, in particular one unix-2.4.0.0 and one unix-2.4.2.0
20:19:52 <monochrom> "ghc-pkg unregister --user unix"
20:20:03 <HairyDude> pikhq: primitives, combinators, gotos, loops :)
20:20:16 <holmak> monochrom: Aha -- I tried "ghc-pkg hide", but that didn't do it
20:20:22 <applicative> holmak, are you using the haskell platform. what does ghc-pkg list say about the two unix packages?
20:20:32 * HairyDude wonders if anyone's tried to eradicate gotos from musical notation
20:20:33 <applicative> holmak, cabal doesn't care about 'hide'
20:20:48 <nihtml> 05:14:25 < ordiclic> jviens de finir mon j
20:20:54 <nihtml> oh sorry
20:21:01 <pikhq> HairyDude: Structured musicing?
20:21:04 <pikhq> :)
20:21:09 <HairyDude> :)
20:21:21 <applicative> nihmtl the sudden intrusion of your language is pleasing.
20:21:21 <holmak> applicative: Good to know. I ended up having two installed after accidentally running "cabal install unix"
20:21:41 <applicative> oh so nothing depends on one of them.
20:21:46 <monochrom> holmak: my http://www.vex.net/~trebla/haskell/sicp.xhtml has more horror stories like yours
20:22:01 <applicative> its just that one of them will have come with the haskell platform, if you're using it
20:22:03 <HairyDude> ohhhh, unregister. I was wondering earlier how to uninstall an old user version of cabal
20:22:13 <HairyDude> without nixing my entire .cabal directory
20:22:14 <holmak> monoschrom: That looks useful
20:22:17 <HairyDude> which I did in the end
20:22:22 <diegoviola> is Haskell pure with the functional paradigm?
20:22:47 <monochrom> executables can only be uninstalled by deleting it in .cabal/bin
20:22:48 <holmak> applicative, monochrom: I installed it because ghc-pkg was complaining about it being broken
20:23:08 <pikhq> diegoviola: Generally.
20:23:09 <applicative> diegoviola: there is a special use of the word 'pure' in this connection, in which haskell is absurdly pure
20:23:25 <monochrom> then you have a previous similar error and installing more packages add more errors, not fix errors
20:23:33 <pikhq> It definitely does depend on what you mean by "pure", though.
20:23:45 <monochrom> the only way to win is not to install
20:23:51 <diegoviola> applicative: I mean 'pure' in the sense that Ruby is 'pure' with the OO thing (everything in Ruby is an object.)
20:24:11 <diegoviola> pikhq: ^
20:24:44 <kmc> well it's definitely not true that "everything is a function" in Haskell
20:24:54 <pikhq> Well, yes, there's also values.
20:24:58 <kmc> functions are values
20:25:01 <pikhq> Some of which are functions.
20:25:09 * c_wraith is playing with SDL.  This binding is rather unfortunately low-level, but it works!
20:25:10 <monochrom> "ghc -v" would be interesting to watch. you may be thoroughly scared
20:25:13 <kmc> values in Haskell are either functions or algebraic data
20:25:15 <kmc> basically
20:25:21 <applicative> everything is a value, everything is 'first class'. not sure what formula could be used
20:25:30 <kmc> lots of things aren't first class in Haskell
20:26:01 <pikhq> Types. Not sure what it would mean for a type to be first-class, but they're certainly not that way in Haskell.
20:26:08 <kmc> it would mean dependent types
20:26:11 <applicative> kmc, i know, it should more like 'you wouldn't believe what's (e.g.) first class'.
20:26:19 <pikhq> Oh, duh, of course it would.
20:26:33 <BMeph> Not everything in Haskell are values, though. Types, for one.
20:26:53 <BMeph> Some people are not happy about that, and are looking to change that. :)
20:27:03 <kmc> not first-class: types, record labels, modules, classes, instances, code
20:27:14 <holmak> monochrom: Are there any prospects for Haskell packages becoming less terrifying in the near future? :)
20:27:34 <applicative> hm, suppose we consider agda instead, can we come up with some suitable "everything is a ...." formula then?
20:27:39 <BMeph> kmc: How are record labels not first-class? They're functions! ;þ
20:27:50 <kmc> not in the update position :/
20:27:55 <pikhq> holmak: By my standards, that *is* "less terrifying".
20:27:57 <monochrom> I don't know. dcoutts says yes. but dcoutts is behind cabal.
20:28:13 <dolio> Dependent types don't have anything to do with types being 'first class'.
20:28:15 <pikhq> holmak: Seems to me you've not had enough of the horrors of poorly-done UNIX packaging.
20:28:18 <dolio> Whatever that actually means.
20:28:21 <applicative> holmak, let us all praise cabal
20:28:39 <applicative> dolio, it doesn't mean anything, surely
20:29:12 <holmak> pikhq: I use Ubuntu, so I am mostly sheltered
20:29:21 <diegoviola> So Haskell is not pure functional?
20:29:34 <pikhq> holmak: Ah, yes, a distro with relatively good foundations.
20:29:47 <zaltekk> dolio: usually it means that user created types and builtin types both have the same full functionality....and those that are limited aren't "first class"
20:29:54 <applicative> diegoviola: I think our crowd is refusing to allow a conception of purity that will permit them to say anything like that
20:29:56 <kmc> diegoviola, what people mean by "haskell is pure functional" is something totally different from "ruby is pure oop"
20:29:57 <zaltekk> meaning there are "better" ones
20:30:04 <kmc> it's also just not worth arguing about
20:30:10 <HairyDude> I like this SPJ presentation http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-retrospective/HaskellRetrospective.pdf
20:30:25 <dolio> Well, I don't think that's what it's meaning here, because there aren't really any non-first-class types in that sense.
20:30:26 <kmc> "Haskell is pure functional" means "applying functions can't cause a side effect"
20:30:29 <dolio> In Haskell.
20:30:47 <kmc> and "if x=y then f(x) = f(y), now and forever"
20:30:54 <zaltekk> i don't know that the term applies the same way
20:30:57 <kmc> functions act like functions from math
20:31:21 <applicative> diegoviola, what kmc is saying is the principal point
20:31:22 <kmc> you can write programs that have effects in Haskell, of course
20:31:29 <kmc> but you use something other than functions
20:31:56 <HairyDude> applying functions never causes a side effect. A funciton might cause a side effect, but applying the function isn't how you make it do that.
20:32:09 <kmc> no, a function cannot "cause a side effect"
20:32:16 <kmc> a function can return a description of an effect
20:32:21 <applicative> if i say 'in haskell, everything is referentially transparent', would that be especially stupid?
20:32:29 <HairyDude> ok, a value may cause a side effect
20:32:40 <kmc> no -- functions are values
20:32:52 <kmc> an IO action *describes* a side effect
20:33:07 <HairyDude> I find that unnecessarily pedantic.
20:33:17 <kmc> the effect is not performed until something external to your program (e.g. the runtime system) reads that description and decides to carry out the actions so described
20:33:24 <applicative> putChar 'c' is an IO action, what does it describe?
20:33:37 <kmc> HairyDude, i'm sorry you do.  it's a really important distinction between the way Haskell handles IO and the way almost every other language does.
20:33:41 <pastorn> zaltekk: are you understanding anything?
20:33:45 <monochrom> this debate is as pointless as the one about "my C code does blah" "no, the computer that runs a compiled version of your C code does"
20:33:47 <applicative> putStrLn "The moon is full" describes the moon
20:33:55 <HairyDude> what monochrom said
20:34:14 <kmc> maybe a more productive thing to say is: in Haskell, evaluation ≠ execution
20:34:20 <kmc> evaluation doesn't trigger side effects
20:34:23 <HairyDude> that I can agree on.
20:34:29 <kmc> doesn't matter if you evaluate an Int, a function, or an IO action
20:34:30 <zaltekk> pastorn: yes. i haven't gotten that far yet, though. watching a movie atm.
20:35:08 <monochrom> and no, the electrons that pass through your computer does all the work
20:35:08 <applicative> diegoviola: see, if you had some sensible piece of code, we could be giving you intelligible advice....
20:35:47 <kmc> diegoviola, most languages use functions for three separate roles: argument dependence, performing effects, and delaying evaluation
20:35:53 <pastorn> zaltekk: anything good?
20:36:07 <kmc> diegoviola, Haskell has a different mechanism for each of these three
20:36:26 <diegoviola> i see
20:36:28 <diegoviola> thanks
20:36:30 <applicative> kmc, suppose we renamed IO "SideEffect", I don't think that would be wrong
20:36:34 <HairyDude> what languages use functions for delaying evaluation?
20:36:48 <applicative> type SideEffect a = IO a
20:36:54 <kmc> HairyDude, how would you implement a lazy list in Python or Java or C?
20:36:56 <pikhq> HairyDude: Any strict language with closures.
20:37:00 <applicative> that's the perfect name for the type
20:37:10 <kmc> applicative, i'm fine with that
20:37:13 <zaltekk> pastorn: Red Riding Hood. it's pretty interesting. about an hour in. or if you meant the language, I've gotten as far as list comprehensions in Programming in Haskell.
20:37:15 <HairyDude> applicative: well, you can get side effects in ST (though not ones that leak out to the outside world)
20:37:26 <applicative> ST is over my head I grant
20:37:26 <kmc> but that's still "x is a side effect" vs "x does a side effect"
20:38:07 <kmc> and some would take issue with the "side" part, since effects are their only purpose, but that's too pedantic even for me ;P
20:38:13 <pikhq> HairyDude: Yeah, but you can consider ST as a monad which happens to run a stateful machine emulator. :P
20:38:20 <HairyDude> kmc: C, I dunno. Python, by overriding whatever the special method is called that lets you reimplement array indexing
20:38:32 <applicative> yes, the use of 'side' in this connection is a historical matter.
20:38:37 <HairyDude> kmc: same in C++, define operator[]()
20:38:40 <pikhq> Which just so *happens* to be cleverly implemented more directly for efficiency purposes.
20:38:44 <kmc> HairyDude, that's just syntax
20:39:02 <kmc> anyway you said it, you define a method, i.e. a function
20:39:08 <HairyDude> kmc: using yield, then
20:39:23 <pikhq> HairyDude: "Lazy".
20:39:41 <kmc> "yield" is also sugar
20:40:05 <hellertime> is there a standard library version of concatMapM, I found this in the Agda2 sources: concat <$> traverse f xs
20:40:15 <kmc> hellertime, maybe in Traversable?
20:40:16 <hellertime> but is there some reason its not stadard?
20:40:17 <HairyDude> what exactly do you mean by "lazy list" then?
20:40:36 <pikhq> HairyDude: A list with the precise semantics of the Haskell type [a], presumably.
20:40:46 <pikhq> Well, set of types [a].
20:40:49 <kmc> i mean a thing which somehow produces values on demand, according to some computation, without performing the whole computation at once
20:41:26 <kmc> functions will clearly be involved
20:41:51 <HairyDude> right, I see.
20:42:04 <hellertime> ugh. can I just say that I hate that hackage uses Google search. every time I go to edit my search, google instant kicks in and screws everything up
20:42:05 <c_wraith> @hoogle IO Bool -> IO a -> IO a -> IO a
20:42:06 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
20:42:06 <lambdabot> Control.OldException bracket_ :: IO a -> IO b -> IO c -> IO c
20:42:06 <lambdabot> Control.Exception.Base bracket_ :: IO a -> IO b -> IO c -> IO c
20:42:08 <kmc> a function is the only way to delay some computation until demanded (i.e. called)
20:42:11 <kmc> not so in Haskell
20:43:27 * c_wraith is once again annoyed at the lack of a proper deconstructor for Bool
20:43:33 <HairyDude> because of the call-by-value semantics, I don't think you'd be able to do lazy lists in that sense (i.e. lazy elements as well as tail) without requiring a lot of boilerplate from the programmer.
20:44:10 <kmc> right
20:44:22 <hellertime> foldMap is a bit like a concatMapM
20:44:35 <kmc> :t \f -> concat <$> mapM f
20:44:36 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
20:45:17 <kmc> HairyDude, in Python the difference between ordinary lists and generators is quite user-visible, and causes all manner of trouble
20:45:21 <pikhq> HairyDude: Yeah, the term for it is "thunks", and it is quite a bit of boilerplate.
20:45:25 <monochrom> many C programs contain re-inventions of lazy lists
20:45:48 <kmc> if you use functions to delay computations, then forcing requires an explicit function call
20:45:50 <applicative> hellertime, it seems there have been many requests for concatMapM
20:45:55 * BMeph wonders why c_wraith doesn't just write "a proper deconstructor", put it on Hackage, and Quits Whinging already! ...idly speculating. ;)
20:46:03 <monochrom> some of their authors are really pround of their boilerplates
20:46:11 <c_wraith> BMeph: no one would use it, because it's "not standard". :)
20:46:45 <HairyDude> more fool them. boilerplate is a symptom of insufficient abstraction, usually :)
20:46:51 <applicative> hellertime: I am seeing a very pleasing looking concatMapP :: (a -> [:b:]) -> [:a:] -> [:b:]
20:46:54 <kmc> monochrom, almost every C program contains re-inventions of lists, period
20:47:00 <kmc> i.e. linked lists
20:47:06 <kmc> also reinvention of binary search, with the canonical bug
20:47:09 <HairyDude> linked lists, definitely.
20:47:18 <danharaj> What is the canonical bug of binary search? :p
20:47:28 <kmc> though these days many C programs contain a copy of linux's list.h pasted somewhere ;P
20:47:29 <applicative> is this a trick question
20:48:01 <HairyDude> C++ seems like a step up from C if only because of the polymorphism that comes with templates.
20:48:07 <HairyDude> I say seems, not saying it actually is :)
20:48:09 <hellertime> applicative: never seen that syntax before
20:48:16 <kmc> yes, C++ seems like a good idea when you start learning it
20:48:23 <applicative> parallel lists
20:48:23 <kmc> that's part of what makes it such a brilliant esolang
20:48:28 <dolio> [:a:] is a parallel array of as.
20:48:28 <BMeph> c_wraith: If you never write it, we'll never be able to roust you in the middle of the night and bitch about your library, like we do dons and edwardk...I mean, we won't be able to sing your praises! ;)
20:48:34 <danharaj> C++ is a Turing Tarpit
20:48:35 <applicative> arrays rather
20:48:42 <c_wraith> BMeph: anyway, I think it's already on hackage :)
20:48:44 <kmc> danharaj, the canonical bug is, you need to find the midpoint between i and j, so you do (i+j)/2
20:48:50 <kmc> er
20:48:51 <kmc> not quite
20:48:59 <kmc> (j-i)/2
20:49:00 <c_wraith> @hackage bool-extras
20:49:01 <lambdabot> http://hackage.haskell.org/package/bool-extras
20:49:09 <HairyDude> kmc: esolang?
20:49:16 <kmc> fuck, i forgot what the bug is
20:49:18 <kmc> HairyDude, yes
20:49:28 <HairyDude> what does that mean?
20:49:31 <kmc> C++ is an esoteric language like Brainfuck or Malbolge
20:49:38 <HairyDude> ahh, right
20:50:03 <pikhq> Particularly its polymorphism.
20:50:04 <applicative> c_wraith which of those is the desired destructor, or none?
20:50:10 <c_wraith> applicative: bool is
20:50:50 <pikhq> (seriously, polymorphism via type-level lambda? That's freaking nuts.)
20:50:57 <applicative> thats what I thought.
20:50:58 <BMeph> bool :: a -> a -> Bool -> a
20:50:59 <kmc> pikhq, tell that to an agda programmer
20:51:03 <kmc> http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html
20:51:05 <kmc> i had it right the first time
20:51:09 <monochrom> I don't know how to code up the exact bug either, since I can only write correct programs, but the bug has to do with a sloppy formula for midpoint that can give you one of the endpoints again and get you into an infinite loop
20:51:10 <kmc> the midpoint is (low+high)/2
20:51:23 <kmc> which will overflow on arrays that are otherwise small enough
20:51:34 <applicative> c_wraith, if then else is the bastard version of bool
20:51:36 <monochrom> oh sorry, nevermind
20:51:36 <kmc> low + (high-low)/2 should be fine
20:51:50 <kmc> the Linux kernel alone contains a dozen implementations of binary search
20:51:55 <HairyDude> c_wraith: go back to untyped lambda-calculus, then every bool is its own destructor :D
20:52:14 <c_wraith> applicative: right.  the problem is if-then-else is horrible :)
20:52:31 <BMeph> applicative: Not true; if-then-else is a syntactic construct that's converted into a "case" expression.
20:53:02 <monochrom> not necessarily converted
20:53:36 <monochrom> I recommend "equivalent to"
20:53:42 <applicative> BMeph, no I was only interpreting c~wraith's rage, not making a scientific statement
20:53:53 * dolio doesn't really understand why if-then-else gets so much hate.
20:54:01 <c_wraith> "rage" might be overstating it a bit
20:54:03 <c_wraith> :)
20:54:14 <applicative> c_wraith's wrath
20:54:17 <BMeph> applicative, c_wraith: It's a bastard version of an expression that does what "bool"ought to, just clunkier. I blame it for Global Warming; that's how much I Hate it! ;þ
20:54:21 <c_wraith> dolio: it's just really verbose...  And isn't a higher-order function
20:54:37 <c_wraith> Heck, it's just not a function
20:54:37 <HairyDude> huh, what does bool do if not the same thing as if-then-else?
20:54:39 <c_wraith> higher-order or not
20:54:44 <dolio> I'm not against there being a 'bool' or something.
20:54:50 <HairyDude> (besides being not first class)
20:55:01 <c_wraith> being first-class is the point
20:55:14 <dolio> But I'd rather have if-then-else in general than only some if function.
20:55:29 <BMeph> HairyDude: Not being first-class if kind of the po...never mind. :)
20:55:37 <HairyDude> agreed, I dislike a scheme-like if, personally
20:55:47 <applicative> dolio, but surely you find the typical agda definition more pleasing than an inbuild if then else
20:56:03 <HairyDude> I like agda's if_then_else_, it's also first class :)
20:56:12 <monochrom> programmers hate things irrationally. if-then-else, position of capslock, colour scheme of ubuntu, borders of mac os x windows, fonts chosen by firefox, command line syntax of gcc... the list goes on and on
20:56:30 <zmv> but if is a macro not a function... oh, wait, I'm on #haskell, not #lisp/#scheme :P
20:56:33 <applicative> the color scheme of ubuntu is horrible!
20:56:36 <c_wraith> hey, hate of gcc command-line syntax is totally rational! :)
20:56:46 <BMeph> Hate is irrational. Done. ;þ
20:56:48 <dolio> applicative: If it could be defined, that'd be nice. But it can't in Haskell.
20:56:48 <HairyDude> the colour scheme of ubuntu was fine before it went orange
20:56:52 <pikhq> monochrom: I limit myself to rational hatred.
20:57:07 <pikhq> The command line syntax of GCC is one of the *least* horrible things about that compiler.
20:57:22 <dolio> I like 'if e1 then e2 else e3' better than 'if (e1) (e2) (e3)', though.
20:57:50 <zmv> inline? yeah
20:58:04 <HairyDude> or scheme (if (long expression) [many lines later] (which branch was this again?)) (oops I forgot the else)
20:58:07 <monochrom> if (e1) { e2 } else { e3 }
20:58:18 <BMeph> dolio: How do you feel about the hackish "if e1 Then e2 Else e3"? :)
20:58:26 <applicative> I don't really like it, I think you have to have come to it as a programmer. Its apparantly intuitive character is fake.
20:58:40 <dolio> BMeph: How is that solving the problem?
20:58:50 <HairyDude> BMeph: if being a reserved word, it wouldn't quite work :)
20:58:57 <HairyDude> </pedant>
20:59:03 <dolio> Do the Then and Else magically generate parentheses in the right places?
20:59:05 <applicative> it is only intelligible where e2 and e3 are commands
20:59:20 <zmv> HairyDude: that's what you have indentation for :P
20:59:34 * BMeph makes an "eef" function, just to satisfy HairyDude's pedantic scanner... ;þ
20:59:49 <HairyDude> :)
21:00:08 <HairyDude> zmv: because indentation lets you just as easily recognise the correct branch as an "else" keyword, right
21:00:20 * BMeph then puts his "eff" on a steek! :D
21:00:49 <HairyDude> tbh this rant is as much against Lisp non-syntax as my dislike of if-then-else sans then and else
21:01:01 * BMeph "obvoiusly" meant "eef" and not "eff" 'cause that's effing ineffable...never mind!
21:01:07 <applicative> the more I think about it, the more I want to use bool, not if then else
21:01:11 <dolio> BMeph: It seems like your suggestion is 'if (e1) Then (e2) Else (e3)', which is even worse than the regular function. :)
21:01:22 * BMeph looks at his cotsant mistypes, and sighs...
21:01:48 <monochrom> s/cotsant/constant/ :)
21:02:19 <BMeph> monochrom: Great, you caught the only one I did on purpose... Figures. ;þ
21:02:26 * hackagebot encoding 0.6.6 - A library for various character encodings  http://hackage.haskell.org/package/encoding-0.6.6 (KangyuanNiu)
21:03:25 <applicative> the characterization of bool :: a -> a -> Bool -> a as a 'fold' is very pleasing
21:03:28 <monochrom> I wonder what's new in this new version of encoding
21:04:48 <applicative> MacOSGreenlandish
21:04:49 <luite> I want automatic diffs on hackage!
21:05:20 <tsuraan_> what do people typically use for a ring buffer in haskell?  I'm trying to write a rolling hash, and the enqueue/dequeue operations on Data.Sequence are taking more time than my actual hash calculations
21:05:34 <HairyDude> bool is a catamorphism
21:05:39 <kniu> monochrom, absolutely nothing
21:05:47 <dankna> "ring buffer" actually has a meaning in audio processing, different from what you'd expect
21:05:51 <dankna> you mean "circular buffer"
21:05:59 <BMeph> applicative: It's not a 'fold', it's a reduction! It's an AwesomeSauce reduction! ;þ
21:06:01 <dankna> and I haven't done that in Haskell yet but I'd look at unboxed arrays
21:06:03 <kniu> monochrom, I just removed some stuff to make it compile in ghc 7
21:06:06 <tsuraan_> ok
21:06:10 <monochrom> heh
21:06:15 <tsuraan_> I'll have a look for that
21:06:30 <applicative> @type either
21:06:30 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
21:06:38 <applicative> @type maybe
21:06:39 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
21:06:40 <monochrom> \∩/ for removing things
21:07:14 <HairyDude> removing things is good
21:07:26 <monochrom> I haven't used a ring buffer in haskell. but I would use an array
21:08:22 <applicative> either and maybe don't look so much like folds.
21:08:47 <tsuraan_> so an Array in the ST monad is going to act just like C array?  that sounds about perfect
21:09:18 <kniu> wait, what
21:09:18 <dankna> I haven't used ST, but yes
21:09:20 <kniu> really?
21:09:24 <dagit> preflex: seen ezyang
21:09:24 <preflex>  ezyang was last seen on #haskell 6 hours, 11 minutes and 25 seconds ago, saying: (same with emacs, if that's how you swing)
21:09:29 <dagit> ezyang: ping?
21:09:32 <kniu> STUArray, you mean?
21:09:43 <tsuraan_> yeah, that one :)
21:09:51 <tsuraan_> still reading the wiki page
21:10:06 <tsuraan_> it's quite a page
21:10:15 <applicative> tsuraan_ what are you putting in these arrays?
21:10:31 <kmc> you can also use IOUArray
21:10:34 <tsuraan_> Word8's
21:10:36 <kmc> that may be easier to wrap your head around
21:11:03 <monochrom> just stretch the meaning of "like"
21:11:44 <kmc> you can use mutable arrays for pure computation with IO + unsafePerformIO
21:11:49 <kmc> ST is a subset of IO for which the equivalent to unsafePerformIO equivalent is safe
21:12:00 <HairyDude> eww, unsafePerformIO
21:12:38 <tsuraan_> is there an advante to using IO that way instead of ST?  My code is currently entirely pure, but really slow
21:13:05 <monochrom> no advantage to using IO if you don't actually do I/O
21:13:21 <kmc> GHC implements IO and ST in an identical way
21:13:35 <kmc> at run-time, i mean
21:13:37 <HairyDude> ST gives you local side effects that go away when you do runST (or whatever it's called)
21:14:09 <kmc> the difference is that runST is safety-checked at compile-time, while unsafePerformIO is... unsafe
21:14:40 <HairyDude> ST is H'98, right?
21:14:44 <monochrom> no
21:14:45 <kmc> no
21:14:46 <HairyDude> oh.
21:14:49 <kmc> runST has a rank-2 type
21:14:50 <monochrom> not even 2010
21:15:06 <monochrom> haskell 2100 will have ST
21:15:09 <applicative> is it clear tsuraan_ needs something that will involve going into a monad?
21:15:16 <tsuraan_> for sanity's sake, if you do something like modifySTRef bs (BS.foldl...) on a bytestring, it won't do in-place modification of that bytestring, right?
21:15:18 <applicative> @type runST
21:15:19 <lambdabot> forall a. (forall s. ST s a) -> a
21:15:24 <kmc> tsuraan_, correct
21:15:31 <tsuraan_> ok
21:15:38 <kmc> you *can* modify bytestrings in place, but you really shouldn't, because the rest of the bytestring code assumes you won't
21:15:39 <tsuraan_> it's not magical.  just making sure :)
21:15:56 <kmc> but you can pass a bytestring into a C library as a raw Word8 array
21:16:00 <kmc> presuming that library won't modify the array
21:16:02 <kmc> and that is very useful
21:16:34 <tsuraan_> bytestrings are length-tagged though, right?
21:16:39 <kmc> yes
21:16:58 <kmc> a bytestring is implemented by a (pointer, length, offset) triple
21:17:05 <kmc> that's why you can slice them efficiently
21:18:29 <kmc> tsuraan_, another way to answer your sanity check question is: values never change in-place.  IORef and STRef don't violate this rule
21:18:30 <applicative> Data.Vector.Unboxed has a Word8 instance, maybe that would be of use
21:18:42 <kmc> ahh, vector.  yes, take a look at vector
21:18:57 <monochrom> I wonder if a priority queue is fast enough when used as a ring buffer
21:19:30 <kmc> do you need the priority bit?
21:19:50 <tsuraan_> no, no need for priorities
21:20:07 <tsuraan_> I'm just rolling a window along a bytestring
21:20:34 <tsuraan_> vector looks cool
21:20:47 <kmc> well, you can implement a queue without mutable state
21:20:51 <applicative> there is the beginning of a tutorial on it
21:20:54 <kmc> http://www.randomhacks.net/articles/2007/02/08/haskell-queues-without-pointers
21:21:04 <kmc> Okasaki's book has several examples
21:21:06 <applicative> http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial
21:21:46 <kmc> tsuraan_, if you are rolling a window along an existing bytestring, why do you need to copy the data into an array?
21:22:01 <monochrom> ah, I was drunk, normal queue already plays fine as a ring buffer
21:22:15 <kenjin2201> Hello, I'm new to Haskell. I want to install haskell-platform on Ubuntu but it fails. It has dependency issues.
21:22:18 <applicative> tsuraan_ I don't know if there's anything in it that would work for you, but I do find Data.Vector.Unboxed makes everything faster than I deserve it to be....
21:22:44 <monochrom> kenjin2201: what exact command did you attempt?
21:22:57 <kenjin2201> sudo apt-get install haskell-platform
21:23:10 <monochrom> then sorry I don't know
21:23:17 <tsuraan_> kmc: I'm using ByteString.foldl to iterate along the bytestring; that doesn't give me an index, so I'd have to keep track of my position in the string so I can access previous elements.  I should probably see how that performs, I guess
21:23:27 <argiopeweb> kenjin2201: Unless the dependencies are directly Haskell related, it's best to ask in #Ubuntu.
21:23:31 <applicative> damn, kenjin2201 that should work.  have you installed ghc before?
21:23:43 <kenjin2201> applicative // yes
21:23:44 <monochrom> but note that it depends on which version of ubuntu
21:23:49 <argiopeweb> Indeed.
21:23:56 <kenjin2201> 11.04 64bit
21:23:58 <tsuraan_> applicative: I'll read up on Data.Vector.  Looks like I have plenty of reading material for a bit
21:24:38 <argiopeweb> kenjin2201: Isn't that beta still?
21:24:48 <kmc> tsuraan_, you can generate the list of (start, end) pairs you want, and map a slicing function over those
21:24:53 <monochrom> officially released on April 28
21:24:55 <kenjin2201> It's not beta anymore
21:25:05 * argiopeweb doesn't keep up with Ubuntu at all...
21:25:08 <applicative> kenjin, I wonder if a pre-exising ghc might mess with 'apt-get install haskell-platform'
21:25:28 <kmc> tsuraan_, ByteString is *already* an unboxed array of Word8.  i don't think you'll produce faster code by first copying the whole array
21:25:50 <kmc> if the obstacle is just that foldl doesn't give you the index, that's easy enough to fix
21:25:52 <kenjin2201> I've tried first removing ghc and install but failed.
21:26:17 <argiopeweb> kenjin2201: Maybe --reinstall might fix you?
21:26:17 <kenjin2201> Thank you for your interest, maybe I should ask in #ubuntu
21:26:47 <tsuraan_> kmc: I don't keep a copy of the bytestring, just the part in the window.  And really, all I want is the last value in the window so when I update my hash with the new word8 I can pull out the old word8 that isn't in my window anymore
21:27:20 <tsuraan_> I should really just keep track of my index in the bytestring and look up the value of the recently-booted item as the window slides
21:27:25 <kmc> *nod*
21:27:30 <kmc> sounds good
21:27:48 <tsuraan_> @hoogle ByteString -> Word8
21:27:49 <lambdabot> Data.ByteString head :: ByteString -> Word8
21:27:49 <lambdabot> Data.ByteString last :: ByteString -> Word8
21:27:49 <lambdabot> Data.ByteString maximum :: ByteString -> Word8
21:27:57 <tsuraan_> @hoogle ByteString -> Int -> Word8
21:27:58 <lambdabot> Data.ByteString index :: ByteString -> Int -> Word8
21:27:58 <lambdabot> Data.ByteString.Unsafe unsafeIndex :: ByteString -> Int -> Word8
21:27:58 <lambdabot> Data.Data gmapQi :: Data a => Int -> (d -> u) -> a -> u
21:28:11 <applicative> kenjin2201: there was a long thread on ubuntu 11.04 http://www.haskell.org/pipermail/haskell-cafe/2011-May/092188.html It is mostly boring at first, but then maybe some wisdom toward the end
21:28:18 <tsuraan_> I'll try that out and see where my next bottleneck is.  thanks a ton!
21:28:26 <kmc> good luck :)
21:28:40 <tsuraan_> thanks :)
21:28:53 <kenjin2201> applicative: Thank you, I'll read it
21:30:15 <applicative> here's the guy with smashing success http://www.haskell.org/pipermail/haskell-cafe/2011-May/092203.html but note he had a fresh install of ubuntu
21:31:16 <monochrom> heh, but it circumvents apt-get altogether
21:32:42 <applicative> monochrom, yes, I noticed, how bad an idea is that?
21:32:59 <monochrom> I do it, so it cannot be bad :)
21:33:31 <applicative> in a previous like, monochrom was a package manager
21:35:20 <monochrom> but that' thread's original poster's problem is clearly some previously installed thing getting in the way
21:35:59 <luite> what's the recommended method to automatically install a cabal package in specific directories that require superuser privs ( /etc/app, /usr/bin, /var/lib/app etc), without requiring the user to build that package with --global?
21:36:02 <applicative> yes, i think that was why it came into  my head to ask kenjin2201 if he'd already installed ghc.
21:36:11 <monochrom> "blah blah is unusable due to missing or recursive dependencies blah blah" cannot possibly happen on a clean system. you must taint your system first to get it
21:36:38 * ddarius finds monochrom's fascination with this topic odd.
21:36:59 <monochrom> but in case of apt-get, if /usr/bin has higher priority than /usr/local/bin, then pre-existing things (in /usr/local) does not get into the way either
21:37:03 <applicative> monochrom installs a fresh os every morning
21:37:35 <ddarius> No, monochrom knows how not to hose his system.
21:37:50 <kmc> if y'all used NixOS
21:37:51 * dankna uses cabal-install exclusively to install Haskell-related stuff
21:37:53 <stephenjudkins> is there a term for this property of a binary tree: the internal representation for a tree given a set of elements is independent of the order of insertion.
21:37:54 <kmc> you wouldn't have this problem
21:37:59 <tgeeky> monochrom changes his / more often than you change your underwear
21:38:02 <stephenjudkins> Okasaki's red-black trees do not have this property
21:39:03 <kmc> NixOS is such a cool idea.  i'm holding off installing it because of the inevitable disappointment
21:39:35 <applicative> you want to save the inevitable disappointment for last, to savor it?
21:39:54 <ddarius> If he never installs it, he'll never be disappointed.
21:40:00 <kmc> exactly
21:40:04 <dankna> Schroedinger's disappointment
21:40:13 <dankna> or perhaps lazily-evaluated disappointment
21:40:18 <monochrom> what? cabal-install's bootstrap.sh crashes for that guy too?
21:40:34 <kmc> this is why the best theoretical computer scientists never get computers
21:40:38 <monochrom> well, I'll just conclude bad RAM and bad disk and overclocked cpu
21:40:56 <applicative> alonzo church never had one
21:41:09 <kmc> cosmic rays!
21:41:12 <kmc> http://blog.ksplice.com/2010/06/attack-of-the-cosmic-rays/
21:41:20 <applicative> they tried to interest him in a Lisp Machine...
21:41:47 <applicative> he said "I had a student once who was interested in these computer things ...."
21:42:06 <monochrom> ok, the guy confesses that he failed to nuke .ghc when he whined
21:42:51 <applicative> like you didn't fail to nuke .ghc the first time you uninstalled! ha!
21:43:16 <applicative> well, maybe *you* did
21:45:24 <ClaudiusMaximus> any simple/elegant way to redirect all my stderr debug printing from the terminal into somewhere else in my application (like a gtk textview)?  or should i pass a logging callback everywhere?
21:46:05 <liyang> 0
21:46:07 <liyang> ...............
21:46:25 <dankna> no simple/elegant way that I'm aware of, except maybe forking at the start and redirecting the child's output?
21:46:32 <dankna> pass the logging callback, it's cleaner
21:46:54 <ClaudiusMaximus> dankna: ok
21:47:04 <monochrom> no, .ghc is ignored when building haskell platform from source normally, because the build scripts normally do --global
21:47:27 <ClaudiusMaximus> dankna: that'll also enable me to tag different types of log messages and filter at display time, so i guess it's a win
21:47:41 <dankna> yeah, it is
21:47:43 <kmc> that shouldn't necessarily require a fork
21:48:11 <dankna> yeah, maybe it doesn't, but I still think the callback is better
21:48:18 <ClaudiusMaximus> plus on the rare chance that someone else wants to try my code, and happens to be on windows, and disables the cmd window, it won't explode
21:50:47 <kmc> redirecting actual stderr is not likely to be cross-platform, anyway
21:51:43 <ClaudiusMaximus> oh noes, i just realized my mandelbrot set renderer draws everything reflected in the real axis
21:51:51 <dankna> heh
21:51:59 <dankna> uh
21:52:04 <dankna> isn't it symmetric along the real axis
21:52:06 <dankna> how did you realize it :)
21:52:17 <ClaudiusMaximus> from the stderr debug printouts
21:52:19 <ClaudiusMaximus> :)
21:52:20 <dankna> ah
21:52:22 <dankna> haha
21:53:09 * BMeph joins in: "Yeah, his name is Bob, but everyone always spells it backwards..." ;þ
21:53:33 <dankna> amusement
21:53:37 <ddarius> boB
21:53:45 <dankna> O(3) slowdown :)
21:55:34 <kmc> O(3)? that's over 9000!
21:56:23 <ddarius> 9000! is quite a bit.
21:56:25 <ClaudiusMaximus> i need a way to tell the renderer that it's work isn't needed any more and cancel/abort - just had one tile that took 5M iterations using one core, when i'd already zoomed in a few more times so that tile wouldn't have been displayed when it finished...
21:56:47 <dankna> what nine thousand
21:56:52 <kmc> asynchronous exceptions?
21:57:10 <dankna> yeah, you can send an exception to a thread
21:57:21 <kmc> it's not the nicest thing to do
21:57:24 <ClaudiusMaximus> right, but this is foreign code :(
21:57:34 <kmc> did you write it?
21:57:38 <ClaudiusMaximus> yes
21:57:46 <dankna> oh
21:57:51 <luite> send it a SIGKILL
21:57:54 <dankna> well, hm
21:58:03 <dankna> are you running all in one process?
21:58:06 <ClaudiusMaximus> yes
21:58:10 <dankna> hm
21:58:20 <kmc> what language?
21:58:31 <ClaudiusMaximus> C++
21:58:32 <kmc> you could make it check some boolean periodically
21:58:38 <ClaudiusMaximus> kmc: right, that's what i'm thinking
21:58:39 <dankna> ah - yes, what kmc said
21:58:48 <luite> yes, wat dankna said
21:58:58 <ClaudiusMaximus> but i need to know which jobs are in progress and where the boolean is...
21:58:59 <dankna> luite: you should follow symlinks when doing that!
21:59:10 <applicative> have you found any small villages or exotic fauna, zooming in on the mandelbrot set?
21:59:21 <kmc> your C++ code runs in the context of a GHC FFI thread? or does it spawn its own threads on the C++ side?
21:59:23 <dankna> living in a fractal would be really boring
21:59:36 <dankna> "Ho hum.  I guess I could go on vacation.  But all these foreign places look the same."
21:59:40 <ClaudiusMaximus> kmc: just regular FFI, no pthreads or anything
22:00:54 <dankna> the signature of the top-level C++ code should be something like
22:01:05 <dankna> JobInformation -> Ptr Bool -> IO ()
22:01:34 <monochrom> living in this world is already boring to me in that sense. I go to several "scenic places, great view, must go look" and they are all the same green land blue sky blue water to me.
22:01:57 <dankna> monochrom: yeah, but imagine how much worse it would be in a Mandelbrot set :) but yeah, that's why you have to visit the actual people
22:02:18 <kmc> heh dankna
22:02:18 <kmc> but your own house would be as interesting as the entire world
22:02:19 <kmc> also you can find things in mandelbrot that look like the overall set, but weirdly different
22:02:20 <kmc> it's not as rigidly self-similar as, say, the sierpinski triangle
22:02:23 <monochrom> the people are isomorphic to each other, too
22:02:43 <dankna> monochrom: only at a very high level.  pay more attention to detail :)
22:02:46 <dankna> kmc: hahaha yeah true enough
22:03:46 <kmc> it's like living on one of those islands in Dubai that's shaped like a continent
22:03:47 <ClaudiusMaximus> i like the layers of features that emerge when you zoom past different embedded copies of the set
22:04:01 <kmc> if you get the island that contains the UAE do you have your own swimming pool with miniature islands in it
22:04:21 <kmc> anyway i prefer julia sets myself
22:04:35 <ClaudiusMaximus> example of such layers http://claudiusmaximus.goto10.org/g/mandelbrot/emndl/emndl-0.1.png
22:04:36 <dankna> I like quaternion Julia fractals :)
22:04:37 <kmc> they're more symmetric, and it's a whole family of interesting sets
22:04:42 <dankna> they are gorgeously textured
22:04:44 <kmc> and the mandelbrot set is a map of that family
22:04:46 <kmc> dankna, yes!
22:04:49 <kmc> they look like taffy
22:04:52 <dankna> yep!
22:05:01 <dankna> and they animate in interesting ways if you move the control point, too!
22:05:20 <kmc> there was a cool GPU renderer for those
22:05:23 <dankna> yep
22:05:25 <dankna> indeed
22:05:56 <dankna> ClaudiusMaximus, that's a pretty neat image.  indeed as you say it's unique.
22:06:14 <dankna> if I wanted fractal-based art for a webpage sidebar, I'd use it :D
22:07:03 <ClaudiusMaximus> dankna: i got the idea from http://mrob.com/pub/muency/exponentialmap.html
22:07:23 <dankna> ah indeed
22:07:36 <dankna> I also, by the way, like that coloring algorithm that produces those purty blocks
22:08:02 <dankna> I think it's something like the last bit of how many iterations the outside area diverges in, or something
22:08:34 <dankna> oooh that's a neat image too
22:08:46 <ClaudiusMaximus> yep, the tiled renderer i'm working on uses that (also using code from mrob) - the rings are from odd/even count of iterations, the radial lines are from the final iterate's atan2 being positive or negative
22:09:40 <dankna> nice
22:10:15 <dankna> I notice that this mrob page you linked to also does something with hue
22:10:17 <dankna> do you know what that is?
22:12:42 <ClaudiusMaximus> the glsl shader i'm using is based on some C code he sent me - it stretches the hue component of hsv colour space to give a more perceptually-uniform spread - in my tiled renderer i'm using log(iteration count) for the pre-warped hue
22:12:54 * dankna nods
22:12:59 <dankna> I see!
22:15:07 <ClaudiusMaximus> dankna: and the forthcoming emndl-0.3 release (too many projects, too little time to actually get them releasable..) has an equalizer for iteration counts, some preliminary images here http://claudiusmaximus.goto10.org/g/mandelbrot/period-7-islands/
22:15:20 <dankna> heh I know the feeling
22:15:25 <dankna> oooh fun
22:16:01 <ClaudiusMaximus> need to finish up the 1.0 release of the bindings to qd before i can release anything else (dependency wait)
22:16:13 <dankna> ya
22:16:15 <ClaudiusMaximus> but that's not the most fun stuff
22:17:31 <ClaudiusMaximus> i ended up writing some macro-heavy C to bracket all the libqd functions with fpu_fix_start ... fpu_fix_end  because i worry about something else adjusting fpu flags and wrong results happening all over
22:17:36 <dankna> right
22:18:37 <luite> hmm, I have some   MonadIO m => Request -> m Response handler, and a socket Handle plus a function recvRequest :: Handle -> IO Request,  sendResponse :: Response -> IO ()  . every connection can get an unlimited number of requests
22:18:40 <monochrom> ghc-generated code doesn't adjust fpu flags
22:18:55 <ClaudiusMaximus> monochrom: i know, but some other random foreign library might
22:19:01 <luite> is there a way to handle all requests, that is, accept new connections and wait for requests on all connections?
22:19:03 <monochrom> oh, then oops
22:19:31 <kmc> luite, create a thread for each?
22:19:44 <kmc> i don't totally understand the question
22:19:47 <luite> kmc: yeah that would work if m was IO
22:19:53 <dankna> oh
22:20:02 <dankna> yeah, I required m to be IO in my http server
22:20:15 <kmc> well there's no way to run an arbitrary MonadIO action in IO
22:20:28 <kmc> so i'd say you're kind of screwed without more structure
22:20:33 <kmc> why aren't they just IO actions?
22:21:12 <luite> I know, I was hoping that there was some way to run it in a single thread or something :)
22:22:05 <luite> they have a lot of state, and that is required within the protocol handler
22:22:16 <kmc> you would have the same problem running it within a single thread, no?
22:22:43 <monochrom> forever (do { x <- liftIO (recvRequest h); y <- handler x; liftIO (sendResponse y) })
22:23:02 <luite> monochrom: yes that's a single connection
22:23:31 <kmc> luite, say you're using StateT s IO.  somewhere you call runStateT, right?
22:23:39 <luite> kmc: the only "problem function" is liftIO
22:24:14 <kmc> so these handlers come from elsewhere, and the particular monad they use is supposed to be abstracted out?
22:24:39 <dankna> it might be helpful to define your own typeclass MonadIO m => MonadHandler m
22:24:47 <dankna> which has additional constraints that make what you want possible
22:24:53 <luite> kmc: yes I know. I can decompose the monad stack, but that requires me to patch some packages from hackage
22:25:09 <luite> because they hide the constructors
22:25:10 <monochrom> (hint: hint) :)
22:25:32 <kmc> are all the handlers using StateT?
22:25:40 <dankna> what packages is it?
22:25:59 <luite> oh I see now that the only package I need to patch is hint
22:26:46 <dankna> hmm
22:26:53 <luite> but I'm not sure whether I can completely restore the GHC state
22:27:05 * dagit is causing ghci to segfault but statically linking does not cause it.  Hmmm...
22:27:27 <dagit> I ran ghci inside gdb but it did not help at all...
22:28:31 <kmc> what did you do inside gdb?
22:28:45 <luite> the complete monad is something like ReaderT WolfgangConfig ReaderT (InterpreterT (ReaderT InterpreterSession) (ErrorT InterpreterError (GhcT IO))))
22:28:48 <dagit> bt/whree
22:28:53 <monochrom> how do you get your Handle? I suspect that is a good place to forkIO
22:28:56 <luite> probably missed some parentheses
22:29:05 <kmc> yikes
22:29:06 <luite> monochrom: with a liftIO
22:29:11 <kmc> but, it's a specific monad, yes?
22:29:25 <dankna> yikes that's a big stack
22:29:42 <kmc> so you must have some way to run it, given a config and error handling and a thing to create GHC sessions
22:30:11 <monochrom> why do you even use the same ghc session or hint session for different Handle's?
22:30:35 <luite> yeah it's possible if I patch hint to expose its InterpreterT constructor, and import the GHC API directly (which is much more likely to break with new versions)
22:30:40 <dagit> http://hpaste.org/47457/segfault_in_ghci
22:31:14 <luite> monochrom: because it takes a lot of time to initialize, and a lot of memory
22:31:38 <monochrom> alright, I don't know how to solve it
22:32:18 <kmc> dagit, yeah, i don't expect just running it in gdb to be very enlightening
22:32:26 <kmc> if you want to track this down with a debugger, you'll have to do some serious digging
22:32:31 <dagit> kmc: It has helped me a time or two in the past
22:32:37 <kmc> with ghci?
22:32:41 <dagit> with ghc
22:32:47 <kmc> interesting, how?
22:32:57 <kmc> this may be slightly relevant: http://hackage.haskell.org/trac/ghc/wiki/Debugging/CompiledCode
22:33:02 <dagit> It was crashing in the rts
22:33:10 <kmc> ah, ok
22:33:11 <dagit> which is in C
22:34:03 <dagit> I think I'm doing something wrong between my makefile and my cabal file
22:34:09 <dagit> I think I might post on SO about it
22:34:14 <monochrom> time to suggest the unthinkable: your own epoll loop: http://hackage.haskell.org/package/epoll/
22:34:17 <dagit> someone else may have already tried this
22:35:30 <luite> monochrom: no prob. I've been looking at MonadPeelIO before, but I wasn't able to write the proper instance for it (which would require patching hint and maybe ghc-mtl, but at least it would be a much cleaner solution)
22:35:32 <monochrom> if you just stick with the low-level API of epoll, you can just liftIO everything
22:35:48 <luite> and MonadControlIO does something similar
22:35:58 <fragamus> hey I have a question: I am trying to use liftM but I have a monad transformer stack. Do I have to liftM more than once?
22:36:15 <kmc> no
22:36:23 <kmc> maybe you're confusing 'liftM' with 'lift'
22:36:35 <kmc> the name similarity is regrettable, as they both have to do with monads and are totally different
22:37:10 <monochrom> there are a million unrelated things called "lift" if you study math
22:37:25 <kmc> TH also has an important function named "lift"
22:39:31 <fragamus> http://hpaste.org/47458/fragamus_liftm_wtf
22:40:02 <fragamus> Here I call a pure function and pass in random numbers.
22:44:27 <fragamus> http://hpaste.org/47459/fragamus_cover_function_that_e
22:44:44 <fragamus> I definitely feel that my code sucks
22:44:59 <shurane> this is just a stylistic question, but what's the advantage of '$' over ()?
22:45:01 <fragamus> I think somehow I should be using liftM
22:46:11 <kmc> shurane, you said it yourself: some people prefer that style
22:46:31 <monochrom> your code is fine. there is a way to change it to use liftM; it will become longer.
22:46:46 <kmc> you can just say "return (riff a b coin ...)"
22:47:03 <luite> hmm, a simple solution: use the regular forkIO stuff to listen on the socket, and use a Chan to forward the requests to the main thread with the hint session
22:47:28 <kmc> shurane, writing «f . g . h $ x» has the advantage that «f . g . h» is a useful expression of its own
22:47:42 <kmc> it's common to write a function and then refactor it to be points-free
22:47:52 <kmc> in which case you'd just delete "$ x" instead of a whole bunch of parentheses
22:48:28 <kmc> luite, ah, i like that idea
22:48:40 <kmc> you don't need concurrency of the interpreter itself?
22:48:58 <kmc> shurane, also ($) is a real infix operator so you can use it in sections, e.g.
22:49:02 <kmc> > map ($ 3) [succ, pred]
22:49:03 <lambdabot>   [4,2]
22:49:19 <luite> kmc: I don't think that's possible with the ghc api
22:49:49 <kmc> :(
22:50:22 <shachaf> Hmm, type a :$ b = a b works.
22:50:35 <kmc> you could accomplish it with an old-school forking server, anyway
22:51:03 <kmc> shachaf, does it require -XTypeOperators?
22:51:04 <dankna> though it would be difficult.  forkProcess kills all threads but the main one, in the child.
22:51:11 <luite> kmc: oh, this process doesn't handle the requests directly, it forks (forkProcess) into new processes that actually do the interpretation work (and that causes exactly the same issue with IO and forking, and I can't work around it with a Chan there)
22:51:11 <dankna> er, by main one I mean the caller
22:51:33 <kmc> oh
22:51:48 <kmc> dankna, ok.  what happens if you naively call fork(2)
22:52:05 <dankna> kmc: then you run into rts limitations which are the reason that forkProcess has that semantic.
22:52:14 <luite> hehe I already tried modifying the forkProcess ghc primitive
22:52:28 <dankna> yeah, I vaguely recall there's a helpful comment there that explains why you can't do what you want :)
22:52:33 <dankna> I tried it too haha
22:52:33 <luite> but decided that that wasn't a terribly great solution ;p
22:52:59 <shurane> kmc, apparently parentheses isn't a problem if you have a cool bracketing system like paredit.pl for emacs
22:53:18 <monochrom> haha, when luite finally finishes this project, he will have patched half of hackage and a quarter of ghc :)
22:53:21 <dankna> yay for paredit
22:54:18 <monochrom> wait, paredit.pl for emacs? not paredit.el?
22:54:34 <shachaf> kmc: Yes.
22:54:45 * shachaf didn't realize that was an extension.
22:54:56 <luite> I still wonder why forkProcess cannot behave more like the regular fork call, I don't really need more than one thread there, so it would actually solve my prob
22:55:31 <luite> if you could use: pid <- fork
22:55:46 <luite> instead of   fork actionToRunInChild
22:57:48 <luite> anyway going to sleep, thanks for the help all :)
22:58:07 <dankna> night then
23:08:23 <Slim8> hello?
23:08:42 <Eduard_Munteanu> hell no!
23:08:44 <Eduard_Munteanu> Slim8: hi :)
23:09:03 <Slim8> sorta new to this
23:10:41 * Eduard_Munteanu scared him :(
23:10:41 <Axman6> bye...
