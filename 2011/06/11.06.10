00:01:02 <ivanm> is there an uncurry3 defined anywhere?
00:01:18 <ClaudiusMaximus> something like this might work:   maybeParser `asTypeOf` Parser (Just (runParser myOtherParser ""))
00:01:21 <Jafet> @hoogle uncurry
00:01:21 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
00:01:22 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
00:01:25 <Jafet> @hoogle uncurry3
00:01:25 <lambdabot> No results found
00:01:57 <ivanm> yeah, already tried hoogle
00:02:33 <ClaudiusMaximus> ivanm: hayoo returns a few
00:03:24 <ivanm> OK, not in any standard libraries
00:04:24 <isomorphic> http://hpaste.org/47633  <-- I'm trying to match up the types for sentence and junk - does this look vaguely sensible?
00:06:38 <ClaudiusMaximus> :t const Nothing :: Maybe String  -- i think you need more brackets
00:06:40 <lambdabot>     Couldn't match expected type `Maybe String'
00:06:40 <lambdabot>            against inferred type `b -> Maybe a'
00:06:40 <lambdabot>     In the expression: const Nothing :: Maybe String
00:07:02 <mjrosenb> is sum lazy?
00:07:13 <mjrosenb> or should i use foldl' (+)?
00:07:18 <ivanm> @src sum
00:07:18 <lambdabot> sum = foldl (+) 0
00:07:29 <ivanm> mjrosenb: my guess is that in ghc it'll use foldl'
00:07:39 <mjrosenb> ghci
00:07:48 <mjrosenb> ?
00:08:01 <ClaudiusMaximus> i define sum', product', maximum' if i notice badness..
00:08:03 <isomorphic> ClaudiusMaximus:  actually, it doesn't like the pure either - Couldn't match expected type `Maybe String'
00:08:03 <isomorphic>                 with actual type `a0 -> f0 a0'
00:08:03 <isomorphic>     In the first argument of `fmap', namely `(pure :: Maybe String)'
00:08:13 <ClaudiusMaximus> :t pure
00:08:14 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
00:08:38 <ClaudiusMaximus> should be pure :: String -> Maybe String, i guess..
00:08:58 <isomorphic> oh right
00:08:59 <isomorphic> I see
00:09:42 <ClaudiusMaximus> but you probably don't need all those type signatures (at least the type of 'pure' should be able to be inferred from the signature on Nothing)
00:09:49 <ekipan> you've already typed sentenceOrJunk
00:10:10 <ekipan> so the subexpressions shouldn't need them, as CM says
00:10:46 <isomorphic> ekipan: Yup, I'll lose the type signatures soon.  At the moment, I kind of rely on ghc :/
00:11:43 <isomorphic> so those changes seem to have chased the errors out of that function - thanks for your help!
00:13:31 <ddarius> foldl and foldl' are different functions.  It would be unsound for GHC to use foldl'.
00:13:40 * hackagebot hack2 2011.6.10 - a Haskell Webserver Interface (V2)  http://hackage.haskell.org/package/hack2-2011.6.10 (JinjingWang)
00:14:06 <opqdonut> ddarius: well strictness analysis enables ghc to sometimes do the equivalent of foldl' when you call foldl
00:15:40 * hackagebot hack2-contrib 2010.9.28 - Hack2 contrib  http://hackage.haskell.org/package/hack2-contrib-2010.9.28 (JinjingWang)
00:16:40 * hackagebot air 2011.6.11 - air  http://hackage.haskell.org/package/air-2011.6.11 (JinjingWang)
00:17:26 <ClaudiusMaximus> hm, versioned data structures or writing a parser/prettyprinter?  getting bored with data Stuff = Stuff0{ sFoo, sBar :: T } | Stuff1{ sFoo, sBar :: T, sNewFeature :: (T, T) } | Stuff2{ sFoo, sBar :: T, sNewFeature :: (T, T), sAnotherOne :: Maybe T } | ...  (along with boring renormalizing to the latest version on load)
00:17:40 * hackagebot air-extra 2011.6.11 - air-extra  http://hackage.haskell.org/package/air-extra-2011.6.11 (JinjingWang)
00:17:42 * hackagebot hack2-handler-happstack-server 2011.6.10 - Hack2 Happstack server handler  http://hackage.haskell.org/package/hack2-handler-happstack-server-2011.6.10 (JinjingWang)
00:19:09 <argiopeweb> Is there a standard way to handle non-terminated C strings off the network using Data.Binary? The only way I'm seeing at the moment is to use the Char8 version of bytestring, splitAt and unpack each string inside my get function.
00:19:40 * hackagebot miku 2011.6.11 - A minimum web dev DSL in Haskell  http://hackage.haskell.org/package/miku-2011.6.11 (JinjingWang)
00:19:42 * hackagebot moe 2011.6.11 - html with style  http://hackage.haskell.org/package/moe-2011.6.11 (JinjingWang)
00:19:44 * hackagebot hsignal 0.2.3.1 - Signal processing and EEG data analysis  http://hackage.haskell.org/package/hsignal-0.2.3.1 (VivianMcPhail)
00:39:42 * hackagebot criterion-to-html 0.0.0.2 - Convert criterion output to HTML reports  http://hackage.haskell.org/package/criterion-to-html-0.0.0.2 (JasperVanDerJeugt)
00:45:20 <erus`> whats a good way todo testing on windows?
00:45:50 <erus`> library etsting
00:46:05 <ddarius> The same way you do it anywhere else.
00:46:25 <erus`> ive never done it
00:47:05 <benmachine> how easy it is to test a library depends a bit on what kind of library it is and what it does
00:47:34 <benmachine> QuickCheck is pretty nice and worth looking at
00:48:10 <erus`> its a chess engine
00:48:14 <erus`> well it will b
00:48:27 <benmachine> oh, I'm doing one of those :P
00:48:44 <benmachine> (mine's not very good though)
00:48:49 <benmachine> http://hackage.haskell.org/package/QuickCheck <-- have a look
00:49:11 <benmachine> QuickCheck will be good at testing small-to-medium pure functions
00:49:14 <benmachine> individually
00:52:02 <Jafet> QuickCheck won't help much, I think
00:52:26 <Jafet> A random testcase generator is as likely to be complicated as the thing being tested
00:52:52 <erus`> i just wanna check single states
00:52:54 <benmachine> Jafet: it depends
00:53:03 <erus`> like enpassant and each different capture
00:53:15 * frerich2 wonders how to test whether a random testcase generator is really random
00:53:22 <benmachine> erus`: so just... write code that does it?
00:53:31 <Jafet> http://chessprogramming.wikispaces.com/Perft+Results
00:53:50 <erus`> benmachine: well i was gonna but i thought there might be some test framework
00:54:06 <erus`> saving me from writing if test1 && test2 && test3 etc
00:54:07 <benmachine> erus`: there are test frameworks
00:54:23 <Jafet> HUnit is one.
00:55:09 <benmachine> erus`: http://hackage.haskell.org/package/#cat:testing this might help
00:56:14 <benmachine> QuickCheck is the only one I've used but yes, HUnit is also quite well-established
00:56:53 <benmachine> I have this vague idea that hspec might be quite nice
00:57:04 <erus`> @Hoogle [a] -> a -> Bool
00:57:04 <lambdabot> Maybe you meant: google hoogle
00:57:11 <erus`> @hoogle [a] -> a -> Bool
00:57:11 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
00:57:11 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
00:57:12 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
00:58:23 <Jafet> I thought HUnit would be a bit orthogonal to QuickCheck
00:58:47 <benmachine> Jafet: well, they both test stuff :P
00:58:57 <benmachine> they're both worth looking at
00:59:46 <ivanm> RWH has a chapter on QC
00:59:51 <ivanm> don't think it covers HUnit though
01:09:56 <erus`> i made my own
01:10:00 <erus`> its very simple
01:10:02 <erus`> :)
01:11:14 <benmachine> :)
01:11:53 <erus`> game tress with haskell are so simple
01:12:10 <erus`> i'm crying tears of joy
01:12:27 <mm_freak_> can you make cabal strict in its Other-modules field for executables?
01:12:37 <benmachine> strict?
01:12:56 <mm_freak_> such that it makes GHC ignore files, which have no corresponding entry there
01:13:07 <ClaudiusMaximus> you can cabal sdist, unpack, and see if it builds... but that's not "fun"
01:13:12 <mm_freak_> reason:  i often add a new module to a project, but forget to update the Other-modules field
01:13:46 <mm_freak_> ClaudiusMaximus: doesn't sound like a solution, but that's what i'm doing in fact, before i upload
01:14:31 <ClaudiusMaximus> would be nice to make it really strict, and let you know if a module is no longer needed
01:14:39 * ClaudiusMaximus too
01:14:49 <benmachine> mm_freak_: the trouble is that cabal doesn't itself do dependency chasing
01:14:51 <benmachine> it leaves that to ghc
01:15:00 <benmachine> in the future I think it is planned that it will
01:15:08 <benmachine> in which case it won't be a problem anymore
01:15:24 <mm_freak_> it's usually not a big deal, because i mostly use darcs pushing/pulling to perform deployment, but sometimes it's just nice to quickly package something up, and when it builds using the 'cabal' command, then i should be safe to assume that my .cabal file is correct
01:15:44 <benmachine> yes, it would be nice
01:15:56 <benmachine> I don't know of any way it can be done though
01:16:05 <mm_freak_> ok
01:16:17 <benmachine> but I don't know everything :P
01:16:26 <mm_freak_> =)
01:16:57 <ClaudiusMaximus> maybe cabal-dev has something like that?
01:17:04 <benmachine> yeah I was just wondering that
01:17:12 <benmachine> if not it would seem like a good place to put such a feature
01:17:21 <mm_freak_> luckily i deploy my apps myself =)
01:22:56 <ClaudiusMaximus> any nice bindings to gpg / other digital signing stuff?
01:23:25 <geheimdienst> bah. what's the difference again between ":m +X" and "import X"?
01:23:45 <opqdonut> no difference AFAIK
01:23:55 <opqdonut> import is newer
01:23:59 <ClaudiusMaximus> does one make your prompt not quite so long?
01:24:21 <merijn> ClaudiusMaximus: They both do that, of course you can manually make it shorter again, but I always forget how :p
01:24:43 <geheimdienst> ":set prompt" or something like that :)
01:24:51 <geheimdienst> they both make the prompt long
01:25:15 <geheimdienst> i thought it's something about the one brings things in scope while the other doesn't
01:25:23 <quicksilver> import is the most recent in a line of changes designed to perpetuate deep misunderstanding by ill-advisedly papering over cracks.
01:25:31 <quicksilver> import in ghci, I mean.
01:26:03 <merijn> quicksilver: Which misunderstanding would that be?
01:27:10 <geheimdienst> one of these cracks does this to me: i have Data.Time.{Format,Clock} imported. then i do "import Data.Time ; print =<< getCurrentTime" and it fails because there's no Show instance for UTCTime. if i do ":m +Data.Time", the print works
01:27:30 <quicksilver> merijn: the fact that ghci is fundamentally different from lines in a .hs file
01:27:44 <quicksilver> merijn: and you can't expect things which work in one to work in the other - you need to understand the difference.
01:27:49 <geheimdienst> so there is a difference between import and ":m +". i'm trying to figure out if it's a bug or what
01:28:00 <quicksilver> geheimdienst: I have a feeling that's a bug but I'm not sure.
01:30:45 <geheimdienst> "The form 'import mod' is equivalent to ':module +mod'" sez http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-commands.html
01:30:51 <geheimdienst> OMG a bug
01:32:44 <mm_freak_> quicksilver: if :m would be powerful enough, i could live with it, but the new "import" stuff finally fixes a few shortcomings
01:33:04 <mm_freak_> you can have qualified and renamed imports in GHCi now, for which i was waiting a very long time
01:33:17 <quicksilver> mm_freak_: true. That's a real advantage.
01:33:36 <quicksilver> mm_freak_: and maybe it would have been silly to design and alternative syntax when there already was one to use.
01:34:56 <mm_freak_> quicksilver: depends…  GHCi is a command line after all, so you would want to get your housework done quickly
01:35:12 <mm_freak_> typing import statements for every single import can be tiring
01:35:30 <mm_freak_> also GHCi does not support multiple imports in one line, which is really bad
01:35:48 <mm_freak_> it's bad, because sometimes i leave GHCi to do something else and then return
01:36:04 <mm_freak_> with :m i just go up the history and press enter
01:36:26 <shachaf> Lemmih: Is http://darcs.haskell.org/~lemmih supposed to exist?
01:36:31 <frerich2> Hi, I tried to write a (brute-force) program to solve some little puzzle somebody here mentioned earlier; the source code is at http://hpaste.org/47634 - this program runs very slowly (I anticipated that, it's quite primitive) but what annoys me is that it runs out of memory. I suspect that at least the 'length' call in there is a killer for the garbage collectior, but I'm just guessing. Does anybody here have
01:36:31 <frerich2>  a clue whether it's possible to adjust this program so that it runs in constant memory?
01:36:36 <ddarius> You could make a : command to do multiple imports.
01:37:10 <treo> frerich2: have you had a look at the profiler output?
01:37:15 <mm_freak_> ddarius: why?  we already have valid syntax for that:  import A; import B; import C; …
01:38:08 <geheimdienst> mm_freak_: you can say ":m + Data.Stuff Data.Blah"
01:39:09 <benmachine> geheimdienst: right, but then you can't qualify etc.
01:39:12 <ddarius> mm_freak_: For the reason you said.
01:39:20 <erus`> > concat [[1,3],[2,4]]
01:39:21 <lambdabot>   [1,3,2,4]
01:39:22 <geheimdienst> benmachine: true
01:40:07 <mm_freak_> ddarius: i mean, we already have valid syntax to do that in files…  we could just reuse that syntax in GHCi
01:40:53 <ClaudiusMaximus> frerich2: length xs == 1 = case xs of [_] -> True ; _ -> False  ; take (length xs) ys = zipWith const ys xs
01:41:39 <Jafet> I wonder if you could make RULES for these
01:41:42 <ddarius> mm_freak_: I'm saying the -user- can define such a command.
01:43:51 <treo> can someone give me some feedback on the code quallity of this: http://hpaste.org/47635 ? I'm new to haskell and thats the first thing I have ever written in it, so I'd like to know how I can improve my "style"
01:44:23 <mauke> treo: step 1, don't use OPTIONS_GHC
01:44:38 <mauke> -fglasgow-exts is really archaic
01:44:48 <mauke> use a LANGUAGE pragma instead
01:45:18 <mauke> I don't see why toTrace is strict in lines
01:45:18 <ddarius> Apparently t makes Google street view "3D".
01:45:44 <mauke> or rather, why it's !lines and not lines
01:45:53 * hackagebot hatt 1.2.1 - A truth table generator for classical propositional logic.  http://hackage.haskell.org/package/hatt-1.2.1 (BenedictEastaugh)
01:46:23 <treo> mauke: thats probably left from trying to reduce the memory footprint
01:46:54 <ddarius> mauke: You should look at updateValues
01:46:56 <treo> as I had the garbage collection running 95% of the time and toTrace was the worst offender
01:47:08 <Jafet> If you were optimizing, I would have expected to see more SCC annotations
01:47:17 <treo> the trace that it takes has 2.5 million accesses
01:47:23 <Jafet> By the way, bang patterns on lists do nothing
01:47:37 <ddarius> Jafet: It doesn't do nothing.
01:47:38 <Jafet> A bang pattern forces the outermost constructor
01:48:06 <mauke> ddarius: it could make sense there
01:48:12 <treo> As I said this is the first thing I ever wrote in haskell, I just had to google what an scc annotation even is
01:48:14 <ClaudiusMaximus> data Values = Values !Int !Int !Int instead of (Int, Int, Int) would help, i imagine
01:48:20 <ddarius> mauke: It actually probably does, but not quite the way he's written it.
01:48:30 <ddarius> In particular, m is lazy.
01:48:53 <shachaf> Jafet: Strongly connected component?
01:49:11 <Jafet> @google GHC user's guide profiling
01:49:12 <lambdabot> http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/profiling.html
01:49:12 <lambdabot> Title: Chapter�5.�Profiling
01:49:51 <benmachine> shachaf: set cost centre
01:49:58 <mm_freak_> ddarius: ah, that's what you mean
01:50:31 <treo> ah, ok. Now I get it. -auto-all helped me out with the cost centres
01:50:52 <mm_freak_> ddarius: but in that case it's not always useful, because often when i need to do something, which i cannot do easily in the shell, i do it in GHCi…  often for that i need a lot of imports
01:51:16 <mm_freak_> but it's a one-time task usually
01:51:31 <benmachine> mm_freak_: keep an "import everything" module around :P
01:51:33 <benmachine> like lambdabot's
01:51:42 <opqdonut> heh
01:52:05 <mm_freak_> what would be really great is if you could :suspend
01:52:24 <mm_freak_> ^Z can do it
01:52:26 <opqdonut> ^Z yeah
01:52:34 <treo> any comment on the moveToT2 function? It looks espessially repetative to me, can I do anything about it?
01:53:21 <mm_freak_> but :suspend would save only part of the GHCi state
01:53:29 <mm_freak_> like imports, settings, etc.
01:53:47 <ddarius> You could define something like that.
01:54:42 <Jafet> treo: it doesn't look repetitive enough
01:55:02 <benmachine> treo: is p in only one of t1 t2 b1 b2?
01:55:10 <treo> benmachine: yes
01:55:11 <Jafet> But note that guards are evaluated sequentially
01:55:28 <Jafet> Perhaps you shouldn't be using lists.
01:55:40 <benmachine> treo: ah. has it occurred to you that 'if p `elem` ps then delete p ps else ps' is equivalent to just 'delete p ps'?
01:56:46 <benmachine> although I suppose the way you're doing it you don't have to walk later lists if you find it earlier
01:57:13 <benmachine> hm
01:57:20 * osfameron gets messed up with some jQuery debugging.  Can haz strongly typed javascript?
01:57:30 <ddarius> > delete 'a' "aab"
01:57:31 <lambdabot>   "ab"
01:57:34 <treo> well actually I usually know in which list it is
01:58:37 <treo> by the time I call moveToT2, but I couldn't figure out how to use this knowledge
01:59:11 <osfameron> (hmmm, a Haskell DSL similar to coffeescript, that compiles down to JS?)
01:59:32 <opqdonut> didn'y yhc or something compile to javascript
01:59:41 <ddarius> opqdonut: Among others, yes.
01:59:54 * hackagebot qd 1.0 - double-double and quad-double number type via libqd  http://hackage.haskell.org/package/qd-1.0 (ClaudeHeilandAllen)
02:00:00 <opqdonut> but yeah, I guess a dsl would be nicer than compiling haskell to js
02:00:06 <opqdonut> for actual web development
02:00:11 <osfameron> yhc is in maintenance mode isn't it?
02:00:15 <ddarius> opqdonut: Why?
02:00:30 <osfameron> also, I suppose the key would be a strongly typed DOM, or wrapper around jQuery
02:01:00 <opqdonut> ddarius: well that was my gut feeling. it would make for simpler/faster js probably
02:01:11 <opqdonut> easier to debug etc
02:01:38 <Jafet> treo: [] is totally the wrong container to use. Use Set
02:01:56 <Jafet> I suspect that once you use the appropriate data structure, things will become a bit clearer
02:02:01 <treo> Jafet: is a set ordered in haskell?
02:02:11 <opqdonut> treo: yes
02:02:22 <Jafet> It requires Ord, but I've never not been able to make one up.
02:02:28 <opqdonut> :t findMin
02:02:29 <lambdabot> Not in scope: `findMin'
02:02:34 <opqdonut> :t Data.Map.findMin
02:02:35 <lambdabot> forall k a. M.Map k a -> (k, a)
02:02:35 <treo> so I can use it a lru list?
02:02:43 <treo> *as
02:02:56 <opqdonut> :t Data.Set.findMin -- stupid me
02:02:56 <Jafet> Well, you seem to treat all your Page lists as sets.
02:02:57 <lambdabot> forall a. S.Set a -> a
02:03:01 <magicman> If by ordered, you mean that "fromList [1,2,3]" is different from "fromList [2,1,3]" then no. If you mean sorted, then ye.
02:03:16 <opqdonut> good distinction to make
02:03:31 <magicman> (where fromList converts from lists to sets)
02:03:35 <treo> I meant the first [1,2,3] is supposed to be different form [2,1,3]
02:04:25 <magicman> (note: I haven't actually looked at the code >_>)
02:04:58 <treo> The code is a tracebased simulator for the adaptive replacement cache algorithm
02:05:01 <Jafet> Oh, LRU uses a move-to-front transformation.
02:05:15 <Jafet> @google adaptive replacement cache
02:05:16 <lambdabot> http://en.wikipedia.org/wiki/Adaptive_replacement_cache
02:05:16 <lambdabot> Title: Adaptive replacement cache - Wikipedia, the free encyclopedia
02:05:32 <Jafet> It still looks inefficient, though.
02:06:18 <treo> as nobody has implemented it in a publicly accessible simulator I had to do it myself (to see if my python based implementation does the right thing)
02:06:55 <treo> Well there is one implementation, but it seems to be wrong, as it gets better hit rates then beladys min
02:07:26 <Jafet> The Wikipedia article looks like a list zipper
02:07:28 <magicman> Still not having looked at the code, but looking at that wikipage. Data.List.Zipper or Data.Sequence, perhaps.
02:07:29 <lpsmith> :t (++)
02:07:30 <lambdabot> forall m. (Monoid m) => m -> m -> m
02:07:45 <magicman> Ninja'd by Jafet.
02:07:58 <magicman> And now I'll shut up, because I should probably have a look at the code before commenting >_>
02:08:43 <lpsmith> is lambdabot no longer responding to /msg ?
02:09:47 <lpsmith> ok, n/m.   It's not responding to /msg lambdabot :t expression.   It is responding to other requests privately
02:09:55 <treo> well the list sizes are usually quite small , length (t1++t2) is usually less then 512 for my tests
02:10:18 <ekipan> use @type for :t, if you weren't already aware
02:11:04 <treo> but I don't really understand zippers yet
02:11:14 <Jafet> Okay, I think treo wasn't actually asking for performance boosts
02:11:48 <Jafet> The fromIntegrals for ARC look suspicious.
02:12:10 <lpsmith> ekipan: I see.   I wonder why lambdabot responds to :t publically, then.
02:12:40 <Jafet> :k Maybe
02:12:40 <lambdabot> * -> *
02:12:59 <Jafet> GHCi has many wonderful commands.
02:13:33 <merijn> lpsmith: lambdabot only respond to commands in privmsg's (i.e. things starting with @), I guess the code for :t only looks at channels or something
02:13:36 <treo> Jafet: thats left from when I used / instead of `div` in the calculation of newTargetSize
02:14:12 <quicksilver> lpsmith: the code for :t is a hack. It's a bug really :)
02:14:14 <lpsmith> :info is one of the more useful ones that isn't as widely appreciated.  You can find where something is imported from,  and fixity declarations, among other things
02:14:24 <quicksilver> :info is great.
02:14:34 <quicksilver> I learnt HOpenGL using :info, :browse and :type
02:14:43 <quicksilver> (and some web documentation on *C* API for opengl)
02:17:11 <treo> the code acutally runs fast enough (about 15 seconds on my notebook) right now, the same code in python (with pypy) takes about three times as long, and the abdomination of java that has a bug in its ARC implementation took several hours for the same trace (about 2.8 million accesses)
02:19:10 <treo> All I wanted where some comments on my style and how to improve it. So if zippers would be the haskell way to implement something like this, then thank you for letting me know :)
02:19:39 <Jafet> Perhaps not. You seem to be walking around the list a lot, and zippers might not benefit you for that
02:21:22 <lpsmith> uhh, if you write a function f as infix `f`,   what's the default fixity declaration if one isn't given?
02:21:55 <treo> In a realy implementation (like it was in Postgres 8.0) there is a hashmap to find out if the page is cached at all and the found value would tell me already in which list it is, so all that needs to be done is to move something to the top and remove the last entry in the list
02:22:13 <treo> *real
02:22:25 <Jafet> By the way, I think hlint would have some things to say about your code
02:22:48 <Jafet> Such as the redundant parentheses for the PolicyReturner instances
02:23:39 <treo> oh nice, there is something like hlint? I didn't even think about looking for a linter
02:24:41 <erus`> how can i get ghci to call unexported functions?
02:24:41 <Jafet> Some people also try to make their code pass -Wall -fno-warn-name-shadowing.
02:24:47 <Jafet> Export them
02:25:03 <lpsmith> I could have sworn mappend was declared infixr 5-ish `mappend`
02:25:11 <lpsmith> but no, it associates to the left.
02:25:19 <lpsmith> And it doesn't appear to have a fixity declaration
02:25:23 <ekipan> http://www.haskell.org/onlinereport/decls.html#fixity "Any operator lacking a fixity declaration is assumed to be infixl 9"
02:25:31 <lpsmith> thanks ekipan
02:26:11 <treo> Oh yes, hlint has a lot to say about it :) Thank you all for your help
02:26:20 <quicksilver> erus`: if you load source in interpreted mode you can call all functions in that module (only) whether or not they are exported.
02:26:37 <quicksilver> :l always uses interpreted mode if the .hs is newer than the .o
02:26:38 <erus`> ah silly me
02:26:45 <erus`> just have to import the file
02:26:49 <erus`> not a file that imports the file
02:28:11 <benmachine> you can force interpreted mode by putting an asterisk in somewhere iirc
02:29:12 <lpsmith> speaking of, is there a convenient way to compile a module from within ghci?
02:29:35 <Jafet> :! ghc -c module.hs
02:29:44 <lpsmith> at one point I tried :! ghc ...,  but that didn't work out too good
02:29:53 <lpsmith> Jafet: IIRC,  that confuses ghci
02:30:05 <Jafet> How?
02:32:15 <lpsmith> Jafet: well, it seems to work now
02:32:54 <negaduck> hi! i've just installed ghc6 package under debian squeeze on an arm machine. I cant find ghci anywhere.
02:34:58 <luite> negaduck: /usr/lib/ghc-6.12.1/bin/ghci according to packages.debian.org :)
02:35:30 <luite> oh apparently not for arm
02:36:14 <lpsmith> negaduck: try dpkg -L ghc6
02:36:23 <Jafet> which ghci
02:36:57 <luite> nah the arm package doesn't include ghci... maybe it's because the ghci dyn linker doesn't support arm?
02:37:31 <lpsmith> Jafet: if it's not in negaduck's path,  and presumably negaduck already tried typing "ghci",  "which" isn't going to help  :)
02:40:17 <ekipan> you could try ghc --interactive and see if it complains at you
02:47:49 <andrus> What does the following list comprehension expand to? [(a, b, c) | a <- [0..9], b <- [0..a], c <- [0..b]]
02:48:20 <yoki> hi there, anybody knows if there is library for printing (e.g. for CUPS) out there?
02:48:43 <luite> > [(a,b,c) | a <- [1..5], b <- [0..a], c <- [0..b]]
02:48:44 <ekipan> andrus: type it into ghci and see
02:48:44 <lambdabot>   [(1,0,0),(1,1,0),(1,1,1),(2,0,0),(2,1,0),(2,1,1),(2,2,0),(2,2,1),(2,2,2),(3...
02:48:51 <ekipan> or lambdabot
02:49:17 <andrus> Sorry, I mean "behind the sugar" -- list comp. is syntactic sugar right? so what would the geenrator function look like?
02:49:18 <luite> oops made some typo's
02:49:23 <luite> oh right
02:50:19 <luite> do { a <- [0..9]; b <- [0..a]; c <- [0..b]; return (a,b,c) }
02:50:33 <ekipan> http://www.haskell.org/onlinereport/exps.html#list-comprehensions
02:51:07 <andrus> thanks!
02:56:08 * hackagebot gruff 0.1 - fractal explorer GUI using the ruff library  http://hackage.haskell.org/package/gruff-0.1 (ClaudeHeilandAllen)
02:56:40 <ClaudiusMaximus> ^^ some preview images http://claudiusmaximus.goto10.org/g/mandelbrot/gruff/prerelease/
02:59:03 <andrus> hmmm, i'm still stuck. how could i write something like f k = do { a_0<-[0..9]; a_1<-[0..a_0]; ...; a_k<-[0..a_{k-1}]; return a_0*10^k + a_1*10^(k-1) + ... + a_k*10^(k-k+1) }
03:00:19 <ion> What language is that?
03:00:28 <haskell> haskellish :]
03:03:27 <mm_freak_> andrus: you're missing parentheses or a $
03:03:34 <mm_freak_> return $ a_0*…
03:04:26 <mm_freak_> if you want to generalize this to arbitray lengths you probably can use foldM
03:04:34 <mm_freak_> or write a recursive variant
03:04:37 <ekipan> @type foldM
03:04:38 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
03:05:27 <andrus> mm_freak_: thanks i'll check foldM
03:10:39 * osfameron wonders how the RWH darcs <=> comments stuff works with new revisions.  Does the tool try to work out which paragraphs are "the same" (even after editing)?
03:12:47 <haskell> > let { f k = 10 * f' k 9 ; f 0 _ = 0 ; f k m = do { a <- [0..m] ; ax <- f (k-1) a ; return $ a * 10^k + ax } } in f 3
03:12:48 <lambdabot>   Not in scope: `f''
03:13:39 <haskell> > let { f k = 10 * f' k 9 ; f' 0 _ = 0 ; f' k m = do { a <- [0..m] ; ax <- f' (k-1) a ; return $ a * 10^k + ax } } in f 3
03:13:40 <lambdabot>   No instance for (GHC.Num.Num [t])
03:13:40 <lambdabot>    arising from a use of `e_11090001103' ...
03:14:17 <haskell> > let { f k = 10 * f' k 9 ; f' 0 _ = [0] ; f' k m = do { a <- [0..m] ; ax <- f' (k-1) a ; return $ a * 10^k + ax } } in f 3
03:14:19 <lambdabot>   No instance for (GHC.Num.Num [t])
03:14:19 <lambdabot>    arising from a use of `e_11090001103' ...
03:14:23 <haskell> D:
03:16:58 <ClaudiusMaximus> > let f k = map (g k) (f' k 9) ; f' 0 n = [[]] ; f' k n = do{ a <- [0 .. n] ; (a:) `map` f' (k - 1) a } ; g k [] = 0 ; g k (a:as) = a * 10^k + g (k - 1) as ; in f 2 -- dunno if this is correct...
03:16:59 <lambdabot>   [0,100,110,200,210,220,300,310,320,330,400,410,420,430,440,500,510,520,530,...
03:18:12 <haskell> > let { f k = f' k 9 ; f' 0 _ = [0] ; f' k m = do { a <- [0..m] ; ax <- f' (k-1) a ; return $ a * 10^k + ax } } in f 3
03:18:13 <lambdabot>   [0,1000,1100,1110,2000,2100,2110,2200,2210,2220,3000,3100,3110,3200,3210,32...
03:18:21 <haskell> > let { f k = f' k 9 ; f' 0 _ = [0] ; f' k m = do { a <- [0..m] ; ax <- f' (k-1) a ; return $ a * 10^k + ax } } in f 2
03:18:23 <lambdabot>   [0,100,110,200,210,220,300,310,320,330,400,410,420,430,440,500,510,520,530,...
03:20:20 <frerich2> osfarmeron: I don't know the details, but since RWH was written using DocBook, chances are that an ID was generated (or assigned directly in the DocBook sources) for each <para> element (which is the DocBook element denoting a paragraph). This ID can be transported to HTML and then referenced from JavaScript etc..
03:21:34 <osfameron> frerich2: hmmm. that's possible. It sounds a very heavyweight strategy for a haskell author though ;-)
03:22:03 <frerich2> osfameron: True; however, it's feasible to compute unique IDs using the XSLT scripts they use for transforming DocBook.
03:22:20 <osfameron> that is the simplest strategy I can think of too though... not sure would work with PseudoPod/Markdown
03:22:50 <osfameron> frerich2: ok.  But then the question returns to - what happens when they edit the sources.  Presumably XSLT would then generate a different ID, and the comment thread would be detached from the paragraph ?
03:23:21 <magicman> That has sometimes happened, IIRC. Comments suddenly moving all over the place.
03:23:56 <frerich2> osfameron: That depends on how the ID is computed. For instance, a simple approach might be to associate number to each paragraph in a <sect1> or so, starting from 1. This is robust against changes to a paragraph, but it breaks if paragraphs are inserted/prepended to a section.
03:24:31 <osfameron> magicman, frerich2: aha!
03:25:12 <osfameron> I suppose that might be Good Enough
03:25:17 <frerich2> The tricky thing is: how much is a paragraph allowed to change before the existing comments to it become invalid?
03:26:07 <osfameron> frerich2: also true. It seems like a HARD PROBLEM
03:27:37 <quicksilver> osfameron: yes. And suppose you duplicate a paragraph in your text editor and edit both copies (for some strange reason)
03:27:45 <quicksilver> osfameron: which one is supposed to retain the comments then?
03:27:54 <quicksilver> Better example - you split a long para into two.
03:28:14 <quicksilver> I would class this problem as BOS-hard.
03:28:18 <frerich2> osfameron: I think there is no automatic way which is correct. I think the easiest would be to (automatically) assign IDs to each paragraph in the DocBook sources and then the humans editing them can keep (or change) them as they see fit.
03:28:41 <frerich2> This automatic assignemnt would need to be done only once, of course.
03:29:01 <quicksilver> somehow need new IDS for new paras
03:29:02 <osfameron> I suppose you could hash each paragraph, and assign each comment thread to that hash only
03:29:04 <quicksilver> perhaps editor support.
03:29:19 <quicksilver> osfameron: but then the slightest change - to respond to a comment - would make all the comments vanihs?
03:29:27 <osfameron> any modification to a paragraph will orphan all its comments.  They then have to get manually re-attached
03:29:48 <osfameron> but the program could suggest para $n and the ones around it
03:30:04 <quicksilver> right but this now requires quite a lot of interaction
03:30:22 <osfameron> if comments were to a particular region, instead of a para, then you could possibly fix it using a LCS diff?
03:30:57 <osfameron> quicksilver: true
03:31:45 <osfameron> perhaps the worse is better approach is better then.  Hash OR positional (with warning)
03:32:22 <benmachine> quicksilver: it only requires interaction when you're already editing a paragraph
03:32:37 <quicksilver> true
03:32:50 <benmachine> you could just have a prompt when saving the documents, these comment threads have been orphaned by your changes, where would you like to reattach them
03:32:52 <quicksilver> but it seems to require something quite sophisticated to ripple back to the author's text editor
03:32:52 <osfameron> (or you could use Levenshtein edit-distance to see which paragraph most closely matched the one commented on)
03:34:20 * osfameron sticks with github for now ;-)
03:34:36 <osfameron> though I expect RWH got *far more* comments from the web-version than to the darcs repo ?
03:41:03 <dcoutts> osfameron: I've been pondering using it for my cabal user guide rewrite
03:41:12 <dcoutts> but the per-paragraph thing is tricky
03:41:45 <dcoutts> and also the fact that the program uses its own standalone http server and can't run as fastcgi
03:42:03 <dcoutts> if it were fastcgi I could use it on code.h.o for example
03:48:19 <osfameron> dcoutts: I don't know code.h.o, but yeah, the para thing is tricky ;-)
03:49:30 <dcoutts> osfameron: point is, any site using apache already (like the Haskell community server)
03:49:52 <osfameron> ah ok
03:50:03 <dcoutts> as far as I know, nobody has made a fastcgi backend for the WAI stiff
03:50:14 <dcoutts> warp is a standalone server backend for WAI
03:50:34 <dcoutts> whereas happstack has both standalone and fastcgi backends
03:50:46 <Lemmih> ?tell shachaf It did once. I don't think it had anything important in it, though.
03:50:46 <lambdabot> Consider it noted.
03:50:59 <HugoDaniel> hi
03:52:05 <shachaf> @messages
03:52:05 <lambdabot> Lemmih said 1m 18s ago: It did once. I don't think it had anything important in it, though.
03:52:30 <shachaf> @where conjure
03:52:30 <lambdabot> http://darcs.haskell.org/~lemmih/conjure/
03:53:05 <shachaf> Lemmih: Is that particularly alive?
03:57:37 <lpsmith> Other than the fact that FastCGI is supported by a lot of webservers,  is there any particular reason to use it instead of say,  reverse proxying?
03:58:26 <quicksilver> in principle writing a fastcgi backend is simpler than writing a web server
03:59:05 <quicksilver> people say that unix domain sockets are lower overhead than local TCP, too
03:59:16 <lpsmith> Yeah, I don't know enough about FastCGI.
03:59:27 <quicksilver> the ability for two processes to hold the same unix socket open means you can do zero-downtime upgrades
04:00:01 <quicksilver> (although you can do that with TCP and two different parts and a smart reverse proxy)
04:00:05 <quicksilver> ports.
04:00:10 <lpsmith> a lot of fastcgi is non-local tcp though
04:00:22 <quicksilver> that advantage doesn't apply in that case, then :)
04:00:37 <quicksilver> my personal experience of fastcgi has always been on the same machine.
04:00:45 <lpsmith> quicksilver: thanks for the food for thought though.
04:01:15 <quicksilver> lpsmith: Ithink the whole thing has become less of an issue now that it's "easier" to write an HTTP server.
04:01:27 <quicksilver> lpsmith: I mean, HTTP server libraries exist in lots of contexts.
04:01:39 <lpsmith> A very simple HTTP server is actually pretty easy to write
04:01:49 <quicksilver> yes, but a very simple one is not good enough for production.
04:01:56 <quicksilver> a full HTTP server is actually *not* that easy.
04:02:11 <quicksilver> ...but you don't need to, because other people have done it for you :)
04:02:46 <lpsmith> well,  but if you reverse proxy,  you don't have to worry about efficiently serving static files,  you don't have to worry about most headers unless your application needs them
04:03:05 <lpsmith> you don't have to worry about implementing SSL
04:03:33 <lpsmith> there is a lot of complexity that you can leave on the front-end server.
04:05:31 <quicksilver> lpsmith: yes but you do that *anyway*
04:05:39 <quicksilver> lpsmith: nobody is saying you don't have a front-end webserver.
04:05:53 <quicksilver> lpsmith: it's the front-end webserver that speaks fastcgi to your fastcgi backend.
04:06:17 <quicksilver> all those things you just mentioned apply to the fastcgi case too.
04:06:32 <quicksilver> the question is whether your frontend <-> backend pipe is speaking HTTP or FastCGI.
04:07:04 <lpsmith> I'm not disputing that,  I'm just saying that speaking HTTP to your application server can have a lot of the supposed advantages of FastCGI
04:07:28 <lpsmith> and you get the advantage that you can test your application server with an normal HTTP client :)
04:07:47 <quicksilver> ok
04:07:59 <quicksilver> but none of those are the things I used when you said "why fastcgi over http"
04:08:11 <quicksilver> someone who gave any of those answers doesn't understand the question.
04:09:08 <lpsmith> well, but you did mention that "production" HTTP is a lot more complex than FastCGI,  and I responded that an application server doesn't need to be as "production" quality as a front end server.
04:09:41 <quicksilver> nod
04:09:46 <quicksilver> I agree.
04:10:10 <lpsmith> As to the relative complexity of implementing the two standards, I dunno.   I've implemented a toy HTTP server and hacked on a few more capable HTTP servers,  I don't know enough about the details of FastCGI
04:10:33 <lpsmith> a toy HTTP server can be quite simple.
04:10:53 <lpsmith> how much you really need for a good application server, I don't know.
04:11:48 <quicksilver> fastcgi is a more sensible protocol for this case because its designed with it in mind.
04:11:49 <lpsmith> as you point out, there are a host of pretty good http servers available :)
04:11:58 <quicksilver> clearly http works fine, and is widely used in this way.
04:12:16 <quicksilver> I imagine you can make a case for fastcgi performing better but you'd need to be very precise about what you meant to say that.
04:13:00 <quicksilver> fastcgi can multiplex multiple clietns over a single channel although I'm not sure how often that is used in practice. Seldom I suspect.
04:14:26 <lpsmith> heh, has anybody reversed proxied HTTP over unix domain sockets?   Really, there isn't any reason you couldn't,  other than it's non-standard and you might have to patch the reverse proxy module.
04:14:37 <erus`> is there a nibble data type? (4bits)
04:15:03 <lpsmith> erus`:  I don't think so,  though unboxed arrays of bools are packed
04:15:06 <benmachine> erus`: I doubt it, unless you count (Bool,Bool,Bool,Bool) :)
04:15:16 <quicksilver> lpsmith: google says that lighttpd and nginx can both do that.
04:15:26 <quicksilver> lpsmith: (I didn't know that until I searched just now)
04:15:29 <lpsmith> benmachine: that's decidedly not a nibble :)
04:15:34 <lpsmith> quicksilver: :)
04:15:41 <benmachine> lpsmith: I think unboxed arrays of bools are packed into a UArray Word8 though
04:15:48 <erus`> if bools are packed thats ok
04:15:52 <benmachine> so you wouldn't actually save over just using Word8
04:16:17 <erus`> im using a word8 at the mo
04:16:40 <lpsmith> >  (\(a,b,c,d) -> a && b && c && d) (True, True, False, undefined)
04:16:41 <lambdabot>   False
04:16:51 <lpsmith> see, definitely not a nibble :)
04:17:06 <benmachine> lpsmith: psh. strict all the fields then :P
04:17:14 <benmachine> erus`: are you trying to save memory or do you want actually different semantics
04:17:28 <erus`> 6 Word64s as bitboards for pawns rooks knights bishops queens and kings, 2 bools for castling each side and Word8 for En Passant (all times 2 for each side)
04:19:26 <erus`> > show ((6 * 8 + 1 + 1)*2) ++ " Bytes per board state"
04:19:27 <lambdabot>   "100 Bytes per board state"
04:20:14 <isomorphic> erus`: If you're doing that much optimisation, do you want to store whole boards or board deltas?
04:20:23 <erus`> > show (3500000000 / 100) ++ " board states in ram"
04:20:25 <lambdabot>   "3.5e7 board states in ram"
04:20:50 <isomorphic> put another way, perhaps your unit is games?
04:21:20 <isomorphic> (i'm guessing you're building a giant branching tree of games)
04:21:36 <erus`> yeah hopefully
04:21:53 <erus`> i'm not sure whether cpu or ram will be the bottleneck
04:22:09 <isomorphic> 100 bytes is quite a lot if there's a lot of self-similarity between adjacent board states
04:22:18 <isomorphic> *similarity*
04:24:48 * isomorphic 's dodgy parser works.
04:25:11 <benmachine> mm, and the majority of the board is going to be empty for most of the time
04:25:17 <benmachine> especially in the latter stages of the game
04:25:18 <isomorphic> ... actually, I'll qualify that - it passes the unit tests
04:25:54 <isomorphic> plus, I would have thought that the evaluative strategy would be about deciding possible deltas - you'll spend a lot of time constructing redundant boards
04:27:39 <isomorphic> How many possible first moves are there in chess?
04:28:02 <kalven> 20?
04:28:13 <isomorphic> (assuming, for simplicity that any piece is free to move in any direction it is allowed)
04:28:14 <frerich2> Two per pawn (move one forward, move two forward) plus two for each knight, I think. So 20?
04:28:50 <isomorphic> Hrmm- but what if, for each piece, we ignore all other pieces on the board
04:28:56 <isomorphic> ie: they're never blocked
04:29:08 <frerich2> That's a helluva lot more :)
04:29:44 <isomorphic> well, I think it's like 16 pieces
04:30:07 <isomorphic> (i'm terrible at chess)
04:30:26 <isomorphic> Each moving in what - maybe 4-odd directions?
04:30:28 <benmachine> two per pawn, fourteen for each rook, three for each knight, seven for each bishop
04:30:33 <isomorphic> (-ish)
04:30:39 <benmachine> five for the king
04:30:48 <benmachine> I think 21 for the queen
04:30:49 <isomorphic> Ah - those rooks -- they're big
04:31:02 <frerich2> two per pawn (=16), 14 per tower (=24), two per knight (=4), 7 per whatever-the-diagonal-thing-is-called-in-english (14), three for the king, 14 for the queen. I think.
04:31:19 <isomorphic> Oh, okay, so let's say we've got 16 pieces and 32 bits to describe the movement of each
04:31:20 <frerich2> From the initial starting positions, assuming that there are no other figures on the board which block them.
04:31:29 <isomorphic> looks like you can do a delta in about 4 bytes
04:31:31 <benmachine> frerich2: ok we disagree on king moves and queen moves
04:31:59 <erus`> king has 5 moves from start
04:32:07 <benmachine> also, how many moves a piece has depends on where it is
04:32:14 <frerich2> Ah yes, and three per knight. I forgot that they are not blocked to the side.
04:32:24 * isomorphic makes a note never to play any of you guys at chess :P 
04:32:36 <benmachine> isomorphic: I'm rubbish at the game but I'm good at counting :)
04:32:40 <isomorphic> (or gals as the case may be)
04:32:52 <benmachine> I actually have a maths exam in half an hour
04:32:56 <benmachine> should probably head thatwaywards
04:33:05 <isomorphic> where's a good rain man quote when you need one ;)
04:33:41 <erus`> a beautiful mind
04:36:58 <erus`> to check if a move is a checkmate i have to evaluate all possible moves
04:37:07 <erus`> but im gonna do them later
04:37:16 <erus`> so im repeating myself
04:37:20 <erus`> :(
04:37:55 <isomorphic> erus`: that would make for an interesting tree traversal with deltas
04:38:23 <erus`> maybe just a big lazy tree?
04:38:30 <isomorphic> erus`: ie: move down tree - update in working gameboard - then evaluate all possible moves - then go up the tree - undoing whatever happened
04:38:49 <isomorphic> erus`: I'm rubbish at haskell - so I wouldn't want to comment
04:40:07 <isomorphic> I wonder whether you can get to the same board state by different routes frequently - that might influence your choice of data structure
04:40:27 <benmachine> isomorphic: it's an interesting point though. the most move choices a piece ever has is a queen in the centre, with (umm) 27 I think
04:40:38 <benmachine> so you can encode a move in 9 bits I reckon
04:41:24 <isomorphic> benmachine: so that's four to identify the piece, five for the move
04:41:39 <pamiz> > let f = (+)
04:41:40 <lambdabot>   not an expression: `let f = (+)'
04:41:44 <benmachine> isomorphic: yes. possibly it can be done in fewer since most pieces don't need five for th emove
04:42:02 <isomorphic> benmachine: yup, but then you need some crazy encoding
04:42:25 <benmachine> sure :) but it'd be easy to abstract
04:42:33 <benmachine> packMove :: Move -> Word8
04:42:37 <isomorphic> :P
04:42:38 <benmachine> unpackMove :: Word8 -> Move
04:42:40 <benmachine> sorted
04:43:22 <Saizan> not to mention that a Word8 uses way more than 32 bits
04:43:23 <benmachine> (which is why I wanted to compress it further, to get rid of that extra bit)
04:43:24 <isomorphic> true that.
04:43:39 <benmachine> Saizan: hm?
04:43:49 <Saizan> @src Word8
04:43:49 <lambdabot> Source not found. Just try something else.
04:43:53 <benmachine> Saizan: due to laziness making pointers and stuff?
04:44:03 <benmachine> oh eep I have to go now
04:44:04 <develhevel> is it possible whe i declare a new data type e.g.: "data Foo = Foo {name::String, (age::Int, hobby::String)}" to declare tuples in it?
04:44:05 <benmachine> hf
04:44:06 <isomorphic> Saizan: Is this boxed?
04:44:25 <isomorphic> benmachine: good luck with the exam!
04:44:44 <pamiz> can somebody tell me how the type is inferred? http://hpaste.org/47638
04:44:48 <Saizan> -- Word8 is represented in the same way as Word. Operations may assume
04:44:48 <Saizan> -- and must ensure that it holds only values from its logical range.
04:44:50 <Saizan> data Word8 = W8# Word# deriving (Eq, Ord)
04:45:35 <magicman> pamiz: That's defaulting at work.
04:46:04 <Saizan> Word# can be either 32 or 64 bits, than there's the boxing
04:46:10 <Saizan> *then
04:46:29 <magicman> The actual type of (+) is Num a => a -> a -> a (because it is a typeclass method).
04:46:45 <magicman> I'm not sure why ghci doesn't give 'f' that type as well, but the answer may involve the word "monomorphism".
04:47:19 <Jafet> And "dreaded"
04:47:33 <erus`> lol
04:47:48 <alpounet> jaspervdj, it would be nice to have an example of HTML output for criterion-to-html, somewhere
04:47:52 <pamiz> i expected ghci to infer the type of the typeclass-method
04:48:20 <magicman> pamiz: And I don't blame you for expecting that. Hence the "dreaded" part :p
04:48:33 <magicman> Anyway, try (in ghci):
04:48:39 <magicman> :set -XNoMonomorphismRestriction
04:49:00 <jaspervdj> alpounet: http://jaspervdj.be/tmp/results.html
04:49:04 <magicman> And then do the "let f = (+)" again.
04:49:15 <pamiz> ah
04:49:30 <alpounet> great, thanks!
04:49:41 <bmm> Noob question: why do I get a syntax error when I want to use "where" in this code? http://hpaste.org/47639
04:49:57 <jaspervdj> alpounet: But I'm not entirely satisfied with the output yet. Once it's cleaned up a little I might throw a blogpost online
04:50:19 <zygoloid> bmm: 'where' is not part of the expression syntax
04:50:20 <alpounet> what do you consider missing in the output ?
04:51:07 <jaspervdj> alpounet: I'd like to add a decent option for a logarithmic scale
04:51:43 <zygoloid> bmm: it's only usable in binding groups. if you move it to the end of the definition of 'collectLines' then it would work. alternatively, use a 'let'.
04:51:56 <develhevel> is it possible whe i declare a new data type e.g.: "data Foo = Foo {name::String, (age::Int, hobby::String)}" to declare tuples in it?
04:52:06 <alpounet> jaspervdj, yeah ok
04:52:16 * magicman puts :set -XNoMonorphismRestriction in his ~/.ghci...
04:52:23 <alpounet> jaspervdj, and some options to plot a graph ? :P
04:52:55 <magicman> (what is the reason that that thing exists anyway? Any reading material on it?)
04:53:33 <Jafet> @where report
04:53:33 <jaspervdj> alpounet: What kind of graph are you thinking of?
04:53:33 <lambdabot> http://www.haskell.org/onlinereport/
04:53:40 <Jafet> Because of that
04:53:52 <magicman> Right...
04:54:45 <ceii> magicman: more precisely, http://www.haskell.org/onlinereport/decls.html#sect4.5.5
04:55:28 <alpounet> jaspervdj, smth like http://chplib.wordpress.com/2010/02/04/progression-supporting-optimisation-in-haskell/
04:56:52 <zygoloid> huh, hpaste doesn't seem to allow annotations any more!
04:56:54 <jaspervdj> alpounet: The progression library looks nice
04:57:24 <jaspervdj> alpounet: criterion-to-html doesn't infer any relationship between the benchmarks
04:57:30 <jaspervdj> it just plots them per group
04:57:41 * hackagebot gruff 0.1.1 - fractal explorer GUI using the ruff library  http://hackage.haskell.org/package/gruff-0.1.1 (ClaudeHeilandAllen)
04:58:54 <zygoloid> preflex: seen chrisdone
04:58:54 <preflex>  chrisdone was last seen on #haskell 15 hours, 22 minutes and 25 seconds ago, saying: * chrisdone changes that to pid <- (fmap toString >=> readMay) <$> getParam "id"
05:00:35 <alpounet> jaspervdj, yeah i see, but that would be *awesome*
05:04:17 <jaspervdj> alpounet: Yes, it would :-)
05:07:50 <bmm> zygoloid: ah, thanks!
05:13:53 <joe6> i have something like this: to blank pad a list and then add an element at the end:  http://sprunge.us/MeIP
05:14:05 <joe6> any suggestions on improving it?
05:14:15 <Jafet> erus: if you're using bitboards, you might as well read as much material as you can find by Hyatt.
05:15:18 <Jafet> You can store a move in much less than one machine word, but you'll probably need mutation to benefit much from that
05:15:49 <Jafet> joe6: an obvious area of improvement is to make it valid haskell
05:17:07 <isomorphic> joe6: What is being represented? Bits?
05:17:11 <joe6> Jafet: which is? point-free style?
05:17:28 <joe6> isomorphic: no, just a byte array
05:17:34 <Jafet> Uh, your code isn't valid haskell
05:17:48 <joe6> no, it is not bits, just an array of 8 bytes.
05:17:55 <Jafet> Which makes your question a little bit even vaguer
05:18:15 <joe6>  http://sprunge.us/LCDF
05:18:34 <ClaudiusMaximus> joe6: take 7 (xs ++ repeat 0) ++ [1]  might work, but has different semantics if (length xs > 7)
05:18:50 <joe6> Jafet, this is the bigger function declaration, and this is all of it:  http://sprunge.us/EMBF
05:19:15 <Jafet> Oh, okay, the rest is irrelevant.
05:19:50 <joe6> ClaudiusMaximus: that is cool. i wish this was agda and I could tell it that the length should not be greater than 7
05:19:52 <OODavo> Is there a Haskell module like Python's fileinput one? (provides streams to filename arguments, or uses stdin with no args)
05:20:11 <joe6> or, maybe, I could just add an error condition
05:20:56 <isomorphic> Or you could make xs belong to some type?
05:21:11 <Jafet> Not worth it.
05:21:56 <ClaudiusMaximus> OODavo: i think readFile provides lazy streams
05:22:25 <OODavo> Sorry, I didn't explain very well.
05:22:49 <ClaudiusMaximus> and getContents does the same for stdin
05:23:05 <joe6> ended up with this:  http://sprunge.us/AgfL
05:23:35 <OODavo> fileinput parses the filename arguments and provides handles to each of them, essentially. If there are no arguments, it instead gives a handle to stdin.
05:23:47 <xkb> what is the easiest way for reading XML in haskell nowadays?
05:23:59 <Jafet> That sounds easy to write
05:24:25 <isomorphic> xkb: TagSoup?
05:24:39 <Jafet> fileInput :: IO [Handle]
05:24:39 * xkb is googling for TagSoup
05:24:49 <OODavo> Yes, it does sound easy. But it also sounds rather boilerplate.
05:24:51 <magicman> @hackage TagSoup
05:24:51 <lambdabot> http://hackage.haskell.org/package/TagSoup
05:25:02 <magicman> Drat. Probably wrong case.
05:25:02 <xkb> cool
05:25:10 <OODavo> I was assuming that interact actually already implicitly did it. 'pparently it doesn't.
05:25:11 <magicman> @hackage tagsoup
05:25:11 <lambdabot> http://hackage.haskell.org/package/tagsoup
05:25:13 <magicman> That one.
05:25:14 <ClaudiusMaximus> stuffs <- case args of [] -> (:[]) `fmap` getContents ; files -> mapM readFile files  -- might work if you want lazy IO
05:25:23 <Jafet> I doubt such a trivial thing would be on Hackage
05:26:16 <Jafet> Why would you assume that a function called “interact” reads the files corresponding to filenames on a program's command line?
05:26:33 * Jafet mumbles something again about Python rotting minds
05:27:00 <OODavo> Seems logical, given the usual behaviour of standard UNIX commands.
05:27:03 <aavogt> you could run your interact program like      runghc program.hs < cat f1 f2 f3, but then you don't know where one ends
05:27:37 <Jafet> Well, it shouldn't matter since interaction is pure.
05:28:00 <aavogt> Jafet: there are lots of trivial things on hackage
05:28:26 <Jafet> Er, trivial × not-used-much
05:28:57 <Jafet> Besides, a unix program has to do option parsing before it can guess which arguments are supposed to be filenames.
05:35:48 <magicman> @type mapM_
05:35:49 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
05:35:49 <efie> i found a few websites which said that haskell if less efficient than imperative and objective orientated languages for example c and java. is this true? i thought the other thing, as in haskell are no auxiliary variables and so. or do one cannot say this in general?
05:37:15 * isomorphic discovers protolol
05:38:53 <ClaudiusMaximus> define efficient!  Haskell is way more efficient in programmer time than C, at least for me; but i still sometimes code tight numerical inner loops in C/C++ and call them from Haskell when I can't make my Haskell go faster
05:39:01 <Nimatek> efie: C is more computationally efficient than most things.
05:40:16 <cheater1> computational efficiency comes from algorithms, not languages.
05:40:18 <cheater1> stop being silly.
05:40:40 <zygoloid> well, a combination of algorithm and implementation (including the language implementation)
05:41:02 <cheater1> implementation is a practical detail.
05:41:17 <zygoloid> speed is a practical detail too
05:43:29 <matthiasgorgens> speed often comes from doing less in a clever,
05:43:34 <matthiasgorgens> or from doing things more parallel.
05:44:10 <matthiasgorgens> efie, it's hard to compare it in general.
05:44:25 <efie> ok :)
05:44:27 <Nimatek> The difference is that in C doing less kind of comes automatically, whereas in functional languages a concise statement can be very inefficient.
05:44:42 <matthiasgorgens> efie, idiomatic C is often faster than idiomatic haskell.  but if you really torture your source, you can squeeze out the last bits in haskell, often, too.
05:44:57 <isomorphic> efie: what kind of program are you going to write?
05:45:14 <matthiasgorgens> nimatek, often, yes.  but for example it's harder to share values in C, with all that mutation going on.
05:45:46 <zygoloid> it is often easier to write memory-efficent code in C than in current haskell implementations
05:45:56 <matthiasgorgens> efie, the best answer to any speed problems is: write a prototype, use a profiler.  then decide what to do.
05:46:24 <matthiasgorgens> zygoloid, yes.  it's not only about the languages, but also about the current implementations.
05:46:30 <efie> isomorphic, none. i have to learn haskell for university and was thinking about efficiency
05:46:45 <Nimatek> matthiasgorgens: Yeah, as always there are areas particular languages excel at.
05:46:47 <efie> "have"
05:46:51 <zygoloid> matthiasgorgens: right. in principle, for instance, strict Bool fields could be packed into bitfields, but ghc doesn't do that
05:46:52 <matthiasgorgens> efie, if you want to see an area where haskell blows almost all other languages for speed, look at stream fusion.
05:47:08 <isomorphic> efie: well, the benefit will be partially in how it makes you think
05:47:30 <aavogt> zygoloid: because it's not always faster to do that?
05:47:40 <efie> matthiasgorgens, ill do some research, thanks
05:47:53 <isomorphic> efie: I can imagine even if you want back to C, you'd start thinking in terms that made it easier to write better or safer code
05:48:04 <matthiasgorgens> efie, you can start with http://lambda-the-ultimate.org/node/2192 or so.
05:48:09 <zygoloid> matthiasgorgens: i'd say with stream fusion, it's more that haskell gives you a very concise, clear, composable syntax for it, not that it makes it faster
05:48:40 <zygoloid> aavogt: sure. but C lets the programmer make that call.
05:48:54 <matthiasgorgens> zygoloid, yes, in a sense.  haskell allows you to write programs that are easy to analyze for the compiler, and thus apply stuff like stream fusion.
05:49:22 <matthiasgorgens> efie, just give haskell a try.  but don't forget about C.  (Do forget about C++, though.)
05:50:07 <efie> why?
05:50:20 <zygoloid> efie: don't forget about c++. pick the language which works best for the constraints of your problem.
05:50:25 <Nimatek> C++ is nice, the people using it are the problem.
05:50:26 <isomorphic> efie: certainly don't be put off by any sense of inefficiency - the prevalance of scripting languages shows efficiency isn't so crucial
05:51:15 <matthiasgorgens> isomorphic, actually haskell programs are quite fast in general.  compared to, say, python.
05:51:15 <zygoloid> efie: don't be fooled into thinking that one language is best for all problems :)
05:51:28 <efie> ok
05:51:42 <matthiasgorgens> zygoloid, we should be more flame-y. :o)
05:52:09 <isomorphic> matthiasgorgens: Yes, I nearly mentioned Python by name.  I was just trying to make it clear that efficiency frequently isn't even remotely an issue.
05:53:00 <matthiasgorgens> efie, if you are interested in learning about very different languages, Forth is worth a look, too.  (not because it's a practical language nowadays, but because it's so foreign to most familar languages.)
05:53:36 <matthiasgorgens> isomorphic, yes.  and the python guys usually just say: prototype in python, use a profiler, get better algorithms, and if that doesn't help enough, replaces critical parts with C.
05:54:06 <matthiasgorgens> that's doable in Haskell, too, but less necessary, since you can use ghc to compile haskell to native code.
05:54:33 <isomorphic> Oh, then I hope python's foreign C interface has improved in the last 5 years or so
05:54:38 <erus`> learning haskell only takes about 10 times as long as learning anything else
05:54:41 <erus`> but its fun
05:55:13 <isomorphic> ^-- this.
05:56:08 <aavogt> erus`: to be able to accomplish the same things? to feel just as comfortable?
05:56:19 <Nimatek> It just needs more neural plasticity than learning yet another imperative language.
05:56:47 <guy> what the hell is this
05:56:49 <Nimatek> I'm currently learning haskell myself.. It's not too problematic.
05:57:20 <Guest45091> hey
05:57:21 <Guest45091> so
05:57:23 <Guest45091> what is haskell
05:57:38 <matthiasgorgens> erus`, haskell takes a while, if you don't already know, say, clean.
05:57:48 <matthiasgorgens> and of course, learning java is faster if you already now, say, C.
06:01:10 <joe6> this works:  http://sprunge.us/CGWC , this is what I am trying to get to:  http://sprunge.us/FbNT , this is my crude attempt at it:  http://sprunge.us/LRGC and this is the ghci error:  http://sprunge.us/JIZX
06:01:47 <joe6> any suggestions on if I could use "when" there
06:02:47 <opqdonut> joe6: it should be "showFilePath True x = return $ trace (show x) x"
06:03:14 <opqdonut> the type of "trace (show x)" is a -> a, the type of "return x" is IO FilePath
06:03:29 <opqdonut> that's the same thing as the error says
06:03:38 <opqdonut> but if you are inside the IO monad, why are you using trace?
06:03:40 <joe6> or, i coud do this: showFilePath True x = (putStrLn $ show x) >> return x
06:03:56 <aavogt> print x >> return x
06:03:58 <opqdonut> btw, "putStrLn $ show x" is just "print x"
06:04:15 <joe6> ok, thanks, guys
06:04:27 <zygoloid> joe6: incidentally, why are you not using 'do' notation for this?
06:05:16 <joe6> zygoloid: was reading too may wadlers' papers then.
06:05:30 <joe6> zygoloid: and wanted to use the monadic operators.
06:06:18 <roconnor> as a rule of thumb, if I'm write " >>= (\x -> " then I use do notation instead.
06:06:24 <roconnor> *I write
06:06:26 <opqdonut> same here
06:07:08 <joe6> but, for a beginner, like me, it is good to see how stuff sticks together.
06:07:39 <roconnor> if it makes you feel better :)
06:09:32 <matthiasgorgens> roconnor, try join, fmap, and return, instead of bind, fmap and return for your monads.
06:10:03 <matthiasgorgens> (that approach has equivalent power, is more useful for reasoning, but more cumbersome to program.)
06:10:05 <roconnor> matthiasgorgens: you mean <$> <*> and join ?
06:10:06 <matthiasgorgens> to program in.
06:10:39 <matthiasgorgens> I mean, <$>, pure and join.
06:10:46 <matthiasgorgens> (pure = return)
06:10:53 <matthiasgorgens> <$> = fmap
06:10:55 <roconnor> matthiasgorgens: and no lambdas?
06:11:09 <matthiasgorgens> you'll need lambdas (or named functions).
06:11:26 <matthiasgorgens> just try to define bind in terms of join, fmap and return as an exercise.
06:11:26 <opqdonut> you never _need_ lambdas
06:11:32 <matthiasgorgens> and then the other way round.
06:11:38 <matthiasgorgens> opqdonut, I meant, in practise. ;o)
06:11:53 <matthiasgorgens> opqdonut, of course you can also tie your hands behind your back, and use SKI calculus.
06:12:05 <roconnor> I is for losers
06:12:09 <opqdonut> indeed
06:12:22 <opqdonut> and S and K are way to short identifiers. const and ap all the way!
06:12:49 <osfameron> K is a Kestrel, right?
06:13:01 <matthiasgorgens> is SKI still universal, even if you are bound by haskell's type system?
06:13:15 <isomorphic> matthiasgorgens: Which forth interpreter/compiler do you recommend?
06:13:30 <zygoloid> S and K? luxury! i just use the X combinator
06:13:42 <opqdonut> oh, my single combinator of choice is Y
06:13:44 <matthiasgorgens> but then you need parens.
06:14:13 <opqdonut> (and yeah, strongly typed SK isn't complete, naturally)
06:14:25 <opqdonut> (strong normalization)
06:17:46 <int-e> opqdonut: heh, that confused me, since in rewriting theory, complete = terminating + confluent (i.e., strongly normalizing) != Turing complete.
06:18:33 <opqdonut> heh
06:19:52 <tgeeky_> le sigh. Does anyone have a copy of "Fast and sound random generation for automated testing and benchmarking in objective Caml" - one which has a pretty color picture in the top left corner of the first page?
06:20:36 <int-e> hrm, terminating = strongly normalizing.
06:22:01 <dmwit> I thought terminating + confluent = strongly normalizing.
06:23:38 <alfa_y_omega> Turing complete proved that halting is not always possible. So, that terminating + confluent always halt in a finite time.
06:24:17 <dmwit> "Terminating" already means "halt in a finite time".
06:24:22 <dmwit> You don't need confluence for that.
06:24:36 <erus`> is haskell turing complete?
06:24:52 <sipa1024> @vixen can haskell solve the halting problem?
06:24:52 <lambdabot> Ooh, functional programmers are so hot!
06:25:15 <tgeeky_> clever answer, in a sense
06:25:22 <sipa1024> erus`: sure is
06:25:27 <erus`> i would be funny if it wasnt so true
06:26:13 <erus`> can haskell pass the turing test?
06:26:36 <quicksilver> int-e: terminating = normalizing (but not strongly)
06:26:46 <quicksilver> int-e: 'strongly' normalizing requires confluent.
06:26:52 <quicksilver> I think.
06:26:53 <isomorphic> erus`: On some days I think #haskell might fail
06:27:18 <quicksilver> isomorphic: is it because of your mother that you think #haskell might fail?
06:27:22 <erus`> once we get quantum processors will everyone code in haskell?
06:27:24 <osfameron> heh
06:27:33 <osfameron> erus`: perhaps if we get quantum brains too
06:27:44 <isomorphic> quicksilver: Nice try, Eliza.
06:27:57 <tgeeky_> osfameron: maybe that's why the zombies love BRAINNNSSSSS so much
06:28:03 <erus`> mapping lists will take one instruction :)
06:28:21 <erus`> on my xxx86
06:28:36 <osfameron> though how do you entangle the list over exactly the right parallel universes to do that?
06:29:01 <erus`> ghc will handle that for you
06:29:15 <osfameron> yay!
06:29:25 <isomorphic> erus`: Why store a list?  Why not just a single, uncollapsed element.
06:31:07 <Jafet> @google quantum monad
06:31:08 <lambdabot> http://cognet.mit.edu/posters/TUCSON3/Yasue.html
06:31:08 <lambdabot> Title: Toward a Science of Consciousness 3: Quantum Monadology
06:31:43 <silver> oh god
06:32:10 <lpsmith> does ghc 7.0.3 still dependent on llvm-2.7,  or is it compatible with llvm-2.8 as well?
06:32:20 <djahandarie> I don't think Haskell is a particularly good pick for doing quantum programming.
06:32:23 <erus`> not quite sure what a monad is and now I have to read about quantum monads
06:32:49 <lpsmith> I don't think any language is a particularly good pick for quantum programming :-P
06:33:11 <djahandarie> Any language based on a typed lambda calculus, that is.
06:33:19 <lpsmith> Or, more importantly,  I don't think any of our hardware is a good pick for executing quantum programs.
06:33:24 * isomorphic is reserving judgment pending an observation. 
06:33:56 <djahandarie> Because lambda calculus allows for you to do things like   (\x -> (x, x))   and    (\x -> 1)
06:33:58 <matthiasgorgens> isomorphic, but that observation might kill the cat.
06:34:16 <matthiasgorgens> djahandarie, you mean cloning and forgetting?
06:34:19 <djahandarie> Yes.
06:34:21 <djahandarie> Both of which would be bad when you're working with qubits.
06:34:29 <matthiasgorgens> djahandarie, you can use Clean's linear type system to get around cloning.
06:34:31 <djahandarie> Due to the non-cloning properity.
06:34:39 <djahandarie> Yes, linear type systems are a very good fit for quantum programming.
06:34:55 <djahandarie> Don't beat me to the punchline. :)
06:35:02 <erus`> haha
06:35:08 <matthiasgorgens> djahandarie, and i guess people will use their quantum-coprocessors like they use GPUs now.
06:35:17 <erus`> does simon peyton jones stop by here?
06:35:22 <osfameron> matthiasgorgens: to mine bitcoins?
06:35:33 <matthiasgorgens> i meant, the way you program them.
06:35:40 <matthiasgorgens> i.e. in a special monad. ;o)
06:35:53 <isomorphic> quibitcoins
06:35:58 <isomorphic> .. actually.
06:36:00 * osfameron isn't even really sure what a GPU is
06:36:26 <matthiasgorgens> osfameron, a graphics card, basically.
06:36:27 <osfameron> apparently they're the reason my laptop is able to render vim editor sessions so beautifully smoothly.
06:36:46 <isomorphic> (qubit even)
06:37:03 <djahandarie> Interestingly enough, there are categorical arguments that also explain why linear type systems make much more sense for quantum programming than a standard typed lambda calculus.
06:37:29 <bmm> None of my JSON strings will be parsed, could somebody help me? http://pastebin.com/muAZ3VbB
06:37:31 <mauke> The paste muAZ3VbB has been copied to http://hpaste.org/
06:37:47 <djahandarie> Mainly by pointing out that nothing in the quantum world is cartesian. You basically get linear type systems when you remove the cartesian from cartesian closed categories anyways (getting symmetrical closed monoidal categories).
06:37:50 <matthiasgorgens> osfameron, you might be interested in http://www.bbspot.com/News/2003/02/ati_ascii.html
06:38:06 <isomorphic> osfameron: Yeah, those vim plugins are very taxing : http://blog.whatfettle.com/2006/02/13/vi-paperclip-assistant/
06:38:14 * bmm is confused, hpaste was down a minute ago
06:38:49 <osfameron> matthiasgorgens: heh
06:39:27 <bmm> (repeat on hpaste) http://hpaste.org/47640
06:39:51 <osfameron> isomorphic: also cute
06:39:59 <osfameron> I think someone actually implemented that didn't they?
06:40:16 <bmm> Aah, I get it, www.hpaste.org just doesn't work. Whoever maintains it, look up a redirect for nginx please ;)
06:40:25 <isomorphic> matthiasgorgens: Finally, the right video card to play this back - http://www.asciimation.co.nz/
06:40:34 <djahandarie> (Other important symmetrical closed monoidal categories are Hilb and nCob, both very common in quantum mechanics)
06:41:06 <matthiasgorgens> isomorphic, isn't the right way to watch star wars via telnet?
06:41:53 <k0ral> matthiasgorgens: in IPv6 of course, for colors
06:41:56 <isomorphic> osfameron: I think they did - Vigor?
06:42:41 <osfameron> isomorphic: yes! that was it ;-)
06:43:11 <isomorphic> matthiasgorgens: morally, that feels right, although I admit that there is potential for disagreement as to the terminal emulation.
06:48:08 * isomorphic just installed vigor
06:51:08 <osfameron> isomorphic: yay ;-)
06:52:33 <isomorphic> bmm: What's the code (not) doing?
06:53:58 <bmm> isomorphic: It seems that I need to define a type of what the JSON should produce, but I don't know how, and it just calls the Error String case all the time :(
06:55:55 <isomorphic> Json.decode is a function somewhere?
06:56:26 <bmm> isomorphic: Oh, wait, maybe I found it, maybe I should add a :: Result ObjectTypeIMakeUp.. Json.decode is from import qualified Text.JSON as Json
06:56:31 <bmm> sorry for not including that in the paste
06:59:15 <isomorphic> bmm: Incidentally, the variable pipe doesn't seem to be used.
07:00:17 <bmm> isomorphic: right, I'm going to create a separate test program because I can't figure this out at alll.. be back in a second
07:04:49 <bmm> isomorphic: this code http://hpaste.org/47642 will compile and run but produce "Error {...json...}" instead of what I want it to do, but it is valid json :S
07:09:33 <erus`> > 0 ^ (-1)
07:09:34 <lambdabot>   *Exception: Negative exponent
07:10:06 <Veinor> what'd you expect? :P
07:10:37 <Jafet> > 0 ** -1
07:10:38 <lambdabot>   Precedence parsing error
07:10:38 <lambdabot>      cannot mix `GHC.Float.**' [infixr 8] and pref...
07:10:42 <Jafet> > 0 ** (-1)
07:10:42 <lambdabot>   Infinity
07:11:08 <solistic> Is there a regex lib that works with Data.Text?
07:11:43 <alfa_y_omega> > 0 ** 0
07:11:43 <lambdabot>   1.0
07:11:49 <alfa_y_omega> liar
07:12:06 <alfa_y_omega> > 0 ** (-0)
07:12:07 <lambdabot>   1.0
07:12:18 <alfa_y_omega> > (-0.0) ** (-0.0)
07:12:19 <lambdabot>   1.0
07:12:21 * hackagebot hack2-contrib 2011.6.10 - Hack2 contrib  http://hackage.haskell.org/package/hack2-contrib-2011.6.10 (JinjingWang)
07:12:32 <Jafet> 0 ** -0 = 1 / (0 ** 0) = 1 / 1 = 1!
07:12:39 <Jafet> Totally
07:12:53 <alfa_y_omega> in math theory, 0^0 is undetermined.
07:13:11 <roconnor> in math theory 0^0 = 1
07:13:16 <Jafet> Except in the theories where it isn't
07:13:21 * hackagebot miku 2011.6.12 - A minimum web dev DSL in Haskell  http://hackage.haskell.org/package/miku-2011.6.12 (JinjingWang)
07:14:24 <alfa_y_omega> 0^0.00000000001
07:14:29 <alfa_y_omega> > 0 ** 0.00000000001
07:14:30 <lambdabot>   0.0
07:14:33 <alfa_y_omega> > 0 ** 0.00000000000
07:14:34 <roconnor> > length (sequence [])
07:14:34 <lambdabot>   1.0
07:14:35 <lambdabot>   1
07:17:55 <roconnor> > let n ^ m = length (sequence (replicate m (takeWhile (< n) [0..]))) in 2^3
07:17:56 <lambdabot>   8
07:17:59 <roconnor> > let n ^ m = length (sequence (replicate m (takeWhile (< n) [0..]))) in 3^2
07:18:00 <lambdabot>   9
07:18:05 <roconnor> > let n ^ m = length (sequence (replicate m (takeWhile (< n) [0..]))) in 0^0
07:18:05 <lambdabot>   1
07:18:37 <magicman> > [x ** y | x <- [0.0,-0.0], y <- [0.0,-0.0]]
07:18:38 <lambdabot>   [1.0,1.0,1.0,1.0]
07:18:46 <roconnor> > let n ^ m = length (sequence (replicate m (take n [(),(),..]))) in 2^3
07:18:47 <lambdabot>   <no location info>: parse error on input `..'
07:18:51 <roconnor> > let n ^ m = length (sequence (replicate m (take n [(),()..]))) in 2^3
07:18:51 <lambdabot>   8
07:19:16 <magicman> > join (liftM2 (**)) [0.0,-0.0]
07:19:16 <lambdabot>   [1.0,1.0,1.0,1.0]
07:19:22 <Jafet> > let n ^ m = length (sequence (replicate m (replicate n undefined))) in 2^3
07:19:23 <lambdabot>   8
07:19:32 <roconnor> ah right
07:20:00 <magicman> So... "sequence" behaves like "product"?
07:20:04 <magicman> (in this case)
07:20:06 <roconnor> yes
07:23:48 <Veinor> @pl \m n -> length . sequence . replicate m . replicate n $ undefined
07:23:48 <lambdabot> flip flip undefined . (((length . sequence) .) .) . (. replicate) . (.) . replicate
07:23:56 <Veinor> @pl \n m -> length . sequence . replicate m . replicate n $ undefined
07:23:56 <lambdabot> flip flip undefined . (((length . sequence) .) .) . flip ((.) . replicate) . replicate
07:27:25 <Cale> alfa_y_omega: Most mathematicians prefer 0^0 = 1. For some reason in highschools, they tend to leave 0^0 undefined, but there are a lot of rather good reasons why 0^0 = 1 is a good way to define it (despite the fact that the function f(x,y) = x^y will be discontinuous there no matter how it's defined)
07:27:57 <Cale> For one, n^m is the number of functions from a set of size m to a set of size n, and there is one function from the empty set to itself.
07:28:37 <tromp> and there is exactly one empty string
07:28:41 <Cale> For another, it removes many special cases from infinite series expansions, e.g. exp(x) = sum over k >= 0 of x^k / k!
07:28:54 <zygoloid> the function x^0 is constant if 0^0 is 1. the function 0^x is discontinuous at x=0 no matter what value you pick for x=0
07:29:15 <alfa_y_omega> > 1 ** 0.00000000001
07:29:16 <lambdabot>   1.0
07:29:24 <alfa_y_omega> > 1 ** 0.00000000000
07:29:25 <lambdabot>   1.0
07:29:26 <Cale> If you leave 0^0 undefined, then exp(0) will be undefined according to that series expansion
07:29:55 <Cale> and you'll be forced to write things like exp(x) = 1 + sum over k >= 1 of x^k / k!
07:30:04 <Cale> which is just slightly more awkward and harder to work with
07:31:00 <alfa_y_omega> > 0.00000000001 ** 0
07:31:01 <lambdabot>   1.0
07:31:39 <alfa_y_omega> Cale, for me, 0^0=undefined.
07:31:57 <Cale> alfa_y_omega: I'm trying to convince you that 0^0 = 1 is a good definition though :)
07:32:25 <alfa_y_omega> then we've a discrepancy in this issue.
07:32:26 <Cale> If you care about the analysis aspect of it, the limit as (x,y) -> (0,0) along any differentiable curve not tangential to the y axis of x^y is 1
07:33:53 <Cale> As a result, if you have some rounding error which makes both x and y round to 0 when they otherwise would have been positive numbers, in all probability the result you wanted was something close to 1.
07:35:36 <alfa_y_omega> > 0 ** -0
07:35:36 <lambdabot>   Precedence parsing error
07:35:36 <Cale> It's for that reason that the floating point specification defines 0^0 to be 1
07:35:37 <lambdabot>      cannot mix `GHC.Float.**' [infixr 8] and pref...
07:35:44 <Cale> > 0 ** (-0)
07:35:44 <alfa_y_omega> > 0 ** (-0)
07:35:45 <lambdabot>   1.0
07:35:45 <lambdabot>   1.0
07:35:59 <alfa_y_omega> 0 ^-0 is 0/0, right? why 1?
07:36:07 <Cale> no
07:36:16 <Cale> 0^(-0) is 0^0 which is 1
07:36:21 <Cale> It's not 0/0
07:36:26 <matthiasgorgens> 0^0 isn't really defined.
07:36:32 <Cale> It is really defined
07:36:33 <opqdonut> it can be and often is
07:36:34 <zygoloid> sure it is.
07:36:42 <matthiasgorgens> there are competing definitions.
07:36:51 <Cale> (I have a mathematics degree, if that means anything to you :)
07:36:51 <opqdonut> it's as defined as x^0 for all other x
07:36:55 <mauke> we killed them
07:36:58 <opqdonut> matthiasgorgens: no, there really aren't
07:37:10 <opqdonut> not outside elementary school, at least :)
07:37:10 <Cale> Everything in mathematics is really up to us.
07:37:14 <alfa_y_omega> mathematicians fight themselves due to the definition problem of 0^0
07:37:20 <matthiasgorgens> oh, you can define 0^0 = a house with a mouse.
07:37:27 <matthiasgorgens> but that would make as much sense as any other value.
07:37:29 <mauke> scroll up
07:37:32 <Cale> We get to choose for ourselves whether or not things are defined and how they're defined when they are.
07:37:36 <opqdonut> alfa_y_omega: they might fight on other issues, but they tend to agree that 0^0 is 1
07:37:43 <matthiasgorgens> oops, yes, scrolling up would have helped.
07:37:44 <Cale> and there are a lot of really good reasons why we'd want 0^0 to be 1
07:37:47 <mauke> rationale was provided
07:38:13 <Cale> The most important one in my eyes being the combinatorial one: n^m should count the number of functions from a set of size m to a set of size n
07:38:40 <Cale> Or the number of strings of length m with an alphabet of size n
07:38:54 <matthiasgorgens> Cale, that's the same thing. ;o)
07:38:59 <Cale> Or the number of ways of painting m objects with n colours.
07:39:01 <alfa_y_omega> > 0 ** (-0.000000000000000000001)
07:39:02 <lambdabot>   Infinity
07:39:02 <Cale> Yes, same thing :)
07:39:21 <Cale> In any case, the result when both are 0 is 1.
07:39:33 <alfa_y_omega> wrong?
07:39:44 <matthiasgorgens> Cale, we should leave it undefined (like in C), and make the program format your hard disk (valid behaviour, since it's undefined) if you try to do 0 ^ 0.
07:39:59 <mauke> matthiasgorgens: it's 1 in C
07:40:13 <Cale> alfa_y_omega: It got rounded to infinity. Note that what values of x^y are for numbers x and y not equal to 0 has no bearing on what x^y is when x and y are both 0
07:40:20 <matthiasgorgens> I meant `undefined' like in the word undefined in the C standard.
07:40:33 <Cale> matthiasgorgens: I wholeheartedly disagree.
07:40:55 <Cale> 0^0 = 1 is natural
07:41:07 <matthiasgorgens> You shouldn't really pick the value you want 0^0 to have, but the rules you want any value to conform to.
07:41:12 <alfa_y_omega> 0^(0-) = infinity, weird?
07:41:13 <silver> any good reasons for 0^0 to be 0?
07:41:26 <Cale> silver: Not any particularly convincing ones.
07:41:30 <alfa_y_omega> > 0 ** (+0.000000000000000000001)
07:41:31 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
07:41:31 <lambdabot>    arising from a use of `...
07:41:37 <alfa_y_omega> > 0 ** (0.000000000000000000001)
07:41:37 <lambdabot>   0.0
07:41:42 <Jafet> And which standards committee defined x^y for all other x,y?
07:41:42 <Cale> silver: except that it makes 0^x a constant function.
07:41:49 <matthiasgorgens> silver, 0^n = 0 for all n in [0,1,..]
07:41:51 <alfa_y_omega> 0^(0+) = 0. OK.
07:41:54 <matthiasgorgens> that's a reason.
07:42:02 <matthiasgorgens> though i don't know if it's good enough.
07:42:16 <Cale> Actually, there are already several definitions which have to be overlapped to talk about x^y where x might be 0 and might be a real number in the first place
07:42:25 <Cale> (well, at least 2)
07:42:26 <Jafet> That's not a good reason, because it doesn't help you do math more efficiently.
07:42:43 <alpounet> alfa_y_omega, 0^(0-) = 1/(0^(0+)) somehow
07:42:46 <alpounet> so it's natural
07:42:49 <Jafet> Letting 0^0 = 1 tends to help you do certain kinds of math more efficiently.
07:43:13 <alfa_y_omega> alpounet, = 1/0 = division by zero
07:43:26 <Cale> alfa_y_omega: I don't see how division by zero has anything to do with this
07:43:36 <Jafet> But 1/(0^0) is 1/1.
07:43:43 <Cale> We're not talking about division, we're talking about exponentiation
07:43:59 <alpounet> except that it's not exactly this
07:44:14 <Jafet> Well, you started with the pseudo math
07:45:02 <Cale> In the real numbers, when x is (strictly) positive, and y is any real value, we define x^y to be exp(y log x)
07:45:16 <matthiasgorgens> http://www.smbc-comics.com/index.php?db=comics&id=2249#comic
07:45:17 <Cale> Unfortunately, that definition isn't applicable when x = 0
07:45:30 <matthiasgorgens> (mathematicians are no longer allowed at sporting events.)
07:45:43 <Cale> and so how the function is defined for 0^x is up to us
07:46:10 <Cale> The obvious thing to do is to extend the natural definition for exponentiation on the natural numbers
07:46:31 <Cale> which can be defined separately according to that combinatorial principle of counting the number of functions between finite sets
07:46:40 <opqdonut> or products
07:46:45 <opqdonut> the value of the empty product is 1
07:46:50 <Cale> indeed
07:47:32 <opqdonut> since then we have (ab)(cd) = <emptyproduct>(abcd), and other nice things
07:47:36 <Cale> The other thing we could argue is that 0^x should always be undefined
07:47:52 <Cale> But that's stupid and inconvenient, just like leaving 0^0 undefined is.
07:48:01 <alfa_y_omega> exponentiation is for base "e", not base 0.
07:48:29 <Cale> x^y is defined using natural exponentiation (base e)
07:48:41 <Cale> for positive x and real y
07:48:44 <alfa_y_omega> translated to base 0 is ....
07:48:54 <Cale> You can't use that definition for x = 0 though
07:48:55 <alfa_y_omega> confused.
07:49:06 <Cale> exp(y log x) is meaningless when x = 0
07:49:18 <Cale> Because log isn't defined at 0
07:49:25 <alfa_y_omega> bingo!
07:49:33 <Cale> But that means 0^1 is undefined as well
07:49:48 <Cale> So this definition is incomplete. We want to extend it.
07:49:50 <alfa_y_omega> 0^1 is defined, 0^1 = 0 = 0
07:49:58 <Cale> no it isn't, not by this definition.
07:50:09 <Cale> If we simply define x^y = exp(y log x)
07:50:17 <Cale> then 0^1 = exp(1 log 0)
07:50:21 <Cale> but log 0 is meaningless
07:50:46 <sipa1024> can't you extend the missing point using a right-limit for x going to 0?
07:51:04 <Cale> You could do that indeed.
07:51:55 <Cale> But limits aren't even really necessary. I consider limits to be a sort of measure of last resort when trying to naturally extend functions.
07:52:13 <Cale> We can just think about what we want the symbol x^y to mean.
07:52:30 <Cale> and the conditions that we want it to satisfy
07:52:43 <alfa_y_omega> mathematicians fail!
07:53:03 <Cale> The most important one being that when y is a natural number, x^y should be the product of y copies of x.
07:53:17 <Cale> and the product of 0 copies of anything is 1
07:54:11 <quicksilver> Cale: (sometimes a condition we want a function to satisfy is the condition of 'being continuous' and that provides a motivation to use limits)
07:54:18 <Cale> yeah
07:54:56 <quicksilver> but I agree other motivations will sometimes seem 'simpler' motivations
07:55:01 <alfa_y_omega> 0^(0-) weird, 0^0 disputed, 0^(0+) ok.
07:55:03 <quicksilver> which argues in their favour.
07:55:12 <Cale> alfa_y_omega: 0- and 0+ aren't numbers
07:55:18 <quicksilver> quite.
07:55:56 <Cale> Or at least, they're not elements of the real numbers
07:57:57 <opqdonut> (Cale: rather, they're not elements of the standard model of the reals)
07:58:45 <Cale> Well, it's not even really clear what they're meant to signify here.
07:58:53 <opqdonut> that too
07:58:59 <Cale> I suppose you could define them to be specific elements of the hyperreals, but which?
07:59:15 <Cale> There are lots of infinitesimals on either side of zero in that field.
08:00:14 <Cale> Or *I guess* if you're a crazy person (like some people around here >_>) you can define them using nilsquare elements and rely on intuitionist logic to avoid contradictions :)
08:00:24 <Veinor> 1/omega ?
08:00:29 <opqdonut> Cale: :)
08:00:29 <Veinor> it seems like a natural infinitesimal choice
08:00:37 <opqdonut> Veinor: that doesn't mean anything
08:00:51 <opqdonut> Veinor: at least, not before defining a ton of things
08:00:54 <Veinor> i might be getting the surreals confused with the hyperreals
08:01:01 <Cale> yeah
08:04:37 <alfa_y_omega> 0^(0-) = 1/(0^0+) = 1/0 = division by zero, not infinity.
08:05:21 <zygoloid> so, this is #haskell. in haskell, 0^0 is defined to be 1.
08:05:51 <opqdonut> alfa_y_omega: you can go ask #math what they think about the issue
08:08:27 * hackagebot hatt 1.3.0 - A truth table generator for classical propositional logic.  http://hackage.haskell.org/package/hatt-1.3.0 (BenedictEastaugh)
08:16:09 <mauke> select :: [IO a] -> IO a
08:17:30 <mauke> select xs = do { v <- newEmptyMVar; ts <- forM xs (\x -> forkIO (x >>= putMVar v)); r <- takeMVar v; forM_ ts killThread; return r }
08:19:36 * osfameron fixes a bug caused by trying to do a pure operation on a variable that wanted to be mutated later.  (in NotHaskell)
08:20:04 <osfameron> another salutory lesson to show that every time you use mutable data, God kills a kitten. (Or makes you waste an hour).
08:24:13 <erus`> osfameron: what was the mutable data?
08:28:55 <osfameron> erus`: metadata about a report.  I'd had a flash of *brilliance* and decided to inplace edit this metadata with the calculated "short name", instead of making it an OO method.
08:29:15 * osfameron travels back in time and shoots himself in the head, pour encourager les autres
08:32:50 <k0ral> does someone know the meaning of readProcess (System.Process) exit codes ?
08:33:45 <gwern> k0ral: they arent the usual unix exit codes?
08:34:30 <k0ral> gwern: maybe, you tell me
08:34:52 <zygoloid> they are whatever the process produces as its exit code :)
08:35:10 <gwern> k0ral: well, that'd be my assumption as to what they are. do you have any reason to not think that?
08:35:51 <k0ral> gwern: could be exit codes related to readProcess itself
08:36:53 <shahn> k0ral: If readProcess encounters an error itself, it throws an exception (I assume).
08:37:00 <quicksilver> the docs are fairly clear.
08:37:08 <quicksilver> data ExitCode
08:37:13 <quicksilver> ExitSuccessindicates successful termination;
08:37:29 <quicksilver> ExitFailure Int indicates program failure with an exit code. The exact interpretation of the code is operating-system dependent. In particular, some values may be prohibited (e.g. 0 on a POSIX-compliant system).
08:37:51 <gwern> makes sense. 0 has always been an exit with success
08:38:23 <k0ral> fine, I'm then looking for what does UNIX exit code 2 mean
08:38:54 <zygoloid> k0ral: readProcess does not produce an exit code. it returns IO String. (at least, in the current version of the process package)
08:39:14 <zygoloid> k0ral: unix does not define the meaning of non-zero exit codes, it depends on which command you ran.
08:39:39 <k0ral> zygoloid: readProcess includes the exit code in its output string, if any
08:39:46 <k0ral> zygoloid: that's a fair point
08:40:31 * hackagebot http-types 0.6.5 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.6.5 (AristidBreitkreuz)
08:46:21 <Cale> alfa_y_omega: You should note that:
08:46:23 <Cale> > 1/0
08:46:24 <lambdabot>   Infinity
08:46:35 <Cale> alfa_y_omega: By definition in IEEE floating point
08:47:10 <Cale> alfa_y_omega: IEEE floating point has Infinity, -Infinity, and NaN
08:47:30 <Cale> > 1/(-0)
08:47:31 <lambdabot>   -Infinity
08:47:42 <Cale> It also has a negative zero
08:47:44 <lunaris> > 0/0
08:47:45 <lambdabot>   NaN
08:48:08 <NemesisD> hi all. i'm trying to compile a web app i made with warp. when i try to run the output file from ghc i get "zsh: exec format error: Server.o"
08:48:33 <NemesisD> oh wait thats the object file... i need coffee
08:48:39 <Cale> NemesisD: .o files are not execu.... right
08:53:19 <JakubOboza> > 1/(-0)
08:53:20 <lambdabot>   -Infinity
08:55:35 <Veinor> > 0 == -0
08:55:36 <lambdabot>   True
08:55:44 <Veinor> > 1 / 0 == 1 / (-0)
08:55:45 <lambdabot>   False
08:55:48 <Veinor> math is broken!
08:55:53 <Veinor> > 1 / 0 == 1 / 0
08:55:54 <lambdabot>   True
08:57:07 <chrisdone> @tell bmm <bmm> Aah, I get it, www.hpaste.org just doesn't work. Whoever maintains it, look up a redirect for nginx please — Done.
08:57:08 <lambdabot> Consider it noted.
08:57:58 <luite> yay
08:58:50 <NemesisD> woo. 5000 req/s
08:59:02 <chrisdone> NemesisD: Warp?
09:01:38 <mekeor> chrisdone: you are chrisdone??
09:01:51 <mekeor> http://chrisdone.com/ ← this guy?
09:02:04 <chrisdone> Yes?
09:02:07 * chrisdone cowers
09:02:07 <mekeor> cool! oO
09:02:08 <mekeor> :)
09:02:18 <chrisdone> o/
09:02:36 <NemesisD> chrisdone: yessir
09:02:41 <mekeor> you really have many haskell-projects, as i read just right now...
09:02:44 <harlekin> @pl (\s -> f (f (f (g))) =<< h s)
09:02:44 <lambdabot> (f (f (f g)) =<<) . h
09:03:08 <NemesisD> chrisdone: i believe you were the guy i was talking to on haskell-beginners about this very subject
09:03:09 <harlekin> Is there a way to shorten mapM_ (mapM_ (mapM_ f)) to map over [[[a]]]?
09:03:17 <chrisdone> Ah, right.
09:04:51 <ManateeLazyCat> Good night all. :)
09:06:08 <mekeor> ManateeLazyCat: gn
09:08:23 <Veinor> harlekin: mapM_ . mapM_ . mapM_ $ f
09:08:24 <Veinor> :P
09:08:36 <chrisdone> I want to use highlighting-kate but it's GPL. As I understand it I can use it and link to it in my codebase, but if I distribute the source *with* highlighting-kate then I need to re-licence everything to GPL?
09:08:42 <xkb> Is it possible to pattern match on record fields? Like calcSum {_ age=a _} = sum a?
09:08:58 <benmachine> chrisdone: I think if you only distribute source you can't go wrong
09:09:06 <benmachine> chrisdone: it's if you distribute binaries that you have to worry
09:09:12 <benmachine> (...maybe?)
09:09:15 <Veinor> xkb: yes, and I don't think you need the _s
09:09:24 <Veinor> so calcSum {age=a} = sum a
09:09:24 <xkb> ah
09:09:28 <xkb> nice
09:10:31 <ManateeLazyCat> Any chinese here? I'm looking for some Chinese guy help me translate all linux software's summary to Chinese, then use those document in software-center. :)
09:10:31 <mekeor> chrisdone: maybe you could ask #fsf, #gnu or #freesoftware?
09:10:58 <chrisdone> benmachine: I don't really understand it. I'm too impatient; I may just go with hscolour. —Aw, crap, hscolour is also GPL. I'm drowning in a sea of GPL.
09:11:07 <djahandarie> ManateeLazyCat, monochrom speaks Chinese!
09:11:09 <benmachine> chrisdone: :( life is hard
09:11:36 <ManateeLazyCat> djahandarie: I believe monochrom is not native Chinese. ;p
09:11:41 <chrisdone> mekeor: They'll just convince me to switch and I'll end up with my housing investments in GPL.
09:12:09 <GOP-USA_dotcom> http://members.beforeitsnews.com/story/700/420/Bitcoin_the_Bit-con:_Avoid_the_Bubble,_Stay_High_and_Dry.html
09:12:16 <mekeor> chrisdone: well.. you're right ^^. but why not switch to GPL?
09:12:24 <benmachine> chrisdone: well, they're not exactly going to be unbiased, but I doubt they're outright going to lie to you
09:12:31 <benmachine> so ask them but be skeptical of the response :P
09:12:38 <benmachine> if they say you're fine you almost certainly are :)
09:13:48 <chrisdone> mekeor: Because I develop a lot of Haskell privately and GPL limits what I can do with my code.
09:13:50 <adorablepuppy> chrisdone: I believe a number of open source licenses are GPL compatible.
09:13:58 <chrisdone> benmachine: I'll see.
09:14:36 <quicksilver> chrisdone: don't ask the FSF :)
09:14:40 <quicksilver> chrisdone: ask the *author*
09:14:46 <quicksilver> it's the author's opinion that matters.
09:14:50 <ManateeLazyCat> http://hi.baidu.com/feisit/blog/item/847750f4f3e0ee76ddc474de.html This is my software-center
09:15:15 <quicksilver> I'm not lawyer and I don't have time to play one in IRC tonight. But - the key question you have to answer is "is my software a derived work of highlighting-kate" ?
09:15:52 <quicksilver> if it is, then you have to distribute the whole package under terms compatible with the GPL. You are of course never forbidden from having looser terms apply to the part which is ours.
09:15:57 <quicksilver> yours.
09:16:25 <xkb> hmm.. and pattern matching on a specific value in a record only? like sumIfMaleOnly {"m" age=a} = sum a?
09:17:31 <quicksilver> xkb: sumIfMaleOnly{gender="m",age=a} = sum a
09:17:31 <chrisdone> quicksilver: I don't think it's a derived work. hpaste may use it to make some code look a bit pretty, but I can trivially swap it for another library.
09:17:52 <xkb> quicksilver: ah so it both binds and matches
09:17:55 <xkb> cool
09:17:56 <Saizan> quicksilver: plus a constructor, i'd guess
09:18:02 <quicksilver> good point Saizan ;)
09:18:03 <JakubOboza> > (\x->x*x) 5
09:18:04 <lambdabot>   25
09:18:20 <xkb> aha, I also forgot the Record constructor
09:18:24 <quicksilver> xkb: yes, it matches against constructors ("m" is a constructor, technically) and binds against variables (like a)
09:18:26 <xkb> that's why it did not work
09:18:42 <camaleon> shapeless , who let the dogs out ?
09:18:53 <chrisdone> quicksilver: What might the author say? (Apart from, from experience of other people asking him to re-license or allow a dual-license, he refused and pressed only GPL.)
09:19:37 <JakubOboza> > (\y -> (\x->x*y) ) 5
09:19:38 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
09:19:38 <lambdabot>    arising from a use of `...
09:20:08 <JakubOboza> > (\y -> ((\x->x*y) x) ) 5
09:20:09 <lambdabot>   x * 5
09:20:48 <shapeless> camaleon, dont understand, no native speaker
09:21:58 <shapr> shapeless: AHA! My nemesis!
09:22:20 <rostayob> ok, something is deeply wrong, pacman and firefox segfault
09:22:39 <shapr> rostayob: check your memory, try memtest86
09:23:55 <rostayob> shapr: thanks, is there anything to run inside arch? I have no cd reader and I'm not sure I can find a USB key :P
09:24:40 <shapr> rostayob: ubuntu has memtester, but if you have memory problems, it may install a corrupt binary.
09:25:50 <rostayob> shapr: ok, found usb key, trying now
09:25:52 <rostayob> thanks for the help
09:26:32 <shapr> rostayob: so, memory corruption or disk corruption, often memory problems result in on-disk corruption.
09:27:12 <chrisdone> Ah, highlighting-kate uses PCRE anyway. Not worth using.
09:28:03 <shapr> chrisdone: are you part of the cult of done?
09:28:37 <chrisdone> shapr: I am on a drug. It's called *Chris Done*! I'm done here and I'm done there.
09:28:43 <shapr> haha, awesome!
09:29:20 <mauke> chrisdone: you broke my hpaste!
09:29:38 <chrisdone> Whatcha talkin’ bout?
09:30:04 <mauke> the interface changed completely
09:30:20 <djahandarie> The Agda language option doesn't seem to be using Haskell highlighting anymore
09:30:23 <mauke> urls, form fields, field values
09:30:44 <mauke> also I get a 500 Server Error when I specify channel/language as 0
09:31:00 <djahandarie> chrisdone, he had a bot set up to automatically copy any pastebin links in here to hpaste
09:31:12 <chrisdone> mauke: Ah— you're automating it? I'm gonna add a JSON API tonight, if that's preferable.
09:31:24 <mauke> I'd prefer a form api
09:31:26 <chrisdone> Ahhh. So that explains those pastes.
09:31:49 <mauke> also there is no "plain text" language
09:31:53 <chrisdone> It's funny; I specifically changed those fields to have proper names and such so that it would be easier to interface with.
09:32:03 <chrisdone> Yeah, I'll fix that. Hold on.
09:32:03 <mauke> yeah, I noticed :-)
09:32:13 <benmachine> and no "other channel" channel :P
09:32:23 <benmachine> (what is the channel field even for, anyway?)
09:32:35 <mauke> dunno, I've hardcoded it to 1
09:34:07 <chrisdone> mauke: Alternatively I can change those numbers to slug strings. Preferable?
09:34:44 <chrisdone> Somehow hardcoding my internal primary keys sounds bad.
09:34:46 <mauke> what's that?
09:34:55 <chrisdone> I mean "haskell" instead of 5, or whatever.
09:35:10 <mauke> sure, as long as I can leave it empty
09:35:18 <chrisdone> Grand.
09:35:19 * chrisdone hacks
09:36:11 <chrisdone> benmachine: The channel field is that I can, tonight/this weekend add announcing and link to channel logs.
09:36:26 <JakubOboza> > 5 * "haskell"
09:36:26 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
09:36:27 <lambdabot>    arising from the literal ...
09:36:40 <benmachine> chrisdone: hmm, do you have any idea how often it is used correctly?
09:36:47 <benmachine> I would say default channel to 'none'
09:37:07 <benmachine> oh I guess you're already going to do that
09:37:09 <benmachine> ok fair enough
09:44:19 <ski> chrisdone : what `lisppaste' does is that if you ask it (the bot) for the paste url in a channel, e.g. #scheme, it responds with `http://paste.lisp.org/new/scheme', and similarly for other channels, but if you ask it in private, you get `http://paste.lisp.org/new' instead
09:45:02 <ski> chrisdone : the difference is that with the channel name in the url, the channel field is preselected to that channel. one could put that url in the topic as well, of course
09:45:05 <chrisdone> ski: Good idea, we can have hpaste.org/new/haskell
09:45:31 <mekeor> why do haskellers approximately always use the BSD-license?
09:45:55 <flux> mekeor, why not?
09:46:11 <mekeor> flux: cause GPL is IMO better :)
09:46:42 <ski> > "GPL" > "BSD"
09:46:43 <lambdabot>   True
09:46:46 <flux> well, it is, if you are have a political agenda..
09:46:51 <byorgey> mekeor: there have been lengthy discussions on the mailing list about the relative merits of various licenses.
09:47:00 <flux> but if you just care that your code is going to be used by someone, BSD is a great choice.
09:47:09 <ski> (now you only need to determine if more or better or worse ..)
09:47:20 <byorgey> mekeor: but I think the simplest reason is that if everyone else is already using a BSD license, and you don't have a strong opinion, it makes sense to use the same license as everyone else.
09:47:59 <byorgey> that doesn't explain why the first Haskellers started using BSD licenses but it does explain why the vast majority do now.
09:48:00 <mekeor> everyone? -- what about the GNU-project? :P
09:48:15 <chrisdone> mauke: Ah, I did make the channel and language optional, empty string should do it… I just forgot to add the option, hur.
09:48:25 <byorgey> by "everyone else" I meant Haskellers, e.g. when choosing a license for a package you are going to upload to Hackage
09:49:32 <mekeor> does hackage force bsd?
09:49:51 <chrisdone> No.
09:49:59 <mekeor> thats good. :)
09:50:40 <mekeor> ok. thanks for those information.
09:50:41 * hackagebot attoparsec 0.9.1.1 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.9.1.1 (BryanOSullivan)
09:50:50 <benmachine> I think hackage rejects AllRightsReserved though?
09:53:13 <mekeor> > putStrLn "foobar"
09:53:14 <lambdabot>   <IO ()>
09:53:33 <mekeor> can i make lambdabot print "foobar"?
09:53:38 <ski> > "foobar"
09:53:40 <lambdabot>   "foobar"
09:54:58 <mekeor> > (\(x:xs)->x:[e|e<-xs,e`mod`x/=0])[2..]
09:54:59 <lambdabot>   [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
09:55:03 <mekeor> cool :)
09:55:28 <ski> i hope that's not supposed to be only primes
09:55:47 <mekeor> oops.. LOL. ^^
09:56:07 <c_wraith> 33 and 45 are totally prime
09:56:16 <c_wraith> that's a new term meaning "composite"
09:56:17 <mekeor> hmm. what did i do wrong?
09:56:23 <ski> also `9'
09:56:39 <ski> you forgot to iterate the "sieving"
09:56:43 <byorgey> mekeor: that lambda only gets applied once, and there is no recursion/iteration
09:56:46 <c_wraith> well, it seems what you did was filter out even numbers
09:57:02 <mekeor> byorgey: right..
09:57:39 <mekeor> > let sieve (x:xs) = x:sieve [e|e<-xs,e`mod`x/=0]) in sieve [2..]
09:57:40 <lambdabot>   <no location info>: parse error on input `)'
09:58:05 <mekeor> let sieve (x:xs) = x:sieve [e|e<-xs,e`mod`x/=0] in sieve [2..]
09:58:11 <jonkri> is it common to have a Types module in projects?
09:58:14 <mekeor> > let sieve (x:xs) = x:sieve [e|e<-xs,e`mod`x/=0] in sieve [2..]
09:58:15 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
09:58:36 <mekeor> --> that's right, isnt it?
09:58:55 <byorgey> jonkri: it's a relatively common pattern.  The reason it shows up is often because the type definitions are mutually recursive
09:59:13 <ski> mekeor : yes
09:59:13 <byorgey> so you put all the mutually recursive type definitions in one module to avoid circular module dependencies
09:59:20 <jonkri> byorgey, yeah, that's the problem i have now :)
09:59:22 <jonkri> thanks
10:00:46 <yoki> hi there, does anybody here know a haskell-library for printing on linux (e.g. CUPS) ?
10:07:05 <xkb> do generators in list comprehensions always need to return lists?
10:07:50 <chrisdone> xkb: Yeah, except recently there's a new (old, but brought back to life) extension for comprehensions generalized for all monads.
10:08:40 <Cale> yoki: Not that I'm aware of (a quick look through hackage doesn't reveal much), but binding to the CUPS libraries in C shouldn't be too bad...
10:08:45 <c_wraith> well, it used to be part of the spec, not an extension
10:09:03 <c_wraith> But yes, list comprehensions must currently result in lists.  What it's a list of is wide-open, though
10:11:04 <ski> > [0 .. 3] `pam` \x -> [0 .. x] `pam` \y -> x + y
10:11:06 <lambdabot>   [[0],[1,2],[2,3,4],[3,4,5,6]]
10:12:06 <mekeor> ski: what does that func do?
10:12:21 <c_wraith> :t pam
10:12:22 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
10:12:33 <c_wraith> it appears to be flip map
10:12:58 <ski> yes
10:13:16 <mekeor> :t map
10:13:17 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:13:35 <mekeor> :t (flip . map)
10:13:36 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[b1]'
10:13:36 <lambdabot>     Probable cause: `map' is applied to too many arguments
10:13:36 <lambdabot>     In the second argument of `(.)', namely `map'
10:13:42 <jonkri> byorgey, could it also be nice to have a Types.hs file if the types are not necessary mutually recursive, but is just somehow related to two modules (in a way that it's not clear which module it should be in)?
10:13:44 <mekeor> :t flip $ map
10:13:45 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
10:13:52 <byorgey> jonkri: sure.
10:14:08 <jonkri> ok goodie :)
10:14:12 <mekeor> ski: pam == flip $ map, right?
10:16:21 <byorgey> jonkri: in OO you usually group things by type (each file is a type with some operations on it) whereas in FP you tend to group things more by functionality.
10:16:22 <ski> <c_wraith> it appears to be flip map
10:16:24 <ski> <ski> yes
10:16:37 <ski> <ski> /msg lambdabot @let pam = flip map
10:16:38 <jonkri> interesting :)
10:16:42 <mekeor> ... :)
10:16:56 <benmachine> there aren't many functions of type [a] -> (a -> b) -> [b] I'd've thought
10:17:00 <byorgey> so a Types module just defines your "domain of discourse" and then your other modules define your algorithms
10:17:00 <benmachine> well, there are infinitely many
10:17:07 <benmachine> but a relatively small infinity >_>
10:17:19 <benmachine> well, there are countably many, but still
10:17:54 <byorgey> benmachine: in a certain technical sense there is only one "interesting" one
10:18:20 <byorgey> in that all others can be decomposed into the interesting one followed by something else.
10:18:27 <benmachine> ah, I see
10:18:32 <benmachine> neat
10:18:36 <benmachine> um
10:18:47 <benmachine> every function can be decomposed into f . id though :P
10:18:59 <benmachine> so presumably there's some restrictions on the something else
10:19:38 <byorgey> but id does not have the type [a] -> (a -> b) -> [b]
10:20:06 <benmachine> oh, I see what you mean
10:20:28 <byorgey> the "interesting" one here being of course  flip map
10:21:07 <benmachine> so every such function is g . flip map for g :: [b] -> [b]?
10:21:17 <byorgey> right.
10:21:24 <ski> byorgey : one might express it as grouping "operations" with common domain (i.e. methods of an object) together in OO and grouping "operations" with common codomain (individual branches in pattern-matching) together in FP
10:21:36 <byorgey> the intuition is that every such function breaks down into some mapping, followed by some rearranging/deleting/duplicating
10:21:41 <joe6> any suggestions on how I can fix this:  http://sprunge.us/LLHZ , error:  http://sprunge.us/RCOa
10:21:59 <byorgey> and the rearranging/deleting/duplicating is independent of the mapping.
10:22:03 <joe6> I am trying to get sramOutput to a Test and also use the output that it provides.
10:22:08 <byorgey> because of the polymorphism.
10:22:19 <ski> (parametric polymorphism)
10:22:25 <byorgey> right, thanks
10:22:28 <joe6> i want to change this checkDataRead :: Assertion
10:22:44 <joe6> from Assertion to Test, as assertions are failing on the first failure
10:22:56 <joe6> whereas, I want it to check everything..
10:23:21 <joe6> any suggestions, please?
10:23:22 <byorgey> ski: yes, that's an interesting way to look at it.
10:24:11 <joe6> this works: checkDataRead, I am not able to the checkDataReadT to work.
10:25:11 <joe6> s/to the/to get the/
10:30:36 <joe6> can I do this without the lambda:  http://sprunge.us/YeNL
10:31:14 <djahandarie> @pl (\x y -> f . g x $ y)
10:31:14 <lambdabot> (f .) . g
10:31:31 <chrisdone> Yeah, but it ain't that preferable.
10:32:20 <djahandarie> \x y -> f . g x $ y   ==   \x -> f . g x   ==   (f .) . g   ==   f .: g
10:32:25 <djahandarie> Pick your poison...
10:32:54 <marchdown> Can I use Xcode4 with haskell platform or should I settle for Xcode3?
10:34:18 <joe6> i have  http://sprunge.us/NHaD , and I am trying to get to:  http://sprunge.us/ZHhd . I cannot get the sramoutput to fit in. any thoughts, please? this is the shorter version of what I was asking before.
10:34:26 <joe6> djahandarie , thanks
10:34:28 <dagit> marchdown: IIRC, xcode3 works fine
10:34:51 <joe6> \x -> f . g x  , i like this
10:35:22 <jonkri> anyone using leksah that can explain what this means: "you can choose Add import from the context menu in the log pane"? where is the log pane? if the log pane is the text area where compilation output goes, there is nothing related to adding imports in its context menu
10:35:45 <jonkri> aha, i have to right click on the error :)
10:35:52 <marchdown> So I *shouldn't* use xcode4 yet?
10:37:30 <chrisdone> mauke: 'K, slugged and empty chan/lang supported.
10:38:07 <chrisdone> Still pondering how to approach the syntax highlighting problem. I'll try gutting highlighter and replace its use of libpcre with a pure Haskell regex lib.
10:39:31 <chrisdone> (… we have those, right?)
10:39:33 * chrisdone checks hackage
10:39:55 <dagit> preflex: seen pastorn
10:39:55 <preflex>  pastorn was last seen on #haskell 4 days, 21 hours, 7 minutes and 51 seconds ago, saying: SDL another
10:40:51 <dagit> preflex: help
10:40:51 <preflex>  try 'help help' or see 'list' for available commands
10:40:59 <joe6> pastorn was sick a few weeks ago.
10:41:28 <dagit> ?seen pastorn
10:41:29 <lambdabot> Unknown command, try @list
10:41:41 <dagit> how do I get preflex to join a channel?
10:42:01 <chrisdone> mauke: Do you recommend a pure-Haskell regex library?
10:42:50 <dagit> Who runs preflex again?  Is it mauke?  dolio?  /me can't remember
10:42:56 <thoughtpolice> mauke
10:43:16 <dagit> thanks
10:43:33 <chrisdone> regexpr looks promising.
10:47:20 <joe6> any suggestions with this, please?  http://sprunge.us/PiLQ . I seem to be tying myself into a knot here, error:  http://sprunge.us/eMNT
10:49:03 <doserj> joe6: the TestList constructor expects a list, but you generate an IO action
10:52:04 <joe6> doserj: i have a list of tests but they need something from the IO action to test
11:05:38 <doserj> joe6: you can't turn IO [a] into [IO a], if that is what you want.
11:06:00 <benmachine> doserj: you can, but not in a way that's useful :P
11:06:11 <c_wraith> :t map return
11:06:12 <lambdabot> forall a (m :: * -> *). (Monad m) => [a] -> [m a]
11:06:12 <codolio> @type return . (head <$>)
11:06:13 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Monad m, Functor f) => f [a] -> m (f a)
11:06:29 <c_wraith> :t fmap (map return)
11:06:30 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f [a] -> f [m a]
11:06:39 <benmachine> I was thinking more like
11:07:12 <benmachine> :t \x -> map (\i -> fmap (!! i) x) [0 ..]
11:07:13 <lambdabot> forall a (f :: * -> *). (Functor f) => f [a] -> [f a]
11:07:37 <benmachine> or um, const []
11:08:09 <codolio> So many options to choose from.
11:08:21 <benmachine> there are certainly no total functions of that type, I reckon
11:08:28 <benmachine> apart from const []
11:09:04 <codolio> There are others.
11:09:14 <robinhoode> Anyone ever get one of these using STM? "longjmp causes uninitialized stack frame: /usr/lib/ghc-6.12.3/lib/ghc terminated"
11:09:31 <codolio> longjmp, eh?
11:09:41 <robinhoode> I'm just learning this package, so I don't even know where to begin.. Google is not much help with this particular error
11:10:13 <codolio> You're not linking to some custom C code of your own, are you?
11:10:35 <robinhoode> No, no, no.. It's likely I'm doing something wrong
11:10:52 <robinhoode> .. in terms of reading/writing to channels and such
11:10:53 <codolio> Is the code relatively unremarkable Haskell?
11:10:53 <djahandarie> robinhoode, that error happens at runtime?
11:10:59 <robinhoode> In ghci
11:11:11 * lispy switches back to irssi
11:11:19 <codolio> Because unless you're doing evil stuff, it's unlikely you'd be doing anything wrong enough to cause that error.
11:11:26 <lispy> sooo painful...
11:11:41 <codolio> That looks like an RTS bug.
11:11:42 * copumpkin puts lispy out of his misery
11:12:08 <flamingspinach> haskell-platform 2011.2 has finally entered debian testing! hurrah! :D
11:12:09 <byorgey> robinhoode: what version of ghci?
11:12:10 <parcs> anyone have any idea why System.Timeout.timeout doesn't work with Language.Haskell.Interpreter.runInterpreter (from the hint package)?
11:12:23 <byorgey> robinhoode: even if you are doing something wrong, that should not happen
11:12:24 <parcs> any by that i mean that it never actually timeouts
11:12:27 <codolio> Of course 6.12.3 is old, so it may already be fixed.
11:12:35 <robinhoode> Upgrade, then?
11:13:03 <benmachine> parcs: timeout works using async exceptions, does runInterpreter block those?
11:13:05 <codolio> Yeah. You can't really file a bug report without knowing if it still happens with something current.
11:13:11 <c_wraith> parcs: timeout works by sending an async exception to the thread running the action.  If that thread is currently blocking/masking async exceptions...
11:13:26 <parcs> ah..
11:14:43 <parcs> so what would be the best course of action to timeout runInterpreter, then?
11:15:34 <luite> runInterpreter does more by the way, you'll find that you cannot kill the process with SIGTERM :p
11:16:32 <parcs> yeah, i recall experiencing that caveat this morning..
11:16:59 <parcs> hmm, i wonder how mueval does it
11:17:19 <k0ral> can I bother you with a very specific question ?
11:18:02 <dankna> don't ask to ask, heh
11:18:39 <k0ral> here goes
11:18:55 <k0ral> I'm getting the following error: The last statement in a 'do' construct must be an expression
11:19:07 <joe6> ended up with something like this:  http://sprunge.us/ceQZ
11:19:08 <k0ral> imContext <- get webViewImContext webview (_)
11:19:37 <k0ral> webview is of type webView (from webkit)
11:19:43 <byorgey> k0ral: is that the last line in your do block?
11:19:44 <k0ral> WebView*
11:19:45 <dankna> k0ral: there are a few types of statements that can appear in a do construct - let-statements, binds (like what you have), and expression statements, which are the generic ones.
11:19:50 <k0ral> byorgey: no it's not
11:20:02 <byorgey> k0ral: then you should probably check that your indentation is correct
11:20:07 <k0ral> byorgey: it is
11:20:11 <dankna> k0ral: if that isn't the actual last line of your block, you should look for why GHC thinks it is - perhaps indentation?
11:20:23 <byorgey> k0ral: maybe paste your code on hpaste.org?
11:20:39 <k0ral> omg
11:20:41 <k0ral> it wasn't
11:20:52 <dankna> heh :)
11:20:52 <byorgey> =)
11:20:53 <k0ral> just 1 space
11:20:55 <dankna> happy to be of service
11:21:07 <k0ral> 1 little f****** space
11:21:29 <dankna> yes, well, you know what they say - computers and women both get hugely upset over one missed period *^^*
11:21:44 <k0ral> well I'm happy I asked because I was investigating completely other things
11:21:48 <dankna> (emoticon denotes blush haha)
11:21:56 <k0ral> haha
11:23:45 <ahihi2> are there any libraries for parsing JSON streams on the fly?
11:23:59 <dankna> yes, probably, but I don't know them
11:24:55 <ahihi2> :)
11:26:11 <chrisdone> I believe aeson can do it.
11:26:17 <chrisdone> -- import Text.Highlighter.Types-- import Text.Highlighter.Lexers-- import Text.Highlighter.Lexer -- import Text.Highlighter.Formatters.Html (format)
11:26:17 <chrisdone>           (runLexer)
11:26:19 <chrisdone> Erm.
11:26:24 <chrisdone> Clipboard fail.
11:26:24 <chrisdone> http://hackage.haskell.org/package/aeson
11:27:09 <chrisdone> It's based on attoparsec.
11:27:32 <ahihi2> thanks, I'll have a look
11:41:15 <stulli> I get a segfault in rxvt and xterm, but not with gnome-terminal. This bug is clearly above my level of competence.
11:42:21 <ezyang> Are you using rxvt or rxvt-unicode?
11:42:27 <DasIch> is there a recommended project layout, informal or otherwise, for haskell projects?
11:42:41 <ezyang> wait, this is so off topic.
11:43:03 <ezyang> DasIch: Use Cabal. There's some flexibility, so play around with the settings.
11:43:25 <ahihi2> chrisdone: hmm, it looks like attoparsec only operates on ByteStrings — those are always finite, aren't they?
11:43:51 <chrisdone> ahihi2: There are lazy bytestrings… I don't think they are finite.
11:43:54 <stulli> ezyang: rxvt-unicode. Is it off-topic when i get the segfault an a haskell program? I'm using vty and vty-ui from hackage.
11:44:13 <ezyang> Ohh, interesting. That sounds like a bug in vty/vty-ui.
11:44:41 <ezyang> Try running the program in gdb and see if you get a trace of any sort.
11:44:48 <DasIch> ezyang: yeah but how do i structure the files etc.?
11:45:15 <ezyang> One convention is to use the base directory as the module structure base, so if you have module Data.Foo, it lives in Data/Foo.hs
11:45:34 <ezyang> Some people like having all source in a subdir, so they have src/Data/Foo.hs and then set hs-src-dir accordingly.
11:45:50 <stulli> Ok, this will be the first time i'm using gdb. Whish me luck :)
11:46:05 <ezyang> It's not too bad, and a very useful skill to have.
11:46:14 <DasIch> ezyang: are there any projects worth checking out as an example?
11:46:33 <ezyang> pick any well known project off of HAckage and run 'cabal unpack project-name' and check out their source.
11:46:48 <DasIch> ezyang: ok, thanks
11:47:45 <chrisdone> ahihi2: (I've never used atto, though, dunno.)
11:48:15 <ahihi2> ah, there is a Data.Attoparsec.Lazy submodule for those
12:00:51 <byorgey> @oeis 1 7 17 31
12:00:53 <lambdabot>  2*n^2-1.
12:00:53 <lambdabot>  [1,1,7,17,31,49,71,97,127,161,199,241,287,337,391,449,511,577,647,721,799,88...
12:04:15 <stulli> ezyang: Would you say this is helpful output? http://hpaste.org/47661 Seems rather arbitrary to me
12:05:16 <ezyang> Oh yeah, you'll want to compile with debugging.
12:05:39 <stulli> Ah, i see
12:05:59 <ezyang> Anyway, complain to the vty maintainers.
12:06:11 <ezyang> If you're interested in pursuing it further, I can suggest how to set up a testing environment to probe further.
12:06:43 <thoughtpolice> bzzt! that's not a pretty one either. it died somewhere in haskell-land
12:06:48 <thoughtpolice> which is never a good thing :(
12:07:16 <ezyang> Death in Haskell land usually has a smaller stack.
12:07:24 <ezyang> It kind of looks like there's some C trace looking to escape.
12:07:40 <thoughtpolice> well, GDB can also potentially just be confused, but it's hard to tell from some 64bit addresses
12:11:03 <ski> (lispy : .. what was painful ?)
12:11:31 <ezyang> In the event of a userland segfault, I usually pull out Debug.Trace and do some good old printf debugging.
12:11:44 <ezyang> But if it's a library's fault, it's better to give them a testcase and yell at them to fix it.
12:13:19 <thoughtpolice> ezyang: but if haskell was userland, then who was C? and for that matter, who was phone?
12:13:37 <ezyang> ...huh?
12:13:49 <thoughtpolice> (i just think the notion of referring to GHC gen'd code as 'userland' rather funny, presumably in contrast to everything else which is.. something else?)
12:14:06 <ezyang> oh, lol. Yeah, words, I do strange things to them.
12:15:06 <thoughtpolice> it's fine, considering i'm obviously terrible at humor :>
12:16:07 * chrisdone just realized that 'humor' drops the 'u' which is admirable optimization but missed an opportunity for 'humer'
12:16:11 <stulli> ezyang: Well, i suppose yelling at them is much easier in this case...
12:16:17 <ben> hmer
12:16:50 <roconnor> I'm starting to not like this enumerator library:  The type system ought to enforce that an iteratee cannot Continue after an EOF
12:17:37 <mauke> preflex: seen dagit
12:17:37 <preflex>  dagit was last seen on #haskell 1 hour, 34 minutes and 23 seconds ago, saying: thanks
12:22:33 <chrisdone> mauke: Don't fill the email field in. It's a /prog/-esque spam trap.
12:23:22 <mauke> I don't think I've ever done that
12:23:29 <chrisdone> ‘K.
12:28:35 <copumpkin> roconnor: I started fooling with one that did that
12:32:56 <thoughtpolice> roconnor: are you just using john's enumerator package? that would be an interesting addition to have (the type system check)
12:33:34 <roconnor> thoughtpolice: yes
12:34:01 <roconnor> it seems improperly designed; but since I'm a beginner, I might not know what I'm talking about.
12:34:48 <thoughtpolice> it's hard for me to keep up with all the design points in the various enumerator libraries. enumerator is vastly different and more simple than iteratee, but has different error semantics IIRC. OTOH, iterIO I think is conceptually named better and nice to use, but it too has very different error semantics as well
12:35:23 <thoughtpolice> furthermore, pretty soon we're going to hit a ridiculous explosion when people want to use two different enumerator libraries with different packages. it'll be "monads-tf" and "monads-fd" supplementary packages everywhere all over again
12:35:48 <thoughtpolice> enumerator seems to have taken *most* of the mindshare at this point, though. i think that was because it was initially much simpler (and probably still is) than john lato's implementation
12:36:00 <roconnor> once I understand what I'm what I'm doing I'll drop enumerator
12:36:01 <codolio> The situation is way worse than monads-tf vs. monads-fd.
12:36:13 <roconnor> and make my own I guess :P
12:36:28 <codolio> It's more like mtl vs. monadLib.
12:37:37 <roconnor> it seems like Enumerator-lib should just accept the fact that an Iteratee can always yield a value in any state and live with that.
12:37:51 <roconnor> hmm
12:37:55 <roconnor> maybe that isn't true
12:38:05 <roconnor> I haven't though too much about errors yet
12:39:54 <thoughtpolice> there's also something 'off' in my mind about iteratees. dunno what it is. i mean, i like the abstraction, and if I was doing something heavily based on I/O I'd consider them, but frankly there are lots of things you don't need lots of heavy I/O mechanics for, so they're probably overkill
12:40:24 <thoughtpolice> and furthermore, people who come from lazy IO and are used to composing stream based functions are going to be rather perplexed when they go from composing stream functions, to piecing together operations based on chunk-wise pieces, etc
12:40:38 <codolio> I don't know about the newest iteratee package, but I think it's sort of a known issue in the existing ones that certain things aren't statically ruled out that could be.
12:40:44 <codolio> At least, I recall hearing about that before.
12:42:40 <roconnor> it'd be one thing if it was hidden by the module system
12:42:52 <roconnor> but the whole data type is available to be mucked with
12:42:55 <thoughtpolice> again i think enumerator has the most mindshare at the moment, but I do like iterIO. i think it has better naming (especially for beginners,) and a bit better documentation IIRC.
12:43:22 <thoughtpolice> of course, nobody likes the fact it depends on 6 or 7 unnecessary libraries because right now it packages several auxiliary iterators/enumerators with the base implementation
12:43:41 <thoughtpolice> so once that happens, it'll only further add to the explosion of "iteratee-<blah> adapter" libraries
12:44:11 <codolio> thoughtpolice: The thing that's off in my mind is that you have to throw away the natural incrementalism you get from laziness for all your data structures.
12:44:23 <codolio> And instead program to an API for incremental computations.
12:45:04 <thoughtpolice> codolio: i think that better articulates it, yeah.
12:45:25 <thoughtpolice> and like I said they're probably overkill for a lot of things. you can do plenty without hardcore I/O in a lot of areas.
12:45:38 <codolio> So, you can write nice pure code that will evaluate everything in an efficiently interleaved way....
12:46:16 <Elliot_Stern> I'm trying to generate documentation using haddock, and I'm getting the error "no input file(s)".  This happens both when I use 'cabal haddock' and 'runhaskell Setup haddock'.  What am I doing wrong?
12:46:18 <codolio> Until you need to do IO, and then none of that interleaving works with the iteratee interleaving unless you rewrite your algorithms to use iteratees.
12:47:04 <codolio> Lazy I/O has its problems, but it hooks into that natural interleaving.
12:47:29 <acowley> The apparent need for wholesale adoption of the iteratee structure is indeed frustrating
12:47:45 <roconnor> @hoogle Data.ByteString.Lazy.ByteString -> Data.ByteString.ByteString
12:47:45 <lambdabot> Parse error:
12:47:46 <lambdabot>   --count=20 "Data.ByteString.Lazy.ByteString -> Data.ByteString.ByteString"
12:47:46 <lambdabot>                  ^
12:49:44 <chrisdone> What does it like there?
12:50:36 <roconnor> I'm only tryin enumerator to see if I can get my SHA256 padding function to run faster
12:50:36 <roconnor> no IO for me
12:52:05 <stulli> Is 'ghc --make -dcore-lint -debug program.hs' appropriate for compiling with debugging? Because when i do this i get an error elsewhere in the program.
12:52:29 <ezyang> -dcore-lint won't really help you out, if it's not acompiler bug.
12:52:31 <roconnor> do I have to use concat . toChuncks ?
12:52:44 <ezyang> -debug links the Debugging version of the RTS, but won't cause C code to be compiled with debugging symbols? (not sure.)
12:53:03 <stulli> Well, it says: 'Please report this as a GHC bug'
12:53:16 <ezyang> Oh, that's definitely not OK :-)
12:53:18 <ezyang> What's the error?
12:53:59 <stulli> ezyang: http://hpaste.org/47662
12:54:15 <tgeeky_> hm. I'm working through the "trivial monad" blog post...
12:54:40 <ezyang> Huh, that's really interesting.
12:54:44 <tgeeky_> looking at my definition: fmapM dothis = bind (return . dothis)
12:54:59 <tgeeky_> looking at the type of that, and the type of fmap
12:55:12 <tgeeky_> which are:
12:55:27 <tgeeky_> fmapM :: (a -> b) -> W a -> W b
12:55:28 <ezyang> It's possible that this was just triggered by earlier memory corruption in the program.
12:55:39 <ezyang> But it could also be a GHC bug. How big is the hs file you're compiling?
12:55:39 <tgeeky_> fmap :: (a -> b) -> f a -> f b
12:55:47 <ezyang> Can you try compiling with 7.0.3?
12:56:03 <tgeeky_> so, can one say that the functor is a monad with in the computational context "id"?
12:57:17 <tgeeky_> does that statement even grok?
12:57:19 <roconnor> tgeeky_: I don't think I'd say that
12:57:34 <roconnor> I'd say the Identity monad is the monad with in the computational context id.
12:57:47 <tgeeky_> so there is still something deeper than functors going on here
12:58:05 <tgeeky_> hmm
12:58:06 <roconnor> every monad is a functor, with the definition you gave.
12:58:11 <roconnor> @src liftM
12:58:11 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:58:16 <ezyang> Well, every monad is a functor...
12:58:17 <roconnor> @undo . src liftM
12:58:17 <lambdabot> (. src liftM)
12:58:22 <stulli> ezyang: The file is only 150 lines or so. I stripped it down somewhat already. 7.0.3 is not in the arch repos yet apparently?
12:58:24 <roconnor> @. undo  src liftM
12:58:25 <lambdabot> Plugin `compose' failed with: Unknown command: ""
12:58:27 <roconnor> heh
12:58:33 <roconnor> @undo do { x1 <- m1; return (f x1) }
12:58:33 <lambdabot> m1 >>= \ x1 -> return (f x1)
12:58:40 <ezyang> stulli: You can download binaries from the GHC website.
12:58:45 <Elliot_Stern> I's trying to generate some documentation for a library via haddock, but it says "No input file(s).".  How do I get it to recognize that the file is there?
12:58:46 <stulli> also now i get the error on gnome-terminal too
12:58:47 <roconnor> @pl . undo do { x1 <- m1; return (f x1) }
12:58:47 <lambdabot> (line 1, column 1):
12:58:48 <lambdabot> unexpected "."
12:58:48 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
12:58:51 <tgeeky_> roconnor: ohhh wat a sec..
12:58:53 <ezyang> but if you have 150 lines, that might be enough as a test-case.
12:58:54 <roconnor> @. pl undo do { x1 <- m1; return (f x1) }
12:58:54 <lambdabot> f `fmap` m1
12:58:57 <ezyang> If you want, I can poke at it.
12:58:59 <roconnor> gah
12:59:01 <roconnor> too short
12:59:10 <tgeeky_> roconnor: then the context is \_ -> id?
12:59:15 <roconnor> anhow, m1 >>= \ x1 -> return (f x1) is more or less what you wrote
12:59:20 <stulli> Yeah, i will download ghc right now
12:59:45 <roconnor> so your defintion of fmapM is in the standard library where it is called liftM
12:59:54 <tgeeky_> > liftM (id) [1,2,3]
12:59:55 <lambdabot>   [1,2,3]
13:00:05 <tgeeky_> > liftM (id) ()
13:00:06 <lambdabot>   Couldn't match expected type `m a1' against inferred type `()'
13:00:19 <stulli> ezyang: If you want to try yourself, i'll upload the current version to darcsden.
13:00:31 <roconnor> tgeeky_: granted I don't really know what you mean by computational context, so I could have been misinterpreting your statement
13:00:34 <ezyang> sure.
13:00:40 <tgeeky_> roconnor: I don't know either, I'm learning :)
13:00:51 <tgeeky_> roconnor: in english, read this statement to me:
13:01:03 <tgeeky_> m1 >>= \ x1 -> return (f x1)
13:01:09 <tgeeky_> please sir
13:01:23 <acowley> tgeeky_:  Monads distinguish themselves at the type level with join.
13:02:06 <Kaidelong> run m1, feed its result into a function where we call it x1, the result of that function is a computation that returns f of x1
13:02:51 <tgeeky_> so everything to the right of \, in there, is in the domain of pure code?
13:03:05 <roconnor> tgeeky_: bind m1 to the function taking x1 and applying it to f and returning the result.
13:03:10 <roconnor> I don't know
13:03:13 <Kaidelong> well yeah, but the stuff on the left isn't?
13:03:18 <roconnor> translating matht to english is hard
13:03:23 <tgeeky_> roconnor: yeah
13:03:30 <tgeeky_> i wish they didn't use the word "return" for starters
13:03:40 <roconnor> tgeeky_: BTW, I want to point out that \ x1 -> return (f x1) is equal to return . f
13:03:41 <tgeeky_> i wa trying to write it using words like "inject" and "recover"
13:03:52 <Kaidelong> better than "eta"
13:04:02 <parcs> i think "return" is rather fitting
13:04:07 <Kaidelong> actually return is sensible, yeah
13:04:10 <tgeeky_> parcs: I thought that the other day
13:04:14 <klugez> If I have a pair of lists (as,bs) and I want to apply f to both lists giving (f as, f bs), what's a concise way of doing that?
13:04:14 <tgeeky_> as long as you think of return happening first
13:04:19 <tgeeky_> and not last, like many other languages
13:04:22 <Kaidelong> it gets you into the right kind of thinking about how monads work in practice
13:04:40 <tgeeky_> like
13:04:49 <tgeeky_> :t (return (+1))
13:04:50 <lambdabot> forall a (m :: * -> *). (Num a, Monad m) => m (a -> a)
13:04:53 <tgeeky_> :t (return . (+1))
13:04:55 <lambdabot> forall (m :: * -> *) a. (Monad m, Num a) => a -> m a
13:06:21 <tgeeky_> that's a "wound up" computation sitting inside a cell, ready to do its dirty work as soon as you give it an a
13:06:27 <acowley> I think writing it with fmap makes it much more readable. Reading aloud is a good example of the awkwardness of naming temporaries
13:06:55 <tgeeky_> acowley: I'll try going through typeclassopedia and writing the several definitions
13:07:32 <tgeeky_> i have a habit of writing things in an editor, and aligning (horizontally) the type definitions with extra whitespace to try and see what's going on
13:07:42 <acowley> I'm sure I have a deep mental rut, but I'm pretty sure everything is composition and mapping.
13:07:51 <tgeeky_> bind    :: (a -> W b) -> (W a -> W b)
13:07:51 <tgeeky_> fmapW   :: (a ->   b) -> (W a -> W b)
13:07:53 <tgeeky_> like that
13:08:37 <tgeeky_> or like this, with all three:
13:08:38 <tgeeky_> bind    :: (a -> W b) -> (W   a -> W   b)
13:08:38 <tgeeky_> fmapW   :: (a ->   b) -> (W   a -> W   b)
13:08:38 <tgeeky_> fmap    :: (a ->   b) -> (  f a ->   f b)
13:09:12 <tgeeky_> not sure it helps me (or anyone else) but I feel compelled to do it :/
13:09:32 <jonkri> i have a type "type Timeout = Integer", and when i try to do "t * 1000" (t :: Timeout) i get an "Expected type: Int" error. what can i do?
13:09:47 <ski> tgeeky_ : i do that often too
13:10:13 <tgeeky_> ski: I would say "I like to do wit especially with other people's (esp. undocumented) code
13:10:19 <tgeeky_> but that's pretty much all code I've seen so far :)
13:11:21 <acowley> jonkri: Either use Int for Timeout, or do toInteger on the second operand
13:11:48 <tgeeky> to whoever: so, if the identity monad is sitting at the bottom of complexity
13:11:53 <tgeeky> then the continuation monad is at the very top?
13:11:58 <tgeeky> not complexity, but... uhh
13:12:19 <tgeeky> flexibility?
13:12:32 <jonkri> acowley, it expects t to be of time Int... somehow it does not "get" that it's an Integer. perhaps it's because Timeout defined in another module?
13:12:53 <tgeeky> excluding IO, is it possible to make a monad which is not expressible as a continuation monad?
13:13:03 <acowley> jonkri: From what you typed, I understand the problem to be that 1000 :: Int
13:13:19 <acowley> jonkri: so you are trying to multiply an Integer and an Int
13:13:21 <tgeeky> jonkri: Int is not the same as Integer
13:13:48 <tgeeky> jonkri: Int is closer to the machine (-2^31 .. 2^31) than Integer (-inf, +inf)
13:14:01 <jonkri> oh i know that :) not even "(toInteger t) * (toInteger 1000)" works... the problem is that t can not become an int or an integer, i think :)
13:14:18 <jonkri> well
13:14:25 <acowley> t * toInteger 1000
13:15:02 <stulli> ezyang: Sorry for the long wait, i somewhat messed around with darcs: http://darcsden.com/stulli/couchnews
13:15:10 <acowley> t already is an Integer, but you're right that it won't implicitly become an Int
13:15:25 <ezyang> is http://darcsden.com/stulli/couchnews a valid darcs get address?
13:15:33 <jonkri> oh, you're right :)
13:15:43 <jonkri> i changed Timeout to Int and it started working
13:15:52 <jonkri> i should go to sleep, it's all a blur :) good night
13:15:52 <stulli> ezyang: Yes, should be
13:16:24 <tgeeky> roconnor: so the M1 (or M2, or whatever) refers to the number of things that are in the anonymous function?
13:16:42 <stulli> ezyang: I put some notes to reproduce the error here: http://darcsden.com/stulli/couchnews/patch/20110610202703-e8089
13:16:51 <tgeeky> > liftM2 (++) [1,2,3,4] [5,6,7,8]
13:16:52 <lambdabot>   Ambiguous type variable `a1' in the constraints:
13:16:52 <lambdabot>    `GHC.Num.Num a1'
13:16:52 <lambdabot>      a...
13:17:08 <tgeeky> > liftM2 (\x y -> x ++ y) [1,2,3,4] [5,6,7,8]
13:17:08 <ezyang> oh, can you minimize it any further?
13:17:09 <lambdabot>   Ambiguous type variable `a2' in the constraints:
13:17:09 <lambdabot>    `GHC.Num.Num a2'
13:17:09 <lambdabot>      a...
13:17:35 <ezyang> that amount of interaction will probably make it hairy to track down the bug...
13:17:46 <roconnor> > liftM2 (+) [1,2,3,4] [5,6,7,8]
13:17:47 <lambdabot>   [6,7,8,9,7,8,9,10,8,9,10,11,9,10,11,12]
13:17:55 <stulli> ezyang: Ok, i'll try to minimize it a bit more
13:25:27 <ezyang> I'm thinking of writing a simple app that converts HNSearch API results into RSS feeds, and was wondering what Haskell webapp framework I should dig into first :-)
13:25:28 <Jeanne-Kamikaze> why would the profiler output a graph showing usage for 0.3 seconds when I've run the program for a much longer time ?
13:25:42 <Elliot_Stern> I's trying to generate some documentation for a library via haddock, but it says "No input file(s).".  How do I get it to recognize that the file is there?  I've run 'cabal configure' and it works fine, and 'cabal sdist' can package everything up, but haddock doesn't seem to see the code.
13:26:26 <chrisdone> Elliot_Stern: Using cabal haddock?
13:27:31 <Elliot_Stern> I've tried both that and 'runhaskell Setup haddock', yes.  Neither work
13:27:50 <chrisdone> Hm. Is it a library or an executable?
13:27:54 <chrisdone> Oh, library.
13:28:13 <c_wraith> odd.  cabal haddock has always worked for me
13:28:33 <ezyang> Jeanne-Kamikaze: The profiler can't instrument C code, so if you spent all that time there, it might not show up.
13:28:36 <chrisdone> Me too. Hard to tell what's up without more info.
13:28:42 <ezyang> If you have more details, we might be able to help more.
13:28:56 <Jeanne-Kamikaze> what if I didn't spend the time there ?
13:29:30 <ezyang> Well, it could be something else, or maybe your instrumentation is wrong, or GHC has ab ug.
13:29:34 <ezyang> We need more details.
13:29:42 <Elliot_Stern> It's a windows xp machine, if that makes any difference
13:29:52 <Elliot_Stern> instrumentation?
13:30:02 <ezyang> Hmm, I personally get a little annoyed when libraries show up more than once on the Hackage package list.
13:30:03 <chrisdone> The Windows Factor usually makes a difference, yeah.
13:30:17 * roconnor cynically thinks that Enumerator will end up in the haskell platform
13:30:17 <chrisdone> ezyang: Yeah. It's confusing.
13:31:16 <Elliot_Stern> What details in particular do you think would be relevant?
13:33:24 <chrisdone> Elliot_Stern: What directory are you doing it from, what's in your path, whether hscolour is in the path, what the .cabal contains, etc.
13:34:25 <Elliot_Stern> it appears that HsColour is in my path.
13:34:57 <chrisdone> Sorry, I meant whether haddock is in the path. (I was just working with hscolour.)
13:35:22 <Elliot_Stern> haddock's in my path too :p
13:35:35 <chrisdone> Can you paste your .cabal and the output of cabal haddock -v?
13:35:36 <chrisdone> @paste
13:35:37 <lambdabot> Haskell pastebin: http://hpaste.org/
13:35:37 <Elliot_Stern> Let me paste the relevant portions of my .cabal file
13:35:41 <chrisdone> :-)
13:36:27 <chrisdone> (Hahaha. I love hlint. Look at the first error here: http://hpaste.org/47635 … Found <one line>, why not <a mountain>?)
13:37:34 <olsner> heh, -fglasgow-exts is of course discouraged and can be replaced by <a mountain>
13:37:41 <chrisdone> :P
13:37:43 <Elliot_Stern> I just realized that I had the synopsis line twice in the .cabal file
13:38:26 <ezyang> stulli: It looks like, for whatever reason, I don't seem to be able to install the deps of your package.
13:39:24 <Elliot_Stern> http://hpaste.org/47663
13:39:43 <stulli> ezyang: That's strange. It should be as easy as cabal makes it
13:39:55 <ezyang> I might just be missing dynamic libraries for something.
13:40:17 <stulli> (still rewriting the example)
13:41:40 <chrisdone> Elliot_Stern: I don't suppose the missing colon next to Exposed-Modules matters. And the output of cabal haddock -v?
13:42:28 <Elliot_Stern> it's version 1.10.something
13:43:09 <Elliot_Stern> cabal-install version 0.10.2
13:43:10 <Elliot_Stern> using version 1.10.1.0 of the Cabal library
13:43:22 <chrisdone> No I mean -v is verbose output.
13:43:37 <Saizan> cabal doesn't throw parse error to exposed-modules without a : ?
13:45:04 <Elliot_Stern> It would appear to have been that missing ':' in the .cabal file
13:45:08 <Elliot_Stern> thanks
13:46:07 <chrisdone> d(*⌒▽⌒*)b
13:59:21 <int80_h> mlitchard@apotheosis:~/repository/svn/perf/autoperf/Aframe$ cabal build
13:59:22 <int80_h> Preprocessing executables for Aframe-0.0.0...
13:59:22 <int80_h> Building Aframe-0.0.0...
13:59:22 <int80_h> <command line>: cannot satisfy -package-id yesod-0.8.1-d866530b1b18a7c21968017e1660cddf:
13:59:25 <int80_h>     yesod-0.8.1-d866530b1b18a7c21968017e1660cddf is unusable due to missing or recursive dependencies:
13:59:28 <int80_h>       yesod-auth-0.4.0.2-715aa6734dcbafa48f145fd1cf399f1c yesod-form-0.1.0.1-42594df25beef695cea29dfef2ce2fab
13:59:31 <int80_h>     (use -v for more information)
13:59:34 <int80_h> ugh sorry
13:59:36 <int80_h> http://hpaste.org/47668
13:59:36 <int80_h> that's what I meant to paste
14:00:49 <Saizan> int80_h: which library did you change?
14:00:57 <int80_h> yesod.form
14:01:22 <byorgey> int80_h: then you will need to recompile any libraries which depend on it, such as (apparently) yesod-auth and yesod
14:01:33 <int80_h> okay
14:01:36 <byorgey> just 'cabal install yesod-auth yesod'
14:01:47 <parcs> int80_h: you might as well install the latest version of yesod -- 0.8.2.1
14:02:12 <Saizan> btw, it's best to bump the version when you modify something
14:02:21 <int80_h> parcs: how do I guarantee I get the latest?
14:02:40 <int80_h> Saizan, well this is not an official change yet. I must test it.
14:03:04 <int80_h> Saizan: then, I', sure that even if it's working, it might not be working in accordance to right style.
14:03:27 <parcs> int80_h: you'll almost always get the latest by updating the package index and directly installing the particular package, i.e cabal update && cabal install yesod
14:04:01 <stulli> ezyang: Here is the minimal example. Either the debugging is wrong or there is a fundamental flaw in vty or vty-ui. http://darcsden.com/stulli/couchnews
14:04:12 <parcs> you can specify a particular package version that you want installed like so: cabal install yesod-0.8.2.1
14:04:33 <ezyang> ooh, excellent!
14:04:47 <stulli> I compiled with 'ghc --make -dcore-lint -debug couchnews.hs' and after starting the program just move down the list 2 times with the arrow keys
14:05:14 <ezyang> You should submit this code sample to the vty developers.
14:05:32 <stulli> Will do
14:11:03 <tommd> ezyang: You weren't successful getting HaLVM 64bit running, right?
14:11:15 <int80_h> http://hpaste.org/47669
14:11:24 <djahandarie> I was thinking about playing with HaLVM actually
14:11:55 <tommd> It should be particularly fun with HaNS released.
14:12:00 <djahandarie> Yeah, that's why
14:12:06 <int80_h> http://hpaste.org/47669
14:14:41 <tommd> Wow, quiet.
14:16:28 <parcs> int80_h: looks like a problem with the depedency list of yesod-core-0.8.2 (which is probably why there's a 0.8.2.1)
14:17:10 <parcs> anyway, yesod already depends on yesod-auth, just not the latest version of it
14:22:54 <int80_h> parcs: yeah I'm tip-toeing my way around these dependencies. I really like cab for problems like this
14:23:48 <parcs> cab the file format?
14:24:23 <int80_h> parcs: http://www.mew.org/~kazu/proj/cab/en/
14:29:49 <roconnor> my Enumerator version of SHA256 seems to be correct
14:30:00 <maurer_> Anyone know of any voodoo I can do to have cabal rebuild everything I currently installed from scratch, ignoring what exists?
14:30:06 <maurer_> I want something like gentoo's emerge -e
14:30:11 <maurer_> (in dependency hell, and want out)
14:31:40 <parcs> cabal install --reinstall world
14:32:01 <maurer_> parcs: Will that realize that it needs to pretend nothing else is installed while it does it?
14:32:07 <maurer_> Otherwise it won't escape the dependency nonsense
14:32:30 <parcs> it will install from the bottom-up i think
14:32:38 <parcs> so yeah
14:32:40 <parcs> maybe
14:32:57 <parcs> but that's a bad way to fix dependency problems..
14:33:41 <Saizan> you can always rm -fr ~/.ghc
14:33:45 <Saizan> @where sicp
14:33:46 <lambdabot> The Wizard book : "Structure and Interpretation of Computer Programs" at <http://mitpress.mit.edu/sicp/> by Hal Abelson,Gerald Jay Sussman with Julie Sussman, videos at <http://swiss.csail.mit.edu/
14:33:46 <lambdabot> classes/6.001/abelson-sussman-lectures/>
14:33:51 <Saizan> not that.
14:34:04 <Saizan> http://www.vex.net/~trebla/haskell/sicp.xhtml
14:34:19 <maurer_> Saizan: Yeah, I may end up doing that.
14:34:35 <maurer_> e.g. list all cabal packages installed, purge .ghc, then rerun the install
14:34:57 <Saizan> "world" would survive
14:35:12 <Saizan> iiuc
14:37:00 <maurer_> Dammit, version of cabal too old, it hadn't been putting my packages in "world"
14:39:25 <bos> @pl \(a,b) -> (b,a)
14:39:25 <lambdabot> uncurry (flip (,))
14:40:59 <hpc> :t (><)
14:41:01 <lambdabot> forall a. (Gen a -> Gen a) -> (Gen a -> Gen a) -> Gen a -> Gen a
14:41:05 <parcs> :t swap
14:41:05 <lambdabot> Not in scope: `swap'
14:41:09 <parcs> :t Data.Tuple.swap
14:41:10 <lambdabot> Not in scope: `Data.Tuple.swap'
14:41:12 <hpc> hmm
14:43:29 <acowley> swap is a Haskell situp, like bool, and aliasing mappend
14:44:53 <Saizan> i thought marlow addes a swap at some point
14:45:05 <maurer_> cabal install --reinstall `ghc-pkg --user list  --simple-output --names-only`
14:45:18 <maurer_> Appears to be the magic incantation, in case anybody comes across this problem with an old cabal like me.
14:45:41 <Saizan> @hoogle swap
14:45:41 <lambdabot> Control.Concurrent.MVar swapMVar :: MVar a -> a -> IO a
14:45:41 <lambdabot> Control.Concurrent.STM.TMVar swapTMVar :: TMVar a -> a -> STM a
14:46:04 <parcs> heh, strangely 'let x = x in x' doesn't peg the cpu..
14:47:33 <Saizan> does it throw a <<loop>> exception?
14:48:45 <c_wraith> it does neither with the threaded runtime
14:49:12 <c_wraith> that's one of the things I miss in the threaded runtime - <<loop>>
14:49:29 <ezyang> Huh, I thought the threaded runtime does blackholing.
14:50:13 <roconnor> are there no functions to convert between bytestrings and lazy bytestrings?
14:50:17 <c_wraith> it does, but it can't detect that the same thread waiting on the blackhole is the one that created it
14:50:24 <acowley> roconnor: toChunks and fromChunks
14:50:35 <c_wraith> so it just blocks, waiting for the blackhole to be replaced
14:51:10 <acowley> ezyang: can you offer me any suggestions to make the ticket I opened on GHC's trac the other day more useful?
14:51:49 <ezyang> Is this 5250?
14:52:35 <ezyang> Mmm, I'd be put off investigating because it's so big.
14:52:35 <acowley> ezyang: yes
14:52:49 <acowley> ezyang: yeah, that's my concern
14:53:00 <zygoloid> huh, we /still/ don't have (<>) = mappend in base ;(
14:53:03 <ezyang> Although, it looks like you've minimized quite well.
14:53:11 <roconnor> ... BSL.fromChucks . (:[]) . toByteString ...
14:53:20 <roconnor> go monkey!
14:53:29 <acowley> ezyang: the test code is really small, though so I hoped its very simplicity would be compelling and perhaps enlightening to the right set of eyes
14:53:35 <ezyang> Are you sure it's not an OpenCV bug?
14:54:00 <acowley> ezyang: not at all, except for the weird behavior of not segfaulting from C, C++, or Python
14:54:38 <ezyang> What if you initialize the GHC runtime from your C program?
14:54:57 <acowley> ezyang: so if it is an OpenCV bug, it's not being triggered by the usual execution paths. I suppose part of my hope is that a GHC dev could suggest what kind of bug the RTS might be likely to expose
14:55:15 <acowley> ezyang: I can give that a shot
14:55:18 <ezyang> I mean, there's literally almost nothing in the Haskell stub file.
14:55:32 <ezyang> So it may just be loading up the RTS is causing memory corruption to become apparent.
14:55:37 <ezyang> Or OpenCV doesn't like the signal handler
14:55:38 <ezyang> etc etc.
14:55:54 <roconnor> boo, my enumerator version is way slower
14:56:25 <ezyang> Have you valgrind'ed the pure C version?
14:56:53 <roconnor> I guess I shouldn't be too surprised; it doesn't use continuations
14:57:43 <ezyang> Other things to try: check out the main wrapper function here:
14:57:50 <acowley> ezyang: I haven't, no. I'm aware of, but not familiar with, valgrind.
14:58:06 <ezyang> It'll catch some types of memory errors. It's worth a shot.
14:58:53 <acowley> ezyang: calling hs_init and hs_exit from CTest2.c and building with GHC does not exhibit the segfault
15:00:36 <ezyang> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-TopHandler.html
15:01:15 <ezyang> You've also failed to specify how to compile the program so as to cause the problem.
15:01:49 <acowley> oops, ghc MyWrap.c Test2.hs -lopencv_core -lopencv_imgproc
15:02:10 <ezyang> post that to the ticket ;-)
15:02:32 <acowley> Iheh, I'm doing so
15:03:05 <ezyang> Anyway, it seems there's a very low chance this is a bug in GHC, just some behavior in GHC that tickles an OpenCV bug.
15:03:22 <ezyang> So the next thing I'd try is looking at handlers and rts.
15:05:07 <acowley> Can you be more specific?
15:05:39 <ezyang> ^ link above. I'm not sure, but I think you may be able to convince GHC not to use the default top handler.
15:05:52 <roconnor> ah fixed it
15:05:57 <roconnor> now it *is* faster
15:07:15 <roconnor> horray
15:08:17 <acowley> roconnor: how much faster?
15:08:40 <roconnor> 6 secs vs 7 seconds
15:08:55 <roconnor> compared to my crappy list processing code
15:09:08 <roconnor> to be fair I should write a bytestring version.
15:09:47 <roconnor> I need a better test case now.
15:09:57 <roconnor> it seemed so reasonable when it was taking 1m15 seconds
15:10:04 <roconnor> but now it is getting too fast
15:13:34 <acowley> what's a command line to compile a .hsc file? I only do it from cabal :/
15:13:48 <ezyang> hsc2hs
15:13:56 <ezyang> then compile the resulting hs file.
15:14:15 <Saizan> at some verbosity level cabal should show you the exact command line, btw
15:14:38 <acowley> err, I guess this isn't an hsc file?
15:18:25 <acowley> ezyang: any tips for compiling this guy? Just running ghc trips on the #include, but hsc2hs trips on the hash suffixes on primitive types
15:18:45 <ezyang> Wait wait, no, you don't want to compile that file.
15:28:11 <acowley> ezyang: okay
15:28:35 <acowley> ezyang: valgrind shows no leaks or any warnings in the C executable
15:29:45 <ezyang> What flags did you run with?
15:30:37 <acowley> nothing exotic. I tried --leak-check=full and --malloc-fill with a couple different values
15:31:40 <ezyang> ok, so much for that theory :-)
15:34:36 <acowley> ezyang: the verbose output is verbose, but nothing is jumping out at me. There are a bunch of REDIR messages which are somewhat interesting as they involve memory operations like new, free, memset, copy, etc.
15:35:02 <ezyang> You said it segfaults, right? What error message?
15:35:17 <acowley> "Segmentation fault"
15:35:23 <ezyang> erm, can you get a trace from gdb?
15:35:50 <acowley> yes, in GDB it's "Program received signal SIGSEGV, Segmentation fault."
15:36:06 <ezyang> What does bt say, then?
15:36:33 <acowley> well that part all looks legit as I hinted at in the ticket
15:37:04 <acowley> we go from ?? to rYf_info to myDilate to cvDilate into the opencv_imgproc library
15:37:52 <ezyang> Right, so can you inspect the local variables and see what's different between the normal C execution and the segfaulting one?
15:39:02 <zmv> http://haskell.org/haskellwiki/Humor/Porn <- trolololol
15:40:05 <acowley> I haven't figured out how to do that actually. With the Release build of the library there's no symbol table, so I need to load the symbol table from a debug build of the library and haven't worked out how to do so
15:55:57 <acowley> The frowny face when fetching an old-fashioned darcs repo is funny, but not confidence inspiring
15:56:50 <aavogt> they have been warning about it for so long now
15:57:40 <acowley> as an ignorant user, it makes it seem like the package is unmaintained
15:58:02 <aavogt> @hoogle Type -> Name -> Maybe Int
15:58:03 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
15:58:03 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
15:58:03 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
16:01:06 <roconnor> does cabal build -O2 by default?
16:01:23 <parcs> -O1
16:07:48 <roconnor> >>=_a9PL                       Data.Serialize.Get    20.1    2.4
16:07:56 <roconnor> wow, 20% of time in bind
16:09:04 <roconnor> I'm not sure I can optimize \s0 m0 f k -> m s0 m0 f (\s m1 a -> (g a) s m1 f k))
16:09:24 <sipa> @pl \s0 m0 f k -> m s0 m0 f (\s m1 a -> (g a) s m1 f k))
16:09:24 <lambdabot> (line 1, column 52):
16:09:24 <lambdabot> unexpected ")"
16:09:24 <lambdabot> expecting variable, "(", operator or end of input
16:09:52 <roconnor> @pl \s0 m0 f k -> m s0 m0 f (\s m1 a -> (g a) s m1 f k)
16:09:52 <lambdabot> flip flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip . flip g)) . (liftM2 (.) .) . m
16:10:51 <magicman> :t liftM2 (.)
16:10:52 <lambdabot> forall a b (f :: * -> *) (m :: * -> *). (Functor f, Monad m) => m (a -> b) -> m (f a) -> m (f b)
16:11:11 <magicman> :t liftM2 (\f g x -> f (g x))
16:11:11 <lambdabot> forall t t1 t2 (m :: * -> *). (Monad m) => m (t1 -> t2) -> m (t -> t1) -> m (t -> t2)
16:14:05 * roconnor doesn't really trust the profiler
16:17:29 <acowley> my attempts at grafting symbol tables seems to be confused
18:18:57 --- topic: '["Paste code/errors: http://hpaste.org", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin and spam issues: #haskell-ops"]'
18:18:57 --- topic: set by monochrom!monokrom@toronto-hs-216-138-220-146.s-ip.magma.ca on [Sat Mar 26 17:29:18 2011]
18:18:57 --- names: list (clog pedro3005 HaudRex LittleQNCCU zodiak Tezeract c_wraith Admas iratsu BlankVerse wyfrn fengshaun soiamso Axman6 ousado dolio zzing neophytos pikhq applicative cubi owst jvia joeytwiddle Draconx|Laptop [[zz]] neilk_ comak ulfdoz GOP-USA_dotcom longh flippo Gunni knkumar andrewsw hereforfun theorbtwo schroedinbug realitygrill ormaaj no_nada gienah replore cobb dankna ISF JaffaCake luigy rntz jrib ymasory vili joyfulgirl japcu gbacon_ malkomalko cmccann Fuco)
18:18:57 --- names: list (bombshelter13b Volt_ zmv DasIch Casperin thom_logn ccc ChongLi_ chessguy hammi wisemanby Veid owain sonnym araujo Niedar PreciousMetals tweve-VB05 Gracenotes jd10 cheater8 _mpu Philonous sm lokydor_ Nordvind lystergic sanjoyd pyrony Lajla dom1 Mathnerd314 stepkut`` tsuraan_ kelvie_ danharaj kx amiri brachiel eugu frerich rostayob NisseP gniourf_gniourf lispy Zephyrus carlocci jrk_ trin_cz tensorpudding monqy itegebo roconnor hamishmack_ Skola_ Jantaro)
18:18:57 --- names: list (geheimdienst Martty acowley jedai_ sipa xcthulhu tauntaun steve_himself rvn_ xinming pi8027 suls psychicist_ shapr copumpkin raxas FusionX gusto anderson lu mbernstein mjonsson Dahak Spockz_ H2S04 bgs100 PhilRod moshee isomorphic ClaudiusMaximus dons wjt cwb Modius alip mlh dk2bee Zeiris qlife aculich brandwe rby gio123 kaf3ii insomniaSalt mjrosenb erikde CindyLinz hackagebot dMazz trez sepp2k Innominate b930913 scm setmeaway minsa robinbb siracusa tredontho)
18:18:57 --- names: list (otto_s_ Philippa kaito_ shachaf augur fihi09 AtnNn neurocyte sidke alexsuraci novas0x2a|laptop n0tk marchdown [mth] subpy almostsix Draconx tgeeky palmje MK_FG Eduard_Munteanu anders^^ stepnem tlockney edenc lokydor tjgillies cwillu_at_work kalivha osfameron Cronecker skrblr sgronblo Skola _flow_ fhs periodic Snufsen andersk byorgey rncarpio anonus digitteknohippie tavelram Nshag Muad_Dibber_ faj mornfall neurogeek||m dreixel uu1101 preflex macUzer drdo)
18:18:57 --- names: list (wtetzner DustyDingo joshc mm_freak_ idnar Gilly kirilk waqf jonke_ `0660 quicksilver henr_k Igloo idoru da-x yell0 ddarius lsthemes parcs ville smop callen BMeph qz milli xale MoALTz perlite AnAdorableNick StoneToad tildedave ian_mi Raku^ bqf sm__ mauke mrdomino QtPlatypus olsner iFire` Cthulhon kamaji caligula_ jystic mrd SimonRC sohum digicyc noam eyck empity twofish FDFlock teratorn o-_-o migimunz Jaak albel727 Vq TacticalGrace Favonia Amadiro hzh_ piksi)
18:18:57 --- names: list (Botje TML geekounet pingveno gdsx davesq jrockway Vulpyne solarus wto tomaw liesen dqd finnomenon pantski tumdum blomqvist lpsmith whoops Astro Tasser miloshadzic cinch Azverkan Boney Bassetts hiredman earthy dmansen em profmakx Lemmih a11235 nimred zaphar_ps timchen1` Ferdirand finnrobi robbert dcolish nornagon appamatto johs burp legov electrogeek nihtml gf3 lambdabot dsouza thetallguy1 lukish obcode RSchulzM helgikrs The_third_man houeland smly- jlewis)
18:18:57 --- names: list (ahihi2 bs338 tafryn c1de0x benmachine rothwell n00p nighty^ pranq nlogax ectospasm janne __main__ ozzloy mikeg lunaris brisbin daed jlouis dmwit srcerer kpal cyanoacry mafs xplat liyang nyingen OnionKnight pettter ricky SonicvanaJr cjay LeNsTR|off jrick avocado osoleve TheMoonMaster milkpost damjan gentz naneau cheshire-cat comex dino- SpiceMan kolmodin gbacon aavogt opqdonut jan247 mattam djahandarie kniu cynick ivan Counter-Strike Intensity bremner`)
18:18:57 --- names: list (jesusabdullah waterlaz sjanssen jix Eliel malorie ski DrSyzygy neaer dcoutts Runar tessier thetallguy kosmikus dfeuer jssanders alfa_y_omega Cale levitation[A] mike1703 Zol willb hydo akosch geekosaur freiksenet Dashkal cpa tomh_ scree integral anssik ion __class__ monokrome rattboi erg brett tridactyla wagle mutewit thorkilnaur drbean zaero chitragupt Octal jonafan jmcarthur Nanar robinhoode forrestv quaestor Aestas jml kolmodin_ Twey llahna novas0x2a)
18:18:57 --- names: list (monochrom sirpengi mokus cncl solidsnack reacocard BrianHV Utkarsh [mth]_ thoughtpolice Obfuscate frerich2 aninhumer erk exobit ps-auxw pastorn guerrilla norm2782 tew88 hiato Bleadof deavidsedice alexsdutton Cerise ehamberg helino flamingspinach hc elliottt petanqk kakos liw eno snorble burp` Katibe flux dumael stepcut shepheb shutdown_-h_now inr yottis Totramon Ke ray jlaire mun_ PHO_ cizra2 kalven Arnar_ aleator_ takamoro1 Boxo xinitrc_ seats MacCoaster_)
18:18:57 --- names: list (koninkje_away CosmicRay hgolden bezik Nightwolf yahooooo untwisted dogmaT dRbiG aristid ixzkn Ornedan Jonno_FTW agemo_ Starfire_ drogoh mietek alpounet jbauman majoh Bwild karld Eelis maurer_ Laney impl mfoemmel yrlnry davean ziman drhodes lifthrasiir blackdog Maxdamantus edwtjo sbok magicman freeformz arkx sajkr And[y] ttblrs_ Yahovah hvr nominolo zomg orbitz jyyou marienz bradwright arnihermann incandenza companion_cube saati lomeo thirsteh savy mortberg)
18:18:57 --- names: list (Entroacceptor ninegrid klugez robinsmidsrod twn lantti tomjnixon Liskni_si davidL eZet identity_ ts00000 Pathin traviscline spetrea saurik tromp Draggor ezyang tomku ido ibt matthew-_ mercury^ regulate zygoloid Veinor pr_ oc_ Derander_ snarkyboojum brixen absence Raynes dixie wires dncr Sunhay_ mux silex zenzike towynlin ortmage ybit flazz welterde tamiko dilinger Nereid hyko bl4ck arcatan mimi_vx ben sordina MasseR poucet ttvd felher EvanCarroll McManiaC)
18:18:57 --- names: list (Will| jayne dropdrive mrshoe hoopy_ pesco sunnavy luite bd_ snr absentia plimsoll chr1s saiam tswett gereedy peddie gds dionoea Saizan sully stroan aiko tommd noddy Mitar vinc rakete ahf micahjohnston wolverian hhulkko ccasin int-e skaar zorzar szbalint confound joni6128 hpc dom96 taruti noj rwbarton ibid kaol dorkitude emias felipe_ _soro_ kloeri ve Aisling hellige carrbs scsibug_ jcapper_ KitB _erik_ @ChanServ ihckt_ inimino zakwilson koala_man copton flori)
18:18:57 --- names: list (duairc Belgarion_ suiside ernst fabjan politik)
18:22:19 <acowley> doesn't gloss require that you have a decoded image already?
18:26:04 <Eelis> i'm not interested in loading pictures. Codec-Image-DevIL was just a dependency of another package i was considering, namely chalkboard
18:26:35 <acowley> Oh! Well, I'm glad you found Gloss, I really like it.
18:26:45 <Eelis> good, i look forward to playing with it :)
18:28:23 <tommd> Gloss is decent, but has its own issues.
18:31:16 <acowley> One problem I had with it is that the Event model of the animation runners is too closed off. I think I wanted to have networking events, but couldn't see how. Then if you want to add fancier rendering things, you may also be stuck with fairly opaque values that are tricky (or impossible) to extend.
18:35:59 <tommd> Eelis: FYI, the missing function appears to be from libpng - you probably don't have dev libraries installed for libpng.
18:36:15 <tommd> Or perhaps a version mismatch.
18:53:26 <stribor> guys i just installed ghc6 compiler for haskell......but i was wondering how can i get interpreter to run from command line
18:53:31 <stribor> on ubuntu
18:53:42 <tswett> stribor: well, the interpreter is called ghci.
18:53:58 <cmccann> is ghci not working?
18:54:09 <cmccann> or did you just not know what it was called?
18:54:17 <cmccann> come to think of it I'm not even sure where that's mentioned
18:54:23 <tswett> runhaskell might also be the command you're looking for, though I think it's more for scripting.
18:54:25 <stribor> so how would i then run 2+2 from command line...i am confused
18:54:31 <cmccann> other than the ghc user guide obviously
18:55:30 <rostayob> @pl \u -> u `M.member` state || u `M.member` sureState
18:55:30 <lambdabot> (line 1, column 9):
18:55:30 <lambdabot> unexpected "`"
18:55:30 <lambdabot> expecting variable, "(", operator or end of input
18:55:40 <cmccann> stribor, if you want the interactive interpreter just run "ghci"
18:55:45 <tswett> stribor: open up a command line and type in ghci and hit enter.  That should bring up GHCi, where you can enter Haskell expressions.
18:55:58 <stribor> tswett: cool...let me try it
18:56:00 <tswett> Anyway, I'm trying to install hscurses, but I'm getting this error: http://pastebin.com/u1rucKHk
18:56:02 <mauke> The paste u1rucKHk has been copied to http://hpaste.org/new
18:56:12 <tswett> TL;DR: <command line>: cannot satisfy -package-id mtl-2.0.1.0-9763a8821c812a910d327bad2c0d23b2
18:56:35 <stribor> tswett: <interactive>:1:0: Not in scope: `ghci'
18:56:47 <tswett> stribor: oh.  You're already running GHCi, then; go ahead and type in 2+2.
18:57:03 <tswett> And it should give you 4.
18:58:11 <stribor> tswett: thank you....the other thing is if i compile .hs file which containt some function lets call it mydunction
18:58:25 <stribor> how would i run that function from ghci
18:58:54 <tswett> stribor: well, what's the type of the function?  If it doesn't take any arguments, simply type the name of the function.
18:58:56 <cmccann> stribor, you can use :l SomeFile.hs to load a file from disk
18:59:16 <stribor> sweeet...thank you guys
18:59:18 <tswett> If it does take arguments, type the function and its arguments, separated by spaces.
18:59:30 <cmccann> stribor, you can also use :? to get a list of commands
18:59:38 <cmccann> most of which will probably just confuse you, haha
18:59:50 <stribor> cmccann: ..lol nice..haha
19:00:06 <cmccann> stribor, just ignore the stuff about debugging and setting options for now
19:00:07 <tswett> I've been doing Haskell casually for years, and I still have no idea what most of GHCi's commands do.  :P
19:00:21 <cmccann> tswett, I mostly know what they do
19:00:24 <cmccann> I just don't use most of them
19:00:26 <cmccann> heh
19:00:54 <cmccann> stribor, anyway, the first set of commands it shows are the ones you'll probably want to know about
19:01:10 <stribor> when do you compile code and when do you just run it from interpreter..whats the difference
19:01:13 <cmccann> helpfully, at most terminal sizes these are also the ones that scroll off the screen
19:01:13 <accel> I know that ghci has commands
19:01:16 <accel> I don't know what they are.
19:01:24 <tswett> I use the :m command and the :r command.  :P
19:01:48 <cmccann> tswett, I also use :t, :i, and :browse a lot
19:01:50 <shachaf> accel: :help is a good one.
19:02:01 <cmccann> and :q sometimes
19:02:08 <shachaf> ^D
19:02:12 <tswett> Ooh, what does :browse do?
19:02:20 <accel> shachaf: my generall process so far is: chrome -> google.com -> type in hoogle -> search in hoogle
19:02:27 <cmccann> tswett, shows you what a module exports
19:02:40 <tswett> cmccann: shiny!
19:03:54 <cmccann> I believe you can also install arbitrary extra commands into ghci but I've never bothered to learn how
19:04:13 <cmccann> but that'd let you do things like use hoogle or whatever from the REPL prompt
19:04:30 <stribor> is there differenc ebetween comipling program or interpret it
19:04:40 <accel> this is really one weird
19:04:48 <accel> one password ocntrols both the ordering of cereal & my git repo backups
19:04:52 <accel> amazon is screwing up my brain
19:04:52 <cmccann> stribor, yes, but the details don't matter that much
19:05:23 <stribor> but the output is same right?
19:05:32 <cmccann> stribor, everything is "compiled" in some sense, it's just a matter of how and what (if anything) is written to disk
19:05:53 <aavogt> more things from Module are in scope at the *Module> prompt than at the   Module>
19:06:21 <cmccann> stribor, but basically "compiling" usually means you're doing something like "ghc --make SomeFile.hs" to create a standalone executable
19:06:40 <stribor> yeah something like in c
19:06:41 <cmccann> whereas "interpreted" means you're loading it in GHCi without creating any compiled files on disk
19:07:04 <cmccann> but there's not really much of a difference when it comes to what GHC is doing internally
19:07:46 <cmccann> aavogt, that's true and it always annoys me because I forget about it :[
19:08:25 <stribor> why true&&true retuens not in scope??
19:08:41 <cmccann> stribor, because the Boolean value is called "True" :)
19:08:46 <stribor> oops
19:08:54 <stribor> :)
19:08:56 <parcs> > true&&true
19:08:57 <lambdabot>   True
19:09:22 <cmccann> > let true = False in true && true
19:09:23 <lambdabot>   False
19:09:43 <accel> ha
19:09:44 <stribor> how do you invoke intepret here in chat
19:09:48 <accel> is that as obscure as haskell gets?
19:09:54 <accel> nothing like C++'s #define while if
19:10:00 <cmccann> stribor, just prefix it with a >
19:10:07 <stribor> >2+2
19:10:19 <cmccann> hm, does it need a space after the > ?
19:10:31 <stribor> > 2+2
19:10:32 <lambdabot>   4
19:10:35 <cmccann> guess so
19:10:39 <stribor> i made it :)
19:11:09 <cmccann> stribor, lambdabot also knows some GHCi commands
19:11:21 <stribor> such as?
19:11:22 <cmccann> though I can never remember what all it does
19:11:40 <aavogt> http://hpaste.org/47671
19:12:34 <cmccann> stribor, mostly :t is all I use, heh
19:12:42 <cmccann> :t (4 +)
19:12:43 <lambdabot> forall t. (Num t) => t -> t
19:13:02 <cmccann> :t map not
19:13:02 <lambdabot> [Bool] -> [Bool]
19:13:06 <cmccann> etc. etc.
19:13:24 <aavogt> accel: people sometimes use the CPP on their haskell
19:13:34 <mjrosenb> :k is also useful
19:13:35 <lambdabot> Not in scope: type variable `is'
19:13:35 <lambdabot> Not in scope: type variable `also'
19:13:35 <lambdabot> Not in scope: type variable `useful'
19:13:38 <mjrosenb> err....
19:13:39 <cmccann> haha
19:14:18 <mjrosenb> i wonder if we could get lambdabot rate limited by that.
19:14:41 <cmccann> be nice to lambdabot :P
19:15:04 <stribor> can you get haskell sytax highlight for vi
19:15:22 <cmccann> stribor, probably but I don't use vi so I wouldn't know
19:15:33 <stribor> what do you use
19:15:34 <cmccann> accel, oh and no, Haskell can get much more obscure than that
19:15:44 <cmccann> stribor, SciTE mostly
19:15:53 <parcs> stribor: vi, no. vim, yes.
19:15:53 <isomorphic> stribor: It works for me
19:16:15 <stribor> parcs: did it came as default or did you have to enable it
19:17:09 <isomorphic> stribor: Set 'syntax on'
19:17:27 <stribor> oh yeah i know that....jusy wondering if there is anything more for that
19:17:41 <isomorphic> there wasn't for me
19:18:04 <stribor> ok
19:19:33 <stribor> how do you exit prelude
19:19:48 <stribor> :q
19:20:15 <isomorphic> ghci?
19:20:22 <isomorphic> Control-D ?
19:21:07 <stribor> yeah both worked..contrpl-d and :q
19:44:24 <isomorphic> http://www.quora.com/Erlang-Haskell-OCaml-screw-one-marry-one-kill-one-Which-and-why
19:51:52 <monochrom> haha
20:08:02 <dons> quora eh?
20:10:22 <cmccann> hooray I got my [haskell] badge
20:11:04 <cmccann> yay for spending too much time on SO
20:11:11 <dons> cmccann: hehe well done!
20:11:20 <dons> you're doing great
20:11:31 <cmccann> dons, thanks :D
20:11:38 <cmccann> not that I'll ever catch up to you :P
20:11:47 <dons> you joined the gold club :)
20:11:59 <dons> http://stackoverflow.com/badges/210/haskell?userid=157360
20:12:01 <dons> SO party !!
20:12:06 <cmccann> it kinda annoyed me that it took so long
20:12:11 <dons> its hard!
20:12:15 <cmccann> I've been over the upvote total for ages
20:12:22 <cmccann> waiting around to get the 200 answers needed
20:13:00 <isomorphic> wow - congratulations!
20:13:09 <dons> its a great contribution
20:13:09 <cmccann> I guess my answer quality was just too high for SO and I should have spammed more low quality answers :D
20:13:26 <dons> cmccann: yeah. haskell ones have a lot of viewers, relatively
20:14:01 <cmccann> the haskell tag actually gets a lot of upvotes, relatively speaking
20:14:15 <cmccann> I've spent some time messing with queries on SO's data site
20:14:41 <dons> i'm not surprised. often the top viewed posts on the site are haskell questions. its quite awesome
20:15:39 <cmccann> I think it also has a lot to do with people being more involved
20:15:53 <dons> yep
20:15:54 <cmccann> most other tags seem to have a lot more questions that just sit there and disappear
20:16:21 <cmccann> probably helps that our volume is low enough to be manageable but high enough to be interesting
20:16:23 <dons> i tend to answer questions during long compile times
20:16:25 <dons> fills in the time
20:16:49 <dons> yes, having good questions is important. the simple ones are a bit tedious
20:17:04 <cmccann> I usually just hit up SO when I need a break from whatever else, it's relaxing
20:17:22 <dons> yeah. a bit of zen
20:18:00 <cmccann> I've actually spent some time recently using my 10k privs around the site, instead of only looking at [haskell] and... holy crap, even the worst questions we get aren't that bad compared to some stuff
20:18:26 <dons> heh
20:19:27 <cmccann> wonder how long until sepp2k gets a gold badge too
20:20:11 <cmccann> he's got the rep and I see him around pretty consistently
20:20:25 <sepp2k> cmccann: 20 answers to go :-)
20:20:29 <tgeeky> if I see the upside-down t (bottom) in a paper, how do I type that in normally? :/
20:20:49 <cmccann> sepp2k, oh heh didn't know you were here
20:21:15 <tgeeky> from: http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf section 3.2, top right (no page numbers? tsk!)
20:21:25 <sepp2k> Mostly lurking
20:21:34 <tgeeky> normalize :: .... then normaize a :: M s a = ...
20:23:06 <tgeeky> is that even right?
20:23:26 <tgeeky> normalize a :: M s a = M (mod a (modulus (undefined :: s)))
20:25:17 <cmccann> speaking of SO, something that I noticed while writing an answer earlier
20:25:34 <cmccann> does anyone know of space partitioning-ish data structures on hackage?
20:25:51 <cmccann> I only found one package that seemed to be abandoned and incomplete
20:26:14 <dons> hmm. don't know of one
20:26:43 <cmccann> it kinda surprised me since I expect hackage to have at least a simple-but-working implementation of anything I can think of :P
20:26:46 <tgeeky> cmccann: species?
20:27:17 <cmccann> tgeeky, hm?
20:27:21 <tgeeky> ++ something to do the work
20:27:30 <tgeeky> cmccann: just a wild suggestion
20:27:47 <cmccann> tgeeky, I'm not seeing the connection :?
20:28:37 <tgeeky> if you're partitioning a fininite set, wouldn't species help you figure out how to do so?
20:28:47 <tgeeky> or do you mean some other partition or some other space (or both?)
20:28:53 <chefjhae> hello
20:29:01 <cmccann> tgeeky, I mean higher-dimensional search trees
20:29:02 <chefjhae> can i ask a question in here
20:29:06 <chefjhae> plsss
20:29:08 <tgeeky> chefjhae: you already did
20:29:32 <chefjhae> tgeeky
20:29:40 <cmccann> tgeeky, i.e., like binary search trees, except you split a multidimensional space along axes instead of splitting a linear (1-D) space at a point
20:29:54 <chefjhae> do you know how to unlock mytouch 4g
20:30:03 <tgeeky> chefjhae: no
20:30:26 <tgeeky> cmccann: oh, ok. I could tell you how to do that for spherical space ;) but it would probably be even less related than species
20:30:38 * tgeeky shrugs
20:32:20 <cmccann> tgeeky, yeah, the idea doesn't seem to be very well know for some reason
20:33:19 <tgeeky> cmccann: well, without going off on a tangent, the apollonian fractal (and the associated group) do that to spherical space - that is, split along tangents instead of points
20:33:26 <tgeeky> ooh, unintentional pun.
20:33:44 <tgeeky> i'm trying to figure out how to express the idea in haskell
20:34:20 <cmccann> tgeeky, here's what reminded me of the subject, for context: http://stackoverflow.com/questions/6308900
20:36:30 <cmccann> tgeeky, sounds interesting, I've wondered if it might be more useful in many cases to partition in other ways
20:36:47 <cmccann> though the simple axis-aligned partitions have the benefit of being very cheap to compute
20:37:28 <tgeeky> let me see
20:37:35 <tgeeky> if i can make this boltzmann test generator work :o
20:37:39 <isomorphic> cmccann: I have a hilbert space implementation if that's helpful - i don't really know what you're up to though.
20:37:52 <cmccann> isomorphic, eh, I'm not up to anything
20:38:05 <isomorphic> okay, np :P
20:38:17 <cmccann> mostly just surprised that hackage doesn't have implementations of some basic spatial search data structures
20:38:44 <tgeeky> cmccann: what is the structure that fits, do you think?
20:39:03 <cmccann> tgeeky, hm? not sure what you mean
20:39:24 <tgeeky> you listed several different kinds of tree configurations (like point quadtree, tries, etc)
20:41:31 <tgeeky> cmccann: nevermind, mu
20:41:36 <cmccann> tgeeky, for the SO question he probably just wants points, regions (i.e., using tries) is more helpful if you want quick lookup for geometric figures with area
20:41:48 <cmccann> say, collision detection in a video game
20:41:48 <fragamus> I want to understand what different effects are obtained by various monad stackings...  high level conversation, no heavy syntax, just concepts
20:42:27 <fragamus> so one of you guys said that StateT stacked onto [] models non-determinism
20:42:42 <cmccann> monad transformers are basically like cheese sauce that you put on your burrito I think
20:42:55 <fragamus> what would ListT stacked on top of State do for me
20:42:58 <tgeeky> i think the list monad by itself is the non-determinism?
20:43:13 <cmccann> yes, the list monad is nondeterminism give or take
20:43:33 <tgeeky> state would be transitions from orderings of nondeterminism, maybe?
20:43:54 <tgeeky> I think the point of all these monad torture-ials is that you have to sit down and try it out to figure it out
20:44:18 <fragamus> ok, and by non-determinism we mean that it is like a depth first tree search or some such right?
20:44:38 <fragamus> like for example a game tree evaluation
20:44:59 <tgeeky> fragamus: non-determinism means that there is a choice in what kind of [ ]-first search you are going to do
20:45:09 <tgeeky> ... I think.
20:45:20 <tgeeky> take everything I say with a entire mine full of salt.
20:46:59 <cmccann> I'm not sure that ListT State would do anything terribly interesting
20:47:08 <cmccann> it'd just be a list of State computations
20:49:18 <fragamus> ListT State... I think/hope that it would allow me to have a herd of states that can reproduce and morph
20:49:35 <tgeeky> only if some of them are male states, and others are female
20:49:53 <fragamus> yes, and some are really cute females
20:52:38 <fragamus> so when we apply a monad transformer does it lift all the functions of the underlying monad? It was surprising to me that I could just invoke various functions of different monad(transformer)s without really specifying which level and it kept everything straight
20:53:52 <mjrosenb> fragamus: that does not sound like it should work.
20:54:20 <fragamus> hmmm, well it seems to work
20:54:34 <tgeeky> famous last words, them
20:54:58 <dankna> yes, that's what the MonadWhatever typeclasses are for
20:55:21 <mjrosenb> fragamus: have you tried invoking the functions that you are using?
20:55:28 <dankna> they define various operations to act immediately if they're in the appropriate level, or to lift it if they're in a level below
20:55:33 <dankna> it doesn't work for every operation
20:55:36 <fragamus> i have for example, a random number generator monad transformer, stacked on some other monads, and i can just whip up a function in do notation and call anything at any level
20:55:44 <mjrosenb> fragamus: haskell likes to just throw arbitrary contexts around some functions that will never be satisfyable.
20:56:10 <fragamus> interesting
20:56:29 <mjrosenb> dankna: but they can't have the same name, right?
20:57:04 <dankna> mjrosenb, correct
20:57:21 <fragamus> very cool
20:57:51 <fragamus> so the outer monadT gets first crack right?
20:58:39 <dankna> exactly so
20:59:43 <fragamus> and really, that is the ONLY monad I am working with, in the sense that the functionality of the underlying monads is exposed only by the grace of the outermost monad transformer
21:00:20 <fragamus> so it essentially incorporates the underlying stuff into itself by lifting it
21:00:46 <dankna> yes, precisely
21:00:56 <fragamus> ok!!!
21:04:30 <fragamus> ok, the thing that REALLY FREAKS ME OUT is the invokation of the monad:
21:04:35 <fragamus> runStateT (runRandT schmoves g) creature
21:04:54 <dankna> yeah
21:05:05 <dankna> it's a relatively complicated invocation, though I've seen bigger
21:05:10 <dankna> why does it freak you out?
21:05:19 <fragamus> the outermost thingy is the innermost thingy
21:05:22 <dankna> ah, yes
21:05:27 <dankna> well, you can see why that is though?
21:05:52 <fragamus> and i have no clear idea of the semantics of this
21:05:53 <dankna> you're essentially running the higher-level monad inside the lower-level one
21:05:55 <fragamus> sort of
21:06:02 <dankna> look at the type signatures
21:06:05 <dankna> :t runStateT
21:06:05 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
21:06:08 <dankna> :t runRandT
21:06:09 <lambdabot> forall g (m :: * -> *) a. (Monad m, RandomGen g) => RandT g m a -> g -> m (a, g)
21:06:16 <dankna> there's really only one way to combine those
21:06:17 <fragamus> you look at the type signatures
21:06:23 <dankna> lol
21:06:41 <dankna> well rather, there's two ways, but only one way that results in the finaly type you want
21:06:42 <dankna> *final
21:08:11 <fragamus> i really dont understand, but please, if the answer is for me to look at that crap ^^^ then im gonna cry
21:08:48 <dankna> hahaha
21:08:49 <dankna> all right
21:08:58 <dankna> you don't really need to get that part, yet
21:09:03 <cmccann> learning to read type signatures isn't that hard, and it's really very useful
21:09:17 <cmccann> though it would help if lambdabot left out the unnecessary forall and kind signatures
21:09:25 <fragamus> i can certainly see that the outermost thing must be approached first, hence it is innermost in the invocation
21:09:50 <dankna> yes
21:10:08 <fragamus> i can do it but it doesnnt lead me to high level understanding as it seems to do for you guys
21:10:15 <fragamus> ok so
21:10:25 <fragamus> what are the semantics of
21:11:04 <fragamus> the thing that is operated on by the next run function
21:11:12 <fragamus> is it a monad   i guess it is but shit
21:11:47 <dankna> it's a monadic action, yes
21:11:58 <dankna> the monad /itself/ is not a value, it's a thing that can contain a value
21:12:07 <dankna> in other words the kind of the monad is not *, it's * -> *
21:12:15 <fragamus> yah
21:12:20 <dankna> a monadic action, however, is a value
21:14:43 <fragamus> ok i see now that the thing in ()s is a monadic action, just as schmoves is
21:14:47 <fragamus> runStateT (runRandT schmoves g) creature
21:15:10 <dankna> yep
21:15:23 <dankna> :t runRandT
21:15:24 <lambdabot> forall g (m :: * -> *) a. (Monad m, RandomGen g) => RandT g m a -> g -> m (a, g)
21:15:42 <fragamus> but what in the blue blazes is that action? I wrote schmoves, but WTF is the action that runStateT gets as an argument?
21:15:54 <dankna> it's just an intermediate value
21:16:14 <dankna> runRandT, as you can no doubt tell at a glance from that type signature :), takes a monadic action -- that is, RandT g m a -- and a random generator -- that is, g
21:16:29 <dankna> and returns a monadic action m (a, g)
21:16:45 <dankna> in a monad of whatever type its caller requires, which is here denoted as "m"
21:17:01 <cmccann> fragamus, each "run____" function is basically just stripping off one layer
21:17:10 <fragamus> as i can no doubt tell from the type signature :P
21:17:16 <dankna> the value it returns is (a, g), which is a pair of the value returned by the inner action, and the new random state
21:17:29 <cmccann> removing the outermost monad transformer and giving something that's just using the inner monad
21:17:36 <dankna> that was my little attempt at humor =p
21:17:54 <fragamus> :P
21:18:00 <dankna> so in a sense each monad in the stack exists, but only for a single action which is the intermediate value
21:18:10 <dankna> only the top monad exists for longer than that
21:18:43 <cmccann> alternatively, each monad always exists, it's just that the monad transformers let you work with them all at once
21:18:45 <dankna> anyway, really, it's not that bad.  you know how to use it, that's what counts.  there's not really anything too deep here.
21:18:56 <dankna> yeah, or what cmccann said is also a valid view
21:19:07 <cmccann> but when it comes to taking things apart to "run" the monad you'll always have to do it one layer at a time
21:19:23 <dankna> well, of course you could define a helper function that did it for you :)
21:19:29 <dankna> if it were a frequent need
21:19:32 <fragamus> ok i like the concept that cmccann just said, it's just removing one layer, BUT it is very confusing to me because I have all these computations intertwined using various levels of the monad stack and it is inconcievable that all the stuff from one layer could be somehow resolved first, and then the next level
21:20:08 <dankna> welllll
21:20:15 <dankna> I know some people have said this is a bad model, but:
21:20:25 <dankna> you can think of a monadic action as a computation "in potentio"
21:20:30 <dankna> it's a set of directions, not yet executed
21:20:45 <dankna> only when you run it does it de-intertwine the layers and actually perform stuff
21:21:06 <cmccann> fragamus, if it helps, you can think of a monad transformer as a description of how to untangle intertwined computations in two different monads
21:21:12 <dankna> it really does undo the intertwining of them though
21:21:16 <cmccann> that's not actually too far from the truth, in fact
21:21:30 <dankna> true enough!
21:21:47 <cmccann> the only reasons monad transformers are necessary is because you can't just glue monads together directly and have it work
21:22:15 <fragamus> ok well I can use it for sure, but when I try to understand it I am reminded of the sparrow that flew down to get a closer look at the badminton game
21:22:39 <dankna> that's quite an analogy there
21:22:45 <cmccann> fragamus, I wouldn't worry too much about it
21:23:02 <cmccann> monad transformers give lots of people headaches
21:23:07 <dankna> when you get more familiar with how it's used you'll see that there's not so much to it
21:23:13 <dankna> just use it for a while, is my advice
21:23:15 <fragamus> i think i have to write one
21:23:27 <dankna> might help, if you really want to
21:23:32 <dankna> or look at the source of one on hackage
21:23:32 <fragamus> i wrote a monad a few months ago
21:24:01 <fragamus> but then I realized that i didnt need it; StateT [] did the job
21:24:05 * dankna nods
21:24:34 <fragamus> It was a good exercise to write a bind operator
21:24:38 <Jafet> Monads are not invented, merely discovered
21:24:53 <cmccann> fragamus, yeah, I've often found the best way to learn something in Haskell is to reinvent it badly a couple times until suddenly it clicks and you wonder why you were doing things the hard way
21:24:54 <dankna> it is a good exercise, yes
21:24:57 <tgeeky> by the *other* guy who invented calculus, whose jock we do not slobber over
21:25:06 <tgeeky> though I think he just invented the name
21:25:12 <tgeeky> not the mathematics
21:25:14 <fragamus> so maybe I will put on my anti-confusion helmet and dive in
21:25:31 <tgeeky> *please* say someone here has used "Tagged" or "Reflection" ?
21:25:38 <dankna> sorry, not I
21:25:42 <tgeeky> le sigh
21:26:12 <cmccann> sorry
21:26:24 <fragamus> i really would like to think that what I'm learning will be a much sought after thing in the future
21:26:30 <tgeeky> also, the testing (chapter 13?) / quickcheck is totally out of date, compared to all the new features of quickcheck 2
21:28:00 <cmccann> fragamus, can't make promises, but a lot of other languages do seem to borrow concepts from Haskell
21:28:23 <tgeeky> which is bound to happen when you're the alpha dog of academic languages
21:28:30 <cmccann> if nothing else, you might learn something here that will be the Next Big Thing in 5 or 10 years
21:28:39 <cmccann> and having a head start can be nice ;)
21:29:20 <dankna> gawd >< I'd forgotten how annoying non-Haskell languages can be ><
21:29:25 <cmccann> hahaha
21:29:41 <dankna> write code, test code, get code working, add a feature to code, notice bug, stare blankly at code you yourself wrote not yesterday ><
21:29:50 <cmccann> dankna, what language?
21:29:54 <dankna> ObjC at the moment
21:30:02 <cmccann> ah, sounds fun
21:30:06 <dankna> yeah, it's not :)
21:30:10 <cmccann> "fun"
21:30:13 <dankna> yeah
21:30:24 <dankna> like those signs that say "Try our 'coffee'"
21:30:38 <tgeeky> dankna: I did notice a haskell language pattern: whereas before you either thrashed against your debugger (or stared at the screen wondering what is goign wrong), in haskell I'm not often convinced that I'm not understanding something, and should ask the compiler (or #haskell) for help :O
21:30:50 <dankna> tgeeky: that's true too
21:31:26 <tgeeky> it's as though GHC++ghci is a wise professor, if only you could ask the right questions, he will say "oh, but of course! This is how you do ___"
21:31:31 <dankna> haha
21:31:49 <dankna> the catch is that you must express your wish precisely, in binary
21:32:47 <cmccann> just wait until something like djinn gets built into the language
21:32:51 <dankna> heh indeed
21:32:58 <cmccann> and you don't have to write functions anymore, just types
21:33:05 <djahandarie> What about Agda?
21:33:06 <acfoltzer> the type checker is all the refactoring engine you need
21:33:18 <tgeeky> i looked at the history of agda's libraries
21:33:18 <acfoltzer> decide you want to use a different type in one spot in a large module?
21:33:22 <tgeeky> that thing is growing like freaking cancer
21:33:31 <acfoltzer> just go ahead and change it, and follow the typechecker's messages back out, changing things along the way
21:33:38 <cmccann> I really need to take another stab at agda
21:33:39 <acfoltzer> brilliant way to work
21:33:55 <cmccann> spent some time learning it a couple months ago but things came up and I never got back to it :(
21:34:13 <tgeeky> acfoltzer: I am still just a baby in haskell, but I find that there is no other situation with a computer (programming language or not) that I feel more confident that if I can get ghci to load a module, it's probably working right :o
21:34:39 <tgeeky> hopefully that sense of security won't be demolished
21:34:50 <acfoltzer> tgeeky: among general-purpose languages, yep
21:34:52 <cmccann> tgeeky, I think the general consensus is that any sufficiently polymorphic function that type checks does SOMETHING useful, even if you don't know what it is
21:35:04 <tgeeky> cmccann: yeah lol
21:35:09 <dankna> hahaha yeah
21:35:10 <dankna> I agree
21:35:22 <tgeeky> cmccann: I have a great example of that, this boltzmann quickcheck plugin thing...
21:35:26 <tgeeky> i really don't understand what it does
21:35:31 <acfoltzer> tgeeky: getting a function to typecheck in Coq or Agda is even stronger, though. Not only will it be shaped right, but it'll have the right things in the right places
21:35:42 <tgeeky> but I can type in some simple generic types and it generates them and never gets stuck
21:36:04 <cmccann> there are still lots of ways to mess things up in Haskell, of course
21:36:07 <tgeeky> acfoltzer: yeah, but I'm struggling with simple haskell stuff
21:36:23 <tgeeky> and I am finding out just how much I *don't* (and should) know about some really simple mathematics
21:36:59 <cmccann> but the language does a good job making sure that the only bugs you create are ones that result from you misunderstanding the problem, sitting down, and deliberately writing a program that does the wrong thing correctly
21:37:13 <cmccann> tgeeky, what mathematics?
21:37:14 <acfoltzer> don't let the unknown math discourage you. If you have programming experience, you probably already know the math, if only by intuition
21:37:41 <tgeeky> cmccann: combinatorics, differentation/integrals
21:37:44 <tgeeky> category theory
21:37:46 <tgeeky> group theory
21:37:57 <tgeeky> lots of things that I should know (since I'm a quantum physicist)
21:38:02 <cmccann> ahahahaha
21:38:04 <tgeeky> and just scraped along
21:38:13 <tgeeky> but which I never "understood" in the way that haskell makes me
21:38:14 <acfoltzer> aaaahaha that's quite a punchline
21:38:19 <cmccann> I was gonna say that combinatorics is something that every programmer should know
21:38:29 <cmccann> but you really have no excuse about some of those :P
21:38:40 <acfoltzer> tgeeky: did you learn about Hilbert spaces when doing quantum?
21:38:47 <tgeeky> acfoltzer: of course
21:39:05 <tgeeky> it's different, though
21:39:07 <cmccann> tgeeky, you've seen John Baez's stuff, right?
21:39:24 <tgeeky> cmccann: I have been exposed to it, but I am deferring really going through it until after I get a good foundation
21:39:46 <tgeeky> I *do* think he's onto something with his general thesis (division algebras and supersymmetry)
21:40:19 <tgeeky> the thing about QM (and learning it)
21:40:27 <tgeeky> is that, in every single semester, every single course
21:40:31 <fragamus> I am not a physicist
21:40:36 <tgeeky> you're always taught - don't get an intuitive understanding of it, because you can't
21:40:38 <cmccann> tgeeky, well, his interests in general tend to cover all kinds of math that are relevant in both physics and Haskell, is why I ask
21:40:57 <fragamus> but I was shocked and amazed when I learned about the sum over histories idea
21:41:00 <tgeeky> cmccann: yeah, he works at category theory and comes back to current (speculative) physics
21:41:04 <fragamus> and the MWI
21:41:15 <tgeeky> he actually just wrote a 150+ page introduction to category theory
21:41:27 <tgeeky> in a new book, Deep Math? or something like that
21:42:03 <acfoltzer> tgeeky: in my experience, category theory only comes into focus once you've seen it from several perspectives. You've got the QM/linear algebra approach, and now that you're learning typed functional programming, you'll have another and it'll make everything easier
21:42:04 * cmccann generally finds MWI-style interpretations much more appealing and intuitive
21:42:19 <tgeeky> acfoltzer: yeah, that's the whole reason I went to haskell
21:43:01 <tgeeky> acfoltzer: that, and I am investgating some specific hypotheses which strong typing (and lazy evaluation) might uniquely enable me to produce results where others have not seen the potential to
21:43:19 <acfoltzer> in QM?
21:43:21 <tgeeky> specifically, fractal symmetries in physics
21:43:21 <fragamus> Once I posed a question to Dr. David Deutsch where I essentially asked if all of the combinations are actualized
21:43:22 <cmccann> I prefer to think that reality consists of a pure function, that wave function collapse business is full of messy mutable state and side effects
21:43:23 <tgeeky> yes
21:44:05 <tgeeky> cmccann: that sounds like the locality-uncertainty-causation route
21:44:11 <fragamus> but sheesh that is a shitload of StateT []
21:44:22 <acfoltzer> haha
21:44:35 <acfoltzer> what about the interpretation of reality as CPS?
21:44:40 <acfoltzer> we just call/cc all the time
21:44:52 <tgeeky> acfoltzer: that might even make sense
21:44:59 <tgeeky> when you think about exactly what a gauge boson does
21:45:20 <fragamus> nothing makes sense
21:45:29 <cmccann> acfoltzer, oh great, now I'm expecting Oleg to start writing physics papers
21:45:36 <tgeeky> Oh yeah? two plus to...... *face melts*
21:45:47 <tgeeky> which one is Oleg?
21:45:53 <acfoltzer> ha, cmccann
21:45:59 <fragamus> no the foundations of simple arithmetic are not simple
21:46:11 <tgeeky> fragamus: so it seems
21:46:26 <tgeeky> acfoltzer: you studied QM?
21:46:31 <acfoltzer> some of my IU colleagues are extending minikanren to simulate QC
21:46:32 <tgeeky> or enough to get your feet wet?
21:46:36 <acfoltzer> so you're not far off mentioning Oleg
21:46:38 <cmccann> tgeeky, Oleg Kiselyov is researcher known for doing crazy mindbending stuff with types, continuations, metaprogramming, and whatnot
21:47:00 <acfoltzer> tgeeky: I sat for a quantum/reversible computing seminar last semester
21:47:01 <fragamus> I was amazed and impressed that Deutsch wrote me back
21:47:05 <Jafet> @quote kill.an.elephant
21:47:05 <lambdabot> olsner says: < kmc> i think 250 milliolegs is enough to kill an elephant  < olsner> kmc: ... to kill an elephant - in the type system!
21:47:18 <acfoltzer> but I don't know much of the physics
21:47:39 <olsner> :>
21:47:57 <fragamus> I have been corresponding with him about twice a year for about five years
21:48:08 <cmccann> fragamus, that's pretty cool
21:48:12 <fragamus> i know
21:48:17 <cmccann> tgeeky, here: http://okmij.org/ftp/ have fun
21:48:39 <acfoltzer> oh man. Don't send someone intimidated by the math of Haskell to Oleg's site
21:48:39 <tgeeky> cmccann: lol I am reading one of his papers right now :/
21:48:41 <acfoltzer> that's just mean
21:48:43 <fragamus> I just found it difficult to get straight answers about MWI
21:48:51 <tgeeky> cmccann: just realized it.
21:48:58 <fragamus> until I went to him
21:49:00 <tgeeky> Functional Pearl: Implicit Configurations
21:49:00 <guerrilla> wait, haskell doesn't support mutually referencing modules? or did i do something wrong?
21:49:11 <cmccann> tgeeky, haha, what paper is it?
21:49:11 <tgeeky> guerrilla: can't both things be true?
21:49:25 <dolio> Officially it does.
21:49:38 <dolio> GHC requires you to write hs-boot files, though.
21:49:38 <Jafet> If you're using GHC, its manual specifies how to do it correctly.
21:49:57 <guerrilla> tgeeky: yes, of course.
21:50:02 <fragamus> Oficcially my **** is 12 inches long
21:50:05 <cmccann> acfoltzer, I actually spent a lot of time trying to figure out oleg's deep magic when I was first learning Haskell
21:50:24 <guerrilla> i prefer not using mutual-reference in any case, i just wanted to test something quickly and encountered the error...
21:50:52 <guerrilla> dolio: ok, good to know. but i think ill just do what i was doing correctly
21:51:28 <Jafet> My foot is 12 inches long, too.
21:51:34 <acfoltzer> I've been a Schemer a lot longer than a Haskeller, so I was familiar that side of his work
21:51:39 <cmccann> a lot of what he does isn't even that difficult, it's just several layers of abstraction removed from everyday programming and he's very no-nonsense about presenting the ideas
21:51:49 <guerrilla> Jafet: officially.
21:51:56 <acfoltzer> when I started with Haskell, I naturally turned to his site, and got the mistaken impression that type-level computation was a normal thing in Haskell
21:52:13 <cmccann> hahaha
21:52:18 <cmccann> maybe it will be someday
21:52:29 <acfoltzer> well, now that I'm learning Cryptol, it's coming in handy
21:52:45 <acfoltzer> but I had to go elsewhere for a while in order to get the right Haskell start
21:52:58 <cmccann> there is work toward making more of that stuff doable without crazy magic tricks
21:53:37 <cmccann> and with less writing code in the world's worst logic programming language
21:53:41 <dolio> A lot of what Oleg does is use limited features and quirks of Haskell's type system, or extensions thereof, to encode things that would make much more sense to just add to the type system.
21:53:46 <dolio> On the Haskell end, that is.
21:54:24 <cmccann> dolio, indeed
21:54:28 <Jafet> Second worst; the worst is from C++
21:54:29 <dolio> Which leads people to propose silly ideas like having 'sugar' for the hackery instead of doing it right.
21:54:48 <cmccann> Jafet, C++ template metaprogramming? that's not a logic language
21:55:08 <cmccann> more functional than anything else really
21:55:15 <acfoltzer> yeah, it all made so much more sense when I saw multi-param type classes as straightforward unification
21:55:30 <acfoltzer> but there's so much in the way that even with logic programming under my belt, I was still mystified at first
21:55:58 <cmccann> programming with MPTCs and fundeps is to prolog as brainfuck is to C
21:56:03 <fragamus> are you guys experiencing the incredible wins of being able to reason about your code because its one big function?
21:56:47 <fragamus> The thing that I like is that my code looks like a spec.
21:57:04 <cmccann> acfoltzer, logic programming is fun without backtracking, isn't it? :]
21:57:05 <acfoltzer> not even your entire code, fragamus. just the type signatures
21:57:11 <Jafet> You want prolog in the type system? I'd be happy with better tuples
21:57:23 <fragamus> but I must admit I haven't done much reasoning about it.
21:57:48 * cmccann would be happier with less prolog and more Haskell in the type system
21:58:18 <Jafet> What would be more Haskell than Haskell?
21:58:35 <acfoltzer> a type language that behaved more like the term language
21:58:39 <cmccann> Jafet, Haskell with extra Haskell inside it
21:58:44 <cmccann> it'd be Haskell all the way down
21:59:05 <cmccann> if you need more Haskell, you just move up one layer and find some
21:59:16 <cmccann> corecursion is nice
22:00:48 <cmccann> but I guess I should probably just start using Agda or something :|
22:01:11 <acfoltzer> there's certainly a balance to be struck
22:02:24 <acfoltzer> I wouldn't want to write quickie programs in Agda, for example
22:02:33 <acfoltzer> but maybe with enough practice, I would
22:03:14 <Jafet> Perhaps quickie programs often aren't
22:03:19 <dolio> There's a fair amount of stuff I'd rather write in Agda, or something closer to it.
22:03:20 <fragamus> dang lost my connection and missed out on the very enlightened chat
22:03:36 <dolio> But I'd have no way to run it subsequently.
22:03:50 <cmccann> acfoltzer, I don't know if there's any inherent reason why quickie programs wouldn't be doable in Agda or something like it
22:03:55 <Jafet> Which is why we write them in haskell and not its half-cousin perl
22:04:55 <acfoltzer> it's probably just my latent Schemer talking :)
22:05:20 <acfoltzer> also my lack of experience with dependent types
22:05:45 <acfoltzer> I usually get caught up trying to solve problems entirely with the type system
22:05:49 <dolio> I often find it nicer to program in Agda even though it requires me to write more signatures and such.
22:05:58 <acfoltzer> and things take a lot longer overall
22:06:07 <acfoltzer> even though it ends up with much nicer assurance
22:06:18 <dolio> Because it buys you real type functions and dependent types, instead of approximations designed to preserve inference as much as possible.
22:07:15 <dolio> Plus the tool support is lightyears ahead.
22:07:47 * cmccann should find some time to play with agda this weekend...
22:08:40 <acfoltzer> I should too
22:08:47 <acfoltzer> most of my dependent type experience is in Coq
22:08:58 <acfoltzer> so maybe I'm conflating my frustrations with that particular language
22:09:41 <guerrilla> dolio: why couldn't you subsequently be able to run your program?
22:10:22 <dolio> Because the state of Agda compilation is way behind that of Haskell.
22:11:59 <guerrilla> dolio: ah ok. but didn't one of the compilers just strip a lot of typing and compile to haskell? is there something wrong with that?
22:13:37 <dolio> Even getting to the point where I could write real programs would probably involve me wrapping a bunch of libraries that haven't yet been written in or wrapped in Agda yet.
22:14:39 * cmccann did a bit of hacking on something to autogenerate agda wrapping for Haskell libraries
22:14:43 <dolio> Agda (minus the termination checker, maybe) is better when I just want to fool with my own data structures.
22:14:52 <guerrilla> dolio: true
22:15:16 <guerrilla> so far im just using agda to rewrite what i did in haskell to verify its correct
22:15:56 <acfoltzer> I wonder how it'd be for cryptography
22:16:02 <guerrilla> havent played with compilation much since i dont want to require users to have agda as its in consant flux it seems
22:16:11 <acfoltzer> implementing ciphers is a new thing for me, but the size types in Cryptol have been helpful
22:16:22 <acfoltzer> I bet there's something similar in agda
22:16:41 <guerrilla> it has some support sized types now, if thats what you mean
22:17:53 <acfoltzer> in Cryptol you can say that something is of type [4][32]Bit, for example, to represent an unpacked 128-bit word
22:17:59 <acfoltzer> that sorta thing would be possible?
22:18:36 <guerrilla> definitely
22:18:52 <guerrilla> one of the first examples you'll learn is fixed sized vectors
22:19:02 <guerrilla> its a short extrapolation to bit matrices
22:19:05 <acfoltzer> I'll have to take another look, then
22:19:20 <guerrilla> you should, it's the future man :) (or something like it)
22:19:37 * guerrilla ducks
22:19:40 <acfoltzer> haha
22:20:07 <acfoltzer> of course, I'm getting paid to learn Cryptol, so that takes priority ;)
22:20:18 <guerrilla> but seriously, tons of active research in the area
22:20:21 <guerrilla> really exciting
22:21:59 <acfoltzer> I'm mostly a user so far, but have touched a bit on the research with hybrid typing
22:22:34 <guerrilla> hybrid type checking you mean?
22:22:53 <acfoltzer> right, the Sage research papers
22:23:16 <guerrilla> ah ok, yah
22:23:44 <acfoltzer> seemed pretty pragmatic when I looked into it, but then I couldn't find an updated implementation
22:23:53 <guerrilla> i conjecture we're getting (theoretically) closer to a point where that's not necc. anymore
22:24:03 <acfoltzer> perhaps that's why
22:25:10 <guerrilla> this stuff is all pretty new and raw though
22:25:24 <acfoltzer> that work just struck me as very nicely pragmatic
22:25:39 <acfoltzer> but perhaps a bit overpromising, since a lot of errors wouldn't come up until runtime
22:32:19 <guerrilla> acfoltzer: doesn't strike me as too different than assert
22:33:11 <acfoltzer> well, that's the thing. assert happens too late
22:35:14 <guerrilla> hmm, adding this paper to my list of things to read this week
22:35:29 <acfoltzer> which?
22:35:50 <guerrilla> "Hybrid Type CHecking" by Cormac Flanagan
22:37:01 <acfoltzer> yeah, Knowles & Flanagan is the main one
22:37:15 <acfoltzer> Flanagan et al is the longer version
22:37:21 <acfoltzer> but the earlier one has the key ideas
22:37:39 <guerrilla> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.114.984
22:37:51 <guerrilla> this looks short enough for my level of interest in it
22:37:52 <guerrilla> :)
22:37:58 <acfoltzer> perfect!
22:39:15 <guerrilla> also it has semantics for refinement types.. my next project
22:43:18 <acfoltzer> well, if you're talking semantics, you might just want to look at contracts
22:43:38 <acfoltzer> the rest of hybrid typing is on the static side
22:45:24 <guerrilla> huh? i'm talking about the typing and subtyping rules.
22:45:58 <acfoltzer> ah. not semantics then ;)
22:46:30 * isomorphic has achieved self actualisation. 
22:46:31 <guerrilla> wtf. how are typing rules not semantics? i'm not talking about operational/denotational/axiomatic semantics or whatever
22:47:18 <acfoltzer> ah, I guess that's the specific meaning it has over here
22:47:27 <acfoltzer> perhaps it's just a difference in... semantics
22:47:53 <guerrilla> i guess it depends on what level of abstraction your working at
22:49:19 <isomorphic> what is it that the phrase 'just semantics' was originally supposed to mean?
22:49:33 <isomorphic> ie: was it supposed to mean - 'you're being pedantic'?
22:49:56 <cmccann> it means quibbling over what things actually mean
22:50:03 <cmccann> instead of more important things, like how the person you're talking to is correct
22:50:46 <isomorphic> cmccann: Yeah, that's the way I've always seen it used.  Particularly in arguments about what things mean.
22:51:25 <acfoltzer> I really wasn't trying to be pedantic, I suppose there's just a silent "operational" that I hear before the word "semantics"
22:51:40 <cmccann> anyway, I need some sleep
22:51:54 <cmccann> so I'll leave you all to discuss the semantics of the word "semantics"
22:52:16 <isomorphic> acfoltzer: That last comment wasn't directed at you by the way
22:52:32 <acfoltzer> I know :) just sayin
22:52:44 <isomorphic> cool :)
22:52:51 <acfoltzer> I've had a few beers so I have to make sure not to step on toes
22:53:28 <isomorphic> Topic for #haskell is metasemantics
22:55:50 <guerrilla> haha, awesome
22:56:16 <guerrilla> anyway, i just meant "cool, more material to look at regarding refinement types" sorry for the confusion
22:59:14 <acfoltzer> guerrilla: it gave rise to metasemantics, so I'd say it was good confusion
23:00:19 <guerrilla> yeah, kinda funny actually. glad that was pointed out. i was too tired to recognize we're taling about the semantics of semantics
23:00:23 <guerrilla> haha
23:00:37 <guerrilla> ok, im going back to being productive now... hehe
23:01:26 <TravisD> I've just started reading "Real World Haskell" by O'Sullivan, Goerzen and Stewart. I just finished a CS degree and I'll be finishing a math degree next semester. Is this a good place to start?
23:01:53 <isomorphic> TravisD: You'll see Stewart in this channel as dons
23:02:09 <TravisD> Neat :)
23:02:11 <isomorphic> (and on StackOverflow)
23:02:36 <isomorphic> So, yes, that book certainly has plenty of community around it
23:03:02 <isomorphic> I would say you should also check out Learn You a Haskell
23:03:05 <Axman6> TravisD: depends how well you know Haskell, it's not the best beginners book, it's much better when you know some haskell
23:03:17 <TravisD> Axman6: I know little to none
23:03:20 <isomorphic> they're written in very different styles that complement one another
23:03:23 <Axman6> LYAH is a better place to start if you're new to Haskell
23:03:28 <Axman6> @where lyah
23:03:28 <lambdabot> http://www.learnyouahaskell.com/
23:03:33 <guerrilla> learn you a haskell for great good is prettier and funnier :)
23:03:57 <TravisD> I think I will take a a combination of both
23:04:21 <arcatan> that's a good solution. they're both great books.
23:04:29 <Axman6> LYAH followed by RWH is the usual advice
23:04:41 <TravisD> Oh, okay. Maybe I will do it in that order then
23:04:42 <isomorphic> lyah has shorter, less dependent examples
23:05:20 <acfoltzer> I recommend switching back and forth a bit
23:05:36 <acfoltzer> most of lyah, then most of RWH, then the end of lyah
23:06:03 <TravisD> Great! Thanks for all the advice :)
23:06:12 <acfoltzer> the functors/applicatives/monads sequence of lyah is great, but I think that doing most of RWH first will be good practice to get you ready for it
23:06:19 <isomorphic> I personally find Haskell needs lots of doing - so I try to get the large examples from RWH and modify them
23:07:45 <TravisD> isomorphic: I'll keep that in mind. I set up emacs with haskell-mode when I got home from work today
23:08:58 <andrus> haskell-mode vim vs haskell-mode emacs?
23:09:10 <TravisD> Anyways, one of my friends has tried to explain monads to me a couple of times in the context of category theory. It didn't make very much sense though, since it was kind of rushed and not very formal
23:09:11 <andrus> i'm a vim user and i won't change, but i wonder if i'm missing anything...
23:09:34 <isomorphic> TravisD: Yup.  Try to get comfortable with putting little examples in GHCI - that's really helpful - you'll often see things explained in this channel by reference to the types of the things involved
23:10:02 <TravisD> Yeah. I was really surprised to see that sometimes the types of functions uniquely identify their behaviour
23:10:17 <isomorphic> ah - yeah djinn?
23:10:39 <TravisD> djinn?
23:11:13 <isomorphic> @where djinn
23:11:13 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
23:11:40 <isomorphic> Does what you just described - implies functions from their types
23:11:50 <TravisD> Ah
23:11:54 <arcatan> @djinn a -> a
23:11:55 <lambdabot> f a = a
23:12:15 <TravisD> @djinn [a] -> a
23:12:16 <lambdabot> Error: Undefined type []
23:12:19 <TravisD> ah
23:12:45 <arcatan> @djinn (b -> c) -> (a -> b) -> a -> c
23:12:45 <lambdabot> f a b c = a (b c)
23:12:59 <acfoltzer> @djinn (a -> b) -> [a] -> [b]
23:12:59 <lambdabot> Error: Undefined type []
23:13:28 <isomorphic> @type (+)
23:13:29 <lambdabot> forall a. (Num a) => a -> a -> a
23:13:35 <TravisD> Are there some functions which are uniquely determined by their type that are nontrivial?
23:13:57 <isomorphic> TravisD: I think it depends on how expressive your typesystem is
23:14:01 <isomorphic> i'm not an expert
23:14:02 <TravisD> ah
23:14:12 <isomorphic> in fact, not even a beginner really :/
23:16:23 <TravisD> It is nice to see that the community is so active
23:22:53 <Azverkan> Just tried using the attoparsec-iteratee library too see how it compared and I was surprised to see this: http://pastebin.com/G0LQPyBR
23:22:55 <mauke> The paste G0LQPyBR has been copied to http://hpaste.org/new
23:23:16 <Azverkan> I am still fairly new to haskell, is there anything glaringly wrong with that test?
23:23:48 <Axman6> explaioning your problem would make answering you a lot easier
23:24:21 <Azverkan> the performance of attoparsec-iteratee is over 90% in the GC
23:25:28 <Axman6> probably because you're not taking advantage of it being an iteratee. what you should be doing is interleaving your input and output within an iteratee
23:26:47 <Axman6> at the moment, you seem to be reading in every single file in the inout file, and then finally writing it out. this is almost guaranteed to cause huge amounts of memory usage
23:27:36 <Azverkan> it more or less roughly mirrors my complex algorithm in a less complicated manner
23:28:00 <Azverkan> the algorithm is such that it has to randomly address 2GB of a file
23:28:06 <Axman6> what you ideally want it to read in a single line of the input, then write your results and repeat
23:30:08 <Azverkan> yeah, I would expect that to performance better when operating in a streaming manner, but in this instance I am trying simulate the full read of the file to mirror what happens with a non trivially optimizable use case
23:31:12 <Axman6> well the parser can't return anything at all until it's read the entire file
23:31:46 <Axman6> there's no use benchmarking a good way of doing something by trying to make it perform like a bad way of doing something
23:33:24 <Axman6> one thing I've learnt this semester from my parallel systems course is that when you're comparing a parallel implementation of some solution to a sequential one, you should use the best known sequential algorithm, not the parallel algorithm running on a single core
23:35:48 <Azverkan> I think you could simplify that to say that the algorithm that uses the least amount of memory bandwidth trumps all other concerns in bandwidth constrained environment
23:36:33 <Axman6> maybe.
23:36:45 <Axman6> large memory usage isn't necessarilly a problem
23:37:06 <Axman6> anyway, if you want to benchmark things, benchmark things that are as good as they can be, not cripled to make the comparison 'more fair'
23:37:22 <Axman6> be cruel man, and life a happier life for it@!
23:37:24 <Axman6> -@
23:37:26 <Azverkan> I was more trying to understand why the iteratee is less efficient in this case
23:38:27 <Axman6> well there'll be a lot of memory allocated just to keep track of the parser itself which can't be freed, along with the data that's parsed in and stored
23:39:19 <Axman6> getting good performance from iteratees requires understanding how they work to some degree, so you don't make mistakes that allocate much more memory than expected
23:41:05 <haskellguy> hi all!
23:41:47 <Azverkan> actually I just noticed that defaultBufSize in the version of iteratee is 1KiB, raising it to a more sane level stops hammering the operating system
23:42:00 <Azverkan> in my version, that is
23:43:10 <haskellguy> i recently started using haskell, and im looking for some project ideas, where i can use higher order functions, recursion etc.. pls suggest a few...
23:43:22 <Axman6> haskellguy: project euler!
23:43:25 <Axman6> @where PE
23:43:26 <lambdabot> I know nothing about pe.
23:43:28 <Azverkan> raising it to 1MB makes iteratee faster faster than stock attoparsec and attoparsec lazy
23:43:28 <Axman6> bah
23:43:32 <Axman6> @where project euler
23:43:32 <lambdabot> I know nothing about project.
23:43:37 <Axman6> you suck lambdabot
23:43:43 <Axman6> @google project euler
23:43:45 <lambdabot> http://projecteuler.net/
23:43:45 <lambdabot> Title: Project Euler
23:43:50 <shachaf> Axman6: That's not really so helpful for learning a programming language.
23:44:19 <Axman6> it helped me learn haskell a lot, by giving me programs to write
23:44:51 <Axman6> and then it helped me learn lots of useful algorithms to make things run more quickly
23:45:59 <haskellguy> @Axman6: thanks.
23:45:59 <lambdabot> Unknown command, try @list
23:46:20 <Axman6> haskellguy: also, stick around in here and ask lots of questions!
23:46:55 <haskellguy> thanks for the support guys, ddnt know this channel is this helpful :)
23:49:01 <ddarius> There's not a project where you wouldn't use "higher order functions, recursion, etc."
23:49:44 <haskellguy> i also need to code my own HOF rather than using map, filter etc...
23:51:16 <haskellguy> i was wondering, if i do that, under the hood, there must be list processing right (since im not using prelude functions like map etc)?
23:52:06 <ddarius> There would only be list processing if you're processing lists.
