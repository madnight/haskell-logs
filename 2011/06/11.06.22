00:02:29 <mwc> shaleh: does it work without the -O2?
00:02:46 <shaleh> hmm, I have not tried it. One sec...
00:03:22 <shaleh> mwc: nope, same result
00:04:06 <mwc> Hmm, that shit is odd then. Pastebin your source assuming you're not working on some super secret NSA project
00:04:52 <mwc> mayhaps someobyd wiser than I shall have the answer that you seek
00:05:17 <identity_> and less drunk
00:05:17 <identity_> :P
00:05:48 <mwc> just because I misspell somebody doesn't mean I'm drunk, identity_
00:06:26 <identity_> mwc: I thought you were saying you were drunk before
00:06:30 <identity_> sorry, misunderstood
00:06:46 <mwc> identity_: stfu, I'm pretty sure that as far as shaleh knows, I'm stone cold sober
00:07:04 <identity_> mwc: Haha.
00:07:32 <shaleh> mwc: the source is not secret, but also not really interesting either. I would have to tease it out to something I could post. It basically reads a csv file, does a HTTP request, parses the JSON response and then does math on the csv + json data
00:07:44 <mwc> fwiw. of ot
00:08:14 <mwc> fwiw, as it's a single file, I suspect GHC is aggresively inlining the fuck out of it and not generating any interesting profiling data
00:08:31 <shaleh> it only uses a meg of memory at runtime so this is mostly just idle curiosity to learn the GHC tool set
00:08:47 <shaleh> well, it is actually 4 hs files
00:09:14 <mwc> Hmm
00:09:46 <shaleh> csv data, json data, the amalgamated data, and the driver
00:10:20 <mwc> it uses a  meg of runtime regardless of the size of the input set?
00:11:47 <shaleh> mwc: i have not experimented too closely. I really do not care how much it uses. Like I said, I am more curious about how much it uses, when, etc. So I can learn to be as efficient as reasonable.
00:13:10 <mwc> Hmm, maybe you don't actually have a problem and everything is working perfectly, your code runs in deterministic space without any heap allocation, and unicorns stalk the garden of eden.
00:13:17 <mwc> Fuck I wish I had your problems :P
00:13:35 <shaleh> heh
00:13:37 <mwc> So without -O2 it still produces all zeros on the heap profile?
00:13:43 <shaleh> mwc: correct
00:14:00 <mwc> bi-fucking-zar
00:14:02 <mwc> what platform?
00:14:29 <shaleh> osx, using haskell platform, 7.0.3 ghc version
00:15:18 <mwc> Odd. It might be an OS X-related runtime bug, but I doubt it. Can you get any useful heap profiling data on other programs?
00:15:30 <shaleh> 1,064,036 bytes allocated in the heap <--- this is for a 4 line csv file
00:16:07 <mwc> What about for a 4000 line CSV file? If the memory usage is constant, count yourself a genius
00:16:21 <shaleh> 1,673,064 bytes allocated in the heap <-- 12 line
00:17:48 <shaleh> a typical input line: 5/16/2011,Buy,TXN,35.11,25,-887.7,,order posting,9.95
00:18:12 <mwc> do any of the other -h options produce useful data? Perhaps -hm?
00:18:45 <shaleh> nope, same zeroes
00:19:18 * shaleh goes looking for another small app to profile
00:19:26 <mwc> Odd, perhaps you should ask during daylight hours in North America to see if any OS X users have advice
00:19:42 <shaleh> yeah, I was about to post to beginners
00:23:45 <erus`> haskell questions on stack overflow get lots of points :)
00:24:17 <mwc> What if you run with -xt as an RTS option?
00:24:20 <shaleh> I am officially, "get off my lawn" aged. I like my mailing lists
00:25:11 <shaleh> mwc: no help
00:25:41 <mwc> Well, I'm out of ideas.
00:27:47 <shaleh> hmm, I just tried it on my baby rpn calculator. No output there either.
00:28:04 <shaleh>  ghc -prof -auto-all -rtsopts -fforce-recomp --make -o rpn main.hs
00:28:16 <shaleh> ./rpn +RTS -hc
00:28:30 <shaleh> same output file as I pasted earlier
00:28:31 <mwc> try deleting the -rtsopts from your compilation
00:29:02 <shaleh> ./rpn +RTS -hcrpn: Most RTS options are disabled. Link with -rtsopts to enable them.
00:29:43 <mwc> sorry, try -rtsotps=all
00:30:13 * mwc had confused -rtsopts with -with-rtsopts
00:31:07 <hpaste> dylykes pasted “RevengeOnTheTypeChecker” at http://hpaste.org/48146
00:31:22 <shaleh> mwc: no love
00:31:29 <dylukes> whoops, misspelled my name.
00:32:15 <mwc> dylukes: now you'll never get the credit you deserve
00:32:28 <dylukes> I'm sure it's been done before :P
00:32:58 <dylukes> anyways I'm having some trouble using my type level nat in my Vec type :(
00:33:17 <dylukes> it seemingly has trouble unifying n, Z and (S n) in most cases.
00:33:32 <dylukes> well, in the commented out ones...
00:33:55 <mwc> I suggest going into your bathroom, turning out the lights, and chanting "Oleg Kiselyov" 3 times
00:34:18 <dylukes> Additionally I'd like to move the (S a) matches on the right hand sides of the instances to (Suc a a1) relationships on the left, but then pattern matching explodes in my face and instances overlap and god knows what.
00:34:37 <mwc> hmm
00:34:42 <shaleh> dylukes: more pragmas, definitely.
00:35:03 <dylukes> shaleh: I actually removed a lot.
00:35:29 <dylukes> I kind of see this as me bending the type checker over backwards and forcing it to inductively figure out types :D.
00:35:42 <dylukes> I'm quite happy with the result, for the most part.
00:35:52 <dylukes> the undefined trick is neat too, ran into that by accident and I'm still not sure why it works though.
00:36:04 <dylukes> This is what happens when I have no internet, just Agda and Haskell and emacs...
00:41:56 <mwc> Aww, damn, he left. I was just about to suggest that if he considered the Curry-Howard isomorphism, the `undefined trick' is just injecting propositions into the environment
00:42:03 <mwc> ie, giving axioms
00:53:27 <erus`> does snap run on windows?
00:57:56 <zark4711> Hi! Is there a way to force import a data constructor from a library where the constructor is not exported from?
00:59:41 <osfameron> zark4711: I don't think so (though possibly with some extension or introspection?)
00:59:46 <osfameron> zark4711: why would you want to?
01:00:59 <Jafet> unsafeCoerce is your friend
01:02:20 <quicksilver> unsafeCoerce is a treacherous and unreliable ally
01:02:30 <quicksilver> if he appears to be your friend, he may have something else on his mind ;)
01:03:07 <Jafet> But he stuck with me all the way when the day was dark and the program segfaulted
01:04:18 <zark4711> hmm. I try to keep it short.
01:04:47 <zark4711> I am builing a html templating engine based on blaze html.
01:05:26 <zark4711> well. more like a web-page-generator.
01:05:39 <mwc> Generally if a data constructor *isn't* exported it's because it represents some internal state which you as a client should not fucking use
01:06:03 <kalven> fucking eh?
01:06:29 <zark4711> mwc: you are right. it has to do with unsafePerformIO which i also should not use.
01:06:49 <zark4711> data Website = ... a bunch of pages
01:06:49 <mwc> If you really think you need it, send an email to libraries@haskell.org and the maintainer and explain why, and 99% of the time you'll get an email explaining why you're wrong and what you should do instand
01:07:08 <zark4711> data RenderEnv = WebSite and Page that is to be rendered
01:07:12 <mwc> zark4711: well, if you've gone to unsafePerformIO your very soul is forfeit and nothing I can advise could possibly save if
01:07:19 <mwc> /if$/it/
01:07:43 <zark4711> type Template = RenderEnv -> Html
01:08:25 <zark4711> was my first approch. did work. except, that i need to introduce state to be able to modify the <head> section when applying a template
01:08:43 <zark4711> some templates might need add java-script imports in the head
01:08:56 <zark4711> other approch
01:09:36 <osfameron> yeah, the sticking js imports in <head> thing is always fun
01:09:49 <zark4711> type Template a = State TemplateState a
01:09:59 * osfameron usually ends up sticking the imports along with the widget code instead
01:10:15 <zark4711> this way i could easily use the monad and stick "Template Html"-things together.
01:10:50 <zark4711> or Template (Html->Html) things or whatever is neede.
01:11:00 <zark4711> unfortunately a typical template would look like
01:11:11 <zark4711> someTempalte :: Template Html
01:11:14 <zark4711> someTemplate = do
01:11:41 <zark4711>    htmlThinINedd <- someFunctionthatReadsFromEnviroment
01:11:57 <zark4711>    evenMoreINeed <- someOtherFunctiosn
01:11:59 <zark4711>    ...
01:12:33 <zark4711> return $ a lot of Html suff goes here and "htmlThingINeed" and "evenMoreINedd"
01:13:34 <zark4711> the control is greate but it is too verbose. and having to work in the State TemplateState monad to creat the Html-things that depend on the enviromentent and fitting them later into the retured Html is tedeous.
01:13:44 <zark4711> other approch:
01:14:33 <zark4711> I lift everything from the blaze html library to my own monad. so blaze-html stuff does not have side effects. but that does not matter. good that i can use it in my own state monad now.
01:15:20 <zark4711> ok. i dont want to create a copy of the blaze html library. what if the library changes? that would mean a lot of work and dependencies that will surely soon fail
01:16:10 <zark4711> so if i can't lift the blaze stuff into my state monad. maybe i could "lower" my state monad into the blaze HtmlM (which is more like string concatenation and no real monad. but it enables the do-notation)
01:16:18 <zark4711> So a template will Be
01:16:23 <zark4711> :: Html
01:16:57 <zark4711> and i use an IORef with the state and unsafePerformIO to modify it. That will make the templates look really great
01:16:57 <osfameron> why do you want your templates to have state?
01:18:29 <zark4711> a template needs to do some stuff someplace in the body where it is applied and it might also need to add a line of html to the head. imagine a template that puts an animation to an image. it will have type Html -> Html and needs to modify the given image in some way. but it also needs to add an import script statement to the head of the html document
01:18:38 <zark4711> therefore i need it.
01:19:01 <osfameron> why does it need state in order to add the import ?
01:20:10 <zark4711> that is probably a good question because i don't know how to not use state.
01:21:33 <osfameron> I don't know how blaze works, so can't actually suggest an alternative way ;-)
01:21:41 <zark4711> a tempalte could be something of type :: (Html,Html) where the fst is the html for the head and the snd is the html for the body.
01:23:22 <zark4711> and i would append two templaes by appending their firsts and seconds. but wait, how to i insert a tempalte then in the middle of a long do $ :: Html
01:24:13 <zark4711> I can't because the first html part for the head has to go somewhere and does not intermix with Html
01:24:28 <zark4711> i mean (Html,Html) does not intermix with Html
01:24:54 <zark4711> so the first part has to go somewhere. in a state?
01:25:38 <osfameron> zark4711: looks like there are Blaze people here in chan, so if you stick around, and maybe ask the question again later when there's more people about, you'll get someone better informed than me who can help ;-)
01:25:42 <zark4711> well, one could lift all blazehtml functions to make them compatible with (Html,Html) by \snippet -> (EmptyHtml,snippet)
01:26:12 <zark4711> but that would be the rewrite library approach
01:26:58 <zark4711> i think i will hide the state in an invisibel ioref and do som nasty but effective things. maybe the html library should have a variant introducing state. that would solve the probelm.
01:27:12 <zark4711> i will talk to one of them.
01:27:42 <zark4711> but that is a too big task for today where i have to finish the template stuff to really create the website, that is due to friday.
01:28:02 <osfameron> good luck ;-)  what's the project?
01:28:18 <zark4711> thank you very much for you insights
01:28:28 <zark4711> just a small website for a customer
01:28:46 <zark4711> http://nikbook.homeip.net/en/Unternehmen/
01:29:17 <osfameron> cool.  interesting to see Haskell being used for that kind of thing
01:29:42 <erus`> good god it looks like the stylesheet didnt download properly
01:29:58 <zark4711> the stylesheet is not done.
01:30:08 <zark4711> the whole site need these grafical things
01:30:15 <zark4711> which i need to build in
01:30:30 <zark4711> for now (click on the image http://nikbook.homeip.net/de/Anfahrt.html)
01:30:50 <zark4711> i need to be able to add more than one javascript snippet to do the image animations
01:30:56 <erus`> why does the site need to be dynamic?
01:31:17 <zark4711> is not dynamic. is statically rendered. but i dont want to use copy paste
01:31:25 <zark4711> also i made shure all the links are valid ;-)
01:31:54 <erus`> i wanna build a site with haskell
01:31:59 <zark4711> and for the same stuff on every page i programmed the template stuff. (only 200 lines so thing overly complex)
01:32:55 <zark4711> I can give you my code, if you want to
01:33:24 <zark4711> or drop me your email. so i can notify you, when i uploaded the source somewhere
01:36:29 <quicksilver> hakyll is supposed to be for that kind of thing
01:36:37 <quicksilver> static website creation
01:37:56 <zark4711> ah. thank you.
01:38:04 <zark4711> i will have a look at that
01:38:07 <erus`> quicksilver: have you tried snap?
01:38:39 <quicksilver> erus`: I've not tried any of them :)
01:40:12 <zark4711> about that Empty thing I started with...I return _ = Empty in the instance Monad HtmlM a... great
02:02:38 <sanjoyd> Hi! If someone has some time to spare, I'd like some constructive criticism on this: https://github.com/sanjoy/Compiler.hs
02:04:20 <Botje> any reason why you chose a hashtable?
02:04:51 <sanjoyd> Botje: for identifying keywords?
02:04:56 <sanjoyd> Botje: what other option do I have?
02:05:21 <quicksilver> Data.Map ?
02:05:30 <quicksilver> or Data.Set possibly
02:05:50 <sanjoyd> quicksilver: I'm trying to implement as much as I can - this is more like a learning project.
02:05:57 <sanjoyd> quicksilver: same reason why I wrote my own State monad.
02:06:36 <Botje> oh, okay then :)
02:09:03 <rpglover64> Is it possible to do anything with type families that can be done with functional dependencies? More specifically, is it possible to modify the "Type-Level Instant Insanity" code to use type families instead of functional dependencies?
02:09:54 * sanjoyd googles Type famililes.
02:11:17 * rpglover64 hopes that sanjoyd will understand it better than him
02:12:14 <jedai> rpglover64: I think that in theory that should be the case but that there are still some problem with type equality constraints in some contexts
02:13:41 <rpglover64> jedai: do you know of any examples of type-level programming with type families?
02:20:45 <hpaste> erus` pasted “bottleneck” at http://hpaste.org/48148
02:21:02 <erus`> can someone look at that paste and tell me how i might optimize it please
02:22:44 <sanjoyd> erus`: have Board contain a Square->Square function, which you can set to id initially, and then to invert to inverse in O(1). :)
02:23:52 <erus`> i have that allready, if i understand correctly
02:24:08 <sanjoyd> Never mind, I'm short on sleep.
02:29:26 * hackagebot syntactic 0.4 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-0.4 (EmilAxelsson)
02:37:59 <Cale> erus`: It's curious that you're not taking advantage of the fact that pairs can be array indices
02:38:45 <Cale> listArray ((1,1),(bs,bs)) or  listArray ((0,0),(bs-1,bs-1))
02:48:05 <tibbe> erus`, you want UArray to store Ints
02:48:21 <tibbe> I mean if your indexes are Ints
02:48:35 <erus`> ah i'll take a look
02:48:39 <tibbe> wait
02:48:43 <tibbe> I might be confusing myself
02:48:48 * tibbe rarely uses Array
02:49:07 <tibbe> I'm wrong, don't mind me
02:50:20 <ben> What's the advantage of (fix $ \f x' -> ... call f recursively ...) x over let f x' = ... call f recursively ... in f x?
02:50:31 <quicksilver> there is no advantage.
02:51:27 <quicksilver> unless you count the fact that fix is 'just' an expression and you can inline it anywhere as an advantage
02:51:42 <quicksilver> i.e. anonymous recursive values, much like lambda lets you write anonymous functions.
02:51:58 <zygoloid> ben: one of the first things ghc's optimizer will do to the first snippet is inline 'fix', resulting in the second code snippet
02:51:59 <roconnor> there is a small difference in how function with multiple arguments are called
02:52:05 <ben> I am looking at the definition of >>= for Iteratees in http://hackage.haskell.org/packages/archive/enumerator/0.4.10/doc/html/src/Data-Enumerator.html#Iteratee
02:52:12 <roconnor> but ya, probably after optimizations they end up the same.
02:52:14 <benmachine> there's also that you can easily replace fix with another fixpoint combinator, e.g. one that memoise
02:52:17 <benmachine> s
02:52:24 <ben> The pdf on the author's website says "Second, the worker is rendered anonymous with fix, so it doesn’t incur any additional time"
02:52:27 <ben> +overhead
02:53:14 <roconnor> I'm hopeful that fix is inlined
02:53:26 <ben> It's probably more complicated that I am able to represent in here
02:54:49 <ben> maybe this is more about the worker/wrapper transformation :i
02:55:27 <quicksilver> ben: that's interesting since I always imagined they generated the same code.
02:55:46 <quicksilver> I guess this is a very specific property of GHC's optimizer that they behave different in some cases
02:58:37 <zygoloid> hmm, they indeed do not generate the same code
03:01:29 <zygoloid> the directly-recursive one is better; the one using fix appears to miss some CSE opportunities
03:01:46 <zygoloid> i guess because things aren't getting lifted to between the \f and the \x
03:02:14 <roconnor> aavogt: That is really nice
03:04:04 <ben> Learning about the execution model by backtracking from some guy's decision without knowing his intentions might not be the best plan D:
03:07:17 <benmachine> erus`: don't create a new array, just change the way you index the old one?
03:12:58 <zygoloid> ben: fwiw, the worker-wrapper transform is applied either way, in my test case.
03:13:54 <ben> zygoloid: does fix make it easier for the compiler, maybe...? :/
03:16:05 <erus`> is there a filter for Data.Array
03:16:06 <zygoloid> hmm, i've made a couple of trivial changes to my testcase, and worker-wrapper is no longer applied to the fix-based one.
03:18:08 <ben> (What does worker-wrapper being applied actually involve? I thought the term refered to writing code that allows you to avoid boxing/unboxing in highly recursive calls, is the compiler just recognising that you did that and eliding the boxing/unboxing steps for you?)
03:19:44 <edon> any of the regex libraries '.' match unicode characters too?
03:19:49 <zygoloid> the compiler splits your function into two parts (recursive and non-recursive), applies a special annotation to the worker, and marks the wrapper as __inline_me
03:21:18 <Cale> ben: Worker-wrapper is just a kinda funny name for transforming a problem into a new domain, solving it there, and then transforming back.
03:22:03 <quicksilver> edon: all of them I would think?
03:22:27 <ben> Cale: I'm trying to figure out what parts of the technique I am responsible for and what the compiler is going to recognise and do about it and where the profit comes in
03:22:53 <Cale> ben: Often, when doing this automatically, there are some nice rewrite rules you can give (using a RULES pragma) to remove any adjacent isomorphisms after inlining
03:22:58 <ben> (and also why the enumerator author uses fix specifically instead of a let-binding)
03:23:09 <Cale> But often if you're doing it by hand, you can do this yourself.
03:23:31 <Cale> For example, if you consider the problem of traversing a tree, the naive way:
03:23:39 <Cale> inorder Tip = []
03:23:52 <Cale> inorder (Branch x l r) = inorder l ++ [x] ++ inorder r
03:24:26 <Cale> Working directly with lists here is bad, because xs ++ ys is O(length xs) time, so for some trees, this becomes quadratic
03:25:39 <Cale> But we can solve it instead by transforming the problem to one on list-transforming functions (which add elements to the beginning of another list), and then applying the resulting function to the empty list to transform back
03:25:59 <Cale> inorder' Tip = id
03:26:06 <ben> That's the dlist scheme, isn't it
03:26:17 <Cale> inorder' (Branch x l r) = inorder' l . (x:) . inorder' r
03:26:18 <Cale> yeah
03:26:32 <Cale> (.) is O(1)
03:26:39 <Cale> so this is efficient
03:26:46 <ben> It always seemed like cheating
03:26:59 <ben> Surely the O(length xs) is just disappearing into some thunks I can't see somewhere
03:27:04 <Cale> nope
03:27:24 <Cale> no cheating here :)
03:28:28 <Cale> (and you can check it by actually running the program on a left-leaning tree, how much better it is :)
03:29:26 <Cale> The thing is that functions of type [a] -> [a] support "concatenation" that's fast, but not much else
03:30:19 <Cale> (f . g) x = f (g x), which always reduces in one step
03:30:27 <Cale> So it can't be anything but O(1) :)
03:31:08 <ben> Yeah, I'm inevitably going to end up with a chain of N or so (.)s and a bunch of ids and (x:)s inbetween
03:31:22 <Cale> (and the performance of it is not affected by the details of what the function f is, unlike with ++
03:31:24 <Cale> )
03:31:36 <Cale> mhm
03:31:55 <Cale> and that chain will be O(n) where n is the size of the tree
03:32:04 <ben> yeah
03:32:19 <ben> And the wrapper part of the whole thing is just ($ [])
03:32:23 <Cale> yeah
03:34:53 <frerich> CaleE: Does this technique of returning a function (x:) instead of doing the concatenation "directlry" have a name? I see to recall somebody else showed me that trick a while ago and I thought it was really cool. Unfortunately I cannot find where I did that now.
03:35:26 <frerich> I'd like to read up about it.
03:35:34 <ben> I have heard the result structure refered to as DList, but I have no idea how formal that is or what it means.
03:35:37 <ben> Difference list?
03:36:09 <Cale> I've always thought of it as the ShowS trick. Don made a library a while back called DList which just newtypes the whole thing and formalises it a bit
03:36:26 <Cale> (which I guess is kinda useful if you need the monoid instance)
03:36:37 <zygoloid> it's quite fun and instructive to draw diagrams of how DLists are represented :)
03:38:09 <volvic> hi people! i am getting the following error while trying to load a BMP image using Repa (through "readImageFromBMP"):
03:38:10 <volvic> Left ErrorLacksWholeNumberOfLines
03:38:10 <volvic> Any ideas of what i am doing wrong?
03:38:14 <edon> quicksilver: regex-compat doesn't, pcre-light matches it though
03:39:03 <Cale> volvic: hmm, that's interesting. Sounds like an error that you'd get from a malformed image file, but if you're sure it's good, maybe it's a bug in the image loader library.
03:39:42 <ben> a google search result suggests "(currently reading only works for 24 bit .bmp)", maybe you are dealing with some exotic bmp.
03:40:24 <volvic> i created the image from scratch on MacOS, so i also thought that might be the problem but now i tried saving it using MS Paint in windows, so it shouldn't be the problem
03:40:56 <volvic> would be nice to try it with a BMP that's confirmed to work
03:41:39 <volvic> Cale: i'm such a noob that library bugs are the last thing I assume when my code doesn't work :)
03:41:45 <erus`> https://github.com/tm1rbrt/haskell/blob/master/pawns/pawns.hs try my ai :)
03:42:53 <Cale> volvic: Have you tried repa-devil?
03:43:12 <ben> http://ilfirin.org/hi.bmp here is a bmp that works for me
03:43:31 <volvic> ben cool! will try that
03:43:43 <ben> ghci> readBMP "hi.bmp" -- => Right (BMP {bmpFileHeader = FileHeader { ....
03:43:44 <volvic> Cale: i did, but I can't get it to work on OSX
03:43:46 <synesthesia> According to the ghc manual, ghci can load static (.a) libs, but I can't seem to find any documentation for how this is done. I'm currently rummaging about ghci/Linker.hs and main/DriverPhases.lhs (in the GHC sources), but I figured I'd ask here in case anyone else knows
03:43:58 <ben> using Codec.BMP directly which seems to be what repa is getting its error type from
03:44:25 <synesthesia> for clarification: I want to be able to load a precompiled .a static lib in osx (the .a lib is my c library)
03:44:38 <synesthesia> this, of course, if for use in my .ffi binding
03:44:54 <volvic> ben: awesum! that worked for me as well
03:45:04 <volvic> do it's got to be my bitmap format
03:45:06 <Cale> synesthesia: Would .o be okay? afaik, you can pass .o files on the commandline
03:45:14 <Cale> synesthesia: I've never tried .a
03:47:00 <Cale> synesthesia: Or you mean at runtime?
03:47:39 <Cale> (you want to load a static library dynamically?)
03:48:02 <synesthesia> Cale: .o would be fine (and I've tried and tested this), but now I'm curious how to link a `.a` file when running ghci (e.g. ghci FFIBinding.hs blah-blah-blah -lmylib)
03:48:18 <synesthesia> Cale: yes, it appears as if this is possible (following ghc bug tickets)
03:48:20 <Cale> ghci FFIBinding.hs foo.o
03:48:28 <volvic> ok so creating the BMP from scratch in MS paint works, but opening and re-saving one created in Seashore (on OSX) doesn't
03:48:34 <volvic> thanks #haskell!!
03:49:34 <Cale> synesthesia: ah, okay
03:59:14 <erus`> steve jobs doesnt wont BMPs to open in haskell
04:00:45 <Axman6> blame the gimp
04:01:22 <Botje> freedom from porn!
04:08:37 <nus> freeform pr0n
04:20:44 <osfameron> this looks rather cute (in Scala) http://www.spark-project.org/examples.html
04:21:04 <osfameron> in an analytics tool, you'd typically want the most *recent* examples, for summaries
04:21:25 <osfameron> is there a pattern for "Give me the latest *evaluated* results of an infinite list" ?
04:21:40 <osfameron> e.g. the bits before a promise/thunk that is still blocking on other data ?
04:22:20 <osfameron> I'm thinking of, for example a groupBy or fold that grouped reporting events by day/week/etc.
04:23:03 <quicksilver> osfameron: no, the property of being 'evaluated' is not observable without 'cheating'.
04:23:05 <osfameron> so I might want to ask for most recent full day (and get most recent results grouped as 21st June) but if I ask after the results are ready, I'd get 22nd
04:23:50 <quicksilver> lazy evaluation is transparent and not observable which means such RTS observation is firmly in the realms of compiler-specific hacks.
04:24:20 <quicksilver> there is a package called 'vacuum' which uses GHC internals to help you visualise how expressions are evaluated, for example.
04:25:37 <roconnor> should StateT s m be an instance of MonadReader s?
04:26:52 <osfameron> quicksilver: ah well.  This is for something I'm likely to be doing in notHaskell, but if there were libraries/patterns/knowledge available, it's worth asking ;-)
04:27:35 <osfameron> I guess in haskell you'd do something like having the scan/group running somewhere with access to a State, and updating the most recent values in that?
04:29:05 <aavogt> osfameron: I don't know if this will work, but you might have a computation which tries to force the rest of it, but that thread gets killed after a short time
04:29:45 <osfameron> aavogt: yeah - I'd thought of something like that!  though... it's fairly hackish
04:29:53 <osfameron> I wonder if I'm thinking the entire thing the wrong way
04:30:16 <osfameron> but I think the equivalent of "tail -f" on an infinite list *is* the most elegant way to model the kind of thing I want
04:31:42 <quicksilver> osfameron: I would model it explicitly rather than trying to 'hack into' the underlying lazy evaluation.
04:32:03 <quicksilver> osfameron: e.g. an explicit queue of work and well understood ways to access the currently completed jobs.
04:32:22 <osfameron> yeah
04:32:49 <osfameron> it's just on the query side where being able to use concepts like filter, map, fold, group etc. is appealing
04:33:04 <osfameron> but I guess I'd explicitly code those on whatever queue I use
04:34:05 <benmachine> roconnor: I think not, because StateT s (ReaderT r m) is useful to partition the environment into bits you modify and bits you don't
04:34:27 <aavogt> but maybe            > do t <- forkIO (do { computation `seq` putMVar v computation });  threadDelay 123; e <- tryTakeMVar v; when (isNothing e) (killThread t) -- osfameron
04:34:55 <aavogt> probably needing more forcing than seq
04:36:23 <osfameron> aavogt: interesting, ta
04:37:19 * hackagebot reactive-banana 0.3.0.0 - Small but solid library for  functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.3.0.0 (HeinrichApfelmus)
04:37:21 * hackagebot reactive-banana-wx 0.3.0.0 - Examples for the reactive-banana library, using wxHaskell.  http://hackage.haskell.org/package/reactive-banana-wx-0.3.0.0 (HeinrichApfelmus)
04:37:49 <luite> ooh reactive bananas
04:46:54 <roconnor> benmachine: ya; I understand, but I want to partition my monadic operations into those that modify the state and those that don't.
05:02:50 <quicksilver> roconnor: this is best achieved by custom classes, in my opinion.
05:03:08 <quicksilver> roconnor: classes following the general model of MonadReader/MonadState but referring specifically to your case.
05:10:43 <roconnor> quicksilver: custom datatype (newtype) in this case should do
05:11:01 <roconnor> newtypeing StateT and giving it both instances.
05:12:02 <benmachine> or you could define a function that took StateT s m a and produced ReaderT r m (a, s)
05:12:05 <benmachine> er
05:12:10 <benmachine> ReaderT s m (a,s)
05:12:12 <benmachine> and vice versa
05:12:35 <roconnor> maybe; it has extra overhead that way.
05:12:51 <roconnor> er
05:12:53 <roconnor> wait
05:13:10 <roconnor> that isn't really want I want
05:14:35 <roconnor> sorry, and first I thought you were talking about making an injection from ReaderT r m a into StateT s m a
05:18:05 <benmachine> roconnor: yeah I didn't really think about it in detail, I admit :P
05:18:13 <benmachine> it sounded like it might work ish
05:21:20 <saml> hey is forkIO good?
05:21:34 <benmachine> :t StateT . runReaderT . ap (asks (flip (,)))
05:21:35 <lambdabot> forall s (m :: * -> *) a. (Monad m) => ReaderT s m a -> StateT s m a
05:21:40 <benmachine> saml: it's brilliant.
05:22:12 <saml> http://haskell.org/haskellwiki/Simple_Servers   is this good?
05:22:30 <benmachine> saml: could you perhaps ask a more specific question?
05:22:53 <saml> i want to write a web application.. that'll work on top of haskell-platform without much dependency
05:23:08 <saml> snap is huge
05:23:38 <Clint> sounds like you don't want yesod
05:23:56 <saml> yah. yesod is huge, too
05:24:47 <aavogt> ghc is huge
05:25:11 <zark4711> saml: look at warp wai
05:25:33 <saml> yah with all those language extensions
05:25:47 <saml> there should be another compiler to make haskell better
05:26:05 <zark4711> it is minimalistic. you can send a lot of stuff from there and do some javascript stuff on the site and you can create pretty amazing things...
05:26:38 <zark4711> but it will get a lot of work. and then maybe yesod/Happstack/snap arent so huge anymore
05:27:12 <saml> i mean.. i just want a development server.. deployment would be fastcgi?
05:27:13 <zark4711> i read the Happstack tutorial after being overwhelmed by yesod. it is quite compact. a good introduction.
05:27:36 <benmachine> saml: why exactly is hugeness a problem, anyways
05:27:41 <zark4711> fastcgi: at least in germany arent many providers that offer that.
05:27:54 <benmachine> slowcgi is nice and simple
05:27:57 <benmachine> well, simple anyway
05:28:04 <zark4711> but when you get a virtual server you are free to run you haskell warp stuff anyway
05:28:23 <saml> benmachine, unnecessarily huge, i think
05:28:30 <zark4711> but sometimes this is overkill. i always....yap
05:28:35 <benmachine> saml: that doesn't really answer my question :P
05:29:07 <saml> it does answer your question.
05:29:08 <zark4711> have a look at the happstack tutorial. it was updated lately
05:29:20 <benmachine> saml: why is it a problem that it's unnecessarily huge?
05:29:28 <saml> okay i'll write in Java EE
05:29:29 <zark4711> gives you some framework.
05:29:59 <zark4711> i mean. it gives you some ideas about how it could work.
05:30:50 <benmachine> saml: btw, I believe the wiki page you mentioned talking about epoll has been implemented in GHC by now
05:30:52 <zark4711> and then maybe you think it should be smaller and you go with something else and program the stuff again that other people have written - like i often do.
05:30:57 <benmachine> not absolutely sure but I think so
05:31:16 <benmachine> saml: so GHC is probably a bit faster than it was when that page was written
05:32:11 <benmachine> yeah, GHC uses epoll instead of select nowadays
05:32:16 <saml> is epoll portable?  for example, compiles and runs on wnidows?
05:32:26 <saml> oh i see
05:32:31 <benmachine> well, GHC uses whatever's available
05:33:27 <saml> https://github.com/tibbe/event  is this part of GHC now?
05:34:43 <aavogt> saml: http://haskell.org/ghc/docs/7.0.4/html/users_guide/release-7-0-1.html
05:38:22 * benmachine updates the wiki page a bit
05:51:47 <ben> Is Scala the closest I am going to get to haskell on the jvm?
06:07:57 <k0ral> what's the purpose of the Setup.hs file for cabal ?
06:08:12 <k0ral> In all examples I see, it's made of the same two lines
06:10:45 <kowey> some projects have more advanced Setup.hs with fancy features
06:10:58 <kowey> for example, a graphical program on a Mac might use Setup.hs to create an "application bundle" for itself
06:11:31 <k0ral> any tutorial and/or sample ?
06:15:15 <kowey> specifically for the case of MacOS? http://code.haskell.org/GenI/Setup.lhs is a bit dated
06:15:28 <kowey> the new tech is to use this cabal-osx library, which I haven't gotten around to
06:15:54 <kowey> documentation for Cabal lives in http://haskell.org/cabal/users-guide/
06:16:19 <dcoutts> (yay for new shorter url)
06:16:36 <dcoutts> (hopefully new userguide rewrite coming soon...)
06:16:42 <kowey> see also http://darcs.net/Setup.lhs (yeah! no more hackage.*?)
06:17:54 <k0ral> your first link is wrong, it's Setup.hs
06:18:00 <kowey> dcoutts: maybe OxHug wants one of these? https://github.com/functionalbrighton (notice me being all pragmatic and pushing my darcs-y ways on people)
06:18:06 <tibbe> saml, yes
06:18:11 <kowey> ah yes
06:18:33 <dcoutts> kowey: you mean a repo for shared projects?
06:18:47 <saml> tibbe, thanks
06:19:13 <kowey> yeah, our little dojo explorations, talks, etc, wiki for links, reading lists
06:19:21 <dcoutts> I see, right
06:23:05 <kowey> github and assembla here have a nice feature of allowing org accounts that individuals can join
06:26:38 * hackagebot snap-core 0.5.1.1 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.5.1.1 (GregoryCollins)
06:28:35 <dainanaki> Has anyone successfully gotten Objective-C code to link against GHC?
06:29:38 * hackagebot snap-core 0.5.1.2 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.5.1.2 (GregoryCollins)
06:29:41 * hackagebot snap-server 0.5.1.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.5.1.1 (GregoryCollins)
06:34:39 * hackagebot snap 0.5.1.1 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.5.1.1 (GregoryCollins)
06:37:16 <T7D_> @:type fmap
06:37:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:37:42 <T7D_> @:k Maybe
06:37:43 <lambdabot> Maybe you meant: . ? @ ask bf do ft id pl rc v wn
06:56:30 <dmwit> :k Maybe
06:56:31 <lambdabot> * -> *
06:56:34 <dmwit> @kind Maybe
06:56:35 <lambdabot> * -> *
06:56:40 <dmwit> T7D_: ^^
07:01:00 <matthiasgorgens> what's the strict equivalent of readFile?
07:02:17 <matthiasgorgens> oh, got it myself.
07:12:58 <chylli> I want to write a busybox using haskell for studing it, is it possible ?
07:13:31 <_habnabit> Anything is possible n
07:13:41 <dmwit> ?wiki simple unix tools
07:13:41 <lambdabot> http://www.haskell.org/haskellwiki/simple_unix_tools
07:13:54 <chylli> thanks very much
07:15:58 <matthiasgorgens> _habnabit, some things are easier than others.
07:16:15 <matthiasgorgens> but yeah, busybox-like tool should be doable.
07:16:55 <tekknolagi>  what is a busybox
07:17:01 <tekknolagi> @google busybox
07:17:02 <lambdabot> http://www.busybox.net/
07:17:02 <lambdabot> Title: BusyBox
07:17:24 <tekknolagi> oh. cool!
07:17:43 <_habnabit> matthiasgorgens: That wasn't what was asked, though.
07:22:48 <matthiasgorgens> i guess that was implied.
07:25:23 * chylli feature
07:25:53 <chylli> I thought IO action is not a strongest feature of haskell.
07:29:30 <dmwit> chylli: Do you still think that?
07:32:07 <chylli> dmwit: I don't know, I'm a newbie. I think haskell is good at FUNCTIONAL problems. I don't know if unix tools will use many features of haskell like lazy calculate, monad, type system, etc
07:33:12 <dmwit> I guess I don't judge a language based on whether the problem I want to solve exercises the entire language, but instead based on whether the problem I want to solve is easily solved.
07:33:21 <Cale> chylli: I think IO actions are really quite a cool feature of Haskell.
07:33:24 <dmwit> I think Haskell makes most problems easy to solve.
07:33:40 * copumpkin agrees with dmwit 
07:33:45 <Cale> chylli: They make it a really good imperative language (better than a lot of other languages designed to be imperative)
07:34:01 <dmwit> As for "Haskell is good at FUNCTIONAL problems", I'm not too clear on the distinction between a functional problem and a non-functional one.
07:34:11 <dmwit> Solutions are functional or otherwise; problems are just problems.
07:34:22 <copumpkin> if I have a dysfunctional problem, I'll use java to solve it
07:34:53 <Cale> chylli: Because you have a really clear separation between running an IO action and just passing it along as a parameter to a function, you can easily write your own control structures without worrying about effects going off early, and programs tend to be extremely clear about the order that things happen in whenever it actually matters.
07:35:37 <quicksilver> copumpkin: ...and now you have two dysfunctional problems?
07:35:39 <Cale> (and yeah, I agree with the others, "functional" is a style of solving problems and not a type of problem.)
07:35:45 <chylli> Thanks, let me 'JUST DO IT'
07:40:43 <k0ral> I'm trying to "chmod +x" a file from data-files section in cabal package
07:41:04 <k0ral> as I understood it, I should hack Setup.hs
07:41:11 <k0ral> use hooks
07:41:35 <k0ral> I noticed the postInst hook which I guess is the right one for my need
07:42:05 <k0ral> but then, how can I know where was the data file installed ?
07:42:49 <dmwit> O_o
07:48:51 * hackagebot hakyll-contrib 0.0.0.1 - Extra modules for the hakyll website compiler  http://hackage.haskell.org/package/hakyll-contrib-0.0.0.1 (JasperVanDerJeugt)
07:50:11 <k0ral> anyone ?
07:51:27 <jaspervdj> k0ral: dist/build/autogen will generate a file called Paths_xxx.hs, which exports a getDataFileName function
07:54:55 * hackagebot hakyll-contrib 0.0.0.2 - Extra modules for the hakyll website compiler  http://hackage.haskell.org/package/hakyll-contrib-0.0.0.2 (JasperVanDerJeugt)
07:56:52 <dcoutts> k0ral: sounds like it's not a data file either then, and should not live in the $datadir
07:57:50 <dmwit> What's the right place for it, out of curiosity?
08:01:37 <chylli> is there a way to use lambdabot locally in my emacs?
08:01:53 <dmwit> ?where goa
08:01:53 <lambdabot> http://haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid
08:02:08 <dmwit> ?wiki haskell mode for emacs
08:02:08 <lambdabot> http://www.haskell.org/haskellwiki/haskell_mode_for_emacs
08:02:24 <dmwit> ?wiki haskell mode for Emacs
08:02:25 <lambdabot> http://www.haskell.org/haskellwiki/haskell_mode_for_Emacs
08:05:48 <chylli> thanks!
08:06:48 <Yrogirg> a bit of offtopic --- does anybody know a free usenet server to get messages from the last 20 years?
08:07:54 <monochrom> groups.google.com has much of it
08:08:28 <monochrom> it started out by buying another website specializing in archiving usenet
08:08:50 <Yrogirg> yes, but there is no spam filtering in their web interface
08:09:11 <k0ral> dcoutts: it's a shell script
08:09:27 <k0ral> dcoutts: where else could it be put ?
08:16:28 <matthiasgorgens> !lambdabot Bool -> a -> a -> a
08:16:59 <matthiasgorgens> ok, that's not how you use that bot.
08:17:09 <dmwit> ?hoogle Bool -> a -> a -> a
08:17:10 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
08:17:10 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
08:17:10 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
08:17:21 <dmwit> I don't think a function-level if exists, sadly.
08:17:25 <dmwit> But it's easy to write.
08:17:25 <matthiasgorgens> actually, I just want `if' as a function.
08:17:28 <matthiasgorgens> yes.
08:17:35 <matthiasgorgens> and actually I want a monadic version.
08:17:41 <k0ral> hmm, juste noticed cabal install didn't even care about Setup.hs O_o
08:17:42 <dmwit> bool True t f = t; bool False t f = f
08:17:48 <k0ral> just*
08:17:49 <dmwit> :t when
08:17:50 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
08:18:05 <matthiasgorgens> I want type:
08:18:47 <matthiasgorgens> oh, no explicit monadic support needed at all.
08:19:00 <matthiasgorgens> Bool -> a -> a -> is enough to replace
08:19:05 <c_wraith> :t if'
08:19:06 <lambdabot> Not in scope: `if''
08:19:08 <dmwit> :t let bool b t f = if b then t else f; boolM mb mt mf = mb >>= \b -> bool b mt mf in boolM
08:19:09 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> m b -> m b -> m b
08:19:30 <matthiasgorgens> test >>= \x -> if x then do_this else do_that
08:19:34 <dmwit> ?pl \b t f -> if b then t else f
08:19:34 <lambdabot> if'
08:19:41 <dmwit> ...but if' doesn't exist outside of ?pl. =)
08:19:47 <matthiasgorgens> with test >>= flip3 if' do_this do_that
08:19:55 <matthiasgorgens> (where flip3 does the obvious thing.)
08:20:17 <matthiasgorgens> (so actually taking the boolean as the last parameter would be best.
08:20:41 <dmwit> matthiasgorgens: You might as well write boolM (above) if that's the function you really want.
08:20:57 <dmwit> Call it ifM if you prefer.
08:22:32 <dmwit> ?pl \b t f -> maybe f (const t) (guard b)
08:22:32 <lambdabot> flip (flip . flip maybe . const) . guard
08:22:52 <dmwit> ?pl \t f b -> maybe f (const t) (guard b)
08:22:53 <lambdabot> flip flip guard . ((.) .) . flip maybe . const
08:22:57 <dmwit> So simple. =P
08:25:10 <samek> hello, i have a question.. why are compiled haskell programs so big? for comparison hello world in C binary is 7.7K but in Haskell it's 695K? why is that?
08:26:02 <monochrom> it's just ghc, not every haskell compiler
08:26:16 <thoughtpolice> samek: GHC has to link in a lot of other object code (from it's supporting standard libraries) just for the hello world case. by default GHC also does static linking i believe
08:26:18 <monochrom> it statically link haskell libs
08:26:23 <thoughtpolice> you can cut down the binary size considerably with dynamic linking
08:26:56 <matthiasgorgens> for example you also get the whole RTS machinery that supports those "+RTS something" command line arguments.
08:27:04 <matthiasgorgens> that must be quite a few kB.
08:27:09 <thoughtpolice> (on my x86_64/linux machine, "hello world" when dynamically linked is about 12kb)
08:28:11 <matthiasgorgens> dmwit, i guess I stick to points for that function.
08:28:17 <thoughtpolice> matthiasgorgens: the RTS is quite large, yes, but you always get that. -rtsopts is only a link time flag, and probably trivially small in comparison to the rest of the RTS (ghc's rts is like 40k C code I think)
08:28:27 <thoughtpolice> *40k LOC
08:28:43 <monochrom> ghc's rts does green threads for you
08:28:43 <samek> hm yes my first thought was static linking to, but when i ran ldd i was confused, because it showed me serveral libs
08:28:44 <matthiasgorgens> yes, the option parsing itself is quite small.
08:28:49 <monochrom> c's rts does nothing
08:28:50 <matthiasgorgens> i meant the machinery to use the different options.
08:29:05 <thoughtpolice> oh yeah, the RTS is not trivial by any means :)
08:29:07 <monochrom> ghc still links c libs dynamically
08:29:40 <monochrom> notice how ldd's output contains no haskell libs
08:29:47 <thoughtpolice> samek: yeah, it'll link to libc etc dynamically - the "dynamic linking" portion only affects actual haskell libraries
08:29:51 <samek> oh yes, that's true :)
08:30:04 <thoughtpolice> samek: so if you compile using 'ghc -dynamic hi.hs' and then do 'ldd', you'll get a lot more output
08:30:07 <monochrom> (notice how it contains many more libs if you "ghc -dynamic"ed)
08:31:06 <Clint> what do dynamic haskell lib filenames look like?
08:31:30 <thoughtpolice> like regular shared objects/dlls on any OS? what do you mean
08:31:51 <samek> i understand now, thanks you all for your answers
08:31:52 <monochrom> libHSrts-ghc7.0.3.so => /usr/local/haskell-platform-2011.2.0.1/lib/ghc-7.0.3/libHSrts-ghc7.0.3.so (0x00840000)
08:31:57 <thoughtpolice> example: RTS dynamic shared object is something like "libHSrts-ghc7.0.4.so"
08:32:04 <monochrom> that's one of ldd's output lines if you "ghc -dynamic"
08:32:09 <Clint> aha
08:32:20 <thoughtpolice> monochrom: we need to quit copying each other
08:32:35 <thoughtpolice> :P
08:33:06 <monochrom> redundant array of cheap answerers
08:33:06 * hackagebot hbro 0.5.2 - A suckless minimal KISSy browser  http://hackage.haskell.org/package/hbro-0.5.2 (koral)
08:34:48 <monochrom> god, now we have a web browser in haskell too
08:35:07 <acowley> I thought it was a kissy browser
08:35:15 <chylli> hoogle: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory
08:35:26 <chylli> which package use libgmp.so.3 ?
08:35:35 <dmwit> Everything uses libgmp.
08:35:36 <thoughtpolice> when will hbro be on halvm? and when will halvm be on the haskell cloud? inquiring minds want to know
08:35:39 <acowley> base I think
08:35:40 <dmwit> Integer is gmp-backed.
08:35:44 <monochrom> every ghc-generated program. for Integer.
08:35:58 <chylli> I don't know why they linked to so.3
08:36:02 <quicksilver> monochrom: it's not the first haskell web browser.
08:36:06 <chylli> why not use the latest libgmp.so
08:36:19 <quicksilver> chylli: because that is how dynamic linking works.
08:36:37 <quicksilver> the .so.3 symlink points to the most recent version which supports that particular ABI.
08:37:02 <chylli> can I ln -sf  it by hand ?
08:37:08 <Clint> if you like breakage
08:37:12 <acowley> you can try
08:37:13 <monochrom> you can try. may crash.
08:37:27 <quicksilver> probably better to understand and solve the problem which means it is missing.
08:37:47 <chylli> I don't know where I can start
08:37:51 <aspect> wait, you have a libgmp.so but no libgmp.so.3?
08:38:00 <chylli> yes
08:38:01 <acowley> symlink tourniquets do work sometimes
08:38:02 <Clint> rebuild against libgmp.so.10
08:38:04 <aspect> usually the former will be a symlink to the latter
08:38:23 <quicksilver> aspect: no, they should both be symlinks to a real version.
08:38:23 <monochrom> quite frankly on ubuntu the only gmp is gmp 3. (and I suspect many other linuxes too)
08:38:24 <quicksilver> lrwxrwxrwx 1 root root     15 Mar 20  2010 /usr/lib/libgmp.so -> libgmp.so.3.4.2
08:38:26 <aspect> what platform are you on?
08:38:27 <quicksilver> lrwxrwxrwx 1 root root     15 Mar 20  2010 /usr/lib/libgmp.so.3 -> libgmp.so.3.4.2
08:38:30 <quicksilver> -rw-r--r-- 1 root root 273608 Apr  9  2008 /usr/lib/libgmp.so.3.4.2
08:38:37 <benmachine> chylli: are you on archlinux by any chance
08:38:40 <chylli> I'm using archlinux
08:38:43 <benmachine> aha
08:38:44 <aspect> quicksilver: you're right - net effect is the same though :)
08:38:46 <benmachine> I had this problem
08:38:57 <aspect> hm. remind me not to use arch :)
08:38:57 <benmachine> you need to rebuild those executables unfortunately
08:39:08 <benmachine> aspect: it has its ups and downs
08:39:31 <chylli> rebuild which ? reinstall ghc ?
08:39:32 <aspect> benmachine: breaking /usr/lib sounds like a big down :)
08:39:52 <benmachine> chylli: no, hoogle
08:39:57 <benmachine> wait
08:40:02 <benmachine> when do you get this message?
08:40:14 <chylli> benmachine: in ghci
08:40:18 <chylli> benmachine: goa
08:40:56 <benmachine> goa?
08:41:13 <Clint> how does hbro depend on hbro
08:41:22 <chylli> yes, I want to use lambdabot in ghci
08:41:58 <chylli> ?where GOA
08:41:58 <lambdabot> http://haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid
08:42:06 <monochrom> it has an executable and a lib. the executable needs the lib
08:43:14 <benmachine> chylli: you need to (re)install the hoogle binary, I think
08:43:17 <Clint> ah
08:44:54 <chylli> resolved. There is an old hoogle in /usr/local/bin, I deleted it.
08:45:07 <monochrom> ha ha
09:01:08 <chylli> when I use hoogle in emacs inferior ghci, I got an error:
09:01:28 <chylli> GOA> :hoogle maybe
09:01:29 <chylli> hoogle maybe
09:01:29 <chylli> A Hoogle error occurred.
09:01:42 <chylli> but it is ok under my terminal ghci
09:09:30 <rudyl313> I currently have a project where all my modules (e.g. Module1) have matching filenames and are all in the same directory... how do I create nested namespaces like Nest1.Nest2.Module1 like many of the common libraries (e.g. Data.List.Split) ... do I put them in directories liek Nest1/Nest2/Module1.hs ?
09:11:15 * hackagebot hack2-handler-mongrel2-http 2011.6.22 - Hack2 Mongrel2 HTTP handler  http://hackage.haskell.org/package/hack2-handler-mongrel2-http-2011.6.22 (JinjingWang)
09:11:47 <rudyl313> also whats the general style on when to use record syntax and when not to? I have a type constructor that takes two arguments.. is it bad form to use record syntax for a type like that or not?
09:13:12 <adnam> rudyl313: yes put them in dirs
09:13:36 <sm> hack is back
09:13:52 <rudyl313> adnam: do I type "module Nest1.Nest2.Module1 where ... " or still "module Module1 where ..." ?
09:14:01 <mwc> rudyl313: when ther labels make sense as projection functions
09:14:12 <mwc> rudyl313: the former
09:14:58 <rudyl313> mwc: adnam: thanks
09:17:46 <mwc> rudyl313: record update syntax is handy too, so if you make lots of minor changes to a value, foo { bar = baz } is nicer than pattern matchng half a dozen fields out of foo
09:18:24 <parcs> mwc: do you think foo { bar = bar foo + 1 } is nice?
09:18:36 <acowley> Record update syntax is so frustrating, though.
09:18:41 <rudyl313> mwc: yeah I typically write "getters" and "setters" for types of non-record syntax anyway, so it kind of does the work for you
09:19:53 <acowley> parcs: it's nice if foo has many fields
09:20:01 <mwc> parcs: compared to: let Foo bar baz quo _ quux = foo in Foo bar baz quo blah quux, yeah, I do
09:20:06 <rudyl313> mwc: I just felt bad about using it for a type with only 2 arguments.. like there was some rule that they need to have more than a certain number of args
09:20:36 <mwc> rudyl313: using it with newtypes (one field) is common in monad transformers
09:20:54 <mwc> newtype State s a = State { runState :: s -> (s,a) }
09:21:18 <rudyl313> mwc: I have seen that.. but I thought that might be a corner case for when you're using newtype specifically
09:21:19 <mwc> that just saves you writing on the next line: runState (State f) = f
09:23:35 <estherilla87> ola
09:25:11 <gwern> C leads to security bugs? film at 11: http://www.openwall.com/lists/oss-security/2011/06/20/2
09:25:31 <Nimatek> Bad programming leads to security bugs.
09:25:36 <mwc> programmers are the leading cause of security bugs. We've all got cells at gitmo waiting for us
09:25:44 <Nimatek> Which is easier to do in C, of course.
09:28:45 <acowley> I blame the users
09:29:50 <yrlnry> Yeah, none of those security errors would have caused any problems if those damn users didn't keep running the programs.
09:30:14 <yrlnry> That's why I like Haskell.  You construct your computation as a monadic value, and then you don't actually have to execute it.
09:30:40 <djahandarie> That's why I like Agda. No one runs that regardless of what you do.
09:31:17 <yrlnry> I was hoping someone would say that.
09:31:29 <monochrom> Dijkstra's guarded command language is never executed too
09:31:57 <yrlnry> Did you see Andrej Bauer's post today about a program that witnesses the nonexistence of injections from N^N to N?
09:38:03 <thoughtpolice> superclass equalities are in! wooooo
09:38:19 <thoughtpolice> well, superclass equality constraints, that is
09:39:02 <benmachine> again? :P
09:39:09 <byorgey> huzzah!
09:39:27 <byorgey> benmachine: what do you mean, "again"?
09:39:39 <benmachine> byorgey: didn't they get put in at one point adn then taken out again because they didn't work
09:39:48 <benmachine> or am I making stuff up
09:42:37 <kmc> acowley, you sent me some ByteString <-> Vector code the other day, right?
09:43:48 <thoughtpolice> benmachine: they were never implemented. GHC could parse them, but it would always bail with "superclass equality constraints are not implemented"
09:44:22 <acowley> kmc: yes
09:44:41 <kmc> why did you go through CStringLen?
09:45:50 <acowley> I suppose the length is used in some of the variants?
09:46:52 <kmc> you can convert a ByteString to a (ForeignPtr, offset, len) tuple directly
09:47:01 <kmc> not really "convert" because that's what it already is internally
09:47:14 <stephanmg> hi.
09:47:19 <kmc> and that's also what a Storable vector is, except that the offset and length are in multiples of the item size
09:47:46 <acowley> Yes, but that unpacking is exactly what the unsafeUseAsCStringLen functions do, isn't it?
09:48:13 <kmc> i don't know
09:48:17 <kmc> it's what toForeignPtr does
09:48:32 <kmc> without requiring you to use IO
09:48:48 <stephanmg> just stumbled over "learn you a haskell"  superb book :)
09:49:23 <acowley> where is that defined?
09:49:28 <acowley> toForeignPtr
09:50:17 <acowley> oh, you're using Data.ByteString.Internal
09:50:25 <acowley> I was sticking to the public API
09:50:27 <kmc> Data.ByteString.Internal
09:50:32 <kmc> which doesn't have haddock docs
09:50:39 <kmc> :/
09:50:43 <kmc> (it does in old versions like 0.9)
09:50:56 <kmc> in practice i think this "internal" API is used by lots of other packages
09:51:03 <kmc> if you want to use ByteStrings with a C library it's very useful
09:51:04 <acowley> right, I figured the public API was recommended and that anything in Internal could legitimately be mucked with
09:51:25 <acowley> I agree, but I didn't notice anything particularly awful about the CStringLen business
09:51:46 <kmc> shrug
09:51:49 <kmc> you have to use unsafePerformIO
09:51:52 <kmc> that's not a big deal though
09:52:16 <acowley> That's a fair point.
09:52:53 <kmc> also i don't think the ForeignPtr-based zero-copy conversions need to be labeled "unsafe"
09:53:08 <kmc> since both sides require and provide the same assumptions about that buffer
09:53:15 <kmc> except, i still don't know about this alignment issue
09:53:46 <kmc> i wonder if they use the same finalizers on that ForeignPtr
09:53:50 <kmc> that's another potential issue
09:53:50 <acowley> the unsafe prefix is to distinguish them from the ones that do a copy
09:53:57 <acowley> right
09:54:01 <acowley> I ran into that
09:54:13 <kmc> right, but i think the zero-copy versions can also be "safe"
09:54:23 <kmc> also if you do want a copy, you can just compose with BS.copy
09:54:40 <acowley> Probably, but the finalizer business had me spooked
09:55:10 <kmc> yeah.  to some degree it's a question of whether you guarantee safety for future implementations of these libs, which might diverge
09:55:57 <acowley> I honestly didn't like the whole thing. There's so much crazy ByteString code out there peppered with unsafe* calls, and not a whole lot of documentation.
09:57:19 <kmc> yeah
09:58:50 <acowley> oh, one thing about using BS.copy is that I might not want to copy the whole thing
09:58:56 <acowley> it looks like I'm doing it wrong in that code
09:59:14 <acowley> so, as written, I should have used BS.copy
10:00:33 <acowley> hm. Now you've really got me thinking about using BS.Internal
10:01:25 <acowley> I should also start using inlinePerformIO more
10:01:32 <acowley> just to raise the stakes
10:04:12 <thoughtpolice> inlinePerformIO usage? better shut down madagascar
10:04:26 <thoughtpolice> acowley: i ran into this too when doing some bindings, i inevitably ended up looking at how things like network-bytestring did it
10:04:37 <kmc> acowley, haha
10:05:07 <acowley> My favorite part of looking into it was how the *one* note in inlinePerformIO is to not allocate in it, and I first encountered use of it with a block that allocates
10:05:22 <kmc> http://haskell.org/pipermail/haskell-cafe/2007-March/023592.html
10:05:23 <kmc> hehe
10:05:46 <acowley> thoughtpolice: did you discover any useful patterns that don't amount to putthing on shades and saying, "Trust me"?
10:06:20 <kmc> "While ghc will try not to duplicate or common up
10:06:20 <kmc> different uses of unsafePerformIO, we aggressively inline
10:06:20 <kmc> inlinePerformIO. So you can really only use it where the IO content is
10:06:20 <kmc> really properly pure, like reading from an immutable memory buffer"
10:07:06 <acowley> kmc: Yeah, that's the thing I read
10:07:36 <kmc> in some other code i'm using it for that
10:07:43 <thoughtpolice> acowley: not really. :x more like aladdin to jasmine - "do you trust me?"
10:07:48 <acowley> I guess once you have "-- warning: this is a tad hardcore" it's all okay?
10:08:06 <kmc> i have a ByteString with some Word32 in machine byte order, and i want to read them with minimal overhead / effort
10:08:08 <zygoloid> inlinePerformIO: do not allocate in it, unless your first or last name starts with S?
10:08:16 <kmc> so I used inlinePerformIO with peek
10:08:21 <kmc> i think that's acceptable
10:08:26 <acowley> I think so, too
10:08:34 <kmc> sketched out by other uses, though
10:08:46 <thoughtpolice> acowley: that's also a rather hilarious comment, i must admit.
10:09:46 <Tomsik> :t inlinePerformIO
10:09:48 <lambdabot> Not in scope: `inlinePerformIO'
10:09:54 <Tomsik> What is this about
10:10:04 <kmc> it's like unsafePerformIO, but more so
10:10:08 <acowley> Tomsik: it's in Data.ByteString.Internal
10:10:12 <Tomsik> More unsafe?
10:10:14 <kmc> yep
10:10:16 <acowley> which is hard to find
10:10:23 <kmc> GHC will try not to inline unsafePerformIO but it aggressively inlines inlinePerformIO
10:10:36 <Tomsik> Sounds like a good, dedicated use
10:10:43 <acowley> why do they say "aggressively"?
10:10:49 <Tomsik> except unsafePerformIO being horrid in the first place
10:10:53 <kmc> maybe it has an {-# INLINE #-} directive
10:10:56 <acowley> it does
10:11:11 <kmc> stuff in unsafePerformIO is supposed to be "externally pure" whereas stuff inside inlinePerformIO has to be really pure in implementation or all hell will break loose
10:11:33 <Tomsik> Why not ST?
10:11:41 <acowley> But why not just say inlined? The extra word makes it sound special, and we're already in territory full of weird compiler-specific under-specified nonsense.
10:11:57 <acowley> unsafePerformIO is really important
10:11:58 <thoughtpolice> ah, unsafePerformIO. you give way to so many wonderful things with your magic, like unsafeCoerce#
10:12:09 <kmc> Tomsik, inlinePerformIO is used to implement ByteString
10:12:16 <thoughtpolice> i thought that one was rather interesting to figure out after I found it from lennart
10:12:19 <kmc> people would be unhappy if they could only manipulate ByteStrings inside ST
10:12:26 <kmc> thoughtpolice, yeah, polymorphic references are bad news
10:12:35 <thoughtpolice> word
10:12:37 <kmc> i think one could theoretically implement an unsafePerformIO which does not have this problme
10:12:42 <kmc> by forcing it to have a monomorphic type whenever used
10:12:43 <acowley> kmc: I've found that I haven't needed inlinePerformIO as most of my pure FFI calls are fairly chunky
10:12:49 <zygoloid> people would be especially unhappy if they could only manipulate (ByteString s) inside (ST s)
10:12:50 <kmc> i don't know if there's a way to do that without compiler hacking
10:12:51 <thoughtpolice> kmc: JHC could accept the same code, but it would generate much different results than what GHC would
10:13:04 <Tomsik> Can'
10:13:14 <thoughtpolice> kmc: i can't exactly remember the details though, but JHC monomorphized things to where it just resulted in a failure, not a "kinda sorta maybe weird memory corruption that segfaults a year later"
10:13:19 <Tomsik> Can't you perform ST inside ByteString and just use runST?
10:13:22 <kmc> cool
10:13:54 <zygoloid> Tomsik: not without circumventing the type system
10:14:00 <kmc> Tomsik, no, because the ByteString you pass back to the user is going to have that 's' parameter buried within
10:14:18 <kmc> i.e. data ByteString s = STUArray s Int Word8
10:14:41 <kmc> you can circumvent the type system, but unsafePerformST is exactly as sketchy as unsafePerformIO
10:14:49 <kmc> indeed would generate identical code under GHC
10:15:03 <Eduard_Munteanu> Mm... you'd just have a frozen Bytestring variant.
10:15:11 <Tomsik> I think I'm missing something important about ByteStrings
10:15:24 <acowley> just define "tadHardcore = unsafeInlineIO" somewhere in your personal Prelude and Haskell IO gets much more awesome
10:15:24 <Eduard_Munteanu> Just like with STArray vs Array
10:15:26 <Tomsik> data ByteString = UArray Int Word8, what's wrong with that?
10:15:36 <Tomsik> Can't you just convert it there and back again?
10:15:39 <kmc> Tomsik, that's fine, just less efficient than the existing ByteString library
10:16:05 <kmc> for one you can't slice them in O(1)
10:16:12 * benmachine vaguely wonders if some of the Storable stuff could go in ST
10:16:13 <Tomsik> Hmm, I thought there's an ST function that basically freezes/thaws in place
10:16:17 <kmc> though that could be added to the UArray API
10:16:24 <kmc> two ByteStrings can share overlapping regions of byte buffer
10:16:45 <kmc> this is one reason you have to be careful if you're messing with the ForeignPtr inside
10:18:03 <NiCROS> is there a reason download speeds are so slow?
10:18:12 <acowley> type checking
10:18:21 <acowley> downloads from haskell.org?
10:18:39 <NiCROS> yes
10:18:51 <thoughtpolice> haskell.org is pretty fast. i can get a ~100mb binary distro of GHC 7.0.4 off there in like 5min ETA
10:18:55 <acowley> They've been slow for quite some time, many have complained, few have suggested a solution.
10:18:58 <thoughtpolice> i know this off hand because I tested it yesterday :P
10:19:09 <acowley> thoughtpolice: I didn't try yesterday, but I've had slow GHC binary downloads for months
10:19:34 <NiCROS> I'm getting < 10 K/s
10:19:44 <thoughtpolice> christ, right now it's something like 2mb/sec for me
10:19:57 <thoughtpolice> of course, i'm at work right now. at home i'm sure it'd be much faster, but that's a limiting factor on my end
10:20:02 <thoughtpolice> er, much slower
10:20:13 <acowley> Hey, it's fast for me, too
10:20:24 <thoughtpolice> yeah, i just completely redownloaded 7.0.4
10:20:28 <thoughtpolice> in like 1min
10:20:40 <acowley> are you taunting us?
10:20:48 <acowley> :)
10:20:49 <thoughtpolice> YEP
10:20:51 <thoughtpolice> :P
10:20:52 <NiCROS> i'm trying to download http://www.haskell.org/ghc/dist/7.0.4/ghc-7.0.4-x86_64-unknown-linux.tar.bz2 and it's going to take 4 hours.
10:21:32 <thoughtpolice> that's what I just downloaded! are you sure your network isn't saturated? just haskell.org? it could likely be a problem depending on where you are (someone reported similar things yesterday)
10:21:39 <acowley> NiCROS: I don't know what's up. I've had slow downloads from home and work for months, but right now I'm pulling a binary at a good clip but I'm on the road now.
10:21:43 <thoughtpolice> (which is why i checked)
10:23:01 <augur> anyone have suggestions for absolutely crucial PLT/etc stuff that _must_ be taught in a quick and dirty intro?
10:23:30 <acowley> augur: HOFs
10:23:32 <NiCROS> I can download from other sites at > 5 M/s
10:23:36 <augur> acowley: hofs?
10:23:50 <thoughtpolice> augur: target audience being? existing programmers who are interested in PLT?
10:23:54 <acowley> augur: higher order functions
10:24:01 <kmc> is this intro to PLT or intro to FP?
10:24:04 <NiCROS> need mirrors !!!
10:24:11 <augur> kmc: a little but of both
10:24:14 <acowley> augur: maps and folds that abstract traversal
10:24:38 <augur> thoughtpolice: target is people who arent necessarily programmers but who want to both understand how to program and understand some important conceptual things
10:24:39 <kmc> untyped λ calc, show nontermination, simply-typed λ calc, prove normalization
10:24:50 <thoughtpolice> NiCROS: yeah, maybe we should think of that soon. :( i do have a server that i probably wouldn't mind putting up as a mirror...
10:25:16 <augur> kmc: eh. i was thinking less hardcore stuff than that. i think theyd just accept that it normalizes if i said so, and they wouldnt care why.
10:25:20 <thoughtpolice> NiCROS: but you're not the only person to report this and as I said it seems to vary. sry there's no fix atm :(
10:25:21 <NiCROS> I can provide server space as well.
10:25:22 <kmc> augur, :(
10:25:32 <augur> i was thinking more programming stuff, not stuff that hardcore theoretical
10:25:44 <augur> acowley's maps and folds are definitely on my list of things
10:26:12 <acowley> talking about the types of those things can be helpful, especially as it provides a good example of polymorphism
10:26:13 <kmc> augur, then i think you're teaching FP, not PLT, which is fine
10:26:25 <acowley> kmc: this is motivating PLT
10:26:29 <acowley> not explicating it
10:26:54 <augur> well, i'd like to teach some PLT stuff, but not necessarily strong normalization properties and stuff :P
10:26:59 <thoughtpolice> i think HOFs and things like RT are good to focus on. the idea that you can just "replace instances of the left hand side with the right hand side" like in algebra is valid, etc
10:27:10 <acowley> yeah
10:27:11 <tswett> "Give an example of a collection of disjoint closed sets which is not countable."  I really want to answer that question with "map return \mathbb{R}^n"
10:27:11 <thoughtpolice> of course, you require a language that is RT for this to really hold :P
10:27:32 <augur> RT?
10:27:37 <thoughtpolice> referential transparency
10:27:38 <acowley> referential transparency
10:27:40 <augur> oh yes
10:27:40 <thoughtpolice> shorthand, sorry :P
10:27:56 <acowley> the mainstream calls that retweeting
10:27:58 <acowley> same thing
10:28:05 <thoughtpolice> bwahahaha
10:28:12 <augur> im not used to seeing that in an acronym
10:28:41 <acowley> No one is. That's how you pick out the people who already know a little PLT!
10:28:59 <augur> :P
10:29:52 <xkb> wow, the new github app for mac is pretty cool
10:30:03 <kmc> what does it do that the website doesn't?
10:30:05 <kmc> we were just wondering that
10:30:07 <xkb> nothing
10:30:10 <xkb> :P
10:30:17 <xkb> works offline
10:30:23 <xkb> without sync obviously
10:31:03 <xkb> shows open commits etc, lets you sync your stuff
10:31:16 <kmc> open commits?
10:31:23 <xkb> that arent pushed
10:31:45 <xkb> gives an overview of all repos on your machine
10:31:54 <Eduard_Munteanu> tswett: use comprehensions :P
10:32:04 <Eduard_Munteanu> That looks mathy.
10:32:54 <Eduard_Munteanu> RT usually stands for "realtime" where I see it.
10:33:39 <acowley> Realtime referentially transparent retweets. Got it.
10:34:21 <acowley> What's happening? "I'm tweeting."
10:34:26 <thoughtpolice> twitter's already realtime bro
10:34:28 <thoughtpolice> REDUNDANT
10:34:30 * hackagebot couch-hs 0.1.1 - A CouchDB view server for Haskell.  http://hackage.haskell.org/package/couch-hs-0.1.1 (PeterSagerson)
10:34:57 <Nimatek> There should be a twitter in the twitter, so you can tweet about yourself tweeting.
10:36:15 <acowley> I'll RT that
10:51:41 <noob> hi
10:52:11 <noob> how can 12 or 15 bit numbers be represented in Haskell ?
10:52:11 <rudyl313> hi noob
10:52:25 <noob> hi rudyl313
10:53:34 <rudyl313> noob: why specifically 12 or 15 bit?
10:53:44 <rudyl313> noob: by numbers you mean integer?
10:54:02 <yrlnry> Maybe he's programming Haskell on a PDP-8.
10:54:06 <acowley> Make a newtype around an Int, define a Num instances that masks unwanted bits
10:54:33 * hackagebot aeson 0.3.2.8 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.3.2.8 (BryanOSullivan)
10:54:55 <dmwit> I'd probably wrap Word16 or Int16 instead.
10:55:03 <noob> rudyl313: yes integers,  i need to model a particular image processing hardware which works with 12 bit values, and some other internal blocks are 15 and 18 bits
10:55:04 <acowley> that would be smarter
10:55:43 <rudyl313> acowley: you'd probably be need to be careful about overflow
10:56:08 <noob> acowley: could you post or point me to a simple example please?
10:56:12 <acowley> That's right. Some thought should be given to overflow.
10:56:31 <acfoltzer> noob: you might want to try out Cryptol, which is designed to model bit-level algorithms http://corp.galois.com/cryptol/
10:56:38 <rudyl313> noob: I would define a new data type that contains an Int ... make it a member of the Num typeclass... implement the arithmetic operations as modulus 2^12 operations
10:57:06 <acowley> noob: newtype Word12 = Word12 { un12::Word16 }
10:57:24 <acowley> noob: instance Num Word12 where ....
10:57:39 <acowley> fill in the operations to behave as you want
10:58:11 <noob> rudyl313:  i would end up having to create types for each bitwidth used in the model won't i?
10:59:14 <noob> also related question.. is it possible to create wider numbers on the fly.. so for example, if i prepend an extra bit and make it 13 bits wide..
10:59:21 <rudyl313> noob: you just need the internal type of the new type to have more bits than 12 or 15 ... then if you implement all the math as mod 2^12 or mod 2^15... it'll behave exactly like 12 or 15-bit numbers
10:59:39 <rudyl313> noob: you'll need to create a separate type for each
10:59:57 <benmachine> well, you said you wanted a separate type for each, so yes
11:00:04 <noob> actually scratch the last q, i should probably use a temp wide enough
11:00:34 * hackagebot randproc 0.1 -   http://hackage.haskell.org/package/randproc-0.1 (DavidBanas)
11:00:36 <acfoltzer> noob: it sounds like it might be worth looking into a language designed for hardware, depending on what your eventual goal is
11:00:51 <scree> noob: so, you could play around a bit to avoid code duplication
11:00:57 <rudyl313> noob: actually I guess you could go --- data Wordx  = Wordx Int Int ... where the first argument to the value constructor is the number of bits and the second is the wrapped value
11:00:58 <benmachine> it's theoretically possible to have a single type which is parametrised by the bitwidth, but it's probably more trouble than it's worth
11:01:25 <rudyl313> noob: then you could define (=), (+), etc. in terms of one of the arguments
11:01:28 <benmachine> or I suppose you could put the bitwidth in the value, yes, although in that case you lose the benefit of statically checking they're the same
11:01:38 <benmachine> rudyl313: not (=) :P
11:01:53 <dino-> Well, this is quite handy: fmap fst . listToMaybe . reads
11:02:12 <rudyl313> noob: (+) (Wordx bits x) (Wordx _ y) = mod (2 ^ bits) (x + y)
11:02:18 <rudyl313> noob: something like that?
11:02:21 <c_wraith> dino-: that throws out incomplete parses
11:02:26 <dino-> :t fmap fst . Data.Maybe.listToMaybe . reads
11:02:27 <lambdabot> forall a. (Read a) => String -> Maybe a
11:02:32 <c_wraith> > reads "123foo" :: Int
11:02:32 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
11:02:33 <lambdabot>         against inferred type ...
11:02:43 <c_wraith> > reads "123foo" :: [(Int, String)]
11:02:43 <lambdabot>   [(123,"foo")]
11:02:49 <rudyl313> benmachine: why not the example given above?
11:02:50 <c_wraith> do you really want to accept that?
11:03:06 <c_wraith> err, it *accepts* incomplete parses, I mean.
11:03:10 <rudyl313> benmachine: what if the wrapped value were a tuple of the bits and internal value?
11:03:15 <dino-> c_wraith: I understand what you're saying. Depends on the application.
11:03:33 <noob> acfoltzer: :) i did look into HDL options but each has its own learning curve, and some are proprietary and need a special eval licence !!
11:04:03 <dino-> Maybe a variation that evaluates to Nothing if that right side of the tuple isn't empty too.
11:04:09 <dino-> Would be saner.
11:04:15 <benmachine> rudyl313: I just meant you can't define (=) because it's not an operator
11:04:55 <monochrom> yeah, define (==) instead
11:05:22 <c_wraith> what version of GHC is the type-level natural extension going into?
11:05:36 <c_wraith> Is it confirmed for 7.2, or is more likely to slip to 7.4?
11:06:26 <benmachine> rudyl313: the tuple of bits and value thing is fine except that if you do it in the type then it's guaranteed to be the same in the arguments of + which is nice
11:06:35 <boon> hi, i was noob a minute ago. webchat got disconnected
11:07:09 <Eduard_Munteanu> Heh.
11:09:18 <dylukes> I tried to get some help last night but dialup went out on me...
11:09:24 <dylukes> any thoughts on how I might improve this?
11:09:26 <dylukes> http://hpaste.org/48146
11:09:31 <boon> benmachine:  so some thing like (+) Word{ val:5 , width:3 } Word{ val:15, width:4} :: Word{width:3 } etc..  might make sense..  but the required return type, parameterised by the return width should be specifiable
11:09:34 <c_wraith> Looks like the extension has been delayed until 7.4
11:09:37 <dylukes> A few things
11:09:49 <dylukes> 1) Nat a => Show a
11:09:55 <benmachine> boon: you can't really use (+) then
11:10:03 <dylukes> 2) Using Suc contexts instead of (S a) for matching.
11:10:10 <acowley> noob left right before I finished sketching a newtyped integer with type-encoded bit length and saturating arithmetic :(
11:10:14 <benmachine> boon: you could define your own addition functions that let you set that
11:10:17 <dylukes> 3) The Vec stuff at the bottom that doesn't work...
11:10:37 <boon> acowley: i was noob before webchat quit on me
11:10:50 <acowley> ah!
11:11:03 <acowley> I don't think I would use this code as is, btw
11:11:37 <hpaste> acowley pasted “bitnums” at http://hpaste.org/48152
11:14:25 <boon> acowley: thanks for the example, i will fudge with it a bit more.. i have one related question though..  if instead of using min ( x, y) it is possible to specify the width to use as a return type
11:14:30 <parcs> hmm
11:14:31 <dylukes> I wish someone could help me TT^TT
11:14:48 <boon> similar to how reads can take a type to read the string into
11:14:55 <dylukes> parcs: you're a cool guy, want to help me with my type level nat and index vec implementation?
11:15:02 <boon> > read "123" ::Int
11:15:02 <lambdabot>   123
11:15:10 <boon> > read "123" :: Float
11:15:11 <lambdabot>   123.0
11:15:18 <dylukes> I always wondered, can that be done via fundeps?
11:15:33 <dylukes> or is it just matching/magic
11:15:50 <dylukes> Oh wait.
11:15:56 <dylukes> :t read
11:15:57 <lambdabot> forall a. (Read a) => String -> a
11:16:03 <dylukes> >_>
11:16:32 <boon> benmachine:  why is that?
11:16:54 <benmachine> boon: just because the interface of (+) doesn't let you specify additional information about the output
11:16:57 <benmachine> where would you put it?
11:17:09 <dylukes> No one wants to help me :(
11:17:09 <boon> well i guess i understand that the class Num does not allow (+) to takeon .. :) yes
11:17:17 <dylukes> And here I thought this type level nat thing was pretty neat.
11:17:37 <dylukes> I used type classes to define "functions" D:
11:17:44 <boon> but i was hoping  that it would be possible to "cheat" it some how
11:17:44 <dylukes> I don't know why it works but it does!
11:17:56 <parcs> dylukes: what exactly do you need help with?
11:18:13 <dylukes> well, a few issues with my implementation
11:18:25 <dylukes> firstly, repeat and append a the end there.
11:18:43 <dylukes> in the case of repeat, the type checker can't resolve n and S n0
11:18:53 <boon> thanks folks, i will work on acowley 's example for a while to see if i get mroe ideas :) thanks
11:18:55 <dylukes> in the case of append it apparently won't use the (Add n1 n2 n3) context properly.
11:19:06 <absence> what do i use instead of filter if i need the index as well as the data?
11:19:17 <byorgey> dylukes: you won't be able to define repeat with the given type
11:19:25 <dylukes> How will I have to do it?
11:19:26 <byorgey> dylukes: because you need to do a case analysis on n
11:19:28 <kmc> absence: filter p . zip [0..]
11:19:37 <dylukes> byorgey: hm?
11:19:37 <kmc> > zip [0..] "hello world"
11:19:38 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(5,' '),(6,'w'),(7,'o'),(8,'r'),(9...
11:19:44 <kmc> :t filter ?p . zip [0..]
11:19:46 <lambdabot> forall t b. (?p::(t, b) -> Bool, Num t, Enum t) => [b] -> [(t, b)]
11:19:53 <dylukes> but n is a type, how can I case over it :(
11:20:04 <kmc> :t map snd . filter ?p . zip [0..]
11:20:05 <lambdabot> forall a b. (?p::(a, b) -> Bool, Num a, Enum a) => [b] -> [b]
11:20:06 <byorgey> dylukes: with a clever trick!
11:20:12 <dylukes> :O
11:20:28 <dylukes> wait, I could case using my zero, one, two, etc… couldn't I?
11:20:51 <dylukes> Additionally, why the *fuck* does that undefined trick work. I ran into it by accident with zero, and it confused the hell out of me.
11:21:03 <byorgey> dylukes: no, you can't use those, becuase they are undefined
11:21:28 <byorgey> dylukes: those are only useful for forcing some type computation to happen
11:21:31 <dylukes> byorgey: doing "three `add` two" in ghci yields (S(S(S(S(S(Z)))))
11:21:43 <dylukes> anyways, what do I have to do?
11:21:53 <absence> kmc: awesome, thanks :)
11:23:01 <byorgey> dylukes: you define a "singleton" GADT like    data SNat :: * -> *  where  SZero :: SNat Z   SSucc :: SNat n -> SNat (S n)
11:23:09 <hpaste> acowley pasted “bitnum expando” at http://hpaste.org/48153
11:23:29 <byorgey> dylukes: now change the type of vrepeat to   vrepeat :: SNat n -> a -> Vec n a
11:23:31 <acowley> boon: return type polymorphism
11:24:09 <byorgey> dylukes: SNat is isomorphic to the regular natural numbers, but indexed by type-level naturals, so it gives you a connection between term-level and type-level naturals
11:24:10 <dylukes> wait… what byorgey  ._.
11:24:16 <parcs> is it possible to dynamically link the ghc binary?
11:24:20 <dylukes> XD
11:24:26 <dylukes> indexed natural numbers
11:24:29 <dylukes> just what I needed  :P
11:24:40 <byorgey> dylukes: just write down that GADT and try to implement vrepeat, I think you will not find it very hard =)
11:24:59 <byorgey> dylukes: well, what did you expect?
11:25:21 <c_wraith> parcs: when would that be helpful?
11:25:21 <dylukes> so what does the kind signature here indicate?
11:25:24 <byorgey> the whole point of doing type-level computation is to be able to index things.
11:25:50 <byorgey> dylukes: it just indicates that SNat has kind * -> * .  Just like  Maybe :: * -> *.
11:25:58 <dylukes> sure
11:26:03 <luite> what's a good way to handle this pattern? [m (Maybe a)] -> m (Maybe a), where the actions in the list are to be executed until one returns (Just a)
11:26:07 <parcs> c_wraith: it would help conserve memory when having multiple ghci sessions open
11:26:10 <dylukes> I mean, does that need to even be there though?
11:26:27 <byorgey> dylukes: yeah, you might be able to leave it out
11:26:45 <byorgey> oh, but you'd have to write   data SNat n where ...
11:26:53 <dino-> luite: You can foldl mplus through a list of Maybes
11:27:12 <dylukes> I kind of like using the kind signature more :\
11:27:13 <luite> dino-: but I don't have a list of Maybes
11:27:15 <dylukes> hehe
11:27:21 <luite> I have a list of m (Maybe a)
11:27:24 <boon> acowley: so unless the class we are trying to make our new type an instance of already supports return type polymorphism, we are out of luck right?
11:27:46 <kmc> maybe you can use http://hackage.haskell.org/package/monad-loops
11:27:49 <dino-> liftM2
11:27:58 <byorgey> luite: by "executed until one returns (Just a)" I assume you mean you *don't* want to do  fmap mplus . sequence ?
11:28:00 <dylukes> okay, so byorgey
11:28:03 <dubuisst> @messages
11:28:03 <lambdabot> You don't have any new messages.
11:28:09 <acowley> boon: Right. More generally, the class definition is a bunch of names and types that you need to conform to.
11:28:11 <tommd> @messages
11:28:12 <lambdabot> You don't have any new messages.
11:28:12 <dylukes> this GADT is a TERM level Nat, indexed by type level Nats.
11:28:13 <byorgey> er, msum
11:28:20 <byorgey> dylukes: right.
11:28:21 <dylukes> making sure I have it straight.
11:28:44 <luite> byorgey: hm, it isn't sequence at least, but it might be msum :)
11:29:05 <erus`> anyone wanna help me write a bitcoin library? :)
11:29:18 <byorgey> luite: well, sequence :: [m (Maybe a)] -> m [Maybe a], but that will execute *all* the actions
11:29:19 <dylukes> heh...
11:29:21 <dmwit> > msum [[Just 3, Just 4, Nothing], [Just 5, Just 6, Nothing]]
11:29:22 <lambdabot>   [Just 3,Just 4,Nothing,Just 5,Just 6,Nothing]
11:29:27 <luite> byorgey: yeah that's the problem :)
11:29:27 <dylukes> still confused on vrepeat :\
11:29:33 <dylukes> the additional parameter seems icky.
11:29:38 <c_wraith> luite: it's not msum, because you can't generate the list dynamically.
11:29:53 <byorgey> luite: right, I don't know of a nice way to do it.  You have to maually recurse through and interleave the monadic evaluation with case analysis on the results
11:30:01 <c_wraith> luite: where "dynamically" means not executing things that aren't necessary.
11:30:08 <byorgey> there probably is a nice abstraction for this sort of thing but I don't know what it is.
11:30:10 <c_wraith> luite: Write a new combinator for this. :)
11:30:20 <boon> acowley: so it should be possible to have a new class which defines the same operators as Num but allows for a return type to be specified ?
11:30:35 <byorgey> dylukes: the additional parameter is sort of icky, but it's the only way to make it work.  Otherwise you have no idea how much repeating to do.
11:30:47 <acowley> boon: I'm not sure how useful such a thing would be.
11:30:49 <dino-> > foldl (liftM2 mplus) (return Nothing) [return Nothing, return (Just 1), return Nothing]
11:30:50 <luite> c_wraith: hehe will do (have needed this pattern a few times recently), just wanted to make sure that I didn't miss some standard thing
11:30:50 <lambdabot>   No instance for (GHC.Show.Show (m (Data.Maybe.Maybe a)))
11:30:51 <lambdabot>    arising from a ...
11:30:52 <dylukes> So how do I change the implementation here?
11:31:13 <dylukes> I mean, it's not an infinite repeat then
11:31:15 <dino-> !
11:31:16 <dmwit> luite: Well, it's easy to write. So, you should write it and at it to monad-loops (since it doesn't seem to be there yet).
11:31:33 <dmwit> s/at it/add it/
11:31:35 <c_wraith> [m a] -> m a depending on some sort of predicate on a, and not wanting to execute anything past that is an idiom I want sometimes
11:31:35 <byorgey> dylukes: that's right. you can't write a well-typed infinite repeat since you have defined a type of finite vectors.
11:31:49 <dylukes> my Nat type is theoretically infinite though :\
11:31:51 <boon> and then we can say BitNum should confirm to Num as a provisos for its instance in the new class
11:32:09 <dylukes> eh, I guess you're right
11:32:15 <dmwit> erus`: What would the library do?
11:32:16 <dylukes> anyways, moving on the vappend then
11:32:29 <byorgey> dylukes: well, you're right, I guess you could write  vrepeat :: a -> Vec (Mu S) a
11:32:34 <boon> that way the final math would look normal, and when a return type is specified, the definitions in the instance of hte new class can be used?
11:32:36 <dylukes> Mu!
11:32:39 <dylukes> I forgot about Mu D:
11:32:41 <c_wraith> something like this?  (a -> Maybe b) -> [m a] -> m (Maybe b)
11:32:50 <byorgey> no, actually, that wouldn't work, you'd have the Mu constructors in the way
11:33:08 <dylukes> :\
11:33:22 <acowley> boon: I'm not sure I understand your suggestion
11:33:46 <luite> dmwit: hmm, maybe it can be written with one of those functions
11:33:49 <dino-> > (foldl (liftM2 mplus) (return Nothing) [return Nothing, return (Just 1), return Nothing]) :: IO (Maybe Int)
11:33:50 <lambdabot>   <IO (Maybe Int)>
11:33:51 <c_wraith> with that combinator, your case would be foo const
11:34:00 * dino- falls over
11:34:03 <dmwit> luite: I didn't see one that looked helpful.
11:34:06 <dylukes> byorgey: In any case… vappend is a bit more important here :P
11:34:13 <c_wraith> dino-: isn't that going to execute too much?
11:34:20 <byorgey> dylukes: Haskell does not support infinite types.  so although n = S n  would be a valid infinite Nat on the term level, it is not a valid *type-level* Nat.
11:34:32 <dylukes> Ah I see.
11:34:47 <byorgey> dylukes: what error does vappend give you?
11:35:02 <dylukes> its a doozy.
11:35:03 <dylukes> One moment
11:35:10 <boon> i will make an example and post it on the haskell reddit later today.
11:35:14 <luite> dmwit: me neither, so far :)
11:35:17 <erus`> dmwit: make payments
11:35:22 <dylukes> I'm on dialup. Pasting slowly.
11:35:24 <boon> acowley: are youon reddit?
11:35:28 <dmwit> luite: The any/all/and/or family are close, but they return an m Bool instead of the m a that made the bool true or false.
11:35:31 <int80_h> boon: could you use hpaste.org instead?
11:35:36 <hpaste> dylukes pasted “Error in VAppend” at http://hpaste.org/48154
11:35:45 <int80_h> boon: for posterity.
11:35:53 <dmwit> erus`: Any reason not to just bind to the C library for doing that? (There must be one, right?)
11:35:55 <dino-> c_wraith: You mean evaluate everything in the list? Not sure
11:36:18 <c_wraith> dino-: yes, it will execute every action in the list.  It has to, because foldl doesn't terminate early
11:36:25 <dmwit> luite: Oh, hey, maybe firstM would work.
11:36:41 <erus`> because we like things in haskell
11:36:56 <dmwit> firstM (liftM isJust) >=> join
11:37:13 <byorgey> dylukes: ah, hmm, it's because type classes are open
11:37:27 <byorgey> dylukes: I wonder if it would help to add more fundeps to the Add class
11:37:39 <byorgey> dylukes: i.e. add x z -> y  and y z -> x
11:37:45 <dmwit> ?pl \mmaybeas -> firstM (liftM isJust) mmaybeas >>= \mmmaybea -> mmmaybea
11:37:46 <lambdabot> join . firstM (fmap isJust)
11:37:52 <dmwit> Yeah, that.
11:38:05 <dylukes> can't add both of those
11:38:05 <acowley> boon: I do read reddit
11:38:06 <dmwit> (.), not (<=<)
11:38:14 <luite> dmwit: that's what I thought first, but the return type seems to be incorrect
11:38:16 <byorgey> dylukes: well, pick one
11:38:28 <dylukes> z y -> x conflicts
11:38:36 <dylukes> and that doesn't fix my problem anyhow
11:39:11 <dylukes> See, I keep feeling using (S n) in my classes is not good somehow
11:39:16 <luite> oh maybe with >=> join
11:39:18 <dylukes> But I can't remove them in favor of Suc contexts
11:39:28 <dylukes> because it complains of overlapping instances for zeros
11:39:35 <dylukes> even if I use Pos to eliminate zero!!!
11:39:44 <dylukes> >:(
11:39:56 * dmwit laughs at the type of firstM (liftM isJust)
11:40:09 <dmwit> luite: Looks like it would execute the successful guy twice. Darn.
11:40:17 <copumpkin> :t firstM (liftM isJust)
11:40:18 <lambdabot> Not in scope: `firstM'
11:40:36 <dmwit> luite: (Even if it was written correctly.)
11:40:45 <dmwit> copumpkin: (Monad m) => [m (Maybe a)] -> m (Maybe (m (Maybe a)))
11:41:19 <dylukes> byorgey: any thoughts? This has confounded me all night long.
11:41:21 <c_wraith> :t let foo _ [] = return Nothing ; foo f (x:xs) = do { x' <- x ; case f x' of { Nothing -> foo f xs ; Just a -> return a } } in foo const
11:41:22 <lambdabot>     Couldn't match expected type `Maybe (Maybe a)'
11:41:22 <lambdabot>            against inferred type `b -> t'
11:41:22 <lambdabot>     In the first argument of `foo', namely `const'
11:41:30 <dino-> And the definition of mplus for Maybe doesn't help to avoid this eval. hm
11:41:32 <c_wraith> :t let foo _ [] = return Nothing ; foo f (x:xs) = do { x' <- x ; case f x' of { Nothing -> foo f xs ; Just a -> return $ Just a } } in foo const
11:41:32 <lambdabot>     Couldn't match expected type `Maybe a'
11:41:33 <lambdabot>            against inferred type `b -> t'
11:41:33 <lambdabot>     In the first argument of `foo', namely `const'
11:41:39 * hackagebot Etage 0.1.9 - A general data-flow framework  http://hackage.haskell.org/package/Etage-0.1.9 (MitarMilutinovic)
11:41:39 <copumpkin> dmwit: oh man
11:41:49 <byorgey> dylukes: I don't know, I have a lot more experience with type families than with fundeps
11:42:00 <dylukes> I don't know how type families work at all ^^
11:42:30 <dylukes> would they be applicable here?
11:42:32 <dmwit> luite: firstM (liftM isJust) >=> fromMaybe (return Nothing) :: Monad m => [m (Maybe a)] -> m (Maybe a)
11:42:46 <dmwit> luite: But as I said, it executes the one guy twice.
11:43:01 <dmwit> Once to check the isJust, and once to return the result.
11:44:40 * hackagebot Etage-Graph 0.1.4 - Data-flow based graph algorithms  http://hackage.haskell.org/package/Etage-Graph-0.1.4 (MitarMilutinovic)
11:45:00 <dylukes> maybe write it using do notation, then <-
11:45:29 <c_wraith> @ty let foo _ [] = return Nothing ; foo f (x:xs) = do { x' <- x ; case f x' of { Nothing -> foo f xs ; Just a -> return $ Just a } } in foo id
11:45:29 <lambdabot> forall a (m :: * -> *). (Monad m) => [m (Maybe a)] -> m (Maybe a)
11:46:09 <c_wraith> I would use that combinator
11:46:28 <luite> dmwit: yeah that's bad in my case, since they are potentially expensive :)
11:46:37 * dmwit nods
11:46:39 <c_wraith> luite: I believe my combinator there does what you want
11:46:54 <luite> oh sorry I missed it because i was messing with ghci
11:47:02 <dylukes> byorgey: could I also use type families for this?
11:47:05 <dylukes> I have no idea how they work though :(
11:47:07 <dmwit> Anyway, confirmed: you're not missing anything from the standard libraries that would do what you want.
11:47:35 <byorgey> dylukes: definitely.  I have a series of blog posts you should find useful, let me find you some links
11:47:44 <dylukes> Please do.
11:47:50 <dylukes> I'll download them before the dialup goes off.
11:47:58 <c_wraith> Also, it's fun to write a combinator where passing it id as the first arg results in the behavior desired for this specific case. :)
11:48:22 <dylukes> gah, bang patterns are being used here...
11:48:28 <dylukes> type to download most of the HaskellWiki~
11:48:47 <dmwit> c_wraith: "return" seems like the more natural first argument. I would expect this combinator:
11:49:11 <Toxaris> @type foldr (\p q -> p >>= maybe q (return . Just)) (return Nothing) -- what about this, luite?
11:49:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m (Maybe a)] -> m (Maybe a)
11:49:23 <byorgey> dylukes: http://byorgey.wordpress.com/2010/08/05/typed-type-level-programming-in-haskell-part-iv-collapsing-types-and-kinds/
11:49:35 <byorgey> dylukes: that one has links to the previous ones, it was a four-part series
11:49:47 <dmwit> :t let foo _ [] = return Nothing; foo f (mx:mxs) = do { x <- mx; v <- f x; case v of { Nothing -> foo f mxs; otherwise -> return otherwise } } in foo return
11:49:48 <lambdabot> forall a (m :: * -> *). (Monad m) => [m (Maybe a)] -> m (Maybe a)
11:50:04 <dylukes> mmk, i'll save/read them
11:50:17 <dylukes> Why does it feel like so much of this is "hacked on" to haskell though :\
11:50:25 <dylukes> I guess because they're GHC extensions.
11:50:34 <dylukes> It feels like, GHC Haskell isn't even really "Haskell"
11:50:41 <c_wraith> dylukes: because it is.  People forget the base Haskell language is *old*
11:50:42 <dylukes> It feels like GNU99 C.
11:51:01 <Igloo> c_wraith: Only 1 year old!
11:51:03 <dylukes> Yeah… Haskell 98 doesn't do much :P
11:51:04 <dmwit> Toxaris: Pretty nice. =)
11:51:07 <dylukes> When
11:51:08 <dylukes> s
11:51:13 <dylukes> When's Haskell' due?
11:51:14 <byorgey> dylukes: there is actually a fairly nice story for type families now, in terms of system FC with equality constraints.
11:51:20 <c_wraith> Igloo: don't look at the newest one, look at the oldest. :)
11:51:27 <byorgey> dylukes: Haskell 2010 is already out!
11:51:41 <dylukes> true
11:51:46 <dylukes> I don't know, when something reaches critical mass like this,
11:51:48 <byorgey> the idea is that there will be incremental revisions to the Haskell standard every year or so.
11:51:57 <byorgey> ok, lunchtime
11:51:57 <dylukes> I can't help but feel maybe a complete "leap forward" is necessary sometimes.
11:52:08 <dylukes> To reconsolidate what's needed and such into a new core language.
11:52:16 <c_wraith> dmwit: hmm.  Yes, that's more general, and not any tougher to use.
11:53:06 <dylukes> hehehe
11:53:14 <dylukes> I've seen like 5 haskell blogs with type signatures for titles.
11:53:18 <luite> c_wraith: thanks, works :)
11:53:20 <dmwit> dylukes: byorgey pointed out to me the other day that many people have requested a big leap forward, but nobody has stepped forward to do the work required to make it happen. =P
11:53:20 <dylukes> ^^
11:53:26 <dylukes> plus hackage, hoogle, etc.
11:53:33 <dmwit> dylukes: So... "patches gladly accepted". ;-)
11:53:38 <dylukes> I
11:53:45 <dylukes> I'm not qualified to do so at all,
11:53:53 <dylukes> and besides, patches are exactly the wrong move imo.
11:53:53 <Toxaris> dmwit: What's the difference between your combinator and mine? Is it just a (map (fmap f))?
11:53:55 <c_wraith> luite: check out dmwit's variant.  It's a little more verbose, but it's not more complicated, and it's more general
11:54:06 <dylukes> Basically I'm saying a successor to Haskell would be nice.
11:54:23 <dylukes> It feels like since Haskell's origin, there have been a lot of new good ideas, they''ve been patched on, but...
11:54:30 <dmwit> I was using "patch" metaphorically, of course.
11:54:41 <dmwit> Toxaris: Yes.
11:55:09 <dylukes> Well, I have no idea how type checkers work. Something to think about.
11:55:26 <dylukes> In like, 2 months, I have to start writing my own language >_>
11:55:35 <dylukes> But I was going for something a bit more esoteric/simple.
11:55:37 <sully> what about type checkers?
11:55:56 <sully> I have an assignment I wrote that I can point you to if you are interested in how HM polymorphic type inference works
11:56:10 <dylukes> Sure.
11:56:11 <sully> (background knowledge of specifying type systems with inference rules assumed, though)
11:56:12 <samg_> dylukes: why do you need to start writing your own language? TaPL makes it pretty easy :)
11:56:16 <dylukes> Can you memoserv that to me?
11:56:20 <thoughtpolice> dylukes: personally I think the fact we've been able to grow haskell so much shows that it's a pretty solid foundation, but that view is marred by several more real-world considerations (like the fact we can move fast, because the community is smaller than most.) there are plenty of warts, however.
11:56:33 <dylukes> samg_: Oh right, I have TaPL on my shelf.
11:56:41 <dylukes> Whoops.
11:56:41 <sully> dylukes: http://www.andrew.cmu.edu/course/15-312-sp11/assignments.html
11:56:58 <sully> assignment 4
11:57:01 <samg_> dylukes: the first chapter takes you through an implementation, and I found it pretty easy to follow even without a strong background
11:57:13 <sully> tapl also has a lot of stuff on type checking
11:57:26 <sully> and a decent section on polymorphic type inference
11:57:35 <samg_> second chapter in TaPL is typed lambda calculus, iirc
11:58:03 <thoughtpolice> dylukes: but for example, many of these 'patched on' things have been tremendously valuable to the community and language as a whole. so i don't know if it's fair to characterize all these "additions" as problems - surely many things were not practical to do/implement at the time of haskell 1.0, or even haskell98 :)
11:58:03 <dylukes> I had to put TaPL down for lack of background before, but I think I'll be fine now.
11:58:26 <thoughtpolice> (it's hard as hell to imagine writing modern haskell without MPTCs for example, although they're now in haskell2010 IIRC)
11:58:27 <dylukes> No, I don't categorize them as problems at all!
11:58:40 <dylukes> Just that a sort of "redo" could consolidate or implement them better :)
11:58:51 <luite> dmwit: thanks :)
11:59:03 <dylukes> sully: .__.
11:59:11 <dylukes> Hahaha, this is ironic.
11:59:17 <thoughtpolice> it used to be scarier in the past, when there weren't clear answers to some of the more "advanced" parts of GHC, like how things such as GADTs or FDs and the like should interact. it seems a lot of that has been smoothed over though with all the recent new Core improvements
11:59:29 <dylukes> If I get my way, I'd run into these assignments in a few years anyhow.
11:59:39 <thoughtpolice> (we just got superclass equalities today for example, which SPJ didn't know how to reliably implement in the old version of Core, from what I understand)
11:59:50 <dylukes> CMU's my first choice college ^^, it's also not fifteen minutes away walking haha.
11:59:57 <sully> ah, nice
12:00:12 <sully> I just finished my undergrad at CMU and am going back for the PhD program
12:00:13 <sully> in PL
12:00:20 <Toxaris> I feel that the field of programming languages is still in its infancy, so I don't expect that any language in use today will prove the test of time. So while Haskell is great and clearly my choice of language right now, I don't think it will be the language of the future. (But hey, maybe the language of the future will be *implemented* in Haskell)
12:00:36 <samg_> I have a question about the type of Data.Enumerator.head :: Monad m => Iteratee a m (Maybe a)    This seems too limited. Why not Monad m => Iteratee a m (Maybe b)?
12:00:44 <thoughtpolice> i can only hope that it has the syntax of haskell, because let's face it: it's totally the best. :P
12:00:49 <sully> the language of the future is C++
12:00:50 * sully cries
12:00:59 <dylukes> Toxaris: Until it's self-hosting of course.
12:00:59 <samg_> For example, Data.Enumerator.Binary.head takes ByteStrings to Word8s.
12:01:08 <dylukes> My goal by the end of senior year is to have a simple language built, which, importantly,
12:01:10 <dylukes> is self hosting.
12:01:34 <JuanDaugherty> a 60 year old adult baby
12:01:38 <dylukes> Somewhat lofty, may or may not get there.
12:01:59 <thoughtpolice> sully: but i love a ridiculously verbose type system without any sort of constraints that makes my eyes bleed when i mistype something! you're a hater, bro.
12:02:16 <sully> and that doesn't give you type or memory safety anyways!
12:02:30 <dylukes> I feel like,
12:02:33 <sully> I hate C++ so much.
12:02:38 <dylukes> something like C++ with better type safety,
12:02:41 * sully currently working for Mozilla on the rust programming language
12:02:43 <dylukes> could actually be decent.
12:02:48 <dylukes> But as it is
12:02:49 <dylukes> C++ is *terrible* D:
12:02:53 <thoughtpolice> sully: i'm watching rust with ernest, i hope you know :)
12:03:04 * sully currently adding lambdas
12:03:12 <dylukes> Currently, I'm finding Scala relatively nice.
12:03:14 <JuanDaugherty> C++ is fine, it's the equivalent of assembly language in this time
12:03:24 <arw__> there won't be _the_ language of the future. that was possible when there were only fortran and lisp around, but nowadays you can only look for the 5 or 10 most used languages...
12:03:41 <sully> the guy running the project didn't plan to put lambdas in and then he hired a bunch of functional programmers out of academia as interns :P
12:03:43 * JuanDaugherty used to be a hater of it too, and from the snooty perspective of an early smalltalker.
12:03:59 <yrlnry> You don't think that COBOL# is the Language of the Future?
12:04:03 <thoughtpolice> sully: i've been thinking about trying to submit patches to the rust guys, but i dunno where to start, and i'm confused by some of how rust works, though. i guess a lot of it isn't implemented/fleshed out yet though, so that's ok...
12:04:13 <companion_cube> COBOL# is far too expressive
12:04:19 <thoughtpolice> sully: but gogogogo! i'd fund you myself for something better than C++ if i could
12:04:42 * hackagebot hspec 0.6.1 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-0.6.1 (TrystanSpangler)
12:04:45 <sully> our channel is #rust on irc.mozilla.org
12:05:07 * thoughtpolice will need to add that to his znc instance
12:05:10 <yrlnry> companion_cube: You gotta admit that the EXECUTE PARALLEL ALGORITHM USING MONADIC ENDOMORPHISMS feature is pretty sweet though,.
12:05:17 <dylukes> You know what I should do?
12:05:38 <dylukes> I should set up some sort of public suggestion forum and take suggestions,
12:05:41 <thoughtpolice> the future is INTERCAL, where you need to remember to be polite to your programs
12:05:44 <dylukes> for the language I'll have to write.
12:05:49 <dylukes> Though mind you, I want something I can FINISH.
12:05:55 <dylukes> thoughtpolice: nope, INTERMALBOLGE
12:05:56 <thoughtpolice> because if you don't - like anybody with any amount of sense - they won't like you :)
12:06:02 <companion_cube> yrlnry: nice syntax, far more expressive then "par"
12:06:17 <kmc> thoughtpolice, actually, C++'s "typename" keyword is inspired by INTERCAL's "PLEASE"
12:06:25 <thoughtpolice> bwahahahahahahahahaha
12:06:44 <thoughtpolice> having to deal with that shit as I work on a C++ code base that works with MSVC and gcc, that was a bit too funny
12:06:51 <Toxaris> dylukes: creating a language is like creating a work of art. I am not sure whether a public design process would work.
12:06:52 <thoughtpolice> oh dear. lunch time.
12:06:57 <kmc> it's funny like a kick in the bollocks
12:07:04 <dylukes> true.
12:07:13 <dylukes> I'm not sure exactly which features I *want* yet :\
12:07:18 <shachaf> @remember kmc actually, C++'s "typename" keyword is inspired by INTERCAL's "PLEASE"
12:07:18 <lambdabot> It is forever etched in my memory.
12:07:28 <thoughtpolice> kmc: it's the depressing kind of funny. the kind where you chuckle, and then merely are left to reflect and feel sad, for reasons you can't quite understand
12:07:46 * Saizan is missing on so much humour by not knowing c++
12:07:46 <dylukes> My initial idea was (unknown to me) almost Scala.
12:07:55 <dylukes> shachaf: thank you.
12:07:58 <sully> dylukes: so, self-hosting is hard
12:08:12 <sully> because either the language is good, in which case compiling it is more complicated
12:08:20 <sully> or the language is lame, in which case writing the compiler sucks
12:08:27 <sully> er, writing the bootstrapped compiler
12:08:29 <arw__> try forth :)
12:08:31 <Toxaris> dylukes: I would like to se a purely functional object-oriented language. Not sure whether that makes sense, but I would like to see it.
12:08:53 <dylukes> Toxaris: I was actually thinking, at the moment,
12:09:06 <kmc> Toxaris, I think designing a language is almost nothing like making a work of art.  i think programmers like to tell ourselves that what we do is art because it makes us feel special
12:09:06 <tromp> it makes no sense, but scala comes close:(
12:09:12 <kmc> http://www.google.com/url?sa=t&source=web&cd=1&ved=0CBYQFjAA&url=http%3A%2F%2Fwww.idlewords.com%2F2005%2F04%2Fdabblers_and_blowhards.htm&ei=skQCTpvXFca9tgeLm5ShAQ&usg=AFQjCNGE8z4CuheaPbBKn1_da9pnF5YHpw
12:09:15 <kmc> blah
12:09:17 <kmc> http://www.idlewords.com/2005/04/dabblers_and_blowhards.htm
12:09:28 <thoughtpolice> Saizan: join the club, you'll be laughing soon enough, but whether or not you'll be laughing out of madness/hysteria or actual joy somehow comes down to you :P
12:10:18 <kmc> i think it *is* like designing a building, in that there are some aesthetic concerns, some very hard engineering concerns, and some "design philosophy" stuff that isn't directly about making the building not fall down, but will have a huge practical effect on the day to day life of people who use that building
12:10:58 <hpaste> mikie annotated “asdf” with “asdf (annotation)” at http://hpaste.org/48150#a48157
12:11:12 <kmc> Toxaris, if you're designing a purely-functional OO language, what does OO mean to you? because it means about a dozen different things to different people.
12:11:44 <Toxaris> kmc: I'm not designing a purely-functional OO language, actually, but if I were,
12:11:59 <Botje> huh. hpaste for key distribution
12:12:01 <Botje> that's a first :p
12:12:12 <kmc> i will make a botnet controlled through hpaste
12:12:24 <Toxaris> kmc: ... I guess OO would mean the approach to late binding
12:13:02 <dylukes> Sorry
12:13:05 <sshc> Does anybody here know any means of constructing a Type (in Language.Haskell.TH) from a TypeRep?
12:13:07 <dylukes> the dialup distribution box died.
12:13:11 <dylukes> Anyways, Toxaris
12:13:30 <dylukes> my idea is basically, atm, C + first class types + first class functions
12:13:36 <Toxaris> kmc: in FP, we have functions as the fundamental codata-type, with function application to observe the value of a function. Now in "my" purely functional OO language, I would like to see objects as fundamental codata-type, with the various methods to observe the value of the object
12:13:46 <dylukes> too lazy to every actually deal with, say, garbage collection :P
12:14:02 <kmc> sshc, TypeRep as in Data.Typeable?
12:14:19 <dylukes> sshc ++ => sshd
12:14:22 <dylukes> D:
12:14:53 <Toxaris> kmc: Add some dependent typing into the mix, and you can observe the value of an object at the type level, somewhat like abstract type members in Scala (or, in calculi, like path-dependent types)
12:14:55 <dylukes> Toxaris: I think I'd need to have some level of runtime to achieve first class types though
12:15:50 <dylukes> I'd also remove the use of non-fixed size integers I think, on a random note
12:15:54 <dylukes> they always just seem to bother me.
12:15:55 <sshc> kmc: Yes.
12:16:01 <dylukes> use a fucking int32 you lazy whore.
12:16:06 <dylukes> >:(
12:16:39 <dylukes> See, the question I have is,
12:16:47 <kmc> dylukes, how are you going to handle first-class functions without garbage collection?
12:16:51 <kmc> how do you manage memory for closures?
12:17:01 <kmc> sshc, heh, now i'm curious what you're doing, because it must be clever and/or insane
12:17:27 <kmc> sshc, anyway, Typeable has functions for taking apart a TypeRep... I think you can write the conversion, though it won't be particularly pretty
12:17:31 <dylukes> kmc: I could borrow some inspiration from the clang blocks extension maybe, but I have no idea otherwise ^^
12:17:34 <Toxaris> dylukes: you want to write a compiler or an interpreter or some virtual machine stuff? (or something else?)
12:17:44 <kmc> dylukes, you could also look at how it's done in C++1x
12:17:45 <dylukes> Well, I "wanted" too.
12:17:49 <dylukes> Now I "have" too.
12:17:51 <dylukes> It's my senior project.
12:17:52 <kmc> but i mostly advise using C++ as an example of what not to do
12:18:07 <dylukes> I'm looking at a LLVM backed compiled language.
12:18:12 <dylukes> Somewhat simplistic as I said.
12:18:14 <kmc> dylukes, anyway, simple garbage collection is not that hard.  it's a lifesaver unless you need super realtime performance
12:18:14 <dylukes> I need to be able to finish it.
12:18:36 <benmachine> sshc: I wrote a function TypeRep -> haskell-src-exts:Type
12:18:46 <benmachine> which is not quite the same but ought to be close enough I think
12:18:52 <Toxaris> dylukes: I am not sure, but doesn't LLVM contain a runtime with GC, too?
12:19:23 <dylukes> Toxaris: that's true, lib clang and libllvm/llvm-c have fucking *everything* in them built in >_>
12:19:35 <kmc> dylukes, i suggest assuming garbage collection, and then if you fail to implement it, throw boehm's gc at it and call it good
12:19:41 <sshc> benmachine: Interesting.  Mind sharing?
12:19:45 <dylukes> Yeah, 2.5 has a garbage collector built in I think :|.
12:19:46 <kmc> i think boehm even has annotations you can produce to make it non-conservative
12:20:08 <benmachine> sshc: sure, one sec
12:20:37 <dylukes> Oh I guess it doesn't have a collector proper.
12:20:42 <dylukes> It has other stuff
12:20:49 <dylukes> that ou can use to make one it seems.
12:20:54 <dylukes> plus there are plugins
12:21:03 <kmc> C-- has the ability to generate the information a GC would need
12:21:05 <kmc> maybe LLVM has the same
12:21:22 <dylukes> It does.
12:21:26 <kmc> dylukes, maybe your language should compile through Haskell
12:21:48 <dylukes> I thought about using the Haskell LLVM bindings, but they're a bit shaky and painful.
12:21:50 <hpaste> benmachine pasted “typeRepToType” at http://hpaste.org/48158
12:21:58 <dylukes> I'll probably do the first run through in C/C++
12:22:01 <kmc> that way you get a sophisticated runtime system including garbage collection, massively concurrent transparent async IO
12:22:07 <dylukes> and then since the language will support extern linking to C/C++,
12:22:09 <benmachine> sshc: http://hpaste.org/48158 the way I do it is actually kind of rubbish :)
12:22:11 <dylukes> make it self hosting.
12:22:12 <kmc> dylukes, no, I mean producing Haskell code.  whether you write the compiler in Haskell is a different question
12:22:15 <benmachine> but I think it works
12:22:25 <dylukes> massively concurrent transparent async IO...
12:22:29 <dylukes> compare to
12:22:32 <dylukes> massively multiplayer...
12:22:32 <dylukes> >_>
12:22:44 <dylukes> eh, I kind of want to write something low level.
12:22:57 <sshc> Thanks
12:22:58 <dylukes> that doesn
12:23:01 <kmc> are you going to produce kernel modules with it?
12:23:02 <dylukes> compile into another language
12:23:10 <dylukes> dunno :P
12:23:12 <kmc> LLVM is another language
12:23:17 <kmc> so is C, so is x86 machine code
12:23:22 <kmc> none of these are what the processor "really executes"
12:23:23 <dylukes> it's for fun man.
12:23:23 <dylukes> and grades.
12:23:30 <dylukes> well… yes
12:23:34 <dylukes> I know, I know...
12:23:40 <dylukes> "another high-level, non-intermediate language"
12:24:15 <shachaf> By definition a language that you compile into is an intermediate language. :-)
12:24:24 <Toxaris> #haskell delivers a massively multiprogrammer online functional programming (MMOFP) experience
12:24:58 <dylukes> @quote Toxaris #haskell delivers a massively multiprogrammer online functional programming (MMOFP) experience
12:24:59 <lambdabot> No quotes for this person. BOB says:  You seem to have forgotten your passwd, enter another!
12:25:11 <dylukes> @remember Toxaris #haskell delivers a massively multiprogrammer online functional programming (MMOFP) experience
12:25:11 <lambdabot> It is forever etched in my memory.
12:25:17 <dylukes> @quote MMOFP
12:25:18 <lambdabot> Toxaris says: #haskell delivers a massively multiprogrammer online functional programming (MMOFP) experience
12:25:22 <dylukes> ^^
12:26:54 <ben> :D
12:27:14 <ben> Has anyone written a real-time collaborative text-editor in haskell yet
12:28:16 <dylukes> anyhow, what I'm wondering is,
12:28:30 <dylukes> is it better to mix type parameters to functions in with term parameters,
12:28:39 <dylukes> or should they be segregated?
12:28:47 <sshc> benmachine: "typeRepToType (splitTyConApp -> (con, args))" What is the syntax of "->" in that context?
12:28:47 <Toxaris> kmc: About "language desing is like building design": So in what category falls something like "it should be self-hosting"?
12:28:54 <dylukes> scale's way of doing things isn't bad, since it does allow the compiler to infer stuff :\
12:28:59 <benmachine> sshc: oh, view pattern
12:29:25 <benmachine> it's not really hugely important, you can do it just the same with typeRepToType thing = ... where (con,args) = splitTyConApp thing
12:30:27 <kmc> Toxaris, depends where that requirement is generated from
12:30:46 <Toxaris> kmc: :) often, it is generated out of thin air.
12:31:20 <Toxaris> kmc: and in these cases, I believe, it is an artifical and artistic concern. It would be nicer / cooler / whatever if it were self-hosting
12:31:21 <dylukes> We find these propositions to be axiomatic, that all types are instantiated equivalently...
12:31:29 <sshc> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#view-patterns — I was unaware.
12:32:26 <kmc> view patterns are nice
12:32:27 <dylukes> Self-hosting also has the benefit of removing dependencies though.
12:32:31 <kmc> do you know about PatternGuards as well?
12:32:50 <kmc> dylukes, dependencies for building the compiler?
12:32:55 <kmc> it adds a circular dependency...
12:33:01 <dylukes> oh btw
12:33:07 <dylukes> is there any way to use Agda-mode's quail completion in Haskell-mode?
12:33:22 <shachaf> > [0.0,2..3] -- What was the reasoning behind this behavior again?
12:33:23 <lambdabot>   [0.0,2.0,4.0]
12:33:57 <dylukes> dependencies to the user.
12:34:09 <dylukes> Well, no, because you can distribute the compiler as a prebuilt executable,
12:34:21 <dylukes> which can build all future revisions of itself.
12:34:26 <dmwit> > round ((4 - 0.0) / (2 - 0.0)) <= round ((3 - 0.0) / (2 - 0.0))
12:34:27 <lambdabot>   True
12:34:31 <dylukes> My point is say, I write my language to generate haskell code, or the compiler is in haskell,
12:34:34 <dmwit> shachaf: ^^
12:34:39 <dylukes> now any user has to install GHC in order to use my languge.
12:34:42 <dmwit> > round ((4.001 - 0.0) / (2 - 0.0)) <= round ((3 - 0.0) / (2 - 0.0))
12:34:43 <lambdabot>   True
12:35:04 <dylukes> depending on C/C++ is okay ,since they're kind of "built in" in most cases though, I guess
12:35:18 <kmc> i don't see why people say "C/C++"
12:35:21 <kmc> they are vastly different languages
12:35:22 <sully> dylukes: self hosting is a pain to build
12:35:28 <kmc> C++ has a whole extra runtime library
12:35:31 <kmc> it's not "built in" in any way
12:35:37 <sully> it's also a pain to make language changes when you only have a self-hosting compiler
12:35:41 <kmc> you can apt-get a C++ compiler, but you can also apt-get a Haskell or OCaml compiler
12:35:44 <shachaf> dmwit: The definition of numericEnumFromThenTo doesn't mention rounding. Are you sure that's the justification?
12:35:47 <dmwit> > round ((4.9 - 0.0) / (2 - 0.0)) <= round ((3 - 0.0) / (2 - 0.0))
12:35:48 <lambdabot>   True
12:35:53 <dmwit> > round ((5 - 0.0) / (2 - 0.0)) <= round ((3 - 0.0) / (2 - 0.0))
12:35:54 <lambdabot>   True
12:35:55 <dmwit> shachaf: no
12:35:57 <sully> especially when there are a bunch of people developing
12:36:02 <dmwit> > round ((5.1 - 0.0) / (2 - 0.0)) <= round ((3 - 0.0) / (2 - 0.0))
12:36:03 <lambdabot>   False
12:36:13 <dylukes> hm.
12:36:16 <dmwit> > [1.0, 3 .. 3]
12:36:17 <lambdabot>   [1.0,3.0]
12:36:26 <dmwit> shachaf: I'm very likely wrong, in fact. =)
12:36:45 <dmwit> > [0.9, 2.9 .. 3]
12:36:46 <lambdabot>   [0.9,2.9]
12:38:13 <Toxaris> dylukes: C is not "built into" Windows
12:38:19 <joe6_> is there  a haskell function that can do : Word16 -> (Word8,Word8)
12:38:46 <NihilistDandy> @hoogle Word16 -> (Word8, Word8)
12:38:47 <lambdabot> Control.Monad.RWS.Lazy evalRWS :: RWS r w s a -> r -> s -> (a, w)
12:38:47 <lambdabot> Control.Monad.RWS.Strict evalRWS :: RWS r w s a -> r -> s -> (a, w)
12:38:47 <lambdabot> Control.Monad.RWS.Lazy execRWS :: RWS r w s a -> r -> s -> (s, w)
12:38:55 <dmwit> shachaf: "For Float and Double, the semantics of the enumFrom family is given by the rules for Int above, except that the list terminates when the elements become greater than e3+i/2 for positive increment i, or when they become less than e3+i/2 for negative i."
12:38:56 <sshc> joe6_: Yep: const (0, 2)
12:39:08 <Botje> joe6_: I'd use some of the Data.Bits combinators
12:39:11 <dylukes> Toxaris: I don't consider Windows on my list of "platforms"
12:39:14 <dmwit> shachaf: (Here, e1, e2, and e3 are [e1, e2 .. e3], respectively.)
12:39:30 <dylukes> Not out of distaste for the OS, just out of convenience.
12:39:45 <dmwit> > 4 <= 2 + (2 - 0.0) / 2
12:39:46 <lambdabot>   False
12:39:49 <dylukes> This is a project for school, if it ends up being something cool enough people want it on windows, someone will manage.
12:39:51 <dmwit> eh
12:39:57 <dylukes> And that's very unlikely
12:40:03 <Toxaris> dylukes: sure, not a problem for a toy project, s
12:40:07 <dmwit> So that's where it terminates. =)
12:40:12 <Toxaris> dylukes: just pointing it out :)
12:40:20 <dylukes> mm.
12:40:43 <joe6_> @hoogle const
12:40:43 <lambdabot> Prelude const :: a -> b -> a
12:40:43 <lambdabot> Data.Function const :: a -> b -> a
12:40:43 <lambdabot> Control.Applicative newtype Const a b
12:42:57 <parcs> is it possible to change the command prefix for ghci commands?
12:43:03 <parcs> (which is by default :)
12:44:01 <dylukes> Toxaris: sully: Anyhw
12:44:01 <dylukes> I'm thinking something C-ish then, with better type checking, and type parameters to functions :|
12:45:49 <NihilistDandy> parcs: What would you prefer? Is ':
12:45:58 <NihilistDandy> * Is ':' hard to get to?
12:46:10 <sully> dylukes: you don't want to write a compiler in that, though
12:46:12 <parcs> NihilistDandy: yes, it requires two key presses
12:46:12 <thoughtpolice> do you mean "type parameters to functions" as in 'generics' or like in System Fw where you can push types into the value-land?
12:46:20 <parcs> NihilistDandy: i would prefer ;
12:46:23 <dylukes> sully: true, I'll probably write the compiler in C or C++
12:46:27 <sully> no!
12:46:29 <thoughtpolice> oh christ
12:46:31 <sully> you don't want to do that either!
12:46:32 <thoughtpolice> don't hurt yourself like that
12:46:35 <sully> oh my god!
12:46:50 <kmc> that's fucking awful
12:46:58 <kmc> even Java would be better
12:47:00 <thoughtpolice> just pattern matching gives you such an advantage in implementing something like a compiler succinctly, i dare not think what it would be like in a language without one
12:47:08 <thoughtpolice> *without it
12:47:10 <sully> yeah, use an ML or haskell
12:47:10 <joe6_> > sizeOf Int
12:47:11 <lambdabot>   Not in scope: `sizeOf'Not in scope: data constructor `Int'
12:47:19 <kmc> forget pattern matching, C and C++ don't even do garbage collection
12:47:19 <sully> or at least something garbage collected
12:47:30 <joe6_> @hoogle sizeOf
12:47:30 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
12:47:31 <lambdabot> Network.Socket.Internal sizeOfSockAddr :: SockAddr -> Int
12:47:31 <lambdabot> Network.Socket.Internal sizeOfSockAddrByFamily :: Family -> Int
12:47:40 <kmc> before you tell me "GCC is written in C", do note that they implemented their own garbage collector
12:47:57 <NihilistDandy> parcs: Nothing in the docs I can find suggests a way to change it
12:47:57 <kmc> a proper smart-pointer-based reference counting scheme in C++ might be okay
12:48:00 <thoughtpolice> joe6_: you need to say something like "sizeOf (undefined :: Int)"
12:48:01 <kmc> but then you're still using C++
12:48:02 <NihilistDandy> You could remap your keyboard
12:48:15 <NihilistDandy> Just switch ':' and ';'
12:48:21 <kmc> and frankly very few people know C++ well enough to do "proper" C++ design
12:48:23 <thoughtpolice> kmc: yeah, don't they use their own GC so they can just allocate and shit willy-nilly inside the compiler proper and not have to worry about it?
12:48:47 <ben> Why do I suspect that proper C++ design involves doing as little C++ as you can manage?
12:48:53 <kmc> which is just as well, because the result of "proper C++ design" are barely nicer than C at best
12:49:01 <kmc> and in between C and "proper C++ design" is a vast chasm of madness
12:49:09 <NihilistDandy> kmc: lol
12:49:16 <kmc> and this is where almost all commercially written C++ code falls
12:50:18 <joe6_> thoughtpolice: ok, thanks.
12:50:22 <kmc> i think understanding C++ well is at least as hard as understanding Haskell well
12:50:38 <kmc> it's just that more people are motivated to understand C++ poorly, and get paid for it
12:50:47 <joe6_> thoughtpolice: which module has the sizeOf function?
12:51:12 <kmc> when i thought i was close to understanding C++ well, i switched industries :)
12:51:36 <sipa> ffelix is daar en der is plek
12:51:46 <sipa> ow, wrong window
12:51:54 <Toxaris> dylukes: If you don't trust your FP skills to implement the compiler in Haskell or some ML, you might want to consider Scala. It supports garbage collection and pattern matching, but you can keep an imperative style of programming if you feel like it.
12:52:16 <kmc> you can also use an imperative style of programming in Haskell or ML
12:52:46 <kmc> and you can get automatic memory management + first class functions + some things resembling pattern matching in almost any language besides C or C++
12:52:54 <Toxaris> dylukes: But writing a compiler in a language like C means that you need to compile from some pattern-matching-based specification language to the actual implementation language by hand
12:53:04 <Toxaris> dylukes: and that's just a waste of time imho
12:54:34 <thoughtpolice> joe6_: i think it's in "Foreign.C" if i'm not mistaken
12:54:46 <dylukes> hm.
12:54:58 <dylukes> Yeah, I considered doing it in Scala :\
12:55:00 <dylukes> not sure yet, I'll see.
12:55:17 <dylukes> I'll probably end up using Haskell if I do FP
12:56:02 <kmc> no, you'll probably end up doing FP even if you use C
12:56:02 <sully> writing a shitty compiler for a functional language isn't really that hard, honestly
12:56:06 <kmc> it will just be insanely painful
12:57:14 <kmc> functional programming is a style of code, it's the natural style for some problems, and those who avoid functional languages usually reimplement their features at great expense
12:57:43 <thoughtpolice> sully: yeah, and with the amount of support haskell has for writing things like compilers/interpreters, you could get away with a small functional language incredibly easy i'm willing to bet
12:58:32 <sully> it's like: elaborate, cps convert, closure convert, hoist, explicitly allocate, codegen
12:58:37 <thoughtpolice> maybe the only thing i would possibly consider hairy is GC, but only because the tricky part is how you want to reliably identify root pointers when you need to collect. you can just say F that and use boehm though
12:58:45 <sully> where codegen is actually secretly a bunch of other things
12:58:51 <sully> right, root pointers.
12:59:03 <sully> so, if you don't care about sucking there are easy ways to track roots
12:59:09 <sully> like haivng all of your roots in an array
12:59:22 <joe6_> any suggestions on how I can make these 2 functions into one:  http://sprunge.us/CWDF
12:59:32 <sully> that's what we did for the SML compiler we wrote for the higher-order typed compilation class at CMU
12:59:33 <joe6_> thoughtpolice: found it in Foreign.Storable
12:59:44 <sully> we also generated C
12:59:46 <sully> really bad C
12:59:49 <thoughtpolice> sully: yeah, that's THE thing that will fuck you up if you want to go beyond toyish IMO.
12:59:55 <sully> yeah
12:59:59 <sshc> Instances of 'Typeable' can only be monomorphic, right?  (the result of 'typeOf', specifically)
13:00:02 <kmc> joe6_, isn't the code the same for both?
13:00:06 <thoughtpolice> sully: DDC does something similar to that - you have a fixed size global array of all root pointers, and on allocation you just stuff it in the array
13:00:21 <kmc> so just generalize the type to (Bits a) => a -> (Word8, Upper, High, Low)
13:00:22 <thoughtpolice> GC sweeps it at GC time, and that's it. what if you have too many root pointers? it bails, but despite this you can write real stuff with DDC
13:00:31 <joe6_> kmc: it is the same but I want the type signature to include both Word32 and Int
13:00:39 <joe6_> thoughtpolice: that was it. Thanks.
13:00:44 <thoughtpolice> joe6_: np
13:00:50 <joe6_> kmc: thanks.
13:00:53 * hackagebot snap-core 0.5.1.3 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.5.1.3 (GregoryCollins)
13:01:53 * hackagebot murmurhash3 1.0 - 32-bit non-cryptographic hashing  http://hackage.haskell.org/package/murmurhash3-1.0 (NisWegmann)
13:15:12 <lfppv> hi, if i do something like, do txt <- getContents, then after i do nLines <- length (lines txt) i get an error
13:16:28 <sepp2k> lfppv: length returns an integer, not an IO. You need to do  let nLines = length (lines txt)
13:16:32 <monochrom> let nLines = length (lines txt)
13:16:46 <lfppv> what let actually does?
13:17:00 <monochrom> give a name to an expression
13:17:35 <lfppv> k, thnks
13:20:57 <kmc> lfppv, the general form is "let x = y in z"
13:21:08 <kmc> > let x = 2+2 in x*x
13:21:10 <lambdabot>   16
13:21:11 <kmc> but there's a special case for "do" expressions
13:21:22 <tromp> > let 0 = 1 in 0
13:21:23 <lfppv> ok
13:21:23 <lambdabot>   0
13:21:24 <kmc> where you omit the "in" and it instead scopes over the rest of the statements in the "do" expression
13:21:30 <monochrom> I wouldn't mix up "let in" and "do let"
13:21:31 <kmc> > let !0 = 1 in 0
13:21:31 <lambdabot>   *Exception: <interactive>:3:4-9: Non-exhaustive patterns in pattern binding
13:21:38 <joe6_> is there a better way of donig this: http://pastebin.com/vyQ0y9zH
13:21:40 <mauke> The paste vyQ0y9zH has been copied to http://hpaste.org/48160
13:22:10 <monochrom> oh, "they both use the same keyword". yeah right, existential types use the keyword "forall" too
13:22:28 <sciolizer> What does it mean when ghci says "Loading package readline-1.0.1.0 ... linking ... <interactive>"? (Most of the time it doesn't say <interactive>.)
13:23:00 <tromp> > let  enumFrom = 42 in [0..]
13:23:00 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
13:23:27 <kmc> monochrom, "do let" is sugar for "let in"
13:23:44 <monochrom> that's desugaring detail
13:23:55 <dmwit> joe6_: yes
13:24:53 <jfmiller28> Good afternoon (PDT) all
13:25:11 <jfmiller28> Can someone help me undersatnd `data ATExp = forall a . TExp a ::: TTyp a`
13:25:21 <jfmiller28> particularly the three colons
13:26:17 <c_wraith> ::: is the data constructor
13:26:23 <c_wraith> ignore how much it looks like ::
13:26:24 <sciolizer> jfmiller28: Any infix operator beginning with : is a constructor.
13:26:31 <sciolizer> (except for ::)
13:26:34 <joe6_> dmwit: how? any thoughts, please?
13:26:38 <dmwit> http://hpaste.org/edit/48160
13:27:12 <monochrom> do you understand "data ATExp = forall a. Whee (TExp a) (TTyp a)"? if so, the author just wants to replace Whee by infix :::
13:28:11 <c_wraith> If you don't understand existential types, it just means that it assures the same a is used in both arguments to ::: at construction time, then throws out what the type actually was.
13:29:44 <dmwit> joe6_: (Though beware that the list may be shorter than two sometimes; you may like "lower2Bytes = take 2 . (repeat 0 ++) . toBytes" better if you're concerned about that.)
13:30:01 <dmwit> joe6_: (Alternately, just drop the first clause of "toBytes" and it will emit an infinite list of zeros for free. =)
13:30:47 <joe6_> dmwit: i do not see any changes at that url?
13:31:10 <dmwit> ehhh
13:31:44 <dmwit> try now
13:31:50 <jfmiller28> Thank you for the answers, I'm trying to see if they help me understand the code...
13:32:02 <dmwit> joe6_: gotta run, good luck
13:32:29 <int80_h> The problem I'm having is that the main library I am using requires a different version of a sub-library than the one I need. What kind of cabal trickery can I use to have them each use the version they need?
13:32:45 <joe6_> is there a haskell function for: Char -> Word8
13:32:59 <dmwit> joe6_: That's not a safe conversion.
13:33:12 <dmwit> However, there is an entire library for String -> [Word8].
13:33:18 <kmc> indeed, very few Chars can be represented by a Word8
13:33:23 <dmwit> (From which a Char -> [Word8] is trivially implemented.)
13:33:24 <joe6_> oh, the sizeOf Char = 2?
13:33:31 <dmwit> > sizeOf Char
13:33:32 <lambdabot>   Not in scope: `sizeOf'Not in scope: data constructor `Char'
13:33:33 <kmc> joe6_, sizeOf Char is not defined
13:33:38 <kmc> it's not a Storable type afaik
13:33:39 <monochrom> > maxBound :: Char
13:33:40 <lambdabot>   '\1114111'
13:33:44 <dmwit> Char is a Unicode codepoint.
13:33:48 <kmc> Char represents a Unicode codepoint (Unicode is neither a 1 nor a 2-byte
13:33:49 <joe6_> dmwit: do you mean ByteString?
13:33:50 <dmwit> So two bytes isn't enough, either.
13:33:50 <kmc> encoding)
13:33:51 <monochrom> google for "unicode"
13:33:54 <tekknolagi> > maxBound :: Int
13:33:55 <lambdabot>   9223372036854775807
13:34:02 <dmwit> joe6_: The library will do ByteString, as well, yes.
13:34:17 <monochrom> see also http://www.joelonsoftware.com/articles/Unicode.html
13:34:20 <dmwit> joe6_: Oh, no, I don't mean the ByteString library, I mean this one:
13:34:21 <kmc> there are many different protocols for representing a Unicode codepoint as a sequence of bytes
13:34:22 <dmwit> ?hackage encoding
13:34:23 <lambdabot> http://hackage.haskell.org/package/encoding
13:34:42 <kmc> joe6_, anyway, if you know your codepoints are under 256, you could just use fromIntegral . fromEnum
13:34:45 <kmc> :t fromIntegral . fromEnum
13:34:46 <lambdabot> forall b a. (Num b, Enum a) => a -> b
13:34:51 <kmc> > fromIntegral . fromEnum $ 'X'
13:34:53 <lambdabot>   88
13:34:55 <kmc> > fromIntegral . fromEnum $ '☭'
13:34:57 <lambdabot>   9773
13:35:07 <kmc> > (fromIntegral . fromEnum $ '☭') :: Word8
13:35:09 <lambdabot>   45
13:35:46 <joe6_> kmc, yes, my codepoints are below 256
13:35:53 <NiCROS> I'm getting Configuring X11-1.5.0.0... "The program ghc version >=6.4 is required but it could not be found."
13:36:00 <kmc> joe6_, why are they?
13:36:09 <dmwit> NiCROS: Upgrade GHC.
13:36:16 <dmwit> NiCROS: (What version are you on??)
13:36:19 <NiCROS> ghc --version shows The Glorious Glasgow Haskell Compilation System, version 7.0.4
13:36:31 <dmwit> hum
13:36:53 <dmwit> I wonder if you've modified $PATH, but haven't "export"ed it.
13:36:58 <NiCROS> nope
13:37:20 <monochrom> I want a survey done on how many people claim "all my chars are below 256" and how many of them eat their words in 2 years
13:37:46 <joe6_> monochrom: i converted the string from a C string.
13:38:02 <joe6_> from C code, and in C, I assume that the Char is one byte.
13:38:26 <dmwit> joe6_: So why not convert it to [Word8] instead of going via [Char]?
13:38:28 * ben melts down into a puddle of multibyte characters
13:38:28 <c_wraith> joe6_: why do you assume the conversion function doesn't treat its input as encoded unicode?
13:38:43 <joe6_> it is a CString
13:38:53 <dmwit> Right...
13:39:09 <c_wraith> joe6_: you might be surprised by what withCString does
13:39:10 <hpaste> ezyang pasted “postorder_dfs_from_except” at http://hpaste.org/48162
13:39:12 <joe6_> makes sense to just use Word8 instead of Char
13:39:44 <c_wraith> joe6_: you probably should treat the CString as a ByteString, not a String
13:40:33 <dmwit> type CString = Ptr CChar; newtype CChar = CChar Int8
13:40:41 <dmwit> So, yeah, going via Char is silly.
13:41:05 <dmwit> And possibly wrong, if you aren't paying very close attention.
13:41:27 <Peaker> Yesterday I finally read "From Lists to Streams to Nothing at all".. pretty awesome paper :-)
13:41:27 <kmc> if you really want to assume that C string is ASCII encoded, you should use an explicit "decode" function
13:41:46 <dmwit> It sounds like he just wants a sequence of bytes.
13:42:04 <dmwit> ...which many C programmers represent as an array of chars.
13:42:08 <monochrom> C is so 1970s
13:42:55 <chrisdone> monochrom: That's not what the Lispers said. :-(
13:42:55 <lambdabot> chrisdone: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:46:15 * hackagebot couch-hs 0.1.2 - A CouchDB view server for Haskell.  http://hackage.haskell.org/package/couch-hs-0.1.2 (PeterSagerson)
13:53:44 <Peaker> monochrom: unfortunately C is very 2011 too :-(
13:54:08 <monochrom> does C provide garbage collection?
13:54:15 <Peaker> monochrom: sometimes you don't want GC
13:54:18 <adrake> monochrom, no
13:54:24 <monochrom> then it is not very 2011
13:54:35 <Peaker> monochrom: in 2011, GC is not always a good thing
13:54:37 <int80_h> The problem I'm having is that the main library I am using requires a different version of a sub-library than the one I need. What kind of cabal trickery can I use to have them each use the version they need?
13:54:54 <monochrom> if it provided garbage collection that you can opt-in or opt-out, then it would be very 2011
13:55:45 <Peaker> monochrom: just opt-in and opt-out by writing different parts in C or not C...
13:56:18 <monochrom> what is so 2011 about C? does it even provide nested functions yet?
13:57:01 <drdo> What's so 2011 about C? The fact that 90% of the software on your computer right is written in it
13:57:13 <Peaker> monochrom: I don't see any other language competing with C in the tight-resource-control arena except C++ which is a monster
13:57:20 <drdo> and 90% is probably an underestimation
13:57:36 <Peaker> I write C at work, and I don't see any other language which could do the job as well, for many of the things we do
13:58:43 <Peaker> It's an almost paradoxical situation where performance bugs are worse than correctness bugs.. a correctness bug can be worked around in many ways.. a performance bug can result in crashes or otherwise cannot be worked around
13:58:53 <drdo> Peaker: C is fine in some application areas
13:58:55 <monochrom> well then we disagree on the definition of 1970 and 2011
13:59:04 <jystic> Once you discover the secret to better C (http://thedailywtf.com/Articles/The_Secret_to_Better_C.aspx) I don't know why you'd want to use anything else
13:59:19 <Peaker> So a language which makes "performance correctness" easy like C but other forms of correctness hard is better there than a language like Haskell which makes performance correctness harder but other correctness easy
13:59:19 <drdo> The major complaint i have about C is no proper macros or anything good at all for abstraction
13:59:27 <rtharper> hrm, is there not a "replace" function for List?
13:59:35 <benmachine> C does in some ways just have bad design descisions though
13:59:42 <benmachine> the syntax is just weird in places
13:59:52 <monochrom> I don't take "still used in 2011" as the definition. I take the attitude behind it. such as no nested functions. such as "8 bits ought to be enough for human text characters"
13:59:53 <Peaker> drdo: I miss parameteric polymorphism, type-classes, stricter type-checking, proper modules, ...
14:00:00 <benmachine> I always thought typecasts awkward, especially being sometimes implicit and sometimes not
14:00:17 <drdo> Peaker: I'm serious actually, i don't mean turning C into another language
14:00:22 <benmachine> and yes, no proper modules is upsetting
14:00:22 <Peaker> monochrom: btw: I think C is a bad language -- it's just the best at that domain.. nobody is working on that domain :-(
14:00:47 <Peaker> drdo: But there's really no tension between the features I mentioned and tight resource control
14:01:07 <Peaker> which is what C has no good replacement for
14:01:29 <drdo> stricter type-checking
14:01:33 <drdo> you don't want this in C
14:01:48 <Peaker> drdo: Why not?  I don't want confusion of enum and int to be A-OK with the compiler
14:02:04 <drdo> the kind of places where you want to use C are the places where people like to hack shit up to shave off one instruction
14:02:12 <Peaker> drdo: I want to be able to do what the dimensions package does in Haskell -- have different numeric types but still be able to use them like numbers
14:02:15 <benmachine> drdo: sure, but you can do that without implicit type conversions
14:02:27 <Peaker> drdo: that has little to do with non-strict type checking
14:02:28 <benmachine> even an *optional* type system would be an improvement
14:02:28 <drdo> benmachine: sure you can
14:02:41 <drdo> implicit type conversion and type enforcement are different
14:02:57 <Peaker> drdo: strict type checking means that you could still do everything you do now -- you'd just have to be explicit when type conversion takes place
14:02:59 <benmachine> (actually the really weird thing is that lots of people write C in non-performance-critical places, just because it's what they know)
14:03:12 <Peaker> benmachine: or because C has really good ffi to C :)
14:03:13 <drdo> Peaker: C is kind of like that, you cast stuff
14:03:15 <monochrom> that is what you get for tight resource control, or generally being a control freak. you have to know an enum equivales an int.
14:03:25 <drdo> the type system is very limited though
14:03:28 <benmachine> Peaker: :P
14:03:34 <Peaker> drdo: no, if you confuse two different enum typed arguments -- the compiler will approve without warning
14:03:35 <drdo> So you have lots of trouble expressing even the most primitive things
14:03:44 <Eduard_Munteanu> Hrm, similar discussion going on in -blah
14:04:10 <Peaker> monochrom: the fact all enums are ints is bad for control :) it should have been:   enum char { ..} or  enum int { .. } :)  and then you'd still have to cast it to char or int for safety
14:04:32 <Peaker> drdo: I rarely ever want to cast enums to ints and vice-versa, almost all cases of that happening are bugs --- and my compiler is not helping at catching those
14:04:37 <benmachine> I read an article about how C was really bad for optimisation because of pointer aliasing
14:04:42 <drdo> Peaker: gcc doesn't warn?
14:04:45 <Peaker> drdo: no
14:04:54 <benmachine> Peaker: I think it does sometimes
14:04:55 <Eduard_Munteanu> benmachine: um, 'restrict'? It's been there since C99
14:05:02 <benmachine> or sufficiently advanced gcc does
14:05:14 <benmachine> Eduard_Munteanu: sure, but is it enforced, or frequently used correctly?
14:05:28 <drdo> benmachine: In theory, a haskell compiler for example should be able to provide much better native code because it knows much more about your program
14:05:41 <drdo> The problem is that existing compilers are not SS
14:05:45 <benmachine> :P
14:05:46 <benmachine> quite
14:05:57 <Peaker> drdo: not even with "-Wextra"
14:06:06 <benmachine> at the same time there are a lot of people who *think* they are smarter than compilers but aren't
14:06:11 <Peaker> benmachine: enum and int are completely interchangable at the highest warning level :-(
14:06:31 <Peaker> I also would like my "fromIntegral" conversions to require explicit calls like in Haskell..   inconvenience is cheap.  Bugs are expensive.
14:06:42 <Peaker> The fact C prefers convenience over safety/bugs is a huge mistake
14:06:44 <Eduard_Munteanu> Unfortunately it's really easy to be smarter than GHC in lots of cases :)
14:07:46 <Peaker> anyway, I write C at work -- and am really bummed that so many things are unnecessarily hard... C++ would alleviate many of them but has a whole slew of its own problems... And *nobody* seems to be working on improving the low-level language situation
14:07:55 <benmachine> Peaker: I'm sure I got a warning about something somewhere, but I can't reproduce it
14:08:04 <benmachine> Peaker: you've found your calling obv
14:08:07 <drdo> Peaker: There was this thing called BitC
14:08:21 <kmc> Peaker, i know many people (including myself) with plans for a "C++ killer"
14:08:28 <Eduard_Munteanu> Hm, indeed. C and C++ are pretty much lonely in the realm of low-level languages.
14:08:33 <kmc> but they don't get adopted, when they're even developed
14:08:41 <Eduard_Munteanu> Well, maybe Pascal or D get close, but still.
14:08:43 <Peaker> benmachine: C repeatedly prefers convenience (avoiding those 20 seconds you get annoyed at it not compiling and fixing it) over safety (avoiding that bug you're hunting for hours while someone's machine is on hold and he cannot work)
14:08:49 <theorbtwo> kmc: You mean, in addition to Java and C#?
14:09:00 <kmc> garbage collection disqualifies them from the title
14:09:00 <drdo> Peaker: C doesn't prefer convinience at all
14:09:01 <benmachine> Peaker: yaino. gcc is quite clever though
14:09:02 <Eduard_Munteanu> (not that I'd touch Pascal :D)
14:09:08 <Peaker> drdo: bitC doesn't seem to be going anywhere.. but I am not sure
14:09:26 <kmc> in any environment where Java or C# is an acceptable choice, there are lots of other choices
14:09:27 <Eduard_Munteanu> I personally think GCC is awesome.
14:09:31 <Peaker> drdo, benmachine: gcc is type-conversion-happy
14:09:37 <Eduard_Munteanu> Overall, I mean.
14:09:38 <drdo> Peaker: People write in C mainly because a lot of stuff is written in C
14:09:39 <Peaker> kmc: Don't say "D" :-)
14:09:47 <Peaker> kmc: D seems like the work of a PL illiterate
14:09:52 <kmc> "well i guess i'm writing a realtime app, so i have to punch myself in the balls repeatedly"
14:09:57 <benmachine> Peaker: there are worse things than D
14:10:00 <kmc> Peaker, true, but so do most languages
14:10:01 <theorbtwo> kmc: Hmm.  IMHO, it's hard to make a better C or C++ without adding gc, but my opinion may well be ignorant.
14:10:12 <kmc> theorbtwo, improvement on C++? good god yes
14:10:17 <chrisdone> Peaker: You've seen ATS?
14:10:17 <kmc> for starters you can clean up the syntax enormously
14:10:20 <drdo> theorbtwo: There's a lot of stuff you can do to make C better without GC
14:10:27 <kmc> in fact some people have invented alternative syntaxes for C++
14:10:40 <theorbtwo> I program very little C or C++.  Especially the second one.
14:10:45 <hpaste> dylukes pasted “OH THE HORROR” at http://hpaste.org/48166
14:10:48 <kmc> also, if you're writing performance-critical code then a good metaprogramming system is essential
14:10:52 <drdo> The main problem with C is that you can't abstract stuff very well
14:10:53 <Peaker> chrisdone: Yeah, I tried going through tutorials, but was heavily turned off.. It may be great, but even if it is, it's not exactly at the same niche as C, apparently
14:10:54 <kmc> so you can  generate super-specialized stuff and move more work to compile time
14:10:59 <kmc> and CPP and C++ templates both suck
14:11:01 <drdo> Yes you have preprocessor "macros"
14:11:08 <drdo> But those suck big time
14:11:09 <dylukes> drdo: ^
14:11:09 <kmc> so there's just two of many areas for improvement
14:11:15 <kmc> without changing the runtime at all
14:11:16 <Peaker> C++ without the OO silliness would be nice
14:11:24 <Eduard_Munteanu> The issue with ATS is it's a ML descendant.
14:11:26 <dylukes> case in point, kmc: http://hpaste.org/48166
14:11:29 <kmc> C++'s take on OO is quite idiosyncratic
14:11:44 <kmc> what's that dylukes?
14:11:48 <Peaker> Inheritance is useless... Existential types with proper parameteric polymorphic and type-classes would give you everything positive you can get from C++'s inheritance
14:11:52 <Eduard_Munteanu> Which gets you Haskell-ish stuff in a not-so-nice-looking package (syntax)
14:11:54 <kmc> oh that's some D?
14:12:01 <dylukes> It's C1X with static generic expressions
14:12:02 <benmachine> kmc: no it's a proposed extension to C iirc
14:12:06 <dylukes> essentially, type switching
14:12:14 <kmc> buh?
14:12:50 <kmc> just use gcc with __builtin_types_compatible_p(), problem solved
14:12:51 <dylukes> It's an ugly, but functional way to "overload"
14:13:02 <kmc> (by "problem solved" i mean "now you have two problems")
14:13:38 <Peaker> drdo: what do you mean by "can't abstract" -- we abstract things all the time, but we rely on convention somewhat.. I have for example:  foo.h  and foo_private.h   and you indirectly #include the private file and are not supposed to use private things from there
14:13:58 <monochrom> dylukes++ :)
14:14:17 <dylukes> monochrom: hm?
14:14:18 <drdo> Peaker: I mean in the sense that you don't have proper macros
14:14:24 <theorbtwo> Peaker: The problem with convention is that hile it makes it somewhat harder to make mistakes if you know the conventions, it doesn't do a good job catching accidents or idiots.
14:14:39 <Peaker> drdo: why are proper macros needed for abstraction?
14:14:44 <monochrom> ATS syntax is too verbose, thanks you drinking the curry-howard koolaid wholesale. but it is a fine low-level language semantic-wise
14:14:54 <monochrom> s/thanks you/thanks to/
14:14:55 <dylukes> the only problem with this is, as you may notice,
14:14:55 <dylukes> the number of parameters to the "overloaded" function,
14:14:57 <Peaker> theorbtwo: well, if you do C, you really want to get rid of the idiots anyway :)
14:15:03 <drdo> Peaker: They aren't, they are just a really good one
14:15:06 <dylukes> corresponds to the dimension of the required matrix/tensor of _Generics D:
14:15:08 <kmc> Peaker, that doesn't work though
14:15:23 <theorbtwo> FWIW: I hate the word "proper" in this sort of debate.  If you mean lispy macros, or metaquoting macros, say so.
14:15:34 <kmc> Peaker, i'm sick of hearing that argument for why C is good.  bad programmers will simply not be discouraged by all the bugs and security holes they introduce
14:15:41 <kmc> especially because these things are fucking hard to find
14:15:43 <drdo> theorbtwo: I just said proper because some people call what the C preprocessor does macros
14:16:02 <theorbtwo> drdo: Yes.  I understand that.  "Proper" is a value judgement, not a class of macro.
14:16:13 <drdo> I mean macros as in lisp
14:16:37 <theorbtwo> I consider what the C preprocessor does proper macros, and the lispy kind is something different that I wish people would find a different name for.
14:16:50 <theorbtwo> The lispy kind is clearly *better*, but that doesn't make cpp macros *improper*.
14:17:02 <chrisdone> theorbtwo: I'm sure lispers feel the same way vise versa.
14:17:06 <kmc> it makes them bad and you should feel bad
14:17:07 <kmc> anyway
14:17:10 <kmc> i have a Haskell question
14:17:19 <kmc> i'm writing a tiny library
14:17:25 <kmc> the only GHC extension it uses is ScopedTypeVariables
14:17:28 <monochrom> what new lib have you written again?
14:17:28 <theorbtwo> On #haskell?  How bizarre.
14:17:36 <Peaker> kmc: IMO, C code by good programmers rarely has any of the buffer overruns/etc...  assertions guard array accesses (except performant-bottlenecked ones) and the awful awful stdlib is not used
14:17:40 <kmc> should i keep that, or jump through the usual hoops to keep it Haskell 98-ish?
14:17:54 <monochrom> god, every time we go off-topic, kmc has a new lib to name and upload
14:18:01 <kmc> Peaker, you're wrong and i don't care to explain why
14:18:03 <Eduard_Munteanu> Assertions can usually be turned off by a compile-time option.
14:18:05 <monochrom> conclusion: we should do this more :)
14:18:06 <kmc> it would be off topic anyway
14:18:10 <kmc> monochrom, it's the same lib :/
14:18:13 <chrisdone> kmc: For portability concern?
14:18:16 <monochrom> hahaha
14:18:16 <drdo> Peaker: It's not so much about errors, it's more about it being way harder than it needs to be
14:18:20 <benmachine> kmc: it depends a little on how extensively you use it, but I've always thought of ScopedTypeVariables as one of the easier extensions to circumvent
14:18:26 <Peaker> drdo: Yes, I agree C is harder than it needs to be
14:18:37 * chrisdone forgets other implementations than GHC exist these days…
14:18:43 <kmc> chrisdone, I guess.  I feel like any self-respecting Haskell implementation should support this extesion, though
14:18:47 <Peaker> drdo: But I disagree that C code inevitably is full of security problems, too
14:18:47 <kmc> chrisdone, but they have cool features GHC doesn't!
14:18:48 <drdo> You spend a lot of time worrying about things that are conceptually simple
14:19:08 <theorbtwo> Portability is a nice feature, but it's a feature.  Consider the tradeoff like you would any other feature.
14:19:08 <monochrom> how painful is it to not use ScopedTypeVariables in your lib?
14:19:10 <drdo> Peaker: I agree with you
14:19:34 <kmc> monochrom, it will just look ugly.  the library is about 16 lines of code total, it's not going to get that terrible
14:19:42 <Peaker> drdo: well, I don't feel that I worry about conceptually simple things as much as I fell that C encourages/forces me to think about how to write things not only correct and modular, but also machine-friendly, which is inherently a more complicated problem..  Sometimes it's not justified, perhaps
14:19:45 <drdo> Peaker: There's also an interesting thing that happens with very large C projects, you tend to be less performant than the same program written in another language
14:19:47 <chrisdone> I'd personally consider it someone else's problem. If they want to use it on blah random compiler, they should make that judgement call.
14:19:58 <benmachine> kmc: if it's only 16 lines of code I'd say drop the extension, it can't be that essential :P
14:20:05 <theorbtwo> Are you likely to want to use this library on a compiler without ScopedTypeVariables?  Are other people?  Is it hard to retrofit later?
14:20:20 <Peaker> drdo: that is often the case -- unless performance is the top concern, a lot of the time
14:20:29 <monochrom> wait, I think your lib does some other things that are ghc-specific too, right?
14:20:32 <benmachine> kmc: but I've always had a thing against ScopedTypeVariables because I find the h98 ways of doing it cute, so I wouldn't listen to me too much
14:20:40 <drdo> Peaker: An example would be gobject
14:21:02 <Peaker> drdo: that library doesn't seem to have performance as a concern -- it seems to try to emulate high-level languages in C at the expense of performance
14:21:03 <chrisdone> kmc: If I want to use your library on an old compiler that's my problem.
14:21:15 <Peaker> drdo: come to #-blah?
14:21:29 <benmachine> does JHC have scopedtypevariables?
14:21:35 <benmachine> or any of the others that I forget
14:21:37 <Peaker> chrisdone: but you're encouraging making compatible Haskell compilers harder and harder :-(
14:21:41 <kmc> monochrom, yeah, the whole idea of ByteString -> Vector conversion is arguably GHC specific
14:21:44 <Eduard_Munteanu> Well if you go about making vtables in C it's not really that easy to get things layed out as a C++ compiler would, for optimal performance.
14:22:00 <kmc> is ByteString supported by other compilers? how different is it?
14:22:04 <dylukes> what are vtables ._.?
14:22:15 <kmc> oh, I remember the code having some ifdefs for other compilers at least
14:22:24 <monochrom> I seem to recall hugs can do certain bytestring versions too
14:22:35 <kmc> dylukes, a struct containing (pointers to) methods for your object
14:22:44 <Eduard_Munteanu> dylukes: do you know about virtual methods?
14:22:50 <kmc> that's how you can select the implementation based on the runtime type
14:22:53 <dylukes> nope~
14:22:58 <dylukes> I don't know about any of this fancy C++ stuff :(
14:23:05 <monochrom> vtable is for dynamic dispatch
14:23:07 <kmc> in Java (almost) all methods are virtual
14:23:11 <dylukes> oh, I see
14:23:12 <Eduard_Munteanu> I don't know much myself either.
14:23:14 <chrisdone> Peaker: Haskell from five years ago looks different to Haskell today… code becomes more concise, less workarounds; compilers should evolve, don't you think so?
14:23:18 <dylukes> its a dynamic dispatch table then
14:23:21 <kmc> anyway if B inherits from A, you might pass a B to a function that expects an A, but it still needs to call B's methods
14:23:23 <kmc> yeah
14:23:23 <dylukes> but how is it so optimized/different
14:23:33 <dylukes> kmc: covariance, egads.
14:23:34 <Eduard_Munteanu> It only makes sense with virtual functions.
14:23:53 <theorbtwo> Perhaps what should happen is that the good extensions that have happened since h98 should get bundled up and called h12?
14:23:54 <Eduard_Munteanu> Otherwise dispatching would be straightforward.
14:24:30 <chrisdone> Peaker: Personally, I frankly have better things to be doing than surveying the support across various different compilers, like getting the job done… Lispers spend all day worrying about portability and look at their library landscape.
14:24:36 <theorbtwo> (Dispite the y2k bug, h2012 seems like an obnixious name.)
14:24:41 <joe6_> i have 2 lists (one comment element) and I want to arrange the elements of the second list in the order of the elements of the first list. Any suggestions on something in the library that can do that?
14:24:42 <Eduard_Munteanu> kmc: admittedly that's usually the case in C++ projects too
14:24:47 <Eduard_Munteanu> (especially libs)
14:24:52 <Eduard_Munteanu> If I'm not mistaken.
14:24:53 <joe6_> s/one comment/one common/
14:24:56 <kmc> Eduard_Munteanu, what is?
14:25:12 <Eduard_Munteanu> kmc: most methods being virtual
14:25:21 <kmc> it's not really the case in C++, it depends
14:25:35 <joe6_> theorbtwo: isn't that agda?
14:25:41 <Peaker> chrisdone: well, currently only ghc is viable.. I think it might be helpful to avoid superfluous uses of extensions if it makes it easier for other compilers to enter the scene which would be good for everyone
14:25:50 <kmc> anyway, vtables are a concept in implementing OOP, not a concept in implementing C++.  i claim that any time you try to explain an OOP-related concept by reference to C++, you've pretty much lost
14:25:58 <Eduard_Munteanu> No, I mean it's just how people go about writing C++ code.
14:26:13 <theorbtwo> Lots of C libraries rely on things not in the spec ... but which any sane implementation does anyway.  Not in the "extensions" sense, in the "implementation details" sense, though.
14:26:23 <chrisdone> Peaker: How do you define superfluous?
14:26:25 <mikeg> chrisdone: Why is the pgsql-simple.withPoolConnection of type (... -> m a) -> m () ? Wouldn't it be useful to be able to query with a connection pool?
14:26:39 <jaj> theorbtwo: you mean undefined behaviour in C?
14:26:40 <Eduard_Munteanu> I usually mention C++ because I don't know the others well enough :)
14:26:46 <theorbtwo> jaj: Yes.
14:27:22 <theorbtwo> Eduard_Munteanu: You'll also find that libg (GObject) uses a vtable, for example.
14:27:24 <monochrom> the isomorphism is complete
14:27:39 <Eduard_Munteanu> And Wine.
14:27:48 <kmc> relying on undefined behavior regularly screws people, though
14:28:33 <monochrom> the isomorphism being completed: both directions of: talking about C leads to kmc having a haskell question; kmc having a haskell question leads to talking about C.
14:28:36 <chrisdone> mikeg: Mostly to discourage people returning the Connection value and trying to re-use it.
14:28:38 <joe6_> List A = [Item1], List B = [(Item1,Item2)] and I want to sort List B elements in the order of List A elements.
14:28:40 <kmc> :D
14:28:47 <kmc> :t sortOn
14:28:48 <lambdabot> Not in scope: `sortOn'
14:28:50 <kmc> :t sortWith
14:28:52 <lambdabot> Not in scope: `sortWith'
14:28:54 <kmc> fuck man
14:28:58 <Peaker> chrisdone: little effort to replace
14:28:59 <Eduard_Munteanu> http://lwn.net/Articles/444910/
14:29:04 <kmc> :t sortBy
14:29:05 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
14:29:10 <monochrom> please don't fuck man.
14:29:16 <kmc> :t sortBy (comparing fst) -- joe6_
14:29:18 <lambdabot> forall a b. (Ord a) => [(a, b)] -> [(a, b)]
14:29:18 <Peaker> chrisdone: btw: About surveying support -- you don't need to. That's what the H98/H2010 standards do for you
14:29:20 <Eduard_Munteanu> A LWN article about OOP in Linux and such
14:29:22 <theorbtwo> kmc: Depends on the undefined behavior.  Relying on the contents of uninitlized memory, very bad.  Relying on being able to malloc an extra-large area and then go off the end of an array at the end of a struct, quite portable, but not technically defined.
14:29:28 <Eduard_Munteanu> (the Linux kernel I mean)
14:29:33 <chrisdone> Peaker: If I followed those standards I'd get nothing done. :-)
14:29:45 <mikeg> But I can still get the Connection out with an IORef.. which is the only way I can see to get the query results out currently?
14:29:47 <kmc> theorbtwo, C99 has a nicer way to do that one anyway
14:29:56 <chrisdone> H2010 allowed '.' in module names. Gee, so progressive!
14:30:04 <joe6_> kmc, thanks a lot.
14:30:08 <theorbtwo> Perl, which is crazily portable, relies on that one.  Nobody even bothered to document it being required for decades, because everybody could do it.
14:30:13 <monochrom> yeah, it should allow ';' too
14:30:15 <benmachine> who do I talk to about getting a package deprecated?
14:30:17 <Peaker> chrisdone: IME (admittedly I wrote only a few medium sized projects and no very large project in Haskell), most non-H98 things can be localized to a module (e.g: ST/higher-rank use is my most common one.. Existential types can usually be encoded relatively easily in other means)
14:30:19 <theorbtwo> kmc: Yes, but relying on the undefined behavior is more portable then c99.
14:30:27 <kmc> even relying on memory writes happening in the order you say will screw you on SMP systems
14:30:34 <mikeg> sorry if I caught you in the middle of a different discussion :o)
14:30:44 <thoughtpolice> benmachine: ross patterson
14:30:48 <kmc> existential types can be encoded as rank-2 types via a continuation passing style
14:30:49 <benmachine> thoughtpolice: thanks
14:30:51 <monochrom> benmachine: I guess someone uploads a new version to mark it deprecated
14:30:58 <benmachine> monochrom: it's my package
14:31:10 <monochrom> oh nevermind, I guess wrong
14:31:15 <benmachine> I can change the description and synopsis and everything to go "this is rubbish"
14:31:15 <thoughtpolice> well, ross can *actually* deprecate things and make them not appear
14:31:17 <Peaker> chrisdone: Oh, right, hierarchial modules are pretty trivial so even before H2010 they were legit :)
14:31:20 <thoughtpolice> unless you explicitly search for them
14:31:21 <benmachine> but I can't take them off the package list
14:31:22 <chrisdone> mikeg: Alternatively you can return it from a module.
14:31:27 <thoughtpolice> er, not even search for them
14:31:35 <thoughtpolice> i think you have to know the exact package name and go to that URL
14:31:38 <chrisdone> mikeg: Er, a monad. Sorry, Peaker's message distracted me.
14:31:39 <Peaker> kmc: well, Rank-2 is also a problem..
14:32:03 <chrisdone> mikeg: But yeah, I can change it, it's not like the API is set in stone, I whipped it up to solve my own problem.
14:32:24 <monochrom> that gives me a pun idea...
14:32:25 <chrisdone> Peaker: Let me see my own uses.
14:33:03 <Peaker> chrisdone: GADTs are pretty awesome but usually they increase guarantees and not power, so it's probably not hard to localize/reimplement in H2010 if needed
14:33:04 <thoughtpolice> benmachine: also, i looked at the backlog, and yeah, pointer aliasing messes up many potential optimizations in C, but it still seems to be quite fast. :P but it really is a problem
14:33:15 <mikeg> Yeah that is how I solved it locally (by changing the definition). I was just worried maybe connection pools *shouldn't* be used for queries or something
14:33:41 <benmachine> thoughtpolice: it was just interesting because up until I read that I had always just gone "C = fast" in my head
14:33:57 <benmachine> thoughtpolice: but it highlighted the fact that actually more control doesn't always mean more speed
14:34:58 <thoughtpolice> benmachine: yeah, eventually even simple examples can be tricky when you actually think about aliasing. for example, given f(int *a, int *b) { *a = 0; *b = 1; return b; } can the compiler rearrange the assignments ? nope, because 'a' and 'b' could alias :(
14:35:23 <benmachine> yeah
14:35:31 <Eduard_Munteanu> f(restrict int *a, restrict int *b)  :P
14:35:42 <benmachine> I mean, restrict is supposed to fix that, but it feels like a sticking plaster
14:35:43 <Eduard_Munteanu> Actually many projects turn on strict aliasing rules.
14:35:46 <Eduard_Munteanu> for GCC
14:35:49 <benmachine> not an actually good way of fixing the problem
14:36:06 <theorbtwo> Yes, but there are now strict rules on what can and cannot alias.  In fact, there were always strict rules, but gcc didn't previously actually make such programs go splat.
14:36:07 <benmachine> Eduard_Munteanu: strict aliasing bugs are really obnoxious though
14:36:14 <theorbtwo> A *lot* of things got hit by that.
14:36:16 <Eduard_Munteanu> Yeah.
14:36:36 <Peaker> how come Hayoo! doesn't find stuff if you just change the argument order??
14:36:41 <Peaker> I thought it was kinda based on Hoogle
14:36:42 <monochrom> "this summer, Haskell 1984 is coming to a theatre near you! Haskell 1984 is the latest and most correct rendition of the novel 1984. Starring: Ross Patterson as Winston Smith; lambdabot as Julia; and Simon Peyton Jones as O'Brien. Remember: Ceiling cat is watching you unsafePerformIO!"
14:36:58 <Eduard_Munteanu> Maybe if GCC would have to prove they don't alias?
14:37:00 <hpaste> int80_h pasted “dependency hell.” at http://hpaste.org/48172
14:37:02 <chrisdone> Peaker: Hm. I'm currently using these in one project:
14:37:04 <chrisdone> > fmap (nub.words) $ readFile "x.txt"
14:37:04 <chrisdone> ["ViewPatterns","TypeFamilies","TypeOperators","FlexibleContexts","TemplateHaskell","GeneralizedNewtypeDeriving","MultiParamTypeClasses","FlexibleInstances","UndecidableInstances","TypeSynonymInstances","LiberalTypeSynonyms","QuasiQuotes","PackageImports","TupleSections","RecordWildCards","ScopedTypeVariables","OverloadedStrings","NoMonomorphismRestriction","NamedFieldPuns","DeriveDataTypeable","StandaloneDeriving","PatternGuards","NoOverloadedS
14:37:04 <chrisdone> trings"]
14:37:06 <lambdabot>   <IO [[Char]]>
14:37:10 <monochrom> ... all because Ross Patterson's job is erasing your package from history completely :)
14:37:13 <benmachine> Peaker: I think it's less clever than hoogle in that respect, that's been my impression anyway
14:37:32 <Eduard_Munteanu> (I think there's some -W goodness there too, not sure)
14:38:22 <Peaker> benmachine: why not just hoogle-index all of hackage in Hayoo and use Hoogle?  Why did they reimplement hoogle poorly?
14:38:39 <benmachine> Peaker: pass. maybe hayoo is more clever in other ways
14:39:00 <int80_h> could someone look at my hpaste? Having trouble with dependencies.
14:39:18 <Peaker> benmachine: I was showing Hayoo to someone as a cool Haskell thing assuming it was Hoogle and it screwed up my demo.. Change arg order -- bam, no match
14:39:42 <Peaker> "look, it of course works if you change the arg order" -- "eh, no it doesn't"
14:40:02 <benmachine> :P
14:40:08 <benmachine> stick to hoogle
14:40:50 <chrisdone> Peaker: I think we're from difficult to reconcile worlds on this. I'm very happy using the language extensions provided by GHC and restricting my code to non-H98 would make most of my code needlessly bigger, the notion of localising or reimplementing is something I'd only think about if I were personally porting a library because I wanted to use some out of date compiler. It's a waste of time to even bother thinking about this stuff up front.
14:42:22 <Peaker> chrisdone: well, I also use some of these extensions, but I do give it a moment's thought.. How hard would it be without the extension. I just use the extension if it is more than a few minutes of effort not to
14:44:39 <chrisdone> The lispers at work waste time debating on whether to use a perfectly convenient function because it's not portable. Bleh.
14:46:00 <monochrom> lispers seem to be dining philosophers
14:46:39 <acowley> the kind with too few chopsticks or too few spoons?
14:47:08 <monochrom> with too many forks and they start using forks as weapons
14:47:16 <acowley> hahaha
14:48:05 <chrisdone> Hell is all the guys eating but their chopsticks are six feet long and they can't get the food into their mouths. Heaven is the same, but they're feeding eachother. :-)
14:48:07 <acowley> TIL: Generations of poor students have suffered because lispers stab each other with forks.
14:49:15 <acowley> PLT = http://kuusisto.typepad.com/.a/6a00d8341dbac353ef0133f369b473970b-800wi
14:49:43 <acowley> This should have been my answer earlier when augur asked about intro to PL material
14:50:30 * hackagebot stdata 0.0.4 - Structure Data Library  http://hackage.haskell.org/package/stdata-0.0.4 (DavidDarais)
14:51:11 <chrisdone> I once booted up mzscheme and saw this: http://img406.imageshack.us/img406/4841/whattheve9.png
14:51:27 <acowley> Eli!
14:51:54 <chrisdone> eli♥
14:53:56 <acowley> chrisdone: hang this up in the office and point to it when you get particularly frustrated: http://globalnerdy.com/wordpress/wp-content/uploads/2007/10/john_mccarthy_successories_poster.jpg
14:54:14 <danharaj> Is there any way I can speed up my code if I know I'm using a data structure ephemerally instead of persistently?
14:54:47 <kmc> which datastructure?
14:54:58 <kmc> do you mean local changes to the code only?
14:55:10 <chrisdone> acowley: I should print off Dijkstra and put it up on the wall behind me, so he's always looking over my shoulder, not liking it.
14:55:18 <kmc> 'cause you can rewrite it using ST, but that's usually a big change
14:55:20 <danharaj> kmc: A balanced binary tree. And I mean I am threading a structure through a recursive function, accumulating on it.
14:55:34 <kmc> you're threading the tree?
14:55:38 <danharaj> yeah.
14:55:59 <kmc> well, you probably *are* using it persistently, because most tree update functions will give you a tree which shares some nodes with the old tree
14:56:11 <kmc> that being much of the appeal of persistent data structures
14:56:24 <danharaj> kmc: Indeed, but can I somehow tell GHC to perform in-place updates?
14:56:32 <monochrom> no
14:56:40 <kmc> by rewriting your code to use ST
14:56:45 <monochrom> but there is a new and faster hash table if you want
14:56:58 <kmc> that said there is
14:57:00 <kmc> http://hackage.haskell.org/package/linear-maps
14:57:05 <danharaj> monochrom: I heard, and I'm glad :p They should put it in the next version of containers.
14:57:05 <kmc> it scares me and i don't know much about it
14:57:36 <danharaj> kmc: So I rewrite my code to be a ST value, and I keep the tree in an STRef?
14:57:49 <kmc> well, a STRef holding a tree won't save you much
14:58:00 <kmc> because it's just holding a pointer to an immutable tree
14:58:00 <danharaj> As I thought.
14:58:08 <monochrom> no that simple. implement the data structure with STRef's all the way down
14:58:09 <kmc> you'd need, like, a statically shaped tree of STRefs
14:58:24 <kmc> or even not static -- grow the ref-tree as needed, and mutate in place otherwise
14:58:34 <kmc> won't be pretty and i don't expect it will be much faster
14:58:45 <kmc> can you give us some more parameters about what you're doing and what the performance requirements are?
14:58:56 <kmc> i bet there's a better pure data structure -- maybe hash tries, as someone suggested
14:59:22 <monochrom> balancing a mutable tree is a delicate balancing act :)
14:59:58 <shachaf> monochrom: More than an immutable tree?
15:00:16 <kmc> if you tree is mutable then you can use a splay tree
15:00:18 <danharaj> kmc: I'm implementing the bentley-ottmann algorithm for intersecting a collection of line segments. I keep two data structures: A min-heap, and a search tree. My ordering for the search tree changes at certain points in the algorithm, but there's a procedure for fixing it up. Basically, the two operations I have on the tree are: Insert a node using the current ordering, and swap two nodes when the ordering changes.
15:00:21 <kmc> i don't know if that's a good idea, though
15:00:46 <danharaj> I can't use Data.Set because the ordering is not fixed.
15:01:05 <monochrom> yes, more.
15:01:05 <kmc> but Data.Set is probably not much different from what you have implemented, anyway
15:01:07 <jaj> if you "modify" a data structure, for example with record syntax, will ghc actually delete and recreate a new data structure internally or will it just change the pointer of the modified element?
15:01:21 <kmc> jaj, it will create a new record, whose fields are mostly the same pointers as the old record
15:01:27 <kmc> there's no in-place update
15:01:51 <jaj> hmm, wouldn't an in-place update benefit performance?
15:01:57 <kmc> yes
15:02:10 <kmc> it would also break all of the nice things about Haskell
15:02:19 <danharaj> The reason why I'm concerned about the copying is because I'd like to minimize the memory use of these basic algorithms.
15:02:36 <kmc> the compiler could infer linear use of data, to some degree, but that's in general very hard
15:03:01 <danharaj> Also, I'd like to learn how to create efficient mutable data structures to round out my skills.
15:03:19 <kmc> jaj, right now if you want to use mutation in Haskell you just write it in imperative style, using IO or ST or such
15:03:32 <monochrom> I actually have http://hackage.haskell.org/package/hashtables in mind
15:03:37 <kmc> ST has the advantage that a "closed universe" of mutable state can be turned into a pure result value
15:03:59 <dylukes> kmc: can safely be...*
15:04:05 <dylukes> IO can too, using unsafePerformIO
15:04:08 <kmc> yeah, fair enough
15:04:10 <jaj> kmc: I don't understand why it would break anything, it's just internal memory management that is not exposed to the programmer, it's a matter of not touching data instead of copying it and deleting the initial copy
15:04:17 <dylukes> and of course, it does for the duration of the entire program, the only safely performed IO...
15:04:23 <dylukes> the final return value is a "pure" value arguably.
15:04:31 <danharaj> jaj: What if the old version is used later?
15:04:34 <kmc> jaj, the compiler doesn't know in general that you won't use both the old and new versions of that record
15:04:53 <dylukes> kmc: So lets see, thinking about my language still.
15:05:00 <dylukes> :\
15:05:09 <dylukes> Maybe I should adopt agda style mix fixing. that might be nice.
15:05:15 <dylukes> as a later thing to do, once the basics work
15:05:17 <jaj> kmc: hmm yeah true
15:05:19 <kmc> dylukes, do you know how to parse it?
15:05:31 <danharaj> Has anyone thought about a linear types extension for GHC?
15:05:43 <djahandarie> Why do you want linear types?
15:05:53 <danharaj> or uniqueness types, perhaps.
15:05:54 <kmc> jaj, most Haskell data structures make heavy use of sharing between different "versions" of a value
15:05:55 <dylukes> kmc: Nope TT_TT
15:06:03 <kmc> it's also extremely useful to avoid mutable updates in a concurrent context
15:06:09 <dylukes> That aspect of it looks brutally difficult.
15:06:14 <kmc> you can just grab a pointer, operate on it locklessly as long as you want, and then do an atomic pointer swap later
15:06:26 <kmc> it's very much like RCU, actually
15:06:40 <danharaj> djahandarie: To help the compiler find places where it can perform in-place updates.
15:06:43 <kmc> (remember, every concept in the history of programming has at least two names: the name used by functional programmers, and the name used by everyone else)
15:07:03 <dylukes> kmc: so true...
15:07:11 <shachaf> kmc: Are there that many examples of that?
15:07:16 <kmc> i'm extremely confused because danharaj and djahandarie are talking to each other and their nicks are basically the same
15:07:22 <danharaj> The right name, and the name everyone else uses.
15:07:26 <kmc> i point this out mostly because people won't stop saying the same about me and ksf
15:07:32 <danharaj> heh :p
15:07:36 <shachaf> That's before you bring geheimdienst into it.
15:07:52 <kmc> shachaf, "hash consing" vs "featherweight pattern"
15:08:02 <kmc> two completely different, totally useless names
15:08:03 <djahandarie> Apparently I can't say anything in here anymore without it turning into a discussion about nicknames.
15:08:14 <dylukes>  kmc  I thought you are ksf
15:12:10 <sgronblo> any idea when haskell-platform will be fixed in ubuntu?
15:17:48 <hilbert> e
15:17:52 <hilbert> nvm
15:22:26 <Eduard_Munteanu> djahandarie: I found ivan and ivanm quite confusing ;)
15:33:06 * Peaker reads the backlog and sees images posted with Hebrew on them :)
15:37:37 <shachaf> Peaker: Speaking of which, does the MzScheme logo look like the Tnuva logo to you?
15:38:06 <ivan> Eduard_Munteanu: ivanm is the smart one
15:38:19 <ivan> I live in the Python salt mines
15:38:38 <Egbert9e9> i've been googling around and i'm terribly confused with haskelldb
15:39:03 <Lemmih> Egbert9e9: That's normal.
15:39:06 <Egbert9e9> lol
15:40:42 <Peaker> shachaf: haha, yeah :)
15:42:10 <Egbert9e9> i thought not learning sql would be easier than using less high level libs that get sql commands in sql language
15:42:25 <Egbert9e9> not learning and using haskelldb instead
15:43:49 * hackagebot MaybeT-monads-tf 0.2.0.1 - MaybeT monad transformer compatible with monads-tf (deprecated)  http://hackage.haskell.org/package/MaybeT-monads-tf-0.2.0.1 (BenMillwood)
15:49:43 <benmachine> do language pragmas go before or after haddock module comments, or doesn't it matter?
15:50:00 <Lemmih> benmachine: It doesn't matter.
15:50:21 <Lemmih> benmachine: I like to put them before.
15:50:38 <Eduard_Munteanu> Heh :)
15:50:39 <benmachine> k
15:50:49 <bos> pretty much everyone puts them before
15:51:47 <Lemmih> benmachine: Bow to our peer pressure!
15:52:43 <benmachine> Lemmih: duly bowed
15:52:58 <benmachine> (my machine of death card said "peer pressure", eep)
16:17:39 <joe6_> kmc, i think sortBy is not helping. I want to order the elements of List B in the order of the elements in List A.
16:17:45 <joe6_> the List A is not ordered
16:17:48 <joe6_> List A = [Item1], List B = [(Item1,Item2)] and I want to sort List B elements in the order of List A elements.
16:18:07 <joe6_> the sortBy seems to take a single vector
16:18:21 <joe6_> and, not take 2 lists
16:18:22 <ddarius> Holy mackerel!  It's jfredett!
16:19:29 <joe6_> almost like a look-up function
16:19:51 <aavogt> Lemmih: did ghc always not count comment lines when looking for LANGUAGE pragmas?
16:19:54 <magicman> joe6_: can you define a function that takes List A, and two items, and determines if the first item is less than, equal to, or greater than the second?
16:20:23 <aavogt> a while back it used to be quite sensitive to putting them more than a couple lines in
16:20:27 <fxr> hi, do we have a ZDD library?
16:20:47 <joe6_> magicman, but the List A is not sorted.
16:21:12 <magicman> joe6_: Ahh. So... what should the result be for [Item1] and [(Item1,Item2)] ?
16:21:44 <joe6_> just [(Item1,Item2)], where the Item1 = List A
16:21:54 <magicman> (you realize that [(Item1, Item2)] is a 1-element list, which has a 2-element tuple, right?)
16:22:01 <joe6_> magicman, let me explain
16:22:02 <zygoloid> joe6_: nonetheless you can define such a function. suppose you build a Map Item1 Int from List A, and use that to determine how to compare items in List B
16:22:29 <Saizan> magicman: (unless it's a type?)
16:23:07 <magicman> Right.
16:23:24 <magicman> Ah, I see.
16:24:24 <joe6_> List A = [6,5,1,7,8,9], List B = [(1,99),(5,88),(7,77),(8,88),(6,66),(9,55)] and I want Sorted List B to be [(6,66),(5,88),(1,99...(9,55)]
16:24:24 <magicman> So... If you pass it [1,4,3,2] and [(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")], it should return [(1,"one"),(4,"four"),(2,"two"),(3,"three")] ?
16:24:43 <joe6_> magicman, yes
16:25:27 <zygoloid> > (\as -> sortBy (comparing (flip M.lookup (M.fromList (zip as [0..])) . fst))) [5,1,3,2,4] [(1,'a'), (3,'c'), (4,'d'), (5,'e')]
16:25:29 <lambdabot>   [(5,'e'),(1,'a'),(3,'c'),(4,'d')]
16:25:33 <magicman> Apologies for the misinterpretation from earlier, then.
16:25:51 <magicman> :t mapMaybe
16:25:52 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
16:26:02 <joe6_> magicman, no need to apologize. Thangs for trying to help.
16:26:13 <joe6_> s/Thangs/Thanks/
16:26:25 <zygoloid> joe6_: ^^ is that what you want?
16:27:24 <joe6_> zygoloid: i am trying to understand the code. But, the result is exactly what i want.
16:28:01 <joe6_> zygoloid: what is M?
16:28:09 <Peaker> Data.List.Stream paper claims it is just a "proof of concept"... any progress since then?
16:28:22 <magicman> joe6_: Qualified name for Data.Map
16:28:30 <zygoloid> joe6_: lambdabot has: import qualified Data.Map as M
16:28:45 <joe6_> zygoloid: ok, thanks a lot.
16:28:58 <zygoloid> np. do you see how it works?
16:29:09 <joe6_> i will break it down.
16:29:17 <ion> > let m = M.fromList [(1,99),(5,88),(7,77),(8,88),(6,66),(9,55)] in map (flip M.lookup m) [6,5,1,7,8,9]
16:29:18 <lambdabot>   [Just 66,Just 88,Just 99,Just 77,Just 88,Just 55]
16:29:20 <Saizan> > let a = [5,1,3,2,4]; b = M.fromList [(1,'a'), (3,'c'), (4,'d'), (5,'e')] in map (b M.!) a
16:29:21 <lambdabot>   "eac*Exception: Map.find: element not in the map
16:29:25 <magicman> joe6_: The trick is to define a function "cmp :: [a] -> (a,b) -> (a,b) -> Ordering" (possibly including an Eq a or Ord a constraint).
16:29:27 <ion> > let m = M.fromList [(1,99),(5,88),(7,77),(8,88),(6,66),(9,55)] in map ((,) <*> flip M.lookup m) [6,5,1,7,8,9]
16:29:29 <lambdabot>   [(6,Just 66),(5,Just 88),(1,Just 99),(7,Just 77),(8,Just 88),(9,Just 55)]
16:29:44 <ion> > let m = M.fromList [(1,99),(5,88),(7,77),(8,88),(6,66),(9,55)] in map ((,) <*> fromMaybe 0 . flip M.lookup m) [6,5,1,7,8,9]
16:29:46 <lambdabot>   [(6,66),(5,88),(1,99),(7,77),(8,88),(9,55)]
16:31:30 <magicman> joe6_: Also, it probably needs a postprocess or preprocess step to remove the (a,b) items for which the a is not in the list.
16:32:35 <magicman> > let f l1 l2 = mapMaybe (\x -> M.lookup x (M.fromList (map (\(k,v) -> (k,(k,v))) l2))) l1 in f [1,4,3,2] [(1,"1"),(2,"2"),(3,"3"),(4,"4"),(5,"5")]
16:32:36 <lambdabot>   [(1,"1"),(4,"4"),(3,"3"),(2,"2")]
16:33:22 <magicman> (works, too. Mapping a lookup over the list that determines the order, instead of doing a lookup for every comparison)
16:33:37 <joe6_> magicman, a is always in the list
16:33:55 <magicman> Okay :)
16:35:25 <joe6_> @hoogle Data.Map.!
16:35:25 <lambdabot> Parse error:
16:35:25 <lambdabot>   --count=20 Data.Map.!
16:35:25 <lambdabot>                  ^
16:35:31 <magicman> > let f l1 l2 = mapMaybe (\x -> fmap ((,) x) M.lookup x (M.fromList l2)) l1 in f [1,4,3,2] [(1,"1"),(2,"2"),(3,"3"),(4,"4"),(5,"5")]
16:35:32 <lambdabot>   Couldn't match expected type `t -> Data.Maybe.Maybe b'
16:35:32 <lambdabot>         against infe...
16:35:42 <joe6_> @hoogle M.!
16:35:42 <lambdabot> Parse error:
16:35:42 <lambdabot>   --count=20 M.!
16:35:42 <lambdabot>                 ^
16:35:48 <ion> @hoogle (Data.Map.!)
16:35:49 <lambdabot> Parse error:
16:35:49 <lambdabot>   --count=20 (Data.Map.!)
16:35:49 <lambdabot>                   ^
16:35:50 <magicman> > let f l1 l2 = mapMaybe (\x -> fmap ((,) x) $ M.lookup x (M.fromList l2)) l1 in f [1,4,3,2] [(1,"1"),(2,"2"),(3,"3"),(4,"4"),(5,"5")]
16:35:51 <lambdabot>   [(1,"1"),(4,"4"),(3,"3"),(2,"2")]
16:36:29 <dmwit> What would you want Hoogle to tell you if you already know the module and function name?
16:36:34 <joe6_>  = [5,1,3,2,4]; b = M.fromList [(1,'a'), (3,'c'), (4,'d'), (5,'e'),(2,'f')] in map (b M.!) a
16:36:53 <joe6_> > let a = [5,1,3,2,4]; b = M.fromList [(1,'a'), (3,'c'), (4,'d'), (5,'e'),(2,'f')] in map (b M.!) a
16:36:53 <lambdabot>   "eacfd"
16:37:00 <dmwit> ?hoogle (!)
16:37:01 <lambdabot> Data.IntMap (!) :: IntMap a -> Key -> a
16:37:01 <lambdabot> Data.Map (!) :: Ord k => Map k a -> k -> a
16:37:01 <lambdabot> Text.Html (!) :: ADDATTRS a => a -> [HtmlAttr] -> a
16:45:43 <aristid> @pl mapMaybe (\(a,b) -> fmap (a,) b)
16:45:43 <lambdabot> (line 1, column 28):
16:45:43 <lambdabot> unexpected ","
16:45:43 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
16:45:59 <aristid> @pl mapMaybe (\(a,b) -> fmap (\x->(a,x)) b)
16:45:59 <lambdabot> mapMaybe (uncurry (fmap . (,)))
16:48:01 <ion> @pl mapMaybe (\(a,b) -> (,) a <$> b)
16:48:01 <lambdabot> mapMaybe (uncurry ((<$>) . (,)))
16:50:23 * hackagebot configurator 0.0.1.1 - Configuration management  http://hackage.haskell.org/package/configurator-0.0.1.1 (BryanOSullivan)
16:51:44 <Peaker> Thinking about ezyang's maximizing sharing idea (replacing (a -> a) funcs with (a -> Maybe a) funcs) -- for map is it right to have type:  (a -> Maybe a) -> [a] -> Maybe [a]  and not:  (a -> Maybe a) -> [a] -> ListT Maybe a  ?
16:53:38 <Saizan> with the latter type you don't have much hope of maintaining the sharing
16:58:06 <Saizan> oh, you mean you'd return only the diff?
16:59:30 <Peaker> Saizan: well, at any point in the list you might want to say: Share everything else
16:59:56 <Peaker> Saizan: I guess for ezyang's original purpose it was not useful, since slices of the sub-structure are not used in his examples
17:00:47 <Saizan> you could even go farther with ListT Maybe (Maybe a)
17:01:12 <ash_> so... I am still a bit new at haskell, but if I wanted to debug code that uses the FFI does anyone have any suggestions?
17:02:28 <jfmiller28> Is there a monadic version of (:)
17:02:54 <Saizan> ?type liftM2 (:) -- ?
17:02:55 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m [a1] -> m [a1]
17:03:39 <DukeDave> Hey, does anyone in here have experience with wxHaskell? Why is only 'paintBar' being painted?
17:03:39 <DukeDave>     panel   <- panel frame [on paint := (paintFoo >> paintBar)]
17:03:42 <Peaker> Saizan: heh
17:04:16 <joe6_> any suggestions on how to fix this: http://pastebin.com/YnxqDqK8
17:04:18 <mauke> The paste YnxqDqK8 has been copied to http://hpaste.org/48173
17:04:47 <joe6_> which map is it using.
17:05:06 <joe6_> i tried both Data.List.map and Data.Map.map
17:05:22 <jfmiller28> what about (monad m)=>a -> m [a] -> m [a]
17:06:07 <joe6_> magicman, i am trying this:
17:06:13 <joe6_>  > let f l1 l2 = mapMaybe (\x -> M.lookup x (M.fromList (map (\(k,v) -> (k,(k,v))) l2))) l1 in f [1,4,3,2] [(1,"1"),(2,"2"),(3,"3"),(4,"4"),(5,"5")]
17:06:24 <c_wraith> :t \a -> liftM (a:)
17:06:25 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m [a] -> m [a]
17:06:38 <Peaker> > let f (Just x) z = z in f Nothing `seq` "No problem with pattern match failures before more args"
17:06:38 <c_wraith> though I'd generally write that as
17:06:38 <lambdabot>   "No problem with pattern match failures before more args"
17:06:42 <c_wraith> :t \a -> fmap (a:)
17:06:43 <lambdabot> forall a (f :: * -> *). (Functor f) => a -> f [a] -> f [a]
17:07:15 <Peaker> http://hackage.haskell.org/packages/archive/Transhare/0.9/doc/html/src/Data-Transhare.html#transResult_laws <-- transRM uses case instead of nicer func-def matching for some reason
17:08:04 <aavogt> > let f (Just x) = \z -> z in f Nothing `seq` "depends on how you write the args?"
17:08:05 <lambdabot>   "*Exception: <interactive>:3:4-23: Non-exhaustive patterns in function f
17:09:03 <joe6_> > let f l1 l2 = mapMaybe (\x -> M.lookup x (M.fromList (map (\(k,v) -> (k,(k,v))) l2))) l1 in f [1,4,3,2] [(1,"1"),(2,"2"),(3,"3"),(4,"4"),(5,"5")]
17:09:04 <lambdabot>   [(1,"1"),(4,"4"),(3,"3"),(2,"2")]
17:09:52 <joe6_> where is the function map from?
17:10:22 <Peaker> aavogt: is this an artifact or is it well-specified?
17:10:41 <magicman> joe6_: map (\(k,v) -> (k,(k,v)) l2 -- that one?
17:10:48 <Peaker> aavogt: I'd normally expect the position of the = to be syntax sugar only, except for optimization hints like inlining
17:10:59 <magicman> That's Data.List.map. Or Prelude.map.
17:11:04 <magicman> (they're the same thing)
17:11:15 <joe6_> i get an error when I use that.
17:11:16 <aavogt> Peaker: it's a well specified that seq can tell the difference
17:11:27 <Peaker> aavogt: that sucks :-)
17:11:39 <joe6_> magicman: http://pastebin.com/dQvRtvCk
17:11:40 <mauke> The paste dQvRtvCk has been copied to http://hpaste.org/48174
17:11:51 <Peaker> aavogt: I think we should just have a Seq type-class without instances for products and functions
17:12:10 <Peaker> (or maybe no-op instances for them) and of course no lifted products
17:12:17 <magicman> > let f l1 l2 = mapMaybe (\x -> Data.Map.lookup x (Data.Map.fromList (Data.List.map (\(k,v) -> (k,(k,v))) l2))) l1 in f [1,4,3,2] [(1,"1"),(2,"2"),(3,"3"),(4,"4"),(5,"5")]
17:12:18 <lambdabot>   Not in scope: `Data.Map.lookup'Not in scope: `Data.Map.fromList'Not in scop...
17:12:29 <benmachine> Peaker: I'm not convinced lifted products are so awful
17:12:38 <magicman> > let f l1 l2 = mapMaybe (\x -> M.lookup x (M.fromList (Prelude.map (\(k,v) -> (k,(k,v))) l2))) l1 in f [1,4,3,2] [(1,"1"),(2,"2"),(3,"3"),(4,"4"),(5,"5")]
17:12:39 <lambdabot>   [(1,"1"),(4,"4"),(3,"3"),(2,"2")]
17:13:01 <Peaker> benmachine: well, bottoms are generally evil, so the more we eliminate the better :-)
17:13:19 <Peaker> benmachine: also simpler IMO to have the only value of () be ()
17:13:19 <joe6_> let me try Prelude.map
17:13:42 <Peaker> benmachine: and then suddenly we can have (a,b,c) be syntax sugar for (a,(b,c))
17:13:43 <Saizan> :t mapMaybe
17:13:44 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
17:13:48 <benmachine> Peaker: I used to think like that but it makes strictness tricky
17:13:52 <Saizan> ?hoogle mapMaybe
17:13:52 <lambdabot> Data.IntMap mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
17:13:53 <lambdabot> Data.Map mapMaybe :: Ord k => (a -> Maybe b) -> Map k a -> Map k b
17:13:53 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
17:13:57 <Peaker> benmachine: in what cases?
17:14:03 <magicman> Ahhh.
17:14:08 <joe6_> magicman: this is what I am getting on my ghci: http://pastebin.com/LuRhTxA1
17:14:09 <mauke> The paste LuRhTxA1 has been copied to http://hpaste.org/48175
17:14:11 <Saizan> joe6_: i think your problem is mapMaybe
17:14:16 <magicman> Yes. That'd be Data.Maybe.mapMaybe, and not Data.Map.mapMaybe.
17:14:23 <benmachine> Peaker: I um don't remember :P
17:14:27 <joe6_> oh, ok.
17:14:37 <Peaker> benmachine: I think maybe the laziness crowd cares too much about strictness analysis, when we should really be moving towards more totality, instead
17:14:50 <benmachine> Peaker: totality would be nice but there's a greater burden on the compiler
17:15:03 <benmachine> I don't think there's such a thing as a simpler totality checker
17:15:05 <benmachine> *simple
17:15:05 <joe6_> Saizan, that was it
17:15:12 <joe6_> thanks.
17:15:29 <Peaker> benmachine: well, I think we shouldn't mind transformations that refine programs and have less bottoms
17:15:43 <Saizan> i think you'd need strictness analysis even if you have totality if you wanted good performace
17:15:55 <benmachine> yeah, the performance concerns are a dificulty
17:16:05 <benmachine> sometimes you *want* to be eager
17:16:49 <Peaker> Saizan: to have laziness when it is beneficial?
17:16:57 <Peaker> (or vice versa, I guess)
17:18:17 <Saizan> Peaker: yeah
17:19:09 <Peaker> Saizan: well, that's OK.. I didn't like that it seemed that dcoutts/dons/third-guy's stream fusion was not put in by default -- and I got the impression it was due to nuanced strictness modifications
17:19:22 <Peaker> Saizan: if we only have strictness analysis as an optimization, everyone can be more lenient about it being a bit wrong
17:20:03 <Saizan> Peaker: iirc, foldr/build has similar problems and it's there
17:20:39 <Peaker> ah, so the better stream fusion was rejected because it still has cases of regression, because of some holes in the ghc optimizer?
17:20:55 <Peaker> because the state-machine stream processors are an awesome idea.. :-)
17:21:27 <Saizan> i don't have up to date info on it
17:22:00 <Peaker> that paper is the first time I think it clicked for me how the functional paradigm can describe extremely low-level programs reasonably while at the same time describe very high-level ones as well.. and even the low-level ones seem easier to term-rewrite/optimize than equivalent imperative ones
17:22:01 <Saizan> i think it used to not optimize nested concatMap's as well as foldr/build though
17:22:21 <Peaker> so convenient to do all your optimization passes in roughly the same language
17:22:46 <Peaker> Saizan: really? I thought foldr/build doesn't do the nested concatMap's and that stream fusion does (I'm talking about "from lists to streams to nothing at all" paper)
17:23:42 <Saizan> as i said, i'm not so familiar with the subject
17:24:27 <Saizan> anyhow, rejecting stream fusion because it doesn't preserve some bottoms is not what is usually called strictness analysis
17:24:54 <djahandarie> Peaker, fairly sure it was the other way around
17:24:56 <Peaker> yeah, sorry, I guess I meant waste of focus on refined-ness issues
17:30:42 * hackagebot bullet 0.2.1 - A wrapper for the Bullet physics engine.  http://hackage.haskell.org/package/bullet-0.2.1 (CsabaHruska)
17:32:43 * hackagebot lambdacube-engine 0.2.1 - 3D rendering engine written entirely in Haskell  http://hackage.haskell.org/package/lambdacube-engine-0.2.1 (CsabaHruska)
17:33:45 * hackagebot lambdacube-examples 0.1.2 - Examples for LambdaCube  http://hackage.haskell.org/package/lambdacube-examples-0.1.2 (CsabaHruska)
17:38:32 <ash_> does anyone know of a what haskell calls unix select? I cant seem to find an equivalent
17:38:58 <kmc> in GHC you typically would not call select yourself
17:39:07 <kmc> you would create many threads and do blocking I/O
17:39:14 <kmc> the GHC IO manager will translate this to select() automatically
17:39:25 <kmc> (or something better like epoll() or kqueue() if your platform supports it)
17:39:36 <kmc> GHC's threads are very lightweight; you can create 100,000 of them on a modest system
17:39:39 <ash_> what if I want to do an IO with a timeout?
17:39:51 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/System-Timeout.html
17:40:29 <ash_> ah, okay, thanks
17:40:59 <kmc> no problem :)
17:41:52 <dmwit> I was going to say "throw it an exception", but asking a library to throw it an exception for you is even better. =D
17:44:38 <ash_> anyone know off hand if System.IO.hWaitForInput will work on a /dev/tty device?
17:45:18 <kmc> it probably will
17:45:34 <kmc> what are you concerned about
17:46:42 <ash_> i dont know how ghc implemented its asyncio, and on os x kqueue doesnt work on /dev/tty file descriptors
17:46:52 <shachaf> Is there a reasonable way to liftIO withBinaryFile?
17:46:57 <ash_> select works, but if it used kqueue it will fail silently
17:47:07 <kmc> ash_, oh, that is very unfortunate
17:47:09 <kmc> i don't know then
17:47:24 <kmc> i know ghc 7.0 has some support for kqueue
17:47:25 <shachaf> withBinaryFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r -- I want FilePath -> (Handle -> FooT IO r) -> FooT IO r
17:47:28 <ash_> i am using the System.Hardware.Serialport library to try to communicate with a serial device
17:47:31 <kmc> don't know if it's for OS X or FreeBSD or what
17:47:40 <ash_> and it just hangs and doesnt print any sort of message as to whats wrong
17:47:46 <ash_> just trying to figure it out
17:47:48 <kmc> shachaf, I don't think you can, due to covariance / contravariance
17:47:50 * hackagebot lambdacube-examples 0.2.1 - Examples for LambdaCube  http://hackage.haskell.org/package/lambdacube-examples-0.2.1 (CsabaHruska)
17:48:00 <kmc> shachaf, but monad-peel might do it
17:48:51 * hackagebot lambdacube-bullet 0.2.1 - Example for combining LambdaCube and Bullet  http://hackage.haskell.org/package/lambdacube-bullet-0.2.1 (CsabaHruska)
17:50:59 <shachaf> kmc: Sigh... I was hoping it would be simple.
17:51:13 <shachaf> Looks like Oleg wrote a post about it, though.
17:53:54 * hackagebot stunts 0.1.0 - A revival of the classic game Stunts (LambdaCube tech demo)  http://hackage.haskell.org/package/stunts-0.1.0 (CsabaHruska)
17:58:23 <hpaste> fragamus pasted “This is from ListT done right” at http://hpaste.org/48176
18:00:02 <Peaker> @type Data.List.map
18:00:02 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:00:25 <Peaker> someone imported a different map unqualified?
18:00:30 <fragamus> I had to disambiguate because I imported something else
18:00:46 <Peaker> fragamus: don't import names like "map" unqualified?
18:01:40 <Peaker> fragamus: that ListT is not from http://hackage.haskell.org/package/List right?
18:02:11 <fragamus> right
18:02:12 <fragamus> import Data.Set
18:02:14 <fragamus> import Data.List
18:02:27 <shachaf> Wait, so there's no way to bracket/catch in a MonadIO?
18:02:38 <Peaker> fragamus: why not? :)
18:02:58 <fragamus> because...
18:03:24 <Peaker> shachaf: http://hackage.haskell.org/packages/archive/MonadCatchIO-transformers/0.2.2.2/doc/html/Control-Monad-CatchIO.html
18:03:39 <fragamus> The Haskell hierarchical libraries implement a ListT monad transformer. There are, however, some problems with that implementation.
18:03:42 <fragamus> ListT imposes unnecessary strictness.
18:03:45 <fragamus> ListT isn't really a monad transformer, ie. ListT m isn't always a monad for a monad m.
18:04:00 <Peaker> what's runListT' type? Where's the Maybe from?
18:04:44 <Peaker> fragamus: the List package is not the "standard" broken ListT, it's a real ListT where the monadic wrapper is around each rest-of-list reference in all cons cells
18:05:07 <fragamus> runListT' :: Functor m => ListT m a -> m (Maybe (a, ListT m a))
18:05:47 <fragamus> import Data.Maybe
18:09:03 <Peaker> hmm.. that seems like a weird function to have
18:09:49 <Peaker> oh, sorry, not weird, just not nice to use Maybe rather than some specialized type like ListItem, e.g:
18:09:51 <Peaker> http://hackage.haskell.org/packages/archive/List/0.4.2/doc/html/Control-Monad-ListT.html
18:13:44 <shachaf> Peaker: Sigh...
18:13:55 <Peaker> shachaf: ?
18:14:11 <shachaf> MonadCatchIO and such.
18:14:45 <shachaf> All of it is complicated, and it seems that you have to write your own instances, and so on...
18:15:25 <Peaker> shachaf: Yeah, using monad transformer stacks for large parts of a program is a bitch in practice
18:15:34 <Peaker> (localized use is nice though)
18:15:54 <Peaker> Too much code around uses IO in ways not compatible with transformers
18:16:06 <fragamus> Peaker: so, for my program I should use it sparingly, right
18:16:14 <shachaf> In this case I have Iteratee ByteString IO a that needs to read a file and write it to a handle.
18:16:24 <shachaf> Or, rather, read from a handle and write to a file.
18:16:25 <aavogt> shachaf: this is more confusing http://www.haskell.org/pipermail/libraries/2010-April/013559.html
18:16:46 <fragamus> Peaker: and they don't need to always be the same stack; the stacks should be customized to the functions that are being used
18:17:46 <fragamus> right?
18:20:00 <Peaker> fragamus: sometimes that is hard -- converting between different stacks can be a problem
18:28:09 <dmwit> some dice up ins
18:30:09 <hpaste> int80_h pasted “yesod-forms 0.2.0 confusion” at http://hpaste.org/48179
18:39:33 <dmwit> int80_h: ...did you consider adding an instance declaration for (RenderMessage Aframe FormMessage)?
18:41:44 <aavogt> int80_h: do the examples show the   mkYesod  after you define the form?
18:48:00 <int80_h> aavogt: I figured it out. The error did in fact indicate what the problem was
18:48:42 <int80_h> dmwit: I eventually noticed that. At first I didn't think the error was due to that, but rather due something indirect
18:49:00 <dmwit> Yeah, that error usually is something indirect.
18:49:11 <dmwit> But not this time! =)
18:49:21 <int80_h> okay now I have a parse error. I'm going to stare at this for a minute and then post to hpaste if I can't where the problem is
18:49:40 <dmwit> There's your problem! You accidentally an entire word at the end!
18:50:00 <int80_h> I keep ... that.
18:50:54 <int80_h> found it. I accidently a )
18:52:06 <int80_h> we have compile!
18:52:51 <tekknolagi> how do i join a list of integers into a string? [0, 1, 2, 3] -> "0123"
18:53:25 <ben> I suspect it involves turning them into strings individually and then concatenating them
18:53:30 <shachaf> > joinInts [0,1,2,3]
18:53:31 <lambdabot>   "0123"
18:53:34 <tekknolagi> ooh
18:53:35 <tekknolagi> thanks!
18:53:37 <tekknolagi> what module?
18:53:39 <tekknolagi> Control.Monad?
18:53:42 <shachaf> joinInts = join . map show
18:54:03 <dmwit> > [0 .. 3] >>= show
18:54:05 <lambdabot>   "0123"
18:54:13 <shachaf> Er, yes, there is that.
18:54:33 <shachaf> > concatMap show [0..3]
18:54:34 <lambdabot>   "0123"
18:54:56 <tekknolagi> thank you!
18:55:14 <tekknolagi> then how do i change that once more into an integer?
18:55:17 <tekknolagi> Char->Int?
18:55:25 <dmwit> > read "0123" :: Int
18:55:25 <lambdabot>   123
18:55:29 <tekknolagi> thanks!!
18:56:05 <ben> Gosh, this enumerator thing doesn't want to fit into my head
18:56:10 <dmwit> > digitToInt '0'
18:56:11 <lambdabot>   0
18:56:39 <dmwit> ben: As with monads, the way to understand it is to write it once.
18:56:45 <dmwit> ...or tence.
18:57:27 <ben> I'm not sure why an iteratee has to have the m around it, so that applying an enumerator to it requires a monadic action
18:57:39 <tekknolagi> i'm trying to remember this piece of code i got yesterday, and it used replicateM to make a list of the combinations of [0,1] of length [1..4]
18:57:54 <tekknolagi> i remembered a mangled version, looks kinda like this:
18:57:54 <tekknolagi> concatMap (\n -> map replicateM n [0, 1])
18:58:00 <ben> Maybe I'm vastly misunderstanding the monad instance
18:58:02 <parcs> ben: to allow defining useful class instances
18:58:11 <parcs> like MonadIO, MonadTrans
18:58:16 <dmwit> :t replicateM
18:58:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
18:58:47 <ben> parcs: Well, yeah, I can see how the monadic stuff coming in handy really soon, but why isn't that somewhere in the continue part of the whole machinery
18:58:54 <dmwit> > [1..4] >>= \n -> replicateM n [0,1]
18:58:55 <lambdabot>   [[0],[1],[0,0],[0,1],[1,0],[1,1],[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1...
18:58:57 <ben> I just made an iteratee why does it need to do IO before I can hand it to my enumerator
18:59:10 <tekknolagi> whoa that was fast
18:59:13 <tekknolagi> thank you dmwit!
18:59:26 <parcs> ben: it doesn't. the monad can be Identity
18:59:51 <ben> parcs: Yeah, but it's gonna be IO for all the silly little motivating testcases I'm trying to think about :(
18:59:52 <monochrom> I thought the enumerator did the IO
19:01:07 <monochrom> well, I guess the type of your iteratee involves the token "IO" but that's like saying the type of return involves "IO" too
19:01:47 <ben> well yeah there's gonna be a bunch of return involved at the beginning
19:02:41 <parcs> iteratees would have to do IO if you're, say, writing to a socket.
19:02:54 <parcs> as with Network.Enumerator.iterSocket
19:03:23 <monochrom> enjoy the ability to finally "output debugging messages" while you're in IO
19:03:53 <monochrom> I thought people would kill for that ability
19:05:36 <parcs> ben: there are helper functions for that
19:05:50 <parcs> see continue, yield and returnI
19:05:56 <ben> Yeah, I see those
19:06:53 <ben> Maybe I just need to find some simple sample code to wrap my head around how all these parts that individually make sense to me are meant to be used together :<
19:08:47 <parcs> ben: ignore the 'm' parameter in the types of Iteratee, Enumerator and Enumeratee. they should be much easier to comprehend, then
19:09:36 <parcs> also Step
19:10:08 <monochrom> ben: are you using the "enumerator" package?
19:10:11 <ben> yes
19:11:01 <hpaste> monochrom pasted “enumerator example” at http://hpaste.org/48180
19:11:15 <ben> cheers
19:11:16 <monochrom> then I hope my example paste helps
19:11:37 <int80_h> non-haskell related question. IN some Yesod examples I see reference to something called a nonce. I went to w3cschools.com and did a search for the term but nothing came up. COuld anyone here tell me what a nonce is?
19:12:30 <dmwit> Likely http://en.wikipedia.org/wiki/Cryptographic_nonce
19:12:33 <parcs> for instance, it's now obvious that Iteratees are just Steps. and Steps are continuation-like generators of data. and Enumerators are just functions that provide data for Steps (or Iteratees; they're the same thing)
19:13:30 <int80_h> dmwit: thanks. I think that's it
19:13:31 <hpaste> ben annotated “enumerator example” with “enumerator example (annotation)” at http://hpaste.org/48180#a48181
19:13:40 <ben> Why isn't it this? :3
19:14:32 <parcs> $$ is a pretty synonym for >>==
19:14:44 <parcs> or rather, ==<<
19:14:47 <monochrom> I have forgotten what Step does
19:14:55 <Cale> int80_h: In cryptography, a nonce is a number or piece of data which is used only once
19:15:05 <taotree> I'm seeing this error (I'm on ghc-7.0.3.20110330) but on hackage, it looks like there is an option for wxcore to use containers 0.4: "containers-0.4.0.0 was excluded because wxcore-0.12.1.6 requires containers
19:15:05 <taotree> >=0.2 && <0.4
19:15:05 <taotree> "
19:15:06 <monochrom> but my do_or_die is not a single step
19:15:11 <parcs> Steps yield data in a chunked fashion
19:15:26 <ben> monochrom: As far as I can tell, continue is Iteratee $ return . Continue
19:15:38 <dmwit> taotree: 0.4 is not <0.4
19:15:38 <Cale> (similar to a nonce word, which is a word constructed on the spot to meet a specific need that is not expected to recur)
19:15:46 <parcs> again, Iteratees are just Steps
19:15:48 <ben> and $$ is unwrapping the Iteratee, running the monadic computation and the result is again a step
19:15:52 <dmwit> taotree: (though 0.4 is <=0.4)
19:16:43 <monochrom> well, my iteratee directly outputs to stdout through IO, so there is really nothing to yield (and I yield () at the end)
19:16:54 <taotree> dmwit: I was saying, if you look on hackage, it says: "... or ... containers (>=0.2 & < 0.5)
19:17:16 <monochrom> if you are transducing data, maybe you will use Step
19:18:06 <taotree> oh, maybe I need to set a flag to get that second option?
19:18:25 <dmwit> taotree: Perhaps you need to "cabal update".
19:18:31 <taotree> dmwit: already did
19:19:01 <john__> 1-2
19:19:08 <parcs> monochrom: in that case you are yielding IO actions, no?
19:19:34 <monochrom> I'm liftIO'ing directly
19:19:41 <dmwit> taotree: Since it's trying to install 0.12.1.6 instead of 0.12.1.7, I don't believe you.
19:20:14 <taotree> I already had 0.12.1.6 installed--it doesn't automatically install a new version does it?
19:20:16 <parcs> well the actions get executed right away, so you're left with ()s in the IO monad
19:20:16 <dmwit> taotree: (And 0.12.1.6 indeed requires containers <0.4.)
19:20:20 <taotree> I think I figured it out
19:20:27 <parcs> but i guess we can argue that
19:21:13 <monochrom> I am not big on accumulating a humongous IO action proportional to input size
19:21:48 <taotree> dmwit, right, that was it. I was looking at 0.12.1.7 on hackage without realizing it
19:21:54 <taotree> thanks!
19:29:05 <tekknolagi> how would i convert a char list to an int?
19:29:20 <stepcut> tekknolagi: read ?
19:29:26 <ddarius> how -would- you convert a char list to an int?
19:29:38 <monochrom> map ord charlist
19:29:42 <stepcut> > read "123" :: Int
19:29:43 <lambdabot>   123
19:29:52 <d7> stepcut: Hee hee hee.
19:30:05 <monochrom> > map ord "123"
19:30:05 <lambdabot>   [49,50,51]
19:30:08 <tekknolagi> ooh
19:30:10 <tekknolagi> thanks!
19:30:16 <tekknolagi> oh
19:30:16 <tekknolagi> no
19:30:18 <tekknolagi> i wanted
19:30:22 <tekknolagi> "0123" -> 123
19:30:29 <ddarius> > const 3 "foo"
19:30:30 <tekknolagi> just
19:30:31 <lambdabot>   3
19:30:33 <tekknolagi> without read?
19:30:50 <c_wraith> > read "582" :: Word8
19:30:51 <lambdabot>   70
19:30:55 <c_wraith> :)
19:31:00 <tekknolagi> without read please :P
19:31:03 <dmwit> tekknolagi: Why not use read?
19:31:08 <dmwit> :t readIntAtBase -- okay, fine
19:31:09 <lambdabot> Not in scope: `readIntAtBase'
19:31:12 <ddarius> > consnt 123 "0123"
19:31:13 <lambdabot>   Not in scope: `consnt'
19:31:17 <ddarius> > const 123 "0123"
19:31:18 <lambdabot>   123
19:31:20 <dmwit> :t readInt
19:31:21 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
19:31:28 <ddarius> :t readIntAtBase
19:31:29 <lambdabot> Not in scope: `readIntAtBase'
19:31:41 <c_wraith> > map digitToInt "123"
19:31:42 <lambdabot>   [1,2,3]
19:31:49 <c_wraith> then do some mathy stuff
19:31:53 <dmwit> > readInt 10 isDigit digitToInt "0123"
19:31:54 <lambdabot>   [(123,"")]
19:32:24 <ddarius> > readInt 1 isDigit digitToInt "123"
19:32:25 <lambdabot>   [(6,"")]
19:32:43 <dmwit> cute
19:33:22 <shachaf> tekknolagi: Why are you avoiding read?
19:34:15 <ddarius> shachaf: read is how the Man gets to you, man.
19:35:40 <c_wraith> > read "this is fun!" :: Int
19:35:41 <lambdabot>   *Exception: Prelude.read: no parse
19:36:40 <Cale> > reads "this is fun!" :: [(Int, String)]
19:36:41 <lambdabot>   []
19:36:49 <stepkut> > foldl ((+) . (* 10)) 0 $ map digitToInt "123"
19:36:49 <Cale> > reads "234this is fun!" :: [(Int, String)]
19:36:50 <lambdabot>   [(234,"this is fun!")]
19:36:51 <lambdabot>   123
19:37:17 <stepkut> if you are clever you can get rid of the map
19:37:53 <pikhq_> "read" *really* should be of type [Char] -> Maybe a...
19:38:33 <monochrom> steal the source code of readIO and turn it into Maybe a
19:38:37 <monochrom> @src readIO
19:38:38 <lambdabot> Source not found.
19:38:47 <dmwit> pikhq_: reads has a better type
19:38:53 <monochrom> well then you will find it yourself
19:39:08 <pikhq_> dmwit: Okay, true.
19:39:53 <dmwit> readMaybe s = case filter (null . snd) (reads s) of ((x, ""):_) -> Just x; _ -> Nothing
19:41:06 <luite> > (show.read) "5"
19:41:07 <lambdabot>   "*Exception: Prelude.read: no parse
19:41:26 <parcs> cabal install safe
19:41:27 <luite> > (show.read) "()"
19:41:28 <lambdabot>   "()"
19:44:11 <stepkut> ?pl \x y -> (+) (x * 10) (digitToInt y)
19:44:12 <lambdabot> (. digitToInt) . (+) . (10 *)
19:44:39 <stepkut> > foldl ((. digitToInt) . (+) . (10 *)) 0 "123"
19:44:41 <lambdabot>   123
19:44:49 <stepkut> victory!
19:44:55 <dmwit> Wow, did it just use the fact that (+) is commutative?
19:44:59 <dmwit> ?pl \x y -> y + x
19:45:00 <lambdabot> (+)
19:45:03 <dmwit> yikes!
19:45:27 <Axman6> dmwit: why the filter in your readMaybe above?
19:45:42 <stepkut> dmwit: how did you even notice that!?
19:45:50 <dmwit> Axman6: A matter of aesthetics. Should (readMaybe "123Foo") return (Just 123) or (Nothing)?
19:46:09 <Axman6> depends on the situation i guess
19:46:11 <ddarius> dmwit: @pl is very trusting.
19:46:23 <dmwit> I choose Nothing, and so I filter out results of the former type.
19:46:29 <c_wraith> @pl \x -> 1 + x + 1
19:46:29 <lambdabot> (2 +)
19:46:35 <dmwit> yeesh
19:46:36 <Axman6> heh, nice
19:46:49 <dmwit> > 2 + x == 1 + x + 1
19:46:51 <lambdabot>   False
19:46:57 <Axman6> that relies on the fact that 1 + 1 = 2 though, might not always be the case >_>
19:47:00 <stepkut> dmwit: Nothing would match the behaviour of, read "123Foo" :: Int
19:47:06 <c_wraith> that was my point, Axman6  :)
19:47:07 <stepkut> > read "123Foo" :: Int
19:47:08 <lambdabot>   *Exception: Prelude.read: no parse
19:47:32 <dmwit> stepkut: Which is, in part, why I choose Nothing as my result. =)
19:47:42 <tekknolagi> > digitToInt "0123"
19:47:42 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
19:47:43 <lambdabot>         against inferred type...
19:47:49 <ddarius> Arguably, fromInteger should be a ring homomorphism, but only arguably.
19:47:56 <stepkut> ?type digitToInt
19:47:57 <lambdabot> Char -> Int
19:48:02 <dmwit> Using ((x,""):_) instead of [(x,"")] is also an aesthetic choice. When it's ambiguous, should you return something or not?
19:48:19 <tekknolagi> join (map digitToInt "123")
19:48:22 <tekknolagi> > join (map digitToInt "123")
19:48:23 <lambdabot>   Couldn't match expected type `m a'
19:48:23 <lambdabot>         against inferred type `GHC.Types...
19:48:33 <dmwit> > map digitToInt "123" -- can't join it any farther
19:48:35 <lambdabot>   [1,2,3]
19:48:43 <ddarius> join . map f = (>>= f)
19:48:43 <tekknolagi> > joinInts (map digitToInt "123")
19:48:44 <lambdabot>   Not in scope: `joinInts'
19:49:08 <tekknolagi> dmwit: can you make it an int without read?
19:49:17 <dmwit> Yes.
19:49:18 <Saizan> > foldl' (\a d -> a * 10 + d) 0 $ map digitToInt "123"
19:49:19 <lambdabot>   123
19:49:24 <ion> Err. What’s the proper term for a float that is not NaN or infinite?
19:49:44 <stepkut> Saizan: you can condense the map into the foldl' though..
19:49:53 <ivanm> ion: a number? :p
19:50:18 <ion> isNumber :: RealFloat a => a -> Bool isn’t very descriptive. :-\
19:50:23 <Saizan> > foldl' (\a d -> a * 10 + digitToInt d) 0 "123"
19:50:24 <lambdabot>   123
19:50:38 <Saizan> stepkut: you prefer it like that?:)
19:50:45 <stepkut> Saizan: and then make the lamba function pointless so that that is completely unreadable :)
19:50:50 <stepkut> Saizan: see above..
19:51:02 <dmwit> ion: How about "finite"?
19:51:14 <stepkut> > foldl' ((. digitToInt) . (+) . (10 *)) 0 "123"
19:51:15 <Saizan> stepkut: ah, i see :)
19:51:16 <lambdabot>   123
19:51:39 <monochrom> some people say "degenerate" for NaN and infinite
19:52:21 <monochrom> this is set up to make sure "nonDegenerate" looks really ugly and hard to type
19:52:55 <ion> Thanks, i think i’ll go with isNotDegenerate. isFinite doesn’t immediately signal that it checks for isNaN, too.
19:53:39 <monochrom> but people do argue whether infinite counts as degenerate
19:53:43 * stepkut wonders what ever happened to Stefan O'Rear
19:53:51 <Kaidelong> main reason I'm asking this is because I would like to avoid reading what oleg actually wrote originally but
19:54:10 <Kaidelong> why does Data.Random.Extras have an O(n*log(n)) shuffle?
19:54:26 <Kaidelong> does it have some advantage over O(n) swap-based shuffling?
19:54:40 <monochrom> you should give up hope on unambiguous meaningful identifiers. people can't even agree whether 0 is "natural" or not
19:55:02 <ivanm> stepkut: IIRC, he doesn't haskell much anymore
19:55:03 <monochrom> just say "isEnterpriseReady" when in doubt
19:55:27 <stepkut> ivanm: yeah :(
19:55:47 <ivanm> Kaidelong: I am going to randomly guess that the O(n) version requires mutating arrays
19:55:57 <Kaidelong> it does
19:56:16 <Kaidelong> list to mutable array to list is still O(n) though
19:56:22 <ivanm> there's also a shuffle package on hackage IIRC
19:56:23 <smoge> hi
19:56:29 <Kaidelong> my GUESS is that it is related to memory efficiency
19:56:32 * ivanm waves idly in smoge's general direction
19:56:36 <ion> Perhaps i’ll imitate libc and go with isNormal and check for denormals as well, as i don’t care one way or another with them. http://www.gnu.org/s/hello/manual/libc/Floating-Point-Classes.html
19:56:42 <smoge> I'm looking for some working example of realtime audio engine in haskell
19:56:46 <Kaidelong> but I can't image how you would shuffle something without evaluating the whole list in the process
19:56:50 <smoge> is there some work in this direction?
19:57:06 <smoge> I mean really realtime audio
19:57:08 <ivanm> smoge: I think there are bindings to C libraries, but I don't recall anyone writing a new audio engine in Haskell
19:57:14 <ion> Oh, it checks against zeros too. That’s not what i want either.
19:57:21 <ivanm> and "really realtime" usually implies you don't want a language with GC
19:57:27 <ivanm> ion: 0 isn't normal? :o
19:57:31 <smoge> yes.. I was wondering about this
19:57:36 <smoge> if this is possible at all
19:57:40 <smoge> maybe with llvm?
19:57:52 <c_wraith> haskell has been used for realtime stuff.  atom is an example
19:58:05 <c_wraith> But the way atom works is "your haskell program generates a C program"
19:58:08 <ivanm> smoge: http://hackage.haskell.org/package/#cat:sound
19:58:15 <ivanm> smoge: using LLVM will still require GC
19:58:37 <smoge> I know about bindings to CSound and SuperCollider
19:58:43 <smoge> they're cool.
19:58:45 <ion> ivanm: The document i linked says FP_NORMAL is returned by fpclassify if none of FP_NAN, FP_INFINITE, FP_ZERO or FP_SUBNORMAL apply.
19:58:54 <smoge> but it's c++ in the end, not haskell
19:59:51 <ion> dmwit: It seems libc uses “isfinite” to test against both FP_INFINITE and FP_NAN. I’ll go with that, thanks.
20:00:46 <Jafet> “isfinite” is itself a wrapper; the libc function is “fpclassify”
20:00:47 <ion> At least my naming won’t surprise people who know isfinite from C99.
20:00:57 <ion> jafet: yes
20:01:47 <Jafet> Oh, your question was nomenclature.
20:02:20 <ivanm> smoge: well, do you really need to write a new audio engine?
20:02:23 <ivanm> or do you just want to use it?
20:02:36 <Jafet> smoge: it is certainly possible with GHC, but you may well find yourself writing C in the end
20:02:53 <smoge> would be fun to know there is one, so we could extend it using haskell
20:03:03 <smoge> with more 'plugins', so to speak
20:03:15 <Jafet> Except it's an awkward C in a sea of indentation and (>>=)
20:03:22 <ivanm> Jafet: heh
20:03:39 <smoge> hsc3 is cool, though
20:03:54 <smoge> it's a little language to control supercollider audio engine (C++)
20:05:10 <Cale> smoge: Well, for realtime/high performance stuff in Haskell, probably your best bet is code generation of some sort, or else for less stringent requirements, you can drive a small program written without a garbage collector using a Haskell program which produces output a bit ahead of time (or in a way which is somewhat independent of time), so that GCs don't hurt you.
20:06:16 <Cale> You could possibly move more of supercollider out into Haskell land, and make the core stuff which is written in C++ (or whatever) smaller.
20:06:17 <smoge> just saw a project of a lua engine for realtime audio (silencio)
20:06:21 <smoge> |o|
20:06:47 <smoge> Cale: that would be fun
20:07:42 <Cale> But for that sort of thing, it probably is helpful to have at least a little bit of code which can run continuously without a garbage collector.
20:08:17 <smoge> Cale: do you work with audio in haskell?
20:08:40 <ivanm> smoge: a better question is: what _doesn't_ Cale work with in Haskell? :p
20:08:42 <Cale> No, but I am working on a game with iPwn studios for iPhones and other mobile devices.
20:08:57 <ddarius> Cale: Have they paid you yet?
20:09:06 <Cale> sure, they pay me all the time
20:09:08 <monochrom> Cale doesn't write proofs in haskell
20:09:15 <smoge> a iPhone game written in haskell?
20:09:19 <dmwit> oh
20:10:09 <Cale> and on the iPhone, a major GC (every few minutes) can take around 300ms, so we need a little core of lowlevel code, with our Haskell program emitting descriptions of what to display a bit into the future (in terms of animation files, and velocities/accelerations)
20:10:35 <Cale> and that smooths over any times where the Haskell program needs to stop and GC
20:10:54 <smoge> oh, latency is either not good for this kind of stuff
20:11:06 <smoge> but better then drops/clicks/etc
20:11:32 <smoge> I did not know about haskell on iphones
20:11:36 <smoge> cool
20:12:03 <dmwit> Cale: Would you expect this to be a concern at modern desktop hardware speeds?
20:12:08 <Cale> dmwit: no
20:12:25 <Cale> Well, obviously it depends on how much garbage your program produces
20:12:30 <dmwit> yes
20:12:40 <dmwit> Yes, definitely.
20:13:35 <Cale> I've also found that there are some cute RTS options which seem to help a bit.
20:14:05 <Cale> +RTS -w  seems smoother to me
20:14:37 <Cale> (this was with desktop demo/test programs, I haven't tried it on the device)
20:14:46 <luite> hmm, 300ms does seem rather long for action games, even with smoothing
20:16:53 <dmwit> I tried playing an FPS with 500ms ping this afternoon.
20:16:58 <Cale> Maybe, though I'm not sure which device that was measured on as well. That's just what I heard from Ryan about a year ago as a kind of upper bound. It's possible that it's better on newer devices.
20:17:11 <dmwit> It was way too frustrating -- I only made it about 30s before quitting.
20:18:07 <Cale> Oh, definitely for something like that. Here, the latency isn't persistent though.
20:18:33 <Cale> So it's more like having a much smaller ping with a possible 300ms spike every few minutes.
20:19:49 <Cale> I've played Q2 with a 300ms ping with not much problem either. Takes a little getting used to if you've played LAN or vs. AI for a long time, but it's not so bad.
20:20:15 <smoge> I try to work with latencies lower then 10ms here
20:20:38 <Cale> Well, with audio processing, it's a different story.
20:20:45 <smoge> yes.. :-)
20:20:47 <guerrilla> so. i do ghci "Main.hs".. ":set -fbreak-on-exception".. ":trace main" i get an exception (from init) and then ":hist" but it says "Empty history. Perhaps you forgot to use :trace?"
20:20:58 <guerrilla> what gives? i think i had this problem before but i cant remember what i did to solve it
20:21:02 <Cale> With pure audio generation, you could probably tolerate much higher latencies.
20:21:16 <Cale> But if you're acting as a stream processor, it's important to keep that down.
20:21:56 <smoge> yes. if you are playing, of listening to the result in realtime, 20ms is already too much
20:21:59 <Cale> guerrilla: Can I see the program? Is the use of init near the top level?
20:22:07 <smoge> if you are just generating audio, 50ms can be ok
20:22:13 <smoge> or even higher
20:22:17 <Cale> Or even 1s could be fine :)
20:22:38 <smoge> 1s? hum.. well, depends of the stuff
20:22:46 <ivanm> @tell edwardk with our discussion of how to do multivariate polynomials... I started wondering if it would be possible to do something ala repa and enforce the variable ordering, etc. in the type...
20:22:47 <lambdabot> Consider it noted.
20:22:51 <guerrilla> Cale: the program is really large actually... i don't know where the init is.. i use a lot of inits gaurded by lengh > 0 but i cant figure out where this is happening
20:23:10 * ddarius pukes all over guerrilla's code.
20:23:24 <guerrilla> ddarius: why exactly?
20:23:24 <ivanm> ddarius: just the _description_ makes you puke? :o
20:23:41 <Cale> Well, length and init are two functions which are usually best avoided.
20:23:57 <guerrilla> by doing what exactly?
20:23:59 <Cale> (but there are cases where you'll need them)
20:24:02 <parcs> > length > 0
20:24:04 <lambdabot>   *Exception: (==): No overloading for function
20:24:06 <ivanm> Cale: well, repeated application of
20:24:08 <Cale> yeah
20:24:09 <ivanm> @type not . null
20:24:10 <lambdabot> forall a. [a] -> Bool
20:24:17 <ivanm> > not . null $ [1..]
20:24:18 <lambdabot>   True
20:24:25 <ivanm> > (> 0) . length $ [1..]
20:24:29 <lambdabot>   mueval-core: Time limit exceeded
20:24:33 <ivanm> guerrilla: ^^
20:24:40 <Cale> guerrilla: Pattern matching and/or use of null can take the place of checking if the length of a list is positive.
20:24:46 <ivanm> don't use length to test for non-empty lists!
20:24:48 <Cale> guerrilla: That's O(1) rather than O(n) time
20:24:55 <guerrilla> ok
20:24:57 <guerrilla> i'll do so
20:25:00 <Cale> length xs takes an infinite amount of time if xs is an infinite list
20:25:04 <guerrilla> yes
20:25:07 <guerrilla> i understand now
20:25:14 <guerrilla> anyway, this doesnt help solve the actual issue
20:25:18 <Cale> right right
20:25:23 <Cale> so, hmm
20:25:25 <guerrilla> how do i find out where this ungaurded init is?
20:25:41 <ivanm> guerrilla: I've used trace messages to do something similar in the past
20:25:51 <adrake> ⃠A
20:25:51 <ivanm> (when I was using a lot of fromJust's)
20:25:57 <ddarius> Rewrite all your coded not to use guarded inits.
20:26:04 <Cale> How many places are you really using init? (I find it slightly hard to believe there's more than a handful)
20:26:05 <adrake> er, wrong channel
20:26:20 <ddarius> Cale: Ye of little faith.
20:26:23 <luite> yeah use error and panic instead, like they do with ghc :p
20:26:45 <Cale> adrake: What's the right channel for "<adrake> ⃠A"? ;)
20:26:47 <guerrilla> luite: ok
20:26:50 <luite> guerrilla: nooo
20:27:00 <luite> don't do that ;p
20:27:06 <guerrilla> oookay
20:27:09 <MatrixFrog> # ⃠A obviously
20:27:13 <ivanm> adrake: what symbol do you have there anyway? :/
20:27:29 <ivanm> guerrilla: Debug.Trace
20:27:33 <Cale> It looks like a universal "no" symbol to me, but it overlaps the previous character
20:27:45 <luite> I was trying to print a haskell AST with GHC, but they made it basically impossible because ghc uses panic for AST nodes that need to be filled in later
20:27:47 <guerrilla> ivanm: yeah.. i think i have to
20:27:52 <ivanm> and use something like: initTrace msg lst = trace msg $ init lst
20:27:56 <guerrilla> but whats up with ghci not giving me the trace?
20:28:02 <ivanm> then provide a unique message for each one
20:28:08 <ivanm> *shrug* never used the debugger in ghci
20:28:16 <ivanm> luite: heh
20:28:19 <guerrilla> ivanm: yeh, will do..
20:28:20 <Cale> guerrilla: The ghci debugger is weird, and I've never really used it, so I don't know.
20:28:22 <ivanm> Cale: yeah, same
20:28:28 <ivanm> (for the symbol adrake had)
20:28:47 <Cale> guerrilla: It's usually better to just break things down into smaller pieces and test/understand them independently.
20:28:48 <ivanm> some kind of control character being printed wierdly? :/
20:29:11 <Cale> If you're really at a loss, try compiling with -prof -auto-all -rtsopts and running the program with +RTS -xc
20:29:32 <ddarius> It's usually better to write your code in a way that these errors do not occur.
20:29:40 <Cale> Indeed
20:29:50 <confound> it's a unicode UPPERCASE COMBINING NO THANKS character
20:30:01 <ivanm> is -rtsopts the flag needed to re-enable +RTS in ghc 7?
20:30:08 <guerrilla> ddarius: yeah well haskell doesn't have dependent types
20:30:12 <kmc> yet
20:30:18 <kmc> wait for Haskell 2999
20:30:20 <Cale> U+20E0 COMBINING ENCLOSING CIRCLE BACKSLASH
20:30:23 <ddarius> Haskell will never have dependent types.
20:30:31 <sm> guerrilla: I seem to remember the ghci debugger manual explained all that weirdness quite well
20:30:31 <guerrilla> no kidding
20:30:37 <ivanm> guerrilla: so having dependent types will suddenly fix your code? :/
20:30:43 <guerrilla> ivanm: yes
20:30:56 <ivanm> ddarius: at least not if we wanted it to look anything like what we currently call "Haskell"?
20:30:58 <ddarius> guerrilla: So just translate your code to Agda.
20:31:03 <Cale> Well, it *might* prevent the code from compiling.
20:31:12 <Cale> If the list type he used was counted
20:31:15 <guerrilla> ddarius: yes, i probably should be
20:31:33 <Cale> guerrilla: What does your program do? Why so much init?
20:31:34 <sm> oh.. it looks like you did it right. dunno
20:31:42 <confound>  ⃠
20:32:05 <kmc> ddarius, COBOL 2002 is object-oriented
20:32:28 <ddarius> kmc: So?
20:32:28 <joe6_> need some desgin advice, please? I am trying to do something like this: filledProfile <- populateProfile profile sortedPatternResponses
20:32:34 <Cale> COBOL 2030 will have lambda
20:32:40 <joe6_> where Profile is a Memory State
20:32:44 <guerrilla> Cale: translate from one source language to another. (srry not a very good explanation, but i'm going to work on this issue now)
20:32:45 <kmc> Haskell will become popular, then it will become bloated and encumbered by legacy apps, and then people will try to shove in the latest buzzwords
20:32:49 <MatrixFrog> you mean cobol will get lambdas before java? :P
20:32:51 <taotree> Trying to build my cabal project that uses wx on ubuntu natty and I get:  can't load .so/.DLL for: stdc++ (libstdc++.so: cannot open shared object file: No such file or directory)
20:32:51 <kmc> which i assume by 2999 will include dependent types
20:32:59 <joe6_> and I fill that up by parsing each item in the list of sortedPatternResponses
20:33:05 <luite> whoah COBOL 2002... I've really missed a lot of language development
20:33:17 <joe6_> Should I be using the State Monad for this?
20:33:25 <ddarius> kmc: In 2999, computing and virtually all technology will be complete unrecognizable.
20:33:39 <Saizan> taotree: make sure your libstdc++.so is not a linker script
20:33:39 <ddarius> Or, I will have eliminated us all.
20:33:50 <joe6_> taotree: do you have llvm-gcc installed?
20:34:01 <ivanm> Cale: there is a non-empty list type available IIRC
20:34:01 <Saizan> ddarius: *I* ?
20:34:04 <SAilorREaliTy> arre there any ops of #LOGIC here
20:34:15 <joe6_> taotree: I think that file is part of the llvm-gcc and that will be removed in the 3.0 version.
20:34:16 <SAilorREaliTy> Saizan
20:34:20 <SAilorREaliTy> can you unbant me please
20:34:28 <Saizan> i can't
20:34:29 <SAilorREaliTy> I've been bant for a year
20:34:32 <SAilorREaliTy> why =(
20:34:38 <Saizan> not an op
20:34:40 <joe6_> or, can you check "apt-file search libstdc++.so" to which package that file belongs
20:34:49 <SAilorREaliTy> do you know the names of any ops? I only remember you
20:35:29 <Saizan> no, also this is off-topic for
20:35:31 <guerrilla> gah! sorry for the bother... it was stupid. /me doesnt want to talk about it! lol.. anyway thanks for the null vs. length suggestion guys
20:35:33 <Saizan> ##haskell
20:35:40 <SAilorREaliTy> PLzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
20:35:42 * ddarius votes for banning SAilorREaliTy from here for a year.
20:36:17 <confound> ddarius: PLzzzzzz!
20:36:33 <Cale> SAilorREaliTy: The only op in that channel is "BearPerson"
20:36:49 <SAilorREaliTy> never heard of him before. Thanks
20:36:57 <Cale> (which you could figure out by asking chanserv)
20:37:05 <confound> (and not annoying whole other channels)
20:37:12 <Cale> (using /msg chanserv access list #logic )
20:37:27 <SAilorREaliTy> true
20:37:37 <taotree> joe6_, ran that, it belongs to various packages. It appears the one that matters might be libstdc++6-4.5-dev
20:37:53 <taotree> Saizan, not sure how to do that
20:39:16 <ivanm> guerrilla: so you found your error?
20:39:36 <taotree> joe6_, I don't have llvm-gcc installed
20:39:50 <guerrilla> ivanm: yes, thanks
20:40:18 <taotree> Is there a way I can tell where it's looking for it? maybe I need to symlink or something since it appears to be in: /usr/lib/x86_64-linux-gnu/gcc/x86_64-linux-gnu/4.5/libstdc++.so
20:41:25 <Saizan> taotree: what does "file  /usr/lib/x86_64-linux-gnu/gcc/x86_64-linux-gnu/4.5/libstdc++.so" say?
20:42:22 * ivanm wonders whether using a Map or an Array would make more sense for a system of equations
20:43:11 <taotree> Saizan, it's a symlink to another symlink to /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.14 which is "ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, stripped"
20:44:17 <Saizan> taotree: ah, so the problem is not what i thought
20:44:43 <taotree> wait... all those are libstdc++.so.6, but it's looking for just libstdc++.so
20:44:57 <joe6_> taotree: this is what I have: http://pastebin.com/VX9zs2Ee
20:44:59 <mauke> The paste VX9zs2Ee has been copied to http://hpaste.org/48182
20:45:31 <joe6_> taotree: in /usr/local/lib: http://pastebin.com/VNv7KTgC
20:45:32 <mauke> The paste VNv7KTgC has been copied to http://hpaste.org/48183
20:46:09 <taotree> maybe that's the problem, I don't have it in /usr/local/lib at all
20:46:28 <joe6_> taotree: no, that is because I installed llvm-gcc
20:46:40 <joe6_> taotree, you do not need the file in /usr/local/lib
20:46:41 <taotree> of course, I don't have anything in /usr/local/lib except a bunch more dirs
20:46:45 <taotree> right
20:47:18 <joe6_> can you check if you can install gcc (or, a gcc package with libstdc++)
20:47:36 <taotree> I have gcc 4.5.2
20:47:39 <Saizan> taotree: cabal accepts --extra-lib-dirs= as a flag, btw
20:48:50 <taotree> Saizan, I just tried "cabal install --extra-lib-dirs=/usr/lib/x86_64-linux-gnu/gcc/x86_64-linux-gnu/4.5/ " but same error
20:49:55 <joe6_> can I have a function that updates a record field? such as: updateOneField :: Record -> Record
20:50:42 <taotree> joe6_, you might try fclabels or I think data-accessor or something like that
20:50:47 <joe6_> which takes Record as a parameter and returns the same Record, but with one field value changed
20:50:53 <taotree> oh wait
20:51:03 <taotree> joe6_, myrecord {field=newvalue}
20:51:06 <taotree> you don't need a function
20:52:39 <joe6_> taotree: yes, that was easy. Thanks.
20:53:37 <taotree> I can compile if I just use ghc, but if I run cabal, that's when it fails.
20:53:57 <taotree> I wonder if it's because I'm using templatehaskell... maybe it uses the equivalent of ghci for that and I think there is a bug about that
20:54:10 <taotree> anyway... gotta go, thanks for trying to help
20:56:30 <joe6_> taotree, have you tried cabal install with -vv?
21:08:28 <nathanfh> Does anyone know if there is there an idiomatic equivalent of   foo f (a,b) = (f a,f b)?
21:08:45 <ivanm> nathanfh: f *** f
21:08:51 <ivanm> @type \ f -> (f *** f)
21:08:52 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
21:09:01 <ivanm> @type succ *** succ
21:09:02 <lambdabot> forall b b'. (Enum b, Enum b') => (b, b') -> (b, b')
21:09:33 <ivanm> which you can also write as "join (***) f"
21:09:50 <ivanm> @type join (***)
21:09:50 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
21:09:55 <nathanfh> ivanm: Thanks. I thought I was missing something.
21:10:02 <nathanfh> I need to grok Arrows better.
21:10:19 <tekknolagi> hello
21:10:25 <tekknolagi> currently i have this line of code:
21:10:26 <tekknolagi> map (concatMap show) ([1..5] >>= \n -> replicateM n [0,1])
21:10:51 <tekknolagi> it generates a list of binary in string form. how would i map a function to convert the string to a number?
21:10:54 <tekknolagi> > map (concatMap show) ([1..5] >>= \n -> replicateM n [0,1])
21:10:55 <lambdabot>   ["0","1","00","01","10","11","000","001","010","011","100","101","110","111...
21:11:11 <ivanm> @type read
21:11:11 <lambdabot> forall a. (Read a) => String -> a
21:11:26 <ivanm> tekknolagi: though why use show ?
21:11:29 <ivanm> @hoogle digits
21:11:29 <lambdabot> Prelude floatDigits :: RealFloat a => a -> Int
21:11:29 <lambdabot> Numeric floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)
21:11:29 <lambdabot> Numeric lexDigits :: ReadS String
21:11:29 <ddarius> ivanm: That wouldn't produce the right number.
21:11:49 <ivanm> ddarius: oh, as in he wants it to be binary still?
21:12:01 <ivanm> IIRC there's a digits library on hackage
21:12:02 <tekknolagi> ddarius: yeah
21:12:25 <ivanm> tekknolagi: http://hackage.haskell.org/packages/archive/digits/0.2/doc/html/Data-Digits.html
21:12:34 <tekknolagi> ivanm, ddarius: i'd like it to be in binary still, and i used read to convert an array of ints to one string of ints
21:12:39 <ivanm> tekknolagi: undigits 2
21:13:02 <tekknolagi> > undigits 2 "01"
21:13:03 <lambdabot>   Not in scope: `undigits'
21:13:06 <tekknolagi> ?
21:13:15 <ivanm> tekknolagi: from that digits library I gave you the link to
21:13:21 <tekknolagi> ah
21:13:21 <tekknolagi> k
21:13:30 <ivanm> and your replicateM is then just "digits 2"
21:13:54 <tekknolagi> i cannot import "Data.Digits"
21:13:57 <tekknolagi> it doesn't see it
21:14:21 <ivanm> tekknolagi: "cabal install digits"
21:14:25 <tekknolagi> right
21:14:25 <tekknolagi> thakns
21:14:27 <tekknolagi> thanks*
21:14:58 <tekknolagi> this has helped a lot
21:16:55 <tekknolagi> gnn
21:16:56 <tekknolagi> hmm*
21:17:11 <tekknolagi> having trouble with digits. i tried `digits 2 "0001001"
21:17:13 <tekknolagi> `
21:17:15 <tekknolagi> and it doesn't work
21:17:54 <ivanm> tekknolagi: digits 2 3682345
21:18:10 <tekknolagi> > digits 2 3682345
21:18:11 <lambdabot>   Not in scope: `digits'
21:18:25 <ivanm> tekknolagi: it won't work here!
21:18:30 <tekknolagi> right
21:18:37 <ivanm> do it on your local machine after installing the digits library
21:18:43 <tekknolagi> k
21:18:45 <tekknolagi> here
21:18:45 <tekknolagi> though
21:19:03 <tekknolagi> how can i map that to...
21:19:03 <tekknolagi> no
21:19:10 <tekknolagi> i want to apply that to a string
21:19:18 <tekknolagi> "00011101" -> 11101
21:19:24 <ivanm> @hoogle Char -> Int
21:19:24 <lambdabot> Data.Char digitToInt :: Char -> Int
21:19:24 <lambdabot> Data.Char ord :: Char -> Int
21:19:25 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
21:20:02 <ivanm> so you want: undigits 2 . map digitToInt
21:20:28 <tekknolagi> where is undigits?
21:20:53 <tekknolagi> and how does one un-import?
21:21:27 <ivanm> same library
21:21:31 <ivanm> look at the documentation
21:21:40 <ivanm> to un-import in ghci, use :m -Foo
21:21:56 <tekknolagi> thank yoU!!
21:22:11 <tekknolagi> here:
21:22:12 <tekknolagi> unDigits 2 . map digitToInt (map (concatMap show) ([1..5] >>= \n -> replicateM n [0,1]))
21:22:16 <tekknolagi> i get an error
21:22:26 <tekknolagi> Couldn't match expected type `a0 -> [c0]' with actual type `[b0]'
21:22:26 <tekknolagi>     In the return type of a call of `map'
21:23:52 <ivanm> unDigits 2 . map digitToInt $ ...
21:24:08 <ivanm> tekknolagi: though why are you using show inbetween? :/
21:24:21 <tekknolagi> show? it makes it a string
21:24:24 <tekknolagi> right......
21:24:59 <ivanm> tekknolagi: but why are you wanting a String?
21:25:09 <tekknolagi> its better than an array...
21:25:11 <tekknolagi> oh
21:25:12 <tekknolagi> i can use this
21:25:13 <tekknolagi> instead
21:25:29 <ivanm> and if it's because you want to read in actual values, why not do so rather than your fixed generation of them?
21:26:26 <tekknolagi> ...what?
21:28:26 <ivanm> I'm still trying to work out why you're using show
21:28:54 <ivanm> if it's because your purpose is to read in binary digits from a file or something, then use a sample value like "00110101" or whatever to test
21:29:09 <ivanm> rather than a fixed generation of it
21:29:11 <tekknolagi> never mind
21:29:13 <tekknolagi> fixed it
21:29:18 <tekknolagi> map (unDigits 10) (replicateM 5 [0,1])
21:29:31 <tekknolagi> thank you! i'm *very* new to Haskell and its methods
21:29:36 <ivanm> ummmm...... don't you want 2, not 10?
21:29:39 <tekknolagi> no
21:29:42 <ivanm> I thought you said they were meant to be binary...
21:29:45 <tekknolagi> 2 gives 0, 1, 2, 3...31
21:29:51 <tekknolagi> 10 assumes its already in base 10
21:29:55 <tekknolagi> and leaves it that way
21:30:00 <ivanm> yes, but isn't that what you wanted?
21:30:03 <tekknolagi> no
21:30:19 <tekknolagi> earlier:
21:30:24 <tekknolagi> "i'd like it to be in binary still,"
21:30:26 <tekknolagi> ...
21:30:43 <tekknolagi> is there a way to do it without unDigits?
21:30:51 <ivanm> wait, so you want an Int that's a binary representation of another Int?
21:30:55 <ivanm> that sounds wrong IMHO
21:30:59 <ivanm> why do you want that?
21:31:06 <tekknolagi> it counts in binary for me :)
21:31:22 <tekknolagi> that's all
21:31:23 <ivanm> ummmm..... but addition, etc. won't be in binary
21:31:33 <tekknolagi> it's a non-issue
21:31:40 <ivanm> what _exactly_ are you wanting to do?
21:31:53 <tekknolagi> have it count in binary, preferably without unDigits
21:32:38 <ivanm> count _what_ in binary?
21:32:43 <tekknolagi> count.
21:32:45 <ivanm> what is your actual use case?
21:32:45 <tekknolagi> like 1, 2, 3, 4
21:32:48 <tekknolagi> not using it
21:32:55 <tekknolagi> i'm fiddling around, trying to get used to Haskell
21:32:55 <ivanm> so you want to generate binary numbers?
21:32:59 <tekknolagi> yes
21:33:03 <ivanm> and what's wrong with unDigits?
21:33:12 <tekknolagi> unDigits does not come with Haskell
21:33:29 <tommd> And the "quake" function doesn't come with C...
21:33:34 <tekknolagi> what's quake?
21:33:39 <ivanm> tekknolagi: uhhhh..... almost nothing comes with "Haskell", if by "Haskell" you mean the language standard
21:33:41 <ivanm> > iterate (*2) 1
21:33:41 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
21:33:51 <ivanm> tekknolagi: we have libraries for a reason
21:34:04 <tekknolagi> i mean...it must be installed alongside ghci separately
21:34:05 <ivanm> no-one wants to re-implement everything from scratch every single time
21:34:21 <tekknolagi> > iterate (*2) 2
21:34:22 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
21:34:28 <tekknolagi> > iterate (*2) 1
21:34:29 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
21:34:35 <tekknolagi> > iterate (*1) 1
21:34:36 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
21:34:41 <ivanm> @type iterate
21:34:42 <tekknolagi> weird
21:34:42 <lambdabot> forall a. (a -> a) -> a -> [a]
21:34:50 <ivanm> @src iterate
21:34:50 <lambdabot> iterate f x =  x : iterate f (f x)
21:34:58 <tekknolagi> @src map
21:34:59 <lambdabot> map _ []     = []
21:34:59 <lambdabot> map f (x:xs) = f x : map f xs
21:35:38 <tekknolagi> so is there a way without undigits? or that (since now you mentioned it) that i could compute in binary as well?
21:35:54 <ivanm> you could just copy the source of undigits
21:36:07 <tekknolagi> it's haskell?
21:36:11 <ivanm> it's not hard, just usage of foldl
21:36:13 <tekknolagi> whoa
21:36:14 <tekknolagi> that's tiny
21:36:46 <ivanm> <sarcasm>no, I secretly got you to use a Ruby library inside ghci</sarcasm>
21:36:56 <tekknolagi> what?
21:37:03 <tekknolagi> i like Ruby
21:37:41 <tekknolagi> is there a good way to learn haskell, aside from lyah?
21:37:53 <kmc> LYAH is not a way in of itself
21:37:55 <kmc> RWH is another good book
21:37:57 <shachaf> No, LYAH is the only way.
21:38:01 <ivanm> kmc: not for a beginner
21:38:08 <ivanm> @where books
21:38:08 <lambdabot> See `LYAH',`RWH'
21:38:16 <kmc> an essential component is playing around in GHCi or such
21:38:17 <tekknolagi> ivanm: am i that much of a beginner?
21:38:26 <ivanm> tekknolagi: you're saying you're not?
21:38:34 <tekknolagi> im just curious what constitutes a beginner
21:38:44 <ivanm> someone who hasn't touched haskell before
21:38:46 <tekknolagi> i taught myself python in half a day, now writing business scale apps in it
21:38:46 <tekknolagi> no
21:38:49 <tekknolagi> i've touched haskell before
21:38:52 <nkpart> Pretty much everyone except Oleg, non?
21:39:01 <tekknolagi> > let sq x = x * x in sq 3
21:39:02 <lambdabot>   9
21:39:04 <tekknolagi> yay
21:39:08 <ivanm> nkpart: well, there's also dons, the simons, etc. ...
21:39:27 <tekknolagi> ivanm: what? so lyah is not a good place to start?
21:39:32 <tekknolagi> @lyah
21:39:33 <lambdabot> Unknown command, try @list
21:39:40 <tekknolagi> @where lyah
21:39:40 <lambdabot> http://www.learnyouahaskell.com/
21:40:06 <Jafet> I'm sorry, tekknolagi, but you cannot write business scale apps in Haskell.
21:40:13 <ivanm> tekknolagi: I never said that
21:40:17 <Kaidelong> > ((*)<*>id)(3)
21:40:18 <lambdabot>   9
21:40:26 <tekknolagi> Jafet: the point was that I figured it out fast
21:40:29 <ivanm> _you_ said that you wanted other ways
21:40:39 <tekknolagi> ivanm: i said i'd be interested in other ways
21:40:47 <Jafet> I bet you only think you did.
21:40:50 <Kaidelong> Jafet: What's "business scale"?
21:40:58 <Jafet> I have no idea!
21:41:04 <ivanm> craft of functional programming version 3 just came out
21:41:06 <tekknolagi> Kaidelong: in my case, I'm working for Elance. i'm fourteen
21:41:18 <ivanm> @google elance
21:41:18 <lambdabot> http://www.elance.com/
21:41:19 <lambdabot> Title: Elance | Outsource to freelance professionals, experts, and consultants - Get wo ...
21:42:00 <tekknolagi> functions can have numbers and quotes in them?
21:42:01 <Kaidelong> bah temp firms
21:42:19 <ivanm> tekknolagi: huh?
21:42:34 <Kaidelong> he means names can include digits and ', I think
21:42:35 <tekknolagi> doubleSmallNumber' x = (if x > 100 then x else x*2) + 1
21:42:37 <tekknolagi> yeah
21:42:38 <tekknolagi> digits
21:42:49 <tekknolagi> > doubleSmallNumber' x = (if x > 100 then x else x*2) + 1
21:42:50 <lambdabot>   <no location info>: parse error on input `='
21:42:52 <ivanm> yes, they can have quotes as part of the function name
21:42:54 <tekknolagi> > let doubleSmallNumber' x = (if x > 100 then x else x*2) + 1
21:42:55 <lambdabot>   not an expression: `let doubleSmallNumber' x = (if x > 100 then x else x*2)...
21:43:09 <Jafet> No single quotes, only primes
21:43:09 <tekknolagi> > let doubleSmallNumber' x = (if x > 100 then x else x*2) + 1 in doubleSmallNumber 3
21:43:10 <lambdabot>   Not in scope: `doubleSmallNumber'
21:43:17 <Kaidelong> > let _'4 = 5 in _'4^2
21:43:18 <lambdabot>   25
21:43:27 <Twey> identifier ::= <lowercase letter> (<letter> | <number> | "_" | "'")+
21:43:27 <ivanm> it usually indicates either: a) it's a strict version of the non-primed function, or b) it's an improved/replacement for the non-primed function/value (typically used for values inside a where/let clause)
21:43:33 <tekknolagi> > let doubleSmallNumber' x = ((if x > 100 then x else x*2) + 1) in doubleSmallNumber 3
21:43:35 <lambdabot>   Not in scope: `doubleSmallNumber'
21:43:52 <tekknolagi> ivanm: that makes sense
21:43:54 <Jafet> c) someone hasn't heard of -fno-warn-name-shadowing
21:44:28 <Twey> Heh
21:44:37 <tekknolagi> ease up on the newbie
21:44:37 <tekknolagi> :P
21:44:46 <tekknolagi> brb
21:45:38 <kmc> sometimes foo' is a version of foo with default values for certain arguments, or vice versa
21:46:13 <ivanm> kmc: I think that comes under my "b)" variant, doesn't it?
21:46:28 <ivanm> dammit, google is failing me in my quest to check what name shadowing is...
21:46:32 <kmc> ok
21:46:46 <dankna> ivanm: is it returning false positives? :D
21:47:22 <ivanm> well, it's coming up with a lot of cabal files, mailing list messages, etc.
21:47:25 <aavogt> @quote evar
21:47:25 <lambdabot> DRMacIver says: I dread to think what category theory would look like after the software engineering world had got their grubby paws on it. Enterprisevariant functors. Commutative UML diagrams.
21:47:33 <aavogt> @quote view
21:47:33 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice. Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.  Licence
21:47:33 <lambdabot> to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
21:48:25 <aavogt> @quote benmachine evar
21:48:25 <lambdabot> benmachine says: let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x / best view pattern evar
21:48:35 <aavogt> that one is name shadowing ^^
21:49:06 <ivanm> wtf does that even mean? :/
21:49:28 <ivanm> how does that case statement even work? :/
21:50:21 <aavogt> so the x bound by the second lambda could refers do a different value (in this case x)
21:50:33 <aavogt> err, it's the same 0 as before
21:51:07 <ivanm> but how does even doing "let (\x -> ...) = 0 in x" work? how do you make a function = 0 ?
21:51:24 <Jafet> > let 1 = 0 in ()
21:51:25 <lambdabot>   ()
21:51:27 <shachaf> ivanm: It's a view pattern.
21:51:42 <Jafet> > let (\x -> x) = 0 in ()
21:51:43 <lambdabot>   <no location info>: Parse error in pattern
21:51:49 <shachaf> > let ((\x -> x) -> x) = 0 in x
21:51:51 <lambdabot>   0
21:52:14 <aavogt>   let f -> p = y   is just like       let p = f y
21:52:40 <ivanm> shachaf: I thought with view patterns you wouldn't have the \ there... :/
21:52:50 * aavogt is missing parentheses I guess... you don't need them with case
21:52:52 <shachaf> ivanm: The (\x -> ...) is the function used in the view pattern.
21:52:59 <shachaf> > let (id -> x) = 0 in x
21:53:00 <lambdabot>   0
21:53:06 <shachaf> > let ((\x -> x) -> x) = 0 in x
21:53:06 <lambdabot>   0
21:53:11 <shachaf> > let (\x -> x -> x) = 0 in x
21:53:11 <lambdabot>   0
21:53:51 <ivanm> OK, I must be mis-understanding view patterns then...
21:53:55 <ivanm> :/
21:54:07 * ivanm goes off to re-check the documentation for them
21:55:18 <shachaf> ivanm: Do you understand the first example? It just lets you pattern-match on the return value of a function.
21:56:12 <ivanm> OK, now I get it I think; I didn't realise the LHS of a view pattern was a function
21:56:27 <shachaf> Isn't that the point of it? :-)
21:56:38 * shachaf wishes the syntax was slightly lighter.
21:56:41 <ivanm> I think I was getting it mixed up with pattern guards or something :/
21:57:24 <kmc> i tend to prefer pattern guards, in the situations where both are feasible solutions
21:57:28 <ivanm> so that quote had a view pattern inside the case statement?
21:57:45 <ivanm> kmc: it would be nicer if we could have nested guards as well IMHO
21:57:59 <kmc> what would that mean?
21:58:50 <Jafet> Like nested cases, but shorter?
21:58:52 <aavogt> it means putting commas between different Bool, or pattern matches?
21:59:08 <ivanm> Jafet: yeah
21:59:14 <kmc> we can already (with PatternGuards) put a sequence of guards (pattern or bool) separated by commas
21:59:41 <ivanm> kmc: right, but I wanted a conditional along with it
21:59:41 <kmc> > let f x | Just y <- x, even y = "yay" | otherwise = "boo" in (f (Just 3), f (Just 4), f Nothing)
21:59:42 <lambdabot>   ("boo","yay","boo")
21:59:56 <Jafet> How do you parse: f x | g x | h x = y | j x = z | k x = w?
22:00:02 <kmc> isn't that what you want ivanm?
22:00:23 <ivanm> kmc: what happens if I do another a -> Maybe b on the y in your example?
22:00:39 <shachaf> kmc: I think ivanm wants to be able to say both "even y" and "odd y" for the same "Just y <- x" case.
22:00:40 <kmc> what do you mean "do"
22:00:47 <ivanm> shachaf: yup
22:00:51 <kmc> oh, right
22:00:56 <kmc> yeah, that is not ideal
22:01:02 <kmc> view patterns have a similar duplication
22:01:12 <kmc> write ten equations which all say f (g -> ...)
22:01:30 <kmc> GHC guarantees the LHS will only be evaluated once, if it's syntactically identical
22:01:33 <kmc> still not ideal
22:02:05 <ivanm> yeah, explicit syntactic structure > language guarantees > implementation guarantees
22:03:23 <Jafet> It's all cases, anyway
22:03:40 <Jafet> Maybe if there was some less horrid syntax for cases
22:03:47 <ivanm> anonymous cases!
22:04:00 <Jafet> We need Tracer Bullet on this.
22:04:14 <ivanm> huh?
22:04:50 <kmc> i would like some anonymous case yes
22:04:55 <kmc> gotta get me summa dat
22:08:30 <ash_> is there a good strategy for finding the element after what I searched for in a list? (eg, x = [1, 2, 3, 4]  the item right after 2)
22:09:29 <ivanm> ash_: head . tail . dropWhile (not . p) ?
22:09:46 <djahandarie> > head . tail . dropWhile (/= 2) $ [1,2,3,4]
22:09:48 <lambdabot>   3
22:09:52 <djahandarie> Oops, beat to it :)
22:09:54 <Jafet> listToMaybe . drop 1
22:10:08 <ivanm> Jafet: yeah, yeah...
22:10:09 <djahandarie> That is indeed safer.
22:10:10 <ivanm> ;)
22:10:36 <ash_> thanks, i am still learning the right ways to manipulate lists in haskell
22:27:12 <DukeDave> Can anyone suggest an explanation of the reader monad? I keep getting references to the Monad.Reader 'magazine'
22:27:22 <DukeDave> *a link to a suggestion
22:28:40 <DukeDave> Aha, a Google with "-magazine" seems to do the trick
22:30:53 * hackagebot simple-sendfile 0.1.1 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.1.1 (KazuYamamoto)
22:33:06 <tekknolagi> what is haskell really good at?
22:33:35 <sully> tekknolagi: constructing the infinite list of the fibonacci numbers
22:33:45 <tekknolagi> one can do that in python, too
22:34:10 <tekknolagi> i mean
22:34:14 <tekknolagi> what's it known for?
22:34:26 <sully> functional languages are known for being good at symbolic computation
22:34:36 <sully> things like compilers and theorem provers are bread and butter
22:34:36 <tekknolagi> huh
22:34:56 <ash_> i wrote a custom set of arcade controller drivers in it, for fun
22:35:06 <tekknolagi> whoa...
22:35:13 <tekknolagi> could you write a compiler/interpreter in haskell?
22:35:18 <sully> yes.
22:35:21 <sully> boy could you ever.
22:35:21 <ash_> see pugs
22:35:35 <ifnspifn> I also read that every function in Haskell maps to a function in the lambda calculus
22:35:35 <tekknolagi> @google pugs haskell
22:35:36 <lambdabot> http://en.wikipedia.org/wiki/Pugs
22:35:36 <lambdabot> Title: Pugs - Wikipedia, the free encyclopedia
22:35:44 <tekknolagi> @google "pugs haskell"
22:35:46 <lambdabot> http://pugs.blogs.com/pugs/haskell/
22:35:46 <lambdabot> Title: Pugs: Haskell
22:35:53 <tekknolagi> yay :)
22:36:01 <tekknolagi> whoa.
22:36:07 <ifnspifn> and that every language can map to haskell; thus, every algorithm in every language is just mathematics, and can't be patented :]
22:36:17 <sully> I mean, haskell /is/ a lambda calculus
22:36:45 <ifnspifn> man, I just started Discrete II, so I'm working on knowing what the lambda calculus is :P
22:36:54 <ifnspifn> I've no idea, to be honest
22:37:23 <tekknolagi> what's lambda calculus? is there a concise explanation?
22:37:27 <sully> so, "the" lambda calculus is a particular model of computation built around first class functions
22:37:43 <sully> "a" lambda calculus is any model of computation built around first class functions :P
22:37:47 <tekknolagi> what's a first class function?
22:38:02 <sully> a function that you can treat like any other value
22:38:04 <shachaf> It's a little stone that represents an eigenvalue.
22:38:14 <tekknolagi> .....eigenvalue? stone?
22:38:18 <sully> you can pass it to other functions, return it from other functions, store it in variables, etc
22:38:23 <ifnspifn> right
22:38:34 <tekknolagi> what are those?
22:38:40 <ifnspifn> would a simple recursive function, like the standard example of factorial, count?
22:38:43 <ifnspifn> since it returns a value?
22:38:48 <sully> what are variables?
22:38:59 <sully> what are what?
22:39:04 <tekknolagi> oh
22:39:05 <tekknolagi> im sorry
22:39:09 <tekknolagi> eigenvalue and stone
22:39:09 <sully> it's not really a property of any particular function
22:39:20 <sully> it's a property of all functions in certain languages
22:39:32 <tekknolagi> an eigenvalue?
22:39:39 <sully> no, being a first-class function
22:39:40 <shachaf> tekknolagi: Ignore what I say, please.
22:39:47 <sully> yeah, ignore shachaf's answer
22:39:51 <ifnspifn> haha :P
22:40:13 <ash_> this isnt matlab we are talking about, so not everything is a matrix
22:40:24 <tekknolagi> shachaf: ok
22:40:31 <Cale> tekknolagi: If V is a vector space, and T is a linear operator V -> V, then an eigenvector for T is a nonzero vector v in V such that T(v) = cv for some scalar c, called the associated eigenvalue of v.
22:40:44 <ifnspifn> I'm learning now about formal languages, recognizability, basic computability stuff -- so first class functions belong to a language class
22:40:48 <Cale> But this has nothing to do with the discussion at hand.
22:40:58 <tekknolagi> o.O
22:41:03 <sully> not that sort of language
22:41:21 <yuriks> ifnspifn: a first class function is a function that you can treat as a value
22:41:23 <sully> like, functions in some programming language are "first-class" if they can be treated like any other value in the language
22:41:42 <sully> so like
22:41:59 <sully> all functions in haskell, scheme, ml, javascript are first class
22:42:08 <sully> and no functions in java are first class
22:42:21 <ivanm> sully: though apparently they're coming in Java 7 IIRC
22:42:23 <ifnspifn> because it's interpreted?
22:42:29 <ivanm> ifnspifn: no
22:42:35 <tekknolagi> Java..interpreted?!
22:42:41 <ivanm> because of the language specification
22:42:54 <ivanm> @type map
22:42:55 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:43:04 <shachaf> Compilation is just an optimization of interpretation. It has nothing to do with the capabilities of a language.
22:43:05 <Cale> ifnspifn: Because you can't put them in datastructures or pass them as parameters to methods or procedures, etc.
22:43:07 <ash_> scoping is an important factor with first class functions, without sane scoping rules first class functions aren't as useful
22:43:14 <ivanm> ^^ map is a higher order function because it takes in a function as an argument
22:43:15 <tekknolagi> shachaf: i know, but why the switch?
22:43:24 <shachaf> Huh?
22:43:36 <tekknolagi> why from compilation to interpretation?
22:43:43 <ivanm> tekknolagi: for what?
22:43:53 <Cale> Who switched?
22:44:05 <ivanm> some languages are typically interpreted; others are typically compiled, and yet others are typically done both ways
22:44:18 <ivanm> then there are those that compile to some kind of byte-code and interpreted on a VM
22:44:23 <tekknolagi> like Python!
22:44:24 <dankna> some languages are typically not used at all, neither comiled nor interpreted
22:44:24 <ivanm> (e.g. Java)
22:44:28 <dankna> (Brainfuck comes to mind)
22:44:31 <ivanm> dankna: heh
22:44:37 <tekknolagi> well BF is interpreted
22:44:37 <dankna> sorry, haha, I had to
22:44:40 <tekknolagi> and i wrote a compiler for it
22:44:45 <tekknolagi> kinda
22:44:46 <Cale> ISWIM is a better example
22:44:47 <ivanm> tekknolagi: there are other compilers as well
22:44:55 <dankna> sure, but in practice the compiler isn't used, because nobody writes anything in it :)
22:44:55 <ivanm> Cale: intercal?
22:44:58 <Cale> There are lots of BF compilers and interpreters
22:44:59 <shachaf> tekknolagi: No, it's compiled.
22:45:08 <Cale> and there are implementations of intercal, from what I remember
22:45:10 <sully> ivanm: basically all languages that are interpreted are interpreted by compiling to bytecode and then interpreting that with a bytecode VM
22:45:14 <ivanm> @quote @bf
22:45:14 <lambdabot> <erg0t> says: @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>. <lambdabot>  Hello World!
22:45:20 <shachaf> Cale: ISWIM is used by Conal all the time.
22:45:20 <sully> ivanm: anything else is basicaly impossible to make performant
22:45:22 <tekknolagi> whoa
22:45:23 <Cale> but ISWIM was never implemented and yet was more influential than any of those
22:45:31 <shachaf> To make a point.
22:45:38 <tekknolagi> what is iswim
22:45:41 <shachaf> (Or something like that.)
22:45:42 <tekknolagi> @google iswim
22:45:43 <lambdabot> https://www.thinkorswim.com/tos/displayPage.tos?webpage=iSwim&displayFormat=hide
22:45:43 <sully> ruby had an AST-walking interpreter before version 1.9 and it was slow as balls
22:45:54 <sully> now they have a bytecode interpreter, but it's still pretty fucking slow
22:45:55 <Cale> http://en.wikipedia.org/wiki/ISWIM
22:46:11 <sully> I think that perl is not a bytecode interpreter?
22:46:16 <sully> (but parrot is)
22:46:20 <ash_> macruby compiles ruby to native code now, so its both compiled and interpreted
22:46:26 <ash_> perl5 has a bytecode interpreter
22:46:36 <ash_> its converted to bytecode before executing
22:46:39 <ivanm> sully: well, bash isn't compiled to a bytecode AFAIK... :p
22:46:42 <sully> ok
22:46:47 <sully> somebody had told me it was AST-walking
22:46:52 <dankna> bah, there's a language called Gedanken.  now I want to use that name for a thought-experiment language? but can't, because it's taken
22:46:54 <sully> ivanm: yeah, that's probably true
22:46:55 <dankna> all the good names tend to be!
22:47:03 <tekknolagi> use "gurke"
22:47:07 <dankna> haha
22:47:07 <tekknolagi> it means cucumber :)
22:47:25 <dankna> cute
22:47:32 <shachaf> dankna: Yes, name your language Cucumber.
22:47:32 <sully> but like, if you are worried about the performance of your bash script too much
22:47:38 <sully> it is probably time to rewrite it in a new language
22:47:52 <Cale> Like Haskell
22:47:58 <sully> yeah, sure :P
22:48:06 <shachaf> sully: I know someone who spent a while optimizing a zsh script.
22:48:13 <tekknolagi> shachaf: why not? this is named haskell, python is named after a show, ruby is named after a rock, and basic is named after its difficulty leve;
22:48:14 <ivanm> Cale: there is apparently some ISWIM implementations: http://code.google.com/p/kiama/source/browse/src/org/kiama/example/iswim/README.txt?r=0d00350fc0e7a75216ac7167e5b6a11e3f3ac1d7
22:48:15 <shachaf> Or maybe he was just planning to?
22:48:15 <sully> although honestly I'd probably do it in python
22:48:17 <tekknolagi> why not vegetables?
22:48:28 <Cale> I once wrote an IRC bot as what was essentially one long bash pipeline
22:48:29 <ifnspifn> so I'm about to log out -- before I go, where's the next step for getting acquainted with Haskell? I rather like it thus far
22:48:41 <sully> ifnspifn: what have you been using so far?
22:48:48 <Cale> ifnspifn: What have you done/read?
22:48:50 <ifnspifn> C, Java, Javascript, Ruby
22:48:54 * hackagebot wai-app-file-cgi 0.2.3 - File/CGI App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.2.3 (KazuYamamoto)
22:48:58 <ifnspifn> Obj-C to a small extent
22:48:59 <Cale> ifnspifn: I mean, about Haskell
22:49:02 <ifnspifn> oh
22:49:05 <yuriks> ifnspifn: learnyouahaskell is a nice intro, practical haskell too, though it gets a bit heavy sometimes
22:49:05 <ifnspifn> well, uh
22:49:11 <ifnspifn> the tutorial on tryhaskell.org :P
22:49:20 <ivanm> shachaf: there was a joke at one point of having a grep daemon, etc. to optimise linux boot processes without resorting to systemd, etc. (as every grep, sed, etc. call required spawning a new process)
22:49:21 <tekknolagi> shachaf: why not? this is named haskell, python is named after a show, ruby is named after a rock, and basic is named after its difficulty level, C is named after a letter, JavaScript's name was a marketing ploy.
22:49:22 <Cale> ah, yeah, LYAH would be a good next step
22:49:29 <sully> I've used Real World Haskell and Learn You a Haskell
22:49:32 <Cale> http://learnyouahaskell.com/
22:49:53 <ash_> sully: perl's syntax cannot be converted into an AST without partial evaluation, but they do a few tricks in the parse to side step that problem by evaluating certain statements at runtime
22:49:53 <sully> although I mostly skimmed them looking for syntax until I got to the parts that weren't basically the same as SML modulo syntax
22:49:54 <yuriks> oh, yeah, real world haskell, not practical haskell :P
22:49:59 <ifnspifn> excellent :] what sorts of environments support it on Mac, if you know?
22:50:07 <sully> ash_: oh my god perl.
22:50:19 <ivanm> ifnspifn: the haskell platform is available for OSX
22:50:22 <yuriks> ifnspifn: http://hackage.haskell.org/platform/
22:50:23 <ivanm> if that's what you mean
22:50:27 <ifnspifn> beautiful, thank you
22:50:40 * sully not a real haskeller; I am a spy over from ML-land
22:50:50 <hogfathom> Guys, I think there's something I'm missing about function composition.
22:50:57 <ifnspifn> thanks for the reading material folks, g'night
22:51:11 <sully> although I'm switching to haskell more and more just on practical grounds
22:51:14 <ivanm> hogfathom: what?
22:51:17 <shachaf> sully: Is ML-land worth visiting?
22:51:31 <hogfathom> I created a function and haskell is complaining that it returns a function and doesn't know how to show it
22:51:33 <shachaf> @remember sully although I'm switching to haskell more and more just on practical grounds
22:51:34 <lambdabot> Okay.
22:51:34 <hogfathom> But I can't see how that is
22:51:35 <ivanm> sully: which ML?
22:51:37 <hogfathom> :S
22:51:40 <sully> ivanm: SML
22:51:46 <ivanm> hogfathom: well, you _can't_ show a function!
22:51:53 <hogfathom> I know, but it shouldn't return a function
22:51:57 <hogfathom> The function I wrote
22:52:07 <hogfathom> I can't tell why it returns a function
22:52:07 <ivanm> hogfathom: lemme guess, you did something like:
22:52:09 <sully> shachaf: if you find yourself thinking "man, I love this language but I'm not a big fan of laziness and purity", then yeah
22:52:12 <ivanm> > prec . (*2) 3
22:52:13 <lambdabot>   Not in scope: `prec'
22:52:19 <ivanm> > pred . (*2) 3
22:52:19 <lambdabot>   No instance for (GHC.Num.Num (f a))
22:52:20 <lambdabot>    arising from a use of `e_123' at <in...
22:52:24 <ivanm> hogfathom: ^^ something like that?
22:52:27 <hogfathom> It doesn't look anything like that
22:52:31 <sully> SML also has a pretty cool module system
22:52:31 <shachaf> sully: Are you not a big fan of laziness and purity?
22:52:34 <ivanm> @hpaste
22:52:34 <lambdabot> Haskell pastebin: http://hpaste.org/
22:52:47 <ivanm> hogfathom: ^^ can you paste your code and your error so that we can have a look?
22:52:48 <Cale> hogfathom: Apply the resulting function to another parameter?
22:52:51 <hogfathom> Sure
22:52:57 <Cale> Yeah, paste your code
22:53:03 <sully> shachaf: I'm not a fan of laziness. I could maybe be convinced about purity?
22:53:16 <ash_> for the interested, there have been a number of people that have talked about the parsing of perl http://www.jeffreykegler.com/Home/perl-and-undecidability has a list of 3 articles discussing it in pretty good detail
22:53:25 <hpaste> hogfathom pasted “Euler Seven” at http://hpaste.org/48185
22:53:29 <Cale> sully: Laziness (or at least non-strict semantics) is awesome for compositionality
22:53:30 <ivanm> sully: but how else can you tie-the-knot programming?
22:53:34 <hogfathom> Did I do that right?
22:53:46 <sully> ivanm: what do you mean by that?
22:53:51 <ivanm> hogfathom: how do you call it?
22:53:57 <ivanm> @where tying-the-knot
22:53:57 <lambdabot> I know nothing about tying-the-knot.
22:54:01 <ivanm> @where tying
22:54:01 <lambdabot> I know nothing about tying.
22:54:02 <Cale> sully: But it takes some getting used to as far as performance is concerned (like learning to write efficient strict programs)
22:54:05 <ivanm> @google tying-the-knot
22:54:06 <lambdabot> http://www.1049films.com/
22:54:06 <lambdabot> Title: Tying the Knot - The Movie
22:54:08 <ivanm> bah
22:54:09 <hogfathom> I just call it with a number
22:54:10 <ivanm> @google tying-the-knot haskell
22:54:11 <Cale> lol
22:54:11 <hogfathom> if that's what you mean
22:54:12 <lambdabot> http://www.haskell.org/haskellwiki/Tying_the_Knot
22:54:12 <lambdabot> Title: Tying the Knot - HaskellWiki
22:54:17 <ivanm> sully: ^^
22:54:25 <ivanm> hogfathom: like "eulerSeven 3" ?
22:54:28 <hogfathom> Yeah
22:54:38 <ivanm> can you paste the error up as well please?
22:54:44 <hogfathom> Ah, yes
22:54:47 <Cale> Tying the knot is less important than, say, being able to separate the production of a tree from the condition used to determine whether to explore some branch of it.
22:55:10 <sully> Cale: yeah, I'm familiar with the arguments in favor
22:55:22 <ivanm> Cale: as in lazy exploration of a search space?
22:55:27 <Cale> yeah
22:55:35 <sully> I mean, having laziness as an easy to use option is nice
22:55:50 <Cale> Strict programs end up being turned inside out, and you lose the ability to put things together from libraries
22:56:01 <Cale> if all your library functions are strict
22:56:02 <ivanm> *nod* I do something like that for some parsing (the laziness isn't really required, but it's cool to put in some trace messages just to see how the actual parse tree "grows" as you use it)
22:56:25 <Cale> So even just strictness by default is annoying, because it makes the optional laziness kinda useless.
22:56:43 <hpaste> hogfathom pasted “Euler Seven” at http://hpaste.org/48186
22:56:46 <Cale> (unless you're very disciplined about using it whenever you can)
22:56:48 <tekknolagi> can one have variadic arguments in haskell?
22:56:58 <Cale> tekknolagi: yes, but it's complicated
22:57:12 <hog> Oops
22:57:14 <tekknolagi> ...how complicated? nowhere near as easy as python's?
22:57:20 <hog> Accidentally closed irc somehow
22:57:23 <hog> It pasted though, right?
22:57:25 <Cale> tekknolagi: You use a typeclass
22:57:31 <tekknolagi> hog: it pasted, yah
22:57:34 <ivanm> hog: your error comes up from what you're doing in ghci
22:57:40 <Cale> You can see Text.Printf for the general idea
22:57:54 <hog> Not sure why "hogfathom" is still in here...
22:57:55 <ivanm> hog: you must just be entering "eulerSeven" or something in ghci
22:58:00 <Cale> hog: Did you forget to apply eulerSeven to a parameter?
22:58:16 <Cale> :t printf
22:58:17 <tekknolagi> typeclass.... o.O that does sound complicated
22:58:17 <lambdabot> forall r. (PrintfType r) => String -> r
22:58:27 <ivanm> hog: you can use "/msg nickserv ghost" to kill hogfathom
22:58:33 <hog> Cale: you know what?
22:58:38 <Cale> > printf "%i %d" 5 pi :: String
22:58:39 <lambdabot>   "5 *Exception: Printf.printf: bad argument
22:58:43 <Cale> lol
22:58:52 <Cale> > printf "%i %f" 5 pi :: String
22:58:53 <lambdabot>   "5 3.141592653589793"
22:58:56 <ivanm> Cale: printf-th !
22:58:57 * hackagebot mighttpd2 2.2.2 - A classical web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.2.2 (KazuYamamoto)
22:59:00 <hog> Cale: I am the dumb
22:59:00 <hog> That is what happened
22:59:00 <hog> *facepalm*
22:59:00 <hog> I'm usually not this stupid, I swear
22:59:04 <ivanm> (or whatever the statically-checked version is called)
22:59:06 <azaq23> hog: hogfanthom will ping timeout in a few seconds - if you just killed your irc application or if it doesn't log out on closing, this will happen
22:59:11 <hog> Oh, apparently mIRC minimizes to taskbar
22:59:14 <sully> so, I buy that composing things is easier because of laziness
22:59:16 <Cale> hog: Well, the error message says as much
22:59:32 <hog> Yeah, I guess you're right
22:59:34 <Cale> (that it doesn't know how to show a function of type Int -> ...)
22:59:39 <hog> I'm new to Haskell and to programming in general
22:59:39 <sully> I think you are overstating the case some, though
22:59:40 <ivanm> Cale: yet when I suggested that he said that wasn't the case! *humph* :p
22:59:44 <shachaf> sully: Laziness will also never make a strict program not-terminate, but the reverse is not true. :-)
22:59:47 <hog> so
22:59:47 <hog> :S
23:00:07 <ivanm> Cale: didn't augustsson have some good examples in a blog post recently about why laziness is nice?
23:00:10 <Cale> hog: No worries!
23:00:13 <ivanm> in response to harper IIRC
23:00:24 <Cale> Why Functional Programming Matters
23:00:27 <Cale> is mislabelled
23:00:30 <Cale> and should be called
23:00:39 <Cale> Why Nonstrict Semantics Matters
23:00:40 <sully> I mean, as somebody who writes in strict languages, I don't think that I've lost the ability to put things to together from libraries
23:00:51 <ivanm> Cale: need pure/referentially transparent in there as well
23:00:53 <sully> (Harper also overstates his case approximately always)
23:01:08 <shachaf> sully: The whole data-structures-represent-control-structures property of laziness is pretty neat.
23:01:15 <sully> shachaf: right, but either it will do something different or I need to get rid of my effects too
23:01:20 <ivanm> sully: http://augustss.blogspot.com/
23:01:21 <Cale> sully: Well, your libraries likely don't even have a lot of stuff because it just isn't as useful in a strict language
23:01:31 <Cale> For example, tails is super-useful in Haskell
23:01:38 <Cale> > tails "Hello, World!"
23:01:39 <lambdabot>   ["Hello, World!","ello, World!","llo, World!","lo, World!","o, World!",", W...
23:01:41 <sully> well, my libraries don't have a lot of stuff because SML is a dead language
23:02:13 <Cale> > any (isPrefixOf "Wor") (tails "Hello, World!")
23:02:14 <lambdabot>   True
23:02:29 <ivanm> sully: see the "Reuse" bit of that blog post
23:02:37 <ivanm> which I think is what Cale is alluding to
23:02:41 <sully> yeah, I've read the post
23:02:52 <Cale> You wouldn't want to do something like that in a strict language, because it's dumber under strict evaluation than lazy.
23:02:54 <osfameron> why is tails less useful in a strict language?
23:03:05 <sully> because you computer all of the tails
23:03:09 <sully> instead of just the ones you care about
23:03:13 <osfameron> ah yes, fair enough
23:03:15 <sully> *compute
23:03:29 <Cale> Your computer accidentally all of the tails
23:03:50 <Cale> ;)
23:03:52 * ivanm accidentally the goes home
23:04:08 <ivanm> I blame Cale for phrasing it that way :p
23:04:13 <osfameron> of course, if your language has a promise {} primitive, you could define a lazyTails
23:04:20 * shachaf accidentally adds the an additional word.
23:04:56 <Cale> osfameron: sure, but you're relying on your libraries to be lazy whenever you might need it then
23:05:14 <shachaf> Cale: You're relying on your libraries being lazy in Haskell too. :-)
23:05:24 <shachaf> It's just more common, because it's the default.
23:05:29 <Cale> sure, but laziness is the default, so we do it more
23:05:32 <Cale> yes
23:06:21 <shachaf> That's not necessarily an argument for pervasive laziness, though. Most optimized Haskell libraries will have at least a bit of strictness in them.
23:06:44 <Cale> Well, there's an even more refined one :)
23:07:45 <Cale> Let's break functions down into cases based on whether their inputs and outputs are 'large' or 'small' in terms of the number of parts they have which could conceivably be evaluated separately
23:08:10 <Cale> The only case where strictness is really important is functions of type  large -> small
23:08:47 <Cale> and that, only when the small result is done by summarizing all/most of the input, rather than by selecting a part of it
23:09:45 <Cale> In all other cases, lazy evaluation is either roughly equivalent to strict evaluation (though it may induce a bit of overhead), or preferable.
23:11:17 <sully> except that laziness can introduce asymptotic space inefficiencies
23:11:25 <sully> that need to be resolved by adding in strictness
23:11:29 <Cale> Only in that case I specified
23:11:53 <Cale> and for that matter, so can strictness
23:12:12 <sully> that seems like a fairly common case
23:12:45 <sully> I mean, in any case, I really am familiar with the arguments for why laziness is good
23:12:48 <Cale> People who are used to strictness automatically program around the awkward cases where it would be horribly space inefficient, and the same goes for people used to lazy programming.
23:12:55 <sully> there are trade-offs
23:13:10 <sully> I've made my decision on what is more important to me. I don't expect everyone to make the same one
23:17:07 <yitz> sully: this is not a question of priorities that needs a decision about relative importance. it is two very different styles.
23:18:29 <yitz> sully: it's worthwhile to have the level of understanding of both that comes from having implemented serious-sized projects, while making a bona-fide effort to write truly idiomatically for that paradigm.
23:18:48 <sully> yeah, which is why I'm in #haskell and writing haskell programs :P
23:19:00 <yitz> sully: :)
23:19:19 <sully> and in any case, you guys have typeclasses and a living community that writes libraries
23:19:34 <sully> although I miss my module system
23:20:06 <dankna> yeah, for me, it's as much about agreeing with the community's vision for the language as it is liking the state of it at any given point in time
23:20:12 <sully> (SML badly needs a language revision)
23:20:42 <yitz> dankna: yes, it can be very frustrating if the community is heading off in a different direction than you are
23:20:43 <dankna> I loved the Nintendo DS as a platform at one time, but what I wasn't thinking through was that Nintendo was moving in a direction tangent to how I wanted them to move
23:20:48 <sully> it needs a lot of syntax fixes, an expanded standard library, Harper's modular typeclasses
23:21:12 <dankna> I see
23:21:21 <yitz> dankna: i've seen it happen to good people in the haskell community. i feel very bad for them.
23:21:30 <dankna> ah, indeed
23:21:45 <sanjoyd> hlint makes me look so smart. :D
23:22:55 <yitz> dankna: personally, i think iteratees is a major mistake. the right direction, in the mid-term until a lot more progress is made on FRP, is building higher-level combinators on top of lazy IO that have richer semantics.
23:23:17 <yitz> dankna: but that's my opinion. the community seems to be going the other way, so i'm rolling along with them.
23:23:19 <dankna> hmm
23:23:29 <dankna> I honestly? have been ignoring iteratees
23:23:32 <dankna> I"m not even totally sure what they are
23:23:35 <shachaf> Why are iteratees a major design mistake?
23:23:39 <dankna> although I imagine they have something to do with iteration fusion
23:23:44 <dankna> but yes, rolling with it is probably the best move
23:24:07 <yitz> dankna: i recently have been making a concerted effort not to ignore them. it's difficult, because i hate them. :)
23:24:27 <dankna> fair :)
23:24:54 <Saizan> an iteratee is a stream consumer, essentially
23:24:59 <shachaf> After looking at a bit of iteratee code a coworker and I weren't particularly fond of it, but then he read some things about them and now apparently he really likes them.
23:25:17 <Saizan> which can be fed the stream in chunks
23:25:19 <yitz> shachaf: bolting scheme-style obfuscated CPS onto Haskell is losing out on a lot of Haskell's power and beauty
23:26:11 <dankna> stream consumer.  hm.
23:26:26 <yitz> shachaf: lately i've been debugging apps that i've written based libraries that use iteratee/enumeratee.
23:26:42 <yitz> shachaf: it feels like debugging BASIC with gotos.
23:27:26 <yitz> shachaf: lazy IO is *so* much more elegant, and at least as efficient when used correctly.
23:28:33 <Saizan> dankna: the difference between an iteratee and ([a] -> b) (where [a] is the stream here), is that you don't have to have the whole input to start feeding it into the iteratee, which will also signal you when it won't consume any more of it
23:28:38 <shachaf> Lazy IO as in unsafeInterleaveIO?
23:29:03 <Saizan> in a sense it's a way of being extra-explicit about lazyness
23:29:16 <dankna> hmmm?. okay, that sounds sort of nice, I guess
23:29:23 <yitz> shachaf: well sometimes you need that, when the higher-level combinator you need is missing. so you write that combinator.
23:29:30 <dankna> I honestly very seldom want to pass streams of things around anyway
23:29:34 <maurer_> I also disagree with iteratees. I think we just need weaker semantics for lazy IO, i.e. thunks may be arbitrarily forced, the only garuantee you have is that all the thunks you needed forced are eventually forced.
23:29:48 <dankna> this might have to do with the fact that I'm not really a functional programmer at heart, as previously discussed
23:29:55 <dankna> don't get me wrong, I love higher-order functions
23:30:16 <Saizan> dankna: these are mostly used for implementing network protocols, actually :)
23:30:16 <dankna> but as part of my own idiolect, which I seriously call by a silly name, "useful programming"
23:30:19 <dankna> hmmm okay then
23:30:20 <yitz> maurer_: we need different semantics in different situations. a much richer library of combinators. like what you say, the oposite, and in between.
23:30:22 <dankna> that makes some sense
23:30:57 <maurer_> yitz: I mean, the biggest thing here is that I want to remob eth eprogrammer's ability to assume a thunk _isn't_ forced.
23:31:01 <maurer_> *remove the
23:31:47 <yitz> maurer_: sometimes you want 'em forced sometimes not.
23:32:08 <maurer_> yitz: If you want to ensure it is forced, it should not be inside any sort of unsafe*IO
23:33:25 <yitz> maurer_: that's not the issue. unsafe* should not appear in normal programs at all, either way. they are low-level constructs, accessing compiler internals, which can be used in many different ways to get meaningful combinators with the semantics you need.
23:34:01 <maurer_> yitz: Sure, but the point is that you shouldn't use something even _derived_ from unsafe* if you care about sequencing
23:34:31 <maurer_> Then the second point here is that usually, you shouldn't care about sequencing.
23:35:15 <yitz> maurer_: not true. you can and must use them to build the combinators. you just have to understand the low-level semantics fully when using them, and relieve the library user of needing to know that.
23:36:04 <shachaf> Would you consider getContents such a combinator?
23:36:37 <yitz> shachaf: an extremely primitive one, yes
23:36:49 <tekknolagi> you guys ever heard of Lithe?
23:36:52 <tekknolagi> it's a programming language
23:36:55 <tekknolagi> though
23:36:57 <tekknolagi> i can't find the download - anyone know where to find it?
23:36:59 <yitz> @google lithe
23:37:00 <lambdabot> http://dictionary.reference.com/browse/lithe
23:37:03 <sully> I,I Lithe Assailant
23:37:31 <yitz> @vixen have you ever heard of Lithe?
23:37:31 <lambdabot> let me answer that later, okay?
23:38:26 <tekknolagi> dammit >.<
23:38:27 <yitz> tekknolagi: sorry we speak Haskell here. is there a #lithe channel? is Lithe related to Haskell in some way?
23:38:56 <yitz> tekknolagi: it sounds like Lisp with a.. well, with a lisp.
23:39:31 <tekknolagi> you guys are pretty much the only knowledgeable ones here. the folks on the Python channel have a collective intelligence at the theoretical zero point
23:39:57 <tekknolagi> no, there is no #lithe channel
23:40:10 <tekknolagi> yitz: it's not. i'll post a small code sample in a sec
23:40:38 <tekknolagi> https://gist.github.com/ba96e8610117ddbec724
23:40:41 <tekknolagi> that's absolute value
23:40:58 <tekknolagi> then you can do stuff like | 2 - 5 | + 3
23:41:08 <tekknolagi> you can *define* operators and shit
23:42:09 <shachaf> Linking to the Wikipedia article would have been just as effective.
23:42:23 <tekknolagi> true, true - forgot about it
23:42:30 <tekknolagi> it almost doesn't exist
23:42:36 <tekknolagi> (the article)
23:42:41 <yitz> tekknolagi: right i don't see any apparent relation to haskell. or lisp for that matter.
23:43:15 <yitz> tekknolagi: if you want to write a compiler for it in haskell, that's something you could discuss here. it might be fun.
23:44:00 <tekknolagi> sorry - just trying to ask the people that actually know something >.<
23:44:12 <tekknolagi> though
23:44:21 <tekknolagi> i've never written a compiler or interpreter in Haskell
23:44:28 <tekknolagi> what's it like?
23:45:17 <yitz> tekknolagi: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
23:45:38 <tekknolagi> ooh thank you!
23:46:07 <tekknolagi> why are things related to Haskell in the format `something something A something`?
23:46:24 <tekknolagi> (e.g. learn yourself A haskell, write yourself A scheme)
23:46:43 <yitz> tekknolagi: those are the only two i know about
23:47:00 <yitz> tekknolagi: they're both really cool though
23:47:08 <tekknolagi> oh
23:47:08 <tekknolagi> k
23:47:25 <tekknolagi> do people just hang around IRC channels and not feel like jumping in?
23:47:47 <tekknolagi> there are so many people here, and none talking
23:48:24 <ivan> projection fallacy, you think everyone is using IRC the same way you are :)
23:48:47 <tekknolagi> ivan: i asked a question; i asked if they happen to jump in at all
23:49:38 <tekknolagi> but sure, sure
