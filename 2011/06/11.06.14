00:01:04 <erus`> actually i favour easy and prettyness of code over speed
00:03:33 <isomorphic> erus`: C arrays?
00:03:33 <lambdabot> isomorphic: You have 1 new message. '/msg lambdabot @messages' to read it.
00:04:04 <frerich2> erus`: I like to use Data.Array for that; random access is done using (!) and modifying elements is done with (//)
00:07:28 <erus`> ok :)
00:07:30 <erus`> > take 9 $ repeat Nothing
00:07:31 <lambdabot>   [Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing]
00:07:40 <erus`> is there a quicker way to right that?
00:08:11 <ddarius> > replicate 9 Nothing
00:08:11 <lambdabot>   [Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing]
00:10:27 * ddarius wonders why blackdog has SharePoint questions.
00:11:51 <blackdog> ddarius: boss has promised a client sharepoint integration
00:12:05 <blackdog> i was looking for shapr because he's worked with it before
00:12:07 <blackdog> (i think)
00:12:08 <ddarius> Integration with what?
00:12:10 <ddarius> He has.
00:12:32 <blackdog> our product - dropbox-ish sort of thing
00:12:41 <blackdog> halfway between dropbox and a CMS, i suppose.
00:12:59 <ddarius> blackdog: What technology does it use?
00:13:47 <blackdog> ddarius: ruby
00:13:59 <blackdog> it's still a bit prototypical
00:47:25 <roconnor> is IntMap balanced?
00:48:42 <erus`> i want to add an element onto the end of a list
00:48:52 <erus`> at the moment i have xs ++ [x]
00:48:58 <erus`> is there a quicker way?
00:49:20 <mmaruseacph2> erus`, using difference lists
00:49:27 <mmaruseacph2> or Okasaki's Queue
00:50:35 <shachaf> Or consing and then reversing.
00:50:46 <shachaf> Or not using lists at all.
00:50:54 <frerich2> erus`: I don't think there's a quicker way. SOmetimes it's possible to write the code so that it actually builds a list in reverse order (so the last element of the list is added first) - then you just have to reverse once at the end.
00:50:58 <ddarius> roconnor: My impression is that it is basically a trie on the bits, so it wouldn't be balanced.
00:52:36 <roconnor> ddarius: ah. Can I expect deleting from an IntMap (and hence HashMap) to have a lot more sharing than deleting from a Data.Map?
00:52:43 <roconnor> this is what I imagine.
01:02:30 <roconnor> damn.  hashable depends on text, which depends on deepseq which depends on ...
01:03:02 <roconnor> I hate these suprious dependencies that the anti-orphan-instancers burden us with
01:03:41 * roconnor tries to use hashable 1.0.1.1 instead
01:04:35 <osfameron> what are anti-orphan-instancers?
01:05:05 <roconnor> people who are against having orphan instances
01:10:49 <sipa> what are orphan instances?
01:11:24 * osfameron googles, and discovers http://www.haskell.org/haskellwiki/Orphan_instance
01:12:32 <roconnor> sipa: they are class instances of types that neither occur in the module defining the type, nor in the module defining the class.
01:13:07 <roconnor> sipa: the problem with them is that you could have two modules define two different (or same) orphan instances for the same class/type paire
01:13:22 <roconnor> then when you try to use both modules you blow up.
01:13:26 <sipa> thanks for the summary, roconnor :)
01:13:51 <osfameron> why can't you exclude one of the instances?  (as you would do with clashing names in a normal package)
01:14:07 <sipa> is it possible the exclude instances?
01:14:07 <c_wraith> there's no mechanism to select instances
01:14:12 <roconnor> osfameron: because there is no way to control imports of instances; they are always imported
01:14:19 <c_wraith> in theory, sure.  but there's nothing in the language that allows it.
01:14:27 <c_wraith> and there are consistency issues with excluding instances
01:14:35 <roconnor> this is probably the biggest problem with the design of the haskell language
01:14:46 <osfameron> what are the workarounds?
01:14:50 <quicksilver> osfameron: it is a global error to have two different instances linked into the same program.
01:14:59 <quicksilver> osfameron: GHC does not report all such errors - but that is a bug in GHC.
01:15:11 <erus`> i need todo if condition1 then func1 else if condition2 then func2 two else func3 else func3
01:15:18 <erus`> i there a neater way todo that?
01:15:39 <quicksilver> erus`: people often use guards
01:15:55 <sipa> case (condition1,condition2) of { (True,_) -> func1; (False,True) -> func2; (False,False) -> func3 }
01:15:55 <roconnor> osfameron: you can make one (or both) of the orphan instances operate on a newtype instead of the actual type.
01:16:16 <roconnor> osfameron: but that requires editing a module that you may or may not have privledges to edit.
01:16:30 <osfameron> could you not move both the orphan instances into an entirely new 3rd package?
01:16:38 <osfameron> i.e. have both original packages import that instead
01:17:00 <roconnor> osfameron: yes, I think that is my perfered solution; though that doesn't quite work if the two instances are different.
01:17:45 <roconnor> I think it would be rare for two people to fight over two different instances for a type without using newtype wrappers.
01:17:57 <roconnor> I suppose it is possible.
01:18:06 <erus`> is there an `elem` type function for Data.Array?
01:18:06 <quicksilver> a import system which permitted type renaming would help with certain cases
01:18:25 <erus`> @hoogle Array -> a -> Bool
01:18:26 <lambdabot> Did you mean: Array a a -> a -> Bool /count=20
01:18:26 <lambdabot> Prelude seq :: a -> b -> b
01:18:26 <lambdabot> Control.Parallel par :: a -> b -> b
01:18:33 <quicksilver> to allow you to newtype all uses of a type in another library
01:20:42 <ClaudiusMaximus> hm, enabling GeneralizedNewtypeDeriving doesn't affect derived Read/Show instances it seems - so newtype X = X Y deriving Show  gives show (X y) == "X " ++ show y
01:21:42 <ClaudiusMaximus> not sure whether that's a good thing or a bad thing, probably less surprising than the extension changing the derived instance
01:21:43 <tsanhwa> @hoogle try
01:21:43 <lambdabot> Control.Exception try :: Exception e => IO a -> IO (Either e a)
01:21:43 <lambdabot> Control.OldException try :: IO a -> IO (Either Exception a)
01:21:43 <lambdabot> Control.Exception.Base try :: Exception e => IO a -> IO (Either e a)
01:24:18 * roconnor replaces import qualified Data.Map as M with import qualified Data.HashMap as M
01:30:01 * Phyx- <3 SYB
01:30:31 <roconnor> Phyx-: is the the one where you get lots of run-time type errors?
01:35:06 <Phyx-> roconnor: runtime type errors?
01:35:20 <accel> probably run time type matching not complete errors
01:35:40 <roconnor> I thought SYB put everything into Dynamic did run-time type checking.
01:35:45 <roconnor> maybe I'm misremembering
01:37:30 <quicksilver> not quite
01:37:45 <quicksilver> SYB encodes details about the structure of your type into a 'Data' instance
01:38:07 <quicksilver> and then 'trusts' those details to perform various tricks via the moral equivalent of Dynamic or unsafeCoerce
01:38:24 <quicksilver> but as long as the you trust the instance there are no runtime errors.
01:40:47 <roconnor> ah
01:40:53 <roconnor> safer than I figured
01:41:59 <roconnor> this HashMap is working much better for me than Data.Map =)
01:43:30 <roconnor> or not :(
01:43:45 <roconnor> what the hell?
01:52:22 <Phyx-> yeah, what quicksilver said..
01:52:24 * Phyx- was on the phone
01:52:49 <Phyx-> wonder why gmail is marking -cafe mail as important
02:05:42 <roconnor> is it unusual to exhast a 512 MB heap with 396 MB total memory in use?
02:05:58 <roconnor> is the Gen:1 garbage collector causing this?
02:07:00 * roconnor finds GHC's heap statistics very very confusing
02:07:09 <roconnor> none of it makes any sense to me.
02:11:22 <quicksilver> roconnor: it's a copying collector so you need 2x the space
02:12:25 <zygoloid> Phyx-: gmail is just really smart ;)
02:13:05 <quicksilver> and because of the way heaps grow, in a growing heap you need 3x the space, I believe, but I can no longer reconstruct that argument.
02:14:12 <mjrosenb> quicksilver: "a growing heap"?
02:14:15 <roconnor> ok
02:14:43 <mjrosenb> if your gc ever needs more than twice the allocated space, i suspect something is *very* wrong
02:14:59 <zygoloid> i've definitely heard the 3x claim for GHC before
02:15:07 <Phyx-> zygoloid: :)
02:15:45 <Phyx-> :t mkQ []
02:15:46 <lambdabot> forall a b a1. (Typeable a1, Typeable b) => (b -> [a]) -> a1 -> [a]
02:15:52 <int-e> but ghc has a compacting gc as well, and uses it by default if more than 30% of the maximum heap size (set by the -M option) is live data, hmm. ( http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-gc ).
02:16:14 <Phyx-> :t mkQ [] (\_ _-> [])
02:16:15 <lambdabot>     The lambda expression `\ _ _ -> []' has two arguments,
02:16:15 <lambdabot>     but its type `b -> [a]' has only one
02:16:15 <lambdabot>     In the second argument of `mkQ', namely `(\ _ _ -> [])'
02:16:44 <Phyx-> Am I missing something there? why can't b just be in the form of a (c->d) ?
02:17:57 <Phyx-> :k Typeable
02:17:58 <lambdabot>     Class `Typeable' used as a type
02:17:58 <lambdabot>     In the type `Typeable'
02:18:04 <Phyx-> :info Typeable
02:18:34 <zygoloid> Phyx-: -> is right-associative.
02:19:03 <Phyx-> ah, crap, right
02:19:38 <int-e> zygoloid: I think the 3x number comes from the -F option: If the live data size is M bytes, then we will allocate 2M bytes before doing the next (major) garbage collection. To collect the live data, we need another memory area of size M --> 3M total.
02:22:43 <roconnor> what is the idea behind -F?
02:22:45 <ClaudiusMaximus> any bindings to avahi/zeroconf/bonjour/etc? or some other way to let my application automagically find other instances of itself on my LAN?
02:25:18 <zygoloid> int-e: that doubling behaviour would have been my guess :)
02:25:32 <zygoloid> roconnor: http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/runtime-control.html search for '-Ffactor'
02:27:48 <roconnor> heh, running performGC a lot really slows things down. =)
02:29:50 <bmm> How do I create a unicode string from a escaped unicode string (so how do I get "some \u2665 surgery" to become a string)?
02:29:50 <lambdabot> bmm: You have 1 new message. '/msg lambdabot @messages' to read it.
02:30:49 <Jafet> > text "some \2665 surgery"
02:30:50 <lambdabot>   some
02:31:30 <bmm> Jafet: it's an utf heart character \u2665 :)
02:31:57 <Phyx-> yay my code compiles... 40 lines compressed down to 4 with SYB
02:32:21 <Jafet> > 0x2665
02:32:22 <lambdabot>   9829
02:32:26 <Jafet> > text "some \9829 surgery"
02:32:27 <lambdabot>   some
02:32:45 <sipa> ♥
02:32:45 <Jafet> Hrm
02:32:53 <Jafet> > "♥"
02:32:54 <lambdabot>   "\9829"
02:33:06 <Phyx-> ♥
02:33:39 <DevHC> > (<3)
02:33:40 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Bool.Bool)
02:33:40 <lambdabot>    arising fro...
02:34:00 <kstt> hi, there is the isString class that provides 'fromString :: String -> a'. Is there an other class that provides the 'toString :: (Stringable a) => a -> String' for String, ByteString, Text ... ?
02:34:14 <bmm> Ah, cool, got it now. Just replace the u with an x: putStrLn "some \x2665 surgery"
02:34:21 <kstt> (efficiently if possible)
02:34:29 <bmm> Thanks for the help guys!
02:34:50 <bmm> > putStrLn "some \x2665 surgery"
02:34:51 <lambdabot>   <IO ()>
02:34:56 <bmm> > text "some \x2665 surgery"
02:34:57 <lambdabot>   some
02:35:20 <DevHC> kstt: u probably mean the Show class which has (read :: String -> a)
02:35:39 <lunaris> DevHC: Or show :: a -> String even :)
02:35:43 <kstt> DevHC: ok, I was wondering if there was an other or not
02:35:59 <DevHC> uhm
02:36:02 <DevHC> Read*
02:36:09 <Jafet> kstt: er, ByteString corresponds to [Word8], not String.
02:36:18 <Jafet> Why do you want this?
02:36:19 <lunaris> DevHC: kstt requested a function of type a -> String
02:36:48 <lunaris> Jafet: ByteString.Char8?
02:37:07 <kstt> lunaris: yeah, but DevHC gave me the right function. The type is just inverted :)
02:37:19 <kstt> the right _class_
02:37:55 <Jafet> lunaris: that doesn't correspond to String, either.
02:38:09 <kstt> Jafet: I'd like a function to be polymorphic in a parameter 's', so that it can accept Strings and ByteStrings.
02:38:23 <blackdog> am i likely to be able do better than 500ns for a C call? I seem to be able to execute id in 50ns, but the equivalent of id in C seems to take 500ns or so...
02:40:22 <Jafet> kstt: the only thing String and ByteString have in common is that they're sequences – one of Char, and one of Word8... so you want this function to operate on sequences?
02:40:51 <ClaudiusMaximus> blackdog: threaded runtime? safe or unsafe foreign import?
02:41:45 <kstt> Jafet: specifically, there is some « string type mismatch » between various libs I use in a project (Snap with bytestrings, HDBC with strings and so on). I wrote some HDBC request functions that will take a "string-like" parameter. But I want to be able to use them with Strings OR ByteStrings.
02:41:47 <blackdog> ah, i haven't turned on unsafe. non-threaded runtime
02:42:24 <kstt> Jafet: because I don't want my logic code to be littered with BS.pack and BS.unpack
02:42:46 <Jafet> You're using BS.pack and BS.unpack to convert between String and ByteString?
02:42:56 <kstt> at the moment, yes
02:43:17 <kstt> I could write such a class myself and provide instances for String, ByteString, and Text. But that must already exist :)
02:43:22 <Jafet> @type Data.ByteString.pack
02:43:23 <lambdabot> [Word8] -> BSC.ByteString
02:43:32 <Jafet> No, what you're saying doesn't typecheck
02:45:47 <kstt> There is an instance of Show for ByteString
02:46:05 <kstt> that does seem to typecheck :)
02:46:29 <kstt> I'd be happy with that, but show is just too wide for my needs.
02:46:58 * zygoloid hates the FFI safe/unsafe keywords (where safe functions are marked unsafe, and unsafe functions are marked safe)
02:47:40 * Jafet puts zygoloid into the total perspective vortex
02:47:42 <blackdog> zygoloid: yeah, it's really done from the viewpoint of the implementation, i suppose
02:48:09 <Jafet> kstt: and how do you convert String to ByteString?
02:48:39 <zygoloid> blackdog: yeah. that's not something i want to care about as a user. i think i'd hate it just as much the other way around, though :)
02:49:10 <kstt> Jafet: I need to go the other way at the moment
02:49:19 <Twey> Oh gods
02:49:47 <Twey> http://vimeo.com/6612724 — because having a Turing-complete typesystem isn't enough; now we need a Turing-complete kind system, as well
02:49:50 <zygoloid> any unambiguous pair would be better. careful/fast?
02:50:16 <zygoloid> Twey: at least it's not turtles all the way down :)
02:50:24 <Jafet> kstt: could you answer the question, first?
02:50:55 <blackdog> checked/unchecked?
02:51:00 <kstt> Jafet: I guess that's the point of 'pack'. However, I understand that 'pack . show' != id
02:51:02 <blackdog> anyway. not going to change now :)
02:51:14 <Jafet> kstt: I showed you the type of pack, above. It doesn't typecheck.
02:52:06 <Twey> zygoloid: Not yet :þ
02:52:18 <Jafet> Turings all the way down
02:52:31 <kstt> Jafet: that one typechecks http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString-Char8.html#v:pack
02:53:32 <Jafet> So what's your really really really excellent reason for using ByteString.Char8?
02:53:57 <Jafet> "[...] these byte strings are taken to be in the subset of Unicode covered by code points 0-255."
02:56:36 <absence> what's the state of high-level gui libraries in haskell? at first glance it seems like some of them are broken or abandoned. anyone knows what works or what's "best"?
02:57:51 <kstt> Jafet: none. I sincerly appreciate your motivation to lead me to understand where I'm wrong. Unfortunatly, it's (mandatory) lunch time for me so I need to go. If you could point me to some reading to achieve this course, I'll read it as soon as I'm back. Thx
02:58:01 <blackdog> ClaudiusMaximus: interestingly, i can't seem to get any c call below 35ns, even if it's just returning the argument.
02:58:22 <blackdog> i guess some overhead isn't unreasonable
02:58:57 <Jafet> kstt: perhaps you can prove that your conversion will never need to deal with characters outside of Latin-1... but given that you're doing web programming on one hand and using a database on the other, I'm going to guess that you can't
02:59:10 <Jafet> In which case, using Char8 is incorrect.
02:59:30 <kstt> Jafet: fortunatly, I reallly want to go the other way : ByteString -> String
02:59:41 <kstt> at least at the moment
03:00:38 <Jafet> So there are some code points represented by the ByteString, and you want to pull them out into a String. How are they encoded?
03:00:48 <kstt> so if the Show instance for ByteString is unicode aware, all is good
03:01:06 <Jafet> ByteString has nothing to do with Unicode.
03:01:16 <Jafet> It's a string... of bytes.
03:02:05 <kstt> so it is not always suited for wab developments, where forms usually carrie user input
03:02:41 <Jafet> I'm guessing that this is a really good time for you to read about Unicode, code points, and encodings.
03:03:32 <Jafet> You encode a bunch of code points into bytes, and then decode the bytes back into code points.
03:03:55 <ClaudiusMaximus> blackdog: 35ns is how many clock cycles?
03:04:38 <Jafet> Probably about 100
03:05:36 <erus`> has anyone done minmax before?
03:05:44 <erus`> is it just choose the path with the highest minimum then the highest maximum>
03:05:59 <Twey> erus`: Yes
03:07:54 <erus`> why cant the wikipedia article just say that
03:08:27 <Twey> Heh
03:09:35 <erus`> is there a haskell editor with auto/tab completion like ghci?
03:09:44 <Jafet> Because "highest" is pretty vague
03:10:50 * ClaudiusMaximus would like it if there was a nice way to "copy last N lines of ghci history to end of the current file and :edit"
03:12:07 <Jafet> Run ghci in emacs, then do the opposite
03:12:23 <ClaudiusMaximus> where "N" could be "everything since the file was :reload"
03:12:38 <ClaudiusMaximus> i haven't recovered from the last time i tried emacs...
03:15:52 <ClaudiusMaximus> my experiment with cabal flags didn't work - i thought cabal was supposed to try all combinations and see what works?
03:16:36 <Jafet> It's not even a regulated drug. What's wrong with it?
03:16:55 <ClaudiusMaximus> or is that level of automagic not there  (i want to optionally build-depend on hmpfr)
03:17:25 <ClaudiusMaximus> the usual n00b scenario of not being able to figure out how to quit
03:24:12 <erus`> @hoogle xor
03:24:13 <lambdabot> Data.Bits xor :: Bits a => a -> a -> a
03:24:37 <int-e> roconnor: my understanding of -F is that it ties the garbage collection time to the rate of allocation - with F=2 and assuming constant working set size, you copy one byte during GC per byte allocated.
03:24:48 <erus`> is there a bool -> bool -> bool xor?
03:24:58 <ClaudiusMaximus> @instance Bits
03:24:58 <lambdabot> Maybe you meant: instances instances-importing
03:25:03 <ClaudiusMaximus> @instances Bits
03:25:04 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
03:25:12 <ClaudiusMaximus> @instances-importing Data.Bits Bits
03:25:12 <lambdabot> Int, Integer
03:26:36 <ClaudiusMaximus> hm, surprising
03:27:33 <ClaudiusMaximus> @check (/=) == (xor`on`(fromEnum::Bool->Int))
03:27:33 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
03:29:04 <mjrosenb> erus`: there is also /=
03:29:06 <ClaudiusMaximus> @check (\a b -> ((a::Bool) /= b) == (toEnum (fromEnum a `xor` fromEnum b) :: Bool)
03:29:06 <lambdabot>  Unbalanced parentheses
03:29:14 <ClaudiusMaximus> @check (\a b -> ((a::Bool) /= b) == (toEnum (fromEnum a `xor` fromEnum b) :: Bool))
03:29:14 <lambdabot>   "OK, passed 500 tests."
03:29:19 <mjrosenb> erus`: which is a fairly standard definition :-p
03:29:42 <mjrosenb> oh hey, ClaudiusMaximus just said that
03:29:48 <mjrosenb> i'm totally paying attention
03:29:50 <mjrosenb> i swear.
03:29:51 <ClaudiusMaximus> amidst a string of fail
03:29:53 <ClaudiusMaximus> :)
03:30:44 <augur> anyone know of some really out there paradigms currently being researched?
03:31:35 <lunaris> Functional programming? /trollface
03:31:40 * lunaris slinks away
03:32:18 <augur> lunaris: :P
03:32:39 <erus`> should it take long to evaluate a tictactoe game tree?
03:32:52 <augur> no
03:33:06 <erus`> it took about 10 secs to evaluate 255168 nodes
03:33:24 <augur> thats not long
03:33:40 <augur> atleast, i wouldnt consider it long
03:33:49 <erus`> thats ghci too not compiled
03:34:42 <erus`> only takes three when compiled
03:36:59 <erus`> is there a built in function to get total number of element x in a list before i write my own?
03:37:54 <Ke> length.(filter (==x))
03:38:48 <mjrosenb> erus`: compiled with or without optimization?
03:39:00 <erus`> without i guess
03:39:09 <mjrosenb> or optimisation if you're one of those crazy people :-p
03:39:50 <Jafet> Yeah, that's long.
03:40:21 <Jafet> My golf version didn't run in lambdabot's mueval until I added alpha-beta pruning.
03:41:15 <Jafet> > let xo s=let[p,q,l]=[sum[2^k|k<-j,s!!k==c]|c<-"XO|"];o= -1;j=[0..10];w p=any(ap(==)(p.&.))[7,112,273,292,546,1057,1092,1792];n=first(0-);i(n,-1)|n<0=":-("|n>0="-_-'"|True=":-|";i(_,q)=[head[c|(v,c)<-zip[p,q,l,2047]"XO|.",k.&.v/=0]|k<-(2^).j]++if w q then" :-)"else"";x a p b q|w p=(1,o)|w q=(o,o)|True=z[p+k|k<-(2^).j,all((==0).(k.&.))[p,q,l]]where z[]=(0,o);z r=foldr y a r;y p a|a<b=max a(-fst(x(n b)q(n a)p)/2,p)|True=a;in i$x(o,o)q(o,1)p in xo "X..|...|
03:41:16 <lambdabot>   <no location info>:
03:41:16 <lambdabot>      lexical error in string/character literal at end o...
03:41:54 <Jafet> Bah, IRC.
03:42:00 <erus`> first turn should have an advantage right?
03:42:25 <Jafet> Yes, but it's usually a draw.
03:43:22 <erus`> i have more loss nodes than wins or draw :/
03:43:28 <erus`> i think its the wrong way round
03:43:38 <Jafet> None of those are reached in optimal play
03:45:08 <frerich2> erus`: No, there is no built-in function. However, the 'filter' function can be used to get a list of all elements which are equal to your given element x, and then you can use 'length' on that to count them. So an "occurrences" function could be "occurrences x = length . filter (x ==)"
03:45:56 <k0ral> isn't there a way to gather several pattern matching in a single entry of a "case of" structure ?
03:46:19 <dobblego> k0ral: yes, using tuples, though depending on your data type, there may be a neater way than PMing
03:47:18 <k0ral> dobblego: oh sorry I didn't mean that actually, let me rephrase it
03:47:42 <Jafet> Sounds like he wants to group patterns to expressions
03:48:03 <Jafet> Which is currently impossible
03:48:14 <k0ral> I'd like to use something like an OR operator between several cases
03:48:41 <k0ral> "if it matches this OR that, then do..."
03:48:53 <k0ral> Jafet: impossible ?
03:49:03 <Jafet> Not possible.
03:49:25 <k0ral> I know what this means -_-', I'm just really surprised
03:50:04 <k0ral> so you would duplicate code in such case ?
03:50:27 <ClaudiusMaximus> > let f x y | x > 0 || y > 0 = x + y  | x < 0 || y < 0 = x * y  | otherwise = error "both zero" in f 1 2
03:50:28 <lambdabot>   3
03:51:32 <quicksilver> k0ral: you never need to duplicate code.
03:51:39 <quicksilver> k0ral: you just name the code and use the name.
03:51:52 <quicksilver> but it is, occasionally, annoying, and or patterns have been proposed as a language feature.
03:52:21 <adimit> is there a library function to chunk up a bytestring into chunks of n size?
03:52:38 <k0ral> quicksilver: are they going to be accepted ?
03:53:45 <quicksilver> k0ral: not unless someone writes the code.
03:54:53 <k0ral> and is anyone writing the code ?
03:55:08 <dobblego> dunno are you? :)
03:55:11 <quicksilver> no.
03:57:40 <k0ral> I'm far from being able to
04:12:02 <erus`> http://stackoverflow.com/questions/6342862/why-are-my-results-inversed
04:16:17 <roconnor> even with  157,662,344 bytes maximum residency my 512MB heap still gets exhausted.
04:16:28 <roconnor> I truly have no idea what these heap statistics mean.
04:18:22 <roconnor> 301 MB total memory in use
04:18:44 <roconnor> I don't understand.
04:18:48 <Entroacceptor> erus`: wikipedia verifies your results, but it's still inverted
04:19:09 <luite> erus`: probably because the lose games are longer, an odd number of moves
04:19:28 <luite> but I don't really agree with your definition of having an advantage
04:19:47 <erus`> yeah i dont mean that
04:21:14 <luite> hmm, but lose games are an even number of moves
04:21:31 <erus`> luite: why would it matter?
04:22:20 <luite> erus`: I think that the "problem" is somewhere near the leaves of the game tree
04:22:33 <adimit> roconnor: you will always use more memory than you have heap space, since the GC and stack pointers aren't factored into the heap statistics.
04:22:51 <adimit> maximum residency is always a bit, or even way above heap usage.
04:23:12 <adimit> My best guess about your running out of heap space is that maybe the stuff isn't getting GC'ed.
04:23:29 <adimit> how did you arrive at these numbers (i.e. which profiling options did you use?
04:24:20 <roconnor> -hT
04:24:23 <roconnor> +RTS -hT
04:24:25 <luite> erus`: but it's difficult to see whether these numbers have anything to do with having an actual advantage in a real game, since they're neither related to the win probability for the best move, nor a random move
04:24:36 <roconnor> adimit: I'm constantly running performGC as an experitment
04:25:46 <adimit> are you restricting the size of the heap to 512? In my experience, ghc will happily grow the heap as large as memory can hold unless it's restricted.
04:26:07 <luite> erus`: but what I'd do is keep track of counts of winning/losing positions at each depth in the game tree. then you can see whether game length has anything to do with it
04:26:09 <roconnor> adimit: the amount of memory resident is much lower with many many GCs, but it still runs out of heap at around the same place.
04:26:26 <roconnor> adimit: yes  +RTS -M512M
04:26:45 <roconnor> if I don't do that my kernel starts killing random processes and eventually my computer hangs
04:26:56 <roconnor> I think
04:27:02 <adimit> roconnor: try running it without that restriction. My suspicion is that suddenly heap usage explodes, and your program dies before the profiler can manage it.
04:27:18 <adimit> then decrease your input or problem size.
04:27:37 <adimit> and make a heap profile (+RTS -hc) — see if it spikes.
04:27:43 <roconnor> adimit: I've done that
04:27:46 <roconnor> there is no spike
04:27:53 <roconnor> just a gentle increase
04:28:06 <roconnor> I'm not running with unrestricted heap
04:28:12 <roconnor> I don't want my computer to hang
04:29:03 <adimit> I know the fear…
04:29:19 <adimit> that's indeed curious, lemme whip up the GHC manual…
04:30:11 <roconnor> there is nothing particularly unusual about the data being processed when the heap is exhausted
04:30:37 <roconnor> Maybe I am simply running out of heap; I'd be fine with that; but what gets me is that the profiling numbers just don't add up.
04:30:42 <adimit> roconnor: if you run/compile without profiling options, does the heap space still run out?
04:31:08 <roconnor> yes
04:31:31 <roconnor> I've run with and without profiling.  IIRC it always runs out of heap at around the same spot (maybe exactly the same) spot.
04:31:44 <adimit> have you tried +RTS -xt? It measures the stack, too.
04:31:55 <ClaudiusMaximus> maybe try -xc (iirc, prints stack trace on exception)
04:31:57 <roconnor> I haven't tired that
04:32:17 <Phyx-> http://www.everydaynodaysoff.com/wp-content/uploads/2011/06/U.S.-Nuclear-Chain-Of-Command-XKCD-Comic.png :P
04:32:37 <adimit> esp. if you're using some folds, or excessive recursion, the stack can become rather humongous.
04:32:54 <roconnor> my lists I fold on are usually pretty short
04:33:26 <quicksilver> adimit: recursion does not use the stack in GHC>
04:34:35 <adimit> quicksilver: oy, didn't know that. Forgot how exactly I got the stack to blow… I think it was with lazy folds.
04:34:45 * roconnor runs ./Main +RTS -M512M -xt -hc
04:34:52 <scree> in any case, isn't the stack limit usually massively smaller than the heap limit?
04:34:54 * roconnor runs ./Main +RTS -M512M -xt -hc -S
04:35:10 <quicksilver> adimit: the stack gets used by entering thunks
04:35:17 <quicksilver> adimit: so deeply nested thunks will case stack overflows
04:35:29 <adimit> quicksilver: I stand corrected, thanks :-)
04:35:33 <quicksilver> (of course, the obvious way to create deeply nested thunks is recursion...)
04:35:51 <adimit> (which is why I blamed recursion… foolishly.)
04:36:45 <blackdog> is running "cabal configure --executable-profiling" meant to be enough to include profiling code? When I try to run the resulting binary with +RTS -prof, it tells me to link with -rtsopts
04:36:50 <scree> unless roconnor is using some other RTS options to increase the stack limit massively, I can't see that being the problem
04:37:00 <ezyang> blackdog: You need rtsopts too.
04:37:15 <ezyang> Otherwise, you can't tell the executable to run in profiling mode (even though it was compiled that way.)
04:37:16 <roconnor> I put a bounty on a stack overflow question that is similar to mine: http://stackoverflow.com/questions/5306717/how-should-i-interpret-the-output-of-the-ghc-heap-profiler
04:37:29 <ezyang> Well, you could gdb it, twiddle the appropriate flag, and then let it run.
04:37:46 <roconnor> I am observing the same thing. the graph of heap usage is 1 tenth the size of the heap when the heap gets exhausted.
04:37:49 <blackdog> ezyang: how do you include that in cabal options?
04:39:53 <adimit> roconnor: having the code and a minimal example might help. I could run the thing on my 32Gig server and see when it terminates, and what happens along the way.
04:40:48 <roconnor> that would take some work to make
04:45:30 <scree> roconnor: can I just clarify: do you mean you get an out of memory error with a 512M limit, when the OS thinks you are only using 300M, and the heap profile thinks you are using about 100M?
04:46:04 <roconnor> scree: the 300M also came from the heap profile (+RTS -S)
04:46:22 <scree> roconnor: oh ok.  How much does the OS think you are using?
04:46:25 <roconnor> I didn't check that
04:46:36 <roconnor> I expect it to be about 300.
04:46:51 <roconnor> not sure
05:25:56 <hpaste> tm1rbrt pasted “tictactoe” at http://hpaste.org/47784
05:33:56 <erus`> if anyone can tell me why thats reporting the wins for O's rather than X's i would be very gratefull
05:34:04 <erus`> i cant see an error in my logic
05:35:00 <Entroacceptor> maybe you're inverting a bit too early
05:42:50 <erus`> oh shit i know
05:46:37 <erus`> no i dont
05:47:10 <dixie> > 6*32
05:47:11 <lambdabot>   192
05:47:38 <dixie> > 72/32
05:47:39 <lambdabot>   2.25
05:47:55 <dixie> > 6*4
05:47:56 <lambdabot>   24
05:48:14 <dixie> > 72/4
05:48:15 <lambdabot>   18.0
05:54:31 <GraninAS> putStrLn "Hi there!"
05:55:14 <scree> erus`: so, here's the problem
05:55:25 <scree> erus`: think about what your logic does on a 1x1 board
05:56:05 <scree> erus`: you start with inv=False and a blank board; then you invert the board, place an X and iterate with the new board and inv=True
05:56:24 <scree> erus`: at this point you judge that X has won, but because inv=True you switch that to O has won
05:56:31 <scree> erus`: when actually, X won
05:57:14 <erus`> yeah
05:58:53 <erus`> i need to either walk the tree for each of X's first moves
05:59:01 <erus`> or a special wrapper
05:59:47 <scree> erus`: I don't think you need to do either
06:00:09 <scree> erus`: flipping the if inv then ... else ... should give you correct code
06:01:00 <scree> erus`: I think you've just mistaken inv to mean "O is just about to move" for "O just moved"
06:01:39 <scree> erus`: there are also 101 style points to make, but I'll spare you them if you'd rather
06:01:55 * zygoloid suggests: data Result = Win Piece | Draw
06:02:12 <zygoloid> and get rid of the result inversion entirely
06:02:38 <erus`> scree formatting advice is well recieved
06:02:55 <zygoloid> erus`: start with all the things which hlint suggested (at the bottom of the paste)
06:03:36 <dcoutts> blackdog: the -rtsopts is a pita
06:04:26 <scree> erus`: so, I was mainly thinking: (1) allPossibleMoves is inefficient as it uses ++ [x] and foldl; either use (:) and foldr or just "mapMaybe"
06:04:47 <hpc> :t mapMaybe
06:04:48 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
06:05:14 <erus`> scree: if i call walkpaths with a board like "   XXX   "
06:05:18 <erus`> if i change inv
06:05:24 <erus`> if inv ... etc
06:05:55 <erus`> then that will return a win for O
06:08:50 <scree> erus`: so, you're probably right that a better fix is to change "walkPaths False ..." to "walkPaths True ..."
06:09:01 <scree> erus`: they are semantically equivalent
06:12:01 <scree> erus`: hmm, I've reconsidered that.
06:13:25 <erus`> go on... ?
06:13:26 <scree> erus`: invertBoard $ allPossibleBoards b is what you want I think
06:14:15 <scree> erus`: with inv how it was
06:14:48 <erus`> else concat $ map (walkPaths (not inv)) (map invertBoard $ allPossibleMoves b) ??
06:14:55 <scree> erus`: think so
06:14:59 <scree> erus`: with inv back the way it was
06:15:04 <erus`> ok
06:16:21 <scree> erus`: what I was going to say a moment back: "invert{Board,Result}" reimplement the Functor instance of Maybe.  Consider using fmap.
06:16:46 <erus`> ok
06:18:01 <scree> erus`: and finally, "if result /= Nothing then [fromJust result]: fromJust is bad; consider a case statement, or the "maybe" function
06:18:04 <scree> :t maybe
06:18:05 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
06:18:34 * scree is a bit concerned that he's turning into a human version of hlint
06:20:59 <erus`> i wish simon peyton jones would do a 60 min video explaining what a monad is
06:21:04 <erus`> hes great at speaking
06:22:24 <joe6> any suggestions for a good quickcheck tutorial? I checked out the links from google, but just curious if there was something better?..
06:24:20 <joe6> the RWH talks about Test.QuickCheck.Batch, but it does not seem to exist anymore. Is it deprecated?
06:24:30 <joe6> What is the alternative?
06:29:06 <dino-> joe6: I see, that Batch seems to be gone in the 2.x version of the API.
06:30:32 <dino-> joe6: Maybe this? http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck
06:30:41 <dino-> (you probably have already seen)
06:31:08 <dino-> We need a RWH 2nd edition already!
06:31:19 <joe6> @hoogle printTestCase
06:31:19 <lambdabot> No results found
06:31:50 <joe6> btw, any simple example of the usage of printTestCase, please?
06:32:19 <joe6> I want to add in more detail than the standard "+++ OK, passed 100 tests.", such as the name of the function tested.
06:32:33 <joe6> > : printTestCase
06:32:33 <lambdabot>   <no location info>: parse error on input `:'
06:32:37 <joe6> > :t printTestCase
06:32:38 <lambdabot>   <no location info>: parse error on input `:'
06:33:08 <joe6> something similar to the label of the Test.Hunit?
06:33:29 <dino-> hm, just found this: http://www.techques.com/question/1-4772902/How-to-display-a-reason-of-a-failed-test-property-with-quickcheck
06:33:49 <dino-> joe6: ^
06:35:06 <roconnor> scree: so I've just run with heap profiling on.  I get:
06:35:12 <joe6> this does not work: deepCheck p = check (defaultConfig { configMaxTest = 10000}) p, in ghci. I got it from uri: http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck
06:35:15 <roconnor> 146,310,708 bytes maximum residency (8688 sample(s))
06:35:23 <roconnor> 118,373,420 bytes maximum slop
06:35:37 <joe6> dino, cool, thanks.
06:35:51 <roconnor> 310 MB total memory in use (3 MB lost due to fragmentation) -- this is close to, maybe somewhat less than what htop was reporting before death.
06:37:18 <roconnor> scree: and finally the heap chart produced by hp2ps only goes upto 40M
06:37:25 <roconnor> so basically, .... WTF?
06:38:05 <MaskRay> provided  >>>data Set a = Tip | Bin !Size a !(Set a) !(Set a)<<<, what does the `Bin {}' in `case t of {Bin {} -> False}' mean?
06:38:29 <roconnor> I don't know where my stack use is suppoed to be
06:38:41 <benmachine> MaskRay: do you know about record syntax?
06:38:41 <roconnor> I did +RTS M512M -xt -hc -S
06:39:31 <dmwit> MaskRay: It matches the Bin constructor without binding any of Bin's fields.
06:39:37 <dmwit> MaskRay: It's a Stupid Haskell Trick (tm).
06:39:51 <mm_freak_> SHIT
06:39:51 <mm_freak_> i have sent a mail to -beginners, which really doesn't belong there
06:39:51 <mm_freak_> can anybody please delete it quickly?
06:40:08 <benmachine> I don't think that's how mailing lists work :P
06:40:11 <dmwit> It's a mailing list...
06:40:16 <dmwit> You can't unsend an email.
06:40:17 <MaskRay> dmwit: It seems to be the same to Bin _ _ _
06:40:31 <mm_freak_> yes…  but it could at least be removed from the archives
06:40:35 <dmwit> MaskRay: Correct, except that "Bin {}" won't break if the Bin constructor later takes a different number of arguments.
06:40:53 <roconnor> oh I guess -xt just includes the stacks space in the numbers reported
06:41:05 <roconnor> anyhow, the numbers in the heap profile just don't add up
06:41:56 <MaskRay> benmachine: something like `data Foo = Foo { bar1 :: Int, bar2 :: Int }'?
06:42:38 <benmachine> MaskRay: yes. with record syntax you can pattern-match by e.g. doing case t of Foo { bar1 = 0 } -> whatever
06:42:58 <adnam> oh, didn't know that
06:43:08 <benmachine> MaskRay: you can also match against just the constructor and no records in the obvious way - case t of Foo {} -> whatever
06:43:23 <benmachine> MaskRay: since this last method doesn't use any of the record fields, it actually works even on non-records
06:43:39 <benmachine> and hence, everything that dmwit said
06:45:22 <MaskRay> benmachine: Can I consider record syntax as some syntactic sugar for ADT? Are they identical essentially?
06:45:51 <benmachine> MaskRay: there are some subtle differences, but in principle they are the same yes
06:46:36 <benmachine> (subtle differences like, which order the fields are matched in, which I believe GHC got wrong until recently)
06:47:33 <bmm> Does anybody on the channel know of a code using twitter streaming API with hs-twitter? I'm trying to get it to work using Curl, but Curl can't handle UTF-8 correctly it seems.
06:50:48 <amindfv> MaskRay: ADT meaning algebraic datatype? RWH stays away from that acronym (namespace issues), so I'm not sure what you mean
06:54:47 <MaskRay> amindfv: I don't know the terminology. I mean something like `data Foo = Foo bar1 bar2'
06:56:26 <dafis> MaskRay: yup, that's an algebraic data type
06:57:09 <amindfv> MaskRay: I mean, were you asking if Record syntax (data Foo = Foo bar1) is an algebraic datatype?
06:57:50 <amindfv> MaskRay: I just didn't know what you meant by ADT - it could also be Abstract Data Type or something
06:58:06 <amindfv> bus, given context, I guess I know the answer
06:58:10 <amindfv> :)
06:58:19 <MaskRay> amindfv: `data Foo = Foo Bar1 Bar2 ' and `data Foo = Foo {bar1 :: Bar1, bar2 :: Bar2}' are identical, aren't they?
06:58:32 <ManateeLazyCat> Hi all. :)
06:58:41 <quicksilver> except the latter makes pattern matching and field update possible
06:58:46 <byorgey> hi ManateeLazyCat =)
06:58:52 <quicksilver> it is only a syntactical convenience, though.
06:58:56 <isomorphic> Hi ManateeLazyCat
06:59:05 <luite> hi ManateeLazyCat
06:59:06 <ManateeLazyCat> byorgey: Hey. :)
07:00:01 <Entroacceptor> hi ManateeLazyCat
07:00:10 <MaskRay> amindfv: Disregarding some minor differences: the latter also create some functions that lookup fields in the data type
07:00:20 <amindfv> MaskRay: yes
07:01:46 <MaskRay> amindfv: So I can reference it as `Foo {}' even if Foo's definition is the former: Data Foo = Foo Bar1 Bar2
07:02:28 <ManateeLazyCat> Entroacceptor: Hey, how are you recently?
07:04:12 <Entroacceptor> more chatting about coding than starring at an editor :)
07:04:28 <ManateeLazyCat> Entroacceptor: :p
07:04:55 <eddayyy> how do you C-c C-l and import modules you're currently working on in haskell inferior mode emacs?
07:05:06 <eddayyy> keeps giving me Cannot find module ...
07:05:48 <MaskRay> eddayyy: :m + Data.Map
07:06:16 <benmachine> MaskRay: that imports library modules, I assumed he meant ones you were writing
07:06:35 <benmachine> (well, that's what it does in ghci anyway, I don't actually use emacs(]
07:06:38 <benmachine> *)
07:07:10 <eddayyy> benmachine: thats what i'm trying to do yeah
07:07:24 <eddayyy> MaskRay: i'm trying to import modules that i'm writing into other modules that i'm writing, not Data.Map etc
07:07:26 <MaskRay> emacs inferior-haskell-mode forks a ghci process
07:07:46 <benmachine> in ghci you can use :l to load source files
07:07:53 <MaskRay> s/forks/spawns/
07:08:35 <eddayyy> benmachine: it doesn't work even when i use :l
07:09:03 <benmachine> eddayyy: hm. does the output of :!pwd look sensible
07:09:41 <eddayyy> benmachine: yep
07:09:49 <benmachine> eddayyy: what was the error exactly?
07:10:19 <eddayyy> benmachine: I load the first module, it compiles fine. Then I load second module which imports the first module, and it fails with "Could not find module (name of first module)"
07:10:40 <benmachine> eddayyy: do the filenames match up with the module names?
07:10:59 <joe6> any suggestions on how I can use quickcheck with this code: http://pastebin.com/5gyAuKnd
07:11:01 <mauke> I have copied your paste 5gyAuKnd to http://hpaste.org/new - pray I don't copy it any further.
07:11:03 <eddayyy> benmachine: yep
07:11:16 <benmachine> eddayyy: you could try :set -v to see a list of filenames tried
07:11:34 <joe6> i cannot understand using quickcheck with monadic functions? Can anyone please help?
07:11:38 <mauke> argh
07:11:41 <benmachine> mauke: what on earth is that
07:11:59 <joe6> this is the error I get:  http://sprunge.us/eIij
07:11:59 <benmachine> oh, you're trying to pick up pastebins and hpaste them instead?
07:12:23 <benmachine> joe6: try mapM_
07:12:27 <joe6> mauke, is there something like pastebinit for hpaste? I would love to use it.
07:12:45 <simonwu> /?
07:12:56 <benmachine> joe6: well, the first error ought to be fixed by a mapM_, the second might need a =<<
07:13:11 <eddayyy> benmachine: theres an extra "src" directory that might be confusing things
07:13:12 <benmachine> the third one I suspect needs some parentheses
07:13:15 <mauke> joe6: I don't know what that is
07:13:26 <joe6> benmachine: better,  http://sprunge.us/bAUG
07:13:28 <benmachine> eddayyy: hm?
07:14:08 <benmachine> joe6: return (actualu,actualh,actuall) == (u,h,l) doesn't do what you think
07:14:19 <benmachine> joe6: function application is hungrier than any operator
07:14:33 <benmachine> joe6: so that parses as (return ...) == (u,h,l)
07:14:36 <joe6> benmachine: i am trying to get the quickcheck framework setup
07:14:57 <benmachine> joe6: yes yes I know, this is just a silly thing about precedence though
07:15:02 <joe6> and then go about adding more actual functions there
07:15:11 <benmachine> joe6: you want return (... == (u,h,l))
07:15:17 <joe6> ok, cool. will put a $ there.
07:15:17 <benmachine> note extra parentheses
07:15:22 <benmachine> or $ will also work yes
07:15:23 <eddayyy> benmachine: that worked, i just changed directories to within src :) thanks
07:15:31 <eddayyy> benmachine: how do i turn off -v mode
07:15:40 <benmachine> eddayyy: eerm, good question
07:15:45 <joe6> benmachine: down to one error:  http://sprunge.us/gDGO
07:15:50 <benmachine> ghci> :unset -v
07:15:50 <benmachine> don't know how to reverse -v
07:15:52 <benmachine> eep.
07:15:55 <erus`> how can i sort by X then Y, like sort by surname and then firstname?
07:16:12 <benmachine> eddayyy: :set -v0 seems to work
07:16:27 <benmachine> erus`: there are a few clever ways
07:16:53 <benmachine> erus`: import Data.Monoid and use sortBy (comparing lastName `mappend` comparing firstName)
07:16:56 <isomorphic> can anybody explain why ghci doesn't allow us to make new data statements?
07:16:56 <benmachine> I think
07:18:10 <benmachine> joe6: okay, what do you think this error means
07:19:14 <xplat> isomorphic: ghci basically parses things the way they are parsed inside a do block.  anything that can't normally be done inside a do block requires special code to be written.  you can't write a data declaration inside a do block.
07:19:57 <quicksilver> I don't think that's the right explanation to be honest.
07:20:03 <bmm> How do I find the index first the occurance of a substring? (don't tell me I have to copy and paste one of the 100 implementations people posted on the internet)
07:20:13 <snod_> Hey guys
07:20:18 <xplat> the best way to work with user-defined types in ghci is to use :load or the emacs haskell-mode
07:20:33 <benmachine> xplat: ghci *does* allow full import statements though
07:20:41 <xplat> quicksilver: it's not the whole explanation, but it's right as far as it goes
07:20:45 <quicksilver> it doesn't support 'data' declarations because the feature doesn't support declarations.
07:20:50 <xplat> benmachine: only as of ghc7
07:20:53 <isomorphic> ah - how does emacs haskell mode escape the limitation?
07:20:58 <quicksilver> xplat: I just don't htink it gives a good answer to 'why'
07:21:04 <benmachine> xplat: well, that *is* the current version :P
07:21:13 <quicksilver> I don't think the answer is 'because ghci is do blocks'
07:21:19 <xplat> benmachine: and it required a lot of special code to be written
07:21:22 <benmachine> quicksilver: mm, I imagine the 'why' is because an expression context is more often useful than a declaration context
07:21:24 <quicksilver> the answer is more like 'because ghci is an evaluator - it doesn't do declarations'
07:21:35 <quicksilver> benmachine: it's just amissing feature.
07:21:38 <benmachine> xplat: nevertheless, that code has indeed been written
07:21:44 <quicksilver> almost all other REPLs support declarations.
07:21:45 <mauke> preflex: msg #haskell test http://pastebin.com/5gyAuKnd
07:21:46 <preflex> test http://pastebin.com/5gyAuKnd
07:21:47 <joe6> benmachine, I need to add a Testable instance to IO Bool?  http://sprunge.us/SNRM
07:21:48 <mauke> The paste 5gyAuKnd has been copied to http://hpaste.org/47792
07:21:49 <benmachine> quicksilver: true
07:21:59 <quicksilver> ghci is a poor relation in this regard
07:22:09 <xplat> isomorphic: it lets you write stuff in a buffer and load it automatically, so it basically uses the same :load mechanism, it's just a little easier
07:22:10 <joe6> i was wondering if there might be a snippet that does that already..
07:22:31 <benmachine> joe6: I don't think so, you probably just want to apply the function to Bool instead of IO Bool
07:22:32 <mauke> preflex: seen chrisdone
07:22:32 <preflex>  chrisdone was last seen on #haskell 17 hours, 4 minutes and 26 seconds ago, saying: Yeah. I either use list functions with Data.Char or full Parsec, pretty much.
07:22:55 <isomorphic> xplat: ah gotcha, thanks :) I was thinking about what REPLs might be available / suitable.
07:23:13 <benmachine> joe6: printTestCase wants to be given a property but you're giving it an IO Bool instead
07:23:16 <mauke> turns out "email" is a required field but must be sent empty
07:23:17 <joe6> benmachine: I want to test an IO function. I have not filled in the IO details yet, as I want the basic quickcheck framework running.
07:23:20 <isomorphic> xplat: in vim that is
07:23:37 <xplat> quicksilver: the majority of repls are for languages that don't even HAVE any real distinction between declarations and expressions
07:23:53 <benmachine> joe6: hmm. I'm not sure how well-suited QC is to testing IO
07:24:02 <xplat> for the ones that do, there are often limitations
07:24:09 <joe6> benmachine, this works: quickCheck . printTestCase "testing xxxxxx" $ ((\s -> s == s) :: [Char] -> Bool)
07:24:10 <benmachine> joe6: nevertheless you can fix this so it typechecks
07:24:27 <benmachine> joe6: sure, [Char] -> Bool is testable, but IO Bool isn't
07:24:28 <quicksilver> xplat: well, the MLs manage it.
07:24:29 <xplat> scala's REPL is pretty nice in that regard, but there are still some annoying differences
07:24:38 <joe6> and I am trying to get it to work with IO Bool. I want to use quickcheck to generate the different inputs
07:24:46 <quicksilver> xplat: and so did augustss's haskell interpreter
07:24:48 <joe6> so, I do not miss much.
07:25:16 <joe6> benmachine, can I do something to make IO Bool testable?
07:25:19 <benmachine> joe6: hmm. you might want to try Test.QuickCheck.Property.morallyDubiousIOProperty
07:25:33 * benmachine is reading http://hackage.haskell.org/packages/archive/QuickCheck/2.4.0.1/doc/html/Test-QuickCheck-Property.html#t:Property
07:25:57 <isomorphic> joe6: I had a similar problem - check out test-framework-hunit
07:26:31 <joe6> isomorphic: i have used hunit, but find quickcheck attractive, as it can generate the test data.
07:26:41 <joe6> can hunit generate test data, too?
07:26:57 <isomorphic> joe6: okay, check out test-framework-quickcheck2 ;)
07:26:57 <joe6> benmachine: that seems to be it. Thanks
07:27:26 <isomorphic> joe6: iirc, test-framework-quickcheck is not good if you've got IO
07:27:28 <joe6> isomorphic: is that different from quickcheck? on haskellWiki?
07:27:47 <isomorphic> joe6: but you can do what you want with the hunit one
07:27:49 <joe6> isomorphic: what is the package name?
07:28:03 <isomorphic> joe6: cabal install test-framework-hunit
07:28:08 <joe6> how do I get hunit to generate testdata?
07:28:27 <isomorphic> You don't - but this at least gets around your IO problem :P
07:28:40 <joe6> oh, ok..
07:28:42 <isomorphic> You might be able to do something with test-framework-quickcheck2
07:28:57 <sam9> Hi I had a question about Haskell
07:28:58 <joe6> is it cabal install test-framework-quickcheck2?
07:29:08 <sam9> what does the word go do?
07:29:18 <sam9> I have a code here that I'm tring to interpret
07:29:28 <benmachine> sam9: 'go' isn't special
07:29:34 <nlogax> it is not a keyword, sam9, but a common function name
07:29:37 <isomorphic> joe6: Yes
07:29:53 <benmachine> but often haskellers use it to refer to a recursive loop internal to a function they're writing
07:30:06 <joe6> isomorphic: ok, thanks. just installed it. will check it out.
07:30:13 <benmachine> joe6: it's much easier to test non-IO stuff than IO stuff in general
07:30:16 <sam9> hm... let me take a look at the code again
07:30:29 <benmachine> joe6: if you can separate the IO out from your test it will be more reproducible
07:30:46 <sam9> oh... right
07:30:47 <negaduck> what is >>? operator called? how to find it in google?
07:30:48 <sam9> sorry about that...
07:30:55 <sam9> I'm new to haskell
07:31:02 <sam9> and trying to write line by line in command prompt...
07:31:15 <sam9> but I keep getting stuck in go
07:31:18 <parcs> > [5..1]
07:31:19 <lambdabot>   []
07:31:20 <sam9> but go was defined in the bottom
07:31:49 <mauke> sam9: don't write line by line in command prompt
07:31:52 <isomorphic> joe6: You should be able to make a list of tests that are testCase s (hunit) and testPropertie s (quickcheck2) - you execute them using defaultMain
07:31:53 <benmachine> negaduck: google is bad at finding operators, you should try hoogle instead: http://www.haskell.org/hoogle/?hoogle=>>
07:31:58 <snod_> sam9: Hey Haskell is not really meant for writing programs. We like to write cool one liners in GHCI
07:32:06 <snod_> oh no
07:32:08 <snod_> he went away
07:32:09 <zygoloid> @hoogle (>>?)
07:32:09 <lambdabot> No results found
07:32:16 <joe6> isomorphic: the test-framework is pretty cool. thanks.
07:32:22 <zygoloid> negaduck: i've never heard of a >>? operator. did you mean >>
07:32:34 <snod_> hey btw
07:32:45 <negaduck> benmachine: thanks
07:32:47 <isomorphic> joe6: I call it from cabal - so you can instrument cabal test
07:32:59 <joe6> oh, ok.
07:33:08 <snod_> Is ghc using a recursive descent parser?
07:33:14 <isomorphic> joe6: But be cautious of the output - it seems to log the output and present it over and over -- at least it did for me :/
07:33:19 <snod_> I never digged in it
07:33:25 <joe6> benmachine: i am using haskell to test code in a simulator. so, I am stuck with IO
07:33:32 <erus`> can someone give me an example of sorting a list of tuples by 2 conditions please :)
07:34:03 <mauke> erus`: sortBy whatever
07:34:17 <erus`> it says whatever is not in scope
07:34:29 <mauke> you have to write it first
07:34:33 <negaduck> zygoloid: that's very convinient thing, you should try it
07:34:38 <benmachine> :t sortBy (\(x,y) -> comparing y `mappend` comparing x)
07:34:38 <erus`> 'it' is not in scope
07:34:38 <lambdabot>     Occurs check: cannot construct the infinite type:
07:34:39 <lambdabot>       b = (b -> a1, b -> a)
07:34:39 <lambdabot>       Expected type: (b -> a1, b -> a)
07:34:46 <benmachine> oh
07:34:47 <benmachine> I silly
07:35:03 <zygoloid> negaduck: i don't understand what you mean, sorry.
07:35:06 <benmachine> :t sortBy (comparing snd `mappend` comparing fst)
07:35:07 <lambdabot> forall a b. (Ord b, Ord a) => [(a, b)] -> [(a, b)]
07:35:11 <mauke> :t sortBy (comparing snd ++ comparing fst)
07:35:12 <lambdabot> forall a b. (Ord b, Ord a) => [(a, b)] -> [(a, b)]
07:35:12 <byorgey> :t sortBy (comparing fst `mappend` comparing (uncurry (+)))
07:35:13 <lambdabot> forall a. (Ord a, Num a) => [(a, a)] -> [(a, a)]
07:35:28 <benmachine> byorgey wins
07:35:30 <isomorphic> erus`: Depending on what you're doing, you might want to make your tuple an instance of Ord
07:35:40 <benmachine> isomorphic: tuples are already Ord
07:35:55 <Nimatek> Yesterday a person pointed out happstack's memory use after load testig it with 'siege'. I was wondering if someone here knows about the issue.
07:36:20 <Nimatek> Because it does use inappropriate amounts of memory without freeing it.
07:36:45 <zygoloid> @type sortBy (comparing (fst &&& uncurry (+)))
07:36:46 <lambdabot> forall b. (Num b, Ord b) => [(b, b)] -> [(b, b)]
07:37:13 * hackagebot regex-genex 0.3.1 - From a regex, generate all possible strings it can match  http://hackage.haskell.org/package/regex-genex-0.3.1 (AudreyTang)
07:37:23 <zygoloid> @type sortOn (fst &&& uncurry (+)))
07:37:24 <lambdabot> parse error on input `)'
07:37:27 <zygoloid> @type sortOn (fst &&& uncurry (+))
07:37:27 <lambdabot> forall b. (Num b, Ord b) => [(b, b)] -> [(b, b)]
07:38:32 <negaduck> hoogle can't find >>? operator
07:38:33 <negaduck> pity
07:38:34 <joe6> any suggestions on how to get this correct:  http://sprunge.us/jKVE
07:38:42 <benmachine> negaduck: where did you see it?
07:39:04 <joe6> > :t quickCheck . printTestCase "testing xxxxxx" . morallyDubiousIOProperty  $ ((\s -> return True) :: [Char] -> IO Bool)
07:39:05 <lambdabot>   <no location info>: parse error on input `:'
07:39:18 <negaduck> benmachine: in real world haskell
07:39:30 <benmachine> negaduck: specifically?
07:39:32 <negaduck> oh. It's a custom func. Sorry
07:39:36 <benmachine> mm
07:39:39 <isomorphic> benmachine: oh - doesn't that mean that 'sort x' sorts by two conditions?
07:39:39 <negaduck> p.238
07:39:58 <benmachine> isomorphic: I... guess so?
07:40:15 <isomorphic> ie:
07:40:38 <isomorphic> > ( 1, 2 ) > (2, 1)
07:40:38 <lambdabot>   False
07:40:53 <zygoloid> Ord on tuples (and all built-in and derived cases) is lexicographic
07:40:53 <benmachine> > (2,1) > (1,2)
07:40:54 <lambdabot>   True
07:41:29 <isomorphic> zygoloid: So, it sorts on two conditions if it is a two-tuple
07:41:31 <isomorphic> ?
07:42:00 <zygoloid> isomorphic: it sorts lexicographically. that is, first by the fst, then by the snd (within groups where the fst is equal)
07:42:40 <isomorphic> Cool, two conditions.
07:42:48 <benmachine> :t mconcat [comparing fst, comparing snd]
07:42:49 <lambdabot> forall a b. (Ord a, Ord b) => (a, b) -> (a, b) -> Ordering
07:44:13 <isomorphic> benmachine: I hadn't realised a tuple was Ord - i thought you'd have to define something like (what it actually is)
07:44:14 <hpaste> noob pasted “Eat memory??” at http://hpaste.org/47794
07:45:09 <isomorphic> ^-- surely that should be titled "I can haz memory'
07:45:16 <bmm> Why does this code seem to eat memory: http://hpaste.org/47794 I just wanted it to buffer lines and adding the "let newBufferValue" just above the if seems to make it eat memory.
07:46:46 <bmm> Ooh, I should have posted as bmm instead of noob :) But I think this is an obvious new-to-haskell-don't-understand-lazy-thing
07:47:47 <Saizan> could anyone with ghc < 7 test this code for me? http://hpaste.org/47795
07:49:23 <hpaste> bmm pasted “runhaskell 6.12.1 output” at http://hpaste.org/47796
07:49:43 <bmm> Saizan: done, see http://hpaste.org/47796
07:50:39 <Saizan> bmm: ghc version?
07:50:46 <roconnor> okay things are finally starting to make sense.  GHC's heap needs to be 3x the live data size unless you do something like +RTS -c
07:50:47 <Saizan> ah, 6.12.1 thanks
07:50:57 <roconnor> in which case twice the live data size will work
07:50:58 <byorgey> 6.12.3 gives the same output
07:51:12 <roconnor> +RTS -M512M -c runs a lot longer for me than withouth -c
07:51:57 <roconnor> still, it is mysterious why the heap profile chart is smaller than the live data.
07:52:48 <isomorphic> bmm: Does appending the newInput to the end of bufferValue cause bufferValue to be completely read in
07:53:24 <isomorphic> ie: it looks like it would only need to read to the '\n' if that if tested against bufferValue
07:55:42 <bmm> isomorphic: aaaaah, found it. it's the case where bufferedLines  is a single element list!
07:56:41 <bmm> isomorphic: I'll have to do more testing. Thanks for looking at it!
07:57:13 <isomorphic> bmm: Sorry I wasn't more help :/  But glad you sorted it out! :)
07:57:46 <bmm> isomorphic: was a hard one to find, I never figured that lines "hello\n" would result in a single element list ["hello"]
07:59:28 <erus`> how do i make a function to get element 2 from a 3 element tuple
07:59:46 <Nimatek> erus`: f (a,b,c) = b
07:59:48 <monochrom> f (x,y,z) = (x,z)
08:01:45 <apfelmus_> I'm trying Chris Done's TryHaskell
08:01:47 <apfelmus_> http://chrisdone.com/posts/2010-04-05-haskell-json-service-tryhaskell.html
08:02:02 <apfelmus_> With exceptionally weird results, though.
08:02:05 <byorgey> trytryhaskell?
08:02:30 <apfelmus_> Entering 1+5 gives 5 as result
08:02:32 <monochrom> haha
08:02:54 <apfelmus_> The expression 5 evaluates to 2.
08:03:12 <apfelmus_> The expression 1 evaluates to 6.
08:03:12 <osfameron> I'm getting 6 and 5 as expected
08:03:12 <benmachine> worjsforme
08:03:18 <benmachine> *k
08:03:30 <osfameron> or I *was*
08:03:33 <osfameron> now it's just stuck on 5
08:03:41 <apfelmus_> haha :)
08:04:01 <osfameron> oh, that's just because the box doesn't trap <Return>
08:04:02 <byorgey> apfelmus_: It's randomly permuting the correct answers through time.
08:04:19 <byorgey> apfelmus_: so if you get a result of 17 that *will* be the correct answer to some *future* query that you will make
08:04:22 <byorgey> and so on
08:04:53 <apfelmus_> byorgey: Sure, but how do I distinguish that from an infinite group of monkeys typing on infinitely many keyboards at once?
08:04:57 <isomorphic> byorgey: It's all making sense now.  The IO Monad really does have a lot of state wrapped up
08:05:35 <magicman> You'll know when you see it quote Hamlet.
08:05:39 <quicksilver> apfelmus_: tryhaskell will  never produce the complete works of shakespeare.
08:05:41 <byorgey> apfelmus_: monkeys would be more likely to type integers that are much larger than the average results of your test expressions
08:06:16 <monochrom> it can get stuck on previous answers if there is a recent error. keep trying
08:06:23 <apfelmus_> Ah. These are two very good arguments.
08:06:39 <monochrom> then again, it is a bug, nothing should get stuck
08:06:58 <quicksilver> we could put those monkeys to better use
08:07:10 <quicksilver> they could throw peanuts at chrisdone whenever tryhaskell has a bug
08:07:28 <monochrom> please don't harm chrisdone!
08:07:36 <apfelmus_> monochrom: Ah, reloading the page did a lot of good.
08:08:07 <monochrom> "reload yourself a web page for great good"
08:08:16 <monochrom> err, s/self//
08:08:22 <monochrom> err, s/your/you/
08:08:39 <apfelmus_> How does the Haskell loading box work?
08:08:55 <quicksilver> javascript ajax to serverside haskell
08:08:56 <apfelmus_> It says "OK" but the variable is still not in scope.
08:09:04 <quicksilver> ah, wrong level of abstraction :)
08:09:08 <monochrom> I don't know. I have "f = 1\nmain = print f" and all it does is "OK"
08:09:24 <monochrom> then I have "main = print" and it is still "OK"
08:09:41 <monochrom> and right, it doesn't affect the evaluation box
08:09:53 <monochrom> I should try to cause a type error
08:10:29 <isomorphic> type errors are dramatic
08:10:30 <monochrom> "f = f f" causes a popup with the type error
08:10:49 <apfelmus_> Ok, so it's doing something, at least.
08:10:53 <monochrom> with a lot of "\n"s
08:12:01 <apfelmus_> monochrom: The error message includes a unique file name.
08:12:30 <apfelmus_> It looks like the reason for this not working is that it doesn't know which loaded file to consult again.
08:14:53 <aBrickOntheWall> given the definition newtype Writer w a = Writer{ runWriter:: (a, w)}
08:14:55 <aBrickOntheWall> instance (Monoid w) => Monad (Writer w) where
08:14:57 <aBrickOntheWall>     (Writer (x,v)) >>= f = let (Writer (y, v')) = f x in Writer (y, v `mappend` v')
08:14:59 <aBrickOntheWall> I am trying to figure out what the value of y and v' are?
08:16:04 <monochrom> they depend on f x
08:16:23 <aBrickOntheWall> ok... is y=fx?
08:16:40 <monochrom> no, Writer (y, v') is f x
08:18:51 <apfelmus_> Huh, weird.
08:18:52 <apfelmus_> http://tryhaskell.org/haskell.json?method=eval&expr=x&guid=apfelmus
08:19:11 <apfelmus_> On Safari, this evaluates to 1 for me. On Chrome, however, it gives an "x not in scope" error
08:19:32 <aBrickOntheWall> ok..let me try and work that out
08:20:43 <monochrom> if you restart safari and use the same url again, what happens?
08:21:10 <apfelmus_> monochrom: Now it's not in scope.
08:21:27 <monochrom> then it is browser session, which points towards cookies
08:22:00 <erus`> it took all day but i made perfect tictactoe ai :D
08:22:27 <apfelmus_> monochrom: Yeah. I didn't find any cookies for tryhaskell.org, though, but I should keep looking.
08:22:35 <coastrz> coastrz
08:23:46 <apfelmus_> monochrom: It was cookies. Awesome, thanks a lot!
08:24:32 <monochrom> ♥ cookies
08:24:49 <monochrom> @vixen do you love cookies?
08:24:50 <lambdabot> love is a powerful word...
08:25:09 <monochrom> @vixen cookies are powerful words too, no?
08:25:10 <apfelmus_> I have some plans for Haskell tutorials, so it's great that I can use Chris' service.
08:25:10 <lambdabot> why don't you guess?
08:25:29 <apfelmus_> Thanks for your help!
08:26:52 <aBrickOntheWall> thanks monochrome. It makes sense now.
08:26:54 <aBrickOntheWall>  
08:31:26 <roconnor> hmm, my program's footprint is growing well beyond the maximum heap size I gave it!
08:32:04 <roconnor> currently at 700M resident memory according to top when run with +RTS -M512M -c
08:49:47 <monochrom> roconnor: -M512M -c successfully gives "Heap exhausted; Current maximum heap size is 536870912 bytes (512 MB);" here
08:50:12 <monochrom> there are two other kinds of memory. stack and C heap
08:52:01 <roconnor> yes but by default the stack is 8M right?
08:52:20 <monochrom> yes
08:52:34 <roconnor> That isn't going to cause a 200M discrepency
08:52:53 <roconnor> runnning 6.12.3 here
08:52:56 <roconnor> maybe I shoudl upgrade
08:53:11 <roconnor> I think repa work in GHC 7 now.
08:54:00 <monochrom> same success with 6.12.3
08:54:45 <roconnor> I don't know what to say.  I killed the process and restarted it with -M256M -c
08:55:07 <roconnor> right now it is at 355M resident according to top
08:55:17 <monochrom> then there is still C heap
08:55:29 <roconnor> do bytestrings live in the C heap?
08:56:00 <monochrom> bytestrings live in some "pinned memory" which doesn't sound like haskell heap
08:56:35 <roconnor> I have some bytestrings, but they shouldn't be long lived.  They aren't part of my big structures.
08:57:05 <monochrom> any FFI library may use C heap
08:57:22 <monochrom> "repa" doesn't sound like pure haskell to me
08:57:32 <roconnor> oh I'm not using repa for this
08:57:50 <roconnor> it was just the reason I've been postponing upgrading GHC
08:58:02 <roconnor> This program is almost pure haskell
08:58:09 <copumpkin> monochrom: I think repa is pure haskell
08:58:09 <roconnor> it uses bytestring and network
08:58:40 <roconnor> and a few otherthings that should be pure: HashMap PSQueue
08:58:43 <monochrom> some ForeignPtr is involved in bytestring
08:59:19 <roconnor> why would I run out of heap without -c but exceed my heap with -c?
09:01:32 <roconnor> well maybe; this whole thing doesn't make sense anyways.
09:02:00 <EvilMachine> hello guys. special hello to ivanm if there. ;)
09:03:00 <EvilMachine> say guys, what's the best way to write a function, whose branching is 3-dimensional?
09:03:54 <erus`> how do you write a 2d branching one?
09:05:17 <EvilMachine> as in: the cross product of [0..2], [0..3] and [0..2]
09:05:38 <EvilMachine> erus`: hmm, i don't even know that one. :)
09:05:51 <EvilMachine> erus`: i think there should be a generic way
09:05:52 <monochrom> what a strange "branching"
09:06:00 <roconnor> how do you write a 1d branching one?
09:06:07 <zygoloid> why not just pattern match?
09:06:17 <EvilMachine> monochrom: for the lack of a better word... in the third language of mine. :)
09:06:23 <monochrom> > [ (x,y,z) | x<-[0..2], y<-[False..True], z<-"ab" ]
09:06:24 <lambdabot>   A section must be enclosed in parentheses thus: (`False..` True)Not in scop...
09:06:38 <monochrom> > [ (x,y,z) | x<-[0..2], y<-[False .. True], z<-"ab" ]
09:06:39 <lambdabot>   [(0,False,'a'),(0,False,'b'),(0,True,'a'),(0,True,'b'),(1,False,'a'),(1,Fal...
09:06:40 <EvilMachine> zygoloid: i kinda included pattern matching in branching
09:06:56 <copumpkin> > sequence [[0..2],[0..3],[0..2]]
09:06:57 <lambdabot>   [[0,0,0],[0,0,1],[0,0,2],[0,1,0],[0,1,1],[0,1,2],[0,2,0],[0,2,1],[0,2,2],[0...
09:07:19 <copumpkin> but you're screwed if you have infinite lists in the wrong place
09:07:27 <copumpkin> @hackage control-monad-omega
09:07:27 <lambdabot> http://hackage.haskell.org/package/control-monad-omega
09:07:31 <EvilMachine> monochrom: well, i wonder if that would work, if there actually was a small algorithmic difference for each of the x*y*z variants. :/
09:07:44 <joe6> i have this:  http://sprunge.us/dibY and I am trying to get to this:  http://sprunge.us/DeOe
09:07:53 <forrestv> hi roconnor ... not much intersection between bitcoin and haskell :)
09:08:01 <EvilMachine> monochrom: i guess i would have to make those differences into lambda functions to dynamically use
09:08:03 <joe6> any suggestions on how I can nest monadicIO functions?
09:08:10 <roconnor> forrestv: there is alot, sipa too
09:09:01 <zygoloid> EvilMachine: why not just write a function which pattern matches on the three arguments? f 0 0 0 = ...; f 0 0 1 = ...; f 0 1 0 = ... ; ...
09:09:03 <EvilMachine> roconnor: 1d branching? = pattern matching / "case". or "if ... then ... else".
09:09:19 <roconnor> EvilMachine: you can pattern match on multiple parameters at the same time.
09:09:42 <EvilMachine> zygoloid: yeah, that was my first solution there really is way too much similarity for me to feel comfortable about that though. ;)
09:09:50 <EvilMachine> roconnor: i know
09:10:03 <zygoloid> EvilMachine: put the similarity in a where clause, match the common bits, ...
09:10:30 <zygoloid> using a where-clause will mean using guards, but that might be ok depending on your actual problem
09:10:31 <EvilMachine> zygoloid: ok, yeah, i think that's the best solution
09:10:47 <EvilMachine> zygoloid: actually, i already needed guards anyway
09:11:49 <EvilMachine> maybe i'm expecting *too* much elegance. i kinda hoped for some single function on a single line, doing it all. ;)
09:12:29 <sipa> forrestv: actually, i learned about bitcoin because of a discussion in #haskell-blah
09:12:43 <copumpkin> I was thinking of doing a bitcoin implementation in haskell for the fun of it
09:12:48 <peoro> hello
09:12:54 <EvilMachine> sipa: oh oh. now i'm nauseous. ;))
09:12:57 <forrestv> ah, hehe
09:13:01 <EvilMachine> sipa: bitcoin. ;)
09:13:15 <mm_freak_> postgresql supports array types…  is there a way to use them in HDBC?  SqlValue doesn't seem to reflect any array/list-like type
09:14:04 <peoro> I'm trying to build a really simple HOpenGL program (following here: http://www.haskell.org/haskellwiki/OpenGLTutorial1), but `ghc -package GLUT HelloWorld.hs -o HelloWorld' gives me some linking errors: undefined reference to `glutMainLoop', `glutCreateWindow' and `glutInit' -- why does this happen and how can I fix?
09:14:20 <EvilMachine> mm_freak_: isn't a table with one column also a array?
09:14:43 <EvilMachine> mm_freak_: or with two, an associative one
09:14:55 <hpc> i think he means array type as in "this column is an array
09:14:56 <hpc> "
09:14:57 <mm_freak_> EvilMachine: in simple cases postgresql saves me from having to use a relation table for m:n relations
09:15:20 <mm_freak_> and yes, i mean array columns
09:15:38 <roconnor> monochrom: okay -M256 -c finally died with Current maximum heap size is 268435456 bytes (256 MB);
09:15:53 <roconnor> monochrom: it died with top reporting 460M used
09:16:10 <roconnor> monochrom: and it died in the place where -M512 usually dies
09:16:11 <mm_freak_> in my case i have an m:n relation, but i do lookups only in one direction…  an array column would suffice here
09:17:04 * ski idly wonders what happens if roconnor uses e.g. `-M16' instead
09:17:28 <roconnor> sorry i meant -M256M and -M512M above
09:20:59 <joe6> any suggestions on how I can fix this:  http://sprunge.us/UAXK , error:  http://sprunge.us/ggOR
09:21:50 <copumpkin> pyrony: klout!
09:23:31 <copumpkin> I wonder if the makers of klout get infinite klout because they can affect everyone else's klout
09:25:01 <ski> joe6 : the error basically says `Assertion' doesn't match `IO _'
09:25:24 <Lemmih> thoughtpolice: What's up?
09:25:26 <ski> joe6 : what if you try wrapping all your `IO'-actions with `liftIO' here ? (i'm only guessing)
09:26:53 <ski> joe6 : oh, and i'd try either remove the `>> return stack' part, or changing `IO' in the type to some type which can both do assertions (including doing I/O) and return a value
09:27:03 <thoughtpolice> Lemmih: not much!
09:27:07 <copumpkin> omg a thoughtpolice
09:27:13 <thoughtpolice> zzzzzzzzzzzzomg
09:27:38 <thoughtpolice> Lemmih: and yourself?
09:27:49 <ski> well, i'd suppose i'd start with looking at documentation, for how `Assertion' is meant to be used (and whether it can incorporate arbitrary `IO', and how that works with reproducability)
09:28:52 <joe6> ski, thanks. I was trying this : http://pastebin.com/t499bGF0
09:28:55 <mauke> The paste t499bGF0 has been copied to http://hpaste.org/47798
09:29:10 <joe6> i want to nest monadicIO functions ie. call one from the other
09:29:18 * ski ty's mauke
09:29:43 <joe6> ski, at the bottem, the prop_stackm is what I want.
09:29:50 <joe6> but, am not sure how to get to that.
09:30:14 <thoughtpolice> Lemmih: btw, i don't know if you were cc'd in the confirmation email, but on google analytics at one point we seemed to have stuff for projects.haskell.org/lhc w/ a homepage i assume. it is now gone so i deleted it :(
09:30:30 <thoughtpolice> Lemmih: i assume page got blasted when code/projects.haskell.org infrastructure went down
09:30:38 <ski> preflex : xseen chrisdone
09:30:42 <ski> hm
09:30:45 <joe6> ski, I thought that I can get away by changing the Property to IO, but that does not seem to help
09:30:45 <ski> preflex: xseen chrisdone
09:30:45 <preflex>  chrisdone was last seen on freenode/#haskell 19 hours, 12 minutes and 42 seconds ago, saying: Yeah. I either use list functions with Data.Char or full Parsec, pretty much.
09:31:10 <joe6> ski, does that make sense?
09:31:18 <ski> joe6 : `Property' and `IO' are very different things
09:33:27 <joe6> monadicIO takes IO actions and converts to Property?
09:33:44 <joe6> and I want to use an assert in a called function
09:34:27 <joe6> specifically this:  http://sprunge.us/QfIJ
09:35:03 <joe6> so, I do not have to assert the stack size test in every top-level function
09:37:16 <joe6> that uses the stack
09:37:47 <joe6> this is the monadic quickcheck stuff.
09:37:58 <roconnor> @hoogle ARR_WORDS
09:37:59 <lambdabot> No results found
09:38:11 <joe6> this is the full file: http://pastebin.com/V5GTRR3P
09:38:14 <mauke> The paste V5GTRR3P has been copied to http://hpaste.org/47799
09:39:10 <joe6> or, is there a different way of performing such abstraction..
09:39:28 <roconnor> what is an ARR_WORDS? something in bytestrings?
09:39:55 <copumpkin> it's the backing for ByteArrays iirc
09:40:09 <copumpkin> which probably includes Integer if it's large enough
09:41:23 <jonkri> why does leksah kill me?
09:41:59 <ski> joe6 : looking at <http://hackage.haskell.org/packages/archive/QuickCheck/2.4.1.1/doc/html/Test-QuickCheck-Monadic.html>, i think `Property' in your `prop_stackm' should probably be `PropertyM IO Stack'
09:42:04 <jonkri> sorry, but... first it messes up my cabal file, and now i get an "A package using 'cabal-version: >=1.6' must use section syntax" error when tryingto upload to hackage
09:42:47 <roconnor> copumpkin: thanks
09:42:52 <roconnor> copumpkin: do you know what type Some is?
09:42:56 <roconnor> @hoogle Some
09:42:56 <lambdabot> Control.Applicative some :: Alternative f => f a -> f [a]
09:42:56 <lambdabot> Control.Exception data SomeException
09:42:56 <lambdabot> Control.Exception SomeException :: e -> SomeException
09:43:47 <copumpkin> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects?redirectedfrom=Commentary/Rts/HeapObjects
09:44:11 <copumpkin> one of the CONSTR types probably
09:44:17 <copumpkin> Nothing would be a static one, I think
09:44:38 <copumpkin> Some would probably be CONSTR_1_0
09:44:46 <copumpkin> (I'm guessing)
09:45:03 <roconnor> why would it be one of the CONSTR types?
09:45:16 <copumpkin> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects?redirectedfrom=Commentary/Rts/HeapObjects#DataConstructors
09:45:21 <copumpkin> the DataConstructors section
09:46:05 <copumpkin> so the general one is CONSTR
09:46:14 <copumpkin> but "unique" things like Nothing will be CONSTR_STATIC
09:46:32 <roconnor> copumpkin: ah wait, iti s a type in HashMap
09:46:34 <roconnor> copumpkin: sorry
09:46:42 <ski> joe6 : did that help any ?
09:46:45 <copumpkin> a type in hashmap?
09:47:30 <roconnor> http://hackage.haskell.org/packages/archive/hashmap/1.2.0.0/doc/html/src/Data-HashMap.html
09:47:37 <roconnor> there is a type called Some in there
09:47:51 <copumpkin> oh I see
09:48:14 <copumpkin> not sure then
09:48:26 <joe6> ski, I tried that, but that did not seem to help.
09:48:35 <roconnor> copumpkin: no I answered my question
09:48:40 <copumpkin> oh :)
09:48:41 <roconnor> sorry for sending you on a wild goose chase
09:48:47 <copumpkin> no problem
09:48:49 <joe6> i am checking the docs to see if there is anyother function that can wrap up the Property functions.
09:49:19 <ski> joe6 : you seem to have other problems as well, other parts looks confused, but i'm not sure what you really want to do
09:49:58 <ski> joe6 : i would probably start with commenting out most of it, commenting in one part of a time (in topological order), fixing it, repeatedly
09:50:41 <ski> joe6 : at least you seem to have confused `Property' with `PropertyM IO blah' in one place, so look for that in other places as well
09:51:37 <ski> what do you need `IO' for, anyway ?
09:52:04 <joe6> ski, i am trying to test an external program, hence the need for IO
09:52:24 <joe6> ski, will comment out the other pieces and do what you recommend.
09:52:26 <luite> http://hpaste.org/47800 <- is it possible to make something like this work somehow, without adding a type annotation in the main function?
09:52:40 * hackagebot pontarius-xmpp 0.0.5.0 - A (prototyped) secure and easy to use XMPP library  http://hackage.haskell.org/package/pontarius-xmpp-0.0.5.0 (JonKristensen)
09:52:44 <joe6> ski, thanks for the advice
09:52:55 <luite> oh wait
09:53:00 <luite> that code has error
09:54:36 <luite> this one http://hpaste.org/47801
09:55:11 <luite> the problem is that D 5 is polymorphic, and there's not an instance of C for the most general type
10:00:23 <joe6> ski, i was able to get it work following what you did, by changing to prop_stackm :: Label -> Stack -> Int -> PropertyM IO Stack
10:00:31 <joe6> ski, thanks for the help.
10:01:39 <dafis> luite: perhaps it would work with ExtendedDefaultRules (I think, it may be spelled differently), worth a try
10:03:05 <ski> joe6 : nice
10:03:37 <luite> dafis: doesn't work, at least just adding th ExtendedDefaultRules extension doesn't
10:04:10 <c_wraith> ExtendedDefaultRules just allows GHC to default a type when a non-built-in typeclass constraint is present.
10:04:20 <dafis> luite: okay, then I have no other idea than a type signature
10:04:46 <c_wraith> That is, if you had (Foo a, Num a) => a, normally GHC won't default it.  If you turn on that extension, it will default it to Integer
10:04:57 <dafis> c_wraith: that's exactly what we have here
10:05:08 <callamberlamps> Why the heck are so many Haskell programmers overweight? I don't really want to be part of a community that promotes unhealthy living
10:05:27 <dafis> Num a from the literal 5, C from the use of str
10:05:30 <c_wraith> luite: got a paste somewhere?
10:05:33 <luite> wel actually not, I have a (Num a) => D a,  and an instance of C Double
10:05:35 <luite> c_wraith: yea
10:05:43 <luite> c_wraith: http://hpaste.org/47801
10:06:05 <tncardoso> callamberlamps, in computer science laziness is a virtue
10:06:20 <dafis> callamberlamps: what's your sample?
10:06:23 <callamberlamps> tncardoso: http://tristitiaetira.wordpress.com/2011/06/14/so-you-want-to-go-into-computer-science/
10:06:37 <c_wraith> luite: and it's complaining that it doesn't know what type to make the literal 5?
10:06:56 <callamberlamps> dafis: All the Haskell programmers I've met
10:07:16 <callamberlamps> imho they've let laziness spread into more than thunks
10:07:17 <c_wraith> callamberlamps: it's actually a secret conspiracy.  run while you still can.
10:07:21 <dafis> callamberlamps: how many (and who?)
10:07:36 <luite> c_wraith: see annotation for error
10:07:39 <callamberlamps> about 100 so pretty much every Haskell programmer
10:08:03 <tncardoso> callamberlamps, im my lab everybody is skinny
10:08:14 <dafis> callamberlamps: so you've never met a Simon, I take it, they're skinny
10:08:28 <callamberlamps> uh huh
10:08:32 <callamberlamps> Simon who
10:08:41 <callamberlamps> Probably not a Haskell programmer
10:08:44 <dafis> Simon PJ, SimonM
10:08:55 <callamberlamps> Oh that British idiot
10:09:06 <callamberlamps> Or was it Australian?
10:09:18 <callamberlamps> whatever he's an annoying dick
10:09:23 <callamberlamps> He doesn't count
10:09:28 <hpc> wut
10:09:56 <callamberlamps> I just don't like the British or Australian
10:10:10 <dafis> callamberlamps: freaking Yank?
10:10:19 <callamberlamps> Nope
10:10:39 <dafis> what then?
10:10:58 <callamberlamps> Pretty fitting that GHC comes from a criminal hellholde
10:11:03 <callamberlamps> Glasgow that is
10:11:17 <benmachine> goodness me, #haskell is not up to its usual standard in dealing with trolls today
10:11:20 <callamberlamps> Sort of like order arising out of chaos
10:12:28 <callamberlamps> benmachine: what are you talking about?
10:12:33 <callamberlamps> benmachine: Haskell is trolling
10:13:02 --- mode: ChanServ set +o monochrom
10:13:06 --- mode: monochrom set +q *!*@gateway/web/freenode/ip.178.73.220.13
10:13:21 --- mode: monochrom set -o monochrom
10:14:22 <gwern> @quote apple
10:14:23 <lambdabot> gwern says: Judging by the emails to -cafe and various bug trackers, the life of a Haskell developer on Apple systems is one drawn out agony of despair as they cut themselves on all the rounded
10:14:23 <lambdabot> corners of the faux Unixy-ness of Macs.
10:14:49 <monochrom> haha
10:15:08 <roconnor> @hoogle copy
10:15:08 <lambdabot> Data.ByteString copy :: ByteString -> ByteString
10:15:08 <lambdabot> Data.ByteString.Char8 copy :: ByteString -> ByteString
10:15:09 <lambdabot> Data.ByteString.Lazy copy :: ByteString -> ByteString
10:15:26 <gwern> monochrom: in my defense, I was enjoying some mead when I wrote that
10:16:19 <gwern> (mead is sweet, but loosens the tongue)
10:17:01 <luite> c_wraith: it looks like none of the proposals for adding defaulting rules has been implemented in ghc
10:17:01 <tromp> OSX is almost but not quite entirely unlike Linux
10:17:41 <wjp_> hello
10:17:51 <minsa> When I read "Learn you a haskell", I feel like I get it. Then I read "Gentle Introduction to Haskell".
10:17:54 <gwern> GREETINGS FELLOW HUMAN
10:18:02 <minsa> it makes me realize there are a lot of holes in my knowledge.
10:18:07 --- mode: ChanServ set +o monochrom
10:18:12 --- mode: monochrom set -q *!*@gateway/web/freenode/ip.178.73.220.13
10:18:21 --- mode: monochrom set +b *!*@gateway/web/freenode/ip.178.73.*
10:18:32 --- mode: monochrom set -o monochrom
10:20:35 <ski> @quote gentle
10:20:36 <lambdabot> lament says: gentle like gangrape
10:20:42 <ski> @quote gentle.introduction
10:20:42 <lambdabot> kmc says: i started to read the "tutorial" and it was incomprehensible. makes the Gentle Introduction to Haskell look like Teach Yourself PHP in 24 Hours
10:20:54 <ski> @quote gentle..introduction
10:20:54 <lambdabot> shapr says: [Regarding Hudak's so-called 'Gentle' introduction] Yeah, the mental brickbat of doom is a bit closer.
10:21:15 <ion> I wondered what kind of a fruit gan-grape is for a second.
10:21:29 <c_wraith> luite: ExtendedDefaultRules is used by ghci, and I've used it as well.  I think it's just limited to only *exactly* the specific case I mentioned.
10:22:43 <benmachine> oh wow, we have a long ban list
10:23:02 <ski> benmachine : it's lazily garbage-collected
10:23:17 <minsa> ski : what is the "tutorial" ?
10:23:35 <ski> i'm not sure which tutorial kmc was referring to
10:23:53 <ski> @where tutorial
10:23:53 <lambdabot> http://www.haskell.org/tutorial/
10:24:02 <ski> is the "Gentle" introduction
10:24:37 <ski> minsa : i suppose the "Gentle Introduction" is meant to be gentle, if you already know functional programming
10:25:08 <ski> minsa : otherwise, people seem to recommend reading other tutorials
10:25:35 <minsa> heh, but it's still fun even though I am getting my ass kicked.
10:25:41 <ski> (mind, i didn't find any fault in the Gentle Introduction, but then i already knew some basic Haskell when i discovered it)
10:25:44 <monochrom> I think minsa understands the gentle introduction just fine
10:26:30 <monochrom> one would not say "my knowledge has holes" after reading it if one were lost
10:26:58 <ski> ok
10:27:40 <ski> (i interpreted what minsa said as her/him being confused by it)
10:28:51 <minsa> ski, I definitely have to work through it. It's not automatic.
10:31:53 <ski> yeah. that's all well and fine
10:40:38 <luite> c_wraith: hmm, yes, that doesn't help here. I wonder what's the right thing to do, in my application, the class C is actually very similar to the Show class in ghci. it would make usability much better if it can do a lot of defaulting, but implementing that looks hairy
10:46:02 * roconnor is beginning to suspect that bytestrings are not reported in the heap profile.
10:46:13 <lispy> roconnor: that can happen actually
10:46:25 <roconnor> ?
10:46:28 <lispy> roconnor: IIRC, it's because they are malloced on the C side or something like that
10:46:35 * roconnor nods
10:46:38 <lispy> roconnor: I know at least some versions of ghc can have issues with it
10:46:52 <yitz> @vixen what do you use to study the gentle introduction?
10:46:52 <lambdabot> i'm a psychology major
10:47:07 <lispy> roconnor: I think what you see is the Haskell wrapper around the array, but not the bytes of the array in the heap profile
10:47:43 <roconnor> lispy: so if the heap profiler says I'm using 30 MB and I'm exhausing my 512M heap, it could because I have 100's of megabytes of bytestring arrays stashed away?
10:48:12 <lispy> roconnor: yes, I believe so
10:48:20 <lispy> roconnor: what OS are you on?
10:48:24 <roconnor> linux
10:48:44 <roconnor> I should ask the heap profiler who is retaining bytestrings
10:49:01 <lispy> roconnor: on linux you can do a trick with the dynamic loader to override malloc and manually add some statistics about how much memory is allocated via malloc
10:49:09 <lispy> yes, that's a good idea too
10:49:12 <roconnor> sounds complicated
10:49:28 <lispy> yeah, it's something I wish the RTS could do for you
10:49:48 <roconnor> I added a copy of copy's but to no effect
10:49:51 <copumpkin> djahandarie: there is one, on the wiki
10:49:54 <copumpkin> but nobody updates it anymore
10:50:01 <roconnor> granted unless I get enough copy's to free all my bytestrings, then there would be no effect.
10:50:15 <copumpkin> djahandarie: http://www.haskell.org/haskellwiki/Twitter
10:50:27 <lispy> roconnor: I think you're right to look at retainers by type
10:50:35 <lispy> roconnor: you probably need some strictness somewhere
10:50:50 <copumpkin> thoughtpolice: muffin_noodle, eh :P
10:51:31 <roconnor> I want to do something like -hr -hcByteString I think
10:51:44 <thoughtpolice> copumpkin: old hold over from back home when i use to game a LOT more
10:51:51 <copumpkin> :)
10:53:01 <thoughtpolice> copumpkin: where'd you see that, btw? i can't even remember if i have that tied to anything besides steam :P
10:53:14 <copumpkin> thoughtpolice: the haskellwiki page I just linked to
10:53:25 <thoughtpolice> oh, lololol
10:53:31 <thoughtpolice> didn't see that one
10:53:35 <lispy> roconnor: probably.  I always have to check the user guide for ghc :)
10:53:41 <shachaf> "maybe mzero return" doesn't happen to have a more compact name, does it?
10:54:23 <roconnor> hmm, empty graph
10:57:31 <byorgey> shachaf: not that I know of.  I've used that function before too.
10:57:53 <gwern> :t maybe mzero return
10:57:54 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
10:58:03 <gwern> @hoogle (MonadPlus m) => Maybe a -> m a
10:58:03 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
10:58:03 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
10:58:04 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
11:03:07 <joe6> this works:  http://sprunge.us/DZAj , any suggestions on how I can add a label to the assert here:  http://sprunge.us/LDPR
11:04:13 <roconnor> lispy: -hr -hyByteString
11:14:33 <ski> @hoogle maybeToMPlus
11:14:34 <lambdabot> No results found
11:14:55 <xplat> msum.catMaybes.return?
11:15:07 <ski> @let maybeToMPlus :: MonadPlus m => Maybe a -> m a; maybeToMPlus = maybe mzero mplus
11:15:07 <lambdabot>  <local>:12:62:
11:15:07 <lambdabot>      Couldn't match expected type `m1'
11:15:07 <lambdabot>             against in...
11:15:16 <ski> er
11:15:17 <xplat> er, msum . maybeToList
11:15:18 <ski> @let maybeToMPlus :: MonadPlus m => Maybe a -> m a; maybeToMPlus = maybe mzero return
11:15:19 <lambdabot>  Defined.
11:15:52 <ski> @let listToMPlus :: MonadPlus m => [a] -> m a; listToMPlus = foldr (mplus . return) mzero
11:15:53 <lambdabot>  Defined.
11:16:04 * hackagebot couchdb-enumerator 0.2.0 - Couch DB client library using http-enumerator and aeson  http://hackage.haskell.org/package/couchdb-enumerator-0.2.0 (JohnLenz)
11:16:07 <c0pumpkin> ski: that's nice
11:16:08 <ski> i'd like those in `Control.Monad' or something
11:16:16 <xplat> c°pumpkin
11:16:16 <helino> hi, what is the best way to run your quickcheck/hunit tests using cabal?
11:16:23 <ski> @index listToMaybe
11:16:23 <ddarius>  @let mplusToMPlus
11:16:23 <lambdabot> Data.Maybe
11:16:29 <ski> @index maybeToList
11:16:29 <lambdabot> Data.Maybe
11:16:40 <ben> c0pumpkin: heh
11:16:41 <c0pumpkin> xplat: it was annoying someone in #scala to have a common prefix with me
11:16:44 <xplat> listToMPlus is just msum, right?
11:16:53 <ski> @type listToMPlus
11:16:54 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [a] -> m a
11:16:56 <ski> @type msum
11:16:57 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
11:16:59 <c0pumpkin> xplat: nope
11:17:07 <xplat> oh, hm
11:17:08 <c0pumpkin> but msum . map return
11:17:09 <ddarius> c0pumpkin: Was that person Odersky?
11:17:19 <c0pumpkin> ddarius: nah :)
11:17:22 <c0pumpkin> that'd be codersky!
11:17:33 <ddarius> c0pumpkin: Then why didn't they change their nick?
11:17:38 <xplat> coödersky
11:17:41 <c0pumpkin> I'm just too considerate
11:17:51 <ddarius> c0pumpkin: You're damn right you are.
11:17:52 <ski> ddarius : *grin*. `MPlus' was an abbreviation of `MonadPlus' there -- maybe it would be better not to abbreviate ?
11:17:54 <sm> question of the day.. is there a standard lib or idiom for accessing parts of larger tuples ? like fst, snd
11:18:06 <c0pumpkin> sm: no
11:18:09 <sm> drat
11:18:12 <c0pumpkin> @hackage tuples
11:18:13 <lambdabot> http://hackage.haskell.org/package/tuples
11:18:19 <c0pumpkin> ugh
11:18:22 <c0pumpkin> I always get that one wrong
11:18:24 <c0pumpkin> @hackage tuple
11:18:24 <lambdabot> http://hackage.haskell.org/package/tuple
11:18:29 <ion> ski: m :: I (); m = pSL "H. w."
11:18:31 <helino> anyone got any tips on how to integrate cabal and quickheck/hunit?
11:18:35 <sm> yay
11:18:45 <c0pumpkin> sm: but I'd just avoid using huge tuples for much
11:18:49 * ski Hugs ion
11:19:02 <sm> I fairly frequently find myself with a triple to unpack, at least
11:20:20 <monqy> let (_, _, a) = yourtriple in a
11:20:29 <monqy> a bit verbose but it works
11:20:55 <ion> helino: I’m doing this in something i’m working on: https://github.com/ion1/rrdgraph-haskell/blob/master/rrdgraph.cabal
11:21:22 <ion> cabal configure -ftests && cabal build && dist/…/rrdgraph-tests
11:21:29 <sm> yeah.. I was just now getting lost in nested where and case clauses.. but maybe it's not worth another dependency. I shall use that lib next time probably
11:21:40 <sm> thx
11:22:42 <helino> ion: thanks, I've seen the new Test-Suite directive in cabal >= 1.10, have you tried using this?
11:23:19 <ion> helino: Not yet.
11:31:41 * frerich things a "Coolest Haskell Composition" site would be fun where people can post little functions which use between one and five applications of (.) and other people could vote on them. Every now and then I see somebody whipping up something like "flip blah . yoyo . dyne (`==` on length)" or so and I'm *amazed* how concise, readable and powerful the function actually is.
11:32:41 <ddarius> frerich: You should learn J.
11:33:22 <Nimatek> ddarius: That's just unreadable.
11:33:36 <ddarius> It isn't if you know it.
11:34:09 <Nimatek> I guess so.
11:34:11 <pgavin> anyone know if GHC supports anything like __func__ or __FUNCTION__ from C/C++?
11:34:50 <pgavin> actually what would be even cooler is to get the name of the immediate caller
11:34:52 <pgavin> somehow
11:41:48 <ski> @tell chrisdone hm, istr <http://hpaste.org/13301> had <http://hpaste.org/13302> as an annotation. has the annotation-associations been broken for old pastes ?
11:41:48 <lambdabot> Consider it noted.
11:51:36 <ion> frerich: On the subject, the Monoid b => Monoid (a -> b) instance is very useful for this pattern:
11:51:47 <ion> > mconcat [ const "foo", id, show ] "bar"
11:51:48 <lambdabot>   "foobar\"bar\""
11:53:09 <lpsmith> sigh... it'd be nice to have a way to tweak the hard-wired defaulting rules in GHC
11:53:23 <lpsmith> e.g. default to ByteString instead of String,  etc.
11:54:14 <lpsmith> there used to be some kind of functionality regarding that in either Hugs and/or GHC,  but I'm not sure what happened to it
12:01:00 <ion> > runReader (concat <$> sequence [ pure "foo", ask, asks show ]) "bar"
12:01:01 <lambdabot>   "foobar\"bar\""
12:01:37 <erus`> :t pure
12:01:38 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
12:02:24 <erus`> :t const
12:02:25 <lambdabot> forall a b. a -> b -> a
12:03:49 <ion> > map ($ 42) [ const "foo", pure "bar", return "baz" ]
12:03:49 <lambdabot>   ["foo","bar","baz"]
12:04:18 <shachaf> > (concat <$> sequence [pure "foo", ask, asks show]) "bar"
12:04:18 <lambdabot>   "foobar\"bar\""
12:06:31 <ion> Oh, i have managed to miss the MonadReader r ((->) r) instance.
12:08:52 <xarch_> @pl f x y = (x * y) `div` (y - x)
12:08:52 <lambdabot> f = ap (ap . (div .) . (*)) subtract
12:19:52 <ski> frerich,ion : you've seen <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx>, right ?
12:23:16 <frerich> ski: That's cool :-)
12:26:44 <xplat> @tell xarch_ (liftM2 . liftM2) div (*) subtract
12:26:44 <lambdabot> Consider it noted.
12:27:08 <gwern> @tell dons http://www.galois.com/~dons/arch-haskell-status.html seems to be broken
12:27:08 <lambdabot> Consider it noted.
12:27:13 <gwern> @flush
12:27:34 <gwern> what it used to look like if anyone cares: http://webcitation.org/5zFRmC7kv
12:27:51 <xplat> @quote contract
12:27:51 <lambdabot> Veinor says: I can teach you monads if you sign this contract ／人◕‿‿◕人＼
12:28:07 <Veinor> haha
12:28:24 <gwern> so geeky
12:29:36 <shachaf> @ohai gwern
12:29:37 <lambdabot> gwern!!
12:31:38 <gwern> actually, all of dons's pages on galois.com that I link seem to be dead
12:31:44 <ion> ski: Nice
12:36:32 * hackagebot css 0.1 - Minimal monadic CSS DSL.  http://hackage.haskell.org/package/css-0.1 (ChrisDone)
12:36:55 <copumpkin> @ty let f g h i x y = g (h x y) (i x y) in f
12:36:56 <lambdabot> forall t t1 t2 t3 t4. (t -> t1 -> t2) -> (t3 -> t4 -> t) -> (t3 -> t4 -> t1) -> t3 -> t4 -> t2
12:41:58 <xplat> copumpkin: it turns out to be liftM2 . liftM2
12:42:16 <copumpkin> xplat: I thought it might be something like that
12:43:13 <dafis> @ty liftM2 . liftM2
12:43:14 <lambdabot> forall (m :: * -> *) a1 a2 r (m1 :: * -> *). (Monad m, Monad m1) => (a1 -> a2 -> r) -> m (m1 a1) -> m (m1 a2) -> m (m1 r)
12:43:14 <wntKissAnyAss> gentoo.de they block and ping-overflows unwanted people in irc
12:43:41 <parcs> @ty liftM2 ap
12:43:42 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m, Monad m1) => m1 (m (a -> b)) -> m1 (m a) -> m1 (m b)
12:44:01 <roconnor> when the heap profiler says that SYSTEM,updateBlock is retaining something, what does it mean?
12:44:13 <roconnor> (updateBlock a a function of mine)
12:49:58 * roconnor is becoming increasing convince he has a major ByteString.Lazy space leak that doesn't appear on the heap profile
12:51:13 <DrDobs> hello
12:51:33 <copumpkin> roconnor: considering ByteStrings live outside the haskell heap (don't they?) I wouldn't be too surprised
12:51:58 <roconnor> that would also explain why the heap profile is 10x smaller than the heap when I run out of heap
12:52:26 <roconnor> that and I have a surprising amount of Lazy Bytestring constructors hanging around when I expect them all to be short lived. ...
12:52:35 * roconnor is looking at you PS
12:53:35 <dafis> roconnor: PS?
12:53:35 <copumpkin> they're ForeignPtrs to facilitate interop with non-haskell code
12:53:36 <copumpkin> not sure what they use to allocate though
12:53:36 <copumpkin> it seems that a pinned bytearray would be fine
12:53:36 <copumpkin> and then haskell would know about it
12:53:36 <copumpkin> unless you just wrap an existing pointer
12:53:48 <byorgey> hi DrDobs
12:54:16 <roconnor> dafis: PS is a name of a constructor of the Lazy Bytestring data type I believe.
12:54:35 <dafis> roconnor: it's the strict bytestring's constructor
12:54:45 <dafis> lazy is Empty and Chunk
12:54:51 <roconnor> oh?
12:54:59 <roconnor> ...
12:56:31 <dafis> roconnor: istr that you copy a lot?
12:56:45 <roconnor> istr?
12:56:51 <dafis> I seem to remember
12:57:02 <ski> (alt. s/remember/recall/)
12:57:11 <roconnor> I added some copy's in an attempt to free some bytestrings
12:57:31 <dafis> roconnor: maybe that didn't work out
12:57:40 <dafis> what are you doing, by the way?
12:58:03 <roconnor> validating bitcoin client
12:58:47 <roconnor> heh, okay I think that maybe printing out my entire priority queue at each step has plugged my leek ^_^
12:58:49 <dafis> roconnor: not familiar with that, what are you doing with the ByteStrings
12:59:00 <roconnor> I'm reading network packets
12:59:04 <roconnor> parsing them
12:59:11 <roconnor> and squirling small bits of them away.
12:59:43 <dafis> roconnor: sounds like your parser may need to force results
13:01:35 <roconnor> I've never really understood how to mix laziness with maps
13:02:50 <Elvish_Pillager> Hi. I've googled for this a bit, but can't figure it out: Is there an existing Haskell multi-indexed container type? Like, say, I want to store events in something like a (Map.Map (time, location) eventInfo), but I want to be able to look up events either by time or location.
13:03:17 <dankna> hm
13:03:32 <dankna> I would probably do it as (Map time eventInfo, Map location eventInfo)
13:03:43 <copumpkin> Elvish_Pillager: I doubt it, and am not sure how you could do it more efficiently than just a pair of maps
13:03:54 <copumpkin> Elvish_Pillager: the question is how would you even write a type for it?
13:04:10 <Phyx-> dankna: wouldn't updating be an issue?
13:04:20 <dankna> Phyx: yes, it would take some care
13:05:07 <Elvish_Pillager> yeah, updating is the issue I'm worrying about
13:05:08 <copumpkin> well, you could either have an implicit value-level fundep
13:05:16 <copumpkin> or have the individual lookups return sets
13:06:56 <dankna> oh, yes, I see the issue you're referring to, copumpkin
13:07:01 <dankna> didn't think of that at first
13:07:45 <Elvish_Pillager> I don't see the issue; maybe I'm just too much a beginner?
13:08:00 <copumpkin> I could insert (5, 6) -> 7 and (4, 6) -> 8
13:08:09 <copumpkin> now I look up by snd, the value 6
13:08:13 <copumpkin> what does it return?
13:08:34 <Elvish_Pillager> copumpkin, I imagine there'd be separate lookup functions for the two key types
13:08:42 <Elvish_Pillager> oh wait
13:08:44 <dankna> the issue is that maps enforce a uniqueness constraint
13:08:47 <Elvish_Pillager> right
13:08:51 <Elvish_Pillager> no, it's not unique by those things
13:08:56 <Elvish_Pillager> the lookup functions should return lists
13:08:57 <copumpkin> so it could return Set(7,8)
13:09:02 <Elvish_Pillager> or sets, yeah
13:09:19 <copumpkin> or it could complain about uniqueness (fundep violation) on insert
13:09:30 <copumpkin> or overwrite the previous mapping, which seems unpleasant :P
13:11:04 <Elvish_Pillager> hang on, it turns out that the thing I was originally looking for this for doesn't really want any kind of uniqueness
13:12:47 * hackagebot named-formlet 0.1 - A simple formlet library with named formlets.  http://hackage.haskell.org/package/named-formlet-0.1 (ChrisDone)
13:12:48 <Elvish_Pillager> I probably need to write my own type anyway, I just need to figure out how to write it nicely.
13:13:16 <copumpkin> I'd just implement it as a pair of maps that check constraints as you modify them
13:13:26 <copumpkin> unless you need more than a pair
13:14:23 <Elvish_Pillager> I might - I'm not sure exactly how this will be structured right now. The basic thing is that I wanted to do things like make an updated version with all the events at a particular location removed, so that they wouldn't show up in a lookup by time, and vice versa.'
13:20:27 * roconnor notices Data.Map has more !'s than Data.PSQueue
13:22:49 * hackagebot idris 0.1.7.1 - Dependently Typed Functional Programming Language  http://hackage.haskell.org/package/idris-0.1.7.1 (EdwinBrady)
13:23:25 <dafis> does anybody remember which module one has to import to get the Show instance for UTCTime in scope?
13:24:09 <chrisdone> λ> :m + Data.Time
13:24:10 <chrisdone> λ> getCurrentTime
13:24:10 <chrisdone> 2011-06-14 20:48:56.144264 UTC
13:24:10 <chrisdone> λ>
13:24:10 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
13:24:13 <chrisdone> Er, Data.Time?
13:24:56 <dafis> Prelude Data.Time Data.Time.Format Locale Data.Time.Clock> parseTime defaultTimeLocale "%D %H:%M:%S  %p" ds :: Maybe UTCTime
13:24:56 <dafis> <interactive>:1:1:
13:24:56 <dafis>     No instance for (Show UTCTime)
13:25:09 <Twey> chrisdone: http://journal.twey.co.uk/dev/2011-06-05-hive.html
13:25:17 <dafis> nope, not here
13:25:54 <dafis> oh, wait, I did "import Foo", I had to use :m + Foo
13:26:33 <chrisdone> Twey: Cool. /me reads
13:27:21 <dafis> Okay, so why doesn't bring "import Foo" at the ghci prompt the instances into scope?
13:28:05 <Phyx-> Twey: A few years ago I wrote somethig like that in C#. The core was just a plugin loader, with 3 different plugin types, A security plugin (has to be signed), connection plugins adding support for different plugins, Command plugins which allow a plugin to inplement actual functionality
13:28:08 <erus`> how can i improve my code ? https://github.com/tm1rbrt/haskell/blob/master/tictactoe/tictactoe.hs
13:52:09 <Seppoz> Nibble` says fold is awesum can you explain why?
13:52:44 <Twey> Because you can represent most list operations as folds
13:53:36 <Seppoz> im sorry but i still dont get hat
13:53:38 <Seppoz> *that
13:53:53 * ski thinks it's interesting that you can express `zip' as a `foldr'
13:54:21 <chrisdone> Twey: It seems like components further down the tree will need to be aware of where input comes from in order to use the `in' method as opposed to the `out' method. This seems to break the abstraction if a component needs to know what kind of component is communicating with it, so I'm not clear on the implementation of the reflector despite being clear on the concept.
13:55:48 <Phyx-> ski: as a single foldr?
13:57:43 <ski> Phyx- : as two `foldr's, one for each input list
13:57:49 <ddarius> chrisdone, Twey: All I see when I look at it is concurrent processes that communicate over channels.  The problem is just a matter of a manager process to wire them up (or rather wire up the initial configuration.)
13:57:56 <Phyx-> Twey: ah ok :)
13:57:59 <ddarius> @src zip
13:57:59 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
13:57:59 <lambdabot> zip _      _      = []
14:00:45 <ddarius> > foldr (\a zip' bs -> case bs of [] -> []; (b:bs') -> (a,b):zip' bs') (const []) "abc" "def"
14:00:46 <lambdabot>   [('a','d'),('b','e'),('c','f')]
14:01:37 <ddarius> > foldr (\a zip' bs -> case bs of [] -> []; (b:bs') -> (a,b):zip' bs') (const []) "abc" "defi"
14:01:37 <lambdabot>   [('a','d'),('b','e'),('c','f')]
14:01:45 <ski> the idea is that you're to use `foldr' for deconstructing and looping through the lists, not anything else
14:01:47 <ddarius> > foldr (\a zip' bs -> case bs of [] -> []; (b:bs') -> (a,b):zip' bs') (const []) "abcd" "def"
14:01:48 <lambdabot>   [('a','d'),('b','e'),('c','f')]
14:02:10 <ski> (so implementing `null' and `head' and `tail' in terms of `foldr' doesn't count)
14:03:33 <ddarius> > foldr (\a zip' -> foldr (\b bs' -> (a,b):bs') []) (const []) "abcd" "def"
14:03:34 <lambdabot>   [('a','d'),('a','e'),('a','f')]
14:04:33 <c_wraith> that's not right
14:05:14 <Twey> chrisdone: Why would they need to be aware of where the input comes from?
14:05:14 <copumpkin> magic
14:05:23 <ddarius> c_wraith: Clearly.  I didn't use zip' at all.
14:06:45 <chrisdone> Twey: Can you elaborate on this? “[C]omponents further down the tree may send messages to the in method on this address to have them passed inwards as if they came from a parent of the reflector.”
14:07:01 <hpaste> “Mukesh Tiwari” pasted “SPOJ Recurrence_5294” at http://hpaste.org/47812
14:07:19 <mauke> chrisdone! why is "email" a required field
14:07:38 <ddarius> mauke: He has to make money some way.
14:08:07 <mauke> but if you put anything in your post is rejected
14:08:13 <mauke> you have to send it as ""
14:08:54 <Twey> chrisdone: The aggregator can send a message to the reflector's ‘in’ method
14:09:25 <Twey> Which causes the reflector to tag the message with a target=<the sending component> and send it off as if it had received it from the server
14:09:26 <chrisdone> mauke: Because I put it as a field in my formlet (rather than writing orthogonal code to check POST params manually). I can take it out if it's a problem.
14:10:07 <mauke> it's not a problem anymore, just counterintuitive
14:11:21 <chrisdone> Twey: Ah, okay. Then it forwards it to the child components?
14:12:12 * chrisdone waits for diagrams and code
14:12:38 <Twey> chrisdone: Yeah, when/if it makes its way back up to the reflector again, the reflector sends it directly back to the original component, which can treat it specially because it's still tagged with ‘target’
14:13:00 <chrisdone> Twey: Right, I grok then.
14:13:34 <Twey> ddarius: Yeah, there's a pretty GUI/TUI management console in the works somewhere for building big complex chains and saving and recreating configurations.
14:19:35 <chrisdone> mauke: If you remove the bit from your bot about sending an empty string email I'll restart hpaste with that requirement removed.
14:20:35 <mauke> I'm currently working on making it asynchronous
14:21:08 <mauke> removing one line of data isn't that important :-)
14:21:30 <chrisdone> Okay. :-)
14:25:03 <chrisdone> Asynchronous? What's it written in?
14:25:17 <mauke> irssi script, perl
14:25:57 <chrisdone> Right now it blocks the client when pulling or something?
14:26:07 <mauke> which means every time someone mentions a pastebin url my irssi freezes until it's completed two http requests
14:26:24 <chrisdone> Yeah.
14:28:15 <mauke> so what I've done is I've written a (hopefully) complete subprocess module
14:28:21 <chrisdone> Twey: BTW I was working on lojbot late 2008-2009. Yep, that's 2~ years ago. Time flies like an arrow. :-)
14:28:51 <chrisdone> mauke: So it launches a separate Perl process and IPC's?
14:28:59 * dafis refrains from quoting Groucho
14:29:16 <mauke> hmm, what woukd its type be?
14:29:55 <mauke> forkOff :: String -> IO () -> (String -> String -> Int -> IO ())
14:30:03 <mauke> not much ipc
14:30:25 <mauke> it takes an action to run in a separate process
14:30:31 <mauke> you can specify its stdin up front
14:30:32 <chrisdone> What're the strings? stdout/stderr/exit value?
14:30:39 <mauke> exactly
14:30:43 <chrisdone> Ah, ok.
14:32:11 <chrisdone> (forkOff :: String -> (String -> String -> Int -> IO ()) -> IO (), no?)
14:32:13 <Twey> chrisdone: Hehe, truly
14:33:15 <hpaste> ski pasted “`zipWith' using `foldr'” at http://hpaste.org/47814
14:33:38 <chrisdone> rtharper: Hey Tom; you're coming to CamHac right? What will you be hacking on?
14:33:46 <rtharper> chrisdone: I won't, actually
14:33:51 <rtharper> I'll be at Utrecht
14:34:32 <chrisdone> Oh. (　´_ゝ`）
14:34:36 <copumpkin> ski: that's interesting
14:34:49 <rtharper> chrisdone: I'll be hacking on UHC
14:34:49 <mauke> oh, I was missing a -> IO () at the end
14:35:08 <ski> chrisdone : hm, some recent change at `hpaste.org' appears to have made it impossible to make a paste/annotation from w3m :(
14:35:30 <chrisdone> rtharper: Ah, enjoy. :-)
14:35:32 <chrisdone> ski: Let me try it.
14:35:53 <ski> (chrisdone : also, the text-box, when viewed in w3m is now only one line, instead of several lines. but that's not as severe a problem)
14:36:37 <mauke> works here
14:37:06 <mauke> it looks like one line but it's edited with an external editor
14:37:22 <mauke> I wonder why I'm seeing everything as source code
14:37:24 <chrisdone> ski: Hmm. w3m http://hpaste.org/ — w3m/0.5.2 actually shows me merely the HTML. I recall it should render the DOM. What version are you using?
14:37:32 <chrisdone> mauke: Me too. ._.
14:37:53 <mauke> chrisdone: hit v
14:37:56 <ski> nothing happens on this side, when i press the `Submit' button, except that i'm redirected to <http://hpaste.org/> (with my paste not showing up in the list of recent pastes)
14:38:15 <mauke> ski: did you enter something in the email field?
14:38:21 <ski> mauke : nothing
14:38:40 <ski> (then i also tried entering a few bogus values, to no effect)
14:38:53 <mauke> chrisdone: I don't see a Content-type header
14:38:55 <chrisdone> It seems I'm not actually sending a Content-Type from Snap. I thought Snap would take care of that.
14:39:06 <chrisdone> Yeah. I'll add one.
14:39:10 <ski> mauke : oh, i'm also getting the HTML source now, unless i press `v' -- it wasn't that way before
14:39:17 <ski> ah,ok
14:39:51 <hpaste> chrisdone annotated “test” with “test (annotation) from w3m” at http://hpaste.org/47815#a47816
14:40:10 <chrisdone> ski: Yeah, I'll add the Content-Type. Sorry about that.
14:40:27 <ski> copumpkin : indeed :)
14:41:06 <ski> (mauke : yeah, i've already set up `emacsclient' as external editor. that part is working fine)
14:41:38 <chrisdone> Hm, w3m is quite nice.
14:42:06 <ski> chrisdone : w3m/0.5.1 here
14:43:20 <ski> (re w3m nice : you can also make w3m display images inline in at least XTerm and frame buffer, using the `w3m-img' package)
14:44:16 <mauke> ah, that reminds me of writing a primitive console image viewer using svgalib
14:44:18 <mauke> good times
14:44:34 <osfameron> hmmm. foldr isn't tail recursive?
14:44:34 <Twey> Huh, you can display images in xterm?
14:44:43 <copumpkin> osfameron: no
14:44:46 <Twey> @src foldr
14:44:46 <lambdabot> foldr f z []     = z
14:44:46 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:44:57 <Twey> Can't be
14:45:02 <copumpkin> osfameron: foldl is, sort of. foldl' is closer
14:45:02 <osfameron> does haskell have other optimizations than TCE to apply to it?
14:45:04 <mauke> it's tail but not recursive
14:45:23 <copumpkin> osfameron: notions of tail recursiveness are more complicated and sometimes less relevant, in haskell
14:45:25 <ski> copumpkin : roughly the `A' and `B' types are used to "freeze" the "current continuation" inside the two `folds', so you can pass the bar back and forth between them, a bit like coroutines
14:45:26 <shachaf> osfameron: Well, there's laziness, if you consider that an optimization.
14:45:42 <osfameron> aha
14:45:50 <Twey> I think appropriate application of strictness/laziness stops it overflowing
14:45:58 <ski> osfameron : if `foldr' was tail-recursive, then it couldn't be incremental
14:46:01 <osfameron> that could be why foldr is less commonly implemented in other languages
14:46:06 <ski> Twey : yes
14:46:32 <Twey> You just have to make sure the ‘f x _’ is evaluated and the ‘foldr f z xs’ isn't
14:46:43 <Twey> Then the applications can be collapsed
14:46:49 <Twey> And it runs in constant space
14:47:11 <roconnor> ... I think switching form ByteString to [Word8] has improved my memory performance :D
14:47:12 <ski> Twey : adaiui, XTerm itself knows nothing about it, w3m looks at `WINDOWID' and communicates with X to draw images on top of the XTerm window
14:47:19 <Twey> Oh, right
14:47:24 <Twey> Ick :þ
14:47:38 <Twey> (ADAIUI?)
14:47:44 <chrisdone> ski: 'K, try it in w3m now.
14:47:51 <ski> s/adaiui/afaiui/
14:48:22 <Twey> Ah
14:49:16 <hpaste> ski pasted “test in w3m” at http://hpaste.org/47817
14:50:02 <dankna> bah, when you're pasting something nobody is ever going to read, you have to make it amusing!
14:50:04 <dankna> that paste was boring!
14:51:21 <chrisdone> “I'm informed that your Royal father grows evermore eccentric and﻿ at present﻿ he believes himself to be a small village in Lincolnshire.”
14:51:25 <Twey> It dropped my paste :<
14:51:36 <Twey> chrisdone: Check encoding handling
14:51:48 <chrisdone> Twey: “Dropped”?
14:51:55 <chrisdone> Twey: You didn't fill in the email, did you?
14:51:57 <hpaste> Twey pasted “The Unseen Paste” at http://hpaste.org/47818
14:51:59 <ski> chrisdone : ok. whatever you did (including and apart from sending `Content-type') seems to have made things work in w3m, on this side
14:52:02 <ski> chrisdone : ty
14:52:02 <dankna> there you go, yes, something like what chrisdone just said.
14:52:04 <Twey> chrisdone: No
14:52:13 <Twey> chrisdone: ‘Dropped’ as in completely ignored and sent me back to the form
14:52:19 <dankna> I filled in the email once, I felt stupid
14:52:23 <Twey> chrisdone: I think because I wrote β in it
14:52:32 <chrisdone> Twey: Which field?
14:52:39 <Twey> The paste field
14:52:55 <chrisdone> Works here…
14:53:05 <Twey> Hm
14:53:08 <hpaste> Twey pasted “The Unseen Paste” at http://hpaste.org/47819
14:53:11 <Twey> Huh.
14:53:13 <Twey> Now it works.
14:53:15 <hpaste> chrisdone annotated “The Unseen Paste” with “A real β” at http://hpaste.org/47818#a47820
14:53:17 <Twey> It didn't before…
14:53:28 <dankna> Twey: hahaha I get the reference!
14:53:37 <ski> chrisdone : btw, is it the case that paste-annotation relationships between old pastes have disappeared (as appeared to be the case) ?
14:54:21 <chrisdone> ski: I think so, depending on ‘old’. Ones from last year, I didn't maintain relationships. If you have a couple you want linking up I can sort them manually in a jiffy.
14:55:00 <chrisdone> Speaking off, I should probably make an export available of the DB in case I get ran over.
14:56:50 <chrisdone> ski: http://hpaste.org/13301
14:57:01 <ski> chrisdone : istr <http://hpaste.org/13301> had <http://hpaste.org/13302> as annotation
14:57:04 <ski> yes
14:57:17 <chrisdone> Done.
15:00:33 <chrisdone> That use of foldr bent my brain a little.
15:02:16 <chrisdone> I've never thought of using a function for the cons.
15:03:04 <Twey> chrisdone: ?
15:03:06 <shachaf> Which use of foldr?
15:03:15 <chrisdone> http://hpaste.org/47814
15:03:20 <Twey> > foldr (:) [] [1 .. 10]
15:03:20 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
15:03:40 <chrisdone> Er, a function for the nil, sorry.
15:03:56 <Twey> Oh, right
15:03:58 <iskren> is it true that a pattern having @ (like a@(b:bs)) will match regardless of what is after @
15:04:06 <mauke> no
15:04:16 <kmc> it matches only things that (b:bs) would match
15:04:16 <Twey> Haven't you seen the old ‘foldr (.) id’?
15:04:20 <iskren> mauke, this was for me?
15:04:22 <kmc> but it also binds the whole matched thing to 'a'
15:04:44 <iskren> kmc, mauke ah thanks very much!
15:04:50 <mauke> preflex: msg #haskell test http://pastebin.com/5gyAuKnd
15:04:50 <preflex> test http://pastebin.com/5gyAuKnd
15:04:58 <chrisdone> :t foldr (\x f k -> x : f k) (const [])
15:04:59 <lambdabot> forall a b. [a] -> b -> [a]
15:05:02 <kmc> ~(b:bs) will match anything
15:05:03 <Twey> A pattern like a@~(b:bs) will match regardless.
15:05:05 <kmc> but that's a different beast entirely
15:07:44 <chrisdone> I once had a use for ~, and then I rewrote my code and didn't. :-(
15:07:51 <chrisdone> HugoDaniel: Coming to CamHac? ;-)
15:08:18 <kmc> chrisdone, did you rewrite it to use "let"?
15:08:19 <monochrom> rewriting with a "let" waives some "~"s
15:08:28 <monochrom> or with a "where"
15:08:31 <kmc> it's useful with lambda
15:08:49 <kmc> it sucks to write \a -> let (b:bs) = a in ...
15:11:22 <ski> > foldr (\n k z -> k (n : z)) (\z -> z) [0,1,2,3] []  -- chrisdone, surely you've seen this "leaned so far right he came back left again!"-style before ?
15:11:22 <lambdabot>   [3,2,1,0]
15:11:28 <kmc> hehe
15:12:11 <monochrom> haha leaned so far right it came back left
15:12:20 <ski> (<http://www.willamette.edu/~fruehr/haskell/evolution.html>, see "Yet another senior Haskell programmer")
15:12:22 <chrisdone> > foldr (\x f (k:ks) -> (,) x k : f ks) (const []) [1..5] [5..10]
15:12:23 <lambdabot>   [(1,5),(2,6),(3,7),(4,8),(5,9)]
15:12:33 <chrisdone> ski: Nope! Never seen it.
15:12:51 <mauke> preflex: msg #haskell test http://pastebin.com/5gyAuKnd
15:12:51 <preflex> test http://pastebin.com/5gyAuKnd
15:12:53 <mauke> The paste 5gyAuKnd has been copied to http://hpaste.org/
15:12:58 <mauke> oh well
15:13:16 <monochrom> oh, where is the unique id? :)
15:13:31 <ski> chrisdone : the extra argument to `foldr' above is an accumulator which is passed down into the `cons' and `nil' arguments of the `foldr'
15:13:39 <monochrom> it also doesn't seem to get copied at all
15:13:41 <ski> in my case, the `nil' just returns the accumulator at the end
15:15:20 <mauke> something changed again
15:15:51 <chrisdone> ski: Yeah, it's quite nice.
15:15:52 <mauke> hpaste silently rejects my posts now
15:15:59 <Twey> mauke: I got that!
15:16:06 <osfameron> hmmm, how can foldr work on infinite lists?
15:16:06 <monochrom> http://stackoverflow.com/questions/6172004/writing-foldl-using-foldr/6172270#6172270 has a complete and teachable description
15:16:33 <osfameron> thanks
15:16:35 <Twey> osfameron: Laziness :þ
15:16:40 <monochrom> foldr f works for infinite lists if f is non-strict enough
15:16:42 <roconnor> > foldr const undefined [0..]
15:16:43 <lambdabot>   0
15:16:49 <ski> chrisdone : you must have used monadic types for `nil' before though, right ?
15:16:51 <chrisdone> mauke: Consistently? With what data?
15:17:18 <chrisdone> ski: Sure, I've used Maybe.
15:17:20 * ski has several times thought he needed `foldM' or something similar, only to realize (after implementing the fold) that it's just `foldr'
15:17:23 <osfameron> roconnor: ah!
15:17:36 <roconnor> @src concat
15:17:36 <lambdabot> concat = foldr (++) []
15:17:42 <monochrom> it is best to just calculate. let the symbols do the work
15:17:49 <roconnor> ^^ also works on infinite lists most of the time.
15:18:15 <ski> osfameron : if `foldr' wasn't incremental (e.g. if it was tail-recursive), then it couldn't work for infinite lists
15:18:47 <osfameron> ok
15:19:00 <monochrom> right, this is why the converse, "implement foldr using foldl" cannot be perfectly done. you have to ignore the infinite case
15:19:08 <chrisdone> mauke: Ah, wait. I think a patch I removed in git wasn't actually removed. My bad. Re-applied it when fixing ski's w3m issue. Sec.
15:19:19 <ski> that it works for infinite lists is a symptom of it being incremental
15:19:30 <Twey> > concat $ repeat "."
15:19:31 <lambdabot>   ".............................................................................
15:19:58 <c_wraith> > concat $ repeat [1..]
15:19:59 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:20:14 <c_wraith> heh.  I like repeat [1..]
15:20:34 <mauke> preflex: msg #haskell test http://pastebin.com/5gyAuKnd
15:20:34 <preflex> test http://pastebin.com/5gyAuKnd
15:20:57 <chrisdone> mauke: Haha, waaaait. Stop hacking. :-P
15:21:15 <mauke> implemented basic sanity checks
15:21:35 <mauke> now it won't announce obviously failed posts
15:21:58 <roconnor> osfameron: you can use a combination of CPS style and foldr to perform early escape.  I had a reddit comment about this somewhere, but it isn't so easy to find stuff on reddit.
15:21:59 <ski> > let concat = (>>- id) in concat (repeat [0 ..])
15:21:59 <lambdabot>   [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8...
15:23:01 <nihtml> :t >>-
15:23:02 <lambdabot> parse error on input `>>-'
15:23:05 <monqy> :i >>-
15:23:08 <ski> @type (>>-)
15:23:09 <lambdabot> forall (m :: * -> *) a b. (MonadLogic m) => m a -> (a -> m b) -> m b
15:23:26 <c_wraith> so it's fair join
15:23:28 <chrisdone> mauke: Twey: So I removed the spam trap from the form but then reverted that patch (except I didn't, I got side-tracked). Then I ended up compiling that patch when fixing the Content-Type and rebuilding. Twey, that's probably why it failed first and then worked, because the home page changed after you visited the first time.
15:23:31 <c_wraith> right, instead of concat
15:23:32 <c_wraith> makes sense
15:23:33 <chrisdone> Aaaanyway. /me rebuilds
15:23:34 <osfameron> roconnor: heh, interesting
15:23:40 <ski> > let concat = (>>- id) in concat [[0,1,2,3],[4,5,6],[7,8],[9],[]]
15:23:41 <lambdabot>   [0,4,1,7,2,5,3,9,6,8]
15:23:42 <kmc> ooh ooh i want to see an example of using (>>-)
15:23:45 <ski> > concat [[0,1,2,3],[4,5,6],[7,8],[9],[]]
15:23:45 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
15:23:55 <Twey> chrisdone: Oh.
15:24:07 <Twey> What is MonadLogic?
15:24:08 <ski> `(>>-)' is fair, wrt infinite lists
15:24:13 <mauke> chrisdone: but why did it fail for me?
15:24:15 <chrisdone> mauke: 'K, so the spam trap is back. Please send "" as before. I won't change it now (didn't mean to).
15:24:15 <kmc> Twey, a class for logic programming
15:24:23 <Twey> Logic programming?
15:24:26 <Twey> Like Prolog?
15:24:28 <aavogt> is there a liftM2 that is written in terms of >>-?
15:24:28 <kmc> yes
15:24:31 <Twey> Oh
15:24:40 <kmc> though saying that is something like saying "imperative programming? like Java?"
15:24:41 <Twey> Does that differ from [], operationally?
15:24:46 <ski> Twey : well, only the backtracking part of it, not the logic variable part of it
15:24:52 <chrisdone> mauke: Because sending "", after applying, became equivalent to sending *something*, as opposed to no param at all… sorry.
15:25:03 <mauke> heh
15:25:05 <ski> Twey : see my `concat' examples above for how it differs
15:25:09 <kmc> Twey, yes, for starters it handles infinite choice properly (but so does control-monad-omega)
15:25:16 <kmc> it also allows "soft cut" whatever that is
15:25:20 * chrisdone learns that mixing API with UI leads to smudge
15:25:31 <ski> kmc : it's basically a conditional
15:25:41 <hpaste> int80_h pasted “find my stupid syntax error” at http://hpaste.org/47822
15:26:14 <mauke> preflex: msg #haskell http://pastebin.com/xUJLX9MM
15:26:14 <preflex> http://pastebin.com/xUJLX9MM
15:26:15 <Twey> … int80_h is not here
15:26:16 <mauke> The paste xUJLX9MM has been copied to http://hpaste.org/47823
15:26:31 <hpaste> chrisdone annotated “find my stupid syntax error” with “here it is” at http://hpaste.org/47822#a47824
15:26:41 <chrisdone> int80_h: http://hpaste.org/diff/47822/47824
15:26:42 <int80_h> http://hpaste.org/47822
15:26:45 <kmc> > let concat = (>>- id) in concat [[('a',x),('b',x)] | x <- [1..]]
15:26:46 <lambdabot>   [('a',1),('a',2),('b',1),('a',3),('b',2),('a',4),('b',3),('a',5),('b',4),('...
15:26:46 <hpaste> Twey annotated “find my stupid syntax error” with “find my stupid syntax error (annotation)” at http://hpaste.org/47822#a47825
15:26:48 <int80_h> hah
15:26:49 <ski> kmc : in Prolog `( Condition -> Consequent ; Alternate )' is comparable to `if Condition then Consequent else Alternate' in Haskell, the former being logically equivalent to `( Condition,Consequent ; \+ Condition,Alternate )', but only executes `Condition' once
15:26:53 <kmc> > Prelude.concat [[('a',x),('b',x)] | x <- [1..]]
15:26:53 <lambdabot>   [('a',1),('b',1),('a',2),('b',2),('a',3),('b',3),('a',4),('b',4),('a',5),('...
15:26:58 <wyfrn> hey guys ... is anybody familar with the System.Console.Haskeline module?
15:26:59 <Twey> int80_h: It's ‘import’, not ‘include’.
15:27:20 <ski> kmc : more specifically, this is true with one caveat : `Condition' can only have at most one solution
15:27:29 <chrisdone> @faq Can Haskell bestow its users the ability to predict the future, in an annoyingly narrow perspective (that of problem pastes)?
15:27:29 <lambdabot> The answer is: Yes! Haskell can do that.
15:27:31 <Twey> int80_h: This isn't C :þ
15:27:36 <int80_h> thanks. This is what slepp deprevation does.
15:27:39 <Twey> Heh
15:27:41 <Twey> chrisdone: Haha
15:28:01 <ski> kmc : some Prologs have variants of this construct where this restriction on `Condition' is lifted, this is typically called "soft cut" (i don't know the reason)
15:28:09 <chrisdone> @remember int80_h thanks. This is what slepp deprevation does.
15:28:09 <lambdabot> Okay.
15:28:51 <Twey> Haha :-D
15:28:53 <kmc> chrisdone, you forgot to build with ghc --make
15:28:54 <kmc> ;)
15:29:02 <Twey> Slepp deprevation always gets me.
15:29:07 <int80_h> booo!
15:29:31 <chrisdone> kmc: Ex-squeeze me? :o
15:29:37 <ski> kmc : i would assume that in `MonadLogic', there's an operation `cond :: MonadLogic m => m a -> (a -> m b) -> m b -> m b' such that `cond condition consequent alternate' will execute `consequent' (passing along every solution of `condition' each at a time) iff `condition' has at least one solution, otherwise it executes `alternate' instead
15:30:52 <kmc> chrisdone, a joke about predictable error pastes
15:31:04 <guerrilla> is there a way to make "fail" work with UTF-8 strings.. such as "μ"?
15:31:24 <monochrom> fail "μ"
15:31:48 <guerrilla> its not outpitting correctly for me for some reason
15:31:53 <chrisdone> kmc: Ohhhhhhh ヽ(´ー｀)ﾉ
15:32:11 <monochrom> "UTF-8 strings" may reflect misconceptions. see http://www.joelonsoftware.com/articles/Unicode.html
15:32:38 <guerrilla> monochrom: no, i mean that they are encoded in utf-8 in the .hs file.
15:32:53 <guerrilla> i have no idea how they're stored internally by GHC
15:32:55 <Twey> Heh
15:33:05 <monochrom> yes, they are in UTF-8 in .hs files
15:33:30 <monochrom> internally a Char is a Unicode code point already
15:33:39 <Twey> The other day I was talking to a programmer about combining characters and RTL text, and they said ‘oh, I've never needed to use those so I don't know’
15:33:48 <Twey> I became worried
15:34:19 <chrisdone> He doesn't know what?
15:34:29 * ski wonders what "RTL" is
15:34:35 <kmc> right to left
15:34:40 <monochrom> resistor transfer logic
15:34:43 <guerrilla> in any case,         fail "μ"
15:34:45 <Twey> ski: ‘Right-To-Left’, e.g. Arabic
15:34:46 <guerrilla>  doesn not work for me
15:34:46 <kmc> register transfer language
15:34:53 <guerrilla> Test: user error (�)
15:34:59 <monochrom> err, resistor transistor logic
15:35:02 <kmc> guerrilla, which version of GHC?
15:35:07 <guerrilla> (unicode displays fine, outputting from putStrLn
15:35:10 <guerrilla> kmc: 1sec...
15:35:15 <kmc> and do your locale environment variables agree with your terminal's settings?
15:35:17 <guerrilla> kmc: 6.12.3
15:35:25 <guerrilla> guerrilla@delta:/tmp/foo$ env | grep LC_
15:35:25 <guerrilla> LC_MESSAGES=pt_BR.UTF-8
15:35:34 <guerrilla> like i said, it works for putStrLn
15:35:44 <kmc> can you pipe your error into hexdump?
15:35:55 <pankajk> hi doston
15:36:08 <guerrilla> kmc, just a sec, i'll hpaste that
15:36:17 <monochrom> works here in ghci, both 7.0.3 and 6.12.3
15:36:50 <guerrilla> monochrom: ok thanks for confirming that.. may be something funky going on with my installation
15:37:25 <monochrom> alright, breaks if in a file and runghc'ed
15:37:30 <guerrilla> kmc: http://hpaste.org/47826
15:37:42 <monochrom> yes, breaks if in a file and compiled, too
15:37:59 <guerrilla> yeah, i am doing it through compilation
15:38:10 <monochrom> but if loaded and invoked inside ghci, it is correct
15:38:31 <guerrilla> weird
15:38:39 <guerrilla> even with 7.0.3?
15:39:11 <monochrom> even with 7.0.3
15:39:32 <monochrom> bug in the exception printing code
15:39:41 <guerrilla> encoding it as hex works
15:39:59 <guerrilla>         fail "\xce\xbc"
15:40:01 <guerrilla> for example
15:40:19 <guerrilla> im thinking it may not be printing, but internalising
15:40:51 <monochrom> the exception printing code is obviously still using the old iso-latin-1 convention
15:41:03 <guerrilla> an ideas on how to work around it? (I'll file a bug later)
15:41:23 <monochrom> you know, a long time ago, ghc assumed iso-latin-1 universally. a lot of that old code may still haven't been exorcised
15:41:39 <guerrilla> monochrom: i did read that
15:42:26 <guerrilla> ok, so         fail (encodeString "μ")
15:42:29 <guerrilla> is the workaround btw
15:42:31 <monochrom> yeah
15:42:39 <monochrom> until the bug is fixed
15:42:39 <guerrilla> safe enough for my usage...
15:42:45 <guerrilla> yeah, i'll file now.
15:43:26 <guerrilla> um, actually, where do you do that? i've never done so for GHC
15:43:38 <kmc> you can go to #ghc ;)
15:43:46 <kmc> but there's a Trac instance
15:43:53 <kmc> http://hackage.haskell.org/trac/ghc/
15:43:54 <guerrilla> kmc: just found it.. finally :)
15:44:10 <monochrom> log in as guest or create your own account
15:44:26 <guerrilla> yep yep, i got it from here monochrom thanks
15:45:05 <guerrilla> apparently getArgs has a similar issue btw (while i was searching to see if this is already known)
15:45:36 <monochrom> getArgs is more difficult because windows and linux feed different encodings to you
15:45:43 <wyfrn> hey guys ... is anybody familar with the System.Console.Haskeline module?
15:45:59 <monochrom> but the exception printer has no excuse
15:46:00 <kmc> i'm not, but you should probably just ask your question
15:46:03 <kmc> wyfrn, ^
15:47:31 <wyfrn> i wonder if there is a way to use several history contexts with haskeline ...
15:47:32 <monochrom> in fact the C or posix interface specifies only a bunch of bytes for args and environment variables
15:50:03 <guerrilla> monochrom: if this is for my benefit, i do happen to know all this
15:50:23 <guerrilla> no offense intended
15:54:47 <guerrilla> monochrom, kmc: thanks.
16:09:37 <eddayyy> how do you destructure on an object with a huge amount of fields?
16:09:47 <kmc> record syntax?
16:09:49 <eddayyy> (without doing (Object a b c d e f g ...) whilst pattern matching)
16:10:24 <eddayyy> kmc: can you pattern match on record syntax?
16:10:38 <hpc> eddayyy: indeed
16:10:59 <hpc> field f{fieldName = fieldValue} = fieldValue
16:11:12 <hpc> er, field F
16:11:14 <eddayyy> hpc: so something like toJSON (AuthUser { f1 = ..., }) = rgs ?
16:11:20 <hpc> yeah, like that
16:11:30 <eddayyy> nice, thanks
16:11:31 <eddayyy> :)
16:11:38 <hpc> you can get even quirkier, if you want
16:11:44 <hpc> you can match a constructor only
16:11:55 <hpc> consOnly ASDF{} = stuff
16:12:00 <eddayyy> hpc: eh? how do you get the fields then? :D
16:12:10 <hpc> eddayyy: this is unrelated ;)
16:12:26 <hpc> > let f Right{} = "yay" in f (Right 5)
16:12:27 <lambdabot>   "yay"
16:12:37 <hpc> :t let f Right{} = "yay" in f
16:12:38 <lambdabot> forall t t1. Either t t1 -> [Char]
16:12:57 <eddayyy> hpc: awesome
16:13:48 <hpc> there's some ghc extensions that deal with record patterns too
16:13:48 <eddayyy> hpc: however you're not getting the field of Right there right?
16:13:57 <hpc> eddayyy: no, you ignore it
16:14:12 <hpc> the convenience there is that you can add more things to Right, without worrying about that pattern
16:14:20 <hpc> as opposed to Right _ _ _ ...
16:14:46 <eddayyy> hpc: oh right, cool
16:15:28 <hpaste> int80_h pasted “how to bind a 4 element  tuple” at http://hpaste.org/47829
16:15:50 <int80_h> ah, hpaste beat me
16:17:12 <gfarfl> int80_h: you mean like: foo <- createProcess ... ?
16:17:22 <benmachine> int80_h: foo@(_, Just hout, _, _)?
16:17:32 <Twey> int80_h: You want *all* of them in ‘foo’?  As a tuple?
16:17:41 * benmachine pokes Twey 
16:17:49 * Twey pokes benmachine.
16:18:06 <benmachine> hi I was going to talk to you about network
16:18:16 <benmachine> but iono if I should talk to tibbe first actually
16:18:35 <benmachine> preflex: seen tibbe
16:18:35 <preflex>  tibbe was last seen on #ghc 3 hours, 34 minutes and 44 seconds ago, saying: is it possible to create file links into the repo on the Trac wiki?
16:18:49 <int80_h> benmachine : thanks that's it
16:19:06 <int80_h> Twey: No just the second element
16:19:22 <int80_h> Twey: what benmachine gave does that right?
16:19:33 <benmachine> let us demonstrate by example
16:19:44 <benmachine> > let foo@(_, 2, _, _) = (1,2,3,4) in foo
16:19:45 <lambdabot>   (1,2,3,4)
16:20:02 <int80_h> > foo
16:20:04 <lambdabot>   *Exception: In scope: `foo'
16:20:11 * benmachine blinks
16:20:22 <benmachine> lambdabot are you screwing with me again :(
16:20:24 <int80_h> benmachine: What was that supposed to demonstrate?
16:20:32 <int80_h> let me try that in ghci
16:20:51 <benmachine> int80_h: what foo gets bound to if you use foo@(_, Just hout, _, _) as a pattern
16:20:54 <Twey> int80_h: What benmachine gave binds the whole tuple to ‘foo’ (as well as matching the second element against ‘Just hout’)
16:21:10 <benmachine> :t foo
16:21:11 <lambdabot> forall a. a
16:21:46 <ion> > let foo@(_, x@2, _, _) = (1,2,3,4) in (foo, x)  -- does this work, btw?
16:21:47 <lambdabot>   ((1,2,3,4),2)
16:24:07 <ion> > let a@(b@(c@(d@(e@(f,_),_),_),_),_) = (((((0,1),2),3),4),5) in (a,b,c,d,e,f)
16:24:08 <lambdabot>   ((((((0,1),2),3),4),5),((((0,1),2),3),4),(((0,1),2),3),((0,1),2),(0,1),0)
16:24:24 <int80_h> benmachine: well I suppose I could just then grab the second element from that tuple
16:24:37 * hackagebot hR 0.1 - R bindings and interface  http://hackage.haskell.org/package/hR-0.1 (DylanSimon)
16:24:40 <int80_h> all I need is the second element
16:24:45 <benmachine> int80_h: I don't get it, you're already matching against the second element of the tuple
16:25:20 <int80_h> benmachine: but if foo gets bound to every element, what happens with the matched patern?
16:25:36 <benmachine> int80_h: I don't understand that question at all
16:25:50 <int80_h> okay I think I'm confused by what you did, let me re-read
16:26:12 <int80_h> 16:49 < Twey> int80_h: What benmachine gave binds the whole tuple to âfooâ (as well as matching the second element against âJust houtâ)
16:26:25 <int80_h> so what you did binds the whole tuple to foo
16:26:31 <benmachine> yes
16:26:44 <int80_h> so foo is now (bar,baz,bin,boo)
16:27:26 <int80_h> if I just wanted baz bound to foo, what does the pattern matching accomplish?
16:27:43 <ion> (_,foo,_,_)
16:28:20 <eddayyy> thinking of releasing a lib soon
16:28:32 * eddayyy is excited
16:30:36 <gfarfl> int80_h: I'm confused. Do you want the tuple or not?
16:30:55 <int80_h> gfarfl: I do not. I just want the second element
16:31:21 <gfarfl> int80_h: then there is no need to modify your example. The second element is bound to hout
16:31:55 <int80_h> gfarfl: oh! I didn't recognize that syntax at all. I thought somethign was being left out
16:32:28 <gfarfl> int80_h: the pattern matching means that hout is a Handle instead of a Maybe Handle
16:32:59 <int80_h> thank you! :)
16:54:04 <b930913> Given x=50, and l is a list of integers, how do I remove all integers in l that satisfy x mod l != 0?
16:55:06 <ben> filter?
16:55:11 <ben> @type filter
16:55:12 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
16:55:20 <kmc> b930913, you might find it easier to write as a list comprehension
16:55:54 <Nimatek> I like list comprehenstions: [n | n <- l, n `mod` x /= 0]
16:56:18 <ben> == surely
16:56:30 <Nimatek> Oh, yes. 'remove'
16:56:32 <Nimatek> Sorry.
16:57:53 <b930913> Nimatek: Where did n come from?
16:57:54 <kmc> filter ((/= 0) . (`mod` x)) l
16:58:05 <ski> Nimatek : i assume you swapped `x' and `n' by mistake ..
16:58:41 <ski> b930913 : if `l' is a list, then `x mod l' doesn't make sense, but if `n' is a number in that list, `x mod n' makes sense
16:58:49 <kmc> :t (`mod` x) >>> (=/ 0)
16:58:49 <lambdabot> Not in scope: `=/'
16:58:52 <kmc> :t (`mod` x) >>> (/= 0)
16:58:53 <lambdabot> Expr -> Bool
16:58:57 <kmc> :t (`mod` 3) >>> (/= 0)
16:58:58 <lambdabot> forall a. (Integral a) => a -> Bool
16:59:02 <Nimatek> b930913: It gets newly defined in the list comprehension.
17:02:00 <b930913> Meh, I miss the whole point of haskell methinks.
17:02:05 <kmc> how so?
17:02:34 <b930913> Whatever the explanation given, I never get it or the answer.
17:02:56 <kmc> do you know what list comprehensions are?
17:03:14 <b930913> Nope.
17:03:22 <kmc> then you could read about that
17:03:28 <kmc> when we give explanations involving this unfamiliar term
17:03:43 <Axman6> > [x+y | x <- [1,2,3], y <- [10,20,30]]
17:03:44 <lambdabot>   [11,21,31,12,22,32,13,23,33]
17:04:16 <b930913> kmc: Then I don't understand that either.
17:05:00 <Nimatek> > [n | n <- [1..10], 50 `mod` n == 0]
17:05:01 <lambdabot>   [1,2,5,10]
17:05:09 <kmc> b930913, why not?
17:05:28 <kmc> b930913, step back a bit: how are you learning Haskell? and why?
17:05:40 <monqy> > filter ((50 `mod`) >>> (== 0)) [1..10]
17:05:40 <lambdabot>   [1,2,5,10]
17:05:56 <kmc> if the explanation of "list comprehension" contains another unfamiliar term, you can look that up, or ask for it here
17:06:12 <Axman6> > let divs n = [ x | x <- [1..n], n `rem` x == 0] in divs 121
17:06:13 <lambdabot>   [1,11,121]
17:06:22 <Axman6> > let divs n = [ x | x <- [1..n], n `rem` x == 0] in divs 144
17:06:23 <lambdabot>   [1,2,3,4,6,8,9,12,16,18,24,36,48,72,144]
17:06:38 <Axman6> > let divs n = [ x | x <- [1..n], n `rem` x == 0] in divs (product [1..10])
17:06:39 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,12,14,15,16,18,20,21,24,25,27,28,30,32,35,36,40,42,45...
17:07:02 <hpc> b930913: in general, a list comprehension takes the form [expression | var <- list, var <- list, ..., filter, filter, ...]
17:07:59 <Nimatek> This is a good explanation, http://learnyouahaskell.com/starting-out#im-a-list-comprehension
17:08:00 <hpc> b930913: what ends up happening is that it tries every possible combination of things taken from each list, then outputs a list
17:08:42 <hpc> to take a concrete example, [(x, y - x) | x <- [1,2,3], y <- [4,5,6], even y]
17:09:03 <hpc> b930913: it will try x = 1, y = 4; x = 1, y = 5, etc
17:09:26 <hpc> b930913: it will skip a combination if any of the filters evaluate to false
17:09:44 * b930913 thinks ASM is easy compared to this.
17:09:52 <hpc> b930913: if it all works out, it evaluates the expression using the current combination, then puts it in the list
17:10:25 <hpc> > [(x, y - x) | x <- [1,2,3], y <- [4,5,6], even y]
17:10:26 <lambdabot>   [(1,3),(1,5),(2,2),(2,4),(3,1),(3,3)]
17:10:43 <gwern> @wn dialectician
17:10:45 <lambdabot> *** "dialectician" wn "WordNet (r) 2.0"
17:10:45 <lambdabot> dialectician
17:10:45 <lambdabot>      n : a logician skilled in dialectic
17:11:13 <hpc> > [(x, y) | x <- [1,2,3], y <- [4,5,6], even y] -- better example
17:11:13 <lambdabot>   [(1,4),(1,6),(2,4),(2,6),(3,4),(3,6)]
17:11:35 <hpc> b930913: does that make sense?
17:12:05 <b930913> hpc: Excepting the pipe and the "even y".
17:12:39 <nanothief> I have a data type that takes a lot of type variables, ie data MyData a b c d e f g = ... . Are there any techniques I could use to simplify this?
17:12:48 <hpc> b930913: i will start with the 'even y' part first
17:12:56 <hpc> b930913: imagine the "identity comprehension"
17:13:06 <b930913> Thewah?
17:13:06 <hpc> > [x | x <- [1..5]] -- b930913
17:13:07 <lambdabot>   [1,2,3,4,5]
17:13:16 <hpc> > [x | x <- [1, 2, 3, 4, 5]] -- b930913
17:13:16 <lambdabot>   [1,2,3,4,5]
17:13:32 <hpc> b930913: it takes a list and does nothing with it
17:13:50 <b930913> >[1..5]
17:13:58 <b930913> > [1..5]
17:13:59 <lambdabot>   [1,2,3,4,5]
17:14:15 <b930913> What does your line do that my line doesn't?
17:14:21 <hpc> b930913: nothing
17:14:31 <kmc> b930913, how are you learning Haskell? and why?
17:14:36 <hpc> it's a starting point
17:14:40 <benmachine> kmc: why not? :P
17:14:48 <hpc> b930913: now we don't actually want every element of that list
17:14:53 <hpc> we only want even numbers
17:14:55 <hpc> > even 5
17:14:56 <lambdabot>   False
17:14:59 <hpc> > even 16
17:15:00 <lambdabot>   True
17:15:21 <b930913> kmc: I kind of gave up after people kept referring me to URLs I had said I didn't understand.
17:15:23 <Twey> [x | x <- xs] = map id xs
17:15:27 <hpc> we could filter the list like this:
17:15:41 <hpc> > filter even [1..5]
17:15:42 <lambdabot>   [2,4]
17:15:55 <hpc> or we could filter it with a comprehension
17:16:09 <hpc> > [x | x <- [1,2,3,4,5], even x]
17:16:09 <benmachine> Twey: is that equation particularly more enlightening than concatMap return xs?
17:16:09 <lambdabot>   [2,4]
17:16:24 <hpc> the list will only contain elements for which "even x" is true
17:16:45 <kmc> b930913, then why are you here?
17:17:00 <kmc> if you've given up and are taking a negative defeatist attitude toward everything
17:17:33 <b930913> kmc: On the off chance that people are more helpful at this time of day.
17:18:05 <b930913> hpc: The comma separates conditions?
17:18:11 <hpc> b930913: indeed
17:18:54 <kmc> b930913, you can't just read a document, reach something you don't understand, and give up
17:19:27 <benmachine> kmc: he does seem to be trying
17:19:30 <b930913> > sum [x | x <- [3,6..1000], `x` mod 3 == 0]
17:19:31 <lambdabot>   <no location info>: parse error on input ``'
17:19:34 <kmc> i'm not saying he/she isn't
17:19:46 <benmachine> he/she, yes
17:19:50 * benmachine bad at pronouns sometimes
17:19:57 <kmc> but you will not get very far in haskell with this approach
17:20:01 <kmc> or in anything academic really
17:20:08 <hpc> > sum [x | x <- [3,6..1000], x `mod` 3 == 0]
17:20:08 <lambdabot>   166833
17:20:25 <benmachine> kmc: sure but are you going to have your life turned around by someone on an IRC channel? I'd focus on the problems we can fix :)
17:20:33 <b930913> Did I really put the backticks on the wrong word? :s
17:20:41 <kmc> if you encounter something confusing, you have to find some other document explaining that thing, or ask about that in particular
17:20:46 <kmc> or re-read it until it makes sense
17:20:57 <benmachine> b930913: if it's easier for you, you can write it (mod x 3 == 0) without any backticks at all
17:21:01 <hpc> b930913: you should see the mistakes i have made...
17:21:20 <hpc> in fact... https://code.google.com/p/hs-svg/source/detail?r=10
17:21:23 <benmachine> b930913: the backticks are just a way of writing the function in the middle, in some cases this reads more naturally but it's entirely optional
17:21:31 <b930913> benmachine: I'm used to the infix operator, so I'll probably stick with that :p
17:21:36 <Nimatek> Haskell syntax is a bit subtle, with all the whitespace.
17:22:05 <b930913> Nimatek: It's worse with all the variables that spring out of nowhere..
17:22:14 <kmc> they don't spring out of nowhere
17:22:24 <hpc> they kind of do, in list comprehensions
17:22:29 <hpc> or they look like they do
17:22:29 <kmc> they get defined, sometimes to the right of where they're used
17:22:57 <kmc> benmachine, how should people get over learning-how-to-learn problems, if teaching them is a waste of time?
17:23:01 <hpc> the way you read comprehensions is unusual, even for how haskell does things
17:23:22 <Nimatek> b930913: It may help to imagine you're doing math on a paper. That's more Haskell-y.
17:23:29 <kmc> Haskell mimics maths notation in a number of places, which can  be unusual if you're not familiar with maths notation
17:23:42 <kmc> however i will note that Python and other languages do list comprehensions in the same order
17:23:48 <benmachine> kmc: either learning lessons on their own, or being taught by teachers/whoever
17:23:56 <kmc> and also that Haskell's "do" syntax basically lets you write list comprehensions in the other order
17:24:00 <kmc> benmachine, oh, we're not teachers?
17:24:10 <benmachine> kmc: we're more... advisors?
17:24:16 <hpc> do-notation is skipping a few concepts, i think
17:24:19 <benmachine> kmc: we can't give you a bad grade if you don't listen :P
17:24:27 <hpc> tutors
17:24:37 <kmc> hpc, i agree, i was just anticipating the inevitable "haskell is dumb because it's too mathy" response
17:24:40 <benmachine> yeah, that's how I look at it
17:24:41 <hpc> unpaid occasionally-trolled temp tutors
17:24:51 <Evious> Paid in ego boosts.
17:24:55 <hpc> :D
17:25:04 <Evious> "Ohmygodohmygodohmygod people are listening to what I say :D"
17:25:06 <blackdog> kmc: i sometimes get the "haskell is dumb because it's too irregular", which i sorta understand
17:25:12 <blackdog> liskell is an interesting take...
17:25:13 <b930913> > [x | x <- [3,5..80000000], 600851475143 `mod` x == 0]
17:25:13 <benmachine> Evious: that always creeps me out :<
17:25:16 <lambdabot>   mueval-core: Time limit exceeded
17:25:26 <benmachine> "oh goodness I am an authority on something what do I doooo"
17:25:36 <b930913> > [x | x <- [3,5..800000], 600851475143 `mod` x == 0]
17:25:37 <lambdabot>   [71,839,1471,6857,59569,104441,486847]
17:26:05 <Nimatek> The mathy part is part what drew me to Haskell. Instead of thinking how to do something, you just define the result :p
17:26:14 <Nimatek> part of*
17:26:34 <kmc> yeah, declarative programming is very nice
17:26:39 <hpc> b930913: so the other half of your confusion was the business with what goes left of the "|", yes?
17:27:36 <b930913> hpc: I think I've got it now.
17:27:44 <hpc> cool
17:27:49 <b930913> \= == != right?
17:27:59 <hpc> > 1 /= 2
17:27:59 <lambdabot>   True
17:28:04 <hpc> > 1 /= 1
17:28:05 <lambdabot>   False
17:28:10 <hpc> indeed
17:28:31 <b930913> No, forward slash is :p
17:28:37 <hpc> :P
17:28:39 <b930913> > 5\3
17:28:40 <lambdabot>   <no location info>: parse error on input `\'
17:28:54 <hpc> so that's one concept down, only a million more to go!
17:28:59 <b930913> Hmm, some languages \ means mod I think.
17:30:09 <sevenfive> hi
17:30:16 <kmc> hi sevenfive
17:30:25 <kmc> @let (\=) = (/=)
17:30:26 <lambdabot>  Defined.
17:30:27 <sevenfive> i'm trying to make a simple game
17:30:31 <Nimatek> > :t (%)
17:30:32 <lambdabot>   <no location info>: parse error on input `:'
17:30:38 <hpc> :t (%)
17:30:39 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
17:30:44 <sevenfive> i want to do something as soon as the player presses an arrow key
17:30:59 <sevenfive> but it seems like they always have to press enter first
17:31:02 <sevenfive> oh its a command line thing
17:31:06 <sevenfive> on mac os x
17:31:27 <hpc> hSetBufferMode NoBuffering stdin?
17:31:36 <hpc> or something like that
17:31:42 <sevenfive> hm
17:31:45 <sevenfive> ok
17:32:00 <Axman6> what sort of game is it?
17:32:03 <kmc> or you could use a real terminal library like hscurses or vty
17:32:23 <benmachine> I recommend a real terminal library
17:32:29 <benmachine> I used hscurses once it was ok
17:32:35 <sevenfive> terminal library?
17:33:05 <hpc> sevenfive: it's kind of like a graphics library, for terminals
17:33:13 <hpc> you tell it where to put text, how to color it, whatever
17:33:21 <sevenfive> ooo
17:33:22 <sevenfive> ok
17:33:36 <sevenfive> thanks
17:34:56 <b930913> hpc: Come to ##930913 so I can discuss application without giving away the answer to a well known math puzzle?
17:38:10 <azaq23> > (fromRational (2 % 4) :: Float, 2 `mod` 4)
17:38:11 <lambdabot>   (0.5,2)
17:50:57 <hpc> :t div
17:50:58 <lambdabot> forall a. (Integral a) => a -> a -> a
17:51:00 <hpc> :t (/)
17:51:00 <lambdabot> forall a. (Fractional a) => a -> a -> a
17:54:35 <hpc> :t mod
17:54:35 <lambdabot> forall a. (Integral a) => a -> a -> a
17:55:26 <b930913> > 5 3 ``div``
17:55:27 <lambdabot>   <no location info>: parse error on input ``'
17:55:36 <b930913> Can't postfix it then? :p
17:56:33 <benmachine> :P
17:58:44 <b930913> hpc: Thanks for you help :)
17:58:59 <hpc> no problem
18:06:43 * hackagebot simple-sendfile 0.0.1 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.0.1 (KazuYamamoto)
18:19:37 <joe6> i have a list of functions and I want to give each function the random generator. Any suggestions on how I can do that?
18:23:15 <dankna> :t sequenceM
18:23:16 <lambdabot> Not in scope: `sequenceM'
18:23:18 <dankna> :t sequence
18:23:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
18:23:29 <djahandarie> :t Data.Traversable.sequenceA
18:23:30 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
18:23:31 <dankna> joe6: seems relevant
18:26:18 <joe6> thanks
18:38:52 <joe6> any suggestions on how I can incorporate the sequenceA here:  http://sprunge.us/QUVa
18:40:36 <joe6> i am using map to run a list of tests. I want to string the random generator between each of those functions. I cannot figure out how to use the sequenceA in this context.
18:41:58 <djahandarie> @ty Data.Traversable.sequenceA :: [a -> b] -> (a -> [b]) -- is all dankna meant. Not sure what your precise problem is
18:41:59 <lambdabot> forall a b. [a -> b] -> a -> [b]
18:42:25 <joe6> djahandarie: i have this:              , TestList
18:42:25 <joe6>                . map (TestList . checkWithDiffValues hin hout)
18:42:28 <joe6>                $ whichTests
18:42:40 <joe6> sorry, let me put it on one line
18:43:52 <joe6> I have this: TestList . map (TestList . checkWithDiffValues hin hout) $ tests, and I want to send the randomgenerator through each of these tests..
18:45:24 <joe6> djahandarie: does that make sense?
18:45:43 <joe6> i have a list of tests, which I run with a function checkWithDiffValues
18:45:58 <joe6> this function takes the test and runs the function with different values.
18:46:40 <joe6> i am trying to figure out if there is a smart way of making this function thread the randomgenerator, without making it a recursive function.
18:47:44 <djahandarie> Why would you want to do that? You will always get the same generator with getStdGen, provided you don't call newStdGen.
18:47:50 <joe6> i could make the checkWithDiffValues (gen::StdGen) hin hout
18:48:43 <joe6> so, any function that uses a randomGenerator has to be a recursive function?
18:48:57 <djahandarie> I'm not sure how recursion is involved.
18:49:12 <b930913> I'm trying to get a list of all even multiples of three, help? [x | x <- [2,4..100], ( /3)==0]
18:49:36 <djahandarie> joe6, remove the line    gen' <- newStdGen   in checkWithDiffValues. You will now always be using the same StdGen.
18:49:37 <luite> all even multiples of three are multiples of six ;p
18:49:53 <b930913> luite: The problem gets bigger, dw ;)
18:50:11 <sbahra> > [6, 12 ..]
18:50:12 <lambdabot>   [6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96,102,108,114,120,126,132,138...
18:50:23 <luite> b930913: you're looking for (`mod` 3)
18:50:24 <joe6> djahandarie: I want to use different values?
18:50:30 <joe6> is that what I have?
18:50:52 <luite> b930913: or actually, x `mod` 3 == 0
18:51:10 <b930913> luite: Ah, thanks.
18:51:49 <joe6> djahandarie: i want to use different values and not the same values
18:51:53 <Jafet> joe6: if you don't want to use continuation-passing style (“recursion”), you can thread the generator through a State or ST, or RandomT or whatever it's called
18:52:45 <Jafet> You can also split the generator for every test
18:52:52 <joe6> Jafet, oh, ok. thanks.
18:54:04 <djahandarie> joe6, it would have the same results. Passing the same generator along would do the same thing.
18:55:35 <djahandarie> The StdGen is already stored as 'state' in IO. Wrapping another layer of State on top of it would be useless.
18:56:15 * Jafet decides to actually read the testcase, to see what all the fuss is about
18:56:48 <liyang> GHC7's complaining that it can't UNPACK an Unboxed.Vector in a record, even though I'm sure I saw performance benefits with it under GHC 6. Does anyone know anything about this? :-/
18:56:51 <b930913> How could I do x `mod` [3,4,5]?
18:56:55 <joe6> is there some function that can do infinite splitAt: splitAt :: Int -> [a] -> [[a], [a],[a].....]
18:57:11 <liyang> b930913: map (x `mod`) [3,4,5]
18:57:12 <joe6> is there some function that can do infinite splitAt: with a function signature of .. Int -> [a] -> [[a], [a],[a].....]
18:57:15 <djahandarie> joe6, why would it result in more than one list?
18:57:22 <djahandarie> And , makes no sense on the type level
18:57:36 <joe6> i want to break a list into many sublists
18:57:37 <Jafet> If you're using IO, you can just dispense with all this threading and use randomIO
18:57:39 <djahandarie> You likely just want [[a]].
18:57:44 <Jafet> :t randomRIO
18:57:45 <lambdabot> forall a. (Random a) => (a, a) -> IO a
18:57:58 <liyang> joe6: iterate (take n)
18:58:10 <joe6> Jafet, will check out randomIO. I think that is what I need.
18:58:15 <djahandarie> joe6, yes, but splitAt only gives one splitting point. If you want 'splitEvery' then see what liyang said.
18:58:24 <b930913> liyang: And if that is iterated fast, would it be considerably slower than unwrapping it?
18:58:31 <djahandarie> You can also use, literally, splitEvery from Data.List.Split
18:58:33 <joe6> liyang: yes, that is what I need.
18:58:59 <aavogt> > iterate (take 1) "liyang"
18:59:00 <lambdabot>   ["liyang","l","l","l","l","l","l","l","l","l","l","l","l","l","l","l","l","...
18:59:16 <liyang> Hm? Oops.
18:59:39 <liyang> splitAt and map fst then. ^^;;
18:59:40 <Eduard_Munteanu> > iterate (drop 1) "liyang"
18:59:41 <lambdabot>   ["liyang","iyang","yang","ang","ng","g","","","","","","","","","","","",""...
18:59:48 <Jafet> > unfoldr (\x -> if null x then Nothing else Just (splitAt 1 x)) "liyang"
18:59:49 <lambdabot>   ["l","i","y","a","n","g"]
18:59:59 <aavogt> > map fst $ iterate (splitAt 2 . snd) ("","liyang")
19:00:00 <lambdabot>   ["","li","ya","ng","","","","","","","","","","","","","","","","","","",""...
19:00:52 <Eduard_Munteanu> > iterate (take 1 . drop 1) "liyang"
19:00:53 <lambdabot>   ["liyang","i","","","","","","","","","","","","","","","","","","","","","...
19:01:11 <joe6> Jafet: randomRIO is a very good idea. Exactly what I need.
19:01:23 <aavogt> an unfoldr is probably cleaner for the splitting
19:01:23 <joe6> does it generate different values evrytime I use it?
19:01:48 <liyang> stop trying to splice me into pieces. ;_;
19:02:20 <aavogt> > unfoldr (\x -> case splitAt 2 x of ("","") -> Nothing; a -> Just a) "liyang"
19:02:21 <lambdabot>   ["li","ya","ng"]
19:02:25 <joe6> Jafet: it seems to, when I try it in the ghci prompt.
19:02:33 <djahandarie> Data.List.Split> splitEvery 2 "liyang"
19:02:34 <djahandarie> ["li","ya","ng"]
19:02:43 <b930913> liyang: It throws some error when I try your map.
19:03:00 * liyang isn't having a good morning
19:03:52 <djahandarie> > take 2 .: takeWhile (not . null) . iterate (drop 2) $ "liyang"
19:03:54 <lambdabot>   ["li","ya","ng"]
19:03:59 <liyang> > map (42 `mod`) [3,4,5]
19:04:00 <lambdabot>   [0,2,2]
19:04:12 <djahandarie> liyang, switch countries, then it'll be night!
19:07:58 <djahandarie> liyang, well, vector switched to a data family at one point. But that was awhile back, not sure if that's the issue or not.
19:10:24 <liyang> djahandarie: this is with the data family version...
19:11:05 <liyang> Admittedly, ghc6 didn't even complain when you write data Foo a = Foo {-# UNPACK #-} !a
19:15:02 <djahandarie> It uses newtype instances, and those are hardly ironed out. Not sure the unpacker would even see through them...
19:25:17 <djahandarie> liyang, is it telling you "Ignoring unusable UNPACK pragma on the first argument of ... ?"
19:26:04 <djahandarie> Or xth argument, whatever
19:27:09 <b930913> $ cabal update
19:27:11 <b930913> Downloading the latest package list from hackage.haskell.org
19:27:13 <b930913> cabal: <file descriptor: 5>: resource exhausted
19:27:15 <b930913> :?
19:29:37 <djahandarie> liyang, I see no reason you shouldn't be able to unpack through newtype instances, I would submit a bug report. However, even data instances don't support being unpacked yet IIRC, so I wouldn't expect this to get done too fast. :p Though the Vector use case could make it happen faster.
19:31:08 <zuserm> does anyone have experience using the plugins package?
19:31:16 <liyang> djahandarie: in my use I think I saw a ~10% speed improvement by unpacking an unboxed 6-tuple of Doubles
19:31:44 <hpaste> djahandarie pasted “data family unpacking” at http://hpaste.org/47830
19:32:24 <djahandarie> liyang, that paste is basically what's happening here as far as I can tell. Could submit something to the GHC trac
19:33:37 <liyang> djahandarie: Yup, looks about right. Thanks for the example.
19:34:38 <robinhoode> What do you call the symbol for join? (>>=) Just join?
19:34:45 <robinhoode> I've seen it called a 'fish' before..
19:34:48 <djahandarie> robinhoode, that isn't join. It's sometimes called bind.
19:34:50 <liyang> djahandarie: Shall I file a ticket, or are you going to do that?
19:35:01 <robinhoode> djahandarie: Doh, you're right..
19:35:01 <djahandarie> liyang, you can do it, I'm not that interested. :p
19:35:07 <liyang> <>< is a fish.
19:35:17 <liyang> djahandarie: just checking. :3
19:35:45 <djahandarie> robinhoode, though, often, bind = flip (>>=)
19:36:02 <djahandarie> But I call it bind anyways.
19:37:26 <azaq23> @src join
19:37:27 <lambdabot> join x =  x >>= id
19:38:25 <b930913> How can I get [[1,2,3],[2,3,4],[3,4,5],[4,5,6]] given [1,2,3,4,5,6] ?
19:39:44 <lispy> hello
19:41:04 <lispy> > (\xs -> zipWith3 (\x y z -> [x,y,z]) xs (tail xs) (tail (tail xs))) [1..6]
19:41:05 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6]]
19:41:31 <robinhoode> So another monad trivia question for someone trying to reach beyond newb status: Is there anything in the standard library that has this signature? Monad m => (a -> b) -> (a -> m b)
19:42:02 <liyang> djahandarie: found this on the third page of results for "UNPACK" http://hackage.haskell.org/trac/ghc/ticket/3990
19:42:08 <lispy> ?hoogle Monad m => (a -> b) -> (a -> m b)
19:42:08 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
19:42:08 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
19:42:08 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
19:42:09 <azaq23> @hoogle (a -> b) -> (a -> m b)
19:42:09 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
19:42:09 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
19:42:10 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
19:42:23 <lispy> robinhoode: ^^
19:42:25 <djahandarie> > map (take 3) . takeWhile ((>=3) . length ) $ iterate (drop 1) [1,2,3,4,5,6]
19:42:26 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6]]
19:42:35 <b930913> And how can I get [[1,2,3],[2,3,4],[3,4,5],[4,5,6]] given "123456"?
19:42:43 <robinhoode> lispy: No, look and you'll see: none of them match!
19:42:57 <lispy> robinhoode: yes, so doesn't that answer your question?
19:43:02 <djahandarie> liyang, yeah, I've seen that bug report before. It's talking about data instances though, not newtype instances.
19:43:02 <azaq23> > map (read :: String -> Int) "12345"
19:43:03 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
19:43:03 <lambdabot>         against inferred ty...
19:43:11 <lispy> robinhoode: hoogle searched the standard places but didn't find an exact match
19:43:17 <applicative> > filter (\x -> length x == 3) $ map (take 3) (tails [1..6])  -- dull
19:43:18 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6]]
19:43:44 <djahandarie> Ah, tails is what I was looking about, forgot about that function.
19:43:54 <applicative> > map (read. (:[])) "123456"
19:43:55 <lambdabot>   [*Exception: Prelude.read: no parse
19:44:02 <liyang> djahandarie: related though. Will just add a comment to that ticket.
19:44:09 <djahandarie> Sounds good
19:44:32 <robinhoode> @pl (\f -> (\x -> return $ (f x)))
19:44:33 <lambdabot> (return .)
19:45:03 <parcs> > (\n xs -> take (length xs - n + 1) $ map (take n) $ inits xs) 3 [1..6]
19:45:04 <lambdabot>   [[],[1],[1,2],[1,2,3]]
19:45:10 <parcs> well then.
19:45:28 <applicative> > [read [x] :: Integer | x <- "123456"]
19:45:29 <lambdabot>   [1,2,3,4,5,6]
19:45:58 <parcs> > (\n xs -> take (length xs - n + 1) $ map (take n) $ tails xs) 3 [1..6]
19:45:59 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6]]
19:47:05 <lispy> now create [[1,2,3],[2,3,4],[3,4,5],[4,5,6]] using fibs instead of [1..6] !
19:47:18 <b930913> "Not in scope: `tails'" :s
19:47:23 <djahandarie> b930913, Data.List
19:47:43 * lispy thinks b930913 needs a fishing lesson and fewer fish
19:47:54 <djahandarie> Maybe.
19:48:10 <djahandarie> Not sure how you teach a compositional approach aside from examples though.
19:48:14 <djahandarie> Assuming the examples can be read.
19:48:30 <applicative> > map (read . (:[])) "123456" :: [Integer]
19:48:31 <lambdabot>   [1,2,3,4,5,6]
19:52:05 <parcs> > map (chr . (- ord '0') . ord) "123456"
19:52:05 <lambdabot>   Couldn't match expected type `a -> GHC.Types.Int'
19:52:06 <lambdabot>         against inferred ...
19:52:17 <parcs> > map (chr . (subtract ord '0') . ord) "123456"
19:52:17 <lambdabot>   Couldn't match expected type `GHC.Types.Char -> GHC.Types.Int'
19:52:18 <lambdabot>         agai...
19:52:22 <parcs> > map (chr . (subtract $ ord '0') . ord) "123456"
19:52:24 <lambdabot>   "\SOH\STX\ETX\EOT\ENQ\ACK"
19:52:35 <parcs> hmm
19:52:46 <parcs> > map ((subtract $ ord '0') . ord) "123456"
19:52:48 <lambdabot>   [1,2,3,4,5,6]
19:54:33 <b930913> How do I convert a list of strings to a list of integers? E.g. ["1234","4392"] to [1234,4392]
19:54:53 <aavogt> map read
19:55:03 <monqy> > map read ["1234", "4392"]
19:55:04 <lambdabot>   [*Exception: Prelude.read: no parse
19:55:06 <monqy> oops
19:55:15 <monqy> > map read ["1234", "4392"] :: [Int]
19:55:16 <lambdabot>   [1234,4392]
19:55:44 <applicative> what does lambdabot default to reading things as?  I was surprised by the no parse error
19:56:01 <parcs> ()
19:56:06 <parcs> > read "()"
19:56:07 <lambdabot>   ()
19:56:27 <applicative> indeed
19:56:29 <parcs> i'm not sure how lambdabot is even able to default a Read instance
19:56:59 <applicative> ghci does the same
19:58:03 <parcs> i get an ambiguous type variable error in ghci
19:58:06 <monqy> me too
19:58:16 <b930913> monqy: It works, but then fails when I let it = something.
19:58:41 <monqy> b930913: what do you mean?
19:58:58 <applicative> > let a =  map read ["1234", "4392"] :: [Int] in take 3 a
19:58:59 <lambdabot>   [1234,4392]
19:59:38 <azaq23> ghci -XNoMonomorphismRestriction seems to default to () too
19:59:52 <b930913> applicative: "take 3" ?
19:59:56 <applicative> azaq23 I noticed that, I wondered if I had if off
20:00:06 <applicative> b930913: yeah, I was thinking of an earlier example
20:00:33 <b930913> > let a = map read ["1234", "4392"] :: [Int] in  a
20:00:34 <lambdabot>   [1234,4392]
20:00:41 <b930913> Ah, ok.
20:00:44 <b930913> Thanks.
20:01:47 <b930913> Still throws an error though :(
20:02:08 <b930913>     Couldn't match expected type `[Char]' against inferred type `Int'
20:04:27 <applicative> b930913: what did you write?  Is this in a module or in ghci?
20:04:28 <monqy> did you by any chance omit the map read? or write it like map read (["12352", "235"] :: [Int])
20:05:37 <b930913> ghci
20:06:00 <b930913> "let nums =  map read nums :: [Int] in nums"
20:06:35 <monqy> oh you're shadowing nums? that can get confusing
20:06:39 <monqy> what is nums
20:07:07 <djahandarie> He isn't shadowing nums.
20:07:12 <djahandarie> That's recursive, and why it's not working.
20:07:15 <monqy> oh
20:07:16 <b930913> A list of strings.
20:07:24 <djahandarie> b930913, use a different variable name.
20:07:36 <monqy> I guess that's the confusion
20:07:45 <b930913> Ah.
20:07:54 <b930913> You can't do a=a+1? :p
20:08:13 <applicative> omigod
20:08:56 <applicative> > map (\a -> a == a + 1) [1..]
20:08:57 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
20:09:03 <djahandarie> b930913, no, variables in Haskell are immutable. They cannot be changed.
20:09:18 <applicative> b930913: a doesnt equal a + 1
20:09:31 <b930913> Variables that can't change are called constants in my book.
20:09:41 <djahandarie> b930913, sure.
20:10:06 <applicative> okay when you say let b = 1 ;  let a = b + 3 it's all constants
20:10:46 <b930913> And Sod's law says constants aren't and variables won't.
20:11:08 <monochrom> and Sod doesn't sod off :)
20:12:10 <b930913> Gah, how do I sum each listitem in a list?
20:12:16 <ptrf> 31
20:12:21 <ptrf> oops
20:12:22 <b930913> map sum nums?
20:12:26 <monochrom> > sum [3,6,1]
20:12:27 <lambdabot>   10
20:12:43 <monochrom> or you can do foldl (+) 0 [3,6,1]
20:12:47 <applicative> > foldr (+) 0 [3,6,1]
20:12:48 <lambdabot>   10
20:12:57 <applicative> @quote fugue
20:12:57 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
20:12:58 <b930913> Hold on.
20:13:04 <b930913> I've made a foobar.
20:15:08 <b930913> Ok, given a list of strings ["1234","4923"] how do I sum each "word"? (Result being [10,18])
20:16:06 <applicative> b930913: earlier on we had > map (read . (:[])) "123456" :: [Integer] for one such string
20:16:12 <djahandarie> Does the fact that   ["1234", "4923"] == [['1', '2', '3', '4'], ['4', '9', '2', '3']]   help you ?
20:17:25 <monochrom> > map (sum . map digitToInt) ["1234","4923"]
20:17:26 <lambdabot>   [10,18]
20:17:33 <b930913> djahandarie: Not when it throws errors for being a string :(
20:17:39 <monochrom> take your time. digitToInt is in Data.Char IIRC
20:17:40 <applicative> > map (map (read . (:[]))) ["1234","4923"] :: [[Integer]]
20:17:41 <lambdabot>   [[1,2,3,4],[4,9,2,3]]
20:18:10 <djahandarie> b930913, a 'string' doesn't exist. We only have lists of characters.
20:18:12 <applicative> > map (sum . map (read . (:[]))) ["1234","4923"] :: [[Integer]]
20:18:13 <lambdabot>   No instance for (GHC.Num.Num [GHC.Integer.Type.Integer])
20:18:13 <lambdabot>    arising from a ...
20:18:29 <djahandarie> b930913, and you can exploit that to get your answer
20:18:32 <applicative> > map (sum . map (read . (:[]))) ["1234","4923"] :: [Integer]
20:18:34 <lambdabot>   [10,18]
20:20:09 <b930913> I can minimum that then, but how do I find what the original string was that gave that sum?
20:20:28 <djahandarie> By never getting rid of the original string.
20:21:32 <applicative> you're not going to find it by applying a function to [10,18], I wouldn't think.
20:21:59 <monochrom> I am not thrilled about obsession with strings
20:22:20 <applicative> monochrom: you mean b930913's our Haskell's
20:22:29 <applicative> or rather Haskell's
20:22:37 <monochrom> but multiple digit lists give the same sum. [1,9] [2,8] [5,4,1] all sum to 0
20:22:47 <monochrom> sorry, all sum to 10
20:22:59 <greenland>  #haskell, I've defined some values that are not in a list in a module, and I'd like to map over a list of those variables but, I'm told they're not in scope. Am I doing it wrong?
20:23:02 <monochrom> haskell is clearly not obsessed with strings
20:23:36 <recursif> anybody knows whether haskell uses call stack at back-end ?
20:23:48 <applicative> greenland, why dont you paste it at hpaste.org
20:24:33 <monochrom> look for the "partition problem" and prepare to brute-force a bit if you really want to reverse-engineer digits from sums
20:25:02 <applicative> greenland, it's a little hard to follow.
20:25:10 <hpaste> greenland pasted “magic module” at http://hpaste.org/47831
20:25:38 <applicative> greenland, cosmic!
20:26:11 <greenland> ...thats neat
20:28:17 <Axman6> greenland: value names must start with a lower case letter, you can't use Foo = ... to define what Foo is
20:28:39 <greenland> i'm making functions, aren't I?
20:28:42 <Axman6> you have to use time, not Time, space, not Space etc
20:29:01 <Axman6> even if they are functions, they need to have lower case names
20:29:04 <hpaste> applicative pasted “magic” at http://hpaste.org/47832
20:29:17 <djahandarie> (Functions are values, anyways.)
20:29:56 <greenland> thanks...
20:29:57 <djahandarie> (But technically data constructors are also values. Would be best to say non-data-constructors.)
20:30:01 <applicative> greenland: this compiles.  You were using uppercase as Axman6 says, also Animus is just another name of the type, not a constructor, which is Affinity
20:31:17 <applicative> greenland, for magical material, I recommend Integer and Double rather than Int and Float
20:31:41 <greenland> applicative: why did you comment out that line?
20:31:42 <Axman6> yeah, there's only one reason to ever use Float: when memory usage is a big problem
20:31:59 <applicative> greenland it cant be the type
20:32:45 <applicative> greenland: calcBias a time is a Float, so the maximum of a list of such things is a Float
20:33:35 <greenland> applicative: ....I'm a long way from ruby. is the float percision terrible or something? ...it's not for any scientific application or anything...
20:34:03 <Axman6> float is about half as precise as double, and they're equal in speed
20:34:22 <Axman6> there's basically no reason to even use floats
20:35:15 <greenland> not even when doing small-integer combat math in 100 threads on a 512mb virtual host?
20:36:17 <Axman6> do you find that you're having to store millions and millions of float values?
20:37:04 <recursif> too many robots here
20:37:07 <recursif> :))))
20:37:28 <Axman6> anyway, it's far more important you understand the basic problems with your code than whether to use Double over Float.
20:37:49 <greenland> Axman6: that's... true
20:38:26 <Axman6> the first one is related to the line applicative commented out: your types don't match
20:38:43 <monochrom> 512mb can hold at least 64,000,000 doubles
20:38:59 <recursif> omg
20:39:04 <recursif> you need a beer
20:39:05 <recursif> ?D
20:39:05 <lambdabot> Maybe you meant: . ? @ v
20:39:06 <recursif> :D
20:39:32 <Axman6> you've got calcBias :: Animus -> Affinity -> Float, and when you use the a in the map, you get (calcBias a :: Affinity -> Float)
20:39:48 <recursif> because of hardware limitation we are all programming in all wrong way...
20:39:51 <Axman6> so when you apply the map to the [Affinity], you get a [Float]
20:40:06 <Axman6> , then you just fine the maximum float value
20:40:16 <Axman6> which doesn't really give you much
20:42:38 <Axman6> greenland: does that make any sense?
20:48:05 <applicative> greenland: it's seeming fine, we just have to figure out what calcBias is meant to do, I think
20:49:20 <greenland> it should give a float/double ... it's just distance formula
20:50:40 <greenland> theres four corners, i want to tell what corner is opposite what with the compliment function
20:51:05 <NemesisD> if i want to sort a list, highest to lowest and performance is an issue, should i sortBy and reverse or should i compose the comparator with flip
20:51:12 <NemesisD> or does it not really matter
20:52:06 <monochrom> flip
20:52:31 <NemesisD> and perhaps an even more important question, if i'm just going to take n from the list after i'm done, will the reverse still require O(n)
20:52:43 <ski> @flip
20:52:43 * lambdabot slaps  with a slab of concrete
20:53:05 <monochrom> reverse costs as much as list length. not negotiable
20:53:08 <djahandarie> (Ah, the failure of big-O notation, nothing like it...)
20:53:15 <djahandarie> (Also, if performance is an issue then stop using lists.)
20:53:41 <monochrom> > take 1 (reverse (repeat ()))
20:53:45 <lambdabot>   mueval-core: Time limit exceeded
20:54:00 <applicative> greenland, im starting to get it.  I think I see the reason for the capitals before , do you want the function to return something like Time or Space...?
20:55:13 <greenland> applicative: exactly... in a previous version they were all laid out as four possible values of a custom type... not sure which is more sane
21:02:26 <applicative> greenland: a type data Poles = Time | Space | Matter | Energy seems fine, then for any position, theres, say, a length 4 list giving distances
21:11:22 <greenland> rock on
21:14:39 <Peaker> monochrom: reverse can be made more lazy so that take 1 would work
21:16:30 <Axman6> > take 1 . sort . reverse $ [1..1000000]
21:16:34 <lambdabot>   mueval-core: Time limit exceeded
21:16:37 <Axman6> > take 1 . sort . reverse $ [1..100000]
21:16:40 <lambdabot>   [1]
21:16:45 <Axman6> > take 10 . sort . reverse $ [1..100000]
21:16:47 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
21:17:07 <lpsmith> heh, the "recent package updates" on haskell.org is about 2 months old
21:17:20 <Axman6> fi sort is implemented using mergesort, then it will return the minimum value as soon as it is known
21:17:35 <Axman6> if*
21:21:13 <Axman6> i think that «take k . sort take» O(n log k)
21:21:29 <Axman6> uh, sort»*
21:26:03 <Peaker> the best algorithm equivalent to    take k . sort     is O(n)
21:26:51 <c_wraith> no...  it's O(n + k log k)
21:27:00 <c_wraith> unless you don't care about getting them in order
21:27:12 <Peaker> c_wraith: yeah, sorry, that's right
21:27:29 <Peaker> But   take k . sort    is worse than that, iirc
21:27:36 <mjrosenb> c_wraith: even then, it still can't take O(n), can it?
21:28:04 <mjrosenb> oh, never mind, it can.
21:34:51 <guerrilla> so, in do notation... you can apparently do like "SomeConstructor x <- something" what happens when "something" returns an alternative constructor of its return type?
21:35:56 <c_wraith> guerrilla: the great shame of the Monad typeclass.  fail gets called with an error message describing it
21:36:58 <guerrilla> hmmm, rather interesting. then i'll stick with case'ing on the outside and handling it myself
21:37:09 <c_wraith> > runState (do { Just x <- return Nothing ; return x }) 0
21:37:10 <lambdabot>   *Exception: Pattern match failure in do expression at <interactive>:3:15-20
21:37:24 <guerrilla> oy
21:37:27 <guerrilla> how horrible
21:37:36 <guerrilla> (total functional programmer here)
21:37:36 <c_wraith> Well, that's what you'd want
21:37:43 <c_wraith> In comparison to...
21:37:46 <Peaker> The really sad thing is that Haskell did it right before Haskell98
21:38:00 <c_wraith> > (do { Just x <- return Nothing ; return x }) :: Maybe Int
21:38:01 <lambdabot>   Nothing
21:38:14 <c_wraith> *that* one is what I consider to be the real bad choice
21:38:23 <Peaker> You got a MonadZero constraint if you did that -- which would tip you off about the possibility of a pattern match failure.. If it was a Monad context, it was safe
21:38:23 <guerrilla> Peaker: what did it to?
21:38:32 <guerrilla> c_wraith: omfg. stop. you're ruining my life ;) haha
21:38:56 <djahandarie> c_wraith, the hell?
21:39:00 <djahandarie> Haven't seen that behavior before
21:39:02 <Peaker> c_wraith: you basically want to scratch "fail" and just call "error" there?
21:39:25 <c_wraith> Peaker: I want refutation of an irrefutable pattern match (which is basically what that is) to *always* be an error.
21:39:47 <Peaker> > head (do { Just x <- return Nothing ; return x })
21:39:48 <lambdabot>   *Exception: Prelude.head: empty list
21:39:54 <guerrilla> c_wraith: you mean at type chck time, right?
21:40:00 <c_wraith> guerrilla: no, at runtime.
21:40:23 <c_wraith> irrefutable pattern matches that can fail should be a warning, though.
21:40:33 <Peaker> c_wraith: I want single-constructor matches (those that cannot errorize) to be syntactically different to those that can
21:40:35 <c_wraith> much like the warning for non-exhaustive pattern matches
21:41:08 <guerrilla> how can return x; return y; type check when y and x are not the same type?
21:41:19 <c_wraith> djahandarie: Maybe overloads fail to be const Nothing
21:41:33 <azaq23> djahandarie: It's just fail getting called on the pattern match failure. fail for Maybe is fail _ = Nothing
21:41:36 <c_wraith> guerrilla: return is not a control flow statement
21:41:57 <c_wraith> guerrilla: return is just a (poorly-named) function
21:43:31 <guerrilla> c_wraith: aware.. but doesn't return get you like "SomeMonad T" whereas bind actually returns a function...
21:43:52 <c_wraith> > Just 5 >> Just "foo"
21:43:53 <lambdabot>   Just "foo"
21:43:54 <guerrilla> oh wait, i totally read what you wrote above wrong
21:44:02 <guerrilla> nevermind my last couple questions
21:44:08 <c_wraith> > return 5 >> return "foo" :: Maybe String
21:44:09 <lambdabot>   Just "foo"
21:45:26 <Peaker> (>>) and (>>=) allow the monadic value arguments to have different types (same monad type though)
21:45:41 <guerrilla> > return 5; return "foo"
21:45:42 <lambdabot>   <no location info>: parse error on input `;'
21:45:45 <guerrilla> oops
21:45:46 <guerrilla> > return 5; return "foo";
21:45:47 <lambdabot>   <no location info>: parse error on input `;'
21:45:52 <guerrilla> no?
21:46:05 <guerrilla> Peaker: yeah
21:46:35 <Peaker> guerrilla: you're writing a statement-list, that makes sense in a do block
21:47:12 <guerrilla> right, dono how to use lambdabot :)
21:47:35 <Peaker> > do { return 5 ; return "foo" }
21:47:36 <lambdabot>   No instance for (GHC.Show.Show (m [GHC.Types.Char]))
21:47:36 <lambdabot>    arising from a use ...
21:48:22 <guerrilla> ok, not what i was expecting, but closer..
21:49:09 <Peaker> guerrilla: what monad should be used in that code?
21:50:42 <guerrilla> 1sec
21:51:40 <guerrilla> like this http://hpaste.org/47833
21:51:57 <guerrilla> i would expect, naivley Just "foo" or for that not to compile at all
21:52:41 <guerrilla> but i guess it's not the monad that's my issue but do notation
21:53:35 <guerrilla> like (return x) (return y) is not valid.. however, that's not what is happening in a "do", right?
21:54:18 <NemesisD> hey all. i was wondering if i could get your guys' thoughts on an algorithm i'm working out
21:54:20 <guerrilla> it's really (return x) >>= (\ _ -> return y)   right?
21:54:39 <RayNbow`TU> guerrilla: it's not a real error
21:54:47 <guerrilla> if so, that clarifies it for me
21:54:58 <azaq23> guerilla: To your last question, yes. do { return x ; return y } evaluates to return x >> return y
21:55:00 <azaq23> @src (>>)
21:55:00 <lambdabot> m >> k      = m >>= \_ -> k
21:55:05 <ski> @undo do return x; return y
21:55:05 <lambdabot> return x >> return y
21:55:25 <guerrilla> whoah.. lambdabot is amazing. and thanks all of you :)
21:55:31 <NemesisD> so i'm writing an app that, given a wishlist and a set of vendor inventories, produces the optimal orders the users would have to place to fulfil that wishlist, optimal for the sake of simplicity meaning cheapest
21:57:33 <NemesisD> the approach i've taken so far is fairly straightforward to code but the way i've done it is quite slow for larger wishlists (>20 items). it generates all conceivable ways the wishlist could be split up amongst the vendors, sorts those orders by how much they would cost and how well they fulfil the wishlist and then does a head/take off of that list
21:57:36 <Peaker> guerrilla: The "error" is from "hlint" which gives you hints about improvements for the code.. weak hints are "warning" and strong hints ("never do that, it's not nice!") are marked as "error"
21:57:58 <Peaker> NemesisD: I think in the general case that problem is NPC?
21:58:24 <Peaker> NemesisD: though with heuristics it could probably avoid becoming the general case most of the time
21:58:42 <guerrilla> Peaker: sorry, which error?
21:58:52 <RayNbow`TU> the error in the hpaste you linked to, guerrilla
21:58:59 <RayNbow`TU> "redundant do" at line 3
21:59:03 <Peaker> guerrilla: "3:5: Error: Redundant do"
21:59:04 <guerrilla> ah ok, no, i wasn't concerned by that at all :)
21:59:14 <Peaker> guerrilla: note if you click it, it shows you what it means as an example
21:59:20 <guerrilla> just using it as an example
21:59:37 <guerrilla> of how you could return multiple times, since i couldnt figure out lambdabot
21:59:56 <guerrilla> i knew hpaste has hlint support now ;) quite cool
22:00:12 <Peaker> guerrilla: "return" just wraps a value in a monadic wrapper, so no problem to bind multiple such wrapped values together
22:00:33 <guerrilla> Peaker: yeah, i see how it all works now
22:00:42 <NemesisD> Peaker: it will be possible in the use case of this to impose upper bounds on the wishlist size, but i'd like that ceiling to be as high as i can get it. a lot of my heuristics i can thing of happen too late, after it's already generated the crapload of orders, many of which will just be discarded
22:00:47 <guerrilla> Peaker: cool that you can click on the error, i did not know that part
22:01:18 <Peaker> NemesisD: yeah, you can probably prune many options known to be worse or suboptimal
22:02:43 * guerrilla goes back to coding. thanks guys
22:03:18 <NemesisD> Peaker: i guess i could require a limit to the lower bound of acceptable wishlist coverage. so for example if the wisihlist contains 5 items, i'd have to specify that i'm not interested in any orders that have fewer than 3 of those
22:03:57 <NemesisD> not sure how much quicker that will make things
22:04:30 <Peaker> NemesisD: must it really be optimal? A greedy algorithm can probably work well in most cases
22:04:37 <Peaker> (but perhaps not optimally)
22:07:35 <NemesisD> Peaker: hmm could you elaborate
22:12:07 <Peaker> NemesisD: if you just choose the "best" next action and don't do (much) backtracking, that may approximate the optimum well enough
22:13:24 <NemesisD> Peaker: what do you mean by next action?
22:14:11 <Peaker> NemesisD: in your search recursion, instead of iterating all possible things you could do and recurse, you could try to choose some maximal/best thing to do and recurse over that one single choice only
22:14:14 <NemesisD> and there must be some set to compare against to determine if something is best. the problem with this is that if it were generating orders and then comparing their relative price, i wouldn't know when to stop
22:14:44 <Axman6> Peaker: doesn't that assume that shipping doesn't get cheaper the more items you buy?
22:16:19 <NemesisD> Axman6: very good point. my system takes into account things like buy > $100 and shipping is free type deals
22:16:49 <NemesisD> here's an approach i was thinking about. it may require something like enumerators about which i know very little:
22:18:23 <NemesisD> rather than at the outset generating all possible ways the wishlist can be distributed out amongst the vendors, it would work in passes. first pass is the best case: that your entire wishlist can be fulfiled by the given vendors. it generates the orders from that, sorts them, takes the amount you want (say top 5) and if that gets you your 5, it stops there
22:18:26 <Peaker> well, by greedy algo. I'm referring to a specific known problem.  Say you're a thief in a store. You have a bag. You want to steal as much money as you can. Each item in the store has a price and mass.  You can only carry M mass. If the things you steal are continuous, then a greedy algo solves this: Always place the item with the best cost/mass ratio until bag full or until product over, then switch to next best
22:19:00 <Peaker> now if the products you can steal are discrete -- the problem is NP complete and greedy algorithm doesn't solve it *optimally* anymore. But it probably gives a reasonable solution most of the time
22:19:11 <NemesisD> it would only go back and start generating sub-optimal cases where it covers say 90% of your wishlist if it has not generated enough to fulfil your requests. these subsequent trips will be hard since the number of possibilities increases dramatically
22:21:06 <NemesisD> Peaker: ah, makes a bit more sense
22:21:14 <Axman6> NemesisD: the simple answer is: keep doing what you're doing, and throw more hardware at it!
22:22:21 <Peaker> these kinds of problems tend to have a bazillion possible heuristics to improve them
22:22:27 <NemesisD> Axman6: pseq to the rescue eh?
22:22:48 <Axman6> well, more par i guess... but possibly
22:23:13 <hydo> Is there any reason why I should use the MaybeT package over the transformers package alternative?
22:23:25 <hydo> or vice versa for that matter.
22:23:28 <Axman6> it's a sifficult problem though, since things like shipping can mean the results change sort of unprodictably
22:24:09 <NemesisD> Axman6: well my program has the benefit of getting a snapshot of all the data it needs at the outset. the downside is that the result is needed synchronously and can't be backgrounded
22:28:31 <minsa> how do I go from Main to Prelude back ?
22:29:54 <Axman6> what do you mean?
22:30:31 <Axman6> when the prompt says Main>, you've in the scope of the Main module, which should implicitly also have everything that's in the Prelude too
22:31:53 <shachaf> :set -XYesImplicitPrelude
22:32:34 <NemesisD> how does one install profiling libraries for cabal packages
22:32:51 <NemesisD> i.e. in order to profile a program, it wants profiling libraries for the text package
22:33:04 <Axman6> NemesisD: the easiest way to to turn it on in the config file for cabal, then you'll always have profiling libraries
22:33:14 <Axman6> but for a one off, you need cabal install foo -p
22:33:23 <Axman6> or cabal install -p foo, i can't remember which
22:33:26 <Axman6> possibly both
22:33:34 <Axman6> I'd recommend the config file though
22:34:42 <NemesisD> Axman6: rgr. thank you
22:35:51 <OceanSpray> how do I install ONLY profiling libraries or ONLY shared libraries?
22:36:04 <OceanSpray> so that cabal doesn't build the same package three times?
22:36:58 <minsa> Axman6, thnx.
22:40:00 <NemesisD> shoot, gotta reinstall so many libraries
22:40:41 <Axman6> NemesisD: this is why it's useful to have it turned on by default =)
22:41:00 <OceanSpray> how do I turn off the default by default?
22:41:47 <NemesisD> Axman6: with haskell i do most of my lesson-learning the hard way
22:42:16 <Axman6> OceanSpray: i don't believe you can
22:42:27 <Axman6> it's not a feature I've seen anyone want before
22:45:33 <OceanSpray> well I want it pretty bad
22:45:33 <dibblego> anyone successfully used the doc-review package? It appears to die with documents containing certain characters
22:45:49 <OceanSpray> every time I install something I have to wait for 3x as long.
22:47:04 <OceanSpray> and how do I get a shared AND profiled library?
22:47:37 <OceanSpray> these really should be options applied to one canonical build upon install, not extra builds.
22:51:08 <dibblego> hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)
22:52:51 <Axman6> OceanSpray: file bugs, write code. there are very few GHC devs, with much more pressing problems
23:01:28 * hackagebot Monadius 0.94 - 2-D arcade scroller  http://hackage.haskell.org/package/Monadius-0.94 (HideyukiTanaka)
23:03:35 <frerich2> Neat, the homepage of Monadius is some www.geocities.jp address.
23:03:42 <frerich2> I didn't know geocities is still around.
23:10:47 <roastbird> hello, does anyone know of Haskell (server-side) webapps that have been acquired by bigger firms? i'm thinking of using Haskell for my next project, but not if it's going to restrict potential exit strategies
23:16:35 <NemesisD> hmm the profiling option in the RTS eludes me
23:17:07 <NemesisD> it seems like it isn't granular enough
23:18:32 <NemesisD> apparently nothing but my main and GC/SYSTEM use any time
23:18:39 <dirrt> a
23:19:06 <NemesisD> -pa?
23:20:08 <adimit> NemesisD: you can split up your main function into cost-centres in two ways: name parts of it and make them top-level functions, or use SCC pragmas to assign in-line cost-center annotations.
23:20:21 <adimit> Consult chapter 5 of the GHC manual for details.
23:21:03 <NemesisD> one of the alarming things is that it allocates 3,532,112,216 bytes supposedly :P
23:21:31 <adimit> that is overall transit, *not* maximum residency.
23:21:52 <NemesisD> yeah i figured, since i've only got 2gb in this system
23:27:05 <danharaj> I have taken a liking to replacing some Bool's in my code with Maybe's.
23:27:45 <adimit> it might often save you an if statement or two :-P
23:27:58 <adimit> esp. because you can chain maybe in Monads.
23:28:16 <danharaj> Well to me it's more important that it makes it clear what is the fail case and what is the continue case.
23:28:28 <adimit> 'scuse me for the tardspeak. that should've been phrased differently.
23:28:37 <danharaj> It's late, all is forgiven.
23:28:42 <adimit> actually, it's early.
23:28:50 <adimit> ^^ I just got up.
23:29:04 <danharaj> same thing
23:29:06 <danharaj> just mirrored
23:35:11 <yitz> danharaj: i agree with you. Maybe often is a clearer style.
23:42:36 <bytbox>  /join #linux
23:42:45 <bytbox> oops
23:42:47 <bytbox> disregard that
23:48:04 <dibblego> can anyone tell me why I cannot read this file? http://paste.pocoo.org/show/407999/
23:52:00 <shachaf> dibblego: Is that an invalid UTF-8 character?
