00:22:29 * roconnor sighs
00:23:02 <roconnor> I feel like I should filter out hackage packages by use of "unsafePerformIO"
00:23:24 <shachaf> That's the spirit!
00:24:18 <Axman6> roconnor: no ByteStrings for you?
00:24:27 <roconnor> :(
00:24:48 <dankna> see what we need to do is
00:24:57 <dankna> have a type that marks the presence of unsafePerformIO
00:25:00 <dankna> we can call it ReallyIO
00:25:14 <shachaf> dankna: An instance of Monad?
00:25:17 <dankna> indeed!
00:25:25 <dankna> and then of course we have to define reallyUnsafePerformIO :: ReallyIO a -> a
00:25:34 <shachaf> dankna: Courageous and innovative.
00:25:38 <dankna> thank you.
00:25:52 <dankna> I suspect you of being facetious for the sake of ironic humor.  but that's okay.  so am I.
00:25:58 <Axman6> dudeAreYouReallySureYouWantToPerformThatIO?
00:26:06 <dankna> heyDudeWhere'sMyIO
00:26:24 <Axman6> iSwearILeftMyIOHereSomewhere
00:26:41 <dankna> noSeriouslyDudeWhere'sMyIO
00:26:42 <Axman6> types'YULieToMe
00:27:14 <dankna> ooh ooh, I have a good one --  iSolemnlySwearIAmUpToNoIO
00:27:41 <Axman6> there's got to be a unicode character for fingers crossed
00:28:00 <dankna> yeah, you know, I actually think I saw that in the latest batch ><
00:28:10 <dankna> the one with all the emoticons in it
00:29:15 <Axman6> ✌
00:29:20 <Axman6> close enough
00:29:52 <dankna> uh, no, V-for-victory or the peace sign, which, oddly, are almost the same, are not close enough :)
00:30:08 <dankna> (oddly because their meanings are opposite)
00:32:06 <roconnor> the impelementation of persistent-equivalence made me throw up in my mouth a little.
00:32:56 <dankna> what is that exactly?
00:33:49 <roconnor> dankna: it is supposed to be some form of union find
00:34:21 <ivanm> roconnor: hey, I use unsafePerformIO _once_ in graphviz, and it's completely optional (OK, current version on hackage has it twice)!
00:34:35 <roconnor> ivanm: herritic
00:34:36 <dankna> oh hmm
00:34:51 <roconnor> actually I don't feel so bad for safe uses of unsafePerformIO
00:35:15 <roconnor> but I'm not convinced the use in persistent-equivalence is safe ... maybe I'm wrong, but it looks very very unsafe.
00:35:22 <ivanm> roconnor: when you don't have any attributes (and even then AFAIK it's only one), then dot -Tcanon is pure
00:35:24 <flux> what, ivanm doesn't like kittens? because you know, every time you use unsafePerformIO..
00:35:38 <ivanm> flux: I _love_ kittens, especially in a white sauce...
00:35:39 <ivanm> ;-)
00:35:45 <roconnor> I've been seeing a lot unsafe uses of unsafePerformIO lately
00:36:16 <roconnor> like that Data.Unique fiasco
00:36:17 <roconnor> god
00:36:29 <dankna> Data.Unique is kind of a cool trick though
00:36:38 <dankna> that's the one where you get integers in the order you observe them, right?
00:37:20 <roconnor> dankna: ya, but unsafePerformIO newUnique is not so cool.
00:37:24 <roconnor> god
00:38:04 <sully> what happens?
00:38:08 <roconnor> How about we write a function a -> b that *always* returns a different value on the same input!
00:38:16 <dankna> fair enough
00:38:44 <roconnor> sully: you get a function that is not referentially transparent
00:41:52 <dankna> sigh
00:42:24 <dankna> I have 6200ish lines of code
00:42:30 <dankna> and I strongly suspect that 4000ish of it is plumbing
00:42:36 <dankna> that's what happens when you insist on mixing languages :(
00:42:38 <sully> roconnor: I guess that should horrify me, but I come from ML land :P
00:44:18 <kosmikus> roconnor: Data.Unique in itself isn't unsafe though. So what's this "Data.Unique fiasco" you're referring to?
00:45:13 <ivanm> kosmikus: a recent thread on -cafe
00:45:33 <ivanm> IIRC, it was how Data.Unique isn't unique over multiple runs or threads or something
00:45:56 <owst> Is http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide supposed to be pointing to an old guide? If not, who should I tell?
00:46:25 <ivanm> preflex: seen dcoutts
00:46:25 <preflex>  dcoutts was last seen on #ghc 9 hours, 47 minutes and 30 seconds ago, saying: woo!
00:46:28 <dcoutts> owst: mm, yes, I need to update all the pointers to the latest release
00:46:30 <dankna> owst: dcoutts is the person to tell, but I'm not clear that it's ...
00:46:31 <dankna> ah
00:46:51 <ivanm> dcoutts: wow, that was quick! :o
00:47:20 <owst> I found the latest docs easily enough, but Google took me to the old docs... thanks dcoutts :)
00:48:34 <ivanm> would "Data.GraphViz.Attributes.Simplified" be a good module name for more "user-friendly" helper functions to create Attributes?
00:48:54 <ivanm> (i.e. unless you want to really fiddle, just import that rather than Data.GraphViz.Attributes)
00:56:18 <mjrosenb> ivanm: can you invert it?
00:56:30 <ivanm> hmmm.... possibly
00:56:36 <mjrosenb> ivanm: e.g. have the full one be a sub-module of the simple one?
00:56:38 <ivanm> what would the complete version be called then?
00:57:13 <ivanm> "API compatability? what API compatability?" :p
01:02:13 <mjrosenb> complex?
01:02:26 <ivanm> heh, probably not
01:02:55 <ivanm> since the simplified variants are just wrappers around multiple constructors; e.g. fillColor = FillColor . X11Color
01:04:35 <ivanm> I'm also trying to think of a better namespace than Data.GraphViz.Types.* for the various implementations of Dot graphs
01:12:51 * hackagebot concurrentoutput 0.2.0.2 - Ungarble output from several threads  http://hackage.haskell.org/package/concurrentoutput-0.2.0.2 (JoachimBreitner)
01:22:52 * hackagebot darcswatch 0.4.4 - Track application of Darcs patches  http://hackage.haskell.org/package/darcswatch-0.4.4 (JoachimBreitner)
01:38:12 <solrize> http://www.realworldtech.com/forums/index.cfm?action=detail&id=113114&threadid=113034&roomid=2    what is he on about?   (torvalds ranting against STM)
01:38:21 <dankna> against STM?  what?
01:38:22 <dankna> looking
01:39:16 <dankna> hmm, it looks to me like he's talking about hardware transactional memory, actually
01:41:16 <solrize> hmm
01:41:29 <solrize> does that exist?
01:41:47 <dankna> apparently!
01:41:55 <solrize> tx
01:41:58 <dankna> that's what he's describing
01:41:59 <dankna> np :)
01:53:43 <ivanm> tibbe: with your objection to using pretty-printing for bytestrings: how about an alternate way of creating binary data?
01:54:00 <ivanm> (that is, instead of using binary or cereal)
01:54:04 * tibbe tries to remember his objection.
01:54:14 <tibbe> what do you want to achieve?
01:55:09 <ivanm> the suggestion from lispy was that you might as well make a pretty-printing library be class-based as a lot of it would be duplicated
01:55:21 <dankna> mm
01:55:28 <tibbe> right
01:55:33 <dankna> the problem arises when you need to provide context to the printing
01:55:42 <ivanm> and you and bos said that having a bytestring instance didn't make much sense or somesuch, presumably to discourage people using bytestrings for textual purposes
01:55:49 <tibbe> I think my point was that ByteString and Text share very few properties, mostly that of being sequences
01:55:51 <ivanm> (encodings, etc.)
01:55:57 <tibbe> right
01:56:21 <dankna> I don't know what you're doing so I can't really comment, but if I were doing it all over again, I would consider something like class PrettyPrintable object context | object -> context
01:56:32 <tibbe> so it's easy to get people confused over the difference between the abstract concept of a sequence of Unicode code points (Text) and a specific Unicode encoding (e.g. UTF-8 held inside a ByteString)
01:56:46 <ivanm> *nod*
01:56:47 <dankna> that way you can make the method be prettyPrint :: context -> object -> Text, or whatever
01:57:00 <tibbe> for example, what would this method on your PP class do: period :: Doc?
01:57:03 <ivanm> I'm thinking of having it based upon just Word8s
01:57:32 <dankna> GHC has this problem all over the place, things that can't /quite/ be in its pretty-printing class because they have contexts and the class doesn't allow for it
01:58:00 <ivanm> tibbe: admittedly, a class-based approach has problems with _specific_ combinators
01:58:08 <ivanm> s/combinators/values/
01:58:14 <ivanm> as opposed to joining combinators
01:58:54 <tibbe> ivanm, right
01:59:03 <tibbe> ivanm, so things like concatenation makes sense
01:59:09 <ivanm> yup
01:59:11 <tibbe> (since both instances are sequences)
01:59:39 <tibbe> but any method that outputs a Unicode code point is a bit bogus
01:59:57 <tibbe> because there needs to be an encoding of that code point before it can be stored in the ByteString
02:00:01 <ivanm> so if we do something like dankna's approach, you'd have things like period be used when the sequence values are Chars
02:00:05 <tibbe> for example, there's no one encoding for \n
02:00:13 <ivanm> then again, I would also find it useful to be able to deal with ASCII characters
02:00:19 <tibbe> right
02:00:26 <ivanm> tibbe: the whole \n vs \r\n vs \r thing?
02:00:27 <tibbe> you can do something like Data.ByteString.Char8
02:00:33 <tibbe> which is slightly unsafe
02:01:01 <tibbe> ivanm, no, \n can be encoded using different byte sequences in different encodings, which one will you use for the ByteString?
02:01:10 <ivanm> huh... didn't knkow that
02:01:12 <ivanm> *know
02:01:27 <ivanm> my current need: to be able to have files that look like: >>planar_code<< and then a whole bunch of literal Word8 values
02:01:33 <dankna> though in that particular case, the byte sequences happen to be quite similar because it's a 7-bit ASCII character
02:01:43 <dankna> mostly the wider ones have padding bytes
02:01:53 <tibbe> in UTF-32 newlines take 4 bytes
02:02:00 <dankna> yep
02:02:07 <tibbe> etc
02:02:20 <ivanm> ahhhh
02:02:42 <tibbe> so it's not that it's necessarily wrong to do what you want to do
02:03:41 <ivanm> well, if someone wants to use Char values with Bytestrings, they could always define their own String -> [Word8] function assuming there's a one-to-one correspondence
02:07:08 <dankna> what's the end application?
02:07:17 <ivanm> dankna: for me?
02:07:24 <ivanm> I need something to do binary encoding of graphs
02:07:29 <dankna> oh, hm
02:07:37 <dankna> for that, ByteString is appropriate
02:07:40 <dankna> and Text is definitely not :)
02:07:42 <ivanm> and using binary/cereal _sucks_ if you don't want extra embedding of type information
02:07:45 <dankna> and [Word8] is not really particularly nice
02:07:47 <dankna> I agree
02:09:16 <benmachine> dankna: couldn't you just define an instance for (context, object) or something
02:09:21 <benmachine> or a context-setting newtype
02:09:27 * benmachine is a bit behind the conversation
02:09:46 <dankna> benmachine: well, actually, yes, but that turns out to be a nuisance
02:09:57 <dankna> benmachine: because people do inane things like define generic instances for tuples :)
02:10:21 <benmachine> well data ObjectContext = Thing Context Object then :P
02:10:47 <dankna> yeah, but in a system the size of GHC, you don't want to introduce a new type without good reason
02:10:57 <dankna> or at least, I feel hesitant to; maybe some of the more experienced people wouldn't
02:11:19 <dankna> it's cognitive overhead when trying to understand the system
02:11:40 <dankna> it also doesn't really speak to the problem because, for example
02:11:42 <dankna> there are instances like
02:12:01 <dankna> PrettyPrint (ComplicatedGraphStructure a)
02:12:05 <dankna> er
02:12:08 <dankna> PrettyPrint a => PrettyPrint (ComplicatedGraphStructure a)
02:12:30 <dankna> to get the context inside where it would have to be with that approach, you would need to map the entire graph structure into a new one
02:12:49 <ivanm> dankna: oh, I'm not suggesting doing anything like that
02:12:51 <dankna> I actually went ahead and pulled everything out of PrettyPrint (or whatever it was called) entirely
02:13:08 <ivanm> I just want to use something better than binary or cereal
02:13:15 <dankna> ivanm: oh I know.  I'm just elaborating because benmachine asked about the motivation of my suggestion.
02:13:51 <dankna> I think you want to be using lazy bytestrings because they have O(1) append (timewise, at least; spacewise not so much), btw
02:14:04 <dankna> when you're doing a lot of concatenation it's almost certainly a win
02:14:24 <an> hi
02:14:46 <dankna> I'm amazed that the nick "an" isn't reserved for somebody
02:14:47 <ivanm> dankna: specifically, using a builder internally
02:14:59 <dankna> ivanm: yes
02:15:42 <dankna> I was just thinking about that.  I'm not sure really how a builder would look for bytestrings.
02:15:56 <ivanm> blaze-builder
02:16:07 <ivanm> which is meant to out-perform binary's builder
02:16:25 <dankna> I see
02:28:46 <solrize> why does Text use 16-bit chars instead of utf8?
02:28:56 <ivanm> solrize: short version: history
02:29:07 <mauke> what history?
02:29:11 <ivanm> there's a GSoC project to investigate migrating to utf8 instead
02:29:20 <mauke> haha, seriously?
02:29:36 <ivanm> IIRC, the original author chose UTF-16 as the internal encoding because eh thought it would be used more often or be more efficient
02:30:13 <ivanm> mauke: yup, primarily because all the web frameworks are using it and continually encoding/decoding to UTF-8
02:30:15 <mauke> in other words the original author is an idiot
02:30:38 <mauke> nah, that's unjustified
02:30:40 <ivanm> *shrug* I think it was long enough ago that UTF-8 wasn't that popular
02:30:42 <mauke> I just hate UTF-16
02:30:55 <mauke> when was UTF-8 not popular?
02:31:08 <mauke> is Text older than 1996?
02:31:09 <erikde> mauke: the original author is widely considered rather smart. however i thing he did make a mistake on this one.
02:31:23 <solrize> ivanm, thanks, interesting.
02:31:38 <erikde> mauke: no, its relatively recent.
02:31:46 <ivanm> mauke: hey, I'm trying to remember what bos, etc. said both on his blog posts and on -cafe!
02:31:58 <mauke> no one uses UTF-16 except windows
02:32:04 <ivanm> @google haskell text utf-16
02:32:06 <lambdabot> http://blog.ezyang.com/2010/08/strings-in-haskell/
02:32:07 <lambdabot> Title: How to pick your string library in Haskell : Inside T5
02:32:13 <mauke> and even then only internally, not for text files
02:33:23 <ivanm> well, there are various claims that UTF-16 is sometimes more efficient for asian languages, etc.
02:33:26 <ivanm> (than UTF-8)
02:33:57 <mauke> ah, but I don't care about them
02:34:13 <solrize> i don't understand the point of utf-16.  you get big bloat over utf-8 for latin text, and you still have to deal with the prospect of 4-byte codes for non-latin that could go outside the BMP
02:34:21 <mauke> ding! exactly
02:34:26 <ivanm> doesn't utf-16 pre-date utf-8?
02:34:37 <mauke> utf-16 combines the disadvantages of utf-8 with the disadvantages of utf-32
02:34:42 <mauke> ivanm: that would surprise me
02:34:55 <mauke> UCS-2 maybe
02:35:45 <Feuerbach> is there a more efficient CDouble -> Double conversion than realToFrac?
02:36:13 <accel> that's like something with the efficeincy of haskell and beauty of x86 assembly
02:38:16 <w00p> can you make in haskell a type of the numbers between 1 and 100?
02:39:17 <sipa> data NumbersBetween1And100 = N1 | N2 | N3 | N4 | N5 | ... | N100
02:39:18 <sipa> ? :)
02:39:21 <solrize> w00p you mean, checked by the type system?  afraid not
02:39:23 <mauke> yes, but it's not pretty
02:39:29 <solrize> you could make a newtype
02:39:34 <solrize> newtype N100 = N100 Int
02:39:45 <solrize> and then make the constructor check the number was in range
02:40:04 <solrize> and put it in a module so you couldn't escape the constructor
02:40:11 <solrize> arithmetic on them would do runtime checks
02:40:29 <solrize> that's probably what you were asking, i presume that's what ada does
02:40:36 <ivanm> don't forget to make a Bounded instance!
02:40:58 <w00p> hmm I'll try to write that
02:41:36 <o-_-o> map read $ splitOn ":" "1:12:28.43"
02:41:41 <o-_-o> I am trying to do this
02:41:53 <w00p> but yeah i hoped it could be checked by the type system, solrize
02:41:56 <ivanm> o-_-o: and?
02:41:57 <develhevel> howto exit a programm? just exit?
02:42:00 <o-_-o> and I think I have to do something like read "3"::Int
02:42:09 <ivanm> @hoogle ExitCode
02:42:09 <o-_-o> how do I do that in the above ?
02:42:09 <lambdabot> System.Exit data ExitCode
02:42:20 <ivanm> o-_-o: define a resulting type of your expresion
02:42:27 <ivanm> develhevel: see System.Exit
02:43:03 <o-_-o> ah
02:43:07 <o-_-o> ivanm: thanks
02:43:17 <ivanm> np
02:45:04 <o-_-o> what is the haskell equivalent of reduce ?
02:45:16 <sipa> fold
02:45:18 <osfameron> o-_-o: foldl and friends
02:45:18 <sepp2k> fold{l,r}
02:45:26 <o-_-o> ah...ok
02:46:39 <develhevel> how to do something like this: i have a function "foo [String] -> IO [String]" and want to make "when (...) return input" but it dont work
02:47:24 <solrize> w00p you might like this:  http://goto.ucsd.edu/~rjhala/liquid/
02:49:35 <sipa> what's foo?
02:50:57 <develhevel> foo :: [String] -> IO [String]      foo input = do ...
02:51:03 * hackagebot AC-BuildPlatform 1.1.0 - Detect which OS you're running on.  http://hackage.haskell.org/package/AC-BuildPlatform-1.1.0 (AndrewCoppin)
02:52:36 <ivanm> develhevel: can you explain in more detail what exactly you want it to do?
02:52:39 <benmachine> develhevel: return in Haskell doesn't do what it does in other languages
02:53:53 <ivanm> the _simplest_ (but not necessarily most efficient solution) is to use an if-statement to determine whether or not to recurse
02:55:02 <w00p> solrize: seems nice, haskell should totally have this :)
02:55:02 <solrize> develhevel, maybe you want:    when (...) $ return input
02:55:25 <solrize> w00p yeah, one of the authors is working on it for ghc
02:55:36 <w00p> great
02:56:49 <benmachine> w00p: it's not a straightforward question though, because you have to answer things like, what do you do when someone adds 60 and 70
02:56:59 <ivanm> solrize: I doubt he wants that...
02:57:38 <benmachine> if you want that to not typecheck, you can only add numbers which are known at compile time, which seems quite restrictive :)
02:58:55 <solrize> w00p, the really pointy-headed languages won't let you add x+y in that type, unless you supply a proof that x+y <=100
03:00:55 <develhevel> i make a small example in hpast just a scond
03:01:12 <w00p> i'm actually just playing around to see how deep the haskell type system go
03:03:05 <develhevel> here is my example: http://hpaste.org/47588/function how can help me?
03:04:48 <ivanm> develhevel: if choice == "1" then return input; else foo input
03:04:58 <frerich2> develhevel: A function always has to return values of the same type; in your code, "input" is a list of strings, but on the last line you return "()" which is a different type ("()").
03:05:07 <ivanm> though I don't get why you're doing that; it will just recurse until someone types in "1"
03:05:21 <ivanm> frerich2: the "return input" there is useless anyway
03:05:59 <frerich2> ivanm: Yes, the function is strange; I was just trying to clarify one thing (that you cannot return different types)
03:06:13 <develhevel> frerich2: but when i change it in return [] it also dont work
03:06:30 <ivanm> develhevel: why don't you actually try what I tell you to do for once?
03:06:46 <ivanm> or have you told your IRC client to ignore me?
03:07:05 <develhevel> ivanm: because i have some more choices only in this example its one
03:07:31 <ivanm> develhevel: why don't you try telling us what you actually want to do rather than a really bad example?
03:07:33 <develhevel> ivanm: dont ignore you :) so i should use some mire if else?
03:07:54 <ivanm> no, in that case there's probably a better way of doing it
03:08:29 <develhevel> i want to create a choise, then i type a 1, then the function is returnd, when i type a 2 the function is filtered and returned and then i type a 3 the programm exit
03:09:11 <ivanm> "the function is filtered" ? that doesn't make much sense
03:09:26 <ivanm> develhevel: i.e. you want a prompt?
03:09:34 <ivanm> I suggest a helper function
03:09:44 <develhevel> yes, sry for my bad english
03:09:46 <frerich2> develhevel: Ok, so you made sure that both 'return' yield the same value (IO [String]). However, consider the signature of 'when'. It's "Bool -> a () -> a ()"
03:09:59 <ivanm> frerich2: he doesn't want when
03:10:04 <frerich2> ivanm: Right.
03:10:16 <ivanm> develhevel: use System.Exit to get out of a program
03:10:23 <solrize> develhevel, yeah, return doesn't do what you think it does :)
03:11:18 * frerich2 thinks it would have been much nicer if "return" was called "wrap" and "<-" was a nicer name for a function called "wrap".
03:11:25 <develhevel> ivanm: System.Exit i use. solrize: how to do that?
03:11:32 <frerich2> In all the tutorials I read that "return wraps a given value in the monad", and I wondered why it'snot called "wrap" if it wraps things :)
03:11:43 <ivanm> frerich2: huh? why would <- be related to "wrap" ?
03:11:53 <benmachine> frerich2: in Applicative it's called 'pure' which is slightly nicer
03:11:58 <frerich2> ivanm: Err sorry, I mean "unwrap" for <-
03:12:09 <ivanm> frerich2: you don't like >>=
03:13:02 <ivanm> ?
03:13:03 <shachaf> frerich2: "wrap" is a pretty weird name that smells of monads-as-containers.
03:13:05 <ivanm> why ?
03:13:09 <ivanm> shachaf: agreed
03:13:18 <shachaf> "return" is pretty weird too, admittedly, but "wrap" is more biased if anything.
03:13:23 <benmachine> shachaf: well, monads-as-containers is a metaphor that works for some people
03:13:33 <ivanm> benmachine: but doesn't apply to all monads
03:13:52 <benmachine> ivanm: well, it depends how far you twist it :)
03:14:15 <shachaf> I think it causes more harm than good.
03:14:17 <ivanm> benmachine: a State monad is a container?
03:14:19 <frerich2> shachaf: Yes, that's the idea actually. I'm just a beginner myself but so far the mental image of a "Monad x" being something which "holds" a value of type "x" worked okay.
03:14:33 <shachaf> Even Cale, who originally wrote it, recommends Monads-as-computations instead now.
03:14:45 <shachaf> frerich2: Yep, unhelpful mental image.
03:15:08 <frerich2> Monads-as-computations? Hmmm.
03:15:16 <shachaf> http://www.haskell.org/haskellwiki/Monads_as_computation
03:15:24 <benmachine> personally I like monads-as-fancy-functions
03:15:29 <ivanm> I thought we sorted out once and for all that monads were _burritos_!
03:15:35 <benmachine> i.e. (a -> m b) being interesting rather than m a
03:15:35 <shachaf> benmachine: "functions"?
03:15:37 <companion_cube> monads-as-burritos is cool too
03:15:51 <benmachine> shachaf: the idea of a monad is that you can compose a -> m b with b -> m c and get a -> m c
03:16:00 <benmachine> (in this model)
03:16:04 <shachaf> http://www.haskell.org/pipermail/haskell-cafe/2007-August/030508.html
03:16:23 <roconnor> @type (>=>)
03:16:24 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
03:16:45 <shachaf> And it's associative by law. :-)
03:16:49 <benmachine> you can implement >>= in terms of >=>
03:17:03 <shachaf> Wait, wrong link.
03:17:07 <shachaf> I meant http://www.haskell.org/pipermail/haskell-cafe/2007-August/030506.html
03:17:23 <benmachine> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html <-- this is my favourite monad tutorial
03:17:54 <shachaf> benmachine: I never found that one particularly helpful.
03:18:03 <benmachine> shachaf: oh. I did :)
03:18:21 <shachaf> So say many people.
03:18:46 <benmachine> can't please everyone :P
03:19:26 <benmachine> :t \m f -> f <=< id $ m -- fwiw
03:19:26 <lambdabot> forall b (m :: * -> *) c. (Monad m) => m b -> (b -> m c) -> m c
03:22:44 <frerich2> shachaf: That second haskell-cafe link was quite enlightening
03:23:27 <dfilimon> hi guys, does anybody know how i can add 3 values of type IO Integer?
03:23:34 <dfilimon> say x :: IO Integer
03:23:39 <dfilimon> and I'd like f = x + x + x
03:23:42 <dfilimon> how could i do that?
03:23:45 <benmachine> dfilimon: there are a few ways
03:23:48 <shachaf> dfilimon: Those aren't values, they're computations that produce values if you run them.
03:23:51 <sipa> :t liftM2 (+)
03:23:52 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1 -> m a1
03:23:56 <benmachine> the simplest is with do-notation
03:24:04 <frerich2> shachaf: In particular, realizing that "Monad m => m Int" doesn't say anything at all aboout what the computation yields, since that's entirely up to the monad.
03:24:06 <benmachine> shachaf has a good point though
03:24:14 <benmachine> you'll only be able to get an IO Integer out
03:24:31 <sipa> you can lift the (+) operator to work on those computations though, with liftM2
03:24:32 * shachaf goes to sleep instead of arguing about monads.
03:24:51 <dfilimon> thanks that's great :)
03:24:52 <roconnor> what is that iteratee library that everyone likes?
03:25:08 <benmachine> roconnor: umm, enumerator?
03:25:19 <roconnor> I think that's it
03:25:30 <benmachine> well I don't know if everyone likes it but I'm guessing that's what you meant
03:25:38 <roconnor> :)
03:25:46 <benmachine> it's the version designed to be a bit simpler than the other one
03:25:49 <benmachine> at the cost of performance
03:25:54 <benmachine> (potentially)
03:25:57 <benmachine> ...I think
03:25:57 <roconnor> oh
03:26:25 <roconnor> well, maybe simple is a good way to start using the tech
03:26:29 <dfilimon> guys, another quick question
03:26:37 <dfilimon> if: let x = print "hello" >> return 2
03:26:45 <dfilimon> liftM2 (+) x x
03:26:51 <dfilimon> this prints "hello" twice
03:27:13 <dfilimon> i thought it would cache the value x
03:27:15 <benmachine> roconnor: don't trust me on the performance question, I don't actually know :P
03:27:35 <benmachine> dfilimon: the value x is an IO instruction
03:27:42 <benmachine> saying "print hello and then return 2"
03:27:43 <sipa> dfilimon: you give the computation twice
03:27:53 <benmachine> so if you use it twice, you've gotta print hello twice
03:28:02 <sipa> you can use liftM (*2) if you want to double the result of a computation
03:28:12 <dfilimon> no, i was just wondering if
03:28:14 <dfilimon> f = x + x
03:28:22 <dfilimon> calculates x twice
03:28:28 <benmachine> dfilimon: ah, that's a different question
03:28:32 <dfilimon> i wanted to see if that's the case so i added a print...
03:28:42 <benmachine> adding a print changes the meaning :)
03:28:51 <dfilimon> and if it's just f = x + x?
03:28:55 <sipa> dfilimon: x in your case is a computation, and the computation itself is only created once
03:28:55 <dfilimon> would it evaluate x twice?
03:28:58 <benmachine> so it might have been valid to calculate x only once, but once you put the print in it isn't anymore
03:29:01 <dfilimon> if x :: Integer
03:29:08 <blackh> dfilimon: Evaluation and execution (called 'sequencing') of I/O are two very different things.
03:29:08 <sipa> but you're still running it twice
03:29:19 <benmachine> dfilimon: it's technically up to the compiler, but it would probably re-use the x value
03:29:33 <benmachine> almost certainly, I'd've thought
03:29:36 <benmachine> there's some subtlety though
03:30:02 <dfilimon> i see, thanks a lot :)
03:30:09 <dfilimon> i have an exam coming up tomorrow
03:30:19 <dfilimon> and my prof likes trick questions
03:30:21 <benmachine> I have an exam this afternoon so there :P
03:30:27 <benmachine> (it's not haskell though)
03:30:27 <dfilimon> good luck ;)
03:30:29 <benmachine> thx
03:30:34 <roconnor> if x is a variable it will be likely evaluated once; if x is an expression, it will likely be evaluated twice (in GHC).
03:31:20 <frerich2> Actually, it's a bit annoying that there are so many "tutorials" on monads on them, because it's hard to tell the good (most importantly: comprehensible and correct) ones and the bad ones apart.
03:31:28 <benmachine> frerich2: yes, it is
03:31:56 <benmachine> possibly one could take haskellwiki to be an authoritative source
03:31:57 <benmachine> or #haskell
03:32:40 <Botje> frerich2: presenting and using the types early on is an indicator of good monad tutorials
03:33:09 <Botje> even better if they implement and show how to use some 'standard' monads
03:33:15 <frerich2> I've read so many tutorials now and every now and then I think I "got it", only to be told afew days later that "Well that's not *really* the essence of it". :-[
03:33:41 <Botje> frerich2: grab the state monad and start hacking something that uses state
03:33:53 <Botje> then start hacking something that uses reader or writer
03:34:05 <Botje> once you stop getting confused by the type errors, you 'get' monads
03:34:26 <dankna> yeah - it sounds like you're letting people tell you you don't understand when you actually have enough working knowledge of it.
03:34:52 <Botje> and please, don't go looking too far
03:35:16 <Botje> monads are a dead simple concept, and most tutorials make them out to be much harder than they are
03:35:56 <Botje> kind of like when I set out to learn about continuations
03:36:06 <Botje> i spent a week reading 'tutorials' and not really getting it
03:36:18 <Botje> but once you plonk down call-with-current-continuation in scheme, it's so obvious
03:36:25 <dankna> this is really an argument against tutorials in general, isn't it.
03:36:38 <dankna> which is fine with me, I've always been a fan of working from reference material.
03:37:04 <Botje> tutorials are wonderful for getting to know APIs
03:37:10 <Botje> but they're horrible for concepts :)
03:37:15 <dankna> yes, that's fair
03:52:35 <tibbe> mauke, the original author measure the difference between utf-8 and utf-16 and the latter was faster, possible due to GHC lays out the branches
03:53:36 <tibbe> mauke, the argument for switching to utf-8 is that these benchmarks might have unfairly benefited utf-16 as only the functions on Text (e.g. map) were benchmarked, instead of looking at something like encodeUtf8 . map . decodeUtf8
03:53:43 <tibbe> since utf-8 is *way* more common
03:54:52 <tibbe> mauke, I think the original authors were Tom Harper and Duncan Coutts
03:59:54 <sioraiocht> wah?
04:00:07 <sioraiocht> oh, this must be about Text
04:00:16 * ivanm passes sioraiocht a `t'
04:00:32 <sioraiocht> cheers =p
04:15:48 <adimit> tibbe: may I ask if unionWith is planned for unordered-containers' HashMap? (and if not, if you'd accept patches?)
04:17:56 <tibbe> adimit, I'll definitely accept patches
04:18:17 <tibbe> adimit, I just haven't had time to do it yet. Working on improvements to GHC that I hope will benefit unordered-containers eventually.
04:18:26 <adimit> tibbe: ok, lemme see if I can whip up something. I'm not a huge Haskell Guru, but I hope it'll help you.
04:18:29 <adimit> good to hear :-)
04:18:57 <tibbe> adimit, it shouldn't be too difficult if you start with union and add an extra parameter.
04:19:14 <tibbe> adimit, you will have to add the function to FullList as well and call it from HashMap.
04:19:20 <tibbe> (will probably be clear once you read the code)
04:19:26 <Dr_H> hello
04:19:31 <adimit> I just ran into an annoying problem: I tried to use iteratee's mapReduce with HashMap, and there are two problems: mapReduce uses the monoid instance (i intend to write a patch for that, too, because that's nearly useless)
04:19:49 <adimit> and there's no union-with function in HashMap, which is the second road block.
04:20:09 <tibbe> adimit, the second is easily fixed
04:20:18 <adimit> tibbe: thanks for the hints, I'll go do it now, then.
04:20:22 <tibbe> adimit, are you saying that the HashMap Monoid instance doesn't do what you want?
04:20:50 <adimit> I thought actually, that that writing parameterized mapReduce will be easier.
04:20:56 <tibbe> ok
04:20:58 <tibbe> it might
04:21:13 <adimit> no, the monoid instance will not combine the values (which in my case are counts.)
04:21:29 <tibbe> the monoid instance might actually be a bit more efficient if it applies in your use case and the author of mapReduce used INLINABLE correctly (in order to get call-site specialization)
04:21:42 <adimit> currently, the monoid instance for hashmap does a union, which is exactly not what i want.
04:22:02 <adimit> (i.e. it just overwrites the old value, and discards it.
04:22:02 <tibbe> adimit, arguably the monoid instance for HashMap should be: instance Monoid v => Monoid (HashMap k v) where ...
04:22:44 <tibbe> adimit, would would have to have the HashMap be HashMap ByteString Sum (where Sum is a newtype wrapper for Int that provides a Sum monoid instance)
04:22:50 <adimit> in which case, for example, Monoid (HashMap k Int) would add the Int values?
04:23:09 <adimit> ah,
04:23:11 <tibbe> There's no instance for Monoid Int, as there are several possible ones
04:23:12 <adimit> true! that's smart.
04:23:27 <tibbe> so you pick a newtype wrapper that does what you want e.g. First, Last, Product, or Sum
04:23:51 <adimit> yes, that Sum would be nifty. I think you're right, that's a much prettier design (but its intended use should be documented.)
04:23:59 <tibbe> yeah
04:24:07 <tibbe> well, HashMap currently doesn't support it
04:24:13 <tibbe> but I would be for fixing the monoid instance
04:24:15 <tibbe> (I think)
04:24:41 <adimit> I will not tackle that yet. I think that unionWith is a little morge general and useful right now (methinks.)
04:25:11 <adimit> afterwards, I'll try to see if it's possible to migrate the monoid instance like you suggested.
04:25:37 <tibbe> sure
04:25:41 <tibbe> do unionWith first
04:25:52 <tibbe> then the instance is just mappend = unionWith mappend
04:25:59 <adimit> aye.
04:26:20 <tibbe> I'm working on changing the underlying data structure to a hash-array mapped trie
04:26:42 <tibbe> I will port all functions in unordered-containers when I change the underlying type so don't worry about wasting work
04:26:48 <adimit> sounds interesting :-)
04:26:50 <adimit> ok, thanks!
04:26:54 <tibbe> that should bring the memory usage down quite a bit
04:26:58 <tibbe> you're welcome
04:27:26 <adimit> sounds good. I did get my memory usage down by just transforming everything to Text. I tried Data.SmallString, but that made GHC segfault, and I'm stilled puzzled why.
04:28:01 <tibbe> ok
04:28:30 <tibbe> Text takes 3 words less than ByteString (but the UTF-16 encoding makes it break even with ByteString at about 24 characters)
04:28:38 <tibbe> assuming the ByteString stores utf-8 data
04:28:51 <tibbe> after this summer Text is hopefully utf-8
04:29:03 <adimit> I really hope so.
04:29:20 <adimit> I really love the Data.Text library as it is already, though. Such a nice design.
04:29:39 <ivanm> tibbe: you mean we've got to wait until the beginning of next year? :o
04:29:44 <ivanm> :p
04:30:13 <tibbe> ivanm, for Text in utf-8?
04:30:20 <tibbe> ivanm, august hopefully
04:30:49 <ivanm> tibbe: but it's just started to be winter!
04:30:50 <ivanm> :p
04:30:59 <tibbe> it's a bit speculative though. It hinges on Jasper being able to convert the internal representation without losing performance.
04:31:04 <tibbe> ivanm, doh
04:31:08 <tibbe> ivanm, australia?
04:31:12 <ivanm> yup :D
04:31:24 <adimit> also, Germany. It's raining here, and it's cold. IN JUNE
04:31:33 <Saizan> adimit: yay!
04:31:37 <tibbe> it's a bit rainy and cold here in switzerland as well
04:48:30 <Feuerbach> Does hSetBuffering have any effect on hGetBuf?
04:49:11 <quicksilver> good question.
04:49:12 <quicksilver> probably.
04:58:00 <blackdog> hey, any recommendations on doing distributed computation in haskell?
04:58:19 <blackdog> i'm all over parallelism, but is there an easy way of distributing work over multiple machines?
05:10:08 <solrize> blackdog, http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/remote.pdf
05:14:51 <o-_-o> If I have a polynomial, like k0*n^0 + k1*n^1 + k2*n^2 +...+km*n^m. The values k0..km are in a list, and the n is given before hand. Is it possible to write a function, without using recursion ? Only map foldr and friends ?
05:15:23 <opqdonut> yes
05:15:28 <o-_-o> I have written a recursive function which uses accumulators and map and foldr, but I wanted to know if there is someway to avoid that...
05:15:48 <poucet> > iterate (*5) 1
05:15:49 <lambdabot>   [1,5,25,125,625,3125,15625,78125,390625,1953125,9765625,48828125,244140625,...
05:15:54 <opqdonut> it's just a simple fold
05:16:05 <poucet> > sum $ zipWith (*) (iterate (*5) n) [1,2,3]
05:16:07 <lambdabot>   0 + n * 1 + n * 5 * 2 + n * 5 * 5 * 3
05:16:08 <Twey> > map (5 ^) [0 ..]
05:16:10 <lambdabot>   [1,5,25,125,625,3125,15625,78125,390625,1953125,9765625,48828125,244140625,...
05:16:10 <opqdonut> or a simple zipWith and a fold
05:16:19 <poucet> > sum $ zipWith (*) (iterate (*n) 1) [1,2,3]
05:16:20 <lambdabot>   0 + 1 * 1 + 1 * n * 2 + 1 * n * n * 3
05:16:45 <o-_-o> ah...nice
05:16:50 <o-_-o> :-)
05:16:57 <poucet> I typo'd that 'n', but lambdabot nicely caught it ;)
05:17:05 <Twey> Hehe
05:17:18 <poucet> > sum $ zipWith (*) [1,2,3] (iterate (*n) 1)
05:17:20 <lambdabot>   0 + 1 * 1 + 2 * (1 * n) + 3 * (1 * n * n)
05:17:43 <poucet> hmm I was hoping it would collapse the 2*1 if on the same side
05:17:55 <sipa> @let toPolFun lst x = foldl (\a e -> a*x+e) 0 lst
05:17:56 <lambdabot>  Defined.
05:18:05 <sipa> > toPolFun [2,3,4] x
05:18:07 <lambdabot>   ((0 * x + 2) * x + 3) * x + 4
05:18:21 <sipa> hmm, no
05:19:26 <parcs> > foldr (\a e -> a*x+e) 0 [2,3,4]
05:19:27 <lambdabot>   2 * x + (3 * x + (4 * x + 0))
05:19:46 <magicman> That, or swap the a and e in the foldl version.
05:20:49 <o-_-o> ok..time for the actual problem
05:21:16 <o-_-o> I get an input string which looks like "1:12:43" "1:2:34:43" etc.,
05:21:20 <o-_-o> nevermind
05:21:34 <o-_-o> oh..well since I started I may as well complete it
05:21:50 <kaito_> That lambdabot is the coolest thing ever.
05:22:04 <poucet> > splitBy (==':') "1:12:43"
05:22:06 <lambdabot>   Not in scope: `splitBy'
05:22:17 <parcs> @hoogle splitAt
05:22:18 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
05:22:18 <lambdabot> Data.ByteString splitAt :: Int -> ByteString -> (ByteString, ByteString)
05:22:18 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
05:22:24 <o-_-o> it needs to be done as 43 * 60 ^0 + 12 * 60^ 1+ 1 *60^2
05:22:32 <parcs> @hoogle splitEvery
05:22:32 <lambdabot> No results found
05:22:39 <poucet> http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
05:22:39 <o-_-o> I used splitOn from Data.List.Split
05:22:55 <o-_-o> > splitOn ":" "1:12:43"
05:22:55 <lambdabot>   Not in scope: `splitOn'
05:23:02 <poucet> so let's assume you already have the numbers
05:23:04 <o-_-o> > Data.List.Split.splitOn ":" "1:12:43"
05:23:05 <lambdabot>   Not in scope: `Data.List.Split.splitOn'
05:23:09 <poucet> > [1,12,43]
05:23:10 <lambdabot>   [1,12,43]
05:23:11 <o-_-o> grrr.....
05:23:57 <poucet> > let f n l = sum $ zipWith (*) (reverse l) (iterate (*n) 1) in f 5 ["1","12","43"]
05:23:58 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
05:23:58 <lambdabot>    arising from a use of `f'...
05:24:02 <poucet> > let f n l = sum $ zipWith (*) (reverse l) (iterate (*n) 1) in f 5 $ map read ["1","12","43"]
05:24:04 <lambdabot>   128
05:24:05 <o-_-o> anyway and then converted it to float using read ::Float and then wrote myself a function with an accumulator to finish the job, but this is better
05:24:26 <poucet> like so?
05:25:01 <o-_-o> no 1 * 60^2 + 12 * 60^1 + 43 * 60^0
05:25:09 <o-_-o> it is reverse
05:25:13 <poucet> I reverse it
05:25:24 <o-_-o> hmm..
05:25:31 <poucet> > 1 * 60^2 + 12 * 60^1 + 43 * 60^0
05:25:33 <lambdabot>   4363
05:25:33 <aavogt> > words . map (\x -> case x of ':' -> ' '; _ -> x) $ "1:12:43"
05:25:34 <lambdabot>   ["1","12","43"]
05:25:37 <o-_-o> it is 1 hour 12 min and 43 secs actually :-p
05:25:37 <poucet> ah
05:26:04 <o-_-o> so 3600 + 720 + 43
05:26:06 <poucet> > let f n l = sum $ zipWith (*) (reverse l) (iterate (*n) 1) in f 60 $ map read ["1","12","43"]
05:26:07 <lambdabot>   4363
05:26:15 <poucet> right, I just needed to rpelace the 5 by 60
05:26:21 <opqdonut> > foldl (\acc x -> acc * n + x) [1,12,43]
05:26:22 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
05:26:22 <lambdabot>         against inferred ...
05:26:31 <opqdonut> gah
05:27:29 <opqdonut> > foldl (\acc x -> acc * n + x) 0 [1,12,43]
05:27:30 <lambdabot>   ((0 * n + 1) * n + 12) * n + 43
05:27:45 <opqdonut> that's the way to not reverse the list
05:29:03 <o-_-o> heh...amazing
05:30:01 <hqm42> how to add a derived typeclass to an allready existing datatype? Foo is defined by a library i am using. i need something like: instance Show Foo deriving
05:30:13 <mauke> deriving instance Show Foo
05:30:38 <hqm42> thx a lot
05:31:23 <opqdonut> (that's also the way to do the least multiplications)
05:31:29 <applicative> do you need the StandaloneDeriving pragma?
05:31:31 <opqdonut> (or at least less)
05:35:09 <applicative> hqm42 right, you add {-#LANGUAGE StandaloneDeriving #-} Haven't used that for a while....
05:36:13 <poucet> You can just define the instance manually
05:42:20 <ion> It would be nice if Prelude had a separate type classes for Show (accurate representation) and SomethingElse (Stringify? Printable?) for a pretty representation, à la Ruby’s inspect and to_s. Stringify for a representation of XML might return the serialized XML; stringify for Rational might return a string like "1/3" or "5"; stringify for String might be id; stringify for ByteString might be toString.
05:42:49 <Twey> Agreed
05:43:36 <Twey> Or, well… we should replace String with Text, anyway :þ
05:49:44 <applicative> it seems there are typeclasses Pretty around.  But one associated with say the prettyprinting library in base might be cool.
06:13:07 <develhevel> how to write a function with \ which get a (String, String, (String, String) [(String,String)]) and only get the first String?
06:13:42 <sipa> (\(x,_,_,_) -> x)
06:15:22 <quicksilver> or (\x _ _ _ -> x)
06:15:27 <quicksilver> if they're not really in a tuple.
06:19:34 <Twey> :t fst4
06:19:35 <lambdabot> Not in scope: `fst4'
06:19:38 <Twey> :<
06:24:24 <Younder> develhevel, _ means 'don't cate'
06:24:50 <develhevel> thx, works
06:24:53 <Younder> care
06:25:04 * hackagebot seqloc 0.2.1 - Handle sequence locations for bioinformatics  http://hackage.haskell.org/package/seqloc-0.2.1 (NicholasIngolia)
06:25:39 <ion> You probably want to define a new type if you find yourself working with something like (String,String,(String,String),[(String,String)])
06:26:12 <develhevel> how to cast a sequence [1..] into a String that i could use putStrLn?
06:26:20 <ion> show
06:26:37 <develhevel> ion: yes but i only have it one time
06:26:52 <Younder> and..
06:27:05 <ion> NB: print = putStrLn . show
06:27:58 * dixie yesterday infected with haskell one person at work! (and gave him Graham Hutton book)
06:28:43 <shapr> yay!
06:28:50 <arcatan> now remember, we should be avoiding success
06:29:14 * Younder signs the carge for the assassin of ion
06:29:26 <luite> he's not really infected until he has started a weblog in functional programming with at least one monad tutorial ;)
06:29:37 <luite> *on
06:29:48 <arcatan> hey, by that measure i'm still not infected!
06:30:02 <develhevel> ion: hm, dont work, i have a like [(Int, String)] and want to make: mapM_ (\(x,y) -> print $ x ++ y) list
06:30:40 <ion> Is there a type error?
06:30:47 <develhevel> ion: yes
06:30:52 <Jeanne-Kamikaze> show the x ?
06:31:12 <Younder> x is a integer, not a string
06:31:13 <ion> Ah, (Int, String)
06:31:16 <ion> Missed the type.
06:31:45 <ion> How about just mapM_ print list?
06:32:44 <develhevel> ion: got it :)
06:32:54 <develhevel> show x fixed it
06:33:01 <mun_> hi
06:34:09 <Younder> are you?
06:38:06 * hackagebot hakyll 3.2.0.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.0.0 (JasperVanDerJeugt)
06:52:07 * hackagebot seqloc-datafiles 0.1.1 - Read and write BED and GTF format genome annotations  http://hackage.haskell.org/package/seqloc-datafiles-0.1.1 (NicholasIngolia)
06:53:11 <develhevel> i have a list of ["1","2"] howto convert it to Int [1,2]? i know there is read but "let new = map read old" dont work
06:53:55 <opqdonut> it should.
06:53:55 <luite> > map read ["1", "2"] :: [Int]
06:53:57 <lambdabot>   [1,2]
06:54:12 <luite> develhevel: read is polymorphic, you may need to add a type signature
06:54:43 <develhevel> ah, with the :: [Int] it work
07:00:03 <Saizan> it's a bit ironic how they invented extended defaulting explicitly for ghci but never made NoMR its default
07:06:42 <develhevel> how can i write two operations like: "x<-getLine; print x" into one operation/line?
07:07:12 <Saizan> do x <- getLine; print x
07:07:25 <opqdonut> getLine >>= print
07:07:48 <Saizan> (do is part of the syntax there)
07:08:34 <quicksilver> if you were already in a do block
07:08:41 <quicksilver> you can actually write "x <- getLine; print x"
07:08:45 <quicksilver> exactly as you had it ;)
07:09:41 <develhevel> okay, have two more questions: how can give me a small easy to understand example with <$>
07:09:45 <develhevel> <*>
07:09:49 <fragamus> or getline >>= print
07:10:48 <opqdonut> develhevel: (+) <$> read <*> read
07:10:55 <derdon> still true: http://twitter.com/#!/donz0r/status/60477736635998208 :)
07:11:45 <opqdonut> er, sorry, bad example
07:12:38 <opqdonut> develhevel: add two random numbers: (+) <$> randomRIO (0,2) <*> randomRIO (4,7)
07:12:46 <opqdonut> :t (+) <$> randomRIO (0,2) <*> randomRIO (4,7)
07:12:48 <lambdabot> forall a. (Num a, Random a) => IO a
07:13:59 <develhevel> thx opqdonut
07:16:22 <ion> a <$> b <*> c <*> d is equivalent to pure a <*> b <*> c <*> d which is (given equivalent Applicative and Monad instances) equivalent to do a' <- pure a; b' <- b; c' <- c; d' <- d; a' b' c' d'
07:18:22 <ion> Looking at e.g. Maybe (where pure = Just): Just (+1) <*> Just 2 == Just 3, Nothing <*> _ == Nothing, _ <*> Nothing == Nothing.
07:19:22 <ion> In f <$> a <*> b which is equivalent to pure f <*> a <*> b (and in this case Just f <*> a <*> b), if any one of them is Nothing, the result is Nothing. Otherwise it’s Just (f a b).
07:20:18 <ion> Sorry. Otherwise it’s Just (f a' b') where a' and b' are a and b unwrapped from the Just.
07:21:15 <develhevel> ion: thank you :)
07:22:05 <synesthesia> can anyone point me to the 'conanical' introduction to FRP (I'm referring to the paper)
07:22:40 <synesthesia> there seems to be a lot of recent work, but I'm mostly looking for the introductory paper that first explored these ideas (if such a thing exists)
07:23:56 <derdon> Data.Char.isMark '^'
07:24:03 <derdon> why is that false?
07:24:12 * hackagebot samtools 0.1.2 - Binding to the C samtools library  http://hackage.haskell.org/package/samtools-0.1.2 (NicholasIngolia)
07:24:13 <derdon> the same with Data.Char.isMark '´'
07:24:41 <ion> The Applicative and Monad instances for List, on the other hand, behave akin to nested ‘foreach’s. [(+1), (+2), (+3)] <*> [1] == [2, 3, 4]. [(+1), (+2), (+3)] <*> [1, 11] == [2, 12, 3, 13, 4, 14]. [(+)] <*> [1,2] <*> [10,20] == [11, 21, 12, 22] == (+) <$> [1,2] <*> [10,20]
07:24:51 <mauke> derdon: because they're not marks
07:25:02 <derdon> mauke: give me examples which return true
07:25:13 * hackagebot samtools-enumerator 0.1.1 - Enumerator interface to SamTools library  http://hackage.haskell.org/package/samtools-enumerator-0.1.1 (NicholasIngolia)
07:25:15 * hackagebot samtools-iteratee 0.2.1 - Iteratee interface to SamTools library  http://hackage.haskell.org/package/samtools-iteratee-0.2.1 (NicholasIngolia)
07:25:19 <mauke> > isMark 'a'
07:25:21 <lambdabot>   False
07:25:27 <mauke> > isMark '̈'
07:25:29 <lambdabot>   True
07:25:44 <ion> > isMark "Shuttleworth"
07:25:45 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
07:25:45 <lambdabot>         against inferred type...
07:25:53 <mauke> > filter isMark [minBound ..]  -- enjoy your zalgo
07:25:54 <lambdabot>   "\768\769\770\771\772\773\774\775\776\777\778\779\780\781\782\783\784\785\7...
07:25:58 <mauke> aww
07:26:06 <mauke> > text $ filter isMark [minBound ..]
07:26:07 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
07:26:16 <mauke> > var $ filter isMark [minBound ..]
07:26:18 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
07:26:22 <mauke> :-(
07:26:31 <erus`> > toEnum 'a'
07:26:33 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
07:26:33 <lambdabot>         against inferred type ...
07:26:53 <erus`> > ord 'a'
07:26:54 <lambdabot>   97
07:27:43 <kstt> What On Earth could I do to prevent cabal from breaking all the time ??? I spend hours each month fixing its errors :(
07:27:50 <mauke> > text "\255"
07:27:52 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
07:27:59 <ion> > isMark shuttleworth
07:28:00 <lambdabot>   True
07:28:03 <dcoutts> kstt: use --dry-run
07:28:09 <dcoutts> kstt: and await the next release
07:28:13 <Cale> synesthesia: A slightly different typo would have produced Conalical, which would have been totally appropriate, since I'd then be able to link you to Conal Elliott's work :) I'm actually not sure what the very initial stuff was, but there was a system called FrTime in scheme which was pretty early...
07:28:27 <derdon> > shuttleworth
07:28:28 <lambdabot>   Not in scope: `shuttleworth'
07:28:39 <dcoutts> kstt: and in the mean time, read the Cabal "SICP" page
07:28:50 <djahandarie> kstt, also, read http://www.vex.net/~trebla/haskell/sicp.xhtml
07:28:54 <djahandarie> Oops, too late :)
07:28:59 <kstt> dcoutts: thanks. I just updated it because it asked to be. cabal install cabal-install -> everything is broken again :(
07:29:14 <erus`> >let upper s = map (\c -> if c >= 'a' && c <= 'z' then chr $ (ord c) + 26 else c) in upper "Hello"
07:29:18 <erus`> > let upper s = map (\c -> if c >= 'a' && c <= 'z' then chr $ (ord c) + 26 else c) in upper "Hello"
07:29:19 <lambdabot>   Overlapping instances for GHC.Show.Show
07:29:19 <lambdabot>                              ([GHC....
07:29:46 <erus`> :(
07:29:46 <Saizan> > let upper = map (\c -> if c >= 'a' && c <= 'z' then chr $ (ord c) + 26 else c) in upper "Hello"
07:29:47 <lambdabot>   "H\DEL\134\134\137"
07:30:03 <ion> H\DEL\134\134\137 to you, too.
07:30:15 <Cale> synesthesia: See also Fran and Yampa, which were pretty early on...
07:30:26 <erus`> > let upper s = map (\c -> if c >= 'a' && c <= 'z' then chr $ (ord c) + 26 else c) s in upper "Hello"
07:30:27 <mauke> > map (xor ' ') "Hello"
07:30:27 <lambdabot>   "H\DEL\134\134\137"
07:30:28 <lambdabot>   No instance for (Data.Bits.Bits GHC.Types.Char)
07:30:28 <lambdabot>    arising from a use of `D...
07:30:34 <mauke> oh u
07:30:44 <mauke> > map (chr . xor 32 . ord) "Hello"
07:30:45 <kstt> Dear, that's a long reading just to get a simple package manager to work
07:30:46 <lambdabot>   "hELLO"
07:30:48 <Saizan> erus`: the 's'
07:31:04 <erus`> i added it
07:31:27 <Saizan> ah, yeah, misread
07:33:24 <synesthesia> Cale: I'm leafing through Conal's work right now, and thanks ;-)
07:35:21 <Cale> preflex: seen Conal
07:35:22 <preflex>  Conal was last seen on #haskell 1 day, 15 hours, 5 minutes and 20 seconds ago, saying: Peaker: sure. i see a role for iteratees in imperative/nondenotative programming.
07:35:39 <Cale> synesthesia: He often hangs around in here, you might catch him sometime :)
07:36:16 <quicksilver> nothing nondenotative about iteratees
07:36:19 <roconnor> Cale: is fingertree-psqueue better than PSQueue?
07:36:29 <quicksilver> quite straightforward to make a semantics of streams or whatever
07:36:42 <quicksilver> sometimes conal just tries to be provocative I think :)
07:38:43 <Saizan> he's making me hate any word starting with "denot"
07:39:20 <synesthesia> quicksilver: this 'provocative' streak seems to be common to many of the FP bloggers; c.f. ML's Rob Harper (http://existentialtype.wordpress.com/)
07:39:31 <jmcarthur> :(
07:39:33 <synesthesia> that said, I do enjoy the flaming
07:39:39 <Philippa> yeah. Honestly, we need less of people promoting their ideas by trolling
07:40:04 <Philippa> especially on IRC
07:40:10 <synesthesia> ah, that would be unpleasant
07:41:01 <Philippa> I'm being a little unkind - but only a little given how I've seen Conal react to less-than-outright-enthusiasm when people join in attempting to figure stuff out
07:41:30 <roconnor> quicksilver: how do you mean "quite straightforward to make a semantics of streams"?
07:41:36 <Philippa> (if anyone wants to pull the "don't talk behind his back like that!" thing, I'd be happy to talk it through with him if it came to that)
08:08:47 <erus`> Philippa: who is trolling?
08:13:54 <hansiiii> how could help me get these two code snippes more simple and effecitve: http://hpaste.org/47590/help_make_it_simpel
08:32:03 <byorgey> hansiiii: http://hpaste.org/47591/help_make_it_simpel_annotatio
08:33:33 <Peaker> every time someone is looking for conal it flags my IRC client :P
08:35:44 <byorgey> Peaker: um... and whose fault is that? =)
08:36:48 <ClaudiusMaximus> sane limit for module size?  i have a couple over 400 lines still (had one over 1200 before i split it up...)
08:38:46 <byorgey> ClaudiusMaximus: sane according to what purpose?
08:38:55 <byorgey> and how good is your documentation?
08:39:10 <ClaudiusMaximus> byorgey: errr, documentation is somewhat absent
08:39:48 <byorgey> well, 400 lines with no documentation is rather long =)
08:39:51 <ClaudiusMaximus> yes..
08:40:21 <byorgey> because it is hard to find your way around such a module
08:40:29 <ClaudiusMaximus> the bulk of one module is boring gtk initialization...
08:40:45 <byorgey> oh, if it's boring, then by all means =)
08:41:31 <zygoloid> hansiiii: a slightly simpler way of doing the second thing: http://hpaste.org/paste/47591/help_make_it_simpel_annotatio#p47593
08:42:01 <byorgey> zygoloid: ah, nice
08:42:41 <lispy> good morning!
08:47:01 <dbpatterson> are there any libraries that help with formatting calendar output? ie, that'll give a month's worth of days in a rectangular list of lists, etc
08:47:51 <byorgey> good morning lispy!
08:48:34 <dbpatterson> or, barring that, is there any way to get the time package to give days of the week? In seems to only deal with numbers...
08:51:53 <monochrom> Data.Time.Calendar.WeekDate
08:51:57 <benmachine> dbpatterson: any of this http://hackage.haskell.org/packages/archive/time/1.2.0.5/doc/html/Data-Time-Calendar-OrdinalDate.html help?
08:52:05 <benmachine> or what monochrom said
08:53:38 <benmachine> dbpatterson: also, formatTime in Data.Time.Format has a few weekday formats
08:53:48 <dbpatterson> benmachine: yeah, that should work, thanks :) - monochrom: it seems like "Week" dates arent normal years…
08:54:18 <dbpatterson> OrdinalDate huh. wouldntve guessed that.
08:54:46 <benmachine> well I didn't guess it, I just looked at Data.Time.Calendar.*
08:54:53 <benmachine> until I found one that looked likely :)
08:56:24 * hackagebot persistent-equivalence 0.2 - Persistent equivalence relations (aka union-find)  http://hackage.haskell.org/package/persistent-equivalence-0.2 (ChrisSmith)
09:00:56 <kmc> good morning #haskell
09:01:18 <copumpkin> good morning kmc
09:01:31 <tgeeky> holla!
09:01:38 <Saizan> good morning to you, kmc
09:01:49 <kmc> yay friendly people
09:02:11 <benmachine> kmc: are there ever anything else :o
09:02:21 <tgeeky> benmachine: serial killers, Hitler
09:02:25 <tgeeky> that's it though
09:02:26 * kakos is Hitler
09:02:33 <kmc> IRC trolls
09:02:36 <kmc> bots
09:02:46 <tgeeky> hm. this persistent-equivalence is kind of cute
09:02:47 <monochrom> monochroms
09:02:56 <benmachine> man, you want them to be friendly AND people, that's kinda picky
09:03:19 <tgeeky> interesting that the latest version broke the docs
09:03:47 <tgeeky> maybe they take time to build
09:04:12 <kmc> lambdabot is not a friendly bot
09:04:17 <kmc> @slap lambdabot
09:04:17 * lambdabot orders her trained monkeys to punch lambdabot
09:04:26 <kmc> @vixen screw you
09:04:26 <lambdabot> i drive a pickup truck
09:04:35 <tgeeky> that doesn't even...
09:04:40 * zygoloid didn't manage to figure out how persistent-equivalence uses unsafePerformIO (or why it's safe)
09:04:53 <develhevel> i have a problem, i use the function (read :: Read a => String -> a) to transform a String to a Int ["1", "2"] -> [1,2] when i insert a "a" i get a error: "Prelude.read: no parse" how to catch this error?
09:05:00 <monochrom> she means she will run the truck over you
09:05:22 <kmc> develhevel, use "reads"
09:05:35 <kmc> > reads "1" :: [(Int,String)]
09:05:35 <lambdabot>   [(1,"")]
09:05:38 <kmc> > reads "a" :: [(Int,String)]
09:05:39 <lambdabot>   []
09:05:44 <kmc> it gives a list of possible parses
09:06:10 <kmc> what you really want is read :: (Read a) => String -> Maybe a
09:06:17 <kmc> which should be in the standard lib, but isn't
09:06:20 <kmc> but you can build it from "reads"
09:06:25 <ion> > (reads :: ReadS Integer) "1"
09:06:26 <lambdabot>   [(1,"")]
09:06:27 <ulfdoz> > reads "deadbeaf"
09:06:27 <kmc> :t fmap fst . listToMaybe
09:06:28 <lambdabot>   []
09:06:28 <lambdabot> forall a b. [(a, b)] -> Maybe a
09:06:33 <kmc> :t fmap fst . listToMaybe . reads
09:06:34 <lambdabot> forall a. (Read a) => String -> Maybe a
09:06:45 <kmc> @let safeRead = fmap fst . listToMaybe . reads
09:06:46 <lambdabot>  Defined.
09:06:50 <kmc> > safeRead "1" :: Maybe Int
09:06:51 <lambdabot>   Just 1
09:06:52 <kmc> > safeRead "a" :: Maybe Int
09:06:53 <lambdabot>   Nothing
09:06:58 <dolio> There's a readEither in the GHC libs, but it's not exported anywhere.
09:07:02 <Igloo> kmc: The problem with making a standard lib for it is whether you allow trailing whitespace or anything
09:07:03 <benmachine> > safeRead "23banana" :: Maybe Int
09:07:04 <lambdabot>   Just 23
09:07:08 <kmc> *nod*
09:07:15 <ulfdoz> ah, got it. Interesting.
09:07:22 <benmachine> Igloo: is that such a huge problem? :P
09:07:31 <kmc> @let saferRead x = case read x of [(v,"")] -> Just v; _ -> Nothing
09:07:32 <lambdabot>  Defined.
09:07:35 <kmc> err
09:07:36 <kmc> @unlet
09:07:36 <lambdabot>  Defined.
09:07:38 <dolio> What does read do with trailing whitespace?
09:07:38 <kmc> @let saferRead x = case reads x of [(v,"")] -> Just v; _ -> Nothing
09:07:39 <lambdabot>  <local>:2:0:
09:07:39 <lambdabot>      Warning: Pattern match(es) are overlapped
09:07:39 <lambdabot>               In...
09:07:42 <benmachine> @undefine
09:07:46 <kmc> @let saferRead x = case reads x of [(v,"")] -> Just v; _ -> Nothing
09:07:46 <lambdabot>  Defined.
09:07:50 <kmc> @let safeRead = fmap fst . listToMaybe . reads
09:07:51 <lambdabot>  Defined.
09:07:55 <benmachine> @let
09:07:56 <lambdabot>  Defined.
09:08:04 <benmachine> useful.
09:08:05 <kmc> > safeRead "23banana" :: Maybe Int
09:08:07 <lambdabot>   Just 23
09:08:08 <kmc> > saferRead "23banana" :: Maybe Int
09:08:09 <lambdabot>   Nothing
09:09:09 <develhevel> hm dont understand it :(, perhaps you can change this, so that it work: map read ["1","2","a"] :: [Int]
09:09:11 <dolio> > read "21    " :: Int
09:09:12 <lambdabot>   21
09:09:40 <kmc> let safeRead = fmap fst . listToMaybe . reads in map safeRead ["1","2","a"] :: [Maybe Int] -- develhevel
09:09:42 <ion> ghci> let natural :: Parser Integer; natural = read <$> many1 digit in parse (natural <* eof) "" <$> ["1", "1x"]
09:09:45 <ion> [Right 1, Left (line 1, column 2): unexpected 'x' expecting digit or end of input]
09:09:52 <kmc> but you might want to make "safeRead" a top-level function instead
09:09:57 <dolio> What is the "a" supposed to produce?
09:10:01 <dolio> 10?
09:10:49 <kmc> > let safeRead = fmap fst . listToMaybe . reads in map safeRead ["1","2","a"] :: [Maybe Int]
09:10:50 <lambdabot>   [Just 1,Just 2,Nothing]
09:12:05 <develhevel> kmc: perhaps it is easyer for me to run throw the list and check if every entry is a Int?
09:13:11 <ion> Perhaps it’s easier to use Parsecl
09:13:20 <ion> Parsec even.
09:13:50 <develhevel> grml must go offline, thx for help bye
09:15:59 <sully> is there a standard function for determining if one list is a subsequence of another?
09:16:17 <dolio> isInfixOf?
09:16:46 <sully> I don't want it to be "whole and intact"
09:16:54 <sully> "ace" is a subsequence of "abcde"
09:17:13 <dolio> Then I think the answer is no.
09:17:40 <nihtml> sully: all and elem ? :}
09:17:47 <benmachine> nihtml: doesn't quite do it
09:17:49 <ziman> I'd say there are lcs algorithms on hackage.
09:17:57 <sully> I don't want lcs, either
09:17:59 <benmachine> I think you could do it with a short-ish foldr
09:18:06 <sully> I mean, what I want is a three line function or something
09:18:31 <periodic> If you're not doing generalized common subsequences it's a quick greedy algorithm, right?
09:18:38 <sully> yeah, it isn't hard
09:18:45 <sully> I just didn't want to rewrite standard library code
09:18:58 <periodic> Yeah, I don't think it's a common one...
09:19:09 <sully> so, the all and elem thing doesn't work for the question I asked
09:19:34 <sully> but does work for what I am trying to do, which is seeing whether a multiset represented as a sorted list is a subset of another
09:19:44 <periodic> If you hoogle for [a] -> [a] -> Bool I'd expect it would come up, but I dont' see anything.
09:19:48 <benmachine> isSubSeqOf [] ys = True; isSubSeqOf (x:xs) ys = isSubSeq xs (drop 1 . dropWhile (/= x) $ ys)
09:20:15 <benmachine> oh um
09:20:28 <benmachine> need a isSubSeqOf xs [] = False in there
09:20:38 <benmachine> (after the first clause)
09:20:38 <sully> isSubSeqOf xs ys = xs `elem` subsequences ys
09:20:39 <sully> :P
09:20:44 <sully> "no"
09:21:04 <byorgey> benmachine: that doesn't quite work either, if the last element of xs is not in ys
09:21:18 <benmachine> byorgey: oh, um, yes, bother
09:21:42 <byorgey> benmachine: I guess you need first  isSubseqOf [] [] = True, then the xs [] -> False case, then the [] ys -> True case
09:22:06 <dolio> If you switch drop 1 to tail, it'll at least error out. :)
09:22:15 <byorgey> =)
09:23:17 <benmachine> isSubSeqOf [] ys = True; isSubSeqOf xs [] = False; isSubSeqOf (x:xs) ys = case dropWhile (/= x) ys of [] -> False; _:zs -> isSubSeq xs zs
09:24:05 <sully> isSubSeqOf [] _ = True
09:24:05 <sully> isSubSeqOf _ [] = False
09:24:05 <sully> isSubSeqOf (x:xs) (y:ys) = if x == y then isSubSeqOf xs ys else isSubSeqOf (x:xs) ys
09:24:10 <sully> is mine
09:24:31 <benmachine> yeah that's simpler
09:24:44 <benmachine> I was trying to avoid recursion but failed :P
09:24:44 <periodic> damnit, sully.
09:24:50 <periodic> I just finished testing that.
09:24:59 <benmachine> now make it a foldr
09:25:27 <sully> I think that this is probably the cleanest implementation and I'm going to leave it like this
09:25:35 <sully> I don't feel too guilty about explicit recursion
09:25:58 <kmc> :t isInfixOf
09:25:58 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
09:26:17 <sully> doesn't do the same thing
09:26:22 <kmc> i see
09:26:39 <sully> > isInfixOf "ace" "abcde"
09:26:40 <lambdabot>   False
09:26:46 <sully> I want that to be True
09:26:50 <sms> Hello all! I'm getting an error "No action for prompting/generating user+password credentials  provided (use: setAuthorityGen); returning Nothing" while trying to use cabal behind proxy. I have HTTP_PROXY env variable set up correctly. Any ideas?
09:27:00 <periodic> Does anyone have any suggestions on how to approach a discrete event simulation problem?  One where I have a lot of actors that respond to global events and their responses may cause later events?  Yampa doesn't seem to be quite what I'm looking for, though it comes up a lot.  It doesn't seem to have a global event queue.
09:27:06 <dcoutts> sms: hmm, interesting
09:27:50 <dcoutts> sms: ahh! your proxy requires a password
09:28:00 <dcoutts> sms: right?
09:28:04 <sms> dcoutts: I'm using Windows and GHC Platform.
09:28:09 <sms> right
09:28:32 <dolio> I was trying to do that the other day.
09:28:34 <sms> I have my password imbedded into HTTP_PROXY env variable
09:28:42 <dcoutts> sms: right, got it
09:28:46 <mbuf> anyone? http://hpaste.org/47594/last_statement_in_do_express
09:28:50 <dolio> I gave up and downloaded from Hackage manually (and mailed myself a darcs repo of Agda).
09:29:22 <dcoutts> sms: ok, so we'll need to patch the code in Distribution/Client/HttpUtils.hs
09:29:52 <dcoutts> sms: sorry, we didn't anticipate it (and the HTTP lib doesn't do it automagically)
09:30:34 <ziman> mbuf, your indentation on line 40 seems to be off by a space
09:30:43 <dcoutts> sms: assuming you don't have time to send a patch (though if you do, that'd be great), can you file a ticket at http://hackage.haskell.org/trac/hackage/
09:31:04 <mbuf> ziman, how did you check that?
09:31:12 <sms> dcoutts: Will do. Thanks for helping.
09:32:23 <ziman> mbuf, visually. Indentation of a do-block is determined by the first token after the do keyword, which is "tables" in your case.
09:32:24 <dcoutts> sms: if it makes you feel special, you're the first cabal user ever to report using an authenticated proxy :-)
09:32:41 <dolio> Damn!
09:32:57 <sms> dcoutts: that was the first time I tried to use cabal :-)
09:33:23 <byorgey> mbuf: also, this particular error is often generated by indentation problems
09:33:35 <ziman> mbuf, I'd guess that the rest of the block somehow parses as arguments to getTables, which leaves the "tables <- getTables" statement as the last one in its do-block.
09:33:36 <byorgey> which is just something you pick up once you see it enough.
09:34:30 <mbuf> byorgey, ziman could you please tell me how the indentation should be? I am new to Haskell
09:35:06 <byorgey> mbuf: if the first line of a do-block is  'do foo ...'  then every subsequent line of the do-block should start in the same column as the 'f' in 'foo'
09:35:19 <ziman> mbuf, try deleting the space before "when" and "commit"
09:35:38 <byorgey> mbuf: anything indented more than that will be interpreted as a continuation of the previous line; anything indented less will end the do-block
09:38:07 <mbuf> byorgey, ziman thanks
09:43:13 <mbuf> if I have [[String]], how can I define a function that operates on each [String], for example, if I have [ ["a","b","c"], ["d","e","f"]], I want to do one set of operations on 'a', and 'd', another on 'b', and 'e' and so on
09:43:53 <byorgey> mbuf: maybe you want to do a transpose first?
09:44:02 <byorgey> > transpose [ ["a","b","c"], ["d","e","f"]]
09:44:03 <lambdabot>   [["a","d"],["b","e"],["c","f"]]
09:44:19 <byorgey> otherwise I don't quite understand what you're trying to do
09:44:39 <djahandarie> Yeah, sounds like map f . transpose to me
09:45:07 <mbuf> byorgey, interesting; I have CSV values in a file, and I just want to read each line, get the column values, and write to database
09:45:43 <saati> @src transpose
09:45:44 <lambdabot> transpose []             = []
09:45:44 <lambdabot> transpose ([]   : xss)   = transpose xss
09:45:44 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
09:45:45 <djahandarie> Most popular databases let you import a CSV directly.
09:46:04 <mbuf> djahandarie, ohh! where can I find some examples of the same?
09:46:04 <djahandarie> :t ala ZipList Data.Traversable.traverse
09:46:05 <lambdabot> forall a (t :: * -> *). (Data.Traversable.Traversable t) => t [a] -> [t a]
09:46:41 <tsuraan_> I'm trying to figure out why my foldr isn't acting lazy.  the ghci log is at https://gist.github.com/1014840
09:46:56 <djahandarie> mbuf, well, depends on the database you are using. At least MySQL can do it with LOAD DATA INFILE
09:47:52 <lispy> someone is harassing lambdabot again
09:47:57 <lispy> Cale: ping?
09:48:09 <djahandarie> Doesn't it store logs?
09:48:13 <lispy> Cale: I want to restart lambdabot there is YARAP (yet another run-away process)
09:48:26 <djahandarie> Would be nice to see what causes those
09:48:45 <djahandarie> Someone should really just rewrite lambdabot
09:49:00 <lispy> djahandarie: sometimes people ask it to type check things that have exponential types and sometimes mueval doesn't do it's job correctly
09:49:14 <djahandarie> Ah, that.
09:49:15 <Cale> lispy: Interesting. My script is supposed to catch those every 120 seconds when they occur.
09:49:28 <lispy> djahandarie: funny you say that.  Dons originally implemented the evaluation stuff and it worked correctly.  Then it was rewritten and now it's buggy :)
09:49:45 <lispy> Cale: interesting.
09:49:52 <kmc> Prelude> foldr hasher (0,0,[]) [1..10]
09:49:52 <kmc> (10,55,[9,8,7,6,5,4,3,2,1,0])
09:49:54 <kmc> ^^^ tsuraan_
09:50:05 <lispy> Cale: I just forwarded you the report so you can see what it looks like
09:50:12 <mbuf> djahandarie, I was trying to look at HDBC, http://book.realworldhaskell.org/read/using-databases.html
09:50:14 <kmc> the result list starts with the last element of the input
09:50:22 <kmc> so it can't be incremental
09:50:50 <Cale> lispy: Yeah, I saw the process and killed it. I'm not sure why it wasn't caught by the script...
09:51:08 <tsuraan_> > foldr (:) [] [1..10]
09:51:09 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
09:51:31 <tsuraan_> how am I reversing that?
09:51:47 <tsuraan_> that was a bit rhetorical.  I'm sure I can figure that out :)
09:52:32 * hackagebot hakyll 3.2.0.1 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.0.1 (JasperVanDerJeugt)
09:53:46 <tsuraan_> kmc: thanks for that sanity check, btw.  I probably would have spun my tires for hours on that :-/
09:57:12 <rudyl313> I just implemented a function that I'm sure already exists:  https://gist.github.com/1014859 ... can anybody tell me what function would do that?
09:58:08 <tsuraan_> kmc: I need a left fold, don't I?  That's the only way you can get a count up from the beginning...  ByteString.foldl (which is what I'm really using; the lazy bytestring was just to see if my function really is lazy) says it's strict in the accumulator though.  Does that mean it will foil my irrefutable match that's giving me the lazy behaviour that I need?
09:59:27 <BrianHV> rudyl313: zipWith?
09:59:51 <rudyl313> BrianHV: thanks!
10:00:13 <byorgey> rudyl313: note that your function generates an error if the lists are different lengths; zipWith just truncates to the length of the shorter list
10:00:29 <rudyl313> and as a followup question: if order doesn't matter for my folding function should I use foldr or foldl ... and why?
10:00:50 <rudyl313> byorgey: gotcha
10:00:51 <byorgey> rudyl313: it depends what your fold is generating
10:01:14 <rudyl313> foldl (*) 1 xs ys  ... for example
10:01:28 <Cale> lispy: hey, did you kill it just now?
10:01:33 <byorgey> well, for that you should use 'product' =)
10:01:57 <Cale> never mind, there's still a process I can use :)
10:01:57 <byorgey> rudyl313: but if you are "crunching down" a list into a "summary value" you usually want to use  foldl' (note the ' )
10:02:17 <tsuraan_> if you're building a list with a fold and you want it to be lazy, then you need foldr, right?
10:02:24 <rudyl313> byorgey: interesting
10:02:27 <Cale> lispy: I want to make sure the automatic script will find it. I found one problem (the output of ps apparently has changed slightly)
10:02:28 <byorgey> rudyl313: foldl' is a stricter version of foldl (you'll have to import it from Data.List)
10:02:34 <byorgey> you almost never want to use foldl
10:02:39 <byorgey> tsuraan_: right.
10:02:48 <rudyl313> byorgey: any reason to use left over right/
10:03:26 <byorgey> rudyl313: yes, because in this case a left fold can "compute the answer as it goes" -- it essentially carries along an accumulator
10:03:43 <byorgey> rudyl313: whereas a foldr will have to get all the way to the end of the list before it can start doing any computation
10:03:55 <rudyl313> byorgey: thanks
10:03:58 <byorgey> > foldl f z [a,b,c,d]
10:03:59 <lambdabot>   f (f (f (f z a) b) c) d
10:04:08 <byorgey> > foldr f z [a,b,c,d]
10:04:09 <lambdabot>   f a (f b (f c (f d z)))
10:04:23 <byorgey> notice how the (f z a) can be done right away, before even looking at the b
10:04:26 <byorgey> and so on
10:04:44 <byorgey> whereas (f a ...) has to wait for the value of the ... before doing anything with the a
10:05:03 <rudyl313> byorgey: cool ... I'll use foldl' from now on :)
10:05:05 <c_wraith> meh.  that depends on f :)
10:05:31 <byorgey> c_wraith: yes, but we're talking here in the context of a fold that is producing a "summary value"
10:05:31 <c_wraith> (but when f is strict in both its arguments, like (*), yes)
10:06:00 <adu> hi byorgey
10:06:05 <byorgey> hey adu =)
10:10:08 <tsuraan_> is there any way to use a foldr to lazily generate a list of "found elements" and their indices?
10:10:34 * hackagebot criterion 0.5.0.10 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-0.5.0.10 (BryanOSullivan)
10:12:13 <tsuraan_> all I really want to do is fold a function over a bytestring until it hits some "truth" value, and then have it stop and tell me where it found that value.  I'm really not having any luck with what would be a really trivial "for" loop in C
10:13:17 <tsuraan_> I did try explicit recursion over Data.ByteString.unpack, but that was really slow
10:17:24 <Botje> tsuraan_: there's a findIndex
10:17:42 <Cale> lispy: okay, should be a little more robust. At some point I should just write the cleaning up script in Haskell. It would probably save some pain. :P
10:19:32 <tsuraan_> Botje: yeah, I saw that one, but I also need the accumulator from fold; I'm trying to implement the block-splitting algorithm from rsync (basically), so I need to calculate a running hash over some data and determine where that hash has certain properties (e.g. all high bits are set)
10:20:35 <tsuraan_> I can compute a list of all the matching hashes at ~160MB/s, but I can't make the list of where they occurred at all.  it's maddenning
10:20:53 <Botje> you could use mapAccumL with a nasty accumulator
10:21:38 <Botje> something like (Hash, Index, [Index])
10:22:00 <Botje> but that's just a foldl, then
10:22:17 <tsuraan_> yeah, and foldl with a list can't be lazy
10:22:25 <tsuraan_> and foldr doesn't seem to be able to calculate indices
10:22:54 <tsuraan_> I think I need findIndexAccum
10:23:07 <Cale> What do you mean by 'calculate indices'? Normally the answer to that is to zip your list with [0..] beforehand
10:23:09 <tsuraan_> if only it existed
10:23:24 <Botje> i'm afraid you'll have to dive into the bytestring internals and write something yourself
10:23:27 <tsuraan_> Cale: I'm using a ByteString though
10:23:52 <tsuraan_> unpacking to [Word8] and zipping with [0..] really slows it down
10:23:53 <tommd> tsuraan_: Cale's suggestion is good but also consider using a scan.
10:25:02 <Cale> mapAccumR?
10:25:13 <Cale> mmm...
10:25:14 <Cale> nah
10:25:19 <tsuraan_> Botje: I'm digging through the ByteString sources right now.  I assume all of ByteString written in Haskell, so I should be able to write my own
10:25:39 <tsuraan_> Cale: yeah, since I don't need the output ByteString, it's pretty much just a foldr
10:26:14 <Jafet> It's not pretty Haskell (or pretty not-Haskell?)
10:26:15 <Cale> tsuraan_: yeah, ByteString is written in "Haskell" in that it uses lots of low-level primitives and some clever RULES
10:26:15 <Botje> tsuraan_: it's IO under the hood, with peeks and pokes and stuff
10:26:28 <tsuraan_> oh :(
10:26:39 <Xeon> Is haskell a good language for newbies?
10:26:43 <Jafet> I believe the latest version is based on Storable arrays.
10:26:54 <Botje> Xeon: newbies to what, exactly?
10:26:59 <Jafet> There are no good languages for newbies
10:27:01 <Botje> and how do you quantify 'good' ?
10:27:09 <tsuraan_> maybe I just need to drop to C for this one.  I've managed to get the rest so fast though, it's sort of sad to fail here
10:27:10 <Xeon> Easy to learn...
10:27:19 <Xeon> and use.
10:27:33 <Cale> Xeon: It's probably about as easy to learn as your first language as any other will be.
10:28:01 <Xeon> Less Code or More than C?
10:28:19 <tsuraan_> I've read that Haskell is easier to learn as a first language than as an nth (n>1) language, because you don't have so many notions about how things should work
10:28:20 <Cale> If you already know another language, it might be harder than many others as a second language (but if you learn Haskell first, learning your second language is no harder)
10:28:48 <Cale> Xeon: Code is usually much shorter than the equivalent C, sometimes by a factor of 10.
10:29:06 <Xeon> oohk. Is there any Tutorial or guide for Haskell?
10:29:21 <Cale> learnyouahaskell.com
10:29:26 <Xeon> and Is it as Portable as C and others?
10:29:38 <Cale> It's more portable than C in some ways.
10:29:50 <Ke> theoretically, but in practice C is more portable
10:30:02 <Ke> since compilers lack in platforms
10:30:02 <Jafet> There is an interpreter written in C, so it is exactly as portable as C.
10:30:10 <Cale> Well... it depends on what you mean by portable too :)
10:30:20 <Ke> Jafet: haskell == ghc
10:30:26 <Jafet> @slap Ke
10:30:26 <lambdabot> Come on, let's all slap Ke
10:30:32 <Ke> ;o)
10:30:53 <Jafet> Well, ghc is nearly exactly as portable as gcc, and gcc more-or-less defines portability for C.
10:30:54 <dolio> What about yhc, uhc, jhc, nhc and hbc?
10:31:02 <Cale> If you're talking about how often you'll be able to compile a program unmodified to run on a different platform, I'd say it does much better than C.
10:31:05 <Xeon> Okk People Thank You! Atleast it has an IRC where I could ask for Advice while there is nothing official for c... :D
10:31:25 <Cale> Xeon: C is a terrible language for beginners, I'd have to say.
10:31:56 <dolio> As bad as BASIC?
10:31:57 <Xeon> ooh... I learned Basic as My first language..I think that is more terrible... :P
10:31:59 <Cale> Xeon: It forces you to think about things which distract from learning about how to program.
10:32:00 <tommd> But an excellent language for ocmplex, security critical, network facing applications.
10:32:16 <Cale> Xeon: I disagree. Basic is a better first language than C.
10:32:22 <mercury^> Cale: It depends. If you start with MIPS machine language for example, C will seem very natural.
10:32:34 <Botje> Xeon: there is a ##c, but it's not a very friendly channel from what i've heard
10:32:42 <mercury^> But C on its own is very badly motivated.
10:32:59 <Jafet> It's not very friendly to newbies... but then we've already established that C is not for "newbies".
10:33:01 <Cale> Most implementations of Basic don't even force you to manage your own memory, which I think is the biggest thing which makes C inappropriate for beginners.
10:33:06 <Jafet> (Whatever that word means)
10:33:24 <Cale> MIPS machine language would be similarly inappropriate for a beginner to programming.
10:33:31 <Xeon> I think I should learn Haskell. BTW Is there any other language which I should learn before stepping into Haskell?
10:33:53 <Jafet> "I want to learn French, should I learn German first?"
10:34:00 <tromp> lambda calculus
10:34:03 <Cale> That's rather like starting people learning mathematics by teaching them ZFC with FOL syntax.
10:34:05 <nolrai43> So I need to implement a stopwatch in haskell, (or really a chess clock..but thats just two connected stopwatches) I looked at Data.Time, but it proves awkward for this task, (in particular adding segments of time doesn't seem doable) Where should I go from here?
10:35:02 <nolrai43> Xenon: No I don't think so.
10:35:03 <Cale> Not that ZFC is a bad system to learn about eventually. It's just not very motivated until you learn some less foundational mathematics
10:35:06 <mercury^> Cale: it is a very simple language. Of course it is hard to write complex programs with it. It still does a good job of teaching you the important concepts.
10:35:11 <monochrom> I know advocators of starting math learning from categories.
10:35:13 <Jafet> @hackage datetime
10:35:14 <lambdabot> http://hackage.haskell.org/package/datetime
10:35:48 <Jafet> mercury: one might say that it teaches you about computers, not about computing
10:35:59 <Xeon> :P Kk thanks people. The Effort was really appreciated :)
10:36:03 <Cale> mercury^: It does an extremely poor job of teaching you about a lot of things, such as recursion and type discipline.
10:36:10 <Cale> and functions
10:36:28 <nolrai43> monochrom: yeah, but semi-naive categories are not as bad as fully specified ZFC.
10:36:33 <Jafet> mercury: <insert Dijkstra quote here>
10:36:35 <mercury^> It teaches you about recursion. And functions are a very natural way to keep the complexity low.
10:36:54 <mercury^> Jafet is right though in that it is much worse at teaching you about algorithms than a high level language is.
10:37:15 <mercury^> For that aspect you should program in another language.
10:37:36 <Cale> It doesn't help you learn about recursion, let's put it that way. Recursion isn't a concept which is directly supported by MIPS assembly.
10:38:09 <mercury^> The good thing about it is that you will immediately understand concepts such as tail recursion.
10:38:10 <Cale> You can still apply the concept of recursion in understanding the programs that you write, but strictly speaking they're not written in a recursive style, because they can't be.
10:38:19 <nolrai43> Jafet: Thanks.
10:38:34 <tsuraan_> wrt my ByteString hasing problem: I can do it with explicit recursion and unsafeIndex.  they say that a C programmer can write C in any language; I'm about to prove them right :-/
10:39:00 <Cale> tsuraan_: What happens if you just unpack the ByteString and work with lists?
10:39:00 <mercury^> Whereas someone starting with Haskell, I imagine, will have a hard time understanding why some recursion might be good while another kind can be bad.
10:39:17 <tsuraan_> Cale: it gets really slow
10:39:19 <monochrom> MIPS assembly teaches you logic programming and convex hull algorithms
10:39:38 <Cale> mercury^: That can be understood even without talking about real implementations of the language on hardware. All you need is an expression reduction model of the language.
10:39:47 <tsuraan_> hashing goes from >150MB/s down to ~2MB/s
10:40:00 <Cale> tsuraan_: Just checking :)
10:40:27 <tsuraan_> but explicit recursion with unsafeIndex can sum all the bytes of a bytestring at 800MB/s, so it's definitely fast enough :)
10:40:32 <Jafet> Two-dimensional euclidean convex hull algorithms?
10:40:42 <tsuraan_> I'll have to write a blog post on writing C in haskell, and then you can all cry :)
10:41:05 <kmc> that sounds like the kind of blog post i would write
10:41:12 <tsuraan_> I do feel bad about it though; haskell is such a nice language
10:41:14 <mercury^> Cale: hrm. I guess so. But I would be much less happy with it. It seems as if such a model helps you predict some of the effects, but there would still be a feeling of not really _understanding_ them.
10:41:27 <Cale> tsuraan_: How much do the bounds checks cost if you use safe indexing?
10:41:39 <tsuraan_> Cale: good question.  let me check
10:41:54 <monochrom> "someone starting with Haskell" may either mean no prior computing model or prior C model
10:42:14 <monochrom> someone with a prior C model has problem with haskell's model, yeah
10:42:16 <kmc> tsuraan_, imo part of what makes (GHC) Haskell nice is that you *can* write things in the fast ugly way, when necessary
10:42:27 <kmc> without pulling your entire program into a ugly language
10:42:43 <monochrom> someone with no prior model would not even presume how haskell is executed, and therefore humble enough to ask and learn
10:42:52 <tsuraan_> Cale: it goes down from 800MB/s to 484MB/s, which is still much faster than I can acquire data.  I might leave it on safe mode
10:42:52 <kmc> of course it's better when the compiler does that optimization for you
10:43:18 <tsuraan_> kmc: yeah, it is great to be able to get awesome performance at a cost of prettiness.  I don't even try for speed in Python, for example
10:43:18 <mercury^> monochrom: He would also not be able to understand the real explanation of how it is executed.
10:43:23 <kmc> for example you could write this "hash a ByteString" function in C, but call it from Haskell at the same API
10:43:26 <Cale> mercury^: I get by essentially all of the time without ever going deeper than a graph reduction model of performance in my head. If you want to be Don Stewart and write language shootout entries, then maybe looking at the core or the assembly output of ghc might be worthwhile, but in almost all practical cases, it's not really necessary.
10:43:26 <Jafet> tsuraan: you may enjoy this http://www.haskell.org/pipermail/haskell-cafe/2004-March/005939.html
10:43:41 <kmc> it's easy to convert a ByteString to a raw C array without copying it
10:43:54 <monochrom> there is no "the real explanation"
10:44:01 <tsuraan_> kmc: really?  the useAsCString says it's O(n)
10:44:08 <tsuraan_> kmc: is there a better way?
10:44:11 <kmc> yes
10:44:15 <kmc> (less safe but faster)
10:44:41 <Jafet> Yep, it uses Storable
10:44:42 <kmc> Data.ByteString.Internal.toForeignPtr
10:44:55 <mercury^> Cale: well, even when not writing shootout entries I tend to be very performance aware. I rarely program anymore, because I am always very annoyed at what the compilers do. :)
10:45:00 <kmc> unfortunately the Internal docs aren't on Hackage :/
10:45:02 <Cale> mercury^: The real explanation about how a program is executed/evaluated is a moving target anyway :)
10:45:03 <Jafet> Storable means: you can pass it to C... maybe
10:45:06 <kmc> but you can go back a ew versions and see them
10:45:11 <tsuraan_> kmc: cool
10:45:50 <Cale> mercury^: Since a new version of GHC often mysteriously improves the performance of programs (and occasionally I suppose there are regressions as well, but they're hopefully less severe :)
10:45:51 <kmc> tsuraan_, are you familiar with ForeignPtr?
10:46:05 <tsuraan_> kmc: not yet :)
10:46:05 <kmc> someone was talking about a 100x regression from 6.12 to 7.0 here
10:46:15 <kmc> i hope it's limited to a small set of programs
10:46:25 <mercury^> Cale: I had even improved one shootout entry by a factor of 3 (iirc) once, but then did not submit it, because GHC still did something stupid with it and nobody was helping me resolve that.
10:46:32 <kmc> tsuraan_, ok.  http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/Foreign-ForeignPtr.html
10:46:33 <Jafet> Exactly 100x sounds interesting, usually it's asymptotic
10:46:36 <tsuraan_> with foreignPointer, or in general?  the 100x might have been me, because I built ghc wrong
10:46:46 <kmc> unrelated to ForeignPtr
10:46:50 <kmc> sorry
10:46:59 <Cale> The real story is *quite* complicated and impractical to actually think about on a regular basis.
10:47:25 <kmc> Cale, I think you have to go deeper than graph reduction to understand (for example) why strictness can make such a difference on numerical algorithms
10:47:28 <tsuraan_> kmc: thanks!
10:47:29 <kmc> because it has to do with unboxing
10:47:42 <Cale> Not to mention that the real story about how most machine languages are executed now is too complicated for the average assembly programmer to really know what he's doing when he optimises a piece of code over a handful of instructions.
10:48:30 <mercury^> Cale: that's not really true. Sure, it is much more complicated that having a sequence of instructions that is executed one at a time, but it is still very understandable.
10:48:47 <mercury^> There are tables with all the uop fusion rules.
10:49:04 <kmc> but at that point you also have to model half a dozen different caches
10:49:28 <kmc> it's always amusing when people get to the ISA level and then proclaim smugly that they know how the CPU *really* works
10:49:59 <mercury^> Also lists that tell you which execution units can handle which instructions, their throughput etc.
10:50:32 <mercury^> Cache prediction algorithms are also rather fully explained in the manuals.
10:50:34 <kmc> also if your code is running in virtualization
10:50:45 <kmc> there's a huge set of extra things to consider
10:50:49 <Eduard_Munteanu> What's the hairy problem of the day? :)
10:51:04 <Jafet> The same hairy problem from three days ago it seems
10:51:09 <monochrom> the hairy problem of the day is "do you know your computer? really?"
10:51:20 <kmc> for example you probably don't think of CPUID as an instruction which takes tens of thousands of cycles to execute
10:51:31 <kmc> but it is under virtualization
10:51:50 <monochrom> oh, no wonder my virtual machine boots so slowly :)
10:51:54 <Jafet> To be fair, how many assembly inner loops use CPUID
10:52:24 <kmc> Linux's gettimeofday() did, until recently
10:52:25 <Eduard_Munteanu> It is used as a serializing instruction at times.
10:52:48 <kmc> yep, they changed from CPUID to MFENCE and this improved the performance of gettimeofday() under Xen by a factor of 80
10:53:07 <shachaf> kmc: Huh. How recently?
10:53:07 <Jafet> To be fair, how many inner loops use getti... oh, right.
10:53:12 <kmc> i don't recall
10:53:31 <kmc> people care about gettimeofday() performance, otherwise it wouldn't be a vsyscall to begin with
10:53:33 <mercury^> Are there not better instructions for serialisation?
10:53:54 <kmc> i mentioned one just now
10:53:55 * roconnor installs enumerator
10:54:08 <mercury^> I haven't really had a look at the multicore stuff, but from what I skimmed there were many specialised instructions for all that stuff.
10:54:16 <Eduard_Munteanu> Yeah, I don't think you get *FENCE on all x86 CPUs.
10:54:24 <kmc> it came in on original MMX or SSE i think
10:54:26 <kmc> it is pretty old
10:55:26 <kmc> Linux has directives for "at boot, if I support CPU feature X, write here instruction Y, else instruction Z"
10:55:36 <chrisdone> @hoogle (t -> Either a1 a) -> Maybe t -> Either a1 (Maybe a)
10:55:36 <lambdabot> No results found
10:56:00 <kmc> likewise "overwrite this lock with a NOP if the second-to-last CPU is hot-unplugged"
10:56:01 <mercury^> kmc: hmm, I hope it can also write whole blocks of instructions ^^
10:56:37 <chrisdone> @hoogle (t -> f a) -> m t -> f (m a)
10:56:37 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
10:56:37 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
10:56:37 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
10:56:50 <mercury^> You might want to use a completely different algorithm if you have certain instructions available.
10:57:01 <chrisdone> Well, bugger me.
10:57:17 <kmc> mercury^, the easiest way to accomplish that would be to call through a function pointer
10:57:32 <chrisdone> Ah, Traversible doesn't fit Either.
10:57:37 <chrisdone> @instances Traversable
10:57:39 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
10:57:42 <nolrai43> hmm, is there really not a way to get the current time more accurate the the second? It seems strange..
10:57:47 <mercury^> kmc: yeah, but that has the disadvantage of unnecessary indirection.
10:58:02 <Cale> mercury^: It's all described clearly, but actually programming while taking it all into account in order to produce anything close to the optimal result is unintuitive and tricky. I once spent some time with some folks at McMaster writing a Haskell program to optimise map-computing loop bodies for PPC+Altivec code.
10:58:05 <nolrai43> All I need is like tenths of second.
10:58:09 <chrisdone> nolrai43: Data.Time.getCurrentTime returns microseconds (or maybe nano?).
10:58:32 <chrisdone> Probably micro.
10:58:35 <nolrai43> Okay I am confused.
10:58:38 <chrisdone> @hoogle getCurrentTime
10:58:38 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
10:58:38 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
10:58:55 <kmc> mercury^, you can also use the "alternatives" mechanism i described to change your direct calls to other direct calls
10:59:01 <mercury^> Cale: it makes optimisation a fun challenge at least. :)
10:59:03 <kmc> see alternative_call, http://lxr.linux.no/linux+v2.6.39/arch/x86/include/asm/alternative.h
10:59:14 <Jafet> DiffTime is defined using Fixed.Pico, but that's mostly cosmetic
10:59:37 <chrisdone> This is a length of time, as measured by a clock. Conversion functions will treat it as seconds. It has a precision of 10^-12 s.
10:59:37 <Cale> mercury^: Indeed. I think it's more suited to machines than humans now though.
10:59:55 <Cale> At least, at that level.
11:00:08 <mercury^> Cale: from an economical standpoint, very often yes.
11:00:24 <Cale> Even from a results standpoint, I think machines will outperform humans consistently.
11:00:41 <mercury^> I'd be willing to bet against that. :)
11:00:47 <Jafet> I wonder what kind of clock measures 10^-12s. The SI second is defined using a natural unit of about 10^-10s.
11:01:20 <mercury^> Cale: unfortunately I am rather short on time these days, but maybe during my semester break we can have a small challenge.
11:01:25 <Jafet> Cale: well, at some point you need a human to write a program to decide what assembly code to use
11:01:30 <chrisdone> @djinn (inp -> Either err out) -> Maybe inp -> Either (Maybe out)
11:01:30 <lambdabot> Error: kind error: (KVar 7,KStar)
11:01:33 <Jafet> And that's where the wetware creeps in
11:01:37 <chrisdone> @djinn (inp -> Either err out) -> Maybe inp -> Either err (Maybe out)
11:01:37 <lambdabot> f a b =
11:01:37 <lambdabot>     case b of
11:01:37 <lambdabot>     Nothing -> Right Nothing
11:01:37 <lambdabot>     Just c -> case a c of
11:01:37 <lambdabot>               Left d -> Left d
11:01:39 <lambdabot>               Right e -> Right (Just e)
11:01:44 <Cale> Jafet: yeah
11:01:54 <chrisdone> Ah, somehow I think djinn would produce something concise. Duh.
11:02:02 <mercury^> You write something in a language of your choice, I write something in x86 machine language optimised for the 45nm core2.
11:02:04 <Jafet> Especially when the human is distracted by other features in the program, like parsing and error reporting
11:02:30 <Jafet> chrisdone: theorems for free, unless you pay-per-line?
11:02:38 <benmachine> Jafet: you could get a human to write a program to write a program to decide what assembly to use :)
11:02:52 <chrisdone> Jafet: Hehe.
11:02:57 <Cale> Look at FFTW for instance.
11:03:05 <chrisdone> @pl \f x -> case x of (Just y) -> Just <$> f y; Nothing -> Right Nothing
11:03:05 <lambdabot> (line 1, column 28):
11:03:05 <lambdabot> unexpected ">" or "-"
11:03:06 <lambdabot> expecting variable, "(", operator or end of input
11:03:10 <roconnor> IF Data.Enumerator.Stream has chunks that are lists, then I don't see how this is supposed to help me.
11:03:11 <Cale> Beating that by hand is pretty hard :)
11:03:20 <mercury^> Cale: that's different because it adapts to the specific program at hand.
11:03:30 <kmc> benmachine, there's that superoptimizer that uses random search + SMT solvers to find improved peephole optimizations
11:03:43 <Cale> Sure - special purpose compilers FTW.
11:03:46 <chrisdone> What's pl getting stuck on there?
11:03:48 <benmachine> :t maybe (Right Nothing) (fmap Just . f)
11:03:49 <lambdabot> forall a a1 a2. (Show a2, SimpleReflect.FromExpr (Either a1 a)) => Maybe a2 -> Either a1 (Maybe a)
11:03:54 <mercury^> If you were given the specification of the specific problem, you could beat it.
11:03:55 <benmachine> oops
11:04:01 <benmachine> :t \f -> maybe (Right Nothing) (fmap Just . f)
11:04:01 <lambdabot> forall a a1 a2. (a2 -> Either a1 a) -> Maybe a2 -> Either a1 (Maybe a)
11:04:05 <Jafet> If FFTW was actively maintained by an unbounded army of assembly hackers for every architecture in use, they would beat the optimizer
11:04:07 <benmachine> kmc: yes that was what I was thinking
11:04:36 <Jafet> chrisdone: case-of
11:04:45 <monochrom> djinn tries to be elementary rather than concise. (as in, "elementary proofs", as in, try to use kindergarten-level steps, at the expense of length)
11:04:51 <Jafet> (Because you can't make deconstruction into combinators)
11:05:15 <mercury^> Cale: this problem is a bit trivial of course, but I have a hand optimised wordcount here. If you want to, I can have it run against your challenger.
11:05:16 <Cale> Jafet: But even beating FFTW for a specific architecture and size of transform is quite hard.
11:05:33 <mercury^> Hard, but doable.
11:06:06 <Cale> Maybe, maybe not for some architectures. There's no proof, but it might be producing optimal code in some cases.
11:06:13 <kmc> i think you are agreeing with each other
11:06:22 <mercury^> Cale: I also have a sudoku solver.
11:06:34 <kmc> a human with unbounded time can perform at least as well as the best optimizing compiler
11:06:42 <kmc> proof: simulate that compiler by hand
11:06:47 <chrisdone> benmachine: Can ya think of a nice name for that function? I have a legit use for this function.
11:06:55 * Eduard_Munteanu just compiled atlas-blas a few days ago... it took a few hours.
11:07:07 <Eduard_Munteanu> Just optimizing it I guess.
11:07:18 <Jafet> chrisdone: I would try to name its generalization
11:07:42 <kmc> but optimizing compilers are way more effective than omg l33t hardcore hand-tuned assembly, for most real cost/benefit problems
11:07:52 <monochrom> strange to say "perform" with "unbounded time"
11:08:08 <Jafet> > (\f -> maybe (Right Nothing) (fmap Just . f)) `asTypeOf` (undefined :: Monad m1, Monad m2 => m1 a -> m2 a -> m1 (m2 a))
11:08:10 <lambdabot>   <no location info>: parse error on input `=>'
11:08:22 <Jafet> :t (\f -> maybe (Right Nothing) (fmap Just . f)) `asTypeOf` (undefined :: (Monad m1, Monad m2) => m1 a -> m2 a -> m1 (m2 a))
11:08:23 <lambdabot>     Couldn't match expected type `Either a1 (Maybe a)'
11:08:23 <lambdabot>            against inferred type `Either a1 a -> Maybe (Either a1 a)'
11:08:23 <lambdabot>     In the second argument of `asTypeOf', namely
11:08:27 <lpsmith> agh,  sometimes i'm close to giving up on trying to understand Haskell performance
11:08:32 <Jafet> Oh, other way round
11:08:55 <Jafet> What if we had a compiler so complex that no one could simulate it by hand
11:08:55 <chrisdone> Yeah, m2 (m1 a)
11:09:11 <Jafet> Hm, then no one could debug it, so it couldn't exist as long as programs have bugs
11:09:34 <chrisdone> Ah, no, the type in general isn't right.
11:10:00 <mercury^> Jafet: you would always be able to go through its instructions one by one.
11:10:06 <chrisdone> What's the purpose of asTypeOf?
11:10:16 <monochrom> I don't want to simulate ghc by hand already! :)
11:10:25 <Jafet> It was redundant there, chrisdone
11:10:25 <mercury^> Most definitely not.
11:10:28 <benmachine> chrisdone: forces things to be the same type, can be useful for resolving ambiguity
11:10:28 <roconnor> I'm supposed to remove lists to make my SHA256 faster, but if my Stream is simply "Chunk theList", then I haven't removed anything
11:10:52 <benmachine> chrisdone: why did you reject Traversable?
11:11:39 <benmachine> chrisdone: there's not a standard instance of Traversable for Either but I think one can be defined
11:11:56 <kmc> chrisdone, you don't need it as much if you have ScopedTypeVariables
11:12:00 <chrisdone> benmachine: Is Maybe an instance of Traversable?
11:12:05 <kmc> should be
11:12:05 <benmachine> chrisdone: yes
11:12:10 <kmc> it's a bounded-length list
11:12:37 <Jafet> roconnor: not [] Chunk, as in ByteString?
11:12:52 <chrisdone> :t traverse
11:12:53 <lambdabot> Not in scope: `traverse'
11:12:57 <chrisdone> ~_~
11:13:01 <roconnor> sorry I mean Chunks
11:13:08 <roconnor> as in http://hackage.haskell.org/packages/archive/enumerator/0.4.10/doc/html/Data-Enumerator.html#v:Chunks
11:13:18 <benmachine> :t Data.Traversable.traverse
11:13:19 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
11:13:35 <benmachine> oh wait you don't need Traversable Either, silly me
11:13:45 <benmachine> (but you can define it if you like)
11:14:02 <chrisdone> Don't I need Applicative (Either a)?
11:14:13 <benmachine> yes, but that's somewhere
11:14:24 <benmachine> that's in Control.Applicative
11:14:28 <benmachine> it's not even orphan :O
11:14:36 <chrisdone> Mhm.
11:15:00 <benmachine> might be new, I don't know
11:15:13 <benmachine> obtw chrisdone if there's a typo in tryhaskell are you the person to tell
11:15:32 <chrisdone> > f (((+1) -> n) -> n) 2
11:15:32 <benmachine> (step32 has parantheses, should be parentheses)
11:15:32 <lambdabot>   Pattern syntax in expression context: ((+ 1) -> n) -> n
11:15:39 <chrisdone> > f (\((+1) -> n) -> n) 2
11:15:40 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
11:15:40 <lambdabot>    arising from a use of `...
11:15:46 <chrisdone> benmachine: Sure. Let me see.
11:16:12 <Eduard_Munteanu> Jafet: well for NISC cpus you're already there.
11:16:20 <benmachine> http://tryhaskell.org/#32 <- parantheses
11:16:27 <nolrai43> Why are NominalDiffTime and DiffTime differnt things and how do I change from one to the other?
11:16:34 <Eduard_Munteanu> Unless you make some aliases to common-looking instructions.
11:16:35 <chrisdone> Oh, yeah.
11:17:29 <chrisdone> Fixed.
11:18:02 <benmachine> nolrai43: http://hackage.haskell.org/packages/archive/time/1.2.0.5/doc/html/Data-Time-Clock.html explains it
11:18:41 <roconnor> is Enumarator useful with the Identity Monad?
11:19:45 <chrisdone> > let integer x = case reads x of [(x,_)] -> Just (x::Integer); _ -> Nothing in (integer "x",integer "5")
11:19:46 <lambdabot>   (Nothing,Just 5)
11:19:59 <chrisdone> :t let integer x = case reads x of [(x,_)] -> Just (x::Integer); _ -> Nothing in Data.Traversable.traverse integer
11:20:00 <lambdabot> forall (t :: * -> *). (Data.Traversable.Traversable t) => t String -> Maybe (t Integer)
11:20:04 <chrisdone> Sweet.
11:20:15 <chrisdone> > let integer x = case reads x of [(x,_)] -> Just (x::Integer); _ -> Nothing in Data.Traversable.traverse integer (Just "4")
11:20:15 <lambdabot>   Just (Just 4)
11:20:21 <chrisdone> ^_ ^
11:20:32 <chrisdone> Oh, not quite right.
11:20:53 <chrisdone> > let integer x = case reads x of [(x,_)] -> Right (x::Integer); _ -> Left ("Boo!"::String) in Data.Traversable.traverse integer (Just "x")
11:20:54 <lambdabot>   Left "Boo!"
11:20:56 <chrisdone> > let integer x = case reads x of [(x,_)] -> Right (x::Integer); _ -> Left ("Boo!"::String) in Data.Traversable.traverse integer (Just "5")
11:20:57 <lambdabot>   Right (Just 5)
11:20:58 <chrisdone> :-)
11:21:11 * chrisdone high-fives benmachine
11:21:28 <chrisdone> :t Text.Parsec.parse
11:21:29 <lambdabot> Couldn't find qualified module.
11:22:11 * benmachine \o.
11:22:54 * chrisdone laughs maniacally
11:24:40 <chrisdone> > "x" :: Text
11:24:41 <lambdabot>   Not in scope: type constructor or class `Text'
11:25:56 <roconnor> how do I convert a list to a an Enumerator?
11:27:44 <chrisdone> roconnor: unfold?
11:28:19 <roconnor> unfold requires a (s -> Maybe (a, s))
11:28:42 * roconnor is totally lost
11:29:42 <chrisdone> (\(a:s) -> Just (a,s)) ?
11:29:58 <roconnor> doing this will make my program faster?
11:30:10 <chrisdone> Haha, I don't know. Just answering that specific question.
11:30:17 <roconnor> :D
11:30:19 <roconnor> thanks
11:31:03 <chrisdone> I figured the enumerator has some advantages with none of the functions on it having to check for null…
11:31:20 <roconnor> chrisdone: there is a null in Chunks
11:31:56 <ezyang> Idle thoughts: I wonder if the projection functions from primitive recursive theory could be used to make composing multi-arity functions easier.
11:32:36 <roconnor> primitive recursive theory?
11:32:41 <roconnor> ah
11:33:17 <roconnor> ezyang: I did a bunch of programming in primitive recursion theory when proving the incompleteness theorem.
11:33:46 <erus`> > not . not . not True
11:33:46 <lambdabot>   Couldn't match expected type `f GHC.Bool.Bool'
11:33:47 <lambdabot>         against inferred typ...
11:33:56 <roconnor> > not . not . not $ True
11:34:00 <lambdabot>   mueval-core: Time limit exceeded
11:34:23 <monochrom> in fact primitive recursion theory talks about composing functions of incompatible arities all the time.
11:34:43 <ezyang> Yeah, that's why I thought it might be a useful notation.
11:40:35 <roconnor> replacing foldl' with Data.Enumerator.List.fold just makes things slower
11:40:43 <roconnor> I dont' see how this was supposed to help
11:41:57 <roconnor> Why would runIdentity (run_ (EL.unfold foo (padding blockSize x) $$ EL.fold shaStep h0)) be any better than foldl' shaStep h0 $ padding blockSize x
11:41:59 <dolio> > runIdentity $ not . not . not . Identity True
11:42:02 <lambdabot>   False
11:43:19 <benmachine> roconnor: who claimed it would be?
11:47:07 <roconnor> I'd have to check my logs
11:47:11 * roconnor looks
11:47:40 <dolio> Someone advocating iteratees, probably?
11:49:08 <roconnor> heh I guess I misrememberd
11:49:14 <roconnor> [Saturday 04 June 2011] [14:50:07] <mm_freak>   roconnor: as said i don't know the structure of SHA, so iteratees may not be a good fit
11:50:00 <roconnor> @type execState
11:50:01 <lambdabot> forall s a. State s a -> s -> s
11:50:08 <nolrai43> @type fromNum
11:50:09 <lambdabot> Not in scope: `fromNum'
11:50:13 <dolio> I don't think you're supposed to do SHA on lists using iteratees.
11:50:35 <dolio> You're supposed to not use lists, and use iteratees instead.
11:50:53 <roconnor> my input is a list
11:51:05 <roconnor> or maybe a bytestring
11:51:33 <dolio> Then you have failed to switch to iteratees.
11:51:57 <roconnor> oh, do I have to infect my whole program to make SHA fast?
11:51:57 <dolio> Maybe I'm off, though.
11:52:01 <roconnor> ok
11:52:11 <dolio> That's my impression of iteratees, yes.
11:52:24 <roconnor> I mean, SHA256 :: Bytestring -> Hash
11:52:31 <roconnor> I'm not about to change that signature
11:52:41 <roconnor> that is clearly what it ought to be
11:53:01 <roconnor> I just want to stop SHA256 from doing billions of useless allocations
11:53:41 <dolio> If you want your algorithms to be fast and interleaved, you have to write the algorithms to work on iteratees instead of regular data structures.
11:53:44 <dolio> I think.
11:54:23 <roconnor> there is no interleaving
11:54:30 <dolio> Bytestring -> Hash is not going to get injected in nicely.
11:54:52 <dolio> You read the entire string into memory and then hash it?
11:58:04 <roconnor> the string isn't very big
11:58:18 <roconnor> but I have many of them
11:58:33 <roconnor> so I'm currently spending 40% of my time shaing
11:58:41 <roconnor> and most of that time is spend allocating memory I think
11:59:45 <dolio> Well, you're not going to get faster by implementing the Bytestring -> Hash part by re-unfolding the string into an iteratee and then using an iteratee to compute the hash.
11:59:51 <dolio> Instead of just folding over the string.
12:00:43 <dolio> Maybe you can use iteratees for doing arriving at each of the byte strings you want to hash, though.
12:00:56 <dolio> And then map your hash over it.
12:17:14 <stepkut> is there a type like, data Proxy a = Proxy, defined in 'base' or another standard library ?
12:17:50 <opqdonut> haven't seen one
12:17:52 <Jafet> That's not legal '98, so probably not
12:18:07 <stepkut> right. so probably not in base
12:18:11 <mauke> that's perfectly legal H98
12:18:27 <mauke> and there is one but I have no idea in what library
12:18:49 <stepkut> mauke: according to this wiki it is an extension.. http://www.haskell.org/haskellwiki/Phantom_type
12:18:50 <dolio> > Const ()
12:18:51 <Jafet> Er, then what does that resemble that isn't legal '98? ...
12:18:52 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.Const () b))
12:18:52 <lambdabot>    arising...
12:19:02 <stepkut> but it is used in Data.Fixed
12:19:03 <dolio> @type Const ()
12:19:04 <lambdabot> forall b. Const () b
12:19:11 <chrisdone> Jafet: data Proxy?
12:19:28 <stepkut> Jafet: data types with no constructors?
12:19:40 <mauke> stepkut: where does it say it's an extension?
12:19:44 <dolio> Proxy has a constructor.
12:20:00 <dolio> Empty data declarations are what need the extension.
12:20:02 <Jafet> Data types that don't have every type variable in the left side appearing in the right side?
12:20:36 <Eduard_Munteanu> Jafet: no, rather those that don't have any constructor
12:20:44 <stepkut> mauke: oh.. I didn't read carefully
12:20:52 <stepkut> mauke: nevermind :)
12:20:58 <Jafet> I know those are an extensino.
12:20:59 <Eduard_Munteanu> like   data Void
12:22:21 <chrisdone> They're called phantom types right?
12:22:48 <stepkut> chrisdone: yeah
12:23:30 <stepkut> I keep coming up with places where I need that Proxy type
12:24:58 <stepkut> for example, I want to have a class function that extracts the position information from a error type like, class GetPosition err pos | err -> pos where getPosition :: pos
12:25:07 <stepkut> oops
12:25:11 <stepkut> sorry mixed up to classes
12:25:19 <stepkut> I want the defaultPosition
12:25:49 <stepkut> class InitialPosition err pos | err -> pos where initialPosition :: pos
12:26:03 <tgeeky> hm. RWH is down. :/
12:26:13 <stepkut> but that does not work, because initialPosition needs to know what type 'err' is
12:26:33 <Jafet> Oh right, that's the one that's an extension
12:26:35 <stepkut> so I can do this instead, initialPosition :: Proxy err -> pos
12:30:08 <benmachine> stepkut: try tagged on hackage
12:30:16 <benmachine> http://hackage.haskell.org/package/tagged
12:30:55 <stepkut> benmachine: nice
12:31:02 <stepkut> benmachine: at first glance, it looks perfect
12:31:41 <stepkut> except for its dependencies on data-default and semigroups :-/
12:32:01 <benmachine> oh, that's weird
12:32:27 <stepkut> benmachine: that is the pitfall of type classes
12:32:33 <benmachine> yes
12:32:40 <benmachine> I don't know what the point of Data.Default is though
12:32:52 <benmachine> it never seemed to me like a useful thing
12:33:13 <stepkut> instance Default (Proxy s) where
12:33:13 <stepkut>     def = Proxy
12:33:22 <tgeeky> yeah
12:33:25 <tgeeky> you can get rid of that ;)
12:33:47 <benmachine> stepkut: on the other hand, neither of those are particularly heavyweight dependencies :)
12:34:12 <stepkut> benmachine: yeah.. but every dependency is another thing that can be broken.. and another thing to debianize
12:34:23 <benmachine> ah
12:34:53 <stepkut> packaging three libraries for the sake of getting, data Proxy a = Proxy, seems a bit too much
12:35:03 <benmachine> edwardk: why on earth do you provide a Default instance for Proxy in your tagged package? the extra dependency is upsetting users
12:36:05 <stepkut> benmachine: because it is the only sensible way to make people happy who want a Default Proxy instance
12:36:15 <benmachine> stepkut: yes but who even wants one
12:36:28 <stepkut> benmachine: otherwise he would have to create a package, tagged-default, with just that one instance :)
12:36:33 <monochrom> Ralf Hinze says "data Proxy a = Proxy" is a phantom type, "data Void" is not a phantom type.
12:36:53 <benmachine> monochrom: well, the way I see it, Proxy isn't a phantom type, but 'a' is
12:37:09 <benmachine> (specifically in the case where a appears in the type but doesn't correspond to any values of type a)
12:38:34 <ezyang> Bah, whenever I strict-ify a function, I always forget to translate the recursive calls to point to the strict version. ^_^
12:39:52 <djahandarie> ezyang, easy solution, just use fix for everything
12:40:01 <ezyang> Heh :-)
12:41:20 <djahandarie> I wonder how much people have looked into strict Mu-recursive combinators like cata and such. Would strictness be a property of the data type or the function there? Dunno...
12:41:59 <roconnor> dolio: thanks
12:42:10 <roconnor> I guess I need to think this through and understand
12:42:22 <roconnor> I don't even know where my allocations are coming from yet.
12:42:29 <ezyang> Depnds on what kind of recursion, I guess.
12:46:05 * roconnor sighs
12:54:51 <shelhezan> Hello, someone's here who can verify my little haskell function? http://hpaste.org/47597/mirroring
12:54:55 <javadyan> Hi guys
12:55:34 <javadyan> quick question: what Haskell library/module do I use to measure time intervals? I want to benchmark some code.
12:56:11 <SoleSoul> Hi. I have a code I wrote which I usually compile. I want to run it un gchi. The code uses getArgs to get a file name from the command line. Is there a way to run the module and pass command line arguments to it from within ghci? thanks
12:57:04 <javadyan> ideally I want a function that returns a monotonic value indicating the number of microseconds passed since some unspecified moment in past
12:57:33 <RichardBarrell> javadyan: System.Time has getClockTime and diffClockTimes.
12:58:00 <c_wraith> javadyan: if benchmarking code is your primary goal, use the criterion package.  It does statistically sound benchmarking.
12:58:02 * hackagebot mecha 0.1.0 - A constructive solid geometry (CSG) modeling language.  http://hackage.haskell.org/package/mecha-0.1.0 (TomHawkins)
12:58:03 <thoughtpolice> javadyan: well, for just benchmarking code, you should probably use criterion.
12:58:19 <thoughtpolice> yes, as c_wraith says, criterion does statistically sound benchmarking and will even generate pretty graphs automatically.
12:58:23 <thoughtpolice> it's a nice tool
12:58:44 <c_wraith> pretty graphs are the best. :)
12:58:52 <javadyan> Thanks!
12:59:21 <thoughtpolice> bryan never disappoints when he contributes a library. :)
13:01:10 <roconnor> @seen mm_freek
13:01:10 <preflex>  Sorry, I haven't seen mm_freek
13:01:10 <lambdabot> Unknown command, try @list
13:01:15 <roconnor> preflex: seen mm_freek
13:01:16 <preflex>  Sorry, I haven't seen mm_freek
13:01:26 <roconnor> preflex: seen mm_freak
13:01:26 <preflex>  mm_freak was last seen on #haskell 22 hours, 54 minutes and 1 second ago, saying: but that's only optimal in terms of memory…  if you want optimum in time, then given you use a buffer of b bytes, you will need about b+t bytes memory
13:01:34 <chrisdone> shelhezan: Why's Type in upper case? O _o
13:05:43 <SoleSoul> is there a way to use :main and :trace in ghci in the same time?
13:07:40 <shachaf> SoleSoul: Is there a difference between :main and just running main?
13:07:46 <shachaf> I guess you can pass arguments.
13:07:51 <Cale> SoleSoul: Even though there is :main, a thing people commonly find convenient is to define something like mainWithArgs :: [String] -> IO ()
13:07:59 <SoleSoul> shachaf: Yes, I need to pass command line arguments
13:08:00 <kmc> main = getArgs >>= mainWithArgs
13:08:14 <kmc> anyway you might be looking for ":set args"
13:08:17 <Cale> SoleSoul: and then set  main = mainWithArgs =<< getArgs -- but kmc beat me to it :)
13:10:01 <SoleSoul> Thank you everyone :)  :set args was the simplest solution
13:10:27 * roconnor wishes for wren
13:10:28 <shelhezan> chrisdone, does it matter? :D i use to write it in upper case
13:13:31 <derdon> I'm not quite sure, but I think there's an important mistake in learnyouahaskell: "All the elements in a set are unique. And because they're internally implemented with trees […], they're ordered."
13:13:44 <derdon> I don't think that elements in a set are ordered
13:14:00 <c_wraith> well.  It's an implementation detail
13:14:05 <c_wraith> Not a part of the definition
13:14:19 <derdon> oh
13:14:40 <c_wraith> And furthermore, it's an implementation detail of Data.Set.  There are other options that don't use the same definition
13:14:50 <derdon> ah, I see. I should have read more carefully
13:15:13 <kmc> it should probably be worded differently to emphasize that this is an implementation detail
13:15:39 <SoleSoul> I'm trying to detect an infinite loop. I tried using :trace and ^C and then :history but it says "not stopped at a breakpoint", how do I do it then?
13:16:07 <kmc> as an alternative to the GHCi debugger, you could use Debug.Trace
13:16:37 <roconnor> my interator stuff is looping forever :(
13:16:59 <mornfall> Is interator a neologism or a typo? :)
13:17:27 <roconnor> type
13:17:28 <roconnor> iterator
13:17:37 <kmc> iternumeratoratee
13:17:52 <c_wraith> seems like a long way to spell manatee.
13:17:53 <mornfall> I was kind of hoping for the former.
13:17:58 <c_wraith> That project's just an IO library, right
13:18:01 <c_wraith> :)
13:18:20 <mornfall> c_wraith: Don't be evil... :P
13:18:24 <roconnor> It was suggested to me that using it in pure code might eliminate my allocations
13:18:48 <roconnor> but all the tutorial seems to be about interleaved IO
13:19:34 <mornfall> Yes, because that's where it is somewhat novel, I guess. :)
13:20:44 <mornfall> I hate to say it, but iteratee may be a better design pattern than it is a library abstraction.
13:21:39 <Liskni_si> What is a library abstraction?
13:22:02 <mornfall> If I understanding things correctly (which is not extremely likely, anyway), attoparsec is an instance of iteratee-the-design-pattern.
13:22:14 <mornfall> Liskni_si: Whatever abstraction you can usefully put in a library. :)
13:22:25 <kmc> Liskni_si, can you give some context for that question?
13:22:56 <mornfall> kmc: My statement about iteratees, methinks.
13:22:56 <Liskni_si> kmc: mornfall's line just before mine line
13:23:13 <kmc> oh i missed that, sorry
13:23:14 <Liskni_si> s/line$//
13:23:34 <kmc> i think that just indicates that existing libraries aren't mature enough
13:23:42 <kmc> once a design pattern is truly well-understood it should become a library
13:23:56 <mornfall> kmc: Maybe. :)
13:24:36 <mornfall> kmc: Although I would argue to the contrary, that in a design pattern, there isn't enough "substance" that could go in a library while making the client code shorter and easier to understand.
13:24:56 <mornfall> kmc: (Possibly because everything you could put in a library already is.)
13:24:59 <kmc> at that point you might have to look at improving the language rather than the library
13:25:05 <mornfall> True. :)
13:25:08 <kmc> that's why so many things are "design patterns" in Java but ordinary libraries in other languages
13:25:29 <kmc> in Lisp you replace this hard distinction with a continuum of libraries becoming more and more macro-ful
13:26:01 <MHD> I'm getting some weird errors trying to cabal install openal
13:26:13 <mornfall> Well, my impression of the iteratee libraries is that they don't really make the code substantially easier to read, or even shorter. They just standardise how you write the design pattern.
13:26:38 <kmc> then they do make the code easier to read
13:26:42 <kmc> by standardizing the names used
13:26:42 <mornfall> Which may be useful in itself (well, not really if you have 3 mutually incompatible libraries for that...)
13:27:02 <kmc> right, hence the maturity issue
13:27:26 <mornfall> kmc: Yes and no. In many cases, the library types are forced to be more general (and therefore also harder to read) than would be needed in specific cases.
13:27:38 <mornfall> Well, maturity would help there too.
13:27:41 <mornfall> I guess.
13:27:44 <mornfall> At least a bit.
13:27:46 <kmc> i am basically suspicious of claims that something fundamentally can't be usefully abstracted
13:28:02 <MHD_> ah, never mind. Where is GHC's include directory?
13:28:50 <mornfall> kmc: Sometimes it may be matter of rephrasing the question.
13:29:00 <kmc> sure
13:29:16 <mornfall> Maybe there is something that isn't iteratees that would make writing them much more convenient.
13:29:23 <kmc> yes
13:30:17 <kmc> i just want to avoid the Java situation, where they give up on abstraction and write the patterns down in books and make programmers type them in by hand
13:30:30 <kmc> if that's the situation at present, fine, but nobody should consider it a good thing
13:34:43 <mornfall> kmc: Do you have a good definition of a design pattern, for this context? (I have an intuition, but it seems to resist my naive attempts at pinning it down...)
13:34:57 <kmc> i don't
13:35:18 <kmc> i cynically describe it as a macro you're forced to write out by hand
13:35:50 <kmc> but the term is also abused to mean "anything the 'patterns community' wishes to encourage"
13:35:56 <kmc> regardless of the structure of the idea
13:36:09 <kmc> i don't expect that the "write code that doesn't suck pattern" can ever be made into a library
13:36:16 <companion_cube> design patterns are ways to use classes to fix flaws of java
13:36:28 <mornfall> So at that level, it won't be "use double dispatch because it lets you manage complexity of X" but "here's how you write double dispatch in language Y".
13:36:47 <kmc> well it's usually "here's how and why"
13:37:05 <kmc> but a document merely explaining a language feature isn't a design pattern
13:37:15 <mornfall> Right, but it's not "here's why, the how is trivial".
13:37:21 <kmc> yeah
13:37:53 <kmc> the java people won't consider classes a design pattern, because Java has syntax for them
13:38:06 <kmc> but first-class functions are, because you have to fake it, in a standardized boilerplate way
13:38:10 <mornfall> But yeah, I do wonder why so many otherwise competent-seeming people think of design patterns as the best thing since structured programming. :)
13:38:28 <kmc> most of the programmers i know and respect do not think highly of design patterns
13:38:54 <roconnor> I really can't make heads or tails of this thing
13:39:19 <roconnor> normally when I randomly slap functions together that typecheck something happens
13:39:26 <mornfall> :D
13:39:33 <MHD_> Isn't the most important thing to avoid Anti-patterns?
13:39:35 <roconnor> but this just hangs
13:39:45 <kmc> haha
13:39:49 <shachaf> roconnor: Which thing?
13:39:51 <mornfall> roconnor: Hangs eating CPU or hangs doing nothing?
13:40:00 <kmc> if a pattern is "anything the patterns community encourages" then an anti-pattern is "anything the patterns community discourages"
13:40:00 <roconnor> let me check
13:40:01 <mornfall> shachaf: Some iteratee stuff, legend has it. ;)
13:40:06 <shachaf> Ah.
13:40:06 <jonafan> i think of design patterns as common things that happens when you write in an OOP language with certain features
13:40:18 <kmc> i try to avoid the "Writing Code That Sucks" Anti-Pattern
13:40:23 <roconnor> mornfall: no CPU use
13:40:31 <kmc> i much prefer to utilize the "Writing Code That Is Pretty Good" Pattern
13:40:32 <mornfall> roconnor: Waiting for IO somewhere, then?
13:40:45 <roconnor> I don't know
13:40:50 <mornfall> roconnor: Can you strace it?
13:40:50 <roconnor> I didn't touch an of the IO functions
13:40:54 <mornfall> Oh.
13:41:00 <roconnor> *any
13:41:00 <mornfall> Hm.
13:41:01 <kmc> jonafan, that's fair because mostly people write about patterns in that context
13:41:04 <mornfall> That's weird then.
13:41:06 <jonafan> you write code because it needs to have certain features, then you step back and say "incidentally, this is a visitor pattern"
13:41:11 <kmc> but there are plenty of design patterns in Haskell too
13:41:19 <roconnor> mornfall: I'm guessing I got it in a loop deadlock thing
13:41:21 <mornfall> I can imagine half a dozen ways to write out a non-obvious infinite loop.
13:41:29 <mornfall> But that would probably eat CPU.
13:41:49 <roconnor> mornfall: fix id doesn't eat the CPU
13:42:03 <ezyang> Hmm. I'm trying to decide if doing x inserts to an IntMap, or creating an IntMap and then union'ing them, is faster.
13:42:08 <kmc> one little pattern is updateFoo r x = r { foo = x }
13:42:10 <ezyang> Probably the former.
13:42:17 <mornfall> Oh.
13:42:19 <kmc> this sucks, people acknowledge it sucks, so they write libraries like fclabels to fix it
13:42:21 <mornfall> GHC's tricky sometimes.
13:42:32 <kmc> it would be incorrect to write a book about the virtues of the Record Updater Function Pattern
13:43:01 <MHD_> wait, records are udateable?
13:43:17 <roconnor> MHD_: if you use lenses
13:43:27 <mornfall> They are not *mutable*.
13:43:33 <kmc> yep, «r { foo = x }» returns a record with the field foo having the value x, and otherwise identical to r
13:43:38 <MHD_> mornfall: I know
13:43:45 <kmc> with a typical compiler the other fields will be pointers back into the old record
13:43:47 <mornfall> But you can use them to construct new values that share all fields apart from some.
13:43:52 <mornfall> I mean, retain, not share.
13:43:55 <MHD_> Eff, I could have used that ten weeks ago
13:43:56 <mornfall> That was confusing bit of terminology.
13:44:01 <kmc> (pointers to the same stuff the old record pointed to, i should say)
13:44:17 <kmc> this is one of the main reasons to use records, which generally have shitty properties
13:44:21 <mornfall> Well, record is an ADT.
13:44:25 <MHD_> I know how it works, just wasn't familiar with the syntax
13:44:37 <mornfall> MHD_: Ah okey. :)
13:44:55 <mornfall> kmc: Matching on records can be useful.
13:45:10 <MHD_> Also, another little thing I have: Why isn't StateVar generic over all monads?
13:45:37 <kmc> how would that work?
13:45:44 <kmc> true mornfall
13:45:54 <kmc> even more useful with RecordWildCards and NamedFieldPuns
13:46:13 <mornfall> MHD_: Data.StateVar?
13:46:15 <MHD_> kmc: That there was a "makeStateVar :: (Monad m) => m a -> (a -> m ()) -> StateVar m a"
13:46:19 <mornfall> Or some other StateVar?
13:46:21 <MHD_> mornfall: ÅYeah
13:46:27 <MHD_> Yeah*
13:46:37 <mornfall> MHD_: Because Monad is concept that's too general.
13:46:49 <mornfall> MHD_: In some monads, there's simply no way to have StateVar.
13:46:51 <shachaf> Hmm, even the name "pattern" is pretty silly as a thing to encourage. The point of programming is to eliminate regularity.
13:47:15 <MHD_> mornfall: I know, but then say have a MonadVar class
13:47:16 <mornfall> MHD_: How would it work in Maybe?
13:47:23 <MHD_> mornfall: It wouldnt
13:47:27 <mornfall> I see.
13:47:33 <MHD_> mornfall: It would work in MonadState
13:47:37 <MHD_> In some cases
13:47:55 <mornfall> Presumably because no-one has thought of the need. :)
13:48:10 <mornfall> Lifting things into typeclasses is a favourite Haskell pastime, though.
13:48:16 <MHD_> I am so going apeshit over haskell libraries sometimes
13:48:39 <MHD_> But the flaws are charming
13:49:12 <mornfall> Well, perfect composability is something you can aim for, not something you can achieve. :)
13:49:38 <MHD_> I think I might make a Control.Monad.StateVar package
13:49:49 <MHD_> To replace Data.StateVar
13:49:52 <MHD_> or something
13:50:31 <MHD_> It would also make it so that both IORef and STRef were StateVars
13:50:51 <mornfall> IORef already is, IIUIC
13:51:02 <MHD_> but STRef isn't
13:51:11 <MHD_> because StateVar is IO
13:51:23 <MHD_> And STRef is almost Identical to IORef
13:52:01 <mornfall> MHD_: Lift ST into a typeclass while you are at it. ;)
13:52:17 <MHD_> Why the hell not
13:52:28 <MHD_> Is there a MonadTrans of it?
13:52:40 <mornfall> I think ST is a bit special.
13:52:45 <c_wraith> isn't one of the examples the "fun with type functions" paper covers creating a class that covers both IORefs and STRefs?
13:53:07 <MHD_> maybe, havent read it
13:53:10 <benmachine> typeclasses are overrated
13:53:17 <benmachine> yeah, I said it
13:53:26 <MHD_> benmachine: Blasphemy!
13:53:27 <mornfall> benmachine: Dude.
13:53:28 <kmc> it might be hard to stuff STRef into this class due to the extra type parameter?
13:53:41 <mornfall> kmc: That's why type functions, I guess. :)
13:53:56 <kmc> you can only modify (STRef s a) within monad (ST s), not (ST s1)
13:53:59 <mornfall> The type family welcomes all.
13:54:04 <kmc> hehe
13:54:13 <MHD_> What is the extra type paramer of ST?
13:54:19 <MHD_> What does it do?
13:54:27 <mornfall> State.
13:54:32 <kmc> anyway it's true that most monads would have no use for makeStateVar, but it's still reasonable to generalize the function to any context for which you *can* provide the getter and setter
13:54:42 <c_wraith> it ties an STRef to the particular invocation of runST that it was created in.
13:54:43 <MHD_> Yeah, but what is it?
13:54:51 <kmc> MHD_, it's never instantiated
13:54:52 <c_wraith> It never actually *is* anything
13:55:01 <benmachine> makeStateVar Nothing (const $ Just ())
13:55:04 <mornfall> Sounds like a witness.
13:55:06 <sanjoyd> I'm using Happy to generate a parser, but the generated HS file gives me a 'Not in scope: `happy_var_0''.
13:55:13 <sanjoyd> Any idea where I might be wrong?
13:55:13 <kmc> ST uses a type system trick to ensure that stuff inside each runST is a "closed universe" of state
13:55:14 <c_wraith> It just prevents the value from being leaked, because you can't express its type in the return value of runST
13:55:41 <MHD_> coooooooooooooool
13:55:48 <kmc> at runtime, ST and IO are identical
13:55:58 <mornfall> Yeah, that's the catch with ST. :)
13:55:58 <kmc> and runST and unsafePerformIO are identical
13:56:00 <MHD_> but at compile time they arent!
13:56:06 <kmc> yeah, ST has compile-time safety checking
13:56:12 <mornfall> You don't need that witness with State.
13:56:25 <MHD_> that is like oceans elevn clever
13:56:31 <kmc> and the safety checking is not a compiler special feature, but is a consequence of how they use this very general and separately useful rank-2 types feature
13:56:32 <kmc> yes
13:56:34 <mornfall> (Because State is actually pure.)
13:57:05 <MHD_> Can you make State continuations based?
13:57:05 <mornfall> But ST is fast.
13:57:12 <kmc> MHD_, it already is
13:57:17 <kmc> all monads are
13:57:28 <kmc> (>>=) takes an action and a continuation for what to do after that action
13:57:29 <MHD_> *head desk*
13:57:30 <kmc> :t (>>=)
13:57:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:57:42 <mornfall> CPS for the masses.
13:57:47 <c_wraith> Well.  Mutable structures in haskell aren't that fast.  ST is only faster than pure code if it allows you to do significantly less allocation
13:57:51 <MHD_> I know. Understand what I mean, Not used to all this yet
13:58:18 <kmc> it might be fun to implement State with Cont, though
13:58:19 <MHD_> Also, where is GHC's include directory?
13:58:19 <mornfall> c_wraith: You can almost say that in full generality, without reference to ST. :)
13:58:28 <kmc> MHD_, what does that mean? "include directory?"
13:58:46 <mornfall> Probably the reverse of an exclude directory.
13:58:51 <MHD_> kmc: I need to cram in some OpenAL headers somewhere...
13:58:52 <mornfall> Or inverse.
13:58:55 <kmc> MHD_, C headers?
13:58:58 <MHD_> monrfall: har. har. har.
13:59:08 <MHD_> kmc: yeah, to build openal with haskell
13:59:18 <MHD_> kmc: also probably some LLVM headers
13:59:29 <kmc> cabal install --extra-something=foo
13:59:34 <ddarius> A continuation state monad works out nicely.
13:59:34 <mornfall> Oh. LLVM. Magic. :)
13:59:38 <kmc> --extra-include-dirs  /  --extra-libs-dirs
14:00:03 <MHD_> mornfall: LLVM is indeed magic
14:00:15 <kmc> how so?
14:00:17 <MHD_> mornfall: Especially the monad
14:00:33 <MHD_> The LLVM monad is like, way awesome
14:00:44 <acfoltzer> MHD_: ocean's eleven clever is a great way to describe it, nice
14:00:49 <MHD_> it allows you to do JIT compilation and use the resulting code as functions
14:00:51 <acfoltzer> it's one of my favorite type system tricks, too
14:01:06 <mornfall> MHD_: Sounds inherently unsafe to me.
14:01:18 <MHD_> mornfall: it's encapsulated in IO
14:01:25 <kmc> MHD_, i agree that is cool, but I'll be the curmudgeon and point out that Lisp has had this for 30 years
14:01:28 <mornfall> MHD_: Type unsafe.
14:01:37 <kmc> it's as type unsafe as importing C code generally
14:01:41 <mornfall> I promise promise promise this function is of type Foo -> Bar.
14:01:47 <MHD_> mornfall: It's not, actually.
14:01:55 <kmc> if you want to compile Haskell code and import it in a type-safe way, there are other libs for that
14:02:03 <kmc> with the LLVM library you're generating something like assembly
14:02:18 <mornfall> kmc: Well, typed assembly, though.
14:02:20 <MHD_> LLVM is type checked
14:02:32 <mornfall> As far as assembly can be typed, anyway.
14:02:32 <MHD_> very thoroughly type checked
14:02:43 <kmc> more so than C code?
14:02:54 <MHD_> kmc: ye
14:02:56 <MHD_> yes*
14:03:03 <mornfall> kmc: I think it doesn't have implicit casting.
14:03:16 <MHD_> You cant even convert between i32 and i64 without an instruction
14:03:20 <kmc> if my LLVM function returns a pointer, the Haskell type checker has no knowledge of the layout of the struct at that address
14:03:34 <kmc> if you're using Storable et al, it's still fundamentally not only type unsafe but memory unsafe
14:03:36 <mornfall> Right, that's what I initially meant. :)
14:03:50 <MHD_> II havent read that much of it
14:03:53 <mornfall> Although as long as you talk scalars, it can be safe.
14:03:53 <kmc> if you're using LLVM to generate little Int -> Int functions then I agree they can be mostly typechecked
14:04:02 <mornfall> But that's not very interesting.
14:04:05 <MHD_> But it uses haskells type system to ensure things with type magic
14:04:22 <kmc> cut out the middleman!  http://mainisusuallyafunction.blogspot.com/2010/09/executing-bytestring.html
14:05:05 <MHD_> lol
14:05:12 <MHD_> Python has that too
14:05:22 <mornfall> That's a bit sick, though.
14:05:27 <kmc> only a bit?
14:05:28 <MHD_> yeah
14:05:40 <MHD_> Turing completeness to the max
14:06:26 <mornfall> kmc: Well, it can be good that you can execute arbitrary blobs. As long as that doesn't happen at random, like in C.
14:06:59 <kmc> yeah
14:07:03 <mornfall> Like, oh, you wrote over my return address. Let me jump at some random location for you kthxbay.
14:07:16 <tsuraan_> I still want something like erlang's term_to_binary that you can just hand a function to.  I don't think that really makes any sort of sense in Haskell, but I miss it :)
14:07:18 <kmc> but it's fine, because C programmers never make mistakes!
14:07:34 <kmc> tsuraan_, http://hackage.haskell.org/package/hint ?
14:07:48 <kmc> what's the input type of term_to_binary?
14:07:58 <tsuraan_> in erlang, anything
14:08:13 <kmc> you said "a function"
14:08:19 <kmc> do you mean source code for a function?
14:08:21 <kmc> or the function itself?
14:08:23 <tsuraan_> it makes anything into a binary (ByteString-ish thing), and then binary_to_term converts a binary into whatever it was
14:08:27 <tsuraan_> the function itself
14:08:29 <kmc> oh
14:08:39 <kmc> so it's not 'hint', it's universal serialization
14:08:41 <mornfall> Well, introspection I guess.
14:08:47 <kmc> yeah, it is hard to do this in most Haskell systems
14:08:48 <benmachine> as nice as that is it must make a lot of optimisations impossible
14:08:51 <tsuraan_> and haskell doesn't have function pointer-type-things, so it probably doesn't make sense at all for haskell
14:08:51 <kmc> YHC had it at one point
14:08:53 <mornfall> The function knows its source.
14:09:02 <tsuraan_> mornfall: in haskell?
14:09:02 <kmc> sure Haskell has function pointers
14:09:06 <tsuraan_> really?
14:09:11 <mornfall> tsuraan_: I am guessing about erlang here.
14:09:16 <kmc> Foreign.Ptr.FunPtr
14:09:21 <mornfall> Not in Haskell (although probably nothing precludes it).
14:09:24 <mornfall> GHC doesn't do that though.
14:09:39 <kmc> YHC had universal serialization at one point
14:09:46 <kmc> it stores functions as bytecode
14:09:55 <tsuraan_> yeah, that's what erlang does
14:10:07 <kmc> benmachine, which optimizations?
14:10:10 <tsuraan_> and then the erlang VM can compile it down to machine code, if it wants
14:10:13 <mornfall> Well, if you went with LLVM JITter, you could have that in GHC too, maybe.
14:10:22 <kmc> yes
14:10:26 <kmc> this is my dream
14:10:30 <kmc> Super Mutant Template Haskell
14:10:33 <benmachine> kmc: no specific ones
14:10:36 <kmc> with runtime code generation
14:10:40 <benmachine> just general magic
14:10:50 <mornfall> kmc: Typesafe.
14:10:51 <kmc> sure, it's hard to optimize the use of the function that comes out of the deserializer
14:10:54 <kmc> mornfall, sure
14:11:16 <kmc> two APIs: one that typechecks the code when you typecheck the code-generating-code
14:11:23 <kmc> the other that typechecks the code when you generate it (at runtime)
14:11:25 <kmc> both are typesafe
14:11:29 <tsuraan_> it helps for erlang that they only have a small handful of types that they need to serialize.  haskell is a bit crazier on the types front
14:11:30 <kmc> that is the direction TH is going anyway
14:11:41 <kmc> erlang is dynamically typed
14:11:42 <mornfall> tsuraan_: Not really.
14:11:49 <kmc> that means 'types' are a totally different concetp
14:11:58 <mornfall> tsuraan_: As long as you stay out of existential types, it shouldn't be all that different.
14:12:33 <mornfall> And serialising witness types is kind of pointless anyway. :)
14:13:00 <MHD_> If you are all so iffy about LLVM: http://hackage.haskell.org/packages/archive/llvm/0.9.1.2/doc/html/LLVM-Core.html
14:13:32 <kmc> why mornfall?
14:13:50 <kmc> a typical use of existentials in Haskell is OOP
14:14:08 <kmc> the type is the interface; the implementation is hidden by the existential quantifier
14:14:16 <kmc> i'd want to be able to serialize these objects
14:14:35 <kmc> MHD_, I'm not iffy about LLVM
14:14:37 <kmc> i think it's great
14:14:43 <MHD_> heh
14:14:51 <MHD_> You seem sceptical about type safety
14:15:05 <mornfall> Well, I guess it should work. Although I think GHC won't make Read/Show instances for non-Haskell98 types.
14:15:14 <kmc> i think that if i generate LLVM code which manipulates structs through pointers, it will not be typesafe
14:15:18 <mornfall> But that may be kind of arbitrary.
14:15:18 <kmc> the same is true for plain old C code
14:15:18 <roconnor> I do I join an Enumertee and Interatee into an Interatee?
14:15:26 <kmc> mornfall, it can
14:15:35 <kmc> you can derive instances on GADTs even
14:15:48 <roconnor> ah =$
14:15:48 <kmc> but the existential is probably a problme
14:15:51 <mornfall> Can you? It always gave me shortcut directions to Hell.
14:15:53 <MHD_> But LLVM has typesafe pointers... Mostly
14:16:04 <kmc> and array bounds checking?
14:16:11 <MHD_> I guess.
14:16:23 <mornfall> Anyhow, I am knee-deep in LLVM C++ code.
14:16:24 <kmc> mornfall, you have to use StandaloneDeriving
14:16:31 <benmachine> mornfall: if you use standalone deriving GHC just generates the code and hopes
14:16:35 <mornfall> kmc: I never even heard that. :)
14:16:43 <benmachine> if it breaks it's your problem :P
14:16:48 <mornfall> benmachine: Way cool. :)
14:16:57 <kmc> i mean it's still safe
14:17:00 <kmc> it generates and typechecks the instance
14:17:02 <benmachine> (well, hopes that it will type check)
14:17:31 <mornfall> Well, what I don't know is how it will reify the opaque value in read.
14:17:38 <k0ral> anyone could tell me if there is a difference in final executable size depending on whether I import all GTK or only the submodules I need ?
14:17:38 <lambdabot> k0ral: You have 1 new message. '/msg lambdabot @messages' to read it.
14:17:52 <mornfall> You need *some* value there, afterall.
14:18:08 <kmc> mornfall, you can't derive that particular instance
14:18:17 <kmc> you can't derive Show for *all* GADTs
14:18:47 <mornfall> kmc: So how would an universal serialiser solve that?
14:19:04 <kmc> well i'm not saying you can write a universal serializer in pure GHC Haskell
14:19:09 <mornfall> :)
14:19:11 <mornfall> Okey.
14:19:13 <kmc> so it's irrelevant what GHC is today capable of doing
14:19:14 <HugoDaniel> :D
14:19:17 <mornfall> (Well, Data.data *could* help.)
14:19:20 <mornfall> Data.Data*
14:19:46 <kmc> http://hpaste.org/47600/deriving_show_for_an_existenti
14:20:06 <kmc> if we extend GHC properly then we can assume Show (or rather "Serialize") for all types
14:20:20 <kmc> but it's kind of all-or-nothing
14:20:35 <kmc> because serializing a function requires serializing the values it's closed over, but their types are not part of the function's type
14:20:40 <mornfall> Nice.
14:21:26 <ski> also, it's hard to serialize things like an `IORef Foo'
14:21:46 <kmc> or a Handle
14:21:51 <mornfall> ski: Well, depends what you expect to do with it when you deserialize.
14:21:52 <ski> yea
14:22:18 <ski> i expect it to yield the same reference as was serialized, of course
14:22:45 <mornfall> Can't serve. :)
14:23:40 <Saizan> eden serializes functions by their address
14:23:56 <Saizan> won't serialize mutable vars though, last time i checked
14:23:58 <mornfall> Whatever eden is.
14:24:01 <c_wraith> that seems tough to make portable between systems.
14:24:08 <ski> in OCaml, you can marshall(sp ?) closures, if you unserilize in a process running the same program compiled for the same platform, with the same compiler version
14:24:31 <kmc> this is useful in some settings but not in the settings where Erlang is often used
14:24:43 <ski> iirc, Erlang just transmits bytecode
14:24:43 <mornfall> ski: Which isn't nearly as general as an IORef though.
14:24:51 <ski> mornfall : *nod*
14:25:13 * ski doesn't remember how the marshaller in OCaml handles `ref's .. probably by barfing an exception
14:25:21 <mornfall> Wow for multithreaded browsers.
14:25:31 <mornfall> Now bad javascript can eat more than one CPU core!
14:25:47 <MHD_> Is there like a compendium for flags that you can give Cabal install?
14:26:08 <mornfall> cabal help install :)
14:26:30 <MHD_> suh
14:26:32 <MHD_> duh
14:26:43 <MHD_> Maybe I should take off my leathe gloves
14:26:54 <MHD_> they don't helpmy typing
14:27:07 <mornfall> Beware the fingerprints though.
14:27:26 <MHD_> They were fingerless in the first place
14:27:27 * hackagebot hbro 0.4.5 - A suckless minimal KISSy browser  http://hackage.haskell.org/package/hbro-0.4.5 (koral)
14:28:56 <mornfall> It drags in zeromq!
14:29:00 <mornfall> (hbro)
14:29:06 <kmc> minimal!
14:29:11 <kmc> zero is the smallest number
14:29:27 <ski> > pred 0
14:29:28 <lambdabot>   -1
14:29:40 * ski couldn't resist
14:30:56 <mornfall> Zero is the smallest ordinal.
14:31:40 <ddarius> Zero is the smallest number greater than or equal to zero.
14:31:48 <kmc> > рred 0
14:31:50 <lambdabot>   NaN
14:33:01 <mornfall> Now say something about referential transparency.
14:33:21 <mornfall> How did -1 turn into a NaN.
14:33:57 <monochrom> @undefine
14:34:00 <monochrom> > pred 0
14:34:01 <lambdabot>   -1
14:34:33 <mornfall> lambdabot is a stateful sinner...
14:34:45 <monochrom> @chop lambdabot
14:34:46 <lambdabot> Maybe you meant: echo show
14:35:42 <benmachine> @stop lambdabot
14:35:42 <lambdabot> Maybe you meant: show slap
14:36:07 <mornfall> Don't @slap him, it's a trap.
14:37:31 <monochrom> @slap lambdabot
14:37:32 * lambdabot activates her slap-o-matic...
14:37:34 <kmc> mornfall, stupid tricks
14:37:48 <kmc> mornfall, hint: are "pred" and "рred" really the same function?
14:37:53 <MHD_> Anybody know what version of LLVM architecture that the LLVM package requires?
14:38:07 <monochrom> > map ord "рred 0"
14:38:08 <lambdabot>   [1088,114,101,100,32,48]
14:38:22 <monochrom> heh, 1088 is too big to be ascii
14:38:23 <MHD_> you sly dog
14:38:49 <kmc> maybe i can interest you in logging into bankofаmerica.com
14:38:51 * monochrom applies the trick again
14:39:07 <mornfall> > map ord "[1088,114,101,100,32,48]"
14:39:08 <lambdabot>   [91,49,48,56,56,44,49,49,52,44,49,48,49,44,49,48,48,44,51,50,44,52,56,93]
14:39:16 <ben> Firefox can't find the server at www.xn--bankofmerica-29j.com. :(
14:39:31 <kmc> > iterate (map ord . show) "hi"
14:39:32 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
14:39:32 <lambdabot>         against inferred type ...
14:39:34 <monochrom> because it's ipv6 day
14:39:40 <ben> Kinda happy that my terrible console font does not render non-latin letters properly
14:39:40 <kmc> > iterate (show . map ord) "hi"
14:39:41 <lambdabot>   ["hi","[104,105]","[91,49,48,52,44,49,48,53,93]","[91,57,49,44,52,57,44,52,...
14:39:56 <monochrom> @let рutStrLn s = text s
14:39:57 <lambdabot>  Defined.
14:40:07 <monochrom> > рutStrLn "hello"
14:40:09 <lambdabot>   hello
14:40:10 <mornfall> Now we are trespassing on -blah territory. :D
14:40:12 <monochrom> \∩/
14:40:12 <kmc> haha
14:41:42 <mornfall> I don't seem to have a routable v6 address...
14:49:50 <MHD_> Man, sometimes it feels like haskell is my only true love
14:50:01 <MHD_> Women are just too much ttrouble.
14:50:14 <sanjoyd> Yeah. They're not referentially transparent.
14:51:02 <luite> Eelis: if you're interested, I went with selinux instead of ptrace for my sandbox thing. this has the advantage that you can selectively restrict access to file descriptors in the daemon
14:51:49 <BobFunk> any image library that handles alpha channels for png?
14:51:50 <MHD_> sanjoyd: what an excellent metaphor
14:51:58 <MHD_> Women have hidden state
14:52:02 <BobFunk> and allows resizing and cropping
14:54:16 <MHD_> How many great haskell gurus lurk this channel?
14:54:20 <Taslem> When you use let/in, does Haskell remember the values it assigned to the variables?  Like, when you do:  let q = f z in q + q?
14:54:44 <c_wraith> it's a single name binding.
14:54:51 <Eelis> luite: that's a reasonable choice. i don't like anything that requires kernel modules though
14:55:02 <c_wraith> the thunk only gets evaluated once (in the absence of some concurrency cases)
14:55:06 <geheimdienst> c_wraith: i think he means: does f z get evaluated twice or once
14:55:11 <MHD_> Taslem: look at fix
14:55:18 <c_wraith> geheimdienst: which I then answered :)
14:55:33 <MHD_> Taslem: fix f = let x = f x in x
14:55:57 <Cale> Taslem: It's really up to the implementation, but yes.
14:56:03 <Taslem> Oh, okay.
14:56:40 <Cale> Taslem: Typically, constants are not re-evaluated as long as they remain in scope.
14:56:56 <Cale> (Lazy evaluation says they aren't)
14:57:39 <Cale> With enough cleverness, you can make use of that fact to memoise things, as Data.MemoCombinators does.
14:58:10 <Cale> (but it's not the same as function memoisation outright, which if applied everywhere would result in no garbage collection ever being done)
14:58:14 <dylukes> Cale!
14:58:18 <Cale> hi
14:58:31 <dylukes> I have a friend who's looking for some software for visualizing polyhedra and their stellations.
14:58:35 <luite> Eelis: yeah I understand. my solution bascially needs a seperate install because of this (also because it requires 100 user accounts, some group scheduler settings, lots of --bind mounts and other "intrusive" stuff)
14:58:37 <dylukes> I think it was called Great Stella or something
14:58:43 <dylukes> I figured you'd know where it might exist
14:58:50 <dylukes> or if there's something equivalent or better.
14:58:57 <dylukes> It involves polyhedra. You're the go to guy.
14:58:57 <Eelis> luite: yeah, it's a trade-off
14:59:28 <Cale> :) I don't actually know. I'd probably just use Mathematica if I needed to produce a diagram of some polyhedron.
14:59:32 <FurryHead> Hi everyone!
14:59:38 <dylukes> yeah, that's what I said.
14:59:45 <dylukes> Learn to program/plot/use math tools
14:59:46 <dylukes> >_>
14:59:46 <luite> but I hope to have my Wolfgang website back soon with the new sandbox. now with all new haskell evaluation on the web, with IO :p
15:00:12 <Cale> http://www.software3d.com/Stella.php
15:00:15 <geheimdienst> luite, nice work :)
15:00:23 <Cale> It does look kinda cool though :)
15:00:28 <dylukes> Cale: yeah, he's somewhat broke.
15:00:35 <dylukes> Basically I was wondering if you already had it. I
15:00:41 <dylukes> I'd force him to pay for a license eventually, mind you.
15:00:43 <dylukes> I always do.
15:00:50 <dylukes> ^^
15:01:04 <dylukes> Hm… so if my Google Talk client stops working,
15:01:08 <dylukes> can I still blame IPv6 today?
15:03:09 <geheimdienst> http://www.software3d.com/JPeg/GRhomCubOct+Cat.jpg <- about that, the website says "Great Rhombicuboctahedron". what a name for a kitty
15:06:47 <FurryHead> @exec 5*6
15:06:47 <lambdabot> Unknown command, try @list
15:06:51 <FurryHead> @list
15:06:51 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
15:07:04 <geheimdienst> > 5*6
15:07:05 <lambdabot>   30
15:07:20 <FurryHead> @slap me
15:07:20 <lambdabot> stop telling me what to do
15:07:28 <FurryHead> @slap FurryHead
15:07:28 * lambdabot secretly deletes FurryHead's source code
15:07:33 <FurryHead> @slap FurryHead
15:07:33 <lambdabot> *SMACK*, *SLAM*, take that FurryHead!
15:07:41 <FurryHead> Wow. Aggressive bot :p
15:09:38 <FurryHead> Is there a drastic difference between 6.12.* and 7.0.3?
15:10:03 <FurryHead> (I'm reading a haskell book, and it says to get the latest version. If there's a drastic change in the language, I'll use 6.12 instead)
15:10:33 <kmc> those are versions of GHC, not of Haskell
15:10:57 <kmc> GHC 7.0 implements Haskell 2010 by default; GHC 6.12 implements Haskell 98 by default, but the differences between the two are minor
15:11:23 <kmc> if you're using language extensions (or a library which uses language extensions), the difference between the compiler versions will matter more
15:11:29 <kmc> anyway you should get GHC 7
15:11:45 <aavogt> the difference you might notice is that n+k patterns are off by default with 7 but not with 6.12
15:12:52 <kmc> by which i mean, get the latest Haskell Platform
15:12:53 <geheimdienst> FurryHead: there's no big differences. don't worry. i recommend ghc 7
15:12:56 <kmc> which comes with GHC and useful libraries
15:12:58 <FurryHead> Ok
15:13:44 <Favonia> aavogt: I hope they've removed n+k patterns from all tutorials :p
15:14:05 <kmc> they are used in some old books
15:14:36 <geheimdienst> used for what? confusing people and giving haskell a bad rap?
15:14:39 <geheimdienst> ;)
15:15:04 <FurryHead> http://book.realworldhaskell.org/read/index.html
15:15:11 <aavogt> unfortunately there's no nice error message either
15:15:17 <kmc> yes, all of that should work well in GHC7
15:15:17 <FurryHead> That's the online book I'm using. It uses 6.8.?
15:15:40 <kmc> and there are various benefits to using the latest GHC
15:16:01 <luite> FurryHead: just use the latest one and ask here if anything doesn't work as expected
15:16:03 <acowley> people wanted inductive natural numbers and n+k are like a bad version of that
15:16:08 <geheimdienst> FurryHead: have you had a a look at LYAH? generally the approach is to start with LYAH and then move on to real world haskell (RWH)
15:16:10 <geheimdienst> @where lyah
15:16:11 <lambdabot> http://www.learnyouahaskell.com/
15:16:20 <FurryHead> ok
15:16:21 <smop> oic
15:16:25 <kmc> geheimdienst, on what do you base that claim?
15:16:26 <smop> guess i will finish that then
15:16:31 <kmc> i advise people to look at both books and see which they like more
15:16:32 <FurryHead> I was just looking at it to see if it's something I might like to learn
15:16:42 <FurryHead> Someone recommended learning a functional programming language.
15:16:52 <kmc> it's definitely not required to read LYAH before RWH
15:16:59 <kmc> Haskell is not a typical functional programming language :D
15:17:03 <kmc> but it's one of the most interesting ones
15:17:22 <FurryHead> Meh, it seems really big :\
15:17:23 <geheimdienst> kmc, i've heard it a few times in here, and i agree with it. i can see how RWH could be confusing if you're starting out ... *shrug*
15:17:24 <ben> If I buy the print version of LYAH, how much of the money is going to arrive at BONUS?
15:17:29 <chrisdone> It's one of the few functional languages in my view. :-P
15:17:41 <FurryHead> I am using TinyCore linux, and TinyCore's repo doesn't have ghc
15:17:44 <chrisdone> (Otherwise what the hell does ‘functional’ mean?)
15:17:45 <kmc> yeah we can argue until we turn blue about what a "functional language" is
15:17:53 <kmc> chrisdone, it means "not Java" ;)
15:17:59 <FurryHead> So I have to look through debian's repos for it, and it seems like there's a lot of deps that are large.
15:18:00 <aavogt> RWH explains the old Control.Exception
15:18:02 <FurryHead> :\
15:18:28 <FurryHead> 266MB???? O.O
15:18:36 <chrisdone> kmc: I like "functional as opposed to procedural". Scheme is procedural. Haskell functional.  ☺
15:18:39 <kmc> FurryHead, why do you care?
15:18:44 <kmc> Haskell is also prodecural
15:18:47 <kmc> Scheme is also functional
15:18:54 <kmc> whatever
15:18:59 <FurryHead> kmc: Perhaps it's the fact I have a 1.5GB hard drive for all my dev files. :\
15:19:04 <kmc> oh, that sucks
15:19:04 <FurryHead> (Including the OS)
15:19:09 <FurryHead> Yeeeaaaah.
15:19:09 <kmc> why is your drive so small?
15:19:19 <FurryHead> It's a hand-me-down, given to me by a friend
15:19:32 <tensorpudding> flash?
15:19:42 <FurryHead> the hard drive got fried, and all I had was a 1.5gb hdd on hand. Haven't had the spare cash to go purchase a new one.
15:20:04 <geheimdienst> @where tryhaskell
15:20:05 <lambdabot> http://tryhaskell.org/
15:20:09 <chrisdone> kmc: Scheme's about as functional as Java then. :p
15:20:11 <geheimdienst> ^^ you could always play with that
15:20:16 <tensorpudding> you'd find it hard to fit an os on that
15:20:19 <FurryHead> geheimdienst: Thanks :)
15:20:22 <kmc> you can get a 4GB USB stick for under $10
15:20:34 <FurryHead> kmc: On a USB1.1 interface? :D
15:20:39 <kmc> sure, i've done it
15:20:40 <FurryHead> (And I have a 4gb flash drive)
15:20:46 <kmc> won't be pretty, though
15:20:50 <FurryHead> It's murdorously slow.
15:20:54 <kmc> FurryHead, there's also "Hugs", an interpreter for Haskell 98
15:20:58 <kmc> pretty small program
15:21:06 <kmc> it doesn't support all the libraries and language extensions GHC does
15:21:11 <tmhtdougie> Hi all, I just installed the haskell framework from source on ubuntu. I have  a symlink at /usr/local/bin/cabal that points to my .cabal/bin/cabal executable. "which cabal" returns the location of the symlink. cabal --version says my cabal-install version is 0.8.0 but when i check the version of the executable in my .cabal dir it says the version is 0.10.2, why don't these versions agree?
15:21:14 <FurryHead> Ok, I'll check it out
15:21:18 <Favonia> Haskell is my favorite imperative PL!
15:21:29 <aavogt> it's funny that you might still hear the rumor that hugs98 has better error messages
15:22:29 <kmc> FurryHead, how much RAM do you have?
15:22:31 <zenzike> k
15:23:46 <FurryHead> kmc: 648mb
15:23:48 <acowley> tmhtdougie: perhaps another cabal on your path?
15:23:54 <FurryHead> (I think)
15:24:06 <byorgey> tmhtdougie: perhaps try runnung 'rehash' (zsh) or 'hash -r' (bash) ?
15:24:18 <FurryHead> brb
15:24:41 <geheimdienst> tmhtdougie: have you tried which -a cabal ?
15:24:52 <tmhtdougie> byorgey: You're MAGIC! It works! Thanks!
15:25:01 <byorgey> =D
15:26:32 <byorgey> tmhtdougie: most modern shells cache the location of programs that have been looked up in the path
15:26:34 <tmhtdougie> geheimdienst: Thanks for the command. Looks like I had an executable hiding in /usr/bin
15:28:23 <tmhtdougie> byorgey: That's good to know. I just assumed that since my /usr/local/bin comes first in my path that it wouldn't even look in anything else if it found the symlink.
15:29:23 <byorgey> tmhtdougie: right, the problem is that if it thinks it knows where cabal is it won't even look in /usr/local/bin at all
15:29:31 <byorgey> it's a rather sneaky gotcha
15:29:36 * hackagebot json-builder 0.1.1 - Data structure agnostic JSON serialization  http://hackage.haskell.org/package/json-builder-0.1.1 (LeonSmith)
15:29:45 <tmhtdougie> I'm not sure how the /usr/bin location got cached though. Is it possible that if I removed the cabal in /usr/local/bin that it would recache to the one in the /usr/bin ?
15:30:30 <byorgey> maybe. I don't know.
15:31:00 <kmc> i've sometimes got "/bin/foo: command not found" when i type "foo"
15:31:04 <kmc> because i'd rm'd it
15:32:07 <benmachine> tmhtdougie: it sounds weird that you'd put a symlink that goes from /usr/local/bin into your home dir. why not just put .cabal/bin on your path?
15:32:11 <danharaj> Who was it that came up with GHC's profiling tools?
15:32:13 <danharaj> Was it the simons?
15:32:17 <dylukes> benmachine: ^
15:32:26 <dylukes> Don't symlink things unless you have too...
15:32:36 <dylukes> keep multiple separate bins for different things,
15:32:48 <dylukes> i.e I have my /usr/bin, /usr/local/bin, rvm bin, cabal bin, etc
15:33:16 <dylukes> I never touch /usr/bin, its installation standard, but I put all my stuff in /usr/local/
15:33:20 <dylukes> keeps it nice and clean.
15:33:37 <tmhtdougie> I admit that would make sense but this machine isn't for production. Single user mucking around that will probably be reinstalled in about a week.
15:33:44 <dylukes> I install (through brew) everything in its own prefix, then symlink it into /usr/local/bin, lib, include, etc
15:33:46 <parcs> i keep all my stuff is ~/.local
15:34:15 <dylukes> Either way we all agree, managing binaries is a good thing to do,
15:34:20 <dylukes> and it's always better to install at the user level.
15:34:30 <dylukes> My policy is I rarely, if ever, should need to type sudo.
15:34:32 <kmc> i wish there were a cabal-to-dpkg thingy
15:34:36 <kmc> there is one for Arch Linux
15:34:38 <dylukes> kmc: I seriously don't.
15:34:46 <dylukes> Keep cabal and apt-get packages SEPARATE.
15:34:52 <kmc> why?
15:34:53 <dylukes> I don't want my package managers getting mixed up with each other.
15:35:03 <kmc> why should every language duplicate package management functionality?
15:35:05 <dylukes> You end up in situations where you have something installed in one,
15:35:06 <tmhtdougie> I usually install local things to ~/install and then place symlinks in ~/bin with ~/bin as the first location in my path
15:35:07 <dylukes> and not in the other,
15:35:12 <kmc> the problem is that you have n package managers in the first place
15:35:13 <dylukes> but it doesn't recognize the other as a dependency,
15:35:17 <kmc> there should be one.
15:35:19 <dylukes> etc...
15:35:22 <tmhtdougie> That way even with a very limited machine I maintain a lot of control over my installations.
15:35:22 <dylukes> Well,
15:35:28 <dylukes> I think there should be one system-level package manager,
15:35:35 <chrisdone> We use REHL for production servers, Cabal->RPM seems attractive to me.
15:35:36 <dylukes> and then individual ones per language/hackage type thing.
15:35:39 <geheimdienst> tmhtdougie: that sounds sensible to me
15:35:54 <dylukes> For instance, I use cabal for haskell stuff, npm for node.js stuff, rvm for rubies/gems...
15:36:05 <kmc> i kind of want to switch to NixOS
15:36:06 <dylukes> Those would certainly have collisions if they were all one manager.
15:36:14 <kmc> why?
15:36:15 <tmhtdougie> chrisdone: Are the RPMs up to date in the RHEL repo?
15:36:19 <dylukes> plus, I'd like to be able to uninstall entire languages and ALL of their packages easily in one go.
15:36:25 <thoughtpolice> i don't think anybody likes the recreation of tools like a build system or a package manager for every programming language that's ever been invented. unfortunately it's the reality it seems.
15:36:27 <dylukes> A unified package manager would be great but...
15:36:27 <chrisdone> tmhtdougie: Never!
15:36:28 <kmc> dpkg already does a fine job managing haskell, python, etc. packages
15:36:30 <dylukes> it's not feasible right now.
15:36:36 <thoughtpolice> for that reason i'm with dylukes when he says to just keep cabal and apt packages seperate.
15:36:36 <kmc> i don't understand why i should care what language a program was written in
15:36:40 <kmc> if i just want to download and use it
15:36:52 <dylukes> Right, but you may not just be downloading programs.
15:36:58 <dylukes> I think programs should have their package manager...
15:37:06 <dylukes> and then for modules per-language, have one for the language.
15:37:13 <dylukes> Haskell has cabal, Ruby has gems, Python has Pypi...
15:37:23 <tmhtdougie> CPAN has Perl :P
15:37:24 <geheimdienst> dylukes: i don't understand you, if you tell your system package manager to uninstall python, it will first remove anything that depends on python ...
15:37:25 <dylukes> they're "sub package-managers"
15:37:41 <dylukes> geheimdienst: ?...
15:37:44 <parcs> i'd first like a general package manager that can work at the root _and_ user level
15:37:51 <dylukes> parcs: this is true.
15:38:06 <dylukes> I'm just saying I like managing language-module packages separately from system-wide programs.
15:38:09 <geheimdienst> regarding your point that you'd like to uninstall an entire language sometimes
15:38:24 <dylukes> The other thing is, theres something of collision in naming.
15:38:37 <dylukes> You don't think most of cabal would collide with other stuff?
15:38:37 <kmc> ok, you keep saying what you want (which is what you have today) without saying why it's good
15:38:49 <dylukes> Because it's clean and it works.
15:38:52 <kmc> apt-get install libghc6-mtl
15:38:54 <dylukes> What's the problem as it is?
15:38:54 <kmc> no collision
15:39:04 <kmc> dylukes, massive wasted developer effort
15:39:12 <dylukes> apt-get install network -v>1.0
15:39:15 <dylukes> which network?
15:39:18 <dylukes> Haskell network module?
15:39:22 <dylukes> Ruby network module?
15:39:22 <kmc> apt-get install libghc6-network
15:39:24 <kmc> this exists *today*
15:39:31 <dylukes> Why would I want to put libghc6/7 in front of it.
15:39:33 <dylukes> That's obnoxious.
15:39:36 <dylukes> :|
15:39:39 <kmc> to fucking say which one you want
15:39:41 <kmc> gah
15:39:51 <parcs> heh
15:40:11 <dylukes> I think it makes more sense to use a package manager for each logical set of packages.
15:40:15 <thoughtpolice> :( flustered. personally I agree i shouldn't have to care about what language software is written in if i want to use it. the problem is, i both use lots of haskell software, and write it
15:40:18 <dylukes> You never worry about collisions, or inconvenient naming.
15:40:40 <dylukes> The point though, is cabal/gems/pypi etc… are repositories (mostly) of language modules,
15:40:42 <dylukes> not of programs.
15:41:04 <dylukes> they're, in my book, sub-managers...
15:41:08 <andrus> Can anyone tell me how to make this more idiomatic?: https://gist.github.com/1015661
15:41:25 <dylukes> if a package manager existed that enforced a logical hierarchy and allowed for switching between package contexts, that'd be fine I suppose.
15:41:33 <parcs> cabal is hardly a package manager, anyway. it's mostly a build tool with a cli frontend
15:42:26 <dylukes> parcs: Yeah… cabal isn't the best example ^^
15:42:27 <thoughtpolice> i'd say cabal is probably more of a package manager than a build system - it actually must do things like dependency resolution on packages. OTOH, it doesn't do any building on its own, and after it satisfies dependency constraints, merely invokes GHC --make
15:42:29 <dylukes> something like gems is better.
15:42:42 <dylukes> well, ghc-pkg is the real "manager" behind the scenes.
15:42:56 <dylukes> cabal is the build system which oddly front-ends it.
15:43:42 <dylukes> I have to go eat dinner… I'll come back to discuss this, it is interesting.
15:44:52 <kmc> i think we should have two independent teams developing two completely separate web browsers
15:44:59 <kmc> one for sites ending in ".com" and one for sites ending in ".org"
15:45:32 <geheimdienst> whatever you say, but i want to be on the team that can browse lolcats
15:46:04 <geheimdienst> oh wait, you were making a point about package managers 8-)
15:46:05 <kmc> i mean, otherwise there will be collisions
15:46:11 <geheimdienst> dylukes is gone, though
15:46:16 <kmc> i know, that's why i came back
15:46:18 <thoughtpolice> geheimdienst: would we have to lay out internet rules allowing lolcats to exist on only one domain, but not the other then?
15:46:35 <blackdog> hesitant as i am to wade into an already-started discussion - i think there are two very different use cases there. cabal sort of sits uncomfortably in the middle between using stuff on the system, and the sort of facility offered by rvm/virtualenv/cabal-dev of isolation and multiple environments
15:46:38 <thoughtpolice> well, not domain. you know what i mean.
15:46:39 <kmc> my spies are everywhere
15:46:56 <kmc> i agree that !∃ good hierarchical package manager
15:47:07 <kmc> (maybe "¬∃")
15:47:09 <thoughtpolice> blackdog: on that note, i am loving cabal-dev. :)
15:47:36 <kmc> a hypothetical such package manager would be vastly preferable to the hodge-podge duplication we have today
15:47:40 <kmc> "collisions" are a non-issue
15:47:49 <kmc> Debian already has loads of collisions between two packages both written in C
15:47:52 <kmc> they deal with it.
15:48:20 <blackdog> thoughtpolice: indeed:) it's a bit frustrating that it always has to recompile from scratch, but i can't think of a better way to do it in a compiled language. Ruby + RVM gets a pass because they only have to worry about the occasional extension package
15:48:40 <blackdog> kmc: namespaces are a honking great idea, let's do more of that etc
15:48:59 <thoughtpolice> yeah. cabal-dev ghci is also rather killer
15:49:07 <blackdog> thoughtpolice: .. say what?
15:49:12 <blackdog> tell me that does what i think it does
15:49:20 <blackdog> i've been wanting a bounded console for aaaaages
15:49:39 <thoughtpolice> https://github.com/creswick/cabal-dev - "Cabal-dev 0.7.3.1 and greater are capable of launching ghci with the project's package database and local modules (if the package under development exposes a library)."
15:49:54 <blackdog> dons: you must be busy - i posted a question on SO about Repa and got no response :)
15:50:08 <blackdog> thoughtpolice: kalloo kallay, that is the dog's bollocks.
15:50:23 <kmc> what an odd turn of phrase
15:50:44 <geheimdienst> the blackdog's bollocks or another dog's?
15:50:55 <thoughtpolice> blackdog: i know! :>
15:51:54 <chrisdone> ♥ cabal-dev ♥
15:52:38 <geheimdienst> andrus: your code looks pretty good already, if you ask me :) you just might want to add some more type annotations on the top-level functions. just for orientation. you'll see the warnings if you compile with -Wall, i believe
15:52:44 <dons> blackdog: somewhat busy, yes.
15:52:57 <dons> long days
15:54:20 <andrus> geheimdienst: thanks, i haven't tried compiling yet--i've just run it in ghci
15:55:11 <geheimdienst> > zip3 [1..5] [7..] [99..]
15:55:12 <lambdabot>   [(1,7,99),(2,8,100),(3,9,101),(4,10,102),(5,11,103)]
15:55:36 <geheimdienst> ^^ this might be a little easier than the double-zip you're doing in line 39 :)
15:56:00 <c_wraith> @hoogle zip3
15:56:00 <lambdabot> Prelude zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
15:56:00 <lambdabot> Data.List zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
15:56:01 <lambdabot> Prelude unzip3 :: [(a, b, c)] -> ([a], [b], [c])
15:56:01 <rudyl313> how can I specify more than one typeclass for my type parameter in: funcName :: Num a => Type1 a -> Type2  a  -> Type3 a ... i.e. more than just Num
15:56:17 <tmhtdougie> kmc: Do you purpose then that distribution maintainers interface their system package managers with Hackage?
15:56:19 <c_wraith> rudyl313: put the list in parens
15:56:20 <andrus> rad! thanks
15:56:28 <geheimdienst> funcName :: (Num a, Nom b, Nomnom a) => ...
15:56:32 <geheimdienst> rudyl313: ^^
15:56:48 <rudyl313> c_wraith: geheimdienst: thanks!
15:56:52 <kmc> tmhtdougie, Arch already does
15:57:00 <kmc> they have a bot that downloads Hackage packages and makes them into Arch packages
15:58:19 <tmhtdougie> That's pretty neat. But does it install cabal when you install the haskell framework?
15:58:20 <kmc> i expect such a scheme would never work with Debian's rules and procedures
15:58:35 <kmc> but i'd be pretty happy with a third-party apt repo
15:58:38 <kmc> or even a command i run myself
15:58:48 <kmc> that creates a .deb
15:59:02 <kmc> (there are many of these commands already)
15:59:25 <thoughtpolice> funny enough i created my first .deb the other day. only it wasn't for debian. it was for cydia. i was surprised at how easy it is (in the simple case that is, i understand some debian packages are um, rather complex)
15:59:34 <kmc> tmhtdougie, i don't know; i haven't used Arch for Haskell dev
15:59:41 <stepkut> let's say I have a parser with the type, Parser tok err a. Does it make sense to say, 'this parser works with a polymorphic token type'? That doesn't sound quite right to me.. but, abstract and generic didn't sound any better :)
15:59:57 <kmc> "this parser works with any token type"
15:59:59 <tmhtdougie> Wouldn't we need a third-party apt repo for every linux distribution then?
16:00:15 <stepkut> kmc: much better, thanks :)
16:00:26 <kmc> yeah
16:00:31 <kmc> this is in general how Linux software is distributed
16:00:34 <stepkut> kmc: i knew there was a simpler way to say it
16:00:38 <kmc> it's how Haskell Platform is already distributed
16:00:51 <kmc> s/apt/yum/ for some distros, of course
16:01:01 <geheimdienst> still i don't really see what the big deal is. having cabal and pacman side-by-side seems entirely practical to me. to me it's all in the category of "occasional minor inconvenience"
16:01:19 <kmc> i agree it's not a huge deal in practice
16:01:24 <kmc> i'm mostly concerned about wasted effort
16:01:28 <kmc> they both do the same thing
16:01:35 <kmc> why should smart people waste time writing that program twice
16:01:49 <geheimdienst> that's an important point, yes
16:02:05 <kmc> also, it's dumb that i can't (for example) point to any file on my system and say "what package installed this?"
16:02:17 <kmc> i have to separately ask "what Debian package installed this", "what Ruby package installed this"
16:02:28 <kmc> as an end user i do not care what language my apps are written in
16:02:31 <tmhtdougie> Sounds like you should write which-pkgman
16:02:37 <kmc> (not entirely true ;D)
16:02:37 <dylukes> kmc: My solution to that, is segregate installation prefixes properly.
16:02:56 <blackdog> kmc: maybe we're optimising on two different axes. if everyone used one system package manager, perhaps it could work, but if we need a solution for haskell devs, we either write a language-specific one or write an adaptor for each of the system package managers
16:03:01 <dylukes> My brew installations are exclusively in /usr/local/Cellar/, my rvm is exclusively in .rvm, and my cabal is exclusively in .cabal
16:03:15 <kmc> that's annoying -- more places to look for stuff
16:03:23 <dylukes> Don't mix and sandbox your managers, and you'll go far.
16:03:27 <kmc> it means i have to know what language a programis written in
16:03:29 <kmc> just to find its files
16:03:30 <dylukes> No.
16:03:37 <dylukes> Programs should always be in one manager.
16:03:45 <dylukes> gems/cabal/etc are for language modules
16:03:50 <dylukes> I disagree with programs being in them at all.
16:03:51 <dylukes> >_>
16:03:55 <kmc> whatever
16:03:57 <dylukes> Programs should be in apt-get/brew/etc
16:03:59 <dylukes> imo.
16:04:10 <dylukes> I don't like the mixing of modules/libraries/programs in package managers at all.
16:04:15 <kmc> hey, I have a Haskell question
16:04:20 <dylukes> Is it about confluence?
16:04:22 <dylukes> ^
16:04:23 <dylukes> ^^*
16:04:54 <kmc> does anyone have an example of using Logic / LogicT which can't be implemented (well) instead using Omega?
16:05:23 <geheimdienst> andrus: oh i just noticed, i think you could simplify lines 56-65 a little. it's possible to say e.g. "f 0 = 0 ; f 1 = 1 ; f x = something_more_complicated". in that case you can get rid of the "f n | n == 0 = ... n == 1 = ..."
16:05:32 <kmc> that is, I understand what fair msum gets you, compared to the list monad, but I don't understand what (>>-) or ifte get you
16:05:56 <Saizan> kmc: have you checked the paper?
16:06:05 <kmc> i read the (a?) paper a while ago
16:06:12 <kmc> i don't remember -- but i could go back and look again
16:06:27 <Saizan> i remember some examples but not the details
16:06:55 <andrus> geheimdienst: that's a good point
16:07:08 <geheimdienst> (... this would of course be more effective if you rename to_pallette to something shorter. i think in that short function, it's entirely okay to do a single-letter name and say in a comment "for converting to palette")
16:08:08 <geheimdienst> btw guys, is hlint turned off for hpaste now? i thought it would bitch about parens, as in "map (fst) xs"
16:18:09 <periodic> What's a good priority queue implementation?
16:18:18 <periodic> There are a lot of packages that could work...
16:18:21 <periodic> any suggestions?
16:18:38 <ezyang> Check what academic papers the queues are written off of.
16:18:43 <ezyang> Add points if Okasaki is mentioned ;-)
16:18:49 <periodic> I'm not well qualified to judge those...
16:18:54 <periodic> at least not in one afternoon...
16:19:10 <gwern> no, go by revdeps instead! ad hoc heuristics woot woot
16:19:23 <periodic>  ha.
16:19:29 <gwern> go by vox populi, not vox dei
16:19:33 <byorgey> periodic: I suggest http://hackage.haskell.org/package/pqueue
16:19:35 <ezyang> I recently did some work with PSQueue. However, this is a /searchable/ priority queue.
16:20:11 <geheimdienst> +1 to dependencies. if lots of people use it, chances are it kinda works and is somewhat documented
16:20:22 <monochrom> meaning a marriage of set and priority queue
16:20:29 <periodic> Ideally I could find a queue that has simple insert and getMin operations with Ord a.
16:20:53 <periodic> yeah, that's been another thing.  There are plenty of libraries that are still 0.10 or 0.21.  Hard to know how stable they are.
16:20:54 <thoughtpolice> while searching for priority queues on hackage - http://hackage.haskell.org/package/meldable-heap
16:20:58 <periodic> Thanks, byorgey
16:21:00 <thoughtpolice> "It has been proved correct using the Coq proof assistant. The proofs are included in the Cabal package."
16:21:27 <kmc> periodic, plain old Data.Map has that, yeah?
16:21:28 <thoughtpolice> i guess it was extracted and jim wrote a shim for it? how neat :)
16:21:35 <periodic> oh, well if it's been prooved...
16:21:35 <kmc> it won't be the fastest but it's built in and easy
16:21:36 <gwern> that wasn't the package with sed as part of the proof was it
16:21:38 <monochrom> we like to start with 0. then, since we are so perfect, there is no need to advance to 1.
16:21:49 <thoughtpolice> gwern: no, that was wouter's work
16:22:33 <thoughtpolice> gwern: specifically, on correctly modeling the stackset inside xmonad, iirc. sed was used to clip the result into xmonad in a compilable form, i think to change type names or something
16:22:36 <periodic> kmc: ha, never noticed that Data.Map does have those functions.  I always thought of it as a hash implementation.
16:22:37 <thoughtpolice> either way, uber gross
16:23:36 <kmc> yeah, it's not hashed at all
16:23:43 <kmc> it's a binary tree of bounded balance
16:23:48 <kmc> IntMap is a trie on the int bits
16:23:56 <kmc> thus it's usually much faster than Map
16:24:39 <kmc> the hashmap package has a type which hashes to index an IntMap, and uses Map within that to resolve collisions
16:24:49 <kmc> and i think there's a better version of that package in the works, but I forgot the name :/
16:24:49 <geheimdienst> thoughtpolice: interesting historical info. that could explain the off-the-wall names StackSet has for its parameters. "i" meaning "tag" and "a" meaning Window and such
16:24:51 <periodic> hm, what about an efficient map on Doubles?
16:25:04 <kmc> anyway hash tries are way better than flat hash tables in a functional and/or concurrent context
16:25:11 <monochrom> unordered-containers
16:25:13 <kmc> periodic, how many doubles?
16:25:17 <kmc> that's the one monochrom
16:25:18 <kmc> thanks
16:25:57 <periodic> kmc: It's an event queue, things are ordered by time.  Probably in the 1-100 element range, lots of inserts and removes though.
16:26:19 <kmc> plain old Map should be fine
16:26:35 <kmc> how frequently do you need to do lookups?
16:26:36 <periodic> Well, I'll give it a shot.  If the performance sucks, I'll find it in the profiling.  If not, hooray!
16:26:41 <kmc> yeah
16:26:44 <kmc> the HashMap API is very close
16:26:48 <kmc> also, there's a cheap "hash" for Doubles
16:26:49 <thoughtpolice> geheimdienst: what do you mean? wouter did this only recently and the result was definitely not merged into xmonad
16:27:00 <kmc> which is unsafeCoerce
16:27:21 <periodic> kmc: I hope the lookups won't be a large part of the program, as the main work will be in responding to events.  We'll see though.
16:27:24 <periodic> thanks for the input, everyone.
16:27:31 <andrus> so there is zipWith and zipWith3... is there a way to zipWithN where n is variable?
16:28:05 <kmc> no, what would its type be?
16:28:11 <geheimdienst> thoughtpolice: oh, then i misunderstood. then the strange names in StackSet have to have some other reason than "transplanted code"
16:28:11 <Saizan> with typeclass hackery yes, or you can use the ZipList applicative
16:28:13 <geheimdienst> nvm
16:28:37 <thoughtpolice> geheimdienst: specifically, he rewrote StackSet.hs in Coq, proved a bunch of invariants about it, then extracted haskell code, then clipped it into xmonad
16:29:02 <thoughtpolice> of course, like i said, it was gross as hell, because wouter had to literally clip it into the build using sed. coq-extracted programs are typically not very friendly to the outside world it seems
16:29:28 <Saizan> which won't give you zipWithN, but f <$> a1 <*> ... <*> an
16:29:31 <thoughtpolice> (or at least aren't extracted in a way that apparently does not require contortions? i can't say, i've never written a lot of proven things with coq)
16:29:31 <andrus> Saizan: is there a way to write dynamic typeclasses? I don't know what the terminology would be. I'll look into ZipList applicative
16:29:47 <gwern> thoughtpolice: so you might say coq programs are dicks
16:29:59 <Saizan> another option is TemplateHaskell, of course
16:30:00 <geheimdienst> thoughtpolice: it's interesting and it freaks me out a little :)
16:30:21 <Saizan> andrus: what do you mean by dynamic typeclasses?
16:31:03 <thoughtpolice> on the note of an n-ary zipWith, I found this interesting stack overflow answer: http://stackoverflow.com/questions/2468226/how-to-zip-multiple-lists-in-haskell
16:31:24 <thoughtpolice> specifically the solution ADEpt put in (from wren thorton) is small enough to include inline
16:31:48 <thoughtpolice> http://okmij.org/ftp/Haskell/polyvariadic.html#polyvartype-fn
16:32:53 <andrus> Saizan: my thinking is pretty fuzzy--i can't elaborate
16:33:31 <andrus> thoughtpolice: thanks, I will look into the post and polyvariadic page
16:34:21 <geheimdienst> oh ... how can i add say 1 day to an UTCTime? if i do things like «addUTCTime (secondsToDiffTime 1000) =<< getCurrentTime», there's mismatches between DiffTIme and NominalDiffTime, whatever that is
16:34:35 <geheimdienst> i suspect there's an easy solution, but it's not apparent to me from the haddock
16:34:45 <kmc> look at the typeclass instances?
16:35:21 <kmc> hmm, that's no good
16:35:21 <Saizan> ?hoogle addUTCTime
16:35:22 <lambdabot> Data.Time.Clock addUTCTime :: NominalDiffTime -> UTCTime -> UTCTime
16:35:33 <c_wraith> Isn't NominalDiffTime an instance of Num?
16:35:46 <doserj> i think so
16:35:52 <c_wraith> so you can just go addUTCTime 1000
16:36:19 <geheimdienst> ah! thanks guys :) that works
16:36:44 <parcs> the Num instance should be more emphasized in the docs..
16:36:52 <parcs> maybe some examples should be added too
16:37:00 <kmc> yeah, i remember being confused by this for a while
16:37:01 <geheimdienst> examples should be more empha... yeah absolutely
16:37:06 <luite> not all days have 86400 seconds though :p
16:37:50 <geheimdienst> luite: i will strangle anyone who utters the words leap second
16:38:03 <kmc> leap second
16:38:17 <aavogt> how long is February 29?
16:38:34 <c_wraith> when it happens, it's always the same length
16:38:41 <c_wraith> leap seconds are always on dec 31
16:38:50 <dylukes> I use UTC exclusively.
16:38:51 <kmc> they can be on June 30 in principle
16:38:54 <kmc> this has not happened recently
16:38:55 <geheimdienst> kmc: please provide your place of residence so i can strangle you
16:39:15 <geheimdienst> aavogt: around 6 hours on average?
16:39:59 <kmc> :D
16:40:32 <monochrom> > рutStrLn ("lea" ++ "p second")
16:40:34 <lambdabot>   leap second
16:40:42 <dylukes> Time to strangle lambdabot.
16:40:52 <dylukes> @vixen we're going to come strangle you now.
16:40:53 <lambdabot> right now?
16:40:58 <dylukes> @vixen yes, right now.
16:40:58 <lambdabot> that's what i figured
16:41:04 <dylukes> @vixen you're pretty sharp.
16:41:04 <lambdabot> am i? i'm glad you think so at least
16:41:38 <dylukes> @vixen chuck pants roast up turkey few garbage disc door
16:41:38 <lambdabot> i'm 19
16:42:34 <monochrom> since UTCTime is a record with a Day field, you can just add 1 to that field
16:42:48 <blackdog> dylukes: are you trying to confuse my bag of regexes?
16:43:06 <xplat> monochrom: but in that case don't you have to carry?
16:43:20 <monochrom> no. check it out.
16:43:28 <dylukes> blackdog: ^^
16:43:49 <xplat> 19-year-old bag of regexes?
16:44:28 <geheimdienst> monochrom: yeah, the whole thing hasn't clicked for me yet. there's also an addDay function in that package, but i couldn't get it to work rightaway ... whatever, the Num instance for NominalDiffTime works great :)
16:45:49 <monochrom> x{utctDay = addDay 1 (utctDay x)}
16:47:16 <aavogt> thoughtpolice: that zipWithN needs lots of type annotations
16:50:06 <aavogt> I guess you can't sensibly demand that the result type not be a function
16:53:38 <chrisdone> Rewrote hpaste in Snap and my pgsql library. It's now up on the new server, should be a lot faster now. Whether it's stable… we'll see.
16:53:45 * chrisdone goes to bed and sleeps like a baby
16:54:09 <djahandarie> Nice!
16:54:18 <djahandarie> Is this leading up to an IRC bot being available? :p
16:54:26 <Axman6> chrisdone: we demand blog posts!
16:54:48 <geheimdienst> chrisdone: oh, that's why hlint was off?
16:54:50 <chrisdone> djahandarie: Yeah, sounds like a plan. :-)
16:54:54 <geheimdienst> anyway, good work
16:55:02 <djahandarie> Wheee.
16:55:04 <djahandarie> chrisdone++
16:55:26 <chrisdone> geheimdienst: Yeah, I'll add that back (people use that?). That bit needs updating with some changes ndm did for me. :]
16:55:32 <chrisdone> o/
16:55:44 <geheimdienst> damn sure people use that!
16:55:46 <geheimdienst> :)
16:55:52 <djahandarie> That hlint thing was the most awesome thing ever
16:56:31 <chrisdone> Ah, okay. :-) Yeah, I love hlint, really nice software.
16:56:37 <geheimdienst> it's the main reason why hpaste is so much more useful than gist or whatever
17:00:52 <luite> chrisdone: feel really fast now
17:01:00 <chrisdone> :D
17:01:51 <djahandarie> Just curious, why snap rather than, say, Yesod, or any other framework? Familiarity?
17:04:36 <chrisdone> djahandarie: I really just wanted to test my pgsql library and give Snap a try, hpaste seems to be a really good baseline test, simple to do, existing database. Web-dev in Haskell still feels like an experiment.
17:04:57 <luite> it does..
17:07:23 <Evious> Anyone know how Snap and co compare against Erlang libraries like Misultin/Cowboy?
17:07:26 <luite> efforts also don't seem focused... we have lots of json libraries, many different html templating libs... some for javascript code generation, lots of database bindings
17:07:37 <luite> but none are really finished
17:08:18 <Evious> The JSON library creators should all get together, and assemble them into Voltron.
17:08:41 <Evious> I found that creating read-bindings to the untyped outside world, is one of the harder parts of Haskell.
17:09:49 <int80_h> yesod question here: I was looking for the best approach to do this  http://api.jquery.com/selected-selector/
17:11:51 <luite> no idea, I still write my jquery by hand :p
17:12:13 <chrisdone> luite: Indeed. At least Snap and Yesod seem to be emerging as favourites, I think. I see those mainly mentioned in real-world cases.
17:14:03 <chrisdone> (Judging from this thread recently http://www.reddit.com/r/haskell/comments/ht9k1/biggest_most_popular_most_trafficked_web_app/)
17:14:10 <cmccann> my impression is that both Snap and Yesod are actually used for real-world work, and both are similar enough to "standard" approaches to be not heavily experimental while still getting a lot of benefit from being Haskell
17:14:36 <cmccann> and the most significant differences between the two seem to be in matters of personal taste
17:14:53 <chrisdone> Ah, I forgot about happstack. (Sorry, HS guys! >_>)
17:14:57 <luite> hehe
17:15:14 * chrisdone nods
17:15:15 <thoughtpolice> people seem to give yesod a lot of flac for the template-haskell usage, but honestly I'm with snoyman and others when I say "i dunno why"
17:15:53 <cmccann> some people find that sort of heavy reliance on metaprogramming and weird magic to be distasteful
17:16:00 <thoughtpolice> especially considering you can just get rid of pretty much all of it, AFAIK. don't like hamlet? plug in something like heist. don't want QQ for routing? use the regular routing rules
17:16:10 <aavogt> happstack state is similar
17:16:16 <thoughtpolice> er, routing data types
17:16:20 <aavogt> in that there's lots of magic in the TH
17:16:23 <cmccann> and I can kinda see why, I guess, but it doesn't bother me that much
17:16:47 <luite> I use happstack for my gitit wiki, but I need some functionality that's not really supported by gitit (json interface, more complicated user management), not sure what to do yet
17:17:00 <thoughtpolice> cmccann: yeah. in most cases for yesod QQ/TH just seems to be used to give a convenient syntax. and if you don't even want that *library* you can just throw it out all together
17:17:19 <hpc> chrisdone: hachicode.com doesn't DNS for me :/
17:17:30 <cmccann> I figure it's worth giving yesod a try for anyone who's not sure what they'd prefer
17:17:38 <thoughtpolice> i think snoyman said a good portion of the sites he's developed in yesod for example, don't use things like persistent or warp etc.
17:17:46 <joe6> is there a smarter way of writing this?  filter (\x -> (/=) "" $ head x)
17:17:56 <chrisdone> hpc: Works here. IP is 175.41.138.141
17:18:01 <joe6> can I do it without the lambda?
17:18:12 <luite> I've used persistent (on postgresql) with snap :)
17:18:13 <hpc> joe6: filter ((/= "") . head)
17:18:18 <hpc> @pl \x -> (/=) "" $ head x
17:18:19 <lambdabot> ([] /=) . head
17:18:23 <joe6> hpc, thanks
17:18:51 <hpc> i would personally write filter (\x -> head x /= "")
17:18:53 <cmccann> joe6, could also consider (not . null . head)
17:19:01 <thoughtpolice> luite: persistent seems neat, i dunno what i'd use it for though
17:19:09 <joe6> cmccann, that is better, more clarity, thanks.
17:19:11 <aavogt> luite: gitit can be used as a library sort of like here http://hpaste.org/47603
17:19:44 <aavogt> so requests get handed off to it only once your main decides that is suitable
17:20:46 <hpc> chrisdone: a noble effort; everything on the page is linked using the full hachicode url; i assume the site is new, so i will just wait for the change to propogate to me
17:21:24 <chrisdone> hpc: Okies. S'weird because that link is a few days old at least.
17:22:03 <hpc> or ill try tomorrow, after ipv6-day is over
17:22:07 <chrisdone> hpc: Ah, I see others have the same problem. Eh, we'll see.
17:23:13 <int80_h> chrisdone: yeah it's a testament to the power of yesod that a n00b like myself can do anything with it at all. I'm having some success, but being inexperienced I'm looking to avoid the "wrong" way of doing things. If yesod has the right way to do wat UI want, I'd just as soon do it that way rather than write the jquery by hand.
17:23:36 <chrisdone> If anyone's interested in looking, or feels like reviewing somewhat, the hpaste code is on github, it's in strict MVC-style. https://github.com/chrisdone/amelie/tree/master/src I would like it to be in a state where people can and want to hack on it. I have to go to sleep now but I'll read the backlog in the morning.
17:23:57 <joe6> any smarter way of writing this: filter (not . null . head) . filter (not . null) . map words . filter (not . null) . lines $ lst
17:24:17 <chrisdone> int80_h: Sure, that's good. Would you say it has a Railseqsue quality of being noob-friendly?
17:24:29 * chrisdone disappears in a puff of smoke
17:25:14 <byorgey> joe6: does it behave the same if you take out the rightmost "filter (not . null)" ?
17:25:28 <byorgey> > words ""
17:25:29 <lambdabot>   []
17:25:31 <joe6> oh, yeah. sorry missed that.
17:25:38 <int80_h> chrisdone: no way, it forces me to think way harder than rails does.
17:25:42 <joe6>  filter (not . null . head) . filter (not . null) . map words . lines $ lst
17:25:51 <byorgey> joe6: what's the filter (not . null . head) for ?
17:25:57 <hpc> > words "        \t    "
17:25:58 <lambdabot>   []
17:26:16 <byorgey> > words ",foo"
17:26:17 <lambdabot>   [",foo"]
17:26:21 <joe6> to remove the blank words in the beginning of the sentence, I thought..
17:26:39 <byorgey> that will remove any lines which start with a blank word
17:26:48 <joe6> yes, i do not nee that.
17:27:08 <byorgey> I am not 100% sure but I don't think words ever generates any empty words.
17:27:19 <joe6>  http://sprunge.us/OBbH
17:27:27 <aavogt> this can probably replace the last two filters:
17:27:28 <byorgey> @check all (not . null) . words
17:27:29 <lambdabot>   "OK, passed 500 tests."
17:27:45 <joe6> byorgey: that is smart. thanks.
17:27:45 <aavogt>  catMaybes (\x -> do (_:_) : _ <- x; return x)
17:28:13 <joe6> @hoogle isHexWord
17:28:13 <lambdabot> No results found
17:28:20 <aavogt> @check length (> 2) . words
17:28:21 <lambdabot>   The section `GHC.Classes.> 2' takes one argument,
17:28:21 <lambdabot>  but its type `[a]' has n...
17:28:31 <aavogt> @check \x -> length (< 2) . words $ x
17:28:33 <lambdabot>   The section `GHC.Classes.< 2' takes one argument,
17:28:33 <lambdabot>  but its type `[a]' has n...
17:28:54 <aavogt> @check \x -> (< 2) . length . words $ x
17:28:55 <lambdabot>   "Falsifiable, after 271 tests:\n\"\\752266\\99831\\423123\\900303\\560607\\...
17:29:24 <aavogt> it takes that many to get one that splits into two words
17:29:51 <byorgey> heh
17:29:51 <Saizan> @src words
17:29:51 <lambdabot> words s = case dropWhile isSpace s of
17:29:51 <lambdabot>     "" -> []
17:29:52 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
17:29:52 <aavogt> so 500 tests is pretty poor for the default generator
17:30:05 <byorgey> aavogt: good point.  whitespace characters are relatively rare.
17:31:01 <Saizan> it's clear enough from the source though :)
17:31:40 <aavogt> how do people go about setting up old ghcs for testing their libraries?
17:32:03 <byorgey> aavogt: I use stow, it works pretty well
17:32:25 <aavogt> the ghc-6.8.2 binary x86_64 doesn't work because ld complains about a bad format
17:33:01 <byorgey> oh, you mean like that
17:33:33 <aavogt> errors like /usr/bin/ld: skipping incompatible /home/aavogt/wip/ghcs/ghc682/lib/ghc-6.8.2/lib/base-3.0.1.0/libHSbase-3.0.1.0.a
17:44:23 <gwern> lambdabot: @join #lesswrong
17:52:52 <kmc> hmm, is there a simple way to parallelize a backtracking search written using the list monad or similar?
17:54:09 <kmc> hmm, there are these packages 'tree-monad' and 'parallel-tree-search'; anyone used them?
17:54:35 <hpc> search (Tree left a right) = search left `par` search right `par` {compare 'a' and blah blah blah}
17:54:38 <hpc> perhaps this?
17:55:18 <kmc> probably needs some pseq, but yeah
17:55:52 <kmc> parSearch (Choice l r) = rs `par` (parSearch l ++ rs)
17:56:03 <kmc> that makes sense too
17:56:15 <kmc> "where rs = parsSearch r"
17:56:41 <hpc> in any event, i suspect you could just write your regular search, then pepper with par/pseq
17:56:57 <aavogt> is there some way to make larger pieces of work done at for each par (with less total par)
17:57:26 <aavogt> that seems to be a difficult point to get speedups
17:59:44 <hpc> i think as long as you pick pieces that don't depend on each other, you can get away with an almost stupidly large number of pars
18:00:02 <hpc> because they don't map to real threads until the runtime decides it would work out
18:00:14 <hpc> and i understand GHC's runtime is pretty good at that
18:18:31 <aavogt> is there a way to recover from   reify (mkName "not_actually_in_scope_sometimes")?
18:20:00 <aavogt> heh, it's called  recover
18:21:25 <scooty-puff> i believe the lazy StateT monad i'm using is killing my performance, but my use of MonadFix prohibits all strict monadic operations - is it possible to kind of switch between lazy and strict?
18:21:53 <scooty-puff> my only option i see is to define a monad that has two data constructors
18:22:05 <ezyang> What are you doing?
18:22:28 <scooty-puff> code generation, but the monad that i've defined is just a newtype of the lazy StateT
18:22:52 <scooty-puff> from profiling, i've pinpointed one of my methods - however, since there isn't much going on there, i'm not so sure
18:22:58 <scooty-puff> let me put up a link - its on github
18:23:45 <scooty-puff> https://github.com/sonyandy/jfuck/blob/master/Language/Brainfuck/Emitter.hs#L48
18:23:51 <scooty-puff> the line of the function is selected
18:23:52 <luite> it it possible to print a list of all exposed modules of the latest version of all installed packages?
18:26:12 <scooty-puff> http://hpaste.org/47605
18:26:20 <scooty-puff> thats the top of the .prof file
18:29:01 <dibblego> hi stuart
18:29:20 <stuart> Hello.
18:29:33 <dibblego> how is it going?
18:29:33 <scooty-puff> yo
18:29:46 <kmc> hpc, you still need to limit the amount of "par" somewhere
18:29:52 <stuart> I was having trouble getting cabal to connect to hackage.haskell.org
18:29:52 <kmc> dons's multicore programming in haskell talk has examples
18:30:03 <kmc> you want to par n levels or such
18:30:40 <kmc> iirc "par" is just a push onto a lockless queue
18:30:47 <kmc> pushing a single pointer
18:30:57 <kmc> but it's still bad to do that between every k instructions if k is small
18:32:07 <dibblego> stuart: still? it is working fine for me
18:32:54 <stuart> Yep. Still.
18:33:24 <stuart> is there a mirror I can try?
18:33:56 <dibblego> unfortunately no, can you connect to the webpage with a browser?
18:35:09 <stuart> no I cant get the web page.
18:35:16 * hackagebot json-builder 0.2.0 - Data structure agnostic JSON serialization  http://hackage.haskell.org/package/json-builder-0.2.0 (LeonSmith)
18:36:10 <dibblego> strange, because I just did cabal update fine
18:36:29 <tgeeky> is LeonSmith here?
18:36:46 <stuart> I'll continue to check my network settings here, just in case.
18:38:13 <scooty-puff> is 40% gc time acceptable - this is a short running program, and am worried about how it might scale
18:40:32 <tgeeky> lpsmith: does [invertible-syntax] and [partial-isomorphisms] seem interesting to you re: json-builder?
18:41:46 <lpsmith> tgeeky:  I haven't looked at them,  but maybe
18:42:27 <tgeeky> lpsmith: it sounds (from my relatively ignorant point of view) like exactly what you want
18:42:43 <kmc> scooty-puff, only you can prevent forest fires^W^W^W answer that question
18:42:56 <kmc> but you can usually decrease the GC time by increasing the allocation area size
18:42:58 <kmc> ./foo +RTS -A400M
18:43:04 <kmc> or otherwise screwing with RTS flags
18:43:08 <kmc> dons had a thing to tune them automatically
18:43:34 <tgeeky> lpsmith: which is someting like avoiding the inner component of: [printer] -> [serialzer] ... [deserializer] -> [parser]
18:43:42 <tgeeky> and using [printer] <-> [parser]
18:44:04 <lpsmith> tgeeky: 0.1.1 and 0.2 is a fair bit faster than the previous versions;  I still need to do more benchmarks but performance seems so far to be right in line with Aeson.
18:44:37 <tgeeky> lpsmith: the paper for those can be found here: http://www.informatik.uni-marburg.de/~rendel/unparse/rendel10invertible.pdf
18:45:18 <tgeeky> lpsmith: I can provide some very large JSON data (real world) for you to parse?
18:45:57 <lpsmith> tgeeky: yeah, that might be helpful at some point
18:46:07 <lpsmith> However I don't do parsing yet.  :)
18:46:13 <lpsmith> Only serialization
18:46:15 <tgeeky> lpsmith: yeah, read that paper I linked
18:46:29 <tgeeky> lpsmith: I'd like to hear your opinion about the applicability
18:47:59 <tgeeky> lpsmith: http://www.pnathan.com/elements.json
18:48:21 <tgeeky> lpsmith: that's not mine, but if that's not big enough for benchmarking purposes (or complicated enough) I will generate one with isotopes instead
18:49:52 <lpsmith> tgeeky: I'll take a look,  but I'm guessing that they are complimentary tasks.   I know that that unifying parsing and pretty printing has gotten a fair bit of attention.   There was one (I can't quite find it at the moment) that was in /r/haskell a week or so ago that went through Aeson,  and it would probably benefit to moving to my library for serialization.
18:50:26 <tgeeky> lpsmith: well I clearly don't understand something, since I thought the point of your library was to avoid serialization :o
18:50:40 <kmc> "I also switched to using the highlighter package because that’s BSD3 and therefore I can make the whole Amelie project BSD3."
18:50:40 <lpsmith> tgeeky: it's to avoid marshalling
18:50:43 <kmc> that's... not how it works
18:51:00 <tgeeky> kmc: in his head... in his head...
18:51:03 <kmc> it is totally fine for BSD-licensed projects to depend on GPL-licensed components
18:51:32 <kmc> chrisdone, ^^^^
18:51:39 <lpsmith> and to avoid marshalling as a _computational task_.
18:51:44 <kmc> but, maybe you're following a personal rule rather than a legal one
18:52:50 <tgeeky> lpsmith: if I understand correctl, that is to store JSON structure as Haskell structure in memory directly?
18:53:05 <tgeeky> lpsmith: and be certain you can dump it to JSON?
18:53:16 <lpsmith> tgeeky:  the point of those packages is to avoid writing code,  the point of my package is to avoid tying up CPU cycles  :)
18:53:45 <tgeeky> lpsmith: can't we have both? *bats eyes mindlessly* ;O
18:54:00 <lpsmith> tgeeky: of course :)
18:54:33 <lpsmith> that's why they are probably complimentary approaches
18:55:08 <tgeeky> lpsmith: so you can build arbitrarily complex JSON stuff in memory, and cheaply serialize it, but can't reconstruct it from the serialized version?
18:55:39 <lpsmith> tgeeky: http://hackage.haskell.org/packages/archive/aeson/0.3.2.7/doc/html/Data-Aeson.html#t:Value
18:56:05 <lpsmith> if you use aeson,  you have to first convert your data structure into that data structure.
18:57:09 <tgeeky> lpsmith: if I use yours, I... don't?
18:57:16 <lpsmith> If you use json-builder,  you will be able to go directly from your data structure to a string,  bypassing Aeson.Value.
18:57:20 <lpsmith> Yes, exactly
18:57:35 <tgeeky> but once I have the string, send it to something which flips a bit
18:57:41 <tgeeky> I have to use Aeson to get it back?
18:57:45 <lpsmith> yeah
18:57:50 <lpsmith> At the moment :)
18:57:59 <tgeeky> so what you're doing is neither serialization nor marshalling
18:58:03 <tgeeky> but just JSON-Storage ish?
18:58:07 <tgeeky> (at the moment)
18:58:18 <tgeeky> JSON-EfficientInMemoryRepresentationShinyBits
18:59:18 <kmc> too many sons
18:59:31 <photex> Hello, first time here, new haskeller
18:59:36 <kmc> hi photex!
18:59:38 <kmc> welcome
18:59:39 <photex> sadly stuck on Cent5.5
18:59:46 <cmccann> kmc, obviously needs some daughters instead?
18:59:50 <SpiceMan> install a VM :p
18:59:51 <photex> having a hard time getting settled haha
19:00:08 <kmc> photex, better than RHEL4
19:00:19 <photex> something that might be handy... no idea if it's already possible, can I specify versions with cabal
19:00:22 <lpsmith> tgeeky: well,  CS vocabulary isn't standard.   What I mean (and what many other people mean) by "serialization" is turning a data structure into a sequence of bits that can be stored in a file or sent over a network or whatever.
19:00:29 <tgeeky> lpsmith: well I'm going to be working with pretty huge datasets (from Mathematica: ParticleData (1108 members), ElementData (118), IsotopeData (2800), ChemicalData (56000), AstronomicalData (170000))
19:00:30 <photex> so, if I want to try something
19:00:36 <photex> and it needs a newer 'text'
19:00:43 <tgeeky> lpsmith: so I will be a prime candidate for testing of whatever :)
19:00:50 <photex> I can try an older version that will work with my 6.12.3 install
19:01:00 <lpsmith> tgeeky: I'd appreciate feedback
19:01:02 <lpsmith> :)
19:01:03 <photex> kmc indeed
19:01:17 <tgeeky> lpsmith: the partial-iso thing is very neat, I really encourage you to check it out)
19:01:28 <byorgey> photex: you can specify versions with cabal.  you can just say  cabal install somepackage-3.2.6
19:01:28 <kmc> cabal install text-1.2.3.4
19:01:36 <photex> HA!
19:01:42 <photex> easier than it should be
19:01:43 <photex> lol
19:01:49 <tgeeky> lpsmith: it's rather simple, and you can specify partial-isomorphisms piecewise, so you can test it on small parts of your data structure without writing the entire syntax
19:01:52 <kmc> you can also try to run a newer userspace in a chroot
19:02:01 <kmc> which may be easier to set up than a VM (or harder)
19:02:02 <photex> I can't get it to build
19:02:21 <photex> I've been trying desperately to use 6.12.3 to get the latest release
19:02:34 <photex> even going as far to create a node on rackspace cloud
19:02:45 <photex> to try and build a package on a vanilla system
19:02:50 <photex> that I could hopefully use at work
19:02:51 <photex> hah
19:02:58 <kmc> what happens if you just get the haskell platform binaries
19:03:09 <photex> libc mismatch
19:03:11 <photex> glibc
19:03:13 <tgeeky> lpsmith: forked.
19:03:25 <byorgey> photex: oh, boo =(
19:03:29 <photex> yar
19:03:47 <photex> basically... I'm trying to convince work, that we could get some haskell love going
19:03:48 <photex> haha
19:03:59 <photex> but I think it'll take a while
19:04:08 <photex> probably if we ever update to Cent6 or something
19:05:28 <lpsmith> tgeeky.   Thanks.   As I was saying,  I saw a isomorphism library that used Aeson on /r/haskell a short while ago,  and it would probably benefit from json-builder.
19:05:51 <lpsmith> tgeeky  I don't think that isomorphisms should be part of json-builder,  but if somebody wants to use json-builder in their library,  then that would be awesome
19:06:08 <tgeeky> lpsmith: hehe :) hint hint
19:06:33 <tgeeky> lpsmith: as a project, I am taking over (and documenting, previously undocumented) the mpppc package
19:07:02 <tgeeky> lpsmith: I was looking for an complicated use-case example to show off that library, and I settled on drawing Periodic Table data
19:08:21 <tgeeky> lpsmith: are you referring to the post about putJSON and getJSON being the same... or something like that? I think I might have seen it, but I don't know what library it was
19:11:56 <photex> ok another probably very simple question
19:12:11 <photex> is there something akin to erlangs release tool for haskell?
19:12:21 <deco> is haskell okay  for web dev ?
19:12:21 <photex> or the leiningen uberjar for clojure?
19:12:51 <photex> or perhaps another way of asking, what is the idiomatic strategy for deploying to a node?
19:13:34 <rothwell> "deploy, find space leak, hastily un-deploy"
19:13:44 * rothwell ducks rotten vegetables
19:13:48 <photex> he
19:13:49 <photex> h
19:14:13 <photex> I guess I'm curious what 'deploy = ' in that scenario
19:15:31 <parcs> deco: i'd say it's 'okay'
19:16:38 <aavogt> is quickcheck-1 still preferable in some way?
19:17:56 <lpsmith> tgeeky: well, not just that putJSON and getJSON being the same,  but that you only have to write one description of the mapping.
19:19:01 <tgeeky> lpsmith: yeah, what was that? remember the name? Reddit's search is about as useful as a wooden nickel
19:19:35 <lpsmith> tgeeky: but as an example of how easy it is to write a "custom" putJSON,  if you have a value of type :: [(String, Integer)],  all you have to do to convert that to a json object syntax is "mconcat . map (uncurry row)"
19:19:37 <kmc> photex, GHC makes statically linked binaries by default
19:19:49 <photex> !
19:19:50 <photex> again
19:19:53 <photex> rather nice
19:20:03 <kmc> it is and it isn't
19:20:13 <lpsmith> tgeeky: I'm still looking for it
19:20:16 <kmc> i should say: the Haskell code is statically linked, but platform C libraries aren't
19:20:20 <photex> it's compatible with how we build software at work at least :)
19:20:42 <photex> and we have a lot of machines with the same os image on it
19:22:57 * isomorphic wishes whoever thought of the library concept had just skipped to disk deduplication
19:23:07 <lpsmith> tgeeky: here it is,  I finally found it by looking through HWN:  http://martijn.van.steenbergen.nl/journal/2011/05/08/introducing-jsongrammar/
19:23:31 <lpsmith> that was longer ago than I first thought :-o
19:23:36 <deco> thanks parcs
19:24:49 <kmc> linux has same-page merging now
19:25:13 <kmc> memory pages which are not a priori known to be shared can become shared if they are discovered to have identical content
19:25:14 <isomorphic> kmc: ie: memory dedup?
19:25:39 <photex> well thanks for the help! One last question is whether the ghc and platform packages are being built by a CI system or something.
19:25:40 <isomorphic> yup - and yet you see the pain libraries cause ;)
19:25:46 <lpsmith> Martijn also mentioned the work you pointed me towards :)
19:26:05 <kmc> GHC has a buildbot
19:26:08 <kmc> i don't know about the platform as a whole
19:26:17 <photex> if I can contribute a rackspace node sometime etc I'd be happy to chip in
19:26:19 <ezyang> Fascinating! An inference rule from => A to => [] A does not imply A -> [] A
19:26:31 <kmc> ezyang, modal logic?
19:26:35 <ezyang> yeah.
19:26:44 <photex> if there is a certain distro you'd like to test on etc
19:26:44 <tgeeky> lpsmith: ok I'll check it out
19:26:52 <tgeeky> lpsmith: and see what I can do
19:27:36 <kmc> photex, you can ask in #ghc as well
19:27:41 <photex> ah cool
19:27:45 <photex> cheers!
19:28:50 <kmc> ezyang, why not?
19:30:04 <ezyang> Well, if you look at the sequent calculus rules for a modal logic (say S4), you'll find you can't actually derive A => [] A
19:30:59 <ezyang> and a system that does allow that would be unsound.
19:31:02 <ezyang> It's very strange.
19:31:36 <dolio> Is it?
19:32:06 <ezyang> To me, at least.
19:32:14 <tgeeky> lpsmith: and Tillmann is the guy who wrote partial-iso. Interesting comments, too. Thanks for finding the link!
19:32:29 <luite> what's the easiest way to do String -> Rational for numeric literals like "0.123" (no exponents and stuff)?
19:33:02 <ezyang> I have some sort of survey paper which tries to explain why this is the case, but I think it's just slightly over my head. Maybe another few hours and I'll understand.
19:33:41 <dolio> []A is meant to be that A holds in "all possible worlds".
19:33:55 <dolio> If you can derive A in the empty context, then you must be able to derive it anywhere.
19:34:05 <kmc> > read "0.123" :: Rational
19:34:06 <lambdabot>   *Exception: Prelude.read: no parse
19:34:11 <kmc> grr
19:34:25 <dolio> But being able to derive A under the assumption of A doesn't say anything about whether you can derive it under other sets of assumptions, for instance.
19:34:39 <ivanm> kmc: read as Double then convert?
19:34:39 <luite> kmc: yes if that was possible I wouldn't have asked this :)
19:34:50 <kmc> just checking
19:35:08 <luite> ivanm: that's lossy
19:35:27 <ezyang> Hmm?
19:35:30 <ivanm> luthen probably a fold over the digits
19:35:33 <ivanm> @hoogle digits
19:35:34 <lambdabot> Prelude floatDigits :: RealFloat a => a -> Int
19:35:34 <lambdabot> Numeric floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)
19:35:34 <lambdabot> Numeric lexDigits :: ReadS String
19:35:47 <ivanm> luite: I think there's a digits library on hackage...
19:36:27 <luite> hm that's for integers
19:37:10 <ivanm> or else adapt what polyparse has as the sample way of parsing floating point numbers?
19:41:24 <dolio> ezyang: The weirder rule is the one I've seen for possibility.
19:41:40 <dolio> Which is: G => A  to G => <>A
19:41:44 <ezyang> ah, the left <> elimination rule? Yeah, very strange.
19:41:49 <dolio> Which seams weak.
19:41:56 <ezyang> oh, no, not that one.
19:42:15 <ezyang> well, you can preserve arbitrary other terms on the right side too
19:42:50 <dolio> Well, this was a more intuitionistic characterization of modal logic, I think.
19:43:08 <ezyang> oh I see.
19:43:33 <dolio> On the other hand, if it were G => A  to G' => <>A, then you could derive <>A for all A.
19:43:38 <dolio> Because false proves everything.
19:44:11 <luite> ivanm: guess I'll just use a parser lib then, had expected that there would be something simpler and more ready made :)
19:44:34 <ivanm> luite: you could probably do without a parsing library and just use Strings by hand if you want
19:44:50 <dolio> Presumably there isn't a possible world in which false holds.
19:45:34 <dolio> The thing I was reading wasn't sequent calculus, either, I think. It was Martin-loef style natural deduction.
19:47:08 <joe6> need some help with this: my input is:  http://sprunge.us/GeCF and I am trying to get the 3 lines after matching the line with this: *Main Text.Printf Data.List.Split> filter (isPrefixOf "000008") . lines $ lst
19:47:12 <joe6> ["000008   ed93     call\t0x126, 0x1             ;  to process the spi input/output"]
19:47:15 <joe6> it :: [[Char]]
19:47:22 <joe6>  http://sprunge.us/ZbbL
19:47:29 <joe6> sorry, did not mean to paste the code
19:47:36 <joe6> just a wrong click
19:47:54 <joe6> need some help with this: my input is:  http://sprunge.us/GeCF and I am trying to get the 3 lines after matching the line with this: http://sprunge.us/ZbbL
19:59:49 <mxc> hi
20:00:01 <mxc> something thats been bothering me for a while
20:00:28 <mxc> if h ave some functions f1, f2 ::  a -> IO (Maybe a) is there a clean way to bind them togehter?
20:00:35 <mxc> like f1 >>= f2  etc..
20:00:50 <kmc> maybe you want MaybeT IO ?
20:00:56 <mxc> i knwo a simple bind wont work, but I feel like i'm missing something the wya i'm doing it
20:01:55 <mxc> maybeT wont work, I over simplified a bit
20:02:05 <kmc> :t MaybeT
20:02:06 <lambdabot> Not in scope: data constructor `MaybeT'
20:02:16 <mxc> my types are more like f1 :: MonadIO m => a -> m (Maybe a)
20:02:56 <aavogt> what happened when you tried to use MaybeT?
20:03:38 <mxc> i didn't
20:03:51 <mxc> yet
20:03:53 <aavogt> it can be made to work
20:04:08 <mxc> i dont have control of the functions
20:04:25 <Nereid> if you can make IO `o` Maybe into a monad
20:04:28 <Nereid> then it ought to work
20:04:45 <kmc> :t (>>= maybe (return Nothing) ?f)
20:04:45 <lambdabot> forall a (m :: * -> *) a1. (Monad m, ?f::a1 -> m (Maybe a)) => m (Maybe a1) -> m (Maybe a)
20:05:00 <Nereid> but then
20:05:07 <Nereid> how would you deal with values that are in IO but not Maybe
20:05:39 <Nereid> well, you still could, sure.
20:05:45 <aavogt> lift :: IO a -> MaybeT IO a
20:05:47 <Nereid> you just can't use both monads for the same do block of course.
20:09:58 <mxc> i think kmc got it
20:10:47 <mxc> strange
20:10:50 <mxc> *S4M.Server.DataModel.PersistentTH Control.Monad> :t \f ->  (>>= maybe (return Nothing ) f)
20:10:50 <mxc> \f ->  (>>= maybe (return Nothing ) f)
20:10:50 <mxc>   :: Monad m => (a -> m (Maybe a1)) -> m (Maybe a) -> m (Maybe a1)
20:10:51 <mxc> *S4M.Server.DataModel.PersistentTH Control.Monad> let bnd f =  (>>= maybe (return Nothing ) f)
20:10:51 <mxc> <interactive>:1:26:
20:10:51 <mxc>     Ambiguous type variable `m0' in the constraint:
20:10:51 <mxc>       (Monad m0) arising from a use of `return'
20:11:16 <djahandarie> fyi, use http://hpaste.org for such large pastes in the future
20:11:26 <mxc> i thought 10 lines was the limit
20:11:56 <aavogt> mxc:  perhaps if you use -XNoMonoLocalBinds
20:12:16 <mxc> aavogt - thanks!
20:12:50 <djahandarie> mxc, I usually use an external paste site if it's over 2-3 lines
20:12:59 <mxc> noted
20:13:09 <kmc> MonoLocalBinds eh
20:13:18 <kmc> i thought that was only turned on if you used other extensions
20:13:25 <kmc> (or explicitly)
20:16:16 <monochrom> GADTs turns on MonoLocalBinds but can be overriden
20:16:44 <ivanm> is it possible to define something in one module and re-export it from another with different haddock documentation?
20:17:10 <monochrom> I don't think so
20:17:34 <ivanm> I suppose I could do so by importing the original module qualified and then creating an alias with the same name and different documentation... but it seems rather hacky :s
21:25:40 <byorgey> suppose (hypothetically) I wanted to write a user manual. That is, a document with chapters, sections, subsections, etc.
21:25:59 <djahandarie> Don't do it, no one reads those things.
21:26:21 <byorgey> I want to be able to write it using some standard markup format and easily generate html.  Being able to programmatically munge it in between would be useful too.
21:26:24 <byorgey> hehe =)
21:26:33 <c_wraith> I dunno.  I'd appreciate a manual explain users to me.
21:26:35 <byorgey> anyone have any recommended tools/toolchains for accomplishing this?
21:26:49 <djahandarie> pandoc?
21:27:01 <byorgey> c_wraith: ah, you want a user user manual
21:27:24 <kmc> pandoc is a good tool (and it has a user manual ;D)
21:27:28 <c_wraith> dunno.  Car manual, tv manual, user manual.
21:27:30 <kmc> i like the markdown format but it supports others
21:27:34 <c_wraith> the pattern seems clear
21:27:38 <kmc> haha c_wraith
21:27:57 <pikhq> My usual recommendation for typesetting any form of writing is LaTeX, but I'm not entirely sure how easy it is to generate sane HTML out of that.
21:28:26 <kmc> there are TeX → HTML converters but the output is usually pretty ugly
21:28:26 <byorgey> pandoc is a great tool but I need something a bit higher-level that can manage generating multiple cross-linked html files
21:28:34 <byorgey> this is going to be way too big to fit on a single page.
21:28:35 <kmc> Docbook?
21:28:40 <kmc> whatever-they-used-for-SICP?
21:29:30 <byorgey> ah, it looks like this is exactly what docbook is for =)
21:29:36 <byorgey> I will check it out
21:30:06 <byorgey> oh, ugh, it's xml =P
21:31:01 <byorgey> hmm, looks like pandoc can generate docbook
21:32:01 <aavogt> that's interesting, haddock says my  newtype Proxy a = Proxy (Proxy a)   is actually a  data Proxy a
21:39:08 <ivanm> what would people say are the most important Graphviz attributes? labels, shapes, styles and arrows ?
21:45:45 <kmc> byorgey, XML is a terrible concrete grammar but it's an okay data model
21:45:53 <kmc> so maybe you can write in something more palatable and translate to XML
21:46:01 <kmc> pandoc being one way to accomplish this
21:46:03 <byorgey> kmc: right
21:46:21 <byorgey> I'm going to try just writing in markdown and using pandoc to convert to docbook
21:46:44 <roconnor> @src zipWith
21:46:44 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
21:46:44 <lambdabot> zipWith _ _      _      = []
21:47:26 <byorgey> the only problem is that I want to make it literate Haskell, and you can only have two heading levels with markdown+lhs in pandoc =(
21:48:03 <kenjin2201> ..
21:51:25 <ivanm> byorgey: yeah
21:51:42 <ivanm> unless you use some kind of pre-processor to remove the markdown from the file before loading it in ghc/ghci
21:52:00 <ivanm> (which I've thought about doing)
21:52:17 <byorgey> would it be enough to just remove lines beginning with # ?
21:53:04 <ivanm> yes
21:53:13 <ivanm> assuming you dont' use bird-tracks for block quotes
21:53:32 <ivanm> and you have blank lines before/after the ~~~ (when using bird-tracks for LHS)
21:53:50 <byorgey> yeah
21:54:04 <byorgey> I'm OK with not having block quotes
21:54:18 <ivanm> byorgey: you can still have block qutoes, just use indentation rather than > to denote them
21:54:40 <EvilMachine> yeah! i think i finally "got" monads. the solution was, that they are *easier/simpler* than i assumed.
21:54:56 <byorgey> ivanm: doesn't that make a code block rather than a blockquote?
21:55:05 <luite> EvilMachine: no go write a tutorial ;)
21:55:07 <EvilMachine> i have one question i hope someone can verify:
21:55:19 <EvilMachine> luite: lol. yet another one?
21:55:39 <acowley> Well that's one way of solving bugs that only appear in release builds of someone else's code: use an older version.
21:56:15 <ivanm> byorgey: ummm, code blocks use ~~~ ... ~~~ to denote them...
21:56:36 <ivanm> acowley: oh? what problem is this?
21:56:41 <ivanm> kenjin2201: did you actually have a question?
21:56:42 <EvilMachine> luite: what analogy should i take? fat people who are so fat that they twist space and time? monkeys on drugs bashing about? so hard to choose. ;)
21:56:44 <acowley> EvilMachine: I wrote some Template Haskell the other day to deal with your crazy love of do notation
21:57:16 <EvilMachine> acowley: lool. should i feel bad? because i do.
21:57:25 <byorgey> ivanm: I mean if you indent with four spaces you get a preformatted block, i.e. surrounded by <pre> </pre>
21:57:25 <EvilMachine> ivanm: hello btw. :)
21:57:41 <acowley> ivanm: I get a segfault deep within the latest SVN of OpenCV 2.2 on Linux. It goes away when debug info is left in the libraries
21:57:54 <ivanm> byorgey: huh... I thought it was still a block quote
21:57:57 <acowley> ivanm: but I can link against OpenCV 2.1 which is in Ubuntu's repositories
21:58:24 <EvilMachine> ok, one thing i think i realized: monads are crazy useful for what they call "aspect-oriented programming" but in a more generic, broader way. correct?
21:58:25 <ivanm> acowley: oh, you're still using HEAD of a library rather than even a semi-stable tarball?
21:58:29 <acowley> EvilMachine: Actually it was something that I thought should be easy and it had been rankling me that I didn't know the magic incantation
21:58:32 <luite> EvilMachine: do something with quantum mechanics, where observing something changes the system, states become entangled. you can only put other things in entanglement but gan't get anything out
21:58:37 <ivanm> EvilMachine: depends: wtf is "aspect-oriented programming" ?
21:58:53 <acowley> ivanm: Peaker tried the stable release with patches to make it work on Ubuntu 11.04 and got the same segfault
21:58:56 <EvilMachine> acowley: you must be new to Haskell. ;)
21:59:06 <ivanm> EvilMachine: he isn't...
21:59:09 <EvilMachine> acowley: i thought that was usually the case.
21:59:14 <ivanm> and I don't think he's referring to a Haskell library...
21:59:15 <acowley> ivanm: so I just went ahead and used SVN because the necessary patches were already there
21:59:16 <EvilMachine> ivanm: i know. it's a meme. :)
21:59:27 <luite> EvilMachine: it's probably a bad analogy and I haven't thought about it properly, but that's perfect for monad tutorials :p
21:59:27 <ivanm> is it? I've never heard it here before...
21:59:48 <EvilMachine> ivanm: ok, a Slashdot meme. "You must be new here."
22:00:28 <EvilMachine> ivanm: well, aspect-oriented is about as nice as modular programming.
22:01:02 <EvilMachine> ivanm: the idea is that you modularize your program not only in the classic way, but can also split it by aspect
22:01:04 <acowley> EvilMachine: you'll like the TH version of the code http://hpaste.org/47608
22:01:26 <EvilMachine> ivanm: one aspect would be error management. or logging. or some checking. or network transparency.
22:01:50 <ivanm> I fail to see what that has to do with Monads
22:01:51 <EvilMachine> ivanm: which, as might be obvious, made me think: soo.... like monads, but limited? :)
22:02:12 <ivanm> unless you use some kind of class-based abstraction to use IO for pproduction and a simpler monad for testing
22:02:29 <acowley> I think of aspect oriented programming as more like straight function composition with perhaps a reader applicative
22:02:32 <luite> byorgey: if you find a solution for pandoc markdown and lhs, please tell me. and write a parser for the format in javascript ;)
22:02:54 <acowley> I like pandoc markdown and lhs. What's the problem with it?
22:02:56 <EvilMachine> ivanm: well, think of how you could use monads, do "add a hook" to the beginning and end of every function. transparent to the outside code.
22:03:26 <ivanm> EvilMachine: that sounds horrible
22:03:36 <ivanm> acowley: limited headers mainly
22:03:42 <ivanm> i.e. can't start lines with "#"
22:03:51 <EvilMachine> ivanm: you failed to say why :)
22:03:58 <byorgey> EvilMachine: monad transformers can be used in that way.  In the FP community this is often called "mixins"
22:04:12 <EvilMachine> byorgey: exactly
22:04:18 <EvilMachine> byorgey: that's what i meant
22:04:24 <ivanm> EvilMachine: OK, lemme be more specific: it doesn't sound like something you would use monads for specifically
22:04:32 <byorgey> although there are currently some problems preventing this sort of style from widespread practical use
22:04:40 <acowley> why do you need more than two levels of headers though? that seems like a style smell
22:05:00 <EvilMachine> ivanm: well, "doesn't sound like" itself doesn't sound like a particularly convincing argument. ;)
22:06:00 <byorgey> acowley: maybe I don't. I don't know. I'm writing a user manual for diagrams and I expect it will not be short.
22:06:45 <acowley> Ah. Use an image with a diagrammatic logo for the title on the cover page, then two levels of headings for chapters and sections could be enough :)
22:07:26 <EvilMachine> byorgey: make it in diagram form then. :)
22:07:27 <byorgey> I... what?
22:08:01 <acowley> no more fonts, just diagrams
22:08:18 <luite> acowley: for longer documents, more than 2 levels can be appropriate
22:08:27 <acowley> let your inner knuth out
22:08:32 <EvilMachine> lol
22:09:25 <acowley> luite: I agree, but I don't think it's essential.
22:10:05 <acowley> Maybe bold italics can be used for subsection headings. And if you're going to HTML you could marquee some headings. People dig that.
22:10:09 <luite> acowley: but it's not only that, I like the ### style headings better than the underline style, less typing
22:10:33 <EvilMachine> hmm... why not make levels infinite? like in HTML5.
22:10:57 <acowley> Yeah, the underlines are awkward in ASCII. The trick is to spend more time writing tweets, then writing articles in markdown feels luxurious.
22:11:07 <EvilMachine> lol
22:12:17 <EvilMachine> acowley: tweets? there are 40-50 year old men in mid-life crisis and marketing agencies for famous people here? (those are the only ones using twitter. that's a fact. ^^)
22:12:54 <acowley> btw, is it idiomatic TH to leave fields of a QuasiQuoter undefined? All I needed was quoteExp.
22:13:13 <arcatan> EvilMachine: apparently there a quite many of those here!
22:13:26 * EvilMachine has a sad. :(
22:13:39 <acowley> EvilMachine: if you'd just buy more Lady Gaga merch I could buy my sports car :(
22:14:16 <ivanm> dammit, the more complex documentation is leaking through into my user-friendly module :@
22:14:53 <EvilMachine> acowley: I want to say that if you continue, i will have to gouge my eyes out. But i will say that we should get back on topic. ^^
22:15:34 <ivanm> I was going to try using alias for some of the types and giving them new documentation, but that would require re-defining some values just to give them the new type :@
22:16:01 <EvilMachine> ivanm: seems the [complex -> user-friendly] interface needs redefinition
22:16:20 <acowley> ivanm: it's worth the trouble
22:16:41 <acowley> ivanm: type aliases with good names and helpful documentation are way more useful than stacks of parameterized foobars.
22:16:43 <EvilMachine> ivanm: just by the way: what are you documenting?
22:16:50 <ivanm> acowley: except that it breaks the point of "you can mix-and-match this with the complex version if you need some of them"
22:17:10 <ivanm> EvilMachine: a more user-friendly version of Data.GraphViz.Attributes from my graphviz package
22:17:11 <EvilMachine> acowley: i agree. meaningfulness is always good for the mind.
22:17:21 <acowley> ivanm: ah. This came up cafe today or yesterday, didn't it?
22:17:23 <EvilMachine> ivanm: ah. thx
22:17:31 <ivanm> acowley: I talked about it here yesterday...
22:17:48 <acowley> ivanm: the idea of having a friendly module export specialized versions of internal functions
22:17:55 <EvilMachine> ivanm: i just hope that means more efficient. not just simpler. :)
22:18:04 <ivanm> huh, I'll re-check cafe then
22:18:13 <ivanm> EvilMachine: ummm... "more efficient" on the programmer
22:18:25 <acowley> ivanm: I basically summarized the thread there, there wasn't much insight
22:18:28 <ivanm> it's just alias with better names for a bunch of existing values
22:18:33 <ivanm> acowley: heh
22:18:43 <djahandarie> I'm not a huge fan of type aliases. I'll use it if there's some really crazy type I need to clean up, but I weigh a adding type alias the same as adding a new data type, because the end user really doesn't know until reading the docs
22:19:21 <ivanm> djahandarie: well, for me it's doing "type Style = StyleItem" as I'm not exporting the constructors for StyleItem here, so the default documentation for them doesn't make any sense
22:19:29 <ivanm> that works
22:19:35 <EvilMachine> ivanm: :) i knew you weren't the type who follows the dumbing-down spiral to MS Bob world. :)
22:19:44 <acowley> djahandarie: I dunno, things like IntMap Float really benefit from some custom naming
22:20:14 <ivanm> the problem comes about with the pre-defined arrows: they already have type ArrowType (which has a comment about the grammar, etc. that upstream uses) which in the simplified module aren't necessary
22:20:17 <acowley> djahandarie: also variants of State and Reader
22:20:24 <djahandarie> acowley, internally maybe, but I don't think I'd do that for a library.
22:20:51 <djahandarie> Variants of State and Reader? I usually type alias transformer stacks but I don't think I'd do it for a State or Reader
22:21:03 <ivanm> here's the module as it currently stands: http://hpaste.org/47609
22:21:05 <EvilMachine> djahandarie: i noticed that there are two kinds of minds. mathematician minds seem to look for structure, and therefore dislike names. and the rest (like me) has trouble with structure without attached meaning in form of names
22:21:22 <EvilMachine> djahandarie: so it depends on the person
22:21:24 <acowley> djahandarie: so you don't like things like Parser?
22:21:33 <acowley> djahandarie: I think those names are greatly helpful
22:21:42 <ivanm> wow... wtf happened to the indentation on hpaste? :/
22:21:49 <ivanm> preflex: seen chrisdone
22:21:49 <preflex>  chrisdone was last seen on #haskell 4 hours, 57 minutes and 26 seconds ago, saying: * chrisdone disappears in a puff of smoke
22:21:57 <EvilMachine> acowley: if he's more of a structural thinker, it might actually hinder him.
22:22:00 <acowley> ivanm: after you past, it gets better
22:22:05 <djahandarie> Jesus christ there is some crazy thunder going on outside of my house
22:22:09 <ivanm> chrisdone: oi! get your patch of smoke back here! :p
22:22:19 <acowley> well I see the downside in hiding the familiar structure, and I agree it's a problem
22:22:20 <ivanm> acowley: after I past what?
22:22:48 <djahandarie> EvilMachine, I don't think any mathematician would dislike good names if they don't obscure the structure
22:22:48 <ivanm> I'm just trying to have more user-friendly terms and removal of boilerplate when defining attributes, that's all!
22:23:03 <djahandarie> In fact mathematicians often abscure structure with crazy names so that's probably a nonexample anyways :p
22:23:04 <acowley> ivanm: when I made an hpaste just now, when I pasted my code in the textbox the indentation was messed up, but after I submitted the final paste looked fine
22:23:07 <djahandarie> obscure*
22:23:16 <ivanm> acowley: it doesn't look right here: http://hpaste.org/47609
22:23:30 <acowley> mathematicians loaded the haskell terminology cannon
22:23:44 <EvilMachine> acowley: hmm, maybe. the argument i'm coming from, is that they look for the most general patterns, and therefore specific names would only limit that.
22:23:47 * hackagebot egison 0.1.2.4 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-0.1.2.4 (SatoshiEgi)
22:23:48 <EvilMachine> oops
22:23:53 <ivanm> @tell chrisdone hpaste seems to mess up the indentation of module export lists, specifically after a line with a comment: e.g. http://hpaste.org/47609
22:23:54 <lambdabot> Consider it noted.
22:23:56 <EvilMachine> djahandarie: hmm, maybe. the argument i'm coming from, is that they look for the most general patterns, and therefore specific names would only limit that.
22:24:04 <acowley> djahandarie: write some elisp to get tooltips for types so we can see through friendly names
22:24:20 <djahandarie> acowley, that would be neat
22:24:34 <acowley> ivanm: well, yes, that looks troubled
22:25:03 <EvilMachine> djahandarie: acowley i agree. that sounds good
22:25:06 <acowley> that's something that VisualStudio really does a great job with, and type aliases are probably where I miss it the most
22:25:11 <EvilMachine> acowley: but can i also have the opposite? :)
22:25:26 <djahandarie> EvilMachine, my main issue is that a type alias requires me to look up something I wouldn't need to beforehand. And not only that, but it changes the type from 'something I understand' to 'something that could either be a type alias, or some insanely complicated data type'.
22:25:33 <acowley> you want the editor to make up a friendly name for a parameterized foobar?
22:25:52 <acowley> djahandarie: that's not far from working with an abstraction, though
22:26:04 <acowley> djahandarie: peeking at the representation isn't always helpful
22:26:13 <djahandarie> Sure
22:26:22 <djahandarie> But a type alias does nothing to change the interface
22:26:35 <djahandarie> It isn't an abstraction. You are directly working with the 'representation'
22:26:36 <acowley> It changes the type level interface
22:26:40 <EvilMachine> acowley: i fall apart if i only see things like ((.)$(.))
22:27:02 <EvilMachine> djahandarie: good point
22:27:38 <acowley> djahandarie: so, let's say I know I'm working with a WeightDictionary, and I have functions for looking up the weights of things. That it's an IntMap underneath should be irrelevant. I see type aliases as a lazy (possibly harmfully lazy) way of suggesting that level of abstraction.
22:27:45 <EvilMachine> djahandarie: you know ,my motto: no compromises. especially when we can have both: let's have type aliases and what's behind them *at the same time*
22:28:00 <EvilMachine> djahandarie: then i don't fall apart, and you can see what's behind it
22:28:09 <acowley> djahandarie: in my own code I sometimes alias the few functions over the underlying representation that I want to use with the mindset that I might some day want to seal the abstraction
22:28:25 <EvilMachine> acowley: yep, i want the editor to make up friendly names! :D
22:28:35 <djahandarie> acowley, I normally just newtype in that case.
22:28:51 <acowley> EvilMachine: do you find "gensym645" friendly? We could probably do that.
22:28:53 <EvilMachine> acowley: in other words: explain the complex type to me, if i don't get it
22:29:00 <EvilMachine> acowley: lol. nope
22:29:20 <acowley> djahandarie: yeah, and that's the right thing to do, but is using a type alias in that situation really bad?
22:29:50 <EvilMachine> acowley: nice, the idea of making sets of aliases for different mindsets is a really good idea. it will definitely help me
22:29:52 <acowley> EvilMachine: the point in the friendly names is that the explanation is entirely application specific. You're using a general structure to achieve a particular goal.
22:30:42 <EvilMachine> djahandarie: type aliases, as acowley said, are a good idea for different ways of thinking about it.
22:30:56 <EvilMachine> djahandarie: even when behind the scenes it's exactly the same
22:31:33 <acowley> EvilMachine: djahandarie's discipline in using newtypes is probably the correct thing, though. It prevents you from being sloppy, at the expense of some extra syntax
22:32:04 <djahandarie> acowley, I feel like I'm being lied to if there is some function   averageWeight :: WeightDictionary -> Int   yet WeightDictionary is just a type alias for IntMap Float. After finding that I'm often irritated that I had to look in the documentation for that, I would have rather just been told directly.
22:32:28 <EvilMachine> acowley, djahandarie: i think it's pointless to convince each other of how the different ways are better. because "better" is relative. you are both right.
22:33:10 <djahandarie> EvilMachine, I think that's a good excuse to kill most discussion. :p
22:33:23 <EvilMachine> djahandarie: lol. actually, it's psychology
22:33:31 <EvilMachine> djahandarie: and physics
22:33:31 <acowley> djahandarie: Interesting! I've never thought it would really annoy anyone. Whenever I discover a name is a type alias, I find it somewhat enlightening, but if that discovery is giving me more freedom then the API wasn't fully fleshed out to begin with.
22:34:38 <EvilMachine> maybe type aliases should be seen more like "tags" e.g. in the flickr sense. one alternative for what to call it.
22:35:10 <EvilMachine> so ghc could display: WeightDictionary aka. IntMap Float.
22:35:38 <EvilMachine> that way we would have the knowledge *what* it is, and what's its *purpose* in this *case*
22:35:39 <djahandarie> acowley, I think category-extras is a good example of type aliases gone wrong: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Algebra.html#t:Algebra.
22:36:03 <acowley> EvilMachine: that'd be up to the editor rather than GHC
22:36:24 <djahandarie> The type signatures read really nicely, but I need to depth-first traverse the docs to understand how the hell to use it
22:36:34 <ivanm> hooray, only two more things to do before I can release the new version of graphviz!
22:36:40 <EvilMachine> djahandarie: yes. but without it, it loses any meaning. "f g w m a"? seriously? that telly you absolutely nothing about its purpose. ^^
22:36:43 <acowley> "GDialgebra f g w m a" isn't self-descriptive enough for you?
22:36:53 <EvilMachine> acowley: yes and no
22:37:05 <acowley> djahandarie: at least he gave you, "NB: these definitions are actually wrong"
22:37:16 <acowley> that's the escape hatch
22:38:15 <EvilMachine> djahandarie: how would you feel about those type aliases being there, but the documentation showing the original types side-by-side to them. while in the code, you could use both.
22:38:29 <djahandarie> EvilMachine, that would be fine.
22:38:39 <acowley> djahandarie is right, though. The type for GDialgebra is much more informative if you don't know the names. But the type doesn't pin down the properties.
22:38:50 <EvilMachine> djahandarie: they would be mere comments for you.
22:38:51 <acowley> EvilMachine: that's how it works
22:39:05 <acowley> EvilMachine: you can use the RHS of an alias instead of the alias
22:39:17 <djahandarie> Yes, but it doesn't show in the docs.
22:39:21 <acowley> and in haddock, you click on the alias to see the RHS
22:39:28 <roconnor> @type mapAccumL
22:39:29 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
22:39:31 <EvilMachine> acowley: well, not really. in the documentation for the things that *use* the type aliases, you still have to look up the original types, no?
22:39:46 <roconnor> @type mapAccumL'
22:39:47 <lambdabot> Not in scope: `mapAccumL''
22:39:51 <roconnor> @type mapAccumR'
22:39:52 <lambdabot> Not in scope: `mapAccumR''
22:39:54 <acowley> it's hyperlinked
22:39:56 <EvilMachine> acowley: yes, you can use it. i thought that was obvious. :
22:39:57 <EvilMachine> :)
22:40:04 <djahandarie> acowley, I think clicking to another page is definitely enough to make you lose track of what the hell is going on
22:40:28 <dolio> Those aliases come straight out of mathematics, by the way.
22:40:33 <acowley> djahandarie: so maybe this is actually a worth addition to haddock's styling
22:40:33 <EvilMachine> acowley: clicking on the alias is exactly the step too much djahandarie is rightfully complaining about
22:40:39 <acowley> s/worth/worthy
22:40:45 <EvilMachine> acowley: it should be right there next to it. without clicking
22:40:46 <EvilMachine> :)
22:40:49 <dolio> In case there was any doubt about the "mathematical" mindset.
22:41:04 <EvilMachine> djahandarie:  i agree
22:41:24 <djahandarie> dolio, the problem is that I understand exactly what the mathematical names are, but I always need to click through to see what it's an alias for after not using the lib for awhile
22:42:12 <EvilMachine> dolio: somebody here, a couple of months ago, said, that if Haskell were designed with a mathematical mindset, the list would have been called "vector". :)
22:42:46 <dolio> The only real problem is that 'Algebra f a' is really 'an f-algebra structure on carrier a', not 'an f-algebra.'
22:42:54 <acowley> If you think about reading edwardk's code as reading mathematics, then you appreciate what we have more because the jargon is actually hyperlinked to types you can better understand.
22:42:56 <djahandarie> i.e., 'GAlgebra' provides useful information in a conceptual sense, but (f (w a) -> a) provides useful information in the 'trying to smash types together' sense.
22:43:05 <dolio> Why would it be called that?
22:43:35 <djahandarie> Why would what be called what?
22:43:37 <EvilMachine> djahandarie: i think an analogy is the command line interface versus the context menu. that's why TAB in bash is so neat. but not even requiring to type tab, would be even better.
22:43:47 <dolio> Why would lists be called vectors?
22:43:57 <acowley> You have to leave Vector for the dependent typing people. It's their crown jewel.
22:44:12 <EvilMachine> dolio: apparently, because that's what they are in math. (it's not my argument. i'm just the messenger.)
22:44:35 <djahandarie> dolio, because if Haskell were designed with a mathematical mindset, it would have dependent types and there would be no list!! Down with lists
22:45:16 * djahandarie -> bed
22:45:17 * EvilMachine likes stomping crown jewels of arrogance. ;) (Not deserved ones though.)
22:45:31 <EvilMachine> djahandarie: night. :)
22:45:46 <EvilMachine> djahandarie: i take your shift. it's 08:00 here. :D
22:47:25 <ivanm> huh, it seems that haddock doesn't accept qualified entities despite its documentation saying it does
22:47:32 <EvilMachine> Wikipedia says: Deciding equality of dependent types in a program may require computations. If arbitrary values are allowed in dependent types, then deciding type equality may involve deciding whether two arbitrary programs produce the same result; hence type checking becomes undecidable.
22:47:42 <ivanm> preflex: seen waern
22:47:42 <preflex>  waern was last seen on #ghc 11 hours, 48 minutes and 14 seconds ago, saying: I haven't added a file in a very long time :-)
22:47:47 <EvilMachine> Sounds bad for dependent types
22:48:19 <EvilMachine> ivanm: btw: are you a semi-admin or something?
22:48:39 <roconnor> @type foldl'
22:48:40 <EvilMachine> ivanm: or a secret Ming the Merciless? :D
22:48:40 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:48:46 <ivanm> EvilMachine: huh?
22:48:59 <EvilMachine> ivanm: (that's more of a compliment.)
22:49:21 <ivanm> wtf does "semi-admin" mean?
22:49:42 <EvilMachine> ivanm: you know what i mean
22:49:56 <ivanm> no I don't
22:51:21 <EvilMachine> ivanm: allright, i give you a hint: you are here all the time, and you usually give a bit grouchy reactions. ;)
22:51:36 <ivanm> I've only been here a fair amount recently
22:51:42 <ivanm> since I'm home sick
22:51:44 <ivanm> rather than at uni
22:51:47 <blackdog> EvilMachine: he's just an angry man. comes from living in canberra.
22:52:05 <blackdog> (luvyerwork buddy:P)
22:52:05 <ivanm> @slap blackdog
22:52:06 * lambdabot locks up blackdog in a Monad
22:52:20 <EvilMachine> ivanm: oh. well then, i hope you will get well soon. :)
22:52:25 <ivanm> blackdog: oh? you use my libraries?
22:52:41 <blackdog> it's ok, i understand. i'd be angry too if every time i tried to escape from hell a roundabout took me back to where i started
22:52:50 <EvilMachine> loool
22:53:06 <ivanm> blackdog: you're the one living in Sydney!
22:53:16 <blackdog> ivanm: no, but you're a useful person to sharpen an argument on
22:53:26 <EvilMachine> fractal roundabouts going all the way down? :D
22:53:26 <ivanm> heh, fair enough
22:53:33 <blackdog> for instance: that github is better than an island full of catgirls
22:53:57 <ivanm> does the island have internet?
22:54:35 <EvilMachine> if i have more catgirls around me than i can count, my question would be: what is an Internet??
22:55:12 <ivanm> EvilMachine: you obviously can't count very high...
22:55:48 <ivanm> EvilMachine: and he never said that you would be on that island
22:55:56 <ivanm> unless you're one of the catgirls... >_>
22:57:12 <roconnor> @src foldl'
22:57:12 <lambdabot> foldl' f a []     = a
22:57:13 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
22:57:14 <blackdog> (just in case anyone thinks i'm being horrifically sexist, it's a glancing reference to Reedspacer's lower bound)
22:57:18 <blackdog> http://lesswrong.com/lw/xt/interpersonal_entanglement/
22:59:16 <ivanm> blackdog: that kind of argument is discriminatory against dog-lovers!
23:07:58 <EvilMachine> ivanm: if i have a lot of catgirls around me, i don't give a fuck about *counting* them. :D
23:08:27 <EvilMachine> ivanm: i said i would be on the island. that's enough. you should know that. ^^
23:09:08 <EvilMachine> ivanm: i wonder though, why you'd assume not being on the island, and if you would, you would mostly care about *counting* them. ;)
23:09:21 <EvilMachine> ivanm: you aren't The Count by any chance? :D
23:09:27 <ivanm> he just said "an island full of catgirls", i.e. the existance of such
23:09:36 <ivanm> and you were the one who first mentioned counting!
23:09:46 <ivanm> besides, you'd eventually get sick of catgirls
23:10:07 <ivanm> especially if they're some kind of bio-engineered construct of limited intelligence (and thus limited conversational skills)
23:10:26 <EvilMachine> ivanm: what make you think one would still live before getting sick of them? they are catgirls after all.
23:10:56 <EvilMachine> ivanm: limited? i definitely hope they are! :D
23:11:45 <EvilMachine> now if you manage to get *this* derailed topic train back *on* topic, I offically bow to you. ;)
23:11:46 <blackdog> ivanm: i think you're allowed to posit catgirls who are both smart and sexy.
23:12:07 <ivanm> blackdog: that link you provided said otherwise!
23:12:15 <EvilMachine> blackdog: i disagree. ^^
23:12:15 <ziman> catgirls able to code Haskell? :)
23:12:25 <EvilMachine> ivanm: it's a physical impossibilit
23:12:33 <ivanm> OK, does anyone have any recommendations about what to rename Data.GraphViz.Types.* to?
23:12:49 <blackdog> ivanm: you're quite right, i retrat
23:12:50 <blackdog> ct
23:13:05 <ivanm> of _course_ I'm right!
23:13:11 <ivanm> you should remember that more often!
23:13:12 <ivanm> :p
23:13:18 <blackdog> that's probably why all the catgirls love you
23:13:27 <blackdog> smooth ivan of the long whiskers, they say.
23:13:32 <ivanm> O...K...
23:13:41 <EvilMachine> ivanm: please be a bit nicer to other people. sometimes i wonder how you stay alive with that attitude in RL. ;)
23:13:43 * ivanm points out that he doesn't know of any catgirls
23:13:53 <ivanm> EvilMachine: what attitude?
23:14:17 <EvilMachine> ivanm: this time you either definitly know what i mean, or it's time to find out.
23:14:20 <blackdog> EvilMachine: he's actually pretty cuddly in real life, if occasionally pedantic:)
23:14:27 * roconnor thinks when GHC compiles with profiling on it won't inline specialized versions of functions that don't have type signatures
23:14:36 <ivanm> blackdog: _occasionally_ ?
23:14:46 <EvilMachine> blackdog: yeah, pedantic and cuddly are exclusives to me.
23:14:48 <roconnor> because I'm seeing a big difference in profiling data whether I add a type signature or not.
23:15:13 <NemesisD> hey all. i've got a *very* simple web service. 1 action that takes a JSON POST and returns a json response. i'm thinking yesod might be overkill. is snap the way to go?
23:15:37 <EvilMachine> blackdog: you know, i don't think he's a bad person. rather the opposite. it's just:
23:15:53 <blackdog> NemesisD: what're you doing with the json on the back end? need db support etc?
23:15:55 <ivanm> NemesisD: I thought all of those web frameworks were more for actual HTML, etc.
23:16:01 <ivanm> aren't _all_ of them overkill?
23:16:23 <EvilMachine> blackdog: i thought he would only be like that here with me. but now i don't think so anymor
23:16:38 <EvilMachine> blackdog: it's not nice. and it's not helping anyone
23:16:41 <blackdog> EvilMachine: i never said he wasn't a bad person. there's a reason he got sent to canberra.
23:16:51 <SpiceMan> ivanm: no, some web frameworks are nice.
23:16:57 <ivanm> @slap blackdog
23:16:58 * lambdabot pokes blackdog in the eye
23:17:03 <EvilMachine> blackdog: i know. i just said that i don't want you to think i would think he was
23:17:04 <blackdog> (he beats me)
23:17:06 <ivanm> EvilMachine: what's not nice?
23:17:16 <EvilMachine> blackdog: he got sent
23:17:27 <blackdog> EvilMachine: I'm just messing around. I know you're not casting aspersions.
23:17:35 <ivanm> *sigh* I _chose_ to go to ANU...
23:17:48 <EvilMachine> ivanm: i still am not quite done with pattern detection, so it's not quite possible for me, to put it in words
23:18:50 <NemesisD> blackdog: nope. its a mostly pure task it performs. the JSON it gets in the post gives it all the context it needs to produce the response json, which is the sole objective
23:18:50 <NemesisD> its only on a web server because a rails app will be querying it and I didn't want to handle IPC, plus we might end up putting it on a different server
23:18:56 <NemesisD> ivanm: you may be right, i may be looking for the best haskell http server i can strap it to, i'd as little interaction with the http stack as posisble, i just want the post request in a usable format
23:19:10 <EvilMachine> ivanm: something in how you talk to me feels like attacks and talking down to me. which causes me to become angry. this would lead to us constantly fighting, if i wouldn't constantly hold back
23:19:45 <ivanm> EvilMachine: *shrug* then you're misinterpreting what I'm saying
23:19:57 <EvilMachine> ivanm: denial won't fix this
23:20:02 <EvilMachine> ivanm: i'm not the only one
23:20:13 <ivanm> oh? who else pray tell>
23:20:14 <ivanm> ?
23:20:23 <ivanm> if you're referring to pretty-printing yesterday: I was trying to stop you from making a mistake
23:20:37 <EvilMachine> ivanm: well, just about any reaction i have ever read from you. ;)
23:20:44 <ivanm> it took me a while to convert graphviz from using String to using pretty-printing
23:20:53 <EvilMachine> ivanm: listen. i don't want to fight with you. but i also won't hold back.
23:20:56 <ivanm> oh?
23:21:14 <EvilMachine> ivanm: just be a bit nicer. that will make your life easier too.
23:21:16 <EvilMachine> ok?
23:21:29 <ivanm> *shrug* I still don't have a clue about what you're talking about
23:21:51 <EvilMachine> ivanm: that i can believe. but maybe that's part of the problem
23:25:43 <EvilMachine> ivanm: look at your messages above. half of them are in the form of a "or really, isn't X Y?" with an implicit "(And aren't you dumb for not knowing that)?"
23:26:00 <benmachine> 07:35:38 < EvilMachine> ivanm: please be a bit nicer to other people. sometimes i wonder how you stay alive with that attitude in RL. ;)
23:26:06 <benmachine> ^ I don't think this is a nice way to put it tbh
23:26:19 <benmachine> if you are going to accuse people of being not nice you have to be *very* tactful about it
23:26:20 <EvilMachine> benmachine: ok, i agree
23:26:21 <ivanm> EvilMachine: no implicit message there
23:26:28 <EvilMachine> benmachine: absolutely right
23:26:45 <EvilMachine> ivanm: sorry, i should not offend you, when complaining about you offending me.
23:26:52 <ivanm> *shrug* I wasn't offended
23:27:13 <ivanm> I understood your way of saying it was meant to be in jest
23:27:25 <benmachine> oh well clearly I am oversensitive :P
23:27:28 <EvilMachine> benmachine: it's just... very hard... not to get angry while being attacked.
23:27:36 <ivanm> but I would posit that you're over-reading what I'm saying and putting in some kind of cultural assumptions or some such
23:28:29 <EvilMachine> ivanm: you're a bit like my brother. he also can't read between the lines. not even his own. some people are like that. they hurt others who are sensible for it. i am.
23:28:29 <augur> @tell conal third view highlights data TT's LT constructor bold green instead of normal red
23:28:30 <lambdabot> Consider it noted.
23:28:44 <EvilMachine> ivanm: maybe we should just... not talk. :)
23:29:19 <ivanm> EvilMachine: oh, I can; I just don't say things with hidden overtones (with the exception of acting "overly straight" for humour purposes when pretending not to understand something)
23:29:48 <ivanm> maybe I should start using more emoticons... :p
23:30:13 <EvilMachine> ivanm: this is exactly why i mean. overly straight. pitch-black sarcasm.
23:30:38 <EvilMachine> emoticons only make it more visible. not nicer.
23:30:45 <ivanm> e.g. going on about counting catgirls
23:31:10 <EvilMachine> ivanm: whatever. i don't want to tell you how to be. just... if you want to answer to things i say, you can't do that.
23:31:37 <EvilMachine> ivanm: yeah, the sarcasm is often coupled with being pedantic.
23:31:49 <EvilMachine> whatever. i've got some work to do
23:32:03 <benmachine> EvilMachine: maybe you could be more tolerant?
23:32:08 <ivanm> Oh, I'm pedantic at times, but typically only for comedic effect
23:33:54 * hackagebot egison 0.1.2.5 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-0.1.2.5 (SatoshiEgi)
23:34:27 <EvilMachine> benmachine: imagine someone telling you "oh, you're sooo smart! you did't overlook the fact that $X at all! :P " in that overly straight tone. and then being asked to be more tolerant to that. you would answer with: "wtf? me?? are you serious?" :)
23:35:17 <EvilMachine> benmachine: and i'm already holding back for niceness and tolerance purposes. it's just: enough is enough. maybe that enough is a bit low for me.
23:35:42 <EvilMachine> but don't worry. i won't attack ivanm or anything. i like the guys here too much.
23:35:56 <chrisdone> ivanm is like a big bowl of jelly with sprinkles ontop.
23:35:57 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
23:36:00 <chrisdone> @messages
23:36:01 <lambdabot> ivanm said 1h 12m 9s ago: hpaste seems to mess up the indentation of module export lists, specifically after a line with a comment: e.g. http://hpaste.org/47609
23:36:09 <chrisdone> ivanm is like a big bowl of rubbish oatmeal.
23:36:13 <ivanm> hey chrisdone
23:36:24 <chrisdone> Hey bro.
23:36:28 <ivanm> chrisdone: wait, I'm both rubbish oatmeal _and_ jelly with sprinkles? :o
23:36:43 <EvilMachine> will it blend?
23:37:02 <EvilMachine> (oatmeal can kill a blender, i think)
23:37:28 <ivanm> EvilMachine: ZOMG, you mean you want to chuck me in a _blender_?!?!?!? :o
23:37:29 <ivanm> :p
23:39:00 <EvilMachine> ivanm: lol. hell no! <ivanm-mode>i couldn't miss your nice comments!</ivanm-mode>
23:39:03 <EvilMachine> :D
23:41:54 <chrisdone> When using Snap I recommend: outputText text = do let !x = toStrict $ text; writeText x
23:42:08 <chrisdone> Otherwise any exceptions in text aren't caught by the Snap handler.
23:42:15 <ivanm> chrisdone: why do you need to bang with toStrict ?
23:42:38 <chrisdone> ivanm: Because the call to toStrict is still lazy.
23:43:08 <ivanm> ahhhh
23:43:16 <chrisdone> I tried it without first and then realized.
23:45:33 <ivanm> chrisdone: so, with hpaste: is that from your code or the highlighting library you're using?
23:46:45 <chrisdone> It's the 'highlighter' library. It behaves a little weird with comments, not sure what stylesheet is supposed to be used.
23:47:14 <ivanm> which one you using? the new one you blogged about?
23:47:19 <chrisdone> Yeah.
23:47:23 <chrisdone> http://hackage.haskell.org/package/highlighter
23:47:54 <ivanm> why is it that all these highlighting libraries are all fixed in terms of which languages they support?
23:47:56 <chrisdone> It adds extra newlines after comments. So I display:none'd those elements but I see it causes other problems elsewhere.
23:48:08 <ivanm> (rather than have the ability to provide extra stylesheets, etc. at runtime)
23:48:17 <ivanm> huh
23:48:56 <chrisdone> ivanm: I think this one can be extended with extra languages easily by making a Lexer.
23:49:13 <chrisdone> http://hackage.haskell.org/packages/archive/highlighter/0.2/doc/html/src/Text-Highlighter-Lexers-Haskell.html#lexer
23:49:51 <chrisdone> May be that the Haskell lexer itself is flawed. I'll make an issue on the amelie Github tracker.
23:50:25 <ivanm> huh
23:50:34 <chrisdone> https://github.com/chrisdone/amelie/issues/1
23:50:37 <ivanm> but it's using Bytestrings rather than Text...
23:56:44 <develhevel> is there a function to check if a String is a int (String -> Int) only find isDigit (Char -> Int)
23:57:58 <ivanm> develhevel: various parsing libs have one
23:57:59 <rothwell> develhevel: http://pastebin.ca/2077176
23:58:31 <ivanm> I've also done one that first checks if the first character is a '-', if it is checks that there is at least one digit
23:58:40 <ivanm> i.e. ignoring the negative case:
23:59:04 <ivanm> > let isInt = liftM2 (&&) (not . null) (all isDigit) in isInt "338943"
23:59:06 <lambdabot>   True
23:59:23 <ivanm> and your type of isDigit is wrong! ;-)
