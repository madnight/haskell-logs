01:04:01 <tjgillies> woohoo = forever $ forkProcess woohoo
01:06:21 <osfameron> yay, a purely functional forkbomb
01:10:36 * hackagebot dtd-types 0.2.0.0 - Basic types for representing XML DTDs  http://hackage.haskell.org/package/dtd-types-0.2.0.0 (YitzGale)
01:18:09 <Jafet> woohoo = fix $ forever . forkProcess
01:18:24 <Jafet> Absolutely alliterative
01:21:43 <Boxo_> * fix (forever `fmap` forkProcess)
01:23:51 <Jafet> aka "What the fork"
01:24:27 <Eduard_Munteanu> :)
01:26:24 <Jafet> Bah, this program is taking a day to calculate what some guy did in an hour on a PDP-11.
01:27:10 <Jafet> The worrying part is that I didn't bother to optimize it too much, because it wouldn't be the time-consuming part of the task
01:34:24 <DukeDave> Erm, cannot make pretty:
01:34:26 <DukeDave> readNum inputBuffer numPoints = get inputBuffer >>= (\s -> numPoints $= read (reverse s))
01:34:52 <DukeDave> My immediate thought was, "well that lambda is unnecessary", but I can't make it go away :|
01:38:42 <Jafet> $= is the Moroccan doorman operator?
01:38:55 <Eduard_Munteanu> :))
01:39:10 <Jafet> (Made in Morocco; they operate doormen.)
01:39:14 <Eduard_Munteanu> :t >=>
01:39:18 <Eduard_Munteanu> :t (>=>)
01:39:25 <Eduard_Munteanu> Uh.
01:39:27 <Jafet> parse error on input `>=>'
01:39:32 <Eduard_Munteanu> I know :)
01:39:51 <Jafet> (>=>) :: forall (m :: * -> *) a b c. Monad m => (a -> m b) -> (b -> m c) -> a -> m c
01:41:53 * DukeDave still doesn't get joke :(
01:42:44 <DukeDave> The ($=) is from here: http://hackage.haskell.org/packages/archive/StateVar/1.0.0.0/doc/html/Data-StateVar.html
01:43:45 <Jafet> :pl (\s -> numPoints $= read (reverse s))
01:43:51 <Jafet> ((numPoints $=) . read . reverse)
01:44:10 <ski> DukeDave : `readNum inputBuffer numPoints = (numPoints $=) . read . reverse =<< get inputBuffer'
01:44:28 <Jafet> Heh, IRC client renamed my "lambdabot" window to "dmwit"
01:44:44 <DukeDave> ski: Ooh, now that's clever, I always forget about (=<<)
01:44:55 <DukeDave> Jafet: Thanks also
01:45:23 <DukeDave> Jafet: So, the Moroccan doorman joke, I don't get it? :|
01:45:37 <Jafet> Don't worry, I don't get it either
01:45:43 <DukeDave> :P
01:46:30 <Eduard_Munteanu> Actually 'man' is redundant, it could be Moroccan door operator, sounds more techy ;)
01:47:14 <DukeDave> Aha, this is a bribe joke!?
01:50:06 <Eduard_Munteanu> Probably not, but it's still funny :)
01:50:39 <Eduard_Munteanu> You want more concrete? Consider the robot monkey operator...
01:50:42 <Eduard_Munteanu> (:[])
01:52:42 * hackagebot dtd-types 0.2.0.1 - Basic types for representing XML DTDs  http://hackage.haskell.org/package/dtd-types-0.2.0.1 (YitzGale)
02:45:50 * hackagebot AC-BuildPlatform 1.0.0 - Detect which OS you're running on.  http://hackage.haskell.org/package/AC-BuildPlatform-1.0.0 (AndrewCoppin)
02:58:00 <medfly> dudes
02:58:49 <medfly> how do I decide how to make new threads? as many as I have CPUs? as many as I need (possibly flooding myself with threads)?
02:58:52 <medfly> :3
03:00:29 <thoughtpolice> well, ghc maps lightweight threads onto OS threads. they're much lighter, so you can potentially create millions of them. they get multiplexed onto the set of OS threads that the runtime uses.
03:01:07 <thoughtpolice> in other words: you can create lots and lots of threads. now, sparking threads to evaluate '2+2' isn't useful, but if you have a good workload that can be parallelized, the # of threads should not be the bottleneck (at least i would think)
03:02:27 <medfly> because I recall repeatedly using forkIO to bring down a system, it makes me scared >.>
03:03:00 <thoughtpolice> define 'bring down' - it's pretty simple to write a pthreads program in C that just maxes out every cpu you have
03:03:43 <medfly> right
03:04:10 <medfly> I could accidentally create as many threads as that...
03:04:40 <medfly> what are other policies besides creating as many as I need, and creating as many as the number of CPUs?
03:05:13 <thoughtpolice> well deciding where to cut yourself off is still your own decision. you have to cut the workload to an appropriate granularity anyway. ghc just makes it possible and easy to have *lots* of threads
03:05:54 <medfly> the maximal number I could accidentally create is in the millions, I imagine that's enough to fuck up even on ghc.
03:05:59 <medfly> so I'd need some sort of limit ;-;
03:06:13 <thoughtpolice> i'm pretty sure ghc's been able to do millions of threads, for at least a while now
03:06:33 <thoughtpolice> depends on how much RAM you give it ultimately i think
03:06:46 <thoughtpolice> (something like 17 machine words of memory per forkIO thread?)
03:07:41 <gienah> thoughtpolice: I think from memory that simon pj said in a presentation that it was on the order of 200 - 300 bytes per haskell lightweight thread
03:07:55 <thoughtpolice> oh, i'm probably just thinking of the TSO
03:08:44 <medfly> oh that's actually a lot
03:08:46 <gienah> thoughtpolice medfly: this presentation: http://skillsmatter.com/podcast/scala/talk-by-haskell-expert-simon-peyton-jones
03:08:46 <medfly> :3
03:08:58 <thoughtpolice> i remember simon m having something to say about it in a ticket (a bug about preserving fpu something or another + with forkio)
03:09:04 <medfly> shit man that looks long
03:09:49 <medfly> anyway... is it stupid to restrain it to have as many threads as cores? because I want to access my hard disk (flash memory) with each one anyway, and that's not as parallel too
03:09:57 <medfly> and like a ton of threads is a ton of info
03:10:02 <medfly> I just don't want to make stupid design choices
03:12:39 <thoughtpolice> well threads are never free, ghc just makes them cheap (and this is a good for many things and in some cases allows better programming models with the appropriate support.) second, if you only a few threads because you're bottlenecked on I/O, well, there you go. you'll have to actually benchmark things to get real performance characteristics tho
03:13:35 <thoughtpolice> in which case i point you to a very slick benchmarking library: http://hackage.haskell.org/package/criterion
03:14:42 <medfly> :o
03:14:54 <medfly> it's not a huge deal, I just don't want to make stupid design choices ^^
03:15:05 <medfly> thanks
03:15:38 <ziman> when I was writing a raytracer I found out that it's much better to parallelize scanlines than pixels :)
03:16:45 <Jafet> Hm, just finished timing a program that took twice as long at -N3
03:16:45 <ziman> as long as your threads do non-trivial amounts of work (to keep the overhead:effect ratio low), any number of them is okay, I'd say
03:17:07 <ddarius> May have been even better to parallelize rectangles.
03:17:34 <Jafet> The difference isn't that much
03:17:47 <Jafet> Scanlines still have locality
03:20:37 <thoughtpolice> Jafet: how many cores? 2?
03:21:05 <Jafet> 4; at least one is being hogged by another computation
03:21:12 <thoughtpolice> ah, yeah that would explain it
03:21:25 <thoughtpolice> GHC has known performance degredations if it essentially is using every active core
03:21:42 <thoughtpolice> the reason is that the GC thread will constantly get descheduled and it hurts performance a lot
03:21:49 <Jafet> Oh, does -O2 -threaded imply blackholing?
03:21:59 <thoughtpolice> so if you have 4 cores and 1 is taken, then GHC using 3 will cause the GC thread to thrash
03:22:31 <thoughtpolice> GHC always uses blackholes, do you mean eager blackholing? i don't think that's the default
03:22:37 <thoughtpolice> (not at -O2 anyway)
03:23:31 <ziman> does GHC not take this into account when processing the -Nx option? (use x-1 cores for worker threads, 1 core for GC)
03:24:10 <Jafet> Well, this wouldn't be the first time the GHC manual didn't agree with GHC
03:24:21 <thoughtpolice> i could be wrong
03:24:40 <ziman> I mean, RTS.
03:24:43 <thoughtpolice> ziman: it'll auto-detect the amount of cores you have if you use just '-N', i don't think it auto-adjusts to x-1 though
03:24:52 <thoughtpolice> it probably should
03:25:00 <Jafet> Oh, music player is using another core
03:25:11 <thoughtpolice> simon's new GC avoids this particular pathological case, but at this point it may not get merged into HEAD because it's hella more complicated apparently
03:25:27 <gienah> the threadring benchmark no longer works for me on the shootout site, I go to it and it seems to show n-body instead of threadring (seems broken or hacked or lying to me): http://shootout.alioth.debian.org/u32q/performance.php?test=threadring
03:25:48 <thoughtpolice> ziman: also, some OSs are more dramatically affected than others
03:26:12 <thoughtpolice> ISTR OS X/solaris being relatively unaffected, but linux takes a much larger hit. not sure about windows.
03:26:22 <thoughtpolice> (this is pretty old behavior)
03:30:34 <Jafet> Well, for my program -Nk means multiply running time by k
03:30:42 <Jafet> Guess I'll optimize somewhere else
03:32:56 <zygoloid> Did you not read the RTS docs?   -N<n>    Run on <n> processors. Sequentially.
03:33:07 * zygoloid ducks
03:33:35 <Jafet> Those crazy ultra-determinists
03:34:29 <ziman> :)
03:38:38 <Jafet> do let { xs' = process xs; sz = length xs; sz' = length xs'; }; dumpFile xs'; putStrLn $ "Before: " ++ show sz ++ ", after: " ++ show sz';
03:39:00 <Jafet> What's a pretty way to do the above, without using O(length xs) space?
03:40:38 <Saizan> sz = length xs is ruining everything
03:43:31 <isomorphic> I'm guessing 'process xs' must be evaluated lazily?
03:46:01 <Jafet> (It might be more clear if xs' = concatMap process xs)
03:47:27 <Saizan> concatMap process is nice wrt space because you can GC xs as you consume xs'
03:47:36 <Jafet> sz and sz' must be evaluated in lockstep with xs and xs', so that their conses are GCed, but that 1) is ugly 2) needs a helper function to seq through sz, sz' 3) requires to expand the definition of xs' in the helper
03:51:11 <Saizan> maybe just "sz `par` sz' `par` dumpFile xs'" would do?
03:51:41 <Jafet> I guess most people just solve the problem by writing what I did: let { helper [] szs = return szs; helper (x:xs) (!sz,!sz') = let x' = process x in dumpFile x' >> helper xs (sz+1, sz'+length x'); } (sz, sz') <- helper xs
03:52:27 <Jafet> Saizan: oh that looks nice. I wonder if it works
03:56:14 <ddarius> Whether it works or not, and how well, depends on how the threads get scheduled.
03:57:09 <isomorphic> can somebody remind me how to use deepSeq to make evaluation of a function timeout?
03:59:04 <Jafet> Well, as long as each thread has bounded waiting time, the space leak is negligible
03:59:29 <Jafet> timeout t (evaluate . deepSeq $ x)
03:59:39 <isomorphic> Jafet: could you periodically sync up the threads using deepseq?
03:59:51 <Jafet> (You need evaluate to force deepSeq to start)
04:00:07 <Jafet> Are you referring to my question or something else?
04:00:50 <isomorphic> Jafet: I'm wondering whether the timeout machinery can be used to sync things up and kick in the GC
04:01:38 <Jafet> Heh
04:02:07 <isomorphic> jafet: and thanks!
04:02:47 <Jafet> I'd call that pfollows a b; schedules computation of a until it blocks and then schedules b
04:03:10 <Jafet> par should work for most cases though, as I just tested
04:10:03 <develhevel> hi, i have a value and it is true or false. now i want to change if from true to false, how does i make it? with "/" or "!"? (in c++ its "!")
04:10:04 <Jafet> Actually, it seems that par doesn't work for space usage. I was only testing evaluation order
04:10:23 <ben> develhevel: 'not'
04:11:08 <isomorphic> jafet: for that timeout code above, timeout doesn't seem to receive the result of the statement passed to deepseq - is that correct?
04:11:08 <Jafet> (re: Saizan)
04:11:29 <develhevel> ben: thx
04:11:39 <osfameron> develhevel: you could also have used Hoogle: http://www.haskell.org/hoogle/?hoogle=Bool-%3EBool ;-)
04:11:46 <osfameron> hoogle++
04:11:53 <Jafet> Huh, isomorphic? deepSeq a == a, evaluate a == return a
04:12:12 <Jafet> You get return x :: IO a (which happens to be reduced to NF)
04:12:55 <Jafet> ...and using my ugly helper, it runs in 10M, when it was previously using 1G.
04:15:41 <isomorphic> jafet: NF?
04:16:09 <Jafet> What deepSeq evaluates a term to
04:16:26 <Jafet> Normal form, if it exists
04:16:52 <isomorphic> hrmm...
04:17:01 <isomorphic> > timeout 4000000 (evaluate . deepseq $ "test") >>= putStrLn
04:17:22 <isomorphic> ... ?
04:17:28 <Jafet> <IO()>
04:17:35 <isomorphic> I expected "test"
04:17:55 <Jafet> The bot is called mueval, not muexec.
04:18:14 <isomorphic> :P
04:19:46 <isomorphic> so, I am guessing I need to somehow run the IO action that's been created?
04:20:03 <isomorphic> (i'm doing this in GHCI btw)
04:22:07 <Jafet> Control.Parallel> let xs = [1..10000000]; sz = length xs; in (sz `par` print (last xs)) >> print sz
04:22:07 <Jafet> <interactive>: out of memory (requested 1048576 bytes)
04:22:17 <Jafet> I wonder why it doesn't collect xs while it's evaluating sz
04:22:44 <Saizan> because it hasn't started evaluating (last xs) ?
04:23:29 <Jafet> Oh, I might need -threaded
04:23:42 <Saizan> ghci is -threaded by default
04:23:49 <Jragon> Hey.
04:24:02 <Saizan> -Nx ?
04:24:19 <Jafet> Doesn't that evaluate last xs and sz concurrently, then?
04:24:33 <Jragon> I was hoping I could find some examples of Haskell.
04:24:39 <Jragon> I want to see what people have done with it.
04:25:54 <Saizan> hackage.haskell.org
04:26:18 <Jafet> (let l = last xs; sz `par` l `par` print l) also fails. Maybe I still don't understand the semantics of par
04:30:27 <Jragon> Are there any websites made using Haskell?
04:31:47 <ezyang> http://www.quora.com/Is-there-any-website-or-web-application-programmed-in-Haskell
04:31:55 <Cale> Jragon: yes, sure.
04:32:35 <isomorphic> Jragon: Check out the channel #s napframework
04:33:06 * ddarius would be surprised if there wasn't a web site made using Brainfuck.
04:33:55 <Cale> Where is luite? There are lots of less fun examples, but I want to show off the demo that he made too. :)
04:35:21 <Jafet> There probably isn't. Most web developers don't have the intellectual fortitude to program in brainfuck.
04:35:52 <ddarius> Jafet: That doesn't keep Brainfuck developers from writing web sites.
04:37:17 * gienah thinks its bad enough putting coq on my resume, will keep away from brainf**k
04:37:46 <Jafet> I'd guess the world has about the same number of brainfuck developers as S23/B3 UTM programmers
04:39:33 <frerich2> I've recently played a little bit with Parsec, and I think it's really fun stuff (I can almost write my grammar's BNF 1:1 in Haskell). However, I was wondering (since I don't have a storng Comp.Sci. background): are "combinatorial parsers" like Parsec the same as recursive descent parsers? Or is it more like, "combinatorial" describes how the parser is constructed, and "recursive descent" describes how the parser does its work.
04:39:34 <Jafet> coq and brainfuck sounds like a hot combination
04:40:06 <Jafet> Parser combinators are most naturally implemented with recursive descent
04:40:10 <Cale> frerich2: More like the latter
04:40:14 <gienah> Jafet: :-)
04:40:31 <mekeor> Jafet: what's S23/B3?
04:40:48 <Jafet> Especially if you want to compose them arbitrarily the way parsec does
04:41:12 <Cale> You could have a parser combinator library which constructed a table parser, though monadic ones are typically some variation on recursive descent, because (>>=) doesn't really let you do much with the parser ahead of time.
04:41:41 <ddarius> The parser combinators related to Pappy work that way.
04:41:57 <frerich2> It's really neat to see how far Parsec took things. When I was a student I actually did something roughly similiar, too (a recursive descent parser framework which came with parsers like 'char' or 'string 'or '<|>' [which I called "either"]).
04:42:05 <Jafet> mekeor: game of life ruleset
04:42:08 <frerich2> Just that I did it in C++ and it didn't look half as nice
04:45:05 <Jafet> frerich: http://www.boost.org/doc/libs/1_46_1/libs/spirit/doc/html/spirit/introduction.html#id868739
04:55:43 <QinGW> ,date
04:55:59 <Twey> Has anybody written a book or guide on higher-level Haskell application/library structure?  Monad stacks, and so on?
05:02:04 <joe6> Wey, that would be awesome.
05:02:36 <joe6> Twey: that would be awesome.
05:05:16 <earthy> Twey: http://books.google.com/books/about/Advanced_functional_programming.html?hl=eN&id=JmpCHL_bHdQC ?
05:05:53 <djahandarie> jmcarthur, nice!
05:05:53 <preflex>  djahandarie: you have 1 new message. '/msg preflex messages' to read it.
05:06:44 <earthy> Twey: (or the 2002, 2004 and 2008 editions)
05:07:32 <k0ral> hey guys, in which "directory" of the libs tree should I put my browser lib ?
05:07:52 <k0ral> I thought about Network and Graphics but neither is really satisfying
05:09:10 <earthy> Twey: or did you look for more of an in-between between those and say RWH? :)
05:15:05 <gienah> Twey: http://www.haskell.org/haskellwiki/Typeclassopedia
05:21:27 <Twey> earthy: Isn't that a bit out-of-date now?  1998?
05:21:44 <Twey> gienah: I don't think that covers application structure…
05:22:00 <earthy> Twey: why would it b?
05:22:02 <earthy> be?
05:22:24 <Twey> earthy: I was of the opinion that most of this design methodology is pretty new stuff — 2005–
05:22:50 <earthy> ah :)
05:22:52 <earthy> no. :)
05:23:23 <earthy> most of the *experience* on it is new ;)
05:27:55 <fasta> earthy: which methodology?
05:28:06 <earthy> monad stacks
05:28:43 <earthy> see e.g. https://wiki.ittc.ku.edu/lambda/images/e/e3/Modular-interpreters.pdf
05:28:46 <earthy> (1995)
05:28:53 <fasta> earthy: what is the most complicated stack that those lecturers built?
05:29:09 <earthy> fasta: the lecturers... dunno
05:29:28 <earthy> but complete programming language interpreters was the status quo circa 1995
05:29:33 <fasta> earthy: it seems pretty pointless to listen to someone who hasn't actually used them in a real project.
05:30:12 <fasta> Just talking about interpreters from 1995 is also not going to be exciting.
05:30:31 <gienah> Twey: there is some stuff on application stucture in "The Fun of Programming" which is on: http://www.haskell.org/haskellwiki/Books note its in print at amazon.co.uk (actually 1 in stock)
05:31:00 <earthy> fasta: as I said, there's theory and experience
05:31:08 <earthy> the *theory* existed... the experience is newer
05:31:13 <fasta> earthy: sure, where is the experience?
05:31:36 <earthy> (because some people, such as the don, decided 'screw it... let's just use this stuff to do things')
05:32:02 <fasta> the don? Uhm, ok.
05:32:19 <dafis> Corleone or Stewart?
05:33:00 <earthy> Stewart :)
05:34:08 <earthy> fasta: but yeah, a book just above the level of RWH would be a good thing
05:34:19 <fasta> earthy: that is not what I asked.
05:34:27 <earthy> Twey did though
05:35:07 <fasta> There is no market for a book.
05:35:09 <earthy> what did *you* ask then, exactly? because now I'm confused.
05:35:32 <fasta> earthy: where the lecturers got their experience.
05:35:46 <earthy> ah. trying to solve the problems they were interested in
05:36:07 <fasta> earthy: such as?
05:36:40 <earthy> such as writing an interpreter in a fashion suited to gradual extension
05:36:43 <earthy> and then a compiler ...
05:36:52 <fasta> That's all?
05:37:02 <fasta> Ok.
05:37:17 <earthy> (programming language researchers tend to want to design programming languages.... weird isn't it? :))
05:37:42 <earthy> ofcourse, after that somebody picked up the pieces and thought 'hey, this works well with web servers'
05:38:04 <earthy> and similar
05:38:05 <fasta> I don't think that has already been demonstrated.
05:38:10 <earthy> why?
05:38:29 <fasta> The performance of monad transformers have not been shown to be on par with optimized code.
05:38:43 <fasta> It is perfectly possible to do so, but in reality it is just the case.
05:38:49 <fasta> just not*
05:38:51 <earthy> *ah*! wait!
05:39:02 <fasta> has*
05:39:20 <earthy> now I see what you're getting at
05:39:27 <gienah> sometimes even language researchers think its cool to apply to web servers: http://www.impredicative.com/ur/
05:39:47 <fasta> Writing such a compiler for compiler supported structures, is an exercise for a student, but making it work in general seems to be more interesting.
05:39:48 <Twey> earthy: I see
05:40:10 <earthy> no, obviously, optimising code to a special purpuse can not always be done generically
05:40:21 <fasta> earthy: well, actually it can.
05:40:28 <earthy> *always*? :)
05:40:46 <fasta> earthy: if the compiler has enough information, yes, but it requires lots of CPU time.
05:41:10 <earthy> ah. right. 'if the compiler has enough information'. that's exactly where the problem is
05:41:10 <fasta> The moment the human knows more about the problem, it is game-over.
05:41:47 <earthy> because, in an open-world environment, when compiling a library, you *cannot* know which conditions will hold at a callsite for that library later on
05:42:14 <earthy> therefore, the designer of the library needs to make assumptions that are general enough, but may not afford perfect optimization
05:42:15 <dafis> earthy: make your library restricted enough
05:42:28 <earthy> dafis: that's the tradeoff
05:42:47 <earthy> too restricted and your library has no use other than the program it was written for
05:42:55 <earthy> too general and it's hard to optimzie
05:42:57 <fasta> earthy: I think 'programming language researchers' should build working systems, since there isn't much to be researched left.
05:43:09 <fasta> E.g., they should build a Coq, etc.
05:43:09 <dafis> huh?
05:43:23 <fasta> (and not stop with it if it only half baked)
05:43:29 <dafis> not much to be researched left?
05:43:31 <fasta> if it is*
05:43:49 <fasta> dafis: monad transformers are from 1995.
05:44:01 <fasta> CoC is from the 80s.
05:44:10 <dafis> so, are monad transformers the end of everything?
05:44:14 <fasta> dafis: no.
05:44:23 <fasta> dafis: it demonstrates that nothing new happened.
05:44:29 <earthy> the hot current thing is dependently typed programming
05:44:32 <earthy> afaict
05:44:36 <fasta> earthy: which is old.
05:44:40 <earthy> (not a programming language researcher)
05:44:47 <fasta> earthy: at least 30 years.
05:44:51 <earthy> fasta: okay. name one thing you consider new. :)
05:45:28 <earthy> (because monad transformers in 1995 were old already... their application to interpreters was *not*)
05:45:32 <fasta> earthy: there was recently an algorithm invented to solve maximum flow problems asyptotically more efficiently.
05:45:43 * earthy nods
05:45:45 <fasta> asymptotically*
05:46:00 <fasta> earthy: I will admit that I don't consider a lot of things 'new'.
05:46:15 * scree weeps because there are no more programming languages to be conquered
05:46:32 <saati> scree: do you know prolog?
05:46:35 <fasta> scree: there are still some, but they require hard work, not research.
05:46:39 <dafis> scree: Malbolge?
05:46:50 <earthy> Oz
05:46:51 <erus`> scree invent a new one
05:47:01 <earthy> (I hear interesting things about Oz)
05:47:16 <earthy> oh, and I'm personally looking forward to programming C# and F# in anger
05:47:26 <erus`> with crazy message passing operators and every function is async like "Hello World" -> stdout
05:47:49 <Twey> Hrmph
05:48:03 <saati> isn't haskell doing the same thing implicitly with lazyness?
05:48:27 <earthy> Twey: what?
05:49:05 * scree was being slightly ironic
05:50:28 <earthy> Twey: you do realise that by doing advanced Haskell you're really close to PhD Level programming research, right? :)
05:50:48 <Twey> What's the appropriate pattern to use when you have a monad stack (ReaderT over IO, in my case), then want to allow user code to execute in IO (e.g. for a callback) whilst using actions in the monad stack?
05:52:40 <Jafet> earthy: is that a good thing?
05:53:41 <earthy> jafet: well, it is reason for documentation on it to be encoded in research papers rather than accessible books or documentation
05:54:41 <earthy> Twey: I would guess the appropriate pattern would be to design a datastructure that allows communicating the actions to be executed from the user code down to an 'interpreter' in the IO layer of the stack
05:55:18 <earthy> something like  IOT ReaderT IO   sounds weird
05:57:56 <Twey> earthy: Hrm :-\
05:57:59 <Jafet> What's IOT, is that anything like STT
05:58:09 <earthy> IOT does not exist :)
05:58:22 * earthy just hypothesized one for the sake of the argument
05:59:49 <Cale> Twey: Honestly, I often find ReaderT over IO specifically to be more trouble than it's worth, if only because the frequency of liftIO when using it tends to be higher than the extra parameter you'd be passing around...
06:00:28 <Cale> and yeah, using anything higher order becomes painful
06:00:59 <Twey> Cale: It seems to me that a lot of the functions in IO would be better off in MonadIO instead >.>
06:01:36 <Cale> Well, maybe, except that would make the common case of not wanting to use any monad transformer over IO slightly inconvenient
06:02:02 <Twey> How?  IO itself can be an instance of MonadIO, can't it?
06:02:03 <Cale> (I suspect)
06:02:08 <Cale> Yeah, it can.
06:02:15 <Jafet> earthy: well, the question is whether it could exist
06:02:23 <Cale> Though you'd run into ambiguous types quite easily.
06:02:23 <Jafet> Without being too weird
06:02:31 <Twey> Yes, I suppose so
06:02:32 <Cale> I guess ghci could aggressively specialise
06:02:49 <Twey> Okay, then.  *takes a wrecking ball to his carefully-constructed monad stack*
06:03:02 <Cale> How big is your monad stack? :)
06:03:11 <Cale> Also, have you newtyped the thing?
06:03:16 <Saizan> i don't think it'd be easy to get into ambiguous type variables, the "m" is going to appear in the result type most of the time
06:03:16 <djahandarie> TEN THOUSAND HIGH!
06:03:40 <Saizan> well, with the MR off
06:03:42 <Twey> Cale: ReaderT IO >.>  Haha.  But there's a DBus in there somewhere, too.
06:03:45 <osfameron> do you sometimes/often/always need to stack more than 2 monads together?
06:03:52 <Jafet> Can you even lift it?
06:03:59 * djahandarie agrees that newtype with deriving is a good way to deal with monad transformer stacks
06:04:02 <Cale> I actually hate the term "monad stack"
06:04:03 <Twey> Cale: Yes, I did newtype it
06:04:13 <Cale> Because you're not stacking monads at all
06:04:24 <Cale> You're applying monad transformers to some base monad.
06:04:26 <Twey> You're stacking monad transformers
06:04:33 <Cale> yeah
06:04:34 <Twey> Close enough, right?
06:04:40 <Cale> I *guess*
06:04:46 <Twey> Hehe
06:05:18 <Cale> We don't tend to refer to function compositions as function stacks though.
06:05:23 <Cale> Or value stacks
06:05:35 <earthy> worst I've done is type DocumentRepresentation = WriterT Postings (StateT Location PutM) ()
06:05:46 <Cale> f (g (h x)) -- value stack
06:05:57 <earthy> f . g . h  -- function stack
06:06:16 <earthy> would 'composed monad' be better? :)
06:06:31 <dafis> mOnion
06:06:41 <djahandarie> You can probably use the 'stack' terminology for any semigroup :)
06:07:05 <Jafet> (?reader :: a) => IO ()
06:07:17 <Jafet> Have to cps-transform it for writer though
06:07:24 <Twey> I like ‘function stack’.
06:07:31 <Twey> I think I have a function stack in my xmonad.hs.
06:07:51 <Twey> http://stuff.twey.co.uk/xmonad.hs
06:08:24 <Twey> commSpace is very nicely described as a ‘function stack’.
06:22:02 <genneth> hi guys; I seem to remember that there was a list of companies working with Well-Typed and MSR on parallel haskell... I can't seem to find it on google --- does anyone have a link to it?
06:24:31 <varnie> I am haskell newbie, should I skip all info regarding language extensions in my case?
06:24:49 <varnie> such as OverlappingInstances, TypeSynonymInstances to name a few.
06:25:30 <frerich2> varnie: I always skipped them so far, I tried understanding some of them but the explanations usually assume that you already have a good idea of how Haskell works (so you can understand how the extension extends the current behaviour).
06:25:48 <hpc> varnie: agree with above
06:25:54 <varnie> I am learning Haskell by real word  haskell tutorials btw
06:26:09 <hpc> varnie: there's some extensions that make more sense than others, but a lot of them do strange new things to the type system
06:26:17 <Jafet> You're bound to use some of them eventually, so read it when you need to
06:26:17 <hpc> which is already difficult enough to grasp as a newbie
06:26:24 <varnie> and I faced these extensions mentioned in the "Typeclasses" article
06:26:50 <Jafet> I think RWH uses a few extensions in the later chapters
06:26:53 <frerich2> varnie: I remember reading that, too (I'm also reading RWH right now) but I just skipped over the explanations.
06:27:16 <varnie> okay, I see
06:27:37 <frerich2> varnie: I once actually needed some extension, but I only found out because I couldn't get some code to work and googling the error message given by GHC actually explained that I need some extension to make this work.
06:27:51 <frerich2> varnie: So I just ignore all the crazy stuff until I seem to hit a problem
06:28:24 <frerich2> varnie: And now that I think about it, I forgot what the extension did and why. It was something with 'quantified type variables' or something like that.
06:28:38 <frerich2> I just remember thinking "Hm I thought that's how it works all the time, oookay..."
06:30:24 <varnie> I didn't get that "quantified type variables stuff" btw
06:31:07 <varnie> is it just not to mess up several functions with the same name (coming from different modules)?
06:31:21 <earthy> Well,   DeriveDataTypeable   is a useful extension
06:32:19 <earthy> but I only turn one of them on if I truly need it
06:32:45 <scree> varnie: i think frerich2 means explicitly scoped type variables, which is not what you just said
06:32:59 <varnie> scree, sure, I understood that
06:33:29 <scree> varnie: ok sorry, what was your question above then?
06:33:56 <varnie> what does "quantified" keyword mean?
06:34:05 <varnie> it is used in the import section in some cases
06:34:46 <scree> varnie: so, "qualified" is a keyword in import statements
06:35:05 <scree> varnie: AFAIK there's no "quantified" keyword
06:35:12 <frerich2> varnie: I was thinking it's like quantifiers in maths (the upside-down A "for all" or the mirrored E for "exists"); I see that in function signatures sometimes ("forall a. a -> (a, a)" or so).
06:35:17 <varnie> yes, I meant qualified, sorry.
06:36:02 <scree> varnie: right; in that case, yes, it means what you said above: it prevents "foo" from module A and module B being in scope, but puts only "A.foo" and "B.foo" in scope
06:36:23 <scree> varnie: (if A and B are imported qualified)
06:36:47 <varnie> thank you for the info
06:41:07 <mun_> does anyone know why there are HOL provers when the proof calculus for HOL is incomplete? how does one work with an incomplete proof calculus?
06:42:20 <quicksilver> all the best logic systems are incomplete
06:42:29 <quicksilver> you just prove what you can, and enjoy it while it lasts.
06:45:40 <Eduard_Munteanu> I suppose it wouldn't be much fun doing stuff in systems comparable to Presburger arithmetic.
06:46:16 <Eduard_Munteanu> By the way, this holds for all math, not just theorem provers.
06:46:18 <Jafet> Decide every statement you can imagine?
06:46:41 <Jafet> A circuit designer might like that
06:46:42 <zygoloid> even with a Presberger arithmetic prover, there's still the challenge of making it as fast as possible
06:48:24 <varnie> please help me in understanding what "newtype" means
06:48:43 <varnie> if it is possible, could you draw a parallel  with, say, C++ (if it is possible of course)
06:48:45 <Jafet> It's the keyword you use to define a newtype
06:48:49 <hpc> varnie: say you have a data type with one constructor and one thing inside
06:48:54 <zygoloid> varnie: it's like a "strong" typedef
06:48:55 <Twey> varnie: You can think of it as an optimised ‘data’ for the case where there is only one constructor
06:48:56 <hpc> varnie: data Foo = Foo Baz
06:49:06 <Zao> varnie: It's akin to a typedef that doesn't let you confuse the old and new type.
06:49:16 <zygoloid> varnie: the representation is the same as the underlying type, but the semantics can be defined any way you like
06:49:18 <varnie> and what it is good for?
06:49:18 <Eduard_Munteanu> Or 'type'.
06:49:35 <Eduard_Munteanu> varnie: basically cases where you'd use a data with a single constructor.
06:49:37 <zygoloid> varnie: it's a cheap way of allowing the same data model to have different interpretations
06:49:39 <quicksilver> an abstraction barrier.
06:49:43 <hpc> varnie: if you use the newtype keyword, when your program compiles it takes away all the crap that is normally important with data types, and all you have is a Baz
06:49:47 <Zao> varnie: It's good for when you need something that is exactly like the old type, but where it doesn't match any functions/instances of the old one.
06:49:50 <Eduard_Munteanu> The 'newtype' is faster, and you can use some nice extensions on it.
06:49:59 <Zao> (it _does_ get rid of instances, right?)
06:50:07 <hpc> it's still technically a different type, so you get type-checking for errors and different instances
06:50:10 <Eduard_Munteanu> (basically the newtype doesn't exist at runtime)
06:50:15 <zygoloid> Zao: (right)
06:50:26 <Jafet> Zao: yeah, but you can make it keep them
06:50:39 <Zao> Jafet: How, pray tell?
06:50:39 <Jafet> With GeneralizedNewtypeDeriving
06:50:43 <Zao> Ah.
06:51:13 <Jafet> Well, you still have to name the instances manually I think
06:51:19 <varnie> how often newType gets used in Haskell programming?
06:51:22 <zygoloid> varnie: in terms of the 'pure' haskell semantic model, it's exactly the same as 'data' except that the 'bottom' value and the wrapped 'bottom' value are identical
06:51:26 <hpc> varnie: a lot
06:51:29 <Zao> varnie: Rather often.
06:51:33 <Eduard_Munteanu> @src State
06:51:42 <ben> zygoloid: so it's basically a 'data' with a single strict field?
06:51:43 <zygoloid> varnie: perhaps not enough :)
06:51:45 <Eduard_Munteanu> *sigh*
06:52:11 <varnie> newType has more restrictions on its uses than the data keyword
06:52:20 <zygoloid> ben: denotationally, almost. case behaves differently in the two situations.
06:52:36 <ben> oh dear, that's complicated
06:52:53 <Twey> ben: 150644 < Twey> varnie: You can think of it as an optimised ‘data’ for the case where there is only one constructor
06:52:56 <Twey> :þ
06:53:06 <zygoloid> 'case C undefined of C _ -> ()' is _|_ if C is a strict data ctor, and is () if C is a newtype ctor
06:53:09 <varnie> is it smth like OOP inheritance/overriding (kinda of)?
06:53:11 <Eduard_Munteanu> varnie: yeah. You're only allowed to use one constructor and it must contain one thing.
06:53:23 <ben> Twey: I was wondering whether the 'strict' qualifier made it more or less identical
06:53:34 <zygoloid> ben: a more precise description is that a data ctor C !a has no value C _|_, but a newtype ctor C a has no value _|_
06:53:34 <Eduard_Munteanu> varnie: mm, not really
06:53:39 <hpc> ben: a more apt analogy might be "a data with the constructor missing"
06:53:53 <hpc> instead of data Foo a = Foo a, data Foo a = a
06:54:01 <hpc> (to horribly abuse syntax)
06:54:16 <ben> ok, cheers
06:55:26 <Eduard_Munteanu> varnie: you might think of them as opaque typedefs
06:55:38 <varnie> good point!
06:56:07 <Eduard_Munteanu> They don't expand straight to the definition, unlike 'type', but you have to pattern match.
06:57:06 <varnie> and why there should be only one field?
06:57:33 <Eduard_Munteanu> You'd need real constructors (i.e. tag bits) to distinguish values.
06:57:51 <Eduard_Munteanu> Think of 'data' as a strongly-typed union.
06:57:57 <Eduard_Munteanu> (from C/C++)
06:58:15 <ziman> @quote grubby paws
06:58:55 <Eduard_Munteanu> The newtype has only one possible thing in it, so you don't get any additional structure/overhead at runtime
06:59:40 <Eduard_Munteanu> OTOH, on a 'data' you have to check what you get. To do so you compare constructors, which are represented as bits in the final executable.
07:01:30 <Eduard_Munteanu> (you can think of 'data' as something like  struct { enum con_name con; union { int foo; float bar; ... }; };  with automatic checking)
07:01:35 <quicksilver> "which are represented as bits in the final executable" is one step too far.
07:01:58 <quicksilver> I'll let you go as far as "which you could imagine might be represented as..." ;)
07:02:02 <Eduard_Munteanu> I mean tag bits, at least in GHC. Well prolly not the executable but the actual memory representation.
07:02:11 <quicksilver> I know what you mean.
07:02:17 <Eduard_Munteanu> (I mean the final compiled representation.)
07:02:18 <Jafet> What's an executable?
07:02:24 <quicksilver> yes, I know what you meant.
07:02:27 <quicksilver> but they might not be.
07:02:29 <Eduard_Munteanu> Yeah, it's a fair point.
07:02:37 <quicksilver> perfectly possible to imagine haskell compilers which don't do that.
07:02:45 <quicksilver> GHC will eliminate explicit tags in some cases
07:02:56 <quicksilver> IIRC JHC will in some other cases
07:03:25 <Eduard_Munteanu> Still, without taking GeneralizedNewtypeDeriving into consideration, newtype is there for practical rather than semantic considerations.
07:03:42 <Eduard_Munteanu> practical == implementation concerns
07:04:27 <quicksilver> true but the level of abstraction is still different
07:04:36 <quicksilver> newtype simply promises zero overhead
07:04:43 <quicksilver> it doesn't need to go into detail about bits.
07:05:06 <quicksilver> (there is also a subtle semantic difference but that's certainly not the purpose of newtypes)
07:06:17 <varnie> it reminds me unions in the C world
07:06:34 <varnie> which got resolved at compile time
07:07:39 <quicksilver> you are right to be reminded of unions - more sepcifically, tagged unions, which is what Eduard_Munteanu was talking about.
07:07:46 <quicksilver> I don't know what you mean by 'resolved at compile time'.
07:07:55 <Jafet> C unions are septic enough
07:07:55 <quicksilver> C doesn't really resolve unions at all.
07:17:45 <varnie> I faced "!" here and don't know how to treat it. any help? " data Foo2 = Foo2 !Int "
07:18:28 <shapr> varnie: It forces strictness.
07:19:02 <shapr> varnie: Read section 6.3 of http://www.haskell.org/tutorial/moretypes.html
07:19:50 <djahandarie> edwardk_, hmmm :-)
07:19:55 <harlekin> Hi. I have a list of lines, with some empty lines in between them. Is there a nice way to group those lines according to where the empty lines are?
07:19:57 <varnie> I am there already.
07:20:08 <shapr> varnie: Does that answer your question?
07:20:15 <varnie> yes
07:20:22 <harlekin> Like, turn ["a", "b", "c", "", "d", "e"] into [["a", "b", "c"], ["d","e"]]?
07:20:24 <shapr> varnie: Any more questions?
07:20:32 <varnie> no
07:20:34 <djahandarie> harlekin, check out Data.List.Split from the split package.
07:20:35 <hpc> :t split
07:20:39 <harlekin> djahandarie: thanks.
07:20:43 <shapr> varnie: aw, just one more? :-/
07:20:43 <hpc> :/
07:20:58 <varnie> no, not now
07:21:04 <shapr> varnie: Ok... writing something interesting?
07:21:21 <Jafet> Now, now, let's not seq him
07:21:21 <varnie> I am a newbie in Haskell and that's all
07:21:35 <Jafet> He might get a weak head from that
07:21:36 * shapr thunks Jafet over the head
07:21:47 <shapr> varnie: What do you think so far?
07:21:54 <djahandarie> Terrible puns of the day go to Jafet and shapr
07:21:59 * shapr grins
07:22:16 <varnie> haha
07:22:20 <shapr> I'm in good form today.. normal form that is :-)
07:23:10 <varnie> I think it that fighting against monads conception will be hard for me :)
07:23:46 <Twey> Hahah.
07:23:47 <shapr> varnie: Monads are easier (in my opinion) if you learn functor -> applicative -> monad
07:23:52 * djahandarie imagines someone giving birth to a monad
07:23:52 <Jafet> Well, I suggest not fighting them
07:24:07 <hpc> what shapr said
07:24:45 <hpc> and obligatory lyah mention because it spends way more time on functor than it might need to, which really helps
07:25:10 <hpc> once you get functor, the rest is easy
07:25:37 <varnie> I know what is functor from C++ world:)
07:25:42 <erus`> what is monads?
07:25:52 <Jafet> varnie: it isn't.
07:25:52 <quicksilver> varnie: sadly, you don't :)
07:25:55 <djahandarie> varnie, different functor.
07:26:24 <hpc> @quote functor.C++
07:26:31 <hpc> oh right
07:26:49 <djahandarie> Wait, wasn't Cale just here?
07:26:54 <quicksilver> unfortunately in the deep mists of time somebody decided to use functor as a word for 'function-like-object'
07:26:58 <Jafet> varnie, this is a good time to recall Minsky: "Anyone could learn Lisp in one day, except that if they already knew Fortran, it would take three days"
07:27:04 <Cale> hi
07:27:06 <hpc> there's a quote of someone saying that after learning haskell, he feels incredibly silly every time he has to refer to a C++ functor
07:27:08 <varnie> hehe;)
07:27:09 <Cale> What's up?
07:27:10 <varnie> I got it:)
07:27:13 <djahandarie> Cale, lambdabot is exploded
07:27:17 <Cale> oh
07:27:31 <Zao> hpc: I tend to go with "callable".
07:27:35 <Twey> Again?
07:27:37 <MHD0> I really miss dependent typing in Haskell
07:27:44 <noteventime> Wouldn't a C++ functor class be something like a functor from the category of C++ classes with functions as morphisms to some subcategory of that category?
07:27:47 <Cale> All my screens are gone
07:27:51 <Twey> Isn't ‘callable’ just a function?
07:27:56 <hpc> Cale: hate it when that happens
07:28:18 <Cale> A C++ functor is just a stupid name for what we'd call a function.
07:28:20 <djahandarie> MHD0, :(
07:28:22 <Jafet> noteventime: actually formalizing that notion for a language like C++ will take twenty PhD-years
07:28:41 <djahandarie> Jafet, and each PhD-year is 4 human years?
07:28:43 <Jafet> And all those PhDs would end up with PHD
07:29:08 <Zao> Twey: In my world, something callable is something you can invoke with arguments in parens.
07:29:13 <Cale> Well, perhaps "procedure" would be a better term, since you can't stop the effects
07:29:16 <Jafet> djahandarie: humans just can't do it, so that's only an extrapolation
07:29:20 <Zao> Twey: free function pointers, objects with op() overloaded, etc.
07:29:22 <frerich2> Isn't a C++ functor different since it may carry some state (like counting the number of times it was invoked)?
07:29:27 <noteventime> Cale: A generic functor class would map a function to an object somehow reifying that function though
07:29:34 <MHD0> djhandarie: I'm trying to implement a LLVM code generator monad, and if I had dependent typing I could make it built in with the haskell type system. Now I just have to do it with soft typing.
07:29:49 <djahandarie> Do it in Agda instead!
07:29:50 <quicksilver> frerich2: that's not really "different" - C++ functions can do that too.
07:29:57 <quicksilver> (as can C functions)
07:30:15 <Cale> frerich2: Well, that's just a property of the fact that it can have side effects.
07:30:38 <Jafet> C++ "function objects" are an implementation of closures.
07:30:53 <Cale> A first class procedure can do everything that C++ functors can, anyway.
07:31:05 <Jafet> Ordinary functions in C++ cannot be bundled up into closures
07:31:10 <Cale> Even if it's not strictly speaking a function.
07:31:30 <Zao> Stop trying to bring in your silly nomenclature into my language, will you?
07:31:33 <Cale> (because it has some effects or doesn't always produce the same result when given the same parameter)
07:32:08 <Jafet> MHD0: Haskell does have dependent typing! We just make it clunky as a sporting handicap to coq
07:32:10 <Cale> C++ "functions" rarely are.
07:32:17 <Twey> Zao: What is the effective difference between these things and a function?  (in the imperative, impure sense)
07:32:42 <Jafet> Perhaps it's more accurate to say that GHC has
07:33:03 <MHD0> Jafet: I can make a Array type composed of an Int length and a atom type?
07:33:14 <Zao> Twey: The effective difference is that they have all the usual powers of class instances.
07:33:32 <Zao> Twey: May contain state, has ctors/dtors/etc., may have inheritance, and so on.
07:33:36 <Jafet> What's a atom type?
07:33:42 <harlekin> @pl (\p -> (p:) `fmap` f s)
07:33:42 <lambdabot> (`fmap` f s) . (:)
07:33:43 <Twey> Aha
07:34:11 <Zao> Twey: And oh, they can be polymorphic (in the function sense).
07:34:22 <Jafet> (Which are of course, not quite related to Haskell classes nor instances)
07:34:28 <Twey> Functions can't?
07:34:39 <Zao> Twey: If you have an overloaded free function, a function pointer can only point to a particular overload.
07:35:01 <Zao> While a class may have several op() overloads, taking all kinds of awesome arguments.
07:35:05 <harlekin> @pl (\(x:xs) -> (x, xs))
07:35:05 <lambdabot> liftM2 (,) head tail
07:35:06 <Zao> (even being function templates)
07:36:06 <varnie> sorry I've been off
07:37:08 <hiptobecubic> Does anyone know of any examples of haskell being used for computationally intensive purposes? Solving pde's, running numerical simulations, heavy linear algebra, etc?
07:38:15 <Jafet> I suppose combinatorics doesn't count
07:38:25 <Zao> Twey: http://codepad.org/Hp8L2rip
07:38:34 <Zao> Slightly nonsensical, but ought to provide a bit of context.
07:40:13 <noteventime> hiptobecubic: Have you checked http://www.haskell.org/haskellwiki/Haskell_in_industry ?
07:40:41 <Jafet> I don't know what kind of intensive computation is involved in financial trading
07:40:43 <shapr> hiptobecubic: Have you seen Repa, Data Parallel Haskell, and perhaps heard about the Credit Suisse project to do global economic modeling with Haskell?
07:40:45 <Cale> C++, Y U SO UGLY?
07:40:56 <shapr> @remember Cale C++, Y U SO UGLY?
07:40:56 <lambdabot> Good to know.
07:41:05 <Zao> I may have botched the enable_if syntax, I never get that right on the first try :D
07:41:09 <hiptobecubic> Cale, :D
07:41:32 <shapr> hiptobecubic: Haskell is/was used by Xilinx and Intel for die layout. I bet that's computationally expensive.
07:41:49 <cubi> I need to change my nick name :/
07:41:57 <varnie> reading docs regarding Haskell I noticed that it's always saying that "a function applied to the values(args),but not vice versa. it is interesting
07:42:39 <hiptobecubic> I am studying grid computing, from a computational science perspective rather than theory/computer science perspective. So i have hard time convincing my supervisor to let me write things in languages other than c and fortran.
07:43:15 <Cale> varnie: What would the other way around be? "a value applied to the function"?
07:43:17 <Jafet> If I was your supervisor, I would be hard to convince too
07:43:23 <varnie> yes!
07:43:28 <varnie> like in the C world
07:43:33 <Cale> maybe "supplied"
07:43:43 <varnie> yes, it is better to say so
07:44:03 <develhevel> when i'm in ghci, how can i print the defeinition e.g. of the typeclass Eq
07:44:05 <hiptobecubic> Jafet, sure. Because you don't know about the computationally intensive world of high frequency finance!
07:44:10 <develhevel> for a function i write :t foo
07:44:12 <hiptobecubic> neither do i, but maybe it's there
07:44:16 <Jafet> Then again, it shouldn't take long to write some inner loops in haskell and see how it performs
07:44:21 <shapr> hiptobecubic: Well, I plan on using the Cell BE blades in my BladeCenter with OpenCL and doing it all from Haskell.
07:44:35 <Cale> develhevel: :info Eq  will give you something, but in general source code is not available from ghci
07:45:01 <Cale> develhevel: However, if you have haddock documentation for the libraries that you're using, there will be source links in the right margin
07:45:03 <shapr> hiptobecubic: CloudHaskell is a distributed option: https://github.com/jepst/CloudHaskell/blob/master/README
07:45:11 <hiptobecubic> shapr, well that sounds pretty sexy. Does haskell have OpenCL bindings (for lack of a better term) ?
07:45:46 <shapr> hiptobecubic: At least one OpenCL binding, OpenCLRaw
07:46:08 <shapr> For non-distributed manycore computing, there's http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Repa_Tutorial
07:46:15 <varnie> so, is it a very important concept in Haskell (applying functions to values, but not supplying arguments to functions as in imperative languages)?
07:46:31 <shapr> varnie: Yes, because functions are also values.
07:46:33 <varnie> f a b -- we apply f to a and b
07:46:35 <Cale> Those are the same thing, aren't they?
07:46:46 <Cale> You're just saying it the other way around.
07:46:58 <varnie> it is naturally to think the opposite (supplying a and b to f)
07:47:03 <varnie> hmm, very may be
07:47:32 <noteventime> hiptobecubic: What about things like atom? http://hackage.haskell.org/package/atom/
07:48:10 <Cale> varnie: The part where it really starts to become different is the way in which all functions in Haskell actually have exactly one parameter / take exactly one argument.
07:48:28 <varnie> Cale, yes I am awared of that already (did read about that) :)
07:48:53 <varnie> "In Haskell, all functions are considered curried: That is, all functions in Haskell take just single arguments."
07:49:12 <Cale> Yeah, and when you write f x y z, it really means ((f x) y) z
07:49:38 <Cale> But you can just think of it as the single function f taking three parameters if you like, because that's kinda the same thing :)
07:50:27 <shapr> hiptobecubic: Got any particular flavor of grid in mind?
07:50:40 <Cale> I guess we could also do things like: f (x,y,z), because we have tuples, but we don't because it's far more convenient to curry things.
07:50:42 <varnie> hehe, I passed through this obstacle :)
07:50:50 <hiptobecubic> Well we are mostly working with super computing clusters.
07:50:55 <Eduard_Munteanu> And it types, -> associates to the right. Like    A -> B -> C    means A -> (B -> C)
07:50:58 <Eduard_Munteanu> *And in
07:51:04 <shapr> hiptobecubic: So, infiniband links or just gigabit ethernet?
07:51:43 <varnie> "The important property here is that the
07:51:43 <varnie> ->
07:51:43 <varnie> operator is right associative, and function application is left associative"
07:51:44 <shapr> I can't afford to put infiniband into my home BladeCenter :-( It's just too expensive.
07:51:56 <Cale> varnie: I suppose also on a related note to your original point, you'll often see people turn something like  f (g (h x)) into  f . g . h $ x
07:52:12 <hiptobecubic> shapr, infiniband
07:52:23 <varnie> Cale, I've read about ($) and (.) stuff
07:52:30 <Cale> where instead of applying functions successively to a value, we instead compose a bunch of functions and then apply the composite all at once
07:53:03 <Eduard_Munteanu> @bot
07:53:03 <lambdabot> :)
07:53:09 <Eduard_Munteanu> Yay.
07:53:20 <shapr> hiptobecubic: x86 cluster? or something more interesting like Cell/POWER cores?
07:53:36 <Cale> You'll also see some people write f $ g $ h $ x, abusing the fact that $ happens to associate to the right, but I recommend against relying on that, if only because composition (.) is a much nicer operation, and for instance, f . g . h will be meaningful here, while f $ g $ h will be a type error.
07:53:43 <hiptobecubic> shapr, I've only played with x86 so far. But I just started.
07:54:24 <shapr> hiptobecubic: If you have reason to use/learn about Cell or IBM BladeCenters, you should talk to me :-) I bought my own.
07:54:36 <Cale> If you do that enough, you'll eventually get used to just composing functions together often without referring to the arguments at all.
07:54:59 <hpc> the practice is called point-free (or pointless)
07:55:23 <Cale> (which is a term from topology, where functions mostly operate on (geometric) points)
07:55:27 <hiptobecubic> We mainly use Lisa in the netherlands.  https://subtrac.sara.nl/userdoc/wiki/lisa64/description
07:55:31 <hiptobecubic> shapr, ^
07:55:38 <hiptobecubic> shapr, for?
07:55:50 <hpc> Cale: really? awesome
07:56:20 <shapr> hiptobecubic: Purely for my own entertainment and experiments. I do have some upcoming fun projects though.
07:56:29 <hiptobecubic> shapr, how much was it?
07:57:45 <shapr> hiptobecubic: I ended up paying about USD $5000 all told, and that includes Layer 2-7 router module, spare power supplies more blades than I can fit into one chassis, etc. But it took months of ebay stalking :-)
07:58:10 <shapr> hiptobecubic: I have pix! http://picasaweb.google.com/shae.erisson/UbuntuOnMyBladeCenter
07:58:29 <hiptobecubic> shapr, sure. Sounds pretty sexy. What are you running on it?
07:59:24 <hpc> shapr: whoa
07:59:37 <shapr> hiptobecubic: I'm running Debian on the x86 blades, and Yellow Dog Linux on the Cell blades. Two networking modules means 2gigE links to each blade. No way I can afford anything faster, sadly.
08:00:13 <quicksilver> what shapr isn't telling you is that that thing consumes so much power that the power cost can consume his entire living allowance for a month if he switches it on for 10 minutes :)
08:00:24 <Cale> http://en.wikipedia.org/wiki/Pointless_topology
08:00:45 <hiptobecubic> quicksilver, that was my next question :)
08:01:05 <shapr> quicksilver: Bah, it peaks at 13000 watts :-P but I don't usually use more than 1000 watts at any given moment.
08:01:12 <hiptobecubic> shapr, i meant why have you built it. What projects are you planning on using it for. The distros aren't (hopefully) going to make much difference
08:01:21 <Jafet> ...how much power per watt?
08:01:23 <hiptobecubic> 13000 :D:D:D:D  haha
08:01:37 <quicksilver> shapr: at least you save on heating, right? ;)
08:01:42 <hiptobecubic> You'll have the FBI raiding your house looking for hydroponics
08:02:08 <shapr> I don't have anything like the 20Tflop peak that hiptobecubic has, but I do have ~2.5Tflop peak
08:02:29 <shapr> quicksilver: Yah, who needs a dryer, I just hang my clothes by the exhaust fans...
08:02:55 <hiptobecubic> shapr, if it makes you feel any better, I haven't done anything worthwhile yet.
08:03:01 <Cale> I'm reminded of http://www.youtube.com/watch?v=oH3LuOs9gc8
08:03:09 <shapr> hiptobecubic: I actually built it to figure out what I could do with >100 cores in one box.
08:03:18 <hiptobecubic> shapr, have you benchmarked it doing anything?
08:03:27 <hiptobecubic> shapr, how many cores is it?
08:03:59 <shapr> hiptobecubic: I've only benchmarked with distributed.net. I was ranked 11th monthly with two of my QS20 Cell blades running.
08:05:46 <Cale> see also: http://www.youtube.com/watch?v=rGL67coOdOk&feature=related
08:05:46 <shapr> hiptobecubic: I'm using obsolete QS20 blades that take up two slots, so six dual Cell blades (Cell has 1 boss CPU and 8 SPUs) and one dual-quad Xeon and one dual-dual Xeon, that's 108 cell cores and 12 x86 cores.
08:06:07 <Cale> (that guy has a lot of insane videos with electrical abuse :)
08:06:22 <shapr> Jafet: I try to think of flops/$ in the purchase price :-P
08:06:39 <Jafet> Me too.
08:06:47 <Jafet> I think of the marginal cost
08:07:21 <Jafet> Haskell on Cell? Would that work?
08:08:05 <noteventime> Wasn't there someone working on some DSL for writing code for the SPEs?
08:08:37 <Egbert9e9> lazarus can compile for any architecture and use the same widgets for many widget toolkits. is there anything like that for haskell? is gtk like that?
08:09:10 <Egbert9e9> i mean, gtk isn't
08:09:17 <Egbert9e9> but it has wide support, right?
08:09:30 <quicksilver> wx is slightly like that
08:09:33 <Egbert9e9> ah
08:09:34 <quicksilver> but you say "many toolkits"
08:09:40 <Aune> Hello all. I have a slight problem with OpenGL in Haskell. My program compiles, but when I run it, the window does not appear. I get a tab in the program tray but pressing it reveals no window.
08:09:41 <quicksilver> wx supports win32, OSX
08:09:44 <quicksilver> and has a native linux look.
08:09:45 <Aune>  Also, Im using Ubuntu, here is my code: http://hpaste.org/47332/ghc_linking
08:09:47 <shapr> Jafet: Haskell has an OpenCL binding, and there's an OpenCL compiler for the Cell, that's where I'm aiming.
08:09:47 <Egbert9e9> gtk doesn't?
08:09:48 <quicksilver> that's only 3 ;)
08:09:56 <quicksilver> not so well.
08:10:01 <Aune> Anyone can tell my why this is happening?
08:10:07 <Egbert9e9> an extreme bummer, yo!
08:10:07 <shapr> noteventime: I think Chris Anand's Coconut does SPE code.
08:10:10 <quicksilver> gtk/OSX wasn't finished last I looked.
08:10:20 <Jafet> Also, another way to get Cells: https://documents.epfl.ch/users/l/le/lenstra/public/pictures/DSC00942k.JPG
08:10:21 <quicksilver> (you can use X11 on OSX, of course, but most people don't like that)
08:10:47 <Cale> import Display?
08:10:49 <shapr> Jafet: Yah, but nowadays you'd have to use a Sony-sued firmware mod.
08:10:50 <Egbert9e9> so if i want wide support i should go for wx?
08:10:55 <Jafet> Apparently, EPFL has over 200 of those (over 1200 Cell processors)
08:10:57 <Cale> oh, sorry
08:11:03 <Jafet> And they do integer math on them!
08:11:11 <noteventime> shapr: Right, I think that's the one I was thinking of
08:11:38 <Cale> You are correct, that is indeed what happens :)
08:11:40 <shapr> Jafet: Probably because the original Cell only does single-precision. The PowerXCell does double-precision, but is far more expensive.
08:12:22 <shapr> hiptobecubic: If you get permission to try Haskell dev for your cluster, I want to hear about it!
08:12:24 <varnie_> "the type signature of the (=~) operator is difficult to understand, so we will not explain it here." what it is about?
08:12:30 <Egbert9e9> sigh, all this gtk2hs learning and i'm still stuck -_-
08:12:40 <Aune> Cale, do you have any idea why or how I can fix it?
08:12:43 <Jafet> @type (=~)
08:12:43 <Cale> Aune: set the window size
08:12:47 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
08:12:54 <Aune> Cale, doh!
08:13:22 <Jafet> varnie: that type signature allows the same operator (=~) to mean different things, depending on where it's used
08:13:37 <Jafet> So ideally, you could use it anywhere and it would do The Right Thing
08:13:43 <Jafet> In reality, it doesn't happen
08:14:19 <varnie_> speaking in C++ terms, it can be overloaded for some Class (C++ class) specifically so, it might mean only God knows what, correct)?
08:15:07 <varnie_> and there're no warranties it will  perform "regexp"
08:15:27 <Jafet> No, stop trying to compile Haskell to C++
08:15:31 <varnie_> okay
08:15:46 <Jafet> It's not useful
08:15:54 <Cale> varnie_: more or less (though classes in Haskell have very little to do with C++ classes)
08:16:04 <varnie_> yes, I know that, that's true
08:16:07 <hiptobecubic> shapr, haskell goes to libc right? so it could be possible to do things in haskell and just not tell anyone :D
08:16:19 <varnie_> I keep both concepts in mind
08:16:32 <Jafet> The GHC RTS goes to libc
08:17:07 <Jafet> So yes, the cluster admin probably doesn't have to know
08:17:22 <Jafet> Think his supervisor would be interested in the source code though
08:18:46 <varnie_> how to load Text.Regex.Posix in GHCI? It cannot see it
08:19:09 <Cale> import Text.Regex.Posix  or :m + Text.Regex.Posix
08:19:27 <Cale> and if you don't have that, you'll need to install the package...
08:19:35 <Jafet> Not in base?
08:19:36 <varnie_> that's the case
08:19:46 <Cale> cabal install regex-posix
08:19:49 <varnie_> "Could not find module `Text.Regex.Posix':"
08:19:56 <Cale> (from the commandline, rather than ghci)
08:20:09 <Cale> and if you don't have cabal-install, it'd be a good idea to get that first
08:20:18 <varnie_> the problem is that I don't have cabal installed (I am on freebsd box btw)
08:20:24 <Cale> Another thing to consider is not using regex at all.
08:20:47 <Jafet> Then install cabal-install
08:21:24 <Cale> http://hackage.haskell.org/packages/archive/cabal-install/0.10.2/cabal-install-0.10.2.tar.gz
08:21:42 <Cale> there's a bootstrap.sh script in there which *should* get it running from most configurations...
08:21:43 <shapr> hiptobecubic: Will you be blogging about Haskell on Clusters?
08:21:51 <varnie_> here's what I found: "At the moment, the best way to get cabal-install installed on your
08:21:51 <varnie_> system is to simply download it and build then install." (they speak about FreeBSD)
08:21:54 <Cale> I don't know anything about making stuff work on freebsd though.
08:22:10 <varnie_> no problem
08:22:33 <shapr> Cale++ # for sheer awesomeness
08:22:37 <shapr> @karma Cale
08:22:37 <lambdabot> Cale has a karma of 50
08:22:49 <hiptobecubic> shapr, I'm quite new to cluster computing and literally haven't done anything more than lyah with haskell. If it comes to the point where I'm able to do some interesting things I'll try to write about it, sure. Anything that might help me get noticed someday.
08:22:52 <varnie_> @karma shapr
08:22:52 <lambdabot> shapr has a karma of 9
08:22:55 <varnie_> wow:)
08:23:07 <Cale> shapr secretly has infinite karma
08:23:18 <Jafet> \omega + 9
08:23:25 <shapr> hiptobecubic: I'd suggest a Hakyll-based blog, mostly because I just started my own: http://www.ScannedInAvian.com/
08:23:42 <Cale> (the karma file has been reset a lot in the past...)
08:24:02 <hpc> it's also not generally used that much in here anymore
08:24:39 <hpc> what shapr said; you can get a nice website running with haskell very easily
08:25:33 <shapr> hiptobecubic: Documenting failure in greater detail than success is a good way to get noticed. Implies you don't repeat mistakes.
08:25:51 <Cale> What is that board in the picture on your projects page?
08:25:58 <hiptobecubic> shapr, a reasonable thought.
08:26:23 <Phyx-> does anyone know which file i should edit to change the ghc version name?
08:27:23 <shapr> Cale: Arduino on the left, Renesas RX62N dev board on the right ( http://www.renesas.com/RDKRX62N ). It was free, but not particularly Linux/gcc friendly.
08:27:57 <noteventime> Has there ever been an interactive program/proof derivation system (dunno what it's called) like Coq's tactics for Haskell?
08:28:09 <shapr> noteventime: Agda?
08:28:10 <tibbe> adimit, so I think the conclusion from your HashMap issue is that it can be worthwhile to call 'copy'
08:28:15 <noteventime> shapr: Agda has tactics?
08:28:22 <tibbe> adimit, on ByteString keys before inserting into the map
08:28:22 <shapr> noteventime: I don't know :-/
08:28:49 <noteventime> Let me check, I've been told it didn't, but that might have been out of date news
08:29:20 <tibbe> adimit, most of the time sharing the underlying buffer is not a problem, as all the ByteStrings that share the buffer tend to be in use. Of course, in your case you're counting duplicates (and discarding them) so it's a bit of a pathological case.
08:29:57 <noteventime> shapr: Agda is based on writing the proof terms yourself
08:30:31 <jmcarthur> no agda doesn't really have tactics
08:30:33 <noteventime> Though there might be some external system adding something like tactics to it
08:30:43 <varnie_> is monads the most difficult part of understanding Haskell (in a practical way)?
08:31:02 <shapr> varnie_: No, I think the most difficult part is managers :-P
08:31:03 <Cale> varnie_: No, they're not difficult.
08:31:06 <hpc> varnie_: only if you imagine monads to be difficult :P
08:31:17 <Jafet> @quote monad.tutorials
08:31:18 <lambdabot> Cale says: What we need are monad tutorial transformers. // So that we can compose the features of monad tutorials
08:31:20 <varnie_> I like your responses)
08:31:31 <hpc> monads are quite simple if you learn the prerequisite concepts
08:31:40 <Cale> The hardest part is that if you're not a functional programmer already, you need to learn to program again.
08:31:41 <hpc> don't jump straight from arithmetic to derivatives, etc
08:31:46 <noteventime> There seems to be some interesting Emacs mode for Agda though
08:31:54 <varnie_> it takes a while to understand where to apply them
08:32:04 <jmcarthur> that is the primary way to use agda, noteventime
08:32:05 <varnie_> or just to "recognize" we are dealing with monad
08:32:15 <Cale> varnie_: Don't worry about it
08:32:32 <hpc> varnie: it will come to you as you gain experience
08:32:33 <varnie> okay, I'll try
08:32:34 <shapr> varnie_: Yah, understand functors first, then applicative, then monads. That's one good approach.
08:32:34 <noteventime> jmcarthur: Any idea if a similar idea could be applied to Haskell?
08:32:37 <Egbert9e9> cabal install wx :-D
08:32:46 <Cale> varnie_: Some libraries we write happen to contain monads, and it's nice to recognise it when it happens.
08:32:56 <jmcarthur> noteventime: probably not as effectively
08:32:58 <Cale> varnie: But otherwise, it's not worth stressing out about.
08:33:07 <varnie> I see.
08:33:54 <noteventime> jmcarthur: True, I find the idea of programming by refining partial terms (which seems what the agda mode allows you to do) sounds rather intuitive
08:34:02 <varnie> I liked the tutorial describing monads operating with spaceships and spacesuits :)
08:34:34 <jmcarthur> noteventime: this is also pretty neat (and the standard libraries have what you need to use agda this way)   http://www.csie.ntu.edu.tw/~b94087/aopa-intro.pdf
08:34:48 <jmcarthur> it's not tactics, but it does allow you to check derivations and stuff
08:35:01 <Cale> varnie: lol
08:35:10 <varnie> Cale, here it is: http://www.iterasi.net/openviewer.aspx?sqrlitid=ixx7fcluvek_9lfolsxr_g
08:35:37 <varnie> this link is in the tutorials section on haskell.org if I'm not mistaken
08:35:45 <Cale> varnie: yeah, it's (in)famous
08:36:08 <shapr> varnie: /me uses {-# UNPACK #-} !Burrito and gets cheese on his keyboard
08:36:12 * shapr grins
08:36:45 <hpc> that page was broken without javascript
08:36:57 <varnie_> you're about this link? http://www.iterasi.net/openviewer.aspx?sqrlitid=ixx7fcluvek_9lfolsxr_g
08:37:03 <hpc> it seems to use an iframe with dynamic width/height
08:37:08 <Egbert9e9> can we have a command for lambdabot that'll make it say that monads are just like that weird mathematical thing in category theory?
08:37:11 <hpc> and doesn't even measure the page dimensions right
08:37:11 <Cale> There are a lot of monad tutorials which are extremely poor, because for whatever reason, everyone wants to write a tutorial when they understand monads for the first time. Understanding something yourself doesn't necessarily mean you can write a decent tutorial on it though :P
08:37:24 <hpc> Egbert9e9: which one? there are several
08:37:34 <Egbert9e9> the famous quote
08:37:35 <hpc> monoids in the category of endofunctors is one
08:37:49 <varnie_> yup
08:37:55 <Jafet> @quote endofunctors
08:37:56 <Egbert9e9> wow
08:37:56 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
08:38:08 <hiptobecubic> Any people familiar with navier-stokes in here that can help me understand this equation? I am just trying to identify the different parts of it based on the wiki article. http://mathbin.net/63026
08:38:09 <djahandarie> @quote lax.pullback
08:38:10 <lambdabot> No quotes match. Maybe you made a typo?
08:38:12 <hiptobecubic> oops. wrong channel
08:38:13 <Jafet> @quote invisible.train
08:38:14 <lambdabot> kmc says: a monad is like an invisible train filled with jello traveling backwards in time
08:38:19 <hpc> there's another one that puts it in terms of catamorphisms or something?
08:38:30 <Cale> hpc: That would be odd
08:38:35 <djahandarie> That made no sense, oops
08:38:38 <hpc> i forget exactly
08:38:43 <djahandarie> @quote lax.functor
08:38:44 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
08:38:48 <hpc> yes, that
08:38:49 <djahandarie> @quote 2-category
08:38:49 <lambdabot> dolio says: Monad are just monads in the 2-category of categories.
08:38:56 <hpc> haha
08:39:03 <Egbert9e9> oh god oh god oh god ;____;
08:39:06 <varnie_> the list goes on
08:39:14 <hpc> i like that last one
08:39:32 <hpc> recursive definitions are definitions that include recursive definitions
08:39:41 * osfameron doesn't understadn any of the "monads are just ..." jokes ;-)
08:40:00 * Cale understands all of them... so far
08:40:43 * Egbert9e9 has no hope to understand any
08:40:48 <Cale> Well, I'd need a moment to pick apart and check the lax functor one, but it vaguely makes sense
08:41:01 <sm> why is cabal install cabal-install keen to downgrade my 1.10.x to 1.8.x ?
08:41:25 <sm> s/1\./0./g
08:41:55 <djahandarie> Cale, technically a lax 2-functor depending on terminology
08:42:40 <owst> Is there a way to do something like this: http://nominolo.blogspot.com/2010/04/haskell-tip-redirect-stdout-in-haskell.html without permanently clobbering stdout? I'd like to be able to redirect stdout to a filehandle, within one function.
08:43:23 <Cale> Yeah, and that would be defining the more general monad in a bicategory, rather than the classical sort of monad. :)
08:44:29 <varnie> thanks for the conversation, I gotta go.
08:44:31 <djahandarie> You could also say: Monads are just monoids in the one-object bicategory corresponding to a monoidal category.
08:44:37 <hpc> varnie: later
08:44:37 <varnie> good bye.
08:44:43 * shapr waves to varnie 
08:45:41 <Jafet> owst: probably POSIX specific
08:46:05 <dcoutts> sm: my fault, I'd not realised the canonical source of the preferred-versions file comes from the hackage-scripts darcs repo. I'd just updated the version on the server.
08:46:15 <Egbert9e9> so guise, the best gui toolkit for a cross platform app will be wx, right? i'm not currently compiling wx for nothing, right?
08:46:33 <dcoutts> sm: it'll fix itself next time someone uploads, and I've sent Ross the patch so it'll not get reverted next time he updates.
08:46:35 <Cale> Egbert9e9: GTK is just as good.
08:46:51 <Jafet> Oh, nevermind, that code doesn't use posix handles
08:46:51 <Cale> Depends on what you like better
08:46:57 <sm> great, thank you. Making sure I have latest 0.10.2 on all systems right now
08:47:02 <Egbert9e9> Cale: i'm half doing that because i'm afraid of treeview
08:47:16 <Egbert9e9> Cale: i think i like glade
08:47:24 <dcoutts> sm: in the mean time, you can just say: 'cabal-install >= 0.10'
08:47:33 <Cale> Yeah, glade is pretty cool
08:48:10 <sm> I love cabal install --only-dep, and keep trying cabal install --only but that does something else, I'm not sure what
08:48:21 <sm> issue-worthy ?
08:48:43 <dcoutts> sm: oh yes, hmm.
08:48:54 <dcoutts> sm: --only is a secret undocumented flag :-)
08:49:04 <sm> no longer secret ! :)
08:49:33 <dcoutts> sm: --only will go away at some point
08:49:37 <sm> great
08:49:38 <sm> I also love that cabal build now auto-configures when it needs/can
08:49:43 <dcoutts> so the clash will disappear
08:50:16 <dcoutts> sm: yes, it's better but not perfect yet, it will not configure from a clean state
08:50:42 <sm> ah, yes
09:00:57 <Aune> Is there an up to date tutorial on OpenGL in Haskell, Im using http://www.haskell.org/haskellwiki/OpenGLTutorial2 but all the links in this tutorial are dead.
09:02:34 <byorgey> Aune: perhaps http://www.haskell.org/pipermail/haskell-cafe/2011-March/090517.html  http://hackage.haskell.org/package/nehe-tuts  ?
09:02:39 <tgeeky> pasting this here for posterity... just questions about what is going on here: http://hpaste.org/47333/foldl_state_machine
09:03:25 <mbernstein> Can I ask a rather silly question that I can't seem to find the answer to?  It's probably fairly trivial, but yeah
09:03:42 <tgeeky> mbernstein: no question is trivial if the answer causes learning
09:03:47 <mbernstein> okay, thanks
09:03:52 <mbernstein> I understand that in the type signature for max :: Ord a => a -> a -> a
09:04:09 <mbernstein> -> denotes returning a function and it gets partially applied and then you apply it to the next, etc - but what does the => denote?
09:04:18 <Aune> byorgey, will take a look, thanks.
09:04:45 <mbernstein> I realize a -> a -> a    also is (( a -> a) -> a), but the => isn't apparent to me
09:05:10 <mbernstein> Is it some sort of constraint?
09:05:12 <tgeeky> mbernstein: it's the "context" in which the thing on the right side of => makes sense, for "max"
09:05:16 <tgeeky> mbernstein: exactly
09:05:51 <mbernstein> tgeeky: tyvm, I'll have to think on that a bit then :)
09:05:56 <byorgey> mbernstein: actually, a -> a -> a  is (a -> (a -> a))
09:05:57 <tgeeky> mbernstein: it's saying: "For 'max', this is only true of 'a' exhibits 'Ord'"
09:06:20 <mbernstein> byorgey: yeah you are correct, I just realized that after writing it
09:06:40 <mbernstein> byorgey: Still getting used to the idea that it's just a bunch of partially applied functions.  It's fairly interesting, though
09:06:44 <byorgey> mbernstein: ok, from the other things you said it does seem like you understand it =)
09:07:19 <tgeeky> byorgey: for complete detail, check Chapter 4 of Haskell 2010 report: http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-620004
09:07:30 <tgeeky> notice the [context =>] parts
09:08:02 <mbernstein> tgeeky: Ah, so the type has to be part of Ord basically in order it to be a valid call, gotcha.  Not sure the actual nomenclature since it's not really an inheritance sort of deal as in traditional oop, but I get the idea I think
09:08:06 <tgeeky> mbernstein: then, check out 4.1.4
09:08:18 <mbernstein> tgeeky: checking now
09:08:52 <tgeeky> mbernstein: I used to think about OOP things years ago when I got my degree, but I don't have it ingrained any more
09:08:56 <iwtu> Hello. I know how to define fold funcion fold list but I don't how to define a fold funcion for binary tree. Let suppose I the data type is data Bt a = Nil | Node a (Bt a) (Bt a). can you give me some hint? thanks
09:09:40 <iwtu> this is clear : fold f a Nil = a
09:10:18 <mbernstein> Well I appreciate it.  I've been going through LYAHFGG, but some things that I tend to think are massively important end up being only a short paragraph that I end up having to go back and locate since it cascades throughout things >.<
09:10:21 <tgeeky> mbernstein: if you, in GHCI, type :info Ord
09:10:35 <tgeeky> you will see "class Eq a => Ord a where ..."
09:10:52 <tgeeky> which means everything that's Ord sits in a deeper context itself (Eq)
09:11:15 <tgeeky> and you will see the a log list of things which "fulfill" the Ord context
09:11:36 <tgeeky> instance Ord Ordering, instance Ord Integer, instance Ord Float, instance Ord Double, ...
09:12:01 <mbernstein> tgeeky: Yeah, a lot of the base types sit in there I see (for good reason).
09:12:09 <mbernstein> that is quite useful, thanks
09:12:13 <tgeeky> mbernstein: yes, and you can deduce that they must all be in Eq as well
09:12:17 <tgeeky> (and check that fact)
09:12:42 <mbernstein> tgeeky: The learning curve of haskell is steep so far, but I feel somewhat liberated thought wise :)
09:12:46 <tgeeky> mbernstein: but you can build up more complex contexts, involving more types
09:13:06 <tgeeky> mbernstein: I advocate treating it like a playground. You can be rather sure you're not going to break anything, so go wild.
09:14:23 <iwtu> but .. fold f z (Node a left right) = f z (fold f a left) and.. what about right?
09:15:39 <byorgey> iwtu: the idea is to replace every occurrence of Node by 'f' and every occurrence of Nil by 'a'
09:16:02 <tgeeky> byorgey: that's probably similar to the answer to my question, :o
09:16:04 <tgeeky> lol
09:16:16 <byorgey> iwtu: so since Node has the type  a -> (Bt a) -> (Bt a) -> Bt a,  f must have the type   a -> b -> b -> b
09:16:46 <byorgey> so fold f z (Node a left right) = f a (fold f z left) (fold f z right)
09:17:17 <iwtu> byorgey: I think that f is a binary funcion, isn't?
09:17:33 <byorgey> iwtu: not if you are writing a fold for Bt.
09:18:10 <byorgey> iwtu: unless you are thinking of 'foldr' from the Foldable class?
09:18:30 <byorgey> that is slightly different, it is basically flattening the tree into a list first and then doing a fold over that
09:18:31 <iwtu> byorgey: no no. it's just a general task
09:18:33 <tgeeky> byorgey: should one always ask "which direction" when folding?
09:18:44 <tgeeky> byorgey: I'm still a little hazy about right/left folds
09:18:56 <byorgey> iwtu: ok, then forget what I said about Foldable
09:19:05 <iwtu> done :)
09:19:19 <byorgey> iwtu: a 'fold' for a datatype will take one argument for each constructor
09:19:27 <tgeeky> byorgey: then foldr can never be used on a [ .. ], since you can't flatten it...
09:19:29 <byorgey> and each argument will be a function of the same arity as the constructor
09:19:55 <iwtu> byorgey: I not cleary understand
09:20:02 <byorgey> so in the case of fold for Bt it takes a constant (z) corresponding to Nil, and a 3-argument function (f) corresponding to Node
09:21:00 <byorgey> fold f z (Node a (Node b Nil Nil) (Node d Nil Nil)) = f a (f b z z) (f d z z)
09:21:36 <iwtu> byorgey: fold f z (Node a left right) = f a (fold f (fold f a right) left) ?
09:21:44 <sm> what's the best way to implement the old unknownArgs in latest cmdargs ? ie, to capture --unrecognised --options
09:22:08 <byorgey> iwtu: no
09:22:45 <iwtu> byorgey: it isn't not good? on all nodes execute f
09:23:09 <byorgey> iwtu: fold f z (Node a left right) = f a (fold f z left) (fold f z right)
09:23:36 <tgeeky> sm: how was it done?
09:24:21 <sm> tgeeky: it was like this: http://hackage.haskell.org/packages/archive/cmdargs/0.1/doc/html/System-Console-CmdArgs.html#v:unknownFlags
09:24:50 <iwtu> byorgey: this it is clear. It is ok if it is fold on binary tree. I wanted make fold like on list but on binary three
09:25:53 <byorgey> iwtu: ok. In that case I suggest: (1) implement a generic fold for binary trees like I was talking about (2) implement  flatten :: Bt a -> [a]  in terms of this generic fold (3) compose with list fold.
09:25:55 <iwtu> so thank you for telling me what the fold should do over binary tree :)
09:26:21 <tgeeky> sm: maybe CmdArgs.Annotate with Missing?
09:27:04 <sm> tgeeky: thanks, I'll check that out
09:27:29 <iwtu> byorgey: yeah, it would be much more easier make list and than fold...
09:28:22 <tgeeky> sm: also the modeArgs in data Mode a ( http://hackage.haskell.org/packages/archive/cmdargs/0.7/doc/html/System-Console-CmdArgs-Explicit.html#v:modeArgs )
09:28:35 <tgeeky> sm: ignore that last one
09:28:54 <iwtu> byorgey: I am really new on irc. If I have some problem can I try to ask for advise here? Is it very rude?
09:29:07 <tgeeky> iwtu: no, it's appropriate
09:29:58 <raichoo> iwtu: #haskell is known to be one of the friendliest channels around ;)
09:31:38 <iwtu> so thanks for all the kindness :) I am quite supprised I can write in English in order to solve the problem. Thanks guys :)
09:31:56 <iwtu> raichoo: I like #archlinux too :)
09:32:38 <byorgey> iwtu: it is not only rude, it is encouraged =)
09:32:46 <byorgey> er, not only *not* rude I meant =)
09:32:54 <raichoo> iwtu: I prefer #openindiana ^^ I'm more a solaris guy :) But this is getting off-topic :)
09:33:19 <byorgey> tgeeky: and now to address your question
09:33:24 <byorgey> tgeeky: every algebraic data type has a generic fold which works by replacing its constructors with combining functions.  For this sort of fold it does not make sense to talk about "right" versus "left".
09:34:03 <byorgey> tgeeky: however, there is another kind of folding which essentially boils down to flattening to a list and then folding
09:34:43 <byorgey> tgeeky: another way to think about it is that you inject all the elements into some monoid and then combine
09:34:47 <iwtu> byorgey: hope not too much encouraged :)
09:35:01 <byorgey> which is the same thing since lists are the free monoid
09:36:01 <byorgey> if it IS actually a monoid -- that is, the combining binary operation is associative and the base case is the identity for the combining operation -- then it doesn't matter whether you fold left or right, they are equivalent.
09:36:03 <tgeeky> byorgey: that first kind of fold sounds like in-place flattening?
09:36:19 <byorgey> tgeeky: it's not flattening at all.
09:36:26 <tgeeky> a combining function
09:36:32 <tgeeky> is there another name for that?
09:36:43 <byorgey> tgeeky: with flattening you have to choose a specific ordering for all the data elements
09:36:58 <byorgey> tgeeky: a generic fold does not necessarily force you to choose such an ordering
09:37:16 <byorgey> for example imagine a tree where each node contains a Set of child subtrees
09:37:46 <byorgey> you could not flatten it without making an arbitrary choice for the order of the children, but you could still fold over it
09:38:55 <tgeeky> so you could have a family of combining functions which have different orderings, and fold over it in different ways?
09:39:47 <tgeeky> that is, the combining functions determine (perhaps indeterminately) the resulting ordering?
09:40:06 <byorgey> no
09:40:07 <tgeeky> that makes less sense after reading it. :/
09:40:10 <tgeeky> lol
09:40:40 <rudyl313> is it possible to make a parameterized type an instance of the Show typeclass?
09:40:59 <notyy> when I run cabal install yesod  ,it reports:Codec.Compression.Zlib:premature end of compressed stream, what's wrong?
09:41:17 <byorgey> rudyl313: yes. perhaps you want something like   instance Show a => Show (MyParameterizedType a) where ... ?
09:41:36 <tgeeky> byorgey: stop responding to my nonsense, back to work with you!
09:41:41 <rudyl313> byorgey: ahhh, I was missing the "Show a => " part :)
09:41:43 <byorgey> tgeeky: hehe, ok =)
09:42:01 <tgeeky> byorgey: key thing: Foldable corresponds to "right" folds, in general?
09:42:20 <tgeeky> since it says the minimum implementation defines foldr
09:42:32 <edwardk_> tgeeky: you can find foldl as well
09:42:45 <edwardk_> foldl is defined in terms of foldr/foldMap if you don't though
09:42:55 <byorgey> tgeeky: no, Foldable corresponds to "monoidal folds" for which foldr and foldl are supposed to be equivalent
09:43:17 <edwardk_> byorgey: foldMap does. foldr and foldl are both directional
09:44:21 <byorgey> edwardk_: ah, yes, you're right
09:44:22 <mightybyte> Anyone know if there's a library that allows enumerators/iteratees to read Data.Binary data?
09:44:32 <byorgey> anyway, the point is that Foldable gives no special preference to foldr
09:44:50 <tgeeky> edwardk_: s/if you don't though/??/, thanks
09:45:25 <edwardk_> tgeeky: if you don't definite it. i was continuing my previous statement
09:45:56 <tgeeky> edwardk_: ok
09:46:03 <rudyl313> byorgey: is there anyway to make only a specific instance of my type showable (but not other instances)... ie. instance Show (MyParameterizedType Int) where ...
09:46:40 <edwardk_> rudyl313: sure, just write that. you'll probably have to turn on an extension or two
09:47:03 <rudyl313> edwardk_: not sure what that means (turning on an extension)
09:47:21 <byorgey> tgeeky: Foldable corresponds to "data types which can be flattened into a list of elements".  And once you have a list of elements you can of course do foldr or foldl depending on which way you want to associate the combining.
09:47:25 <edwardk_> You'll probably need to put {-# LANGUAGE FlexibleInstances #-} at the top of the file
09:47:38 <rudyl313> edwardk_: ah ok cool thanks
09:48:00 <edwardk_> rudyl313: you can do it without that extension but it is pretty tedious to do
09:48:37 <rudyl313> edwardk_: is it generally considered bad to use extensions like that? since its not techically following the haskell standard?
09:49:01 <tgeeky> rudyl313: no, all the cool kids do it
09:49:19 <tgeeky> rudyl313: the extensions are made to be used
09:49:28 <rudyl313> tgeeky: k cool
09:49:42 <edwardk_> (todo it without flexible instances you'd need to define something like      class ShowMyType a where showsPrecMyType :: Int -> MyType a -> ShowS     ; instance ShowMyType Int where ...;   then you define instance ShowMyType a => Show (MyType a) where showsPrec = showsPrecMyType
09:49:48 <edwardk_> you can see how it is much uglier
09:49:56 <tgeeky> rudyl313: main caveat: if you are writing a library or module, using an extension changes your "portable?" field to "no, uses extensions"
09:50:08 <edwardk_> rudyl313: in this case, nobody will complain. FlexibleInstances are about as uncontroversial as extensions come
09:50:14 <tgeeky> rudyl313: in terms of your .cabal file
09:50:45 <edwardk_> you need to use it to define any instances for [Char] or String (which also requires TypeSynonymInstances) for instance.
09:51:23 <rudyl313> edwardk_: tgeeky: thanks for the feedback guys :)
09:51:52 <edwardk_> anyways you have both solutions now. feel free to implement whichever makes you happier =)
09:51:59 <rudyl313> edwardk_: yeah I don't even understand that other implementation that doesn't use extensions :P
09:52:12 <tgeeky> edwardk_: and byorgey: thanks for *your* help, as usual
09:52:25 <rudyl313> edwardk: so I think I'll just use the extension haha
09:53:07 <tgeeky> rudyl313: by "all the cool kids use it", I mean, "I have noticed that pretty much any interesting package on hackage has a "portable?" line "no, uses extensions (...)"
09:53:09 <edwardk_> rudyl313: what i did was made up a class for some type a that just provided the ability to show 'MyType a'  -- feel free to replace the definition showsPrecMyType with showMyType :: MyType a -> String
09:54:15 <edwardk_> rudyl313: the FlexibleInstances extension allows instance heads (MyParameterizedType Int) to not have to be of the form (TypeConstructor a b c)
09:54:16 <rudyl313> tgeeky: ok cool, I feel better about using it now ;)
09:54:53 <rudyl313> edwardk_: ok cool
09:55:00 <edwardk_> rudyl313: in the 'non-extension version' i had to make up a class i could constrain 'a', to get ShowMyType a => Show (MyParameterizedType a) -- putting the head in the right form
09:55:15 <edwardk_> er that i could use to constrain
09:55:22 <rudyl313> edwardk_: gotcha
09:57:24 <dcoutts> notyy: most likely the download failed
10:02:37 <notyy> dcoutts: I don't know. I can install other package
10:02:55 <notyy> dcoutts: just installed time
10:03:20 <dcoutts> notyy: see if the local cached .tar.gz is 0 size or something like that
10:03:42 <dcoutts> see if removing it and fetching again works
10:08:18 <notyy> dcountts:I am newbie, where is this cached .tar.gz file?
10:09:51 <Jafet> Most likely in .cabal/packages/
10:10:38 <dcoutts> yes, under ~/.cabal/packages/hackage.haskell.org/yesod/
10:10:53 <dcoutts> notyy: or whatever $pkgname it was you were having trouble with
10:11:45 * hackagebot configurator 0.0.0.1 - Configuration management  http://hackage.haskell.org/package/configurator-0.0.0.1 (BryanOSullivan)
10:12:25 <notyy> ah,I find all packages, but no yesod,which I am trying to install
10:13:45 * hackagebot yices 0.0.0.10 - Haskell programming interface to Yices SMT solver  http://hackage.haskell.org/package/yices-0.0.0.10 (KiYungAhn)
10:15:40 <tgeeky> bos: in case you didn't see, the "configuration file" format is dead
10:16:04 <sm> am I right in thinking executables depending on libraries in the same package is not really robust yet ?
10:16:49 <thoughtpolice> sm: it should work, it's just rarely used
10:17:13 <thoughtpolice> (i believe all you have to do is tell cabal that the hs-source-dirs for the library and executable are one and the same, and it'll "do the rest")
10:17:48 <dcoutts> thoughtpolice: no, the hs-source-dirs have to be different
10:17:54 <dcoutts> otherwise it's pointless
10:18:13 <dcoutts> as local source files are always used in preference to modules from packages
10:18:31 <dcoutts> sm: it works apart from haddocking
10:19:36 <sm> I read about the haddock problem but thought I'd try it anyway. Am I doing it wrong in http://joyful.com/repos/hledger/hledger/hledger.cabal ? For me, it still builds everything twice, and another dev gets this error: http://pastie.org/1998404
10:19:48 <Jafet> How do I ask cabal-install to ask haddock to make links to formatted source code?
10:20:11 <sm> sounds like I need to set a source dir
10:20:12 <dcoutts> Jafet: it's a flag to cabal haddock, see cabal haddock --help
10:20:20 * sm will try
10:20:39 <Jafet> I see
10:21:03 <dcoutts> sm: yes, the exe has to have a separate src dir
10:21:06 <Jafet> Hmm, can I do this without reinstalling libs
10:21:13 <dcoutts> sadly not
10:21:21 <sm> thanks!
10:22:00 <sm> just for reference, do we know of any package that currently does this right ?
10:24:09 <Jafet> Bah, doesn't seem to be a way to get packages in a topological order
10:24:26 <Jafet> ghc-pkg dot produces... trippy output
10:25:09 <dcoutts> sm: leksah (though it has a curious pre-6.12.3 hack)
10:26:35 <sm> great
10:28:00 <bos> tgeeky: ?
10:29:48 * hackagebot ListTree 0.2.1 - Trees and monadic trees expressed as monadic lists where the underlying monad is a list  http://hackage.haskell.org/package/ListTree-0.2.1 (YairChuchem)
10:30:18 <tgeeky> bos: http://hackage.haskell.org/packages/archive/configurator/latest/doc/html/Data-Configurator.html
10:30:26 <tgeeky> http://hackage.haskell.org/package/configurator-0.0.0.1
10:30:50 <bos> tgeeky: ah - thanks
10:30:54 <tgeeky> bos: yep
10:31:49 * hackagebot List 0.4.2 - List monad transformer and class  http://hackage.haskell.org/package/List-0.4.2 (YairChuchem)
10:36:04 <Jafet> Hm, I think I can regenerate the documentation with a shell script
10:38:52 * hackagebot accentuateus 0.9.2 - A Haskell implementation of the Accentuate.us API.  http://hackage.haskell.org/package/accentuateus-0.9.2 (MichaelSchade)
10:40:53 * hackagebot text 0.11.1.0 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.1.0 (BryanOSullivan)
10:45:59 <copumpkin> @remember xplat nae, that'd be 'arr, my small example ain't half near as yellow as a lily-livered spaniard!  scupper me wi' a cutlass, arr.'
10:45:59 <lambdabot> I will never forget.
10:49:52 <tgeeky> i'm convinced that that could only be deciphered by a *genuine* pirate... wel done
10:50:55 <tgeeky> byorgey: update on my pastie... what I'm really looking for is a walkthrough to the steps on the left side of (page 8)
10:51:01 <tgeeky> of this this paper
10:51:04 <tgeeky> but still, later
10:51:28 <notyy> muhahah,success, thank you all.
10:52:53 <tromp> @let p=Memo.integral q where q 0=1; q 1=0; q n=1+avg[p j + p (i-2-j) | j<-[0..i-2]]
10:52:54 <lambdabot>  <local>:2:44: Not in scope: `avg'
10:52:54 <lambdabot>  
10:52:54 <lambdabot>  <local>:2:48:
10:52:54 <lambdabot>      Ambiguous occurrence...
10:53:33 <tromp> @let p=Memo.integral q where q 0=1; q 1=0; q n=1+sum[p j + p (n-2-j) | j<-[0..n-2]] / (n-1)
10:53:34 <lambdabot>  <local>:2:48:
10:53:34 <lambdabot>      Ambiguous occurrence `p'
10:53:34 <lambdabot>      It could refer to either `L...
10:54:08 <tromp> @let cars=Memo.integral q where q 0=1; q 1=0; q n=1+sum[cars j + cars (n-2-j) | j<-[0..n-2]] / (n-1)
10:54:10 <lambdabot>  Defined.
10:54:27 <tromp> > map cars [0..10]
10:54:28 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:54:28 <lambdabot>    `GHC.Real.Fractional a'
10:54:28 <lambdabot> ...
10:54:44 <tromp> > map cars [0..10] :: Rational
10:54:45 <lambdabot>   Couldn't match expected type `GHC.Real.Rational'
10:54:45 <lambdabot>         against inferred t...
10:55:04 <tromp> > map cars [0..10] :: Double
10:55:05 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
10:55:05 <lambdabot>         against inferred ty...
10:56:25 <sm> notyy: great, what was it ?
10:58:15 <notyy> sm: a dependent package is not fully downloaded
10:58:42 <notyy> sha-1.4.1.3, I delete it and run cabal install again
11:08:19 <cobb>  /quit
11:14:02 <rudyl313> is it possible to override the behavior of the show method on a type such as Rational?
11:15:17 * hackagebot mysql-simple 0.2.2.1 - A mid-level MySQL client library.  http://hackage.haskell.org/package/mysql-simple-0.2.2.1 (BryanOSullivan)
11:16:00 <dafis> rudyl313: with a newtype
11:16:27 <rudyl313> dafis: interesting ... I'll have to look into that
11:17:42 <dafis> rudyl313: the nice thing is, with GHC's GeneralizedNewtypeDeriving, you can derive almost everything you want to have unchanged and only write custom Show or whatever instances
11:18:36 <rudyl313> dafis: oh nice
11:21:09 <dafis> heja tibbe
11:22:05 <tibbe> dafis: yo
11:22:43 <shapr> hoi tromp! How's code?
11:23:09 <dafis> rats, openSuSE doesn't have the matching debuginfo packages, so I don't get more out of gdb
11:23:29 <tromp> hi, Shae! i'm busy solving June Ponder This
11:24:06 <shapr> Oh, never seen those puzzles before.
11:24:15 <tromp> http://domino.research.ibm.com/Comm/wwwr_ponder.nsf/Challenges/June2011.html
11:24:50 <shapr> tromp: Yah, I just found 'em. Too bad they don't have any IBM BladeCenter trivia...
11:25:05 <tibbe> dafis: :/
11:25:10 <tibbe> dafis: food eating time!
11:25:22 * hackagebot mysql-simple 0.2.2.2 - A mid-level MySQL client library.  http://hackage.haskell.org/package/mysql-simple-0.2.2.2 (BryanOSullivan)
11:25:25 <dafis> tibbe: I have just eaten
11:25:56 <tibbe> :)
11:26:14 <dafis> didn't give me new ideas, though
11:26:14 <tibbe> bos: you're adding features quickly ;)
11:26:27 <tibbe> bos: 10 mins betweens releases
11:26:31 * tibbe eats food
11:26:46 <bos> tibbe: yeah, i screwed up!
11:27:08 <dafis> that's what I call a quick fix, then
11:27:22 <dafis> before the first bug report
12:03:10 <chrisdone> bos: Ping!
12:03:28 <tgeeky> error! error!
12:04:19 <eiqerdsag> hi, girls
12:05:00 * chrisdone waves a hanky at eiqerdsag
12:05:29 <ptek> Dear Haskellers, I am pretty new to this great language and I am looking for a function to calculate differences between numbers in an array.
12:05:33 <ptek> For example f [2,4,7,12] should produce [(4-2),(7-4),(12-7)] => [2,3,5]
12:05:54 <ptek> Does anyone know by a chance if there exists something like that per default?
12:06:13 <monochrom> > zipWith (-) (tail [2,4,7,12]) [2,4,7,12]
12:06:14 <ptek> I mean in some library?
12:06:14 <lambdabot>   [2,3,5]
12:06:21 <tgeeky> chrisdone: I do declare
12:06:59 <ptek> wow! Thank You!
12:07:08 <tgeeky> ptek: how about THEM apples, as Matt Damon would say
12:11:19 <chrisdone> bos: I was wondering why you have two separate classes for SQL conversion (Param and Result) rather than one bidirectional class, but thinking about it, it sounds like a good idea. I found that with the JSON library I have quite a few types that are only one-way, in or out, and for readJSON/showJSON I have to specify an error. I like the two class idea.
12:11:44 <ptek> tgeeky: sorry, never heard about Matt Damon :) what apples again?
12:12:18 <tgeeky> ptek: hehe. it's a silly quote (from a rather good movie)
12:12:38 <tgeeky> ptek: http://en.wikipedia.org/wiki/How_do_you_like_them_apples
12:12:56 <tgeeky> chrisdone: that's hard to do
12:13:12 <dolio> It's a pretty good line. Or was originally.
12:13:15 <ptek> tgeeky: hehe
12:13:36 <tgeeky> chrisdone: though I think this partial-isomorphisms paper which I'm just beginning to understand probably has something clever to say about that
12:14:25 <chrisdone> bos: It's a four-day weekend here and I'm finally getting round to hacking on pgsql. I'm considering just taking mysql-simple and replacing the mysql parts with pgsql for now. Any advice on how and where to credit you?
12:14:37 <chrisdone> tgeeky: What's hard to do?
12:14:52 <tgeeky> chrisdone: writing a bidirectional class that doesn't have caveats
12:14:58 <bmars> For a function to be considered pointfree, does it have to be written without any parameters?
12:15:36 <dolio> Yes, except point free isn't really a property of functions.
12:15:40 <dolio> It's a property of definitions.
12:16:18 <tgeeky> bmars: you can "see" what he's talking about when you look at many of the examples listed here http://www.haskell.org/haskellwiki/Pointfree
12:16:29 <bmars> we couldn't consider a function to be pointfree?
12:16:38 <monochrom> some people equate functions with definitions
12:17:06 <tgeeky> bmars: you can write a function, and then change the definition to be pointfree. Or you can write a pointfree definition, and recover the original function.
12:17:12 <chrisdone> tgeeky: Well the problem is the bidirectionality in itself. Sometimes I don't want bidirectionality. Like outputting built-in objects in a JSON service. I'm never going to read new built-in objects in so it's a JSON instance but only one way.
12:17:22 <bmars> i'm currently reading the wiki article and the programming with arrows paper and he gives examples of "pointfree" functions with parameters
12:17:34 <b0fh_ua> Hello! I have 2 lists: a=[1,1,1,1] and b=[1,0,0,0]. I want to get list c=[1,2,3,4] which is drawn from (tail a) and items starting from second are drawn like previous item from b plus current item from a.
12:17:46 <b0fh_ua> How can I do that using list comprehension for example?
12:17:47 <tgeeky> chrisdone: yeah. PM me to discuss it a little more, and I'll try not to confuse you
12:17:54 <tgeeky> but there's a clever example
12:18:17 <tgeeky> that explains the utility of such a bidirectionl mapping (and the pitfalls)
12:19:28 <dolio> k = h . g . f  is a point free definition. k x = h (g (f x)) is not a point free definition. But they both define the same function.
12:20:13 <tgeeky> > (k = h . g .f) == (k x = h (g (f x))
12:20:13 <lambdabot>   <no location info>: parse error on input `='
12:20:17 <tgeeky> figured
12:20:43 <tgeeky> > (h . g .f) == (\x -> h (g (f x))
12:20:43 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:20:54 <chrisdone> :t h . g . f
12:20:54 <lambdabot>     Ambiguous type variable `a' in the constraints:
12:20:54 <lambdabot>       `Show a' arising from a use of `h' at <interactive>:1:0
12:20:54 <lambdabot>       `SimpleReflect.FromExpr a'
12:21:27 <chrisdone> Worth a try.
12:21:30 <bmars> dolio: the first example given is count w = length . filter (==w) . words and "This is an example of "pointfree" programming style."  It's somewhat confusing.
12:22:18 <chrisdone> Ah, that is point-free. But it uses the `w' as a formal parameter because making that point-free too would be less readable.
12:22:34 <chrisdone> @pl \w -> length . filter (==w) . words
12:22:34 <lambdabot> (length .) . (. words) . filter . (==)
12:22:49 <chrisdone> Ew. :-)
12:22:54 <tgeeky> length (boobs) words
12:22:55 <tgeeky> lol
12:23:14 <noteventime> What's the connection between point-free style and formal/pointless topology btw?
12:23:16 <ion> (.:) = (.)(.)(.)  -- Total Recall
12:23:18 <tgeeky> chrisdone: anyway, the example that comes up in this paper I'm reading is that of serialization/deserialization
12:23:23 <dolio> Yes, often you get better results by only eliminating some of the points.
12:23:37 <tgeeky> chrisdone: and the connection to [parsing] and [printing]
12:24:19 <tgeeky> chrisdone: one can view serialization as [printing] -> ["native format"], and deserialization as ["native format"] -> [parsing]
12:25:02 <tgeeky> chrisdone: which is fine, and acceptable, if one wishes to, and if one has an appropriate specification for ["native format"], then you can simply write:
12:25:13 <tgeeky> chrisdone: [parser] <-> [printer]
12:25:18 <tgeeky> chrisdone: and be done with it
12:25:59 <shapr> chrisdone++ # for years of awesomeness
12:26:02 <shapr> @karma chrisdone
12:26:02 <lambdabot> chrisdone has a karma of 3
12:26:11 <dolio> @karma
12:26:12 <lambdabot> You have a karma of 9
12:26:16 <shapr> @karma
12:26:16 <tgeeky> @karma
12:26:16 <lambdabot> You have a karma of 0
12:26:16 <lambdabot> You have a karma of 9
12:26:19 <tgeeky> fail
12:26:19 <dolio> Wow, that's higher than expected.
12:26:26 <shapr> dolio: you must be awesome
12:26:31 <dolio> @karma dons
12:26:31 <lambdabot> dons has a karma of 14
12:26:40 <tgeeky> dolio-- # for being surprised by his own awesomeness
12:26:50 <tgeeky> @unkarma dolio-- # for being surprised by his own awesomeness
12:26:50 <lambdabot> dolio-- has a karma of 0
12:27:00 <tgeeky> wait a second
12:27:04 <dolio> I remember back when dons had about 10 times that.
12:27:16 <tgeeky> chrisdone: that make any sense?
12:27:16 <monochrom> then lambdabot crashed
12:27:17 * chrisdone makes shapr a cup of hot chocolate o//
12:27:32 <chrisdone> tgeeky: I understand.
12:29:01 <tgeeky> chrisdone: JSON, I think, could actually be done this way. I'll find out soon enough.
12:29:24 <dolio> Printing and parsing is more like a Galois connection.
12:29:30 <dolio> Than an isomorphism.
12:29:58 <noteventime> An adjunction then?
12:30:09 <dolio> Right.
12:30:37 <noteventime> That's pretty interesting, I've never thought of it like that
12:30:38 <tgeeky> dolio: I *think* this paper is arguing that you can get a stronger connection
12:30:48 <tgeeky> dolio: with pprinting, even.
12:31:11 <edwardk_> noteventtime: exactly
12:31:36 <tgeeky> dolio: I guess a 'partial isomorphism' is, by definition, an adjunction.
12:31:43 <edwardk_> an adjunction is a more useful relation that isomorphism. you don't want to have to retain every useless pair of parentheses for most applications.
12:32:23 <bos> chrisdone: i think that's a cool idea. i don't care about credit right now.
12:32:26 <tgeeky> edwardk_: I don't think one can say something that general
12:32:31 <edwardk_> every space, every comment, in the original would have to be retained. this is useful for refactoring browsers where that stuff is significant, but its quite the burden for the representation.
12:32:39 <tgeeky> edwardk_: ah, no, not true there
12:33:15 <tgeeky> Eduard_Munteanu: if you use a partial isomorphism, then you specify the treatment of Sets and [Multisets <-> Set] seperately
12:33:16 <edwardk_> an isomorphism is stronger than an adjunction, but there are a lot more adjunctions than there are isomorphisms. ;)
12:33:20 <chrisdone> bos: Ok. Are you coming to CamHac? :-)
12:33:31 <tgeeky> Eduard_Munteanu: sry
12:33:40 <bos> chrisdone: nope, way too far away :-(
12:34:00 <tgeeky> edwardk_: yes, but one can think less about an isomorphism :O
12:34:08 <dolio> What's a partial isomorphism? Is that like a retract situation?
12:34:32 <chrisdone> Ah, okay.
12:34:35 <edwardk_> tgeeky: when i wrote that i meant in the domain of parsing and pretty printing
12:34:38 <tgeeky> dolio: yeah, an set of isomorphisms (some) of which could be multisets
12:35:00 <tgeeky> edwardk_: yes, and this paper suggests (and supposedly demonstrates) that you can get away with a better treatment
12:35:35 <tgeeky> edwardk_: the parser has a set of rules about whitespace, and the printer has a multiset of rules about whitespace (and comments)
12:36:23 <tgeeky> edwardk_: so what is ' ' to the abstract syntax, is: ' ', '  ', '   ', '{- comment -}', to the conrecete syntax
12:38:25 <NemesisD> is there a standard way to implement ordering precedence for use in ord? i know records are automatically sorted by their fields in the order in which they are defined but i'd like more control than that
12:38:26 <noteventime> I'm probably missing something, but it sounds kinda like they're defining the morphisms in such a way that an isomorphisms defines an equivalence relation agreeing with the closure operation of the adjunction (i.e. print composed with parse)
12:38:49 <noteventime> Err, that came out rather more convoluted than I was hoping for
12:38:52 <mauke> NemesisD: write your own Ord instance
12:40:26 <NemesisD> mauke: hmm yeah, i was trying to figure out a clever way to do that other than a bunch of case statements. i see that ordering is an instance of a lot of interesting classes, maybe one will help with that
12:40:53 <edwardk_> i'm somewhat underimpressed by the paper. i find the adjunction between parsing and pretty printing to be a nicer description, because then i can know given pretty -| parse that pretty . parse is a monad and that parse, yielding stuff like    pretty . parse . pretty . parse = pretty . parse.
12:40:55 <mauke> > EQ ++ LT
12:40:59 <lambdabot>   mueval-core: Time limit exceeded
12:41:02 <mauke> > EQ ++ LT
12:41:02 <edwardk_> A genuine isomorphism also gives me that
12:41:04 <lambdabot>   LT
12:41:52 * hackagebot temporal-music-notation 0.1.6 - music notation  http://hackage.haskell.org/package/temporal-music-notation-0.1.6 (AntonKholomiov)
12:41:54 * hackagebot temporal-music-notation-western 0.1.6 - western music notation  http://hackage.haskell.org/package/temporal-music-notation-western-0.1.6 (AntonKholomiov)
12:42:14 <edwardk_> i need to actually work through the proof for the partial isomorphisms, which appear to just be isomorphisms in the kleisli category of Maybe.
12:43:52 * hackagebot attoparsec 0.9.0.0 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.9.0.0 (BryanOSullivan)
12:43:54 * hackagebot temporal-music-notation-demo 0.1.6 - generates midi from score notation.  http://hackage.haskell.org/package/temporal-music-notation-demo-0.1.6 (AntonKholomiov)
12:43:56 * hackagebot aeson 0.3.2.7 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.3.2.7 (BryanOSullivan)
12:44:52 * hackagebot tagsoup 0.12.1 - Parsing and extracting information from (possibly malformed) HTML/XML documents  http://hackage.haskell.org/package/tagsoup-0.12.1 (NeilMitchell)
12:45:16 <byorgey> edwardk_: I forget, do adjunctions compose?
12:45:22 <noteventime> yay, tagsoup saved my statistics course :p
12:45:24 <edwardk_> byorgey: yes
12:45:27 <byorgey> ok.
12:45:41 <edwardk_> it is one of my favorite uses of string diagrams to show how ;)
12:46:07 <dafis> noteventime: how that?
12:46:13 <byorgey> edwardk_: I would love to see it =)
12:46:30 <edwardk_> have you seen the string diagram talk by the catsters?
12:47:19 <noteventime> dafis: I used it for automated access to a web interface for a statistics database
12:47:39 <dafis> cheating?
12:47:45 <byorgey> edwardk_: no, should I?
12:47:45 <noteventime> No, just data mining
12:47:50 <edwardk_> for the category theory class here at work, i went through that material, and then did two additional proofs using them. that you can 'sandwich an adjunction' in a monad (by outlining it with the adjunction), and that you can compose adjunctions.
12:47:59 <noteventime> dafis: The alternative would have been to manually enter all the data
12:48:19 <dafis> noteventime: I see
12:48:28 <edwardk_> it is pretty short and i think really highlights the way that adjunctions give rise to monads.
12:48:48 <noteventime> Hmm, I haven't watched the string diagram videos yet
12:49:27 <edwardk_> http://www.youtube.com/user/TheCatsters#g/c/50ABC4792BD0A086
12:49:45 <dolio> The string diagrams are pretty cute for seeing it.
12:49:46 <Guest97052> so guys where is haskell primarily used
12:50:02 <edwardk_> dolio teases me about my string diagrams
12:50:04 <dolio> Although, in general, just having the types probably determines how they compose.
12:50:09 <edwardk_> yeah
12:50:25 <dolio> Unless you try sticking a left and a right adjoint together.
12:50:29 <dolio> But don't do that.
12:50:33 <edwardk_> they do, but i can rattle it off by sketching the string diagrams =)
12:51:14 <noteventime> Do string diagrams generalise to n-categories?
12:51:17 <edwardk_> with the diagram its obvious that the natural transformations are nested cups and nested caps
12:51:24 <noteventime> Or does the question not even make sense?
12:51:56 <edwardk_> noteventime: yes. they are just the poincare dual of a diagram involving categories, functors and natural transformations (or 0-, -1, and 2- cells)
12:52:14 <edwardk_> you can take the dual in higher dimensional spaces
12:52:28 <dolio> It'll get hairy pretty quick, though, as visual stuff with n-categories does.
12:52:32 <edwardk_> yeah
12:52:42 <edwardk_> i didn't say they were _useful_ that way. ;)
12:52:45 <noteventime> Which kinda defeats the point :p
12:53:15 <noteventime> Was just curious
12:54:03 <edwardk_> noteventime: well, in a 3 category, slices of your diagram would be a usual string diagram. in fact. in the catsters video, they start by doing the dual of a diagram with just categories and functors, no natural transformations, which makes it a 'slice' of a traditional string diagram.
12:54:40 <edwardk_> but beyond a 3-category it'd be kinda silly.
12:55:00 <Phyx-> "ghc.exe: Test\QuickCheck\All.hs:1:14-28: You can't use Template Haskell with a profiled compiler" <-- does anyone know why not?
12:56:17 <chrisdone> http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/template-haskell.html#id554964
12:56:32 <edwardk_> the main use for string diagrams is that in a monoidal category, braiding really looks like braiding, so in some sense you really are playing with strings.
12:56:47 <chrisdone> Phyx-: Might be vaguely helpful. ^
12:57:06 <chrisdone> (I've never personally dealt with the problem.)
12:59:32 <dolio> The Rosetta stone paper actually has some diagrams with tubes, as I recall.
12:59:43 <dolio> I don't remember how they come up.
13:00:01 <djahandarie> I like that paper
13:02:15 <edwardk_> hrmm. there should probably be some nice connection to trace diagrams. http://blog.sigfpe.com/2009/05/trace-diagrams-with-monads.html the cupcap -> identity rule looks like one of the laws for an adjunction, which isn't surprising since they are related to feynman diagrams.
13:04:59 * hackagebot attoparsec-enumerator 0.2.0.4 - Convert an Attoparsec parser into an iteratee  http://hackage.haskell.org/package/attoparsec-enumerator-0.2.0.4 (JohnMillikin)
13:06:01 <MHD> Are continuations more efficient?
13:06:09 <roconnor> sometimes
13:06:21 <MHD> I have a State/Writer hybrid.
13:06:32 <MHD> and the >>= gets a litte lcomplex.
13:06:37 <MHD> complex*
13:07:01 <MHD> Actually, it's an Error/State/Writer
13:07:08 <b0fh_ua> pascal = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1]
13:07:16 <b0fh_ua> can somebody please explain this?
13:07:52 <sipa> > iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1]
13:07:53 <dafis> b0fh_ua: do you know the Pascal triangle?
13:07:54 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
13:07:56 <MHD> b0fh_ua: look at the argument iterate is given
13:08:08 <b0fh_ua> dafis: yeah, I understand the concept
13:08:16 <MHD> b0fh_ua: [1]
13:08:19 <b0fh_ua> I don't understand lambda inside
13:08:34 <MHD> Do you know iterate?
13:08:39 <b0fh_ua> sure
13:08:51 <MHD> All right
13:08:56 <MHD> We start out with [1]
13:09:11 <MHD> then we add a zero to the beginnig like so [0, 1]
13:09:20 <MHD> and to the end like so [1, 0]
13:09:33 <dafis> b0fh_ua: we add a zero to the front of one copy, to the end of another copy, and add corresponding terms in the augmented row(s) to get the terms of the new row
13:09:33 <MHD> then we zipWith (+)
13:09:34 <b0fh_ua> yes, and use zipWith to get [1,1]
13:09:45 <MHD> then we do the same again
13:09:58 <MHD> [0, 1, 1] + [1, 1, 0] = [1,2,1]
13:10:08 <noteventime> Haha, that's pretty clever :)
13:10:11 <b0fh_ua> hold on here, really
13:10:13 <MHD> and voila, pascals triangle
13:10:41 <MHD> [1, 1] ++ [0] = [1, 1, 0]
13:10:52 <MHD> [0] ++ [1, 1] = [0, 1, 1]
13:10:57 <b0fh_ua> but the question is - how do we get result of previous iteration on current iteration?
13:11:06 <MHD> that's what iter does.
13:11:06 <mauke> that's what iterate does
13:11:07 <shapr> iterate
13:11:17 <shapr> :t iterate
13:11:19 <lambdabot> forall a. (a -> a) -> a -> [a]
13:11:21 <mauke> > iterate f x
13:11:22 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
13:11:34 <b0fh_ua> iterate :: (a -> a) -> a -> [a]
13:11:35 <MHD> iterate f x = [x, f x, f $ f x, f $ f $f x ...]
13:11:37 <dafis> b0fh_ua: we get it from the iteration before etc, until we reach the base case, which is supplied
13:11:38 <shapr> > iterate (+ 1) 0
13:11:39 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
13:12:08 <b0fh_ua> so it applies the same function to the result of previous one?
13:12:15 <shapr> right!
13:12:17 <b0fh_ua> damn, then I didn't understand iterate well
13:12:41 <MHD> heh
13:12:45 <MHD> Confused it with fix?
13:18:34 <roconnor> MHD: you can try slapping a codensity transformer on the top of your stack to see if get better preformance; though doing a continuation transformation of your entire monad might be more efficent still.
13:20:47 <MHD> roconnor: I'm not using transformers
13:21:00 <MHD> I like to hand code such small things
13:21:12 <roconnor> you can apply the codensity transformer to any monad.
13:21:12 <MHD> (It's liek 10 lines with type defs)
13:23:26 <MHD> roconnor: Codensity just made me go what the fuck. I am not that Category theory ninja yet.
13:24:20 <shapr> b0fh_ua: more questions?
13:24:24 <roconnor> it's just a name :)
13:25:56 <b0fh_ua> no, everythin is clean
13:26:00 <b0fh_ua> thanks a lot!
13:28:33 <roconnor> MHD: anyhow, if you are writing it by hand you might as well CPS transform it by hand too.
13:28:46 <MHD> roconnor: Yeah
13:28:57 <MHD> That's what I am doing
13:29:06 <MHD> Man i love Continuations
13:29:13 <edwardk_> roconnor: there is always monad-ran ;)
13:29:19 <roconnor> yes
13:29:50 <edwardk_> MHD: you can always try to import monad-ran and use type MyMonad = RanT (StateT s (ErrorT e (WriterT w)))
13:30:00 <edwardk_> MHD: or whatever the layering is
13:30:32 <MHD> It's more like ContT (ErrorT (StateT (WriterT)))
13:30:36 <edwardk_> RanT does the cps transformation by building up a tower of right kan extension transformers. effectively keeping you in continuation passing style.
13:30:37 <MHD> pr whatever
13:30:50 <pr_> :<
13:30:56 <MHD> edwardk_ What's a kan?
13:31:05 <edwardk_> a mathematician
13:31:11 <MHD> what the hell are all these mad types!
13:31:14 <MHD> hehehe
13:31:20 <edwardk_> hahaha
13:31:30 <noteventime> I'd have called it Kan-Fu
13:31:43 <edwardk_> basically monad-ran is a tower of cps'd-transformers that ensure that they only ever cps once.
13:31:45 <MHD> I'll just stick to monads. I have yet to even realise a purpose for which I need Arrows
13:32:13 <edwardk_> you basically work with code of the form newtype Ran f g a = Ran { runRan :: forall r. (a -> f r) -> g r } -- for various types f and g.
13:32:17 <MHD> Transformers don't tickle my fancy yet
13:32:29 <edwardk_> i build up transformers that I apply to f and g depending on the monads you want to compose
13:32:37 <MHD> Okay
13:33:20 <edwardk_> for instance cps'd State is Ran ((->) s) ((->) s)     which becomes forall r. (a -> s -> r) -> s -> r
13:33:54 <MHD> And cps'd Error State?
13:33:57 <edwardk_> and cps'd ReaderT of something I can convert to Ran f g is Ran f (ReaderT e g)
13:34:34 <edwardk_> because, say, ReaderT e (State s) would be    forall r. (a -> s -> r) -> e -> s -> r
13:34:43 <edwardk_> error is a bit tricky, but its in there. =)
13:35:05 <MHD> Cps'd Error State Writing, lol
13:35:37 <dolio> What he hasn't mentioned yet is this complicated system isn't really any better than using Codensity YourMonad. :)
13:35:59 <MHD> What does Codensity do?
13:36:18 <dolio> Codensity m a = forall r. (a -> m r) -> m r
13:36:39 <edwardk_> Given Ran f g     -- The ErrorT'd version of it would be Ran f (ErrorTH e f g) where newtype ErrorTH e f g o = ErrorTH { getErrorTH :: (e -> f o) -> g o }
13:36:49 <edwardk_> MHD: Codensity is just the special case of Ran where f = g
13:37:05 <MHD> Oh.
13:37:25 <pe> Is it me, or ghc also has the problem with optimization flags and extended precision in x87 processors ?
13:37:27 <MHD> I'm making a LLVM code generator with type cheking
13:37:27 <edwardk_> in general you can take any monad m, and look at Ran m m directly.
13:37:48 <edwardk_> (or Codensity m)
13:37:52 <edwardk_> and get a monad that way
13:38:37 <edwardk_> since Codensity m is a monad no matter what m is!, but if m is a monad you can use it as a monad transformer giving you lift.
13:38:44 <MHD> So what I have is newtype LLasm a = LL { unLL :: State -> Instructions -> (State -> Instructions -> a -> Result) -> (State -> String -> Result) -> Result }
13:38:47 <roconnor> edwardk_: CPS transformationa makes the monad stricter?
13:39:05 <edwardk_> roconnor: potentially. i never did pay any attention to strictness on these ;)
13:39:10 <roconnor> ok
13:39:12 <edwardk_> it definitely changes strictness on writer
13:39:38 <MHD> I' using a function composition list
13:39:49 <MHD> [String] -> [String]
13:39:58 <MHD> with (.) instead of (++)
13:40:07 <dolio> If you reassociate to the right, and you have infinite left-recursion, you have a problem. :)
13:40:08 <MHD> (a :) instead of [a]
13:40:38 <MHD> So basically (a :) . (b :) . (c :) $ []
13:40:45 <MHD> instead of [a, b ,c]
13:40:56 <MHD> Works wonders
13:41:01 <edwardk_> In fact the state monad above comes from the factthat (,) e -| (->) e, so you can exploit the way kan extensions and adjunctions interact to show Ran ((->) e) ((->)e) that its isomorphic to the composition of (->) e and (,) e.
13:41:26 <edwardk_> yeah, codensity in particular is going to fully re-associate to the right
13:41:50 <MHD> I' just going to leave Codensity and Ran to you guys until I start on CS uni
13:42:05 <MHD> I'm like in the equivalence of High School
13:42:05 <edwardk_> MHD: not a bad idea. just mentioning the latter for roconnor =)
13:43:01 <djahandarie> MHD, no, learn it now!
13:43:29 <MHD> djahandarie, I will when I have a use for it.
13:44:08 <djahandarie> Damn pragmatists.
13:44:08 <MHD> djahandarie: First I'm thinking Erlang, SML, Scala and FORTH
13:44:16 * djahandarie goes back to ##categorytheory
13:44:22 <MHD> Havent learnt another language in ages.
13:44:48 <shapr> MHD: Agda?
13:44:56 <Twey> The best way to succeed in institutionalised education is to learn it all yourself and then just go to classes for attendance :þ
13:45:16 <shapr> Twey: exactly! That's my approach... trying to finish my undergrad degree by the time I'm 40
13:45:24 <Twey> Heheh
13:45:33 <MHD> shapr: Maybe
13:45:43 <djahandarie> Twey, unfortunately we are not all ddarius.
13:45:59 <Twey> djahandarie: You're not ddarius?  Damn!
13:46:06 <djahandarie> Yes, confusing, I know
13:46:09 <Twey> djahandarie: I think it's just you.
13:46:17 <Twey> The rest of us, we're all ddarius.
13:46:23 <djahandarie> :(
13:46:41 <Twey> MHD: I might suggest Factor rather than FORTH these days
13:46:50 <Twey> Unless you're specifically going for the minimalism
13:47:01 <MHD> Twey: I'm going for minimalism
13:47:06 <Twey> Alright
13:47:18 <MHD> Twey: Factor just feels... Too new. FORTH is like C
13:47:26 <MHD> fells like it
13:47:29 <Twey> Haha, I know what you mean
13:47:34 <shapr> I want to use forth on my Arduino.
13:47:44 <MHD> Factor tastes like Python in comparison.
13:47:47 <Twey> Like C, but better, smaller, and much easier to implement :þ
13:47:51 <Twey> Mmm
13:48:22 <Twey> Factor is more like D or something-that's-a-lot-like-an-updated-C-but-not-C++
13:48:30 <djahandarie> Twey, the assignment calculus? ;)
13:48:39 <Twey> There's an assignment calculus?
13:48:48 <djahandarie> Yes, it's really awesome research
13:48:56 <Twey> *Damn*.  *reads paper*
13:49:00 <djahandarie> www.cas.mcmaster.ca/~bendermm/thesis.pdf
13:49:10 <Twey> Oh, heck, there's even a series of videos on it.
13:49:15 <Twey> Hm, decisions decisions
13:49:16 * hackagebot blaze-html 0.4.1.2 - A blazingly fast HTML combinator library.  http://hackage.haskell.org/package/blaze-html-0.4.1.2 (JasperVanDerJeugt)
13:49:25 * Twey tries the paper first.
13:49:35 <djahandarie> Videos are boring
13:49:45 <Twey> Videos are slow
13:50:00 <djahandarie> I meant these specific videos :p
13:50:03 <Twey> But sometimes friendlier
13:50:05 <Twey> Oh, right :þ
13:51:32 <MHD> Man, LLVM is annoying
13:52:06 <MHD> I need to verify, both that a block has a value to deliver and that it ends with a flow alteration.
13:52:08 <lpsmith> so does anybody know how to mechanize the theory of compass-and-straitedge constructions?
13:52:35 <lpsmith> I'm wondering if there isn't a nice introduction that gives a taste of how to do that...
13:54:01 <edwardk_> lpsmith: hrmm
13:55:31 <edwardk_> lpsmith: you might want to run through the open source stuff from http://en.wikipedia.org/wiki/Interactive_geometry_software
13:58:18 * hackagebot nehe-tuts 0.2.3 - Port of the NeHe OpenGL tutorials to Haskell.  http://hackage.haskell.org/package/nehe-tuts-0.2.3 (JasonDagit)
13:59:30 <lpsmith> edwardk_:   thanks.   Sadly I don't have an iOS device,  but this looks interesting,  and it makes me wonder how to implement such a thing:  http://digitalmathematics.blogspot.com/2011/05/euclid-geometric-constructions-iphone.html
14:00:52 <MHD> Also Agda seems awesome. Does it have monads?
14:02:29 <lpsmith> I would think that _somebody_ on this planet already knows how to mechanize compass and straightedge constructions
14:03:35 <lpsmith> edwardk_: I did find this though,  though I don't have ready access to it at the moment and it's probably a little "heavier" than I'm really looking for anyway:  http://www.springer.com/mathematics/geometry/book/978-3-540-50478-8
14:04:09 <edwardk_> lpsmith: i think i may buy that one =)
14:04:27 <edwardk_> (the game, not the book)
14:04:32 <edwardk_> the book looks rather neat too
14:04:50 <edwardk_> MHD: not only does it have monads, but you can prove your monad satisfies the monad laws ;)
14:05:20 <MHD> Man, I could do statically typed LLVM monad code there...
14:05:42 <MHD> Does it have type classes?
14:06:09 <noteventime> Does Agda have code extraction?
14:08:28 <dolio> It has something of the sort, but I'm not sure how well it works.
14:08:34 <dolio> As I'm not sure anyone really uses it.
14:09:43 <lpsmith> edwardk_: let me know what you think of the game.   I did manage to convince one of my friends to buy it,  sadly I haven't seen him in person for years :)
14:10:41 <edwardk_> noteventime: yes. i've never actually used it though
14:11:06 <edwardk_> mhd: not really. you wind up passing a lot of stuff explicitly
14:12:13 <MHD> Oh, okay.
14:12:22 <Saizan> lately they added a new flavour of implicits that get filled in with whatever you've in scope, as long as there's an unique choice
14:12:36 <edwardk_> oooh, nifty
14:13:20 <Saizan> i've not tried them yet
14:14:35 <Phantom_Hoover> So, I hear there's a Haskell cult?
14:14:53 <tgeeky> *crickets*
14:14:55 <NihilistDandy> PRAISE BE TO CURRY
14:15:33 <NihilistDandy> MAY YOUR ENDEAVORS BE POINTLESS, AND MAY THE IMPOSSIBLE NEVER OCCUR
14:15:44 * tgeeky sighs
14:15:52 <proq> Phantom_Hoover: sure.  on midnight on june 3rd everyone will drink monads and chant "curry"
14:15:56 <Phantom_Hoover> Cool.
14:16:01 <tgeeky> I would pay like, a whole dollar, to stop everyone from using the word "pointless" in favor of "pointfree"
14:16:02 <Phantom_Hoover> How does the drink monad work?
14:16:09 <NihilistDandy> tgeeky: It was a joke :P
14:16:25 <NihilistDandy> "Pointfree endeavors" doesn't make sense
14:16:40 <tgeeky> it does to a haskeller
14:16:41 <companion_cube> beer >>= return drinking
14:16:52 <NihilistDandy> tgeeky: Don't sass me.~
14:16:57 <tgeeky> NihilistDandy: lol :o
14:17:01 <companion_cube> >> rather
14:17:09 <NihilistDandy> :D
14:17:12 <proq> I was thinking more of drinking a bourbon monad
14:17:27 <shachaf> tgeeky: What's wrong with "pointless"?
14:17:49 <monochrom> I use "pointfree"
14:17:52 <tgeeky> shachaf: human life is pointless (to a nihilist)
14:18:01 <tgeeky> but functions can be pointfree
14:18:07 <noteventime> I just say formal when it's about topology :|
14:18:08 <NihilistDandy> And you question my use of pointless :P
14:18:11 <merijn> I mostly program pointless :>
14:18:26 <tgeeky> but any function that has a purpose is *not* pointless
14:18:32 <tgeeky> though it might be pointfree
14:18:55 <tgeeky> shachaf: what's wrong with "pointless"? It comes overloaded by default with a negative conotation
14:18:57 <sully> I mean, in a mathematical sense, the *functions* aren't pointless
14:19:00 <sully> er, pointfree
14:19:04 <dolio> How much would you pay for a new name for "irrational" numbers?
14:19:07 <sully> their definitions are
14:19:15 <sully> the definitions are pointfree
14:19:20 <monochrom> "pointless" is ambiguous. that's what's wrong with it
14:19:21 <sully> the style is pointless :P
14:19:24 <merijn> Isn't the haskell cult just a subsection of the people who have accepted the untyped lambda calculus are their lord and saviour :>
14:19:29 <tgeeky> dolio: that's not fair, because the definition came before the use of "irrational" to mean crazy
14:19:35 <proq> that sounds odd.  what about "purpose free"?
14:19:41 <djahandarie> merijn... untyped?
14:19:42 <Phantom_Hoover> merijn, yes, they're an offshoot from the more hardcore Lazy Kists.
14:19:50 <Phantom_Hoover> djahandarie, you... don't,..
14:19:53 <Phantom_Hoover> Know..
14:19:57 <merijn> djahandarie: Yes?
14:20:00 <Phantom_Hoover> What the untyped lambda calculus is.
14:20:07 <Phantom_Hoover> And you're in #haskell.
14:20:15 <dolio> Why does it matter which came first?
14:20:19 <tgeeky> tgeeky: the origin of the term 'irrational' is (probably) platonic
14:20:21 <merijn> Phantom_Hoover: I assume he was implying you want typed :p
14:20:41 <tgeeky> dolio: because point-free topology came after purposelessness
14:20:41 <Phantom_Hoover> Typesystems are for the weak.
14:20:47 <merijn> Which is of course not true, since the typed lambda calculus is less expressive then untyped
14:20:59 <merijn> Phantom_Hoover: Then you might be in the wrong programming language channel :p
14:21:03 <dolio> That isn't an answer to the question I asked.
14:21:04 <NihilistDandy> No one actually calls it pointless except in a tongue-in-cheek fashion, do they?
14:21:07 <tgeeky> dolio: it is a preference, for sure
14:21:08 <merijn> Python and Lisp are that way :p
14:21:11 <djahandarie> Being 'expressive' isn't always better.
14:21:12 <tgeeky> dolio: hence the small bounty
14:21:18 <sully> merijn: it depends on /which/ typed lambda calculus
14:21:19 <Phantom_Hoover> <merijn> Phantom_Hoover: Then you might be in the wrong programming language channel :p
14:21:21 <Phantom_Hoover> It was a joke.
14:21:33 <sully> I mean, I call it pointless to make fun of haskellers
14:21:36 <merijn> djahandarie: I agree, but you can implement Haskell in the untyped lambda calculus, but not in the typed :)
14:21:47 <NihilistDandy> sully: Exactly. Tongue in cheek.
14:21:48 <noteventime> Untyped lambda calculus is the kind you write by hand
14:21:54 <Phantom_Hoover> merijn, depends on which typed LC you use.
14:21:56 <djahandarie> merijn, Haskell /is/ implemented in a typed lambda calculus.
14:22:07 <Phantom_Hoover> Simply typed won't work, sure, but there are plenty of others.
14:22:08 <merijn> Haskell is turing complete, so it is not
14:22:14 <Phantom_Hoover> Um.
14:22:16 <ezyang> GHC Haskell, at least.
14:22:22 <sully> merijn: it depends which typed lambda calculus you mean.
14:22:23 <djahandarie> Yes, GHC Haskell, sorry.
14:22:24 <merijn> ok, let me rephrase
14:22:25 <tgeeky> dolio: however, I would give one third of the bounty of the nobel prize for proof that a point-free (irrational-free) invariant metric toplogy exists
14:22:31 <Phantom_Hoover> Typed LCs need not be non-TC.
14:22:33 <tgeeky> so, $333,333,333.
14:22:35 <tgeeky> err
14:22:38 <merijn> GHC Haskell is not typed LC :p
14:22:39 <tgeeky> three less threes.
14:22:43 <sully> the typed lambda calculus extended with recursive types is turing complete
14:22:50 <Phantom_Hoover> The simply-typed LC is.
14:22:53 <sully> or with exceptions
14:22:53 <merijn> Phantom_Hoover: Eh, yes they do. Unless their type system is inconsistent
14:23:02 <sully> or with natural numbers and fix
14:23:11 <merijn> Phantom_Hoover: Consistent type system -> strong termination -> not Turing complete
14:23:24 <dolio> There are plenty of inconsistent type systems to choose from.
14:23:41 <sully> I mean, inconsistent doesn't mean not sound
14:23:47 <sully> and really you care about soundness more
14:24:04 <monochrom> that kind of consistency is overrated
14:24:20 <djahandarie> merijn, GHC really uses a typed lambda calculus in one of its compilation phases so arguing otherwise is probably not a great move. :p
14:24:28 <tgeeky> dolio: I feel like asking if there is a *most* inconsistent, but that would be pointless.
14:24:29 <djahandarie> It's called System F_C
14:24:30 <merijn> monochrom: I know, but I like to be dogmatic and unpractical in my spare time, don't ruin my fun :(
14:24:52 <djahandarie> monochrom, proving termination is pretty underrated imo.
14:25:01 <Phantom_Hoover> Huh?
14:25:04 <djahandarie> (Or productive nontermination)
14:25:19 <merijn> I would so trade Turing completeness for strong termination + a coprogramming monad
14:25:31 <djahandarie> Monad?!
14:25:34 <monochrom> moving termination proofs into types is overrated
14:25:44 <NihilistDandy> Overrating is overrated
14:25:51 <sully> merijn: agda?
14:26:05 <merijn> djahandarie: Well, you could use some other abstraction for coprogramming, but why not a monad?
14:26:28 <merijn> sully: I think Epigram is more interesting, albeit even more unusable in "The Real World" (TM)
14:26:43 * sully should look at epigram
14:26:47 <NihilistDandy> Pfeh, Real World
14:26:51 <sully> what are its distinguishing features?
14:26:58 <ior3k> does this channel come with a dictionary? You could all be speaking mandarin and I'd understand more or less the same
14:27:16 <dolio> Syntax that is a nightmare to parse.
14:27:17 <merijn> ior3k: Yes, but we call that dictionary Google Scholar and papers ;)
14:27:25 <monochrom> ior3k: 真的嗎?
14:27:30 * merijn agrees with dolio
14:27:31 <djahandarie> merijn, I don't think I've ever actually used a monad for corecursion.
14:27:46 <proq> ior3k: no, you'll have to consult dictionary.com or wikipedia
14:27:51 <c_wraith> djahandarie: never used the list monad?
14:27:52 <djahandarie> Though I think I've seen one
14:28:05 <merijn> sully: The most distinguishing feature is probably the type checker aided construction of terms
14:28:12 <c_wraith> Though I guess the list monad doesn't work with infinite co-recursion
14:28:27 <c_wraith> Though LogicT would
14:28:43 <Phantom_Hoover> merijn, how do you define a consistent type system, come to think of it?
14:29:06 <monochrom> probably through curry-howard
14:29:29 <merijn> CH, yeah
14:29:33 <Phantom_Hoover> Do all typed LCs have to conform to Curry-Howard?
14:29:34 <djahandarie> c_wraith, I don't see how the list monad captures the concept of productive corecursion
14:30:27 <djahandarie> Phantom_Hoover, all type systems have that correspondence, just the majority aren't particularly interesting.
14:30:39 <monochrom> if you drink the curry-howard koolaid wholesale, you hallucinate that "a->b" means "a implies b" and you would not want a program that proves it.
14:30:39 <merijn> sully: It's interesting, you can specify the type of a function and then based on context (i.e. existing functions, type dependency and constraint typing etc.) have the compiler to a lot of the work of constructing a valid term for you
14:31:06 <Phantom_Hoover> djahandarie, so why... I've forgotten what I was even arguing about.
14:31:17 <merijn> Phantom_Hoover: It happens :D
14:31:56 * ior3k consults Google Scholar
14:32:04 <Phantom_Hoover> For what?
14:32:11 <Phantom_Hoover> What I was arguing about?
14:32:18 <merijn> I lose track of my understanding of type theory midway through discussions, though I seem to have increased the minimum time I can keep the discussion up
14:32:35 <liznewbtcminer> o.o; merf.
14:32:44 <djahandarie> monochrom, I don't see why you find CH so uninteresting. It is certainly fairly useless in Haskell, but not when you have a consistent type system it becomes pretty nice to have around.
14:32:52 <liznewbtcminer> CH?
14:33:13 <merijn> liznewbtcminer: Curry-Howard(-DeBruijn) last one only if you're Dutch ;)
14:33:18 <djahandarie> The curry-howard correspondence.
14:33:18 <sully> curry-howard correspondence
14:33:19 <Phantom_Hoover> Curry-Howard isomorphism.
14:33:50 <liznewbtcminer> o.o;
14:33:56 * liznewbtcminer hides, lost.
14:33:59 <dolio> djahandarie: Another approach is the logic-enriched type theory, which has a separate logical segment. Similar to Coq's Prop.
14:34:08 <merijn> ior3k: It's mostly based on type theory, which means in order of simplicity (sorta): proposition logic, predicate logic, (un)typed lambda calculus, lambdacube, calculus of constructions, dependent typing (by the time you are here you will either be insanely smart, just insane or both)
14:34:22 <Phantom_Hoover> liznewbtcminer, it involves making types propositions, and members of the types proofs of the propositions.
14:34:41 <ior3k> merijn: or just feeling really stupid
14:34:43 <dolio> Curry-Howard urges you to crush it all into the same thing, encoding your propositions at types.
14:34:45 <djahandarie> merijn, you seem to be using a strange partial order.
14:34:50 <Phantom_Hoover> So a function between two types transforms proofs of one into the other, a.k.a. logical iplication.
14:34:52 <dolio> Which may or may not be a good idea.
14:34:53 <Phantom_Hoover> *implication
14:34:56 <merijn> ior3k: I dunno if there's any good intro's to the topic, I certainly didn't find any when I started learning this a few months back. Although I hear the book Types and Programming Language is pretty good
14:35:12 <dolio> As types, even.
14:35:25 <merijn> djahandarie: That's the order I "learned" all this stuff in, which may or may not make sense
14:35:47 <joe6> helllo, I am using the usb module and it gives me an error that I have no clue about. To get more details on what is going on, I downloaded and installed the libusb-1 package and installed it with --enable-debug-log .
14:35:50 <ior3k> I mean, just the abstract of this paper:  http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-304.html is hilarious. I can read all the words and understand nothing about it
14:36:01 <dolio> If you keep them separate, there's not necessarily a problem with adding general recursion to the type segment, because it doesn't need to make the logical segment inconsistent.
14:36:08 <joe6> I am trying to figure out how the binding--libusb package is linked to the libusb package.
14:36:14 <liznewbtcminer> Phantom_Hoover: that just went over my head like, ten times, so i'll just say okay :)
14:36:27 <joe6> as, I still do not see any messages from the usp package.
14:36:32 <merijn> ior3k: :D
14:36:46 <geheimdienst> ior3k: what got you interested in that paper? why do you want to understand it?
14:36:58 <djahandarie> dolio, why would that be useful? I don't think I've ever actually wanted to use general recursion, or rather, when I have, it was always a mistake anyways
14:37:13 <merijn> ior3k: Yeah, I know how you feel (even though I can (now) sorta grok what the abstract is about)
14:37:45 <merijn> geheimdienst: Naah, the type theory discussion started and he asked for a dictionary so I said "Google Scholar", then he got even more lost (as tradition demands)
14:37:58 <ior3k> geheimdienst: I just searched for co-recursion
14:38:11 <dolio> djahandarie: Because it's often cumbersome to write in a style that satisfies the machine's ability to verify termination, even if you never really need the power of general recursion.
14:38:21 <djahandarie> I guess
14:38:28 <merijn> ior3k: corecursion is just two functions recursively calling eachother
14:38:34 <noteventime> ior3k: Haha, thanks for that paper, it might be relevant to my bachelors thesis :D
14:38:41 <djahandarie> merijn, not in that context.
14:38:50 <dolio> So being able to program naturally, together with a logical segment for proving termination might be useful.
14:39:02 <merijn> djahandarie: Damn, my word-based association trick of looking smart failed :<
14:39:14 <merijn> djahandarie: Infinite recursion in this context?
14:39:54 <noteventime> merijn: unfold :)
14:40:02 <c_wraith> merijn: co-recursion traverses co-inductive data structures.
14:40:12 <monochrom> you mean corecursion here refers to zero = 0 : zero?
14:40:25 <monochrom> then it is just one function calling itself :)
14:40:47 <merijn> c_wraith: Yes, that is much clearer >.>
14:41:02 <c_wraith> merijn: I could have just said co-data structures :)
14:41:05 <noteventime> Unfold would be the "standard" example of corecursion in (infinite) lists
14:41:28 <merijn> c_wraith: But I know what co-data is (although I sorta guessed co-inductive data structures were the same)
14:41:33 <Phantom_Hoover> Where is lambdabot.
14:41:34 <noteventime> In the sense that fold is the natural form of recursion for lists
14:41:48 <NihilistDandy> > 2 + 2
14:41:50 <lambdabot>   4
14:41:54 <monochrom> @bots
14:41:54 <lambdabot> :)
14:41:55 <NihilistDandy> Phantom_Hoover: Right there
14:41:56 <monochrom> @humans
14:41:56 <lambdabot> Unknown command, try @list
14:41:57 <ddarius> a
14:42:02 <Phantom_Hoover> Oh.
14:42:22 <monochrom> where are all the humans?
14:42:26 <shachaf> @remember ddarius a
14:42:26 <lambdabot> It is stored.
14:42:31 <Phantom_Hoover> @where humans
14:42:32 <lambdabot> I know nothing about humans.
14:42:36 <Phantom_Hoover> OH REALLY
14:42:44 <Phantom_Hoover> SOUNDS SUSPICIOUS
14:42:52 <Phantom_Hoover> :t unfold
14:42:53 <lambdabot> Not in scope: `unfold'
14:42:57 <Phantom_Hoover> -_-
14:43:04 <sully> @list
14:43:04 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
14:43:05 <NihilistDandy> I wonder if I develop a sufficiently powerful computer vision system, then cause it to observe itself... will it become self-aware?
14:43:08 <merijn> Phantom_Hoover: Don't antagonize it, we don't need lambdabot to turn into skynet any faster then she already is
14:43:19 <noteventime> :t undoldr
14:43:19 <merijn> NihilistDandy: Why do you need vision for that?
14:43:20 <lambdabot> Not in scope: `undoldr'
14:43:24 <noteventime> :t unfoldr
14:43:26 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:43:34 <merijn> NihilistDandy: Also, how do you know lambdabot is not already self-aware?
14:43:39 <NihilistDandy> merijn: It's gotta be able to recognize itself :D
14:43:47 <NihilistDandy> merijn: I didn't say it wasn't
14:43:53 <proq> NihilistDandy: well, I'll see you in 50 years when you're done making it sufficiently powerful
14:43:56 <merijn> NihilistDandy: Blind people can't recognize themselves?
14:44:05 <sully> @unlambda
14:44:05 <lambdabot>   unlambda: Parse error at end of file
14:44:09 <NihilistDandy> merijn: Not visually
14:44:14 <Phantom_Hoover> @where everyone
14:44:15 <lambdabot> I know nothing about everyone.
14:44:16 <sully> @unlambda `sk
14:44:16 <lambdabot>  Done.
14:44:35 <shachaf> @unlambda .a
14:44:35 <lambdabot>  Done.
14:45:02 <shachaf> @bf ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++...
14:45:02 <lambdabot>   <<<
14:45:10 <monochrom> it takes much more than self-observation to get self-awareness
14:45:26 * hackagebot accentuateus 0.9.3 - A Haskell implementation of the Accentuate.us API.  http://hackage.haskell.org/package/accentuateus-0.9.3 (MichaelSchade)
14:45:28 <Phantom_Hoover> Does she have a Lazy K mode?
14:45:33 <monochrom> for example, no amount of threadscope and strace has led to self-awareness yet
14:45:36 <NihilistDandy> Depends on your definition of self-awareness
14:45:37 * shachaf wonders why people treat self-awareness as such an important property.
14:45:43 <noteventime> @where anything
14:45:44 <lambdabot> I know nothing about anything.
14:45:44 <ion> @dc 1 2+p
14:45:44 <lambdabot> Maybe you meant: do rc
14:45:54 <shachaf> Awareness in general is interesting, but self-awareness seems like a completely pointless special case to focus on.
14:46:23 <NihilistDandy> Pointless from a computer science perspective, but vaguely interesting from a philosophical standpoint
14:46:28 <NihilistDandy> For certain values of interesting
14:46:36 <sully> Phantom_Hoover: you mean lambdabot?
14:46:43 <merijn> Everything is interesting for certain values of interesting
14:46:43 <Phantom_Hoover> Self-awareness for different values of 'self'.
14:46:50 <Phantom_Hoover> sully, yes.
14:46:57 <Phantom_Hoover> Seems like a good language to have.
14:47:00 <sully> it odesn't look like it
14:47:08 <Phantom_Hoover> -_-
14:47:09 <NihilistDandy> Phantom_Hoover: Write a module
14:47:12 * sully wrote a lazy k interpreter in haskell just the other day
14:47:26 <sully> that was substantially faster than the provided C++ implementation
14:47:26 <Phantom_Hoover> NihilistDandy, looks like sully has one.
14:47:34 <sully> even after I spent a lot of time optimizing it
14:47:41 <Phantom_Hoover> sully, that C++ implementation is crap, so it's not surprising.
14:48:02 <NihilistDandy> Phantom_Hoover: He has an interpreter. Still likely needs a lambdabot module to talk to it
14:48:07 <Phantom_Hoover> lazier.scm is also highly suspect, not least because of the unquoted ()s and stuff.
14:48:10 <monochrom> I don't mind using your definition. if you wonder how much vision can accomplish, I say wonder how much threadscope and strace and ptrace can accomplish first, I suspect same answer.
14:48:22 <sully> yeah, I also had to fix up lazier.scm a bit
14:49:15 <Phantom_Hoover> strace true is possibly the most stupid thing I have seen after the actual source for GNU true.
14:49:26 <Phantom_Hoover> sully, have you seen my quasi-monadic IO library for Lazy K.
14:50:25 <fffej> hi, I'm using Yesod with the Redis libraries.  I've pushed my app live, but I'm seeing "<socket: 7>: hFlush: resource vanished (Broken pipe)" after a while of using it.  Can anyone give me some guidance as to where I should start figuring out what's going wrong?  I can't see this problem locally
14:50:33 <sully> Phantom_Hoover: nope
14:51:04 <Phantom_Hoover> http://esolangs.org/wiki/User:Phantom_Hoover/io.scm
14:51:20 <shachaf> Phantom_Hoover: What's wrong with strace true?
14:51:26 <shachaf> Phantom_Hoover: Don't you want localization?
14:51:48 <Phantom_Hoover> Yes. After all, what if you're running true in a culture without a concept of 0?
14:52:07 <shachaf> Phantom_Hoover: /bin/true does support --help and --version.
14:52:13 <applicative> fffej, there is a #yesod if you can believe it... don't know if anyone is awake...
14:52:26 <Phantom_Hoover> shachaf, indeed, I have looked at the source.
14:52:37 <fffej> @applicative, thanks
14:52:37 <lambdabot> Unknown command, try @list
14:52:46 <shachaf> There's also a #snap, complete with a bot that will now ping them.
14:53:10 <ozataman> fffej: it might possibly be a redis connection going stale issue. the redis package does not have connection pool interface, AFAIK
14:53:16 <lpsmith> #snapframework actually, byt yeah
14:53:31 <ozataman> fffej: the standard redis server config will disconnect the connection after 300 secs. make sure you disable that
14:53:51 <fffej> ah-ha, that's probably it.  Thanks ozataman
14:54:14 <ozataman> fffej: I'be been intending to create a connection pool wrapper on redis for a while now... similar to bos' riak lib
14:54:46 <bos> ozataman: http://hackage.haskell.org/package/resource-pool
14:55:15 <ozataman> bos: oh I hadn't seen that - thanks!
14:55:36 <fffej> perfect, I'll use that, thanks
14:55:39 <bos> ozataman: yeah, i pulled out the riak connection pooling code and made it generic
14:55:51 <drhodes> On division there is Zero and "everything else". on sqrt there is negative numbers and positive numbers.  These invalid/valid domains,  do they have a name in type theory?
14:55:52 <bos> i use it with mysql-simple now in my app, for instance
14:55:58 <ozataman> bos: that's perfect, thanks for that
14:56:21 <Phantom_Hoover> drhodes, R \ {0}, R?
14:56:46 <drhodes> Phantom_Hoover: I mean generally, the topic which address the domains
14:56:49 <Phantom_Hoover> In type theory? That kind of thing doesn't have a name in type theory AFAIK.
14:56:55 <drhodes> ok
14:57:06 <Phantom_Hoover> Unless you mean the domain of a function.
14:57:27 <monochrom> you can use a predicate subtype for the domains and codomains of these functions
14:58:02 <drhodes> predicate subtype, ok - thanks!
15:12:40 <fffej> bos, ozataman: thanks for pointing out redis connection pooling and the data.pool library.  Seems to have fixed the problem I was having
15:41:23 <blackdog> js scripters discover monads, film at 11: http://owns.ch/keeping-sanity-in-callback-hell.html
15:43:02 <dibblego> heh
15:45:20 <acowley> Anyone here have a webcam, GHC7, and OpenCV 2.2 installed?
15:46:37 <merijn> blackdog: They already did a while ago, JQuery is a monad too
15:47:56 <bos> as are my pants.
15:48:05 <bos> they bind and return.
15:48:10 <bos> not to mention join.
15:48:41 <hpc> monads are like pants!
15:48:55 <acowley> a pants monad would make packing for air travel easier, but I dispuate the existence of useful Pants (Pants me) -> Pants me property
15:49:23 <merijn> hpc: Probably true, easy to get someone in pants, very hard to get them out :>
15:49:30 <hpc> acowley: how about enabling the topological impossibility of removing underpants while still wearing pants?
15:50:02 <acowley> hpc: my legs are fibers over my pelvis
15:50:12 <hpc> lol
15:50:40 <hpc> depending on what material they are, pants can be fibers over your pelvis too
15:50:41 <hpc> ;)
15:50:45 <acowley> computational anatomy is a promising field
15:52:41 <acowley> So no one's sitting at a machine with a little camera looking back at them? I want to test a package on a system I didn't set up in case I do something funny to my computers that is essential for making things work.
15:53:14 <acowley> which tends to happen (to me at least) with large-ish libraries
15:54:30 <conal> any mac users here? i'm having trouble with dylibs, e.g., "/opt/local/lib/libpango-1.0.dylib: mach-o, but wrong architecture". i've forgotten whether ghc-7.0.3 is 32-bit or 64-bit and how to tell 'port install' to match.
15:55:01 <acowley> conal: you probably want to add +universal
15:55:17 <conal> acowley: thx. sounds familiar. i'll give it a try.
15:55:19 <acowley> to the macports config file
15:55:24 <acowley> but I can't find mine now
15:55:24 <merijn> I'm pretty sure +universal is the default for MacPorts
15:55:32 <acowley> ah, it wasn't in the past
15:55:38 <merijn> All my stuff is build as it, anyway
15:55:51 <acowley> also, on mac, having ghc-7.0.3 as 32-bit is critical if you want to use LLVM
15:56:12 <geheimdienst> conal: i seem to recall "otool -L" or something similar can tell you what architectures are in your dylib file. should provide a clue what's going on
15:56:43 <conal> geheimdienst: sweet. thx.
15:57:08 <bos> yep, otool is your friend in a cruel OSX world of crappy tooling
15:58:01 <geheimdienst> bos, you seem to be mistaken. apple always does everything right. you can see this because their things are shiny
15:59:22 <blackdog> merijn: embarrassingly, i haven't actually played with jquery. how is it a monad?
15:59:23 <shachaf> geheimdienst: See, that's the sort of logic we want to be able to express in Haskell proofs. That's why termination is an overrated requirement.
15:59:35 <shachaf> geheimdienst: Wait, that was djahandarie who wanted termination. Never mind.
15:59:46 <geheimdienst> :D
15:59:53 <blackdog> conal: ghc 7.0.3 is 32 bit by default, i'm pretty sure
16:00:10 <conal> blackdog: ah, okay. thx.
16:01:04 <blackdog> conal: have had many problems with ghc being 32 bit and ruby & other libs being 64 bit:/
16:01:20 <conal> what does 'universal' mean?
16:01:56 <blackdog> i think it tells ports to build fat binaries with both architectures?
16:02:08 <blackdog> not sure, i use homebrew these days
16:02:09 <bos> conal: blackdog: there's a 64-bit ghc 7.0.3 installer for OSX now
16:02:11 <bos> thats' what i run
16:02:20 <blackdog> bos: i thought it was marked experimental
16:02:23 <geheimdienst> conal: possibly it means "has an powerpc compartment and an x86 compartment". from a few years ago when the transitioned to nitel processors
16:02:24 <conal> bos: oho!
16:02:46 <geheimdienst> *intel
16:03:03 <acowley> I think universal is just 32bit and 64bit now
16:03:09 <Axman6> blackdog: experimental but works well
16:03:15 <geheimdienst> ... but it could be the ... er yeah, what acowley said
16:03:49 <shachaf> Not very "universal" without 16-bit support.
16:04:18 <geheimdienst> fine, call it bothiversal if you want
16:04:21 <Axman6> Apple don't support 20 year old systems
16:04:24 <acowley> Yeah, I tried to use macports on my arduino.
16:04:46 <Axman6> on your arduino?
16:04:56 <blackdog> shachaf: we play both kinds of music: country _and_ western.
16:05:15 <acowley> Well, after adding +universal to the config file, I got cocky.
16:05:24 <geheimdienst> Axman6: apple don't support even a few year old systems
16:05:44 <Axman6> if a few == > 7-8, then yes
16:05:45 <acowley> Very few of my Apple products are still supported
16:05:46 <geheimdienst> (TODO: fix grammar)
16:06:13 * acowley reassures his G5 iMac and iPhone 3G of their worth
16:06:40 <shachaf> PowerPC? Hah!
16:06:48 <Axman6> we're still running two G5 iMacs
16:06:51 <geheimdienst> Axman6: i don't think the current OS versions for example still support power pc. i bought a new g4 laptop in summer 2005, that's < 6 years ago
16:06:51 <shachaf> @vixen Tell acowley what you think of PowerPC.
16:06:52 <lambdabot> are you horny?
16:06:58 <Axman6> bought the second one a year or so ago
16:07:08 <shachaf> Ahem.
16:07:26 <Axman6> geheimdienst: that doesn't mean Apple don't support the machine though, they still make their apps for PPC i believe
16:07:44 <Axman6> well, many of them, except the ones where the performance necessary to run them can't be provided by any PPC machines
16:08:16 <acowley> Axman6: it's much worse.
16:08:38 <acowley> Axman6: I have 10.4 on the iMac G5, and can't install the latest iTunes which is needed to work with the iPhone
16:09:05 <geheimdienst> Axman6: i'm not an apple user anymore, i haven't been following closely. i just think that your guess of "7-8 years" is a little high
16:09:12 <acowley> Axman6: and the worst thing of all is that I eventually gave up trying to maintain a PPC GHC as getting the latest to compile left me with strange linker errors
16:09:14 <geheimdienst> (based on my gut feeling)
16:09:52 <Axman6> acowley: m3ga maintains a PPC build for linux
16:09:57 <Axman6> nice timing btw
16:09:58 <geheimdienst> wikipedia says the last OS to support powerpc was 10.5, which had its first release in 2007
16:10:26 <dankna> it's been about five years
16:10:29 <dankna> ah
16:10:31 <m3ga> acowley, Axman6: ghc HEAD currently has a broken ghci. i'm hacking on it now
16:10:40 <Axman6> my iTunes definitely works on PPC too
16:10:45 <m3ga> broken for linux-powerpc that is
16:11:14 <Axman6> /Applications/iTunes.app/Contents/MacOS/iTunes (for architecture ppc):Mach-O executable ppc
16:11:17 <acowley> I have a working iTunes on the computer, but I couldn't use it install iOS 4.1 (?) when it came out
16:11:19 <geheimdienst> Axman6: the issue might be that acowley has 10.4
16:11:24 <acowley> geheimdienst: right
16:11:34 <dankna> anyway, PPC OS X is nice to support if it's no extra effort, but I wouldn't lose sleep over it
16:11:48 <Axman6> but that's not Apple's fault... they supported your system by providing a new OS, you haven't bought it
16:12:00 <Axman6> dankna: not really worth it these days
16:12:06 <acowley> paid support
16:12:07 * dankna nods
16:12:22 <blackdog> Axman6: uh, which OS? You can't run new apple OSes on PPC hardware...
16:12:30 <Axman6> 10.5
16:12:36 <acowley> While I agree with you in principle, I think there is a difference between paid support and free updates
16:12:53 <dankna> yeah - the SEC certainly thinks so :)
16:12:54 <acowley> otherwise you could just say their offer to sell me new hardware counts as support
16:12:57 <Axman6> you get free updates, you don't get free upgrades
16:16:52 <shachaf> Axman6: So apt-get update is free and apt-get upgrade isn't? Not very useful. :-)
16:17:10 <m3ga> shachaf: :-)
16:17:15 <Axman6> it's not a free OS, i don't see your point
16:17:44 <shachaf> Axman6: I was just purposefully misunderstanding "update" and "upgrade".
16:18:18 <acowley> Axman6: I think you're being charitable in viewing some iTunes version changes as updates and some as upgrades
16:18:25 <Axman6> updates fix bugs, and only rarely provide new features. it's not a hard concept to understand
16:18:37 <hpc> update = "this version is changed"
16:18:40 <Axman6> iTunes is a free piece of software
16:18:44 <hpc> upgrade = "you get new version"
16:18:45 <acowley> Axman6: honestly, I don't resent the end of support for the OS, but I don't think 7 years is what you get
16:18:56 <hpc> (where "change this version" = "increment subversion")
16:19:14 <acowley> Axman6: by that definition, many upgrades *are* free
16:19:26 <shachaf> Axman6: A concept being easy or difficult to understand doesn't mean I accept it. :-)
16:19:35 <acowley> I think Apple does pretty well with adding new features to existing products
16:20:18 <acowley> but I'm not going to pretend that's some eminently logical dividing line between supported and not-supported
16:22:03 <Axman6> me either
16:22:17 <acowley> Back on topic: the latest GHCs not being packaged for 10.5 was a bit of a letdown
16:39:16 <k0ral> hi, I get the following error: "Ambiguous module name `Control.Monad.Trans' it was found in multiple packages: mtl-2.0.1.0 monads-tf-0.1.0.0"
16:39:16 <lambdabot> k0ral: You have 1 new message. '/msg lambdabot @messages' to read it.
16:39:33 <hpc> k0ral: package imports?
16:39:49 <hpc> it's a ghc extension that solves that problem
16:40:02 <hpc> the more long-term solution is perhaps to uninstall one of them
16:40:10 <hpc> (iirc monads-tf is the older one)
16:40:29 <k0ral> I don't really know either of them, which one should I uninstall ?
16:40:51 <k0ral> ok monads-tf
16:41:18 <hpc> i would wait for a second opinion on which one, but the package import solves the ambiguity immediately
16:42:39 <k0ral> well, I unregistered monads-tf which was a dependency of dbus-client, which I don't use anymore
16:43:42 <acowley> You can also do package hide on monads-tf
16:43:52 <acowley> but unregistering is fine
16:44:04 <k0ral> thank you for your suggestions
16:44:18 <k0ral> I'll keep them in mind in case I meet again such problem
16:47:47 * hackagebot hbro 0.4.1 - A suckless minimal KISSy browser  http://hackage.haskell.org/package/hbro-0.4.1 (koral)
16:48:37 <hpc> @isdown hackage.haskell.org
16:48:38 <lambdabot> Unknown command, try @list
16:48:51 <joe6> k0ral, have you tried hbro?
16:48:52 <hpc> oh nvm, just very slow
16:49:06 <joe6> is it better than uzbl?
16:49:32 <k0ral> joe6: well, as the author of hbro, I have tried it of course
16:49:39 <joe6> haha..
16:49:54 <joe6> sorry, did not see the author, till late.
16:50:02 <joe6> better/faster than uzbl?
16:50:14 <k0ral> that's a tricky question :)
16:50:39 <k0ral> better is subjective, but I guess as it is still in early development stage, it cannot be better
16:51:12 <k0ral> as for speed, I didn't benchmark it so can't say
16:51:42 <k0ral> but as far as I tested it, it's really fast
16:52:11 <k0ral> the thing is: I'm trying to follow uzbl example, but with what I think to be a more modern approach
16:52:32 <k0ral> I'm personnaly using uzbl in a daily basis
16:57:49 * hackagebot repa 2.0.1.1 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-2.0.1.1 (BenLippmeier)
17:27:53 * hackagebot splot 0.1.18 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.1.18 (EugeneKirpichov)
17:39:58 <dmwit> haha, "s ~ t is an unboxed type represented by a zero-bit value, and passed in, well, a zero-bit register -- a very narrow bit-field indeed"
17:40:31 <dmwit> On an unrelated note, will GHC compile "data Void" to a similar zero-bit field? =P
17:40:40 * ddarius makes a zero bit computer architecture to go along with it.
17:41:11 <dmwit> Boy, those zero-bit instructions sure are easy to implement!
17:42:04 <hpc> dmwit: try evaluating BB(0) next :D
17:42:26 <c_wraith> Wait, I think I can evaluate BB(0)
17:43:24 <c_wraith> Nope, I failed. :)
17:43:30 <hpc> heh
17:44:37 <hpc> > bb 0
17:44:39 <lambdabot>   Eleventy-one and a half
17:44:42 <c_wraith> I got some kind of exception when I tried to look up the current state in the state/input table
17:45:32 <midnightmagic> that's numbawang
17:45:51 <NihilistDandy> DAS IST NUMBERWANG
17:46:22 <hpc> haha
18:20:29 <[mth]> Does anyone know of a library that can be used for producing output based upon a grammar? Basically pretty printing as a reverse operation for a parser.
18:20:29 <lambdabot> [mth]: You have 1 new message. '/msg lambdabot @messages' to read it.
18:35:13 <dmwit> [mth]: There was a paper about specifying both parsers and pretty-printers simultaneously that I saw just recently.
18:35:18 <dmwit> http://lambda-the-ultimate.org/node/4191
18:47:17 <Favonia> hmm does anyone have suggestions for forcing strict evaluation in Haskell?
18:47:35 <dmwit> :t seq
18:47:36 <lambdabot> forall a t. a -> t -> t
18:47:43 <dmwit> :t rnf
18:47:44 <lambdabot> Not in scope: `rnf'
18:47:53 <Favonia> I found packages deepseq, strict-io, etc, but I am worried about `rnf'.
18:47:53 <monochrom> seq usually works. try it.
18:47:57 <Cale> see bang patterns
18:48:10 <Cale> They're sometimes a good deal more convenient than using seq directly
18:48:19 <Favonia> It seems that every time I use rnf, it will check the whole data structure.
18:48:21 <dmwit> :t ($!)
18:48:21 <lambdabot> forall a b. (a -> b) -> a -> b
18:48:23 <Cale> But... be careful about your use of strictness.
18:48:30 <dmwit> Favonia: ...yes. That's the whole point of rnf.
18:48:34 <Cale> Favonia: That's precisely what rnf is for
18:48:34 <monochrom> yes rnf is for the whole thing
18:48:42 <dmwit> Maybe we'd better ask what you're trying to do...
18:48:46 <Cale> rnf accidentally the entire data structure
18:48:57 <djahandarie> LOL
18:49:14 <monochrom> rnf forces everyone and his/her grandmother
18:49:18 <djahandarie> @remember Cale rnf accidentally the entire data structure
18:49:19 <lambdabot> Good to know.
18:49:28 <Favonia> Cale: well, I hope that it will stop checking if it already checked the data structure before
18:49:29 <shachaf> rnf on purpose the whole data structure, surely?
18:49:56 * copumpkin still wants an snf
18:50:10 <shachaf> snf?
18:50:15 <copumpkin> spine! ;)
18:50:19 <Zao> Slightly Normal Form.
18:50:42 <monochrom> it is not so easy to define what is spine and what is not spine
18:50:47 <shachaf> And rnf is "Really Normal Form"?
18:51:20 <Favonia> I could implement dual versions of all data structures, and add a tag by myself to denote "reduced" or "possibly not reduced"
18:51:27 <shachaf> What does the 'r' stand for, anyway? I hope it's not "reduce".
18:51:44 <Favonia> shachaf: no idea :P
18:52:07 <shachaf> Favonia: It would be kind of weird for GHC to keep track of it by itself. It'd have to go back over the entire structure and tag each part "fully reduced".
18:52:07 <copumpkin> monochrom: what I was thinking was that it'd be valid on a * -> * type where the parameter occurs in strictly positive positions, and you pretend that you need a Seq typeclass to use seq on values, and then snf :: f a -> b -> b (no Seq constraint on a)
18:52:20 <copumpkin> monochrom: but that doesn't exactly roll off the tongue
18:52:21 <monochrom> r seems to be "reduce" indeed
18:52:28 <copumpkin> yeah
18:52:44 <monochrom> "rnf should reduce its argument to normal form" seems like "reduce to normal form"
18:52:48 <shachaf> Why is it a verb? :-(
18:53:22 <monochrom> because we are tired of the tyranny of nouns
18:53:43 * shachaf <- not a fan of verbs.
18:53:58 <monochrom> most function names are verbs, really
18:54:00 <shachaf> New problem: Verb-free speech.
18:54:06 <blackdog> shachaf: java fan?
18:54:07 <blackdog> http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html
18:54:08 <monochrom> Data.Map is full of "insert", "update"
18:54:10 <copumpkin> shachaf: good idea
18:54:24 <copumpkin> shachaf: new concept?
18:54:26 <monochrom> no one really wants "insertion", "updateness"
18:54:53 <blackdog> monochrom: i guess it does blur the line between ephemeral and persistent structures
18:55:06 <shachaf> blackdog: functions `elem` nouns
18:55:32 <Favonia> shachaf: hmm I think I know currently it is not possible. I am worried about this because somebody made a strict-io package but it uses rnf. If I am write/readIORef a big data structure, then it will have to check the whole data structure everytime, right?
18:55:49 <blackdog> shachaf: false
18:55:57 <shachaf> blackdog: Incorrect.
18:56:19 <copumpkin> shachaf: limited communication ability? :(
18:56:53 <shachaf> Favonia: Presumably -- how else?
18:57:22 <monochrom> without actual code it's hard to tell
18:57:23 <ddarius> rnf is misnamed
18:57:44 <ddarius> copumpkin: 1
18:57:51 <Favonia> shachaf: I just feel it is misleading. People might write something with quadratic running time just because of using rnf.
18:58:03 <copumpkin> ddarius: ?
18:58:05 <ddarius> rnf/deepSeq is a hack
18:58:12 <ddarius> copumpkin: 1001101
18:58:23 <copumpkin> oh
18:58:30 <copumpkin> hum
18:58:37 <Favonia> ddarius: I think I agree with you... do you have a better workaround :/
18:58:51 <mafs> Anyone know what's up with the missing dependency issue on Hackage for `text`?
18:58:54 <ddarius> Favonia: Don't use rnf/deepSeq.  I have no idea what the context is.
18:59:11 <mafs> I got it and also noticed jaspervdj's blaze-html has it too, so I assume it's not just me doing something silly :(
18:59:48 * shachaf surrenders.
19:13:38 <lpsmith> what does "rnf" stand for?   "recursive normal form?"
19:14:03 * aavogt thinks reduce to normal form
19:14:28 <dolio> Yes, reduce.
19:15:00 <geheimdienst> reduce noms ferociously
19:15:24 <ddarius> The nf is a lie.
19:15:35 <Favonia> really nice function
19:15:37 <dolio> Is it?
19:16:02 <ddarius> dolio: Yes.
19:16:15 * ddarius wonders what "Phobic United Foundation" does.
19:16:17 <Favonia> ddarius: after searching the web for a while, I feel the only sensible way is to make a dual version of everything (reduced/possibly not reduced)
19:17:06 <Favonia> ddarius: kind of painful :(
19:18:43 <dolio> Can you elaborate on that? My concern would be that it can't possibly evaluate under binders correctly, but functions aren't an instance of NFData, it seems.
19:18:57 <dolio> So it doesn't claim to be able to cause normal forms for those.
19:20:24 <ddarius> > rnf id
19:20:26 <lambdabot>   Not in scope: `rnf'
19:20:51 <dolio> According to the haddock, at least.
19:21:01 <Favonia> @hoogle rnf
19:21:01 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
19:21:22 <Favonia> > Control.Parallel.Strategies.rnf 123
19:21:22 <lambdabot>   Not in scope: `Control.Parallel.Strategies.rnf'
19:21:36 <dolio> I was looking at the deepseq docs, I think.
19:21:55 <Favonia> wait I misunderstood this version of rnf :/
19:23:54 <scooty-puff> is there a way to define a MonadTrans for an instance of class PMonad m where return :: m i i a, etc.
19:24:08 <scooty-puff> or rather a transformer that can be made to it
19:24:18 <scooty-puff> seems to much weird handling of type variables
19:24:28 <scooty-puff> via newtype Wrap, etc.
19:25:25 <scooty-puff> i.e. it would "t m i j a" or "t i j m a"?
19:26:53 <dibblego> MonadTrans takes a value :: (* -> *) -> * pretty sure
19:27:11 <dibblego> @src MonadTrans
19:27:12 <lambdabot> Source not found. It can only be attributed to human error.
19:27:27 <scooty-puff> so the latter - the problem is how to make it also an instance of PMonad, m i j a
19:27:29 <dolio> (* -> *) -> * -> *
19:27:43 <ian_mi> error is between lambdabot and chair
19:27:44 <scooty-puff> just make all PMonad's possible transformers over regular monads?
19:27:44 <dibblego> yeah that
19:28:24 <scooty-puff> and then make an Identity type if required?
19:28:33 <scooty-puff> or if the transformer part not necessary?
19:30:09 <dibblego> speaking of, where might I find class f `T` g where (~>) :: f a -> f a
19:30:15 <dibblego> !seen edwardk
19:30:28 <Saizan> a monad is * -> *; a monad trans is (* -> *) -> (* -> *); a PMonad is (* -> * -> * -> *), a PMonadTrans should be  (* -> * -> * -> *) ->  (* -> * -> * -> *)
19:30:52 <scooty-puff> so would have to define my own transformer..
19:30:54 <scooty-puff> thats a shame
19:30:59 <Saizan> dibblego: forgot a g?
19:31:00 <scooty-puff> o i see, Saizan
19:31:06 <dibblego> yeah I did indeed
19:31:12 <dibblego> f a -> g a
19:32:26 <dolio> You can't really define indexed monad transformers correctly in Haskell.
19:32:35 <scooty-puff> ok
19:32:57 <Saizan> dolio: why?
19:33:10 <dolio> Presumably the index should be a product of the indices for the two underlying monads.
19:33:14 <dolio> But there are no product kinds.
19:33:59 <Saizan> true, but you can demand that to the specific transformers i think
19:34:40 <Saizan> btw, you can make a MonadTrans t into a PMonadTrans with newtype Wrap t m i j a = Wrap (t (m i j) a), i think
19:34:53 <scooty-puff> yeah thats what i'm doing now
19:35:19 <Favonia> dolio: hi, after reading the codes and documents, I think rnf might not be able to force every thunk within the data structures. For example, it uses rnf . toList for Map, but it seems that Map's have other information like sizes within the data structures, and that information is not exposed by toList.
19:36:13 <Favonia> dolio: so I would agree with ddarius that it is more like a hack
19:36:18 <Saizan> aren't the sizes kept in strict fields?
19:36:31 <dolio> Well, that's true, but it isn't as fundamental a limitation as it would have for functions.
19:36:46 <dolio> It's an artifact of Map being abstract.
19:37:31 <Saizan> yep, they are even UNPACK'ed
19:38:17 <Axman6> Favonia: aren't those pieces of data strict, along with the spine of the map?
19:38:31 <Favonia> Saizan: ok... then I guess it if fine for Data.Map
19:38:57 <Axman6> and usually that's not something you'd particularly care about anyway
19:39:25 <Axman6> it's more a matter of making sure the elements in the map are evaluated, and that the structure is fully evaluated too
19:39:36 <Favonia> Axman6: in general, there is no guarantee that this implementation will work. by definition it is not guaranteed to be reduced to rnf anyway.
19:40:11 <dolio> In general doesn't matter.
19:40:33 <dolio> What matters is if the procedures for each instance of NFData work.
19:40:53 <Favonia> Axman6: I agree with you that elements/keys are more important, but still it might not be in normal form.
19:41:40 <Axman6> rnf is more for practicality than a guaranteed means to making sure something is in nf
19:42:04 <parcs> :t quotRem
19:42:05 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
19:42:16 <Saizan> for that matter, there's no guarantee an instance of Monad is a monad, etc..
19:43:04 <dolio> The other objection I can think of is that rnf doesn't return the normal form of its argument like you might think.
19:43:44 <dolio> It returns a unit that, if you cause it to be evaluated, also causes thunks to be evaluated such that its argument might be normalized in some sense.
19:43:46 <Favonia> Axman6: hmm I don't want to say that it is not useful. it is just kind of misleading :P
19:44:00 <ddarius> dolio: The newer library is more like the former.
19:44:23 <ddarius> rnf is for laziness, and not the good kind of laziness.
19:45:29 <dolio> Anyhow, I never find myself needing rnf.
19:45:48 <dolio> I don't know what people use it for, really.
19:46:32 <dolio> Other than evaluating all of the input of readFile, or something, because they dislike lazy I/O.
19:46:33 <Favonia> Saizan: well those instances of NFData I just mentioned are right within the package deepseq... and its correctness depends on other packages :/
19:46:59 <ddarius> dolio: The solution to that problem is not to use lazy IO, not to use rnf.
19:47:28 <dolio> Well, using rnf is a very poor way of not using lazy I/O.
19:48:04 <ddarius> dolio: Have you made bread yet, by the way?
19:48:15 <dolio> No.
19:48:19 <Favonia> Saizan: for monads, I believe most instances of Monad can be shown "correct" by themselves. :P
19:49:06 <dolio> Maybe I'll get around to it now that my mind isn't preoccupied by housing concerns.
19:51:13 <dolio> What happened on Monday, by the way? Are we rescheduling the big get-together for some other time?
19:51:33 <dolio> copumpkin is going out of town for a week on Friday.
19:52:23 <ddarius> dolio: Nothing happened.  I haven't talked to Mo since... Thursday, I think.
19:53:43 <dolio> Don't you guys, like, work together?
19:53:59 <djahandarie> They do?
19:54:10 <djahandarie> I thought he was just some random dude ddarius met somewhere random
19:54:22 <dolio> No. They both work for the same person, at least.
19:54:34 <djahandarie> Aw, that's not as cool
19:54:59 <ddarius> dolio: I see Mo more than I see my employer whom I also see rather rarely.
19:55:15 <dolio> Huh.
19:55:58 <dolio> I suppose I technically don't see my employer very often (or ever in person), but he lives in another state.
19:56:09 * djahandarie was convinced that Mo was some guy ddarius picked off the side of the street
19:56:24 <dolio> No. edwardk picked him off the street.
19:56:25 <ddarius> djahandarie: That's a different story, and the other way.
19:56:41 <ddarius> dolio: It took Ed quite a while.
19:56:44 <djahandarie> Wait what?
19:56:50 <dolio> Yes. It's an amusing story.
19:57:28 * djahandarie is interested
19:57:43 <ddarius> This isn't really the place.
20:01:21 <Favonia> Saizan: UNPACK is really interesting. thanks for your info
20:07:03 <jagttt> Hi. I'm wondering if pattern matching like "foo (i+1) = i" still works in the current version of haskell. I've seen many examples like this on the wiki but I found that they won't work in ghci 7.0.
20:07:18 <ddarius> No it doesn't.
20:07:31 <dolio> Haskell 2010 got rid of that.
20:07:47 <ddarius> It only took twenty years.
20:07:54 <jagttt> thanks!
20:08:31 <dolio> There's an option to turn it on in GHC still, I think.
20:08:47 <lispy> yes there is
20:08:53 <lispy> But your code won't be valid Haskell2010
20:09:24 <ddarius> Which matters not at all.
20:09:27 <dolio> I don't much care about the standard.
20:09:35 <dolio> But n+k patterns are pretty evil in implementation.
20:09:51 <Favonia> jagttt: you might want NPlusKPatterns for backward compatibility?
20:09:58 <lispy> yes, they are ill specified
20:10:18 <aavogt> > let f (x+1) = x in f 0
20:10:19 <lambdabot>   <no location info>: Parse error in pattern
20:10:37 <jagttt> Favonia: I'm just learning Haskell and find this a little bit confusing :)
20:11:06 <Favonia> jagttt: then please ignore that kind of patterns :P
20:11:24 <parcs> why can't n+k patterns be syntactic sugar for (subtract k -> n)
20:11:34 <lispy> IIRC, there is a flag that specifies that you want the Haskell98 standard, but I could be wrong
20:11:37 <jagttt> Favonia: yep. thanks!
20:12:02 <ddarius> parcs: Because 1) that would be unsound, and 2) view patterns are an even heavier extension, though a much more pragmatic one.
20:12:26 <aavogt> parcs: n+k patterns don't match when the n would be negative or something
20:13:08 <dolio> I wouldn't worry that much about what n+k patterns actually did when considering what they conceivably should do.
20:13:10 <dolio> What they did was nuts.
20:13:48 <lispy> I think the only time I've ever used them was when learning about them
20:14:11 <aavogt> nuts would be if you could use the k from another pattern match
20:14:20 <aavogt> but with view patterns you can do that :)
20:15:00 <shachaf> aavogt: What if you used n+k and it arbitrarily matched some (n,k) that added up to the argument?
20:15:51 <Saizan> that'd be more fit for prolog
20:16:38 <ddarius> Or Curry.
20:16:45 <dolio> aavogt: I don't know. That might still be less nuts that translating to Integer, subtracting, and then translating back to the original type.
20:18:20 <shachaf> It only works for Integral values?
20:18:26 <dolio> Yes.
20:18:54 <dolio> And it has nothing to do with how (+) and (-) for the type are defined.
20:19:19 <dolio> Only to/fromInteger.
20:19:21 <Saizan> how in the world is that better than doing the subtraction in the original type?
20:23:07 <lispy> It's quite odd
20:23:20 <lispy> You also can't shadow (+) and (-) to change the behavior
20:25:20 <dolio> Well, that isn't so surprising.
20:55:01 <mustelo> is there a standard name or definition for the function of type (a -> b) -> (a -> c) -> a -> (b,c) ?
20:55:55 <ddarius> :t (&&&)
20:55:56 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
20:56:58 <mustelo> thanks
21:20:30 <fragamus_> > [1,2,3,4]
21:20:31 <lambdabot>   [1,2,3,4]
21:20:39 <fragamus_> > length [1,2,3,4]
21:20:40 <lambdabot>   4
21:20:54 <fragamus_> > (length [1,2,3,4]) /2
21:20:54 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
21:20:55 <lambdabot>    arising from a use o...
21:21:02 <fragamus_> > (length [1,2,3,4]) / 2
21:21:03 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
21:21:03 <lambdabot>    arising from a use o...
21:21:09 <fragamus_> hmmmm
21:22:57 <Veinor> > (fromInt . length [1,2,3,4]) / 2
21:22:58 <lambdabot>   Not in scope: `fromInt'
21:23:05 <Veinor> what's the function i'm looking for here
21:23:08 <Veinor> @hoogle Int -> Integer
21:23:08 <lambdabot> Prelude toEnum :: Enum a => Int -> a
21:23:08 <lambdabot> Data.Bits bit :: Bits a => Int -> a
21:23:08 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
21:23:18 <Veinor> > (toInteger . length [1,2,3,4]) / 2
21:23:19 <lambdabot>   Couldn't match expected type `f a'
21:23:19 <lambdabot>         against inferred type `GHC.Types...
21:23:26 <Veinor> > (toInteger . length $ [1,2,3,4]) / 2
21:23:26 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
21:23:27 <lambdabot>    arising f...
21:23:43 <Veinor> oh right
21:23:50 <Veinor> > (toEnum . length $ [1,2,3,4]) / 2
21:23:51 <Saizan> can you define non-compact types in haskell?
21:23:51 <lambdabot>   2.0
21:24:43 <shachaf> > (fromIntegral . length $ [1,2,3,4]) / 2
21:24:44 <lambdabot>   2.0
21:24:51 <shachaf> > (genericLength $ [1,2,3,4]) / 2
21:24:52 <lambdabot>   2.0
21:24:59 <shachaf> > lenght [1,2,3,4] `div` 2
21:25:00 <lambdabot>   Not in scope: `lenght'
21:25:03 <shachaf> > length [1,2,3,4] `div` 2
21:25:04 <lambdabot>   2
21:25:13 <fragamus_> thank you
21:41:26 <Lytol> hi all, I'm a bit of a Haskell noob, and I'm having trouble finding a way to take a substring by index and length (ideally)
21:42:18 <Lytol> i know i can use "take" for the first n elements, but what about an offset/starting index
21:42:18 <Veinor> > take 5 . drop 3 $ "abcdefghijklmnop"
21:42:19 <lambdabot>   "defgh"
21:42:29 <Lytol> ahhhh...
21:42:44 <Lytol> much thanks
21:45:18 <Veinor> no problem :)
21:45:42 <Veinor> note that this takes time proportional to the index of the substring
21:49:00 <dibblego> is there a plugin to derive the source to ap given a Monad instance?
21:49:22 <jmcarthur> @src ap
21:49:22 <lambdabot> ap = liftM2 id
21:49:34 <dibblego> using (>>=)/return
21:50:01 <jmcarthur> i'm guessing you mean with all the Monad stuff inlined
21:50:05 <dibblego> yes
21:50:08 <jmcarthur> i know of nothing that does that
21:50:12 <dibblego> ok ta
21:53:42 <dibblego> more to the point is there an Applicative f => StateT s f a ? I don't seem to be able to find a way without Monad f =>
21:54:28 <dibblego> er, Applicative f => instance Applicative (StateT s f)
21:55:21 <dibblego> my bones are telling me no
21:56:52 <copumpkin> State seems like one of those things that would be pretty useless without the full power of Monad
21:57:11 <dibblego> yeah my bones' thoughts exactly
21:57:30 <jmcarthur> @unmtl StateT s f a
21:57:31 <lambdabot> s -> f (a, s)
21:58:24 <jmcarthur> yeah i don't know about this one
21:58:32 <jmcarthur> i'm thinking it's not gonna happen
21:58:38 <dibblego> Applicative (State s) seems useful enough, but not Applicative f => Applicative (StateT s f)
21:58:53 <dibblego> righto thanks
21:58:57 <copumpkin> what would you do with Applicative on State?
21:59:41 <dibblego> I'll let you know when I do so :)
21:59:53 <jmcarthur> i could see using State in the implementation of something but only exposing an Applicative instance for some reason
22:00:13 <copumpkin> well, I mean more
22:00:17 <jmcarthur> but i think the inner functor in StateT would still have to be a monad
22:00:28 <copumpkin> "if we didn't have instance Monad (State s), and only had Applicative, would State still be useful?"
22:00:41 <jmcarthur> ah, no, you'd lose its generality
22:01:16 <jmcarthur> i'm not sure it would be useful at all assuming you can't just write bind yourself
22:01:30 <copumpkin> yeah, pretending it couldn't be written
22:02:25 <dibblego> yeah, good point, cheers
22:09:10 <nathanfh> Has anyone else had difficulty using cabal to install cairo?
22:13:27 <saati> after puting ~/.cabal/bin in my PATH no, it compiled smoothly
22:19:50 <c1de0x> copumpkin !
22:24:34 <kish> how do i get the percent difference between 9.85 and 8.48
22:24:40 <kish> in like a line of sweet haskell
22:24:51 <Axman6> a/b*100
22:25:06 <Axman6> > 9.85/8.48*100
22:25:07 <lambdabot>   116.15566037735847
22:25:40 <Axman6> so 9.85 is 16.15% larger than 8.48
22:27:07 <tg_> if those are penis sizes, I'm impressed!
22:27:10 <tg_> err, i'm back.
22:27:16 <tg_> s/^^//
22:33:24 <lispy> preflex: seen pastorn
22:33:24 <preflex>  pastorn was last seen on #haskell 5 days, 3 hours, 27 minutes and 14 seconds ago, saying: MaskRay: then just do it?
22:33:31 <lispy> hmm
22:37:15 <EvanR> im having trouble printing debug messages from a forkIO thread that was created from a forkIO... its just not showing up, print, putStrLn, Debug.Trace...
22:37:27 <EvanR> so i cant verify if those threads a going away when they should be
22:41:53 <Jafet> Maybe they went away too soon
22:42:57 <dmwit> EvanR: There's nothing about forkIO that should cause prints to stop appearing. So, either stdout is block buffered and you haven't filled a block, or that thread isn't getting to those prints.
22:43:13 <MaskRay> preflex: he asked me a BNF problem
22:44:05 <EvanR> dmwit: errr the other IO actions in there are occuring, the networking. and other stdout is occuring in other threads
22:44:16 <dmwit> MaskRay: preflex is a bot, I don't think it understands you =P
22:44:40 <Jafet> Let's not jump to conclusions...
22:45:01 <MaskRay> dmwit: i see..
22:45:25 <dmwit> EvanR: Wow, cool. Can you narrow it down to a small test case and put it online somewhere? I'd love to help debug it. =)
22:45:47 <EvanR> dmwit: alright, well the program is pretty small
22:45:56 <EvanR> http://codepad.org/Fb16fsdD
22:46:05 <EvanR> i cant get userThread to print anything to stdio
22:47:28 <dmwit> userThread doesn't appear to have a print anywhere.
22:47:34 <dmwit> And it looks like it has a very, very short runtime.
22:47:38 <dmwit> Like one loop in most cases.
22:47:42 <dmwit> Is that what you intended?
22:48:05 <EvanR> i removed the print from the final version
22:48:15 <EvanR> it doesnt have a short runtime
22:48:27 <EvanR> getFrame blocks
22:48:39 <dmwit> getFrame is running in a different thread.
22:48:49 <EvanR> ok
22:48:56 <EvanR> and the fix is running in another
22:49:01 <dmwit> Yes.
22:49:05 <EvanR> and it loops
22:49:09 <dmwit> But the loop in the fix probably only runs once.
22:49:14 <EvanR> why do you say that
22:49:30 <dmwit> Ah, I see. It's busy-waiting on signal.
22:49:41 <dmwit> Okay, I understand.
22:49:41 <EvanR> no, its blocking on readChan
22:49:48 <EvanR> its the best i could come up with
22:49:52 <EvanR> it fullfills the task
22:50:12 <dmwit> Right... but it only loops if the signal has been sent.
22:50:19 <EvanR> when i havent verified is if the signal thing actually works, the userThread ends at some point
22:50:26 <dmwit> If the signal hasn't been sent yet, the thread just... ends.
22:50:29 <EvanR> it only loops if the signal has not been sent?
22:50:42 <dmwit> um
22:50:52 <EvanR> signal starts empty
22:51:03 <EvanR> when (isEmptyMVar signal) do
22:51:04 <dmwit> It only loops if the signal *has* been sent.
22:51:11 <dmwit> oh
22:51:13 <dmwit> bleh
22:51:18 <dmwit> Yes.
22:51:22 <EvanR> descriptive code ftw
22:51:25 <EvanR> fail
22:51:43 <jaspervdj> mafs: https://github.com/bos/text/pull/4 should be fixed soon
22:53:15 <dmwit> Okay.
22:53:22 <dmwit> Where should I stick a print, and how do I test it?
22:59:12 <EvanR> dmwit: anywhere in userThread
22:59:23 <EvanR> to test, run it and connect to it with javascript like this
22:59:29 <EvanR> http://pastebin.com/FrvFVcbJ
22:59:31 <mauke> The paste FrvFVcbJ has been copied to http://hpaste.org/47345/httppastebincomfrvfvcbj
23:03:17 <dmwit> EvanR: network-websocket doesn't build here (I assume that's the right package?)
23:03:37 <EvanR> i did cabal install websocket
23:03:39 <EvanR> er
23:03:40 <EvanR> websockets
23:03:51 <dmwit> hokay
23:09:01 <EvanR> dmwit: gotta go to bed soon :(
23:09:12 <dmwit> still building websockets...
23:09:15 <EvanR> heh
23:09:27 <EvanR> comments and sort of clean up
23:09:28 <EvanR> http://codepad.org/WxlHFLOs
23:09:39 * hackagebot repa 2.0.2.1 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-2.0.2.1 (BenLippmeier)
23:09:41 * hackagebot repa-examples 2.0.2.1 - Examples using the Repa array library.  http://hackage.haskell.org/package/repa-examples-2.0.2.1 (BenLippmeier)
23:10:42 <dmwit> EvanR: Okay, I got it to run. But the "acceptThread" thread never gets past the "accept listener" line.
23:11:00 <dmwit> I loaded up a simple html page that just includes test.js (with your javascript in it).
23:11:27 <EvanR> well accept blocks until something tries to connect
23:11:33 <EvanR> also port 9999 is wrong
23:11:35 <EvanR> its 8088
23:12:05 <dmwit> oh right
23:12:28 <dmwit> Ah, that helps. =)
23:13:22 <dmwit> userThread makes plenty of output for me.
23:13:28 <EvanR> hmm.
23:13:37 <EvanR> what did you use to print
23:14:20 <dmwit> putStrLn
23:14:41 <EvanR> if you close your browser or close the tab or refresh, can you verify the thread ends?
23:15:43 <dmwit> How would I verify that?
23:15:57 <EvanR> a print after the fix occurs
23:16:04 <dmwit> No, it doesn't seem to.
23:16:10 <EvanR> or after the when
23:16:41 <EvanR> if one occurs after the getFrame, well thats good, at least the stuff i have no control over works
23:17:20 <dmwit> Yes, I put a print after every line, and they all seem to fire (except the ones after the when).
23:17:37 <EvanR> including the one after getFrame?
23:17:48 <dmwit> yes
23:18:01 <EvanR> so its putting () into the mvar...
23:18:06 <dmwit> Yes.
23:18:17 <dmwit> Gotta go to bed now. Good luck!
23:18:23 <EvanR> me too
23:18:29 <EvanR> :((( memory leaks on the horizon...
23:26:54 <mafs> jaspervdj: Yay! Thanks for getting around to that
23:27:43 <mafs> Didn't know text was on github either. thought it was on bitbucket
