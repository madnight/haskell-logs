00:11:52 <erus`> 7.0.4 is bug fixes?
00:12:11 <koala_man> can someone give me an example implementation of a function that uses rank 2 types to prevent types from escaping, like runST does?
00:13:11 <femarie> hello.. i have a question
00:13:28 <femarie> hello?
00:13:32 <femarie> anybody here?
00:13:55 <tibbe> erus`, yes
00:14:00 <tibbe> femarie, yes?
00:14:01 <RayNbow`TU> don't say you have a question, just ask the question and hope someone replies ;)
00:14:42 <femarie> how can we create alternative notations to these functions:
00:14:50 <femarie> P- 1100
00:14:55 <femarie> Q-1010
00:15:05 <femarie> f0- 0000
00:15:13 <femarie> f1- 0001
00:15:19 <femarie> f2- 0010
00:15:28 <femarie> f3-0011
00:15:38 <femarie> f4-0100
00:15:44 <femarie> f5-0101
00:15:53 <femarie> f6-0110
00:16:00 <femarie> f7-0111
00:16:05 <luite> hmm, better use hpaste.org
00:16:13 <Cale> femarie: You might want to explain how those are notations for functions in the first place, and if you have more than a few lines of text, use a paste site like hpaste
00:16:27 <taotree> I switched all the modifyIORef's to atomicModifyIORef's but it's still hanging.
00:16:56 <luite> taotree: if you have multiple threads working on those things, MVar might be more appropriate than IORef
00:17:03 <femarie> our teacher said that alternative notations in haskell
00:17:22 <femarie> he said that it is via haskell
00:18:24 <femarie> how can i use i use this hpaste.org?
00:18:36 <Cale> http://hpaste.org/new
00:19:36 <koala_man> is it possible to write functions with semantics similar to runST (in terms of preventing references from escaping) or is that compiler magic like IO?
00:20:01 <femarie> taotree: what is that IORef and MVar?
00:20:12 <mustelo> name that function? f (y:ys) x = if x == y then x else f ys y
00:20:28 <pikhq> koala_man: The preventing references from escaping bit is actually just clever type-level magic, IIRC.
00:20:32 <luite> koala_man: you need higher rank type variables for that, that's a GHC extension
00:20:37 <luite> but not specific to ST
00:20:43 <shachaf> I think in principle all of ST could be implemented purely.
00:20:50 <shachaf> luite: You need that for regular ST too. :-)
00:21:10 <luite> well, ST isn't haskell 98 or 2010 is it?
00:21:11 <taotree> mustelo, name it? it's a find function. I was just using that today on a Seq
00:21:17 <pikhq> koala_man: The only compiler magic is making it actually run as though it were IO, but pure.
00:21:28 <taotree> oh wait... there's a y at the end
00:21:31 <mustelo> taotree, just wondering if it exists somewhere I don't know about
00:21:37 <pikhq> Yeah, I know of know reason it couldn't be pure.
00:21:38 <koala_man> I have RankNTypes enabled, but I can't quite figure how to write such functions
00:21:43 <femarie> cale: can you help me how to answer my question? i'm still a beginner.. i'm just confused on what our professor assigned to us
00:21:46 <taotree> mustelo, shouldn't it be x at the very end?
00:22:04 <mustelo> taotree, no, then it would just be find
00:22:24 <taotree> mustelo, oh, you're looking for duplicates right next to each other?
00:22:26 <Cale> femarie: I'm equally confused. The things you wrote might have some definition in your book or course, but they're not obviously Haskell code.
00:22:29 <mustelo> taotree, right
00:22:45 <RayNbow`TU> mustelo: what would the initial value for x mean?
00:22:46 <taotree> mustelo, ok, don't know if it exists
00:23:21 <Cale> femarie: If I had to guess, maybe they're supposed to be truth tables for boolean functions?
00:23:33 <Cale> femarie: But it's not clear without more context.
00:23:38 <mustelo> RayNbow`TU, ah, sorry, that's an excerpt from the full definition, which calls f (tail l) (head l) on an original list. does that make sense? I can hpaste if you want
00:24:04 <RayNbow`TU> mustelo: ah ok
00:24:26 <mustelo> I guess I'm asking if there's a way to write this thing without explicit recursion
00:24:30 <erus`> this would be cool : > let x = 2 5 in (+) x
00:24:31 <RayNbow`TU> can't you just call it f and give a meaning full name to the function that calls f?
00:25:02 <Cale> mustelo: could you hpaste?
00:25:17 <othiym23> mustelo: what's the problem with the recursion?
00:25:46 <Cale> erus`: except that's bracketed the wrong way implicitly
00:26:00 <hpaste> mustelo pasted “findFirstDup” at http://hpaste.org/47867
00:26:06 <Cale> (+) 2 5 means ((+) 2) 5, rather than (+) (2 5)
00:26:25 <frerich> mustelo: Just to make sure I got this right - the function should yield the first item which appears multiple (subsequent) times in the list? E.g. "Yadda" should yield 'd'?
00:26:35 <taotree> luite, thanks for the suggestion on MVar. I guess I'll have to go learn about them.
00:26:45 <mustelo> findFirstDup [1,2,3,3] -> 3
00:27:05 <mustelo> frerich, right
00:27:06 <Cale> > concat . map tail . group $ "Hello, world!"
00:27:07 <femarie> cale: yes.. you're right
00:27:08 <lambdabot>   "l"
00:27:30 <Cale> > concat . map tail . group $ "abcde"
00:27:30 <RayNbow`TU> @let findAdjacent xs = listToMaybe [y | (x:y:_) <- tails xs, x == y]
00:27:31 <lambdabot>   ""
00:27:31 <lambdabot>  Defined.
00:27:39 <RayNbow`TU> > findAdjacent "Yadda"
00:27:41 <lambdabot>   Just 'd'
00:27:47 <Cale> > concat . map tail . group $ "Yadda"
00:27:49 <lambdabot>   "d"
00:28:47 <mustelo> > concat . map tail . group $ "xaabb"
00:28:49 <lambdabot>   "ab"
00:28:52 <RayNbow`TU> oh, Cale's solution is nicer :p
00:29:44 <frerich> It should get a 'head' so that it yields 'd' instead of ['d'] for "Yadda".
00:29:45 <Cale> Or even...
00:30:14 <luite> > (group >=> tail) "hello"
00:30:15 <lambdabot>   "l"
00:30:26 <Cale> > tail <=< group $ "Yadda"
00:30:27 <lambdabot>   "d"
00:30:27 <Cale> yeah
00:30:33 <RayNbow`TU> frerich: head is unsafe :p
00:30:54 <tensorpudding> that's some fancy code golf there
00:30:57 <frerich> > head . head . filter ((> 1) . length ) . group $ "Yadda"
00:30:58 <lambdabot>   'd'
00:31:00 <Cale> listToMaybe is safe though
00:31:07 <mustelo> oooh, those are pretty luite, Cale
00:31:14 <tensorpudding> i was going to say, you've got concat and map there
00:31:58 <tensorpudding> but concatMap is >>= isn't it
00:32:10 <Cale> concat and map can be combined to give concatMap which is the =<< for the list monad, but since we want a function anyway, <=< makes it nicely points free
00:32:30 <tensorpudding> ah, right, arguments reversed
00:32:39 <luite> tensorpudding: yeah but >=> works better here because there's a function on the left side
00:32:43 <tensorpudding> yeah
00:35:27 <mustelo> thanks all
00:39:31 <femarie> help me please:
00:39:50 <femarie> what are the alternative notations of these functions  P-0011 Q- 0101 f0- 0000- contradiction f1- 0001-nor f2- 0010-not P ^ Q f3- 0011-not P f4- 0100- not (if P then Q) f5-0101-not Q . . . f15-1111- tautology  note: alternative notations in haskell
00:42:25 <yitz> @type (<=<)
00:42:26 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
00:42:52 <luite> femarie: still doesn't look very haskellish... but I guess they are truth tables for PQ, P(~Q), (~P)Q, (~P)(~Q) respectively?
00:43:50 <luite> femarie: in haskell you'd write it something like: f :: Bool -> Bool -> Bool,   f p q = not p
00:45:34 <femarie> luite: really? help me how to use haskell
00:45:37 <femarie> please
00:46:19 <femarie> yes.. somewhat like that.. all are the truth tables for PQ
00:46:50 <luite> femarie: have you installed the haskell platform? if not, download it from here: http://hackage.haskell.org/platform/
00:52:32 <taotree> ah, this is painful. I switched it to use MVars and still the same hanging.
00:52:59 <Cale> taotree: What is your program doing?
00:54:22 <femarie> are you all a programmer here?
00:54:57 <femarie> who knows erlang?
00:55:14 <soulthreads> erlang in #erlang
00:55:26 <femarie> <calle, luite: thank you s for your help
00:55:45 <femarie> soulthreads: yes?
00:56:35 <soulthreads> felher, just try.
00:58:02 <femarie> luite: i cant install haskell here... does this http://tryhaskell.org/ could help me?
00:58:28 <erus`> can i Turn an ordered type into an int somehow?
00:58:30 <luite> femarie: a little, but it's very limited
00:59:02 <luite> erus`: if it's an Enum, you can use fromEnum
00:59:03 <erus`> @hoogle Ord -> Int
00:59:03 <lambdabot> Warning: Unknown type Ord
00:59:03 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
00:59:03 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
00:59:31 <erus`> perfect thanks luite
00:59:33 <femarie> do you know how to start  in using it with my problem
00:59:46 <taotree> Cale, I think it's deadlocking or something... I'm creating an opengl window, doing some calculations, and running mainloop
00:59:51 <femarie> luite: do you know how to ?start  in using it with my problem
01:00:26 <luite> femarie: you can type things like: let notP p q = not p in notP True False
01:00:49 <luite> > let notP p q = not p in notP True False
01:00:50 <lambdabot>   False
01:01:35 <luite> femarie: but for it to be really useful, you'd have to install the haskell platform. then you can make your own file with boolean functions, and make functions to print their truth tables
01:01:44 <tensorpudding> > let notP p q = not p in notP True undefined
01:01:45 <lambdabot>   False
01:03:53 <erus`> luite: do you know how i can get all possible combinations of n items from a set?
01:05:16 <femarie> luite: thanks.. though i still couldnt get it, i am glad that you undoubtly helped me...
01:05:23 <femarie> got to go.. bye
01:06:30 <augur> anyone interested in reading a linguistics paper that uses haskell? :D
01:06:49 <augur> not only haskell, but /completely untested haskell/? lol
01:06:50 <Nisstyre> yes
01:07:11 <luite> > let comb n = filter ((==n).length) . subsequences . nub in comb 2 "hello"
01:07:12 <lambdabot>   ["he","hl","el","ho","eo","lo"]
01:07:31 <luite> first try, but horribly inefficient
01:08:06 <augur> Nisstyre: http://wellnowwhat.net/linguistics/AProgrammaticApproachToBracketingParadoxes.pdf
01:09:21 <mm_freak> i was bored
01:10:34 <mm_freak> the shortest fully lazy function i could come up with to split a string into comma-separated words:
01:10:37 <mm_freak> unfoldr$(*>)<$>listToMaybe<*>pure.(id***drop 1).span(/=',')
01:10:49 <mm_freak> (only using the base library, of course)
01:11:48 <luite> @type splitOn
01:11:49 <lambdabot> Not in scope: `splitOn'
01:11:52 <luite> aw
01:14:22 <erus`> combinations n xs = [ y:ys | y:xs' <- tails xs, ys <- combinations (n-1) xs']
01:14:26 <erus`> is that quick?
01:14:30 <mm_freak> luite: the base library doesn't have that ;)
01:14:46 <mm_freak> erus`: are you looking for replicateM?
01:15:05 <mm_freak> > replicateM 5 "abc"
01:15:06 <lambdabot>   ["aaaaa","aaaab","aaaac","aaaba","aaabb","aaabc","aaaca","aaacb","aaacc","a...
01:15:29 <Axman6> > replicateM 10 "01"
01:15:30 <lambdabot>   ["0000000000","0000000001","0000000010","0000000011","0000000100","00000001...
01:15:34 <erus`> mm_freak: no its cant duplicate items
01:15:41 <Axman6> > replicateM 5 "01"
01:15:42 <lambdabot>   ["00000","00001","00010","00011","00100","00101","00110","00111","01000","0...
01:15:44 <erus`> im generating every poker hand
01:15:50 <mm_freak> erus`: so permutations
01:15:52 <erus`> so i cant use a card twice
01:15:55 <mm_freak> > permutations "abcde"
01:15:56 <lambdabot>   ["abcde","bacde","cbade","bcade","cabde","acbde","dcbae","cdbae","cbdae","d...
01:15:56 <mjrosenb> > let combinations n xs = [ y:ys | y:xs' <- tails xs, ys <- combinations (n-1) xs'] in combinations 3 "abcde"
01:15:57 <lambdabot>   []
01:16:15 <mm_freak> erus`: the 'permutations' function in Data.List is very fast and very lazy
01:16:17 <erus`> can i permutate 52 items in less than a long time?
01:16:24 <mm_freak> let's see
01:16:38 <sipa> erus`: you want one permutation, or all?
01:16:57 <mm_freak> > product [2..52] / (product [2..47] * product [2..5])
01:16:58 <erus`> i need every combination of 5 items for a list of 52
01:16:58 <lambdabot>   2598960.0
01:17:06 <mjrosenb> permutations will still be slow, because you're discarding 99% of the permutations
01:17:10 <mm_freak> erus`: probably no
01:18:17 <mjrosenb> erus`: also, you seem to discard every other element.
01:18:23 <mjrosenb> > let combinations n xs = [ y:ys | y:xs' <- xs, ys <- combinations (n-1) xs'] in combinations 3 "abcde"
01:18:24 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
01:18:31 <mm_freak> although haskell can iterate 2 million entries quickly, you will have to write your own permutation function
01:18:35 <frerich> erus`: You could simplify the problem by treating two hands to be equal even if the order of cards is different. That means there are a lot less "different" hands.
01:18:35 <sipa> > [ [a,b,c,d,e] | a <- [0..47], b <- [a+1..48], c <- [b+1..49], d <- [c+1..50], e <- [d+1..51] ]
01:18:36 <lambdabot>   [[0,1,2,3,4],[0,1,2,3,5],[0,1,2,3,6],[0,1,2,3,7],[0,1,2,3,8],[0,1,2,3,9],[0...
01:19:14 <mm_freak> the Data.List function can only generate the whole set, which is huge
01:19:20 <mm_freak> > product [2..52]
01:19:20 <lambdabot>   80658175170943878571660636856403766975289505440883277824000000000000
01:19:30 <mm_freak> but you need only a small subset
01:19:51 <mjrosenb> > product [47..52]
01:19:52 <lambdabot>   14658134400
01:19:58 <mjrosenb> a very small subset
01:20:11 <erus`> my function takes about 3 secs in ghci
01:20:28 <erus`> i only need todo it once
01:20:29 <mm_freak> > product [48..52] `div` product [2..5]
01:20:30 <lambdabot>   2598960
01:20:33 <mjrosenb> erus`: the one you entered is kinda borked.
01:20:34 <mm_freak> you need that many
01:20:57 <erus`> 2598960 == length $ combinations 5 [0..51]
01:21:07 <erus`> that matches the wiki article
01:21:10 <mjrosenb> or maybe not.
01:21:47 <mjrosenb> combinations 3 "abcde" should not have returned the empty list when i tried it :(
01:22:07 <mm_freak> erus`: purely from a performance standpoint your function looks fine to me, if it works
01:22:14 <erus`> it needs "combinations 0 _  = [ [] ]" too
01:22:29 <erus`> mm_freak: ok thats good then
01:22:32 <mm_freak> i'm not so good at parsing list comprehensions, because i like to avoid them
01:23:08 <mjrosenb> oh hey
01:23:11 <mjrosenb> tails != tail
01:23:28 <erus`> will the haskell default hash tabe perform ok with 2 million indexes?
01:23:37 <mjrosenb> yeah, that would be why i'm not understanding it
01:23:41 <mm_freak> what is the default hash table?
01:23:50 <erus`> whatever is in the platform
01:23:51 <frerich> erus`: I think there's still some performance hit; eventually, you will traverse your list of 2.6 million items. I believe it would be useful to not consider hands different just because the order of cards is different.
01:24:16 <mjrosenb> frerich: the way he is constructing it, there should not be any duplicates
01:24:17 <erus`> frerich: how can i remove duplicates?
01:24:23 <mjrosenb> frerich: they should always be sorted.
01:24:47 <mjrosenb> > let combinations 0 _ = [[]]; combinations n xs = [ y:ys | y:xs' <- xs, ys <- combinations (n-1) xs'] in combinations 3 "abcde"
01:24:48 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
01:24:55 <mjrosenb> > let combinations 0 _ = [[]]; combinations n xs = [ y:ys | y:xs' <- tails xs, ys <- combinations (n-1) xs'] in combinations 3 "abcde"
01:24:56 <lambdabot>   ["abc","abd","abe","acd","ace","ade","bcd","bce","bde","cde"]
01:24:58 <mm_freak> frerich: your statement contradicts with him getting 2 million entries
01:25:16 <mm_freak> 2598960 entries = sorted
01:25:21 <mm_freak> unsorted would be 120 times that size
01:26:07 <frerich> Ah, I thought 2.6 million would be unsorted already. That's still a lot of data to hold given that you will probably just use a little bit of it.
01:26:39 <mm_freak> i don't know the application, but 2.6 million entries are very feasible to iterate with haskell
01:26:59 <sipa> > length [ [a,b,c,d,e] | a <- [0..47], b <- [a+1..48], c <- [b+1..49], d <- [c+1..50], e <- [d+1..51] ]
01:27:01 <lambdabot>   2598960
01:27:14 <sipa> lambdabot just iterated them all
01:27:57 <mm_freak> oh, i'm seeing my favorite pattern again
01:27:59 <mm_freak> foldM
01:28:38 <frerich> sipa: When I said "you will traverse your list" I was actually thinking of "you will traverse and do something with your list". Of course simply iterating the list itself is not very expensive.
01:29:12 <frerich> sipa: My point is that 2.6 million is not a small factor, so whatever function is done over the list should better be cheap - or you avoid creating the list in the first place.
01:29:58 <mm_freak> frerich: how would you do it without a list?  i can only imagine sets to be faster, but still having lists as input
01:30:20 <mm_freak> but the sets would be too small to justify the data structure, i think
01:30:31 <mm_freak> lists can be fused away after all
01:31:25 <frerich> mm_freak: It depends on what the list is used for (and my suspicion is that whatever it is, you don't need a list for it). For instance, for generating hands for a game you don't need to know all of them.
01:31:57 <frerich> Anyway, if it works good enough there's no reason to bother. :-)
01:33:20 <mm_freak> frerich: i think you shouldn't conclude anything here, because it's not that you know little about erus`' application, but you know nothing…  some people may interpret your statement as an imputation
01:33:50 <frerich> mm_freak: Didn't he talk about his application in the last days? I seem to recall it's a card game.
01:34:07 <frerich> Maybe I'm confusing this with somebody else.
01:35:09 <mm_freak> i don't know, but i can tell you that lists are perfectly fine for /generating/ permutations, and that's what he's doing
01:35:22 <mm_freak> if used properly, the lists will disappear in the executable
01:39:28 <frerich> Sure, I'm just testing whether this is an XY problem.
01:56:25 <bartwe> Hi, the icfp contest starts in less then a day, are #haskell-ers competing ?
01:57:19 <mjrosenb> bartwe: i am, although it is unclear if my group is going to use sml or haskell at this point.
01:57:39 <bartwe> sml ?
01:57:45 <mjrosenb> :(
01:58:39 <mjrosenb> the grandfather of all statically typed functional languages
01:58:46 <mjrosenb> distant cousin to ocaml
01:59:18 <bartwe> I haven't been to LtU in a long while, i guess this was GC'ed
02:14:34 <erus`> sorting 2 million hands by strength is taking a while
02:14:39 * hackagebot runghc 0.1 - runghc replacement for fast repeated runs  http://hackage.haskell.org/package/runghc-0.1 (MikeZuser)
02:16:18 <mjrosenb> erus`: sorting 2,000,000 ints took about 2 seconds.  if your compare function is signifigantly slower, that is quite reasonable.
02:16:46 <erus`> its been about 60 secs :(
02:17:09 <erus`> done
02:17:39 <erus`> the worst poker hand is a 7 5 4 3 2 unsuited
02:18:09 <luite> are you going to make huge bucks on online poker sites with your haskell poker ai?
02:18:58 <erus`> nah they watch that kinda thing now
02:19:05 <erus`> you can get in trouble
02:19:34 <mjrosenb> erus`: how long does it take to find the best hand?
02:20:08 <bartwe> kind of annoying that icfp requires a guest vm to be 64it, i don't have access to a 64bit host
02:20:11 <luite> erus`: do they check for patterns?
02:20:40 * hackagebot runghc 0.1.0.1 - runghc replacement for fast repeated runs  http://hackage.haskell.org/package/runghc-0.1.0.1 (MikeZuser)
02:20:41 <erus`> luite: yep, so that means no playing more than a few tables at a time
02:20:47 <mjrosenb> bartwe: if you're on a team, then chances are *someone* will.
02:20:57 <erus`> and bots only play on $1 tables so thats about $5 an hour
02:21:01 <erus`> not worth it
02:21:33 <erus`> (this is only stuff i have heard/read)
02:21:49 <bartwe> mjrosenb: i'm not on a team however
02:22:03 <luite> bah, it could've been the greatest commercial success for haskell so far ;)
02:22:18 <bartwe> mjrosenb: i wasn't aware that 64 bit was common enough to see it as a requirement
02:23:30 <erus`> haha
02:23:32 <bartwe> har
02:25:25 <mjrosenb> bartwe: well, basically every machine made in the last 5 years has been amd64
02:27:39 <luite> some atoms didn't support it
02:27:58 <mjrosenb> interesting.  i thought all atoms were 64 bit
02:28:03 <bartwe> i think atleast one of my machines does have a capable cpu, but the os isn't
02:28:25 <mjrosenb> bartwe: :(
02:28:40 * mjrosenb has always run a 64 bit os on 64 bit hardware
02:29:08 <bartwe> steam hardware survey ony shows about 50% 64 bit capable window instalations
02:29:18 <luite> mjrosenb: maybe the most recent ones are, but I have an atom N270, which is only 2 years old or so, which doesn't support amd64
02:29:34 <bartwe> now that i think about it i did run 64bit debian on this machine, but it failed to support my monitor setup
02:31:59 <luite> hmm, even the most recent atom Z series don't support it
02:32:08 <mjrosenb> luite: i think i have a N310, and it is amd64.
02:32:22 * mjrosenb will need to keep this in mind when purchasing a new router.
02:42:51 <dreixel> any clue on why hackage fails to build this? http://hackage.haskell.org/packages/archive/instant-generics/0.3.2/logs/failure/ghc-7.0
02:43:48 <mjrosenb> dreixel: not horribly useful, but it looks like syb is missing
02:45:31 <dreixel> but why would syb be missing?...
02:45:44 <dreixel> http://hackage.haskell.org/package/syb-0.3.2 built
02:48:07 <mjrosenb> i don't know how hackage works, is it possible that the different packages are sandboxed?
03:16:50 <ksf> "xplat: the underlying graph of a category is transitive. transitive graphs have no bridges. this is why trolls always have problems with category theory."
03:17:06 * ksf nominates that for the haskell quote of the century.
03:36:29 <erus`> if i have a function "something = someBigOperation" in a file, will it be evaluated every time i call it?
03:37:15 <benmachine> erus`: I don't think so (but in theory the compiler can do that if it wants)
03:37:41 <ben> does it help to put the noinline pragma?
03:41:14 <Eduard_Munteanu> I don't think it's about inlining as much as sharing.
03:42:03 <benmachine> well, inlining defeats sharing
03:42:16 <benmachine> but GHC will probably only inline if it's a sensible thing to do I imagine
03:43:56 <Eduard_Munteanu> erus`: can you paste what you have?
03:44:02 <Eduard_Munteanu> You could also profile to tell.
03:45:15 <ksf> erus`, the question is whether it's a CAF or not.
03:45:15 <rtharper> benmachine: GHC's inliner does not always behave as expect, it's a good idea to specify the behaviour if you want a function to be treated a certain way
03:45:34 <ksf> ghc inlines, but quite conservatively.
03:45:54 <rtharper> Aye, which is the desirable default behaviour, imo
03:46:00 <ksf> ...it first has to strictify stuff, anyway.
03:46:11 <benmachine> rtharper: sure, but I'd say you should have a pretty firm idea both of what GHC is doing and what it should be doing before you go around adding annotations to everything
03:46:35 <ksf> inlining doesn't really buy you anything out of tight loops
03:46:54 <hpaste> erus` pasted “poker hands” at http://hpaste.org/47872
03:47:24 <ksf> chances are your algorithm is cache-bound even before optimising.
03:47:28 <erus`> if i have multiple calls to total hands, i dont want it calculating sortedHands everytime
03:48:07 <ksf> sortedHands is a CAF if I've ever seen one.
03:48:12 <ksf> totalHands too.
03:48:35 <Eduard_Munteanu> sortedHands should be shared fine I think
03:48:36 <ksf> ...both are going to be executed exactly once.
03:48:37 <benmachine> erus`: they will probably be kept in memory the first time they are calculated
03:48:52 <ksf> erus`, if in doubt, have a look at the core.
03:48:58 <benmachine> erus`: which means they're not recalculated but also means they're keeping memory
03:49:39 <ksf> ...such rather short+simple programs are a great way to get a grip on core.
03:50:05 <quicksilver> ksf: "inlining doesn't really buy you anything out of tight loops"
03:50:22 <quicksilver> ksf: that's not really so, in haskell - inlining is the first step to many of GHC's optimisations.
03:50:38 <Eduard_Munteanu> Well, not only in Haskell
03:50:40 <ksf> as in specialising, yes.
03:50:45 <quicksilver> ksf: inlining permits specialisation, and it permits SpecConstr, and it permits RULES
03:50:55 <ksf> ...but I count that as a seperate one to inlining proper.
03:51:19 <quicksilver> GHC inlines functions rather agressively, but tends not to inline values like the CAFs under discussion here.
03:52:35 <ksf> erus`, also do a simple profiling run. it will tell you how often each top-level symbol has been entered.
03:52:37 <Eduard_Munteanu> Can't you get both in theory? I mean, inline but place a check to see if the global copy has been evaluated.
03:52:51 <ben> That rather seems to defeat the purpose?
03:53:00 <erus`> ksf: is there any simple docs on the ghc profiling tools?
03:53:13 <ksf> compile with -prof -auto-all
03:53:15 <ben> I mean by checking whether the global copy has been evaluated, wouldn't you have to put it into cache to begin with?
03:53:19 <ksf> then run with +RTS -p
03:53:35 <ksf> wait, there's a new option ghc needs to enable the +RTS syntax in the first place
03:53:59 <Axman6> -rts-opts i think
03:54:02 <Axman6> or --
03:54:40 <ben> core is full of type annotations :o
03:54:53 <ksf> erus`, http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/profiling.html has a good introduction to the basics
03:55:35 <ksf> the rest is basically experience, unless you want to profile concurrency, for which we have threadscope.
03:56:27 <ksf> Eduard_Munteanu, the indirection will hardly be noticed by most processors, anyway.
03:57:12 <Eduard_Munteanu> I guess it won't help in most cases, I was rather thinking about transformations that could be enabled than the actual calling sequence
03:57:23 <ksf> the jump to the CAF is unconditional, and if ghc outputs remotely smart assembly, "value already there" is the fast path.
03:57:35 <ksf> so you don't stall the pipeline.
03:59:57 <aleator_> Hi, How do I tell haskell-platform not to install GL?
04:00:27 <erus`> my approach is hopeless
04:00:48 <erus`> im sorting hands by strength but theres many hands with equal strength :/
04:01:18 <ben> the CAF is gonna be represented by some instructions that either return a pointer to the value or jump to some code that computes the value, updates the thunk and then returns it, right?
04:01:34 <ben> I'm trying to get my head around the indirections involved
04:02:00 <ksf> erus`, well, that's still an ordering.
04:02:31 <ksf> ben, yep.
04:03:14 <erus`> ksf: except i was gonna use the list to give my AI a rating for the hand
04:03:31 <erus`> but it will think two identical hands have different ratings
04:03:43 <ksf> try "groupBy"
04:05:00 <erus`> groupBy what though?
04:05:03 <ksf> actually, group would suffice if you implement the Ord instance as the value comparison, but as there are multiple ways to order them, I'd go without an Ord instance.
04:05:20 <erus`> yeah i implemented Ord for hands
04:05:31 <ksf> erus`, (==)
04:05:47 <ksf> group = groupBy (==)
04:06:18 <ksf> in the same spirit as sort = sortBy compare
04:06:35 <erus`> so after grouping  sorted hands i have a [[Hand]] in order of strength. now how can I lookup a hand quickly...
04:06:51 <erus`> for example
04:06:57 <erus`> i want its index in the list
04:07:15 <ksf> lists are designed for lookup by index
04:07:19 <augur> i wonder if sleep-sort can be used to actually sort something in reasonable time
04:07:47 <ksf> erus`, I don't think you should bother about the data structure, though, just abstract it away.
04:07:50 <erus`> augur: on reddit someone multiplied to time to sleep by .001
04:08:03 <ksf> ...and think about it if/when it's necessary.
04:08:24 <augur> erus`: i was thinking more where you spin off the threads and then somehow force them to collapse immediately but in order
04:08:25 <erus`> ok
04:08:49 <ben> augur: so just steal the scheduler's data structures?
04:08:56 <augur> almost
04:09:04 <augur> i mean, not actually using the scheduler itself
04:09:40 <augur> but somehow taking the data, pushing it directly into an inherently ordered domain, and then just reading off the things in that domain
04:11:58 <augur> someone on hn suggests using hardware
04:12:21 <ksf> augur, I don't think it's possible to register a wait without piggy-backing on the sorting algorithm of the dispatcher.
04:12:38 <augur> which is a possibility. push the data down into binary registers at the numbered address
04:13:02 <augur> then cascade some sort of memory read type thing
04:13:16 <Eduard_Munteanu> Hm, interesting, I just looked it up
04:13:57 <Eduard_Munteanu> But it's O(n^2) AFAICT
04:14:02 <ezyang> Anyone still looking for housing for Hac Phi?
04:14:02 <lambdabot> ezyang: You have 1 new message. '/msg lambdabot @messages' to read it.
04:14:39 <augur> Eduard_Munteanu: take the log!
04:14:50 <Eduard_Munteanu> Erm, not n^2.
04:14:55 <ezyang> maybe I'll hostel it, like I did while I was traveling Europe.
04:14:56 <augur> or the inverse of any monotonically increasing function
04:15:53 <augur> ezyang: im probably going to stay in a hostel or something too. or a hotel if i have the money.
04:16:08 <Eduard_Munteanu> O(v^2) where v is the max value I think
04:16:16 <augur> i guess sleep sort is sort of like a bucket sort with (almost) non-discrete buckets
04:16:43 <erus`> ksf: is there anything special about group
04:17:06 <erus`> i should be getting 75432 distinct hands
04:17:08 <Eduard_Munteanu> Suppose the input was [1..n], then you had to sleep for 1 + 2 + ... + n = n (n + 1) / 2 ~ O(n^2)
04:17:21 <Eduard_Munteanu> So I guess it's at least that.
04:17:24 <erus`> i get 7462*
04:17:33 <augur> yeah, worst case n^2 for n the max of the numbers
04:17:40 <Axman6> Eduard_Munteanu: no, the maximum time spent sleeping is n
04:18:02 <Eduard_Munteanu> Axman6: I meant for the whole sort to complete.
04:18:07 <augur> Axman6 is correct actually
04:18:14 <augur> you sleep for the longest n
04:18:23 <augur> because you have multiple threads
04:18:25 <Axman6> that's the reason it works, a thread is spawned for each element, and and each thread returns after n seconds
04:18:26 <augur> not one thread
04:18:34 <Eduard_Munteanu> Oh, right
04:18:46 * Axman6 -> home
04:19:18 <Eduard_Munteanu> So it's O(n) but not in the input size
04:19:32 <Eduard_Munteanu> but the actual values there
04:19:55 <augur> yeah
04:20:42 <Eduard_Munteanu> I think you can also get the min and max in O(n) (n = input length) to prescale them.
04:21:25 <augur> Eduard_Munteanu: well you could also just scale it by an arbitrarily small number and as long as you have temporal resolution to match, youll be fine
04:22:00 <augur> or scale it by some sigmoid function
04:22:20 <Eduard_Munteanu> Yeah, and offset so you can sort negatives too.
04:22:33 <augur> aha! thats how you can sort arbitrarily large numbers of numbers with arbitrarily large size!
04:23:19 <augur> if you have continuous time resolution, just map every number through a sigmoid with some arbitrarily small size
04:23:34 <augur> you could sort almost instantly for any list!
04:23:53 <yhosok> when monad comprehension comming?
04:23:54 <Eduard_Munteanu> Heh, though in reality sleeping is best-effort
04:24:05 <augur> Eduard_Munteanu: shh thats not the point
04:24:09 <augur> this is hypothetical
04:24:11 <Eduard_Munteanu> :)
04:24:27 <augur> we've just invented the idea sorting algorithm, it just depends on impossible computers :D
04:25:09 <Eduard_Munteanu> Now who came up with sleep-sort? Some random 4chan guy, really? :)
04:25:15 <augur> yeah
04:25:18 <augur> crazy innit?
04:25:20 <Eduard_Munteanu> *sigh*
04:25:51 <augur> but there are lots of smart people who hang out on the chans
04:25:53 <augur> its odd
04:26:11 <Eduard_Munteanu> Oh, I see somebody saying this is actually a case of bucket sort.
04:26:41 <augur> i said that earlier
04:26:48 <augur> im glad im not alone in thinking this
04:26:51 <augur> its continuous bucket sort
04:27:08 <augur> well, discrete if you have discrete time steps
04:27:19 <Twey> yhosok: Next release, I believe
04:28:10 <ezyang> suppose I have two boolean conditions A and B, and I do three different things: (A && B, A && ~B, ~A). What's the best way to setup the guards for this?
04:28:27 <augur> ezyang: what
04:28:30 <ezyang> right now I have A in the guard, and then an if checking B, but I'm wondering if I should put B in the guard too.
04:28:40 <ezyang> let me paste it, it'll be clearer.
04:29:21 <ezyang> http://hpaste.org/47873
04:29:29 <ezyang> I'm trying to decide between the top or bottom.
04:29:31 <Eduard_Munteanu> I'd think you want to do the faster check first, if there's one.
04:30:16 <ezyang> A is the faster check, and fortunately, that's how it splits too.
04:30:21 <augur> ezyang: its the same thing isnt it
04:30:35 <augur> do whichever is clearer to you
04:30:37 <ezyang> yes. This is purely a stylistic question.
04:30:46 <ezyang> I don't know! :-(
04:30:49 <Eduard_Munteanu> Also probably the most common case first.
04:31:10 <Eduard_Munteanu> If their likelihood is really biased.
04:35:34 <ksf> the actual ingenuity of sleepsort is realising that a complexity theorist's mind will asplode while trying to decide whether sleep(n) is O(1) or O(n).
04:36:33 <ksf> ezyang, !b !a a b
04:36:36 <ezyang> Nah, complexity theorists are well aware of the dependence of complexity on your measure of n.
04:36:49 <ezyang> Hm?
04:37:05 <ksf> (I seriously don't know how I come up with those, I have a ROM routine for such stuff)
04:37:15 <ksf> ezyang, checking order.
04:37:34 <ksf> wait, it's incomplete.
04:37:42 <ksf> no, it isn't.
04:37:59 <ezyang> So, it is true that I could do the b check first.
04:38:02 <ezyang> but it's more expensive.
04:38:14 <yhosok> Twey: thanks
04:38:35 <ezyang> wait wait.
04:38:46 <ksf> yeah, checking a first is better.
04:39:25 <ksf> ezyang, what about toEnum and dispatch on number?
04:39:38 <ezyang> I can do this http://hpaste.org/47873
04:40:10 * hackagebot ivor 0.1.14.1 - Theorem proving library based on dependent type theory  http://hackage.haskell.org/package/ivor-0.1.14.1 (EdwinBrady)
04:42:37 * ksf once tried to abuse BDDs to generate perfect minimal hashes for arbitrary switches on large words, but then the problem is more about generating a decision tree that's capable of being compiled to a series of fast insns, and that's where stuff gets hairy.
04:43:35 <ksf> it's ye olde multiply-by-a-constant problem, just ampilfied. and multiply-by-constant is already NP.
04:47:34 <erus`> can i make this parallel? sort $ map handFromCards $ combinations 5 newDeck
04:50:35 <ksf> @faq can haskell make  sort $ map handFromCards $ combinations 5 newDeck  parallel?
04:50:36 <lambdabot> The answer is: Yes! Haskell can do that.
04:50:56 <RichardBarrell> (map handFromCards) can almost certainly be made parallel, unless "handFromCards" is much too fast to benefit from parallelism.
04:51:23 <ksf> it probably is, with the Ns involved in a card deck.
04:52:00 <RichardBarrell> IIRC Data.List.sort in GHC is already SMP-capable.
04:53:24 <erus`> @faq how do i make it parallel
04:53:24 <lambdabot> The answer is: Yes! Haskell can do that.
04:53:29 <ksf> no, it doesnt.
04:53:30 <erus`> :|
04:53:57 <ksf> @hoogle par
04:53:57 <lambdabot> Control.Parallel par :: a -> b -> b
04:53:57 <lambdabot> Text.Html paragraph :: Html -> Html
04:53:57 <lambdabot> Text.XHtml.Frameset paragraph :: Html -> Html
04:54:13 <erus`> > par 1 2
04:54:14 <lambdabot>   2
04:54:38 <erus`> the compiler should be able todo that itself
04:54:43 <erus`> its all pure code
04:55:04 <erus`> any map operation should be parallel automagicly
04:55:40 <ksf> map f x:y:xs = fy `par` (f x : fy : map f xs) where fy = f y
04:55:45 <ksf> ...something like that.
04:56:15 <ksf> erus`, it could, but it would usually make code slower.
04:56:58 <erus`> i want my data parallel haskell
04:57:07 <Axman6> erus`: but with what granularity? what if you do map (+1) on a list on ints? that's at most 20 instructions per element, is that worth forking a thread for?
04:57:23 <ksf> 20 insns?
04:57:35 <erus`> Axman6: it would use common sense
04:57:49 <ksf> ah, I see, the sufficiently smart compiler conjecture.
04:57:50 <Axman6> "common sense" is very difficult to program
04:58:10 <benmachine> it's rare enough in people ^_^
04:58:57 <Axman6> should map (const (fix id)) run faster in parallel?
04:59:21 <Axman6> what if you never use the elements of the list? then you've told the compiler that that work is worth computing, but never use it
04:59:36 <ksf> curiously enough, the reduceron is designed as a single core machine.
04:59:54 <CakeProphet> > e
04:59:55 <lambdabot>   Ambiguous occurrence `e'
04:59:55 <lambdabot>  It could refer to either `L.e', defined at <local...
05:00:24 <Axman6> ksf: though its executing is highly parallel isn't it?
05:00:29 <ksf> ...using parallelism not to do multiple reductions at the same time, but instead using it to reduce most reductions to a single clock tick.
05:02:05 <Axman6> ksf: it would be very interesting to see what a parallel reduceron could do. i wonder if it would have impressive power usage too
05:02:29 <ksf> the sync overhead might not be worth it.
05:02:33 <test123978456> hi
05:03:22 <test123978456> is it any standard function which calculate how many N lements is in in list? for example i got ::[Int] and wanna calculate how many times 3 on that list exists
05:03:34 <test123978456> for [1,3,1,3,3,4,3] should return 4
05:04:21 <ksf> > length . filter (== 3) $ [1,3,1,3,3,4,3]
05:04:23 <lambdabot>   4
05:05:20 <test123978456> ouch, filter ;)
05:05:23 <test123978456> thanks a lot ;)
05:06:04 * frerich things such a 'count' function would be a nice addition to Data.List
05:06:52 <Axman6> why? they're trivially constructed from more primitive list functions like length and filter, and will perform exactly the same
05:06:57 <hpc> you don't need the length of a list often enough for it to matter, either
05:07:02 <Axman6> assuming stream fucion anyway
05:07:03 <hpc> in my experience, at least
05:07:04 <Axman6> fusion*
05:09:17 <parcs> @type splitAt -- Axman6 so what do you have to say about this function
05:09:18 <lambdabot> forall a. Int -> [a] -> ([a], [a])
05:09:23 <parcs> @src splitAt
05:09:24 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
05:09:32 <Axman6> what about it?
05:09:50 <parcs> it's trivially constructed from more primitive list functions and will perform exactly the same
05:10:01 <parcs> yeah it exists
05:10:05 <parcs> yet*
05:10:28 <Axman6> convenience, and it's more general than 'count the number of times x appears in the list'
05:10:51 <ksf> I was actually surprised to see that take and drop isn't implemented in terms of splitAt
05:11:01 <parcs> @src find
05:11:01 <lambdabot> find p          = listToMaybe . filter p
05:11:07 <parcs> etc..
05:11:42 <CakeProphet> :t listToMaybe
05:11:43 <lambdabot> forall a. [a] -> Maybe a
05:11:52 <CakeProphet> er, well right. :P
05:12:13 <CakeProphet> > listToMaybe [1,2,3,4]
05:12:14 <lambdabot>   Just 1
05:12:43 <Axman6> > listToMaybe []
05:12:44 <lambdabot>   Nothing
05:13:00 <ksf> what'd be interesting to see is a combination of reduceron, cpu and gpu on one chip.
05:13:19 <Axman6> indeed
05:13:55 <ksf> graph reduction can surely be put to good use even outside of fp languages.
05:14:03 <Axman6> i need to read the reduceron paper
05:14:11 <Axman6> yeah
05:14:17 <ksf> it's highly technical and fascinating.
05:14:25 <augur> it needs to be less technical
05:14:29 <augur> i didnt understand a damn bit of it
05:14:35 <hpc> ^
05:14:38 <augur> well, of the talks anyway
05:14:43 <hpc> it needs a wikipedia article
05:15:01 <ksf> well, it's like me as a guitarist listening to a guitar maker explain the intricacies of wood selection.
05:15:29 <augur> no because that you can understand. maybe you dont know the details but you get the general picture, everything else is details.
05:15:34 <augur> but with the reduceron, i didnt get it at all
05:15:35 <ksf> a lot of the rationale and analysing carries over, but the task is completely different.
05:21:40 <Axman6> augur: ever done any digital electronics?
05:22:03 <augur> Axman6: no
05:22:33 <augur> why?
05:22:57 <ksf> well, that might explain stuff.
05:23:06 <augur> yes probably :)
05:23:14 <augur> but i understand normal CPUs just fine
05:23:27 <augur> not the details of the circuitry, no
05:23:40 <augur> but the general structure of the cpu, sure
05:23:48 <ksf> while I'm far away from being a wizard there, I could scrobble together a full adder out of gates moderately quickly
05:23:53 <ksf> ...still, after all these years.
05:24:07 <augur> oh i could do that easily
05:24:39 <Axman6> augur: the general structure of a CPU is probably a level above the electrical engineering you'd need I'd guess
05:24:53 <ksf> well, scrobbing stuff together from binary boolean ops is all you have to do in CPU design
05:25:09 <augur> but probably just the right level of explanation for a reduceron, Axman6!
05:25:13 <ksf> ...the rest is hardware layout.
05:25:32 <augur> i mean, i doubt the details of the gate layout is as important as the concept of how to do graph reduction
05:25:53 <ksf> well, the paper gives full operational semantics.
05:25:56 <ksf> *in haskell*.
05:25:59 <augur> lol
05:26:06 <augur> metacircular CPU
05:27:32 * ksf wonders what it would cost to produce such a cpu at moderate clock speeds and a batch size of 1000 or something.
05:27:59 <augur> well, the reduceron is supposed to run on FPGAs right?
05:28:13 <augur> so .. as much as an FPGA!
05:28:21 <ksf> that doesn't mean you can't burn it into silicon.
05:28:45 <augur> perhaps, but it does mean you dont need to burn it into silicon
05:28:46 <Eduard_Munteanu> ASIC is damn expensive
05:29:06 <ksf> it just means that it's optimised to take advantage of parallelism instead of clock speeds.
05:29:18 <ksf> that is, per se, not a bad thing at all.
05:29:22 <ezyang> What does a comma in a guard mean?
05:29:26 <Eduard_Munteanu> You'd need a few hundred thousand dollars to get started with even small batches.
05:29:32 <ksf> ezyang, part of a tuple?
05:29:46 <ezyang> > let f | True, False = 2 in f
05:29:47 <lambdabot>   *Exception: <interactive>:3:4-22: Non-exhaustive patterns in function f
05:29:54 <ezyang> >let f | True, True = 2 in f
05:29:56 <earthy> ksf: look at mosis or cmp
05:30:02 <ezyang> > let f | True, True = 2 in f
05:30:03 <lambdabot>   2
05:30:10 <ezyang> &&, apparently.
05:30:13 <earthy> (mosis.com or cmp.imag.fr)
05:30:17 <ksf> Eduard_Munteanu, even with cheap fabs?
05:30:30 <Axman6> hmm, actually, memristors are supposed to open the possibility of reprogrammable CPU/memory hybrids, you could use that to implement the reduceron in an adhoc manner :O
05:30:43 <Eduard_Munteanu> ksf: I think so. The startup costs are quite high.
05:31:05 <Axman6> > let f | undefined, True = 1 in f
05:31:06 <lambdabot>   *Exception: Prelude.undefined
05:31:14 <Axman6> > let f | false, True = 1 in f
05:31:14 <lambdabot>   Not in scope: `false'
05:31:16 <mm_freak> (it always confuses me that silizium (german) is called silicon in english, because i always confuse silicon and silicone)
05:31:17 <Axman6> > let f | False, True = 1 in f
05:31:18 <lambdabot>   *Exception: <interactive>:3:4-22: Non-exhaustive patterns in function f
05:31:19 <earthy> cmp.imag.fr has prices of roughly 700 euro / mm^2 in a .35u CMOS process
05:31:30 <Eduard_Munteanu> mm_freak: heh, indeed
05:31:34 <earthy> that is for 25 bare dies
05:31:35 <Axman6> interesting, I've never seen that used
05:31:54 <Eduard_Munteanu> Here it's something like silicium too.
05:31:55 <mm_freak> huh?
05:32:15 <earthy> packaging adds another 50 euro per chip to that roughly
05:32:20 <parcs> > let f x | True, Just y <- x = y in f (Just 5)
05:32:21 <lambdabot>   5
05:32:22 <mm_freak> > case undefined of _ | True, True -> "yes"
05:32:22 <lambdabot>   "yes"
05:32:26 <mm_freak> cool
05:32:35 <earthy> so you're looking at minimum outlay of about 25kEUR for a custom chip
05:32:37 <Eduard_Munteanu> earthy: yeah, but that's not the problem.
05:32:47 <mm_freak> i didn't know you can combine guards that way
05:32:50 <Eduard_Munteanu> Just getting it panelized is going to cost a lot
05:33:45 <hpc> > case Left 5 of Right x, Left x -> x
05:33:46 <lambdabot>   <no location info>: parse error on input `,'
05:33:59 <ksf> mm_freak, it's just like with "sulfur" and "sulfate".
05:34:06 <ksf> ...etc pp.
05:35:26 <ksf> chemistry nomenclature is actually very regular, once you forget words like "water" and "salt".
05:35:36 <parcs> > let f x | Right x = 5 in f 5
05:35:37 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
05:35:37 <lambdabot>         against inferred type ...
05:35:40 <earthy> eduard: panelized?
05:36:19 <ksf> earthy, well, divided by 1000 people that's 25 euros per person.
05:36:21 <ksf> ...for a chip.
05:36:36 <ksf> factoring in for pandora-experience, make that 50 euros.
05:36:50 <earthy> ksf: err, that's for *25* IC's. not 1000. :)
05:37:17 <ksf> well, the rest is going to be way cheaper, is'nt it?
05:37:30 <earthy> probably
05:37:58 <Eduard_Munteanu> Yeah, ASICs aren't cheap for low volumes.
05:38:10 <Eduard_Munteanu> For reasonable amounts they are though.
05:38:42 <Axman6> FPGA's are probably the best bet until the world decides that haskell is actually the one true way
05:39:01 <ksf> or the pandora project decides that it's time to roll their own processor.
05:39:11 <Axman6> link?
05:39:14 <ksf> because TI just doesn't happen to sport a 128-core arm.
05:39:32 <Axman6> they're coming though
05:39:39 <ksf> http://openpandora.org/
05:39:45 <Axman6> i think they'll be pretty standard in the next decade
05:39:52 <ksf> you'd have to dig in the forums to get to the design discussion.
05:40:11 <Axman6> ah, i see. I've seen that before
05:40:13 <ksf> it's 99% software and rejoicing about arrived boxen, now.
05:40:55 <Axman6> heh
05:41:23 <augur> anyone aware of any new programming/computational paradigms being investigated?
05:41:35 <ksf> there are any left?
05:41:42 <Reaganomicon> Sleepsort is a pretty new development.
05:41:50 <Axman6> sleepsort based algorithms
05:41:55 <earthy> augur: other than quantum computing?
05:41:58 <Axman6> damn, beat me to it Reaganomicon :P
05:42:17 <Axman6> parallel quantum computers!
05:42:19 <opqdonut> augur: local distributed algorithms is a fairly new (and quite interesting) field
05:42:26 <opqdonut> augur: but it's mostly theory
05:42:26 <augur> opqdonut: links?
05:42:41 <Axman6> ksf: do you have one?
05:43:04 <ksf> Axman6, not yet.
05:43:14 <opqdonut> augur: http://www.cs.helsinki.fi/u/josuomel/tut-2011/ that's a good starting point I guess
05:43:56 <Botje> augur: DNA computing?
05:44:15 <augur> Botje: is there any real development there tho?
05:44:30 <Axman6> they recently implemented sqrt using DNA
05:44:36 <augur> sure
05:44:49 <augur> im interested in more general paradigms
05:46:14 <Axman6> time-travel computing, run supercomputers in super fast spaceships that orbit the sun so they caluclate things more quickly (or more slowly... i can't remember now...)
05:46:34 <Axman6> must be slower
05:46:37 <Entroacceptor> Axman6: yes
05:46:54 <augur> Axman6: it will depend on who's accelerating where
05:46:57 <Axman6> you get in a super fast ship, and wiz around for a bit, and things happen quicker!
05:47:54 <Entroacceptor> Axman6: please don't accelerate the planet to relativstic speeds
05:48:01 <Eduard_Munteanu> I don't think the solution for performance problems is to move complexity to the CPU
05:48:07 <Axman6> just the spaceship you're sitting in
05:48:36 <augur> Axman6: that would make the computer on the ship go slower than the computer on the ground.
05:48:45 <Axman6> sure
05:49:03 <Axman6> but you'd get the results from the computer on the ground 'sooner'
05:49:18 <aavogt> no, you seem to have this one backwards http://en.wikipedia.org/wiki/Twin_paradox
05:49:31 <ksf> indeed.
05:49:39 <Eduard_Munteanu> I'd rather move things out of the CPU and replace it with registers, caches etc. and have compilers do the hard work.
05:49:50 <Entroacceptor> no, you just don't understand him properly ;)
05:49:55 <augur> Axman6: yes, if you were on the ship, and the computer on the ground, then sure
05:50:02 <Axman6> yes
05:50:08 <augur> you would experience the time for the computation to happen as being shorter
05:50:13 <augur> thats not a computational paradigm :P
05:50:24 <Axman6> but it feels faster!
05:51:15 <augur> im dont care about faster!
05:52:14 <yitz> i've been very good at sleepsort for years, but i'm not sure if i could program it as an algorithm
06:13:58 <mm_freak> ksf: yeah
06:26:26 * hackagebot uni-util 2.2.1.1 - Utilities for the uniform workbench  http://hackage.haskell.org/package/uni-util-2.2.1.1 (ChristianMaeder)
06:34:02 <hpaste> chrisdone pasted “cannot satisfy -package-id utf8-string-0.3.6-b308ad9fc2d24291fe4fbf9384c576a8” at http://hpaste.org/47876
06:34:43 <chrisdone> Can anyone explain why the above failure occurs?
06:36:01 <hpaste> chrisdone annotated “cannot satisfy -package-id utf8-string-0.3.6-b308ad9fc2d24291fe4fbf9384c576a8” with “Removed uninteresting compile messages” at http://hpaste.org/47876#a47877
06:38:07 <hpaste> chrisdone annotated “cannot satisfy -package-id utf8-string-0.3.6-b308ad9fc2d24291fe4fbf9384c576a8” with “With -v” at http://hpaste.org/47876#a47878
06:38:27 * hackagebot xml-enumerator 0.3.3 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.3.3 (MichaelSnoyman)
06:39:41 <chrisdone> Note: without --enabled-shared, it works fine.
06:40:20 <tgeeky> hm. Anyone remember the name of the haskell package which was a binding to a web2.0-ey service to input multilingual characters?
06:40:27 <tgeeky> it was uploaded in the last month I think
06:41:21 <tgeeky> (it had the same name as the web service)
06:42:06 <parcs> it was posted on the haskell reddit i recall
06:42:16 <parcs> maybe you should look through that
06:42:30 <tgeeky> http://hackage.haskell.org/package/accentuateus-0.9.2
06:42:32 <tgeeky> found ti
06:42:34 <tgeeky> it
06:46:28 * hackagebot HarmTrace 0.1 - HarmTrace: Harmony Analysis and Retrieval of Music  with Type-level Representations of Abstract  Chords Entities  http://hackage.haskell.org/package/HarmTrace-0.1 (JosePedroMagalhaes)
06:47:28 * hackagebot HarmTrace 0.1.1 - HarmTrace: Harmony Analysis and Retrieval of Music  http://hackage.haskell.org/package/HarmTrace-0.1.1 (JosePedroMagalhaes)
07:02:57 <ezyang> > let Just x = Just 2 in x
07:02:58 <lambdabot>   2
07:05:35 <ezyang> > (\Just x -> x) (Just 2)
07:05:36 <lambdabot>   Constructor `Data.Maybe.Just' should have 1 argument, but has been given 0
07:06:17 <Veinor> > (\(Just x) -> x) (Just 2)
07:06:17 <lambdabot>   2
07:11:31 * hackagebot snap-core 0.4.3 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.4.3 (GregoryCollins)
07:12:31 * hackagebot snap-server 0.4.3 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.4.3 (GregoryCollins)
07:13:31 * hackagebot snap 0.4.3 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.4.3 (GregoryCollins)
07:14:08 <lispy> Good morning
07:19:48 <tgeeky> hioh!
07:24:29 <ezyang> Hello all, perf question. I have a map to a tuple which is heavily accessed and I would like to be optimized as possible. However, I have a number of clients which require access to a version of the map which only contains one of the elements in the tuple. If I do a map on the map, my allocation shoots through the roof, so that's a no go. But if I make a separate map for the extra tuple items, I have to pay an extra cost of maintaining two maps and keeping
07:24:29 <ezyang>  do?
07:26:07 <ezyang> I was originally hoping the modify the clients to simply use the tuple-fied version of the map, but it turns out such a change would be very far-reaching.
07:26:10 <ksf> you left the most important bit out
07:26:15 <benmachine> ezyang: I think your message got cut off? "[...] I have to pay an extra cost of maintaining two maps and keeping"
07:26:21 <ksf> ...which is "how often is the map changed"
07:26:22 <benmachine> " do?"
07:26:55 <ezyang> "them up to date. What should I do?"
07:27:04 <ezyang> ksf: Very frequently.
07:27:09 <ezyang> The usage pattern is as follows:
07:27:10 <ksf> first shot, use a more efficient map.
07:27:22 <ezyang> We're using IntMaps, can't get too much more efficient then that.
07:27:25 <ksf> that is, one that unboxes both of your values.
07:27:33 <ksf> well, yes, you can, in the buckets.
07:27:57 <ksf> that depends on the type of values, of course.
07:28:00 <dixie> I have a stupid question again :-) I did profiling (-hd) and in output there hill of "Chunk". Is that something from bytesting?
07:28:09 <ezyang> Ah, sure.
07:28:20 <benmachine> dixie: lazy bytestrings are made up of strict chunks
07:28:58 <ezyang> OK, so, usage pattern. We have a list of work items to process. Each work item takes the map and updates 1 or more entries in the map. Across all work items, all entries in the map get updated.
07:29:16 <ezyang> This process is repeated arbitrarily many times until a fixpoint is reached.
07:29:17 <ksf> can you distribute them smartly?
07:29:30 <ksf> that is, first distribute, then calculate, then collect?
07:29:40 <ksf> or does the calculation need random access?
07:29:56 <ezyang> The calculation /may/ need random access.
07:29:58 <dixie> benmachine: I'm doing parsing of the large ascii file (hence I'm using lazy bytestring) to in memory data structures. I use in data structures also lazy bytestring. Is suggest to use there strict version?
07:30:08 <ezyang> It is determined by the underlying shape of the graph that we derived the work items from.
07:30:21 <dixie> benmachine: and thanks for answer :)
07:30:28 <ksf> well, optimizing a part of the system is better than nothing.
07:30:49 <benmachine> dixie: tricky, I don't know the best answer
07:31:05 <benmachine> dixie: some would say use iteratees but they're quite unfriendly
07:31:08 <ksf> and I suppose the calculation always works on the previous version of the map?
07:31:15 <ezyang> Yes.
07:31:33 <ksf> seems like you want to completely re-construct the map each iteration.
07:31:47 <benmachine> dixie: what you want to be careful of is that as you consume the chunks of the bytestring, you don't keep them around, so they can be garbage collected
07:31:55 <ezyang> mmf. Can I do that.
07:32:04 <ezyang> No, that would be counterproductive, algorithmically speaking.
07:32:06 <ksf> which possibly makes it amendable to even more data-structure level optimisation.
07:32:12 <benmachine> dixie: it's quite hard to do that reliably, which is why iteratees were invented, but they're a little tricky to use
07:32:27 <ksf> ezyang, well, you're updating everything, so where's the problem in creating a new map?
07:33:09 <ezyang> The map is a representation of the graph, and each work item helps move the graph towards a fixpoint. So we want to push any changes from a previous work item to the next one to encourage more rapid fixpoint convergence.
07:33:27 <ezyang> Basically, the it's a kind of linear dependency thingy.
07:34:08 <ezyang> wait a sec, I can draw it out
07:34:18 <augur> ezyang: you draw everything
07:34:21 <augur> draw draw draw
07:34:23 <augur> thank you.
07:34:52 <ksf> use a fine-locking data structure?
07:35:32 <tibbe> ezyang, what do you use to draw?
07:35:45 <dixie> benmachine: it will definitely need to look on that topic. but my application is not so critical, reducing all space leaks will be fine. thanks!
07:36:13 <ezyang> xournal + x61 tablet
07:36:29 <benmachine> dixie: I've never done that sort of application I'm afraid, so don't rely on my advice too much :)
07:37:26 <augur> ezyang: draw on the screen?
07:37:59 <ezyang> yeah
07:38:07 <ezyang> http://web.mit.edu/~ezyang/Public/map-pattern.png
07:38:18 <Arafangion> What's a good site for a beginning haskell programmer to read about TDD in haskell?
07:38:21 <dbpatterson> what is the easiest way for testing for no duplicates in a list? This would probably work, but, seems quite wasteful…: (all (== 1)) . (map length) . group . sort
07:38:40 <augur> what is that, map-reduce, ezyang?
07:38:52 <ezyang> nah, if it were map-reduce it'd be parallelizable
07:38:53 <lispy> Arafangion: we do property driven development more than test driven, but it's pretty similar in goal
07:39:16 <augur> ezyang: but its some sort of map-sort-reduce type operation?
07:39:21 <augur> but wthout the clean separation?
07:39:23 <lispy> Arafangion: HUnit and QuickCheck are the main testing frameworks you'll use.  I'm not sure of a site that pulls it all together.
07:39:42 <ezyang> f is not necessarily expressible as 'map g'
07:39:49 <augur> ah ok
07:39:50 <lispy> Arafangion: I would start here: http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck
07:39:57 <Arafangion> lispy: I've seen some vague references to them, will check them out in more detail - thanks for that link.
07:40:11 <Arafangion> lispy: Why do you say that you do 'property driven development'? What'd the difference?
07:40:22 <ezyang> What is different in m' mostly depends on the graph structure underlying the map.
07:40:25 <Arafangion> lispy: Keep in mind that I don't actually believe that TDD exhaustively tests the project!
07:40:37 <Arafangion> (It's more of a means of finding regressions when I refactor)
07:40:58 <lispy> Arafangion: quickcheck generates random instances of your types and tests a property.  So you might declare that, reverse (reverse (reverse xs)) == reverse xs
07:41:17 <lispy> ?check \xs -> (reverse (reverse (reverse xs))) == reverse xs
07:41:18 <lambdabot>   "OK, passed 500 tests."
07:42:05 <Arafangion> lispy: Why is that not TDD?
07:42:27 <lispy> Arafangion: Yeah, that's a reasonable view of TDD.  In Haskell the rich types can be used to cover most of what you would check in TDD (but not all, without going into heavy theory)
07:42:36 <ezyang> TDD has an emphasis on single-case examples.
07:42:40 <ezyang> not random generation of tests.
07:43:07 <ezyang> I guess, maybe keeping two maps up-to-date won't be so bad. I guess we'll see.
07:43:16 <lispy> Arafangion: It's different because we wrote a property.  We decided that reversing something 3 times should always be the same as reversing it once.  We didn't just test that reverse [1,2,3] == [3,2,1]
07:43:28 <ezyang> Unfortunately, I can't unbox my intmap, because we're polymorphic in the contents.
07:44:02 <lispy> Arafangion: properties tend to sound more like, "forall xs such that ..., we want the following to hold."
07:44:23 <Arafangion> lispy: Arguably that's a limitation of the framework, right? You can't easily say in most test frameworks: "I want...", you have to give explicit examples - I like the sound of properties much better.
07:44:28 <lispy> Arafangion: and then QC tries a few xs to see if it can find a counter example
07:45:28 <lispy> Arafangion: and then we have HUnit which is a "typcial" unit test framework.
07:45:41 <Arafangion> lispy: I've currently got the website for that open.
07:45:50 <lispy> Arafangion: You can also write QC properties that are sort of 'degenerate' in that they test a specific case
07:45:52 <ksf> haskell isn't really suited for tdd.
07:45:58 <lispy> ?check 1 == 1
07:45:58 <lambdabot>   "OK, passed 500 tests."
07:46:05 <ksf> haskell code tends to be too bug-free for that.
07:46:15 <Arafangion> ksf: I don't believe you.
07:46:25 <ksf> *especially* during refactoring. with a bit of experience it becomes quite hard to mess it up.
07:46:36 <ksf> static typing does wonders.
07:47:21 <lispy> Arafangion: we do have more bug prevention tricks available to us than in most languages.  You might want to read up on "equational reasoning" if you're not already familiar with it (helps when debugging and refactoring in my experience)
07:47:24 <Arafangion> lispy: I imagine that if I do TDD in Haskell, I might end up testing properties in QuickCheck, and contrary to normal TDD, also do integration checks using HUnit?
07:47:25 <ksf> and if in doubt, let the old code hang around and just do a qc property that asserts that the old and new version behave the same.
07:47:44 <ksf> the simple code/fast code dual is a quite good metric.
07:47:56 <ezyang> Are there any data structures that are particularly optimized for when the set of keys are known? Bucket type data structures, right?
07:48:17 <dbpatterson> ksf: the key is to make your type descriptive enough to make errors not compile, of course… it is easy to write buggy code using tuples, lists, Ints, Strings, etc….
07:48:28 <lispy> Arafangion: Perhaps.  I'm not sure I know what you mean when you say integration tests.  If you're doing continuous integration checkout cabal-dev (which you should use anyway as the sandboxing makes cabal-install much nicer to use)
07:48:33 <ksf> ezyang, depending on the value of "known", try perfect hashes.
07:49:19 <lispy> Arafangion: http://www.reddit.com/r/haskell/comments/f3ykj/psa_use_cabaldev_to_solve_dependency_problems/
07:49:34 <rostayob> Arafangion: nice to see you here (:
07:49:52 <lispy> I tend to think, if you're not using cabal-dev then you deserve all the obnoxious cabal dependency issues that you'll encounter :)
07:50:01 <Arafangion> lispy: For example, I have worked on a project (in an imperative language) that has a few thousand tests that execute in minutes. Each tests only a tiny part of the project - just one function or class.  We also have other tests that could take hours to run - that gives assurance that the whole program manages to work together.
07:50:10 <Arafangion> rostayob: Ssh. :)
07:50:32 <Arafangion> rostayob: That page you gave me is one of the best documents I've seen on Haskell, I'm very intruged. :)
07:51:00 <lispy> Arafangion: Ah okay.  So, yeah hunit can make sense for the latter.  I've also seen people use shell scripts in a "black box" testing scenario
07:51:22 <rostayob> Arafangion: glad to hear that, if you have any doubts this is the right place
07:51:26 <Arafangion> lispy: True black box testing can be too slow, though.
07:52:12 <Arafangion> rostayob: Awesome. :)
07:52:39 <lispy> Arafangion: well written Haskell code often has view moving parts that interfer and interact badly together so some people probably argue that integration testing (outside of getting it to compile) is less important here.  But...we have a lot of not-well written code hiding on hackage amongst lots of good code...
07:52:44 <ksf> Arafangion, another thing worth setting up is performance regression testing
07:52:51 <lispy> s/view/few
07:52:53 <ksf> combinatorrent does that, for example.
07:53:35 <lispy> Arafangion: At any rate, pure code is much easier to test in Haskell
07:53:36 <Arafangion> lispy: Hence the importance of integration tests.
07:53:42 <ksf> time each build against a suitable test case, graph the results and notice ongoing trends.
07:54:02 <Arafangion> lispy: That, funnily enough, is a trend I've noticed in my imperative projects. The more functional the code, the easier to test.
07:54:30 <lispy> Yup, and the more you write with testing in mind the easier it is to debug and glue together
07:54:49 <lispy> Sometimes just writing with testing in mind prevents the bugs that your tests don't end up  finding
07:55:05 <Arafangion> Yep, TDD is the whole philosophy. It's not just tests.
07:55:23 * ksf supresses bugs by tying up loose ends.
07:55:41 <lispy> Arafangion: good luck.  I'm going to wander off
07:55:45 <Arafangion> (I've heard of people calling it "BDD", changing the word 'Test' to 'Behaviour', to reduce the tendendy of people thinking that it's about tests, but I think we're all in agreement)
07:55:54 <Arafangion> lispy: Ok, me too, thanks for those references!
07:56:03 <ksf> the closer input and output domain of every functions are to their *actual* domain and codomain the better.
07:56:43 <Entroacceptor> lispy: why didn't you tell me about cabal-dev earlier
07:56:44 <Arafangion> ksf: That's something I often struggle with in my group projects - keeping code isolated.
07:56:53 <lispy> Entroacceptor: hehe :)
07:56:59 * Arafangion looks for cabal-dev and combinatorrent.
07:56:59 <lispy> Entroacceptor: nice, isnt' it?
07:57:05 <ksf> haskell is still lacking on that front, though.
07:57:13 * lispy leaves for real
07:57:17 <Arafangion> ksf: ...  A bittorrent client?
07:57:19 <Arafangion> lispy: Cya!
07:57:24 <Entroacceptor> I've wasted hours in trying to get some things compiled
07:57:25 <ksf> adts would have to be more extensible to do that properly.
07:57:33 <ksf> Arafangion, yes, and it's even fast.
07:57:44 <ksf> a hell of a user experience, though.
07:58:15 <ksf> ...and it won't have any problems scaling to 1024 cores, it's a prime example of how to write erlang in haskell.
07:58:28 <Arafangion> ksf: That's actually my other main concern with haskell, but I think haskell is useful enough for learning about programming.
07:59:07 <Arafangion> ksf: Awesome!
07:59:31 <ksf> well, you give a (single-file) .torrent on the command line, and when you figure out proper debug options and a decent grep expression, you might even get sensible output.
07:59:41 <Arafangion> Heh.
08:00:14 <Arafangion> ksf: At work I primarily work on desktop applications. The polished GUI kind where you have a team of graphic artists working for you.
08:00:45 <ksf> functional guis are still a research topic
08:00:48 <Arafangion> I wont' be able to use Haskell for that, but I'd like to see if it /could/ be used for that.
08:01:00 <ksf> just like every other language.
08:01:00 <Arafangion> ksf: Do you have links?
08:01:01 <d7> ksf: There is some pretty good research tho.
08:01:06 <ezyang> @hoogle (Just (Just a)) -> a
08:01:06 <lambdabot> Did you mean: Maybe (Maybe a) -> a /count=20
08:01:07 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
08:01:07 <lambdabot> Data.Foldable foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
08:01:13 <ksf> haskell is a perfectly fine imperative language if you need it to be.
08:01:18 <augur> ezyang: Omega is a nonstandard model of integers.
08:01:32 <ezyang> augur :-)
08:01:40 <Arafangion> ksf: I'm still looking for a good GUI - whatever the paradigm. :(
08:01:51 <d7> Arafangion: You start here: "Functional Reactive Programming from First Principles"
08:01:53 <Arafangion> Cocoa's the best so far.
08:01:57 <ksf> there's some issues with using standard kits like gtk, though, and that is that you can't write your own gobjects due to awkwardness.
08:01:58 <Arafangion> d7: Thanks.
08:02:22 <augur> ezyang: which are crucial for certain proofs of non-first-orderizability. for instance, the geach kaplan sentence has a mathematical translation which is true in non-standard models but false in standard models
08:02:23 <d7> Arafangion: And "Genuinely Functional User Interfaces" by Courtney, A.
08:02:24 <augur> or maybe the reverse
08:02:36 <d7> There is actually a framework built around that you can mess with.
08:02:38 <augur> and the distinction is only capturable in non-first-order logics
08:02:48 <d7> Sadly it looks like twm rose from the grave
08:03:23 <ksf> there's two things that could happen: elerea gets picked up for a tk and gets a push/pull implementation (still impure under the hood), or conal picks up ghc hacking.
08:04:06 <Arafangion> I think the trend is actually to allow the UI to be completely decoupled from program code. (Which is how Interface Builder works in Cocoa)
08:04:16 <Arafangion> Or even HTML5.
08:04:32 <ksf> that's always a good idea.
08:04:40 <ksf> MVC isn't a new idea, though.
08:04:55 <Arafangion> Many different types of MVC, though.
08:07:27 <ksf> Arafangion, how's that for decoupling? http://haskell.org/haskellwiki/TV
08:07:59 <ksf> generiticy can be a bane to useability too, though.
08:08:47 <Arafangion> ksf: Vaguely similar to Cocoa.
08:09:05 <Arafangion> ksf: With the IBOutlet and IBAction's.
08:09:32 * Arafangion likes it - bookmarks it.
08:09:40 <d7> ksf: MVC isn't what decoupling of UI from client code is. That's just how OO people choose to interpret the imperative.
08:09:47 <ksf> probably won't even compile.
08:10:09 <ksf> some nasty people already proposed to use conal as the base unit for bitrot.
08:10:48 <Arafangion> d7: Yeah, there's lots of different ways to do MVC.
08:11:08 <ksf> like nesting the letters.
08:11:23 * Arafangion blinks - hs-dotnet?
08:12:47 <Arafangion> Hmm, Haskell has COM+ bindings?
08:13:44 <ksf> @faq can Haskell talk to my espresso machine?
08:13:44 <lambdabot> The answer is: Yes! Haskell can do that.
08:13:54 <Arafangion> Heh.
08:14:07 <quicksilver> @faq but is my espresso machine remotely interested in what haskell is trying to say?
08:14:07 <lambdabot> The answer is: Yes! Haskell can do that.
08:14:10 <Arafangion> Thanks for that ksf, g'night!
08:14:44 <gienah> Arafangion: Calling Hell from Heaven and Heaven from Hell .
08:14:52 * ksf 's espresso machine actually has a "/dev/coffee" sticker on top.
08:15:04 <benmachine> ksf: HTTP error 418
08:15:38 <gienah> @google "Calling Hell from Heaven and Heaven from Hell"
08:15:40 <lambdabot> http://research.microsoft.com/en-us/um/people/emeijer/Publications/finne99calling.pdf
08:15:40 <lambdabot> Title: Calling hell from heaven and heaven from hell Sigbjorn Finne University of Glasg ...
08:16:36 <Arafangion> gienah: An *extremely* apt title.
08:18:19 <Arafangion> Oh, one point - can Haskell currently be used on mobile devices? (Eg, iPhone? Android?)
08:18:43 <pumpkin> yes
08:19:02 <Arafangion> pumpkin: Awesome!
08:19:13 <copumpkin> it's not an ideal situation yet
08:19:22 <Arafangion> Please elaborate? :(
08:19:25 <quicksilver> it's about as far as you can get from ideal
08:19:28 <quicksilver> no official support
08:19:30 <quicksilver> compiler patches required
08:19:36 <quicksilver> no bridge to use native APIs
08:19:37 <copumpkin> http://projects.haskell.org/ghc-iphone/
08:19:39 <Arafangion> No official support - that's to be expected, I guess.
08:19:40 <ksf> how does firefox manage to get worse with every new version?
08:19:55 <copumpkin> Arafangion: it'll get better once we get better cross-compilation support in GHC
08:20:16 <Arafangion> copumpkin: Not having cross compilation is a downer. :(
08:20:18 <arw_> ksf: feature bloat while not managing to handle the pile of new bugs.
08:20:51 <TylerE> ksf: change for the sake of change (see also: kde4, gnome3)
08:21:20 <thoughtpolice> now that i have a jailbroken iphone (thanks copumpkin! :P) the thought of GHC is mighty tantalizing
08:21:30 <thoughtpolice> luajit is pretty crazy awesome on it too, for that matter.
08:21:48 <Arafangion> thoughtpolice: Does it require a jailbroken phone? :(
08:22:08 <thoughtpolice> Arafangion: oh, no. i was just saying, since i can upload programs to it without a dev account
08:22:41 <Arafangion> Ah, good.
08:22:47 <thoughtpolice> ghc-iphone will sign with your apple key IIRC, and apple will officially allow you to write apps in "any" language now, modulo anything that downloads/creates code at runtime
08:22:59 <copumpkin> the signing is just a command-line utility
08:23:06 <copumpkin> you can sign anything with your key if you want
08:23:07 <Arafangion> That's fricking awesome.
08:23:09 <thoughtpolice> which is good, because executables built with GHC are insanely easy to recognize
08:23:23 <Arafangion> thoughtpolice: How so?
08:23:34 <thoughtpolice> not that apple was ever consistent with enforcing that policy anyway
08:23:47 <thoughtpolice> Arafangion: step 1) build anything with GHC. step 2) run 'strings output.exe'
08:23:52 <thoughtpolice> done
08:24:07 <Arafangion> thoughtpolice: Heh.
08:24:17 <erus`> whats strings
08:24:31 <arw_> erus`: extracts all strings from a file.
08:24:33 <thoughtpolice> it outputs all the recognizable strings inside the executable file.
08:24:49 <Arafangion> erus`: Classic unix application.
08:24:52 <erus`> is that a ghc utility?
08:24:56 <arw_> erus`: where string is everything longer than 4 ascii characters and null-terminated.
08:24:57 <thoughtpolice> no, unix utility
08:24:58 <erus`> i have it on win7 :/
08:25:19 <Arafangion> erus`: Then console yourself that at least, you can install cygwin.
08:25:22 <thoughtpolice> erus`: it could be in your $PATH from ghc, perhaps, if you have it installed
08:25:35 <Arafangion> ghc contains 'strings'?
08:25:44 <thoughtpolice> the windows installer contains quite a bit, IIRC
08:25:58 <erus`> ah its part of mingw gcc
08:26:03 <erus`> :)
08:26:04 <thoughtpolice> ^^ like that
08:26:10 <thoughtpolice> since GHC uses mingw on windows
08:26:29 <thoughtpolice> although i dunno if it actually puts them in $PATH
08:26:32 * thoughtpolice doesn't use windows very much
08:26:32 <Arafangion> Ahh, fair enough.
08:26:42 * Arafangion sandboxes his Win7 nicely in a VM.
08:26:45 <Arafangion> Only way to use it.
08:27:10 <erus`> ghc platform contains perl too :/
08:27:19 <Arafangion> erus`: Normal.
08:27:20 <thoughtpolice> yep
08:27:38 <Arafangion> It's surprising how common perl is installed.
08:28:16 <osfameron> does ghc still contain Perl?  I thought they'd got rid of the horrid mangler, or whatever it was called
08:28:26 <thoughtpolice> no it's still there.
08:28:35 <osfameron> \o/
08:28:40 <thoughtpolice> it's not quite deleted from the code yet, it's just no longer enabled or anything by default
08:29:08 <thoughtpolice> but the evil mangler should hopefully die RSN (although i think i've said that several times in the past when it's been talked about :| )
08:29:11 <copumpkin> preflex: seen xplat
08:29:11 <preflex>  xplat was last seen on #haskell 1 day, 29 minutes and 49 seconds ago, saying: any WAI ones can be run as CGI
08:29:30 <erus`> whats the evil mangler?
08:30:22 <ksf> erus`, I'm not sure you really want to know.
08:30:26 <thoughtpolice> tl;dr: GHC can compile to a horrid form of C. this form of C cannot properly manifest the needed register/stack usage for the compiler calling conventions, and it also cannot eliminate tail calls. the EM is a script written in perl that processes the *assembly* output of GHC to fix that
08:30:31 <thoughtpolice> it's not pretty
08:30:32 <thoughtpolice> by a long shot
08:30:46 <erus`> haha
08:30:50 <Arafangion> thoughtpolice: Wow.
08:30:52 <erus`> well works over
08:30:55 <erus`> bye all
08:31:02 <thoughtpolice> luckily though, the EM is only used on the code path to compiles to C, which is ill-advised for use these days. you should be using the native code generator or LLVM code generator
08:31:05 <osfameron> wasn't the idea that the "evil" components would get rewritten in haskell, at which point they were renamed "glorious" ?
08:31:15 <thoughtpolice> er, my bad, it rewrites the ASM output of GCC, after it compiles the awful code
08:31:26 <ksf> the llvm backend has a "righteous mangler"
08:31:32 <osfameron> heh
08:31:49 <thoughtpolice> oh right, it does. but i think it's mostly there to fix some weird OS X oddity
08:32:00 <ksf> the evilness of the evil mangler doesn't stem from perl. perl only adds to it.
08:32:03 <thoughtpolice> (because GNU as is like, five trillion years old.)
08:32:07 <thoughtpolice> (on OS X, anyway)
08:33:17 <Arafangion> Hmm, you can have STM, as a *package*?
08:33:35 <Arafangion> (Very nice)
08:33:36 <thoughtpolice> the primitives are provided by the RTS, but user-level package, yes
08:34:55 <ksf> many, many things are libraries in haskell, though.
08:35:14 <Arafangion> It's been a long time since I got excited by a language.
08:35:59 * ksf just recently got excited about disciple.
08:36:58 <Arafangion> ksf: What's good about it?
08:37:26 <ksf> it blends purity and mutability seemingly perfectly.
08:37:39 <ksf> that is, you can't categorise it as functional or imperative, it's just a pure language.
08:37:53 <Arafangion> Like F# in that respect? (Note: I don't actually know F#)
08:38:02 <ksf> f# isn't pure
08:38:10 <ksf> ocaml and lisp, neither.
08:38:30 <Arafangion> Lisp definetly isn't, from what I've seen.
08:38:50 <ksf> so you have the advantage of destructive update for performance reasons, *and* the advantage of purity which enables tons of compiler optimisations.
08:39:05 <ksf> ...and the compiler is smart enough to infer all of that stuff.
08:39:05 <thoughtpolice> well, in haskell, we normally use the type system to track side effects and get 'do' notation amongst others. can you do that in disciple? you can certainly say 1 area of code is bound by two type-level effects, but can you construct your own effects to be type checked, like we can create an instance of Monad?
08:39:24 <thoughtpolice> that's always been my biggest wonder - 'can you construct arbitrary kinds of effects and interference rules?'
08:39:27 <ksf> yep, you can define your own effects.
08:39:37 <Arafangion> ksf: Nice, good to know that the list of languages to learn isn't dying out, as I was fearing. :)
08:40:01 <thoughtpolice> ksf: ok, i didn't know that. i thought at one point ben said there were some limitations, but i haven't looked at disciple much since it's announcement
08:40:53 <Twey> parcs: I'm pretty sure splitAt is not trivially constructed and will not perform the same — IIRC the real splitAt (unlike the naïve implementation λb gives) only traverses the list once
08:40:57 <Arafangion> I notice that in the benchmarks shootout, G++ is considered faster than GHC, interesting.
08:40:58 <ksf> the type system is powerful enough to express that e.g. gettimeofday takes a struct and writes to it, as well as having an effect on the dummy "!Time" effect token.
08:41:11 <thoughtpolice> ksf: but that's pretty awesome. i never read ben's paper on the matter. but on the note of exciting, i am actually getting quite excited with ur/web :)
08:41:20 <thoughtpolice> and i've never even done much web programming
08:41:21 <Arafangion> Says nothign about what programs were used, though.
08:41:45 <ksf> thoughtpolice, large chunks of his thesis are a very easy read.
08:41:57 <thoughtpolice> ksf: does the compiler still compile to C? i heard there was an llvm backend in the works
08:42:05 <ksf> both, yes.
08:42:12 <ksf> c is supposed to be faded out.
08:42:22 <ksf> llvm doesn't do tco yet, though
08:42:26 <thoughtpolice> i guess i more wanted to ask 'is llvm the default' :P
08:42:32 <Arafangion> tco?
08:42:36 <thoughtpolice> tail-call optimization
08:42:36 <ksf> and the compiler generally could be smarter. it doesn't even unbox properly.
08:42:41 <Arafangion> Cool.
08:42:47 <thoughtpolice> ksf: does disciple need to do that? LLVM itself does support TCO since a while now
08:43:21 <ksf> disciple is very peculiar when it comes to loops. as it's lamdas all the way down, while-loops desugar into actual functions, which are then tco'ed like the rest.
08:43:43 <ksf> thoughtpolice, I've only read the tracker, don't know any details.
08:44:46 <ksf> http://disciple.ouroborus.net/ticket/212
08:45:33 <ksf> some foreign import issues, too.
08:45:37 <ksf> that is, plumbing.
08:46:42 <thoughtpolice> ah. there isn't much news about disciple. sure it could use some love.
08:47:04 <ksf> it's under active development, but could definitely use more manpower.
08:47:29 <ksf> both on the library sinde and a handful of compiler hackers.
08:47:46 <ksf> or, probably, the language side.
08:48:01 <ksf> ben plans to bootstrap the compiler asap
08:48:29 <ben> ಠ_ಠ
08:48:33 <thoughtpolice> ksf: yeah. ur/web is similar. it's actively developed, but otherwise is really raw (bad compiler errors, no packages, very few docs or references)
08:48:39 <ben> i need a less common nick
08:48:53 <ksf> ...which shouldn't be too big an undertaking as much haskell code is valid disciple code, and seems to usually run with minor changes
08:49:02 <ksf> mostly due to strictness, that is.
08:49:42 <ksf> on the upside, the C ddc generates is very grokkable.
08:49:54 <ksf> it's actually, *gasp*, using the C stack.
08:50:47 <augur> ok peeps
08:50:56 <augur> more deep philosophy questions for you
08:51:32 <augur> folds and unfolds are incredibly important concepts in (mathy) computer science. what other ideas do you think are equally as important?
08:51:57 <ksf> hippomorphisms.
08:52:18 <benmachine> zygohistomorphic etc.
08:53:01 <hpc> the categorical dual of a hippomorphism should be a giraffomorphism
08:53:31 <monochrom> haha
08:53:46 <augur> hpc: im not sure if you're serious about hippomorphisms or not
08:53:49 <hpc> :P
08:53:53 <monochrom> @remember hpc the categorical dual of a hippomorphism should be a giraffomorphism
08:53:53 <lambdabot> Nice!
08:54:20 <sipa> what about hippopotomonstrosesquipedaliomorphisms?
08:54:20 * copumpkin thinks we should have a mesomorphism and a telemorphism
08:54:41 <augur> ok so noones taking my question seriously :(
08:54:55 <benmachine> it's easier to be silly, sry
08:55:01 <monochrom> benmachine did
08:55:09 <copumpkin> augur: curry-howard
08:55:10 <benmachine> lies and slander
08:55:22 <Saizan> sipa: now you're just sticking words together!
08:55:28 <sipa> Saizan: no!
08:55:37 <sipa> http://en.wiktionary.org/wiki/hippopotomonstrosesquipedaliophobia
08:56:36 <augur> Saizan was technically correct; typing sentences constitutes sticking together words, and you were indeed typing sentences.
08:56:50 <sipa> ok, i admit
08:56:51 <hpc> augur: folds and unfolds are specialized catamorphisms and anamorphisms, so i suppose those?
08:57:01 <sipa> i've been typing several words after eachother
08:57:33 <hpc> sipa: but there you put words together! "eachother"
08:57:53 <monochrom> camel case sticks words together
08:58:02 <augur> hpc: you mean "folds" for trees, etc.?
08:58:16 <sipa> hpc: actually, that's a language error on my part - in dutch we write it as one word
08:58:25 <hpc> :P
08:58:34 <hpc> augur: i was thinking of the prelude fold/unfold
08:58:36 <hpc> on lists
08:58:59 <hpc> oh, natural transformations perhaps?
08:59:01 <augur> hpc: ok, so the generalization of list fold into non-list domains
08:59:34 <augur> sure, i was considering that sort of thing to be just a fold.
09:04:22 <augur> anything else as big and important as catamorphisms and anamorphisms?
09:05:02 <ksf> hylo. epi.
09:05:12 <ksf> there's a full zoo
09:08:22 <augur> ok besides morphisms :P
09:08:46 <benmachine> copumpkin suggested curry-howard
09:08:50 <ksf> but it's morphisms all the way down!
09:09:09 <ksf> there's not even objects, just identities.
09:09:17 <augur> pah!
09:09:21 <augur> ok CHI + morphisms
09:09:46 <ksf> I don't think CHI is thinkable without morphisms.
09:10:09 <augur> atleast the iso- sort :D
09:10:19 <augur> no but seriosly, nothing else? CHI and morphisms?
09:10:47 <ksf> well, you can base the CHI on virtually everything.
09:11:02 <ksf> choose a logical system, choose a proof language.
09:11:58 <ksf> one could even say that CS starts where prepositions + proofs can't use the same language, anymore.
09:12:23 <ksf> CHI involving presburger would be kind of silly, I think.
09:17:00 <kai__> so
09:20:16 <erus`> is there a better way to compile haskell to javascript than lambdascript?
09:21:26 <ryant50001> erus`: there's ghcjs, which i think is newer; i haven't used either one, though, so i couldn't say which one's better
09:21:54 <o1iver> Hey. I am wondering if there is a package containing an IP data type (I know about iproute, is that what you use?)
09:22:10 <o1iver> IP Address I mean
09:22:20 <augur> ksf: preposiitons + proofs?
09:22:21 <augur> what
09:24:38 <ksf> types are prepositions, programs are proofs.
09:25:16 <hpc> prOOOOOpositions :P
09:25:18 <augur> types are PREpositions? you sure you dont mean PROpositions?
09:25:19 <augur> :P
09:25:23 <hpc> @wn preposition
09:25:28 <lambdabot> *** "preposition" wn "WordNet (r) 2.0"
09:25:28 <lambdabot> preposition
09:25:28 <lambdabot>      n 1: a function word that combines with a noun or pronoun or noun
09:25:28 <lambdabot>           phrase to form a prepositional phrase that can have an
09:25:28 <lambdabot>           adverbial or adjectival relation to some other word
09:25:30 <lambdabot> [4 @more lines]
09:25:30 <augur> if types are prepositions, what are postpositions?!
09:25:45 <augur> @wn proposition
09:25:45 <lambdabot> *** "proposition" wn "WordNet (r) 2.0"
09:25:45 <lambdabot> proposition
09:25:46 <lambdabot>      n 1: (logic) a statement that affirms or denies something and is
09:25:46 <lambdabot>           either true or false
09:25:46 <lambdabot>      2: a proposal offered for acceptance or rejection; "it was a
09:25:47 <lambdabot> [9 @more lines]
09:25:57 <ksf> same difference.
09:26:01 <augur> hardly!
09:26:06 <augur> brb
09:26:10 <lunaris> Pedantry from someone who chooses not to use capital letters?
09:26:17 <lunaris> <trollface>
09:26:19 <ksf> well, prepositions are non-zero arity propositions.
09:27:42 <ksf> @tell augur well, prepositions are non-zero arity propositions.
09:27:42 <lambdabot> Consider it noted.
09:27:47 * ksf in gone shopping
09:27:52 <ksf> is, even.
09:28:03 <lunaris> has, even
09:28:07 <lunaris> :P
09:28:26 <ksf> I felt like using perfect aspect.
09:28:33 <lunaris> going, then.
09:28:46 <ksf> ...whether that exists in your version of english is yet another topic.
09:28:52 <ksf> no, that'd be progressive.
09:29:18 <lunaris> My metalanguage stinks.
09:29:59 <lunaris> Though I know of no place in which "is gone" is correct.
09:30:19 <lunaris> As something that requires another verb, at least.
09:30:24 <lunaris> :/
09:30:37 * lunaris should probably shut up.
09:31:13 <Twey> I think time is more important than place here
09:31:40 <lunaris> Oh crap.
09:31:52 <lunaris> Now there are two; I'm screwed.
09:32:04 <ksf_> "he is gone" is different semantically from the russian perfect aspect, though.
09:32:22 <lunaris> ``He is gone shopping'' is incorrect though.
09:32:24 <ksf_> "he has gone (but could already be back)"
09:32:59 <lunaris> I have no problem with the sentence "X is gone."
09:33:11 <ksf_> there's no "incorrect" in linguistics. there's only understandable or not.
09:33:11 <lunaris> I suggested "has" as you added "shopping"
09:33:12 <benmachine> ksf_: go shop already :<
09:33:18 <osfameron> "He is become shopping" would be grammatically correct, if old-fashioned (if semantically a bit bonkers)
09:33:49 <lunaris> That's quite a statement.
09:33:49 <benmachine> osfameron: that is how I am going to announce my errands from now on
09:34:40 <lunaris> benmachine: Only for verbs of motion (which I imagine is in keeping with most errands)
09:34:47 <lunaris> :)
09:35:02 <benmachine> I am become cycling?
09:35:08 <lunaris> Lol
09:35:14 <lunaris> Archaic or just trolling?
09:35:26 <osfameron> I think you'd use it more with words like "immanent"
09:35:35 <osfameron> I'm not sure if immanence is an errand though, strictly speaking
09:36:01 <benmachine> ok now I'm confused – you can become imminent?
09:36:04 <lunaris> It's not a verb.
09:36:11 <benmachine> I mean if you happen to be an event then perhaps
09:36:16 <lunaris> An event is either imminent or it isn't.
09:36:20 <osfameron> benmachine: imm*a*nent
09:36:23 <osfameron> but that was the wrong word
09:36:24 <lunaris> imminent.
09:36:31 <osfameron> I think I might have meant "manifest" ;-)
09:36:36 <lunaris> TIL a word :)
09:36:39 <lunaris> Apologies.
09:36:42 <benmachine> heh, me too
09:41:00 * hackagebot groundhog 0.0.1 - Type-safe, relational, multi-backend persistence.  http://hackage.haskell.org/package/groundhog-0.0.1 (BorisLykah)
09:47:47 <copumpkin> thoughtpolice: congrats on getting the patch in finally!
09:54:26 <sanjoyd> Ideas on structuring a code generator in Haskell?
09:55:02 * hackagebot groundhog-sqlite 0.0.1 - Backend for the groundhog library using sqlite3.  http://hackage.haskell.org/package/groundhog-sqlite-0.0.1 (BorisLykah)
09:55:03 <augur> lunaris: capitalization does not convey phonological differences, but the spelling difference between preposition and proposition does
09:55:03 <lambdabot> augur: You have 1 new message. '/msg lambdabot @messages' to read it.
09:55:31 <augur> also, ksf_, no they're not
09:57:23 <sanjoyd> I basically have an AST, and want to generate a three address stream of instructions from it.
09:57:42 <lunaris> augur: Sorry; I'll stay out of it.
09:57:45 <monochrom> "he is gone shopping" is an abbreviation of "he is gone. shopping"
09:57:51 <lunaris> Wow.
09:57:55 <augur> monochrom: no its not.
09:57:59 <JuanDaugherty> thoughtpolice: I'm thoughtcrime.biz
09:58:00 <lunaris> I end up starting the most pointless debates.
09:58:05 <monochrom> haha
09:58:12 <lunaris> augur: Do apostrophes signify phonological differences?
09:58:45 <lunaris> sanjoyd: Some people would have a type class that classifies things for which code can be generated.
09:58:54 <thoughtpolice> copumpkin: simon pushed it through finally! :) i need to update the wiki page, write some testsuite patches and a manual patch
09:58:58 <thoughtpolice> i'll probably do that today if possible
09:58:59 <augur> luite: in english orthography, usually no. sometimes theyre useful for disambiguation but ambiguity exists regardles
09:59:06 * thoughtpolice is already working on ghc for projectaweek anyway
09:59:20 <lunaris> Noted.
09:59:28 <d7> thoughtpolice: What's your patch?
09:59:29 <augur> obviously that was for you, lunaris
09:59:34 <augur> tab complete is betraying me
09:59:40 <Saizan> lunaris: some people would probably be abusing typeclasses :)
09:59:46 <sanjoyd> lunaris: so I have a class C with a function (C a => a -> [Instruction]) ?
09:59:52 <lunaris> sanjoyd: Something like that.
10:00:05 <thoughtpolice> d7: it gives GHC the ability to load plugins that users write, so you can easily write things like optimization passes
10:00:10 <lunaris> sanjoyd: I'm a fan of class Code a where { toCode :: a -> Doc } (where Doc is from Text.PrettyPrint or the like)
10:00:13 <lunaris> But I'm not an expert.
10:00:15 <d7> thoughtpolice: Oh that is cool.
10:00:27 <d7> thoughtpolice: I eagerly await documentation of said.
10:00:28 <lunaris> Saizan: Type classes are there to be abused.
10:00:34 <sanjoyd> The problem is keeping track of information - when emitting code for an if statement involves emitting code to evaluate it's expression.
10:00:46 <sanjoyd> (So I'll need to "remember" where the value went).
10:01:01 <sanjoyd> Which virtual register and the like; and this needs to be propagated back the if.
10:01:06 <lunaris> sanjoyd: Is an `if' expression not represented by some AST node `If Exp Stmt Stmt' for example?
10:01:09 <lunaris> I see.
10:01:18 <lunaris> sanjoyd: Maybe a code generation monad might suit.
10:02:06 <lunaris> Depending on how much separation you want, you might use RWS (not sure how your Haskell is), but you could do something like:
10:02:31 <augur> afk getting good
10:02:38 <lunaris> newtype CodeM a = CodeM { runCodeM :: State [Instr] a } deriving (Monad, MonadState [Instr])
10:02:42 <lunaris> Or something
10:02:57 <lunaris> Obviously, this depends on whether or what Monad framework you use etc.
10:03:06 <sanjoyd> I just found Harpy.CodeGenMonad.
10:03:09 <lunaris> But then you'd just build a list of Instrs and generate code for them in one pass.
10:03:10 <sanjoyd> I'll look there first.
10:03:18 <lunaris> Hopefully the principle is similar.
10:12:31 <ksf_> augur, yes, it is.
10:12:40 <ksf_> not an abbreviation, though, but sloppy punctuation.
10:13:10 <ksf_> but, as, maybe indeed or not apparently, english, in, or especially in, punctuation matters is an utter mess.
10:14:05 <benmachine> @remember ksf_ but, as, maybe indeed or not apparently, english, in, or especially in, punctuation matters is an utter mess.
10:14:06 <lambdabot> It is stored.
10:17:06 * hackagebot doctest 0.3.0 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.3.0 (SimonHengel)
10:34:02 <augur> ksf_: what
10:34:10 <xkb> is it possible to match to parts of a Record? like so: data Stcok = Stock {value::Int, size::Float}  calculateStock :: Stock -> Float calculateStock a | Stock {_ b} = b ?
10:34:17 <xkb> Stcok = Stock
10:35:24 <hpaste> rovar pasted “eh?” at http://hpaste.org/47883
10:36:00 <lunaris> xkb: f (Stock { value = 3 }) = 4
10:36:08 <lunaris> xkb: f (Stock { value = 3, size = x }) = 4
10:36:15 <xkb> ahh ok
10:36:20 <xkb> with the ()
10:36:21 <lunaris> (I think)
10:36:26 <xkb> I'll try i
10:36:28 <xkb> it*
10:36:54 <identity_> xkb: but guards might work out better for you
10:37:11 <rovar_> hey all.. i am trying to use an existing lib which defines its own monads, particularly mongodb, and I'm getting a lot of "no instance defined..." errors.. now I can stub these things out using orphan instances.. but I'm trying to find the correct strategy.
10:37:18 <rovar_> because I don't think that's the right one
10:37:21 <rovar_> http://hpaste.org/47883
10:37:22 <identity_> f someStock | size someStock == value = doThis | otherwise = doThat
10:37:26 <sm> damn, I really want hackage package renames
10:37:55 <xkb> identity_: thanks, that was my first approach
10:38:07 <xkb> the real code has 3 fields, where 2 of those are MayBe
10:38:19 <lunaris> xkb: Pattern guards could help clarify
10:38:20 <xkb> So I want to map on the Just a, or Nothing
10:38:22 <lunaris> clarity*
10:38:31 <lunaris> xkb: It could also be a job for fmap
10:38:37 <xkb> hmm interesting
10:39:02 <lunaris> f x | Just y <- maybeField1 x, Nothing <- maybeField2 x = False | otherwise = True
10:39:09 <lunaris> Again, syntax may not be perfect.
10:39:23 <lunaris> Or, if you're doing:
10:39:50 <lunaris> f x | Just y <- mF1 x, Just z <- mF2 x = Just (g x y) | otherwise = Nothing
10:39:57 <xkb> datatype is data OrderResponse = OrderResponse {orderMilk::Maybe Float, orderSkins::Maybe Int, orderResponseCode :: ResponseCode} and I need to build JSON for each combination of MayBe values
10:40:00 <lunaris> Then f = liftA2 g
10:40:11 <lunaris> (Or the like -- that's the gist...perhaps)
10:40:52 <lunaris> xkb: Well
10:41:02 <lunaris> If you have functions for Float -> JSON, Int -> JSON
10:41:09 <lunaris> You could use fmap and get back Maybe JSON values.
10:41:18 <lunaris> Or something.
10:41:19 <xkb> gonna try fmap, sounds nice
10:41:22 <lunaris> There are various strategies.
10:41:26 <lunaris> Applicative might help too.
10:41:30 <lunaris> (See Control.Applicative)
10:41:40 <lunaris> Though of course, there's the maybe function and others.
10:42:38 <xkb> the choices, the choices :)
10:44:09 <lunaris> Indeed :)
10:46:40 <yitz> @type maybe . maybe
10:46:42 <lambdabot> forall a b a1. b -> (a -> (a1 -> b) -> Maybe a1 -> b) -> Maybe a -> (a1 -> b) -> Maybe a1 -> b
10:47:30 <yitz> @type flip maybe . flip maybe
10:47:31 <lambdabot> forall a a1. (a1 -> a) -> (Maybe a1 -> a) -> Maybe a -> Maybe a1 -> a
10:47:48 <yitz> closer
10:50:13 <parcs> he better find his terminal
10:50:39 <identity_> parcs: hate when that happens. I lost mine at sea once
10:50:41 <identity_> never got it back.
10:50:50 <parcs> ouch.
10:51:27 <roconnor> anyone know if for the ICFP content if we will need internet connection during the contest?
10:52:15 <identity_> roconnor: are you implying that it is possible to get by without internet at any moment in time?
10:52:31 <identity_> how will you know what to answer when people ask you questions if you don't have google and/or wikipedia?
10:53:05 * scree manages without internet for up to 8 hours a day
10:53:16 <parcs> heh
10:53:20 <accel> that's pretty amazing
10:53:26 <accel> I generally have to wake up every 3 hours to check email
10:53:30 <identity_> I just did 10 days without internet.
10:53:52 <sanjoyd> I once did 9 months.
10:53:57 <identity_> The ship only made it back to land because my nerves of steel kept me from stabbing everyone on board to death.
10:54:23 <roconnor> identity_: sometimes I work on a train.
10:55:59 <accel> identity_: was this a cruise ship?
10:56:18 <identity_> accel: Yes. The kind where you work 12 hours a day in stinking fish :(
10:56:23 <identity_> I got ripped off
11:06:02 <k0ral> I'm quite confused with the several ways of performing concurrency in a gtk app
11:06:23 <k0ral> there is the forkIO with the "timeoutAddFull" trick
11:06:57 <k0ral> apparently one can use forkOS, but can't see what's the difference
11:07:22 <k0ral> and finally one can deconstruct the gtk main loop
11:07:34 <monochrom> yes there are several ways but one of them is least work: call postGUISync or postGUIAsync, and link with -threaded
11:08:07 <k0ral> do you mean not using any fork function at all ?
11:08:22 <monochrom> feel free to forkIO
11:08:47 <monochrom> I have an example at http://www.vex.net/~trebla/haskell/gtk-interact.xhtml
11:09:30 <k0ral> can't see any postGUI* function
11:09:51 <k0ral> oh yes
11:10:05 <k0ral> I'm wondering why my browser didn't match it...
11:10:11 <monochrom> there are several ways because postGUISync and postGUIAsync are fairly new, so the web is full of old examples of old ways
11:10:49 <monochrom> in fact postGUIAsync and postGUISync just wraps up one of the old ways so you have less boilerplate code
11:11:19 <k0ral> I read such functions were supposed to be used only when using several OS threads
11:11:25 <k0ral> which isn't the case here, is it ?
11:11:38 <monochrom> you never know what forkIO does
11:12:15 <k0ral> isn't forkIO only the lightweight threading system provided by Haskell, that doesn't create an actual new OS thread ?
11:13:01 <dmwit> forkIO is M-to-N threading.
11:13:06 <monochrom> forkIO is the lightweight threading system provided by Haskell, that liberally decides when to create a new OS thread and when to jump between them too
11:13:08 <dmwit> So it may or may not use a separate OS thread.
11:13:32 <ben> Does that mean I do not have to pass +RTS -N8 or whatever anymore?
11:13:45 <monochrom> think "farm of OS threads"
11:14:03 <dmwit> ben: No, I don't think it means that.
11:14:03 <k0ral> is forkIO the right threading system to use here ?
11:14:07 <monochrom> yes
11:14:16 <RichardBarrell> forkIO is very nearly always the right threading system.
11:14:37 <accel> exit
11:14:56 <ben> Oh, right. It only creates OS threads for blocking FFI calls and that sort of thing, does it not.
11:16:24 <k0ral> so what is that d*** forkOS ?
11:16:24 <monochrom> forkOS will not relieve you from needing postGUIAsync and postGUISync anyway
11:16:24 <RichardBarrell> forkOS is like forkIO, but it creates a thread that is bound to one specific OS-level thread.
11:16:25 <RichardBarrell> forkOS is needed for certain specific C-level APIs that do silly things with thread-local storage. You rarely need or want to use it.
11:16:25 <monochrom> forkOS creates a lightweight haskell thread that does not jump between OS threads
11:16:25 <RichardBarrell> s/C-level/C/
11:16:26 <monochrom> forkIO creates a lightweight haskell thread that does jump between OS threads
11:16:51 <tiffany> I need to install a gtk theme
11:16:58 <k0ral> ok so I'm sticking to forkIO
11:17:14 <monochrom> and in both cases you still don't know the ratio of # of lightweight threads : # of OS threads
11:17:42 <k0ral> regarding postGUI functions
11:17:59 <k0ral> I read it was supposed to be used every time one needs to change something in GTK
11:18:07 <k0ral> that's not what you're doing in your example
11:18:23 <k0ral> hmmmm
11:19:16 <monochrom> postGUIAsync $ do textBufferSetText ...  I be damned if that is not an effect on a gtk widget
11:20:04 <k0ral> yes yes, but last time I read your code I thought I spotted a line where you interacted with gtk without using postGUI
11:20:08 <ben> (As far as I can tell, postGUIAsync does not so much post gui events asynchronously as asynchronously grabbing the global gtk lock and then running the event itself?)
11:20:18 <k0ral> can't find it now so I guess I'm mistaken
11:20:23 <monochrom> that's when I know I am in the correct thread already
11:21:38 <monochrom> "main" is on a forkOS-kind thread, i.e., won't jump
11:22:03 <monochrom> clearly, in the same OS thread of initGUI and mainGUI, I don't need to post
11:22:13 <k0ral> fair enough :)
11:22:40 <k0ral> I see you didn't need to use the timeoutAddFull function
11:22:51 <monochrom> but I have forkIO ( ... postGUIAsync (textBufferSetText ... ))
11:23:23 <ben> Oh, right, then only the GUI thread is gonna be the one executing the mainloop itself.
11:23:35 <ben> I kinda forget that there's so much C stuff under there. Sorry for being ignorant.
11:24:49 <k0ral> monochrom: I was expecting you to confirm, or not, the last sentence :)
11:24:58 <monochrom> postGUIAsync is implemented by an idleAdd
11:25:12 <monochrom> I don't use timeoutAddFull
11:25:48 <k0ral> what if GTK is never idle ?!
11:26:07 <monochrom> postGUISync is implemented by an idleAdd plus an MVar and just wait for that MVar
11:28:44 <monochrom> idleAdd is in turn implemented by a GLib-level idleAdd plus grabbing the gtk lock
11:29:36 <monochrom> but then the lock-grabbing is done in the same OS thread as mainGUI, in fact mainGUI is the caller
11:32:56 <monochrom> you should design your program so that gtk is infinitely often idle
11:33:46 <monochrom> even before multi-threading, you should.
11:34:08 <ben> but my program is busy doing stuff!!
11:34:23 <ksf_> UIs are by default idle.
11:34:29 <ksf_> by definition, even.
11:34:31 <k0ral> actually I sometimes get segfaults
11:34:57 <k0ral> so I'm chasing such design errors
11:35:03 <ksf_> those aren't very helpful without stack traces
11:35:15 <k0ral> let's see if postGUI will solve them
11:35:17 <monochrom> the best way to ensure that the UI detects user input is to be infinitely often idle. idling is when key and mouse events can get through
11:35:59 <ksf_> monochrom, like doing all the work in another thread than the mainGUI one?
11:36:23 <monochrom> that is the easiest way today
11:36:29 <Cale> It totally sucks that GUI libraries aren't more threadsafe.
11:36:36 <ksf_> yep
11:36:40 <k0ral> Cale: so agreed
11:36:49 <monochrom> but remember that 30 years ago you could not use threads at all
11:36:59 <ksf_> gtk isn't 30 years old.
11:36:59 <k0ral> Cale: let's do a Haskell-native GUI library
11:37:12 <monochrom> but guis are
11:37:14 <ksf_> gtk is monolithic, that's the main problem.
11:37:27 <ksf_> I'm not aware of any non-research microlithic tk, though.
11:37:30 <ben> Let's make it a gnome-native-looking GUI library, too, please ;)
11:37:59 <Nimatek> Screw gnome and gtk, tbh.
11:38:20 <ksf_> gah. native look and feel is overrated.
11:38:21 <monochrom> gtk was born just in the midst of people fighting holy wars over select-loop vs threading
11:38:25 <ksf_> remember kai's power tools?
11:38:52 <ksf_> you don't have to be blender to benefit from a non-native tk.
11:38:57 <Cale> ksf_: I do!
11:39:16 <Cale> KPT was amazingly well-designed :)
11:39:25 <Cale> Also Convolver :)
11:39:38 <ksf_> one, very important thing haskell needs before we can do a proper TK of any kind is a *sane record system*, though.
11:39:53 <Nimatek> If you go for an existing toolkit, pick Qt.
11:40:07 <ben> Is Qt actually popular within Haskell?
11:40:10 <ksf_> wolfgang did an awesome job to prove that it's possible, but I still wouldn't want to use it.
11:40:14 <ben> I haven't seen it mentioned in here a lot :)
11:40:14 <ksf_> ben, no.
11:40:16 <Nimatek> ben: I don't think so.
11:40:31 <ksf_> I've heard something about bindings, but I guess they never took off.
11:40:38 <ksf_> c++ is a true bugger to interface to
11:40:52 <Cale> Though, I think generally it's nice to respect people's configuration wishes with respect to UI widgets and such.
11:40:57 <ksf_> ...including interfacing c++ from c++.
11:41:09 <ben> Qt kind of turned me off when the hello-world tutorial made me specify the size of the "hello world" button in pixels, instead of calculating it from the font size or something :)
11:41:19 <Cale> I don't really care if all my apps have exactly the same style of menus and buttons and stuff though.
11:41:23 <ben> (Also I guess the custom preprocessor)
11:41:55 <ksf_> any modern tk should be themeable enough to look virtually indistinguishable from other tks, anyway.
11:41:57 <Cale> Some people are super-picky about everything looking "native" whatever that means :)
11:42:05 <ben> Cale: I am not going to get angry at a non-native-looking app that has a different skin or even has the okay/cancel buttons in a different order, but from there it's only a short step to key shortcuts/input methods not working
11:42:22 <ben> non-app-specific ones obviously
11:42:28 <ryant50001> i think native look and feel matters more in a mass-market context
11:42:34 <ksf_> ok/cancel orders in the wrong order is just sloppy design.
11:42:43 <ben> ksf_: don't gnome and kde disagree though?
11:42:52 <Nimatek> It may not matter to you personally, but inconsistency is an issue on the linux desktop.
11:42:53 <ksf_> isn't ok always left?
11:43:03 <ryant50001> if your users are judging your program by how slick it looks, you better either fit in or have a cool "different" look
11:43:27 <ksf_> apply is always left, at least, and ok/cancel-dialogs (modal, even!) are a broken concept, anyway.
11:43:41 <ben> yes, okay
11:43:45 <ben> let me try to find a counterexample
11:45:26 <ben> < ksf_> isn't ok always left? <- http://imgur.com/K0xsF
11:45:55 <ksf_> hmm.
11:46:09 <ksf_> well, at least there *are* buttons.
11:46:26 <ksf_> some apps expect you to have window decorations and use those to close a window.
11:46:48 <ben> http://imgur.com/DVmi2 <- from gimp :)
11:47:21 <Cale> ksf_: Or if you don't have window decorations, keyboard shortcuts of some sort at least :)
11:47:40 <ksf_> well, there's meta+shift+c
11:47:56 <ben> What's wrong with alt-f4 :)
11:47:58 <ksf_> which is the official close-button in xmonad.
11:48:05 <Cale> I see no problem with that sort of thing for a tool window
11:48:29 <k0ral> monochrom: actually it's not segfaultint anymore
11:48:35 <k0ral> monochrom: thank you for the trick
11:48:39 <Cale> Like, there's no real need for that colour picker to have OK and Cancel buttons, if it just directly changes the active colour and isn't modal.
11:48:42 <monochrom> you're welcome
11:49:40 <k0ral> monochrom: you said forkIO is always the thread system one should use, I guess there are exceptions cases ?
11:50:05 <monochrom> when you don't want the lightweight thread to jump between OS threads
11:50:21 <ben> Basically what I was getting at is not so much matching a native UI in a pixel-perfect way but rather emulating the thing that user expectations are built upon
11:50:36 <ben> but what do I know, I haven't built a portable GUI app in my lifetime
11:50:49 * ksf_ should take clutter for a spin sometime.
11:52:31 <monochrom> swing lets you choose the windows theme when running on windows
11:52:46 <monochrom> and IIRC it emulates
11:53:43 <ksf_> swing is a nightmare
12:07:50 <noob> hi all
12:11:44 <Cale> hi
12:13:26 <hpaste> tgeeky pasted “periodic” at http://hpaste.org/47884
12:14:26 <tgeeky> can someone discuss how to add the periodic properties (like "metal", "gas", "group 1", "group 2" , ...)
12:14:27 <monochrom> haha
12:14:34 <tgeeky> to that bundle of mess? :o
12:15:22 <tgeeky> I'm trying to model this after the layout in the [Facts] module on hackage
12:16:23 <tgeeky> any suggestions appreciated... brb
12:17:12 <o1iver> hi guys. Anybody used the snap-framework before?
12:17:48 <keseldude> I'm no expert, but I would have probably started with data Element = Element { name :: String, mass :: Double, atomicNumber :: Int/Word16/whatever, etc.}
12:18:46 <shapeless|afk> I would start with the atomic number. From that, you can proceed to the number of electrons on the tires of the atom, the outer electrons, the main groups...
12:19:25 <keseldude> or if you want to enumerate them like you did, you could have had name :: ElementName
12:19:42 <keseldude> and then you wouldn't need to store atomicNumber
12:20:19 <tgeeky> yeah, I want to avoid doign that (not just storing it, but having the freedom to reassign it)
12:20:57 <keseldude> then maybe do the ElementName the way you did
12:21:11 <keseldude> but have a module function like mass :: ElementName -> Double
12:21:14 <keseldude> and just pattern match
12:21:47 <tgeeky> ok, the next thing I was attempting to do
12:21:49 <tgeeky> was to do the groupings
12:22:14 <tgeeky> like, "metal", "gas", "actinide", "stable", "synthetic"
12:22:43 <tgeeky> as well as the group/period
12:22:48 <tgeeky> i guess that's just pattern matching too
12:23:34 <keseldude> yeah, I would do that as a guard
12:24:02 <keseldude> group e | e `elem` [insert, the, elements] = Group1
12:24:21 <tgeeky> yeah ok
12:24:40 <mia999> hi
12:25:14 <JuanDaugherty> moin
12:35:43 <noob> hi mia
13:09:30 <MHD> Is it just me or is Haskell completely void of a pyton/C# like approach to string formatting?
13:10:09 <lpsmith> there is text.printf
13:10:12 <lpsmith> mhs ^
13:10:22 <lpsmith> err,  MHD ^
13:10:23 <MHD> yeah, but that's the C approach
13:10:32 <MHD> with the %...
13:10:42 <MHD> python and C# uses {...}
13:10:52 <Evious> You're looking for string templating?
13:11:07 <MHD> perhaps... is that what they call it nowadays?
13:11:37 <Evious> Well, the Python fancy string formatting is just ERB/DTL, on a smaller scale.
13:12:15 <MHD> and ERB/DTL is..?
13:12:40 <Evious> Django template language/ERB templates
13:13:22 <ski> MHD : <http://www.shimweasel.com/2009/10/30/string-interpolation-in-haskell-or-doing-easy-things-the-hard-way> seems to do that
13:14:11 <MHD> So there isn't a function set for doing that=
13:14:14 <MHD> ?
13:14:46 <Evious> The recent Haskell web service libraries use file template engines. They might include functions for templating on a low level, too.
13:15:51 <Evious> I'm really curious if/how this is done. How do you link the world of Haskell typed to a string containing a simple, untyped language?
13:16:24 <JuanDaugherty> erb = enterprise ruby bean?
13:16:28 <Twey> It's quite easy to embed an untyped language within Haskell.
13:17:00 <JuanDaugherty> extensible ruby boilerplate?
13:17:07 <MHD> Twey: I know
13:17:12 <c_wraith> with all the runtime safety that implies! :)
13:17:16 <MHD> Probably gonna make my own.
13:17:25 <Twey> MHD: I was talking to Evious, who seemed confused about the concept
13:17:27 <listener> What is a difference between haskel and lisp
13:17:35 <JuanDaugherty> uh oh
13:17:40 <Twey> listener: Lisps use sexprs
13:17:44 <MHD> listener: Everything except the programming paradigm
13:17:45 <c_wraith> listener: number of parenthesis
13:17:56 <Twey> Everything, especially the programming paradigm ;)
13:18:03 <Twey> For most common values of ‘Lisp’.
13:18:08 <c_wraith> honestly, "everything" is a pretty good answer.
13:18:27 <Twey> But listener said ‘a difference’ — I presume they wanted a specific example
13:18:29 <MHD> lol
13:18:54 <listener> Yes is there a difference between parameter evaluations
13:18:54 <MHD> For one, lisp is mostly strict and dynamically typed
13:19:00 <MHD> as far as i understand
13:19:07 <Evious> Twey, I've written simple interpreters and stuff, but how do you bind that to a statically typed "printf" like function?  Using the example of 'templatePrint "Foo is {{ foo }} and bar is {{ bar }}" Foo Bar'
13:19:13 <MHD> And it has very powerful macros
13:19:17 <monochrom> another good answer goes like "lisp is <definition of lisp>, haskell is <definition of haskell>". when people ask "what is the difference between", they don't necessarily mean it
13:19:23 <Twey> MHD: ‘Lisp is not a language.’
13:19:39 <Twey> Most Lisps are strict and dynamically typed.
13:19:43 <JuanDaugherty> btw, you don't wanna ask that question in #lisp, they bite
13:19:50 <JuanDaugherty> (in more ways than one)
13:20:15 <listener> If one wants to implement a gui what course shoud one use
13:20:17 <MHD> Twey: Not a language? Lisp is... Evaluable data structures?
13:20:33 <Twey> MHD: Template Haskell macros are exactly as powerful as Lisp macros (if a bit clumsier)
13:20:34 <Evious> "Template Haskell" seems the most likely answer to my question, and "use a pretty printing library instead" an even better one. So nevermind, really.
13:20:39 <ski> MHD : Lisp is a family of languages
13:20:42 <Evious> Probably trying to ask a question that don't need answering.
13:20:51 <Twey> Lisp is a fuzzy set containing languages
13:20:51 <MHD> ski: Yeah, all right.
13:21:03 <listener> Can you write your own as in lisp
13:21:06 <benmachine> Twey: clumsiness can be relevant!
13:21:09 <monochrom> I think people who like "I am #{name}" hate pretty-printing combinators
13:21:14 <MHD> I'm mostly familiar with CL and Scheme
13:21:24 <listener> Scheme is close to native lisp
13:21:24 <benmachine> Twey: otherwise turing-completeness gets you most of the way :P
13:21:35 <Twey> benmachine: Heh, right
13:21:35 <Evious> MHD, take a look at pretty printing libraries. I don't know what's a good example, but this may be a start http://hackage.haskell.org/packages/archive/pretty/1.0.1.0/doc/html/Text-PrettyPrint-HughesPJ.html
13:21:55 <Twey> benmachine: But E.G. CPP macros are not Turing-complete (I think?)
13:22:03 <listener> What is the field that most haskel is used
13:22:22 <benmachine> Twey: hmm. they don't have the syscalls to compete, but I'm pretty sure the ioccc would have words on that subject
13:22:23 <JuanDaugherty> academia and then finance prolly
13:22:39 <MHD> Evious: That's sadly not what I am looking for
13:23:06 <MHD> Evious: I'm making a code generator, so it's more hexadecimals and less documents
13:23:13 <listener> Isnt haskel functional like lisp
13:23:16 <JuanDaugherty> but the use in finance is like that of smalltalk in the same industry in the 90s
13:23:28 <MHD> listener: No, it's more.
13:23:43 <listener> more functional? or more than lisp?
13:23:50 <JuanDaugherty> way more
13:23:52 <MHD> listener: Haskell is quite close to mathematical formulae
13:23:57 <monochrom> lisp is not functional enough
13:24:04 <Evious> MHD, I strongly suspect a combinator-based embedded DSL is what you're looking for, then. It is to Haskell's strong types, what "{{ foo }} {{ bar }}" is to Python's dynamic typing.
13:24:07 <benmachine> Twey: consider the ability for a file to include itself, and that's probably enough
13:24:39 <listener> can you make a comparison.... whats not functional in lisp but is in haskel.... conditioning... or somenthing else
13:24:59 <Twey> listener: Lisps are not generally very functional.  Most Lisps are quite imperative.
13:25:06 <JuanDaugherty> lisp is broadly considered a functional language but from a Haskell, Caml, etc. perspective, people centered in those lang cultures it isn't
13:25:07 <benmachine> Twey: seems like people have implemented the game of life in CPP
13:25:10 <benmachine> sorta :P
13:25:24 <Twey> benmachine: I stand corrected.  But I refuse to consider CPP in the same light as Lisp macros and TH :þ
13:25:27 <monochrom> haskell's "map f xs" and scheme's (map f xs) translated to lisp looks really bad. functions are not first-class in lisp
13:25:37 <Cale> listener: Common Lisp in particular makes a distinction between functions and values that makes functional programming somewhat more awkward than it should be. Lisps also don't tend to have pattern matching, which is somewhat central to a functional style of programming.
13:25:39 <MHD> Is ther an arrow parsing library that uses Swiestra and Duponcheel's work?
13:25:40 <benmachine> Twey: well, admittedly TH allows arbitrary IO
13:25:43 <hpaste> bos pasted “config” at http://hpaste.org/47885
13:25:53 <benmachine> I actually always found that a bit scary, and reckon GHC should allow you to turn it off
13:25:56 <Twey> benmachine: Gerrout :þ
13:25:58 <Cale> (of course, lisp isn't really one language, so it's a bit hard to say exactly what the differences are)
13:26:33 <pastorn> trying to use haddock... could not find link destinations for:
13:26:34 <pastorn>     GHC.Base.String Data.Maybe.Maybe GHC.Classes.Eq GHC.Show.Show
13:26:47 <Evious> I'm currently trying to do stuff with a Lisp dialect on a functional VM - by "functions are not first-class in lisp" do you mean specific implementations, or as a general limitation of all lisps?
13:26:51 <pastorn> how do i find where my GHC lib dir is?
13:27:01 <monochrom> that is not a fatal error. it just means fewer hyperlinks in your web pages
13:27:11 <listener> So what for is haskel good
13:27:11 <ski> Twey : don't forget Camlp4 ..
13:27:17 <listener> can i use it in cg
13:27:21 <pastorn> monochrom: no, i get nothing in my doc directory
13:27:33 <pastorn> $ haddock -o doc/ Text/OpenGL/EnumExtSpec.hs
13:27:37 <monochrom> -h
13:27:42 <Evious> lambdabot, can Haskell be used in cg?
13:27:49 <pastorn> haha
13:27:52 <pastorn> monochrom: thanks :D
13:27:54 <Cale> listener: One of the things which I think is characteristic of how "functional" a programming language is would be how cheaply it represents function composition. In Haskell, function composition gets the single character operator symbol period (.), while in lisp, it's often given a more awkward name like compose, and not frequently used directly.
13:27:55 <pastorn> monochrom++
13:28:05 <Evious> Feh, it used to say "Yes, Haskell can do that." listener: http://cdsmith.wordpress.com/2011/03/13/haskells-niche-hard-problems/
13:28:21 <benmachine> Evious: that's @faq
13:28:23 <JuanDaugherty> well lisp really is one language with two major dialects
13:28:24 <Twey> @faq Can Haskell be used in CG?
13:28:24 <lambdabot> The answer is: Yes! Haskell can do that.
13:28:30 <Evious> :D
13:28:47 <Cale> listener: Haskell is a general purpose language, so it's good for most things.
13:29:03 <JuanDaugherty> a fat one and a lean one
13:29:13 <Cale> listener: The things which make it good as a language are mostly things which apply to broad ranges of problems, and not a specific thing.
13:29:23 <pastorn> monochrom: how is this usually done? do i put haddockify.sh in the project root?
13:29:52 <listener> I canot see any laungage be more of anything because of syntax
13:29:53 <monochrom> usually cabal is used. "cabal haddock"
13:30:04 <monochrom> or else a makefile
13:30:04 <Evious> (.) only starts to shine when you have currying, though. Do you need both currying and easy function composition for a language to be "functional"?
13:30:17 <Cale> listener: I don't understand your last statement, can you rephrase that?
13:30:18 <JuanDaugherty> that's why it's called the 'Canot Cycle'
13:30:42 <monochrom> of course, "cabal haddock" is meant to be followed by "cabal copy"
13:30:46 <Cale> Evious: They both help
13:31:24 <Cale> Functional programming is a style of programming. A functional programming language is one in which functional programming is especially easy to do.
13:31:25 <listener> is it fast
13:31:39 <pastorn> monochrom: i think i'll just make a script, for easy use while writing...
13:31:40 <Cale> listener: Some implementations of Haskell produce fast code.
13:31:47 <listener> or at least er than c++
13:31:56 <Cale> listener: (Languages are not fast or slow, they're languages)
13:32:04 <pastorn> monochrom: how do i get the nice CSS that all pages online usesL
13:32:05 <pastorn> ?
13:32:11 <monochrom> english is slow. chinese is fast :)
13:32:14 <Cale> listener: Language implementations produce better or worse code for the programs they compile.
13:32:23 <pastorn> do i just steal it, put it in ./docs/ and tell haddock to look there?
13:32:29 <JuanDaugherty> monochrom, \o
13:32:36 <monochrom> new enough haddock does the nice CSS already
13:32:38 <listener> was generalising for the sake of characters typed
13:32:56 <Cale> listener: However, I'd say *writing* Haskell code is a good deal faster than writing C++ code, for someone with a similar level of expertise in both languages.
13:33:20 <monochrom> haddock 2.8.0 or newer
13:33:21 <Twey> <insert joke about the impossibility of C++ expertise here>
13:33:28 <Cale> Twey: yeah
13:33:42 <pastorn> monochrom: http://hpaste.org/47886
13:33:47 <JuanDaugherty> but it might take you a few years before you get to the point where you can use that efficiency, which is why it has a negligible market footprint
13:33:51 <ben> I still feel more comfortable around a scary dirty C++ codebase than any haskell code I didn't write in the past ten minutes. I must be doing it wrong. :(
13:33:51 <mjoldfield> Twey : In a C++ room, wouldn't people say the opposite ? :)
13:33:52 <Cale> Though many people put it on their resumes, nobody actually knows C++.
13:33:58 <JuanDaugherty> like mouse droppings really
13:34:02 <listener> then c++ has better marketing
13:34:11 <erus`> classes in haskell are like interfaces in go. amirite?
13:34:12 <Cale> I don't think even Stroustrup knows C++
13:34:21 <pastorn> monochrom: nevermind... i thought i was running ghc7 but was running ghc 6.12.3
13:34:23 <shapr> JuanDaugherty: What's mouse droppings? huh?
13:34:25 <Twey> mjoldfield: Probably, but they'd not be as correct :þ
13:34:41 <shapr> erus`: As in, found at all the good universities?
13:34:42 <JuanDaugherty> Stroupstup has made a career of C++
13:34:43 <mjoldfield> Twey : They'd just think that they were correct ? ;)
13:34:51 <Twey> Yep :þ
13:35:06 <erus`> type classes?
13:35:13 <monochrom> try 2.8.1
13:35:27 <shapr> erus`: Was attempting to be humorous :-)
13:35:30 <JuanDaugherty> and he totally does know it and is involved intimately in it's progressive development
13:35:33 <erus`> i know :P
13:35:33 <Twey> erus`: Errr, I don't know about Go, but type classes are generally similar to interfaces in traditional OO languages.
13:35:36 <pastorn> monochrom: thanks :D
13:35:37 <Twey> Except with multiple dispatch.
13:35:53 <JuanDaugherty> SFAIK, he practically owns the 0xWhatever spec
13:35:55 <Cale> erus`: Type classes are like predicates on types which, when they're true, say that a particular interface of functionality related to that type is present.
13:36:05 <shapr> JuanDaugherty: what's that about mouse droppings?
13:36:07 <erus`> yeah sounds the same
13:36:11 <erus`> ok cool cool
13:36:20 <erus`> i like that kind of OO
13:36:23 <Cale> (and they can have multiple type parameters, providing relationships between types)
13:36:27 <JuanDaugherty> shapr, oh, the general computing market footprint of haskell
13:36:28 <Cale> They're not used for OO
13:36:35 <ski> erus` : you can have type classes which relates several types. can you do that in Go ?
13:36:39 <shapr> JuanDaugherty: Huh, I see Haskell used in lots of places.
13:36:41 <ben> Cale: Is that in "standard" haskell?
13:36:42 <shapr> JuanDaugherty: Where do you use Haskell?
13:36:51 <erus`> ski yeah, you can implement several interfaces
13:36:55 <Cale> they're used to restrict the types over which type variables range
13:37:03 <ski> erus` : no, a *single* type class
13:37:03 <shapr> JuanDaugherty: I see Haskell used in embedded systems, clusters, and everything inbetween.
13:37:10 <JuanDaugherty> shapr, not anyplace I get paid if that's the question
13:37:26 <Cale> ben: "Standard" Haskell doesn't include a lot of things which people use all the time unfortunately.
13:37:31 <erus`> errr reword the question
13:37:40 <shapr> JuanDaugherty: I've had the most success getting paid for contract work in Haskell. Have you tried that?
13:38:00 <listener> Thank you... for patience and explanation
13:38:38 <JuanDaugherty> shapr, is there a contradiction? IT is a multi trillion dollar industry these days. You're not trynna drag me into a lang flamination are you ? :)
13:38:41 <thoughtpolice> ben: you feel comfortable around a dirty and scary c++ code base? how dirty and scary? at least with haskell, if it's dirty and scary, I can (typically) rewrite it a hell of a lot easier, providing things are even remotely decomposed/slightly orthogonal
13:38:47 <shapr> JuanDaugherty: er, huh? I'm confused.
13:38:54 <Cale> ben: (Or depending on your perspective, quite fortunately)
13:39:13 <shapr> JuanDaugherty: You said you haven't been paid to write Haskell. I thought that meant you wanted to get paid to write Haskell?
13:39:14 <danharaj> We all program in GHC anyway.
13:39:16 <ben> Cale: Fortunately ghc has a lot of active research going on? :)
13:39:25 <Cale> yeah
13:39:30 <thoughtpolice> ben: i say this because, as someone who works on C++ that has dealt with all sorts of crazy shit, I am much more comfortable working around an unknown haskell codebase. it's safer almost by definition. but i have a bit of experience in both C++ AND haskell, so YMMV
13:39:33 <Evious> I have written dirty Haskell while sleep deprived and tired, using one letter names and not planning ahead. And then it worked the moment it compiled, with no bugs :p
13:39:37 <luite> what things can you do to make loading a module with ghc (typechecking, generating bytecode) faster? I'm already preloading/linking the packages that the module depends on
13:39:37 <listener> i just asked same question in #lisp
13:39:38 <thoughtpolice> er, s/works on/works with/
13:39:43 <Cale> ben: and Hugs and other implementations don't have much trouble implementing a lot of that as well
13:39:53 <erus`> anyone know a site with lots of haskell presentation/research videos?
13:39:53 <Evious> I've tried to do the same with C/C++, but it didn't end well.
13:40:04 <JuanDaugherty> shapr, that you use Haskell in paid work and know of many practical applications doesn't affect the statement of the degree/scale of its market penetration
13:40:18 <Cale> You want there to be a good amount of exploration and for implementations to stay ahead of standardisation in order for the language not to "die" in the sense of improvement.
13:40:18 <luite> erus`: youtube, vimeo ;)
13:40:19 <ben> thoughtpolice: My mileage probably varies because I have not enough experience with haskell (though I am sure I have less C++ experience than you as well), so I probably think too imperatively
13:40:20 <Younder> erus`, Microsoft research has some
13:40:45 <shapr> JuanDaugherty: Mice must be large where you live ;-) Haskell's market penetration is impressive in the places I've lived.
13:40:51 <ben> Cale: It certainly beats the C++ model where the language is ahead of the implementations for ten years and then decides to come back to the state of the implementations
13:40:53 <danharaj> I find any temp names longer than 3 letters in a function body make it harder for me to read.
13:40:55 <thoughtpolice> Cale: hey, I heard of this new radical language out there! it's called standard ML! do you think it'll die any time in the future?
13:41:06 <JuanDaugherty> shapr, that's israel isn't it?
13:41:15 <shapr> JuanDaugherty: No, USA.
13:41:18 <luite> erus`: at least some things are up there, ICFP talks, perhaps more introductory talks from local haskell user groups
13:41:23 <ski> erus` : like e.g. one can make something like `class Collection c e | c -> e where empty :: c; elem :: e -> c -> Bool; insert :: e -> c -> c; remove :: e -> c -> c' in Haskell, which is a type class relating types which can act like collection types to types which are used as element types of the former
13:41:39 <shapr> JuanDaugherty: Oh, USA and Sweden were places where I got paid to write Haskell.
13:41:55 <monochrom> (USA is huge, too)
13:42:14 <Cale> thoughtpolice: I'm fairly ignorant of what goes on in the ML world. Is there a lot of progress in terms of language features?
13:42:19 <JuanDaugherty> in the US there are millions of people in IT
13:42:24 <shapr> JuanDaugherty: How do you measure the computing market footprint?
13:42:32 <thoughtpolice> Cale: no, it was a joke, because man, SML is totally dead. :P
13:42:34 <ben> shoe sizes. duh.
13:42:35 * shapr decides to exploit JuanDaugherty's metric
13:42:42 <JuanDaugherty> i doubt more 10-20% of them have even heard of haskell
13:43:09 <JuanDaugherty> and that's prolly high
13:43:10 <thoughtpolice> Cale: MLton is still a very good ml implementation, but it hasn't gone forward in several years (basically maintenance mode,) and that's because SML as a language has been codified by a standard for a long time, and that basically equated to it being dead as far as activity.
13:43:40 <erus`> ski i cant even grok what your doing there
13:43:56 <shapr> JuanDaugherty: I'm not convinced that's a useful metric. I think it makes more sense to see if you can write software quickly/well with Haskell, and if you can get paid for such software.
13:44:08 <thoughtpolice> of course, not every standardized language dies because a new revision of a standard *doesn't* come out in some time frame, but SML is rather peculiar in that there has been almost 0 extensions to it by any compilers in the past several years
13:44:16 <Cale> That's sorta unfortunate, but it's reasonable given that we should have those people working on at least Haskell if not Agda and other futuristic languages.
13:44:19 <thoughtpolice> i think SML/NJ implements two small syntactic extensions, and one is for pattern matching
13:44:24 <JuanDaugherty> shapr, ur Shae Erikson oder, no?
13:44:33 <shapr> No, I'm Shae Erisson.
13:44:37 <erus`> ski: why does the constructor have two args?
13:44:41 <JuanDaugherty> right sorry didn
13:44:44 <ski> erus` : instances of this might look like `instance Collection IntSet Int where ...',`instance Ord e => Collection (Set e) e where ...', &c.
13:44:47 <JuanDaugherty> t see you had it set
13:45:01 <ski> erus` : `Collection' is not a constructor, it is a type class
13:45:12 <thoughtpolice> Cale: SML is a very clean language though, I like it a lot. just no community or activity. but it's got high quality implementations, and the language is quite nice I think!
13:45:42 <monochrom> apart from eqtype I like sml
13:45:43 <thoughtpolice> of course I don't like the syntax, because we all already know haskell has the best syntax, but oh well :>
13:45:45 <erus`> ah ok it makes sense
13:45:47 <Cale> thoughtpolice: The lexical syntax is painful though ;)
13:45:54 <Cale> yeah
13:45:56 <Cale> haha
13:46:27 <shapr> JuanDaugherty: Have you tried to get contract work writing Haskell?
13:46:36 * JuanDaugherty is old and I haven't chosen to identify with lang monocultures so my perspectives are somewhat unusual
13:46:54 <ski> thoughtpolice : which extensions are you thinking of ?
13:47:02 <JuanDaugherty> shapr, no I wouldn't want to do haskell for somebody else, for like galois or whatever
13:47:28 <JuanDaugherty> a free worker collective or sumthin, sure but not wage labor
13:47:32 <benmachine> wouldn't a monoculture be C#
13:47:33 <thoughtpolice> ski: sml/nj i know has some syntactical extensions for 'option patterns' IIRC, the other I can't remember off the top of my head. i haven't looked at sml/nj in several years though, I think MLton is nicer
13:47:37 * thoughtpolice checks
13:47:40 <JuanDaugherty> don't like to cross the streams like that
13:48:11 <shapr> JuanDaugherty: Sounds like open source software. Have you worked on any of the Haskell projects like lambdabot ?
13:48:21 <Cale> Well, the market is always at least 20 years behind what we can do with programming languages.
13:48:30 <Cale> It's just the way things work, unfortunately.
13:48:32 * ski doesn't find SML syntax very painful .. maybe a little more clumsy than Haskell in some places, but it's not a problem
13:48:41 * monochrom says 30 years
13:48:58 <Cale> Yeah, that's probably closer to the truth.
13:49:00 <JuanDaugherty> shapr, no, not yet
13:49:03 <thoughtpolice> oh, wow! sml/nj extends it a bit more than i thought
13:49:04 <thoughtpolice> http://smlnj.org/doc/features.html
13:49:14 * thoughtpolice eats his own words
13:49:22 <monochrom> 50 years if you are surrounded by people who want code to look like english
13:49:24 <shapr> JuanDaugherty: Last I heard, contributing a new plugin to lambdabot gives you lambdabot admin privs.
13:49:36 <hpaste> bos pasted “full config” at http://hpaste.org/47887
13:49:44 <ski> thoughtpolice : there's also <http://successor-ml.org/index.php?title=Main_Page>
13:49:54 <JuanDaugherty> but I am planning to something with the CSP pkg (Hoare's) i forget the name
13:49:55 <thoughtpolice> ski: ty
13:50:48 <monochrom> CHP
13:51:00 <JuanDaugherty> shapr, why would I care about that? I can run my own lambdabot if i want. Maybe not in this channel.
13:52:06 <shapr> JuanDaugherty: because it looks cool.. it's like having extra awesomeness! I've written some lambdabot plugins myself.
13:52:33 <shapr> JuanDaugherty: If you were only out for commercial results, I doubt you'd be here :-)
13:52:43 <JuanDaugherty> au contrair
13:52:57 <shapr> Ah, you are here in #haskell purely for commercial reasons?
13:52:58 <Cale> Lambdabot needs a maintainer though
13:53:06 <DukeDave> Are there any cabal people around?
13:53:15 <JuanDaugherty> unless somebody started the fucking revolution and I didn't get the memo
13:53:16 <Cale> (I am not lambdabot's maintainer, I just run the main instance of it here)
13:53:16 <shapr> Cale: Who's the lambdabot maintainer?
13:53:28 <Cale> Lambdabot doesn't currently have a maintainer
13:53:37 <ben> Sounds like you are the de-factor maintainer :(
13:53:38 <Martty> lambdabot isnt a bot at all
13:53:50 <Martty> just the volunteer in turn right now
13:53:53 <Martty> gotta be fast with ghci
13:54:09 <shapr> JuanDaugherty: So what commercial advantages brought you to #haskell ?
13:54:38 <JuanDaugherty> CSPM-Frontend
13:55:07 <luite> is there a difference in the GHCI environment between mkTopLevEnv for a module, and mkExportEnv and loading the imports manually?
13:55:22 <erus`> I wrote a tictactoe AI so give me the damn keys to the castle
13:55:28 <erus`> its opensource on github
13:55:45 <monochrom> "accomplishment unlocked" :)
13:56:17 <JuanDaugherty> (that's not the answer to your question, I don't think there are any commercial advantages to #haskell, no direct ones anyway)
13:56:38 <luite> oh I should add that that's for a module without an export list
13:58:07 <ben> I wonder what percentage of the total haskell userbase is in #haskell at least once a week
13:58:11 <Cale> JuanDaugherty: There are commercial advantages to using Haskell though, and there are advantages in terms of learning to use Haskell to using #haskell ;)
13:58:26 <monochrom> perhaps the top level environment of a module has unexported things, and the export environment doesn't
13:58:49 <Cale> ben: I don't think that we're actually all that much of it.
13:58:54 <JuanDaugherty> Cale, yes the latter is my main reason for being here
13:59:02 <luite> monochrom: yeah that's the usual difference. but my module doesn't have an export list, so everything should be exported
13:59:13 <JuanDaugherty> <- AKA Lycurgus, RenJuan
13:59:20 <monochrom> then probably no difference
13:59:36 <shapr> JuanDaugherty: You're also JKnecht sometimes, right?
13:59:39 <ben> I suspect we could play "six degrees of lambdabot" pretty easily though
13:59:59 <luite> monochrom: I'm asking because the module needs to be interpreted for mkTopLevEnv
14:00:03 * hackagebot swish 0.3.2.0 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.3.2.0 (DouglasBurke)
14:00:05 <erus`> what's the most minimal pure functional programming language? like a stripped down haskell toy language
14:00:17 <Twey> erus`: Lambda calculus?
14:00:17 <shapr> erus`: The SKI combinators?
14:00:17 <JuanDaugherty> shapr, I stopped using that after about the first year or two here, maybe 4-5 years ago
14:00:48 <JuanDaugherty> I only use Lycurgus, and my real western and chinese names now
14:00:48 <k0ral> how do you break a forever structure ?
14:00:56 <k0ral> +from
14:01:17 <monochrom> depends on the exact meaning of "forever structure"
14:01:26 <k0ral> forever $ do blablabla
14:01:35 <benmachine> k0ral: that depends on the monad and isn't always possible
14:01:38 <monochrom> is that in IO or some other monad?
14:01:41 <k0ral> Control.Monad
14:01:50 <monochrom> no general way
14:02:16 <k0ral> basically, I'm forking a thread that performs a forever
14:02:24 <benmachine> ah, so it's IO then
14:02:33 <monochrom> sigh, then you should say "IO" rather than "Control.Monad"
14:02:40 <monochrom> throw an exception
14:02:41 <k0ral> I'd like it to stop asynchronously (let's say with a MVar)
14:02:47 <Twey> If it's an IO you can throw an exception or something
14:02:55 <Twey> You can just throwTo — no need for MVars
14:03:15 <monochrom> you can also killThread from inside or outside
14:03:22 <benmachine> yes
14:03:30 <benmachine> or, don't use forever
14:03:32 <benmachine> is the other option
14:03:37 <Twey> Also a good option
14:03:47 <benmachine> use recursion that sometimes doesn't
14:03:52 <k0ral> I need the thread to exit in a clean way
14:03:54 <monochrom> you should not generalize your question in general
14:04:22 <benmachine> k0ral: define 'clean'
14:04:25 <monochrom> some clean up can be done in exception handlers
14:04:29 <benmachine> or, why do you need that?
14:04:32 <monochrom> and yeah, you should not generalize your question in general
14:04:34 <JuanDaugherty> clean = doesn't trap
14:04:42 <k0ral> fine, let's dig into details then
14:05:01 <shapr> JuanDaugherty: So what's your interest in CSP?
14:05:07 <k0ral> I have a function fun :: IO () -> IO ()
14:05:09 <benmachine> monochrom: you should not generalise your generalisation advice in general generalisations.
14:05:28 <k0ral> the forked thread will trigger fun with argument fun2 :: IO ()
14:05:43 <k0ral> let's say fun = forever $ fun2
14:06:01 <monochrom> you mean fun fun2 = forever $ fun2
14:06:07 <k0ral> yes sorry
14:06:10 <JuanDaugherty> shapr, intend to put together some general purpose support for distributed computing based on it
14:06:56 <k0ral> actually let's say fun fun2 = do (forever $ fun 2) >> putStrLn "BLABLA" >> return ()
14:07:17 <k0ral> -fun 2 +fun2
14:07:31 <k0ral> currently, BLABLA is never displayed
14:07:40 <monochrom> fun fun2 = forever fun2 `finally` putStrLn "BLABLA"
14:07:40 <k0ral> since I cannot leave the forever structure
14:07:42 <ski> k0ral : the type of `forever' means that `forever foo' can't monadically return a value (barring partial values)
14:07:53 <monochrom> and fun2 throws an exception to quit
14:07:57 <shapr> JuanDaugherty: I saw some recent activity in the world of distributed computing with Haskell, is that what got you interested?
14:09:14 <monochrom> you also have the option of not using forever, of course
14:09:14 <k0ral> ski: so you mean my fun cannot exist ?
14:09:20 <JuanDaugherty> shapr, no but what are you referring to, support of parallelization in upcoming ghc?
14:09:27 <JuanDaugherty> *support for
14:09:27 <k0ral> monochrom: what alternative do you suggest ?
14:09:37 <monochrom> explicit recursion
14:10:08 <k0ral> well, forever a = a >> forever a ?
14:10:37 <shapr> JuanDaugherty: Have you seen CloudHaskell? http://hackage.haskell.org/trac/ghc/wiki/ErlangInHaskell
14:11:07 <k0ral> monochrom: ^ + how would this solve my problem ?
14:11:18 <monochrom> I feel that you have a design flaw. "do it infinitely many times, let me know when you are done" sounds like an oxymoron or a sarcasm
14:11:34 <k0ral> I completely agree
14:11:41 <k0ral> but can't find any alternative
14:11:48 <benmachine> k0ral: the idea is to do something like
14:11:51 <monochrom> so, do not specify "do it infinitely many times"
14:12:07 <benmachine> fun = do thing; a <- checkMVar; if a then fun else return ()
14:12:17 <katja> hey! could you please help me. I have forgotten my password here . how can I restore it?
14:12:19 <monochrom> specify a concrete condition to stop, and code up around that
14:12:20 <benmachine> ^ repeatedly does thing until checkMVar says to stop
14:12:27 <benmachine> katja: what password?
14:12:39 <k0ral> benmachine: I thought of this, but there is still a problem
14:12:46 <k0ral> "thing" is a blocking IO ()
14:12:50 <JuanDaugherty> shapr, no don't think I had. Does he have a nick here?
14:13:09 <katja> benmachine: for a nickname on freenode servise
14:13:10 <shapr> JuanDaugherty: I don't know.
14:13:12 <benmachine> k0ral: so?
14:13:14 <ski> k0ral : write an `doUntil :: IO Bool -> IO ()' ?
14:13:17 <k0ral> so even if I send a signal via a MVar, it won't be received until "thing" has progressed
14:13:34 <k0ral> and thing doesn't progress often
14:13:45 <benmachine> katja: oh, we can't help with that, it probably says what to do on the freenode website, or you can try /msg NickServ help
14:14:08 <benmachine> k0ral: so you want 'thing' to be /interrupted/ somehow?
14:14:16 <k0ral> benmachine: yes
14:14:29 <JuanDaugherty> shapr, well thx, I'll evaluate it vs. CSPM-Frontend
14:14:32 <benmachine> k0ral: you want exceptions. get the thread ID with myThreadId and use throwTo or killThread
14:14:56 <benmachine> k0ral: then use catch or try or whatever is your favourite in the thread to receive the exception and deal with it snesibly
14:15:02 <shapr> JuanDaugherty: Sure, tell me how it works out.
14:15:21 <JuanDaugherty> will do
14:15:27 <ski> katja : maybe you could also try asking in #freenode ?
14:15:31 <k0ral> benmachine: I will read about that, but at first sight, I still can't get how it could work
14:15:34 <katja> REGISTER <27121989> <kate.kokatjuhha@googlemail.com>
14:15:54 <katja> damn
14:16:03 <mauke> thanks for your email address
14:16:24 <k0ral> benmachine: I'll come back later with more bothering questions
14:16:28 <benmachine> k0ral: cool :)
14:16:35 <ski> katja : i think you should not put `<' and `>' around the password and email address, there
14:16:36 <k0ral> but thank you for your help
14:17:29 <benmachine> katja: also, the logs for this channel are published somewhere I think; if that's actually your password for anything, change it
14:17:39 <benmachine> (do you give REGISTER your password? I don't remember)
14:17:50 <ski> you do
14:18:11 <monochrom> t <- forkIO (forever fun2 `finally` putStrLn "!"); threadDelay 5000000; killThread t
14:18:42 <JuanDaugherty> is googlemail.com the same as gmail?
14:18:50 <monochrom> fun2 = getLine >>= putStrLn
14:19:07 <copumpkin> JuanDaugherty: yeah
14:19:19 <benmachine> JuanDaugherty: they're both email by google. my understanding is that googlemail was created for some weird copyright reason, and was the only thing available in the UK for a while
14:19:23 <monochrom> now there is a blocking thing you keep repeating but killed after 5 seconds
14:19:36 <benmachine> JuanDaugherty: some time ago they offered googlemail people the opportunity to switch to gmail though so I guess it's worked out
14:19:42 * JuanDaugherty never new and it's been my mailer for 5 years+
14:19:58 <inter> Has anyone here had problems compiling PAKCS using GHC?
14:21:27 <JuanDaugherty> inter, ur trynna build curry in ghc?
14:21:39 <JuanDaugherty> *with ghc
14:23:09 <inter> Yeah, I'm having trouble getting CYI and PAKCS running on the new Fedora release. Now GHC is complaining about ambiguous references from import in the source.
14:23:26 <JuanDaugherty> *knew
14:23:42 <akvarel> how can I join java channel?
14:23:52 <akvarel> with /join java?
14:23:59 <hpaste> adnap pasted “bounds” at http://hpaste.org/47888
14:24:11 <adnap> whoa
14:24:11 <JuanDaugherty> prolly #java or ##java
14:24:13 <adnap> cooll
14:24:16 <adnap> that's new
14:24:28 <shapr> Oh, announce got fixed!
14:24:45 <adnap> can anyone tell me why this doesn't behave as i expect?  why can i create a GInt 9?
14:25:05 <akvarel> JuanDaugherty:doens work
14:25:16 <akvarel> JuanDaugherty:doesnt work
14:25:23 <JuanDaugherty> did for me it's ## there's about 350 people there
14:26:46 <ski> shapr : yeah, chrisdone got around to it, in the last days
14:26:51 <shapr> yay!
14:26:58 <erre> step3... what next?
14:27:38 <adnap> how does Int implement wraparound?
14:27:46 <ski> (if you use the link in the topic, it will also auto-select language Haskell and channel #haskell, as default)
14:27:51 <DukeDave> Why must you mock me cabal! :'(
14:28:11 <DukeDave> I just wanted to get wxhaskell
14:28:37 <DukeDave> But of *course* you don't with a proxy, and of *course* I can't get the source from darcs and build it
14:28:53 <inter> adnap, try applying the data constructor to the integer values on the rhs of minBound and maxBound.
14:29:32 <dcoutts> DukeDave: what's the problem?
14:29:34 <adnap> inter: i did
14:29:38 <adnap> inter: it doesn't change anything
14:30:11 <sshc> DukeDave: What's wrong?
14:30:46 * DukeDave So, I tried using cabal install, but that failed with my proxy
14:30:55 <inter> It works fine for me. You probably aren't annotating calls to minBound with a type and getting an error about ambiguous type variables.
14:31:06 <dcoutts> DukeDave: oh, it doesn't like your http proxy? any idea why?
14:31:12 <JuanDaugherty> DukeDave, when I "just wanna" I look to HP
14:31:23 <dcoutts> DukeDave: it's not a funny one that requires JavaScript to configure or something?
14:31:54 <DukeDave> No, not at all, it's worked for everything else :|
14:32:00 <DukeDave> The issue is identical to here: http://stackoverflow.com/questions/1551053/how-do-i-get-cabal-to-bypass-my-windows-proxy-settings
14:32:57 <JuanDaugherty> why don't you just access it from someplace else?
14:33:28 <DukeDave> JuanDaugherty: My broadband provider don't believe in timely service :(
14:34:38 <shapr> Hm, I have a vps, I could become lambdabot instance and repo maintainer.
14:34:46 <JuanDaugherty> DukeDave, your best experience of haskell will be on linux or mac i think
14:34:46 <benmachine> @get-shapr
14:34:46 <lambdabot> shapr!!
14:34:51 <shapr> benmachine: you called?
14:34:58 <benmachine> shapr: I think lambdabot likes you
14:35:03 <shapr> benmachine: could be...
14:35:04 <DukeDave> I cleared my proxy related env vars as suggested, and it failed over to direct, I was then hoping I could just use proxy_chains, but it kept seg faulting :(
14:35:20 <adnap> @hoogle a -> (a -> Bool) -> Maybe a
14:35:20 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
14:35:20 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
14:35:20 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
14:35:21 <DukeDave> JuanDaugherty: I'm using Ubuntu!
14:35:49 <JuanDaugherty> i thought windows-proxy referred to the OS
14:36:59 <DukeDave> JuanDaugherty: Oh, that's not my SO question, but it has exactly the same symptoms as I see on Ubuntu
14:37:14 <DukeDave> dcoutts: There's no known issues with proxies then?
14:37:15 <JuanDaugherty> ah
14:37:59 <DukeDave> There's an old bug out on it: http://hackage.haskell.org/trac/hackage/ticket/562
14:39:31 <DukeDave> Aw, someone linked to a patch which apparently resolved it, but it's an invalid hpaste URL
14:40:47 <DukeDave> Ah, it became a bug in HTTP and was resolved fixed 18 months ago :|
14:41:00 <dcoutts> DukeDave: there's an issue with configuration for some corporate proxies that use JS, and some proxies lie and silently gunzip things (though I think we made a workaround for that)
14:41:17 <dcoutts> DukeDave: ah, yes, we do rely on a recent HTTP
14:42:13 <DukeDave> Hmm, well I'm tethering over my mobile phone, which is the proxy
14:42:47 <DukeDave> But I can't imagine it's doing anything sophisticated
14:43:01 <dcoutts> DukeDave: if it still doesn't work with the latest HTTP lib, then lemme know. I'll want a log of cabal update -v3 (or similar)
14:43:30 <adnap> @hoogle [Maybe a] -> [a]
14:43:30 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
14:43:30 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
14:43:30 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
14:44:36 <JuanDaugherty> DukeDave, tethered operation is pushin it
14:46:07 <DukeDave> JuanDaugherty: Well apt, darcs and git all seem to manage okay from the command line, so it can't be that weird
14:46:39 <DukeDave> dcoutts: Here's the magic: I'm using cabal-install from apt on Ubuntu
14:47:09 <dcoutts> DukeDave: sure, they're using different HTTP libs
14:47:16 <dcoutts> e.g. curl in the case of darcs
14:47:22 <JuanDaugherty> DukeDave, yeah, it depends on the carrier. All my tethering experience is with AT&T on iphone
14:48:36 <adnap> > [(+2), (*3)] <*> [2, 5]
14:48:37 <lambdabot>   [4,7,6,15]
14:48:42 <adnap> aw
14:48:44 <DukeDave> JuanDaugherty: Ah, interesting, I do know they do some magic to compress images down
14:48:55 <DukeDave> dcoutts: I have: libghc6-http-dev-4000.0.6-69dbf          If that means anything?
14:49:05 <JuanDaugherty> well I think the big thing is the moving ip
14:49:05 <adnap> man, i've forgotten so much
14:49:11 <dcoutts> DukeDave: yeah, try a later one
14:49:30 <dcoutts> DukeDave: basically you need to rebuild HTTP and cabal-install from source
14:49:57 <adnap> how do you take a list of functions and a list of arguments, and get a list where the first element is the first function applied to the first argument, the second element is the second function applied to the second argument, etc.?
14:50:06 <dcoutts> DukeDave: if updating then still doesn't work, file a ticket with the output of cabal update -v3 (assuming that's the command that's failing)
14:50:22 <DukeDave> dcoutts: Okay, sorry to go off topic, but do you know if I can build my own libs without breaking the ones from apt?
14:50:23 <inter> zipWith the apply operator
14:50:36 <DukeDave> Incidentally I currently have: cabal-install_0.8.0-1_i386
14:50:37 <mauke> adnap: zipWith id
14:50:38 <ryant5000> does anyone know when the haskell reddit was created?
14:50:55 <dcoutts> DukeDave: cabal installs in $HOME by default, so doesn't overwrite any stuff from apt
14:51:18 <DukeDave> I was using --global :D
14:51:18 <adnap> mauke: that's clever
14:51:32 <monochrom> don't mix --global with apt-get
14:51:43 <benmachine> doesn't --global go into /usr/local?
14:51:53 <monochrom> yes, but that is not the problem
14:52:02 <DukeDave> monochrom: Yeah?
14:52:16 * DukeDave is never sure which path to take with a nice managed Linux distro
14:52:25 <monochrom> or rather, that doesn't alleviate any problem
14:52:41 <DukeDave> I wonder if I should just abandon apt altogether and go down the Haskell platform route
14:52:44 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml for the real problems, and they have nothing to do with directories
14:53:04 <Jafet> apt-get install haskell-platform
14:53:04 <monochrom> in short, metadata dominates over data
14:53:20 <JuanDaugherty> DukeDave, NixOS is the distro consonant with Haskell
14:53:50 <geheimdienst> arch linux is the distro vowel with haskell ...
14:55:14 <DukeDave> Hmm, I just don't want to break everything :|
14:55:21 * monochrom feel sad that people just assume ghc scans directories for libs every time and don't know the dark truth
14:55:27 * ddarius solves the problem with metametadata.
14:55:37 <mux> pffft, cd /usr/ports/devel/hs-haskell-platform && make install clean
14:55:38 <mux> :-)
14:55:41 <benmachine> DukeDave: man, what kind of attitude is that? breaking everything is totally fun times
14:55:51 <thoughtpolice> never metadata i didn't like
14:56:07 <adnap> and if you have a bunch of functions a -> Maybe a, how do you run a value through all of them, getting a Nothing if any one of the functions returns Nothing, and a Just otherwise?
14:56:08 <monochrom> hahaha
14:56:10 <DukeDave> benmachine: This is what happens when you use Ubuntu, you become complacent ;)
14:56:21 <mux> adnap: monads!
14:56:26 * DukeDave now gets upset when a webcam doesn't natively work
14:56:29 <adnap> i know
14:56:34 <adnap> i can't remember though!
14:56:34 <adnap> argh
14:56:40 <mauke> mapM?
14:56:44 <benmachine> :t foldr (<=<) return
14:56:45 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
14:56:57 <benmachine> ^ works if it's the same 'a' in every case
14:57:22 <ddarius> thoughtpolice: 'should be metadatum.
14:57:30 <monochrom> if they are not the same a, you can still "z <=< y <=< x" manually
14:57:32 <adnap> :t (<=<)
14:57:33 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
14:58:00 <Jafet> Metadatas
14:58:07 <benmachine> metadatae
14:58:18 <geheimdienst> metalore
14:58:25 * benmachine giggles
14:58:33 <thoughtpolice> ddarius: foiled again :(
14:58:37 <mietek> Anyone taking part in the ICFP contest this year?
14:58:42 <mauke> metal ore?
14:58:48 * sully ICFPing
14:59:09 <JuanDaugherty> a bunch of lisper I think
14:59:14 <monochrom> I am not doing the icfp contest
14:59:15 <JuanDaugherty> *lispers
14:59:20 * thoughtpolice has never done icfp
14:59:22 <thoughtpolice> although it looks like fun
14:59:29 <sully> of my team, 4/5 know haskell and 4/5 know SML
14:59:41 <sully> and we haven't decided which we are using yet
14:59:47 <mietek> thoughtpolice: the 2006 contest was most excellent
14:59:48 <monochrom> haha
14:59:54 <sully> yeah, the 2006 one was great
15:00:08 <mux> is 2006 the one with the VM?
15:00:09 <JuanDaugherty> SML = standard ML?
15:00:12 * hackagebot spreadsheet 0.1.1 - Read and write spreadsheets from and to CSV files in a lazy way  http://hackage.haskell.org/package/spreadsheet-0.1.1 (HenningThielemann)
15:00:13 <sully> mux: yes
15:00:13 <monochrom> yes
15:00:15 <benmachine> sully: presumably not the same 4? :P
15:00:15 <sully> JuanDaugherty: yes
15:00:15 <mux> because that was clearly awesome
15:00:21 <sully> benmachine: yeah, not the same 4
15:00:27 <mux> the adventure game, oh my
15:00:29 <mietek> http://www.boundvariable.org/
15:00:30 <mux> the 2d coding
15:00:36 <ddarius> sully: That's an easy choice.
15:00:41 <mux> the basic with roman numerals, hahaha
15:00:44 <sully> I think it is probably easier for a haskeller to pick up SML on the fly than for a SMLer to pick up haskell on the fly
15:00:46 <mux> I so loved it.
15:00:51 <mietek> Yeah
15:00:53 <ddarius> benmachine: It would have been more interesting that way though.
15:01:05 <benmachine> heh
15:01:10 <thoughtpolice> mietek: looks cool!
15:01:13 <DukeDave> Nooo, now I get wxHaskell from darcs, and it won't build :'(
15:01:16 <thoughtpolice> i think i remember hearing about that one
15:01:25 * thoughtpolice had just baaarely started learning haskell, at the time
15:01:28 <mux> http://mu.org/~mux/mult.2d <- heh, I still have some old stuff from it
15:01:38 * DukeDave doesn't miss dependency hell
15:02:09 <mietek> mux: nice domain name; have you tried mu.mu? :)
15:02:18 <mux> mietek: not mine actually :-)
15:03:09 <mux> hey, I think I could have space-optimized mult some more.
15:03:14 <mux> whatever
15:03:31 <Jafet> What's mu.mu?
15:04:27 <mux> I remember there was a video of one of the organisator who implemented the vm in postscript, and demo'ed it in the video, going to the printer, etc :-P
15:04:30 <Jafet> :t fix.fix
15:04:31 <lambdabot> forall a. ((a -> a) -> a -> a) -> a
15:06:07 <mux> > fix error
15:06:08 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
15:06:34 <copumpkin> > fix fail
15:06:35 <lambdabot>   ""
15:06:43 <copumpkin> > fix show
15:06:44 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
15:09:56 <inter> I understand 'fix succ' but not
15:10:08 <inter> 'fix show'. Why is it printing slashes?
15:10:35 <sully> so, when you fix show
15:10:38 <benmachine> > show ""
15:10:39 <lambdabot>   "\"\""
15:10:41 <sully> show winds up being String -> String
15:10:46 <benmachine> ^ do you understand why it does that, inter?
15:10:59 <sully> and the first character of show on a string is always going to be "
15:11:13 <monochrom> each time you show a string that has a " in it, you get a backslash to escape it
15:11:46 <Twey> > show ""
15:11:47 <lambdabot>   "\"\""
15:11:48 <benmachine> monochrom: I finished reading your SICP article, I like your style
15:11:53 <Twey> > show "\"\""
15:11:54 <lambdabot>   "\"\\\"\\\"\""
15:11:55 <monochrom> thank you
15:12:07 <Twey> > show "\"\\\"\\\"\""
15:12:08 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\"\\\"\""
15:12:10 <mauke> > iterate show ""
15:12:10 <lambdabot>   ["","\"\"","\"\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\...
15:12:27 <Twey> That would be the *sensible* way to do it :þ
15:12:58 <inter> Interesting, thanks for explaining.
15:13:26 <monochrom> and of course, each time you show a string that has a backslash, you get more backslashes to escape it, too
15:13:44 <mux> fix (scanl (+) 0 . (1:))
15:13:51 <mux> > fix (scanl (+) 0 . (1:))
15:13:53 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:14:17 <monochrom> see my http://www.vex.net/~trebla/haskell/scanl.xhtml for how fix (scanl (+) 0 . (1:)) works
15:16:53 <parcs> > fix $ (0:) . scanl (+) 1
15:16:55 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:17:15 <parcs> > fix $ scanl (+) 0 . (1:)
15:17:17 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:21:40 <plsch> this is good stuff
15:23:42 <Eduard_Munteanu> I bet it doesn't come cheap.
15:25:46 <scooty-puff> i was hoping someone could help explain something funny about type families and functional dependencies
15:26:10 <hpaste> scooty-puff pasted “Type Families and Fun Deps” at http://hpaste.org/47893
15:26:41 <scooty-puff> the commented out section compiles, while the uncommented section doesn't (and correctly does not)
15:28:28 <djahandarie> @tell mgsloan http://www.vex.net/~trebla/haskell/sicp.xhtml
15:28:28 <lambdabot> Consider it noted.
15:28:55 <tactical> hi folks.  does anyone else feel quite depressed after spending a long time programming in haskel
15:29:11 <monochrom> no
15:29:18 <hpaste> LeNsTR pasted “Simple server” at http://hpaste.org/47894
15:29:28 <plsch> never
15:29:38 <byorgey> tactical: depressed how?
15:30:08 <tactical> like, feeling like there's no need to go on
15:30:28 <LeNsTR> :)
15:31:24 <parcs> tactical: "go on" with respect to what?
15:31:36 <tactical> like, wanting life to all be over
15:31:41 <JuanDaugherty> tactical, no but a recent great insight (due to "This Emotional Life") i've had is that the opposite of depression is vitality
15:32:08 <scooty-puff> the hotel i'm in has a little calendar that says "happiness is a state of activity"
15:32:09 <JuanDaugherty> that and that none of the treatments really work
15:32:17 <hpaste> greenland pasted “3?” at http://hpaste.org/47895
15:32:31 <JuanDaugherty> people just decide to not be depressed
15:32:37 <greenland> does anybody know why that is a parser error?
15:32:56 <kmc> you can't just define functions in a "do" like that
15:33:14 <kmc> you can do it in a "where" block outside the "do", or a "let" block inside
15:33:23 <kmc> also you probably want show (myLength text)
15:33:25 <greenland> i had them un-indented and it gave the same error so i figured the opposite was true. >_>
15:33:37 <kmc> well if you un-indent you'll then need the "where" keyword
15:33:52 <greenland> where where?
15:35:09 <hpaste> kmc annotated “3?” with “3? (annotation)” at http://hpaste.org/47895#a47896
15:35:13 <kmc> easiest just to show ^^^^
15:35:32 <MHD> Is there an arrow parsing library that makes use of the Swiestra and Duponcheel method?
15:35:32 <kmc> you actually have a lot of leeway on where to put stuff and how much to indent
15:35:33 <greenland> rock on
15:35:39 <kmc> indentation is just shorthand for braces and semicolons
15:36:00 <kmc> if you have trouble with indentation you can switch to the whitespace-insensitive style and sort out the syntax
15:36:06 <kmc> and then figure out how to achieve those with whitespace
15:37:17 <MHD> @type app
15:37:17 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
15:40:51 <ben> so is haskell: the craft of fp one of those books where you can't actually read it on the internet before buying it?
15:41:21 <monochrom> probably
15:41:39 <ben> author's name is simon, it's probably worth the money
15:41:42 <monochrom> it is also rather dated
15:41:45 <kmc> heh
15:42:01 <kmc> is it a book about Haskell, or a book about FP?
15:42:36 <ben> I'm just looking at it because of dons' tweet. https://twitter.com/donsbot/statuses/81476696213164032
15:44:06 <monochrom> 3rd edition! no wonder
15:44:20 <monochrom> then it is not dated
15:44:48 <monochrom> perhaps you should wait for amazon to post some excerpt
15:45:12 <ben> Well, for now it's gonna sit next to RWH and LYAH on my wishlist. I am not good with purchase decisions.
15:45:18 <monochrom> I wonder what is "new material on testing"
15:45:26 <kmc> those two are free online, though
15:45:52 <ben> Yeah, maybe I should just send BONUS a couple bucks and skip the middleman.
15:45:52 <monochrom> web browser graphics?! I wonder how he pulls that off
15:47:02 <monochrom> but I/O early is a good sign if you are a practical person
15:55:22 <danharaj> what would you guys call {lines} U {line segments} U {rays} ?
15:56:12 <othiym23> I almost just said "power lines", but I caught myself almost in time
15:56:18 <maurer_> Directionals?
15:56:32 <maurer_> Why are these all going in the same type?
15:56:42 <maurer_> (it seems the only common property they have is direction)
15:56:49 <danharaj> Because I'm performing intersection tests on them.
15:56:58 <maurer_> Ah.
15:57:09 <danharaj> I've settled on `LineShapes' but that sounds a bit silly.
15:57:20 <kmc> use http://www.classnamer.com/
15:57:38 <danharaj> FlexibleTimestampAnnotation
15:57:39 <danharaj> perfect!
15:57:53 <fryguybob> zero curvature stuff
15:58:06 <danharaj> planes have zero curvature too
15:58:39 <kmc> "generalized line segment"?
15:58:43 <kmc> "line part"?
15:58:44 <danharaj> the most descriptive name I can think of is
15:58:48 <kmc> "line fragment"
15:58:55 <danharaj> "Closed subsets of one dimensional affine subspaces"
15:59:04 <danharaj> (closed non-empty)
15:59:08 <danharaj> (closed connected non-empty)
15:59:32 <othiym23> data ClosedConnectedNonEmptySubsetsOfOneDimensionalAffineSubspaces = ...
15:59:34 <othiym23> perfect!
15:59:39 <kmc> needs more factory
16:00:07 <othiym23> type CCNESOODAS = ClosedConnectedNonEmptySubsetsOfOneDimensionalAffineSubspaces if you need a shorter name
16:00:17 <danharaj> as a side question
16:00:19 <othiym23> seems mnemonic enough to me
16:00:45 <danharaj> what is the pattern called where you don't export constructor names and export functions that act like constructors but also perform invariant checking?
16:00:50 <evaryont> how does one get the name of the process? similar to shell's $0 or ARGV[0].
16:00:56 <ben> smart constructors?
16:01:11 <danharaj> ben: thanks.
16:01:13 <kmc> ideally you could write that type as a dependent product, i.e. (S ⊆ Affine 1, S ≠ Ø, Closed S, Connected S)
16:01:17 <hpc> evaryont: try the POSIX module
16:01:32 <kmc> there's a portable way
16:01:33 <parcs> @hoogle getExecutablename
16:01:33 <lambdabot> No results found
16:01:37 <kmc> System.Environment.getProgName
16:01:47 <evaryont> kmc, hpc: thanks
16:01:58 <hpc> oh cool
16:02:06 <parcs> oh, that's it
16:02:10 <danharaj> kmc: I prefer thinking about it as a disjoint union because that let's you reason about it pattern matching-like
16:02:30 <danharaj> of course ideally you'd be able to prove the types are equivalent.
16:03:13 <kmc> sounds like a fun exercise ;)
16:03:16 <kmc> paging dr. copumpkin
16:04:45 <danharaj> also ideally I would be able to use (.) with linear transformation represented as matrices by writing a type class.
16:04:52 <danharaj> But that's tangential.
16:05:00 <danharaj> (instance)
16:05:04 <copumpkin> kmc: ohai
16:05:09 <copumpkin> sup?
16:05:20 <kmc> i heard you like proving stuff ;)
16:05:24 <copumpkin> oh I do
16:05:38 <geheimdienst> well prove it, then
16:05:39 <kmc> danharaj, yeah, the syntax for composition is not that important
16:05:47 <copumpkin> prove that I like proving stuff?
16:06:08 <kmc> danharaj, would you do that by writing an instance of Category?
16:06:20 <copumpkin> danharaj: write an instance of Category in my agda CT lib! :D
16:06:20 <danharaj> kmc: I suppose.
16:06:28 <kmc> there's a category of linear maps, i suppose
16:06:32 <copumpkin> well, mine and xplat's :)
16:06:46 <danharaj> copumpkin: does agda have OpenGL bindings yet?
16:06:51 <danharaj> (or an ffi in general ;) )
16:06:55 <copumpkin> danharaj: an FFI to haskell :)
16:07:04 <danharaj> FFI's within FFI's
16:07:14 <copumpkin> but nobody knows how it works
16:07:16 <kmc> if you're using Agda then Haskell is the low-level, unsafe, grungy, impure language
16:07:20 <copumpkin> cause nobody ever runs their agda programs
16:07:25 <danharaj> heh
16:07:33 <kmc> so it's the natural choice for FFI
16:07:51 <danharaj> so we're going to have towers of languages
16:07:54 <copumpkin> danharaj: anyway, it's fun if you like logic and proofs :P not so much if you like pretty pictures on the screen
16:08:05 <kmc> danharaj, I would say we've had them for quite a while
16:08:14 <danharaj> copumpkin: how is program extraction in agda?
16:08:28 <copumpkin> well, it's just called compilation
16:08:34 <copumpkin> and it's currently pretty terrible
16:08:44 <monochrom> agda programs can be run, don't worry
16:08:45 <copumpkin> in that it compiles to haskell with unsafeCoerce around every expression
16:08:50 <kmc> yessss
16:08:54 <copumpkin> there's a new compiler though
16:09:00 <copumpkin> and apparently it's better but doesn't go through haskell anymore
16:09:07 <kmc> does that break the Haskell FFI?
16:09:10 <monochrom> someone actually uses agda for web thingies and prove them correct and obviously run them
16:09:10 <copumpkin> not sure
16:09:26 <kmc> i would think you'd want to compile to Core or something
16:09:40 <kmc> but the new compiler uses some intermediate language designed for implementing languages like Agda, IIRC
16:09:44 <danharaj> Core isn't very stable is it?
16:09:45 <monochrom> and tries to recommend it all to ruby people
16:09:54 <copumpkin> kmc: except you can't hand GHC core and ask it to compile it
16:09:54 <kmc> haha monochrom
16:10:01 <copumpkin> except for that external core stuff
16:10:05 <copumpkin> that isn't very well fleshed out
16:10:07 <kmc> copumpkin, yeah, i thought LHC did just that
16:10:08 <monochrom> yeah, the guy started with ruby
16:10:15 <kmc> or does LHC do the opposite
16:10:22 <kmc> right, it does the opposite, my bad
16:10:25 <copumpkin> yeah
16:10:29 <kmc> it's a whole program Core → native code backend for GHC
16:12:46 <danharaj> Is LHC still active?
16:15:02 <copumpkin> hasn't been recently
16:15:04 <copumpkin> I don't think
16:15:13 <copumpkin> in fact, I'm the only person left in the IRC channel
16:15:18 <copumpkin> Lemmih would know though
16:15:26 <danharaj> it's kind of uncomfortable to me that GHC seems to be the only project that stays alive
16:16:08 <kmc> UHC is still active
16:16:15 <JuanDaugherty> was Agda Martin-Löf's wife or sumthin?
16:16:33 <kmc> didn't they add a Javascript backend recently?
16:16:41 <geheimdienst> it's an ancient king. agdamemnon
16:16:48 <JuanDaugherty> ah, thx
16:16:55 <danharaj> geheimdienst: worst pun ever.
16:16:55 <kmc> JHC also had a release within the last few months, and some people used it for cool stuff (Wii homebrew, iirc)
16:17:07 <geheimdienst> my work here is done
16:17:12 <kmc> what makes me sad is that Hugs is basically done
16:17:45 <kmc> IMO your crazy optimizing native-code compiler should be paired with a portable-C interpreter
16:17:57 <kmc> they can share a (self-hosted) frontend
16:18:08 <kmc> and then you can distribute precompiled bytecode for the compiler, which can be used by the interpreter
16:18:12 <kmc> makes bootstrapping new platforms much easier
16:18:20 <kmc> this is roughly how ocamlc works
16:18:24 * JuanDaugherty totally was looking for like a babylonian diety
16:18:57 <JuanDaugherty> so wtf is it an acronym, proper name, what?
16:19:15 <kmc> also, Hugs and JHC and UHC all have interesting extensions that GHC doesn't
16:20:02 * danharaj rips hair out
16:20:07 <benmachine> JHC has ACIO doesn't it?
16:20:10 <kmc> yes
16:20:22 <benmachine> that's pretty cute
16:20:32 <kmc> Hugs has Trex, i don't know much about it but it's at least an attempt to make records less terrible
16:20:36 <danharaj> Computational geometry is a bitch. Even though special cases are easier to handle because of variants.
16:20:36 <benmachine> I can't remember what "affine" means in this context though
16:21:02 <benmachine> does it mean "it's ok for this to not happen" or something
16:21:09 <kmc> i think it means that if the result is unused, it's as if the action never executed
16:21:10 <kmc> yeah
16:21:17 <kmc> and "central" means it commutes with the rest of IO
16:21:33 <kmc> as in group theory
16:21:35 <benmachine> yeah, I remember that one because I group theory
16:21:42 <kmc> so it's basically stuff like creating MVars
16:21:45 <danharaj> Do you accidentally all the group theory?
16:21:49 <kmc> if you create an MVar and throw it out, no harm no foul
16:21:56 <kmc> and if you create two MVars, the order doesn't matter
16:22:06 <JuanDaugherty> *deity
16:22:13 <kmc> what's really clever is that they then have a way to embed arbitrary IO into ACIO safely
16:22:29 <benmachine> oh?
16:22:32 <kmc> though I think you can implement this with just MVar ACIO
16:22:35 <danharaj> kmc: That's a cool idea. The more algebraic structure IO has, the easier it is to reason about.
16:23:14 <kmc> benmachine, yeah, it's like IO t -> ACIO (IO t)
16:23:31 <benmachine> huh? how does that help?
16:23:37 <kmc> executing the resulting IO action executes the input action, but only the first time
16:23:44 <benmachine> ahh
16:23:45 <kmc> subsequent invocations it just returns the original result
16:23:48 <benmachine> sensible
16:24:18 <kmc> i think you can implement this by creating an MVar to hold the result
16:25:12 <benmachine> mm
16:26:12 <benmachine> although you're not really using the full power of MVars, so a native implementation might be more efficient
16:26:17 <benmachine> *primitive implementation
16:26:31 <benmachine> *whatever, you know what I mean
16:26:35 <kmc> what aren't you using?
16:26:52 <danharaj> I wouldn't call that an embedding though. It's not a monomorphism is it? You're mapping an action to its idempotent.
16:27:08 <kmc> yeah, i didn't mean "embedding" in a mathematically precise way
16:27:32 <danharaj> Imprecise terminology? In my Haskell? ;)
16:27:34 <kmc> the problem with naive top-level IO is that you don't know when IO will occur
16:27:42 <benmachine> kmc: well, I'm just wondering if lots and lots of concurrent threads execute the IO action, are they going to form a kind of queue
16:27:43 <kmc> this makes it so you have to explicitly ask for it to occur
16:27:55 <kmc> but you still get to talk about a single global "instance" of that action
16:28:20 <benmachine> kmc: I was wondering if you could do it with just an IORef but I suspect that you wouldn't be able to easily guarantee the action only ran once
16:28:29 <kmc> a queue is what you want, right?
16:28:37 <benmachine> well, you don't need locking on reads
16:28:42 <benmachine> because the value is written at most once
16:28:55 <kmc> but they do have to block until it's ready
16:29:04 <benmachine> sure, but *after* that
16:29:12 <kmc> yeah
16:29:27 <kmc> a "write-once MVar" would be useful, in general... but I suppose that's a thunk itself, right? ;)
16:29:42 <shachaf> That's an IVar, isn't it?
16:29:47 <kmc> or is it unsafeInterleaveIO ;)
16:30:41 <benmachine> they don't want to do any more locking
16:30:41 <benmachine> @faq can haskell tell if I am lagging
16:30:41 <lambdabot> The answer is: Yes! Haskell can do that.
16:31:38 <benmachine> 00:56:03 < benmachine> @faq can haskell tell if I am lagging
16:31:40 <benmachine> 00:57:18 < lambdabot> The answer is: Yes! Haskell can do that.
16:31:45 <benmachine> (note timestamps)
16:31:48 * benmachine sighs theatrically
16:31:57 <kmc> haha
16:32:07 <kmc> @remember benmachine 00:56:03 < benmachine> @faq can haskell tell if I am lagging 00:57:18 < lambdabot> The answer is: Yes! Haskell can do that.
16:32:07 <lambdabot> Done.
16:32:32 <kmc> @forget benmachine 00:56:03 < benmachine> @faq can haskell tell if I am lagging 00:57:18 < lambdabot> The answer is: Yes! Haskell can do that.
16:32:32 <lambdabot> Done.
16:32:53 <kmc> @remember benmachine 00:56:03 <benmachine> @faq can haskell tell if I am lagging [...] 00:57:18 <lambdabot> The answer is: Yes! Haskell can do that.
16:32:54 <lambdabot> It is forever etched in my memory.
16:36:01 <dankna> cute hahaha
16:37:01 <byorgey> http://www.icfpcontest.org/
16:37:10 <byorgey> "Lambda: The Gathering"  hehehe
16:37:29 * hackagebot void 0.5.2 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.2 (EdwardKmett)
16:38:26 <dankna> wait wait
16:38:29 <dankna> that's this weekend?!
16:38:37 <dankna> who wants to do it with me hehe?
16:38:37 <kmc> it's *now*
16:40:13 <dankna> bah no takers?
16:40:41 <monochrom> @pl \f c ~(x:xs) -> c : f (c + x) xs
16:40:41 <lambdabot> (line 1, column 6):
16:40:41 <lambdabot> unexpected "~"
16:40:41 <lambdabot> expecting pattern or "->"
16:40:49 <monochrom> @pl \f c (x:xs) -> c : f (c + x) xs
16:40:49 <lambdabot> flip flip tail . (ap .) . flip flip head . ((.) .) . ap ((.) . (.) . (:)) . (. (+)) . (.)
16:40:57 <monochrom> nevermind :)
16:41:02 <dankna> heh
16:41:48 <parcs> @pl \(Just x) ->
16:41:48 <lambdabot> (line 1, column 8):
16:41:48 <lambdabot> unexpected "x"
16:41:48 <lambdabot> expecting operator or ")"
16:41:51 <parcs> @pl \(Just x) -> Just x
16:41:51 <lambdabot> (line 1, column 8):
16:41:51 <lambdabot> unexpected "x"
16:41:51 <lambdabot> expecting operator or ")"
16:42:11 <danharaj> heh
16:42:21 <danharaj> Why doesn't lambda the gathering have a Black Lotus?
16:42:45 <geheimdienst> @vixen Why doesn't lambda the gathering have a Black Lotus?
16:42:45 <lambdabot> who's to say?
16:42:55 <geheimdienst> @vixen danharaj's to say
16:42:55 <lambdabot> you know what? if we'd known it was going to be like this we'd have picked our own goddamn cotton!
16:43:54 <kmc> hahahaha
16:44:10 <kmc> the real question is why doesn't it have Blacker Lotus
16:54:36 <danharaj> I wish I could override the Eq Float instance with my own equality test.
16:54:36 <dankna> that's what newtype is for, yes?
16:54:36 <danharaj> True.
16:54:36 <danharaj> I suppose I should just do that.
16:54:41 <shachaf> Or *By functions.
16:55:48 <danharaj> shachaf: for the purposes of deriving
16:59:27 <danharaj> wait, if I newtype and make my own Eq instance, will I be able to derive Ord, Floating, Real, etc. instances?
16:59:27 <shachaf> Presumably Ord and Eq instances should match.
17:04:57 <Cale> danharaj: It's usually better to just explicitly test the distance between floating point values, rather than trying to override what equality means. The (==) on Float is bad enough :)
17:05:16 <hpc> or don't use floats ;)
17:05:32 <monochrom> > fix ((0:) . map succ)
17:05:33 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
17:05:38 <monochrom> \∩/
17:05:51 <danharaj> Cale: Yeah. I guess I should just add a typeclass for such tests, since I want to extend it to tuples of Floats etc.
17:07:45 <aavogt> shachaf: that doesn't seem to be enforced anywhere http://hpaste.org/47898
17:10:05 <aavogt> so that way you can replace what (==) means, but everything else can be exactly the same
17:11:53 <monochrom> http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm is a good article on floating point equality
17:11:59 <danharaj> oh sweet jesus christ finally
17:12:31 <danharaj> I can do line-line, line-ray, line-seg, ray-seg, ray-ray, and seg-seg intersection with no special cases.
17:13:00 <danharaj> The code is ugly as all fuck but no one is going to read it anyway.
17:13:27 <augur> dmwit: what are the plans for talks this year at hacphi?
17:13:48 <dankna> augur: are you coming?  cool
17:14:11 <dankna> we should have nametags with real names and irc nicks haha
17:14:15 <augur> dankna: yep i now know what hacphi is, and im in DC, so why not!
17:14:27 <augur> dankna: im going to ONLY have my irc nick
17:14:27 <dankna> awesome!  I'll be there as well, my father lives in the area so it's convenient for me
17:14:33 <dankna> augur: haha okay!
17:14:44 <augur> im an identity rebel
17:14:48 <dankna> noted
17:15:05 <augur> consider it my attempt to force people to rethink the notion of identity in a virtual setting
17:15:11 <dankna> duly noted
17:15:23 <augur> who is augur? is it the same person from sign on to sign on?
17:15:25 <augur> how do you know?
17:15:26 <monochrom> just use a uuid
17:15:29 <augur> how /could/ you know?
17:15:30 <danharaj> If I had the money, I would go with a nametag labelled with a hash of my genome.
17:15:49 <dankna> danharaj: so we couldn't tell you apart from your clones?
17:16:02 <danharaj> indeed.
17:16:06 <danharaj> We will all be attending.
17:16:06 <dankna> I usually /do/ know such things, because personalities differ too much
17:16:20 <augur> dankna: we could tell him apart by inspecting his proteome.
17:16:23 <dankna> hahaha yeah
17:16:36 <danharaj> Get your hands off of my proteome.
17:16:44 <lispy> heh
17:17:30 <augur> byorgey: what is diagrams?
17:17:52 <augur> oh i see, its a declarative graphics lib
17:18:20 <hpc> yeah, library for building images out of shapes, obviously optimised for diagram-ish type images
17:21:09 <augur> diagrams looks like something i wanted to work on last year
17:21:11 <augur> hm!
17:32:51 <kmc> my friend uses Python for scientific stuff (NumPy, SciPy, etc) and is evaluating Haskell as a possible alternative.  he's interested in matrix stuff, stats, and plotting
17:33:07 <hpc> kmc: hooray!
17:33:09 <kmc> i've pointed him at these packages: hmatrix, repa, repa-algorithms, statistics, hstatistics
17:33:16 <kmc> any good ones i'm missing?
17:33:26 <kmc> DPH would be great but last i heard it's Not There Yet
17:34:06 <aavogt> Chart is pretty if a bit more verbose than say matplotlib
17:35:31 <Eduard_Munteanu> There's a dying #haskell-math, that reminds me...
17:35:51 <kmc> we also have some half-baked scheme to interface to matplotlib by generating Python code
17:36:57 <Eduard_Munteanu> I wonder if there's a control theory package, like the Matlab/Octave stuff.
17:37:40 <Eduard_Munteanu> (Why the hell is this stuff so hard to find implemented? :/)
17:40:06 <Jonny3> are monads tricky to learn
17:40:24 <shachaf> @quote what's.the.problem
17:40:24 <lambdabot> wadler says: A monad is a monoid in the category of endofunctors, what's the problem?
17:40:29 <Eduard_Munteanu> (Well, I'm probably not fair, usually I'm looking for Matlab-compatible stuff)
17:40:45 <kmc> Jonny3, "monad" is just the name of a general API, shared by lots of unrelated types
17:40:56 <kmc> so it's mostly not about learning "monads" but about learning each type
17:41:10 <kmc> people often get trapped looking for some super general "monad insight" that isn't there
17:41:12 <Eduard_Munteanu> Interesting way to put it, yeah.
17:41:21 <Jonny3> ah I see, it's just in our advanced programming lectures, they often went off on tangents about monads
17:41:22 <kmc> people also have difficulty with IO and think they're having difficulty with monads
17:41:27 <Jonny3> which went way over my head
17:41:39 <kmc> but actually IO is an atypical monad, and the fact that it's a monad is mostly irrelevant to how you use it
17:41:50 <jrope> Hi, anyone here familiar with HDBC?
17:42:39 <Eduard_Munteanu> jrope: well you could drop a question and see if someone has an answer
17:43:39 <jrope> sure, I'm trying to use the fetchRow function but I don't see how to use it with a Statement created from the prepare function
17:44:19 <hpc> jrope: i can help
17:44:20 <kmc> is there any nice super general way to call Python libraries from Haskell?
17:44:31 <hpc> gimme a sec to open up some of my code
17:44:39 <jrope> cool, thanks
17:44:56 <kmc> I don't consider using the CPython C API directly to be "nice"
17:45:08 <Eduard_Munteanu> jrope: how so?
17:45:23 <Eduard_Munteanu> prepare :: conn -> String -> IO Statement
17:45:38 <Eduard_Munteanu> fetchRow :: Statement -> IO (Maybe [SqlValue])
17:45:47 <hpc> jrope: you have to execute the statement
17:45:47 <jrope> yeah
17:46:04 <jrope> but I need Statement -> [SqlValue] -> IO (Maybe [SqlValue])
17:46:15 <jrope> because my Statement has '?' placeholders in it
17:46:18 <hpc> so s <- prepare blah blah; execute s options; Just $ fetchRow s
17:46:25 <hpc> or whatever
17:46:49 <hpc> jrope: execute :: Statement -> [SqlValue] -> IO Integer
17:46:54 <jrope> ah, I see
17:46:56 <hpc> the return value is the number of rows
17:47:14 <hpc> don't forget to finish the statement when you are done
17:47:34 <hpc> also, might i suggest using fetchRowAL
17:47:54 <hpc> or one of the other ones that puts the row in a data structure
17:48:09 <jrope> I'm using fetchRowMap
17:49:13 <jrope> I don't get how execute changes the Statement that was bound in the call to prepare
17:49:45 <hpc> jrope: the statement is a pointery thing that you can only manipulate in IO
17:49:48 <hpc> jrope: it's like a file handle
17:50:23 <hpc> or better, it's like a connection inside a connection
17:50:32 <hpc> you connect to the SQL server with your connection
17:50:56 <hpc> then you open another "connection"
17:51:00 <hpc> then send the query over it
17:51:03 <hpc> and get the response back
17:51:16 <jrope> ah, okay that makes more sense
17:51:23 <JuanDaugherty> this is standard full rdbms ops jrope with statement preparation and execution, it's ages old
17:51:25 <jrope> I didn't get that from reading the docs
17:51:42 <hpc> just use this metaphore to get yourself to working code, and then forget it
17:51:48 <hpc> i am probably wrong in many crucial ways
17:51:50 <JuanDaugherty> you only need to prepare a statement once, you can then supply parameters and the ready access plan executes
17:52:03 <JuanDaugherty> (using the open cursor)
17:52:03 <hpc> like that
17:52:10 <dankna> what the statement actually is is an opaque object that encapsulates the database engine's compiled bytecode
17:52:19 <jrope> so I can call execute a bunch of times on the same statement with different parameters
17:52:24 <dankna> preparing it compiles the SQL query text into bytecode
17:52:51 <JuanDaugherty> i created a client server engine for DB/2 using this about 20 years ago
17:52:54 <dankna> binding parameters to it is like pre-substituting those parameters into the bytecode, a linking-like operation
17:53:11 <dankna> but thinking of it as a connection within the main connection is not hugely wrong either
17:53:16 <JuanDaugherty> it can have a dramatic effect on performance vs standard embedded SQL
17:53:25 <dankna> in common with a connection, it stays around until it's explicitly cleaned up
17:53:40 <dankna> JuanDaugherty, OH yes, it definitely affects performance
17:55:38 <jrope> cool, got it to build, thanks everyone!
17:55:49 <JuanDaugherty> not all RDBMS present the static interface although it's part of the original concept and in the beginning was dominant over embedded
17:56:48 <kmc> damn kids these days just glue together whatever strings get passed into their PHP app
17:57:06 <dankna> indeed, it really is annoying
17:57:17 <Cale> WHEEEEEEEE MAEK SQL QUERY
18:00:06 <parcs> interesting, i didn't know prepared statements persist for the duration of the connection..
18:01:23 <JuanDaugherty> they persist as long as the cursor is valid
18:01:50 <JuanDaugherty> which normally would be the same thing
18:04:05 <JuanDaugherty> essential a library like the one mentioned gives embedded apps static performance
18:04:12 <JuanDaugherty> *essentially
18:06:32 <JuanDaugherty> dunno if any COTS or other products have a feature like it built in this time, it sort of flies in face of some things to do it
18:08:03 <JuanDaugherty> *essentially
18:16:00 <dmwit> augur: We'll have a projector and a time slot to put all the talks in.
18:16:04 <dmwit> Other than that, no plans.
18:16:17 <augur> so no idea what the talks will be
18:16:18 <dmwit> augur: Also, join is in #haskell-hacphi in case you haven't yet!
18:16:19 <JuanDaugherty> parcs, a very long lived process generally will need to reprepare the statement regularly
18:16:33 <dmwit> augur: We've requested people put up a title/summary on the wiki.
18:16:53 <dmwit> But there may be people that won't decide until the very end whether they even want to talk or not. =P
18:17:47 <ddarius> @quote lax.functor
18:17:47 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
18:17:54 <parcs> JuanDaugherty: why is that?
18:19:36 <JuanDaugherty> parcs, because operations in the database can invalidate the access plan, even if the connection to the database if still good
18:19:46 <JuanDaugherty> *is still
18:37:55 <iker> Hola
19:07:10 <copumpkin> koninkje_away: you going to hac phi?
19:07:53 <cmccann> this was kinda fun: http://i.imgur.com/ppNTS.jpg
19:08:25 <copumpkin> cmccann: wassat?
19:08:43 <cmccann> copumpkin, the roots of a whole punch of polynomials, plotted on the complex plane
19:09:11 <ddarius> What's with people and plotting roots of polynomials?
19:09:50 <kmc> what's the best way to get Storable stuff out of a ByteString?
19:09:50 <cmccann> ddarius, blame John Baez, I think
19:10:06 <kmc> I know I can do it through ForeignPtr but has someone abstracted this yet?
19:10:10 <copumpkin> I blame his cousin, joan
19:10:47 <copumpkin> she was in a relationship with bob dylan
19:10:54 <copumpkin> nothing good ever comes of that
19:11:54 <cmccann> anyway, it's kind of interesting how a bunch of polynomials with coefficients taken from a very limited set of choices produce patterns when you plot the roots
19:12:54 <cmccann> but mostly I was just toying with generating images in Haskell and it was an easy source of "something to render"
19:32:57 <Cale> cmccann: I agree, I've done things like that before in Mathematica as well.
19:34:12 <lispy> Cale: have you seen this? http://www.khanacademy.org
19:34:45 <lispy> Cale: One of my first thoughts when I saw it was "Cale should have videos/exercises there for teaching Haskell"
19:34:56 <cmccann> Cale, I suspect I'd prefer doing this sort of thing in Haskell, heh
19:36:19 <Cale> lispy: I have seen it. It's a good idea.
19:36:33 <Cale> Have other people started making videos for it?
19:37:15 <parcs> nope, it's all khan at the moment
19:45:11 * JuanDaugherty thought at first it was like you know KHAN! academy
19:50:35 <Cale> Genghis Khan teaches how to use the decimal system to divide the Mongol soldiers into groups.
19:50:51 <Cale> http://en.wikipedia.org/wiki/Mongol_military_tactics_and_organization#Decimal_system
20:25:34 <JuanDaugherty> *CSPM-Interpreter
20:26:19 <JuanDaugherty> (the notation processor prolly doesn't map to anything in whosits cloud pkg)
20:30:57 <kaledd> :-D
20:33:47 <kaledd> hi
20:33:51 <kaledd> hgkjh
20:34:02 <kaledd> ihlllهمتنتهاعاعاعاعاع
20:37:26 <kaledd> :-(
20:37:55 <kaledd> تهع
20:38:25 <kaledd> افبقعغفغلاتلهغلهغلهغلغل
20:38:48 <JuanDaugherty> that's odd all I did was highlight the last part that was clearly in arabic and it (xchat) changed it into the prior string
20:39:39 <monochrom> partly because of right-to-left unicode text
20:39:42 <JuanDaugherty> but didn't happen with افبقعغفغلاتلهغلهغلهغلغ
20:39:52 <JuanDaugherty> ah
20:40:34 * JuanDaugherty decides not to mess with hebrew or arabic, chinese is enough
20:40:50 <liyang> masochist
20:41:12 <kaledd> اه
20:41:33 <JuanDaugherty> i suppose arabic would be easier
20:42:51 <JuanDaugherty> but you know I was JKnecht because of the Glasperlenspeil which ties in with the Hanzi, or rather the logographeme concept generally
20:46:08 <JuanDaugherty> *spiel
20:50:58 <shachaf> a = do { let b = do { c <- d; ...; e }; f <- foo b; ... } -- Is there a good way to "flatten" this sort of thing, assuming it's much longer and nests to several levels?
20:51:10 * shachaf realizes his question may be somewhat vague.
20:52:05 <dibblego> shachaf: monad transformer?
20:52:21 <monochrom> a = do { f <- foo $ do { ... }; ... }
20:52:22 <dibblego> or for arbitrary type constructors, applicative functor
20:52:44 <shachaf> monochrom: Right, but that still keeps nested levels of "do".
20:53:17 <monochrom> you can see an example of it in my http://www.vex.net/~trebla/haskell/gtk-interact.xhtml  look for "postGUIAsync $ do"
20:53:35 <monochrom> it cannot be flattened. it is that nested by nature
20:54:16 <monochrom> especially since it is "f <- foo b" not "f <- b"
20:54:34 <shachaf> If it had been f <- b then it would be easy to flatten. :-)
20:54:36 <monochrom> "f <- b" could have been inlined flatly easily
20:54:55 <monochrom> "f <- foo b" is genuinely nested
20:55:33 <shachaf> Right, but that can make for awkward, explicit code.
20:56:20 <monochrom> nothing awkward about it. "t <- forkIO $ do { ... }" happens all the time
20:56:44 <shachaf> Say that this was [] and foo was nub.
20:57:45 * shachaf is probably not providing enough context.
20:57:55 <monochrom> in fact it is a good thing it is nested and you must indent more. how else do I visualize where the foo part begins and ends?
20:58:59 <monochrom> you have an action of 5 lines to give to foo. you propose the whole thing to be flat. if it is flat, how do I eye-ball that you are only giving 5 lines not 10 lines to foo
20:59:54 <shachaf> If you take [] and nub, you can think of it as a "nub at this point" action, maybe.
21:02:00 <monochrom> same consideration. I want to eye-ball what exactly you're passing to nub. I want to see it's 5 lines of code not 10 lines or 20 lines
21:02:27 <monochrom> if you don't have nested indentation I can't see where it ends
21:05:14 <monochrom> perhaps you are just complaining that you have to enter "do" one more time
21:06:37 <monochrom> the alternative is going back to >>= and >>
21:07:44 <monochrom> if you use >>= for the whole thing, you won't have to worry "where must I add more 'do' and why should I", because there is no longer any "do", it's >>= all the way down
21:08:33 <monochrom> a = foo (d >>= \c -> ... e) >>= \f -> ...  no more nested "do"s
21:09:17 <monochrom> but of course clearly the (...) proves that there is still intrinsic nesting
21:24:50 <kaledd> :-(
21:25:25 <copumpkin> o.O
21:28:42 <Axman6> he was here for a whole minute, and NOONE helped him with his porblem! D:
21:29:40 <copumpkin> his problem was typing in arabic, from what I could tell
21:31:11 <Axman6> you've reminded me of a bash.org quote: >:), evil face or sad jew?
21:31:29 <Axman6> doesn't work very well with this font :(
21:31:43 <copumpkin> oh he's back
21:31:49 <copumpkin> kaledd: do you have a haskell question?
21:31:59 <byorgey> hahaha
21:31:59 <copumpkin> o.O
21:32:10 <luite> hehe
21:37:01 <kaledd> :-(
21:37:10 <kaledd> :)
21:37:17 <luite> hi kaledd
21:37:30 <kaledd> hi
21:38:47 <copumpkin> kaledd: are you learning haskell?
21:39:01 <luite> he only wants to talk to me ;p
21:39:05 * copumpkin gives up
21:39:50 <kaledd> :-(
21:40:00 <copumpkin> kaledd: what's wrong?
21:40:02 <luite> kaledd: are you having problems with your irc client?
21:40:08 --- mode: ChanServ set +o copumpkin
21:40:13 <luite> aw
21:41:29 <kaledd> هاي
21:42:36 <copumpkin> kaledd: no
21:42:40 <kaledd> ها
21:42:51 <kaledd> :-/
21:43:00 <copumpkin> stop it
21:43:19 <kaledd> هاي
21:43:43 <kaledd> هاي
21:43:54 <copumpkin> kaledd: نحن لا نتحدث العربية هنا
21:44:15 <kaledd> اين اجد غرف اللغة العربية
21:44:23 <copumpkin> oh it's persian
21:45:00 <copumpkin> kaledd: ما در اینجا فارسی صحبت نمی کنند
21:45:01 <luite> google translate thinks arabic
21:45:06 <copumpkin> I dunno
21:45:31 --- mode: copumpkin set +b *!*@77.30.8.28##haskell-ops
21:45:39 <copumpkin> is that how a redirect ban works?
21:45:43 <luite> "hi, where can I find arabic chatrooms" or something like that
21:45:57 --- mode: copumpkin set +b *!*@77.30.8.28$#haskell-ops
21:46:09 --- mode: copumpkin set -b *!*@77.30.8.28##haskell-ops
21:46:23 <luite> no idea, I've never banned anyone here ;p
21:46:48 <copumpkin> that worked
21:47:07 <luite> is he now in -ops?
21:47:11 <monochrom> yes
21:48:04 <JuanDaugherty> he might not be able to see/read latin
21:48:22 <copumpkin> ##arabic is tiny, but it's his best bet
21:48:32 --- mode: copumpkin set -b *!*@77.30.8.28$#haskell-ops
21:48:39 <luite> JuanDaugherty: he read my "hi" and said hi back
21:48:46 <JuanDaugherty> ah
21:49:08 <luite> but he might not understand much english
21:49:41 <JuanDaugherty> yeah was gonna say not positve definite zero but that's not saying much
21:50:25 <JuanDaugherty> hi and ok are pretty universal I think
21:50:54 <luite> yeah but at least it means that he's able to  see the text
21:51:31 <JuanDaugherty> but he was clearly having charset problems or so it appeared here in xchat
21:52:12 <luite> oh I could see the arabic text just fine here
21:52:40 <luite> although I have no idea whether it is in the correct right-to-left (?) order
21:55:03 <JuanDaugherty> he was Saudi, it's a very insular culture
21:56:06 <luite> they might have their own haskell user group that we've never heard about
21:56:35 <JuanDaugherty> and could be quite young, just learning that he will have to learn English
22:00:06 <kaledd> :-(
22:00:32 <kaledd> بلالاثفلافافافافافغاغفا
22:00:43 <kaledd> ‏‫(08:25:52 ص) موضوع #haskell هو: ["Paste code/errors: http://hpaste.org/new/haskell ", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin and spam issues: #haskell-ops"]
22:00:43 <kaledd> (08:26:06 ص) kaledd: :-(
22:00:43 <kaledd> (08:26:26 ص) ArnoVanLumig [~arno@ip51cde5d4.adsl-surfen.hetnet.nl] دخل الغرفة.
22:00:43 <kaledd> (08:26:26 ص) ArnoVanLumig ترك الغرفة.
22:00:43 <kaledd> (08:26:26 ص) scm [~svencm@e176109031.adsl.alicedsl.de] دخل الغرفة.
22:00:44 <kaledd> (08:26:27 ص) povik ترك الغرفة (quit: Ping timeout: 252 seconds).
22:00:44 <kaledd> ‏‫(08:26:43 ص)‬‎‬ ‪kaledd‬‏‬: ‫بلالاثفلافافافافافغاغفا
22:00:57 <pikhq> Man, my terminal doesn't do LTR text right.
22:01:26 <shachaf> pikhq: Was that an RTL "RTL" that my terminal did LTR?
22:01:50 <pikhq> shachaf: No, that was a thinko.
22:02:07 <pikhq> Very unfortunate one, considering the subject at hand.
22:04:01 <copumpkin> kaledd: هذا ليس المكان المناسب لنسأل عن غرف الدردشة العربية. نحن لا نعرف من اين يمكن العثور عليها
22:07:28 <koninkje> copumpkin: Not likely (me going to hac phi)
22:07:37 <copumpkin> aw
22:07:57 <shachaf> copumpkin: Not likely (that messages getting to kaledd).
22:08:02 <shachaf> (Since he's not in here.)
22:08:24 <koninkje> copumpkin: I'll be coming back from Canada then; I suppose I could try re-routing through Phi, but...
22:08:37 <kmc> "هاسكل هي لغة برمجة مطابقة للمعايير، للأغراض العامة، وهي لغة وظيفية إلى حد كبير، دون دلالات ألفاظ ملزمة وبكتابة ثابتة وقوية. وقد سُميت بـ هاسكل علي اسم عالم المنطق " هاسكل كوري ". وفي اللغة هاسكل، "تمثل الوظيفة مواطن من الدرجة الأولى" من لغة البر
22:08:38 <kmc> مجة."
22:08:53 <kmc> from ar.wikipedia.org
22:09:02 <kmc> Google Translate says: 'Haskell has been named by the name of the logician "Haskell Korean."'
22:09:07 <kmc> that's.... mostly correct
22:09:24 <byorgey>        Haskell, "is a function of the first-class citizen" of the language of righteousness
22:09:34 <byorgey> "the language of righteousness", I like it =)
22:10:07 <JuanDaugherty> yeah Google translations are a hoot
22:10:25 <JuanDaugherty> especially chinese-english
22:10:48 <byorgey> oh, it's because I didn't copy the last few characters
22:11:15 <byorgey> now it says "programming language" instead of "language of righteousness"
22:11:29 <shachaf> :-(
22:11:34 <byorgey> but clearly those characters ought to just be dropped
22:14:03 <fragamus> hey guys, can I have a monadic function that has state at the bottom of the monad transformer stack, and which is polymorphic with respect to the schema of the state?
22:14:53 <byorgey> "polymorphic with respect to the schema of the state"?
22:15:09 <JuanDaugherty> meant in chrome, check out "jesus" in the mandarin wiki, section "born man"
22:15:52 <fragamus> structure of the state
22:20:16 <byorgey> fragamus: I still don't really understand the question.  Can you give an example of what you are trying to do?
22:20:57 <fragamus> well
22:22:49 <hpaste> fragamus pasted “This function sucks” at http://hpaste.org/47902
22:23:03 <fragamus> yep.  That was me ^^^
22:24:02 <fragamus> you see how it doesn't manipulate the state
22:24:30 <fragamus> but i need to call it from the monad that is declared there
22:26:02 <byorgey> hmm, hpaste.org is being really slow for me, I haven't been able to load it yet
22:26:11 <byorgey> oh, there we go
22:26:54 <byorgey> fragamus: so what happens if you replace ([Int], [Int], [Int]) with s ?
22:27:15 <fragamus> yeah
22:27:17 <byorgey> in fact it doesn't matter that it's a state monad at all
22:27:26 <fragamus> yeah
22:27:54 <fragamus> so can I replace the whole schmegegge with Monad m
22:28:23 <byorgey> you should just write  snag_normal :: (MonadRandom m) => m Float
22:28:45 <fragamus> ok
22:28:51 <fragamus> thanks doctor
22:28:56 <byorgey> sure =)
22:29:35 <byorgey> fragamus: in general, one approach to this sort of thing is to just remove the type signature completely, then load it in ghci and ask it what type it has inferred
22:29:41 <byorgey> it will tell you the most general type
22:30:12 <fragamus> yeah
22:30:46 <fragamus> snag_normal :: (MonadRandom m) => m Float
22:30:53 <fragamus> that works ^^^
22:31:10 <fragamus> but if i delete the type sig it does not compile
22:31:47 <byorgey> interesting
22:31:50 <byorgey> what is the error?
22:32:15 <byorgey> oh, it's probably because of the monomorphism restriction
22:32:32 <augur> anyone know about general relativity? :x
22:32:41 <byorgey> it should work if you turn that off, by putting {-# LANGUAGE NoMonomorphismRestriction #-} at the top of your .hs file
22:32:57 <augur> whats a monomorphism restriction
22:33:19 <kaledd> ل
22:33:21 <byorgey> http://haskell.org/haskellwiki/Monomorphism_restriction
22:33:36 <fragamus> Main.hs:71:1:
22:33:37 <fragamus>     Couldn't match type `m0' with `RandT g (State ([Int], [Int]))'
22:33:37 <fragamus>       because type variable `g' would escape its scope
22:34:15 <kaledd> ب
22:35:24 <augur> byorgey: oh i see
22:35:33 <augur> i mean i dont
22:35:35 <augur> but i see
22:36:09 <byorgey> if you write something of the form  x = blah blah blah, you would usually expect it to be evaluated only once
22:36:17 <byorgey> since it is "obviously" not a function
22:36:50 <byorgey> however, if it has a type class polymorphic type like   Num a => ... a ..., it is essentially a function which takes a dictionary of Num methods
22:36:56 <byorgey> so it will be recomputed every time it is used
22:37:04 <augur> i dont understand how f = \x -> x is subject to possible sharing that f x = x isnt
22:37:42 <byorgey> no, their behavior is exactly the same.  the monomorphism restriction is just intended to lessen programmer surprise
22:38:07 <byorgey> since people will not be surprised that f x = ... is not shared, but they might be surprised that something of the form  f = ... is not
22:38:17 <augur> the page says tho that there is the potential for shared computation
22:38:28 <byorgey> I am just explaining the reasoning behind it.  personally I think it is dumb.
22:38:30 <augur> i mean
22:38:38 <augur> i dont get the idea of shared anything to begin with
22:38:46 <augur> what is that supposed to mean
22:38:52 <byorgey> if I write  x = 2 + 3 + 5
22:39:06 <byorgey> and then use x in seven places in my code, it will only be computed once
22:39:16 <byorgey> so the computation 2 + 3 + 5 will be shared among those seven locations
22:39:21 <augur> i see
22:39:34 <augur> and what is a case where this distinction actually matters with functions?
22:39:37 <byorgey> but actually, x = 2 + 3 + 5 is a bad example, because that has the type  Num a => a
22:40:08 <augur> i mean, functions arent supercompiled are they, so how does f = \x -> x introduce computation that f x = x doesnt
22:40:13 <augur> or why would anyone think it does
22:40:13 <byorgey> augur: with functions the distinction does not matter.
22:40:33 <byorgey> it's just that the monomorphism restriction applies to anything which is syntactically of the form  x = ...
22:40:41 <augur> oh i see
22:40:42 <byorgey> no matter whether it is a function or not.
22:41:01 <dmwit> (f x = let c = e in \y -> e') may be more efficient than (f x y = let c = e in e').
22:41:30 <augur> that makes sense
22:42:02 <dmwit> More relevantly, (f = let c = e in \x -> e') may be more efficient than (f x = let c = e in e').
22:42:41 <augur> aha right i see
22:43:15 <augur> because simple defines will evaluate the body the first time its accessed, which computes e once
22:43:24 <dmwit> Yes.
22:43:34 <augur> whereas the other wraps it all up in a lambda which re-evaluates e each time
22:43:43 <augur> supercompilate!
22:43:52 <augur> .. supercompulation*
22:43:53 <dmwit> =)
22:43:58 <augur> what a weird type
22:44:02 <augur> my brain does weird things
22:44:06 <augur> i truncate words, often
22:44:15 <augur> but morphophonologically
22:44:24 <augur> and end up typing other "words"
22:50:12 <fragamus> um, byorgey, I did what you said, I turned of Monomorphism restriction, and i loaded my code in ghci, and it says my function is not in scope
22:51:19 <augur> ?keal
22:51:19 <lambdabot> where can i find opensource schematics of Linus Torvalds' x86 clone?
22:51:24 <augur> ?keal
22:51:25 <lambdabot> all i know is i have experienced my own death unhappening...
22:51:29 <augur> ?keal
22:51:29 <lambdabot> just seeing how offtopic i could get everyone
22:51:33 <augur> ?keal
22:51:33 <lambdabot> know you know this 24 periods Keal SecretTM
22:51:37 <augur> ?keal
22:51:37 <lambdabot> one prollem. T broke confines of the visual basic langage and would not compile
22:51:45 <augur> ?keal
22:51:45 <lambdabot> can you make a macro that builds the expression accoridng to a genetic algorithm where you decide what is good and what is bad?
22:51:54 <augur> ?keal
22:51:54 <lambdabot> how do i search for someone saying 'Keal' in mirc
22:51:57 <byorgey> ok, ok =)
22:51:58 <augur> ?keal
22:51:58 <lambdabot> what are epsilons?
22:52:08 <augur> im failing to see a problem with his sentences
22:52:55 <byorgey> fragamus: are you sure it loaded correctly?  are you sure you spelled it right? etc.
22:53:07 <byorgey> the MR should have nothing to do with what is in scope
22:53:11 <augur> fragglepus
22:58:33 <fragamus> byorgey: yeah buddy i took out the pragma and now i can get types again
22:59:06 <fragamus> but unfortunately i had to use an explicit type for snag_normal so it would compile
22:59:16 <fragamus> so its heisenfucked
23:08:08 <fragamus> byorgey: I really like the new type signature
23:08:31 <fragamus> byorgey: it is just perfect
23:08:51 <fragamus> and way hipster polymorphic
23:12:21 <luite> zygohipstermorphic
23:16:20 <fragamus> fragomorphic
23:20:24 <fragamus> do you guys typically use -XFlexibleContexts?
23:22:50 <mm_freak> fragamus: seldomly
23:23:03 <mm_freak> but i think that really depends on who you are
23:23:36 <mm_freak> if you like type families like i do, you don't need that extension very often
23:25:09 <fragamus> a family man
23:25:34 <fragamus> Well I like em flexible
23:25:56 <fragamus> That's who I am^^^
23:31:09 <tang> I cannot get bamse package installed on my machine, anybody can help?
23:35:29 * JuanDaugherty can't I use NSIS for that
23:50:56 <mbuf> is there an e-mail client written in Haskell?
23:52:00 <shachaf> I understand that darcs sends emails. :-)
23:56:48 <magicman> @hoogle Monad m => Maybe a -> a -> m b -> Maybe b
23:56:49 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
23:56:49 <lambdabot> Control.Monad liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
23:56:49 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
23:56:56 <magicman> Erp.
23:57:01 <magicman> @hoogle Monad m => Maybe a -> (a -> m b) -> Maybe b
23:57:01 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
23:57:01 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
23:57:01 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
23:57:25 <magicman> Erp Erp. I am obviously not awake.
23:57:31 <magicman> @hoogle Monad m => Maybe a -> (a -> m b) -> m (Maybe b)
23:57:31 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
23:57:31 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
23:57:32 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
