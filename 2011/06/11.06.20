00:23:20 * hackagebot generic-deriving 1.0.1 - Generic programming library for generalized deriving.  http://hackage.haskell.org/package/generic-deriving-1.0.1 (JosePedroMagalhaes)
01:21:19 <trygvis> will osx 10.5 be supported for the latest haskell platform releases?
01:27:29 <erus`> i have a nested list
01:27:39 <erus`> how can i get the index of an item?
01:27:52 <shachaf> @brain
01:27:52 <lambdabot> I think so, Brain, but I don't think Kaye Ballard's in the union.
01:28:15 <shachaf> Shouldn't that be @pinky?
01:28:16 <shachaf> @brain
01:28:16 <lambdabot> Wuh, I think so, Brain, but isn't Regis Philbin already married?
01:28:29 <jlaire> > findIndex (== 42) [0,1,2,5,42,100]
01:28:29 <lambdabot>   Just 4
01:32:54 <jlaire> > let f x = msum . zipWith (\i -> fmap ((,) i) . findIndex x) [0..] in f (== 1) [[0,0,0],[2,2,2],[100,1,5,10]]
01:32:55 <lambdabot>   Just (2,1)
01:44:52 <erus`> jlaire: i only need the first index, if that makes the code any shorter...
01:47:34 <jlaire> > let f x = findIndex (x `elem`) in f 1 [[0,0,0],[2,2,2],[100,1,5,10]]
01:47:35 <lambdabot>   Just 2
01:47:40 <jlaire> erus`: ^^
01:51:10 <jlaire> > let f x = msum . map (findIndex (x ==)) in f 1 [[0,0,0],[2,2,2],[100,1,5,10]]
01:51:12 <lambdabot>   Just 1
01:56:21 <chrisdone> Has anyone done PDF editing in Haskell?
01:56:21 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
02:07:23 <sohum> is there a cabal clean command, to wipe almost everything in your cabal directory and start over?
02:07:43 <sohum> uh. not the actual cabal clean command
02:08:24 <Starfire> rm -rf ~/.cabal perhaps?
02:08:38 <Starfire> At least that's what I've been using.
02:09:08 <sohum> I'm a bit wary about doing that, ubt if you say it works...
02:09:34 <shachaf> Well, it'll delete everything.
02:09:39 <shachaf> Which is a superset of almost everything.
02:09:52 <Starfire> And there might be some issues about packages remaining in the ghc cache.
02:10:06 <sohum> mm. you'd have to add rm -dfR ~/.ghc
02:10:24 <shachaf> rm -rf ~ would take care of both of those. :-)
02:10:31 <sohum> hush you :p
02:11:20 <sohum> basically, I tend to keep my /home through installs and I think it may be time to start giving the debian recommended way of installing haskell libs a try. and thus I should probably clean my cabal cruft.
02:11:37 <shachaf> What's the Debian-recommended way?
02:11:49 <shachaf> If it's anything like it is for Ruby, probably not. :-)
02:11:51 <sohum> they're trying to package *everything*, as far as I can tell
02:12:02 <shachaf> Eh. They don't even package GHC 7.
02:12:06 <shachaf> (Do they?)
02:12:08 <Starfire> I don't know about debian proper, but at least on Ubuntu, the packages are old.
02:12:14 <sohum> they totally do
02:12:32 <sohum> debian testing is on 7.0.3-1
02:13:01 <sohum> (no one runs debian stable for up to date packages, so don't even mention that :p)
02:15:19 <sohum> (they even renamed the package from ghc6 to ghc :p)
02:15:55 <erus`> stupid linux drivers
02:17:08 <mjo> Is there anything in Debian which takes a cabal package and turns it into a .deb ? There's something like that for Perl (dh_make_perl IIRC)
02:17:16 <sohum> I believe there is
02:22:01 <earthy> there is, indeed. cabal-debian
02:22:50 <mjo> So that's presumable the quasi-painless way to do it
02:53:25 <erus`> how do i get the Float result from dividing 2 ints
02:54:42 <lcf> by making both floats first?
02:54:59 <mjo> Do you want to do integer division then convert to a float, or convert them to floats then do the division ?
02:56:12 <mjo> Either way, fromIntegral is presumably what you want
02:59:34 <erus`> https://github.com/tm1rbrt/haskell/blob/master/poker/poker.hs <- if anyone has any easy optimization ideas i would be very grateful
03:00:41 <benmachine> erus`: have you tried profiling
03:01:20 <erus`> is there a tutorial for that with ghc 7
03:01:31 <erus`> i tried one that didnt create a .prof file
03:02:25 <benmachine> the main thing to do is ghc -prof -auto-all
03:02:34 <benmachine> oh wait you need the rts options
03:03:08 <benmachine> erus`: try this http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
03:04:16 <benmachine> erus`: compile with -rtsopts and then run with +RTS -p
03:07:07 <erus`> ok
03:09:55 <benmachine> erus`: with -rtsopts as well as -prof -auto-all I mean
03:11:36 <erus`> yeah i had to add -prof
03:11:47 <erus`> whats the -auto-all ?
03:16:34 <erus`> benmachine: ok i have my bottlenecks... now what?
03:18:10 <zygoloid> erus`: look at them, decide if they're reasonable, think about how to remove them / speed them up
03:18:48 <benmachine> erus`: -auto-all places cost centres on a bunch of stuff automatically
03:19:16 <erus`> I havnt the first clue about optimal haskell code :(
03:20:39 <hpaste> fxr annotated “huge memory usage” with “huge memory usage (annotation)” at http://hpaste.org/48005#a48013
03:22:27 <zygoloid> erus`: you can canonicalize the card selection process more.
03:23:18 <erus`> sortedHands?
03:23:54 <zygoloid> yeah.
03:24:09 <zygoloid> currently you analyze each hand for each combination of suits
03:24:19 <zygoloid> all you actually care about is which suits within the hand are equal
03:24:45 <erus`> ah yes
03:25:22 <zygoloid> you could generate something like [(Hand, Int)] where the Int is the number of ways the hand can come up with different suits
03:26:13 <Peaker> @type \f xs -> zipWith fromMaybe xs (map f xs)
03:26:14 <lambdabot> forall a. (a -> Maybe a) -> [a] -> [a]
03:27:04 <benmachine> Peaker: isn't that just map (\x -> fromMaybe x (f x)) xs?
03:27:05 <Axman6> :t fromMaybe
03:27:06 <lambdabot> forall a. a -> Maybe a -> a
03:27:14 <benmachine> i.e. map (fromMaybe <*> f) xs
03:27:14 <Axman6> oh right
03:27:40 <Peaker> benmachine: yeah.. I was just wondering about ezyang's maximizing sharing blog.. but this is not close at all to what he does there, on second thought
03:27:50 <zygoloid> @type map (ap (flip maybe id))
03:27:51 <lambdabot> forall a. [a -> Maybe a] -> [a -> a]
03:28:03 <zygoloid> @type map . ap (flip maybe id)
03:28:04 <lambdabot> forall a. (a -> Maybe a) -> [a] -> [a]
03:28:58 <Peaker> Nothing represents "no-change", so you want to lift:  (a -> Maybe a) to [a] -> Maybe [a] with maximal sharing
03:29:07 <Peaker> (and Nothing if the list should be fully shared)
03:29:25 <benmachine> ah
03:29:40 <zygoloid> Peaker: maximum sharing here requires minimum laziness :(
03:29:54 <benmachine> can't you just return the original list in the fully-shared case?
03:30:04 <zygoloid> (you need to scan to the end of the input list to determine if you can share the first cons in the output)
03:30:28 <Peaker> zygoloid: well, doesn't laziness at most add a constant overhead to the best case here?  The decision of whether it is even Just or Nothing requires going over the entire list
03:31:39 <isomorphic> is there a word for a map followed by a fold?
03:32:00 <zygoloid> Peaker: i thought you wanted (a -> Maybe a) -> [a] -> [a]
03:32:11 <benmachine> isomorphic: what kind of word?
03:32:26 <isomorphic> perhaps it would be foldMap?
03:32:29 <benmachine> yeah
03:32:35 <isomorphic> a function, that takes a bunch of parameters
03:32:44 <isomorphic> if that makes sense
03:32:49 <isomorphic> like concatMap I guess
03:32:51 <benmachine> notice though that since map can be defined in terms of fold you can fuse a foldr . map into just a foldr :)
03:33:22 <isomorphic> oh, good point
03:33:24 <isomorphic> :P
03:33:26 <isomorphic> thanks
03:33:32 <benmachine> well, that isn't exactly because map can be defined in terms of foldr
03:33:34 <benmachine> but it's true anyway
03:34:20 <isomorphic> i get the idea :P - yeah, it had that feel about it ... like there'd be something like that
03:34:58 <benmachine> foldMap still exists, but I think it's more of a convenience than anything else
03:47:10 <Peaker> zygoloid: yeah, that was wrong, as I said later :)
03:52:32 * hackagebot HarmTrace 0.3 - HarmTrace: Harmony Analysis and Retrieval of Music  http://hackage.haskell.org/package/HarmTrace-0.3 (JosePedroMagalhaes)
03:56:11 <Peaker> trace the harm!
03:58:27 <HugoDaniel> hi
03:58:40 <HugoDaniel> how do i add constraints to my haskell data type ?
03:59:16 <HugoDaniel> say, i have a data type like this: data MyData = MD { name :: Data.Text }
03:59:39 <HugoDaniel> but i want name to be constrained to a length of 1000
04:00:08 <luite> unpossible!
04:00:15 <luite> well
04:00:23 <HugoDaniel> cant i do it with gadts ?
04:00:26 <luite> HugoDaniel: you could hide the MD constructor
04:00:42 <HugoDaniel> yeah, and only expose functions :/
04:00:47 <parcs> (Char, Char, Char, Char, ..., Char)
04:00:51 <HugoDaniel> ahah
04:00:52 <HugoDaniel> :D
04:01:01 <HugoDaniel> parcs: ghc has a hard limit in tuples
04:01:01 <luite> or use a different type that wraps Data.Text
04:01:09 <parcs> HugoDaniel: what is it?
04:01:16 <flux> hugodaniel, (Char, Char, Char, Char, (Char, Char, Char, Char.. ) etc?
04:02:02 <HugoDaniel> hmm
04:02:20 <praveen> hello haskell community!
04:02:26 <parcs> HugoDaniel: make a newtype of Text and replace its constructor with a constructor that ensures that the length of the text is 1000
04:02:34 <roconnor> @tell copumpkin another boring task to be done is to make a  ripemd160-bytestring module similar to the sha256-bytestring module.
04:02:34 <lambdabot> Consider it noted.
04:02:43 <HugoDaniel> :)
04:02:46 <HugoDaniel> cool
04:02:47 <jlaire> you can do it with 2-tuples, (Char, (Char, (Char, ... )))
04:03:04 <HugoDaniel> thanks parcs
04:03:35 <HugoDaniel> there is another kind of constraint that im interested in
04:04:01 <luite> parcs: hmm, it should be possible to reify the max length
04:04:02 <roconnor> @tell copumpkin I also would like a ripemd160-hash to ascii mailbox name encoder/decoder.
04:04:02 <lambdabot> Consider it noted.
04:04:22 <HugoDaniel> hmm
04:04:31 <parcs> luite: maybe, but i'm not keen on how to sanely do it
04:04:58 <luite> i didn't claim anything about sanely ;p
04:05:26 <flux> @faq Can Haskell do statically constrained data structures in a sane fashion?
04:05:26 <lambdabot> The answer is: Yes! Haskell can do that.
04:05:59 <flux> maybe agda.. ?
04:07:58 <osfameron> statically constrained?
04:12:23 <flux> say you have a constraint on an integer that it must be between 1 and 10 and your program won't compile if you attempt to break that constraint.
04:13:38 <osfameron> ah cool.  I sometimes want that
04:14:35 <osfameron> Perl's Moose has it for object attributes: subtype Int1To10 as Int, where { $_ >= 1 && $_ <= 10 };
04:14:44 <osfameron> but of course those are checked dynamically
04:15:19 <osfameron> how do you do it in Haskell?
04:15:31 <pamiz> what happens if the integer value is read at runtime?
04:16:32 <flux> pamiz, you would need to put in explicit code to check for the fact. for example: assert (i >= 1 && i <= 10);
04:17:38 <pamiz> but how can you decide whether the condition holds or not, if you dont know i at compile time?
04:19:53 <ben> you check at runtime
04:21:06 <pamiz> flux said that it should not compile if the constraint is violated. that is why im confused
04:21:30 <flux> pamiz, there are obviously cases where the compiler can only say 'it may be violated here or not, I refuse to compile'
04:21:58 <flux> pamiz, and then you will guarantee compiler that if you have a String, you will get a Int(1..10) out, because if it's not 1..10, your assertion will stop the evaluation of the function right there
04:22:04 <flux> so the value will never end up into a Int(1..10)
04:22:17 <flux> basically you've managed to move the source of the erronous value to its source
04:22:35 <flux> well, that atleast would be an idea, I've never actually used a language that really allwoed that ;-).
04:23:18 <flux> hmm, make is "move the source" -> "move the point of error"
04:23:35 <jlaire> n <- getInt; let valid = if 1<=n && n<=10 then Just n else Nothing :: Maybe Int1To10
04:23:59 <jlaire> a sufficiently smart compiler (tm) would accept that
04:24:12 <flux> actually I think ATS has something like that, doesn't it?
04:24:32 <jlaire> yeah
04:24:37 <Twey> It's called dependent typing
04:24:47 <Twey> ATS, Coq, Agda, &c.
04:25:30 <sohum> right
04:26:11 <sohum> so does the vector package have any serious incompatibilities between 0.5.* and 0.7.0.1?
04:26:18 <sohum> and/or where could I find that out for myself?
04:29:24 <sohum> flux: I *believe* (and I'm very likely to be wrong) that with some unrecommended ghc extensions and a bunch of type level hackery you can approximate dependent typing in haskell
04:32:06 <sohum> flux: (iirc) you get some ridiculous inefficiencies, though, so it's not actually useful
04:33:24 <sohum> the answer to my vector question, btw, seems to be nontrivially yes, and I learned that by just trying to compile a package which depends on vector-0.5 on vector-0.7
04:47:04 <isomorphic> Can anybody suggest a better alternative than a list comprehension for comparing every pair in a list, ie: [ myFunction a b | a <- z, b <- z, a /= b] ?
04:47:24 <sohum> @pl \i j -> f k (f k o i) j
04:47:24 <lambdabot> f k . f k o
04:52:51 <xkb> isomorphic: cant u use zip or something like it?
04:53:01 <identity_> isomorphic: I seem to recall that there was some.. liftM magic or something using replicateM
04:53:06 <identity_> I just don't remember it
04:53:31 <aavogt> @ty \f z z -> liftM2 (\x y -> guard (x/=y) >> f x y) z z
04:53:32 <lambdabot>     Conflicting definitions for `z'
04:53:32 <lambdabot>     Bound at: <interactive>:1:3
04:53:32 <lambdabot>               <interactive>:1:5
04:53:39 <aavogt> @ty \f z -> liftM2 (\x y -> guard (x/=y) >> f x y) z z
04:53:40 <lambdabot> forall a2 (m :: * -> *) b (m1 :: * -> *). (Eq a2, MonadPlus m, Monad m1) => (a2 -> a2 -> m b) -> m1 a2 -> m1 (m b)
04:54:01 <identity_> What I'm thinking of was definitely replicateM
04:54:02 <identity_> iirc
04:54:37 <aavogt> @ty \f z -> do z1 <- z; z2 <- z; guard (z1/=z2); f z1 z2
04:54:37 <lambdabot> forall (m :: * -> *) t b. (MonadPlus m, Eq t) => (t -> t -> m b) -> m t -> m b
04:54:48 <isomorphic> oh - yeah, I think i know what you mean
04:55:14 <pamiz> :r
04:55:15 <isomorphic> identity_: like as in, interpreting a list as a monad that handles indeterminate calculations?
04:55:29 <jlaire> > liftM2 (,) [1,2,3] "abcd"
04:55:30 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(1,'d'),(2,'a'),(2,'b'),(2,'c'),(2,'d'),(3,'a'),(3...
04:55:58 <jlaire> > (,,) <$> [1,2,3] <*> "abcd" <*> "ABCD"
04:55:59 <lambdabot>   [(1,'a','A'),(1,'a','B'),(1,'a','C'),(1,'a','D'),(1,'b','A'),(1,'b','B'),(1...
04:56:22 <identity_> isomorphic: something like that yeah
04:56:38 <identity_> I'll have to admit that I don't quite grok list-as-a-monad as well as I should :(
04:56:55 <jlaire> > do { a <- [1,2,3]; b <- "abc"; return (a,b) }
04:56:56 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
04:57:02 <aavogt> > replicateM 2 [a,b,c] -- or this?
04:57:03 <lambdabot>   [[a,a],[a,b],[a,c],[b,a],[b,b],[b,c],[c,a],[c,b],[c,c]]
04:57:11 <identity_> aavogt: probably that, yeah
04:57:31 * aavogt doesn't trust using that version, since it's easy to get the 2 wrong
04:57:43 <isomorphic> aavogt: that's close - is there a way to put a guard to prevent the [a, a] pair?
04:57:50 <aavogt> so it's hard to trust that the lists are all length 2
04:58:04 <aavogt> > a == a
04:58:05 <lambdabot>   True
04:58:10 <identity_> I like jlaire's version
04:58:11 <aavogt> > a /= a
04:58:11 <lambdabot>   False
04:58:13 <identity_> isn't that what you need?
04:58:21 <identity_> pairs et al
04:58:21 <jlaire> > sequence [[1,2,3],[10,20,10],[100,200,300]]
04:58:22 <lambdabot>   [[1,10,100],[1,10,200],[1,10,300],[1,20,100],[1,20,200],[1,20,300],[1,10,10...
04:58:22 <identity_> no lists
04:58:36 <isomorphic> close - i'm actually after the version that does (n-1)n/2 comparisions
04:58:54 <aavogt> > replicateM 2 [a,b,c] >>= \(x,y) -> guard (x/=y) >> return (x,y)
04:58:55 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr]'
04:58:55 <lambdabot>         against inferre...
04:59:10 <jlaire> isomorphic: can there be duplicate elements
04:59:14 <jlaire> i.e., is using == fine
04:59:15 <aavogt> > replicateM 2 [a,b,c] >>= \[x,y] -> guard (x/=y) >> return (x,y)
04:59:16 <lambdabot>   [(a,b),(a,c),(b,a),(b,c),(c,a),(c,b)]
04:59:48 <jlaire> (and is the Eq constraint ok to have)
04:59:49 <isomorphic> jlaire: equals is fine - i've made the underlying data structure an Eq instance
04:59:53 <jlaire> ok
05:00:15 <isomorphic> aavogt: that looks perfect
05:00:40 <identity_> does it really do the amount of comparisons you need?
05:00:42 <aavogt> it's the same as the list comprehension
05:00:44 <isomorphic> is there a one-liner way to test which is more efficent?
05:01:01 <jlaire> > filter (uncurry (/=)) $ replicateM 2 [a,b,c]
05:01:01 <isomorphic> identity_: It looks to - it's that old handshaking problem
05:01:02 <lambdabot>   Couldn't match expected type `(a, a)'
05:01:02 <lambdabot>         against inferred type `[Simpl...
05:01:19 <jlaire> > filter (\[x,y] -> x /= y) $ replicateM 2 [a,b,c]
05:01:20 <lambdabot>   [[a,b],[a,c],[b,a],[b,c],[c,a],[c,b]]
05:01:24 <identity_> I'm so bad at determining the big-O of haskell stuff by looking at it tbh
05:01:34 <identity_> I would probably resort to using Debug.Trace or something
05:01:40 * hackagebot hack2-handler-warp 2011.6.20 - Hack2 warp handler  http://hackage.haskell.org/package/hack2-handler-warp-2011.6.20 (JinjingWang)
05:02:10 <jlaire> you know which indices the duplicates are at, so you could filter them without any == comparisons
05:02:35 <jlaire> if you know the length of the list
05:02:52 <aavogt> > let one (x:xs) = (x,xs) : map (fmap (x:)) (one xs); one [] = [[]] in one [a,b,c]
05:02:52 <lambdabot>   Couldn't match expected type `(t, [t])' against inferred type `[a]'
05:03:12 <aavogt> > let one (x:xs) = (x,xs) : map (fmap (x:)) (one xs); one [] = [] in one [a,b,c]
05:03:13 <lambdabot>   [(a,[b,c]),(b,[a,c]),(c,[a,b])]
05:03:40 <isomorphic> @type replicateM
05:03:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
05:04:20 <aavogt> > let one (x:xs) = (x,xs) : map (fmap (x:)) (one xs); one [] = [] in let z = [a,b,c] in  [ (a,b) | (a,z1) <- one z, (b,_) <- one z1 ]
05:04:21 <lambdabot>   [(a,b),(a,c),(b,a),(b,c),(c,a),(c,b)]
05:04:40 <aavogt> still a one-liner?
05:04:42 <jlaire> > let rmdups _ _ [] = []; rmdups n 0 (_:xs) = rmdups n n xs; rmdups n i (x:xs) = x : rmdups n (i-1) xs in rmdups 4 $ replicateM 2 [a,b,c,d]
05:04:43 <lambdabot>   No instance for (GHC.Num.Num [[SimpleReflect.Expr]])
05:04:43 <lambdabot>    arising from a use ...
05:04:50 <jlaire> > let rmdups _ _ [] = []; rmdups n 0 (_:xs) = rmdups n n xs; rmdups n i (x:xs) = x : rmdups n (i-1) xs in rmdups 4 0 $ replicateM 2 [a,b,c,d]
05:04:51 <lambdabot>   [[a,b],[a,c],[a,d],[b,a],[b,c],[b,d],[c,a],[c,b],[c,d],[d,a],[d,b],[d,c]]
05:04:56 <jlaire> > let rmdups _ _ [] = []; rmdups n 0 (_:xs) = rmdups n n xs; rmdups n i (x:xs) = x : rmdups n (i-1) xs in rmdups 4 0 $ replicateM 2 [a,a,c,c]
05:04:57 <lambdabot>   [[a,a],[a,c],[a,c],[a,a],[a,c],[a,c],[c,a],[c,a],[c,c],[c,a],[c,a],[c,c]]
05:05:19 * aavogt wonders why there doesn't seem to be this 'one' aka. 'select' in Data.List
05:05:21 <jlaire> if there are no duplicates, tat works
05:05:53 <aavogt> jlaire: there's an [a,a] in there
05:06:07 <jlaire> aavogt: because the input was [a,a,c,c]
05:06:19 <jlaire> for [a,b,c,d] it's correct
05:06:35 <jlaire> rmdups removes every (n+1)th element
05:06:38 <aavogt> > let one (x:xs) = (x,xs) : map (fmap (x:)) (one xs); one [] = [] in let z = [a,a,b,c] in  [ (a,b) | (a,z1) <- one z, (b,_) <- one z1 ]
05:06:39 <lambdabot>   [(a,a),(a,b),(a,c),(a,a),(a,b),(a,c),(b,a),(b,a),(b,c),(c,a),(c,a),(c,b)]
05:07:01 <isomorphic> that's still correct behaviour for my problem
05:07:05 <aavogt> > let one (x:xs) = (x,xs) : map (fmap (x:)) (one xs); one [] = [] in let z = [a,a,c,c] in  [ (a,b) | (a,z1) <- one z, (b,_) <- one z1 ]
05:07:06 <lambdabot>   [(a,a),(a,c),(a,c),(a,a),(a,c),(a,c),(c,a),(c,a),(c,c),(c,a),(c,a),(c,c)]
05:07:17 <koala_man> can you prove ((p -> q) and -q) -> -p with curry-howard?
05:08:08 <develhevel> why does the FFI provide C types like (unsigned int - CUInt) but no signed types? (like signed int)
05:08:22 <ben> But there's CInt
05:08:23 <aavogt> jlaire: it's probably better to remove the duplicates before they are put together?
05:10:13 <HugoDaniel> :D
05:10:16 <HugoDaniel> you guys are crazy
05:10:18 <HugoDaniel> eheh
05:11:20 <develhevel> ben: ok, but why there is no long double but there is a long int?
05:12:12 <benmachine> I believe the absence of CLDouble is for no better reason than it hasn't been implemented yet
05:12:15 <ben> dunno
05:12:48 <isomorphic> is there a simple way to time an operation in ghci?
05:13:02 <jlaire> isomorphic: :set +s
05:13:26 <isomorphic> jlaire: Thanks :)
05:13:40 <benmachine> http://hackage.haskell.org/trac/ghc/ticket/3353 ← GHC ticket for adding long double support in the FFI
05:18:48 <frerich> jlaire: Neat, I wasn't aware of ":set +s" either, thanks for pointing that out!
05:19:01 <jlaire> np :)
05:19:04 <jlaire> (rtfm!)
05:27:34 <benmachine> read the fantastic manual.
05:29:16 <jlaire> I was thinking of "fine", used in a netiquette RFC
05:30:02 * isomorphic thought something different entirely 
05:33:02 <benmachine> isomorphic: there are definitely no other meanings
05:33:05 <benmachine> that's all of them
05:35:03 <jlaire> the RFC does allude to another one
05:35:38 <jlaire> http://www.ietf.org/rfc/rfc1855.txt
05:37:07 <isomorphic> ah yes. They knew about fmap all the way back then
05:43:21 <varnie> greetings. could you check whether or not this function is buggy? http://hpaste.org/48016
05:43:40 <varnie> it doesn't handle negative integers correctly AFAIK.
05:43:56 <isomorphic> varnie: Have you seen quickcheck?
05:44:08 <varnie> please keep in mind that function isn't mine.
05:44:19 <varnie> it is from: http://haskell.org/haskellwiki/99_questions/Solutions/21
05:44:40 <varnie> regarding quickcheck, yes, I've seen it.
05:44:47 * hackagebot HarmTrace 0.4 - HarmTrace: Harmony Analysis and Retrieval of Music  http://hackage.haskell.org/package/HarmTrace-0.4 (JosePedroMagalhaes)
05:45:41 <isomorphic> varnie: Will it handle an empty list?
05:46:38 <earthy> hm. are the haskell planet rss and atom feeds broken?
05:47:08 <varnie> you're right. it is buggy but it is presented as the solution for "problem 21" on the haskell website
05:47:34 <varnie> I suppose it should be removed from there, what do you think on it?
05:47:59 <isomorphic> varnie: not necessarily a probem, depending on what principle is meant to be taught
05:48:12 <isomorphic> might not be ideal
05:49:31 <varnie> I have better solution :-[
05:49:43 <isomorphic> what is it?
05:50:25 <varnie> here it is: http://hpaste.org/48019
05:50:42 <varnie> but I am just newbie.
05:51:11 <jlaire> varnie: that's almost identical to the first solution
05:51:14 <Botje> varnie: note  that you need to specialcase for 0
05:51:32 <isomorphic> non-recursive
05:51:34 <jlaire> 0 is invalid input
05:51:39 <jlaire> it starts at 1 for some odd reason
05:51:43 <Botje> ah
05:52:22 <isomorphic> varnie: but good effort
05:52:32 <jlaire> the example deals with that using a (n+1) pattern >_>
05:53:39 <varnie> my GHCI cannot deal with that solution: Parse error in pattern: n + 1
05:54:01 <jlaire> varnie: if you're copying it to GHCi, put "let " at the beginning
05:54:19 <varnie> no, I put that function into my module and then load it
05:54:29 <jlaire> odd
05:54:31 <benmachine> it may be more to do with the fact that n+k patterns were removed in haskell2010
05:54:41 <benmachine> so sufficiently new GHCs will have them off by default
05:55:00 <jlaire> oh, well that's even more reason to remove it from the example solution
05:55:24 <varnie> you're right! "(Note that this solution uses n+k-patterns which are removed from Haskell 2010.) "
05:55:53 <varnie> http://haskell.org/haskellwiki/99_questions/Solutions/19 suffers the same issue.
05:56:05 <jlaire> and starting at 1 is just confusing
05:56:15 <jlaire> maybe there's a reason for it
06:05:57 <varnie> I want to know which built-in functions can I use for my 99 haskell problems implementations?
06:06:37 <hpc> varnie: there's no real set list
06:06:57 <hpc> varnie: i would go with "use the functions whose implementations you understand"
06:07:08 <varnie> then I am on a good way.
06:07:46 <hpc> and also don't do things like define length' in terms of length :P
06:08:34 <varnie> I passed that step already (implemented my own length func)
06:09:16 <parcs> @hoogle (<#>)
06:09:16 <lambdabot> No results found
06:09:20 <parcs> @hoogle lambda
06:09:20 <lambdabot> Language.Haskell.Syntax HsLambda :: SrcLoc -> [HsPat] -> HsExp -> HsExp
06:09:50 * hackagebot hack2-handler-warp 2011.6.20.1 - Hack2 warp handler  http://hackage.haskell.org/package/hack2-handler-warp-2011.6.20.1 (JinjingWang)
06:11:04 <varnie> @hoogle random
06:11:04 <lambdabot> package random
06:11:04 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
06:11:04 <lambdabot> module System.Random
06:12:50 * hackagebot maid 2011.6.20 - A simple static web server  http://hackage.haskell.org/package/maid-2011.6.20 (JinjingWang)
06:23:53 <edwardk> hrmm. i'm enjoying implementing (multivariate) polynomials in the vector space monad much much more than i was enjoying it implementing them directly
06:24:13 <synonymous> I'm a little stuck here. I'm writing a function which takes a few random number generators and compares them in some way. It returns a bool. So the type we will be generating is not mentioned in the type signature. Yet, I wan't to keep the function polymorphic, only constrained by (Random a). Did I explain myself clearly enough?
06:25:51 <roconnor> synonymous: in order to compare things you need them to be instances of Ord?
06:25:56 <edwardk> yes. used the tagged library and pass a Proxy or do it in the Tagged monad for the type 'a' or just roll your own phantom type
06:26:24 <edwardk> foo :: Random a => Proxy a -> your current signature
06:26:37 <edwardk> then to run it use foo (Proxy :: Proxy Int)
06:27:02 <edwardk> you may of course need other constraints on a.
06:27:14 <edwardk> the Proxy argument exists just to pass in type information
06:27:24 <edwardk> the type of Proxy is data Proxy a = Proxy
06:27:31 <edwardk> so it carries no actual 'a' term
06:27:45 <roconnor> I don't see how you can pass random number generators into the function without mentioning the type of numbers they randomly generate.
06:28:08 <edwardk> Proxy a is an argument. its just a phantom type
06:28:29 <edwardk> that is enough to let him use random with the same type using scopedTypeVars
06:28:37 <edwardk> or asTypeOf
06:28:47 <synonymous> roconnor: gen <- newStdGen, now :t gen is just StdGen
06:29:03 <roconnor> @type newStdGen
06:29:03 <lambdabot> IO StdGen
06:29:06 <roconnor> ah
06:29:12 <synonymous> edwardk: thats that's it!
06:29:30 <edwardk> happy to help
06:31:18 <varnie> I cannot find a function which would return a random value from a list supplied
06:32:20 <identity_> varnie: something like (with System.Random) let foo l = randomRIO (0, length l) >>= \x -> return $ l !! x
06:32:41 <edwardk> just generate a number and index into a list with it
06:32:41 <identity_> eh
06:32:55 <identity_> let foo l = randomRIO (0, length l - 1) >>= \x -> return $ l !! x
06:33:29 <varnie> and should we pay attention to the type of "generated" value?
06:33:41 <varnie> so we might use it as an index (so, it should be int)
06:33:58 <roconnor> @type let foo l = randomRIO (0, length l - 1) >>= \x -> return $ l !! x in foo
06:33:59 <lambdabot> forall a. [a] -> IO a
06:34:25 <identity_> :t (!!)
06:34:26 <lambdabot> forall a. [a] -> Int -> a
06:34:30 <identity_> varnie: aye
06:34:35 <identity_> but it is inferred automatically in this case
06:38:31 <roconnor> edwardk: I don't know much about shift and reset.
06:39:29 <varnie> okay, thanks
06:39:34 <roconnor> edwardk: where are your new operators?
06:39:44 <edwardk> roconnor: i hpasted them the other day for ski
06:40:08 <edwardk> nothing earth shaking, just analogues due to the fact that both Cont and Store are kan extensions
06:40:15 <roconnor> http://hpaste.org/47920
06:40:25 <edwardk> yeah
06:40:32 <edwardk> remember the crappy callCV combinator?
06:40:40 <edwardk> this was me working towards one in a more principled way
06:41:10 <roconnor> I don't remember callCV
06:41:18 <edwardk> look in Discont
06:41:23 <edwardk> on comonad-transformers
06:41:26 <edwardk> it isn't unique
06:41:32 <edwardk> unlike callCC which is a well-oiled machine
06:42:18 <companion_cube> callCV makes me feel like searching for people to hire
06:42:44 <edwardk> =)
06:43:42 <roconnor> I think I undrestand unshift and unreset less than shift and reset.
06:44:50 <edwardk> they don't do much
06:45:38 <edwardk> i was trying to puzzle through them with jacques up at mcmaster, since i had him there ;)
06:45:46 <edwardk> and i figured some of your store expertise would have rubbed off
06:46:30 <roconnor> heh
06:46:36 <roconnor> I don't understand this fancy Store i j
06:47:06 <edwardk> oh, i should put up the indexed store comonad somewhere
06:47:34 <edwardk> its just Store i j a = Store (i -> a) j
06:47:40 <roconnor> ya I see it's definition
06:47:53 <edwardk> you can yield a value of j, and resume with a value of i.
06:47:54 <roconnor> but (Store i) isn't a comonad.
06:48:05 <edwardk> its not. its an indexed comonad
06:48:17 <edwardk> lemme paste code
06:48:25 <roconnor> what are the operations of an indexed comonad?
06:48:32 <roconnor> or the operations of an indexed monad
06:48:37 <edwardk> pure :: a -> w i i a
06:48:58 <edwardk> extend :: (a -> w i j a) -> w i k a -> w j k a
06:48:59 <Eduard_Munteanu> BTW, any resources on those?
06:49:07 <edwardk> Eduard_Munteanu: my head mostly
06:49:11 <Eduard_Munteanu> :)
06:49:51 <edwardk> @hpaste
06:49:51 <lambdabot> Haskell pastebin: http://hpaste.org/
06:50:21 <edwardk> http://hpaste.org/48020
06:50:34 <edwardk> that is a fairly awful indexed comonad module
06:50:44 <roconnor> ah
06:50:50 <roconnor> crazy
06:51:07 <edwardk> otherwise its the Store you know and love
06:51:50 <roconnor> edwardk: is this some sort of comonadoid?
06:52:04 <edwardk> well, its a comonad given rise to by an indexed adjunction
06:52:27 <edwardk> when you set i = j you get the comonad you're used to
06:52:33 <sam9> I have a question about haskell
06:52:36 <edwardk> most monads/comonads can be split like this
06:52:40 <edwardk> sam9: shoot
06:52:45 <sam9> A piece of code is giving me a really hard time
06:52:53 <sam9> what was the site where I can post?
06:53:01 <edwardk> @hpaste
06:53:02 <lambdabot> Haskell pastebin: http://hpaste.org/
06:56:33 <ski> edwardk : `extend :: (a -> m j k b) -> (m i j a -> m i k b)'
06:56:35 <hpaste> edwardk annotated “indexed (co)monads for roconner” with “indexed (co)monads for roconner (annotation)” at http://hpaste.org/48020#a48022
06:57:33 <edwardk> ski: thats the monad version. we woops my version was a bit conflated =)
06:57:47 <edwardk> i was so focused on getting the indices right that i got the arrow backward
06:58:02 <edwardk> extend :: (w j k a -> b) -> w i k a -> w i j b
06:58:03 <ski> you forgot to use both `a' and `b', as well
06:58:06 <sam9> http://hpaste.org/48023
06:58:12 <sam9> the code is a little long...
06:58:16 <ski> s/extend/preserve/ :)
06:58:19 <sam9> but it is giving me a lot of trouble
06:58:30 <varnie> good bye, gotta go.
06:58:37 <edwardk> that was the version that gave
06:58:51 <edwardk> duplicate :: w i k b -> w i j (w j k b)
06:58:57 <edwardk> which is particularly satisfying
06:59:28 <edwardk> ski: the ship has already sailed on that one =)
07:01:39 <edwardk> that is a very odd inner loop sam9
07:02:11 <sam9> I wasn't sure if this was natural in haskell or not...
07:02:31 <sam9> I'm a bit new to haskell and I downloaded this from the haskell website...
07:02:32 <edwardk> i would have expected something more list comprehensiony
07:02:52 <edwardk> and yes if xs ys and ks aren't the same length it'll drop some
07:02:58 <sam9> but when I try it out... it gets the right values...
07:03:19 <edwardk> but i can't yet tell if its deliberately doing so =)
07:03:47 <sam9> hm... I see...
07:04:01 <sam9> I guess I have to plug in real numbers and go through it again step by step...
07:04:12 <sam9> cuz this is a functional language... its hard to just go line by line debugging...
07:04:16 <Botje> wow, that is some serious macho coding :)
07:04:32 <ski> (edwardk : .. only if one doesn't change it :)
07:04:41 <edwardk> go len xs ys ks = [ k x y | k <- map (f len) ks ++ map (g len) ks | x <- xs ++ xs | y <- ys ++ ys ]
07:04:50 <merijn> Is there a bitshift operator in Haskell? (I assume yes, but what is it?)
07:05:06 <edwardk> but then you can recode that as zipWith3 id (map (f len) ks ++ map (g len) ks) (xs ++ xs) (ys ++ ys)
07:05:36 <ski> @type Data.Bits.shift
07:05:36 <lambdabot> forall a. (Bits a) => a -> Int -> a
07:05:44 <merijn> ski: Ah, thanks :)
07:05:50 <HugoDaniel> i need to generate xml with haskell, what package should i use ?
07:06:33 <edwardk> roconnor: the indexed comonad stuff clicking?
07:06:38 <iskren> hello.
07:07:30 <yitz> HugoDaniel: i've been using xml-enumerator lately. i'm happy with it.
07:07:37 <iskren> Is there any reason the module System is not available on a ghc on mac (v 7.*). For example it didn't recognize the List module; Data.List should have been specified
07:08:17 <yitz> HugoDaniel: you build an xml structure using the types in xml-types. it then uses blaze-builder to render it for you.
07:08:20 <erus`> can i serialize a datatype to file/bytes somehow?
07:08:36 <benmachine> iskren: System and List are in the haskell98 package
07:08:56 <benmachine> iskren: nowadays it's more common to use the qualified variants
07:09:07 <benmachine> Data.List is essentially List but bigger
07:09:19 <edwardk> iskren: you need to use -package haskell98 to get old stuff like that
07:09:41 <HugoDaniel> yitz: nice :)
07:09:46 <HugoDaniel> i was looking at xmlgen
07:09:50 <HugoDaniel> seems cool too
07:09:54 <iskren> benmachine, Ok The reason is because I just submitted one university project, and the tutors cant get it work ... and they don't seem to know haskell well enough to fix it themselves
07:10:05 <iskren> (the reason I'm asking)
07:10:18 <benmachine> edwardk: it's not hidden by default is it?
07:10:25 <Botje> erus`: there's Data.Binary
07:10:36 <Eduard_Munteanu> edwardk: hrm, from what I gathered from Agda's stdlib, they define (normal) monads in terms of an underlying indexed monad.
07:10:40 <benmachine> iskren: if you can provide us with specific errors we can be more useful
07:10:47 <iskren> I mean -- what is the most proper way to compile it (makefile) and include it (source file)
07:10:55 <edwardk> Eduard_Munteanu: that fits my recollection
07:11:08 <Botje> iskren: ideally, you would use cabal to generate a Setup.lhs
07:11:09 <edwardk> benmachine: if it isn't it will be soon from the sounds on the mailing list
07:11:11 <benmachine> iskren: ghc --make usually does everything for you
07:11:19 <benmachine> edwardk: ah, hm
07:11:24 <Botje> then your tutors can run Setup.lhs configure; Setup.lhs build
07:11:31 <Eduard_Munteanu> I'm not sure if that works in Haskell, though; I mean, I can't see how that collapses to an 'm a'-something :)
07:11:35 <benmachine> it isn't in 7.0.3 afaik
07:11:37 <Botje> (or cabal build, which comes with ghc nowadays)
07:11:50 <Botje> iskren: I am running ghc 7.0.3 on a mac
07:12:06 <benmachine> Botje: don't think cabal as a command comes with ghc
07:12:09 <Botje> if all your errors are because of packages, I could try to compile it and fix the obvious warnings
07:12:14 <benmachine> comes with HP but that's different :P
07:12:18 <Botje> benmachine: the platform then?
07:12:19 <Botje> ah :)
07:13:04 <yitz> HugoDaniel: same basic idea, except it uses its own internal ad-hoc XML type.
07:13:37 <HugoDaniel> cool
07:13:41 <iskren> benmachine, I applied the tips in one wiki, and they use ghc -c filenamen -cpp
07:13:41 <HugoDaniel> ill go with xml-enumerator
07:13:44 <yitz> HugoDaniel: there's been an effort in the web-devel community to standardize applications on xml-types, to encourage interoperability between xml packages.
07:13:50 <HugoDaniel> i really enjoy snoyman packages :)
07:14:11 <iskren> Botje, great!
07:14:16 <benmachine> iskren: that sounds like a difficult way of doing it, which wiki is that?
07:14:30 <yitz> HugoDaniel: yeah he's good. i take some credit for getting him hired at my company :)
07:14:33 <iskren> Botje, can I give you an archive containing some code and you'll try to just build it? :)
07:14:38 <Botje> iskren: sure
07:15:07 <HugoDaniel> yitz:  :D
07:15:20 <HugoDaniel> i would love to work in a team with him, thats for sure
07:15:36 <yitz> HugoDaniel: but anyway, yeah, using blaze-builder to render xml is not a big deal to implement, and it will be easy to use and fast.
07:15:43 <iskren> benmachine,   http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/separate-compilation.html
07:15:44 <HugoDaniel> yes
07:15:49 <yitz> HugoDaniel: so any of those is probably fine.
07:16:17 <benmachine> iskren: I think those are just examples
07:16:27 <benmachine> iskren: ghc --make is much easier
07:16:37 <HugoDaniel> i usually try to avoid the parsec dependency, xml-enumerator uses attoparsec seems like the right tool to me
07:16:56 <HugoDaniel> thanks
07:17:10 <iskren> benmachine, ok, but what exactly. I mean -- I have a lot of files, and 2 executables
07:17:24 <benmachine> HugoDaniel: what's wrong with parsec?
07:17:46 <yitz> HugoDaniel: yeah its cleaner and faster here, no need for a general token parsing library for simple xml rendering.
07:17:51 <iskren> benmachine, is there a flag to ghc that will be more strict on my platform? so I know it will work on theirs?
07:17:55 <yitz> s/its/it's/
07:18:03 <benmachine> iskren: if you name your files the same as the modules they contain, apart from the two main modules, you should be able to just do ghc --make mainfile.hs
07:18:11 <benmachine> iskren: that will track down all the dependencies for you
07:18:18 <edwardk> hugodaniel: i have to admit bos's recent revelations about backtracking in attoparsec scare the hell out of me
07:18:28 <edwardk> hugodaniel: at least with parsec i know what i'm getting
07:18:34 <HugoDaniel> yeah true :(
07:18:35 <benmachine> iskren: if you made a cabal file that might be better, but it's also a bit tedious for small projects
07:18:41 <yitz> edwardk: don't worry, he backtracked from that :)
07:18:53 <edwardk> yitz: he backtracked back to the backtracking behavior ;)
07:18:55 <yitz> edwardk: i've been using it extensively. it works great.
07:20:50 <yitz> edwardk: i suspect that try is a no-op. it keeps stuff in byte buffers to be fast. but in typical uses of atto that's an advantage, not a problem.
07:21:39 <iskren> Botje, here is the archive: http://iskren.info/share/pr1.tar.gz
07:22:00 <edwardk> yes, but try being a no-op means you can be many levels deep in a grammar holding on to god only knows what.
07:22:32 <edwardk> the point of try is to let it cut off access to backtracking
07:22:48 <yitz> edwardk: it has a CPS-style interface that encourages you to factor your parsing into digestable pieces for speed and exptlicitly controled streaming, rather than shoving an entire document into a massive parser.
07:22:56 <edwardk> yes
07:22:58 <Botje> installing happy and hunit ..
07:23:18 <edwardk> but i'm somewhat dubious that the 'try is a noop' machinery means you get artifacts at the chunking boundaries
07:23:23 <yitz> edwardk: so if you need the big parser, then yeah, better go with parsec.
07:23:35 <yitz> edwardk: artifacts?
07:23:38 <iskren> Botje, well, yes :-/
07:23:59 <edwardk> whether or not an untry'd block tries to backtrack past the current chunk.
07:24:01 <iskren> Botje, thank you very much for helping me with that!
07:24:02 <Botje> iskren: compiles just fine here
07:24:14 <iskren> benmachine, the ghc --make Foo.hs
07:24:16 <edwardk> so you might get different results due to local backtracking within a chunk than you will if it straddles
07:24:53 <iskren> doesn't really work for my unit test executable (it needs hunit, and it has the main function, the module is called Tests and the main function is main, but even -main-is Tests.main and -package HUnit didn't help)
07:25:14 <iskren> Botje, well can run ./Tests
07:25:16 <yitz> edwardk: the continuation interface makes that kind of behavior pretty explicit, so you do know what your getting anyway.
07:25:23 <edwardk> attoparsec was build more or less assuming that it was parsec, i've always used it under that flawed assumption, heck even bos seemed to have that assumption for the most part until he found the try machinery
07:25:26 <iskren> Botje, and there is a test directory containing test_all.sh
07:25:31 <yitz> s/your/you're/
07:25:38 <edwardk> i've ported it to another language, and i still don't know that i do ;)
07:25:39 * yitz has a stuck apostrophe key today
07:26:19 <yitz> edwardk: it's definitely not parsec
07:26:44 <edwardk> i meant that it'd parse the same stuff given the same combinators
07:27:33 <yitz> edwardk: i haven't tried a careful comparison, but i definitely find myself thinking differently when writing parsers in the two libraries.
07:28:33 <yitz> edwardk: i *know* that you get different results - in the case where try is not a no-op in parsec :)
07:29:13 <edwardk> =)
07:29:51 <yitz> edwardk: the way you empty your buffer in parsec is by not using try. the way you do it in atto is by ending this parse and running the next one.
07:30:35 <edwardk> at the chunk boundary you mean?
07:32:21 <iskren> what is the proper way to do if inside a do syntax, but just for one expression, and then have another do block (do sth. (if a then do A else do B) do sth else)
07:32:35 <yitz> no, you get back a "left-over" and run another parse. the chunking is just a manual mechanism that replaces the automatic one that you get when you parse a lazy bs/text.
07:33:23 <Botje> iskren: see /query
07:33:35 <iskren> Botje, /query of what?
07:33:38 <yitz> edwardk: you'd never do that in parsec, but in atto it's just pointers into memory, so it's almost free, especially when fusion is happening.
07:33:48 <Botje> iskren: I talked at you in a private msg window
07:33:50 <edwardk> yes, but i can use that mechanism in any other parsing combinator library. it doesn't do me much good when i have half a gig in a single xml file or something where i have structure and can't just start over mid-stream
07:33:55 <Botje> commonly called a query :)
07:34:10 <edwardk> well, its almost as free in parsec running on an iteratee base
07:34:17 <yitz> edwardk: i'm doing exactly that.
07:34:45 <edwardk> anyways, i'll summarize with just 'i am disappoint' ;)
07:37:28 <jimmy_the_ask> hi
07:37:28 <lambdabot> jimmy_the_ask: You have 1 new message. '/msg lambdabot @messages' to read it.
07:38:23 <jimmy_the_ask> what's faster, operations on Int or on Integer ?
07:38:30 <yitz> edwardk: if your half-gig is in memory, you're better off with atto, because it does a lot less copying. if not, then anyway you'll use an event-based xml processor so atto again wins.
07:38:45 <Eduard_Munteanu> jimmy_the_ask: Int
07:38:48 <yitz> edwardk: parsec is for when you need a higher-level token type.
07:39:04 <ion> jimmy_the_ask: Usually it doesn’t matter. Integer has more safety.
07:39:39 <edwardk> anyways, i guess we'll have to continue this later or i'll be late for work =P
07:39:43 <yitz> edwardk: or a more flexible monadic interface
07:39:48 <jimmy_the_ask> ok, thanks
07:39:48 <edwardk> later, man
07:39:54 <yitz> edwardk: byebye
07:40:54 <ion> jimmy_the_ask: You’ll generally want to use Integer, unless you have a specific reason to use a N-bit integer, in which case you probably want IntN/WordN.
07:44:01 <develhevel> is there something like #{size struct} in the hsc2hs?
07:44:49 <yitz> ion: the problem is that many Prelude functions are monomorphic on Int, and that is contagious. So I find myself using Int much more than Integer, just to avoid all the extra work that usually arises when I use Integer.
07:53:00 <accel> does haskell have a library for writing onlines via monads/combinators for doing string parsing/manip tasks? (i.e. tasks typically done by sed/awk or perl -pie)
07:55:59 <develhevel> is there something like #{alignment struct} in the hsc2hs?
08:15:30 <dino-> accel: For parsing, there is parsec and attoparsec
08:18:08 <dino-> accel: Can also use regexp. I say that because of your mention of perl -pie
08:18:30 <accel> dino-: I've used aprsec before
08:18:36 <accel> I don't know how to write oneliners in it
08:18:45 <accel> was wondering if there's a haskell library for fast/dirty jobs
08:19:07 * hackagebot hakyll 3.2.0.2 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.0.2 (JasperVanDerJeugt)
08:19:16 <Silvah> There's no Haskell library for fast/dirty jobs.
08:19:43 <Silvah> But there are lots of Haskell libraries for fast/clean jobs.
08:19:54 <erus`> i only like dirty jobs
08:20:00 <erus`> and blowjobs
08:20:53 <dino-> accel: mm, maybe a thin wrapper around Text.Regex then.
08:22:10 <dcoutts> Botje: cabal init will generate a Setup.hs and a blah.cabal file
08:25:27 <dino-> accel: You can write shell scripts with Haskell with #! /usr/bin/env runhaskell
08:25:43 <ion> Those are shell scripts?
08:25:44 <dino-> But one-liners.. not sure how much is going to be able to be accomplished that way.
08:26:28 <dino-> ion: Technically I suppose sort of a just-in-time compile. But I think of it that way.
08:27:04 <ion> People tend to refer to POSIX sh scripts by “shell scripts”.
08:27:41 <ion> But yeah, the term is ambiguous.
08:28:41 <dino-> shapr: Hey. Hows code?
08:29:04 <shapr> dino-: Code is in Python.... haven't written much Haskell lately :-(
08:29:14 <shapr> dino-: How's code with you?
08:29:26 <dino-> shapr: Ah. It's been a whole lot of Scala for me for months. Starting an Erlang job in one week.
08:29:46 <dino-> Say what you will about Scala, but it's quite a relief when being forced to target the JVM.
08:30:00 <shapr> dino-: That's awesome!
08:31:05 <shapr> dino-: I'd like to have an FP job again... hopefully after I finish my degree.
08:32:09 <mightybyte> As I understand it, in category theory (a -> a) is called an endomorphism.  Is there a name for (a -> IO a)?
08:32:12 <dino-> shapr: thank you. Yeah, I've been pretty teriffied of the prospect of sliding back to straight Java or more Perl for a living.
08:33:04 <dino-> Tough call between those two, eh? Do you want not-entirely-insane types or ability to write closures?
08:33:44 <quicksilver> mightybyte: it's an endomorphism in a different category.
08:34:00 <quicksilver> mightybyte: (the kleisli category of the IO monad)
08:34:25 <mightybyte> quicksilver: Ahhh, thanks.
08:34:29 <quicksilver> "return" is the identity morphism in that category.
08:34:37 <quicksilver> and (>=>) is composition.
08:34:40 <mightybyte> How does that relate to an endofunctor?
08:34:50 <quicksilver> the monad laws are, basically, the things that make sure it is a category indeed.
08:35:21 <quicksilver> an endofunctor is a functor from a category to itself.
08:35:37 <quicksilver> "Maybe" is an endofunctor on Hask.
08:36:21 <mightybyte> Interesting
08:37:22 <Eduard_Munteanu> mightybyte: a -> IO a   is merely the unit of the IO monad, i.e. return
08:37:31 <quicksilver> Eduard_Munteanu: no it's not.
08:37:54 <Eduard_Munteanu> What do you mean? Maybe I'm missing some context.
08:37:56 <quicksilver> Eduard_Munteanu: there are lots of morphisms in types of the form a -> IO a
08:38:11 <quicksilver> 'return' is just one particularly important one.
08:38:17 <Eduard_Munteanu> Oh, right.
08:38:45 <quicksilver> it's the only interesting one which is guaranteed to exist, though.
08:39:22 <Eduard_Munteanu> Yeah, the only one which isn't "arbitrary" :)
08:43:40 <mightybyte> quicksilver: According to wikipedia, "an endomorphism is a morphism from a mathematical object to itself".  It seems like (a -> IO a) isn't really a morphism to itself
08:44:21 <Eduard_Munteanu> IO :: * -> *
08:44:41 <quicksilver> mightybyte: yes, it is.
08:44:49 <quicksilver> mightybyte: in the kleisli category.
08:44:59 <acfoltzer> mightybyte: it's an endofunctor, not an endomorphism
08:44:59 * mightybyte googles
08:45:17 <quicksilver> mightybyte: in the kleisli category of IO, a morphism from "a" to "b" is a function of type "a -> IO b"
08:45:23 <byorgey> acfoltzer: no it isn't.
08:45:30 <Eduard_Munteanu> IO is an endofunctor, as for "endomorphism" I'm not sure
08:45:41 <acfoltzer> ah, misunderstood
08:45:47 <mightybyte> quicksilver: Ahhh, I see.
08:45:59 <Eduard_Munteanu> In CT morphisms are always in the same category, not "across", so...
08:46:26 <quicksilver> mightybyte: more generally, in any kleisli category for a monad T over any category C, a morphism from 'a' to 'b' in the kleisli category is the same thing as a morphism from 'a' to 'T b' in C
08:47:42 <mightybyte> All kinds of abstract goodness going on there.
08:47:47 <quicksilver> right.
08:48:12 <quicksilver> it's potentially confusing when the same mathematical entity is different things in different places :)
08:48:17 <mightybyte> Yeah
08:48:33 <quicksilver> so 'a' is an object of Hask, and also an object of the Kleisli category of IO over Hask.
08:48:35 <mightybyte> So is there a different term for what "a -> IO a" is in the category C?
08:48:45 <acfoltzer> so, just so I can clear up my own confusion: IO is an endofunctor, and a -> IO a is a (endo?)morphism in the kleisli category for IO
08:48:54 <quicksilver> mightybyte: a kleisli arrow, perhaps?
08:49:08 <quicksilver> acfoltzer: yes.
08:49:09 <byorgey> acfoltzer: right
08:49:25 <develhevel> what is the alignment in the Storable typeclass? what does the alignment tell me?
08:49:27 <mightybyte> quicksilver: Ok, that makes sense.  I was just wondering if there were any other concepts lurking around in there.
08:49:29 <acfoltzer> cool. always nice to banish a misconception :)
08:49:33 <Eduard_Munteanu> So does "endo" even make sense?
08:49:33 <quicksilver> acfoltzer: a -> IO a is a (not endo) morphism in Hask, and it's an endomorphism in the kleisli category.
08:49:43 <Eduard_Munteanu> (admittedly "arrow" can be confusing at times too :D)
08:50:21 <quicksilver> acfoltzer: that is, in Hask it's a morphism between two different objects "a" and "IO a", whilst in the kleisli cat for IO, it's a morphism from "a" to "a".
08:50:48 <Eduard_Munteanu> Oh.
08:50:50 <mightybyte> quicksilver: Yeah, that was the root of my question.
08:50:52 <acfoltzer> that makes sense
08:51:10 <mightybyte> It's clearly not endo in the obvious category.
08:53:13 <ben> what's the recommended way/library for sending simple http (post/get) requests and receiving the results?
08:53:16 <ben> curl?
08:53:26 <Eduard_Munteanu> Guys, there's ##categorytheory, mind ;)
08:55:01 <monochrom> HTTP or curl
08:55:19 <ben> cheers
08:55:36 <mightybyte> quicksilver: Thanks for the clarification
09:24:06 <copumpkin> roconnor: you mean the enumerator module?
09:24:18 <copumpkin> robbert: for ripemd160
09:24:21 <copumpkin> roconnor I mean
09:39:29 <gal_bolle> I'm trying to use cabal sdist to prepare a release of darcs. darcs.cabal contains a line "if impl(ghc>=7.0) {extensions: NoMonoLocalBinds}" which makes cabal complain about NoMonoLocal and refuse to make a dist tarball. What can I do?
09:42:13 <dcoutts> gal_bolle: it depends on what version of Cabal hackage is using
09:42:23 <dcoutts> gal_bolle: if it's using a development version then it'll work
09:42:35 <dcoutts> if it's using Cabal-1.10.x then it will refuse it
09:43:03 <gal_bolle> i'm indeed using cabal 1.10.2
09:43:13 <dcoutts> gal_bolle: does it really refuse to make a tarball? I thought it was just a warning
09:43:16 <gal_bolle> is there a way to subdue it?
09:43:25 <gal_bolle> maybe it's refusing for another reason
09:43:39 <gal_bolle> it tells me it's an error, then gives me a serving of warning
09:44:01 <gal_bolle> then exits with status 1
09:44:05 <dcoutts> can I see the output?
09:44:14 <dcoutts> sounds like something else is wrong
09:44:20 <gal_bolle> probably
09:44:24 * hackagebot scrypt 0.1.1 - Stronger password hashing via sequential memory-hard functions.  http://hackage.haskell.org/package/scrypt-0.1.1 (FalkoPeters)
09:44:49 <gal_bolle> actually something else is wrong
09:44:59 <gal_bolle> cabal: Error: Could not find module: Version with any suffix:
09:45:01 <gal_bolle> ["gc","chs","hsc","x","y","ly","cpphs","hs","lhs"
09:45:21 <dcoutts> oh that's because you generate that module iirc
09:45:22 <gal_bolle> i got caught by a monomorphic local red herring
09:45:29 <gal_bolle> yes
09:45:41 <gal_bolle> so i'll have to generate it, then run sdist i guess
09:45:42 <dcoutts> gal_bolle: iirc, the Setup.hs sdist works
09:46:12 <dcoutts> because you've got custom code in the Setup.hs to handle this in sdist
09:46:24 <dcoutts> the problem is that cabal sdist cannot call Setup.hs sdist because the interface is crap
09:47:09 <dcoutts> Setup.hs sdist does too much, it creates the tarball, but cabal sdist wants to make the tarball itself, it just wants a source tree ready for tar
09:47:49 <dcoutts> the solution is that we have to extend the Setup.hs sdist command line interface with an output dir flag
09:48:21 <gal_bolle> i stopped trying using Setup.hs that when runghc stopped working for me; it just returns status 127 whatever I do
09:48:47 <dcoutts> compile Setup.hs
09:49:07 <gal_bolle> yes, that's what I am doing, thanks to your explaination
09:49:23 <gal_bolle> i was using cabal out of laziness, not knowing there was a difference
09:49:29 <gal_bolle> thanks
09:49:32 <dcoutts> usually there isn't
09:49:37 <dcoutts> but that's an infelicity
09:54:22 <joe6> is there a better place to download the ghc-7.0.4 source code. It tells me that it will take 2 hrs to download it.
09:54:39 <joe6> from here: wget http://haskell.org/ghc/dist/7.0.4/ghc-7.0.4-i386-unknown-linux.tar.bz2
09:55:09 <thoughtpolice> joe6: that's a binary distribution of GHC, not the source code
09:55:11 <thoughtpolice> http://www.haskell.org/ghc/dist/7.0.4/ghc-7.0.4-src.tar.bz2
09:55:15 <thoughtpolice> ^ that is the source code
09:55:28 <joe6> sorry, I meant the binary distribution
09:55:41 <joe6> thoughtpolice: sorry, I meant the binary distribution.
09:56:17 <thoughtpolice> joe6: np. either way i do not think so. GHC 7.0.4 is new, so it probably won't be in any package managers yet, ditto with the haskell platform. i also don't think there are faster mirrors than the haskell.org servers, but perhaps they should be
09:56:20 <fasta> Is Leksah dead?
09:56:32 <thoughtpolice> s/they/there/
09:56:51 <erus`> can anyone point me to a good troll article on why haskell sucks please
09:56:55 <joe6> thoughtpolice: ok, thanks.
09:57:00 <thoughtpolice> joe6: so it'll take a while. GHC binaries being large is something people do complain about. sry :(
09:57:16 <joe6> haha, worth the pain, though..
09:57:20 <Igloo> If it's taking 2 hours then the problem is probably your connection, not the server
09:57:30 <Igloo> I get an eta of just over 5 mins
09:57:42 <hamishmack> fasta: No
09:58:05 <joe6> Igloo: oh, really. will check it out. Thanks.
09:58:06 <thoughtpolice> i'd say I get something similar (eta of like 4 minutes,) but I'm on my work internet connection which is, well, not slow to say the least.
09:58:07 <fasta> hamishmack: then why doesn't it work?
09:58:20 <thoughtpolice> so it might be unfair to say that :P
09:58:32 <fasta> hamishmack: in my world, Fails to Build => dead project.
09:59:30 <thoughtpolice> realistically 'being dead' is quite different from 'needing manpower' - i sometimes run into build problems all the time with software, doesn't mean it's dead. if you're encountering an error in particular, perhaps you should contact the leksah maintainers and let them know so they can help you
09:59:46 <fasta> I already solved this 'build problem'.
09:59:58 <parcs> erus`: this may be what you want http://steve-yegge.blogspot.com/2010/12/haskell-researchers-announce-discovery.html
10:00:06 <fasta> I think it is second issue I had to fix already.
10:00:11 <fasta> the second*
10:01:01 <thoughtpolice> i don't speak for the leksah devs however, nor do i know how frequent they are to work on the project, so i won't say it's dead or not. but being dead is different than needing manpower or just a build failure, unless this failure is completely systemic and affects everyone, not just you
10:01:04 <erus`> parcs: read it before :) funny
10:01:18 <fasta> erus`: all the problems in Haskell are already documented.
10:01:18 <thoughtpolice> (i use emacs anyway)
10:01:46 <fasta> erus`: it is easy to shoot holes in the system, but then again, it is easy to do that for C++ too.
10:01:51 <thoughtpolice> parcs: i thought that one was entertaining. and a yegge post that's below the 'small novel' watermark is something to behold in itself
10:03:18 <fasta> thoughtpolice: do you have jump to definition functionality in Emacs already?
10:03:36 * hackagebot TinyLaunchbury 1.0 - Simple implementation of call-by-need using Launchbury's semantics  http://hackage.haskell.org/package/TinyLaunchbury-1.0 (DavidSankel)
10:03:38 <thoughtpolice> dunno if ghc-mod does that, I just use it for the flymake mode
10:03:45 <thoughtpolice> which by itself is a ridiculous timesaver
10:04:02 <fasta> Flymake also has issues.
10:04:22 <fasta> thoughtpolice: e.g., how do you say that it should dump its temporary files somewhere else?
10:04:24 <thoughtpolice> it works quite well with ghc-mod. either way it appears to have an info command (C-c C-i) that will give you relevant source information
10:05:00 <thoughtpolice> fasta: ghc-mod? or flymake? ghc mod just bundles flymake and adds a mode for GHC, i'm actually not sure of that question atm
10:05:05 <fasta> I worked around that in a recent project, but it is something basically every user hates, AFAIK.
10:05:14 <thoughtpolice> (as to where it stores things)
10:05:57 <fasta> thoughtpolice: this issue: http://stackoverflow.com/questions/1856671/configure-flymake-to-use-specific-directory-for-temp-files
10:06:01 <thoughtpolice> the only thing ghc-mod doesn't quite get yet is preprocessors, which will off the line information by a single line. i think i fixed that at one point but dunno if i sent a patch to kazu
10:06:06 <thoughtpolice> i should check that
10:06:17 <fasta> thoughtpolice: who made ghc-mod?
10:06:41 <thoughtpolice> kazu yamamoto
10:06:43 <thoughtpolice> http://www.mew.org/~kazu/proj/ghc-mod/en/
10:06:47 <thoughtpolice> @hackage ghc-mod
10:06:47 <lambdabot> http://hackage.haskell.org/package/ghc-mod
10:06:52 <gal_bolle> when the .cabal file has a "main-is" clause within a if then else, sdist tries to use the concatenation of the main-is for the two if branches (main_then.hsmain_else.hs), which fails, since it can't find it
10:07:04 <gal_bolle> I don't know if it's a known issue
10:07:21 <fasta> thoughtpolice: interesting.
10:07:29 <gal_bolle> http://hpaste.org/48025
10:08:17 <thoughtpolice> fasta: it works pretty well. there are edge cases, and some people argue the style ghc-mod takes (basically using the GHC API and doing things like checking for error outputs and whatnot and highlighting the lines) should not be the "one true way"
10:08:28 <dcoutts> gal_bolle: http://hackage.haskell.org/trac/hackage/ticket/817
10:08:33 <thoughtpolice> other people want more client-server functionality so we can build the server to integrate with GHC once, and any IDE could then be a client
10:08:36 * hackagebot TinyLaunchbury 1.0.1 - Simple implementation of call-by-need using Launchbury's semantics  http://hackage.haskell.org/package/TinyLaunchbury-1.0.1 (DavidSankel)
10:08:38 <thoughtpolice> but frankly ghc-mod works now, so i use it
10:09:20 <fasta> thoughtpolice: yes, it is a hack, but then again, our machines can eat through 1000 times more information per second, so it doesn't matter.
10:09:23 <thoughtpolice> (i would agree that's probably not the best or most accurate way, though. and it won't handle certain cases like when you need files which may depend on a build step, like autoconf-subst'd files, for example)
10:10:26 <fasta> I suppose it would be pretty simple to modify GHC to enable all kinds of interesting information, though.
10:10:59 <fasta> Nobody does it, but likely people would want to pay for it now.
10:11:16 <fasta> Or rather fund its development for <5000 dollar.
10:12:09 <thoughtpolice> we should have GHC kickstarter projects! that would actually be kinda awesome
10:12:13 <bgamari> Is there any way to get ghc to print out the types of definitions during compilation?
10:12:24 <fasta> thoughtpolice: with bitcoins
10:12:40 <bgamari> It would be nice to have an overview of everything defined to debug typing issues
10:12:41 <thoughtpolice> I HEAR THEY'RE CHEAP RIGHT NOW
10:12:56 <thoughtpolice> bgamari: no, i don't think so. what is the use case you're thinking of?
10:13:12 <erus`> bitcoins are illegal
10:13:20 <fasta> thoughtpolice: still pretty expensive, if you ask me.
10:13:23 <erus`> you can mine them in minecraft
10:13:52 <mekeor> erus`: r bitcoins rly illegal??
10:13:56 <benmachine> bgamari: there are various options to get ghc to dump various parts of output, but it's not necessarily user-friendly
10:13:58 <fasta> erus`: do you have an intelligent question to share with this channel?
10:14:47 <fasta> thoughtpolice: cabal install ghc-mod # fails to build here.
10:14:50 <poucet> > sum [1,2,3,4]
10:14:51 <lambdabot>   10
10:14:54 <poucet> > sum [1,2,3,4, n]
10:14:55 <lambdabot>   0 + 1 + 2 + 3 + 4 + n
10:15:03 <benmachine> bgamari: maybe some of this would be interesting: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-debugging.html but probably it's only meant for consumption by GHC devs
10:15:04 <bgamari> thoughtpolice, benmachine: I'm just trying to get a sense of what I'm doing wrong in my type system
10:15:13 <bgamari> benmachine: thoughtpolice,     Occurs check: cannot construct the infinite type: a = Dif a
10:15:16 <thoughtpolice> bgamari: now, if you want the types of library functions, you can open GHCi, import the module, and do ':i <name>' and it'll give you lots info info including types and whatnot. in your own module, you can do the same, but the module has to type check properly to be loaded
10:15:24 <erus`> fasta: yes; can you point me to a basic haskell optimizing tutorial? i learned how to use -prof earlier so i know where the bottlenecks are now but i know not how fix them
10:15:25 <bgamari> benmachine, thoughtpolice, Is not a particularly useful error
10:15:28 <thoughtpolice> bgamari: ah, post some code! it'll be easier to see what's going on
10:15:44 <benmachine> bgamari: that error does make sense, but only once you're used to it I think
10:16:10 <benmachine> bgamari: it's like, if you write foo x = x : x, then you're using x as a thing and a list-of-thing at the same time
10:16:21 <fasta> erus`: learn how to evaluate simple expressions first.
10:16:31 <fasta> erus`: big systems work the same as small systems.
10:16:31 <benmachine> so if you say the type of x is a, you're forming the equation a = [a], which means a = [[a]] = [[[a]]] = ...
10:16:43 <hpaste> “Ben Gamari” pasted “    Occurs check: cannot construct the infinite type: a = Dif a ” at http://hpaste.org/48027
10:16:46 <benmachine> bgamari: and that's an infinite type, and they're Bad.
10:16:56 <bgamari> thoughtpolice: http://hpaste.org/48027
10:17:00 <fasta> erus`: make drawings of your data structure as it evaluates for example.
10:17:05 <thoughtpolice> fasta: what's the issue? the only major thing i could think of is that maybe you're lacking an external program like happy in order to generate a parser file for some dependency. what dependency failes to install? or does ghc-mod itself only fail?
10:17:34 <bgamari> benmachine: Fair enough, I'm just getting started with the Haskell type system
10:17:40 <thoughtpolice> (cabal can't track "dependencies on a program" because programs like happy don't expose any library to be registered for GHC, so sometimes cabal can have uninformative error messages)
10:17:42 <fasta> thoughtpolice: http://paste.debian.net/120468/
10:17:50 <benmachine> bgamari: indeed that's exactly what's going on here, by the looks of it - newtonRaphsonDiff expects two functions of the same type, but you've given it two functions of (I believe) different types
10:17:54 <benmachine> :t deriv
10:17:55 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
10:18:06 <benmachine> ^ notice that 'dif f' is a different type from f
10:18:10 <benmachine> er
10:18:16 <benmachine> 'deriv f' is a different type from 'f'
10:18:31 <benmachine> how you fix that I don't know, ask your differentiation library docs :)
10:18:40 <thoughtpolice> fasta: ouch. :( seems like you got cabal confused. what does 'ghc-pkg check' say?
10:19:06 <thoughtpolice> (monochrome could probably better answer any problems you have since he wrote an entire article on cabal problems like this, lemme see if i can find a link)
10:19:10 <fasta> thoughtpolice: There are problems in package HTTP-4000.1.1: dependency "network-2.3.0.2-0436fbce1f203c6e68950b8dfae33e3f" doesn't exist
10:19:20 <fasta> thoughtpolice: and some others.
10:19:21 <bgamari> benmachine: bummer
10:19:33 <benmachine> bgamari: actually I suspect newtonRaphson has too permissive a type signature, and claims to accept functions which can't be differentiated
10:19:38 <fasta> thoughtpolice: systems that don't work are not good advertising for Haskell.
10:20:02 <bgamari> benmachine: Hmm
10:20:43 <hamishmack> fasta:  http://code.google.com/p/leksah/issues/list
10:21:04 <thoughtpolice> fasta: i can't give much expertise in these areas, since i have very rarely encountered them, i can only known that cabal still has cases where diamond dependency problems confuse it. it's hard to isolate exactly what package confused it, too
10:21:20 <benmachine> bgamari: I've gotta go, but I wonder if you want something like (forall a. Num a => a -> a) as an argument
10:21:24 <hamishmack> fasta: If you don't file a bug report I'll just go on assuming you are dead
10:21:30 <benmachine> ...actually probably that's too restrictive
10:21:35 * benmachine shrug
10:21:36 * benmachine run off
10:21:37 <thoughtpolice> @where sicp
10:21:37 <lambdabot> The Wizard book : "Structure and Interpretation of Computer Programs" at <http://mitpress.mit.edu/sicp/> by Hal Abelson,Gerald Jay Sussman with Julie Sussman, videos at <http://swiss.csail.mit.edu/
10:21:37 <lambdabot> classes/6.001/abelson-sussman-lectures/>
10:21:39 <hamishmack> fasta: :-)
10:21:41 <thoughtpolice> hm, wrong one
10:22:00 <thoughtpolice> @google "structure and installation of cabal programs"
10:22:01 <lambdabot> No Result Found.
10:22:04 <thoughtpolice> :(
10:22:29 <thoughtpolice> you'd think that would be relatively unambiguous
10:22:33 * thoughtpolice checks his irc logs
10:22:56 <bgamari> thoughtpolice: You have any ideas about http://hpaste.org/48027
10:23:04 <bgamari> Any input would be appreciated
10:23:11 <thoughtpolice> http://www.vex.net/~trebla/haskell/sicp.xhtml
10:23:12 <thoughtpolice> there it is
10:23:46 <thoughtpolice> bgamari: does 'Data.Number.Dif' come from the numbers package, IIRC?
10:24:19 <bgamari> thoughtpolice: yep
10:24:31 <Twey> What's the FFI type corresponding to a void pointer?
10:25:01 * thoughtpolice also looks over the convo benmachine had with bgamari while it installs
10:25:45 <bgamari> Thanks
10:26:22 <thoughtpolice> Twey: on my "FFI import" I think I normally just use 'Ptr a', so you can effectively put a pointer to whatever the hell you want there
10:26:35 <thoughtpolice> i don't know if that's the "correct" way to do it however :P
10:33:08 <bgamari> thoughtpolice: Ideas?
10:33:27 <thoughtpolice> bgamari: looking, your infinite type err is a bit different with my GHC (what ghc version are you using, btw?)
10:33:27 <monochrom> it's storage and identification :)
10:33:33 <thoughtpolice> monochrom: damnit!
10:33:50 <bgamari> thoughtpolice: 6.12.3
10:34:33 <monochrom> 7.0.x uses a new type checker and therefore different style error messages
10:34:45 <thoughtpolice> bgamari: yeah, i'm using 7.0.4, and the type checker was completely overhauled and redone, so it's actually not an infinite type error, but a 'rigid type variable' problem (basically meaning that you're using a type variable i a "more general way" than you should)
10:36:17 <roconnor> copumpkin: I found the bytestring module works just as well as the enumerator module for my purposes.
10:36:42 <bgamari> thoughtpolice: Perhaps I'll try to find a newer package
10:38:17 <roconnor> copumpkin: all the endienness in ripemd160 is wrong :P
10:38:55 <roconnor> I mean the spec is wrong; the code conforms to the spec; otherwise it wouldn't work ;)
10:39:02 <copumpkin> roconnor: oh, weird
10:39:08 <copumpkin> so the official spec is broken?
10:39:19 <roconnor> According to my endienness preferences
10:40:08 <joe6> the haskell-platform-2011.2.0.1 requires ghc-7.0.3. Is it ok to use it with ghc7.0.4?
10:40:17 <joe6> or, will it not work?
10:40:25 <fasta> How can I get cabal and ghc in a clean state?
10:40:57 <joe6> the configure says:  http://sprunge.us/AcMK
10:41:38 <monochrom> you can try following that instruction about --enable-unsupported-ghc-version
10:41:48 <monochrom> I haven't tried, too lazy
10:42:14 <joe6> monochrom, ok, wasn't sure if there are some bottlenecks to doing that..
10:42:41 <roconnor> copumpkin: oh and another thing I want to try is a WordVector module using with http://hackage.haskell.org/package/vector
10:42:50 <thoughtpolice> bgamari: i think it has a bit to do with the type class constraints concerning the 'deriv' function that's causing GHC to give the roundabout, but i don't know the best fix while keeping the functions generalized :(
10:42:54 <thoughtpolice> sry
10:43:30 <zzing> Are there any examples of audio generation? I am doing something with C, and have an example, but I am looking for 'functional inspiration', especially any state transition systems.
10:43:31 <copumpkin> roconnor: a Vector of Word8?
10:43:38 <joe6> when I install a new ghc and haskell platform, is there some method of just re-installing all the previously installed cabal modules?
10:43:41 <fasta> cabal: internal error: could not construct a valid install plan.
10:43:44 <fasta> Interesting...
10:43:52 <dcoutts> fasta: oh, that is an interesting one
10:44:24 <dcoutts> joe6: the plan for that is "cabal install world". It sometimes works at the moment, but really needs the new solver to work fully.
10:44:28 <roconnor> copumpkin: one that conforms to the interface found in WordArray WordByteString and WordList
10:44:53 <fasta> dcoutts: how can I nuke every package or thing which ghc7 believes about the world?
10:44:57 <joe6> dcoutts: ok, thanks. let me try that. it would be very cool to have that.
10:45:07 <fasta> dcoutts: (including cabal install.)
10:45:09 <dcoutts> fasta: rm ~/.ghc/
10:45:09 <thoughtpolice> zzing: i think there are some synthesis/composition libraries on hackage
10:45:12 <thoughtpolice> zzing: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:music
10:45:13 <thoughtpolice> there you go
10:45:14 <roconnor> copumpkin: those modules are all swappable with each other.
10:45:18 <copumpkin> I see
10:45:33 <zzing> thoughtpolice: hey thank you mate
10:45:47 <thoughtpolice> np
10:46:41 <roconnor> copumpkin: if you want to have some fun you can swap in those various modules and see the various memory performances.
10:51:07 <mjo> Given a list of items, is there a standard way to generate the list all the possible choices of n elements from the list
10:51:25 <mjo> A bit like a generalized permutations in other words
10:52:14 <byorgey> mjo: if you want choices with repetition, you can do  replicateM n
10:52:22 <byorgey> choices without repetition is a bit trickier
10:53:31 <mjo> byorgey: Sadly that is the case
10:53:56 <mjo> The lists are small though, so given that the elements are unique I could just sort and nub
10:54:00 <monochrom> bgamari: newtonRaphson :: (RealFrac a) => (forall b. RealFrac b => b -> b) -> a -> a -> a  (and turn on RankNTypes). this is because the parameter f plays two roles and needs the extra polymorphism
10:54:25 <byorgey> mjo: no, that won't be the same thing, the results will not all be of length n
10:55:11 <byorgey> mjo: well, it's not too hard to write: in the base case (empty list) you make sure you are trying to select 0 things
10:55:31 <byorgey> in the (x:xs) case, you can either select x and then select (n-1) things from xs, or ignore x and select n things from xs
10:55:37 <monochrom> P.S. if you say RealFrac you can omit Ord
10:57:37 <mjo> yes, of course, you'll still get the duplicate [1,1] case from [1,2,3,4] won't you ?
10:58:17 <mjo> byorgey: I can see it's easy to write, it just seemed like the sort of thing which would already exist somewhere...
10:58:36 <monochrom> or perhaps you can stay rank-1 and use unDif on f. newtonRaphsonDiff (unDif f) (deriv f) eps x0
10:58:37 <byorgey> it's probably in some library on Hackage but it's not in a standard library
10:58:54 <mjo> byorgey: I don't feel so bad about not finding it
10:58:58 <mjo> byorgey: Thanks though
11:05:41 <bgamari> monochrom: Unfortunately the latter doesn't work
11:06:31 <bgamari> monochrom: I get several instances of     Couldn't match type `a' with `Dif a'
11:07:23 <monochrom> oh, I meant this: newtonRaphson :: (RealFrac a) => (Dif a -> Dif a) -> a -> a -> a;  newtonRaphson f eps x0 = newtonRaphsonDiff (unDif f) (deriv f) eps x0
11:07:42 <bgamari> monochrom: I get several instances of     Couldn't match type `a' with `Dif a'
11:07:45 <bgamari> Oops
11:08:04 <bgamari> Excellent point
11:08:37 <bgamari> That makes sense although I can't say I would have thought of it myself
11:08:52 <bgamari> These sorts of issues seem very tricky to get write
11:08:54 <bgamari> right*
11:09:04 <bgamari> The compiler doesn't do much to help you
11:09:49 <byorgey> telling you that 'a' doesn't match 'Dif a' is doing quite a bit to help you =)
11:11:13 <monochrom> 6.12.3 says "Occurs check: cannot construct the infinite type: a = Dif a"
11:11:39 <monochrom> although, when my type tutorial is done, you will see that it's the same thing as "a doesn't match Dif a"
11:14:07 <bgamari> Thanks!
11:16:34 <hpaste> permi pasted “permu” at http://hpaste.org/48031
11:30:05 <danharaj> What sequence data structure should I use if I want to perform very cheap swapping of elements?
11:30:44 <c_wraith> mutable array?
11:34:26 <Cale> It's relatively cheap with Data.Sequence
11:34:33 <Cale> (log time)
11:34:43 <Somelauw> Maybe haskell has transient vectors or something.
11:35:20 <Cale> You could also use a Data.Map or Data.IntMap from indices to values (though you lose the guarantee that all elements of the sequence are present that way)
11:36:11 <Eliel> is it possible to define a datatype that doesn't specify the exact type for one element but rather a typeclass?
11:36:38 <Cale> Eliel: That's called an existential type. Yeah it's possible (with extensions)
11:36:45 <danharaj> Eliel: The idiom I've seen is that you define it to be a type constructor and put the type class constraint in your interface functions.
11:37:08 <Cale> data Showable where S :: (Show a) => a -> Showable
11:37:11 <danharaj> oh, you mean like you can hold any type of that class in the data? That's existential, yeah.
11:38:15 <Cale> But, if you feel like doing that, I find it's often worth thinking about whether another type (maybe a function type) would be better.
11:38:40 <Cale> In the case of Show specifically, if all you know about some value is how to turn it into a String, then why not just record a string?
11:39:08 <Cale> For most typeclasses and datatypes, there are easy ways around using existentials.
11:39:35 <danharaj> generally you can substitute a type and a type class with a record type that holds all the functions you want plus the value.
11:39:54 <Cale> Or all the functions you want, already applied to the value :)
11:40:12 <ben> someone write a better data.enumerator tutorial, tia
11:40:24 <danharaj> what if I have a function a -> a, ;p
11:40:36 <danharaj> state machines
11:41:51 <Eliel> I'm designing data structures for a web-server and am trying to figure out how to do the authentication. I want the datatype to be able to have several authentication records in it as a list.
11:41:59 <Cale> danharaj: That can be replaced by (recursively) a value of the interface record type :)
11:42:32 <Eliel> as well as, the authentication methods might vary
11:42:51 <Cale> Eliel: Okay, so what are the authentication records?
11:44:28 <Eliel> Cale: one of them would have simple username and password. Also, for some things the system ought to support one time pad code lists to verify some things.
11:44:55 <Eliel> also need to keep the option open to easily add alternative authentication methods to replace the simple username and password one
11:45:01 <Eliel> like PKI
11:45:44 <Cale> Eliel: So suppose I have an authentication record of an arbitrary type which I don't tell you straight away. What do you need to know about it from me in order to make use of it?
11:46:46 <Cale> If you ask for the type of record, then that's like making a disjoint union type like   data AuthRecord = UserPass ... | PKI ... | OTP ...
11:47:16 <Eliel> hmm, yes, that would work.
11:48:02 <Cale> If you give me some sign in details and ask the authentication record to take care of deciding whether or not the sign in is valid
11:48:15 <Cale> Then that's like a function   SignInDetails -> Bool
11:49:29 <Eliel> would be ideal if the program can support new authentication methods without needing recompilation, but I'm not sure if that's possible with haskell.
11:49:56 <Cale> Eliel: Sure it is, you just have to say what you mean by that :)
11:50:40 <Cale> What data go into specifying an authentication method in general, and once specified, how is it used?
11:51:47 <Cale> Also, if it's convenient to define them in Haskell code without needing to recompile the main program, you could always use hint to load up Haskell object or source files defining things at runtime.
11:52:20 <Eliel> I suppose the part this interface needs to care about is that it gets the sign in details and passes them to a authenticate function
11:52:46 <Cale> Are the details needed for each method different?
11:54:19 <Eliel> hmm... not too much I think
11:54:38 <Eliel> username and something to verify, so you could perhaps generalize it as password.
11:56:14 <Eliel> what is this hint that you can use to load up haskell object or source files at runtime?
11:56:23 <Eliel> do you have a link?
11:56:35 <parcs> @hackage hint
11:56:35 <lambdabot> http://hackage.haskell.org/package/hint
11:56:56 <hpaste> permi annotated “permu” with “permu (annotation)” at http://hpaste.org/48031#a48033
11:57:09 <danharaj> hmm, I wish there were a way to use a mutable structure in pure code provided it's used in a 'threaded' fashion.
11:57:16 <danharaj> (without using a monad)
11:57:25 <Eliel> Cale: thank you
12:00:08 <Cale> danharaj: Well... that's kinda what ST is for. You could try to ignore the fact that ST is a monad and only use the applicative interface, I guess ;)
12:02:01 <danharaj> actually, how good is GHC at optimizing the pattern "use data structure, modify data structure, pass modified data structure to recursive call"?
12:03:29 <Saizan> it won't update in-place
12:03:43 <fasta> dcoutts: what was that internal error about?
12:03:46 <Cale> But that tends to be cheaper than people expect because everything is pointers
12:03:59 <dcoutts> fasta: not sure, did you paste a log?
12:04:14 <fasta> dcoutts: what do you want to see?
12:04:33 <dcoutts> fasta: the command line and the error message
12:04:59 <dcoutts> fasta: and cabal --version
12:06:12 <fasta> dcoutts: http://paste.debian.net/120480/
12:06:43 <dcoutts> fasta: ah ok, upgrade to cabal-install-0.10.x
12:09:19 <fasta> dcoutts: that works.
12:11:46 <dcoutts> fasta: the older version does not understand intra-package deps (e.g. the leksah exe depends on the leksah lib) and thought it looked like a dependency cycle
12:14:57 <fasta> dcoutts: could leksah not have specified a version of cabal needed?
12:15:22 <dcoutts> fasta: it's a version of cabal-install, not cabal, so no
12:16:20 <Enigmagic> anyone know if this function already exists somewhere for the enumerator package, hoogle doesn't know...   Monad m => [Iteratee a m b] -> Iteratee a m [b]
12:16:28 <dcoutts> fasta: leksah was doing the right thing (it specified cabal-version: >=1.8). It's just that cabal-install didn't properly support the feature 'til version 0.10
12:22:07 <Tomsik_> Enigmagic: are Iteratees a monoid?
12:23:24 <Cale> Enigmagic: Maybe I'm missing something, but there's an instance (Monad m, Nullable s) => Monad (Iteratee s m)
12:23:33 <Cale> Which means that you can just use sequence
12:23:37 <Cale> :t sequence
12:23:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:26:47 <Enigmagic> Cale: that's what i thought too ... but i get odd results
12:26:56 <Enigmagic> probably something broken with my code :\
12:28:14 <Enigmagic> (well, i started with a forM which should be equivalent in this case)
12:41:41 <Fuco> ap (as defined in lambdabot) is S combinator right?
12:42:12 <NemesisD> hi all. i'm gettting an error with cabal saying a version of bytestring is shadowed by another. they have the same version number but a different sha. ghc-pkg unregister bytestring and then installing it again didn't seem to fix it
12:42:50 <dcoutts> NemesisD: if you get rid of the duplicate and don't re-install another duplicate but use the original then it should be fine
12:43:12 <NemesisD> dcoutts: how do i get rid of the duplicate with the busted sha
12:43:24 <Tomsik_> Fuco: I think that depends on the underlying applicative functor/monad
12:43:34 <dcoutts> NemesisD: like you did before: ghc-pkg unregister
12:43:48 <NemesisD> dcoutts: how would i specify the sha though?
12:44:02 <dcoutts> NemesisD: it'll be the one in the user package, so no need
12:44:16 <Fuco> Tomsik_: heh, yea... looking at @unpl ap now
12:44:42 <Zert> hello ppl
12:44:51 <Fuco> ap f g x = f x (g x) <- this is S comb however
12:45:03 <Zert> how i can upgrade all users packages installed by cabal to new version of ghc?
12:45:05 <Fuco> well, ap is just a randmo name now
12:45:30 <monochrom> re-install all of them. new ghc ignores old packages
12:45:36 <dcoutts> Zert: you can try cabal install world, but it may or may not be able to find a solution
12:45:49 <dcoutts> Zert: use cabal install world --dry-run
12:45:49 <Zert> in system-wide packages installed by gentoo portages i use haskell-updater, but how i can reinstall all of them?
12:45:56 <Zert> great thanks!
12:46:26 <monochrom> I keep a list of packages by hand
12:47:37 <dcoutts> monochrom: once we get the new solver you should try the 'world' feature and let us know how you like/dislike/would-improve it
12:47:54 <Zert> monochrom: it is so dirty way
12:48:16 <monochrom> 'world' has zero clue which packages I want for good and which are just free trials I abandon promptly
12:48:31 <Enigmagic> Cale: so the actual problem is that the input isn't replicated... so i guess sequence isn't what i want
12:48:50 <Enigmagic> https://gist.github.com/94d8b6659507c01ca578
12:49:05 <monochrom> 'world' will also re-establish multiple-version disasters that you once established and rectified
12:49:14 <dcoutts> monochrom: that's true. gentoo solves that with a flag --one-shot to indicate that it should not be maintained
12:49:23 <Enigmagic> unless anyone has any ideas, i'll probably have to code it up myself. i swear i remember seeing an implementation somewhere though ..
12:49:32 <monochrom> basically 'world' has zero clue which packages you have unregistered
12:50:08 <dcoutts> monochrom: also true, so we'd need to implement uninstall :-)
12:51:15 <dcoutts> monochrom: but actually it might help with the multipleversionitis because by default it'll try to get everything using the same version of everything (though that's not always possible)
12:53:51 <monochrom> I don't feel dirty to keep anything by hand. there are already two dozen tiny changes to ubuntu config files I do by hand and I jot them down. may as well jot down the haskell libs I frequently use
12:54:15 <proq> monochrom: I just check them in to version control
12:55:46 <monochrom> version control feels too different from a ship's captain's log. I want a ship's captain's log
12:55:57 <dcoutts> monochrom: I don't mean that you should use this feature, just that your experience of it would be valuable, but as you've noted there's a few obvious things to implement first.
12:56:24 <proq> monochrom: voice-to-speech | vc-checkin-script?
12:56:28 <monochrom> I guess one could manually edit .cabal/world
12:56:29 <geheimdienst> monochrom: that's lame. my approach is to make config changes, forget about them, months later something gets overwritten, things start failing in hidden ways, i curse a lot and slowly rediscover what i did for what reason back then
12:56:31 <dcoutts> monochrom: valuable to the cabal hackers I mean, not necessarily to you :-)
12:56:35 <dcoutts> monochrom: yes, can do that
12:56:55 <Enigmagic> Cale: and i found the partially complete iteratee implementation on cafe... going to port it over to enumerator http://www.haskell.org/pipermail/haskell-cafe/2011-January/088319.html
12:56:56 <proq> that's a unix pipe if the reference was ambiguous btw
12:57:15 <dcoutts> geheimdienst: a tried and trusted method
12:57:31 <proq> erm, voice-to-text  :P
12:58:03 <geheimdienst> i hear voice-to-speech is an academically pretty underexplored field
12:59:45 <robert2011> @type map
12:59:46 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:00:36 <robert2011> Hi!
13:00:41 <Cale> hello
13:00:48 <Tomsik_> it there something like div that rounds like ceil instead of floor?
13:01:01 <monochrom> no
13:01:48 <joe6> any thoughts on what I am missing:  http://sprunge.us/QOPg
13:02:06 <robert2011> Tomsik_: can you use something likef loor (x + .5)
13:02:07 <dcoutts> Tomsik_: you can make one using divMod
13:02:37 <dcoutts> if the mod is non-0 then +1
13:02:42 <Tomsik_> robbert: that'll be slow probably, I'd rather avoid that
13:09:30 <matthiasgorgens1> Hi.  I am using System.Process to start of curl to download some files.  (I guess that's the right way to start off another process?)  Now, I am trying to send a signal to the subprocess, but it seems like I can only send SIG_KILL (i.e. terminateProcess).  Is there a way around that?
13:10:13 <robert2011> Can somebody recommend a Haskell book? I have "Real World Haskell" from oreilly. It is quite nice and has helped me a lot. But as a C/C++ programmer I usually stumble a bit when using data structures and the like. Is there any book that could help me to do it the *right* Haskell way?
13:10:30 <matthiasgorgens1> Theres signalProcess :: Signal -> ProcessID -> IO () in System.Posix.Signals, but it seems there's no way to convert from ProcessHandle to ProcessID.
13:10:49 <lispy> robert2011: There are numerous books about Haskell from the academic side of the camp
13:10:55 <raichoo> robert2011: learn you a haskell.
13:11:03 <lispy> robert2011: If RWH is not what you want, I'm not sure what to recommend.
13:11:04 <raichoo> learnyouahaskell.com
13:11:19 <matthiasgorgens1> robert2011, as an alternative, you could read lots of code.
13:11:27 <lispy> robert2011: but perhaps one of the more academic (from the ground up) books would work?
13:11:46 <geheimdienst> yeah, lyah is a good choice. it's available for free on the web
13:11:49 <geheimdienst> @where lyah
13:11:50 <lambdabot> http://www.learnyouahaskell.com/
13:11:52 <lispy> ?hoogle ProcessHandle -> ProcessID
13:11:52 <lambdabot> Warning: Unknown type ProcessHandle
13:11:52 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
13:11:53 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
13:13:34 <robert2011> Learn you a Haskell seems really funny... :-)
13:13:39 <matthiasgorgens> lispy, that doesn't seem to be the way to go..
13:13:40 <lispy> matthiasgorgens: perhaps instead of solving the signal problem you could use the curl package on hackage?
13:13:52 <matthiasgorgens> lispy, i tried that, but it's too low-level.
13:13:58 <raichoo> robert2011: It's great to get your head around the fundamentals.
13:14:18 <matthiasgorgens> or, to say it in a different way, the high level interface doesn't allow to write directly to a file,
13:14:24 <matthiasgorgens> and the low-level interface is too low level.
13:14:43 <robert2011> raichoo: I would not go that far. My code contains still (imho) too much do blocks...
13:14:52 <matthiasgorgens> perhaps if I could get the lazyness just right, i could use the curl package and write to a lazy bytestring, that gets written to file.
13:15:03 <matthiasgorgens> lispy, but i've tried that, and i wasn't smart enough.
13:15:34 <raichoo> robert2011: do blocks are not necessarily a bad think. Depends on the monad ^^
13:15:42 <raichoo> thing that is
13:16:00 <matthiasgorgens> raichoo, yes. what's worse is intermingly recursion with the general code.
13:16:06 <matthiasgorgens> intermingling.
13:16:15 <matthiasgorgens> raichoo, recursion belongs into clever combinators.
13:16:21 <lispy> matthiasgorgens: what about the first constructor listed here: http://hackage.haskell.org/packages/archive/curl/1.3.7/doc/html/Network-Curl-Opts.html#t:CurlOption
13:16:56 <robert2011> Oh yeah, all these monads... But I will try, promised! And thank you very much!
13:17:21 <matthiasgorgens> lispy, I had a look at that, but it seems you need to implement your own WriteFunction.  (I had a look at how manatee uses curl,
13:17:24 <lispy> matthiasgorgens: Which is something you set with setopt: http://hackage.haskell.org/packages/archive/curl/1.3.7/doc/html/Network-Curl-Easy.html
13:17:44 <matthiasgorgens> and that's quite lowlevel.  mucking around with buffers, malloc-ing and so on.)
13:18:53 <danharaj> :t fix
13:18:54 <lambdabot> forall a. (a -> a) -> a
13:18:55 <danharaj> :t fix fix
13:18:56 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
13:18:56 <lambdabot>     Probable cause: `fix' is applied to too many arguments
13:18:56 <lambdabot>     In the first argument of `fix', namely `fix'
13:19:13 <matthiasgorgens> lispy, i'm afraid i will introduce more bugs that way, than if i call out to the command-line curl binary.
13:20:16 <matthiasgorgens> lispy, also i'd have to do the "resume a download" logic myself.
13:20:22 <matthiasgorgens> lispy, thanks for your help so far!
13:25:06 <robert2011> :type fromIntegral
13:25:12 <robert2011> @:type fromIntegral
13:25:12 <lambdabot> forall a b. (Integral a, Num b) => a -> b
13:26:21 * edwardk waves hello.
13:29:29 <devinus> how can i use the new ghc llvm backend when installing packages using cabal?
13:31:33 <lispy> matthiasgorgens: depending on your requirements, I bet you can find an existing http library on hackage.  There are several.
13:32:17 <matthiasgorgens> lispy, yes, there are several.  though i believe that we have to support more than http.
13:32:43 <lispy> matthiasgorgens: as in, https or something else?
13:33:32 <matthiasgorgens> lispy, yes, at least https, but maybe also ftp and friends.  also we will have to deal with failing network connections.
13:35:56 <parcs> devinus: cabal install -fllvm, i presume
13:35:57 <lispy> matthiasgorgens: what about this one? http://hackage.haskell.org/package/download-curl-0.1.3
13:36:08 <maurer_> C/win 4
13:37:02 <matthiasgorgens> lispy, thanks, i've looked at that.  but I do not actually want to look at the content of what i'm downloading within haskell.  actually i do not want the downloaded files in memory at all.  i want to write them to disk.
13:37:25 <c_wraith> be wary of the curl bindings with multithreaded code, anyway.  They segfault for me.
13:37:40 <c_wraith> matthiasgorgens: sounds exactly what http-enumerator was built for.
13:37:47 <lispy> c_wraith: oh right, I've seen that too.  I thought it was solaris only.
13:38:08 <lispy> matthiasgorgens: well, Network.Curl.Download.Lazy should allow you to stream from memory to disk
13:38:13 <matthiasgorgens> !c_wraith, thanks, i'll have a look.
13:38:23 <matthiasgorgens> lispy, yes, maybe i give the lazyness another try.
13:38:31 <matthiasgorgens> lispy, i could make lazyness work on my first try.
13:38:44 <lispy> matthiasgorgens: lazy + IO makes me nervous though.  I don't really want to encourage it.
13:39:00 <lispy> Esp., since you mentioned failure cases ande resuming
13:39:09 <matthiasgorgens> lispy, yes.
13:39:27 <matthiasgorgens> lispy, the good thing about command-line curl (and wget) is, that they have already thought of those problems.
13:40:20 <matthiasgorgens> c_wraith, the enumerator-package looks good so for: "This example uses interleaved IO to write the response body to a file in constant memory space."
13:49:08 <Cale> Weird question that I don't really care about the answer to, but seems kinda fun: Suppose I have a regular language L over an alphabet Sigma, and I have a family of regular languages M_s for each s in Sigma. Define the language I(L,M) to consist of all words obtained by picking a word w in L, and for each s occurring in w, if the last occurrence of s in w is at position n, choosing a word v_s of length at least n from
13:49:08 <Cale> M_s, and then splicing the words chosen from each M_s together according to the word w. (So that if the ith symbol in w is s, then the ith symbol of our constructed word is the ith symbol of v_s). Is this language necessarily regular?
13:50:46 <matthiasgorgens> Cale, the weird length requirement may make it non-regular.
13:52:54 <Cale> Yeah, possibly. I could probably define it without explicitly stating that length restriction though (it's just what naturally occurs because if there's an s at the nth position in w, then we'll need something at the nth position in our v_s)
13:53:14 <matthiasgorgens> yes.
13:53:40 <matthiasgorgens> any L that produced only finite words would be fine.
13:54:39 <matthiasgorgens> Cale, it helps that removing a prefix and postfix keeps a regular language regular.
13:54:59 <Cale> yeah
13:55:17 <matthiasgorgens> does removing a finite number of words (i.e. all that are smaller than n) keep regularity?
13:55:38 <matthiasgorgens> i guess it should do.
13:55:52 <matthiasgorgens> (but might make the grammar quite large.)
13:55:57 <Cale> Yeah, the difference of any two regular languages is regular
13:56:09 <matthiasgorgens> yeah, temporarily forgot about that.
13:56:51 <matthiasgorgens> there's an obvious construction of M_s out of an infinite number of regular languages.
13:57:04 <matthiasgorgens> but of course that doesn't keep regularity.
13:58:33 <matthiasgorgens> i'd try an induction over the length of words in the resulting language.
13:58:39 <danharaj> does Data.Sequence have a function analagous to insertBy?
13:58:40 <Cale> I'm thinking there might be a way to approach it in terms of funny operations on finite state machines also.
13:58:44 <matthiasgorgens> there's probably a pattern that's gonig to repeat.
13:58:54 <matthiasgorgens> Cale, yes.
13:59:08 <matthiasgorgens> Cale, basically that's what i wanted to say. :o)
13:59:23 <matthiasgorgens> Cale, especially non-deterministic state-machines.
13:59:27 <Cale> yeah
13:59:31 <matthiasgorgens> Cale, hey, i guess that's solves it.
13:59:52 <Cale> Like start with the product of all the machines and then start adding lots of epsilon edges to it
13:59:54 <matthiasgorgens> (or does it?  if you need an infinite number of state machines,
13:59:57 <matthiasgorgens> that would be too much.)
14:00:00 <Cale> errr... or something
14:00:20 <danharaj> argh
14:00:22 <Cale> Nah, that doesn't work
14:00:28 <danharaj> Why doesn't Sequence have `insertBy' :(
14:00:28 <Cale> danharaj: insertBy?
14:00:42 <Cale> Like for producing sorted words?
14:01:26 <danharaj> I need it because I am going to be inserting elements that must respect an ordering. I need Sequence because I'm going to be mutilating the sequence often.
14:01:31 <erus`> if we can store the state of the universe, will a step of reality yield the same result every time? is the world purely functional? or is it scheme?
14:01:55 <Cale> danharaj: hmm, can you describe your problem further?
14:02:02 <gwern> erus`: the schrodinger wave-equation updates deterministically...
14:02:13 <gwern> erus`: so I suppose it depends on your interpretation of quantum mechanics?
14:02:17 <matthiasgorgens> erus`, if you make sure to also store the state of the universe's random number generator, you'll be fine.
14:02:42 <Cale> Yeah, things are quantum mechanically deterministic, as far as our model of things is concerned.
14:02:45 <matthiasgorgens> Cale, we need to find a way to re-use state-machines.
14:02:54 <erus`> matthiasgorgens: is that not encapsulated in the state of the universe?
14:03:10 <matthiasgorgens> erus`, only pseudo-random number generators need state.
14:03:25 <matthiasgorgens> erus`, real random number generators should have the opposite of state.
14:03:38 <danharaj> Cale: I'm implementing the Bentley-Ottmann algorithm for intersecting a list of line segments. It's a plane-sweep algorithm. I need to keep an ordered list of line segments at each step. I insert a segment when I come across its first endpoint. I swap two segments when they cross. I remove a segment when I come across its second endpoint.
14:03:51 <erus`> i think its just a hash of the entire state
14:04:22 <matthiasgorgens> danharaj, looks like you'd be well served with a priorityQueue?
14:04:51 <danharaj> matthiasgorgens: I use a priority queue for the events.
14:05:03 <danharaj> At each event I fiddle with the ordered list of segments.
14:05:41 <matthiasgorgens> ok.
14:06:15 <matthiasgorgens> danharaj, have you looked at Data.DList?
14:06:32 <Cale> DList won't be good because he needs more than just fast concatenation
14:06:38 <Cale> Data.Sequence is reasonably good
14:06:52 <Cale> He just needs to write insert himself, I guess.
14:07:03 <Cale> Could do it in a binary search way
14:07:12 <danharaj> I should take a note to ask the maintainer of containers to add insert and insertBy
14:07:16 <Cale> another option would be to use the fingertree package directly
14:07:32 <Cale> which actually might be more convenient
14:08:01 <Cale> fingertrees are awesome
14:08:28 <danharaj> are fingertrees exposed in Base/Containers?
14:08:43 <Cale> danharaj: nope, you need the fingertree package from hackage
14:09:43 <danharaj> alright. while I'm at it, what's the mailing list I can bitch about to try to get insert/insertBy added to Data.Sequence?
14:09:46 <joe6> any suggestions on how I can fix this error:  http://sprunge.us/JOfW , nm /home/j/.cabal/lib/llvm-0.9.1.2/ghc-7.0.4/HSllvm-0.9.1.2.o | grep -i LLVMAddIPSCCPPass         U LLVMAddIPSCCPPass
14:10:22 <joe6> it says that a symbol is undefined, but I can find the symbol in the library file of llvm.
14:10:39 <joe6> I do not know where HSllvm is looking
14:11:26 <joe6> nm /usr/local/lib/libLLVMipo.a | grep -i LLVMAddIPSCCPPass
14:11:27 <joe6> 00000480 T LLVMAddIPSCCPPass
14:13:30 <danharaj_> :\
14:17:04 <dumael> joe6: what OS are you running?
14:21:12 <joe6> dumael: linux debian
14:21:43 <joe6> dumael:  http://sprunge.us/PDGb
14:22:29 <joe6> dumael: i have installed "cabal install llvm --reinstall" multiple times and this is what it says:  http://sprunge.us/NCiM
14:22:41 <joe6> dumael: i presume that it means that everything is ok.
14:23:21 <joe6> but, when I run the command:  http://sprunge.us/ZPFJ
14:23:43 <joe6> i am not sure if this has something to do with haskell-platform
14:24:04 <joe6> as the haskell platform was geared for ghc-7.0.3 and I am using ghc-7.0.4
14:26:16 <dumael> joe6: what version of LLVM (llc -version) ?
14:27:18 <joe6> dumael:  http://sprunge.us/VdHC
14:29:06 <joe6> dumael: could it be affected by the LD_RUN_PATH?
14:31:03 <joe6> dumael: does not seem to be the LD_RUN_PATH
14:31:15 <dumael> possibly. check "echo $LD_RUN_PATH" and "env" and ensure that any linker vars have /usr/local/lib/ in them.
14:32:37 <joe6> dumael:  http://sprunge.us/KIeG
14:35:38 <joe6> dumael: I noticed that configure is using llvm-config-2.7 and not the latest llvm-config
14:38:17 <dumael> that could be a problem alright. I'm out of ideas, you may want to double check what version of LLVM ghci is trying to link to.
14:39:03 <dumael> it's not working at here at all for (refusing to link to libstdc++.so for a start)
14:39:08 <dumael> (for me)
14:44:07 <joe6> dumael: sorry, I lost my net connection for a little bit there.
14:44:30 <joe6> dumael: this is the llvm.buildinfo file: http://pastebin.com/9iA8KkUt
14:44:32 <mauke> The paste 9iA8KkUt has been copied to http://hpaste.org/48042
14:44:54 <joe6> dumael: i think it could be something to do with using llvm-config-2.7
14:47:02 <tekknolagi> what is a cool haskell hack that will blow my mind?
14:47:39 <copumpkin> > let (a, b, c) = (c + 2, 2, b * 3) in (a, b, c)
14:47:44 <copumpkin> oh whoops
14:47:44 <copumpkin> :)
14:47:58 <copumpkin> no lambdabot :(
14:48:03 <Cale> wat
14:48:14 <shachaf> @Calesnack
14:48:18 <copumpkin> @Calesnack
14:48:36 <ben> went missing in that netsplit~
14:48:42 <Cale> yeah, it happens
14:48:49 <copumpkin> > let (a, b, c) = (c + 2, 2, b * 3) in (a, b, c)
14:48:54 <lambdabot>   (8,2,6)
14:48:55 <ben> copumpkin: that translates into fix, right
14:48:58 <Cale> lambdabot seems to do a poor job of noticing when it's been disconnected
14:49:00 <dumael> joe6: i'd say that's it. scrub every copy of LLVM from your machine bar the latest one, and rebuild the haskell package. No ideas after that I'm afraid.
14:49:59 <tekknolagi> copumpkin: what's a lambdabot
14:50:14 <shachaf> @vixen what's a lambdabot
14:50:20 <lambdabot> i dunno...
14:50:22 <ben> > fix $ \(~(a, b, c)) -> (c + 2, 2, b * 3)
14:50:30 <lambdabot>   (8,2,6)
14:50:51 <tekknolagi> (8, 2, 6)
14:50:56 <tekknolagi> what/
14:50:58 <tekknolagi> ?
14:51:02 <shachaf> ben: That's an odd sense of "translates into".
14:51:14 <tekknolagi> > print "hi"
14:51:22 <lambdabot>   <IO ()>
14:51:26 <byorgey> ben: it doesn't translate into fix.  recursive let is just primitive.
14:52:01 <tekknolagi> let (x, y, z) = (1, 2, 3)
14:52:05 <tekknolagi> > let (x, y, z) = (1, 2, 3)
14:52:12 <lambdabot>   not an expression: `let (x, y, z) = (1, 2, 3)'
14:52:18 <ben> let needs an "in" at the end
14:52:24 <ben> > let (x, y, z) = (1, 2, 3) in x
14:52:24 <lambdabot>   1
14:52:34 <tekknolagi> what is the lambdabot...?
14:52:44 <identity_> God.
14:52:49 <tekknolagi> this is kinda coo
14:52:52 <tekknolagi> cool*
14:52:58 <Cale> Well, it might translate into fix, depending on how the compiler works
14:53:01 <ben> byorgey: shachaf: I spent some time trying to wrap my head around the dynamic semantics given for recursive let in the report, it seems to mention fix there
14:53:07 <identity_> inb4 gigantic theological discussion.
14:53:14 <ben> as 'translation into the kernel'
14:53:18 <Cale> It's reasonably common to implement recursion in compilers by taking fix as the primitive
14:53:37 <ben> I ultimately failed wrapping my head around it but at least I memorised the pattern
15:03:28 <dcoutts> dumael: I've also notice that LLVM is odd in that the .so version of the lib does not contain all the bits that are included in the static library
15:03:43 <monochrom> the haskell report does not touch how (steps and order) to evaluate pure things including recursive let.
15:03:58 <dcoutts> dumael, joe6: perhaps that's what you're hitting, but you'd have to check the symbol to be sure
15:04:23 <dcoutts> e.g. in 2.8 at least the .so version does not include all the arch backends that the static libs have
15:04:55 <monochrom> however, it sides itself with denotational semantics, so that's where you can find out what answers a recursive let would give
15:05:25 <dcoutts> joe6, dumael: the LLVM.so has just the x86 backend, but there's a static lib for ARM, and of course the Haskell binding binds all the backends, hence it doesn't work with the .so version (ie in ghci using dynamic linking)
15:06:26 <ddarius> One day there will be a war between those who denote and those who reduce.
15:06:35 <monochrom> the haskell report is fairly explicit where to be strict and where to be non-strict. plug this information into the usual denotational semantics business, and you will see e.g., "ps = () : ps" is an infinite list rather than a failure
15:07:12 <hydo> alert!  reality not matching my assumptions!  Reality clearly flawed!  ok, well, not that bad.  in directory A I forkIO off a worker which setCurrentDirectorys to directory B.  Thread A is suddenly in directory B.  Assuming this is the expected behavior, is there any way I can keep the parent process/thread/whatever in directory A?
15:07:57 <dcoutts> hydo: the current directory is a global (OS process wide) setting
15:08:18 <dcoutts> don't fiddle with it in programs using threads or you'll go mad :-)
15:08:37 <hydo> dcoutts: ah, ok, so since forkIO doesn't make a separate -OS- process, it's a shared... thing.
15:08:45 <dcoutts> generally just don't fiddle with the current dir
15:08:55 <hydo> but.... but....
15:08:57 <hydo> ok
15:08:58 <c_wraith> it's hidden state.
15:09:01 <hydo> ACCEPTANCE
15:09:02 <dumael> dcoutts: I see. I've hit upon LLVM problems before, but they'be mostly been internal LLVM errors.
15:09:04 <c_wraith> hidden state is not your friend! :)
15:09:11 <ddarius> c_wraith: Hidden, global, mutable state.
15:09:16 <dcoutts> hydo: use the FilePath functions for making relative and absolute paths as appropriate
15:09:22 <monochrom> going with the denotation way, here is the process of figuring it out: define this sequence s 0 = ⊥, s n = () : s (n-1). i.e., you think of ps = fix (\x -> () : x), you take out the (\x -> () : x) part, and s n = (\x -> () : x) (s (n-1))
15:09:43 <monochrom> so s 0 = ⊥, s 1 = () : ⊥, s 2 = () : () : ⊥...
15:09:56 <hydo> dcoutts: ok, yea, I can see how I can make that work.  Thanks!
15:10:10 <monochrom> lastly, ps is the limit of that sequence. so you can have as many ()'s as you like down the list
15:10:14 <dcoutts> hydo: the usual thing is just to pass in a base directory and then use base </> ...
15:10:53 <monochrom> that is the answer the haskell report wants. it doesn't care what steps you take to arrive at that answer, at what cost.
15:19:38 <sm> g'day all
15:20:30 <sm> I just port installed libgcrypt to satisfy the Unixutils package which says missing C lib: crypt, but no joy. Any idea what mac port provides this ?
15:22:20 <sm> gosh there's a hs-Crypto port.. I'll try that
15:22:43 <sm> no I won't, that's haskell code
15:23:44 <trygvis> sm: did you include --extra-lib-dirs/--extra-include-dirs when you did configure?
15:23:56 <sm> hi trygvis, yes pretty sure those are in effect
15:24:04 <sm> in my ~/.cabal/config
15:24:31 <trygvis> libgcrypt only has libgcrypt.a/.dylib, not libcrypt
15:25:16 <trygvis> you could probably llok at hs-Crypto's dependencies
15:26:06 <sm> port info hs-Crypto says "Library Dependencies: hs-platform-HUnit, hs-QuickCheck" - is that what you mean ?
15:26:51 <trygvis> "openssl" has /opt/local/lib/libcrypto.a
15:29:12 <kuraj> hi folks
15:30:03 <kuraj> let me ask you a question... im actually trying to recreate in haskell a puzzle solver ive written in prolog back in time
15:30:11 <Cale> kuraj: sure
15:30:46 <kuraj> the puzzle is sort of a battleship game, and one part of it involves creating all the possible ways of placing the ships on the board
15:31:16 <kuraj> we represent the board as a list of lists (thus a quasi-array which is n-by-n dimensions)
15:31:35 <kuraj> and the ship is a list of tuples, one tuple per "piece"
15:32:11 <sm> libcrypt is what it wants.. I dunno, giving up
15:32:31 <kuraj> so back in prolog i would do something like a predicate that does "take a ship from the list and put it on the board horizontally OR vertically, until the list of ships are empty"
15:32:45 <sipa> kuraj: you want the list monad
15:33:19 <kuraj> sigh
15:33:25 <kuraj> im having a hard time understanding monads :(
15:33:38 <monochrom> s/ monad//
15:33:44 <ddarius> kuraj: Or more generally, there are several packages on Hackage that have "logic programming" monads that would let you translate the Prolog pretty directly.
15:33:58 <ddarius> (In fact, arguably producing a result that is better in many ways.)
15:34:32 <trygvis> sm: I think installing openssl should solve it
15:34:32 <trygvis> sm: but I'm off to bed, later
15:34:32 <kuraj> in fact i dont want to "translate" my prolog solution
15:34:51 <kuraj> i just want to acheive the same result
15:35:12 <sm> thx
15:35:36 <kuraj> which ultimately would be a lazy list of solutions, and a function that prints them as they become computed
15:35:38 <sm> that seems like libcryptO, but who knows.. gotta leave this yak unshaven
15:36:33 <monochrom> yes, just use lazy list and depth-first search
15:36:58 <kuraj> also i only want to do this with what GHCI provides (downloadable packages are a big no-no)
15:37:39 <ddarius> Luckily, you can implement a more than adequate logic monad with logic variables, unification, and backtracking in about half a page of code!
15:37:54 <kuraj> define half a page of code
15:39:12 <ddarius> kuraj: I implemented a (pure) Prolog interpreter several years ago.  The first cut, parser and all, was, I believe 83 lines.
15:39:16 <ddarius> wc -l lines
15:39:43 <Cale> That's a pretty specific number to remember ;)
15:39:44 <monochrom> > let once x = [x-3, x-2, x-1] in [ (a0, b0, a1, b1) | a0 <- once 30, b0 <- once a0, a1 <- once b0, b1 <- once a1 ]
15:39:45 <lambdabot>   [(27,24,21,18),(27,24,21,19),(27,24,21,20),(27,24,22,19),(27,24,22,20),(27,...
15:40:09 <monochrom> those are the list of all possible first two rounds of a game of nim
15:40:12 <edwardk> ddarius is nothing if not specific
15:42:41 <joe6> dcoutts:  your explanation makes sense. any suggestions on how I can build llvm to work?
15:42:41 <monochrom> a generalized and beefed-up version of that will exhaustively search for ways to win or lose
15:43:18 <dcoutts> joe6: don't use it in ghci, the static linking will work ok
15:43:36 <joe6> dcoutts: oh, use it with runghc? you mean?
15:43:43 <dcoutts> no, compile with ghc --make
15:43:49 <joe6> oh, ok.
15:43:56 <dcoutts> ghci and runghc use dynamic linking
15:44:24 <joe6> i want to explore some llvm functionality, and the ghci would be a great help, as I can find out what works and what does not.
15:44:31 <dcoutts> yeah, annoying
15:44:44 <dcoutts> it clearly used to work once, with an older LLVM release
15:44:59 <joe6> i am rebuilding the llvm-gcc from source, as on debian, it came packaged with llvm-2.7
15:45:13 <joe6> and I think that was confusing the llvm haskell binding to use the llvm-2.7
15:45:19 <dcoutts> if you ask me, it's pretty bonkers for llvm to have different stuff in its static libs vs the dynamic ones
15:45:24 <joe6> instead of the latest version 2.9 that it had.
15:45:35 <joe6> s/it/i/
15:45:37 <dcoutts> but it does, seems they don't really care about dynamic linking to llvm
15:46:22 <joe6> oh, ok. does that happen with --enable-shared option too?
15:46:33 <joe6> while building llv..
15:46:41 <joe6> s/llv/llvm
15:46:42 <dcoutts> --enable-shared on what?
15:47:50 * hackagebot xdg-basedir 0.2.1 - A basic implementation of the XDG Base Directory specification.  http://hackage.haskell.org/package/xdg-basedir-0.2.1 (WillDonnelly)
15:47:59 <joe6> dcoutts: like this, I mean: ./configure --prefix=/home/j/local/llvm --disable-optimized --enable-assertions --enable-shared && make && make install
15:49:33 <joe6> instead of installing the llvm binaries.
15:51:22 <edwardk> insight of the evening: Oleg's LogicT m = Codensity (GEndo m) where newtype GEndo m a = GEndo (m a -> m a)
15:51:26 <edwardk> it all comes back to Codensity ;)
15:51:57 <edwardk> also it is a nice example of codensity of something that is quite obviously NOT a haskell Functor.
15:52:50 <Axman6> > [x | x <- [1..50], 50 `rem` x == 0]
15:52:51 <lambdabot>   [1,2,5,10,25,50]
15:55:47 <ddarius> edwardk: GEndo = Endo1
15:57:23 <ddarius> What we need are varargs at the type level (plus kind products and kind polymorphism).  Let's just add kind classes.
15:59:27 <edwardk> ddarius: true nuff
16:04:13 <dcoutts> joe6: so --enable-shared on the llvm ./configure script just means that it builds and installs the LLVM.so
16:04:30 <dcoutts> joe6: which I was saying is the second class citizen
16:04:46 <joe6> oh, ok.
16:04:47 <dcoutts> joe6: without --enable-shared you only get the static libs
16:05:10 <joe6> and, they do not work.
16:05:14 <joe6> ok, got it.
16:05:18 <joe6> thanks.
16:05:18 <dcoutts> well, they're not complete
16:05:31 <joe6> sorry, the dynamic libs are not complete.
16:05:32 <dcoutts> so might work for some llvm progs, but not for the haskell binding
16:05:59 <joe6> is there anything I can do (such as building from source) or some such thing, that might help.
16:06:17 <dcoutts> file bugs with the llvm devs
16:06:22 <dcoutts> complain
16:28:48 <kuraj> is there a function that will apply a function over an n-th element with an n-th parameter of the second list?
16:29:21 <kuraj> i.e. function * [1,2,3,4] [6,5,4,3] = [6, 10, 12, 12]
16:29:35 <kuraj> function (*) that is
16:29:35 <cmccann> kuraj, zipWith?
16:29:53 <kuraj> -face palm-
16:29:53 <hpc> > zipWith (*) [1,2,3,4] [6,5,4,3]
16:29:54 <lambdabot>   [6,10,12,12]
16:29:55 <kuraj> thanks
16:29:59 <kuraj> :D
16:30:03 <hpc> zipWith is easy to forget
16:30:19 <kuraj> i used it on one of the first of my classes..
16:30:30 <shachaf> @hoogle (a -> b -> c) -> [a] -> [b] -> [c]
16:30:31 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
16:30:31 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
16:30:31 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
16:31:23 <parcs> > getZipList $ (*) <$> ZipList [1..4] <*> ZipList [4..8]
16:31:23 <lambdabot>   [4,10,18,28]
16:32:26 <kuraj> you see i forgot about zipwith but something was telling me that a function like this DOES exist in haskell
16:32:27 <kyagrd> anyone using hmatrix recently
16:32:39 <kuraj> over time i discovered it can do a lot of really fancy stuff with lists
16:32:50 <cmccann> kuraj, yeah, that happens to everyone :]
16:33:08 <kyagrd> It seems to fail since the C libraries of lapack and blas thing upgraded to 3.x version (at least in Debian unstable)
16:33:13 <cmccann> kuraj, that's why hoogle exists, really
16:33:49 <kuraj> i see... im afraid im not familiar with types enough so i'd stuggle with using it
16:34:29 <cmccann> kuraj, well, look at shachaf's query and how that describes using a function to combine lists of the types that match its arguments
16:34:41 <kuraj> heres what i came up with while trying to generate all placings of the ships on the board
16:35:04 <kuraj> since im afraid of monads (bear with me)
16:35:42 <kuraj> i just generated a list of all possible binary sequences of the length n (which is the amount of ships to place)
16:36:00 <cmccann> kyagrd, I did something with hmatrix just the other day
16:36:23 <kuraj> im going to zip it with a function that places a ship on the board, with 0 being vertically and 1 horizontally
16:37:15 <kuraj> now only to figure out how to replace a sublist of certain atoms in a list with the ship..
16:38:14 <kuraj> i'll probably end up using the do notation because im familliar with imperative programming... successfully defeating the sole purpose of writing it in haskell
16:38:23 <kuraj> >.<
16:39:28 <cmccann> kuraj, if you want to put a copy of your code on hpaste or something, often someone in here will be willing to give you advice
16:41:06 <kuraj> thank you, i'll be sure to do that if i get definitely stuck at some point :)
16:41:22 <kuraj> at this moment, it doesnt looks so bad
16:41:38 <cmccann> kuraj, fiar enough, it's just kind of difficult to give feedback for a rough description
16:42:00 <kuraj> oh bear with me i was just thinking aloud
16:42:01 <kuraj> sorry
16:42:28 <kuraj> btw i already noticed how something that takes up 300 lines of code in prolog roughly translates to 30
16:42:37 <kuraj> that's fairly relieving...
16:43:01 <cmccann> heh, I haven't used prolog in ages
16:43:10 <kuraj> its actually quite fun
16:43:21 <cmccann> so I recall, though I never really "got it" back then
16:43:25 <ddarius> Prolog is an atrocious language that everyone should learn.  Really, the logic programming community should move on to superior languages.
16:43:47 <kuraj> i never got it during the courses, only to learn it while doing my first assignment
16:44:04 <kuraj> because it was the first task that i was allowed to program the way I liked
16:44:07 <kuraj> and then i was like
16:44:12 <cmccann> ddarius, do superior logic programming languages exist, or are you asserting that they should be created?
16:44:12 <kuraj> "oh... so THAT'S how it works"
16:44:36 <hpc> my CS330 professor swears by it
16:44:44 <ddarius> cmccann: They exist, they just don't have nearly the support from the community or the implementation effort of extant Prolog implementations.
16:44:45 <hpc> even though it has no complement and no union
16:44:58 <ddarius> cmccann: A nice example, and one of the better supported ones, is lambdaProlog.
16:45:07 <cmccann> ddarius, ok, thanks
16:45:15 <kuraj> the issue with prolog is that there are many implementations of it
16:45:30 * cmccann will keep it in mind for whenever he gets around to messing with logic programming
16:45:56 <kuraj> and the community doesnt compare even to that of haskell's
16:45:59 <kuraj> i mean
16:46:03 <kuraj> just go to #prolog
16:46:25 <kuraj> you can call yourself lucky if you manage to talk to a non-idling person
16:46:28 <ddarius> The issue with Prolog is that it uses an impoverished logical basis and then pollutes that with impurities and questionable semantic choices.
16:47:48 <hpc> is there any use for '!' other than to do '!,fail'?
16:47:57 <cmccann> prolog is still a better logic language than GHC's type class instance selection, har har
16:48:11 <kuraj> um
16:48:28 <parcs> hpc:
16:48:35 <ddarius> http://dtai.cs.kuleuven.be/projects/ALP//newsletter/dec07/content/Articles/tom/content.html compares the LP and Haskell community, but unfortunately still advocates the LP communities death grip on Prolog.
16:48:37 <kuraj> you use ! if you're satisfied with an answer at this point and you dont want the predicate to return looking for more
16:48:50 <ddarius> hpc: Neck cuts are fine.
16:48:57 <parcs> i stopped reading The Art of Prolog after i arrived on the section on cuts
16:49:02 <parcs> i can't understand them, at all
16:49:11 <hpc> neck cuts?
16:49:26 <hpc> kuraj: that makes sense, ish
16:49:28 <parcs> whatever ! signifies
16:49:40 <kuraj> hold on a sec
16:49:46 <ddarius> @google "neck cut" "logic programming"
16:49:47 <lambdabot> http://cisnet.mit.edu/Logic-Programming-1995-International-Symposium/644
16:49:48 <kuraj> ill give you a real life example
16:49:49 <kuraj> :P
16:50:22 <hpc> ddarius: wants a cookie
16:50:36 <ddarius> I have no idea if it even says what I want.
16:50:48 <hpc> :P
16:51:49 <kuraj> nevermind
16:51:55 <hpc> judging from the definition of 'neck', 'neck cut' = "only if"?
16:52:11 <hpc> as in, p(x) if stuff, more stuff
16:52:31 <hpc> p(x) only if stuff, more stuff
16:52:45 <kuraj> all in all, most of the time i used cuts in prolog, was placing them in the very end of the predicate anyway
16:53:03 <kuraj> ive seen examples where you'd use it in the middle of one, but never understood why'd you want that
16:54:24 <othiym23> kuraj: to constrain the combinatorial explosion of terms
16:55:03 <kuraj> yeah thats pretty much what it is
16:56:23 <mightybyte> Is there any way to simulate a control-c on a haskell thread?
16:56:27 <othiym23> which is why it's called "cut" in the first place -- you're pruning branches off the problem space
16:56:32 <parcs> mightybyte: send a SIGINT ?
16:56:41 <mightybyte> ...from code I mean
16:57:41 <shachaf> Send a SIGINT from code?
16:58:19 <shachaf> Ctrl-C is generally sent to an OS thread, not to a Haskell thread.
16:58:35 <mightybyte> Hmmm
17:00:41 <HugoDaniel> why send a sigint when you can send a sigkill!
17:00:53 <mightybyte> I'm trying to create a unit test to test the behavior of the C-c handler.
17:05:19 <mightybyte> Aha.  http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception-Base.html#v:UserInterrupt
17:11:18 <gwern> woo, just finished reverse-engineering the Alexa toolbar
17:11:29 <gwern> one more archiving method for archiver bot
17:14:39 <hpaste> gwern pasted “alexa reverse engineering” at http://hpaste.org/48050
17:17:32 <Clint> can anyone tell me why http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot doesn't work?
17:18:04 <gwern> Clint: that's a seriously vague question
17:18:07 <aavogt> Clint: how not? It has worked for me in the past
17:18:56 <hpaste> Clint pasted “tutbot failure” at http://hpaste.org/48051
17:19:22 <Clint> the irc server doesn't seem to have received the commands
17:23:39 <aavogt> Clint: how long did you wait?
17:23:56 <Clint> aavogt: several minutes
17:24:13 <aavogt> mine connected within say 10 s
17:24:14 * hackagebot archiver 0.5 - Archive supplied URLs in WebCite & Internet Archive  http://hackage.haskell.org/package/archiver-0.5 (GwernBranwen)
17:24:56 <hpc> Clint: config problem perhaps
17:25:15 <Clint> config of what exactly?
17:25:18 <gwern> now all I need is a function to archvie stuff in Wikiwix, and I'll have the best archive program around
17:25:19 <hpc> double-check port number and hostname for typos
17:25:31 <Clint> hpc: it's definitely connecting to the irc server
17:25:38 <hpc> ah
17:25:40 <Clint> it's just not registering a nick
17:25:50 <Clint> .. or anything else
17:27:22 <aavogt> Clint: if I copy-paste the code right after "The monadic, stateful, exception-handling bot in all its glory: ", that one works
17:29:14 <Clint> aavogt: i have to switch around Control.OldException on that one, but it does the same thing
17:30:09 <Tyr42> Hello
17:30:50 <Tyr42> I'm getting some weird errors when trying to compile a program using Control.Parallel
17:31:11 <Tyr42> but it works (sortof) in ghci
17:31:40 <aavogt> Clint: one difference might be that the address the bot connects in my case should be the only irc client at that ip
17:31:54 <Clint> same here
17:31:54 <aavogt> Tyr42: did you use   ghc --make?
17:32:11 <hpaste> kuraj pasted “replace” at http://hpaste.org/48053
17:32:21 <hpc> aavogt: shouldn't be a problem, i think
17:32:48 <kuraj> here i have a piece of code that finds and replace any occurence of substring b to a substring c in string a
17:33:13 <kuraj> (i found it somewhere in the internet)
17:33:24 <parcs> ah, the internet.. you can never trust that place
17:33:28 <kuraj> what im actually trying to acheive is a function that will find and replace ONE occurence
17:33:55 <kuraj> so that with a list comprehension i'll get a list of all possible scenarios in which  the function finds and replaces one occurence of substring
17:34:09 <sprzybil1a> any idea why the vim package is 404'ing on me?
17:34:18 <kuraj> can i easily acheive that?
17:34:22 <hpc> kuraj: remove the recursive call from the 'then' case
17:34:31 <sprzybil1a> sorry wrong chan*
17:34:36 <hpc> instead of "replace blah quux", "blah"
17:35:15 <Tyr42> @ aavogt Thanks, that worked.  It really needs a better way of erroring out if I forget that
17:35:21 <hpc> right now the code says "replace this occurence, then replace ocurrences in the rest of the string"
17:35:33 <aavogt> Tyr42: supposedly that't the default for ghc now
17:35:44 <hpc> the change will make it say "replace this occurence; we changed one, so we can just leave the rest of the string alone"
17:36:02 <Tyr42> aavogt:  I just did a fresh install, and just apt-get-ed ghc
17:36:22 <Tyr42> aavogt:  Lazy, I know, but I just wanted to get it running right away
17:36:33 <kuraj> hpc: thanks, it almost works
17:37:39 <kuraj> now lets see
17:38:33 <hpc> kuraj: once you get it working, i strongly suggest internalizing it and then rewriting it; that snippet has horrendous style
17:38:46 <kuraj> i see
17:39:08 <kuraj> im actually stuck at how to make the list comprehension work
17:39:32 <kuraj> i guess ill probably need to rewrite this anyway
17:42:17 * hackagebot kit 0.7.6 - A dependency manager for Xcode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.7.6 (NickPartridge)
17:45:27 <Clint> so the N from NICK doesn't seem to make it into the tcp packet
17:48:13 <tekknolagi> what are some crazy things that haskell can do in one line that most other languages cannot?
17:48:36 <cmccann> avoid runtime errors?
17:48:38 <cmccann> har har har
17:48:49 <hpc> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
17:48:49 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:48:56 <tekknolagi> whoa........
17:49:00 <hpc> @quote fib
17:49:01 <lambdabot> ghc says: try_stub.o: unknown symbol `Safe_zdffibonaccizuhszuaM1_closure'
17:49:09 <hpc> @quote fibonacci
17:49:10 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
17:49:20 <kuraj> fst(2, 1 `div` 0)
17:49:26 <tekknolagi> what is lambdabot?
17:49:37 <hpc> @vixen what are you?
17:49:37 <lambdabot> yes, i am
17:49:37 <cmccann> my favorite silly example though is the n-fold cartesian product
17:49:42 <HugoDaniel> :)
17:49:46 <hpc> :)
17:49:48 <cmccann> > replicateM 3 [0,1]
17:49:49 <lambdabot>   [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
17:50:11 <tekknolagi> > replicateM 6 [0, 1, 2]
17:50:11 <ozataman> I keep getting "unknown symbol ...." errors when doing cabal install on a package that uses another package with FFI bindings when TH kicks in to process one of the modules. I tried --extra-include-dirs, --extra-lib-dirs and this only happens on a ubuntu 64-bit box.. I'm really out of steam - any thoughts?
17:50:12 <lambdabot>   [[0,0,0,0,0,0],[0,0,0,0,0,1],[0,0,0,0,0,2],[0,0,0,0,1,0],[0,0,0,0,1,1],[0,0...
17:50:13 <kuraj> oh
17:50:17 <kuraj> you put a > there
17:50:18 <tekknolagi> > replicateM 6 [0, 1]
17:50:18 <hpc> :t filter
17:50:19 <lambdabot>   [[0,0,0,0,0,0],[0,0,0,0,0,1],[0,0,0,0,1,0],[0,0,0,0,1,1],[0,0,0,1,0,0],[0,0...
17:50:19 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
17:50:22 <hpc> :t filterM
17:50:23 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
17:50:23 <Favonia> tekknolagi: a IRC bot with built-in Haskell evaluator and beyond
17:50:24 <kuraj> > fst (2, 1 `div` 0)
17:50:24 <lambdabot>   2
17:50:30 <tekknolagi> neat!
17:50:35 <cmccann> closely related is the power set with filterM that I think hpc is about to do :P
17:50:38 <tekknolagi> how does one join characters in an array?
17:50:49 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in primes
17:50:50 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
17:50:51 <tekknolagi> like ['0', '1', '0'] -> "010"
17:50:53 <kuraj> the ++ operator stands for concatenation
17:50:58 <kuraj> oh
17:51:03 <azaq23> > ['0', '1'] == "01"
17:51:04 <lambdabot>   True
17:51:04 <Eduard_Munteanu> @yarr
17:51:04 <lambdabot> Aye
17:51:05 <kuraj> arent those equivalent?
17:51:08 <hpc> @quote filterM
17:51:08 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
17:51:12 <okaythen2> Does haskell have a library function called "unPr"?
17:51:16 <hpc> damn, and i forget how to do it
17:51:29 <tekknolagi> azaq23: i meant printing wise
17:51:38 <Tyr42> okaythen2: Try hoogle
17:51:49 <okaythen2> thanks. .com?
17:51:51 <Eduard_Munteanu> Or hayoo
17:51:55 <Eduard_Munteanu> @hoogle unPr
17:51:56 <lambdabot> No results found
17:51:57 <Cale> okaythen2: Not in the libraries I know about, but if I was to guess, it would be an unwrapper for a newtype called Pr
17:52:03 <Eduard_Munteanu> Yeah, try hoogle or hayoo online
17:52:12 <kuraj> hpc, how does my function have to be defined to make the list comprehension work? i do get why it doesnt work with the current one but i have no idea how to fix it
17:52:23 <Eduard_Munteanu> @google hayoo
17:52:24 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
17:52:24 <lambdabot> Title: Hayoo! - Haskell API Search
17:52:29 <okaythen2> this is where i'm seeing it http://contracts.scheming.org/
17:52:35 <Cale> kuraj: Is your code pasted somewhere?
17:52:45 <azaq23> tekknolagi: A list of characters is a string, there is not difference. In other words, type String = [Char]. You can do "putStrLn ['0', '1']"
17:53:20 <hpc> kuraj: remind me what you wanted the comprehension to do?
17:53:35 <Eduard_Munteanu>  newtype PR a = PR { unPr :: [RV a] } deriving Show
17:53:37 <okaythen2> ah! it is an array index
17:53:40 <Eduard_Munteanu> It's on that page.
17:53:54 <kuraj> return a list of ways one can replace an instance of substring a inside string b
17:54:09 <Cale> okaythen2: I was right, it's a newtype unwrapper
17:54:21 <Cale> okaythen2: unPr :: PR a -> [RV a]
17:54:24 <kuraj> i.e. [1,0,0,1] 0 2 = [[1,2,0,1], [1,0,2,1]]
17:54:57 <okaythen2> hmmm, is that def in the paper?
17:54:59 <Cale> kuraj: substring or element?
17:55:01 <hpc> kuraj: ah, that sounds beyond the powers of comprehensions
17:55:09 <Cale> kuraj: because that looks like replacing elements
17:55:12 <Eduard_Munteanu> okaythen2: yes, below its first occurence though
17:55:25 <Cale> (which is far simpler)
17:55:35 <kuraj> ok this was a bad example - a substring actually: or "abbbba" "bb" "cc" = ["accbba", "abccba", "abbcca"]
17:55:50 <Cale> kuraj: okay
17:56:30 <Cale> Probably the best way is to start by forming all splits of the string into two parts.
17:57:05 <kuraj> if i design the stirng to work on strings will it always work on lists of other elements? e.g. tuples
17:57:15 <kuraj> like
17:57:21 <Cale> Well, as long as you don't specifically work with characters, and you use the list syntax :)
17:57:29 <kuraj> list syntax yes
17:57:53 <tekknolagi> > join [1, 2, 3]
17:57:53 <lambdabot>   No instance for (GHC.Num.Num [a])
17:57:54 <lambdabot>    arising from a use of `e_1123' at <int...
17:58:00 <tekknolagi> > join [1', '2', '3']
17:58:01 <lambdabot>   <no location info>:
17:58:01 <lambdabot>      lexical error in string/character literal at chara...
17:58:05 <tekknolagi> > join ['1', '2', '3']
17:58:05 <lambdabot>   Couldn't match expected type `[a]'
17:58:06 <lambdabot>         against inferred type `GHC.Types...
17:58:16 <okaythen2> so the type PR a is a structure with only one element, unPr, correct?
17:58:16 <tekknolagi> > :t join
17:58:17 <lambdabot>   <no location info>: parse error on input `:'
17:58:21 <kuraj> so that would be [1,2,3,4,5] [3] [("a", 1)] = [1,2, ("a", 1) ,4,5]
17:58:40 <kuraj> ^ not sure if second argument should be 3 or [3]
17:58:47 <kuraj> but eiher way
17:59:07 <kuraj> what i really want to is to place these ships (which are lists of tuples) into a list which contains 0's
17:59:23 <kuraj> one after another, and in a way so they dont overlap
17:59:24 <Tyr42> What's the best way to parallelize a filter ... $ map ...?
17:59:33 <Cale> splits [] = [([],[])]
17:59:34 <Cale> splits (x:xs) = ([],x:xs) : [(x:us,vs) | (us,vs) <- splits xs]
17:59:39 <kuraj> so using a list comprehension i would be able to get all possible configs
17:59:44 <Cale> ^^ start with this
17:59:56 <Cale> Which gives you all ways to cut the string into two parts
17:59:58 <kuraj> lets see
18:00:14 <Cale> Next, we'll look to see if the second part has an initial prefix that matches what we want to replace
18:00:14 <tekknolagi> how would i import the module `Data.List.Utils` ?
18:00:21 <tekknolagi> or load it, or whichever
18:00:26 <Cale> (using isPrefixOf, perhaps)
18:00:33 <kuraj> OHHHHH
18:00:35 <kuraj> i get the concept behind this
18:00:54 <kuraj> thats pretty much what i used to determine substrings in prolog
18:01:12 <tekknolagi> > :find join
18:01:12 <lambdabot>   <no location info>: parse error on input `:'
18:01:17 <Tyr42> I'm trying with Control.Parallel, but it's running out of stack space
18:01:39 <tekknolagi> can somone help with the module loading deal?
18:01:58 <Cale> Tyr42: Is the list you're filtering through formed in a fashion where later elements are constructed from previous ones?
18:02:06 <parcs> :load Qualified.Module.Name
18:02:16 <parcs> err, :module *
18:02:30 <Tyr42> Cale:  Nope, just a straight map
18:02:51 <parcs> tekknolagi: actually, :module + Data.List.Utils
18:02:55 <tekknolagi> parcs: nah, when I try to load "Data.List.Utils" it cannot find the module, and fails
18:02:55 <tekknolagi> oh
18:03:07 <Tyr42> Cale: Well, with a generating function that enumerates a list at the start of the pipeline
18:03:15 <Cale> Tyr42: Stack overflows generally indicate that a large expression built up from strict functions is being reduced all at once. The stack consists of case expressions (or other pattern matches) which are waiting for their scrutinee to be sufficiently evaluated to pattern match.
18:03:30 <tekknolagi> parcs: it doesn't work
18:03:35 <Cale> If you have something like   iterate f x
18:03:39 <Cale> and you parMap on that
18:03:41 <azaq23> :t join -- tekknolagi
18:03:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
18:03:57 <tekknolagi> azaq23: not in scope
18:04:30 <tekknolagi> what am i doing wrong?
18:04:31 <Cale> then there's a possibility that the elements won't be evaluated in order, and (theoretically, though this is a bad practical example) the first one to evaluate might be quite large
18:05:03 <azaq23> tekknolagi: You're searching for a list joining function like "".join() in python. "join" is not such a function, but a function from Control.Monad and not connected to list joining things
18:05:22 <azaq23> tekknolagi: Also, as I already stated, "01" is nothing different but ['0', '1']
18:05:33 <Cale> That is, the first one to evaluate might be f (f (f (f (f ... (f x)...)))), and it won't have been previously reduced to something manageable because the earlier elements in the list which are parts of it won't have been reduced yet
18:05:38 <hpaste> Tyr pasted “Parallel md5 brute force” at http://hpaste.org/48057
18:05:38 <tekknolagi> azaq23: exactly. how would I print it `joined` though?
18:05:50 <Tyr42> Cale:  It's that
18:06:18 <Tyr42> should output "password"
18:07:09 <azaq23> tekknolagi: You print a list of characters like you would do any strings. I don't see your problem. Do you really seek a function to join a list of *strings* into one string? Then, there is intercalate (which is like bla.join() in python)
18:07:18 <azaq23> > intercalate ", " ["a", "b", "c"]
18:07:18 <tekknolagi> oh
18:07:19 <lambdabot>   "a, b, c"
18:07:33 <Cale> Tyr42: what package is Data.Hash.MD5 in?
18:07:35 <azaq23> intercalate is part of Data.List
18:07:35 <tekknolagi> > intercalate "" ["a", "b", "c"]
18:07:36 <lambdabot>   "abc"
18:07:49 <azaq23> Yet, each "a" is actually ['a']
18:07:58 <Tyr42> MissingH
18:08:18 <Tyr42> but that's big
18:08:26 <Eduard_Munteanu> > concat ["a", "b", "c"]
18:08:27 <lambdabot>   "abc"
18:08:35 <Eduard_Munteanu> > join ["a", "b", "c"]
18:08:35 <lambdabot>   "abc"
18:08:42 <Eduard_Munteanu> :t join
18:08:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
18:08:54 <Cale> Yeah, that's okay, it's only a cabal-install away :)
18:09:11 <Eduard_Munteanu> (for the bigger picture :D)
18:09:44 <Cale> I think you pasted a half-edited version of your file though.
18:09:51 <Tyr42> It works with map instead of (parMap rseseq)
18:10:16 <tekknolagi> currently i have: https://gist.github.com/a7b5bfbb31a8980f65a7 in a file. when i try to run it with `runghc` it fails with `not in scope`. why?
18:10:19 <Tyr42> Cale: I just copy and pasted from my gvim, which as working...
18:10:51 <Eduard_Munteanu> @index replicateM
18:10:52 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
18:11:00 <parcs> @where lyah
18:11:00 <lambdabot> http://www.learnyouahaskell.com/
18:11:25 <Eduard_Munteanu> :)
18:12:06 <Tyr42> lyah needs a chapter on parallelism
18:12:33 <kuraj> Cale: [ ys | ys <- splits[1,2,3,4], isPrefixOf [2,3] (snd ys) ]
18:13:26 <azaq23> tekknolagi: intercalate is in Data.List, you have to import Data.List. Also, you don't understand haskell monadic IO and you don't use the main "string printing" function (putStrLn, which has the type String -> IO ()). You should read "learn you a haskell".
18:13:50 <parcs> tekknolagi: you must import the module Control.Monad
18:14:33 <kuraj> Cale: I think I know what I want to do now - hold on
18:15:30 <tekknolagi> thank you!
18:16:16 <napping> it might be better to get expressions working in ghci.
18:16:16 <lambdabot> napping: You have 2 new messages. '/msg lambdabot @messages' to read them.
18:16:21 <Cale> Tyr42: answer size chars hash = take 1 . filter (((== hash).fst)) . withStrategy (parListChunk 10 rdeepseq) . (map (\x -> (md5s $ Str x, x))) $ guesses size chars
18:16:31 <Cale> Tyr42: That was successful on my machine
18:16:59 <Tyr42> Cale:  Thanks
18:17:21 * hackagebot HsOpenSSL 0.9.0.1 - (Incomplete) OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.9.0.1 (MasatakeDaimon)
18:17:42 <Cale> It'll take some experimentation to see if it's actually faster :)
18:17:48 <Cale> But it works
18:18:12 <Eduard_Munteanu> Bah, DPH must arrive someday
18:18:44 <Cale> ah, parListChunk 1000 rdeepseq
18:18:47 <Cale> muuuuch better
18:18:52 <Tyr42> ok
18:19:20 <Tyr42> and +RTS -T2 -RTS, right?
18:19:27 <Cale> You have to make the chunks large enough to make up for the scheduling overhead
18:19:35 <Cale> -N4 on my machine... what's T?
18:19:39 <Tyr42> N
18:19:40 <Tyr42> ok
18:19:59 <Cale> Also, you can leave off the -RTS if you want
18:20:03 <dankna> wow, I'm getting a segfault in pure Haskell code :(
18:20:13 <Cale> (since you're not going to put more normal options after)
18:20:24 <Cale> dankna: That sucks
18:20:26 <tekknolagi> how do i send/receive lambdabot messages?
18:20:29 <Cale> dankna: How is that happening?
18:20:34 <dankna> (it deals with arrays, which I imagine are the culprit.  also I'm on an old version of HEAD.)
18:20:42 <Eduard_Munteanu> Using a higher than CPU/core N might be a bit better, say +1
18:20:43 <Cale> tekknolagi: You can "/query lambdabot" in most IRC clients
18:20:43 <dankna> I'm not sure quite how it's happening, unfortunately
18:20:55 <Cale> tekknolagi: to open a window or tab for talking to lambdabot
18:21:13 <Tyr42> Cale:  Do I need an option when compiling to have -N work, or do I just need to update GHC?
18:21:26 <Cale> tekknolagi: Otherwise, lambdabot will just respond here to various commands starting with @ as well as any line starting with "> "
18:21:30 <tekknolagi> Cale: is there a help page for commands?
18:21:36 <Cale> -rtsopts -threaded
18:21:46 <Cale> ghc -rtsopts -O2 -threaded --make md5
18:21:51 <Cale> is how I compiled it
18:21:54 <Eduard_Munteanu> (assuming GHC spawns as many real threads as you tell it to)
18:22:10 <Cale> I don't know what this -rtsopts thing is, but it seems to be required in newer GHCs
18:22:18 <azaq23> tekknolagi: @list lists commands, @help <command> is more specific
18:22:23 <Cale> (it's very irritating, if you ask me, that it's not the default anymore)
18:22:26 <tekknolagi> thanks
18:22:34 <dankna> Cale: because responding to +RTS options is a security hole
18:22:41 <Tyr42> "ghc: unrecognised flags: -rtsopts"?
18:22:42 <dankna> Cale: so there's three modes, off, on, and "safe"
18:22:42 <Cale> How so?
18:23:12 <dankna> Cale: well, you could change the program's behavior with them
18:23:21 <dankna> Cale: I don't have a specific exploit but for anything setuid that's just a red flag
18:23:29 <Cale> RTS options can't let the program do things which the user who is running the program can't do
18:23:36 <dankna> unless the program is setuid
18:23:36 <Cale> hm
18:23:42 <Eduard_Munteanu> Ha!
18:23:48 <Cale> That's still pretty rare
18:24:03 <dankna> okay, but you get to be the one who explains "sorry, GHC is not designed for writing setuid programs" to people
18:24:07 <Eduard_Munteanu> I think there is a distro which uses Haskell scripts.
18:24:18 * Eduard_Munteanu was about to mention it
18:24:27 <Cale> I'd figure people who want to write setuid programs wouldn't mind setting an extra option to turn off RTS flags
18:24:37 <Eduard_Munteanu> Yeah.
18:24:39 <Cale> It's just annoying for 99.9% of the users
18:24:45 <dankna> it's just that it's the default behavior that is scary - it makes people think "hmm, what other traps are lurking here"
18:24:59 <dankna> and then they go write their program in C instead
18:25:00 <Cale> I don't see it as scary
18:25:09 <dankna> you're not in security, obviously :)
18:25:16 <Cale> Let's suppose you give me a setuid program which gives me RTS options
18:25:19 <parcs> tekknolagi:@list
18:25:19 <dmwit> C has null-terminated strings by default, ... and there's no compiler option to turn them off.
18:25:21 <Cale> what's the worst that I can do?
18:25:35 <dmwit> What kind of traps is it, exactly, that you think you're avoiding by using C?
18:25:42 <kuraj> Cale: do you own a gun?
18:25:45 <dankna> dmwit: I agree completely that using C gives a false sense of security, but I'm explaining the psychology, not justifying it!
18:25:52 <c_wraith> Cale: write profiler output over /etc/passwd
18:26:00 <Cale> OH SHIT I CAN CHANGE THE NUMBER OF GARBAGE COLLECTOR GENERATIONS
18:26:09 <dankna> that's true, the RTS opts let you write to any file
18:26:13 <dankna> by redirecting the profiler output
18:26:29 <Cale> Oh, I guess that's pretty fun.
18:26:49 <Cale> But disabling -N and such?
18:26:53 <Cale> Is it really necessary?
18:26:53 <c_wraith> There are some legit issues with setuid haskell programs and arbitrary rtsopts enabled. :)
18:27:25 <dankna> the point is that to add more safe options to the whitelist would require work that nobody has thus-far stepped up to do
18:27:36 <Eduard_Munteanu> Cale: I guess GHC should attempt to guess threading options, btw.
18:27:45 <dmwit> Yeah, it really should.
18:27:54 <parcs> doesn't it?
18:28:32 <Cale> Well, if you run with +RTS -N
18:28:36 <Cale> it tries to guess
18:28:45 <cmccann> Cale, I think this is the ticket in question BTW: http://hackage.haskell.org/trac/ghc/ticket/3910
18:30:05 <parcs> yeah, that's what i was referring to. i remember reading that ghc implicitly runs programs with -N, now
18:31:42 <gfarfl> o
18:31:44 <gfarfl> oops
18:32:07 <parcs> nope, i'm wrong
18:32:53 <tekknolagi> hmm
18:33:02 <kuraj> is there a function for chopping n characters off the beginning of a string?
18:33:13 <ClaudiusMaximus> i fix that "oops i forgot +RTS -N -RTS" by linking with char *ghc_rts_opts = "-N";
18:33:15 <tekknolagi> parcs: in lyah, there's one bit where it says `lucky :: (Integral a) => a -> String` - what does that do/mean?
18:33:22 <tekknolagi> kuraj: init, right?
18:33:22 <gfarfl> kuraj: drop
18:33:26 <tekknolagi> oh
18:33:26 <cmccann> > drop 2 "abcd"
18:33:27 <lambdabot>   "cd"
18:33:33 <kuraj> great, thank you!
18:33:37 <tekknolagi> > init 2 "abcd"
18:33:38 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
18:33:38 <lambdabot>         against inferr...
18:33:51 <tekknolagi> oh that's not haskell.
18:33:56 <tekknolagi> parcs: in lyah, there's one bit where it says `lucky :: (Integral a) => a -> String` - what does that do/mean?
18:34:34 <dmwit> tekknolagi: That is a type declaration.
18:34:41 <azaq23> @src init
18:34:42 <lambdabot> init [x]    = []
18:34:42 <lambdabot> init (x:xs) = x : init xs
18:34:42 <lambdabot> init []     = undefined
18:34:54 <dmwit> It says that the variable "lucky" knows how to turn any Integral type into a String.
18:35:00 <tekknolagi> azaq23: that was a different language, sorry and
18:35:19 <tekknolagi> dmwit: is it necessary in a function declaration?
18:35:35 <tekknolagi> > lucky :: (Integral a) => a -> String
18:35:36 <lambdabot>   Not in scope: `lucky'
18:35:40 <dmwit> tekknolagi: No, you do not need type declarations.
18:35:47 <azaq23> tekknolagi: It is actually a related function. init is like tail, but the other way round - it chops of the last character of a list
18:35:47 <tekknolagi> dmwit: thank you
18:35:50 <azaq23> > init "013"
18:35:51 <lambdabot>   "01"
18:35:57 <kuraj> Cale: look what I made: replace string suba subb = zipWith (++) (map fst (splitBefore suba string)) (map (subb ++) (map (drop (length suba)) (map snd (splitBefore suba string))))
18:36:07 <dmwit> > let lucky :: (Integral a) => a -> String; lucky = undefined in 3 -- tekknolagi, this is how to declare variables for use in lambdabot
18:36:08 <lambdabot>   3
18:36:17 <tekknolagi> oh......
18:36:17 <kuraj> i am aware that this can be improved by use of the $ operator, gonna do it in a sec
18:36:25 <kuraj> but it works as expected :)
18:36:55 <Cale> kuraj: You should use let or where to define  splitBefore suba string  so that it's not computed twice
18:37:30 <tekknolagi> > let charName :: Char -> String
18:37:31 <dmwit> :t unzip
18:37:31 <lambdabot>   not an expression: `let charName :: Char -> String'
18:37:32 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
18:38:00 <tekknolagi> > let charName :: Char -> String; charName 'a' = Albert
18:38:00 <lambdabot>   not an expression: `let charName :: Char -> String; charName 'a' = Albert'
18:38:04 <tekknolagi> > let charName :: Char -> String; charName 'a' = Albert in 1
18:38:04 <lambdabot>   Not in scope: data constructor `Albert'
18:38:11 <tekknolagi> > let charName :: Char -> String; charName 'a' = 'Albert' in 1
18:38:12 <lambdabot>   <no location info>:
18:38:12 <lambdabot>      lexical error in string/character literal at chara...
18:38:20 <dmwit> "let (fsts, snds) = unzip (splitBefore suba string)" is better than "map fst (splitBefore suba string)" and "map snd (splitBefore suba string)". ;-)
18:38:24 <tekknolagi> > let charName :: Char -> String; charName 'a' = "Albert" in 1
18:38:25 <lambdabot>   1
18:38:31 <tekknolagi> > let charName :: Char -> String; charName 'a' = "Albert" in 'a'
18:38:31 <lambdabot>   'a'
18:38:36 <tekknolagi> > let charName :: Char -> String; charName 'a' = "Albert"
18:38:37 <lambdabot>   not an expression: `let charName :: Char -> String; charName 'a' = "Albert"'
18:38:50 <dmwit> tekknolagi: Do you mean "... in charName 'a'"?
18:39:03 <tekknolagi> > let charName :: Char -> String; charName 'a' = "Albert" in charName 'a'
18:39:04 <lambdabot>   "Albert"
18:39:06 <tekknolagi> yeah
18:39:07 <tekknolagi> thanks
18:42:30 <kuraj> Cale: thanks, done... dude. if i had this piece of code given by someone else to determine what it actually does, i'd shoot myself
18:43:55 <monochrom> that's illegal
18:43:55 <dmwit> kuraj: There's a few ways to help the readability a lot.
18:44:05 <dmwit> For example, here's a law: map f . map g = map (f . g)
18:44:18 <Cale> kuraj: Well, you can always break it into smaller pieces to make it easier to understand
18:44:47 <joe6> any suggestions on this error, please:  http://sprunge.us/ZGSP
18:44:47 <dmwit> (Though in your case, I would rather write that law as "map f (map g (map h xs)) = map (f . g . h) xs" to make it more obvious where you can apply it. =)
18:45:01 <joe6> setup: internal error: unexpected package db stack: [UserPackageDB]
18:45:04 <dmwit> kuraj: Also, my unzip suggestion from before (in case you missed it.)
18:45:06 <joe6> is the error
18:46:05 <monochrom> oh, right, map (blahblah . blahblah . blahblah . blahblah) is better
18:47:27 <dmwit> Dunno whether you're being sarcastic or not, but I find "map (\(s1, s2) -> subb ++ drop (length suba) s2)" much more readable than "map (subb ++) (map (drop (length suba)) (map snd ...))".
18:47:52 <monochrom> you can also use various line breaks and indentation tricks to clarify
18:47:54 * lispy agrees with dmwit 
18:48:09 <monochrom> I am not sarcastic
18:48:10 <lispy> (not that my opinion matters)
18:50:19 <danharaj> So uhh, anyone have a favorite implementation of a balanced binary search tree?
18:50:42 <dmwit> Data.Map.Map ?
18:50:43 <monochrom> Data.Map is my favourite. or Data.Set
18:50:47 <Cale> danharaj: Did you look into finger trees for what we were talking about earlier?
18:51:02 <dmwit> danharaj: Okasaki also discusses red-black trees in his book.
18:51:21 <danharaj> Cale: Yeah. I read the paper on finger trees by Hinze, and he notes that using finger trees tend not to perform as well as specialized search trees.
18:51:27 <kuraj> dmwit: thanks, i did
18:51:40 <danharaj> I suppose I could use Data.Map with unit values?
18:51:44 <danharaj> That feels kludgy :p
18:51:45 <Cale> danharaj: Well, okay, but they tend to get very acceptable performance.
18:52:14 <kuraj> the funny thing is that the person who will be grading these doesnt even know haskell well
18:52:14 <danharaj> Cale: To be honest, I'm not too worried about performance, but I am worried about memory consumption if that changes anything.
18:52:45 <kuraj> he just puts the algorithm to tests and verifies whether it works correctly and performs in a reasonable time
18:53:03 <monochrom> that is the best grader ever
18:53:18 <danharaj> Looks like he's got his priorities straight.
18:53:37 <dmwit> danharaj: A Data.Map.Map with () values is essentially a Data.Set.Set.
18:53:45 <dmwit> ...but less performant in terms of memory.
18:53:50 <monochrom> but there is an even better grader. on top of those two, measure program size, shorter is better
18:54:15 <dankna> no, don't you know anything about grading?  closer to the mean is better :)
18:54:19 <danharaj> dmwit: That's true. I'm thinking about how I want to handle Eq cases for my particular problem.
18:54:49 <monochrom> and my "program size" means number of tokens so as not to discriminate against longer identifiers or more whitespaces
18:54:54 <dankna> fair
18:54:55 <Cale> lol, don't even run the programs, just compute the mean length and give grades based on the distance from it
18:58:09 <joe6> any suggestions on how I can go about fixing this error:
18:58:11 <joe6> Registering llvm-0.9.1.2...
18:58:11 <joe6> setup: internal error: unexpected package db stack: [UserPackageDB]
18:58:18 <monochrom> it is an approximation for "a system so simple it obviously has no error" vs "a system so complicated it has no obvious errors". you could accomplish the same pass-all-tests and performs-well by either being smart about it or keeping adding kludges. token count distinguishes them
19:02:57 <Cale> joe6: dcoutts should be able to tell you what that means
19:03:13 <Cale> preflex: seen dcoutts
19:03:13 <preflex>  dcoutts was last seen on #haskell 2 hours, 56 minutes and 54 seconds ago, saying: complain
19:05:30 <Cale> joe6: It does sound like maybe something got messed up with your cabal/ghc packages
19:06:32 <joe6> Cale, oh, ok.
19:06:43 <joe6> everything else seems to install fine.
19:07:19 <joe6> it is just the latest git version of llvm
19:09:58 <parcs> > let f = \x -> f x in f x
19:10:00 <parcs> > let f = \x -> f x in f 2
19:10:02 <lambdabot>   mueval-core: Time limit exceeded
19:10:04 <lambdabot>   mueval-core: Time limit exceeded
19:19:41 <Cale> joe6: hum, I don't really know
19:21:37 <fryguybob> joe6: That looks like the issue I run into with gtk2hs
19:21:38 <fryguybob> http://hackage.haskell.org/trac/gtk2hs/ticket/1203
19:21:55 <joe6> Cale, ok, thanks.
19:21:55 <joe6> is it ok to run multiple cabal commands? (install in a different terminal)
19:22:55 <fryguybob> You could try editing the Setup.hs to match the last code in that link.
19:22:59 <joe6> fryguybob: i did check out your fix when I googled on the error. This issue seems to be different
19:22:59 <joe6> though, could be related
19:23:08 <joe6> I checked out the Setup.hs, but it has different code than what you have.
19:24:07 <joe6> let me try what you had exactly.
19:24:07 <fryguybob> This code is what I'm refering too: https://github.com/bos/llvm/blob/master/Setup.hs#L108-110
19:24:17 <joe6> I thought I did something differently.
19:25:09 <joe6> oh, ok. I was looking at the otherwise clause
19:25:57 <fryguybob> packageDb = nub $ withPackageDB lbi ++ maybeToList (flagToMaybe  (regPackageDB regFlags))  -- might work.
19:27:30 <joe6> ok, thanks. will try this.
19:34:46 <kuraj> i made a terrible good
19:34:48 <kuraj> goof*
19:36:02 <Peaker> if listToMaybe should have been "head", then maybeToList is "unhead"? :)
19:36:22 <monochrom> heh
19:36:38 <kuraj> i wrote a function that can effectively display all the ways it can replace a certain substrings with another one... but i forgot that i have a LIST of lists, not a single list...
19:36:46 <kuraj> which means
19:36:46 <dons_> ebyaMoTsil ?
19:36:50 <dons_> in the style of cons
19:36:55 <dons_> and snoc
19:37:25 <monochrom> ebayMobile
19:38:47 <Peaker> but snoc is (sort of) a flipped cons
19:38:55 <kuraj> doing replace [ [0,0,0,0], [0,0,0,0] ] [0, 0] [a, a] would return [ [ [a, a, 0, 0], [0, 0, 0, 0] ], [ [0, a, a, 0], [0, 0, 0, 0] ], [ [0, 0, a, a], [0, 0, 0, 0] ], [ [0, 0, 0, 0], [a, a, 0, 0] ], [ [0, 0, 0, 0], [0, a, a, 0] ], [ [0, 0, 0, 0], [0, 0, a, a] ] ]
19:39:09 <kuraj> i cant simply flatten the list of lists and then unflat it again
19:39:21 <Peaker> @type (map . map)
19:39:22 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
19:39:30 <Peaker> kuraj: do you want something like that ^^ ?
19:39:38 <kuraj> because i dont want results like [0, 0, 0, a] [a, 0, 0, 0]
19:39:50 <kuraj> oh
19:39:51 <kuraj> hmm
19:39:54 <kuraj> let me see.
19:40:02 <Cale> It's not quite the same...
19:40:13 <Cale> You want a list of all ways to apply the function to one of the list elements
19:41:20 <kuraj> you see how i have this grid which is actually a list of lists, i need to have a list of all ways i can put a ship (horizontally) in it
19:41:21 <kuraj> so yes
19:41:36 <kuraj> i'd need to extend what i wrote to a list of lists, instead of a single list
19:41:37 <bfig> hey. i'm getting an error "ambiguous use of operator "(==)" with "(==)" "
19:41:56 <dmwit> > True == True == True
19:41:57 <lambdabot>   Precedence parsing error
19:41:57 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
19:42:02 <kuraj> except that i dont know if i can actually "extend" what i wrote
19:42:05 <dmwit> > (True == True) == True
19:42:06 <kuraj> :-(
19:42:06 <lambdabot>   True
19:42:23 <dmwit> bfig: Paste the source somewhere and link us. =)
19:42:44 <sully> Peaker: ITYM fmap fmap fmap
19:43:15 <kuraj> unless..
19:43:35 <kuraj> i could use the split to define another function in a similar fashion and then embed one into another
19:43:41 <Cale> kuraj: I think what you're trying to do isn't really very well-suited to lists
19:43:47 <bfig> semiparse n m s xs = findstring n (take m xs) (drop m xs)
19:44:11 <kuraj> Cale: this is the best I can do :/
19:44:12 <Cale> kuraj: A Data.Map from integer pairs to contents would make a lot more sense.
19:44:13 <bfig> dmwit, that's the line of code where it fails
19:44:34 <Cale> kuraj: But I guess if Data.Map is still intimidating, go ahead :)
19:44:43 <bfig> wait no, that is not the line
19:44:44 <Cale> kuraj: It's good practice anyway
19:44:54 <bfig> let me check again and i'll post back if there is a problem
19:45:07 <kuraj> i guess
19:45:24 <kuraj> you should know that i really appreciate you guys' help
19:46:11 <bfig> dmwit, nevermind, a couple parenthesis solved it
19:47:56 <Peaker> sully: I prefer the SEC style
19:48:09 <sully> SEC?
19:48:22 <dmwit> ?where sec
19:48:22 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
19:48:35 * sully was joking, in any case
19:51:30 <bfig> what's the problem here when $$ is replaced by (length xs): ($$ == 3) and ($$ == 3). i get type mismatch: f->f->Bool vs a->b->c->d->e
19:52:11 <monqy> :t and
19:52:11 <dmwit> I'm not sure I understand the question.
19:52:12 <lambdabot> [Bool] -> Bool
19:52:41 <dmwit> Is your question: What is wrong with "(length xs == 3) and (length xs == 3)"?
19:52:41 <bfig> mmm weird. thought it was Bool->Bool->Bool
19:52:46 <dmwit> :t (&&)
19:52:47 <lambdabot> Bool -> Bool -> Bool
19:52:47 <bfig> dmwit, yes
19:52:55 <bfig> ok, thanks
19:56:28 <Cale> bfig: That means to take the function (length xs == 3) and apply it to the parameters (and) and (length xs == 3)
19:56:39 <Cale> but (length xs == 3) isn't a function, so that's a problem
19:57:20 <bfig> of course once the matter of and vs && is clarified the question doesn't make much sense
19:58:00 <dmwit> Even if "and" had the type you thought it had, what you wrote was still wrong.
19:58:04 <dmwit> That's what Cale is trying to tell you.
19:58:05 <Cale> You can use functions whose names are composed of letters as infix operators, but you need to enclose them in `backticks`, but yeah, and isn't the function you want here.
19:59:19 <bfig> Cale, i remembered this in particular was defined in infix form
19:59:26 <bfig> obviously not and but &&
19:59:49 <dmwit> (&&) is not composed of letters, and so doesn't need backticks.
19:59:56 <Cale> Yeah, infix functions are distinguished by having names composed of symbol characters
20:02:17 <Peaker> Agda mixfix could have removed this point of confusion (and add one about spacing!)
20:03:17 <bfig> isn't that just a convention?
20:03:43 <dmwit> Isn't what a convention?
20:03:57 <dmwit> Infix functions being symbol characters and prefix functions being letter characters?
20:03:58 <bfig> letterness of infix operator
20:04:01 <dmwit> No.
20:04:02 <othiym23> nope
20:04:15 <dmwit> It's part of Haskell's grammar.
20:04:40 <dmwit> "a `f` b" and "a f b" parse differently; "a (&) b" and "a & b" parse differently.
20:05:31 <bfig> i got confused by the infix keywords
20:05:50 <joe6> fryguybob: your fix worked. Thanks a lot.
20:06:04 <joe6> llvm compiled without a problem.
20:10:46 <Peaker> @type (&)
20:10:47 <lambdabot> Not in scope: `&'
20:12:11 <joe6> anyone know how I can submit a patch to github? I want to submit a patch to haskell llivm project hosted on github
20:13:00 <Peaker> joe6: one way is to fork their repo, commit&push a change to your fork, and then send them a pull request
20:13:40 <joe6> i thought there was a simple command to email a patch
20:13:42 <dmwit> (It's not only one way -- it's the recommended way.)
20:13:56 <dmwit> git is really crappy about emailing patches.
20:13:57 <joe6> git send-email, oslt
20:14:10 <joe6> git format-patch and then email manually?
20:14:30 <dmwit> Have a look at "git am", I think.
20:14:46 <dmwit> Oops, no, that's for the guy on the other end.
20:17:25 <Cadynum> to anyone with gtk2hs experience: is it possible to prevent a widget to request another size after the inital size request upon it's creation?
20:19:02 <dmwit> Cadynum: Well, you can set the maximum and minimum requestable sizes to be equal.
20:19:15 <dmwit> However, you should know that a request doesn't necessarily imply that's the size you'll get.
20:21:10 <dmwit> Also, container widgets send their children "requests for requests", so it's really not a good idea to never send a request; at the very least, you should reply to a parent container.
20:21:21 <dmwit> So maybe I should ask what it is, exactly, that you're trying to do.
20:21:24 <Cadynum> i've been messing around wth widgetSizeRequest but that doesn't do what i want
20:22:13 <Cadynum> i have a horizontal two paned layout, the content in the second pane gets changed (labels and treeviews) depending on what you click on in the first pane
20:22:31 <Cadynum> when a label is too large it resizes the entire winodw
20:22:42 <tekknolagi> and?
20:23:03 <Cadynum> i dont want the window to get automatically resized simply
20:23:04 <dmwit> And he doesn't want it to resize the window, presumably. =P
20:23:49 <tekknolagi> you wrote this in haskell?
20:23:52 <dmwit> How are you generating the content in the second pane?
20:24:03 <Cadynum> tekknolagi, yep, gtk2hs
20:24:06 <dmwit> Are you tearing down the old widgets and adding new, or just manipulating widgets that are already there?
20:24:21 <Cadynum> dmwit, im changing the contents of the widgets
20:24:25 <Cadynum> no new widgets
20:24:39 <dmwit> Okay.
20:24:49 <dmwit> You should probably override some signal in the TreeView.
20:24:56 <dmwit> Not sure which one, but let's see if we can figure it out.
20:25:08 <Cadynum> i think the treeview is fine, i have it set to ellipsize the text
20:25:15 <dmwit> Oh?
20:25:24 <dmwit> Which widget do you think is asking for a different size, then?
20:25:48 <Cadynum> i think the labels does it, but it's weird since they would actually fit
20:26:46 <Cadynum> what's also weird is how the new space is distributed. it's the right pane that requests the space, yet the left pane is the one that actually gets bigger
20:27:19 <dmwit> Huh.
20:27:25 <Cadynum> it is technically correct i suppose based on how i have constructed the panes. but it's still werid to see it in action
20:27:34 <tekknolagi> post the code?
20:27:45 <dmwit> Yeah, hard to do much without a minimal test-case at this point.
20:29:46 <dmwit> (Probably just doing the process of whittling it down to a minimal test-case will make it obvious what the problem is, anyway. =)
20:30:16 <Cadynum> the code is quite large and messy
20:31:06 <Cadynum> but if you want to look at it anyway it is at git://git.mercenariesguild.net/rivertam.git in tremulous-query and gui
20:36:41 * hackagebot aosd 0.1.3 - Bindings to libaosd, a library for Cairo-based on-screen displays  http://hackage.haskell.org/package/aosd-0.1.3 (DanielSchuessler)
20:40:28 <Cadynum> i just want that the ratio between the panes and the window size stays the same no matter what content comes to it
20:43:32 <dylukes> Wow. I hate Agda so much.
20:43:36 <dylukes> It has completely RUINED HASKELL FOR ME.
20:44:09 <dmwit> Cadynum: Have you tried something easy, like setting widgetWidthRequest and widgetHeightRequest?
20:44:20 <Saizan> dylukes: you'd be the first, i think
20:44:36 <dylukes> Wait...
20:44:42 <copumpkin> :P
20:44:43 <Cadynum> dmwit, yeah, i've tried setting it to zero, but as soon as i change something gtk feels the need to igore that
20:44:46 <dylukes> there's a GHC extension for type-level nats right?
20:44:50 <Cadynum> (and other values too)
20:44:52 <dylukes> That might alleviate it slightly.
20:44:53 <copumpkin> dylukes: in the works
20:45:02 <dylukes> I want indexed types now. I recall I said something along the lines of "why would you need those?" before.
20:45:05 <Saizan> there's a ghc fork, currently
20:45:06 <dylukes> I take it all back D:.
20:45:11 <copumpkin> dylukes: GADTs are that
20:45:14 <dylukes> Praise the lord.
20:45:15 * dmwit nods sadly
20:45:22 <dylukes> copumpkin: heh?
20:45:29 <dylukes> Well, I can't make an indexed Vec type in Haskell.
20:45:33 <dylukes> I've tried.
20:45:33 <dylukes> :(
20:45:33 <copumpkin> dylukes: sure you can
20:45:46 <dylukes> Show me, master.
20:46:06 <cmccann> there's also she, if your tastes run that way
20:46:09 <copumpkin> dylukes: http://hpaste.org/41453/foldl_on_vec
20:46:20 <parcs> talking about indexed type families?
20:46:48 <parcs> if not, what are indexed types?
20:47:11 <joe6> dcoutts, with this fix, I can use ghci and llvm :  http://sprunge.us/YKXQ
20:47:44 <joe6> @seen dcoutts
20:47:44 <lambdabot> Unknown command, try @list
20:47:44 <preflex>  dcoutts was last seen on #haskell 4 hours, 41 minutes and 29 seconds ago, saying: complain
20:51:14 <Cadynum> dmwit, hah! by setting the attribute windowAllowShink for the toplevel window i was able to make it stop
20:51:22 <Saizan> parcs: like GADTs, but in a dep. typed language they can be indexed by values too
20:52:51 <dmwit> Cadynum: nice!
20:53:31 <Cadynum> 'If True, the window has no mimimum size. Setting this to True is 99% of the time a bad idea. ' oh well, it's better than the flicker autoresizing
20:54:47 <Jafet> Hah! I outsmarted gtk!
20:55:07 <dmwit> Jafet: What, you, too? =D
20:56:09 <Jafet> No, I'm not smart enough to use gtk.
20:57:26 <Cadynum> i have another gtk related question too, about sorted treeviews: is it possible to set a column to sort to by default? i want to to appear selected too
21:00:30 <Cadynum> i want it to appear selected just like if you would've clicked on it*
21:00:51 <dmwit> The answer is almost certainly, "Yes, it's possible.". =)
21:02:22 <tekknolagi> i think he wants to know how...
21:03:41 <Veinor> if i have two integers and i want to divide them (and keep the remainder)
21:03:56 <Veinor> which division do i want?
21:04:02 <dmwit> Yes, I know that. But I don't know how to do it, and even somebody very familiar with gtk would probably have to do exactly the same experiments with a test program as he is surely doing right now.
21:04:11 <Jafet> divMod or quotRem
21:04:27 <Veinor> i meant, i want to take (2 :: Integer) and (4 :: Integer) and get 0.5
21:04:39 <dmwit> :t (/) `on` fromInteger
21:04:40 <lambdabot> forall b. (Fractional b) => Integer -> Integer -> b
21:04:47 <Veinor> ah
21:04:49 <Jafet> :t (%)
21:04:50 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
21:04:56 <dmwit> % is very nice, too
21:04:59 <Cadynum> dmwit, i think this question is general for sorted treeviews
21:06:11 <tekknolagi> > 5 % 2
21:06:12 <lambdabot>   5 % 2
21:06:21 <tekknolagi> > (%) 5 2
21:06:21 <lambdabot>   5 % 2
21:06:33 <tekknolagi> question: why doesn't that return an answer?
21:06:42 <Jafet> > 1%2 + 1%3
21:06:43 <lambdabot>   5 % 6
21:06:50 <identity_> it does
21:06:50 <dmwit> tekknolagi: It does return an answer.
21:06:55 <identity_> :t (5 % 2)
21:06:56 <dmwit> tekknolagi: The answer is 5 % 2.
21:06:56 <lambdabot> forall t. (Integral t) => Ratio t
21:07:04 <tekknolagi> dmwit: why not an exact answer?
21:07:06 <dmwit> > 15 % 6
21:07:07 <lambdabot>   5 % 2
21:07:09 <tekknolagi> i mean
21:07:09 <identity_> > 10 % 2
21:07:10 <lambdabot>   5 % 1
21:07:11 <dmwit> tekknolagi: 5 % 2 *is* an exact answer.
21:07:13 <tekknolagi> integer
21:07:23 <dmwit> Because 5 % 2 isn't an Integer.
21:07:25 <tekknolagi> integer, not ratio: how do i change that
21:07:36 <dmwit> > floor (5 % 2)
21:07:36 <lambdabot>   2
21:07:38 <dmwit> > 5 `div` 2
21:07:39 <Jafet> You want to change the value of 5 % 2?
21:07:39 <lambdabot>   2
21:07:47 <tekknolagi> oh
21:07:50 <tekknolagi> thanks dmwit
21:07:58 <identity_> :info Ratio
21:08:01 <Jafet> I hear you can do that in some fortran.
21:08:03 <identity_> meh
21:08:04 <tekknolagi> > (`div`) 5 2
21:08:05 <lambdabot>   <no location info>: parse error on input `)'
21:08:12 <dmwit> > div 5 2
21:08:13 <lambdabot>   2
21:08:14 <tekknolagi> > (div) 5 2
21:08:15 <lambdabot>   2
21:08:15 <tekknolagi> yeah
21:09:34 <dmwit> Oh, I feel so dirty.
21:10:41 <dmwit> instance Num a => PPrint a where pprint = show
21:11:16 <identity_> dmwit: I can't help but pronounce your handle as "dimwit"
21:11:24 <byorgey> SADFACE =(
21:11:24 <identity_> Is that intentional? :(
21:11:25 <dmwit> That's intentional. =)
21:11:29 <identity_> ah, very good
21:11:31 <Jafet> Your penance is to write a proper one for RealFrac.
21:12:14 <shachaf> dmwit: Is there any other meaning to the nick?
21:12:24 <identity_> I noticed his name is Daniel Wagner
21:12:29 <dmwit> But it's so much better than "for i in Int Integer Double Float Rational; echo instance PPrint $i where pprint = show"
21:12:30 <identity_> it has a D and a W
21:12:47 <dmwit> shachaf: As identity_ has guessed, my initials are DMW.
21:13:05 <shachaf> And "it"?
21:13:20 <dmwit> The letters necessary to make a joke. =)
21:14:36 <cmccann> > let 5 % 2 = 11 in 5 % 2
21:14:37 <lambdabot>   11
21:14:39 <cmccann> :]
21:16:49 <identity_> Why do I insist on starting to write my haskell applications before thinking about the design hard enough? I always end up backtracking and having to stack several monad transformers on the crap i've written, often ending with nearly a complete rewrite
21:17:14 <joe6> anyone knows why the castModuleValue would give a value of Nothing:  http://sprunge.us/SQCe
21:18:17 <QtPlatypus> identity_: Because the writing of the application is what helps you understand how the design should be.  Its not until you have the crap code written that your understanding of the problem domain is deep enought to be able to see the better design.
21:18:54 <identity_> QtPlatypus: Probably, yeah
21:19:17 <cmccann> watching a terrible design collapse under its own weight is a viable, if not ideal, method for refining your understanding of the problem
21:19:34 <identity_> But I really need to make an attempt to write down a few steps of the program to realize that.. say.. "hey, I need premature exit so I should probably use ErrorT or MaybeT"
21:19:49 <identity_> (that's what happened now)
21:22:49 <hpaste> dankna pasted “slow...” at http://hpaste.org/48062
21:23:02 <dankna> it seems to be spending most of its time in GC
21:23:20 <dankna> I have an outer loop which invokes this one, hmm, 256 times I think
21:23:24 <dankna> and takes about 18 seconds
21:23:35 <dankna> of which only 2 seconds is mutator time
21:23:45 <dankna> (which is still an order of magnitude higher than I'd like, of course!)
21:23:47 <Jafet> hlint now gives errors! How authoritative.
21:23:54 <dankna> haha I see that
21:24:14 <dankna> most of the heap profile is Doubles and Complex Doubles
21:24:28 <dankna> which, I mean, is kind of duh, what else would it be, but.
21:24:41 <shachaf> Redundant brackets are considered errors? That's a bit extreme.
21:24:48 <dankna> yeah I know right :)
21:25:06 <dankna> and for hlint's information, I put those redundant "do"s there as an aid to refactoring haha
21:25:17 <dankna> because it kills time if I change something and forget to remove/add them as appropriate
21:25:31 <shachaf> Hah, hlint's suggestion for "use unless" has a redundant bracket in it.
21:25:38 <dankna> amusement
21:25:45 <dmwit> hlint does not promise to be idempotent
21:25:53 <shachaf> Or, wait, maybe it doesn't.
21:26:16 <shachaf> Does it at least promise not to get into cycles? :-)
21:26:21 <dmwit> No.
21:26:49 <dmwit> I've even seen cycles.
21:27:38 <cmccann> it should detect cycles and report the offending code as "this code is hopeless, please fix it"
21:28:32 <dmwit> The thing is, there are times when both "X" and "Y" are reasonable, and the decision is somewhat aesthetic.
21:28:43 <mlh> >let 5 % 2  = "The bitter tears of Petra Von Kant" in 5 % 2
21:28:48 <dmwit> If you put "X", hlint will suggest "Y" just in case it happens to match your aesthetics.
21:29:02 <dmwit> "The bitter tears of Petra Von Kant"
21:29:22 <mlh> ta dmwit :-)
21:29:37 <dmwit> mlh: Add a space after your > next time.
21:30:02 <mlh> yeah paste error
21:30:07 <identity_> >"This makes dmwit talk"
21:30:12 <identity_> Or not
21:30:21 <shachaf> "This makes dmwit talk"
21:30:23 <cmccann> dmwit, I figured it mostly reported things that would be widely-agreed-upon improvements, but I honestly don't actually use hlint that much
21:30:24 <dankna> > let 5 % 2  = "The bitter tears of Petra Von Kant" in 5 % 2
21:30:25 <lambdabot>   "The bitter tears of Petra Von Kant"
21:30:26 <identity_> shachaf: :|
21:30:50 <dankna> anyway, I'm more interested in how I can improve my code :(
21:30:56 <dmwit> distributed lambdabot
21:31:08 * shachaf has already learned that dankna doesn't like his "improvements".
21:31:24 <dankna> shachaf: haha I tried them, but they didn't help :( a shame as they were actually rather clean
21:31:24 <mlh> so have people proposed some sort of warning for that?  something like % already defined?
21:31:36 <shachaf> dankna: Wait, which thing are you referring to?
21:31:43 <dmwit> mlh: Yes, there's a shadowing warning available in GHC.
21:31:52 <mlh> ghci to?
21:31:55 <mlh> too?
21:31:58 <shachaf> tooo?
21:32:03 <dmwit> -fwarn-name-shadowing or so
21:32:09 <dankna> shachaf: with the NES emulator, you were the one who suggested the continuation-based monad, right?  or was that Saizan?
21:32:19 <shachaf> dankna: Oh, that wasn't me.
21:32:22 <dankna> oh, okay
21:32:26 * shachaf completely forgot about the NES emulator.
21:32:31 <dankna> what were you referring to then?
21:32:33 <shachaf> Hmm, I should look at that sometime.
21:32:33 <mlh> awesome
21:32:41 <shachaf> dankna: Oh, that timestamp-showing function.
21:32:42 <mlh>  .. let 5 + 2 =  "The bitter tears of Petra Von Kant" in 5 + 2
21:32:45 <dankna> oh, yeah :)
21:32:49 <dankna> you were helpful though
21:32:53 <mlh>  Warning: This binding for `+' shadows the existing binding  imported from Prelude
21:32:57 <identity_> I have a question about ErrorT: http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-Error.html in the first example, function calculateLength, isn't the (`catchError` Left) redundant here?
21:32:59 <dankna> even though yes, I didn't find your code-wording to help with clarity
21:33:14 <dankna> it was great to have another set of eyes on it to verify that I was doing something sane in the first place
21:33:23 <mlh> should be default methinks
21:33:32 <shachaf> mlh: Nah, shadowing is perfectly reasonable.
21:33:46 <mlh> until its not :-)
21:33:50 <Jafet> dankna: passing around closures probably confuses the optimizer
21:34:07 <dankna> Jafet: hmm interesting point yes.  I can probably reword that to pass the information they need instead.
21:34:34 <dmwit> identity_: yes
21:34:40 <Jafet> It's also less repetitive that way.
21:34:43 <dankna> true
21:35:25 <identity_> dmwit: Thanks. That means I'm grokking this
21:38:31 <dankna> sweet, that made it MUCH better!  (still too much, however)
21:38:38 <dankna> that took like 90% off the runtime :)
21:38:43 <dankna> now for the other 10% haha
21:38:58 <dankna> I can remove some closures in the outer loops, too, trying that now
21:39:37 <Jafet> Well, there's no point guessing without a profiler
21:39:48 <Jafet> Better to profile and then guess
21:39:49 <dankna> well, I mean, I ran it under the profiler
21:39:56 <dankna> but I still feel like I'm guessing
21:40:21 <dankna> for example, you'll notice that two of the parameters to the whole function are closures
21:40:25 <Jafet> It's still guessing, but the profiler can verify your guesses
21:40:49 <dankna> I have no idea whether those closures get attributed to the cost-center of their creator or their caller
21:41:14 <dankna> if the former, then they aren't adding substantially to my runtime
21:41:26 <dankna> since it's still the case that this function is 99% of it
21:41:35 <Jafet> There's a cost of creating a closure, and then there's a cost of using it.
21:41:38 * dankna nods
21:43:31 <Jafet> Also, I don't think the bangs do anything to the closures, since GHC doesn't reduce under lambda forms.
21:43:35 <dankna> oh hm
21:43:38 <dankna> good point
21:43:51 <dankna> well, those are gone now anyway
22:02:32 <Guest32757> @help
22:02:32 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:03:42 <Guest32757> @run
22:03:43 <lambdabot>   not an expression: `'
22:03:51 <megajosh2> > 1 + 2
22:03:52 <lambdabot>   3
22:03:55 <megajosh2> It's a genius!
22:04:24 <djahandarie> > let 2 + 2 = 5 in 2 + 2
22:04:24 <lambdabot>   5
22:04:46 <Jafet> @. vixen quote
22:04:46 <lambdabot> let me answer that later, okay?
22:06:31 <othiym23> is there an obfuscated Haskell contest?
22:06:39 <othiym23> cuz there totally should be
22:07:04 <othiym23> and then all the other PL nerds could be like "WE COULDN'T TELL THE DIFFERENCE LOL"
22:07:45 <Jafet> Sometimes one is held in this channel
22:08:14 <othiym23> the above shadowing hijinx seem like they'd be very useful in that context
22:08:20 <cmccann> I'm pretty sure this is a strong contender: http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html
22:09:13 <cmccann> I'm pretty sure that in an obfuscated Haskell contest I'd spend most of my time attempting to mimic the structure of imperative code. how much more obfuscated can you really get than that?
22:09:33 <Jafet> Well, perl contests are usually golfs.
22:09:42 <Jafet> I suppose the ones in this channel are golf courses too.
22:09:44 <othiym23> hmmm... needs more TI 99/4a Extended Basic mnemonics
22:10:01 <cmccann> I mean, there's always running stuff through @pl, but there's no challenge in that
22:10:12 <othiym23> along with typos in the 32nd straight line of DATA statements so the entire program fails with a "SYNTAX ERROR" after you've painstakingly typed all the code in by hand
22:10:18 <othiym23> not that I'm still bitter or anything
22:10:24 <cmccann> hahaha
22:10:27 <dankna> haha
22:10:27 <dankna> yeah
22:10:30 <dankna> know that feeling!
22:10:38 <cmccann> othiym23, brings back memories
22:10:43 <cmccann> not fond memories, mind
22:10:45 <cmccann> but definitely memories
22:10:56 <othiym23> *I* wanted an Apple //e, but noooo
22:11:17 <othiym23> I don't really think of code golf and obfuscation as being the same things
22:11:31 <othiym23> nor Perl poetry, as far as that goes
22:11:41 <othiym23> although they're not entirely disjoint sets
22:11:44 <identity_> I participated in a few golf contests with haskell
22:11:47 <cmccann> anyway, Haskell enthusiasts seem to be more prone to abstraction golfing than plain code golf
22:11:56 <cmccann> "how can I do this in the most abstract, generalized way possible?"
22:11:57 <dankna> poetry and code?  *hem*
22:11:57 <identity_> I always got beaten by python, but I always felt like I was the righteous winner
22:12:02 <othiym23> that's what I took away from a Neighborhood of Infinity, yeah
22:12:07 <identity_> Because my code was so much more elegant
22:12:10 <identity_> but no one agreed.
22:12:14 <dankna> "A dozen, a gross and a score / plus three times the square root of four / divided by seven / plus five times eleven / makes nine squared and not a bit more."
22:12:19 <dankna> (and it does, too)
22:12:27 <othiym23> "let's see what happens if I take the 3rd derivative of this comonadic mutually recursive data structure!"
22:12:40 <dankna> now, can anyone do that - make a poem that does something interesting - in the programming language of their choice? :)
22:13:00 <othiym23> you gotta have a pretty liberal definition of poetry, dankna
22:13:03 <dmwit> dankna: http://en.wikipedia.org/wiki/Black_Perl
22:13:04 <dankna> haha
22:13:06 <dankna> true
22:13:33 <dankna> hahaha reading this
22:13:34 <dankna> wow
22:13:40 <dankna> die sheep! die to reverse the system
22:13:41 <dankna> lol
22:14:10 <othiym23> Perl poetry drove me to Ruby
22:14:25 <cmccann> yeah, I don't think it's really possible to compete with Black Perl
22:14:30 <dankna> indeed
22:14:33 <dankna> I must agree
22:14:34 <cmccann> particularly the way it uses so many keywords
22:15:32 <othiym23> I have seen some OCaml poetry, a long time ago
22:15:50 <othiym23> it was sorta, hmm, aphasic ee cummings-ish
22:15:57 <dankna> ha
22:17:57 <Jafet> Yes, Haskell has nothing on perl.
22:18:00 <Jafet> http://nntp.perl.org/group/perl.golf/1289
22:20:03 <dankna> holy wow
22:20:06 <dankna> that's quite a trick
22:20:14 <dankna> using the GC to do a topological sort haha
22:20:53 <djahandarie> Heh.
22:22:52 <dankna> hm
22:23:06 <dankna> this is weird: fully half my runtime is going to a Double multiplication
22:23:20 <dankna> but almost none is going to a Double division that's executed the same number of times (right next to it, in fact)
22:25:04 <Jafet> The profiler works by statistical sampling
22:25:21 <Jafet> I would expect the most work to be done by exp.
22:25:25 <dankna> hmm okay
22:25:56 <dankna> yeah, I actually eliminated the call to exp by expanding it into cosine and sine, but it runs slower that way so I should change it back
22:26:08 <dankna> I'm going to try changing Double to Float and see if that makes a difference, heh
22:26:19 <Jafet> It probably won't.
22:26:29 <dankna> hm, yeah, it doesn't
22:28:53 <Jafet> It might make a difference to the result, though, if that's what you meant...
22:29:03 <dankna> no, haha
22:29:29 <dmwit> Reminds me of that talk I went to a while ago about speeding code up.
22:29:32 <danharaj> how expensive is truncate, generally?
22:29:42 <dmwit> The main idea was to delete lines at random until the program was fast enough.
22:29:50 <dmwit> Then you double-check that the answer is almost right. =P
22:30:37 <copumpkin> @tell roconnor I'm thinking of making a websockets client library first, before working on your thing. Shouldn't take long
22:30:37 <lambdabot> Consider it noted.
22:30:55 <dankna> dmwit: hah, nice idea haha, wish I could do that :)
22:31:42 <othiym23> you could maybe write a little set of combinators that couple QuickCheck with something that randomly removes chunks of source
22:31:49 <hpaste> dankna annotated “slow...” with “slow... (annotation)” at http://hpaste.org/48062#a48063
22:31:58 <othiym23> put it in a Haskell distribution called Haskell AGE, for Almost Good Enough
22:32:13 <hpaste> dankna annotated “slow...” with “slow... (annotation)” at http://hpaste.org/48062#a48064
22:32:25 <dankna> that's my current version and the profiler output
22:32:58 <dankna> it performs much better than the original version seen at the top, but still, alas!  too slow :)
22:34:34 <dankna> I'm going to try turning it into two unboxed arrays of Doubles, instead of a single boxed array of Complex Doubles
22:35:35 <Jafet> Ugh.
22:35:44 <dankna> why ugh?
22:35:50 <Jafet> Because ugh.
22:35:52 <luite> with vector, you should be able to make an instance for Complex arrays
22:35:53 <dankna> well, yeah
22:35:54 <Jafet> Is writeArray value-strict?
22:36:06 <dankna> it ought to be, but I can try a bang there
22:36:08 <luite> internally as two Double arrays
22:36:39 <luite> so that you can get the real or imaginary parts quickly. if necessary :)
22:36:45 <dankna> hm
22:37:05 <Jafet> Bzzt! It's not.
22:37:08 <dankna> it's a thought, but I'll try the transformation first and then worry about cleaner ways of expressing it if it actually helps
22:37:15 <dankna> Jafet: ah! hmm
22:37:27 <dankna> Jafet: how did you find that out, and what can I do about it? :)
22:37:38 <dankna> oh, I can seq of course
22:37:43 <dankna> but how did you find it out
22:37:55 <Jafet> http://localhost/usr/local/share/doc/ghc/html/libraries/base-4.3.1.0/src/GHC-IOArray.html#IOArray
22:38:12 <dankna> that's a localhost link :)
22:38:21 <dankna> but okay :)
22:38:26 <Jafet> Eh, should work for many people.
22:39:01 <Jafet> Well, the documentation names IOArray as "a mutable, boxed, non-strict array".
22:39:08 <dankna> ah, so it does, haha
22:39:09 <dankna> I see
22:39:47 <Jafet> You could make an instance MArray (IOUArray i (Complex Double)), I suppose
22:39:50 <dankna> ah hey, that knocked another 2s (33%) off!
22:39:54 <Jafet> And implement what luite said there
22:39:56 <dankna> right
23:38:25 <kuraj> im having trouble with a function that would divide a flat list into n-element nested chunks
23:39:12 <kuraj> hmm
23:39:13 <Jafet> You mean, you can't get cabal to install split?
23:39:14 <luite> in what way nested?
23:39:14 <kuraj> oh.. wait.
23:40:00 <kuraj> luite: divideby 4 [a,b,c,d,e,f,g,h,i,j] = [ [a,b,c,d], [e,f,g,h], [i,j] ]
23:40:27 <kuraj> ive got an idea tho
23:40:45 <luite> right, splitEvery
23:40:51 <luite> from split, Data.List.Split
23:41:00 <kuraj> you mean it already exists?
23:41:42 <kuraj> this doesnt seem to be the case in GHCi 7.0.3
23:41:50 <luite> you need to cabal install split
23:42:53 <kuraj> i'd rather have it as a function inside my file
23:43:21 <kuraj> found it
23:43:25 <kuraj> thanks for the info :)
23:43:54 <luite> why? if it bothers you that you have dependencies, you should do cabal init
23:44:26 <kuraj> this is my assignment project - who the hell knows what my supervisior will have installed ;)
23:44:37 <luite> yes, that's why a cabal package is appropriate
23:44:49 <kuraj> i am required to send a single .hs file
23:44:51 <luite> oh
23:45:05 <luite> that's not ideal :p
23:45:18 <kuraj> i know, right :p
23:46:30 <kuraj> oh um... WTF is build
23:46:38 <kuraj> splitEvery i l = map (take i) (build (splitter l)) where (...)
23:47:14 <shachaf> @src build
23:47:14 <lambdabot> build g = g (:) []
23:47:34 <kuraj> it simply makes a singleton list out of atom?
23:47:40 * hackagebot authenticate 0.9.1.5 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.9.1.5 (MichaelSnoyman)
23:47:47 <kuraj> why name it so it can be impossible to search for
23:47:50 <shachaf> That would be (:) g [].
23:47:54 <kuraj> oh
23:48:04 <kuraj> right.. um
23:48:08 <gfarfl> kuraj: chunk from Data.List.Split looks like it might be easier to copy the source for
23:48:08 <shachaf> kuraj: Look for the name together with foldr.
23:48:09 <kuraj> so what does it actually do
23:48:20 <shachaf> @google foldr build
23:48:21 <lambdabot> http://www.haskell.org/haskellwiki/Correctness_of_short_cut_fusion
23:48:21 <lambdabot> Title: Correctness of short cut fusion - HaskellWiki
23:49:22 <kuraj> fusion... oh dear
23:49:32 <luite> gfarfl: that's exactly the same :)
23:51:13 <gfarfl> luite: yes, I see it does the same thing. I misread splitEvery, and thought it was using the Splitter business.
23:51:27 <gfarfl> they are next to each other on the wiki page, and I was skimming
23:52:20 <Nimatek> :t (<|>)
23:52:21 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
23:53:59 <kuraj> meh
23:54:16 <kuraj> i wish there was a way to somehow alter show for nested arrays
23:54:33 <danharaj> What do SPECIALIZE pragmas do?
23:54:43 <kuraj> they'd be so much easier to read if they indented
23:54:59 <luite> danharaj: they tell GHC to generate code specialized for that type
23:55:23 <danharaj> luite: What sort of things does GHC do, generally?
23:55:32 <kuraj> it does magic
23:56:04 <luite> danharaj: I don't think it can automatically specialize code across modules
