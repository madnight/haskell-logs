00:21:02 * hackagebot hgal 2.0.0 - library for computation automorphism group and canonical labelling of a graph  http://hackage.haskell.org/package/hgal-2.0.0 (JeanPhilippeBernardy)
00:24:03 * hackagebot tls 0.7.0 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.7.0 (VincentHanquez)
00:26:03 * hackagebot tls-extra 0.3.0 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.3.0 (VincentHanquez)
01:07:36 <roconnor> > 14 * 24 * 6
01:07:37 <lambdabot>   2016
01:10:14 <Entroacceptor> don't people own brains or calculators anymore?
01:18:04 * roconnor kinda wishes `mod` had a lower precidence.
01:18:18 <roconnor> I always get x + y `mod` n wrong
01:18:36 <mun> hi
01:18:46 <isomorphic> roconnor: The interpretation you want is how it's written in academic papers
01:18:46 <lambdabot> isomorphic: You have 1 new message. '/msg lambdabot @messages' to read it.
01:19:40 <mun> is a statement like \forall T. \exists T'. f : T -> T' a truth statement? that is to see if f takes in a polymorphic type and outputs some particular type?
01:22:06 <isomorphic> oh, incidentally - can somebody write phoenetically how they say 'iteratee'
01:22:27 <isomorphic> I - terror - tee?
01:22:33 <isomorphic> Iterati?
01:35:03 <lyallb> I
01:47:46 <albertid> Hm. I'm just starting with Haskell. Say I want to store intervals as data. Would you a) store the length of each interval as an [Integer] or b) store functions that implement the translation of the interval. Latter would be more general and the value of the interval would be described by its function. But then I have a hard time to compare two intervals. Any hints?
01:49:11 <osfameron> what do you mean by an interval?
01:50:11 <albertid> just the distance between two elements
01:50:29 <osfameron> if it's http://en.wikipedia.org/wiki/Interval_(mathematics) wouldn't you just a have a tuple of (startpoint, endpoint) ?
01:51:15 <albertid> its Interval (music)
01:51:32 <osfameron> nice ;-)
01:52:54 <osfameron> I think your original reasoning is right - storing the data (length of each interval) will be easier to work with
01:52:54 <dixie> hmm, which library is right one? FileManipCompat or filemanip? Does this split compat/no-compat is still valid?
01:53:48 <albertid> osfameron, yep. the problem with comparing functions is that I can only compare them by giving both functions an example data and see if they return the same value
01:54:11 <albertid> which seems crooked
01:54:15 <osfameron> albertid: yeah
01:54:44 <osfameron> albertid: is there a reason you're looking for anything beyond Int as the representation?
01:55:16 <albertid> osfameron, read about applicative functors recently :)
01:55:21 <albertid> but otherwise, no :)
01:55:53 <albertid> and I like the idea that the value is represented by its function
01:56:13 * hackagebot egison 0.2.0.2 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-0.2.0.2 (SatoshiEgi)
01:56:15 <osfameron> albertid: hehe.
01:56:48 <osfameron> albertid: keeping it simple for the first iteration is probably a good idea
01:57:02 <albertid> true
01:57:04 <osfameron> (in FP, do we prefer "for the first recursion" ?)
01:57:59 <benmachine> :P
02:00:10 <deggis> regarding ghc, cabal & linking executable: if i give extra-lib-dirs as --extra-lib-dirs cmd line parameter or specify it in .cabal file, the executable misses the dynamic link. running "export LD_LIBRARY_PATH=[DIR HERE]" before cabal install works, however
02:00:30 <deggis> any hints/ideas on that?
02:02:07 <eddayyy> is it wrong to do class (ToJSON a, FromJSON a, Resolvable a, ...) => Persistable a ?
02:02:15 <erus`> How can I compile resources into an executable with ghc?
02:02:17 <eddayyy> (in order to simulate 'multiple inheritance')
02:07:48 <dcoutts> deggis: do you mean that the static linking fails, or do you mean that at runtime the program cannot find the .so files?
02:07:56 * dcoutts suspects the latter
02:09:39 <osfameron> eddayyy: hello ;-)
02:09:53 <eddayyy> osfameron: hey :)
02:10:36 <eddayyy> osfameron: would you happen to know the answer to q, my friend was asking and I said maybe it would be better to compose monads rather than create a typeclass that 'multiply inherits' but i have no idea what kinda solutions exist in this space.
02:11:50 <osfameron> eddayyy: heh, that's beyond me, I'm sure someone else here will have a much better idea
02:12:16 <osfameron> I'd have thought the typeclass thing you suggested would *work* (and is simpler to declare) but I don't know what the disadvantages of it would be
02:13:35 <deggis> dcoutts: the latter. i'm inspecting the binaries with ldd, which gives not found on all 'custom' so's (@ ~/usr/local/lib/)
02:13:58 <eddayyy> osfameron: as far as i coul d see the disadvantage was having to type many typeclass names before the => which can get pretty lengthy
02:16:43 <osfameron> eddayyy: heh
02:19:03 <k0ral> hi, I have both mtl and monads-tf packages defining the same Control.Monad.Trans
02:19:10 <k0ral> which one should I unregister ?
02:19:23 <benmachine> k0ral: neither, just hide one
02:19:31 <k0ral> how ?
02:19:39 <benmachine> ghc-pkg hide mtl
02:20:22 <k0ral> thank you :)
02:33:13 <lyallb> Is anyone interested in collaborating on a newbies attempt to understand Haskell?
02:33:15 <lyallb> I have a file containing Haskell code to read a file, modify its contents and write a new file.
02:33:17 <lyallb> The code is just a framework that I am adding to as I understand more Haskell.
02:33:19 <lyallb> I am also new to IRC (using ChatZilla on Windows 7). I am not sure how to get my
02:33:21 <lyallb> file to interested parties.
02:34:38 <dcoutts> deggis: right, that's standard linker behaviour
02:35:07 <dcoutts> deggis: -L is for finding libs in the static linking phase, it does not change the runtime dynamic linker path
02:35:19 <sepp2k> lyallb: That's what paste bin are for. http://hpaste.org
02:35:30 <dcoutts> deggis: for that you either use rpath, LD_LIBRARY_PATH or change your system paths
02:35:52 <dcoutts> deggis: obviously the usual thing is for .so libs to live in the system dirs
02:41:02 <deggis> dcoutts: ah. i haven't got good intuition on static vs. dynamic linking, this should be fix'd with reading. thanks for pointing those out
02:42:03 <isomorphic> I have some text that I've parsed in parsec - ie, inside the parser, there's a line
02:42:12 <isomorphic> text <- extractText
02:42:27 <isomorphic> is there a good way to now run a *different* parser against text?
02:42:39 <isomorphic> ie: to extract different text from it?
02:43:16 <fxr> hmm that's a cool request
02:43:49 <fxr> I should note it down.
02:45:00 <mun> is a statement like \forall T. \exists T'. f : T -> T' a truth statement? that is to see if f takes in a polymorphic type and outputs some particular type?
02:46:12 <isomorphic> fxr: Was that responsive to my question?
02:49:02 <fxr> isomorphic: nope I'm just thinking about a modular enumerator pipeline for a webserver...
02:49:20 <isomorphic> :)
02:50:21 <benmachine> isomorphic: so you want to put the result of a parser into the input stream?
02:50:23 <fxr> combining a parser with the main enumerator in a WebMonad is a cool request imo.
02:51:20 <isomorphic> benmachine: Not quite.  I've parsed a sentence, ie:  "This sentence is false.".
02:51:44 <isomorphic> And now I know where the sentence starts and ends (ie: i have it in a variable a <- sentenceParser)
02:51:55 <isomorphic> I'd like to look for words that are in the sentenc
02:51:58 <isomorphic> sentence*
02:52:16 <isomorphic> trouble is, the input from the point of view of the parsing monad, is now consumed
02:52:37 <isomorphic> so, I'm tempted to kick off a new parser mid parse - but that seems, wrong somehow
02:52:43 <benmachine> isomorphic: well, you could use getInput or setInput, or you could just invoke parse again
02:52:46 <isomorphic> make sense?
02:52:47 <benmachine> I don't think it's wrong
02:53:20 <benmachine> well, the disadvantage is you'll have to manually handle parse errors instead of having them be manually propagated
02:53:28 <benmachine> but that's probably not altogether an awful thing
02:54:37 <benmachine> but you could save the input state with getInput, use setInput to set it to your parsed sentence, parse it, and then restore the original thing with setInput
02:54:38 <isomorphic> getPosition looks hopeful
02:54:53 <isomorphic> yup - currently looking at that :P
02:55:05 <benmachine> setPosition won't actually rewind the position, just changes where it thinks this is :P
02:55:07 <isomorphic> I'm rubbish with monads, so I'm going slowly with the state stuff :P
02:55:19 <fxr> hmm smells like a need for explicit checkpoint and rewind for the stream.
02:55:31 <isomorphic> thanks benmachine - how did the exam go?
02:55:40 <benmachine> isomorphic: erm, which one :P
02:55:50 <benmachine> isomorphic: well enough, I hope, have to wait and see
02:55:51 <fxr> we have it in our core-server framework but I don't think we have it in haskell side
02:55:53 <isomorphic> benmachine:  Maths perhaps?
02:55:56 <benmachine> isomorphic: which one :D
02:56:10 <isomorphic> benmachine: Engineering student then?
02:56:14 <benmachine> isomorphic: maths student :)
02:56:22 <isomorphic> :P ouch
02:56:26 <isomorphic> but fun
02:56:35 <benmachine> mm, I quite enjoy it
02:56:55 <isomorphic> :)
02:57:12 <benmachine> it's weird to not have any exams left, I keep feeling like I should be doing something
02:57:14 <isomorphic> it seems like an excellent degree in these times
02:57:27 <benmachine> yeah, it's a pretty good deal in that regard
02:57:38 <benmachine> but even if it wasn't I would be doing it anyway because <3 maths
02:57:52 <isomorphic> hehe :P
03:09:45 <mun> is a statement like \forall T. \exists T'. f : T -> T' a truth statement? that is to see if f takes in a polymorphic type and outputs some particular type?
03:26:27 <hpaste> lyallb pasted “RWFILE” at http://hpaste.org/47748
03:30:16 <lyallb> I have put the code on hpaste as suggested by sepp2k. Anyone care to discuss it with me?
03:32:10 <Phyx-> what's the link?
03:33:37 <lyallb> I guess Phyx is talking to me (new to all this). The link is http://hpaste.org - see above at [20:20] hpaste.
03:34:43 <Phyx-> lyallb: right, i was talking to you :) you also get a direct url to your paste, in this case yours is http://hpaste.org/47748
03:34:56 <opqdonut> what is this code trying to do?
03:35:38 <opqdonut> if you really want to structure the thing like that, you should probably use a real data type instead of a 6-tuple
03:36:12 <opqdonut> then you could use the "thing { field = newValue }" syntax to update just one field
03:36:27 <Phyx-> yeah, was just gonna say, a Record would work much better
03:36:41 * hackagebot egison 0.2.1.0 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-0.2.1.0 (SatoshiEgi)
03:36:59 <lyallb> The code is intended to read a file, change its contents and write it out to another file.  It is an attempt to control a number of things that go wrong with file io.
03:38:00 <lyallb> I am unsure of types, so I thought I would get ghci to tell me all about them.
03:38:05 <Phyx-> aren't the last 3 functions identical?
03:39:23 <lyallb> there is probably duplication at this point. my new strep is to try to open the input file and check it open ok, if not put a message in em
03:41:29 <isomorphic> benmachine: I think I'm using getPosition correctly - do I do "before <- getPosition ; res <- runParser ; setPosition before"?
03:41:30 <lyallb> it is sure to be my 'imperative' brain at work, but this stuff has to be sequential (I don't get monads at present)
03:42:03 <Phyx-> lyallb: which part of them are you having trouble with?
03:43:19 <Phyx-> lyallb: just to be clear, since you're probably thinking Imperatively, those functions are all taking 1 argument which is a 6-tuple, and not 6 arguments, like an imperative language
03:45:18 <lyallb> the whole monad thing is a mystery - so I would like to leave it until I understand what I am doing with the example; it seems to me it should work
03:46:14 <benmachine> isomorphic: what are you expecting that to do?
03:46:28 <lyallb> yes, I understand that the tuple is one argument; it simplifies the in -> func --> out type as far as I see at present
03:47:01 <aavogt> how can I make a 'case' on the kind which makes up a type?
03:47:03 <isomorphic> benmachine: I'd like it to save the position, for later use
03:47:16 <isomorphic> I'm learning that it doesn't do that :/
03:47:20 <benmachine> mmhm
03:47:27 <benmachine> it just saves the line number and column number
03:47:37 <benmachine> you want getInput and setInput I think
03:47:50 <isomorphic> oh okay
03:48:32 <rostayob> @pl \x -> x < 16 && x > 1
03:48:32 <lambdabot> liftM2 (&&) (< 16) (> 1)
03:48:59 <isomorphic> benmachine: Ah - it likes that better! :)
03:49:00 <isomorphic> Thanks!
03:49:05 <benmachine> :)
03:49:19 <companion_cube> (->) is a monad for composition ?
03:49:26 <Phyx-> lyallb: one sec
03:49:37 <benmachine> companion_cube: (->) is not a monad
03:49:42 <companion_cube> (->a)
03:49:43 <benmachine> companion_cube: well, pedantically, anyway
03:49:48 <lyallb> if I can openFile ReadMode in function infp and get the handle into infh or an error message into em is where  I am at
03:49:54 <benmachine> more like (->) a
03:50:50 <benmachine> (which is approximately (a ->) if type sections were allowed)
03:50:51 <Jafet> Merely because it's an applicative functor
03:51:01 <benmachine> Jafet: hm?
03:51:34 <Jafet> Well, I never think about it as a monad, even when I use the Monad instance
03:51:59 <benmachine> do you ever use do with functions?
03:52:27 <Jafet> Applicative do!
03:52:34 <benmachine> :P
03:52:34 <aavogt> here's my non-question (which turns out solved) http://hpaste.org/47749  perhaps there are some style things / extensions which might be unnecessary
03:52:35 <Jafet> Er, no.
03:52:44 <benmachine> oh, well, I don't often
03:52:47 <benmachine> but it's kinda cute
03:54:13 <Lopez_> anyone know why this code is giving an error on the tryhaskell website:  sum [x | x <- [1..9­99], x `mod`­ 3 == 0 || x `mod`­ 5 == 0]
03:54:39 <Phyx-> lyallb: this should atleast increase the readability of your code http://pastebin.com/CZMN6v6G
03:54:40 <mauke> The paste CZMN6v6G has been copied to http://hpaste.org/new
03:55:10 <lyallb> ok having a look, back soon
03:55:39 <Lopez_> thanks
03:55:48 <Phyx-> heh, mauke really liks hpaste
03:56:27 <frerich> Hm, does anybody have a suggestion for a name for my "generalized if" function (\p f g x -> if p x then f x else g x)? Is there a conventional naming scheme for such "generalized" functions?
03:57:02 <frerich> I thought "if'" is a bit non-descriptive, and "genericIf" is not very nice either.
03:57:22 <benmachine> frerich: it's not quite generalised, inasmuch as you can't use it as a drop-in replacement for if
03:58:16 <aavogt> Lopez_: what character is there right after the `mod`, and right after the first 9?
03:58:39 <benmachine> :t \p f g -> do b <- p; if b then f else g
03:58:40 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> m b -> m b -> m b
03:58:51 <aavogt> my non-unicode client here shows ?, so maybe tryhaskell is being confused by that too
03:59:04 <benmachine> frerich: ^ that's a generalisation of your function, you could possibly call it ifM
03:59:15 <parcs> aavogt: looks like an em dash
03:59:41 <benmachine> nah it's not wide enough
03:59:47 <benmachine> — that's an emdash
04:00:02 <parcs> ah yeah
04:01:18 <benmachine> it's a 'soft hyphen' apparently
04:01:24 <benmachine> > text "\xad"
04:01:25 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
04:01:27 <benmachine> :<
04:01:48 * merijn doesn't see anything weird after the first 9 and `mod`...
04:03:12 <augur> anyone have suggestions for how i should teach a friend to program?
04:03:21 <augur> like topics?
04:03:31 <augur> especially theory-oriented topics?
04:03:32 <merijn> augur: Depends on your friends background
04:03:45 <burp> what package provies the "best" either monad?
04:03:47 <augur> logic and natural language semantics
04:04:13 <augur> so hes familiar with LC
04:04:41 <augur> but he doesnt know anything special about programming related stuff
04:04:43 <merijn> No clue in that case :p
04:04:52 <augur> so its mostly going to be ground up
04:06:06 <burp> oh Control.Monad.Instances already defines it
04:07:59 <accel> what is fake about this quicksort? http://news.ycombinator.com/item?id=2648158
04:08:11 <accel> rather: http://news.ycombinator.com/item?id=2648158 <-- why does it say this quicksort is "fake"? what is fake about it?
04:08:15 <aavogt> I have a question re. avoiding an incoherent instance http://hpaste.org/47749
04:08:29 <merijn> accel: It's not how you would implement actual qsort in haskell if you want to be efficient
04:08:31 <saati> accel: pivot choice maybe
04:08:42 <accel> so it's fully functional and correct
04:08:42 <merijn> accel: It's fake in the sense that it is pretty looking but useless
04:08:47 <accel> just not the ideal way to implement it
04:08:49 <kosmikus> accel: it's not quick, because it makes use of inefficient ++, and it's not quicksort as an algorithm
04:08:54 <merijn> accel: For small n, it works perfectly fine
04:09:15 <merijn> accel: And indeed pivot choice is not entirely proper qsort
04:10:01 <aavogt> edwardk: would you know how to add that instance in the hpaste above?
04:10:10 <accel> merijn, saati , kosmikus : nice; thanks
04:11:01 <frerich> benmachine: Hm, I was thinking about your 'ifM' function, but I must admit I don't quite understand how "\p f g -> p >>= \x -> if x then f else g" is a generalization of "\p f g x -> if p x then f x else g x". I should be able to implement the latter function in terms of the former, right?
04:11:42 <benmachine> frerich: I did it off the top of my head so I might have screwed it up
04:11:54 <jaj> I was wondering if there was a lambdabot-like to embed in a webpage?
04:12:09 <benmachine> :t \p f g x -> if p x then f x else g x
04:12:09 <lambdabot> forall t t1. (t -> Bool) -> (t -> t1) -> (t -> t1) -> t -> t1
04:12:23 <benmachine> :t \p f g -> p >>= \x -> if x then f else g
04:12:23 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> m b -> m b -> m b
04:12:25 <merijn> jaj: Figure out what http://tryhaskell.org/ is doing?
04:12:48 <benmachine> frerich: do you see that the types unify?
04:13:23 <frerich> benmachine: I see a similarity, but I think I'm not familiar enough with monads yet to realize that I could have a monadic value with, when executed, yields the same bool value as some function (a->Bool)
04:13:44 <benmachine> frerich: ah, so you're not familiar with the Monad ((->) r) instance?
04:13:44 <frerich> benmachine: That is, how I could 'transform' my (a->Bool) predicate so that I could pass it as the first argument to 'ifM'.
04:13:54 <jaj> merijn: I couldn't remember tryhaskell, it uses mueval, thanks !
04:14:25 <frerich> benmachine: I fear I'm not, sorry. I'm only slowly getting a hang of this. :-}
04:14:48 <benmachine> frerich: well, the short answer is it will Just Work
04:15:09 <aavogt> you'll need some imports, since that instance isn't in the Prelude
04:15:16 <benmachine> oh yeah, Control.Monad.Instances
04:15:28 <frerich> Ah..
04:15:52 <benmachine> frerich: the long answer is that the type (r -> a) can also be written ((->) r a), and so if you substitute m = (->) r in the type of ifM you get the type of your function
04:16:07 <benmachine> frerich: you need Monad ((->) r), this is the so-called 'reader' monad
04:16:38 <frerich> Aha! I heard the name before, but I didn't know this connection.
04:18:24 <benmachine> frerich: a value of type r -> a can be seen as a computation that reads from an environment of type r and yields a value of type a
04:19:11 <frerich> Yep, makes sense. I just didn't know how to "transform" an r -> a value into a monadic value, but now I know the missing piece :)
04:19:19 <benmachine> it already is one :)
04:19:26 <benmachine> (as long as you have that damn instance)
04:19:34 <frerich> Yeah well, so far I didn't :-)
04:19:50 <albertid> Is there something like iterateN when I'm only interested in the final value? (e.g. f(f(f(f(n)))) )
04:20:25 <benmachine> albertid: inexplicably not, there are a few ways of writing that though
04:20:26 <aavogt> iterate f n !! m
04:20:30 <benmachine> there's that yes
04:20:45 <albertid> ah
04:21:02 <benmachine> there's also foldr (.) id (replicate m f) n
04:21:46 <albertid> right, thx :)
04:22:09 <frerich> benmachine: ifM is really cool
04:22:27 <benmachine> frerich: isn't it? kinda surprising it's not standard
04:23:56 <frerich> benmachine: I just used it to nicely update a list of records, like "map (ifM (playerHasName "Joe") updatePlayer id) players" <-- this yields a new list which is just like "players" except that the function "updatePlayer" is used for getting the new Player value for "Joe".
04:24:14 <benmachine> :)
04:24:20 <aavogt> http://hackage.haskell.org/trac/ghc/ticket/836 related to ifM
04:26:24 <parcs> :t foldr ($)
04:26:25 <lambdabot> forall b. b -> [b -> b] -> b
04:52:20 <roconnor> @hoogle diffTime
04:52:20 <lambdabot> Data.Time.Clock data DiffTime
04:52:20 <lambdabot> Data.Time.Clock data NominalDiffTime
04:52:20 <lambdabot> Data.Time.Clock picosecondsToDiffTime :: Integer -> DiffTime
04:54:12 <jaj> hmm in during the webkit compilation I get: Could not find module `System.Glib.GString'. glib does not seem to have a GString module.
05:04:55 <roconnor> any good way of finding the highest bit in a positive Integer?
05:05:49 <zygoloid> @hoogle log :: Integer -> a
05:05:50 <lambdabot> Prelude log :: Floating a => a -> a
05:05:50 <lambdabot> Prelude logBase :: Floating a => a -> a -> a
05:05:57 <zygoloid> hmm, maybe not
05:05:58 <sipa> roconnor: http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogObvious ?
05:07:52 * hackagebot egison 0.2.1.1 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-0.2.1.1 (SatoshiEgi)
05:12:09 <luite> roconnor: if you use it in ffi code C datatypes, you can use a gcc builtin __builtin_clz
05:12:46 <zygoloid> > let bits 0 = 1; bits n = go n 1 where go 0 _ = 0; go n k | s == 0 && k > 1 = go n (k `div` 2) | s == 0 = 1 | otherwise = k + go s (2*k) where s = n `shiftR` k in map bits [0,1,2,3,1023,1024,65535,65536,65537 :: Integer]
05:12:47 <lambdabot>   [1,1,2,2,10,11,16,17,17]
05:13:15 <luite> otherwise using the idea from this code (the nlz function) can be useful: http://www.hackersdelight.org/HDcode/ilog.c.txt
05:13:55 <zygoloid> luite: Integer, not Int :o
05:14:40 <luite> ah k, the nyou need a loop instead of a fixed number of comparisons :)
05:14:55 <zygoloid> if you can access the representation, it ought to be O(1)
05:14:59 <luite> but the binary search idea should still be applicable
05:15:15 <luite> O(1), how?
05:15:23 <zygoloid> the representation knows how many words long the integer is
05:15:41 <luite> does it always use the shortest number of words/
05:15:45 <luite> +possible
05:16:08 <zygoloid> i believe so. but i could be wrong :)
05:16:10 <luite> and least instead of shortest :p
05:16:12 <luite> hehe
05:17:47 <roconnor> @hoogle diffUTCTime
05:17:47 <lambdabot> Data.Time.Clock diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime
05:17:52 <zygoloid> i'm somewhat surprised there isn't a clz and a popcount in Bits
05:18:28 <zygoloid> hmm, i guess clz isn't the right primitive, but something like that
05:20:13 <Twey> clz?
05:20:37 <luite> count leading zeros
05:24:11 <rostayob> @pl genEdges (u, us) = map ((,) u) us
05:24:11 <lambdabot> genEdges = uncurry (map . (,))
05:33:11 <xkb> Hi
05:33:22 <xkb> I'm tinkering with Text.JSON
05:34:01 <xkb> and I'm trying to create a readJSON instance for something like this: Order {customer::String, bill::Bill}
05:34:13 <xkb> and I run into problems trying to read the JSON for Bill
05:34:53 <xkb> I somehow want to point to the readJSON implementation for Bill, so I tried lookup "bill" jsonObjAssoc >> =readJSON
05:35:01 <xkb> where jsonObjAssoc is a JSObject
05:35:29 <xkb> however, the type-checker can't figure that one out
05:35:42 <xkb> Couldn't match expected type `JSValue' with actual type `m0 b0'
05:35:52 <xkb> any tips on how to approach this?
05:50:39 <roconnor> > 10 * 1 `div` 10
05:50:40 <lambdabot>   1
05:52:16 <noteventime> xkb: I'm not sure if this is the nicest way, but wouldn't you have to match against the JSValue being an JSObject, then use fromJSObject to get an association list?
05:53:12 <xkb> noteventime: I played around with that, and it seems to work
05:53:12 <noteventime> I might be looking at the wrong json library
05:53:22 <xkb> Text.JSON
05:53:27 <noteventime> I agree that it isn't very pretty :p
05:54:15 <xkb> hmm now off to fight with ByteString
05:54:33 <xkb> got a lazy one, need a non-lazy one
05:54:59 * hackagebot hack2-contrib 2011.6.13 - Hack2 contrib  http://hackage.haskell.org/package/hack2-contrib-2011.6.13 (JinjingWang)
05:56:16 <dankna> BS.concat $ BSL.fromChunks myLazyByteString
05:56:23 <dankna> er
05:56:27 <dankna> s/fromChunks/toChunks/
06:11:47 <Baughn> > let a = a in a
06:11:51 <lambdabot>   mueval-core: Time limit exceeded
06:15:54 <trega_> :t vcat
06:15:55 <lambdabot> [Doc] -> Doc
06:16:10 <jaj> Baughn: evil
06:16:14 <trega_> > vcat [ text "Hello", text "World!" ]
06:16:15 <lambdabot>   Hello
06:16:15 <lambdabot>  World!
06:16:30 <absentia> yeas?
06:16:40 <trega_> hmmm
06:17:45 <trega_> > vcat [ repeat (text "Hello World!") ]
06:17:46 <lambdabot>   Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
06:17:46 <lambdabot>         agains...
06:17:56 <trega_> > vcat $ repeat (text "Hello World!")
06:17:56 <lambdabot>   *Exception: stack overflow
06:18:08 <trega_> damn, thought i was on to something
06:18:19 <Baughn> jaj: Testing a theory. I was trying to fix that two/three years back. Happy to see it's still broken.
06:18:39 <Baughn> jaj: GHC detects deadlocks just fine, it just doesn't throw an exception if there's any kind of signal handler installed.
06:18:39 <jaj> > vcat $ take 10 $ repeat (text "Hello World!")
06:18:40 <lambdabot>   Hello World!
06:18:40 <lambdabot>  Hello World!
06:18:40 <lambdabot>  Hello World!
06:18:40 <lambdabot>  Hello World!
06:18:40 <lambdabot>  Hello World!
06:18:42 <lambdabot>  Hello...
06:19:05 <erus`> > "\n\n\nhi"
06:19:08 <lambdabot>   "\n\n\nhi"
06:19:18 <erus`> > putStr "\n\n\nhi"
06:19:19 <lambdabot>   <IO ()>
06:20:18 <trega_> Baughn: the rts detects that infinite loop actually
06:20:35 <Baughn> trega_: That's what I said.
06:20:50 <trega_> Baughn: oh, i misinterpreted
06:22:50 <benmachine> Baughn: I think it only detects them if optimisations are enabled
06:22:57 <benmachine> or, some things it only detects if optimisations are enabled
06:23:46 <Baughn> benmachine: The blackhole logic is a pretty fundamental part of the system. Parallel haskell wouldn't work without it.
06:24:00 <Baughn> benmachine: But you may be right about some things. I seem to remember /something/ like that.
06:24:23 <benmachine> maybe you need to compile threaded then?
06:24:27 * benmachine shrug
06:24:34 <Baughn> ..right. That was it. :P
06:25:34 <trega_> > text "\n"
06:25:35 <lambdabot>  Terminated
06:37:59 <MasseR> Is there a function with a signature '[a] -> b -> [(a,b)]' which would replicate b so that the resulting list is as long as the original
06:38:27 <Baughn> \a b -> zip a (repeat b)
06:38:51 <MasseR> But there is no nice name for it? :)
06:39:03 <Baughn> @hoogle [a] -> b -> [(a,b)]
06:39:03 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
06:39:04 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
06:39:04 <lambdabot> Data.Graph.Inductive.Example genLNodes :: Enum a => a -> Int -> [LNode a]
06:39:08 <Baughn> Nope.
06:39:14 <MasseR> Okay, thanks
06:39:16 <Baughn> I guess it doesn't come up much
06:39:34 <Baughn> @pl \a b -> zip a (repeat b)
06:39:34 <lambdabot> (. repeat) . zip
06:39:54 <Baughn> ..right. Sometimes @pl produces usable code. This is not one of those times.
06:40:02 <MasseR> :D
06:40:08 <MasseR> I have yet to see it produce something readable
06:41:30 <Baughn> @pl \f g x -> f (g x)
06:41:30 <lambdabot> (.)
06:41:34 <Baughn> MasseR: There you go. :P
06:41:36 <MasseR> :D
06:42:11 <xplat> @tell isomorphic ĭt·ɚ·ə·tē′ for me
06:42:11 <lambdabot> Consider it noted.
06:43:50 <erus`> what does pl do?
06:43:51 <albel727> is there a good haskell IDE for linux? (autocompletion is the most wanted feature)
06:43:57 <MasseR> erus`: Makes pointfree
06:44:04 <MasseR> albel727: I use ivm
06:44:10 <MasseR> .. why can't I write vim
06:44:51 <albel727> hm
06:45:08 <albel727> you probably use some plugins for autocompletion and whatnot?
06:50:04 <tgeeky> hmm... can someone assist with my build error: http://hpaste.org/47757
06:51:57 <byorgey> tgeeky: run  ghc-pkg show random
06:52:09 <byorgey> I'm guessing maybe you have one installed globally and one locally?
06:52:17 <byorgey> er, ghc-pkg list random
06:53:27 <tgeeky> yep, and they are the same
06:53:33 <tgeeky> get rid of the local?
06:56:08 <mafs> In 'runCassandraT' I am calling catch' (which is just catches from Control.Exception with handlers applied already) to, naturally, catch exceptions, but am running into the problem that it demands I have a type signature including 'CassandraT IO a' instead of the more general 'CassandraT m a', since catches is so tied to IO.
06:56:14 <mafs> Any thoughts on how I could get the type signature to be 'runCassandraT :: (MonadIO m) => CassandraConfig -> CassandraT m a -> ...' again while still being able to catch exceptions? Code is at http://codepad.org/ZVasePrh
06:56:15 <byorgey> tgeeky: yes, get rid of the local, and reinstall any packages which depended on it
06:56:37 <byorgey> tgeeky: you'll know which ones depend on it because ghc-pkg unregister --user random   will warn you that they will break
06:56:59 <tgeeky> byorgey: yeah. unfortunately it's a lot, but I got it. thanks
06:57:25 <byorgey> tgeeky: yeah, sorry, sometimes cabal gets confused like this, dunno why
06:57:34 <byorgey> tgeeky: what version of cabal do you have?
06:57:58 <tgeeky> cabal-install version 0.10.2 using version 1.10.1.0 of the Cabal library
06:58:09 <luite> tgeeky: I usually only install packages with --user because of this
06:58:14 <byorgey> ok, yeah, that's the latest version there is
06:58:23 <tgeeky> luite: my base is haskell-platform, which I think included it.
06:58:31 <tgeeky> I never explicitly install globally, so I assume that it's always installed user
06:58:38 <luite> hmm
06:58:47 <tgeeky> it must have happend
06:58:52 <byorgey> yeah, cabal always installs things locally by default
06:58:58 <tgeeky> i installed 'hulk'
06:59:25 <tgeeky> dunno why it owuld have broken something
06:59:49 <luite> it can sometimes build the same version of a package with different dependencies
07:00:14 * hackagebot darcs-monitor 0.4.2 - Darcs repository monitor (sends email)  http://hackage.haskell.org/package/darcs-monitor-0.4.2 (MarcoSilva)
07:00:16 <tgeeky> *something* broke QuickCheck, IOSpec, show, Streams ... which broke my lambdabot
07:00:32 <tgeeky> and we all know how one misses a lambdabot
07:00:37 <tgeeky> when one does not have
07:17:31 <burp> hm, null <- openFile "/dev/null" WriteMode
07:17:39 <burp> runProcess "/bin/ls" ["/"] Nothing Nothing (Just null) (Just null)
07:17:43 <burp> erm
07:17:47 <burp> runProcess "/bin/ls" ["/"] Nothing Nothing Nothing (Just null) (Just null)
07:18:02 <burp> why does this throw an exception "/bin/ls: runProcess: invalid argument (Bad file descriptor)" ?
07:18:19 <burp> I want to pipe stdout and stderr to /dev/null
07:19:29 <tgeeky> do you want to list /, or .?
07:19:52 <burp> tgeeky: it was just an example
07:20:11 <burp> I want to run something else, but get the error when I set stderr and stdout to /dev/null
07:22:09 <burp> oh wait
07:22:22 <trega_> @hoogle system
07:22:22 <lambdabot> No results found
07:22:30 <burp> it's ok, I found the problem
07:22:37 <tgeeky> burp: which was?
07:22:52 <burp> I used the handle multiple times for multiple runProcess calls
07:24:24 <burp> seems the runProcess blocks the handle (or closes it), whatever
07:36:41 <taotree> I have this function: mapMM = flip $ fmap . fmap  but I am in a place that must return IO ()
07:37:55 <taotree> I'm calling mapMM maybeSomething (\x -> someCode)   but someCode return IO (something)
07:38:11 <taotree> is there something I can do to mapMM to "ignore" the stuff in IO (...) so it will match the needed IO ()?
07:38:24 <monochrom> (\x -> someCode >> return ())
07:39:00 <taotree> monochrom, thanks, but can I do it to mapMM because this happens in many places?
07:39:11 <taotree> so I don't have to write >> return () all over
07:39:41 <monochrom> yes but I'm too lazy to do it
07:40:36 <byorgey> just insert (>> return ()) in the propert place in mapMM
07:40:40 <byorgey> *proper
07:41:12 <byorgey> finding the proper place is left as an exercise for the reader ;)
07:41:44 <taotree> yes, well, I had already tried (\a -> return ()) . flip $ fmap . fmap   ...
07:41:51 <taotree> I guess I'll just have to keep trying things
07:41:57 <robertosucks> i am following Learn you Haskell, but it has no exercises, where can i find some exercices to do?
07:43:57 <roconnor> @undo do { 0 <- foo }
07:43:57 <lambdabot>  Parse error at "}" (column 15)
07:44:04 <roconnor> @undo do { 0 <- foo; return () }
07:44:04 <lambdabot> foo >>= \ a -> case a of { 0 -> return (); _ -> fail ""}
07:44:37 <Yrogirg> Hello! How do I tell GHC that a certain expression (of type Double that is represented as a formula) should be fully evaluated during compilation? So for example it would use 4.2326514735445615 instead of (512 / 0.844)**(1/3)
07:45:29 <byorgey> taotree: don't just try things, figure out the type of each piece
07:46:29 <byorgey> Yrogirg: if you specify that it is of type Double it should be.  I.e. add a type signature.
07:46:31 <taotree> byorgey, yes, that's what I was trying to do :)  but that requires understanding I have not yet achieved.
07:46:48 <byorgey> if it really is not being evaluated it is probably because it has type  Floating a => a  or something like that
07:46:56 <taotree> I got it working by using a do block but... that's really cheating and I think I could do better.
07:47:38 <byorgey> @type fmap
07:47:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:47:42 <byorgey> @type fmap . fmap
07:47:43 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
07:47:53 <byorgey> @type flip $ fmap . fmap
07:47:54 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => f (f1 a) -> (a -> b) -> f (f1 b)
07:47:56 <robertosucks> can someone please recommend me some exercises?
07:49:01 <byorgey> robertosucks: http://www.haskell.org/haskellwiki/99_Haskell_exercises
07:49:08 <byorgey> robertosucks: http://www.haskell.org/haskellwiki/Blog_articles/Exercises
07:49:22 <taotree> do block goes to: mapMM m f = (flip $ fmap . fmap) m f >> return ()  . that works. Can I convert to point-free?
07:49:28 <byorgey> robertosucks: http://dibblego.wordpress.com/2008/09/18/20-intermediate-haskell-exercises/
07:49:36 <robertosucks> thank you
07:49:37 <Yrogirg> byorgey, I have declared it to be Double, it doesn't help. O3 or O2 doesn't matter. It is not the first time I've encountered that problem.
07:49:55 <byorgey> Yrogirg: are you compiling with -O2?
07:50:01 <Yrogirg> yes
07:50:08 <byorgey> Yrogirg: hmm, I don't know then
07:50:54 <Yrogirg> maybe I shall try ghc maillist
07:51:38 <byorgey> taotree: yes, but I don't recommend it
07:51:42 <taotree> erg, thought I had already tried this, but it worked now:   mapMM = (\m f -> return ()) . (flip $ fmap . fmap) Not sure if that's the pretties solution, but... it works and seems reasonable
07:51:55 <taotree> byorgey, oh, ok
07:52:04 <byorgey> @pl \m f -> (flip $ fmap . fmap) m f >> return ()
07:52:04 <lambdabot> flip flip (return ()) . ((>>) .) . flip (fmap . fmap)
07:52:35 <taotree> ah, I get it
07:52:36 <byorgey> @type (\m f -> return ()) . (flip $ fmap . fmap)
07:52:37 <lambdabot> forall t (m :: * -> *) (f :: * -> *) a (f1 :: * -> *). (Monad m, Functor f, Functor f1) => f (f1 a) -> t -> m ()
07:52:37 <taotree> thanks!
07:52:56 <byorgey> taotree: that version is not the same thing, it ignores the second argument
07:53:25 <byorgey> actually it ignores both arguments
07:53:57 <byorgey> just because it typechecks doesn't ALWAYS mean it is correct =)
07:53:57 <taotree> right, I think mapMM m f = (flip $ fmap . fmap) m f >> return () is probably the most readable so far. I'll stick with that
07:54:08 <byorgey> agreed.
07:54:15 <taotree> thanks!
07:57:23 <Martty> quick help, haskell is the right tool
07:57:52 <Martty> i need all the possible tuples combinations from the set [1..8] such that the sum is less than 8 too
07:58:22 * zygoloid ponders if dibblego considers using 'fmap' etc to be cheating in his exercises
07:59:14 <adimit> Martty: a simple list comprehension?
07:59:21 <adimit> > [ (x,y) | x <- [1..8], y <-[1..8], x+y < 8 ]
07:59:22 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3...
07:59:54 <basti_> Martty: 2-tuples or any-tuples?
08:00:29 <Martty> thanks
08:04:38 <adimit> actually, this only gets interesting to implement with any-tuples.
08:04:56 <adimit> I guess dependent types could make that a little more trivial.
08:07:19 <ShaneHudson> Hey all
08:07:37 <ShaneHudson> Does anyone know if there is a version of LearnYouAHaskell on Kindle for free like the online version?
08:11:41 <ivan> Kindle can run Duokan which can read pdf and epub
08:12:36 <ivan> (oh yeah, those aren't free)
08:23:58 <ShaneHudson> I just found it in the Kindle Amazon store... £20. If I were learning for a job or something I would get it but as it is just for interest, I cannot really afford it (especially when the online version is free and very good)
08:31:17 <roconnor> how do I turn a .hp file into a pretty graph?
08:31:55 <monochrom> is it hp2ps?
08:33:58 <Peaker> I remember it was slightly annoying to get from profile results to presentable image
08:35:32 <roconnor> monochrom: thanks
08:36:30 <roconnor> Hmm, 20 megabytes; that isn't so bad
08:36:45 <roconnor> half of that is Data.Map.Bin
08:40:23 <ezyang> What's a nice, simple HAskell expression that, when evaluated, is very big in memory, but is not trivially fusable.
08:43:26 <djahandarie> Anything that would use augment fusion but on a non-list, so it can't use augment fusion, maybe.
08:43:57 <jmcarthur> augment fusion?
08:43:57 <lambdabot> jmcarthur: You have 1 new message. '/msg lambdabot @messages' to read it.
08:44:45 <ezyang> augment fusion?
08:44:51 <jmcarthur> ezyang: cool! guess i'll see you at jane street
08:45:05 <djahandarie> "foldr/augment" forall k z xs (g::forall b. (a->b->b) -> b -> b) . foldr k z (augment g xs) = g k (foldr k z xs)
08:45:08 <djahandarie> This one
08:45:28 <ezyang> Yep :-) Are you coming to Hac Phi>?
08:45:36 <hpaste> exeter pasted “indent problem?” at http://hpaste.org/47764
08:45:56 <djahandarie> "augment/build" forall (g::forall b. (a->b->b) -> b -> b) (h::forall b. (a->b->b) -> b -> b) . augment g (build h) = build (\c n -> g c (h c n)) -- also
08:46:05 <jmcarthur> the move to NYC has almost all of my attention right now, but right now i'm planning to go to hac phi, yes
08:46:07 <ezyang> Hmmm.
08:46:16 <djahandarie> Those only work on non-branching recursive data types
08:46:34 <exeter> I'm having a bit of a problem which left me puzzled. It probably regards indenting an "if". http://hpaste.org/47764 <- here's the code, description of the problem is inside. Any help appreciated!
08:46:39 <quicksilver> exeter: that shold not be indentation.
08:46:47 <quicksilver> exeter: you aren't in a layout construct, so indentation is not relevant.
08:47:20 <exeter> quicksilver: I am sorry I am not understanding what you are sayin. Can you please reword it?
08:47:26 <exeter> oh
08:47:27 <exeter> wait
08:47:31 <quicksilver> exeter: indentation does not matter in general.
08:47:46 <quicksilver> it only matters, specifically, in do blocks and lets and wheres.
08:48:00 <exeter> and with this hint, you've almost solved my problem
08:48:05 <quicksilver> exeter: I think your problem is, rather, that (++) binds stronger than "else"
08:48:11 <exeter> not the question is, how can I "terminate" an if?
08:48:28 <quicksilver> same way you make anything bind tighter than infix
08:48:30 <exeter> oh
08:48:30 <quicksilver> put it in ()
08:48:45 <quicksilver> (if foo then bar else baz) ++ (if foozle then barzle else bazzle)
08:48:49 <exeter> reasonable
08:49:15 <quicksilver> > if True then 0 else 1 + if True then 5 else 7
08:49:16 <lambdabot>   0
08:49:30 <quicksilver> ^^ proof that else binds tighter than +.
08:49:43 <quicksilver> > (if True then 0 else 1) + (if True then 5 else 7)
08:49:44 <lambdabot>   5
08:50:03 <quicksilver> (neither + nor ++ is special -- else binds stronger than all operators)
08:50:24 <benmachine> else extends as far to the right as possible iirc?
08:50:27 <quicksilver> yes.
08:50:39 <quicksilver> that's a clearer way of saying "else binds stronger than all operators" ;)
08:50:46 <exeter> mhhh, it worked and I must say thank you, still, isn't if a keyword?
08:50:55 <exeter> I mean, I know this is just speculation
08:51:18 <exeter> but wouldn't it be right for "if" to behave like where and let?
08:51:28 <hpc> quicksilver: perhaps it would be clearer to say "syntax binds tighter than all operators"?
08:51:35 <quicksilver> hpc: possibly, yes.
08:51:37 <exeter> or is it just sugar?
08:51:46 <quicksilver> exeter: it doesn't need to, that's all
08:51:47 <hpc> syntax sugar is still syntax
08:52:02 <exeter> yes, I felt if was syntax
08:52:03 <quicksilver> exeter: where and let (and do) all support an arbitrarily large number of parts, separated by ;
08:52:04 <exeter> isn't it?
08:52:21 <quicksilver> the ; can be replaced by newlines and indentation - this is the layout construction.
08:52:38 <quicksilver> if/then/else doesn't have an arbitrary number of parts, it doesn't use ;, so layout doesn't apply.
08:53:04 <exeter> fair enough
08:58:31 <exeter> quicksilver: I am not using do notation and still indentation works. I'm guessing you meant monadic code with "do"?
08:59:32 <quicksilver> exeter: ..... don't understand the question.
08:59:42 <quicksilver> exeter: indentation is only relevant in do/let/where/case
08:59:54 <quicksilver> exeter: in other places you are free to indent, or not, exactly as you please.
09:00:32 <tromp_> what about if then else?
09:00:58 <hpc> if-then-else forms a single expression
09:01:06 <exeter> quicksilver: I am avoiding do (using >>= and >> and \stuff -> inst- ok, I finally got it, thanks quicksilver
09:01:33 <exeter> (tutorials are pretty lax on this)
09:02:41 <xplat> i kind of wish haskell had some kind of 'annotations' on datatypes
09:03:02 <hpc> what sort of annotations?
09:03:03 <adimit> xplat: what do you mean? GHC provides the SPECIALIZE and ANN pragmas.
09:03:19 <xplat> that you would be able to access by TH and syb
09:09:08 <dbpatterson1> anyone around who understands happstack state? Specifically, I'm trying to export data from a system that is running version 0.4, but cant seem to install that version anymore (so I think I need to use 6.0)….
09:10:04 <dbpatterson1> more generally, is there a way to get data out without having the code that created it available to compile / interpret (it is all depending on old, not working with current GHC, libraries)
09:13:51 <dbpatterson1> my problem is, I have a compiled binary that is running fine, but I want to migrate the application to using current libraries so it is actually modifiable. I've written a new version of the webapp, but don't know how to get the data back out, as the only obvious ways seem to require being able to compile the code that describes the data…
09:13:54 <xplat> ANN pragmas are similar to what i would want, but 1) there's no namespacing for annotations to stop them from stepping on each other 2) annotations can only be inspected via the GHC API
09:15:10 <thoughtpolice> yeah, annotations are only persisted via interface files at the moment. right now, you actually even need to actually hack GHC to use them. once the plugins stuff goes through (SPJ is apparently looking into it) it should be easier to do at least
09:17:47 <xplat> what brought this up is that i need an embeddable lisp interpreter to be able to see a bunch of state in the embedding app as variables
09:18:18 <absentia> n/win shrink 3
09:22:41 <erus`> who would win a chess match between the ghc developers and the core gcc maintainers ?
09:22:55 <dmwit> More importantly, who would win a go match?
09:23:21 <erus`> the go-lang developers ?
09:23:30 <geheimdienst> most importantly, who would win a "make a compiler" match?
09:23:31 <erus`> rob pike is good at chess i think
09:23:38 <geheimdienst> of course we know the answer to that one
09:24:31 <erus`> fight fight fight
09:28:01 <burp> @oeis 1, 1499999, 1374998250001, 3124994250006499997
09:28:02 <lambdabot>  Sequence not found.
09:35:08 <sm> morning all
09:35:25 <sm> why does that function give that warning, exactly ? https://gist.github.com/1023183
09:38:43 <byorgey> sm: those last two patterns will both match lists of the form (QueryOptInAcct _ : _)
09:39:00 <byorgey> sm: it doesn't mean something is wrong
09:39:08 <lispy> preflex: seen pastorn
09:39:08 <preflex>  pastorn was last seen on #haskell 7 days, 20 hours, 8 minutes and 41 seconds ago, saying: SDL another
09:39:13 <sm> byorgey: I thought it would take the first one and .. guess not
09:39:21 <sm> I would like to write this warning free though
09:40:08 <byorgey> sm: the code will work fine, it's a bit annoying that you get this warning
09:40:35 <byorgey> sm: the only way to have it be warning-free is to add a case for every QueryOpt constructor other than QueryOptInAcct
09:40:45 <byorgey> but that is super annoying depending how many there are
09:41:26 <parcs> what about something like inAccount (o:os) = case o of QueryOptInAcc a -> Just a; _ -> inAccount os
09:41:54 <byorgey> ah, yes, that works
09:42:17 <sm> I'll do that.. thanks, both
09:43:22 <byorgey> you could also write it as  inAccount = msum . map foo  where foo (QueryOptInAcct a) = Just a; foo _ = Nothing
09:43:35 <byorgey> with a better name for foo of course
09:45:48 <sm> nice
09:46:03 <rostayob> when making foreign calls, what are the rules for the call to be thread-safe? Is it enough to know that the called C function doesn't use globals?
09:48:28 <rostayob> (not really a haskell question I guess, but I'm puzzled about the behaviour of a foreign library a wrote)
09:50:38 <hpaste> TravisD pasted “Irreducible Sequences” at http://hpaste.org/47767
09:51:52 <TravisD> Hi, I just posted a fairly long question on hpaste. I'm mostly looking for suggestions on my style. I started reading Real World Haskell a few days ago so I'm not too familiar with Haskell.
09:52:25 * sm can't get make that second variant work without the warning, never mind
09:53:36 <byorgey> TravisD: noRepeatedPrefix = not . hasRepeatedPrefix
09:53:58 <TravisD> byorgey: Is that a lower precedence function call operator?
09:54:04 <TravisD> oh
09:54:05 <TravisD> no
09:54:06 <TravisD> composition
09:54:09 <byorgey> TravisD: right
09:54:47 <byorgey> TravisD: also, for implementing hasRepeatedPrefix I'd use a more "holistic" approach, i.e. a sequence of transformations of the entire data structure, something like:
09:55:18 <byorgey> first, generate all the "splits" of the string, i.e.  "abcd" -> [("a","bcd"), ("ab","cd"), ("abc","d")]
09:55:35 <TravisD> ah, yeah. I thought about doing that, but then thought it was inefficient
09:55:42 <TravisD> but I guess what I have isn't any better
09:55:51 <byorgey> then   map (uncurry isPrefixOf)
09:56:14 <byorgey> in fact, forget map, just do  'any (uncurry isPrefixOf)'
09:56:57 <TravisD> That's much better :)
09:57:47 <byorgey> you can gain a bit of efficiency by only considering splits up to halfway
09:58:04 <byorgey> e.g. we know that "abc" can't possibly be a prefix of "d" since it is longer
09:58:30 <byorgey> so you can insert  (takeWhile (\(a,b) -> length a > length b)
09:58:46 <byorgey> make that >=
09:59:44 <tgeeky> byorgey: I don't know the specifics, so I may be making incorrect assumptions, but wasn't there a push to redefine a lot of structure in haskell (or ghc?) using monad transformers, at some recent point?
09:59:55 <tgeeky> ie, perhaps after you wrote your Typeclassopedia?
10:00:13 <TravisD> byorgey: Ah. I was avoiding computing lengths because it's not cheap but I guess once you have a single split where the prefix is longer than the tail you can stop looking at everything after that
10:00:40 <byorgey> as for generating splits you could just do something like   zipWith splitAt [1..] (repeat str)
10:00:53 <tgeeky> byorgey: looks like this is what mtl 2.x did...
10:00:55 <byorgey> TravisD: length is cheap enough when the lists are short.
10:01:02 <joe6> anything in haskell to read a C file?
10:01:08 <TravisD> byorgey: Alright :)
10:01:12 <byorgey> TravisD: appending to the end of a list  like prefix ++ [head rest] is also not cheap =)
10:01:25 <TravisD> I know :(
10:01:38 <byorgey> joe6: http://hackage.haskell.org/package/language%2Dc
10:01:43 <joe6> i want to translate a C file to an assembly file. just a literal translation would do.
10:01:54 <TravisD> byorgey: The laziness is nice
10:02:41 <byorgey> TravisD: yes, laziness makes it efficient to think in terms of composing a bunch of transformations of an entire data structure
10:02:48 <TravisD> yeah
10:03:04 <joe6> byorgey: do you think language-c is the best bet when I want to translate a  C file to a device-specific asm?
10:03:09 <byorgey> TravisD: whereas without laziness you have to manually "fuse" all the traversals together into a single loop
10:03:11 <tgeeky> TravisD: a rather nice reversal from the negative connotation that 'lazy' carries in real life
10:03:11 <TravisD> byorgey: Thanks for taking some time to think about the problem :)
10:03:23 <byorgey> TravisD: sure =)
10:03:49 <byorgey> joe6: uh, I think a compiler like gcc is the best bet if you want to convert a C file to asm
10:04:06 <byorgey> or do you mean you want to generate the asm yourself?
10:04:39 <joe6> the catch is that this is pic (microchip) asm and it does not have good compilers.
10:05:12 <byorgey> joe6: I see.  then yes, language-c should work well for you.  It parses a C file and gives you an AST to work with.
10:05:21 <joe6> hence, wanted to see if there were any easier ways to generate the asm.
10:05:43 <byorgey> supposedly it is even able to parse the linux kernel source
10:05:55 <joe6> ok, cool. thanks. will check it out.
10:06:31 <byorgey> joe6: and for working with large ASTs you may be interested in using a package that lets you write generic traversals, such as uniplate.
10:06:55 <joe6> byorgey, btw, do you know of the simplest asm backend that gcc supports?
10:07:17 <joe6> i could try to use gcc to generate asm for that backend and then translate that asm to my device asm
10:07:17 <byorgey> joe6: no idea, sorry
10:07:25 <joe6> ok, thanks.
10:08:05 <byorgey> tgeeky: the newest version of mtl redefined all the "basic" monads as applications of their transformer variants to Identity, like State = StateT Identity, etc.
10:08:23 <byorgey> tgeeky: I don't think this corresponds to any sort of "big push"
10:08:32 <byorgey> just something that was done in the mtl package.
10:08:49 <Cale> I'm not sure I understand why that was done.
10:09:07 <tgeeky> byorgey: ok, but one (me) should understand monads at this level, instead of at the individual level?
10:09:19 <tgeeky> to ensure I get the full picture?
10:09:26 <Cale> The non-transformer versions are probably faster by a decent margin, unless something has changed about GHC in recent times.
10:09:32 <tgeeky> byorgey: nice irc backtrack memeory, btw ;)
10:09:58 <byorgey> tgeeky: hehe, I think my mental stack can hold about three slots, so you were close ;)
10:09:59 <Cale> tgeeky: Monad transformers are less important than the basic abstraction of monads.
10:10:18 <hpaste> TravisD pasted “Cleaner hasRepeatedPrefix” at http://hpaste.org/47768
10:10:24 <Cale> But once you understand monads, it's not so hard to understand monad transformers anyway.
10:10:25 <byorgey> tgeeky: yes, I don't think you need to understand this
10:10:41 <tgeeky> byorgey: ok. I just see *dozens* of exception handling libraries and whatnot
10:10:58 <Cale> Dozens? :)
10:11:03 <tgeeky> yeah, seriously :o
10:11:05 <Cale> I can only think of... 3?
10:11:25 <tgeeky> there's at least 4 in the "monad" category
10:11:29 <TravisD> byorgey: Thanks again :) The different style is really great
10:11:38 <Cale> There's the Haskell 98 IO exceptions in the Prelude. There's the old version of Control.Exception, and then there's the new version of Control.Exception
10:11:40 <TravisD> byorgey: Very satisfying
10:11:46 <byorgey> TravisD: great =)
10:12:17 <Cale> OUCH
10:12:32 <Cale> TravisD: that takeWhile is rather expensive
10:12:34 <tgeeky> Cale: hackage -> grep "exception"
10:12:50 <TravisD> Cale: Yeah
10:12:52 <byorgey> Cale: I told him to do it =)
10:13:08 <byorgey> it's not that bad for short strings.
10:13:12 <Cale> I guess so
10:13:19 <tgeeky> TravisD: there's a reason that optimization is late in RWH
10:13:34 <adimit> 'cause it's pretty arcane, and rarley useful :-P
10:13:40 <Cale> tgeeky: ah, okay, don't worry about most of those :)
10:14:07 <tgeeky> TravisD: by the way, the QuickCheck section on RWH is old and the code doesn't work anymore. Use this page: http://cseweb.ucsd.edu/classes/wi11/cse230/lectures/quickcheck.html instead, when you get there. (Chapter 13)
10:14:20 <Cale> tgeeky: A nice thing about Haskell is that it's expressive enough that exceptions can be a library, but that means that people are free to do them in their own way.
10:14:54 <tgeeky> Cale: yeah, I was trying to see if there was an obvious reason why people chose to reinvent the wheel so many times
10:14:58 <TravisD> byorgey: Cale: The sequence (a1, b1), (a2, b2), … is such that length(a_n) = 1+length(a_{n-1}). You could compute the length of a1 and then take the right number
10:15:12 <tgeeky> and, evidently it's not that mtl uses transformers, it's just that people like their own thing
10:15:17 <xplat> tgeeky: it's still not as bad as strings in C++ ...
10:15:29 <monochrom> hahaha
10:15:38 <tgeeky> xplat: touche'
10:15:39 <Cale> TravisD: exactly, yeah
10:16:24 <Cale> tgeeky: I also think a fair number of them are sort of experiments into what's possible to do.
10:16:57 <ben> So what's the preferred error handling style in pure code? An Either-like monad or just doing everything explicilty?
10:17:05 <tgeeky> Cale: ok. I had the though that it would be nice for [cabal || hackage] to support a "this might deprecate (another person's) package [package]"
10:17:18 <byorgey> TravisD: yes, that's a good approach
10:17:21 <hpaste> TravisD pasted “Faster” at http://hpaste.org/47769
10:17:22 <tgeeky> right now, my best way to estimate such a concept is to look at the dates on pages
10:18:06 <byorgey> TravisD: nice
10:18:38 <xplat> ben: the preferred style is to prevent errors at compile time.  barring that, Maybe, Either, or Control.Exception (it depends how many ways are left that things can go wrong)
10:18:42 <TravisD> :) Is it irritating to paste so many changes?
10:18:55 <Cale> TravisD: I wouldn't worry about it :)
10:19:15 <byorgey> TravisD: you can paste modifications to a paste as "annotations"
10:19:24 <Cale> tgeeky: Another thing you'll find a fair number of is libraries of concurrency abstractions. The number of libraries on Hackage is so big now that I can't even hope to understand them all.
10:19:25 <TravisD> Ah okay
10:19:25 <byorgey> but yes, I wouldn't worry about it =)
10:19:50 <byorgey> chrisdone++
10:19:55 <byorgey> new hpaste is nice =)
10:19:56 <tgeeky> Cale: yep. I trust that the ones pointed to by SPJ and SimonMar are the best ones to use :)
10:20:01 <Cale> tgeeky: When I started out in Haskell, it was basically possible to know every library in existence :)
10:20:09 <Cale> Well, maybe :)
10:20:11 <xplat> ben: Maybe if only one thing can go wrong, Either if only one kind of thing can go wrong, Control.Exception for a minefield :)
10:20:24 <tgeeky> Cale: rather, the first ones to get familiar with, not the best to use
10:20:25 <ben> heh,ok
10:20:28 <Cale> yeah
10:20:44 <Cale> And you can always ask around in here to find out what people like.
10:20:45 <monochrom> yikes, why is it so narrow?
10:21:28 <Cale> monochrom: I think it widens to fit the pasted text at least.
10:28:45 <hpaste> TravisD annotated “Faster” with “Faster (annotation)” at http://hpaste.org/47769#a47770
10:45:35 * roconnor uses top level pattern matching
10:46:39 <roconnor> I kinda wish I could get compile time errors when top level patterns fail to bind.
10:47:22 <c_wraith> when do top-level patterns fail to bind?
10:47:35 <roconnor> when I do Right name = Left "foo"
10:47:36 <c_wraith> compile-time constants that change from install to install?
10:48:15 <geheimdienst> > let (Right "lolcat") = Left 42 in 1
10:48:16 <lambdabot>   1
10:48:28 <geheimdienst> > let ~(Right "lolcat") = Left 42 in 1
10:48:29 <lambdabot>   1
10:48:47 <roconnor> I'll use a twiddle if I don't want a compile time check :D
10:48:48 <c_wraith> let bindings are already irrefutable :)
10:48:54 <geheimdienst> > let !(Right "lolcat") = Left 42 in 1
10:48:54 <lambdabot>   *Exception: <interactive>:3:4-30: Non-exhaustive patterns in pattern binding
10:49:08 <geheimdienst> c_wraith: thanks, didn't know that
10:49:27 <geheimdienst> "non-exhaustive patterns" is kind of a roundabout way to say it, but well ...
10:51:10 <c_wraith> > let f (a, b) = 7 in f undefined
10:51:11 <lambdabot>   *Exception: Prelude.undefined
10:51:17 <c_wraith> > let f ~(a, b) = 7 in f undefined
10:51:18 <lambdabot>   7
10:51:40 <c_wraith> > let f x = let (a, b) = x in 7 in f undefined
10:51:41 <lambdabot>   7
10:51:52 <c_wraith> That's actually how irrefutable pattern matches are translated
10:52:32 <c_wraith> which also explains why you get that particular error message
10:52:33 <geheimdienst> "irrefutable" means "match the stuff, do it now", right? which means irrefutable, "~" or "!"?
10:52:53 <c_wraith> irrefutable means "I assure you, this is exactly the form I tell you it is"
10:52:56 <c_wraith> which is ~
11:03:32 <lpsmith> basically irrefutable delays pattern matching until the last possible moment
11:04:33 <Eelis> lpsmith: why isn't that the default, anyway?
11:04:37 <geheimdienst> aaaah now i get it. so ! means "do it now" and ~ means the opposite
11:05:05 <lpsmith> Eelis: because you can't branch using irrefutable patterns
11:05:22 <Eelis> lpsmith: but it could be the default for branchless cases, no?
11:05:29 <Eelis> (or single-branch cases)
11:06:01 <Eelis> i mean when there's only one "alternative"
11:06:56 <lpsmith> Eelis: yes,  but why not just make it explicit at that point?  Why introduce a "discontinuity" into the meaning of your language in one case statement versus multiple case statements?
11:07:13 <lpsmith> Let statements are irrefutable by default though.
11:07:16 <Eelis> discontinuity? it seems like the natural behavior in a language that claims to be lazy
11:07:53 <Eelis> having to say "please be lazy here" is completely counterintuitive
11:08:02 <lpsmith> Eelis: lazy evaluation (without irrefutable patterns) already goes a long way to delaying pattern matching to a point in time close to the last possible moment :)
11:08:15 <Eelis> yes, it goes a long way, so why the bizarre exception?
11:08:39 <monochrom> it is hellish to change strictness by just counting the number of alternatives
11:08:47 <Eelis> why?
11:09:14 <lpsmith> What isn't obvious about Haskell is that it matters how you write a function,  things aren't as lazy as they can be automatically
11:09:15 <Eelis> it seems 100% natural to me
11:09:21 <monochrom> because I change the number of alternatives all the time without intending change of strictness like that
11:09:23 <lpsmith> > tails undefined
11:09:24 <lambdabot>   *Exception: Prelude.undefined
11:09:27 <Eelis> lpsmith: yeah, and i don't see a good reason for that in this case
11:09:43 <lpsmith> @src tails
11:09:43 <lambdabot> tails []         = [[]]
11:09:44 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
11:09:56 <Eelis> monochrom: i don't. whenever i have a single alternative, i want the laziest behavior possible
11:10:09 <lpsmith> @let mytails xs = xs : if null xs then [] else tails (tail xs)
11:10:11 <lambdabot>  Defined.
11:10:17 <lpsmith> > mytails undefined
11:10:19 <lambdabot>   [*Exception: Prelude.undefined
11:10:31 <frerich> byorgey: I only know (by following this IRC channel) realized that you wrote the Typeclassopedia article. Thank you! I still return to it every now and then, and I still find stuff I didn't really realize the first time I read it. I wish there were more articles like this.
11:10:52 <monochrom> so it comes down to "why isn't haskell defined tailored to your habits"?
11:11:02 <byorgey> frerich: thanks, glad you find it useful!
11:11:07 <monochrom> well, because you weren't on the committee
11:11:22 <lpsmith> my definition is a teensy bit lazier than the default (arguably more "natural") definition,  and it's not something that can be fixed via irrefutable patterns.
11:11:22 <Eelis> monochrom:  more like "why is haskell advertised as a lazy language and then suddenly made needlessly non-lazy in some cases?"
11:11:47 <geheimdienst> monochrom: i do think eelis has a point. it's not just his "habit"
11:12:06 <lpsmith> Eelis: I'm not so sure it's "needless"
11:12:15 <Eelis> lpsmith: the existence of ~ proves it's needless
11:12:58 <lpsmith> I disagree,  I don't think you fully appreciate lazy evaluation,  irrefutable patterns, and the interaction between the two yet :)
11:13:08 <Eelis> bah, what a cop-out
11:13:11 <monochrom> well then, now you know it is somewhat lazy but not extremely lazy
11:14:19 <monochrom> you can also complain about "if blah then () else ()" needlessly non-lazy or strict about blah
11:14:23 <lpsmith> Eelis: even if we changed the language as you suggest,  it doesn't get you off the hook from understanding lazy evaluation,  and writing two functions in two seemingly similar ways could still lead to different laziness properties.
11:14:28 <Eelis> monochrom: i knew that already. what i didn't know was the excuses people have for it. i'm not impressed :)
11:14:48 <byorgey> frerich: I am working on a second edition, so if you ever have any suggestions for improvements I'd love to hear them
11:15:04 <monochrom> then don't be impressed
11:15:08 <Eelis> lpsmith: i never claimed that changing the language as i suggest would mean people would no longer need to think about lazy evaluation, so this is a complete strawman :)
11:15:55 <monochrom> people say things like "____ is an OO language" all the time, with ___ not being 100% OO
11:16:15 <monochrom> so I don't see what's wrong with "___ is a lazy language" with ___ not being 100% lazy
11:16:25 <Eelis> heh, the "at least we're not as bad as those other guys" argument. one of the most desperate kind
11:16:42 <monochrom> no, not that argument
11:17:17 <monochrom> my point is "xxx is yyy" has never meant "100% yyy no concession no compromise, pure 100% yyy" in usual language
11:18:20 <monochrom> hell, "___ is a tall guy" never means "___ is the tallest possible guy" even
11:18:33 <monochrom> so nevermind "100% pure tall, no compromise"
11:18:45 <monochrom> the guy will always be shorter than ideal
11:18:49 <roconnor> @hoogle allM
11:18:49 <lambdabot> Text.Regex.Base.RegexLike newtype AllMatches f b
11:18:50 <lambdabot> Text.Regex.Base.RegexLike AllMatches :: f b -> AllMatches f b
11:18:50 <lambdabot> Text.Regex.Base.RegexLike getAllMatches :: AllMatches f b -> f b
11:19:41 <Eelis> monochrom: i specifically made sure to say "needlessly" to emphasize that i could be sympathetic to a compromise if there was a good reason for it. here, that does not seem to be the case.
11:20:40 <benmachine> Eelis: making case-pattern matching always strict is more consistent than making it usually-strict
11:20:47 <Eelis> so i'm told
11:20:52 <monochrom> it is more regular to not depend on counting alternatives
11:21:00 <benmachine> Eelis: suppose you had a function that you *wanted* to be strict, but with only one branch, what would you do?
11:21:16 <Eelis> benmachine: no idea, i basically never bother with strictness annotations
11:21:38 <benmachine> Eelis: ah, well, lucky you. lots of people *do* worry about that sort of thing because it can have severe performance implications
11:21:44 <Eelis> no doubt
11:21:59 <benmachine> so the language is set up such that you can choose what behaviour you want
11:22:19 <benmachine> and frankly it's really not much to ask that you put a ~ in a couple of places, or use let instead of case :)
11:22:32 <Eelis> so you claim that if the default was for single-alternative cases to be lazy, then no amount of annotation could ever recover the current default behavior?
11:22:38 <benmachine> no
11:22:47 <lpsmith> Yes, for example I don't know of any uses of foldl that should not be foldl' instead,   you probably don't want Control.Monad.State.Lazy unless you are 100% sure that you actually do,  etc.
11:22:57 <benmachine> but I claim it would be less consistent and wouldn't reduce the amount of annotation needed
11:23:00 <Eelis> benmachine: then your point about the language being set up to let one choose seems faulty, because then you concede that the choice would also be possible in my variant of the language
11:23:20 <benmachine> Eelis: yes. so the two alternatives are equivalent in expressive power, but the existing one is more consistent
11:23:49 <benmachine> you have the rule 'case-matching is strict' instead of 'case-matching is strict except for when the pattern cannot fail'
11:23:56 <Eelis> whether it's more consistent depends on what property you're looking at. i look at Haskell as a mostly lazy language, and any deviation from that looks like an inconsistency
11:24:05 <zygoloid> Eelis: consider this: you're generating haskell code using TH. you generate a 'case' statement. with your suggestion, you have to count the alternatives and artifically insert a ! if there's only one. that would suck.
11:24:15 <Eelis> zygoloid: TH sucks anyway :)
11:24:27 <monochrom> you wrote a program. I read it. I see whether you use a "case" or a "let". I look at the patterns and where the "~"s are. that is all I need to look out for when I determine the strictness of your program
11:24:36 <zygoloid> first and foremost, haskell is a uniform and consistent language. i consider that property /way/ more valuable than laziness
11:25:04 <zygoloid> multi-branch case statements must be strict, therefore by uniformity single-branch case statements must be strict.
11:25:08 <geheimdienst> ghc -threaded -lazy=0
11:25:12 <monochrom> your scheme would require me to look out for yet another thing, some extra counting. you put this extra stress on me just to fulfill some ill-conceived DWIM guessing.
11:25:17 <benmachine> Eelis: it depends a little on how you read case statements, and interpret pattern matching
11:25:36 <benmachine> Eelis: does undefined match (_,_)? haskell says no, just like Left x doesn't match Right _
11:26:26 <monochrom> I want regular language designs and I don't want DWIM exceptions left right and centre. go to Perl if you want those.
11:26:51 <Eelis> i don't want DWIM. i want "do what one would expect"
11:27:06 <benmachine> Eelis: well, that depends on who is expecting :)
11:27:24 <benmachine> Eelis: evidently there are people who expect a case with two branches to act like a case with one branch
11:27:24 <monochrom> I expect strictness to be independent of counting. that's what I expect.
11:27:36 <Eelis> monochrom: that much i gather
11:28:12 <monochrom> I expect a shorter list of things to look out for when determining program semantics. no exceptions to the rules.
11:28:32 <benmachine> wait a sec, can I check exactly what we're arguing about
11:28:34 <Eelis> again, from my perspective the current behavior /is/ the exception
11:28:43 <Eelis> but we keep going in circles
11:28:45 <benmachine> are we arguing that case Left () of Right _ -> 0 should give 0?
11:29:01 <benmachine> I mean is Eelis arguing that
11:29:09 <Eelis> benmachine: i have no strong feelings about that case
11:29:18 <benmachine> because that looks pretty counterintuitive to me
11:29:33 <geheimdienst> why would Left () ever match Right _, lazy or no? ...
11:29:38 <geheimdienst> (honest question)
11:29:40 <zygoloid> Eelis: why would you write a case rather than a let if you didn't want strictness?
11:29:54 <monochrom> Eelis is arguing that haskell is a "lazy language" and so it should have fewer exceptions to laziness
11:30:06 <tncardoso> i am new to haskell and i'm having a couldnt match expected type error. I am passing [Dir] to a map and it is asking for a [Dir] in the lambda function: http://ideone.com/DXSkS what am i missing?
11:30:11 <benmachine> laziness must be controllable and therefore optional
11:30:20 <Eelis> zygoloid: i'm thinking of this in the context of function definitions
11:30:24 <monochrom> I say to hell with "haskell is a lazy language"
11:30:35 <Eelis> monochrom: well, thanks for proving my point then :)
11:30:48 <benmachine> Eelis: function definitions are sugar on case statements effectively
11:30:53 <Eelis> benmachine: yes
11:31:13 <Eelis> benmachine: zygoloid asked why i don't use a let. it's because i'm defining a function, which is a case
11:31:15 <benmachine> Eelis: I don't think function definitions and case statements should behave differently; that limits the kinds of transformations I can perform
11:31:20 <benmachine> Eelis: use a where.
11:31:26 <Eelis> more typing
11:31:31 <zygoloid> use a ~ ;)
11:31:32 <benmachine> use a ~ then
11:31:48 <benmachine> weep at the additional 3 characters of keyboard wear
11:31:48 <Eelis> i know what ~ does
11:32:57 <zygoloid> Eelis: my view is: (1) consistency is more important than laziness. (2) pattern matching in function bindings is more important than laziness. (1+2) => a single function binding is still strict
11:33:07 <zygoloid> which of (1) and (2) do you sacrifice?
11:33:28 <Eelis> zygoloid: i adressed the point about perceived "consistency" multiple times already.
11:33:43 <zygoloid> Eelis: except that your solution only makes things less consistent.
11:33:51 <Eelis> zygoloid: again, that is a matter of perspective. read up.
11:33:59 <zygoloid> the special case for 'when is it lazy' is /more complex/ with your solution
11:34:26 <zygoloid> more complex is almost by definition less consistent
11:35:12 <Eelis> since i reject the "more complex" characterization (as i have indicated multiple times already), the rest of your point is lost on me
11:35:19 <Eelis> (read up)
11:35:45 <byorgey> tncardoso: the problem is in newpath
11:35:52 <zygoloid> i've read up. please try to characterize the rule you suggest, and you'll see it's more complex.
11:35:59 <byorgey> tncardoso: you probable want cpath ++ [dir]
11:36:36 <byorgey> tncardoso: newpath is inferred to have type  [Dir] -> [Dir] and since y is passed as an argument to it, y is inferred to have type [Dir]
11:36:39 <tncardoso> byorgey, yes, you are right
11:36:43 <tncardoso> byorgey, thanks a lot
11:36:43 <benmachine> Eelis: if it's a matter of perspective, can you accept your perspective is evidently the less common one?
11:37:00 <byorgey> tncardoso: you're welcome
11:37:32 <byorgey> tncardoso: pro tip, when you hit an error like this again, start adding type annotations to functions defined inside a where
11:37:39 <Eelis> benmachine: i obviously blame that on the status-quo bias: people who like a language will automatically be biased to like that language the way it is. any proposed change has that bias working against it.
11:37:43 <byorgey> tncardoso: that usually helps pin down the error a lot better
11:37:58 <Eelis> benmachine: so that point is simply moot :)
11:38:06 <byorgey> tncardoso: I'm not saying you must always put type annotations on such functions, just that it is a helpful exercise when trying to track down a type error
11:38:19 <benmachine> Eelis: it's not entirely moot though, because when consensus was originally being formed, this sort of thing will have been discussed
11:38:49 <Eelis> benmachine: heh, that's the "people decided on X in the past, and hey, they probably decided correctly" argument from authority, which is another fallacy
11:38:57 <ben> Eelis: But don't all people who really like a language secretly hate it?
11:39:00 <ben> just look at ##c++
11:39:11 <benmachine> Eelis: why is it a fallacy? haskell was designed by pretty clever people
11:39:13 <Eelis> ben: i'm not sure why you're asking me. i have no special insight in that language
11:39:19 <tgeeky> roconnor: ping
11:39:31 <roconnor> ack
11:39:38 <monochrom> "case x of { x:xs -> ... ; x:xs -> ... }" has different strictness from "case x of { x:xs -> ... }"?
11:39:39 <ben> I am not sure I have experience the status-quo bias
11:39:50 <Eelis> benmachine: the fact that Haskell is constantly being extended and changed already shows that lots of things weren't thought through properly
11:39:55 <ben> experienced, sorry
11:39:56 <byorgey> Eelis: you seem to be using the "that argument has a generic name, and it is a fallacy" fallacy
11:40:07 * benmachine giggles
11:40:08 <byorgey> ;)
11:40:20 <monochrom> haha
11:40:22 <Eelis> byorgey: how so?
11:40:26 <tgeeky> roconnor: can I get some help with understanding "Functor :: Lens : Applicative :: BiPlate"
11:40:32 <tgeeky> in pm, perhaps?
11:40:33 <roconnor> tgeeky: yes!
11:40:44 <roconnor> how about #haskell-in-depth
11:40:48 <tgeeky> k
11:40:49 <roconnor> or privately if you prefer
11:41:07 <thoughtpolice> Eelis: i reject your rejection of the "more complex" characterization, so your point is lost on me
11:41:23 <Eelis> thoughtpolice: i'll assume that was an attempt at being funny
11:41:32 <benmachine> thoughtpolice: well yes but that's just because we've been brainwashed by the status quo
11:41:55 <thoughtpolice> because frankly, having case 'mean something different, but only when this one particular special case arises where it has dubious advantage' is in fact, adding complexity
11:41:59 <thoughtpolice> Eelis: correct
11:42:14 <benmachine> an attempt at being funny *and* a valid point
11:42:32 <Eelis> thoughtpolice: you're only restating the same point that was already made and that i've already responded to, so i'm not sure what why you're telling me this
11:42:40 <Eelis> s/what why/why/
11:42:49 <benmachine> Eelis: if the behaviour of case was as you want, ~ patterns would still be necessary
11:42:59 <Eelis> benmachine: so?
11:43:05 <benmachine> so you would be adding a new pattern qualifier
11:43:16 <thoughtpolice> Eelis: because we're brainwashed by the status quo, so it is my duty to brainwash others obviously.
11:43:16 <Eelis> so?
11:43:31 <benmachine> so you would be complicating the language in a concrete way and stealing more syntax
11:43:59 <Eelis> again, some point over and over again
11:44:10 <benmachine> no, because I'm giving a specific example this time
11:44:34 <benmachine> pointing out that your way of doing things isn't equivalent, it's actually *adding* a pattern type, whereas in the current way of doing things that pattern type is superfluous
11:44:56 <djahandarie> Eelis, didn't you write that C++ evaluation bot?
11:46:12 <benmachine> Eelis: so essentially you're taking existing syntax which means one thing, and changing it to mean something we can already say in a different way, and then needing a new way of saying what it originally meant. you gain: nothing.
11:46:28 <Eelis> benmachine: the specifics of these different kinds of strictness annotations are entirely inconsequential to me. they're completely overshadowed by the overriding principle about Haskell allegedly being a lazy language. so all this "oh no we mustn't complicate the pattern rules" stuff means nothing to me because in the current situation, the very nature of the language is made inconsistent, which is FAR worse
11:46:55 <thoughtpolice> i like how haskell is only "allegedly" a lazy language.
11:47:03 <Eelis> thoughtpolice: ask monochrom, he'll explain
11:47:19 <benmachine> Eelis: but you agree that it is necessary to have a way of writing the strict form, because strictness is sometimes desirable?
11:47:28 <benmachine> Eelis: so why is one way of writing it wrong but another way of writing it okay?
11:47:37 * zygoloid suggests we apply 's/Haskell is a lazy language/Haskell is a consistent language/g' to the universe
11:47:48 <benmachine> zygoloid: haskell *is* a lazy language though
11:47:58 <Eelis> benmachine: again, i don't know what would be needed to write the strict form, and i care very little. i care about the default
11:47:58 <thoughtpolice> i'm only commenting on how funny that statement sounds, nevermind the actual reasonings behind saying it.
11:48:00 <benmachine> case being strict really doesn't invalidate that imo
11:48:32 <benmachine> Eelis: but you must recognise that other people *do* care about writing the strict form, and with legitimate reason?
11:49:07 <Eelis> thoughtpolice: to be clear: do you wish me to respond to any of your points, or do you just want to make fun of me and not be challenged?
11:49:22 <Eelis> benmachine: i have no problem recognizing that
11:49:52 <benmachine> Eelis: ok, so you agree that there needs to be a strict form, right? since case is strict in every other circumstance, why not just make it strict all the time?
11:49:54 <ninegrid> kung foo
11:50:25 <benmachine> why add two ways of making things strict, with the caveat that one is the one you use when there are multiple alternatives and the other you use when there's one?
11:50:34 <Eelis> benmachine: because case being strict for more than 1 alternative makes logical sense because scrutiny of the expression is necessary to decide which alternative to take. no such choice is necessary for a single alternative. thus, no need for the strictness
11:51:04 <benmachine> Eelis: well, scrutiny is necessary to decide *if you are taking an alternative at all*
11:51:19 <Eelis> benmachine: not always!
11:51:30 <benmachine> e.g. in case x of Left _ -> y; you sort of have an implicit Right branch that says "die now"
11:51:49 <Eelis> yes, that is true for types with multiple ctors, but not for something like a tuple
11:51:55 <benmachine> ok fine (although you're now making the rules even more complicated)
11:51:58 <zygoloid> i can't see any objective way to quantify 'better' here other than by the number of informed people who prefer each option. by that metric, the status quo seems better.
11:52:11 <benmachine> I still don't think you've thought through the strictness annotation, which you've agreed must exist
11:52:12 <Eelis> benmachine: my rules flow naturally from lazyness considerations, so they're quite easy to remember :)
11:52:35 <benmachine> Eelis: but you're blurring the distinction between, for example, undefined and (undefined, undefined)
11:52:36 <dolio> Are we discussing whether matches against product types should be irrefutable?
11:52:50 <benmachine> dolio: that's a part of it yes
11:53:09 <Eelis> benmachine: to the extent that my rules blur that distinction, i see no problem
11:53:13 <benmachine> Eelis: currently case can distinguish between those, but you're proposing that it shouldn't be able to?
11:53:20 <thoughtpolice> Eelis: i don't really see why case being strict, even with only one alternative, is such a travesty that "breaks" the language, and i'm not convinced that special casing such a construct makes things any more 'consistent' with haskell being 'lazy' (i still would say it makes them less consistent,) so if that's poking fun, i guess that's what i'll do.
11:53:21 <benmachine> Eelis: ok, now how do you implement seq on tuples?
11:53:24 <dolio> That's mathematically the better choice if you also get rid of seq.
11:53:46 <benmachine> Eelis: recall that seq _|_ x = _|_ and seq y x = x
11:53:51 <benmachine> dolio: yes but we need seq :)
11:54:06 <dolio> There's the rub.
11:54:16 <Eelis> benmachine: i don't recall ever using seq
11:54:32 <benmachine> Eelis: then you should recognise that your requirements of the language are different from many others'
11:54:35 <frerich> What does it mean when an article about Haskell says that some "kind" must be "* -> *"? What does 'kind' in Haskell-lingo mean?
11:54:46 <shachaf> @wiki Kind
11:54:47 <lambdabot> http://www.haskell.org/haskellwiki/Kind
11:54:53 <dolio> > foldl (+) 0 [1..100000]
11:54:54 <lambdabot>   5000050000
11:54:54 <Eelis> thoughtpolice: to be clear: do you want me to respond to your point just now, or will you just go "no no i'm only joking" again?
11:54:57 <geheimdienst> :k Maybe
11:54:57 <lambdabot> * -> *
11:54:57 <dolio> > foldl (+) 0 [1..1000000]
11:54:59 <lambdabot>   *Exception: stack overflow
11:55:01 <benmachine> Eelis: and therefore you shouldn't go around saying "this is what I want, this is what I think is right" without knowing other peoples' considerations
11:55:02 <geheimdienst> :k Int
11:55:02 <lambdabot> *
11:55:25 <thoughtpolice> frerich: types are to terms, as kinds are to types. for example, a value which is a function may have type 'Int -> Int', where a type may have a kind '* -> *' for example, look at 'Monad', which has kind * -> *
11:55:49 <geheimdienst> frerich: Maybe has kind * -> * because it's declared as "data Maybe a = ...". note the "a"
11:55:51 <thoughtpolice> Eelis: i don't really care
11:55:54 <benmachine> thoughtpolice: Monad doesn't have a kind exactly; Monad m isn't a type
11:56:35 <thoughtpolice> benmachine: ?
11:56:35 <Eelis> benmachine: you're misrepresenting my position. if you go back, you'll notice that this whole conversation started with me explicitly asking for reasons why things are the way they are. so this accusation that i'm too ill-informed to participate in this discussion makes no sense, considering that i started it for the purpose of becoming more informed
11:56:49 <benmachine> but yes, kinds are essentially ways of formalising the notion 'Maybe takes one type and gives a type' and 'StateT takes a type, and a type function, and a type, and gives you a type'
11:58:10 <dolio> Eelis: If you've ever expected sum and product to not use O(n) memory, you've used seq.
11:58:13 <benmachine> Eelis: things are the way they are because case being strict is consistent *and* case being lazy would require something else to be strict, so wouldn't make haskell "lazier" overall, since the capacity for strictness would still be there
11:58:27 <frerich> hmm, interesting, so kinds are like "meta types". Would some type constructor "X a b" mean that the constructed types have kind "* -> * -> *"?
11:58:32 <thoughtpolice> benmachine: why doesn't Monad have a kind? Monad by itself as a type constructor has kind * -> *, while Monad m has kind *
11:58:41 <benmachine> thoughtpolice: Monad m is a constraint not a type
11:58:54 <thoughtpolice> oh, well, i forgot about that one. :P
11:58:55 <Eelis> djahandarie: yes
11:58:58 <thoughtpolice> frerich: yes
11:59:07 <benmachine> frerich: it depends a little how a and b are used
11:59:13 <thoughtpolice> frerich: well, X actually has kind '* -> * -> *'
11:59:43 <benmachine> frerich: data X a b = X (a Char) (b Int Int) means a has kind * -> * and b has kind * -> * -> *, so X has kind (* -> *) -> (* -> * -> *) -> *
11:59:43 <thoughtpolice> if you were to fully apply the type constructor X, a la 'X Int Bool', then you have a type of kind * (and of course, saying 'X Int' would yield a type of kind * -> *)
11:59:47 <monochrom> "data X a b = R a | S b" gives you X :: *->*->*
12:00:16 <monochrom> although, "data Y a b = W (a b)" gives you Y :: (*->*) -> * -> *
12:00:46 <Eelis> benmachine: btw, i appreciate your efforts to reason with me. thanks!
12:00:52 <benmachine> Eelis: np :)
12:00:53 <thoughtpolice> speaking of kinds, byorgey - when am I gonna get typekinds?! (jk :P)
12:00:53 <monochrom> but my examples are too easy
12:00:58 <benmachine> glad to help
12:01:05 <Eelis> benmachine: i will study seq
12:01:13 <geheimdienst> monochrom: how so?
12:01:32 <benmachine> Eelis: you'll probably be upset when you do, it's not terribly pretty :P but other ways of doing have been tried, and it seems the best way to solve the problem
12:01:55 <monochrom> by being easier that "data X a b = X (a Char) (b Int Int)"
12:02:05 <Eelis> @src seq
12:02:05 <lambdabot> Source not found. It can only be attributed to human error.
12:02:09 <Eelis> oh, seq is a built-in?
12:02:13 <benmachine> yes, it has to be
12:02:14 <Eelis> then it can do whatever it wnts, no?
12:02:14 <thoughtpolice> yep
12:02:19 <benmachine> well, not quite
12:02:20 <sanjoyd> Suggest textbooks for understanding Haskell, type theory etc.  better? Right now I'm reading "Design concepts in programming languages", and have found it quite helpful.
12:02:23 <geheimdienst> :k X (a Char) (b Int Int)
12:02:24 <lambdabot> Not in scope: type constructor or class `X'
12:02:24 <lambdabot> Not in scope: type variable `a'
12:02:24 <lambdabot> Not in scope: type variable `b'
12:02:30 <sanjoyd> Any canonical texts I should read?
12:02:31 <benmachine> it can only do things that are possible at all :P
12:02:41 <geheimdienst> :k data X a b = X (a Char) (b Int Int)
12:02:41 <lambdabot> parse error on input `data'
12:02:44 <benmachine> it can do things that are otherwise impossible in haskell
12:02:59 <chrisdone> hpaste now supports displaying a diffs between pastes. :-) http://hpaste.org/diff/47765/47766
12:02:59 <benmachine> the only such thing it does is differentiating between 'undefined' and 'const undefined'
12:02:59 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
12:03:02 <chrisdone> @messages
12:03:03 <lambdabot> tommd said 19h 57m 1s ago: That was it btw, thanks. I didn't expect a buoild step to sed the ghc-pkg .d files!
12:03:12 <Eelis> benmachine: right, but if seq isn't written in Haskell, then i don't see how it's even relevant to the discussion, because i was only arguing for a change in how Haskell source works
12:03:36 * geheimdienst hugs chrisdone
12:03:36 <Eelis> seq would be unaffected
12:03:45 <geheimdienst> diffing sounds awesome, thanks a lot
12:03:46 <benmachine> Eelis: it's more a question of semantics. I wasn't asking for a *haskell* implementation of seq, but any implementation at all
12:03:52 <chrisdone> geheimdienst: ^_^!
12:03:58 <benmachine> Eelis: but I was really alluding to a more complex issue that I couldn't really articulate properly
12:04:00 <thoughtpolice> sanjoyd: real world haskell, and i would advise a text like winskel's "the formal semantics of programming languages" (not sure if there's a better, more recent text, but i like this one.) for type theory, benjamin pierce's "types and programming languages" is excellent
12:04:07 <Eelis> benmachine: i see
12:04:15 <benmachine> Eelis: about whether tuples should be lifted or unlifted
12:04:15 <sanjoyd> thoughtpolice: thanks a lot.
12:04:18 <dolio> benmachine: One possibility is that optimistic evaluation would make most uses of seq superfluous. So we could get rid of seq and have 'unlifted' products that aren't implemented any differently than currently, but you can't tell.
12:04:22 <benmachine> it's not terribly relevant in any case
12:04:23 <frerich> benmachine: Hm good point, I didn't consider that in 'X a b', a or b might have more complex kinds than '*'
12:04:26 <frerich> Thanks everybody!
12:04:38 <benmachine> frerich: usually they don't, but monad transformers are a good example of when they do
12:04:42 <benmachine> :k StateT
12:04:43 <lambdabot> * -> (* -> *) -> * -> *
12:04:50 <Eelis> benmachine: i will read about this "lifting"
12:05:17 <thoughtpolice> sanjoyd: but those should definitely keep you busy, at least for a little while! winskel's book mostly deals with the actual formal sematics of programming languages (domain theory, denotational semantics, etc) rather than type theory or FP explicitly
12:05:25 <sanjoyd> thoughtpolice: I am actually putting off RWH till I really understand what goes on behind the scenes.
12:05:29 <thoughtpolice> sanjoyd: so you may slide on that one, or just supplement it with something more relevant
12:06:01 <benmachine> Eelis: a type is lifted if it contains its own _|_ value, is the short version; this is also interesting wrt the difference between data and newtype
12:06:02 <thoughtpolice> sanjoyd: well, tbf, i don't think you need to understand unification or denotation semantics to write real world haskell. :)
12:06:13 <benmachine> ^ this is true
12:06:16 <sanjoyd> thoughtpolice: I already have some idea of semantics (SOS, BOS, denotational) from DCPL. But I'll give that a try.
12:06:24 <benmachine> and in fact writing real haskell may help with your abstract learning
12:06:25 <sanjoyd> thoughtpolice: I know, my purpose is mainly learning. :)
12:06:32 <benmachine> maybe.
12:07:19 <thoughtpolice> benmachine: i think i would agree. haskell is definitely a fine place to at least test some of the abstract learnings you pick up, and perhaps use them for the real world, even :)
12:07:36 <sanjoyd> benmachine thoughtpolice: yes, I've started writing some code. The thing is that I find it uncomfortable using, say, runST without a understanding properly what an "existential type" is.
12:07:48 <sanjoyd> I don't want to black box anything.
12:07:48 <Eelis> benmachine: for what it's worth, i only ever argued for a pretty superficial change in pattern syntax. i certainly never meant to imply that the Haskell memory representation stuff would have to change
12:07:49 <monochrom> you have to understand general-purpose unification to be a reasonable person
12:07:52 <geheimdienst> chrisdone: looks nice already. are you aware of jsdiff? it's quite good, i've used it in the past to highlight changes in a trac-like way http://ejohn.org/projects/javascript-diff-algorithm/
12:08:07 <geheimdienst> ... i.e., the exact characters that changed
12:08:22 <benmachine> Eelis: sure, but the subtle issues can really kick you in the arse if you don't think about them carefully
12:08:22 <thoughtpolice> sanjoyd: tbf, runST is a *little* bit more than just existential types. it's actually rank 2 types that allow ST to work (safely,) the way it does
12:08:37 <Eelis> benmachine: if you say so :)
12:08:55 <benmachine> Eelis: well, I do, but also I think in retrospect lifting wasn't particularly relevant to the argument
12:09:03 <benmachine> and I shouldn't have brought it up (except that it's interesting)
12:09:04 <Eelis> oh ok, no problem
12:09:20 <chrisdone> geheimdienst: Oh noice. I'll try that.
12:09:24 <benmachine> now I gotta find my socks
12:09:49 <sanjoyd> thoughtpolice: exactly what I'm talking about. I don't want to paste code I don't understand. :)
12:09:51 <benmachine> > find my socks
12:09:52 <lambdabot>   Nothing
12:09:54 <benmachine> :(
12:09:54 <thoughtpolice> sanjoyd: but! fundamentally you're going to be black boxing at least a little bit no matter where you start off. :) you probably won't be understanding laziness at the operational level before you write some lazy programs, etc. that said it's good to have some mechanics, just don't try too hard, or you'll end up reading forever and never coding :P
12:10:06 <byorgey> thoughtpolice: soon, hopefully
12:10:09 <Eelis> benmachine: and i will go into lurking hybernation for 6 months because i've alienated half the channel ;)
12:10:21 <Eelis> with my heresy
12:10:26 <byorgey> thoughtpolice: looks like we will probably be getting a grant to fund work on it =D
12:10:33 <Cale> sanjoyd: runST has nothing to do with existential types
12:10:36 <thoughtpolice> sanjoyd: and personally, I think almost all type system fanciness in haskell "comes with time" - that is, you should probably never spend the effort to deal with some complex type system feature like rank 2 types or something, until you need it
12:10:52 <geheimdienst> chrisdone: iirc, i used it like this: run jsdiff, put output in the html document twice, use css on 1st instance to hide all the insertions, use css on 2nd instance to hide all the deletions
12:10:56 <geheimdienst> or something like that :)
12:10:57 <Cale> sanjoyd: Its type has higher rank polymorphism, but no existential
12:10:57 <sanjoyd> Cale: probably. I don't claim to understand it.
12:11:12 <benmachine> Eelis: well, there's a nice reason and a depressing reason why you don't have to; the nice reason is we're quite forgiving, the depressing reason is we'll probably have forgotten who you are by tomorrow >_.
12:11:15 <Cale> (I guess you can think of it as an existential, sorta...)
12:11:16 <benmachine> *>_>
12:11:21 <dolio> Eelis: Incidentally, in Miranda, 'case undefined of (a, b) -> ...' wasn't necessarily undefined.
12:11:23 <Eelis> benmachine: good good :)
12:11:33 <Eelis> dolio: interesting
12:11:40 <thoughtpolice> byorgey: oooo!!
12:11:45 <Cale> :t runST
12:11:46 <lambdabot> forall a. (forall s. ST s a) -> a
12:12:00 <dolio> But it had seq, and (undefined :: (a, b)) `seq` () was undefined, which is bad.
12:12:09 <thoughtpolice> byorgey: i noticed in you and simon's new paper that you leave some tantalizing possibilities of what could happen with the new coercions representations :>
12:12:30 <Cale> sanjoyd: What that says is that the ST s a that you pass in must be completely polymorphic in s, and since a is a type variable bound in an outer scope, it can't depend on s in any way.
12:12:38 <Eelis> dolio: wait, isn't that what seq is /supposed/ to do? i'm confused now. i thought x`seq`y was supposed to be undefined if x was undefined
12:12:58 <Cale> sanjoyd: This effectively prevents any value with an 's' in its type from escaping in the result of runST
12:13:04 <benmachine> Eelis: yes but the bad bit is that seq and case disagree on how defined things are
12:13:18 <Parallax> Is Haskell a good first language for someone brand new to programming, or should I start somewhere else?
12:13:22 <Eelis> benmachine: oh. i'm afraid i'm not familiar enough with seq yet to see why that's a problem
12:13:24 <benmachine> (or so I imagine; don't know much about miranda)
12:13:28 <byorgey> thoughtpolice: I assume you are referring to spj and Dimitrios Vytiniotis's paper, but yes, it definitely opens up some cool possibilities =)
12:13:30 <Cale> sanjoyd: Which is what prevents you from returning STRefs and using them in other ST computations, which would break referential transparency badly.
12:13:34 <dolio> Eelis: Yes, but for instance: (case undefined of (a, b) -> (a, b)) `seq` () was ().
12:13:34 <Cale> Parallax: I think so.
12:13:39 <parcs> Parallax: it's a great first language
12:13:47 <Cale> Parallax: In fact, if you're going to learn it, learning it first is easiest.
12:13:50 <Eelis> dolio: sounds sensible to me
12:13:50 <thoughtpolice> byorgey: oh, i could have sworn you were in on it too. i just remember hearing you did lots of work with them :)
12:13:56 <chrisdone> Cale++
12:14:02 <dolio> Eelis: And if products are unlifted, then that should be the same as (undefined `seq` ()).
12:14:07 <davidL> :w
12:14:08 <Parallax> I'm being told to learn Python first but Haskell looks interesting
12:14:11 <Cale> Parallax: Once you learn some other programming languages, you'll have to unlearn some things to program in Haskell :)
12:14:14 <Eelis> dolio: hmm..
12:14:14 <sanjoyd> Cale: so since I can't depend on s being of a particular type, I can't "do" anything with it?
12:14:15 <thoughtpolice> byorgey: and while you're here, I might as well tell you, unbound is *awesome*. it makes writing little interpreters and stuff *soooo* much easier and cleaner! so ty :)
12:14:18 <Nimatek> I'm not sure if it's a great first language, because it is quite different.
12:14:22 <byorgey> thoughtpolice: I helped with some of the initial implementation work, but am not a coauthor (neither would I deserve to be)
12:14:36 <lispy> unbound?
12:14:38 <monochrom> haskell is a great first langage
12:14:40 <chrisdone> Nimatek: Heh, funny logic. Different to what (if it's your first)? :-)
12:14:46 <Nimatek> I would suggest starting with Python, too.
12:14:47 <byorgey> thoughtpolice: oh, awesome! thanks for the report =)
12:14:54 <thoughtpolice> lispy: http://hackage.haskell.org/package/unbound
12:14:55 <Cale> sanjoyd: Well, yes, that's true, but values of type s never come up.
12:15:13 <Cale> sanjoyd: If it helps though, you can think of s as the type of the entire heap for the ST computation.
12:15:13 <thoughtpolice> lispy: this package deserves more press amongst those who would use haskell for language implementation :>
12:15:15 <dolio> Eelis: If pairs are actually a product, then (case p of (a, b) -> (a, b)) should be equal to p, as should (fst p, snd p).
12:15:18 <tsuraan_> what's the function that takes a string and a char and returns a list of strings split on that char?
12:15:22 <Nimatek> chrisdone: To the whole world of imperative programming, which is the way most programming is done at the moment.
12:15:22 <lispy> thoughtpolice: interesting
12:15:25 <sanjoyd> From what I understand, only _|_ can be a "value" of s, in this case?
12:15:44 <dolio> Eelis: In Miranda, the first is untrue. In Haskell the second is untrue.
12:15:45 <lispy> Not sure how I would use it, but it does look like it could come in handy for compiler writers
12:15:54 <monochrom> a litmus test of whether a language is a good first language is to ask what "x = x+1" means in that language
12:16:03 <Cale> sanjoyd: Returning any kind of reference to a part of that heap would let the mutable nature of things escape and ruin the rest of Haskell.
12:16:14 <Eelis> dolio: right
12:16:15 <thoughtpolice> lispy: yes, that's the main thing. no more need for people to reimplement alpha substitution & variable capture for the, uh, millionth time. :)
12:16:18 <lispy> > let x = x + 1 in x
12:16:22 <monochrom> after school algebra, you don't expect "x = x+1" to be a good thing
12:16:22 <lambdabot>   mueval-core: Time limit exceeded
12:16:31 <Cale> sanjoyd: So the type of runST cleverly enforces that it doesn't happen.
12:16:35 <Parallax> Got any recommendations for a good book/site to start learning from?
12:16:36 <sanjoyd> Cale: yes, I got that part -> runST (foo) will always return the same value for the same foo.
12:16:46 <monochrom> haskell agrees that it is not a good thing. python disagress. haskell is a better first language
12:16:49 <Cale> sanjoyd: yep
12:16:52 <byorgey> thoughtpolice: well, since our paper was accepted to ICFP it's about to get more press =D
12:16:58 <parcs> @where lyah
12:16:58 <lambdabot> http://www.learnyouahaskell.com/
12:17:01 <thoughtpolice> byorgey: exciting! :D
12:17:01 <parcs> Parallax: ^
12:17:11 <chrisdone> parcs: http://tryhaskell.org
12:17:17 <Parallax> parcs: This guide is meant for people who have programmed already, but have yet to try functional programming.
12:17:22 <lispy> thoughtpolice: Actually, I may have a use for that in my core translator.  Type variables in core tend to look like aabc9 and it would be nice to change that to just 'a'
12:17:23 <Parallax> I have never programmed before
12:17:32 <sanjoyd> Parallax: I really liked lyah, you'll probably like it too.
12:17:36 <parcs> Parallax: yeah, i remember that as soon as i pressed the enter key. listen to chrisdone
12:18:13 <Parallax> thanks, checking it out
12:18:17 <Cale> sanjoyd: Think about what might happen if you could write something like  r = runST (newSTRef 0); x = runST (do modifySTRef r (+1); readSTRef r); y = runST (do modifySTRef r (+1); readSTRef r)
12:18:31 <chrisdone> That reminds me, I wrote a greasemonkey little script to /add/ tryhaskell's console to underneath all LYAH’s code sections, but it crashes on Firefox. Might bump BONUS to write one into the site itself.
12:18:34 <Cale> sanjoyd: The order in which you evaluate x and y would affect their values, which would be bad.
12:19:07 <Cale> sanjoyd: The problem is that the STRef created by newSTRef 0 was able to escape that call to runST
12:19:20 <Cale> So we don't want to allow that, and we need some trick to prevent it.
12:19:26 <Cale> :t newSTRef
12:19:27 <lambdabot> forall a s. a -> ST s (STRef s a)
12:19:45 <Cale> So what we do is to make the STRef carry along the same s in its type.
12:19:47 <monochrom> in fact, python (and all imperative languages) makes you unlearn perfectly fine math. after imperative languages, you think like "how do I change 5 to 7"
12:20:23 <geheimdienst> monochrom: 1+1=3 for large values of 1
12:21:58 <Nimatek> Functional languages are a higher level of abstraction over how the computer actually does things. This can be good and bad, depending on the task.
12:22:52 <monochrom> learn both assembly and haskell as first's. since the syntaxes are so different, you don't get confused
12:23:09 <lispy> Or just start by learning something
12:23:11 <lispy> anything really
12:23:16 <sanjoyd> I try to look at it this way: languages like Haskell are closer to their conceptual machine (which is Lambda calculus) than languages like Python are to theirs (Turing or RAM).
12:23:18 <lispy> And don't stop learning
12:23:33 <Cale> sanjoyd: and now if we try to runST (newSTRef 0), the problem, looking at runST :: forall a. (forall s. ST s a) -> a, is that we're required to first pick some a for which newSTRef 0 :: forall s. ST s a, but we can't really choose a = STRef s Integer, because that wouldn't be the same s as gets bound by the "forall s." there.
12:23:47 <lispy> while( true ) { learnSomething() } and forM [1..] learnSomething
12:23:58 <Cale> It would be like choosing a = STRef t Integer, for some t not necessarily equal to s
12:23:59 <monochrom> why not [0..]
12:24:06 <lispy> It's possible I lost a semicolon
12:24:11 <byorgey> chrisdone++
12:24:17 <redfire> hi all
12:24:23 <Parallax> It looks like this tryhaskell site/book also requires prior programming knowledge
12:24:27 <byorgey> that one was for hpaste diffs =)
12:24:34 <chrisdone> byorgey: Hehe, thanks. :-)
12:24:34 <byorgey> hi redfire
12:25:06 <pgavin> > let { sequence' = let { loop a [] = return (reverse a); loop a (m:ms) = do { x <- m; loop (x:a) ms } } in loop [] } in sequence' [ print n >> return n | n <- [0..5] ]
12:25:07 <lambdabot>   <IO [Integer]>
12:25:11 <pgavin> ...
12:25:13 <monochrom> actually, every programming language requires prior programming knowledge
12:25:17 <redfire> I would to see how does ghc represent closure in the LLVM back end, does anyone know which I have to look to ?
12:25:20 <redfire> *like
12:25:30 <redfire> *file
12:25:35 <byorgey> Parallax: is there something particular in the tryhaskell tutorial you are not understanding?
12:25:37 <pgavin> anyone know if theres a version of sequence that works like that ^^
12:25:53 <byorgey> if you ask here people will be happy to help.  no question is too simple.
12:25:59 <pgavin> i.e., is tail recursive
12:26:05 <Parallax> Oh sorry, I misunderstood
12:26:13 <Parallax> I thought that site was just a front-end for buying the book :P
12:26:40 <Twey> tryhaskell.com has no associated book
12:27:25 <Parallax> It linked to the O'Reilly book so i thought they were related
12:27:26 <Parallax> my mistake
12:27:27 <sanjoyd> Cale: thanks! Clearer now. :)
12:27:36 <chrisdone> Parallax: The book's linked because it was the latest out at the time. :-)
12:28:07 <chrisdone> @seen BONUS`
12:28:07 <preflex>  Sorry, I haven't seen BONUS`
12:28:07 <lambdabot> Unknown command, try @list
12:28:12 <quotemstr> What's a good way to preserve identity in a purely functional tree?
12:28:33 <Cale> quotemstr: "preserve identity"?
12:28:57 <quotemstr> It's a parse tree, and I want some nodes to be able to hold references to other nodes. The problem is that when we perform tree updates, we have to rewrite the tree all the way from top to bottom so new links are preserved. Any pointers from older entries in the tree will refer to old versions of these nodes.
12:29:01 <byorgey> pgavin: what difference are you hoping that would make?
12:29:33 <Cale> quotemstr: Use integer tags?
12:29:59 <quotemstr> e.g., say we have a four-element tree, A root, and B, C, and D hanging off A. Let's say B has to point to C. If we go and change something about C, we need to rewrite C and A. But if we do that, B will point to the wrong node.
12:30:25 <pgavin> byorgey: grow the heap instead of the stack?
12:30:32 <Cale> quotemstr: What do you mean by "point to"?
12:30:43 <Cale> quotemstr: How are you currently representing references into the tree?
12:30:44 <quotemstr> Cale: Sure. That's the idea I had in mind too. But what's the best way to _manage_ these nodes? It seems like you'd have to store a dictionary->node mapping alongside the tree itself and check this mapping when any node changes.
12:31:04 <pgavin> byorgey: Prelude.sequence uses foldr, and isn't tail recursive
12:31:15 <byorgey> pgavin: the Haskell runtime doesn't work like that.
12:31:25 <Cale> You could represent a reference to part of the tree using a lens
12:31:30 <pgavin> byorgey: explain?
12:31:37 <byorgey> stack blowups are usually caused by too much laziness, rather than a lack of tail recursion.
12:31:39 <quotemstr> Cale: Lens?
12:31:58 <byorgey> pgavin: are you having a particular problem with a stack overflow?
12:32:08 <Cale> data Lens a b = Lens { get :: a -> b, put :: b -> a -> a }
12:32:28 <pgavin> byorgey: no, I was just thinking
12:32:28 <quotemstr> Cale: The problem with the dictionary idea is that it turns an O(1) operation (local zippered tree modification) into an O(log N) operation.
12:32:45 <pgavin> byorgey: if you're working in IO, wouldn't there be a problem?
12:32:54 <quotemstr> Cale: I don't understand. How does that help?
12:32:55 <pgavin> *couldn't
12:32:57 <Cale> There are various libraries for working with these things. The idea is that a value of type Lens a b represents some part of type b of a structure of type a in a functional way.
12:33:13 <Cale> and gives you a mechanism for reading it and updating it (immutably)
12:33:26 <Cale> But I don't know if this really helps you.
12:33:40 <Cale> Well, it could.
12:33:41 <quotemstr> Cale: Ah. Yes, that's the desired interface. Implementation is harder.
12:33:45 <byorgey> pgavin: what sort of problem?
12:33:50 * quotemstr reads about lenses.
12:34:40 <roconnor> > (undefined :+ undefined) `seq` 5
12:34:40 <lambdabot>   *Exception: Prelude.undefined
12:34:50 <quotemstr> The two good options, I think, are higher-levl explicit identifiers and relative paths.
12:34:50 <roconnor> > (undefined , undefined) `seq` 5
12:34:51 <lambdabot>   5
12:34:57 <quotemstr> Relative paths are likely more efficient, but they're unstable.
12:35:12 <Cale> http://hackage.haskell.org/packages/archive/fclabels/0.11.1.1/doc/html/Data-Record-Label.html
12:35:18 <Cale> http://hackage.haskell.org/package/fclabels
12:35:25 <rpglover64> Two questions: Is there a major parsing library besides parsec; and does there exist a more powerful version of buildExpressionParser?
12:35:26 <Cale> ^^ this is a nice implementation
12:35:46 <quotemstr> Cale: Thanks.
12:36:18 <quotemstr> "Template Haskell"?
12:36:32 <Cale> quotemstr: For a graph that's going to be mutated a lot, my favourite implementation is  Map Vertex (Set Vertex), or Map Vertex [Vertex] if you need an order on edges.
12:36:33 <pgavin> sequence [ return n | n <- [0..100000000]] becomes:  do x <- return 0; xs <- sequence [ return n | n <- [1..10000000]]; return (x:xs)
12:36:49 <pgavin> byorgey: wouldn't the nested call to sequence grow the stack?
12:36:51 <byorgey> rpglover64: (1) yes, for example, attoparsec and uu-parsinglib (2) I don't know.
12:36:53 <Cale> quotemstr: A macro system for Haskell.
12:36:59 <Cale> quotemstr: It comes with GHC
12:37:16 <quotemstr> Cale: Hrm. I didn't consider using an explicit edge representation of my graph.
12:37:19 <quotemstr> Cale: Ah.
12:37:20 <koala_man> can zero-width negative/positive constructs in regex be used to match languages that aren't mathematically regular?
12:37:37 <rpglover64> byorgey: Thanks; I'd forgotten about uu-parsinglib
12:38:58 <quotemstr> Ah, Lenses aren't _quite_ what I had in mind, I think. They seem to be useful for changing part of a structure given the sub-part to change and the whole, but that doesn't solve the graph problem because it doesn't address keeping track of the bits that need to change.
12:39:56 <Cale> quotemstr: The idea is that rather than putting a reference to B directly in your node, you put a lens which picks B out of your entire tree structure.
12:40:14 <Cale> quotemstr: (in a bizarrely recursive way ;)
12:40:22 <chrisdone> Twey: Still good for CamHac? ;D
12:41:04 <roconnor> quotemstr: edwardk has a very nice talk on youtube about using lenses in scala
12:41:26 <quotemstr> roconnor: I'll go look for it.
12:41:36 <Cale> quotemstr: and then if you want to read the value of B, you have a way to do that (which hopefully doesn't have to change when the part of the tree containing B is updated, because it generically follows a path from the top of the tree), and you also have a way to set it.
12:41:51 <roconnor> http://www.youtube.com/watch?v=efv0SQNde5Q&list=PLEDE5BE0C69AF6CCE
12:41:59 <quotemstr> Cale: Right. Tha makes a lot of sense, and it's what I had in mind --- the lens would store an integer ID. It's the implementation of the lens that's the issue.
12:42:10 <Cale> (getting back the entire tree, not just the subtree containing this node)
12:42:19 <Cale> nonono
12:42:26 <Cale> The lens wouldn't even store an integer ID :)
12:42:52 <quotemstr> Cale: Then... how does it get the value of B? How does it know what node _is_ B?
12:43:46 <quotemstr> Are you saying to essentially store "Get to B by looking at the second child of the root?"
12:43:58 <Cale> Essentially, yeah.
12:44:05 <Cale> Though that might not quite be enough for you.
12:44:14 <quotemstr> Cale: But that breaks if I add, say, an E in place of B and make B a child of E.
12:44:31 <quotemstr> (Which is why I initially asked about keeping track of identity.)
12:44:37 <Cale> Yeah, if you reroot things, you'd have to map some function over all the lenses in the tree to account for it.
12:44:59 <quotemstr> Cale: Yeah. So we're back to O(logN)ish time, IIUC.
12:45:06 <Cale> O(n)
12:45:18 <Cale> (unfortunately)
12:45:23 <quotemstr> Cale: I'm convinced lenses could be kept in some kind of ordered structure.
12:45:39 <Cale> But yeah, it depends on your tree representation...
12:45:44 <quotemstr> Cale: Or let me put it his way: I can implement lenses with integral IDs, and I know I can implement the integral ID scheme in O(logN) time.
12:45:50 <Cale> If you're using an explicit graph, then it's trivial.
12:46:05 <Cale> Your lenses don't need updating, and just refer to a particular vertex directly.
12:46:20 <Cale> right
12:46:32 <quotemstr> Cale: That only works if the graph doesn't change, which mine does, unfortunately.
12:46:56 <Cale> It does work even if the graph changes. You just need to be careful not to reuse integer IDs.
12:47:17 <Cale> (your vertices are integers)
12:48:09 <quotemstr> No, I mean, the geometry-based approach doesn't work. The integer ID one does.
12:48:22 * frerich reads "[..] these laws make f and fmap together an endofunctor on Hask, the category of Haskell types (ignoring ⊥, which is a party pooper)" and snickers
12:49:11 <Cale> So you'd have something like Map Integer (Value,[Integer]), or  IntMap (Value, [Int])
12:49:44 <quotemstr> Cale: Something like that. Then, whenver we update a node, we also update the map.
12:51:08 <quotemstr> Maybe it's possible to somehow do better with an edge-list representation of the graph.
12:51:38 <pgavin> byorgey: I just tested it;  something as simple as { main = sequence [ return n | n <- [0..1000000] ] >> return () } will crash ghc with a stack overflow
12:51:47 <pgavin> byorgey: the tail recursive one doesn't, though
12:52:15 <byorgey> pgavin: really? interesting
12:52:33 <byorgey> pgavin: and what if you compile with -O2?
12:53:30 <hpaste> pgavin pasted “stack overflow with sequence” at http://hpaste.org/47772
12:53:37 <pgavin> byorgey: didn't try that
12:53:57 <quotemstr> Well, thanks. I'll read up on some things.
12:54:09 <chrisdone> I always run with -O2 when testing performance.
12:54:17 <Saizan> i don't think there's any optimization that will make sequence use constant stack in IO
12:54:26 <pgavin> still overflows
12:54:44 <pgavin> optimization isn't really the issue
12:55:36 <byorgey> you're right.
12:55:36 <Saizan> sequence is fine for monads with a lazier (>>=) though
12:55:54 <byorgey> pgavin: however, in this particular case you should be using sequence_, not sequence
12:56:04 <pgavin> byorgey: yeah, but if you need the result :)
12:56:07 <monochrom> > runState (undefined >> put ()) ()
12:56:08 <lambdabot>   ((),())
12:56:17 * monochrom giggles
12:56:30 <erus`> according to reddit, strings crash the runtime
12:56:38 <copumpkin> erus`: That's misleading
12:56:39 <roconnor> > runState (undefined >> put ()) undefined
12:56:40 <lambdabot>   ((),())
12:56:48 <copumpkin> first of all, they crash _AT_ runtime
12:56:50 <copumpkin> not _the_ runtime :)
12:56:53 <erus`> haha
12:56:58 <monochrom> > runState (sequence [ return n | n <- [0..] ] >> put ()) ()
12:56:59 <lambdabot>   ((),())
12:57:05 <erus`> phew
12:57:20 <erus`> can start pumping more money into my haskell startup now
12:57:35 <copumpkin> yep!
12:57:41 <copumpkin> it's a pretty trivial issue, in my opinion
12:57:50 <copumpkin> not sure what the big noise is
12:57:56 <Saizan> what's the issue?
12:57:58 <monochrom> you can play some continuation trick to trade stack for heap (or is it called trade heap for stack?)
12:58:05 <copumpkin> Saizan: you can write a partial IsString instance
12:58:09 <copumpkin> and then zomg your string literals crash
12:58:14 <olsner> omg strings crash haskell!? :P
12:58:20 <monochrom> you can also use some ghc magic numbers to waive stack limits
12:58:26 <Saizan> copumpkin: surprising!
12:58:33 <copumpkin> inorite
12:58:47 <c_wraith> doesn't ghc 7 get rid of stack limits in general?
12:59:00 <c_wraith> and ghc 7 makes them auto-init to 32k, instead of 1MB
12:59:35 <Saizan> i thought the stack limits were artificial in the first place? to catch bugs?
12:59:44 <monochrom> see my http://article.gmane.org/gmane.comp.lang.haskell.cafe/87524/
13:00:48 <monochrom> it is a limitless stack internally, then an external illusion of a limit for your enjoyment
13:01:03 <monochrom> "because most often it is an infinite loop"
13:01:28 <pgavin> you can always write code in a way that limits the stack size
13:02:18 <pgavin> well ok maybe not always
13:02:24 <pgavin> shouldn't generalize :)
13:02:34 <monochrom> I can
13:02:36 <zygoloid> you can always move your stack onto the heap
13:02:46 <zygoloid> (where you == monochrom)
13:03:16 <pgavin> yeah I guess you can always make an explicit stack
13:03:20 <pgavin> then you have it on the heap
13:03:23 <chrisdone> Guys might like this if y'aven't seen it: http://channel9.msdn.com/Shows/Going+Deep/E2E-Brian-Beckman-and-Erik-Meijer-CoContravariance-in-Physics-and-Programming-1-of-2
13:03:30 <monochrom> so in fact limitless stack has been around since 6.10
13:05:07 <monochrom> it is hard to believe that it's 2010 indeed
13:06:15 <shapr> y2k+10?
13:06:23 <shapr> monochrom: but wait
13:06:28 <shapr> I don't think it is 2010
13:06:34 <monochrom> exactly
13:07:24 <monochrom> "Happy new year! It's hard to believe that it's 2010. To start off the new year right, how about some Beckman and Meijer?" in the most recent url
13:07:49 <monochrom> yes it may surprise you that I go for the text content instead of the video content
13:08:33 <monochrom> I think I finally understand why programmers are so obsessed with videos (when articles are so much more efficient). http://xkcd.com/303/
13:09:47 <hpaste> nschoe pasted “HaskellNet.SMTP test” at http://hpaste.org/47773
13:09:52 <Nimatek> This is the actual reason for template metaprogramming.
13:12:03 <nschoe> Hi everyone, I'm experiencing a small problem with the HaskellNet library in the SMTP module. I'm trying to send an email within a Haskell program, and wrote this: http://hpaste.org/47773 . When I compile it and run my program I got the error:user error (Pattern match failure in do expression at Network/HaskellNet/SMTP.hs:243:26-33). I suppose it is gmail smtp server who need a username and password in order to forward email, but not sure. Can
13:12:03 <nschoe> anyone help me on this one, please? ^^
13:12:47 <chrisdone> Also http://video.google.com/videoplay?docid=-2726904509434151616
13:13:46 <pgavin> nschoe: if a library call is failing like that I would complain to its maintainer
13:14:11 <monochrom> that reminds me to remove google from my flashblock whitelist
13:14:26 <pgavin> monochrom: heh, why?
13:14:41 <nschoe> pgavin, ok, that means it's not gmail-related? The library is "broken"?
13:14:48 <monochrom> video that plays immediately (does not wait for you to tell it to start) is evil
13:14:49 <pgavin> nschoe: I would say so
13:14:54 <pgavin> monochrom: ah, ok
13:14:56 <pgavin> true
13:14:59 <ddarius> monochrom: Unfortunately, Google Maps needs flash to work.
13:15:06 <ddarius> At least for street view.
13:15:09 <monochrom> but thank God for the flashblock plugin for firefox
13:15:23 <nschoe> pgavin, ok, thanks I'll send him an email then.
13:15:27 <monochrom> oh, right, that reminds me of why I had google whitelisted :)
13:15:39 <pgavin> monochrom: damned if you do...
13:15:59 <ddarius> Solution: Press and hold the power button on your computer.
13:16:02 <monochrom> I guess I just have to whitelist it again next time I street-view
13:16:06 <pgavin> you might be able to whitelist just maps.google.com
13:16:23 <Cale> nschoe: The library has some poor error handling there...
13:16:34 <ddarius> That's how I have it set up.
13:16:51 <Cale> nschoe: It assumes that when you send the MAIL command to the server, it's going to get back a 250 response, and pattern matches the 250 directly
13:18:15 <Cale> Oh, I see, it does actually catch the exception and re-throw it as an IO error.
13:18:23 <Cale> But that's not particularly useful.
13:18:50 <Cale> It would be nice if it would throw a more specific error.
13:19:21 <pgavin> so not exactly broken
13:19:29 <pgavin> but not exactly right, either :)
13:19:31 <nschoe> Cale, okay, so it's not really broken?
13:19:33 <Cale> nschoe: Is it possible that it's something like the server needs authentication?
13:19:40 <danharaj> List should be a typeclass or something :|
13:19:47 <chrisdone> monochrom: I like videos that show humans being human in real time. :-)
13:20:10 <pgavin> nschoe: you might be able to catch that exception and report something more useful to the user
13:20:10 <Cale> nschoe: The stupid thing is that the message that was actually returned from the server isn't going to be part of the exception that's passed back
13:20:16 <nschoe> Cale, Yeah. That is exaclty what I am thinking, and if I'm correcto, I should do things "manually" bu using the 'sendCommand' function, right?
13:20:35 <ddarius> chrisdone: I enjoy stop-motion videos.
13:21:44 <chrisdone> (I suppose videos are difficult for non-native speakers and more of a chore.)
13:22:12 <monochrom> my favorite videos are http://www.youtube.com/watch?v=SXmv8quf_xM ("tracer t") and http://www.youtube.com/user/Nikitabanana88
13:22:51 <monochrom> for covariance a few paragraphs and pictures would be way more efficient, thank you very much
13:23:42 <nschoe> Cale, in this case, I know it's not really the channel for that, but let me ask anyway: do you know where I can find an article that explain which commands (and in what order) to issue in order to authenticate and send a msg?
13:24:50 <pgavin> nschoe: umm, the RFC would be authoritative
13:24:53 <ddarius> monochrom: Tracer T has negative efficiency.
13:25:22 <chrisdone> monochrom: With narration about the interactions between the two people and description of pauses and facial expressions, etc.?
13:25:23 <pgavin> http://www.ietf.org/rfc/rfc2821.txt
13:25:24 <dixie> i'm learning space leaking fixing on my program and I have a question. Can 6MB text file read as "String" (no bytestring) consume 70 MB of memory???
13:25:34 <Cale> nschoe: I don't really know anything about SMTP, but have a look at the source code for sendMail as linked from the Haddock documentation
13:25:42 <ddarius> > 24 * 6
13:25:43 <lambdabot>   144
13:25:48 <ddarius> > 12 * 6
13:25:49 <lambdabot>   72
13:25:55 <Cale> nschoe: You could essentially do the same stuff, but manually, and look at what the server actually gives you.
13:26:12 <ddarius> dixie: You're running on a 32-bit machine.
13:26:39 <chrisdone> monochrom: Most of the insight from that video is how they deal with solving problems, merely stating the problem itself and the solutions isn't half the information.
13:26:40 <nschoe> Cale, okay. That's a good idea, thank you.
13:26:44 <nschoe> pgavin, thanks too.
13:26:54 <pgavin> np :)
13:26:57 <monochrom> chrisdone: no. I also find the haskell wikibooks lengthy story-telling to be excessive
13:26:59 <dixie> ddarius: 64bit, but I use 32bit system/libraries etc
13:27:12 <Cale> dixie: String is incredibly space-inefficient, because it's a linked list of 32-bit wide characters
13:27:46 <danharaj> At least on GHC it is.
13:27:50 <Cale> yeah
13:27:58 <dixie> Ok. thanks :) I have to switch to bytestring (it make sense anyway). I didn't realize that :)
13:28:06 <monochrom> Dijkstra successfully demonstrates problem solving processes using very short text and formulas
13:28:17 <Cale> dixie: also consider the text library
13:28:23 <Cale> dixie: if you want Unicode support
13:28:50 * ddarius rewords Cale's sentences.  Use the text library if what you are dealing with is text.
13:29:06 <Cale> Well, that works :)
13:31:38 <chrisdone> monochrom: Alright. I guess a sentence can sum up the nextgenhacker video, “A twelve year old fails at understanding basic networking and unintentionally demonstrates that under the pretense of teaching recondite practices.” ;-D
13:32:11 <chrisdone> monochrom: Yeah, you're right. I *do* get all the humour from just the text!
13:32:15 <monochrom> well, that one is for entertainment, like you said, a video of humans
13:32:26 <chrisdone> monochrom: Ah, okay.
13:33:14 <monochrom> if I were dying to learn covariance, I would not be looking for entertainment, like, I'm dying, I only have 5 minutes to learn covariance, thank you very much
13:34:08 <monochrom> see for example http://www.cs.utexas.edu/users/EWD/ewd12xx/EWD1294a.PDF for how Dijkstra teaches problem-solving without videos
13:34:25 <quotemstr> After reading the literature, it seems like the best known graph representation is a pair of search trees.
13:34:32 <monochrom> to walk you through his thought, even
13:35:08 <thoughtpolice> @quote monochrom if I were dying to learn covariance, I would not be looking for entertainment, like, I'm dying, I only have 5 minutes to learn covariance, thank you very much
13:35:08 <lambdabot> No quotes match. Maybe you made a typo?
13:35:15 <thoughtpolice> @quote+ monochrom if I were dying to learn covariance, I would not be looking for entertainment, like, I'm dying, I only have 5 minutes to learn covariance, thank you very much
13:35:15 <lambdabot> No quotes match. You untyped fool!
13:35:16 <dixie> ddarius: It works with ASCII subset and not with the text. The other characters has to escaped
13:35:20 <thoughtpolice> gaaaah.
13:35:25 * thoughtpolice can't remember lambdabot commands anymore
13:35:25 <monochrom> it is @remember
13:35:26 <thoughtpolice> for shame
13:35:32 <thoughtpolice> @remember monochrom if I were dying to learn covariance, I would not be looking for entertainment, like, I'm dying, I only have 5 minutes to learn covariance, thank you very much
13:35:32 <lambdabot> I will never forget.
13:40:53 <chrisdone> monochrom: Dijkstra, however, as he always did, thought about and planned everything out ahead of time. He wasn't flawless, people make mistakes and get stuck. And if you're interested in seeing people *actually* working, not retrospectively describing the “interesting” bits (i.e. them succeeding and making good decisions), then you ought to see everything. A video will demonstrate that. A pre-planned essay won't.
13:41:09 <luite> is it possible with ghc-pkg or cabal to get a list of exported modules by the latest version of each installed package?
13:41:42 <tgeeky> luite: nope, neither
13:42:40 <Cale> monochrom: trolololol that NextGenHacker video is hilarious!
13:42:50 <chrisdone> monochrom: For example — Dijkstra did video lectures, and he actually works things out. It's the difference between watching someone find their way home when they're lost, and someone drawing a map of how they found their way home, imho.
13:43:11 <monochrom> you haven't seen it before? it's pretty old actually. but now you know of the TracerT monad transformer...
13:43:42 <lolsauce> Dijkstra was a dumbass
13:44:02 <pgavin> luite: you can probably combine "ghc-pkg field foo exposed-modules" with some other shell commands to get what you want
13:44:09 <lolsauce> Glad that guy is dead
13:44:22 <monochrom> there are a couple of people doing parodies. one says "I'm booting linux in virtualbox" but then it boots solaris. then the login name is "ebay".
13:44:26 <chrisdone> Oh, it's this guy again. (￣ー￣)
13:44:41 <lolsauce> Dijkstra considered harmful
13:44:49 <lolsauce> Woah, not anymore hehehe
13:44:55 --- mode: ChanServ set +o monochrom
13:45:09 <lolsauce> problem monochrom?
13:45:12 --- mode: monochrom set +q *!*@gateway/web/freenode/ip.46.246.125.104
13:45:18 --- mode: monochrom set -o monochrom
13:45:31 * tgeeky sets mode +q himself
13:46:22 <chrisdone> monochrom: You don't see the difference in what I mean?
13:46:31 <monochrom> I see. I concede.
13:47:57 <chrisdone> Okies. >_>
13:48:47 <tgeeky> chrisdone: question: if I told you that running hulk (and connecting to it) hard locked the VM I had it on, would you be surprised? :o
13:49:10 <chrisdone> tgeeky: What's a hard (as opposed to soft or other) lock?
13:49:25 <tgeeky> chrisdone: only solution was to kill virtualbox itself
13:49:39 <tgeeky> it did it twice, but only after I connected (from outside the vm)
13:49:42 <tgeeky> so I just moved on
13:50:37 <luite> pgavin: ah thanks, that should do :)
13:50:59 <chrisdone> tgeeky: Hmm. That's not happened to me on three separate machines, two were VMs. Erm. Could possibly be a segfault due to one of the encryption libraries. Hard to say without seeing what config you used.
13:51:22 <tgeeky> chrisdone: ok. I'll give it another shot later this week.
13:52:12 <chrisdone> tgeeky: Did you generate a login password in for the AUTH/passwd_file?
13:52:18 <tgeeky> yep, and I logged in
13:52:45 <tgeeky> and i could see my lambdabot in there a channel, but before I could send a message, the VM locked
13:53:05 <tgeeky> I didn't diagnose it much more, I was trying to ascertain the stability of the package, but it seems that it's stable, so it's probably my fault
13:55:02 <tsuraan_> does "cabal install yices" normally install a "yices" program in ~/.cabal/bin/
13:55:03 <tsuraan_> ?
13:55:17 <chrisdone> tgeeky: I can't think of anything that would cause it to lock up a whole VM. Could you see observe CPU/mem usage of hulk next time you try? That is definitely unexpected.
13:55:30 <tgeeky> chrisdone: yeah, I'll give the debugging the ol' college try.
13:55:42 <tgeeky> but just not today, I need to get something done
13:55:47 <parcs> tsuraan_: check the cabal file
13:55:54 <parcs> it seems that it doesn't
13:56:52 <tsuraan_> strange.  I was trying to play around with Regex.Genex, but it can't do anything without an external "yices" program
13:57:22 <tsuraan_> I guess yices maybe isn't haskell-specific
13:57:23 * hackagebot regex-genex 0.3.0 - From a regex, generate all possible strings it can match  http://hackage.haskell.org/package/regex-genex-0.3.0 (AudreyTang)
13:57:42 <parcs> you need the yices executable from here, i think: http://yices.csl.sri.com/
13:57:44 <tsuraan_> now that's freaky timing :)
13:57:53 <romanandreg> do you know if there is a gsub/replace function in the Standard Library?
13:58:00 <romanandreg> for String
13:58:01 <romanandreg> ?
13:58:03 <tsuraan_> parcs: thanks
13:59:49 <chrisdone> romanandreg: Nope. There is one in Data.List.Util from MissingH.
14:00:32 <chrisdone> Though Data.Text has a replace function.
14:01:14 <roconnor> How come my haskell program runs out of heap with +RTS -M512M -hT, but the resulting graph of the heap profile only goes upto 50M?
14:02:45 <romanandreg> chrisdone: Thanks, at least is on Data.Text
14:02:48 <romanandreg> that's comforting
14:02:49 <romanandreg> :-p
14:03:01 <chrisdone> :-)
14:04:07 <romanandreg> chrisdone: does Data.Text.replace works with RegExp as well? or just plain strings?
14:04:20 <chrisdone> Just plain strings.
14:04:33 <romanandreg> chrisdone: T_T
14:04:35 <romanandreg> hehehe
14:04:43 <chrisdone> I think there's a regex library that works with Text.
14:05:26 <romanandreg> http://hackage.haskell.org/packages/archive/text-icu/0.6.3.4/doc/html/Data-Text-ICU-Regex.html ?
14:05:28 <chrisdone> Your best bet at this point's probably http://hackage.haskell.org/packages/archive/regex-compat/0.95.1/doc/html/Text-Regex.html
14:05:54 <chrisdone> Ah, maybe it was that one.
14:06:06 <Volt_> @hoogle pcre-less
14:06:06 <lambdabot> No results found
14:06:07 <chrisdone> The one I pasted works with strings.
14:06:16 <Volt_> hmm
14:06:18 <chrisdone> (String’s)
14:06:20 <Volt_> http://hackage.haskell.org/package/pcre-less-0.2.1
14:06:29 <Volt_> that has a gsub function
14:06:37 <Volt_> gubg
14:06:40 <Volt_> subg
14:07:35 <chrisdone> IME pcre is unstable. It was the reason hpaste would segfault a few times a day. >_>
14:07:39 <Volt_> oh, the command is @hackage isn't it
14:07:45 <Volt_> @hackage pcre-less
14:07:46 <lambdabot> http://hackage.haskell.org/package/pcre-less
14:09:14 <romanandreg> uhmm
14:09:22 <romanandreg> thanks guys
14:09:37 <chrisdone> :t Text.Regex.mkRegex
14:09:38 <lambdabot> String -> Regex
14:10:11 <chrisdone> > Text.Regex.subRegex (Text.Regex.mkRegex "[a-z]") "hello dave" "_")
14:10:12 <lambdabot>   <no location info>: parse error on input `)'
14:10:18 <chrisdone> > Text.Regex.subRegex (Text.Regex.mkRegex "[a-z]") "hello dave" "_"
14:10:19 <lambdabot>   Not in scope: `Text.Regex.subRegex'Not in scope: `Text.Regex.mkRegex'
14:10:26 <chrisdone> Er, what.
14:10:44 * chrisdone smacks lambdabot up side of the haid
14:10:49 <romanandreg> hehe
14:10:56 <romanandreg> :t Text.Regex.subRegex
14:10:56 <lambdabot> Regex -> String -> String -> String
14:11:46 <chrisdone> I like this library because it's pure Haskell.
14:11:59 <romanandreg> Text.Regex.subRegex (Text.Regex.mkRegex "dave") "hello dave" "****"
14:12:02 <chrisdone> The argument order of subRegex is a bit ass-backwards and Regex isn't an instance of IsString but oh well.
14:12:10 <romanandreg> > Text.Regex.subRegex (Text.Regex.mkRegex "dave") "hello dave" "****"
14:12:11 <lambdabot>   Not in scope: `Text.Regex.subRegex'Not in scope: `Text.Regex.mkRegex'
14:12:24 <romanandreg> > :m + Text.Regex
14:12:24 <lambdabot>   <no location info>: parse error on input `:'
14:12:30 <romanandreg> hehe
14:13:09 <romanandreg> chrisdone: that's important, (the Text.Regex being a full haskell implementation), that way one can avoid awful portability issues
14:13:31 <romanandreg> I think I wouldn't mind a more built in support for Regex in Haskell
14:15:08 <chrisdone> romanandreg: There's a kind of messy reworking of it so you can just write "foo" ~= "bar" and that's a regex operation. But the API is confusing, half documented and incomplete. Hard to say who's orchestrating it but I just avoid Regex in Haskell.
14:15:46 <chrisdone> http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html#glob.regex
14:15:47 <erus`> i like the python functions
14:15:52 <erus`> for regex
14:16:53 <merijn> On the other hand Parsec has been so trivially easy since I started to learn it... it seems you might as well just write a proper parser instead of using regexes in Haskell :>
14:18:29 <chrisdone> Yeah. I either use list functions with Data.Char or full Parsec, pretty much.
14:20:47 <romanandreg> yeah... but sometimes Parser combinators seems overkill for just "replace the string given this regexp" kind of situations don't you think?
14:21:07 <monochrom> if the regexp is simple
14:21:31 <romanandreg> I like Parser combinators (a lot)... but I don't want to label as "The hammer"
14:21:37 <romanandreg> I don't want to label the Parsec libraries as "The Hammer"*
14:21:42 <merijn> romanandreg: Yeah, I'm not saying its ideal. Just the current regex implementation is only so-so and there is not much motivation to improve it
14:22:18 <romanandreg> merjin: yes, exactly... that's the situation so far
14:22:45 <merijn> Of course, should you feel compelled to write a better regex library... ;)
14:22:50 <monochrom> there is a way to replace every prime number in a string (by whatever) using a regexp
14:22:58 <romanandreg> and the problem is that is not that easy to implement regex in Haskell, the approach of really abstract types that can't cast different things is pretty cool, but is really difficult for people to replicate that behaviour
14:23:03 <romanandreg> it seems daunting at the least
14:23:29 <romanandreg> abstract types that can*
14:23:38 <merijn> monochrom: Really?
14:23:51 <monochrom> really. it uses \1 \2 etc of course
14:24:08 <beastaugh> the 'regexp' that does that is not actually a regular expression in the strict sense
14:24:29 <merijn> beastaugh: I was just wondering that, but now I'm not entirely sure its not possible...
14:24:41 <monochrom> not mathematician-strict, but programmer-strict
14:25:49 <merijn> monochrom: What is the difference? I'm not a mathematician but I still think Perl regexes are not regexes
14:26:19 <monochrom> a mathematician strictly rejects \1 \2 etc as part of regex
14:26:40 <monochrom> a perl programmer strictly rejects something to be called "regex" if it doesn't have \1 \2 etc
14:27:09 <beastaugh> indeed
14:27:12 <merijn> If it can only be modeled using a push-down automaton it is not a regex
14:27:52 <merijn> And if Perl programmer strict is now a substitute for programmer strict the world is doomed :p
14:27:55 <monochrom> you can't even get people to agree whether 0 is a natural number, what is 0^0, etc. forget about a universal regex
14:28:19 <hpaste> int80_h pasted “selectField” at http://hpaste.org/47776
14:29:28 <monochrom> I think the sum of perl programmers, python programmers, and shell script programmers dominate the set of programmers who care about something called "regex"
14:29:40 <hpaste> int80_h annotated “selectField” with “selectField - from Yesod.Forms” at http://hpaste.org/47776#a47777
14:29:49 <monochrom> so even though they are still not all of programmers, they are the only one who matter
14:30:55 <merijn> monochrom: I'm pretty sure Python regex are "formal" regexes, i.e. not Perl compatible
14:31:06 <beastaugh> that primality-test regex is essentially an unreadable Prolog program
14:31:27 <samg_> I'm confused by some operaters in this source code: ++> and <++. Anyone seen them before? github.com/jaspervdj/digestive-functors
14:31:40 <merijn> @hoogle (++>)
14:31:40 <lambdabot> No results found
14:31:55 <monochrom> anyway it's an example of "just string replacement by regex" and yet you really want to use parsec or something :)
14:32:15 <samg_> They are used alongside Applicative operators.
14:32:33 <monochrom> they look fishy :)
14:32:51 <samg_> Here is the exact source where I am seeing them: https://github.com/jaspervdj/digestive-functors/blob/master/examples/multi.hs
14:32:58 <samg_> see line 31
14:33:03 <beastaugh> samg_: the definitions are given in the library
14:33:06 <beastaugh> https://github.com/jaspervdj/digestive-functors/blob/master/digestive-functors/src/Text/Digestive/Types.hs#L149-173
14:33:18 <samg_> ah! should have looked there
14:33:19 <samg_> thanks
14:33:25 <beastaugh> no worries
14:33:30 <roconnor> > 40000*6*4
14:33:31 <lambdabot>   960000
14:33:39 <int80_h> questions about Yesod : http://hpaste.org/47776
14:33:45 <roconnor> that isn't even a megabyte
14:35:22 * roconnor wonders how people deal with Data.Maps of 40000 entries
14:36:41 <monochrom> right, it doesn't take 1MB if there is no thunk
14:36:49 <ion> roconnor: What do you mean by that?
14:37:16 <roconnor> I don't know.  I'm just having memory troubles.
14:37:39 <monochrom> there may be unevaluated thunks if you don't look
14:37:46 <tromp> does anyone know how to deal with "utils/ghc-pwd/dist/build/tmp/ghc-pwd: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory" while installing ghc?
14:37:56 <roconnor> I have a map, but I'm keeping a long list of checkpoints of that map as I insert
14:38:04 <roconnor> I can't tell if my memory use is too large or normal
14:38:23 <roconnor> I imagined I have a lot fo sharing between my checkpoints
14:38:53 <roconnor> there doesn't seem to be a strict version of Data.Map.Insert
14:39:17 <thoughtpolice> tromp: you'll need libgmp3-dev installed (on debian, for example)
14:39:56 <tromp> does it need to be in standard location (i.e. requiring sudo) ?
14:40:03 <roconnor> I didn't really learn anything from the heap charts
14:40:23 <monochrom> Data.Map.insert is strict enough
14:40:34 <roconnor> I exhaust my 512MB heap, but the heap chart only goes upto 50MB
14:40:46 <roconnor> so I'm not sure where the other 450MB went
14:40:52 <monochrom> it doesn't force the value, but you can force the value yourself easily with $!
14:41:17 <monochrom> Data.Map.insertWith is the one not strict enough, but there is Data.Map.insertWith' to remedy that
14:42:49 <roconnor> nah I just use insert and delete
14:43:09 <roconnor> why would the heap graph only go upto 50?
14:43:54 <Eduard_Munteanu> > (iterate (+1) 0) !! 100000
14:43:55 <lambdabot>   100000
14:44:06 <Eduard_Munteanu> > (iterate (+1) 0) !! 10000000
14:44:14 <lambdabot>   mueval: ExitFailure 1
14:44:14 <lambdabot>  mueval-core: Time limit exceeded
14:44:18 <monochrom> how large is each key? how large is each value?
14:44:22 <ion> > iterate (+10000000) 0 !! 1
14:44:25 <lambdabot>   10000000
14:44:40 <roconnor> key is 9 word32s
14:45:03 <roconnor> value varies in length.  It has a list in it, but usually the list is small.
14:46:19 <roconnor> I've scatter some seq into my code but to no effect yet.
14:46:29 <Eduard_Munteanu> Note it probably won't do unless you go through it and force each checkpoint.
14:46:49 <roconnor> won't do what?
14:47:11 <Eduard_Munteanu> Won't do... won't work.
14:47:35 <roconnor> would one lookup force the checkpoint?
14:48:04 <Eduard_Munteanu> I'm not sure.
14:48:28 <roconnor> What I don't get is why the heap chart is 1/10th the size of my heap that gets exhausted.
14:48:32 <Eduard_Munteanu> If the lookup isn't strict enough you'll still have thunks dangling there.
14:48:51 <roconnor> how can a lookup not be strict enough?
14:51:12 <roconnor> maybe I don't understand what -hT does
14:53:16 <monochrom> suppose you do "foldl insert empty blahblah", it is normally a large thunk full of insert's, not the final binary search tree
14:53:38 <roconnor> monochrom: then I do a lookup and?
14:53:52 <int80_h> @hoogle reads
14:53:53 <lambdabot> Prelude reads :: Read a => ReadS a
14:53:53 <lambdabot> Text.Read reads :: Read a => ReadS a
14:53:53 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
14:54:03 <monochrom> if the lookup is forced, now the insert's are all forced and you get a binary search tree
14:54:27 <monochrom> some stack is needed in the process
14:54:37 <xplat> is the implicit Maybe (=>) syntax for view patterns in GHC7?
14:54:41 <roconnor> I'm reguarly doing lookups during my construction and checkpoing of my map.
14:54:58 <lpsmith> ok, I tried to add a -Wall -fno-warn-name-shadowing  in my .cabal file, yet GHC is still warning about shadowing.
14:55:07 <int80_h> @src reads
14:55:07 <lambdabot> reads = readsPrec minPrec
14:55:15 <monochrom> make sure those lookups are forced too
14:55:23 <int80_h> @hoogle read
14:55:23 <lambdabot> Prelude read :: Read a => String -> a
14:55:23 <lambdabot> Text.Read read :: Read a => String -> a
14:55:23 <lambdabot> module Text.Read
14:55:33 <roconnor> hmm
14:55:49 <roconnor> I'm printing the size of the map at each checkpoint
14:55:49 <int80_h> ^read "1" :: Int
14:55:59 <roconnor> that should force things
14:56:00 <int80_h> >read "1" :: Int
14:56:05 <int80_h> > read "1" :: Int
14:56:06 <monochrom> that will force enough, yes
14:56:06 <lambdabot>   1
14:56:23 <int80_h> > reads "1" :: Int
14:56:24 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
14:56:24 <lambdabot>         against inferred type ...
14:56:43 <int80_h> could someone tell me how to use "reads" properly?
14:56:47 <roconnor> maybe +RTS -hc will tell me something
14:56:59 <int80_h> > reads "1"
14:57:00 <lambdabot>   []
14:57:11 <int80_h> > reads "12"
14:57:12 <lambdabot>   []
14:57:15 <monochrom> however, because of tree balancing, sharing between checkpoints may not be as much as you would like
14:57:15 <ion> > (reads :: ReadS Int) "1"
14:57:17 <lambdabot>   [(1,"")]
14:57:57 <int80_h> ion: how could I populate the String in the returned pair?
14:58:08 <ion> > (reads :: ReadS Int) "1parsefail"
14:58:09 <lambdabot>   [(1,"parsefail")]
14:58:36 <Design1> Hi, is it possible that the "hello word" of the Happstack's Crash Course eats up to 250MB of RAM?
14:58:40 <ion> > (reads :: ReadS [Integer]) "[1,2]parsefail"
14:58:41 <lambdabot>   [([1,2],"parsefail")]
14:58:47 <roconnor> monochrom: think I'd get more sharing with a hashmap?
14:58:56 <monochrom> I don't know
14:59:12 <int80_h> > (reads :: ReadS Int) ["1parsefail","2moorfails"]
14:59:13 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:59:13 <lambdabot>         against inferred type...
14:59:30 <monochrom> hashmap is a trie. that is the end of what I know
14:59:44 <roconnor> :)
15:00:02 <roconnor> I can imagine inserting and deleting in a trie would keep more sharing
15:00:08 <monochrom> I haven't learned trie for real
15:00:28 <int80_h> ion: how about populating the returned list with multiple pairs, like I just tried to do
15:00:32 <Nimatek> Design1: That would be strange.
15:01:08 <Design1> <Nimatek> Me too. I'm a beginner with Haskell so I don't know if it is a normal thing.
15:01:28 <int80_h> > (reads :: ReadS Int) ["1parsefail","2moorfails"]
15:01:29 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
15:01:29 <lambdabot>         against inferred type...
15:01:38 <Nimatek> Design1: uses 1.5mb resident here.
15:01:39 <Design1> <Nimatek> I used this for the test: siege -c30 -b -t30S http://localhost:8000
15:01:43 <int80_h> > (reads :: ReadS Int) "1parsefail" "2moorfails"
15:01:44 <lambdabot>   Couldn't match expected type `t1 -> t'
15:01:44 <ion> int80_h: AFAIR multiple pairs would mean alternative matching parse results, and an implementation of reads could provide them, but the current one doesn’t (as it doesn’t tend to be that useful).
15:01:44 <lambdabot>         against inferred type `[(GHC...
15:02:30 <ion> For more advanced parsing you might want a full parsing library such as Parsec.
15:02:46 <Design1> <Nimatek> I compiled statically with GHC the "hello world" code (few lines of code)...
15:02:48 <int80_h> ion: I see, so anything useful will be in the first member of the pair, in the form of a list
15:03:00 <int80_h> ion: that's helpful!
15:03:47 <dankna> (this question should go to #ghc but I bet someone here can help me faster :D)
15:03:53 <Design1> <Nimatek> When I execute the binary it takes about 0.3MB, but after the siege it takes about 250MB and does not release it.
15:04:11 <dankna> so I've got a committed patch in my local copy of the GHC repo.  how do I send it to the appropriate people for their attention?
15:04:11 <ion> A valud parse result from reads is a non-empty list of pairs where fst has the result and snd is empty, and you generally only need to care about the first item of the list.
15:04:24 <Nimatek> Design1: I just tested that, uses 150mb here now.
15:04:52 <ion> case reads … of (result, ""):_ -> success; _ -> failure
15:05:31 <Design1> <Nimatek> I've not experience with Haskell, but it seems an exageration. A bigger Django site that I use for comparison took only 10MB...
15:06:06 <Nimatek> Design1: I'm new to Haskell too, by the way :)
15:06:26 <Design1> <Nimatek> Harg! ^_^
15:07:15 <Design1> There is anyone that uses Haskell in production for a web site?
15:08:17 <ion> > let f s = case reads s of (result, ""):_ -> Just result; _ -> Nothing in map f ["42", "", "42foo"] :: [Maybe Integer]
15:08:18 <lambdabot>   [Just 42,Nothing,Nothing]
15:08:20 <Eduard_Munteanu> What do you mean by "in production"? For a commercial website?
15:08:33 <Eduard_Munteanu> Erm, or a large website?
15:08:44 <Design1> <Eduard_Munteanu> For a public non trivial web site
15:09:23 <Design1> <Eduard_Munteanu> I mean something that is for a client, little or big is not important :)
15:09:30 <ion> int80_h: ↑
15:09:46 <Eduard_Munteanu> http://www.yesodweb.com/page/testimonials
15:10:08 <Design1> <Eduard_Munteanu> I'm a beginner so I have not enough experience with Haskell but I have problems with memory consumption
15:11:32 <adimit> Is there a function somewhere on hackage that'll fator an Int (or Integer) to [Word8]?
15:11:35 <Design1> <Eduard_Munteanu> How much RAM your web application consumes?
15:11:41 <Eduard_Munteanu> Not sure about public though, but it's a start.
15:11:57 <Eduard_Munteanu> Oh, that's not mine. I just looked it up for you.
15:12:00 <test123978456> hi
15:12:03 <adimit> I want to represent big integers as ByteStrings. I could of course perform the factorization myself, but maybe there's some library function…
15:12:31 <ion> adimit: Why, btw?
15:12:41 <test123978456> please tell me why this doesn't work: [(1,2,_)] `elem` [(4,5,6), (1,2,3)]
15:12:52 <test123978456> or how to make it work
15:12:56 <Eduard_Munteanu> Design1: you might want to look at this: http://www.haskell.org/haskellwiki/Performance
15:13:03 <ion> test123978456: You can’t apply a function to a pattern.
15:13:25 <Eduard_Munteanu> And try to figure where your space leak lies.
15:13:26 <adimit> ion: short version: data compression.
15:13:30 <Design1> <Eduard_Munteanu> Actually I'm not so much interested about the framework to use but how much RAM Haskell uses for a web site
15:13:33 <test123978456> ion, how can I avoid this?
15:13:47 <adimit> ion: long version: big list of memory-expensive stuff, but a finite domain. Index over it.
15:14:21 <Saizan> Design1: that question doesn't make sense
15:14:45 <adimit> Since my list is finite, and because of its specific size, instead of storing the data itself, I could store 3-byte indices (in a database.) that'd save me a lot. So I have a conversion table that gives each unique data point an index in Int.
15:14:47 <Eduard_Munteanu> Yeah, it's a big "it depends".
15:14:53 <Design1> <Eduard_Munteanu> Thanks, but that document does not help me about memory usage for a generic web application (daemon)
15:14:58 <adimit> Now I need to turn Int into 3 bytes :-)
15:15:07 <test123978456> i wanna see if tuple (x, y, _) exists in list of tuples
15:15:11 <ion> > any (\n -> case n of (1,2,_) -> True; _ -> False) [(4,5,6), (1,2,3)]
15:15:12 <lambdabot>   True
15:15:27 <Eduard_Munteanu> Design1: what libs are you using?
15:15:31 <Saizan> Design1: anyhow, you can write haskell web applications that use small amounts of memory
15:16:00 <Eduard_Munteanu> It matters if it's Yesod or something else.
15:16:08 <Design1> <Eduard_Munteanu> For you, is it possibile that an application whithout a database connection, without loading a template, uses 250MB when a Python script uses about 6MB? For me there is something that's wrong...
15:16:46 <Design1> <Eduard_Munteanu> I tried with Happstack. The test is: siege -c30 -b -t30S http://localhost:8000
15:17:06 <Saizan> Design1: yes, there's probably something wrong in your code
15:17:15 <test123978456> ion, err, i don't get it at all
15:17:42 <Design1> <Saizan> I uses this code (the first 4 lines script): http://www.happstack.com/docs/crashcourse/HelloWorld.html#hello_world
15:17:45 <Saizan> Design1: btw, there's #happs for happstack specific help
15:17:49 <ion> test123978456: I recommend reading LYAH.
15:17:50 <ion> @where lyah
15:17:50 <lambdabot> http://www.learnyouahaskell.com/
15:19:05 <Design1> <Saizan> No replies in #happs. Actually I see someone :)
15:19:15 <tekknolagi> hello
15:19:29 <test123978456> i mean whats wrong with that: any (\n -> case n of (1,2,_) -> True; _ -> False) ys = unique xs ys
15:19:42 <test123978456> it's part of my guard (|)
15:19:58 <ion> design1: That notation generally means a quote from Saizan. Saizan never said that at least on this channel.
15:20:26 <Saizan> ion: he's using that in place of "Saizan:" apparently
15:20:48 <Eduard_Munteanu> Design1: are you using tab-completion, or merely pasting our nicks?
15:21:13 <Design1> <Eduard_Munteanu> Pasting
15:21:39 <Eduard_Munteanu> Design1: try typing 'edu' then pressing tab
15:21:40 <Cale> test123978456: not much, except the guard itself is missing...
15:21:43 <Design1> Eduard_Munteanu: sorry but I don't use IRS since years...!
15:22:17 <test123978456> ok, nvm, got my bug ;)
15:22:18 <test123978456> thanks
15:31:28 <Scriptor> hi everyone, I have a question about exercise 2.3 in purely functional data structures
15:31:47 <Scriptor> it's basically asking how to implement insert into a binary search tree without path copying
15:32:18 <Scriptor> by using exceptions, but I can't figure out how you'd go about doing that
15:35:39 <monochrom> no, it is specifically inserting an element that is already present in the tree, and so there should be nothing to copy
15:35:56 <Scriptor> ah, I see
15:36:24 <Scriptor> ... "existing element" goddamnit I didn't read too closely
15:36:29 <roconnor> still, my heap chart only goes upto 50M
15:36:34 <roconnor> why am I running out of heap?
15:36:41 * shachaf fails to find "Exercises" section in PhD thesis.
15:37:11 <Scriptor> shachaf: yea, it's only in the book form
15:37:46 <Scriptor> but monochrom is right, I just read the question wrong, it's asking for how to handle the case where you insert an element that already exists
15:37:59 <monochrom> http://www.amazon.com/not-exactly-the-thesis/dp/0521663504/
15:39:49 <monochrom> I can do it with "one handler per iteration". it should be easy. but the challenge is "don't do that, only one handler per insertion"
15:40:50 <jrope> Has anyone here worked with snap-auth?
15:41:46 <c_wraith> jrope: check out #snapframework .  Might get more attention there.
15:41:55 <shachaf> jrope: Perhaps somebody in #sn pframework? :-)
15:42:05 <jrope> ah, thanks, good call
15:42:18 * shachaf manages to escape etabot.
15:42:33 <c_wraith> heh.  that's why you threw in that space? :)
15:43:28 <int80_h> @hoogle lookup
15:43:28 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
15:43:28 <lambdabot> Data.HashTable lookup :: HashTable key val -> key -> IO (Maybe val)
15:43:28 <lambdabot> Data.IntMap lookup :: Key -> IntMap a -> Maybe a
15:56:34 <shachaf> c_wraith: That bot is infuriating.
15:56:59 <shachaf> (If you're the sort of person who gets infuriated by that sort of thing.)
15:58:17 <danharaj> :t (.)
15:58:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:58:52 <danharaj> I sometimes feel like exponential objects should be a type class, and (.) and curry are typed more generally.
15:59:47 <danharaj> curry/uncurry
16:00:53 <c_wraith> danharaj: isn't that the Category approach to everything?
16:01:50 <danharaj> c_wraith: Yeah.
16:02:56 <danharaj> c_wraith: For example, if you represented linear transformations as matrices and wanted (.) to be matrix multiplication.
16:03:52 <c_wraith> would the extra parameters include dimensions then?  that's kinda cool.
16:04:09 <c_wraith> in fact, yes, they'd be vector sizes
16:05:33 <danharaj> I wouldn't mind (.) being partial, but yeah if you could encode dimension in the types of vectors then you could respect that.
16:21:28 <c_wraith> (.) being partial means it's not a category anymore...  It's a...  hmm, I forgot the name.
16:22:16 <xplat> (.) being partial is a category, but if it's even MORE partial it's a precategory
16:22:30 <xplat> iirc
16:22:57 <c_wraith> I thought being a category meant that arrows composed
16:25:10 <xplat> arrows compose only if the head of one matches the tail of the other
16:25:27 <xplat> that's what makes them different from monoids
16:26:29 <xplat> see also: http://nlab.mathforge.org/nlab/show/paracategory
16:26:49 <xplat> wow, the url for nlab changed
16:28:07 <c_wraith> oh, ok
16:37:56 <xplat> is the implicit Maybe (=>) syntax for view patterns in GHC7?
16:38:09 <xplat> or is that still under development?
18:41:23 --- topic: '["Paste code/errors: http://hpaste.org/new/haskell ", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin and spam issues: #haskell-ops"]'
18:41:23 --- topic: set by mauke!~mauke@p3m/member/mauke on [Sat Jun 11 05:12:13 2011]
18:41:58 <benmachine> monochrom: you sure?
18:42:06 <benmachine> "The sort function implements a stable sorting algorithm. It is a special case of sortBy, which allows the programmer to supply their own comparison function."
18:42:09 <benmachine> http://haskell.org/onlinereport/haskell2010/haskellch20.html#x28-23000020.2
18:42:47 <dolio> It's specified by the standard to be insertion sort.
18:42:48 <monochrom> darn, I missed that
18:43:04 <dolio> So whatever the actual implementation is, it'd better be compatible.
18:43:10 <tgeeky> i took 'stable' to mean 'used to check sorting algorithims against'
18:43:44 <monochrom> heh, no, not the software "enginnering" kind of "stable"
18:44:05 <tgeeky> 'stable' as in, resistant to R7.2 earthquakes
18:53:48 <int80_h> any yesod users here?
18:54:05 <sshc> "{-# OPTIONS_GHC -fcontext-stack=1024 #-}" seems to have no effect, but passing -fcontext-stack=1024 on the command line does
18:54:34 <aavogt> sshc: where is the code that triggers the overflow?
18:55:35 * aavogt has some code which seems to need    {-# OPTIONS_GHC -fcontext-stack=81 #-}
18:56:04 <sshc> aavogt: It's only located on my computer.  Why is that important?
18:56:57 <sshc> I'm wondering why the pragma has no effect, but passing it to ghci on the command line does
18:56:59 <aavogt> sshc: I mean if the type that has trouble finding correct instances is in your file, or typed into the ghci
18:57:50 <aavogt> when you load files, the -fcontext-stack isn't set for the ghci I think
18:57:57 <sshc> Oh.  That explains it, then.
18:59:45 <sshc> (The need to specify a *fixed* setting for that seems *possibly* symptomic of a shortcoming in design.  I don't know about it, though; is it really that difficult to let it grow dynamically at runtime as needed?)
19:00:17 <monochrom> for dealing with undecidable instances?
19:02:10 <monochrom> http://xkcd.com/303/ would come true
19:03:27 * sshc searches the manual for -fcontext-stack
19:05:56 <Jafet> Uhh, you just need to supply the correct busy beaver number to -fcontext-stack.
19:06:19 <monochrom> or look for such a number dynamically at runtime
19:07:19 <aavogt> what are you doing that needs such a context stack?
19:07:23 <sshc> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#undecidable-instances
19:07:38 <aavogt> you can have types which are many pages long with only a double-digit context stack
19:08:07 <sshc> Is it possible to remove the limit?
19:08:13 <aavogt> (not that you write them out explicitly)
19:08:19 <sshc> I probably could provide a reasonably high number
19:08:23 <dibblego> why prefer Text over [Char]?
19:08:31 <dolio> Performance.
19:08:34 <aavogt> you hate pattern matching
19:09:10 <Jafet> And view patterns
19:09:38 <monochrom> it is possible to give a very large limit
19:09:50 <sshc> aavogt: 99's too small
19:10:21 <monochrom> perhaps 2^32-1 will suit you. practically you won't even wait that long yourself if it comes to that
19:11:14 <dolio> Are we writing the Ackermann function in the type system or something?
19:11:23 <Jafet> What if your instances used CPS
19:11:33 <monochrom> hahaha
19:11:37 <sshc> aavogt: ghci blows up in my face if it's set to 99
19:11:58 <sshc> With pages and pages of backtrace
19:12:16 <Jafet> Metaprogramming: "Why are you rewriting your types in Agda?" "Er, performance."
19:12:47 <sshc> dolio: Um, … something like that :)
19:13:12 <sshc> I'm following "faking dependently-typed programming in Haskell" and want to do some experimenting
19:13:53 <monochrom> since you're experimenting, how do you know that your experiment should even terminate?
19:14:01 <monochrom> do you have a termination proof?
19:14:48 <monochrom> normally, a cost bound can be extracted from a termination proof. what is the extracted bound?
19:30:46 <danharaj> I feel silly using toList . fromList instead of nub to nub lists, but alas.
19:30:59 <danharaj> (Data.Set)
19:32:11 <sshc> danharaj: Why would you do that?
19:32:40 <byorgey> sshc: it's faster
19:32:59 <sshc> Oh.  Interesting.
19:33:00 <Cale> danharaj: You could use map head . group . sort
19:33:31 <danharaj> Cale: That's true. I wonder how the two would benchmark against each other.
19:33:45 <gwern> data.set won, iirc
19:34:12 <gwern> the map head idiom had some very bad cases
19:34:24 <gwern> again, iirc. been a while since I ran my little benchmarks
19:35:03 <monqy> so is nub quadratic? is there any reason?
19:35:34 <dolio> It's impossible to do better with just Eq.
19:35:44 <monqy> oh right that
19:36:33 <Jafet> nub is lazy, though.
19:36:53 <dolio> You can write a lazy O(n log n) nub with Ord.
19:36:56 <Jafet> You could be lazy with Set and possibly a bit faster, but it's not a one-liner
19:37:07 <gwern> note that the Data.Set trick requires a different type sig
19:37:13 <gwern> Ord, I think, because it's building a tree
19:37:21 <Jafet> O(n log m), where m is the output size
19:37:29 <dolio> Yes.
19:37:42 <dolio> nub is O(n*m).
19:39:11 <danharaj> so I'm confused why Data.Set has `elems', `toList', and `toAscList'
19:39:33 <danharaj> the documentation doesn't say if they return equal results or not.
19:39:42 <Jafet> Presumably toAscList is the inverse of fromAscList
19:39:49 <Jafet> Even for strange inputs
19:40:05 <aavogt> they are implemented in the same way last I checked
19:40:43 <Jafet> Uh yeah, they would be
19:41:16 <danharaj> The docs should say that :|
19:41:39 <Jafet> Bug the maintainer
19:41:45 <aavogt> maybe they are leaving themselves some room to change them
19:42:02 <danharaj> Maybe I will at some point.
19:42:05 <Jafet> I don't see any sensible way to change them.
19:42:23 <Jafet> Maybe that's why no one complained so far; they have to be the same
19:42:31 <aavogt> if the Data.Set.Set is implemented differently, the toList might be quicker than toAscList
19:43:36 <Jafet> You'd change the big-O of half the module functions anyway, if you did that
19:43:55 <Jafet> Or worse, the type signatures
19:44:14 <danharaj> d'oh
19:44:15 <blackdog> @tell shapr ping me when you're back? i need to ask you some questinos about sharepoint
19:44:15 <lambdabot> Consider it noted.
19:44:23 <danharaj> Why is findMin O(log n) instead of O(1) :\
19:44:24 <blackdog> (much as i hate to do it to the poor bastard)
19:44:50 <byorgey> sharepoint?
19:45:03 * byorgey shudders
19:45:18 <xplat> it's probably more like 'if you dump it with toFoo, it is guaranteed to load right with fromFoo, and this can even be preserved across other people's implementations of sets if they'd like to be compatible that way'
19:45:25 <blackdog> byorgey: you hate death, but you don't hate doctors because of it :)
19:45:54 <Jafet> But you still shudder at medicine
19:46:17 <dolio> Finding the minimum element of a balanced tree is O(log n).
19:46:41 * byorgey concedes that is true but is unsure which parts of the metaphor correspond to what
19:46:43 <xplat> a finger tree, otoh
19:47:22 <xplat> but of course you make up for it elsewhere
19:47:34 <danharaj> I have to wonder what trade-offs were considered when choosing the underlying representation of Data.Set
19:50:57 <Jafet> Probably none in particular, since it's the generic ordered set library
19:58:37 <weinuth> Hey there, haskell newbie here, I could use a little help. I'm trying to use the redis package, and there's something wrong with me doing this, something about ambiguous types: items <- smembers r (B.pack "key")
20:01:20 <weinuth> and I had the same trouble with (toBS "key"). Does this look like a common mistake I'm making?
20:04:33 <blackdog> weinuth: you might have OverloadedStrings on?
20:05:00 <weinuth> yessir I do, I don't know what that does. This is scaffolded by Yesod
20:05:11 <shachaf> blackdog: That would only help resolve ambiguity. :-)
20:05:22 <blackdog> basically, it means you need to constrain the type a bit more - the type inferencer has found multiple types that might work, and isn't sure which to use
20:05:23 <shachaf> weinuth: If you have that, you might be able to replace (B.pack "key") with just "key".
20:05:40 <shachaf> blackdog: (Assuming B.pack :: String -> ByteString, which it seems to be.)
20:05:43 <blackdog> yeah, you don't need to pack if overloadedstrings is on
20:05:52 <blackdog> anyway, post a sample
20:12:38 <weinuth> Thanks blackdog and shachaf, that was really helpful. Now I see that another part was depending on OverloadedStrings...well I'm just messing around, this is literally my first attempt after reading Learn You a Haskell. Thanks!
20:13:48 <luite> web frameworks tend to use those, otherwise they'd lose in benchmarks to node.js ;)
20:23:21 <shachaf> Is there a reasonable way to pick a random element out of a Data.Set?
20:25:59 <Cale> shachaf: hmmm...
20:26:15 <QinGW> zZz...
20:27:15 <Cale> I think it's possible the best thing is just to convert to a Sequence.
20:27:35 <shachaf> And then index it by a random index?
20:28:12 <Cale> yeah
20:29:01 <shachaf> That seems slightly silly.
20:29:36 <shachaf> I suppose I can just use a Seq instead of a Set, since I don't really need set operations.
20:30:25 <Cale> Technically, due to its implementation, it would be possible to index a Set like that faster than the library actually exposes.
20:30:52 <shachaf> It's just a balanced binary tree, right?
20:30:55 <Cale> But perhaps they're not exposing that possibility because they don't want to pin that aspect of the implementation down
20:31:28 <Cale> Yeah -- importantly with each branch labelled with a size.
20:31:50 <Cale> (So you could do a binary search to find the nth element if you wanted.)
20:31:53 <shachaf> I suppose that makes some sense, but it's still slightly annoying. :-)
20:33:06 <Cale> Might be worth mentioning on the libraries mailing list to see what people think.
20:33:28 <shachaf> I don't particularly care about it being perfectly random. Just randomly going down a branch until reaching a leaf would be good enough for me.
20:34:13 <luite> Data.Map does support retrieving by index
20:34:34 <luite> maybe you can use a Data.Map k () instead?
20:36:43 <shachaf> Map k () instead of Set k? :-(
20:37:35 <luite> yes, not ideal, but at least it supports all the Data.Set operations efficiently, and you don't need to convert it to uniformly sample :)
20:39:00 <luite> both Data.Map and Data.Set claim to O(1) compelxity for size
20:39:40 <Jafet> You could just copy the Set source code, right?
20:40:04 <Jafet> :t Data.ByteString.pack
20:40:05 <lambdabot> [Word8] -> BSC.ByteString
20:40:12 <luite> yes, it would probably be easy, that complexity indicates that the nodes are already labeled with subtree sizes
20:40:50 <Jafet> String -> ByteString isn't quite correct, unless the encoding is specified
20:41:14 <luite> depends on which ByteString
20:41:32 <shachaf> Jafet: True. But that still won't cause OverloadedStrings ambiguity, will it?
20:41:34 <Jafet> luite: it could also be implemented by storing the size separately and updating, since subtrees are not required to be similar
20:42:22 <Jafet> Hm, IsString for [Word8]? *coughs*
20:43:06 <luite> Jafet: hmm, true. let's check the source :)
20:43:22 <luite>               | Bin {-# UNPACK #-} !Size a !(Set a) !(Set a)
20:43:31 <Jafet> That is, you can't take a subtree of a Set and pretend it's also a Set.
20:43:32 <shachaf> Jafet: Right, but GHC doesn't say "ambiguous types" for that. :-)
20:44:59 * shachaf wishes newtypes were more convenient to use so they could be more prevalent.
20:46:02 <Jafet> The line that separates type from newtype is partly one of inconvenienxe
20:47:05 <shachaf> Mostly, I think.
22:16:41 <holmak> @djinn (a -> f b) -> (c, a) -> f (c, b)
22:16:42 <lambdabot> -- f cannot be realized.
22:17:08 <holmak> @djinn (a -> m b) -> (c, a) -> m (c, b)
22:17:08 <lambdabot> -- f cannot be realized.
22:17:30 <Jafet> @djinn Functor f => (a -> f b) -> (c, a) -> f (c, b)
22:17:31 <lambdabot> Error: Class not found: Functor
22:17:36 <Jafet> @djinn Monad f => (a -> f b) -> (c, a) -> f (c, b)
22:17:37 <lambdabot> -- f cannot be realized.
22:18:30 <Jafet> Sure it can
22:19:07 <holmak> I'm trying to do (second f), where (f :: a -> Maybe b)
22:19:18 <holmak> so, lifting the Maybe outside the tuple
22:19:19 <copumpkin> > strength . fmap ?f
22:19:23 <lambdabot>   mueval-core: Time limit exceeded
22:19:25 <copumpkin> :t strength . fmap ?f
22:19:26 <lambdabot> forall a1 (f :: * -> *) a a11. (Functor f, ?f::a11 -> f a) => (a1, a11) -> f (a1, a)
22:19:38 <Jafet> second doesn't lift that way
22:19:43 <Jafet> Look at the types
22:19:46 <copumpkin> :t \f -> strength . fmap f
22:19:46 <lambdabot> forall a1 (f :: * -> *) a a11. (Functor f) => (a11 -> f a) -> (a1, a11) -> f (a1, a)
22:19:47 <holmak> Yes, I know
22:20:07 <dolio> Those are DMTL quality names.
22:20:23 <copumpkin> I'm kind of surprised at them
22:20:41 <dolio> @type strength
22:20:41 <lambdabot> forall a1 (f :: * -> *) a. (Functor f) => (a1, f a) -> f (a1, a)
22:21:02 <Jafet> @pl \f (c, a) -> f a >>= \b -> return (c, b)
22:21:03 <lambdabot> (`ap` snd) . (. fst) . (. ((return .) . (,))) . flip . ((>>=) .)
22:21:23 <copumpkin> Jafet: why use Monad when it can be done for any Functor!
22:22:33 <Jafet> Hm, I've never really looked into the Functors that aren't Monads
22:23:43 <Jafet> @index strength
22:23:43 <lambdabot> bzzt
22:24:10 <holmak> @type \f (x, y) -> (x,) <*> (f y)
22:24:10 <lambdabot> Illegal tuple section: use -XTupleSections
22:24:19 <holmak> Bah!
22:24:40 <holmak> @type \f (x, y) -> (\z -> (x,z)) <*> (f y)
22:24:41 <lambdabot>     Couldn't match expected type `a -> b'
22:24:41 <lambdabot>            against inferred type `(t, t1)'
22:24:41 <lambdabot>     In the expression: (x, z)
22:24:57 <holmak> @type \f (x, y) -> (\z -> (x,z)) <$> (f y)
22:24:58 <lambdabot> forall t t1 a (f :: * -> *). (Functor f) => (t1 -> f a) -> (t, t1) -> f (t, a)
22:25:07 <holmak> Victory!
22:26:40 <Jafet> (,) x
22:27:10 <holmak> @type \f (x, y) -> ((,) x) <$> (f y)
22:27:11 <lambdabot> forall t t1 a (f :: * -> *). (Functor f) => (t1 -> f a) -> (t, t1) -> f (t, a)
22:27:18 <holmak> Good call, Jafet
22:40:01 <taotree> so if I need fast random access to a list by index... I see an array package, a vector package...  what do I use?
22:42:45 <Jafet> Well, none of them behave like lists.
22:43:18 <Jafet> If you want arrays, there's Data.Array, vector, repa...
22:43:53 <taotree> sorry, by list I meant an ordering of objects... not a linked list
22:44:28 <Jafet> Not all list containers are linked lists.
22:44:43 <Jafet> Sequence uses a tree.
22:45:09 <taotree> right... why do you say array/vector don't behave like lists?
22:46:54 <taotree> oh... looks like Sequence is probably what I want
22:48:39 <Jafet> Let's see... no cons, no append, no incremental updates
22:49:14 <taotree> ah, ok, I understand. Right, it is Sequence I want then. Thanks!
23:40:35 <resistor> anyone around who understands the "-morphism" recursion schemes?
23:42:56 <shachaf> resistor: Probably at least some of them. If you have a specific question, you should ask it so they can see. :-)
23:44:50 <resistor> well, i'm trying to understand them.  i think i have a grasp of catamorphisms and anamorphisms (since they have fairly concrete examples)
23:45:14 <resistor> my current thought is trying to express the minimax algorithm in terms of them
23:45:30 <resistor> i think it's a hylomorphism, but maybe something more specific?
23:45:46 <resistor> i don't really understand the more complex forms, and finding examples is proving hard
23:49:48 <resistor> *crickets* ;-)
23:59:55 <erus`> whats a good datatype for fixed length array with random access and quick modification ?
