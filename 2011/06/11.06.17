00:02:53 <hpaste> gienah pasted “gentoo ghci -package ghc” at http://hpaste.org/47905
00:04:18 <gienah> slyfox^w: my ghci -package ghc output built with portage, ghc 7.0.4, in case its of any interest: http://hpaste.org/47905
00:32:55 * hackagebot groundhog 0.0.1.1 - Type-safe ADT-database mapping library.  http://hackage.haskell.org/package/groundhog-0.0.1.1 (BorisLykah)
00:34:55 * hackagebot groundhog-sqlite 0.0.1.1 - Backend for the groundhog library using sqlite3.  http://hackage.haskell.org/package/groundhog-sqlite-0.0.1.1 (BorisLykah)
00:43:48 <develhevel> where is the difference when i use the FFI if i write unsafe or not to a ccall?
00:44:34 <gienah> develhevel: its unsafe if the C or native code may callback into the Haskell code
00:45:49 <develhevel> so it could be good if i dont know it, always to use unsafe?
00:47:08 <develhevel> when i want to test a functiom with a Ptr CInt, how can i create a Ptr in the ghci?
00:49:11 <Botje> develhevel: there's a malloc and a mallocBytes
00:49:24 <Botje> in Foreign.Marshall.Alloc
00:50:17 <develhevel> thx :)
01:20:55 <osfameron> is there a way to use [] syntax for any list types other than the builtin one?
01:24:32 <Phyx-> osfameron: no, the [] can't be specified at source level
01:25:21 <Axman6> it's one of the few pieces of actually special syntax
01:25:26 <osfameron> fair enough
01:25:42 <osfameron> I was looking at this post (vaguely perl-related, quite cryptic) http://www.modernperlbooks.com/mt/2011/06/meaning-mechanism-type-tyranny.html
01:26:10 <osfameron> there's a mechanism in Perl to allow you to pretend that an object is a builtin data structure, but it seems to be out of fashion these days
01:27:00 <osfameron> I guess with fmap, traversable, foldable etc., it's easy enough to make haskell collection types that conform to neat interfaces
01:27:12 <osfameron> (even though they don't get the special syntax for lists)
01:27:12 <Phyx-> osfameron: like indexers in C# I assume?
01:28:14 <osfameron> Phyx-: I've just googled indexers - I think Perl's tie is slightly more general - it allows indexing, but also push/pop/delete/splice/etc.
01:29:48 <Phyx-> osfameron: hmm ok, I need to get around to learning Perl and Python one of these days.. Seems like the popular thing to do
01:31:06 <osfameron> heh, in the perl community, it's learning haskell that's trendy ;-)
01:31:31 <Phyx-> hehehe
01:32:00 <Phyx-> uhg.. being sick sucks...
01:32:04 * Phyx- crawls back into bed
01:32:43 <mm_freak> has anyone used hdaemonize?  it doesn't seem to work on my system
01:32:56 <Phyx-> but before I do.. I have a weird issue
01:33:05 <shachaf> mm_freak: What sort of system do you have?
01:33:13 <mm_freak> shachaf: linux x86_64
01:33:28 <mm_freak> glibc-based (arch linux)
01:33:31 <shachaf> In what sense does it not seem to work?
01:33:40 <develhevel> is it not possible in the FFI to make a declaration like: foo ::  ... -> IO Ptr CInt
01:34:11 <Phyx-> I have a .hsc file that cabal preprocesses and puts into my library, if i jump into ghci and load it it works, yet GHC someone doesn't find all the instances in the module. If i preprocess the file myself, then ghc finds (and uses the local one instead of the package one)
01:34:22 <mm_freak> shachaf: i get the "starting" syslog message and then nothing happens
01:34:30 <mm_freak> my 'program' function is not called at all
01:34:41 <mm_freak> do i have to start those daemons as root?
01:35:23 <Phyx-> actually, hsc should be getting an extra -I, could hsc2hs be failing and cabal just generating an empty file?
01:35:35 <shachaf> mm_freak: How are you using it?
01:36:26 <Phyx-> Anyone know how you pass extra options to hsc2hs in a .cabal file?
01:37:13 <mm_freak> shachaf: almost like in the example:  main = serviced simpleDaemon { ... }
01:38:04 <mm_freak> my 'program' writes (or should write) an Emergency message to the syslog
01:38:08 <mm_freak> this message never shows up
01:38:50 <shachaf> strace it?
01:39:10 * shachaf doesn't know much about how syslog works, but presumably some sort of permissions are needed?
01:39:11 <flux> mm_freak, but it works without 'serviced'?
01:39:57 <mm_freak> it doesn't work as root either
01:40:11 <mm_freak> flux: doesn't make sense without serviced
01:40:15 <yitz> mm_freak: can you have the program do something else visible when it starts, like create a file?
01:40:22 <flux> oh, I'm not familiar with the library :)
01:41:04 <yitz> mm_freak: sounds like it's probably not starting at all, but that would be a way to confirm that
01:41:04 <shachaf> mm_freak: It does look like it drops privileges, so maybe it's supposed to be run as root.
01:41:29 <shachaf> Yes -- are you sure it's being run?
01:43:43 <DukeDave> Boo, I think my cabal is broken:
01:43:43 <DukeDave> $ cabal update
01:43:43 <DukeDave> Downloading the latest package list from hackage.haskell.org
01:43:43 <DukeDave> cabal: does not exist
01:43:50 <DukeDave> Is there a known issue?
01:44:06 <shachaf> Can you get to hackage.haskell.org?
01:44:07 <yitz> DukeDave: try it with -v
01:44:35 <shachaf> DukeDave: Proxy issue, maybe?
01:45:04 <identity_> cabal sure is making some pretty bold claims by claiming that hackage.haskell.org simply doesn't exist because the host computer can't reach it..
01:45:07 <DukeDave> shachaf: I was trying to get it to work with my proxy last night, now I'm on a direct connection, I'm wondering if I upset it some how :|
01:45:20 <DukeDave> yitz: Smart
01:45:30 <DukeDave> Oh, interesting
01:45:38 <DukeDave> I just ran it as root (sudo) and it worked
01:46:08 <frerich> identity_: That's quite philosophical (existence vs. being able to observe), maybe cabal is on to something.
01:46:11 <DukeDave> I wonder if there's an issue where if run as root after a fresh config, then a user can no longer run it?
01:46:18 <yitz> DukeDave: you must have had the wrong permissions either on the directory or the existing index file
01:46:45 <yitz> DukeDave: fix them and then try again without sudo
01:47:10 <DukeDave> yitz: You win!       -rw-r--r-- 1 root root 41164800 2011-06-17 10:11 00-index.tar
01:47:10 <identity_> frerich: Perhaps
01:47:30 <mm_freak> yitz: yes, my 'program' function is never evaluated
01:47:41 <mm_freak> shachaf: running as root didn't fix it
01:47:56 <yitz> mm_freak: i guess that would explain why it's having some trouble with syslog
01:47:57 <shachaf> Did strace -f yield any insights?
01:48:25 <DukeDave> Damn, I've chown'd the index files but still nothing :|
01:48:26 <shachaf> strace *always* yields insights.
01:48:41 <DukeDave> And -v doesn't offer any output
01:49:09 <identity_> strace fixed my marriage. If it can't fix your problem you're doing it wrong, bro
01:49:55 <yitz> DukeDave: does .cabal itself exist and have the right ownership/perms? or is your cabal config pointing somewhere else (possibly non-existent) as the repo-cache-dir?
01:50:34 <DukeDave> yitz: Everything under ~/.cabal is mine, I presume when I run it with a sudo it still looks there?
01:50:42 <mm_freak> shachaf: that's quite a bunch of information
01:50:46 <mm_freak> i have no idea how to parse it
01:50:50 <yitz> DukeDave: oop sorry remote-repo-cache, it's called
01:50:59 <shachaf> strace gives you *all* the information.
01:51:08 <DukeDave> yitz: Is there a global cabal conf somewhere?
01:51:11 <yitz> DukeDave: yes. look inside .cabal/config
01:51:34 <yitz> DukeDave: no it just uses .cabal/config
01:51:34 <mm_freak> shachaf: also i should note that the process is actually running
01:51:47 <shachaf> Somewhere in those logs is a proof of Goldbach's conjecture. *And* a counterexample.
01:51:48 <mm_freak> but it doesn't seem to do anything
01:51:57 <mm_freak> it also doesn't respond to "stop"
01:52:08 <mm_freak> hehe
01:52:15 <yitz> mm_freak: the thing runs ok without hdaemonize?
01:52:24 <DukeDave> yitz: Hmm, well that's mine, and looks correct: remote-repo-cache: /home/dave/.cabal/packages
01:52:38 <mm_freak> yitz: "the thing" is just a little test program, which writes a syslog entry and a file
01:52:43 <mm_freak> neither happens
01:52:48 <DukeDave> drwxr-xr-x  3 dave dave 4096 2011-06-16 22:21 packages/
01:54:41 <yitz> DukeDave: did you try what shachaf said:  shachaf> Can you get to hackage.haskell.org?
01:55:24 <yitz> mm_freak: neither happens even when you run the program directly, without hdaemonize?
01:57:11 <yitz> DukeDave: ls -l .cabal/packages/hackage.haskell.org/00*
01:58:00 <DukeDave> yitz: Yep, I can ping hackage, and when I $ sudo cabal update it works (well tells me there's a newer version)
01:58:14 <shachaf> Sounds like a permissions issue, then.
01:58:14 <yitz> DukeDave: you know what - even if you can get to the server, perhaps there were a few seconds where you couldn't, and it would have worked the second time even without sudo.
01:58:28 <shachaf> You could always sudo rm -rf ~/.cabal if you don't care about anything in there. :-)
01:58:35 <shachaf> Or do a chown/chmod -R.
01:58:37 <yitz> shachaf: yeah it must be one of those two
01:58:42 <DukeDave> -rw-r--r-- 1 dave dave 41164800 2011-06-17 10:20 00-index.tar
01:58:42 <DukeDave> -rw-r--r-- 1 dave dave  2841006 2011-06-17 10:20 00-index.tar.gz
01:58:58 <DukeDave> Yeah I went for a chown, but perhaps I'll just rm it, I guess cabal can recreate?
01:59:03 <yitz> DukeDave: dunno everything looks ok. try it again without sudo.
01:59:40 <DukeDave> I've cycled a few times now, and 100% update works with sudo, but "cabal: does not exist" without
01:59:54 <yitz> DukeDave: yeah basically you'll only use any customization you did in .cabal/config (which you can save elsewhere), and you'll have to rebuild all your packages from cabal install.
02:00:06 <DukeDave> Well, I get "Downloading the latest package list from hackage.haskell.org" first, and then "does not exist"
02:00:15 <yitz> DukeDave: the problem could be you'll get different verions for some things.
02:00:29 <DukeDave> yitz: Meh, I hardly ever use cabal anyway
02:00:35 <yitz> DukeDave: which could be annoying if you installed via Haskell Platform
02:00:36 <DukeDave> I tend to get everything from apt
02:00:53 <develhevel> is it not possible in the FFI to make a declaration like: foo ::  ... -> IO Ptr CInt, i alawys get "`IO' is applied to too many type arguments" but i need IO because it could couse side effects
02:00:56 <yitz> DukeDave: ah. so you could just reinstall all those apt packages
02:01:01 <DukeDave> But now I need wxHaskell, which hasn't made it through Debian Haskell yet
02:01:18 <shachaf> develhevel: type a :$ b = a b; ... -> IO :$ Ptr CInt
02:01:25 <shachaf> That's bad advice, by the way, don't take it.
02:01:27 <yitz> DukeDave: what version of cabal are you using?
02:01:29 <shachaf> IO (Ptr CInt)
02:01:40 <shachaf> tree -pu ~/.cabal | less # :-)
02:02:40 <DukeDave> yitz: 0.8.0-1 according to apt
02:02:55 <DukeDave> Is that the same versioning system as we use?
02:03:03 <yitz> DukeDave: not all that old
02:03:10 <yitz> DukeDave: yes
02:03:16 <yitz> except the -1
02:04:41 <yitz> DukeDave: hmm, you probably ran apt as root, i wonder if some things are weird because of that. although i'm pretty sure that nowadays the debian haskell team is pretty careful about those kinds of things.
02:05:02 <DukeDave> yitz: Aha, I think I know what it is, one moment
02:05:13 <mm_freak> yitz: then it works, of course
02:05:25 <yitz> mm_freak: just checking :)
02:05:28 <DukeDave> I just apt-get remove'd cabal-install, rm -r'd .cabal, and apt-get install'd cabal-install
02:05:55 <yitz> DukeDave: then check all the perms again
02:05:58 <DukeDave> Config file path source is default config file.
02:05:58 <DukeDave> Config file /home/dave/.cabal/config not found.
02:05:58 <DukeDave> Writing default configuration to /home/dave/.cabal/config
02:05:58 <DukeDave> Downloading the latest package list from hackage.haskell.org
02:05:58 <DukeDave> cabal: does not exist
02:06:40 <DukeDave> But, I just did "set | grep proxy", and it looks like Ubuntu hasn't unset some env vars, like its proxy gui promised it had >:(
02:07:09 <yitz> DukeDave: what are the exact remote-repo lines in .cabal/config?
02:07:35 <yitz> DukeDave: also check for weird spurious space or control characters there too. maybe use hexdump -C
02:08:06 <yitz> DukeDave: you're behind a proxy?
02:08:30 <DukeDave> yitz: Yep, it was an erroneous http_proxy env var
02:08:41 <DukeDave> yitz: I was behind a proxy, but now I'm not
02:09:19 <DukeDave> Ubuntu has a nice "proxy manager" which is suppose to unset the "*_proxy" environment variables, but it didn't.
02:09:40 <Botje> well, it can't.
02:09:54 <Botje> unless it can somehow coerce your session process to unset that variable
02:10:11 <flux> simply have a custom getenv implementation in your libc and you're set ;)
02:10:22 <Botje> and then tell all the processes inbetween to also fix their http_proxy var :P
02:12:03 <DukeDave> Well, I started the terminal after I used gnome-network-properties to set myself to "Direct internet connection", and then did "Apply system-wide", I assumed that would unset the vars :|
02:12:09 <DukeDave> But this is probably one for #ubuntu ;)
02:14:02 <yitz> DukeDave: haha. OK. So without those pesky env vars, now it works?
02:16:45 <DukeDave> yitz: Yep, and for full points, I tried to use Ubuntu's own bug reporting software, but that appears to be failing with a no route to host :D
02:16:54 <yitz> hahaha
02:17:08 <yitz> DukeDave: ok, glad you're back in business
02:17:38 <DukeDave> yitz: Yes, thank you for all your help
02:17:47 <yitz> DukeDave: np
02:17:53 <DukeDave> Now I'm just a'hoping that wxHaskell builds!
02:17:57 <DukeDave> Can we still:
02:18:00 <DukeDave> yitz++
02:18:11 <yitz> @karma yitz
02:18:11 <lambdabot> You have a karma of 2
02:18:59 <DukeDave> @karma DukeDave
02:18:59 <lambdabot> You have a karma of 0
02:19:03 <yitz> DukeDave: and that's even after the web-devel community interpreted by reddit post and ghc bug as a troll :)
02:19:13 <yitz> DukeDave++
02:19:19 <DukeDave> @karma DukeDave
02:19:19 <lambdabot> You have a karma of 1
02:19:34 <DukeDave> Oh, cute, and I'm glad to see lambdabot is back up :)
02:19:48 <yitz> @vixen glad to see that you're back up
02:19:49 <lambdabot> yup
02:20:49 <yitz> gotta go. bye all.
02:55:18 * hackagebot HarmTrace 0.2 - HarmTrace: Harmony Analysis and Retrieval of Music  http://hackage.haskell.org/package/HarmTrace-0.2 (JosePedroMagalhaes)
03:08:12 <frerich> https://days2011.scala-lang.org/sites/days2011/files/ws3-1-Hundt.pdf <-- I wonder how Haskell would have compared to the other languages
03:39:03 <dankna> > compare (1, 2) (2, 1)
03:39:04 <lambdabot>   LT
03:39:20 <dankna> > compare (1, 2) (1, 0)
03:39:21 <lambdabot>   GT
03:54:54 <ClaudiusMaximus> > readSigned readFloat "-1.23e4"
03:54:55 <lambdabot>   [(-12300.0,"")]
03:57:39 * ClaudiusMaximus not having fun writing Read instance
03:58:47 <ClaudiusMaximus> > lex "-1.23e4"
03:58:48 <lambdabot>   [("-","1.23e4")]
03:59:20 <erus`> > lex "print \"Hello World!\" ++ show 1337"
03:59:21 <lambdabot>   [("print"," \"Hello World!\" ++ show 1337")]
04:00:33 <ClaudiusMaximus> @src readSigned
04:00:33 <lambdabot> Source not found. stty: unknown mode: doofus
04:04:11 <ClaudiusMaximus> i think what's happening in my attempt at Read instance is that fromString "-" -> 0.0, when i should fail instead...
04:17:13 <DukeDave> With the record syntax, is there an easy way to update just one field of a data type?
04:17:26 <dankna> > [(0, 0,) .. (2, 2)]
04:17:30 <lambdabot>   mueval-core: Time limit exceeded
04:17:34 <dankna> huh.
04:17:36 <dankna> okay.
04:17:42 <DukeDave> I.e. Without having to manually deconstruct and reconstruct it?
04:17:59 <dankna> DukeDave: not for a reasonable value of "easy", no, though there are things called lenses
04:18:10 <dankna> the simplest way is
04:18:25 <dankna> existingRecordValue { fieldName = newValue }
04:18:50 <dankna> it occurred to me after I answered that you probably weren't aware of that, so I guess I should mention it :)
04:18:53 <dankna> as it's probably what you want
04:19:02 <dankna> but I wouldn't really call it easy
04:22:36 <siracusa> :t [(0, 0,) .. (2, 2)]
04:22:37 <lambdabot> Illegal tuple section: use -XTupleSections
04:22:47 <liyang> DukeDave: update f rec@Cons {field} = rec {field = f field} , with {-# LANGUAGE FieldNamePuns #-}
04:23:16 <Axman6> > [(0, 0) .. (2, 2)]
04:23:17 <lambdabot>   No instance for (GHC.Enum.Enum (t, t1))
04:23:17 <lambdabot>    arising from a use of `e_10022' ...
04:23:21 <Axman6> :(
04:23:41 <ClaudiusMaximus> > range ((0,0),(2,2))
04:23:42 <lambdabot>   [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
04:24:34 <liyang> Well you can map (Integer, Integer) into Integer and back again...
04:27:43 <dankna> yeah, anyway, I did it another way
04:28:54 <ClaudiusMaximus> @hoogle (i -> e -> f) -> Array i e -> Array i f
04:28:54 <lambdabot> Data.Array.IArray accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
04:29:12 <Twey> How can you map (Integer, Integer) into Integer?
04:29:16 <Twey> Oh, stupid question, never mind
04:29:47 <ClaudiusMaximus> probably several ways, interleaving bits would be one way
04:30:10 <Twey> Yeah, ((* 2) *** (+ 1) . (* 2))
04:32:43 <erus`> is 'list' written in haskell or built in to haskell?
04:34:43 <ClaudiusMaximus> erus`: you could write data List a = Nil | Cons a (List a) in Haskell, but the sugar [1,2,3] is built in (afaik)
04:38:52 <augur> Twey: did you at one point hang out in #javascript?
04:40:25 <Twey> augur: For a long time, yes
04:40:30 <Twey> Until it got too much :þ
04:41:56 <ezyang> Wow, I'm very afraid of running 'map' on data structures now, for fear of blowing up allocation.
04:43:26 <Axman6> ezyang: it'll be fine, just make sure you NEVER use the results!
04:44:32 <Maxikq> hello
04:44:39 <ezyang> :-)
04:45:07 <Maxikq> i want to designate type of expression: (.)(.)(.) but i don't know how
04:45:14 <Maxikq> i've done something like that: (.) (.) (.) x = (.) ( (.) x ) g y = ( (.) f g x ) (h y) = ( f (g x) ) (h y)
04:45:40 <ezyang> :t (.)(.)(.)
04:45:41 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
04:45:46 <augur> Twey: i thought i recognized you for a while now
04:46:02 <Maxikq> i know... but i have to do that manually
04:46:20 <benmachine> (.)(.)(.) = (\f g x -> f (g x)) (.) (.)
04:46:38 <ezyang> @pl (.)(.)(.)
04:46:38 <lambdabot> (.) . (.)
04:46:44 <benmachine> = (\x -> (.) ((.) x))
04:46:47 <ezyang> @unpl (.)(.)(.)
04:46:48 <lambdabot> (\ c e f i -> c (e f i))
04:47:17 <benmachine> = (\x -> (\f g y -> f (g y)) ((.) x))
04:47:44 <benmachine> = (\x -> (\g y -> (.) x (g y)))
04:48:16 <benmachine> = (\x -> (\g y -> (\f h z -> f (h z)) x (g y)))
04:48:41 <benmachine> = (\x -> (\g y -> (\z -> x (g y z))))
04:48:56 <benmachine> = (\x g y z -> x (g y z))
04:50:39 <Maxikq> ok, thanks, i'll try to understand it :)
04:51:36 <benmachine> (I'm assuming once you've got down to the lambda you know what to do)
04:52:02 <Maxikq> yeap
04:55:27 <zygoloid> (.) = result; (.) (.) (.) = result . result = \g f x y ->  g (f x y)
04:55:33 <erus`> what is expression re-writing?
04:55:42 <test123978456> hello
04:55:51 <benmachine> erus`: where you get an expression, and um...
04:55:54 <Twey> Heh
04:55:55 <benmachine> erus`: in what context?
04:56:03 <Twey> test123978456: Hi
04:56:04 <erus`> in pure-lang
04:56:35 <zygoloid> erus`: it's probably the same thing as evaluation by graph rewriting
04:56:56 <zygoloid> depends who said it and what they meant ;)
04:57:15 <test123978456> is it any tricky way to "update" a list of list? [[Int]]. I got a function get::Int->Int->[[Int]]->Int which returns me the value of the list on x-y position (x-element of y-column).
04:57:43 <test123978456> and I got list of tuples (Int, Int, Int) like (x,y,m) i wanna update list on x, y set value m
04:58:09 <Twey> test123978456: This question is wrong in many ways
04:58:12 <erus`> I think i mean 'term rewriting'
04:58:24 <lebedev> Hello! How can I repeat the symbol '@' fifty times? One of the solution is: take 50 $ repeat '@'. Who knows more shorter solution?
04:58:36 <Twey> test123978456: If you want a rectangular array, use one of the Array types, like IArray, MArray, or STArray
04:58:55 <companion_cube> > replicate 50 '@{
04:58:56 <lambdabot>   <no location info>:
04:58:56 <test123978456> for example function [[1,1], [1,1]] [(1,1,5) (2,2,7)] should return [[5,1],[1,7]]
04:58:56 <lambdabot>      lexical error in string/character literal at chara...
04:58:58 <companion_cube> > replicate 50 '@'
04:58:59 <lambdabot>   "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
04:59:00 <Twey> MArray and STArray also allow in-place updates, though you would probably be okay with just returning a new IArray
04:59:18 <test123978456> do You know what i mean?
04:59:24 <benmachine> lebedev: that solution is already quite short :P
05:00:13 <zygoloid> @src replicate
05:00:13 <lambdabot> replicate n x = take n (repeat x)
05:00:24 <lebedev> Thanks! replicate 50 '@' is working!:)
05:00:45 <test123978456> Twey, ok i'll read about arrays types :)
05:00:48 <erus`> @src cycle
05:00:48 <lambdabot> cycle [] = undefined
05:00:49 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
05:00:51 <test123978456> but what about my question?
05:00:59 <test123978456> changing elements in the list?
05:01:09 <erus`> thats clever
05:01:19 <Twey> test123978456: It's possible, but it will be awkward and slow, because lists are not the right type to be using here
05:01:20 <test123978456> i know that i should generate another list (some elements must be copied, some - changed)
05:01:58 <test123978456> Twey, could You gimmie any hint how to do that on the lists?
05:02:03 <zygoloid> @type fix . join (++)
05:02:04 <lambdabot> forall a. (Monoid a) => (a -> a) -> a
05:02:29 <Twey> test123978456: Direct recursion is probably the simplest way
05:02:37 <benmachine> test123978456: if you insist on using a list (as Twey said, arrays are better, a Data.Map could also work) I'd recommend using splitAt
05:02:43 <Twey> But really, the code is going to be horrible
05:03:01 <test123978456> @src splitAt
05:03:01 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
05:03:07 <benmachine> > case splitAt 3 [1,2,3,4,5] of (xs, y:ys) -> xs ++ '8':ys
05:03:08 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
05:03:08 <lambdabot>    arising from the literal `1...
05:03:11 <benmachine> er wups
05:03:19 <benmachine> > case splitAt 3 "12345" of (xs, y:ys) -> xs ++ '8':ys
05:03:21 <lambdabot>   "12385"
05:04:09 <test123978456> benmachine, eee, it's not what i mean (and can't see how can it be useful for me)
05:04:26 <benmachine> test123978456: it's how to replace one element of the list with another
05:04:42 <benmachine> in this case, the fourth element of the list is '4' and I'm replacing it with '8'
05:04:52 <poetix_> Anyone here know which pair of adjoint functors generate the Exception monad?
05:05:09 <benmachine> in your case, the element is a list, but that's fine - you just do it twice
05:06:25 <test123978456> ok i see it now ;) thanks a lot ;)
05:07:45 <Younder> benmachine: _ instead of y perhaps?
05:09:29 <ClaudiusMaximus> > let l = [[1,1],[1,1]] ; a = listArray ((1,1),(2,2)) (concat l) ; a' = accum (\_ e -> e) a [((1,1),5), ((2,2),7)] ; l' = [ [ a' ! (i, j) | j <- [1,2] ] | i <- [1,2] ] in l'
05:09:30 <lambdabot>   [[5,1],[1,7]]
05:11:14 <test123978456> where are listArray?
05:11:23 <erus`> groupBy even [1..10]
05:11:26 <erus`> > groupBy even [1..10]
05:11:27 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
05:11:27 <lambdabot>         against inferred ...
05:11:56 <test123978456> @src listArray
05:11:56 <lambdabot> Source not found. I feel much better now.
05:12:05 <erus`> > groupBy (\x -> x `mod` 2 == 0) [1..10]
05:12:06 <ClaudiusMaximus> @hoogle listArray
05:12:06 <lambdabot> Data.Array.IArray listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
05:12:06 <lambdabot> Data.Array.MArray newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
05:12:06 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
05:12:06 <lambdabot>         against inferred ...
05:12:21 <erus`> @hoogle groupBy
05:12:22 <lambdabot> Data.ByteString groupBy :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
05:12:22 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
05:12:22 <lambdabot> Data.ByteString.Char8 groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
05:13:40 <ClaudiusMaximus> :t (`on` even)
05:13:41 <lambdabot> forall c a. (Integral a) => (Bool -> Bool -> c) -> a -> a -> c
05:15:20 <ClaudiusMaximus> > groupBy ((&&) `on` even) . map floor $ [1, 1.618 ..]
05:15:22 <lambdabot>   [[1],[1],[2,2],[3],[4,4],[5],[5],[6],[7],[7],[8],[9],[9],[10,10],[11],[12,1...
05:20:43 <sepp2k> Wouldn't you rather want (==) `on` even ?
05:20:52 <ClaudiusMaximus> depends what you want!
05:21:35 <ClaudiusMaximus> but yes
05:26:11 <Spockz> dblhelix: do you by any chance finish your one-pass algorithm for coming up with principal types from you phd thesis?
05:27:20 <dblhelix> Spockz:  there's a draft. :)
05:28:00 <dblhelix> Spockz: and a prototype even. :)
05:28:03 <Spockz> dblhelix: can we look at it? We're trying to do the strictness analysis polyvariance style for APA now
05:28:11 <Spockz> dblhelix: that sounds good :D
05:28:39 <dblhelix> Spockz: I'll have to check with Jur whether you can have the prototype then ;-)
05:29:20 <Spockz> dblhelix: ah yes, me and my big mouth
05:30:39 <Spockz> dblhelix: we would like it very much to see the draft anyway
05:30:57 <dblhelix> Spockz: do you have to actually drive a transformation with your analysis? MTDs won't give you any improvements in precision...
05:31:32 <Spockz> dblhelix: no we do not have to do any transformation
05:31:39 <dblhelix> Spockz: just send me an e-mail to remind me (cc jur) and I will dig it up later today
05:32:04 <Spockz> dblhelix: at vector fabrics or do you still have access to the CS mail?
05:32:31 <dblhelix> Spockz: what's then the added value of an algorithm that computes MTDs? (because that's the one-pass algorithm that you mean, right?)
05:32:53 <dblhelix> Spockz: I think my cs.uu.nl-mail still gets forwarded
05:33:39 <dblhelix> Spockz: without MTDs, a one-pass algorithm is straigtforward: essentially it's what is described in NNH (Ch. 5)
05:34:04 <Spockz> dblhelix: ah, the assignment is to do what is written in the Making stricterness more relevant and improve upon it to be polyvariance
05:34:09 <dblhelix> /ss/straigtforward/straightforward/
05:34:50 <Spockz> + paper somewhere
05:36:21 <dblhelix> Spockz: but the one-pass algorithm you are referring to is from the paper on MTDs, isn't it?
05:37:22 <Spockz> dblhelix: yes, but I thought it would come in handy in deriving the type and analysis for a function, as it is better than an adopted version of DM
05:38:58 <dblhelix> Spockz: I don't think I agree on that... deriving MTDs when you do not really have to (because, for instance, you are only interested in printing the annotated type of a term) only complicates things imo
05:39:29 <dblhelix> Spockz: anyway, I could send you the algorithm anyway and you can judge for yourself then
05:40:17 <Spockz> dblhelix: Do you still want the email?
05:40:38 <dblhelix> Spockz: if you still want the algorithm ;-)
05:40:53 <Spockz> dblhelix: ghehe okay, one sec
05:42:50 <identity_> So.. ghci with ghc version 6.12.3 crashes when I press æ :(
05:43:03 <Twey> identity_: o.@
05:43:17 <identity_> g>
05:43:18 <identity_> <stdin>: hWaitForInput: invalid argument (Invalid or incomplete multibyte or wide character)
05:43:37 <identity_> It's uncool
05:43:40 <Twey> What encoding are you using?
05:43:49 <identity_> utf-8 afaik
05:43:50 <Twey> Sounds like your encoding doesn't match GHCi's
05:44:05 <Twey> I think GHCi always uses UTF-8… what does ‘echo $LANG’ say?
05:44:08 <identity_> using putty to connecto to a shell
05:44:09 <mauke> what do you get when you enter æ in xxd?
05:44:10 <identity_> sec
05:44:27 <Twey> Ah… there are many points of failure in this setup
05:44:50 <identity_> $LANG is .. nothing.
05:44:50 <identity_> heh.
05:45:13 <identity_> Twey: yeah. I know. That's why I'm not really making a big deal out of it. This is just temporary
05:45:19 <Twey> No wonder, then :þ
05:45:23 <mauke> hello?
05:45:29 <Twey> mauke asked you a question
05:45:37 <identity_> oh
05:45:39 <identity_> sorry, didn't see that
05:46:29 <identity_> c2b4 c3a6
05:47:31 <mauke> where did the ´ come from?
05:47:55 <identity_> seems the term was messing up, sec
05:48:13 <identity_> c3a6 = æ
06:06:06 <identity_> So I have a function that looks something like this: generateWord :: Map a b -> String -> WriterT [String] IO String. The map it takes is always the same map, but I need a function that basically does this for me: generateWord m "initial seed" >>= generateWord m >>= generateWord m >>= ... and for some reason I can't grok what I need to be using(if it already exists)
06:06:18 <identity_> I tried to fit it into foldM but I've been unsuccessful so far. Any hints?
06:06:34 <HugoDaniel> (>>= . =<<)
06:08:55 <osfameron> haha #protolol "“the best thing about haskell  jokes is that they are just monoids in the category of  endofunnies”
06:09:10 <identity_> har har
06:09:23 <mm_freak> identity_: replicateM
06:09:32 <mm_freak> but the type you gave makes no sense
06:09:34 <saml> how do I do practical programming ?
06:09:46 <mm_freak> you couldn't possibly use the map, which you get passed, in any useful way
06:10:16 <mm_freak> saml: spend less time thinking about category theory and write real programs ;)
06:10:21 <identity_> mm_freak: why?
06:11:00 <mm_freak> identity_: starting with the fact that 'a' is even too general for most Map functions to work
06:11:07 <ClaudiusMaximus> :t \f -> iterate (f =<<) . return
06:11:08 <lambdabot> forall (m :: * -> *) b. (Monad m) => (b -> m b) -> b -> [m b]
06:11:27 <Nisstyre> saml: http://pragprog.com/the-pragmatic-programmer
06:11:56 <identity_> mm_freak: Well, I just simplified it thinking it wouldn't matter.. The map is Map String [(String, Integer)], mapping a word to words that follow it in text and their probabilities
06:12:04 <identity_> writing something to generate text based on markov chains
06:12:11 <identity_> or however you put it
06:13:04 <identity_> generateWord :: M.Map String [(String, Integer)] -> String WriterT [String] IO String takes the seed and randomly(more or less) selects a word that follows it and 'tell's it, then returns it
06:13:15 <mm_freak> identity_: you can simplify, but in that case i recommend writing A instead of a, so that one knows that you mean a specific type, which you don't want to explain further
06:13:27 <identity_> Ah
06:13:58 <mm_freak> so you want to apply a WriterT computation multiple times?
06:14:09 <mm_freak> to a certain, let's call it, seed?
06:14:11 <identity_> Yes. Passing the result of computation into the next one
06:14:25 <Nisstyre> like a "chain" :P
06:14:28 <Nisstyre> right?
06:14:38 <identity_> I want to emulate this: execWriterT (generateWord m "seed" >>= generateWord m >>= generateWord m >>= ..)
06:14:40 <mm_freak> see ClaudiusMaximus's example using 'iterate'
06:14:42 <identity_> aye
06:14:46 <mm_freak> or use foldM
06:14:53 <identity_> hmm
06:16:28 <mm_freak> if your solution feels complicated, it probably is, so you may even want to use explicit recursion here
06:16:37 <identity_> Yeah
06:16:50 <identity_> Maybe I am trying too hard to be generic
06:17:40 <mm_freak> explicit recursion is not less generic, but may be easier to write and later read, depending on how you fold
06:18:39 <mm_freak> i think, the 'iterate'-based solution is quite good
06:19:59 <DukeDave> dankna: liyang: Thanks for your help with the records syntax guys, forgot to mention it before I went to lunch :)
06:20:04 <DukeDave> dankna++
06:20:11 <DukeDave> liyang++
06:22:52 <exeter> I have a tree like structure (or better, a folderlike structure, where a Folder can contains other Folders or Files). I would like to "navigate" it (i.e. get the "parent" folder, etc). What's the simplest way of doing it? I'm reading "zippers" on LYAHFGG, but it seems they're only for Trees!
06:23:31 <mauke> what you're describing is a tree
06:24:17 <exeter> mauke: correct me if I am wrong. A tree can only have two "leaves"
06:24:24 <mauke> wrong
06:24:42 <mauke> are you thinking of a pair?
06:24:50 <mauke> (a, b)?
06:24:59 <dankna> DukeDave: np :)
06:25:02 <exeter> ...no
06:25:25 <exeter> I meant "a single node of a tree can only have two subnodes". Correct, mauke?
06:25:29 <mauke> no
06:25:35 <exeter> meh
06:26:10 <identity_> exeter: You could have a recursive data structure that contains a list of itself
06:26:27 <mauke> also known as a tree
06:26:33 <augur> chaitin-kolmogorov complexity. :T
06:27:03 <scree> (rooted tree)
06:28:38 <identity_> exeter: But to answer your question, a zipper sounds like what you need to traverse back and forth
06:28:52 <exeter> thanks identity
06:30:56 <exeter> is zipper a std library?
06:31:06 <exeter> *module
06:32:23 <k0ral> monochrom, and all gtk2hs users: should I use postGUI* for quitAdd function when in an external thread ?
06:33:21 <dcoutts> k0ral: when using the threaded rts you must use postGUI* for anything that's not in a gui callback (an external thread)
06:34:59 <k0ral> fair enough
06:35:13 <k0ral> it's not the threaded rts in my case
06:35:21 <k0ral> but anyway
06:36:42 <dcoutts> k0ral: if you're using the single threaded rts then you don't need to use postGUI* at all
06:38:49 <k0ral> actually I don't really know what is rts threading system, I only read it was about using the -RTS flag and I'm not using it, I'm using forkIO
06:38:57 <k0ral> and -threaded flag
06:53:25 * hackagebot void 0.5.3 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.3 (EdwardKmett)
06:53:41 <test123978456> hi again
06:54:35 <test123978456> please tell me more about "where" and "let". If i have something like where x = very_time_consuming_function and I'm using x a lot of times
06:54:45 <test123978456> how much my function is called?
06:54:47 <test123978456> only one?
06:55:08 <identity_> test123978456: Yes
06:55:25 <identity_> well, it depends on the situation and so on
06:55:28 <identity_> but for the most part, yes
06:55:38 <test123978456> and the result of that function is substitute?
06:56:31 <test123978456> ok, thanks a lot :)
07:06:47 <dblhelix> Spockz: I've sent you a description of the algorithm by e-mail
07:19:01 <develhevel> when i'm in do notation and i have a (Int, (Int, Int)) and want to make a (Int, Int, Int) of it without writing a whole function but rather write it in labmda notaion, how can i do it? i know (\(x,(y,z)) -> (x,y,z)) but dont know where to put it
07:19:36 <develhevel> i need somethink like: put this lambda notation on this value
07:19:42 <Eelis> develhevel: you may be looking for fmap
07:20:19 <develhevel> fmap is for lists but i dont have a list
07:20:26 <Eelis> fmap is not just for lists, it's for all functors
07:20:38 <Eelis> :t fmap
07:20:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:20:52 <develhevel> fmap (\x -> x+1) 1 dont work but fmap (\x -> x+1) [1] work
07:21:13 <Eelis> that's because 1 does not have a type that's an application of a functor
07:21:53 <parcs> develhevel: do { x <- f; return $ (\(x,(y,z)) -> (x,y,z)) x }
07:22:10 <parcs> or alternatively fmap (\(x,(y,z)) -> (x, y, z) f
07:22:44 <monochrom> (x,(y,z)) <- m0; f (x,y,z)
07:22:51 <quicksilver> if it is actually coming out of an action f, you might as well write do { (x,(y,z)) <- f; .... do stuff with x y and z }
07:23:00 <Yrogirg> Hello! Has anybody tried calling sympy functions from haskell?
07:24:05 <develhevel> okay
07:35:01 <xiphiasx> how is a normal haskell program supposed to be structured?
07:35:29 <quicksilver> sensibly.
07:35:39 <xiphiasx> lol :p
07:35:40 <xiphiasx> what i meant was
07:35:40 <osfameron> start with:  IDENTIFICATION DIVISION
07:35:45 <xiphiasx> OH PLEASE NOT THAT
07:35:54 <c_wraith> depends on the size of the program.
07:35:55 <osfameron> then TYPE DIVISION, and finally MONAD DIVISION
07:36:01 <xiphiasx> for those who care
07:36:06 <xiphiasx> it's an emulator i'm writing
07:36:37 <xiphiasx> so i wanted to follow all of haskell's standards on packaging and what not
07:36:38 <c_wraith> But the most common approach, for larger applications, is to create your own embedded domain-specific language
07:36:57 <c_wraith> Such that your main logic is expressed in terms of the domain.
07:37:50 <xiphiasx> i see
07:41:34 <xiphiasx> found it: http://www.haskell.org/haskellwiki/Structure_of_a_Haskell_project
07:43:02 <osfameron> out of interest, why does that tool go as far as to recommend a version-control tool?
07:43:16 <xiphiasx> dunno
07:43:23 <osfameron> does darcs have features that play well with other parts of haskell toolchain?
07:43:37 <xiphiasx> i'm using git no matter what
07:43:38 <xiphiasx> :p
07:44:24 <xiphiasx> also
07:44:30 <xiphiasx> i've noticed that writing stuff in haskell is very small
07:44:35 <xiphiasx> xmonad would be huge in C probably
07:48:36 <osfameron> you could compare its code size against that of awesome
07:49:28 <Saizan> i guess darcs was perceived as the version-control tool that the whole community was familiar with
07:49:36 <xiphiasx> ah
07:49:47 <xiphiasx> well, like i said, i'm doing an emulator for a video game console
07:49:51 <xiphiasx> strong typing is well, required
07:50:15 <erus`> are there any emulators in haskell? lots of vm's but i havnt seen a console emulator
07:50:31 <xiphiasx> unsure
07:50:34 <xiphiasx> but i'm almost positive it can be done
07:50:39 <xiphiasx> there's no need for dynamics
07:50:43 <xiphiasx> there's no need to torture myself with C/C++
07:51:02 * JuanDaugherty used to feel that way about c++
07:51:25 <xiphiasx> besides, haskell has a lot of cool shit i can take advantage of
07:51:37 <xiphiasx> erus`: it's the playstation 1 btw
07:51:54 <erus`> have you written a console emulator before?
07:52:08 <xiphiasx> i was actually in the middle of my one in C++
07:52:15 <xiphiasx> and then it struck me: why not do this in haskell
07:52:18 <ezyang> What would I call a variant of map, with signature (a -> Maybe b) -> f a -> Maybe (f b)?
07:52:21 <xiphiasx> cross-platform, less hell
07:52:31 <ezyang> (essentially, return Nothing if no changes.)
07:52:38 <xiphiasx> documentation system
07:52:42 <xiphiasx> its own build-system
07:52:43 <xiphiasx> etc
07:53:05 <ClaudiusMaximus> :t mapMaybe
07:53:06 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
07:53:10 <Saizan> ?type Data.Traversable.traverse -- ezyang
07:53:11 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
07:53:13 <ezyang> Not quite.
07:53:14 <parcs> xiphiasx: which console?
07:53:18 <xiphiasx> PS1
07:53:24 <ezyang> Oh, traverse looks like what I want.
07:53:30 <ezyang> Let's make sure it has the right semantics...
07:53:39 <xiphiasx> parcs: as far as I know, there is not a single console emulator written in haskell
07:53:49 <xiphiasx> but it makes sense to use haskell if you're emulating hardware
07:54:16 <ezyang> No, it has the wrong semantics, at least, under the ordinary Applicative instance for Monad.
07:54:18 <ezyang> *Maybe
07:54:28 <kmc> it makes sense to use Haskell if you're writing a compiler
07:54:32 <kmc> and a fast emulator will be a compiler
07:54:39 <Saizan> ah, nothing if no changes
07:54:53 <ezyang> Right, but if there is some changes, then we should update the entire structure.
07:55:02 <xiphiasx> kmc: well
07:55:11 <xiphiasx> you mean dynamic translation of the emulated CPU
07:55:12 <xiphiasx> which is JIT
07:55:17 <xiphiasx> if that's what you mean by "compiler"
07:55:20 <kmc> yes
07:55:28 <kmc> a JIT compiler is a type of compiler
07:55:30 <xiphiasx> right now it's just an interpreter
07:55:36 <kmc> it's often a more sophisticated, more heavily optimizing compiler
07:55:37 <erus`> http://www.mutantlemon.com/omegagb/
07:55:46 <kmc> because it has more information and can make narrower assumptions
07:55:50 <xiphiasx> i know :p
07:58:13 <xiphiasx> oh
07:58:23 <xiphiasx> omegagb, gameboy emulator in haskell
07:58:44 <parcs> it's 5 years old
07:59:08 <ezyang> Bah, no suggestions? :-)
07:59:11 <parcs> actually 4, by the looks of the darcs repo
07:59:30 <ezyang> maybe I'll ask my blog about it.
07:59:32 <kmc> thats ok because the gameboy is more than 4 years old ;)
07:59:43 <xiphiasx> hah
08:02:52 <Saizan> ezyang: is 'a' actually the same as 'b' in your version of (a -> Maybe b) -> f a -> Maybe (f b) ?
08:03:03 <ezyang> Actually, it is!
08:03:39 <Saizan> it didn't look implementable otherwise :)
08:18:23 <ezyang> I need to do a fold on a list while preserving order. The list isn't too long. foldr, or foldl and a reverse?
08:18:30 <ezyang> *Should I use.
08:22:50 <copumpkin> @djinn (a -> c) -> (b -> c) -> (b -> a)
08:22:50 <lambdabot> -- f cannot be realized.
08:24:17 <quicksilver> ezyang: that's a peculiar question. foldl and foldr both process the elements from left to right.
08:24:30 <quicksilver> they differ in how they are bracketed, not the order used.
08:25:06 <ezyang> My intuition is that foldl sees the items of a list in "reverse"
08:25:23 <ezyang> erm, I'm pretty sure this is noncontroversial.
08:25:31 <ezyang> > foldl flip [] [1,2,3]
08:25:31 <lambdabot>   Occurs check: cannot construct the infinite type: b = b1 -> b
08:25:39 <ezyang> > foldl (:) [] [1,2,3]
08:25:40 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
08:26:00 <ezyang> > foldl (flip (:)) [] [1,2,3]
08:26:01 <lambdabot>   [3,2,1]
08:28:33 <quicksilver> ezyang: that doesn't proof that foldl sees them in reverse. That proves that "flip (:)" works backwards.
08:28:42 <quicksilver> flip is the reversing actor there, not foldl.
08:29:21 <ezyang> Right, but you can't efficiently do the same trick with a foldr.
08:29:36 <quicksilver> well, (:) has a non-symmetric type.
08:30:06 <quicksilver> (1+(2+(3+(4+5)))) and ((((1+2)+3)+4)+5) are seeing the list in the same order.
08:30:16 <quicksilver> well, I'm not sure about 'seeing'
08:30:25 <quicksilver> but the order is preserved in both cases.
08:30:29 <quicksilver> you probably want foldr, anyhow.
08:32:36 <monochrom> @quote monochrom evaluat
08:32:36 <lambdabot> monochrom says: some kind of lazy evaluation is already known to highschool kids. teachers tell you that in a*(b+c), "evaluate b+c first", right? well, I challenge you to take 0*(389238493+97283748)
08:32:36 <lambdabot> and find one single student who faithfully evaluate 389238493+97283748 first.
08:34:11 <Eelis> hm, is there some reason the gtk hackage package doesn't wrap gdk_window_create_similar_surface?
08:40:42 <DukeDave> Hey guys, I'd like to overwrite all the values in a Data.Map Int Int with pseudo random Ints, but not sure how :|
08:42:01 <monochrom> draw from a list of random numbers. available from "randomRs"
08:42:56 <c_wraith> sadly, I can't see an easy way to do it while maintaining the tree structure.
08:43:01 <doserj> you can use fromList and toList
08:43:09 <c_wraith> yeah, that's all I can see
08:43:19 <monochrom> why maintain the tree structure. create a new tree.
08:43:45 <monochrom> "overwrite all" = create new
08:44:25 <c_wraith> because as far as I know, fromList is O(n log n), where retaining the structure would be O(n)
08:44:46 <c_wraith> though I guess you could use toAscList and fromAscList
08:44:52 <c_wraith> which should get that log n factor back
08:44:57 <monochrom> yes
08:45:35 <monochrom> get the original keys with "keys"
08:46:30 <scree> can't you use Data.Traversable and mapM?
08:46:45 <scree> with your favourite random monad
08:47:13 <quicksilver> you should be able to, yes.
08:47:35 <ezyang> @pl flip fmap
08:47:36 <lambdabot> flip fmap
08:47:40 <ezyang> :t flip fmap
08:47:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
08:47:48 <ezyang> @hoogle f a -> (a -> b) -> f b
08:47:48 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
08:47:49 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
08:47:49 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
08:47:54 <ezyang> blah
08:49:35 <c_wraith> :t undefined :: Rand
08:49:36 <lambdabot>     Expecting an ordinary type, but found a type of kind * -> * -> *
08:49:36 <lambdabot>     In an expression type signature: Rand
08:49:36 <lambdabot>     In the expression: undefined :: Rand
08:50:06 <scree> > let tree = Data.Map.fromList [(1, 2), (3, 4)] in runRand (Data.Traversable.mapM (const $ getRandomR (1, 10)) tree) (mkStdGen 0)
08:50:07 <lambdabot>   Not in scope: `Data.Map.fromList'
08:50:22 <c_wraith> just use M
08:50:33 <scree> > let tree = M.fromList [(1, 2), (3, 4)] in runRand (Data.Traversable.mapM (const $ getRandomR (1, 10)) tree) (mkStdGen 0)
08:50:34 <lambdabot>   (fromList [(1,6),(3,6)],1601120196 1655838864)
08:50:40 <piotr1> quit
08:50:58 <scree> > let tree = M.fromList [(1, 2), (3, 4)] in runRand (Data.Traversable.mapM (const $ getRandomR (1, 10)) tree) (mkStdGen 4)
08:50:59 <lambdabot>   (fromList [(1,10),(3,1)],1563150291 1655838864)
08:51:23 <scree> DukeDave: ^^^
08:51:58 <DukeDave> scree: Wow
08:53:39 <DukeDave> Dare I ask why the const is required?
08:53:55 <DukeDave> Is that to stop it memoizing the result of getRandomR ?
08:54:20 <scree> DukeDave: it's just saying that the current value in the map is irrelevant
08:54:21 <mauke> memoizing? what
08:54:33 <NemesisD> hi all. i've got a datatype and i want to be able to combine 2 of them into 1. it is essentially a wrapper for a list but with another field on it. the problem is i can't really define mempty because of that field
08:54:57 <DukeDave> Oh, ah, yes I see
08:55:17 <DukeDave> mauke: I thought I'd heard people using cost to force values to be evaluated?
08:55:41 <scree> DukeDave: that doesn't happen
08:56:05 <scree> DukeDave: are you thinking of "seq", which is exactly like const except that it forces its first argument to be evaluated (a bit)?
08:56:10 <NemesisD> the datatype is an "order" which has a vendor and a list of line items. 2 orders with the same vendor mappended combines their line items. 2 orders with different vendors mappended would keep the left one unaltered
08:56:50 <DukeDave> scree: Yes! Yes I am :)
08:57:45 <scree> NemesisD: what is your reason for wanting an mempty when one doesn't really exist?
08:59:10 <NemesisD> scree: the minimal complete definition of monoid requires mempty. so i guess what i'm probably asking is should i be using a different typeclass instead?
09:01:03 <scree> NemesisD: what you want is technically a "semigroup".  I don't believe such a class exists in the standard packages.
09:01:14 <scree> NemesisD: as I see it you have three choices.
09:01:17 <quicksilver> what wqould be the advantage of such a class?
09:01:24 <quicksilver> what are you hoping to gain from a typeclass at all?
09:01:31 <quicksilver> why not just give your operation a name/symbol and use it?
09:01:59 <scree> NemesisD: choice 1: do what quicksilver said
09:02:35 <scree> NemesisD: choice 2: use the semigroup class, or define your own.  only plausible advantage is that you get to write an equivalent of mconcat (on non-empty lists) in more generality
09:02:52 <NemesisD> yeah. maybe it isn't necessary
09:03:32 <DukeDave> scree++
09:03:52 <DukeDave> So that looks perfect, except I can't import Control.Monad.Random :|
09:04:18 <companion_cube> if you have an instance of Data.Traversable for some type, can you deduce Functor or Monad from it ?
09:04:21 <scree> NemesisD: choice 3: implement Monoid with "mempty = error "blah"" and write an mconcat that doesn't fail on non-empty lists.  This has no advantages
09:04:36 <DukeDave> I have System.Random
09:04:46 <DukeDave> Where does it come from :(
09:05:24 <scree> DukeDave: it's a package on hackage, MonadRandom I think
09:06:40 <DukeDave> scree: Cool, thanks, got it
09:07:23 <roconnor> apparently static libraries build with GHC are not portable and depend on some sort of gconv nonsense >:(
09:10:12 <scree> NemesisD: actually, there's a better reason why you shouldn't be trying to instantiate Semigroup or Monoid.  Your binary operation is not associative
09:11:13 <quicksilver> scree: yes it is? left-biased choice is associative and so is ++, a mixture of the two is still associative?
09:13:06 <DukeDave> One last item: Is there a anything nice for: (m a, m b) -> m (a, b)
09:13:21 <DukeDave> Hoogle didn't turn anything up
09:13:26 <parcs> :t uncurry (liftM2 (,))
09:13:27 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
09:15:17 <scree> quicksilver: so, (([1,2], "a") ++ ([], "b")) ++ ([3,4], "a") = ([1,2,3,4], "a")
09:15:43 <scree> quicksilver: but ([1,2], "a") ++ (([], "b") ++ ([3,4], "a")) = ([1,2], "a")
09:15:46 <scree> quicksilver: I think
09:21:24 <xiphiasx> questoin
09:21:28 <xiphiasx> er, question
09:21:34 <xiphiasx> what is meant by "pure or impure code"
09:22:16 <parcs> impure code is code involving IO, has side effects
09:22:19 <beastaugh> pure code is referentially transparent
09:22:30 <xiphiasx> ah
09:27:57 <fragamus> :t foldl
09:27:58 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:33:32 <erus`> :define referentially transparent
09:33:37 <ezyang> Whipped up a blog post on my earlier question: http://blog.ezyang.com/2011/06/a-pattern-for-avoiding-allocation/
09:39:24 <ClaudiusMaximus> is it a bug that `ghc -Dfoo bar.hs baz.cc` #define's foo in bar.hs but not in baz.cc ?  (workaround is `ghc -Dfoo -optc=-Dfoo`)
09:47:17 <d7> Hey folks
09:47:20 <scree> ezyang: your code necessarily stack overflows hideously
09:47:28 <d7> what's the preferred way to host documentation for projects locally?
09:47:33 <d7> Is there a tool to just make it happen?
09:48:13 <kmc> "cabal haddock --hyperlink-source" will generate it
09:48:25 <kmc> not sure what you mean by "host"
09:48:53 <ezyang> scree: It's true. I'm not really sure how to work around it.
09:48:57 <d7> kmc: Well, for example
09:48:58 <beastaugh> kmc: I didn't realise you could pass the --hyperlink-source option to cabal haddock, thanks!
09:49:13 <d7> kmc: I want to do some hacking with snap, but I don't really have Snap's types and API memorized
09:49:18 <ezyang> Hopefully it fuses ok. I haven't tested that yet.
09:49:22 <scree> ezyang: the trouble is that, when I'm processing l@(x:xs), I can't expose a constructor until I know whether "xs == foo xs"
09:49:34 <d7> kmc: With Rubygems, you can actually make a little webserver that hosts all the html documentation for your installed gems
09:49:36 <d7> kmc: That was an awesome feature.
09:49:40 <scree> ezyang: because I'm either exposing l's constructor, or a new one
09:49:49 <scree> ezyang: so what I'm saying is, there is no workaround
09:49:54 <ezyang> :-(
09:50:23 <scree> ezyang: obviously on balanced binary trees, we don't care about log n stack and this is a useful optimization
09:50:28 <kmc> d7, do you need to view it from a remote machine?
09:50:39 <kmc> i use file:// URLs to read my local haddocks and it works fine
09:50:44 <ezyang> Yep.
09:50:54 <d7> kmc: No. In fact, I am on a train undergrond most of the time I want this feature; even cellphones have a hard time talking to the outside world.
09:51:02 <d7> s/gron/groun/
09:51:18 <kmc> there's some way to make Haddock create cross-linked docs for all installed libs
09:51:21 <kmc> but i forgot how exactly
09:51:23 <fusion5> hello, I have a piece of code that causes a stack overflow in ghc, is it possible to see the stack trace to determine which function is causing it?
09:51:27 <kmc> anyway, the web server seems superfluous
09:51:38 <kmc> but if you do need to serve a directory i recommend thttpd
09:51:56 <mightybyte> d7: If you download the snap projects and build them locally you can run the haddock.sh script in the root project directories to generate API docs that you can view locally.
09:51:57 <d7> kmc: I'd take static files
09:52:05 <fusion5> *causes a stack overflow when the binary is run (not in ghc the compiler)
09:52:27 <d7> mightybyte: One would think we could leverage our ~/.cabal directories for this
09:52:42 <thoughtpolice> kmc: i think haddock does that by default now doesn't it?
09:52:44 <kmc> cabal haddock --hyperlink-source
09:52:46 <kmc> does what?
09:52:59 <mightybyte> d7: Yeah, I'm not sure whether there's existing infrastructure for that or not.
09:53:12 <d7> mightybyte: Ahah. Perhaps I have found a way to contribute back to the community. :)
09:53:23 <d7> I dunno how to make that happen offhand tho
09:53:30 <thoughtpolice> kmc: if you install packages and enable documentation, it'll properly generate links to things in other libraries
09:53:46 <thoughtpolice> and update the global installed-package-documentation index
09:57:05 <d7> So how do I get cabal to actually generate documentation?
09:57:13 <d7> I don't see any .html files in my ~/.cabal dir
09:57:13 <d7> but
09:57:25 <d7> My config does have documentation True
09:57:45 <kmc> they end up in dist/doc/
09:58:00 * hackagebot hstzaar 0.7 - A two player abstract strategy game.  http://hackage.haskell.org/package/hstzaar-0.7 (PedroVasconcelos)
09:58:01 <kmc> that's where a given project's "cabal haddock" will put them
09:58:05 <kmc> i don't know about global docs
09:59:09 <d7> I am just surprised more people don't have this problem.
09:59:15 <dcoutts> d7: ~/.cabal/share/doc
09:59:33 <d7> dcoutts: Is there a way to force cabal to globally regenerate them?
09:59:48 <dcoutts> no, they're only generated when packages are build/rebuild
09:59:57 <d7> Is there a way to force a rebuild of all packages?
10:00:11 <dcoutts> rm -r ~/.ghc
10:00:19 <d7> You mean .cabal?
10:00:21 <dcoutts> no
10:00:33 <d7> So if I do that then what do I tell cabal?
10:00:43 <d7> just cabal install a-package?
10:00:46 <dcoutts> right
10:01:15 <dcoutts> d7: that's just deleting (unregistering) all your per-user packages
10:01:22 <dcoutts> somewhat drastic
10:02:10 <d7> So caball install snap is in flight
10:02:18 <d7> Does it do the doc building at the very very end?
10:02:28 <Eelis> is there a place where one can put bounties on bugs/feature requests? the gtk package is missing a binding for a function i need and i wouldn't mind putting up 10 bucks for a fix.
10:02:32 <dcoutts> d7: of each package build, yes
10:02:50 <dcoutts> d7: and the global index is only updated after all are built
10:02:56 <d7> Okay
10:03:04 <dcoutts> Eelis: or send a patch :-)
10:03:20 <Eelis> dcoutts: i dunno how that C interfacing stuff works well enough
10:03:21 <nus> d7, why don't you just mirror http://snapframework.com/docs locally?
10:03:25 <Eelis> dcoutts: and don't want to know :)
10:03:40 <d7> nus: Because that is at least as much of a pain in the ass, and ad-hoc per project?
10:04:17 <dcoutts> d7: if you just want docs for specific packages: cabal install $thepkg --reinstall
10:04:30 <Eelis> dcoutts: the whole point of me using Haskell for my project is so that i don't have to bother with C/C++. if i end up having to hack low level C bindings i might as well use C and save myself a few headaches :)
10:04:52 <dcoutts> Eelis: the C bindings are really not that bad btw
10:05:05 <dcoutts> but yes, it's a fair point, no time to learn
10:05:08 <Eelis> dcoutts: i looked at them briefly and could not make any sense of them
10:05:15 <dcoutts> oh ok :-)
10:05:50 <dcoutts> Eelis: perhaps I think they're not so bad because I wrote half of them :-)
10:06:26 <Eelis> dcoutts: perhaps :) this function in particular is a Cairo thing though. i read that paolo wrote the Cairo bindings
10:06:35 <nus> d7, I doubt typing wget -r -l 0 could induce that much pain, and having the docs mirrored locally is as much ad-hoc p.project as it is for generating them locally
10:06:46 <d7> nus: Why aren't they generated automatically at install time?
10:06:48 <dcoutts> Eelis: ah yes, and they use a different, more terse, style
10:07:37 <nus> d7, 'cause the packager and/or author(s) chose so?
10:07:40 <d7> nus: Seems like a better solution to just generate them locally. Less pain if you forget to mirror something and are caught without an internet connection.
10:09:31 <nus> d7, well, let's see (-:
10:12:56 <d7> Ahh, there we go
10:13:04 <d7> I have to explicitly --enable-documentation
10:15:44 <ski> xiphiasx : basically all Haskell code is oure, has no side-effects
10:16:22 <xiphiasx> ski: including when reading from a file?
10:16:30 <ski> yes
10:16:52 <xiphiasx> ah, neat
10:17:04 <ski> consider
10:17:15 <ski>   do let foo = getLine
10:17:18 <ski>      foo
10:17:19 <ski>      foo
10:17:20 <ski> vs.
10:17:23 <ski>   do foo
10:17:26 <ski> er
10:17:30 <ski>   do getLine
10:17:32 <ski>      getLine
10:17:41 <ski> these two snippets behave the same
10:18:08 <parcs> http://www.haskell.org/haskellwiki/Referential_transparency
10:18:27 <ski> there is no problem with using `let' to factor-out or folding-in code like this, the code will mean the same anyway
10:18:27 <kmc> there are effects in Haskell -- but function evaluation never causes an effect
10:18:49 <ski> (effects /= side-effects)
10:19:02 <kmc> a function can return a description of an effect, to be performed later
10:19:22 <xiphiasx> awesome
10:19:36 <kmc> such effect-descriptions are ordinary first-class values and can be manipulated at will, without causing any effects to actually occur
10:19:42 <ski> xiphiasx : if we had `getLine :: String' (or `getLine :: () -> String', if you want an argument), then `getLine' would be side-effectful, *precisely* because we didn't specify in the interface (the type) that it might do I/O
10:19:58 <benmachine> d7: you can change the default in .cabal/config
10:20:11 <benmachine> oh wait you said you did that
10:20:26 <ski> xiphiasx : however, since we specify `getLine :: IO String', that it might do I/O is *part* of the interface, it doesn't happen on the "side", hidden, therefore there are no side-effects here, just effects
10:20:27 <ion> let getLine = (return . unsafePerformIO) Prelude.getLine in do let { foo = getLine }; foo; foo
10:21:18 <ski> xiphiasx : this also means that we separate clearly between the action of type `IO String' which is something which might do I/O if we run it, and the result of type `String' where the I/O has already happened
10:21:35 <ski> xiphiasx : this is why we can safely replace `foo' by `getLine' above
10:21:47 <kmc> but this "IO" stuff is more powerful and interesting than just tagging some functions as "impure"
10:22:04 <ski> kmc : it is ?
10:22:08 <xiphiasx> neat
10:22:08 <benmachine> d7: so you needed to do --enable-documentation even though you had documentation: True? that sounds odd
10:22:45 <ski> kmc : how is it different from `type IO a = () -{impure}-> a' ?
10:22:45 <kmc> it's more interesting, because separating evaluation from execution is more fundamental
10:23:12 <d7> benmachine: I agree.
10:23:15 <kmc> you can build IO actions which produce functions which return IO actions, etc.
10:23:24 <d7> benmachine: But it definitely says true and it definitely was not updating documentation.
10:23:30 <kmc> you can do that with impure functions that take a () argument, sure
10:23:33 <benmachine> d7: it works for me, are you sure your config file is being read correctly?
10:23:39 <kmc> but it's a lot nastier
10:23:50 <ski> xiphiasx :  btw, this also means that for an operation to be able to do I/O, it must have an `IO' in its result type somewhere (maybe hidden inside a larger `data' or `newtype', but it must be there)
10:23:55 <d7> benmachine: No, but then I'm not sure how I'd check that.
10:24:10 <xiphiasx> ski: ah
10:24:17 <xiphiasx> well, i only need to open a file
10:24:19 <benmachine> d7: hmm, fair point. cabal --help ought to print where it is, at least
10:24:28 <benmachine> (just to make sure that's the one you're editing)
10:24:28 <xiphiasx> store the entire file as binary data into my memory manager
10:24:32 <d7> benmachine: It did, and that's what I changed
10:24:33 <xiphiasx> done
10:24:50 <dcoutts> d7: did you make sure the line in the ~/.cabal/config is uncommented?
10:24:51 <benmachine> d7: hmm
10:24:53 <benmachine> ah
10:24:54 <benmachine> yeah
10:24:56 <d7> dcoutts: Ayep.
10:25:15 <benmachine> dcoutts: maybe the default config file should say "remove -- from lines you want to do anything" :P
10:25:23 <benmachine> (or does it, I forget)
10:25:25 <dcoutts> benmachine: it does
10:25:29 <benmachine> fair enough
10:25:34 <benmachine> it doesn't say in mine, I guess I deleted it
10:25:38 <dcoutts> (or something equivalent)
10:25:46 <d7> "-- Lines (like this one) beginning with '--' are comments."
10:25:51 <benmachine> ah
10:26:03 <dcoutts> benmachine: you've probably got one generated by an older version of cabal
10:26:13 <dcoutts> it doesn't get rewritten on upgrades
10:26:23 <d7> Oh interesting
10:26:27 <benmachine> yeah but I generated a new one the other day
10:26:31 <benmachine> well, a while ago
10:26:44 <benmachine> I probably just delted that bit
10:27:13 <d7> Ahh, I think I see what happened
10:27:23 <d7> Curse you vi, you put tabs in my file and confused something.
10:27:36 <benmachine> :<
10:27:36 <ddarius> d7: I blame user error.
10:27:43 <benmachine> ddarius: I blame you
10:28:03 <d7>  Maybe I had an error in the file I deleted some extra-* lines and retyped them in emacs so I was sure they didn't have tabs, and now it is finding that documentation line.
10:28:20 <d7> ddarius: I'm willing to cop to pebkac, but I'm taking vi down with me.
10:28:21 <benmachine> oh ok
10:28:26 * benmachine hugs vim
10:28:44 <d7> still, this index file is great.
10:28:55 <benmachine> dcoutts: I just moved my config file and cabal updated to generate a new one, it has username/password in it twice
10:29:07 <benmachine> (version 0.10.2)
10:29:12 <benmachine> (possibly from darcs, I forget)
10:30:59 <benmachine> oh darcs version doesn't do it
10:31:07 <monochrom> it's a good idea to confirm your password :)
10:31:34 <dcoutts> benmachine: yeah, that was my fault, fixed in the darcs version.
10:32:31 <drosophyllum> Things just compile... and then ... just work. I like this language.
10:32:42 <kmc> yeah, well getting them to compile is the hard part ;)
10:32:47 <kmc> but errors at compile time are infinitely better
10:34:12 <drosophyllum> thats true, but its remarkable that this is a compiled language
10:34:44 <drosophyllum> writing the compiler for such a high level language must have been a little violent
10:34:56 <c_wraith> Eh.  There's a lot of history and research in the area.
10:35:12 <c_wraith> I believe the basic idea for compilers for languages of this sort was developed around 1980
10:35:36 <c_wraith> which well-predates haskell (which started in 1990)
10:42:59 <fizruk> hi all! can anyone point me some papers on implementing efficient immutable data structures?
10:44:45 <c_wraith> fizruk: anything written by okasaki
10:44:55 <monochrom> everything by Chris Okasaki. http://www.eecs.usma.edu/webs/people/okasaki/pubs.html
10:44:56 <kmc> what kind of data structures?
10:44:58 <k0ral> where will extra-source-files mentioned in cabal package be put ?
10:45:05 <ski> Chris Okasaki, "Purely Functional Data Structures", <http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf>
10:45:56 <k0ral> I mean when installing the package
10:46:17 <dcoutts> k0ral: they're not installed, they're source files.
10:46:20 <c_wraith> k0ral: they're not installed anywhere.  they're just included with the source distro produced by cabal sdist, and uploaded to hackage
10:46:23 <fizruk> kmc: lists and trees for the begging
10:46:47 <monochrom> eh? you don't need a phd to do lists and trees
10:46:49 <fizruk> c_wraith monochrom ski: thanks
10:46:57 <kmc> well it depends what language you're using
10:47:05 <kmc> in Haskell you don't really have to "implement" lists and trees
10:47:10 <kmc> you just specify what they are
10:47:15 <k0ral> dcoutts, c_wraith: what about data-files ?
10:47:36 <c_wraith> k0ral: somewhere in ~/.cabal  I've never used the feature
10:47:39 <absentia> on sovient russia, lists incriminate you...
10:47:42 <kmc> but, maybe you want your lists to do more than a simple linked list
10:47:57 <k0ral> dcoutts, c_wraith: maybe I should ask differently: how can I include a file that is needed at runtime but not at compile time ?
10:48:00 * JuanDaugherty don't need no stinkin phd period.
10:48:02 <kmc> if you want something like a list but with efficient indexing, look at Data.Sequence
10:48:12 <dcoutts> k0ral: http://www.haskell.org/cabal/users-guide/authors.html#paths-module
10:48:16 <monochrom> data-files are likely in $prefix/share, which means ~/.cabal/share if --user on unix
10:48:35 <copumpkin> JuanDaugherty: why would anyone want a stinking phd? I'd prefer a nicely fragrant one
10:48:36 <monochrom> your ~/.cabal/config has commented-out defaults for all these directories
10:48:39 <dcoutts> k0ral: they go in the $datadir, and there's a way to find them at runtime, see the user guide ^^
10:49:12 <k0ral> dcoutts, monochrom, c_wraith: thank you, I have enough information to go ahead :)
10:49:27 * JuanDaugherty imagines an experience of the other snakepit that might waft so sweet.
10:50:04 <dcoutts> k0ral: so don't guess the paths, just use the getDataFileName provided by cabal and it'll always work no matter how the user configures the package
10:50:41 <dcoutts> (there's also an env var to override the location for special circumstances)
10:50:46 <k0ral> dcoutts: fine :)
10:51:03 <JuanDaugherty> copumpkin, I guess an honorary degree in CS or Math would be like that.
10:51:09 <k0ral> dcoutts: but still if this env var is changed, getDataFileName will point to the right location ?
10:51:58 <monochrom> some people got their phds by skipping shower for months. those are stinking phds.
10:52:19 <JuanDaugherty> strange defense that
10:52:34 <JuanDaugherty> could be effective way though
10:52:54 <copumpkin> oh is that what they mean by defending, regarding a phd?
10:53:00 <copumpkin> defensive bad hygiene?
10:53:45 <monochrom> think of a phd defense as an interview for "xxx idols" or "xxx got talents"
10:53:47 <benmachine> in the manner of the skink
10:53:51 <benmachine> er
10:53:51 <benmachine> skunk
11:04:07 <saml> > i wanna learn haskel
11:04:08 <lambdabot>   Not in scope: `wanna'Not in scope: `learn'Not in scope: `haskel'
11:04:40 <drosophyllum> lambdabot-> lol
11:05:35 <parcs> > do it
11:05:36 <lambdabot>   now!
11:05:44 <parcs> :P
11:06:07 <JuanDaugherty> sml: LYAH
11:06:16 <parcs> hmm, strange:
11:06:20 <parcs> @type do ?x
11:06:21 <lambdabot> forall t. (?x::t) => t
11:06:22 <drosophyllum> > take 3 (repeat 5)
11:06:23 <lambdabot>   [5,5,5]
11:06:27 <parcs> @type do { ?x; ?x }
11:06:28 <lambdabot> forall (m :: * -> *) b. (?x::m b, Monad m) => m b
11:06:29 <k0ral> I have troubles making Paths_pkgname working
11:06:40 <drosophyllum> oh wait... is this what I think it is!?
11:06:41 <c_wraith> > do 5 -- parcs
11:06:42 <lambdabot>   5
11:07:10 <c_wraith> parcs: a do block doesn't constrain the type until you have multiple lines in it
11:07:13 <k0ral> when recompiling with Dyre
11:07:36 <k0ral> Could not find module `Paths_hbro'
11:07:47 <mauke> > let us = do it in here
11:07:49 <lambdabot>   yes!
11:07:52 <parcs> c_wraith: why?
11:09:05 <c_wraith> parcs: because a do block doesn't actually constrain the type at all.  The type is only constrained by the desugared expression.  Without multiple lines, nothing can desugar into >> or >>=, which are what actually constrain the type
11:09:22 <k0ral> dcoutts: is getDataFileName usable in a context where Dyre is usd ?
11:09:23 <c_wraith> > do { let x = 5 ; x }
11:09:24 <lambdabot>   <no location info>: parse error on input `}'
11:09:26 <parcs> c_wraith: oh of course!
11:10:01 <c_wraith> > do { let {x = 5} ; x }
11:10:02 <lambdabot>   5
11:11:49 <parcs> > do do 5
11:11:50 <lambdabot>   5
11:11:55 <parcs> heh
11:23:27 <xiphiasx> hm
11:23:30 <xiphiasx> haskell.org went down
11:23:45 <xiphiasx> maybe not
11:23:46 <drosophyllum> its back
11:25:17 <xiphiasx> question
11:25:18 <xiphiasx> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Word.html#g:1
11:25:21 <xiphiasx> where are signed integers?
11:25:43 <kmc> Data.Int
11:25:52 <kmc> why do you need explicit sizes?
11:25:58 <xiphiasx> emulation
11:25:58 <xiphiasx> :p
11:26:04 <xiphiasx> there's no way to pull off the PS1 without those
11:26:12 <xiphiasx> i could use long and short etc
11:26:14 <xiphiasx> but this way is much better
11:27:15 <kmc> :)
11:27:24 <xiphiasx> oh
11:27:27 <xiphiasx> casting
11:27:31 <xiphiasx> casting from signed -> unsigned
11:27:36 <xiphiasx> how would one do that?
11:28:00 <c_wraith> > (fromIntegral :: (Int32 -> Word32)) -1
11:28:01 <lambdabot>   *Exception: show: No overloading for function
11:28:10 <xiphiasx> neat
11:28:11 <c_wraith> oh
11:28:12 <c_wraith> hah
11:28:13 <xiphiasx> o
11:28:16 <c_wraith> > (fromIntegral :: (Int32 -> Word32)) (-1)
11:28:17 <lambdabot>   4294967295
11:28:21 <c_wraith> there :)
11:28:21 <xiphiasx> marvelous
11:28:24 <xiphiasx> you'll see me in here a lot
11:28:28 <xiphiasx> i'm somewhat new to haskell
11:28:31 <xiphiasx> i used it before
11:28:33 <xiphiasx> but now i can barely remember it
11:28:37 <xiphiasx> i'll get back into it
11:36:02 <yrlnry> As I understand it there is a formal topological sense in which the sequence ⊥, 1:⊥, 1:2:⊥, 1:2:3:⊥, … tends to the limit 1:2:3:… .  You can put a topology on the space of values, and in this topology, the infinite list is indeed the limit of the sequence of partial lists.  Where can I read more about that?
11:37:11 <ski> @where topology
11:37:11 <lambdabot> "topology in Haskell" <http://www.haskell.org/pipermail/haskell/2004-June/014134.html> and "Synthetic topology of data types and classical spaces" <http://www.cs.bham.ac.uk/~mhe/papers/entcs87.(pdf|
11:37:12 <lambdabot> dvi|ps)> by Martn Escard
11:37:20 <ddarius> Presumably it's the Scott topology.
11:37:22 <ski> is a bit related to that
11:37:38 <yrlnry> Thanks very much!  Last time I tried to read a paper by Escardó I did not get much out of it.
11:37:57 <yrlnry> I'll try this.
11:38:11 <monochrom> yeah, scott topology. though I'm pretty sure you shouldn't bring in topology at all
11:38:20 <yrlnry> why not?
11:38:31 <monochrom> only partial order is necessary
11:39:00 <yrlnry> Oh, is the topology derived from the Scott domain partial ordering in some simple way?
11:39:06 <monochrom> yes
11:39:24 <yrlnry> Still I think this monograph is probably just what I want.  I wanted to know why computable functions were continuous.
11:39:27 <yrlnry> (Also.)
11:39:33 <monochrom> I'm pretty sure you won't use "open set" "closed set" often
11:39:38 <JuanDaugherty> is there a plain reason that ">>=" and ">>" would not be in something calling itself a haskell cheatsheet that I'm not picking up?
11:39:54 <yrlnry> JuanDaugherty:  incompetent cheatsheet author?
11:40:00 <sanjoyd> Can someone give me an example of something with a kind * -> (* -> *) -> * ?
11:40:03 <c_wraith> JuanDaugherty: the author thought monads are complicated?
11:40:04 <JuanDaugherty> right, except for that
11:40:12 <c_wraith> :kind StateT
11:40:13 <mauke> googling wildly, possibly related: http://en.wikibooks.org/wiki/Haskell/Denotational_semantics http://blog.ezyang.com/2010/12/hussling-haskell-types-into-hasse-diagrams/
11:40:16 <c_wraith> @kind StateT
11:40:17 <JuanDaugherty> just checking
11:40:17 <lambdabot> * -> (* -> *) -> * -> *
11:40:22 <sanjoyd> c_wraith: thanks.
11:40:29 <c_wraith> sanjoyd: not quite what you were looking for, but close
11:40:47 <yrlnry> mauke:  I've seen those EZYang posts; I think they're not what I want.  But thanks very much.
11:40:57 <yrlnry> I think this Escardó monograph is a good place to start.
11:41:15 <monochrom> if the cheatsheet tells you to use the do-notation, it can omit >>= and >>
11:41:26 <monochrom> and vice versa
11:41:33 <yrlnry> it should still explain one in terms of the other.
11:41:39 <yrlnry> Since you inevitably see both.
11:41:56 <yrlnry> >>= is not some obscure feature that not everyone needs to know.
11:42:05 <kmc> sanjoyd, data T x f = T (f x)
11:42:20 * ddarius likes the amount of negation used in yrlnry's statement.
11:42:30 <sanjoyd> kmc: yeah, got the hang of it now.
11:42:32 <d7> I've gotta confess
11:42:33 <d7> let z t = let (c,whatever) = (t + 1, whatever) in c
11:42:34 <kmc> T (Just 3) :: T Int Maybe
11:42:37 <d7> Seriously disturbs me
11:42:51 <kmc> why?
11:43:06 <d7> I guess my question is
11:43:12 <d7> how could one ever use that?
11:43:17 <monochrom> let z t = let {c = t + 1; whatever = whatever} in c
11:43:17 <kmc> what do you mean?
11:43:29 <mauke> int z(int t) { int c = t + 1, whatever = whatever; return c; }  // valid C code
11:43:29 <kmc> also is "whatever" meant to be a single variable?
11:43:32 <monochrom> but since there is an outer let...
11:43:42 <monochrom> let z t = let {c = t + 1; whatever = whatever} in c in z 5
11:43:45 <d7> monochrom: Well it was just fooling on ghci
11:44:01 <monochrom> if you don't want to use it, then don't use it
11:44:09 <d7> kmc: I mean, is there ever a case where you can use the result of a computation to help invoke it? That seems to be the implication of that code.
11:44:13 <kmc> yes
11:44:15 <kmc> that's called recursion
11:44:17 <kmc> > let (evens, odds) = (0 : map succ odds, map succ evens) in evens
11:44:17 <d7> But for the life of me I don't get how that knot could ever be untied
11:44:18 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
11:44:27 <d7> kmc: Yes but in this case
11:44:29 <d7> I mean..
11:44:35 <kmc> in Haskell we can recurse with non-functions
11:44:38 <kmc> because of laziness
11:44:41 <mauke> d7: by using guarded recursion
11:44:44 <kmc> you're right that "let x = x" is useless
11:44:50 <d7> obviously not this case since it's impossilbe ;)
11:44:51 <kmc> but "let x = f x" is not necessarily
11:44:55 <kmc> > let x = 1:x in x
11:44:56 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:45:00 <ski> d7 : you could use `let z t = c where (c,whatever) = (t + 1,whatever)', instead ..
11:45:20 <JuanDaugherty> d7, have you ever programmed a recursive function, like quicksort?
11:45:24 <d7> JuanDaugherty: Yes
11:45:31 <d7> kmc: I seem to recall reading a thing about pretty printer library
11:45:46 <d7> that did something like this. I didn't understand it then
11:45:56 <JuanDaugherty> well there you go
11:45:56 <monochrom> again, if you don't want to use it, then don't use it. you don't have to care
11:46:01 <kmc> do you understand my evens/odds example?
11:46:10 <monochrom> but I have used it and I'm too lazy to tell you details now
11:46:31 <d7> kmc: I think I do.
11:47:08 <d7> It still doesn't come naturally on me to recurse that way, tbh.
11:47:25 <kmc> yeah, it takes getting used to
11:47:47 <kmc> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
11:47:48 <lambdabot>   not an expression: `let fibs = 1 : 1 : zipWith (+) fibs (tail fibs)'
11:47:51 <kmc> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
11:47:51 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
11:47:52 <d7> I get why the statement I wrote is not an error, whatever is circular but it's never used so whatever.
11:48:06 <mauke> > let whatever = whatever in whatever
11:48:10 <lambdabot>   mueval-core: Time limit exceeded
11:48:15 <d7> yeah
11:48:21 <mauke> oleg actually uses this
11:48:23 <kmc> fun fact: ghc -O2 will discover those infinite loops and bail out
11:48:29 <d7> orly?
11:48:32 <d7> mauke: Also, orly?
11:48:37 <kmc> ya rly
11:48:45 <mauke> because doing '__=__' and using '__' instead of 'undefined' is shorter
11:48:46 <d7> mauke: How does one use that?
11:49:08 <mauke> can you think of a use for 'undefined'?
11:49:09 <d7> mauke: Shorter, like character count?
11:49:12 <mauke> yeah
11:49:13 <xiphiasx> question
11:49:16 <xiphiasx> what's the performance of haskell
11:49:20 <d7> mauke: I usually use it for stubbed functions. :)
11:49:22 <yrlnry> I just discovered Oleg's web site this week.
11:49:27 <mauke> xiphiasx: about 56
11:49:28 <yrlnry> xiphiasx:  14.3
11:49:38 <kmc> over 9000
11:49:41 <xiphiasx> i mean like
11:49:42 <yrlnry> Mauke: Are you using Herglotz Units there?
11:49:45 <xiphiasx> is it comparable to C?
11:49:47 <mauke> but is it webscale?
11:49:47 <xiphiasx> or C++?
11:49:56 <kmc> xiphiasx, Haskell is a language, not a piece of software
11:49:58 <mauke> xiphiasx: it can be compared to both C and C++ simultanously
11:49:59 <kmc> therefore it has no performance
11:50:08 <kmc> GHC is a compiler for Haskell which produces pretty fast code
11:50:10 <xiphiasx> alright then
11:50:10 <mauke> concurrency, you see
11:50:11 <xiphiasx> GHC
11:50:24 <mauke> ghc is slower than gcc
11:50:38 <confound> that's because h comes after c in the alphabet
11:50:39 <mauke> most of the time is probably spent linking, though
11:50:39 <kmc> usually the simple idiomatic Haskell code will not run as fast as C code, but will take less time to write
11:50:42 <d7> xiphiasx: If you don't get tripped up by the memory model, it's generally comparable-or-better-than the modern jvm (with better memory usage), from what I've seen so far.
11:50:46 <ski> @where oleg
11:50:46 <lambdabot> http://okmij.org/ftp/
11:50:51 <kmc> then you can optimize the parts that need optimizing
11:50:53 <xiphiasx> i don't care about how long compilation takes
11:51:02 <xiphiasx> as long as i'm not sitting there for like 10 minutes :p
11:51:08 <confound> write small programs then
11:51:10 <d7> xiphiasx: In some cases it can get down to the level where a good C++ or C compiler operates.
11:51:19 <xiphiasx> then this is the tool for the job
11:51:19 <kmc> remember that tons of real-world work gets done in Python and PHP and Ruby
11:51:22 <d7> xiphiasx: Haskell is way better about compilation than, say, Scala
11:51:28 <xiphiasx> kmc: i'm aware
11:51:35 <kmc> GHC totally blows away common interpreters for those languages
11:51:41 <xiphiasx> however, emulation is nearly impossible in those languages
11:51:51 <d7> kmc: Every time people ask me if Haskell is fast enough for real work, I point to ruby enterprise edition and say, "The bar is pretty effing low."
11:52:00 <kmc> http://visual6502.org/JSSim/
11:52:22 <xiphiasx> seen it
11:52:22 <xiphiasx> heh
11:52:23 <kmc> Python and Ruby *could* have really good implementations, btw
11:52:25 <kmc> Javascript and Lua do
11:52:26 <monochrom> I'm reading the official python tutorial. I'm horrified to see that the first while-loop example is the fibonacci sequence. and the first define-function example is again the fibonacci sequence.
11:52:30 <kmc> PyPy is getting there
11:52:48 <confound> in fact every example is the fibonacci sequence, even sockets and string formatting
11:52:57 <d7> monochrom: In general, Python is a horrifying experience.
11:52:58 <monochrom> so much for complaining about using the useless fibonacci sequence in haskell tutorials. the official python tutorial does it too
11:53:00 <mauke> they're stealing our everything!
11:53:09 <xiphiasx> kmc: ruby has rbx
11:53:11 <xiphiasx> rbx is very good
11:53:12 <confound> there's only one way to learn it!
11:53:14 <mauke> layout, list comprehensions, fibonacci, ...
11:53:25 <d7> monochrom: It's an incredible intellectual heist that people consider python "simple"
11:53:37 <confound> it's simple because it doesn't have dollar signs
11:53:38 <xiphiasx> it's simple until you know it
11:53:39 <xiphiasx> :p
11:53:43 <d7> Indeed.
11:53:56 <d7> It's simple until you actually want to write software and not one-off data munging hakcs.
11:54:04 <companion_cube> d7: python is simple if you're accustomed to imperative OO way of thinking
11:54:14 <d7> companion_cube: I am very accustomed to the OO, imperative way of thinking
11:54:20 <d7> companion_cube: I do not consider python simple or beautiful.
11:54:39 <kmc> well these days you only learn Java in school
11:54:45 <kmc> Python seems fantastic compared to Java
11:54:54 <kmc> an OOP language where you can define a class with less than two dozen lines of boilerplate?
11:54:56 <kmc> sign me up
11:55:05 <d7> kmc: Scala. But...
11:55:11 <mauke> package YourClass;  # zomg awesome
11:55:18 <monochrom> python was there earlier
11:55:23 <d7> Python just has so many weird things. e.g., explicit self parameters.
11:55:25 <companion_cube> scala is great apart from compilation time
11:55:48 <yrlnry> You can define an OOP class in Perl with WAY less than two dozen lines of boilerplate.
11:55:55 <d7> Indeed.
11:55:55 <hvr> companion_cube: and apart from the Java legacy...
11:56:07 <yrlnry> Closer to 2, and approaching zero if you want to.
11:56:12 <d7> and dear god, calling a superclass method in python is like... a homerian epic.
11:56:25 <yrlnry> Calling one in perl is easy, except it doesn't actually work.
11:56:40 <yrlnry> :)
11:56:47 <d7> Haha, and it also doesn't work except in python 3000
11:57:08 <companion_cube> hvr: java legacy ? yes, there is null, but sometimes the java std libs are useful
11:58:04 <hvr> companion_cube: well, I expect Java to be an intermediate step in the evolution, leading to something much more interesting, once it can leave Java-compatibility behind
11:58:37 <companion_cube> the jvm is still claimed to be a great piece of software by many
11:58:39 <hvr> tbh, I don't care at all about java libraries
11:59:00 <hvr> companion_cube: jeah, but when I say Java I mean the language, not the VM
11:59:05 <companion_cube> oh, yeah
11:59:06 <d7> Meanwhile people complain about ruby's 3.times { do_something }
11:59:16 <companion_cube> scala is not like java
11:59:28 <d7> companion_cube: The JVM is a competent, well-instrumented environment
11:59:32 <companion_cube> but sometimes it's great to be able to use code written for java
12:00:31 <k0ral> guys, I'm having troubles to make getDataFileName work when dyre is recompiling
12:00:39 <hvr> companion_cube: can't judge that... I only programmed for a few weeks in Java, and never ever again since then... I'm quite happy with the stuff outside the java-ecosystem :)
12:00:42 <k0ral> anyone has a clue on this ?
12:01:39 <hvr> I see big potential in Scala however, as a mindset-shifting tool
12:02:45 <confound> like python, scala is much more palatable if you're viewing it as an alternative to java
12:03:02 <hvr> python is a java-alternative? :)
12:03:16 <confound> [15:21] < kmc> Python seems fantastic compared to Java
12:03:30 <hvr> ...and so does Haskell... :)
12:03:59 <monochrom> python is even a c-alternative
12:04:15 <companion_cube> i dont' think everyone is ready to get rid of side effects as a builtin and use a purely functional language, and scala provides the ability to do both
12:04:40 <hvr> ...as does haskell :)
12:05:05 <companion_cube> errrr
12:05:07 <dino-> I feel like you certainly can miss the point and write in Scala like it's Java-with-different-syntax. But you can also deliberately avoid that lean hard towards FP.
12:05:07 <mauke> http://i.imgur.com/YdVai.jpg
12:05:08 <confound> hvr: you can make that argument if you like, it's just not what I was responding to
12:05:20 <mauke> (since we're not quite on topic anyway)
12:05:21 <dino-> ^ avoid that and..
12:05:38 <companion_cube> the idea with scala is to begin with java-less-verbose and progressively use more FP-like style
12:05:47 <companion_cube> with immutable collections, actors and so on
12:06:01 <hvr> companion_cube: yeah, that's what I meant by mindset-shifting
12:06:17 <ddarius> I don't think that's the perspective with which Odersky came at it.
12:06:28 <companion_cube> i do agree, maybe scala will really make FP enter the mainstream
12:06:47 <hvr> ddarius: ...what do you think it was?
12:07:11 <companion_cube> he wanted a more powerful type system !
12:07:13 <companion_cube> :)
12:07:23 <ddarius> That's actually not a bad way to put it.
12:07:37 <hvr> ...doesn't that ultimately lead to Haskell?
12:07:50 <ddarius> No.
12:07:59 <hvr> (or at least HM systems?)
12:08:03 <companion_cube> weren't there some papers on LtU saying that scala's type system is stronger ?
12:08:14 <ddarius> Haskell isn't HM.
12:08:23 <kmc> Haskell's type system isn't that great
12:08:27 <kmc> GHC Haskell's is cooler
12:08:34 <kmc> but Scala has some features GHC doesn't
12:08:40 <kmc> (whether or not they're good features is another question)
12:09:02 <hvr> companion_cube: I'd be interested in those papers in case you still have the refs
12:10:02 <companion_cube> http://lambda-the-ultimate.org/node/4039 for instance
12:10:25 <kmc> there's a converse to the "Python is awesome because it's not Java" fallacy
12:10:37 <companion_cube> personnally, i feel that scala's implicits are black magic, but theoretically they can do lots of things
12:10:40 <kmc> which is to find Haskell and then declare that it is the best of all possible programming languages
12:10:57 <kmc> i like implicits as a simpler, more general approach to type classes
12:11:10 <mauke> haskell is blub
12:11:11 <kmc> the main thing you lose is the guarantee of a single canonical instance
12:15:13 <ddarius> @pl (\y' -> Right $ y':counit (rest ys))
12:15:13 <lambdabot> Right . (: counit (rest ys))
12:19:26 <sgronblo> does anyone know if ubuntu is planning on ever fixing the haskell-platform package?
12:19:56 <ddarius> @let counit = either id id
12:19:56 <lambdabot>  Defined.
12:20:14 <ddarius> @let paraList c n [] = n; paraList c n (x:xs) = c x xs (paraList c n xs)
12:20:15 <lambdabot>  Defined.
12:20:24 <ddarius> @let sharingMap' f = counit . join (paraList (\y ys rest xs -> maybe ((y:) <$> rest xs) (Right . (:counit (rest ys))) (f y)) Left
12:20:25 <lambdabot>   Parse error: ;
12:20:34 * hackagebot hbro 0.5.0 - A suckless minimal KISSy browser  http://hackage.haskell.org/package/hbro-0.5.0 (koral)
12:20:40 <ddarius> > 3
12:20:41 <lambdabot>   3
12:20:56 <ddarius> @let sharingMap' f = counit . join (paraList (\y ys rest xs -> maybe ((y:) <$> rest xs) (Right . (:counit (rest ys))) (f y)) Left)
12:20:57 <lambdabot>  Defined.
12:21:53 <ddarius> > sharingMap' (\x -> if x == 2 then Just 3 else Nothing) [1..10]
12:21:55 <lambdabot>   [1,3,3,4,5,6,7,8,9,10]
12:23:39 <ddarius> @pl (\y ys rest xs -> maybe ((y:) <$> rest xs) (Right . (:counit (rest ys))) (f y)
12:23:39 <lambdabot> (line 1, column 79):
12:23:39 <lambdabot> unexpected end of input
12:23:39 <lambdabot> expecting variable, "(", operator or ")"
12:23:44 <ddarius> @pl (\y ys rest xs -> maybe ((y:) <$> rest xs) (Right . (:counit (rest ys))) (f y))
12:23:45 <lambdabot> ap (flip . ((flip . (flip .)) .) . (. ((((Right .) . flip (:) . counit) .) . flip id)) . ap . ((flip . (maybe .)) .) . (.) . (<$>) . (:)) f
12:24:20 <ddarius> @pl \xs -> maybe ((y:) <$> rest xs) (Right . (:counit (rest ys))) (f y)
12:24:20 <lambdabot> flip (flip maybe (Right . (: counit (rest ys))) . ((y :) <$>) . rest) (f y)
12:34:43 <ski> ddarius : ok, a parsimonious `map'
12:35:13 <rtharper> is there any other kind?
12:35:26 <ski> @src map
12:35:26 <lambdabot> map _ []     = []
12:35:27 <lambdabot> map f (x:xs) = f x : map f xs
12:35:44 <ski> taken at face value, that's not parsimonious
12:36:39 * ski ponders a compiler pass for parsimonification
12:39:36 <Cale> ski: What do you mean by parsimonious here?
12:40:41 <shachaf> @ty asTypeIn -- Is this a lambdabot invention?
12:40:42 <lambdabot> forall a b. a -> (a -> b) -> a
12:40:46 <Cale> yeah
12:41:43 <kmc> i'm writing a MATLAB .mat file parser in haskell
12:41:45 <Cale> :t map `asTypeIn` \map -> map (*2) [1..10]
12:41:46 <lambdabot> forall a. (Num a, Enum a) => (a -> a) -> [a] -> [a]
12:41:57 <Cale> :t map `asTypeIn` \map -> map (*2) [1..10 :: Integer]
12:41:57 <lambdabot> (Integer -> Integer) -> [Integer] -> [Integer]
12:42:01 <kmc> the format is basically nested type-len-data triples
12:42:10 <kmc> (as is every other damn format in the world, yet they can't be standardized for some reason)
12:42:16 <kmc> anyway, is Attoparsec a good choice here?
12:42:27 <kmc> even though my "grammar" has no possibility of backtracking
12:42:40 <Cale> :t (>>=) `asTypeIn` \(>>=) -> getLine >>= putStrLn
12:42:41 <lambdabot> IO String -> (String -> IO ()) -> IO ()
12:42:59 <kmc> i feel like it still provides useful plumbing
12:43:21 <ClaudiusMaximus> @check \n -> n <= 0 || (map magnitude . (zipWith (-) `ap` drop 42)) (iterate (((0.27698448519620117 :+ 7.137640148907812e-3) +).(^2)) 0) !! n == 0
12:43:22 <lambdabot>   "OK, passed 500 tests."
12:43:41 <ski> Cale : as in the example `filter' function in Olin Shiver's and David Fisher's "Multi-Return Function Call", 200[46]-09, at <http://www.ccs.neu.edu/home/shivers/citations.html#mrlc>
12:44:17 <ski> Cale : see "Multi-return Function Call example" <http://hpaste.org/13301> for just the example
12:44:43 <ski> (shachaf : yeah, i invented it one day here ..)
12:49:06 <Cale> oh, in terms of memory?
12:49:30 <ski> yeah, not unnecessarily constructung new cells
12:49:35 <ski> i.e. sharing when possible
12:49:42 <ski> @src asTypeIn
12:49:43 <lambdabot> a `asTypeIn` f = a where _ = f a
12:49:43 <lambdabot> infixl 0 `asTypeIn`
12:49:48 <ski> @src asAppliedTo
12:49:48 <lambdabot> Source not found. :(
12:49:55 <ski> @type asAppliedTo
12:49:56 <lambdabot> forall t b. (t -> b) -> t -> t -> b
12:50:02 <ski> @type asTypeIn
12:50:03 <lambdabot> forall a b. a -> (a -> b) -> a
12:51:31 <Saizan> ski: a problem is that it can't be lazy and it seems to use O(n) stack?
12:52:06 <ski> infixl 0 `asAppliedTo`; a `asTypeIn` f = a where _ = f a  -- apparently
12:52:21 <ski> er, bad
12:52:43 <ski> infixl 0 `asAppliedTo`; f `asAppliedTo` x = f `asTypeIn` \f -> f x
12:54:53 <ski> (Saizan : pondering ..)
12:55:06 <d7> Is it bad form to poach *** from arrows for tuple manipulation? :)
12:55:31 <Cale> d7: no
12:55:53 <Cale> In fact, the instance of Arrow for (->) is probably the most commonly used one :)
12:56:03 <ClaudiusMaximus> better to use fmap than second, or not?
12:56:58 <d7> Cale: Even though some of the functions make very little sense? :)
12:57:19 <ski> Saizan : the point (in the paper) of the `filter' in SML (with this extension) would be that this would be an example of a semi-tail-recursive function
12:58:04 <ski> Saizan : my Haskell translation was just to be able to discuss this extension in Haskell syntax
12:58:27 <d7> Cale: E.g., loop.
12:58:45 <ddarius> Just go whole hog to Oz or another language with dataflow/logic variables.
12:58:46 <Cale> Well, loop makes sense
12:58:51 <ski> Saizan : seeing how tail-recursive functions can't be incremental, it's possible that you're right. i'm not sure
12:58:55 <Cale> I don't know whether you'd actually use it over using fix directly
12:59:08 <d7> Cale: Fix?
12:59:12 <ski> @src (,) fmap
12:59:12 <lambdabot> fmap f (x,y) = (x, f y)
12:59:17 <Cale> fix f = x where x = f x
12:59:20 <ski> @sr (->) second
12:59:20 <lambdabot> second f = id *** f
12:59:27 <ski> @sr (->) (***)
12:59:28 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
12:59:42 <Cale> (should be in the prelude, but it's not)
12:59:52 <ski> ClaudiusMaximus : so `fmap' and `second' differs in strictness
12:59:54 <Cale> It's in Data.Function iirc, though
13:00:10 <Saizan> ski: semi-tail-recursive = ?
13:00:31 <Cale> It gives the least defined x such that x = f x
13:00:38 <Cale> > fix (0:)
13:00:39 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
13:00:40 <ski> Saizan : the point is to be able to pass more than one continuation to a function call
13:00:56 <ClaudiusMaximus> ski: interesting; i remember some discussion about (,) fmap strictness on -cafe, but can't remember the outcome :)
13:00:56 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
13:00:57 <lambdabot>   3628800
13:01:19 <ski> Saizan : semantically, the function has a return type like `Either# a b', operationally it is passed one continuation for `a', and one continuation for `b'
13:01:49 <ski> Saizan : a semi-tail-all is a call which uses the same continuation, for at least one of the continuations passed
13:02:07 <Saizan> ski: i see
13:02:12 <ski> Saizan : so, if the called function chooses to return through that continuation, it is in effect a tail-call-return
13:02:13 <ddarius> ski: You don't know whether to return the original input unchanged or some modified input, in the worst-case, until you reach the end.  In the best-case, it should behave just like map.
13:02:22 <ski> Saizan : see the paper for details
13:02:40 <d7> Cale: Oh, fix.
13:02:45 <d7> Cale: I didn't realize loop was fix.
13:02:54 <ddarius> d7: It isn't.
13:02:59 <ddarius> It's related to fix.
13:03:02 <d7> Ah
13:03:02 <ski> ddarius : *nod*
13:03:22 <ski> @type loop
13:03:23 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
13:04:14 <ski> `loop' is related to <http://en.wikipedia.org/wiki/Trace_(linear_algebra)>
13:04:28 <Cale> In a quite abstract way, yes :)
13:05:32 * ski idly wonders whether it is possible to make `instance Num a => Category (LinearTransformation a)' ..
13:18:41 <benmachine> ski: why wouldn't it be
13:23:06 <ski> benmachine : i was pondering things like `LinearTransformation Double (Succ (Succ (Succ Zero))) (Succ (Succ Zero))'
13:23:59 <benmachine> ah
13:24:19 <benmachine> I imagine 'id' would be the tricky one, then
13:25:22 <benmachine> well actually the problem is that you could have a LinearTransformation Double Char (IO ()) and you'd have to be able to compose that with LinearTransformation Double (IO ()) (s -> a)
13:25:45 <benmachine> because it's impossible to say 'only type-level naturals, please'
13:26:03 <ski> if `LinearTransformation' is a GADT, it could work
13:27:00 <sully> anybody here doing the ICFP now?
13:32:55 <whatsup159951> hi
13:32:57 <whatsup159951> could You help me please?
13:33:30 <whatsup159951> I got a list of tuples [(int, Int, Int)] like [(a,b,c)] and wanna make them bigger into: [(a,b,0,c)]
13:33:34 <whatsup159951> I mean add one element
13:33:37 <mauke> ok
13:34:02 <ski> > map (\(a,b,c) -> (a,b,0,c)) [(a,b,c)]
13:34:03 <lambdabot>   [(a,b,0,c)]
13:34:06 <monochrom> > map (\(a,b,c) -> (a,b,0,c)) [(1,2,3), (7,4,1)]
13:34:06 <lambdabot>   [(1,2,0,3),(7,4,0,1)]
13:34:39 <ski> .. i wonder how to pronounce `GADT' .. "gadget" ? :)
13:34:47 <monochrom> G A D T
13:34:59 <hpaste> tafryn pasted “isSquare” at http://hpaste.org/47918
13:35:03 <Twey> I pronounce it /gadt/
13:35:07 <ski> that's awkward to say out aloud
13:35:14 <monochrom> I also found that the SQL standard specifies that SQL should be pronounced S Q L
13:35:16 <ski> (what monochrom said)
13:35:29 <Twey> Or /ɡadət/ if I'm feeling slow :þ
13:35:32 <ski> monochrom : not "sequel", then ?
13:35:37 <monochrom> no
13:35:41 <whatsup159951> thanks a lot ;)
13:35:59 * ski has always pronounced it "ess que ell"
13:36:28 <tafryn> I'm having some dificulty resolving the error that the above paste returns. How do you deal with ambiguous type variables?
13:36:59 <ski> generally by removing the ambiguity
13:37:00 <Twey> I once had a computing teacher try to tell me that ‘Sequel’ is Microsoft's name for their SQL implementation
13:37:12 <Twey> tafryn: Tag the offending variable with an explicit type
13:37:24 <ski> or use `asTypeOf'
13:37:25 <Twey> Oh, that's more of a conflict than an ambiguity
13:37:36 <Twey> :t ((^ 2), floor, sqrt)
13:37:37 <lambdabot> forall a a1 b a2. (Num a, RealFrac a1, Integral b, Floating a2) => (a -> a, a1 -> b, a2 -> a2)
13:38:09 <Twey> Something cannot be both Integral and RealFrac/Floating
13:38:15 <monochrom> fromIntegral . (^2) . floor . sqrt
13:38:24 <monochrom> because of floor
13:38:25 <ski> s/floor/fromIntegral . floor/
13:38:46 <Twey> :t (**)
13:38:47 <lambdabot> forall a. (Floating a) => a -> a -> a
13:38:53 <Twey> :t (^^)
13:38:53 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
13:39:09 <Twey> Hmph, I thought there was an Integral a => a -> a -> a one
13:40:21 <Twey> Or even a Num a => a -> a -> a
13:40:43 <ski> @type (^)
13:40:43 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
13:41:07 <Cale> To have a potentially fractional exponent, the base needs to be able to represent (or approximate) irrational numbers.
13:41:17 <Cale> because 2^(1/2) is irrational
13:41:26 * edwardk waves hello.
13:41:38 <Cale> hello
13:41:45 <ClaudiusMaximus> @src Real
13:41:45 <lambdabot> class  (Num a, Ord a) => Real a  where
13:41:45 <lambdabot>     toRational      ::  a -> Rational
13:41:46 <tafryn> ski et. al.: Thanks.
13:41:49 <ski> lo edwardk
13:41:59 <edwardk> cale: sorry we never got a chance to meet up while i was lurking north of the canadian border
13:42:22 <Cale> edwardk: Yeah, sorry about that too. I'm not very mobile :)
13:42:24 <edwardk> preflex: xseen roconnor
13:42:25 <preflex>  roconnor was last seen on freenode/#haskell 4 hours, 35 minutes and 7 seconds ago, saying: apparently static libraries build with GHC are not portable and depend on some sort of gconv nonsense >:(
13:42:44 <Cale> Hopefully at some point I'll finish learning to drive and get a proper license
13:42:46 <edwardk> @tell roconnor i have a cute little analogue to shift/reset for indexed store.
13:42:47 <lambdabot> Consider it noted.
13:43:21 * ski tries to pry over edwardk's shoulder
13:43:40 <edwardk> yeah anand mentioned something about the fact you never got around to that. =) no worries. had i known i would have dragged wren up your way and gone from there ;)
13:44:29 <edwardk> ski: came about while trying to investigate what a callCC analogue for my Discont comonad transformer should be
13:44:53 <edwardk> still not 100% satisfied with that, but the shift/reset clone are pretty straightforward
13:44:56 <d7> I need to form 2 way mappings between datatypes
13:45:03 <companion_cube> i read "discount comonad"
13:45:06 <d7> What's the right way to do that?
13:45:35 <ski> edwardk> @src Discont
13:45:50 <d7> Like I have a http.enumerator's Case Insensitive bytestring vs a Snap.Types Case Insentitive bytestring
13:46:12 <edwardk> newtype DiscontT s w a = Discont (w s -> a) (w s)
13:46:26 <d7> Is there a nice way to describe this?
13:46:49 <edwardk> as opposed to newtype StoreT s w a = StoreT (w (s -> a)) s
13:47:00 <edwardk> it is basically Store (w s) a
13:47:10 <ski> *nod*
13:48:34 <edwardk> ski: let me hpaste an email i sent out about it the other day, one sec.
13:48:38 <edwardk> @hpaste
13:48:38 <lambdabot> Haskell pastebin: http://hpaste.org/
13:49:05 <hpaste> edwardk pasted “for ski” at http://hpaste.org/47920
13:49:29 <edwardk> hopefully that is clearer than what i can cram through the eye of the irc needle
13:51:15 <edwardk> (i don't have the actual code here, but i at least had the email handy)
13:52:50 <edwardk> i keep meaning to package up an indexed (co)monad package that includes those. i have code, but its pretty icky right now
13:53:47 <edwardk> i did like the label and break function in that email though, they together are much nicer than the current rank-1 compromise on the type of callCC
13:57:39 <ski> edwardk : generally i think what you called `label' is easier to work with than `callCC'
13:57:58 <edwardk> yeah
13:58:05 <ski> i mean, the continuation is already not doing continuation effects, so why inject it into `Cont' ?
13:58:19 <ski> (same with `shift')
13:58:56 <edwardk> well, moreover it needs to be a forall b. Cont r b  which takes you into rank 3 territory. using break to return from the 'label' moves that to the usage site, meaning the type can be rank-1
13:59:00 <ski> or i suppose, *especially* regarding `shift'
13:59:39 <ski> for `callCC' you want an easy way to abort the computation, either with the continuation `callCC' gives, or an extra primitive
14:00:02 <ski> .. which i suppose is your `break', now that i look at it
14:00:05 <edwardk> i'm looking for a nice way to rephrase a call-with-current-value as a form of 'continue from back at this label with this state instead' combinator
14:00:14 <edwardk> yep
14:00:14 <alfa_y_omega> callCC should be renamed to GotoCC, it's Goto with Current Continuation.
14:00:34 <alfa_y_omega> so, programmers will understand it better.
14:00:39 <ski> alfa_y_omega : no, since it duplicates the current continuation
14:00:44 <edwardk> alfa: well, the issue is at the use site, its a goto, not at the current continuation capture point.
14:01:11 <alfa_y_omega> many programmers assume that every call has return
14:01:20 <alfa_y_omega> CallCC hasn't return.
14:02:18 <ski> edwardk : SML/NJ uses   val callcc : ('a cont -> 'a) -> 'a  val throw : 'a cont -> 'a -> 'b
14:02:22 <edwardk> yeah
14:02:31 <edwardk> but the names collide pretty badly in the haskell world ;)
14:02:35 <ski> @src Cont callCC
14:02:36 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
14:02:48 <ski> alfa_y_omega : note how `c' is used *twice* there
14:03:02 <monochrom> no, "call with current continuation" is right
14:03:04 <ski> so it's not just "Goto with Current Continuation"
14:03:15 <edwardk> callcc is my label, and throw is my break
14:03:31 <ski> edwardk : yeah, i just wanted to draw the analogy of the types
14:03:31 <monochrom> since "callCC f" is really "call f, give it the current continuation"
14:03:38 <edwardk> yep
14:03:48 <monochrom> it is inside f that may do the "goto"
14:04:41 <ski> alfa_y_omega : a call to `callCC' can return, it's a call to the captured continuation which doesn't return
14:04:41 <edwardk> monochrom: when is tarted writing that email i used 'goto' as the name for break, but it had the wrong appearance.   label $ \foo -> do ..... ;  goto foo () -- is returning from the block you label.
14:04:52 <edwardk> so it acts more 'break'-like or return-from like
14:04:56 <edwardk> hence the name
14:06:38 <edwardk> in the indexed store comonad case i'm aiming for something closer to unlabel $ \foo -> .... continue foo (alternate state)
14:06:48 <ski> alfa_y_omega : you could have a   val phi : ('a cont -> 'b) -> ('b cont -> 'a)  primitive, which wouldn't duplicate the current continuation ..
14:07:19 <edwardk> or loop rather than unlabel
14:08:30 <shachaf> Is there a SetBy/MapBy type that can take a comparison function instead of using Ord?
14:09:04 <edwardk> shachaf: not as such, but you can make one with reflection ;)
14:09:15 <ski> you could make one with existentials, i think
14:09:34 <Cale> It's hard to compare things with something out of an existential
14:10:03 <Cale> That's a good example of something which seems like it'd be nice to have dependent types for.
14:10:06 <ski>   makeSetBy :: (a -> a -> Ordering) -> exists set_a. {empty ;; set_a,...}
14:10:16 <ski> s/;;/::/
14:10:27 <edwardk> newtype OrderedBy s a = OrderedBy a; instance Reifies s (a -> a -> Ordering) => Ord (OrderedBy s a) where compare = ....;        then use a Set (OrderedBy s a) -- inside of a scope where s is bound using reify on your function
14:10:56 <Cale> ski: But then how do you perform any operations on those sets? You need evidence that the element you're trying to insert (say) has the same type as the elements already in the set.
14:11:00 <Cale> hmm
14:11:06 <edwardk> its a pretty simple usecase for the reflection lib, since the dependent type can be used according to a stack discipline
14:11:14 <ski> Cale : `makeSetBy' returns a record that contains all the operations
14:11:36 <Cale> ski: Yeah, but can you actually use insert? Its type seems to make it useless.
14:11:40 <edwardk> ski: yes, but the above can be used to work with stock haskell sets.
14:12:02 <ski>   makeSetBy :: (a -> a -> Ordering) -> exists set_a. {empty :: set_a,insert :: a -> set_a -> set_a...}
14:12:21 <edwardk> ski: you really don't want to use the existential there
14:12:33 <edwardk> how can i call any of those methods on any a's i have lying around?
14:12:38 <edwardk> ah
14:12:45 <edwardk> i see how you wrote one into the record
14:13:07 <ski> it's uglier than SML functors, but i think it works
14:13:19 <edwardk> schachaf: assuming you don
14:13:37 <edwardk> don't want to invent a new set type, read http://comonad.com/reader/2009/clearer-reflection/ and use Ord instead of Monoid from the example
14:13:41 <monochrom> it's easier to just newtype
14:14:11 <edwardk> monochrom: assuming you know the ordering at compile time and don't need anything from your environment
14:14:27 <edwardk> if your ordering depends on stuff from the environment then you need the extra power given there
14:14:38 <monochrom> but I want to learn the reflect-reify pair anyway
14:14:41 <Cale> and probably more sensible to newtype as well, in that you don't end up accidentally mixing up different orderings
14:15:09 <ski> Cale : you can't mix them, with the `makeSetBy'-approach
14:15:22 <ski> (that's sortof the point)
14:16:36 <Cale> yeah
14:17:13 <ski> (of course, i suppose it would be easier to use the above as `makeSetBy :: (a -> a -> Ordering) -> exists set_a. SetOf set_a a *> ()', for a suitable class `SetOf')
14:17:30 <Cale> Oh, I see, in the Reifies way, you use the type s to represent your comparator
14:17:33 <parcs> :t \x -> case x of "" -> ()
14:17:34 <lambdabot> [Char] -> ()
14:17:44 <edwardk> cale: yep
14:17:51 <edwardk> cale: that lets it close over some part of the environment
14:17:57 <parcs> :t fromString
14:17:58 <lambdabot> Not in scope: `fromString'
14:18:12 <ski> @type read
14:18:13 <lambdabot> forall a. (Read a) => String -> a
14:18:16 <ski> @type reads
14:18:16 <lambdabot> forall a. (Read a) => String -> [(a, String)]
14:18:24 <ski>   reads :: Read a => ReadS a
14:18:30 <monochrom> does s stand for "signature", "sort"?
14:18:33 <ski>   type ReadS a = String -> [(a,String)]
14:18:49 <edwardk> monochrom: stands for 'oleg used that character' ;)
14:18:59 <ski> > (reads :: ReadS Int) "945"
14:19:00 <lambdabot>   [(945,"")]
14:19:04 <Cale> http://www.pps.jussieu.fr/~mellies/RandomWalkDimeresFifty.html
14:19:04 <monochrom> like "the signature of an algebra', even "the signature of an ML structure"
14:19:47 <edwardk> basically all its doing is turning a stableptr into a list of ints that it can serialize into a type, then playing games to avoid leaking it
14:23:11 <ion> @let love = (<3)
14:23:12 <lambdabot>  Defined.
14:23:27 <thoughtpolice> ah reflection, such an intriguing and underused library. that paper of oleg's is one of my favorites, although i don't remember all the details.
14:23:39 <ion> @let symbolOriginatingFromFemaleAnatomyAndNotTheBloodPumper = (<3)
14:23:40 <lambdabot>  Defined.
14:24:17 <edwardk> the implementation has had to change about 3-4 times to keep up with changes in ghc, but it has been worth maintaining =)
14:24:30 <edwardk> the current version should be pretty robust against compiler changes
14:24:35 <monochrom> @let x ♥ y = show x ++ " loves " ++ show y
14:24:36 <lambdabot>  Defined.
14:24:47 <monochrom> > 5 ♥ [5]
14:24:49 <lambdabot>   "5 loves [5]"
14:25:04 <c_wraith> did I miss a surprise extra valentines day?
14:25:18 <monochrom> no
14:25:21 <shachaf> @check \x -> show (text x) == x
14:25:21 <lambdabot>   "OK, passed 500 tests."
14:25:32 <Cale> offtopic: http://i.imgur.com/PYMck.png
14:25:55 <monochrom> hehe
14:26:03 <monochrom> it's on topic
14:26:07 <monochrom> @quote launch
14:26:07 <lambdabot> astrolabe says: I guess missile launching would have to be in IO
14:26:20 <monochrom> IO detected!
14:27:04 <shachaf> Pah, Starcraft? Everyone knows the message is "Warning: Nuclear missile launched"
14:27:16 <c_wraith> not in starcraft 1
14:27:21 <shachaf> No, in Red Alert 2.
14:27:33 <c_wraith> who's ever heard of that game?
14:27:39 <monochrom> I
14:28:00 <shachaf> I
14:28:08 <monochrom> In fact, I have C&C the first decade so I have it
14:28:10 <copumpkin> dons: nice view from your office :)
14:28:29 <shachaf> In fact, I too have C&C the first decade so I have it
14:29:04 <shachaf> That was perhaps the best C&C game.
14:29:06 <monochrom> > рutStrLn "IO launch detected"
14:29:07 <lambdabot>   IO launch detected
14:29:33 <shachaf> @ahoy рutStrLn
14:29:33 <lambdabot> "\209\128utStrLn"
14:29:47 <monochrom> hehe busted
14:30:05 * shachaf 's terminal renders that pseudo-p slightly differently.
14:30:16 <shachaf> > putStrLn "<IO ()>"
14:30:17 <lambdabot>   <IO ()>
14:30:29 <ion> It’s the cyrillic er.
14:30:52 <ion> My font renders them identically. I guess it’s DejaVu Mono.
14:30:56 <Eduard_Munteanu> "P" ? Is it a different character ?
14:31:31 <monochrom> > 'р' == 'p'
14:31:32 <lambdabot>   False
14:31:35 <monochrom> \∩/
14:31:39 <Eduard_Munteanu> Heh.
14:31:44 <dons> copumpkin: yeah, its not bad
14:31:44 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
14:31:49 <shachaf> monochrom: A couple of months ago I tried to play RA2 online and found almost no one there. Does anyone still play it?
14:32:02 <Eduard_Munteanu> AFAIK, they look the same, in Latin, Greek and Cyrillic script
14:32:08 <monochrom> no one plays it online
14:32:16 <Eduard_Munteanu> (the uppercase one I mean)
14:33:42 <shachaf> And offline?
14:33:55 <monochrom> I don't know, but should be a few
14:34:26 <monochrom> > putЅtrLn "another one"
14:34:28 <lambdabot>   eno rehtona
14:34:40 <shachaf> That pseudo-S looks weird in this font.
14:34:55 <shachaf> It looks like it's one pixel off from 'S'.
14:35:05 <shachaf> @show putЅtrLn
14:35:06 <lambdabot> "put\208\133trLn"
14:35:49 <ion> shachaf: ITYM that pseudo-Ѕ matches the other pseudo letters better than the real Ѕ.
14:36:50 <shachaf> That letter doesn't even exist in Russian.
14:37:20 <parcs> in what package is Text.PrettyPrint.HughesPJ located?
14:37:37 <ion> Dze (S s; italics: S s) is a letter of the Cyrillic alphabet, used in the Macedonian language to represent the voiced alveolar affricate /dz/, pronounced like ‹ds› in "pods".
14:37:44 <ion> So it seems. :-)
14:37:50 <monochrom> parcs: "pretty"
14:38:13 <shachaf> @hoogle Text.PrettyPrint.HughesPj
14:38:13 <lambdabot> module Text.PrettyPrint.HughesPJ
14:38:15 <shachaf> Enlightening.
14:38:33 <monochrom> #haskell > @hoogle
14:38:35 <shachaf> (But the web interface to Hoogle would've been more useful.)
14:38:45 <shachaf> #haskell Text.PrettyPrint.HughesPj
14:38:54 <monochrom> "pretty"
14:39:15 <shachaf> #haskell (a -> b) -> [a] -> [b]
14:39:21 <monochrom> map
14:39:26 <shachaf> #haskell forall a. a
14:39:31 <hpc> liftM2
14:39:32 <monochrom> Wow
14:40:09 <shachaf> @hoogle forall a. a
14:40:09 <lambdabot> Prelude undefined :: a
14:40:10 <lambdabot> Test.QuickCheck.Batch bottom :: a
14:40:10 <lambdabot> Data.Function fix :: (a -> a) -> a
14:40:13 <monochrom> should have said "the impossible has happened"
14:40:51 <monochrom> no, should have said "processing... processing..."
14:42:39 <hpc> @hoogle IO ()
14:42:40 <lambdabot> Network.BSD endHostEntry :: IO ()
14:42:40 <lambdabot> Network.BSD endNetworkEntry :: IO ()
14:42:40 <lambdabot> Network.BSD endProtocolEntry :: IO ()
14:42:52 <hpc> whoa, they do exist
14:43:07 <hpc> (functions with that type)
14:43:19 <companion_cube> not functions, values !
14:43:24 <hpc> lol
14:43:35 <parcs> man, the pretty printing library is so simple, yet so powerful
14:45:48 <parcs> and its also 14 years old
14:45:50 <parcs> :P
14:46:38 <ddarius> @hoogle isBottom
14:46:38 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
14:46:56 <hpc> woo halting oracle!
14:47:57 <monochrom> I knew reflect-reify cannot be done in pure haskell unless a powerful monad is used. you do unsafePerformIO
14:50:18 <edwardk> monochrom: sure, to allocate the stableptr.
14:50:52 <edwardk> monochrom: if you want to use a more limited type, like lists of serializable things, or something you can serialize to them, then you can get by without the io component behind the scenes.
14:51:29 <edwardk> monochrom: but the api is convenient, and the quantifier keeps you from noticing that anything hinky is going on
15:02:23 * ClaudiusMaximus tries to find a recurrence relation for jacobian matrices; because 'ad' kinda blows up when i use it on (iterate f x !! 1e6)
15:03:42 <ion> claudiusmaximus: The solution is moar hardware.
15:05:28 <ClaudiusMaximus> ion: i already moved my swap to sd-card for less lagginess...
15:05:44 <rekahsoft> hi all..was wondering how i would speed up recursive functions in haskell..specifically i was just doing lame example functions while fiddling with haskell
15:06:52 <ion> claudiusmaximus: Try compressed swap on SD card. :-)
15:07:09 <kmc> i like compressed swap on RAM
15:07:17 <ski> rekahsoft : depend on what the function does ..
15:07:18 <ion> That’s nice, too.
15:07:18 <kmc> rekahsoft, can you put your example on hpaste.org?
15:07:42 <rekahsoft> lol just wast putting a past up now
15:07:46 <ion> Compressed swap in RAM, falling back to compressed swap on disk or equivalent.
15:08:42 <rekahsoft> http://pastebin.com/wRkK0Jwa
15:08:44 <mauke> The paste wRkK0Jwa has been copied to http://hpaste.org/47921
15:09:03 <ski> mauke++
15:09:06 <ben> mauke is the best #haskell bot
15:09:30 * ben says fibzipWithfibtailfib really fast
15:09:45 <ski> rekahsoft : "Don't do it again"
15:09:48 <shachaf> @vixen Is mauke the best #haskell bot?
15:09:48 <lambdabot> Ooh, functional programmers are so hot!
15:10:02 <rekahsoft> so in lisp/scheme i would use an accumilator to speed this up..just so i don;t overload the stack
15:10:12 <kmc> rekahsoft, the problem here is not Haskell, it's the algorithm
15:10:26 <kmc> you're recomputing lots of values of this function
15:10:40 <ski> rekahsoft : i.e. avoid recomputing results of subcomputations what you've already computed
15:10:43 <kmc> fib 10 = fib 9 + fib 8; fib 9 = fib 8 + fib 7
15:10:44 <rekahsoft> yes yes i figured..haskell is a little different to what i'm used to so i am still getting comfortable with it
15:10:50 <kmc> fib 8 gets computed twice
15:10:58 <ben> This would be as bad in C too
15:11:01 <kmc> that's an exponential slowdown, it will dwarf anything about accumulators etc
15:11:02 <rekahsoft> still don't get how nothing has state and these monad things :P lol
15:11:12 <ben> Not important for fib :)
15:11:15 <kmc> don't worry about "monad", that's just the name of a generic API to lots of different things
15:11:20 <kmc> rekahsoft, take a look at http://hackage.haskell.org/package/data-memocombinators
15:11:24 <ski> rekahsoft : accumulators work fine .. as does an infinite list
15:11:28 <kmc> this lets you memoize function results without explicit state
15:11:29 <ion> You don’t get comfortable with Haskell. Haskell may choose to be benevolent toward you.
15:11:36 <kmc> http://hackage.haskell.org/package/MemoTrie is similar
15:11:37 <ski> rekahsoft : and memoization in general, as kmc says
15:11:44 <companion_cube> is there any project to give an alternative to monads for IO management? like clean's uniqueness typing ?
15:11:45 <ion> It helps if you give it praise.
15:11:57 <companion_cube> (on which i should read)
15:12:08 <rekahsoft> oo i figured you couldn't do memozation in haskell since there was no state...but i guess if you use an infinite list it would work
15:12:21 <kmc> rekahsoft, or an infinite trie, as those libraries do
15:12:21 <ion> @hoogle State
15:12:21 <lambdabot> module Control.Monad.State
15:12:21 <lambdabot> Test.HUnit.Base data State
15:12:21 <lambdabot> Test.HUnit.Base State :: Path -> Counts -> State
15:12:25 <kmc> (lists suck for lookup)
15:12:40 <kmc> rekahsoft, also there are plenty of ways to get honest mutable state in Hasklel
15:12:42 <rekahsoft> what if i did fib 1000000 then tho?..wouldn't it end up with a list 10000000 long? thus filling up memory?
15:12:46 <aa_> hi I'm a total newbie and I just wrote a program :) http://paste.pocoo.org/show/414021/ I am havin gtrouble explaining it
15:12:48 <kmc> yes
15:12:55 <ski> > fix $ \fibs0 @ ~(_:fibs1) -> 0 : 1 : zipWith (+) fibs0 fibs1  -- rekahsoft,infinite list
15:12:55 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:13:03 <aa_> does print return a function?
15:13:11 <kmc> no, it returns an IO action
15:13:14 <kmc> :t print 3
15:13:15 <lambdabot> IO ()
15:13:29 <kmc> companion_cube, they are not alternatives.  you might implement the IO type using uniqueness types and still implement the monad API
15:13:39 <aa_> kmc oh, and an IO action can be main?
15:13:42 <ion> kmc: He asked whether print returns a function, not whether print 3 returns a function. Depending on which he meant, the answer is yes or no.
15:13:51 <aa_> no I meant print
15:13:53 <kmc> main must be an IO action
15:13:59 <companion_cube> and conversely, could we do IO another way than monadic ?
15:13:59 <ion> :t print
15:14:00 <lambdabot> forall a. (Show a) => a -> IO ()
15:14:06 <aa_> something like String->(String->Something)
15:14:11 <kmc> when i hear "does f return A" i interpret as "does the type of f unify with b -> A"
15:14:12 <ion> a -> IO () is a function. You apply it to an a and you get an IO action.
15:14:29 <aa_> sorry for the confusion
15:14:39 <ben> oh come on you guys you're just being even more confusing now!!
15:14:42 <parcs> rekahsoft: that's what memoization is: a exchange of memory for speed.
15:14:47 <kmc> (IO T) is not a function type
15:15:07 <ben> 'You need an equation for main that defines main as an IO action. print "hello" is an IO action, so all is well.'
15:15:21 <aa_> ok, so main must be an IO action
15:15:24 <ski> companion_cube : also, in case you wonder, you'd still have a use for `IORef's and `STRef s's, if you have uniqueness typing -- e.g. Mercury has both <http://www.mercury.csse.unimelb.edu.au/information/doc-latest/mercury_library/store.html>
15:15:24 <kmc> yes
15:15:29 <aa_> and print returns one
15:15:37 <ski> yes
15:15:41 <aa_> so my program makes perfect sense :)
15:15:48 <kmc> yay :)
15:15:52 <aa_> thanks guys
15:16:00 <ben> You could load it in, uh, ghci if you're using ghc
15:16:04 <ben> and use :t to find out types of stuff
15:16:10 <kmc> companion_cube, you could do IO exactly the way it's done now, but fail to notice that IO is an instance of Monad
15:16:16 <kmc> does that count as "not monadic" or no?
15:16:23 <ben> @type print
15:16:24 <lambdabot> forall a. (Show a) => a -> IO ()
15:16:29 <ben> :t print "hello"
15:16:30 <lambdabot> IO ()
15:16:31 <ben> \o/
15:16:40 <ski> companion_cube : we could use dialogue-style I/O, as Haskell did before monads ..
15:16:43 <kmc> that is, you could have «(>>=) :: IO a → (a -> IO b) → IO b» and not worry about whether this could generalize
15:16:51 <aa_> ghci is great, so :t anything
15:16:53 <companion_cube> kmc: no, it would still be monadic if trivially isomorphic to a monad
15:16:58 <ski> companion_cube : or CPS I/O
15:17:00 <ben> yeah
15:17:07 <aa_> that should be on the front page
15:17:11 <ben> If you say :load yourhaskellfile.hs you can then say :t hello
15:17:31 <shachaf> > рrint "hello"
15:17:32 <lambdabot>   "hello"
15:17:49 <kmc> companion_cube, i claim that I can write a Monad instance for almost any implementation of IO that you give me
15:17:50 <ion>   "hello"
15:17:51 <ben> evil :(
15:17:53 <kmc> i'm not sure if that's true or not
15:17:54 <ski> companion_cube : `main :: Answer' defined in terms of `end :: Answer; putChar :: Char -> Answer -> Answer; getChar :: (Char -> Answer) -> Answer; ...'
15:18:12 <companion_cube> ski: is this CPS IO ?
15:18:14 <ski> yes
15:18:23 <companion_cube> neat
15:18:31 <shachaf> (>>=) IO is also CPS IO.
15:18:38 <kmc> all monads are continuation-passing style, in a sense
15:18:39 <kmc> yeah
15:18:44 <shachaf> You just pass the continuation to >>= instead of to the action.
15:19:01 <companion_cube> State monad really is CPS composition, right ?
15:19:01 <ski> @type cont . (>>=)  -- see ! CPS ! :)
15:19:02 <lambdabot> forall a (m :: * -> *) b. (Monad m) => m a -> Cont (m b) a
15:19:13 <kmc> you can read (>>=) as "execute this action with this continuation"
15:19:25 <kmc> :t cont
15:19:26 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
15:19:34 <ski> shachaf : you could define `type IO = Cont Answer' to get the monad, yes
15:19:53 <shachaf> ski: You can do that for any monad, in fact. :-)
15:20:04 <ski> yeah, that's the point :)
15:20:24 <ski> @hoogle Monad m => ((a -> m r) -> m r) -> ContT r m a
15:20:24 <lambdabot> Control.Monad.Cont ContT :: ((a -> m r) -> m r) -> ContT r m a
15:20:29 <ski> @type ContT
15:20:30 <lambdabot> forall a (m :: * -> *) r. ((a -> m r) -> m r) -> ContT r m a
15:20:33 <aa_> so, is it reasonable to do a type and then a few functions for that type and have a program that does something, I mean is that a reasonable pattern?
15:20:44 <ski> oh, `Cont' is hidden, but not `ContT' ?
15:20:50 <ski> @type ContT . (>>=)
15:20:51 <lambdabot> forall a (m :: * -> *) r. (Monad m) => m a -> ContT r m a
15:21:02 <shachaf> "Cont" doesn't even exist anymore, does it?
15:21:15 <shachaf> @ty cont
15:21:16 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
15:21:25 <ski> companion_cube : the `State s' monad isn't CPS anymore than any other monad
15:21:44 <kmc> shachaf, you mean in mtl 2.0?
15:21:54 <companion_cube> hmmm
15:22:03 <kmc> i guess (Cont r) is a synonym for (ContT r Identity)
15:22:28 <shachaf> Right. I mean the value constructor Cont, not the type constructor (alias).
15:22:35 <kmc> oh
15:23:28 * ski wants both `newtype Cont r a = MkCont ((a -> r) -> r)' *and* `newtype Cont r a = ContFromContT (ContT r Identity a); newtype ContT r m a = MkContT ((a -> m r) -> m r)' ..
15:26:46 * edwardk tunes in to see ski's Cont rant
15:27:26 <dobblego> Cont (\me -> me too)
15:27:27 <edwardk> rekahsoft: there is also 'representable-tries' but it builds on a bit more than MemoTries ;)
15:28:00 <edwardk> (otoh, its more useful if you need to build a lot of closely related tries, because you can adjust single elements of the result)
15:28:06 <shachaf> newtype Cont x y = MkCont x
15:28:10 <shachaf> Wait, I missed a letter there.
15:29:29 <edwardk> Cont r = ContT r Identity these days
15:29:32 <ski> edwardk : i'd like to be able to have multiple `newtype'-definitions of a single type, as long as the compiler can see that they are isomorphic
15:30:09 <edwardk> i'd be nice to be able to deconstruct the Cont like it was a real constructor, but meh
15:30:15 <ski> edwardk : that way we can have both insanely-nested `newtype'-wrappings, for generality, *and* a simple interface for the common uses
15:30:24 <edwardk> *nods*
15:31:57 <ddarius> ski: Implement it.  Also, franka had some work that may possibly be relevant.
15:32:55 * shachaf is annoyed at how inconvenient newtypes are to use.
15:33:11 <shachaf> It seems that in most of the cases that people use type aliases, they just use them because newtypes are too much of a hassle.
15:33:20 <dobblego> shachaf: have you seen the newtype package?
15:33:48 * mgsloan was just talking to djahandarie about that in person :D
15:33:52 * ddarius usually uses newtypes when he needs what newtypes provide.
15:34:01 * ddarius rarely uses 'type' except for abbrevation.
15:34:15 <shachaf> Things like type FooId = String, type BarId = String are pretty common.
15:34:20 <kmc> yes, that's lame
15:34:23 <shachaf> type Port = Int and what not.
15:34:43 <ski> shachaf : <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.3.5> would be nice to have in GHC
15:34:51 <kmc> it amuses me that UNIX does not even provide "typedef int file_descriptor_t"
15:36:27 <shachaf> mgsloan: You're at that Oregon thing too?
15:36:40 <mgsloan> yup yup :D it's been quite good so far
15:36:45 * shachaf feels left out.
15:36:52 <companion_cube> what if newtype was just a type alias, but with different typeclass instances ? and writing   f :: Blah and f :: Foo   would actually make a difference in the choice of the typeclass ?
15:37:08 <ddarius> shachaf: Most people aren't at the Oregon thing.  They are the excluded minority.
15:37:16 <kmc> that would be a disaster companion_cube
15:37:22 <mgsloan> aww :/ yeah, there aren't /that/ many haskellers here
15:37:28 <kmc> type inference is spooky action at a distance
15:37:35 <mgsloan> lots and lots of categorical / logicies though
15:37:44 <kmc> this is okay because it's either finding the one true principal type, or failing
15:37:46 <pastorn> what Oregon thing?
15:37:52 <c_wraith> summer school, I assume
15:37:53 <mgsloan> http://www.cs.uoregon.edu/Activities/summerschool/summer11/
15:37:58 <ddarius> "categorists" "logicians"
15:38:06 <ski> ddarius : link ?
15:38:08 <kmc> but if you let it decide between two different runtime behaviors, your code will be impossible to understand
15:38:13 <kmc> type classes already have too much of this problem, imo
15:38:20 <companion_cube> aww :/
15:38:45 <ddarius> @google "Inferring Type Isomorphisms Generically"
15:38:47 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.11.2950&rep=rep1&type=pdf
15:38:47 <lambdabot> Title: Inferring Type Isomorphisms Generically
15:39:00 <Vulpyne> I have a possibly dumb question if anyone's familiar with the new hashtables library. If you use mapM_ from Data.HashTable.IO, what happens if you modify the hash you're mapping over?
15:39:12 <mgsloan> ddarius: it's more fun to be  informal with ye who are endowed with such formalness
15:39:14 <ski> ty
15:39:36 <ddarius> mgsloan: "categorical" isn't even a noun.
15:40:08 <mgsloan> true.  What can I say, I'm half trying to understand this lecture on categorical game semantics... (and largely failing)
15:40:33 <ddarius> Game semantics is cute, but I haven't studied it much.
15:43:44 <Vulpyne> Does anyone have any idea regarding my question?
15:43:56 <Anon703> no
15:44:11 <shachaf> Your question isn't very clear.
15:44:32 <Vulpyne> What was unclear about it? It seemed fairly specific to me.
15:44:34 <benmachine> this is why mutable structures are a bad idea :P
15:44:36 * benmachine silly
15:44:44 <Anon703> please repeat the qwestion
15:44:53 <shachaf> Oh, it provides its own mapM_?
15:44:53 <Vulpyne> Repeated question: I have a possibly dumb question if anyone's familiar with the new hashtables library. If you use mapM_ from Data.HashTable.IO, what happens if you modify the hash you're mapping over?
15:44:58 <Vulpyne> Yes, it does.
15:45:20 <Anon703> hmmmm
15:45:22 <c_wraith> Vulpyne: if it doesn't specify, the answer is "undefined" behavior.
15:45:23 <Vulpyne> The documentation doesn't say anything about whether modifying the structure you're mapping over.
15:45:52 <Anon703> how old are you
15:45:59 <Anon703> vulpyne
15:46:05 <Vulpyne> So if you wanted to change something in a way that requires mapping over items, you would have to use toList and then rebuild the entire structure?
15:46:19 <Vulpyne> Why does my age matter?
15:46:36 <benmachine> it doesn't
15:46:40 <Anon703> i dont know please tell me though
15:46:58 <Vulpyne> 31.
15:47:09 <Anon703> oh
15:47:11 <c_wraith> is there a reason you're using a hash table?  Not "is there a reason wanting key/value mapping", but, "is there a reason you can't use an immutable structure?"
15:47:29 <Anon703> c wraith hi
15:47:38 <Vulpyne> Performance is the main reason. It's going to have to do a massive number of lookups and very few changes.
15:47:41 <benmachine> Vulpyne: huh, the source looks odd, it uses unsafeIOToST
15:47:53 <Anon703> hmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
15:48:01 <benmachine> Vulpyne: so what leads you to believe a hashtable would be good for performance?
15:48:27 <Vulpyne> benmachine: I only glanced at it and knew I really wouldn't have much of a clue figuring out that sort of semantic question.
15:48:29 <Anon703> why am i called anon 703 for
15:48:49 <keseldude> it's not so odd... Data.HashTable is written with ST in mind because it (clearly) doesn't need anything more than that
15:48:51 <Vulpyne> benmachine: Well, it's either that or Data.Map. That hashtable library was tested to be faster, which is why I decided to use it.
15:48:55 <keseldude> the IO, as it says, is just convenient
15:49:12 <benmachine> Vulpyne: tested to be faster? well, okay
15:49:17 <Vulpyne> I can explain more about what I'm doing, if that'll help you, but I'm pretty sure I need something similar.
15:49:34 <Vulpyne> This isn't the old hash map thing that came with GHC.
15:49:58 <aavogt> Vulpyne: it would make sense that you could modify existing entries safely
15:50:24 <benmachine> Vulpyne: well, it doesn't answer your question to talk about that, just that using immutable structures makes that sort of question go away :)
15:50:38 <c_wraith> aavogt: the common problem is "what happens when you add or remove an entry during traversal?"  See all the issues with java collections and "fail-fast" iterators
15:50:43 <aavogt> but whether new entries you add will also get mapped doesn't seem to be defined
15:51:01 <Vulpyne> aavogt: What I actually need to do is delete entries.
15:51:07 <poucet> is cairo part of the haskell platform?
15:51:27 <Vulpyne> Hmm.
15:51:32 <benmachine> Vulpyne: so you start mapping at some entry, and during that delete an entry, and you don't want to then meet that entry later in the mapping?
15:51:45 <Anon703> DO MICE CRY
15:51:52 <aavogt> poucet: it's part of gtk2hs, which wasn't in the platform last I checked
15:52:05 <poucet> aavogt: thanks
15:52:05 <Anon703> hmmm
15:52:06 <Vulpyne> Actually, I think the smart thing would be to use it's fold function and generate a list of keys I want to delete and then just delete them.
15:52:10 <Vulpyne> Er, its.
15:52:13 <Anon703> hmmm
15:52:18 <benmachine> that could work
15:52:19 <poucet> aavogt: I thought cairo was a separate package: cairo-0.12
15:52:23 <Anon703> hmmm
15:52:24 <Anon703> hmmm
15:52:25 <Anon703> hmmm
15:52:26 <Anon703> hmmmh
15:52:41 <benmachine> in principle the mapM_ function is typeclass polymorphic and so could really do whatever it wanted
15:52:47 <Anon703> hmmm
15:52:50 <Anon703> hmmmm
15:52:51 <Anon703> hmmm
15:52:52 <Anon703> hmmm
15:52:53 <Anon703> hmmm
15:52:54 <Anon703> hmmm
15:52:55 <Anon703> hmm
15:52:59 <benmachine> @where ops
15:53:00 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
15:53:15 <benmachine> Anon703: please stop repeating useless things
15:53:20 <aavogt> poucet: maybe it is a separate package on hackage, but you'll end up installing gtk2hs to get cairo
15:53:21 <Vulpyne> One for the ignore list. Yeah... I think your initial answer that the behavior is undefined is likely correct in that case.
15:53:26 <Anon703> PLEASE TELL ME WHAT YOUR ON ABOUT !!!!!!!!!!!
15:53:53 <Vulpyne> I can do what I want by generating a list of things I'd like to delete from the hash, and then just deleting them afterwards. Thanks for helping me think it through.
15:53:54 <poucet> aavogt: yeah, having trouble installing it on mac, so installing a new platform version
15:53:58 <poucet> aavogt: please stop spamming
15:53:59 <poucet> whoops
15:54:02 <poucet> Anon703: Please stop spamming
15:54:09 <Anon703> oops
15:54:25 <companion_cube> Anon703: do you like haskell ? cause if you don't, you'll get bored here
15:54:49 <Anon703> i do
15:55:02 <companion_cube> cool
15:55:26 <Anon703> cool
15:55:34 <kmc> don't drink and IRC
15:55:37 <kmc> actually, do
15:55:43 <kmc> but don't expect not to get banned
15:55:59 <Anon703>  so lets talk about somthing diffrent
15:56:11 <aavogt> see #haskell-blah
15:56:13 <kmc> Anon703, why don't you talk to lambdabot
15:56:18 <kmc> @vixen what do you think of this Anon703?
15:56:18 <lambdabot> let's don't talk about that
15:56:22 <companion_cube> :D
15:56:24 <benmachine> Vulpyne: which actual table type are you using?
15:56:43 <Anon703> i find you nice kmc
15:56:49 <companion_cube> don't not imitate kmc and not use anything but double negations
15:57:00 <Anon703> ok
15:57:23 <Anon703> do mice cry
15:57:34 * benmachine giggles at documentation for the HashTable class helpfully telling you of the instances HashTable HashTable, HashTable HashTable, and HashTable HashTable
15:57:45 <Vulpyne> benmachine: The basic one.
15:57:59 <shachaf> > do mice cry
15:58:00 <lambdabot>   maybe
15:58:03 <Anon703> whats the answer
15:58:05 <companion_cube> :D
15:58:10 <kmc> @faq Can Haskell make mice cry?
15:58:10 <lambdabot> The answer is: Yes! Haskell can do that.
15:58:11 <Anon703> i know
15:58:32 <kmc> :t mice
15:58:33 <lambdabot> Not in scope: `mice'
15:58:33 <benmachine> Vulpyne: at a guess, I'd say mapM_ does do what you want
15:58:40 <Anon703> they cant they havent got tear ducts
15:58:55 <benmachine> (but as others have pointed out, it doesn't seem to guarantee that it will do so in future releases)
15:58:56 <kmc> good to know then
15:59:02 <fxr> does xml-enumerate gives any clue about the exceptions? line number for the error etc?
15:59:11 <Vulpyne> benmachine: Interesting.
15:59:16 <Anon703> bye
15:59:23 <Vulpyne> I think generating the list of stuff to delete will be safer though, and I doubt much slower.
15:59:34 <Anon703> BYE
15:59:36 <Anon703> BYE
15:59:38 <Anon703> BYE
15:59:41 <benmachine> sure, doing the obviously correct thing is generally a good idea
15:59:45 <Anon703> BABY
15:59:45 <Vulpyne> I'm going to use this for expiring stuff from the hash, which won't run all that frequently anyway.
15:59:46 <Anon703> ON
15:59:47 <kmc> good bye, don't come back
15:59:49 <Anon703> THE
15:59:52 <Anon703> TREE
15:59:53 <kmc> @where ops
15:59:53 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
15:59:54 <Anon703> TOPS
16:00:09 <shachaf> dobblego?
16:00:14 <Vulpyne> Well, I'm certainly in favor of doing the correct thing. It's just not always obvious to me. :)
16:00:23 <Anon703> see ya
16:00:28 <benmachine> Vulpyne: fwiw I'm going on http://hackage.haskell.org/packages/archive/hashtables/1.0.0.0/doc/html/src/Data-HashTable-ST-Basic.html, which seems to check if a hash is deleted before running the function on it
16:00:30 <dobblego> shachaf: yo
16:00:36 <benmachine> (mapM_ is in there somewhere)
16:00:49 <dobblego> all it took was a yo!
16:01:03 <shachaf> The mighty dobblego yoyo.
16:01:10 <shachaf> yobblego
16:01:14 <Vulpyne> benmachine: Huh... I should have looked at that.
16:01:35 <benmachine> Vulpyne: I say "seems to" because I'm only guessing what recordIsDeleted does and what hashes mean, etc.
16:01:43 <benmachine> *what hashes means
16:01:47 <benmachine> (as in the variable)
16:02:16 <Vulpyne> Yeah. Thanks for looking at it for me. I'm gonna to it the safe way though.
16:02:38 <Vulpyne> Time to go home.
16:02:44 <benmachine> Vulpyne: even when you don't know much about the internal workings of a library, sometimes source can be self-documenting :)
16:11:22 <poucet> installing cairo is really painful :/
16:11:26 <poucet> setup: The program pkg-config version >=0.9.0 is required but it could not be
16:11:26 <poucet> found.
16:12:44 <sethgil> what is this
16:12:56 <sethgil> does anyone know what this is?
16:12:56 <luite> poucet: which platform?
16:13:02 <sethgil> mac os x
16:13:06 <poucet> luite: snow leopard
16:13:09 <sethgil> yeah
16:13:10 <luite> sethgil: an irc channel about the haskell programming language
16:13:26 <sethgil> lion in a few weeks ;)
16:13:42 <sethgil> what's irc?
16:14:13 <sethgil> i just stumbled this website, and i really have no idea what's going on
16:14:39 <benmachine> sethgil: irc is short for internet relay chat
16:14:51 <luite> poucet: hmm, I don't know much about macs... but you have to install the development libraries for cairo, the pkg-config program is a simple program that tells gcc or ghc where to find the libraries for cairo
16:14:55 <benmachine> the 'relay' bit is only there because 'ic' is a ridiculous name >_>
16:15:30 <benmachine> sethgil: hello, we are people who are interested in haskell, some of us are quite good at it
16:15:36 <benmachine> oh
16:15:38 <benmachine> he went
16:17:21 <poucet> luite: Thanks
16:17:43 <monochrom> why do all the trolls come at my dinner time only?
16:18:01 <benmachine> monochrom: because you strike terror into the hearts of evildoers everywhere
16:18:39 <keseldude> I'm sure they plan it out
16:29:05 <ksf> <3 darcs
16:29:43 <ksf> one of its greatest features is just pulling stuff while having unrecorded changes
16:29:48 <ksf> ...because it just works.
16:30:14 <ksf> not to mention the wonderfully transparent lazy pulls
16:30:16 <parcs> doesn't git do the same?
16:30:34 <ksf> change a line, do a darcs diff, and see it pull a handfull of patches.
16:31:02 <ksf> git feels like juggling raw eggs.
16:31:32 <jaj> I never juggled raw eggs so I don't know what that feels like
16:31:42 <kmc> with git you would stash your local changes before merging or rebasing from upstream
16:31:54 <ksf> yep.
16:32:00 <ksf> whereas darcs couldn't care less.
16:32:01 <kmc> ksf, do you mean that it's easy to screw up?
16:32:12 <kmc> because it's pretty hard to screw up permanently in git
16:32:24 <ksf> well, you can always get new eggs.
16:32:25 <sanjoyd> ksf: what happens if you pull with local changes in darcs?
16:32:28 <shachaf> You can pull in git with modified changes as long as they're in different files.
16:32:30 <ksf> but you still have to clean up the mess.
16:32:32 <kmc> you have to understand the object model, not just the pile of commands
16:32:47 <kmc> but fortunately there are only a few types of object, compared to hundreds of commands
16:33:19 <ksf> what I imagine darcs is doing is stash the changes into a patch, apply the rest, then transpose the old patch onto the new tree.
16:33:37 <sanjoyd> That patch might fail.
16:33:52 <ksf> well, yes.
16:34:04 <ksf> then it might unapply the conflicting pulled patches.
16:34:15 <ksf> would have to try.
16:34:32 <ksf> but, and I mean this seriously, I really don't care about learning how to use a vcs.
16:34:39 <sprzybilla> to find the first 24 multiples of 13, why is it take 24 [13,26..] instead of take 24 [13, 12..]   ?
16:35:03 <ksf> I find them useful for collaboration and nothing else.
16:35:13 <Botje> > [13,12 .. 1]
16:35:13 <lambdabot>   [13,12,11,10,9,8,7,6,5,4,3,2,1]
16:35:30 <shachaf> sprzybilla: Because those are the first two elements, and it computes a diff between them to figure out the rest.
16:35:31 <Botje> sprzybilla: the second number (12) is used to give the next element in the range
16:35:39 <shachaf> Hmm, too much VCS talk.
16:35:49 <shachaf> The word I meant to use was "subtract".
16:36:52 <ksf> > let multiples n = iterate (+n) n in take 24 $ multiples 13
16:36:53 <lambdabot>   [13,26,39,52,65,78,91,104,117,130,143,156,169,182,195,208,221,234,247,260,2...
16:37:32 <shachaf> @pl \n d -> enumFromThen n (n+d)
16:37:32 <lambdabot> liftM2 (.) enumFromThen (+)
16:38:11 <sprzybilla> Botje, shachaf: Thanks!
16:41:21 <ksf> > iterate id id <*> []
16:41:28 <lambdabot>   mueval-core: Time limit exceeded
16:41:28 <lambdabot>  mueval: ExitFailure 1
16:42:24 <ksf> that looks fishy.
16:43:20 <ksf> as in "that's unecessarily _|_"
16:45:00 <ksf> and that sholud probably be "iterate (id.) id" to be cromulently senseless.
16:46:01 <ezyang> I'm trying to remember why ($) doesn't interact well with rank-2 polymorphism. Does anyone have a reference?
16:46:39 <ski> @type ezyang
16:46:44 <lambdabot> Not in scope: `ezyang'
16:46:45 <ski> er
16:46:58 <ski> (bad wiring in head)
16:46:58 <ski> @type ($)
16:46:59 <lambdabot> forall a b. (a -> b) -> a -> b
16:47:39 <ski> ezyang : one problem can be trying to instantiate `a' or `b' to polytypes (`ImpredicativeTypes')
16:48:20 <ski> @type runST
16:48:21 <lambdabot> forall a. (forall s. ST s a) -> a
16:48:32 <shachaf> > runST $ return 1
16:48:33 <lambdabot>   1
16:49:16 <ezyang> aggh, I've never understood impredicative types :-(
16:49:30 <kmc> neither does GHC ;)
16:50:06 <kmc> i'm fine with impredicative types in a setting with explicit polymorphism and no inference
16:50:07 <kmc> like System F
16:50:15 <kmc> there it's just passing a ∀-type into a Λ
17:07:05 <pjpj> does anyone know if the author of LeanYouAHaskell chats here?  I would like to thank them for the tutorials- they're excellent.
17:08:45 <c_wraith> pjpj: he does occasionally.  goes by the name BONUS
17:08:55 <ksf> preflex, seen BONUS
17:08:55 <preflex>  BONUS was last seen on #haskell 48 days, 5 hours, 7 minutes and 58 seconds ago, saying: yeah i think that's better as well
17:09:14 <cmccann> emphasis on "occasionally"
17:09:21 <parcs> pjpj: you may thank him by buying his book :)
17:09:41 <cmccann> I've seen him on the Haskell reddit sometimes at times as well
17:09:45 <pjpj> actually I was thinking about sending him some bitcoins.
17:10:22 <ksf> doesn't flattr accept bitcoin donations by now?
17:11:28 <dmwit> preflex: seen BONUS_
17:11:28 <preflex>  BONUS_ was last seen on #haskell 1 year, 191 days, 10 hours, 53 minutes and 41 seconds ago, saying: osaunders_: usually i think it's defined as a function that uses only the stuff it takes as parameters and function application
17:14:39 <parcs> preflex: xseen BONUS
17:14:40 <preflex>  BONUS was last seen on freenode/#haskell 48 days, 5 hours, 13 minutes and 44 seconds ago, saying: yeah i think that's better as well
17:28:25 <poucet> Anyone familiar with Voronoi and Delauney?
17:37:37 <treetrunks> aha!
17:37:43 * treetrunks grins
17:42:20 <_habnabit> Is there a simpler way to write `flip ((flip (compare . snd)) . snd)` ?
17:43:42 <Eduard_Munteanu> @unpl flip ((flip (compare . snd)) . snd)
17:43:43 <lambdabot> (\ b c -> compare (snd b) (snd c))
17:44:01 <_habnabit> 'unpl' ?
17:44:33 <Eduard_Munteanu> It's the opposite of the 'pl' plugin, which turns stuff you type into pointfree-style code
17:44:37 <sipa> @pl \b c -> compare (snd b) (snd c)
17:44:37 <lambdabot> (. snd) . compare . snd
17:44:46 <_habnabit> hah.
17:45:11 <Eduard_Munteanu> I'd use the unpl-ed version, really.
17:45:21 <_habnabit> but flip!
17:45:29 <parcs> i'd use compare `on` snd
17:45:34 <ClaudiusMaximus> :t comparing snd
17:45:35 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
17:46:09 <Eduard_Munteanu> Yeah, I guess that's better.
17:46:17 <parcs> @src comparing
17:46:17 <lambdabot> Source not found. Do you think like you type?
17:46:27 <parcs> :t compare `on` snd
17:46:28 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
17:46:37 <Eduard_Munteanu> @undefine
17:46:46 <Eduard_Munteanu> @src comparing
17:46:46 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
17:46:55 <Eduard_Munteanu> :t comparing
17:46:56 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
17:46:56 <_habnabit> ah, comparing.
17:46:57 <olsner> I think neither of comparing or "on" are in the standard libs
17:47:02 <olsner> (or?)
17:47:05 <ClaudiusMaximus> @index comparing
17:47:05 <lambdabot> bzzt
17:47:45 <Eduard_Munteanu> @index on
17:47:45 <lambdabot> bzzt
17:47:58 <Eduard_Munteanu> @vixen Go bzzt yourself!
17:47:59 <Eduard_Munteanu> :P
17:47:59 <lambdabot> I have a boyfriend, but he likes to watch.
17:49:23 <parcs> >_>
17:50:41 <parcs> so is `comparing` the same thing as `on compare`
17:51:18 <ski> @type comparing
17:51:19 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
17:51:27 <ski> @type (`on` compare)
17:51:28 <lambdabot> forall c a. (Ord a) => ((a -> Ordering) -> (a -> Ordering) -> c) -> a -> a -> c
17:51:36 <ski> @type (compare `on`)
17:51:36 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
17:51:40 <ski> hm, yes
17:51:44 <ski> @type equating
17:51:45 <lambdabot> Not in scope: `equating'
17:52:14 <ski> @let equating :: Eq a => (a -> b) -> (a -> a -> Bool); equating = ((==) `on`)
17:52:14 <lambdabot>  <local>:1:62:
17:52:14 <lambdabot>      Could not deduce (Eq b) from the context (Eq a)
17:52:15 <lambdabot>        ar...
17:52:22 <ski> @let equating :: Eq b => (a -> b) -> (a -> a -> Bool); equating = ((==) `on`)
17:52:24 <lambdabot>  Defined.
17:53:36 <benmachine> on is in Data.Function
17:53:39 <benmachine> comparing in Data.Ord
17:53:40 <benmachine> iirc
17:53:44 <benmachine> @hoogle on
17:53:44 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
17:53:44 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
17:53:45 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
17:53:48 <benmachine> @hoogle comparing
17:53:48 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
17:53:55 <benmachine> olsner: ^
17:55:13 <olsner> benmachine: cool, must've been added since ghc 6.8 or whenever it was I got annoyed at not having those functions :P
17:55:27 <benmachine> mm
17:56:13 <benmachine> been around since 6.10 I think
19:11:25 <kmc> is there some existing library for reading Storable things out of Attoparsec?
19:14:30 <mikeg> kmc: looks like it may even be exported by Data.Attoparsec.Internal
19:15:19 <kmc> ghci won't let me import that module
19:15:51 <kmc> "      it is a hidden module in the package `attoparsec-0.8.1.0'"
19:17:03 <mikeg> Yes, i don't think attoparsec actually exports that module, and i don't see where `storable` is used in other functions
19:17:40 <mikeg> (though you may be able to copy-paste that function if you import necessary stuff from Data.ByteString.Internal)
19:19:53 <kmc> or i can implement it myself with Data.ByteString.Internal
19:20:58 <mikeg> Yeah it looks like Data.Attoparsec.Internal.storable doesn't require other things from Data.Attoparsec.Internal
19:21:54 <kmc> dare i use inlinePerformIO?
19:22:15 <mikeg> well if bos uses it ;)
19:22:53 <ion> :t inlinePerformIO
19:22:54 <lambdabot> Not in scope: `inlinePerformIO'
19:22:58 <ion> @hoogle inlinePerformIO
19:22:58 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
19:23:54 <Eduard_Munteanu> Did that lose its "unsafe"?
19:24:46 <Eduard_Munteanu> (maybe 'inline' means double unsafe :D)
19:24:49 <mikeg> or unsafeUnsafe..
19:24:58 <Eduard_Munteanu> Heh, yeah.
19:25:52 <ion> “The difference of course is that inlinePerformIO is even less safe than unsafePerformIO. While ghc will try not to duplicate or common up different uses of unsafePerformIO, we aggressively inline inlinePerformIO. So you can really only use it where the IO content is really properly pure, like reading from an immutable memory buffer (as in the case of ByteStrings).” http://www.haskell.org/pipermail/haskell-cafe/2007-March/023592.html
19:28:29 <Eduard_Munteanu> I guess inlinePerformIO . return   makes a nice id :P
19:31:23 <aavogt> is there such a thing for haskell http://www.mercury.csse.unimelb.edu.au/information/doc-release/mercury_user_guide/Declarative-debugging.html
19:31:48 <kmc> http://ww2.cs.mu.oz.au/~bjpop/buddha/ ?
19:32:02 <kmc> ion, ah, that makes me feel better about using it.  thanks.
19:32:50 <aavogt> unfortunately, that one seems to be only haskell 98
19:34:11 * aavogt takes a look anyways
19:36:17 <jrope> Hi everyone, how do I change the prompt in ghci so it doesn't show all the modules I have loaded?
19:36:20 <dolio> There are multiple declarative debuggers. Unfortunately, I think they've bit rotted.
19:36:49 <aavogt> jrope: :set prompt >
19:37:02 <jrope> thanks
19:37:10 <kmc> dolio, what is there besides buddha?
19:37:29 <aavogt> you can put it in ~/.ghci to make it permanent
19:42:06 <dolio> kmc: Hat might be one. To be honest I've never investigated the debugging options for Haskell much. But I think the actual author of Buddha once told me there was a declarative debugger for Haskell he thought was better than Buddha.
19:42:06 <aavogt> buddha is rather bitrotten, -package lang to drop,  FiniteMap to change to Map
19:50:38 <aavogt> odd, some ghc used to accept excess leading commas
19:51:01 <aavogt> in export lists. These days it seems only to accept trailing commas before the )
19:54:56 <ski> i usually write like
19:55:04 <ski>   module Foo
19:55:08 <ski>     ( blah
19:55:13 <ski>     , bleh
19:55:15 <ski>     )
19:55:31 <ski> (well, s/)/) where/)
19:56:40 <shachaf> module\nFoo\n(\nblah\n,\nbleh\n,\n)\nwhere\n\n\n\n
19:57:41 <ski> why so many trailing newlines ?
19:58:35 <aavogt> yeah, I do it like shachaf
19:59:04 * ski stares blankly
19:59:30 <aavogt> kmc: this buddha involves c files with error: too few arguments to function ???rts_apply???
20:01:32 * aavogt wonders whether vacuum has some up-to-date code for printing values on the ghc heap to reuse
20:22:10 <mietek> I have a function of type ST s (Game s) which initializes my game state
20:22:36 <kmc> that's not a function
20:23:14 <mietek> ...
20:23:15 <confound> that's your mother
20:23:26 <kmc> anyway, go on
20:23:38 <mietek> I guess it is a constant, in a way
20:23:49 <kmc> it's an ST action
20:23:56 <kmc> or an (ST s) action, to be ultra pedantic
20:24:16 <kmc> it's a constant in a way, but so are functions
20:24:29 <kmc> (+3) is always and forever the unchanging "add 3 to stuff" function
20:24:33 <Cale> (to be a function, it would need to have type  A -> B  for some types A and B)
20:24:33 <aavogt> @hoogle runST
20:24:33 <lambdabot> Control.Monad.ST runST :: ST s a -> a
20:24:33 <lambdabot> Control.Monad.ST.Lazy runST :: ST s a -> a
20:24:33 <lambdabot> Data.Array.ST runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
20:24:49 <mietek> I was thinking about what Cale said
20:24:51 <mietek> Anyway!
20:24:54 <aavogt> @ty runST
20:24:54 <lambdabot> forall a. (forall s. ST s a) -> a
20:25:04 <aavogt> so hoogle lies?
20:25:11 <mietek> It seems to me the type ST s (Game s) is pointful, is it not?
20:25:22 <kmc> pointful?
20:25:23 <Cale> pointful?
20:25:37 <mietek> What exactly is s in that type?
20:25:44 <aavogt> @ty runST (undefined :: ST s (Maybe s))
20:25:45 <lambdabot>     Inferred type is less polymorphic than expected
20:25:45 <lambdabot>       Quantified type variable `s' escapes
20:25:45 <lambdabot>     In the first argument of `runST', namely
20:25:48 <kmc> mietek, it's an uninstantiated type variable, and it has to remain that way
20:25:56 <kmc> ST uses a type system trick to do compile-time safety checking
20:26:11 <kmc> that's why runST is safe and unsafePerformIO isn't, even though they're identical at runtime (with GHC's implementation)
20:26:20 <aavogt> you can't have STRefs escape that way
20:26:20 <Cale> mietek: It's what ensures that you can't just apply runST to that
20:26:43 <Cale> mietek: Because there's (at least potentially) references to mutable state inside the Game s value
20:26:46 <kmc> runST forces its argument to represent a "closed universe" of state
20:27:04 <acfoltzer> the s stands for aweSome way to get rid of dangling pointers
20:27:05 <kmc> the value returned from runST can't refer to the type variable s, or that wouldn't be the case
20:27:21 <aavogt> kmc, Cale what happens if you put the STRef into Dynamic?
20:27:24 <Cale> and if you were able to get that value out of the call to runST, the localised breakage of referential transparency in ST would escape and ruin Haskell globally.
20:27:46 <mietek> Thanks.  This is why I love this channel.
20:27:48 * aavogt supposes that would be an issue if it was allowed
20:28:02 <Cale> aavogt: Can't have a polymorphic instance of Typeable
20:28:17 <ski> aavogt : hoogle strips away too many `forall's
20:28:23 <ski> @type runST
20:28:24 <lambdabot> forall a. (forall s. ST s a) -> a
20:29:16 * kmc looks at Data.Vector.Storable.unsafeFromForeignPtr
20:29:25 <kmc> can I really convert a ByteString to a Vector this easily?
20:29:30 <kmc> will i shoot myself in the foot in some horrible way?
20:35:13 <aavogt> Cale: putting polymorphic values into Dynamic could make sense in other situations, right? (ignoring how difficult it would be to make happen)
20:35:41 <Cale> Yeah, it could be nice in some situations.
20:35:52 <Cale> (though using Dynamic is rare enough in the first place)
20:35:56 <aavogt> sort of like having a data type with -XExistentialQuantification implicitly created and unwrapped
20:49:07 <kmc> is it really this easy
20:49:12 <kmc> ByteString -> Storable Vector
20:49:37 <kmc> just by re-using the ForeignPtr
20:49:56 <kmc> i am almost suspicious; if it were that easy it would already be in the Vector lib
20:52:17 <hpaste> qtplatypus pasted “Non-exhaustive patterns in function sign” at http://hpaste.org/47924
20:52:48 <QtPlatypus> What am I missing in this function?
20:54:37 <kmc> guards are arbitrary boolean expressions
20:54:45 <kmc> GHC doesn't try to analyze them for completeness
20:55:10 <Axman6> maybe using | otherwise = error "um, wut?" would help
20:55:14 <luite> QtPlatypus: you might already know this, but this function is better written as  case compare x 0 of ...
20:55:18 <kmc> sign x = case compare x 0 of { LT -> -1; EQ -> 0; GT -> 1 }
20:55:34 <aavogt> @hoogle signum
20:55:35 <lambdabot> Prelude signum :: Num a => a -> a
20:56:01 <kmc> a naive compiler is going to produce worse output from the code with three independent boolean tests
20:56:01 <aavogt> though maybe you need a round, or fromIntegral in there somewhere
20:56:13 <aavogt> ghc too probably
20:56:14 <Axman6> > let f = (-1) . fromEnum . flip compare 0 in map f [-6,0,10]
20:56:15 <luite> QtPlatypus: if you write it like that, you only do one comparison instead of three, and pattern matches are checked for completeness
20:56:19 <lambdabot>   mueval-core: Time limit exceeded
20:56:22 <Axman6> :\
20:56:22 <kmc> there are in fact types where sometimes none of (x < y), (x == y), and (x > y) holds
20:56:24 <Axman6> > let f = (-1) . fromEnum . flip compare 0 in map f [-6,0,10]
20:56:24 <QtPlatypus> luite: Thanks.
20:56:26 <lambdabot>   [-1,-1,-1]
20:56:29 <kmc> in fact there are types where neither (x == x) nor (x /= x) holds
20:56:30 <Axman6> hmm
20:56:40 <kmc> > let x = 0/0 in (x == x, x /= x)
20:56:40 <Axman6> > map fromEnum [LT,EQ,GT]
20:56:41 <lambdabot>   (False,True)
20:56:41 <lambdabot>   [0,1,2]
20:56:52 <kmc> oh, i'm surprised NaN /= NaN
20:56:57 <kmc> never mind that then
20:57:02 <Axman6> > let f = subtract 1 . fromEnum . flip compare 0 in map f [-6,0,10]
20:57:03 <lambdabot>   [-1,0,1]
20:57:17 <Draconx|Laptop> kmc, well, it's not equal to anything :)
20:57:17 <Axman6> bloody caleskell
20:57:30 <kmc> i thought the rule was that any comparison involving NaN was false
20:57:40 <kmc> cause you can't say that two NaNs aren't equal, either
20:57:51 <Axman6> no, i think it's more that nothing is equal to NaN
20:57:55 <kmc> anyway, floating point makes mathematicians cry
20:57:58 <Draconx|Laptop> no, that "rule" is patently false.
20:58:02 <Axman6> so NaN /= anything = Fasle
20:58:10 <Draconx|Laptop> true, you mean.
20:58:16 <Axman6> uh, yeah
20:59:11 <Saizan> kmc: or make others say that they have fixed division by zero
21:01:02 <cmccann> if memory serves me NaN /= NaN is right in the IEEE spec
21:01:32 * Eduard_Munteanu imagines a headline: "largest supercomputer figures out the answer to a fundamental question: what's 1/0?"
21:01:50 <kmc> supercomputer contemplates where 0.9999… == 1
21:02:04 <cmccann> justified, as mentioned, by interpreting (/=) as (not . (==))
21:02:30 <cmccann> NaN is weird :(
21:04:04 <cmccann> but I think the way it behaves makes sense from a standpoint of "make number-crunching on floats as efficient as possible"
21:04:08 <Draconx|Laptop> kmc, http://i.imgur.com/ph7XB.png is the truth table for all the comparison operators defined in the 1985 version of IEEE 754.  You will notice that there are as many "T" results as "F" under the "Unordered" (NaN) column.
21:04:24 <Eduard_Munteanu> Another interpretation would be comparing NaNs is like substracting them, but then you'd get a NaN (somewhat like "undecidable"), I guess.
21:07:58 <cmccann> I still find it kind of annoying that NaN breaks Ord for floats
21:08:23 <Draconx|Laptop> they should have never been made an instance of Ord.
21:08:24 <kmc> i have a toplevel Bool which is True iff the platform is little-endian
21:08:24 <cmccann> which means that things that only need some arbitrary total ordering are buggy
21:08:27 <kmc> am i going to hell for this
21:08:40 <cmccann> while the Ord instance doesn't even match the actual semantics of floats anyway
21:09:00 <cmccann> kmc, you're going to either heaven or hell
21:09:06 <cmccann> depending on the afterlife's endianness
21:09:07 <kmc> but i won't know which until runtime!
21:09:12 <kmc> :D
21:09:15 <aavogt> kmc: it's going to change at runtime ?
21:09:31 <kmc> there are CPUs which can change endianness
21:09:35 <aavogt> you ought to make it IO Bool
21:09:36 <kmc> but i don't correctly deal with those :/
21:09:38 <kmc> i doubt GHC does either
21:10:04 <kmc> prctl(PR_SET_ENDIAN, PR_ENDIAN_BIG)
21:10:08 * Saizan had one of those bools too
21:11:05 <kmc> for some reason this is in Linux's prctl(2) and not arch_prctl(2)
21:11:26 <kmc> apparently the 64-bit base for a segment register is "architecture-specific thread state" but the endianness is not
21:12:07 <Draconx|Laptop> arch_prctl sounds like a much newer interface.
21:14:15 <kmc> prctl also lets you tell Linux whether to kill your process if a cosmic ray hits its address space
21:19:48 <NotARobot> Anyone know of a modulus operator in this language
21:20:02 * hackagebot air 2011.6.18 - air  http://hackage.haskell.org/package/air-2011.6.18 (JinjingWang)
21:20:07 <ski> @type mod
21:20:08 <lambdabot> forall a. (Integral a) => a -> a -> a
21:20:17 <ski> > 17 `mod` 7
21:20:17 <lambdabot>   3
21:20:23 <ski> > 17 `divMod` 7
21:20:24 <lambdabot>   (2,3)
21:20:41 <NotARobot> Thanks sky
21:20:43 <NotARobot> ski
21:21:02 <ski> @type div
21:21:03 <lambdabot> forall a. (Integral a) => a -> a -> a
21:21:04 <ski> @type divMod
21:21:05 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
21:23:49 * cmccann scratches his head at the ICFP contest being a game with "lambda" in the title, but using combinatory logic instead of lambda calculus
21:24:04 <Eduard_Munteanu> "modulus" for "absolute value" doesn't seem common in English.
21:24:17 <NotARobot> Alright I want to get all the multiple of 3 from 1 to 10... I feel I could do this by filter (`mod`3) [1..10] why can i not do this
21:24:39 <cmccann> NotARobot, because that's not a boolean predicate
21:24:59 <ski> > filter ((0 ==) . (`mod` 3)) [0 .. 9]
21:25:00 <cmccann> Are you expecting it to treat numbers as logical values, i.e. 0 is false, etc.?
21:25:01 <NotARobot> K, the (x) condition requires a boolean return then
21:25:01 <lambdabot>   [0,3,6,9]
21:25:03 * hackagebot miku 2011.6.18 - A minimum web dev DSL in Haskell  http://hackage.haskell.org/package/miku-2011.6.18 (JinjingWang)
21:25:05 <ski> > filter ((1 ==) . (`mod` 3)) [0 .. 9]
21:25:07 <lambdabot>   [1,4,7]
21:25:08 <ski> > filter ((2 ==) . (`mod` 3)) [0 .. 9]
21:25:10 <lambdabot>   [2,5,8]
21:25:45 <NotARobot> Oh, that is cool ski.  I like that a lot
21:25:50 <ski> > partition ((0 ==) . (`mod` 3)) [0 .. 9]
21:25:52 <lambdabot>   ([0,3,6,9],[1,2,4,5,7,8])
21:26:30 <kmc> :t either fail return
21:26:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => Either String a -> m a
21:26:41 <ski> @let d `divides` 0 = True; d `divides` n = n `mod` d == 0
21:26:41 <lambdabot>  Defined.
21:26:58 <ski> > partition (3 `divides`) [0 .. 9]
21:27:00 <lambdabot>   ([0,3,6,9],[1,2,4,5,7,8])
21:27:04 * Eduard_Munteanu wonders why it's common here...
21:27:16 <saterus> cmccann: are you working on the icfp problem?
21:27:25 <cmccann> saterus, sort of
21:27:33 <NotARobot> lambdabot can you explain the forall statement you just put up to me
21:27:34 <cmccann> don't really have much time this weekend :|
21:27:43 <mietek> Is Ix derivable in any way?
21:27:43 <cmccann> but I'm going to try and at least make something
21:27:50 <ski> NotARobot : which of them ?
21:28:13 <NotARobot> ski : forall (m :: etc etc
21:28:20 <ski> @type mod
21:28:21 <lambdabot> forall a. (Integral a) => a -> a -> a
21:28:23 <ski> this means that
21:28:27 <ski>   mod :: forall a. (Integral a) => a -> a -> a
21:28:32 <ski> which is simpler written as
21:28:38 <ski>   mod :: Integral a => a -> a -> a
21:29:04 <NotARobot> TY I believe I understand now
21:29:10 <mietek> Ah, it is!
21:29:19 <ski> and that means that `mod' is a function taking two values of type `a', and returning a value of type `a', for *any* type `a', provided `a' is an integral type (a member of the type class `Integral')
21:29:24 <saterus> cmccann: i'm not really planning on submitting anything, i've just been looking at how to approach it.
21:29:30 <ski> e.g. `Int' and `Integer' are integral types
21:29:37 <ski> NotARobot : ok ?
21:29:45 <NotARobot> si
21:30:26 <ski> NotARobot : so the `forall a. ' part was claiming (explicitly) that this works for *every* type `a'
21:30:41 <ski> NotARobot : in most cases, you can omit the `forall ...' part, though
21:31:25 <ski> mietek : for `data' types with more than one constructor ?
21:32:15 <mietek> ski: for enumerations.
21:32:20 <mietek> Works fine.
21:32:27 <ski> hm, oh right
21:32:40 <ski> not for a single constructor, with arguments in `Ix', then ?
21:32:40 <cmccann> saterus, I tend to suspect that very aggressive strategies will dominate
21:32:41 <mietek> I just didn't expect to have to import Data.Ix (Ix)
21:32:50 <ski> heh
21:33:15 <cmccann> saterus, beyond that I dunno, heh
21:36:13 <saterus> cmccann: i would agree with that. haven't put much thought into the strategies yet, i'm still working on the game representation.
21:37:25 <saterus> cmccann: i'm still trying to figure out how to store the lists of slots when the fields are holding differently typed functions.
21:38:13 <rata_> hi
21:38:22 <NotARobot> hi
21:38:53 <rata_> is there any built-in function like "f Nothing s = error s; f (Just x) _ = x"?
21:39:10 <cmccann> saterus, I'm pretty sure you don't want to give the cards the types they'd have as Haskell functions
21:39:54 <cmccann> if that's what you're implying
21:40:24 <cmccann> you're almost certainly going to want your strategy to include things that are not well-typed in Haskell
21:40:47 <saterus> cmccann: well, yeah. that's what i had been thinking. :)
21:42:01 <cmccann> saterus, I'm not sure if I should tell you WHY I think that's the case or if you should figure it out yourself though :T
21:42:20 <NotARobot> Anyone have a link to a resource of operators?
21:42:32 <NotARobot> Syntax is the issue
21:42:55 <Eduard_Munteanu> @where report   -- maybe this?
21:42:55 <lambdabot> http://www.haskell.org/onlinereport/
21:44:15 <saterus> cmccann: fair enough. i'll think about it some more.
21:45:11 <cmccann> saterus, I suppose that's more in the spirit of the contest and such
21:45:58 <ski> NotARobot : which operators ?
21:46:19 <NotARobot> I found it
21:46:22 <NotARobot> TY
21:46:34 <NotARobot> How do i reply to you directly like that ski
21:46:54 <ski> just write `ski : blah'
21:47:30 <ski> @type fromMaybe
21:47:31 <lambdabot> forall a. a -> Maybe a -> a
21:47:44 <ski> rata_ : you could use `fromMaybe (error s)', i suppose
21:48:00 <NotARobot> ski : Im attempting to modify the statement given to find the odd or even divisible numbers in a given subset
21:48:21 <NotARobot> ski : filter (((1 ==) . (`mod­` 3)) || ((0 ==) . (`mod­` 2))) [0 .. 100] is what I came  up with it doesnt work
21:49:16 <ski> > filter (\n -> 1 == n `mod` 3 || 0 == n `mod` 2) [0 .. 100]
21:49:17 <lambdabot>   [0,1,2,4,6,7,8,10,12,13,14,16,18,19,20,22,24,25,26,28,30,31,32,34,36,37,38,...
21:49:50 <rata_> ski: thanks
21:49:54 <NotARobot> ski : purpose of (\n -> 1 == n
21:49:55 <ski> i'm not sure what you mean by "find the odd or even divisible numbers in a given subset", though
21:49:58 <Eduard_Munteanu> You can use tab-completion
21:50:07 <Eduard_Munteanu> Try    s<tab>
21:50:08 <rata_> ski: I'm thinking now of a good operator name for that
21:50:43 <rata_> maybe ?, like parsec's <?>
21:50:46 <ski> rata_ : maybe `fromJustOrError' ?
21:50:53 <ski> @type fromJust
21:50:54 <lambdabot> forall a. Maybe a -> a
21:51:07 <rata_> no, I want an operator name
21:51:16 <rata_> (infix function I mean)
21:51:25 <ski> ok
21:51:56 <ski> NotARobot : `\n -> ..n..' is the function that if given any input `n', computes `..n..'
21:52:28 <ski> > let good n = 1 == n `mod` 3 || 0 == n `mod` 2  in  filter good [0 .. 100]
21:52:29 <lambdabot>   [0,1,2,4,6,7,8,10,12,13,14,16,18,19,20,22,24,25,26,28,30,31,32,34,36,37,38,...
21:52:30 <Axman6> > map (\n -> n * n) [1..10]
21:52:31 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
21:52:41 <Axman6> > map (\n -> n * (n-4)) [1..10]
21:52:42 <lambdabot>   [-3,-4,-3,0,5,12,21,32,45,60]
21:52:51 <ski> you could put that `good' into a `where'-clause, in your larger definition
21:53:06 <NotARobot> ski : youre awesome
21:53:47 * ski sometimes misses being able to do `> foo where blah' in lambdabot ..
21:54:57 <ski> (Hugs supports that as well. istr lambdabot did at a time, also)
21:57:00 <Cale> That was when lambdabot was a bit less secure about how it handled constructing the Haskell program to execute, iirc :)
21:57:53 <mietek> How can I use a STArray in IO?
21:57:53 <ski> well, i wouldn't mind it being secure *and* supporting trailing `where's
21:58:09 <mietek> ST doesn't appear to be a monad transformer.
21:58:23 <aavogt> couldn't you just rewrite the let to a where (in the lambdabot code)?
21:58:32 <mietek> I'd like to lift a few IO operations into ST, if that makes sense.
21:58:36 <Cale> mietek: How are you ending up in the situation of needing to do that?
21:58:53 <mietek> Cale: say I want to read stuff into a STArray.
21:59:08 <Cale> mietek: "read stuff"?
21:59:15 <ski> `ST s' is indeed not a monad transformer
21:59:16 <Cale> Like, do actual input?
21:59:26 <mietek> Yes, actual IO input.
21:59:33 <ski> you can't do I/O in `ST s'
21:59:37 <ski> it's not what it's for
21:59:39 <Cale> Read that stuff into something that's not an STArray, like a list, and pass it in.
22:00:02 <Cale> ST specifically prohibits any actual I/O
22:00:12 <Cale> It is for *pure* imperative computation.
22:00:29 <ski> s/imperative/state/
22:00:32 <mietek> Okay.
22:00:52 <Cale> Of course, another thing you could do is use IOArrays
22:00:52 <ski> in `ST s' you an mutate local, internal, state
22:00:57 <ski> nothing else
22:00:59 <mietek> Maybe a better way to use it would be: do some pure imperative computation, do some I/O, and continue with the pure imperative computation.
22:02:14 <ski> hm, i suppose it would be okay to convert between `IOArray i a' and `STArray RealWorld i a'
22:02:36 <ski> @type Control.Monad.ST.stToIO
22:02:37 <lambdabot> forall a. ST GHC.Prim.RealWorld a -> IO a
22:03:09 <NemesisD> i'm trying to find out if any typeclasses apply to this problem. i've got an "Order" type which has a vendor and line items. 2 orders can be grouped (line items combine) but only if they have the same vendor. closest i can find is a semigroup but that's not quite right
22:03:50 <NemesisD> the trick is i've got a list of Orders and i want to efficiently compact that list so that orders with the same vendor are concatenated
22:04:09 <Cale> NemesisD: I guess it's a special case of a category where there are no arrows between distinct objects ;)
22:04:32 <aavogt> make a Map with the keys being the vendor
22:04:41 <aavogt> @hoogle fromListWith
22:04:41 <lambdabot> Data.IntMap fromListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
22:04:41 <lambdabot> Data.Map fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
22:04:41 <lambdabot> Data.IntMap fromListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> IntMap a
22:05:00 <Cale> yeah, that's what you probably want :)
22:05:25 * ski wonders if it's related to semi-direct products, somehow ..
22:05:33 <cmccann> @hoogle unionsWith
22:05:33 <lambdabot> Data.IntMap unionsWith :: (a -> a -> a) -> [IntMap a] -> IntMap a
22:05:33 <lambdabot> Data.Map unionsWith :: Ord k => (a -> a -> a) -> [Map k a] -> Map k a
22:05:45 <cmccann> etc.
22:06:13 <cmccann> if you want to combine maps after building them with fromList and such
22:06:26 <NemesisD> hmm, the fromListWith* ones are almost right except they don't allow for the case of a failure to combine
22:06:40 <Cale> NemesisD: That won't come up
22:06:56 <Cale> NemesisD: Because it'll only combine things with the same key, i.e. the same vendor
22:07:40 <NemesisD> ohhhh
22:09:36 <NemesisD> niiice
22:10:31 <cmccann> NemesisD, I use Map/Set/etc. for that sort of grouping all the time :] it's pretty handy
22:13:39 * cmccann still needs to scare up a multi-dimensional version of something like Map one of these days
22:13:58 <cmccann> I keep hitting little things where it would be useful, but not significant enough to take the time to implement it on the spot :[
22:16:44 <aavogt> cmccann: there's one in happstack-ixset
22:17:17 <aavogt> at least that one used to generate a bunch of Data.Map
22:18:28 <cmccann> aavogt, hm
22:18:43 <hpaste> mietek pasted “ST experiments” at http://hpaste.org/47926
22:19:19 <cmccann> aavogt, that looks like it still assumes a 1-dimensional ordering though
22:19:30 <mietek> So, this works nicely
22:19:46 <mietek> Cale: here's what I had in mind
22:19:57 <mietek> ski: thanks for pointing out stToIO
22:20:13 <kmc> mietek, what's the point of doing it this way
22:20:17 <kmc> as opposed to using IOArray
22:20:26 <mietek> I realise this immediately poses a question, why not use IOArray
22:20:33 <aavogt> cmccann: I don't follow what you're looking for then
22:20:38 <kmc> you can also use stToIO on "compound" ST actions
22:20:43 <cmccann> aavogt, something like a quadtree
22:20:46 <mietek> But I'm skipping over parts which are imperative, but pure
22:20:47 <kmc> which would cut down on the number of invocations
22:20:56 <mietek> kmc: sure
22:21:15 <cmccann> aavogt, something that can e.g. do nearest-neighbor searches for more general notions of distance
22:21:29 <mietek> On question, though: is it possible not to pass a state instance explicitly?
22:21:56 <cmccann> the simplest example being something like using (Int, Int) for a key and being able to search for nearby elements based on euclidean distance
22:22:12 <kmc> mietek, what's that mean?
22:22:50 <kmc> you want the thing named by 'state' to be an implicit parameter?
22:23:14 <kmc> you can define peekState and pokeState inside the "do" block
22:23:20 <kmc> and make them close over 'state'
22:23:23 <cmccann> aavogt, last I checked there seems to be one incomplete and abandoned library on hackage that was going to have this sort of data structure and I've asked around a couple times and nobody knows of anything else :[
22:23:34 <mietek> I defined a type called 'State' to carry around some values that I want, in this example: a STArray
22:23:59 <kmc> mietek, so are you using runST elsewhere?
22:24:00 <mietek> Control.Monad.State however allows me to carry values "inside itself", by using Control.Monad.get/put
22:24:28 <mietek> Sorry: Control.Monad.State.get/put
22:24:37 <kmc> right
22:24:44 <cmccann> aavogt, that made more sense, I hope? :T
22:25:01 <kmc> the C.M.State type is syntactic sugar for passing around a single value through pure functions
22:25:20 <kmc> ST is a way to write real imperative programs manipulating any number of arrays, reference cells, etc.
22:25:28 <kmc> as such, it requires you to name whatever it is you're manipulating
22:25:41 <kmc> but like i said, you can make a local function which closes over an STArray or whatever
22:25:55 <kmc> so you're using this stuff with runST elsewhere?
22:26:05 <mietek> Can I combine C.M.State and ST?
22:26:17 <kmc> yes
22:26:35 <aavogt> cmccann: yep. It would take a couple lookups to get that to happen with ixset... it might be a bit easier than   Map (Int,Int) a  or   Map Int (Map Int a)
22:26:57 <mietek> I'm not using runST elsewhere; I would be calling the functions in ST s directly using stToIO
22:26:58 <cmccann> aavogt, thing is those don't actually work at all
22:27:06 <kmc> mietek, then i think you're missing the point of ST
22:27:10 <kmc> why not just use IOArray
22:27:22 <cmccann> nearest neighbor relies on using the same ordering as the data structure to be efficient
22:28:08 <kmc> as for combining them, you can do something like: StateT (STArray s Int Int) (ST s) a
22:28:24 <kmc> but now you have "state" at two levels: which array am I currently manipulating, vs. what's in that array
22:28:29 <aavogt> don't actually work is different from "is as efficient as a list"
22:28:30 <cmccann> aavogt, you can't map a plane onto a line such that relative distances between points are preserved :]
22:28:31 <kmc> so maybe you want ReaderT instead
22:28:51 <kmc> or maybe you want GHC's ImplicitParams extension
22:29:35 <cmccann> aavogt, okay, "don't work" in a loose sense :P
22:29:59 <mietek> kmc: thanks for the suggestions, I'm reading up on them now
22:30:52 <kmc> mietek, the point of ST is runST; it lets you use a "closed universe" of mutation as a pure value
22:31:10 <kmc> if you're only using ST within IO, you might as well use IO stuff directly
22:31:19 <kmc> though i can think of some exceptions to this
22:31:48 <kmc> it can be nice to assert that big chunks of your code *could* be pure, even if you don't use them that way
22:32:02 <kmc> but in that case you wouldn't have stToIO on every line
22:32:05 <cmccann> aavogt, obviously if exact matches are all that matter then mapping it to a linear ordering is fine, but sometimes the actual distance really is necessary
22:32:14 <kmc> you'd have one stToIO that encompasses a big ST action
22:32:18 <kmc> which you could later replace with runST
22:32:59 <kmc> mietek, anyway, beware of overcomplicating your code with StateT / ReaderT / etc.  all they provide is syntactic sugar for function args, and not even all that much sugar
22:33:07 <mietek> Right.
22:33:19 <cmccann> aavogt, an obvious example being collision detection algorithms for something like a game, where you really need to avoid superfluous comparisons
22:34:06 <cmccann> aavogt, anyway thanks for the suggestions anyway, sorry to complain so much :P
22:34:34 <aavogt> well there should be such a data structure in containers
22:35:12 <cmccann> aavogt, see that's why it annoys me, I'm used to hackage having every data structure I can think of and some I can't :P
22:37:10 <mustelo> is the function   count :: (Eq a) => a -> [a] -> Int  that counts occurrences defined somewhere already?
22:39:28 <Axman6> no, but filter and length are
22:39:38 <mustelo> right, fair enough
23:58:29 <rprije> If I want to make a new typeclass which is derivable, is my only alternative to use template haskell?
