00:00:45 <neilk_> is there a word for this pattern:
00:01:08 <neilk_> wait until Event X has happened, but if it has already happened, go ahead and do it now
00:21:11 --- mode: holmes.freenode.net set +o ChanServ
00:27:36 * hackagebot hlint 1.8.10 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.10 (NeilMitchell)
00:35:37 * hackagebot tagsoup 0.12.2 - Parsing and extracting information from (possibly malformed) HTML/XML documents  http://hackage.haskell.org/package/tagsoup-0.12.2 (NeilMitchell)
01:55:18 <frerich> Is there a ready-made function '\x p f -> if p x then f x else x'? I have this "Maybe apply function to value if predicate matches' used in a few places, I'm wondering whether it has a well-known name.
01:57:02 <mjrosenb> frerich: i have not seen anything per se, but i'd probably generalize it into two functions
01:57:14 <mjrosenb> \x p f g -> if p x then f x else g x
01:57:21 <mjrosenb> and put the x as the last argument
01:58:03 <ezyang> @hoogle a -> (a -> True) -> (a -> a) -> a
01:58:04 <lambdabot> Did you mean: a -> a -> Bool -> a -> a -> a /count=20
01:58:04 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
01:58:04 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
01:59:30 <ClaudiusMaximus> @pl \p f g x -> if p x then f x else g x
01:59:30 <lambdabot> (ap .) . liftM2 if'
01:59:32 <mjrosenb> i think you can get something similar with ArrowApply.
01:59:51 <mjrosenb> @src if'
01:59:51 <lambdabot> Source not found. I've seen penguins that can type better than that.
01:59:59 <mjrosenb> :t if'
02:00:00 <lambdabot> Not in scope: `if''
02:00:03 <mjrosenb> ...
02:00:08 <ClaudiusMaximus> @unpl if'
02:00:08 <lambdabot> if'
02:00:11 <mjrosenb> @slap lambdabot
02:00:12 * lambdabot locks up lambdabot in a Monad
02:02:06 <mjrosenb> and by ArrowApply, i mean ArrowChoice
02:02:22 * mjrosenb has been attempting to wrap his head around arrows for a week or two now
02:12:46 <ClaudiusMaximus> s'been a productive night!  i think i got a shiny new "external angle from parameter coordinates" algorithm figured out :) needs more testing, but i'm hopeful that it works more often than it fails..   plus my very minimal C++ wrapper over MPFR (just the things i need, no heed to efficiency..) seems to work in the renderer when called from ghc/integer-simple
02:14:02 <ClaudiusMaximus> bit suspicious of hmpfr's fromRational/fromInteger/show etc though - not sure they're precise enough.. so i'm avoiding those functions for now
02:15:43 <ClaudiusMaximus> need to figure out the fast way to do "angled internal address -> external angles" though, my "search via lavaurs' algorithm" is a bit exceedingly slow
02:16:50 <mjrosenb> angled internal address/external angles?
02:17:19 <ClaudiusMaximus> http://arxiv.org/abs/math/9411238v2
02:18:32 <mjrosenb> ClaudiusMaximus: that looks amazing.
02:21:00 <ClaudiusMaximus> it does, most of it is way over my head, but i've managed to implement some of it
02:21:41 <mjrosenb> yeah, it looks like it is using some terminology about the mandlebrot set that i have never seen before.
02:23:05 * mjrosenb wonders if it is possible to encode something like fractran into a fractal-like structure
02:23:56 <ClaudiusMaximus> what's fractran?
02:24:38 <mjrosenb> it is a turing complete "language" written by john conway
02:24:50 <mjrosenb> where the "program" is an ordered set of fractions
02:25:32 <ClaudiusMaximus> interesting - i seem to have seen it before, but forgot the name
02:25:36 <mjrosenb> basically, you start with a whole number, and you keep multiply by the first fraction in the set that will cause the result to be an integer
02:25:47 <ClaudiusMaximus> yeah got wikipedia page open
02:25:49 <mjrosenb> and if none do, then you terminate
02:53:30 <adimit> is there a function like doTimed :: IO a -> IO (a,b) where b is some sort of time span?
02:54:15 <adimit> pardon, (a -> IO b) -> a -> IO (b,c)
02:54:29 <adimit> (c being the timed thing)
02:55:04 <ddarius> The former one makes more sense as it is simpler and the latter can be written in terms of it.
02:55:31 <adimit> ah, well, always trust your first instinct.
02:56:14 <adimit> but, well, hoogle and hayoo both failed me, so I assume I'll write it myself (seems like a good addition to Data.Time.Clock)
02:56:16 <ClaudiusMaximus> http://hackage.haskell.org/packages/archive/criterion/0.5.0.10/doc/html/Criterion-Measurement.html
02:56:27 <adimit> ClaudiusMaximus: thanks.
02:57:26 <flinstone> Hi guys anybody used prolog?
02:57:41 <adimit> well, yeah.
02:57:52 <adimit> flinstone: what's your question?
02:58:35 <ddarius> @tell byorgey Use realToFrac rather than fromRational . toRational in Criterion.Measurement (and anywhere else.)
02:58:36 <lambdabot> Consider it noted.
02:58:39 <flinstone> adimit, i want to try prolog and expert system in it
02:59:03 <adimit> flinstone: there's #prolog, too‚Ä¶
02:59:20 <flinstone> adimit, ok
03:01:07 * mjrosenb suspects he does not want to know what an "expert system" is
03:01:43 <Jafet> @google expert system
03:01:43 <lambdabot> http://en.wikipedia.org/wiki/Expert_system
03:01:44 <lambdabot> Title: Expert system - Wikipedia, the free encyclopedia
03:01:58 <Jafet> Oh, read about it. It's amusing.
03:02:32 <Jafet> Oops, the Wikipedia article isn't meta enough.
03:03:57 <flinstone> Jafet, What does it mean is not meta enough?
03:05:05 <rostayob> I have a debian stable virtual machine, i installed the haskell platform
03:05:23 <flinstone> Jafet, i do not know what ishould use for expert system rule engine, or prolog what you can recommend?
03:05:32 <xkb> Does anyone have some small sample code on exposing JSON to a jQuery client? Something real small in either happstack, yesod or snap?
03:05:34 <rostayob> trying to compile a fairly simple piece of code results a linking error
03:06:00 <Jafet> That's what you get for running stable!
03:06:21 <rostayob> Jafet: it's just a vm to test my software with the packages i'm likely to find on servers :P
03:06:32 <Jafet> Cough, what I said was, paste relevant information
03:06:55 <Jafet> Hm, I don't think it matters much unless you're fiddling with shared-libs.
03:07:12 <rostayob> Jafet: well the linking errors seem related to containers
03:07:30 <Jafet> flinstone: sorry, I can't recommend anything, since I don't know what expert systems are
03:07:32 <hpaste_> rostayob pasted ‚Äúlinking troubles‚Äù at http://hpaste.org/47703
03:07:47 <rostayob> there you go :P
03:07:51 <ddarius> Jafet: Really?
03:07:56 <rostayob> that's the code ( http://hpaste.org/47703 )
03:08:53 <k0ral> why can't I find udisksevt in hackage ? https://github.com/dpx-infinity/udisksevt
03:09:26 <Jafet> ddarius, I'm referring to how most packages are statically linked by GHC by default
03:10:31 <Jafet> rostayob: the errors please, since probably no one here runs debian stable to reproduce them...
03:10:55 <hpaste_> rostayob pasted ‚Äúlinking troubles‚Äù at http://hpaste.org/47704
03:11:02 <rostayob> Jafet: http://hpaste.org/47704
03:11:31 <Jafet> Note that GHC 6 did not use --make by default for linking.
03:11:42 <rostayob> Jafet: oh. right.
03:11:47 <arcatan> xkb: all you need to do is to just output JSON instead of HTML
03:12:52 <rostayob> Jafet: now it works, I had forgot about that. thanks
03:14:49 <xkb> arcatan: hehe true, there's so many frameworks that it's hard to choose one just for this simple problem
03:14:58 <flinstone> Anybody know advanced c# open source projects(functional programming in c#,parsers,domain modeing,dsl etc)
03:15:22 <ddarius> Jafet: My comment was in reference to your statement about expert systems.
03:15:23 <mjrosenb> flinstone: i think that c# has their own channel.
03:15:43 <xkb> arcatan: I just need URI mapping like /person/1 to a function with parameter set as 1, and return JSON
03:16:29 <flinstone> mjrosenb, yes, but here are a lot of people intresting in functional prgramming and another concepts
03:16:39 <Botanok> Okay can we can linear types so we can stop using this ST monad mumbo jumbo magic
03:17:14 <Jafet> ddarius: I meant that in the same way as when I say that I don't know what "OOP" is
03:17:32 <Botanok> OOP is snake oil bullshit
03:17:41 <Jafet> See.
03:17:58 <Botanok> It is poorly defined
03:18:15 <ddarius> Jafet: I would say there are some reasonably clear technical definitions of "expert system."
03:19:44 <ddarius> Or rather, there is a reasonably clear technical definition of "expert system," that may not encompass all of what people want it to mean, but is still more or less agreed upon.
03:19:50 <Jafet> Sure, but it gets tarred over by a lot of business-speak.
03:20:40 <Botanok> Why doesn't Haskell have array types built into its core language
03:20:52 <Jafet> Could you point me to one of these technical definitions, ddarius?
03:20:54 <ddarius> The problem with OOP is that there are a bunch of technical definitions that contradict each other and are rarely viewed as being the "essence" of OOP by practitioners.
03:21:42 <Jafet> Botanok: it does, in the module named Array (!)
03:22:28 <Botanok> That's in a module
03:22:42 <Jafet> Which is part of the Haskell 98 language specification.
03:23:22 <Botanok> I meant as a primitive
03:23:32 <Jafet> It is a primitive.
03:23:46 <Jafet> The name of the primitive is exported by Array, not the Prelude.
03:23:52 <Jafet> How is that a problem?
03:24:32 <Botanok> You should be able to make datatype declarations that are arrays
03:25:19 <Jafet> Why define another array data type when there is already Array?
03:25:28 <Botanok> That one should be removed
03:25:33 <ddarius> Jafet: http://en.wikipedia.org/wiki/Inference_engine is a start.
03:25:34 <flinstone> What should i use in Haskell for domain modeling, rule engines etc?
03:26:14 <Jafet> ddarius: thanks
03:26:41 <Jafet> Botanok: you're being silly.
03:27:20 <Jafet> Stop being silly and you might have some extra time in your life to read about the ST monad mumbo jumbo magic.
03:28:19 <flinstone> :-)
03:28:37 <ddarius> Haskell should be like most mainstream languages and make the array type constructor be second-class so people have to constantly create wrappers about it.
03:29:21 <Botanok> I want indexable datas eg data Stuff = Stuff Int*100  and then b= Stuff {1,2,3,4...} and then 1.b == 1 2.b == 2 etc..
03:30:05 <ziman> Array is indexable. :)
03:30:29 <Botanok> Go hack what I want into GHC
03:30:35 <Jafet> Do it yourself
03:30:39 <Botanok> You will get paid
03:30:43 <mjrosenb> i think he means that he wants ! to be typeclassed
03:30:45 <Botanok> 3 bananas
03:31:05 <Jafet> Stick them up your butt.
03:31:05 <ziman> (!) is typeclassed in Data.Array.IArray, iirc
03:31:13 <Jafet> What a waste of time.
03:31:42 <Botanok> Jafet: keep your sexual desires out of this
03:33:08 <Botanok> At least until we get to know each other better
03:33:26 <Botanok> I never knew Haskellers were such perverts
03:34:01 <ddarius> Even assuming sexual connotations, that was pretty mundane, if a bit odd.
03:35:36 <Botanok> 1 banana would have been normal
03:35:46 <Botanok> 3 is kind of perverted
03:35:54 <Botanok> That aside
03:36:26 <Botanok> this is the best place on freenode for trolling
03:36:32 <Botanok> except for #politics
03:36:59 <adimit> there are people in a #politics channel on a popular irc network? Why would they join there?
03:38:06 <Botanok> 90% trolls 10% idiots
03:38:27 <Botanok> I think there is a little overlap as well
03:38:31 <Botanok> Just like in here
03:39:18 <merijn> Botanok: Reverse the numbers and you have the state of humanity in general :>
03:39:47 <Botanok> Politicians are often trolls
03:39:59 <merijn> I think politicians are mostly both
03:41:00 <Botanok> Why aren't anyone cloning reddit with one of the great web frameworks for haskell?
03:41:09 <Botanok> Like maybe snap
03:41:18 <adimit> because we already have hackernews.
03:41:21 <merijn> Botanok: Why would anyone?
03:41:40 <merijn> adimit: Someone needs to make a more hacker-ish HN, though :\
03:41:40 <Botanok> Okay then why aren't anyone making something like mongodb in Haskell
03:41:57 <adimit> merijn: well, HN is mostly for enterpreneurs, I guess.
03:42:15 <Botanok> A keyvalue store in haskell
03:42:20 <merijn> adimit: I know, which is kinda annoying because I'm really looking for a HN for hackers, but so far I can't really find anything
03:42:33 <merijn> Botanok: Because mongodb already exists (and as far as I can tell is created by quite competent people)
03:42:50 <merijn> Why reinvent the wheel if the current wheel performs adequately?
03:43:03 <Botanok> To beat it with Haskell
03:43:15 <Entroacceptor> otoh there's acid-state
03:43:42 <Botanok> Well do you think you could compete with something like that?
03:44:15 <hpc> Botanok: why aren't you cloning reddit? :P
03:44:33 <merijn> Botanok: (open source) software is not a competition, you don't "beat" other projects
03:44:34 <Botanok> I like to troll instead
03:44:55 <Botanok> merijn: oh that is the only reason I write code
03:45:03 <Botanok> to beat other people and watch them cry
03:45:27 <merijn> I don't need someone to beat my code to make me cry
03:45:41 <merijn> The code I'm working on already makes me cry as-is
03:45:54 <Botanok> javaEE?
03:46:28 <merijn> No, compiler + runtime for a research language (both written in C)
03:47:04 <Botanok> C and C++ needs to be replaced
03:47:13 <merijn> That's why we have Go
03:47:18 <Botanok> I cried when you bros abandoned C--
03:47:25 <Botanok> I will never forgive you for that
03:47:26 <merijn> C-- was horrible
03:47:44 <merijn> Of course you'd still need C for 8bit CPUs since  Go is only 16 (or 32?) bit and up
03:48:05 <Botanok> What was horrible about C--
03:48:34 <merijn> What was good about it?
03:55:27 <Botanok> Well now you have llvm
03:57:04 <lexplua> Hi all!
03:57:14 <hpaste_> haskelldude pasted ‚Äúcaesar cipher‚Äù at http://hpaste.org/47706
03:57:15 <ohrores> Hi
03:57:32 <haskelldude> pls look into my code snippet
03:57:46 <ohrores> yes
03:58:05 <haskelldude> it gives weird chars, not ROT13 ones
03:58:26 <lexplua> Who knows good stories about ST and Parsec ?
03:59:04 <merijn> haskelldude: What does "(ord 'z') + 13" do?
03:59:32 <haskelldude> gets the ascii value of 'z' and add 13 to it
03:59:46 <merijn> haskelldude: And the result of that will be?
04:00:15 <haskelldude> 135
04:00:34 <lexplua> haskelldude :  why you use "show" ?? result of map will be String
04:01:14 <lexplua> becose rot13::Char->Char
04:01:15 <merijn> haskelldude: "ord 'a'" is 97, "ord 'z'" is 122, so a-z is between 97 and 122. 135 is some entirely different character range
04:01:27 <ohrores> @help
04:01:27 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:01:44 <Entroacceptor> it's not called ADD13 ;)
04:01:49 <merijn> haskelldude: You need to add some more code to make sure the result of +13 will always be between 97 and 122
04:02:12 <haskelldude> i c!
04:02:16 <haskelldude> thanks
04:02:22 <merijn> haskelldude: My approach would be to subtract 97 from "ord a", then add 13, do modulo 26, then add 97 to it again
04:02:38 <Entroacceptor> but only if the input is in that range in the first place
04:02:47 <merijn> haskelldude: (Of course this only works for lowercase letters, if you also want to do capital letters it becomes a bit more complicated)
04:03:03 <Entroacceptor> xkb: decided on a framework yet?
04:03:09 <merijn> But that should be enough to get you started :)
04:03:22 <haskelldude> ya. got it :)
04:03:36 <lexplua> rot13 a = show ( (ord a) + 13)
04:03:48 <lexplua> Char->String
04:04:30 <lexplua> and let sentence' = map (++) $ map rot13 sentence
04:04:57 <lexplua> ops
04:04:58 <hpc> :t map (++)
04:04:59 <lambdabot> forall a. (Monoid a) => [a] -> [a -> a]
04:05:29 <lexplua> let sentence' = foldl (++) "" (map rot13)
04:06:07 <lexplua> let sentence' = foldl (++) "" (map rot13 sentence)
04:06:07 <merijn> Can I use functions defined in where clauses inside the guard of a function?
04:06:17 <hpc> yes
04:09:38 <haskelldude> lexplua: it gives a number stream
04:11:10 <hpc> lexplua: btw, lists are monoids, so you can use mconcat
04:11:25 <hpc> > mconcat ["a","b","c","d"]
04:11:25 <lambdabot>   "abcd"
04:13:28 <lexplua> in ghci
04:13:40 <lexplua> let s= "hello"
04:13:51 <lexplua> let rot13 a = show ( (ord a) + 13)
04:14:11 <lexplua> let sentence' = foldl (\x y -> x++y++" ") "" (map rot13 s)
04:14:41 <lexplua> sentence'
04:15:05 <lexplua> "117 114 121 121 124 "
04:16:18 <haskelldude> thanks
04:17:08 <ddarius> merijn: That's the purpose of where clauses.
04:18:40 <hpaste_> merijn pasted ‚Äúrot13‚Äù at http://hpaste.org/47707
04:18:59 <merijn> lexplua: That is the more sensible way to implement it :p
04:20:08 <merijn> oh, I guess I could've removed the parenthesis on that last line too, oh well
04:21:40 <merijn> haskelldude: Of course the code I just posted only caesar shifts a-z and A-Z ascii chars. Making it work for arbitrary unicode characters would be far from trivial
04:21:43 * ddarius loves the hlint smackdown.
04:23:43 <merijn> I'm pretty pleased I managed to write something with only 1 hlint warning which wasn't even that bad :p
04:23:55 <merijn> That doesn't usually happen the first time around :p
04:28:31 <lexplua> What about ST ?
04:29:14 <Peaker> > 'a' < 'z'
04:29:14 <lambdabot>   True
04:29:22 <Peaker> merijn: you don't need to "ord" to get an Ord :)
04:29:30 <merijn> Peaker: Damn :\
04:30:07 <ddarius> :t (%)
04:30:08 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
04:30:14 <ddarius> Probably not what you want.
04:30:20 <Peaker> merijn: also, you could put the (chr.) and (.ord) inside rotFromStart
04:30:32 <Peaker> merijn: since they're duplicated
04:30:42 <merijn> ddarius: Ah, I actually fixed that inside the code I tested before pasting :p
04:30:47 <Peaker> hpaste doesn't seem to allow editing
04:30:52 <merijn> `mod` and all
04:31:05 <ddarius> Peaker: I believe chrisdone is in the process of rewriting it.
04:31:19 <ddarius> Peaker: It's has been noticeably less featureful the last few days or so.
04:32:02 <merijn> Peaker: Yeah, but on the other hand leaving them *out* rotFromStart keeps the function a bit cleaner/more readable
04:32:33 <merijn> I'm a big fan of readability :p
04:32:40 <hpaste_> ‚Äúmerijn / Peaker‚Äù pasted ‚ÄúChanges‚Äù at http://hpaste.org/47708
04:32:52 <ddarius> Looking at your indentation for the do-block, I do not agree.
04:33:02 <Peaker> merijn: could split the function in two
04:33:12 <merijn> ddarius: I copied the do block from haskelldude :)
04:33:51 <merijn> Peaker: Hah, pretty sure that is a type error :p
04:34:00 <merijn> "map rot 13 sentence" is not gonna work :)
04:36:09 <Peaker> oops
04:36:16 <hpaste_> ‚Äúmerijn / Peaker‚Äù pasted ‚ÄúChanges‚Äù at http://hpaste.org/47709
04:37:23 <merijn> Can you nest where clauses in where clauses? :>
04:38:25 <haskelldude> merijn: awesome!
04:38:27 <haskelldude> thanks
04:39:43 <ddarius> merijn: You can attach a where clause to any function/value declaration.
04:45:17 <hpaste> ‚Äúmerijn / Peaker‚Äù pasted ‚ÄúPolish it 'til it shines!‚Äù at http://hpaste.org/47710
04:50:41 <hpaste> ‚Äúmerijn / Peaker‚Äù pasted ‚ÄúChanges‚Äù at http://hpaste.org/47711
04:51:22 <drbean> uppercase = flip elem ['A'..'Z'] c
04:51:39 <ddarius> :t inRange
04:51:40 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
04:51:52 <ddarius> > inRange ('a', 'z') 'c'
04:51:52 <lambdabot>   True
04:52:14 <ddarius> Also
04:52:16 <ddarius> :t isLower
04:52:17 <lambdabot> Char -> Bool
04:52:36 <arcatan> 2
04:52:39 <ddarius> (albeit isLower operates over all unicode characters)
04:53:12 <merijn> ddarius: I was about to say, that'll break for unicode strings. The current one works and just ignores non-ascii alphabetical chars
04:53:43 <ddarius> :t isAscii
04:53:44 <lambdabot> Char -> Bool
04:53:51 <ddarius> In fact
04:53:56 <ddarius> :t isAsciiLower
04:53:57 <lambdabot> Char -> Bool
04:54:06 <merijn> >.>
04:59:14 <hpaste> cirno pasted ‚Äúheap sort as an hylomorphism‚Äù at http://hpaste.org/47712
05:01:28 <ezyang> I wonder if there's a name for foldr (.) id
05:01:31 <hpaste> ‚Äúddarius (original merijn/Peaker)‚Äù pasted ‚Äúfish in a barrel‚Äù at http://hpaste.org/47713
05:01:44 <ddarius> ezyang: ala Endo mconcat
05:02:23 <ezyang> *sigh* :-)
05:02:31 * hackagebot xml-enumerator 0.3.2 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.3.2 (MichaelSnoyman)
05:02:33 <ddarius> At one point it was just mconcat, then they switched it on me.  For a while I just thought I had been somehow completely retarded in my Prolog pretty printer.
05:03:44 <opqdonut> heh
05:04:10 <ddarius> :t ala Endo
05:04:11 <lambdabot> forall a b n' o'. (Newtype n' o') => (((a -> a) -> Endo a) -> b -> n') -> b -> o'
05:04:24 <ddarius> :t ala Endo mconcat
05:04:24 <lambdabot>     Couldn't match expected type `(a -> a) -> Endo a'
05:04:25 <lambdabot>            against inferred type `[a1]'
05:04:25 <lambdabot>     In the second argument of `ala', namely `mconcat'
05:04:41 <opqdonut> btw, why "foldr (.) id" and not "flip $ foldr ($)"
05:04:44 <opqdonut> :)
05:05:58 <ddarius> > appEndo . mconcat . mapEndo $ [showString "hello ", showString "world"] ""
05:05:58 <lambdabot>   Not in scope: `mapEndo'
05:06:09 <ddarius> > (appEndo . mconcat . map Endo $ [showString "hello ", showString "world"]) ""
05:06:10 <lambdabot>   "hello world"
05:06:28 <ddarius> > (mconcat [showString "hello ", showString "world"]) ""
05:06:29 <lambdabot>   "hello world"
05:07:04 <ddarius> > (mconcat [showString "hello ", id]) "bar"
05:07:05 <lambdabot>   "hello barbar"
05:07:13 <ddarius> > (appEndo . mconcat . map Endo $ [showString "hello ", id]) "bar "
05:07:14 <lambdabot>   "hello bar "
05:08:32 <opqdonut> yeah you were using the Monoid a => r -> a instance there
05:08:46 <ddarius> opqdonut: Not originally.
05:08:55 <ddarius> :k Endo ShowS
05:08:56 <lambdabot> *
05:09:08 <ddarius> :t Endo (showString "foo")
05:09:08 <lambdabot> Endo String
05:09:18 <opqdonut> yeah but on your second-to-last lambdabot expr there
05:09:28 <opqdonut> I just wondered about that for a second
05:09:31 <ddarius> I meant in my Prolog pretty printer.
05:09:44 <ddarius> String -> String fits both instances nicely.
05:09:53 <ddarius> So there is no type error.
05:11:46 <Koterpillar> I'm trying to write sortBy as an exercise, but the interpreter gives me "[" and hangs. How can I step through everything, ideally seeing the current expression being evaluated?
05:12:15 <opqdonut> use the ghci debugger
05:12:25 <ddarius> Koterpillar: You could use the GHCi debugger, but that will probably be more confusing than enlightening.
05:12:40 <ddarius> You could try to see if you can get Buddha or Hat to build.
05:12:41 <opqdonut> it does require some getting used to
05:12:47 <ddarius> However, I recommend simply expanding by hand.
05:13:01 <opqdonut> Koterpillar: see how ":step the-expression" works for you
05:13:08 <Koterpillar> In the debugger, I set a breakpoint on my function (:break), but after three :step it hung.
05:15:27 <Koterpillar> opqdonut, that seemed to help, thank you! At least, something is going on and not hanging.
05:15:48 <opqdonut> then use :list and maybe :print to look around
05:16:42 <Koterpillar> Well, same. :step hangs after a couple more steps
05:16:55 <Koterpillar> Shouldn't it be more... atomic?
05:17:06 <lispy> hello
05:18:02 <ezyang> Hello!
05:20:59 <Koterpillar> ...figured it out. let hid my parameter
05:22:34 <lispy> ezyang: How were exams?
05:23:11 <Guest9304> "let p = e1  in  e0" = "let p = fix ( \ ~p -> e1) in e0" gosh i turn into a complete idiot every time fix isused
05:23:29 <ezyang> lispy: Went reasonably well; glad they're over.
05:23:42 <lispy> ezyang: I know the feeling :)
05:24:08 <lispy> ezyang: What are you doing this summer?  Research?
05:24:14 <lispy> taking a break?
05:24:36 <ezyang> Unfortunately, not research. I was pretty constrained in what I could do, since my summer is effectively 8 weeks long.
05:24:42 <ezyang> I'm working Jane St this summer.
05:25:07 <lispy> oh, that's a short-ish sumer
05:25:10 <lispy> summer*
05:25:33 <ezyang> yeah
05:25:48 <ezyang> It probably would have been better if I got a research job, since I'm thinking about grad school these days, but what can you do.
05:26:06 <lispy> Yeah, no worries
05:26:23 <lispy> Get some more industry experience while you can.  If you go grad school that experience will be handy later
05:26:42 <ezyang> Heh, that's reassuring to hear :-)
05:26:45 <lispy> It's good to have both practical and theoretical expertise.  Balance is good
05:27:54 <haskelldude> i need to practice making custom higher order functions, what kind of programs i should write?
05:28:35 <lispy> haskelldude: rewrite the prelude from scratch yet?
05:28:35 <haskelldude> for ex: string processing application, where can i apply this?
05:28:46 <merijn> lispy: That's reassuring, I missed grad school application deadlines of the places I wanted to go this year >.>
05:29:08 <hpc> haskelldude: write an IRC bot, perhaps
05:29:23 <haskelldude> lispy: i need something simpler, for now..
05:29:40 <lispy> haskelldude: the prelude is simple :)
05:29:57 <lispy> haskelldude: write your own map/foldl for example
05:30:15 <lispy> write your own zipWith
05:30:36 <merijn> haskelldude: Most Prelude functions are really simple to write
05:30:54 <hpc> for extra credit, define every function in terms of another function, so the whole prelude is broken, but with correct definitions
05:31:02 <haskelldude> lispy: i was wondering if there is any function i can write that does something which cant be done using prelude function
05:31:22 <lispy> Yeah, IO a -> a, can't be written using the prelude :)
05:31:47 <haskelldude> hmm
05:32:26 <hpc> haskelldude: write an IRC bot
05:32:27 <lispy> You shouldn't need IO a -> a unless you're doing something questionable
05:32:46 <merijn> lispy: Questionable things are the only things worth doing :>
05:33:14 <ddarius> @src Eq
05:33:14 <lambdabot> class  Eq a  where
05:33:15 <lambdabot>     (==), (/=)   :: a -> a -> Bool
05:33:19 <ddarius> Bah @src
05:34:51 <hpc> haskelldude: it will expose you to enough new concepts to occupy at least a month, depending on what you decide the bot will be able to do
05:35:33 <mjrosenb> haskelldude: write an unlambda interpreter
05:35:48 <merijn> Write a Scheme compiler :>
05:36:13 <haskelldude> well, im still a noob :)
05:36:41 <ddarius> Everything is easy with Haskell.
05:36:59 <merijn> I would have accomplished so much more in programming if I hadn't convinced myself that things like writing compilers were hard...
05:38:01 <haskelldude> i will considr abt those latr :) thanks
05:38:31 <chrisdone_> haskelldude: Write a pretty printer for Haskell that follows tibbe's style guide: https://github.com/tibbe/haskell-style-guide
05:38:34 <hpc> merijn: heh, it is hard, but only if you want to write a GOOD compiler
05:38:48 <chrisdone_> haskelldude: ‚Ä¶ So that I can add it to hpaste.org. >_>
05:38:49 <hpc> (see also: writing good programs is in general, hard work and lots of time)
05:40:02 <merijn> hpc: Who cares? You don't need to write a *good* compiler to learn something
05:40:20 <wjlroe> How can you specify a build-depends in a .cabal file that specifies a source - i.e. this package is from github?
05:40:42 <merijn> Just the realization it brings that "hey, I *can* write a compiler" and "Ooooh! So that's how it works" is enough I'd say
05:41:02 <merijn> Hell, even if you write a compiler that only parses arithmetic expressions you're ahead of the curve
05:42:10 <haskelldude> are higher order functions only applied with lists?
05:42:52 <lispy> haskelldude: nope
05:42:54 <ddarius> chrisdone_: Yes.  We just need someone else to upload a judgement package to Hackage.
05:42:59 <mjrosenb_> haskelldude: no
05:43:10 <lispy> :t fix -- haskelldude this is recursion has a higher-order function
05:43:11 <mjrosenb_> haskelldude: about half the time they are applied to functions :-p
05:43:11 <lambdabot> forall a. (a -> a) -> a
05:43:41 <mjrosenb_> fix ("ha"++)
05:43:47 <mjrosenb_> > fix ("ha"++)
05:43:49 <lambdabot>   "hahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahaha...
05:43:56 <lispy> > fix show
05:43:57 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
05:44:21 <lispy> in #haskell we fix a lot of things that aren't broken
05:44:29 <lispy> > fix error
05:44:29 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
05:44:35 <hpc> :D
05:44:44 <hpc> an error within an error
05:44:57 <hpc> EXCEPTION
05:46:04 <shachaf> > fix fi—Ö
05:46:05 <lambdabot>   fix (fix (fix (fix (fix (fix (fix (fix (fix (fix (fix (fix (fix (fix (fix (...
05:46:15 <magicman> :t fix fix
05:46:15 <mjrosenb_> err...
05:46:16 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
05:46:16 <lambdabot>     Probable cause: `fix' is applied to too many arguments
05:46:16 <lambdabot>     In the first argument of `fix', namely `fix'
05:46:31 <hpc> shachaf: wait, what
05:46:34 <hpc> :t fix
05:46:35 <lambdabot> forall a. (a -> a) -> a
05:46:44 <haskelldude> oh wats happening :S
05:46:50 * ddarius will leave people to puzzle it.
05:47:17 * mjrosenb_ assumes that they did something along the lines of 
05:47:25 <mjrosenb_> > f 1 :: expr
05:47:26 <lambdabot>   Could not deduce (SimpleReflect.FromExpr expr) from the context ()
05:47:26 <lambdabot>    arisi...
05:47:39 <hpaste> entro pasted ‚Äúbytestring‚Äù at http://hpaste.org/47716
05:47:46 <mjrosenb_> or whatever the correct thing was
05:47:51 <Entroacceptor> yes, I did. :)
05:47:52 <mjrosenb_> > f 1 :: Expr
05:47:53 <lambdabot>   f 1
05:47:56 <mjrosenb_> that one.
05:48:04 <shachaf> > fix f :: Expr
05:48:05 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
05:48:05 <Entroacceptor> can someone help me with that?
05:48:07 <shachaf> Huh, neat.
05:48:45 <shachaf> Entroacceptor: Probably you want to use ByteString.(Lazy.)Char8 or something of the sort?
05:49:07 <shachaf> Pasting an error without the code that produced it might be counterproductive in general. :-)
05:49:24 <Entroacceptor> shachaf: all the code is there ;)
05:49:43 <Entroacceptor> import Data.ByteString; pack "hallo" gives me the same error in ghci
05:50:00 <chrisdone_> Entroacceptor: Yeah, import Data.ByteString.Char8
05:50:02 <ben> isn't pack from .Char8
05:50:02 <shachaf> Entroacceptor: Well, no, it's not -- e.g. the import isn't.
05:50:10 <chrisdone_> http://www.haskell.org/ghc/docs/6.6.1/html/libraries/base/Data-ByteString-Char8.html#v%3Apack
05:50:19 <ddarius> mjrosenb_: That's not what shachaf did.
05:51:34 <Entroacceptor> so you're not supposed to just import ByteString?
05:51:37 <hpc> :t fix ?fix
05:51:38 <lambdabot> forall a. (?fix::a -> a) => a
05:52:12 <ddarius> @hoogle pack
05:52:12 <lambdabot> Data.ByteString pack :: [Word8] -> ByteString
05:52:13 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
05:52:13 <lambdabot> Data.ByteString.Lazy pack :: [Word8] -> ByteString
05:52:19 <ddarius> There are many packs.
05:52:22 * hackagebot hoogle 4.2.5 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.5 (NeilMitchell)
05:52:36 <chrisdone_> Also Data.Text.pack, Data.Text.Lazy.pack, ‚Ä¶
05:52:42 <chrisdone_> ;_;
05:53:07 <ddarius> chrisdone_: Just use fromString.
05:54:11 <shachaf> As long as you're using fromString, you might as well use it implicitly in Entroacceptor's particular case.
05:54:14 <Entroacceptor> great, now the other part fails (toJsonBS) with is a->ByteString
05:54:22 <shachaf> ({-# LANGUAGE OverloadedStrings #-})
05:54:54 <ddarius> shachaf: Yes, but sometimes one could need to use fromString directly.  Also, using it explicitly doesn't require any extensions.
05:55:23 <chrisdone_> (s/sometimes/often, IME.)
05:55:28 <Entroacceptor> where's fromString from?
05:55:31 <chrisdone_> Data.String
05:55:35 <ddarius> @hoogle fromString
05:55:35 <lambdabot> Data.String fromString :: IsString a => String -> a
05:56:41 <chrisdone_> chris@cn-done:~/Projects/me/amelie/src$ find . -name '*.hs' | xargs grep -E '(pack|fromString)' | wc -l
05:56:42 <chrisdone_> 30
05:56:46 <jonkri> what's wrong with the forall part of this syntax? session :: (forall a. XMLable a, MonadIO m, ClientState s m) => s -> ...
05:56:56 <shachaf> chrisdone_: Now try grep '"'. :-)
05:57:11 <chrisdone_> shachaf: What about it?
05:57:12 <ddarius> jonkri: Probably what the error message says is wrong.
05:58:03 <shachaf> chrisdone_: (Just giving one number won't be helpful in comparing explicit/implicit uses.)
05:58:08 <ddarius> (It also doesn't make -any- bloody sense.)
05:58:26 <Entroacceptor> @hoogle toJsonBS
05:58:27 <lambdabot> No results found
05:58:29 <chrisdone_> shachaf: I wasn't comparing.
05:58:32 <Entroacceptor> @hayoo toJsonBS
05:58:33 <lambdabot> Unknown command, try @list
05:58:36 <Entroacceptor> aww
05:59:10 <shachaf> jonkri: What's that forall supposed to mean inside the class constraint?
05:59:33 <chrisdone_> shachaf: ‚ÄúBut sometimes one could need to use fromString directly‚Äù sounds like one hardly ever needs it; I just demonstrated I use all the time.
06:00:38 <chrisdone_> There's also the issue of OverloadedStrings making things ambiguous, and GHC doesn't default like it does with fromIntegral.
06:01:53 <ddarius> What would it default to?  String?
06:02:10 <ezyang> I wonder if user-extensible defaulting is a good idea.
06:02:33 <ddarius> ezyang: It isn't.
06:02:48 <ezyang> Yeah, I could believe that.
06:02:58 <mjrosenb_> user-extensible defaulting?
06:02:59 * shachaf notes that OverloadedStrings isn't part of -fglasgow-exts.
06:03:26 <chrisdone_> ddarius: I'd prefer it, yeah.
06:03:27 <jonkri> shachaf, i want it to make the "[SimpleVariable a m]" list provided to the function is polymorphic
06:03:33 <kenjin2201> When writing eDSL, Lisp programmers often think of generating list code using macros when the work requires more than simply combining functions. How do Haskell programmers approach those problems?
06:03:37 <ddarius> -fglasgow-exts probably only activates the features it activated back in 2005 or something like that (which wasn't everything then.)
06:04:03 <ddarius> kenjin2201: We combine functions.
06:04:03 <chrisdone_> ddarius: For example, I have: href :: (ToValue location,ToHtml html) => location -> html -> Html
06:04:18 <chrisdone_> ddarius: Now I can't write: bar :: Html; bar = href "x" "y", because the string literals are ambiguous.
06:04:23 * hackagebot dia-functions 0.2.1.1 - An EDSL for teaching Haskell with diagrams - functions  http://hackage.haskell.org/package/dia-functions-0.2.1.1 (PeterDivianszky)
06:04:27 <merijn> kenjin2201: Do you have a more concrete example of when combining functions doesn't suffice?
06:04:29 <chrisdone_> I have to type annotate. :-(
06:04:44 <parcs> kenjin2201: most of the stuff that lisp macros do can be done through combining functions. the rest can be done through Template Haskell, Haskell's version of metaprogramming
06:04:50 <chrisdone_> (String is both an instance of ToValue and ToHtml.)
06:04:51 <kenjin2201> merijn: Say you need to write SQL
06:05:41 <ddarius> chrisdone_: Using the current defaulting "logic" with an extension to String would still fail to default in that case.
06:06:01 <kenjin2201> Thank you all.
06:06:37 <shachaf> parcs: All of "the rest"?
06:06:41 <ddarius> kenjin2201: In Lisp, for most macros, a good way of handling them is to write (usually higher order) functions and then have macros that expand into calls to them for a bit of sugar.
06:07:33 <parcs> shachaf: probably not
06:07:51 <kenjin2201> ddarius: Then , haskell must restrict more in terms of the syntax.
06:08:28 <ddarius> Indeed, but Haskell's lighter syntax makes that much more palatable and also Haskellers like being explicit.
06:08:30 <merijn> kenjin2201: Haskell restricting more is one of the core features, isn't it? :>
06:09:16 <kenjin2201> hmm...Thank you really. I feel like realizing something that's not clear yet.
06:09:19 <jonkri> when i specify "session :: forall a. (XMLable a, MonadIO m, ClientState s m) => ..." i get errors about s and m not being in the scope. what does that mean?
06:09:32 <ddarius> kenjin2201: As was mentioned, there are things like Template Haskell that allow CL-like macros, but they aren't used too much for a variety of reasons good and bad.
06:09:39 <mjrosenb_> map (\n -> length (fix (\l -> show [take n l]))) [1..20]
06:09:43 <mjrosenb_> > map (\n -> length (fix (\l -> show [take n l]))) [1..20]
06:09:44 <lambdabot>   [5,7,8,10,12,13,15,17,19,21,22,24,26,28,30,32,34,36,38,39]
06:09:55 <chrisdone_> ddarius: Ah, good point. I just tested, it actually does default (e.g show "x", defaults to String). The behaviour I'd want is indeed different.
06:10:15 <Saizan> jonkri: add them to the forall
06:10:17 <kenjin2201> ddarius: Is template haskell  a different implementation of Haskell?
06:10:22 <ddarius> kenjin2201: No.
06:10:34 <ddarius> kenjin2201: It is a very GHC-specific extension.
06:10:48 <sms> [1..3]
06:10:54 <kenjin2201> hmm
06:11:15 <shachaf> reverse [3,2..1]
06:11:33 <Saizan> jonkri: forall is what brings type variables in scope, if you don't use it at all the compiler will insert one for you for all the free type variables in the rest of the type
06:12:01 <Saizan> jonkri: but if you use it you're supposed to take care of all of them
06:12:21 <jonkri> Saizan, what is a free type variable?
06:12:33 <ddarius> Oi.
06:12:59 <mjrosenb_> jonkri: it is what makes polymorphism possible
06:13:00 <ski> jonkri : do you know what a free variable is in an ordinary expression ?
06:13:12 <mjrosenb_> jonkri: it is like the fluxx capacitor of computer science.
06:13:18 <shachaf> @free type variable
06:13:18 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
06:13:37 <Saizan> jonkri: one that doesn't have a corresponding forall in the current type signature or one in the surrounding scope
06:14:02 <shachaf> Type variables want to be free.
06:14:17 <ddarius> shachaf: No they don't.
06:14:22 <Saizan> jonkri: the surrounding scope only matters if you have the ScopedTypeVariables extension
06:15:43 <jonkri> what's the difference between MonadIO m and forall m. MonadIO m?
06:16:05 <parcs> depends on the context
06:16:14 <shachaf> jonkri: m is free in the former.
06:16:22 <ski> the former is a (class) constrant
06:16:36 <jonkri> ah, ok. so what if i don't want m and s to be free, only a?
06:16:45 <shachaf> Er, that's assuming MonadIO is a type constructor, which it isn't.
06:16:51 <ski> (the latter is not a well-formed type expression)
06:16:53 <jonkri> in "session :: (XMLable a, MonadIO m, ClientState s m) => ..."
06:17:14 <Saizan> jonkri: can you give us more context?
06:17:27 <Saizan> jonkri: what you're asking seems confused
06:17:28 <jonkri> sure :)
06:18:17 <ddarius> jonkri: Free type variables are like normal variables not being in scope.
06:18:18 <ddarius> > foo
06:18:18 <lambdabot>   Not in scope: `foo'
06:18:26 <ddarius> jonkri: You don't want any to be free.
06:19:18 <mjrosenb_> forall can be used in any type annotation (assuming the appropriate ghc flags)?
06:19:23 <ski> otoh, you want some variables bound at some places, and others bound at other places
06:19:32 <Saizan> e.g. when you have a signature like (map :: (a -> b) -> ]a
06:20:03 <hpaste> jonkir pasted ‚Äúpoly‚Äù at http://hpaste.org/47717
06:20:10 <mjk> i want haskell to display chinese string, like this: putStrLn "÷–Œƒ",but can't do it, can anyone help me?
06:20:11 <ddarius> ski: I wasn't going to mention that as it happens less so with type variables and not at all without extensions.
06:20:20 <Saizan> "map :: (a -> b) -> [a] -> [b]" is actually a shorthand for "map :: forall a b. (a -> b) -> [a] -> [b]"
06:20:24 <jonkri> Saizan, code is messy, but http://hpaste.org/47717
06:20:34 <mjk> can i use Data.Text.Encoding?
06:20:47 <jonkri> see the line marked with "PROBLEMATIC"
06:21:01 <ski> ddarius : well, it happens with `class' declarations ..
06:21:35 <ddarius> That's true.
06:21:37 <Saizan> there's no annotate button anymore?
06:21:38 <mjk> my computer is WinXP/console
06:21:41 <Saizan> session :: XMLable a, MonadIO m, ClientState s m => s -> [(VariableName, SimpleVariable a m)] -> (StateT s m ()) -> m ()
06:21:47 <chrisdone_> Saizan: I'm adding it now.
06:22:26 <Saizan> jonkri: you want this -> session :: MonadIO m, ClientState s m => s -> (forall a. XMLable a => [(VariableName, SimpleVariable a m)]) -> (StateT s m ()) -> m ()
06:22:32 * ddarius will graciously assume that chrisdone_ took this disruptive approach to spur himself into quickly completing the coding.
06:22:40 <jonkri> oh
06:22:55 <chrisdone_> ddarius: Yep. :-)
06:23:19 <ski> jonkri : s/MonadIO m, ClientState s m/(MonadIO m, ClientState s m)/
06:23:44 <Saizan> chrisdone_: make it so it'll preload the original code in the textarea, thanks :)
06:24:47 <jonkri> it compiles :)
06:24:49 <jonkri> thanks
06:26:37 <ski> jonkri : since the `stateSimpleVariables' field had type `forall a. XMLable a => [(VariableName, SimpleVariable a m)]', there was a good chance that that would be the appropriate type of the function argument which you wanted to put in that field
06:27:15 <shachaf> "Instead, Haskell requires you to be explicit about side effects through Monads." -- is it that hard to say "the type system" instead of "Monads"?
06:27:16 <Saizan> we need a tutorial named "a tour through System F to RankNTypes"
06:27:22 <ski> jonkri : and you need extension `Rank2Types' for this ..
06:27:48 <ski> shachaf : whence ?
06:28:00 <jonkri> ski, hehe, yes, i noticed that :) "forall" scared and confused me a little bit :)
06:28:12 <ddarius> (The real question, though, is: is that a sensible declaration?)
06:28:40 * shachaf momentarily read "Rank12Types" and was somewhat worried about what was to follow.
06:28:58 <shachaf> ski: A post on a website, not here.
06:29:56 <ddarius> shachaf: I don't think it's unreasonable and I don't think saying "the type system" would be better.  The type system knows nothing about effects.
06:31:02 <ddarius> The type system is being leveraged, but it is the API of monads that produces the affect using the type system.
06:31:28 <ddarius> s/affect/effect/
06:31:39 <shachaf> ddarius: A post like that just encourages the "monads are about side effects" mentality. Haskell doesn't *require* you to use Monad for side effects, at any rate -- you can express it however you want, and that just happens to be a common way.
06:32:24 <ddarius> Monads -are- about side-effects from one perspective, which happens to be the perspective commonly used in Haskell.
06:32:31 * ski thinks monads are about *effects*
06:33:09 <ddarius> If you limit "side-effects" to mutable state, then I agree, but I don't know why you would do that.t
06:33:10 <ski> e.g. the list monad is about (anglic) nondeterminism effects
06:33:11 <shachaf> Perhaps "the type system" was a bad substitute.
06:33:39 <shachaf> Fair enough.
06:33:55 * ski agrees with ddarius
06:33:59 <shachaf> This was in response to a post about mutability, but I suppose it was more general.
06:34:44 <mikeg> shachaf: How can you do effects in Haskell without using monads?
06:34:50 <ski> (whether an effect is a side-effect is "just" a POV)
06:35:20 * ddarius considers "effect" and "side-effect" synonyms.
06:35:21 <ski> mikeg : what does "using monads" mean ? does it count if you don't use the `Monad' class nor any of the standard monad operations ?
06:35:23 <shachaf> mikeg: I suppose that depends on what you mean by "effect".
06:35:32 <shachaf> (And by "monad".)
06:35:56 <mikeg> ski: well, `unsafePerformIO (putStrLn "Foo") :: ()` doesn't count!
06:36:14 <ski> i haven't mentioned `unsafePerformIO'
06:38:29 <ski> mikeg : to clarify : i consider using `Maybe', `[]' and `State s' monads just as effectful as using `IO' or `ST s'
06:38:41 * ddarius agrees with ski.
06:39:07 <hpc> also agreed
06:39:40 <hpc> (modulo performance, but that is dons' territory :P)
06:41:01 <ski> i think Haskell has no side-effects (barring partiality and nontermination) -- if you want side-effects for any monad you like, try using e.g. SML/NJ or Scheme, using Andrzej Filinski's Monadic Reflection
06:41:07 <mikeg> Well, that is still using a Monad. Is the effectful part the monad part, though? I don't totally understand how, for example, [] could have "effects"
06:42:03 <ddarius> mikeg: It doesn't "have" effects, it -models- an effect.
06:42:06 <ski> mikeg : given a value of type `m a', for a monad `m', the `m' part of `m a' represents "effects of a computation"
06:42:27 * shachaf supposes he also agrees.
06:42:42 <ddarius> mikeg: When you write in a stylized fashion (monadic style), you can view it as working in a language with the effect modelled by the monad.
06:42:42 <xkb> There's also an implementation of Clean's uniqueness typing for IO I think?
06:43:10 <ddarius> For [], this would correspond to Prolog-style depth-first backtracking.
06:46:12 <ddarius> Adding almost any effect to Haskell would lead to an increase in expressiveness a la Felleisen, and as such, in Haskell as-is requires a global transformation to encode.  That transformation is monadic style.
06:47:21 <mikeg> So, all effects in Haskell are practically encapsulated in a Monad (excluding the effect of running a calculation, perhaps)?
06:48:41 <mikeg> Brings be back to the original question - how can you have side-effects without Monad? I guess by using the draft Haskell style main :: [input] -> [output]?
06:49:00 <ddarius> "Running a calculation" has no effect (except perhaps non-termination).  Any other effect would need to be modelled as a global transformation.  Usually this is done with monads.
06:49:05 <chrisdone_> mikeg: Is that sort of asking how do you have sequence?
06:49:30 <ddarius> mikeg: You can't do I/O without using IO in current Haskell.
06:50:09 <ski> mikeg : imo you can't have side-effects in Haskell, perios
06:50:13 <mikeg> ddarius: Ah, thanks, got it :) chrisdone_: Hmm?
06:50:18 <ski> s/perios/period/
06:50:28 <ddarius> Incidentally, if you wanted to model non-termination in a language without it, such as Agda, this would also require a global transformation and could be done using a partiality monad.
06:50:47 <shachaf> You could probably do IO without using >>=/return, though (if you used unsafePerformIO).
06:50:49 * ddarius agrees with ski (modulo the things ski is implicitly excluding.)
06:50:56 <chrisdone_> mikeg: Are you asking how to have effects without monads in Haskell, or any pure lazy language?
06:51:45 <ski> shachaf : before the advent of monadic I/O, I/O was done in dialogue-style, often wrapped up in continuation-passing-style
06:51:58 <xkb> ski: mikeg: maybe there's something in this paper: Porting the Clean Object I/O Library to Haskell
06:52:02 <xkb> @Porting the Clean Object I/O Library to Haskell
06:52:03 <lambdabot> Unknown command, try @list
06:52:04 <shachaf> Would Reader ((a -> a) -> a) be a reasonable way to model non-termination?
06:52:14 <mikeg> Well, limiting it to Haskell would be easier for me, since I'm not familiar with other pure lazy monadic languages
06:52:17 <shachaf> ski: Right -- I was replying to the "current Haskell" comment.
06:52:22 <ddarius> xkb: Object I/O is a GUI library.  Not an I/O framework.
06:52:43 <ski> xkb : i would be very surprised if one could model Clean's uniqueness typing in Haskell ..
06:52:45 <ddarius> shachaf: That doesn't even make sense.
06:53:49 <shachaf> I mean passing around fix explicitly.
06:54:04 <mikeg> ski: ty, i'll read it
06:54:35 * ski wonders why shachaf would want to pass around `fix' explicitly
06:54:40 <ddarius> shachaf: There is no fix to pass around.  So you could write things in that monad that uses a "fix" in the state, but (a -> a) -> a is uninhabited.
06:54:54 <ski> mikeg : read what ? :)
06:55:12 <mikeg> Porting the Clean Object I/O Library to Haskell, oh @xkb
06:55:14 <ddarius> mikeg: Haskell isn't a "monadic" language.
06:55:37 <shachaf> Oh. Yes.
06:55:51 <mikeg> "supports monads" (preferably built-in)?
06:56:21 <ddarius> mikeg: Other than some very light sugar, monads are just a library.
06:56:32 <xkb> There are a few other papers on porting Clean's type system to haskell (Uniqueness typing)
06:56:51 <xkb> the one I mentioned focusses mainly on MVars though, not on IO
06:56:56 <shachaf> Well, that and the fact that you need IO to do I/O.
06:57:18 * shachaf should probably sleep, not having done so in the night.
06:57:24 <lispy> ddarius: any ideas how I can debug the following: I have an FFI binding that works great when I statically link it all together (on osx), but when I build a .dylib and load it into ghci it crashes when I run my initialization function
06:57:58 <ddarius> lispy: gdb? (or presumably OS X has a nicer debugger)  I know nothing about anything Apple.
06:57:58 <lispy> crashes == ghci segfaults
06:58:21 <lispy> ddarius: fair enough.  I already tried gdb/valgrind.  Surprisingly unhelpful
06:58:42 <ddarius> I don't know about valgrind, but I'm not surprised gdb is unhelpful.
06:58:51 <lispy> valgrind might help but it causes ghci to break
06:59:03 <lispy> ghci can't do input inside of valgrind :(
06:59:21 <shachaf> lispy: Mine can.
06:59:24 <rothwell> the os x linker is notoriously buggy... it's likely not your fault
06:59:38 <lispy> rothwell: Maybe there is a workaround?
06:59:44 <shachaf> What's the FFI binding? Have you tried  it in other OSes?
06:59:53 <rothwell> maybe... unfortunately i've not used it for a couple of years
07:00:07 <rothwell> was exactly this sort of thing that finally turned me off
07:00:14 <lispy> shachaf: Yes I have, but on other OSs I can let ghc build the shared lib instead of needing to do it manually via make
07:01:49 * lispy thinks this must a be a solveable issue but isn't sure how to elucidate the problem
07:02:35 <ddarius> lispy: Do other FFI bindings doing similar things work?  I.e. if you bind to a trivial C function and attempt to link it, does it crash?
07:03:42 <lispy> oh good idea
07:03:54 <lispy> I can bind something pure like sine and see what happens
07:09:15 <luite> what kind of concurrency things would you use for this problem: I have a pool with a fixed number of workers. Each worker has a client and a state. Each client can do requests and require a certain worker state. The required state can change every request. Doing a request on a worker with the correct state and client is cheap. reassigning a worker to a different client is most expensive, changing the state is less expensive than reassigning to other clients. Ev
07:11:17 <Jafet> Sounds very much like SMP scheduling.
07:11:35 <Jafet> Er, no, only a little bit
07:13:11 <Saizan> got truncated at "Ev"
07:13:27 <haskelldude> how to check if a given char is in a list?
07:13:31 <luite>  Every client can have at most n workers assigned to it at the same time.
07:13:34 <luite> haskelldude: elem
07:13:36 <Peaker> Saizan: funny, I got it truncated at ". E"
07:14:00 <Jafet> IRC is a modern internet protocol with reliable data delivery characteristics
07:14:04 <ski> > 'k' `elem` "haskelldude"
07:14:05 <lambdabot>   True
07:14:31 <shachaf> luite: Is this for your wolf? What are the states?
07:15:20 <luite> the main problem is what to do when a client has already been assigned the max number of workers, and all are busy. the first one with the correct state to become available should be used. but other requests before it might want to reset those to a different state
07:15:24 <luite> shachaf: yes
07:15:40 <Peaker> luite: Maybe have a list of clients, each client be a thread-safe list of tagged states, each state be a thread-safe list of tagged workers, each worker is a tagged MVar listening for work?  That way a worker can be moved to different states/clients, and it is easy to find a worker?
07:16:40 <luite> shachaf: workers = ghc api process, state is currently loadeded haskell modules. clients are actual web clients. workers are completely restarted before being used by a different client
07:16:41 <ddarius> Bloody christ.  Just model each worker as a concurrent process as fits the problem.
07:17:03 <Peaker> luite: why not import everything everywhere?
07:17:24 <Peaker> luite: (fork a state that's already imported, perhaps)
07:17:43 <Peaker> ddarius: that sounds like "god damn it, just solve the problem" :)
07:18:04 <Jafet> I thought GHC didn't like forking.
07:18:07 <luite> Peaker: already doing that for all installed pacakges, but this is about code that users can edit
07:18:08 <homie> are they only concurrent or also coconcurrent ?
07:18:34 <opqdonut> or merely ncurrent? :)
07:18:48 <luite> ddarius: what are the haskell data types to do that? :p
07:18:54 <Jafet> Concurrant
07:19:20 <opqdonut> you want some concurrant sauce with that?
07:19:35 <Peaker> luite: is importing compiled code expensive enough to warrant these mechanisms?
07:19:39 <ddarius> luite: Channels and IO.
07:20:26 <lispy> ddarius: seems to work when I bind to sin
07:20:53 <lispy> guess that menas I should debug the initialization function itself
07:20:55 <luite> Peaker: loading and linking the binary packages takes a few seconds, that's way to long for anything interactive
07:21:37 <luite> Peaker: starting a worker for a new client means forking this state, which is relatively fast, but still much slower than just handling a request by an existing worker
07:21:45 <tswett> > "tswett"
07:21:46 <lambdabot>   "tswett"
07:22:40 <Jafet> Oh, so forking works
07:23:39 <ddarius> luite: Just have the clients talk to a manager process that fetches a worker for them.  The workers tell the manager process their state.  The manager process uses whatever scheme it likes to choose a worker to handle a client's request.
07:23:56 <Jafet> Can't you fork an instance that's loaded some modules, and then load extra modules?
07:25:21 <luite> Jafet: yes that's what I do
07:25:27 <luite> ddarius: yes I was thinking channels and mvars, but I don't know how exactly to do this. the problem is that if a client has 3 workers, then choosing a worker at the time of request is quite unoptimal because you could choose the one working on a really long request.
07:26:11 <luite> Jafet: that's the difference between forking (really long initialization time) and loading extra modules (relatively long) :p
07:26:14 <ddarius> luite: Who said the manager had to assign a worker immediately?  Anyway, what other times would you choose?
07:26:30 <Jafet> Are you searching for an algorithm, or an implementation of some chosen algorithm?
07:27:08 <luite> ddarius: when a worker becomse available again could be a good time
07:27:19 <ddarius> Then do it then.
07:27:35 <ddarius> That's the magic of concurrent processes.  They are much less coupled.
07:28:47 <luite> Jafet: I guess there's not a complete algorithm for this already, I was looking for tips on data structures or concurrency primitives that could make implementing this easier
07:29:14 * ddarius wishes the "standard" concurrency libraries used CML's insights.
07:29:30 * edwardk waves hello.
07:29:30 <ddarius> luite: The problem, as far as I can tell, just comes down to you choosing some heuristic.
07:29:40 <edwardk> preflex: xseen roconnor
07:29:41 <preflex>  roconnor was last seen on freenode/#haskell 1 day, 55 minutes and 55 seconds ago, saying: yes
07:29:49 <Jafet> There probably are ten complete algorithms for this, each specialized to some other situation
07:30:36 * ddarius rescues hello from edwardk's brutal clutches.
07:30:40 <Jafet> You're going to make this a public service, right? Perhaps you could just do it the naive way and collect usage data first. I think optimizing for whatever the common case is should be enough.
07:31:09 * edwardk apologizes for any damage he may have caused hello with his thoughtless waving.
07:31:44 * chrisdone_ discretely wipes the drops of hello that were splashes on his corduroy trousers
07:32:11 <edwardk> aavogt: http://www.cas.mcmaster.ca/~anand/DSL2011.html is a quick announcement Chris put up so we can try to get koninkje into the country.
07:33:00 <ddarius> Advanced category theory, eh?
07:33:07 <luite> Jafet: I already have some data about the test, where I used a simpler pool that just resets the state of the least recently used worker if none with the correct state is available. problem is that that ended up resetting too many workers for each client
07:33:10 <edwardk> i didn't write the blurb
07:33:26 <edwardk> i'll harass him and clean it up a bit later ;)
07:33:39 <lispy> hey edwardk
07:33:41 <Peaker> ddarius: what are CML's insights?
07:34:10 <edwardk> he needed some kind of announcement to make it official enough that the folks at the border would acknowledge that wren needed to be here.
07:34:15 <edwardk> heya lispy
07:34:22 <ddarius> Peaker: I highly recommend you read Reppy's thesis on it.  I significantly underestimated what was there when I first heard of CML.
07:34:27 <sanjoyd> Hi! I'm looking through the GHC source, trying to figure how it represents the AST. Any pointers on where I should start?
07:34:41 <ddarius> edwardk: You should have put him as one of the speakers or as a guest.
07:34:49 <edwardk> ddarius: the most categorical it is going to get is that i'm going to use the codensity monad a lot, and we'll be talking about initial and final encodings
07:34:51 <edwardk> agreed.
07:34:57 <lispy> Once again, perl has completely mystified me.  I want to install ack (trying via cpan).  It gives no error message but I also do not have ack installed now...hmm
07:35:17 <shachaf> lispy: Maybe it's called ack-grep?
07:35:23 <edwardk> so not very advanced category-theory-wise
07:35:42 <Jafet> luite: hm, could you explain what's expensive about forking, again?
07:35:44 <lispy> shachaf: I guess it's "cpan App::Ack" instead of "cpan ack"
07:36:10 <edwardk> oh, and free monads. also not scary
07:36:36 <ddarius> Surely everyone is an expert at free monads by now.
07:36:47 <edwardk> they will be by the end of the workshop ;)
07:37:23 <lispy> "free monads: you get what you pay for"  <-- is this your workshop?
07:37:40 <luite> Jafet: well forking at least copies some memory pages that are modified, and all client-specific code needs to be loaded and typechecked. (the last part is also done when the state is reset)
07:37:42 <edwardk> hah
07:38:04 <edwardk> i was leaning more for "confessions of a used (domain-specific) programming language salesman"
07:38:41 <Jafet> I don't see how that's more expensive than "reset a worker", sorry
07:39:09 <edwardk> nodding to erik meijer's paper from icfp06
07:41:32 <lispy> is __stdcall in C the same as ccall in the FFI?
07:41:43 <lispy> I guess it probably depends on the C compiler
07:42:10 <luite> Jafet: hmm, I'm probably not very consistent in my terminology. In concrete terms, there's restarting a worker process, and changing the loaded modules. restarting a process takes much longer, according to my measurements, than loading a relatively small module
07:46:25 <ddarius> lispy: No, it's not.
07:47:07 <ddarius> There is a stdcall calling convention for the FFI.
07:50:16 <lispy> I just tried using stdcall in the FFI but it's not supported on my platform so it defaults back to ccall
07:50:24 <lispy> Warning: the 'stdcall' calling convention is unsupported on this platform, treating as ccall
07:50:35 <lispy> that's probably fine actually
07:51:30 <hanDerPeder> is there a function that yields the first element in a list that is true for some predicate?
07:51:57 <ddarius> If the function you are trying to call is actually using the stdcall calling convention and your code is trying to call it with the C calling convention, it's going to break horribly.
07:52:08 <ddarius> :t find
07:52:09 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
07:52:33 <mjrosenb> :t \p -> head . filter p
07:52:34 <lambdabot> forall a. (a -> Bool) -> [a] -> a
07:53:11 <parcs> ;t listToMaybe .: filter
07:55:35 <mjrosenb> :t .:
07:55:36 <lambdabot> parse error on input `.:'
07:55:40 <mjrosenb> :t (.:)
07:55:40 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
07:56:27 <mjrosenb> so .: is fmap . fmap?
07:56:33 <mjrosenb> :t fmap . fmap
07:56:34 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
07:56:44 <parcs> yep
07:58:29 <benmachine> I imagine a __stdcall macro expands to nothing on platforms that don't support stdcall
07:59:52 <lispy> i think I narrowed it down a bit.  It seems to be caused by a platform specific init function
08:04:28 <lispy> I found the line that crashes
08:04:28 <lispy> memset( &_glfwLibrary.hints, 0, sizeof( _glfwLibrary.hints ) );
08:04:36 <lispy> _glfwLibrary is a global
08:04:48 <lispy> So, maybe I'm having some issue referening a global?
08:04:55 <lispy> I did build with -fPIC
08:05:59 <benmachine> what's the value of &_glfwLibrary.hints?
08:07:25 <benmachine> well I guess it wouldn't matter too much
08:07:43 <benmachine> you could see if gdb can print _glfwLibrary
08:07:48 <lispy> it has this type
08:07:49 <lispy> _GLFWhints      hints;
08:08:38 <lispy> so hints is a struct full of int flags
08:08:43 <lispy> it's very simple
08:08:54 <benmachine> can gdb print it?
08:08:54 <lispy> I'll try in gdb
08:09:43 <lispy> running, ghci in gdb is non-trivial by the way
08:09:46 <lispy> I had to make a script
08:10:10 <benmachine> could you get a similar result by using runhaskell?
08:10:17 <benmachine> runhaskell -main-is whatever foo.hs
08:10:31 <benmachine> (in that order, otherwise -main-is is given as an argument to foo.hs)
08:12:23 <lispy> benmachine: I set a break point and it eventually resolved it, but it crashed before the break point happened: http://hpaste.org/47718
08:12:37 <AtnNn> Is anyone else able to install poppler? how? I get this error: http://hackage.haskell.org/packages/archive/poppler/0.12.2/logs/failure/ghc-7.0
08:12:39 <lispy> benmachine: which is odd.  if I comment out the body of that function the code works but with it in there it crashes
08:13:40 <benmachine> lispy: doesn't necessarily mean it crashes during that code :P
08:14:09 <lispy> oh true
08:14:14 <jonkri> i'm trying to call "session :: (MonadIO m, ClientState s m) => s -> (forall a. XMLable a => [(VariableName, SimpleVariable s m a)]) -> (StateT s m ()) -> m ()" with "SimpleVariable State IO Pingpong" as "SimpleVariable s m a" where "Pingpong" is an instance of "XMLable". however, i get an error "could not deduce (a ~ Pingpong) from the context (XMLable a)". code: http://paste.pocoo.org/show/405047/
08:14:17 <lispy> But, odd that it could crash before the berak point
08:15:17 <lispy> bah, gdb on osx doesn't support -tui
08:15:29 <jonkri> is there some way where i can maintain polymorphosism in the simple variable list while allowing the function calling session to know the type Pingpong explicitly
08:24:53 <mheld> hey y'all
08:24:58 <rovar> oy
08:25:03 <lispy> benmachine: according to printf:_glfwLibrary.hints=0x2041170c0
08:25:03 <lispy> sizeof(_glfwLibrary.hints) = 56
08:25:26 <mheld> anybody here ever read computational semantics with functional programming?
08:25:26 <lispy> benmachine: that first line is actuall the address, typo in the printf
08:25:41 <benmachine> lispy: did you try to print the value itself?
08:25:59 <benmachine> or I dunno, its first element or something
08:26:58 <lispy> I can, but what are we hoping to get from that?
08:28:34 <benmachine> lispy: I admit I'm somewhat guessing, but I'm trying to get gdb to either prove the memory is accessible or tell you it isn't
08:29:35 <lispy> okay, then how about I explicitly write 0 to each of them
08:29:51 <benmachine> that would work as well
08:31:05 <ddarius> Really the question is probably can you write to ((byte)(&_glfwLibrary.hints))[55]
08:31:42 <lispy> writing to them explicitly is a crasher
08:31:48 <lispy> I'll try writing to some of them
08:32:34 <msieradzki> btw why does haskell binding (even glfw-b) not expose major/minor as hints (so that you can create ogl 3.2 context)
08:32:38 <benmachine> lispy: are you writing to them from code or from gdb? gdb usually says if you're trying to write to somewhere you shouldn't iirc
08:32:52 <benmachine> (which is what I was aiming for)
08:33:14 <lispy> I'm doing it from code
08:33:31 <benmachine> oh
08:33:31 <lispy> writing to the first one is a crasher
08:33:35 <lispy> I can try from gdb
08:33:57 <rostayob> are the operation on Data.Set and Data.Map lazy? so will be something like 'S.findMin . S.filter $ foo' lazy?
08:34:14 <lispy> benmachine: what is the command?
08:34:30 <benmachine> lispy: um, I can't remember, but you can try printing them with print
08:34:57 <lispy> hmm
08:35:10 <benmachine> I'm sure there is a command though
08:35:11 * benmachine fiddles
08:35:29 <lispy> I ran 'run' and that put me in ghc.  Then I caused the library to load, now how would I go back to gdb?
08:35:43 <lispy> oh, C-c
08:36:22 <benmachine> (see: help set)
08:36:34 <lispy> hmm
08:36:35 <lispy> (gdb) print _glfwLibrary.hints.refreshRate
08:36:35 <lispy> Attempt to extract a component of a value that is not a structure.
08:36:45 <lispy> that would be valid in C
08:36:50 <benmachine> odd
08:37:10 <lispy> gdb can see _glfwLibrary
08:37:31 <benmachine> print _glfwLibrary.hints?
08:37:33 <lispy> But it doesn't have any type info, probably because I couldn't get the debugging symbols to stick around (cabal cleaned them up)
08:37:41 <lispy> same error
08:38:17 <benmachine> print _glfwLibrary?
08:38:20 <benmachine> :P
08:38:25 <lispy> oh, print {TYPE}ADREXP /me tries
08:39:22 <benmachine> can you persuade cabal to not clean them up?
08:42:41 <lispy> getting cabal to do anything is like asking a favor from someone who doesn't like you
08:43:57 <benmachine> :P
08:44:31 <lispy> Did I already mention this code works fine when statically linked?
08:44:38 <lispy> So, I think this is a matter of getting some linker options right
08:45:01 <benmachine> oh, yes that sounds fair
08:45:52 <dons_> Cale: i want a tool like vacuum that shows evaluation steps as a .svg
08:46:00 <dons_> do we have such a tool?
08:46:06 <ddarius> Cabal is much more rational or at least predictable than someone who doesn't like you.
08:46:09 <Cale> Sadly we do not.
08:46:31 <Cale> dons_: The closest thing I know of is a different programming language, and unreleased.
08:46:43 <benmachine> ddarius: I like how you imply that someone could only possibly dislike you if they were irrational :P
08:46:43 <ddarius> Hat might have been able to do something sort of like that.
08:47:02 <Cale> (http://www.cas.mcmaster.ca/~kahl/HOPS/)
08:47:41 <dons_> ddarius: yeah. that's the closest thing. the redex trail debuggers
08:47:44 <dons_> freja
08:47:47 <Cale> Hey, edwardk should take the time to bug Dr. Kahl to release some of his stuff, given that he's up there...
08:48:11 <dons_> oh yes.
08:48:43 <msieradzki> are there any known (especially obvious to some but not me) bugs with respect to using GHCi to load haskell binding to C++ DLL compiled with mingw on win32?
08:48:53 <Cale> It frustrates me a little bit that Dr. Kahl is sitting on an awesome relations library and a bunch of other cool stuff and never releases it online :P
08:49:08 <dons_> old school
08:49:10 <ddarius> Cale: Just go knock on his door.
08:49:18 <Cale> ddarius: I'm not in the same city
08:49:26 <lispy> msieradzki: Sounds familiar.  I'm having issues loading a dylib on osx in ghci :)
08:49:27 <ddarius> Cale: I don't see how that stops you.
08:49:31 <Cale> lol, I guess.
08:49:46 <lispy> msieradzki: but I don't know any specific bugs. It does feel like a black art.
08:49:50 <dons> http://www.ittc.ku.edu/csdl/fpg/Tools/Hood
08:49:59 <dons> i keep forgetting about andy's debugger
08:50:43 <Cale> I could make a day trip to Hamilton on a bus to go visit... I probably should given that it would be nice to attend some of Edward's workshop.
08:51:19 <Cale> It's kinda troublesome not having a driver's license or a car. :)
08:52:38 <ddarius> Cale: Where are you?
08:52:45 <Cale> Brantford
08:53:33 <ddarius> Pah, 37.7km is nothing.
08:53:46 <Cale> It's quite a way to walk
08:54:05 <ddarius> You could walk there and back in a day.  A long, exhausting day, but a day.
08:55:08 <benmachine> really? at 4km/h that's ten hours ._.
08:55:20 <benmachine> maybe I am a slow walker
08:55:53 <ddarius> benmachine: A somewhat fast walk is 4mph or 6 2/3km/h, so about five hours.
08:56:13 <Cale> 10 hours there + 10 hours back = 20 hours -> still technically less than a day
08:56:17 <msieradzki> lispy, it just crashes horribly and when I click debug in MSVC the only trace I'm left with is that Bullet (C++ lib I'm using) crashes while freeing something but that's above the stack entry that probably contains abort() call, and finding the cause feels a bit like black art, I should probably try to make a testcase
08:56:29 <msieradzki> unless it's just "oh we don't expect ghci to be able to that yet"
08:56:37 <benmachine> ddarius: a somewhat fast walk that you can keep up for five and a half hours
08:56:50 <ddarius> benmachine: Easily unencumbered.
08:57:00 <ddarius> 4km/h is a really slow walk.
08:57:04 <benmachine> (personally I'd cycle, but even that would take a few hours)
08:57:15 <ddarius> You can easily keep 5km/h encumbered.
08:57:57 <ddarius> benmachine: My normal walking about is probably over 4mph, though I am a bit of a fast walker.
08:58:11 * shachaf suspects a bus would still be faster.
08:58:14 <benmachine> :P
08:58:20 <shachaf> Apparently train+bus would get there in ~2 hours.
08:58:22 <ddarius> Certainly when I'm trying to get somewhere I walk at least 4mph.
08:58:28 <benmachine> ddarius: yeah possibly I'm confusing my mph with my kmph
08:59:00 <benmachine> but man, walking anywhere at any speed for more than a couple of hours would not be fun for me :P
08:59:24 <dons> Cale: you can use 'hood's observe from ghci to trace
08:59:48 <dons> still fine tuning
08:59:50 <ddarius> vacuum is probably better than Hood's observe.
08:59:50 <dons> but it might work
08:59:52 <lispy> msieradzki: I'm really not sure if dlls are supported at the moment, but I thought they were.
09:01:25 <Peaker> ddarius: that CML dissertation is a pretty long one
09:02:06 <Peaker> ~180 pages
09:02:19 <MasseR> Wow gtk looked nice with F#
09:02:24 <Peaker> (+ overheads)
09:02:45 <ddarius> 180 pages is about typical for a PhD thesis.
09:04:24 <haskelldude> im playing around with calculator functions, i did a base convertor, and need a few more ideas... pls suggest... i need to use my own higher order functions as much as possible..
09:05:46 <lispy> If I rewrote GLFW in Haskell, I would not be having this issue....
09:05:55 * lispy tries to fight the urge
09:06:51 <Nimatek> haskelldude: http://projecteuler.net/
09:17:16 <dons> Cale: hood output, http://stackoverflow.com/questions/6322921/explain-how-a-recursive-haskell-list-function-works/6322964#6322964
09:17:31 <dons> i need to add a tracing mode to vacuum, i think
09:17:38 <dons> so i can both observe steps, and view sharing
09:18:51 <jonkri> if i have a type "data A = A { a :: (forall t. Ord t => [t -> ()]) }", and a function "b = A { a = [c] }"... is there somehow i can make c "c :: Integer -> ()" without getting errors like these: http://paste.pocoo.org/show/405086/
09:20:03 <jonkri> i want the [c] list to be polymorphic and c to be explicit
09:21:29 <benmachine> jonkri: I think the type "forall t. Ord t => [t -> ()]" says, a list of functions that can take *any* t with Ord and return ()
09:21:42 <benmachine> so c :: Integer -> () doesn't do that
09:22:08 <jonkri> of course :) thanks
09:22:20 <benmachine> jonkri: I think! I'm not an expert on foralls :)
09:22:56 <luite> Cale: can you update your fingertree-psqueue package to work with base 4.* ?
09:23:09 <arcatan> (functions of type Integer -> () sound either useless or unsafe...)
09:23:53 <benmachine> arcatan: useless except for working out how to use rank-N types :)
09:24:23 <arcatan> ah
09:27:49 <scooty-puff> is it possible for do notation for regular monads and do notation for indexed monads to both be present in the same source file?
09:28:43 <NisseP> not unless you can write a `return`, `(>>=)`, etc, that works for both
09:29:42 <NisseP> not return. (>>=), (>>), fail. but still.
09:29:53 <Cale> luite: um, sure
09:30:04 <Cale> luite: I was unaware that anyone actually used that package :)
09:30:27 <scooty-puff> ok
09:30:28 <Cale> luite: It's probably slower than psqueue
09:30:29 <scooty-puff> thanks
09:30:52 <scooty-puff> (maybe slip in via arrow's do notation?  not really familiar with it)
09:31:02 <Cale> (I made it as an example for using fingertree more than anything)
09:31:56 <NisseP> nor am I, sorry
09:32:46 <Cale> dons: nice :)
09:33:05 <Cale> dons: I wasn't aware that hood was still maintained, that's pretty cool
09:33:20 <Cale> I know about the arrow do-notation
09:33:30 <Cale> But... I'm not sure what you want to do with it
09:33:30 <luite> Cale: oh I used it in an old test program and now I need something similar. I thought I'd use fingertree-psqueue again, but I can use PSQueue instead if that's better :)
09:33:52 <NisseP> use it for monads, I think. Or indexed ones.
09:33:54 <Cale> luite: Probably... it would be interesting to know how it holds up performance-wise
09:34:01 <NisseP> and regular `do` for the other ones.
09:34:33 <Cale> But yeah, I'm betting that psqueue is faster, given that it's constructed specifically to be a priority search queue, and isn't just a specialisation of finger trees with an appropriate monoid.
09:34:38 <scooty-puff> yeah, splitting out my Indexed monad def to not use >>=, >>, fail, and have a submodule export those, at least to make it work better together
09:34:44 <ompalomps> Cale: Probably doesn't, Haskell isn't to be used for performance critical code. I hear they do it over at Galois but a lot of things of dubious nature goes on over there.
09:34:54 <dons> Cale: built out-of-the box from hackage.
09:35:01 <dons> ompalomps: ??
09:35:05 <ben> heh
09:35:08 <Cale> dons: Yeah, it looks like someone updated it
09:35:15 <ompalomps> dons: the showers of galois
09:35:24 <Cale> ompalomps: what?
09:35:33 <ompalomps> Oh come on you guys
09:36:27 <Cale> scooty-puff: Have you seen: http://hackage.haskell.org/package/ixdopp
09:36:27 <chrisdone> ‡≤†_‡≤†
09:36:59 <Cale> btw, what are people using indexed monads for?
09:36:59 <ompalomps> Hey I'm not against it
09:37:04 <Cale> (I'm just curious)
09:37:08 <luite> I'm also looking for something like a Map, with (Ord a, Ord b), with fast a -> Maybe b,  and b -> [a] lookups
09:37:19 <KirinDave> Wait. Indexed monads now?
09:38:01 <ompalomps> btw dons stole my socks
09:38:02 <KirinDave> I was just getting comfortable with monads. Now there is a whole another type?
09:38:10 <dons> KirinDave: yeah, some things are only monads when indexed through a structure (canonical example is Set via Ord).
09:38:20 <dons> they're not really well supported in Haskell, but common in e.g. Agda
09:38:26 <Cale> class ParameterisedMonad m where
09:38:26 <Cale>   return :: a -> m s s a
09:38:26 <Cale>   (>>=) :: m s1 s2 t -> (t -> m s2 s3 a) -> m s1 s3 a
09:38:47 <ompalomps> When will Haskell get linear types so we can dump this ST monad mumbo jumbo?
09:38:52 <Cale> ^^ I'm assuming this is the sort of indexed monad being discussed
09:39:03 <dons> KirinDave: just be aware that things like Set can obey the monad laws, even if that's not easy to tell Haskell about
09:39:05 <ben> ompalomps: What's a linear type?
09:39:26 <KirinDave> dons: Sometimes I feel like learning haskell is roughly akin to running out of water about halfway across the atlantic while on a an early colony ship.
09:39:27 <chrisdone> Ah, it's the troll from yesterday, with a new nickname. (troppa)
09:39:45 <Cale> ompalomps: Even if Haskell had linear types, we'd still want to define a monad to handle the awkward threading of the unique values.
09:40:07 <Cale> ompalomps: and it'd end up looking pretty much like ST
09:40:20 <ompalomps> Well I want linear types and I want it now
09:40:52 <Cale> ompalomps: Why?
09:41:01 <Cale> What would you use them for?
09:41:19 <ompalomps> The exact same thing I use the ST monad for
09:41:28 <ompalomps> I just don't like the ST monad
09:41:35 <ompalomps> it's the work of the devil or something
09:41:37 <ben> ompalomps: Do you like anything about haskell?
09:41:41 <Cale> heh
09:41:51 <ompalomps> ben: yeah I like dons
09:42:05 <Cale> ompalomps: I've never really found so much occasion to use the ST monad personally.
09:42:05 <ompalomps> dons is almost the human incarnation of haskell
09:42:52 <Cale> I guess it's nice that it's there if I'm translating some theoretically pure algorithm from imperative pseudocode, but usually there's a better translation than that.
09:42:54 <ompalomps> Well one day you might need to write something
09:44:03 <lpsmith> Cale: it's useful for efficiently building immutable arrays using mutation :)
09:44:24 <Cale> lpsmith: That's true
09:45:28 <ompalomps> Also who came up with Iteratees?
09:45:32 <Cale> Apart from things like that, very few externally pure algorithms really require an unbounded amount of mutable state internally.
09:45:36 <ompalomps> That's the dumbest idea ever
09:46:19 <Cale> ompalomps: The dumbest idea ever, I don't know. But I'll agree with you about there being something a little off with iteratees.
09:46:30 <Cale> At least, with most of the presentations of them that I've seen.
09:46:51 <ompalomps> A datatype that feels like category theory
09:47:04 <ompalomps> It just keeps piling up definitions
09:47:09 <ompalomps> what the fuck?
09:47:09 <Cale> My problem with iteratees is that they don't look *enough* like they came from category theory.
09:47:50 <ompalomps> lol you need to get your head examined
09:48:00 * hackagebot authenticate 0.9.1.2 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.9.1.2 (MichaelSnoyman)
09:48:08 <Cale> They're a pragmatic solution to the problem, and they certainly perform well.
09:48:21 <KirinDave> Okay.
09:48:22 <Cale> But they're a little bit less than completely beautiful.
09:48:32 <KirinDave> Are iterator objects considered 'functional'?
09:48:32 <ompalomps> beefed up continuations
09:48:50 <KirinDave> Because I was reading http://www.amk.ca/python/writing/functional
09:48:54 <adimit> they're certainly a little unwieldy, and the documentation is too sparse (from a non-theoretical user point of view.)
09:49:12 <KirinDave> And it's like reading an alternate universe version of functional.
09:49:23 <ompalomps> You have to derive them to understand them almost
09:49:28 <ompalomps> that is stupid
09:49:41 <Cale> KirinDave: sure, kinda. In Haskell, they're just functions X a -> [a]
09:49:42 <adimit> absolutely every intro to iteratees first derives them.
09:49:54 <adimit> which is why the documentation sucks.
09:50:13 <ompalomps> lol did I scare dons away?
09:50:13 <KirinDave> Cale: Well..
09:50:19 <KirinDave> Cale: Look at the link.
09:50:26 <KirinDave> The way they describe them doesn't strike me as "functional"
09:51:31 <Cale> ompalomps: dons is a busy guy
09:51:33 * tommd has been programming too much Gallina.  Haskelling with syntax of "let x := ... in match e with | blah => expr"
09:52:06 <ompalomps> he needs to take time off to get trolled more often
09:52:07 <Cale> KirinDave: Well, it's python, so what do you expect? :)
09:52:19 <KirinDave> Cale: A connection, albeit a rough one, to reality?
09:52:50 <Cale> KirinDave: Basically iterators are the same thing as lazy lists, at least when you keep things pure.
09:52:53 <KirinDave> Cale: I mean, that is just ... weird.
09:53:12 <Cale> So you can build up some of the functional programming paradigm from that.
09:53:49 <ddarius> KirinDave: You can't trust the Canucks.
09:54:01 <KirinDave> ddarius: Wut?
09:54:22 <ompalomps> Has anyone made a functional language without garbage collection?
09:54:34 <adimit> that sounds like a nightmare.
09:54:40 <Cale> ompalomps: That would be dumb.
09:54:41 <ompalomps> Or a big fat runtime?
09:54:51 <ddarius> It's been done.  Multiple times.
09:54:51 <KirinDave> Yeah, some schemes
09:54:55 <Cale> ompalomps: Without a runtime, sure.
09:54:59 <KirinDave> Bigloo I think it was?
09:55:07 <KirinDave> It had a clever stack-based collection system
09:55:24 <Cale> I suppose it depends on what you mean by "garbage collection"
09:55:48 <ompalomps> Just stackframe allocation
09:55:57 <ompalomps> Nothing else
09:55:59 <KirinDave> ompalomps: Yeah, I think it was bigloo that did that.
09:56:00 <Cale> But there's got to be some automatic way to collect garbage. Manual memory management doesn't really fit with how FP works.
09:57:09 <Cale> You can do region inference.
09:57:35 <Feuerbach> Why do type classes and type constructors share the namespace? Can it lead to ambiguity if I have eg. a type named Monad?
09:57:51 <Cale> Feuerbach: I don't think it can...
09:58:07 <alt-nick> yeah, I often want to make classes and types with the same names and am not able to
09:58:39 <chrisdone> dankna: Like what?
09:58:54 <ddarius> Cale: One way to avoid garbage collection is not to allocate any memory.
09:59:28 <Cale> Yeah, I suppose.
09:59:35 <ddarius> (Another way is not to deallocate any memory...)
09:59:36 <dankna> well, I came up with different names that worked okay, but for example I have three types Window, BrowserWindow, DocumentWindow, and I wanted a typeclass that could convert either of the two specialized kinds into the general kind, and the general kind into a Maybe of either specialized kind.
10:00:09 <dankna> I eventually called the typeclass WindowKind, I think
10:00:28 <dankna> but my first instinct was to call it Window, which of course I couldn't
10:01:13 <chrisdone> Cale: Isn't Ur GC-less?
10:02:08 <chrisdone> ‚ÄúThe Ur/Web compiler also produces very efficient object code that does not use garbage collection.‚Äù http://www.impredicative.com/ur/
10:04:10 <Cale> chrisdone: I don't really know anything about Ur, but... people have different ideas about what garbage collection entails. It's probably doing something to automatically statically determine what deallocations are required, but I don't really know.
10:04:52 <dankna> sounds interesting, actually
10:04:56 <benmachine> haskell doesn't have garbage collection, GHC does :P
10:05:46 <Cale> benmachine: That's a good point
10:06:14 <benmachine> (JHC didn't until recently, but I don't think that counts)
10:09:10 * lispy gets annoyed with ghci
10:13:53 <tommd> GHCi gets annoyed with its entire user base.
10:14:12 <lispy> tommd: do you know much about dylibs and ghci on osx?
10:14:19 <tommd> Nope
10:14:21 <lispy> For starters, why does it need a dylib...
10:14:25 <tommd> Particularly not the osx part.
10:14:59 * lispy is not fond of segfaults
10:16:31 <lispy> Interesting
10:17:15 <lispy> I built the code with debugging (the C bits, in the from of printf statements).  I then rebuilt just the C bits with the debugging removed, copied the new .dylib into place and when I load things up in ghci it still prints the debug messages
10:17:27 <lispy> That makes me think ghci doesn't really use the .dylib
10:18:12 <tommd> huh.
10:18:28 <tommd> Can you use a custom dynamic loader and just have it crash any time that lib is called?
10:18:49 <tommd> Might be annoying/hard if there are legit uses of other dynamic libraries by GHCi though.
10:19:21 <tommd> I'm rather surprised there aren't more flexible / run-time configurable dynamic linker loaders out there.
10:21:06 <lispy> running strace on it now to see what files ghci tries to open
10:21:27 <lispy> interestingly it opens the dylib _after_ the debug output
10:21:47 <lispy> Could be an issue of the order things are printed
10:24:13 <byorgey> ddarius: eh? Criterion.Measurement?
10:24:13 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
10:26:04 <hpaste> self pasted ‚ÄúTrue && 1‚Äù at http://hpaste.org/47719
10:26:20 <tommd> How does cabal query the GHC version?  I'm illegitimately getting this: cabal: cannot configure haddock-2.9.2. It requires ghc >=7.0 && <7.2
10:26:24 <byorgey> hey, the hpaste bot is back!
10:26:26 <byorgey> hpaste++
10:26:27 <tommd> I could investigate, but figured someone already knows...
10:27:07 <lispy> tommd: I'd have to use --verbose=3 to check
10:27:08 <self> i'm walking through "real world haskell" for fun an an early example on data types shows that you cannot execute "True && 1" because boolean operators are not associated with 0/1 like in some other programming language but they do not say how you could get the same result, how can we get the same result?
10:27:09 <chrisdone> byorgey: :)
10:27:30 <byorgey> chrisdone: is this your doing?
10:27:36 <chrisdone> byorgey: Yuppers!
10:27:39 <lispy> :t (&&)
10:27:41 <lambdabot> Bool -> Bool -> Bool
10:27:42 <tommd> lispy: It's buried in a build system, I'll dig!
10:27:59 <byorgey> self: you could write a function to convert numbers to boolean values
10:28:03 <lispy> self: you'd have to define a new (&&) function (and you'd probably want to add a type class constraint)
10:28:09 <byorgey> toBool 0 = False ; toBool _ = True
10:28:18 <Cale> (/= 0) will turn a number into a Boolean value.
10:28:20 <byorgey> then you could write   True && toBool 1
10:28:24 <self> maybe I'm asking this too early and I will never want to do such a thing, is that possible too/
10:28:27 <self> ?
10:28:32 <parcs> instance Num Int where fromInteger x = case x of { 0 -> False; _ -> True }
10:28:42 <parcs> Num Bool*
10:28:44 <chrisdone> I can't think of a practical example of such a case in Haskell.
10:28:54 <Cale> self: You can compare a number to 0 in order to turn it into a Bool.
10:29:20 <Cale> self: and to go the other direction, you can use fromEnum
10:29:22 <byorgey> chrisdone++
10:29:29 <Cale> > map fromEnum [False, True]
10:29:30 <lambdabot>   [0,1]
10:29:32 <chrisdone> I find the a || b idiom in other languages useful and I use that in Haskell with Maybe and (<|>).
10:29:44 <self> gotcha
10:30:28 <tommd> ... and it's getting the right GHC binary and version.  Begin frustration!
10:30:31 <chrisdone> > let xs = [1..5] in find (>6) xs <|> find (<3) xs
10:30:32 <lambdabot>   Just 1
10:32:43 <byorgey> tommd: if you paste your .cabal file I'll take a look at it
10:35:15 <self> why can I do
10:35:22 <self> > True : [False,True]
10:35:23 <lambdabot>   [True,False,True]
10:35:25 <self> but not
10:35:32 <self> > [False,True] : True
10:35:33 <lambdabot>   Couldn't match expected type `[[GHC.Bool.Bool]]'
10:35:33 <lambdabot>         against inferred t...
10:35:44 <self> ?
10:35:44 <tommd> byorgey: http://hpaste.org/47720
10:35:52 <tommd> It's a typical HaLVM cabal config.
10:36:06 <Cale> self: Well, (:) is part of the definition of a list...
10:36:26 <Cale> self: A list is either empty [], or it is a nonempty list constructed from a first element and another list using (:)
10:36:27 <tommd> I've had to port lots of patches to even get the build past Cabal, but they didn't deal with this issue, I don't think.  Don't beat your head very hard though - good chance I could have caused this.
10:36:39 <Cale> self: If you want to concatenate lists (++) is what you're looking for
10:36:54 <self> i'm just experimenting with the operators
10:36:55 <tommd> Well, no, what am I saying.  The patched cabal isn't used yet.  So this should be good.
10:37:01 <Cale> The type of (:) indicates how it should be used:
10:37:06 <Cale> (:) :: a -> [a] -> [a]
10:37:19 <Cale> It takes an element, and a list of elements of that type, and produces another list.
10:37:50 <hpaste> ‚ÄúMukesh Tiwari‚Äù pasted ‚ÄúCompilation Erro‚Äù at http://hpaste.org/47721
10:38:03 <yitz> @type (:)
10:38:04 <lambdabot> forall a. a -> [a] -> [a]
10:38:20 <ben> @type intersperse
10:38:21 <lambdabot> forall a. a -> [a] -> [a]
10:38:38 <tgeeky> if I want to make a "copy" (using this word since I don't know which of decleration to use - I think newtype is out) data Maybe a = Nothing | Just a ... data Divable a = Nope | Yep a ... there's no way to do this and get all of Maybe's instances to come along?
10:38:47 <Eelis> hm, i wonder why the Cairo package doesn't use any handy color data types and instead uses nasty separate RGBA parameters
10:38:50 <ddarius> byorgey: Bah, I wanted bos.
10:39:30 <tgeeky> type is out, because I want to specify the value constructors
10:39:36 <keep_learning> hello all
10:39:39 <keep_learning> http://hpaste.org/47721
10:39:39 <luite> are MVars supposed to be cheap enough to create one for every web request?
10:39:59 <tgeeky> luite: yes, I think so
10:40:02 <keep_learning> could some please tell me why printf is giving compiler error for this code.
10:40:05 <tgeeky> luite: according to Wadler's paper
10:40:30 <ddarius> @tell bos Use realToFrac rather than fromRational . toRational in Criterion.Measurement (and anywhere else.)
10:40:30 <lambdabot> Consider it noted.
10:41:06 <ddarius> luite: You could create tens of thousands for every web request.
10:41:23 <tgeeky> their overhead is in tens of bytes
10:41:25 <tgeeky> that's it, I think
10:41:36 <luite> tgeeky: which paper?
10:42:27 <tgeeky> luite: http://community.haskell.org/~simonmar/par-tutorial.pdf
10:43:02 <tgeeky> @where+ "Parallel and Concurrent Programming in Haskell 1.1" http://community.haskell.org/~simonmar/par-tutorial.pdf
10:43:02 <lambdabot> Done.
10:44:45 <dizzyone> msieradzki is a jew
10:44:46 <dizzyone> bye
10:44:59 <keep_learning> no one ?
10:45:16 <keep_learning> i am stuck with printf and not able to understand the error
10:45:32 <Saizan> keep_learning: annotate with the error
10:46:26 <hpaste> ‚ÄúMukesh Tiwari‚Äù annotated ‚ÄúCompilation Erro‚Äù with ‚ÄúCompilation Erro (annotation)‚Äù at http://hpaste.org/47721#a47722
10:47:00 <keep_learning> Saizan, http://hpaste.org/47721
10:47:13 <keep_learning> submitted the compilation error
10:47:26 <c_wraith> Ah.  It doesn't know what type you mean, there.
10:47:37 <c_wraith> try replacing the 0.25 with (0.25 :: Double)
10:47:43 <c_wraith> So it knows what type you mean.
10:48:35 <luite> tgeeky: hmm, it doesn't seem to say anything about newMVar performance?
10:49:31 <ddarius> luite: I can't imagine what model you'd have where MVars would be so expensive that one per web request would be prohibitive.
10:49:57 <byorgey> tgeeky: the only way to get all of Maybe's instances for free is to make a newtype around Maybe, and then use GeneralizedNewtypeDeriving
10:50:21 <c_wraith> You know it's all the rage these days for web requests to result in multiple SQL queries.  There's no way creating a single MVar is expensive in comparison to that. :P
10:50:35 <tgeeky> byorgey: ok, that makes perfect sense. thanks.
10:50:46 <chrisdone> keep_learning: You need to specify the type of the printf arg because it's ambiguous to printf.
10:51:33 <tgeeky> luite: seems so, it says that the cost of threads is a few hundred bytes.
10:52:29 <tgeeky> but nothing like an experiment to settle it
10:52:57 <ddarius> There's no need for an experiment here.
10:52:57 <luite> ddarius: probably... it's just that it's much more common for concurrency things to make a small number of MVars for a higher level structure. The operations that are then used really often are the try/take functions, not the newMVar one
10:53:45 <ddarius> newMVar is even cheaper than take/putMVar.  It just allocates memory, i.e. bumps a pointer.
10:53:50 <c_wraith> luite: it's just a regular allocation.  the magic in MVars is in take/put
10:54:02 <luite> ok, then I guess I'm fine, thanks :)
10:54:09 <c_wraith> luite: why do you think this is a problem, anyway
10:54:11 <c_wraith> ?
10:54:34 * ddarius imagines one could do a Smalltalk #become per web request (in an implementation without indirections) and probably be fine most of the time.
10:55:11 <luite> c_wraith: didn't think it would be a problem, I was just wondering if it could become one :)
10:55:23 <ddarius> (Admittedly, if the newMVar triggers a garbage collection, that would be as expensive as a #become.)
10:56:51 <ddarius> luite: You do realize that a Chan is essentially a doubly-linked list of MVars and so every writeChan allocates at least one MVar.
10:57:12 <luite> hmm, I thought a Chan was two mvars
10:57:55 <ddarius> luite: And how is a linked list implemented?
10:58:18 <luite> ah right :)
10:58:40 <chrisdone> keep_learning: In (printf "" 0), what type does 0 have?
10:59:24 <keep_learning> chrisdone, It should be Int
10:59:29 <keep_learning> or Integer
10:59:55 <keep_learning> but if we write (printf "" (0::Int))
11:00:09 <keep_learning> then i think it will of type Int
11:00:19 <keep_learning> chrisdone, am i correct ?
11:02:11 <chrisdone> Sorry I was sorting my pasta.
11:02:52 <chrisdone> Yeah, with the type signature it's Int. Without it's Num b.
11:03:23 <chrisdone> Likewise, for 0.25, its type is Fractional t => t.
11:04:15 <chrisdone> printf wants instances of PrintArg. It can't instantiate an instance from Fractional t => t.
11:04:27 <tommd> what does "{pkg_name}" (note the brackets appear explicitly) mean in a ghc-pkg list?  I know "(pkg-name)" (parens) mean the package is hidden.
11:05:00 <chrisdone> tommd: Run ghc-pkg check. Is it broken?
11:05:39 <chrisdone> Ah, no, that's not the notation for broken packages. N/m.
11:06:41 * tommd goes for a run while pondering issues of compilation.
11:07:16 <chrisdone> keep_learning: Can ‚Äúshow (read "4")‚Äù compile?
11:08:17 <keep_learning> chrisdone, i think no
11:08:24 <chrisdone> keep_learning: Why?
11:08:33 <keep_learning> because we have to make sure the read "4" type
11:08:51 <keep_learning> read :: String -> what we want to convert
11:09:02 <keep_learning> chrisdone, am i correct ?
11:09:08 <chrisdone> Right.
11:09:36 <keep_learning> chrisdone, so like in printf we have to mention the type
11:09:44 <chrisdone> Exactly.
11:09:57 <ddarius> > show (read "()")
11:09:58 <lambdabot>   "()"
11:10:13 <keep_learning> chrisdone, could you please write the piece of code for printf which compiles
11:10:24 <chrisdone> ddarius: Cheating. :-)
11:10:35 <keep_learning> chrisdone, i am kind of new to type casting
11:11:14 <c_wraith> keep_learning: it's not type *casting*, it's just type *annotation*.  and I already told you exactly how to fix it.
11:11:19 <keep_learning> chrisdone, although i changed the inner function with readD ( read :: String -> Double ) and it worked
11:11:42 <c_wraith> keep_learning: it never changes the type of something.  It just allows you to specify a more specific type for polymorphic expressions
11:12:27 <keep_learning> c_wraith, its got this from C . Sorry :)
11:12:32 <hpaste> chrisdone annotated ‚ÄúCompilation Erro‚Äù with ‚ÄúType annotation‚Äù at http://hpaste.org/47721#a47723
11:12:38 <parcs> @type 4
11:12:39 <lambdabot> forall t. (Num t) => t
11:13:29 <keep_learning> chrisdone, thank you
11:13:35 <keep_learning> i got it
11:13:50 <keep_learning> it looks like i have to learn lot in Haskell
11:13:54 <keep_learning> thank you all
11:14:06 <keep_learning> One more question ?
11:14:17 <keep_learning> how to read Double in ByteString
11:14:45 <keep_learning> They have  Data.ByteString.Char8.readInteger
11:14:54 <keep_learning> but no readDouble
11:15:02 <keep_learning> any idea
11:15:02 <ben> binary
11:15:26 <parcs> bytestring-nums has some stuff on that
11:20:13 <fwaht> has anyone had success in installing yi with cabal from cygwin?
11:20:15 <parcs> although i would just do read . unpack
11:20:37 <dons> bytestring-lexing
11:20:41 <dons> has readDouble
11:22:42 <fwaht> is yi worth installing?
11:23:37 <dons> it represents about 10 FTEs of effort. so probably. its a big project
11:23:47 <dons> there's got to be something in there worth a few minutes of your time
11:24:10 <benmachine> FTEs?
11:24:19 <dons> full-time engineer years
11:24:32 <benmachine> oh, years
11:24:33 <benmachine> neat
11:24:37 <fwaht> what i'm asking is, is if it's significantly better than leksah or vim with haskell
11:24:41 <fwaht> support
11:24:52 <fwaht> to jump through hoops to install
11:24:56 <dons> not compared to leksah, but def. better support for haskell than vimmmmm
11:25:05 <dons> leksah is a bit different. its an ide
11:25:08 <dons> yi is an editor
11:25:16 <dons> so leksah does project management stuff
11:25:20 <benmachine> what does yi have in haskell support that vim doesn't?
11:25:23 <dons> while yi concentrates on language support
11:25:35 <dons> well, e.g. type completion, incremental parsing, etc
11:25:35 <ion> I want to define an instance for a type so that multiple instance function definitions use the same helper function, which isn‚Äôt used by anything else. Is there a way to make the helper local to the instance definition?
11:25:38 <fwaht> it says it wants to supplant vim, and you can use vim as an ide
11:25:48 <dons> try it and see.
11:25:50 <fwaht> with plugins
11:26:19 <fwaht> i'm trying to try it, but it's a pain in the ass to install on windows
11:27:00 <dons> oh, on windows. yes.
11:27:06 <fwaht> even arch linux
11:27:10 <dons> you're better off with visual studio+haskell or eclipse-fp
11:27:10 <ion> instance Arbitrary Name where { arbitrary = ‚Ä¶ `suchThat` notCapsOnly; shrink = filter notCapsOnly . ‚Ä¶ }
11:27:11 <zmv> yeah
11:27:20 <dons> everything's a pain on windows.
11:27:28 <fwaht> you're painting with a broad stroke
11:27:30 <ion> I want notCapsOnly to be local to both ‚Äòarbitrary‚Äô and ‚Äòshrink‚Äô.
11:27:38 <ion> the definition of notCapsOnly, that is
11:27:55 * ddarius started using vim on Windows and has never programmed in Haskell in anything other than vim on Windows or Linux.
11:27:57 <fwaht> yeah, the aur package for yi is out of date
11:28:04 <dons> yeah, i use vim on windows
11:28:09 <fwaht> same
11:28:13 <dons> in cygwin. or gvim in mingw
11:28:13 <benmachine> ion: I'd like a feature that does it but as far as I know it's not possible; why do you want it?
11:28:35 <ddarius> I used mingw console vim on Windows.
11:28:50 <ion> benmachine: Just because notCapsOnly isn‚Äôt used by anything else than the instance definition.
11:29:44 <fwaht> lol cabal install yi fails on arch linux
11:29:53 <benmachine> fwaht: error?
11:29:57 <fwaht> it says "the 'impossible' happened'
11:29:57 <parcs> fwaht: doesn't fail fo rme
11:29:58 <fwaht> that's useful
11:30:20 <benmachine> fwaht: that usually means a bug in something, can you hpaste the whole error?
11:32:13 <hpaste> asfasdf pasted ‚Äúasdfasdf‚Äù at http://hpaste.org/47724
11:32:22 <fwaht> that's it
11:32:24 <fwaht> http://hpaste.org/47724
11:32:26 <hpaste> benmachine pasted ‚ÄúnotCapsOnly local to two functions‚Äù at http://hpaste.org/47725
11:32:46 <benmachine> ion: ^ that shows it can be done, albeit in an ugly way
11:33:08 <benmachine> ion: there was some discussion about submitting a proposal to allow 'let' or something similar in a declaration context
11:33:15 <benmachine> but I don't think it ever got anywhere
11:33:21 <ion> benmachine: Hmm, interesting. :-)
11:33:59 <ion> But i guess i‚Äôll keep using instance Arbitrary Name where { ‚Ä¶ }; nameNotCapsOnly = ‚Ä¶
11:34:08 <benmachine> mm
11:34:15 <fwaht> benmachine: do you have a solution to that error?
11:34:55 <benmachine> fwaht: this is on arch?
11:35:00 <parcs> fwaht: what version of ghc do you have installed?
11:35:03 <benmachine> one sec, I'll see if it happens to me
11:35:05 <fwaht> yeah, it's arch
11:35:16 <benmachine> parcs: well, the error is loading the ghc-7.0.2 package so um
11:35:24 <parcs> benmachine: arch-linux specific
11:35:29 <benmachine> ah I see
11:35:40 <zmv> fwaht: try Syuing first
11:35:46 <benmachine> you want the arch package version, not the ghc version
11:35:46 <fwaht> this is just a fresh install in vmbox
11:35:52 <fwaht> with all the up to date packages
11:36:14 <parcs> fwaht: pacman -Qi ghc
11:36:49 <fwaht> 7.0.2-1
11:37:39 <parcs> fwaht: yeah, that version of ghc is problematic due it symbol stripping
11:37:55 <parcs> you should install 7.0.2-2 from the [testing] repository
11:38:10 <parcs> s/it/to
11:38:15 <benmachine> iirc you can't use the ghc binaries on arch because the libraries they're compiled against differ, which is kind of annoying
11:38:18 <benmachine> I compile from source :P
11:38:25 <fwaht> i'm remembering why i stopped using arch
11:38:29 <benmachine> (the ghc binary releases I mean)
11:38:31 <parcs> fwaht: why is that?
11:38:38 <fwaht> because of problems like this
11:38:42 <fwaht> with rolling updates
11:38:59 <fwaht> you get stuck with something broken occassionally
11:39:07 <benmachine> surely that happens on all systems
11:39:09 <benmachine> occasionally
11:39:15 <fwaht> no?
11:39:19 <parcs> fwaht: yeah, admittedly 7.0.2-2 should have been removed from [testing] already. something is up with the maintainer..
11:39:34 <fwaht> well, it depends on what you mean by occassionally i suppose
11:39:35 <parcs> but 7.0.2-2 fixes this very error you're experiencing, and works flawlessly otherwise
11:39:41 <benmachine> fwaht: ok what system never breaks everything ever? :P
11:39:47 <benmachine> er *anything
11:39:59 <fwaht> yeah ben, i think you're taking my use of occassionally too literally
11:40:37 <handonson> How do I get a "head" or "tail" of Data.Sequence?
11:40:45 <benmachine> fwaht: hm, so basically you think that arch breaks things more often than other distros
11:40:49 <magicman> :t viewLeft
11:40:50 <lambdabot> Not in scope: `viewLeft'
11:40:53 <fwaht> yes
11:41:00 <benmachine> that's possibly true
11:41:19 <fwaht> debian breaks the least i imagine
11:41:20 <parcs> handonson: take 1, drop 1?
11:41:21 <benmachine> if you don't have the time or energy to fix things when they go wrong, arch is probably not for you :P
11:41:35 <magicman> :t Data.Sequence.viewl
11:41:36 <fwaht> yeah ben, i figured that out for myself
11:41:36 <lambdabot> forall a. Seq.Seq a -> Seq.ViewL a
11:41:43 <magicman> :i Seq.ViewL
11:41:45 <handonson> parcs: there is no take in Data.Sequence
11:41:46 <fwaht> about a year ago i guess when i stopped using it
11:41:56 <parcs> @hoogle Data.Sequence.take
11:41:56 <lambdabot> Data.Sequence take :: Int -> Seq a -> Seq a
11:42:04 <handonson> huh?
11:42:12 <fwaht> there was some update that really broke arch that i forgot about
11:42:23 <fwaht> but still, i like the idea of arch
11:42:30 <handonson> ?!
11:42:30 <lambdabot> Maybe you meant: . ? @ v
11:42:36 <handonson> parcs: thanks
11:42:51 <benmachine> handonson: you can also case-match on a ViewL
11:42:55 <handonson> what about init and last?
11:43:07 <benmachine> handonson: viewl and viewr might interest you
11:45:25 <lispy> In case anyone wants to take a stab at it, here is a write up of the osx/ghci/segfault stuff I was working on eariler (still need help): http://stackoverflow.com/questions/6323755/osx-ghci-dylib-what-is-the-correct-way
11:48:18 <fwaht> this might be heretical but i'm liking gnome 3
11:48:32 <fwaht> except for the lack of a taskbar
11:48:46 <lolsauce> It's the same as unity
11:48:55 <fwaht> isn't unity just compiz?
11:49:10 <fwaht> it's gnome2 with a compiz plugin
11:49:19 <lolsauce> Yeah
11:49:46 <lolsauce> There's not much of a difference
11:49:54 <lolsauce> Or is there
11:50:02 <fwaht> i don't know, in ui the small things can be huge in my opinion
11:50:07 <fwaht> like opera for example
11:50:14 <fwaht> i like opera, but it has all the ui quirks
11:50:31 <fwaht> like it used to be that when you opened an image larger than the window, you wouldn't get a magnifier glass to resize it
11:50:42 <fwaht> or the buttons would be 2 pixels larger than the address bar
11:50:53 <fwaht> those kinds of things eventually drive me insane
11:53:01 <parcs> opera's ui is highly configurable though. all those quirks can (probably) be fixed through tinkering
11:53:25 <fwaht> the point is, they should be fixed from the start
11:53:35 <fwaht> and that magnifying thing wasn't fixable
11:53:43 <fwaht> before it had extensions at least
12:00:05 <zmlka> fwaht: you might be interested in http://nixos.org/nix/ if you don't like one package breaking others
12:00:48 <fwaht> this is a distro?
12:01:10 <zmlka> like arch is based on pacman, nixos is based on nix
12:01:13 <zmlka> yep
12:01:22 <fwaht> i'll check it out, thanks
12:01:26 <fwaht> it's active right?
12:01:47 <zmlka> It's young, so I haven't tried it yet
12:02:07 <zmlka> yes it is active
12:03:07 <fwaht> http://nixos.org/nixos/ < wow that sounds amazing
12:06:38 <zmlka> I plan on givint it a go later, the only thing that I am unsure about is upstart
12:11:39 <fwaht> i installed ghc from testing and now cabal is saying it can't satisfy -package-id quickcheck
12:12:32 <fwaht> oh nevermind i just did a cabal install on it
12:12:40 <fwaht> thought it was suppose to do that automagically
12:13:13 <roconnor> fwaht: I've been running nixos for a year an a half
12:13:31 <fwaht> you like it?
12:13:34 <roconnor> yes
12:13:47 <fwaht> you've used arch?
12:14:04 <roconnor> no
12:14:16 <fwaht> oh i was just going to ask if you missed anything
12:14:19 <geheimdienst> nixos is a binary distro, not source, right?
12:14:39 <roconnor> geheimdienst: I'd say it is a source distro with binary optimisations
12:15:03 <sanjoyd> roconnor: have you used Debian?
12:15:07 <roconnor> yes
12:15:12 <geheimdienst> oh really? you have to compile everything? that sucks
12:15:24 <geheimdienst> didn't know that
12:15:32 <sanjoyd> I'd like to try out something new for my netbook.
12:15:39 <roconnor> geheimdienst: no, you don't have to compile anything that is precompiled
12:15:50 <sanjoyd> (But it is a 1.6 Ghz Intel Atom, so compiling is not an option).
12:16:03 <tonyhwks> hi
12:16:08 <geheimdienst> okay, so the packages are somewhat binary
12:16:34 <roconnor> there is a continuous integration server called hydra that is constantly compiling stuff
12:16:52 <geheimdienst> ah, that makes sense. thanks for the explanation
12:16:56 <roconnor> well, I guess it could stop compiling if it's queue gets empty
12:17:14 <sanjoyd> What is a sensible way to represent an AST in Haskell? I've been trying to do things like "data IfStmt = IfOnly Expression Body | IfElse Expression Body Body"
12:17:21 <sanjoyd> But there must be a better way.
12:17:41 <roconnor> sanjoyd: that seems mostly sensible
12:18:13 <sanjoyd> Oh, okay.
12:18:34 <AtnNn> is there an alternative to System.Process that uses Word8 or ByteString?
12:19:20 <tonyhwks> please suggest a few projects like finding Least Common Multiplier, Greatest common devisor, matrices...
12:19:38 <ion> Find the sum of two numbers
12:20:07 <tonyhwks> ion: thanks, but need to perform more operations...
12:20:10 <Nimatek> tonyhwks: http://projecteuler.net/
12:20:46 <frerich> tonyhwks: Find the smallest natural number which can be expressed in two different ways as the sum of two cubic numbers.
12:21:05 <dafis> aka taxicab number :)
12:21:20 <frerich> :^)
12:22:09 <sanjoyd> Or the smallest even number which can't be expressed as a sum of two primes.
12:22:24 <dafis> 0
12:22:33 <sanjoyd> Ah, non-zero. :D
12:22:36 <dafis> 2
12:22:54 <sanjoyd> Also, non-2.
12:22:58 <AtnNn> find the fourth number that repeats itself in its collatz sequence
12:22:59 <djahandarie> 1796!
12:23:03 <roconnor> 4
12:23:34 <djahandarie> Ah damn it, I was wrong
12:23:55 <ion> Find the largest number that is smaller than œÄ.
12:24:20 <sanjoyd> AtnNn: there was a recent paper proving the Collatz sequence. I don't know enough math to make sense of it, though.
12:24:31 <sanjoyd> s/sequence/theorem/
12:24:35 <byorgey> sanjoyd: it's bunk.
12:24:42 <sanjoyd> byorgey: oh, okay.
12:24:44 <dafis> find the largest number n such that if k > 1 and gcd n k == 1 then k is prime
12:25:17 <dafis> byorgey: proven bunk?
12:25:39 <AtnNn> is it on arxiv?
12:25:50 <Eduard_Munteanu> So btw, is that proof valid?
12:26:11 <byorgey> dafis: what is your criterio for "proven bunk"?
12:26:24 <Eduard_Munteanu> I remember some blog post identifying potential issues with it.
12:26:34 <byorgey> Eduard_Munteanu: yes, mine =)
12:26:39 <Eduard_Munteanu> Oh :)
12:26:48 <byorgey> it is not a valid proof.
12:26:57 <dafis> byorgey: proven incorrect statements, huge gaps in purported proofs
12:27:35 <byorgey> dafis: well, it has a single giant gap the shape of, oh, the Collatz conjecture
12:28:20 <Eduard_Munteanu> Well it's not like that dude is a crackpot or something... stuff is easy to miss. Like in Deolalikar's case with P != NP
12:28:42 <dafis> byorgey: got an url for your blogpost?
12:29:34 <byorgey> dafis: http://mathlesstraveled.com/2011/06/04/the-collatz-conjecture-is-safe-for-now/
12:29:43 <sanjoyd> byorgey: okay, just read your post.
12:29:49 <dafis> gracias
12:30:18 <sanjoyd> I think this is in Wikipedia too (inverting, constructing a tree etc.).
12:30:33 <sanjoyd> I thought the flaw would be something more subtle. :/
12:30:57 <byorgey> sanjoyd: I thought so too. =(
12:31:21 <Eduard_Munteanu> byorgey: I think I first saw some reddit post though
12:31:57 <byorgey> Eduard_Munteanu: yes, I link to a few other things from that blog post, look for the words "several other people"
12:33:08 <Eduard_Munteanu> Yeah, I found it by browsing those links, the last one in particular
12:34:40 <Eduard_Munteanu> It's interesting to see some math being done (or should I say, blown to pieces :D) on reddit. :)
12:36:44 <sanjoyd> What is :::?
12:36:49 <sanjoyd> Can google something like htis.
12:37:13 <aavogt> @hoogle :::
12:37:13 <lambdabot> No results found
12:37:21 <byorgey> yeah, it's interesting how papers on famous topics like this often end up getting thoroughly reviewed on reddit and in blog post comments etc. before the referees at the journal where it was submitted even take a look at it =)
12:37:22 <parcs> it's some kind of data constructor
12:37:26 <byorgey> sanjoyd: where did you see it?
12:37:43 <sanjoyd> http://hackage.haskell.org/packages/archive/streams/0.7.2/doc/html/Data-Stream-Infinite.html
12:37:49 <sanjoyd>  inits _|_ = [] ::: _|_
12:38:48 <byorgey> sanjoyd: from the context it appears it is supposed to mean 'cons', as in (:) for lists or :> for that Stream type
12:38:53 <byorgey> but for some reason the comment uses :::
12:39:13 * sanjoyd does not know what :> is either.
12:39:15 <byorgey> perhaps an older version of the library defined streams as  Stream a = a ::: Stream a  and the documentation didn't get updated?
12:39:19 * sanjoyd tries to Hoogle.
12:39:24 <sanjoyd> @hoogle :>
12:39:24 <lambdabot> Data.Sequence (:>) :: Seq a -> a -> ViewR a
12:39:26 <byorgey> sanjoyd: :> is defined at the top of that page
12:39:34 <fwaht> are most people here using leksah?
12:39:39 <byorgey> it is the constructor for the Stream type
12:39:47 <sanjoyd> Yeah, got it.
12:40:27 <parcs> fwaht: most people here use vim or emacs, i'd imagine
12:40:30 <byorgey> fwaht: I have no idea what most people here are using. =)  I personally use emacs.
12:40:43 * sanjoyd is on Emacs too.
12:40:51 <dafis> kate
12:40:59 <fwaht> vim with a separate console for ghc?
12:41:06 * sanjoyd waits for someone to say TextMate.
12:41:11 <parcs> fwaht: vim, tmux and ghci is all you need ;)
12:41:35 <sanjoyd> Unless you want to IRC. :)
12:41:56 <fwaht> haven't seen tmux before
12:42:16 <parcs> it's an improved screen with a bsd license
12:42:36 <fwaht> care to share your vim config?
12:43:18 <fwaht> like, what are you using for auto complete ect
12:43:44 <lispy> ivan: ping
12:44:01 <ivan> I ain't ivanm
12:44:10 <lispy> oops
12:44:13 <lispy> ivan: sorry!
12:44:16 <ivan> np
12:44:22 <lispy> preflex: seen ivanm
12:44:22 <preflex>  ivanm was last seen on #xmonad 19 hours, 55 minutes and 14 seconds ago, saying: aavogt: can you help obcode out?
12:44:29 <tonyhwks> is there a way to get a list of floats in getLine ?
12:44:36 <Eduard_Munteanu> Heh I confused him a few times too :)
12:44:55 <byorgey> tonyhwks: getLine gives you a String, and you can convert that to a list of floats with  map read . words
12:45:03 <parcs> fwaht: google "vim omnicompletion"
12:45:08 <Eduard_Munteanu> :t read
12:45:08 <lambdabot> forall a. (Read a) => String -> a
12:45:09 <byorgey> > map read . words $ "2.345 6.78 9.23"
12:45:11 <lambdabot>   [*Exception: Prelude.read: no parse
12:45:20 <byorgey> > map read . words $ "2.345 6.78 9.23" :: [Double]
12:45:22 <lambdabot>   [2.345,6.78,9.23]
12:45:24 <fwaht> yeah, are you using ctags?
12:45:35 <fwaht> and updating that for every haskell file?
12:46:06 <sanjoyd> Does ghci 7.0.3 not have Data.Stream.Infinite?
12:46:56 <parcs> fwaht: no, omnicompletion is different
12:47:30 <parcs> it keeps track of all symbols used in a file and matches against those
12:47:48 <byorgey> sanjoyd: not by default.
12:47:51 <tonyhwks> thanks
12:48:04 <byorgey> sanjoyd: that documentation you linked to is from the streams package, so you will have to  'cabal install streams'
12:48:04 <dafis> sanjoyd: it's in the strams package, I think, not in the libs shipped with ghc anyway
12:48:22 <jonkri> newbie question: if i have a typeclass called XMLable, and an instance of that type class, and a value of the instance, and i want to return the value as a "XMLable a => a" from a function, how can i convert the instance to its generic typeclass form?
12:48:34 <byorgey> jonkri: you can't.
12:48:39 <jonkri> doh
12:48:40 <ion> To combine it with an IO action: map read . words <$> getLine :: IO [Double]
12:48:45 <byorgey> jonkri: XMLable a => a  means "this value can have any XMLable type you want"
12:49:16 <tonyhwks> im trying to do matrix operations, what is the best way to get list of values for matrices? list of tuples? how to let user input any dimension?
12:49:53 <byorgey> jonkri: if what you mean instead is that "this value has some XMLable type but I'm not telling you which one", then you can accomplish that with an existential wrapper.  But it probably isn't what you want.
12:49:54 <jonkri> byorgey, isn't it enough that it can perform the typeclass functions on it?
12:50:40 <ion> tonyhwks: Perhaps http://hackage.haskell.org/packages/archive/hmatrix/0.11.1.0/doc/html/Data-Packed-Matrix.html
12:51:01 <byorgey> jonkri: yes, it sounds like you are asking about returning an existentially wrapped value: "you don't know what type this is, other than the fact that it is XMLable, so the only thing you can do with it is XMLable operations" ?
12:51:38 <byorgey> jonkri: what exactly are you trying to do?
12:51:51 <tonyhwks> i was going to do it from scratch..
12:51:58 <ion> Why?
12:52:31 <tonyhwks> for learning purpose
12:55:24 <jonkri> byorgey, it's a little complicated, and i'm probably doing it wrong, but i want to be able to provide a record with a set of functions operating on an arbitrary type, such as this one: http://paste.pocoo.org/show/405233/ (tbc)
12:56:18 <guerrilla> think there'll ever be support for mixfix or distfix parsing in haskell?
12:56:38 <jonkri> byorgey, then, i want to store these record objects in a polymorphic list somehow [ http://paste.pocoo.org/show/405234/ ], and being able to call the callbacks where the callbacks are AWARE of the real type, but the rest of the program isn't
12:56:57 <jonkri> s/where/in a way that
12:57:33 <byorgey> jonkri: oh, sorry, looks like I have to run, but I can help you think about this later if no one else has
12:57:49 <jonkri> byorgey, no problem, thanks a lot :)
12:58:08 <jonkri> you have a good one :)
13:10:13 <Peaker> I see there was a leksah discussion? Are people successfully using it? It didn't work for me
13:11:25 <dented42> in GHCi one can ask for the types of expressions. Is there a way to ask for the type of an expression that is in a function definition? Is there some way to extract the type signature of a subexpression that lives within a larger one?
13:14:45 <c_wraith> > let f = (+) (3 :: Int) in typeOf f
13:14:46 <lambdabot>   Int -> Int
13:14:55 <c_wraith> @hoogle typeOf
13:14:55 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
13:14:55 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
13:14:55 <lambdabot> Data.Typeable typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
13:16:40 <ion> > typeOf (+)
13:16:40 <lambdabot>   Integer -> Integer -> Integer
13:17:08 <parcs> > fix typeOf
13:17:09 <lambdabot>   TypeRep
13:17:19 <ion> > let f :: Num a => a -> a -> a; f = (+) in typeOf f
13:17:20 <lambdabot>   Integer -> Integer -> Integer
13:17:38 <ion> > typeOf ((+) :: Num a => a -> a -> a)
13:17:39 <lambdabot>   Integer -> Integer -> Integer
13:17:45 <lispy> > let python = const (text "Haskell") in fix python
13:17:46 <lambdabot>   Haskell
13:17:55 <lispy> See, if you fix python you get Haskell
13:18:00 <nihtml> :D
13:18:12 <nihtml> :t text
13:18:13 <lambdabot> String -> Doc
13:18:21 <parcs> > typeOf (undefined :: forall a. a)
13:18:22 <lambdabot>   Ambiguous type variable `a' in the constraint:
13:18:22 <lambdabot>    `Data.Typeable.Typeable a...
13:18:25 <Jafet> If you looked at their changelogs, you would realize that the language had no fixed points.
13:18:28 <nihtml> :t fix
13:18:29 <lambdabot> forall a. (a -> a) -> a
13:18:44 <parcs> > typeOf (undefined :: forall a. [a])
13:18:45 <lambdabot>   Ambiguous type variable `a' in the constraint:
13:18:45 <lambdabot>    `Data.Typeable.Typeable a...
13:18:55 <nihtml> :t Doc
13:18:56 <lambdabot> Not in scope: data constructor `Doc'
13:19:24 <parcs> nihtml: it's part of some pretty-printing package
13:19:29 <ski> > typeOf ((undefined :: forall a. [a]) :: [()])
13:19:30 <lambdabot>   [()]
13:19:34 <Jafet> dented42: perhaps one of the Haskell IDEs provides this, but I've never used them
13:20:01 <Jafet> GHCi doesn't, but it's not hard to trick it into doing so
13:20:12 <nihtml> i was reading about, yeah, parcs, thanks
13:20:36 <dented42> Jafet: Hmmm... Oh well
13:21:27 <orifichu_> is haskell mature for web applications?
13:22:27 <lispy> orifichu_: I made a haskell web app for internal use at work.  I thought snap was nice.  Yesod looks good tooo.
13:22:51 <Jafet> :t let f 0 = 0; f x = recip $ 2*fromIntegral (truncate x) - x + 1 in iterate f 0
13:22:52 <lambdabot> forall a. (RealFrac a) => [a]
13:23:35 <Jafet> :t let f 0 = 0; f x = recip $ ?g x in f undefined
13:23:36 <lambdabot> forall a a1. (?g::a -> a1, Fractional a1, Num a) => a1
13:23:48 <MHD> Is there some sort of Parsec-like library for parsing binary data?
13:24:00 <parcs> binary!
13:24:04 <lispy> MHD: attoparsec, binary and cereal
13:24:09 <MHD> okay
13:24:24 <lispy> i'd start with binary
13:24:31 <MHD> I'm looking for something to write a PNG-reader in...
13:24:48 <Jafet> Well, Binary is more like ReadP
13:24:55 <orifichu_> lispy: but using some framework?
13:24:55 <lispy> MHD: I did some quick and dirty bmp loading just using binary
13:24:56 <Jafet> Not that that doesn't often suffice
13:25:07 <lispy> orifichu_: yes, snap and yesod are frameworks
13:25:19 <MHD> lispy: PNG needs a little more than quick and dirty.
13:25:27 <lispy> MHD: I bet
13:25:51 <lispy> MHD: my point is that it should be possible.  You might look into the iteratee stuff.  Oleg wrote an example tiff parser.
13:26:05 <MHD> Oh, and. Strict or Lazy Binary?
13:26:08 <Jafet> Eh, as long as you're not writing the deflate part...
13:26:30 <MHD> Jafet: Believe me, I'm not :P those zlib guys can run their gig.
13:27:06 <MHD> Maybe, like, read the header of the PNG and then from the PNG size, decide wether to use lazy or strict bytstring?
13:27:16 <orifichu_> lispy: but is not problem with libraries? like sql libraries?
13:27:18 <Jafet> Nope, just use lazy ByteString
13:27:22 <MHD> Okay :P
13:27:43 <Jafet> The programmers were a bit less lazy when they implemented that one
13:27:46 <lispy> orifichu_: we have sql libraries.  What db engine wil lyou use?
13:28:11 <orifichu_> lispy: mysql and postgresql
13:29:12 <lispy> orifichu_: I've used takusen with both of those.  Real-World Haskell documents using HDBC with them.
13:31:46 <orifichu_> lispy: you recommend use haskell with some web framework to do hugs web applications?
13:33:45 <lispy> orifichu_: I'd stick to ghc
13:33:49 <mun> hi
13:34:03 <lispy> orifichu_: No one is really using hugs anymore, except maybe the mobile platform folks
13:34:48 <mun> what's the usual way to indicate that an unary function f is polymorphic using logical notation? f : \alpha -> \tau? is alpha typically used to denote a type variable?
13:35:33 <eddayyy> hello
13:36:01 <eddayyy> are there any neat tricks to get away from staircasing Just -> Nothing syndrome?
13:36:13 <rovar> the maybe monad
13:36:59 <eddayyy> rovar: example? :D
13:37:24 <orifichu_> lispy: which programming language would you use for web applications?
13:38:35 <ski> mun : `forall' ?
13:39:47 <rovar> eddayyy: http://learnyouahaskell.com/a-fistful-of-monads#the-monad-type-class
13:39:49 <ski> eddayyy : <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html>
13:40:26 <lispy> orifichu_: I use haskell
13:40:32 <rovar> ski:  huh.. i haven't read that one yet..
13:40:41 <rovar> thought I'd seen em all
13:40:43 <ski> it's one of the oldest
13:41:05 <eddayyy> rovar: so the answer is instead of staircasing use unhappy sidewards face? (>>=)
13:41:08 <rovar> does anyone know if there is a module for randomly generating models for test data?
13:41:11 <ski> (you'll note some archaisms in it)
13:41:21 <rovar> eddayyy: or use 'do' notation
13:41:27 <ski> eddayyy : .. what rovar said
13:41:41 <rovar> eddayyy: unhappy sidewards face is your friend, get to know him.
13:42:05 <orifichu_> Do you have experienced some problem using haskell for web applications?
13:42:17 <orifichu_> lispy: Do you have experienced some problem using haskell for web applications?
13:42:20 <rovar> speaking of... does anyone know of a module for randomly generating models for test data?
13:42:55 <lispy> orifichu_: I wrote a web application that we use internally at work using Haskell.
13:42:59 <Jafet> Randomly generating... models?
13:43:00 <parcs> eddayyy: you just have to use do notation, making note that every expression must be of type 'Maybe a' and that once a Nothing is encountered then the entire computation is short-circuited to return Nothing
13:43:01 <rovar> e.g.  randomly selecting from a set of enums, randomly selecting from a list  to populate a record
13:43:10 <Jafet> Well, QuickCheck randomly generates test data, but you have to write the models.
13:43:19 <lispy> orifichu_: But, i know Haskell really well.  I didn't have any problems with the web framework.  all the problems I have are with javascript and gnu plot
13:43:23 <rovar> Jafet: err.not generating modules.. generating data to fit the models
13:43:42 <rovar> i just want to check before I write my own.. seems like a common thing..
13:44:02 <rovar> i just need a large data set with which to experiment.. it happens to be a graph
13:44:15 * ski wonders if this is models as in `model theory' ..
13:44:59 <rovar> nothing so complex.. i have some ideas for classification of entities in a graph..
13:45:02 <Jafet> Randomly generated models would probably be quite interesting... or possibly quite uninteresting
13:45:10 <rovar> so I just need a graph with some very specific characteristics.
13:45:58 <orifichu_> lispy: some good tutorial to learn haskell and snap?
13:50:10 <lispy> orifichu_: http://snapframework.com/docs/quickstart  http://learnyouahaskell.com/chapters  http://book.realworldhaskell.org/read/  http://www.yesodweb.com/page/five-minutes
13:50:22 <lispy> orifichu_: all of those should be pretty good
13:51:20 <yoki> hi there, anybody knows a printing library/binding for haskell (e.g. for cups)?
13:51:44 <orifichu_> lispy: thanks
13:52:25 <lispy> yoki: never heard of one, I'd check hackage
13:53:24 <tgeeky> yoki: doubt there is one
13:53:43 <tgeeky> but you never know what nicities you can find on hackage
13:54:14 <yoki> i checked hackage too, but couldn't find one
13:54:31 <tgeeky> yoki: what are you thinking of doing with it, if it did exist?
13:55:11 <yoki> tgeeky: I am trying to get printing to work
13:55:30 <yoki> like sending jobs to a printer (not stdout)
13:55:45 <tgeeky> straight from haskell?
13:55:51 <yoki> yes
13:56:17 <tgeeky> i guess try to use c2hs to wrap libcups?
13:57:08 <yoki> yes, i am currently doing this, i m just checking if anybody did this before ;D
13:57:39 <tgeeky> I'm a little curious using file handles is out of the question?
13:58:40 <tgeeky> there are libraries for postscript
13:59:10 <tgeeky> and a few PDF writers
14:00:07 <yoki> tgeeky: what do you mean with "using file handles", sending data to the printer device straight?
14:00:30 <tgeeky> yeah, or sending data to a file, and using command-line or unix interfaces to printing that file
14:01:27 <yoki> it's an option but a cups-binding would be nicer i think
14:02:05 <tgeeky> lcups only has about 40 functions ;)
14:02:14 <tgeeky> http://www.cups.org/documentation.php/api-cups.html
14:03:05 <yoki> yeah i know but they have useful documentation
14:06:02 <mun> what's the proper term for functions that are not polymorphic?
14:06:26 <sclv> monomorphic
14:06:35 <sclv> that goes for any type, not just function types
14:07:25 <mun> thanks
14:07:39 <sully> one of my friends used to have a flail made of a metal pipe, a chain, and a weight
14:07:42 <tgeeky> mono is always the singular of poly :o
14:07:49 <sully> it was labelled the monomorphiser
14:08:21 <sully> when the campus police confiscated it, he became probably the first person who ever had to explain what "monomorphize" meant to a police officer
14:08:42 <tgeeky> lol
14:08:50 <kakos> sully: Seems like amorphiser would be a better name.
14:08:53 <tgeeky> that reminds me of the story with SPJ and the customs officer
14:09:03 <tgeeky> "You have to let him in, he invented ML!"
14:09:23 <tgeeky> (he didn't, in case one hasn't seen it)
14:09:32 <benmachine> I haven't seen it :o
14:10:37 <tgeeky> I would love to attend a SPJ lecture.
14:10:45 <tgeeky> it's a shame he doesn't do regular teaching
14:14:26 <mheld> is there a De Facto haskell tutorial for people who've done FP before?
14:14:27 <brandwe> I had lunch with SPJ when he visited MS Campus in Redmond.
14:14:46 <brandwe> He drove his bike all over campus, and be brought it from Cambridge :-)
14:14:59 <brandwe> So British
14:15:51 <shachaf> mheld: Depending on what sort of FP you've done, you might not need a tutorial. :-)
14:15:59 <mheld> I'm a schemer
14:16:02 <ski> mheld : maybe the Gentle Introduction would suit you ?
14:16:07 <mheld> well, I guess the term is Racketeer now
14:16:10 <akahn> Why might I get *** Exception: error received: Error_Packet_Parsing "Failed reading: invalid header type: 72\nEmpty call stack\n when I attempt to make an HTTP request with http-enumerator?
14:16:11 <shachaf> ("You haven't done FP until you've done Haskell, man.")
14:16:22 <shachaf> mheld: Only if you use Racket and not Scheme.
14:16:37 <ski> mheld : <http://www.haskell.org/tutorial/>
14:16:42 <akahn> here's the http-enumerator code in question: http://pastie.org/2058177
14:16:47 <shachaf> Anyway, yes, there's the gentle introduction.
14:17:42 <Jafet> Haskell has more typing, so it requires less typing. But it takes getting used to.
14:33:54 <mheld> ah awesome
14:33:58 <mheld> I'll check out the gentle intro
14:34:01 <mheld> thanks!
14:59:01 <lispy> > not otherwise
14:59:01 <lambdabot>   False
14:59:14 <lispy> > otherwise or not otherwise
14:59:15 <lambdabot>   Couldn't match expected type `([GHC.Bool.Bool] -> GHC.Bool.Bool)
14:59:15 <lambdabot>           ...
14:59:23 <lispy> > otherwise `or` not otherwise
14:59:24 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
14:59:24 <lambdabot>         against inferred typ...
14:59:29 <lispy> :t or
14:59:29 <lambdabot> [Bool] -> Bool
14:59:32 <lispy> ah
14:59:37 <lispy> > otherwise || not otherwise
14:59:38 <lambdabot>   True
15:00:58 <shachaf> @check \x -> x || not x
15:00:59 <lambdabot>   "OK, passed 500 tests."
15:01:16 <hpc> > let id x | x == otherwise = x; | otherwise = x in id 5
15:01:17 <lambdabot>   <no location info>: parse error on input `|'
15:01:20 <hpc> :(
15:01:45 <shachaf> Semicolon unneeded.
15:01:47 <lispy> > let { test (Just _) = otherwise; test Nothing = not otherwise } in test (Just 1)
15:01:48 <lambdabot>   True
15:02:11 <lispy> I like saying, "... = not otherwise" instead of False
15:02:16 <lispy> Great fun when you read the code later
15:04:22 <siracusa> > otherwise `maybe` not $ Just otherwise
15:04:23 <lambdabot>   False
15:04:54 <hpc> heh
15:05:21 <hpc> siracusa: that one is going in my bag of tricks :D
15:05:42 <siracusa> :-)
15:05:50 <lispy> cute
15:06:06 <lispy> ?remember siracusa otherwise `maybe` not $ Just otherwise
15:06:06 <lambdabot> Nice!
15:06:32 <shachaf> > let –ætherwise = not otherwise in –ætherwise
15:06:32 <lambdabot>   False
15:08:03 * roconnor hasn't used maybe infix before
15:10:17 <dolio> Wait...
15:10:27 <dolio> > let otherwise = not otherwise in otherwise
15:10:31 <lambdabot>   mueval-core: Time limit exceeded
15:10:53 <Jafet> > "–ætherwise"
15:10:54 <lambdabot>   "\1086therwise"
15:10:57 <tomh> mm anyone know a page which describes the allowed characters for custom operators?
15:11:09 <dolio> Ah, of course.
15:11:10 <tomh> not exactly sure what to google for :/
15:12:35 <shachaf> tomh: Doesn't the Report describe it?
15:13:19 <tomh> I guess so, what should I look for?
15:13:24 <siracusa> tomh: I think any symbol for which Data.Char.isSymbol yields true is allowed
15:13:50 <tomh> hmm
15:13:51 <Jafet> Except for the very special ones
15:14:24 <siracusa> > isSymbol '*'
15:14:25 <lambdabot>   False
15:14:38 <shachaf> http://www.haskell.org/onlinereport/syntax-iso.html
15:14:42 <tomh> I can't seem to use this for example: (:?:)
15:15:12 <shachaf> symbol -> ascSymbol | uniSymbol<special | _ | : | " | '>
15:15:15 <NisseP> tomh: (:?:) is a constructor name
15:15:27 <shachaf> tomh: Starts with a colon, which is like uppercase.
15:15:27 <NisseP> As is anything starting with :
15:15:30 <tomh> ok
15:15:48 <parcs> > filter isSymbol (enumFrom 0)
15:15:49 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
15:15:49 <lambdabot>    arising from the literal `0...
15:15:59 <parcs> > filter isSymbol (enumFrom '\0')
15:16:00 <lambdabot>   "$+<=>^`|~\162\163\164\165\166\167\168\169\172\174\175\176\177\180\182\184\...
15:16:22 <Jafet> > filter isPunctuation (enumFrom '\0')
15:16:23 <lambdabot>   "!\"#%&'()*,-./:;?@[\\]_{}\161\171\183\187\191\894\903\1370\1371\1372\1373\...
15:18:16 <dolio> > map generalCategory ":[*("
15:18:16 <lambdabot>   [OtherPunctuation,OpenPunctuation,OtherPunctuation,OpenPunctuation]
15:18:34 <shachaf> dolio: Those are specifically excluded by special.
15:19:13 <shachaf> > let (‚ÅΩ‚Åæ) = (+) in 5 ‚ÅΩ‚Åæ 3
15:19:14 <lambdabot>   <no location info>: lexical error at character '\8317'
15:19:27 <shachaf> > generalCategory "‚Åæ"
15:19:28 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
15:19:28 <lambdabot>         against inferred type...
15:19:31 <shachaf> > generalCategory '‚ÅΩ'
15:19:32 <lambdabot>   OpenPunctuation
15:19:43 <shachaf> > isPunctuation '‚ÅΩ'
15:19:44 <lambdabot>   True
15:19:55 <shachaf> Hmm. Why doesn't that work?
15:22:24 <bl00dshooter> has anyone here ever remote pair programmed with macvim (or gvim)?
15:22:30 <bl00dshooter> ops, wrong channel
15:23:06 <shachaf> bl00dshooter: You could run normalvim in screen.
15:24:14 <Jafet> screen isn't designed for extreme scrumming.
15:25:00 <shachaf> Scrum of the earth.
15:25:37 * shachaf doesn't know of any obby-like editor for vim, sadly.
15:47:16 <mafs> What would be the proper type to expect if I wanted to catch an exception with network's connect?
15:47:43 <mafs> (Or how would I go about finding this out? I've been digging through the source trying to track down exactly where such an exception is thrown but have not found it yet)
15:47:59 <shachaf> "proper type"?
15:49:15 <mafs> Hmm, bad phrasing perhaps. The type signature that I would use with e so that it can type check (e.g., \(e :: IOException) -> ...)
15:59:49 <Saizan> you could discover it by making it throw an exception and catching it with \(SomeException e) -> print $ typeOf e
16:04:58 <mafs> Saizan: aha, even better, thanks
16:06:28 <tommd> @tell chrisdone That was it btw, thanks.  I didn't expect a buoild step to sed the ghc-pkg .d files!
16:06:28 <lambdabot> Consider it noted.
16:16:32 <lolsauce> Hey some guy told me this http://i.imgur.com/uukhc.png was what haskell was about
16:16:39 <lolsauce> what did he mean?
16:18:54 <scree> so, I don't actually want to click on the link lolsauce is touting, but i'm pretty sure he's trolling nonetheless
16:19:15 <lolsauce> It is some sort of comic
16:20:14 * scree is sceptical
16:21:01 <geheimdienst> scree, it's a cartoon which doesn't make much sense to me (not a shocker picture or the like)
16:21:36 <scree> oh, fair enough
16:22:06 <lolsauce> He said that's what haskellers do
16:22:12 <lolsauce> They don't actually program
16:22:31 <scree> well, it makes no sense to me either
16:23:28 <lolsauce> Well who knows
16:28:07 <Entroacceptor> so, let's say I just compiled a binary and copied it to another system
16:28:17 <Entroacceptor> same architecture and stuff, and it worked before
16:28:20 <Entroacceptor> but now I get rivertam: user error (Pattern match failure in do expression at libraries/base/System/Event/Thread.hs:83:3-10)
16:28:32 <Entroacceptor> and yes, it is compiled with ghc 7.0.2
16:29:10 <geheimdienst> (props for the name 'rivertam')
16:30:55 <Entroacceptor> :)
16:31:00 <geheimdienst> would it be possible that you have "(Just x) <- foo" in your code, where foo on the other machine evaluates to something else? suppose foo was a function that checked the machine's IP address or something
16:31:26 <geheimdienst> or that you use a library's foo function, and there's a version mismatch between the two machines
16:31:36 <Entroacceptor> maybe?
16:31:44 <Saizan> not really his code if the error happens in libraries/base/System/Event/Thread.hs:83:3-10
16:31:52 <Entroacceptor> what he says
16:32:05 <Entroacceptor> (or she/it/...)
16:32:06 <geheimdienst> right
16:32:57 <dafis> Just mgr <- readIORef eventManager
16:33:34 <Entroacceptor> ah, right, I remember vaguely
16:33:46 <Entroacceptor> (I had this before but ignored it for the time..)
16:34:07 <geheimdienst> possibly there's a little bit of runtime version mismatch ...?
16:34:15 <geheimdienst> i dunno
16:34:41 <Entroacceptor> but where should I look?
16:34:43 <Saizan> i think the rts is still linked in statically by default
16:34:59 <Saizan> you could check ldd
16:35:29 <_Ray_> Hi. Where do I start fixing/investigating this? "cabal: dependencies conflict: ghc-7.0.3 requires directory ==1.0.1.2 however directory-1.0.1.2 was excluded because ghc-7.0.3 requires directory ==1.1.0.0"
16:35:32 <Entroacceptor> http://pastie.org/private/ha99fg8syxhjamj4ikqcw <- compiling system
16:35:59 <Entroacceptor> http://nopaste.linux-dev.org/?12055 <- erroring system
16:36:15 <dafis> _Ray_: unregister directory from the user package db
16:36:40 <Saizan> _Ray_: http://www.haskell.org/cabal/FAQ.html#dependencies-conflict
16:36:45 <_Ray_> Thanks :)
16:38:28 <Entroacceptor> but I neither understand the huge differences, nor see where I could fix it
16:40:50 <Saizan> Entroacceptor: have you compiled it with -threaded ?
16:41:20 <Entroacceptor> I'm pretty sure, yes.
16:41:24 <Entroacceptor> lemme check
16:41:40 <Entroacceptor> yes
16:42:18 <Saizan> looks like a ghc bug to me
16:43:21 <Entroacceptor> mhm
16:47:18 <akahn> I'm getting the error "*** Exception: error received: Error_Packet_Parsing "Failed reading: invalid header type: 72\nEmpty call stack\n"" when I attempt to make a request using http-enumerator. Here's the code I'm using: http://pastie.org/2058177 . Any ideas what's going on here? I'm pretty new to the language and ideas.
16:48:13 <Entroacceptor> Saizan: any idea how to make sure?
16:48:37 <Entroacceptor> or, what is the normal way to distribute static binaries
16:49:17 <rovar> can anyone tell me how resize works in quickcheck?
16:49:55 <rovar> I am trying to generate data, and I don't want to constrain the max amount of the total number of records created, but I do want to constrain one of the invocations of listOf
16:51:03 <Saizan> Entroacceptor: you could try making a completely static binary with -static -optl-static , and upgrade to ghc-7.0.3
16:52:25 <rovar> nt <- listOf $ elements ([minBound .. maxBound] :: [Topic])
16:52:46 <rovar> if I change that to listOf $ resize 5 $ elements (...)
16:52:49 <rovar> still no love.
16:53:16 <Saizan> resize 5 $ listOf ... ?
16:53:22 <Saizan> ?hoogle resize
16:53:22 <lambdabot> Test.QuickCheck resize :: Int -> Gen a -> Gen a
16:53:22 <lambdabot> Text.Html noresize :: HtmlAttr
16:53:22 <lambdabot> Text.XHtml.Frameset noresize :: HtmlAttr
16:54:05 <rovar> ?hoogle listOf
16:54:06 <lambdabot> No results found
16:54:35 <rovar> listof is    gen a -> gen [a]
16:54:44 <siracusa> akahn: Have you tried accessing by another software? Curl e.g. also reports an error "error:140770FC:SSL routines:SSL23_GET_SERVER_HELLO:unknown protocol"
16:55:32 <siracusa> So it may be a server-side problem
16:56:28 <Saizan> rovar: "resize 5 $ listOf $ elements (...)" should work if you want a smaller list
16:56:43 <akahn> siracusa: in the browser or with CURL i get the correct response
16:56:44 <ski> @type Test.QuickCheck.listOf
16:56:45 <lambdabot> forall a. Gen a -> Gen [a]
16:56:57 <Entroacceptor> Saizan: --static is introduced in 7.0.3?
16:57:08 <akahn> siracusa: there's something up with the code because even if i change it to just GET http://www.google.com, I get the same error
16:57:21 <Saizan> Entroacceptor: it's -static with just one dash
16:57:35 <siracusa> akahn: Oh, I don't know then
16:57:41 <Entroacceptor> it's getting late...
16:58:50 <_Ray_> Wee, thanks dafis and Saizan, that worked well, and I now have snap and Haskell working on Ubuntu Natty, despite the broken package :)
16:59:04 <Entroacceptor> 6mb binary...
17:00:07 <Peaker> What's with GHC's inconsistent dashing
17:00:09 <Entroacceptor> Saizan: didn't change :/
17:02:19 <Entroacceptor> but I haven't upgraded ghc
17:02:50 <Saizan> does it work fine on the machine where you build it?
17:03:32 <Entroacceptor> Saizan: as far as I get..
17:03:47 <Entroacceptor> mh
17:03:53 <Entroacceptor> ok, one thing to check
17:05:29 <Entroacceptor> yeah, the local one throws an error about the database, the one on the server dies before that
17:08:11 <Entroacceptor> Saizan++ even if this didn't help :/
17:48:42 <shurane> Is there a reason why Haskell has zip3 and zip4 instead of a 'zip n' which returns a function? I'm just asking why it's like this by default.
17:49:07 <benmachine> shurane: because the type of the function would have to depend on the 'n'
17:49:26 <benmachine> types are determined at compile time, so in general that's not possible
17:50:32 <_Ray_> It could take a list of lists, ne?
17:50:54 <benmachine> _Ray_: sure, but that's not the same function; I think that's pretty much what 'transpose' does
17:51:26 <benmachine> (at least on 'rectangular' lists of lists, there may be some subtleties if the list lengths differ)
17:51:37 <_Ray_> ah
17:51:49 <hpc> > transpose [[1],[2,3],[4,5,6]]
17:51:50 <lambdabot>   [[1,2,4],[3,5],[6]]
17:51:55 <shachaf> You can use TH for it, though.
17:52:21 <benmachine> shachaf: teensy bit overkill? :)
17:52:34 <benmachine> it's probably more sensible to use zipWith in a clever way
17:52:40 <shachaf> That's true.
17:52:48 <shachaf> You can do zipN <$>/<*>-style.
17:53:04 <benmachine> yeah, you could use ZipList
17:53:14 <hpc> :t zipWith
17:53:15 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
17:53:38 <shachaf> Well, or define <$>/<*> functions that zip directly, if you prefer.
17:53:52 <shachaf> Or zip comprehensions in GHC. :-)
17:53:55 <benmachine> :t \as bs cs -> zipWith id (zipWith (,,) as bs) cs
17:53:56 <lambdabot> forall b a b1. [a] -> [b1] -> [b] -> [(a, b1, b)]
17:54:42 <hpc> :t zipWith (,,,,,)
17:54:43 <lambdabot> forall a b c d e f. [a] -> [b] -> [c -> d -> e -> f -> (a, b, c, d, e, f)]
17:55:17 <magicman> :t zipWith id
17:55:18 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
17:55:29 <rovar> hrrm.. I have another quickcheck question.   I need to generate a graph,  So  I am generating an arbitrary list of nodes and then an arbitrary list of edges that connect those nodes [(Int, Int)]  my question is, how do I feed in the size of the node list to the generator of the edges list?
17:55:31 <benmachine> :t let as |*| bs = zipWith id as bs in \as bs cs -> map (,,,) as |*| bs |*| cs
17:55:31 <lambdabot> forall a b b1 d. [a] -> [b] -> [b1] -> [d -> (a, b, b1, d)]
17:55:33 <hpc> @src ZipList
17:55:33 <lambdabot> Source not found. There are some things that I just don't know.
17:55:37 <benmachine> oops
17:55:40 <benmachine> :t let as |*| bs = zipWith id as bs in \as bs cs -> map (,,) as |*| bs |*| cs
17:55:41 <lambdabot> forall a b b1. [a] -> [b] -> [b1] -> [(a, b, b1)]
17:55:52 <shachaf> @ty liftA2 ($)
17:55:53 <lambdabot> forall b b1 (f :: * -> *). (Applicative f) => f (b -> b1) -> f b -> f b1
18:12:50 <ben> so "\x -> undefined" is a strict function?
18:12:55 <ben> this semantics thing is tricky business
18:14:21 <hpc> ben: according to the definition, yeah
18:14:51 <ben> I guess this is why unsafePerformIO is considered cheating
18:14:59 <ben> and not just because it's evil.
18:17:38 <benmachine> ben: er, why else
18:19:42 <ben> benmachine: So far I was only considering it evil because of its tendency to make my programs not behave as I *intuitively* expect it :)
18:20:15 <benmachine> ben: yeah I was just wondering how your comment related to the strict thing
18:21:00 <ben> I was equating "f is strict" with "f x forces x as it is forced itself"
18:21:12 <ben> unsafePerformIO would let me observe that I'm wrong
18:24:41 <mjrosenb> what is the definition of strict that is being used here?
18:25:57 <ben> I'm reading through http://en.wikibooks.org/wiki/Haskell/Denotational_semantics and it says f is strict iff f ‚ä• = ‚ä•
18:26:55 <mjrosenb> right... that is what i remember reading :-o
18:27:35 <ben> I'm not sure I'm supposed to read on at http://en.wikibooks.org/wiki/Haskell/Denotational_semantics#Not_all_Functions_in_Strict_Languages_are_Strict
18:27:43 <Peaker> ben: If I understand the definitions correctly: "f x forces x as it is forced itself" means f is eager on x.  Eagerness on an argument leads to strictness on it too, but it can be strict on it without eagerness (for example, if the language somehow forces totality on that argument, then f _|_ is just a non-existent case, and so it is strict in an empty sense)
18:27:44 <ben> since it says "this section is wrong" which is getting awfully philosophical
18:28:04 <c_wraith> wikiality!
18:29:05 <ben> Peaker: Can I write a haskell function that is strict but not eager or is that just a thing the language would have to define?
18:29:44 <Peaker> ben: I don't think you can do that in Haskell
18:30:24 <Peaker> I think eagerness/laziness is just about the operational behavior -- whether or not forcing leads to forcing.  Strictness/non-strictness is about the denotational behavior, whether the _|_ propagates from arg to result
18:30:40 <ben> right
18:32:16 <benmachine> ben: wait a sec, do you mean eager but not strict?
18:33:05 <c_wraith> you can do eager but not strict
18:33:15 <ben> I am not entirely sure what I mean
18:33:16 <Peaker> if you prove totality?
18:33:27 <c_wraith> no, even without totality
18:33:46 <c_wraith> you just need concurrent evaluation to remain non-strict
18:34:33 <c_wraith> assuming your form of bottom is an infinite loop, rather than throwing an exception
18:35:01 <benmachine> how can you do eager but not strict if, for example, x = f x?
18:35:17 <benmachine> you can't possibly force x when f x is forced without bottoming
18:35:21 <Cale> I've seen people use the word 'eager' to mean something more complicated than innermost-first evaluation, (in fact, it was for an evaluation mechanism with nonstrict semantics) so I tend to shy away from using it to describe a specific evaluation mechanism.
18:35:25 <benmachine> unless you do so but unnecessarily
18:35:43 <benmachine> mm
18:35:58 * benmachine just sticks to strict/nonstrict :P
18:37:03 <Peaker> but IME people talk about strictness in the context of the operational behavior they want more often than in the context of denotational behavior they want
18:37:04 <Cale> You can do speculative evaluation, where you try to evaluate innermost for a while, but do some outermost reduction if you don't terminate after so many steps.
18:37:12 <Peaker> so people usually want eager/lazy, and not (non-)strict
18:37:25 <ben> (benmachine: also stepeval is great :)
18:37:39 <benmachine> ben: :) it's a great idea that doesn't really work (yet!)
18:37:42 <monochrom> crazy evaluation is another way to do non-strict :)
18:37:50 <Cale> and then build on top of that some kind of system for remembering which expressions usually terminate quickly and which ones are problematic
18:37:50 <benmachine> heh
18:38:10 <Cale> (for future runs of the same program)
18:38:25 <benmachine> Peaker: yeah but strict/non-strict is far easier to study
18:39:15 <monochrom> strict/non-strict does not tell you how much time and how much memory
18:39:15 <Cale> Heh, yeah, crazy evaluation.
18:39:31 <Cale> Pick a random redex and reduce it. Repeat.
18:39:38 <benmachine> haha
18:39:49 <benmachine> presumably that almost surely works :P
18:39:56 <Cale> yeah
18:40:10 <Cale> at least, most of the time?
18:40:13 <Cale> lol
18:40:22 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/88120/ is an example of strict and two possible opposite memory behaviour
18:40:25 <benmachine> that's interesting actually
18:40:28 <Peaker> benmachine: searching under the flash light :)
18:40:29 <Cale> It'd be interesting to see a proof that it almost surely works
18:40:39 <Cale> in every case
18:41:19 <monochrom> in fact, turning on optimization makes it worse
18:41:24 <benmachine> Cale: well, say you have f x = f x + f x + f x, and tried to evaluate const () (f x)
18:41:49 <benmachine> Cale: I could easily imagine that as time went on it became very very likely that a redex picked at random would be an f x
18:42:15 <benmachine> hmm, that expression exactly might still complete almost surely, but I reckon you could build one which didn't
18:42:31 <benmachine> (it's not obvious, but I reckon it)
19:01:59 <shurane> is there a way to get some documentation for a command in ghci? Sort of like what the '?' operator does in iPython?
19:02:19 <Peaker> doc integration in ghci would be a great feature
19:03:05 <shurane> shucks, so not available yet?
19:03:31 <Peaker> Don't think so
19:05:29 <_Ray_> What does the syntax foo <|> bar mean?
19:05:51 <benmachine> _Ray_: <|> is an operator from Control.Applicative
19:05:56 <shachaf> _Ray_: It's applying the operator <|> to foo and bar. :-)
19:06:04 <shachaf> <|> is kind of like mplus for Applicative.
19:06:13 <benmachine> actually in fairness there are several places that define a <|>
19:06:15 <shachaf> @src Alternative
19:06:15 <lambdabot> class Applicative f => Alternative f where
19:06:15 <lambdabot>     empty :: f a
19:06:15 <lambdabot>     (<|>) :: f a -> f a -> f a
19:06:20 <benmachine> of which Control.Applicative is the most common
19:06:27 <_Ray_> Ah, cool
19:06:28 <benmachine> but I think Parsec and similar have their own
19:06:38 <luite> they have similar meanings
19:06:47 <_Ray_> This is in Snap, btw
19:07:00 <Peaker> We have 3 different Monoids :-(
19:07:19 <luite> _Ray_: they all mean something like try foo first, if that fails then bar
19:07:28 <_Ray_> Yeah :)
19:08:19 <Peaker> Or just concat lists
19:08:31 <shachaf> _Ray_: :info is your friend.
19:08:38 <cmccann> Peaker, what three are those?
19:09:04 <_Ray_> shachaf: How would I use it in this case? (ghci says "Not in scope"... I'm assuming I somehow have to 'load snap'?)
19:09:31 <shachaf> _Ray_: ghci your .hs file, I guess. Or import the appropriate Snap module.
19:09:41 <_Ray_> Alright. Thanks :)
19:09:44 <shachaf> Peaker: You mean Monad, MonadPlus/Alternative, Monoid?
19:11:16 <Peaker> shachaf: MonadPlus, Alternative, Monoid
19:11:35 <Peaker> shachaf: if we had higher-ranked class constraints, MonadPlus/Alternative could just be "law" classes
19:11:57 <Peaker> class (forall a. Monoid (m a), Monad m) => MonadPlus m where <nothing>
19:12:43 * cmccann mentions ArrowPlus as well
19:13:29 <Peaker> Arrow is altogether redundant
19:17:27 <aristid> Peaker: that, and Monoid for Maybe a should be fixed.
19:18:05 <aristid> > Just [1] `mappend` Just [2]
19:18:06 <lambdabot>   Just [1,2]
19:18:17 <aristid> > Just [1] `mplus` Just [2]
19:18:18 <lambdabot>   Just [1]
19:18:36 <Peaker> aristid: that's a great Monoid :)  For MonadPlus, you can just use the First newtype around Maybe
19:18:52 <Peaker> > First (Just [1]) `mappend` First (Just[2])
19:18:53 <lambdabot>   First {getFirst = Just [1]}
19:18:56 <aristid> Peaker: i think the First Monoid should be the default for Maybe
19:19:01 <Peaker> > runFirst $ First (Just [1]) `mappend` First (Just[2])
19:19:02 <lambdabot>   Not in scope: `runFirst'
19:19:08 <Peaker> > getFirst $ First (Just [1]) `mappend` First (Just[2])
19:19:08 <lambdabot>   Just [1]
19:19:09 <aristid> Peaker: and that one should be a newtype Monoid
19:19:36 <Peaker> recursive Monoid is the least arbitrary, I think
19:19:39 <aristid> it's not bad per se, it's just that i like First better.
19:20:34 <aristid> Peaker: First is much simpler, has less constraints, and is useful for error handling
19:21:01 <aristid> that's why MonadPlus and Alternative use it, implicitly :P
19:21:07 <_Ray_> Is playing in Agda fun?
19:21:15 <Peaker> I think they use it because MonadPlus is conventionally used for error handling
19:21:40 <Peaker> but recursive Monoid is more commonly useful IME
19:21:44 <Peaker> and more elegant
19:21:55 <aristid> never needed recursive Monoid so far
19:22:13 <aristid> what kind of stuff is it useful for?
19:25:11 <Peaker> aristid: I really like the way it is used in Phooey
19:25:52 <Peaker> aristid: I also use it to combine (Maybe (Keymap k)) where Nothing means "don't take focus" and if both want focus, then combine their keymaps
19:26:46 <aristid> Peaker: maybe Maybe should not be used for error handling, but there should be a separate option type for that.
19:27:21 <dobblego> Control.Failure.Failure
19:27:59 <Peaker> aristid: yeah, First is one possibility for it :)
19:28:05 <Peaker> Though typically Either is more useful
19:28:24 <aristid> Peaker: it's a bit convoluted due to being a newtype around Maybe, which makes pattern matching harder
19:28:56 <aristid> dobblego: Control.Failure.Failure is a type class, i don't understand your suggestion.
19:29:22 <dobblego> it leaves open the question of "how to handle failure"
19:29:33 * ski thinks it should be possible to have a type defined by more than one `newtype' definition, if all are equivalent, modulo `mewtype'
19:29:56 <aristid> ski: ?
19:30:30 <aristid> dobblego: but we were talking about Monoid and MonadPlus instances
19:31:00 <dobblego> it looked to me like it went on to discuss what "should be used for error handling" (Maybe, Either, ...)
19:31:03 <aristid> Maybe doesn't have an obvious Monoid instance because it is used for both error handling and.. other stuff
19:31:33 <aristid> if there was a clean separation, that might help
19:32:15 <aristid> Peaker: you could however use an ADT: data Focus a = Focused a | Unfocused
19:32:36 <dobblego> isn't that simply newtype Focus a = Focus (Maybe a) ?
19:32:37 <Peaker> but then I lose out on the nice combinators
19:33:00 <aristid> dobblego: it is, with nicer constructor names.
19:33:04 <Peaker> And I don't think it's a coincidence that Maybe's Monoid matches my need
19:33:12 <dobblego> why would that matter?
19:33:36 <aristid> dobblego: some people like pattern matching.
19:34:29 <aristid> Peaker: i haven't really tested this scientifically, but my feeling is that Maybe is used more often for error handling than for recursive Monoids
19:36:29 <ski> aristid : consider `newtype Ran f g a = MkRan (forall b. (a -> f a) -> g b)' (from <http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-KanExtension.html#t:Ran>)
19:36:49 <ski> aristid : now compare `newtype Codensity f a = CodensityFromRan (Ran f f a)' with `newtype Codensity f a = MkCodensity (forall b. (a -> f b) -> f b)'
19:37:12 * cmccann suggests replacing Maybe's error handling aspect with "data WatchThis a = LookIts a | Oops"
19:37:28 <cmccann> it's self-documenting
19:37:46 <aristid> ski: you had to find the scariest example?
19:37:48 <ski> aristid : the former definition is in terms of `Ran', and the latter is "direct", but modulo `newtype'-constructors, they amount to the same thing (i.e. `CodensityFromRan . MkRan = MkCodensity'
19:38:05 <ski> aristid : so we ought to be able to use both definitions at the same time
19:38:47 <aristid> ski: so what do you propose? newtype, but with new names for constructors?
19:38:53 <ski> if we don't care about the extra abstract nonsense cruft (`Ran' in this case), we can just treat it as being defined directly using `MkCodensity' from `forall b. (a -> f b) -> f b'
19:39:17 <ski> but if we're interfacing with generic code which uses `Ran', we want to unpack it into a `Ran'
19:39:20 <aristid> ski: if we could define constructors from isomorphisms, that would be cool
19:39:57 <aristid> or partial isomorphisms, even
19:40:13 <aristid> can of worms
19:40:17 <ski> you can imagine the unpacking gets more painful of there's more than one `newtype' constructor to unpack before we "reach the bottom of the matter" (as some of edwardks's code indeed do)
19:40:45 <ski> i'm just arguing that it would be very nice if we allowed code like
19:40:45 <aristid> ski: even just one unpacking layer can be prohibitive
19:40:48 <ski>   newtype Ran f g a = MkRan (forall b. (a -> f a) -> g b)
19:40:49 <ski>   newtype Codensity f a = CodensityFromRan (Ran f f a)
19:40:55 <ski>   newtype Codensity f a = MkCodensity (forall b. (a -> f b) -> f b)
19:41:16 <aristid> and it'd see that both are equivalent and not complain?
19:41:23 <ski> since if you unwrap the `Ran' in the middle definition, you get the latter definition, so they're essentially the same
19:41:27 <ski> yes
19:42:08 <ski> so, you could choose whether to match on `CodensityFromRan' or on `MkCodensity', depending on your mood
19:42:36 <aristid> newtype First a = First { getFirst :: Maybe a }; data First a = JustFirst a | NothingFirst
19:42:40 <aristid> would that work, too?
19:42:47 <ddarius> There is one way of doing that ...
19:42:48 <ski> so, basically, this would mean that `CodensityFromRan . MkRan = MkCodensity'
19:43:27 <xplat> the First monoid comes from the Maybe MonadPlus, and indirectly from the Either MonadPlus
19:43:37 <ski> aristid : i haven't decided whether it could be sensibly allowed for two definitions which aren't `newtype's
19:43:55 <xplat> the Maybe monoid doesn't come from a MonadPlus
19:43:58 <ski> aristid : but yes, one need to be careful about instances, of course
19:44:02 <aristid> ski: i think what i want is more general
19:44:22 <xplat> even though it's sometimes useful, i bet it gets troublesome that those two don't match
19:44:44 <aristid> xplat: yeah.
19:44:57 <xplat> like if Applicative for [] were ZipList's Applicative
19:45:03 <shachaf> Peaker: mappend and mplus are different, though.
19:45:05 <ski> aristid : in your case, how would it know, in *general*, which constructors of `Maybe' to associate with which constructors of (the latter) `First' ?
19:45:16 * shachaf suspects he missed a few pages of discussion.
19:45:24 <Peaker> shachaf: they have same semantics, just different instances
19:45:27 <aristid> ski: that's why i want something more general, where those associations are made explicit.
19:45:39 <ski> (replace `First' by some other datatype which has at least two constructors of the same type)
19:45:46 <xplat> <*> and ap are different too, but you don't want them to be different
19:45:46 <Peaker> class MonadAwesome m where awesomeReturn :: a -> m a ; awesomeBind :: ...
19:45:56 <Peaker> now proceed to make instances that are sometimes different
19:46:34 <aristid> ski: the solution would somehow annotate it to link the constructors. but don't ask me how
19:46:39 <ski> aristid : if you can figure out a nice generalization, great. but what i think seems nice about the `newtype's-only proposal is that it should require no extra information
19:47:22 <ski> ddarius : .. doing what i was considering ?
19:47:30 <ddarius> ski: Yes.
19:47:54 <xplat> maybe newtype Focused a = Maybe a where { Focused = Just ; Unfocused = Nothing }
19:47:59 <ski> (aristid : re "scariest", this was the first real example i could think of)
19:48:11 <xplat> or you don't even need the Maybe a, it could be inferred
19:48:25 <aristid> ski: First is a real example, but doesn't work with your proposal because it has multiple constructors
19:48:26 <ddarius> That would be called views.
19:48:40 <xplat> but it might be useful for documentation purposes
19:48:54 <ski> ddarius : using coercions like at <http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes> somehow, or something else ?
19:49:09 <aristid> xplat: yeah, that looks good
19:49:40 * ski is not suggesting full-scale views, btw
19:50:26 <shurane> is Data.List.map different from Data.Map.map and 'plain regular' map?
19:50:33 <ski> (aristid : yeah, the first real example fitting my original idea, not your generalization-attempt of it :)
19:50:47 <ddarius> ski: unsafeCoerce will do it.  Though, you should indeed be able to use the new type system implementation to make a safeCoerce.
19:50:48 <ski> @type Data.List.map
19:50:49 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:50:51 <aristid> xplat: i really like the syntax of newtype Focused a = Maybe a where { Focused = Just ; Unfocused = Nothing }
19:50:53 <ski> @type Data.Map.map
19:50:54 <lambdabot> forall a b k. (a -> b) -> M.Map k a -> M.Map k b
19:51:00 <ski> @type map
19:51:01 <xplat> shurane: the first and the last are the same, the middle one is different
19:51:01 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:51:33 <ski> shurane : `map' has the same type as `Data.List.map', and actually also is the same operation. `Data.Map.map' has a different type, so can't be the same
19:52:18 <xplat> i'm not sure newtype views are a good idea because you'd have to impose kind of arbitrary-seeming restrictions on them compared to other newtypes, but they would certainly be convenient
19:53:33 <xplat> well, or you could make them arbitrary views and then there wouldn't be restrictions, but i'm tempted to assume there's a good reason general views don't exist already
19:54:00 <xplat> although i'd like to know what it is :)
19:54:23 <aristid> when you're talking about views, it's not the f (g -> v) = q v stuff?
19:54:45 <ddarius> xplat: The feelings on views are rather polarized.
19:54:54 <xplat> in this case i'm talking about the old kind of views
19:55:00 <Peaker> I don't think the language needs to grow for this
19:55:09 <ddarius> aristid: Those are view patterns not views.
19:55:10 <ski> (aristid : that's view patterns / transformation patterns (<http://research.microsoft.com/en-us/um/people/simonpj/papers/pat.ps.gz>))
19:55:31 <aristid> what are views, then?
19:55:40 <ddarius> @google views wadler
19:55:43 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/topics/language-design.html
19:55:43 <lambdabot> Title: Wadler: Language design
19:56:10 <xplat> views are basically abbreviations for / abstractions of regular constructor patterns
19:56:41 <xplat> basically, a function you can also use in pattern matches, with the restriction that no recursion is allowed
19:57:24 <xplat> and no pattern matching, and all arguments must be used
19:57:35 <aristid> xplat: and no bottom?
19:58:23 <xplat> aristid: that's not a restriction, but it's a property that can be emplaced because of the restrictions
19:58:44 <ski> @src Complex
19:58:45 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
19:59:07 <aristid> xplat: if views are so old, is there a GHC extensions for it? :D
19:59:17 <xplat> (i think those are the right restrictions anyway--the idea is that the function is constant time and can be automatically inverted)
19:59:19 <ski> with views, one could have a `Rect' "constructor" as well as a `Polar' "constructor"
19:59:27 <ski> (which would not be disjoint)
19:59:36 <xplat> aristid: i think they've been written long ago, but not accepted in mainline?
19:59:58 <ski> aristid : they were not implemented (at least not in Hugs or GHC)
20:00:29 <aristid> well ok. good night.
20:00:31 <xplat> ah, so implementation was never finished even experimentally?
20:00:31 <ski> btw, Mercury sortof have views
20:00:32 <ddarius> I'm pretty sure they were never implemented in any Haskell implementation.  At least one, ML implementation has them though.
20:01:09 <ski> ddarius : oh. i've never encountered them in any ML (SML or OCaml or what ?)
20:01:10 <xplat> anyway, it seemed the simons preferred view patterns/transformation patterns
20:02:12 <xplat> i wonder if it was because views couldn't be finished for some other reason, or if they were never finished because they were the unfavourite?
20:02:14 <ski> (in Mercury you can e.g. define `foo("blah" ++ Rest) = ..Rest..', since the function `(++)' has a backward mode (as well as the forward one)
20:02:53 <xplat> ski: that's common to most languages in prolog's family tree though
20:02:54 <ski> there were semantical problems with views (as specified), iirc
20:03:21 <ski> xplat : yeah, except Prolog doesn't have functions (apart from what is effectively data constructors)
20:04:28 <xplat> ski: does mercury have actual functions or just function syntax for relations?
20:04:57 <ski> aristid,xplat : <http://classic-web.archive.org/web/20071228122450/http://www.haskell.org/development/views.html> has some info on views
20:05:07 <ski> xplat : what's the difference ?
20:05:22 <xplat> ski: functions can only have one 'answer'
20:06:00 <ski> functions can only return one result, if you want more you need to use tuples (unlike arguments, which can be multiple, without using tuples)
20:06:23 <ski> or maybe you mean that functions can have at most one solution ? yes, that's true of Mercury functions
20:06:30 <xplat> ski: i don't mean at a time, i mean a function couldn't have alternative results
20:07:01 <xplat> ah, good to know
20:07:06 <ski> (unfortunately it's possible to have a Mercury function which can for some inputs have no solutions .. i've read some developers mention that this was probably a mistake)
20:08:07 <xplat> heh, i thought those folks were too practical-minded, among logic programmers, to resent general recursion like that :)
20:10:12 <xplat> (although these days i'm starting to think embracing general recursion is a false form of practicality)
20:11:22 <ddarius> xplat: Mercury has determinism annotations so that doesn't really differentiate functions and predicates in Mercury.
20:16:32 <ddarius> HaMLet supports views, though I thought there was a more mainstream SML implementation that did.
20:42:34 * hackagebot authenticate 0.9.1.3 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.9.1.3 (MichaelSnoyman)
20:46:51 <ski> xplat : "resent general recursion" ?
20:59:44 <ski> xplat : to clarify, when i said functions are allowed to have zero solutions, for some inputs, i didn't mean because of nontermination, but because of finite failure (so the function returns, but failing, instead of succeeding)
21:02:18 <ski> ddarius : ok. i'm not sure i've seen HaMLet before
21:02:31 <ski> (istr the name, but i'm not sure)
21:02:39 * hackagebot egison 0.2.0.1 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-0.2.0.1 (SatoshiEgi)
21:17:09 <aavogt> preflex tell ivanm where has the haskell-updater repo gone?
21:17:09 <preflex>  Consider it noted.
21:19:46 <Cale> http://radar.oreilly.com/2011/06/javascript-edges-permanent-james-duncan.html -- wtf, what are the vertices in the graph this dude is talking about?
21:19:55 <Cale> What's happening now is that JavaScript is installed on millions and millions of edges of our network. If you think of every web-accessing device as an edge on the network, then JavaScript is in all of them. Every web browser has it, every smartphone has it.
21:20:27 <Cale> Which two vertices in this graph are supposed to be connected by my computer? :P
21:22:34 <luite> he wrote node.js so javascript is supposedly at the nodes as well ;)
21:22:57 <Cale> I get the feeling that this guy decided that the word "edge" sounded cool, and since he likes Javascript, he really wants to be able to say that it's in the edges of something, and that's about as much thinking went into the statement.
21:41:53 <ddarius> Cale: Perhaps they are the edges of the underlying graph of a category representing a monoid.  Then the node isn't so important.
21:42:03 <gienah> aavogt: seems to be here: https://github.com/gentoo-haskell/haskell-updater
21:44:34 <ddarius> Cale: Why did you decide to read that article in the first place?
21:56:49 <Cale> ddarius: It was on programming reddit
21:57:09 <Cale> ddarius: The thing about edges is in the title and made me wonder.
21:57:48 <ddarius> Cale is a sucker for discrete math.
21:58:02 <laxmi> hello setup.hs missing in ghc 7 configure
21:58:24 <laxmi> setup.hs missing in ghc 7 configure any help
22:00:08 <Cale> laxmi: sorry, what? Could you pastebin the message you're getting? Are you trying to compile ghc 7 yourself?
22:03:00 <laxmi> laxmi@laxmi-laptop:/ghc/ghc-7.0.3$ sudo runhaskell Setup configure
22:03:00 <laxmi> <command line>:
22:03:01 <laxmi>     Could not find module `Setup':
22:03:02 <laxmi>       Use -v to see a list of the files searched for.
22:03:21 <laxmi> At least the following dependencies are missing: Cabal ==1.8.*, HTTP >=4000.0.2 && <4001, base >=2.0 && <2.2, network >=1 && <3, time ==1.1.*, zlib >=0.4 && <0.6
22:05:43 * ddarius will post an article to reddit: "Generating functions for javascript" waxing poetic about something cruddy like constructing functions from strings.
22:05:54 <Cale> ddarius: ahaha
22:06:28 <Cale> laxmi: I don't understand why you decided to run that command
22:07:34 <Cale> laxmi: ghc isn't a cabal package, you  ./configure && make && make install  if you're compiling from source, iirc. I don't compile GHC myself though.
22:07:54 <Cale> laxmi: (and I don't recommend it unless you're hacking on it)
22:08:29 <laxmi> ok GHCi, version 7.0.3: http://www.haskell.org/ghc/  :? for help
22:08:30 <laxmi> Loading package ghc-prim ... linking ... done.
22:08:30 <laxmi> Loading package integer-gmp ... linking ... done.
22:08:30 <laxmi> Loading package base ... linking ... done.
22:08:30 <laxmi> Loading package ffi-1.0 ... linking ... done.
22:08:31 <laxmi> Prelude>
22:08:53 <Twey> Uh, that's what's supposed to happen.
22:09:14 <laxmi> Now I want to try online gui in my localhost
22:13:28 <Twey> Online what?
22:14:53 <laxmi> to run via localhost
22:15:30 <laxmi> online grammar browsing with gf
22:15:42 <laxmi> grammatical-framework
22:16:10 <luite> is it possible to turn off the ThreadId output in ghci when doing forkIO?
22:18:19 <laxmi> for configuring gf- runghc Setup.hs configure, code does not work
22:20:36 <DevHC> can i stop ghci from display >1 "it" autocomplete alternatives?
22:21:14 <laxmi> http://pastebin.com/EVvAQKe8
22:21:15 <mauke> The paste EVvAQKe8 has been copied to http://hpaste.org/new
22:21:39 <Cale> laxmi: That command has nothing to do with GHC's installation
22:21:58 <Cale> laxmi: You're in the ghc-7.0.3 directory
22:22:07 <laxmi> yes
22:22:19 <laxmi> wait
22:22:30 <luite> Cale: I used PSQueue instead, so you don't have to upload a new fingertree-psqueue :)
22:24:20 <portnov> hi all
22:25:33 <laxmi> wait I will try to gf irc
22:29:11 <portnov> Q: is there a library for binary files reading/writing for Haskell? Data.Binary looks good, but I need to write aligned data in some cases. Data.Binary.Put has no functions for alignment or to get current offset in output string.
22:35:32 <Cale> luite: Well, thanks for letting me know about it anyway, I'll probably fix it at some point soon.
22:40:12 <Twey> portnov: http://hackage.haskell.org/packages/archive/cereal/0.3.3.0/doc/html/Data-Serialize-Put.html#g:4 ‚Äî is this helpful to you?
22:41:29 <Cale> portnov: imo, Data.Binary and friends (like cereal) are for the most part better suited to writing binary files which are produced by the same library rather than arbitrary formats, but yeah, if you're going to do it, those are probably interesting.
22:41:35 <portnov> Twey: I do not see `getCurrentOutputOffset :: Put Int64' or smth like there
22:42:42 <Twey> portnov: I would hope not; that wouldn't be composable
22:42:58 <Twey> You should be able to make sure it aligns properly by using the right Word sizes, though‚Ä¶
22:43:04 <Twey> Oh
22:43:20 <Twey> You have something variable-length, and you need to pad it to alignment?
22:43:27 <portnov> twey: yes
22:43:47 <portnov> For example, I read in some format specification: ¬´Put a few zero bytes here, such that next data chunk should start at offset which is dividable by 4¬ª
22:44:49 <Twey> Well, you can write aligned serialisation functions
22:45:16 <Twey> I'm guessing that follows a variable-length structure
22:45:46 <portnov> Twey: this could not be done with binary/cereal (as far as can I see), because there is not ¬´get current offset¬ª function in their Put monads.
22:46:02 <Cale> Right
22:46:12 <Cale> Well, you can, it's just awkward
22:46:20 <Twey> You can combine the variable-length structure (say a ByteString) and the padding after it into one function, so: write4Aligned bs = bs `mappend` replicate (mod 4 $ length bs) 0
22:46:26 <Twey> (pseudo-code, obviously)
22:46:42 <Cale> In that you could output the thing and then align it separately, but that might not be as cheap as you'd like.
22:47:30 <portnov> Currently I'm trying to write some wrapper over Data.Binary using StateT.
22:47:51 <Cale> Yeah, you could StateT over PutM
22:48:06 <Cale> and then write some primitives which increment a length counter
22:48:09 <Twey> You wouldn't want to have a ‚Äòget current offset‚Äô function in Put, because then you wouldn't be able to combine their results: depending what someone did with it, it might have entirely different output depending on where you used it
22:48:17 <dmoctezuma> How can I do a while loop? I'm trying to do a simple I/O program that needs to be running while the user input is different from "exit"/"quit"
22:48:37 <Cale> Twey: Well, it's already a monad
22:48:39 <Twey> You should do it as an aligned writer function :-\  Or am I missing the point hugely?
22:49:01 <Twey> Cale: It's a monad, but as it stands it's sanely composable
22:49:08 <Twey> No?
22:49:17 <Twey> dmoctezuma: Recurse instead
22:49:20 <Cale> Twey: Well, the associativity will be weaker, sure.
22:50:31 <shachaf> Twey: Don't you find that pattern rather distasteful?
22:50:50 <Twey> dmoctezuma: main = do input <- getLine; if input `elem` ["exit", "quit"] then print $ reverse input else return ()
22:50:58 <Twey> shachaf: Which pattern?
22:51:22 <Cale> Twey: that's not recursive ;)
22:51:26 <Twey> Errrr
22:51:29 <Twey> >.>
22:51:44 <Twey> dmoctezuma: main = do input <- getLine; if input `elem` ["exit", "quit"] then do print $ reverse input; main else return ()
22:52:01 <Cale> elem -> notElem
22:52:13 <shachaf> Twey: let go = do { l <- getLine; when (not (null l)) $ do { process l; go } } in go
22:52:14 <Twey> Yeah.  I'm a bit fuzzy-headed this morning.
22:52:21 <Twey> Oh, that one
22:52:49 <shachaf> Generally people try to eliminate explicit recursion, e.g. with folds and what not.
22:52:54 <Twey> Yes, but dmoctezuma is clearly not ready for any of the nicer ways of doing it, yet.
22:53:00 <shachaf> It seems odd if it's the standard thing recommended here.
22:53:07 <Twey> It's an introductory thing.
22:53:26 <shachaf> Which nicer ways are you referring to?
22:53:28 <Cale> whileM cond body = do b <- cond; if b then (do body; whileM cond body) else return ()
22:53:54 <shachaf> Cale: And then how will cond examine the input?
22:53:58 <Twey> interact on lines, or an iteratee version of the same
22:54:16 <Cale> shachaf: kind of why it's not in the library. You could use an IORef.
22:54:25 <Twey> x.x
22:54:47 <isomorphic> there is a nice document that shows implementation of simple unix utilities in Haskell
22:54:48 <dmoctezuma> wow, that's confusing
22:54:48 <shachaf> Cale: Yes, exactly. Is there no simple way of capturing that sort of thing?
22:54:52 <isomorphic> perhaps that would be useful?
22:54:52 <Cale> "You wanted a while loop, here's a while loop."
22:55:05 <Twey> Heh
22:55:23 <shachaf> Right, except what I wanted wasn't a while loop, it was a nice way of expressing that function. :-)
22:55:37 <Twey> shachaf: Can't you have ‚Äòcond = fmap (== "exit") getLine‚Äô?
22:55:38 <isomorphic> http://www.haskell.org/haskellwiki/Simple_unix_tools
22:55:55 <shachaf> Twey: Then body won't be able to process it.
22:56:19 <Twey> Hm, or cond :: m (Maybe a) or something
22:56:25 <Cale> We could use:
22:56:36 <shachaf> isomorphic: Those are all interact-based.
22:57:21 <Cale> whileM x cond body = do v <- x; if cond v then (do body v; whileM x cond body) else return ()
22:57:23 <Twey> whileM cond body = do b <- cond; case b of Nothing -> return (); Just v -> do body v; whileM cond body
22:57:45 <dmoctezuma> I would prefer a proper haskell way to doing it, I've just started to learn it and don't want to have bad practices :P
22:57:55 <Cale> whileM getLine (`notElem` ["exit", "quit"]) $ \line -> ...
22:58:35 <Twey> toMaybe cond v = if cond v then Just v else Nothing
22:58:57 <shachaf> I suppose that would work, but it's starting to seem awfully specific.
22:59:07 <isomorphic> shachaf: Yes.  I'm not putting forward a view on the "right" way to do it.  Rather, I was meaning to show some example code that was along roughly the right lines
22:59:14 <Cale> dmoctezuma: But, just recursing is the usual way, because there are so many minor variations on what might be a convenient while loop in different circumstances, and recursion usually is clear enough in any case.
22:59:27 <Twey> whileM (fmap (toMaybe (`notElem` ["exit", "quit"]) getLine) $ \line -> ‚Ä¶
22:59:44 <Cale> hehe
22:59:46 <Twey> Er, plus a bracket >.<
22:59:51 <shachaf> What happened to "the world's finest imperative language"? :-(
23:00:04 <Twey> shachaf: The bar is pretty low in this case :√æ
23:00:36 <Cale> Straightforward recursion is not really much worse than a while loop.
23:00:41 <Cale> If you want, you can use fix
23:00:48 * edwardk waves hello.
23:00:51 <edwardk> preflex: xseen roconnor
23:00:51 <preflex>  roconnor was last seen on freenode/#haskell 7 hours, 52 minutes and 58 seconds ago, saying: * roconnor hasn't used maybe infix before
23:00:57 <Twey> You could have a helper, too: whileMCond get cond body = whileM (fmap (toMaybe cond) get) body
23:01:07 <shachaf> True. But even with fix you're not going to @pl it, are you?
23:01:13 <shachaf> So you have to introduce a new name for nothing.
23:01:28 <Cale> You introduce a new name for looping.
23:01:34 <isomorphic> did anybody else see that 'comprehensible input' or 'input hypothesis' approach to language teaching?
23:01:36 * shachaf has the feeling he's nitpicking at this point. It just seems annoying.
23:01:48 <Twey> whileMCond getLine (`notElem` ["exit", "quit"]) $ \line -> ‚Ä¶
23:01:52 <Twey> I think that's pretty nice.
23:02:17 <Cale> fix $ \loop -> do x <- getLine; if ... then do ...; loop else return ()
23:02:49 <shachaf> What an innovative method of eliminating explicit recursion. :-)
23:02:55 <Cale> kekeke
23:03:01 <Twey> Heh
23:04:02 <Cale> At least you're not actually giving a non-local name to anything.
23:04:17 <dmoctezuma> Twey, what does the ` character stands for?
23:04:25 <Cale> It's just a lambda :)
23:04:28 <shachaf> dmoctezuma: Makes things infix.
23:04:50 <Cale> > elem 5 [1..10]
23:04:51 <lambdabot>   True
23:04:54 <shachaf> Cale: You write your lambdas in superscript?
23:04:56 <Cale> > 5 `elem` [1..10]
23:04:56 <lambdabot>   True
23:05:06 <Cale> shachaf: wat
23:05:12 <isomorphic> http://ask.slashdot.org/comments.pl?sid=2198700&cid=36293622
23:05:17 <shachaf> Oh, I thought you misread ` as a superscript \.
23:05:25 <shachaf> Never mind.
23:05:40 <shachaf> What do you mean by "non-local name"?
23:06:32 * edwardk spams cale's email.
23:06:35 <Cale> shachaf: I mean, when you write something like  do ... ; let { loop = ... } ; loop ; ...
23:07:00 <Cale> It's a little leaky. I suppose let/in is better that way, but syntactically a bit more annoying.
23:07:20 <Cale> Also, having to refer to the loop you just defined is a bit annoying.
23:09:03 <Cale> edwardk: It would be nice to come down and catch some of that... I've been feeling quite rough, and I'd need to figure out a bus or something, but perhaps I'll find a way :)
23:10:02 <shachaf> I thought the plan was to walk?
23:10:30 <Cale> If I'm going to walk, I'd better start now.
23:17:20 <dmoctezuma> shachaf, how good/bad it is to use recursion in a simple I/O program?
23:18:11 <dmoctezuma> I thought that would make the program heavier (in memory of course)
23:18:49 <edwardk> i suppose another option might be for wren and i to wander up that way to harass you tuesday night ;)
23:19:45 <shachaf> dmoctezuma: Heavier? Why?
23:20:07 <shachaf> Recursion is pretty much the way you do things in Haskell, whether explicitly or through library functions.
23:21:10 <dmoctezuma> shachaf, if I just input a number and the program just prints the double of that number, and then waits for me for another input and so on until I tell him to stop. What about that case? using recursion..
23:22:10 <fabjan> dmoctezuma: Your recursive program will be compiled to almost the same code as a loop
23:28:12 <dmoctezuma> cool, I've just check it on the system manager and the memory it uses doesn't increase or so, it stays very very low
23:28:27 <dmoctezuma> Cale, Twey, shachaf, fabjan, thanks
23:37:32 <yitz> @tell isomorphic thanks for the link, that's a nice ./ post.
23:37:32 <lambdabot> Consider it noted.
23:37:58 <laxmi> any information abt grammatical frameworl -gf irc address
23:38:09 <laxmi> any information abt grammatical framework -gf irc address
23:39:25 <edwardk> cale: to reduce the barrier to arrival, if you can figure out a way down i can get you back ;)
23:39:41 <yitz> laxmi: http://www.grammaticalframework.org/
