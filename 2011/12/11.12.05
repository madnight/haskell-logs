00:03:27 <issactrotts> I fixed my problem by bringing over the .cabal/config from my other mac and then running cabal install --reinstall for the package I want (yesod). I wonder why the new .cabal/config puts things in odd places...
00:15:52 <sopvop> Is usage of Typeable considered capitulation?
00:18:16 <lambdabot> Plugin `quote' failed with: thread killed
00:18:28 <ddarius> @botsnack
00:22:37 <Axman6> sopvop: no? what makes you think that?
00:25:06 <sopvop> It uses it's own extension and turns haskell into safe python. To me it looks way too magical.
00:27:21 <Axman6> I think one of the reasons it exists is for when you know something is actually type safe, but you can't prove it to the compiler
00:27:54 * hackagebot ConfigFileTH 0.2 - Template haskell for reading ConfigFiles.  http://hackage.haskell.org/package/ConfigFileTH-0.2 (VilleTirronen)
00:29:36 <ddarius> The fundamental purpose of it is to recover type information.
00:30:55 <Axman6> sopvop: typeable itself isn't magic at all, there's no need for any extensions
00:31:54 <Mathnerd314> OK, I am thinking. can someone merge all the existing programming languages and compilations together?
00:32:02 <Axman6> no
00:32:06 <Axman6> next!
00:32:22 <mbetter> I'll get right on it
00:32:37 <koala_man> why choose between lazyness and mutability when you can have both!
00:32:37 <osfameron> just imagine how awesome a programming language with all the features of Haskell AND Perl AND C AND COBOL would be though!
00:32:48 <Mathnerd314> yes, exactly!
00:32:58 <mjrosenb> Axman6: if we restrict ourselves to haskell programs with fewer than 10 variables, can we solve the halting problem?
00:33:07 <Philippa> osfameron: BEGIN LINE NOISE !<"£><%$£> END LINE NOISE ?
00:33:21 <Mathnerd314> Philippa: of course not
00:33:34 <Axman6> mjrosenb: maybe
00:33:35 <Axman6> next!
00:33:36 <Philippa> mjrosenb: s, k, ohshit?
00:33:44 <Mathnerd314> just use haskell's syntax for now. it's pretty good
00:34:17 <Philippa> you also can't merge "all the compilations", they take mutually exclusive chunks of the design space
00:34:21 <mjrosenb> Philippa: i should have said 6 :-p
00:34:32 <Mathnerd314> Philippa: well, combine all the best ones
00:34:35 <Philippa> you can try to merge the features, but say hello to a massive research project that'll probably only get part way there
00:35:24 <mjrosenb> i mean there are plenty of languages that try to be multi-paradigm
00:35:28 <mjrosenb> and nobody uses them
00:35:29 <Mathnerd314> Philippa: I just want a really strongly-typed programming language
00:35:46 <Mathnerd314> that is connected to the internet
00:35:49 <Axman6> well, that rules out integrating all the dynamically types ones =)
00:35:58 <mjrosenb> Philippa, Mathnerd314, osfameron see also: rust
00:36:19 <Axman6> rust is still very much in development
00:36:34 <Mathnerd314> Axman6: no, I want the types to be after I run a step
00:36:42 <Philippa> mjrosenb: I think Oz-style multiparadigm is the wrong way to go in a statically-typed setting
00:36:58 <Mathnerd314> like I run a type-inferencer program and it fills in the program with types
00:37:04 <Mathnerd314> a code beautifier, if you will
00:37:07 <mjrosenb> Axman6: i think we've finally settled on a syntax!
00:37:11 <Philippa> to the point where I have a problem with PvR's framework because he treats alternatives with embeddings as 'invalid' or 'fallacious'
00:37:50 <mjrosenb> Philippa: PvR?
00:37:55 <Philippa> Mathnerd314: aren't you a special one? Plenty of us want features that don't support complete inference
00:38:37 <Axman6> mjrosenb: for rust?
00:38:52 <Mathnerd314> Philippa: I am just a delivery boy... helping information gets where it want to be
00:39:13 <mjrosenb> Axman6: yeah.
00:39:23 <Mathnerd314> or rather, I want some sort of system I can work on that does that
00:40:19 <Jafet> @quote python.way
00:40:40 <Mathnerd314> I think IRC is a good place to start
00:41:04 <mjrosenb> > "are you there?"
00:41:14 <Mathnerd314> yes
00:41:17 <mjrosenb> lambdabot: ping?
00:41:23 <mjrosenb> :(
00:41:30 <Mathnerd314> oh, right I want lambdabot
00:41:40 <Mathnerd314> I want someone to port it to windows for me
00:42:09 <Axman6> lambdabot: Y U BE NOT LISTENING?
00:42:25 <ddarius> Axman6: elliott has corrupted her.
00:42:44 <Philippa> Mathnerd314: have you learned much about constraint systems?
00:42:47 <Jafet> She's not pure any more?
00:43:43 * ddarius chooses not to make a crass joke.
00:47:09 <danr> I run many processes with createProcess, and sometimes I kill them from another thread, and terminate the process with terminateProcess. I still get lots of zombie-processes, how do I kill them?
00:47:48 <Axman6> what are these processes doing?
00:47:55 * hackagebot persistent 0.6.4.2 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.6.4.2 (MichaelSnoyman)
00:48:04 <danr> Axman6: running an automated theorem prover
00:48:10 <Axman6> ah
00:48:22 <danr> (eprover, to be exact)
00:48:23 <companion_cube> danr: for which logic?
00:48:26 <companion_cube> oh, nice
00:49:40 <danr> the relevant code is on https://github.com/danr/autospec/blob/master/src/Autospec/RunProver.hs, and the important functions are the last two one, runProver and worker
00:52:55 * hackagebot http-enumerator 0.7.1.8 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.7.1.8 (MichaelSnoyman)
00:53:40 <Mathnerd314> Philippa: yeah. I have learned that english is not that bad a way
00:55:17 <Mathnerd314> hackagebot should go away to a different channel. #new-things or something
00:55:46 <Axman6> we quite like hackagebot actually
00:56:17 <companion_cube> yeah, it allows to comment on weird/amusing packages
01:02:29 <tekknolagi> ohai! haven't been on here in a while.
01:02:55 * hackagebot convertible-text 0.4.0.1 - Typeclasses and instances for converting between types  http://hackage.haskell.org/package/convertible-text-0.4.0.1 (MichaelSnoyman)
01:07:04 <carpi> Is there a difference beteween polymorphic types and overloaded types?
01:09:27 <ddarius> Types aren't overloaded.
01:13:01 <carpi> because in "Programming in Haskell" the author talks about polymorphic and overloaded types implying they weree 2 different things
01:14:08 <earthy> they are
01:14:39 <earthy> (but it's function names that can be overloaded in haskell, rather than types)
01:15:58 <carpi> ah , got it - ) i think i understand. i
01:42:56 * hackagebot netwire 3.1.0 - Fast generic automaton arrow transformer for AFRP  http://hackage.haskell.org/package/netwire-3.1.0 (ErtugrulSoeylemez)
01:58:14 <lambdabot> Plugin `dummy' failed with: thread killed
02:02:34 <Phyx-> oh oh
02:03:06 <Phyx-> @type id
02:03:24 <Phyx-> :t id
02:03:26 <Phyx-> :(
02:22:27 <carpi> could someone please tell me why is this an invalid pattern? "myPred (n+1) = n"?
02:22:55 <sipa> you're using an n+k pattern, which is deprecated
02:23:28 <carpi> ah okay.. cos it is mentioned in a book about haskel
02:23:41 <carpi> i must be reading an old bok
02:26:58 <Phyx-> if he switches to Haskell98 it should work right?
02:29:41 <hpaste> Haskell_newbie pasted “Cabal install error” at http://hpaste.org/54876
02:30:43 <haskell_newbie> I  have installed  ghc-7.2.2 and installing cabal
02:30:51 <haskell_newbie> but i am getting error
02:31:07 <haskell_newbie> http://hpaste.org/54876
02:32:50 <Saizan> looks like the bootstrap script is not meant to work on ghc-7.2.2
02:32:56 <cacs> hello. how am I supposed to chat here?
02:33:31 <haskell_newbie> Saizan: so how to install cabal for ghc-7.2.2.
02:33:53 <cacs> Hi, I'm a newbie in haskell.. how am I suppose to run haskell on emacs?
02:33:57 <dcoutts> haskell_newbie: there is no release of cabal-install that is compatible with 7.2
02:34:13 <dcoutts> haskell_newbie: if you are a newbie, I suggest you stick to the released version of the Haskell Platform
02:34:18 <dcoutts> which includes ghc-7.0.4
02:34:24 <dcoutts> and cabal-install and other stuff
02:34:29 <dcoutts> erm 7.0.3
02:34:51 <dcoutts> haskell_newbie: 7.2.x is not for newbies at the moment
02:35:32 <haskell_newbie> dcoutts: Thank you
02:37:08 <zenzike> cacs: probably the easiest is to create files that end in .hs and to edit that source code directly in emacs, and then compile the code in a separate terminal using ghc (or play around with it in ghci)
02:38:05 <zenzike> cacs: there's a haskell-mode that makes your syntax highlight nicely: M-x haskell-mode might work if it's installed (on ubuntu you can apt-get install haskell-mode)
02:42:09 <cacs> I run a windows os .. I have a emacs and I'm having a hard time on how to run haskell on emacs.
02:42:52 <haskell_newbie> dcoutts: There is no  32 bit binary for fedora 15 . https://admin.fedoraproject.org/community/?package=haskell-platform#package_maintenance/details/downloads and for 64 bit rpm , i am getting error.
02:42:53 <jim``> hi, I can't find Data.Array.Parallel.Base.(:*:). Anyone know where it went?
02:43:30 <binsh> Herro! WHats the difference between using : and ++ with lists?
02:43:50 <Phyx-> :t (:)
02:43:50 <haskell_newbie> :t (:)
02:44:01 <haskell_newbie> :t ( ++ )
02:44:04 <Phyx-> lambdabot: ? hellooo
02:44:18 <mux> binsh: (:) prepends a single element on the head of a list, (++) concatenates two lists
02:44:30 <dcoutts> haskell_newbie: if the rpms are no good you can use the generic ghc binary and the source installer for the platform
02:44:45 <Phyx-> binsh: (:) ::  a -> [a] -> [a] -- prepend an element to the start of the list, (++) :: [a] -> [a] -> [a] , concatenates two lists together
02:45:15 <binsh> nice, thx :)
02:45:43 <Phyx-> cacs: if you're on windows, might i recommend notepad++ instead?
02:47:12 <DevHC> binsh: what's the likelyhood of "binsh" meaning "binary shader"? :}
02:47:31 <binsh> nope, its #!/bin/sh/ :P
02:48:38 <dudnik> cacs: you could also try Sublime Text 2
03:04:23 <Phyx-> weird... i keep crashing ghci
03:04:42 <Phyx-> and getting "SetConsoleCursorPosition: invalid argument (The parameter is incorrect.)"
03:05:27 <Jafet> Your argument is invalid
03:05:52 <Phyx-> not mine, ghci's
03:08:35 <cacs> thanks..
03:08:55 <cacs> what is emacs for ?
03:12:40 <Jafet> That's a very good question.
03:17:13 <silver> @seen vrook
03:17:13 <preflex>  vrook was last seen on #haskell 13 hours, 1 minute and 35 seconds ago, saying: Well it wouldn't be standarized core itself per se, but using core as a reference to make sure all bases are covered. It would certainly be a monumental undertaking, but the outcome would be a language which includes Haskell and all its GHC extensions that could be implemented more than once.
03:17:58 * hackagebot persistent 0.6.4.3 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.6.4.3 (MichaelSnoyman)
03:18:00 * hackagebot persistent-postgresql 0.6.1.2 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-0.6.1.2 (MichaelSnoyman)
03:18:02 * hackagebot persistent-sqlite 0.6.2.1 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-0.6.2.1 (MichaelSnoyman)
03:18:04 * hackagebot persistent-template 0.6.3.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-0.6.3.1 (MichaelSnoyman)
03:18:06 * hackagebot pool 0.1.2 - Thread-safe resource pools.  http://hackage.haskell.org/package/pool-0.1.2 (MichaelSnoyman)
03:23:08 * hackagebot shakespeare-css 0.10.4 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-0.10.4 (MichaelSnoyman)
03:23:10 * hackagebot warp 0.4.6.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-0.4.6.2 (MichaelSnoyman)
03:23:12 * hackagebot yesod 0.9.3.4 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.9.3.4 (MichaelSnoyman)
03:23:14 * hackagebot yesod-core 0.9.3.5 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.9.3.5 (MichaelSnoyman)
03:27:59 * hackagebot uri-enumerator-file 0.1.1 - uri-enumerator backend for the file scheme  http://hackage.haskell.org/package/uri-enumerator-file-0.1.1 (MichaelSnoyman)
03:33:51 <zenzike> cacs: on the surface, emacs is just a complicated text editor, like notepad++
03:49:53 <lars9> anyone uses ghc-mode?
03:54:01 <rostayob> lars9: you mean ghc-mod? anyway, I do
03:55:16 <lars9> rostayob: is it good? syntax highlighting and indentation
03:56:03 <rostayob> lars9: it doesn't really change how syntax highlighting and indentation works, afaik. i use it since it enables flymake for haskell (it compiles your file on the fly and highlights errors)
03:56:31 <rostayob> also, it does completion better
03:56:43 <rostayob> but the main advantage, at least for me, is flymake
03:56:52 <mm_freak> copumpkin: how do you deal with side channels with Applicative+Category?
03:57:08 <lars9> rostayob: i really just want better indentation, haskell-mode's is annoying
03:57:29 <quicksilver> you're probably using the wrong haskell-mode, lars9
03:57:32 <quicksilver> or the wrong indentation mode.
03:57:48 <quicksilver> haskell-indentation-mode is pretty smart
03:58:46 <lars9> (load "~/.emacs.d/haskell-mode-2.8.0/haskell-site-file")
03:58:47 <lars9> (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
03:58:48 <lars9> (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
03:58:53 <rostayob> lars9: have you enabled indentation?
03:58:55 <rostayob> ah
03:58:57 <lars9> quicksilver: is this wrong?
03:58:58 <rostayob> you have
03:59:13 <quicksilver> lars9: looks right to me. How do you find it annoying?
03:59:42 <lars9> quicksilver: i need to tab many times to get correct indentation sometimes
04:00:08 <rostayob> lars9: that's because haskell is whitespace based, it can't just know what you want
04:00:11 <lars9> in tuareg mode, i can use M-q to indent a whole ocaml block
04:00:19 <quicksilver> yes, but that's not possible in haskell, lars9
04:00:21 <rostayob> lars9: that's impossible in haskell
04:00:31 <quicksilver> because there are multiple different indentations for each line
04:00:35 <quicksilver> which actually mean different things.
04:00:44 <quicksilver> in ocaml it's just "make this look nice"
04:00:52 <rostayob> since ocaml syntax is not whitespace dependent (actually I'm not sure, SML syntax is)
04:00:52 <quicksilver> in haskell it's "choose what this means"
04:01:33 <quicksilver> haskell-indentation-mode is the most intelligent haskell indenter I've used, at least - I'm not saying it's not possible to do better. It's always possible to do better :)
04:02:02 <lars9> and it always shows this err when loading a .hs file: #[nil "\300C\207" [t] 2]
04:02:42 <rostayob> lars9: is this ghc-mode? have you added ghc-init to your haskell-mode hook?
04:03:07 <lars9> rostayob: oh not ghc-init, let me try
04:03:09 <hpaste> rostayob pasted “ghc-mod init” at http://hpaste.org/54877
04:03:16 <rostayob> ^^^ this is what I have
04:03:39 <rostayob> and I put the .el files in ~/.emacs.d/site-lisp/ghc-mod
04:03:48 <rostayob> anyway i have to go, good luck ehe
04:04:39 <lars9> is that ghc-init part of ghc-mod or hakell-mode?
04:04:48 <lars9> oh thanks bye=)
04:07:35 <hpaste> lars9 pasted “.emacs” at http://hpaste.org/54878
04:07:54 <lars9> what did I miss in this .emacs?
04:11:41 <lambdabot> Plugin `type' failed with: thread killed
04:12:20 <danr> @pl \for -> out for now
04:12:30 <Phyx-> looks like lambdabot is in a world of pain
04:12:35 <danr> :(
04:13:32 <Phyx-> is bot euthanization legal? we should think about letting lambdabot go peacefully..
04:14:34 <mike-burns> Oh man, after I went to bed my trylamda.com got scrutinized.
04:14:55 <mike-burns> I thought I had done substitution right!
04:15:07 <DevHC_> is there a built-in list chopping function?
04:15:38 <Phyx-> list chopping?
04:15:42 <DevHC_> > let { chop k [] = [] ; chop k xs = let (a,b) = splitAt k xs in a : chop k b } in chop 5 "trololololo"
04:16:23 <mauke> Data.List.Split
04:16:39 <DevHC_> Split sounds like a data constructor to me
04:17:10 <mauke> it isn't
04:17:15 <mike-burns> Sounds like a verb to me.
04:17:24 <DevHC_> mauke: what is it?
04:17:30 <mauke> a module
04:17:44 <DevHC_> does not exist here
04:18:19 <mike-burns> http://hackage.haskell.org/package/split
04:18:43 <DevHC_> honoze
05:08:11 * hackagebot syntactic 0.7 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-0.7 (EmilAxelsson)
05:58:14 * hackagebot yesod-auth 0.7.7 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.7.7 (MichaelSnoyman)
06:13:14 * hackagebot thumbnail 0.1 - generate thumbnail image  http://hackage.haskell.org/package/thumbnail-0.1 (KatsutoshiItoh)
06:17:21 <fryguybob> @botsnack
06:17:31 <fryguybob> :(
06:23:14 * hackagebot thumbnail 0.2 - generate thumbnail image  http://hackage.haskell.org/package/thumbnail-0.2 (KatsutoshiItoh)
06:42:34 <singpolyma> Is there a way to make a case ... of expression have two pattern matches go on to the same code?
06:43:43 <_oz> like in c style switch-case without breaks?
06:44:15 <singpolyma> _oz: yes
06:44:23 <_oz> singpolyma: then no.
06:44:39 <_oz> you can do bind it in let though?
06:45:11 <_oz> let comp = ...; case x of 1 -> comp; 2 -> sth_else; 3 -> comp; ...
06:45:23 <_oz> sorry, there must be an "in" there
06:45:34 <_oz> let comp = ... in case ...
06:47:14 <singpolyma> _oz: right, ok
06:48:56 <cheater> help
06:49:01 <cheater> erm, wrong window :)
06:49:08 <Botje> help is --> that way
06:49:19 <cheater> @faq can Haskell help me?
06:49:32 <cheater> omg.. there's no help for me
06:49:37 * cheater goes to commit suicide.
06:49:52 <cheater> *no helping me
06:49:54 <cheater> heheh
06:54:57 * Phyx- hands cheater some rope
07:01:02 <kstt> jaspervdj: in blaze html with overloaded strings, a string litteral explicitly typed to Html does not trigger the unusedbind warning, while a non-annotated string litteral does trigger the warning.
07:01:39 <kstt> I'm wondering what type is infered without annotation ...
07:02:34 <kstt> The warning says GHC.Prim.Any
07:02:38 <cheater> Phyx-: at least you want to help me :)
07:03:12 <_oz> kstt: it should be IsString a => a
07:08:00 <donri> preflex: seen chrisdone
07:08:00 <preflex>  chrisdone was last seen on #haskell 5 days, 16 hours, 3 minutes and 25 seconds ago, saying: likeso http://hpaste.org/irc/haskell/2011-11-29/15-07-13/54684
07:08:14 * hackagebot thumbnail 0.3 - generate thumbnail image  http://hackage.haskell.org/package/thumbnail-0.3 (KatsutoshiItoh)
07:10:31 <kstt> _oz: ok thanks
07:13:16 * hackagebot paragon 0.1.3 - Paragon  http://hackage.haskell.org/package/paragon-0.1.3 (NiklasBroberg)
07:18:14 * hackagebot uuagc-cabal 1.0.0.10 - Cabal plugin for the Universiteit Utrecht Attribute Grammar System  http://hackage.haskell.org/package/uuagc-cabal-1.0.0.10 (ArieMiddelkoop)
07:18:16 * hackagebot uuagc-bootstrap 0.9.39.3.0 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-bootstrap-0.9.39.3.0 (ArieMiddelkoop)
07:43:14 * hackagebot cabal2nix 1.20 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.20 (PeterSimons)
07:51:46 <ricree> I'm having a slight bit of trouble wrapping my head around iteratees.  Can anyone point me in the right direction?
07:53:00 <ricree> sorry.  meant to say Enumeratees
07:53:57 <ricree> like, if I want something that consumes strings, then based on the string produces one or more strings for some iteratee to use, what's the best way to go about that
07:55:19 <jaspervdj> kstt: Hmm, let me see
07:56:14 <jaspervdj> kstt: It might be fixable
07:59:44 <kstt> jaspervdj: that would be convenient indeed, for those lazy folks who want to be compliant to -Wall
08:00:06 <kstt> without type annotation nor explicit binding discard :)
08:00:44 <jaspervdj> kstt: Hmm, I don't think it's fixable
08:00:56 <jaspervdj> (looking at the code again now)
08:00:59 <kstt> ok, no worry.
08:01:14 <jaspervdj> a line in a monad do-notation resolves to :: HtmlM a
08:01:33 <kstt> ah, sure ...
08:01:41 <jaspervdj> so the IsString instance needs `HtmlM a`, not `HtmlM ()`
08:01:46 <kstt> I should have read the Html type definition
08:01:53 <jaspervdj> no problem :-)
08:03:01 <kstt> anyway, it happened to my collegue, who does not have much haskell-fu yet, in a situation that I'd call poor practice anyway, so that's not a real world problem.
08:03:36 <kstt> namely, he was manually interspersing litterals with Blaze.Html.br
08:04:02 <jaspervdj> I usually have all my blaze code in separate modules
08:04:23 <jaspervdj> and I use {-# OPTIONS_GHC -fno-warn-unused-do-bind #-} there
08:05:01 <kstt> while he should obviously have used Data.List.intersperce, together with your kindly defined instance for [Html]
08:05:12 <kstt> uh, caugh caugh ...
08:05:22 <kstt> I try not to show him this kind of trick ...
08:05:29 <kstt> not yet at least :)
08:05:40 <jaspervdj> :-)
08:06:31 <kstt> or every files headers will soon list all -f no-... available in man ghc :)
08:07:23 <kstt> BTW jasper, thank you *very much* for this package.
08:08:14 <kstt> We are using it in production here for the first time, and everything is beautiful in a blue sky. Much better and much more powerful than any alternative I've tried so far.
08:09:58 <kstt> Do you think we could have a do-notation for monoid for christmas ? It would make the thing even more pleasant to use.
08:10:10 * quicksilver sighs
08:10:55 * quicksilver suspects he will never understand why people are so keen on a special notation for monoids
08:11:41 <kstt> I guess for the same reason it can be appreciated for monads : conciseness
08:12:35 <quicksilver> I don't find either foo <> bar <> baz or mconcat [foo, bar, baz] to be verbose
08:12:38 <monochrom> look at traditional monoids for inspirations, for example (numbers, 0, +), (numbers, 1, *), (strings, "", ++)
08:12:47 <quicksilver> (I don't much like the word 'mconcat' but that's not a big deal)
08:12:51 <kstt> after all, there is a "special way" to combine two elements of the same monoid, right ? That's almost the definition of a monoid.
08:13:15 * hackagebot thumbnail 0.3.0.1 - generate thumbnail image  http://hackage.haskell.org/package/thumbnail-0.3.0.1 (KatsutoshiItoh)
08:13:15 <monochrom> for example "0+x+y" is pretty concise. can you do better?
08:13:27 <quicksilver> monochrom: sure. And I find sum [1,2,3,4,5] looks fine, as well as "1+2+3+4+5"
08:13:43 <quicksilver> monochrom: I have no desperate inclination for special whitespace syntax for sums
08:14:14 <mike-burns> What's the proposed new monoid syntax?
08:14:43 <Botje> is it just + ?
08:14:47 <jaspervdj> kstt: we actually made a request in the GHC trac
08:14:51 <quicksilver> well blaze (and some other libraries) have abused do notation
08:14:56 <quicksilver> so you can write:
08:14:58 <quicksilver> do foo
08:15:00 <quicksilver>    bar
08:15:07 <quicksilver> instead of mconcant [foo, bar]
08:15:16 <quicksilver> but I don't see the attraction (apologies for typoes)
08:15:17 <kstt> quicksilver: I would not bother either if I were not using blaze-html I guess ... But blaze makes beautiful usage of its Html monoid as an EDSL.
08:15:40 <mux> hmm, s/beautiful/efficient/ maybe
08:15:46 <jaspervdj> quicksilver: I think I started abusing the do notation, I'm sorry man
08:16:02 <jaspervdj> but it's concise and efficient
08:16:03 <quicksilver> jaspervdj: I doubt it. At least the Put () "Monad" was before you.
08:16:05 <kstt> quicksilver: usualy, my html pages are a bit longer than 'foo' + 'bar' ...
08:16:10 <quicksilver> and I think there are others.
08:16:29 <quicksilver> kstt: of course. But mconcat scales just as well doesn't it?
08:16:42 <quicksilver> the only different is explicit delimiters and commas
08:16:51 <jaspervdj> quicksilver: the put monad is different in that it actually respects the monoid laws
08:17:17 <kstt> quicksilver: it scales with a linar noise of (obvious) operation on obvious lists ...
08:17:17 <jaspervdj> that's whay I meant with "abusing" ;-)
08:17:42 <quicksilver> kstt: don't understand that comment?
08:18:01 <Philippa> quicksilver: I appreciate some of the "just build a monoidal value" monads, they tend to save me some piping effort still - especially if I was going to stack a transformer on top
08:18:15 <Philippa> but yeah, it helps if they don't break the laws :-)
08:18:31 <kstt> quicksilver: yeah, it does not read well ...
08:19:05 <quicksilver> Philippa: the ability to stack a transformer on top is a better justification than the syntax.
08:19:08 <ricree> I'm having a bit of trouble wrapping my head around Enumeratees.  Are there any decent guides to them?
08:19:22 <quicksilver> Philippa: however there could be a generic wrapper for that, no?
08:19:39 <kstt> quicksilver: Philippa argument is an other good reason indeed.
08:20:21 <quicksilver> WrapMonoid :: ((* -> *) -> (* -> *)) -> * -> * -- take a monad transformer and apply it to a Monoid lifted to a "fake" ()-monad
08:21:19 <kstt> jaspervdj: I think I've seen an example of blaze usage with monoid syntax, but I can't find it online, any idea ?
08:21:30 <Philippa> quicksilver: definitely, though you'd see a forest of typeclasses spring up around it and sometimes it makes sense to build more around it as well (for example, "debug" capability)
08:22:08 <KirinDave> what is a "fake ()-monad?"
08:23:13 <kstt> quicksilver: but with EDSL, syntax really matters, because noise can quickly make the thing impractical to use
08:23:40 <quicksilver> KirinDave: a monoid promoted to a monad where the paramter is always () and >> is mappend
08:23:45 <KirinDave> Ah
08:24:08 <kstt> blaze-html, by abusing the monad laws to earn the do-notation, has made the Html EDSL a real pleasure to use and to combine with the full power of haskell. And, really, the result is amazing.
08:24:11 <jaspervdj> kstt: I'm not sure
08:24:28 <quicksilver> kstt: I can't imagine a few commands making the thing impractical to use.
08:24:40 <KirinDave> quicksilver: I am surprised that the monad laws would hold with such a contract, but okay.
08:24:55 <roconnor> Writer w () ~ w
08:24:56 <quicksilver> kstt: that's like saying C++/Java/C#/Perl are impractical to use because they require explict ;
08:25:36 <quicksilver> kstt: note that all we're doing is rewriting "mc [a,b]" to "do {a;b}"
08:25:47 <kstt> quicksilver: they are less pratical in my opinion ! Just as the ($) make nested expression easier to read and write. Are you againt ($) as well ? :)
08:25:49 <quicksilver> ...and then using the fact that layout lets us hide the ; and {}.
08:26:08 <quicksilver> I'm not against $, no.
08:26:15 <ski> kstt : i'm against over-use of `$' :)
08:26:18 <mreh> No instances for (MonadReader ServEnv m, MonadWriter (ServMessages Html) m)
08:26:25 <quicksilver> But I don't have any difficulty using a nested expression with a few levels of [,,]
08:26:29 <mreh> i've never seen that before
08:26:34 <quicksilver> given an editor with reasonable support.
08:26:51 <KirinDave> The problem with a lot of the EDSL code is how difficult it is to read. Without a clear usage guide including example code it's often soup. :\
08:26:56 <quicksilver> for what it's worth, I'm not *against* a layout notation for monoids.
08:27:05 <quicksilver> I think it's an interesting idea to use layout for lots of things.
08:27:08 <quicksilver> without being against it...
08:27:14 <quicksilver> I don't understand why people think it's important
08:27:15 <kstt> quicksilver: hence the smiley above :)
08:27:15 <monochrom> the most concise "noiseless" notation is juxtaposition. this is why both (numbers, 1, mutiply) and (regex, empty, concat) adopt it. so you can write "xyz" and make people guess "is that xy*z, where xy is an identifier? or x*yz, where yz is an identifier? or x*y*z?" meanwhile you can claim "no unnecessary symbol!"
08:27:31 <quicksilver> it strikes me as an improvement of the most trivial order.
08:27:48 <kstt> I agree with that
08:27:56 <kstt> but still, an improvement
08:29:00 <mreh> I don't understand, mtl has this instance: Monad m => MonadReader r (ReaderT r m)
08:29:09 <mreh> and a similar one for WriterT
08:29:59 <monochrom> so that for example "tell" works immediately for WriterT Blah (IO a)
08:30:13 <mreh> given that Blah is a monoid
08:30:21 <monochrom> perhaps s/immediately/out of the box/
08:31:10 <mreh> are you talking to me monochrom? i was saying that in reference to what I said earlier
08:31:30 <mreh> No instances for (MonadReader ServEnv m, MonadWriter (ServMessages Html) m)
08:31:58 <mreh> ServMessages a is a synonym for [a]
08:31:59 <mreh> for now
08:32:14 <rwbarton> sounds like the type variable m is underspecified
08:32:25 <mreh> fark, it needs to be a monad
08:33:06 <mreh> where's the -suggest-instances-that-you-might-be-thinking-of compiler flag?
08:33:42 <mreh> where's the -suggest-instances-that-you-might-be-thinking-of compiler flag?
08:33:46 <mreh> oops
08:35:23 <mreh> i'm using undecidable instances to create a context synonym... i hope that isn't causing this
08:35:42 <mreh> (<_<) (>_>)
08:37:28 <quicksilver> dont do that. HTH. HAND.
08:37:51 <quicksilver> actually undecidable is normally fine.
08:37:56 <quicksilver> on reflection
08:38:15 <lambdabot> Plugin `pl' failed with: thread killed
08:38:55 <mreh> what's the danger? ghc goes into infinite spiral trying to reify some type
08:39:14 <rwbarton> it seems like it should work, paste your class + instance + code + error?
08:39:57 <mreh> my life's work?! if you must
08:40:21 <hpaste> mreh pasted “stupid web server” at http://hpaste.org/54883
08:40:29 <mreh> rwbarton: ^
08:41:33 <rwbarton> where is the error reported?
08:41:46 <mreh> rwbarton: i just pasted that
08:41:54 <hpaste> mreh annotated “stupid web server” with “stupid web server (annotation)” at http://hpaste.org/54883#a54884
08:41:55 <mreh> now
08:41:58 <rwbarton> ah
08:42:09 <mreh> right at the bottom
08:42:18 <mreh> i need to get hte hang of this new hpate
08:42:24 <mreh> not to mention hpaste
08:42:34 <mreh> delicious as the former is
08:42:35 <rwbarton> Mmm, hpate.
08:43:02 <rwbarton> Anyways, it has no way of knowing what 'm' should be when you pass mzero as the second argument to recycleServer.
08:43:15 * hackagebot uuagc 0.9.39.3 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.39.3 (ArieMiddelkoop)
08:43:17 <mreh> i didn't know hpaste was anti capitalist
08:43:55 <mreh> rwbarton: i was hoping it would figure that out
08:44:17 <mreh> :t 1
08:44:22 <rwbarton> well all it knows is: mzero :: ServerPartT m Page with the context Recycle m
08:44:22 <mreh> > show 1
08:44:55 <rwbarton> I'm pretty suspicious of the type signature of recycleServer/unWeb anyways though...
08:46:48 <mreh> i'll give it a concrete type and see what it wants
08:51:26 <alistra> hi guyz
08:51:49 <bwright_> If I have two patterns say f _ = ... and f (x1:y1:xs) = ... will it match the latter if possible first? So a list with 3 elements will choose (x1:y1:xs) over the wildcard? If not how do I enforce that.
08:52:18 <alistra> is somebody using drift here? i think it's a bit outdated, i heard that derive does the same thing, does it support up-to-date arbitrary definition?
08:52:23 <Botje> haskell will match from top to bottom
08:52:34 <bwright_> Botje: ty.
08:55:29 <_Mikey> Hey alistra
08:58:08 <alistra> yo
09:04:30 <binsh> To show the type of a fungtion i write :t in ghci?
09:05:09 <byorgey> binsh: yes, :t can be used to show the type of any expression
09:05:31 <binsh> kk, thx ;)
09:12:21 <age> Hello.
09:12:41 <mbetter> ahoy
09:17:24 <silver> vrook, check it out http://okmij.org/ftp/Computation/Generative.html#meta-haskell
09:32:38 <vrook> I have a list stuck inside a monad, and I want to cons to the list. Something like monadCons :: (Monad m) => a -> m [a] -> m [a].
09:32:58 <vrook> or is this better called "liftCons"
09:32:59 <ski> @type \a -> liftM (a :)
09:34:28 <ehuber> vrook: why not use fmap?
09:34:30 <ski> vrook : you can either use that, or use `list <- listAction' to "extract" the list, then use it
09:34:56 <ski> yeah, `fmap' is the same as `liftM', here
09:35:26 <ehuber> oh, sorry :)
09:35:50 <Proge> tell me haskers, are there many haskell frameworks in progress or is the idea that you create your own?
09:35:59 <Botje> frameworks for what?
09:36:03 <mbetter> framework for what?
09:36:03 <ehuber> @type fmap
09:36:08 <mbetter> beat me
09:36:09 <ehuber> er
09:36:28 <ski>   fmap :: Functor f => (a -> b) -> (f a -> f b)
09:36:39 <ski>   liftM :: Monad m => (a -> b) -> (m a -> m b)
09:36:48 <Philippa> Proge: most of the time the idea is that frameworks are too prescriptive and parametric polymorphism helps avoid the need. There're a few tasks that need something close, granted
09:36:55 <Philippa> well, not need, benefit from
09:37:14 * ski wonders what parametric polymorphism has to do with it
09:38:12 <Proge> so it would be best to start with the building blocks and create your own?
09:38:19 <Philippa> ski: there's an antipattern in statically-typed languages without it where every framework "needs" to provide its own string type, etc etc. Makes things near-impossible to stick together
09:38:22 <mbetter> framework for what?
09:38:35 <Proge> THE framework
09:38:40 <Proge> tehee
09:38:40 <Philippa> with it, you can build things that don't really care what the string-like things are, cheaply
09:38:44 <ehuber> lolwut
09:38:48 <vrook> I don't see how using fmap/liftM can produce the signature a -> m [a] -> m [a]. Hint?
09:38:58 <ehuber> vrook: a can be [b]
09:39:04 <ehuber> you see what im saying?
09:39:12 <Philippa> [] is also a functor
09:39:14 <ehuber> a is just a name for a type, the type can itself be something like [b]
09:39:18 <ski> Philippa : hm, i suppose one could possibly do that with module functors, too
09:39:21 <Philippa> so perhaps you've accidentally overspecialised?
09:39:34 <Philippa> ski: yeah. Or templates in C++, but people don't because it's expensive and 'risky'
09:40:43 <vrook> I understand that b can be substituted for [a]. liftM takes non-monadic types and maps them to monadic ones. I need to combine a non-monadic type with a monadic one.
09:40:49 <vrook> lemme paste
09:41:30 <vrook> https://gist.github.com/1434597
09:42:02 <vrook> I'm converting the generator-passing shuffle to the monad version
09:42:32 <c_wraith> vrook: that's going to be *really* slow, just due to swap
09:42:46 <vrook> c_wraith: yes, "intentionall inefficient" at top
09:42:50 <vrook> just for pedagogy
09:43:17 <c_wraith> also, it's exceptionally silly in a way laziness *mostly* saves you from. :P
09:43:31 <vrook> it's silly, yes. That's the point.
09:44:34 <c_wraith> ah.
09:44:46 <c_wraith> ok, there's nothing related to Rand whatsoever in what you need.
09:45:14 <vrook> well I started out with monadCons :: (Monad m) => a -> m [a] -> m [a] but I figured it couldn't hurt to be more specific.
09:45:24 <c_wraith> it can, actually. :P
09:45:34 <c_wraith> making it more specific means that the function can do more things
09:46:45 <c_wraith> :t \x xs -> pure (x:) <*> xs
09:46:56 <c_wraith> ....  lambdabot must be dead
09:47:21 <c_wraith> oh, right
09:47:25 * c_wraith reduces
09:47:38 <c_wraith> \x xs -> (x:) <$> xs
09:48:06 <c_wraith> I don't see why you want a separate combinator for it, though.
09:48:15 <ski>   fmap . (:)
09:48:31 * ski isn't sure vrook wanted one
09:49:18 <c_wraith> The traditional way to do something like that, since you are already in a do block, is just changing line 19 to two lines:  rest <- shuffle $ tail result ; return $ head result : rest
09:50:00 <vrook> hm yes, I'm writing it as if I'm outside a do-block
09:50:01 <ski> vrook : anyway, `monadCons a mas = liftM (a :) mas'
09:50:34 <jtanguy> Hello
09:50:37 <ski> hello
09:51:24 <jtanguy> may i ask a question?
09:51:37 <Philippa> you just did. You can try another, too
09:51:42 <c_wraith> you just did.  Better to ask your real question than that one.
09:51:42 <jtanguy> ^^
09:51:56 <jtanguy> is there an equivalent of map over tuples ?
09:52:15 <ski> probably not what you're after, no
09:52:17 <c_wraith> I'm not sure what you're asking..  What would its type be?
09:52:44 <jtanguy> something like (a -> b) -> (a,a) -> (b,b)
09:53:01 <c_wraith> join (***) would work.  but don't use that. :)
09:53:34 <c_wraith> nothing's built-in with that type
09:53:44 <ehuber> jtanguy: why not use a list?
09:54:06 <ski> jtanguy : what are you really trying to do ?
09:54:12 <jtanguy> well the main problem is making and enum an instance of Random
09:54:24 <jtanguy> *an enum
09:55:02 <ski> how is the type defined ?
09:56:40 <jtanguy> it's a data MyType = A | B | C | D deriving (Enum, Bounded)
09:59:30 <dupaaaaa> siema kurwa
10:00:04 <ski> jtanguy : i'm not sure what mapping tuples have to do with that ..
10:00:39 <jtanguy> in order to make it an instance of Random, i have to define randomR and random
10:00:57 <jtanguy> random is just randomR (minBound, maxBound)
10:01:02 <ski> jtanguy : .. but i'd define `random', probably by calling `random :: RandomGen g => g -> (Int,g)', and convert the `Int' to `MyType'
10:01:24 <ski> jtanguy : no, `random' is not `(minBound, maxBound)'
10:01:45 <ski>   random :: (Random a,RandomGen g) => g -> (a, g)
10:02:00 <jtanguy> oh wait, i just need to define random, not randomR
10:02:17 <ski> hum, actually, i missed the `randomR' in what you said
10:02:45 <ski> but you can't define `random' in terms of `randomR', unless you redefine `randomR' to not call `random' directly
10:02:56 <ski> jtanguy : *nod
10:02:56 <ski> *
10:03:19 <_Mikey> siema!
10:03:29 <hpaste> keep_learning pasted “Compiler error” at http://hpaste.org/54885
10:03:30 <alistra> omg
10:03:45 <keep_learning> hello all
10:03:50 <_Mikey> hi
10:04:44 <keep_learning> I have declared a data type but getting compiler error. http://hpaste.org/54885
10:04:45 <vrook> ski: monadCons x = liftM (x :) is nice step in my monad education. thanks.
10:05:05 <keep_learning> could some one please tell me why i am getting compiler error.
10:05:16 <DevHC_> what's a Data.Map function closest to a function (updateByIndexWithDefault :: Ord k => a -> k -> (a -> a) -> Map k a -> Map k a) which takes: a default value, a key, and a value-to-value function, and works as the type suggests?
10:06:51 <elliott> lambdabot is dead again?
10:06:53 <plat0> I have a types question.  Is there some way to have a graph type, and a vertex type, and define a function f taking a graph and two vertices (say) which tells me whether they're connected (say), such that they compiler can tell if I've given it a vertex that doesn't actually belong to the graph
10:07:52 <keep_learning> Any one please.
10:07:52 <Philippa> plat0: "branding". The same kind of trick that runST uses
10:08:04 <vrook> I am a bit surprised that m [a] can be inferred as Rand g [a]. How does the inference know I meant the second one and not the first?
10:08:17 <dupaaaaa> lol
10:08:23 <plat0> Or imagine a server which hosts board games.  Can the compiler check whether my code is trying to incorrectly combine a Player Value with a Board value?
10:08:59 <plat0> Philippa: I tried runCont actually.  I guess the runST approach will be similar.  I thought I would need existential types for this.
10:09:08 <elliott> vrook: because your code requires m ~ Rand g for whatever reason
10:09:38 <_Mikey> sorry keep_learning, I don't know much about `seq` which seems to be the problem
10:10:23 <Eduard_Munteanu> plat0: in some cases that's possible, I'm unsure what you mean for this particular one. For the general case you'd need dependent types machinery.
10:10:33 <ski> elliott : it just so happens that lambdabot is only _mostly_ dead
10:10:41 <c_wraith> keep_learning: I think your problem is that you have deepseq 1.2 installed.
10:10:42 <elliott> ski: oh good
10:11:03 <keep_learning> c_wraith, yes
10:11:04 <Eduard_Munteanu> plat0: the general case being arbitrary constraints on those values
10:11:11 <plat0> OK, so let's say I have a function plus :: Tag a (Integer, Integer) -> Tag a Integer
10:11:16 <c_wraith> keep_learning: you need deepseq 1.1.* on versions of ghc below either 7.2 or 7.4
10:11:29 <c_wraith> I think it's below 7.4
10:11:30 <plat0> Can I define some version of integers that forces them to be tied together
10:11:35 <plat0> if I want to pass them to plus?
10:11:56 <Eduard_Munteanu> plat0: tied how?
10:12:02 <keep_learning> c_wraith, mine  is ghc-7.2.1
10:12:10 <ski> keep_learning : maybe it's missing an `instance NFData a => NFData (IntMap a)' ?
10:12:23 <c_wraith> keep_learning: in any case, the problem is you have the wrong version of deepseq
10:12:47 <plat0> Eduard_Munteanu: Well perhaps the board game example is clearest.  Perhaps Tag a (Player, Board) -> Tag a Result that forces Player and Board to actually be from "the same game"
10:12:53 <aik> hi
10:13:14 <aik> noob question: what is wrong with the following lines?
10:13:22 <aik> type Edge a = (a,Integer,a)
10:13:26 <aik> instance Ord a => Ord (Edge a) where (v1,w1,v2) <= (v3,w2,v4) = w1 <= w2
10:13:33 <ski> plat0 : `runCont' isn't really similar to `runST'
10:13:42 <c_wraith> I wish things had been set up such that cabal wouldn't install the wrong version of deepseq like that
10:13:43 <aik> I get illegal instance declaration
10:13:50 <Eduard_Munteanu> plat0: in that case I guess you want to tag Player and Board separately, as in give them a phantom type parameter
10:13:55 <ski> aik : `Edge' is a type synonym
10:13:58 <sipa> aik: you need flexibleinstances for that
10:14:03 <plat0> Eduard_Munteanu: exactly, but I don't know how to do this
10:14:07 <keep_learning> c_wraith, so i should unregister the deepseq-1.2.0.1
10:14:15 <ski> aik : you probably want a `newtype' (or a `data')
10:14:16 <c_wraith> keep_learning: yes, and everything built against it
10:14:20 <Eduard_Munteanu> Isn't that TypeSynonymInstances?
10:14:25 <plat0> Eduard_Munteanu: How can I create a player that has a phantom parameter?
10:14:26 <aik> what can I do, if I can't chance any interpreter/compiler options?
10:14:27 <keep_learning> install deepseq-1.1.
10:14:52 <c_wraith> keep_learning: sadly, you'll also need to tell cabal to install everything with a constraint deepseq<1.2
10:14:57 <sipa> aik: use data instead of type - that's what you probably want
10:15:06 <sipa> aik: data Edge a = Edge a Int a
10:15:09 <c_wraith> keep_learning: you can add that to your .cabal/config file, though
10:15:19 <plat0> Eduard_Munteanu: If I try to create a "Player a Whatever" I actually have to provide the a, so I don't know what to do!
10:15:22 <c_wraith> keep_learning: so long as you remove it when you go to gch 7.4
10:15:24 <Eduard_Munteanu> plat0: say you have the datatypes 'Player a' and 'Board a'. Hide their constructors and use a function to create a game.
10:15:26 <c_wraith> *ghc
10:15:29 <aik> sipa, ski: ok, thanks
10:15:43 <ski> plat0 : most of your operations would be polymorphic in the `a', no ?
10:15:58 <plat0> ski: yes the operations are fine, I just don't know how to create the values
10:16:10 <ski> the values are created by the operations
10:16:11 <plat0> Eduard_Munteanu: how do I create a value of type "Player a"?
10:16:27 <plat0> If I use a specific a then that doesn't solve the problem
10:16:30 <ski> plat0 : depends on how `Player' is defined (obviously)
10:16:39 <kissyboy> data Player a = Player String Int
10:16:41 <plat0> and if it's polymorphic in a then I can mix games incorrectly
10:16:43 <Eduard_Munteanu> data Player a = Player String   might do
10:16:44 <kissyboy> Player "foo" 3
10:16:50 <keep_learning> c_wraith, thank you. I am again stuck with library .
10:17:02 <plat0> Oh maybe I'm just being silly
10:17:05 <plat0> Let me check, ...
10:17:33 <Ferdirand> kissyboy: he wants compile-time checking if I understand correctly
10:17:35 <ski> plat0 : hm, i suppose there's a choice between whether to create a graph in one bulk operation, or incrementally
10:17:38 <Eduard_Munteanu> makeGame :: ... -> (Board a, [Player a])
10:17:51 <kissyboy> it's polymorphic, but so is the s in ST, but it's still constrained
10:17:57 <plat0> Eduard_Munteanu: if I do that then a is polymorphic right?
10:18:11 <plat0> So Boards and Players from different games could be mixed incorrectl.
10:18:32 <Eduard_Munteanu> Since you can only use makeGame to create boards and players, their types will be tied together.
10:18:33 <plat0> I need a to be concrete, but unknown
10:18:41 <c_wraith> ski: if someone is missing an NFData instance for something from containers, it's usually a deepseq problem.  The instances got moved between those packages recently, and containers is pinned to ghc, but deepseq isn't (yet.  It will be soon)
10:19:05 <plat0> I know how to do the tying.  I don't know how to do the creating.
10:19:16 <ski> plat0 : hm, i suppose you either want an existential, or to have it give `Foo a (Board a, [Player a])', like with `ST'
10:19:27 <plat0> Yes I exactly want an existential
10:19:38 * ski isn't sure what plat0 means by "the creating"
10:19:39 <plat0> but the usual way of mimicing existentials doesn't seem to do the job.
10:19:53 <plat0> OK, I'll clarify.
10:20:01 <Eduard_Munteanu> plat0: you can make a 'Player a' like this: Player "plat0"
10:20:11 <Eduard_Munteanu> (using my example above)
10:20:47 <plat0> Suppose I have isHisTurn :: Player a -> Board a -> Bool
10:20:53 <plat0> (That's no problem)
10:21:11 <ski> plat0 : well, one way could be to write `makeGraphOps :: ... -> exists a. GraphOps a', where `GraphOps a' is a record type which contains all the operations needed for creating and querying `a'-graphs
10:21:21 <plat0> How can I defined Players and Boards, so that a Player from one game cannot be used with a Board from a different game?
10:21:46 <Eduard_Munteanu> plat0: you create the board and players together
10:21:48 <plat0> ski: OK sounds good, but does "exists" actually exist?
10:22:01 <ski> plat0 : no, you need to encode it manually, in a datatype
10:22:13 <plat0> ski: I've been trying and failing
10:22:35 <Eduard_Munteanu> plat0: say I use makeGame to create two games. Only the players and boards in the same game will have matching (unknown) types.
10:22:46 <plat0> Eduard_Munteanu: right this is exactly what I'm looking for
10:22:51 <plat0> But I can't work out how to do that
10:23:02 <ski> i.e. `makeGraphOps :: ... -> SomeGraphOps' where `data SomeGraphOps = forall a. WrapGraphOps (GraphOps)' (in practice you'd usually unfold, i think)
10:23:03 <plat0> How can I stop the players and boards being polymorphic?
10:23:09 <Eduard_Munteanu> I can't pass mixed stuff to isHisTurn because the parameters won't unify.
10:23:21 <Eduard_Munteanu> plat0: polymorphism isn't a problem
10:23:37 <lunaris> Hi all, does anyone know how to get ":k (:)" to work in HEAD with -XPolyKinds?
10:23:40 <plat0> If I have createStuff :: (Game a, Player a), that's polymorphic in a  right?
10:23:41 <kissyboy> just because a type is polymorphic doesn't mean it can be any type
10:23:47 <lunaris> I get a parse error.
10:23:52 <lunaris> (:k [] works as expected)
10:23:53 <plat0> kissyboy: ah OK.  Can you explain?
10:23:55 <Eduard_Munteanu> plat0: yep... but it's the same 'a' for both the Game and Player.
10:24:00 <lunaris> Is it simply not implemented yet?
10:24:13 <plat0> Eduard_Munteanu: sure, but its /also/ the same a for /other/ Graphs and Players, isn't it?
10:24:13 <Philippa> plat0: more fully, forall a. (Game a, Player a)
10:24:50 <roconnor> anyone know much about *-autonomous categories?
10:24:53 <Philippa> sure. So what you need is the same trick runST uses - use rank 2 polymorphism to require that you're handed a /polymorphic/ Graph or Player. So one that's already got a type isn't legit
10:24:55 <Eduard_Munteanu> plat0: nope...
10:25:03 <Philippa> Eduard_Munteanu: it can be, though
10:25:04 <plat0> OK that would be great
10:25:09 <plat0> I would like it /not/ to be
10:25:11 <Eduard_Munteanu> roconnor: aren't you in ##categorytheory already? :)
10:25:12 <plat0> How can I do that
10:25:18 <Philippa> Eduard_Munteanu: the rank-2 part is how you stop them unifying
10:25:19 <Eduard_Munteanu> (You should :D)
10:25:28 <kissyboy> hmmm ok i tried to make you an example but it doesn't work like intended haha
10:25:33 <ski> plat0 : see "Re: Is overloading a good thing?" by Adrian Hey in 2002-07-17 at <http://groups.google.com/group/comp.lang.functional/msg/22ea87a1cb8abfb8> for how to use existentials in the way i meant
10:25:34 <roconnor> Eduard_Munteanu: ##categorytheory has jerks in it on occasion.
10:25:34 <kissyboy> maybe eduard can take a look at it, sec
10:25:34 <Eduard_Munteanu> Philippa: that's how you stop them from escaping, rather :/
10:25:43 <Philippa> Eduard_Munteanu: same difference
10:26:06 <Philippa> roconnor: only on occasion?!
10:26:08 <Eduard_Munteanu> Philippa: I was proposing hiding the constructors and using a function to create the game and all players.
10:26:11 <plat0> thanks ski
10:26:12 <elliott> plat0: what you want is something like
10:26:16 <Eduard_Munteanu> Heh.
10:26:22 <elliott> plat0: withGame :: ... -> (forall a. Game a -> [Player a] -> r) -> r
10:26:23 <kissyboy> Eduard_Munteanu: did you mean like this? http://hpaste.org/54886
10:26:30 <roconnor> Philippa: well, my sampling is low, so that is all I can guarentee
10:26:32 <kissyboy> oh yeah i forgot the forall
10:26:33 <elliott> that ensures that you can't unify any two "different" Games and Players
10:26:50 <elliott> plat0: of course this is the same as newGame :: ... -> GameExistential, if you go down that route
10:26:55 <plat0> elliott: Right so basically a Cont.  I tried this too ...
10:26:57 <elliott> plat0: my type lets you see the relation to ST more clearly
10:27:00 <Philippa> roconnor: I idle in it, that might change things ;-)
10:27:01 <elliott> no, so basically an ST
10:27:07 <elliott> plat0: the important thing is that the forall is _inside_ the parens
10:27:27 <ski> plat0 : what elliott suggests is basically a way to effect `withGame :: ... -> exists a. (Game a,[Player a])'
10:27:28 <plat0> Hmm right, I think I'm beginning to get it ...
10:27:29 <Eduard_Munteanu> kissyboy: yeah, one way to do it... though you probably want to create multiple players along with a game
10:27:40 <kissyboy> eduard: yeah but that adoesn't work :(
10:27:41 <elliott> plat0: you have to pass withGame a function that accepts a (Game a) and [Player a] for /any/ a
10:27:53 <Philippa> Eduard_Munteanu: PlayerCreationCapability a
10:27:55 <elliott> plat0: which eliminates, e.g. forcing a to be equal to some b given another (Game b)
10:27:56 <kissyboy> with that example if you do playGame (Player "foo") (Game "foo") it typechecks
10:28:08 <kissyboy> even though we don't want it to
10:28:09 <elliott> because that restricts what "a"s you can take, and so the types don't work out
10:28:16 <elliott> kissyboy: hide the constructor
10:28:23 <elliott> you have to do that anyway
10:28:26 <kissyboy> we only want it to typecheck if the player and the game were created with makeGame
10:28:29 <kissyboy> ah
10:29:01 <Eduard_Munteanu> Yeah, the only way it breaks is if anybody's able to create those values in any way.
10:29:18 <kissyboy> ah so you don't need any ST-like tricks
10:29:22 <kissyboy> just good old constructor hiding
10:29:26 <elliott> yes you do
10:29:35 <elliott> newGame :: ... -> (Game a, [Player a])
10:29:49 <elliott> let (g,_) = newGame ...; (_, p:_) = newGame ... in playMove g p
10:29:52 <elliott> mwahaha!
10:29:52 <plat0> How should I think of withGame here?
10:29:59 <Eduard_Munteanu> Hm, I don't see why unless you want something else as well.
10:30:10 <kissyboy> but you don't need any rank-2 types
10:30:17 <elliott> kissyboy: yes you do
10:30:22 <elliott> or existential types
10:30:24 <elliott> one of the wto
10:30:26 <kissyboy> where
10:30:31 <elliott> plat0: well... like runST :) ski's existential solution may meet your needs better
10:30:31 <keep_learning> c_wraith, when ghc-7.4 is going to release ?
10:30:32 <zygoloid> plat0: creation isn't a problem. if you're conjuring up some (Tag a Int) value, and you didn't have an 'a' before, you do want that polymorphic in 'a' (purity implies it's ok to use that value in multiple regions)
10:30:42 <elliott> kissyboy: withGame :: ... -> (forall a. Game a -> [Player a] -> r) -> r
10:30:46 <kissyboy> oh i see
10:30:48 <kissyboy> i missed that
10:30:53 <elliott> kissyboy: or newGame :: ... -> GameAndPlayersExistential
10:30:55 <Philippa> elliott: yeah, existentials give you a rank-2 type for a constructor
10:31:03 <elliott> plat0: but it's easier to use "directly" without the existential
10:31:10 <c_wraith> keep_learning: it has its own branch now, so probably this month.
10:31:22 <plat0> elliott: what do you mean directly?
10:31:38 <elliott> plat0: main = withGame ... $ \g players -> print $ simulateGame g players 0.3 (1/60) "zoop"
10:31:43 <elliott> you don't have to unpack the existential to use it, etc.
10:31:55 <elliott> which can be tricky since there are special rules to stop the type variables escaping :)
10:32:01 <Eduard_Munteanu> elliott: hrm, right
10:32:03 <elliott> the approaches can be converted to each other with a simple wrapper
10:32:05 <zygoloid> plat0: withGame is the function which chooses the concrete type 'a'. that it is able to do that implies that the value it is given works for any specific fixed type 'a', which is what you wanted
10:32:06 <elliott> so it's not a big deal which you choose
10:32:13 <ski> plat0 : you should think of `withGame' as effecting the type `... -> exists a. (Game a,[Player a])', in a roundabout, CPSy, way
10:32:23 <elliott> I'd go with the "callback" style over the existential, personally, it's just nicer to use most of the time imo
10:32:26 <keep_learning> c_wraith, one more thing. I always find it hard to uninstall the old ghc and installing new one.
10:32:40 <keep_learning> c_wraith, so its just like delete the old files and install new one
10:33:19 <plat0> elliott: by existential you mean ski's wrapper type which uses forall to fake an exists?
10:33:34 <elliott> plat0: yes. it's not so much "exists" as "how we write exists around here" :)
10:33:34 <plat0> zygoloid: because the a in Game and Player are bound by the same forall?
10:33:36 <keep_learning> c_wraith, my current installation directroy is /usr/local/bin/ghc
10:33:39 <plat0> elliott: sure
10:34:02 <keep_learning> c_wraith, so just delete all the files of ghc and install new one ?
10:34:10 <c_wraith> keep_learning: I actually often have multiple versions of ghc installed simultaneously.  I just keep them in different directories, and keep a symlink to one of them in my path.  I switch the symlink when I want to switch versions.  But I only ever use user installs of ghc.  Never system installs.
10:34:17 <elliott> plat0: (withGame ... ExistentialConstructor), (\k -> case newGame ... of ExistentialConstructor g players -> k g players)
10:34:22 <elliott> plat0: that's how you change each approach into the other
10:35:20 <ski> plat0 : the two common way to effect `makeGame :: ... -> exists a. (Game a,[Player a])' are : (a) using CPS `withGame :: ... -> (forall a. Game a -> [Player a] -> r) -> r'; (b) using an auxilary data type `makeGame :: ... -> SomeGameFoo' where `data SomeGameFoo = forall a. MkGameFoo (Game a) [Player a]'
10:35:37 <plat0> OK.  This does remind me of continuations a lot.  Although maybe it should remind me of ST.  Perhaps it /would/ remind me of ST if I really knew what it was ;)
10:35:44 <elliott> plat0: the trick is
10:35:49 <elliott> runST :: (forall s. ST s a) -> a
10:36:08 <elliott> admittedly, there the quantification is in the return value not the arguments
10:36:14 * ski isn't sure there's a clear analogy with `runST' here
10:36:18 <elliott> but you can reason about how it forces s to be "unknown" in the same way, IMO
10:36:38 <elliott> you have to produce (ST s a) for any s whatsoever, you have to accept (Game g, [Player g]) for any g whatsoever
10:36:45 <keep_learning> c_wraith, so when we do ./configure --prefix=<my-dir> here  i can give <my-dir> as a target to install ?
10:37:01 <keep_learning> c_wraith, i generally do ./configure
10:37:05 <zygoloid> plat0: yes
10:37:08 <ski> but i suppose you could argue that `runST' has to hide an existential `s' inside it, which it instantiates its polymorphic argument with
10:37:08 <c_wraith> keep_learning: yes, that's how I do it.
10:37:26 <Eduard_Munteanu> keep_learning: yeah... think the default prefix is something like /usr
10:37:26 <plat0> elliott: OK so basically we're not applying the function directly to the Game and Player, we're building an action can be applied to the game and player.
10:37:35 <plat0> *that can be ...
10:37:37 <Eduard_Munteanu> So you end up with /usr/bin/..., /usr/lib/...
10:37:39 <ski> plat0 : yes, that's the CPS part of it
10:37:49 <elliott> plat0: hmm, er, not sure I agree, mostly because I associate "action" with (IO a) for some a :)
10:37:56 <elliott> but if ski thinks you're right you probably are :p
10:38:08 <plat0> elliott: But ST is the same isn't it?  You build a state transforming action.
10:38:17 <elliott> well, true. but ST is a monad.
10:38:21 <elliott> (ok, (ST s) is a monad for all s)
10:38:24 <keep_learning> c_wraith, and keep a symlink to one of them in my path. you mean keep the directory in $PATH
10:38:27 <elliott> so "action" makes sense there
10:38:47 <elliott> plat0: ... having said that, the callback is just (forall g. Reader (Game g, [Player g]) a)
10:38:54 <elliott> so i guess you are completely correct :)
10:38:58 <c_wraith> keep_learning: actually, the symlink is to the bin subdirectory of the prefix dir.  but yes
10:39:02 <ski> plat0 : the CPS part isn't really the important part. the important part is that by using CPS, we can translate the `exists' to a `forall' instead (because `(exists a. Foo a) -> Bar' is basically the same as `forall a. (Foo a -> Bar)')
10:39:33 <plat0> Sure, but the big problem is you can't get an exists in a covariant position, right?
10:39:41 <plat0> So you have to build an action rather than a value.e
10:39:41 <ski> plat0 : yes
10:40:10 <ski> plat0 : or rather, you probably can, but GHC doesn't implement it
10:40:12 <keep_learning> c_wraith, thank you for help.
10:40:16 <plat0> Super, glad I'm beginning to understand this a bit.
10:40:21 <plat0> Thanks for the help, all!
10:40:27 <ski> (e.g. Mercury allows it)
10:40:39 <Eduard_Munteanu> As a weak sum?
10:40:44 <ski> ?
10:40:44 <plat0> I think it would be a very nice addition to Haskell :)
10:41:07 <ski> iirc UHC or something allows `exists', but maybe it was just in contravariant positions
10:41:19 <Eduard_Munteanu> Well, Agda allows its "existentials" just about anywhere but that's a consequence of dependent types, and those sums being strong.
10:41:40 <Eduard_Munteanu> (I'm putting that in quotes since it's not exactly the same thing)
10:42:33 <ski> see <http://www.mercury.csse.unimelb.edu.au/information/doc-latest/mercury_ref/Existential-types.html> for existentials in Mercury
10:42:37 <keep_learning> c_wraith, so when we do cabal install then all packages will install in the directory where my ghc reside ?
10:42:55 <c_wraith> keep_learning: actually, they'll go in ~/.ghc
10:43:15 <c_wraith> keep_learning: which is where cabal puts them by default anyway, unless you specify global installs
10:43:19 * hackagebot dropsolve 0.1.2.1 - A command line tool for resolving dropbox conflicts. Deprecated! Please use confsolve.  http://hackage.haskell.org/package/dropsolve-0.1.2.1 (DanielTrstenjak)
10:43:29 <c_wraith> keep_learning: but it has different subtrees for each ghc version
10:43:42 <DevHC_> is there a DList-like functionality in some base package?
10:43:56 <elliott> DevHC_: ShowS
10:44:00 <elliott> for String
10:44:09 <plat0> Hmm, so am I right in thinking that (exists a. Foo a) is (((exists a. Foo a) -> r) -> r) is ((forall a. (Foo a -> r)) -> r)?
10:44:13 <elliott> with showChar, showString, showsPrec, etc.
10:44:29 <ski> you can also note that in `store', at <http://www.mercury.csse.unimelb.edu.au/information/doc-latest/mercury_library/store.html>, which is Mercury's `ST', we have basically `Store.init :: exists s. Store s', cf. `runST :: forall a. (forall s. ST s a) -> a'
10:44:41 <elliott> plat0: ((exists a. Foo a) -> r) is (forall a. Foo a -> r), yes
10:45:03 <plat0> And then stick -> r on both of those
10:45:11 <ski> plat0 : yes, the first "is" there is the CPSification
10:45:15 <plat0> the left hand one becomes just (exists a. Foo a) by CPS transform.
10:45:19 <plat0> Great.
10:45:23 <plat0> This is cunning.
10:45:32 <plat0> #haskell is much better than the online docs!
10:45:52 <elliott> plat0: oh no, are we?
10:45:52 <ski> plat0 : note that `Zot' is basically the same as `forall r. (Zot -> r) -> r' -- the `forall' here is very important, otherwise the latter gets more powerful
10:45:58 <elliott> plat0: monads are just like burritos!!!
10:46:06 <plat0> and spacemen!
10:46:17 <keep_learning> c_wraith, and what resides inside .cabal folder ?
10:46:45 <plat0> ski: Yeah I was kind of leaving the forall r. implied a la Haskell, but I understand.
10:47:12 <roconnor> Yondea lemma?
10:47:18 <Eduard_Munteanu> ski: hm, how does that work? Is that actually a value like (s :: *, Store s)?
10:47:32 <roconnor> oh no.
10:47:34 <roconnor> Codensity
10:47:34 <plat0> So when elliott said withGame :: ... -> (forall a. Game a -> [Player a] -> r) -> r he was giving me a cunning encoding of (exists a. (Game a, [Player a]))
10:47:39 <ski> plat0 : yeah, but if this type occurs within some larger type, the exactl placement of the `forall' can matter -- but if this is the whole type in a type signature (with `r' not bound further out), then it's ok
10:47:50 <DevHC_> is there a Queue-ish type?
10:47:52 <elliott> plat0: right -- a cunning encoding that's fairly easy to use directly
10:48:00 <ski> plat0 : one way to think of `forall a. Foo a -> ...' is as the type of functions which first takes an (implicit) *type* `a' as argument, then a value of type `Foo a'
10:48:01 <Eduard_Munteanu> DevHC_: Seq?
10:48:03 <c_wraith> keep_learning: package data (not that commonly used), cabal settings, the last-downloaded package index, sometimes a package source cache
10:48:09 <elliott> otherwise it'd just be obfuscation compared to an explicit existential wrapper :)
10:48:19 <Eduard_Munteanu> DevHC_: look at Data.Sequence
10:48:19 * hackagebot confsolve 0.2 - A command line tool for resolving conflicts of file synchronizers. Currently supported are Dropbox and Wuala.  http://hackage.haskell.org/package/confsolve-0.2 (DanielTrstenjak)
10:48:21 <plat0> Got it
10:48:28 <plat0> Very nice.
10:48:39 <plat0> This is the best thing I've learned today.
10:48:46 <ski> plat0 : one way to think of `(exists a. Foo a) -> ...' is as the type of functions which takes a *pair* of a(n imnplicit) type `a', and a value of type `Foo a' as argument
10:49:05 <keep_learning> c_wraith, so i have to delete the ghc ,just delete the directory in which it resides , .ghc and .cabal . This one looks more better then system install.
10:49:22 <DevHC_> looks gwd
10:49:36 <ski> plat0 : these two basically do the same thing : compare with `curriedFoo :: Bar -> Baz -> ...' vs. `uncurriedFoo :: (Bar,Baz) -> ...'
10:49:36 <elliott> ski: *cough* because that's all it is in type theory *cough* :)
10:49:48 * elliott said nothing
10:50:06 * ski stares blankly
10:50:10 <plat0> elliott: which type theory (did you say nothing about)?
10:50:15 <c_wraith> keep_learning: to remove absolutely everything, yes.  if you're going to go to another ghc version, it's often worth it to leave .cabal.
10:51:17 <elliott> plat0: well e.g. in Coq and Agda you do existentials by constructing the dependent tuple type which is a pair of (x : a) and (y : P a) for a given P
10:51:30 <elliott> martin-lof type theory has them built-in :p
10:51:35 <elliott> but i said nothing!
10:52:01 <ski> however, note that `(forall a. Bar a) -> ...' is different from `exists a. (Bar a -> ...)' (*because* the former may use the polymorphic argument multiple (or zero) times, each time with a possibly different type `a')
10:52:21 <plat0> OK yes I recall this is some sort of fibration over a.
10:52:47 * ski doesn't mention to elliott that s/he probably means `y : P x' instead of `y : P a'
10:52:54 <elliott> oops, yes
10:52:55 <elliott> sorry :)
10:53:06 <Eduard_Munteanu> elliott: yeah, though some people here pointed out you can't really use those for abstraction
10:53:07 <plat0> You guys are great at not mentioning interesting things.
10:53:18 <ski> elliott : huh, sorry about what ?
10:53:18 <elliott> i mean... sorry for coughing a lot and not saying anything
10:53:21 <elliott> of course
10:53:27 * ski looks innocent
10:53:37 <plat0> Is there a type theory channel?
10:53:46 <elliott> #haskell :-D
10:53:48 <ski> well, there's this channel :)
10:53:49 <plat0> Where did you guys learn type theory?
10:53:55 <elliott> there's #agda which i gather is popular
10:54:03 <plat0> OK well we can all just not mention type theory here.
10:54:34 * elliott doesn't know all that much type theory, really, but picked up what he did by trying to understand Coq and Agda code :)
10:54:46 <elliott> *does
10:54:54 <Eduard_Munteanu> Is there any translation of weak sums to MLTT?
10:55:10 <Eduard_Munteanu> (or something that comes close to an analogy at least)
10:55:29 <plat0> Well now I know the answer my life is very fine and I'm going to eat soup.
10:55:30 <Eduard_Munteanu> Irrelevance could help perhaps? I wonder.
10:55:48 <ski> plat0 : if you're interested, "Intuitionistic Type Theory" by Per Martin-Löf in 1984 at <http://intuitionistic.files.wordpress.com/2010/07/martin-lof-tt.pdf> might be good to read
10:55:57 <plat0> Thank you everyone
11:06:10 <singpolyma> Is there a way to write QuickCheck code in a seperate modul if you don't export your data constructors?
11:07:05 <DevHC_> what's the better way to accumulate IO () tasks in a variable as i add more scheduled tasks? using (>>) or using Seq? :}
11:07:08 <ezyang> singpolyma: One cute way is to have an Internal module which is re-exported by the public facing module, and imported by the Quickcheck module
11:07:15 <ezyang> I've also seen people use CPP for it.
11:07:34 <ezyang> DevHC_: Maybe you want a channel containing IO actions?
11:07:43 <elliott> DevHC_: with (>>) you'll build up a tower of (((a >> b) >> c) >> d), which I think is suboptimal
11:07:48 * elliott agrees with ezyang
11:08:30 <DevHC_> ezyang: i have no idea what that is
11:08:54 <ezyang> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent-Chan.html#t:Chan
11:09:21 <elliott> I like how the deprecated operations are lite din the docs without any warning. :/
11:09:26 <elliott> *listed in
11:09:32 <Eduard_Munteanu> :t sequence
11:09:32 <elliott> Maybe Haddock should understand DEPRECATED pragmas.
11:09:49 <Eduard_Munteanu> Bah.
11:09:59 <Eduard_Munteanu> @botslap
11:10:18 <ski>   sequence :: Monad m => [m a] -> m [a]
11:10:19 <shachaf> elliott: When you DEPRECATE x something you should probably change the documentation to say "you should use y instead" anyway.
11:10:36 <JoeyA> elliott: Isn't that basically the same as difference list composition?
11:10:50 * DevHC_ builds up a tower of ((((Data.Sequence.empty |> a) |> b) |> c) |> d)
11:11:07 <JoeyA> For a difference list, although it's O(n) to work out the first item after the tower has been built, it uses constant stack space.
11:11:09 <elliott> JoeyA: other way around, no?
11:11:16 <elliott> DevHC_: I think you really want a Chan.
11:11:26 <elliott> If you have IORef (Seq a) or whatever.
11:11:28 <elliott> Or MVar, etc.
11:11:32 <JoeyA> I wonder if >>_IO has the same property.
11:11:46 <DevHC_> elliott: i actually only have Safe stuff
11:11:59 <c_wraith> JoeyA: that isn't exactly true.
11:12:14 <DevHC_> but then again, i have 0 experience with MVars&Chans
11:12:49 <c_wraith> JoeyA: it's still O(1) to get the first element from a [a] -> [a] type.  it just doesn't share
11:12:54 <JoeyA> Of course, you could still build a difference list of actions and execute them with sequence_
11:12:57 <elliott> DevHC_: Safe? Huh?
11:13:27 <JoeyA> c_wraith: How can it be O(1) if the first value is buried under a tower of compositions?
11:13:33 <DevHC_> elliott: i only have RIO, or "restricted IO" types
11:13:42 <JoeyA> I mean that it's O(n) to get the initial item; subsequent items are O(1).
11:13:57 <c_wraith> JoeyA: well, ok.  it depends in the order of the compositions, actually.
11:14:23 <Eduard_Munteanu> Mm... isn't there some 'sequence' for arbitrary containers?
11:14:26 <DevHC_> JoeyA: don't u mean that it uses linear stack space?
11:14:44 <JoeyA> c_wraith: I'm assuming they're composed solely with appends.
11:15:03 <DevHC_> JoeyA, c_wraith: they r
11:15:04 <JoeyA> DevHC_: No, it uses constant stack space.  That's the whole point of difference lists.
11:15:14 <elliott> Eduard_Munteanu: yes
11:15:18 <elliott> Eduard_Munteanu: Data.Traversable
11:15:20 <DevHC_> JoeyA: i have no idea what difference lists r :P
11:15:24 <JoeyA> I don't quite understand why, though.
11:15:26 <shachaf> JoeyA: ((a++) . ((b++) . (c++))) [] will presumably be able to get elements from a immediately.
11:15:28 <Eduard_Munteanu> Ah, I guess it has the same name.
11:15:35 <c_wraith> Prelude> head ((1:) . undefined $ [])
11:15:35 <c_wraith> 1
11:15:41 <JoeyA> > ((1:) . (2:) . (3:)) []
11:15:49 <shachaf> JoeyA: (((a++) . (b++)) . (c++)) []  won't, of course.
11:15:54 <shachaf> But (.) is infixr. :-)
11:16:19 <DevHC_> ok ppl
11:16:22 <DevHC_> so basically
11:16:27 <JoeyA> DevHC_: A difference list is a "list" built with prepend functions composed with (.).
11:16:41 <JoeyA> To convert it to a regular list, apply [] to it.
11:16:54 <JoeyA> DevHC_: See http://hackage.haskell.org/packages/archive/dlist/latest/doc/html/Data-DList.html
11:17:04 <DevHC_> prepend or append?
11:17:08 <JoeyA> (it provides a list API for the concept)
11:17:30 <JoeyA> DevHC_: An item in a difference list is represented by a function that prepends the item.
11:17:41 <DevHC_> but so, basically, using Sequence stuff instead of ((a >> b) >> c) is a waste?
11:17:57 <JoeyA> So (1:) is a difference list with one item, (1:)
11:18:06 <shachaf> What?
11:18:12 <JoeyA> err, 1
11:18:25 <elliott> x = (x:) is a difference list with one item, (x:)
11:18:35 <JoeyA> DevHC_: I don't know if >> has the same benefit, but I suspect it does.
11:18:55 <ski> (`x = (x:)' is a type error)
11:19:07 <c_wraith> Hmm.  I guess I'm used to just using [a] -> [a] directly, and just setting it up such that construction is always lazy.
11:20:26 <c_wraith> the DList wrapper is actually significantly less flexible
11:21:44 <JoeyA> DevHC_: Based on some testing in the terminal, it seems ((a >> b) >> c) is actually inefficient.
11:22:04 <JoeyA> foldl' (\a x -> a >> print x) (return ()) [1..1000000] :: IO ()
11:22:15 <DevHC_> the question is, is there any difference in using Sequence stuff?
11:22:15 <alistra> > foldl' (\a x -> a >> print x) (return ()) [1..1000000] :: IO ()
11:22:22 <alistra> lambdabot: ping
11:22:24 <JoeyA> It prints numbers slowly, suggesting that it's O(n^2)
11:22:38 <Veinor> @botsnack
11:22:54 <alistra> @buttsnack
11:23:02 <JoeyA> DevHC_: Using Sequence, you'll get O(n * log n), if I understand correctly.
11:23:04 <DevHC_> Veinor: i'll take it! nom!
11:23:11 <c_wraith> DevHC_: Sequence is... not very likely to be the structure you're looking for.
11:23:12 <JoeyA> Whereas with a difference list, you'll get O(n) running time
11:23:22 <Veinor> alistra: keep it to #haskell-after-dark
11:23:40 <alistra> hey it's pretty dark in here
11:23:50 <elliott> if we offer \bot enough snacks she'll come back
11:23:53 <alistra> maybe because of the winter
11:24:01 <DevHC_> ok, so i'll use difference lists
11:24:07 <c_wraith> JoeyA: actually, sequence is a finger tree.  putting an element at the start or end is amortized O(1)
11:24:20 <JoeyA> Oh
11:24:22 <c_wraith> JoeyA: and traversing it is O(n)
11:24:30 <JoeyA> DevHC_: foldl' (\a x -> a . (print x >>)) id [1..1000000] (return ())
11:24:37 <c_wraith> JoeyA: the constant factors will be worse, though
11:24:51 <lambdabot> Plugin `type' failed with: thread killed
11:25:12 <vrook> monadCons x = liftM (x :) -- can I get rid of the x?
11:25:14 <Veinor> @botsnack
11:25:21 <Veinor> :()
11:25:21 <JoeyA> DevHC_: The code above uses the same concept as a difference list (compositions), except instead of : for prepending list items, we're using >> to prepend actions.
11:25:22 <Veinor> :(
11:26:15 <c_wraith> DevHC_: Sequence is honestly not that great unless you're doing something it performs really well at, like a combination of pushing to the front, the back, and random access
11:26:48 <c_wraith> vrook: monadCons = liftM . (:)
11:27:05 <shachaf> Don't call it monadCons. :-(
11:27:25 <ski> better to unfold the definition
11:27:44 <vrook> consM ?
11:27:55 <elliott> mons
11:28:04 <JoeyA> In (foldl' (\a x -> a . (x:)) id [1..1000]) [], is foldl' more efficient than foldl, or does it not matter because the accumulator is a function?
11:28:04 <gwern> @quote
11:28:07 <vrook> c_wraith: that was the first thing I tried. It gives "Inferred type is less polymorphic than expected"
11:28:15 <shachaf> Much better to use fmap (x:) yourself than give it that particular name (if it needs a name at all, which it probably doesn't).
11:28:22 <shachaf> vrook: Probably the monomorphism restriction.
11:28:26 <c_wraith> vrook: monomorphism restriction, probably
11:28:37 <elliott> Maybe it's the monomorphism restriction!
11:28:44 <shachaf> vrook: Give it an explicit type signature. You ought to do that anyway.
11:28:45 <c_wraith> vrook: try giving it an explicit type signature
11:28:54 <elliott> You should probably give it an explicit type signature.
11:28:56 <ski> vrook : instead of  head result `monadCons` shuffle (tail result)  why not  (result :) `liftM` (shuffle results)  ?
11:28:57 <c_wraith> if lambdabot was around, I'd ask about stereo
11:28:58 <silver> lol
11:29:04 <elliott> c_wraith: :(
11:29:38 <shachaf> elliott: Your patch broke lambdabot?
11:29:46 <ski> vrook : assuming you change `let result = swapElems 0 index xs' to `let result:results = swapElems 0 index xs', of course
11:29:56 <elliott> shachaf: No, it was the puppy-killing.
11:30:07 <elliott> I don't think Cale has actually applied the patch yet.
11:30:09 <elliott> > 2+ 2
11:30:14 <shachaf> 5
11:30:20 <KirinDave> grrr, HSH still broken for ghc 7.2.* :(
11:30:21 <vrook> why does liftM . (:) provoke the morphism restriction while liftM (x :) does not?
11:30:32 <elliott> morphism restriction :D
11:30:41 <shachaf> vrook: You should read about what it is.
11:30:43 <vrook> monomorphism
11:30:46 <shachaf> vrook: Then you'll know.
11:30:50 <roconnor> vrook: f = ... provokes the MR, while f x = ... does not
11:31:00 <ski> vrook : `monadCons = ...' provokes the DRM, while `monadCons x = ..x..' doesn't, because the latter is a function binding
11:31:22 <elliott> DRM?
11:31:23 <ski> vrook : i suggest disabling the DMR, so you don't have to be annoyed at it
11:31:25 <elliott> Damn Restriction on Monomorphism?
11:31:30 <shachaf> elliott: Dreaded.
11:31:34 <elliott> *Damned
11:31:35 <elliott> shachaf: Ah.
11:31:38 <ski> elliott : er, sorry, DMR :D
11:31:55 <shachaf> I recommend disabling GHC's DRM too, if you're running into difficulties.
11:32:00 <elliott> It should be "to Monomorphism", I suppose.
11:32:07 <elliott> shachaf: But that disables GHC's Trusted Computing features.
11:32:08 <Eduard_Munteanu> Don't worry, DRM is worse :P
11:32:10 <elliott> Like Safe Haskell.
11:32:27 <ski> (and the "D" stood for "Dreaded", yes)
11:32:44 <shachaf> You might have to get the black market version from Edinburgh to disable it completely.
11:32:55 <vrook> sorry, I didn't realize the problem matched exactly the example on haskell wiki for monomorphism
11:33:19 <shachaf> vrook: Every example of the DMR matches that, because that's what the DMR is. :-)
11:33:25 <vrook> yep
11:33:30 * ski wonders when GHC wil lhave `NoMonomorphismRestriction', by default
11:33:37 <vrook> I just didn't recognize it in the wild
11:33:40 <shachaf> ski: When it's part of Haskell?
11:34:02 <ski> i suppose
11:34:07 <shachaf> So never. :-(
11:34:28 * Eduard_Munteanu wonders about -Wmonomorphism-restriction
11:34:37 <elliott> stereomorphism restriction
11:35:43 <FUZxxl> Hi!
11:35:43 <preflex>  FUZxxl: you have 1 new message. '/msg preflex messages' to read it.
11:35:53 <FUZxxl> preflex: messages
11:35:53 <preflex>  DanBurton said 21 hours and 39 minutes ago: regarding the dupes, I don't really mind either way. I kinda like mine better though.
11:38:08 <tristes_tigres> *Main> signum (0.0/0.0)
11:38:08 <tristes_tigres> -1.0
11:38:18 <tristes_tigres> that's SO broken
11:38:41 <alistra> why?
11:38:56 <FUZxxl> tell DanBurton Too poor yours got closed duplicate... I am happy that simonpj tries to implement #5676
11:39:07 <FUZxxl> preflex: tell DanBurton Too poor yours got closed duplicate... I am happy that simonpj tries to implement #5676
11:39:07 <preflex>  Consider it noted.
11:40:40 <shachaf> tristes_tigres: Should be NaN, I suppose?
11:42:06 <Axman6> @src signum
11:42:35 <tristes_tigres> operations on NaN are expeced to produce NaN
11:42:45 <hpaste> “Joey Adams” pasted “Building a list of actions using the difference list technique” at http://hpaste.org/54887
11:43:01 <JoeyA> DevHC_: ^
11:43:10 <tristes_tigres> GHC thinks that signum NaN =-1
11:43:21 * hackagebot happstack-plugins 6.2.1 - The haskell application server stack + reload  http://hackage.haskell.org/package/happstack-plugins-6.2.1 (JeremyShaw)
11:43:53 <FUZxxl> > 1 + 1
11:43:58 <FUZxxl> DanBurton: Hi!
11:44:03 <tristes_tigres> and that's broken
11:44:22 <FUZxxl> Is lambdabot up again?
11:44:29 <FUZxxl> preflex: seen lambdabot
11:44:30 <preflex>  lambdabot was last seen on #haskell 19 minutes and 39 seconds ago, saying: Plugin `type' failed with: thread killed
11:44:39 <FUZxxl> oops
11:44:47 <JoeyA> lambdabot is here, but in a coma, apparently.
11:44:50 <mauke> preflex: seen Cale
11:44:50 <preflex>  Cale was last seen on #haskell 14 hours, 14 minutes and 44 seconds ago, saying: Just brought lambdabot up :)
11:44:51 <DanBurton> FUZxxl: hi :)
11:44:51 <preflex>  DanBurton: you have 1 new message. '/msg preflex messages' to read it.
11:45:27 <_Mikey> we need llama bot-tbh
11:45:42 <FUZxxl> Simonpj said my request is interesting but there probably won't be anybody who wants to implement it :(
11:45:57 <JoeyA> What request?  I'm curious.
11:46:20 <FUZxxl> #5677
11:46:33 <FUZxxl> http://goo.gl/oydx4
11:46:35 <alistra> preflex suddenly became more popular
11:46:40 <alistra> with lambdabot dead and all
11:46:43 <FUZxxl> hehe
11:46:48 <mauke> preflex: botsnack
11:46:48 <preflex>  :-)
11:47:01 <ski> preflex: botslack
11:47:01 <DanBurton> FUZxxl: so implement it yourself? :) I assume spj is talking about people who are paid to work on it
11:47:07 <alistra> preflex: snack
11:47:32 <DanBurton> preflex doesn't seem to have the spell-fudging that lambdabot does
11:47:33 <vrook> ever notice what happens when you forget # after LANGUAGE? "ghc: panic! (the 'impossible' happened)"
11:47:35 * FUZxxl is happy that his codegolf (http://goo.gl/nWfga ) got so many views just from pasting a link into IRC
11:47:46 <FUZxxl> vrook: o.O
11:47:51 <mauke> sounds like a ghc bug
11:48:20 * hackagebot happstack-server 6.4.1 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.4.1 (JeremyShaw)
11:48:36 <FUZxxl> DanBurton: I implement it yourself if you explain me the GHC source.
11:50:14 <FUZxxl> I have yet to understand the black magic that drives the scripts that build GHC...
11:50:44 <ezyang> Infinite Makefile magic!
11:51:23 <FUZxxl> Hi ezyang!
11:51:44 <ezyang> FUZxxl: 'lo!
11:51:47 <siracusa> vrook: That should have been fixed in recent versions
11:51:57 <FUZxxl> ezyang: You haven't posted to your blog in a while
11:52:14 <vrook> ok. this is 6.10.4
11:52:18 <elliott> ouch!
11:52:30 <ezyang> It's true. I had one post cooking but I think I left it on the burner too long and now it's smelling a little funny.
11:52:30 <elliott> vrook: that came out in july 2009
11:52:36 <FUZxxl> hehe
11:52:39 <shachaf> ezyang: See, that's what you get for updating too frequently
11:52:45 <FUZxxl> ezyang: Are you still studying?
11:52:50 <DanBurton> FUZxxl: I'll get back to you on that in maybe 20 years. :) I expect I'll know GHC source by then, maybe.
11:52:50 <vrook> it's still the version in macports
11:52:54 <shachaf> ezyang: People get addicted and then they start complaining when they have to go for two weeks without a fix.
11:52:57 <ezyang> Yeah. PhD apps and all that jazz :-)
11:53:07 <FUZxxl> DanBurton: Okay. Now we are at 2:1...
11:53:18 <elliott> vrook: well, you're going to run into a lot of problems the minute you try using any library :)
11:53:23 <FUZxxl> ezyang: uff... I am still in highschool
11:53:23 * hackagebot happstack 6.0.5 - The haskell application server stack + code generation  http://hackage.haskell.org/package/happstack-6.0.5 (JeremyShaw)
11:53:24 * hackagebot happstack-lite 6.0.2 - Happstack minus the useless stuff  http://hackage.haskell.org/package/happstack-lite-6.0.2 (JeremyShaw)
11:53:26 * hackagebot happstack-hamlet 6.2.2 - Support for Hamlet HTML templates in Happstack  http://hackage.haskell.org/package/happstack-hamlet-6.2.2 (JeremyShaw)
11:53:29 * hackagebot happstack-server 6.4.2 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.4.2 (JeremyShaw)
11:53:31 * hackagebot happstack-hsp 6.2.4 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-6.2.4 (JeremyShaw)
11:53:32 <ezyang> :-) No need to hurry.
11:53:56 <elliott> vrook: I think most people on OS X use the Haskell Platform installer, GHC package installers or Homebrew, those all have ghc 7
11:54:03 * DanBurton wishes he started learning Haskell in high school
11:54:08 <vrook> k thanks
11:54:14 <FUZxxl> ezyang: Can you recommend a university for stuying CS with a focus on FP?
11:54:22 <ezyang> Are you US-based?
11:54:25 <FUZxxl> I'd like to stay in Europe if possible
11:54:38 <ezyang> Oh, that makes things easier :-)
11:54:47 <DanBurton> lucky
11:54:57 <FUZxxl> Is it more difficult in the USA?
11:55:13 <DanBurton> seems like USA is all about the OOP
11:55:24 <shachaf> What?
11:55:33 <FUZxxl> Yeah... Same in many German universities.
11:56:13 <FUZxxl> The FU in Berlin actually invented their own Haskell look-alike »Opal«, but many students say its as pleasant to code as COBOL
11:56:26 <ezyang> FUZxxl: It's the so-called "Eurotheory" divide
11:56:31 <FUZxxl> ?
11:56:56 <ezyang> American computer scientists love complexity theory and algorithms. Europeans love semantics, category theory, etc.
11:57:03 <FUZxxl> hehe
11:57:09 <FUZxxl> That's interesting.
11:57:14 <ezyang> FUZxxl: Anyway, Cambridge University is an obvious place to try for.
11:57:27 <FUZxxl> It also explains why most Haskell stuff has names that stem from European universities
11:57:39 <FUZxxl> I try. Is it difficult to get in?
11:57:44 <gtirloni> it's no uncommon to use a FP language used in an undergraduate program to teach algorithms.. I think you'll worry about finding a FP-focused university if you go to grad school, seems right?
11:57:44 <FUZxxl> What about Glasgow?
11:58:08 <ezyang> It is one of the two top universities in the UK, so... yes :-)
11:58:34 <FUZxxl> I think in Europe there is no grad school... I've only heard that term from the USA
11:58:35 <ezyang> Hmm. I don't really know what Glasgow is up to these days.
11:58:56 <_oz> hi all. FUZxxl Edinburgh is nice for undergrad
11:59:05 <_oz> iirc, they start with haskell
11:59:17 <ezyang> ++ on Edinburgh
11:59:18 <FUZxxl> I also thought about Potsdam, they have the HPI, a private university founded by SAP. I think they are a little bit to concrete for me
11:59:58 <FUZxxl> great...
12:00:00 <_oz> there is also the obvious Utrecht and Chalmers options
12:00:13 <FUZxxl> Is there any university you don't recommend?
12:00:20 <_oz> as they've already said, there are several nice options in Europe
12:00:35 <_oz> FUZxxl: I wouldn't go that far :)
12:00:41 <FUZxxl> hehe
12:00:52 <alkabetz`> Hey #haskell, what's the "correct" way to read something like "0b100101001" as a binary number?
12:01:09 <Botje> readIntAtBase 2
12:01:38 <FUZxxl> okay
12:01:52 <alkabetz`> Botje: What package is that in?  Hoogle doesn't seem to find it.
12:02:11 <ezyang> Try Hayoo.
12:02:15 <ezyang> @hayoo readIntAtBase
12:02:18 <ezyang> boo
12:02:24 <FUZxxl> Damn Haskell. You have functions for anything... Why can't you let me code an obfuscated example to let others think it's all black magic?
12:02:30 <carpi> is it possible to use the actual mathematical lambda symbol when write lambda functions in haskell?
12:02:37 <FUZxxl> ezyang: lambdabot crashed quite often recently
12:02:41 <FUZxxl> preflex: seen lambdabo
12:02:42 <preflex>  Sorry, I haven't seen lambdabo
12:02:43 <FUZxxl> preflex: seen lambdabot
12:02:44 <preflex>  lambdabot was last seen on #haskell 37 minutes and 53 seconds ago, saying: Plugin `type' failed with: thread killed
12:02:49 <shachaf> carpi: By "mathematical" do you mean "Greek"?
12:02:59 <carpi> shachaf: yes
12:03:06 <c_wraith> FUZxxl: just using the applicative instance for (->) wherever possible.  that's pretty close to obfuscation
12:03:07 <FUZxxl> shachaf: Well, no.
12:03:11 <FUZxxl> hehe
12:03:17 <FUZxxl> Just using SKI?
12:03:20 * hackagebot happstack-hstringtemplate 6.0.3 - Support for using HStringTemplate in Happstack  http://hackage.haskell.org/package/happstack-hstringtemplate-6.0.3 (JeremyShaw)
12:03:38 <carpi> shachaf: being able to use the actuall greek symbol would make code more beautiufl
12:03:39 <mauke> alkabetz`: it's readInt
12:03:40 <FUZxxl> What I love is abusing the fact that lambdabot generalizes (.) and friends.
12:03:55 <shachaf> carpi: You can get your editor to use it and turn it into \.
12:04:02 <FUZxxl> carpi: No. It's supposed to work, but it actually doesn't
12:04:11 <shachaf> carpi: However, it won't make your cod emore beautiful.
12:04:41 <FUZxxl> carpi: Using {-# LANGUAGE UnicodeSyntax #-}, you can use much unicode, but due to char-class conflicts, lambda does not work
12:05:12 <carpi> : (
12:05:33 <carpi> would be nice to use the actual lambda though
12:05:48 <c_wraith> you can use other lambdas
12:05:50 <donri> carpi: there are scripts for vim and emacs to pretend some operators are unicode
12:06:23 <donri> https://github.com/Twinside/vim-haskellConceal etc
12:07:21 <c_wraith> heh.  𝜆, for instance, except I don't appear to have a font with a glyph for it
12:07:42 * elliott sees it
12:07:44 <elliott> too italic
12:07:46 <FUZxxl> c_wraith: Did you tried using APL symbols?
12:07:56 <elliott> the lambda is overrated anyway
12:08:01 <elliott> it was a mistake anyway
12:08:13 <elliott> alkabetz`: Numeric, I believe.
12:08:16 <elliott> import Numeric
12:09:22 <donri> the lambda was a mistake?
12:09:28 <donri> is this really #haskell i'm in
12:09:37 <mauke> haskell doesn't use a lambda
12:09:46 <FUZxxl> donri: No. You're in a parallel universe
12:09:51 <donri> ohnoes
12:10:20 <FUZxxl> donri: In this universe, Haskell looks like this:
12:10:21 * tgeeky is grasping at straws here. I'm looking for a package which has some features like 'doctest' (that is, it does processing with comments in hs source files, using haddock) -- but it also had some new syntax that haddock doesn't use... anyone seen this? lately? last 2 weeks? on github?
12:10:21 <donri> oh, you mean the use of the lambda letter in math
12:10:22 <FUZxxl> HAI
12:10:26 <tgeeky> halp :/
12:10:28 <FUZxxl> CAN HAS MONADZ?
12:10:39 <FUZxxl> AI LOVE ZEE MONADS!
12:10:44 <FUZxxl> FIRE ZEE MISSILES!
12:10:48 <FUZxxl> OHNOES
12:10:57 * tgeeky blinks slowly
12:10:58 <elliott> :(
12:10:58 <FUZxxl> LAMBDA NO LEMME DO
12:11:13 <FUZxxl> KTHXBYE
12:11:17 <elliott> donri: the character, in particular
12:11:21 <elliott> donri: it was a mistake in a very literal sense, since it was originally ^ :)
12:11:21 <donri> :)
12:11:26 <elliott> well not so much a mistake
12:11:34 <elliott> but a misguided fix :)
12:11:39 <elliott> I forget what the problem with ^ was now
12:11:46 <mzero> tgeeky: seems vaguely familiar… yet I'm drawing a blank
12:11:50 <donri> isn't most of math notation a "hack"
12:11:53 <tgeeky> mzero: :(
12:11:58 <tgeeky> I am pretty sure I saw it on github.
12:12:12 <tgeeky> but my stupid brain and browser aren't letting me get at my history well enough
12:12:21 <elliott> tgeeky: github has search :P
12:12:34 <tgeeky> elliott: yes, I've tried some general things...
12:12:41 <tgeeky> haddock restricted to haskell
12:12:50 <elliott> tgeeky: https://github.com/search?langOverride=&language=Haskell&q=test&repo=&start_value=1&type=Repositories&x=0&y=0
12:12:54 <elliott> tgeeky: might take a while to go through :P
12:12:58 <elliott> oh only 85
12:12:59 <elliott> not so bad then
12:13:27 <tgeeky> i've done this for a few keywords
12:13:32 <tgeeky> have not found yet
12:13:51 <elliott> fair enough
12:13:55 <mzero> tgeeky: this? https://github.com/sol/doctest-haskell#readme
12:14:09 <tgeeky> mzero: nope. that i'm aware of
12:14:13 <elliott> he said like the doctest package, not the doctest package :)
12:15:29 <donri> i'm probably the only person in the world who has ">>> " as his ghci prompt (because haddock and the doctest package)
12:15:29 <mzero> ah - thought he meant like generic "dockets" -- no the specific one
12:16:20 <tgeeky> donri: a simple idea. yes.
12:16:27 <tgeeky> donri: thanks.
12:16:36 <donri> what, i didn't do anything
12:16:47 <tgeeky> donri: you reminded me to change my ghci prompt
12:17:11 <donri> ah :)
12:17:34 <donri> to answer your question, i too only know of the "doctest" package and to my knowledge it does use haddock syntax (which for some reason is like python's)
12:37:26 <FUZxxl> silence?
12:37:38 <JoeyA> > fix lambdabot
12:37:41 <hpaste> keep_learning pasted “Installing derive” at http://hpaste.org/54889
12:38:00 <keep_learning> hello all
12:38:33 <FUZxxl> keep_learning: Hi!
12:38:54 <FUZxxl> I don't know how to solve your problem, sorry.
12:39:08 <keep_learning> i have installed ghc-7.0.3 in  one of my folder ( /home/user/Public ) and want ot export the libraries installed for global ghc
12:39:39 <keep_learning> FUZxxl, no problem.
12:40:00 <Saizan> keep_learning: you can't use libs compiled for one version of ghc with another version
12:40:23 <elliott> JoeyA: it was me, I broke it
12:40:34 <keep_learning> Saizan, so i need to run cabal install derive ?
12:40:49 <keep_learning> Saizan, where it will install the derive ?
12:41:08 <Saizan> keep_learning: pointing cabal to the right ghc
12:41:26 <Saizan> keep_learning: e.g. cabal install -w ghc-7.0.3 derive, if ghc-7.0.3 is in your PATH
12:41:47 <keep_learning> Saizan, thank you
12:55:08 <vrook> Inside a do block "(y :) `liftM` shuffle ys" and "rest <- shuffle ys ; return $ y : rest" are the same. Is there an "unlift" operation which would allow me to write something like "return $ y : unLiftM (shuffle ys)"  ?
12:55:34 <vrook> just eliding the "rest", basically
12:57:51 <Botje> that would require a magic "unmonad" operation
12:57:52 <DanBurton> I feel suspicious of using both "unlift" and "return", since they sound like opposites
12:58:24 <vrook> yes it would be magical, like the "do" block is magical
12:58:26 <aristid> @hoogle extract
12:58:28 <DanBurton> the recommended way would be just to use liftM as you have
12:58:36 * ski notes this is basically his monadic reflective syntax
12:58:42 <aristid> lambdabot: Y U NO HOOGLE?
12:58:52 <DanBurton> lambdabot down
12:59:04 <DanBurton> preflex: seen lambdabot
12:59:04 <preflex>  lambdabot was last seen on #haskell 1 hour, 34 minutes and 15 seconds ago, saying: Plugin `type' failed with: thread killed
12:59:48 <carpi> could someone please tell me what is the purpose of curry?
12:59:51 <DanBurton> unLiftM = unsafePerformMagic
13:00:11 <DanBurton> carpi: you mean the Haskell function "curry", or currying in general?
13:00:13 <aristid> DanBurton: turns out there IS a kind of "opposite" to return: http://hackage.haskell.org/packages/archive/comonad/1.1.1.1/doc/html/Control-Comonad.html#t:Comonad
13:00:18 <ski> carpi : converting an uncurried function to a curried one
13:00:22 <Saizan> vrook: not as a function, but possibly as sugar
13:00:23 <aristid> DanBurton: it just doesn't work on the same types:)
13:00:23 <carpi> DanBurton: haskell curry
13:00:37 <ski> carpi : also, partially applying an uncurried function on its first argument
13:00:56 <DanBurton> carpi: if you have a function that takes a tuple as input, "curry" can transform it into a function that takes the parts of the tuple separately
13:00:59 <vrook> Shorter version: I'm just talking about a shortcut for "x <- foo bar ; baz x"
13:01:07 <elliott> Has anyone told vrook about banana brackets?
13:01:14 <DanBurton> curry f x y = f (x,y)
13:01:17 <elliott> Based on my 0.01 seconds of reading his line they sound relevant.
13:01:23 <elliott> Erm.
13:01:24 <elliott> Idiom brackets.
13:01:25 <Saizan> vrook: i'd write baz =<< foo bar
13:01:31 <elliott> Banana brackets are the same symbols that mean a different thing. :-(
13:01:34 * ski thinks vrook wants `[< y : [>shuffle ys <] >]'
13:01:47 <carpi> DanBurton: ah.. i think now i kind of undertand. thanks )
13:02:03 <elliott> (| ~y : shuffle ys |)
13:02:14 * elliott thinks ski's looks promising too
13:02:22 <elliott> but [<...>] and [>...<] are too heavy-weight
13:02:24 * ski thinks idiom brackets aren't composable
13:02:35 <ski> elliott : you're free to suggest a better concrete syntax
13:02:47 <elliott> (| y : { shuffle ys } |)? i guess that's probably way too ambiguous outside of unfix
13:02:59 <elliott> (| y : {| shuffle ys |} |) -- bit too heavy on the |s...
13:03:09 * ski has mostly pondered how to type and translate his syntax
13:03:27 <DanBurton> style poll: when is it preferred to use lambda expressions as opposed to moving the inputs to the left of = ? e.g. curry f x y = f (x,y) --vs-- curry f = \x y -> f (x,y)
13:03:46 <keep_learning> When i run cabal install -w ghc-7.0.3 deepseq , it installed deepseq-1.2.0.1. However as suggested by c_wraith i need to install deepseq-1.1.*
13:04:02 <elliott> actually you could just overload ~(...) to be [>...<], since afaict that's always invalid normally
13:04:17 <c_wraith> keep_learning: add --constraint=deepseq==1.1.* to the cabal install line
13:04:18 <ski> DanBurton : the latter is sometimes used when you want to think about `curry' as returning the curried function itself
13:04:33 <keep_learning> how to unregister the deepseq-1.2.0.1 ?
13:04:45 <elliott> DanBurton: you can golf that RHS! curry f = curry f ... wait ...
13:04:58 <c_wraith> keep_learning: ghc-pkg unregister deepseq-1.2.0.1
13:05:02 <Saizan> ghc-pkg-7.0.3 unregister
13:05:16 <DanBurton> curry f = f .: (,)
13:05:37 <ski> DanBurton : if you have more than once defining equation, or have nontrivial formal parameters, then you can't always go from one form to the other, though
13:05:46 <elliott> uncurry f = f .: inverse (,)
13:05:53 <ClaudiusMaximus> DanBurton: i use lamba expressions instead of putting it to the left of = when i want to share some expensive computation depending only on the first few arguments
13:05:58 <elliott> ski: or if you have "where"
13:06:04 <elliott> that depends on late enough arguments
13:06:12 <ski> elliott : yeah
13:06:16 <DanBurton> aye, true
13:06:28 <elliott> DanBurton: but moving things into a lambda lets you do sharing
13:06:48 <DanBurton> elliott: what kind of sharing?
13:06:49 <ClaudiusMaximus> DanBurton: f x y z = g expensive z where expensive = h x y  -vs-  f x y = \z -> g expensive z where expensive = h x y
13:07:35 <DanBurton> I'm not sure I see the difference
13:07:51 <elliott> DanBurton: f x = let x' = expensive x in \y -> x'+y
13:07:56 <elliott> DanBurton: f x y = expensive x + y
13:08:05 <elliott> if you curry the former, the expensive computation is shared between all applications
13:08:20 <elliott> not so for the latter (unless GHC works its magic, but it's pretty conservative about that)
13:08:34 <DanBurton> ah I get it
13:08:56 <DanBurton> thanks
13:09:54 <vrook> Seems the rule should be "always use curried form" due sharing? When wouldn't you want to share?
13:10:08 <elliott> vrook: because usually you don't curry
13:10:13 <elliott> also, sharing can introduce space leaks
13:10:27 <elliott> also, it only works when you have a computation only involving arguments in the right order
13:10:28 <ClaudiusMaximus> vrook: when it takes up lots of space and is cheap to recompute (like [1,,1000000] :: [Int])
13:10:33 <Saizan> ClaudiusMaximus: f x y = g expensive :P
13:10:44 <elliott> vrook: basically most of the time you don't want this
13:10:45 <ClaudiusMaximus> Saizan: true in that case
13:10:50 <elliott> but it's easy to get when you do want it
13:11:01 <keep_learning> c_wraith, when i am running  cabal install -w ghc-7.0.3  --constraint=deepseq-1.1.* then i am getting cabal: dependency expected
13:11:39 <ClaudiusMaximus> keep_learning: --constraint="deepseq==1.1.*" maybe
13:12:13 <ClaudiusMaximus> keep_learning: but i don't know if it understands the *, or whether == is correct (might should be =)
13:13:21 <elliott> cabal understands *
13:14:14 <keep_learning> ClaudiusMaximus, none of --constraint="deepseq-1.1.*" , "deepseq==1.1.*" , "deepseq--1.1.*" and "deepseq=1.1.*" is working
13:14:49 <ClaudiusMaximus> keep_learning: then perhaps try --constraint="deepseq>=1.1" --constraint="deepseq<=1.2"
13:15:06 <ClaudiusMaximus> oops < not <=-
13:15:21 <Saizan> --constraint='deepseq == 1.1.*' worked for me before
13:19:04 <keep_learning> Saizan, [user@haskell Spatial]$ cabal install -w ghc-7.0.3   --constraint='deepseq == 1.1.*'  output is " cabal: No cabal file found. Please create a package description file <pkgname>.cabal"
13:19:06 <mkscrg> i've noticed that Either is documented with the instance Monad (Either e), but ghci doesn't seem to believe
13:20:00 <donri> perhaps you need to import the instance from somewhere
13:21:34 <_Mikey> guys
13:21:43 <_Mikey> I know I'm not thinking
13:21:57 <_Mikey> how to get this -.-
13:22:05 <_Mikey> gahh can't think.
13:22:29 <keep_learning> any one please ?
13:22:42 <Saizan> keep_learning: you also need deepseq there
13:23:06 <Saizan> keep_learning: cabal install -w ghc-7.0.3 --constraint='deepseq == 1.1.*' deepseq
13:23:45 <Saizan> keep_learning: othersie if you know the exact version e.g. 1.1.0.2 you can say cabal install -w ghc-7.0.3 deepseq-1.1.0.2
13:23:46 <keep_learning> Saizan, great , thank you
13:24:07 <_Mikey> :t zipWith
13:24:18 <_Mikey> ahh damn
13:24:25 <_Mikey> curse you lambdabot!
13:24:36 <Saizan> poor thing
13:24:49 <keep_learning> looks like i need to put all these detail some where. probably on my blog . Thank you for help.
13:25:19 <Saizan> cabal install --help has them
13:28:36 <ari> @bot
13:29:48 <ari> ... where do I find a lambdabot that's willing to listen to me? :(
13:30:28 <DanBurton> http://hackage.haskell.org/package/lambdabot
13:31:38 <DanBurton> make sure you're familiar with the good ol' "unpack, tweak version number, cabal install" trick; you might need it a lot to get lambdabot installed properly
13:32:15 <DanBurton> such was my experience when I finally installed lambdabot. Then a few months later my laptop died :( goodbye my sweet lambdabot
13:33:05 <ari> I actually do have a running lambdabot myself, I just wanted to check with somebody else's, since mine is saying that @pointless \x -> x is \x -> x, and call me crazy but that seems kind of pointy to me
13:33:37 <DanBurton> indeed
13:36:24 <JoeyA> lambdabot gives me id when I say @pointless \x -> x
13:36:49 <ski> yes ?
13:37:53 <JoeyA> (in response to what ari said)
13:38:08 <lambdabot> Plugin `dummy' failed with: thread killed
13:38:26 <mercury^> @pl \x -> x
13:41:02 <ari> Ah, well
13:41:15 <ari> Fortunately the stand-alone pointfree package at least acted more sensibly
13:41:41 <ari> Just out of curiousity, though, what *is* up with lambdabot? (i.e. the one on this channel right now?
13:42:36 <Saizan> got patched to be more reliable
13:42:55 <elliott> lol
13:42:58 <elliott> i don't think that's even been applied yet
13:43:04 <elliott> at least, it's not in the repo
13:43:06 <elliott> you can't blame me!
13:43:34 <olsner> the patch made lambdabot more reliably disconnected?
13:43:49 <monochrom> lambdabot has a flu :)
13:43:49 <elliott> the period of perfect reliability (downtime) will start when it gets applied
13:44:10 <roconnor> boid-flu
13:46:12 <DevHC^> how do i fix ``Could not find module `Prelude':
13:46:12 <DevHC^>       Perhaps you haven't installed the "dyn" libraries for package `base'?'' ?
13:59:11 <elliott> is there a way to portably get the system temporary directory in base?
13:59:16 <elliott> i.e. /tmp for unix
14:00:39 <mux> that was one great quit message
14:01:13 <elliott> ah, getTemporaryDirectory
14:01:13 <Axman6> elliott: mktmp i think
14:01:34 <elliott> Axman6: this is to pass /to/ openTempFile
14:02:03 <mux> portable ways involve looking for TMPDIR / TEMPDIR environment variables and falling back to /tmp (under UNIX of course)
14:02:04 <Axman6> oh, i read base as bash =)
14:02:30 <mux> @src getTemporaryDirectory
14:03:07 <mux> yeah, that's about what it does
14:03:15 <elliott> Axman6: heh
14:03:38 <Axman6> also, stop breaking lambdabot
14:10:51 <`Zerax`> It seems that you can't derive new widget types in gtk2hs, is that a correct assumption?
14:17:09 <elliott> hmm, it looks like hint doesn't support compilation (to bytecode) at all :( ... I guess that's to be expected from the name
14:21:06 <`Zerax`> sad
14:24:40 <Cale> elliott: Hrm... if you compile to object code first though, it will load the associated .o files.
14:24:53 <elliott> Cale: Yes, but that involves going via System.Process to GHC :-)
14:25:00 <elliott> I was trying to avoid such ugliness/overhead.
14:25:39 <Cale> Doesn't hint just do what GHCi does?
14:25:52 <Cale> (which is compile to bytecode?)
14:25:59 <ski> > ()
14:26:12 <elliott> Cale: Yes.
14:26:33 <elliott> Hmm.
14:26:39 <MHD0> ski: May I ask why you just evaluated the empty tuple?
14:26:45 <elliott> MHD0: to see if lambdabot is alive?
14:26:52 <hpc> hmm, is there any documentation on ghci's bytecode format?
14:26:54 <Cale> Probably to let me know that lambdabot isn't alive :P
14:26:55 <MHD0> elliott: cool
14:27:10 <elliott> Cale: I guess the essential problem is that I want to be able to use the same interpreted object in two different evaluations /without/ giving it a name (so it can't self-reference).
14:27:21 <Cale> your patch is in btw
14:27:25 <ski> Cale : well, she's only mostly dead
14:27:30 <Cale> yeah...
14:27:37 <Cale> It's still receiving messages
14:27:41 <ski> (she responded to a private query almost four hours after stating it)
14:27:46 <elliott> i.e. what I really want is something like "compile :: String -> (String, String)" which returns (specialNameForTheResult, typeString)...
14:27:56 <elliott> Cale: oh, is it in the running lambdabot?
14:27:59 <Cale> yeah
14:28:12 <elliott> so I really did break it this time :)
14:28:17 <Cale> Heh, maybe
14:28:28 <danlei> maybe a little ot: how to set the syntax type for code blocks in bitbucket (wiki/issues) to haskell?
14:28:45 <ski> (of course, the response was "Plugin `eval' failed with: thread killed")
14:28:51 <Cale> I don't know what's wrong, so I'm restarting
14:28:58 <Cale> > ()
14:29:01 <elliott> at least, the failures it's been getting don't _sound_ like things my patch could cause, so let's not think about that :-)
14:29:04 <Cale> oh...
14:29:10 <Cale> der...
14:29:15 <elliott> ohder
14:29:17 <ski> it may take a little while for her to rejoin all channels
14:29:22 <Cale> I didn't reinstall mueval
14:29:29 <elliott> heh
14:29:30 <donri> danlei: http://confluence.atlassian.com/display/BITBUCKET/Using+Syntax+Highlighting+on+your+Bitbucket+Wiki
14:29:51 <Cale> Had to replace a bunch of packages
14:29:56 <elliott> hmm... if only ghc let you turn off extensions for an expression
14:30:08 <elliott> I could turn on MagicHash, do: foo# = {-# WITHOUT MagicHash #-} expr
14:30:12 <elliott> and self-reference would be avoided! :)
14:30:30 <danlei> donri: #!haskell didn't work for me
14:31:01 <donri> danlei: and you put that on a new line inside a creole code block?
14:31:39 <danlei> donri: {{{\n#!haskell\n...
14:32:38 <donri> danlei: well i don't know then, that's what their own docs say
14:33:11 <danlei> donri: thanks anyway
14:34:34 <elliott> ahaha! all I have to do is get the type, and then do
14:34:45 <elliott> {-# ANN magic (expr) :: type #-}
14:34:47 <elliott> magic = undefined
14:34:50 <elliott> no self-reference :-)
14:35:58 <Axman6> danlei: what's the {{{ for?
14:37:02 <vrook> having trouble getting a latest binary ghc for mac 10.5. haskell-platform-2010.2.0.0.i386.dmg fails to install. http://www.haskell.org/ghc/download has a circular link to distributions packages -> mac -> download page again. "snapshot distributions" only contain windows and linux.
14:37:27 <elliott> vrook: fails to install how?
14:37:43 <elliott> vrook: http://www.haskell.org/ghc/dist/7.2.2/GHC-7.2.2-x86_64.pkg might be what you want
14:38:03 <elliott> vrook: (note that you'll need to trash any ~/.cabal and ~/.ghc you have)
14:38:06 <vrook> elliott: "The following install step failed: run postinstall script for 001-mtl-1.1.0.2. Contact the software manufacturer for assistance"
14:38:15 <elliott> ouch.
14:38:21 <elliott> hmm, wait
14:38:27 <elliott> was it mzero who posted those preview releases for the next HP for OS X?
14:38:42 * elliott wonders how stable those are
14:38:54 <vrook> elliott: that link is the source, right?
14:38:58 <elliott> 15:46:04 <mzero> I have release candidates of Haskell Platform 2011.4.0.0 for Mac OS X out if anyone wants to try 'em (32bit and 64bit, 10.6 and 10.7 only)
14:38:58 <elliott> 15:46:25 <mzero> http://www.ozonehouse.com/mark/platform/
14:38:58 <elliott> 15:46:50 <mzero> mind you - these are RC, so there still could be issues or problems
14:39:03 <elliott> you could try that
14:39:09 <elliott> vrook: no, that .pkg is the installer for GHC only (not the platform)
14:39:10 <elliott> for OS X
14:39:31 * mzero looks up
14:39:32 <elliott> oh, wait
14:39:34 <elliott> 10.6 only
14:39:36 <elliott> cancel that :)
14:39:42 <vrook> yeah i was about to say
14:39:50 <elliott> mzero: vrook is having problems with the latest HP installer on OS X, so I pointed him to the RCs you mentioned in case they might work
14:39:52 <mzero> exactly
14:39:59 <Axman6> anyone know what the best way to get GHc on SLES would be? there doesn't seem to be a platform binary for it (there is some mention for openSUSE however)
14:40:01 <mzero> he is on 10.5?
14:40:05 <elliott> yeah
14:40:14 <mzero> sigh - we don't support that well!
14:40:14 <elliott> actually
14:40:21 <elliott> I probably shouldn't link vrook to GHC 7.2 :)
14:40:26 <vrook> did I need to delete ~/.ghc and ~/.cabal before installing platform?
14:40:26 <elliott> http://www.haskell.org/ghc/dist/7.0.4/GHC-7.0.4-x86_64.pkg
14:40:36 <elliott> get that, that will make you happy, unless you can get the Platform working (which is preferable)
14:40:42 <elliott> vrook: probably
14:40:43 <mzero> that won't work on 10.5
14:40:48 <elliott> mzero: oh, oops
14:40:54 <elliott> I forgot OS X took ages to be 32-bit
14:40:54 <mzero> if it did, the HP would too!
14:40:58 <danlei> Axman6: beginning of the code block
14:41:08 <elliott> mzero: well it was .2 he was trying
14:41:12 <elliott> failing on some mtl thing
14:41:26 <mzero> ? what it's been 32 bit for ever, and 64 bit since Spring
14:41:33 <elliott> err
14:41:35 <elliott> to be 64-bit
14:41:36 <Axman6> danlei: what's it supposed to be?
14:41:37 <elliott> wow
14:41:41 <mzero> but 2010.2.0.0 is the only 10.5 supported version
14:41:49 <mzero> and only 32bit
14:41:51 <elliott> mzero: best just disregard everything I say, this is clearly a bad day for me :-)
14:41:52 <mzero> sigh
14:42:01 <elliott> mzero: yeah, but that doesn't work for him
14:42:05 <elliott> "The following install step failed: run postinstall script for 001-mtl-1.1.0.2. Contact the software manufacturer for assistance"
14:42:15 <mzero> sadly - GHC central hasn't built a version of GHC that runs on 10.5
14:42:15 <elliott> vrook: you uninstalled macports ghc beforehand, right?
14:42:19 <hpc> elliott: you should return it for a new one ;)
14:42:23 <vrook> elliott: yes
14:42:24 <elliott> mzero: oh, at all?
14:42:25 <mzero> In theory, you can build one yourself, and it will work
14:42:33 <elliott> even 7.0.3? huh
14:42:48 <mzero> that is - if you are on 10.5 and pull anything later than 7.2  from GHC, it should a) build, and b) work
14:42:54 <mzero> on 10.5, that is
14:43:00 <vrook> I deleted ~/.ghc and ~/.cabal and samme "mtl-..." error.
14:43:01 <elliott> vrook: the easiest thing might be to upgrade to 10.6 :p
14:43:17 <mzero> but - GHC central's builds so far have been done on 10.6 and without the proper flags to make them work on 10.5
14:43:28 <mzero> we hope to have this all sorted out for 7.4 / HP 2012
14:43:28 <donri> is there a way to see what header files / system libraries a cabal package requires / linked during build?
14:43:36 <mzero> but - sigh - that doesn't help vrook  for now
14:43:37 <danlei> Axman6: what do you mean? I want to format a haskell code block in the bitbucket issue tracker
14:43:39 <Axman6> heh, I love CSIRO's internet, downloading GHC at over 8MB/s
14:43:46 <elliott> mzero: "we'll have it sorted when even fewer people use 10.5" :-)
14:43:46 <singpolyma> what's wrong with this : instance Arbitrary (Tree (Node String)) where  -- ghc tells me I need -XFlexibleInstances
14:43:58 <mzero> vrook - deleting .ghc and .cabal isn't the best way to "clean up" anymore
14:43:59 <Axman6> danlei: oh, right. I thoguht it was in the haskell source. don't mind me =)
14:44:09 <danlei> Axman6: ah, ok :)
14:44:11 <elliott> singpolyma: put {-# LANGUAGE FlexibleInstances #-} at the top of your file
14:44:17 <elliott> singpolyma: unless you can make it Arbitrary (Tree a)
14:44:19 <donri> Axman6: I don't always download in 8MB/s, but when I do it's 4 MB/s slower than usual. :(
14:44:21 <elliott> which you probably can't
14:44:29 <vrook> I won't be using this machine much longer so I'm unmotivated to upgrade to 10.somethingelse.
14:44:32 <singpolyma> elliott: so what is wrong that I need that extension?
14:44:44 <elliott> singpolyma: Haskell 98 is really over-conservative about instance heads
14:44:48 <hpc> singpolyma: http://hackage.haskell.org/trac/haskell-prime/wiki/FlexibleInstances -- an explanation of the underlying problem is here
14:44:52 <elliott> singpolyma: ghc's error message tells you the exact form they have to have
14:44:56 <Axman6> donri: the best speed i've recorded on this link was over 300mbps
14:44:57 <hpc> singpolyma: flexible instances isn't generally considered evil
14:44:58 <mzero> I see - I don't have a good answer for you - if you can't run based on 2010.2.0.0 HP
14:45:01 <elliott> singpolyma: you shouldn't worry about using FlexibleInstances, it's completely fine
14:45:06 <mzero> other than, recompile GHC yourself
14:45:15 * mzero bows head in shame
14:45:15 <donri> Axman6: Ah. I'm capped at 100 mbps.
14:45:22 <hpc> singpolyma: overlapping instances is vaguely evil, and incoherent instances is a total loss of type-safety
14:45:37 <elliott> hpc: huh, how do you unsafeCoerce with incoherent instances?
14:45:38 <singpolyma> elliott, hpc: so, I read that page.  And the error.  I'm not sure I get it.  Is the problem that (Tree (Node a)) is too specific?
14:45:44 <vrook> Yeah, I expect to just recompile. Unfortunately I uninstalled my previous version. I think it's hours to compile on this machine.
14:45:47 <elliott> singpolyma: it's that (Tree (Node a)) doesn't look like (Tree a)
14:45:50 <elliott> Or (Tree b)
14:45:53 <elliott> or (Tree a b c d)
14:45:54 <elliott> basically
14:45:57 <donri> Axman6: It's my home connection FWIW.
14:45:58 <elliott> instance Foo (T a b c d e ...)
14:45:59 <elliott> is all you get
14:46:04 <elliott> and a b c d e MUST be type variables
14:46:07 <vrook> Do I remember a day of compiling ghc?
14:46:09 <Axman6> donri: pretty sure this is a 10Gbit link (so, obviously limited by the `1Gbit ethernet :P)
14:46:10 <elliott> anything beyond that requires FlexibleInstances
14:46:12 <singpolyma> elliott: oh, they can't be concrete types?
14:46:14 <singpolyma> weird
14:46:15 <elliott> vrook: it's more like 2, 3 hours
14:46:22 <elliott> singpolyma: yeah, it is weird, that's why everyone uses FlexibleInstances :)
14:46:50 <singpolyma> elliott: hmm, I'd really rather avoid language extensions, but maybe it's not such a big deal in my QuickCheck tests
14:46:50 <elliott> singpolyma: it's basically because it's dirt simple to implement
14:47:10 <elliott> singpolyma: language extension paranoia is counterproductive for such simple extensions as FlexibleInstances
14:47:29 <elliott> ExistentialQuantification sure, RankNTypes sure, GADTs sure, TypeFamilies sure, FlexibleInstances nah
14:48:00 <donri> i thought typefamilies were valid haskell98
14:48:05 <dmwit> no
14:48:08 <hpc> elliott: you lose type afety in the sense of not knowing which instance it will pick
14:48:12 <dmwit> I don't even think TypeFamilies are in 2010.
14:48:13 <elliott> hpc: ah
14:48:16 <hpc> elliott: so i suppose you lose "value safety"
14:48:16 <singpolyma> elliott: well, I'm not sure what the state of the haskell world is, but in every other language I've worked it, extensions can cause issues pretty quick :)
14:48:25 <elliott> dmwit: that's not saying much, since they're not in 98 :P
14:48:28 <dmwit> The theory behind type families is significantly deeper than the theory behind H98.
14:48:35 <elliott> singpolyma: it isn't really like that with haskell
14:48:42 <donri> oh, i misinterpreted a statement
14:48:46 <elliott> singpolyma: basically GHC likes to stay completely standard by default
14:48:49 <elliott> which is good
14:48:56 <donri> "a few programs will puzzlingly fail to compile with -XTypeFamilies even though the code is legal Haskell 98." I misread this
14:48:57 <dmwit> elliott: Huh? Why would saying "X is not in H2010" be meaningless given "X is not in H98"?
14:48:58 <elliott> singpolyma: but the haskell standard hasn't been significantly revised in 13 years
14:49:06 <elliott> singpolyma: and haskell coding has :)
14:49:15 <elliott> dmwit: well, 2010 didn't add much at all
14:49:18 <elliott> apart from the FFI
14:49:19 <singpolyma> elliott: well, almost completely.  I had to set -XHaskell98 to get fully standard behaviour from GHC, which seems undocumented
14:49:24 <elliott> certainly nothing as big as type families
14:49:30 <elliott> singpolyma: umm, haskell 98 is not the latest standard
14:49:31 <hpc> elliott: doesn't this technically mean haskell is more outdated than say... perl? :P
14:49:41 <elliott> singpolyma: and you'll be using very bad practices with -XHaskell98
14:49:46 <elliott> like non-hierarchical modules
14:49:47 <DanBurton> elliott: H98 is the latest "stable" standard. Or something like that
14:49:53 <elliott> DanBurton: no?
14:50:01 <singpolyma> elliott: which bad proctises?  the only newer one is 2010, and that's too new for stable code, normally
14:50:09 <dschoepe> DanBurton: Haskell 2010 is the latest one
14:50:13 <elliott> singpolyma: http://www.haskell.org/haskellwiki/Haskell_2010#Changes_since_Haskell_.2798
14:50:20 <elliott> singpolyma: Everything in Haskell 2010 has been supported for many, many years.
14:50:40 <DanBurton> "The latest major revision is still Haskell 98." http://hackage.haskell.org/trac/haskell-prime/
14:50:45 <elliott> DanBurton: that page is obsolete
14:50:52 <singpolyma> elliott: ghc by defaultc also allows DoIfThenElse, which is not in 2010, is it?
14:50:52 <hpc> singpolyma: there's a paper that gives a brief history of haskell that will be relevant to you, i think
14:51:02 <dmwit> Yeah, I don't think there's anything terribly controversial in H2010.
14:51:09 <elliott> singpolyma: DoIfThenElse is actually how Haskell 98 was always implemented.
14:51:09 <DanBurton> elliott: why haven't they updated it then?
14:51:10 <elliott> IIRC
14:51:16 <hpc> singpolyma: haskell has a history of being very liberal about what gets researched, and very conservative about what gets standardized
14:51:17 <Axman6> DoIfThenElse?
14:51:25 <elliott> I may be wrong
14:51:37 <DanBurton> it does mention Haskell 2010
14:51:48 <singpolyma> elliott: the parser (H98 compliant) used by hlint chokes on DoIfThenElse
14:51:53 <elliott> singpolyma: but anyway, the fact is that the only compiler anyone really uses is GHC. and while it's good to care about portability, a haskell compiler which does not support such rudimentary things as FlexibleInstances is useless by design
14:52:06 <hpc> singpolyma: search for "being lazy with class"
14:52:28 <singpolyma> elliott: are the pragmas for extensions standard?  or are they themselves a GHC thing?
14:52:41 <elliott> singpolyma: you can code strict Haskell98 if you want to, but your code won't be idiomatic, nobody will want to depend on your libraries (because of the haskell98 package dependency), and you'll tear your hair out trying to do some pretty basic stuff :P
14:52:52 <elliott> and the chances that all your dependencies are strict haskell98 too is ~0
14:53:01 <DanBurton> singpolyma: Haskell 2010 defines some pragmas iirc, such as SPECIALIZE
14:53:08 <elliott> singpolyma: they're a GHC thing, but I believe the other compilers that have implemented the same LANGUAGE extensions use the same names
14:53:19 <elliott> singpolyma: and the Haskell2010 process referred to proposed additions by their extension names
14:53:20 <singpolyma> hmm, ok
14:53:24 <hpc> singpolyma: a year or two ago, coding for haskell98 would have been a totally normal thing, because it more or less meant "not using extensions"
14:53:25 <elliott> so they're pretty official
14:53:31 <hpc> now, that would be haskell2010
14:53:31 <elliott> hpc: not true!
14:53:37 <elliott> hpc: everyone used hierarchical modules a year or two ago :)
14:53:42 <hpc> elliott: "more or less"
14:53:55 <DanBurton> http://www.haskell.org/onlinereport/haskell2010/haskellch12.html#x19-18800012
14:54:00 <DanBurton> ^ pragms
14:54:01 <vrook> http://www.haskell.org/ghc/dist/7.0.4/GHC-7.0.4-x86_64.pkg fails with the same "dyld: unknown required load command 0x80000022" symptomatic of 10.6 running on 10.5
14:54:04 <singpolyma> hpc, elliott: it's also common for C programmers to use C99 or even GNUC, but that dosen't mean I do it :)
14:54:26 <dmwit> singpolyma: The {-# LANGUAGE Foo #-} syntax is standardized; the meaning of particular LANGUAGE extensions is not, of course.
14:54:30 <companion_cube> what is wrong with C99?
14:54:45 <elliott> singpolyma: the difference is that (a) C99 is not that widely fully-implemented (b) the extensions GNU C adds are mostly trivial and easy to avoid (c) there are many practical C compilers
14:55:00 <singpolyma> elliott: agreed
14:55:21 <elliott> Haskell 2010 is trivial to implement in a Haskell 98 compiler, the extensions developed over time for Haskell are not so trivial as to be easy to avoid without pain, and there's really only one practical Haskell compiler (unfortunately)
14:56:17 <singpolyma> elliott: well, one compiler one interpreter, yes?  or is hugs dead?
14:56:34 <elliott> hugs is very dead
14:56:56 <elliott> yhc was the last other active compiler
14:57:00 <elliott> and it died
14:57:24 <singpolyma> interesting
14:57:52 <singpolyma> anyway, I guess I'll use the extension for now, and maybe revisit later when I understand QuickCheck better
14:58:46 <elliott> singpolyma: QuickCheck's extensions: GeneralizedNewtypeDeriving, MultiParamTypeClasses, Rank2Types, TypeOperators, whatever extensible exceptions require, I forget
14:58:54 <elliott> oh, and CPP
14:59:18 <dmwit> > cis pi
14:59:22 <singpolyma> elliott: sure
14:59:39 <dmwit> ?botsnack
14:59:46 <elliott> dmwit: Cale is reinstalling mueval iirc
14:59:50 <dmwit> aha
15:00:17 <vrook> What about uhc?
15:00:21 <vrook> anyone use it?
15:00:26 <elliott> oh, UHC might be developed, I don't know
15:00:29 <elliott> but I've never heard of anyone using it
15:00:46 <elliott> i guess utrecht people might :P
15:01:07 <Axman6> I havem to get haskell programs to run on the nintendo DS
15:01:24 <Axman6> hmm, i think it was uhc
15:01:26 <Axman6> maybe lhc
15:01:43 <elliott> is jhc still developed?
15:01:53 <Axman6> only as lhc i think
15:02:02 <Axman6> could be wrong, never really looked into it
15:02:04 <elliott> oh, I forgot LHC!
15:02:08 <elliott> LHC is GHC-based now though
15:02:16 <elliott> and I don't know if it's still developed
15:05:43 <blackdog> Axman6: didn't puffnfresh get that going?
15:05:50 <Axman6> yep
15:06:27 <dmwit> Can we just call our compilers by their first letter?
15:06:30 <dmwit> g, h, y, l
15:06:43 <dmwit> s/h/u/
15:06:44 <shachaf> q
15:06:51 <Axman6> "I'm a g man myself, others prefer h thought"
15:07:00 <vrook> the uhc trunk isn't very active. maybe there's another branch, though.
15:07:03 <Axman6> though*
15:07:12 <dmwit> "Didn't puffnfresh revive u?"
15:07:45 <koninkje> Does anyone know of a nice applet online which gives types for (simply-typed) terms?
15:07:47 <opqdonut> what about hugs???
15:07:50 <opqdonut> :P
15:08:09 <Axman6> that's h
15:08:11 <dmwit> koninkje: simply-typed, really?
15:08:20 <dmwit> (serious question)
15:08:34 <koninkje> dmwit: Or Hindley-Milner with the quantification left implicit
15:08:45 <parcs> >
15:08:49 <koninkje> it's for an intro class (for non computer scientists)
15:09:01 <dmwit> koninkje: tryhaskell.org will do :t
15:09:43 <koninkje> excellent!
15:09:59 <koninkje> dmwit++
15:10:40 <elliott> Man, all this karma being racked up while lambdabot is sleeping.
15:11:15 <Axman6> you call murder sleeping now?
15:11:21 <gtirloni> lambdabot is working business hours now or what?
15:12:01 <vrook> lambdabot is pining for the fjords
15:12:07 <vrook> that's all
15:12:11 <ddarius> Axman6: Taking a "dirt nap", "putting someone to sleep", I'm sure there are plenty of others.
15:12:12 <vrook> just pining
15:13:13 <dolio> Sleep with the fishes.
15:14:01 <vrook> elliott: did you notice my message that http://www.haskell.org/ghc/dist/7.0.4/GHC-7.0.4-x86_64.pkg is apparently for 10.6?
15:14:12 <gtirloni> eating grass by the roots (poor pt_BR to English translation)
15:14:16 <elliott> vrook: yeah. i replied and mzero gave advice
15:15:02 <elliott> vrook: basically on 10.5 you have very few options other than bootstrap-compiling a new GHC (which is not hard, but if you're not going to be using your machine long, you should probably just stick with macports' ancient version until you're on a platform that can get a newer ghc more trivially :))
15:16:02 <donri> i remember some documentation for common monad instances, much like typeclassopedia covers common classes; what might i be thinking of?
15:16:18 <dmwit> ?where all about monads
15:16:24 <dmwit> argh
15:16:40 <geheimdienst> donri: typeclassopedia does have some sections on common instances, not sure if that helps
15:16:53 <dmwit> http://mauke.dyndns.org/stuff/haskell/All_About_Monads.pdf
15:16:57 <dmwit> donri: That?
15:17:33 <donri> that's the one; much obliged
15:18:33 <donri> geheimdienst: your next wiki porting job!
15:21:52 <geheimdienst> :D
15:26:32 <donri> hm http://www.appropedia.org/Appropedia:Porting_PDF_files_to_MediaWiki
15:27:27 <vrook> elliott: oops, I missed that. It's surprising because the links for HP 2010.1.0.0 and HP 2009.2.0.2 explicitly say Leopard, yet both fail with 10.6-like errors. Shouldn't they just be removed?
15:27:59 <elliott> vrook: those might very well work on 10.5.
15:28:05 <elliott> dunno -- mzero seems to know more than me about GHC on 10.5 :-)
15:28:12 <vrook> HP 2010.2.0.0 as well
15:28:12 <vrook> I tried them all
15:28:22 <elliott> it's possible that there's some system-specific problem, that mtl thing is weird
15:28:23 <vrook> mzero: ping?
15:28:27 <elliott> but oh well
15:28:51 <elliott> I would personally try and bootstrap a new GHC, but that's not for the faint-of-heart, especially not if you'er not planning to use the machine long
15:28:52 <mzero> I'm sorry? vrook, what failures are you seeing? and which versions of OS/Xcode?
15:29:19 <geheimdienst> donri, i used the tex source (seemed easier than from the pdf). the process was kinda manual since inspecting all the text was necessary anyway (some modules are not anymore in the packages they were when it was published, links outdated, etc.)
15:29:24 <mzero> also - which processor?
15:29:40 <vrook> mzero: Xcode 3.1. Failures are "dyld: unknown required load command 0x80000022" which is symptomatic of 10.6 code running on 10.5.
15:30:13 <ddarius> +669-3
15:30:26 <mzero> hmmmm… I don't know how you could see that with 2010.2 or 2009.2
15:31:30 <donri> geheimdienst: yea i just thought a first step could be to get a gross approximation of wikimarkup that can then be proof-read
15:31:41 <mzero> well, maybe 2010.2
15:31:46 <geheimdienst> right, of course
15:31:50 <donri> of course the first step really is to get author approval / find the copyright
15:32:41 <donri> and i don't know if all about monads is considered to be of good quality or not; i just think something *like it* in some form would do good on haskellwiki, to completement the typeclassopedia
15:32:56 <mzero> vroom - what specific version of 10.5 are you running?
15:33:05 <mzero> is it at least 10.5.6?
15:33:14 <dmwit> I consider AAM to be of good quality.
15:33:28 <dmwit> It was immensely helpful to me, and several other people I have recommended it to have also enjoyed it.
15:33:32 <mzero> vrook: nevermind
15:33:35 <vrook> mzero: sorry, I didn't uninstall GHC-7.0.4-x86_64.pkg before trying the older GHC platforms
15:33:37 <donri> cool
15:33:46 <mzero> AH - that makes much more sense
15:34:06 <vrook> whatever the HS Platform installed, the GHC-7.0.4-x86_64.pkg path was still in precedence.
15:34:13 <mzero> though, you shouldn't need to uninstall…. a new install should just blow away the old symlinks in bin
15:34:35 <donri> what is this .pkg stuff you guys keep talking about
15:34:43 <mzero> Mac OS X installer packages
15:34:49 <donri> oic
15:34:53 <monochrom> the joy of mac
15:34:54 <mzero> which is how Haskell Platform is distributed for Mac OS X
15:35:15 <dmwit> Does the HP for Mac OSX include C dependencies?
15:35:22 <lambdabot> Plugin `dummy' failed with: thread killed
15:35:24 <elliott> i think so, yes
15:35:30 <elliott> lambdabot: shhhh
15:35:33 <mzero> I'm not sure what you mean by "C dependencies"
15:35:38 <elliott> lambdabot: it's okay
15:35:41 <monochrom> @botsnack
15:35:45 <donri> > ()
15:35:56 <donri> hey that almost looks like a fish
15:36:00 <dmwit> mzero: A colleague is having a hell of a time installing gtk2hs, not because the Haskell won't build, but because he can't get gtk2 installed.
15:36:05 <dmwit> That is what I mean by "C dependencies".
15:36:19 <mzero> dmwit:  I've NEVER been able to get gtk2 installed!
15:36:19 <dmwit> (Yes, I know gtk2hs isn't part of the HP.)
15:36:37 <mzero> gtk2 on Mac OS X is an orphan in sad sad shape
15:36:57 <mzero> but no, installing HP doesn't require any such shenanigans
15:37:25 <mzero> HP does include opengl support - and that has plenty of C dependencies when we(I) build HP for Mac
15:37:47 <mzero> but that has never been the source of our issues - it is the way GHC itself is built and linked
15:38:11 <mzero> coupled with Apple changing all the assumptions between 10.5 and 10.6 and then again with 10.7/Xcode4
15:39:03 <ageis> how can i get more info why i'm failing due to -Werror and not building a binary with -Werror disabled
15:39:15 <shachaf> mzero: Are there any plans for BayHac yet?
15:39:41 <mzero> only that we are targeting end of March early-April this year
15:40:06 <dmwit> mzero: "I've NEVER been able to get gtk2 installed!"
15:40:10 <dmwit> This makes me very sad.
15:40:38 <dmwit> What do people do if they want to develop a GUI that works on Mac?
15:40:48 <mzero> they cry
15:40:51 <dmwit> I thought gtk2hs was the defacto standard for GUIs in Haskell.
15:40:51 <elliott> Write Objective-C.
15:40:58 <elliott> And call Haskell from it, or so I gather.
15:41:02 <c_wraith> I've only ever run gtk2hs on os x. >_>
15:41:03 <mzero> yes - that
15:41:07 <elliott> gtk is no fun on OS X.
15:41:11 <elliott> wxWidgets is okay.
15:41:18 <dmwit> elliott: I mean, that's great and all, but I can't do that. I don't have a Mac.
15:41:21 <elliott> But not especially aesthetic.
15:41:25 <elliott> dmwit: yep :)
15:41:32 <mzero> you can get gtk2 on OS X running iff you don't build it -- if you find the magic installer for it - and just use it
15:41:49 <mzero> BUT the installers for the prebuilt versions don't include sourcepane or other such enhancements
15:41:51 <c_wraith> I built it.  It wasn't really that bad.
15:41:56 <mzero> I have NO IDEA how the Leksah people build it
15:42:43 <vrook> mzero: I verified that installing GHC-7.0.4-x86_64.pkg and then installing any of the three HP results in the old GHC-7.0.4-x86_64.pkg binaries staying around.
15:43:08 <elliott> vrook: you can uninstall .pkgs by finding the receipt files in some system directory
15:43:12 <elliott> and removing all those files
15:43:14 <dmwit> c_wraith: tell me more
15:43:17 <elliott> ugly, though :)
15:43:23 <dmwit> c_wraith: port didn't work; what did you use?
15:43:31 <c_wraith> dmwit: port, actually
15:43:35 <dmwit> ...
15:43:36 <dmwit> =/
15:43:36 <mzero> yes - I wouldn't expect them to remove the /Library/Frameworks/GHC.framework/Versions/7.0.4-x86_64 tree --- only to overwrite the symlinks in /usr/bin
15:43:41 <vrook> Right, I can uninstall them. -- The "bug" is that HP does not overwrite them or at least give a warning.
15:43:45 <vrook> if that is a bug
15:43:48 <dmwit> c_wraith: What version of perl is active?
15:43:49 <elliott> oh wait
15:43:53 <elliott> vrook: sorry, don't do that
15:44:00 <elliott> sudo /Library/Frameworks/GHC.framework/Tools/Uninstaller
15:44:01 <elliott> do that :p
15:44:05 <vrook> yes that's what I do
15:44:21 <mzero> HP intentionally doesn't overwrite or remove other versions of GHC
15:44:27 <vrook> The confusion arose when I forgot to do that.
15:44:43 <c_wraith> dmwit: 5.12.3 ..  I remember having to upgrade to that as part of the process.
15:44:44 <vrook> My suggestion is to give a warning, then.
15:45:03 <mzero> I have written a new, spiffy uninstaller for that - that can clean up Macs squeaky clean, (or partially clean if that is your wont) -
15:45:10 <vrook> I think it should be an error, actually. I can't imagine any circumstance where I install HP and don't want HP.
15:45:16 <dmwit> c_wraith: Okay, that's weird. Benjamin had 5.12, and it tried to deactivate it and activate 5.8 instead (which failed).
15:45:17 <mzero> I'd point you there….. but it won't run on 10.5 (ouch!)
15:45:30 <dmwit> c_wraith: Could you imagine a reason it would want to do that / a way to prevent it from wanting to do that?
15:45:38 <_Mikey> is llambdabot home?
15:45:46 <dmwit> _Mikey: Not right now.
15:45:49 <elliott> _Mikey: she's here, just not listening
15:45:56 <c_wraith> dmwit: no, I don't know that much about port
15:45:57 <mzero> (that is - the version I built won't run on 10.5 - the source is available and would run… but now we are in chicken-and-egg land!)
15:46:00 <_Mikey> aww
15:46:53 <mzero> llamabot?
15:46:58 <mzero> llambadabot?
15:47:09 <mzero> :-)
15:47:17 <vrook> gah, now I have dead symlinks.
15:47:46 <vrook> what does it install? Is /usr/bin/ghc* all of them?
15:47:48 <elliott> vrook: the OS Xperience!
15:48:27 <Axman6> @hoogle hex
15:48:30 <Axman6> gah!
15:48:34 <Axman6> >_______________________<
15:48:41 <elliott> we really can't function without lambdabot
15:48:50 <elliott> you'll all be dead within the week! mwahahahahahaahaha
15:51:23 <vrook> rm /usr/bin/*ghc* /usr/bin/cabal* -- anything else?
15:52:20 <vrook> Since HP does not overwrite, I need to remove everything.
15:53:22 <elliott> vrook: runhaskell
15:53:41 <acowley> Does anyone have a favorite priority queue library on hackage? I've used pqueue in the past, but it doesn't build on 7.2 so I figured I should see if there's anything new in that area.
15:53:54 <vrook> I found other stuff via ls -l | grep -i ghc
15:54:36 <mzero> crook - no - you need to find all symlinks that point into /Library/Frameworks/GHC.framework   do something like    cd /usr/bin; ls -1l | grep /Library/Frameworks/GHC
15:54:39 <elliott> acowley: I think edwardk has something for it.
15:54:49 <mzero> er, vrook
15:54:54 <elliott> (Surprising everyone immensely.)
15:54:55 <mzero> silly spelling corrector!
15:55:13 <elliott> Although I can't actually find it, so I might be wrong.
15:55:17 <acowley> I know he has a finger trees implementation, but I don't know what it's called
15:55:22 <vrook> mzero: that's what my grep did -- i think I got everything -- is /usr/bin/ the only install dir?
15:55:47 <ageis> anyone? how can i get more info about why my build is failing
15:55:47 <acowley> Oh well, I just patched pqueue to compile so I guess I'll stick with that
15:55:53 <mzero> GHC installs only /Library/Frameworks/GHC.framework   and then symlinks into /usr/bin
15:56:00 <elliott> acowley: Well, it's not fingertree-psqueue, although you might want to look into that one
15:56:05 <elliott> http://hackage.haskell.org/package/fingertree-psqueue
15:56:06 <ClaudiusMaximus> sigh, benchmarking a change in my code designed to make it faster - with integer-gmp it makes my program 3x faster in case A and no change in case B, but with integer-simple it's 1.7x faster in case A and 45x *slower* in case B
15:56:09 <mzero> old HP installed into /Library/Frameworks/HaskellPlatform.framework
15:56:10 <vrook> mzero: k, thanks.
15:56:16 <mzero> new HP installs into /Library/Haskell
15:56:28 <elliott> acowley: Ah: http://hackage.haskell.org/package/heaps
15:56:43 <elliott> ClaudiusMaximus: You use integer-simple?
15:56:51 <elliott> I thought only ARM people used that.
15:57:06 <elliott> Although I suppose you might be an ARM person :P
15:57:10 <mzero> vrook:  you can't run any Haskell code, can you?
15:57:26 <vrook> mzero: nope, just dead symlinks.
15:57:39 <acowley> elliott: thanks, I'll give that a try!
15:57:46 <elliott> np :)
15:57:48 <ClaudiusMaximus> elliott: not arm, it's the other reason: hmpfr - mfpr - gmp   -vs- ghc gc
15:57:56 <elliott> ClaudiusMaximus: Ah.
15:57:56 <mzero> still - I'm surprised, HP has been happily over-writing those symlinks since I took it over
15:58:21 <elliott> ClaudiusMaximus: It would be nice if GHC worked with stock gmps so that problem didn't exist.
15:58:56 <hpaste> ageis pasted “tordnsel fail” at http://hpaste.org/54894
15:59:08 <ageis> can someone look at that for me
15:59:23 <ageis> ah i should do with Werror off
15:59:31 <vrook> mzero: did you take over after 2009.2.0.2 and 2010.1.0.1?
15:59:43 <mzero> yes
15:59:55 <vrook> then why the surprise?
15:59:55 <ClaudiusMaximus> elliott: well, anything that lets me use mpfr without segfaults or really really slow integers would be nice
16:00:16 <elliott> ClaudiusMaximus: Wasn't copumpkin working on something?
16:00:24 <hpaste> ageis pasted “tordnsel fail 2” at http://hpaste.org/54895
16:00:37 <copumpkin> yeah, but I got frustrated and put it off
16:00:44 <copumpkin> I know what to do but it's a pain
16:01:06 <mzero> vrook: I took over with 2011.2.0.0
16:01:53 <mzero> which was a total re-write of the HP for Mac OS X installer, and a major change in installed layout (to help alleviate these kinds of problems going forward)
16:02:54 <mzero> vrook: the surprise is I didn't think the symlink code did anything like look to see if there was something there already - I was pretty sure it was a sort of blind overwriting script
16:06:31 <gripz> Good evening. I am currently eating my way through the Learn You A Haskell handbook. Whenever I try to do a challenge before seeing the solution, I feel like a fucking retard. Is that normal?
16:07:28 <mzero> gripz: we all felt like we were fumbling around in the dark our first time through!
16:07:53 <mzero> don't worry - at some point it will start to click...
16:08:06 <mzero> you have some prior coding experience, yes?
16:08:16 <gripz> Yeah… c++ and Java
16:08:24 * hackagebot twitter-enumerator 0.0.1 - Twitter API package with enumerator interface and Streaming API support.  http://hackage.haskell.org/package/twitter-enumerator-0.0.1 (TakahiroHimura)
16:08:43 <geheimdienst> gripz: it gets easier over time :) the thing that helped me the most was writing code
16:08:45 <_Mikey> fumbling around in the dark?
16:08:46 <shachaf> gripz: You'll get used to it. :-)
16:08:52 * shachaf purposefully keeps "it" ambiguous.
16:08:53 <_Mikey> I felt like someone flushed me down the toilet
16:08:54 <_Mikey> -.-
16:09:11 <mzero> then yes, gripz, expect to feel like you have a case of the dumbs for awhile ---
16:09:25 <mzero> but keep at it - it will improve your C++ and Java coding once you start to get it
16:09:26 <shachaf> YOU ARE EDUCATED STUPID
16:09:32 <shachaf> FOUR SIMULTANEOUS etc etc.
16:09:59 <Axman6> gripz: the learning curve is steep, but oh so worth the climb. there's a reason stuff from Haskell keeps getting stollen in Java and C++ (like C++'s optional in Boost (i think that's what they call it), and generics in Java)
16:10:20 <Axman6> and C# also has plenty of stuff from Haskell peeps these days too
16:10:29 <mzero> and, gripz, we're here for you - this is the nicest IRC channel you'll ever find
16:10:34 <vrook> Ha, HP 2010.2.0.0 has a later ghc than macports. No need to compile after all.
16:10:41 <Phyx-> Axman6: yeah, but with odd names :P
16:10:49 <gripz> Well Thank You everyone for the words of encouragement. I will definitely not give up :D
16:11:12 <Axman6> whoot, I love it when something you didn;'t think would work does :D
16:11:13 <shachaf> gripz: Remember, nubBy(((>1).).gcd)[2..]
16:11:35 <Axman6> managing to talk to a power meter connected to a server using haskell over a serial connection
16:11:44 <shachaf> gripz: Feel free to ask in the channel if you have any questions.
16:11:50 <byorgey> Axman6: nice =)
16:12:02 <Axman6> "<01S;00B4\r"
16:12:02 <Axman6> ">01S,0,0,95338,12824320316,165040,250274000,722200,0,913030,180768;0CC7\r"
16:12:08 <Axman6> it's beautiful!
16:12:14 <gripz> Thanks Shachaf. I don't know what that secret code meant. Nubby isn't in scope though
16:12:17 <byorgey> Axman6: so now you can write a Haskell program to tell you when your refrigerator is running?
16:12:20 <Phyx-> I don't speak gibberish!
16:12:21 <Phyx-> :P
16:12:34 <Axman6> luckily the manufacturer was happy enough to send me their entire protocol
16:12:43 <byorgey> gripz: import Data.List  to get nubBy
16:12:45 <shachaf> gripz: It's case-sensitive, and it's probably in Data.List.
16:12:56 <byorgey> > nubBy(((>1).).gcd)[2..]  -- secret code
16:13:06 <monochrom> "four simultaneous compiler stages: lexer, parser, optimizer, code generator" :)
16:13:09 <byorgey> oh, no lambdabot? =(
16:13:09 <Axman6> gripz: it's 'nub By'
16:13:18 <shachaf> Oh, no, lambdabot!
16:13:29 <monochrom> yeah, lambdabot has the flu
16:13:45 <luite> invite diabot! he's much better anyway
16:13:46 <Axman6> gripz: if lambdabot was around, we'd show you what it does. but since it isn't, i'll just tell you that it computes an infinite list of all prime numbers
16:13:49 <gripz> oh. Haha. I get it. Because I'm a piece of shit and that's not going to stop running
16:14:19 <byorgey> > nubBy(((>1).).gcd)[2..]
16:14:22 <monochrom> what does diabot do? how to use it?
16:14:24 <diabot>   mueval-core: Time limit exceeded
16:14:24 <Phyx-> I can't follow this conversation at all
16:14:32 <byorgey> monochrom: it's a fork of lambdabot
16:14:38 <byorgey> > nubBy(((>1).).gcd)[2..]
16:14:39 <monochrom> @botsnack
16:14:39 <diabot> :)
16:14:41 <shachaf> > 1 + 1
16:14:41 <diabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
16:14:42 <diabot>   2
16:15:01 <monochrom> @quote
16:15:01 <diabot> No quotes yet.
16:15:03 <Axman6> byorgey: more like i can write a program to get the power usage of this server node i'm working on, which will be used for some power benchmarking of these supersomputers I'm working on
16:15:10 <byorgey> monochrom: I'm adding some diagrams-specific stuff to it, but for the moment it can serve as a temporary lambdabot replacement
16:15:21 <byorgey> Axman6: ah, I see =)
16:15:44 <gripz> One day, I hope to work on supercomputers
16:15:46 <monochrom> diagrams-specific stuff means I can enter drawing commands and it will emit SVG code?!
16:15:58 <Axman6> now I need to decode those lines of gibberish
16:16:05 <byorgey> monochrom: which it will upload to a server and give you a short url, yes
16:16:20 <monochrom> ok, that's better than emitting SVG code right here
16:16:25 <byorgey> agreed =)
16:16:42 <mzero> gripz: you already do! Your smart phone has more compute power than the most powerful supercomputers did when I went to school!!!!
16:17:03 <monochrom> you went to school a long time ago
16:17:08 <Axman6> the iPad 2 is more powerful than tha Cray 1 (2? can't remember)
16:17:10 <gripz> ouch man that was kind of cold
16:17:13 <Axman6> the*
16:17:18 <dbelange_> wow man you're old
16:17:21 <monochrom> but then maybe I did, too
16:17:58 <geheimdienst> the takeaway here is of course that somehow steve jobs was the greatest human that ever lived
16:18:05 <geheimdienst> uh wait
16:18:18 * monochrom hasn't worked with punch cards, but has had mid-aged professors who did.
16:18:36 <gripz> I don't appreciate your sarcasm, geheimdienst. I'm trying to learn Haskell right now.
16:18:53 <dbelange_> steve payton-jobs
16:19:08 <monochrom> haha
16:19:19 * ezyang starts paying attention to #haskell, and is very confused. 
16:19:20 <diabot> ezyang: You have 1 new message. '/msg diabot @messages' to read it.
16:19:22 <Axman6> dbelange_: that would be an interesting mix
16:19:25 <Phyx-> he would have been greater, if he was named Simon :P
16:19:30 <mzero> grey pride!!!
16:19:40 <shachaf> ezyang: Confused? Don't be! Your regularly-scheduled zygohistmorphisms will be back shortly.
16:19:45 <Phyx-> ezyang: so am I.. i've been looking for 10mins
16:19:48 <mzero> I coded on punch cards
16:20:06 <ezyang> From the bot: [_____ said 1y 3m 10d 22h 52m 17s ago]. "Wow, that's a really late message"
16:20:21 <Phyx-> lol
16:20:22 <byorgey> oh, hehe
16:20:34 <dbelange_> So I've been thinking of writing a monad tutorial, is there any interest?
16:20:36 <Phyx-> better late than never
16:20:41 <gripz> Oh god yes
16:20:51 <mzero> "It's a trap!!!"
16:20:53 <gripz> Please tell me what the fuck a monad is.
16:20:53 <ezyang> dbelange_: Oh no, not you too!
16:20:54 <byorgey> it's basically whatever was in the tell database the last time the lambdabot repo was snapshotted
16:21:08 <shachaf> gripz: Please don't encourage people to write new monad tutorials. :-(
16:21:15 <dbelange_> Here's the premise: functions are brothels, monads are AIDS
16:21:21 * shachaf sighs.
16:21:35 <shachaf> I get kmc's point. This person is actually being serious for once.
16:21:36 <monochrom> how do I convert IO String to IO?
16:21:38 <byorgey> wtf
16:21:40 <DanBurton> wait who is diabot?
16:21:41 <gripz> Maybe his will actually make sense
16:21:41 <roconnor> dbelange_: what are the T-Cells?
16:21:51 <mzero> (filling in for the missing lambdabot's quote db)
16:21:52 <mzero> kmc: a monad is like an invisible train filled with jello traveling backwards in time
16:22:09 <dbelange_> once you've been to a brothel, you have aids
16:22:16 <mzero> gripz: really, don't worry about the monads for now...
16:22:16 --- mode: ChanServ set +o copumpkin
16:22:16 <dbelange_> but you can't get aids more than once
16:22:21 <shachaf> copumpkin++
16:22:24 <mzero> gripz: just keep plowing through LYAH
16:22:26 <roconnor> mzero: you need mfix to travel backwards in time
16:22:27 --- mode: ChanServ set +q *!*@taurine.csclub.uwaterloo.ca
16:22:31 --- mode: copumpkin set -o copumpkin
16:22:41 <shachaf> gripz: "Monad" is a generic abstraction for a generic thing. It's probably best not to worry about what it means exactly right now.
16:22:52 <shachaf> gripz: You can do IO and so on without "understanding what a monad is".
16:22:57 <acowley> "IO String -> IO" is awesome
16:22:58 <shachaf> gripz: See also the FAQ.
16:23:00 <shachaf> @where faq
16:23:05 <byorgey> DanBurton: diabot is mine, it's a fork of lambdabot, just filling in temporarily while lambdabot is away
16:23:09 <geheimdienst> copumpkin: without any warning? :-o
16:23:10 <irene-knapp> acowley: not well-kinded :D
16:23:14 <gripz> @where faq
16:23:16 <acowley> it's not well-anything!
16:23:18 <roconnor> @where lambdabot
16:23:18 <diabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
16:23:20 <copumpkin> geheimdienst: weve had dealings before
16:23:22 <irene-knapp> yes, indeed
16:23:26 <shachaf> gripz: http://www.haskell.org/haskellwiki/FAQ
16:23:27 <geheimdienst> copumpkin: oh i see
16:23:28 <DanBurton> byorgey: nice
16:23:37 <shachaf> gripz: In particular section 8.
16:23:39 <gripz> I'm confused on what the hell that is. But Question. How can I make my application without using Monads.
16:23:39 <Axman6> gripz: monads are one of those things that are much easier to use than understand initially.
16:24:07 <shachaf> gripz: You mean "without thinking about the Monad class"?
16:24:09 * monochrom 's opinion is that there is nothing to "understand"
16:24:17 <Axman6> well, if it needs input or output, you can't. but that's ok, they're simple enough to use for IO
16:24:17 <geheimdienst> monochrom++
16:24:27 <shachaf> gripz: Just don't think about it. :-) Is your issue with being unable to do IO?
16:24:31 <DanBurton> monochrom: *feel* the monad, *be* the monad
16:24:33 <elliott> gripz: You'll have a lot more difficulty deliberately avoiding monads because they're "hard" than you will just discarding your preconceptions and writing things the easiest way :)
16:24:38 <gripz> Thank you everyone for calming down my fears of Monads
16:24:38 <shachaf> DanBurton: Sigh...
16:24:51 <shachaf> gripz: If so, focus on doing IO in Haskell. You don't need to know what "Monad" means in order to do IO.
16:25:01 <elliott> Maybe we should get rid of the "BEWARE OF THE MONAD" sign.
16:25:07 <Axman6> gripz: http://random.axman6.com/blog/?page_id=70 try that
16:25:29 <gripz> Will I should be able to make that Twitter client without Monads?
16:25:37 <roconnor> OTOH, if you want to build well-structured and useful data structures, you might want to know what a Monad is.
16:25:39 <mzero> gripz: Monad is just a really useful thing in the standard library - turns out IO is built on it… really, don't worry, it isn't mystical, it isn't magic, and it isn't even built in (only syntactic sugar for it is)
16:25:43 <geheimdienst> gripz: right, calming down any fears is definitely the right approach. imho Monad is just a typeclass with 3-4 functions, it's used a fair bit in the standard library, that's it basically *shrug*
16:25:57 <mzero> geheimdienst: +1
16:25:59 <monochrom> monad is right up there with arrays, numbers, functions, points and lines (in Euclid's sense). nothing to "understand". not even definitions "point = ___, line = ___, numbers = ___". you just use them.
16:26:37 <Phyx-> geheimdienst++
16:26:39 <mzero> gripz: have you used lists and Maybe yet in LYAH?
16:26:47 <DanBurton> @google monica monad
16:26:48 <diabot> http://www.haskell.org/haskellwiki/Haskell_logos/New_logo_ideas
16:26:48 <diabot> Title: Haskell logos/New logo ideas - HaskellWiki
16:26:51 <gripz> thanks y'all I'm going to finish eating the book.
16:27:22 <gripz> mzero, Nah I was just studying Guards
16:27:29 <DanBurton> Monads are not scary, see? http://www.haskell.org/haskellwiki/Image:Monica_monad_falconnl.png
16:27:43 <DanBurton> They are warm fuzzy things :)
16:27:44 <monochrom> haha cute neat
16:27:47 <mzero> k - go back to the book - we'll talk Monads later
16:27:58 <shachaf> mzero: That looked a lot like a NetHack inventory line...
16:27:59 <gripz> DanBurton keep that creature away off my screen man! =D
16:28:16 <shachaf> Can we make monad jokes illegal for a while?
16:28:29 <DanBurton> shachaf: then what would we talk about?
16:28:51 * DanBurton starts thinking of other jokes. Hm...zippers...lenses...bananas...
16:28:51 <shachaf> Axman6: Your IO introduction is misleading.
16:28:54 <mzero> shoes, and ships, and sealing wax -- and cabbages and kings
16:28:58 * geheimdienst makes jokes about monad jokes illegal
16:29:05 <monochrom> some tutorials are unhelpful because they try to answer "monad = ___" just because people foolishly ask "monad = ?". the right approach is to refuse to answer that. it's why in my arrow tutorial I put it up front, "what are arrows? I won't answer that, waste of time".
16:29:08 <mzero> and why the sea is boiling hot, and whether pigs have wings
16:29:14 <shachaf> Axman6: "What happened there? Well the first thing was str <- getLine, doing this took the string out of the IO String that is getLine."
16:29:39 <shachaf> Axman6: "What this is saying is that putStrLn takes a string, and gives you nothing back"
16:30:35 <shachaf> "When we start working in IO, we’re kind of stuck in IO."
16:30:53 <shachaf> "boxed up Integer" etc.
16:31:11 <Axman6> yep
16:31:14 <Jafet> @quote IO.monad
16:31:14 <diabot> No quotes yet.
16:31:31 <Axman6> because I found it useful for bootstrapping how I learnt to use monads. I never pretended to be accurate
16:31:34 <roconnor> @quote maiden
16:31:34 <diabot> No quotes yet.
16:31:43 * shachaf "getLine :: IO String contains a String in the same way that /bin/ls contains a list of files"
16:31:59 <Axman6> @hoogle forM_
16:32:00 <diabot> A Hoogle error occurred.
16:32:06 <Axman6> -_-
16:32:07 <shachaf> Axman6: But unhelpful analogies are less helpful than nothing. :-(
16:32:14 <monochrom> IO String contains a String in the same way that US Economy contains an economy :)
16:33:01 <Phyx-> @pl \x->x
16:33:02 <diabot> id
16:33:21 <irene-knapp> monochrom++
16:33:24 * hackagebot gruff 0.3.1 - fractal explorer GUI using the ruff library  http://hackage.haskell.org/package/gruff-0.3.1 (ClaudeHeilandAllen)
16:33:26 * roconnor "getCurrentDirectory >>= getDirectoryContents :: IO [FilePath] contains a list of files in the same way that /bin/ls contains a list of files"
16:33:27 <DanBurton> monochrom++
16:33:39 <Axman6> shachaf: i disagree
16:33:50 <geheimdienst> how do i get the economy out of the US?
16:34:00 <irene-knapp> geheimdienst: gold
16:34:07 <DanBurton> geheimdienst: Fire ze missiles!
16:34:09 <shachaf> Axman6: http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
16:34:13 <Phyx-> monochrom++
16:34:28 <monochrom> thank you all! :)
16:34:33 <Phyx-> geheimdienst: look in china :P
16:34:44 <RomyEatsDrupal> :(
16:34:50 <Axman6> shachaf: you seem to have missed the point of the tutorial. it is not to teach monads, it is to get people to the point where they can do basic IO, without having to worry about what a monad is
16:34:54 <RomyEatsDrupal> oops, pardon me!  wrong room!
16:34:57 <roconnor> If I click on this reddit link about the game of life in Haskell, will it say comonad?
16:35:18 <vrook> I installed Monad.Random with this new haskell platform, but ghc can't find it. Any suggestions?
16:35:30 <Axman6> vrook: how did you install it?
16:35:41 <shachaf> Axman6: Right. I din't bring up the M-word.
16:35:49 <vrook> cabal cabal install MonadRandom
16:35:55 <vrook> one cabal
16:36:05 <vrook> it installed successfully, no errors
16:36:17 <shachaf> Axman6: I think that as-a-way-of-figuring-out-IO-in-Haskell this approach is unhelpful. Nothing to do with monads.
16:36:31 <acowley> vrook: when you say ghc can't find it, do you mean ghc or ghci?
16:38:08 <vrook> acowley: ghci. actually your comment tipped me off -- this is ghci in emacs, so I need to quit the ghci instance and reload.
16:38:18 <vrook> (works now)
16:38:20 <acowley> vrook: that's exactly what I suspected :)
16:38:30 <Axman6> shachaf: then write something better. Plenty of people have told me they found it quite useful, for the purpose it was designed for.
16:38:55 <vrook> that problem makes me miss SLIME
16:39:55 <acowley> vrook: the frustrating thing about that one is that I think it's fixable without doing anything horrifically un-Haskelly
16:40:02 <shachaf> Axman6: I don't want to populate the world with even more IO introductions. :-(
16:40:06 <shachaf> There is already http://haskell.org/haskellwiki/Introduction_to_IO
16:40:07 <acowley> it's not like you're replacing an implementation in GHCi
16:41:11 <Axman6> argh, using vim over ssh makes me miss TextMate even more >_<
16:41:11 <vrook> acowley: is it just the directory or index file being cached?
16:41:33 <Axman6> are there any must have extension things for vim for working in Haskell?
16:41:43 <acowley> vrook: That's what I'm guessing. If I was a good person I'd investigate the code.
16:42:01 <lambdabot> Plugin `dummy' failed with: thread killed
16:42:33 <monochrom> ghci certainly does not re-poll the package database for newly appearing packages
16:42:55 <monochrom> if you think ghc knows its packages by scanning directories, you're wrong.
16:44:01 <mlb-> well holy shit. It's a small world. Axman6: I use your irssi-growl script. Lovely work
16:44:32 <Axman6> heh, thanks
16:45:13 <Axman6> that about a day's work, porting the one that used to come with growl to use Growl::Net. It's the only perl i've ever written :P
16:45:26 <Axman6> pretty sure it doesn't work with the latest Growl
16:45:49 <irene-knapp> yeah, but who wants the latest Growl :(
16:45:52 <mlb-> haha, that's probably why it's so legible. I'd be scared to see what it'd look like if you'd been used to writing perl ;]
16:46:06 <irene-knapp> I would probably have willingly paid $5 or whatever the guy is asking for it
16:46:13 <Axman6> patches more than welcome btw!
16:46:15 <irene-knapp> if it didn't annoy me every hour or so telling me there's a paid upgrade
16:46:30 <mlb-> oh what? Growl's nagware now?
16:46:32 <irene-knapp> yeah :(
16:46:36 <irene-knapp> well, old versions of it are
16:46:41 <irene-knapp> the current is sold through the App store only
16:46:50 <Axman6> irene-knapp: there's no real need to upgrade. Apps can stull use the latest growl, the paid one is just like Growl Pro
16:47:02 <irene-knapp> yes, there WOULD be no real need to upgrade
16:47:07 <mlb-> this is news to me! Unfortunate news!
16:47:12 <irene-knapp> except there's no way to block the damn ads
16:47:31 <irene-knapp> somebody forked it, since it was open-source heh
16:47:41 <irene-knapp> but I think the new version changed the wire protocol, right
16:47:49 <irene-knapp> so "good luck with that"
16:48:20 <Axman6> yeah
16:48:33 <mlb-> ah, new protocol? Screw that.
16:48:35 <irene-knapp> yeah :(
16:48:42 <irene-knapp> claims API compatibility
16:48:44 <irene-knapp> or something
16:48:55 <irene-knapp> I didn't really read past the part where it was all "we changed it totally and now we want your money"
16:49:35 <mlb-> make a popular fork called "Purr" and not that it doesn't make noises demanding money :P
16:49:41 <mlb-> s/not/note/
16:49:41 <irene-knapp> haha nice
16:50:43 <mlb-> hmm, maybe I ought to play with the irssi bit and see if growl for windows uses the same protocol/port...
16:51:01 <irene-knapp> hmmmmm
16:52:55 <siasia> hi there
16:53:11 <Axman6> 'lo siasia
16:53:22 <siasia> does anyone encountered any problems with sending signals from ghci?
16:53:36 <siasia> not working for me
16:53:46 <siasia> I mean posix
16:54:52 <hpaste> werbitt pasted “map” at http://hpaste.org/54896
16:54:56 <werbitt> hi, can anyone help me understand why the map implementation using foldr in that hpaste works, but the one using foldl doesn't?
16:55:34 <irene-knapp> I was going to make a snarky response about the signals not being properly melodic, so the aliens couldn't understand them, until I realized you weren't being purposefully vague :)
16:58:03 <Jafet> Send -9 to outer space
16:58:16 <vrook> werbitt: (:) :: a -> [a] -> [a]
16:58:32 <vrook> colon is for <element> : <list>
16:59:09 <werbitt> oh right, thanks
16:59:21 <irene-knapp> Jafet: I was going for Close Encounters, but oaky :)
16:59:23 <irene-knapp> *okay
16:59:49 <werbitt> vrook++
16:59:58 <Jafet> We could go over to SDF Macross.
17:00:04 <irene-knapp> true!
17:00:27 <fullofnoob> Can someone help me parse a line comment with parsec?
17:00:33 <gripz> Yea shore.
17:00:40 <fullofnoob> I tried - skipChar lineCommentChar >>. skipRestOfLine
17:00:55 <fullofnoob> (actually, this is FParsec, but F# channel is a little silent)
17:01:10 <fullofnoob> I'm just trying to combine two skip operations, basically
17:01:37 <siasia> any insight bout my question? :)
17:05:56 <ehuber> my everything is sore and broken
17:06:01 <ehuber> oops :D
17:18:42 <Apocalisp> @type foldr'
17:18:44 <diabot>     Not in scope: `foldr''
17:18:45 <diabot>     Perhaps you meant one of these:
17:18:45 <diabot>       `BS.foldr'' (imported from Data.ByteString),
17:19:06 <Apocalisp> is there a tail-recursive right fold?
17:19:35 <Axman6> I don't believe such a thing can exist
17:19:50 <Axman6> > foldr f z [a,b,c] :: Expr
17:19:52 <diabot>   f a (f b (f c z))
17:20:21 <Axman6> also, the ' in foldl' means it's strict, not that it's tail recursive (it just happens to be)
17:20:27 <DanBurton> Apocalisp: right fold is lazy, so why care if it is tail recursive?
17:20:32 <DanBurton> @src foldr
17:20:32 <diabot> foldr f z []     = z
17:20:32 <diabot> foldr f z (x:xs) = f x (foldr f z xs)
17:20:43 <jerry> guys can anyone try to give me brief difference between data vs newtype
17:20:52 <Apocalisp> @let foldr' f z xs = foldl (flip f) z (reverse xs)
17:20:53 <diabot>  Defined.
17:20:57 <Apocalisp> @type foldr'
17:20:58 <diabot> forall a b. (b -> a -> a) -> a -> [b] -> a
17:21:01 <hpc> jerry: 'data' is like struct in C
17:21:03 <Apocalisp> yay
17:21:19 <hpc> jerry: 'newtype' is like typedef, only the compiler actually recognizes it
17:21:25 <mauke> hpc: awful
17:21:48 <Axman6> jerry: data lets you define a new kind of data, with as many constructors as you like. newtype is basically used as a typesafe way to tag an existing type as something else, without any runtime overhead
17:21:53 <Draconx> "type" is similar to C's typedef.  "newtype" is nothing like typedef.
17:21:58 <jerry> hpc: there is difference also that data can have more then one constructor right?
17:22:03 <hpc> jerry: a less crappy explanation can be found here:
17:22:05 <hpc> http://learnyouahaskell.com/functors-applicative-functors-and-monoids#the-newtype-keyword
17:22:08 <hpc> jerry: yeah
17:22:12 <mauke> jerry: 'data' creates a new type, 'newtype' sort of creates a new type (but one that is internally identical to an existing type)
17:22:42 <jerry> mauke: how can you create new type using existing type
17:22:55 <jerry> mauke: how do you create Person using existing type?
17:23:03 <mauke> newtype Person = P Int
17:23:15 <mauke> now Person is internally just an Int
17:24:32 <kfish> hi Bynbo7
17:25:47 <copumpkin> I think Bynbo7 is the only person who still uses a map succ nick
17:25:51 <copumpkin> > map succ "copumpkin"
17:25:52 <diabot>   "dpqvnqljo"
17:25:57 <copumpkin> see, mine doesn't work as well
17:26:26 <mauke> > succ . "mauke"
17:26:27 <diabot>   Couldn't match expected type `a0 -> c0'
17:26:27 <diabot>              with actual type `[GHC...
17:26:32 <mauke> terrible
17:26:53 <copumpkin> lol
17:26:54 <hpc> > map succ hpc
17:26:55 <diabot>   Not in scope: `hpc'
17:27:02 <hpc> > map succ "hpc"
17:27:03 <diabot>   "iqd"
17:27:14 <copumpkin> :t (.)
17:27:15 <diabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
17:27:18 <copumpkin> it got reverted!
17:27:21 <copumpkin> Cale!!!1!!!
17:27:23 <rwbarton> byorgey++
17:27:26 <hpc> diabot got reverted
17:27:32 <Cale> wat
17:27:32 <preflex>  Cale: you have 2 new messages. '/msg preflex messages' to read them.
17:27:39 <Cale> oh, I can fix that
17:27:41 <copumpkin> Caleskell is no more!
17:27:44 <copumpkin> :t flip
17:27:44 <diabot> forall a b c. (a -> b -> c) -> b -> a -> c
17:27:47 <copumpkin> WTF!!!1!!
17:27:50 <copumpkin> it makes sense
17:27:50 <copumpkin> fix it
17:28:00 <hpc> @let flip = const
17:28:01 <diabot>  <local>:1:24:
17:28:02 <diabot>      Ambiguous occurrence `flip'
17:28:02 <diabot>      It could refer to either...
17:28:12 <hpc> aw, that would have fixed it ;)
17:28:17 <copumpkin> yeah, that doesn't work as well
17:28:21 <Cale> oh, L.hs is still there, it's just not using it?
17:28:24 <Cale> hum
17:28:32 <irene-knapp> > map succ "irene-knapp"
17:28:33 <diabot>   "jsfof.lobqq"
17:28:35 <irene-knapp> hm.
17:28:37 <irene-knapp> not very phonetical.
17:28:43 <parcs> > 1 1
17:28:43 <diabot>   1
17:28:47 <mauke> > map pred "irene-knapp"
17:28:47 <diabot>   "hqdmd,jm`oo"
17:28:51 <Cale> er, weird
17:28:53 <Cale> @undefine
17:28:58 <Cale> :t (.)
17:28:58 <irene-knapp> wait, how does > 1 1 work?
17:28:59 <diabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
17:29:00 <kulakowski> \msg diabot map succ "kula"
17:29:03 <Cale> hrm
17:29:11 <copumpkin> instance Num b => Num (a -> b) -- irene-knapp
17:29:13 <mauke> irene-knapp: instance (Num a) => Num (e -> a)
17:29:19 <irene-knapp> hm
17:29:21 <irene-knapp> interesting
17:29:25 <parcs> fromIntegral = const
17:29:33 <mauke> irene-knapp: you can turn any Applicative into a Num
17:29:34 <irene-knapp> haha, wow
17:29:37 <copumpkin> irene-knapp: it's lifting everything over reader, basically
17:29:41 <irene-knapp> hmmm
17:29:47 <mauke> irene-knapp: http://mauke.dyndns.org/stuff/haskell/fun.hs
17:29:52 <mauke> if you don't mind breaking everything
17:29:58 <irene-knapp> well, indeed
17:29:58 <mauke> lambdabot does it a bit more sanely
17:30:03 <Cale> lol, I have a new file in my home directory called Int, and it contains a Parsec parse error
17:30:14 <mauke> haha
17:30:19 <parcs> how did that happen
17:30:20 * irene-knapp sees the === operator there and shivers because it's reminiscent of PHP :(
17:30:25 <Cale> I don't know
17:30:33 <copumpkin> the === operator is awesome
17:30:41 <irene-knapp> hah, interesting
17:30:54 <hpc> Cale: nicely done
17:30:55 <shachaf> > var $ map (foldr (.) id . replicate 2999 $ succ) "copumpkin" -- Coïncidence? I think not!
17:30:56 <diabot>   చదధబతధఢఠథ
17:30:58 <copumpkin> if you want 1% of what's wrong with java, you get some of it from ===
17:30:59 <mauke> primary suspect: broken shell escaping
17:31:08 <hpaste> Cale pasted “Contents of "Int"” at http://hpaste.org/54897
17:31:12 <shachaf> look_of_copumpkin
17:31:27 <mauke> Cale: Char -> Int
17:31:35 <Cale> rofl
17:32:00 <irene-knapp> hah!
17:32:17 <shachaf> > var $ map (foldr (.) id . replicate 5259 $ succ) "copumpkin"
17:32:18 <diabot>   ᓮᓺᓻᔀᓸᓻᓶᓴᓹ
17:32:18 <geheimdienst> possibly you had some haskell highlighted and accidentally middle-clicked in a terminal window ...
17:32:42 <Cale> Possibly, though it's also quite possible that lambdabot is broken :P
17:32:44 <mauke> that usually doesn't create multiline files
17:32:59 <mauke> especially not nicely indented ones
17:34:25 <Cale> @undefine
17:34:25 <shachaf> > var . unlines . flip map [0,9016,9017,9018] $ (\n -> map (foldr (.) id . replicate n $ succ) "copumpkin")
17:34:26 <diabot>   copumpkin
17:34:26 <diabot>  ⎛⎧⎨⎭⎥⎨⎣⎡⎦
17:34:28 <diabot>  ⎜⎨⎩⎮⎦⎩⎤⎢⎧
17:34:30 <diabot>  ⎝⎩...
17:34:35 <Cale> :t (.)
17:34:35 <diabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
17:34:38 <Cale> hrm
17:34:41 <copumpkin> oh wait
17:34:42 <elliott_> what's diabot
17:34:45 <copumpkin> it's not lambdabot
17:34:50 <elliott_> oh lambdabot
17:34:50 <copumpkin> that's why
17:34:53 <shachaf> No, it's byorgey's bot or something.
17:34:54 <Cale> heh
17:34:54 <hpc> ...i thought the Eval.hs mangling function fixed that crap?
17:35:08 <elliott_> ah, it lacks the caleskell
17:35:20 <elliott_> we demand a bot implementing caleskell-standard functionality!
17:35:23 <elliott_> > 2+2
17:35:23 <diabot>   4
17:35:30 <elliott_> lambdabot :(
17:35:40 <Cale> hrm
17:35:42 <elliott_> Cale: Is lambdabot still printing these lines on the console?
17:36:05 <Cale> I'm not sure what's going on exactly
17:36:18 <elliott_> If so, it might be my patch, although I can't for the life of me think *why*. My test patched lambdabot saw everything but refused to talk to the channel but I assumed it was just broken because I ripped out half the dependencies and wrote a quick configuration without thinking.
17:36:36 <elliott_> But it makes no sense for my code to cause that, at least not before it gets disconnected for the first time...
17:36:59 <vrook> what does it mean when ghci can run something bug ghc gives missing symbol errors?
17:37:12 <vrook> *but
17:37:22 <Cale> I had to change the code you gave, you had a writeMVar which is something that doesn't exist
17:37:23 <elliott_> vrook: you forgot --make
17:37:24 <Jafet> It probably means you need to upgrade to ghc 7
17:37:33 <Cale> but maybe it does exist on your system?
17:37:44 <vrook> elliott_: thanks
17:37:48 <vrook> (works)
17:37:51 <elliott_> Cale: er, oops, that was a last minute change >_>
17:37:51 <Hellololo> help!
17:38:08 <vodik> i've been trying to google this and drawing blanks. can someone point me to functions to walk directory structures?
17:38:12 <elliott_> Cale: writeMVar v a = modifyMVar_ v (const (return a)) is the desired semantics
17:38:16 <irene-knapp> Hellololo: your keys are in the laundry basket.  you're welcome.
17:38:19 <elliott_> or more simply takeMVar v >> putMVar v a
17:38:20 <fullofcdrs> anyone here familiar with parsec?
17:38:33 <Cale> ah, then that would be why :P
17:38:36 <elliott_> oh!
17:38:40 <elliott_> Cale: and it's broken too
17:38:51 <elliott_> Cale: it tries to reconnect whenever *anyone* quits >_>
17:39:02 <mauke> hahaha
17:39:05 <elliott_> +      | "QUIT " `isPrefixOf` line' ->
17:39:05 <elliott_> +        -- arrange for a reconnection
17:39:05 <elliott_> +        io $ writeMVar heartbeat 0
17:39:05 <elliott_> removing these three lines should fix it
17:39:12 <elliott_> it'll still reconnect when disconnected
17:39:15 <elliott_> it'll just take longer to do it
17:39:22 <Lemmih> vodik: getDirectoryContents from System.Directory
17:39:37 <elliott_> Cale: so lambdabot has been trying to reconnect while the original lambdabot is still connected, essentially :P
17:39:41 <vodik> Lemmih: perfect, thanks
17:39:48 * elliott_ whoops
17:39:53 <hpc> o.O
17:40:01 <elliott_> it's me, I killed the kittens
17:41:07 <Lemmih> vodik: There's also http://hackage.haskell.org/package/directory-tree
17:41:15 <elliott_> just wait for my patches to GHC, the haskell world will never be safe again
17:41:56 <vodik> Lemmih: looking into it
17:42:00 <vodik> thanks again
17:42:01 <Cale> elliott_: I'll roll back your patch for now, and you can try again once everything is in order :)
17:42:07 <elliott_> Cale: probably for the best :)
17:42:44 <vodik> Lemmih: second link is perfect, cheers!
17:43:01 <Cale> > 1 + 1
17:43:06 <Lemmih> 2!
17:43:08 <lambdabot>   unrecognized option `--noimports'
17:43:11 <Cale> blah
17:43:15 <lambdabot>  Usage: mueval [OPTION...] --expression E...
17:43:19 <Cale> nice
17:43:31 <elliott_> lmao
17:44:34 <irene-knapp> haha, nice
17:44:35 <Cale> oh, it's --no-imports now, thanks mueval! thueval!
17:44:47 <elliott_> What *are* mueval's options?
17:44:48 <elliott_> We just don't know.
17:48:56 <Cale> let's see if this works yet
17:49:05 <Cale> > 1 + 1
17:49:16 <lambdabot>   2
17:49:19 <Cale> okay, good
17:50:15 <MaskRay> can anyone demonstrate how to compile a simple program with foreign export in jhc?
17:50:50 <hpc> perhaps it is time to write lambdabot 3.0?
17:51:07 <hpc> in a way that doesn't break so hard
17:56:07 <irene-knapp> :k []
17:56:09 <lambdabot> * -> *
17:56:14 <irene-knapp> :k [] String
17:56:15 <lambdabot> *
17:56:19 <irene-knapp> :t [] String
17:56:20 <lambdabot> Not in scope: data constructor `String'
17:56:23 <irene-knapp> :t [] Char
17:56:24 <lambdabot> Not in scope: data constructor `Char'
17:56:28 <irene-knapp> :t [] Int
17:56:29 <lambdabot> Not in scope: data constructor `Int'
17:56:48 <irene-knapp> oh, hm, it's taking the second one as a data constructor rather than a type constructor
17:57:03 <megajosh2> Hey, is anyone familiar with the ConfigFile library? I'm trying to get the Either CPError ConfigParser out of an ErrorT monad and I use something like
17:57:11 <megajosh2> fromJust . (>>= Just) . runErrorT
17:57:23 <megajosh2> I can't help but feel that I'm doing something horribly wrong and there's a more straightforward way
17:57:25 <hpc> megajosh2: can you give more complete types?
17:57:30 <megajosh2> One sec
17:57:57 <megajosh2> (let cp = emptyCP in do { cp <- add_section cp "client"; set cp "client" "username" "determinacy" }) :: MonadError CPError m => m ConfigParser
17:58:26 <megajosh2> Basically, I'm just trying to get the ConfigParser (i.e. cp) out of all the monadic wrapping
17:58:40 <hpc> :t runErrorT
17:58:41 <megajosh2> Or at least the Either
17:58:41 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
17:58:53 <hpc> megajosh2: what's the "m" there?
17:59:03 <megajosh2> Well
17:59:05 <megajosh2> One second
17:59:23 <megajosh2> runErrorT (let cp = emptyCP in do { cp <- add_section cp "client"; set cp "client" "username" "determinacy" }) :: Monad m => m (Either CPError ConfigParser)
17:59:33 <megajosh2> A monad
17:59:47 <megajosh2> That's where you start to see the Either
17:59:53 <fullofcdrs> Can someone tell me why skipWhitespace and skipWhitespace1 won't type check for the choice operators? - http://codepad.org/G64X6pZd
18:00:07 <fullofcdrs> (this is in F# FParsec)
18:00:46 <hpc> megajosh2: right, so you have a value of type "m (Either CPError ConfigParser)"
18:01:12 <hpc> megajosh2: first we need a function that takes the Either bit and turns it into just a ConfigParser
18:01:24 <hpc> megajosh2: i don't know anything about what's actually in there, so im gonna have to go with
18:01:32 <hpc> :t either (const Nothing) id
18:01:33 <lambdabot> forall a a1. Either a1 (Maybe a) -> Maybe a
18:01:45 <hpc> :t either (const Nothing) Just
18:01:47 <lambdabot> forall a a1. Either a1 a -> Maybe a
18:01:51 <hpc> ^ that
18:02:19 <hpc> so suppose, fromRight = either (const Nothing) Just
18:02:35 <hpc> megajosh2: and then you need something to pull the ConfigParser out of the monad
18:02:48 <byorgey> I though megajosh2 wanted the Either CPError ConfigParser?
18:02:58 <hpc> oh
18:03:03 <hpc> derp
18:03:04 <megajosh2> Either one
18:03:17 <megajosh2> But I think that's more straightforward because I was really just aiming for the ConfigParser
18:03:25 <byorgey> megajosh2: first of all, (>>= Just) is the same as id.
18:03:33 <hpc> anyhoo, there's no generic way to get a value "out" of a monadic value
18:03:49 <byorgey> megajosh2: fromJust means 'assume it is Just, and if not then crash with a useless error message'.
18:04:03 <megajosh2> Hmm
18:04:08 <hpc> megajosh2: what you want to do is either know your "m" beforehand, or you want to do everything (or most of it) in that monad, and bring all your other functions "towards" the monad instead
18:04:13 <megajosh2> (>>= Just) ≡ id, I never thought of it that way
18:04:26 <byorgey> megajosh2: what you should really do is something like   case (runErrorT ... ) of  Nothing -> (do something sensible here); Just e -> handle the Either CPError ConfigParser
18:04:34 <hpc> megajosh2: which means using fmap, (<$>)/(<*>), monadic functions, etc
18:04:48 <byorgey> ah, hpc, good point
18:05:15 <byorgey> write a function that works on  Either CPError ConfigParser and then use liftM to use it in the monad m
18:06:22 <shachaf> hpc: So much M-word. :-(
18:06:30 <shachaf> «"towards" the monad»
18:06:50 <shachaf> Why can't everyone just think exactly the way I do.
18:07:04 <megajosh2> Life would be so much easier
18:07:23 <megajosh2> I'd be able to read minds
18:07:29 <vrook> Probably unlikely, but is there a way to change the name of the .hi extension? Several times now I've opened a .h file instead of .hs due to tab complete. I guess I can configure emacs to ignore .hi.
18:07:43 <vrook> ... which would be better than changing the name .hi
18:08:00 <hpc> shachaf: yeah, using deliberately not-quite-correct-but-you-know-what-i-mean terminology to avoid having to teach category theory while solving this problem ;)
18:08:55 <vrook> (nevermind)
18:09:30 <hpc> vrook: clearly you should ln -s foo.h foo.hs
18:09:43 <hpc> vrook: for all *.hs in your project
18:09:48 <shachaf> hpc: No category theory needed.
18:10:03 <shachaf> Nor is any talk of the M-word or "monadic functions" or whatever needed.
18:10:16 <mauke> hpc: isn't that the wrong way around?
18:10:28 <hpc> mauke: heh, i can never remember the order
18:10:36 <mauke> hpc: it's like cp
18:10:44 <hpc> oh, that helps
18:11:14 <megajosh2> hpc: Neither can I
18:11:40 <miden> hello there
18:11:45 <hpc> mauke: oh cool, it is the other way around
18:11:58 <hpc> mauke: i will remember that for at least the next half hour :D
18:12:31 <miden> i ve got a quick question : Is there any way to take a string with \r\n inside it and print it with lines without changing the type of the value
18:12:31 <miden> ?
18:12:49 <miden> for example func :: Something -> String
18:13:17 <miden> and i want func "testtestte\r\ntestetst" to be printed like :
18:13:23 <miden> putStr
18:13:35 <miden> (but i don't want IO)
18:13:35 <mauke> wtf
18:13:36 <rwbarton> did you just answer your own question?
18:13:45 <mauke> miden: for debugging, yes
18:13:49 <mauke> for actual code, no
18:13:54 <hpc> miden: for debugging, there's trace
18:14:10 <hpc> miden: it's in Debug.Trace, and the module name very much indicates what it should be used for ;)
18:16:09 <fullofcars> how do I change `anyOf "!@#$"' into a parser?
18:21:43 <shachaf> fullofcars: That depends on what you mean by a "a parser".
18:21:57 <shachaf> (Also by «anyOf "!@#$"».)
18:24:26 <fullofcars> well, I managed to do it by many (anyOf whitespaceTextChars)
18:24:40 <fullofcars> (this is done in terms of parsec)
18:35:01 <vrook> Earlier I had a  run-time type error in ghci (perhaps related to the random monad). Is that possible or was I hallucinating?
18:35:21 <shachaf> vrook: Well, it's the "run-time" of ghci...
18:35:39 <shachaf> Without being more specific, we can only say that you're hallucinating.
18:36:45 <vrook> I haven't been able to reproduce it, and for the past 30 minutes it's been my white whale.
18:37:02 <Axman6> hmm, what's a simple parser library for Strings (wondering if there's anything much more lightweight than parsec)
18:37:28 <shachaf> Axman6: ReadP?
18:38:12 <Axman6> hmm, possibly.. that's monadic right?
18:40:36 <Axman6> hmm, maybe parsec will do
18:42:19 <gwern> @qipte
18:42:20 <lambdabot> PhilipWadler says: I'm delighted to learn that "a monad is a monoid in the category of endofunctors"---anyone know where I can find a good tutorial?
18:42:35 <mzero> oh - lambdabot is back!
18:42:37 <mzero> @botsnack
18:42:37 <lambdabot> :)
18:47:54 <Axman6> lambdabot++
18:47:58 <Axman6> @karma lambdabot
18:47:59 <lambdabot> lambdabot has a karma of 1
18:48:01 <Axman6> lambdabot++
18:48:02 <Axman6> @karma lambdabot
18:48:03 <lambdabot> lambdabot has a karma of 2
18:48:10 <Axman6> where did your karma go D:
18:51:45 <Axman6> urgh, how do I just get the next character from the string in parsec?
18:58:11 <mzero> char
18:58:25 * hackagebot nbt 0.3 - A parser/serializer for Minecraft's Named Binary Tag (NBT) data format.  http://hackage.haskell.org/package/nbt-0.3 (AdamFoltzer)
19:00:08 <Axman6> mzero: thanks
19:08:35 <Axman6> mzero: actually that matches a specific char. I think letter is what I'm after
19:18:58 <Sgeo> "How to make a function strict without changing its body"
19:19:19 <Sgeo> Is there a difference between using that trick and slapping ! in front of the pattern?
19:19:27 <Sgeo> Besides the fact that with that trick, you can do a deepSeq
19:19:33 <Sgeo> http://okmij.org/ftp/Haskell/#making-function-strict
19:22:43 <accel> anyone here familiar with coding in haskell-style in clojure?
19:22:55 <accel> I need to do a new project in clojure; but I would like a set of principles to help me enfore pure functions
19:22:59 <accel> and keep state stuck inside of monads
19:33:58 <hpaste> megajosh2 pasted “"rigid type variable" problems?” at http://hpaste.org/54899
19:34:24 <megajosh2> I can't make sense of the error in that paste... can anybody here?
19:34:30 <megajosh2> http://hpaste.org/54899
19:37:56 <doserj> megajosh2: your class declaration claims you can return errors of any type e, but in your instance declaration , you only return errors of one specific type.
19:44:13 <megajosh2> doserj: Is there any way I can get the behavior I'm looking for, then?
19:50:55 <megajosh2> I guess I should just use one specific error type...
20:00:26 <Nisstyre> how would I make data Tree b a = Empty | Leaf a | Branch b (Tree b a) (Tree b a) and instance of Functor? This should be really easy but for some reason I can't figure out how.
20:01:13 <Axman6> what do you have so far?
20:01:36 <ski> start with `instance Functor (Tree b) where ...'
20:01:45 <Nisstyre> Axman6: let me paste it
20:01:46 <Nisstyre> one second
20:01:55 <ski> figure out what specific type of `fmap' you're implementing
20:02:10 <Nisstyre> it's a problem with my types
20:02:35 <Nisstyre> http://codepad.org/jef8GTSH
20:03:11 <ski> Nisstyre : what is the type of `fmap' in your case ?
20:03:32 <ski> if you can state it, you're halfway done
20:03:44 <Nisstyre> ski: takes a function that takes one argument and returns one argument, and a type that is an instance of Functor
20:03:50 <Nisstyre> and returns a type that is an instance of Functor
20:03:58 <ski> please state a type signature :)
20:04:06 <Nisstyre> ugh, okay let me copy and paste
20:04:07 <Axman6> what is the type of fmap for your specific case
20:04:23 <Nisstyre> oh ok
20:04:24 <Axman6> fmap :: (a -> b) -> ... -> ...
20:04:42 <Nisstyre> well, fmap :: (a -> b) -> Tree a b -> Tree a b
20:04:45 <Nisstyre> I suppose
20:04:46 <Nisstyre> right?
20:04:48 <ski> where the `...'s are what, exactly ?
20:04:49 <Axman6> yep
20:04:53 <ski> no
20:05:00 <ski> that's not right
20:05:13 <Axman6> oh, no it's not. my bad@!
20:05:16 <Nisstyre> where am I going wrong here?
20:05:20 <ski> the simplest way is to start from the generic type of `fmap'
20:05:21 <ski> i.e.
20:05:30 <ski>   fmap :: (a -> b) -> (f a -> f b)'
20:05:38 <ski> what is `f' in your case ?
20:06:00 <Nisstyre> okay I think I see where I'm wrong in my thinking
20:06:03 <Axman6> (hint, for list, it's [], for Either it's Either e)
20:06:05 <Nisstyre> f takes a single argument
20:06:13 <Nisstyre> but my type, Tree, takes two type arguments
20:06:14 <Nisstyre> right?
20:06:18 <Axman6> yep
20:06:33 <Nisstyre> so it can't be made an instance of Functor
20:06:40 <Axman6> sure it can
20:06:44 <Nisstyre> how?
20:06:48 <Axman6> how else would Either be a functor then?
20:06:56 <Nisstyre> fair enough
20:07:06 <Axman6> > fmap (+1) (Left "Damn")
20:07:07 <lambdabot>   Left "Damn"
20:07:16 <Axman6> > fmap (+1) (right 3)
20:07:17 <lambdabot>   No instance for (GHC.Show.Show
20:07:17 <lambdabot>                     (a (Data.Either.Either d...
20:07:18 <Axman6> > fmap (+1) (Right 3)
20:07:19 <lambdabot>   Right 4
20:07:36 <ski> Nisstyre : `Tree' *itself* can't be made an instance of `Functor', that's right
20:07:45 <ski> but you can get something that's almost as good
20:07:53 <Axman6> :t fmap (+1) `asAppliedTo` (Left "hello")
20:07:54 <lambdabot> forall a. (Num a) => Either [Char] a -> Either [Char] a
20:07:55 <geheimdienst> Nisstyre: here is the implementation of the Either Functor for inspiration http://hackage.haskell.org/packages/archive/base/4.4.1.0/doc/html/src/Control-Monad-Instances.html
20:08:02 <ski> namely, `Tree b' can be made an instance of `Functor', for any type `b'
20:08:28 <ski> in `instance Functor (...)', `...' has to have kind `* -> *'
20:08:30 <ski> @kind Maybe
20:08:31 <lambdabot> * -> *
20:08:33 <ski> @kind Either
20:08:34 <lambdabot> * -> * -> *
20:08:36 <ski> @kind Either Int
20:08:37 <lambdabot> * -> *
20:08:37 <ski> @kind Either a
20:08:38 <lambdabot> Not in scope: type variable `a'
20:08:44 <ski> bah
20:08:45 <Axman6> u suck lambdabot
20:08:53 <DanBurton> @botslap
20:08:53 <lambdabot> Unknown command, try @list
20:08:59 <ski> @botsmack
20:09:00 <lambdabot> :)
20:09:04 <Axman6> no!
20:09:10 <lambdabot> I only have nice things to say aboutAxman6.
20:09:12 <Axman6> you're not supposed to like that!
20:09:20 <Axman6> awww :)
20:09:34 <lambdabot> Come, come, elucidate your thoughts.
20:09:53 <Axman6> Nisstyre: ANYWAY! ok, so, we'll start from here: instance Functor (Tree c) where fmap f ...
20:10:14 <ski> :( why you already renamed it ?
20:11:51 <Nisstyre> Axman6: when you say (Tree c) are you saying Tree will only have one type variable?
20:12:14 <Axman6> is there a good library for writing a repl like thing, but is really just supplying commands to run (as Haskell types), and displaying the results?
20:12:26 <Axman6> @src Functor
20:12:26 <lambdabot> class  Functor f  where
20:12:26 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
20:13:06 <geheimdienst> Nisstyre: it's similar to how you can have a function of 2 arguments, then apply it to one arg, leaving a function of 1 arg
20:13:19 <Axman6> Nisstyre: if we replace f with Tree c, we get fmap :: (a -> b) -> (Tree c) a -> (Tree c) b, or fmap :: (a -> b) -> Tree c a -> Tree c b,
20:14:39 <Nisstyre> geheimdienst: that's what I was thinking, thanks for clarifying it. So you can do partial application in class instances?
20:14:44 <Nisstyre> Or something similar to it?
20:15:30 <Axman6> you can do it anywhere really
20:15:33 <geheimdienst> i guess you could say that. the kind was * -> * -> * previously, now only * -> * is left. see also what ski did above
20:15:48 <geheimdienst> (Either Int has kind * -> *)
20:16:12 <Axman6> Nisstyre: now notive that that says you can only change the type of the second type parameter on the tree, the first must stay the same
20:16:15 <ski> Nisstyre : you can partially apply `newtype's and `data' types anywhere. however, you can't partially apply `type' synonyms
20:16:36 <Axman6> huh, how come ski?
20:16:51 <ski> Axman6 : it's not allowed
20:17:02 <Nisstyre> Axman6: so make it explicity
20:17:06 <Nisstyre> *explicit
20:17:10 <Nisstyre> like Int or something, right?
20:17:14 <Axman6> no
20:17:23 <Nisstyre> is that not what you meant by change?
20:17:25 <Axman6> the typer i have you was the type you need
20:17:33 <ski> assuming `f' is `Tree c' as Axman6 suggested, then
20:17:35 <ski>   fmap :: (a -> b) -> (f a -> f b)
20:17:35 <Axman6> you now need to change your definition
20:17:39 <ski> becomes what ?
20:17:42 <acfoltzer> anyone know if there are instances of the vector-space package classes for the OpenGL vector types?
20:17:48 <ski> Nisstyre ^
20:18:18 <Nisstyre> fmap :: (a -> b) (Tree c a -> Tree c b) ?
20:18:24 <Axman6> yep
20:18:43 <Axman6> so, from that we can see that all the a's get turned into b's, and all the c's stay the same, right?
20:18:52 <Nisstyre> yes
20:19:06 <Axman6> ok, so, in your definition, whast was happening to the c's?
20:19:43 <Nisstyre> well, I'm not sure
20:20:00 <ski> look at
20:20:02 <ski>   fmap f (Leaf x) = Leaf $ f x
20:20:10 <ski> what's the type of `x' ?
20:20:26 <Nisstyre> it could be anything
20:20:29 <ski> (in terms of `a',`b',`c')
20:20:55 <Nisstyre> oh, well, I guess it would be b
20:21:01 <Nisstyre> if we're going by my definition
20:21:26 <ski> well, note that here we're saying
20:21:35 <ski>   fmap :: (a -> b) -> (Tree c a -> Tree c b)
20:21:47 <ski> so, the type of `f' above is here `a -> b'
20:21:47 <Nisstyre> then it would be c I think
20:21:56 <Nisstyre> Leaf only takes one argument, so
20:21:59 <ski> and the type of `Leaf x' (second argument) is `Tree c a'
20:22:20 <ski> so, what type does that mean `x' must have, then ?
20:22:41 <ski> (it's not `b', since `Tree c a' doesn't even mention `b')
20:23:03 <ski> to determine this, you could take your definition
20:23:05 <ski>   data Tree b a = Empty | Leaf a | Branch b (Tree b a) (Tree b a)
20:23:17 <ski> and rename the variables so that the head looks like `Tree c a'
20:23:20 <ski> i.e.
20:23:25 <djanatyn>  /window 11
20:23:28 <ski>   data Tree c a = Empty | Leaf a | Branch c (Tree c a) (Tree c a)
20:23:29 <djanatyn> ermm, sorry
20:23:49 <ski> then you see that the template there is `Leaf a'
20:23:54 <Nisstyre> yes
20:24:00 <ski> so, in `Leaf x' in the pattern, `x' must have type `a'
20:24:17 <vrook> Is there a conventional name for putStrLn . show ? It seems pretty common.
20:24:17 <ski> and since we knew `f :: a -> b', `f x' will have type `b'
20:24:34 <Axman6> vrook: print
20:24:36 <Axman6> :t print
20:24:37 <lambdabot> forall a. (Show a) => a -> IO ()
20:24:43 <ski> and `Leaf $ f x' will then have type `Tree c2 b', for any type `c2', e.g. when `c2' is `c'
20:24:44 <Axman6> @src print
20:24:45 <lambdabot> print x = putStrLn (show x)
20:24:54 <vrook> oops, thanks
20:25:08 <ski> Nisstyre : now, let's look at the other clause
20:25:17 <ski>   fmap f (Branch x left right) = Branch (f x) (fmap f left) (fmap f right)
20:25:33 <ski> Nisstyre : what is the type of `x',`left',`right', respectively ?
20:26:16 <Nisstyre> x would be (a -> b)
20:26:18 <Nisstyre> right?
20:26:22 <ski> no
20:26:27 <ski> that's the type of `f'
20:26:39 <ski> the first argument, i.e. `f', has type `a -> b'
20:26:54 <ski> the second argument, i.e. `Branch x left right', has type `Tree c a'
20:27:31 <ski> (this can be read off the type signature `fmap :: (a -> b) -> (Tree c a -> Tree c b)')
20:28:11 <ski> Nisstyre : does that make sense ?
20:28:15 <Nisstyre> yeah
20:28:20 <dmwit> preflex: seen roconnor
20:28:20 <preflex>  roconnor was last seen on #haskell 3 hours, 53 minutes and 28 seconds ago, saying: If I click on this reddit link about the game of life in Haskell, will it say comonad?
20:28:30 <ski> Nisstyre : any idea for how to figure out `x',`left',`right', then ?
20:28:34 <Axman6> @hoogle hPutStrLn
20:28:35 <lambdabot> System.IO hPutStrLn :: Handle -> String -> IO ()
20:28:35 <lambdabot> Data.ByteString hPutStrLn :: Handle -> ByteString -> IO ()
20:28:35 <lambdabot> Data.ByteString.Char8 hPutStrLn :: Handle -> ByteString -> IO ()
20:28:41 <Axman6> @hoogle stderr
20:28:41 <lambdabot> System.IO stderr :: Handle
20:28:42 <lambdabot> GHC.IO.Handle.FD stderr :: Handle
20:29:12 <dmwit> ?botsnack
20:29:12 <lambdabot> :)
20:29:25 <Nisstyre> ski: well left and right will both be Tree c a
20:29:28 <dmwit> ?ask roconnor for help converting an HSV triple to a Colour
20:29:29 <lambdabot> Consider it noted.
20:31:03 <ski> Nisstyre : yes
20:31:24 <Nisstyre> I'm not sure what the type of x is
20:31:42 <Axman6> look at your definition for Tree
20:31:54 <ski> the type of `Branch x left right' was `Tree c a'
20:31:59 <ski> and we know
20:32:03 <ski>   data Tree c a = Empty | Leaf a | Branch c (Tree c a) (Tree c a)
20:32:05 <Nisstyre> so is it just Tree c ?
20:32:21 <ski> so, the relevant template here is `Branch c (Tree c a) (Tree c a)'
20:32:21 <Axman6> not quite
20:32:42 <Nisstyre> yes
20:32:53 <Nisstyre> so it's just c
20:33:13 <Axman6> yep!
20:33:15 <ski> matching the sub-patterns in `Branch x left right' with the data constructor argument types in `Branch c (Tree c a) (Tree c a)' gives us `x :: c', `left :: Tree c a', `right :: Tree c a'
20:33:24 <ski> Nisstyre : exactly :)
20:33:30 <ski> so, `x :: c' here
20:33:36 <ski> and remember, `f :: a -> B'
20:33:41 <ski> er, `f :: a -> b'
20:33:52 <ski> so, what's the type of `f x' ?
20:34:08 <ski> (which occurs in your `fmap f (Branch x left right) = Branch (f x) (fmap f left) (fmap f right)')
20:34:39 <Nisstyre> (a -> Tree c) I think
20:34:53 <ski> that's not even wrong
20:35:24 <ski> `f' is a function taking inputs of type `a', and yielding outputs of type `b'
20:35:32 <ski> in `f x', you pass `x' as input to `f'
20:35:42 <Nisstyre> yeah of course
20:35:42 <ski> so, the type of `x' must match the input type of `f'
20:35:55 <ski> and which are those two types ?
20:36:29 <Nisstyre> ski: I dunno
20:36:49 <ski> hint : i mentioned it above
20:37:07 <Nisstyre> well a -> b
20:37:40 <ski> that's the whole type of `f', yes
20:37:47 <ski> what's the *input* type of `f' ?
20:37:56 <ski> i.e. the type of the inputs/arguments of `f'
20:38:30 <Nisstyre> a
20:38:35 <ski> yes
20:38:41 <ski> and the type of `x' was ?
20:38:45 <Nisstyre> c
20:39:33 <ski> so, you're trying to pass something of type `c' (namely `x') to a function (namely `f') that wants something of type `a' as input
20:39:51 <ski> this only works if `c' and `a' can be made the same type
20:39:57 <ski> in this case, they can't be
20:40:02 <Nisstyre> okay
20:40:05 * mzero is back -- someone was trying to ping me?
20:40:12 <ski> because `fmap' doesn't know what `a',`b',`c' will finally be
20:40:14 <ski> it knows
20:40:25 <ski>   fmap :: (a -> b) -> (Tree c a -> Tree c b)
20:40:44 <ski> and it's the *caller* of `fmap' who decides what types `a',`b',`c' will be
20:40:58 <ski> so, in general you can't assume `c' and `a' is the same type
20:41:03 <ski> Nisstyre : and this is your type error
20:41:09 <Nisstyre> okay, I understand now
20:41:22 <ski> Nisstyre : your `f' function can convert `a's into `b's, but it can't do anything with the `c's
20:41:31 <augur> byorgey: is there a species for dags?
20:42:08 * ski misread "dags" as "dogs" initially
20:42:55 <augur> ski: :)
20:43:28 <byorgey> augur: hmm, great question
20:43:42 <augur> or preferably, connected, singly rooted dags
20:43:43 <augur> :)
20:43:43 <byorgey> there is definitely a species for dogs
20:43:47 <byorgey> it is called "dogs"
20:43:55 <augur> i think its called canis familiaris, actually
20:44:14 <augur> canis lupus familiaris
20:44:22 <augur> <house reference>
20:44:54 <byorgey> augur: well, I mean, there certainly *is* a species of dags.
20:44:55 <mzero> perhaps a different way of approaching Nisstyre's problem is to ask: What do the c and a types represent in Tree c a?  Why do you trees have different types for the value in a branch vs. the value in a leaf? (Not that it is wrong, I'm probing your thinking....)
20:45:10 <dmwit> I don't suppose anybody other than roconnor knows how to turn an HSV triple into a Colour?
20:45:13 <byorgey> augur: namely, the species which, given a set of labels, constructs all the dags on those labels.
20:45:21 <augur> ya
20:45:37 <byorgey> augur: I suppose what you are really asking (which is an interesting question) is whether there is a nice way to describe it algebraically in terms of more primitive species + operations
20:45:46 <Nisstyre> mzero: it probably came about because I was trying to convert a datatype I'd written before to have a value along with each Branch
20:45:47 <rwbarton> I figured out how to turn an RGB triple into a Colour at least
20:45:53 <Nisstyre> and I just wasn't thinking
20:46:01 <dmwit> rwbarton: That would be good enough for me, there's a function to go from HSV to RGB.
20:46:11 <rwbarton> hmm let me find it
20:46:23 <mzero> it's fine - but again, what do the types c and a represent? Why are there two types?
20:47:04 <Nisstyre> mzero: there are two types because a Branch has a value that goes along with it in addition to the two nodes
20:47:15 <rwbarton> dmwit: I used sRGB24 from .SRGB
20:47:23 <byorgey> augur: I don't know the answer. A quick glance in BLL does not turn anything up.  They talk about the species of directed graphs but not acyclic ones.
20:47:35 <mzero> is that value totally independent of the type that is in the Leaf? Or do you expect them to be the same?
20:47:39 <Nisstyre> mzero: that makes sense to do right?
20:47:44 <vrook> dmwit: just google for hsv2rgb and so forth. The function isn't hard because it's essentially slicing a cube.
20:47:48 <Nisstyre> mzero: I don't expect them to be the same actually
20:48:00 <mzero> okay - now
20:48:02 <augur> byorgey: im looking through all of BLL's mention of directed graphs
20:48:03 <dmwit> vrook: I know the math isn't hard.
20:48:15 <dmwit> vrook: It's the library API that's hard. =)
20:48:22 <vrook> oh ok, sorry
20:48:26 <dmwit> rwbarton: Ah, thanks. sRGB looks about right.
20:48:28 <twoshot_> guys, I'm trying to compile my first haskell program, and I'm having a hell of a time. I apparently can't do a "data" declaration in ghc and I need a main method?
20:48:53 <byorgey> augur: intuitively, it seems like acyclicity is a "global" property, I am not sure how you would rule it out compositionally
20:49:04 <dmwit> ?hpaste some code, twoshot_
20:49:04 <lambdabot> Haskell pastebin: http://hpaste.org/
20:49:08 <augur> byorgey: that what i figure
20:49:09 <dmwit> Bonus points for including the error message.
20:49:16 <vrook> Interestingly, there's a nice geometrical description of the algorithm: you can slice a cube to get a hexagon.
20:49:16 <mzero> as  Functor - then if some function f converts a's to b's --- then fmap f someTree convert's the a's of the Tree to b's ---- now which datum in the tree are you expecting it to convert?
20:49:30 <byorgey> augur: hmm, but it may be that dags are isomorphic to some other structure which can be defined directly.  I will think about it.
20:49:31 <Nisstyre> mzero: it worked for this unfoldtree function I wrote http://codepad.org/W07uspVd
20:49:34 <augur> byorgey: i ask because one view of syntactic trees is that they're (singly-rooted) dags
20:49:35 <twoshot_> dmwit, lol ok thanks. be back. btw i'm on a text based irc editor in unix so if i forget who is helping me, sorry
20:49:35 <Axman6> twoshot_: you probably want to use ghci
20:49:43 <Nisstyre> meaning it built a tree when I ran it
20:49:55 <augur> byorgey: so im always looking for nice ways of expressing that property
20:50:02 <Axman6> irc has editors now?
20:50:06 <byorgey> augur: interesting. why dags?
20:50:10 <byorgey> i.e. why not just trees?
20:50:19 <twoshot_> Axman6: i can never figure out interactive editors, but if i can figure it out i'm definitely ok with doing that
20:50:27 <Nisstyre> mzero: I'm expecting it to convert both
20:50:29 <mzero> Nisstyre: there's nothing wrong with your Tree type
20:50:32 <mzero> AHA
20:50:36 <augur> byorgey: well, in transformational theories, we have movement, and one idea about movement is that you dont actually move anything, you just multiply-dominate something
20:50:43 <mzero> it can't convert both --- unless both are the same type!
20:50:47 <Nisstyre> okay
20:50:52 <mzero> because f convert's a to b ----
20:50:53 <Nisstyre> that shows the flaw in my thought process
20:51:05 <byorgey> augur: that went totally over my head. can you give an example?
20:51:11 <Axman6> twoshot_: time to learn! ghci is pretty simple
20:51:11 <dmwit> augur: Some kind of observable common sub-expression, then?
20:51:20 <mzero> right? so fmap f  --- that f takes some type a ---- if it converted both --- the both Branch values and Leaf values would have to have the same type. Does that make sense?
20:51:21 <augur> byorgey: sure. so imagine the tree for the sentence "who did john see"
20:51:23 <Nisstyre> mzero: actually I'm not sure why I thought of it that way
20:51:28 <byorgey> ok
20:51:31 <twoshot_> Axman6, I'll check it out
20:51:41 <Nisstyre> that the type a Leaf would have would be different from the type attached to a Branch
20:51:51 <twoshot_> dmwit, i'm running off a livecd so i may not be able to get this thing installed
20:51:53 <augur> byorgey: instead of something like (who, (did, (john, see))) or something like that, you would have (who, (did, (john, (see, who))))
20:52:01 <ski> twoshot_ : normally you write code in a file, (re)load it into the interactor (e.g. GHCi), test around a bit, edit the file, reload, &c.
20:52:09 <Nisstyre> mzero: that makes perfect sense
20:52:09 <byorgey> augur: oh, I see
20:52:13 <twoshot_> i may roll a dice and see whether i overwrite part of my corrupted ntfs system lol
20:52:15 <byorgey> interesting
20:52:17 <augur> byorgey: and via some function linearize : Tree -> String, you put the "who" on the left
20:52:21 <mzero> Great! So now you have two ways of proceeding!
20:52:34 <Nisstyre> I should rewrite it so that they are the same type I think
20:52:37 <augur> byorgey: or maybe you dont! some languages actually repeat things
20:52:44 <Nisstyre> because it won't matter to me if they are really
20:52:52 <dmwit> twoshot_: Um, what thing exactly is it you might not get installed?
20:52:53 <mzero> If you now think that the type at the Branches and the type at the Leaves should be the same, then you need to recode your type
20:52:58 <dmwit> twoshot_: Nobody here asked you to install anything.
20:53:11 <augur> byorgey: but if the expression is more complex, e.g. "which student did john see", trying to define a data type that captures this poses interesting problems
20:53:20 <mzero> Otherwise, if you think they should remain independent, then you need to think about, as a Functor, which one should be transformed by fmap f
20:53:26 <byorgey> augur: yes, I can imagine
20:53:27 <augur> byorgey: as can be seen by the plethora of ideas for data types with "sharing"
20:53:42 <Nisstyre> mzero: okay, thanks for pointing out the flaw in my thinking
20:53:45 <twoshot_> dmwit, I can't really say I've tried the code unless I try it before uploading it. (I have tried it but not on this computer)
20:53:50 <Nisstyre> really I appreciate it
20:54:05 <augur> byorgey: hamana has a nice type that uses left-ward references
20:54:09 <Axman6> hmm, what's a command that will likely use a lot of CPU on a linux system?
20:54:12 * dmwit is a bit lost
20:54:18 <dmwit> Axman6: yes > /dev/null
20:54:22 <byorgey> augur: link?
20:54:24 <Axman6> hmm, that might do it
20:54:28 <Nisstyre> Axman6: umm, something that does a lot of IO
20:54:38 <rwbarton> md5sum /dev/zero
20:54:49 <augur> byorgey: so you get something like (who, (did, (john, (see, ref up up up left))))
20:54:53 <ski> augur : what about "which john ate" ?
20:54:57 <dmwit> Nisstyre: Doing lots of IO doesn't typically make you CPU-bound.
20:55:01 <augur> byorgey: http://arxiv.org/pdf/1007.4266
20:55:09 <byorgey> augur: ah, ok, thanks
20:55:12 <Nisstyre> dmwit: well, concurrent IO might
20:55:22 <augur> ski: thats not a well formed question, but its a well formed relative clause, and it would have similar structure
20:55:30 <Nisstyre> right?
20:55:37 <dmwit> I'm having a hard time believing it.
20:55:37 <ski> augur : yes, i meant it as a relative clause
20:55:44 <mzero> Nisstyre: happy to help!
20:55:44 <Nisstyre> because the kernel has to manage everything
20:56:19 <hpaste> twoshot_ pasted “data” at http://hpaste.org/54901
20:56:27 <ski> augur : i'm thinking about writing it as `(who,\x -> (john,(ate,x)))'
20:56:29 <augur> byorgey: i dont like the reference approach very much because it relies on non-duplication of the structure. you have to actually use reference objects so a linearization function also needs a de-referencing function if you want to linearize "low"
20:56:30 <Axman6> Nisstyre: that's not likely to make the machine use a lot of CPU really. it'll be waiting for hardware a lot of the time. computing something is likely to use a lot of CPU
20:56:34 <ski> er, s/who/which/
20:56:45 <augur> ski: thats sort of what we think about these things
20:56:47 <twoshot_> dmwit, i posted the first data declaration in hpaste
20:56:51 <Nisstyre> Axman6: fair enough, I was probably thinking it would cause a lot of blocking
20:57:01 <Nisstyre> but that isn't the same as using a lot of cycles
20:57:10 <Axman6> blocking usually means a lot of not much CPU usage :P
20:57:13 <ski> augur : so `\x -> (john,(ate,x))' is basically a tree with a hole in it
20:57:23 <dmwit> twoshot_: Just get rid of the "(Ord a, Show a) =>" nonsense. =)
20:57:24 <ski> i.e., it's HOAS
20:57:28 <mzero> twoshot_: take the constraints off your data and you'll be fine
20:57:30 <augur> ski: more accurately, its something like (which_x, (C, (john, (ate, which_x))))
20:57:35 <dmwit> twoshot_: Any functions that actually need those constraints will get them.
20:57:55 <ski> augur : what is the `C' thing ?
20:57:58 <augur> ski: but we think that the word is actually in both places, not just one place with a hole in the other place
20:58:07 <ski> augur : why ?
20:58:08 <twoshot_> dmwit, i have to keep it :/. I know haskell infers the types but I'm supposed to use that declaration exactly.
20:58:11 <augur> ski: C is the widget that acts vaguely like lambda
20:58:20 <Axman6> good windows sftp client?
20:58:38 <dmwit> twoshot_: In that case, you'll need to enable the appropriate language extension.
20:58:40 <augur> ski: why because there are some languages where you repeat the thing in the low position!
20:58:42 <dmwit> One moment while I look it up.
20:59:16 <augur> ski: or take SLQZ where you say things like "the man seems the man to be tall", whereas in english you'd say just "the man seems to be tall"
20:59:17 <twoshot_> how does one go about looking up the appropriate language extension dmwit
20:59:24 <ski> augur : i'm not sure why one'd want to reflect that in the abstract syntax, though
20:59:30 <dmwit> twoshot_: (The error should mention the appropriate language extension.)
20:59:35 <dmwit> twoshot_: There's a list of all extensions here:
20:59:39 <dmwit> http://www.haskell.org/ghc/docs/7.2.2/html/libraries/Cabal-1.12.0/Language-Haskell-Extension.html
20:59:49 <ski> (in the concrete syntax, sure)
20:59:49 <twoshot_> dmwit, I think the error mentioned data
21:00:31 <mzero> twoshot_: what error are you getting? 'cause that definition loads fine --- suitable reformatted
21:00:39 <twoshot_> thanks dmwit
21:00:40 <ski> augur : i.e. why not use a version with non-repeated word, and only duplicate when linearizing it ?
21:00:42 <mzero> you don't need extensions
21:00:43 <augur> ski: fair enough. but if you're working in a traditional transformational mold, you build these things bottom up and "displace", or at least copy, elements
21:01:05 <twoshot_> mzero, not sure anymore. i'm not on a computer with a working haskell compiler and it will take me a a good 30 minutes to do so
21:01:11 <ski> (obviously if you parse, you go the other way around, merging together when constructing the abstract syntax tree)
21:01:13 <twoshot_> I have to install linux first
21:01:21 <dmwit> twoshot_: Add {-# LANGUAGE DatatypeContexts #-} to the top of your file.
21:01:42 <twoshot_> dmwit k thanks
21:01:48 <dmwit> twoshot_: This will result in a warning, because this feature is deprecated.
21:01:54 <twoshot_> lol
21:01:58 <dmwit> (And the fix I suggested is the HQ-approved workaround.)
21:02:05 <hpaste> mzero pasted “reformatted Tree” at http://hpaste.org/54902
21:02:06 <twoshot_> k
21:02:10 <augur> ski: my primary concern is having a nice formalization of such trees with sharing. perhaps tree functions would be good to have to do that, but i'm not sure how you'd define that bottom up. maybe with contexts.
21:02:18 <dmwit> mzero: It loads (with the language extension) with no reformatting here.
21:02:22 <ski> augur : hm, that's more similar to rewriting systems (Maude, &c. ?) than pattern-matching functions like in Haskell, yes ?
21:02:24 <mzero> twoshot_: that loads w/o warnings
21:02:29 <mzero> or language extensions
21:02:34 <dmwit> And doesn't without the language extension, with or without the language extensions.
21:02:36 <augur> ski: no idea.
21:02:38 <dmwit> So perhaps you have an old GHC.
21:02:51 <mzero> 7.0.2
21:02:57 <twoshot_> perhaps i do
21:03:02 <twoshot_> i'm pretty sure mine was 7.2.2
21:03:03 <dmwit> 7.2.2 gives an error.
21:03:06 <dmwit> yes
21:03:09 <twoshot_> lame
21:03:11 <twoshot_> haha
21:03:19 <mzero> really? why? isn't it legal Haskell 98>
21:03:21 <twoshot_> thank you very much
21:03:21 <mzero> ?
21:03:31 <twoshot_> mzero, what do you mean?
21:03:38 <dmwit> I'm not sure, but it definitely isn't legal H2010.
21:04:02 <copumpkin> really? I thought data type contexts were only removed in 2011
21:04:04 <ski> augur : iiuyc, in "traditional transformational mold" you do small transformation steps, where you don't keep much track of which nodes is "function nodes" and which nodes is "constructor nodes", if you see what i mean
21:04:06 <Nisstyre> twoshot_: he means the various standards for Haskell
21:04:17 <copumpkin> however, the datatype contexts are useless
21:04:42 <mzero> dmwit: sure it is: http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-680004.2
21:04:50 <twoshot_> Nisstyre, I thought it was standard :/
21:05:09 <dmwit> You're right, it is legal H98 and H2010.
21:05:09 <Nisstyre> (documents)
21:05:11 <dmwit> So that's odd.
21:05:11 <augur> ski: im not sure i'd say that. we have a pretty good notion of which nodes are function nodes and which are constructor nodes. its just that you can reuse nodes.
21:05:29 <mzero> okay - so I'm not sure what is going on - but the thing I pasted, which is a reformatting of what twoshot_ pasted, is legal Haskell 98 and legal Haskell 2010
21:05:34 <ski> augur : ok, ty for the clarification
21:05:47 <twoshot_> mzero, why does that confuse you?
21:05:48 <dmwit> Yes. And it's also an error in GHC 7.2.2.
21:06:00 <dmwit> twoshot_: Because of the last sentence I just wrote. =)
21:06:06 <twoshot_> ah ok :)
21:06:14 <mzero> dmwit: how could that be an error? GHC 7.2.2 no longer accepts legal haskell by default?
21:06:15 <dmwit> twoshot_: GHC is supposed to implement H98 and H2010, depending on which version you have and which one you ask for.
21:06:16 <mzero> :-)
21:06:21 <twoshot_> cutting edge programs never work perfectly htough
21:06:28 <dmwit> mzero: That statement seems to be correct.
21:06:41 <augur> ski: i actually have one way of defining it that basically is just normal trees indexed "head identities" (so that different copies of the same word are recognized as "shared" in some sense), and also indexed by proofs that fully saturated subtree for that head word is the same across all subtrees
21:06:53 <mzero> perhaps this is why 7.2 was considered experimental - and not for production release?
21:07:20 <twoshot_> probably
21:07:29 <augur> ski: that has some interesting consequences, namely, you end up with trees "in contexts" where the contexts look roughly like multisets of all the fully saturated subtrees
21:07:33 <dmwit> mzero: I don't believe the GHC folks intend to re-enable support for it by default.
21:07:47 <dmwit> mzero: At least according to the error message. =)
21:07:48 <mzero> ? I can't believe that
21:08:16 <ski> augur : hm, does this means that *all* copies of a word are recognized as "shared", or only ones which actually are forced to be the same, by the linearization of the AST ?
21:08:20 <dmwit> mzero: "Warning: -XDatatypeContexts is deprecated: It was widely considered a misfeature, and has been removed from the Haskell language."
21:08:33 <rwbarton> wishful thinking?
21:08:38 <dmwit> indeed
21:08:54 <augur> ski: only the ones that result from copying. so consider a sentence like "who saw who", where you have two _distinct_ instances of the word "who"
21:08:55 <ski> augur : that sounds interesting, but i'm not quite sure how you mean
21:09:06 <Axman6> what did DatatypeContexts  do?
21:09:08 <ski> augur : ty, good :)
21:09:24 <dmwit> Axman6: e.g. data Num a => Foo a = Foo a
21:09:37 <augur> ski: underlyingly we'd say this is probably something like (who_x, (who_y, (who_x, (saw, who_y)))) where the lower copies get treated as bound variables when mapped into the semantics
21:09:38 <Axman6> ah, yeah, definitely a misfeature
21:09:39 <dmwit> It doesn't work as well as you might expect it to.
21:09:47 <mzero> Hmph! Well - a) while I agree with the sentiment, b) it seems twoshot_ has an instructor that requires poorly defined data types --- SO - twoshot_ just go ahead and add the flag when compiling if your using 7.2 -- or install 7.0.x
21:10:12 <twoshot_> mzero, I'm going to install 7.0.x. Linux is almost installed
21:10:18 <augur> ski: in that, each occurrence of who_x is "shared", but its unrelated to the occurences of who_y
21:10:20 <dmwit> Yes, absolutely. Or add the pragma, which is easier.
21:10:35 <twoshot_> also, why is this channel so hw friendly?
21:10:40 <ski> augur : ok, so basically `(who,\x -> (who,\y -> (x,(saw,y))))', then :)
21:10:50 <dmwit> twoshot_: I don't see anybody doing homework for you (yet).
21:10:53 <rwbarton> It seems that http://www.haskell.org/ghc/docs/latest/html/users_guide/bugs-and-infelicities.html#vs-Haskell-defn has not been updated recently
21:10:54 <augur> ski: or consider a more complex one:   ((which_x, student_y), (did, (john, (see, (which_x, student_y)))))
21:11:19 <twoshot_> dmwit, yeah but normally people hear the mention of hw and start attacking you
21:11:21 <dmwit> Dealing with the vagaries of a particular compiler hardly seems central to the lesson embodied by this homework.
21:11:28 <ski> (that's a question, yes ?)
21:11:39 <augur> ski: this shows what i mean by the fully saturated subtree: every occurance of which_x must combine with student_y. its no good combining it with student_y in one place and teacher_z in some other place
21:11:51 <augur> ski: yeah its a question: "which student did John see?"
21:11:54 <twoshot_> but i understand what you mean, and i agree with it
21:12:00 <mzero> huh.... the 7.2.2 manual says that extension is on by default: http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#datatype-contexts
21:12:33 <dmwit> Empirically, the manual is wrong. So perhaps there is a chance they'll re-enable it in 7.4.
21:12:36 <dmwit> File a bug. =)
21:12:58 <ski> augur : when you use `did' here, it makes it harder for me to follow the structure. could you make an example without it, that still contained your point ?
21:13:02 <augur> ski: so if you wanted to do this indexing the trees, you index each tree with a Map Nat [Nat], or something like that, so the tree for just "(which_x, student_y)" is something like { x -> [y], y -> [] }
21:13:03 <twoshot_> while im waiting for linux to install, what would be a real world application for haskell?
21:13:10 <twoshot_> that someone would actually write nowadays
21:13:28 <dmwit> twoshot_: Browse hackage.
21:13:34 * ski ponders
21:13:36 <twoshot_> dmwit, ?
21:13:49 <augur> ski: the map for (see_z, (which_x, student_y)) would be  { z -> [x], x -> [y], y -> [] }
21:13:59 <dmwit> twoshot_: http://hackage.haskell.org/packages/archive/pkg-list.html
21:14:04 <dmwit> ?wiki haskell in industry
21:14:04 <lambdabot> http://www.haskell.org/haskellwiki/haskell_in_industry
21:14:23 <twoshot_> cool thanks
21:14:24 <augur> ski: and so on. and then you can freely take any two trees indexed thusly and put them together in a branch, provided their maps unify
21:14:28 <mzero> twoshot_: web servers - music composition - data analysis - program analysis - just to name a few
21:15:04 <dmwit> The ones I use the most are ghc, darcs, and xmonad.
21:15:11 <augur> ski: so if you tried to do   (which_x, teacher_w) + (... (which_x, student_y)),   the map for the left tree would be { x -> [w], w -> [] }, and for the right tree would it { x -> [y], y -> [], ... }
21:15:18 <ski> augur : hm, iiuc, you can think of "Who ate the cheese ?" as having basically the same structure as "John ate the cheese." except that the latter as "John" filled in instead of "Who"
21:15:26 <augur> ski: and obviously they dont unify since x -> [y] does not unify with x -> [w]
21:16:00 <augur> ski: actually we think of the who as still having been displaced: (who, (C, (who, (ate, (the, cheese)))))
21:16:29 <Axman6> @hoogle file
21:16:30 <lambdabot> Prelude type FilePath = String
21:16:30 <lambdabot> System.IO type FilePath = String
21:16:30 <lambdabot> System.FilePath.Windows type FilePath = String
21:16:35 <Axman6> @hoogle openfile
21:16:36 <lambdabot> System.IO openFile :: FilePath -> IOMode -> IO Handle
21:16:36 <lambdabot> GHC.IO.Handle.FD openFile :: FilePath -> IOMode -> IO Handle
21:16:36 <lambdabot> System.Posix.IO OpenFileFlags :: Bool -> Bool -> Bool -> Bool -> Bool -> OpenFileFlags
21:16:40 <ski> augur : applying this for "Which student did John see ?" we seem to get e.g. "Pekka did John see." which we can simplify to "John did see Pekka." or "John saw Pekka." -- is this correct ?
21:17:06 <augur> ski: actually its even worse, we think the structure of that is REALLY this:   (who, (C, (who, (T, (who, ((ate, v), ((the, cheese), (AgrO, (ate, (the, cheese))))))))))
21:20:04 <ski> augur : i can't say i can follow even why you said `((which_x, student_y), (did, (john, (see, (which_x, student_y)))))' before : why `(which_x, student_y)' at that place in the right part ?
21:20:31 <ski> i.e. i don't understand the basic example properly, so i have a hard time following your AST suggestions
21:22:42 <augur> ski: because we think its constructed like so:    see + which student => john + see (which student) => did + john (see (which student)) => which student + did (john (see (which student)))
21:23:41 <augur> ski: the theory is such that things are "merged" into the position where they get semantic interpretation, and then "moved" into other positions (possibly where they get more semantic interpretation)
21:24:21 <ski> `did' here seems a it to me like a `flip', that changes the order of the objects, so that the object which we omit would come first
21:24:40 <ski> s/a it/a bit/
21:24:52 <byorgey> augur: hmm, relevant? p. 47 of BLL says that the computation of generating series for the species of preorders and posets is an open problem.
21:25:26 <byorgey> now, (a) maybe someone solved it since then and (b) dags are not quite the same as posets
21:25:29 <twoshot_> ok i'm off to boot into my new linux system. be back in a few
21:26:16 <augur> ski: thats called "do support". i actually left that bit out of the really compelx tree i showed you, but the idea goes something like this:
21:26:39 <ski> augur : i.e. "John saw {which student}" => "John did see {which student}" => "{which student} did John see" => "Which student {omitted} did John see ?"  -- does this make sense ?
21:26:43 <byorgey> oh, no, if we knew the series for posets we could recover that for dags using  Poset = Dag(E)
21:27:00 <augur> ski: T is where tense morphology lives. in english questions, the T morphology raises to combine with the C head (the thing that specifies what kind of clause it is)
21:28:01 <ski> augur : cf. `foo x = bar x baz' => `foo x = flip bar baz x' => `foo = flip bar baz' (maybe it's a far-fetched comparision, though)
21:28:22 <augur> ski: if the tense morphology is "next to" the verb-y thing, then it can combine with the verby thing like normal, as in  "who saw john", where the tense is still next to the verb in the relevant sense: who Tense see John
21:28:49 <augur> ski: but if the tense morphology is ever separated from the verb, you pronounce it as "do": who Tense john see => who did john see
21:29:49 <augur> ski: this also is how you get other subject-aux inversion: "will" is a tense head   john will see who => will (john _ see who) => who whil (john _ see _)
21:29:54 <ski> s/verb-y thing/VP/ ?
21:30:05 <byorgey> augur: I suppose you can view dags as equivalence classes of  L x (p [] p^2)  structures, i.e. a cllection of edges superimposed on a linear ordering of the nodes
21:30:09 <augur> or also   who will see john => will (who _ see john) => who will (_ _ see john)
21:30:28 <augur> byorgey: thanks, ill check out that page.
21:30:38 <byorgey> and you consider equivalence up to reorderings of nodes which don't switch the direction of any edges
21:30:43 <augur> byorgey: hmm
21:30:51 <byorgey> nut I don't know how satisfying that is.
21:30:54 <byorgey> *but
21:31:00 <augur> ski: what you're suggesting is more like the categorialist approach
21:31:45 <ski> augur : i (possibly incorrectly) interpret "do" there as a way to *rewrite* the sentence to *make* the "verb-y thing" come next to the "tense morphology"
21:32:06 <augur> ski: for the CGers, "do"/"did", etc really is just a widget like you suggest
21:32:22 <ski> "CG" here is ?
21:32:28 <augur> ski: categorial grammar
21:32:31 <ski> (not "Computational Geometry", i'm sure)
21:32:35 <ski> ah, right
21:32:50 <byorgey> Computer Graphics
21:32:56 <byorgey> Common Gateway
21:33:23 <byorgey> Corrupt Gnomes
21:33:43 <augur> ski: we transformationalists have different analyses stemming from chomsky. we prefer to not have 10 different words that look the same but have different type signatures, or to have words that lift the tense morphology, and so forth.
21:34:03 <augur> ski: we'd rather say that the words move around, and that they get pronounced this way or that for other reasons
21:35:54 <ski> well, some kind of raisings are obvious -- i'm assuming you speak of variations which are not obvious
21:36:21 <augur> what do you mean some kinds of raisings are obvious
21:36:53 <twoshot_> Does version 6.12.1 work? That's what it pulled from the repository
21:37:10 <Axman6> ew
21:37:11 <twoshot_> (standby while i try)
21:37:59 <Axman6> that's pretty ancient
21:38:35 <augur> ski: in general i think the categorialists would say that did : (NP -> S) -> NP -> S   (or more accurately, (S\NP)/(S/NP) which encodes directionality)
21:38:35 <mzero> twoshot_: 6.12 should work fine if all you're doing is basic Haskell work (I'm guessing problem sets?)
