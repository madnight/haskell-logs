00:01:14 <hpaste> wavewave annotated ‚ÄúCannot deduce instance‚Äù with ‚ÄúCannot deduce instance (annotation)‚Äù at http://hpaste.org/55114#a55115
00:01:33 <wavewave> cedricshock : this seems to work.
00:02:20 <cedricshock> wavewave: yep, that's what I did.
00:02:41 <edwardk> shachaf: i would like to belatedly also recommend the combinatorial species book
00:03:03 <shachaf> edwardk: Hah, all recommendations noted. :-)
00:03:07 <edwardk> or moving to boston, where i can loan it to you ;)
00:03:40 <shachaf> They have it at the Stanford library.
00:03:47 <shachaf> Although, hmm, it's checked out right now.
00:03:47 <wavewave> edwardk: what's the title of the book?
00:04:19 <wavewave> Ahh.. I got it.
00:04:58 <shachaf> Maybe I should find out who checked it out.
00:05:20 <shachaf> I wish they let *me* check out books. As it is I have to go to the library to read them, in the library, at the library hours.
00:06:32 <shachaf> copumpkin: (This is your cue to insert a "#firstworldproblems".)
00:08:13 <copumpkin> #firstworldproblems
00:08:49 <russellw> shachaf, in my day we had to go to the library to discover that a book was checked out ;)
00:09:46 <copumpkin> back in my day, we had no libraries and we had to carry heavy clay tablets around everywhere with us to write on
00:10:06 * shachaf was born in the age of light clay tablets.
00:10:25 <russellw> Clay tablets? You lucky bastard!
00:10:28 <russellw> etc :)
00:10:34 <copumpkin> I skipped the papyrus :P
00:11:02 <copumpkin> "back in my day, we didn't even have writing! we had to track down people who had memorized the content and wait for them to recite to us, memorizing it as they did so"
00:11:51 <shachaf> "back in my day, there was no knowledge! so all this business was unnecessary"
00:12:20 <etpace> k/window 3
00:12:25 <etpace> oops
00:12:34 <shachaf> etpace: Alt-3. :-)
00:15:18 <etpace> shachaf unfortunately ive gotten used to xmonad mod key being alt
00:15:28 <shachaf> etpace: Bind that to mod4.
00:16:00 <etpace> unfortunately, my xmonad is a bit borked and ghc cant find its libraries and it wont recompile
00:16:07 <etpace> (even though the libs are in ghc-pkg)
00:17:10 <mauke> how many ghcs do you have?
00:17:54 <etpace> just one I believe
00:18:13 <mauke> what does 'ghc-pkg check' say?
00:19:04 <etpace> Complains of broken: MissingH, HTTP-4000 and hslogger
00:22:39 <etpace> note tthat :m + XMonad workds, but :m + XMonad.Config.GNome doesnt, even though xmonad-0.10 and xmonad-contrib-0.10 is in same package.conf
00:22:59 <mauke> how does it fail?
00:23:27 <etpace> Cannot find module `XMonad.Config.Gnome'
02:42:23 * hackagebot smallcheck 0.6 - A property-based testing library  http://hackage.haskell.org/package/smallcheck-0.6 (RomanCheplyaka)
02:46:35 <VeXocide> hi, given two lists I want to generate all interleavings of the items in the lists such that the order of those in the original lists is preserved, like http://codepad.org/3EfSmn0A
02:46:50 <VeXocide> but I can't manage to figure it out, could someone lend me a hand?
02:47:27 * hackagebot test-framework-smallcheck 0.1 - Support for SmallCheck tests in test-framework  http://hackage.haskell.org/package/test-framework-smallcheck-0.1 (RomanCheplyaka)
02:49:26 <ski> VeXocide : hm, i would try using the list monad for nondeterminism
02:49:53 <ski> you can probably reason your way to a solution in any case, but i think thinking about this monadically makes it simpler
02:50:17 <ski> at each step, you either draw an element from the one list, or the other list (assuming both are non-empty)
02:50:51 <ski> (so it's a little like a `merge' function)
02:51:35 <haruki_zaemon> hi all
02:51:44 <haruki_zaemon> I'm trying to execute a file via ghci
02:51:52 <haruki_zaemon> it has one statement: let x = 1
02:51:58 <haruki_zaemon> but I get: parse error (possibly incorrect indentation)
02:52:05 <haruki_zaemon> what am I doing wrong? :(
02:52:25 <mauke> haruki_zaemon: that's not a valid statement
02:53:12 <haruki_zaemon> does ghci treat files different to interactive?
02:53:15 <mauke> yes
02:53:21 <haruki_zaemon> ahhh!!!
02:53:25 <haruki_zaemon> thanks :)
02:53:29 <mauke> you can't just put '2 + 2' in a file either
02:53:33 <k0ral> hi, if you had to name the function f = flip $ maybe (return ()), which name would you choose ?
02:53:38 <Axman6> ghci is basically a sort of modified IO monad
02:53:47 <mauke> s/IO monad/do block/
02:53:57 <Axman6> yeah, that's what i was after
02:54:02 <haruki_zaemon> mauke thanks. I actually modified a whole program to make it more like ghci interactive and wondered why it wouldn't work LOL
02:54:10 <Axman6> one christmas party and a weekend and i've forgotten everything
02:54:26 <haruki_zaemon> Axman6 right, thanks!
02:54:29 <haruki_zaemon> makes perfect sense now
02:55:30 <VeXocide> ski, I was drawing from both, which might have been the problem
02:55:33 <VeXocide> let me try this
02:58:47 <ski> @type flip (maybe (return ()))
02:58:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe a -> (a -> m ()) -> m ()
02:58:48 <VeXocide> ski, thanks, http://codepad.org/AtYemimr does the trick (though it can probably be cleaned up)
02:59:23 <ski> k0ral : `forMaybe_'
03:01:51 <VeXocide> ski, if you know any ways to clean it up it'd be greatly appreciated, it's my third day using Haskell in years :+
03:02:07 <haruki_zaemon> mauke Axman6 thanks!
03:02:28 * hackagebot shake 0.0 - Build system creator  http://hackage.haskell.org/package/shake-0.0 (NeilMitchell)
03:04:50 <ski> VeXocide : that code looks correct :D
03:05:29 <ski> VeXocide : instead of using `concat (map blah bleh)', you can use `concatMap blah bleh' ..
03:06:19 <VeXocide> ski, ah!
03:06:20 <ski> VeXocide : but wait, the result of the lambdas are always singletons (single-element lists), so if you remove the singletons there, returning the element directly, you can elide the `concat's at the same time
03:07:29 * hackagebot hbro 0.7.1.0 - A minimal KISS compliant browser  http://hackage.haskell.org/package/hbro-0.7.1.0 (koral)
03:07:30 <ski> btw, instead of using `interleave (x:xs) (y:ys) = ...' and then in `...' using `x:xs' and `y:ys', you can say `interleave xs0@(x:xs) ys@(y:ys) = ...' and then use `xs0' and `ys0' instead of `x:xs' and `y:ys' in `...'
03:08:01 <ski> VeXocide : finally, in the base cases, i would rename `x' and `y' to `xs' and `ys'
03:08:54 <VeXocide> ski, I'm at http://codepad.org/qVyPb3vM without the xs0@(x:xs)
03:09:01 <VeXocide> definitely better, thanks!
03:14:12 <ski> VeXocide : oh, i forgot to say one thing, you can simplify `[element] ++ list' to `element : list' -- however it's up to you which you find clearest
03:14:21 <ski> (go with the one which is clearest to you)
03:24:41 <k0ral> ski: I can't get to what extend forMaybe_ makes sense, could you please enlighten me ?
03:25:14 <Binsh> Hey guys. Im getting this error : "  The last statement in a 'do' construct must be an expression" in this code : http://hpaste.org/55119 and i cant find the error. Can anyone help me out? :)
03:26:18 <ski> k0ral : well, maybe `forMaybeM_' would be somewhat better
03:26:21 <ski> consider
03:26:25 <ski> @type mapM_
03:26:26 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
03:26:35 <ski> and
03:26:37 <ski> @type forM_
03:26:38 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
03:26:49 <ski> (`for_' is just `flip mapM_')
03:27:05 <ski> what you want is basically the same thing, but with `Maybe a', instead of `[a]'
03:27:09 <fsgxdroid> can somebody help me with following code:
03:27:10 <hpaste> fsgxdroid pasted ‚Äúdiagonalize problem‚Äù at http://hpaste.org/55120
03:27:16 <fsgxdroid> Couldn't match expected type `Int -> [Int]'
03:27:39 <ski> k0ral : also see
03:27:40 <ski> @type Data.Foldable.for_
03:27:41 <lambdabot> forall (t :: * -> *) a (f :: * -> *) b. (Data.Foldable.Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
03:27:59 <ski> which is a generalization of both `forM_' and your `forMaybeM_' thing
03:28:48 <ski> (btw, note that the `forMaybeM_' name would better correspond to renaming `forM_' to `forListM_' -- but `forM_' is what it's named now)
03:29:04 <iainm> hey Binsch. I'm no expert, but try putting return statements at the start of lines 4 and 7
03:29:10 <k0ral> ski: very interesting, thank you
03:29:46 <iainm> I think that should get you to a problem about readFile needing to be Handle -> IO [String]
03:30:24 <k0ral> ski: shouldn't forM_ be (Monad m, Monad m') => m a -> (a -> m' b) -> m' () ?
03:30:34 <k0ral> (basically m a instead of [a])
03:30:57 <ski> k0ral : no
03:31:03 <Binsh> iainm: ok, thx, ill give it a try
03:32:14 <k0ral> ski: but you've just said forM_ should actually be renamed to forListM_, so I thought I could generalize it
03:32:15 <ski> k0ral : the point is that you have some data structure containing a bunch of `a's, like having type `[a]' or `Maybe a' in your case, and you want to run a monadic action (for any monad whatsoever) for each element in the data structure (collection)
03:32:56 <ski> k0ral : yes, and `Data.Foldable.for_' is such a generalization, but it's not really good to generalize the `[]' and `Maybe' here into a monad (i think, at least)
03:33:26 <ski>   Data.Foldable.for_ :: (Foldable t,Applicative i) => t a -> (a -> i b) -> i ()
03:33:44 <ski> k0ral : note how that uses `Foldable' for the generalization of `[]' and `Maybe'
03:34:37 <k0ral> interesting, I'm gonna read more about that, thank you for your explanations and your patience
03:34:42 <ski> (and it also generalizes from `Monad' to `Applicative', since you don't really need `Monad' here -- but `Applicative' wasn't invented yet when `mapM',`mapM_',`forM',`forM_' were defined, which is why they use `Monad' instead of `Applicative')
03:36:35 <ski> k0ral : note that "morally" all monads are applicative functors (but for hysterical raisins, `Applicative' isn't a superclass of `Monad', like it ought to be, so sometimes you will have types `T' which are an instance of `Monad' but not of `Applicative' -- in those cases, you can very easily say `instance Applicative T where pure = return; (<*>) = ap' -- but you should nag the person who defined `T' to make that declaration)
03:37:15 <iainm> Binsh, sorry, return on line 4 would be wrong. Like the error says, you want to end each do block with a return. At the moment, the do block starting on line 3 ends with a return when ineof is true, but not otherwise. The do block starting at line 6 never ends with a return.
03:38:47 <k0ral> ski: I'm not able to understand everything you said but I'm working on that :) thank you again
03:39:11 <ski> k0ral : yw. if you wonder about anything in particular, just ask
03:41:22 <Binsh> iainm: I fixed it :) it was a identation error. It seemed like "do" wanted to be on a line by itself :S
03:41:57 <ddarius> Binsh: You are probably mixing tabs and spaces.
03:42:05 <ddarius> Or at least using tabs.
03:42:11 <Binsh> Im using tabs
03:42:32 <ddarius> Do you have your tab stops at 8 spaces?
03:42:38 <Binsh> 4
03:42:46 <ddarius> Then what you see is not what GHC sees.
03:43:00 <`Zerax`> Are you sure that fixes it? Unless I'm being completely dense there is a type error in what you pasted.
03:43:02 <ddarius> I recommend setting your editor to expand tabs to spaces.
03:43:15 <Binsh> Hmm okay, ill try it
03:43:42 <ski> Binsh : if you're using tabs for indentation, then you should make sure to (a) not use any spaces for indentation; (b) break line after every layout-introducing keyword (can be avoided in cases where you only have a single line in the layout-block)
03:43:50 <ciaranm> why isn't there a liftA0?
03:43:53 <Binsh> http://hpaste.org/55119
03:43:58 <Binsh> theres the working code
03:44:00 <ski> ciaranm : `pure' ?
03:44:12 <ciaranm> ski: yeah, but that's inconsistent
03:44:31 <ski> it's the same with `liftM0' being called `return'
03:44:41 <ciaranm> there should be both!
03:44:52 <ski> i suppose you could propose those as aliases
03:49:03 <ski> Binsh,`Zerax` : yeah, looks like having type errors to me, too
03:51:03 <ciaranm> is it just me, or does eitherM have its arguments in a silly order?
03:51:13 <ski> @hoogle eitherM
03:51:13 <lambdabot> No results found
03:51:30 <ciaranm> Data.Either.Unwrap
03:53:46 <ski> ciaranm : hm, agree
03:54:02 <ski> <The eitherM function takes an Either value and two functions which return monads. If the argument takes the form Left _ then the element within is passed to the
03:54:08 <ski> oops
03:54:10 <ciaranm> i keep trying to write the two functions first
03:54:15 <ski> <http://hackage.haskell.org/packages/archive/either-unwrap/1.1/doc/html/Data-Either-Unwrap.html>
03:54:23 <ski>   eitherM :: Monad m => Either a b -> (a -> m c) -> (b -> m c) -> m c
03:54:28 <ski> it ought to be
03:54:37 <ski>   eitherM :: Monad m => (a -> m c) -> (b -> m c) -> (Either a b -> m c)
03:54:41 <ski> for consistency
03:54:41 <ciaranm> yeah
03:55:05 <ski> (also, that order is often the one you want, when partially applying)
03:55:39 <alistra> @hoogle maybe
03:55:40 <lambdabot> Prelude data Maybe a
03:55:40 <lambdabot> Data.Maybe data Maybe a
03:55:40 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
03:55:44 <ski> (if you want the other order, you can probably in most cases use a `case' instead, without too much ugliness)
03:56:24 <ciaranm> really i want either to be a monad
03:56:35 <ciaranm> really really i want either to be a monad except sometimes on the left
03:58:03 <ski> `Either e' is a monad ?
03:58:24 <ciaranm> not for general e, no, which is the problem
04:00:56 <ski> well, <http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Data-Either.html> lists `Monad (Either e)' as an instance, with no constraint on `e'
04:01:39 <ski> (i agree that `instance Error e => Monad (Either e)' is sillyness)
04:03:19 <ciaranm> hrm. when did that happen?
04:03:35 <ski> i don't recall exactly
04:04:03 <ski> i suppose mine and others complaints about it finally took some hold
04:10:54 <`Zerax`> Never underestimate the power of complaining
04:21:00 <hpaste> fsgxdroid annotated ‚Äúdiagonalize problem‚Äù with ‚Äúdiagonalize problem (annotation)‚Äù at http://hpaste.org/55120#a55122
04:22:31 <fsgxdroid> i looking for help, i have almost working code which generates square-shaped list of lists of integers (a square matrix)
04:22:35 <fsgxdroid> http://hpaste.org/55120#a55122
04:34:35 <ski> fsgxdroid : hm, your original paste was mostly right
04:35:14 <ski> some type signatures are wrong, and one use of `++' is a bug
04:35:25 <ski> (and one piece of the code is missing)
04:36:54 <ski> fsgxdroid : if you prefer to think about the annotation, then : the basic problem is that  x' <- x, c <- [1..l]  will effectively by two nested loops, trying out element of `x' together with every possible value for `c' -- what you want is to make these two procees in "lockstep", not try every combination of them
04:43:16 <fsgxdroid> ski, ok, i'll try to go one with my first solution
04:47:02 <zhulikas> how can I translate "abƒócƒó" to "abece" ?
04:47:18 <zhulikas> or should I just use simple string replace
04:47:27 <zhulikas> or is there a way to change encoding or something
04:47:34 <zhulikas> for a given string
04:47:45 <zhulikas> ƒç -> c, ƒØ -> i
04:47:48 <zhulikas> these are baltic letters
04:47:59 <etpace> Does anyone know how haskell types mutually recursive functions? ie: foo = .. bar ..; bar = ... foo ...;? To get the type of foo we need bar, and vice versa.
04:48:13 <kmc> etpace, read _Typing Haskell in Haskell_, or read the Report itself
04:48:37 <kmc> you can construct some bizarre corner cases with mutually recursive type inference
04:48:39 <cheater> in an xml document such as "<foo><bar/></foo>" parsed by lib expat, would bar be accessed with /foo/bar or with /bar ?
04:48:42 <ski> etpace : infer most general type of the whole group, then genealize
04:49:18 <etpace> thanks, ill look into it
04:49:34 <ddarius> cheater: That's not an XML document.
04:49:45 <cheater> ddarius: i simplified. you know what i mean.
04:50:00 <etpace> "most general type" = foo :: alpha |- when typing bar, bar :: beta |- when typing foo and then unify the types with alpha and beta?
04:50:03 <ddarius> Presumably it would be /foo/bar
04:50:10 <ddarius> Why would it be /bar?
04:50:24 <cheater> ddarius: i'm looking for someone who has specific experience with expat based parsers
04:50:32 <cheater> because i have a parser here based on expat and it's /bar
04:50:34 <cheater> (which is incorrect)
04:50:54 <cheater> so i don't know if the error is in expat itself or in the code built on top of it
04:51:00 <ski> etpace : rather use `foo :: tau_0,bar :: tau_1' when typing both `foo' and `bar'
04:51:11 <kmc> etpace, you can turn your mutually-recursive set of bindings into a single recursive definition of a tuple
04:52:20 <ski> etpace : where `tau_0' and `tau_1' are fresh "logic variables", i.e. placeholders for concrete types, which will (possibly) be filled in by unification in the type inference algorithm (those that are not filled in, and which doesn't occur in the context will be generalized)
04:52:31 * hackagebot mime-mail 0.4.1.0 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.4.1.0 (MichaelSnoyman)
04:52:40 <etpace> aha, I was thinking about that
04:52:50 <ski> etpace : if you know about unification in logic programming, that can help understanding the process
04:52:52 <etpace> but I was wondering if I wanted it to be tau_1 or forall tau. tau
04:52:59 <ski> the former
04:53:23 <ski> you only generalize after having posted all the constraints
04:53:32 <etpace> aha, thanks
04:54:01 <ski> (and solved for the constraints, of course -- but a unification monad will usually do that automatically)
04:54:16 <etpace> sure
04:55:20 <etpace> I want to generalise my "type inference" monad at the moment, I'd like to be able to "compose" rules easily (adding effectful typing onto HM or something), so I think my current inferance moand (unification+fresness) needs a rerwrite
04:57:22 <ski> etpace : you might find "Polymorphic Type Inference" by Michael Schwartzbach in 1995 at <http://cs.au.dk/~mis/typeinf.pdf> interesting
04:59:46 <etpace> thanks a lot
05:07:00 <Binsh> ineof <- hIsEOF file gives me a [Bool], but it expects a IO Bool. The type of hIsEOF is Handle -> IO Bool. Anyone who knows whats wrong?
05:08:04 <Eduard_Munteanu> Binsh: can you paste some context?
05:08:35 <Eduard_Munteanu> Or the actual error?
05:09:05 <opqdonut> you probably try to use ineof as a list or something like that
05:09:05 <Binsh> Yeah
05:09:09 <Binsh> 2sec
05:09:10 <opqdonut> but it's hard to say without code
05:09:21 <Eduard_Munteanu> Yeah, or in the list monad.
05:09:40 <Binsh> http://hpaste.org/55119
05:09:41 <Binsh> the code
05:10:12 <opqdonut> your indentation looks pretty messed up
05:10:14 <Eduard_Munteanu> Binsh: your function's type is Handle -> [String]
05:10:40 <Binsh> Thats the only identation that works :P
05:10:51 <opqdonut> yeah it actually seems to work
05:11:06 <Binsh> Yeah, but
05:11:16 <Eduard_Munteanu> Binsh: hIsEOF belongs to the IO monad, you can't use it like that
05:11:17 <Binsh> does that have anything to say?
05:11:23 <Binsh> hmmmmmmmmkay
05:11:41 <opqdonut> rFile probably should be of type "Handle -> IO [String]"
05:13:43 <Binsh> hmmkay
05:13:56 <Binsh> that removed one error :P
05:14:24 <Eduard_Munteanu> Yeah, now you have to deal with the change in rFile's type in the caller
05:14:30 <opqdonut> http://hpaste.org/55119 <- I annotated that with a working version
05:14:35 <opqdonut> see if you understand the changes
05:15:00 <Eduard_Munteanu> Ah, other stuff required changes too.
05:15:08 <opqdonut> (the code could be much prettier but I did the minimal changes to fix it)
05:16:06 <Binsh> Nice. I really dont understand the changes. Why IO[String 9 instead of String
05:16:31 <Binsh> [String]
05:16:54 <Binsh> What is a IO [String]
05:16:57 <`Zerax`> The function you use to determine whether it is EOF returns an IO Bool, the do notation unwraps it, but before you return from the function you have to rewrap it in the IO Monad so it is typesafe.
05:17:07 <opqdonut> an IO [String] is an IO operation that returns a [String]
05:17:20 <opqdonut> just like IO Bool is an IO operation that returns a Bool
05:17:34 <Eduard_Munteanu> Binsh: because hIsEOF gives you an IO something; you can't "get the String out" in any sensible way. Do you understand IO?
05:17:42 <opqdonut> have you read LYAH? I recommend it.
05:17:44 <opqdonut> @where lyah
05:17:45 <lambdabot> http://www.learnyouahaskell.com/
05:18:21 <Binsh> yea, maybe i should.
05:18:38 <Binsh> Im pretty new to Haskell. :)
05:18:44 <ski> @wiki Introduction to IO
05:18:44 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
05:18:46 <opqdonut> IO is not hard, but it is more complex than writing pure code
05:18:49 <ski> Binsh : you can try that ^
05:19:08 <Binsh> ok, thx
05:19:36 <`Zerax`> I've never been convinced that using do-notation before understanding what it actually does is helpful for beginners.
05:20:24 <Binsh> hehe, its my first time using the do-notation
05:20:51 <ski> Binsh : "The IO Monad for People who Simply Don't Care" by Dan Piponi (dpiponi) at <http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html> might perhaps also be useful
05:21:19 <`Zerax`> @pl maybe False (const True)
05:21:20 <lambdabot> maybe False (const True)
05:21:22 <Binsh> ive been taking a course in functionl programming. weve never made a whole program, just some basic functions which weÊve been calling from ghci
05:21:26 <`Zerax`> hm
05:21:33 <Eduard_Munteanu> @undo do { y <- f x; g y; return y }
05:21:34 <lambdabot> f x >>= \ y -> g y >> return y
05:23:18 <VHD__> is there a way to compile haskell program so that the required dll automatically are copied into the compiling directory?
05:23:21 <ski> Binsh : possibly to shield you from having to learn how to use I/O (and more generally, monads), while learning basic things like immutable variables (no assignment), pattern-matching, iteration using recursion, the type system, &c.
05:23:26 <donri> the irony http://darcsden.com/alex/highlighter/browse/src/Text/Highlighter/Lexers/Haskell.hs
05:24:26 <Eduard_Munteanu> VHD__: you might be able to produce a statically-linked executable, not sure how that works on Windows (I'm guessing that's your intended platform).
05:24:41 <VHD__> yes that it is.
05:24:45 <`Zerax`> Works better on Windows than Linux ;)
05:24:50 <cheater> donri: lol
05:26:07 <Eduard_Munteanu> VHD__: you might want to try passing   -static -optc-static -optl-static   to ghc.
05:26:14 <Binsh> ski: yeah, that might be why :)
05:26:38 <VHD__> hmm ok I will try that
05:26:39 <Binsh> ski: it looks kinda messy, but maybe ill get the time to learn it soon
05:26:41 <Eduard_Munteanu> (-static might not be needed, GHC does static linking against *Haskell* libs by default, or did)
05:27:05 <Eduard_Munteanu> VHD__: so it won't copy the dlls into the target dir, but it will embed them into the executable directly.
05:27:16 <ski> Binsh : it's actually quite nice and powerful, once you learn it :)
05:27:19 <VHD__> yeah that would be good enough
05:28:00 <mauke> > 4 ‚àó 5
05:28:03 <lambdabot>   21
05:28:05 <hpc> Binsh: http://blog.ezyang.com/2011/11/how-to-read-haskell/ -- doesn't teach you to write IO code, but teaches you to read it; might help a bit in lieu of having time to learn it correctly
05:28:29 <ski> @quote best.imperative.language
05:28:30 <lambdabot> SPJ says: Haskell is the world's best imperative language.
05:28:42 <mauke> > 2 ‚àó 8
05:28:44 <lambdabot>   22
05:28:47 <hpc> ski: he is 100% right, imo
05:29:19 <Eduard_Munteanu> In certain ways, perhaps.
05:29:39 <mauke> > 3 ‚àó 10
05:29:41 <lambdabot>   37
05:30:13 <mauke> > 2 ‚àó 12
05:30:15 <lambdabot>   34
05:30:15 <Eduard_Munteanu> mauke: a * b + (b - a)?
05:30:38 <mauke> hmm
05:30:40 <Eduard_Munteanu> > 12 ‚àó 1
05:30:42 <lambdabot>   1
05:30:45 <Eduard_Munteanu> > 12 ‚àó 2
05:30:47 <lambdabot>   14
05:33:32 <alistra> > 5*5
05:33:33 <Eduard_Munteanu> Anyway, I'm not entirely convinced it's worth putting up with jumping through all those hoops if you want to write or translate imperative code.
05:33:34 <lambdabot>   25
05:33:43 <wereHamster> @t ?
05:33:44 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
05:34:10 <Eduard_Munteanu> (assuming we're talking about "really imperative" code :))
05:34:53 <Eduard_Munteanu> > 5 ‚àó 5
05:34:53 <ski> @help type
05:34:53 <lambdabot> type <expr>. Return the type of a value
05:34:55 <lambdabot>   25
05:35:29 <ski> @type [("cat",True),("dog",False)]
05:35:30 <lambdabot> [([Char], Bool)]
05:35:52 <wereHamster> @type (?)
05:35:53 <lambdabot> Not in scope: `?'
05:43:37 <Cale> http://oleksandrmanzyuk.wordpress.com/2011/12/10/on-the-applicative-structures-of-monads/ -- anyone else read this? :)
05:45:26 <hpc> Cale: neat
05:46:38 <byorgey> gwern: so now I can mention again that the GHC-plugins work (from 2008) has been merged into GHC
05:46:41 <Cale> It points out the fact that we often do neglect the other instance of Applicative that every Monad has.
05:47:12 <Eduard_Munteanu> Hm.
05:48:28 <ddarius> Cale: Of course we do.
05:48:58 <Eduard_Munteanu> So I guess that rules out a sensible, default   instance (Monad m) => Applicative m
05:49:26 <Cale> ddarius: Is there an obvious reason to do it? :)
05:50:26 <Cale> I guess the fact that the execution order of the one we focus on corresponds better with lazy evaluation order :)
05:51:04 <ddarius> Cale: Most people would find it unexpected.  Heck, it causes enough trouble in C and C++.h
05:51:20 <Cale> C++.h? :)
05:51:34 <ddarius> On the other hand, I don't think it is -too- common for Haskell code to rely on the particular definition of liftM2.
05:51:59 <ddarius> No, I take that back.
05:52:13 <ddarius> Using the other instance of Applicative would totally screw a lot of code.
05:56:05 <hpaste> fsgxdroid annotated ‚Äúdiagonalize problem‚Äù with ‚Äúdiagonalize problem (final version)‚Äù at http://hpaste.org/55120#a55128
05:58:41 <fsgxdroid> is it a good solution for a following haskell code?: http://hpaste.org/55120#a55128
06:04:52 <byorgey> fsgxdroid: looks pretty good
06:05:08 <fsgxdroid> :)
06:06:00 <byorgey> my only suggestions would be (1) come up with a better name for diagonalize'' (any more than a single prime is too many IMO) and (2) note the hlint suggestion at the bottom.
06:06:52 <byorgey> fsgxdroid: I seem to recall you used to have : and we told you to change it to ++.  But I think that was because you had specified the wrong type so it wasn't clear what you were trying to do.
06:07:06 <byorgey> but anytime you have  [foo] ++ bar  that is better written as  foo : bar
06:07:26 <ddarius> length, blech
06:08:16 <ddarius> There's a solution that pretty directly models the Perl example that is quite a bit clearer.
06:09:40 <byorgey> ddarius: hmm, how would you do that? (without using (!!)) ?
06:12:34 * hackagebot fix-parser-simple 15319.1 - Simple fix-expression parser  http://hackage.haskell.org/package/fix-parser-simple-15319.1 (MatthewFarkasDyck)
06:12:53 <ddarius> > let diagonalize xs = [[if i == j then a else 0 | (i, x) <- zip [0..] xs] | j <- zipWith const [0..] xs] in diagonalize [3,29,14] -- zipWith const for shachaf (I think)
06:12:54 <lambdabot>   [[a,0,0],[0,a,0],[0,0,a]]
06:13:04 <ddarius> > let diagonalize xs = [[if i == j then x else 0 | (i, x) <- zip [0..] xs] | j <- zipWith const [0..] xs] in diagonalize [3,29,14] -- zipWith const for shachaf (I think)
06:13:05 <lambdabot>   [[3,0,0],[0,29,0],[0,0,14]]
06:13:37 <byorgey> oh, with a parallel list comprehension, nice
06:13:49 <ddarius> It's not a parallel list comprehension.
06:13:58 <ddarius> @. pl undo [[if i == j then x else 0 | (i, x) <- zip [0..] xs] | j <- zipWith const [0..] xs]
06:14:00 <lambdabot> [0..]
06:14:00 <byorgey> oh, whoops, I didn't see the ]
06:14:20 <ddarius> Hmm.  That was not what I expected lambdabot to say.
06:14:30 <ddarius> @undo [[if i == j then x else 0 | (i, x) <- zip [0..] xs] | j <- zipWith const [0..] xs]
06:14:31 <lambdabot> concatMap (\ j -> [concatMap (\ (i, x) -> [if i == j then x else 0]) zip [0 ..] xs]) zipWith const [0 ..] xs
06:14:47 <ddarius> Bad pretty printer probably.
06:15:08 <ddarius> @. pl undo [[if i == j then x else 0 | (i, x) <- (zip [0..] xs)] | j <- (zipWith const [0..] xs)]
06:15:09 <lambdabot> ((zip [0..] xs >>=) . (`ap` snd) . (. fst) . flip flip [] . ((flip . ((:) .)) .) . flip flip 0 . ((flip . if') .) . (==)) `fmap` zipWith const [0..] xs
06:15:15 <ddarius> That is more like it.
06:16:40 <ddarius> > let diagonalize xs = join (liftM2 (\(i,x) (j,_) -> if i == j then x else 0)) (zip [0..] xs) in diagonalize [3,29,14]
06:16:41 <lambdabot>   [3,0,0,0,29,0,0,0,14]
06:16:49 <ddarius> Ah yeah.
06:16:55 * byorgey would probably solve it using  down :: f a -> f (a, Diff f a),  but that would certainly not be clearer for a beginner...
06:17:56 <fsgxdroid> alright guys, i have no idea what are you talking right now :) anyway, i updated my function names and replaced "++" with ":"
06:17:58 <hpaste> fsgxdroid annotated ‚Äúdiagonalize problem‚Äù with ‚Äúdiagonalize problem (another version)‚Äù at http://hpaste.org/55120#a55129
06:19:31 <ddarius> > let diagonalize xs = [[if x == y then x else 0 | x <- xs] | y <- xs] in diagonalize [3,29,14] -- optimizing for size over correctness
06:19:33 <lambdabot>   [[3,0,0],[0,29,0],[0,0,14]]
06:20:17 <fsgxdroid> nice
06:20:33 <byorgey> fsgxdroid: not to be too picky, but "recursion" is not much better than "diagonalize''".  ;)  Neither tells me anything at all about what the function is for.
06:20:49 * ddarius suggests "go."
06:21:23 <byorgey> fsgxdroid: what you have named "recursion" is what you used to call "diagonalize'".  I think diagonalize' was a fine name for that.
06:21:53 <fsgxdroid> byorgey: alright, i will change that
06:21:59 <byorgey> because it was just a recursive helper for diagonalize.
06:22:20 <Eduard_Munteanu> diag/diagonal sounds a bit better IMO, 'diagonalize' could mean something else.
06:22:40 <byorgey> Eduard_Munteanu: however, it looks like the name is specified by the assignment.
06:22:49 <Eduard_Munteanu> Ah, nevermind then.
06:23:28 <hpc> @let diagonalize xs = [[if x == y then x else 0 | x <- xs] | y <- xs]
06:23:29 <lambdabot>  Defined.
06:23:38 * ddarius would probably call the top level function, "diagonal."
06:23:50 <ddarius> "Diagonalize" makes me think of something else entirely.
06:24:07 <byorgey> something like   fmap up . (fmap . second . fmap) (const 0) . down
06:24:08 <hpc> > let identity n = diagonalize (replicate n 1) in identity 3
06:24:09 <lambdabot>   [[1,1,1],[1,1,1],[1,1,1]]
06:24:13 <ddarius> hpc: You do realize that that is wrong?
06:24:25 <Eduard_Munteanu> Yeah, Gaussian elimination and what not.
06:24:26 <DasIch> can anyone help me out with this type error http://paste.pocoo.org/show/519300/ ? i tried reproducing it in ghci but it works flawlessly if I load the file with main commented out
06:24:28 <mah_b> @run diagonalize [1,1,1]
06:24:30 <hpc> oh lol
06:24:30 <lambdabot>   [[1,1,1],[1,1,1],[1,1,1]]
06:25:03 <hpc> @undefine
06:26:44 <byorgey> DasIch: the error message is a good one.  GHC is complaining because it doesn't know what type you want to use as input to testLog2.
06:27:08 <byorgey> DasIch: try writing  quickCheck (testLog2 :: Int -> Property)  (or whatever type you want to use)
06:27:30 <DasIch> byorgey: ah that works
06:29:07 <DasIch> byorgey: ok, so ghc doesn't know which type to choose that makes it ambiguous and ghc complains but why does it work in ghci?
06:29:14 <k0ral> I can't find any cryptanalysis tool written in Haskell, I'm thinking of implementing one myself, do you think it's a useful project ?
06:29:27 <mauke> DasIch: you said you had main commented out
06:29:42 <ddarius> k0ral: Only to cryptographers at best.
06:29:44 <DasIch> mauke: yeah but executing quickCheck testLog2 in ghci works
06:29:50 <mauke> DasIch: ghci defaults harder
06:30:05 <Eduard_Munteanu> What does a cryptanalysis tool do anyway?
06:30:10 <lukish> Solving ex13 http://blog.tmorris.net/20-intermediate-haskell-exercises/ . If I have banana :: (x -> m y) -> (m x) -> (m y) and need to build apple :: (m a) -> m (a -> b) -> (m b), I can say that all I need to do is get (x -> m y) from (m a) and m (a -> b)
06:30:19 <lukish> But I cannot understand how.
06:31:03 <DasIch> mauke: ah, good to know
06:31:09 <DasIch> thanks guys :)
06:31:25 <Saizan> lukish: you won't use the (m a) argument for that, but for the (m x) argument
06:31:41 <ddarius> lukish: Learn Prolog.
06:32:33 <mauke> ah, we have unicorn
06:32:34 <mauke> good
06:32:50 <k0ral> Eduard_Munteanu: provide a framework to assist anyone trying to decrypt a ciphertext
06:32:55 <mauke> and even jellybean
06:33:31 <lukish> mauke: are ther usable in defining apple?
06:33:36 <mauke> yes
06:34:24 <byorgey> k0ral: it sounds like a fun project.  Whether it is useful depends on your definition of useful.
06:35:07 <k0ral> byorgey: 1/ does it already exist ?
06:35:20 <hpaste> fsgxdroid annotated ‚Äúdiagonalize problem‚Äù with ‚Äúdiagonalize problem (yet another version) is it optimal?‚Äù at http://hpaste.org/55120#a55130
06:35:37 <k0ral> byorgey: as far as I looked, I couldn't find any modern, open-source and sustainable solution
06:35:56 <k0ral> byorgey: 2/ does it solve a problem ?
06:36:21 <lukish> mauke: how should I solve that exercies? For example I have arg1 :: (m a), arg2 :: m (a -> b). Should I build some expression use them like arguments to other function to have (m -> b) finally?
06:36:28 <fsgxdroid> i can't understand the part of "replicate (j-1)" why variable "j" is not 0 in first time
06:36:35 <mauke> lukish: huh?
06:37:17 <mauke> oh wait, I've been thinking in the wrong direction
06:37:43 <mauke> that just makes it easier
06:37:47 <mauke> (still need unicorn, though)
06:38:29 <byorgey> fsgxdroid: the expresion (l - c)  is used to compute j, where l is the length of the list and c is an index
06:39:00 <byorgey> fsgxdroid: note that the index starts counting from 0.  so in the last case the index will be (l - 1), hence j = l - (l - 1) = 1
06:39:51 <byorgey> fsgxdroid: it might be better to call zeros with (l - c - 1) instead of (l - c), since that is a more meaningful value
06:39:55 <byorgey> then you don't need the (j-1)
06:40:05 <Cale> lukish: There's a kind error there...
06:40:26 <hpaste> fsgxdroid annotated ‚Äúdiagonalize problem‚Äù with ‚Äúdiagonalize problem (yet another version) is it optimal? (annotation)‚Äù at http://hpaste.org/55120#a55131
06:41:34 <Cale> lukish: m is clearly of kind * -> * in your first two types, because 1) it's taking a -> b as a type parameter, and a -> b is a type of kind *, and 2) m (a -> b) is the type of a value, so must have kind *
06:42:48 <Cale> lukish: but in m -> b, it is the first parameter to (->) which has kind * -> * -> *, and so needs to be kind * there
06:44:21 <fsgxdroid> why it is not possible to replace "++" to ":" in following: "replicate i 0 ++ [x] ++ replicate j 0" => "replicate i 0 : x : replicate j 0"
06:44:36 <fsgxdroid> sorry for the stupid question :)
06:44:38 <hpc> fsgxdroid: because the types don't work out
06:44:43 <hpc> :t (:)
06:44:44 <lambdabot> forall a. a -> [a] -> [a]
06:44:50 <hpc> :t (Prelude.++)
06:44:51 <lambdabot> forall a. [a] -> [a] -> [a]
06:45:08 <hpc> fsgxdroid: in uses of (x ++ y), x and y must be the same type
06:45:20 <hpc> in (x : y), x must be the same type as the ELEMENTS of y
06:45:37 <hpc> if you try and switch one out for the other without changing anything else about the code, you get an infinite type error
06:45:55 <hpc> because it tries to solve the type equation (a = [a])
06:46:17 <Cale> fsgxdroid: whenever you have x : xs, x must be of an appropriate type to be an element of the list xs
06:46:38 <Cale> fsgxdroid: Because x:xs forms a new list where x is the first element, and xs is the tail of the list
06:46:42 <mauke> @let harmony = map var ["honesty", "kindness", "laughter", "generosity", "loyalty", "magic"]
06:46:43 <lambdabot>  Defined.
06:47:02 <Cale> (Just to say what hpc said again :)
06:47:03 <hpc> > harmony
06:47:04 <lambdabot>   [honesty,kindness,laughter,generosity,loyalty,magic]
06:47:21 <hpc> :t var
06:47:23 <lambdabot> forall a. String -> Sym a
06:47:24 <hpc> oh right
06:48:00 <Cale> fsgxdroid: Do our explanations make sense? :)
06:48:29 <fsgxdroid> Cale, not very much but I really try to understand :)
06:49:53 <fsgxdroid> thinking in functional programming language is much harder than in non-functional: perl, java etc...
06:49:57 <mauke> fsgxdroid: ++ concatenates two lists. : doesn't.
06:50:20 <fsgxdroid> but what about "zeros x c (l-c-1) : diagonalize' xs l (c+1)"
06:50:27 <fsgxdroid> why it is useful to use it there...
06:50:44 <hpc> fsgxdroid: in that case, we are dealing with lists of lists
06:50:50 <fsgxdroid> my first solution was " [zeros x c (l-c-1)] ++ diagonalize' xs l (c+1)"
06:50:58 <fsgxdroid> or smth like that...
06:50:59 <mauke> fsgxdroid: [x] ++ y is the same as x : y
06:51:02 <ski> fsgxdroid : it's possibly not so much harder as being different : i.e. a bit like learning programming again from scratch
06:51:34 <fsgxdroid> mauke, ok... that make sens
06:51:49 <mauke> : adds a single element to the front of a list
06:51:51 <fsgxdroid> mauke, its like shorthand?
06:52:05 <mauke> ++ adds multiple elements to the front of a list
06:52:15 <mauke> ++ is just a helper function that calls : for each element
06:52:39 <hpc> @src (++)
06:52:39 <lambdabot> []     ++ ys = ys
06:52:39 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
06:52:39 <lambdabot> -- OR
06:52:39 <lambdabot> xs ++ ys = foldr (:) ys xs
06:53:06 <hpc> fsgxdroid: a good exercise is to figure out why that first definition of (++) works
06:53:11 <hpc> @src []\
06:53:12 <lambdabot> Source not found. Maybe if you used more than just two fingers...
06:53:13 <hpc> @src []
06:53:14 <lambdabot> data [] a = [] | a : [a]
06:55:12 <saati> how does ghc know [] a is [a]? is this one specific thing hardcoded?
06:55:30 <hpc> saati: yeah
06:55:45 <hpc> saati: tuples are magic too, and so is (->)
06:56:00 <ski> > [0,1,2] :: [] Integer
06:56:01 <lambdabot>   [0,1,2]
06:56:10 <lukish> Cale: so what should I do with that kind error?
06:56:14 <hpc> iirc, that's all the magic types, with the rest being just unboxed stuff
06:57:34 * hackagebot tagsoup 0.12.6 - Parsing and extracting information from (possibly malformed) HTML/XML documents  http://hackage.haskell.org/package/tagsoup-0.12.6 (NeilMitchell)
06:57:42 <ski> (well, types with syntactic sugar forms)
06:58:45 <hpc> tuples could be defined in haskell if ',' was a capital symbol
06:59:13 <hpc> and it would be really nice if tuples didn't need parens and just became type-level lists
06:59:15 <ski> well, only if you iterate them, no ?
06:59:54 <hpc> yeah, nothing larger than a 2-tuple could be defined
07:00:00 <hpc> but i pretend those don't exist anyway
07:00:17 <ski> what should the kind of `(:,)' be ? `* -> [*] -> [*]' ?
07:00:47 <ski> (also requiring say a `Tuple :: [*] -> *' thing)
07:01:02 <hpc> i was more thinking, data (:,) a b = a :, b
07:01:04 <ddarius> (->) is more magic than tuples or lists.
07:01:07 <hpc> with appropriate fixity
07:01:29 <hpc> then (a :, b :, c) == (a :, (b :, c))
07:01:52 <ski> hpc : yeah, but if you want to do multi-arity tuples, you need to decide more things
07:02:27 <ski> e.g. if you create a tuple where one of the elements is a tuple, should that be "flattened" ?
07:02:39 <ski> maybe only if it's the last tuple element ? (why only that one ?)
07:02:47 <vrook> Why is [1,2] >>= replicate 3 legal? [1,2] is not a monadic type and replicate 3 doesn't return a monadic type.
07:02:52 <Cale> lukish: Well... what do you actually mean? :)
07:03:00 <hpc> ski: you are overcomplicating things
07:03:11 <Cale> vrook: The list type constructor is a monad.
07:03:21 <hpc> ski: it would just be a totally ordinary type that associates just like (->)
07:03:28 <lukish> Cale: you're trying to say, that exercise is incorrect?
07:03:28 <Cale> (>>=) :: [a] -> (a -> [b]) -> [b]
07:03:30 <hpc> (a -> b -> c) == (a -> (b -> c))
07:03:36 <ski> vrook : `[1,2]' isn't a type at all. the point is that the type of it is `[Integer]' (well, really `[a]' where `a' is in `Num', but that's irrelevant to the point, here)
07:03:39 <Cale> lukish: Which exercise is this?
07:03:40 <hpc> and (a, b, c) == (a, (b, c))
07:03:44 <lukish> Cale: 13
07:03:48 <Cale> of what?
07:03:58 <lukish> Cale: http://blog.tmorris.net/20-intermediate-haskell-exercises/
07:03:59 <hpc> ski: when i said "type-level list", i was being extremely informal
07:03:59 <ski> vrook : and the type `[Integer]' is syntactic sugar for `[] Integer', and `[]' *is* a monad
07:04:04 <ski> @type replicate
07:04:06 <lambdabot> forall a. Int -> a -> [a]
07:04:11 <Cale> okay...
07:04:37 <Cale> lukish: No, that exercise is correct, just how you represented it here is incorrect
07:04:40 <mauke> lukish: no, you made a typo when you wrote the type here
07:04:43 <ski> vrook : also, the return type here is `[a]', i.e. `[] a', and `[]' is still a monad, so it *does* return something of a monadic type
07:05:11 <lukish> Cale: mauke: ok.
07:05:47 <Cale> There are (at least) two natural solutions to defining that 'apple'
07:07:06 <lukish> Cale: if x :: m (a -> b) , what type will have (jellybean x)?
07:07:15 <vrook> Cale: where did you get (>>=) :: [a] -> (a -> [b]) -> [b] ?
07:07:22 <vrook> > :t (>>=)
07:07:23 <lambdabot>   <no location info>: parse error on input `:'
07:07:25 <ski> hpc : yeah, it's just not clear to me why the last position in a tuple should be privileged in that way
07:07:33 <vrook> :t (>>=)
07:07:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:07:38 <Cale> vrook: By replacing each m in the general type of (>>=) with the list type constructor
07:07:44 <dropdrive> Is it possible to write a "sum" function that adds (a->b->Double) to (a->b->Double) as well as (a->Double) to (a->Double)?
07:08:06 <ski> @type (>>=) :: [a] -> (a -> [b]) -> [b]
07:08:07 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
07:08:15 <ski> vrook : presumably he typed it in by hand
07:08:20 <Cale> dropdrive: It's possible to write an instance (Num a) => Num (e -> a) which makes the usual sum function do that
07:08:41 <Cale> lukish: type error
07:08:47 <Cale> lukish: well...
07:08:55 <ski> > ((*) + (/)) 2 3
07:08:56 <Cale> lukish: unless m = (->) a
07:08:56 <lambdabot>   6.666666666666667
07:09:13 <Cale> lukish: in which case jellybean x :: a -> b
07:09:14 <ski> dropdrive : yeah, `instance Num a => Num (rho -> a)'
07:09:17 <Cale> and x :: a -> a -> b
07:09:21 <vrook> OK I finally get it -- :i [] gives this: instance Monad [] -- Defined in GHC.Base
07:10:02 <ski> dropdrive : since `Num' unfortunately requires `Eq' and `Show', you have to fake those, though
07:10:38 <lukish> Cale: whole problem with that exercies, that I can't understand how can I use m (a -> b) to get m b
07:11:01 <dropdrive> Cale: Thanks.
07:11:03 <lukish> I can't get (a -> b) from m (a -> b)
07:11:27 <dropdrive> ski: Thanks.  When I declare that instance, what is the scope of its effect?
07:11:30 <vrook> are there any other sugarings apart from [Foo] ?
07:11:35 <ski> lukish : you can get from `s -> t' to `m s -> m t', though ..
07:11:55 <ski> dropdrive : the whole program
07:12:17 <Cale> lukish: Suppose x :: m (a -> b), and you write x >>= f. What is the type of f's parameter?
07:12:21 <mauke> lukish: you sort of can (locally), with banana
07:12:23 <Cale> oh sorry
07:12:34 <Cale> lukish: Suppose x :: m (a -> b), and you write banana f x. What is the type of f's parameter?
07:13:05 <ski> lukish : now, ponder what happens if `s' here is `a -> b' ..
07:13:09 <Cale> (I honestly hate the "cute" choices of names in those exercises.)
07:14:27 <danr> Cale: yeah I think the pedagogical point of it is not worth it
07:14:54 <danr> especially if you want to use bananas and apples or grapefruits infix
07:15:05 <lukish> Cale: m (a -> b) -> m b
07:15:14 <Cale> lukish: nope
07:18:11 <lukish> Cale: what did you mean "type of f's parameter"?
07:19:04 <lukish> Type of (a -> m b) when I supply it with x :: m (a -> b) ?
07:20:18 <vrook> ski: If you remember our macro dsl conversation, I think we were making it much more complicated than it is. It's easy to add dsl macros which are defined in terms of other dsl macros. https://gist.github.com/1461193
07:20:31 <`Zerax`> Yes, they're type variables, if x were actually Maybe ( Int -> Bool ) what would the type of f be.
07:21:13 <dgpratt> lukish: Suppose x :: m (a -> b), and you write banana (\y -> ...) x. What is the type of y?
07:21:17 <fsgxdroid> i need to write a function shifts that produces all cyclic shifts of a given list i.e: shifts "abC" => ["abC","bCa","Cab"]
07:21:19 <fsgxdroid> > let shifts (x:xs) = take (length x') (x' : shifts x') where x' = xs ++ [x]
07:21:21 <lambdabot>   not an expression: `let shifts (x:xs) = take (length x') (x' : shifts x') w...
07:23:17 <fsgxdroid> i want to first list to be "abC" but in my code, first list is "bCa"
07:23:18 <lukish> dgpratt: (a -> b) -> (m b)
07:23:39 <`Zerax`> You have your solution
07:24:19 <hpaste> cedricshock pasted ‚ÄúTypeable and deserialization: Can getStaticAnnotationByType be written without referenceing Instance1 or Instance2‚Äù at http://hpaste.org/55132
07:27:25 <lukish> `Zerax`: have I?
07:28:05 <Cale> The type 'a'
07:28:34 <lukish> `Zerax`: I apply m (a -> b) to second banana argument and have :: ((a -> b) -> m b) -> m (a -> b) -> m b
07:28:43 <cedricshock> The closest I've been able to find to an answer to the question posed by my paste is http://okmij.org/ftp/Haskell/class-based-dispatch.lhs I also remember seeing an instance for some serialization given Data and Typeable, but I can't find one anywhere.
07:28:43 <Cale> lukish: You may want to rename some type variables while doing this because the overlapping senses of a and b will get confusing
07:28:49 <lukish> Where is (m a) in all that stuff.
07:29:38 <lukish> Okay, let's say, that in old function signatures there are x and y instead of a and b
07:32:58 <dgpratt> lukish: for clarity, you are supposing that banana :: (x -> m b) -> m x -> m y, correct?
07:33:09 <Cale> cedricshock: What... problem are you trying to solve here? :)
07:33:12 <dgpratt> err...
07:33:36 <lukish> dgpratt: (x -> m y) -> m x -> my
07:33:38 <dgpratt> missed one: banana :: (x -> m y) -> m x -> m y
07:33:48 <dgpratt> lukish: ok
07:34:13 <dgpratt> lukish: so, per Cale's example, x :: m (a -> b)
07:34:20 <lukish> Than I "applied" second argument with m (a -> b).
07:34:40 <lukish> And have ((a -> b) -> m b) -> m (a -> b) -> m b
07:34:56 <lukish> And cannot see any m a there
07:34:57 <dgpratt> and we are doing: banana (\y -> undefined) x
07:35:20 <dgpratt> and the question is: what is the type of y
07:35:34 <Cale> lukish: Remember what you originally asked me though...
07:35:48 <dgpratt> to avoid confusion, how about: banana (\p -> undefined) x, what is the type of p
07:35:49 <Cale> lukish: That you couldn't figure out how to get m b from m (a -> b)
07:35:57 <Cale> lukish: but look at the type you just wrote :)
07:36:06 <lukish> dgpratt: p :: ((a -> b) -> m b)
07:36:19 <dgpratt> lukish: not quite
07:36:48 <lukish> dgpratt: m b
07:37:00 <Cale> lukish: so if you can construct a function (a -> b) -> m b from the other stuff that you have, then you can construct a function m (a -> b) -> m b as you wanted
07:37:11 <cedricshock> Cale: Say I have a typeable, serializable data type a0 that can be used to create a non serializable data type b0, and then I have the existential quantification over all a0 that can produce a b0. Now I have a type for some subset of b0 that can be produced from a piece of serialized data. On deserialization I'd need to call the deserializer for a specific a0.
07:37:38 <dgpratt> lukish: so if x is passed as the second param to banana (:: m x), what does the type parameter x 'specialiaze' to...err...become?
07:38:06 <lukish> dgpratt: a -> b
07:38:12 <dgpratt> lukish: right
07:39:00 <dgpratt> lukish: so type parameter x represents (a -> b) everywhere in the type of banana now...
07:39:26 <lukish> dgpratt: yes.
07:39:38 <dgpratt> lukish: so the type of the first parameter to banana becomes?
07:40:00 <lukish> dgpratt: so (banana (\p -> undefined) x) :: m b
07:40:18 <lukish> But how can it help
07:40:53 <`Zerax`> Look at your solution to Exercise 6.
07:40:59 <dgpratt> lukish: what is now the specialized type of the first parameter to banana?
07:41:33 <dgpratt> lukish: was  :: (x -> m y), is now?
07:41:33 <lukish> dgpratt: (a -> b) -> m b
07:41:41 <dgpratt> lukish: right
07:42:19 <dgpratt> so if we pass (\p -> undefined) as that first parameter, what is the type of p?
07:43:20 <lukish> dgpratt: it will be first parameter of (a -> b) -> m b, so (a -> b)
07:43:29 <dgpratt> lukish: right
07:44:40 <vrook> Is [] monadic because order matters for lists?
07:45:04 <opqdonut> no
07:45:14 <lukish> dgpratt: so?
07:45:27 <opqdonut> the [] type has been hijacked to represent the nondeterminism / multiple results monad
07:45:47 <exFalso> good afternoon
07:46:09 <exFalso> can anyone suggest a serialisation library other than Binary?
07:46:17 <donri> cereal, safecopy
07:46:24 <exFalso> (we need the unconsumed input)
07:46:36 <exFalso> thanks i'll check those out!
07:47:56 <donri> actually safecopy is built on top of cereal, adding versioning (think db migrations)
07:48:12 <dgpratt> lukish: lemme bring up the full example, hold on a minute
07:49:24 <exFalso> hmm no custom error types i guess it's exception time again :D
07:54:33 <dgpratt> lukish: ok, so apple :: (Misty m) => m a -> m (a -> b) -> m b
07:55:10 <dgpratt> and we already said that x :: m (a -> b)
07:55:29 <dgpratt> lukish: do we have a name for the first parameter, yet?
07:56:35 <augur> oh wow
07:56:42 <augur> there are so many X sort in Y folk dance videos
07:56:56 <lukish> dgpratt: what is name for the first parameter?
07:58:53 <dgpratt> lukish: I was asking if you had one in mind; let's call the first parameter y and the second x, because we already are thinking of x :: m (a -> b)
07:59:50 <dgpratt> so so far we have: apple y x = banana (\p -> undefined) x, right?
07:59:57 <lukish> Than y :: m (a -> b)
08:00:01 <lukish> If it's second
08:00:25 <dgpratt> lukish: I'm calling y as the first parameter, so y :: m a
08:00:32 <lukish> Sorry, ok
08:01:00 <vrook> mapM_ f lst -- if lst is used only for this mapM_, does ghc optimize away the construction of the lst?
08:01:19 <lukish> (banana (\p -> undefined) x) :: m b
08:01:31 <lukish> So, it's the answer?
08:01:34 <dgpratt> lukish: right
08:02:05 <dgpratt> lukish: so what do we have in hand, we have a (y :: m a) and a (p :: (a -> b))
08:02:33 <dgpratt> lukish: do we have something that can make an (m b) from those pieces?
08:02:51 <lukish> apple _ = banana (\p -> undefined) compiled well
08:03:22 <dgpratt> lukish: yes, undefined aka bottom, so not a valid solution
08:04:31 <lukish> dgpratt: furry'
08:04:54 <dgpratt> lukish: yes!
08:05:04 <lukish> (furry' p y) :: m b
08:05:17 <dgpratt> lukish: ding!
08:06:21 <lukish> So, we should put it in lambda with \p?
08:06:29 <dgpratt> lukish: I would
08:09:13 <lukish> dgpratt: well, great.
08:09:30 <dgpratt> lukish: indeed, nice job
08:09:52 <lukish> So what is main advices to solving that kind of exercises?
08:10:06 <dgpratt> lukish: take it very slowly and carefully
08:10:30 <dgpratt> lukish: you figured everything out yourself, we just walked you through it
08:11:08 <`Zerax`> Always look to break down such problems in terms of what you already know, many of the parts of the solution you had already solved, you just needed to put them together.
08:11:20 <lukish> That might be true. But when I see signature of function need to build I don't know how to start/
08:11:59 <dgpratt> I have to run, ttfn
08:12:44 <mateu> I realize whitespace is important in the layout of a haskell file, but I'm finding an example that is dependent on the amount.
08:12:55 <hpaste> mateu pasted ‚ÄúAmount of indent space make a difference?‚Äù at http://hpaste.org/55133
08:15:41 <ddarius> mateu: where opens a block of layout.  Everything in that where block needs to be indented more than the first non-whitespace character following the where.  In this case the body of you do block is less indented than mainWith.
08:15:49 <dropdrive> > (repeat 1) == (repeat 2)
08:15:50 <lambdabot>   False
08:15:53 <dropdrive> > (repeat 1) == (repeat 1)
08:15:57 <lambdabot>   mueval-core: Time limit exceeded
08:15:58 <mateu> hmm maybe it's require to line up with mainWdith
08:16:11 <dropdrive> > let x = repeat 1 in x == x
08:16:12 <ddarius> mateu: No, it's required to be more indented than mainWith.
08:16:14 <lambdabot>   mueval-core: Time limit exceeded
08:16:19 <Marian> is it possible to get the type of a function at runtime (like :type in ghci)
08:16:51 <ddarius> mateu: If it's less indented, as in your second example, you are closing the where block.  If it is equally indented, you are declaring another function within the where block.
08:17:10 <parcs> Marian: yes, with Data.Typeable.typeOf
08:17:18 <mateu> ddarius: thanks that makes some sense
08:17:25 <Marian> ok cool thanks
08:19:56 <ddarius> mateu: I would tend to write something akin to your first example, but you could put a newline after the where and then you could start mainWith anywhere on the line except in the very first column.
08:21:07 <ddarius> I use four space indents though, so I only lose one level by my convention.
08:21:56 <Marian> parcs: mh that works for integers and lists an such, but for functions it says Ambiguous type variable `a' in the constraint:      `Typeable a' arising from a use of `typeOf`
08:22:53 <ski> Marian : how are you using `typeOf' ?
08:23:08 <Marian> ski: typeOf map, for example
08:23:32 <ski> > typeOf (map :: (Int -> Bool) -> ([Int] -> [Bool]))
08:23:33 <lambdabot>   (Int -> Bool) -> [Int] -> [Bool]
08:24:08 <ski> the problem is not that you can't use `typeOf' on functions
08:24:22 <ski> Marian : what is the real code that you want to use this in ?
08:25:02 <ski> (to clarify, you *can* use `typeOf' on functions)
08:25:23 <dropdrive> ski: So what can you use typeOf for?
08:25:51 <ski> you can use `typeOf' on any value which has a type in the type class `Typable'
08:26:37 <ski> i suppose usually `typeOf' is for printing out the type of some value
08:26:56 <Marian> ski: ah I can only use it after I told haskell what a,b etc are?
08:27:00 <ski> there's also other functions that are requiring `Typable', such as `cast'
08:27:03 <ski> @type cast
08:27:03 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
08:27:39 <hpaste> ciaranm pasted ‚Äúparsec hates me‚Äù at http://hpaste.org/55134
08:27:55 <ciaranm> ^^ i am utterly confused. why does it barf when i uncomment the opLetter line?
08:27:59 <Marian> > typeOf lines -- that works, fine
08:28:00 <ski> Marian : well, either Haskell must be able to infer that the type of the argument to `typeOf' is in fact in `Typeable' -- if it can't do that on its own, because of ambiguity, you have to help it, like i did with `map' above
08:28:01 <lambdabot>   [Char] -> [[Char]]
08:28:13 <ski> > typeOf not  -- here no type ascription "helping" is needed
08:28:14 <lambdabot>   Bool -> Bool
08:28:26 <sam6> In haskell, is it possible for a function to have an internal list of Integers and whenever I call the function, it removes the first value in the list and returns it?
08:28:31 <Marian> ski: can I make it return such "a" stuff like :type does?
08:28:36 <ski> (and this is because `not' is not a polymorhic function)
08:28:50 <ciaranm> sam6: no (at least not the way you describe it)
08:28:57 <Marian> ski: yeah, got it
08:28:58 <ski> Marian : no, `typeOf' only handles monomorphic types
08:29:02 <sam6> is there a way to achieve something similar?
08:29:08 <donri> state monad
08:29:10 <ciaranm> sam6: State monad
08:29:12 <ski> so, i had to choose some monomorphic instance of `map' above
08:29:29 <Marian> okay, I'll see if that works in my code
08:29:42 <ski> Marian : *usually* (not always) you are using a monomorphic instance, when you're using a polymorphic function, so this tends not to be a problem that often
08:30:13 <sam6> so I was looking into State monad and I'm not sure if I have to make a state for each of the entry in the list
08:30:24 <sam6> I'm not sure if I am understanding it correctly but...
08:30:27 <Marian> ski: I want to do some debugging output, so as I cannot print a function I thought I'd print its type
08:30:35 <ciaranm> sam6: do you understand monads?
08:30:47 <sam6> I understand maybe and list monads
08:31:04 <ciaranm> iirc lyah explains the state monad fairly clearly
08:31:07 <sam6> I read briefly about state monads but not quite sure yet
08:31:41 <donri> http://haskell.org/haskellwiki/All_About_Monads#The_State_monad
08:31:58 <mateu> ddarius: interesting, I was able to start mainWith in the first column (expected something to blow up)
08:32:41 <rwbarton> you made an empty where block, and mainWith is at top level
08:33:17 <rwbarton> so if mainWith referred to an argument of main (impossible of course, as there aren't any) something would have blown up
08:33:23 <mateu> is there a way to warnings for this type of stuff (e.g defining an empty block)
08:34:58 <xxx_man> ski: hi
08:36:14 <ski> Marian : ok, so you need to ensure that in every case you use it, the function type is known, monomorphic, and an instance of `Typable' -- do you have any particular example where you have trouble with this ?
08:36:28 * mateu tries hlint but no warnings.
08:37:44 <ski> Marian : note that if you're doing a polymorphic function, which takes a function as argument which includes type variables, then to be able to do this, you need to add `Typable' as a constraint for those type variables -- without that, there need not be any type information left when the function executed, from which `typeOf' could construct the result to print
08:38:02 <ski> @let grab :: MonadPlus m => StateT [t] m t; grab = StateT (\as -> case as of [] -> mzero; a:as -> return (a,as))
08:38:03 <lambdabot>  Defined.
08:38:09 <ski> @let runAffine :: Monad m => StateT [t] m a -> [t] -> m a; runAffine = evalStateT
08:38:10 <lambdabot>  Defined.
08:39:00 <saati> is there something like [a] -> a -> [[a]] in the lib? a more generic version of lines/words
08:39:03 <ski> > do {x <- grab; let {y = x^2}; xs <- replicateM 4 grab; return (xs,y)} `runAffine` [3,6 ..]
08:39:04 <lambdabot>   No instance for (GHC.Show.Show (m ([t], t)))
08:39:04 <lambdabot>    arising from a use of `M592...
08:39:12 <aavogt> @hackage split
08:39:12 <lambdabot> http://hackage.haskell.org/package/split
08:39:42 <ski> > do {x <- grab; let {y = x^2}; xs <- replicateM 4 grab; return (xs,y)} `runAffine` [3,6 ..] :: [([Integer],Integer)]
08:39:43 <lambdabot>   [([6,9,12,15],9)]
08:39:47 <saati> aavogt: thanks
08:40:01 * ski only now notices sam6 left
08:41:06 <Stevo> hey guys, currently working on a college assignment which involves a implementation on a 234 tree in haskell and was wondering if has anyone much experience with this? specifically the data type definition I have one idea of how it could be done but im aware of another one
08:41:56 <ddarius> mateu: I don't think it is a problem that comes up enough for effort to be put in warning about it.
08:42:02 <ddarius> mateu: You can try -Wall though.
08:42:25 <augur> hmm
08:43:32 <augur> is this a good explanation for the "call by name" and "call by value" distinction: CBV is using the values in the denotation of types, CBN uses expressions of that type?
08:43:55 <augur> so that expressions are "names" for values?
08:46:09 <ski> in CBV, only values are substituted for variables; in CBN, every expression (including the value expressions) can be substituted for variables
08:46:41 <ski> (this is a syntactic, not semantic way to think about it)
08:47:13 <augur> ya
08:47:14 <augur> ok.
08:47:21 <ski> augur : i'm not sure what you mean by "values in the denotation of types"
08:47:37 <augur> ski: fair enough :)
08:47:46 <augur> im just looking for ways to remember which means which
08:47:47 <ski> you can also consider the difference in a denotational way
08:47:57 <augur> i always need to look this up in wikipedia
08:48:03 <augur> there are too many call-by-X's :(
08:48:32 <Stevo> nobody have any tips on 234 trees :(
08:48:49 <ski> in CBV, the denotations of value expressions need only contain normal "values" in the domain we're mapping into -- so the environment will map variable identifiers to such semantic values
08:50:25 <ski> however, in CBN, the environment will need to map variable identifiers to a domain which contains a `_|_' "value" (assuming our expressions can fail to terminate) -- similarly, if our expressions can have any other side-effect (cf. linguistic side-effects), the denotation of a variable in an environment will have to take that into account
08:50:40 <ski> augur : does that help ?
08:50:41 <ski> augur : ok
08:50:48 <augur> maybe!
08:50:55 <augur> i get the concepts
08:51:04 <augur> i just need a mnemonic to remember which concepts map to which names :)
08:51:11 <augur> and vicey vercey
08:51:13 <ski> ok
08:52:06 <ski> call-by-value is so called since in the reduction rule `(\x0. E1) V0  -->  E1 [x0 |-> V0]', `V0' is required to be a value expression
08:52:36 <dropdrive> Dumb question ... I can see how (a -> m b) is different from m (a -> b) for m = list or maybe, but what about for m = IO?  I can't figure out if they are different (or are they necessarily the same via the "obvious" way)?).
08:52:48 <ski> in call-by-name, this is generalized into `(\x0. E1) E0  -->  E1 [x0 |-> E0]' where `E0' is any expression whatsoever (so may contain unperformed side-effects)
08:53:30 <ski> dropdrive : you can always convert from `m (a -> b)' to `a -> m b', for any monad `m' -- the other direction isn't possible in general
08:53:58 <ski> dropdrive : in the specific case when `m' is `IO', that other direction is not possible
08:54:23 <ski> a way to see this : say you're given a function `T -> IO U'
08:54:26 <xxx_man> ski: second please
08:54:46 <ski> now this function may decide which I/O to do, depending on what value of type `T' is passed to the function
08:55:10 <ski> now, we wanted to construct from this something of type `IO (T -> U)'
08:55:14 <BMeph_> Stevo: Do you have a "bigger" question than "tell me how to do it"? Because from what you've said, you have at least two possible ways to do a data structure, and...haven't gone any farther. :)
08:55:25 <ski> this is something thatmay do some I/O before computing a function from `T' to `U'
08:55:50 <ski> so, this result will need to do all the I/O upfront, before even seeing the `T' input, and after seeing the `T' insput, it can't do any I/O
08:56:12 <ski> dropdrive : this should be some kind of explanation for why the reverse direction isn't possible with `IO'
08:56:28 <ddarius> a -> M b = call-by-value, M a -> M b = call-by-name
08:56:42 <Stevo> BMeph: The problem is that my data definition is quite vague and to be hoenst I don't know if it's right at all.  this is what i have for it but again chances are is that it's horribly wrong data Tree a = EmptyTree | Node [a] (Tree a) (Tree a) | Node [a] (Tree a) (Tree a) (Tree a) | Node [a] (Tree a) (Tree a) (Tree a) deriving (Show, Read, Eq)
08:56:51 <BMeph_> dropdrive: IO (a -> b) is like a system call. a -> IO b is like using the system call.
08:57:15 <dropdrive> ski: I think I see...will need to re-read several times.  Basically are you saying that in the a -> IO b example, you have to bind on every call, so there can be side effects every time?
08:58:13 <ski> dropdrive : for a concrete example, consider `(\prefix -> do s <- getLine; return (prefix ++ s)) :: (String -> IO String' -- this function will take a prefix as argument, (generate an action that will) get a line of input, and return that line, prefixed with the argument
08:58:39 <ddarius> dropdrive: A -> IO B is a function of A that determines an action.  You can have a different action for each function.  Replace IO with [] or Maybe and you should see a similar problem.
08:58:54 <ski> dropdrive : it's not possible to convert this to something of type `IO (String -> String)', since that would only do I/O once, before giving the function, instead of asking for the line each time the function was executed
08:59:01 <ddarius> s/each function/each value of A/
08:59:24 <BMeph_> Stevo: 1) More Dakka! (j/k ;) 2) different "Node" names for the number of subtrees 3) if you don't start off with something, you'll never know if it's "horribly wrong" or not 4) Haskell is make for playing around, so play! :)
08:59:34 <ski> augur : see ddarius' comment above, too
08:59:51 <augur> lolol
08:59:59 <augur> if only i knew what that meant!
08:59:59 <augur> :D
09:01:17 <Stevo> BMeph_: I guess one thing im unsure of is that since any node can have up to 3 data types within it IE (14,21,38) should that be represented in a list form? also i guess to make life easier name the nodes, NodeOne, NodeTwo,NodeThree =p always room for more Dakka Dakka
09:02:29 <ddarius> dropdrive: Consider Bool -> Maybe Int, one value of that type is \b -> if b then Just 1 else Nothing, there's no way to make a Maybe (Bool -> Int) that behaves the same, it would have to know to return Nothing before I even applied the function.
09:02:57 <dropdrive> ddarius: Yeah, I said above that I see why it's different for m = list or maybe, didn't quite get it for IO.
09:02:58 <ski> augur : you can translate a language with side-effects into one without, using e.g. monads. if you do the call-by-value translation, then a function of type `T -> U' will be translated to a function of type `T -> M U', where `M' is the monad that captures the effect; otoh if you do the call-by-name translation, functions of type `T -> U' will be translated to functions of type `M T -> M U', so to actually get a result from the argument, you ha
09:03:57 <ddarius> dropdrive: ioError "fragglerock" :: IO A for any type A.  Having an IO A doesn't mean you will ever actually be able to get an A.
09:04:04 <ski> Stevo : i think you wanted to have four (not three) `Tree a'-typed arguments to the last constructor, yes ?
09:04:20 <Stevo> ski: Yes sorry typo there
09:04:26 <ski> Stevo : btw, why do you have a list of elements directly in each node, instead of just a single element ?
09:06:42 <Stevo> ski: I said above that in each node you may not nessicarily have a single element you can have up to 3, so do i just instead of  [a] NodeTwo a a a (Tree a) (Tree a) and just ignore the fact that some of the elements may go unused? and yes logically thinking that probably makes more sense alas its been a while since iv sat down with haskell
09:08:06 <Cale> ski: your message above got cut off at "so to actually get a result from the argument, you h"
09:08:31 <ski> "so to actually get a result from the argument, you have to execute it, possibly getting a different value each time"
09:09:08 <ski> Stevo : may the number of elements in a node differ from the number of direct sub-trees, in every possibly combination of ways ?
09:09:52 <ski> Stevo : i think it probably makes sense to make different cases for the allowed number of elements in each node
09:10:40 <ski> (Stevo : and you should emphatically *not* make "some of the elements go unused" !)
09:11:06 <Stevo> ski: my understanding of it is that your capped at 3 per node , if you try to insert a fourth then the whole thing gets split in two
09:11:43 <Stevo> ski: it could get mesy if you have unique cases for each one you see or at least that's what i think
09:13:00 <xxx_man> ski: I uploaded in another server
09:13:16 <ski> Stevo : if the number of elements is independent of the number of direct sub-trees (all possibilities allowed), then you can make this in a simpler way
09:17:19 <shapr> gwern: Perhaps I could sign up for a GSoC to do tutorials, quickcheck/hunit tests and propaganda for under-used Haskell libraries?
09:17:30 <shapr> gwern: I was just reading http://www.gwern.net/Haskell%20Summer%20of%20Code#results-1
09:18:59 <Stevo> ski: well here is the way it apparently works. I want to create a try with the numbers (75,5,70,10) i insert 75 as the root, I then insert 5 in the root node (5,75) i then insert 70 into the root node (5,70,75) so the root node is now considered a 4 node when i go to add 10 we have to split  up the node and create our leafs
09:19:57 <Stevo> sli: and we get (5,10) <- (70 "Root") ->(75)
09:20:19 <statusfailed> How do 'inputs' work with the state monad? i.e. if you want your next state to depend on the current state and also input
09:20:39 <marens> i have built a hashtable from a list of (Char, [Char]) which contained multiple values for the same Char key, how can i lookup all the values in the hashtable? HashTable.lookup only show the one that was added last, HashTable.toList contains all the vlues again.
09:20:56 <statusfailed> would you just curry the state function to have your inputs first?
09:21:11 <marens> or is there a better datastructure i should use for that
09:21:25 <Stevo> ski: wikis definition is probably more clear "The numbers means a tree where every node with children (internal node) has either two children (2-node) and one data element or three children (3-node) and two data elements or four children (4-node) and three data elements."
09:22:01 <ciaranm> when using parsec's makeTokenParser, is there a good way of persuading it that newlines aren't whitespace?
09:23:43 <Stevo> ski: so this is what i have data Tree234 a = EmptyTree | NodeTwo a (Tree a) (Tree a) | NodeThree a a (Tree a) (Tree a) (Tree a) | NodeFour a a a (Tree a) (Tree a) (Tree a) (Tree a)  		deriving (Show, Read, Eq)
09:23:49 <ski> Stevo : ok, so the two numbers here are not independent, then
09:23:57 <Yrogirg> hello! what is the best (fastest or richest) haskell package for complex numbers?
09:24:18 <ski> Stevo : yes, that looks good
09:26:14 <byorgey> Yrogirg: Data.Complex is in base
09:26:33 <byorgey> Yrogirg: unless you're saying that does not have enough features for your needs.
09:27:12 <Yrogirg> ok, I'll look at it
09:27:21 <ddarius> ...
09:28:44 <ddarius> I'm not aware of any library for any programming language that advertises being a "fast" complex number library.
09:30:13 <byorgey> I suppose if you tried hard you could make a slow complex number library.
09:31:11 <copumpkin> Complex CReal
09:31:16 <copumpkin> there you go! I've made it slow for you
09:31:16 <ddarius> Complex was, ironically, one of the few areas the Report went out of its way to do the right thing with regards to strictness.
09:33:42 <donri> can you export qualified imports, such that the qualifier is kept?
09:33:47 <ddarius> No.
09:34:54 <donri> is do-notation a direct translation to the operators, even for a custom monad *class*?
09:35:46 <ddarius> donri: What else would it be?  However, it translates to qualified operators unless you have -XNoImplicitPrelude
09:36:34 <donri> certainly
09:37:00 <donri> thanks
09:38:23 <Stevo> ski: okay so with the 234 my intial steps are adding 3 elements to NodeThree at the start up so it ll always start off  like NodeThree 3 4 5 and then on the next insertion it gets split, i know for most other trees at the start up people have some sort of definition which is life single = Node x EmptyTree Emptyree should i still be looking at the same sort of approach?
09:42:12 <Stevo> ski: so something like singleNodeThree :: a -> Tree234 a   singleNodeThree x = NodeThree x _ _ EmptyTree EmptyTree
09:45:54 <copumpkin> what's an elegant way to do an "inactivity timeout" in haskell? I know about the timeout function, but that doesn't quite cover my use case: I'm receiving events over a socket and I'd basically like to bomb if I don't receive anything for a few seconds. I was thinking of forking an IO action with a timer in it followed by something that kills the connection, and then killing the threadId of the last one of those I did every time I receive a new
09:45:54 <copumpkin>  but that doesn't feel very clean
09:46:06 <copumpkin> is there a better approach?
09:46:19 <djahandarie> Have had the same problem myself, but don't remember coming up with a nice solution for it
09:47:06 <ski> Stevo : i think such a s `singleton' could be useful, yes
09:47:44 <ski> Stevo : but it shouldn't use `NodeThree' (you can't use `_' as a wildcard in expressions; and even if you could, you shouldn't)
09:47:49 <ddarius> copumpkin: Fork a thread, every time you receive an event over the socket, kick the dog to reset the timer.
09:48:14 <copumpkin> ddarius: so a Chan to the thread, and a timeout call on the chan read??
09:48:17 <ski> Stevo : in sort, `single' could be useful, `singleNodeThree' isn't
09:48:22 <rwbarton> copumpkin: you could do it without killing the watchdog thread, keep an MVar of the last time you got some data and have the watchdog sleep until n seconds after that time, if it's increased sleep again
09:48:28 <Stevo> ski: damn okay, but root will always start of having three elements though hmm =/
09:48:58 <ddarius> What rwbarton said, only you don't need an MVar really.
09:49:06 <ski> Stevo : i don't see why you couldn't have `NodeTwo a0 EmptyTree EmptyTree'
09:49:31 <Eduard_Munteanu> Well, select() can already use a timeout... perhaps some Haskell API exposes such a thing as well?
09:49:49 <copumpkin> ddarius: what would you use then?
09:49:55 <ddarius> copumpkin: An IORef.
09:49:57 <copumpkin> kickTheDog :: IO ()
09:50:13 <djahandarie> :: Dog ()
09:50:21 <djahandarie> type Dog = IO ???
09:50:21 <copumpkin> oh, so the message receiver updates the IORef and the killer thread looks at it periodically
09:50:28 <rwbarton> kick :: Dog -> IO ()
09:50:34 <rwbarton> yes
09:50:39 <copumpkin> seems simple enough
09:51:11 <ddarius> copumpkin: All you need is a bit, so you can clear the IORef when it wakes up if it was set.  If it was clear, kill the thread.  The thread sets the IORef.
09:52:35 * copumpkin wonders if watchdog :: Int -> IO () -> IO (IO (), IO ()) would be a good signature for it :P
09:52:51 <copumpkin> timeout, action to perform on timeout, then one IO action to kick the dog, the other to cancel the watchdog
09:52:57 <djahandarie> I remember getting some insanely strange issues with lazy I/O and timeout
09:54:04 <djahandarie> Broke all the STM guarantees
09:55:43 <ddarius> copumpkin: You could use the isomorphism (a,a) ~ Bool -> a
09:56:57 <copumpkin> ddarius: so calling the function with False would kill the watchdog, and with True would kick it?
09:57:00 <copumpkin> poor dog :(
09:57:18 <copumpkin> watchdog :: Int -> IO () -> IO (Bool -> IO ()) is a cute signature though
09:57:20 <c_wraith> True could be defined to tickle it instead of kicking it.
09:57:29 <copumpkin> tickle does sound nicer
09:57:35 <rwbarton> data DogFood = Biscuit | Poison
09:57:42 <djahandarie> Hahahahaha
09:57:42 <copumpkin> lol
09:57:47 <ddarius> There's a lot of different terms for patting the dog.
09:59:13 * ski idly wonders whether this watchdog can do apport
10:00:01 <ddarius> copumpkin: If you are going to hand one action to some manager thread and the other to a worker, your first interface may be better suited to it.  If the worker is going to handle both killing and kicking the dog, this one is arguably a bit better.
10:00:15 <ddarius> Obviously there is no real big difference either way.
10:00:22 <copumpkin> yeah, I like yours better
10:00:26 <copumpkin> I'll go with it for no
10:00:27 <copumpkin> w
10:01:07 <djahandarie> Are there functions for that isomorphism somewhere?
10:01:41 <ddarius> djahandarie: No.
10:02:07 <ddarius> :t let bool t f b = if b then t else f in uncurry bool
10:02:09 <lambdabot> forall a. (a, a) -> Bool -> a
10:02:22 <hpaste> cedricshock annotated ‚ÄúTypeable and deserialization: Can getStaticAnnotationByType be written without referenceing Instance1 or Instance2‚Äù with ‚ÄúTypeable and deserialization: Can getStaticAnnotationByType be written without referenceing Instance1 or Instance2 (annotation)‚Äù at http://hpaste.org/55132#a55136
10:03:02 <ddarius> do tellTheDogI'm <- watchdog; ... forkIO ( ... tellTheDogI'm (not done) ... )
10:03:14 <opqdonut> :D
10:04:15 <cedricshock> Anyone have any thoughts on my updated paste? (ddarius: Notice there are no more flexible instances, etc, but even further abuse of existential quantification)
10:05:32 <Peaker> A beginner I'm helping confused empty instance declarations with "deriving" -- the result is of course 0 compile warnings/errors, a big "Stack overflow" at runtime.. Not very nice to a beginner :-(
10:06:11 <Peaker> I think the loopy declarations in Eq/Ord are a bad trade-off.. It really isn't ever nicer to define (/=) vs (==), it's entirely reasonable to demand defining (==) and make (/=) a non-method
10:06:11 <jmcarthur> :\
10:06:34 <copumpkin> what's wrong, jmcarthur ?
10:06:51 <Peaker> and for Ord, defining (<) isn't ever any harder than defining any of the others...
10:06:54 <jmcarthur> it would be nice to be able to specify things like "if X and Y are defined, then Z has this default"
10:07:03 <statusfailed> ok dumb question time again, why is the state monad needed? Isn't it just like having a state transition function, a foldl, and a list of inputs?
10:07:09 <jmcarthur> copumpkin: it was a reaction to what Peaker said
10:07:13 <copumpkin> ah
10:07:17 <jmcarthur> statusfailed: convenience
10:07:27 <jmcarthur> statusfailed: also useful under abstractions
10:07:32 <Peaker> Also, I'm really appreciating "let rec" in ML variants after encountering a bunch of accidental recursions
10:07:33 <statusfailed> jmcarthur: it seems more fiddly to me :(
10:07:51 <statusfailed> jmcarthur: could you expand what you mean by "useful under abstractions"?
10:08:06 <Peaker> Also, allowing record fields in sum types -- and then making *partial getters* by default, is pretty bad behavior for a language geared towards type-safety
10:08:07 <ddarius> :t mapM
10:08:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
10:08:26 <jmcarthur> statusfailed: i'd say i should have emphasized the abstraction part more heavily than the convenience part. the state monad, like many monads, is useful for making little DSLs and stuff
10:08:45 <aavogt> Peaker: the problem with bad instances could be fixed if the compiler was smarter
10:08:55 <Peaker> aavogt: how?
10:08:57 <jmcarthur> aavogt: i'm not sure about that.
10:09:08 <jmcarthur> aavogt: after all, mutual recursive definitions are legal
10:09:56 <aavogt> ghc already detects a certain kind of infinite loop (at runtime...)
10:10:02 <jmcarthur> Peaker: there are indeed many warts in haskell among the good parts :\
10:10:10 <statusfailed> jmcarthur: Hm, I guess I still don't really 'get it', so i'll just accept that :p
10:10:17 <aavogt> whatever it's called "blackholing" which gives exceptions that print like <loop> I think
10:10:27 <rwbarton> statusfailed: what you described sounds like specifically using the State monad with mapM
10:10:44 <hpaste> copumpkin pasted ‚Äúwatchdog (comments?)‚Äù at http://hpaste.org/55137
10:10:59 <jmcarthur> aavogt: that is true, but it's a fundamentally dynamic thing and just happens to be easy to do due to ghc's evaluation model
10:11:16 <statusfailed> rwbarton: that seems true
10:11:25 <Eduard_Munteanu> Peaker: perhaps there are things where only non-equality is decidable? But this isn't really an argument in Haskell.
10:11:35 <statusfailed> I guess my question was more "why bother with it" if it can be achieved with just a standard fold
10:11:38 <rwbarton> there are other functions that are polymorphic over monads too, though
10:11:43 <statusfailed> but I suppose it's cleaner
10:11:53 <Peaker> Eduard_Munteanu: yeah, it does not relate here
10:11:57 <jmcarthur> statusfailed: if the only point is to fold i wouldn't use State
10:12:07 <rwbarton> for example mapping over some other data structure that's an instance of Traversable
10:12:34 <Peaker> jmcarthur: I think that maybe ADTs should have been split -- anonymous sum support + record/recursion support
10:12:49 <statusfailed> jmcarthur: I just meant that it seems like you could do with a fold what state does
10:13:19 <rwbarton> of course you could just write a "stateful map" for that data structure... but this way you decompose the problem into two parts: the monadic map over the data structure, which can be reused for other monads, and the State monad, which can be reused for other data structures
10:13:20 <jmcarthur> statusfailed: that fails to hold true once you do more complicated things
10:13:38 <Peaker> It could have a downside: data Nothing = Nothing ; data Just a = Just a ;  type Maybe a = Nothing | Just a   (synonym for anonymous sum)
10:14:03 <statusfailed> Ah, yeah
10:14:10 <statusfailed> I can see that being true, but I can't think of any examplse
10:14:11 <statusfailed> heh
10:14:39 <Peaker> Then potentially the Id data constructor could be reused (type Maybe a = Nothing | Id a)
10:16:18 <copumpkin> any comments on the watchdog?
10:16:24 <copumpkin> would people do things differently?
10:16:29 <copumpkin> (http://hpaste.org/55137)
10:17:01 <ddarius> copumpkin: The only thing that maybe might be useful, though not for you, is a start button.
10:17:34 <copumpkin> I guess I could make it startable/stoppable arbitrarily many times
10:17:36 <copumpkin> so you can pause it
10:17:57 <Peaker> jmcarthur: Unfortunately, many of Haskell's warts are exactly in beginner territory -- and it really requires effort to go past them
10:18:52 <Cale> Peaker: There are lots of compromises between convenience and safety in Haskell.
10:19:17 <cedricshock> copumpkin: Or put the delay in the state so that the frequency can be changed after it's started, but that's just adding complexity.
10:19:31 <ddarius> Unlike Java which compromises both convenience and safety for no discernible reason.
10:19:47 <Cale> There's a whole set of programs down at the small end of the spectrum where you're not really super-interested in type safety or handling errors in a particularly nice way.
10:19:58 <ddarius> cedricshock: I would find that an odd feature for a watchdog.
10:20:11 <copumpkin> it'd be a very well-trained watchdog
10:20:17 <copumpkin> where you can say "wait for me for 3 hours"
10:20:28 <copumpkin> and then change your mind and tell him 2 hours instead
10:20:53 <Cale> and a nice thing about Haskell is that such programs can be reasonably written, and then filled out to be very safe programs as well, as it becomes more important that they handle failure better
10:20:59 <cedricshock> Yeah, that wouldn't work.
10:21:26 <Peaker> Cale: I think Haskell is way too far on the convenience side
10:21:28 <Cale> But unfortunately, yes, it does hurt the large-scale case a bit.
10:21:49 <rwbarton> way too far, wow :P
10:21:51 <Peaker> Cale: convenience is so petty in the grand or even medium scheme of things
10:22:05 <Cale> Haskell is way farther on the safety side than almost any practical language in existence :)
10:22:09 <Peaker> Cale: saving a few seconds here and there does not add up to even a fraction of a single time you have to debug a runtime problem
10:22:27 <ddarius> copumpkin: You could, technically, "pause" the watchdog in your earlier scheme.
10:22:30 <Peaker> Cale: Also, Haskell unsafety translates to more catastrophic results than unsafety in other languages (perhaps by necessity)
10:22:35 <Cale> I mean, if you want Agda, there is Agda :)
10:22:51 <jmcarthur> most languages are downright scary
10:22:54 <rwbarton> wow, are you talking about the same Haskell I use?
10:23:04 <Peaker> Cale: I want Haskell record accessors to be total (and if that means banning records in sum constructors, that's good)
10:23:09 <rwbarton> when I write an empty Eq instance I just get a program that hangs
10:23:11 <Peaker> and recursions to be explicit
10:23:22 <Peaker> rwbarton: or crashes with *loop* with -O2
10:23:27 <rwbarton> even better
10:23:33 * ddarius doesn't find Haskell "unsafety" being more catastrophic than other languages.
10:23:37 <Cale> Peaker: I think it's been too long since you've written a program in something other than Haskell perhaps? :)
10:23:40 <Peaker> rwbarton: it's not easy to understand where that hang/loop is happening
10:23:51 <rwbarton> well at least I didn't get a random wrong output!
10:23:55 <Peaker> ddarius: It's much harder to debug a Haskell runtime error than C, Python and other languages
10:23:58 <rwbarton> how am I going to track down where that is happening!
10:24:01 <rwbarton> er, ?
10:24:05 <ddarius> Peaker: I don't find that to be the case.
10:24:09 <Cale> Things are decidedly better when Haskell programs go wrong than in most other languages with which I'm familiar.
10:24:22 <ddarius> Peaker: I also have less of them.
10:24:26 <Peaker> ddarius: Say someone added an empty Eq instance to your project, and you get a hang -- how do you figure out what caused the hang?
10:24:30 <jmcarthur> rwbarton: the point, i think, is that this is a pretty silly reason to have a runtime issue since it's so syntactically obvious
10:24:38 <copumpkin> ddarius: without having the dog expire?
10:24:39 <rwbarton> sure, I agree with this particular example
10:24:41 <Cale> Peaker: by using the profiler
10:24:41 <Peaker> ddarius: I agree that we have much less runtime errors -- I'm saying that the ones we do have are significantly worse
10:24:53 <rwbarton> (why would I ever want to have the compiler define (==) for me in terms of (/=))
10:24:57 <benmachine> *fewer
10:25:00 <ddarius> Peaker: I don't agree at all.  Especially compared to C.
10:25:01 <Peaker> Cale: A beginner cannot practically use the profiler, yet...
10:25:05 <jmcarthur> i'm not sure i'd say they are worse
10:25:07 <Cale> Why not?
10:25:13 <Cale> It takes like 5 minutes to learn to use the profiler
10:25:14 <ddarius> copumpkin: Yes.
10:25:15 <copumpkin> perhaps someone should make a libraries proposal to kill the (/=) and (==) linkage
10:25:15 <Peaker> Cale: compiling all the dependencies with profiling is a nightmare
10:25:23 <Peaker> Cale: if nobody told him to add "profile: yes" to the cabal config
10:25:31 <jmcarthur> the ghc profiler is by far the easiest one i've ever learned
10:25:35 <Cale> I guess...
10:25:36 <rwbarton> when we get stack traces, perhaps you'll just be able to hit ^C and find out where your program is looping
10:25:47 <copumpkin> ddarius: by forking off something that keeps tickling the dog until I stop it?
10:25:53 <ddarius> copumpkin: Yep.
10:25:53 <Cale> rwbarton: Only if you've compiled with profiling, of course.
10:25:57 <rwbarton> oh
10:25:59 <rwbarton> I see
10:25:59 <jmcarthur> doesn't make it convenience, as in the case you bring up, but it was very clear what went wrong the first time it happened tome
10:26:00 <ddarius> copumpkin: You can call it pointDefeater.
10:26:03 <jmcarthur> *to me
10:26:04 <copumpkin> lol
10:26:20 <copumpkin> ddarius: in the same way, I could make something that "starts" the watchdog later
10:26:27 <copumpkin> :D
10:26:29 <jmcarthur> *convenient
10:26:36 <copumpkin> inefficientStartWatchdogLater
10:26:37 <Cale> rwbarton: The "stack trace" will use a "stack" which doesn't even normally exist in running Haskell code.
10:26:40 <ddarius> copumpkin: Of course, pausing is strictly more expressive than just starting.
10:26:47 <rwbarton> yes I understand
10:27:06 <rwbarton> wonder whether it could be the default without -O though? or is that a terrible idea
10:27:24 <Rabbi_Meish> hello
10:27:34 <Cale> I'm not sure. But we should have cabal default to building profiling libraries and documentation.
10:28:04 <jmcarthur> it's hard to say what defaults "should" be, i think
10:28:11 <ddarius> Cale: Then people will complain about GHC taking an extra hundred megs on their 3 terabyte hard drives.
10:28:21 <Cale> ddarius: fuck those people
10:28:30 <copumpkin> go Cale!
10:28:30 <Peaker> ddarius: GHC already comes with that extra hundred megs -- it's just the ~/.cabal libs
10:29:05 <Cale> ddarius: If they really want to turn those options off, they can turn them off. Most people will want documentation and profiling support eventually.
10:29:13 <shapr> ha
10:29:42 <Eduard_Munteanu> HP already comes with profiling stuff.
10:29:46 <Peaker> ideally, cabal could be smart enough to rebuild missing profiling packages
10:30:01 <Peaker> a lot of beginner-pain in Haskell revolves around cabal deficiencies
10:30:18 <Peaker> Working around the PVP is a hard-learned skill everyone needs to master to use Haskell in practice
10:30:18 <ddarius> Don't use cabal.
10:30:21 <shapr> I wonder if writing working tutorials and newbie friendly documentation for various existing libs would count as a good GSoC project.
10:30:25 <Peaker> ddarius: what do you use, instead?
10:30:32 <Cale> also, the new default of not having RTS options is really really stupid
10:30:38 <rwbarton> just write haskell like it's 1998
10:30:48 <jmcarthur> yeah the rts thing continues to bite me
10:30:54 <ddarius> Peaker: I wasn't talking about me, and I don't have huge issues with cabal, though I was around long before it was.
10:30:55 <shapr> What RTS thing is that?
10:31:11 <Cale> You now have to compile with --with-rtsopts if you want to use +RTS ...
10:31:12 <lukish> I need to say, that it's time for 14 ex of 20 intermediate haskell exercises.
10:31:15 <Yrogirg> hey guys, how comes  2 * (1 :+ 3) works for Data.Complex? 1 :+ 3 is definitely Complex a, but how 2 becomes Complex a?
10:31:19 <Peaker> ddarius: well, not using cabal is also very painful -- things are nicely modular, which leads to dependency hell
10:31:30 <shapr> Er, that sucks, I really want +RTS !
10:31:32 <rwbarton> :type 2
10:31:37 <Cale> Because some people complained about security concerns
10:31:38 <rwbarton> :t 2
10:31:39 <Peaker> Yrogirg: Whenever a number literal is used, ghc injects an implicit "fromInteger" call on it
10:31:39 <lambdabot> forall t. (Num t) => t
10:31:52 <Peaker> s/number/integer
10:31:55 <Eduard_Munteanu> shapr: somewhat though I guess it must involve coding for the better part of it.
10:32:00 <lukish> I have s :: [a], t :: (a -> m b). And need to get m [b].
10:32:14 <Yrogirg> ok, ty
10:32:16 <Cale> hurr durr, there's an RTS option to write to an arbitrary file! OH NO WHAT IF I WAS TO SETUID ROOT THIS
10:32:21 <lukish> First question. is unicorn s :: m [a]?
10:32:38 <rwbarton> yes
10:32:54 <rwbarton> unicorn has type x -> m x, right?
10:33:02 <lukish> rwbarton: right
10:33:26 <copumpkin> I think you need a mapmypus for that
10:33:45 <copumpkin> wow, that function name sounds a lot worse than I meant it to sound
10:34:07 <lukish> With map I will have [m b], not m [b]
10:34:21 <Peaker> Cale: I think it's a valid concern -- not sure the result is good, though.  It could keep that default while issuing a compilation warning
10:34:33 <copumpkin> lukish: yeah, but there might be something else you can do to transform [m b] to m [b]?
10:35:18 <Peaker> Cale: warning linking to an explanation of the security issues, and says "Use -disable-rts to avoid that issues.  rts options are enabled. Use -enable-rts to suppress this warning"
10:35:31 <lukish> it's exercise 15 actually. http://blog.tmorris.net/20-intermediate-haskell-exercises/
10:35:49 <lukish> But I'm solving 14.
10:35:51 <copumpkin> lukish: oh, I see :)
10:36:02 <copumpkin> he's going about it the other way around, since you can define one in terms of the other
10:37:05 <`Zerax`> I wonder how many people go on to actually find out what the real names of these functions and types are ;)
10:37:17 <`Zerax`> For some definition of real
10:38:04 <lukish> Hoogle gives them immediately
10:38:21 <`Zerax`> That's a relief.
10:38:54 <ddarius> `Zerax`: The exercises are not particularly valuable for learning how to program using monads.
10:39:52 <Yrogirg> :q
10:40:06 <Yrogirg> oops, i wanted to quit chat
10:40:14 <`Zerax`> Does provide some valuable experience at least.
10:41:00 * Eduard_Munteanu now wonders if there's an IRC analogue to Vimperator :P
10:42:06 <lukish> Well, how can I use (a -> m b) to get m [b]?
10:42:24 <lukish> With map i will have [m b] as I said.
10:43:24 <rwbarton> lukish: well... there is one way you can get an m [b], without using any of the values you've been passed
10:43:25 <fryguybob> @type sequence
10:43:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:43:44 <shapr> Peaker: I like that solution
10:44:43 <lukish> fryguybob: m is not monad
10:44:53 <lukish> I hope, lol
10:44:57 <rwbarton> lukish: this exercise is trickier than the previous ones in that there is not an essentially unique way to do it
10:45:19 <rwbarton> though there is a standard way to do it
10:45:57 <fryguybob> @type foldr (liftA2 (:)) (pure [])
10:45:58 <lambdabot> forall a (f :: * -> *). (Applicative f) => [f a] -> f [a]
10:46:00 * ddarius would like to eat something but doesn't feel like moving.
10:46:07 <lukish> Well, if I have function m a -> m b, does it mean that I can get m [a] -> m [b]?
10:46:22 <Peaker> shapr: Maybe I could make a ghc ticket
10:46:27 <copumpkin> ddarius: delivery!
10:46:30 <shapr> Peaker: do it!
10:46:32 <dgpratt> @faq can Haskell make ddarius something to eat?
10:46:33 <lambdabot> The answer is: Yes! Haskell can do that.
10:46:33 <Eduard_Munteanu> Does anybody know if simple reference counting would be enough for a hypothetical Haskell compiler/RTS, instead of garbage collection?
10:47:00 <Eduard_Munteanu> I'm not really sure, but I'd normally guess no.
10:47:11 <jmcarthur> you always have to have a plan for cycles when using ref counting
10:47:14 <ddarius> copumpkin: I'm not sure if I've ever ordered delivery.  I know I haven't since I moved to Boston and also not before I moved off base.
10:47:29 <ddarius> Eduard_Munteanu: Yes it would be.
10:47:53 <ddarius> Well, except for IORefs and such.
10:48:03 <Eduard_Munteanu> Ah. For some reason I thought that'd be a less likely candidate than GC or even regions.
10:48:08 <Eduard_Munteanu> Hm.
10:48:32 <Eduard_Munteanu> ddarius: any idea if it's ever been tried?
10:48:36 <ddarius> jmcarthur: The compiler is aware of the loops so it can put in appropriate logic.
10:49:10 <Eduard_Munteanu> I guess it would be appealing to various projects, like OS kernels, since it's easier to replace a bare, refcounting heap allocator than a GC.
10:49:49 <Peaker> Coarse-grained refcounting can be good. Fine-grained refcounting is pretty bad
10:49:55 <Eduard_Munteanu> (and regions don't seem to be going anywhere)
10:49:59 <Peaker> (performance-wise)
10:50:32 <ddarius> Yes, resolving it leads to deferred reference counting which is just waxing back to garbage collection.
10:50:51 <ddarius> (There being a nice duality between reference counting and [tracing] garbage collection.)
10:51:37 <Eduard_Munteanu> But still... it moves some of that logic into the compiler, no?
10:51:53 <Eduard_Munteanu> (as opposed to the RTS, which you'll probably have to replace anyway in those cases)
10:52:02 <lukish> rwbarton: standart way means only Prelude functions?
10:52:15 <rwbarton> no
10:52:41 <rwbarton> I mean... for example there are a lot of functions with the same type signature as map
10:52:53 <mbetter> import qualified
10:52:55 <ddarius> :t \f -> reverse . map f
10:52:57 <lambdabot> forall a a1. (a1 -> a) -> [a1] -> [a]
10:52:59 <mbetter> oops
10:53:11 <lukish> @hoogle  [a] -> (a -> m b) -> m [b]
10:53:12 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
10:53:12 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
10:53:12 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
10:53:30 <rwbarton> but if you gave someone the type signature (a -> b) -> [a] -> [b] to implement a function with, you'd be a bit surprised if they produced something other than map
10:53:39 <Eduard_Munteanu> Peaker: I wonder if graininess somehow gets us to regions, if the compiler is to make smart decisions statically
10:53:51 <mreh> what defines an acid-state transaction? is it the invoking of createAcidState and the end of the program?
10:54:39 <mreh> i think they called it openLocalState in the lastest release
10:54:44 <Eduard_Munteanu> mreh: hm? I think you should have a look at this: http://en.wikipedia.org/wiki/ACID
10:54:49 <lukish> som answer is flip mapM ?
10:54:51 <rwbarton> your (Misty m) => [a] -> (a -> m b) -> m [b] is much like that 'map' type signature, though you actually have even more options... but there's a particular function you're "supposed" to write.
10:54:59 <mreh> Eduard_Munteanu: i understand what ACID means
10:54:59 <mbetter> when you call update, it's durable once it returns
10:55:09 <fryguybob> @src forM
10:55:10 <lambdabot> forM = flip mapM
10:55:10 <Eduard_Munteanu> Oh, hrm, I think I misread you.
10:55:20 <mreh> but where does ACID apply to acid-state?
10:55:34 <mreh> it seems to apply to update atleast
10:55:43 <rwbarton> but since your Misty is just defined in a symbol-pushing, "here are some types" kind of way, I don't know how you're supposed to figure out what that function is
10:55:59 <mbetter> isn't update what matters?
10:56:04 <lukish> But, can I import some packages in those exercises?
10:56:14 <Peaker> Eduard_Munteanu: I think with lots of static analysis it may be possible to get rid of superfluous incs/decs but very hard to get rid of the extra storage for refcounts that pushes things out of the relevant cache lines
10:56:31 <mreh> mbetter: yes I suppose so, i just have to go and rewrite my code!
10:56:39 <Eduard_Munteanu> lukish: I think the idea is to implement those yourself. Well, all the better if you're familiar with that stuff and say "oh, that's 'fmap'" for example, but that's something else.
10:56:57 <mbetter> how do you have it now?
10:57:17 <mbetter> something where you need to know that an update finished before you make a query?
10:57:59 <mreh> mbetter: I need isolation of one transaction
10:58:04 <mreh> a collection of queries and updates
10:58:12 <mreh> from any other changes to the database
10:58:12 <Peaker> shapr: http://hackage.haskell.org/trac/ghc/ticket/5690
10:58:16 <Eduard_Munteanu> Peaker: I'm thinking... wouldn't you be able to refcount something like slabs, or larger blocks? Say, refcounting creates / destroys corresponding chunks of 1MiB.
10:58:39 <mbetter> you can use scheduleUpdate as well
10:59:01 <cedricshock> Is there anything like evaluateCast :: DataType -> (forall d. d -> a) -> IO (a) ?
10:59:10 <Peaker> Eduard_Munteanu: then any little object still reachable in any slab keeps the entire slab alive?
10:59:21 <Eduard_Munteanu> Hrm, right.
10:59:38 <mbetter> the sequence of updates is guaranteed
10:59:38 <Eduard_Munteanu> You'd still need to pack objects in a sensible manner.
10:59:47 <Eduard_Munteanu> (or compact them :/)
11:01:24 <Eduard_Munteanu> I think I'm getting a hang of ddarius' remark wrt the similarity to GC, now :)
11:02:15 <cedricshock> Actually that needs another argument for the data to cast evaluateCast :: DataType -> (forall d. d -> a) -> o -> IO (Maybe a). Something that casts o as the DataType if possible and returns the evaluation of the rank2 function over all d.
11:03:09 <Eduard_Munteanu> It kinda sucks we're still stuck with ye olde C.
11:04:12 <Eduard_Munteanu> (not only that, but it seems even replacing some parts of those systems with higher-level languages is a tough proposition)
11:08:47 <ddarius> rwbarton: If the exercise set asserts some laws should hold, the ambiguity could be resolved.
11:09:04 <benmachine> cedricshock: what do you mean by over all d
11:09:48 <bwright> Has anyone read, "The Lambda Calculus, Its Syntax and Semantics"? If so what did you think of it?
11:12:39 * earthy has
11:12:43 <earthy> it is dense
11:13:02 <earthy> and good.
11:13:14 <earthy> ofcourse, I had Barendregt teach me the stuff himself, so...
11:13:28 <bwright> Oh wow what was he like as a teacher?
11:13:31 <earthy> he's great
11:13:49 <earthy> very thoughtful
11:16:37 <ddarius> @google "A Unified Theory of Garbage Collection"
11:16:39 <lambdabot> http://dl.acm.org/citation.cfm?id=1028982
11:16:39 <lambdabot> Title: A unified theory of garbage collection
11:20:13 <augur> barendregt's recent work is fucking loopy
11:20:21 <lukish> Another question about moppy. Could it be recursive?
11:20:52 <lukish> For example, I get x :: a, produce m b from it.
11:20:55 <rwbarton> lukish, sure
11:21:00 <ski> augur : what's it about ?
11:21:00 <rwbarton> after all, you are being passed a list
11:21:14 <augur> ski: mind, meditation, and loopy shit like that
11:21:17 <lukish> But how can I add this m b to resulting m [b]
11:21:25 * ski grins
11:21:55 <augur> ftp://ftp.cs.kun.nl/pub/CompMath.Found/AM01.pdf
11:22:06 <carpi> coudl someone please tell me what is the reason for the existence of language extensions? The reason I ask is because.. If there was no sound reason to include them in 98 why have them now, when then could potentially contaminate an otherwise sound language? I might be wrong but im curious..
11:22:22 <rwbarton> lukish: it might help to do exercise 16 first
11:22:56 <Cale> carpi: huh?
11:23:10 <Cale> carpi: Because they're *useful*
11:23:21 <Cale> carpi: and because standards are overrated
11:23:43 <alistra> it¬¥s sometimes shorter  and more readable to use an extension
11:23:47 <ski> carpi : some of the extensions lift restrictions in H98 that were mostly put in there because of either (a) make implementation easier; or (b) we didn't know how to do the general case in a good way (or at all) then
11:23:54 <rwbarton> carpi: many of them represent advances in language design since 1998
11:24:09 <alistra> view patterns, bang patterns
11:24:22 <mbetter> why is there a new version of anything?
11:24:24 <Cale> GADTs, TypeFamilies...
11:24:42 <Cale> I mean, did you actually look at any of the language extensions?
11:24:51 <cedricshock> I don't think it's possible to write a deserializer over existentially quantified types in haskell.
11:24:52 <ski> carpi : other's add completely new things which people hadn't thought up then, but are useful -- some of these come with some dangers or complications, though
11:24:53 <Cale> I'm a little surprised at the question :)
11:25:02 <mbetter> it's a crazy question
11:25:15 <cedricshock> I think it requires dependent types that we just don't have.
11:26:01 <carpi> Cale: sry.. but i think there is a tendency to end up being bloated like some other languages out there.. im not complaining though
11:26:21 <ski> augur : hehe, fun
11:26:32 <Cale> carpi: Haskell has no pretention of being a minimalist language
11:26:34 <augur> ski: its amazing how very smart people can also be completely loopy
11:27:05 <Proge> all smart people are loopy :D
11:27:31 <ski> augur : i think whether there's anything useful coming out of stuff like in that paper remaind to be seen
11:27:31 <Eduard_Munteanu> ddarius: thanks, looks interesting
11:27:35 <bwright> Yeh there is a fine line between insanity and genius.
11:27:52 <augur> ski: im more concerned with the motivations behind it, not what comes out of it
11:27:52 <carpi> Cale: i don't think it has to be minimal as long as it is logically sound in construction and aesthetic at the same time while giving expressive powers
11:27:54 <Cale> carpi: Though of course there should be a reasonable way to implement all the things which end up in standards -- so the things which go in the standard are the things which are all very well-understood and must be implemented.
11:28:10 <ski> augur : mhm ?
11:28:38 <dgpratt> Proge: if that is a reflexive relation, then I must be smart
11:29:00 <augur> ski: well, its mystical mumbojumbo that has no founding in anything remotely scientific. its some bullshit a guy pulled out of his ass one day
11:30:37 <dgpratt> err.../s/reflexive/symmetric
11:31:22 <carpi> the reason why i like haskell is because to a large extent it is based on mathematical rigor. Im not sure the same thing can be said about other languages. And i don't think that rigor should be lost at the expense of adding more and more extensions.. unless those extensions themselves are well thought out, sound , aesthetic and based on the same mathematical rigor..
11:31:40 <carpi> apologies .. if i sound pedantic. just a little concerned.. unecessarily i think
11:31:54 <rwbarton> extensions without those qualities generally get rejected by the community if not by the compiler writers
11:32:30 <Cale> carpi: Of course, they are.
11:32:31 <bwright> carpi: Protect yourself with censorship! Extensions are optional for a reason.
11:32:55 <Cale> carpi: Pretty much all of them have corresponding research papers.
11:33:37 <Cale> btw, does anyone know if there's a way to make google always search for the thing I asked to search for and not editorialise my queries?
11:33:52 <Cale> anyway, carpi: http://research.microsoft.com/~simonpj/papers/constraints/jfp-outsidein.pdf
11:34:23 <xplat> copumpkin: edwardk: so what is this 'STM-killer' i hear so much about?
11:34:26 <Cale> That paper describes a unified type system tying together a few of the larger extensions.
11:34:32 <ski> augur : true. the challenge is to try to *make* it scientific
11:34:41 <Cale> Many of the smaller extensions are purely syntactic.
11:34:42 <edwardk> xplat: not so much an stm killer as a slightly related idea
11:34:47 <ski> (possibly discarding many parts, of course)
11:34:54 <ddarius> carpi probably believes in the real numbers.
11:34:59 <carpi> so when extensions get included into the compiler they have to be approved by the compiler writers at the top? like Mr. Peyton for example? i thik he is active in haskell development
11:35:31 <augur> ski: no thats not the challenge. you dont just start with random shit and say, hey lets make it scientific. maybe 10,000 years ago you did, but we're beyond the point of being clueless, we're beyond the point of having no science to build upon.
11:35:36 <edwardk> basically you can fork and join, and define versioned variables with their own 3 way merge strategies such that each fork gets their own copy and on merge you apply the strategy using the two versions and their least common ancestor
11:35:39 <ski> carpi : that's a valid worry, yes
11:35:59 <edwardk> xplat: that much in and of itself is pretty neat because it gives you something ST s -like that you can get parallelism out of
11:36:02 <bwright> ski: Is your name in relation to SKI Combinator Calculus?
11:36:04 <ski> carpi : btw, you may note that SML (i.e. Standard ML) actually has a formal specification of the semantics
11:36:08 <ddarius> edwardk: The stuff out of the C# stuff?
11:36:21 <benmachine> Cale: I vaguely remember that there was some project that essentially proxied all your google queries, so they appeared to be coming from the same source as a bunch of others... don't remember the name though
11:36:21 <ski> bwright : yes sir/madam
11:36:25 <edwardk> ddarius: check my github for revisions
11:36:35 <edwardk> ddarius: but yeah daan leijen has a c# version
11:36:48 <lukish> I have furry' :: Misty m => (a -> b) -> m a -> m b. How can I get type of (furry' f), where f :: a -> b -> c?
11:36:56 <edwardk> xplat: now if you break the revision control metaphor there becomes something else you can do
11:37:15 <edwardk> xplat: which is to record a series of forks and joins and play it back later in an edited context
11:37:29 <ski> augur : well, i don't think we've come very far wrt this topic. maybe we won't come very far either, maybe there's nothing concrete here. i don't think we know
11:37:29 <benmachine> lukish: first, rename variables so f :: d -> e -> f
11:37:37 <lukish> I think it's "m a -> m (b -> c)"
11:37:43 <lukish> But how can I check it?
11:37:44 <edwardk> xplat: because you can recycle the result of any branch that only reads from variables that haven't been changed in the meantime, this gives you a model for incremental computation as well as parallel computation
11:37:44 <carpi> thanks for the paper link )
11:37:58 <adimit>  /j #sql
11:38:07 <adimit> srry, damn space.
11:38:12 <Cale> benmachine: Yeah, I don't actually care about privacy much here, but when I search for OutsideIn(X) and it searches for Outside In(X) instead, it's really annoying.
11:38:16 <benmachine> lukish: erm, write those definitions in a file and load it in ghci
11:38:25 <ddarius> adimit: No we know that you are a relational apologist.
11:38:32 <augur> ski: we've come far enough to know that just taking some random mysticism shit from an old religious text as a nice model is not very reasonable.
11:38:36 <edwardk> xplat: so in my case i can take a type checker and re-run it with slightly modified types, or a packrat parser that has access to a symbol table and rerun it with an edited version-controlled symbol table
11:38:39 <ski> augur : so, i agree that it is loopy, and maybe it will forever stay loopy. but i think it's ok to try to make it less loopy
11:38:44 <benmachine> Cale: ohh, I see what you mean, sorry, was thinking of something else entirely
11:39:10 <adimit> ddarius: :( not true. I just like HDBC
11:39:11 <edwardk> xplat: make sense?
11:39:30 <ddarius> Cale: There's probably parameter that can be passed to get that behavior from Google.
11:39:47 <lukish> benmachine:     The type signature for `f_' lacks an accompanying binding
11:39:48 <lukish> Failed, modules loaded: none.
11:39:57 <rwbarton> Cale: you could do this: (1) go to google.com (2) right-click the text entry and choose whatever "make a search engine" is called in your browser of choice (3) append &nfpr=1 to the URL
11:40:03 <benmachine> lukish: f_ = undefined
11:40:06 <edwardk> what i like about it is i get determinism, parallelism and incrementalization out of basically 4-5 combinators
11:40:12 <benmachine> lukish: or f_ = f_ will satisfy it too
11:40:15 <Cale> hmmm...
11:40:24 <Cale> rwbarton: yeah, that does seem to do it
11:40:34 <lukish> benmachine: great
11:40:35 <ddarius> Cale: Edit the Search module.
11:40:56 <Cale> It's sad that isn't the default
11:41:08 <ddarius> Cale: Why?
11:41:40 <Cale> Because, I don't mind it suggesting that I might have typoed something, but I usually mean to search for what I typed.
11:41:58 <dgpratt> edwardk: maybe you mentioned it, but was this what you referenced earlier? http://channel9.msdn.com/Shows/Going+Deep/E2E-Concurrent-Programming-with-Revisions
11:42:10 <Cale> I don't like the second-guessing about spelling and really, who does?
11:42:11 <copumpkin> rwbarton: what does nfpr=1 stand for?
11:42:46 <edwardk> i usually reference the papers rather than that video, but yes
11:42:52 <Cale> Look at all the silly stuff that happens with Apple's iPhone autocorrect. It's the same thing, basically.
11:43:23 <edwardk> i see erik is still wearing his trademark tie die shirts
11:44:44 <rwbarton> copumpkin: "no f'ing putting right"? That was the best I could do.
11:44:54 <copumpkin> how did you figure that out? :P
11:44:55 <dgpratt> Cale: usually Google turns out to be smarter than me
11:45:30 <Cale> I've only ever been annoyed by Google's autocorrection.
11:45:36 <edwardk> dgpratt: also that video iirc doesn't talk about the recording feature i mentioned
11:45:53 <mbetter> it's the worst when you're searching for code stuff
11:46:07 <rwbarton> examining the link "Search instead for" link, also it was mentioned here recently
11:46:33 <benmachine> Cale: some people aren't great at typing? and it doesn't help that your searching profile is probably, um, a little obscure
11:46:43 <benmachine> Cale: google more often corrects me accurately than inaccurately
11:46:55 <Cale> I suppose that's true :P
11:47:09 <ddarius> @google nfpr=1
11:47:10 <mbetter> i would rather do exactly what i asked for than do something unexpected
11:47:11 <lambdabot> http://www.google.com/support/forum/p/Web%20Search/thread?tid=02c6ec0718868dbc&hl=en
11:47:11 <lambdabot> Title: How can I disable Google Search Autocorrect? - Web Search Help
11:47:12 <benmachine> which is not to say I still wouldn't prefer it to do what it's told :P
11:49:23 <Sums> hey guys
11:49:30 <Sums> just checking out the tutorial
11:49:31 <Sums> wassup
11:49:40 <benmachine> hi
11:49:49 <mbetter> which one? there are thousands
11:49:54 <Sums> try haskell
11:50:02 <Sums> it linked me to here
11:51:01 <mbetter> Check out the haskell amuse-bouche by Mark Lentczner
11:51:21 <mbetter> http://www.youtube.com/watch?v=b9FagOVqxmI
11:51:25 <Sums> gotcha
11:52:06 <mbetter> i found that quite inspiring
11:52:59 <Sums> haskell is a desktop language right?
11:53:07 <mbetter> what do you mean?
11:53:09 <mike-burns> Sure.
11:53:14 <Sums> like C++, java, etc
11:53:15 <parcs> as opposed to?
11:53:20 <Sums> not a web/scripting lang
11:53:21 <MostAwesomeDude> It's a fairly general-purpose language.
11:53:23 <ion> You can also write under a desktop.
11:53:38 <MostAwesomeDude> You can use it for systems, graphics, or whatever.
11:53:39 <jmcarthur> it's as general as any other
11:53:44 <Sums> hmm
11:53:47 <jmcarthur> i'm using it to make a game right now
11:53:56 <mbetter> i'm writing a web app
11:53:58 <Sums> how would you compare it to java?
11:53:59 <opqdonut> there are web application and database libraries for haskell too
11:54:04 <MostAwesomeDude> "Web scripting lang" is really not fair; there's exactly three languages out there with any web scripting traction, and two of them suck hard.
11:54:11 <mike-burns> It's in the same family of programming languages as C++ and bash.
11:54:56 <jmcarthur> well, this is a biased group, but i'd pick haskell over java any day. or were you looking more for a point by point comparison?
11:54:58 <MostAwesomeDude> mike-burns: Uh? It's neither imperative nor object-oriented... Isn't it a lot closer to ML, Ocaml, etc.?
11:55:13 <Sums> a comparison
11:55:23 <Sums> perhaps performance/speed
11:55:32 <mike-burns> Just try the language, dude.
11:55:41 <Sums> i'm on it
11:55:46 <Peaker> MostAwesomeDude: I read the paper about Pickler Combinators -- and I intend, when I have a bit of free time, to polish it up somewhat and put on hackage, should be decent Construct alternative, I think
11:55:57 <mbetter> watch the video, it's a very good primer
11:56:00 <jmcarthur> haskell is safer, higher level, on par for speed except in some rare cases where it is significantly faster or slower
11:56:12 <Sums> hmm
11:56:27 <MostAwesomeDude> Peaker: I'd be interested in that. My mind doesn't grok Haskell yet, and the best thing I could come up with is a list of types which would be iterated through to create whatever parser or builder would be needed.
11:56:30 <Sums> is it practical in the software industry?
11:56:35 <Sums> is it a valuable asset?
11:56:37 <jmcarthur> a very subjective question ;)
11:56:45 <mbetter> it's a valuable asset for your brain
11:56:49 <jmcarthur> i use OCaml where i work, which is related to haskell
11:56:54 <MostAwesomeDude> e.g. buildParser [word16, int16, cString]
11:57:06 <Sums> hmm
11:57:07 <fryguybob> Sums: Software industry is highly impractical when it comes to many things.
11:57:26 <MostAwesomeDude> Sums: If you want to be relevant in the industry, learn Java, C++, Python, and C#.
11:57:36 <mike-burns> Knowing something makes you worth more than not knowing something.
11:57:40 <Sums> i'm still very young
11:57:43 <Sums> want to have some fun
11:57:44 * jmcarthur doesn't feel irrelevant in the industry
11:57:48 <mbetter> F# is highly related to OCaml and you can write .NET with that
11:58:08 <Sums> so i'm gonna play around with this
11:58:19 <jmcarthur> if fun is the criteria you're after then it is going to be hard to beat haskell
11:58:29 <Peaker> MostAwesomeDude: Pickler combinators was not easy for me too -- and I feel I do grok Haskell :)  The paper http://research.microsoft.com/en-us/um/people/akenn/fun/picklercombinators.pdf is great
11:58:42 <mbetter> Haskell: #1 in fun!
11:58:45 <MostAwesomeDude> > the URL has "fun"
11:58:47 <lambdabot>   Not in scope: `the'Not in scope: data constructor `URL'Not in scope: `has'
11:58:53 <MostAwesomeDude> Pfft, heh.
11:59:03 <jmcarthur> haskell can be kind of mind bending, which hurts pragmatism (according to some) but definitely makes it fun :)
11:59:06 <Peaker> MostAwesomeDude: it's indeed fun
11:59:18 <Sums> hahaha
11:59:22 <mike-burns> It's only mind-bending if you know something else first.
11:59:36 <jmcarthur> learning programming at all is kind of mind bending
11:59:42 <jmcarthur> so it's mind bending either way
11:59:43 <mike-burns> True, true.
11:59:45 <mbetter> anyways, learning Haskell has made me write better VBA
11:59:49 <MostAwesomeDude> Well, it depends on what you know. It's easier to get to Haskell from Scheme than from Python.
11:59:51 <Peaker> jmcarthur: Haskell code is often great (type-safe, elegant) that imperfections stick out like sore thumbs -- causing perfectionism which can reduce productivity :)
12:00:00 <jmcarthur> Peaker: heh
12:00:14 <Sums> how old is everyone btw? i'm 17
12:00:19 <MostAwesomeDude> OTOH, Python's adopted a handful of Haskell's idioms and functions, so that helps.
12:00:21 <jmcarthur> 26
12:00:22 <opqdonut> I used to be 17
12:00:33 <MostAwesomeDude> 23 and already cranky and burnt-out. :3
12:00:38 <jmcarthur> i wonder how useful an age discussion really is here...
12:00:41 <mbetter> i'm less than twice that, so i don't feel that old
12:00:54 <Sums> burnout, that sucks
12:01:16 <Cale> I'm 28, and have been programming in Haskell since I was 18. :)
12:01:19 <mbetter> Haskell: #1 with the young!
12:01:26 <RealAlex> 25. I wonder what happens with programmers when they reach 30
12:01:39 <mbetter> alex: you don't want to know
12:02:00 <MostAwesomeDude> RealAlex: I know a handful of older gentlemen in the field. Age doesn't really matter, only chops matter.
12:02:01 <RealAlex> I don't think I really have choice here
12:02:27 <mbetter> RealAlex: True. I guess you do want to know, then.
12:02:27 <jmcarthur> wow, i've been into programming for over 70% of my life...
12:02:32 <MostAwesomeDude> jg, one of the guys that wrote X11, is still hacking away. He's kind of the elder of X. It's pretty awesome.
12:02:55 <Sums> regrets mannn
12:03:01 <Sums> i picked up C++ when i was in 7th grade
12:03:06 <Sums> i regret stopping it after i entered HS
12:03:13 <Sums> oh well
12:03:21 <KingTubby> Hi.
12:03:45 <Cale> I somewhat regret having all that information about C++ taking up space in my head ;)
12:03:58 <MostAwesomeDude> C++ is the kind of thing that only hurts your brain as you continue to learn it.
12:04:12 <MostAwesomeDude> It's not the worst language, by any means, but the tricks required to draw speed out of it are...unfriendly.
12:04:14 <jmcarthur> i started learning BASIC when i was 7 because i found a cool book in the library that had cartoon robots on the cover
12:04:14 <mbetter> MostAwesomeDude: s/C++/VBA/g
12:04:20 <MostAwesomeDude> mbetter: :c
12:04:33 <MostAwesomeDude> I *still* have some PHP brain damage in the back of my head.
12:04:38 <ddarius> mbetter: Given the choice (and to some extent I do have this choice,) I'd rather write C# than F# for most of what I use C# for.
12:04:38 <Cale> jmcarthur: lol, I remember seeing a book like that
12:04:52 <bwright> After reading the C++11 standard I decide I would write more haskell.
12:05:00 <bwright> decided*
12:05:02 <KingTubby> Haha
12:05:04 <mbetter> i might have read that book too
12:05:06 <Eduard_Munteanu> Book? Heh... I accidentally stumbled upon qbasic while poking my fingers at DOS, when I was about 6 or 7
12:05:13 <Eduard_Munteanu> (I'm 23 now)
12:05:17 <mbetter> i learned basic on my Atari 88
12:05:18 <mbetter> 800
12:05:41 <Sums> okay
12:05:42 <Sums> question
12:05:57 <Sums> if you could be the greatest ever in any language right now, what would it be?
12:06:04 <KingTubby> I used butterfies to flip bits when I was 4.
12:06:08 <Sums> granted instant knowledge and familiarity with all info regarding that language
12:06:10 <MostAwesomeDude> Sums: COBOL.
12:06:14 <bwright> Sums: English.
12:06:15 <mike-burns> English.
12:06:16 <RealAlex> Sums, what do you mean "if"
12:06:17 <mike-burns> Oh snap.
12:06:19 <MostAwesomeDude> I would never want for money ever again.
12:06:45 <jmcarthur> agda
12:06:50 <Eduard_Munteanu> Damn.
12:06:53 * Eduard_Munteanu wanted to say that
12:07:07 * RealAlex wanted to say that he wanted to say that
12:07:12 <jmcarthur> more than one person can say it
12:07:13 <statusfailed> can I pattern match against newtypes?
12:07:14 <Eduard_Munteanu> :)
12:07:16 <mbetter> probably javascript
12:07:20 <Eduard_Munteanu> statusfailed: yes
12:07:21 <jmcarthur> statusfailed: yes
12:07:29 <jmcarthur> damn, i wanted to say that, obviously
12:07:33 <Sums> hmm
12:07:34 <mbetter> Eduard_Munteanu won this round
12:07:35 <Sums> lol
12:07:39 * fryguybob agrees with ddarius, F# makes the subtle difference between it and Haskell too apparent to me while C# makes me happy it isn't java.
12:07:45 <Cale> statusfailed: In fact, you'll need to in order to unpack them.
12:07:55 <KingTubby> Im new to Haskell from python background. Nice language!
12:07:56 <statusfailed> newtype SomeType = SomeType {mkSomeType :: (Int, Int)}
12:08:00 <jmcarthur> Cale: not if you use record syntax
12:08:01 <Cale> statusfailed: (or else use record syntax and use the field name)
12:08:01 <statusfailed> how do?
12:08:05 <dgpratt> fryguybob, ddarius: I also agree with this sentiment
12:08:09 <Eduard_Munteanu> I hesitated because Agda itself has some rough edges, and I wonder whether I'm not actually hoping for more than what's currently possible.
12:08:22 <statusfailed> I was using type before but then i wanted to make it a Monad so it has to be newtype apparently
12:08:27 <jmcarthur> Eduard_Munteanu: my thinking was that if i was an agda master then the knowledge would still be useful elsewhere
12:08:28 <kmc> differences between F# and Haskell are subtle?
12:08:33 <ddarius> Eduard_Munteanu: You could say Epigram 2.
12:08:49 <MostAwesomeDude> Actually, I take it back. I'd rather have a perfect knowledge of x86 assembly, for personal reasons.
12:08:57 <dgpratt> kmc: :-) maybe not so much
12:08:59 <ddarius> x86 assembly is fun.
12:09:01 <fryguybob> kmc: :D not so much, but from a distance.
12:09:04 <kmc> yeah
12:09:11 <kmc> from a distance all those weirdo FP languages are the same
12:09:18 <Cale> I would ask for knowledge of a future version of Haskell, in the hopes that I could beat people to writing a bunch of papers.
12:09:24 <kmc> conversely #haskell tends to lump all "imperative languages" together
12:09:28 <kmc> it's all a matter of perspective
12:09:34 <ddarius> kmc: Of the statically typed ones, they pretty much are (re FP languages.)
12:09:35 <Sums> programming would be so much for fun with a prettier interface
12:09:39 <Sums> what are some good IDEs?
12:09:41 <dgpratt> the thing is, I am often tempted to try writing Haskell code in F#; it rarely works out well
12:09:44 <MostAwesomeDude> vim!
12:09:46 <mike-burns> vim, emacs.
12:09:46 <mbetter> Sums: vim
12:09:46 <Sums> Vim isnt for windows so yea
12:09:47 <MostAwesomeDude> emacs!
12:09:47 <jmcarthur> emacs!
12:09:48 <mbetter> dammit
12:09:52 <Eduard_Munteanu> ddarius: yeah, I hear it's got even more researchy stuff
12:09:53 <Cale> Sums: vim is for windows
12:09:55 <mike-burns> Vim is for windows.
12:09:56 <kmc> F# and Scala have subtyping, don't they?
12:09:57 <ddarius> Sums: I learned vim on Windows.
12:10:03 <kmc> that's a pretty huge difference from Haskell
12:10:04 <Sums> really? i thought it was just OS X
12:10:07 <mike-burns> Hahaha.
12:10:08 <jmcarthur> all the good editors run on pretty much any system
12:10:17 <kmc> not to mention strict semantics and side effects
12:10:20 <mbetter> just CPM, i thought
12:10:21 <Cale> Sums: hah, most of its users are probably linux users
12:10:38 <kmc> these seem at least as big as the difference between, say, Javascript (mainstream) and Scheme (weirdo FP language)
12:10:51 <kmc> perspective and marketing
12:11:15 <MostAwesomeDude> From my perspective, JS is the weird one out, not Scheme. :3
12:11:17 <jmcarthur> i agree with kmc. the difference between haskell and ocaml seems pretty stark to me
12:11:23 <jmcarthur> *differences
12:11:29 <mbetter> I've been flipping between writing Javascript and Haskell, and ASI can suck it
12:11:40 <statusfailed> wait
12:11:47 <statusfailed> haskell wiki says I can't pattern match on a newtype
12:11:48 <statusfailed> :\
12:11:51 <kmc> as i keep saying, we should make a new language which is identical to haskell, but has a different name, and is marketed as a pragmatic multiparadigm language rather than an academic toy for FP extremists
12:11:53 <Cale> statusfailed: where?
12:11:56 <jmcarthur> if it says that then it's wrong
12:11:59 <kmc> ;)
12:12:00 <hpc> statusfailed: you can pattern match, but it is a noop
12:12:11 <hpc> that might be what they meant
12:12:12 <jessopher> or if the constructor is not exposed
12:12:19 <kmc> (i guess ocaml also has subtyping, but it's not so popular?)
12:12:19 <RealAlex> trying to understand something here. (I'm am a newbie as well) When there is some possible "cross-purposness" burried somewhere very deep in the code of my app (or a framework i.e. somebody else's code) - would using Monads be a good way to implement some kind of "dependency injection" so that I can kind of replace those deeeeep-leveled functions "on-the-fly"?
12:12:22 <statusfailed> a noop?
12:12:23 <companion_cube> kmc: and call it haskellscript?
12:12:24 <MostAwesomeDude> kmc: Ooh, multiparadigm? Can I create objects? :3
12:12:25 <jmcarthur> statusfailed: newtype Foo = Bar Int; baz (Bar x) = f x
12:12:29 <statusfailed> oh
12:12:47 <Cale> statusfailed: It's possible to not export the newtype's data constructor from a module, making it impossible for users of your module to pattern match the newtype.
12:12:47 <ddarius> RealAlex: Just parameterize.
12:12:51 <fryguybob> kmc: mojave FP?
12:12:53 <Eduard_Munteanu> You may only call it Haskellscript if it's a totally different language :P
12:13:00 <statusfailed> "Pattern-matching on a newtype constructor does no work"
12:13:02 <kmc> MostAwesomeDude, we might have to change the word "value" to "object" and "type" to "class" in the docs
12:13:03 <Cale> statusfailed: Which is useful for abstraction
12:13:04 <bwright> kmc: Just call it Jarva.
12:13:05 <statusfailed> I assumed that meant "not"
12:13:09 <jmcarthur> heh
12:13:16 <jmcarthur> nope, it just means that it's free
12:13:18 <dgpratt> lol
12:13:20 <mike-burns> kmc: The best marketing would be something like what Rails did: hype up something that actually does make it trivial for people who don't know anything about what they're doing, and just so happens to use Ruby. A killer app, I guess.
12:13:25 <mike-burns> No need for a new name to do that.
12:13:37 <companion_cube> then call it "basicscript", i think it has nothing common with bsic
12:13:45 <bwright> Just what haskell needs more EDSLs!
12:13:49 <statusfailed> Cale: I'm just using ghci though so it's not that
12:13:51 <RealAlex> ddarius, let's say the top function I call is process_request. the functon I want to replace is deep deep inside of it, called "prepare_report" for instance. Would you still suggest adding a parameter to the process_request ?
12:14:03 <hpc> bwright: it does!
12:14:15 * ddarius is not interested in catering tothe "peolpe who don't anything about what they're doing" crowd, though Haskell is, in some ways, good for that (and in other ways bad for it.)
12:14:16 <hpc> bwright: just as long as they aren't arrow-based monoid associative semigroup rings
12:14:17 <RealAlex> ddarius, and pass that extra parameter the whole way?
12:14:19 <MostAwesomeDude> kmc: But that's lies!
12:14:29 <ddarius> RealAlex: Yep.
12:14:34 <Cale> statusfailed: now that you've explained the context, it's clear that it just wasn't the typo you thought it was
12:14:37 <bwright> hpc: hehe.
12:15:15 <ddarius> There are ways of getting such things passed implicitly, or you could use monads to do that passing, though that will probably be worse than the disease, or you could just pass it.
12:15:19 <KingTubby> I run GHC(i) 7.0.3(dont know if that matters) but I would think this would stop "computing": filter (<15) [1..]. Since the predicate will always be false for values over and 15. Should the type system be able to figure this out?
12:15:21 <Cale> statusfailed: It means what it says: if you pattern match on a newtype constructor, no work is done at runtime to make that pattern match happen, because the representation of a newtype is actually the same as the representation of the type that it wraps.
12:15:43 <Cale> KingTubby: no, it shouldn't be able to figure that out
12:15:46 <jessopher> newtype constructors are free as in potato chips, while crashing on your moms couch. no work.
12:15:56 <RealAlex> ddarius, what if it's in somebody else's code? e.g. a framework? a web framework in which I want to replace one little function ... having something to do with persistence.
12:16:00 <statusfailed> Cale: ah... could someone change that to "doesn't do any work"?
12:16:07 <RealAlex> I can't really add parameters there
12:16:07 <statusfailed> or have I still misunderstood
12:16:13 <Cale> statusfailed: yes
12:16:19 <Cale> statusfailed: what page is it on?
12:16:19 <jmcarthur> that would be a reasonable rephrasing
12:16:24 <mbetter> realalex: hide their function and import your own?
12:16:25 <ddarius> RealAlex: Then you're screwed and you would be screwed regardless.
12:16:29 <statusfailed> Cale: http://www.haskell.org/haskellwiki/Newtype
12:16:39 <KingTubby> Cale: Ok.
12:16:51 <opqdonut> i've always found that "newtypes disappear in compilation" is a good explanation
12:16:56 <RealAlex> mbetter, that's closer :)
12:17:02 <Sums> Kobe or Lebron?
12:17:14 <jmcarthur> KingTubby: try this instead: takeWhile (<15) [1..]
12:17:18 <Cale> statusfailed: okay, changed
12:17:21 <mbetter> i'm doing it for a few functions in happstack right now
12:17:22 <Sums> ...think this is the wrong place to ask that
12:17:33 <statusfailed> Cale: awesome, thanks :)
12:17:41 <RealAlex> ddarius, Let's say I write that framework, right now. and I do want people to be able to replace some function. Still, I see that it has nothing to do with all the many levels of function on top of it that actually use it
12:17:54 <KingTubby> jmcarthur: cool.
12:18:23 <Cale> KingTubby: It would have to understand something about the monotonicity of the sequence in question which is something somewhat nontrivial to prove, and certainly isn't reflected in the type [Integer] that the list has.
12:18:26 <RealAlex> so if you say monads are possible for that I guess I'm going to take it :) why this way could be worse?
12:19:08 <RealAlex> less clear I suppose...
12:19:21 <Cale> RealAlex: while it's possible to use a reader monad to implicitly pass a parameter... I often say write it the other way first.
12:19:23 <ddarius> RealAlex: Unless the code is already using a monad, changing it to use a monad would be far more destructive than adding a parameter.  At any rate, there are other ways of doing it that aren't as bad.
12:19:38 <mbetter> sounds like a monad.. reader or state
12:20:00 <KingTubby> Cale: ok, thanks.
12:20:43 <ddarius> RealAlex: But this non-locality of change is an effect of the lack of expressive Haskell suffers from being purely functional, though "dependency injection" frameworks in Java, say, are also pretty intrusive.
12:20:53 <Cale> A lot of people seem to fret about passing an extra parameter, but often if you just do that, you can later refactor things quite nicely by looking at what sets of parameters are common and bundling them together into a new datatype.
12:21:11 <mike-burns> But dependency injection as a pattern and not a framework is very nice.
12:21:19 <Cale> and that cleans things up nicely enough that you don't worry about additional abstractions.
12:21:23 <ddarius> Dependency injection is just parameterization.
12:21:28 <mike-burns> Yup.
12:21:57 <RealAlex> yeah, sure. I rather refered to a particular implementation e.g. service locator or IoC
12:22:14 <RealAlex> sorry for not being clear about that
12:22:17 <KingTubby> Is there somewhere that lets you look at the implementation for a function from prelude? takeWhile and my filter have the equal type signature.
12:22:30 <mike-burns> @src takeWhile
12:22:30 <Cale> RealAlex: The extra parameter makes it clearer which parts of the code depend on what, as well.
12:22:31 <lambdabot> takeWhile _ []                 =  []
12:22:31 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
12:22:31 <ion> Look it up on hoogle and click ‚ÄúSource‚Äù.
12:22:31 <lambdabot>                    | otherwise =  []
12:22:32 <mbetter> click on "source" on hackage
12:22:55 <azaq23> KingTubby: http://haskell.org/ghc/docs/latest/html/libraries/base/src/Prelude.html
12:23:12 <RealAlex> Cale, yes... I got it. but, you see - I should know all about it at the moment of writing that function.
12:23:17 <RealAlex> it's not allways that I can add a parameter
12:23:23 <Cale> hm?
12:23:24 <ion> Instead of the ‚Äúotherwise‚Äù value, i might have preferred something like
12:23:24 <azaq23> ok, that doesn't even contain the implementations
12:23:28 <ion> foo | predicate = bar
12:23:29 <RealAlex> e.g. when I write/use a framework/library
12:23:32 <ion>     |           = baz
12:23:48 <RealAlex> I kind of have to predict what of these things I write they may need to replace
12:23:53 <RealAlex> I can't do that
12:24:06 <rwbarton> there's no way you can write a function where part of the function is replaceable without knowing about it when you write the function
12:24:10 <Cale> RealAlex: okay, sure. That's not an easy thing to do.
12:24:18 <RealAlex> with a dependency injection container in a OOP language I can simply let them replace _anything_
12:24:32 <Cale> RealAlex: Maybe it's not safe to just replace _anything_
12:24:43 <RealAlex> rwbarton, that makes sense.
12:25:01 <Cale> It might break any number of invariants of your code, things that you were assuming about the things that you used to do that.
12:25:20 <Cale> and it's really hard to express all the things that you actually depend on about all the things you use in general
12:25:22 <companion_cube> coding with invariants ? so old-fashioned
12:25:23 <mike-burns> The typical pattern of DI in OO is to parameterize such that the unit tests are easy to write with mocks. This tends to provide for a nice level of swappability for the end user.
12:25:23 <RealAlex> safety is very important, but this is not what I'm wondering about currently :P
12:25:26 <KingTubby> ion: mbetter azaq23 Thanks! Nice with the actual implementation :)
12:26:18 <Cale> companion_cube: I'm using 'invariants' as a synonym for 'properties'
12:26:37 <companion_cube> Cale: sorry, that was sarcasm :/
12:26:42 <Cale> ah
12:26:59 <ddarius> RealAlex: You can simply parameterize everything.  You could, with Ashley, make every function a method of a type class for starters.
12:27:29 <RealAlex> okay okay, I think I get the picture now
12:27:33 <Cale> Or just take everything that you use as a parameter directly.
12:27:46 <Cale> and then you end up with pure lambda terms
12:27:51 <ddarius> Which is exactly what "constructor DI" is doing.
12:27:54 <RealAlex> yeah yeah, I got it
12:28:03 <RealAlex> thanks.
12:28:07 <RealAlex> cool :)
12:31:18 <Cale> You can even avoid using datatypes like that, by abstracting over the data constructors :P
12:31:33 <RealAlex> :P
12:31:42 <RealAlex> I hope I won't have to
12:32:21 <ddarius> Actually, the natural encoding of algebraic data types in OOP languages leads to something almost exactly like Scott encoded terms.
12:33:31 <RealAlex> I guess this is how you understand which tool/language to use. You count how many functions parameters you'll have to add to how many functions and then compare it with... introducing one global variable. And if it's less than 1000 to 1 - you can go with Haskell =D
12:34:11 <RealAlex> in ideal, "pure" world when we just know from the beginning which places are going to be replacable we could simple use haskell.
12:34:29 <rwbarton> you can always put your 1000 functions in a record...
12:34:40 <Cale> RealAlex: So long as you have the source code, anything is replaceable.
12:34:43 <BMeph> Let 1000 record bloom!
12:34:50 <Cale> In any language
12:34:55 <RealAlex> Cale, as I said - we are not always able to change the source code
12:35:01 <RealAlex> take any framework that needs to be updated
12:35:07 <RealAlex> sure you can submit a pull request..
12:35:47 <RealAlex> of course if it were we who wrote that ideal frameworks in ideal world...
12:35:59 <RealAlex> *those
12:39:03 <jessopher> I run into these kinds of problems in my head all of the time, i rarely run into them in my actual source code. When I have to refactor, i refactor... where i cannot refactor, i repackage
12:39:05 <ddarius> RealAlex: We'll just write a preprocessor to automatically insert those 1000 parameters and then you can configure it with an XML file.
12:40:14 <RealAlex> ddarius, insert where? to the framework's code? You're not the maintainer of the framework I use.
12:40:24 <shachaf> <ddarius> > let diagonalize xs = [[if i == j then x else 0 | (i, x) <- zip [0..] xs] | j <- zipWith const [0..] xs] in diagonalize [3,29,14] -- zipWith const for shachaf (I think)
12:40:25 <RealAlex> so you inserting anything would hardly help me :)
12:41:09 <ddarius> RealAlex: We just need to convince everybody that it is a good idea.
12:41:14 <shachaf> > foldr(\x y->(x:0.y):(0:).y)[] [3,29,14]
12:41:16 <lambdabot>   [[3,0,0],[0,29,0],[0,0,14]]
12:41:25 <RealAlex> ddarius, the problem is that I need it now
12:41:36 <shachaf> ddarius: My use of zipWith const involved (repeat 0) as the first argument, which is of course silly.
12:41:59 <RealAlex> ddarius, also, the maintainer and "everybody" are on a vacation
12:42:05 <RealAlex> why not
12:42:21 * copumpkin slaps shachaf 
12:42:35 <shachaf> copumpkin: What did I do?!
12:42:55 <copumpkin> you zipped a repeat
12:43:01 <shachaf> Oh.
12:43:15 <shachaf> I thought it would be something involving the use of "0.y".
12:43:18 <shachaf> > 0.[1,2,3]
12:43:20 <lambdabot>   [0,0,0]
12:43:53 <shachaf> That looks like pseudo-APL.
12:43:54 <ddarius> > zipWith const (0.fix show) [1..10]
12:43:57 <lambdabot>   [0,0,0,0,0,0,0,0,0,0]
12:45:18 <copumpkin> the fix show is key
12:52:31 <copumpkin> > map (succ . head . tail) . iterate (drop 2) . map length . group . fix $ show
12:52:37 <lambdabot>   mueval-core: Time limit exceeded
12:52:43 <copumpkin> > take 5 . map (succ . head . tail) . iterate (drop 2) . map length . group . fix $ show
12:52:47 <lambdabot>   mueval-core: Time limit exceeded
12:52:49 <copumpkin> damn you lambdabot
12:54:12 <Cale> huh
12:54:16 <Cale> > take 5 . map (succ . head . tail) . iterate (drop 2) . map length . group . fix $ show
12:54:19 <lambdabot>   [2,4,8,16,32]
12:54:23 <Cale> > map (succ . head . tail) . iterate (drop 2) . map length . group . fix $ show
12:54:30 <lambdabot>   mueval: Prelude.undefined
12:54:30 <lambdabot>  mueval: ExitFailure 1
12:54:34 <djahandarie> lol
12:54:38 <Cale> lol
12:54:39 <Cale> > map (succ . head . tail) . iterate (drop 2) . map length . group . fix $ show
12:54:44 <lambdabot>   mueval-core: Time limit exceeded
12:54:51 <djahandarie> > 3
12:54:52 <lambdabot>   3
12:54:58 <Cale> Okay, I'm going to check on the server :P
12:55:29 <Cale> nothing obviously wrong with it
12:55:42 <shachaf> Obviously nothing wrong with it.
12:55:46 <parcs> > read "12e1000000000000" :: Integer
12:55:47 <Peaker> MostAwesomeDude: btw: The main combinator for parser-builder is very similar to the monadic bind, up to an extra first arg:   sequ :: (b -> a) -> PU a -> (a -> PU b) -> PU b
12:55:51 <lambdabot>   mueval: ExitFailure 1
12:55:52 <lambdabot>  mueval: Prelude.undefined
12:56:04 <djahandarie> Cale, that function eats memory extremely fast
12:56:05 <Peaker> what determines whether a paper becomes a "functional pearl"?
12:56:06 <Cale> parcs: Well, that clearly just takes a long time to compile :P
12:56:22 <ddarius> Peaker: Whether the author put "Functional Pearl" in the title.
12:56:23 <shachaf> Peaker: I always thought it was whether the title started with "functional pearl".
12:56:35 <Peaker> ddarius: oh, I thought there was someone filtering them :)
12:56:46 <Peaker> "This gets to be a pearl, this does not"
12:57:00 <ddarius> Peaker: Many of them appeared in the JFP and so had to meet those quality standards.
12:58:22 <Cale> Yeah, I guess that does get slow quickly... still the first 80 characters of the result are pretty quick.
12:59:00 <Peaker> I liked the pearl -- but I think the state-threading could have been done in a less ad-hoc manner..  Sort of a StateT transform on the PU is done, by manually putting (s->) and (s,) all over the place there
12:59:10 <djahandarie> Cale, used like 2GB of memory by the 7th or so entry of the list for me
12:59:23 <Peaker> (though StateT isn't directly applicable because it's an invariant type constructor)
13:06:04 <fryguybob> > fix ((1:) . (>>= \x -> [1+x, 1/(1+x)])) -- functional pearl
13:06:07 <lambdabot>   [1.0,2.0,0.5,3.0,0.3333333333333333,1.5,0.6666666666666666,4.0,0.25,1.33333...
13:06:46 <Cale> > fix ((1:) . (>>= \x -> [1+x, 1/(1+x)])) :: [Rational]
13:06:49 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,2 ...
13:09:08 <Cale> > let pyth r = (x,y,z) where {m = numerator r; n = denominator r; [x,y,z] = sort [2*m*n, m^2 - n^2, m^2 + n^2]} in map (pyth . (+1)) . fix $ ((1:) . (>>= \x -> [1+x, 1/(1+x)]))
13:09:11 <lambdabot>   [(3,4,5),(6,8,10),(5,12,13),(8,15,17),(7,24,25),(20,21,29),(16,30,34),(10,2...
13:09:30 <djahandarie> What's this one?
13:09:40 <Cale> Pythagorean triples
13:09:58 <Cale> 3^2 + 4^2 = 5^2
13:10:01 <djahandarie> Last one was the countable set of rationals right?
13:10:16 <Cale> yeah, positive rationals
13:15:12 <shachaf> djahandarie: Every set of rationals is countable. :-)
13:25:34 <sam6> Hi
13:25:58 <sam6> is it possible to make a function that returns an Integral?
13:26:46 <djahandarie> :t const 1 :: Integral i => a -> i
13:26:48 <lambdabot> forall a i. (Integral i) => a -> i
13:26:51 <donri> Integral is not a type
13:27:42 <Axman6> sam6: Integral is a class of numbers, do you mean Integer?
13:27:50 <gwern> shapr: I'm not sure you're allowed. aren't you a little old to claim to be a student?
13:28:06 <sam6> I mean Integral
13:28:12 <gwern> byorgey: yeah, I mentioned the plugins' merge. but does anything use it yet?
13:28:32 <sam6> is it possible to make a function that takes in an Integer or an Int and works the same way?
13:28:40 <Axman6> yes
13:29:02 <Axman6> foo :: Integral a => a -> a
13:29:09 <donri> I'd imagine it's possible to have a function (Integral b) => a -> b
13:29:18 <bwright> Depends on what you mean.
13:29:20 <djahandarie> :t fromInteger :: Integral a => Integer -> a
13:29:21 <lambdabot> forall a. (Integral a) => Integer -> a
13:29:28 <azaq23> > let f :: Integral t => t -> t; f = (* 2); g :: Integer -> Integer; g = f; ((f :: Int -> Int) 2, g 3)
13:29:29 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:29:37 <bwright> The function that takes an Int will behave differently at the maxBound, Integer does not have that problem.
13:29:43 <azaq23> > let f :: Integral t => t -> t; f = (* 2); g :: Integer -> Integer; g = f in ((f :: Int -> Int) 2, g 3)
13:29:43 <donri> @hoogle (Integral b) => a -> b
13:29:44 <lambdabot>   (4,6)
13:29:45 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
13:29:45 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
13:29:45 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
13:29:59 <sam6> what does forall do?
13:30:04 <bwright> You can have a function that takes either an Int or an Integer but you can't guarentee just of that that they will behave exactly the same.
13:30:06 <ben> What's a simple library for doing trivial csv parsing?
13:30:06 <Axman6> ignore it
13:30:16 <donri> @hoogle csv
13:30:17 <lambdabot> package csv
13:30:17 <lambdabot> package csv-enumerator
13:30:18 <lambdabot> package bytestring-csv
13:30:19 <donri> ^_^
13:30:32 <ben> yeah and which of those is simplest and trivialest
13:30:34 <copumpkin> gwern: he's in college, so I don't see why not. The only age restrictions are to be over 18
13:30:45 <sam6> I often see forall when functions are defined2026 what does it do?
13:30:49 <donri> likely the first one
13:31:02 <Axman6> sam6: forall is implicit in haskell's types, but lambdabot adds it because... i don;t know why, because it can
13:31:03 <gwern> copumpkin: shapr is in college? isn't shapr that ancient unicyclying haskeller who used to maintain lambdabot and stuff?
13:31:11 <copumpkin> yes, and he's in college
13:31:17 <copumpkin> and he's not ancient :P
13:31:18 <gwern> possibly I am thinking of someone else with a nick starting with 's'
13:31:32 <sam6> discGaussians :: (RandomGen g, Real r, Integral a) => g -> r -> [a]
13:31:33 <Axman6> foo :: forall a b. a -> b is exactly the same as foo :: a -> b
13:31:34 <gwern> the shapr I am thinking of was like a contractor in europe for years and years
13:31:39 <sam6> is it possible to make function like this?
13:31:50 <copumpkin> gwern: I don't see how that precludes him being in college right now
13:31:53 <adimit> Question: instance C ([] Text) requires -XFlexibleInstances, but instance C a => C [a] would require me to provide an orphan instance C Text. Which is better?
13:32:01 <donri> sam6: why not?
13:32:13 <gwern> copumpkin: it'd be fairly unusual...
13:32:14 <vrook> mapM_ print [1..n] -- is the list [1..n] optimized away, leaving only iteration here?
13:32:17 <adimit> (stylistically, theoretically, am I doing it wrong anyway‚Ä¶)
13:32:25 <gwern> copumpkin: most developers don't go back to college in their 30s or whatever
13:32:28 <copumpkin> gwern: well, it's the case
13:32:33 <Axman6> vrook: probably
13:32:43 * gwern still feels suspicious
13:32:43 <donri> sam6: you *can* get type errors for ambiguous type variables depending on how/where you *use* the function, but it should certainly be possible to define one such
13:32:56 <sam6> I want to define a function like this http://hpaste.org/55146
13:33:03 <copumpkin> gwern: go ahead
13:33:05 <sam6> but it seems to be ambiguous type variable
13:33:39 <copumpkin> I need moar enumeratees
13:33:39 <donri> sam6: try adding a more specific type signature at the point where you are using the function
13:34:15 <shachaf> vrook: That depends on what you mea by "iteration".
13:34:18 <sam6> if I try to load it in ghci
13:34:21 <shachaf> vrook: You might say that the list *is* iteration.
13:34:24 <sam6> it cannot deduce type
13:34:39 <Axman6> sam6: you need it to have a == r )at the type level) or convert r to the type a is
13:34:58 <shachaf> unsafeConverse
13:35:27 <sam6> wait2026 Axman6 can you say that again?
13:35:31 <Axman6> r :: Real r :: r, but you've said your function returns an a, which is different to r
13:35:51 <Axman6> you probably need to use fromIntegral (-r*w)
13:35:55 <Axman6> :t randomR
13:35:56 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
13:36:12 <Axman6> :t (*)
13:36:13 <lambdabot> forall a. (Num a) => a -> a -> a
13:36:18 <vrook> shachaf: I mean that no memory is allocated to create a list structure.
13:36:43 <shachaf> vrook: I imagine that some memory will be allocated.
13:36:48 <Axman6> so, when r is multiplied by something, the something must also be the same type. and the types you give to randomR must be the same as those returned
13:37:11 <shachaf> vrook: Only some constant amount of memory, though -- the list will be evaluated lazily and garbage-collected as it's iterated over.
13:37:22 <shachaf> I doubt it'll optimize it into an actual loop.
13:37:50 <Axman6> so when you have r :: Real r => r, then randomR (-r*w,r*w) g :: (r,g), not some random integral. there is no implicit type convertsion in Haskell, but that's what you're asking it to do sam6
13:37:51 <vrook> shachaf: hm why not? Doesn't ghc do the tail-call thing?
13:38:13 <shachaf> vrook: What does "the tail-call thing" have to do with it?
13:38:40 <Axman6> vrook: I'm not sure it will automatically be a tail call though, depends on the monad. it might in IO
13:38:44 <shachaf> vrook: Er, when I said "actual loop" I meant something along the lines of for (i = 1; i < n; i++)
13:39:03 <Axman6> > mapM show [1,2,3]
13:39:04 <lambdabot>   ["123"]
13:39:10 <Axman6> hmm
13:39:19 <Axman6> > mapM show [10,20,30]
13:39:20 <lambdabot>   ["123","120","103","100","023","020","003","000"]
13:40:49 <sam6> I changed it like this but has error http://hpaste.org/55147
13:41:38 <Axman6> what error?
13:42:32 <sam6> Could not deduce (Random a) arising from a use of 'randomR'
13:42:43 <Axman6> oh, yes, well look at the type of randomR:
13:42:45 <Axman6> :t randomR
13:42:46 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
13:43:01 <Axman6> see that the a must be an instance of Random?
13:43:13 <Axman6> you also need to add the constraint Random a to your function
13:43:21 <sam6> Oh I see...
13:44:10 <donri> :t let w = 5 in \g r -> randomR (-r*w, r*w) g
13:44:12 <lambdabot> forall a g. (Num a, Random a, RandomGen g) => g -> a -> (a, g)
13:47:27 * shachaf attempts to read GHC-generated assembly, finds it somewhat alien-looking.
13:47:31 <sam6> I apologize but I must ask for another help
13:47:32 <sam6> http://hpaste.org/55148
13:47:48 <sam6> the first method has ambiguous type as well it seems :(
13:47:51 <ezyang> shachaf: It's pretty great. HAve you looked at? http://hackage.haskell.org/trac/ghc/wiki/Debugging/CompiledCode
13:48:32 <donri> sam6: try removing the type signature and load it in ghci and run :t on it
13:48:34 <xplat> edwardk: hm, it makes some sense, but i'd like to know how that relates in the incremental context to things like adaptive (functional) programming
13:49:12 <shachaf> ezyang: I haven't; that'll probably help.
13:49:18 <donri> sam6: also you might want fromIntegral not fromInteger
13:49:27 <sam6> getGaussRand :: RandomGen t => t -> Integer -> (Integer, t)
13:49:43 <edwardk> xplat: well there had been some work in incremental computation. if you look at this in that context, the branches from the fork/join tree just turn out to just provide the synchronization points and the merge strategy provides the mechanism for reusing old computations
13:49:57 <xplat> edwardk: also, where are the papers?
13:50:01 <sam6> I see2026 that was the problem
13:50:27 <edwardk> http://research.microsoft.com/en-us/people/daan/ recent publications
13:50:35 <edwardk> the project itself has a page but its missing the last paper there iirc
13:51:54 --- mode: adams.freenode.net set +o ChanServ
13:52:22 <edwardk> you can find a version of this in haskell on daan's page, and one on my github
13:52:23 <edwardk> daan's version is built around IO, mine is built around sparks
13:52:37 <edwardk> blah, giving up talking til the netsplit has passed
13:52:40 <hiptobecubic> Axman6, what is going on with that map command?  mapM show [10,20,30] ?  why is it doing cartesian product?
13:53:16 <Axman6> hiptobecubic: it's using the list monad:
13:53:29 <jessopher> @pl (\a b -> return b)
13:53:41 <lambdabot> const return
13:53:41 <edwardk> xplat: still here?
13:53:46 <Axman6> > [[x,y,z]|x <- show 10, y <- show 20, z <- show 30]
13:53:47 <lambdabot>   ["123","120","103","100","023","020","003","000"]
13:54:22 <Axman6> @src mapM
13:54:23 <lambdabot> mapM f as = sequence (map f as)
13:59:41 <Zarathu> let sumOfDigits = sum . map digitToInt . show
13:59:49 <Zarathu> Why doesn't sumOfDigits 2 ^ 100 work?
14:00:17 <shachaf> Zarathu: Parentheses.
14:00:18 <Axman6> sumOfDigits (2^100)
14:00:18 <rwbarton> because "f x ** y" always means "(f x) ** y"
14:00:36 <Axman6> you wrote (sumOfDigits 2) ^ 100
14:00:36 <Zarathu> shachaf: It returns 0, though. :P
14:00:51 <Zarathu> Sorry, I meant, why doesn't sumOfDigits (2 ^ 100) work?
14:00:54 <shachaf> Zarathu: That's because it's parsing it the way Axman6 said.
14:01:04 <Axman6> > let sumOfDigits = sum . map digitToInt . show in (sumOfDifits 2) ^ 100
14:01:05 <lambdabot>   Not in scope: `sumOfDifits'
14:01:08 <rwbarton> :t sum . map digitToInt . show
14:01:09 <lambdabot> forall a. (Show a) => a -> Int
14:01:10 <Axman6> > let sumOfDigits = sum . map digitToInt . show in (sumOfDigits 2) ^ 100
14:01:11 <lambdabot>   0
14:01:20 <Axman6> > let sumOfDigits = sum . map digitToInt . show in sumOfDigits (2 ^ 100)
14:01:22 <lambdabot>   115
14:01:22 <shachaf> > (sum . map digitToInt . show) (2^100)
14:01:24 <lambdabot>   115
14:01:27 <shachaf> Works for me.
14:01:46 <Axman6> 2 ^ 100
14:01:53 <Axman6> > 2 ^ 100
14:01:54 <lambdabot>   1267650600228229401496703205376
14:02:05 <Axman6> > 2 ^ 100 :: Int
14:02:06 <rwbarton> If you really meant (sumOfDigits 2) ^ 100 then the reason is because sumOfDigits returns an Int and so the computation is done modulo some power of 2 less than 2^100
14:02:06 <lambdabot>   0
14:02:11 <Axman6> that's why you get 0
14:03:03 <xplat> edwardk: i am here
14:03:14 <DanBurton> > sum . map digitToInt . show $ 2 ^ 100
14:03:16 <lambdabot>   115
14:03:17 <xplat> almost real-time now too
14:03:19 <edwardk> xplat: not sure if my comments made it through the split
14:03:34 <Zarathu> Thanks.
14:03:43 <xplat> when i first asked you a question i was still (over?) a day out and skimming
14:04:25 <xplat> i got the link to daan leijen's homepage, and the comment that the newest paper was not on the project page
14:05:14 <xplat> as well as the prior comment that forks/joins are sync points and merge strategy provides a mechanism for reuse
14:05:27 <xplat> i'll probably understand that better once i read a paper or two
14:05:49 <shachaf> Whoa, man, a netsplit!
14:06:48 <edwardk> ok. then you've got everything =)
14:10:33 <salisbury> I've just posted a question re. arrows on StackOverflow. If anyone has a few minutes to have a look id appreciate it
14:10:34 <salisbury> http://stackoverflow.com/questions/8467979/arrows-hxt-and-type-signatures
14:13:52 <xplat> does #haskell have any handy tips for anyone compiling eir own ghc for the first time?
14:14:06 <ezyang> xplat: Make sure you setup your build configuration properly
14:15:03 <Axman6> xplat: i've never really had any problems compiling GHC
14:15:42 <ezyang> Building a release GHC takes a long time and is really not want you want for hacking on GHC
14:16:12 <xplat> ah, yes, hacking on GHC is what i want
14:16:35 <xplat> although possibly using the plugin interface if it'll do what i want -- does that make a difference?
14:16:58 <ezyang> http://hackage.haskell.org/trac/ghc/wiki/Building/Hacking
14:20:00 <edwardk> xplat: take a look at my github repo and/or the papers, i'm going to go grab dinner, and i'll happily answer any further questions when i get back ;)
14:21:06 <xplat> if only the paper would download :(
14:27:10 <parcs> xplat: copy mk/build.mk.sample to mk/build.mk and uncomment "BuildFlavour = Quick"
14:27:15 <hpaste> keep_learning pasted ‚ÄúIntMap update‚Äù at http://hpaste.org/55150
14:27:25 <keep_learning> hello all
14:27:47 <keep_learning> could some one suggest me some thing more Haskellish way to write this http://hpaste.org/55150
14:28:41 <xplat> ezyang: parcs: thanks!
14:37:33 <xplat> well, firefox can't seem to get its act together, but curl downloaded it just fine :-/
14:40:05 <Peaker> keep_learning: One way is: digitHistogram = Map.unionsWith (+) . map ((`Map.singleton` 1) . digitToInt) . BS.unpack
14:41:12 <keep_learning> Peaker, thank you
14:42:24 <hpaste> keep_learning annotated ‚ÄúIntMap update‚Äù with ‚ÄúIntMap update (annotation)‚Äù at http://hpaste.org/55150#a55152
14:43:19 <shapr> gwern: dude
14:43:28 <gwern> dude!
14:44:00 <shapr> gwern: Um, I really am in college. I really have been a GSoC mentor several times.
14:44:20 <shapr> I really do unicycle, I was a contractor in Europe for years, I did maintain lambdabot for years, and I did start #haskell some ten years ago
14:44:28 * gwern makes the http://memedepot.com/view/207 face
14:44:43 <gwern> shapr: so how does that work exactly
14:44:49 <shapr> How does what work?
14:45:02 <DrSyzygy> shapr: Did you just get called on your entire lifestory or something?
14:45:05 <gwern> shapr: I mean, how do you you know go back
14:45:17 <shapr> DrSyzygy: yah, pretty much
14:45:25 <DrSyzygy> *snrk*
14:45:35 <gwern> why would you even do that
14:45:41 <shapr> DrSyzygy: Have you ever spoken Swedish with me on the phone?
14:45:51 <DrSyzygy> shapr: .... yes.
14:46:02 <Peaker> keep_learning: You can also use some variation of: Map.alter (Just . maybe 1 (+1))
14:46:06 <shachaf> I once had shapr speak Swedish at me on the phone!
14:46:08 <shapr> DrSyzygy: ok, so there's one data point that shows other people believe me :-)
14:46:13 <DrSyzygy> :-)
14:46:15 <shapr> shachaf: Right, I've spoken to you on the phone too!
14:46:23 * gwern bets he isn't even a real Doctor
14:46:31 <DrSyzygy> gwern: ...
14:46:35 <shapr> Actually, he has a PhD in math
14:46:40 <gwern> shapr: yeah, so a fake doctor
14:46:43 <DrSyzygy> wth, is this "challenge everyone" day?
14:46:48 * shapr grins
14:46:49 <copumpkin> gwern just being gwern
14:46:55 * gwern 's rule of thumb is that if you can't administer CPR, you're not a real doctor
14:46:55 <DrSyzygy> gwern: Screw that noise. We had the doctoral title before those damn medics coopted it!
14:47:03 <shapr> gwern: So, I really am forty years old, and I'm working on my undergrad CS degree.
14:47:15 <benmachine> TV CPR always makes me laugh
14:47:20 <benmachine> but that's hardly on topic
14:47:24 <DrSyzygy> gwern: Doctor derives from docere -- teaching.
14:47:37 <DrSyzygy> gwern: Fucking medics stole our title, NOT the other way around.
14:47:45 <deech> Hi all, I'm installing the "hdirect" package and I'm seeing the following error: "  Ambiguous module name `Prelude': it was found in multiple packages: base haskell98-2.0.0.0". It doesn't point to a source location, but there's a number of "import Prelude" statements in the source. Is that bad?
14:47:46 <gwern> DrSyzygy: so? the maths then were just philosophers or geometers, not 'doctors'
14:47:53 <benmachine> fucking medicine is a very small part of medicine
14:48:01 <benmachine> I'm pretty sure they all conspired to steal your title
14:48:04 <shapr> gwern: I really did leave my defense contractor job in Boston to go get my CS degree in Alabama.
14:48:07 <BMeph> keep_learning: or just use "M.insertWith (+)" instead of the "M.insert". I'll annotate. :)
14:48:10 <gwern> shapr: but OK, if you're really an undergrad I guess you could apply...
14:48:23 <gwern> shapr: your idea is no worse than jasper benchmarking text
14:49:14 <shapr> gwern: I'd like to do a GSoC project that would be good for the community and that I could complete in the time allotted, thus I would value your input.
14:49:26 <gwern> shapr: your description was too vague to really be judgeable
14:49:39 <shapr> Also, it amuses me to do GSoC as a student after several years of doing GSoC as a mentor.
14:49:40 <gwern> shapr: edwardk claims this year he will nag me into being one of the voting mentors or something
14:49:50 <shapr> gwern: You should do that!
14:49:53 <shapr> I will help him nag you!
14:50:00 * gwern should but would he?
14:50:10 <shapr> gwern: Of course you will! You want to help the community, right?
14:50:11 <hpaste> roaldfre pasted ‚ÄúGHC profiling (missing time?)‚Äù at http://hpaste.org/55153
14:50:15 <roaldfre> I'm having some GHC profiling woes (accumulated time for function does not add up). Annyone care to take a look?
14:50:26 <shachaf> gwern: You should be one of the mentors that goes to Mountain View at the end!
14:50:35 <shapr> YES!
14:50:37 <gwern> shachaf: but then I'd have to like pay for a plane!
14:50:38 <shapr> That would be awesome!
14:50:42 <shapr> gwern: Nah, they fly you there.
14:50:48 <gwern> shapr: and as I already said, imposed too much on my sister this year
14:51:02 <hpaste> BMeph annotated ‚ÄúIntMap update‚Äù with ‚ÄúIntMap annotation by BMeph‚Äù at http://hpaste.org/55150#a55154
14:51:50 <Peaker> benmachine: Someone I know is a CPR/emergency cardiologist -- he says most of the official instruction from the American Heart Association is in constant flux, not scientifically verified, etc
14:52:07 <benmachine> Peaker: oh, I hadn't heard that
14:52:26 <benmachine> the two things I've heard from pop-culture medicine wrt CPR are
14:52:39 <gwern> 'evidence-based medicine, man how does it work? we don't know!'
14:52:44 <Peaker> benmachine: he says they recently changed their instructions to continue pumping the heart without testing for pulse -- which can cause re-arrest after heart starts
14:52:53 <deech> nm, it's a problem with GHC 7.2.1. Sorry for noise, should have Googled first.
14:52:54 <benmachine> a. you should roughly speaking do it to the beat of Staying Alive, or Another One Bites The Dust, depending on how optimistic you feel
14:53:05 <benmachine> b. if you don't break a rib you're not pressing hard enough
14:53:12 <homie`> lol
14:53:49 <bozhidar> #haskell
14:53:54 <shapr> bozhidar: You called?
14:53:57 <Axman6> correct!
14:54:04 <bozhidar> no
14:54:07 <Peaker> benmachine: what do they say about the breath-in-mouth part? The specialist explains it's a waste of precious time and should not be done at all
14:54:42 <benmachine> Peaker: I don't know anything about that part
14:54:49 <Peaker> and that all of the modern machinery is also much much slower than just immediately doing it by hand -- and not scientifically shown to have any improvement, at all
14:55:00 <benmachine> Peaker: I should point out this education is largely from dinosaur comics, not like, actual training
14:55:06 <Peaker> heh
14:55:17 <bozhidar> #emacs
14:55:49 <parcs> Peaker: i read that too
14:57:25 <Peaker> parcs: somehow they get lots and lots of emergency services to buy those machines, though
14:58:28 <parcs> i meant the breath-in-mouth thing being totally useless
14:59:42 <parcs> i never heard of a cpr machine..
15:00:26 <shapr> DrSyzygy: So anyway, written any Haskell lately?
15:00:53 <Gulli> Hey!
15:01:04 <Gulli> could someone explain to my what ($) means?
15:01:06 <DrSyzygy> shapr: Nope. But I'm writing GAP kernel modules -- does that count?
15:01:08 <Gulli> Google is not helping
15:01:11 <ezyang> @src ($)
15:01:11 <lambdabot> f $ x = f x
15:01:17 <Gulli> concaat?
15:01:21 <parcs> Gulli: ($) in function application as a function
15:01:42 <shapr> DrSyzygy: graph automorphism problem?
15:01:45 <Gulli> hmm, I though $ ment ()
15:01:52 <DrSyzygy> shapr: http://www.gap-system.org/
15:01:54 <Peaker> parcs: when you pump the heart -- you're actually pumping the lungs too, so breathing happens naturally anyway
15:01:57 <Axman6> it sort of does...
15:02:15 <DrSyzygy> Apparently, some of the crazy people at Heriot-Watt are controlling GAP computations wiht a parallel gap controlling script. :-P
15:02:15 <shapr> DrSyzygy: Why in the kernel? no context switching costs?
15:02:16 <Axman6> Gulli: f . g . h $ x === (f . g . h) x
15:02:17 <parcs> Peaker: yep
15:02:19 <DrSyzygy> *parallel haskell
15:02:28 <DrSyzygy> shapr: kernel as in writing C code, not GAP code.
15:02:36 <Axman6> Gulli: it's basically just there to same having to use some brackets
15:02:48 <DrSyzygy> shapr: And what I'm doing is computational geometry -- I'm currently writing glue to get access to libANN for approximate nearest neighbour searches.
15:02:54 <Gulli> yeah I thought so
15:02:59 <ion> > map ($42) [pred, id, succ]
15:03:00 <lambdabot>   [41,42,43]
15:03:00 <Gulli> but still im not able to rewrite this function
15:03:02 <shapr> DrSyzygy: Wow, sounds like fun!
15:03:29 <Gulli> multiApply f c = sum(zipWith ($) f c)
15:03:42 <Gulli> how would I go about removing that ($)?
15:03:56 <ion> Replace it with id
15:04:06 <Axman6> Gulli: multiApply f x = sum (zipWith (\g y -> g y) f c)
15:04:17 <Gulli> ahh a lambda function
15:04:20 <Axman6> if that makes it any clearer what it's doing
15:04:28 <Gulli> right?
15:04:35 <DrSyzygy> shapr: Meh. It's as close as I get to doing the research _I_ want to do while also doing the research my PI and my funding agency expect me to be doing.
15:04:48 <Axman6> also replacinf ($) with id would also work, as ion said (but it's probably less clear to you why)
15:05:05 <shapr> DrSyzygy: Yah, that's always a hard balance to find. I'm still thinking about doing research after my undergrad, so trying to learn more about that sort of thing.
15:05:10 <ion> ‚Äú($) f x = f x‚Äù means ‚Äú($) = \f x -> f x‚Äù, therefore you can substitute ($) with the definition and the other way around.
15:05:15 <ion> s/therefore //
15:05:30 <Gulli> everything seems much easier in Haskell
15:05:58 <Axman6> heh, we don't hear that often
15:06:00 <Gulli> or from my point of view, im just begining with it
15:06:06 <ion> Quote-worthy? :-)
15:06:12 <Axman6> glad you feel that way though :)
15:06:22 <Axman6> @remember Gulli everything seems much easier in Haskell
15:06:22 <lambdabot> Done.
15:06:37 <Gulli> ><
15:07:52 <DanBurton> Hey guys can you give me a sanity-check on this answer I posted to SO? I'm pretty sure it's right but not 100% confident. http://stackoverflow.com/a/8468399/208257
15:10:16 <dgpratt> Axman6: I finally made peace with moppy and sausage :-)
15:11:34 <dgpratt> someone was in here earlier asking some questions about that exercize; I thought for a while about how I would explain the solution to that problem
15:12:07 <dgpratt> now it finally makes sense to the point that I can generalize/internalize the solution
15:12:26 <DanBurton> dgpratt: tetris, but with types!
15:12:35 <dgpratt> DanBurton: lol; too right
15:13:13 * DanBurton wants to create an MMO where you fight baddies with the Haskell type system
15:13:28 <Marian> is there a trick to concat IO lists? in other words, I have a function that returns an IO [a], which I use in map, so I have [IO [1,2], IO [3,4]]. I want to get IO [1,2,3,4] out of it
15:13:38 <c_wraith> :t liftM2 concat
15:13:39 <lambdabot>     Couldn't match expected type `a2 -> r' against inferred type `[a]'
15:13:39 <lambdabot>     In the first argument of `liftM2', namely `concat'
15:13:39 <lambdabot>     In the expression: liftM2 concat
15:13:41 <c_wraith> err
15:13:45 <c_wraith> :t liftM2 concat
15:13:45 <lambdabot>     Couldn't match expected type `a2 -> r' against inferred type `[a]'
15:13:46 <lambdabot>     In the first argument of `liftM2', namely `concat'
15:13:46 <lambdabot>     In the expression: liftM2 concat
15:13:49 <c_wraith> :t liftM concat
15:13:50 <lambdabot> forall a (m :: * -> *). (Monad m) => m [[a]] -> m [a]
15:13:51 <c_wraith> I fail
15:13:59 <DanBurton> fmap concat, or equivalently, liftM concat
15:14:03 <c_wraith> anyway, liftM concat works
15:14:06 <donri> stupidity: trying the same thing and expecting different results ;)
15:14:30 <DanBurton> Marian: having [IO [a]] sounds weird
15:14:47 <dgpratt> donri: sounds like an imperative programming language
15:14:57 <donri> hah!
15:15:14 <ion> IO [IO [IO a]]
15:15:19 <donri> FP: not stupid -- Einstein
15:15:20 <DanBurton> Haskell: trying the same thing and getting the same results :)
15:15:46 <DanBurton> Marian: is the code you are working with small? Can you hpaste it?
15:16:54 <DanBurton> http://hpaste.org/new/haskell
15:18:05 <Philippa> liftM concat's a lambdacat, even
15:18:05 <Marian> http://paste.pocoo.org/show/519485/
15:18:24 <Marian> er, oh I hope it doesn't matter which paste i use ;)
15:19:37 <DanBurton> Marian: personally I heart hpaste, but any pastebin will do I guess
15:20:08 <mike-burns> @src forM
15:20:09 <lambdabot> forM = flip mapM
15:20:29 <donri> speaking as a totally unbiased member of the pocoo team, the lodgeit pastebin is quite a good one; but hpaste is particularly good for haskell. :P
15:20:34 <DanBurton> @hoogle [IO [a]] -> IO [a]
15:20:34 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
15:20:34 <lambdabot> Data.Typeable gcast1 :: (Typeable1 t, Typeable1 t') => c (t a) -> Maybe (c (t' a))
15:20:34 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
15:20:35 <jmcarthur> :t liftM concat . sequence
15:20:35 <lambdabot> forall a (m :: * -> *). (Monad m) => [m [a]] -> m [a]
15:21:18 <DanBurton> I wonder if "asum" is the solution here
15:21:20 <xplat> 18:40  * DanBurton wants to create an MMO where you fight baddies with the Haskell type system <-- if you write any network-facing or setuid code in haskell, you don't need an MMO, you live it
15:22:03 <jmcarthur> asum just folds <
15:22:05 <jmcarthur> oops
15:22:12 <jmcarthur> asum just folds <|> over it, i'm betting
15:22:21 <jmcarthur> not the same thing
15:22:25 <DanBurton> foldr <|> empty
15:22:28 <DanBurton> is the implementation
15:22:33 <jmcarthur> liftM concat . sequence   works fine
15:23:01 <DanBurton> yeah sequence, then liftM concat works I guess.
15:23:24 <DanBurton> I'm still queasy seeing [IO [a]] though
15:23:31 <xplat> won't asum in the list monad's Alternative work just fine?
15:23:41 <jmcarthur> yeah i'm betting it was created by a map where a mapM would be more appropriate
15:23:46 <xplat> oh, IO
15:24:11 <DanBurton> > asum [[4, 5, 6], [7,9,2]]
15:24:12 <lambdabot>   Not in scope: `asum'
15:24:20 <xplat> then sequence . asum?
15:24:31 <DanBurton> > let asum = foldr <|> empty in asum [[4, 5, 6], [7,9,2]]
15:24:32 <lambdabot>   Ambiguous occurrence `empty'
15:24:32 <lambdabot>  It could refer to either `Control.Applicative...
15:24:35 <jmcarthur> > [1,2,3] <|> [4,5]
15:24:36 <lambdabot>   [1,2,3,4,5]
15:24:54 <jmcarthur> liftM asum . sequence
15:24:56 <xplat> er, asum . sequence.  which i guess is concat.sequence in this case ...
15:25:02 <DanBurton> :t empty
15:25:03 <lambdabot>     Ambiguous occurrence `empty'
15:25:03 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
15:25:03 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:55:0-22
15:25:11 <statusfailed> What does <- corresponde to in "do" notation?
15:25:14 <jmcarthur> it would still need the liftM, even
15:25:28 <xplat> xplat: either lrn2read types, or lrn2drink coffee
15:25:28 <jmcarthur> statusfailed: x <- y   ==>   x >>=
15:25:31 <jmcarthur> oops
15:25:33 <statusfailed> for example in List monad, do { xs <- map f}
15:25:35 <jmcarthur> statusfailed: x <- y   ==>   x >>= \y ->
15:25:35 <DanBurton> statusfailed: "do x <- foo; bar" desugars to "foo >>= \x -> bar"
15:25:38 <parcs> @undo do { x <- y; foo }
15:25:39 <lambdabot> y >>= \ x -> foo
15:25:46 <jmcarthur> i hate this keyboard
15:25:53 <shapr> jmcarthur: get one you don't hate?
15:25:57 <jmcarthur> working on that
15:26:00 <shapr> jmcarthur: Buy a kinesis contoured keyboard?
15:26:10 <dgpratt> shapr: $$
15:26:16 <roaldfre> (+1 for the Kinesis)
15:26:47 <shapr> dgpratt: worth it too, I have two in front of me, and wore out two older kinesis keybards
15:26:48 <DanBurton> statusfailed: basically, <- means "perform this monadic action, and assign the result to x". That's not exactly how it works, but sort of.
15:26:57 <jmcarthur> not sure i want to spend $300 on a keyboard
15:27:08 <jmcarthur> ... especially if they wear out like that ;)
15:27:23 <dgpratt> shapr: it looks awfully good
15:27:30 <jmcarthur> really, anything would be nicer than this one
15:27:31 <mike-burns> $300 for a tool you use every day, all the time?
15:27:33 <Marian> yeah that liftm sequence thing does it, thank you
15:27:37 <xplat> i'm trying to think of a way to explain the difference between monads, comonads, and arrows for programming with effects
15:27:42 <shapr> jmcarthur: It did take six or seven years of sixteen hours a day of typing to wear out one.. the other one was a casualty of a breakup.
15:27:54 <jmcarthur> mike-burns: this would apply if it was the keyboard i used at work
15:27:54 <xplat> the assumption being that the audience already understands monads
15:28:13 <DanBurton> :t (return 3 :: IO Int) <|> (return 4 :: IO Int)
15:28:14 <lambdabot>     No instance for (Alternative IO)
15:28:14 <lambdabot>       arising from a use of `<|>' at <interactive>:1:0-44
15:28:14 <lambdabot>     Possible fix: add an instance declaration for (Alternative IO)
15:28:16 <mike-burns> Wild breakup.
15:28:25 <statusfailed> DanBurton: nope, still not following :\
15:28:42 <DanBurton> statusfailed: how much do you know about monads?
15:28:43 <shapr> mike-burns: yes
15:28:50 <Marian> sorry if I didn't really read all your monad and >>=<<>> functions stuff :) I'm new to that whole IO thing, not to speak of monads, i'll have a closer look at that later
15:28:50 <statusfailed> no wait
15:29:25 <dgpratt> xplat: I look forward to you sorting that out, esp. the comonads part; not something I know much (anything?) about
15:29:29 <keep_learning> :t ( return 3 :: m Int ) <|> ( return 4 :: m Int )
15:29:30 <lambdabot>     Could not deduce (Monad m) from the context ()
15:29:30 <lambdabot>       arising from a use of `return' at <interactive>:1:2-9
15:29:30 <lambdabot>     Possible fix:
15:29:50 <statusfailed> DanBurton: bits and bobs
15:30:12 <azaq23> :t (return 3 :: Monad m => m Int) <|> (return 4 :: Monad m => m Int)
15:30:13 <lambdabot> forall (f :: * -> *). (Monad f, Alternative f) => f Int
15:30:20 <DanBurton> statusfailed: are you interested in using do notation for anything except IO right now?
15:30:38 <statusfailed> DanBurton: Yep
15:30:46 <statusfailed> I'm trying to see what it means in context of List
15:30:50 <DanBurton> ok, so the monad explanation then
15:31:01 <DanBurton> I like the List monad :)
15:31:02 <xplat> would it make sense to say that 'with monads, when you ask for a value, the producer of the value decides what effects will happen, and you are affected by them' whereas 'with a comonad, if you produce a value, the consumer decides what effects will happen, and you are affected by them'?
15:32:00 <DanBurton> So first off, some dumb examples
15:32:09 <DanBurton> > do x <- [1..10]; return x
15:32:09 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
15:32:35 <DanBurton> for the List monad, <- selects an element of the list. You might say that it selects every element, nondeterministically.
15:32:37 <jmcarthur> xplat: i don't think that is in line with how i see them
15:32:55 <xplat> jmcarthur: interesting, how do you see them?
15:33:02 <DanBurton> This is because for Lists, bind = concatMap
15:33:48 <roaldfre> Can anyone have a quick look at http://hpaste.org/55153 please? (can't get my head around ghc profiling)
15:33:57 <DanBurton> > do x <- [1..10]; y <- [1,2]; return (x*y)
15:33:58 <lambdabot>   [1,2,2,4,3,6,4,8,5,10,6,12,7,14,8,16,9,18,10,20]
15:34:23 <statusfailed> errrrrr
15:34:23 <DanBurton> statusfailed: how much of this is making sense so far?
15:34:31 <statusfailed> all good up until now I think
15:34:49 <DanBurton> are you familiar with concatMap?
15:34:50 <jmcarthur> xplat: well, for one, i'm not sure i see the distinction between "producer", "consumer", and "you" in your explanation
15:35:22 <statusfailed> DanBurton: no, but frmo the type signature I can guess I think
15:35:42 <statusfailed> essentially a one-to-many functino on each element, concatenated
15:36:03 <xplat> > do { x <- [1..10]; y <- [show, (:[]).toEnum.(fromEnum'a'+)]; y x }
15:36:04 <lambdabot>   Not in scope: `fromEnum'a''
15:36:12 <xplat> > do { x <- [1..10]; y <- [show, (:[]).toEnum.(fromEnum 'a'+)]; y x }
15:36:13 <lambdabot>   "1b2c3d4e5f6g7h8i9j10k"
15:36:16 <DanBurton> > concatMap (\x -> [x, (2*x)]) [1,2,3]
15:36:17 <lambdabot>   [1,2,2,4,3,6]
15:36:19 <statusfailed> I'm still a bit confused about the desugar actually
15:36:45 <DanBurton> statusfailed: I'll make an hpaste so I have more room to demonstrate the desugar
15:36:52 <statusfailed> DanBurton: ok, thanks
15:37:14 <fryguybob> > do x' <- [a,b,c]; y' <- [x,y,z]; return (x'*y')
15:37:15 <lambdabot>   [a * x,a * y,a * z,b * x,b * y,b * z,c * x,c * y,c * z]
15:37:56 <jmcarthur> xplat: i didn't think it through very well, but i think i would say something along the lines of "with monads, you produce context. with comonads, you consume context."
15:38:21 <xplat> jmcarthur: 'you' is the consumer in the first case, the producer in the second
15:39:40 <dgpratt> jmcarthur: that sounds like a good litmus test to tell whether you understand comonads; I'll know I understand them when your explanation makes sense to me :-)
15:39:54 <xplat> if you like pithy, i guess you could rephrase mine with 'monads let you impose effects on your callers; comonads let you impose effects on your callees'
15:41:12 <jmcarthur> dgpratt: there isn't much to understand, really
15:43:49 <hpaste> DanBurton pasted ‚Äúdesugaring List monad‚Äù at http://hpaste.org/55155
15:45:22 <xplat> i'm still figuring out where to fit arrows into it all
15:46:06 <xplat> bearing in mind arrows should really be called 'promonads' (or rather 'strong promonads', but the same applies to regular monads, at least)
15:46:20 <statusfailed> DanBurton: Oh, that's much clearer
15:46:24 <statusfailed> but!
15:46:25 <copumpkin> pronads
15:46:36 <statusfailed> in the very first line, is x not a list?
15:46:37 <Saizan> no procomonads?
15:46:45 <DanBurton> but?
15:46:46 <xplat> they turn out to be the same
15:46:53 <statusfailed> or is that not a problem
15:46:53 <copumpkin> copromonads
15:46:58 <xplat> them too
15:47:02 <copumpkin> shit monads?
15:47:15 <Saizan> oh shit, monads
15:47:16 <jmcarthur> a more violent explanation: monads smash effects together. comonads tear effects apart.
15:47:29 <copumpkin> jmcarthur: let your anger out
15:47:36 <statusfailed> what is the type of x in "x <- ls" ?
15:47:36 <copumpkin> only then can you achieve true inner peace
15:47:41 <DanBurton> monads are to burritos as comonads are to ___???
15:47:49 <jmcarthur> statusfailed: if ls :: m a, x :: a
15:47:50 <statusfailed> no ignore me
15:48:14 * copumpkin complies
15:48:15 <dgpratt> DanBurton: ...what happens when you eat too many burritos?
15:48:22 <xplat> monads are to pumpkins as comonads are to copumpkins
15:48:27 <jmcarthur> dgpratt: comonads happen
15:48:43 <fryguybob> ... as comonads are to being a burrito?
15:48:56 <dgpratt> jmcarthur: I was finishing DanBurton's comment :)
15:49:08 <jmcarthur> ah
15:49:27 * DanBurton contemplates the new moniker of "coburrito"
15:49:42 <xplat> dgpratt: monads are to burritos as distributive laws are to pepto-bismol
15:49:51 <jmcarthur> is that a burrito with the tortilla on the inside?
15:50:03 <statusfailed> Ok, I get it now
15:50:08 <statusfailed> DanBurton: thanks for that paste
15:50:14 <DanBurton> statusfailed: no problem :)
15:50:22 <statusfailed> definitely saving that :p
15:50:56 <dgpratt> xplat: hey, that makes sense!
15:51:46 <jmcarthur> monads are to [f a] -> f [a] as comonads are to f [a] -> [f a]
15:52:32 <jmcarthur> ^^ what i meant by smashing effects together and tearing them apart
15:53:05 <DanBurton> jmcarthur++
15:53:38 <xplat> monads are to concat as comonads are to tails?
15:53:49 <DanBurton> @remember xplat monads are to burritos as distributive laws are to pepto-bismol
15:53:49 <lambdabot> I will never forget.
15:53:59 <xplat> (roughly)
15:54:38 <jmcarthur> not sure that works as a concrete example
15:54:44 <jmcarthur> since the monad is lists and the comonad is streams
15:55:03 <xplat> that's why i said roughly
15:55:04 <dgpratt> is there a good comonad writeup somewhere?
15:55:17 <jmcarthur> trying to think of a non-trivial functor that is both a monad and a comonad
15:55:26 <jmcarthur> i guess stream is...
15:55:39 <jmcarthur> monads are to diagonalization as comonads are to tails
15:55:58 <DanBurton> statusfailed: I answered a question on StackOverflow almost the same way about a month ago: http://stackoverflow.com/q/8029046/208257
15:56:16 <donri> dgpratt: http://www.haskell.org/haskellwiki/Typeclassopedia#Comonad maybe?
15:56:28 <xplat> 'both a monad and a comonad' i think is impossible for nontrivial functors in a way that gives the same Applicative
15:56:32 <jmcarthur> i don't know of any great ones. never read the typeclassopedia stuff
15:56:51 <jmcarthur> xplat: bah!
15:56:57 <dgpratt> jmcarthur: read = past tense?
15:57:06 <jmcarthur> past tense, yes
15:57:20 <jmcarthur> *i have never read...
15:57:38 <dgpratt> jmcarthur: gotcha; ain't English great?
15:57:59 <jmcarthur> if i had formed a complete sentence then i think this would not have been as confusing
15:58:03 <xplat> if one were the best ever at English, one wouldn't cause such confusion
15:58:26 <xplat> unless it was the Pick OS English
15:58:39 <copumpkin> how can I compose enumeratees?
15:58:54 <jmcarthur> :t (.)
15:58:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:59:01 <jmcarthur> :)
15:59:33 <jmcarthur> (i don't remember the type that enumeratees are)
15:59:54 * DanBurton finds it interesting how Monads provide join :: m (m a) -> m a, and comonads provide dup :: w a -> w (w a), which are non-trivial, even though for a comonad, join = extract, and for a Monad, dup = return
16:00:05 <edwardk> xplat: there are plenty of things that are both monads and comonads in a useful way. the condition you are looking for is that join and return are comonad coalgebras or equivalently that the duplicate and extract are monad algebras
16:00:44 <edwardk> xplat: not sure i parsed 'in a way that gives the same Applicative' though
16:00:45 <DanBurton> Can anything besides Identity be both a Monad *and* a Comonad?
16:01:00 <jmcarthur> DanBurton: i don't understand what you just said about join and dup
16:01:09 <jmcarthur> oh i see
16:01:12 <DanBurton> from the types
16:01:29 <jmcarthur> you mean that in some contexts either will fit
16:01:58 <DanBurton> if you want to perform "dup" on a Monad as if it were a comonad, dup = return
16:02:05 <DanBurton> and vice versa for join = extract
16:02:11 <jmcarthur> DanBurton: well, i've already pointed out Stream as an example of both, but as xplat pointed out it might depend on how you define "is both"
16:02:29 <jmcarthur> ah you mean are there any such that your claim holds true in all cases
16:02:37 * hackagebot fix-parser-simple 15320.1 - Simple fix-expression parser  http://hackage.haskell.org/package/fix-parser-simple-15320.1 (MatthewFarkasDyck)
16:02:42 <DanBurton> I guess
16:02:52 <edwardk> DanBurton: a good example is basically any http://en.wikipedia.org/wiki/Bialgebra in the vector space sense
16:03:03 * DanBurton doesn't actually know where his brain is going with this, but the join/dup stuff seems important somehow
16:03:03 <rwbarton> also a monad has two different maps w a -> w (w a)
16:03:18 <parcs> copumpkin: >=>
16:03:29 <DanBurton> rwbarton: what's the other way?
16:03:36 <rwbarton> return and fmap return
16:03:36 <DanBurton> fmap return?
16:03:39 <copumpkin> parcs: that doesn't work
16:03:45 <copumpkin> parcs: or wait
16:03:54 <copumpkin> it uses the function instance of monad?
16:03:55 * dgpratt just remembered listening to some talk about how reactive extensions (LINQ-to-events) was the categorical dual of LINQ
16:04:18 <jmcarthur> @check \x -> return x == (fmap return x :: [[Int]])
16:04:19 <lambdabot>   Not in scope: `myquickcheck'Not in scope: `return'Not in scope: type constr...
16:04:41 <DanBurton> I suspect Comonad has two ways to do join :: w (w a) -> w a ?
16:04:43 <edwardk> DanBurton: note that return is not the same as duplicate for the stream monad/comonad
16:05:18 <jmcarthur> ah, return /= fmap return
16:05:27 <xplat> copumpkin: if you figure out how to compose enumeratees let me know.  i actually only tried in enumerators, but the function i came up with to compose them, while it worked in ideal circumstances, didn't handle leftovers in the Right Way
16:05:28 <jmcarthur> fails on [], in this case
16:06:07 <copumpkin> xplat: eww
16:06:15 <jmcarthur> DanBurton: sure. extract and fmap extract
16:06:33 <xplat> copumpkin: basically, it composed them like enumeratees compose onto an iteratee, but composing like enumeratees compose onto an enumerator would have worked better
16:07:13 <copumpkin> xplat: the whole iteratee nonsense feels close to good, but feels extremely dirty and overcomplicated somehow
16:07:18 <rwbarton> DanBurton: yep, extract and fmap extract
16:07:30 <copumpkin> like, it almost works the way I'd hope it would work
16:07:30 <DanBurton> jmcarthur, rwbarton: d'oh that was easy
16:07:35 <copumpkin> but there are so many nasty special cases
16:07:43 <xplat> copumpkin: but that seems to be harder, because enumeratees are iteratees first and enumerators second, in a certain precise way
16:07:47 <edwardk> danburton: saying something is both a monad and a comonad is not very useful because there isn't any law immediately to saw how the two relate. thats why its better to instead think of monads and comonads that are somehow compatible, like i mentioned above where return and join are comonad coalgebras
16:08:46 <DanBurton> edwardk: I can understand what you just said at a very hand-wavy level of detail :) but that makes sense I guess
16:09:09 <edwardk> otherwise you have no idea what extract . return  or return . extract means
16:10:00 <edwardk> http://en.wikipedia.org/wiki/Monad_(category_theory)#Algebras_for_a_monad
16:10:10 <parcs> copumpkin: hmm yeah, >=> doesn't actually work.. i'm not sure how to compose enumeratees directly, but the usual iteratee pipeline looks something like: enumerator $= enumeratee $= enumeratee $= ... $$ iteratee
16:10:30 <copumpkin> it just feels like if I have Enumeratee x y m a and Enumeratee y z m a, I should be able to get Enumeratee x z m a
16:10:52 <edwardk> extract for your comonad being a monad algebra for your monad would let you reason using the diagrams from that link
16:10:53 <copumpkin> or the other way around
16:11:03 <DanBurton> s/z/c and you almost have Enumeratee y m c a
16:11:20 <jmcarthur> based on what parcs just said, what about ($.) a b x = a $= b $$ x
16:11:23 <xplat> copumpkin: i find the same thing about iteratees btw.  i want to improve them somehow.  i even reserved a channel name on here if people want to discuss that ...
16:11:26 <jmcarthur> again, i don't know the types
16:11:35 <copumpkin> xplat: ooh
16:12:00 <edwardk> DanBurton: in particular the diagram on the right in the link i just gave shows you how extract . return = id follows
16:12:22 <xplat> i was going to grab a wikia and start filling it with notes, but i didn't get around to it yet
16:12:53 <xplat> ##iteratees fwiw, but i'm the only one in there :-7
16:13:19 * DanBurton wonders if working on one of the Iteratee libraries would be a good GSOC project
16:13:35 <edwardk> xplat is the iterati, scheming behind our backs and controlling the flow of information in the world.
16:13:44 <copumpkin> DanBurton: more than working on a library, I want someone to clean up the fundamental idea
16:14:23 <DanBurton> @google xkcd standards
16:14:24 <lambdabot> http://xkcd.com/927/
16:14:24 <lambdabot> Title: xkcd: Standards
16:14:34 <DanBurton> relevant ^
16:14:36 <edwardk> copumpkin: too many things on my plate. i gave you It. thats as far as I'm going. ;)
16:15:02 <copumpkin> edwardk: :P
16:15:08 <DanBurton> edwardk: thanks for the wiki links, btw
16:15:17 <copumpkin> DanBurton: I just think the idea feels icky, but close to what it should be
16:15:21 <edwardk> DanBurton: or http://xkcd.com/974/
16:15:59 <DanBurton> copumpkin: I think we all feel the same icky-yet-close feeling about them, too
16:58:47 <edwardk> updated the hac boston wiki entry with the room #s
16:59:08 <edwardk> if someone wants to tweak maps etc. now that we know those, it would be great
16:59:12 <edwardk> preflex: xseen kmc
16:59:13 <preflex>  kmc was last seen on freenode/#haskell 4 hours, 46 minutes and 17 seconds ago, saying: MostAwesomeDude, we might have to change the word "value" to "object" and "type" to "class" in the docs
16:59:23 <edwardk> @tell kmc room #s confirmed and on wiki
16:59:23 <lambdabot> Consider it noted.
17:17:37 * hackagebot zoom-cache-pcm 0.2.2.0 - Library for zoom-cache PCM audio codecs  http://hackage.haskell.org/package/zoom-cache-pcm-0.2.2.0 (ConradParker)
17:32:37 * hackagebot fix-parser-simple 15320.2 - Simple fix-expression parser  http://hackage.haskell.org/package/fix-parser-simple-15320.2 (MatthewFarkasDyck)
17:43:36 <scooty-puff> i was hoping someone here could help me with some syntax related to a paper i am reading
17:43:48 <scooty-puff> and using to implement type inference, the compiler for the language being written in haskell
17:44:34 <scooty-puff> below the "bar", for the APP operation of the Hindley-Milner syntax/(type system)
17:44:51 <scooty-puff> it show pis <subscript>|tv(gamma)
17:44:57 <scooty-puff> where gamma is the type context/environment
17:45:07 <scooty-puff> and psi is the substitution
17:45:30 <scooty-puff> the paper in question is type inference with constrained types
17:45:36 <scooty-puff> page 6
17:46:14 <scooty-puff> i understand psi \ {alpha} means psi without the alpha substitution
17:47:38 * hackagebot applicative-quoters 0.1.0.3 - Quasiquoters for idiom brackets and an applicative do-notation  http://hackage.haskell.org/package/applicative-quoters-0.1.0.3 (BenMillwood)
17:49:42 <alistra> hi
17:50:21 <byorgey> scooty-puff: I am looking at page 6 of that paper and I don't see what you're talking about
17:50:45 <byorgey> scooty-puff: the paper is by Odersky, Sulzmann and Wehr?
17:51:27 <scooty-puff> byorgey, correct, let me get the page from the bottom, not from the pdf reader
17:51:39 <byorgey> oh, in Figure 3?
17:51:47 <scooty-puff> figure 4
17:52:17 <byorgey> I think we are looking at different papers, there is no figure 4 in the paper I'm looking at
17:52:18 <scooty-puff> i understand <subscript>| means "evaluated at" generally
17:53:00 <scooty-puff> its the figure that shows the type inference rules for VAR, ABS, etc.
17:53:02 <rfm47> Hi!  any thoughts on which web framework i should look into first?  i've used happs (pre-happstack), but am not up to speed on the yesod/snap/happstack pros/cons
17:53:07 <byorgey> scooty-puff: they don't define the notation anywhere earlier in the paper?
17:53:33 <donri> rfm47: one of those three, yes, beyond that it's highly subjective and dependant on your use case
17:53:45 <scooty-puff> not that i can tell - i'm kind of hoping it means apply the substitution to the type context's free variables
17:53:51 <scooty-puff> (tv == freeVars)
17:54:01 <byorgey> scooty-puff: oh, "Let phi|U be the restriction of the substitution to the domain U"
17:54:14 <scooty-puff> o, bleh, was worried it meant that..
17:54:17 <scooty-puff> ok, thanks!
17:54:31 <donri> rfm47: it's also trivial to mix and match packages from all those projects together
17:54:37 <byorgey> scooty-puff: it just means to throw out all the mappings that don't correspond to free vars of Gamma
17:55:21 <mateu> donri: that's good to know, I was wondering how easy it might be to write a project that could target all three.
17:55:35 <donri> why would you want to do that
17:55:43 <mateu> because I'm wacked
17:55:47 <donri> ah.
17:55:49 <mateu> by acmeism
17:55:50 <rfm47> donri, yeah, that's the impression i was getting.  i like acid-state, but am not sure about templating style yet
17:56:12 <scooty-puff> byorgey, i will give it a shot - currently, the way i have implemented it is unsound - equivalent of:
17:56:25 <byorgey> rfm47: I have a friend who swears yesod is the most awesome thing ever.  I know some of the guys who have worked on snap and it seems really impressive, and the documentation is awesome. happstack just released a new happstack-lite package making it easy to get started.
17:56:45 <scooty-puff> let x #= y = x `asTypeOf` y in (x #= True, x #= (0 :: Int)) being considered type safe
17:56:47 <rfm47> byorgey, thanks!  that's sort of the insight i'm fishing for :-)
17:56:51 <byorgey> so all of them seem to have good things going for them, although I've never used any personally =)
17:57:21 <rfm47> i guess the main differences are performance, dynamic-reload handling, request routing...?
17:57:54 <donri> not really, they all perform well and at least happstack does dynamic reloading and i think yesod too
17:58:18 <mateu> are they all hack compliant?
17:58:21 <donri> yesod used to use web-routes from happstack for routing but not in the latest version of its variant
17:58:38 <donri> i like to use happstack stuff because it's more bare bones plain haskell, often
17:58:41 <benmachine> oh dang, I've been uploading uncommitted changes to hackage
17:58:41 <benmachine> oops
17:58:58 <rfm47> donri, as opposed to TH stuff, you mean?
17:59:06 <donri> yesod likes to put everything in quasi-quoters for better or worse, snap likes to be more practical and traiditional with xml templating etc
17:59:38 <donri> but, again, you can mix and match these components quite freely
17:59:51 <rfm47> donri, thanks, also very useful.
18:01:28 <donri> if you want to get started quickly and get something presentable fast you might like yesod because it provides scaffolding and a lot of sugar via quasi-quoting etc
18:02:08 <donri> OTOH if you used to know happs, happstack might still be familiar to you
18:02:23 <cheater> not really, happs is a fairly big rewrite
18:02:43 <donri> yes, but conceptually similar right?
18:02:56 <cheater> donri: you can use snap with html DSLs very very easily
18:03:02 <cheater> donri: i wouldn't say so.
18:03:03 <rfm47> yeah, it's familiar to me, seemingly
18:03:08 <donri> snap has a concept of snaplets which allow a component based design
18:03:18 <cheater> yes, snaplets are a biggie
18:03:19 <donri> and xml templates are designer friendly and enforce valid html
18:03:21 <rfm47> ah, snaplets, that was something i wanted to learn more about!
18:03:26 <cheater> it's very important to be able to modularize
18:03:38 * mateu wonders how hack is fitting into all this.
18:03:52 <donri> so they all have their strengths, depending on your needs and preferences
18:06:26 <donri> rfm47: happstack optionally uses TH but mostly for deriving instances for datatypes
18:07:09 <donri> rfm47: by contrast yesod tends to invent custom syntax for stuff like templating and routing and parse in quasi-quotes
18:07:13 <rfm47> donri:  i see.  i think i'll spend some time figuring out snaplets, and if i like them i'll try out snap
18:07:24 <donri> both approaches have pros and cons
18:07:38 * hackagebot git-annex 3.20111211 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20111211 (JoeyHess)
18:09:24 <donri> @wiki Web/Frameworks
18:09:24 <lambdabot> http://www.haskell.org/haskellwiki/Web/Frameworks
18:09:33 <rfm47> yep, i've read that
18:12:07 <donri> why do everyone say snap has such great docs? am i missing something?
18:12:26 <donri> byorgey!? :D
18:12:45 <byorgey> donri: does it not have great docs anymore? it used to
18:13:13 <rfm47> they seem ok
18:13:27 <donri> well, most of it is api docs and heist and now snaplets
18:13:52 <donri> i'm not sure where this "sensible and clean monad for web programming" is documented
18:15:52 <donri> and most of the heist docs are about the xml language, not much about splicing
18:17:49 <scooty-puff> byorgey, if you still have that paper about and don't mind spending the type:
18:18:17 <scooty-puff> it looks like as described, some things may be typeable by the rules given, but otherwise unsafe, by my understanding (which is .. not great)
18:18:19 <scooty-puff> i.e.:
18:19:13 <scooty-puff> \ x . (f (x + 1)) (not x) for some f
18:19:59 <mayahustle> hi, i'm trying to learn Haskell's FFI, I created a simple C file and header, along with a .hsc file, used hsctohs, and then loaded into ghci specifying the path to my header file, and ghci complains that it can't load my file
18:20:05 <ion> lenstr: Thanks for the information! We appreciate it.
18:20:15 <mayahustle> any suggestions would be great
18:21:45 <ion> The first lmgtfy result: http://gbacon.blogspot.com/2009/06/loading-object-files-into-ghci.html
18:24:47 <scooty-puff> byorgey, i may have found it - algorighm W specifies that the APP rule e1 e2 should apply the substituion produced by e1 to the type environment/context before checking e2
18:24:54 <scooty-puff> if i add that to the constraint version
18:24:55 <scooty-puff> it works
18:25:20 <mayahustle> :ion why do you need the extra shell script, if ghci provides the -L and -l flags?
18:28:12 <benmachine> ho hum
18:28:24 <benmachine> I'm trying to work out what is the shiniest way to build CGI scripts
18:28:37 <benmachine> can any of the previously-mentioned web frameworks help me
18:28:42 <mayahustle> oh wait, i just realized, in the error report ghci is trying to open libfoobar.dylib, my library is simply foobar.h, do I need to rename something?
18:31:26 <parcs> benmachine: i think yesod can. it is built on top of wai which has a cgi frontend
18:34:38 <Sgeo> @hoogle [Int]->[Int]
18:34:39 <lambdabot> Data.Graph.Inductive.Query.BFS bfsn :: Graph gr => [Node] -> gr a b -> [Node]
18:34:39 <lambdabot> Data.Graph.Inductive.Query.DFS dfs :: Graph gr => [Node] -> gr a b -> [Node]
18:34:39 <lambdabot> Data.Graph.Inductive.Query.DFS rdfs :: Graph gr => [Node] -> gr a b -> [Node]
18:36:13 <Bynbo7> sebz: that's a very specific type. what are you looking for exactly?
18:36:20 <Bynbo7> uh, Sgeo, not sebz
18:36:47 <Sgeo> Axman6, accumulating a list of numbers with addition
18:36:57 <Sgeo> Erm, similarly to tail . scanl (+) 0
18:37:00 <Sgeo> I think
18:37:08 <Sgeo> :t tail . scanl (+) 0
18:37:09 <lambdabot> forall a. (Num a) => [a] -> [a]
18:37:12 <Axman6> > scanl (+) 0 [1..10]
18:37:13 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55]
18:37:21 <Jafet> :t mapAccumL (+) 0
18:37:22 <lambdabot>     Occurs check: cannot construct the infinite type: acc = (acc, y)
18:37:22 <lambdabot>       Expected type: (acc, y)
18:37:22 <lambdabot>       Inferred type: acc
18:37:35 <mayahustle> \quit
18:37:40 <shachaf> \end{irc}
18:37:42 <Axman6> there's nothing built in for that specific task however (nor should there be)
18:38:02 <Axman6> > scanr (+) 0 [1..10]
18:38:03 <lambdabot>   [55,54,52,49,45,40,34,27,19,10,0]
18:38:19 <Axman6> > scanr f z [a,b,c,d] :: [Expr]
18:38:20 <lambdabot>   [f a (f b (f c (f d z))),f b (f c (f d z)),f c (f d z),f d z,z]
18:38:32 <Axman6> hmmmm
18:38:47 <Axman6> > scanr const 10 [1,2,3,4]
18:38:48 <lambdabot>   [1,2,3,4,10]
18:39:05 <Axman6> i've never seen that was to do append before...
18:39:40 <shachaf> I think Axman6's sentence caught a bug in my English parser.
18:39:49 <shachaf> There's a _|_ in there somewhere.
18:40:13 <Axman6> way*
18:40:28 <byorgey> I've never seen what that to do English before
18:41:10 <byorgey> hah, funny, I actually couldn't figure out what you meant
18:41:19 <byorgey> one letter can make a big difference =)
18:41:27 <shachaf> > scanl (flip const) 10 [1,2,3,4]
18:41:29 <lambdabot>   [10,1,2,3,4]
18:41:43 <shachaf> Incredible.
18:41:53 <scooty-puff> can anyone explain what |- (turnstile) means, compared to |-<superscript>w
18:41:53 <Axman6> :O
18:43:12 <shachaf> > (fix . scanl (flip const)) 'A'
18:43:14 <lambdabot>   "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...
18:43:43 <Axman6> zomg, scanl is totz a turing complete language!!1!!
18:45:22 <shachaf> > fmap fmap fmap fmap (fmap fmap) fmap fix (fmap scanl) flip const 'A' -- Much better.
18:45:24 <lambdabot>   "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...
18:45:45 <Jafet> shachaf's a sucker for the pointfree.
18:45:58 <Axman6> free?
18:46:10 <PatrickRobotham> shachaf: How do you keep all those fmaps in your head?
18:46:28 <shachaf> Jafet: Is there a way to eliminate all the parentheses?
18:47:00 <sam7> Hi
18:47:20 <sam7> I have a code http://hpaste.org/55156
18:48:02 <byorgey> scooty-puff: they don't have fixed/standard meanings.  They are probably just two different judgments.
18:48:03 <sam7> I want to make: discGaussians' :: (RandomGen g, Real r, Random a, Integral a) => g -> r -> Int -> [a] -> [a]
18:48:10 <sam7> is this possible?
18:48:12 <byorgey> scooty-puff: you'll have to look back through the paper to see where each is defined.
18:48:34 <scooty-puff> ok
18:48:42 <scooty-puff> looks also like i wasn't looking at the final version of the paper
18:49:14 <Jafet> > let a = flip const in concat $ fix . scanl a $ ":-) "
18:49:15 <lambdabot>   ":-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-...
18:49:44 <shachaf> > concat . repeat $ ":-) "
18:49:45 <lambdabot>   ":-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-...
18:50:02 <sam7> Hi I have a short code here http://hpaste.org/55157
18:50:11 <sam7> I'm not sure how I can solve the error
18:53:00 <Sgeo> Has the Netwire wiki page been updated for Netwire 2 yet?
18:54:16 <sam6> hi is Real abstract type?
18:56:25 <ion> > cycle ":-) "
18:56:26 <lambdabot>   ":-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-...
18:57:13 <Axman6> sam9: Real is a class. types can implement Real
18:57:16 <Axman6> @src Real
18:57:17 <aavogt> sam9: what's supposed to happen when your    w*r == 5.5?
18:57:17 <lambdabot> class  (Num a, Ord a) => Real a  where
18:57:17 <lambdabot>     toRational      ::  a -> Rational
18:58:13 <aavogt> does that mean your result will be between -5 and 5 inclusive, or -6 and 6...
18:58:45 <aavogt> you need to explicitly say what kind of conversion you want, say with one of floor round
18:58:54 <aavogt> @type floor
18:58:55 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
19:00:12 <aavogt> @type (floor . toRational)
19:00:13 <lambdabot> forall b a. (Integral b, Real a) => a -> b
19:07:16 <sam9> aavogt: if w*r == 5.5
19:07:34 <sam9> then I want an Integral between -5.5 and 5.5
19:07:45 <Axman6> so between -5 and 5
19:07:49 <sam9> so one of -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5
19:08:11 <Axman6> > truncate (-5.5)
19:08:12 <lambdabot>   -5
19:08:17 <Axman6> > truncate (5.5)
19:08:18 <lambdabot>   5
19:08:28 <Axman6> you need to use trancate then
19:08:31 <Axman6> :t truncate
19:08:32 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
19:09:46 <sam9> then I want to truncate the result of randomR?
19:09:51 <sam9> or the param?
19:10:01 <Axman6> the parameters
19:10:09 <Axman6> -r*w and r*w
19:10:51 <sam9> hm2026 then it seems to give me malformed class assertion
19:11:06 <Axman6> you probably need to change Real to RealFrac
19:11:12 <Axman6> :t truncate
19:11:12 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
19:11:22 <Axman6> sam9: learn to read type signatures, they are your friends
19:12:39 * hackagebot husk-scheme 3.4.3 - R5RS Scheme interpreter program and library.  http://hackage.haskell.org/package/husk-scheme-3.4.3 (JustinEthier)
19:12:40 <sam9> wait2026 if we put RealFrac, then a cannot be Integral right?
19:12:40 <hpaste> ttat pasted ‚Äúincrement n-th list item ‚Äù at http://hpaste.org/55162
19:12:54 <Axman6> look at the type of truncate
19:12:58 <ttat> hi is this the most natural way to increment the n-th list item?
19:13:03 <Axman6> :t truncate
19:13:04 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
19:13:45 <sam9> hm2026 then is there no way to define the function so that I can pass in an Integral, Double, or etc. as r?
19:14:03 <irene-knapp> why
19:14:22 <irene-knapp> are you posting control characters.... oh hmmmm... that's U+2026
19:15:04 <irene-knapp> horizontal ellipsis
19:15:04 <irene-knapp> ah
19:15:08 <irene-knapp> you must be on a Mac :)
19:15:12 <irene-knapp> it does that to me, too
19:15:25 <irene-knapp> (but not on this connection because it's in a terminal)
19:17:22 <sam9> is there a function toIntegral?
19:17:39 <shapr> :t toIntegral
19:17:40 <lambdabot> Not in scope: `toIntegral'
19:17:44 <shapr> :t fromIntegral
19:17:44 <lambdabot> forall a b. (Integral a, Num b) => a -> b
19:18:12 <sam9> is it possible to convert types such as Double to Integral?
19:18:22 <copumpkin> :t round
19:18:22 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
19:18:25 <copumpkin> :t truncate
19:18:26 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
19:18:33 <copumpkin> :t ceiling
19:18:34 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
19:18:40 <copumpkin> :t floor
19:18:40 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
19:18:43 <sam9> I see...
19:18:46 <benmachine> what copumpkin is trying to say is, no, there is no way to do that
19:19:03 <benmachine> > floor pi
19:19:04 <lambdabot>   3
19:19:26 <irene-knapp> who would eat pi off the floor?
19:19:49 <irene-knapp> > 0.0 == 1 + e ^^ i * pi
19:19:56 <lambdabot>   mueval: ExitFailure 1
19:19:56 <lambdabot>  mueval: Prelude.undefined
19:20:03 * benmachine blink
19:20:06 <irene-knapp> hm
19:20:08 <irene-knapp> how did that happen
19:20:09 <copumpkin> **
19:20:16 <irene-knapp> > 0.0 == 1 + e ** (i * pi)
19:20:18 <irene-knapp> ah thanks
19:20:20 <lambdabot>   False
19:20:25 <sam9> I want a function that can take in a number (can be Int, Integer, Double, Float, etc.) and change that number to an Integral type
19:20:57 <benmachine> sam9: there are functions which do Double and Float and Rational
19:20:57 <irene-knapp> as we can see, nobody has implemented my "subset of irrational numbers represented as parameters defining a convergent infinite series" type yet
19:21:01 <irene-knapp> which would allow that to be True
19:21:23 <benmachine> irene-knapp: ...parameters?
19:21:35 <benmachine> sam9: it's kind of weird to want to round Integers :)
19:21:38 <sam9> benmachine: so I guess there is no function that works for all...
19:21:46 <benmachine> sam9: you could define one with a typeclass
19:21:59 <irene-knapp> like, I would imagine there's some sort of expression with fractions and exponents and stuff which covers most of the common cases, trig functions and e and pi and roots
19:22:02 <benmachine> sam9: there isn't one because usually you know what type you are dealing with, so you know which function to use
19:22:07 <irene-knapp> but I don't really know enough math to know if that's true :)
19:22:18 <benmachine> irene-knapp: it's... nonstraightforward
19:22:21 <benmachine> I think
19:22:23 <irene-knapp> well, certainly
19:23:09 <irene-knapp> the last time I looked at it I got as far as trying to figure out whether transcendental numbers were the same concept
19:23:14 <irene-knapp> and failing to determine that, meh
19:23:29 <benmachine> transcendental numbers are not the solution of any equation
19:23:38 <benmachine> so every transcendental number is irrational
19:23:38 <copumpkin> any polynomial
19:23:43 <benmachine> err yes
19:23:46 <benmachine> that's what I meant
19:23:48 <irene-knapp> oh hmmmmm
19:23:52 <irene-knapp> thanks
19:24:00 <irene-knapp> that's actually a much nicer statement of it than wikipedia has
19:24:09 <benmachine> "almost all" real numbers are transcendental :P
19:24:13 <irene-knapp> not sure I understand why pi and e are tra.... OH because it doesn't allow trig in the equation
19:24:33 <irene-knapp> yes, well, intuitions like "almost all" are pretty damn useless when talking about infinite sets :D
19:24:45 <benmachine> irene-knapp: yeah, just multiples, sums, and positive integer powers
19:25:08 <irene-knapp> gotcha
19:25:31 <irene-knapp> and presumably you mean any FINITE equation
19:25:38 <benmachine> I believe that the existence of transcendental numbers was proven some time before anyone found one
19:25:42 <irene-knapp> since you can in fact express pi and e as an infinite series
19:25:50 <irene-knapp> er, as separate infinite series :)
19:25:53 <benmachine> irene-knapp: copumpkin was right, I meant polynomial
19:25:55 <sam9> benmachine: if I create a typeclass, how can I go about it briefly?
19:25:59 <irene-knapp> ah, gotcha, good then
19:26:40 <benmachine> sam9: class TurnThisThingIntoAnInteger a where becomeAnInteger :: a -> Integer
19:26:54 <benmachine> sam9: instance TurnThisThingIntoAnInteger Integer where becomeAnInteger x = x
19:27:14 <benmachine> sam9: instance TurnThisThingIntoAnInteger Float where becomeAnInteger x = truncate x
19:27:17 <benmachine> etc.
19:27:22 <sam9> I see...
19:27:42 <benmachine> sam9: it's important to choose names that are not terrible like mine
19:27:50 <benmachine> terrible-like-mine that is
19:28:24 <irene-knapp> note that you have some limits
19:28:55 <irene-knapp> because instance (Floating f) => TerribleName f is considered to be the same instance as instance (RealFrac f) => TerribleName f
19:29:04 <irene-knapp> not sure just why that is :/
19:29:21 <irene-knapp> but anyway it means you can't have both of them in effect at once without doing things that it's better you don't
19:29:40 <benmachine> irene-knapp: because types can be Floating and RealFrac, and then which would you choose?
19:29:45 <irene-knapp> yes, but
19:30:07 <irene-knapp> it seems like it would be better to establish some sort of precedence rule than to disallow it altogether
19:30:14 <sam9> benmachine: for type instantiation, is it possible to have a non concrete type?
19:30:18 <sam9> for instance
19:30:34 <Axman6> like what?
19:30:41 <sam9> instance TurnThisThingIntoAnInteger RealFrac where becomeAnInteger x = truncate x ?
19:30:54 <benmachine> sam9: not really
19:30:56 <sam9> or something like that?
19:31:03 <Axman6> instance RealFrac f => TurnThisthingIntoAnInteger f where ...
19:31:19 <Axman6> but I'm not sure if that's a good way to do it
19:31:30 <benmachine> sam9: suppose you did that, and then you also defined instance TurnThisThingIntoAnInteger Integer
19:31:40 <benmachine> sam9: then someone comes along and defines instance RealFrac Integer
19:31:52 <benmachine> sam9: never mind that it doesn't make sense, you now have ambiguity
19:32:12 <benmachine> sam9: we don't like ambiguity, so we say you can't define both the original instances
19:32:42 <benmachine> you can define *one* general instance, or you can define an instance for each concrete type separately
19:32:47 <benmachine> usually you want to do the latter
19:33:16 <sam9> I see...
19:33:22 <irene-knapp> with MPTCs, you can actually define many semi-general instances :D
19:33:48 <irene-knapp> but this is not applicable to your problem
19:33:52 <irene-knapp> merely an example of me being annoying
19:35:40 <irene-knapp> :t unfoldl
19:35:44 <lambdabot> Not in scope: `unfoldl'
19:35:45 <irene-knapp> :t unfoldr
19:35:46 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
19:35:48 <irene-knapp> :t unfold
19:35:49 <lambdabot> Not in scope: `unfold'
19:35:55 <irene-knapp> hm
19:36:32 * jessopher is starting to notice the better parts of hackage failing to build with 7.0.3
19:36:59 <irene-knapp> > unfold (\toVisit -> case toVisit of { [] -> Nothing ; (item:rest) -> Just (item, rest) } ) [1, 2, 3]
19:37:00 <lambdabot>   Not in scope: `unfold'
19:37:03 <irene-knapp> > unfoldr (\toVisit -> case toVisit of { [] -> Nothing ; (item:rest) -> Just (item, rest) } ) [1, 2, 3]
19:37:04 <lambdabot>   [1,2,3]
19:37:06 <irene-knapp> oh good
19:37:48 <gwern> is it wrong of me to be amused that dcoutts or Mikhail only post on the SoC cabal projects *after* I designate them failures in my SoC page?
19:38:04 <irene-knapp> haha
19:38:08 <irene-knapp> maybe?
19:39:18 <byorgey> gwern: no, being amused is appropriate I think =)
19:40:00 <irene-knapp> > True && True
19:40:00 <lambdabot>   True
19:40:04 <gwern> (I guess this falls into the 'weeellll I was going to get around to it evveennntually....' category of things)
19:40:07 <irene-knapp> > and True True
19:40:08 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
19:40:08 <lambdabot>         against inferred typ...
19:40:11 <irene-knapp> ah, okay
19:40:34 <byorgey> gwern: I am amused that the *act* of labeling a SoC project a failure may in fact cause it to eventually be a success.
19:41:09 <byorgey> squeaky wheel gets the oil, &c.
19:41:10 <gwern> byorgey: I know right?
19:42:31 <irene-knapp> :t intercalate
19:42:32 <lambdabot> forall a. [a] -> [[a]] -> [a]
19:42:43 <irene-knapp> @hoogle forall a . a -> [[a]] -> [a]
19:42:45 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
19:42:46 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
19:42:46 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
19:42:49 <irene-knapp> ah, there we go
19:43:08 <irene-knapp> > intersperse ' ' ["This", "is", "a", "bunch", "of", "words."]
19:43:09 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
19:43:09 <lambdabot>         against inferred type...
19:43:25 <irene-knapp> oh, hm
19:43:29 <irene-knapp> so intercalate is what I want.  fair.
19:52:38 <ddarius> Yeah, they just quietly stuck intercalate sometime several years ago.  Before then it was always concat . intersperse ",".
19:54:08 <jessopher> luckily, hlint knows about it
20:01:29 <hpaste> ‚Äúthing in the box‚Äù pasted ‚Äúnobody‚Äù at http://hpaste.org/55163
20:45:23 <alkabetz> If I need to share mutable state between functions, I should use an IORef or an MVar that I pass in to each, correct?
20:46:11 <c_wraith> if you truly need to share mutable state, yes.  However, needing to share mutable state is rare.
20:47:00 <alkabetz> I'm writing a network-backed filesystem with HFuse, and I'd like the various FUSE operations to be able to share and update a cache.
20:47:28 <c_wraith> That's a case where it's probably what you want then, since you're doing IO anyway
20:47:36 <alkabetz> OK, cool.  Thanks.
20:52:40 * hackagebot yesod-auth 0.7.7.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.7.7.1 (MichaelSnoyman)
21:36:49 <vrook> instance Functor (ST s) ...  instance Show (ST s a) ... I don't see the pattern of when (ST s a) is needed vs (ST s).
21:37:12 <shachaf> vrook: Because of the kind of Functor instances vs. Show instances.
21:37:30 <shachaf> Functors instances take an argument; Show instances don't.
21:38:24 <vrook> What is ST s called and what is ST s a called?
21:38:54 <vrook> The former is partially specified, or something?
21:40:12 <shachaf> vrook: No, they're both just things.
21:40:16 <shachaf> ST s a is a type of kind *.
21:40:21 <shachaf> ST s is a type of kind * -> *
21:40:34 <Folklore> does haskell produce native code
21:40:50 <Enigmagic> Folklore: GHC does, GHCi uses an interepreter
21:41:30 <Folklore> thx
21:43:31 <int-e> in any case that's a question of the implementation of the language rather than the language itself. hugs interprets haskell code, nhc/yhc and jhc compiles to native code via C, ghc has its own native code generator and an llvm backend, an interpreter, and a C based backend that is not really used anymore
21:44:30 <accel> is there some functional pearl I can use, together with zippers, for serialization/deserializatino persistent documents? I want a nice way to read/write the (current state of doc + all historical state of doc)
21:44:43 <mizu_no_oto> Is there a term for the kind of checking you do with QuickCheck?  Is it considered Unit Testing, or is there a different term for it?
21:44:56 <shachaf> mizu_no_oto: Quick checking.
21:45:01 <int-e> Are there other significant implementations of Haskell that I forgot? (I included some that are not up-to-date anymore. almost everybody seems to be using ghc anyway.)
21:45:14 <shachaf> int-e: There's hbc...
21:45:57 <int-e> true. thanks
21:49:15 <Folklore> Enigmagic to just x86 or x86-64, ARM or what?
21:50:17 <VHD> I am trying to make a shogi (is a chess variant) game, I used the hsChess as a starting point. My problem is, calculating the game tree for say even 2 ply down is really slow and this is before any searching is applied.
21:55:44 <vrook> Whenever * -> * is expected, I put (ST s), and whenever * is expected I put (ST s a). I suppose I can get by with that, but I don't really understand what's happening. kinds aren't covered in Hutton or (that I can see) in RWH.
21:56:34 <vrook> Does (ST s) produce a sort of "function", whereas (ST s a) is some sort of "value"?
21:56:44 <shachaf> vrook: Yes, more or less.
21:56:50 <shachaf> vrook: On the type level.
21:57:00 <vrook> But s has no connection to a.
21:57:10 <vrook> You can't get an a from an s.
21:57:30 <mzero> vrook: do you see how Maybe is different than Int  ?
21:58:00 <vrook> Yes, but I can't get a Maybe Int from a Maybe.
21:58:35 <mzero> I don't know what you mean by that
21:58:37 <vrook> what is a "function" on the type level called, as in (ST s).
21:58:48 <vrook> Just * -> * without a name?
21:59:05 <mzero> I'd call it a "type constructor"
21:59:16 <mzero> a thing that will construct a type from a type
21:59:17 <shachaf> vrook: Well, that's a pretty good name. :-)
21:59:25 <shachaf> It happens that all type-level functions are also constructors.
21:59:45 <espringe> If this is the last "pattern" in my function:
21:59:45 <espringe> jesus x = x
21:59:49 <Folklore> is it true haskell has no equivilant for a structure?
21:59:54 <Folklore> also whats this 1 module per file thing
21:59:55 <espringe> is it possible to simplify it to something, like:
21:59:55 <espringe> jesus = id
22:00:04 <Saizan> shachaf: or partial applications of them?
22:00:17 <Enigmagic> espringe: generally yes
22:00:20 <mzero> espringe: no - because all patterns must have the same number of arguments
22:00:35 <espringe> That's the error i'm getting, about diff amount of arguments
22:00:35 <mzero> so only if all your patterns take no arguments
22:00:45 <espringe> No, the other patterns have arguments
22:00:46 <shachaf> Saizan: That's why I was hesitating to say "constructor" before.
22:00:57 <espringe> So the only way is to have a "dummy" argument like 'x' ?
22:01:01 <mzero> espringe: then you can't -- all patterns for a function must have the same number or arguments
22:01:05 <mzero> yes
22:01:10 <espringe> k, thanks
22:01:18 <mzero> though, I wouldn't call it dummy there - you're using it!
22:01:18 <shachaf> Saizan: But I think you could argue that "F" and "F x" are both constructors.
22:01:40 <Enigmagic> Folklore: have you looked at records?
22:01:51 * mzero wonders what shachaf's F is
22:02:49 <Enigmagic> Folklore: scroll down to the 'Record syntax' section here http://learnyouahaskell.com/making-our-own-types-and-typeclasses
22:03:13 <Folklore> thanks
22:04:03 <shachaf> mzero: Some two-argument constructor.
22:06:09 <VHD> has anyone done a chess implementation in shogi using bitboards?
22:06:16 <VHD> in haskell*
22:06:45 <Saizan> shachaf: i guess so
22:09:11 <espringe> http://hpaste.org/55165
22:09:11 <espringe> Two things. The warning on line 7, about a redudant $. If i remove that $, the code doesn't compile
22:09:20 <espringe> Also, do you have any pointers on making that more succinct?
22:10:53 <Saizan> did you add the parens when you removed $?
22:11:04 <shachaf> espringe: To the first point: Looks like a bug in hlint, vaguely.
22:11:23 <espringe> Why would I add parens? Isn't the whole point of using $ to not add parens?
22:11:25 <Saizan> espringe: if you click on the warning it shows the actual code to replace
22:11:45 <Saizan> espringe: you'd save the outer ones
22:11:46 <Enigmagic> shachaf: looks correct to me
22:11:48 <espringe> oh cool
22:12:00 <Enigmagic> shachaf: expand the warning out and it makes sense
22:12:01 <espringe> I didn't see that it suggested moving the parens
22:12:05 <espringe> yeah nice
22:12:06 <espringe> thanks
22:12:24 <shachaf> Oh, oh, I see its proposed solution.
22:12:29 <shachaf> Never mind.
22:12:35 <shachaf> hlint is very pushy.
22:13:37 <espringe> Ok, here's the cleaned up version: http://hpaste.org/55167
22:13:38 <espringe> What can i do to make that more succinct?
22:14:07 <mzero> espringe: camelTake and camelDrop are doing very very similar work ---
22:14:49 <espringe> I couldn't see how to unify it though
22:14:50 <Saizan> > groupBy (\x y -> isLower y) "JesusSaves"
22:14:52 <lambdabot>   ["Jesus","Saves"]
22:14:57 <mzero> have you considered merging them into one function that returns both parts?
22:14:58 <Saizan> > groupBy (\x y -> isLower y) "esusSaves"
22:14:59 <lambdabot>   ["esus","Saves"]
22:15:14 <shachaf> Saizan++
22:15:19 <espringe> Saizan: jesus. Well done.
22:16:14 <Saizan> the old art of abusing groupBy :)
22:20:44 <espringe> Saizan: It fails on the case like "JesusSavesHTML", where "HTML" should be one big word :D
22:20:45 <espringe> any ideas?
22:22:02 <mzero> espringe: yours fails or his?
22:22:07 <espringe> his
22:22:38 <mzero> eh, well, that's what you get from a bunch o' wizards -- amazing one-liners that don't quite work!
22:22:39 <mzero> :-)
22:23:14 <mzero> you're code was fine - but you could make it smaller by doing the take/drop thing as a single function:
22:23:27 <shachaf> espringe: I don't think HTML *should* be one big word.
22:23:28 <mzero> have it return (String, String)
22:23:47 <espringe> shachaf: Alas, that is the problem specification
22:23:47 <shachaf> At least, not by most wiki camelcasing algorithms I've seen.
22:23:56 <mzero> shachaf: how do you know his definition of CamelCase??
22:24:07 <espringe> 'H', 'T', 'M', 'L' isn't 4 different words
22:24:23 <ddarius> Actually, that's exactly what it representts.
22:24:52 <espringe> Sure, but for instance -- if i'm pretty printing camelcase stuff by intercalating a space. IT shouldn't be "H T M L"
22:25:09 <espringe> Anyway, this is for a predefined problem -- so i can't really cahnge it
22:25:14 <shachaf> mzero: All I know are the standard ones.
22:25:50 <espringe> shachaf: Any idea how to adapt that awesome one liner for my wrong (?) specification?
22:25:54 <shachaf> espringe: Is this homework, by the way? It's considered polite to mention that, if so.
22:26:02 <espringe> shachaf: nope
22:26:11 <espringe> shachaf: Just a language comparison
22:26:13 <shachaf> espringe: You could post-process the output by finding one-character strings and merging them with the thing that comes after them.
22:26:17 <shachaf> espringe: Ah.
22:26:32 <shachaf> espringe: How should "IAmAWord" be parsed? :-)
22:26:47 <espringe> 'IAm' 'AWord'
22:26:54 <espringe> http://pastebin.com/bgSvhQUs
22:26:54 <espringe> Is the original definition (in python)
22:26:56 <mauke> The paste bgSvhQUs has been copied to http://hpaste.org/55168
22:26:59 <espringe> That's what im rewriting
22:30:10 <muep> hello
22:31:07 <mzero> yo, muep, what's up?
22:34:47 <muep> is there some empty IO action I could use a placeholder in a record?
22:35:03 <mzero> return ()
22:35:28 <mzero> though, if it is really a placeholder, and you want to be sure you'll never use it -- there is always   undefined
22:35:47 * mzero wonders what being in a record has to do with it
22:38:44 <muep> it is a placeholder in the sense that I think I want it as the default value in the record
22:39:14 <mzero> is the type of the field   IO ()   ?
22:39:32 <muep> yes, that's what I thought I'd put there
22:41:16 <mauke> espringe: I translated your python to haskell but I think it's ugly
22:41:20 <mzero> defaultSnork = Snork { sAction = return (), sPattern = "*", sWibble = False }
22:41:34 <muep> mzero: I am not very skilled in haskell but return () seems to do exactly what I want there, so thanks
22:41:54 <mauke> espringe: http://hpaste.org/55169
22:41:55 <espringe> mauke: cool :o got a link?
22:42:00 <espringe> mauke: thanks
22:43:09 <espringe> mauke: Looks pretty good, it's better than the one i did
22:47:56 <mauke> espringe: direct version: http://hpaste.org/55169
22:48:05 <mauke> looks like split doesn't buy you much
22:48:46 <mauke> yeah, the second version also works better with infinite strings
22:49:37 <espringe> mauke: Very nice, that 2nd one looks much nicer
22:51:29 <mauke> espringe: http://hpaste.org/55169
22:51:37 <mauke> third version, now without `elem`
22:51:51 <espringe> wouldn't "isLower" and "isUpper" be even cleaner?
22:52:01 <mauke> yes, but semantically different
22:52:06 <espringe> good point
22:52:16 <mauke> > isLower '√ü'
22:52:16 <lambdabot>   True
22:52:41 <espringe> Well done, that looks really good
22:52:45 <espringe> thanks for that, i got to go now
22:57:08 <cwraith> > liftM2 (&&) (>0) (<10) 7
22:57:09 <lambdabot>   True
22:57:24 <mauke> > inRange (1, 9) 7
22:57:25 <lambdabot>   True
23:47:26 <tomHaskell> I have little experience with IRC. How does it work?
23:55:44 <tomHaskell> I understand that it's a real time chat. But are all the people in the box right of chat window presently online?
23:55:57 <shachaf> Every last one of them.
23:56:02 <shachaf> (Except for me.)
