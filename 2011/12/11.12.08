00:00:01 <shurikas> but it's still a function
00:00:43 <shurikas> so my definition is wrong?
00:00:45 <dmwit> Okay. So, what's the question, again?
00:00:47 <shurikas> if anybody can check the code
00:01:06 <adrake_> @src (<*>)
00:01:07 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
00:01:17 <dmwit> The code looks okay to me.
00:01:42 <dmwit> It's a bit weird that you named the function a and the value you're applying it to f, instead of the other way around, but it's just alpha-varying.
00:01:55 <dmwit> (On line 9.)
00:02:19 <shurikas> ohh, that's why it looks strange
00:02:19 <Peaker> luite: You compose parser&builder together, like a pickler combinator, but where you control the wire format
00:02:20 <dmwit> Also, you forgot to define "No >>= f".
00:02:29 <Peaker> luite: so you don't have to manually implement both Get and Put, just one
00:03:00 <shurikas> dmwit, it doesn't compile other way around
00:03:19 <dmwit> shurikas: It does for me.
00:03:28 <shurikas> f <*> a = fmap f a
00:03:29 <dmwit> shurikas: Did you remember to switch names on both sides of the equals sign?
00:03:37 <dmwit> shurikas: Yes f <*> a = fmap f a
00:03:43 <shurikas> Yes f O.o
00:03:54 <shurikas> why does it need to include Yes?
00:04:01 <dmwit> Well, that's the type.
00:04:07 <dmwit> Probably (a -> b)
00:04:15 <shurikas> hmm
00:04:16 <shurikas> ok
00:04:19 <dmwit> So it's either a "Yes f" for "f :: a -> b" or a "No".
00:04:35 <Peaker> luite: http://en.wikipedia.org/wiki/Construct_(python_library)  look at the examples
00:05:18 <shurikas> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
00:05:19 <shurikas> ok...
00:05:20 <shurikas> I see
00:05:25 <shurikas> f (a -> b)
00:05:32 <shurikas> thanks
00:05:53 <luite> Peaker: ah tnx, looks interesting. looks like something where adt's might come in handy
00:08:13 <Peaker> luite: these examples don't show the "tricky" parts -- e.g: a Pascal string.  Byte-count followed by that number of bytes.. Trickier if it is some computation of the number of bytes. If you use a lambda, you need a bijective lambda -- and if you want to be able to compile fast C parser or such you need to avoid lambdas altogether
00:08:59 <luite> Peaker: how about IP checksums?
00:11:37 <Peaker> luite: another interesting difficulty.. this is an example case where Haskell makes things somewhat difficult.  I want the DSL to have no "black box lambdas" I would want to be able to write functions using my own primitives and type-class'd points-free combinators so that eventually I can do anything with the computation structure (e.g: make it bijective, compile it to C, etc)
00:12:17 <Peaker> Lots of Haskell's idioms center around lambdas (e.g: Functor and all its subclasses) -- which doesn't work here
00:12:56 <Peaker> s/lambdas/Hask?  Maybe category-extras more generic non-Hask Functor would be more useful here (e.g: A Functor on bijective functions?)
00:13:47 <luite> hmm interesting. I don't know that category-extras thing though :)
00:14:30 <Peaker> you know how Cale generalizes (.) to fmap, and Category generalizes it to Cat compose?
00:14:43 <luite> only the first
00:14:59 <Peaker> There's Control.Category..
00:15:26 <Cale> I prefer (<<<) for Control.Category, but... http://i.imgur.com/xJxVA.gif
00:16:12 <Peaker> If you take a superset of both generalizations, you replace first and second (->) with generalized types: you get something like:  class GenericFunctor cat1 cat2 f where cat1 a b -> f (cat2 a b)
00:16:18 <Cale> Lately I've been working with a *lot* of Arrowy code.
00:16:53 <Peaker> maybe the "f" is actually superfluous here
00:17:19 <Cale> http://www.cs.berkeley.edu/~megacz/garrows/ -- our arrow library is almost identical in terms of its primitives to this one, but we use different names for things :P
00:17:22 <dmwit> I don't think the "computing a checksum" part is hard.
00:17:29 <dmwit> It's the "duplicating information" part that's hard.
00:18:40 <dmwit> We've punted on that problem in both lens papers I've helped with so far.
00:18:46 <Cale> except that we leave arr in, but limit its use
00:18:56 <Peaker> Cale: how do you limit it?
00:19:42 <Peaker> also, I don't see why not write some notation for Category+Applicative once it's established that at least programmatically, they can replace arrows (the extra laws can still be established)
00:19:47 <Cale> By having our own preprocessor for the proc/do notation which uses other primitives in place of it, and only uses arr to match on general patterns, or when general expressions are to the right of -<
00:20:05 <Peaker> (instead of duplicate the abstractions and all the code that revolves around them)
00:20:08 <dmwit> So, to simplify the question: suppose my data type is Int and I want my wire format to repeat the Int twice (in machine format, say). Can Construct do that?
00:20:24 <Peaker> Cale: did you put arr in some subclass/seperate class?
00:20:31 <Cale> Peaker: Arrow shouldn't be what it is right now :P
00:20:39 <Peaker> dmwit: yeah
00:22:14 <Peaker> dmwit: I need to reread that lib to remember how to use it though
00:22:19 <dmwit> Ah, I see, the interesting thing is that everybody *expects* parsers to fail sometimes.
00:22:22 <dmwit> So that's nice.
00:22:30 <luite> Peaker: ah (I think). sorry bit busy, packing stuff and stuff, have to fly to canada tomorrow :)
00:22:34 <Cale> Peaker: yes, and in fact, it's generalised so that you could use some other primitive arrows instead of (->)
00:22:48 <Cale> Peaker: But that's not really essential for us
00:23:11 <dmwit> I don't suppose Construct tries to make any guarantees about when it will and will not fail.
00:23:11 <Peaker> Cale: what's the advantage over Applicative+Category?
00:23:25 <Peaker> dmwit: nope, it's Python :)
00:23:35 <Cale> Having 100% of the information about how everything is bound as an explicit graph structure.
00:24:28 <Peaker> Cale: don't you lose it once you use arr with (->) just like you lose it with fmap?
00:24:37 <Cale> Well, you can't see through arr, of course, but the preprocessor turns pattern matches on non-pair types into uses of arr which produce nested pairs
00:24:57 <GordonFreeman> hello <; SUP Cale
00:25:00 <Cale> and that's pretty much the main place where you end up with arr. Nothing else requires it.
00:25:37 <Cale> well, heh, also cases where you have compound expressions to the right of -< but that's also unavoidable
00:26:02 <Peaker> Cale: well, it would be nice, imo, to fix Cat+App than to use Arrows, because the (*->*) kind is nicer than (*->*->*) when you only want to talk about the output type (as in Applicative)
00:26:08 <Cale> But if you avoid those two, our preprocessor will give you a structure that has only values of a datatype you control in it.
00:26:31 <Cale> (and if you make use of them, you'll get arrs)
00:26:49 <Cale> another concern is that the laws for Arrow are incorrect
00:26:54 <Cale> "incorrect" :)
00:27:22 <Cale> You *really* want  (f >>> g) *** (h >>> k) = (f *** h) >>> (g *** k)
00:28:10 <Cale> It means that the Kleisli arrows of noncommutative monads are not Arrows, but you don't really want them to be, because they're poorly behaved and unintuitive.
00:28:46 <opqdonut> what's a noncommutative monad?
00:28:47 <Cale> Arrowised FRP systems will satisfy that law.
00:29:02 <Peaker> Cale: having two competing abstractions (Functor vs Category for (.), App+Cat vs Arrowy-stuff for points-free combinations) is a really bad thing for Haskell's eco-system, IMO. I think it is possible in both of these cases to have a generalization to rule them all
00:29:37 <Cale> opqdonut: Basically one which doesn't satisfy  do v <- x; w <- y; return (v,w)  =  do w <- y; v <- x; return (v,w)
00:30:05 <opqdonut> oh, right. I started thinking about (>>) being commutative but that didn't make sense
00:30:18 <Peaker> what are interesting commutative monads that give useful power that you don't already get from Applicative?
00:30:20 <opqdonut> so State is noncommutative for example?
00:30:54 <Peaker> The effect order doesn't matter, but you still want to be able to choose effects based on effect results, I guess
00:30:54 <Cale> Peaker: The Functor vs. Category for (.) thing is nothing more than a notational issue. The only reason I think Functor deserves (.) is that fmap is a far more common operation than generalised composition in an Arrow or "Category"
00:31:16 <Peaker> Cale: I disagree - (.) and fmap generalize in different "Directions", but there is a generalization that captures both of these generalizations
00:31:25 <Peaker> Cale: (Category..) and fmap, that is
00:31:37 <Cale> What is that?
00:31:42 <Peaker> Cale: let me find it in category-extras
00:32:02 <Cale> I've tried generalising it in both directions at once, and the ambiguities made it pretty much unusable.
00:32:35 <Peaker> Cale: I think it was this: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Categorical.html
00:34:47 <Cale> hmmm... I'd have to try that to see how the fundeps affect things. It might be fine.
00:39:30 <Peaker> semi-overlapping abstractions lead to library fragmentation
00:39:46 <Peaker> and a lot more teaching/learning to do to get the same expressiveness/usefulness
00:40:21 <Cale> I dunno. I don't think it's that bad to have libraries which are written in somewhat different styles.
00:40:54 <Cale> It's not like the fact that two things are both Arrows makes them automatically any easier to use together than, say, an Arrow and a Monad.
00:41:10 <Cale> You use what sets of combining operations make sense for your library
00:41:24 <Cale> and then worry about what abstractions it fits into
00:41:46 <Cale> (if any)
00:42:33 <Peaker> Cale: A library of combinators for one abstraction is not usable with the other library, though
00:42:46 <Cale> sure
00:42:46 <Peaker> (Anything that's specific only to the generalization will not apply to the other generalization)
00:43:04 <Peaker> sort of the same kind of mess we have with liftA2 vs liftM2
00:43:07 <Cale> Has never been a problem for me
00:43:40 <Cale> Well... liftA2/liftM2 there's a clear way that could be cleaned up because every Monad is an Applicative
00:43:52 <Cale> But even if we don't, it's not a *huge* deal.
00:44:11 <Peaker> liftA2/M2 is not a huge deal -- but a million paper cuts.. :)
00:44:37 <Peaker> It's also hard to know what you're losing when you have library fragmentation -- it's mainly an invisible loss, I think
00:45:28 <Cale> I don't think we'd benefit at all from, say, every library containing an instance of Monad and none of the other abstractions being used, even if that were reasonable.
00:45:41 <Peaker> especially in the Arrow case -- if we have a generalization that captures Functor/Applicative/Monad and the Arrows in a more general way, it may enable interesting things we aren't yet aware of
00:46:13 <ddarius> Arrow already captures Functor/Applicative/Monad.
00:46:27 <Cale> (though I don't want it to capture Monad)
00:46:59 <Varakh> any idea why i'm getting a non-ending loop? http://hpaste.org/54980
00:47:09 <Peaker> ddarius: Arrow sucks, though :)  The example we talked about above is   fmap vs Category.(.)
00:47:37 <Cale> Peaker: It doesn't really suck... it's very close to something quite expressive and useful.
00:47:38 <Peaker> ddarius: I think it possible to have a generalization more general than either of them that makes both of them, perhaps, obsolete
00:47:44 <Cale> It's just missing some primitives that it should have.
00:47:46 <Peaker> Cale: I agree it's very close to not sucking :)
00:47:56 <Peaker> Cale: but "arr" in the base class there makes it really bad
00:48:04 <Cale> nah, arr isn't a big deal :)
00:48:18 <Peaker> Cale: it ruins the whole point, imo, of exposing the computation's structure
00:48:34 <Cale> It doesn't necessarily do so :)
00:48:36 <Peaker> Cale: if it was quarantined in its own sub-class (as you say you have done)...
00:48:46 <Peaker> Cale: Are you talking about Control.Arrow or the concept in general?
00:48:57 <Cale> Not exposing the computation's structure ruins the whole point of exposing the computation's structure
00:48:58 <Peaker> Cale: when I say Arrows suck I'm referring to the specific implementation in Control.Arrow
00:49:23 <DanBurton> Varakh: taking a look...
00:49:30 <Cale> Well, I'm saying that you can keep arr and add some other things, and it'll be totally fine for most EDSLs.
00:49:40 <Cale> You'll get all the optimisations you want, basically.
00:50:00 <Peaker> Cale: Also, the fact the arrows force a product type there makes them less useful. An FRP library of a friend is much like arrows, but uses a sum type instead of arrow types, and the arrows represent event stream
00:50:08 <Cale> ?
00:50:16 <Cale> oh
00:50:20 <Peaker> Cale: the (,) in arrows should probably have been parameterized too
00:50:34 <Cale> Yeah, we've done that too, though we don't make use of that
00:50:39 <Peaker> Cale: well, if you think of "arr" as something that only disables an optimization -- then you don't lose much -- but often you just can't implement it
00:51:02 <Cale> Really the important thing is that (,) is symmetric or braided monoidal with respect to >>>
00:51:05 <Peaker> s/instead of arrow types/instead of product types/  above
00:51:24 <Peaker> Cale: But it is (,) specifically :-(
00:51:42 <Varakh> DanBurton: ok thx
00:51:45 <bwright> Why isn't there a standard type Nat? (Or am I wrong)
00:51:54 <Peaker> Cale: "arr" makes it impossible to make an arrow out of (a->b,b->a)
00:52:05 <Cale> That's okay with me :)
00:52:13 <Peaker> Cale: well, I think it sucks :)
00:52:19 <Peaker> it should not have been in there
00:52:30 <dmwit> bwright: There's a few on Hackage.
00:52:37 <DanBurton> Varakh: which expression are you trying to evaluate that causes the loop?
00:53:10 <Varakh> t2 = ([1,2,3],[(1,2,3),(1,3,2),(2,1,3)])
00:53:21 <Varakh> simple testgraph
00:53:42 <Varakh> i tried it on paper to evaluate it step by step with my functions and i dont see where it fails
00:53:44 <bwright> dmwit: It just makes things like say, take in standard prelude look really ugly.
00:53:47 <Peaker> So if Arrow split "arr" to different classes, used a param type instead of (,), I think it would perhaps become useful :)
00:54:02 <dmwit> bwright: Efficiency matters.
00:54:25 <Cale> What you really need are  swap :: (a,b) ~> (b,a), assocL :: (a,(b,c)) ~> ((a,b),c), assocR :: ((a,b),c) ~> (a,(b,c)), forget :: a ~> (), extendL :: a ~> ((),a), extendR :: a ~> (a,()), retractL :: ((),a) ~> a, retractR :: (a,()) ~> a, and dup :: a ~> (a,a), and to make the arrow notation produce those.
00:54:38 <Cale> (along with ***)
00:54:52 <bwright> dmwit: So there is some inherit cost in having a Nat type?
00:55:04 <Cale> You can also generalise over the pair and unit being used
00:55:05 <bwright> dmwit: (I am a haskell newbie)
00:55:05 <Peaker> Cale: I wonder how that matches up with conal's DeepArrow
00:55:06 <Cale> (and we do)
00:55:12 <dmwit> bwright: Anyway, there are at least the following packages on Hackage with natural number data types: nat, natural-number, naturals, numbers
00:55:24 <dmwit> bwright: Yes; how do you implement it? There's a few choices:
00:55:42 <DanBurton> Varakh: oh OK I think I get it now. Looking into it...
00:56:00 <Peaker> Cale: yeah I guess you'd want to make unit=0 rather than unit=1 if you use (+) instead of (*) for the type
00:56:08 <dmwit> bwright: 1. Use Word, Word8, Word16, Word32, Word64, whatever. Very efficient, but every subtraction now has a conditional.
00:56:13 <Peaker> s/for the type/for the pair
00:56:22 <dmwit> bwright: 2. Peano numerals. Hell on your cache.
00:56:33 <Varakh> DanBurton: thanks. i think this has to work dunno why it doesnt :>
00:57:09 <dmwit> bwright: 3. Lazy binary numerals. Much faster than Peano numerals, much slower than Word... but at least it's correct (unlike Word).
00:57:11 <Cale> Peaker: yeah, actually, you also want fst :: (a,b) ~> a and snd :: (a,b) ~> b, but those fall out in terms of these, and first and second
00:57:40 <dmwit> bwright: 4. Integer with some smart constructors. Also a good choice. There's still lots of runtime checks that plain old Integer doesn't incur, though.
00:57:42 <bwright> dmwit: Couldn't you have something like Nat and Natural (like Int and Integer)
00:57:59 <dmwit> bwright: Sure. That's essentially what Word is.
00:58:14 <Varakh> DanBurton: brb, coffee ;)
00:58:16 <dmwit> bwright: But again, without the subtraction checks that you really need to make it behave like a Nat.
00:58:25 <Peaker> Cale: they're a problem if you use sum types instead of product types
00:58:41 <Cale> Peaker: indeed, but maybe that's something different
00:59:07 <bwright> dmwit: But for example in standard prelude take, you still preform that check n > 0
00:59:24 <bwright> But you have to explicitly state it. I don't really see the elegance in it.
00:59:29 <Cale> Peaker: this structure is actually something which can be described extremely succinctly -- if Control.Category is a reasonable model of categories, then Arrow should be a model of symmetric monoidal categories.
00:59:33 * dmwit nods agreeably
00:59:45 <dmwit> Having a built-in Nat seems like a sensible proposal overall.
00:59:54 <dmwit> Why not submit something official to the Haskell' committee?
01:00:26 <Cale> bwright: You're exchanging one check for another if you use the Num class though :P
01:00:49 <bwright> Cale: Yes but the point is abstraction. I don't have to explicitly write that out.
01:01:46 <bwright> dmwit: I am sure someone more capable then myself has already done so.
01:02:09 <bwright> dmwit: Till then I suppose third party libraries are a good choice.
01:02:12 <Cale> bwright: I think the main reason there's no Nat in the Prelude is bikeshedding.
01:02:25 <dmwit> I wonder: would you (or other programmers) be surprised if take (1 - 5 + 10) took 10 elements, rather than 6?
01:02:31 <Varakh> re
01:03:10 <Cale> The real scourge is Int
01:03:28 <Cale> Let's get Int out of the Prelude first, and then worry about a proper natural datatype :)
01:03:47 <Cale> okay, I need to sleep
01:04:02 <Peaker> Cale: I don't really know my CT :-)
01:04:02 <bwright> dmwit: Yes.
01:04:38 <dmwit> bwright: In that case, I would argue that Int was the right choice (rather than Nat).
01:05:16 <Cale> ... should have been Integer ;)
01:05:27 <dmwit> Sure, sure, Integer rather than Natural.
01:05:43 <dmwit> Though Int is what... like 4 times faster than Integer?
01:06:26 <bwright> If you need a Integer to index you list because it is that big....
01:06:34 <bwright> How often would that actually come up.
01:06:44 <dmwit> [0..] !! 2^1024
01:07:45 <dolio> If you need an integer to index your list, then your program will probably take too long to finish.
01:07:47 <Varakh> DanBurton: i think its the way it try to stop recursion :/
01:07:54 <dolio> Integer, that is.
01:08:19 <DanBurton> Varakh: that would make sense
01:08:43 <Varakh> but i dont know how i do it in another way
01:08:50 <DanBurton> Varakh: what is the purpose of "prim"?
01:09:12 <Varakh> minimal spanning tree
01:09:22 <DanBurton> oh that makes sense
01:09:29 <DanBurton> Prim's algorithm
01:09:32 <Varakh> ye
01:09:52 <DanBurton> oh and that's why it's in the MST module :)
01:10:26 <Varakh> =P
01:10:45 <Varakh> loopPrim n n' e e' | testList n n' = []
01:10:45 <Varakh>                    | otherwise loopPrim n (newEdge n' (searchEdge e (last n'))) e ((searchEdge e (last n')):e')
01:11:01 <Varakh> this might work, but i get an obscure indentation error :o
01:11:41 <DanBurton> try lining up the two pipes
01:11:51 <dmwit> pipes don't need to line up
01:11:57 <dmwit> They don't use layout at all.
01:12:10 <dmwit> Perhaps loopPrim itself doesn't line up with its brothers?
01:12:14 <DanBurton> no but it looks nice and usually works with layout rules
01:12:18 <DanBurton> :)
01:12:32 <dmwit> Varakh: forgot an = after otherwise
01:13:33 <Varakh> -..-
01:13:37 <Varakh> thanks
01:13:56 <Varakh> non-ending loop again ^^
01:15:28 <shurikas> do I need to have exact type to define a Monoid ?
01:16:10 <hpaste> shurikas pasted “monoid doesnt compile” at http://hpaste.org/54988
01:16:19 <shurikas> how can I apply it to this data type?
01:16:46 <dmwit> shurikas: You need some way to combine "a" and "b".
01:16:52 <dmwit> Function application (as you're doing here) won't cut it.
01:17:03 <shurikas> and how can I combine it? or is it up to me to decide?
01:17:03 <dmwit> Perhaps... you could demand that the underlying type "a" be a Monoid? =)
01:17:24 <dmwit> It is up to you to decide.
01:17:41 <DanBurton> Varakh: well tbh I have no clue. Apparently " testList n n' " is never True, which causes the code to infinite loop
01:17:41 <dmwit> But you will probably have to choose something less polymorphic than "Instance a" to put there.
01:17:51 <shurikas> you mean a concrete type?
01:17:54 <dmwit> Like a class constraint on "a", or a particular monomorphic type to replace "a".
01:18:04 <dmwit> shurikas: That's one possibility, yes.
01:18:06 <shurikas> I mean like Num?
01:18:11 <shurikas> type class
01:18:15 <dmwit> That's a possibility, too.
01:18:20 <dmwit> There's lots of possibilities.
01:18:35 <dmwit> But "a" is too unrestricted -- there's no way to combine two arbitrary values that happen to have the same type.
01:18:42 <shurikas> hmm so it's impossible to define a monoid for a polymorphic type?
01:18:46 <shurikas> ok
01:18:55 <dmwit> (Actually, this isn't strictly true. You could throw one of them away, for example.)
01:19:00 <shurikas> and it wouldn't make much sense anyway :)
01:19:28 <shurikas> hmm, you suggested constraining "a" to Monoid a
01:19:29 <dmwit> (And this is often useful, too -- so Data.Monoid defines First and Last, which do exactly that.)
01:19:31 <shurikas> what does it give to me?
01:19:42 <dmwit> shurikas: It gives you mempty and mappend, of course. =)
01:20:33 <dmwit> shurikas: That is, while implementing mappend :: Instance a -> Instance a -> Instance a, you are allowed to call mappend :: a -> a -> a.
01:20:56 <dmwit> shurikas: (Provided that you constrain "a" to be a Monoid, of course.)
01:21:29 <Varakh> DanBurton: it must be true, this function works :/
01:21:35 <shurikas> hmm can't figure a way to define it with Monoid a
01:21:36 <shurikas> :/
01:22:00 <dmwit> shurikas: What have you tried?
01:22:12 <DanBurton> Varakh: have you ever used Debug.Trace before?
01:22:19 <shurikas> well, I need to define a mappend for it
01:22:21 <shurikas> instance Monoid a => Monoid (Instance a) where
01:22:53 <shurikas> thought of this:
01:22:54 <shurikas> mappend (Instance a) (Instance b) = mappend a b
01:22:56 <shurikas> but doesn't work :D
01:23:15 <dmwit> Pretty close, though.
01:23:19 <shurikas> damn it
01:23:24 <Varakh> DanBurton: ye
01:23:29 <dmwit> The only trick is that at the end you had something of type "a" instead of something of type "Instance a".
01:23:39 <shurikas> ahh
01:23:43 <dmwit> But you've got something lying around that wraps up "a"s into "Instance a"s...
01:23:50 <shurikas> Instance (mappend a b)
01:23:55 <dmwit> right =)
01:24:03 <shurikas> thanks :D
01:24:46 <shurikas> hehe to define mempty I still need something concrete
01:25:06 <hpaste> DanBurton annotated “MST” with “MST (with traceShow)” at http://hpaste.org/54980#a54989
01:25:47 <dmwit> shurikas: Yep. But remember, you know "a" is a Monoid, so you get "mempty :: a" and "mappend :: a -> a -> a".
01:26:14 <dmwit> ...one of which is a concrete "a". ;-)
01:26:34 <DanBurton> Varakh: when I use "prim" on "t2" that you said above, e' turns into an infinite list full of (1,2,3)
01:26:51 <DanBurton> according to the trace
01:27:40 <DanBurton> I'm not sure what to make of that but I'm pretty sure that's not what it's supposed to be
01:28:38 <DanBurton> I suggest you play around with traceShow and try to see what Haskell is actually computing for the first few steps
01:28:57 <DanBurton> and contrast with what you calculated by hand
01:33:36 <eisenhowerz> has anyone dealt with the foldrTree problem here?
01:34:24 <dmwit> Describe the problem for us.
01:34:40 <dmwit> Also: is it homework?
01:35:08 <eisenhowerz> unfortunently yes, But I have been starting and working on this problem for 4 hours now... its simple to i know it. one sec. let me drop it in hpaste. =)
01:35:14 <eisenhowerz> starring*
01:37:17 <eisenhowerz> http://hpaste.org/54990
01:38:04 <dmwit> Why are you trying to return lists from this function?
01:38:08 <dmwit> Nothing in the type mentions lists.
01:38:14 <eisenhowerz> So the problem is to write a function that aggreates elements of this binary tree structure.    ex.  foldrTree (:) [] orderedCharTree
01:39:00 <eisenhowerz> thats one of my concerns.. i thought you return lists using [a].   also its part of the assignment. we have to use that... erg
01:39:35 <dmwit> Yes, you write lists using brackets. But foldrTree should not be returning lists, so that's irrelevant.
01:40:09 <eisenhowerz> whops. sorry I meant to say it returns a string. ( sorry still in c++ mode )
01:40:29 <dmwit> Your type doesn't mention String anywhere.
01:41:00 <shurikas> dmwit, mempty = mempty :: a :/
01:41:05 <shurikas> doesn't work :D
01:41:35 <dmwit> Let me try that again, since what I said wasn't 100% correct.
01:41:35 <dmwit> foldrTree should not be implemented with lists in mind.
01:41:42 <dmwit> The fact that you can call it at a type that happens to result in it returning a list is irrelevant. You aren't allowed to use that knowledge when implementing foldrTree.
01:41:57 <dmwit> shurikas: You've got an "a" where you need an "Instance a" again. =)
01:43:05 <dmwit> In other words, foldrTree should work for any type I choose; this happens to include lists and strings and stuff, but also other stuff -- like Int.
01:43:11 <Varakh> DanBurton: ye
01:43:22 <Varakh> i have this too now ^^
01:43:26 <dmwit> So long as I can provide a base case and a combining function, you've got to deal with it. =)
01:43:27 <Varakh> dunno how to fix
01:43:27 <eisenhowerz> dmwit, mer, yea your right.
01:44:12 <hpaste> Varakh pasted “MST” at http://hpaste.org/54991
01:44:27 <Varakh> DanBurton: see new paste
01:49:22 <Varakh> DanBurton: any idea why?
01:51:17 <dmwit> Dude.
01:51:49 <dmwit> Adjacent lines with different choices for the "tabs or spaces" question is a violation of intergalactic law.
01:52:04 <Varakh> :/
01:52:22 <Varakh> any idea why i get a non-ending loop?
01:52:44 <dmwit> No, but I recommend trying to find the smallest input that loops and then tracing what it does by hand for a few rounds.
01:55:45 <dmwit> shurikas: (Did you get it?)
01:55:50 <shurikas> nope
01:55:55 <shurikas> mempty = Instance (mempty :: a)
01:56:04 <dmwit> Yep, perfect. Just leave off the type annotation.
01:56:05 <shurikas> doesn't work :D
01:56:11 <shurikas> WAT
01:56:11 <dmwit> It's not annotating what you think it's annotating.
01:56:23 <shurikas> damn it, why :(
01:56:28 <shurikas> now I am confused
01:56:29 <dmwit> =)
01:56:36 <dmwit> Take a second and I'll explain it.
01:56:42 <shurikas> mempty = Instance (mempty)
01:56:51 <shurikas> mempty for Instance a is Instance for mempty a ?
01:57:18 <shurikas> and as a is Monoid, it looks for mempty for monoid automatically
01:58:05 <dmwit> By default, when you write a type signature with variables in it, those type variables are scoped *only over that type signature*. Similarly, in instance declarations, the type variables are scoped as locally as possible.
01:58:38 <dmwit> So when you write "instance Monoid a => Monoid (Instance a) where ...", the scope of "a" is restricted to the instance declaration -- the type variable "a" is not in scope inside the "where" block.
01:58:45 <dmwit> (Again, I'm talking about "by default" here.)
01:58:54 <dmwit> So, now, you come along and write
01:59:01 <shurikas> so a is automatically a Monoid
01:59:10 <dmwit> mempty = Instance (mempty :: a), and "a" is a *brand new* type variable
01:59:27 <shurikas> but how second mempty is not reffering to first one
01:59:35 <dmwit> and then the compiler is stuck trying to prove that this arbitrary type "a" happens to match the other, non-arbitrary, actually-chosen type "a"
01:59:38 <dmwit> And it can't. =)
01:59:50 <dmwit> It's a bit more clear if we use two different names:
02:00:06 <dmwit> instance Monoid a => Monoid (Instance a) where mempty = Instance (mempty :: b)
02:00:18 <dmwit> Since "a" wasn't in scope in the "where" block, this is a perfectly meaning-preserving transformation.
02:00:32 <dmwit> But now it seems obvious that the compiler would have trouble believing you that "a = b". =)
02:03:40 <hpaste> eisenhowerz annotated “foldrTree” with “foldrTree (annotation)” at http://hpaste.org/54990#a54993
02:04:04 <eisenhowerz> dmwit,  i feel that i'm getting closer but my head can't think recursivly anymore. can you give me some more insight?
02:06:38 <dmwit> eisenhowerz: Getting closer.
02:06:57 <dmwit> eisenhowerz: You're missing a case, though: what should foldrTree do with empty trees?
02:07:28 <dmwit> There's a few other infelicities, but let's start there.
02:08:05 <eisenhowerz> dmwit, you mean like foldrTree f l Empty ?
02:08:32 <dmwit> eisenhowerz: yes
02:08:45 <eisenhowerz> i'm trying to think what it should spit out. should it put out Empty? i was trying to figure that but it would literally explode
02:09:20 <dmwit> It should return something of type "b". Do you have any of those things lying around?
02:09:47 <eisenhowerz> lol well l. sorry for being slow
02:10:56 <eisenhowerz> I shouldn't put out    f l Empty = f l   right?   f l Empty = l ?
02:11:17 <eisenhowerz> i'm having trouble on figuring out what it needs to traverse back up
02:11:35 <yitz> Varakh: a little hard to follow all that. for any expression e of type Bool, "if e then True else False" is equivalent to just e. start by getting rid of all those redundant ifs, so it becomes more readable.
02:11:59 <dmwit> eisenhowerz: Yes, that last one seems sane. I'm not sure I understand what you mean by "traverse back up".
02:13:04 <yitz> Varakh: also, just say "bool" instead of "bool /= False".
02:13:34 <eisenhowerz> dmwit,  nvm. i think i understand .  Any idea next. i'm having massive errors with  the next three cases.  ? Thanks again for helping
02:15:21 <dmwit> eisenhowerz: Yes, let's take one case at a time.
02:15:39 <dmwit> eisenhowerz: The "Node one t1 t2" is my favorite, let's start there.
02:16:15 <dmwit> eisenhowerz: Now, I agree that you want to call foldrTree recursively. But you should check the types of the things foldrTree expects, and the types of the things you're actually handing it.
02:16:28 <dmwit> For example, foldrTree expects a function as its first argument; are you giving it a function?
02:17:11 <yitz> Varakh: anyway, based on the comment, i guess what you really want is testList x = all (`elem` y) x
02:17:13 <eisenhowerz> dmwit, isn't that what f does?     f    =>  (a -> b -> b )
02:17:53 <dmwit> eisenhowerz: Yes. Are you giving foldrTree f as its first argument?
02:18:05 <dmwit> eisenhowerz: (Hint: nope. ;-)
02:18:28 <eisenhowerz> ah. well i thought i was.  can you correct me on it? b/c i have literally no idea on that part ( thus i was trying to figure out that earlier )
02:18:31 <salisbury> is Int of fixed width?
02:18:50 <Varakh> yitz: ye
02:18:53 <dmwit> eisenhowerz: Well, from the code you pasted, you are giving "(f l t1)" as foldrTree's first argument.
02:18:58 <dmwit> eisenhowerz: No?
02:19:45 <eisenhowerz> thats considered as one argument?
02:19:51 <dmwit> Yes.
02:20:10 <eisenhowerz> " foldrTree((f) l t1) "   i don't think that would fix it.. Lol
02:20:27 <dmwit> Parentheses do grouping, not function application.
02:20:39 <dmwit> "f x y z" is the application of "f" to the functions "x", "y", and "z".
02:20:58 <dmwit> "f (x y z)" is the application of "f" to the result of applying "x" to "y" and "z".
02:22:02 <dmwit> Or, more clearly: "f (x y z)" is the application of "f" to the term "(x y z)", that is, to the application of "x" to "y" and "z".
02:22:41 <eisenhowerz> (foldrTree(f) l t1)
02:22:51 <dmwit> That looks a bit more right.
02:22:58 <dmwit> I would also accept no parentheses at all:
02:23:00 <eisenhowerz> Wow. i really doubted my self there
02:23:01 <dmwit> foldrTree f l t1
02:23:30 <dmwit> Okay, so what's the entire line you have now?
02:23:41 <yitz> Varakh: it looks like (a, Integer, a) stands for a vertex.
02:23:42 <dmwit> The one that starts with "foldrTree f l (Node one t1 t2)"?
02:24:00 <eisenhowerz> foldrTree f l (Node one t1 t2) =    foldrTreef l t1  foldrTree f l t2
02:24:21 <Varakh> yitz: ye
02:24:21 <dmwit> Okay. Now, what's weird about that is:
02:24:37 <dmwit> you've given foldrTree seven arguments (!), when it expects only three.
02:24:38 <eisenhowerz> well except the foldrTreef is actually foldrTree f * my bad
02:24:42 <yitz> Varakh: how does newVertex work? as a constant pure value, it always represents the *same* new vertext. is that what you want?
02:25:00 <eisenhowerz> so no wi drop () around both of them ?
02:25:08 <dmwit> hm?
02:25:23 <eisenhowerz> (foldrTree f l t1)  (foldrTree f l t2)  ?
02:25:42 <dmwit> That still gives foldrTree four arguments: f, l, t1, and (foldrTree f l t2).
02:26:10 <dmwit> Maybe instead of trying to get the Haskell syntax right, you should first try to answer the following question:
02:26:17 <dmwit> what three arguments do you want to provide to foldrTree?
02:26:39 <eisenhowerz> func b and the Tree ?
02:27:11 <dmwit> Those are the types of the things you want to supply, yes. But what are the values that have those types?
02:27:53 <Varakh> yitz: why is it always the same vertex?
02:28:10 <Varakh> this is why i get a non-ending loop and i dont know how to fix it
02:28:13 <eisenhowerz> dmwit, i'm not follwing
02:28:41 <sefb1704> hey guys :)
02:29:31 <hpaste> sefb1704 pasted “HaskellAdventure” at http://hpaste.org/54995
02:30:20 <Varakh> yitz: ?
02:30:21 <sefb1704> problem: whatever parameters are given in the "_" he should perform this action but he is also supposed to give them to the next function
02:32:08 <sefb1704> oh whait i think i got it
02:32:14 <sefb1704> sry wasnt thinking
02:32:52 <yitz> in haskell every function and value is pure. when you call a function with certain values, it always gives the same result. within an expression, a single variable always has the same value.
02:33:22 <Varakh> yitz: so what do i have to change in order to get it work
02:33:38 <yitz> Varakh: if you pass newVertex as a parameter to the function, it can have a different value depending on what you passed in. but if it is a global variable it is fixed.
02:33:46 <eisenhowerz> dmwit, Oh wait. i need to output a "b" there  gotcha.
02:34:24 <Varakh> yitz: it should change
02:34:37 <Varakh> with every call of loopPrim
02:35:02 <yitz> Varakh: i don't exactly know what you are trying to do. but you either want newVertex to be a parameter of the function, or you want newVertex to be a function so you can pass it different parameters to get different new vertices.
02:35:54 <Varakh> im trying to get a minimal spanning tree
02:37:00 <yitz> Varakh: perhaps you want your function to have an extra integer parameter you can increment to get unique new vertices. you then may have to pass back the new value of the integer as part of your result.
02:37:39 <yitz> Varakh: ah so the vertices already exist, and you have a supply of them?
02:37:58 <Varakh> ok
02:37:59 <Varakh> got it
02:38:04 <Varakh> :D
02:38:24 <Varakh> replaced newVertex with (searchNew' (snd g) (last n')) in the expression
02:38:33 <Varakh> dont mind the '
02:38:34 <yitz> Varakh: if you have a supply of them, you can pass around a list of the unused vertices and pop one off when you need it.
02:38:34 <Varakh> ;>
02:38:51 <yitz> Varakh: yeah ok
02:39:22 <Varakh> thanks alot yitz
02:39:36 <yitz> Varakh: anyway, without understanding your code, if you expect the vertex to be changing and it didn't, that might explain how you got into an endless loop :)
02:42:42 <Varakh> :F
02:42:43 <Varakh> :D
02:45:37 <Varakh> yitz: got 2 versions and mixed them up. stillt not working :/
02:46:10 <hpaste> Varakh pasted “MST” at http://hpaste.org/54996
02:48:34 <dever> hey all, i'm doing some work with C.Types, specificall CDouble's, and i want to print them out using printf, but can't seem to get it working... any hints?
02:57:11 <Varakh> yitz: deleted it now
02:57:14 <Varakh> the vertex
02:57:17 <Varakh> and it works
02:59:46 <hpaste> eisenhowerz annotated “foldrTree” with “foldrTree (annotation) (annotation)” at http://hpaste.org/54990#a54998
03:00:23 <eisenhowerz> Alright, if anyone could help me with this last part. So I can finally die of exhaustion
03:00:58 <dmwit> eisenhowerz: I think you just got the arguments to "f" backwards on line 30.
03:01:23 <dmwit> eisenhowerz: But you should take just a second after fixing that before you die of exhaustion to do one more thing.
03:02:30 <eisenhowerz> dmwit, FML . Lol  . well at least I painfully went through it
03:02:34 <eisenhowerz> whats the last thing?
03:03:02 <dmwit> eisenhowerz: Suppose a stray dmwit came along and pranked you by commenting out line 29.
03:03:07 <dmwit> eisenhowerz: What would happen?
03:03:53 <eisenhowerz> as i thought prob nothing
03:04:00 <dmwit> Why?
03:04:03 <eisenhowerz> im' pretty sure my algorithm just goes until empty.
03:04:06 <eisenhowerz> b/c my base case is awesome?
03:04:28 <dmwit> Are you just guessing? =)
03:04:47 <eisenhowerz> well this is how i originally designed it but then i grew doubts after ( 9 hours about now * )
03:05:00 <eisenhowerz> am i right? let me test it!
03:05:49 <eisenhowerz> wait is everything coming out backwards .....
03:05:51 <eisenhowerz> =(
03:05:53 <eisenhowerz> * cries*
03:07:12 <dever> can anyone help with formatting the printing of a CDouble please?
03:07:58 <eisenhowerz> dmwit,  Thanks for all your help.  I can't thank you enough.
03:09:43 <dmwit> no worries
03:09:56 <dmwit> dever: I guess "show" isn't enough?
03:10:31 <dever> dmwit: narp, has to be printed to a specified precision :/
03:10:35 <dmwit> dever: If so, take a look at the Numeric module, in particular show{E,F,G}Float.
03:20:52 <prs`> I have a long list of type [(a,b)], how can I get the element with the largest value for b?
03:21:09 <prs`> so I basically want max over a tuple
03:24:45 <kissyboy> maximumBy (compare `on` snd) yourList
03:24:53 <kissyboy> the on function is in Data.Function, i believe
03:24:55 <Axman6> maximumBy (comparing snd)
03:27:43 <eikke> I got some code which crashes 'ghc --make', or makes ghci barf when interpreted, yet if I make a minor change to the code it no longer type-checks
03:27:51 <eikke> code at https://gist.github.com/1446795
03:28:19 <eikke> when changing line 17 to 'print $ c "abc"', it doesnt type-check either, only when using an integer (that's what it looks like)
03:30:53 <alistra> it shouldn't typecheck now
03:30:55 <alistra> i think
03:31:00 <alistra> or hmm
03:32:02 <eikke> alistra: it only type-checks when I have an explicit type annotation in line 10, and use a bool and int when calling 'c'
03:32:21 <alistra> if you use int where?
03:32:24 <eikke> alistra: removing the annotation makes type-checking fail, and using anything but an integer when calling c as well
03:32:27 <alistra> if int then bool else bool
03:32:30 <eikke> alistra: line 17
03:32:57 <alistra> i removed the language pragma
03:33:03 <alistra> and it doesn't typecheck then
03:33:07 <eikke> alistra: then the type annotation can't be used
03:33:38 <alistra> more like they don't work as advertised
03:33:41 <alistra> or the typechecker
03:33:44 <alistra> one of them :P
03:34:00 <eikke> (reason for the code: checking how some code influenced by OCaml's value restriction in OCaml works in Haskell)
03:34:13 <alistra> it should do an error when trying to put this Bool -> Bool in t->t ref
03:34:31 * hackagebot yaml 0.4.1.2 - Low-level binding to the libyaml C library.  http://hackage.haskell.org/package/yaml-0.4.1.2 (MichaelSnoyman)
03:37:33 <eikke> alistra: when using an explicit type annotation (print $ c (1 :: Int)), typechecking fails as well (as expected)
03:38:23 <alistra> it should :P
03:39:47 <harriotq> I'm looking for a make world kind of solution. My code is in ~/foo and then I have some libraries in ~/foo/lib/{hmatrix,primitive,...} which got there by cabal unpack.  So they need to get built along my project and recompiled if I change them.
03:39:54 <eikke> alistra: yup. will check Trac, then report if not reported yet
03:39:58 <hpaste> eisenhowerz pasted “compose” at http://hpaste.org/55001
03:40:26 <eisenhowerz> last thing im' trying to do tonight. any idea how to get this going? b/c iterate usually takes another argument maybe?
03:40:27 <dcoutts> harriotq: an approximation is: cabal install ~/foo ~/foo/lib/{hmatrix,primitive,...}
03:40:41 <dever> dmwit: maybe i don't need to use CDouble, as from what i'm seeing its equivalent to Double? and can be used freely with C arrays?
03:41:11 <dcoutts> harriotq: but it will build all the packages, not skip ones that are unchanged, though those builds will not be full rebuilds of course
03:41:23 <dcoutts> harriotq: so it's not a "make" replacement
03:41:52 <harriotq> dcoutts: I'll try that thanks.
03:41:53 <dmwit> openshake...?
03:42:13 <harriotq> Actually I'd like all the sources be part of the same source tree so there would be only one "project" to build
03:42:26 <Botje> eisenhowerz: you want the num'th element of the list generated by iterate.
03:42:47 <Botje> eisenhowerz: I suggest starting off with id and composing it with (f.)
03:43:10 <Botje> eisenhowerz: so iterate (f.) id
03:43:18 <Botje> eisenhowerz: then take the num'th element from that list.
03:43:36 <shurikas> data Tuple a b = Tuple a b
03:43:36 <shurikas> instance Functor (Tuple a) where
03:43:36 <shurikas>     fmap f (Tuple a b) = Tuple a (f b)
03:43:43 <shurikas> is it possible to apply f to both a and b?
03:43:47 <Botje> no
03:43:52 <shurikas> why not?
03:43:53 <Botje> since you cannot be sure they are the same type
03:44:20 <dmwit> data Twople a = Twople a a
03:44:27 <shurikas> so when using fmap over a data type which has two values, it can be applied only to second value?
03:44:31 <Botje> heh. Twople.
03:44:35 <Botje> reminds me of Eple
03:44:41 <dmwit> shurikas: no
03:44:46 <shurikas> ah, ok
03:44:47 <shurikas> I see
03:44:55 <shurikas> you just defined that both values are of same type
03:44:58 <shurikas> ok
03:46:03 <shurikas> hmm, I still want to have a tuple which can hold values of different types
03:46:11 <shurikas> I'll see if applicative functors can solve my problems :)
03:46:14 <harriotq> So if I have a package in ~/foo/lib/package0 and assuming it contains some code in the root level and then the usual hierarchy like ~/foo/lib/package0/Data/Algorithm/...,  is there a way to make ghc find and compile everything.  Like cd ~/foo && ghc -O2 --make Main.hs  (in which Main imports Data.Algorithm.Bar)
03:46:22 <Botje> shurikas: there are bifunctors thogh.
03:46:30 <Botje> shurikas: where you give two functions.
03:46:47 <dmwit> shurikas: Applicative functors are functors.
03:46:52 <dmwit> So they can't do anything functors can't do.
03:47:01 <shurikas> then maybe I think about monoids
03:47:01 <dmwit> shurikas: But you might be interested in
03:47:12 <shurikas> when I add two touples, I want their both values to be added
03:47:22 <dmwit> class Bifunctor f where bifmap :: (a1 -> b1) -> (a2 -> b2) -> f a1 b1 -> f a2 b2
03:47:48 <shurikas> (Tuple 1 "a") mappend (Tuple 3 "bc") should be (Tuple 4, "abc")
03:48:01 <shurikas> don't mind the mistake
03:48:05 <shurikas> with missing `
03:48:08 <dmwit> > (Sum 1, "a") `mappend` (Sum 3, "bc")
03:48:09 <lambdabot>   (Sum {getSum = 4},"abc")
03:48:13 <shurikas> yeah, Sum
03:48:13 <dmwit> =)
03:48:22 <shurikas> later - Product
03:48:32 <shurikas> and after all - Writer probably :)
03:48:40 <Botje> dmwit wins one lambda cookie.
03:48:42 <shurikas> and maybe one shiny day - State
03:49:27 <jessopher> harriotq: well its not a proper package without a cabal file, so you might beable to rebuild a specification for both packages combined from the two cabal files
03:49:52 <dcoutts> in principle, merging cabal packages is (usually) possible
03:51:56 <jessopher> is there a 'cabal-merge' type tool?
03:52:33 <harriotq> jessopher: I'd like to do away without cabal because it obviously doesn't support the workflow I'm after.  It wants to assume that packages are immutable black boxes and not something that I'm actively tampering with
03:52:42 <Younder> I am studying Real World Haskell. Are there any answers to the problems in this book?
03:53:13 <jessopher> harriotq: well its your workflow, so i cant really argue, but i usually dont get that feeling from cabal
03:54:07 <hpaste> eisenhowerz annotated “compose” with “compose (annotation)” at http://hpaste.org/55001#a55003
03:54:29 <eisenhowerz> Botje, could you take a look at that ?
03:55:56 <Younder> Really, I am a 44 year old man who has been programming for 20 years, I am not a student.
03:55:57 <dmwit> What do you think ($) does?
03:56:08 <dmwit> Younder: heh
03:56:33 <dmwit> ?google real world haskell solutions
03:56:34 <lambdabot> http://haskell.elkstein.org/
03:56:34 <lambdabot> Title: Real World Haskell Solutions
03:56:41 <jessopher> hah
03:56:46 <soiamso> Younder: I never heard that
03:57:16 <harriotq> jessopher: interesting.  So what do you do when you're trying to learn the internals of some package and need to modify it to make learning easier?
03:58:44 <dmwit> eisenhowerz: What do you think ($) does?
03:59:05 <Younder> soiamso, I find some of the problems hard to solve and would like to see if I hit the jackpot or if I missed a better way.
03:59:06 <eisenhowerz> dmwit, google is failing me here to find what $ does
03:59:19 <dmwit> eisenhowerz: Why did you put ($) in your code?
03:59:51 <eisenhowerz> honestly, c&p.   i'm going to shoot that it has the same meaning as ( .. )
03:59:58 <eisenhowerz> with considerations from php
04:00:15 <Younder> I also program PHP..
04:00:16 <soiamso> eisenhowerz: hoogle
04:00:17 <dmwit> uh... what's the meaning of (..)?
04:00:26 <dmwit> Never mind, it doesn't matter.
04:00:31 <jessopher> harriotq: well i do that with my own packages after they bitrot and i forget myself. you can always unregister the package and rebuild, or build to several different environments (two users for two different versions of a package, building and registering them in seperate local environments)
04:00:32 <eisenhowerz> =(
04:00:37 <dmwit> eisenhowerz: ($) is function application.
04:00:41 <Philippa> eisenhowerz: nearly, yeah. There're a few nitpicks and f $ g $ x doesn't do what you want
04:00:48 <Younder> My entire bugtrack system is written in it.
04:00:48 <dmwit> ?src ($)
04:00:49 <lambdabot> f $ x = f x
04:01:06 <eisenhowerz> UhhhHHHHHHHH. wait it does nothing?
04:01:18 <dmwit> eisenhowerz: No, it does something: it applies f to x.
04:01:39 <dmwit> But yes, you're right; what it does is quite trivial.
04:01:46 <Younder> curry you know
04:01:48 <dmwit> Usually it's just used to get rid of some parentheses.
04:01:59 <eisenhowerz> I was close! =)
04:02:03 <Eduard_Munteanu> And it has a different precedence than plain application.
04:02:26 <dmwit> eisenhowerz: Alright, now check your code.
04:02:40 <Eduard_Munteanu> > (+1) . (*2) 3
04:02:41 <lambdabot>   No instance for (GHC.Num.Num (f a))
04:02:41 <lambdabot>    arising from a use of `e_1123' at <i...
04:02:44 <jessopher> harriotq: we are being kind of vague though, it would be a lot easier to talk productively if we were talking in concrete terms... im sure cabal is not the right hammer for every nail
04:02:44 <Eduard_Munteanu> > (+1) . (*2) $ 3
04:02:45 <lambdabot>   7
04:03:21 <Eduard_Munteanu> > ((+1) . (*2)) 3
04:03:22 <lambdabot>   7
04:03:24 <Younder> Laziness I guess takse some getting used to..
04:04:06 <Botje> eisenhowerz: why did you apply num to iterate?
04:04:22 <eisenhowerz> compose num f =  (num $ iterate (f)id)  !! num
04:04:33 <Botje> eisenhowerz: also, iterate f id means that you apply f to id, which is nonsense.
04:04:36 <Younder> nice!
04:05:17 <Botje> eisenhowerz: yes, so why did you do num $ iterate ...
04:05:19 <eisenhowerz> Botje, don't yiou have to tell it how many times to iterate? ( thats what i put num there )
04:05:29 <Botje> eisenhowerz: that's what the !! num is for
04:05:35 <Botje> iterate produces an infinite stream
04:05:51 <Botje> > iterate (f.) id :: [Expr]
04:05:52 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
04:05:53 <lambdabot>         against inferred ...
04:05:55 <Botje> bah
04:06:22 <dmwit> eisenhowerz: I'm a bit concerned that you're just throwing code against the wall to see what sticks.
04:06:41 <Botje> eisenhowerz: you should at least make sure your code typechecks
04:06:42 <dmwit> eisenhowerz: It might be worth taking a walk through a few early chapters of one of the many excellent Haskell tutorials.
04:07:12 <dmwit> ?where lyah
04:07:12 <lambdabot> http://www.learnyouahaskell.com/
04:07:23 <eisenhowerz> dmwit, Botje, Oh yes I know!    I went through 5 of that
04:07:23 <dmwit> ?where rwh
04:07:23 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
04:07:45 <dmwit> There's also the Gentle Introduction and YAHT.
04:07:57 <eisenhowerz> I actually really enjoy this language. is there a large web application to this?
04:08:16 <Botje> eisenhowerz: note that compose num f = (iterate f id) !! num is not 100% correct yet
04:08:31 <Eduard_Munteanu> eisenhowerz: web stuff written in Haskell? You could take a look at Yesod.
04:08:34 <eisenhowerz> Botje, yea your right, it loads but no good
04:08:36 <Botje> compose 5 (+1) 0 will return 4 instead of five.
04:08:42 <Eduard_Munteanu> @google yesod
04:08:43 <lambdabot> http://www.yesodweb.com/
04:08:43 <lambdabot> Title: Yesod Web Framework
04:08:44 <Botje> i'll leave it up to you to fix that.
04:08:49 <harriotq> jessopher: that registering business sounds very complicated and possibly dangerous to my ear. Maybe it's only because of my limited experience, but I'd like the build step be a function of a bunch of source files, not dependent on mutable (possibly shared and outdated) database :)
04:10:21 <eisenhowerz> Botje, I can't actually even run compose 5 (+1) , i get  No instance for (Show (a0 -> a0))    arising from a use of `print'  Possible fix: add an instance declaration for (Show (a0 -> a0))
04:11:53 <Botje> eisenhowerz: yes. because haskell doesn't know how to print functions.
04:12:01 <Botje> eisenhowerz: you have to apply the result of the compose to a value.
04:12:10 <Botje> eg. "compose 5 (+1) 0"
04:12:23 <Botje> or (compose 5 (+1)) 0 if you want
04:12:28 <Botje> it's the same for haskell
04:12:38 <eisenhowerz> oh, i understand ty
04:12:49 <eisenhowerz> and mine outputs 5.. ? lol
04:17:31 <Botje> oh, duh
04:17:32 <Botje> nevermind
04:17:47 <Botje> !! indexes from zero, but [0..] !! 5 is indeed 5
04:17:49 <Botje> so yay, it works!
04:25:53 <alistra> > let a = [0..] in a !! length a
04:25:57 <lambdabot>   mueval-core: Time limit exceeded
04:26:21 <jessopher> harriotq: cabal install can be completely user local. If you have some non-production environment to build in, you shouldn't have to worry about 'danger'. all the changes cabal makes to your system, intermediate files, registration (visibility to other packages), are completely revertible. If you completely trash the local store of configuration and packages, you can remove the configuration
04:26:21 <jessopher> files, and start from scratch.
04:26:32 <alistra> > let a = [0..] in reverse . reverse a
04:26:33 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
04:26:34 <lambdabot>    arising from a use...
04:26:38 <alistra> > let a = [0..] in reverse . reverse $  a
04:26:43 <lambdabot>   mueval-core: Time limit exceeded
04:27:08 <Eduard_Munteanu> alistra: of course, that can't work... you can't get to the last element of an infinite list
04:27:21 <alistra> Eduard_Munteanu: don't worry, i know
04:27:32 <alistra> had my classes on prooving that :P
04:27:34 <Eduard_Munteanu> Oh, I guess you're looking if reverse . reverse fuses.
04:27:57 <alistra> i don't know how list fusion works yet
04:28:09 <alistra> except for the optimizer somehow using RULES pragma
04:28:28 <Eduard_Munteanu> Yeah, that's how it does it.
04:28:43 <Eduard_Munteanu> Although Prelude stuff doesn't involve much fusion.
04:28:45 <alistra> yeah but that somehow
04:29:12 <Eduard_Munteanu> @hackage stream-fusion
04:29:13 <lambdabot> http://hackage.haskell.org/package/stream-fusion
04:30:12 <Eduard_Munteanu> alistra: those rules tell the compiler to replace certain terms with other terms
04:30:43 <Eduard_Munteanu> It's the programmer's job to check those RULES are actually valid.
04:30:50 <alistra> yeah i know that also
04:31:16 <alistra> but how the compiler knows if it's a good thing to fuse the rules
04:31:36 <alistra> also why isn't data.list already fuseagble
04:31:39 <alistra> also why isn't data.list already fuseable
04:32:54 <Eduard_Munteanu> Presumably you write fusion rules which result in an improvement. That is, you don't provide both directions of   map (f . g) = map f . map g
04:33:49 <Eduard_Munteanu> Another thing is the common idioms in Data.List / Prelude aren't really fusion-friendly.
04:34:56 <_oz> to the best of my understanding, functions in Data.List are fused
04:35:13 <_oz> but they use foldr/build fusion not stream fusion
04:35:28 <alistra> is the ghci also using fusion?
04:35:32 <alistra> or just ghc -O
04:36:01 <_oz> -O and upwards
04:36:12 <alistra> is lambdabot -O?
04:36:16 <prs`> kissyboy: thanks!
04:36:18 <_oz> there was a flag to show which rewrite rules kicked in
04:37:23 <harriotq> jessopher: I'm specifically worried about my local environment.  The reason is that building the packages I need will take me some 30 minutes.  (if I install them in a different order than last time, then it might fail altogether)   So if I make a mistake and need to rebuild everything, I'm gonna waste time and lose focus.   So from my point of view, touching cabal in any way is a huge risk that I'd rather avoid.
04:37:55 <jessopher> well merging the packages seems like it would be an even bigger risk
04:37:57 <_oz> alistra: i'd be surprised if lambabot were to optimise.
04:38:04 <jessopher> in that context
04:38:08 <_oz> the flag I was talking about is this: -ddump-simpl-stats
04:38:21 <_oz> from http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/rewrite-rules.html
04:39:19 <jessopher> but i do see your point
04:42:10 <jessopher> im sure there is a way for you to short-circuit the functionality of the depended on package in the depending package, so you do not have to rebuild both each time... but there may not be, and cabal might just be completely out of the question
04:42:50 <alistra> is it good to fuse rev.rev = id?
04:43:10 <alistra> i mean semantics wise?
04:43:40 <hpc> alistra: if your program works unfused it will work fused
04:43:48 <hpc> but if it works fused it might not work unfused
04:43:55 <alistra> ok
04:44:28 <alistra> not sure if we want to have a semantics that makes our programs loop infinitely
04:44:31 <hpc> in terms of performance it cuts out two traversals of the list, which is always a good thing
04:44:49 <alistra> s/have/keep
04:45:22 * jessopher is admittedly a dependency weenie, and has a closet full of reinvented wheels.. so i think i will bow out
04:45:41 <hpc> jessopher: lol, im the same way
04:46:22 <hpc> mostly though i am just lazy
04:46:40 <hpc> if it's easier to do it myself than dig through dependencies, i do that
04:49:20 <alistra> i'm the opposite
04:49:24 <alistra> always hoogling for types
04:49:27 <alistra> :D
04:49:46 <Eduard_Munteanu> Some stuff already fails when you're not using optimizations, but passes otherwise.
04:50:50 <jessopher> well for small dependencies, like a function here and there, sure.. things like monad transformers or parser combinators.. wheel closet
04:51:55 <hpc> i think for parsers i would just use parsec
04:52:18 <hpc> or perhaps look for something else that doesn't break so many Prelude functions
04:53:21 <alistra> happy/alex
04:53:46 <alistra> parsec is for people who don't know context-free grammars
04:54:18 <hpc> i know CFGs and compile errors tend to be extremely non-local
04:54:23 <hpc> so i would rather use parsec for that reason
04:55:01 <jessopher> i have an unnatural aversion to parser generators, and non-locality of errors
04:55:14 <simon> I like parser generators
04:55:25 <alistra> alex uses LINE pragma
04:55:31 <alistra> don't know why happy doesn't
04:55:40 <simon> alistra, what's that?
04:55:43 <alistra> so with alex it's cleaner :P
04:55:47 <simon> I'll just google it.
04:55:57 <simon> ah.
04:58:27 <alistra> simon: are you that simon who wrote happy:P?
04:58:38 <sshine> no. :)
04:58:41 <alistra> :P
04:59:09 <hpc> sshine: there's like five different simons that all do big haskell stuff
04:59:21 <alistra> oh wait
04:59:23 <alistra> it uses them
04:59:38 <sshine> being 'simon' on this channel is majorly ambiguous, yes
05:00:02 <sshine> I have had to change my highlight patterns because so many URLs include 'simonpj', etc.
05:00:14 <hpc> er, alistra: what i said above
05:00:23 <jessopher> being any specific first name in this channel is somewhat ambiguous (it has the population of a small city)
05:00:32 <alistra> :]
05:00:37 <sshine> Haskell City
05:00:40 <hpc> jessopher: only 800 people
05:00:45 <hpc> VERY small city
05:00:58 <jessopher> right
05:01:12 <sshine> not that small. we might have more than one bicycle repair man.
05:01:27 <jessopher> ha
05:01:36 <alistra> and about 800 programmers
05:01:38 <flux> did someone call for a BICYCLE REPAIR MAN?
05:01:41 <flux> (sorry)
05:02:03 <jessopher> well i have a closet full of wheels they can use if somones bike breaks
05:02:16 <hpc> jessopher: you invent them yourself!
05:03:59 <hpaste> a pasted “a” at http://hpaste.org/55006
05:09:17 <jessopher> hpc: they are all derivative wheels honestly. I probably couldnt give them to the bicycle repair main without providing some kind attribution or source code or something
05:13:36 <worldsayhshi> Hello all; I'm in the process of learning haskell and I'm trying to get gtk2hs to work on my laptop. I'm having some issues when trying to install using cabal on fedora 16. The cairo-pdf package seems to be missing when I try installing the gtk package ("cabal: There is no package named 'cairo-pdf'."). Thanks for response.
05:14:18 <Eduard_Munteanu> worldsayhshi: did you update cabal's package list?   cabal update
05:14:23 <worldsayhshi> yes
05:14:38 <ahax> did you install cairo pdf from cabal ?
05:15:00 <Eduard_Munteanu> worldsayhshi: also mind cabal doesn't handle binary or non-Haskell dependencies.
05:15:27 <worldsayhshi> I ran 'cabal install cairo-pdf' which gave me "cabal: There is no package named 'cairo-pdf'."
05:15:44 <worldsayhshi> Well, first I ran 'cabal install gtk'
05:16:07 <worldsayhshi> Mayne the issue is fedora using gnome 3?
05:16:23 <worldsayhshi> so appropriate gtk isn't installed
05:22:17 <jessopher> worldsayhshi did you `cabal update` as well? If the package really exists, it shouldnt matter... it wont work if it installs in the absense of the binary dependencies, but it should still be available
05:23:01 <worldsayhshi> Yes, I've run 'cabal update'.
05:23:03 <jessopher> oh wait that was already said
05:23:25 <Eduard_Munteanu> @hackage gtk
05:23:26 <lambdabot> http://hackage.haskell.org/package/gtk
05:23:37 <jessopher> @hackage cairo-pdf
05:23:38 <lambdabot> http://hackage.haskell.org/package/cairo-pdf
05:24:04 <Eduard_Munteanu> I think he's missing some non-Haskell dependency.
05:25:32 <worldsayhshi> There seems to be some people having similar problems in the comments of a recent update on the gtk2hs page. gnome 3 support seems, from reading about it, to still be a bit bleeding edge..
05:25:43 <worldsayhshi> I'm reading the comments now.
05:25:46 <Eduard_Munteanu> worldsayhshi: what does   pkg-config --modversion cairo-pdf   say?
05:26:13 <Eduard_Munteanu> Or even plain  'cairo'
05:26:26 <Eduard_Munteanu> It could very well be missing altogether.,
05:26:42 <worldsayhshi> "Package cairo-pdf was not found in the pkg-config search path.
05:26:43 <worldsayhshi> Perhaps you should add the directory containing `cairo-pdf.pc'
05:26:43 <worldsayhshi> to the PKG_CONFIG_PATH environment variable
05:26:43 <worldsayhshi> No package 'cairo-pdf' found
05:26:43 <worldsayhshi> "
05:27:16 <worldsayhshi> Eh.. "No package 'cairo' found"
05:27:41 <worldsayhshi> Are these binary packags?
05:29:20 <Eduard_Munteanu> worldsayhshi: you're supposed to get them using your distro's package manager.
05:30:01 <Eduard_Munteanu> I'd try installing plain 'cairo' first.
05:31:54 <jessopher> actually, look waht happens if you follow the links to those packages
05:32:04 <worldsayhshi> Eduard_Munteanu: Heh, I just assumed that everything gtk related was included in the distribution - fedora 16...
05:32:06 <jessopher> they dont exist
05:32:30 <jessopher> well cairo-pdf anyhow
05:32:37 <worldsayhshi> huh
05:32:48 <jessopher> the haskell hackage package
05:32:58 <jessopher> that package isnt in the DB
05:33:48 <Eduard_Munteanu> jessopher: sure, that's the red herring
05:33:58 <Eduard_Munteanu> He's actually missing external deps.
05:34:23 <Eduard_Munteanu> (the "cairo-pdf" message probably comes from pkg-config)
05:34:23 <jessopher> i know, i just think its an important thing to take into consideration.. for later on
05:36:09 <worldsayhshi> cairo is marked as installed in the package manager anyhow... :S
05:36:37 <luite> worldsayhshi: you need the development package
05:37:10 <worldsayhshi> ah
05:37:18 <luite> libcairo2-dev on ubuntu 10.04
05:37:33 <luite> you can apt-file search cairo.pc if you have a debian or ubuntu distro
05:45:25 <sshine> when I use Text.Printf.printf, I get a type signature (PrintfArg a1, PrintfArg a, Ord a1, Ord a, Num a, Num a1) => ... -> [Char]
05:45:31 <carpi> is there a function for inverse of tan? i checked hoogle, there is only an "indegree" and "outdegree" functions for graphs
05:46:07 <Botje> carpi: isn't that just atan?
05:46:20 <Botje> or atan2
05:46:57 <carpi> ah.. i think atan..
05:46:58 <worldsayhshi> Thanks for the help, things are a bit clearer. A new problem though. I've installed gtk+-devel with yum. But when running 'cabal install gtk' I now get "setup: The pkg-config package gtk+-2.0 is required but it could not be found."
05:47:47 <Botje> worldsayhshi: can you check in /usr/lib/pkgconfig ?
05:47:57 <Botje> there should be a file called gtk+-2.0.pc
05:48:04 <sshine> is there a way to avoid those PrintfArg a typeclasses? should I use some fromWhatever wrapping function everywhere?
05:48:06 <Botje> it's not impossible that you have gtk3 installed
05:48:30 <Botje> sshine: if you know the types up front you can specialize your function for those.
05:48:54 <worldsayhshi> 'rpm -qa | grep 'gtk+' gives me "gtk+-devel-1.2.10-71.fc15.i686
05:48:54 <worldsayhshi> gtk+-1.2.10-71.fc15.i686"
05:49:43 <worldsayhshi> Where should I find gtk+-2.0.pc?
05:50:04 <Botje> /usr/lib/pkgconfig
05:50:07 <luite> in /usr/lib/pkgconfig usually
05:50:10 <Botje> or possibly /usr/local/lib/pkgconfig
05:52:14 <luite> worldsayhshi: that sounds lke a gtk 1 devel pacakge, you need 2.0
05:53:12 <worldsayhshi> Yes, I have gtk+.pc but no gtk+-2.0.pc
05:53:50 <luite> doesn't fedora have a tool to search for the packages that provide that file?
05:55:01 <worldsayhshi> Not sure, I'm quite new to fedora.
05:56:00 <Clint> it's probably something like gtk2-devel
06:03:11 <worldsayhshi> gtk2-devel did the trick! :) Thanks for the help. My gtk-app is running.
06:14:40 <siracusa> What does this syntax mean in a guard: "| t<-a!c,c+d>1,t==b!d =..." ?
06:15:55 <mreh> holy moly
06:16:24 <mreh> is that from a compiling program?
06:16:37 <siracusa> @where e_10
06:16:38 <lambdabot> let(!)=div;f n=1:n:1:f(n+2);w@(x:y)%[a,b,c,d]|t<-a!c,c+d>1,t==b!d=t:w%[10*(a-c*t),10*(b-d*t),c,d]|0<1=y%[x*a+b,a,x*c+d,c]in(2:f 2)%[1,0,0,1]>>=show
06:16:50 <siracusa> ^ from this one
06:17:13 <mreh> is this your hobby? :)
06:17:13 <ion> > let f a | Just b <- a = b in f (Just 42)
06:17:15 <lambdabot>   42
06:17:26 <quicksilver> siracusa: which part of it exactly?
06:17:43 <srhb> Is it a question about pattern guards in general, or understanding that particular one?
06:17:43 <quicksilver> siracusa: multiple things separated by commands? or the <- part?
06:17:45 <siracusa> the <- and the comas
06:17:48 <siracusa> *commas
06:17:50 <mreh> i've never seen that syntax before, i should read the language guide more often
06:17:51 <ion> > let f a | Just b <- a, b > 42 = b; f _ = 0 in f (Just 42)
06:17:53 <lambdabot>   0
06:17:59 <quicksilver> it's not in the language guide, mreh
06:18:02 <ion> > let f a | Just b <- a, b > 42 = b; f _ = 0 in [f (Just 42), f (Just 43), f Nothing]
06:18:04 <quicksilver> it's an extension.
06:18:04 <lambdabot>   [0,43,0]
06:18:07 <quicksilver> <- is a pattern guard
06:18:14 <quicksilver> commans let you do multiple guards at once
06:18:21 <quicksilver> without pattern guards, commas would be just the same as &&
06:18:28 <quicksilver> with pattern guards, it's not the same.
06:19:00 <jessopher> I have a package with multiple executables, with the same 'Other-Modules:' specification. is there any way to keep cabal from recompiling the common modules (all of them in this case) for each executable build?
06:19:14 <siracusa> quicksilver: What is the extention for the commas called?
06:19:36 <siracusa> *extension
06:19:59 <mreh> jessopher: in my experience cabal only recompiles source files that have changed
06:20:02 <benmachine> you get summands in a sum, so a command is a piece of a com
06:20:19 <quicksilver> siracusa: it's part of PatternGuards as far as I know.
06:20:38 <siracusa> Ok, thanks
06:21:02 <mreh> cabal isn't recompiling, GHC is doing the compiling
06:21:03 <jessopher> mreh: well its recompiling for each executable, in the same cabal build
06:21:21 <jessopher> oh..
06:21:36 <mreh> if you use GHC, i assume you are
06:21:39 <jessopher> right
06:22:08 <mreh> not a GHC expert, but there will be a linking phase where GHC will have to link in the common modules for each executable
06:22:08 <Saizan> jessopher: you can make them a lib and depend on it in the build-depends of the execs
06:22:49 <jessopher> Saizan: within the same cabal file?
06:22:52 <Saizan> mreh: the sources for each exectuable get copied somewhere else before the build, that's why some modules get compiled more than once
06:22:56 <Saizan> jessopher: yes
06:23:01 <jessopher> alright, thanks
06:23:11 <mreh> jessopher: is it slow as ass or something?
06:23:16 <Saizan> jessopher: but make sure to use a different hs-source-dirs for the lib
06:23:38 <mreh> all hail Saizan
06:23:48 <jessopher> mreh: it will be if this project gets too much larger
06:24:06 <jessopher> Saizan: noted
06:24:23 <mreh> i've only known one package to be slow, and that's the crypto stuff
06:24:38 <mreh> clearly i've not done enough compiling
06:24:50 <Saizan> actually, it's not that the sources get copied, it's that the -outputdir= passed to ghc changes
06:25:47 <mreh> your beard is great Saizan
06:26:35 <srhb> I've been searching around for a decent comparison between Happstack, Yesod and Snap with regards to starting web development in Haskell, but all sources of comparison seem ridiculously dated. Does anyone have a link for a more recent comparison?
06:26:42 <jessopher> this will make my cabal file a lot more manageable to boot
06:27:04 <mreh> srhp: I tried that recently too, i just lumped for happstack because it seems the most mature
06:27:14 <mreh> tbh, i just went with my gut feeling
06:28:10 <srhb> mreh: To be honest, that was my gut feeling too. But I'm very new to this, it would be my first real Haskell project, so I thought maybe I was just being ignorant. :-)
06:28:27 <mreh> srhb: do you know Transformers?
06:28:52 <srhb> mreh: I do not.
06:29:35 <mreh> ah, well happstack relies on them heavily
06:29:42 <mreh> I can't comment on the other frameworks
06:29:53 <srhb> mreh: Thanks, that's one thing to look into at least.
06:30:01 <mreh> what's the project?
06:30:31 <srhb> mreh: For now it's a simple self-motivated one. I want to write a web app that allow users to create flash cards for various courses and subjects.
06:30:58 <srhb> It should be easy no matter which one I choose.
06:31:06 <srhb> I hope. :-)
06:31:26 <mreh> so you need some kind of persistant storage
06:31:48 <srhb> mreh: Indeed. I think Happstacks version of that sounds really interesting, but I have no idea if it can handle schema changes.
06:32:02 <mreh> srhb: safecopy :)
06:32:05 <srhb> mreh: Say, what happens if I change what "fields" a User has? Like, if I add a birth date or whatever.
06:32:40 <hpc> happstack uses acid-state right?
06:32:43 <mreh> you can either do them manually, or use safecopy to import the data at the time of use
06:32:49 <mreh> hpc: it can
06:33:15 <mreh> by *them* I mean data migration
06:33:30 <mreh> acid-state grew out of happstack
06:33:39 <hpc> srhb: acid-state will need some explicit conversion between the old user type and the new one
06:33:43 <mreh> it's in it's own package
06:33:47 <hpc> because strictly speaking, they are different types
06:34:10 <mreh> is there an acid-state that uses static schemas?
06:34:20 <srhb> hpc: Yes, I got that far as well, I just didn't find an example of how to actually do it. And as this would be a developing project (mostly for developing my skills) I wanted to be sure I could do it.
06:34:21 <hpc> dunno how yesod and snap do things, but a relational database will return stuff from the database as a (Map String SQLValue)
06:34:24 <hpc> which is more flexible
06:34:44 <srhb> But that seems to lose some type safety.
06:34:46 <mreh> acid-state allows you to use haskell datatypes, that sold me
06:34:49 <hpc> it loses lots
06:36:20 <mreh> you have to roll your own acid-state server if you want multiple processes to access the one db
06:36:48 <mreh> doesn't sound like you need that
06:38:00 <srhb> No, I don't think I will. At least not for this project. But I hadn't thought about that at all, so that's interesting information.
06:38:21 <mreh> srhb: there is source code for an image board written with happstack/acid-state/safe-copy
06:38:43 <srhb> Interesting, do you know where I can find that?
06:38:45 <mreh> https://github.com/paulmillr/happstack-imageboard
06:38:46 <mreh> there
06:38:56 <mreh> @where imageboard
06:38:56 <lambdabot> I know nothing about imageboard.
06:38:57 <srhb> mreh: Thank you. :)
06:39:06 <mreh> that got me started
06:41:32 <mreh> @where+ imageboard https://github.com/paulmillr/happstack-imageboard
06:41:34 <lambdabot> Good to know.
06:43:51 <srhb> It appears that Happstack can -also- use SQL databases if need be?
06:44:12 <mreh> i've never tried it
06:44:50 <mreh> type safety was too much of a benefit, and it didn't take long to learn IxSet
06:45:16 <mreh> Data.IxSet, check it out
06:45:32 <Saizan> nothing can stop you from querying a db :)
06:48:54 <EvanR-work> Saizan: not even the law?
06:49:34 <jessopher> unless its a physical law... i jaywalk every other day
06:49:40 * hackagebot Bitly 0.0.7 - A library to access bit.ly URL shortener.  http://hackage.haskell.org/package/Bitly-0.0.7 (SergeyAstanin)
06:50:40 <EvanR-work> laws of physics were made to be broken
06:51:18 <EvanR-work> well im glad bitcoin has finally stabilized
06:51:22 * EvanR-work waits for it
06:51:34 <EvanR-work> wrong channel!
06:54:57 <kniu> @hoogle (!)
06:54:58 <lambdabot> Prelude (!!) :: [a] -> Int -> a
06:54:59 <lambdabot> Data.List (!!) :: [a] -> Int -> a
06:54:59 <lambdabot> Data.IntMap (!) :: IntMap a -> Key -> a
06:55:05 <jessopher> i like to call them strong suggestions of physics
06:55:41 <EvanR-work> ! is array indexing
06:58:35 <turiya> hi..
06:59:17 <turiya> when i use cabal i get the following error "data is not in tar format".. i hae no clue what to do..
07:05:10 * hackagebot bitly-cli 0.1.1 - A command line tool to access bit.ly URL shortener.  http://hackage.haskell.org/package/bitly-cli-0.1.1 (SergeyAstanin)
07:10:04 <jessopher> turiya: how are you using it?
07:11:05 <patrek> how can I compose  a function to a partial application? ex: (+1).(-)
07:11:19 <patrek> it returns type error
07:11:57 <hpc> :t (+1) . (-)
07:11:58 <lambdabot> forall a. (Num a) => a -> a -> a
07:12:09 <siracusa> :t (+1) .: (-)
07:12:10 <lambdabot> forall a. (Num a) => a -> a -> a
07:12:22 <hpc> oh right, the funky Num instances
07:12:49 <jessopher> it may also not be a type error, and have something to do with how . is interpreted by ghc
07:12:50 <xivix> what's the difference there?
07:13:03 <jessopher> in the first case
07:13:46 <hpc> ghci> :t (+ 1) . (-)
07:13:46 <hpc> (+ 1) . (-) :: (Num (a -> a), Num a) => a -> a -> a
07:14:04 <jessopher> :t (+1).(-)
07:14:05 <lambdabot> forall a. (Num a) => a -> a -> a
07:14:13 <jessopher> hrmf
07:14:15 <hpc> ghci> let (.:) = (.) . (.)
07:14:15 <hpc> ghci> :t (+ 1) .: (-)
07:14:15 <hpc> (+ 1) .: (-) :: (Num a) => a -> a -> a
07:14:35 <hpc> lambdabot has a Num instance for Num a => (e -> a)
07:14:43 <hpc> and (.) = fmap
07:14:53 <hpc> which makes it tricky to figure out what's going on
07:14:54 <byorgey> patrek: (.) is only for composing functions of a single argument.  So  ((+1) . (-)) x y =  (+1) ((-) x) y = (((-) x) + 1) y   which is clearly not what you want
07:14:56 <sshine> if I want random numbers and not deal with an StdGen, must I manually wrap it in a monad or something?
07:15:07 <jessopher> lambdabot is intentionally trying to confuse us
07:15:18 <hpc> patrek: define (.:) = fmap fmap fmap, then use (+ 1) .: (-)
07:15:29 <byorgey> patrek: you can also just write  \x y -> (x - y) + 1
07:15:39 <sshine> ah, setStdGen and IO ().
07:16:05 <xivix> sshine: er, how do you propose you'll get random numbers without it?
07:16:06 <byorgey> sshine: there is also http://hackage.haskell.org/package/MonadRandom
07:16:13 <roconnor> @hoogle random
07:16:14 <lambdabot> System.Random class Random a
07:16:14 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
07:16:14 <lambdabot> package random
07:16:26 <roconnor> @hoogle RandomGen
07:16:27 <lambdabot> System.Random class RandomGen g
07:16:27 <lambdabot> package randomgen
07:17:04 <sshine> xivix, implicitly. thanks all.
07:17:09 <donri> anyone know if haskellwiki exposes a mediawiki api somewhere? api.php just redirects to a non-existing page (presumably a catch-all rewrite rule)
07:17:56 <roconnor> @hoogle mkStdGen
07:17:57 <lambdabot> System.Random mkStdGen :: Int -> StdGen
07:18:23 <roconnor> sshine: In principle you don't need to use IO or a monad at all, you can just use mkStdGen and random
07:18:43 <roconnor> sshine: using a monad simply helps you organize your code
07:19:10 <hpc> sshine: in practice, you need some way to pick a good initial seed, which is where IO comes in
07:19:19 <hpc> sshine: generally you take it from the current time
07:19:27 <hpc> or some function of it
07:20:02 <roconnor> well, if sshine is looking at setStdGen, then it would seem sshine has something else in mind when it comes to picking a seed
07:20:10 * hackagebot Bitly 0.0.8 - A library to access bit.ly URL shortener.  http://hackage.haskell.org/package/Bitly-0.0.8 (SergeyAstanin)
07:20:12 * hackagebot bitly-cli 0.1.2 - A command line tool to access bit.ly URL shortener.  http://hackage.haskell.org/package/bitly-cli-0.1.2 (SergeyAstanin)
07:22:46 <patrek> byorgey: I am trying to do  a small preprocessing that's why I need to be able to do something like:  #define  treeFunc (norm treeFunc)
07:23:18 <patrek> since I don't know arity of treeFunc I cannot use (.)
07:23:25 <patrek> or lambda
07:24:25 <byorgey> patrek: if you don't know the arity of treeFunc then you are pretty much out of luck
07:24:57 <patrek> isn't it that Int-> String-> Bool == a -> Bool ?
07:28:38 <byorgey> patrek: no, Int -> String -> Bool == Int -> (String -> Bool)
07:28:42 <jessopher> patrek: i dont think so, -> is right associative (Int -> (String -> (Bool)))
07:30:00 <patrek> aha
07:39:14 <turiya> jessopher: "cabal install gtk" fails with the error transformers-0.2.2.0 failed while unpacking the package. The exception was: user error (data is not in tar format)..
07:40:17 <byorgey> turiya: what OS are you using?
07:40:49 <turiya> byorgey: fedora 16
07:41:32 <byorgey> turiya: ok. are you able to successfully 'cabal install' other packages? or does everything fail with an error like that?
07:42:36 <turiya> byorgey: i can install other packages.. this particular package does not install
07:43:03 <byorgey> turiya: ok. look in ~/.cabal/packages/hackage.haskell.org/transformers/
07:43:25 <byorgey> check the permissions (is there anything owned by root?)
07:43:59 <byorgey> and also see if there is a file 0.2.2.0/transformers-0.2.2.0.tar.gz
07:44:16 <byorgey> check its permissions, try running the 'file' command on it to see if it really is a tar file, etc.
07:44:18 <turiya> the file you mentioned is present
07:45:27 <turiya> hmm..file says the .tar.gz file is ASCII text
07:45:56 <byorgey> turiya: aha =)
07:46:14 <byorgey> turiya: if you're curious you can look and see what's in it, it might give you a clue as to how it happened
07:46:34 <byorgey> but at any rate you should just delete it
07:46:47 <byorgey> so cabal will re-download it
07:47:02 <turiya> thanks! i think it is a html file..
07:47:43 <byorgey> yeah, I've seen that sort of thing happen if e.g. you try to run 'cabal install' when you've just connected to a network which redirects all traffic to a login/authorization page
07:48:21 <turiya> i think i saw redirects in that html..
07:48:21 <byorgey> it would be nice if cabal install tried to re-download cached .tar.gz files which are not in tar format
07:48:30 <byorgey> but for now at least, it doesn't
07:48:35 <turiya> ok..
07:49:15 <turiya> it is sometimes very frustrating to deal with errors like these when one does not know what is going on :(
07:49:29 <dcoutts> byorgey: it'd be nice if it checked the size of the file after downloading :-)
07:49:40 <turiya> thanks very much!
07:49:53 <turiya> it installed now :)
07:51:15 <byorgey> turiya: great!
07:51:53 <jessopher> i had to manually nslookup hackage earlier to get cabal to be aware of its dns resolution
07:52:14 * dcoutts notes that that is not cabal's fault
07:52:22 * jessopher figured as much
07:52:27 <dcoutts> that's the system dns resolver cache
07:52:59 <jessopher> its behind like 3 crappy routers that mangle dns between here and the internet, so im not surprised
07:53:56 <turiya> i am unable to set a specific attribute in gnuplot, does anyone have experience with gnuplot?
07:54:59 <zenzike> turiya: I've played a little with it
07:55:23 <zenzike> turiya: usually it's just a case of "set variable value;"
07:59:19 <jessopher> is there some loose criteria somewhere for what makes a package suitable for upload to Hackage? Other than a cabal file that parses
07:59:36 <dcoutts> jessopher: you think it might be useful
07:59:41 <dcoutts> ie reusable
07:59:56 <dcoutts> jessopher: there's no strict criteria
08:00:19 <mkscrg> i'm learning the enumerator package, and i often find myself looking for a way to turn a list into an enumerator. i can't find a provided function that does this. am i missing something?
08:01:24 <jessopher> dcoutts: Ok :)
08:01:39 <qgel_> In the book I'm reading it says that foldr works on infinite lists whereas foldl does not. Can someone explain this to me? Doesn't foldr have to go to the 'end' of the list first to begin folding?
08:02:20 <Cale> qgel_: let's look at the definition
08:02:23 <Cale> @src foldr
08:02:24 <lambdabot> foldr f z []     = z
08:02:24 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:02:26 <dcoutts> qgel_: exactly it doesn't, at least not necessarily. It depends on the strictness of the function you're folding.
08:02:27 <Cale> @src foldl
08:02:28 <lambdabot> foldl f z []     = z
08:02:28 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:02:48 <Cale> foldl in the recursive case does nothing but to pass control to itself with different parameters
08:03:12 <dcoutts> suppose  f _ _ = 3
08:03:18 <Cale> foldr on the other hand passes control to f immediately, and f gets to decide whether or not it needs to look at its second parameter
08:03:39 <Cale> and only if f examines its second parameter will it actually continue the computation of the foldr
08:04:38 <Cale> Lazy evaluation is outermost-first
08:04:55 <mkscrg> in other words, why doesn't enumerator expose an equivalent of the old enumList?
08:05:34 <qgel_> Ah, so f can 'break' in foldr and stop the computation but in foldl it cant because foldl is called recursively before f?
08:05:53 <Cale> qgel_: yeah
08:05:59 <qgel_> Thanks :)
08:06:16 <Cale> qgel_: In fact, foldl will do nothing but scan to the end of the list building up a giant expression in terms of f to be evaluated at the end
08:06:42 <Cale> qgel_: Sometimes that expression will be large and if f is strict, can create a stack overflow
08:07:14 <Cale> qgel_: So there's a stricter version of foldl calles foldl' which does some reduction of the accumulating parameter as it goes.
08:07:20 <Cale> called*
08:07:38 <turiya> zenzike: I wanted to change the font size of text in the legend, I tried with "add key ["font","\",20\""]" but i did not have any luck
08:10:13 <copumpkin> @ask kfish you mentioned that someday scope will support an html visualization. How will that work? would you write the entire thing in html5 with all the logic in javascript, or would you issue websocket-like requests to a server process that handles the seeking and data file interpretation?
08:10:14 <lambdabot> Consider it noted.
08:10:40 <qgel_> Cale: Thanks, but I don't have any idea what makes a function strict at the moment. I'll just continue reading, I'm sure it will come up eventually
08:10:47 <zenzike> turiya: I think you can do something in your "plot" command, like "plot foobar with lines title "{/Times=25 FOOBAR}""
08:11:39 <turiya> zenzike: is it in the gnuplot haskell library or in the gnuplot command line?
08:11:47 <zenzike> turiya: command line
08:12:37 <turiya> ok..i was able to set the font in the command line but it is tedious to copy data and form haskell and plot from command line..
08:13:45 <turiya> ... copy data from haskell and plot ... ^^^^
08:13:57 <zenzike> turiya: I'm afraid I've never used the haskell library :-(
08:14:41 <Cale> qgel_: case does, or pattern matching, which turns into case
08:15:08 <turiya> oh..i think using the command line might be the best option
08:15:11 <Cale> qgel_: A function f is called strict if f undefined is undefined.
08:15:36 <Cale> qgel_: and that will tend to happen when f pattern matches on its argument (though there are other ways it can happen)
08:15:54 <roconnor> turiya: is your plot 3-D?
08:16:02 <Cale> (1:) isn't strict because 1 : undefined isn't the same thing as undefined
08:16:09 <Cale> > head (1 : undefined)
08:16:11 <lambdabot>   1
08:16:21 <turiya> rconnor: it is just a plain 2d plot
08:16:47 <roconnor> turiya: you may wish to consider haskell-charts if you haven't already :)
08:17:13 <turiya> rconnor: i have been trying to install that right now.. :)
08:17:33 <turiya> roconnor: ^^
08:17:41 <roconnor> :)
08:30:04 <KirinDave> I have a haskell architecture question. Really this is a "How do you do this functionally" because I know how I _could_ do it in haskell.
08:30:20 <KirinDave> I have a number of connections to a resource, say sockets to a database.
08:31:27 <KirinDave> I have a number of them because I may want to do multiple things at once, so I have pooled them and I have a fairly standard doWithConnection :: pool -> (connection -> IO a) -> IO a sort of acesss
08:31:54 <KirinDave> But sometimes for whatever reason these connections become toxic. Maybe they time out
08:32:00 <KirinDave> Maybe the db has an error
08:32:11 <KirinDave> Whatever. The point is I learn, inside doWithConnection, that my connection is bad.
08:32:24 <KirinDave> Id like to remove that connection from the pool and do something sensible.
08:32:36 <KirinDave> In Scala, I'd use an exception and exception handlers inside doWithConnection
08:32:44 <KirinDave> In Haskell/functionally, what's the right approach?
08:33:08 <Cale> Um, well, you can use an exception. IO does have a pretty nice extensible exception system now.
08:33:19 <KirinDave> is that the preferred way now?
08:33:29 <geheimdienst> KirinDave: you learn that the connection is bad inside doWithConnection or inside the passed (connection -> IO a) action?
08:33:29 <hpc> KirinDave: look at the "with" functions in System.IO
08:33:32 <geheimdienst> (must be the latter)
08:33:40 <Cale> Well... for things involving IO, you're probably not going to get too much nicer
08:33:43 <KirinDave> geheimdienst: In the later.
08:33:53 <KirinDave> The problem with learning there though
08:34:03 <KirinDave> is that I will usually learn VIA my own exception. :)
08:34:06 <Cale> You could do a whole bunch of other things... like pass a failure continuation into your handler
08:35:52 <Cale> Or, in fact, have the failure continuation be part of the Connection that gets passed into the handler in the first place (and get set by withConnection)
08:36:16 <KirinDave> Hmm.
08:36:40 <Cale> withConnection :: Pool -> (Connection -> IO () -> IO a) -> IO a
08:37:23 <Cale> (that's a pretty simplistic type for such a thing, you could give it a parameter if you want the handler to provide feedback on what's wrong)
08:37:51 <mm_freak_> is there a serialization library based on blaze-builder?
08:37:58 <hpc> Cale: i would have it return an Either type, too
08:38:25 <Cale> So you'd call it like  withConnection pool $ \conn fail -> do ... some things ...; when (something) fail; ... return v
08:38:59 <KirinDave> Yeah
08:39:07 <Cale> But then if you'd built that failure continuation into the connection itself, you could say:
08:39:45 <Cale> withConnection pool $ \conn -> do ... some things ...; when (something) (redial conn); ... return v
08:40:01 <KirinDave> Cale: In that sort of model it'd almost make more sense to have it be like executeTransaction :: Pool -> Transaction a -> IO a
08:40:14 <KirinDave> Cale: Because then we could say retries are sensible.
08:40:18 <Cale> Indeed, that'd be a reasonable thing
08:40:33 <Cale> Then you start looking very much like STM
08:40:45 <KirinDave> Which you cannot fault on its pretty face. :)
08:40:48 <Cale> and you also can probably do 'orElse'
08:42:01 <Cale> and you also (presumably) get to elide the connection parameter to a lot of things inside your transactions
08:42:33 <KirinDave> I guess sort of the more subtle question is that these "with____" sorts of things are great
08:42:38 <Cale> at the cost of not having arbitrary IO and/or making it slightly more awkward to do IO
08:43:03 <KirinDave> but sometimes you need to carry state outside of the continuation you pass for error correction.
08:44:27 <Cale> My usual approach is to figure out the ideal code that I want to write, and then work out whether it's possible to make that happen (it typically is, more often than not... maybe I'm not being imaginative enough :)
08:45:19 <hpc> Cale: heh, same here
09:01:10 <Baughn> I'm allowed to say "foo { a = 42 }" to construct a record copy with top-level fields replaced..
09:01:33 <Baughn> Would "foo { a { b = 42 } }" be a reasonable syntax for doing the same at deeper levels?
09:02:11 <Baughn> Though ideally there'd be a way to refer to the previous value in there. Something like, say..
09:03:10 <Baughn> foo { a = a + 1 }, foo { a { b = b + 1 } }, or even foo { a { b = up.c + 1 }, c = 3 } (Which would not necessarily set b to 4)
09:03:29 <Baughn> Before I do a long write-up, does this look familiar to anyone?
09:03:44 <donri> you can certainly nest records Foo { bar = Bar { baz = 42 } }
09:04:18 <Baughn> donri: The idea here is that Bar would have more than one field
09:04:28 <Baughn> But you're just modifying one of them
09:04:52 <donri> you can't modify pure data structures
09:05:02 <Philonous> Baughn:  Don't lenses handle that more gracefully?
09:05:04 <Baughn> Oh, come on. You know what I mean.
09:05:10 <donri> nope, i don't
09:05:27 <Baughn> Philonous: Not really. Not when you're doing multiple modifications.
09:05:33 <Baughn> At least, I don't think so..
09:06:49 <shachaf> Hmm, you could probably write some operators for doing multiple modifications with lenses with a reasonable syntax.
09:06:53 <geheimdienst> Baughn: there's several packages that try to improve record-updating. see http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio
09:06:58 <carpi> are there some sort of coding guidelines for haskell?
09:07:17 <Baughn> geheimdienst: I'm aware of most of them. I'm trying to figure out an improved syntax, not just another library
09:07:35 <quicksilver> I think the libraries are a better notion than a new syntax
09:07:36 <Baughn> But you're right, whatever we come up with should include the abilities of lenses
09:07:45 <quicksilver> because the libraries being "just haskell" are first-class and composable
09:07:58 <quicksilver> new syntax would be, well, syntax, and fail at abstraction or composability
09:08:03 <quicksilver> which was the problem with record notation in the first place.
09:08:14 <ski> not the only problem
09:08:29 <geheimdienst> Baughn: you mean you want to do something like the libraries, but do it yourself with only prelude functions?
09:08:31 <Baughn> The libraries don't play that well with each other, though..
09:08:41 <Baughn> I'd like something that works everywhere
09:09:07 <Baughn> (And worse, lots of other packages don't define lenses at all!)
09:09:16 <ski> lenses are more expressive, and also harder to reason about
09:09:26 <Baughn> geheimdienst: I want something like the libraries, but defined as part of the haskell standard
09:09:38 <geheimdienst> ah, i see
09:09:51 <ski> (if you modify the `foo' part of a structure with a lens, does that implicitly also modify the `bar' part ? you don't know in general)
09:10:06 <Baughn> It's been long enough, that by now I'd settle for an inferior standard just to /have/ a standard
09:10:58 <Baughn> Structural modification has its advantages
09:11:00 <donri> carpi: nothing official that i know of, but there's e.g. http://snapframework.com/docs/style-guide
09:11:13 <Baughn> carpi: We'
09:11:18 <Baughn> carpi: We've got http://code.google.com/p/ganeti/wiki/HaskellStyleGuide
09:11:41 <Baughn> Though I'd take that one with a bunch of salt
09:11:46 <carpi> Thank you )
09:12:02 <jessopher> make a nice styleguide soup
09:12:38 <Baughn> Also https://github.com/tibbe/haskell-style-guide, which has an elisp module to enforce it
09:13:04 <ricree> Binaries built with the windows ghc running in wine would work ok for normal windows installs, right?
09:13:14 <carpi> i think even hlint does some style enforcing
09:14:01 <jessopher> ricree: don't see why not
09:15:30 <ricree> thanks.  I didn't either, but I figured it was worth asking before I got started
09:16:07 <hpaste> Carpi pasted “Difference?” at http://hpaste.org/55011
09:16:12 <carpi> Is there a difference? ^^^
09:16:15 <ski> Baughn : maybe something like `foo { a { b := _ -> c0 + 1 }, c := c0 -> 3 }', where `l := p -> e' can be abbreviated as `l = e' if `p' is `_' ?
09:16:40 <Eduard_Munteanu> carpi: sure
09:17:15 * mzero wonders why not      do  (iFile:oFile:_) <- getArgs
09:17:17 <Saizan> the latter is a parse error
09:17:28 <carpi> is oFile not part of the "do" in the first case?
09:17:39 <Eduard_Munteanu> carpi: not part of the 'let'
09:17:40 <mzero> no, oFile is not part of the let
09:17:47 <Baughn> ski: Sounds reasonable, but now I have to figure out how to make this coexist with lenses.
09:17:50 <mzero> in the second case
09:17:59 <Eduard_Munteanu> Erm, right.
09:18:19 <dmwit> Down with let!
09:18:24 <Baughn> ski: The lack of standardization for this is hurting pretty hard, I think. We should probably just figure something out, implement it, and present it as an optional extension, then see what happens.
09:18:29 <ski> Baughn : well, if you modify the `a' part and the `c' part of `foo', you know those parts are independent, so the order doesn't matter. not so with lenses
09:18:33 <dmwit> Each line should determine which thing it's doing based on whether there's an "=" or an "<-".
09:18:44 <Baughn> ski: Yeah, but lenses have advantages too. :P
09:18:54 <carpi> which means in the second case.. if i were to follow that let with an "in" then oFile would not be in scope?
09:19:18 <carpi> to be used after the "in" clause .. that is...
09:19:19 <dmwit> carpi: The second case is just an error. Doesn't matter whether there's an "in" or not.
09:19:24 <ski> Baughn : yes. maybe it would be possible to express this independence for lenses, when it does hold ..
09:19:35 <carpi> dmwit: but it seems to run fine
09:19:37 <dmwit> carpi: The oFile equation is in a different block than the iFile equation.
09:19:42 <carpi> giving the same input for both
09:19:57 <carpi> i mean .. giving the same output for both
09:19:58 <Saizan> if you add an "in" it should parse
09:20:08 <Saizan> it doesn't work without the 'in' though
09:20:20 <dmwit> carpi: That's not true. The second one doesn't compile. At least not here.
09:20:27 <Eduard_Munteanu> Or explicit braces '{' / '}'.
09:20:51 <Baughn> ski: With lenses being automatically defined by GHC, we'd be fine so long as GHC guarantees such. Not with user-defined ones, but those could be distinguished by not being capitalized.
09:20:53 <Eduard_Munteanu> Erm, I think...
09:21:03 <carpi> small correction. i tried again.. doesn't compile. Apologies
09:21:04 <Eduard_Munteanu> (not sure if you need an 'in' in that case)
09:22:04 <mzero> carpi - the extra indentation in the first case, causes the oFile line to be another clause in the let statement within the do
09:22:32 <Eduard_Munteanu> > do { let { a = 1; b = 2 }; return b }
09:22:34 <lambdabot>   No instance for (GHC.Show.Show (m a))
09:22:34 <lambdabot>    arising from a use of `M5154179684...
09:22:36 <mzero> in the second case the oFile line is a statement that isn't allowed directly in a do
09:22:39 <ski> Baughn : btw, one might want to update two records at the same time, using parts from one in the other and vice versa
09:22:56 <ski> > do { let { a = 1; b = 2 }; return b } :: Maybe Int
09:22:58 <lambdabot>   Just 2
09:23:48 <carpi> but
09:23:52 <Baughn> ski: Right, which brings up the question of whether to use the updated or original version
09:24:10 <carpi> no buts..i think i understand now. thanks
09:24:16 <Baughn> ski: I'm having a hard time deciding, which probably means it isn't too important. :P
09:24:18 <ski> well, i was pondering each would use the old version of the other
09:24:26 <Baughn> That's one option
09:24:47 <ski> well, it's really the sensible one, imo
09:24:50 <Baughn> Another is that both use the new version, as mentioned. This could potentially lead to LOOPs
09:25:05 <Baughn> And you can do it explicitly if you want to, so.. yeah, old it is.
09:25:07 <ski> consider `foo {...}' and `bar {...}' which we want to be able to refer to each other
09:25:22 <Baughn> Oh, in let..
09:25:31 <carpi> but i wonder.. if 'let' is an expression why is it not possible to bind values to names without using 'let'?
09:25:34 <Baughn> Right. You're perfectly correct, it'd be confusing to have it any different.
09:25:37 <ski> say `foo {x := x0 -> x1}' and `bar {x := x1 -> x0}'
09:26:00 <Baughn> carpi: I don't see how those have anything to do with one another
09:26:00 <carpi> because... if you want to use 'let' and 'in' in an expression you can't do so without using let twice
09:26:10 <jessopher> carpi: and it is possible to bind values to names without let
09:26:21 <carpi> example... "let m = let x = 3 in x+2"
09:26:21 <dmwit> ski: Oh, that's a good argument against my "down with let" thing earlier (though I know you didn't mean it that way).
09:26:33 <carpi> i can't write "m = let x = 3 in x + 2"
09:26:41 <carpi> because its a parse error
09:26:51 <Eduard_Munteanu> You could have a different syntax that didn't require 'let' I guess.
09:27:16 <ski> we *can* always do this by inventing `data FooBar = FB {foo :: Foo,bar :: Bar}' and then do `let FB {foo = newFoo,bar = newBar} = FB {foo = oldFoo,bar = oldBar} {foo {x := x0 -> x1},bar {x := x1 -> x0}} in ..newFoo..newBar..'
09:27:25 <ski> but this strikes me as a bit cumbersome
09:27:35 <carpi> jessopher: how? could you please tell me?
09:27:45 <jessopher> carpi: where clause
09:27:47 <Eduard_Munteanu> > let m = { let x = 3 in x + 2 } in m
09:27:48 <conal> any hxt users here? i'm starting to use hxt pickling, and i don't see picklers for basic types like Char & Bool. wondering whether i'm not looking in the right place or what.
09:27:48 <lambdabot>   <no location info>: parse error on input `{'
09:27:55 <carpi> Eduard_Munteanu: what do you mean by diferent syntax?
09:27:59 <carpi> ah.. where?
09:28:08 <jessopher> and any sort of non-let pattern matching
09:28:23 <ski> Baughn : so, it seems that we'd like to be able to have several record updates at the same time, that can refer to each other, without having to manually pack them into a single record and unpack afterwards
09:28:27 <Eduard_Munteanu> > let { m = let x = 3 in x + 2 } in m
09:28:28 <lambdabot>   5
09:28:31 <jessopher> where is not a question in haskell
09:28:50 <jessopher> > x where x = 1
09:28:51 <lambdabot>   <no location info>: parse error on input `where'
09:28:56 <jessopher> doh
09:29:00 <Baughn> ski: Which would be simple enough with the suggested syntax, right?
09:29:29 <ski> Baughn : as i see it, the basic problems with current record syntax is (a) hard to do nested updates; (b) hard to do simultaneous updates with cross-references
09:29:37 <Eduard_Munteanu> carpi: well do-syntax could probably a different syntax for binding names, without 'let'.
09:29:48 <ski> Baughn : i don't know, i haven't suggested any syntax for that use case, yet
09:29:58 <Eduard_Munteanu> *probably use
09:30:30 <ski> Baughn : there's also the "problem" of not being able to express general lenses, but i don't include this in the basic problems
09:30:41 <Eduard_Munteanu> Something like ski said above in a different context...  do { m := 5; xs <- getArgs; ... }
09:31:10 <Baughn> ski: https://docs.google.com/document/d/1gUpGWjXBHwImpasEX9DU2EMFlJ0fbjPvxBOvL1KadTE/edit?hl=no
09:31:11 <ski> Baughn : what you suggested first, and the modification i suggested, (a) would be solved, and part of (b)
09:31:23 <Baughn> ski: Let's keep track of this in there. :)
09:31:55 <Baughn> Not the best medium for coding, but meh..
09:32:20 * ski wonders if this thing is supposed to require JavaScript
09:32:28 <Baughn> It is
09:34:25 * ski doesn't get it to work, even in firefox ..
09:34:49 <ski> Eduard_Munteanu : well, the `:=' i used wasn't for binding, it was for *updating*
09:35:14 <Eduard_Munteanu> Yeah, sure, a different context.
09:35:44 <ski> Baughn : btw, there's also the possibility of considering light-weight record types (like FLEX in Hugs, e.g.)
09:35:57 <Baughn> ski: Not familiar with those
09:38:15 <ski> Baughn : imagine that if you wrote `foo p = sqrt (#x p ^ 2 + #y p ^ 2)', it'd infer `foo :: (Floating a,r \ x,r \ y) => Rec {x :: a,y :: a | r} -> a'
09:38:39 <ski> so, `foo' would automatically work on any record value having fields `x',`y' of type `a' in `Floating'
09:39:14 <Baughn> ski: Record field disambiguation, in other words?
09:39:33 <ski> Baughn : so in this scheme, instead of declaring specific record types, you already have an infinite number of them (compatible with each other), a bit like tuple types
09:39:50 <Baughn> I think we could do that more generally without rewriting it to type-classes
09:39:51 <ski> no disambiguation at all here
09:40:22 <ski> if your record has a field named `x' and a field named `y', of the correct types, you can pass the record to `foo', period
09:42:53 <Baughn> ski: Sounds.. orthogonal. Would be nice to have, and I'm not quite sure why we don't.
09:43:11 <Baughn> ski: Also, did you try it in Chromium?
09:43:38 <ski> Baughn : you could also do stuff like `bar p = p {y = #x ^ 2}', which would infer `bar :: (Num a,r \ x,r \ y) => Rec {x :: a | r} -> Rec {x :: a,y :: a | r}', so this would add a new field to a record
09:43:56 <ski> Baughn : for better info on this, see e.g. <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#trex>
09:44:28 * ski has no Chromium installed
09:44:43 <Baughn> It should work with firefox too, if you don't have noscript turned on or somethign..
09:44:47 <Baughn> Or an ancient version
09:44:55 <abs> what are the major obstacles to implementing record types and record subtyping? i recall simple typing rules in types and programming languages, and the example implementation there wasn't complicated.
09:45:19 <ski> (usually, w3m is good enough for me. i mostly use firefox as a fall-back to view pics or videos (not often))
09:45:44 <ski> Baughn : heh, 4.0.1 here
09:45:53 <lukish> I'm trying to solve http://blog.tmorris.net/20-intermediate-haskell-exercises/ and stuck on third one.
09:46:07 <lukish> ((->) t) - what does 't' means here?
09:46:13 <mauke> any type
09:46:17 <mauke> it's a type variable
09:46:18 <ski> `t' is presumably just a type variable
09:46:18 <Baughn> ski: Yeah, that's ancient.
09:46:44 * ski has 1.something on this other computer ..
09:46:54 <lukish> So, ((-> t) is a kind or what?
09:47:18 <ski> lukish : it's `(->) t', (or `(t ->)' if you prefer), and no, it's a type
09:48:04 <Eduard_Munteanu> (->) t  ::  * -> *
09:48:06 <ski> lukish : note that the type `Foo -> Bar' is really sugar for `(->) Foo Bar'
09:48:49 <ski> lukish : in case type operator sections were allowed, one could also write this as `(Foo ->) Bar'
09:49:20 <ski> lukish : so `(t ->)', i.e. the `(->) t' you see means "the type of functions from `t' to"
09:50:39 <ski> lukish : e.g. if `m' is `(->) t', then `banana :: (a -> m b) -> m a -> m b' becomes `banana :: (a -> (->) t b) -> (->) t a -> (->) t b' -- can you resugar that one ?
09:51:54 <hpc> if you really want to be annoying, banana :: (->) ((->) (((->) a (m b)) (m a)) (m b')
09:51:57 <hpc> i think
09:52:21 <ski> (well, the closing single quote shouldn't be in there)
09:52:43 <hpc> oh, right :P
09:53:24 <ski> and no, it's not right :)
09:53:59 <ski>   banana :: (->) ((->) a (m b)) ((->) (m a) (m b))
09:54:34 <lukish> I'm not understanding what is `resugaring` there for
09:54:48 <ski> well, you don't *need* to do it
09:54:58 <ski> but i meant rewriting from
09:55:01 <ski>   banana :: (a -> (->) t b) -> (->) t a -> (->) t b
09:55:03 <ski> to
09:55:21 <ski>   banana :: (a -> (t -> b)) -> (t -> a) -> (t -> b)
09:55:25 <ski> and maybe even to
09:55:31 <ski>   banana :: (a -> t -> b) -> (t -> a) -> t -> b
09:55:49 <ski> lukish : but maybe you prefer to read the first of those, i dunno
09:56:01 * jessopher wonders what this banana function's definition is
09:56:19 <ski> jessopher : the exercise is to write it
09:56:24 <lukish> Well, seems I've got it.
09:58:34 <lukish> banana :: (->) ((->) a (m b)) ((->) (m a) (m b)) looks like a mess at first, but is equal to (a -> t -> b) -> (t -> a) -> t -> b, right?
09:59:34 <lukish> But, is it quite uncurrieble because of (->) () () stuff?
09:59:41 <ski> lukish : if you set `m' to be equal to `(->) t', yes
09:59:56 <shachaf> lukish: The latter is a particular instantiation of the former.
09:59:58 <ski> (i'm not sure what you mean by "uncurrieble")
10:00:17 <shachaf> lukish: The "(->) (...) (...)" doesn't change anything about it. It's equivalent to the infix form.
10:00:29 <lukish> Okay.
10:00:38 <shachaf> What you wrote is equivalent to banana :: (a -> m b) -> m a -> m b
10:00:43 * ski idly wonders how long lukish has been learning Haskell
10:00:58 <mzero> :t (=<<)
10:01:00 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
10:01:04 <shachaf> Going by your choice of letter, you may have meant to put (Monad m) => in front. :-)
10:01:13 <ski> mzero : spoil-sport :)
10:01:18 <jessopher> yeah i think hoogle would solve this exercise
10:01:20 <mzero> d'oh
10:01:24 <shachaf> lukish: The short answer to your question is "no", by the way.
10:01:26 <mzero> sorry - that's what I get for just walking in
10:01:36 <ski> shachaf : no, this is a signature in a class, `Misty m'
10:01:48 <shachaf> Oh.
10:01:56 <shachaf> That's what I get for just walking in.
10:02:11 <shachaf> Sorry, lukish!
10:02:13 <mercury^> The end of Cont r a is a, right? It clearly has the correct mapping property, but why is it final?
10:02:17 <mzero> class Misty m where banana :: (a -> m b) -> m a -> m b
10:02:18 <mzero> ?
10:02:19 <ski> mzero,shachaf : <http://blog.tmorris.net/20-intermediate-haskell-exercises/>
10:02:24 <mzero> that's some choice of names!
10:02:36 <shachaf> ski: Yes, now I see.
10:02:43 <ski> you haven't seen the furry unicorn yet
10:03:14 <byorgey> mercury^: ?
10:03:33 <mzero> I see - interesting ideas
10:03:33 <mercury^> byorgey: ‘?’ to which part?
10:03:55 <mzero> is one not supposed to know what these are? or is it just renamed to make it fun / not collide when you load it into ghci?
10:04:17 <byorgey> mercury^: "The end of Cont r a is a, right? It clearly has the correct mapping property, but why is it final?" <-- I don't understand what you are asking.
10:04:25 <Eduard_Munteanu> I think mercury^ was asking a CT question, maybe?
10:04:44 <mercury^> First I am asking whether the end of Cont r a is really a, as I suspect. Then I am asing for a reason.
10:05:03 <byorgey> mzero: I think the idea is that without the common names you will just sit down and work everything out by looking at the types, without "intuition" or previous prejudices getting in the way
10:05:27 <mzero> ah - unless I'm distracted by furry unicorns....
10:05:44 <hpc> @unmtl Cont r a
10:05:44 <lambdabot> (a -> r) -> r
10:05:53 <shachaf> mzero: It seems to be in the "warm fuzzy thing" vein.
10:05:55 <lukish> `furry` in those exercies looks like a functor fmap, actually
10:06:01 <hpc> runCont :: Cont r a -> (a -> r) -> r
10:06:03 <byorgey> mercury^: oh, 'end' in the CT sense.
10:06:10 <Eduard_Munteanu> (But ends aren't really familiar to me.)
10:06:28 <mzero> shhhhhhh lukish, nobody here but us mono ids…..
10:06:42 <mzero> (damn spelling corrector….. monoids)
10:07:33 <lukish> Did `monoid`'s name came from mono and id?
10:08:17 <jessopher> i think it came from monad, and 'oid'
10:08:24 * Eduard_Munteanu suspects it's "oid" plus something.
10:08:36 <jessopher> 'something like a monad'
10:08:37 <Eduard_Munteanu> Hrm, monad ought to be a newer concept :/
10:08:44 <mercury^> jessopher: :D
10:09:10 <engla_> lukish: it's from abstract algebra but before that, ?
10:09:23 <Eduard_Munteanu> Also, categories used to be called monoidoids, so :/
10:09:33 <Eduard_Munteanu> (yeah, silly name :D)
10:09:44 <mercury^> Eduard_Munteanu: you might want to check your sources on that.
10:09:57 * jessopher contemplates monoidoidoids
10:10:29 <hpc> @quote semigroupoidoid
10:10:29 <Eduard_Munteanu> mercury^: oh? I remember stumbling upon "monoidoid"...
10:10:30 <lambdabot> No quotes match. :(
10:10:46 <mercury^> Eduard_Munteanu: that does not mean that categories were initially called that.
10:10:48 <mzero> no no - it comes from Latin for "mountain-like" mon(s)-oid   --- mons like Olympus Mons (http://en.wikipedia.org/wiki/Olympus_Mons)
10:11:28 <mzero> so named because the Romans believed that the Greeks believed that concept was handed down from Mt. Olympus
10:11:50 <Eduard_Munteanu> mercury^: but "monoidoid" used to be a name for categories, no?
10:12:07 <jessopher> and who of us can argue with either of them
10:12:09 <mercury^> I do not think that it was ever seriously used.
10:12:10 <Eduard_Munteanu> (or maybe still is, dunno)
10:12:19 <Eduard_Munteanu> Ah. :)
10:12:32 <Eduard_Munteanu> Still... it seems natural if you look at "groupoid".
10:12:36 <mzero> of course, the Greeks knew better, and called the concept miletian - after Thales of Miletus --
10:12:39 <Eduard_Munteanu> (a bit silly, though)
10:12:54 <mzero> … and if *you* beleive all this… I've got a bridge to sell you
10:13:10 <mercury^> Anyone writing it is making a fool out of himself in a non-funny way, so I think people are avoiding it.
10:13:48 <mercury^> The name ‘groupoid’ is bad enough.
10:13:55 <Eduard_Munteanu> Strangely, I've also seen groupoid used to describe a semigroup without associativity.
10:14:16 <mercury^> Is that not the way it was used in Haskell circles for a while?
10:14:43 <Eduard_Munteanu> Hm... dunno, last time I mentioned that use of "groupoid" everybody shrugged.
10:14:50 <abs> i thought monoid was derived from greek mon[o]-oid, as monoids satisfy one group axiom modulo associativity.
10:15:01 <Eduard_Munteanu> mercury^: maybe that was semigroupoid?
10:15:05 <mercury^> abs: huh?
10:15:32 <mercury^> Eduard_Munteanu: in any case, a semigroupoid should be a category without units.
10:15:34 <Eduard_Munteanu> edwardk has a package with that name. That is, categories minus identities.
10:15:41 <mercury^> Which is not what it was used for in Haskell.
10:15:43 <Eduard_Munteanu> Yeah.
10:15:46 <Eduard_Munteanu> Ah.
10:15:56 <mercury^> As far as I know, at least.
10:17:13 <mercury^> In mathematics that concept seems to be disregarded in favor of inverse semigroups and the étale groupoids you can construct out of them.
10:17:48 * ski . o O ( Moufang loops )
10:18:02 <rwbarton> sixth google result for "monoid etymology": http://wikidiff.com/monoid/shag
10:18:24 <Eduard_Munteanu> :))
10:19:05 <mercury^> That's great. :)
10:19:21 <danr> rwbarton: excellent
10:19:43 <jessopher> a fair comparison
10:19:55 <danr> oh, domino is an anagram to monoid. that's pretty nifty
10:19:57 <mercury^> rwbarton: do you know the answer to my earlier question about ends of Cont r a?
10:20:40 <rwbarton> mercury^: I didn't see it
10:20:53 <mercury^> The end of Cont r a is a, right? It clearly has the correct mapping property, but why is it final?
10:20:57 <mzero> as is "in doom"!
10:21:17 <danr> mzero: that's also great!
10:21:23 <mzero> "I'd moon domino monoid in doom"
10:21:37 <danr> a quasi-palindrome!
10:21:49 <Eduard_Munteanu> palindromoid :P
10:21:51 <mzero> a palindromoid
10:21:52 <mzero> heh
10:21:53 <Eduard_Munteanu> Heh.
10:22:00 <danr> Eduard_Munteanu: but of course!
10:24:40 <mzero> for the brave: release candidates of HP 2011.4.0.0 for Mac OS X  --  http://www.reddit.com/r/haskell/comments/n53ot/for_the_brave_release_candidates_of_hp_2011400/
10:25:39 <mercury^> I feel a bit bad for spamming this now, but since edwardk might have the answer: the end of Cont r a is a, right? It has the correct mapping property, bt why is it final?
10:26:10 <hpc> mercury^: what do you mean by "end"?
10:26:46 <Eduard_Munteanu> hpc: http://en.wikipedia.org/wiki/End_(category_theory)
10:27:29 <Eduard_Munteanu> (assuming that's accurate)
10:27:44 <edwardk> given indexed cont Cont i o a = Cont (a -> i) -> o  where the i represents the - and o is the positive argument to the end, then you get forall r. (a -> r) -> r  -- which is Yoneda Identity a ~ a. You need indexed Cont to take the end like that. otherwise its just a limit in Hask
10:27:45 <lambdabot> edwardk: You have 3 new messages. '/msg lambdabot @messages' to read them.
10:27:47 <mercury^> hpc: an object A together with maps m_r into Cont r a so that for p: s -> r, p_* m_s = p^* m_r.
10:28:13 <copumpkin> ⌠
10:28:14 <copumpkin> ⎮
10:28:16 <copumpkin> ⌡
10:28:30 <edwardk> copumpkin will be the end of us all
10:28:31 <Eduard_Munteanu> Neat, copumpkin
10:28:36 <srhb> copumpkin: Pretty!
10:28:44 <Nafai> copumpkin: Nice!
10:28:53 <edwardk> or at least will take the end
10:29:06 <srhb> Now we need a dictionary to do all sorts of funny multiline unicode math.
10:29:15 <srhb> TeX-> IRC Unicode? :>
10:29:24 <mercury^> edwardk: I did not understand that argument. Can you alaborate?
10:29:26 <mercury^> elaborate*
10:30:14 * hackagebot hmatrix 0.12.0.2 - Linear algebra and numerical computation  http://hackage.haskell.org/package/hmatrix-0.12.0.2 (AlbertoRuiz)
10:30:24 <edwardk> mercury^: ends need a functor C^op * C -> D
10:30:32 <mercury^> edwardk: yes.
10:30:41 <edwardk> Cont has the wrong signature. so you at least need to change to indexed cont to view it as an end
10:30:54 <edwardk> (a -> r) -> r  -- r occurs in both positive and negative position
10:30:55 <mercury^> Yes, that part was clear.
10:31:00 <edwardk> so split r into the positive and negative parts
10:31:04 <edwardk> ok
10:31:15 <mercury^> It was when you introduced the forall and said something about Yoneda that I got confused.
10:31:44 <rwbarton> this end is the same as Nat((->) a, Id)
10:31:48 <edwardk> then you can use the hackish construction for ends in haskell, which is that you can say newtype End f = End (forall a. f a a)
10:32:26 <edwardk> or rather forall r. f r r to avoid alpha renaming later
10:32:26 <mercury^> Hrm. I need to think about that. (Do I have a chance of figuring it out?)
10:32:32 <edwardk> probably
10:32:45 <edwardk> i mentioned it in my blog a long time ago
10:32:50 <edwardk> i think kan extensions iii
10:33:00 <edwardk> where i talk about kan extensions as ends and coends
10:33:15 <edwardk> dan piponi gave a slightly more principled version of a similar argument elsewhere
10:33:26 <mercury^> rwbarton: I did not understand your comment either, by the way.
10:33:31 <edwardk> when he described ends and coends on his blog
10:34:38 <edwardk> mercury^: did you ever read dan piponi's article on the yoneda lemma
10:34:39 <edwardk> ?
10:35:04 <mercury^> Anyway, suppose I believe you that the end is given by forall r. a -> r -> r, how does the Yoneda lemma come in?
10:35:09 <mercury^> Nope. :(
10:35:41 <mercury^> I guess all my questions have been answered in the literature and I am being silly? :/
10:36:17 <rwbarton> I think John Baez has also written about this computation, most likely
10:36:18 <edwardk> newtype Yoneda f a = Yoneda (forall r. (a -> r) -> f r) -- is sort of a manifestation of the natural transformation involved in the yoneda lemma
10:36:27 <srhb> Only in #haskell : Your questions are trivial because they have been explored in academia. O:-)
10:36:34 <edwardk> translated into Haskell, the yoneda lemma states Yoneda f a is isomorphic to f a
10:36:41 <edwardk> (given that f is a Functor)
10:36:58 <rwbarton> (also this is what I'd probably call the co-Yoneda lemma)
10:37:51 <edwardk> rwbarton: i'm on the fence in the phrasing, i just don't want to go change all my code ;)
10:38:01 <mercury^> covariant Yoneda lemma I think is a good choice
10:38:02 <edwardk> and this one is more useful than the other in haskell
10:38:11 <mercury^> The Yoneda lemma for Hask^{op} :)
10:38:14 <rwbarton> OK, just remarking that the terminology may be inconsistent/confusing.
10:38:18 <edwardk> *nods*
10:38:30 <mercury^> Can we just switch it around to make it standard?
10:38:57 <mercury^> newtype Yoneda f a = Yoneda ( forall r. (r -> a) -> f r)
10:38:58 <edwardk> mercury^: well you have a covariant and a contravariant version. so its co in the variance sense
10:39:11 <edwardk> mercury^: thats not the contra version
10:39:43 <edwardk> data ContravariantYoneda f a = forall r. Contra (f r) (r -> a)
10:40:10 <mercury^> edwardk: hmm, are you sure? It's f(a) = hom(hom(-,a),f) after all.
10:40:22 <mercury^> That seems to match the Haskell piece I wrote.
10:41:06 <rwbarton> mercury^: about my "Nat((->) a, Id)" comment... if we pretend we're working in Set or somewhere else that we are happy to talk informally about "elements" of objects, then an element of the end will be, firstly, an object of [indexed] Cont r r a for every r, i.e., a map f_r : (a -> r) -> r
10:41:25 <lukish> Well, how can I test my solutions to those 20 exercises?
10:41:38 <lukish> If it compile - it's enough?
10:41:43 <rwbarton> and then, it must satisfy a condition for every g : r -> s given by the functoriality of Cont in each argument
10:42:00 <Eduard_Munteanu> lukish: not if you used 'undefined' or other stuff
10:42:02 <mercury^> rwbarton: right.
10:42:14 <rwbarton> f_r is the "data" part of a natural transformation, and those extra conditions are that it really is in fact natural
10:42:21 <lukish> Eduard_Munteanu: I don't
10:42:23 <ski> lukish : i think the original, with all the `error "todo"'s in it also compiles fine
10:42:36 <Eduard_Munteanu> lukish: or non-terminating recursion
10:43:32 <rwbarton> The (contravariant) yoneda lemma is about hom(f,hom(-,a))
10:43:52 * Eduard_Munteanu thinks now would be a good time for somebody to spam^W er, mention Agda :P
10:44:04 <shachaf> lukish: As he mentions in the comments, there are some laws that your implementation needs to satisfy, but he neglects to mention them. :-)
10:44:37 <shachaf> lukish: I think the criterion is that there are no _|_s and no "unsatisfying" solutions like (const []). Or something along those lines.
10:45:27 <mercury^> rwbarton: f is not considered a functor C^{op} -> Set there, is it?
10:45:47 <mercury^> rwbarton: I think you consider it a functor C -> Set^{op}.
10:45:53 <mercury^> Which is even more non-standard.
10:46:32 <rwbarton> oh, oops, I meant hom(hom(-,a),f) like you said
10:48:22 <mercury^> (I would call that the Yoneda lemma, the statement of edwardk the Yoneda lemma for C^{op} and the co-Yoneda lemma is about representables being dense)
10:48:27 <Eduard_Munteanu> lukish: you might be able to use djinn to check some of those
10:48:56 <mercury^> Anyway, let's get back to the end.
10:49:03 <Eduard_Munteanu> @djinn a -> Not (Not a)
10:49:04 <lambdabot> f a b = b a
10:49:12 <lukish> I'm trying to write Fluffy instance to Either data. Why can I do that for Right and not for Left?
10:49:15 <lukish> instance Fluffy (Either t) where
10:49:16 <lukish> --    furry f (Left a)  = Left . f $ a furry f (Right a) = Right . f $ a
10:49:45 <Eduard_Munteanu> Seems reasonable.
10:50:02 <hpaste> dmalikov pasted “-” at http://hpaste.org/55013
10:50:05 <Eduard_Munteanu> What type does furry have?
10:50:22 <lukish>     furry :: (a -> b) -> f a -> f b
10:50:22 <mauke> lukish: because the types don't match
10:50:40 <hpc> @src Either fmap
10:50:41 <lambdabot> fmap _ (Left x) = Left x
10:50:41 <lambdabot> fmap f (Right y) = Right (f y)
10:50:47 <Eduard_Munteanu> I mean, where are those exercises, again?
10:50:58 <mzero> http://blog.tmorris.net/20-intermediate-haskell-exercises/
10:50:59 <mercury^> Shall we move the discussion about ends to ##categorytheory?
10:51:12 <doserj> lukish: Left uses the type t that is fixed in the "instance Fluffy (Either t)" declaration
10:52:27 <lukish> I thought that Left and Right are equal parts of Either.
10:52:29 <mzero> lukish: because the Fluffy takes a type constructor, so that the "contained type" can be transformed by furry --- in Either a b, the type constructor is (Either a), so the type a is fixed --- and type b, is the one that is transformed by furry --- hence, you can only right the transform on the Right side
10:52:46 <mzero> no, Left has type a, Right has type b    (in Either a b)
10:53:08 <Eduard_Munteanu> :t Right
10:53:09 <lambdabot> forall b a. b -> Either a b
10:53:42 <Eduard_Munteanu> (that's why Either takes two type parameters)
10:53:47 <lukish> So, what is `Either a` finally?
10:54:01 <Eduard_Munteanu> Either a :: * -> *
10:54:10 <lukish> It's something like a type function?
10:54:10 <Eduard_Munteanu> Like   Maybe :: * -> *
10:54:11 <roconnor> @kind Either a
10:54:13 <lambdabot> Not in scope: type variable `a'
10:54:15 <roconnor> @kind Either ?a
10:54:17 <lambdabot> parse error on input `?a'
10:54:19 <roconnor> aww
10:54:31 <Eduard_Munteanu> lukish: yeah
10:54:41 <Eduard_Munteanu> Either :: * -> * -> *
10:55:03 <Eduard_Munteanu> Partial application works there too.
10:56:01 <hpaste> keep_learning pasted “Compiler error” at http://hpaste.org/55014
10:56:11 <keep_learning> hello all
10:56:41 <keep_learning> Why compiling this code said there is no Main module http://hpaste.org/55014
10:56:51 <keep_learning> I am simply trying to compile this code
10:56:54 <keep_learning> for profiling
10:57:15 <monochrom> add -c ?
10:57:23 <rwbarton> does that Measuretime.hs contain a "main = ..."?
10:57:44 <donri> it probably contains something other than module Main where
10:57:46 <keep_learning> yes it contains main
10:58:20 <DanBurton> does it load into ghci?
10:58:26 <donri> keep_learning: I suggest you create a separate Main module and import Measuretime there
10:58:29 <rwbarton> then it needs to be the module Main or not have a module declaration at all or you need to use -main-is
10:58:31 <keep_learning> donri, it not module Main but module Snowfall.Spatial.Sim.Measuretime
10:58:51 <monochrom> yes, use -main-is
11:03:41 <keep_learning> rwbarton, compiling with  "ghc -isrc  -main-is -o Measuretime test/Snowfall/Spatial/Sim/Measuretime.hs"  says "<command line>:  Could not find module `Measuretime  Use -v to see a list of the files searched for."
11:04:24 <byorgey> keep_learning: -main-is needs an argument
11:05:17 <monochrom> -main-is Snowfall.Spatial.Sim.Measuretime
11:05:55 <monochrom> all I wished was you looked it up in the GHC user guide
11:06:05 <keep_learning> DanBurton ,yes it loading in ghci
11:06:21 <keep_learning> monochrom, yesterday i had bigger problem with this code
11:06:39 <monochrom> well, my sympathy
11:06:46 <keep_learning> then i searched quite a lot got this http://haskell.org/ghc/docs/6.10.2/html/users_guide/template-haskell.html
11:06:55 <keep_learning> monochrom, :) thank you
11:07:18 <rwbarton> are you using template haskell or ghc 6.10.2?
11:07:18 <keep_learning> but no today i solved one issue then other is coming
11:07:23 <monochrom> well yeah, searching in the template-haskell part isn't going to reveal -main-is
11:07:39 <keep_learning> i am trying to profile a code
11:07:50 <keep_learning> in which i got some error yesterday
11:08:27 <keep_learning> the last one http://hpaste.org/54965
11:09:52 <keep_learning> rwbarton, i am using ghc-7.0.3
11:10:06 <shachaf> keep_learning: You should do exactly what GHC is telling you to. :-)
11:10:51 <monochrom> template haskell changes with GHC versions. looking into 6.10.2 doc for 7.0.2 guidance is doomed
11:11:03 <monochrom> err s/7.0.2/7.0.3/
11:11:10 <keep_learning> shachaf, yes but yesterday i was not able decode it.
11:11:11 <roha> Question unrelated to haskell: What command do i have to insert in .vimrc if i want to seg "imap jj <Esc"?
11:11:25 <roha> set not seg
11:11:31 <keep_learning> shachaf, now i am doing the same thing. first trying to compile normal
11:11:37 <shachaf> roha: Exactly that command.
11:11:39 <keep_learning> then i am getting error
11:11:43 <hpaste> lukish pasted “ex 4 5” at http://hpaste.org/55015
11:11:44 <shachaf> roha: You should probably ask in #vim instead of here. :-)
11:11:46 <lukish> I think I solved exercises 4 and 5. Is is looks right?
11:12:50 <donri> roha: you should use inoremap, and i hear jl is better than jj
11:13:03 <donri> personally i have caps and escape swapped system-wide
11:13:18 <shachaf> lukish: Looks right (assuming it type-checks).
11:13:35 <roha> donri: hmm thanks ill try that as well!
11:13:41 <shachaf> I don't think there's a non-_|_ solution to that that would type-check (other than the right one).
11:14:12 <shachaf> lukish: By the way, in general, when you @paste, you should make sure to include type definitions and so on so that people can understand your @paste with minimal context. :-)
11:24:59 <keep_learning> Now  my executable is generating but when i am running with ./Measuretime +RTS -p , it say Measuretime: Most RTS options are disabled. Link with -rtsopts to enable them
11:25:29 <monochrom> yeah, add -rtsopts
11:29:09 <dgpratt> copumpkin: what font do you use for IRC?
11:30:45 <EvanR-work> comic sans
11:31:18 <dgpratt> EvanR-work: :-P
11:31:57 * ski doesn't use any font for IRC ..
11:32:16 <EvanR-work> ski uses a braile display
11:32:19 <srhb> ski: I suppose voice counts too.
11:32:27 <srhb> EvanR Braille is totally a font.
11:32:30 <monochrom> or direct usb connection to brain
11:32:31 <dgpratt> ski: eh? voice to text?
11:32:38 <dgpratt> err...
11:32:41 <monochrom> or direct wifi to brain
11:32:46 <dgpratt> text to voice?
11:33:14 <DanBurton> I guess you could display the braille dots on the screen, although that's not exactly what braille was intended for
11:33:45 <ski> i run it inside screen, so i get whatever font the terminal displays (so if i'm attached to screen in multiple terminals, i can view the same IRC in multiple fonts at the same time, should i so wish)
11:33:47 <dgpratt> I was inquiring about the font because many of you folks like to take full advantage of unicode
11:34:04 <dgpratt> ski: oh
11:34:05 <EvanR-work> yeah thats dumb, in the same category as -- --- .-. ... .   -.-. --- -.. .
11:34:10 <srhb> dgpratt: Monaco fixed-with makes me happy.
11:34:13 <EvanR-work> its not supposed to be printed out
11:34:15 <srhb> width*
11:34:35 <monochrom> I use ubuntu's default sans serif font
11:35:17 <monochrom> every "specific" "brand name" font misses something. ubuntu's default font unions them all.
11:35:32 <srhb> Mmm, font flame war, typographic dream.
11:35:33 <la55e> could anyone tell me what is wrong with this function: http://hpaste.org/55017
11:35:53 <dgpratt> ok, thanks for the suggestions
11:36:19 <monochrom> play 0 stayWin swapWin = return (stayWin, swapWin) ?
11:36:56 <la55e> monochrom: not working either
11:38:16 <la55e> ah, now i figured out it myself... i needed to add ::IO Int after both lines with randomRIO
11:38:56 <srhb> Huh, why is that necessary?
11:40:08 <monochrom> because randomIO is polymorphic in return type. think of maxBound
11:40:34 <byorgey> @type randomIO
11:40:35 <lambdabot> forall a. (Random a) => IO a
11:40:45 <byorgey> @type randomRIO
11:40:46 <lambdabot> forall a. (Random a) => (a, a) -> IO a
11:40:57 <byorgey> really the problem is that 0 and 2 are also polymorphic
11:40:59 <srhb> monochrom: But doesn't it become unambiguous in the if-then-else?
11:41:06 <srhb> Aaah, no, it's the equality.
11:41:23 <srhb> I get it now. :-)
11:41:55 <byorgey> modeling the Monty Hall problem, are wel? =)
11:42:05 <la55e> yep
11:42:20 <monochrom> day of problems-solve-themselves-if-unanswered
11:43:34 <srhb> So in what ways are 0 and 2 polymorphic?
11:43:57 <monochrom> 0 :: (Num a ) => a
11:47:20 <byorgey> > 0 :: Int
11:47:21 <lambdabot>   0
11:47:23 <byorgey> > 0 :: Integer
11:47:24 <lambdabot>   0
11:47:27 <byorgey> > 0 :: Double
11:47:29 <lambdabot>   0.0
11:47:30 <byorgey> etc.
11:47:58 <srhb> So an equal solution would have been to prepent :: Int to any of the arguments to RandomRIO?
11:48:02 <la55e> here is my complete solution to the Monthy Hall problem: http://hpaste.org/55021
11:48:04 <srhb> Sorry, any of the tuple values
11:48:09 <la55e> any suggestion on what i could do better?
11:48:14 <monochrom> yes
11:48:24 <srhb> Thanks, that clears it op. :)
11:55:32 <la55e> to me it looks like Monty Hall problem is a problem that is solved in less lines with imperative languages...
11:55:40 <ddarius> la55e: You don't need both of those ':: IO Int's and you have a slight performance problem.
11:56:37 <la55e> okay, at least one i need :)
11:57:31 <ddarius> la55e: There are probably better, more compact ways of writing that if you don't directly mimick an imperative solution.
11:58:09 <Cale> la55e: My first question is why are you using randomness when you should be using nondeterminism? :)
11:58:15 <la55e> ddarius: this was the first solution i could come up with myself... i have been to much in the imperative land :(
11:58:40 <Cale> la55e: There are probability monads which will solve the problem very nicely
11:58:45 <Cale> and give you exact results
11:59:29 <la55e> well, actually i could get an exact answer straigt with some simple math. this is just an experiment with using random
11:59:30 <roconnor> > mappend (Sum 1,Sum 0) (Sum 0,Sum 1)
11:59:32 <lambdabot>   (Sum {getSum = 1},Sum {getSum = 1})
11:59:36 <Cale> but, since I don't have one in lambdabot, I'll use  WriterT (Product Rational) [] :)
12:00:26 <roconnor> Cale: WriterT (Sum Integer, Sum Integer) ?
12:00:42 <Cale> roconnor: ?
12:01:01 <roconnor> keep track of counts of stayWin and swapWin
12:01:07 <Cale> Why would I want to play 10000 times when I can play once and compute the probability as I go?
12:01:12 <Cale> ;)
12:01:29 <roconnor> depends if you want a simulator or not
12:01:46 <la55e> Cale: i got the idea from this one... but decided to try without looking at that code: http://rosettacode.org/wiki/Monty_Hall_problem#Haskell
12:03:29 <roconnor> > mkStdGen 0
12:03:31 <lambdabot>   1 1
12:03:37 <ddarius> play n = (length***length) . partition (uncurry (==)) <$> replicateM n (liftM2 (,) (randomRIO (0,2) :: IO Int) (randomRIO (0,2)))
12:04:23 <salisbury> if one has multiple versions of the same function, each with different pattern matches
12:04:51 <salisbury> is there a way to apply a guard to all of them without having to place it on each
12:04:52 <ddarius> The clauses are parts of a function, not different versions.
12:05:03 <salisbury> clauses, yes sorry
12:05:39 <ddarius> salisbury: No, but you can push the pattern matching further in.
12:06:10 <salisbury> yes, I suppose I'll have to do that then
12:06:22 <salisbury> thanks
12:10:16 <Cale> > let collect = M.toList . M.fromListWith (+) . map (second getProduct); option xs = WriterT [(x,Product p) | (x,p) <- xs]; door = option [(0,1/3),(1,1/3),(2,1/3)] in collect . runWriterT $ do car <- door; choice <- door; if car == choice then return True else return False
12:10:18 <lambdabot>   [(False,0.6666666666666667),(True,0.3333333333333333)]
12:12:06 <ddarius> return (car == choice)
12:12:13 <Cale> indeed
12:12:23 <ddarius> In fact, liftM2 (==) door door
12:12:43 <ddarius> That might start to obscure things though ...
12:12:46 <shachaf> ddarius: The first transformation I would agree with completely; but the names "car" and "choice" might be useful.
12:13:32 <lukish> I'm stuck at exercise 6. All that I can figured out is that I need to do something like furry' f x = banana . unicorn . f $ x, but I dunno how can I get a from m a
12:13:32 <ddarius> Cale: Why not have lambdabot load some probability monad library?
12:13:33 <shachaf> liftM2 (\car choice -> car == choice) door door :-)
12:13:46 <lukish> Any hints?
12:14:23 <shachaf> lukish: People in this channel don't follow along with everything you do, so you should probably include the relevant types in your question, or at least a link to the exercises. :-)
12:14:29 <Cale> lukish: ;___; why did that thing have to use silly names for pre-existing concepts...
12:14:32 <Cale> lukish: Link?
12:14:36 <lukish> http://blog.tmorris.net/20-intermediate-haskell-exercises/
12:15:00 <shachaf> Cale: I think that was the point of it.
12:15:11 <shachaf> The "warm fuzzy thing" school of pedagogy.
12:15:27 <Cale> Well, implementing Functor and Monad for various things is a good exercise
12:15:40 <Cale> I don't see why replacing all the names of things is particularly helpful.
12:15:41 <lukish> Best I've ever sone :)
12:15:51 <lukish> done*
12:16:13 <Cale> I guess return is something people have preconceived notions about
12:16:20 <Cale> but fmap and (>>=) aren't...
12:16:30 <Cale> anyway
12:16:43 <Cale> you can't get a from m a
12:16:47 <Cale> in general
12:16:57 <shachaf> Cale: Consider that if the exercise using names like "Fluffy" and "banana" is easier for you than using "Functor" and "banana", that's probably because you have a good understanding of those concepts already.
12:17:08 * ddarius doesn't want to pay over $1,500 for a baritone acoustic guitar.
12:17:11 <shachaf> Cale: So reading the silly-name version helps you see what it's like for people who don't. :-)
12:17:32 <Cale> shachaf: But surely it's not any *harder* when it uses Functor as the name.
12:17:34 <dmwit> lukish: You don't get an a from an m a.
12:17:48 <Cale> Yeah, thankfully, that's not being asked for :)
12:18:03 <dmwit> lukish: You *can* get an m a from an m (m a) if you're clever about it.
12:18:03 <Cale> You want an f b, yeah?
12:18:34 <dmwit> lukish: But you shouldn't need that for this exercise.
12:18:37 <Cale> You have an a -> b and an m a, and you want an m b
12:18:49 <lukish> Cale: yes
12:18:53 <Cale> you also have b -> m b
12:18:55 <ddarius> Where "clever" = do the only path the types force upon you.
12:18:58 <Cale> which is unicorn
12:19:06 <Cale> (or return)
12:19:09 <dmwit> Yes, for small values of clever. =)
12:19:27 <Cale> and so by composing a -> b with b -> m b, you get an a -> m b
12:19:39 <Cale> and you have an (a -> m b) -> m a -> m b
12:19:41 <lukish> Aw
12:19:57 <lukish> So, it's f . unicorn.
12:20:10 <Cale> unicorn . f
12:20:23 <dmwit> gonna need a banana in there somewhere
12:20:28 <`Zerax`> Such nomenclature would make for a very amusing programming language.
12:20:33 <Cale> unicorn . f is just your a -> m b
12:21:31 <Cale> shachaf: Of course if you already do know what a functor is, you'll recognise it here instantly.
12:22:09 <lukish> banana (unicorn . f $ x) x is (a -> b) -> m a -> m b
12:22:10 <lukish> ?
12:22:15 <Cale> nope
12:22:26 <Cale> you have an extra $ x
12:22:54 <Cale> banana (unicorn . f) x
12:22:57 <shachaf> lukish: Why are you asking #haskell instead of ghci? :-)
12:22:59 <lukish> A, that's right
12:23:21 <ddarius> shachaf: Why is lukish asking Cale instead of lambdabot?
12:23:30 <lukish> shachaf: i've made my hour.
12:23:49 <lukish> ddarius: what should I asking it for?
12:23:58 <shachaf> ddarius: lambdabot doesn't let you define custom classes, and ostensibly lukish doesn't know about the "standard" names for these.
12:24:40 <lukish> shachaf: thanks.
12:24:50 <shachaf> lukish: ?
12:25:13 <`Zerax`> Of course, perhaps there is some shrewdness in Tony's renaming of things, makes it marginally more difficult to google the answers. Some attempt to engage the old white matter might be made ;)
12:25:28 <lukish> Cale: thanks for explanations.
12:32:07 <Younder> My teethe hurt like hell
12:32:45 <homie> go to a doc ?!
12:32:50 <Younder> I called my dentist yesterday
12:33:02 <homie> and ?
12:33:11 <Younder> Tomorrow
12:33:36 <homie> is it loose already ?
12:33:51 <homie> can you knock it off somehow ?
12:33:52 <Younder> so suffering the torments of hell today
12:34:32 <Younder> need to pull two molars
12:35:43 <monochrom> recursively
12:35:57 <gwern> @quote Aztec
12:35:58 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
12:36:06 <gwern> lambdabot: @join #lesswrong
12:39:40 <Younder> no chance on undernet
12:40:36 <Younder> I am dying here
12:44:48 <cari_veri_dt> hello there! my tried running a glade gtk2hs tutroail's example and it fails on runtime: "Expected <glade-interface> but got <interface>". My glade does only produce <interface> files, as it seems.
12:45:05 * JuanDaugherty advises against DIY dentistry.
12:45:16 <hpc> cari_veri_dt: update
12:45:25 <cari_veri_dt> hpc:  update what exactely?
12:45:34 <hpc> cari_veri_dt: or better, build the GUI programatically
12:45:39 <hpc> (update glade)
12:46:12 <cari_veri_dt> I apt.get installed galde jsut yesterday , how can it be not up to date :) ?
12:47:24 <hpc> hmm
12:47:39 <cari_veri_dt> I just looked it up, its glade versino 3.10.
12:47:53 <hpc> same version i have
12:47:55 <hpc> hmm
12:48:33 <hpc> im stumped
12:48:50 <hpc> could be an option in glade, but im on phone atm
12:52:34 <keep_learning> :t par
12:52:35 <lambdabot> forall a b. a -> b -> b
12:52:40 <keep_learning> :t pseq
12:52:41 <lambdabot> forall a b. a -> b -> b
12:52:50 <keep_learning> :t seq
12:52:51 <lambdabot> forall a t. a -> t -> t
13:04:32 <lukish> Solving exercise 7 http://blog.tmorris.net/20-intermediate-haskell-exercises/ . It's a bit strange that I need to write banana :: (a -> [b]) -> [a] -> [b].
13:04:33 <roconnor> > let play = do {correctChoice <- join (liftM2 (==)) (StateT (return . randomR (0,2))); tell (if correctChoice then (Sum 1, Sum 0) else (Sum 0, Sum 1))} in execWriter (evalStateT (replicateM 10000 play) (mkStdGen 20111208))
13:04:36 <lambdabot>   (Sum {getSum = 3349},Sum {getSum = 6651})
13:04:41 <roconnor> am I too late?
13:05:15 <lukish> Is it right, that I'm need to doing something like concate . map ?
13:05:19 <Cale> roconnor: hehe
13:05:22 <lukish> or concatMap
13:05:30 <mzero> lukish: yes, yes it is
13:05:37 * roconnor got distracted by actual work
13:05:38 <mzero> did you determine that from the types ?
13:06:09 <lukish> Well, I dunno what else should match that signature
13:06:13 <Cale> Why is it strange?
13:06:16 <Cale> That is correct
13:06:29 <lukish> Actually, I can get first list form lists of resultin lists
13:06:44 <Cale> lukish: hint: standard list functions
13:06:45 <cari_veri_dt> thanks hpc. it runs when not using the xml. maybe I should relly learn to do it that way, but I m beginner and started out from glade interface designer.
13:06:55 <lukish> And that function also will have that type
13:08:01 <lukish> Cale: concatMap is standard, isn't it?
13:08:12 <Cale> yep
13:08:41 * roconnor is way to comfortable with join as a W combinator
13:09:12 <Cale> It is a side effect *cough* of hanging out in #haskell
13:09:16 <ddarius> Computational combinatory logic ho.
13:10:55 <roconnor> I *could* write randomR twice, ... or I could just use join and write it once ...
13:13:14 <mateu> I'm just getting my feet wet w/ haskell and I'm wondering how I might define a positive Int type?
13:14:21 <cgroza> Why there are no default argument in haskell? I know they exist in Ocaml...
13:14:48 <roconnor> The most basic basic way of defining a type of natural numbers is data Nat = Zero | Succ Nat
13:15:04 <copumpkin> Zero | Succ !Nat ?
13:15:06 <jessopher> cgroza: default argument?
13:15:36 <ddarius> :k Mu Maybe
13:15:37 <lambdabot> *
13:15:40 <cgroza> jessopher: something like def fun(arg1, arg2 = True, arg3 = 4)
13:15:58 <jessopher> cgroza: that doesnt make much sense with pure functions
13:15:59 <ddarius> cgroza: Put some thought into it, and I'm sure you will discover the reason.
13:16:47 <Axman6> hint: currying
13:16:54 <cgroza> ddarius: because of partial application?
13:19:58 <keep_learning> @hoogle parallel
13:19:59 <lambdabot> Control.Parallel module Control.Parallel
13:19:59 <lambdabot> package parallel
13:19:59 <lambdabot> package parallel-io
13:27:41 <cari_veri_dt> Hey guys, how to run other programs (e.g. a terminal) inside my program's window?
13:30:55 <jessopher> cari_veri_dt: System.Cmd and System.Process ... though i think later than the former
13:31:20 <jessopher> more the latter^
13:31:31 <AfC> cari_veri_dt: (or do you mean you really want a nice 80x25 terminal embedded in a larger GUI program?)
13:31:40 <jessopher> hehe
13:31:50 <cari_veri_dt> AfC: yes embedded :)
13:31:53 <hpaste> “your mother” pasted “bogus code” at http://hpaste.org/55025
13:32:00 <deggis> cgroza: you can explicitly pass your arguments in Maybe and use some default if arg was Nothing. i guess that's the closest you get
13:32:25 <jessopher> there are even predefined functions that make it easy
13:32:32 <Axman6> that would work quite well with view patterns actually
13:33:06 <Axman6> foo (fromMaybe default -> x) (fromMaybe default2 -> y) = ...
13:33:19 <Axman6> :t fromMaybe
13:33:21 <lambdabot> forall a. a -> Maybe a -> a
13:33:41 <jessopher> do we have a view pattern extension?
13:33:47 <Axman6> yes
13:33:47 <deggis> Axman6: oh, true!
13:34:19 <Axman6> I'm pretty sure the extension is ViewPatterns :P
13:34:37 <deggis> i think it's viewpatterns too
13:34:37 <jessopher> well i would expect it to be if it exists
13:34:46 <AfC> cari_veri_dt: assuming you're using gtk2hs to get to the GNOME libraries, the embedded terminal widget is "vte" i.e. http://developer.gnome.org/vte/0.30/VteTerminal.html and Debian packages  libvte* looks like Haskell has it at Graphics.UI.Gtk.Vte.Vte
13:35:42 <cari_veri_dt> Afc ok let me have a look..
13:39:24 <carpi> how do you write a function that splits a list into elements that return True for a given function and elements that return False for the same function ?
13:39:27 <Axman6> ha, made it into the haskell weekly news
13:39:35 <Axman6> carpi: partition
13:39:42 <Axman6> > partition even [1..10]
13:39:43 <lambdabot>   ([2,4,6,8,10],[1,3,5,7,9])
13:39:46 <carpi> without using any built ins
13:39:56 <Axman6> homework?
13:40:10 <jessopher> wow, even implicit maybe...
13:40:15 <Axman6> (not that that means I won't help you, I just won't give you the answer)
13:40:50 <carpi> nope.. the thing is .. i already wrote the code..
13:40:53 <hpaste> Carpi pasted “splitWith” at http://hpaste.org/55026
13:40:58 <carpi> there ^^^
13:41:02 <carpi> and it works
13:41:04 <carpi> but..
13:41:12 <carpi> it looks unwieldy and unaesthetic
13:41:38 <carpi> i can't seem to find a way to write it more simpler
13:42:17 <Axman6> I think the actual source looks something like this: partition _ [] = ([],[]); partition f (x:xs) = let ~(ts,fs) = partition f xs in if f x then (x:ts,fs) else (ts,x:fs)
13:43:20 <carpi> i thought so.. too much boiler plate in yoru code
13:43:38 <Axman6> hmm?
13:43:41 <Axman6> @src partition
13:43:42 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
13:43:42 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
13:43:42 <lambdabot>                               | otherwise = (ts, x:fs)
13:43:54 <carpi> ah shite.. i mean..
13:43:57 <carpi> /s/your/my
13:44:03 <Axman6> heh
13:44:14 <Axman6> yours also returns the results in reversed order right?
13:45:04 <carpi> ah yes.. i think so.. but let me check.. im glad you reminded.. never checked that.. been testing it with lists of only 2 unique elements so far ol
13:45:09 <letrec> Got the following error: Couldn't match expected type `B.ByteString' with actual type `Data.ByteString.Lazy.Internal.ByteString'. B is Data.ByteString.UTF8. Can someone confirm that it is not the same type?
13:45:21 * hackagebot blaze-builder 0.3.0.2 - Efficient buffered output.  http://hackage.haskell.org/package/blaze-builder-0.3.0.2 (SimonMeier)
13:45:46 <mauke> letrec: apparently it's a strict bytestring
13:45:48 <carpi> haha.. you right. its reversed.. shucks
13:45:51 <Axman6> letrec: they're not. you need the lazy version
13:46:54 <salisbury> anyone have an idea as to why hSeek would 'block indefinitely in an MVar operation'?
13:47:06 <letrec> mauke: Axman6: I see, thanks. How can I convert a lazy bytestring to a strict one?
13:47:18 <Axman6> i believe handles are protected by an MVar salisbury
13:47:32 <salisbury> hmm..
13:47:40 <Axman6> letrec: first you need to figure out if you need to do that...
13:48:22 <mauke> concat . toChunks
13:49:41 <cari_veri_dt> Afc is this the related package ? libghc-vte-dev ?
13:50:27 <letrec> Axman6: I basically want to use pattern matching.. And it requires strict bytestring as far as I know
13:50:52 <Axman6> you can't pattern match on bytestrings
13:50:52 <AfC> cari_veri_dt: looks that way.
13:51:08 <Axman6> since you have no access to the contructors
13:54:27 <hpaste> DukeDave pasted “Using a shared library for the C++ in wxhaskell” at http://hpaste.org/55027
13:56:07 <DukeDave> So, I wrote a story, and I wondered if anyone would like to help me give it an even happier ending? ^
13:56:11 <salisbury> Axman6: by protected, you mean an MVar is used to prevent multiple threads using the handle, correct?
13:56:30 <DukeDave> And as bonus points, you'll be doing open source and people will love you..
13:56:40 <Axman6> yeah, something like that. i've never looked into the details
13:57:41 <salisbury> Axman6: ah, I think it may be that a call to hPutBuf for 4 bytes is not putting all 4
13:58:05 <salisbury> Will try specifying Int32..
14:03:37 <deggis> one version (no idea of performance) of partition, partition p = foldl mappend mempty . map (\x->if p x then ([x],[]) else ([],[x]))
14:04:46 <deggis> i'm pretty sure there's some extra weight still
14:05:26 <cari_veri_dt> Afc yea loks good. jsut need to figure out how to use it. it opens a window as expected , but no IO so far.
14:06:38 <deggis> i'm sure there's a thingie that does that map (...) thing there
14:08:16 <deggis> uh, and while browsing Data.List there's a partition already defined, too
14:08:51 <letrec> Axman6: I'm talking about matching using Text.Regex.PCRE.Light.. Basically I read a file as lazy Text and I want to convert it into ByteString to do the matching. Does it makes sense?
14:11:06 <byorgey> deggis: note that doing  foldl (++) is a bad idea, since left-nested list concatenation takes O(n^2) time to evaluate
14:11:30 <byorgey> because it has to repeatedly re-traverse the leftmost part of the list which is already been constructed
14:12:16 <byorgey> just switching to foldr would be a big speedup
14:12:23 <byorgey> also, foldr mappend mempty = mconcat
14:13:32 <byorgey> for the map (...) thingy, given  ensure p x = guard (p x) >> return x, you could write  map (\x -> (ensure p x, ensure (not . p) x))
14:13:59 <jessopher> what formatting is used for package descriptions on Hackage?
14:14:00 <byorgey> which could be simplified to map (ensure p &&& ensure (not . p))
14:15:05 <byorgey> jessopher: it's a format specific to Haddock
14:15:10 <byorgey> jessopher: http://www.haskell.org/haddock/doc/html/markup.html
14:15:30 <Jafet> "ensure p &&& ensure (not . p) looks so misleading.
14:15:38 <byorgey> haha, so it does =)
14:15:39 <Jafet> s/)/)"/
14:15:44 <jessopher> ah ok, thanks byorgey
14:16:24 <monochrom> to P and not to P, that's the answer
14:16:35 <donri> byorgey: you sure haddock style is used even in the cabal description/summary?
14:16:41 <donri> i think that's what jessopher meant
14:17:13 <jessopher> it is
14:17:30 <jessopher> (what i meant) and i dont think its haddock
14:17:58 <deggis> byorgey: thanks! indeed
14:18:15 <jessopher> im seeing '.'s for paragraph separators, and // for italics
14:18:15 <byorgey> donri, jessopher: ah, sorry, you may be right
14:19:03 <byorgey>  // for italics is the same as Haddock
14:19:18 <byorgey> . is just to indicate a blank line, to help out the cabal parser
14:19:32 <salisbury> Axman6: this is crazy.. remember that MVar issue, I just accidentally resolved it by placing a putStrLn $ show filePos
14:19:55 <salisbury> where filePos is the result of a previous hTell
14:20:34 * jessopher gives it a go with the checker
14:20:44 <salisbury> would hTell be affected by laziness?
14:22:19 <Axman6> lazy IO could be the cause, yes
14:22:19 <byorgey> jessopher: turns out it is indeed Haddock.  see http://www.haskell.org/cabal/users-guide/#package-descriptions, search for "description"
14:22:30 <byorgey> jessopher: the 'synopsis', however, does not allow any markup
14:23:35 <jessopher> alright
14:30:54 <cari_veri_dt> AfC: hey . I found a method: terminalFeedChild but I dont know how to get stdin to it. Can help me? it should be easy. I thought, I have to pass "stdin" as argument.
14:32:29 <donri> cari_veri_dt: type?
14:34:20 <cari_veri_dt> donri : stdin is of type IO , not? and I think terminalFeedChild (from Graphics.UI.Gtk.Vte.Vte ) expects right that.
14:35:13 <Axman6> stdin has type Handle in Haskell :\
14:36:17 <cari_veri_dt> Axman6: so what do I do to get the keyboards input?
14:36:32 <donri> do you have a TerminalClass?
14:36:38 <Axman6> @hoogle IO String
14:36:39 <lambdabot> Did you mean: :: IO String
14:36:39 <lambdabot> System.IO.Error ioeGetErrorString :: IOError -> String
14:36:39 <lambdabot> System.IO.Error ioeSetErrorString :: IOError -> String -> IOError
14:36:59 <Axman6> @hoogle :: IO String
14:37:00 <lambdabot> Prelude getContents :: IO String
14:37:00 <lambdabot> System.IO getContents :: IO String
14:37:01 <lambdabot> Prelude getLine :: IO String
14:38:58 <cari_veri_dt> terminalFeedSource :: TerminalClass self     => self     -> String    string - a string in the terminal's current encoding  -> IO ()
14:39:47 <donri> something like terminalFeedSource Terminal "bla"
14:42:22 <AfC> cari_veri_dt: sorry, haven't used VTE in about 7 years, and not from Haskell
14:43:14 <AfC> cari_veri_dt: (it would be help if they had some documentation, wouldn't it)
14:44:05 <cari_veri_dt> donri I have tried terminalFeedChild myterminal getLine , but ghc says [char] and IO string is not the same.
14:44:17 <Axman6> they're not
14:44:59 <donri> cari_veri_dt: terminalFeedChild myterminal =<< getLine
14:45:02 <Axman6> cari_veri_dt: have you ever used IO in haskell before?
14:45:40 <cari_veri_dt> Axman6:  never before.
14:45:51 <Axman6> then you should start with learning the basics
14:45:57 <donri> @where LYAH
14:45:58 <lambdabot> http://www.learnyouahaskell.com/
14:46:07 <donri> is a good place to start before you jump onto FFI stuff
14:46:29 <dgpratt> I'm going through the example lukish posted earlier: http://blog.tmorris.net/20-intermediate-haskell-exercises/
14:46:42 <Axman6> dgpratt: those are fantastic
14:46:48 <dgpratt> finding myself stuck on moppy
14:47:04 <Axman6> really helped me understand the implementation of many monads
14:47:44 <dgpratt> Axman6: yeah, I'm quite liking it for similar reasons
14:48:15 <Axman6> dgpratt: yeah that one is a big difficult. I'll give you a hint: moppy [] _ = return []
14:48:29 <dgpratt> Axman6: ok, thanks :)
14:48:44 <Axman6> and now would be a good time for you to start thinking aloud about what this function actually needs to do
14:49:12 <cari_veri_dt> donri: Axman6 AfC, thank you guys very much. it almost works .but the rest I get running on my own. have a good day/night
14:49:28 <Axman6> cari_veri_dt: good luck
14:49:31 <zhulikas> how can I define (++) for my custom type?
14:49:39 <dgpratt> before you said anything, my first thought was to fmap the second param over the first
14:50:00 <zhulikas> should I put it somewhere in the instance for monoid/monad, or just write it inside a module ?
14:50:02 <dgpratt> which leaves me with needing [m b] -> m [b]
14:50:04 <Axman6> zhulikas: you can't use the name (++) without hiding it when importing the Prelude
14:50:12 <zhulikas> oh, ok
14:50:18 <zhulikas> so (++) is strictly for [a]
14:50:27 <zhulikas> (++) is also mappend, right?
14:50:40 <Axman6> zhulikas: it doesn't have to be, but probably should be. try implementing the Monoid class
14:50:42 <dgpratt> besides stealing the definition of sequence, not sure how to get there
14:50:49 <zhulikas> I implemented monoid
14:51:05 <Axman6> gusto: yeah, that's a good place to start. it's actually how that function is implemented in Control.Monad
14:51:08 <zhulikas> It's just I am so used to ++ and + that I wish to have something like that to my own type
14:51:12 <shachaf> zhulikas: It is never the case that (++) is strictly for [a] *and* (++) is also mappend.
14:51:15 <shachaf> It's one or the other.
14:51:26 <Axman6> dgpratt: well, let's thing about this. you now have a [m b] right?
14:51:27 <donri> zhulikas: it's more that (++) is the mappend for [a]
14:51:38 <dgpratt> Axman6: right
14:51:40 <shachaf> Also, (+) is very different from (++). (+) is usually commutative. :-)
14:51:47 <zhulikas> well yes...
14:51:55 <zhulikas> I just wonder what would be the most natural way to replace mappend
14:52:15 <zhulikas> let's say for a type Sum a (which is ZSum a in my module)
14:52:22 <zhulikas> and acts the same as Sum a
14:52:23 <donri> you could argue that mappend should have been called (++) just like fmap might should be map etc, yes
14:52:28 <dgpratt> Axman6: seems that I should be able to fold it somehow, but the step function...it seems a bit hairy
14:52:30 <Axman6> dgpratt: ok, so, we probably want to write a function with type foo :: [m b] -> m [b] right? (which you've already identified is sequence)
14:52:43 <dgpratt> Axman6: right
14:52:49 <Axman6> dgpratt: It's much clearer if you write the recursion explicitly
14:53:04 <dgpratt> Axman6: ok
14:53:11 <Axman6> ok, so again, start with the base case: foo [] = ...?
14:53:32 <zhulikas> ok then, I can just define (:-)
14:53:49 <Axman6> zhulikas: only constructors can start with :
14:53:56 <zhulikas> damn it
14:53:57 <Axman6> but -: would be ok
14:54:00 <zhulikas> ah, ok
14:54:10 <Axman6> i think
14:54:23 <Axman6> :let (-:) = (+) in 1 -: 3
14:54:27 <Axman6> > let (-:) = (+) in 1 -: 3
14:54:28 <lambdabot>   4
14:54:29 <dgpratt> Axman6: guess: foo [] = unicorn []?
14:54:46 <Axman6> looks pretty good to me
14:54:52 <dgpratt> Axman6: ok
14:55:06 <Axman6> ok, now we have: foo (mb:mbs) = ...
14:55:25 <Axman6> take it in steps. first you probably want to 'get the b out of the mb' right?
14:56:31 <Axman6> (hint, you probably want to use another Misty function)
14:56:34 <dgpratt> Axman6: sure :)
14:57:01 <Axman6> so, get it to the point where you're starting to write a lambda that's taking the b from the mb
14:57:47 <dgpratt> Axman6: that'd be jellybean, I think
14:57:50 <Axman6> foo (mb:mbs) = ...? (\b -> ...) (ignore the second ... for now)
14:58:13 <dgpratt> Axman6: ah, not not quite
14:58:26 <chrisdone> alright chaps, check this sexy emacs hackery http://www.youtube.com/watch?v=6ofEZQ7XoEA
14:58:48 <donri> oh look everyone it's chrisdone
14:59:03 * chrisdone pouts
14:59:22 <Axman6> EVERYONE POINT AND LAUGH!
14:59:33 <donri> ok that is kinda sexy
14:59:36 <chrisdone> ;_;
14:59:39 <donri> i tend to use groom and hscolour
15:00:13 <chrisdone> what's groom?
15:00:20 <donri> data pretty printer
15:00:22 <byorgey> @package groom
15:00:23 <lambdabot> http://hackage.haskell.org/package/groom
15:00:52 <Axman6> damn, that's really cool
15:00:52 <chrisdone> ah ok
15:01:10 <byorgey> chrisdone: sexy!
15:01:12 <chrisdone> :D
15:01:53 <chrisdone> gonna pop it in a module and add it to the haskell-emacs repl, you haskell-mode guys can add it to inf-haskell too :)
15:02:28 * byorgey keeps meaning to try out chrisdone's emacs mode but at this point is probably going to wait for the point when chrisdone shouts "IT'S READY NOW COME AND GET IT"
15:02:39 <chrisdone> haha :D
15:02:53 * donri waits for chrisdone to port it to vim
15:02:53 <chrisdone> wise
15:03:06 <donri> [insert waiting for OP skeleton pic]
15:03:15 <Axman6> that's the first thing i've seen that has made me want to try emacs
15:03:45 <donri> also see his other videos on emacs e.g. haskell imports
15:05:17 <byorgey> ooh, haskell-move-nested is sexy too
15:05:47 <chrisdone> yeah, that's so convenient
15:06:42 <gwern> groom should just be in ghc
15:06:57 <gwern> if spaces matter size-wise, you shouldn't be using read/show
15:08:42 <chrisdone> gwern: agreed!
15:09:18 <_oz> pretty-show is another alternative
15:09:24 <_oz> it sometimes generates too many lines tho
15:09:43 <chrisdone> anyhoo, I'm outta here, ciao!
15:10:29 <qwerty> Hi
15:10:45 <qwerty> i need help
15:11:27 <Axman6> don't we all
15:11:34 <glguy> Anyone know how to specify an argument with "cmdlib" where if you don't specify the flag at all it gets "nothing" and if you do specify the flag you get the string argument? So "myprogram -i var" or "myprogram", not "myprogram -i"
15:11:36 <Guest90705> :?
15:11:38 <Axman6> I for one have a drinking problem
15:11:41 <Guest90705> wait a minute
15:11:53 <glguy> I can't find the correct combination of "Default" and "Required" to make this happen
15:11:59 <Axman6> it's ruined not just my life, but that of my wife and children
15:12:06 <Axman6> XD
15:12:50 <Yankovsky> much better than guest124812
15:13:01 <Yankovsky> i need help
15:13:17 <glguy> Yankovsky: You should just ask your question. If someone is able they will try and help.
15:13:23 <Yankovsky> which os better for haskell programming
15:13:27 <Yankovsky> linux windows
15:13:32 <Axman6> all of them
15:13:47 <Axman6> but honestly, probably linux
15:13:50 <donri> fedora *subjective question -> subjective answer*
15:13:54 <Axman6> OS X is pretty great these days too
15:14:07 <AfC> donri: good type signature, there
15:14:09 <Yankovsky> ok
15:14:14 <Yankovsky> i heard about helium
15:14:27 <Yankovsky> that it is a good implementation for learning
15:14:30 <donri> AfC: not sure if valid
15:14:32 <Yankovsky> haskell
15:14:40 <donri> AfC: Silly subjective => -- there, fixed
15:14:45 <AfC> donri: yeah, well. You pays your money and you takes your chances
15:14:57 <Axman6> t's good for learning hellium anyway. I've never tried hellium though
15:15:32 <Yankovsky> i just have some problems with installing it on win so i ask
15:15:39 <Yankovsky> ok
15:15:40 <Axman6> Yankovsky: I'd personally recommend just trying to learn haskell, since there's better materials for learning haskell with.
15:15:43 <Axman6> @where lyah
15:15:44 <lambdabot> http://www.learnyouahaskell.com/
15:15:49 <Axman6> Yankovsky: ^^^^^^^^^^^^^^^^
15:16:04 <Yankovsky> i know
15:16:22 <AfC> Yankovsky: in the embedded world, people work in the environment that is most productive for them, and then export / cross compile as a last step before downloading firmware at a device for testing.
15:16:24 <Yankovsky> currently i am read book and write functions
15:16:26 <AfC> Yankovsky: That analogy probably applies well to something like Haskell; work where you're comfortable; if you have to port later to the production system you can look at that separately.
15:16:27 <Yankovsky> )
15:16:51 <AfC> Yankovsky: of course, since any production environment is likely to be Linux, you're probably not too badly off if you're using Linux on the desktop as well.
15:16:59 <Yankovsky> i am just not very comfortable with my environment win ghci notepad
15:17:13 <Axman6> yeah, that's a pretty crappy environment
15:17:20 <Yankovsky> ))
15:17:27 * kfish uses ghci and a paper notepad
15:17:27 <lambdabot> kfish: You have 1 new message. '/msg lambdabot @messages' to read it.
15:17:28 <Axman6> at lweast install notepad++ if you decide to use windows
15:17:30 <Yankovsky> so i asking for something better)
15:18:05 <Yankovsky> i have ubuntu no problem with it
15:18:30 <Yankovsky> i find something called yi
15:18:33 <Yankovsky> is it cool?
15:18:38 <kfish> copumpkin: websockets
15:18:44 <copumpkin> kfish: whee
15:18:55 <shachaf> glguy: Require False, Default "foo" doesn't do what you want?
15:19:03 <copumpkin> kfish: I was just bemoaning the lack of websocket clients in haskell the other day :)
15:19:08 <copumpkin> kfish: but I guess you won't necessarily provide one either
15:19:16 <glguy> shachaf: no: then it uses the default value if you write "myprogram -i"
15:19:24 <copumpkin> oh man, glguy is back!
15:19:30 <kfish> copumpkin, i expect we'll make a demo ie. port the scope demo
15:19:35 <copumpkin> kfish: whee!
15:19:49 <glguy> shachaf: I just found a work-around. if you use [] instead of Maybe it doesn't do the optional argument behavior...
15:20:04 <Yankovsky> i will try ubuntu yi helium
15:20:16 <Axman6> Yankovsky: do you have a favourite editor?
15:20:26 * glguy doesn't support these kinds of obfuscation on top of getOpt >:-(
15:20:44 <Yankovsky> visual studio for c# and intellij idea for java
15:20:45 <Yankovsky> )))
15:21:05 <Yankovsky> editors, heh
15:21:22 <Axman6> yeah, those aren't editors :P
15:21:52 <glguy> Hello, copumpkin
15:22:06 <glguy> Are you sure I haven't been here the whole time and *you've* been MIA?
15:22:16 <copumpkin> oh, that is possible
15:22:36 <glguy> but not likely :)
15:22:52 <roha> newbie question: is there a reversed, standard version of the '.' operator  in haskell? like |- in f#? Also is there something like |> which just shoves the left value into a function on the right?
15:23:11 <glguy> Control.Arrow.>>>, I believe
15:23:21 <glguy> or is it Category now?
15:23:29 <Axman6> > ((+1) >>> (*2)) 4
15:23:31 <lambdabot>   10
15:23:38 <glguy> :t (>>>)
15:23:39 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
15:23:56 <roha> great! thanks
15:23:57 <glguy> :t (>>>) :: (a -> b) -> (b -> c) -> (a -> c)
15:23:58 <lambdabot> forall a b c. (a -> b) -> (b -> c) -> a -> c
15:24:10 <Axman6> @hoohle system
15:24:11 <lambdabot> System.Process system :: String -> IO ExitCode
15:24:11 <lambdabot> System.Cmd system :: String -> IO ExitCode
15:24:11 <lambdabot> package system-argv0
15:24:29 <donri> lambdabot corrects for typos?
15:24:41 <Axman6> if they're close enough, yeah
15:25:38 <Yankovsky> Thanks!
15:25:46 <Yankovsky> and bye
15:25:50 <Yankovsky> haskell is cool
15:26:40 <shachaf> Yes, the way Haskell introduces auto-type-correction into all your programs is very nifty.
15:27:49 <donri> typo inference?
15:30:15 <dgpratt> Axman6: still stuck :-/
15:30:29 <shachaf> Also, I'm unable to type the character combination "typo" on the first try.
15:31:01 <dgpratt> I think: foo (x:xs) = f x (foo xs), where f :: m a -> m [a] -> m [a]
15:31:16 <Axman6> dgpratt: ok, so, where were we, foo (mb:mbs) = ...? (\b -> ...) right?
15:31:46 <shachaf> glguy: It doesn't seem to do that here.
15:32:23 <shachaf> glguy: What behavior are you after?
15:32:42 <dgpratt> Axman6: does that jive with what I just wrote?
15:32:56 <shachaf> I get "FATAL: option `--glguy' requires an argument".
15:33:09 <Axman6> dgpratt: hmm, the types given were a bit backwards. anyway, let's start with: foo (mb:mbs) = banana (\b -> ...) mb
15:33:46 <glguy> shachaf: did you make a tiny test case? Could you paste what you did to hpaste?
15:33:52 <ski> shachaf : (re "type^Ho") hehe
15:34:40 <ski> "auto-type-correction" ?
15:34:57 <glguy> I'd like my program to print the message you just printed
15:35:03 <glguy> I haven't had that experience, yet
15:35:21 <shachaf> glguy: I just modified the thing in the documentation.
15:35:27 <shachaf> I deleted it already, but let me reconstruct it.
15:36:22 <glguy> the field should be "Nothing" if you do not specify the flag at all, it should be "Just thing" if you specify "-i thing"
15:36:31 <glguy> and it should be an error to specify "-i" on its own
15:36:40 <shachaf> glguy: http://hpaste.org/55031
15:36:41 <shachaf> Oh.
15:36:45 <shachaf> I must've misunderstood.
15:37:22 <shachaf> Yes, I didn't realize that you meant Nothing, the value.
15:38:14 <glguy> I don't care which constructor I get, exactly. I just need to be able to tell the difference between the flag being specified or not. The correct behavior is obtained by using List instead of Maybe
15:38:22 <glguy> cmdlib tries to be clever if you use Maybe
15:38:48 <glguy> the really unfortunate result of that cleverness is that  "-i thing" and "-ithing" parse differently
15:39:19 <sal23> Any pointers on how to do the union of data types for storable vector? I asked this question but haven't found any good solution yet: http://stackoverflow.com/questions/8438130/defining-storable-instance-for-union-data-types
15:40:14 <sal23> the other thing I am wondering about is whether this kind of thing is done by Data.Vector.Vector behind the scenes? If so, there is no point in writing my own union using storable vector and primitive instances
15:40:32 <dgpratt> Axman6: well, the lambda must have type :: a -> m [a], right?
15:40:35 <shachaf> glguy: I don't particularly like this library, at first sight.
15:40:47 <shachaf> That sort of magic, anyway.
15:41:05 <Saizan> sal23: the answer you got there seems as good at it gets
15:41:10 <glguy> shachaf: I'm modifying code that uses it. I would not have elected to use it in my own code.
15:41:15 <Axman6> dgpratt: yep.
15:41:45 <Axman6> dgpratt: now don't forget about that mbs sitting there. we need to turn that [m b] into m [b] right?
15:41:54 <glguy> sal23: you'll need to do the same thing that C programmers do and encode the choice with a tag
15:41:58 <dgpratt> Axman6: right
15:42:05 <sal23> Saizan, does the compiler order the constructor by indices, i.e., the constuctor byte is going to be 1, 2 and so on
15:42:13 <Axman6> dgpratt: do we have a function that can do that?
15:42:33 <Axman6> (hint, you're probably still writing it!)
15:42:35 <dgpratt> Axman6: foo :)
15:42:40 <Axman6> yes!
15:43:02 <Axman6> ok, so, how about we not turn that [m b] into m [b]:
15:43:23 <Saizan> sal23: that's up to you when you write the Storable instance
15:43:48 <Axman6> so, so far you've got: foo (mb:mbs) = banana (\b -> ...) mb
15:44:01 <dgpratt> const $ foo xs?
15:44:19 <sal23> Saizan: got it. So, basically tag it when storing data
15:44:22 <Axman6> now we want to extend that: banana (\b -> ... (foo mbs)) mb
15:44:31 <Saizan> sal23: yeah
15:44:40 <Axman6> well, const is going to ignore the value we want from the mb right?
15:44:57 <dgpratt> Axman6: yeah, no good
15:45:15 <sal23> Saizan: off-hand, you know if this is going to be better than using Data.Vector.Vector, performance-wise?
15:45:53 <Axman6> ok, so, i'll give you one more thing, and see if you can get it from there. I'm struggl;ing to think how to get you to get yourself to what i'm about to show you, so i thyink it's probably difficult to come up with on your own
15:46:30 <Saizan> sal23: i don't know
15:46:37 <Axman6> foo (mb:mbs) = banana (\b -> banana (\bs -> ...) (foo mbs)) mb
15:46:38 <dgpratt> Axman6: let me stare at it a bit
15:46:51 <sal23> Saizan: guess I will find out myself then, with criterion benchmarking
15:46:57 * dgpratt is not looking! :)
15:47:22 <Axman6> I think this is actually a lot clearer when you're using (>>=), because the order of the arguments makes the flow of data more obvious
15:55:34 * hackagebot cuda 0.4.0.2 - FFI binding to the CUDA interface for programming NVIDIA GPUs  http://hackage.haskell.org/package/cuda-0.4.0.2 (TrevorMcDonell)
15:58:24 <alistra> hi
15:58:41 <ski> lo
15:58:51 <alistra> mid
16:00:57 <alistra> it appears that haskell has really a lot of libs
16:01:15 <alistra> but no really popular and awesome programs
16:01:28 <alistra> besides a few (inb4 xmonad, pandoc and darcs)
16:03:28 <jessopher> those are real, popular, and i think they are awesome. they are not a lot though
16:03:31 <Axman6> there's also GHC
16:03:35 <jessopher> hah
16:03:50 <Axman6> which is super popular among haskell users
16:03:58 <alistra> well those self refferential do not count
16:04:05 <shachaf> Hugs are also pretty popular among Haskell users.
16:04:16 <shachaf> shapr, for instance.
16:04:25 * ski hugs Hugs
16:04:27 <jessopher> i like lowercase hugs
16:05:34 * hackagebot noodle 0.0.18 - the noodle programming language  http://hackage.haskell.org/package/noodle-0.0.18 (JesseRudolph)
16:05:50 <youlysses_> Hey all, I'm intrested in learning haskell as my first "offical" language. Reccommended, or...?
16:05:59 <alistra> kinky
16:06:00 <EvanR> yes
16:06:13 <Axman6> youlysses_: depends why you're learning it
16:06:37 <Axman6> youlysses_: it can be quite difficult for people who've used other languages to adjust (but most who do are extremely thankful they did)
16:07:33 <youlysses_> Mainly for fun, Axman6. I've learned bits and pieces of c,c++, and python... but not too much.
16:07:57 <jessopher> theres lots of funs in haskell to be had
16:08:25 <Axman6> well, haskell will be very different to those. it's a lot of fun, and you'll learn a lot of useful techniques for use in those other languages
16:08:30 <m3ga> youlysses_: there are a number of universities that teach haskell basics in 1st year computer science
16:09:10 <youlysses_> Well, that sounds promising.
16:09:17 <m3ga> they do it because it puts people with no previous programming experience on the same footing as people who have already done java, C++ etc
16:09:31 <mgccl> Is it possible to user define things, so it can have special syntax like lists? For example what if I want to implement sets? and write things like someset = {1,2,5,4},  someset :: {a}
16:09:40 <youlysses_> How so? Because it's not a "mainstream" language?
16:09:47 <AfC> youlysses_: yes
16:09:49 <hpaste> Ice_Blade pasted “Type test” at http://hpaste.org/55032
16:10:03 <m3ga> haskell is radically different from the more mainstream languages.
16:10:13 <youlysses_> In a good way...?
16:10:17 <AfC> youlysses_: (but more in the sense that things are done rather differently in Haskell than they are done in mainstream languages. Popularity isn't the issue)
16:10:27 <Ice_Blade> Could someone help me with a question I'm having some trouble with?
16:10:30 <NewAlexandria> I found this place by stumbling across "Literate Programming"
16:11:04 <jessopher> i think its pretty mainstream now anyway. just not in a LOC or commercial sense
16:11:11 <Axman6> youlysses_: in a very good way
16:11:13 <m3ga> python, ruby java and C++ are basically the same language (the differences are minor). haskell is veru different from all of those.
16:11:22 <m3ga> youlysses_: yes, in a really good way
16:11:44 <m3ga> NewAlexandria: literate programming can be done in any language and also haskell. i have done some.
16:11:46 <youlysses_> So you could say, it's better designed or?
16:11:49 <AfC> youlysses_: I've heard the phrase "rewire your brain" a few times in recent weeks; seems an appropriate metaphor if you've been doing more conventional programming. And if you haven't, then it's not really an issue.
16:11:50 <ski> youlysses_ : the point is that most popular languages are imperative, while Haskell is functional, a different programming paradigm
16:11:51 <m3ga> in haskell
16:11:56 <companion_cube> python and C++ ? seriously ??
16:12:18 <m3ga> companion_cube: who me?
16:12:24 <salisbury> does there exist a 'map' that does not require all elems of list to be same type?
16:12:35 <companion_cube> yes... they are both imperative, but yet very different, imho
16:12:57 <m3ga> basically object oriented imperative languages.
16:12:58 <NewAlexandria> m3ga: I I suppose you could, but no compiler/interpreter is out there for it; mainstream
16:13:06 <engla_> salisbury: how can it then be a list?
16:13:14 <youlysses_> That sounds like good marketing for haskell. haskell "rewire your brain" lol
16:13:24 <m3ga> NewAlexandria: what do you want to do?
16:13:36 <salisbury> [(a, b), (c, b), (c, b)]
16:13:37 <m3ga> what goal are you trying to achieve
16:13:42 <Axman6> salisbury: what do you mean by 'map'? a function or a data type?
16:13:48 <salisbury> perhaps its technically not a list
16:13:52 <salisbury> function
16:14:02 <salisbury> [a] -> [b]
16:14:03 <Axman6> well, lists can't hold more than one type
16:14:20 <Axman6> @hoogle threadDelay
16:14:21 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
16:14:21 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
16:14:22 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
16:14:25 <ski> youlysses_ : note that Haskell has no assignment, and no direct analogue of `for' and `while' loops built-in
16:15:03 <ski> (youlysses_ : and this is considered a feature, not a bug)
16:15:22 <NewAlexandria> m3ga: write more concise code... e.g. with powerful-concise expressions, but also transparent & historically-understandable expressions
16:15:50 <youlysses_> ski, weird.
16:15:53 <AfC> youlysses_: I assume you've already looked around a bit, so have doubtless run into "Learn You a Haskell". Go spend a few weeks with it, it's pretty fun. See what you think after playing a bit.
16:15:58 <ski> youlysses_ : but fun ! :)
16:16:16 <salisbury> yeah, I'll do with out it I guess
16:16:22 <m3ga> NewAlexandria: literate programming means something else, basically keeping documentation and code in the same file.
16:16:31 <youlysses_> I heard of it before, AfC and I just found again litterally 10 secs ago lol
16:16:47 <ski> youlysses_ : basically, (temporarily) forget (some of) the basics of programming, when you are learning Haskell
16:16:48 <m3ga> NewAlexandria: see wikipedia for literate programming
16:16:50 <NewAlexandria> :m3ga: this is my thought though, even if poorly expressed
16:17:29 <ski> salisbury : `map' has nothing to do with it. it's the list type itself (or really the static type system) which requires each element in a list to have the same type
16:17:50 <youlysses_> Well next firday, I have nearly a month free ... so, should be fun!
16:18:13 <NewAlexandria> m3ga: very concise coding, e.g yield, send, call, namespacing in RoR, can be very hard to 'unpack' in the mind - even if you wrote it
16:18:34 <NewAlexandria> m3ga: c.f. FactoryGirl codebase's use of "association" calls
16:18:48 <m3ga> NewAlexandria: google for 'literate haskell' which should find you the haskell wiki section on literate programming in haskell. documtation in literate prog can be text or say TeX
16:19:11 <ski> salisbury : assume you wanted to have a list with elements of either type `A' or `B', then you could instead define a new type `data AorB = An_A A | A_B B', and use `[AorB]' instead -- or you could reuse `Either' and use `[Either A B]'
16:19:13 <AfC> youlysses_: be warned, just because you can read it on the web doesn't mean it's something you can skim. It is worth reading slowly, patiently, and carefully.
16:19:25 <augur> hey conal
16:19:53 <m3ga> NewAlexandria: adding type annotations is very good documentation. something you cannot really do in say ruby
16:20:03 <ski> salisbury : another way, which may be sometimes useful is if you're doing OO-style things, like wanting a list of widgets, each of which may be a different type, but which all responds to the methods in the `Widget' class
16:20:55 <Axman6> :t intercalate
16:20:56 <lambdabot> forall a. [a] -> [[a]] -> [a]
16:21:03 <ski> salisbury : and if you really want that, you can do that too : this is `[exists a. Widget a *> a]' (but in current Haskell you have to write that in a somewhat indirect/roundabout way, but it can be done)
16:22:11 <youlysses_> AfC, beleive me, I plan on taking my time.
16:22:22 <elliott> ski: Antipattern :/
16:22:39 <elliott> (Admittedly I don't know what "Widget" looks like here.)
16:23:01 <Axman6> @hoogle system
16:23:02 <lambdabot> System.Process system :: String -> IO ExitCode
16:23:02 <lambdabot> System.Cmd system :: String -> IO ExitCode
16:23:03 <lambdabot> package system-argv0
16:23:08 <Ice_Blade> Anyone feel like helping me? http://hpaste.org/55032 I'm trying to build a list of tuples of a general type, but it's not working.
16:24:33 <elliott> Ice_Blade: your Expr definition is wrong
16:24:34 <monochrom> type ASteps = [[(AExpr,String)]] is illegal. AExpr is not a type.
16:24:39 <elliott> you need to name your constructors
16:24:42 <Cale> Ice_Blade: What do AExpr and BExpr have in common that you want to capture? What do you plan to do to consume the list you want to produce?
16:24:45 <elliott> monochrom: Yes iti s.
16:24:48 <elliott> data AExpr = Int N [...]
16:24:54 <elliott> Ice_Blade: try data Expr = A AExpr | B BExpr
16:24:56 <monochrom> oh, sorry
16:25:10 <elliott> Ice_Blade: note that you must apply an AExpr to A, like (A myAExpr), and similarly for BExpr, to get an Expr
16:25:16 <elliott> Haskell doesn't have subtyping
16:25:39 <elliott> so strictly, what you want to do is not possible (but this is a good thing :) )
16:25:42 <ski> elliott : i didn't say you want to do this often, but sometimes you do want this
16:26:06 <youlysses_> What's with this magic?
16:26:07 <elliott> ski: right, yeah; if typeclasses are useful in 90% of your contexts and you need a list in one place it's obviously for the best
16:26:07 <youlysses_> http://tryhaskell.org
16:26:14 <elliott> I think I might just have an adverse reaction to "Widget" :)
16:26:19 <Ice_Blade> Its part of a parser, and I wanted a list of all the expressions that were evaluated, as a BExpr can have an AExpr in it I was running into problems
16:26:21 <elliott> youlysses_: it runs server-side
16:27:13 <ski> elliott : if you want, you can pass around a tuple/record record of operations instead. sometimes you can even partially apply them and remove the existential, just passing a bunch of closures around
16:27:13 <youlysses_> Oh ok.
16:27:33 <youlysses_> I was like 0_0
16:27:50 <youlysses_> Would be super suprised if it was embedable ...
16:28:09 <elliott> youlysses_: Well, people have compiled Haskell to JS before.
16:28:23 <Ice_Blade> hmm, I guess I'll go rethink my strategy without subtyping :(, elliott: thanks for the tip.
16:28:42 <youlysses_> Well that's actually pretty badass! DId it kill the performance or?
16:28:45 <elliott> Ice_Blade: no problem :) these kinds of restrictions will help you structure things better in the long-run, honest :)
16:28:53 <elliott> youlysses_: Here's an old demo: http://www.cs.york.ac.uk/fp/darcs/yhc/web/jsdemos/HsWTKDemo.html
16:29:00 <elliott> youlysses_: but the compiler it was based on died
16:29:30 <youlysses_> Still... pretty cool!
16:29:32 <Ice_Blade> yeah, the project was almost done, and then I ran into this. Murphy strikes again. :D
16:29:53 <jessopher> robocop?
16:30:01 <elliott> youlysses_: it is, and hopefully we'll be doing that kind of thing regularly sometime soon :)
16:30:22 <elliott> Ice_Blade: Is the wrapping in A/B thing unworkable for you?
16:30:31 <elliott> It's probably preferable to replacing all your code.
16:31:11 <Ice_Blade> I'm going to go back and check, if it doesn't work I'll be back
16:31:51 <periodic> There's no good way to write a function with a type like "(C a, C b, C c) -> (a, b, c)" is there?
16:32:07 <ski> periodic : depends on what `C' is
16:32:08 <monochrom> depends on C
16:32:13 <periodic> For artibary-length tuples.
16:32:17 <ski> no
16:32:31 <periodic> Assume there is a function "C a -> a" that may do various things.
16:32:48 <NewAlexandria> m3ga: for now, hacking ruby by day, I'll play with rocco for ruby.  http://rtomayko.github.com/rocco/  This is far flung from a Haskell forum, but thanks - one and all
16:33:04 <periodic> I really want to be able to define a list of query parameters, where each column has a known type, and return the same number of items with the associated types.
16:33:56 <periodic> So if it was something like "(EmployeeName, EmployeeDepartment, EmployeeSalary)" it would return "(String, String, Float)".  (where the types of the selectors might be something like "Column a" where a is the type of data to return.)
16:34:19 <bloop> So I'm finally starting to understand monads, but I'm having trouble seeing the wider implications. Will someone help me understand the wider implications?
16:34:30 <salisbury> ski: thanks for the tip. I didn't think of using Either
16:34:36 <periodic> I can specify columns in a list, but I don't have a good way to return the data without a cast.
16:34:42 <elliott> bloop: You might find "understanding monads" a little anti-climatic.
16:34:46 <salisbury> ski: this is what I will do
16:35:00 <monochrom> you can write like:
16:35:03 <monochrom> @src sequence_
16:35:04 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
16:35:09 <elliott> bloop: They're just an abstraction that happens to appear in a lot of places.
16:35:10 <periodic> bloop: Lots of stuff can be defined as a monad.  It's a very common and powerful pattern that crops up a lot.
16:35:11 <monochrom> and it works for all monads
16:35:33 <Cale> bloop: Have you looked at Parsec?
16:35:35 <monochrom> FSVO "works", depending on FSVO ">>", of course
16:35:59 <periodic> In the last 24 hours I've used monadic functions to handle IO, errors, maybe values, parsing, configuration...
16:38:02 <periodic> bloom: I once implemented a monad in PHP...
16:38:07 <bloop> I'm learning about them with Clojure, because types and categories confuse me and lambda doesn't :p. At any rate, I see that they're just a design pattern like CPS, but more general. It's that generality that I don't quite understand the scope of.
16:38:11 <periodic> it was actually really useful.
16:38:14 <jessopher> the big let down with monads is that their implications are much wider than something like a 'class' or a 'module'. They don't care at all if you are writing software, so framing them solely as a design tool is ... strange
16:39:29 <monochrom> Phil Wadler's http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#marktoberdorf may show you how much you can re-factor with monads
16:41:44 <elliott> bloop: you really need a typed language to properly understand monads, IMO
16:41:56 <elliott> because they're basically defined by the structure of the types
16:43:12 <periodic> I don't know if you need types, but you need to understand that monads are operations on types/categories (I'm light on the category theory, but it helped me understand it)
16:43:12 <Ice_Blade> elliott: I did a find and replace and it seems to be working now (where it didn't when I tried it earlier today...) problem appears to be solved. Thanks again.
16:43:35 <elliott> Ice_Blade: cool :)
16:43:37 <bloop> elliott: well, there is a monad library for Clojure, and it doesn't exactly have to jump through hoops. It's just that the Monad laws have to be proven with tests rather than types. I'm ok with that, in general
16:43:50 <elliott> bloop: the monad laws aren't proven with types in haskell
16:44:06 <jessopher> they dont even need to be proven
16:44:11 <jessopher> yeah that
16:44:16 <elliott> bloop: unfortunately it's very hard to explain why a language like haskell is better-suited to helping you understand the abstract structure of monads than something like clojure -- it's basically because clojure has no machinery for "talking about types"
16:44:17 <dgpratt> Axman6: still around?
16:44:29 <bloop> elliott: really? so you can make a bind/return combinations that aren't valid and just what? get run time errors?
16:44:56 <elliott> bloop: to prove the monad laws with types would require full dependent typing, which is a BIG trade-off
16:45:02 <ski> elliott : you don't need a statically typed language to understand monads (but it helps), what you *need* is to think in types (which can be done in Scheme or whatever)
16:45:03 <Axman6> dgpratt: yep
16:45:19 <elliott> yes, Haskell can have runtime errors for violating the laws, although it's not so much "errors" as things just give wrong results
16:45:24 <rwbarton> bloop: you won't get run time errors
16:45:25 <elliott> ski: right
16:45:27 <dgpratt> Axman6: this? foo (\b -> banana (\bs -> unicorn (b:bs)) (foo mbs)) mb
16:45:33 <elliott> ski: but it's hard to learn that in a language like Scheme or whatever
16:45:43 <rwbarton> it is like if you defined addition on some class in an OO language, and you didn't have (a + b) + c = a + (b + c)
16:46:09 <ski> jessopher : they *do* need to be proven. it's easy to make something an instance of `Monad' without satisfying the laws
16:46:16 <Axman6> dgpratt: almost, need to replace the first foo with banana
16:46:44 <bloop> well, i have noticed with the clojure stuff that it helps if they name things specifically like "mv" vs "v"...
16:46:47 <jessopher> ski: thats what I am saying, haskell monads arent necessarily monads at all. need was the wrong word i guess
16:46:50 <dgpratt> Axman6: oh, oops, just a translation error
16:47:10 <ski> bloop : if you make operations which doesn't satisfy the monadic operations, then refactorings which you might do without thinking about them can be incorrect, and generic monadic code might work incorrectly
16:47:27 <dgpratt> Axman6: thanks much for the help :)
16:47:55 <Axman6> dgpratt: but apart from that, it looks perfect. sequence [] = return []; sequence (ma:mas) = ma >>= \a -> sequence mas >>= \as -> return (a:as)
16:47:58 <ski> bloop : "work incorrectly" in a similar way as an operations which expectes as sorted list as input may behave strangely if you pass a non-sorted list
16:49:01 <bloop> ski: gotcha. my understanding of haskell's type system is very limited, so I guess the assumption of "it knows everything and can prove arbitrarily complex things about your code" is probably not valid then?
16:49:04 <donri> @hackage checkers
16:49:04 <lambdabot> http://hackage.haskell.org/package/checkers
16:49:07 <donri> can be used to check monad laws
16:49:13 <donri> with quickcheck
16:49:29 <alistra> well i would figure it plays checkers
16:49:32 <alistra> by the name
16:49:33 <elliott> @faq Can Haskell know everything and prove arbitrarily complex things about your code?
16:49:34 * mreh imagined a haskell implementation of draughts
16:49:35 <lambdabot> The answer is: Yes! Haskell can do that.
16:49:41 <elliott> bloop: WRONG AGAIN, LISPER!
16:49:45 <ski> bloop : yeah, it can't (but if you work with the types instead of against them, you can be suprised with how much you actually *can* check statically)
16:49:56 <elliott> @faq Can Haskell beat Lisp in any flamewar?
16:49:57 <lambdabot> The answer is: Yes! Haskell can do that.
16:50:05 <jessopher> hah
16:50:16 <bloop> I'm not here for a flamewar >.>
16:50:25 <elliott> Aww, okay. :(
16:50:43 <donri> @faq Can Haskell shoot you in the foot?
16:50:44 <lambdabot> The answer is: Yes! Haskell can do that.
16:51:05 <alistra> @faq can a bot in haskell anwer 'no', to each faq question?
16:51:05 <bloop> but the machinery of monads, while pretty complex and not fully loaded into my head, makes more sense to me than the implications. the general space of (in the very low level like C++: "action lists") (in Scheme: continuations) (in things with lambda: CPS) seems like it hits an apex with monads. Is that maybe in the general area of accuracy?
16:51:05 <lambdabot> The answer is: Yes! Haskell can do that.
16:51:16 <ski> bloop : e.g. it's possible with GADTs to ensure that operations on AVL trees preserve the AVL invariant
16:51:21 <elliott> bloop: Well, Cont is actually the most general of monads.
16:52:12 <elliott> bloop: http://blog.sigfpe.com/2008/12/mother-of-all-monads.html -- but it probably won't make any sense without at least cursory Haskell knowledge :/
16:52:14 <bloop> elliot: what do you mean by that? Can I implement Maybe with Cont?
16:53:26 <elliott> bloop: It's quite subtle, but it basically reduces to "if you have 'native support' for Cont (say, fancy language syntax or whatever), then you can recover this support for every other monad with a clever embedding".
16:53:37 <elliott> You can almost certainly state the property in a stronger way, but I'm too cautious to :)
16:53:51 <bloop> elliott: I've read LYAH and can read the syntax (though I find it gross, tbh ;) ) so I guess that counts as 'cursory' ...
16:54:15 <Axman6> this is pretty cool, I've written a program that can run a program that you give it, and using a power meter connected to the machine, record the power usage during its run to a CSV file =D
16:54:29 <Axman6> a freaking love Haskell, it makes this stuff so easy
16:54:36 <elliott> bloop: the thing about the syntax is that all the "bloat" people perceive is actually just operators from libraries -- and any Lisp fan can appreciate the difference :P
16:55:18 <ski> elliott : well, you really need composable continuations
16:55:28 <elliott> ski: well, I did say Cont, not call/cc :)
16:55:47 <ski> elliott : yeah, but you need `Cont2'
16:56:22 <bloop> elliott: right, I'm just not a fan of precedence or significant whitespace or operators where the means of parsing the rest of the form is not the first thing in the form... so, you know, not Lisp
16:57:08 <elliott> bloop: That's fine until you actually start writing programs at a sufficiently high-level, higher-order, abstract level -- then all your actual form is lost in the deep nesting of connectives ;-) </flamebait>
16:57:21 <elliott> The significant whitespace is optional, though; it just desugars to a syntax with {;}.
16:57:24 <bloop> If I ever get sold on static typing, I'll probably end up at Qi before Haskell, is what I'm saying
16:57:35 <ski> there's Liskell, though
16:57:41 <elliott> Too bad Qi is dead :P
16:57:50 <elliott> (OK, OK, so it just became Shen.)
16:57:58 * ski isn't sure whether therp still maintains it, though
16:58:00 <elliott> ski: Has anyone touched Liskell in years?
16:58:05 <ski> @where liskell
16:58:05 <lambdabot> http://clemens.endorphin.org/liskell
16:58:08 <ski> elliott : no idea
16:58:22 <elliott> "Liskell is available from this darcs repository:
16:58:22 <elliott> http://darcs.liskell.org/ghc-6.6/ghc"
16:58:29 <elliott> Oh goody.
16:58:43 <elliott> I don't think I've ever had the chance to use 6.6 :-)
16:58:50 <ski> preflex: xseen therp
16:58:50 <preflex>  therp was last seen on freenode/#xmonad 136 days, 10 hours, 27 minutes and 21 seconds ago, saying: nicoo: well, I can trick xmonad, by echo '#!/bin/bash; if [ -e "triggerFileForFvwm]; then fvwm; else /usr/bin/xmonad "$*"; fi'  > bin/xmonad
16:59:59 <DanBurton> you could always just write Haskell in lisp-style: always use functions in prefix form, parens everywhere, etc.
17:00:21 <DanBurton> heck I think with enough parens you can get around the significant whitespace issue
17:00:50 <DanBurton> personally I'm a big fan of significant whitespace
17:01:00 <elliott> <DanBurton> you could always just write Haskell in lisp-style: always use functions in prefix form, parens everywhere, etc.
17:01:16 <elliott> DanBurton: maybe not such a good idea :P
17:01:18 * ski thinks sexps can be pretty readable
17:01:29 <elliott> you could always just write Haskell in lisp-style [...] as long as you don't mind everyone else disowning you
17:01:54 <ski> (of course, in some cases you want to make `n'-ary functions, or macros, to make something palatable)
17:07:48 <bloop> I guess my big question is: can I always refactor what in Clojure might be a ref/agent/atom with a monad?
17:08:42 * ski isn't sure exactly what "a ref/agent/atom" in Clojure is
17:09:10 <ski> possibly a "ref" is like an `IORef', or probably more like a `TVar' (STM) ?
17:11:52 <bloop> ski: refs are impure mutable references (to immutable things) that can only be changed in an explicit transaction
17:12:14 <ski> yeah, i think that (at least more or less) corresponds to `TVar's, then
17:12:26 <elliott> yeah, that's TVars, precisely
17:12:29 <ski> `TVar's can only be changed in an `STM' transaction
17:12:35 <elliott> (they can only be read in an explicit transaction, too!)
17:13:08 <bloop> elliott: that's a difference, Clojure refs can be read at any time
17:13:19 <elliott> bloop: it's equivalent
17:13:22 <bloop> so can TVars always be refactored out?
17:13:32 <elliott> \var -> atomically (readTVar var) :: TVar a -> IO a
17:13:37 <elliott> (aka readTVarIO)
17:13:40 <ski> @type GHC.Conc.writeTVar
17:13:41 <lambdabot> forall a. GHC.Conc.TVar a -> a -> GHC.Conc.STM ()
17:13:44 <ski> @type GHC.Conc.readTVar
17:13:45 <lambdabot> forall a. GHC.Conc.TVar a -> GHC.Conc.STM a
17:13:45 <elliott> it's just a really trivial transaction :)
17:13:48 <ski> @type GHC.Conc.atomically
17:13:49 <lambdabot> forall a. GHC.Conc.STM a -> IO a
17:13:50 <elliott> ski: (why not Control.Concurrent.STM?)
17:13:57 <elliott> also,
17:13:59 <elliott> @type GHC.Conc.newTVar
17:14:01 <lambdabot> forall a. a -> GHC.Conc.STM (GHC.Conc.TVar a)
17:14:09 <ski> elliott : dunno, that's what hoogle told me
17:14:23 * ski didn't pause to think about it
17:14:56 <ski> but yes, `Control.Concurrent' would be the standard way to get at these
17:17:10 <bloop> So, Haskell has some facilities for mutable state and impurity, but idiomatically uses them very rarely. is that accurate?
17:17:20 <ski> bloop : so i don't think you'd factor them out, you'd just use them probably similarly to how you do in Clojure
17:17:46 <elliott> bloop: Well, not necessarily.
17:17:59 <elliott> bloop: Certainly the ideal is to have every program be 99% purely functional with a small imperative core around it to interface with OSes.
17:18:05 <ski> bloop : haskell has facilities for mutable state and effects (not impurity), and you use then when you need to, or when you think it will help
17:18:21 <elliott> bloop: But Haskell has very well-polished support for effects, and its mutable state is among the best you'll find, since it has one of the only decent STM implementations.
17:18:26 <elliott> (I gather Clojure has one of the few others.)
17:18:34 <bloop> right. sounds like Clojure...
17:19:07 <ski> bloop : the `STM' monad is just a way to enforce that you don't change a `TVar' outside of an `atomically' transaction
17:19:16 <bloop> Clojure also has vars, agents, and atoms, which have other concurrency semantics.
17:19:19 <bloop> ski: that's neat!
17:19:29 <bloop> ski: clojure builds that in to the language
17:19:45 <ski> bloop : do you mean it checks it at run-time ?
17:19:50 <bloop> ski: (of course I mean that in a negative tone)
17:20:06 <bloop> ski: yep. throws up on you
17:20:07 <elliott> bloop: and most importantly, you cannot execute IO actions in STM
17:20:09 <ski> or do you mean that transaction-code is a different syntactic class to normal code ?
17:20:22 <elliott> I think Haskell is the only language that statically ensures your transactions are actually properly isolated
17:20:34 <bloop> I mean that the (dosync (blah blah)) special form can not be implemented in Clojure
17:20:54 <bloop> as far as I know...
17:21:03 <elliott> you can implement STM + TVar in Haskell, it's slow enough :P
17:21:05 <elliott> s/enough/though/
17:21:13 <bloop> the different mutable things in Clojure aren't libraries and aren't part of any prelude. they're baked in
17:25:35 * hackagebot cereal 0.3.5.0 - A binary serialization library  http://hackage.haskell.org/package/cereal-0.3.5.0 (TrevorElliott)
17:25:54 <ski> bloop : and `STM' is a monad basically because we need to specify the order in which we change `TVar's, and what we do next may depend on the value we read out of a `TVar', and this is more or less what monads are for (i.e. explicit sequencing, as well as later actions depending on results of previous actions)
17:26:40 <bloop> ski: makes sense
17:27:18 <ski> (if we need to sequence things, but what to do next doesn't depend on previous results, one can usually use an applicative functor, instead of a monad -- often specific parsers only need to use the "applicative functor" functionality, not the full monadic functionality)
17:27:23 <hpaste> boris annotated “MST” with “MST (annotation)” at http://hpaste.org/54996#a55034
17:27:27 <ski> (oh, and every monad is an applicative functor)
17:28:19 <ski> bloop : note that for some monads, "sequencing" may get a nonstandard interpretation
17:28:23 <ski> consider
17:28:52 <bloop> ski: applicative functor? I think that's what you call how I usually do animation O.o
17:29:12 <ski> > do x <- [0,1,2]; y <- [0,1,2,3]; guard (x <= y); return (x,y)
17:29:14 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(1,1),(1,2),(1,3),(2,2),(2,3)]
17:29:23 <ski> > do y <- [0,1,2,3]; x <- [0,1,2]; guard (x <= y); return (x,y)
17:29:24 <lambdabot>   [(0,0),(0,1),(1,1),(0,2),(1,2),(2,2),(0,3),(1,3),(2,3)]
17:29:30 <donri> LYAH quite nicely teaches functors, then applicative, and then monads in terms of those
17:29:57 <ski> note how the `x <- [0,1,2]' and `y <- [0,1,2,3]' basically works like a loop each, and the sequencing here really means how these loops are nested inside each other
17:30:19 <ski> so, in the list monad, "sequencing" means "loop nesting"
17:30:38 <elliott> bloop: It's probably best to learn functors, then applicative functors, then monads.
17:30:41 <bloop> ski: right. the monad libaray for Clojure explains that the 'for' special form is just the list monad
17:30:51 <elliott> bloop: Unfortunately the only language with abstractions for applicatives that I know of is ... Haskell.
17:31:03 <bloop> elliott: I have a macro for them :p
17:31:11 <donri> @where LYAH
17:31:11 <lambdabot> http://www.learnyouahaskell.com/
17:31:13 <elliott> Huh? I don't know what "for" is, but it doesn't sound like the list monad.
17:31:17 <ski> bloop : heh, i suppose you could have interactive animation, which reacts to how you fiddle your mouse pointer, or whatever, and that would probably need to be monadic, then
17:31:19 <rwbarton> Or you can view the list monad as giving you a notion of nondeterministic computation, so first you are nondeterministically choosing a value from [0,1,2], then a value from [0,1,2,3]
17:31:23 <elliott> donri: bloop wants to learn monads without learning Haskell :p
17:32:00 <rwbarton> (and in fact this is a common example of using call/cc)
17:32:10 <donri> learn you a haskell idiom
17:32:11 <bloop> ski: exactly! that's what I've been struggling with. The way I've been doing it, each 'statement' can only respond to the previous, so I go through all this hulabaloo to thread values through, and that's exactly what a monad is, right?
17:32:43 <DanBurton> sorta, yes
17:33:18 <ski> bloop : hm, how does `for' work in Clojure ?
17:33:19 <bloop> elliott: ski's code in clojure is (for [x [0 1 2] y [0 1 2 3] :when (<= x y)] [x y])
17:33:36 <EvanR> if each statement can only respond to the previous, then its a fold right
17:33:46 <elliott> bloop: Really? I'd expect that to zip them. But okay.
17:34:00 <EvanR> or unfold
17:34:18 <ski> bloop : ok. does that only work with lists, or with any monadic actions ?
17:34:36 <DanBurton> > do x <- [0..2]; y <- [0..3]; guard (x <= y); [x, y]
17:34:37 <lambdabot>   [0,0,0,1,0,2,0,3,1,1,1,2,1,3,2,2,2,3]
17:34:47 <ski> DanBurton :)
17:34:49 <augur> is there a Reader utility function that basically is like...   do set x ; return lookup == return x
17:35:12 <DanBurton> or perhaps "return [x,y]" would be what the clojure is doing
17:35:15 <augur> i mean, that looks like state, so maybe thats not quite what i mean, but
17:35:24 <donri> augur: i don't think "reading" involves "setting"
17:35:36 <bloop> ski: it only works for sequences (which are all clojrue data structures)
17:35:50 <augur> if Reader is sort of like variable binding (with a single variable being bound, essentially), there should be some form of "shadowing"
17:35:52 <ski> augur : there is no `set' in the environment/reader monad
17:35:53 <DanBurton> oh dumb me; I always forget to read up above
17:36:01 <DanBurton> I just jump in :)
17:36:05 <ski> augur : there is a "local set", though
17:36:11 <augur> ski: oh?
17:36:15 <ski> @type local
17:36:17 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
17:36:23 <augur> im just thinking of cases where like
17:36:24 <ski> @type local . const
17:36:25 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => r -> m a -> m a
17:37:04 <augur> eval (Lam v b) = \x -> eval b . assign v x
17:37:04 <ski> EvanR : that's a bit vague ..
17:37:05 <Saizan> yeah, local is shadowing
17:37:34 <augur> ok ill check out local
17:37:38 <augur> @where local
17:37:39 <lambdabot> I know nothing about local.
17:37:41 <augur> :|
17:37:51 <ski> augur : `eval (Lam v b) = \x -> local (insert (v,x)) (eval b)' would be more like it
17:37:52 <rwbarton> @hoogle local
17:37:52 <lambdabot> System.IO localeEncoding :: TextEncoding
17:37:53 <lambdabot> GHC.IO.Encoding localeEncoding :: TextEncoding
17:37:53 <lambdabot> Data.Time.LocalTime module Data.Time.LocalTime
17:37:53 * augur shakes fist
17:37:56 <rwbarton> er
17:37:59 <ski> @index local
17:37:59 <lambdabot> Control.Monad.Reader, Control.Monad.RWS
17:38:39 <augur> what is MonadReader? :|
17:39:05 <ski> augur : the general class for monads which support the basic features of `Reader r'
17:39:11 <augur> ah
17:39:18 <augur> weird
17:39:36 <donri> http://haskell.org/haskellwiki/All_About_Monads#Definition_7
17:39:51 <ski> augur : e.g. `Reader r' and `ReaderT r m' will be instances of `MonadReader', but so will `StateT s (Reader r)'
17:40:07 <ski> augur : it's basically a way to avoid littering your code with `lift' calls
17:40:19 <DanBurton> augur: yeah "set" looks like state, not reader
17:40:54 <ski> augur : if `ask' only worked on `Reader r', then to use it in `StateT s (Reader r)', you'd have to say `lift ask'
17:41:13 <ski> augur : but with the class `MonadReader', we can say just `ask' in that latter case, anyway
17:41:55 <ski> augur : what is the type of your `eval' ?
17:42:31 <augur> ski: er.. something like Term -> Reader Env Int i suppose.
17:42:46 <vrook> Has ghc become a de facto standard? I keep running into issues which are solved by a ghc extension. For instance I just noticed that "deriving" only works with 6 classes, which is weird. But there's an extension for that.
17:42:50 <augur> or something like Term a -> Reader (Env a) a
17:43:21 <ski> bloop : i'm not exactly sure what you mean by "each 'statement' can only respond to the previous" .. but for a monad in general, each command may depend on any result of any previous command (which is in scope)
17:44:06 <hpc> vrook: basically; you're free to make another compiler (and some have), and getting it up to spec isn't hard
17:44:41 <rwbarton> extensions are gradually being added to new versions of the Haskell language standard
17:44:46 <hpc> vrook: but then you have to implement the GHC extras, which could be extensions, pragmas, or even just the GHC API
17:44:57 <vrook> what does me making another compiler have to do with the question
17:45:12 <vrook> nevermind, i'll ignore that
17:45:12 <hpc> vrook: that was the "royal you"
17:45:42 <hpc> vrook: anyhoo, a new compiler would be a shitload of work, and most people would rather just write a GHC extension to do a neat new thing
17:45:53 <bloop> ski: s/statement/command then... yes. monads are neat and I want to grokk them for pretty immediate practical reasons (though of course only limited to personal projects because nobody will pay you to write FP :p )
17:46:01 <ski> augur : hm, you might need something more like `eval (Lam v b) = asks $ \env -> return $ \x -> runReader (eval b) (insert (x,v) env)', then
17:46:10 <hpc> bloop: plenty of people will pay
17:46:26 <hpc> bloop: haskell (and i think ocaml a bit more so) are extemely popular in finance
17:46:38 <elliott> bloop: Maybe people won't pay you to write Clojure ;-)
17:46:53 <bloop> hpc: and I like making games, where the whole industry is oriented around C++
17:47:01 <hpc> bloop: facebook uses haskell "scripts" to do automated refactoring of their crappy php code
17:47:05 <hpc> ah
17:47:05 <augur> eh.. probably. :)
17:47:20 <hpc> bloop: the place Cale works for is making an iphone game in haskell
17:47:23 <bloop> hpc: that amuses me greatly (the facebook thing)
17:47:34 <hpc> ("making"; they haven't finished porting GHC yet lol)
17:47:39 <ski> bloop : well, i think often in games, one can sneak in some kind of "scripting" language
17:47:49 <lita> Oi
17:47:51 <augur> ski: im not really thinking about what im writing so i probably didnt mean what i wrote :)
17:47:58 <bloop> ski: true, and I got my kicks with Lua for a while. but now I need harder drugs
17:48:16 <lita> Hi, I´m new in here
17:48:21 <lita> I´m from Brasil
17:48:26 <ski> hello lita
17:48:29 <hpc> bloop: i have a game i want to make in haskell, which i think would be a huge pain to write in any other language
17:48:37 <ski> lita : are you wanting to learn Haskell ?
17:48:58 <hpc> bloop: it uses ContT magic to keep the UI responsive during periods of very heavy computation
17:49:07 * hpc will probably never finish it though
17:50:04 <mm_freak_> hpc: any reason not to use concurrency for that?
17:50:38 <ski> bloop : re monads : one big reason for they being using much in Haskell is that you really need some way to explicitly sequence effectful code (like I/O e.g.) in a lazy language. since it's lazy, it would probably be crazy to make it impure (i.e. having side-effects), since it would be very hard to predict when side-effects occured
17:51:05 <hpc> mm_freak_: GTK uses thread-local state, so i couldn't do any UI updates from forked threads
17:51:17 <mm_freak_> hpc: you don't have to
17:51:30 <hpc> mm_freak_: it's probably easy to do, yeah, but i just don't feel like thinking about it
17:51:33 <ski> bloop : so, we needed some way of doing basic I/O and mutable state things (which is a no-brainer in imperative languages) -- there were a couple of approaches to that, before Wadler realized one could use the monad idea for this
17:51:37 <hpc> and i liked having a reason to learn ContT
17:51:49 <bloop> ski: I can see that. Clojure only has lazy data structures (as opposed to lazy evaluation) and needs a few functions like "doall" and "doseq" to force code with side-effects to evaluate. Of course, it can only do it because THOSE functions aren't lazily evaluated.
17:52:14 <hpc> mm_freak_: i could easily multithread, and i think i actually compile with the threaded runtime
17:52:15 <ski> bloop : then, having that, people noticed that there were several other things that also fit the general monadic idea, like exceptions, nondeterminism, continuations e.g.
17:52:20 <mm_freak_> hpc: i used to love ContT, but its missing MonadFix bites me
17:52:49 <mm_freak_> especially in games without MonadFix i'd probably kill myself =)
17:52:49 <bloop> ski: yep. that's why I'm interested. Its a good design pattern for sequencing operations, even if you don't NEED to explicitly sequence operations
17:52:56 <hpc> mm_freak_: ah, yeah; someday ill learn to love the miracle of MonadFix
17:52:57 <ski> bloop : so, people e.g. started writing parser monads which are really nice and helpful, but which you probably wouldn't have thought of to write in an imperative language
17:53:09 <hpc> this game is simple enough that it doesn't need it, i think
17:53:20 <hpc> just a giant IORef that gets updated single-threadedly
17:53:28 <hpc> for a turn-based game
17:53:53 <ski> bloop : e.g. O'Caml, which is a (strict) functional language which allows side-effects, has a library (LWT) for handling cooperative threads, which is monadic
17:54:50 <mm_freak_> hpc: you don't need a complicated application for MonadFix…  a simple application is:  using in this instant a value computed by a computation from the last instant, when that computation comes later in the composition
17:54:59 <bloop> ski: I think I have what I was looking for: Even in Haskell where monads are idiomatically used for ALL sequenced operations, things like TVar are still very occasionally useful.
17:55:11 <mm_freak_> do rec { x <- comp1 y; ...; y <- comp2 }
17:55:53 <hpc> is mfix even definable for ContT?
17:55:57 <hpc> :t mfix
17:55:58 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
17:56:14 <mm_freak_> i think someone showed an IORef mess to define MonadFix for ContT
17:56:20 <vrook> Suppose I monadically build up 1 million putChars. Is GHC making 1 million thunks, or can it do something smarter?
17:56:23 <hpc> @djinn (a -> ((a -> r) -> r)) -> ((a -> r) -> r)
17:56:23 <lambdabot> -- f cannot be realized.
17:56:24 <ski> mm_freak_ : i suspect `mfix' might be doable for linear continuations
17:56:27 <hpc> pah
17:56:30 <mm_freak_> so it's probably possible
17:56:41 <mm_freak_> ski: i've tried hard, but all solutions were impure
17:56:43 <elliott> vrook: the IO monad pretty much gets "eliminated" at runtime
17:57:03 <elliott> there are thunks, but I don't think they'll stay around for a case like that
17:57:08 <mm_freak_> all CPS-based monads fail at that unfortunately, including some useful ones like Iteratee
17:57:26 <ski> mm_freak_ : one problem with `mfix' is what laws we want for it. iirc Magnus Carlsson has a paper somewhere where he shows that you can't make an `mfix' for `Cont' which satisfies all the "reasonable" laws he proposes
17:57:54 <mm_freak_> ski: i couldn't write mfix at all, let alone obeying any laws
17:58:00 <sully> I feel liked Magnus Carlsson should be a viking king or something
17:58:20 <ski> well, he *is* a swede
17:58:38 <hpc> @src Maybe mfix
17:58:38 <lambdabot> mfix f = let a = f (unJust a) in a where unJust (Just x) = x
17:59:33 <elliott> ; unJust Nothing = fix id
17:59:53 <elliott> partial no more! :-)
18:00:00 <hpc> so it looks like the pattern for mfix is
18:00:15 <hpc> mfix f = let x = f (extract x) in x
18:00:24 <hpc> for some "extract" that is appropriate to the monad
18:00:42 <ski> bloop : yeah. the idea is that you normally first to try to write your code in a non-effectful way (not using monads or applicative functors), but if you find that you want/need to use some kind of effect, then you reach for them
18:00:42 <hpc> and for Identity that would be "id", which would make mfix = fix
18:00:52 * hpc thinks out loud
18:02:08 <hpc> so for Cont, that "extract x" could be "x id"
18:02:22 <ski> bloop : many algorithms can e.g. be stated perfectly well without mutation (sometimes with a `O(log(n))' penalty), but sometimes you want to have mutation, so you can then use the `ST s' monad inside your code, mutating all you like, but still (often) present a non-monadic interface
18:02:28 <hpc> but for ContT, i think you need a way to pull that "x" out of the monad you transform over
18:02:34 <hpc> or something
18:02:34 <mm_freak_> hpc: try to write it
18:02:39 <mm_freak_> it sounds simple, i know =)
18:02:44 <hpc> mm_freak_: :P
18:02:49 <mm_freak_> the insight comes when you try to write it
18:02:58 <bloop> ok thanks everyone (especially ski) and happy hacking!
18:03:01 <mm_freak_> you will find that you could sort of 'continue forever' =)
18:03:08 <ski> bloop : yw
18:03:49 <hpc> @unmtl ContT r m a
18:03:50 <lambdabot> (a -> m r) -> m r
18:03:56 <mm_freak_> in fact mfix /is/ a very simple combinator…  as long as there is no CPS to un-CPS =)
18:04:28 <Axman6> woah, i think the cont monad just clicked for me :o
18:04:40 <Axman6> it seems so obvious now
18:05:04 <hpc> Axman6: try wrapping your head around http://hpc.dyndns-web.com:8000/blog/view.cgi?id=11
18:05:06 <mm_freak_> you might be able to write MonadFix for a variant of ContT without CPS effects:  data Codensity m a = forall r. Cod ((a -> m r) -> m r)
18:05:14 <hpc> Axman6: i think that should make sense now
18:05:45 <rwbarton> ok, so here is a puzzle I have concerning mfix
18:05:52 <hpc> mm_freak_: i remember someone saying you can write mfix for any Monad that is also a Comonad
18:06:02 <ski> @let evalCont :: Cont o o -> o; evalCont = (`runCont` id)
18:06:03 <lambdabot>  Defined.
18:06:04 <Axman6> is that yours?
18:06:09 <hpc> yes
18:06:10 <ski> @type let mfix f = return x where x = evalCont (f x) in mfix
18:06:11 <lambdabot> forall o (m :: * -> *). (Monad m) => (o -> Cont o o) -> m o
18:06:16 <mm_freak_> hpc: not very useful though, because there are only few haskell monads that are also comonads
18:06:24 <hpc> mm_freak_: true
18:06:37 <hpc> wait, isn't Cont a comonad?
18:06:44 <rwbarton> Suppose I want to write down the list of length 5 whose first element is 0, and each element is one more than the previous element, then I can write
18:06:48 <ski> hpc : can you tell why this `mfix' isn't a valid one ?
18:06:55 <mm_freak_> hpc: no, but there is a Discont comonad =P
18:06:56 <rwbarton> > fix (\xs -> 0 : map (+1) (take 4 xs))
18:06:57 <lambdabot>   [0,1,2,3,4]
18:07:04 <hpc> heh
18:07:11 <ski> hpc : no, `Cont' has the wrong kind to be able to be a comonad
18:07:41 <rwbarton> now suppose I want to generate all lists of length 5 which start with 0 and where each element is either 1 or 2 more than the previous element
18:07:45 <ski> (that's a hint)
18:08:25 <hpc> :t (`runContT` return)
18:08:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => ContT a m a -> m a
18:08:48 <rwbarton> how do I write this with mfix?
18:09:17 <mm_freak_> rwbarton: doesn't sound like an mfix question to me…  mfix is for value recursion, or as another way to look at it, for certain kinds of data dependencies
18:09:34 <mm_freak_> fix is perfectly appropriate for that
18:09:36 <rwbarton> I want to express a value recursion in a nondeterministic setting
18:10:00 <ski> > mfix $ \xs -> do n <- [1,2]; return (0 : map (n +) (take 4 xs))  -- rwbarton, this might not be what you're after
18:10:02 <lambdabot>   [[0,1,2,3,4],[0,2,4,6,8]]
18:10:19 <rwbarton> ski: I wanted each choice to be independent
18:10:29 <ski> rwbarton : in this, the nondeterministic choice is only made once (which is what `mfix' is supposed to do)
18:10:57 <hpc> a good example of mfix use is in memoization - one guy uploaded an sqlite memoization package
18:11:17 <rwbarton> I think this example can be done with mfix, it's the next one that causes problems.
18:11:18 <hpc> and it uses mfix to memoize recursive functions
18:11:30 <Axman6> sounds cool
18:11:42 * roconnor uses mfix for time travel
18:12:26 <rwbarton> > mfix $ \xs -> fmap (0 :) $ mapM (\x -> [x+1, x+2]) (take 4 xs)
18:12:30 <lambdabot>   mueval-core: Time limit exceeded
18:12:37 <rwbarton> > mfix $ \xs -> fmap (0 :) $ mapM (\x -> [x+1, x+2]) (take 1 xs)
18:12:41 <lambdabot>   mueval-core: Time limit exceeded
18:12:52 <EvanR> hmm. is there a package for keeping a persistent state for an application across restarts
18:12:56 <rwbarton> Perhaps this one doesn't work either.
18:13:07 <mm_freak_> rwbarton: i can't imagine a way to do that with mfix
18:13:09 <EvanR> acidstate seems to be for multiwriter multireader
18:13:15 <rwbarton> What do you think what I wrote should compute?
18:13:23 <mm_freak_> rwbarton: look at the type signature…  unlike fix there aren't even any starting values
18:13:29 <mm_freak_> :t mfix
18:13:30 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
18:13:31 <Axman6> "The usual description of ContT is that it "reifies the remainder of the computation", which is right up there with "monoid in the category of endofunctors"." someone gets it!
18:13:32 <roconnor> EvanR: I thought acidstate was for persistent state
18:13:37 <roconnor> EvanR: but I haven't used it yet
18:13:39 <EvanR> yes
18:13:44 <EvanR> it seems good
18:13:44 <hpc> Axman6: goddamn right
18:14:08 <EvanR> roconnor: but perhaps overkill since an 'app' generally doesnt need acid
18:14:38 <mm_freak_> EvanR: many apps need ACID…  it's just that programmers don't realize
18:14:46 <EvanR> hmm
18:14:52 <EvanR> good call
18:14:52 <hpc> Axman6: i can't wait for the terrible continuation tutorials to start rolling in, so i can say Cont is like wearing roller skates in a maple syrup factory
18:15:14 <mm_freak_> EvanR: i always go crazy when my system crashes and i have to recover all my mail accounts in claws mail, because it does not use ACID for its configuration files
18:15:17 <donri> EvanR: are you having any issues with acid-state?
18:15:25 <EvanR> no im not
18:15:29 <EvanR> havent used it yet
18:15:35 <rwbarton> mm_freak_: I am going to perform a nondeterministic computation that outputs a list of integers. An oracle gives me access to the output which I call xs. My output is the list which starts with 0, then for each of the first four elements of xs, either I output one more than that number or two more than that number.
18:15:49 <donri> it's not difficult to use, if that was your fear
18:16:03 <EvanR> no im hoping its easy
18:16:10 <EvanR> like several other packages i picked up
18:16:17 <vrook> Apart from demarkating pure and impure code, what do monads actually buy us? I don't have trouble making that separation in my favorite languages, so in this regard Haskell is solving a problem I don't actually have.
18:16:25 <rwbarton> The possible outputs of this procedures are precisely the lists of length 5 which start with 0 and where each element is either 1 or 2 more than the previous element.
18:16:50 <hpc> vrook: monads don't mark "pure/impure" code so much as they provide a "sequencing" function
18:16:57 <hpc> vrook: take a look at the source for the Identity monad
18:16:57 <MostAwesomeDude> vrook: Massive simplification of certain kinds of pseudo-imperative workflows.
18:17:01 <MostAwesomeDude> vrook: Look at ST.
18:17:08 <hpc> vrook: then open a text editor and copy-paste it
18:17:11 <rwbarton> And I can express the procedure as \xs -> fmap (0 :) $ mapM (\x -> [x+1, x+2]) (take 4 xs). It's just that mfix is somehow unable to produce the result.
18:17:19 <hpc> vrook: then erase all instances of "Identity"
18:17:22 <vrook> hpc: yes of course, it's hard to be precise in irc
18:17:40 <hpc> vrook: imagine what return and (=<<) look like
18:18:05 <hpc> (spoiler: "return" is magic "id", and (=<<) is magic ($))
18:18:08 <Axman6> vrook: it is a problem you do have, you just don't know it
18:18:13 <donri> or (>>=) for that matter ;)
18:18:40 <MostAwesomeDude> What's =<< ?
18:18:48 <MostAwesomeDude> Besides a guy with a very wide mustache?
18:18:49 <donri> oh, you used that intentionally because ($)
18:18:54 <hpc> MostAwesomeDude: it's (>>=) with the arguments flipped
18:19:06 <MostAwesomeDude> hpc: Oh. Does it still execute in the same order?
18:19:06 <Axman6> @src (=<<)
18:19:07 <lambdabot> f =<< x = x >>= f
18:19:13 <MostAwesomeDude> Aha.
18:19:41 <hpc> donri: yeah, it's a trick i like a lot
18:20:03 <hpc> donri: i use it to explain how Category works in terms of Monad (http://hpc.dyndns-web.com:8000/blog/view.cgi?id=8)
18:20:28 <mm_freak_> rwbarton: you know, i might find a way to write this with mfix
18:20:32 <mm_freak_> but the monad wouldn't be []
18:21:14 <donri> hpc: there's a bug in your stylesheets
18:21:20 <mm_freak_> really, the type signature of mfix alone gives me the impression that it's simply not possible
18:21:40 <donri> hpc: font-family: mono should be monospace
18:21:41 <rwbarton> I don't see why
18:21:57 <rwbarton> I think you can do it by replacing [] with a different monad that also models nondeterminism
18:22:01 <vrook> MostAwesomeDude: can you be more specific about "massive simplification"? What could be simpler than calling stuff directly -- not using monads?
18:22:12 <mm_freak_> rwbarton: then write it
18:22:29 <MostAwesomeDude> vrook: Did you see the ST monad?
18:22:46 <hpc> donri: oh balls
18:22:50 <rwbarton> :k Logic
18:22:51 <lambdabot> * -> *
18:22:53 <rwbarton> ooh
18:23:09 <hpc> donri: my approach to designing my website so far has been "no CSS errors, no JS errors, and looks how i want in the latest ff"
18:23:15 <donri> hpc: as a result the code blocks render in proportional font for me :)
18:23:16 <vrook> MostAwesomeDude: yes, what about it?
18:23:16 <rwbarton> no MonadFix though, apparently
18:23:24 <mm_freak_> Logic is just a more efficient [], and it doesn't have MonadFix anyway
18:23:42 <MostAwesomeDude> vrook: Well, it lets you reason about the order of operations in a certain simple way.
18:23:47 <hpc> donri: and... it is monospace already
18:23:54 <rwbarton> Those two statements seem somewhat at odds with each other, but ok.
18:23:58 <hpc> must be part of the highlighting script
18:24:00 <Axman6> hpc: not for him
18:24:13 <donri> hpc: yes, in syntaxhighlighter.css
18:24:25 <hpc> donri: try refreshing
18:24:29 <endojelly> from http://www.haskell.org/haskellwiki/Monad/ST: " [1] (Since we're using Integers, technically it's not constant space, as they grow in size when they get bigger, but we can ignore this.)"
18:25:07 <endojelly> couldn't the example just use Int instead of Integer and the function would really run in constant space, making the footnote unnecessary?
18:25:19 <donri> hpc: myep that's more like it
18:25:36 <donri> hpc: don't feel bad, snap has had a similar bug since forever on their website (still do)
18:25:45 <hpc> haha
18:25:53 <donri> in their case, they have monospace quoted
18:26:02 <Axman6> D:
18:26:05 <Axman6> the horror!
18:26:10 <donri> you're not allowed to quote pseudofonts, it seems
18:26:14 <hpc> donri: yeah, it being in third-party code makes me totally unguilty :D
18:26:27 <vrook> endojelly: My guess is that being wrong is worse than growing space.
18:26:29 <hpc> donri: i had to do a fair bit of tweaking of colors and stuff to get it to look as good as it does
18:26:47 <vrook> that is, overflows
18:26:51 <rwbarton> ugh, I can't define a Monad instance in terms of return and join?
18:26:59 <hpc> it had some bugs that made it off by a fraction of an em and adding useless scroll bars
18:27:08 <endojelly> vrook, "within Int range"?
18:27:19 <hpc> rwbarton: nope; known problem and hell if i know why it isn't fixed
18:27:43 <Saizan> rwbarton: put the join in a where when you define >>= :)
18:28:12 <vrook> endojelly: just sayin' that it will eventually be wrong
18:28:12 <hpc> Saizan: for some monads that can be even slower than directly defining bind
18:28:20 <augur> ski: hmm...   set :: Reader r r -> Reader r a -> Reader r a   ;   set x r = Reader $ runReader r . runReader x
18:28:21 <rwbarton> yeah, that turned out to be the case :)
18:28:36 <rwbarton> oh, you mean slower in terms of runtime?
18:28:38 <Axman6> hpc: hmm, by the end of that page, i'd lost how the final result works :(
18:29:13 <hpc> Axman6: yeah, i was kind of assuming people would follow along with their own code and run it as they went
18:29:46 <Axman6> it might be worth mentioning that at the beginning
18:29:47 <vrook> MostAwesomeDude: can you be more specific about "a certain simple way"? The ST examples seem to look like basic imperative-like do blocks.
18:30:12 <Axman6> :t callCC
18:30:13 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
18:30:23 <Axman6> @src callCC
18:30:24 <lambdabot> Source not found. My brain just exploded
18:31:00 <mm_freak_> @src [] mfix
18:31:00 <lambdabot> mfix f = case fix (f . head) of
18:31:01 <lambdabot>            []    -> []
18:31:01 <lambdabot>            (x:_) -> x : mfix (tail . f)
18:31:11 <hpc> Axman6: mentioned below the block of code where the big GTK program is defined
18:31:40 <endojelly> vrook, hmm, I thought Int in the signature kind of implied that overflows might affect things (the semantics are clearly defined, I believe?), but maybe that's thought too far
18:31:42 <ski> rwbarton : i think the trouble is related to that your `mapM' call there will in a sense double the number of solutions "each time around" the `mfix'
18:32:31 <rwbarton> Isn't mfix supposed to "apply the effects only once" though?
18:32:37 <hpc> Axman6: i actually have a note to do a proper proofread of all the posts i have so far, because the early ones really suck
18:32:41 <hpc> :P
18:32:44 <ski> augur : that is basically `local', yes
18:33:00 <Axman6> hpc: I don't get how it solves the problem. how does it vield control back to the main thread?
18:33:01 <augur> ski: hm!
18:33:15 <mm_freak_> rwbarton: correct, it's not a composition of effects, it only builds data dependencies
18:33:24 <Axman6> windows, why do you randomly decide that you should redraw all your icons?
18:34:14 <endojelly> Axman6, I always wondered about that bit.
18:34:16 <hpc> Axman6: suppose you wrote
18:34:44 <mm_freak_> rwbarton: you might be lucky with nested mfixes, but then you lose the point of using mfix
18:34:48 <hpc> forM_ [0, 1, 2] $ \x -> print x >> yield
18:35:17 <hpc> Axman6: so it would first print x, then it would do yield, which has a continuation which is:
18:35:31 <hpc> forM_ [1, 2] $ \x -> print x >> yield -- more or less this
18:35:34 <MostAwesomeDude> vrook: "it strikes me that ST is like a lexical scope, where all the variables/state disappear when the function returns." From Monad/ST on the wiki. It's just a bit of additional sugar power that lets things be both pure and readable for certain convoluted algorithms.
18:35:44 <MostAwesomeDude> vrook: If nothing else, it eases some of the porting to Haskell.
18:35:46 <hpc> and that gets added as an idle callback in GTK
18:36:10 <hpc> then that's technically the end of this "thread" of execution
18:36:22 <Axman6> hmm, i see
18:36:30 <endojelly> Axman6, I have not used Windows a lot since after about Windows 98, but I clearly remember those random icon redraws. The icons would turn into a default icon (if I remember correctly), and redraw once again to show the actual icons. it's probably somehow connected to memory management?
18:36:31 <Axman6> still not 100% clear, but that makes more sense
18:36:32 <hpc> GTK idles, then goes "oh, i should do this", then continues
18:37:01 <Axman6> endojelly: it's more likely connected with epic failure, but sure :P
18:37:10 <vrook> MostAwesomeDude: My question was: what does that buy us in comparison to simply calling impure functions with an actual lexical scope?
18:37:25 <MostAwesomeDude> vrook: Purity, determinism, isolation.
18:37:37 <hpc> vrook: because from the outside, ST is pure
18:37:40 <ski> endojelly,Axman6 : often the icons are redrawn with the wrong pics
18:38:03 <Axman6> ansd the 'i should do this' but runs the code you want, then adds the next continuation as the next thing to execute by idleAdd right?
18:38:06 <Axman6> and*
18:38:08 <hpc> vrook: ST is the rug; you sweep dirt underneath, but it still looks nice on top
18:38:30 <Axman6> but it makes the dirt all clear when it comes out from under the rug
18:38:48 <ski> vrook : the knowledge that the whole of the computation doesn't need to be explicitly sequences wrt other things, so it doesn't have to live inside a monad
18:38:53 <hpc> you can't hide a brick under there, though
18:39:07 <MostAwesomeDude> Sometimes, you're an imperative systems programmer (/me) and you just want to get something done, but you're not super-sure how you'd implement it prettily and handily. ST lets you hax your way around it and fix it another day.
18:39:15 <hpc> (ie, you can't do anything that would be visible to the outside world, like printing things)
18:39:26 <Axman6> oh, ha
18:39:28 <ski> (hpc : or memoizing)
18:39:31 <augur> ski: hmm. Reader seems difficult to use for actual multi-typed environments
18:39:36 <Axman6> i was struggling with how that made sense XD
18:39:37 <vrook> hpc: But that is not really relevant to my comparison. I said at the beginning that separating pure and impure is not a problem that I have in my favorite languages. So telling me that it's pure is not impressive in this context.
18:39:59 <mm_freak_> > map (scanl (+) 1) (replicateM 4 [1,2])
18:40:00 <lambdabot>   [[1,2,3,4,5],[1,2,3,4,6],[1,2,3,5,6],[1,2,3,5,7],[1,2,4,5,6],[1,2,4,5,7],[1...
18:40:29 <Axman6> vrook: the reason you should like the distinction is that a whole class of bugs are removed when you know that a certain piece of code can't do any IO
18:40:31 <hpc> vrook: ah; i suppose from that perspective, ST looks totally pointless
18:40:32 <endojelly> aren't there some problems that can be solved more efficiently with non-pure algorithms?
18:40:52 <Axman6> endojelly: yes, that's one of the main reasons we have ST
18:41:05 <hpc> endojelly: ST is indeed impure underneath; i think there's even a function that turns an STRef into an IORef
18:41:12 <hpc> @hoogle STRef s a -> IORef a
18:41:13 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
18:41:13 <lambdabot> Data.Graph.Inductive.Basic hasLoop :: Graph gr => gr a b -> Bool
18:41:13 <lambdabot> Data.Graph.Inductive.Query.DFS isConnected :: Graph gr => gr a b -> Bool
18:41:19 <endojelly> that's what I thought ST was for
18:41:20 <hpc> @hoogle STRef
18:41:20 <lambdabot> Data.STRef module Data.STRef
18:41:21 <lambdabot> Data.STRef data STRef s a
18:41:21 <lambdabot> Data.STRef.Lazy data STRef s a
18:41:23 <hpc> pah
18:41:26 <MostAwesomeDude> @hoogle STtoIO
18:41:27 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
18:41:27 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
18:41:27 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
18:41:54 <hpc> haha, that's what it was
18:42:05 <MostAwesomeDude> RealWorld, BTW, is unsafe, but doesn't have the markings for some reason.
18:42:07 <ski> augur : well, if you can implement types `Ident :: * -> *' and `Env :: (* -> *) -> *' with operations `lookup :: Env key -> key a -> Maybe a' and `insert :: (key a,a) -> Env key -> Env key', together with operations for allocating a new `Ident a' for any `a', i think you could use `Reader (Env Ident)'
18:42:24 <augur> O_O
18:42:24 <MostAwesomeDude> So yeah, if you wanna do iffy things with ST, you can, but you can also write totally pure code with it.
18:42:43 <ski> augur : well, s/lookup ::/lookup :: Eq1 key =>'
18:42:44 <hpc> MostAwesomeDude: i suppose because if you are a bad enough dude to even GET a RealWorld, stToIO is the least of your problems
18:42:47 <hpc> :P
18:42:47 <endojelly> but why should I ever write totally pure code with ST...
18:42:57 <MostAwesomeDude> hpc: I am not a bad enough dude. :c
18:42:59 <vrook> Axman6: I just haven't run into this issue of not knowing what does IO. You could say that Haskell is enforcing a well-designed program, but it's not very compelling to me because I just can't remember having that problem.
18:42:59 <Axman6> vrook: if you look closely at the programs you write, you'll notive that most of it can actually be written purerly. if you separate the small amount of IO from the usually large pure part, you'll find that your program can becomd clearer, and you can reason a lot more clearly about what it is actually doing. you don';t have to worry about "is thie value of this thing going to chance between different reads?"
18:43:01 <ski> augur : .. or were you talking about something else ?
18:43:09 <hpc> endojelly: because you get the performance benefits of mutation
18:43:17 <MostAwesomeDude> endojelly: For the reason I do it: Because sometimes it's way easier to reason about your code in that way.
18:43:27 <endojelly> hpc, is that still called "pure"?
18:43:27 <augur> ski: im not sure. i just mean if you want to use Reader for a language with multiple types, higher order functions, etc.
18:43:44 <ski> hpc : `ST' is not impure
18:43:48 <hpc> endojelly: the stuff that is mutable can't ever escape from ST due to type magic
18:43:57 <endojelly> it's referentially transparent, yes, but what does "pure" mean? the same?
18:44:01 <MostAwesomeDude> Technically, nothing in ST is mutable.
18:44:03 <augur> i suppose actually that wouldnt be impossible since you could just have terms in the reader instead of values
18:44:04 <Axman6> vrook: purity also gives you things like the trivial ability to make programs run in parallel, without having to worry about nondeterminism in the results
18:44:13 <hpc> i thought STRefs were implemented as IORefs
18:44:19 <hpc> or some wizardry
18:44:30 <ski> augur : yeah, i was assuming you were talking about having typed identifiers, where the environment would associate each such typed identifier with a value of the respective type
18:44:46 <Axman6> vrook: essencially, purity can give you parallel programs for free (though we don't get it for free because choosing what is expensive and what isn't is best left to the author, not the compiler)
18:44:47 * hpc shuts up now and gets some sleep
18:45:11 <vrook> Axman6: but good programs naturally separate into pure/impure. Assume that I am able to make the separation. Is there anything else that monads actually give me?
18:45:13 <Axman6> hpc: it's more likely IORefs are implemented as STRefs (but i'm pretty sure they're separate things)
18:45:19 <MostAwesomeDude> STRef s a is mutable in s, not in general.
18:45:26 <ski> hpc : normal non-monadic types and functions are implemented by mutation of memory, at the machine code level -- they're still pure
18:45:50 <ski> hpc : what matters is the interface/behaviour, not the underlying implementation
18:46:11 <Axman6> vrook: code reuse. you can use functions like mapM in IO, list, Parsers, Either, because they all use the monadic interface. but it behaves very differently depending on the monad
18:46:32 <Axman6> you get composability for free too
18:47:20 <Axman6> > replicateM 10 "hello" :: [String]
18:47:21 <lambdabot>   ["hhhhhhhhhh","hhhhhhhhhe","hhhhhhhhhl","hhhhhhhhhl","hhhhhhhhho","hhhhhhhh...
18:47:29 <Axman6> > replicateM 10 "hello" :: Maybe String
18:47:30 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Char'
18:47:31 <lambdabot>         agai...
18:47:34 <Axman6> hmm
18:47:39 <Axman6> :t replicateM
18:47:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
18:47:43 <ski> endojelly : "What is a Purely Functional Language" by Amr Sabry in 1993-01 at <https://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps>
18:47:51 <Axman6> > replicateM 10 (Maybe 1)
18:47:52 <rwbarton> aha, here we go.
18:47:53 <lambdabot>   Not in scope: data constructor `Maybe'
18:47:58 <Axman6> > replicateM 10 (Just 1)
18:47:59 <lambdabot>   Just [1,1,1,1,1,1,1,1,1,1]
18:48:00 <Axman6> -_-
18:48:14 <Axman6> > replicateM 10 (Right 1)
18:48:15 <vrook> Axman6: again, just imagine the imperative-language analogue in, say, lisp. I just call map, so I don't even need to remember a mapM.
18:48:16 <lambdabot>   Right [1,1,1,1,1,1,1,1,1,1]
18:48:24 <vrook> ... and I can map to a vector, etc.
18:48:39 <Axman6> but now you've lost all your type safety
18:48:40 <rwbarton> > mfix $ \(~(xs@[a,b,c,d,e])) -> liftM (0 :) $ mapM (\x -> return (x+1) `mplus` return (x+2)) [a,b,c,d] :: [[Int]]
18:48:41 <lambdabot>   [[0,1,2,3,4],[0,1,2,3,5],[0,1,2,4,5],[0,1,2,4,6],[0,1,3,4,5],[0,1,3,4,6],[0...
18:48:59 * anomenat is a haskell beginner and, I must admit, totally confused by monads
18:49:16 <ski> vrook : yes, but if you now need a `map' which calls the argument function in reverse order on the list, you need to check up whether `map' makes any guarantees about in which order the function is called on the elements
18:49:39 <Axman6> anomenat: you'll find that initially, using them is a hell of a lot easier than trying to understand 'what monads are'
18:50:09 <Axman6> because what monads are is extremely simple, but why the simplicity makes them powerful is difficult to see
18:50:20 <rwbarton> > length (mfix $ \(~(xs@[a,b,c,d,e])) -> liftM (0 :) $ mapM (\x -> return (x+1) `mplus` return (x+2)) [a,b,c,d] :: [[Int]])
18:50:21 <lambdabot>   16
18:50:26 <rwbarton> so that works fine
18:50:38 <ski> vrook : e.g. in Scheme, there's `map-in-order' which plays a similar role as `mapM' in Haskell
18:50:45 <vrook> ski: what do you mean check? Order is left to right.
18:50:50 <vrook> ... in lisp
18:51:40 <vrook> scheme is random order, iirc, which I think is wrong
18:52:00 <vrook> (not literally random -- implementation-dependent)
18:52:04 <ski> vrook : in case the order isn't specified, it might be preferable by an implementation to choose to call in another order
18:52:18 <vrook> ski: not in common lisp
18:52:21 <Axman6> :t mapM
18:52:22 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
18:52:24 <EvanR> the idea of map shouldnt involve any order at all
18:52:30 <EvanR> order of evaluation
18:52:36 <EvanR> it could all happen simultaneously
18:52:43 <ski> vrook : ok, so you only have something like `mapM', not something like `map', then
18:53:10 <Axman6> > runState (mapM (\x -> modify (+1) >> return (x*x)) [1..10]) 0
18:53:11 <lambdabot>   ([1,4,9,16,25,36,49,64,81,100],10)
18:53:29 <anomenat> Axman6: yes, that's probably true. It's just a much steeper learning curve than most languages.
18:53:40 <EvanR> anomenat: simple stuff is hard ;)
18:53:51 <Axman6> anomenat: this is true. but the grass is so much greener at the top of the hill ;)
18:53:52 <EvanR> ridiculous complex and wtfy systems are easier for people to pick up, for some reason
18:54:08 <Axman6> EvanR: they're usually more tangible
18:54:14 <Axman6> i? a? hmm
18:54:17 <EvanR> maybe because we are geared toward natural language
18:54:26 <EvanR> which makes no sense
18:55:17 <EvanR> early computer languages tried to emulate english (or russian) ;)
18:55:17 <MostAwesomeDude> It's because you need to understand the IO monad somewhat in order to print your Hello World.
18:55:34 <EvanR> > print "hello world"
18:55:35 <lambdabot>   <IO ()>
18:55:48 <anomenat> I decided to try out Haskell a few days ago, so I wrote a few sorting functions to see what they looked like. I was impressed: very nice, clear expression of the algorithm with no clutter, and it only took me a few minutes to write each one: much faster than doing the same in, say, C. But then I wanted to test them on some files. Hours later and I still hadn't managed to open a file and apply my functions to its contents :p
18:55:58 <cgroza> I still think english emulation is easier with functional languages.
18:56:29 <EvanR> yes
18:56:39 <Axman6> @hoogle FilePath -> IO String
18:56:40 <lambdabot> Prelude readFile :: FilePath -> IO String
18:56:40 <lambdabot> System.IO readFile :: FilePath -> IO String
18:56:41 <lambdabot> System.Directory getAppUserDataDirectory :: String -> IO FilePath
18:57:02 <ski> @google IO monad for people who simple don't care
18:57:03 <lambdabot> http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
18:57:04 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care
18:57:10 <ski> anomenat : have you seen that ^ ?
18:57:13 <anomenat> No
18:57:48 <EvanR> anomenat: check this out
18:57:51 <EvanR> withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
18:57:58 <EvanR> ok nevermind
18:58:32 <anomenat> It was actually the use of things like liftM that confused me
18:58:33 <EvanR> was looking for :: FilePath -> (ByteString -> IO a) -> IO a ;)
18:59:28 <anomenat> I did read http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html though
18:59:31 <ski> anomenat : you can always rewrite `do ...; y <- liftM f blah; ...' into `do ...; x <- blah; let {y = f x}; ...'
18:59:36 <Bynbo7> anomenat: you probably wanted: main = readFile "foo" >>= print . unlines . mySort . lines :P
18:59:41 <cgroza> anomenat: maybe you should take a look at Control.Applicative. It makes the work with monads significantly easier.
18:59:50 <EvanR> heh
18:59:54 <Bynbo7> uh, s/print/putStrLn probably
19:00:07 <Bynbo7> Axman6: piss off!
19:00:07 <cgroza> anomenat: and Control.Monad,
19:00:09 <ski> Bynbo7 : argh, please use `>>>' or `=<<' instead
19:00:29 <Bynbo7> yeah =<< might have been clearer
19:00:34 <ski> (Bynbo7 : `/msg NickServ ghost Axman6 <password>' ?)
19:00:39 <Bynbo7> i never use =<< though
19:00:42 <Bynbo7> never think of it
19:00:47 <Bynbo7> ski: lazy :P
19:00:53 <EvanR> anomenat: try for the most basic forms first, you dont strictly need liftM to do anything
19:00:59 <EvanR> or applicative
19:01:00 <Bynbo7> it'll get disconnected in about 30s anyway
19:01:29 <JoeyA> join . launchMissiles . maybe (return ()) id =<< confirmationFromPresident
19:01:49 <JoeyA> (err, that's probably not right)
19:01:52 <roconnor> JoeyA: please reenter your email address to confirm
19:02:02 <anomenat> ski: hang on, in your example, if blah :: IO a then is x :: a?
19:02:04 <JoeyA> lol
19:02:04 <ski> cgroza : i think one should understand the monadic computation vs. result distinction before trying that
19:02:10 <ski> anomenat : yes
19:02:18 <anomenat> That explains a lot...
19:02:21 <ski> anomenat : that's what `<-' in a `do' *does*
19:02:45 <cgroza> anomenat: code can get really messy if you use that <- alot.
19:03:16 <EvanR> (<-) :: m a -> a  >;)
19:03:20 <ski> cgroza : well, better to be messy than incomprehensible and possibly not working as a result :)
19:03:24 <donri> http://4.bp.blogspot.com/_D_Z-D2tzi14/S8TRIo4br3I/AAAAAAAACv4/Zh7_GcMlRKo/s1600/ALOT.png <- that alot
19:03:24 <EvanR> (that is NOT true im joking)
19:03:28 <mm_freak_> cgroza: why?
19:04:00 <cgroza> mm_freak_: I used to write a program that checks for last modification dates, and I made a 3 line function into a 10 line one.
19:04:12 <EvanR> cgroza: you were just using the wrong monad ;)
19:04:15 <JoeyA> The problem with confirmationFromPresident :: IO Bool is: what if it goes from True to False in the process of launching missiles.  How would one make the operation atomic?
19:04:27 <cgroza> mm_freak_: that's when I looked up and found Control.Applicative and Control.Monad :D.
19:04:33 <mm_freak_> cgroza: that's unlikely to be the fault of '<-'
19:04:41 <ski> EvanR : if `Gamma |- e :: IO tau', then `Gamma |-{x <- e}- Gamma,x :: tau'
19:04:41 <cgroza> EvanR: mm_freak_ : Still a newb here.
19:04:49 <EvanR> JoeyA: uh how would it go from true to false
19:05:17 <JoeyA> EvanR: Might happen when the President calls off the attack.
19:05:24 <anomenat> if I do x <- readFile somePath, what's the type of x?
19:05:30 <EvanR> results of io actions cant be reversed ;)
19:05:41 <EvanR> unless haskell now supports time travel
19:05:42 <mm_freak_> anomenat: what's the type of 'readFile somePath'?
19:05:55 <cgroza> not to mention finding separate names for unpure values just to get them through pure functions.
19:06:00 <ski> @type readFile "somePath"
19:06:01 <lambdabot> IO String
19:06:19 <EvanR> cgroza: that can be annoying
19:06:19 <JoeyA> EvanR: That can be accomplished with some magic involving realWorld#.
19:06:25 <anomenat> mm_freak_: IO String
19:06:35 <mm_freak_> anomenat: then logically what's the type of x?
19:06:51 <ski> cgroza : "unpure values" is misleading
19:06:55 <roconnor> @go IO is not a Monad
19:06:55 <lambdabot> Maybe you meant: google googleit do
19:06:56 <anomenat> Well, I would have said IO String, until a few minutes ago
19:06:56 <EvanR> JoeyA: no amount of code will stop missiles that are already out the launch bay ;)
19:07:07 <cgroza> ski: suggest a better term then.
19:07:07 <mm_freak_> anomenat: and what do you say now? =)
19:07:08 <ski> @google I/O is not a Monad
19:07:09 <lambdabot> http://r6.ca/blog/20110520T220201Z.html
19:07:09 <lambdabot> Title: I/O is not a monad
19:07:14 <Axman6> EvanR: surerly (<-) :: a <- m a? :P
19:07:24 * EvanR goes insane
19:07:25 <anomenat> mm_freak_: String
19:07:34 <ski> cgroza : "values" ? (results of monadic computations/actions, if you want that)
19:07:42 <JoeyA> EvanR: That's the thing.  It takes time for them to be launched.
19:07:45 <mm_freak_> cgroza: what you are experiencing is over-enthusiasm…  don't draw any conclusions from that for now
19:07:45 <anomenat> But I don't fully understand why
19:07:48 <mm_freak_> not a single one
19:08:04 <JoeyA> So it's important to be able to interrupt the operation.
19:08:05 <cgroza> mm_freak_: enthousiasm for what?
19:08:09 <EvanR> JoeyA: unsafeLaunchMissiles implies it cannot be abort once started
19:08:15 <EvanR> unless you destroy the silo
19:08:23 <mm_freak_> anomenat: when you write "x <- c" and 'c' is of type 'm a', then 'x' is of type 'a'
19:08:27 <mm_freak_> for some monad m
19:08:30 <mm_freak_> IO is a monad
19:08:49 <EvanR> if you want to be able to abort the launch, then make unsafeLaunchMissiles :: MVar ()
19:08:50 <mm_freak_> cgroza: right now combinator style =)
19:08:56 <EvanR> write to it to start the launch
19:09:04 <EvanR> take from it to attempt toabort
19:09:05 <cgroza> mm_freak_: :D.
19:09:33 <vrook> is the launch example supposed to demonstrate something about monads?
19:09:35 * Axman6 would have unsafeLaunchMissiles :: IO () and launchMissiles :: IO (() -> IO ())
19:09:38 <cgroza> mm_freak_: if I am enthousiastic for that, I really need to get a life :).
19:09:38 <EvanR> vrook: no
19:09:40 <EvanR> its a joke
19:09:49 <ski> anomenat : the point of `str <- readFile somePath' is to "execute" the `IO'-action, binding it's result to `str'
19:10:02 <EvanR> Axman6: nice
19:10:17 <EvanR> but why not IO (IO ())
19:10:18 <mm_freak_> ski: uh, bad choice of terminology
19:10:24 <JoeyA> vrook: The canonical example of launchMissiles :: IO () has to do with STM.  See http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/index.htm#beautiful
19:10:29 <Axman6> that would work too
19:10:31 <ski> mm_freak_ : "execute" ?
19:10:44 <EvanR> you need () -> IO () to emulate a C void function xD
19:10:46 <edwardk> preflex: xseen byorgey
19:10:46 <preflex>  byorgey was last seen on freenode/#haskell 4 hours, 5 minutes and 34 seconds ago, saying: ooh, haskell-move-nested is sexy too
19:10:54 <mm_freak_> anomenat: the whole point of do-notation together with its '<-' notation is to build a composite action from smaller actions
19:11:23 <mm_freak_> anomenat: '<-' basically allows you to refer to results of subactions
19:11:43 <anomenat> ski: which is the same reason why you could replace "liftM f" with just "f" when you use "let" in your example?
19:11:53 <mm_freak_> ski: yeah, because it's misleading…  it lets the IO monad look special
19:12:04 <mm_freak_> when i started with haskell, i had the impression that IO is just a hack
19:12:08 <cgroza> isn't <- and return covered in every decent Haskell tutorial or book?
19:12:38 <EvanR> vrook: its used as a 'foo' name for IO action values, to demonstrate the difference between IO a type values, and actual effects. or to make fun of unsafePerformIO
19:12:52 <ski> anomenat : yes, since `x' in that example has type, say `String', instead of `IO String', you can just pass it directly to `f' which has type, say `String -> Int' (so `y' will be an `Int' in both versions)
19:12:56 <anomenat> cgroza: yes, I have probably read about it before, but I'm afraid I don't really learn things well until I actually try to do them
19:13:37 <ski> mm_freak_ : well, i use the "execute" term for every monad, including e.g. list monad and `Maybe' monad
19:13:38 <donri> IO are values that are performed if bound to main. if instead main was a string that the runtime printed for you then you can imagine that you could create strings from pure functions, and have them printed by appending them to the main value.
19:14:08 <mm_freak_> ski: and that's fine, as long as you're not talking to a beginner coming from an imperative language =)
19:14:17 <EvanR> donri: basically a writer?
19:14:24 <rwbarton> ok, so suppose I have   data T a where A :: (z -> a) -> T z -> T a  (and possibly some other constructors)
19:14:45 <mm_freak_> for us "executing" is really just mapping, for the "executing" is commanding the computer to do something
19:14:46 <cgroza> Why can't I refer to names introduced with <- in where clauses?
19:14:55 <donri> EvanR: what do you mean?
19:15:04 <mm_freak_> cgroza: because they are not in scope there…  you can have inline let-clauses
19:15:07 <wayne> what kind of software is better written in imperative than functional?
19:15:15 <EvanR> donri: you described a writer-like monad
19:15:19 <ski> anomenat : i suppose mm_freak_ would like me to clarify to you that this "execution" of actions isn't anything specific to the `IO' monad, it works the "same" for every monad
19:15:23 <cgroza> mm_freak_: never tried with a let.
19:15:34 <cgroza> mm_freak_: I mostly use where.
19:15:40 <donri> EvanR: i tried to make up a non-monad example
19:15:47 <vrook> unsafePerformIO is a good example of why the separation virtue does not count for much. Any good program has a natural separation between pure/impure. Haskell says, "well I enforce it!" But it's enforcing a problem that's not actually a problem for me. And with unsafePerformIO it's not enforced anyway.
19:15:51 <russellw> wayne, anything with hard real-time constraints that can't afford garbage collection. Functional programming really needs garbage collection
19:15:59 <rwbarton> and I have f :: a -> T a, and I want to write something like    case f undefined of A g _ -> A g (mfix ((\(A _ r) -> r) . f . g))
19:16:01 <EvanR> donri: oh. yeah main :: String, now it makes sense ;)
19:16:07 <EvanR> except it could not do IO
19:16:14 <EvanR> and would be a constant result
19:16:18 <donri> yea, but it's a simplification for sake of example
19:16:28 <mm_freak_> cgroza: variables bound in do-notation are only in scope for the following part of the computation (unless you use do-rec-notation)
19:16:37 <ski> cgroza : `where' attaches to the definition equations, not to any sub-expression/command, the variables bound with `<-' are simply not in scope in the `where' part
19:16:42 <donri> the point is to think of IO actions as values
19:16:46 <EvanR> russellw: i wonder if we will bypass that, theoretically
19:16:58 <cgroza> mm_freak_: ski : that explains it.
19:16:59 <donri> you can pass them around, create them in pure contexts
19:17:06 <rwbarton> this doesn't type check because ghc can't see that if "f undefined" is "A g _", then any output of f will be of the form "A _ r" _for the same type variable z_
19:17:10 <Axman6> russellw: the number of programs with hard real-time constraints is very small though
19:17:45 <rwbarton> is there a non-unsafeCoerce way around this?
19:18:19 <mm_freak_> wayne: also it's not just a question of application type, but also of programmer preference
19:18:19 <ski> vrook : well, really the only valid way to use `unsafePerformIO act' is if `act' is equivalent to `return x' for some `x' (and in that case, it returns `x') -- in other cases, you get undefined behaviour (the implementation can do what it likes)
19:18:26 <russellw> Axman6, on the desktop or server sure. But embedded is a different story. How big is the embedded software industry compared to the whole? I suspect big, but I haven't been able to find much hard data
19:18:35 <Axman6> russellw: also, there are a few programming languages for hard real-time environments that are not imperative at all. have a look at esterel
19:18:43 <ski> vrook : so, it's not really a matter of breaking the separation, it's a matter of undefined behaviour
19:18:57 <wayne> mm_freak_, well, i assume you don't bring a hammer to cut wood
19:19:05 <wayne> even if you really like hammers
19:19:09 <Axman6> russellw: most embedded programming doesn't really have hard real-time constraints anyway
19:19:28 <mm_freak_> wayne: web developers use PHP for web development for many years now…  what's the difference?
19:19:51 <russellw> Axman6, thanks, I'll take a look
19:20:02 <wayne> mm_freak_, php happens to have excellent support for web development.
19:20:29 <Axman6> Ada is probably the most commonly used language for hard RT stuff though (I believe beoing and airbus use it these days)
19:20:36 <mm_freak_> wayne: have you tried a haskell web framework?
19:20:54 <wayne> used snap before
19:21:04 <anomenat> Functional programming seems to use singly-linked lists a lot, is that a true limitation? For example, can you write a good implementation of quicksort in Haskell?
19:21:06 <Axman6> boeing*
19:21:16 <mm_freak_> wayne: PHP totally sucks for web development (or basically any development)
19:21:21 <russellw> Axman6, I would guess Ada is still third after C and C++, yes
19:21:33 <Axman6> anomenat: you can write very clear implementation of "quicksort" in haskell...
19:21:45 <anomenat> Yes, clear, but performant?
19:21:47 <wayne> mm_freak_, i don't think it's that great of a language, but i'd argue against it sucking for web development
19:21:47 <Axman6> russellw: not for safety critical stuff
19:21:48 <ezyang> anomenat: Singly linked lists have a lot of properties that make them good for quick and dirty things involving lists.
19:21:50 <cgroza> anomenat: no
19:21:51 <ski> rwbarton : using `unsafeCoerce#' there wouldn't be safe, you can't rely on the `z1' in `r :: T z1' there being the same type as the `z0' in `g :: z0 -> a'
19:22:09 <ezyang> But Haskell also has more traditional immutable and mutable vector types.
19:22:11 <wayne> because of pear.
19:22:22 <rwbarton> why not?
19:22:25 <russellw> Axman6, C and C++ are very widely used for safety critical stuff. You may be of the opinion that they shouldn't be, but empirically they are
19:22:31 <Axman6> anomenat: lists are used a lot because they're convenient and easy to program with
19:22:40 <mm_freak_> wayne: the only plausible reason to use PHP is that there are many ready-made solutions…  but they only work well, if you never have to write PHP yourself
19:22:41 <scooty-puff> is there a paper that illustrates type inference for recursive generalized let, mutually recursive functions, etc?
19:23:01 <anomenat> russellw: Ada is the most popular language used for fly-by-wire systems in aeronautics
19:23:02 <mm_freak_> wayne: whenever a ready-made solution does not /exactly/ do what you want, you can be sure to get a total mess
19:23:04 <rwbarton> note that I passed in undefined to f originally...
19:23:04 <Axman6> variants of C are pretty common
19:23:25 <mm_freak_> wayne: and haskell has hackage
19:23:33 <cgroza> How does quicksort implemented with the ST monad compare with the C one?
19:23:46 <rwbarton> aren't constructors A[z], if you will, for various types z, non-comparable in the definedness ordering? (I realize I am on shaky ground here)
19:24:18 <ski> rwbarton : hm .. i suppose in your specific case, passing in `undefined', you probably (i'm not sure) could rely on it -- interesting
19:24:29 <Axman6> cgroza: it'll almost certainly be slower, but it could be maybe half as fast, depending on the data used
19:24:41 <rwbarton> yeah, I always find this mfix stuff more mysterious the more I think about it.
19:25:03 <cgroza> Axman6: at least you get the polymorphism.
19:25:06 <ski> anomenat : you can use arrays
19:25:12 <mm_freak_> honestly i'd rewrite an application from scratch before even considering using a PHP solution…  PHP solutions will bite you sooner or later
19:25:19 <Axman6> cgroza: indeed
19:25:29 <Axman6> you can't write a general quicksort in C
19:25:32 <wayne> mm_freak_, that's fine, but the pear library is expansive. you can choose from many different versions of one tool.
19:25:36 <Axman6> so, the comparison is a little moot =)
19:25:56 <rwbarton> @src mapM
19:25:56 <lambdabot> mapM f as = sequence (map f as)
19:25:57 <ski> anomenat : i don't recall whether you can write quicksort nicely with the bulk update operations on immutable arrays, but you can certainly use mutable arrays (e.g. in `ST')
19:25:59 <anomenat> ski: really? OK, I'll hold off on any opinions until I know more about what you can and can't do then :)
19:26:01 <companion_cube> Axman6: why not?
19:26:02 <wayne> PHP code can turn out okay if the OOP is well utilized
19:26:21 <mm_freak_> OOP is just a bad excuse for a missing module system
19:26:22 <cgroza> companion_cube: C does not have polymorphism.
19:26:42 <russellw> PHP isn't the most elegant language design, but it's available everywhere and works perfectly well if used properly
19:26:44 <companion_cube> in C you can still pass a comparison function
19:27:00 <companion_cube> unless you were talking about genericity w.r.t the container itself
19:27:01 <cgroza> companion_cube: yes, but how about the types?
19:27:15 <Axman6> companion_cube: because you can't write a single quicksort function in c that'll sort both an array of ints, and an array of structs with ints, doubles and strings
19:27:31 <companion_cube> ok for this (without macros ^^)
19:27:34 <Axman6> hmm, that is true, but that's really ugly imo
19:27:41 <ski> anomenat : using `ST', you could write a sorting function which took as input an immutable array (or a list, if you prefer), copy it to a temporary mutable array, sort it in-place, then freeze it into an immutable array (or copy out to a list) before returning -- and the type of this function would not involve the `ST' monad
19:27:42 <cgroza> companion_cube: it could work for different types with a cast, only if the 2 types have the same size.
19:27:50 <mm_freak_> wayne: also "versions" in the literal sense?  because cabal-install can do that for you, too, and does it much better
19:28:03 <anomenat> companion_cube: if you care about type-safety and suchlike, then passing a void pointer for the comparison function is undesirable; if you care about performance, then dereferencing that function pointer every time you perform a comparison is undesirable.
19:28:20 <mm_freak_> you can't defend PHP…  there is simply no excuse for using it for new applications
19:28:22 <companion_cube> well for sure if you want type safety then C is a bad choice
19:28:32 <vrook> Axman6: do you know what function pointers are?
19:28:49 <wayne> mm_freak_, yes, php should really have namespaces, and by versions, i meant different implementations
19:28:53 <russellw> mm_freak_, sure I can. I will grant Ruby is more elegant, but PHP works fine
19:28:57 <ski> rwbarton : i think using `unsafeCoerce#' would probably be ok with the current implementation here -- i'm not sure if what you want could be done without using it, though
19:29:07 <rwbarton> ski: what I'm trying to get working now is a version where the "shape" of the nondeterministic computation depends on the values we receive
19:29:09 <vrook> Axman6: just pass in the comparison function and a cast function.
19:29:14 <mm_freak_> wayne: PHP does have namespaces since 5.3
19:29:30 <rwbarton> for example, imagine you don't want the output list to contain the number 3
19:29:39 <Axman6> vrook: that's horrible
19:29:41 <mm_freak_> but following years of PHP tradition they suck just as everything else in the language
19:29:48 <wayne> mm_freak_, i meant the thousands of toplevel functions should be put into them
19:29:54 <companion_cube> vrook: yes, you can do generic sort over arrays of pointers
19:30:03 <cgroza> vrook: you still need to specify the cast function prototype in the quicksort signature.
19:30:14 <rwbarton> so you might define "maybeReturn 3 = mzero; maybeReturn y = return y" and replace "return" by "maybeReturn" in what I wrote
19:30:18 <vrook> Axman6: being horrible is different than not being able to do it.
19:30:24 <mm_freak_> wayne: you can't without breaking lots and lots of applications, and before doing that you should fix them first
19:30:27 <companion_cube> you just give a comparison function which takes a void*
19:30:31 <anomenat> ski: cool. Sounds like Haskell's apparent limitations aren't really that bad, it's just that you have to become a more proficient Haskell programmer before you learn how to get around them. This is not particularly surprising, I suppose. A beginner at imperative programming would have the same issues.
19:30:35 <mm_freak_> 99% of all PHP functions are totally broken
19:31:00 <cgroza> companion_cube: and then do the cast inside? That seems a lot of work just to circumvent the language.
19:31:28 <anomenat> companion_cube: no, you should use C++ templates :)
19:31:34 <ski> rwbarton : the intent of the action `mfix (\x -> do ..x..)' is meant to be in some sense similar to `fix (\mx -> do x <- mx; ..x..)', except that with `mfix', the effects done by `do ..x..' should only be done *once*, instead of infinitely many times
19:31:43 <rwbarton> right
19:31:45 <cgroza> companion_cube: how about the cast function return type? still needs to be specified.
19:32:05 <vrook> companion_cube: I'm not talking about an array of pointers.
19:32:15 <companion_cube> cgroza: no need for a cast function
19:32:30 <companion_cube> bool compare(void *closure, void *a, void *b);
19:32:51 <companion_cube> anomenat: I'm not doing C++ ^^
19:32:59 <cgroza> if that is the case, I would just write that code in C++ using templates and link it in C.
19:33:20 <rwbarton> ski: in effect the issue I ran into is that the shape of the computation must depend on the value of xs, but the value xs only appears at the leaves of the tree (T is basically a tree type, with constructors corresponding to return, mzero, mplus)
19:33:36 <ski> companion_cube : C has higher-order functions (well "functions", since they can't capture a local lexical scope), but no parametric polymorphism. you can simulate parametric polymorphism (as well as existentials) using `(void *)', though
19:33:39 <rwbarton> I added this A constructor to try to push more of the value into the upper levels of the tree, if you see what I mean.
19:34:08 <rwbarton> Maybe what I need is a >>= constructor...
19:34:21 <mm_freak_> really, you simply can't defend PHP…  it's a mistake to write new applications in PHP, and IMO anyone failing to acknowledge that is retarded…  writing a solution in PHP /always/ takes more time, /even/ with ready-made components, will /always/ cost more and will /always/ cause you trouble in the future
19:34:31 <mm_freak_> ok, i'm done with my daily PHP rant =)
19:34:43 <anomenat> ski, mm_freak_ and others: thank you very much for your help, I'm off now, but I have a better idea to investigate Haskell further now.
19:34:56 <anomenat> s/to/how to/
19:35:06 <ski> anomenat : well, if you want both performance and the convenience of higher-order-code, you should look into staged programming
19:35:10 <companion_cube> ski: i know
19:35:35 <companion_cube> I'm writing C right now
19:37:36 <ski> @quote best.imperative.language
19:37:37 <lambdabot> SPJ says: Haskell is the world's best imperative language.
19:37:41 <Axman6> ski: got a link? i've never heard of that
19:37:41 <ski> anomenat : ^ ;)
19:39:41 <ski> Axman6 : well, there's systems like MetaML MetaOCaml, which allows you to generate code at run-time. i think there's also systems that are meant to more resemble C, but i haven't looked in detail at any such. keywords : "staged programming","RTCG (run-time code generation)","partial evaluation","program specialization"
19:39:55 <Axman6> hmm, not sure if i should try this:
19:40:22 <Axman6> apparently read "12e1000000000000" :: Integer produces a segmentation fault in ghc...
19:41:00 <companion_cube> sounds interesting
19:41:19 <ski> Axman6 : e.g., in MetaML, you could write a function  stagedMap  of type  <'a -> 'b> -> <'a list -> 'b list>  meaning that given code for a function converting input elements to output elements, it will generate code for a function converting a list of input elements to a list of output elements
19:41:19 <companion_cube> ski: so it's like having runtime templates, eg?
19:41:45 <rwbarton> does that mean I can make ghc itself segfault by writing 12e1000000000000 in my program source?
19:41:50 <vrook> ski: here's another keyword: lisp
19:41:59 <ski> Axman6 : at least in theory, this generation could use knowledge about the layout of these types, to make the generated function more efficient
19:42:13 <Axman6> ski: is that like specialising map on the input function (or rather, inlining the function into map)?
19:42:20 <ski> vrook : yes, quasi-quotation and macros in Lisps shouldn't be forgotten
19:42:58 <augur> robert harper and louis ck talk alike
19:43:01 <augur> its freaky
19:43:07 <Axman6> > read "12e1000000000000" :: Integer
19:43:08 <augur> its like louis ck is teaching type theory :|
19:43:13 <lambdabot>   mueval: ExitFailure 1
19:43:13 <lambdabot>  mueval: Prelude.undefined
19:43:14 <ski> vrook : however, at least the usual system for quasi-quotation in Lisps doesn't take binders into account (as opposed to MetaML)
19:43:22 <Axman6> huh, how odd
19:43:26 <ski> (.. and MetaOCaml which is more or less the same system)
19:45:08 <ski> vrook : macrology isn't quite the same thing as staged programming in general though (generation at compile-time instead of run-time -- sometimes this doesn't matter, though), but i'd love to see it being more appreciated as well (especially hygienic macros ;)
19:45:47 <ski> companion_cube : well, i can't say i understand templates very well, but that sounds plausible, yes
19:46:35 <ski> (in fact, i suspect Template Haskell could benefit from ideas in hygienic macros)
19:46:47 <vrook> The problem, I think, is that Haskell extensions cannot be written in Haskell because Haskell because types live in a separate universe. So Core code needs to be generated.
19:47:34 <vrook> This is what I realized after my "Haskell needs..." rant.
19:47:48 <ski> vrook : by "extensions", do you mean macros here ?
19:48:11 <ski> (or -- things which would be done using macros in Lisps, at least)
19:48:50 <Axman6> vrook: maybe you should spend more time learning haskell, so you can understand the advantages, rather than asking what they are, and not being able to fully understand the responses you get
19:48:59 <vrook> ski: I mean # LANGUAGE Blah stuff.
19:49:23 <ski> Axman6 : well, it's sensible to try to figure out whether there's any gains, wrt one's goals
19:49:36 <Axman6> sure
19:50:13 <vrook> ski: Maybe I'm wrong. Can all extensions be written with Template Haskell?
19:50:24 <vrook> It seems not, since you have more to check on types.
19:50:32 <rwbarton> how would you implement GADTs with TH?
19:50:33 <Axman6> vrook: many extensions ads new syntax, so no
19:50:41 <Axman6> add*
19:50:57 <vrook> My point is, even if you had macros, it would not be enough.
19:51:08 <vrook> You still need to do the logic of the types.
19:51:45 <ski> vrook : many of the extensions affect how the static type system works -- in some cases you could probably do something similar with TH, together with a bit of introspection in the compiler
19:51:56 <rwbarton> things like DeriveFunctor you can essentially implement with TH (and the TH implementation has been around for a long time, long before DeriveFunctor was added to GHC)
19:51:59 <ski> (i'm thinking about things like `DeriveFunctor')
19:54:51 <Axman6> vrook: this is the price we pay for having type safe programs i think
19:55:00 * ski wonders which message(s) vrook referred to by "Haskell needs..."
19:55:38 <vrook> I still suspect that a combination of TH and some type checking functions would be sufficient to make any extension.
19:55:58 <rwbarton> multiparameter type classes?
19:56:26 <ski> rwbarton : if you could extend the type system programmatially, that might work
19:56:34 <rwbarton> it would be very interesting to see such a system
19:56:38 <Axman6> "some type checking fuunction" would have to be able to figure out what your extensions mean for all other code
19:56:39 * ski nods
19:57:23 <augur> ski!
19:57:38 <vrook> There is an analogy here. It's a high-level one and I'm not sure I can explain it.
19:57:51 <ski> (one basic problem with extending the type system is that properties which the programmer and implementation relies on for reasoning may in some cases be broken, when the type system is extended -- it's not clear how to avoid this)
19:57:58 <ski> augur?
19:58:47 <augur> hey. :p
19:59:03 <ski> a programmingn language consists of two main things : (a) the things you can *do* in it, its expressiveness; (b) the properties you can *rely* on in it, its "reasonability"
19:59:27 <vrook> Haskell goes through great lengths to separate side-effect, to make everything clean and composable. It's all boxed in and consistent. Lisp is exactly the same but in regard to a different sphere. Syntax is composable in Lisp, but not in Haskell. Side-effects are cleanly composable in Haskell, but not in Lisp.
19:59:39 <ski> you use (b) all the time, when reading code, when refactoring code, when debugging code, when writing code
19:59:57 <ski> but often you don't think about needing (b)
20:00:22 <vrook> So in Haskell, an extension has to pervade everything and check other extensions to make sure everything works. Extensions aren't composable by default.
20:00:37 * companion_cube thinks that many programmers are proud to be able to write code with languages that have little (b)
20:01:13 <ski> when you extend a programming language, you sometimes just want a nicer way to do something, and you sometimes actually extend (a), and as a result, (b) often diminishes
20:01:33 <companion_cube> e.g. perl :)
20:02:15 * monochrom too thinks that many programmers are too proud and too self-conceived-to-be-smart to accept (b), especially inspired by and aspiring to those really smart enough for it.
20:02:20 <vrook> ski: But you realize that's just an artifact of Haskell. You can have a composable type system -- there is some language in which types can be expressed, so just generate code for that language.
20:03:05 <monochrom> there is really a big difference between Ritchie writing assembly code and you writing assembly code. do not think that you can duplicate the success.
20:03:08 <ski> (the converse is often true too, by restricting a language (or library api), we can sometimes extend its "reasonability" -- cf. monads vs. applicative functors -- or old-style network databases vs. the relational model (though SQL is unfortunately a very ugly surface syntax))
20:03:38 <rwbarton> The extent to which your language has implicit conversions/coercions is another (a) vs. (b) tradeoff
20:03:40 <monochrom> and so for example everything Ritchie says about how power and freedom helps him does not apply to you, emphatically.
20:03:59 <Axman6> where's Cale and conal when we need them
20:04:27 <monochrom> anyway if you're so power-hungry, you should go straight to FPGA instead. screw software.
20:04:39 <companion_cube> FPGA can do recursion?
20:04:55 <Axman6> companion_cube: somewhat
20:05:09 <Cale> wat
20:05:22 <monochrom> dunno. certainly lower level and more freedom. perhaps you will be proud of doing your own trampolining by hand --- in hardware!
20:05:22 <ski> vrook : hm .. assume you define a DSL (not EDSL) in CL, using macros -- how easy is it to to make macros that expand to DSL forms ?
20:06:01 <monochrom> (certainly beats "oleg does trampolining by hand --- at the type level!)
20:06:19 <ski> vrook : one simple example would be a pattern language for a pattern-matching form -- another would be a loop specification language for a general looping form (i'm sure you can imagine more DSLs)
20:06:44 <companion_cube> can oleg write a type level prolog?
20:06:58 <stepcut> I thought the type level already was a prolog
20:08:02 <vrook> ski: I don't understand. DSL and EDSLs are macros that expand to code, not the other way around.
20:08:47 <vrook> But sure, you can have a macro that expands to a DSL which expands to code.
20:09:29 <augur> oh man and their mannerisms are similar too D:
20:10:22 <ski> vrook : assume i define a macro  match  so that i can write the following form :  (match (blah) (nil (on-empty)) ((cons elem list) (on-non-empty elem list)))
20:12:18 <ski> vrook : can i then define a macro  list  so that writing  (match (blah) ((list a b c) ..a..b..c..) ...)  amounts to the same as  (match (blah) ((cons a (cons b (cons c nil))) ..a..b..c..) ...)  ?
20:13:11 <ski> vrook : note that i want to define this `list' macro, not in terms of the expansion of pattern in normal lisp code, but in terms of this pattern language
20:13:21 <Saizan> stepcut: not enough backtracking
20:15:30 <ski> vrook : or take <http://www.lispworks.com/documentation/HyperSpec/Body/m_loop.htm>, i want to be able to define macros that amount to new kinds of clauses in the `loop' macro -- how can i do that ?
20:16:24 <vrook> ski: I think you're just asking if symbol-macrolet exists, which it does. It's a lexical macro. So yes, you can extend LOOP with a symbol-macrolet.
20:17:14 <ski> vrook : in Taylor Campbell's <http://mumble.net/~campbell/scheme/foof-loop.txt> looping macro, i can define custom iterators, but not in terms of other iterators
20:20:45 <vrook> ski: that's scheme, so I can't comment on its macro clusterfuck. I do know that in Lisp it would be easy to pass the body to a symbol-macrolet which would transform and send it to the outer macro.
20:20:55 <ski> vrook : my point is that, given a macro `foo' i'd like to have the subform `(bar ...)' in a form `(foo ... (bar ...) ...)' to expand *before* `foo' sees that subform -- `foo' shouldn't have to be aware that i have defined a macro `bar' to be able to expression some of the things passed to `foo' in a more concise way
20:21:27 <ski> s/like to have/like to have the ability of having/
20:22:15 <vrook> ski: you described just what I said -- pass the forms to an inner symbol-macrolet. done.
20:22:56 <vrook> .. or macrolet (dunno why I started saying symbol-macrolet only)
20:24:33 <ski> afaiu, `macrolet' is basically the same as `let-syntax' in Scheme, which is not what i want
20:25:38 <vrook> ski: the macrolet definition disappears after expansion; it's replaced by the thing that you want.
20:26:29 <ski> let's assume  (defmacro foo (form) "foo" `',form)
20:26:29 <vrook> I'll try to make a simple example.
20:27:32 <ski> what will  (macrolet ((bar () ''zot)) (foo (bar)))  evaluate to (or even expand to) ?
20:27:45 <vrook> Keep in mind that to extend foo you have to redefine it -- which is no big deal because macros are read-time only anyway.
20:28:19 <ski> i don't want to refefine `foo' here at all. assume `foo' is written by a third party
20:31:36 <vrook> I'm confused. I thought you wanted to extend foo?
20:32:31 <vrook> The writer of foo can add hooks to extend the way you want. If not, you can extend it on your own by redefining it.
20:32:53 <vrook> The package system allows you to shadow the old definition with your new shiny foo.
20:33:04 <rwbarton> if foo was built-in syntax, though, there'd be nothing stopping him from what he wants to do
20:33:26 <rwbarton> (I think?)
20:33:33 <ski> no, i wanted to be able to extend the DSL language of the sub-forms that `foo' accept, by making macros in that language, that expand to existing valid sub-forms -- and i should be able to do this without having to modify `foo' at all -- `foo' should ideally not have to be aware that there's some user-defined macros expanding it's argument forms before it gets its hands on it
20:33:39 <vrook> So you won't be able to tell the difference between extending foo one way or the other.
20:34:58 <ski> vrook : yeah, but if i extend `foo' itself, and my neighbour extend it as well, and someone down the block tries to use libraries for both of us, those two extensions are probably not compatible with each other without some nontrivial work
20:35:09 <vrook> ski: I'm not talking about modifying foo.
20:35:16 <ski> s/libraries for/libraries from/
20:35:31 <ski> "you can extend it on your own by redefining it"
20:35:40 <vrook> I'm talking about shadowing the old definition. The old one stays -- you don't touch it.
20:35:54 <ski> "The writer of foo can add hooks to extend the way you want." is good, but the writer of `foo' shouldn't have to think of that
20:35:56 <vrook> In your package, you write a foo which calls the old foo.
20:36:14 <vrook> That's why I said the second technique.
20:36:36 <ski> also, the writer of `foo' might not be able to make that hook API as simple as the existing way to extend the Lisp language with macros, in the normal way
20:37:19 <ski> vrook : yeah, but shadowing doesn't work if someone wants to use two different extensions in the same piece of code
20:38:03 <ski> vrook : don't get me wrong, i think it's great that we have macros at all -- i'm just saying that it would be even greater if we could sensibly define macros for DSL languages as well, in a composable way
20:38:16 <vrook> OK let's forget about the writer making hooks. I only mentioned that to contrast with shadowing, which is what you want to do.
20:39:07 <ski> if you can make the sub-language a EDSL, then there's no problem, it's really just another Lisp macro
20:39:15 <vrook> I don't follow "two different extensions in the same piece of code". There can only be one foo in any piece of code.
20:39:34 <ski> the problem is if we have a proper (non-embedded) DSL
20:39:46 <ski> vrook : exactly
20:41:13 <ski> vrook : say you extend `loop' with a new kind of clause, and someone else also extends `loop' with another new kind of clause. then the next person should ideally be able to import and use both these new (independent) extensions to `loop', without further ado
20:42:03 <ski> of course, if these extensions are deemed common enough and useful enough, they should possibly eventually be incorporated in the "main" `loop' implementation
20:42:09 <ski> but one shouldn't have to wait for that
20:42:30 <ski> (or for someone to understand the implementation of both extensions, and merge them)
20:43:47 <vrook> ski: what if two people write conflicting extensions, using the same keywords but doing different things? You're going to run into non-composability in any case, it's not a problem caused by this technique.
20:44:08 <rwbarton> "what if two people write functions with the same name?"
20:44:42 <ski> vrook : this should in many cases be no different than if two normal lisp macros happen to use the same name -- you rename one or both of them on import
20:45:08 <ski> (or use some kind of module/package/whatever qualifier)
20:45:43 <vrook> ski: you don't have to do either. That's what shadowing is fore.
20:45:44 <vrook> *for.
20:46:06 <vrook> but yes, you must choose one or none.
20:46:08 <ski> if i use shadowing, i can only use one extension at a time, if i don't manually merge them
20:46:44 <vrook> oh sorry, I missed "at the same time"
20:47:37 <ski> however, i agree that for some macro designs, it would be much harder to have extensible sub-clauses for the macro
20:47:49 <vrook> but we can solve that too: (compose-extension 'foo 'ski-foo-extension 'vrook-foo-extension)
20:48:12 <ski> e.g. instead of  (loop as n = (progn (format t "~&Number: ") while n do (format t "~&The square of ~D is ~D.~%" n (* n n))))
20:48:29 <ski> (loop (as n = (progn (format t "~&Number: ")) (while n) (do (format t "~&The square of ~D is ~D.~%" n (* n n)))))  would be much better
20:48:58 <ski> then `as', `while' and `do' here are "primitive forms" in this mini-language of `loop'-clauses
20:50:16 <vrook> ski: the extension that each person writes would not be called foo -- it would be called vrook-foo and ski-foo. The actual foo is the composition. Does that help?
20:51:20 <ski> so the general syntax would be something like  (loop {<loop-clause>}+)  and then defining macros for this DSL would just extend the  <loop-clause>  language  -- so every time there's a form  (shiny blah ...)  there, if `shiny' is a `loop'-clause macro, that would get to expand before `loop' itself was expanded
20:53:08 <vrook> ski: that can be done, too. Loop would be defined like this: (define-extension loop ...). And then additions are done (with-extensions (blah ..) (foo ...)).
20:53:17 <ski> vrook : well, if there would be some principled general way in which to combine `wrook-foo' and `ski-foo' into `wrook&ski-foo', then yes, that would help
20:53:38 <monochrom> extensions again?
20:53:42 <rwbarton> if "foo" is a macro and I write (cond (foo x y z) ...) does (foo x y z) expand or is "foo" used as the condition?
20:53:53 <ski> but it really needs to be simple to get this, otherwise people will forget to enable `foo' to be extended in this way
20:54:21 <vrook> ski: The with-extensions macro writes to a private list what is defined, and that is passed secretly to foo for use in its expansion.
20:54:25 <ski> (in short, i want this to be the default, `foo' shouldn't have to do anything special to enable this)
20:55:03 <ski> monochrom : composable macros
20:55:23 <vrook> ski: that's not normally how people want macros to work. But you can make them work as you want by following the secret-list technique I described.
20:55:36 * hackagebot abstract-deque 0.1.1 - Abstract, parameterized interface to mutable Deques.  http://hackage.haskell.org/package/abstract-deque-0.1.1 (RyanNewton)
20:56:26 <ski> rwbarton : afaik, in all present lisp macro systems, `cond' will get to expand first before `foo' gets a chance to expand (in case `cond' lets it)
20:56:46 <rwbarton> oh cond is a macro
20:56:47 <vrook> ski: Since people expect macros to work a certain way, it's not difficult to understand that something else is need to get the "reverse expansion" you want.
20:56:52 <ski> however, i'm mostly familiar with Scheme, so i might be wrong here
20:56:52 <rwbarton> what's something that isn't a macro
20:56:59 <rwbarton> if?
20:57:04 <kniu> hey guys
20:57:26 <ski> rwbarton : at least in Schem, either of `if' and `cond' might be macros, one defined in terms of the other
20:57:44 <kniu> just a random question, regarding the code posted here: http://www.rust-lang.org/doc/tutorial/intro.html
20:57:56 <rwbarton> okay, let's assume 'if' is not a macro
20:58:02 <rwbarton> oh hmm
20:58:13 <rwbarton> maybe I can't make any interesting examples with if
20:58:18 <kniu> how do you feel about the fn <ident>[args] -> <return type> {<body>} syntax for function definitions?
20:58:26 <vrook> In short, it's not actually a problem that macros expand inner-to-outer because that's the hygenic, sane way to do things. If you want outer-to-inner expansion, you can set that up, but it's obviously crazy to think that should be the default.
20:58:41 <kniu> considering that they're using (fn<domain> -> <codomain>) as the syntax for function types?
20:58:42 <ski> rwbarton : the other being a primitive syntax -- but it doesn't really matter (or it *shouldn't* matter) which are primitive syntax and which are defined macros -- it's the same kind of distinction whether `addInt :: Int -> Int -> Int' is written in Haskell or provided by the run-time system -- i.e. for most purposes it doesn't matter in practice
20:59:08 <rwbarton> okay so even if cond is built-in syntax, then foo will not expand as a macro in my example
21:00:19 <BMeph> kniu: where you have 'args' are the argument types, right?
21:00:37 <ski> rwbarton : `(foo x y z)' there will expand iff `cond' (eventually) expands to code which either is directly `(foo x y z)', or expands to a primitive form with `(foo x y z)' occuring in an "arbitrary expression" sub-form
21:01:17 <rwbarton> right, but in fact cond will examine (foo x y z) and see that it is the wrong length, right?
21:01:23 <rwbarton> I mean in the specific case of cond
21:01:31 * BMeph looks at the link
21:01:38 <rwbarton> I just find the outer-to-inner expansion of macros pretty baffling
21:02:02 <rwbarton> but maybe it's because I've been primed by your use case
21:02:08 <BMeph> kniu: Ah - name and type. not bad, kind of ML-ish. :)
21:02:28 <vrook> ski: Do you understand my point? Do you see why inner-to-outer expansion is the sane, hygenic default? And how you could rig outer-to-inner expansion if you wanted to?
21:03:27 <kniu> BMeph, well
21:03:29 <kniu> not quite ML-ish
21:04:02 <kniu> my beef is that it uses the "fn ... -> ..." syntax in two different ways to mean two different, but related things
21:04:23 <ski> vrook : hm, do you have a reference for some kind of docs or info `compose-extension',`define-extension',`with-extensions' ? -- HyperSpec doesn't seem to have it
21:04:38 <kniu> in one place it's built-in syntax for a definition, whereas in another it is a type constructor
21:04:48 <kniu> seems... off
21:05:04 <ski> vrook : btw, the name `with-extensions' suggests to me that this may have an ingredient of dynamic scope^Wextend -- is that so ?
21:05:20 <ski> (sigh s/extend/extent/)
21:05:36 <Saizan> rwbarton, ski: does it change anything if foo in (foo x y z) is not a macro?
21:06:48 <rwbarton> if foo is not a macro then (cond (foo x y z) ...) is the same as, uh, (progn x y z) if foo is true, and the same as (cond ...) if foo is false, I think
21:07:09 <ski> rwbarton : well, i think  (cond (foo x y z))  (assuming `foo' is *not* a macro, here) is the same as  (cond (foo (begin x y z)))
21:07:30 <rwbarton> yeah, I saw that actually cond doesn't care how long its clauses are
21:07:39 <vrook> ski: They are trivial macros to write. "Dynamic scope" doesn't really have meaning for a macro-defining-macro, since the scope only exists during read-time.
21:08:38 <vrook> ski: I'll make an example, hang on.
21:08:42 <ski> vrook : re inner-vs-outer and outer-vs-inner, i would describe what i want (in a controlled fashion) as "inner-to-outer", while the traditional lisp macros has been "outer-to-inner" : in  (foo (bar ...) ...)  the macro `foo' will always be called first (so outer-to-inner)
21:09:21 <ski> vrook : i agree that doing inner-to-outer in a non-controlled fashion would probably be bad
21:10:03 <ski> vrook : i want a way to separate the specification of what shape the sub-forms of a macro form must have from the actual implementation of the macro (the expansion)
21:10:21 <vrook> I call the default inner-to-outer because that's how all expressions are evaluated in all languages I can think of. The same applies to macros. bar expanded first, foo is expanded next.
21:10:51 <vrook> you want foo to infect bar, doing things to bar before it is expanded.
21:11:20 <ski> vrook : that way, one could first check the shape of the sub-forms, determining which sub-forms are lisp expressions, and which are expressions for any other DSL one wants to use -- then macros for each of those languages would get a chance to expand before the whole macro does any expansion
21:11:38 <vhd> hi could anyone have a look at my question/problem, http://pastebin.com/cAmJMkh4
21:11:41 <mauke> The paste cAmJMkh4 has been copied to http://hpaste.org/55039
21:13:17 <mzero> vhd: you must have a problem with indenting - perhaps mixed spaces and tabs?
21:13:46 <vhd> hmm ok I will check that.
21:14:24 <mzero> look at the error on line 25 (in your paste) --- GHC sees  line 17 and 16 as one expression
21:14:27 <mzero> incidentally
21:14:55 <vhd> yeah thats the problem, but I cant work out why it is doing that
21:15:15 <vhd> ha! it was something to do with indenting.
21:15:17 <vhd> odd.
21:15:26 <vhd> but thank you very much, wasted whole day on this.
21:15:37 <mzero> how about   changeImage i e =  when ((QEvent.eventButton e) == QEvent.LeftButton) (swap i) >> return (QEvent.eventSent e)
21:16:20 <ski> vrook : well, Racket (formerly PLT Scheme) has a concept of "syntax parameters" which really is a dynamic scope that only exists during macro-expand-time -- see <http://blog.racket-lang.org/2008/02/dirty-looking-hygiene.html> for a simple example of using it (if you want more, there's a paper <http://scheme2011.ucombinator.org/papers/Barzilay2011.pdf>)
21:16:20 <mzero> vhd - take the time to find the setting in your editor that causes it to never use tabs
21:16:48 <vhd> yes I think it is because I was jumping between emacs and gedit
21:17:32 * vhd is so glad it works, finally.
21:18:05 <mzero> vhd: consider this version: http://pastebin.com/bsU26Qwy
21:18:08 <mauke> The paste bsU26Qwy has been copied to http://hpaste.org/55040
21:18:14 <mzero> I think that expresses your code's intent more clearly
21:18:51 <vhd> :o "when" have never seen that before
21:19:42 <mzero> Control.Monad
21:19:45 <mzero> :t when
21:19:46 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
21:22:41 <ski> rwbarton : yeah, so `cond' isn't really a good example here
21:22:56 <DanBurton> when is basically the imperative one-branch version of "if"
21:23:04 <ski> Saizan : in case `foo' is not a macro, then there's no problem to begin with that we'd like solved
21:23:49 <vrook> ski: My only point was that "dynamic scope" does not usually refer to things like syntax parameters or (in lisp) compile-time specials.
21:23:59 <mzero> ponders: "... inner-to-outer because that's how all expressions are evaluated in all languages I can think of ..."   and thinks of several popular counter examples
21:24:07 <ski> vrook : no, macros in lisps are traditionally expanded outer-to-inner, as opposed to how procedure calls are evaluated in lisps and most other languages
21:24:41 <ski> i.e. how macros expand are more similar to how Haskell code executes :)
21:25:04 <ski> (though there's no automatic sharing of results, like with call-by-need)
21:25:11 <ski> rwbarton : re "outer-to-inner expansion of macros" : macros in lisps traditionally simply evaluate using call-by-name, instead of call-by-value
21:25:34 * mzero doesn't even know where to begin with that!
21:26:29 <ski> i actually now notice that the great Oleg has pondered this topic a bit : "Applicative syntax-rules: macros that compose better" by Oleg Kiselyov in 2009-03 - 2011-04 at <http://okmij.org/ftp/Scheme/macros.html#ck-macros>
21:27:46 <ski> however, it appears that his solution (if indeed it would apply to the present problem) requires the macro writer of `foo' to write the macro in a specific style, a bit like manually using CPS, instead of being able to use `call-with-current-continuation' when you need control effects
21:28:05 <mzero> http://blog.tmorris.net/20-intermediate-haskell-exercises/ -- was a bit o' fun -- especially by hiding as much of the Prelude as I could!
21:28:34 <anomenat> Suppose I want to sort an array of ints that's not enormous but fairly large, say, 400 MB. What types/functions can I use in Haskell to read this data into memory, operate on it, then write it back to disk in a storage-efficient manner? My sorting functions currently have the type [a] -> [a], but as soon as I unpack from ByteString to [Word8] my memory usage explodes and I run out of main memory.
21:28:35 <ski> vrook : "you want foo to infect bar, doing things to bar before it is expanded." -- in  (foo (bar))  i want the opposite, i want `bar' to expand before `foo'
21:29:06 <ski> (vrook : re "My only point" -- ok, no worries)
21:29:17 <mzero> anomenat: I think you want Vector
21:30:43 <anomenat> http://haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial
21:30:47 <anomenat> mzero: is that the one?
21:31:07 <mzero> yup
21:31:11 <anomenat> mzero: thanks
21:31:50 <mzero> if you are really manipulating Word8 -
21:31:55 <ddarius> @hackage vector-allgorithms
21:31:56 <lambdabot> http://hackage.haskell.org/package/vector-allgorithms
21:32:01 <ddarius> @hackage vector-algorithms
21:32:02 <lambdabot> http://hackage.haskell.org/package/vector-algorithms
21:32:14 <mzero> you will want Unboxed --- or possibly ByteString in some cases
21:32:25 <kulin> Are there any sites that describe patterns for haskell development? I find myself commonly dividing my program into a modules that have a container type that contains any necessary state that then gets passed to each function in that module for stateful programs, but I wonder if there are better alternatives.
21:32:37 <mzero> what is the data? encoded text? data samples?
21:32:41 <copumpkin> so, I have an enumerator/iteratee question
21:32:45 <copumpkin> kfish might know
21:32:49 <rwbarton> if you are really sorting a bunch of Word8's in a ByteString there is a counting sort included in Data.ByteString
21:32:54 <copumpkin> I'd like to hide a shitty connection from myself
21:33:01 <rwbarton> I assume you meant Word32 or something like that though
21:33:59 <anomenat> rwbarton: actually, I don't really mind whether it's Word32 or Word8 - I'm just implementing my own sorting functions as a starting point for learning Haskell.
21:34:17 <rwbarton> oh, ok
21:34:22 <copumpkin> I want to make an enumerator of things that connects to a socket, performs some handshaking, and then keeps reading indefinitely, spitting out frames it parses out of the stream. If the connection dies in any way, I want the thing to transparently restart and keep spitting shit out as if nothing had ever happened
21:34:30 <copumpkin> is there a nice way to do that?
21:35:39 <ddarius> copumpkin: You should just be able to write an enumerator that does that.
21:36:30 <copumpkin> I suppose I'll need a bracket to catch the broken connection?
21:36:40 <kfish> copumpkin, talk to m3ga (who appears to be offline atm)
21:36:48 <kfish> he recently uploaded http-proxy
21:36:53 <JoeyA> Can a GHC rewrite rule have a lambda abstraction in it?
21:37:02 <ddarius> copumpkin: Yes, it would be like a normal file enumerator, for example, except instead of reporting the error, you'd just catch the error, restart, and resume.
21:37:22 <ddarius> JoeyA: You can try it and find out.
21:38:06 <copumpkin> ddarius: okay, I'll give it a go. Is just catching an exception the established way of noticing when your connection dies, or is there a more idiomatic way? I'm not used to doing network code
21:38:15 <kfish> copumpkin, http://hackage.haskell.org/package/http-proxy
21:38:15 <copumpkin> kfish: will do
21:38:50 <ddarius> copumpkin: If the underlying code doesn't already handle timeouts for you, you may need to add those, but otherwise, yes.
21:38:51 <kfish> copumpkin, the iteratee library uses exceptions for any kind of out-of-band signalling
21:43:40 <vrook> ski: there's an ambiguity of terms here. I've been talking about using macrolets, and you posted a macrolet example (macrolet ((bar () 'zot)) (foo (bar))). This produces '(bar) because the inner foo is expanded first. The bar has no chance to infect foo.
21:45:00 <vrook> The technique to which I'm referring is layering macrolets, and like all terms everywhere it's inner to outer.
21:47:01 <ski> vrook : i would say `bar' is inner wrt `foo', here
21:47:39 <ski> (where `bar' itself is define i don't care about, possibly a `defmacro', possibly a `macrolet')
21:50:42 <vrook> I see your point, but I guess I don't think of it that way because foo is totally blind to what bar is. It just expands. That (bar) appears there is kind of irrelevant. foo expands, then bar expands, with the latter doing nothing.
21:51:56 <lewis1711> can anyone recommend a resource for making data structures raphs other than binary trees? assuming "graphs" is even the right term
21:52:06 <lewis1711> that first raphs should be graphs
21:52:17 <vrook> In other words, I callously disregard the input to a macro because I know it can have basically nothing to do with the output of a macro.
21:52:22 <mzero> are you asking about functional data structures?
21:52:28 <mzero> data structures in general?
21:52:35 <mzero> or perhaps graphs in general?
21:53:05 <mzero> or do you mean graphic images of same?
21:53:17 <lewis1711> I mean graphs as in the sense of things with nodes and vertices
21:53:24 <ddarius> vrook makes no sense.
21:55:16 <mzero> in general: http://en.wikipedia.org/wiki/Graph_(data_structure)  -- in functional languages: http://en.wikipedia.org/wiki/Purely_functional (see external links on that page to papers)
21:55:43 <ski> vrook : yes, but if `foo' is checking the sub-form for being of one of the forms `(frob expr ...)', `(zot identifier expr)', matching literally on the symbols `frob' and `zot', then it will be confused when it sees a `bar' symbol instead
21:56:31 <ski> e.g. `loop' looks for literal occurances of `while',`as',`=',&c.
21:57:20 <ddarius> I know I commonly pass parameters to functions and macros because I know they will have no effect on the output.
21:57:26 <lewis1711> can all graphs be done as a recursive data structure? and to make sure I'm not using the wrong terms "data Tree = Leaf | Branch Tree Tree" is a recursive data structure right?
21:57:27 <ski> vrook : i agree that in many cases `foo' will just ignore whatever is in a certain subform, just arranging to place it in an expression-position in the generated code -- however, this is not always the case
21:58:09 <mzero> lewis1711: other than trivial graphs, yes - I'm pretty certain that they are all recursive data structures
21:58:51 <ddarius> type Graph v = (v,v) -> Bool
21:59:50 <mzero> I'm sorry - I left out lewis1711's "can" - yes, the "can all be recursive data structures"
22:00:35 * hackagebot acme-realworld 0.1 - Primitives for manipulating the state of the universe  http://hackage.haskell.org/package/acme-realworld-0.1 (JoeyAdams)
22:02:53 <lewis1711> I see.
22:11:06 <byorgey> haha acme-realworld =)
22:11:58 <edwardk> hah
22:12:41 <ddarius> Yes, it will be useful for those insisting that World-passing is a reasonable way to represent the semantics of IO.
22:14:03 * DanBurton wonders how well acme-realworld actually works.
22:14:19 <byorgey> "Set the current state of the universe.  Program values are not affected by this operation, but the rest of the universe is."
22:15:37 <edwardk> DanBurton: i don't recommend wiring it up to actual missiles
22:15:52 <ski> vrook : anyway, i'm not claiming a majority of macros would suffer from the problem i've been trying to express. i'm just saying that i think there's room to improve the state of affairs, and that i think one would want this kind of thing for really composable macros
22:15:55 <vrook> ski: bar has no opportunity to manipulate what's inside the foo form; it can only manipulate the result of the foo expansion. I agree that outer-to-inner is a better description, but somehow it feels like inner-to-outer. I have no idea why.
22:17:34 <ski> vrook : *nod*, i would like `bar' to have that opportunity, by some kind of pre-scan which determines that the `bar' call occurs in an "expression position" (or "pattern position", or whatever DSL you like) within for whole `foo' form, so that it could expand before the proper `foo' expansion begins
22:19:07 <ski> vrook : i suppose one way to express this is that i think we need a kind of "statical typing" for macros -- and by that i don't mean that we should need to add a statical type system in the normal sense, only that the analysis of which sub-forms belong to which "language" would need to be static
22:19:39 <ski> vrook : at least, that's the only way i've been able to come up with, to get this. there might be other solutions as well, though
22:21:23 <ski> vrook : e.g., the "type" of the `cond' macro should basically specify that the correct application of it is like `(cond {<expression> <expression> ...)}+)'
22:22:04 <ski> and the "type" of a `match' macro should specify that the correct application looks like `(match <expression> (<pattern> <expression> ...)+)'
22:22:08 <ski> &c.
22:22:43 <rfm47> i'm trying to install snap via cabal, and base16-bytestring is failing...
22:22:53 <vrook> ski: actually I think Shen does all of that. Its macros are all matching-based.
22:23:19 <hpaste> rfm47 pasted “base16-bytestring failure” at http://hpaste.org/55041
22:23:39 <ski> this would allow the `bar' macro call in `(match ((bar blah) ...))' to expand before `match' itself expands
22:24:00 <ski> so that `bar' can expand to pattern forms known to `match', without `match' having to know about `bar'
22:24:04 <mightybyte_> rfm47: What version of GHC are you using?
22:24:30 <edwardk> ski: have you seen dave herman's work on types for alpha renaming in macro systems?
22:24:47 <ski> edwardk : i'm not sure
22:25:01 <ski> vrook : what is Shen ?
22:25:09 <rfm47> 6.12.2
22:25:13 <rfm47> sorry, .3
22:25:26 <vrook>  http://www.shenlanguage.org/
22:25:27 <ski> vrook : anyway, i'm starting to get too tired to think now though, so we'll have to continue another time ..
22:25:32 <ski> vrook : ty
22:25:36 * hackagebot IORefCAS 0.1.0.1 - Atomic compare and swap for IORefs and STRefs.  http://hackage.haskell.org/package/IORefCAS-0.1.0.1 (RyanNewton)
22:25:53 <vrook> ski: ok I'll cook up an extender macro example in the meantime.
22:26:29 <AfC> vrook: I think you need >= 7.0 for snap to install; not snap's fault, but things in the dependency chain are broken on GHC 6.12 (I gather some of them have been fixed). That said,
22:26:45 <ski> edwardk : "A Theory of Typed Hygienic Macros" <http://www.ccs.neu.edu/home/dherman/research/papers/dissertation.pdf> ?
22:27:00 <edwardk> yeah
22:27:01 <AfC> vrook: try installing snap-server and snap-core; they might build fine. I never use the snap package's `snap` executable anyway.
22:27:08 <ski> edwardk : ty
22:27:49 <edwardk> it struck me as a really good ideal that is just missing a nice syntax ;)
22:28:15 <edwardk> only problem is prying him away from mozilla/javascript long enough to talk to him about it
22:28:28 <ski> heh
22:28:34 <rfm47> AfC, thanks
22:28:59 <rfm47> nope, snap-server and snap-core depend on it too.
22:29:11 * ski -> ContT Death Mumble Sleep
22:29:31 <mightybyte_> rfm47: Snap should work, with 6.12.3, but like AfC said, this appears to be base16-bytestring's fault.  You might email bos about it if upgrading to GHC 7 is hard for you.
22:29:33 <edwardk> go sleep. =)
22:30:08 <rfm47> mightybyte_, I'm sure I can figure it out, just a slight pain on ubuntu
22:31:22 <AfC> rfm47: Ubuntu Oneiric is shipping GHC 7.0.3; if you're on Natty or Lucid there are packages available via PPA. Shouldn't be a problem.
22:32:06 <mightybyte_> rfm47: Try "cabal install snap —constraint='base16-bytestring<0.1.1.3'"
22:33:34 <rfm47> heh, that em-dash tripped me up briefly.  thanks though, that did seem to get past it
22:33:55 <mightybyte_> Oh, it looks like he's fixed it in head too.  https://github.com/bos/base16-bytestring/commit/83d42a09eb90c8a5c47d6c41b8d2845f16c239f7
22:34:35 <mightybyte_> So you might be able to download the latest from github and install that manually.
22:35:10 <rfm47> thanks.  snap built fine with that constraint, so i think i'm ok for now.  though i'll upgrade to oneiric soon, anyway.
22:35:22 <JoeyA> "* DanBurton wonders how well acme-realworld actually works." In the example show, launchMissiles actually takes effect.  However, with -O2, invoking the getWorld/launchMissiles/putWorld sequence multiple times in a row seems to result in only one call to launchMissiles.
22:35:31 <vhd> how can you apply a function which maps to each value in a list but the function returns IO ()?
22:35:56 <JoeyA> :t mapM_
22:35:56 <ddarius> Yay, CAS.
22:35:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
22:36:13 <vhd> thank you JoeyA
22:36:33 <JoeyA> e.g. mapM_ print [1..100]
22:37:14 <mzero> vhd: what prompted you to ask that? GHC warning message?
22:38:03 <vhd> mzero, no, I was trying to use map, but was getting errors and I knew it was because I was not returning a list but doing action
22:40:14 <mzero> ah - see two different issues here.... one:   you *can* map with something that produces an IO action:    map print [1..100] is perfectly fine --- only it returns [IO ()] - that is, a list of IO actions --- if you want a single action that is those actions in sequence, then      sequence $ map print [1..100]     ---- however, this is called mapM  --- so    mapM print [1..100]
22:40:35 * hackagebot http-enumerator 0.7.2 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.7.2 (MichaelSnoyman)
22:40:43 <mzero> NOW that has the downside that it returns an action with a list of the results
22:40:50 <mzero> :t mapM print [1..100]
22:40:51 <lambdabot> IO [()]
22:41:20 <mzero> who wants a list of ()s?    GHC will complain about such things, given the right flags
22:41:38 <mzero> in that case, you want    mapM_   which discards the results
22:41:38 <vhd> I see, that was very helpful
22:41:51 <mzero> ... there is also sequence_
22:42:52 <mzero> it's good to know, because you do all sorts of things once you get the hang that you can mange lists and other data structures... of IO actions! then use tools like sequence and mapM to string them together
22:43:23 <mzero> imagine building a   Map String (IO ())    and then using lookups to select items to do
22:43:25 <ddarius> Just wait until you realize you can have IO actions that return IO actions.
22:44:46 <mzero> and with all that, I'm off to bed
22:44:56 <vhd> thanks :)
22:45:04 <NemesisD> anyone at all familiar with the mysql package?
22:45:36 * hackagebot zoom-cache 0.9.0.0 - A streamable, seekable, zoomable cache file format  http://hackage.haskell.org/package/zoom-cache-0.9.0.0 (ConradParker)
22:45:59 <ddarius> type Nat = [()]
22:46:25 <copumpkin> kfish: ooo
22:50:35 * hackagebot scope 0.5.1.0 - An interactive renderer for plotting time-series data  http://hackage.haskell.org/package/scope-0.5.1.0 (ConradParker)
22:50:38 * hackagebot zoom-cache-pcm 0.2.1.0 - Library for zoom-cache PCM audio codecs  http://hackage.haskell.org/package/zoom-cache-pcm-0.2.1.0 (ConradParker)
22:51:26 <copumpkin> christmas came early!
22:51:29 <DanBurton> NemesisD: nope sorry
22:51:46 <AfC> copumpkin: no, no. We expect MUCH more out of kfish by Christmas.
22:52:05 <kfish> :)
22:52:07 <copumpkin> :O
22:52:30 <kfish> i expect beer real soon now
22:52:32 <lewis1711> I don't suppose theres some handy function foo :: t -> Int -> [t] that lets you enter an element and how many repititons you want is there?
22:52:45 <copumpkin> :t replicate
22:52:46 <lambdabot> forall a. Int -> a -> [a]
22:52:47 <ddarius> kfish: You should link to the post int he description.
22:52:50 <rwbarton> @hoogle t -> Int -> [t]
22:52:51 <lambdabot> Prelude replicate :: Int -> a -> [a]
22:52:51 <lambdabot> Data.List replicate :: Int -> a -> [a]
22:52:51 <lambdabot> Prelude drop :: Int -> [a] -> [a]
22:53:00 <copumpkin> kfish: so what's new in 0.9 (I noticed scope now has modules)
22:53:01 * kfish regrets scheduling a meeting for 4pm on a friday
22:53:08 <copumpkin> AfC: like what?
22:53:16 <kfish> copumpkin, multichannel support
22:53:19 <lewis1711> what is this hoogle wizardry. you can look up things by signature? excellent
22:53:46 <copumpkin> kfish: cool!
22:53:54 <copumpkin> I have at least a couple of channels I can think of
22:53:56 <kfish> when you do "write [a]" it turns that into a type-level list and calculates parallel summaries of its elements
22:54:02 <copumpkin> cool :D
22:54:27 <kfish> <cough>subtype reflection</cough>
22:55:34 <copumpkin> :)
22:55:36 * hackagebot zoom-cache-sndfile 0.3.0.0 - Tools for generating zoom-cache-pcm files  http://hackage.haskell.org/package/zoom-cache-sndfile-0.3.0.0 (ConradParker)
22:56:09 <kfish> ddarius, good point :)
22:56:36 <kfish> i haven't rewritten the description for scope yet, might do so next week as we have a new coffee machine
22:57:09 * ddarius fails to see the connection between those clauses.
22:57:51 <kfish> writingHaddocks :: Caffeine -> IO Lulz
22:58:27 <shachaf> kfish: For me it's just ((Sleep -> Void) ->)
22:58:46 <vrook> Is Int instead of Integer really that much of an optimization to justify the inability to replicate (maxBound :: Int) + 1 ?
22:59:33 <copumpkin> :t genericReplicate
22:59:34 <lambdabot> forall i a. (Integral i) => i -> a -> [a]
22:59:42 * ddarius needs lists that that take 48 gigabytes!!!
23:00:08 <shachaf> Note that the genericFunctions sometimes have problems that the regular functions don't.
23:00:16 <shachaf> For example, genericLength is foldr instead of foldl.
23:00:34 <copumpkin> as it should be!
23:00:45 <shachaf> copumpkin: Right. Especially if you want to use it with Nat.
23:01:48 <shachaf> However, a genericReplicate' would be nice. :-)
23:02:34 <shachaf> vrook: However, I agree that Integer is a nicer default type.
23:03:29 <copumpkin> or natural
23:03:29 <ddarius> Natural is the nicer default.
23:03:45 <ddarius> Word should be moved into the Prelude and used where it makes sense.
23:03:54 <copumpkin> yeah
23:04:01 <ddarius> We're computer scientists damn it!  We don't care about groups, we care about monoids!
23:04:44 <companion_cube> maybe groups are the good representation for undo ?
23:05:21 <companion_cube> hmm never mind, undo . do /= do . undo
23:05:24 <shachaf> Hmm, why does genericLength [1..1000000] work?
23:05:42 <dmwit> Why shouldn't it work?
23:06:00 <ddarius> copumpkin: Find me a baritone acoustic guitar.
23:06:02 <ddarius> for cheap.
23:06:11 <copumpkin> yessir
23:06:38 <copumpkin> oh, I can't do that
23:06:44 <shachaf> dmwit: I would expect it to build a huge thunk and then have a stack overflow while evaluating it.
23:06:53 <copumpkin> my guitar dealers only deal in guitars that cost over $100k
23:07:01 <shachaf> ddarius: Guitars are never cheap. They cost you your soul.
23:07:15 <copumpkin> shachaf: did you acquire your guitar at a crossroads, by any chance?
23:07:27 <copumpkin> -s
23:07:29 <ddarius> shachaf: Well I already have several guitars, so that's not a problem.
23:07:35 <dmwit> shachaf: Newish GHC?
23:07:39 <shachaf> copumpkin: I don't have a guitar.
23:07:41 <NemesisD> is there a way to tell lambdabot to show you the source in a pm?
23:07:48 <shachaf> dmwit: Yes, 7. Does it make a difference for this sort of thing?
23:07:50 <dmwit> shachaf: The stack gets automatically enlarged when necessary these days.
23:07:57 <shachaf> NemesisD: @src foo (or: the source of what?).
23:08:19 <shachaf> dmwit: Oh. That's kind of odd.
23:08:29 <shachaf> ddarius: Your balance can go negative.
23:08:39 <NemesisD> @src when
23:08:40 <lambdabot> when p s = if p then s else return ()
23:08:57 <zhulikas> @t when
23:08:58 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
23:09:07 <NemesisD> thats simpler than i thought
23:09:44 <ddarius> shachaf: I'm an American.  Leaving beyond my means is a national imperative.
23:09:59 <sbi> lol
23:10:34 <copumpkin> ddarius: this is why you need a massive centrifuge to make several pounds of pea butter at at time
23:10:39 <hydo> ddarius: I see what you did there.
23:12:19 <ddarius> copumpkin: I could get one, but I don't think my landlord would appreciate it.
23:12:36 <copumpkin> but pea butter is supposed to be most excellent
23:12:43 <copumpkin> you need to get your priorities straight
23:13:09 <shachaf> Get rid of your landlord. That's also a national imperative, as far as I can tell.
23:14:11 <ddarius> shachaf: If my landlord lived in the same building, that would probably be a consequence of me getting a large centrifuge.
23:14:47 <copumpkin> you could keep it in the basement. Then it might be called a subterfuge
23:14:54 * copumpkin flees
23:17:04 <whotemp> hi, i'm learning haskell, can someone help me step through the first few expansions of "foldl (:) [] [1,2,3]"?
23:17:14 <ddarius> copumpkin: Speaking of which, license.
23:17:21 <copumpkin> oh god
23:17:22 <mauke> @src foldl
23:17:23 <lambdabot> foldl f z []     = z
23:17:23 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:17:36 <mauke> foldl (:) [] [1,2,3]
23:17:44 <mauke> foldl (:) [] (1 : 2 : 3 : [])
23:18:01 * copumpkin hands mauke a flip
23:18:12 <copumpkin> ddarius: haven't done it yet
23:18:24 <copumpkin> (in case you hadn't guessed)
23:18:27 <mauke> foldl f (f z x) xs where f = (:); z = []; x = 1; xs = 2 : 3 : []
23:18:34 <whotemp> ugh i need to disaple smiley faces
23:18:55 <mauke> foldl (:) ((:) [] 1) (2 : 3 : [])
23:18:57 <lewis1711> whotemp: well if folding doesn't make you smile i don't know what does
23:19:04 <mauke> type error at (:) [] 1; can't proceed
23:22:22 <whotemp> lewis1711: haha
23:22:56 <whotemp> mauke: i started reading up on haskell about 30 minutes ago, could we try that without variables or functions?
23:22:59 <whotemp> sorry
23:23:17 <mauke> huh?
23:23:36 <mauke> you want a type error without variables or functions?
23:23:40 <mauke> > () :: Int
23:23:41 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
23:23:42 <lambdabot>         against inferred type ...
23:24:16 <whotemp> so the tutorial i'm using mentions that the command produces an infinite list
23:24:19 <lewis1711> first thing first might be to ask if whotemp knows about the structure of lists. do you? not that I know haskell very much..
23:24:37 <mauke> what command?
23:24:52 <whotemp> "foldl (:) [1,2,3]"
23:25:03 <whotemp> whoops
23:25:11 <mauke> no, that's a type error
23:25:13 <mauke> it produces nothing
23:25:21 <whotemp> "foldl (:) [] [1,2,3]"
23:25:27 <mauke> same type error
23:25:31 <whotemp> oh
23:25:33 <mauke> > foldl (:)
23:25:35 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
23:25:39 <whotemp> yeah
23:25:39 <mauke> there we go
23:25:46 <whotemp> oh
23:25:55 <mauke> that's not an infinite list, that's an attempt to create an infinitely big *type*
23:26:10 <whotemp> ok
23:26:24 <mauke> namely "list of list of list of list of list of ..."
23:26:34 <kfish> copumpkin, https://plus.google.com/101555949501667191720/posts/CJxACUYTLuM
23:26:39 <whotemp> ok now i get it
23:26:41 <whotemp> thanks much
23:27:22 <copumpkin> kfish: wonderful!
23:27:27 <copumpkin> kfish: <3
23:28:14 <kfish> l8r
