00:01:43 <salisbury> to the folks of #haskell: the best programming community I have encountered thus far. You folks have improved my haskell greatly. And made me have to refactor a bunch of times... thanks though
00:02:05 <augur> :)
00:02:36 <geheimdienst> salisbury: we learned that from the drug dealers. first be very very friendly and give them stuff for free, and they'll be hooked in no time :)
00:03:04 <int-e> (we don't tell them that there'll be always more to learn)
00:03:52 <salisbury> hehe its definitely working. Every time I write ruby these days, I wish I were writing Haskell.
00:05:25 <jessopher> and they we start beating you in the street
00:05:28 <arw> haskell, the heroin language...
00:05:40 <jessopher> then*
00:06:40 <ski> int-e : i'm not sure what you mean
00:08:04 <geheimdienst> salisbury: same for me. i was pretty polyglot in the past. but after finding haskell, whenever i touch another language i just notice how awkward and wrong things are
00:10:32 <salisbury> geheimdienst: I especially notice the (lack of intricate) type systems. I am so impressed by Haskell's type system, I am reading TaPL.
00:12:00 <jessopher> for me, i would settle for a basic type system. unfortunately, that lead me to haskell too
00:12:05 <Blkt> good morning everyone
00:12:07 <int-e> ski: do you not have the feeling that learning Haskell is a never-ending journey?
00:13:12 <ski> int-e : i meant, i'm not sure what you meant by "do the same with an Eq instance that violates the symmetry law"
00:14:12 <int-e> ski: instance Eq Foo where A == B = True; B == A = False
00:14:17 <ski> (but sometimes i worry that one might have learned all of Haskell one day, yes)
00:14:47 <int-e> ski: violating (a == b) == (b == a)
00:15:48 <ski> int-e : i think `(==)' should be subject to the laws `forall a0,a1. a0 == a1 = True => a0 = a1',`forall a0,a1. a0 == a1 = False => a0 =/= a1'
00:16:11 <ski> (so, if `(==)' gives any definite result, it should be correct, in this sense)
00:16:33 <int-e> ski: what is '=' there? structural equality? if so, I disagree.
00:16:49 <ski> (of course, `=' here is semantic equality. i'm not really talking about the representations having to be equal)
00:17:06 <int-e> ski: but (==) should be symmetric, reflexive and transitive
00:17:26 <hpaste> jessopher pasted “all the type system i require” at http://hpaste.org/55292
00:17:31 <ski> (btw, this is one thing that Mercury does better than Haskell : separating the semantical equality on an abastract type from the semantic equality on the representation type)
00:17:55 <int-e> (and yeah, a congruence relation for the desired operations on the underlying structure, i.e., those that do not break the abstraction)
00:18:09 <ski> int-e : it can't be fully reflexive, since `repeat 0 == repeat 0' won't answer `True'
00:18:44 <ski> possibly requiring it to be symmetric would be reasonable
00:19:00 <int-e> ski: true. so replace "forall a. a == a" by "forall a. not (a /= a)
00:19:01 <ski> (and transitive, if formulated in the right way)
00:19:02 <int-e> "
00:20:03 <saati> ghci usually breaks on ^c it doesn't on repeat 0 == repeat 0
00:20:06 <ski> itym replacing `forall a. a == a = True' by `forall a. a /= a = False' ? or maybe `forall a. a /= a =/= True' ?
00:20:28 <ski> saati : probably because it's not allocating anything
00:20:40 <ski> (and yes, this is a known issue)
00:20:41 <saati> it doesn't care about sigterm
00:22:15 <int-e> welll. still wrong. not ((a == a) = False) is what I want.
00:22:42 <int-e> (sorry, laggy connection)
00:23:58 <ski> ok
00:23:59 <ski> (i would write that as `forall a. a == a =/= False' or maybe `forall a. a == a = False => falsity')
00:24:56 <saati> int-e: what do you gain with an assymetric Eq?
00:24:56 <ski> for transitivity, i think `forall a0,a1,a2. a0 == a1 = True /\ a1 == a2 = True => a0 = a2 = True' might be reasonable
00:26:22 <int-e> saati: a counterexample to elem a [b] = a == b
00:26:54 <int-e> since it's actually evaluated as b == a (in ghc's implementation, I haven't checked the report prelude)
00:29:45 <int-e> @index elemBy
00:29:45 <lambdabot> bzzt
00:31:50 <arw> does ghci have some 'kill all threads, close all sockets' button? i'm debugging some code and when I ctrl-c the main loop, there is a leftover listening socket on a port which i can only close by killing ghci.
00:38:47 <arw> gofb6
00:38:59 <arw> oh, sorry. wrong window focus.
00:39:26 <int-e> that's a short password
00:39:56 <arw> fortunately its not a password, just me trying to use vimperator :)
00:40:27 <shachaf> With vimperator, everyday web browsing becomes as enjoyable as typing a password!
00:41:35 <ski> hm, maybe there should be a type `newtype Comparator a = UnsafeMakeComparator {applyComparator :: a -> a -> Ordering}', to pass to functions
00:42:04 <ski> (the idea being that if you use `UnsafeMakeComparator' on an invalid function, it's your fault)
00:42:53 <shachaf> As opposed to just passing functions :: (a -> a -> Ordering)?
00:42:57 <ski> yeah
00:43:16 <ski> i'm not sure, just an idea
00:44:33 * hackagebot hit 0.2.0 - Git operations  http://hackage.haskell.org/package/hit-0.2.0 (VincentHanquez)
01:04:04 <Veinor> bleh
01:04:10 <Veinor> what's the best way to turn a lazy bytestring into a bytestring?
01:04:41 <cswords> Force it?
01:04:45 <shachaf> Veinor: SB.concat . LB.toChunks?
01:05:02 <Veinor> it really annoys me that i have to do that
01:05:28 <shachaf> convertLazyByteStringToStrictByteString = SB.concat . LB.toChunks
01:05:34 <shachaf> There, saved you some keystrokes.
01:05:46 <ion> veinor: Why?
01:06:38 <Veinor> because some libraries i'm using give me lazy bytestrings, and some give me strict
01:06:46 <Veinor> and this means i'm going to have to go back and forth
01:06:54 <cswords> I would guess the library designers decided to do each for some reason.
01:08:33 <frerich> Hi, I'm working on a little program in which I need to detect whether a gievn pixel is close to one of the other pixels I have in a list. 'Close' in this sense means that the manhattan distance is lower than a certain threshold. Here's a sample program: http://hpaste.org/55301 - now, the issue is that the 'closeToAnyOf' function is called very often with different first arguments - the second argument (the list
01:08:33 <frerich>  of 'pivot' pixels) is rather small and relatively constant, but the first argument changes very often (like, it's different for each of 100000 calls).
01:08:53 <frerich> Does anybody have ideas how to improve this? I was thinking about sorting the list of pivot points somehow, or doing some sort of 'clustering' or soemthing.
01:09:33 * hackagebot monad-par 0.1.0.2 - A library for parallel programming based on a monad  http://hackage.haskell.org/package/monad-par-0.1.0.2 (SimonMarlow)
01:10:53 <cswords> frerich, maybe pass the second argument first, store that function?
01:11:12 <cswords> So, the one that changes very little goes in and you get a partially-applied function waiting for the frequently-changing point.
01:11:18 * cswords is not a haskell expert.
01:12:08 <frerich> cswords: Hm, that's an idea. Dunno whether it actually helps tho :-}
01:12:21 <cswords> Time it on large data sets?
01:12:41 <shachaf> cswords: That's not going to help you on its own.
01:12:55 <shachaf> You just have f = \x -> \y -> ...x...y...
01:13:15 <shachaf> If you apply it and store the result, you have g = \y -> ...x...y...
01:13:30 <shachaf> But no computation is going to happen until you apply the second function.
01:13:52 * shachaf hasn't looked at the actual code.
01:15:33 <cswords> It's just a function to compute manhattan distances.
01:15:37 <magicman> But once the second function is applied once, the part that only depends on 'x' will be evaluated for all subsequent calls to the second function, right?
01:16:08 <shachaf> magicman: I don't think so.
01:16:27 <shachaf> Unless you do something like f = \x -> let z = ...x... in \y -> ...z...y...
01:16:48 <magicman> Oh, right.
01:19:16 <cswords> So why won't that work, then?
01:25:24 <ClaudiusMaximus> frerich: kd-tree springs to mind for nearest neighbour search, though i don't know if it'll work with manhattan distance ; otherwise, maybe use an array instead of a list, and then (if you can unbox) repa gives you parallel operations (and image IO with devil bindings)
01:26:19 <frerich> ClaudiusMaximus: Hm interesting. I never did anything with repa before, but yes - this parallelizes quite nicely.
01:26:26 <dmwit> frerich: You could sort by Manhattan distance from the origin.
01:27:19 <dmwit> Or, hell, sort by Manhattan distance from a couple different points if you want more accuracy. =P
01:27:40 <cswords> frerich, I would guess that KD trees are overkill for this problem.
01:27:55 <frerich> I never heard about KD trees before, about to google that.
01:28:46 * ClaudiusMaximus agrees with cswords  - lot of overhead, linear search was faster when i tried a while ago
01:30:39 <cswords> frerich, it's just a data structure for spatial organization. It's nice for things like collision detection where you only want to check against things close by in space, but for what you're doing it doesn't seem quite appropriate.
01:33:42 <dmwit> I think I would make a Map Int [Point], where the keys were distance from the origin, and look up adjacentDistanceThreshold keys in the map.
01:34:24 <dmwit> The code is easy enough to write that you can just do it on a whim to see if it's fast enough and throw it away if it isn't.
01:36:11 <Ferdirand> hello #haskell
01:36:51 <Ferdirand> does it make sense to define instance (Monoid v) => Monoid (Map k v) ?
01:37:50 <opqdonut> yes
01:37:56 <aninhumer> Seems sensible to me
01:38:07 <opqdonut> except you'll probably have a conflict with the existing Monoid instance for Map
01:38:28 <opqdonut> (Ord k => Monoid (Map k v))
01:38:59 <dmwit> You probably need Ord k, yeah. And you probably also only need Semigroup v, if you care about that kind of thing.
01:39:07 <aninhumer> opqdonut: how does that resolve collisions?
01:39:20 <dmwit> aninhumer: Like First v does. =/
01:39:25 <opqdonut> yep.
01:39:29 <opqdonut> takes the first one
01:39:48 <opqdonut> for clarity, I actually recommend just saying "unionWith mappend"
01:40:01 <opqdonut> unless you really need the monoid instance
01:40:05 <opqdonut> dmwit: why semigroup?
01:40:09 <aninhumer> Ah, so kind of like Ordering is a Monoid?
01:40:14 <dmwit> opqdonut: You don't need v to have a mempty.
01:40:29 <dmwit> aninhumer: ...no? Not very like Ordering at all?
01:40:30 <opqdonut> oh, right
01:41:52 * aninhumer hmm, yeah I'd forgotten how Ordering worked
01:41:58 <aninhumer> whoops
01:42:06 <aninhumer> that was not an action
01:42:36 <Ferdirand> re, sorry, my connection decided to be random today
01:43:15 <Ferdirand> i don't really need the monoid instance, I was looking for a very compact way to count distinct values in a long list
01:43:47 <Ferdirand> i half expected a really awesome solution to exist in the libs already :)
01:44:44 <ddarius> unionWith' (+) $ zip xs (repeat 1) -- doesn't seem not very not compact
01:44:51 <dmwit> :t \xs -> length [x | x `S.notElem` S.fromList xs]
01:44:52 <lambdabot> Couldn't find qualified module.
01:44:55 <opqdonut> > foldr (\x -> insertWith (+) x 1) empty [1,2,3,1,2,3,4,5,1]
01:44:55 <lambdabot>   Not in scope: `insertWith'Ambiguous occurrence `empty'
01:44:56 <lambdabot>  It could refer to e...
01:44:58 <opqdonut> gah!
01:45:11 <opqdonut> > foldr (\x -> Data.Map.insertWith (+) x 1) Data.Map.empty [1,2,3,1,2,3,4,5,1]
01:45:12 <lambdabot>   Not in scope: `Data.Map.insertWith'Not in scope: `Data.Map.empty'
01:45:17 <opqdonut> o-kay
01:45:46 <opqdonut> anyway, that will compute the frequencies
01:45:53 <dmwit> \xs -> length [x | x <- xs, not (x `member` fromList xs)]
01:46:00 <dmwit> oh, crap
01:46:08 <dmwit> not that
01:46:22 <shachaf> ddarius: Didn't you mean not to not say the opposite of what you said?
01:46:54 <dmwit> :t M.insertWith
01:46:55 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
01:47:17 <dmwit> > foldr (\x -> M.insertWith (+) x 1) M.empty [1,2,3,1,2,3,4,5,1]
01:47:18 <lambdabot>   fromList [(1,3),(2,2),(3,2),(4,1),(5,1)]
01:47:31 <dmwit> opqdonut: nice =)
01:48:52 <Ferdirand> yep, i had something like that already, but I wondered if i could replace that with the fold from Foldable and an already existing Monoid instace
01:49:40 <Ferdirand> (the goal is purely showoff to a C programmer)
01:50:34 <dmwit> :t fold
01:50:35 <lambdabot> Not in scope: `fold'
01:50:41 <dmwit> :t Data.Foldable.fold
01:50:42 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
01:52:33 <salisbury> in a long list would foldl' not be better?
01:52:44 <opqdonut> salisbury: sure
01:52:58 <opqdonut> I aimed for brevity :P
01:53:29 <salisbury> I was just excited I could contribute for once hehe
01:53:39 <Ferdirand> :t Data.Foldable.foldMap
01:53:40 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
01:54:12 <matobet> @pl (>> (getLine >>= return . (== "ano"))) . putStr
01:54:12 <lambdabot> (>> ("ano" ==) `fmap` getLine) . putStr
01:55:23 <opqdonut> Ferdirand: if you just want the unique elements and not the frequencies, I suggest using Data.Set.fromList :)
01:55:29 <Ferdirand> :t foldMap (`singleton` Sum 1)
01:55:30 <lambdabot> Not in scope: `foldMap'
01:55:30 <lambdabot> Not in scope: `singleton'
01:55:30 <lambdabot>     Ambiguous occurrence `Sum'
01:55:48 <Ferdirand> opqdonut: I do want the frequencies indeed
01:56:47 <dmwit> opqdonut: I think he wants the unique elements in the sense of wanting the elements that occur with frequency 1.
01:56:59 <dmwit> opqdonut: Which is why I started swearing after I posted a Data.Set "solution".
01:57:13 <Ferdirand> no, I want the equivalent of uniq -c, sorry if it was ambiguous
01:57:32 <dmwit> ah
01:57:41 <dmwit> Well, that's even more different.
01:57:50 <dmwit> Or perhaps you want the equivalent of sort | uniq -c?
01:57:50 <Ferdirand> well sort |uniq -c
01:57:55 <dmwit> okay =)
01:58:05 <Ferdirand> otherwise i know about Data.List.group
01:58:26 <Ferdirand> but avoiding the complexity of sorting
01:58:42 <shachaf> Complexity of sorting?
01:59:07 <dmwit> Using a Map means you're not avoiding the complexity of sorting.
01:59:17 <dmwit> ...if you mean "complexity" as in "time complexity".
01:59:28 <Ferdirand> am i not ?
01:59:31 <Ferdirand> oh right
01:59:32 <Ferdirand> duh
01:59:36 <Ferdirand> intuition fail
01:59:51 <dmwit> If you were, I'd wow the CS world by introducing the "add it all into a Map and read 'em back out again" sort. =)
02:00:18 <shachaf> > map (head &&& length) . group . sort $ "Ferdirand"
02:00:19 <lambdabot>   [('F',1),('a',1),('d',2),('e',1),('i',1),('n',1),('r',2)]
02:01:42 <Ferdirand> well it's still better space-wise right ?
02:02:20 <Ferdirand> if my values repeat often enough
02:03:56 <shachaf> Possibly not with sufficient laziness?
02:04:37 <Ferdirand> lazy behavior of sorting algorithms is probably way over my head :)
02:15:27 <saati> @djinn (b -> b1 -> c) -> (a -> a1 -> b) -> a -> a1 -> b1 -> c
02:15:27 <lambdabot> f a b c d = a (b c d)
02:18:58 <shachaf> Sometimes called (.:)
02:22:20 <saati> is there a pl.djinn ?
02:22:48 <ddarius> @. pl djinn (b -> b1 -> c) -> (a -> a1 -> b) -> a -> a1 -> b1 -> c
02:22:49 <lambdabot> f = (.) . (.)
02:23:49 <saati> lambdabot is awesome
02:24:49 <shachaf> @@ @pl @djinn @type (Prelude..) . (Prelude..)
02:24:50 <lambdabot>  f = (.) . (.)
02:25:21 <saati> @type
02:25:22 <lambdabot> <no location info>: not an expression: `'
02:25:43 <saati> what does @@ do?
02:26:11 <shachaf> @help @
02:26:11 <lambdabot>  @ [args].
02:26:11 <lambdabot>  @ executes plugin invocations in its arguments, parentheses can be used.
02:26:13 <lambdabot>  The commands are right associative.
02:26:15 <lambdabot>  For example:    @ @pl @undo code
02:26:17 <lambdabot>  is the same as: @ (@pl (@undo code))
02:26:34 <shachaf> Now that I've told you about @help, I consider you to be fully informed on every command. :-)
02:29:05 <ddarius> @help eval
02:29:05 <lambdabot> eval. Do nothing (perversely)
02:29:10 <ddarius> @help help
02:29:10 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:54:35 * hackagebot mprover 0.0.0.0 - Simple equational reasoning for a Haskell-ish language  http://hackage.haskell.org/package/mprover-0.0.0.0 (AdamProcter)
03:02:05 <ketil> Anybody know (a link to) the cabal syntax for specifying different sets of GHC-options depending on GHC-version?
03:06:15 <int-e> if impl(ghc>=7) <block> ... ghc-options is no different from the other fields.
03:06:40 <ketil> int-e, right, I found it on Stackoverflow.  Trying it now.
03:06:40 <geheimdienst> int-e: i was gonna say that!
03:06:47 <geheimdienst> ketil, see also http://www.haskell.org/cabal/users-guide/#package-descriptions
03:06:55 <geheimdienst> (section "Conditions")
03:08:12 <int-e> geheimdienst: <insert reverb of stereo quote here>
03:08:44 <int-e> @quote contrap
03:08:44 <lambdabot> coedwardk says: <contrapumpkin> like yoda, I speak now <coedwardk> is that word ordering contra-diction?
03:08:53 <int-e> @quote contrapun
03:08:53 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
03:16:04 <ketil> geheimdienst, OK.  I'll update the page at http://haskell.org/haskellwiki/Upgrading_packages.  Take a look and fix if not okay!
03:24:36 * hackagebot murmur-hash 0.1.0.5 - MurmurHash2 implementation for Haskell.  http://hackage.haskell.org/package/murmur-hash-0.1.0.5 (ThomasSchilling)
03:27:53 <sajkr> guys, help. i'm stuck with cabal installing snap.
03:28:44 <sajkr> cabal: cannot configure attoparsec-text-0.8.5.2. It requires attoparsec >=0.7
03:28:44 <sajkr> && <0.10
03:29:14 <int-e> what command did you issue?
03:29:26 <Veinor> sajkr: https://gist.github.com/1169332
03:29:31 <sajkr> and then a bunch of packages require attoparsec-text==0.10.*
03:29:37 <int-e> ah.
03:29:53 <sajkr> int-e: cabal install snap snap-core snap-server -fgnutls
03:30:06 <Veinor> oh, that's not your issue, hm
03:30:13 <Veinor> what's requiring attoparsec-text-0.8.5.2?
03:31:49 <sajkr> Veinor: how do i find that out? i don't see it in the output.
03:31:58 <Veinor> cabal install -v
03:32:25 <sajkr> anyhow, it *is* my issue, since i'm late with a project and i don't have time for dependency conflicts. :)
03:35:02 <int-e> is attoparsec-text-enumerator-0.2 installed, perhaps?
03:35:39 <hpaste> sajkr pasted “cabal -v install output” at http://hpaste.org/55306
03:36:25 <sajkr> int-e: yeah, 0.2.0.4.
03:37:52 <Veinor> sajkr: hmm
03:37:55 <Veinor> try cabal -v2 install
03:38:10 <int-e> actually why is attoparsec-text involved at all? it doesn't want to install that for me at all.
03:38:23 <int-e> ( cabal install --dry-run snap snap-core snap-server -fgnutls | grep atto   after cabal update)
03:38:57 <Veinor> that's what i'm trying to find out, yeah
03:39:42 <sajkr> Veinor: still nothing. i'm confused.
03:40:04 <Veinor> do you have attoparsec-text already installed?
03:40:12 <Veinor> (ghc-pkg list | grep attoparsec-text)
03:41:22 <sajkr> WARNING: there are broken packages.  Run 'ghc-pkg check' for more details. attoparsec-text-0.8.5.1
03:41:38 <Veinor> so you already have attoparsec-text installed for some reason
03:41:51 <sajkr> how do i fix that?
03:42:01 <Veinor> ghc-pkg unregister attoparsec-text-0.8.5.1
03:43:15 <sajkr> Veinor: it seems to work.
03:43:21 <Veinor> yeah
03:43:31 <Veinor> ghc-pkg won't let you unregister a package other packages depend on, so you should be clear
03:44:02 <sajkr> i --force'd it. :)
03:44:08 <Veinor> ... oh
03:44:10 <Veinor> well, then.
03:44:38 * hackagebot bio 0.5.1 - A bioinformatics library  http://hackage.haskell.org/package/bio-0.5.1 (KetilMalde)
03:45:38 <sajkr> Veinor: i'd probably resort to removing ghc/cabal entirely and installing everything from scratch, so i don't mind --force.
03:46:03 <Veinor> i mean, ghc-pkg check will tell you what you broke and if you have to you can always try dependency-mangling attoparsec-text
03:46:40 <sajkr> it was the old version of snap that depended on it, anyway.
03:47:46 <Veinor> ah, yeah
03:48:07 <sajkr> i used to use bauerbill (i'm an arch user), which has cabal2arch support and everything. nowadays, everything breaks once in a while. :(
03:52:40 <sajkr> Veinor: it worked. thanks a lot.
03:53:17 <geheimdienst> ketil: thanks for the wiki contribution. seems good to me, i copied the lines into a random .cabal file and everything worked
04:28:26 <joe9> i use Text.Groom quite a bit for showing data structures. Just curious if there is something better than that out there. Something where I can set the line length?
04:29:39 * hackagebot time-http 0.3 - Parse and format HTTP/1.1 Date and Time strings  http://hackage.haskell.org/package/time-http-0.3 (MasatakeDaimon)
04:30:26 <vrook> This gives a stack overflow for each of foldr, foldl, and foldl'. https://gist.github.com/1481005
04:30:54 <vrook> I thought I somewhat understood the space issues with folds, but apparently I don't at all.
04:31:29 <vrook> I figured the strict foldl' always works, but it doesn't here.
04:37:40 <geekosaur> my gut feeling is zipWith is too lazy and the whole thing is being forced by print
04:39:39 * hackagebot syb 0.3.6 - Scrap Your Boilerplate  http://hackage.haskell.org/package/syb-0.3.6 (JosePedroMagalhaes)
04:40:17 <ClaudiusMaximus> > let ones = repeat 1 ; series = 1 : zipWith (+) ones series in series !! 100000
04:40:18 <lambdabot>   100001
04:40:59 <hpc> :t scanl
04:41:00 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
04:41:24 <hpc> > scanl (+) 0 $ fix (1:)
04:41:25 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
04:42:02 <ClaudiusMaximus> > iterate (+1) 0 !! 100000
04:42:03 <lambdabot>   100000
04:44:09 * geekosaur not really awake enough to fully figure it out, but to really know what's going on with a fold you need to know the strictness of the thing being folded over
04:45:03 <vrook> So foldl' strictifies the arguments to the folding function, but not the result?
04:45:35 <geekosaur> which is why providing a simple schema for figuring out which one to use is difficult; for anything non-trivial you need to work out the strictness/laziness of the function you're folding (I misspoke previously, not the list folded over but the function)
04:46:51 <geekosaur> most things only evaluate to "weak head normal form", meaning the first constructor in the case of data.  strict folds also strictify the function but only to one level, so build is invoked strictly but zipWith should still be a thunk at that point
04:47:47 <geekosaur> but I may be talking out my butt, I should probably shut up and let someone awake answer
04:48:04 <geekosaur> in fact I think I might finally be able to head to bed...
04:49:33 <ClaudiusMaximus> vrook: i can't reproduce the stack overflow here with ghc-7.0.4
04:50:39 <geekosaur> it does also depend on what RULES are in force and now smart the ghc version is...
04:51:36 <vrook> I'm running ghc 6.12.3 since I have OS X 10.5.
04:52:24 <vrook> ClaudiusMaximus: and you tried increasing the 1 mil to 10 mil or something?
04:52:37 <ClaudiusMaximus> vrook: not yet
04:52:53 <vrook> I know darwin has a small stack...
04:52:57 <osaunders> Anyone know of a library for a many-to-many data relationship? (I don’t know the correct name for this is.) It’s basically two maps «Map a (Set b)» and «Map b (Set a)» with appropriate functions for interfacing.
04:53:28 <hpc> osaunders: a graph?
04:53:38 <ByronJohnson> osaunders: Data.Bimap?
04:53:46 <osaunders> Doh!
04:53:49 <osaunders> Neither of those
04:54:39 <maltem> For graphs there's also fgl
04:55:00 <ClaudiusMaximus> vrook: with 10M/foldl ghci is using 1.2GB and taking some time...
04:55:21 <maltem> (inductive graphs, that is)
04:55:36 <vrook> ClaudiusMaximus: you mean foldl' ?
04:55:50 <ClaudiusMaximus> vrook: nope... testing all 3 versions...
04:56:22 <ClaudiusMaximus> but at this rate (ghci now using 2GB, still not completed) i might not..
04:56:39 <hpc> osaunders: depending on the properties/operations you need, a pair of maps would be a perfect data type for this
04:56:44 <hpc> osaunders: you should put it on hackage
04:57:20 <osaunders> hpc: Yeah it’s pretty simple so I was just wondering if someone had already done it
04:58:15 <ClaudiusMaximus> hayoo might be worth a look
04:58:16 <osaunders> I usually like to look at other people’s code and then write my own thing anyway :_
04:58:18 <osaunders> *:)
04:58:35 <vrook> osaunders: maybe this is going to far, but you can represent it as equivalence classes of permutations.
04:58:50 <hpc> osaunders: heh, i usually do my own thing, then see what others did
04:58:56 <vrook> *too far
04:59:06 <vrook> dammit that was a retardo mistake
04:59:23 <osaunders> vrook: not sure what equivalence classes are
04:59:31 <osaunders> as in type classes?
05:00:16 <osaunders> Anyway I think going for simple and obvious might not be a bad thing. I generally don’t like stuff that is too “cool”
05:01:11 <ClaudiusMaximus> vrook: ah, foldl finally stack overflowed
05:01:22 <kmc> osaunders, http://en.wikipedia.org/wiki/Equivalence_class
05:01:25 <ClaudiusMaximus> vrook: testing foldl' now
05:02:12 <vrook> osaunders: An == function naturally partitions a set into equivalence classes. I don't think was I said was valid anyway. But the general motivation is that if you find a mathematical structure it's a big win.
05:02:55 <Idonteven> Hello
05:03:12 <osaunders> vrook: OK
05:03:16 <kmc> hi Idonteven
05:03:40 <Idonteven> I had no idea there would be so many people in here pfff
05:03:46 <Idonteven> All beginners to haskell?
05:03:51 <kmc> no
05:03:57 <kmc> some are experts
05:04:05 <kmc> some just hang around for fun
05:04:23 <kmc> the discussion here ranges from beginner questions to active research topics
05:04:28 <Martty> i am here for the yo mamma jokes
05:04:30 <vrook> It overflows with this too: foldl'' f = foldl' (\acc x -> let res = f acc x in res `seq` res)
05:04:35 <Martty> its been awfully quiet in that respect lately
05:04:37 <ClaudiusMaximus> vrook: but i think i see the problem now - the acc in build is only forced to WHNF by foldl', which is only enough to know whether it is an empty list or a cons cell, and the actual values in the list aren't forced at all
05:04:41 <Idonteven> Cool, just checking it out since I'm gonna need this language for the upcoming year at uni
05:05:00 <ClaudiusMaximus> vrook: x `seq` x doesn't do anything useful
05:05:13 <vrook> deepseq?
05:05:15 <kmc> "if you force x, also force x"
05:05:27 <hpc> @hoogle deepseq
05:05:27 <lambdabot> Control.DeepSeq module Control.DeepSeq
05:05:28 <lambdabot> Control.DeepSeq deepseq :: NFData a => a -> b -> b
05:05:28 <lambdabot> package deepseq
05:05:35 <hpc> @hoogle rnf
05:05:35 <lambdabot> Control.DeepSeq rnf :: NFData a => a -> ()
05:06:21 <vrook> I get an error with deepseq in foldl''
05:06:38 <vrook> "Could not deduce (NFData a) from the context ()"
05:06:49 <ClaudiusMaximus> remove the type signature or modify it
05:07:11 <kmc> :t deepseq
05:07:12 <lambdabot> Not in scope: `deepseq'
05:07:19 <kmc> <lambdabot> Control.DeepSeq deepseq :: NFData a => a -> b -> b
05:07:32 <vrook> aha. I removed the type. No stack overflow now for foldl'' f = foldl' (\acc x -> let res = f acc x in res `deepseq` res)
05:08:00 <vrook> foldl'' :: (NFData a) => (a -> b -> a) -> a -> [b] -> a
05:08:33 <vrook> This should be added to a wiki somewhere
05:08:38 <kmc> i don't like it
05:08:50 <kmc> deepseq is usually a brute force, overkill solution
05:09:07 <kmc> and it can have a significant runtime cost
05:09:35 <vrook> what's a better solution?
05:09:42 <kmc> the alternative is to understand what's going on, and add some whnf-strictness in the right place
05:10:24 <vrook> where do we add it here?
05:10:34 <ClaudiusMaximus> kmc: agree in general, but in this specific example it probably would be a lot of work for the same end operational effect ( https://gist.github.com/1481005 )
05:10:49 <kmc> yeah i am speaking in general
05:10:51 <kmc> i did not see your example
05:10:59 <kmc> anyway if you want to add foldl'' to the haskell wiki, go ahead
05:10:59 <ClaudiusMaximus> would be a good exercise to work through it i think
05:11:01 <kmc> it is a wiki after all
05:12:39 <vrook> I didn't mean literally add foldl'', but to discuss that even foldl' doesn't work sometimes.
05:12:56 <kmc> there is a simple example of that in RWH
05:13:20 <dskippy> What tools do you guys use when you want to know which module a function is in? Is there a simple command-line tool for this?
05:13:28 <hpc> dskippy: hoogle
05:13:28 <kmc> ghci's :i
05:13:35 <hpc> or that
05:13:38 <hpc> @hoogle map
05:13:38 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
05:13:38 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
05:13:38 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
05:13:38 <dskippy> Mostly I'm looking for things I insteall from Hackage.
05:13:48 <dskippy> hpc: Hoogle doesn't have my hackage stuff.
05:13:56 <kmc> vrook, http://book.realworldhaskell.org/read/profiling-and-optimization.html#id678431
05:13:57 <ClaudiusMaximus> hayoo is also handy
05:14:01 <dskippy> @hoogle choose
05:14:01 <lambdabot> Test.QuickCheck.Gen choose :: Random a => (a, a) -> Gen a
05:14:01 <lambdabot> Test.QuickCheck choose :: Random a => (a, a) -> Gen a
05:14:05 <hpc> dskippy: you can install hoogle yourself
05:14:15 <hpc> dskippy: and it will index the stuff you have installed i think
05:14:23 <dskippy> Oh awesome.
05:14:25 <ClaudiusMaximus> in hoogle web interface you can add +cairo to search within the cairo package, for example
05:14:38 <kmc> you can also search by type
05:14:39 * hackagebot boolexpr 0.1 - Boolean expressions with various representations and search queries.  http://hackage.haskell.org/package/boolexpr-0.1 (NicolasPouillard)
05:14:49 <dskippy> So it would have picked up Math.Statistics.choose if it were on my machine?
05:15:02 <statusfailed> If I want to bind a list of monads together with mapM, how do I do that?
05:15:17 <dskippy> Since I have Math.Statistics installed
05:15:29 <ClaudiusMaximus> http://www.haskell.org/hoogle/?hoogle=choose+%2Bstatistics
05:15:32 <kmc> statusfailed, a monad is a type constructor, not a value
05:15:47 <kmc> "Maybe" is a monad.  "Just 3" is not
05:16:05 <ClaudiusMaximus> anyway, hoogle commandline is probably better if you're not near an internet or don't know the package name
05:16:05 <kmc> anyway i don't understand what you're trying to do.  maybe give us the type signature of the function you want
05:16:11 <kmc> :t sequence
05:16:12 <geheimdienst> statusfailed: it depends on what you mean by "bind together", but you might be looking for sequence
05:16:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:16:36 <statusfailed> well if I have two State monads
05:16:41 <statusfailed> I can do s1 >>= s2
05:16:44 <kmc> first step towards writing a function is to decide what its type should be
05:16:50 <statusfailed> I want to do that for a list
05:16:52 <kmc> :t foldr (>=>) return
05:16:53 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
05:17:07 <hpc> statusfailed: what type do you want?
05:17:16 <kmc> you don't have two State monads.  you have two values
05:17:23 <kmc> <kmc> statusfailed, a monad is a type constructor, not a value
05:17:26 <kmc> <kmc> "Maybe" is a monad.  "Just 3" is not
05:17:40 <statusfailed> how should I refer to s1 and s2?
05:17:44 <statusfailed> monadic values?
05:17:51 <kmc> s1 is a State monad action
05:17:56 <statusfailed> action?
05:17:57 <kmc> s2 is a function that returns a State monad action
05:17:59 <kmc> they don't have the same type
05:18:10 <kmc> :t ?x >>= ?y
05:18:10 <lambdabot> forall (m :: * -> *) a b. (?x::m a, ?y::a -> m b, Monad m) => m b
05:19:28 <statusfailed> [State s a] -> s -> (a,s)
05:19:48 <kmc> you want to discard the 'a' values from everything except the last action?
05:19:53 <kmc> and perform the actions in order, left-to-right?
05:20:03 <hpc> :t runState . foldr (>=>) return
05:20:03 <lambdabot>     Couldn't match expected type `StateT s Identity a'
05:20:04 <lambdabot>            against inferred type `b -> m c'
05:20:04 <lambdabot>     Probable cause: `>=>' is applied to too few arguments
05:20:10 <hpc> :t runState .: foldr (>=>) return
05:20:11 <lambdabot> forall s a. [a -> StateT s Identity a] -> a -> s -> (a, s)
05:20:13 <kmc> :t foldr1 (>>)
05:20:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m a
05:20:34 <hpc> :t runState .: foldr (>>) return
05:20:35 <lambdabot> forall s a a1. [a -> a1] -> a -> s -> (a, s)
05:20:43 <hpc> o.O
05:20:48 <kmc> :t runState . foldr1 (>>)
05:20:49 <lambdabot> forall s a. [State s a] -> s -> (a, s)
05:20:54 <kmc> statusfailed, ^^^^
05:20:55 <hpc> oh, there
05:20:57 <vrook> kmc: How exactly does RWH apply here? The only thing new it suggests is bang patterns, which don't help here. Can you show how to fix https://gist.github.com/1481005 without Control.DeepSeq ?
05:21:03 <statusfailed> hey cool ^^
05:21:05 <statusfailed> thanks
05:21:14 <statusfailed> oh, that makes sense
05:21:17 <statusfailed> herp :|
05:21:37 <kmc> <vrook> I didn't mean literally add foldl'', but to discuss that even foldl' doesn't work sometimes.
05:21:37 <kmc> <kmc> there is a simple example of that in RWH
05:21:39 <kmc> that is the context
05:23:24 <vrook> OK it's already in the wiki "If this is the case, then you have to use deepseq."
05:23:30 <kmc> where?
05:23:41 <vrook> the last line of http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
05:24:01 <kmc> oh, well that's not correct
05:25:28 <vrook> It also doesn't belong in the Conclusion section, since it introduces new information.
05:26:20 <vrook> (That's my excuse for not noticing it earlier, anyway.)
05:28:33 <kmc> fixed
05:30:30 <vrook> Why doesn't this work? foldl'' f = foldl' (\ !acc x -> f acc x)
05:30:47 <hpc> @src foldl'
05:30:47 <lambdabot> foldl' f a []     = a
05:30:48 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
05:31:04 <kmc> seems like it adds the same strictness foldl' already has
05:31:11 <vrook> Oh it's the same problem as foldl'
05:31:15 <vrook> yeah
05:31:51 <vrook> So what's the least brute-force way of fixing https://gist.github.com/1481005 ?
05:32:59 <mm_freak> theoretical question:  would it make sense for a language to differentiate between data and codata and have eager evaluation by default for data and lazy for codata?
05:35:58 <quicksilver> mm_freak: Yes.
05:36:14 <quicksilver> mm_freak: or at least lots of people have tried to explore that path.
05:37:22 <hpc> it is certainly possible to automatically distinguish between the two
05:37:35 <quicksilver> I read a Turner paper along those lines
05:37:38 <quicksilver> it might have been this one : http://scholar.google.co.uk/scholar?cluster=7988962173271339683&hl=en&as_sdt=0,5
05:38:20 <_pw_> hi, all. How to use where-clause in GHCi?
05:38:39 <kmc> "where" attaches to a declaration, not an expression
05:38:54 <kmc> so you would attach it to a binding within "let" or another "where"
05:39:16 <kmc> or an arm of a "case", but that's somewhat unusual imo
05:39:19 <sefb1704> hi
05:39:35 <kmc> _pw_, maybe you can tell us what you're trying to do, and we can recommend the best syntax, "where" or no
05:40:17 <sefb1704> i have tried installing ghci on my new linux laptop alot and now i think im done, but now i get unexpected and odd errors when trying to compile some of my programs. one sec, i will post one
05:40:29 <_pw_> kmc: thanks, i am playing with GHCi, and trying some trivial code snippets.
05:41:30 <sefb1704> MyHaskellAdventure0.5.hs:127:0:     Contexts differ in length       (Use -XRelaxedPolyRec to allow this)     When matching the contexts of the signatures for       openbag :: forall a. (Num a) => [a] -> String -> IO ()       decision :: forall a a1.                   (Num a, Num a1) =>                   [a1] -> [Char] -> a -> [Char] -> IO ()     The signature contexts in a mutually recursive group should all be identical     When 
05:42:02 <sefb1704> is ghci maybe not properly installed? :/
05:42:41 <kmc> sefb1704, i'm not sure why you jumped to that conclusion
05:42:47 <kmc> when it seems to be indicating an error in your code
05:42:59 <_pw_> kmc: I try to figure out how where-clause could be used. for example, Prelude> f x = g x where g = id , it complains: <interactive>:1:5: parse error on input `='
05:43:32 <kmc> «f x = g x» isn't valid at the ghci prompt anyway
05:43:35 <_pw_> kmc: oops, i need let before f x
05:43:41 <kmc> you could say «let g = id; f x = g x»
05:44:09 <maltem> "where" works with let in ghci
05:44:09 <kmc> sefb1704, we can help more if you put your code and the error message on hpaste
05:44:11 <quicksilver> "let f x = g x where g = id " is also fine
05:44:13 <sefb1704> kmc, caus i dont load as many things in the beginning as in school. i only load: Loading package ghc-prim ... linking ... done. Loading package integer-gmp ... linking ... done. Loading package base ... linking ... done.
05:44:43 <sefb1704> kmc, okey
05:44:46 <maltem> _pw_, also, the next ghc version will allow more syntax in ghci, if I'm not mistaken
05:45:07 <kmc> yeah, ghci 7.4 allows type declarations, class declarations, etc. at top level
05:45:22 <kmc> i don't know if it also allows function and pattern decls without "let"
05:46:06 <_pw_> kmc: type declarations in GHCi will be introduced in version 7.4?
05:46:34 <kmc> yes
05:46:48 <_pw_> where can i find a roadmap for GHCi?
05:47:14 <kmc> you can build it from the git repo and play with these features today
05:47:38 <hpaste> sefb1704 pasted “Mytextadventure” at http://hpaste.org/55310
05:47:38 <kmc> also see http://hackage.haskell.org/trac/ghc/wiki/Status
05:48:48 <sefb1704> error code: MyHaskellAdventure0.5.hs:127:0:     Contexts differ in length       (Use -XRelaxedPolyRec to allow this)     When matching the contexts of the signatures for       openbag :: forall a. (Num a) => [a] -> String -> IO ()       decision :: forall a a1.                   (Num a, Num a1) =>                   [a1] -> [Char] -> a -> [Char] -> IO ()     The signature contexts in a mutually recursive group should all be identic
05:48:57 <kmc> you should put the error message on hpaste too
05:48:59 <kmc> it's hard to read here
05:49:20 <sefb1704> oh okey. can i somehow edit my hpaste or do i have to create a new document?
05:49:20 <kmc> but anyway, you have hit a weird corner of the haskell type system
05:49:31 <kmc> it's certainly not a result of installing ghc improperly
05:50:19 <maltem> sefb1704, you can "annotate"
05:50:57 <_pw_> http://www.haskell.org/communities/11-2011/html/report.html , here is the report, thanks to all.
05:51:07 <kmc> sefb1704, the functions 'openbag' and 'decision' call each other (indirectly)
05:51:21 <kmc> haskell requires that they have the same number of type class constraints on their types
05:51:24 <maltem> yup, the error is confusing. It's probably just a type mismatch (should a and a1 be the same?), but it's hard to tell from a glance
05:51:30 <maltem> oh
05:51:39 <kmc> in GHC you can disable this requirement with the -XRelaxedPolyRec flag
05:51:44 <kmc> you can put this line at the top of your file:
05:51:49 <kmc> {-# LANGUAGE RelaxedPolyRec #-}
05:52:01 <sefb1704> oO
05:52:07 <quicksilver> you seem to have unneessary polymorphism anyway
05:52:25 <quicksilver> why not make 'a1' and 'a' the same type
05:52:29 <sefb1704> im a beginner in haskell and this seems REALLY odd ;D well okey i will try it
05:52:29 <quicksilver> (or make them all Integer!)
05:52:31 <kmc> sefb1704, http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#typing-binds
05:52:36 <maltem> I'm stunned I just learnt something new about basic function definitions in Haskell
05:53:03 <sefb1704> at what line quicksilver?
05:53:05 <kmc> sefb1704, what if you remove the type signatures, and then ask GHCi for the types with :t
05:53:15 <quicksilver> sefb1704: line 126
05:53:26 <quicksilver> sefb1704: change a1 to a
05:53:29 <sefb1704> kmc, i try that
05:53:30 <quicksilver> and remove Num a1 from the context
05:53:37 <sefb1704> qucksilver, ok
05:54:14 <maltem> sefb1704, btw, if you're handing this in as an assignment, you may want to revise your introducing comments. I find them hard to read
05:54:27 <kmc> you also might want to avoid having a function named 'function'
05:54:29 <quicksilver> I would personally suggest constraining the unnecessary polymorphism preferably to straying outside haskell2010 for a feature you're not really using :)
05:54:46 <kmc> i agree with quicksilver
05:55:30 <kmc> sefb1704, the biggest problem I have with your code is that you've mixed together the description of the world and the logic for traversing it
05:56:36 <kmc> you should probably make a data type to represent the world
05:56:49 <sefb1704> kmc, do you mean i have to remove all signatures?
05:56:50 <kmc> and a "generic" game engine which doesn't care about knives and jungles etc
05:56:52 <kmc> no
05:56:59 <kmc> just the ones which are causing trouble
05:57:04 <kmc> then you can ask ghci for the right type using :t
05:57:06 <kmc> and put them back in
05:57:24 <kmc> also i'm still amused by "sleep n = threadDelay (n * second) where second = 50000"
05:57:29 <kmc> i.e. "where a second is half a second"
05:57:35 <sefb1704> actually i have already tried this ;D but okey i have edited the code since i did this so i will do this one more time
05:58:05 <osaunders> Does this happen to other people. You have a list of things you were referring to as «a» but you can’t call it «as» because as is reserved word
05:58:25 <kmc> it's not actually
05:58:27 <kmc> > let as = 3 in as
05:58:27 <lambdabot>   3
05:58:36 <osaunders> :O
05:58:41 <osaunders> :D
05:58:43 <sefb1704> okey one second, my error after fixing the contract is the following: MyHaskellAdventure0.5.hs:41:44:     Could not deduce (Read a) from the context (Num a)
05:58:56 <kmc> but, editors highlight it as such
05:58:59 <sefb1704> i think he doesnt like how i read the users input and give it to the function
05:58:59 <kmc> contract?
05:59:10 <sefb1704> contract = type
05:59:25 <sefb1704> but okey i will call it type
06:00:35 <sefb1704> the user inserts a number and i give it to a function by writing : decision1 <- getline; (read decision1)
06:00:52 <sefb1704> and then writing this (read decision1) into the arguments of the function. and the function expects an integer
06:02:10 <sefb1704> btw i think i have highly increased my code, it consisted only of 1 function and a huuuge if then else tree in the beginning ^^
06:02:20 <sefb1704> *improved
06:02:28 <hpc> @pl divMod a b = (liftA2 div a b, liftA2 mod a b)
06:02:28 <lambdabot> divMod = ap (ap . ((,) .) . liftA2 div) (liftA2 mod)
06:02:32 <hpc> eeew
06:03:34 <sefb1704> kmc, cant i use 'read' to convert getline into integer?
06:03:39 <donri> is it an established idiom to use suffix underscores for reserved keywords as identifiers? seems to clash with the other idiom of that meaning "throw away monadic value"
06:03:54 <kmc> sefb1704, no, getline is an IO action
06:04:00 <kmc> but you can use it on the *result* of getLine
06:04:01 <donri> perhaps suffix prime would be more consistent and preferable, but vim highlights that badly :(
06:04:03 <kmc> which is what you were doing
06:04:44 <sefb1704> kmc, still this guy is arguing about "read decision"
06:06:19 <sefb1704> yay, if i remove all my contracts this works! :) okey i will use :t now to find out how to change the types
06:07:08 <kmc> they're not called contracts, they are called types
06:08:04 <mokus> yep, they're not agreeing to play nice, they are being forced to by a higher power
06:09:56 <sefb1704> okey, now this works. the solution is to add Read a => .. to the types. i can accept that, doesnt seem too odd to me
06:10:15 <kmc> yeah, that is the type class which lets you convert String to 'a'
06:10:19 <kmc> read :: (Read a) => String -> a
06:10:26 <kmc> but, I thought you were converting to Integer specifically
06:10:35 <kmc> not to some generic 'a'
06:11:18 <sefb1704> yes my intention was to convert an inserted number to integer so that it can actually be used. do you mean this is still wrong? i will test that, at least it compiles correctly
06:11:35 <kmc> if you had to add (Read a) then you are converting String to 'a', not to Integer
06:13:03 <sefb1704> yes, what i meant was adding Read a => .. to the existing type. the result is: decision :: (Read a, Num a) => [a] -> [Char] -> a -> [Char] -> IO()
06:13:56 <EvanR-work> if it compiles, its good
06:13:58 <sefb1704> kmc, so Read a and Num a in combination make this right?
06:14:01 <EvanR-work> if it boots up, its perfect
06:14:03 <kmc> EvanR-work, not actually true
06:14:15 <kmc> sefb1704, no
06:14:30 <kmc> sefb1704, if you thought you were converting String to Integer only, and you had to add (Read a), then something is still wrong
06:15:07 <sefb1704> kmc, i will be right back in 20 minuetes, have to change the room
06:15:17 <sefb1704> kmc, thank you so far
06:15:20 <kmc> :)
06:15:30 <EvanR-work> strToIntgr = read :: String -> Integer ;)
06:16:25 <ClaudiusMaximus> :t readLn
06:16:25 <lambdabot> forall a. (Read a) => IO a
06:17:24 <kmc> :t readLn :: IO Integer
06:17:25 <lambdabot> IO Integer
06:21:13 <EvanR-work> > read "()" :: ()
06:21:13 <lambdabot>   ()
06:21:18 <EvanR-work> > read "()o_O" :: ()
06:21:19 <lambdabot>   *Exception: Prelude.read: no parse
06:26:00 <alistra> > read "()"
06:26:01 <lambdabot>   ()
06:26:06 <alistra> magick
06:26:25 <mzero> botmagicks
06:27:10 <kmc> > reads "()o_O"
06:27:11 <lambdabot>   [((),"o_O")]
06:27:26 <alistra> how
06:27:27 <sefb1704> kmc, i am back.
06:27:27 <alistra> what
06:27:39 <kmc> 'what' what?
06:28:02 <alistra> my ghc can't do that :(
06:28:17 <kmc> you mean, without a type annotation?
06:28:22 <alistra> yeah
06:28:31 <Veinor> hmm
06:28:36 <kmc> lambdabot has different defaulting rules in effect
06:28:38 <kmc> or something like that
06:28:44 <Veinor> djinn needs to learn about monads
06:28:46 <kmc> @check \xs -> xs == reverse xs
06:28:47 <lambdabot>   Not in scope: `myquickcheck'Not in scope: `reverse'Not in scope: `=='Not in...
06:28:51 <kmc> what
06:28:55 <yitz> hi mzero. thanks for setting in motion the issue of uploads
06:29:13 <Veinor> i have an a -> IO Bool, and an IO [a], and i need an IO [a] filtered by the predicate
06:29:22 <yitz> with dons not around very much we need to think about it more than in the past
06:29:51 <Veinor> @pl \pred mxs -> do { xs <- mxs; filterM xs }
06:29:52 <lambdabot> (line 1, column 17):
06:29:52 <lambdabot> unexpected "{"
06:29:52 <lambdabot> expecting variable, "(", operator or end of input
06:29:53 <hpaste> sefb1704 annotated “Mytextadventure” with “Mytextadventure (annotation)” at http://hpaste.org/55310#a55312
06:30:02 <kmc> :t filterM
06:30:03 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
06:30:07 <Veinor> @undo do { xs <- mxs; filterM xs }
06:30:07 <lambdabot> mxs >>= \ xs -> filterM xs
06:30:20 <kmc> :t (>>= filterM ?f)
06:30:21 <lambdabot> forall (m :: * -> *) a. (?f::a -> m Bool, Monad m) => m [a] -> m [a]
06:30:31 <Veinor> ah
06:30:33 <Veinor> thanks
06:30:44 <sefb1704> kmc, as long as you arent busy you would have to scroll down alot to see my edit.
06:32:28 <sefb1704> kmc, question: what do you think about my usage of read?
06:34:03 <kmc> this line?   decision (knife:wood:xs) "clearance" (read decision1) "dont care, pattern matching knows what to do"
06:34:44 <sefb1704> kmc, well, my edit consists of 4 lines and they all stick together you cant only look at one of them
06:34:51 <kmc> i don't understand that line
06:35:16 <vrook> Here's a deepseq alternative for the above fold problem. https://gist.github.com/1481395  It turns out deepseq is more than twice as fast as this.
06:35:30 <vrook> *than this
06:36:24 <sefb1704> kmc, ah okey, no problem. decision is the name of a function, the type is declaired in my post. after "decision" the parameters follow that are given to the function. the function decision basically only posts text
06:40:06 <vrook> kmc: given that using a strict list is more than twice as slow in comparison to deepseq, I'm not sure deepseq should be recommended as a last resort, per the wiki.
06:40:41 <kmc> ok
06:40:50 <kmc> you understand this situation better than i do
06:40:53 <kmc> so edit the page if you like
06:41:14 <vrook> "not sure"
06:42:44 <sefb1704> kmc, okey :/ i thought there was an obvious failure in my code about my usage of read and you could easily explain this to me
06:43:12 <sefb1704> kmc, but its okey like that, my code compiles and works, its just fine
06:47:54 <sefb1704> kmc, okey im offline, thank you alot :*
06:55:20 <wereHamster> @type (:$)
06:55:20 <lambdabot> Not in scope: data constructor `:$'
06:56:09 <wereHamster> one day, I'll understand haskell. That day, however, is still a *long* way ahead :(
06:56:31 <kmc> there's no magic point at which you "understand haskell"
06:56:33 <kmc> there is always more to learn
06:56:54 <kmc> we can help with questions, though...
06:57:09 <ClaudiusMaximus> and some people keep inventing even more haskell that needs to be understood
06:57:23 <kmc> yeah
06:57:55 <kmc> also, you can't really draw a sharp line between "understanding Haskell" and "understanding CS and math"
06:58:04 <kmc> and there's certainly more than one lifetime's worth of that
06:58:53 <minh> Hi there! I have a very simple question concerning the terminology with type-constraints: Consider something like "foo :: (SomeType t) => t -> t",what is that "t" called?
06:59:04 <kmc> a type variable
06:59:54 <minh> kmc: Oh yes, that's it! Thank you very much! (I forgot about it since I didn't get to do any Haskell for the last 3 Months)
07:00:30 <kmc> they're called that even when there are no constraints
07:01:19 <minh> kmc: sure, absolutely!
07:01:22 <wereHamster> ok. correction: one day, I'll understand haskell enough to be of use for me.
07:01:49 <kmc> ah, yes
07:02:12 <hpaste> osaunders pasted “Many-to-many ADT” at http://hpaste.org/55313
07:02:23 <osaunders> ^ what do you guys think of that
07:04:08 <byorgey> osaunders: looks neat
07:04:26 <byorgey> osaunders: however I think your implementation of appendSetsInMap could be much more efficient
07:04:47 <byorgey> osaunders: instead of repeatedly taking the minimum element of the set, just use a fold over the set
07:04:56 <byorgey> using the Foldable instance
07:05:12 <osaunders> Hm
07:06:43 <byorgey> well, perhaps "much" more efficient is overstating things... it would save you a factor of (log n).
07:06:47 <osaunders> byorgey: Would that make it faster or just nicer?
07:06:52 <byorgey> both.
07:07:03 <osaunders> How would it make it faster?
07:07:14 <byorgey> you can traverse/fold a set in O(n).  Repeatedly finding and deleting the minimum takes O(n log n).
07:07:35 <osaunders> Hm OK. I’ll do it :)
07:07:41 <kmc> yeah, i don't think theoretical log factors mean anything in the real world
07:07:49 <kmc> you have to profile to find out whether it matters
07:08:09 <kmc> but i'm all for making the code nicer :)
07:10:30 <osaunders> Yeah
07:12:51 <hpaste> osaunders annotated “Many-to-many ADT” with “Many-to-many ADT (annotation)” at http://hpaste.org/55313#a55314
07:14:28 <osaunders> OK, I have to buy Christmas presents now
07:14:36 <osaunders> I’m buying presents for everyone on #haskell
07:14:45 <osaunders> Only joking
07:14:52 <djahandarie> I WANT A-
07:14:54 <djahandarie> Oh.. :(
07:17:43 <DukeDave> osaunders: It's okay, just use lazy present evaluation, and don't buy any gift wrap :)
07:21:31 * byorgey gets everyone in #haskell their very own rational number!
07:21:34 <byorgey> > let next r = (let (n,y) = properFraction r in recip (fromIntegral n + 1 - y)) in iterate next 1 :: [Rational]
07:21:35 <lambdabot>   [1 % 1,1 % 2,2 % 1,1 % 3,3 % 2,2 % 3,3 % 1,1 % 4,4 % 3,3 % 5,5 % 2,2 % 5,5 ...
07:21:41 <djahandarie> :P
07:24:05 <byorgey> > let next r = (let (n,y) = properFraction r in recip (fromIntegral n + 1 - y)) in map numerator (iterate next 1 :: [Rational])
07:24:06 <lambdabot>   [1,1,2,1,3,2,3,1,4,3,5,2,5,3,4,1,5,4,7,3,8,5,7,2,7,5,8,3,7,4,5,1,6,5,9,4,11...
07:24:28 <byorgey> > let f 0 = 1; f 1 = 1; f n | even n = f (n `div` 2) | otherwise = f (n `div` 2) + f (n `div` 2 + 1) in map f [1..100]
07:24:28 <lambdabot>   [1,1,2,1,3,2,3,1,4,3,5,2,5,3,4,1,5,4,7,3,8,5,7,2,7,5,8,3,7,4,5,1,6,5,9,4,11...
07:31:17 <tromp> > properFraction 1
07:31:18 <lambdabot>   (1,0.0)
07:38:56 <ectod> @undo do { a <- randomSt; b <- randomSt; c <- randomSt; return (a,b,c) }
07:38:57 <lambdabot> randomSt >>= \ a -> randomSt >>= \ b -> randomSt >>= \ c -> return (a, b, c)
07:40:09 <exlevan> > (,,) <$> randomSt <*> randomSt <*> randomSt
07:40:10 <lambdabot>   Not in scope: `randomSt'Not in scope: `randomSt'Not in scope: `randomSt'
07:44:10 <ectod> @help
07:44:10 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:44:24 <ectod> @list
07:44:25 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:49:35 <teneen> In the expression:
08:50:02 <teneen> take 10 $ fix $ (0:) . (1:) . zipWith (+) <*> tail
08:50:21 <teneen> why there should be parentheses around zipWith (+) <*> tail
08:50:35 <teneen> doesn't the (.) have higher precedence than <*> ?
08:51:15 <Saizan> if it does that's the problem
08:51:26 <alistra> it has higher
08:51:45 <alistra> take 10 $ fix $ (((0:) . (1:) . zipWith) (+)) <*> tail
08:51:49 <teneen> the (.) is right associative, it should include the whole zipWith part in it's nesting
08:51:50 <alistra> it's probably like that
08:52:14 <quicksilver> a lambdabot tool which shows full bracketting based on known infixl/r values would be handy
08:52:53 <Saizan> alistra: that can't be
08:52:57 <teneen> alistra: it is take 10 $ fix $ (0:) . (1:) . (zipWith (+) <*> tail)
08:53:18 <alistra> > take 10 $ fix $ (0:) . (1:) . zipWith (+) <*> tail
08:53:19 <lambdabot>   Couldn't match expected type `a1 -> a' against inferred type `[t]'
08:53:20 <Saizan> zipWith (+) will always go togethwer
08:53:51 <alistra> > take 10 $ fix $ (0:) . (1:) . (zipWith (+) <*> tail)
08:53:52 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
08:54:22 <alistra> Saizan: i was talking about the equal term with parens, not the correct one
08:54:29 <alistra> > take 10 $ fix $ (((0:) . (1:) . zipWith) (+)) <*> tail
08:54:30 <lambdabot>   Couldn't match expected type `a -> a1 -> a'
08:54:30 <lambdabot>         against inferred type `...
08:54:40 <teneen> should it by right-associativity desugar to: take 10 $ fix $ (0:) . ((1:) . ((zipWith (+)) <*> tail)) ?!
08:54:44 <alistra> > take 10 $ fix $ ((0:) . (1:) . zipWith (+)) <*> tail
08:54:44 <lambdabot>   Couldn't match expected type `a1 -> a' against inferred type `[t]'
08:54:47 <teneen> shouldn't **
08:54:49 <alistra> this is the one
08:55:21 <alistra> application has the highest priority
08:55:31 <alistra> then (.), then (<*>)
08:55:47 <teneen> alistra: what exactly is applied first?
08:55:56 <teneen> alistra: without parenthese
08:56:13 <alistra> i don't understand the question
08:56:24 <teneen> alistra: in this  take 10 $ fix $ (0:) . (1:) . zipWith (+) <*> tail
08:56:33 <teneen> alistra: what is actually happending?
08:56:41 <alistra> well it's equal to this : take 10 $ fix $ ((0:) . (1:) . zipWith (+)) <*> tail
08:57:01 <alistra> and <*> generates a typerrror
08:57:01 <teneen> alistra: ohh
08:57:10 <alistra> because the left operand is a function
08:57:24 <alistra> and it all goes down from there
08:57:32 <alistra> not correcttly typed function*
08:57:44 <alistra> :t (zipWith (+) <*> tail)
08:57:45 <lambdabot> forall a. (Num a) => [a] -> [a]
08:57:59 <alistra> :t ( <*> tail)
08:58:00 <lambdabot> forall b a. ([a] -> [a] -> b) -> [a] -> b
08:58:09 <benmachine> quicksilver: that would not be hard to write, either
08:58:11 <alistra> :t ((0:) . (1:) . zipWith (+))
08:58:12 <lambdabot>     Couldn't match expected type `[t]'
08:58:12 <lambdabot>            against inferred type `[a] -> [a]'
08:58:12 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
08:58:14 <teneen> alistra: is there any operator which can fix this, without having to add parentheses?
08:58:50 <alistra> take 10 $ fix $ (0:) . (1:) . (zipWith (+) <*> tail)
08:59:04 <alistra> > take 10 $ fix $ (0:) . (1:) $ zipWith (+) <*> tail
08:59:05 <lambdabot>   Couldn't match expected type `[a -> t]'
08:59:05 <lambdabot>         against inferred type `[a1]...
08:59:07 <alistra> hmm
08:59:27 <alistra> > take 10 $ fix $ (0:) . (1:) $ (zipWith (+)) <*> tail
08:59:28 <lambdabot>   Couldn't match expected type `[a -> t]'
08:59:28 <lambdabot>         against inferred type `[a1]...
09:00:05 <alistra> @pl take 10 $ fix $ (0:) . (1:) . (zipWith (+) <*> tail)
09:00:06 <lambdabot> take 10 (fix ((0 :) . (1 :) . (zipWith (+) <*> tail)))
09:00:37 <alistra> @unpl take 10 $ fix $ (0:) . (1:) . (zipWith (+) <*> tail)
09:00:37 <lambdabot> (take 10 (fix (\ i -> 0 : (1 : (((zipWith (+)) <*> tail) i)))))
09:01:36 <alistra> teneen: sorry, don't know :/
09:02:51 <teneen> alistra: ok thanks :)
09:06:55 <alistra> maybe just try that:
09:07:25 <alistra> > let f = 1 : 1 : zipWith (+) f (tail f) in take 10
09:07:26 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
09:07:27 <lambdabot>    arising from a use ...
09:07:48 <alistra> > let f = 1 : 1 : zipWith (+) f (tail f) in take 10 f
09:07:49 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
09:07:58 <alistra> @pl let f = 1 : 1 : zipWith (+) f (tail f) in take 10 f
09:07:58 <lambdabot> take 10 (fix ((1 :) . (1 :) . ap (zipWith (+)) tail))
09:08:12 <alistra> so it's
09:08:23 <kmc> > fix ((0:) . scanl (+) 1)
09:08:25 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
09:08:45 <alistra> > take 10 $ fix $ (1:1:) . ap (zipWith (+) tail)
09:08:46 <lambdabot>   The operator `:' [infixr 5] of a section
09:08:46 <lambdabot>      must have lower precedence th...
09:08:54 <alistra> > take 10 $ fix $ (1:) . (1:) . ap (zipWith (+) tail)
09:08:55 <lambdabot>   Couldn't match expected type `[a]'
09:08:55 <lambdabot>         against inferred type `[a1] -> [...
09:09:02 <alistra> meh
09:09:23 <rwbarton> > take 10 $ fix $ (.) (0 :) $ (.) (1 :) $ zipWith (+) <*> tail
09:09:25 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
09:09:29 <alistra> > take 10 $ fix $ (1:) . (1:) . ap (zipWith (+)) tail
09:09:31 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
09:11:08 <xplat> @@ @elite @help @
09:11:08 <lambdabot> Plugin `compose' failed with: Unknown command: ""
09:11:21 <alistra> and I wondered why people laught that haskell is only good for writing fibonacci series
09:12:00 <kmc> @quote _pizza_
09:12:00 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
09:13:02 <alistra> > take 10 $ fix $ (1:) . (1:) . (flip . ap) tail $ zipWith (+)
09:13:02 <lambdabot>   Couldn't match expected type `[a -> t]'
09:13:03 <lambdabot>         against inferred type `m a1...
09:13:06 <alistra> meh
09:13:13 <alistra> i'm not that good at this
09:14:32 <Patinho`Busy> hi all
09:14:56 <plalloni> hi everyone here
09:15:03 <cyberhog> hi all
09:15:46 <kmc> hi
09:16:01 <cyberhog> I'm a beginner and need to know how/where you save a function with ext *.hs
09:16:27 <kmc> you just do?  i don't understand the question
09:16:32 <roconnor> cyberhog: with notepad
09:16:38 <kmc> you put some haskell code in a file with name ending in .hs
09:16:41 <kmc> using your favorite text editor
09:16:48 <kmc> then you can load it like so:  ghci foo.hs
09:16:52 <alistra> roconnor: nobody uses notepad :|
09:16:54 <kmc> or build an executable:  ghc --make foo.hs
09:17:04 <roconnor> alistra: what happened in the last 10 years?
09:17:15 <cyberhog> Do you save it to the bin folder?
09:17:26 <kmc> what bin folder?
09:17:33 <alistra> what's a bin folder?
09:17:37 <kmc> you mean like /usr/bin? no
09:17:44 <cyberhog> the on in the haskel directory
09:17:44 <roconnor> cyberhog: what OS?
09:17:48 <alistra> like a trash bin in windows
09:17:50 <cyberhog> win 7
09:17:53 <kmc> no
09:17:58 <kmc> just make a fresh folder for your project
09:18:08 <kmc> wherever
09:18:08 <tromp> @let fibab a b = fibs where fibs = a : scanl (+) b fibs
09:18:09 <lambdabot>  Defined.
09:18:17 <alistra> @src scanl
09:18:17 <lambdabot> scanl f q ls = q : case ls of
09:18:18 <lambdabot>     []   -> []
09:18:18 <lambdabot>     x:xs -> scanl f (f q x) xs
09:18:19 <kmc> wherever you like to keep your filez
09:18:33 <roconnor> > fibab 01
09:18:33 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> [t])
09:18:34 <lambdabot>    arising from a use of...
09:18:34 <roconnor> > fibab 0 1
09:18:36 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
09:19:06 <alistra> cyberhog: try a not windows OS, it'll be easier
09:19:39 <roconnor> alistra: I think that is a bit unrealistic of a suggestion for a beginner
09:19:42 <applicative> cyberhog, it doesn't matter, don't listen to alistra.
09:20:02 <applicative> cyberhog: except on matters of the content of your file
09:20:03 <roconnor> cyberhog: I agree with applicative
09:23:14 <kmc> cyberhog, alistra isn't wrong; developing on Linux will be a bit easier, but not enough to offset the difficulty of having to install and learn Linux.  however, that's a worthwhile goal itself
09:23:31 <kmc> anyway it's not relevant to your question, you'd do the same thing on either os
09:25:29 <applicative> this is not a linux irc;  os prejudices are, in my view, totally out of place especially in the present context.
09:25:47 <rwbarton> this isn't a prejudice
09:25:54 <applicative> though i certainly don't want to be gloomy about the matter :)
09:26:03 <kmc> it's not 'prejudice', it's a reasoned opinion that linux is a better environment for software dev
09:26:06 <kmc> based on experience with both
09:26:09 <kmc> that's what makes it not 'pre-'
09:27:06 <kmc> (i haven't done any windows dev in a long while, though)
09:27:24 <applicative> immense labors have been put into getting our compiler to work on the familiar platforms
09:28:01 <kmc> just because you disagree with my evidence-based conclusion does not mean it's 'prejudice'
09:28:08 <alistra> applicative: it's not a particularly good argument to do something, because somebody already put a lot of work in it
09:28:13 <Philippa> mmm. So why doesn't the haskell platform come with proper docs on my system? Oh, wait, it's windows
09:28:21 <kmc> i'd like it if you'd retract that statement
09:28:23 <Philippa> not that that one's the OS's fault
09:28:41 <roconnor> Hi Philippa
09:29:00 <Philippa> hi roconnor - how goes? Sorry about the lack of blog activity, I may have a slowish part one of a two-parter up soon though
09:29:18 <roconnor> Don't worry about it
09:29:37 <roconnor> I'm writing ocaml today :^)
09:29:53 <Philippa> meh, I could use interested people prodding me once in a while :-) Heh, doing anything interesting in it?
09:29:56 <roconnor> world's worst imperative langauge
09:29:57 <xplat> copumpkin: what stackoverflow question did you just get answered?
09:30:08 <kmc> we're always bragging about how #haskell is so nice and friendly
09:30:18 <hpaste> “Patinho`Busy ” pasted “problem with an aux function” at http://hpaste.org/55319
09:30:32 <Patinho`Busy> I need some help pls.... :)
09:30:35 <Patinho`Busy> anyone?
09:30:36 <kmc> it does not seem very friendly to personally attack someone because they have different preferences about operating systems
09:31:09 <kmc> especially when it's based on relevant experience (ease of software development)
09:31:46 <Philippa> I think it's your behaviour that was "attacked", you may be taking this a little too personally and/or severely - the point's been made
09:32:01 <kmc> i'm waiting for applicative to retract the claim that i'm "prejudiced"
09:32:05 <kmc> (and that others are)
09:32:12 <kmc> that's totally crossing the line
09:32:25 <Botje> Patinho`Busy: so you want to generate a foo that already knows about the xxs?
09:32:50 <Philippa> the claim was about your statement, not you. And honestly? You're probably not going to get it at this point, much as a gentle apology wouldn't be out of order
09:32:57 <xplat> kmc: that's true; on the other hand, that's kind of like responding to everyone's car repair questions with 'you shouldn't buy american cars, they're hard to work on'
09:33:08 <kmc> i said "developing on Linux will be a bit easier"
09:33:11 <KitB> What was that thing called that allows me to develop in a sandboxed environment?
09:33:11 <Botje> Patinho`Busy: otherwise you'll have to explain where the xxs comes from in your second case
09:33:12 <Patinho`Busy> yeap Botje
09:33:12 <KitB> Oop, just remembered
09:33:13 <kmc> this is a true statement in my experience
09:33:19 <kmc> i don't think it's unreasonable
09:33:25 <KitB> cabal-dev
09:33:26 <Botje> Patinho`Busy: that's just foo1 = foo xxs
09:33:40 <KitB> Also should you guys not take this discussion over to #haskell-blah?
09:33:40 <Patinho`Busy> :|
09:33:53 <kmc> i'm gonna take it to /dev/null
09:34:03 <Patinho`Busy> lol
09:34:05 <Patinho`Busy> loooooooooooooool
09:34:08 <Patinho`Busy> xD
09:34:42 <alistra> it's funny, because windows users don't know what it is
09:35:10 <cyberhog> I need help compiling>  :1 baby x     chci returns unknown command.  Any suggestions?
09:35:12 <Philippa> yeah, I have no idea. It's almost as if I've only used one OS in my life
09:35:28 <Philippa> cyberhog: what are you trying to do, exactly?
09:35:34 <NihilistDandy> Any Core aficionados about who can answer a very simple question?
09:35:56 <Philippa> you probably want :l rather than :1, or just use file associations to load the file from explorer
09:36:45 <cyberhog> compile a function I create with notepad and save as baby.hs in mydocuments
09:37:05 <Philippa> okay. Do you have any experience with console apps before now?
09:37:14 <cyberhog> no
09:37:19 <Philippa> double-clicking baby.hs is quickest
09:37:22 <applicative> we are explaining it to him
09:38:08 <Philippa> alternatively, learn your way around the windows command prompt a little, then get it into your documents folder and run ghci from it - that way, ghci is looking to load files from the documents folder. Then :l baby
09:38:12 <applicative> does the haskell platform installation make that association ?
09:38:17 <Philippa> I believe so
09:38:22 <applicative> cool
09:38:35 <NihilistDandy> Or :cd from within ghci
09:38:37 <Philippa> plus I've not been told it doesn't work, so I'm assuming that cyberhog hasn't tried it yet :p
09:38:44 <cyberhog> Ok, it worked....thanks
09:38:44 <Philippa> NihilistDandy: yeah, was about to look that up
09:39:03 <dolio> roconnor: You should try scala.
09:39:07 <applicative> oh awesome
09:39:14 <Philippa> I forget whether it does the right substitution for the usual windows shortcuts to work, mind
09:39:36 <Philippa> you might be stuck going to /Users/$username/Documents (assuming a typical win7 installation) the long way
09:39:59 <Philippa> cyberhog: find a command prompt tutorial somewhere sometime, btw. It's useful knowledge
09:40:04 <Philippa> anyway, glad to've helped!
09:41:26 <Patinho`Busy> ups… where is my education… ty  Botje _o_
09:44:25 <Botje> no problem
09:44:26 <Botje> enjoyè
09:44:55 <copumpkin> xplat: about enumerators that retry
09:45:00 <Patinho`Busy> :)
09:46:50 <copumpkin> xplat: the ever-retrying enumerator that reconnects when it gets disconnected from the socket that I mentioned
09:46:56 <copumpkin> mm_freak wrote it for me, basically
09:48:54 <parcs`> yes, ghc on windows totally blows
09:49:23 <parcs`> try pressing ^C in ghci on windows -- it randomly panics with an 'unreachable mvar' error
09:53:51 <roconnor> dolio: is scala a worse imperative language than ocaml?
09:54:25 <parcs`> not to mention it requires cygwin... how can anyone argue that ghc on windows is not worse than ghc on linux?
09:54:59 <dolio> roconnor: Probably.
09:55:03 <roconnor> parcs`: is someone arguing that?
09:55:09 <dolio> I haven't used much ocaml, though.
09:55:15 <delinquentme> NICE! ok so WHY haskell for web programming?
09:55:19 <roconnor> dolio: I could believe it
09:55:49 <roconnor> delinquentme: same reason for haskell or anything else
09:55:56 <roconnor> *for haskell for anything else
09:56:20 <delinquentme> roconnor, so i've programmed in ruby before and started w actionscript .. but never a C style language
09:56:54 <Philippa> having to write your state out explicitly helps you avoid mistakes, support for doing it aids factorings that exploit having it as first class instead of baked-in
09:57:07 <Philippa> both of which are pretty useful in something distributed
09:57:29 <delinquentme> so I know next to nothing about haskell and i've limited experience with core programming languages .. correct me if im wrong but haskell includes some depth that scripting languages dont right?
09:57:46 <roconnor> depth?
09:57:54 <Philippa> honestly, "scripting language" isn't really such a useful concept any more
09:57:56 <dolio> I don't think I'd call Haskell a C style language.
09:58:08 <delinquentme> roconnor, yeah its ambiguous bc i dont really understand haskell :D
09:58:13 <c_wraith> wait, haskell isn't C-style?
09:58:17 <Philippa> it mostly works to identify languages that're descending from things like command prompts, which doesn't tell you a lot
09:58:24 <Philippa> c_wraith: but it has braces and semicolons!
09:58:28 <c_wraith> But I can put in curly braces and semicolons!
09:58:38 <delinquentme> dolio, nah i think its called a "type interface" language?
09:58:40 <Philippa> delinquentme: the type system will be a major difference
09:58:51 <roconnor> delinquentme: haskell has a totally different paradigm for programming than essentially all other languages.
09:59:11 <delinquentme> roconnor, is it not like scala?
09:59:12 <Philippa> the other biggies coming from something like ruby are the lack of state baked into the language (you can't update values in variables) and lazy evaluation
09:59:34 <delinquentme> Philippa, so all vars are immutable?
09:59:37 <Philippa> exactly
09:59:38 <c_wraith> haskell is really not much like scala.  scala can be used like haskell, but it's not what scala was really designed to make easy.
09:59:49 <roconnor> the two most important features of Haskell are: (1) type system, and (2) strong support for a style of denational semantics/equational reasoning (even if it isn't perfect).
09:59:54 <copumpkin> delinquentme: yeah, and you don't have built-in statements, either
09:59:57 <copumpkin> delinquentme: only expressions
10:00:12 <delinquentme> no built in statements??
10:00:12 <Philippa> copumpkin: I believe the report names various things "statements", but sure :p
10:00:35 <Philippa> delinquentme: you don't need them, you can build statement-like-things out of expressions
10:00:39 <Philippa> the expressions are more powerful though
10:00:45 <delinquentme> ahh
10:00:51 <copumpkin> delinquentme: the basic language doesn't allow you to say "do x, then do y". We construct that notion using expressions
10:00:51 <delinquentme> is it faster than C
10:00:53 <Philippa> for example, let ones = 1 : ones in take 4 ones <- all one expression
10:00:55 <delinquentme> and in what instances?
10:01:01 <copumpkin> delinquentme: exactly 173% faster, yes
10:01:03 <kmc> languages don't have speed
10:01:08 <delinquentme> lol
10:01:08 <roconnor> delinquentme: we have an abstract data structure that has some primitive constructions that perform similar functions to statements in other langauges.
10:01:23 <kmc> i think you should learn Haskell rather than asking newspaper-reporter questions about it
10:01:30 * delinquentme is glad this is a lol-enabled zone .. unlike #python
10:01:32 <kmc> RWH and LYAH each have an intro section which will answer some of these
10:01:37 <Philippa> delinquentme: you can achieve performance in the same ballpark as C, but it's sometimes hard work. The direction you have to think in is quite different from C though
10:01:42 <roconnor> delinquentme: understanding how to this abstact data structure is a big hurdle for those coming from other langauges.
10:01:45 <kmc> so does http://haskell.org/haskellwiki/FAQ
10:01:51 <Philippa> Haskell gives you a lot more support in doing what you intended at a high level than C does, though
10:02:10 <Philippa> (learn C one of these days, but don't assume it's a good language for most purposes without learning alternatives)
10:02:23 <delinquentme> Philippa, so when I hear "high level" it usually equates to the same operation with less typing legwork
10:02:34 <Philippa> yeah, I don't mean that myself
10:02:34 <companion_cube> kmc: languages with exactly one implementation, do they have speed ?
10:02:40 <kmc> no
10:02:41 <Philippa> I mean it in the Perlis sense
10:02:50 <Philippa> a program is high-level when it contains no attention to the irrelevant
10:03:01 <Philippa> (a programming language is high-level insofar as it allows writing high-level programs)
10:03:23 <Philippa> C makes me do a bunch of book-keeping I rarely care about: for most programs I write, it's not high-level
10:03:56 <delinquentme> Ok so the programming paradigm is a ig thing
10:04:00 <delinquentme> is*
10:04:13 <delinquentme> so then can I ask what make you as individual decide to pickup scala
10:04:17 <Philippa> yes. Basically it's that and the type system that're worth learning Haskell for
10:04:47 <Philippa> I've decided not to - it looks like a lot of mess, the syntax is heavier-weight than I'm now comfortable with and I'm not convinced it has strong enough pay-offs for me
10:05:00 <delinquentme> oh and also are there any bioinformaticists who would say a few words about progamming bio programs in haskell
10:05:10 <Philippa> as for haskell? I was interested in programming language implementation a decade back and algebraic datatypes + pattern matching were something I needed very badly
10:05:19 <Philippa> somewhere, I don't know if they're in chan though
10:05:33 <Philippa> there are regular expression tools though: you can do everything you'd do in perl
10:05:37 <kmc> i think GHC's good support for concurrency and parallelism is a big reason to learn Haskell
10:05:48 <delinquentme> GHC?
10:05:53 <kmc> GHC is the most popular haskell compiler
10:06:07 <delinquentme> ah ok so this is also a compiled language
10:06:14 <kmc> you can compile it, or you can interpret it
10:06:16 <kmc> same as any language
10:06:41 <Philippa> yeah, "interpreted language" was a distinction from back when compiler technology wasn't Good Enough for certain tasks. It is now
10:06:47 <kmc> most Haskell code is run in GHCi's bytecode interpreter, or compiled to native code with GHC
10:07:02 <kmc> Haskell is a standardized language, and there are other implementations, but GHC is by far the most popular
10:07:04 <delinquentme> kmc, you mentioned RWH and LYAH   << newbie appropriate?
10:07:06 <kmc> (that's in the FAQ, too)
10:07:11 <kmc> yes, they are intro books
10:07:12 <kmc> @where LYAH
10:07:12 <lambdabot> http://www.learnyouahaskell.com/
10:07:14 <kmc> @where RWH
10:07:14 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
10:07:36 <delinquentme> are either of those web-tilted?
10:07:43 <Philippa> LYAH is probably more newbie appropriate than RWH unless you're a confident hacker
10:07:51 <kmc> delinquentme, no
10:07:53 <delinquentme> kk
10:07:58 <Philippa> I think RWH has a couple of web-relevant exercises, but not particularly so
10:08:01 <rwbarton> personally I recommend LYAH for newbies, RWH's strengths are more in the more advanced topics
10:08:02 * kmc tries to avoid the word 'hacker'... too much baggage
10:08:10 <NihilistDandy> The new Craft is pretty good, too
10:08:16 <applicative> delinquentme:  there are bioinformatics people using haskell, or did someone say that
10:08:24 <NihilistDandy> Lots of QuickCheck
10:09:02 <applicative> delinquentme: see the bioinformatics section on hackage http://hackage.haskell.org/packages/archive/pkg-list.html
10:09:02 <Nafai> NihilistDandy: Craft?
10:09:14 <NihilistDandy> Nafai: Craft of Functional Programming
10:09:30 <NihilistDandy> Simon Thompson
10:09:33 <Nafai> Ah, cool.
10:09:42 <applicative> delinquentme: here is a page for some people who have recently been very active http://www.tbi.univie.ac.at/~choener/haskell.html
10:09:57 <delinquentme> applicative, cool!
10:10:01 <delinquentme> TYVMs
10:10:23 <shapr> Ketil Malde does bioinformatics with Haskell last I heard.
10:10:44 <applicative> yes, he's the person most visible in typical forums
10:13:14 <delinquentme> thanks guys!
10:16:03 <NihilistDandy> @src putStrLn
10:16:04 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
10:16:15 <NihilistDandy> @src putStr
10:16:16 <lambdabot> putStr s  = hPutStr stdout s
10:16:22 <NihilistDandy> @src hPutStr
10:16:22 <lambdabot> Source not found. There are some things that I just don't know.
10:19:32 <kmc> ghc defines hPutStr in GHC.IO.Handle.Text
10:19:35 <kmc> it's not exactly pretty
10:19:35 <cyberhog> Need help....again: using win 7. Need to know how to compile function with WinGHCi, function is doubleSmallerNumber.hs which involves an if statement.
10:19:46 <xplat> has anyone thought about doing a better @src plugin?
10:20:16 <kmc> "if" isn't a statement, it's an expression
10:20:30 <kmc> files aren't functions; a file defines an entire module, which can contain multiple functions and other stuff
10:20:48 <kmc> and ghci isn't a compiler; you'd use ghc to compile stuff
10:21:02 <kmc> anyway, what do you want to produce?  a standalone executable?
10:21:12 <kmc> or you just want to test this one function?
10:21:37 <cyberhog> a stand alone
10:22:01 <kmc> what does the program do when you run it?
10:22:24 <cyberhog> if a number is smaller than 100 it squares it
10:22:32 <kmc> a number? from where does this number come?
10:23:12 <cyberhog> I enter it as a peramiter
10:23:19 <kmc> at the command line?
10:23:24 <cyberhog> yes
10:23:40 <kmc> if you want to compile your module as a stand-alone program, you need to define an IO action named 'main'
10:23:47 <kmc> which describes what should happen when the program runs
10:23:50 <kmc> did you do that?
10:24:09 <Philippa> cyberhog: definitely not the "ghci command line"?
10:24:48 <cyberhog> no
10:25:02 <roconnor> oh man, ocaml has function bindings for record syntax!
10:25:09 <roconnor> Haskell is missing out!
10:25:12 <kmc> cyberhog, you know that ghci is a much more convenient way to test your code, right?
10:25:14 <cyberhog> I'll try that, but how do you save it from main?
10:25:44 <kmc> what?
10:25:52 <Philippa> roconnor: I've suggested we should have that a few times, but meh. We need a concrete proposal for that
10:26:03 <roconnor> pfft
10:26:05 <roconnor> too much work
10:26:24 <Philippa> heh. You, me and everyone else who's fed up of the current state of affairs!
10:27:22 <mike-burns> Oh, that ocaml syntax is nice!
10:27:38 <roconnor> a rare instance when ocaml syntax is nicer
10:27:48 <Peaker> I just realized that it's possible to make a combinator for eagerness without strictness on pure exception bottoms specifically.. Javascript seems to do that by having pure exceptions result in a NaN that only yells when forced
10:28:39 <donri> cyberhog: maybe start with http://www.haskell.org/haskellwiki/Introduction_to_IO
10:28:48 * roconnor has no idea what Peaker just said
10:29:17 <Peaker> roconnor: eagerness can have useful operational semantics.. strictness can be bad. You can have the former without the latter, if all your bottoms are exceptions and not non-termination
10:29:41 <Philippa> obPoint: an exception isn't really a bottom any more
10:29:50 <benmachine> non-termination is kind of important
10:29:53 <roconnor> Peaker: right
10:30:05 <Philippa> (though I'll happily accept that we're lifting into something where there's non-termination and exceptions, for example)
10:30:40 <Peaker> benmachine: sure, but that may be an interesting tool in some cases
10:30:49 <Peaker> benmachine: and virtually all the bottoms I encounter in the wild are not non-termination
10:31:07 <roconnor> benmachine: it's not *that* important.  I'd be quite happy to remove non-termination from Haskell :P
10:31:18 <kmc> not i
10:31:28 <roconnor> kmc: I'll give it back as a monad.
10:31:34 <kmc> ok
10:31:50 <roconnor> kmc: and akward difficult to use monad.
10:31:52 <roconnor> *an
10:32:06 <rwbarton> a monad seems like a pretty inconvenient interface for general recursion, yes
10:32:07 <Peaker> roconnor: why?
10:32:34 <kmc> fix :: (a -> a) -> IO a --?
10:32:54 <rwbarton> right but this "general recursion" monad is e.g. commutative
10:32:56 <roconnor> Peaker: because proving productivity by syntaxtic crieterion seems very restrictive for presently used crieterion.
10:33:32 <Peaker> roconnor: that would make code outside the monad difficult to use...
10:33:37 <Peaker> roconnor: the monad would be dandy :)
10:34:26 <copumpkin> roconnor: have you looked at conor's crazy stuff?
10:34:31 <roconnor> copumpkin: nope
10:35:39 <rwbarton> also trying to work in a language without general recursion and no data types (as opposed to codata) sounds bad
10:35:45 <copumpkin> roconnor: this stuff: http://personal.cis.strath.ac.uk/~conor/pub/Hmm/FixTomorrow.agda
10:36:11 <xplat> Peaker: i think he wants to make the monad difficult to use so people won't just give up on programming outside it
10:36:45 <copumpkin> Peaker: I think someone asked about that on the dependent types subreddit recently
10:37:52 <copumpkin> hm, maybe not
10:38:05 <Peaker> I guess detectable partiality is really just an ambient either monad
10:38:11 <roconnor> xplat: no no, I'd like it to be easy to work with coinductive data types, but I don't know how.
10:38:12 <copumpkin> http://www.cse.chalmers.se/~nad/listings/lib/Category.Monad.Partiality.html#1
10:38:34 <copumpkin> that monad is hard to use, so it meets roconnor's criterion
10:38:35 <roconnor> xplat: I can write simple things, but anything moderately complex and it becomes really hard.
10:39:03 <rwbarton> it sounds like both programming inside the monad and programming outside the monad is going to be hard
10:39:18 <roconnor> (and in coq, coinductive types make the system no longer have subject reduction :^)
10:39:51 <copumpkin>   now-or-never : Reflexive _∼_ →
10:39:51 <copumpkin>                  ∀ {k} (x : A ⊥) →
10:39:51 <copumpkin>                  ¬ ¬ ((∃ λ y → x ⇓[ other k ] y) ⊎ x ⇑[ other k ])
10:39:54 <copumpkin> it's now or never guys
10:40:12 <roconnor> I guess there are systems in development trying to have dependent types and general recursion. ... It would be interesting to see those semantics.
10:42:03 <jfincher> anyone have a link handy that can explain to me how typeclasses are implemented in ghc (e.g., dictionary-passing and whatnot)
10:42:34 <xplat> roconnor: it makes terms able to reduce to terms of a different type?!
10:42:40 <c_wraith> jfincher: oh, man.  I just watched a simonpj presentation that talked about that
10:42:49 <c_wraith> I wonder if I can find it again.  I think it was a channel9 thing
10:42:59 <roconnor> xplat: worse; I think it reduces terms to terms that are not well typed
10:44:21 <c_wraith> jfincher: http://channel9.msdn.com/posts/MDCC-TechTalk-Classes-Jim-but-not-as-we-know-them is the presentation I was thinking of.  He discusses their implementation early on
10:44:46 <roconnor> xplat: http://permalink.gmane.org/gmane.science.mathematics.logic.coq.club/3600
10:44:49 <jfincher> c_wraith: awesome, I'll watch that when I get home.
10:45:02 <jfincher> I'd love a textual presentation, though, so I can read it now :)
10:45:42 <c_wraith> Eh, not much to it, really.  class constraints are converted to arguments at compile-time, and dictionaries are explicitly passed around.
10:46:53 <Philippa> jfincher: I think the early Wadler paper on type classes covers the basics - it's all about evidence passing
10:47:23 <xplat> i wonder what exactly is meant by 'most streams don't start with cons' ...
10:49:04 <c_wraith> oh, and instances are converted to data types
10:49:28 <c_wraith> xplat: Perhaps it means "most streams start with a computation that will eventually result in a cons"?
10:50:02 <dolio> Inasmuch as I'd agree with it, no streams start with a cons.
10:50:40 <dolio> Streams are just values that you can observe to yield a cons (or not?).
10:50:53 <xplat> haskell seems to have no (small-step) subject reduction problems with pattern matching on codata
10:50:57 <dolio> The observation is a cons, not what the stream is built out of.
10:51:17 <dolio> And muddling the two is what leads Coq to trouble.
10:51:23 <dolio> (And Agda, previously.)
10:51:32 <dolio> Haskell doesn't have codata appearing inside types.
10:57:42 <dgpratt> <SPJ>: "I, too, have just come from the code face"; ha ha, good one, Simon
11:00:14 <salisbury> is mmap safe to use in a forkIO'ed environment
11:00:16 <salisbury> ?
11:00:26 <Peaker> salisbury: why not?
11:01:02 <salisbury> It warns against multiple programs using the mmapped file, so I was unsure of multiple processes
11:03:01 <salisbury> I suppose once each process uses the same mmap reference
11:03:12 <salisbury> it should be fine
11:03:21 <c_wraith> forkIO doesn't even mean multiple processes
11:03:32 <c_wraith> nor even multiple threads, unless you use the threaded runtime
11:03:51 <c_wraith> forkIO is purely about concurrency as a design aid
11:04:55 <salisbury> I am using the threaded runtime
11:05:05 <c_wraith> it's still all the same process
11:05:43 <salisbury> oh I thought it was a wrapper on fork(2)
11:05:58 <c_wraith> no.
11:06:06 <c_wraith> forkIO is not even *close* to fork(2)
11:06:11 <c_wraith> it creates a new green thread
11:06:19 <c_wraith> that is scheduled by the ghc runtime
11:06:34 <c_wraith> the runtime will multiplex green threads over OS threads if you use the threaded runtime
11:06:39 <c_wraith> But it's still all once process
11:09:57 <salisbury> ok, that fine then
11:10:39 <salisbury> that's*
11:13:01 <ketil> sorry for OT, but I can't find this anywhere: what is the title of the person at an examination who sets the grade?  In Norwegian it is the 'censor', but I have a feeling that's not the right word in English.
11:14:05 <jfincher> ketil: teacher, professor, examiner, proctor
11:14:13 <rwbarton> grader (American) / marker (British, I think)?
11:14:23 <rwbarton> or maybe I don't understand the question
11:14:27 <hpc> the proctor is the one who administers the exam, not the one who grades it
11:14:30 <jfincher> a "proctor" is only present for the examination (to ensure no cheating, etc.) but does not affect the grade
11:14:47 <jfincher> ketil: maybe you just want "grader"
11:14:54 <mwc> how about evaluator?
11:15:19 <jfincher> e.g., for large university classes, individual teaching assistants may grade the exams, rather than the professor teaching the course
11:15:29 <jfincher> they would be called "graders" at least in my midwestern American dialect.
11:15:53 <integral> there's sometimes a formal examiner or external examiner who's named for exams, but they're not necessary responsible for personally writing or marking the papers
11:17:13 <hpc> ive always structured my sentences around "graded by..." rather than "the grader..."
11:20:11 <ketil> Looks like there's varying practice.  IME, the teaching professor usually is the examiner, with a professor from a different institution setting the grades.
11:20:41 <rwbarton> I guess I don't know what "setting the grades" means.
11:21:58 <EvanR-work> hpc: english professors will mob you for that!
11:22:03 <rwbarton> is it the process of reading each student's answers and assigning them scores?
11:23:34 <hpc> EvanR-work: good; my other passtimes are using semocolons everywhere, putting commas "outside the quotes", and using the oxford comma
11:24:10 <EvanR-work> i generally eschew capitalization and punctuation entirely
11:24:14 <hpc> (all things that have annoyed my english teachers in high school)
11:24:42 <EvanR-work> which really annoys ##c ;)
11:25:16 <hpc> haha
11:26:40 <hpc> i annoyed a couple of people on another network by saying i implemented a zork command in my IRC bot, then gave them the syntax for my mueval command
11:26:43 <hpc> "> go north"
11:26:48 <hpc> "you have been eaten by a grue"
11:26:51 <hpc> "> light lamp"
11:26:56 <hpc> "actually, it is a heavy lamp"
11:27:28 <EvanR-work> lol
11:33:55 <tgeeky> "> go north"
11:34:01 <tgeeky> "liar! the south will rise again!"
11:34:57 <maltem> "> go"   "Could not match expected type: "
11:41:50 <hpc> :t text
11:41:51 <lambdabot> String -> Doc
11:42:07 <hpc> the next step is to make Doc an instance of IsString
11:42:20 <hpc> and (e -> Doc) an instance of IsString
11:42:35 <hpc> then define "go" with variadic magic
11:42:41 <hpc> :D
11:49:52 <McManiaC> lass SelectPastes res where selectStr :: String
11:49:56 <McManiaC> class*
11:49:57 <McManiaC>     The class method `selectStr'
11:49:57 <McManiaC>     mentions none of the type variables of the class SelectPastes res
11:50:19 <McManiaC> why is this necessary? how can I make that String fixed for the given instance?
11:50:45 <McManiaC> I know I saw this before, do I need any extensions? :)
12:01:05 <monochrom> it is necessary because if you have "instance SelectPastes A" and "instance SelectPastes B", then whenever you say "selectStr", how do you convey whether it's A's selectStr or B's selectStr?
12:02:00 <monochrom> it is not like you are talking to a mathematician and you can just write "selectStr_A"
12:02:52 <McManiaC> hm
12:03:26 <McManiaC> so the common implementation for this is "foo :: res -> String" and "foo (undefined :: res)"?
12:04:09 <monochrom> if you insist, you could hope for a futuristic extension called "SystemFomegaPlusPlus", which will allow you to write like "selectStr_A" indeed
12:04:31 <monochrom> yes
12:04:52 <monochrom> for example Storable does it, e.g., its "size" method
12:05:26 <McManiaC> yup
12:05:33 <McManiaC> just saw that in the wiki
12:13:55 <fagott> distryslaves
12:19:11 * monochrom decides to skip every thread Gregory Crosswhite starts in haskell-cafe. what an annoyance who keeps creating new threads if his will is not done.
12:24:59 * hackagebot zeromq-haskell 0.8.2 - Bindings to ZeroMQ 2.1.x  http://hackage.haskell.org/package/zeromq-haskell-0.8.2 (ToralfWittner)
12:27:30 <salisbury> There is a blog post with lots of graphs somewhere about Data.HashTable.ST.Cuckoo that I can't seem to find. Does anyone know the one/have a link?
12:32:13 <vrook> Is Data.HashTable deprecated? I tried to use it recently and was surprised that it requires the IO monad, which seems like a wart.
12:33:36 <vrook> Why would it use the IO monad? Hashing has nothing to do with IO. Is it because using a monad transformer is inconvenient?
12:34:13 <monochrom> mutable data
12:34:58 <monochrom> then again, if you wonder that it could be just ST, you are right
12:35:58 <vrook> Did Data.HashTable exist before ST?
12:36:08 <vrook> That's why I figured it was deprecated.
12:36:09 <Sgeo> Is there a nice convenient way to use ST stuff from IO?
12:36:37 <Sgeo> @hoogle ST s a -> IO a
12:36:38 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
12:36:38 <lambdabot> Control.Monad.ST runST :: (forall s. ST s a) -> a
12:36:38 <lambdabot> Control.Monad.ST.Lazy runST :: (forall s. ST s a) -> a
12:36:54 <Sgeo> Why is STToIO unsafe?
12:36:55 <monochrom> after ST. dunno why it has no ST version
12:37:16 <Sgeo> @hoogle STRef -> IORef
12:37:17 <lambdabot> Did you mean: STRef a a -> IORef a
12:37:17 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:37:17 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
12:37:28 <Sgeo> @hoogle STRef s a -> IORef a
12:37:28 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
12:37:29 <lambdabot> Data.Graph.Inductive.Basic hasLoop :: Graph gr => gr a b -> Bool
12:37:29 <lambdabot> Data.Graph.Inductive.Query.DFS isConnected :: Graph gr => gr a b -> Bool
12:37:41 <Sgeo> @hoogle STRef s a -> IO (IORef a)
12:37:41 <lambdabot> Data.Graph.Inductive.Monad isEmptyM :: GraphM m gr => m (gr a b) -> m Bool
12:37:41 <lambdabot> Data.Graph.Inductive.Monad noNodesM :: GraphM m gr => m (gr a b) -> m Int
12:37:41 <lambdabot> Data.Array.MArray readArray :: (MArray a e m, Ix i) => a i e -> i -> m e
12:37:45 * Sgeo stops
12:38:23 <c_wraith> Sgeo: ST -> IO is unsafe because it lets you violate the condition that you can't mix STRefs from one place with STRefs from another
12:38:47 <Sgeo> Hmm
12:39:05 <Sgeo> So, is there no nice way to do things if you want to not write IO-versions of stuff?
12:39:17 <Sgeo> Say, if you made your own STArray, and want to use it comfortably from IO?
12:40:28 <c_wraith> well, unless you throw those refs back into an ST computation somewhere, you're fine
12:40:50 <c_wraith> ..  I guess it would be bad if you updated them and then ran the ST computation they came from, too
12:41:05 <c_wraith> But avoiding things like that, and the unsafe part shouldn't bit you.
12:41:30 <c_wraith> there's also the other direction, if you want to embed IO in ST, for something that's externally pure, but involves mutation internally
12:41:36 <c_wraith> @hoogle unsafeIOtoST
12:41:36 <lambdabot> Control.Monad.ST unsafeIOToST :: IO a -> ST s a
12:41:36 <lambdabot> Control.Monad.ST.Lazy unsafeIOToST :: IO a -> ST s a
12:41:37 <lambdabot> GHC.Conc.Sync unsafeIOToSTM :: IO a -> STM a
12:42:00 <c_wraith> (and probably mutation of foreign memory, to need IO to do)
12:42:09 <vrook> Why doesn't HashTable have its own monad? If you want to use it inside another monad then you use a transformer. I'm guessing doing that is just inconvenient, so it got punted into IO.
12:42:32 <c_wraith> how could it have its own monad?
12:42:38 <c_wraith> it depends on mutable updates.
12:42:42 <c_wraith> that means IO or ST
12:42:48 <c_wraith> and neither of those exist as transformers
12:42:58 <c_wraith> (nor can they exist as transformers)
12:43:25 <vrook> I mean from HashMonad to IO or to ST.
12:43:50 <monochrom> you can write a version that uses its own monad. upload it to hackage.
12:43:55 <c_wraith> you just mean an abstraction over the two?
12:44:09 <c_wraith> such an abstraction is hard to get right, since they are kinded differently
12:44:20 <c_wraith> STRef s a, IORef a
12:44:58 <c_wraith> You can abstract over both with type families (which was one of the motivating cases of introducing them), but it's not pretty at the moment
12:47:10 <vrook> I recently used a transformer to combine RandomMonad with ST, so I figured why not have a HashMonad.
12:47:30 <danr> c_wraith: There is a ST transformer: http://hackage.haskell.org/package/STMonadTrans-0.2
12:47:58 <c_wraith> danr: and that giant warning at the top of that page is exactly why it's not a general transformer :)
12:51:50 <shapr> Man, this Stop Online Piracy Act hearing is really upsetting me. It's only on-topic for #haskell because it could get haskell.org removed for copyright reasons.
12:52:38 <scooty-puff> maybe a stupid question, but if i have : f :: Int -> Int; f x = g x where g x = x, will the value of x be boxed/unboxed?
12:53:15 <scooty-puff> and is there a general algorithm that can be used to decide when boxing/unboxing is required - i.e. to narrow g's type to Int -> Int, even though it's really a -> a
12:53:37 <scooty-puff> (this is for a compiler, and though ghc might be a good thing to model after)
12:53:56 <monochrom> even f :: Int -> Int, f x = x uses boxed Int
12:53:59 <danr> scooty-puff: take a look at --ddump-core with (and possibly without) optimization
12:54:30 <scooty-puff> danr: ok, i'll give it a shot, thanks
12:58:33 <Peaker> specializing and unboxing everything could bring about a code explosion ala C++ templates, I wonder if it helps or harms...
12:58:35 <dmwit> f x = x does not unbox and re-box anything, even at type Int (which is a boxed Int#)
12:58:39 <vrook> c_wraith: MonadRandom has a transformer, so you can use MonadRandom + IO or MonadRandom + ST or whatever else. I don't know why HashTable didn't follow the same pattern.
12:58:55 <c_wraith> vrook: because it's something *entirely* different.
12:59:22 <c_wraith> vrook: MonadRandom needn't depend on mutability.  In fact, the canonical instance, RandT, is essentially StateT
12:59:48 <dmwit> You can tell if a function does boxing/unboxing by checking whether it does a pattern match (or calls a function which does boxing and unboxing).
13:01:54 <c_wraith> vrook: also, ST isn't an instance of MonadRandom.  This actually is a really key point.
13:04:46 <scooty-puff> dmwit: perhaps a bad example, what about:
13:04:58 <scooty-puff> f :: Int -> Int; f x = g x where g x = x + 1
13:05:45 <scooty-puff> g's inferred type is Num a => a -> a, but its only possibly used with Int, so would it be "specialized" (wrong terminology i'm sure..)
13:06:22 <copumpkin> vrook: you mean Data.HashTable? cause nobody uses it, and it hasn't really been changed since practices like those arose
13:06:37 <copumpkin> vrook: there's a much better hashtable package on hackage, but I still think nobody uses it
13:07:00 <vrook> copumpkin: yes I was talking about Data.HashTable.
13:08:56 <MostAwesomeDude> Hey, what's the canonical way to do an amb-style constraint solver? I see lots of roll-your-own stuff in the tutorials, but nothing in the standard base.
13:09:41 <monochrom> g is specialized. x is still boxed. Int is boxed.
13:10:14 <Proge> i wish i knew what that meant
13:10:22 <Proge> i have an xbox
13:10:45 <copumpkin> Proge: you trying to learn haskell?
13:10:53 <Proge> yeah :)
13:10:57 <monochrom> however, call sites of f may inline f and get rid of the box if optimizer feels like to
13:11:01 <Proge> this channel is not helping
13:11:02 <copumpkin> you should try learnyouahaskell.com!
13:11:07 <Proge> except for making me more determined
13:11:09 <copumpkin> Proge: you haven't asked any questions!
13:11:10 <shapr> Proge: Do you have specific questions?
13:11:15 <Proge> just so i can argue with you accademics
13:11:23 <copumpkin> Proge: we're not academics
13:11:28 <shapr> Proge: Er, what about the non-academics?
13:11:28 <copumpkin> stereotyping won't get you very far
13:11:30 <Proge> spelling would help too
13:11:36 <mzero> and we'd much rather help people learn than argue
13:11:39 <monochrom> I am an academic. you can argue with me. but I don't answer.
13:11:40 <Proge> hey i'm not talking about you guys
13:11:42 <Proge> you're talking
13:11:45 <shapr> Proge: I *STARTED* the #haskell channel ten years ago! and I STILL don't have a degree!
13:11:47 <scooty-puff> monochrom: ok, thanks - is there a general algorithm for this, to specialize g?  i guess is it something people bother writing papers about
13:11:49 <Proge> i'm talking about the 'others'
13:12:02 <copumpkin> Proge: the others you somehow know exist but haven't spoken to?
13:12:08 <Proge> i've watched it in here
13:12:09 <copumpkin> anyway, ask us some questions :P
13:12:11 <shapr> Proge: So wait, who do you want to argue with? I'm confused.
13:12:13 <Proge> the wall of academia
13:12:22 <shapr> Proge: We have wall climbing gear for FREE
13:12:22 <Proge> the none practical people
13:12:25 <mzero> well, let's ignore the 'others' --- what's up? need help with something? are you following Learn You a Haskell or Real World Haskell or some other guide?
13:12:25 <copumpkin> Proge: oh, I engage in plenty of that kind of talk myself, but I'm not an academic
13:12:26 <shapr> Proge: Wait what?
13:12:37 <Proge> who don't like the new skool
13:12:46 <shapr> Proge: Wait, which school?
13:12:46 <copumpkin> Proge: anyway, start learning
13:12:51 <Proge> i am trying
13:12:53 <Proge> i'm here
13:13:00 <copumpkin> Proge: read a book, tinker :)
13:13:01 <copumpkin> ask questions
13:13:09 <monochrom> I haven't paid attention to the literature on this.
13:13:09 <copumpkin> don't let scary words scare you off!
13:13:09 <shapr> Proge: Ok! Have you read Learn you a Haskell or Real World Haskell?
13:13:14 <Proge> yeah yeah i have been and had good answers
13:13:22 <copumpkin> okay, good :)
13:13:23 <scooty-puff> monochrom: k, i'll try some general searches and see if anything jumps out
13:13:25 <Proge> i just watched lesser peeps get turned away
13:13:31 <copumpkin> nobody gets turned away
13:13:36 <scooty-puff> monochrom: it so comes to mind because using type inference in a compiler, but the most general type is often too general
13:13:38 <copumpkin> I've been here for three years and haven't seen people get turned away
13:13:39 <Proge> wavewave told me about real world haskell
13:13:42 <mzero> or watch this: http://www.youtube.com/watch?v=b9FagOVqxmI
13:13:43 <Proge> best ive read
13:13:46 <Proge> ty
13:13:56 <mzero> if you prefer to watch an intro for newcomers
13:14:12 <mzero> but if you're already convinced to try - I suggest starting with LYAH
13:14:15 <copumpkin> Proge: keep in mind that dichotomizing into "academics" and "practical people" is going to get people pissed off in here
13:14:25 <Proge> thats my intent
13:14:29 <Proge> then we can talk :)
13:14:34 <copumpkin> Proge: so you'd best avoid that or rethink your belief that those are mutually exclusive
13:14:38 * monochrom turned away 3 million people when copumpkin was not watching
13:14:40 <shapr> Proge: Why do you want to get people upset?
13:14:41 <copumpkin> no, I mean pissed off enough to kick you out
13:14:49 <Proge> it helps me learn faster
13:14:54 <copumpkin> Proge: getting people upset intentionally is called trolling and is the best way to get kicked from anywhere
13:14:55 <shapr> Proge: That's not a good strategy here
13:15:12 <shapr> Proge: I will kick you out if you have to get people upset to learn.
13:15:13 <Proge> i'm never so bad i'd insult you enough to get kicked
13:15:24 <Proge> i like to think of it of askin provocotive questions
13:15:28 <copumpkin> Proge: don't
13:15:32 <Proge> ok
13:15:33 <Proge> why?
13:15:40 <monochrom> why are we still talking about this? walk the walk already. this is silly.
13:15:44 <copumpkin> because we all have the power to kick you, and don't like it
13:15:53 <copumpkin> learn, ask questions, don't try to piss people off
13:15:55 <Proge> isn't that horrible power
13:15:57 <copumpkin> in fact, try not to piss people off
13:16:02 <vrook> It's still not clear to me why MonadHashTable couldn't exist on its own.
13:16:04 <shapr> Proge: It is, but I feel that it is necessary power.
13:16:13 <Proge> for some people perhaps
13:16:18 <shapr> For me.
13:16:20 <monochrom> if you think shapr won't kick you for what you do, well, try it. no point "discussing".
13:16:32 <Proge> ok but when people ask
13:16:40 <Proge> you say you're asking the wrong question
13:16:41 <monochrom> > cycle ["oh you won't kick me", "yes I will"]
13:16:42 <copumpkin> vrook: you looked at http://hackage.haskell.org/package/hashtables ?
13:16:42 <lambdabot>   ["oh you won't kick me","yes I will","oh you won't kick me","yes I will","o...
13:16:43 <shapr> Proge: But I would *much* rather help you learn Haskell so you can find out what sort of awesome stuff can be done!
13:16:43 <Proge> as a standard
13:16:46 * mzero name calling and sterotyping ≠ provocative questions
13:16:58 <copumpkin> Proge: individuals in here might be less helpful, but on the whole we try to be helpful
13:17:00 <Proge> i want to learn
13:17:10 <shapr> Proge: Ok, so have you written any Haskell code?
13:17:13 <copumpkin> I basically learned haskell almost exclusively through this channel
13:17:14 <Proge> but it seems people don't understand how little i know
13:17:16 <copumpkin> I didn't follow a book
13:17:28 <Proge> like a level is assumed
13:17:29 <copumpkin> it was a remarkably pleasant experience
13:17:42 <shapr> Proge: Have you tried to write Haskell code?
13:17:43 <Proge> i'm coming from c#
13:17:53 <shapr> oh, C# has some really awesome points
13:17:58 <Proge> yes i followed a tutorial that made me angry
13:18:04 <Proge> and then dumped me in here
13:18:07 <Proge> via a web client
13:18:09 <Proge> where i stated
13:18:16 <Proge> i didn't like the tutorial
13:18:21 <vrook> copumpkin: yes, and the only offerings are ST monads and IO monads. no HashMonad.
13:18:32 <copumpkin> vrook: how do you mean?
13:18:37 <shapr> Proge: Ok, do you have any specific questions about Haskell? Is there anything that you don't understand?
13:18:47 <Proge> i think i've gotten functional programming
13:18:47 <monochrom> newtype HashMonad a = HM (IO a)
13:18:49 <Proge> however
13:19:05 <Proge> my 'click' if you like is that the english language is a form of
13:19:06 <donri> tryhaskell?
13:19:29 <mzero> we've helped many a newcomer with no experience at all -- but this isn't a class room, it is more like office hours, or section time. -- if you have a question about Haskell, just ask --
13:19:30 <Proge> i also get there are 'powers' that c# doesn't afford
13:19:44 <Proge> but not knowing the questions to ask
13:19:48 <Proge> makes it hard to learn
13:19:59 <copumpkin> Proge: it's going to take some effort on your part :)
13:20:01 <fryguybob> Proge: Sounds like you need a project to work on to generate more questions.
13:20:02 <shapr> Proge: I think you will know questions to ask by attempting to write a program with Haskell.
13:20:14 <scooty-puff> perhaps the euler problems?
13:20:16 <mzero> Then, I suggest, Proge, you go build something in Haskell - perhaps undertake the Euler problems
13:20:20 <Proge> yes but i code all day for money
13:20:26 <mzero> scooty-puff++
13:20:37 <Proge> its hard to code for free with the promise of gold for my brain
13:20:51 <shapr> Proge: you don't have to... but if you want to learn Haskell it will help.
13:20:53 <mzero> then why on earth are you here?
13:20:54 <vrook> copumpkin: I mean that why isn't there HashMonad + transformer + pick your monad, instead of just ST and IO. c_wraith says it has to do with mutability, but I don't see why that would rule out making HashMonad.
13:20:55 <copumpkin> Proge: you wanted to learn this
13:21:02 <copumpkin> Proge: it's not our job to convince you to want to learn it
13:21:03 <Proge> i'm here because i had a revalation
13:21:09 <Proge> thats its deeper than just haskell
13:21:15 <Proge> haskell is closer to my brain
13:21:18 <Proge> than c#
13:21:24 <copumpkin> vrook: what would it do in other monads?
13:21:35 <Proge> i'm already convinced
13:21:37 <shapr> Proge: so... make up your mind... do you want to learn Haskell or not?
13:21:40 <Proge> i do
13:21:51 <cotavish> haskell is a double rainbow all the way across the sky
13:21:57 <Proge> my point is you guys need to teach newbs better
13:21:58 <shapr> Proge: So, write code for free for yourself with the promise of gold at the end of the rainbow.
13:22:02 <mzero> then go forth and code - it is the only way
13:22:02 <Proge> instead of being cryptic
13:22:04 <ezyang> Is there a standard way of wrapping up Haskell values in some opaque form to pass to a C program, or do we tend to do that with foreign import "wrapper"?
13:22:21 <shapr> Proge: The Haskell documentation is not cryptic on purpose.
13:22:34 <MostAwesomeDude> Proge: If you can't even write code without worrying about your compensation, then perhaps you shouldn't be writing code.
13:22:36 <copumpkin> vrook: the issue is that hashtables _need_ mutability to be remotely efficient, so they're pretty much useless in a monad that doesn't let you mutate. The new HAMT stuff would work anywhere, but wouldn't need a monad at all
13:22:44 <mzero> telling folks to go try to code something isn't being cryptic…. "I had a revalation … closer to my breain" is pretty cryptic
13:22:45 <Proge> thats not fair
13:22:54 <shapr> Proge: it is fair.
13:22:55 <fryguybob> ezyang: StablePtr?
13:22:59 <Proge> not everyone is in the same position in life
13:23:01 <mzero> yes, yes it is
13:23:01 <copumpkin> Proge: that's what you get for trying to get people pissed off :P
13:23:03 <captwheeto> ezyang, do you mean like a pipe? Or in passing it through a FFI?
13:23:09 <copumpkin> Proge: you get people pissed off, and they get confrontational towards you
13:23:10 <Proge> this convo?
13:23:12 <Proge> i'm learning
13:23:16 <copumpkin> :)
13:23:24 <Proge> but ok
13:23:25 <copumpkin> you got lots of people to talk to you
13:23:26 <mzero> I'm teaching for free - you do some learning for free - which in this context, means coding
13:23:27 <Proge> i'll try to code
13:23:28 <copumpkin> but they're chewing you out
13:23:29 <shapr> Proge: You are making highly controversial statements and raising the emotional temperature.
13:23:30 <copumpkin> they're not teaching you
13:23:41 <Proge> well i'm learning
13:23:42 <ezyang> I'm constructing an example to help out someone on Haskell-cafe who wanted to do some lazy evaluation from C.
13:23:43 <Proge> so they are
13:23:59 <Proge> i know about energy if i don't know about haskell
13:24:10 <shapr> Proge: If you continue to make polarizing statements, I will remove you.
13:24:14 <ezyang> So the idea is that you'd have some pointer to a Haskell list, and functions for getting the head and tail
13:24:26 <captwheeto> Ah
13:24:26 <Proge> then i shalln't
13:24:26 <ezyang> StablePtr seems pretty reasonable.
13:24:37 <Proge> i appologise
13:24:40 <donri> i didn't read everything, but has Proge read LYAH?
13:24:48 <Guest79019> Hello
13:24:49 <Proge> nope
13:24:53 <donri> @where LYAH
13:24:54 <lambdabot> http://www.learnyouahaskell.com/
13:24:56 <Guest79019> Does anybody here can help me?
13:25:00 <donri> it's written with beginners in mind
13:25:03 <Proge> ty
13:25:03 <shapr> Howdy Guest79019, what is your question?
13:25:23 <vrook> copumpkin: I was thinking that the inner workings of HashMonad would be hidden. All you know is that it's a monad. It could use ST or IO; you don't know or care. Now add a transformer, and we can have HashMonad + any monad, instead of just ST and IO.
13:25:33 <danm_> learn you a haskell was a great book
13:25:38 <Guest79019> shapr: I would like to know if I can convert an IO type to a data type that I have defined
13:25:51 <danm_> I particularly appreciated the build-up to monads
13:25:59 <captwheeto> I'd prefer if it had exercises and a few more pratical examples
13:26:04 <donri> me too
13:26:09 <donri> re monads
13:26:15 <Proge> i got advised real world haskell is also worthwhile
13:26:24 <captwheeto> Yeah, huge though ;)
13:26:25 <mzero> Guest79019: you have a value of type   IO Foo   and you want to get the Foo value out?
13:26:26 <Proge> its hard to be a newb again
13:26:32 <donri> yes, but it's higher level
13:26:34 <shapr> Guest79019: Um, yes you can... but you may want to read Real World Haskell to get a deeper understanding of how to do that.
13:26:40 <copumpkin> vrook: things don't work that way...
13:26:57 <Guest79019> shapr: Can you give me an example?
13:27:11 <Guest79019> mzero: to a data type that I defined
13:27:19 <mzero> right, named, for sake of argument, Foo
13:27:20 <copumpkin> vrook: the key feature of mutating is that the old value is not needed anymore
13:27:35 <copumpkin> vrook: if you can't make that assumption (as is the case with any other monad), then you have to keep around all old copies
13:27:50 <mzero> then, you can only "get it out" in the context of another IO action that will use it -- say, for example, you want to call    show on that Foo value, and then print that:
13:27:58 <copumpkin> vrook: you could do something that secretly uses mutation but provides a persistent view, like DiffArray does (using diffs), but that's ugly
13:28:01 <monochrom> if you are looking for "f :: IO Int -> Int" or something like that, you can stop looking now. find another way. re-design.
13:28:05 <vrook> Proge: Opinions differ, but I thought Programming in Haskell by Hutton was much better than both LYAH and RWH for learning Haskell.
13:28:30 <mzero>      do { a <- aThingOfTypeIOFoo; let b = show a; print b }
13:28:43 <mzero> but yes, indeed, go read LYAH and/or RWH if you haven't
13:28:48 <Proge> ty not heard of that
13:29:05 <mzero> (We suspect you haven't, as those cover the thinking about this kind of thing )
13:29:46 <Proge> ok i'll read before i continue ;)
13:29:54 <vrook> copumpkin: I said "It could use ST or IO". You seem to be answering a different question.
13:30:05 <copumpkin> vrook: you can't secretly use a monad behind the scenes
13:30:10 <copumpkin> that's not how they work
13:30:19 <Guest79019> Can anyone give me a code example please?
13:30:33 <vrook> ohh the IO or ST would be permanently stuck there.
13:30:39 <shapr> Guest79019: mzero's example is a code example
13:31:21 <copumpkin> vrook: yeah, or a new monad that builds on top of ST or IO, but it would have to be explicit. The issue basically boils down to the fact that IO and ST can't have transformers, but can be transformed
13:31:21 <Guest79019> shapr: hm... I didnt understand it very well =[ Sorry...
13:31:40 <captwheeto> Guest79019: Do you have to use impure code?
13:32:19 <copumpkin> vrook: if your hashtable lives in ST, and you want to run some other monadic code, you can transform ST itself. So you could have ErrorT (ContT r (ST s)) blah or something
13:32:34 <Guest79019> captwheeto: The data type I created is Formula... I just want to convert an IO type to this type I've created
13:32:40 <vrook> newtype HashMonad a = HM (IO a) -- you can't ever get rid of the IO in type signatures. My mistake was that it could become opaque somehow.
13:32:42 <copumpkin> vrook: then you can still life your hashtable operations into thre
13:33:22 <copumpkin> vrook: yeah, it's gonna be there. You could not tell people that your HashMonad includes IO if you really wanted to hide it, but you couldn't provide a meaningful transformer for your HashMonad
13:33:25 <Proge> ordered on amazon prime i shall learn soon
13:33:31 <donri> Guest79019: http://www.haskell.org/haskellwiki/Introduction_to_IO
13:33:34 <copumpkin> you could transform HashMonad with other transformers, though
13:34:48 <monochrom> module Hasher(HashMonad) where newtype HashMonad a = HM (IO a)   now it's opague
13:35:24 <monochrom> even though ghci's :info command still leaks unexported information for your curiosity, yes
13:35:45 <shapr> Ah too bad, I was going to help proge a bit directly.
13:35:55 <shapr> I'm distracted by the SOPA hearing insanity.
13:35:59 <monochrom> what agony! you can see the unexported information plain as day, and you aren't allowed to use it :)
13:36:33 <monochrom> Proge needs solitary learning time anyway, so don't you worry.
13:36:55 <shapr> You could be right.
13:37:20 <monochrom> one can write 3 PhD theses and learn 10 languages in a week if he/she signs off from IRC
13:37:35 <copumpkin> mm_freak: you around?
13:38:18 <mm_freak> copumpkin: yeah
13:38:40 <copumpkin> mm_freak: I was thinking about your infinite retry combinator, which is helpful, but if I look at the source for enumHandle, it uses a function continue0
13:38:48 <copumpkin> and has implicit recursion
13:38:51 <copumpkin> do you know what the advantage is there?
13:38:56 <copumpkin> is it an efficiency thing?
13:39:49 <mm_freak> copumpkin: no, the efficiency is the same…  i just find the explicit variant clearer
13:39:56 <copumpkin> I guess the checkContinue0 docs say what it means :)
13:41:17 <copumpkin> ah, okay, the definition of that function is trivial
13:42:43 <mm_freak> it really just captures the looping pattern i used in a combinator
13:44:45 <copumpkin> yep
13:44:52 <copumpkin> alright, cool :)
13:54:53 <EvanR-work> if you load a 3 gig bytestring, then get a 16 byte slice from the middle, for example
13:55:00 * hackagebot oi 0.0.2 - Purely Functional Lazy Interaction with the outer world  http://hackage.haskell.org/package/oi-0.0.2 (NobuoYamashita)
13:55:06 <EvanR-work> will the 3 gigs ever be reclaimed
13:55:33 <kmc> no
13:55:43 <c_wraith> EvanR-work: depends on how you take the slice.  isn't this covered in the bytestring docs?
13:55:44 <kmc> but you can use copy :: ByteString -> ByteString
13:55:53 <EvanR-work> ok
13:56:55 <EvanR-work> the doc explains it clearly
13:56:59 <copumpkin> what you need is powerslice
13:57:01 <kmc> or you can mmap a 3 gig file as a bytestring, then take a 16 byte slice from the middle
13:57:06 <Hejsan> Howdie yall.
13:57:22 <kmc> in which case it will use 3 GB of address space forever, but only a page of physical memory
13:57:38 <EvanR-work> that sounds hardcore
13:57:38 <Axman6> or two
13:57:44 <kmc> yeah or two :)
13:57:56 <Axman6> edge cases!!!
13:57:58 <kmc> well i suppose using the operating system the way it's intended to be used could be considered "hardcore" these days
13:58:00 <Axman6> D:
13:58:07 <EvanR-work> hehe
13:58:21 <Axman6> kmc: but it's not abstracted enough!
13:58:26 <copumpkin> preflex: 6st 1 2 3 4 5 6 7 8 9 10
13:58:27 <preflex>  1st 2rd 3th 4th 5th 6st 7rd 8th 9th 10th
13:58:38 <monochrom> there is a bytestring-mmap lib on hackage for that
13:58:40 <incluye> preflex: 1 2 3 4
13:58:48 <Axman6> 3th?
13:58:49 <copumpkin> preflex: 6st 1 2 3 4 5 6 7 8 9 10 11
13:58:50 <preflex>  1st 2rd 3th 4th 5th 6st 7rd 8th 9th 10th 11st
13:59:01 <incluye> why
13:59:05 <copumpkin> Axman6: if that's your only problem with it
13:59:14 <Hejsan> Im new to haskell and dont really know where to look. But I have a data type "data Status = OK | WARN | CRIT" that I want to define my own Ord functions(??) for like so, OK < WARN < CRIT. But when I try to search for something like overide Ord with custom blablabla I only get to definitions for Ord like this (http://zvon.org/other/haskell/Outputprelude/Ord_c.html)
13:59:16 <Axman6> not my only one... but the first
13:59:23 <EvanR-work> if i have 4G of memory, can i mmap two 3G files?
13:59:24 <copumpkin> Axman6: oh, so 2rd is fine?
13:59:29 <kmc> data Status = OK | WARN | CRIT deriving (Ord)
13:59:32 <mauke> Hejsan: why override anything?
13:59:42 <kmc> EvanR-work, the amount of physical memory you have doesn't matter
13:59:54 <EvanR-work> really now
13:59:54 <Axman6> copumpkin: yeah i missed that one
14:00:03 <kmc> correct
14:00:10 <kmc> that's the point of virtual memory
14:00:16 <copumpkin> :)
14:00:24 <Axman6> swap--
14:00:27 <kmc> a page in your process's address space might map to a page in physical memory, or a page of some file on disk, or nowhere at all
14:00:29 <kmc> no, it's not swap either
14:00:35 <copumpkin> EvanR-work: you probably want addresses that are large enough to hold that much though
14:00:38 <kmc> "virtual memory" ≠ "swap"
14:00:38 <copumpkin> but it's not about your memory
14:00:43 <Axman6> it always saves the day, but it never lets you forget it
14:01:01 <EvanR-work> if i have a 32bit OS, can i mmap two 3G files ;)
14:01:04 <kmc> no
14:01:09 <EvanR-work> ah
14:01:14 <rwbarton> you will be lucky if you can mmap one 3G file
14:01:18 <Axman6> kmc: sure, i wasn't equating the two really, but swap is an important part of making virtual emmory work well
14:01:21 <bashoo> can someone break down how "map toUpper "string"" evaluates?
14:01:30 <monochrom> if you have 4G of RAM, please use a 64-bit OS already
14:01:31 <kmc> most 32-bit OSes will give the user about 3GB of address space
14:01:43 <Axman6> > map f [a,b,c] :: [Expr]
14:01:44 <lambdabot>   [f a,f b,f c]
14:01:50 <kmc> even if you have only 128 MB of RAM, you might want to mmap more than 3GB file
14:01:59 <kmc> this is totally reasonable
14:02:03 <rwbarton> two different processes can mmap two different 3G files thogh
14:02:11 <monochrom> map toUpper ('s':blahblah) -> toUpper 's' : map toUpper blahblah -> etc
14:02:13 <Axman6> bashoo: how it evaluated relies completely on how the list is used next.
14:03:01 <EvanR-work> if i mmap a file, can an external process mess with my application by opening the file in notepad and editing it? ;)
14:03:13 <kmc> yeah
14:03:19 <kmc> can you use segmentation on 32-bit x86 to access more than 4 GB of linear virtual address space from a single process
14:03:19 <monochrom> if you have head(map toUpper ('s':blahblah)), it goes -> head(toUpper 's' : map toUpper blahblah) -> toUpper 's' -> 'S'  THE END
14:03:46 <EvanR-work> that sounds like hax
14:03:53 <kmc> "MAP_PRIVATE: Create a private copy-on-write mapping.  Updates to the mapping are not visible to other processes mapping the same file, and are not carried through to the underlying file.  It is unspecified whether changes made to the file after the mmap() call are visible in the mapped region."
14:04:30 <Hejsan> mauke: thanks. That was more simple than I tought it was gonna be. Didnt know that the order in the definition became the actual Ord order in these cases.
14:04:34 <bashoo> thanks, it was an answer in tryhaskell tutorial and I got it right I just don't quite understand how it evalutes still
14:04:42 <bashoo> toUpper "blah" doesn't work
14:04:49 <Axman6> :t toUpper
14:04:50 <lambdabot> Char -> Char
14:04:52 <monochrom> well yeah that's a type error
14:04:57 <Axman6> :t map toUpper
14:04:57 <EvanR-work> map toUpper "blah"
14:04:58 <lambdabot> [Char] -> [Char]
14:05:03 <Axman6> :t "blah"
14:05:04 <lambdabot> [Char]
14:05:13 <bashoo> :t map
14:05:13 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:06:09 <bashoo> can you break down that last output for me in English?
14:06:16 <bashoo> is that two statements or one?
14:07:06 <Axman6> the type of map?
14:07:17 <monochrom> function from (function from a to b) to (function from (list of a) to (list of b)). IOW, screw English already
14:07:26 <kmc> map :: (a -> b) -> [a] -> [b]
14:07:34 <Axman6> it says that mak takes a function, whose type is a -> b, and a list containing things of the same type a, and returns a list containing b's
14:07:49 <Axman6> map even
14:08:14 <monochrom> there is a reason someone invented algebraic expressions like (a+b)^2 - sqrt(a/(b+c)) and no one ever asked for translating that to English
14:08:23 <bashoo> Axman6: ty
14:08:40 <EvanR-work> unsafeMMapFile :: FilePath -> IO ByteString
14:08:42 <EvanR-work> nice
14:08:56 <Peaker> monochrom: Translating to English is a good pedagogical tool to learn the new notation
14:09:11 <kmc> "translating to english" also known as "explaining"
14:09:22 <EvanR-work> bashoo: also can be read as (a -> b) -> ([a] -> [b])
14:09:24 <monochrom> yes for simplistic expressions like a->[b] only. does not scale. is not webscale.
14:09:26 <kmc> explaining things does help solidify understanding
14:09:33 <EvanR-work> a function from functions to functions ;)
14:09:52 <Axman6> mauke_: i'd argue your notation is not webscale too =)
14:09:53 <monochrom> but anyway since I actually obliged, you can't complain
14:09:57 <Axman6> uh, monochrom
14:10:33 <bashoo> monoling
14:11:14 <monochrom> to be honest I completely don't mind "translating" (a+b)^2 - sqrt(a/(b+c)) to English too if you so demand. pedagogical? well you be the judge.
14:11:26 <EvanR-work> we report you decide
14:12:17 <bashoo> Assuming you don't actually think directly in haskell or mathematics you are translating something, and even if you do the person that created it had to
14:12:57 <EvanR-work> i expand math notation in my head if it gets too confusing, of course i cant fully expand it
14:13:04 <EvanR-work> because it would be even more confusing
14:13:22 <EvanR-work> in words i mean
14:13:33 <monochrom> translating little pieces like a+b and c^2 and sqrt(r) is helpful, sure.
14:14:20 <Axman6> is there something special about that equation by the way?
14:14:36 <monochrom> but eventually if you see (a+b)^2 - sqrt(a/(b+c)) you should be able to think "it's some blob minus some other blob, I'll zoom in to the first blob latter, anyway it's subtraction at the high level"
14:14:40 <Axman6> feels very... triangular...
14:15:12 <monochrom> I made it up on the spot. unlikely to hit something important or useful
14:16:08 <Axman6> > [(a+b)^2 - sqrt (a/(b+c)) | a < [1..5], b <- [1..5], c <- [1..5]]
14:16:09 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
14:16:09 <lambdabot>         against inferred ...
14:16:17 <Axman6> > [(a+b)^2 - sqrt (a/(b+c)) | a <- [1..5], b <- [1..5], c <- [1..5]]
14:16:18 <lambdabot>   [3.2928932188134525,3.4226497308103743,3.5,3.552786404500042,3.591751709536...
14:16:43 <mm_freak> Hejsan: the derived order reflects the order of the constructors you use
14:16:58 <mm_freak> data MyType = Smallest | … | Greatest
14:16:59 <Axman6> > [(a+b)^2 - sqrt (a/(b+c)) | a <- [0..5], b <- [1..5], c <- [1..5]]
14:17:00 <lambdabot>   [1.0,1.0,1.0,1.0,1.0,4.0,4.0,4.0,4.0,4.0,9.0,9.0,9.0,9.0,9.0,16.0,16.0,16.0...
14:17:14 <mm_freak> Hejsan: if you want to have a different order, define an Ord instance for your type
14:17:38 <mm_freak> instance Ord MyType where compare WARN CRIT = LT
14:17:43 <mm_freak> etc.
14:17:56 <Axman6> instance Ord MyType where compare A B = LT; compare B C = LT ...
14:18:03 <EvanR-work> so if i mmap a bytestring and then overlay it with a Data.Map, i could be saving myself a lot of memory
14:18:33 <EvanR-work> i basically have a database
14:18:35 <kmc> overlay?
14:18:46 <mm_freak> Hejsan: for three constructors this already needs nine cases, you a much easier way is to define an Enum instance and use the fromEnum function
14:19:05 <EvanR-work> kmc: , parse, build Map
14:19:15 <mm_freak> in any case, deriving Ord is the easiest and safest way
14:19:20 <EvanR-work> nevermind
14:19:25 <EvanR-work> if i parse the whole thing ill load the whole thing
14:19:32 <kmc> yeah
14:19:44 <mm_freak> EvanR-work: whatever you're doing that statement sounds very wrong =)
14:19:53 <kmc> but the OS can still drop the parts you haven't touched in a while from physical memory
14:20:37 <kmc> if you explicitly read into a buffer and parse that, it can only "drop" parts of the buffer by copying them to swap
14:20:54 <EvanR-work> if i had indexes into the bytestring i could map chunks into other data structures
14:20:57 <kmc> but if you mmap the file, it knows the data is already on disk
14:21:11 <kmc> so it can just drop cold clean pages, does not need to save them first
14:21:13 <EvanR-work> and most of the bytes would not be loaded
14:21:15 <mm_freak> EvanR-work: you have a 3 GiB file and you want to parse part of it?
14:21:36 <rwbarton> if you use BS.drop and BS.take, you effectively are just using indexes into the file
14:21:38 <EvanR-work> im not doing anything real, just imaginating
14:22:01 <bashoo> why is there an empty list at the end of let (a:b:c:[]) = "xyz" in a ?
14:22:13 <EvanR-work> :t 1:2:3
14:22:14 <lambdabot> forall t. (Num t, Num [t]) => [t]
14:22:18 <rwbarton> bashoo: Because you put one there.
14:22:24 <rwbarton> do you mean why does it match?
14:22:25 <EvanR-work> o_O
14:22:26 <kmc> because a non-empty list is some stuff followed by an empty list
14:22:28 <monochrom> all finite lists are made by prepending things to the empty list
14:22:36 <mm_freak> bashoo: data List a = Empty | Cons a (List a)
14:22:38 <rwbarton> "xyz" = 'x':('y':('z':[]))
14:22:44 <mm_freak> Cons 1 (Cons 2 (Cons 3 Empty))
14:22:55 <monochrom> and yeah "xyz" is syntax sugar
14:22:58 <EvanR-work> wanna explain how 1:2:3 is a valid list ;)
14:22:58 <bashoo> ok, this is from a tutorial I'm curious why he made it explicit
14:23:15 <mm_freak> bashoo: probably because it's important to understand
14:23:17 <rwbarton> let (a:b:c:[]) = "xyz" in a  can also be written  let [a,b,c] = "xyz" in a
14:23:18 <kmc> EvanR-work, instance Num [t]
14:23:25 <Axman6> so you'd understand how lists are constructed/defined/matched on
14:23:34 <EvanR-work> > head (1:2:3)
14:23:35 <lambdabot>   No instance for (GHC.Num.Num [a])
14:23:35 <lambdabot>    arising from a use of `e_1123' at <int...
14:23:50 <kmc> numeric literals are overloaded
14:23:59 <EvanR-work> > 1 2
14:24:00 <lambdabot>   1
14:24:01 <kmc> so they can have any type in the Num class
14:24:05 <mm_freak> bashoo: in haskell constructing and destructing lists is a pretty explicit thing…  whenever you use patterns like (x:xs) you are destructing a list
14:24:07 <EvanR-work> they are overloaded to all hell ;)
14:24:20 <mm_freak> :t sin + cos
14:24:21 <lambdabot> forall a. (Floating a) => a -> a
14:24:42 <mm_freak> if functions were storable, you could actually write Eq for them =)
14:24:45 <rwbarton> > sin sin 3
14:24:46 <lambdabot>   0.14065207678644337
14:24:50 <rwbarton> > sin (sin 3)
14:24:51 <lambdabot>   0.14065207678644337
14:24:56 <EvanR-work> > [1,2] + [2,3]
14:24:57 <lambdabot>   No instance for (GHC.Num.Num [t])
14:24:57 <lambdabot>    arising from a use of `e_11223' at <in...
14:25:20 <bd_> mm_freak: not a very useful definition, possibly :)
14:25:28 <mm_freak> bd_: a dangerous one even
14:25:33 <Axman6> > sin^2 3
14:25:34 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
14:25:34 <lambdabot>    arising from a use of `...
14:25:40 <Axman6> > (sin^2) 3
14:25:41 <lambdabot>   1.991485667481699e-2
14:26:06 <bashoo> rwbarton: ok I think I get it now
14:26:11 <EvanR-work> gimmickery
14:26:27 <mm_freak> bd_: but it would be interesting to be able to lift functions to the type level, which really just requires Storable (you don't get application though)
14:26:48 <alistra> > ((\x -> x + 1)^2) 4
14:26:49 <lambdabot>   25
14:27:11 <mauke> > succ^2 $4
14:27:11 <lambdabot>   25
14:27:25 <EvanR-work> (+1) . (^2) $ 4
14:27:29 <Axman6> > succ^succ $ 4
14:27:30 <lambdabot>   No instance for (GHC.Real.Integral (a -> a))
14:27:30 <lambdabot>    arising from a use of `GHC....
14:27:39 <EvanR-work> (^2) . (+1) $ 4
14:27:41 <Axman6> > (succ^succ) 4
14:27:42 <lambdabot>   No instance for (GHC.Real.Integral (a -> a))
14:27:42 <lambdabot>    arising from a use of `GHC....
14:27:45 <mm_freak> :t sin**sin
14:27:46 <Axman6> :(
14:27:46 <lambdabot> forall a. (Floating a) => a -> a
14:27:51 <mm_freak> > sin**sin $ 15
14:27:52 <lambdabot>   0.7559009059328181
14:27:58 * EvanR-work brain explode
14:28:08 <mm_freak> :t (**)
14:28:09 <lambdabot> forall a. (Floating a) => a -> a -> a
14:28:21 <mauke> > inRange 4 (2,3)
14:28:22 <lambdabot>   False
14:28:23 <monochrom> explodential sin
14:28:24 <mm_freak> we have Floating a => Floating (a -> a)
14:28:25 <mm_freak> =)
14:28:31 <mm_freak> lambdabot does
14:28:35 <mauke> > inRange 4 (2,7)
14:28:36 <lambdabot>   False
14:28:57 <mm_freak> > sin 15 ** sin 15
14:28:58 <monochrom> @type inRange
14:28:58 <lambdabot>   0.7559009059328181
14:28:58 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
14:29:06 <monochrom> ha ha
14:29:15 <Axman6> > 1 :: (Int,Int)
14:29:15 <lambdabot>   (1,1)
14:29:19 <Peaker> mm_freak: you could write == for functions that may return True or _|_
14:29:20 <mm_freak> lol
14:29:23 <Axman6> > 1 :: (Int,Int,Double)
14:29:23 <lambdabot>   (1,1,1.0)
14:29:28 <EvanR-work> i had someone in javascript berate me and call me an idiots for advocate functions such as 'inRange'
14:29:43 <Axman6> yeah?
14:29:48 <Axman6> what was their reasoning?
14:29:49 <EvanR-work> because 2 < x && x < 7 is better
14:29:52 <EvanR-work> easier to read
14:30:07 <mm_freak> Peaker: you can write:  instance (Bounded a, Enum a, Eq b) => Eq (a -> b)
14:30:07 <alistra> iirc assembly has a range opcode
14:30:10 <Axman6> than inRange(2,7,x)? o.O
14:30:11 <alistra> x86*
14:30:12 <mike-burns> Depends on the syntax.
14:30:26 <monochrom> 2 < x && x < 7 is easier to read than inRange for people who know javascript but not English
14:30:30 <mm_freak> > (1,1) + (2,3)
14:30:31 <lambdabot>   (3,4)
14:30:32 <EvanR-work> Axman6: its stupid to make little puny functions that arent in a library
14:30:46 <mm_freak> why doesn't lambdabot just import the vector-space package?
14:30:57 <mm_freak> instead of reinventing the square wheel
14:30:59 <Axman6> but all we make is little, puny but powerful functions!
14:31:22 <monochrom> but no one should ever call you an idiot
14:31:52 <Peaker> mm_freak: good luck running a program on a computer :)
14:31:58 <jessopher> > snd (1 + 1)
14:31:58 <lambdabot>   2
14:32:09 <EvanR-work> o_O
14:32:12 <monochrom> I think lambdabot does import the vector-space package
14:32:13 <jessopher> lol
14:32:19 <EvanR-work> > snd 2
14:32:20 <lambdabot>   2
14:32:27 <alistra> > fst 1
14:32:28 <lambdabot>   1
14:32:32 <mm_freak> Peaker: and i was wrong anyway =)
14:32:35 * EvanR-work goes insane
14:32:36 <alistra> > (fst 1, snd 2)
14:32:37 <lambdabot>   (1,2)
14:32:43 <alistra> inside out
14:32:44 <mm_freak> Peaker: Enum doesn't enumerate all possible values
14:32:46 <rwbarton> > (fst * snd) 3
14:32:46 <EvanR-work> > thd 3
14:32:47 <lambdabot>   9
14:32:47 <lambdabot>   can't find file: L.hs
14:32:59 <mm_freak> > 1 ^+^ 1
14:33:00 <lambdabot>   2
14:33:02 <EvanR-work> > thd 3
14:33:02 <mm_freak> indeed
14:33:02 <lambdabot>   Not in scope: `thd'
14:33:15 <Peaker> mm_freak: Enum truly sucks..  I wonder if Enum's toInt . fromInt are supposed to be an identity
14:33:16 <alistra> @hoogle thd
14:33:16 <lambdabot> System.IO openBinaryTempFileWithDefaultPermissions :: FilePath -> String -> IO (FilePath, Handle)
14:33:16 <lambdabot> System.IO openTempFileWithDefaultPermissions :: FilePath -> String -> IO (FilePath, Handle)
14:33:17 <lambdabot> Network.HTTP.Auth AuthDigest :: String -> String -> String -> String -> Maybe Algorithm -> [URI] -> Maybe String -> [Qop] -> Authority
14:33:20 <alistra> @hoogle thrd
14:33:20 <mm_freak> > (3 *^ sin) pi
14:33:20 <lambdabot> No results found
14:33:21 <lambdabot>   No instance for (GHC.Num.Num (Data.VectorSpace.Scalar a))
14:33:21 <lambdabot>    arising from a...
14:33:24 <alistra> @hoogle third
14:33:24 <lambdabot> No results found
14:33:31 <mm_freak> > (3 *^ sin) pi :: Double
14:33:32 <lambdabot>   3.6739403974420594e-16
14:33:33 <alistra> @hoogle (a,b,c) -> c
14:33:33 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
14:33:33 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
14:33:46 <Axman6> openBinaryTempFileWithDefaultPermissions -- <look of disapproval>
14:33:52 <mm_freak> Peaker: most of the h98 classes suck
14:34:13 <monochrom> actually there is already openTempFile somewhere
14:34:34 <Peaker> mm_freak: Hmm.. Indeed :) I was about to say Functor is good, but it too needs to be generalized out of Hask
14:34:36 <monochrom> why do you disapprove?
14:34:36 <alistra> what's the diff between a binary and nonbinary file?
14:34:43 <Axman6> I think that function name is definitely enterprise worthy
14:35:02 <mm_freak> Peaker: actually i think Functor is fine, but all the classes lower in the hierarchy suck =)
14:35:04 <Peaker> mm_freak: having "fail" in Monad is even less sucky than making a class that just defined isomorphism to Int
14:35:06 <mm_freak> except perhaps Applicative
14:35:08 <monochrom> if nonbinary, may be "text file", i.e., CR-LF and Ctrl-Z for windows
14:35:29 <EvanR-work> a binary file is a long list of bits, other files have a mixture of bits, trits, quits etc ;)
14:35:44 <mm_freak> well, i don't have a problem with 'fail', but i have a problem with it being in Monad
14:35:54 <mm_freak> what bothers me more is that there is no such mechanism for arrows
14:36:04 <Peaker> mm_freak: of course, though the String should be generalized too
14:36:11 <alistra> EvanR-work: my files use octits
14:36:17 <alistra> i call them characters
14:36:18 <EvanR-work> octotits
14:36:26 <mm_freak> Peaker: if the string were not there you could just use MonadPlus and ArrowZero
14:36:36 <alistra> @image octotits
14:36:36 <lambdabot> Unknown command, try @list
14:36:38 <monochrom> oh, you are not supposed to equate octits with characters these days
14:36:51 <mm_freak> @heal octitis
14:36:52 <lambdabot> b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b])
14:36:54 <monochrom> but sticking with octits is fine. just keep them octits.
14:36:57 <Axman6> octets no?
14:36:59 <EvanR-work> octets* xD
14:36:59 <mm_freak> huh?!
14:37:02 <Peaker> mm_freak: MonadZero should be split out of MonadPlus too, speaking of sucky h98 classes
14:37:11 <alistra> they are not bets
14:37:13 <alistra> but bits
14:37:19 <mm_freak> Peaker: true, but then you have to split Alternative, too
14:37:29 <mm_freak> and Monoid and …
14:37:39 * alistra recommends searching octotits on google images without SafeSearch
14:37:39 <EvanR-work> also octits are note 8bit bytes
14:37:49 <EvanR-work> 0-7 not 0-255 ;)
14:38:12 <jessopher> i have a problem with fail being in monad, since it doesn't even make sense for the general case of MonadError
14:38:21 <mm_freak> EvanR-work: you might be right about octits, but in all RFCs i have seen an octEt is defined as an eight bit byte =)
14:38:37 <EvanR-work> octets are ducentquindecquints ;)
14:39:36 <EvanR-work> we should all be using utf9 anyway
14:40:59 <EvanR-work> you guys are nuts
14:41:06 <EvanR-work> there is not a single utf9 package on hackage
14:41:22 <monochrom> I am sorry for that
14:41:40 <EvanR-work> should bein acme
14:41:52 <EvanR-work> important stuff goes there
14:41:54 <rwbarton> @hoogle Word9
14:41:54 <lambdabot> No results found
14:42:08 <EvanR-work> @hoogle Char9
14:42:08 <lambdabot> No results found
14:42:26 <rwbarton> data Word9 = Word9 {-# UNPACK #-} !Bool {-# UNPACK #-} !Bool {-# UNPACK #-} !Bool {-# UNPACK #-} !Bool {-# UNPACK #-} !Bool {-# UNPACK #-} !Bool {-# UNPACK #-} !Bool {-# UNPACK #-} !Bool {-# UNPACK #-} !Bool
14:42:49 <monochrom> godawful
14:43:31 <rwbarton> that doesn't even work, does it
14:44:07 <rwbarton> can you {-# UNPACK #-} a field whose type has multiple constructors?
14:44:24 <monochrom> oh, tricky
14:45:34 <monochrom> right, UNPACK doesn't work for Bool or multiple-constructor thingies
14:46:06 <Sgeo> @hoogle don't
14:46:06 <lambdabot> No results found
14:46:08 <Sgeo> :(
14:46:13 <Sgeo> @hayoo don't
14:46:13 <lambdabot> Unknown command, try @list
14:46:52 <pdxleif> http://hackage.haskell.org/package/acme-dont ?
14:47:26 <Sgeo> pdxleif, yes, thanks
14:47:38 <EvanR-work> acme-now is great
14:47:39 <Sgeo> I need it for something I'm working on (no I .. erm, don't)
14:47:47 <mike-burns> Just discovered the acme-realworld package. Solid.
14:48:28 <Sgeo> mike-burns, I think it's new
14:49:00 <Axman6> rwbarton: I don't believe you can, but pointer tagging has basically the same effect (though each bool would be represented as a word sized pointer... so it's not very effective...)
14:49:41 <donri> mike-burns: also see acme-dont
14:49:54 <mike-burns> Yeah! I think I had seen that one previously.
14:50:23 <mike-burns> I really like the subtly of acme-realworld's documentation. It promises so much and never claims it won't work!
14:50:44 <EvanR-work> mike-burns: i just looked at it
14:50:54 <EvanR-work> how would we even know if it didnt work ;)
14:51:01 <EvanR-work> were always in the current state ;)
14:51:07 <kmc> sounds like a good way to get people even more confused about this "world passing" idea
14:51:08 <mike-burns> True! Very true!
14:51:15 <mike-burns> Hah.
14:51:21 <EvanR-work> kmc: yes, yes it is
14:52:01 <EvanR-work> mike-burns: thats the key behind 'program values arent affected, but the rest of the universe is ;)'
14:54:51 <EvanR-work> getWorld = IO (\s -> (# s, fromState s #))
14:54:55 <EvanR-work> lol
14:55:32 <donri> hahaha "hypothetically"
14:57:37 <EvanR-work> donri: yeah, what possible use could that have xD
14:57:57 <donri> it sounds very useful, from the docs
14:59:29 <jessopher> why back up just your data when you can back up the entire universe easily
14:59:41 <EvanR-work> donri: i get it, you get the a but without the side effects
14:59:46 <EvanR-work> yeah, thats useful
15:00:13 <donri> this makes software testing redundant
15:00:24 <donri> just run every program hypothetically
15:00:35 <EvanR-work> lol
15:01:44 <EvanR-work> but it both returns instantly and needs enough time to 'would have run'
15:01:53 <EvanR-work> thats the rub
15:01:55 <EvanR-work> lol
15:02:41 <donri> EvanR-work: yes but it on ly needs that time hypothetically
15:07:07 <steampunkey> hey
15:07:34 <Axman6> 'lo
15:11:33 <eviltwin_> is there a command line option I can pass to ghci to automatically set the prompt? I'm looking to automatically set it when launched from a particular script (ie I don't want to make this part of my local ghci config)
15:12:10 <parcs`> :set prompt "> "
15:12:19 <c_wraith> that's not command-line
15:12:27 <steampunkey> Please suggest two books: 1) a good one for learning the basics of haskell, and 2) a detailed one that would set me on a path of mastery. For the first, have in mind that I am a programmer (including C - that is, lower level, and Scheme - that is, functional) so I'm not seeking to learn (functional) programming, rather I want to learn Haskell programming. The second one should containg best practices (stuff you guys use). How ab
15:12:38 <parcs`> i need to stop skimming crap
15:13:29 <steampunkey> parcs`: reading. it's hard ;-D
15:13:59 <mike-burns> steampunkey: For (2) I recommend writing a lot of code.
15:14:00 <kmc> steampunkey, LYAH and RWH are the main books which get recommended here
15:14:01 <kmc> @where LYAH
15:14:02 <lambdabot> http://www.learnyouahaskell.com/
15:14:03 <kmc> @where RWH
15:14:03 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:14:18 <Axman6> steampunkey: you'd probably find that LYAH is useful for learning haskell (don't assume you know enough functional programming to get by in Haskell, it's _all_ functional programming here, and we have different sybntax and names for things). then Real World Haskell to learn about Haskell... in the real world
15:14:30 <mm_freak> steampunkey: your message is truncated
15:14:37 <kmc> it's not all functional programming
15:14:41 <Axman6> you'll find LYAH pretty basic to begin with, but it is important to make sure you understand the basics first
15:14:57 <kmc> Haskell is an unusual functional language
15:14:57 <steampunkey> kmc: Axman6 is LYAH(FAGG) that comic thing? because i didn't like it.
15:15:03 <kmc> yeah
15:15:22 <Axman6> kmc: yeah i know, but it helps to ween people off their imperative tendancies
15:15:28 <mike-burns> http://goo.gl/ygO3L - this is my preferred reading source for modern Haskell best practices.
15:15:30 <AfC> How can you not like the cute illustrations?
15:15:31 <mm_freak> steampunkey: LYAH is actually very good despite its comic appearance
15:15:40 <steampunkey> i don't like that the art to info ration is very high
15:15:44 <kmc> i can totally understand being annoyed by the tone
15:15:57 <Axman6> indeed, LYAH taught me things after i'd been using haskell for over two years
15:16:21 <Axman6> there's some very cool stuff in there
15:16:25 <AfC> steampunkey: The tone may be friendly, but it is very dense. After the 3rd chapter or so every paragraph has a lot of meaning and learning in it.
15:16:29 <mm_freak> steampunkey: for the second thing i recommend reading this channel and the haskell-cafe mailing list…  there is no one source unfortunately
15:16:31 <AfC> Not for skimming.
15:16:59 <mm_freak> steampunkey: and asking questions
15:17:14 <mm_freak> the haskell community is very welcoming to newcomers
15:17:28 <kmc> sometimes
15:17:49 <kmc> personally i think we spend too much time talking about how smart and friendly and wonderful we are
15:17:58 <mm_freak> compared to all other language communities (except for the languages that are even more brainteasing like agda) =)
15:18:01 <mike-burns> Yeah, let's just do it instead of talking about it.
15:18:40 <mike-burns> Speaking of: steampunkey: If you already know C and Scheme, go try writing some Haskell and look stuff up when you get stuck, or ask in here.
15:18:49 <mm_freak> kmc: well, i think it's fair, when it's true…  and i don't think we aren't doing enough
15:19:00 <mm_freak> a monad tutorial emerges out of thin air about every week =)
15:19:07 <kmc> while in my experience #haskell is one of the best channels on freenode, it also has its own share of flaws and annoyances
15:19:13 <kmc> there are definitely things we could improve, imo
15:19:34 <Axman6> specifically?
15:19:46 <mm_freak> like what?  not saying #haskell is perfect, but i'd be interested in examples
15:19:46 <mike-burns> Last time we had this discussion someone quit in anger.
15:19:52 <kmc> was it me?
15:19:54 <kmc> probably
15:19:58 <Axman6> heh
15:20:08 <mike-burns> Hah, maybe it was!
15:20:25 <kmc> well i'd have to compose a medium to long rant to express my ideas on this topic
15:20:43 <mm_freak> steampunkey: anyway, if you like a more serious tone, have a look at Real World Haskell
15:21:29 <Axman6> steampunkey: you should be prepared that, even if you do know scheme, you'll be doing a lot of brain rewriting
15:21:30 <kmc> also every behavior which annoys me is something i've done multiple times in the past
15:21:33 <kmc> so maybe i'm a hypocrite, but whatever
15:21:51 <dmwit> steampunkey: If you want a higher information density, try the Gentle Introduction.
15:21:54 <dmwit> ?where gentle
15:21:54 <lambdabot> http://www.haskell.org/tutorial/
15:22:05 <ectod> my two cents is that i have almost finished LYAH ( only the last chapter left ) and i find it really good
15:22:05 <mm_freak> kmc: that calls for a blog entry
15:22:16 <dmwit> The gentle intro doesn't get enough love these days.
15:22:17 <kmc> yeah i might write one
15:22:22 <steampunkey> Axman6: kmc: ok, i'll check out RWH. maybe it doubles as an intro to haskell (books tend to aspire to do that too usually)?
15:22:25 <ectod> but it's true that it's really dense, the chapter about functors and applicatives took me over 4 days to finish at the time
15:22:56 <mm_freak> ok, we have LYAH, the gentle intro and RWH, so there is only one left, if you like it very dry:  The Haskell Road to Logic
15:22:58 <Axman6> RWH does have a basic introductory haskell tutorial, but it could be better from my experience
15:23:12 <kmc> we definitely spend too much time bashing other languages
15:23:17 <mm_freak> that one is very dry and doesn't go into the real world aspects of haskell
15:23:25 <Axman6> ectod: nice dedication!
15:23:26 <AfC> mm_freak: I have that on order :)
15:23:31 <EvanR> i think we dont spend enough time bashing other languages
15:23:33 <kmc> if you mention C++ or PHP in here, people will jump on the chance to make fun of these languages
15:23:40 <EvanR> c++ is complete shit
15:23:42 <EvanR> and what about php?!
15:23:53 <EvanR> even worse!
15:23:58 <EvanR> rabble rabble
15:24:07 <mm_freak> kmc: well, except for my occasional PHP rant, i think i have become very calm in that regard =)
15:24:12 <Axman6> did someone say PHP?? D:
15:24:14 <kmc> i'm not a big fan of C++ or PHP but i think nothing new is ever said in these discussions
15:24:25 <kmc> and i used to complain about C++ a lot here, but I just got tired of it
15:24:33 <ectod> Axman6 : thanks but it was easy as i really liked haskell ( coming from C and C++, haskell comes as the messiah )
15:24:37 <Axman6> I never say anything about PHP, because I know next to nothing od it
15:24:47 <Axman6> ectod: heh, glad to hear it =)
15:24:52 <kmc> i feel like sometimes the idea that Haskell is the best language drives wrong conclusions
15:24:55 <steampunkey> kmc: seeing as i'm here to try to escape bad languages (C excluded, it's an entire category on its own, while C++ is a Frankenstein's monster), i can understand
15:24:58 <ectod> :)
15:25:02 <kmc> particularly, the idea that anything Haskell doesn't have is unnecessary
15:25:15 <AfC> Just imagine how they complain about Haskell in #c++ :)
15:25:22 <dmwit> 1. love language X 2. know enough about X to hate X 3. complain about X 4. know enough about complaining about X to hate complaining about X 5. complain about complaining about X 6. I bet you can tell where this is going
15:25:26 <mm_freak> Axman6: there are two kinds of PHP programmers:  idiots and commercial programmers ;)
15:25:37 <mm_freak> sorry, kmc, i couldn't resist =)
15:25:41 <Axman6> mm_freak: haven't you been listening to kmc? :P
15:25:44 <Axman6> heh
15:25:47 <mike-burns> The idea that Haskell is the best language contains the dangerous suggestion that we should stop improving and that we can't learn from other languages.
15:25:51 <bashoo> dmwit: should have expressed that as a function
15:26:12 <mm_freak> mike-burns: why?  you can improve the best language
15:26:21 <mm_freak> "best" doesn't mean "perfect"
15:26:27 <Axman6> I find some ideas in C++ quite interesting, but the thing that turned me off C++ I don;t think were problems with the language, but the common idioms
15:26:30 <bashoo> mm_freak: it can
15:26:43 <mm_freak> bashoo: haskell is far from perfect though
15:26:43 <mike-burns> mm_freak: Because of pride?
15:26:51 <AfC> Exactly. Besides language are the libraries and frameworks built on it, and the production code built using them. They are as much a part of the "language" as the lexical structure and runtime are.
15:26:52 <dmwit> Haskell is the best language, even compared to languages that don't exist. Therefore it is perfect. QED
15:26:55 <shachaf> Axman6: Common idioms like?
15:26:58 <kmc> if you stick around for long enough you'll hear that it's okay that we don't have stack backtraces or a debugger or a sane regex library or Java interop or a popular IDE
15:27:06 <mike-burns> Exactly.
15:27:12 <kmc> in fact because Haskell lacks these things, they must be for idiots only
15:27:15 <bashoo> dmwit obviously the language that exists is better than the language that doesn't exist
15:27:17 <Axman6> i found the whole iterator thing horrible, i'm not sure why though
15:27:24 <Axman6> it just gave me a very uneasy feeling
15:27:25 <dmwit> Obviously!
15:27:28 <Axman6> i just wanted lists >_<
15:27:30 <luite> we should have stacktraces with 7.4 right?
15:27:32 <dmwit> I may even take it as an axiom in later discussions.
15:27:34 <EvanR> regex considered harmful
15:27:35 <mm_freak> kmc: see what you have done
15:27:36 <EvanR> IDEs suck
15:27:43 <kmc> EvanR is just a troll
15:27:50 <mm_freak> you have launched yet another collective language rant and haskell praise =)
15:27:57 <Axman6> kmc: intentionally though...
15:28:10 <mm_freak> actually there is some truth to "regex considered harmful"
15:28:11 <Axman6> luite: sort of I think...
15:28:18 <kmc> the other day he was claiming that putStr is the only logging library you need
15:28:21 <kmc> which i think was a perfect example of this
15:28:30 <luite> I haven't tried them yet, but I've wanted stacktrackes for a long time :)
15:28:41 <kmc> no, I didn't launch it intentionally
15:28:58 <kmc> people asked me which things about #haskell I thought needed improvement
15:29:11 <dmwit> kmc: Yeah, sometimes you might need hPutStr. =)
15:29:23 <EvanR> dmwit: which is actually what i said
15:29:25 <kmc> anyway i get the feeling y'all aren't really interested in a serious answer to that question
15:29:28 <parcs`> for best performance use hPut
15:29:31 <AfC> I think Simon Peyton-Jones mentioned stack traces the other day at a presentation he gave in Sydney, as if it was something they were half way to figuring out how to implement. Something connected to profiling, I believe.
15:29:51 <kmc> yeah, you can bet that as soon as GHC has stack backtraces, then the party line will change
15:29:55 <dmwit> EvanR: Sorry, I'm not taking that bait.
15:30:05 <kmc> to "stack backtraces are wonderful and useful and Haskell's are the best"
15:30:11 <EvanR> some sort of backtrace would be great
15:30:20 <EvanR> i have no idea what it would look like
15:30:26 <kmc> anyway y'all seem to be jumping on my examples rather than understanding the thing i'm talking about
15:30:31 <EvanR> but i cant stand 'error' being the only debug output
15:30:32 <dmwit> kmc: I think you're lying. I haven't heard anybody say backtraces are *bad*.
15:30:59 <kmc> oh the usual answer is "we don't need those because types", "if the code compiles it works", etc
15:31:07 <steampunkey> speaking of programming languages, what others do you *like*?
15:31:19 <kmc> please no.
15:31:34 <parcs`> i like all turing-complete languages
15:31:40 <scshunt> What libraries do you guys use for managing terminal info and doing curses-style work?
15:31:53 <dmwit> steampunkey: Agda for when I get fed up with type hackery in Haskell, vimscript for when I feel sadistic (and need to extend my editor of choice).
15:32:04 <dmwit> scshunt: How about one of the ncurses bindings from Hackage?
15:32:12 <EvanR> matlab
15:32:12 <scshunt> dmwit: sure. Whic?
15:32:14 <AfC> dmwit: no, I get the sentiment kmc is expressing. I haven't been around here that long, but still I have not infrequently seen "oh, the way Haskell does it must be the best, and if it doesn't have feature $x that must be a good thing"
15:32:15 <scshunt> *which
15:32:21 <parcs`> scshunt: there are some ncurses bindings, vty (and vty-ui) and ansi-terminal
15:32:43 <dmwit> scshunt: Oh, I haven't actually done that kind of thing, so I don't know which of the bindings is best.
15:33:03 <steampunkey> dmwit: i heard good things somewhere from someone about Agda. I might just check it out one day. What do you use it for?
15:33:08 <kmc> there's a related tendency, which is to dismiss any missing library or feature as "trivial" as long as you can give a vague sketch of how it's implemented
15:33:16 <kmc> how it would be implemented, i mean
15:33:28 <Bynbo7> steampunkey: usually for writing proofs
15:33:40 <mm_freak> steampunkey: agda is a great /language/
15:33:51 <mm_freak> unfortunately it's not ready for real world application development yet
15:33:52 <steampunkey> Bynbo7: that's kinda obvious, don't you think?
15:34:00 <scshunt> dmwit: How do you Agda without emacs?
15:34:01 <Bynbo7> possibly depending on your definition of great
15:34:02 <dmwit> steampunkey: I'm not sure I've ever produced anything that was actually useful as an end product in Agda.
15:34:05 <bashoo> how much development is done in haskell?
15:34:09 <kmc> a problem may be theoretically uninteresting but it might still take many hours of effort to make a working, tested, documented, optimized, portable, packaged library
15:34:13 <Bynbo7> steampunkey: not from the context I have, no
15:34:36 <AfC> bashoo: have a read of http://www.haskell.org/haskellwiki/Haskell_in_industry
15:34:45 <bashoo> yeah I just did
15:34:49 <steampunkey> Bynbo7: agda is a proof assistant (thus says the WP), so..
15:35:04 <bashoo> it doesn't seem overwhelming but it is hard to judge what those blurbs mean in reality
15:35:05 <kmc> "does Haskell have <foo>?"  "of course it has <foo>, you just need to <sketch of implementing foo from scratch> which should be fairly trivial"
15:35:06 <Bynbo7> steampunkey: well that's what it's used for...
15:35:16 <Bynbo7> you can use it to produce Haskell as well if you like...
15:35:32 <steampunkey> kmc: XD
15:35:59 <steampunkey> kmc: well that's better than saying "no, but we'll implement it in the next version" aka C++ horror
15:36:21 <mm_freak> yes, haskell has { }?
15:36:39 <mm_freak> s/\?/0/
15:36:48 <bashoo> I did a little basic work in C a long time ago wrote a few science tools
15:36:51 <kmc> in fact while i'm on a rant here, I'd like to ban the word "trivial" in this world
15:37:03 <kmc> it used to mean something specific but now it's just a douchebag way to say "easy"
15:37:20 <parcs`> banning the word "trivial" won't be trivial
15:37:22 <bashoo> I'm just looking for something interesting to learn this seemed like a good idea
15:37:25 <mm_freak> i say "almost trivial"
15:37:49 <Axman6> bashoo: haskell is definitely interesting to learn, and use
15:38:00 <kmc> parcs`, it's funny, because you responded to my disdain for a particular word in a way which, ironically, uses the same word
15:38:21 <mm_freak> kmc: you almost sounded like sheldon cooper there
15:38:29 <Axman6> heh
15:38:31 <mm_freak> which is very nontrivial
15:39:17 <scshunt> dmwit: ?
15:39:25 <Peaker> I saw a newbie struggle with Haskell recently, and it's not pretty.. The "setup" and learning issues are much worse than in say, Python, for beginners
15:39:29 <steampunkey> kmc: actually, you reminded me of an episode of Bones when she laughs at a "science" joke, and she laughingly does the same thing (explains the joke back). It was awkward
15:39:44 <Peaker> cabal install is very unreliable, but it is the recommended tool.. partiality is everywhere, but undebuggable
15:39:46 <bashoo> python was another option I considere
15:39:56 <dmwit> scshunt: You just do it.
15:39:59 <steampunkey> <strike>bashoo</strike>
15:40:15 <dmwit> scshunt: I understand that Agda has some vim support, as well, though I don't use it.
15:40:52 <bashoo> but remembering what I did in C the functional style programming I did was a lot more mentally redwarding
15:40:59 <Axman6> to me, python offers me nothing interesting
15:41:10 <Axman6> you may be able to get the job done easily, but that';s not all that's important
15:41:12 <Peaker> The quirks of the language show themselves early: Non-polymorphic stdlib means we need a different "length" for different contains (feels like a huge step back for someone coming from Python). Record namespacing issues. Monomorphism restriction bites.  I've seen all of these and many more bite a beginner in a timespan of 2 hours
15:41:30 <Peaker> s/contains/containers
15:41:42 <kmc> Axman6, mm_freak, anyway, those are some of the things which bug me about #haskell; I hope I have answered your questions in enough detail, though only partially
15:41:47 <mm_freak> well, functional style is really about using combinators and data structures instead of imperative control structures
15:41:48 <kmc> there's more but it can wait for another day
15:42:11 <mm_freak> there is no official definition though
15:42:23 <AfC> Peaker: I think those are valid critiques
15:42:32 <mm_freak> some might argue that javascript's callback style is also functional
15:42:43 <parcs`> the package 'agda-executable' is editor-agnostic
15:42:53 <mm_freak> personally i don't see the connection between event callbacks and functional style
15:43:04 <bashoo> Axman6: so why is haskell interesting?
15:43:19 <dmwit> TYYYYYYYYYPES
15:43:29 <salisbury> yes
15:43:32 <parcs`> Axman6: it is to some people
15:43:34 <Axman6> yeah, types are a big part of it
15:43:35 <salisbury> the types are fantastic
15:43:37 <scshunt> dmwit: Ah, ok. Do you have any recommended resources for learning Agda? I'd like to try it out, ideally from the proof checker perspective but I'm content with just learning it to start
15:43:40 <mm_freak> bashoo: python is a "get stuff done fast" language, while haskell is a "get stuff doine
15:43:43 <mm_freak> done right" language
15:43:51 <Peaker> AfC: I think Haskell is so great that despite these horrors it is still better than the alternatives for many things. But none of these and other problems (version hell, butterfly effect, PVP false negatives) are inherent, and without them, I think Haskell would be soo much better
15:43:59 <EvanR> mm_freak: well, imperative commands to attach event handlers to dom elements is ass. but with a sufficient 'event delegation' library, then handlers are almost declarative
15:44:07 <kmc> i'm going to dissent here and say that types aren't the big deal, at least if you want to get someone interested in Haskell
15:44:11 <dmwit> scshunt: I learned by cribbing from my colleagues. So, I guess I won't be a better judge of resources than Google will be.
15:44:12 <kmc> it's just not that sexy
15:44:17 <kmc> to say "Haskell lets you write safe code"
15:44:17 <salisbury> version hell? I haven't experienced that
15:44:23 <steampunkey> bashoo: while other languages suck in various ways, Haskell looks elegant enough (douchebag word for pretty?) as if it has perhaps managed to not suck.
15:44:24 <dmwit> scshunt: Sorry to be such a bummer. I really only use Agda like... once a year or so. =P
15:44:27 <Axman6> bashoo: to me, it's interesting because it lets me do almost everything I want to in a way that's usually pretty clear and consise, and yet performs well
15:44:27 <kmc> what do i need that for?  i'm a Real Programmer, I never make mistakes
15:44:33 <mm_freak> EvanR: i hate the callback style…  i have adapted netwire to javascript, but it's not finished yet
15:44:36 <Peaker> salisbury: When you write "cabal install X", how often does it actually work?
15:44:39 <EvanR> yeah who wants to write safe code, safe doesnt sound profitable
15:44:42 <dmwit> scshunt: But maybe you should ask in #agda?
15:44:42 <AfC> Peaker: yeah. I was dismayed that the recent "2010 Report" of the language didn't cleanup any of the Prelude problems. Prelude is fine... until you meet ByteString. Then confusion sets in.
15:44:45 <salisbury> so far, 100%
15:44:56 <salisbury> sometimes I have to google to get the correct name
15:44:58 <Peaker> AfC: Yeah, Lazy/Strict bytestring API fragmentation is so bad...
15:44:59 <salisbury> but after that
15:45:00 <mm_freak> flapjax is also nice, but i'm missing the concept and features of netwire on the client side
15:45:13 <Peaker> AfC: You want to use library A and library B, but one uses only strict BS the other lazy Text, and bah
15:45:17 <mm_freak> FRP in javascript
15:45:19 <Axman6> bashoo: the type system allows us tp implement things that are next to impossible to do 100% correctly in other languages (STM being a prime example)
15:45:41 <Axman6> AfC: what do you mean?
15:46:02 <AfC> Axman6: I mean I agree with the sentiments that Peaker was expressing
15:46:05 <kmc> bashoo, if you want my take on "Why learn Haskell?", see http://mainisusuallyafunction.blogspot.com/2011/10/slides-from-why-learn-haskell.html
15:46:20 <salisbury> adding to Axman6's point, it allows Arrows
15:46:29 <kmc> next to nobody uses Arrows
15:46:35 <salisbury> I love arrows..
15:46:36 <Axman6> i'm not sure i;ve ever even used arrows
15:46:42 <kmc> what do you use them for
15:46:48 <Axman6> maybe once or twice, for first and second
15:46:55 <salisbury> mainly processing text
15:47:02 <kmc> using Control.Arrow on (->) doesn't count
15:47:08 <salisbury> haha, no
15:47:11 <kmc> salisbury, what libraries?
15:47:12 <AfC> Axman6: and, perhpas, that ByteString is a good example of a library that is not core to the language that nevertheless is now universally used, has a massive API wart is hellish for [this] beginner to get through.
15:47:12 <Peaker> I want: A) Tons of unnecessary partiality gone B) Better runtime debuggability, C) package installs to be reliable, some sort of signature dependency spec instead of versions, and ease of making sure code works on older ghc's D) Polymorphic containers E) Clean up stdlib
15:47:20 <dgpratt> kmc: I'd have a hard time taking seriously any programmer who claim's he/she does not make mistakes
15:47:28 <salisbury> HXT as well
15:47:39 <kmc> dgpratt, be that as it may, you hear it all the time, but (more importantly) we all have this subconscious bias, even if we're not aware of it
15:47:56 <mm_freak> i love arrows for AFRP
15:48:01 <bashoo> kmc: looking at your slides, so factorial 0 = 1 is a special case of factorial n right?
15:48:06 <bashoo> or
15:48:13 <bashoo> something else entirely but fixing for that case
15:48:14 <kmc> bashoo, the factorial function is defined by two pattern-matching cases
15:48:16 <AfC> Peaker: the way that NIX manages packages provides some of that out-of-band. You might have a look there.
15:48:16 <EvanR> i write all my application code in ring 0
15:48:26 <EvanR> since i make no mistakes and i need performance
15:48:33 <kmc> yeah exactly
15:48:47 <kmc> people use this argument against managed code
15:48:52 <kmc> "well the runtime could have bugs!!"
15:48:57 <EvanR> lool
15:49:04 <kmc> you can use the same argument to say that we should write all programs as kernel modules
15:49:06 <kmc> and run them in ring 0
15:49:06 <Peaker> AfC: I saw that, it's interesting, but I think it may be a disadvantage that it encourages leaving existing packages linked with older (potentially buggy) dependencies
15:49:07 <Axman6> so could the CPU...
15:49:20 <Peaker> AfC: (when you upgrade a lib it doesn't implicitly upgrade the users to the new one)
15:49:25 <parcs`> watch out for those gamma rays
15:49:26 <EvanR> yeah the cpu has bugs, write all code in microcode
15:49:27 <AfC> Peaker: that is exactly the tradeoff, yes.
15:49:34 <kmc> because the Linux kernel could have bugs!  and by "could have" i mean "a dozen privilege escalation bugs discovered in 2010"
15:49:56 <Peaker> AfC: I think the problem is not so much that installs break existing installs but that version number constraints are just the wrong solution
15:50:13 <luite> has 2011 been better in that respect, for the linux kernel?
15:50:24 <Peaker> AfC: and that having them be *conservative* is so much worse than liberal, because cabal refusals are worse than a broken compile with a usable error message that can typically be fixed
15:50:27 <kmc> there are fewer privesc bugs that i'm aware of
15:50:32 <kmc> but i was also closer to the linux security community in 2010
15:50:35 <kmc> so *shrug*
15:50:39 <Axman6> just means people weren't looking as hard
15:50:58 <Peaker> kmc: did you get to know the Linux TCP/IP implementation?
15:50:59 <mm_freak> Peaker: i think nix' point is consistency…  and you can have a systemwide environment and let your users only install specific packages for their needs
15:51:02 <dgpratt> this is reminding me of a conversation the other day where someone told me that it was their intention to only publish bug-free code
15:51:07 <kmc> Peaker, not intimately
15:51:12 <mm_freak> Peaker: nix even has a single-user mode, where regular users can't even install packages
15:51:15 <AfC> Peaker: anyway, I agree, it's daunting for newcomers.
15:51:19 <mm_freak> then the weakest link is the package maintainer
15:51:24 <AfC> Peaker: [I remember being at LISA 2005 when they first announced NIX package manager. Fascinating, but during questions I stood up and said, "hey, do you guys realize you're going to end up having to maintain your own distro"? :)]
15:51:32 <Peaker> AfC: the problem is the advantages of using Haskell come later.. all these disadvantages attack you immediately
15:51:46 <bashoo> that is a problem?
15:51:48 <Peaker> AfC: so it takes a special kind of persistence to go on and learn the language
15:51:49 <rwbarton> Peaker is just in a bad mood nowadays :P
15:51:49 <mm_freak> dgpratt: actually having that as an /intention/ isn't particularly bad
15:51:56 <dgpratt> not surprisingly, this was not the most experienced individual, at least with respect to software development
15:52:00 <rwbarton> I mean how many beginners are using cabal install in the first place
15:52:08 <Peaker> kmc: There's some horrible design error in there, unless I'm mistaken. I wonder if someone can explain why I'm mistaken
15:52:13 <eyebloom> Why is it necessary that bottom is part of every type?
15:52:17 <kmc> in where?
15:52:22 <kmc> Linux TCP/IP?
15:52:27 <Peaker> kmc: yeah
15:52:28 <bashoo> it is best if the problems are immediate
15:52:34 <Peaker> kmc: I guess in stream sockets in general
15:52:42 <Peaker> kmc: TCP is the most common example
15:52:58 <kmc> eyebloom, with lazy evaluation, any "value" might actually be a deferred computation
15:52:59 <MostAwesomeDude> Hey, is http://www.haskell.org/haskellwiki/Amb a reasonable recipe for getting amb? I want to do some general contraint solving.
15:53:00 <dgpratt> mm_freak: the way it was conveyed, it was clear this person thought it was an achievable goal
15:53:02 <mm_freak> eyebloom: because "x = x" has type 'a'
15:53:06 <kmc> and what if that computation doesn't terminate, or throws an execption?
15:53:07 <AfC> rwbarton: beginner isn't "flipping through LYAH". Beginner is someone writing their first real work program. You know, using a web framework, or... and you need cabal for that. Bam.
15:53:17 <mm_freak> eyebloom: and 'a' unifies with every type
15:53:29 <rwbarton> that doesn't sound like Peaker's contention
15:53:35 <mm_freak> eyebloom: so you can use that 'x' in place of an Int, a Bool or whatever else you might have on your mind
15:53:40 <AfC> rwbarton: it's certainly mine :)
15:53:41 <dgpratt> mm_freak: "we can't have bugs in our software" or something to that effect
15:53:46 <rwbarton> well, ok
15:53:46 <eyebloom> When could a function return bottom?
15:53:55 <Axman6> yes
15:53:59 <kmc> > let f _ = error "bottom" in f ()
15:54:00 <lambdabot>   *Exception: bottom
15:54:02 <Axman6> > let f x = undefined in f 10
15:54:03 <lambdabot>   *Exception: Prelude.undefined
15:54:21 <mm_freak> eyebloom: a function never "returns" bottom…  bottom is a theoretical concept and stands for the value of a function that does in fact /not/ return
15:54:25 <Axman6> > let f x = let y = y in y in f 10
15:54:28 <lambdabot>   mueval-core: Time limit exceeded
15:54:31 <mm_freak> eyebloom: or more generally a value that never gets calculated
15:54:50 <EvanR> > 5 + undefined
15:54:51 <shachaf> mm_freak: Why does a function never return _|_?
15:54:51 <lambdabot>   *Exception: Prelude.undefined
15:54:52 <Peaker> rwbarton: I think the main problems arise when you try to do something real
15:55:12 <ddarius> dgpratt: Simply redefine every bug as a feature.  That stack overflow vulnerability is just a remote administration interface.
15:55:13 <mm_freak> shachaf: because that's a contradiction…  the result of a function being ⊥ means that it did not return
15:55:14 <Peaker> rwbarton: The toy examples in ghci are not much of a problem :)
15:55:26 <rwbarton> hopefully by the time you are doing something real you understand a bit about the GHC package landscape, know about Haskell support channels, have seen a .cabal file, etc.
15:55:34 <dgpratt> ddarius: achievement unlocked! :)
15:55:45 <rwbarton> of course, there are some problems (though I never seem to experience them myself, unless I'm using bleeding-edge GHC)
15:55:46 <shachaf> mm_freak: (const undefined) "returns" _|_, I would say.
15:55:58 <Peaker> rwbarton: I tell people "Haskell is safe" and then they get a runtime crash with no debug info if they accidentally define an empty instance declaration...
15:56:01 <shachaf> If you force the value that it returns, that's a different matter, of course.
15:56:11 <rwbarton> I used python fairly heavily for about half a year and I don't even know what the python equivalent of cabal install *is*.
15:56:21 <shachaf> rwbarton: easy_install?
15:56:26 <mm_freak> shachaf: it still never returns, even less when you never force the result =)
15:56:35 <rwbarton> shachaf: never heard of it
15:56:49 <rwbarton> of course I just installed things through apt.
15:56:54 <shachaf> rwbarton: Well, whenever I need to install a Python package, I just "easy_install PACKAGE" and it seems to work...
15:56:57 <shachaf> Right, or apt.
15:57:01 <donri> or "pip"
15:57:20 <mm_freak> shachaf: but that's really about terminology…  i think that there is a difference between "result" and "returning"
15:57:26 <shachaf> mm_freak: (const undefined) is a value, which happens to be _|_.
15:57:32 <mm_freak> fix (1:) never "returns", but it "results"
15:57:38 <shachaf> mm_freak: Eh, yes, I don't think we have an actual argument. :-)
15:57:39 <mm_freak> in my intuitive terminology
15:57:49 <kmc> one problem is that beginners don't want to write 29 different fibonacci functions
15:57:57 <ddarius> "result" isn't a verb in my language.
15:57:58 <kmc> they want to make web apps and video games and whatever
15:57:59 <mm_freak> shachaf: const undefined ≠ ⊥
15:58:05 <mm_freak> const undefined x = ⊥
15:58:06 <shachaf> mm_freak: Right.
15:58:15 <shachaf> mm_freak: Wait, I meant ((const undefined) x)
15:58:56 <mm_freak> i think it's useful to have a difference between production and finishing
15:58:58 <shachaf> kmc: I think there must be more than one class of beginner. :-)
15:59:05 <mm_freak> where production is "resulting" for me and finishing is "returning"
15:59:09 <mike-burns> I want beginners to have a project in mind! That's important and creative.
15:59:21 <mike-burns> Starting with fib is boring and barely instructive.
15:59:24 <kmc> it's hard to delay gratification though
15:59:25 <salisbury> mike-burns: I agree
15:59:26 <mm_freak> fix (1:) produces before it finishes
15:59:33 <salisbury> that is the only way to learn any language really
15:59:40 <mike-burns> Yeah!
15:59:58 <kmc> to learn Haskell you more or less have to spend a lot of time on problems which seem easy, and feeling very dumb because suddenly they are very hard
16:00:09 <shachaf> kmc: Were web apps and video games and whatever really your goal in learning Haskell?
16:00:23 <kmc> not for me, no
16:00:24 <mike-burns> A language's selling point is: how quickly can I get my project idea into a reality. As I see it, at least.
16:00:27 <donri> kmc: ...only to eventually realize they were always actually quite simple
16:00:33 <kmc> i agree about "more than one class of beginner"
16:00:39 <Philonous> ddarius:  Which language is that?
16:00:55 <donri> mike-burns: then haskell sucks :P
16:01:02 <shachaf> donri: "simple" is distinct from "easy". :-)
16:01:04 <donri> depending on your definition of "reality"
16:01:09 <donri> shachaf: that was intentional
16:01:26 * ddarius doesn't want to know what he pays for electricity now that his refridgerator door doesn't want to close half the time.
16:01:30 <salisbury> donri: Not always in that case. I moved my current project to Haskell from C. C takes far longer to write
16:01:43 <ddarius> In fact, I don't know what I've been paying for electricity for the past year at all.
16:01:45 <donri> ah, but compared to some "quick prototyping" language
16:01:52 <kmc> if you bang your head against that seemingly easy problem for long enough, you discover a fundamentally different way to solve a problem that before seemed to have one clear solution
16:01:54 <donri> if you're new to haskell/fp
16:01:58 <kmc> and for some people this is immensely gratifying
16:02:11 <kmc> and is the payoff for all that time feeling dumb about inability to solve simple problems
16:02:12 <salisbury> also, I can prove the program really easily
16:02:31 <kmc> if you don't find this intrinsically gratifying, you'll probably have a much harder time learning haskell
16:02:58 <mike-burns> I get something different out of Haskell.
16:03:22 <mm_freak> donri: i disagree
16:03:45 <mike-burns> I see it as a quick prototyping language with a loving community.
16:04:04 <mm_freak> it's not as quick prototyping as erlang, but it is a great language for being productive
16:04:24 <mike-burns> Yeah.
16:04:26 <mm_freak> especially in the field of network programming
16:04:46 <mike-burns> I'm slower in Haskell than in Ruby, but I tend to like my Haskell more than my Ruby when I'm done.
16:04:47 * ddarius doesn't think he could "prototype" as quickly in Erlang as he could in Haskell.
16:04:54 <jessopher> the value i derive from haskell is that in order for my programs to be well formed in haskell, i generally have to understand the problem domain a little better
16:05:16 <djahandarie> All my time prototyping in other languages is spent in making that language try to be more like Haskell.
16:05:18 <Axman6> ddarius: i'd find the lack of types a pretty big hinderance
16:05:39 <djahandarie> And all my time prototyping in Haskell is spent in making it try to be more like Agda.
16:05:42 <Axman6> i know they have the dializer, but I'm not sure that it's as useful as an actual type system
16:05:52 <mm_freak> ddarius: well, erlang has a very fine-grained mechanism for applying code changes even into running systems
16:06:04 <djahandarie> And when I try to prototype in Agda, I realize that I should have just given up in the first place.
16:06:06 * DanBurton wonders if he relies too much on types these days; makes it hard to program in untyped languages
16:06:15 <ddarius> mm_freak: That's not usually something I care about in or not in a prototyping environment.
16:06:28 <mike-burns> Heh, yes.
16:06:57 <MostAwesomeDude> Hey, if I implement the Enum typeclass on a type, then I can use syntax like [MyCustomType..] right?
16:07:04 <mm_freak> ddarius: well, if you're thinking of prototyping as in agda, then no, erlang is bad at that
16:07:05 <ddarius> MostAwesomeDude: Yes.
16:07:05 <DanBurton> MostAwesomeDude: yep
16:07:07 <kmc> DanBurton, you just need to keep the types in your head even when they're not checked
16:07:08 <MostAwesomeDude> Nifty.
16:07:09 <Axman6> no!
16:07:12 <Axman6> >_>
16:07:18 <mm_freak> and in that agda (together with emacs) is much better than haskell
16:07:23 <DanBurton> MostAwesomeDude: although it is recommended you put a space before and after the ..
16:07:23 <ddarius> mm_freak: I've never used Agda.
16:07:33 <Axman6> MostAwesomeDude: [a..] -> enumFrom a, [a..b] -> enumFromTo a b etc
16:07:38 <DanBurton> MostAwesomeDude: otherwise it might get confused with trying to parse it as a module name
16:07:45 <mm_freak> ddarius: agda is great for incremental development, i wish haskell had that, too
16:07:49 <ddarius> And wouldn't describe most of the things people do in Agda (that I've seen) as "prototyping", at least not prototyping programs
16:08:26 <MostAwesomeDude> Axman6: Aha. So I probably want to make sure my Enum is complete.
16:08:36 <DanBurton> kmc: I much prefer just spewing out a little code I think is kinda sorta right, and then try to compile to see if it typechecks
16:08:39 <kmc> i think that, if you've already learned Haskell just because, then it's a great tool for being productive in a variety of domains
16:08:49 <MostAwesomeDude> Mostly I want to be able to say "list of all of the possible type constructors for this type."
16:08:53 <DanBurton> then I usually run into a few type errors, fix it up, and then it works
16:08:59 <Axman6> MostAwesomeDude: probably, heh
16:09:06 <Axman6> though, for some types it's not possible I think
16:09:15 <kmc> but i'm not sure it's worth anyone's trouble to learn the language just for a productivity gain in some domain
16:09:18 <mm_freak> ddarius: well, suppose you are writing some code and you want to leave holes for filling in later…  agda allows you to do that and can even derive the terms and types in the holes for you
16:09:20 <kmc> maybe if that domain is "writing compilers"
16:09:21 <Axman6> @instances Enum
16:09:21 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
16:09:23 <mm_freak> (as far as that's possible)
16:09:47 * DanBurton dislikes the Double, Float instances of Enum
16:09:50 <EvanR> fromEnum LT
16:09:50 <mm_freak> and that's live in the editor
16:09:53 <EvanR> > fromEnum LT
16:09:54 <lambdabot>   0
16:10:03 <DanBurton> > [LT ..]
16:10:03 <lambdabot>   [LT,EQ,GT]
16:10:25 <DukeDave> I'm confused.. There's a C++ header in the wxHaskell code, which doesn't appear to be legal, but it builds correctly..
16:10:25 <DukeDave> Does the FFI stuff not have anything to do with the headers?
16:10:35 <salisbury> Erlang just rolls off the fingers though really
16:10:38 <MostAwesomeDude> > [1.0 .. 2.0]
16:10:39 <mike-burns> I like to think that Haskell's domain is a type-safe shell script replacement language.
16:10:39 <lambdabot>   [1.0,2.0]
16:10:42 <kmc> GHC's FFI implementation does not parse headers, no
16:10:43 <MostAwesomeDude> > [1.0 .. 2.1]
16:10:44 <lambdabot>   [1.0,2.0]
16:10:48 <mm_freak> also something i miss in haskell:  i can easily ask for the type of a specific part of my code, even if the code isn't even written
16:10:49 <kmc> certainly not C++ headers
16:11:01 <mm_freak> agda resolves the type of ? in x + ?
16:11:04 <DanBurton> salisbury: anybody could say that about a language they are really familiar with
16:11:20 <salisbury> I suppose.
16:11:26 <rwbarton> :t x + ?y
16:11:27 <lambdabot> (?y::Expr) => Expr
16:11:39 <kmc> if you are using hsc2hs then those headers might get included and compiled as part of a C program which runs at compile time
16:11:40 <mm_freak> mike-burns: uh, that's not fair
16:12:03 <mm_freak> mike-burns: you wouldn't write a high performance concurrent network server as a shell script, would you?
16:12:18 <Axman6> i think people have tried...
16:12:21 <EvanR> that would be awesome
16:13:08 <bashoo> code length
16:13:15 <DukeDave> kmc: I don't think it uses hsc2hs
16:13:40 <DukeDave> There's a package called wxdirect, which parses the headers and spits out Haskell
16:14:47 <DukeDave> No, it doesn't use hsc2hs
16:15:02 <DukeDave> So then the question becomes, why does wxcore maintain the headers at all? :|
16:15:16 <bashoo> is there such a thing as the most concise language?
16:15:18 <mike-burns> mm_freak: I probably wouldn't write a high performance concurrent network server.
16:15:36 <Axman6> mike-burns: u suck
16:15:42 <mm_freak> bashoo: yes:  the domain-specific language, where your program can be expressed by an empty source code file
16:15:53 <mike-burns> bashoo: Felleisen wrote a paper on the expressitivity of languages.
16:16:00 <Sgeo> I keep forgetting when msging lambdabot to use @type instead of :t
16:16:02 <mike-burns> That might be related.
16:16:11 <mm_freak> bashoo: there is a domain-specific language for writing hello world programs, where the hello world program is only one byte
16:16:20 <mm_freak> bashoo: i think it's called "hello world"
16:16:39 <Axman6> 1 byte seems 8 bits too long to me
16:16:42 <bashoo> mike-burns: do you havea link?
16:16:50 <shachaf> Axman6: It's not an 8-bit byte.
16:16:50 <mm_freak> Axman6: not for a turing-complete generic purpose language
16:17:06 <Axman6> true
16:17:10 <bashoo> mm_freak: that is why I said is there such a thing instead of "what is"
16:17:17 <mm_freak> Axman6: although the language semantics could be that the empty program specifically is the hello world program =)
16:17:17 <Axman6> damn hardware constraings. we should have addressable bits!
16:17:18 <mike-burns> bashoo: http://www.ccs.neu.edu/scheme/pubs/scp91-felleisen.ps.gz
16:17:21 <bashoo> thank you
16:17:43 <mm_freak> bashoo: well, notice that in haskell you commonly write EDSLs
16:17:50 <mike-burns> I hear they're working on "hello world++" that wraps all the design patterns into the language.
16:17:57 <mm_freak> so "is there?" is a matter of "am i going to make?"
16:18:04 <ddarius> @google concurrent web server in shell scripts
16:18:06 <lambdabot> http://oracleappsdba-zizou.blogspot.com/2010/10/apache-bounce-concurrent-request.html
16:18:06 <lambdabot> Title: Oracle Apps DBA - Zizou: Apache Bounce Concurrent Request.
16:18:50 <bashoo> mm_freak: kind of defeats the purpose of concision doesn't it?
16:19:21 <mm_freak> bashoo: not if you can express the EDSL concisely
16:19:31 <mm_freak> haskell is really about writing/using EDSLs for your purpose
16:19:40 <mm_freak> even IO is an EDSL
16:19:51 <bashoo> over my head right now
16:20:30 <bashoo> I was just wondering if there was a meaningful way to address the idea that some languages generally take more lines of code
16:20:45 <bashoo> while acknowledging that domain or whatever  is important
16:20:50 <mm_freak> bashoo: data IO a where GetLine :: IO a; PutStrLn :: String -> IO (); AndThen :: IO a -> IO b -> IO b
16:21:09 <mm_freak> and then you have an interpreter for the EDSL, which in this case is the compiler/interpreter
16:21:10 <Axman6> so, what you're talking about the latest cool, funky, hyped language, what's a better term for such a thing. ruby was the ? language a few years ago, haskell is the latest ? language now...
16:21:20 <Axman6> buzzword?
16:21:23 <mike-burns> I think that's what I paper I linked is about, bashoo . Haven't read it in a long while though.
16:21:24 <bashoo> trendy?
16:21:30 <Axman6> trendy is good
16:21:32 <mm_freak> bashoo: well, yes…  you don't have so much syntax noise in haskell
16:21:34 <Axman6> anything else?
16:21:41 <mike-burns> Hyped.
16:21:56 <mm_freak> bashoo: but if you really mean that, then APL is very concise
16:21:57 <mike-burns> It.
16:22:06 <mm_freak> however, you don't really want to write anything serious in APL
16:22:14 <mike-burns> VC-fundable.
16:22:30 <mm_freak> it's like perl on steroids in terms of write-only code
16:22:33 <mike-burns> (Ruby is still VC-fundable.)
16:23:17 <bashoo> cutting edge if you want to put a spin on it
16:23:27 * BMeph prefers J and Q for line-noise languages.
16:24:04 * mike-burns prefers Control.Applicative for line-noise.
16:24:40 * mm_freak prefers {-# LANGUAGE Arrows #-}
16:25:18 <Axman6> mike-burns: the time between them being line noise and being amazingly useful is usually quite short. at least it was for me
16:25:48 <mike-burns> They're useful! But you have to admit that it's a long string of punctuation.
16:25:57 <mike-burns> That is rather hard to read.
16:26:15 <Axman6> it can be
16:26:37 <mike-burns> I wrote Perl for five years, and Control.Applicative is definitely better than Perl.
16:26:37 <Axman6> but, sometimes, Foo <$> get <*> get <*> get <*> get is much clearer than the do notation...
16:26:46 <mike-burns> Oh yes, true.
16:27:21 <Axman6> the <*>'s and <$>'s tend to fade into the background eventually, you're just seeing Foo applied to all the gets, in a special way
16:27:32 <shachaf> iI Foo get get get get Ii
16:27:44 <mm_freak> liftA* is usually more readable
16:27:48 <Axman6> iI?
16:28:20 <mm_freak> if your type is an arrow, you can also use (| |) notation
16:28:32 <Axman6> eh?
16:28:34 <mm_freak> (| f (comp1 -< x) (comp2 -< y) |)
16:28:34 <Axman6> never seen that
16:28:42 <Axman6> o.O
16:28:43 <hpc> we have that now?
16:28:47 <hpc> i thought that was for applicatives
16:28:48 <Axman6> what does that do
16:29:00 <mm_freak> hpc: we've had that for a long time and it's not the same as the idiom brackets in SHE
16:29:04 <hpc> (|f x y|) = f <$> x <*> y
16:29:08 <hpc> ah
16:29:21 <hpc> i vote they be called banana brackets
16:29:27 <scshunt> edwardk: I know you had some library for terminal colours and the like. Which was it again?
16:29:36 <mm_freak> Axman6: normally you would write:  (proc (x, y) -> …) -< (x, y)
16:29:44 <mm_freak> Axman6: but arrow notation allows you to make that implicit
16:29:56 <mm_freak> eh
16:29:59 <edwardk> wlpprint-terminfo and wlpprint-extras
16:30:03 <mm_freak> normally you would write:  f (proc (x, y) -> …) -< (x, y)
16:30:08 <edwardk> the name doesn't exactly roll off the tongue
16:30:19 <edwardk> had i to do it over again i would have chosen 'pretty-colors' ;)
16:30:22 <mm_freak> with (| |) you can write:  (| f (…) |)
16:30:37 <mm_freak> if your 'f' is an operator you don't even need the brackets
16:30:50 <mm_freak> (comp1 -< x) <+> (comp2 -< y)
16:31:04 <mm_freak> arrow notation is quite powerful
16:31:24 <mm_freak> it really gives you back much of the power of monadic do-notation
16:31:24 * Axman6 doesn't understand it, but hasn't tried either
16:31:43 <edwardk> scshunt: note that those both build on the existing terminfo library
16:31:50 <mm_freak> Axman6: it's useful for arrows you don't just use for their Category instance
16:31:56 <scshunt> edwardk: thanks
16:31:56 <ddarius> Axman6: That licenses you to disparage it.
16:32:21 <shereek> Hi everyone
16:32:35 <shereek> I need some help here using parsec
16:33:13 <edwardk> shereek: throw out your questions and folks will typically answer. ;)
16:33:27 <edwardk> enough people in here have used parsec over the years =)
16:34:44 <shereek> ok
16:35:04 <mike-burns> And with that, he sneaks off.
16:36:15 <shereek> I'm using my own data type and I did a parse to recognize this type, but I want to use the result of the function parseTest and convert this value to my data type
16:36:31 <mm_freak> edwardk mainly lives on the type level…  i think his presence here is just a shadow of his higher level reality
16:36:43 <mm_freak> it's a projection
16:37:19 <mm_freak> shereek: which library?
16:37:43 <mm_freak> parsec?  attoparsec?  …?
16:37:44 <shereek> baiscally I need to convert an IO type to my data type
16:37:47 <shereek> Parsec
16:38:06 <Axman6> no!
16:38:30 <mm_freak> shereek: converting "IO a" to "a" is never what you want
16:38:32 <Axman6> there is no converting IO types to other types (we'll ignore monad transformers)
16:38:42 <mm_freak> what you want in this case is the 'parse' function
16:38:56 <Ferdirand> nobody escapes the IO !
16:39:03 <mm_freak> parse myParser "" myString
16:39:27 <mm_freak> it gives you Either ParseError MyType
16:39:52 <bashoo> mike-burns: have you read that? what do you make of it? Outside my knowledge base, but I just breezed over it.
16:39:58 <mm_freak> the empty string i passed is for information purposes…  it improves the parser's error messages for the user…  you can pass a file name for example
16:41:09 <mike-burns> bashoo: I found the first few sections interesting and the remaining sections not-for-me (very proof-heavy). The overall point is that first-class continuations are more powerful than most other constructs.
16:41:14 <mike-burns> (As I remember it.)
16:42:23 <shereek> mm_freak: hey
16:42:49 <shereek> mm_freak: I tested here parse myParser "" myString in my project here
16:44:26 <shereek> mm_freak: May please paste a litteof my code here?
16:45:59 <Philippa> @paste
16:45:59 <lambdabot> Haskell pastebin: http://hpaste.org/
16:46:02 <Philippa> use there
16:46:16 <shereek> Ok thanks
16:47:21 <drull95> how does one determine the encoding of a file using haskell?
16:47:25 <mm_freak> mike-burns: i can't confirm that
16:47:34 <drull95> i have a lexer that failing to parse a latin1 file
16:48:18 <drull95> i guess i will figure out how the file command does
16:48:19 <drull95> it
16:48:21 <mm_freak> mike-burns: delimited CPS is the powerful kind of CPS, and you can have it in haskell through the Cont monad
16:48:57 <mm_freak> drull95: you can't really…  you can recognize certain encodings by special marks (like UTF-8's byte order mark)
16:49:16 <ByronJohnson> drull95: I'd consider the mime package
16:49:21 <mm_freak> drull95: the 'file' command line tool will give you an estimate of the encoding
16:49:59 <ByronJohnson> Actually, I may be thinking of a different package
16:51:06 <drull95> i guess for the time being i could just parse the output of the file command
16:51:20 <mm_freak> that's probably your best bet
16:51:53 <drull95> alright thanks
16:54:41 <mm_freak> drull95: http://hackage.haskell.org/package/magic
16:55:24 <hpaste> sheeerek pasted “Doubt with Parsec” at http://hpaste.org/55326
16:55:53 <shereek> mm_freak: can you please see my paste?
16:55:56 <drull95> oh cool. thanks a bunch
16:56:14 <drull95> i didn't even think of hackage
16:57:53 <drull95> shereek, is that portugese?
16:57:57 <shereek> yes
16:58:06 <mm_freak> shereek: have you trimmed down the code?  it looks like a bunch of syntax errors instead of anything related to parsing
16:58:06 <shereek> sorry but I'm from Brazil
16:58:21 <bashoo> >[a..Z]
16:58:30 <mm_freak> > [a .. z]
16:58:31 <lambdabot>   *Exception: not a number
16:58:50 <shereek> I can post the complete code
16:59:02 <bashoo> oh
16:59:07 <mike-burns> > ['a' .. 'z']
16:59:08 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
16:59:10 <bashoo> > ['a'..'Z']
16:59:11 <lambdabot>   ""
16:59:11 <MostAwesomeDude> > ['a' .. 'z']
16:59:11 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
16:59:15 <shereek> The code is very big
16:59:18 <MostAwesomeDude> > ['A' .. 'z']
16:59:19 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
16:59:24 <mm_freak> shereek: that would be better
16:59:25 <MostAwesomeDude> ASCII order.
16:59:29 <bashoo> ah
16:59:36 <bashoo> ty
16:59:37 <mm_freak> shereek: at least don't strip parts of top level definitions
16:59:38 <shereek> mm_freak: The main doubt is to convert the types
16:59:57 <mm_freak> shereek: it's not…  parseTest is really for testing a parser, not for actual productive parsing
16:59:57 <MostAwesomeDude> I suspect you want ['A' .. 'Z'] ++ ['a' .. 'z']
17:00:06 <bashoo> so returning "" means there isn't anything?
17:00:12 <bashoo> I was just seeing what would happen
17:00:57 <hpaste> shereek annotated “Doubt with Parsec” with “Doubt with Parsec (annotation)” at http://hpaste.org/55326#a55327
17:00:59 <ByronJohnson> bashoo: 'a' is after 'Z'
17:01:03 <ByronJohnson> > 'a' < 'Z'
17:01:04 <lambdabot>   False
17:01:20 <ByronJohnson> > [1..4]
17:01:21 <lambdabot>   [1,2,3,4]
17:01:23 <ByronJohnson> > [4..1]
17:01:24 <lambdabot>   []
17:01:38 <mm_freak> shereek: so far that program doesn't do anything except opening the file
17:01:47 <ByronJohnson> @hoogle Enum
17:01:47 <lambdabot> Prelude class Enum a
17:01:48 <lambdabot> Prelude enumFrom :: Enum a => a -> [a]
17:01:48 <lambdabot> Prelude enumFromThen :: Enum a => a -> a -> [a]
17:01:49 <bashoo> so it is basically saying that there is nothing greater than 4 less than 1
17:01:59 <mm_freak> shereek: if you run that program, no parsing is done
17:02:48 <shereek> mm_freak: The code is too big to post here there is an other file. My doubt is if there is any possible to convert the type IO (IO) to a Data type defined for me
17:03:16 <mm_freak> shereek: what you usually do is this:  case parse myParser fileName contents of Left err -> ...; Right result -> ...
17:03:28 <mm_freak> then 'result' would be (for example) of type Deduction
17:04:51 <mm_freak> notice that 'parse' is a pure function, while 'parseTest' is an IO function that doesn't even give you the parsed result
17:05:31 <drull95> shereek, the most you  could do is contain the IO type within your type
17:05:42 <drull95> but what most haskellers would do
17:05:55 <drull95> is put all the IO on the "outside"
17:06:07 <drull95> and do all the other stuff inside
17:06:33 <mm_freak> shereek: in any case, whenever you feel oblicated to "convert" an IO value, you are likely doing something odd…  at least in your beginner times
17:07:07 <mm_freak> oblicated → obligated
17:07:38 <bashoo> people don't use the arrows in haskell?
17:07:46 <bashoo> <-
17:07:48 <bashoo> someone way saying?
17:07:50 <bashoo> was
17:08:04 <mm_freak> bashoo: which ones?
17:08:10 <mm_freak> '<-' can mean a number of things
17:08:28 <bashoo> I don't know I just saw talk about arrows
17:08:42 <mm_freak> bashoo: in that case "arrows" are on the type level
17:08:43 <bashoo> LYAH is teaching me <-
17:08:52 <shereek> drull95: deriving IO at my type?
17:09:04 <mm_freak> the "<-" you saw in LYAH is likely not related to arrows, but to monadic do-notation
17:09:16 <shachaf> mm_freak: "<-" means just one thing, but that one thing can mean a number of things. :-)
17:09:27 <drull95> no you can't derive IO
17:09:30 <shachaf> Actually I guess there's pattern guards.
17:09:39 <mm_freak> shachaf: do-notation, pattern guards, arrow notation, etc.
17:09:44 <mm_freak> so a number of things =)
17:09:59 <shereek> drull95: So wjat do you mean use IO at my data type? Can you please give me an example?
17:10:01 <bashoo> it is list comprehension
17:10:12 <drull95> read the file into a string, pass the string to your parser and get back a result of IO Parsed
17:10:28 <shachaf> mm_freak: Arrow notation isn't Haskell. :-)
17:10:35 <drull95> then pass Parsed to your deduction machinery
17:10:40 <mm_freak> oh yeah, and list comprehension, although that's really just do-notation =)
17:11:07 <mm_freak> drull95: he doesn't seem to understand how to parse without IO =)
17:11:22 <mm_freak> shereek: again, use 'parse' instead of 'parseTest', then you don't get IO in the first place
17:11:43 <drull95> well im bored anyway and i do like to teach
17:12:01 <mm_freak> shereek: it's haskell, it's just not h2010 =)
17:12:24 <mm_freak> uhm
17:12:25 <drull95> im writing a toy c++ parser, lol
17:12:29 <mm_freak> that was for shachaf, not shereek
17:12:31 <vrook> @pl foldr ((++) . f) []
17:12:31 <lambdabot> foldr ((++) . f) []
17:12:47 <mm_freak> a "toy" c++ parser lol
17:12:52 <vrook> @pl concatMap' f = foldr ((++) . f) []
17:12:52 <lambdabot> concatMap' = flip foldr [] . ((++) .)
17:12:59 <vrook> hmm
17:13:07 <vrook> I wanted (concat .) . map
17:13:15 <mm_freak> i'd be surprised if parsing c++ is even decidable =)
17:13:58 <mm_freak> vrook: @pl isn't that intelligent
17:14:14 <vrook> yeah it would need to do mathematica-like symbolic transforms
17:14:16 <mm_freak> @pl concatMap' f x = concat (map f x)
17:14:16 <lambdabot> concatMap' = (=<<)
17:14:19 <mm_freak> lol
17:14:43 <vrook> maybe it is?
17:14:50 <mm_freak> @pl f ==<< x = concat (map f x)
17:14:51 <lambdabot> (line 1, column 10):
17:14:51 <lambdabot> unexpected "="
17:14:51 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
17:15:00 <mm_freak> huh?  doesn't seem to support infix
17:15:05 <vrook> oh perhaps it's just doing a direct match without rules
17:15:35 <mm_freak> it certainly has rules…  a lot of them probably
17:15:46 <shereek> mm_freak: Hey I'm newbie in haskell. I've already got the string and all I need is to convert it to my data Type
17:16:23 <shachaf> mm_freak: What *isn't* Haskell?
17:16:27 <mm_freak> shereek: wasn't meant as an offense…  as soon as you have the 'contents' value you can write this:
17:16:47 <mm_freak> let mx = parse myParser fileName contents
17:16:56 <mm_freak> then you can use 'case' with mx
17:17:03 <mm_freak> case mx of
17:17:08 <mm_freak>     Right result -> ...
17:17:22 <mm_freak> for the "..." 'result' is defined as your parser's result
17:18:10 <mm_freak> more concisely you can just write:  case parse myParser fileName contents of
17:18:15 <mm_freak> saving the 'let'
17:19:38 <shereek> mm_freak: Ok I will test
17:20:51 <mm_freak> shereek:  perhaps this will help you:  parse :: Parser Deduction -> Context -> String -> Either ParseError Deduction
17:21:12 <mm_freak> Context is just String and it's only for the parser's error messages, so usually you would just pass the file name there
17:21:43 <shereek> mm_freak: I got the error: Couldnt match expected type IO b0 with actual Type Deduction
17:21:59 <mm_freak> shereek: could you paste the new code?
17:22:20 <shereek> mm_freak: I'm gonna paste now... sorry
17:24:04 <vrook> So point-free is concatMap' = (concat .) . map -- and 2-point is concatMap' f x = concat (map f x) -- what is the 1-point form?
17:24:25 <shereek> mm_freak: Its says that the constructor type Context is not in scope :S
17:24:38 <mm_freak> vrook: concatMap f = concat . map f
17:24:43 <mm_freak> that's the nicest variant IMO
17:24:48 <vrook> ah thanks
17:24:56 <mm_freak> shereek: ah, no, don't put the type into your code =)
17:25:06 <mm_freak> shereek: the 'parse' function is predefined by parsec
17:26:23 <vrook> concatMap' = (concat .) . map was misleading to me because it tempts me to just stick an f on the end. I suppose function arguments are like infixl 10
17:27:47 <mm_freak> well, removing the points from 2-point compositions usually yields ugly code
17:28:14 <mm_freak> like:  groupsOf n = takeWhile (not . null) . map (take n) . iterate (drop n)
17:28:19 <mm_freak> very readable, while
17:28:23 <mm_freak> @pl groupsOf n = takeWhile (not . null) . map (take n) . iterate (drop n)
17:28:23 <lambdabot> groupsOf = (takeWhile (not . null) .) . ap ((.) . map . take) (iterate . drop)
17:28:26 <shereek> mm_freak: any other sugestion?
17:28:28 <mm_freak> horror
17:28:35 <mm_freak> shereek: yes, paste the code =)
17:28:52 <shereek> mm_freak: what code?
17:29:00 <shereek> mm_freak: Mine?
17:29:02 <mm_freak> shereek: does you code work right now?
17:29:05 <mm_freak> your
17:29:08 <shereek> mm_freak: yes
17:29:18 <shereek> mm_freak: I'm gonna paste it
17:29:24 <mm_freak> shereek: then no need to paste =)
17:30:02 <mm_freak> i'd probably come up with a lot of controversial suggestions ;)
17:30:19 <monochrom> there are several different compositions of arity-2 functions. if you like pointfree, you should consider defining corresponding combinators for those compositions respectively.
17:30:40 <shereek> mm_freak: No problem, maybe this controversial suggestions will work ^^
17:31:01 <mm_freak> the reader monad is actually quite helpful for composing 2-ary functions
17:31:12 <drull95> i love pointfree
17:31:16 <drull95> so concise
17:31:16 <mm_freak> but someone not used to it will find your code unintelligible
17:31:41 <mm_freak> drull95: not always
17:32:05 <drull95> i use whatever is efficient and pretty
17:33:19 <mm_freak> :t liftA2 (.) (map . take) (iterate . drop)
17:33:20 <lambdabot> forall a. Int -> [a] -> [[a]]
17:33:49 <mm_freak> that's streamGroupsOf, 2-ary…  reader monad makes it somewhat readable, but as soon as you try to add the takeWhile part it becomes very ugly
17:34:10 <drull95> whenever i use iterate i end up with complex code
17:34:23 <mm_freak> drull95: the map/iterate pattern is very useful
17:34:38 <mm_freak> > map (take 3) . iterate (drop 3) $ [1..]
17:34:39 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23...
17:35:17 <drull95> that's a nice example. maybe i'm doing something wrong...
17:35:22 <drull95> actually i know what i do wrong
17:35:33 <drull95> i use iterate when i should use arrows or something
17:35:55 <mm_freak> what do you use it for?  and why do you think that arrows could solve your problem?
17:35:59 <drull95> when you want an accumulator iterate is not a good solution
17:36:10 <drull95> tuples and bookkeeping everywhere
17:36:22 <mm_freak> fix is good for that
17:36:30 <drull95> i can't give an example cause i don't have the code any more
17:36:48 <drull95> i've grown as a haskeller and don't solve problems the same way anymore :)
17:37:02 <mm_freak> > fix (\r x y -> x : r y (x+y)) 0 1
17:37:02 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:37:05 <vrook> It's interesting that concat . map f is "obvious" but I  can barely understand (concat .) . map at all.
17:38:53 <mm_freak> drull95: i often use the "fix $ \again" pattern, not only for lists
17:38:55 <parcs`> vrook: substitute . for its definition and see that it works out
17:39:48 <drull95> i'm constantly learning that what i need is already there. i'm just blind
17:39:51 <vrook> oh I can see it working out, but it's like working out the algebra instead of visualizing like geometry.
17:40:04 <drull95> i should get a dog and him code
17:40:16 <mm_freak> > fix (\again n x -> x : again (succ n) (mod (x^2 + 1) n)) 10 1
17:40:16 <lambdabot>   [1,2,5,2,5,12,10,5,9,10,6,17,17,4,17,2,5,0,1,2,5,26,26,5,26,31,17,2,5,26,14...
17:40:28 <mm_freak> > fix (\again n x -> (x .&. 1) : again (succ n) (mod (x^2 + 1) n)) 10 1
17:40:29 <lambdabot>   [1,0,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,0,...
17:40:34 * BMeph prefers "(result concat) . map" himself... ;)
17:40:40 <vrook> meaning, I don't have a "picture" in my head of (concat .) . map, but I do for concat . map f
17:41:00 <parcs`> (concat .) . map says 'compose concat with the application of 'map' to something
17:41:57 <drull95> oh i see. that took a second to get
17:47:00 <cgroza> Is there a function that takes a []
17:47:23 <cgroza> Is there a function that takes a [[a]] and returns the second a from every list?
17:47:36 <mm_freak> cgroza: map (!! 1)
17:47:38 <shachaf> map (!!1)
17:47:41 <mm_freak> but very unsafe
17:47:47 <shachaf> What mm_freak said.
17:47:59 <bashoo> any comments on the difference between > let (a,b:_:_) = (10,"abc") in b
17:47:59 <MostAwesomeDude> Is there a safer !! ?
17:48:00 <bashoo> => 'a'
17:48:02 <bashoo> > let (_,(a:_)) = (10,"abc") in a  ?
17:48:02 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:48:03 <bashoo> err
17:48:11 <MostAwesomeDude> @hoogle [a] -> Maybe a
17:48:11 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
17:48:11 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
17:48:11 <lambdabot> Prelude head :: [a] -> a
17:48:15 <cgroza> no worries, those lists can't get shorter than that.
17:48:33 <bashoo> > let (a,b:_:_) = (10,"abc") in b
17:48:34 <lambdabot>   'a'
17:48:36 <MostAwesomeDude> Er, that's not what I wanted.
17:48:44 <mm_freak> @hoogle Int -> [a] -> Maybe a
17:48:44 <lambdabot> Prelude (!!) :: [a] -> Int -> a
17:48:44 <lambdabot> Data.List (!!) :: [a] -> Int -> a
17:48:44 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
17:48:44 <bashoo> > let (_,(a:_)) = (10,"abc") in a
17:48:45 <lambdabot>   'a'
17:48:48 <bashoo> those two
17:49:02 <MostAwesomeDude> @hoogle Num n => [a] -> n -> Maybe a
17:49:03 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
17:49:03 <lambdabot> Prelude (!!) :: [a] -> Int -> a
17:49:03 <lambdabot> Data.List (!!) :: [a] -> Int -> a
17:49:08 <mm_freak> cgroza: sounds like an application of Data.Vector
17:49:35 <mm_freak> of → for
17:50:42 <mike-burns> > head $ snd (10, "abc")
17:50:42 <lambdabot>   'a'
17:52:10 <benmachine> MostAwesomeDude: listToMaybe . drop n
17:58:09 <hpaste> sheeeerek pasted “My Parse Code” at http://hpaste.org/55328
18:00:18 <vrook> Is there a reason that Prelude has concatMap f = foldr ((++) . f) [] instead of concat . map f ? It seems like foldr would be less economical.
18:00:39 <kmc> why?
18:01:37 <vrook> Well concat . map f gives you elements from left to right, whereas foldr has to traverse the whole input and yield them back.
18:02:31 <kmc> no it doesn't
18:02:51 <kmc> > let mapp f = foldr ((:) . f) [] in mapp succ [1..]
18:02:53 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
18:03:15 <shereek> 29,30...
18:03:15 <DanBurton> @src map
18:03:16 <lambdabot> map _ []     = []
18:03:16 <lambdabot> map f (x:xs) = f x : map f xs
18:03:36 <DanBurton> map appears to be written in right-fold style
18:03:59 <shachaf> Lists are also written in right-fold style.
18:04:15 <kmc> right, «foldr f z» just replaces (:) with f and [] with z
18:04:19 <monochrom> > head (foldr ((++) . id) [] (repeat "x"))
18:04:21 <lambdabot>   'x'
18:04:30 <monochrom> does not traverse the whole infinite list
18:05:18 <djahandarie> Nothing traverses the whole infinite list
18:05:33 <vrook> I was looking at the equation foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...) at http://haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Data-List.html
18:05:53 <kmc> f might produce something before forcing its right-hand argument
18:06:04 <vrook> So it needs to know xn `f` z before it can calculate x1 `f` ...
18:06:11 <monochrom> sure. think of how strict or non-strict f is in its two arguments
18:06:20 <kmc> > let f = const in 2 `f` undefined
18:06:21 <lambdabot>   2
18:06:38 <kmc> > 2 `const` (sum [1..])
18:06:39 <lambdabot>   2
18:07:00 <monochrom> > foldr (&&) undefined (repeat False)
18:07:01 <lambdabot>   False
18:07:02 <kmc> > 2 : undefined
18:07:02 <lambdabot>   [2*Exception: Prelude.undefined
18:07:06 <kmc> > head (2 : undefined)
18:07:07 <lambdabot>   2
18:07:12 <monochrom> so much for "need to know"
18:07:49 <monochrom> in fact, even if you write it out:
18:07:58 <monochrom> > False && (undefined && undefined)
18:07:59 <lambdabot>   False
18:08:32 <vrook> Yes, the equation is only telling me that in order to know the whole list, you need to know (xn `f` z), which is a tautology. The thing that's misleading to me is that xn `f` z is the first thing calculated in that equation.
18:08:58 <kmc> it's not
18:09:03 <monochrom> order of parsing is not order of evaluation.
18:09:05 <kmc> or what do you mean by "first thing"
18:09:14 <monochrom> @quote monochrom lazy
18:09:14 <lambdabot> monochrom says: some kind of lazy evaluation is already known to highschool kids. teachers tell you that in a*(b+c), "evaluate b+c first", right? well, I challenge you to take 0*(389238493+97283748)
18:09:14 <lambdabot> and find one single student who faithfully evaluate 389238493+97283748 first.
18:09:40 <monochrom> seriously, answer me: 0*(389238493+97283748)  do you seriously evaluate 389238493+97283748 first?
18:09:58 <vrook> But doesn't foldr build up a whole bunch of thunks, where as concat . map f doesn't?
18:10:03 <monochrom> False && (undefined && undefined) what is evaluated first?
18:10:04 <vrook> *whereas
18:10:07 <kmc> no
18:10:28 <kmc> <kmc>  «foldr f z» just replaces (:) with f and [] with z
18:10:35 <monochrom> foldr does or does not build up a large thunk depending on f
18:11:14 <vrook> is the same true of concat . map f ?
18:11:15 <monochrom> or rather s/build up/becomes/
18:11:40 <kmc> «concat . map f» potentially uses more space
18:11:52 <benmachine> vrook: concat . map f can quite easily be implemented in terms of two foldrs
18:11:53 <kmc> because 'map' produces (:)-cells and 'concat' consumes those cells
18:12:03 <kmc> but these things happen at the same time
18:12:10 <kmc> and a clever implementation will fuse them
18:12:17 <monochrom> ((++) . f) passed to foldr ensures that foldr does less work than concat . map f
18:12:19 <benmachine> in which case you end up with just one foldr
18:12:27 <benmachine> i.e. they're actually the same
18:13:03 <benmachine> I think the upshot is, concat . map f and the foldr version are certainly semantically equivalent, and probably asymptotically the same
18:13:10 <kmc> vrook, so, back up, you asked about what happens first when you force  «x1 `f` (x2 `f` ... (xn `f` z)...)»
18:13:30 <kmc> well the first thing is you force f itself
18:13:34 <shachaf> monochrom: Well, FSVO "ensure".
18:13:43 <shachaf> They might well both get fused to the same thing.
18:13:46 <benmachine> which one is actually faster is probably a question only a benchmarker can answer with any reliability
18:13:46 <monochrom> because like I said, foldr becomes or does not become a large thunk depending on the operator you give it. you give it ((++) . f), that one prevents large thunk
18:13:58 <kmc> but it's probably already in whnf
18:14:24 <kmc> so then we apply f to the arguments «x1» and «(x2 `f` ... (xn `f` z)...)», either of which can be an unevaluated thunk
18:14:29 <kmc> what happens next is up to f
18:14:37 <monochrom> shachaf, so it is FSVO "less than", for example <=
18:14:55 <kmc> if «f _ _ = 3» then we just get 3, neither argument is forced
18:15:10 <kmc> if «f x _ = x» then we get the head of the list and ignore the rest
18:15:44 <kmc> if «f x y = x : y» then we get something which, if you look only at the head, folds only as far as the head, but if you look further then it computes the fold further
18:15:53 <kmc> because the fields of (:) are thunks
18:15:55 <monochrom> you probably need my http://www.vex.net/~trebla/haskell/lazy.xhtml
18:16:06 <shachaf> monochrom: Well, I don't think there are any guarantees by the Report about "how much work is done" anyway. :-)
18:16:07 <kmc> in fact, the "something" which does this is the same as the input list
18:16:30 <monochrom> no, not the report, but knowledge of typical compilers and interpreters
18:16:35 <kmc> > let head = foldr const (error "head: empty list") in head [5..]
18:16:36 <lambdabot>   5
18:16:54 <kmc> vrook, ^^^ it doesn't traverse to the end of [5..], or build up a bunch of thunks
18:18:15 <kmc> the «foldr ((++) . f) []» definition is manually fusing concat and map
18:18:28 <vrook> thanks, I'm still working on fixing the reasoning that lead me to say that.
18:18:28 <kmc> you hope that a good implementation will generate the same code from «concat . map f»
18:19:04 <hpc> kmc: or better than, if other fusion rules yield better performance
18:19:08 <kmc> note that foldl is never lazy this way
18:19:10 <kmc> @src foldl
18:19:10 <lambdabot> foldl f z []     = z
18:19:10 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
18:19:30 <kmc> this looks good under eager evaluation, because it's tail-recursive
18:19:39 <vrook> Here was my faulty reasoning: In order to get the output element, you have to use the initial value z passed to foldr. But that z is embedded deep inside the parens.
18:19:43 <kmc> but it's bad under lazy evaluation, because it doesn't produce stuff as you go along
18:20:03 <vrook> So you have to travel deep into the parens to evaluate the z.
18:20:05 <kmc> forcing «foldl f z (x:xs)» will always require forcing «foldl f (f z x) xs» and on down the list
18:20:20 <kmc> vrook, your error is at "In order to get the output element, you have to use the initial value z passed to foldr"
18:20:36 <kmc> in my 'head' example, the 'z' value is (error "head: empty list")
18:21:17 <kmc> it's up to 'f', whether and when it forces its right hand argument
18:21:31 <vrook> So the first output element of a folder doesn't depend on z?
18:21:35 <vrook> *foldr
18:21:55 <kmc> what do you mean by "first output element"?
18:21:59 <monochrom> again, that's for f to decide
18:22:02 <kmc> outermost constructor, i.e. weak head-normal form?
18:22:43 <vrook> I just mean the index 0 element of the list that foldr spits out
18:22:43 <monochrom> foldr (+) z depends on z for Int's (+). foldr const z is not going to depend on z for non-empty list
18:22:52 <kmc> vrook, foldr doesn't always spit out a list
18:23:34 <vrook> sorry, I just mean it needs to use the first element.
18:23:40 <monochrom> foldr f z (x:xs) -> x `f` foldr f z (x:xs)  what happens next is up to f.
18:23:47 <vrook> ugh, I mean the initial value
18:24:07 <kmc> > foldr (\_ _ -> "ok") (error "doesn't use initial value") (error "whoops, not a list at all")
18:24:08 <lambdabot>   "*Exception: whoops, not a list at all
18:24:20 <monochrom> so in general you don't even know whether so-called (x2 `f` ... (xn `f` z)...) is even built or not at all
18:24:23 <kmc> oh derp
18:24:45 <kmc> > foldr (\_ _ -> "ok") (error "doesn't use initial value") (error "no first element" : error "whoops, not a list at all")
18:24:46 <lambdabot>   "ok"
18:25:30 <kmc> vrook, you would agree that under lazy evaluation, we might get a result from (f x y) without f completely evaluating x and y?
18:25:43 <monochrom> if you now say, is the haskell wiki article wrong? I may be inclined to say sure. afterall, I didn't write it.
18:26:20 <vrook> They say that hardest part of learning to pilot a plane is unlearning how to drive. I think I'm running into a similar issue. I thought I understood foldr, but my previous learning is sidetracking me again.
18:26:45 <kmc> it just replaces (:) with f and [] with z
18:26:58 <kmc> we don't even need data
18:27:06 <kmc> we could replace every list xs with the function (\f z -> foldr f z xs)
18:27:12 <vrook> kmc: yes I understand that part, I'm just putting it together with my unlearning.
18:27:42 <kmc> under lazy evaluation, you might get a result from (f x y) without f completely evaluating x and y
18:28:01 <kmc> furthermore you might get a "result", like a list, which, as you force parts of it, forces more of x and y
18:29:06 <kmc> foldr f z (x:xs) = f x (foldr f z xs)
18:29:27 <kmc> you might get a result from «f x (foldr f z xs)» without it completely evaluating x and (foldr f z xs)
18:29:36 <kmc> it all depends on f
18:30:37 <kmc> when f = const, you definitely will
18:30:40 <kmc> and you don't use z
18:31:15 <kmc> (i'd never heard that about planes and driving...)
18:33:12 <monochrom> @quote monochrom unlearning
18:33:13 <lambdabot> monochrom says: Learning is unlearning. Intuition is experience. Understanding is feeling.
18:33:21 <monochrom> that's what you heard :)
18:33:33 <MostAwesomeDude> Beginner's mind, unfinished block, etc.
18:34:31 <vrook> If we rewind the conversation and say that f is strict in both of its arguments, do my foldr statements become true?
18:34:45 <kmc> i think so
18:35:13 <MostAwesomeDude> Is there a function [a] -> Bool which can determine whether the input list is sorted?
18:35:19 <vrook> I was remembering examples like http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27 , which uses +.
18:35:23 <kmc> that's why you'd write «sum = foldl' (+) 0» and not «sum = foldr (+) 0»
18:35:37 <vrook> and + is strict in both.
18:35:43 <monochrom> yes, see my http://www.vex.net/~trebla/haskell/lazy.xhtml
18:35:54 <kmc> :t \xs -> and $ zipWith (<) xs (tail xs)
18:35:55 <lambdabot> forall a. (Ord a) => [a] -> Bool
18:36:07 <kmc> MostAwesomeDude, ^^^  (you probably want (<=) though, wohops)
18:36:27 <shachaf> kmc: I would say (<=).
18:36:27 <kmc> vrook, (+) is strict in both for Int and Integer and friends, anyway
18:36:28 <shachaf> Oh.
18:36:41 <MostAwesomeDude> kmc, shachaf : yeah, I guess that works.
18:36:41 <kmc> (does the Report guarantee that?)
18:36:57 <kmc> vrook, you can define (+) for your own type and make it lazy if you like
18:37:12 <shachaf> @ty all (uncurry (<=)) . (zip <*> tail)
18:37:13 <lambdabot> forall a. (Ord a) => [a] -> Bool
18:37:21 <kmc> for example lazy addition of inductive naturals:  data Nat = Zero | Succ Nat
18:37:35 <kmc> then you can say things like «sum [1..] > 7» and get True
18:38:00 <shachaf> kmc: Well, not for sum.
18:38:13 <shachaf> But foldr (+) 0 [1..] > 7
18:38:21 <vrook> does ghci or something else tell me what is strict? I want something like (+) :: (Num a) => !a -> !a -> a
18:38:26 <kmc> mm, right
18:38:49 <kmc> because like i said earlier, sum is implemented with foldl, which always walks to the end
18:39:03 <kmc> vrook, you're not going to get that one specifically
18:39:13 <kmc> because (+) is implemented differently for each type which is an instance of Num
18:39:20 <kmc> they can differ in strictness
18:39:27 <vrook> ok
18:39:30 <kmc> as i was saying
18:39:45 <kmc> more generally, no, I don't know of a ghci feature to display strictness information
18:40:00 <kmc> ghc does some heuristic strictness analysis during compilation
18:40:04 <kmc> it's an important optimization
18:40:21 <kmc> but it's undecidable whether a function is really strict or not
18:40:48 <shachaf> kmc: You can always apply it to _|_ and wait a few seconds.
18:41:02 <shachaf> (Where by _|_ I mean (error "foo").)
18:41:18 <shachaf> For most cases where people are curious whether a function is strict, that would probably work.
18:41:37 <kmc> nobody would ever write a function which takes more than a few seconds to return ;)
18:41:54 <kmc> but yeah
18:41:56 <shachaf> kmc: For most queries of the sort asked in #haskell by people learning what strictness is.
18:42:13 <kmc> if you want to know whether a specific expression is being forced, replace it with «undefined» or «error "foo"»
18:42:45 <shachaf> That's not strictly the same as strictness, but it's an easy first approximation.
18:42:51 <vrook> kmc: thanks for the learnings
18:42:54 <kmc> :)
18:43:00 <djahandarie> > let x = undefined in const undefined x
18:43:01 <lambdabot>   *Exception: Prelude.undefined
18:43:27 <shachaf> > let x = error "foo" in const undefined x
18:43:28 <lambdabot>   *Exception: Prelude.undefined
18:43:35 <djahandarie> :(
18:43:56 <shachaf> > id runST undefined
18:43:56 <lambdabot>   Cannot match a monotype with `forall s. GHC.ST.ST s a'
18:43:58 <shachaf> > (id runST) undefined
18:43:58 <lambdabot>   *Exception: Prelude.undefined
18:44:13 <rwbarton> shachaf: Ssssh.
18:44:18 <shachaf> rwbarton: ?
18:44:39 <rwbarton> Causing trouble with your f x y vs. (f x) y examples.
18:45:00 <shachaf> I don't see no trouble.
18:46:20 <kmc> looks like trouble to me
18:46:33 <djahandarie> I don't think that should even happen
18:46:33 <kmc> i had not seen this particular example of trouble before
18:46:38 <kmc> thank you for showing me
18:46:44 <djahandarie> Probably due to an old GHC version on lambdabot
18:47:10 <monochrom> 6.12.3
18:47:24 <kmc> well, it's type inference for higher-rank types
18:47:24 <djahandarie> < 7 :)
18:47:28 <shachaf> kmc: It's fixed in GHC 7.
18:47:33 <kmc> ghc doesn't guarantee much about that, does it?
18:47:34 <shachaf> And by "fixed" I mean "broken differently".
18:48:35 <int80_h> I'm looking for a function that is the opposit of concat, [a]->[[a]]. hoogle isn't helping. Any ideas?
18:48:37 <drull95> isnt that the only kind of fixed there is?
18:48:50 <kmc> :t (:[])
18:48:51 <lambdabot> forall a. a -> [a]
18:49:09 <kmc> :t (:[]) :: [a] -> [[a]]
18:49:09 <lambdabot> forall a. [a] -> [[a]]
18:49:26 <shachaf> @ty pure :: [a] -> [[a]]
18:49:26 <lambdabot> forall a. [a] -> [[a]]
18:49:38 <int80_h> pure looks right
18:49:44 <djahandarie> Is pure the only pure function???
18:49:45 <int80_h> what library?
18:49:52 <kmc> Control.Applicative
18:49:55 <shachaf> @ty getZipList . pure :: [a] -> [[a]]
18:49:56 <kmc> also 'return' from Control.Monad
18:49:56 <lambdabot> forall a. [a] -> [[a]]
18:50:00 <kmc> obviously there are many functions
18:50:02 <kmc> of that type
18:50:24 <kmc> i picked one arbitrarily, supposing that either you don't care which one, or i would happen to guess right, or it would be a smartass answer and you would specify further
18:50:25 <rwbarton> how about you tell us a little about what you expect your function to do?
18:50:30 <shachaf> int80_h: There exist many functions of type [a] -> [[a]], and at least two of them are some sort of local optimum of simplicity.
18:50:41 <kmc> :t map (:[])
18:50:42 <lambdabot> forall a. [a] -> [[a]]
18:50:48 <shachaf> OK, three.
18:51:07 <kmc> > let f = (:[]); g = map f in (f "testing", g "testing")
18:51:08 <lambdabot>   (["testing"],["t","e","s","t","i","n","g"])
18:51:21 <int80_h> rwbarton: I have a list of (funky yesod type that render radio buttons), I need to make a list of list of those.
18:51:35 <rwbarton> that wasn't helpful in the slightest
18:51:38 <kmc> yes, you already told us you wanted to turn a list into a list of lists but... which one?
18:51:52 <shachaf> > let f = (:[]); g = map f; h = repeat in (f "testing", g "testing", h "testing")
18:51:54 <lambdabot>   (["testing"],["t","e","s","t","i","n","g"],["testing","testing","testing","...
18:51:56 <int80_h> okay , hold on, I will look it up
18:52:00 <rwbarton> > tails "testing"
18:52:01 <lambdabot>   ["testing","esting","sting","ting","ing","ng","g",""]
18:52:15 <kmc> for that matter i can recommend «const []» and «const [[]]» and «const [[], [], []]»
18:52:26 <kmc> these also have the right type
18:52:42 <shachaf> Oh, true.
18:52:45 <shachaf> const []
18:52:50 <drull95> > tails "echo"
18:52:50 <rwbarton> chunks 3
18:52:51 <lambdabot>   ["echo","cho","ho","o",""]
18:52:53 <int80_h> I want to do this [1,2,3,4] and get [[1],[2],[3],[4]]
18:53:04 <kmc> > map (:[]) [1,2,3,4]
18:53:05 <lambdabot>   [[1],[2],[3],[4]]
18:53:11 <kmc> > map pure [1,2,3,4] :: [[Int]]
18:53:12 <lambdabot>   [[1],[2],[3],[4]]
18:53:22 <int80_h> ah I was about to try our pure
18:53:26 <int80_h> yeah I want pure
18:53:38 <rwbarton> writing pure for (:[]) is pretty odd
18:53:49 <kmc> but it's one character shorter!!!
18:53:53 <int80_h> okay I use (:[])
18:53:55 <rwbarton> true
18:54:00 <shachaf> "pure" is a bad name.
18:54:06 <kmc> yep
18:54:11 <shachaf> Why do bad names happen to good functions?
18:54:43 <drull95> what would be a good name?
18:54:54 <int80_h> microsoft is somehow responsible for this travesty.
18:54:57 <benmachine> pure's not as bad as return
18:55:09 <kmc> η
18:55:27 <shachaf> benmachine: I think it's worse.
18:55:34 <drull95> return -> inMonad
18:55:53 <kmc> 'return' encourages false semantics and broken code
18:55:56 <drull95> kmc, i'm all for funky characters, i should learn apl
18:56:04 <shachaf> "pure" suggests that it has anything to do with "impurity".
18:56:05 <kmc> 'pure' encourages false understanding and time-wasting philosophy discussions
18:56:50 <kmc> it's not that funky
18:56:59 <benmachine> I kind of think pure makes sense inasmuch as it tends to be 'purely a value'
18:57:02 <benmachine> 'no additional magic'
18:57:03 <kmc> it's part of an alphabet used by 13 million people
18:57:43 <DanBurton> we should just rename "return" to "foo". That way it will be impossible to draw false meaning out of it.
18:58:00 <drull95> yeah i was just kidding, i think we could use an expansion in the operator space
18:58:29 <drull95> i made a toy haskell which supports prefix operators and i really like it
18:59:23 <drull95> im trying to learn some linear programming but my mind doesn't wrap around it so well
18:59:36 <drull95> i've learned i need to review linear algebra
18:59:46 <benmachine> linear algebra is fun
19:00:20 <drull95> haskell has gotten me into higher mathematics
19:00:44 <benmachine> I was already into higher mathematics
19:00:48 <mm_freak> shachaf: pure is a very good name actually
19:00:51 <benmachine> it's the best
19:01:01 <kmc> i was into higher mathematics before it was cool
19:01:11 <DanBurton> mm_freak: what's your reasoning?
19:01:18 <benmachine> kmc: i.e. now :P
19:01:20 <mm_freak> where 'Applicative f => f a' is an effectful value, 'pure' makes one without effects
19:01:27 <mm_freak> by definition 'pure x' can't have effects, so it's pure
19:01:32 <int80_h> kmc is a hipster haskeller
19:01:49 <DanBurton> makes sense
19:02:08 <benmachine> mm_freak: that's what I said, but in fairness the values/effects dichotomy doesn't always naturally translate
19:02:28 <DanBurton> benmachine: for example?
19:02:49 <mm_freak> benmachine: in what cases does it fail?
19:03:02 <benmachine> mm_freak: it's not that it fails as such
19:03:07 <mm_freak> note: with "effect" i don't mean "side effect"
19:03:08 <mm_freak> just effect
19:03:17 <benmachine> it's just sometimes it doesn't feel like the most natural way of looking at things
19:03:32 <benmachine> describing [2,3] as a value with effects is a bit strange
19:04:00 <mm_freak> the effect of a value of type [Int] is that there may be arbitrarily many Int values
19:04:16 <benmachine> to me that requires a very hazy notion of the term 'effect'
19:04:33 <benmachine> also, pure 0 :: ZipList Int -- what's the effect here?
19:04:38 <mm_freak> why?  "effect" is a very broad term
19:05:00 <mm_freak> there is no effect there…  by definition 'pure 0' won't have functor-specific effects
19:05:01 <benmachine> it can be
19:05:19 <benmachine> mm_freak: ok so what is the effect associated with a specific ZipList
19:05:23 <rwbarton> the effect is that you are allowed to read an integer which tells you where you are in the list, and for sufficiently large integers you can fail to produce a value (past end of the list)
19:05:36 <mm_freak> benmachine: that there can be arbitrarily many values
19:05:39 <rwbarton> perhaps for "effect" one should read "sort of computation"
19:06:00 <benmachine> rwbarton: I don't know that that sits well with me either
19:06:03 <mm_freak> benmachine: "effect" is bound to extracting 'a' out of 'f a'
19:06:09 <rwbarton> *shrug* it makes me happy.
19:06:21 <benmachine> I'm not saying these analogies are all useless
19:06:29 <rwbarton> think of turing machines or whatever that live in some augmented environment
19:06:40 <benmachine> but I don't think they are an effective way of understanding applicatives-in-general
19:06:51 <mm_freak> no, but they give you terminology
19:06:56 <mm_freak> once you understood them
19:07:14 <mm_freak> i'm not assuming my peer to be a beginner
19:07:38 <benmachine> mm_freak: but the terminology is so vague as to be useless to me
19:07:45 <benmachine> because 'effect' can seemingly mean whatever you need it to
19:07:56 <mm_freak> <benmachine> I'm not saying these analogies are all useless ⇐ now you are =)
19:08:19 <jessopher> 'encode' or 'translate' seem like ok substitutions for 'return'
19:08:28 <benmachine> mm_freak: I think the effects analogy is useful with IO because you can come up with a sensible idea of what an effect is in that case
19:08:34 <mm_freak> as said, "effect" is bound to extracting values, because when you never extract, then the whole functor is useless, no matter what it is
19:08:58 <benmachine> mm_freak: nah, functors can be interesting solely for their structure
19:09:03 <benmachine> you might never extract the value itself
19:09:04 <mm_freak> actually for IO "effect" isn't very useful, since you never extract values from an IO computation
19:09:15 <rwbarton> the haskell runtime does
19:09:19 <benmachine> well, you do inasmuch as you give them names
19:09:24 <benmachine> and feed them to other IO computations
19:09:48 <mm_freak> whenever you have some sort of running function, you have the effects of that function
19:10:01 <mm_freak> correspondingly 'pure' will not trigger those effects
19:11:10 <benmachine> okay, fair enough
19:11:22 <benmachine> I still think sometimes the use of the term effects is counter-intuitive
19:11:31 <benmachine> used to refer to things peopel don't think of as effects typically
19:11:35 <benmachine> but I can see how it would be useful
19:11:53 <mm_freak> well, it's common terminology, and it's really just that:  terminology
19:12:03 <rwbarton> once you start thinking of values of type s -> (a, s) as having "effects", it is reasonable to extend that to [a] and so on
19:12:11 <mm_freak> i think "effect" makes good sense as long as you bind it to the running function
19:12:55 <mm_freak> "running" can be pattern matching, using a running function (maybe, either, runState, etc.) or even simply function application for (e ->)
19:14:09 <mm_freak> in this sense functors like IO or Unit don't have effects
19:14:38 <mm_freak> for IO at least not in the scope of haskell
19:18:43 <Patinho`Busy> !nn
19:19:41 <drull95> you know i should really sit down and think about how to help maintain packages
19:19:57 <drull95> ghc-pkg is always complaining about broken packages
19:20:05 <drull95> i fix them and something else breaks
19:34:54 <drull95> i'm trying to install the encoding library but i get "/.../Language/Cpp/encoding-0.6.6/./dist/setup/setup: 4: Syntax error: ";" unexpected"
19:35:07 <drull95> any hints on how to find out what's going on?
19:40:48 <DanBurton> sounds like...the library you're trying to install is messed up
19:41:56 <drull95> i gathered that much. i just dont want to put a huge amount of work into it right now.
19:41:57 <rwbarton> what kind of file is /.../Language/Cpp/encoding-0.6.6/./dist/setup/setup?
19:42:05 <drull95> binary
19:42:29 <drull95> i installed the iconv library so that should be good for now
19:43:19 <drull95> one of these days i will familiarize myself more with the internals of cabal so i can find the place where it's going wrong
19:43:37 <drull95> the error message isn't helpful in the least
19:44:18 <drull95> it's been on my todo list to write a package checker
19:44:32 <drull95> so maybe i will do that instead of my cpp parser
19:45:04 <drull95> gah, too many projects. i must become super-ultra-hyper efficient
19:45:28 <DanBurton> that's what christmas break is for, right? :)
20:00:38 <int80_h> \q
20:00:40 <int80_h> :q
20:09:42 <DukeDave> Okay, someone needs to pay..
20:09:48 <DukeDave> This:
20:09:48 <DukeDave> http://hackage.haskell.org/packages/archive/Command/latest/doc/html/System-Command.html#v:readProcess
20:10:08 <DanBurton> what about it?
20:10:16 <DukeDave> It takes    "[String]   any arguments"
20:10:30 <Axman6> ?
20:10:47 <DukeDave> So I dutifully passed in  ["--foo", "--cake", "--topping lemon]
20:10:54 <Axman6> that's exactly what you weant tough...
20:10:56 <DukeDave> Erm, add a " in there
20:11:20 <Clint> sounds like you need to pay
20:11:22 <DukeDave> Well apparently what makes it to the system call is "--foo --cake --topping"
20:11:33 <Axman6> o.O
20:11:37 <Axman6> how odd
20:11:46 <rwbarton> what makes you think that?
20:11:51 <DukeDave> Or: It only takes (head. words) of each element
20:11:59 <Clint> are you sure it's not just passing "--topping lemon" as the third word?
20:12:00 <geekosaur> it should have been ["--foo", "--cake", "--topping", "lemon"]
20:12:04 * DukeDave is trying to think of a test case
20:12:11 <copumpkin> call echo
20:12:14 <DukeDave> geekosaur: Yes! I realise this now :)
20:12:40 * Axman6 wonders if ["--foo","\"--topping lemon\""] would be necessary
20:12:45 <Axman6> i would hope not :\
20:12:56 <Clint> i can't imagine why you would ever want that
20:12:58 <rwbarton> maybe on some ridiculous windows-y system
20:13:03 <DukeDave> copumpkin: echo doesn't take any params with args?
20:13:21 <geekosaur> depending on what you are invoking, you may be triggering space parsing bugs in the invoked command (shell scripts with inadequate quoting are *very* common)
20:13:21 <copumpkin> if haskell is dropping your extra words, it'll lose them
20:13:31 <Axman6> DukeDave: you'd just use ["foo bar"] and see if that worked
20:13:43 <Axman6> s*
20:13:44 <rwbarton> probably his program is interpreting the "--topping lemon" option as "--topping"?
20:14:03 <copumpkin> DukeDave: are you sure the shittiness isn't on the side of the process you're calling?
20:14:15 <copumpkin> yeah
20:14:19 <rwbarton> anyways if you would have written "prog --foo --cake --topping lemon" at the command line then you want to pass ["--foo", "--cake", "--topping", "lemon"]
20:15:02 <Axman6> but what do you do if you would have written "foo bar \"baz thing\"", where the last would be passed as a single string
20:15:10 <rwbarton> ["foo", "bar", "baz thing"]
20:15:24 <rwbarton> er, without the "foo" if that's the name of your program
20:15:33 <Axman6> rwbarton: but how do you do that from haskell is at least my problem, maybe not DukeDave
20:15:36 <Axman6> 's
20:15:45 <rwbarton> what do you mean "how do you do that from haskell"
20:16:00 <rwbarton> readProcess "foo" ["bar", "baz thing"] whatever
20:16:10 <geekosaur> that would be a haskell list literal that does what you want
20:16:15 <rwbarton> this is what your shell does, when you type: foo bar "baz thing"
20:16:16 <Axman6> well, you seemingly couldn't use readProcess "foo" ["bar","bar thing"], which is what I would have assumed
20:16:21 <rwbarton> sure you can
20:16:41 <rwbarton> or, you better be able to anyways :)
20:16:44 <Axman6> well the problem is that it seems, according to DukeDave, that that doesn't work
20:16:44 <DukeDave> I'd love to answer all the questions, but I can't get ghci to load the Command package :|
20:16:53 <geekosaur> Axman6, that *should* work.  unless you are invoking a program with bugs in its variable processing, like in many shell scripts
20:18:04 <Axman6> DukeDave: writing a program and compiling it would probably be faster if you're fighting ghci
20:18:33 <DukeDave> Axman6: I just had that very thought
20:19:05 <DukeDave> Ha, okay, that time was me... Only had command in a cabal-dev sandbox :D
20:19:14 <DukeDave> Here we go..
20:19:57 <DukeDave> Bah
20:20:08 <DukeDave> readProcess "echo" ["here", "are my", "args"] []
20:20:08 <DukeDave> "here are my args\n"
20:20:30 <rwbarton> "echo" isn't very informative.
20:20:32 <Clint> really you want to pipe it to something that prints one arg per line
20:20:41 <Clint> but it's clearly not losing the my
20:20:55 <Sgeo> "Functional Pearl: Implicit Configurations
20:20:55 <Sgeo> "
20:21:04 <Sgeo> Is this thing commonly used in large Haskell projects?
20:21:14 <rwbarton> how about 'cat', you should be able to figure out its arguments from the errors it produces :)
20:21:27 <Axman6> ha
20:21:38 <Axman6> or even xargs echo
20:21:42 <Axman6> hmm, or not
20:21:46 <Clint> xargs -n1 echo
20:22:16 <hpaste> DukeDave pasted “readProcess weirdness” at http://hpaste.org/55331
20:22:29 <DukeDave> It looks like copumpkin might be close
20:22:43 <Axman6> Clint: but we're not passing these to stdin of xargs like would be needed
20:22:47 <Clint> right
20:22:50 <Clint> that's why i said pipe
20:22:55 <copumpkin> I'm always close
20:23:07 <Axman6> he;s behind you!
20:23:18 <rwbarton> DukeDave: just try wx-config "--libs all" at the command line and you will see you get the same wrong result
20:23:19 <Clint> "--libs all" is totally user error
20:24:16 <DukeDave> So, why?
20:24:38 <DukeDave> I mean, why take [String] and not just String
20:24:54 <rwbarton> so that you don't have to deal with quoting
20:25:04 <Clint> because you want to specify each element as it's passed to execv*
20:25:14 <rwbarton> int main(int argc, char *argv[]) <-- programs take a [String]
20:25:43 <DukeDave> Oh I see
20:26:01 <rwbarton> when you type in your shell: wx-config --libs all
20:26:19 <rwbarton> the shell does the work of splitting this into words and passing them individually to execve
20:26:31 <DukeDave> So it's more like:   $ wx-config '--libs' 'all'
20:26:38 <rwbarton> that is equivalent, yes
20:26:43 <DukeDave> Riiiight
20:29:33 <DukeDave> So I should probably say, thanks all :)
20:29:38 <DukeDave> #haskell++
21:01:04 <rien> hi folks
21:01:20 <dmwit> howdy!
21:01:28 <rien> I need to learn how to convert pointfree composition into pointful application
21:01:30 <rien> hi :)
21:01:50 <shachaf> rien: Insert lambdas.
21:01:55 <dmwit> ?unpl f . g
21:01:55 <lambdabot> (\ c -> f (g c))
21:02:06 <shachaf> There's @unpl but it's much more primitie than @pl.
21:02:11 <rien> what I'm looking for will achieve something like graph-reduction + shunting yard algorithm in a dream world would
21:02:12 <shachaf> Also its job is more difficult.
21:02:21 <rien> yes I specifically don't want what @unpl gives :)
21:02:32 <ddarius> shachaf: ?
21:02:44 <rien> dmwit: I also want to avoid lambdas
21:02:49 <shachaf> ddarius: To which part?
21:03:15 <rien> dmwit: but maybe that's unreasonable for this part of the transformation, and I should use something else to get flatten the lambdas, I don't know
21:03:44 <ddarius> shachaf: Are you saying @unpl is more difficult than @pl?  Also, how is unpl "more primitive"?
21:03:55 <rien> ddarius:
21:04:12 <Cale> http://blogs.msdn.com/b/oldnewthing/archive/2011/12/15/10247870.aspx <-- cute
21:04:12 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
21:04:15 <shachaf> ddarius: Well, @unpl is less well-defined than @pl, I think.
21:04:18 <rien> ddarius: sorry. I'd agree that unpl is more difficult. I do @pl in my head all day long
21:04:44 <shachaf> You can eta-expand anything, but it happens to know about a few combinators like (.) and inlines their definition in.
21:04:57 <ddarius> shachaf: All it does, or needs to do, is expand the definition of the "combinators".  And doing a bit of beta reduction for nicety.
21:05:04 <shachaf> pl can use monadic functions in (r ->), but unpl can't undo that.
21:05:21 <Cale> shachaf: mm... does it not?
21:05:38 <Cale> shachaf: I guess because it doesn't know the types of anything it can't.
21:05:43 <shachaf> @pl \f x -> f x x
21:05:44 <lambdabot> join
21:05:51 <Cale> @unpl join
21:05:51 <lambdabot> (\ b -> b >>= \ a -> a)
21:05:55 <Cale> ah, okay
21:05:56 <shachaf> ddarius: I'm taking "its job" to mean "reverse what @pl does into a reasonable expression".
21:06:04 <Cale> Yeah, that's just a type thing
21:06:08 <shachaf> Cale: There's not much hope of @unpling join. @pl loses information. :-)
21:06:21 <shachaf> Of course, I guess nobody expects "reasonable expressions" of @pl.
21:06:26 <Cale> shachaf: there is if we can know that it's the function monad
21:06:51 * rien *ahem*
21:06:59 <shachaf> Cale: Right (though I doubt unpl knows about types at all?), but there's no type information in "join".
21:07:06 <Cale> yeah
21:07:07 <DanBurton> > (\b -> b >>= \a -> a) [[2,3],[4,5]]
21:07:08 <lambdabot>   [2,3,4,5]
21:07:20 <byorgey> rien: I don't understand what you want to do.  Can you give an example?
21:07:24 <luite> hmm the whistler supermarket is rather expensive
21:07:28 <luite> hmm wrong chan
21:07:43 <ddarius> shachaf: @pl doesn't know about types at all.
21:08:05 <rien> so about graph reduction, the wikipedia page has a pointful example which I could have figured out by myself. what I'd like to learn is how to draw graphs of function composition, pointfree
21:08:08 <rien> byorgey: ^
21:08:15 <shachaf> ddarius: That's why I assumed that @unpl doesn't.
21:09:05 <shachaf> pl's essential goal is pretty well-defined -- get rid of lambdas, and then apply a few optimizations. pl would be satisfactory even if it only knew about S and K and didn't optimize at all.
21:09:18 <shachaf> Whereas a dozen people would probably write unpl a dozen different ways.
21:10:25 <byorgey> rien: I looked at the wikipedia page about graph reduction, and I don't understand what it has to do with pointed vs pointfree.
21:10:31 <byorgey> rien: can you elaborate?
21:10:38 <ddarius> I could write @pl a dozen different ways.  And there is also a clear "well-defined" trivial case.  Expand S and K (or whatever "combinators" pl uses or whatever we want) into lambda terms.  You're done.  You can then "optimize" for presentation by beta reduction.
21:11:47 <shachaf> Maybe what I mean is just that @pl often generates the expression I want, or one pretty close to it. @unpl almost never does, because it does weird unnecessary expansions like id.
21:12:27 <rien> @pl foo x y = 1 + (+) x y
21:12:27 <lambdabot> foo = ((1 +) .) . (+)
21:12:28 <ddarius> shachaf: That's because id is one of the "combinators" it expands.
21:12:32 <rien> how do I execute that?
21:12:40 <rien> > ((1 +) .) . (+) 3 5
21:12:41 <lambdabot>   No instance for (GHC.Num.Num (f (f1 t)))
21:12:41 <lambdabot>    arising from a use of `e_1135' ...
21:12:50 <rwbarton> > (((1 +) .) . (+)) 3 5
21:12:52 <lambdabot>   9
21:12:57 <DanBurton> @pl foo x y = succ (x + y)
21:12:57 <ddarius> shachaf: All expansions are unnecessary.
21:12:57 <lambdabot> foo = (succ .) . (+)
21:13:13 <rien> ah that's it. now how do I draw the graph for that, keeping it pointfree
21:13:18 <byorgey> rien: the same way you evaluate any expression.
21:13:23 <rien> i.e. I don't want the graph for 1 + x + y
21:13:30 <DanBurton> (1+) is the same as succ, fwiw
21:13:35 <shachaf> The goal of making a "nice" expansion is difficult.
21:13:35 <byorgey> rien: the top node is for (.), and so on
21:13:39 <shachaf> DanBurton: Not necessarily.
21:13:49 <DanBurton> shachaf: "mostly" the same, then
21:13:59 <shachaf> It's a different function.
21:14:02 <rien> succ is only for naturals :)
21:14:05 <shachaf> > succ 'a'
21:14:06 <lambdabot>   'b'
21:14:08 <ddarius> shachaf: If the goal is to have "nice" output, the problem is (clearly) poorly defined either way.
21:14:11 <DanBurton> > succ 1.1
21:14:12 <lambdabot>   2.1
21:14:28 <shachaf> ddarius: That is true.
21:14:29 <rien> well, I mean in the papers, for doing uhm... the church numerals or whatever :P
21:14:46 <shachaf> pl happens to be pretty successful at this poorly-defined problem, though, for the most part.
21:14:55 <ddarius> shachaf: No it isn't.
21:14:56 <shachaf> unpl rarely is.
21:15:10 <rien> byorgey: yes but what are the bottom nodes connected to? in other words, how do I spread the points to where they're needed?
21:15:14 <ddarius> Neither of them are implemented with the goal of producing "nice" output.
21:15:18 <byorgey> rien: For dealing with higher-order functions you need explicit application nodes.
21:15:33 <shachaf> I didn't say that was its goal, just that it's successful at it.
21:15:40 <byorgey> rien: so for (((1 +) .) . (+)) 3 5  the top two nodes will actually be function application
21:15:45 <rien> byorgey: that's fine, that's my end goal
21:15:59 <ddarius> shachaf: I said, pl also rarely achieves that goal.  Sometimes it does, usually it doesn't.
21:16:05 <shachaf> What do all the optimizations that @pl does optimize for, if not "niceness"?
21:16:12 <rien> byorgey: no let's not start from the top, that doesn't help me :P
21:16:20 <byorgey> (App (App (...) 3) 5)
21:16:21 <shachaf> At any rate, I suppose you're right.
21:16:21 <rien> how do I draw the (+) node?
21:16:35 <ddarius> shachaf: It's just a random grab-bag.  God knows what the motivation was.
21:17:19 <rien> I can't just draw a + connecting 3 and 5 because 3 and 5 might get used later
21:17:26 <byorgey> rien: just as a + node by itself.
21:17:37 <byorgey> rien: note, the picture on that graph reduction page is a bad example
21:17:56 <rien> that's where I'm missing something. if it's just + by itself then how do I spread the inputs?
21:17:56 <byorgey> rien: because it is for an algebra of first-order arithmetic expressions or something
21:18:24 <ddarius> shachaf: I would say @unpl's "mandate" is just not something you normally want to do regardless and the fact that you rarely want its output has little to do with how well it does what it does.
21:18:32 <byorgey> rien: if you end up with  App (App (+) 3) 5   that's when you get to evaluate the addition
21:19:00 <shachaf> ddarius: Fair enough.
21:19:05 <byorgey> rien: you will never have 3 and 5 as children of a (+) node
21:20:13 <byorgey> because addition is not a defined part of Haskell expressions.  There is only function application.
21:20:52 <rien> byorgey: I don't want to end up with that. I guess what I want is to go from RPN 1 + + (w/ inputs x y) to y + 1 + x
21:21:01 <rien> is that some unsolved problem I'm not aware of?
21:21:39 <byorgey> I doubt it
21:21:45 <byorgey> but I don't really understand what you want.
21:22:12 <rien> 1 + + -> y + 1 + x
21:22:17 <rien> that's what I want
21:22:24 <rien> rpn to applicative
21:22:29 <rien> with no lambdas
21:23:06 <rien> 1 + + to (+ (+ y 1) x) would be even better
21:23:37 <rien> I just want to be pointed in the right direction, I don't need an answer
21:23:58 <mzero> rein - just build the nodes as you go, but if you have to "pull" something off an empty RPN stack, synthesize an input variable
21:24:09 <rien> if I have to generate lambdas that's fine, as long as there's a way to eliminate them at a later step, so that my final form is one of the above
21:24:14 <mzero> that is simulate the stack execution of the RPN machine
21:24:26 <shachaf> rien: Your problem has nothing to do with lambdas.
21:24:36 <mzero> okay, now I'm back with byorgey - and I don't know what you want
21:24:41 <rien> mzero: can you expand on that? 1 + + already runs on a stack machine
21:24:55 <mzero> no, it crashes a stack machine!
21:24:59 <mzero> stack underflow!
21:25:07 <mzero> hmmmm, good name for a site.... :-)
21:25:07 <rien> mzero: no sir, that's a function definition
21:25:10 <byorgey> rien: first you were talking about pointless vs. pointful.  Then you were talking about graph reduction.  Now you bring RPN into it.  I still have no idea what you are trying to accomplish.
21:25:16 <rien> : foo ( x y -- z ) 1 + + ;
21:25:44 <mzero> okay - is some RPN-ish syntax which we haven't spec'd
21:26:22 <mzero> s/is/in
21:26:29 <rien> byorgey: the 1 + + above, which assumes x y as inputs, and by itself is pointfree - I need to convert that into (+ (+ y 1) x) or something like that
21:26:36 <ddarius> > let plus (x:y:xs) = (x+y):xs; push = (:); rpn = flip (foldr (.) id) []; in rpn [plus, push 1, push 1] [x,y]
21:26:36 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr] -> t'
21:26:37 <lambdabot>         against in...
21:26:39 <azaq23> > let f = (+) . (+ 1) in f x y
21:26:40 <lambdabot>   x + 1 + y
21:27:13 <mzero> rein -- it isn't point free in any definition of point free that I know
21:27:35 <shachaf> mzero: 1 + + seems point-free to me.
21:27:45 <shachaf> Like most expressions in RPN languages.
21:27:47 <byorgey> rien: in that case I agree with mzero.  Simulate the RPN program with a stack, and output a node every time you hit an operator.  If the stack has insufficient data, make up a new variable name.
21:27:51 <rien> azaq23: wow, that's like magic to me. how did you make it return code? :P
21:28:03 <ddarius> > let plus (x:y:xs) = (x+y):xs; push = (:); rpn = foldr (>>>) id; in rpn [push 1, plus, plus] [x,y]
21:28:03 <lambdabot>   [1 + x + y]
21:28:16 <rien> mzero: it's pointfree alright.
21:28:19 <mzero> shachaf: I'm not familiar with a definition of point free for RPN languages
21:28:28 <byorgey> look, ddarius even implemented it =P
21:28:29 <rien> you are now :)
21:28:38 <rien> ddarius: trying to decipher it now
21:28:46 * mzero looks around for a definition
21:28:57 <rien> ddarius: okay you're simulating a stack, and...
21:28:59 * mzero wonders if his and byorgey's operational one is it
21:29:06 <azaq23> rien: x, y are constants of type Expr in lambdabot from the package simple-expr, this is a type which is specifically build for this
21:29:12 <rien> I need to learn that magical (>>>)
21:29:26 <russellw> I think the natural definition of point-free in forth would be not using named local variables
21:29:28 <mzero> (>>>) = flip (.)
21:29:39 <russellw> Which are a feature of forth, but purists say you should minimize their use
21:29:40 <mzero> not so magical, actually
21:29:40 <rien> azaq23: ah!
21:30:03 <byorgey> rien: in the future, you should ask for help with your actual top-level goal, rather than asking about things which you think have something to do with it.  it saves everyone time. =)
21:30:17 <rien> sorry, I thought I'd just alienate everyone
21:30:44 <byorgey> rien: unlikely in #haskell =)
21:31:02 <rien> @unpl rpn = foldr (>>>) id
21:31:02 <lambdabot> rpn = foldr (>>>) (\ a -> a)
21:31:17 <rien> lol
21:31:21 <byorgey> > foldr (>>>) id [x,y,z]
21:31:22 <lambdabot>   Couldn't match expected type `c -> c'
21:31:22 <lambdabot>         against inferred type `Simple...
21:31:35 <rien> I'm trying to visualize that pointful, ironically :)
21:31:45 <byorgey> = x >>> (y >>> (z >>> id))
21:31:50 <rwbarton> > foldr (>>>) id [f,g,h]
21:31:51 <lambdabot>   Overlapping instances for GHC.Show.Show (c -> c)
21:31:51 <lambdabot>    arising from a use of `...
21:31:54 <rwbarton> > foldr (>>>) id [f,g,h] x
21:31:55 <lambdabot>   h (g (f x))
21:32:29 <rien> I can't stop smiling
21:33:44 <mzero> of course, (.) *IS* pretty magical (or at least the one from Control.Category, which lambdabot is using)
21:33:56 <ddarius> mzero: No it isn't.
21:34:02 <ddarius> (what lambdabot is using)
21:34:12 <mzero> Oh, it isn't?
21:34:14 <shachaf> mzero: I meant by the usual definition.
21:34:14 <ddarius> Well it's what (>>>) is indirectly using.
21:34:17 <mzero> @src (.)
21:34:17 <lambdabot> (f . g) x = f (g x)
21:34:17 <lambdabot> NB: In lambdabot,  (.) = fmap
21:34:36 <ddarius> In this particular case though, the Prelude (.) is all that's being used.
21:34:45 <shachaf> mzero: There are no named variables.
21:34:52 <rien> oh hold on a sec then. is (>>>) = flip (.) or flip fmap?
21:35:09 <mzero> ddarius: right - and there was a question about (>>>) earlier, and I quipped that it was just flip (.)   -- failing to point out which (.) it was the flip of....
21:35:11 <ddarius> rien: The former is a special case of the latter.
21:35:14 <shachaf> A Factor person I know always tells me how point-free style is much more natural in Factor than in Haskell.
21:35:20 <mzero> (perhaps I said it flippantly.... :-P   )
21:35:34 <ddarius> rien: At any rate, its being used as (.).
21:35:36 <rien> ddarius: yes I remember that, but which one is needed for doing this business that your rpn function did?
21:35:40 <rien> ah gotcha
21:35:45 <rien> ddarius: thanks a lot for that by the way
21:35:49 <russellw> shachaf, personally I would say the other way around
21:35:51 <rien> I will now write it in rpn
21:36:08 <rien> shachaf: yeah I'm doing Factor, plenty more natural
21:36:17 <shachaf> russellw: ?
21:37:16 <russellw> I've tried writing point free in RPN languages, and honestly I've been more productive writing hand assembled hexadecimal machine code - it makes even trivial things into hard puzzles
21:37:42 <russellw> Whereas in Haskell I find even with little experience in the language, I can write a fair amount of stuff quite elegantly point free
21:37:56 <rien> russellw: he wasn't talking about any rpn language :) in Factor I never have that problem
21:38:00 <mzero> I once wrote 1000s of lines of Forth, in a forth w/o function variables....it was and exercise I don't care to repeat
21:38:00 <russellw> And the stuff that doesn't naturally work point free, is obvious about not doing so
21:38:03 <ddarius> russellw: You are confused.  Or rather, you are applying different standards.
21:39:06 <ddarius> "In RPN language I found it hard to write everything point-free.  In Haskell it's easy because I only bother when it's easy."
21:39:33 <ddarius> "∴ Haskell is more natural for point-free code"
21:40:08 <russellw> ddarius, well I think having it be clear when you should or should not try to do a thing in a certain way, is a relevant criterion. If you disagree, then you might assess them as being more on a par
21:41:11 <rien> for the record, in Factor we also only do it when it's easy.
21:41:12 <ddarius> russellw: It's not clear in Haskell, but we don't bother.  Pointful style is usually what you want.  Concatenative languages just have a "wrong default."
21:41:48 <rien> not "just"
21:42:11 <ddarius> russellw: And yes, you could start with "lambdas" in (most) concatenative languages and only eliminate them later, though that would go against the spirit of most concatenative languages.
21:42:39 <liyang> @hoogle b -> (a -> [a] -> b) -> [a] -> b
21:42:39 <lambdabot> No results found
21:43:49 <liyang> There's maybe and either, why not list? :<
21:44:03 <russellw> rien, in that case I could certainly see factor being easier to use in practice than forth
21:44:11 <rien> russellw: [| a b c | b neg b sq 4 a * c * - sqrt + 2 a * / ]
21:44:22 <russellw> ah! yes
21:44:37 <russellw> Nice and readable
21:44:51 <rien> [| is a lexer function
21:45:28 <rien> that code right now is rewritten to use 2 stacks (turing completeness and all that), but I want to rewrite it to use the first more than the second
21:45:44 <rien> that's why I need ddarius's rpn function :)
21:46:21 <mzero> liyang: I've wanted  that   list    and   bool    often!
21:46:59 <shachaf> liyang: There's foldr.
21:47:07 <Axman6> :t lift
21:47:08 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
21:47:09 <shachaf> foldr is pretty much list.
21:47:19 <mzero> and if you squint, perhaps one could make   pair   a synonym for uncurry
21:47:35 <Axman6> :t lift (undefined :: IO (Either String Int))
21:47:36 <lambdabot> forall (t :: (* -> *) -> * -> *). (MonadTrans t) => t IO (Either String Int)
21:47:51 <Axman6> :t lift (undefined :: IO (Either String Int)) :: ErrorT String IO Int
21:47:51 <lambdabot>     Couldn't match expected type `Int'
21:47:52 <lambdabot>            against inferred type `Either String Int'
21:47:52 <lambdabot>       Expected type: IO Int
21:47:59 <Axman6> hmm
21:48:07 <ddarius> russellw: You can do the same thing in (most) Forths.
21:50:27 <Axman6> @unmtl ErrorT e m a
21:50:27 <lambdabot> m (Either e a)
21:52:37 <Axman6> :t either
21:52:38 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
21:52:54 <rien> ddarius: you can use locals like that in most Forths? really? (I don't know much forth)
21:53:44 <ddarius> rien: The ANSI standard for Forth defines such syntax.  Implementing it is optional for compliance, but most implementations on a general purpose CPU will implement it.
21:53:59 <rien> ah...
21:54:00 <ddarius> The standard may even provide an implementation in terms of other things.
21:54:16 <rien> good to know. thanks
21:54:24 <mzero> wasn't part of Forth back in early 1980s...  when I was coding Forth, but yes, it's there now
21:54:30 <rien> hahah
21:54:53 <mzero> on 6502s! with 64k bytes RAM! WOOOT!
21:55:03 <ddarius> mzero: If you had parsing words, you could implement it and it was probably already implemented in some Forths at that time.
21:55:07 <rien> how do I achieve this with lambdabot? : let myfunc = ... in @type flip myfunc
21:56:02 <Axman6> urgh, this library was not written for maintainability >_<
21:56:05 <shachaf> rien: The same way you achieve it in ghci.
21:56:15 <mzero> @type let myfunc a b = length a + b in flip myfunc
21:56:16 <lambdabot> forall a. Int -> [a] -> Int
21:56:26 <rien> shachaf: in ghci I can let something and it stays defined
21:56:36 <rien> mzero: ah :)
21:56:39 <shachaf> rien: Right, but that's not using let in.
21:57:16 <rien> shachaf: I tried letting something without in and it said it wasn't an expression
21:57:36 <shachaf> ＠type gives you the type of an expression; let ... in ... is an expression.
21:58:30 <rien> yes, but that's not what I'd do in ghci ;)
21:58:42 <Axman6> :t maybe
21:58:43 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
22:00:10 <rien> @type foldr
22:00:11 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:00:23 <rien> oops, sorry
22:15:44 <DanBurton> lambdabot is the new ghci
22:16:17 <DanBurton> @faq will lambdabot take over the world with her haskellish charm?
22:16:17 <lambdabot> The answer is: Yes! Haskell can do that.
22:35:32 <Axman6> @hoogle Either a b -> (b -> m (Either a c)) -> m (Either a c)
22:35:32 <lambdabot> No results found
22:35:51 <Axman6> :r either (return.Left)
22:35:57 <Axman6> :t either (return.Left)
22:35:58 <lambdabot> forall (m :: * -> *) a b b1. (Monad m) => (b1 -> m (Either a b)) -> Either a b1 -> m (Either a b)
22:38:27 <mbetter> is there a simple way to putStr a unicode char?
22:38:42 <ddarius> @hoogle putChar
22:38:42 <lambdabot> Prelude putChar :: Char -> IO ()
22:38:42 <lambdabot> System.IO putChar :: Char -> IO ()
22:38:42 <lambdabot> System.IO hPutChar :: Handle -> Char -> IO ()
22:38:55 <ddarius> Or, you know, putStr [c]
22:39:31 <mbetter> seems to break on unicode characters
22:39:58 <ddarius> Set your locale appropriately.
22:41:52 <mbetter> ok, thanks
22:58:23 <mbetter> did something major change between bash 3.x.x -> 4.x.x?
22:58:26 <mbetter> grr
23:22:47 <Sizur> Hello, #haskell!
23:23:06 <ski> hello
23:24:23 <Sizur> I missed #haskell
23:24:28 <Sizur> you guys are the best
23:25:16 * ski . o O ( .. best at what ? )
23:25:45 * Sizur wonders why Haskell has not taken over the world yet...
23:26:17 <Sizur> ski: best at this community thing stuff
23:26:58 <Sizur> I think that's what ppl call this thing outside of my cubicle
23:28:07 <Sizur> there are a number of experts here who tirelessly repeat nice answers personally to noobs
23:28:41 <Sizur> atleast that's how it was a year ago, and I cannot imagine that such nice ppl whould change
23:28:54 <Sizur> negatively
23:29:48 <ski> ok
23:33:38 <rien> ddarius: what's a version of that rpn function that runs without lambdabot's magical x and y ?
23:36:44 <rien> I think what those x and y do is defer computation
23:38:04 <rien> ah, I see now. replacing [x,y] with [2,3] gives 6 :(
23:39:11 <rien> dang, wasted all this time rewriting it, should've realized sooner that this did not do what I need
23:41:42 * ski wonders what rien needs
23:46:11 <rien> ski: it's too late for me now, I'll be back tomorrow asking for the same help :)
23:48:35 <russellw> I agree with Sizur, I haven't been here long but I have been very favorably impressed with the community here so far
23:50:21 <rien> I used to hang around here a few years ago, it was just the same, the best community with the most helpful and knowledgeable people.
23:50:38 <rien> if the language weren't so hard I would've stayed :P
23:50:47 <russellw> :)
23:51:06 <rien> I now only come here when I need pointers for hairy problems, heh
23:52:41 <trez> shave it off!
23:53:19 <rien> my trimmers aren't as powerful as Haskeller® trimmers
23:53:47 <rien> (i.e. I haven't read as many books, or don't have as many titles :P)
23:57:02 <ddarius> We have to read -and- write books?
23:57:31 <rien> dude!
23:57:58 <rien> I was looking for a better answer, one that doesn't rely on tricks :P
23:59:31 <rien> I actually don't want code
23:59:54 <rien> it's more work for me. I'd rather you give me a name of some subject I have to read
