00:00:50 <ville> tomHaskell: depends on what your client decides to show on the right. quite common is to show all the names on a specific channel.
00:01:34 <Jafet> Perhaps we should evict some of those people, so that this channel doesn't appear so high on the list.
00:01:56 <shachaf> Jafet: We tried that some hours today.
00:02:02 <shachaf> They all reconnected straight away.
00:02:22 <Jafet> Darn. Well, it's nice that freenode at least provides that feature.
00:02:48 <kmc> tomHaskell, they are all online, in the sense that they're connected to the server and have joined the channel
00:02:48 <lambdabot> kmc: You have 1 new message. '/msg lambdabot @messages' to read it.
00:02:54 <kmc> but many of them have not said anything in a long time
00:04:07 <tomHaskell> So when you say this specific channel is one among many Haskell channels or the Haskell channel among many others?
00:04:19 <Jafet> preflex, xseen __main__
00:04:19 <preflex>  Sorry, I haven't seen __main__
00:04:51 <shachaf> tomHaskell: Well, it's both.
00:05:00 <shachaf> tomHaskell: This is by far the biggest Haskell channel, though.
00:05:16 <shachaf> There are some channels on Freenode that are bigger (though, apparently, not all that many).
00:06:18 <tomHaskell> Since I connected to this channel through Try Haskell from the Haskell wiki, if I ever wanted to come back... where am I?
00:06:38 <shachaf> tomHaskell: #haskell on Freenode.
00:06:52 <shachaf> tomHaskell: You can get any IRC client and connect to irc.freenode.net and join #haskell
00:10:21 <kmc> tomHaskell, anyone can run a network using the IRC protocol.  Freenode is one of the popular ones, and hosts channels for a lot of programming languages and open-source projects
00:10:41 <kmc> you're in the #haskell channel on freenode
00:10:48 <kmc> which is by far the most active haskell-related channel
00:10:57 <kmc> and also one of the biggest channels on freenode
00:11:20 <opqdonut> I can't see anything about chat on tryhaskell.org
00:11:33 <tomHaskell> It looks like there are about 1300 people logged in now. Since I not familiar with the popularity of IRC that number is larger than I would have guessed.
00:11:40 <shachaf> opqdonut: Type in "chat".
00:11:52 <opqdonut> oh, right.
00:11:56 <shachaf> tomHaskell: Looks like 792 people to me.
00:11:59 <kmc> there are 792 people in this channel
00:12:12 <tomHaskell> It's an option when you run try Haskell in the your browser.
00:12:16 <kmc> there are a lot more logged onto freenode total
00:12:48 <kmc> 63311 logged onto freenode
00:13:05 <shachaf> That's all?
00:13:11 <kmc> that's what /lusers says
00:13:28 <kmc> remember this is one of the biggest channels :)
00:13:41 * kmc wonders where tomHaskell got the 1300 number from
00:14:10 <ddarius> Maybe he's also in #ubuntu
00:14:43 <shachaf> Apparently there are more channels than half the number of users.
00:14:52 <tomHaskell> Is there a statistic that that tell one how many people are logged on. Cause I did a very rough count of all the j's and m's then guess an average number in each letter and multiplied by 26. I am guess that way too complicated, and apparently really off
00:15:26 * shachaf enjoys tomHaskell's estimation method.
00:15:35 <ion> Indeed
00:15:38 <kmc> some IRC clients will tell you how many people are in the channel
00:15:51 <kmc> i recommend connecting with a client like XChat instead of the web thing
00:21:17 <kmc> tomHaskell, any interest in the number of users besides general curiosity?
00:21:47 <tomHaskell> I am just surprised by how many Haskell programmers there are
00:22:17 <shachaf> There may be more people in this channel than there are Haskell programmers. :-)
00:22:50 <kmc> yes, i would not take the number of users in #haskell to be indicative of the number of Haskell programmers
00:22:52 <kmc> in either direction
00:23:02 <kmc> in fact the more time I spend in #haskell the less time I spend Haskell-programming
00:24:05 <tomHaskell> Why would they be here then if they didn't have at least interest in Haskell?
00:24:25 <kmc> maybe they enjoy the regular bouts of PHP-bashing
00:24:33 <gseitz> having interest in haskell /== being a haskell programmer
00:24:50 <kmc> i'm not sure what "a haskell programmer" means, anyway
00:25:14 <gseitz> of course that was meant to be "/=" ;)
00:25:14 <ddarius> shachaf: There are far more Haskell programmers than people in this channel.
00:25:17 <tomHaskell> I don't either. I just meant somebody with some devotion to the language
00:25:30 <ddarius> gseitz: Don't you mean !==?
00:25:54 <kmc> tomHaskell, #haskell is a good place to lurk and learn some interesting things now and then
00:26:01 <kmc> even if you're not making a big effort to learn Haskell
00:26:07 <kmc> (or, it was a good place to do so)
00:26:21 <salisbury> still is
00:27:00 <salisbury> except at ~2AM eastern, when it be comes a good time to learn of IRC client timeout patterns
00:32:12 <mbuf> is there a way to parse a .cabal file and read its values without using Haskell?
00:32:45 <kmc> you mean, a library which does this, which isn't a Haskell library?
00:32:58 <mbuf> kmc: yes; perhaps from Python, for example
00:33:07 <kmc> i don't know of a python library to parse cabal files
00:33:17 <mbuf> kmc: any other language is also fine
00:33:26 <kmc> that's an odd requirement
00:33:35 <kmc> how about a brainfuck library to parse cabal files
00:33:52 <mbuf> kmc: does it exist?
00:33:55 <kmc> how about synthesizable VHDL
00:33:59 <kmc> no
00:34:00 <lcf> it fits the requirement of "any language"
00:34:15 <kmc> What Are You Actually Trying To Do ™?
00:34:30 <mbuf> kmc: read and parse .cabal file requirements and dump the data to .json format
00:34:42 <shachaf> mbuf: And why don't you want to use Haskell for it?
00:34:47 <erus`> whynothaskell.jpg?
00:35:03 <mbuf> shachaf: will try
00:35:30 <kmc> this would make sense if you don't know Haskell, and do know every other language on the planet
00:35:49 <ddarius> kmc: Except that it wouldn't make sense to be interested in .cabal files.
00:35:55 <Enigmagic> mbuf: https://gist.github.com/1466063
00:36:04 <shachaf> ddarius: You might be packaging Haskell packages for others.
00:36:16 <Enigmagic> mbuf: that parses a .cabal file and dumps it out as json
00:36:22 <kmc> nice
00:36:25 <mbuf> Enigmagic: thanks
00:36:48 <ddarius> shachaf: I'd rather not use a Haskell package packaged by someone who knows nothing about Haskell.
00:36:49 <Enigmagic> mbuf: it requires the aeson package
00:37:57 <mbuf> Enigmagic: okay
00:38:32 <mbuf> Enigmagic: kmc thanks for your help
00:39:01 <Enigmagic> np
00:39:19 <ddarius> Great job helping, kmc.
00:39:23 <kmc> :D
00:39:31 <tomHaskell_> What did I miss?
00:39:35 <kmc> not much
00:39:38 <shachaf> tomHaskell_: Great excitement.
00:39:47 <kmc> tomHaskell_, http://tunes.org/~nef/logs/haskell/
00:40:27 <tomHaskell_> I can't believe many people still use IRC. This is like a revelation.
00:41:12 <opqdonut> it's the only technology that has topic-oriented big chat rooms
00:41:22 <opqdonut> (okay, stackexchange's chat has that too)
00:41:30 <opqdonut> everything else tends to be person-to-person
00:41:48 <opqdonut> or too much message-based, like twitter
00:43:11 <kmc> it's not that many
00:43:31 <tomHaskell_> There seems to be over a hundred services like freenode listed in my Xchat connect. I don't know if they are have as many users as Freenode, but that still quite a large number of people.
00:43:35 <ddarius>  @opqdonut IRC, lulz, #luddite
00:44:12 <opqdonut> har har
00:44:55 <kmc> i think IRC is pretty good for what we use it for here
00:44:55 <opqdonut> I'm actually serious. there is nothing like IRC available. SE's chat is kinda, but it's centralized
00:45:18 * ddarius is happy he found his lighter.
00:45:20 <kmc> i've seen XMPP and Zephyr used roughly the same way IRC is
00:45:23 <kmc> but it just doesn't matter
00:45:28 <kmc> IRC is the simplest of those
00:45:42 <opqdonut> XMPP clients tend to have pretty bad support for rooms
00:45:54 <opqdonut> and XMPP servers are a PITA to set up
00:46:07 <opqdonut> (we tried using it at work, but ended up with an ircd)
00:46:32 <shachaf> Some IRC-like protocol should have better support for things bigger than one line.
00:46:33 <kmc> i'm sometimes frustrated by how the Haskell community is fragmented between venues (IRC, mailing lists, stack overflow, reddit, international conference on functional programming)
00:46:38 <kmc> but they all have their place
00:46:44 <shachaf> Gobby-style editing would be nice, if it could be integrated somehow.
00:46:49 <opqdonut> shachaf: (and encodings)
00:46:52 <shachaf> kmc: That's true of most communities.
00:47:05 <kmc> you have to give up on following everything, and trust that interesting things will get spread around
00:47:18 <kmc> i pay attention to reddit and sometimes IRC, hardly ever SO or mailing lists
00:47:19 <shachaf> preflex: rot13 IRC supports encodings!
00:47:19 <preflex>  VEP fhccbegf rapbqvatf!
00:47:35 <tomHaskell_> any body use Haskell in computational Biology?
00:47:36 <shachaf> I used to read -cafe and one day just stopped, more or less.
00:48:08 <danr> preflex: rot13  VEP fhccbegf rapbqvatf!
00:48:08 <preflex>  IRC supports encodings!
00:48:25 <danr> what's in a preflex?
00:48:40 <opqdonut> shachaf: I meant encodings as in charsets. but sure, cryptography would be nice too.
00:49:16 <kmc> IRC supports encodings, sort of
00:49:25 <kmc> IRC is 8-bit clean, but you have to decide out-of-band what the encoding is
00:49:42 <kmc> if you're running a corporate internal IRC server, this isn't an issue
00:50:00 <opqdonut> exactly
00:50:22 <salisbury> shachaf: what's cafe?
00:50:27 <kmc> (also i guess it's not 8-bit clean for nicks)
00:50:30 <opqdonut> salisbury: the haskell-cafe mailing list
00:50:43 <kmc> presumably in some places, non-ASCII nicks and channel names would be improtant
00:50:46 <opqdonut> kmc: well, it might be, but NickChars tends to be pretty tight on actual servers
00:50:58 <opqdonut> non-ASCII channel names work on e.g. IRCNet
00:51:00 <kmc> we should use punycode nicks
00:51:03 <kmc> huh
00:51:23 <opqdonut> but you have to be careful about how the ä in your channel name is encoded, for example
00:51:23 <salisbury> I think an increased amount of library documentation would help haskell greatly
00:51:43 <opqdonut> oh? I think the haddocks on hackage tend to be quite nice
00:51:49 <opqdonut> especially combined with the Source links
00:51:53 <kmc> some are, many aren't
00:52:18 <opqdonut> the docs for the big and proper libraries tend to be good
00:52:25 <kmc> disagree
00:52:25 <kmc> a
00:52:31 <salisbury> kmc's thoughts are pretty much my own
00:52:33 <opqdonut> then there's all sorts of one version one module libs that don't have anything
00:52:34 <kmc> a lot of the docs in 'base' are quite bad, even
00:52:37 <AfC> When it is there, it tends to be "reference style" documentation which is fine if you know what you're doing (and Haskell!) but really opaque otherwise
00:52:43 <kmc> documenting what each function does is only one layer
00:52:52 <kmc> a lot of libraries have that but are missing the higher level "how to put it all together"
00:52:59 <kmc> here are 70 modules with per-function docs for each
00:53:00 <opqdonut> right
00:53:01 <opqdonut> agreed
00:53:02 <kmc> where the hell do you start
00:53:08 <kmc> i think examples are a good way to deal with this
00:53:13 <opqdonut> e.g. quickcheck's higher-level docs are good
00:53:29 <opqdonut> but you're right, nobody else does that
00:53:29 <AfC> the alternative being a more tutorial style, where any given documentation fragment tries to answer the question of what you'd use this for and how to call it
00:53:32 <salisbury> examples with type-signatures
00:53:52 <AfC> which is a lot of work, but a big pay off for users.
00:54:04 <kmc> i wouldn't get rid of the API docs
00:55:16 <AfC> kmc: of course not, but it can still be a lot friendlier / usable. Most packages, you scroll into the docs and you get a lot of "getHeader: get the headers" which is useless
00:55:27 <kmc> yeah
00:55:50 <kmc> i still don't think it's an alternative though
00:55:53 <kmc> but an additional thing
00:56:02 <AfC> Sure
00:56:18 <salisbury> it doesn't have to be centralized either
00:56:30 <kmc> what i do is usually pretty low-tech
00:56:39 <kmc> just some examples in a directory in the tarball
00:56:55 <salisbury> much 'documentation' for ruby is found in user blogs
00:57:00 <salisbury> for example
00:57:06 <kmc> unfortunately that's not directly linked from hackage, but you can get to it from github or whatever
00:57:20 <kmc> also i try to write a short blog post about libraries after i release them
00:57:23 <kmc> with one or two examples
00:57:28 <kmc> but i also don't have a great way of linking it all together
00:58:06 <AfC> kmc: yeah, you see, if I were to have a say (which I don't, it's your code) I'd encourage you to put the examples [especially including snippets showing how to use individual functions]  *in* the code doc.
00:58:23 <salisbury> sounds like a haskell article directory  would be a good idea
00:59:00 <kmc> AfC, sometimes i do, but i think it would be worse in a lot of cases
00:59:06 <kmc> i mean most examples aren't an example of A or B or C
00:59:11 <kmc> they're an example of how to use A,B,C together
00:59:13 <kmc> that's the whole point
00:59:27 <AfC> kmc: [sorry, not to pontificate; I maintain a Java library where code completion space and thereby context sensitive popups of documentation fragments in an IDE are phenomenally helpful]
00:59:33 <kmc> i like suggestions
00:59:44 <kmc> i don't like endless apologies for giving suggestions
00:59:49 <kmc> so suggest or don't
00:59:50 <AfC> heh
01:00:06 <warpzero> how the heck do i get ghci to output it's bytecode for something
01:00:07 <AfC> yeah but I said the J word here, so one has to abase oneself :)
01:00:10 <kmc> that's a good point about IDEs
01:00:38 <kmc> i think not many people use Haskell in such a mode
01:00:41 <kmc> maybe that should change
01:00:52 <kmc> also what i mean by "examples" is maybe a bit different
01:01:01 <kmc> i mean a complete working program, which is probably at least 20 or 30 lines of code
01:01:12 <kmc> i'm not sure that fits in an IDE pop-up
01:01:23 <AfC> kmc: better HTML-on-the-web API documentation was a side effect of making useful context / completion documentation. I wasn't really expecting that.
01:02:01 <opqdonut> warpzero: the easy way is to put your code in a .hs file and use ghc -ddump-SOMETHING
01:02:22 <opqdonut> see the ghc man page for the various -ddump-SOMETHING options
01:02:29 <AfC> The other problem we appear to have in Haskell land is that many libraries DO have a good in-code-thence-haddoc example, but it's only in *one* module (of eight or so)
01:02:40 <AfC> and so unless you happen to find the right entry point [not always obvious] you probably won't see the usage guide
01:02:48 <AfC> which WAS written at great effort by someone.
01:02:49 <warpzero> opqdonut, thanks muchly
01:03:03 <kmc> yeah, like i said, if it's an example of integrating A,B,C, you should not have to look through A.hs, B.hs, and C.hs to find it
01:03:11 <kmc> you want a link from the top level package page
01:03:21 <opqdonut> warpzero: -ddump-simpl is a good place to start
01:03:35 <kstt> haddock is decent for per-module API documentation, but currently lacks package-wide documentation (AKA global usage examples and tutorials).
01:04:09 <kmc> also it's a smaller thing, but inline examples in haddock don't do hyperlinks or syntax highlighting
01:05:06 <salisbury> I'm currently working on text-analysis stuff with RSS/Atom feeds. Perhaps in a few weeks time I could put together an index of Haskell blogs
01:05:49 <salisbury> search-able based on what is exposed in the feed
01:07:57 <kstt> salisbury: good project. I find the haskell planet quiet poorly designed
01:08:15 <kstt> the page is just huge, old blog posts resurfacing for no obvious reason
01:08:44 <kstt> it is not on par with haskell usual quality standards
01:08:50 <kmc> haskell planet also loses formatting from the blogs it syndicates
01:08:53 <kmc> e.g. code highlighting
01:09:01 <kmc> also it's full of off-topic stuff
01:09:06 <kmc> and i understand that's by design, but still
01:09:45 <salisbury> I'll definitely look into it. I'm writing similar code anyhow
01:18:26 <ddarius> We have usual quality standards?
01:18:33 * ddarius also likes Haskell Planet.
01:37:34 <srhb> Does anyone know of a working example of a "Hello World" in Haskell on android? Google is being very unhelpful - or there just isn't one yet at all.
01:38:37 <Axman6> I don't there's been much, if any, work getting haskell to run on android, at least not using GHC
01:39:00 <srhb> Well, then it isn't just my Google fu failing. :)
01:39:16 <Axman6> iPhone sure, but not Android
01:39:27 <kmc> i had a hack to compile Haskell code for Android using GHC 6.12
01:39:33 <kmc> the intellectual property belongs to iPwn Studios
01:39:39 <srhb> I see, okay.
01:39:41 <kmc> there were plans to open-source it, but they are sitting on it currently
01:39:45 <shachaf> kmc: Oh, you actually made that work?
01:39:47 <kmc> ish
01:39:49 <Axman6> you worked for iPwn?
01:39:54 <shachaf> Oh, you were doing it for iPwn?
01:40:04 * shachaf is redundant in this channel.
01:40:13 <kmc> does it count as "worked" if i didn't get paid and the company doesn't respond to my emails
01:40:39 <srhb> kmc: In that case, you totally still own the IP.... O;-P
01:40:56 <Axman6> yeah you quite possibly do :\
01:41:01 <kmc> i signed a contract
01:41:07 <srhb> Blasted. :)
01:41:14 <kmc> it's not like i was particularly prompt responding to them either, we both kinda dropped the ball
01:41:20 <Axman6> kmc: was getting paid a condition of the contract?
01:41:38 <shachaf> A contract to make GHC work on Android without getting paid or releasing the results?
01:41:40 <kmc> yes
01:41:51 <kmc> no, the contract says i get paid
01:42:09 <Axman6> if you don't get paid, you don
01:42:24 * Axman6 too tired to bother finishing that
01:42:37 <salisbury> axman6 may be tired, but he's right
01:42:47 <salisbury> if they don't pay you, they nullify the contract
01:42:58 <kmc> i prefer to get my legal advice from #php
01:43:20 <salisbury> just because haskell does not have a null value
01:43:32 <salisbury> does not mean your contract can't be null ;)
01:44:22 <srhb> Either way, this is depressing news. I was under the naive assumption that Haskell on Android would be a trivial matter, what with everything being Open Source and so.
01:44:36 <kmc> wow
01:44:39 <kmc> that's extremely naive
01:44:41 <salisbury> it runs on a Java VM, however
01:44:43 <Axman6> indeed
01:44:57 <salisbury> you'd have better luck with scala or closure
01:45:01 <Axman6> do they even allow native code on android yet?
01:45:03 <kmc> yes
01:45:05 <salisbury> if you want a functional lang
01:45:09 <kmc> they have for a long time
01:45:18 <Axman6> ok, i thought they did, but couldn't remember
01:45:26 <kmc> that's how i was able to run ghc-generated code
01:45:28 <Axman6> no Go yet though?
01:45:52 <srhb> *shrugs* I've come to expect much of the Open Source and Haskell community in particular.
01:45:54 <kmc> i don't know wtf iPwn is doing or where the money comes from
01:46:08 <kmc> srhb, developing for open source platforms is not automatically easier, you know
01:46:21 <shachaf> kmc: Given what you just said, one might come up with a conjecture about the money... :-)
01:47:03 <srhb> kmc: That wasn't what I tried to imply. I tried to imply that from my perspective, of course it would be a matter of finding the right Google incantation, and voila, I'd have a howto guide - because someone would have clearly solved the problem, regardless of its complexity. ;)
01:47:27 <kmc> you'll find a lot of things that obviously should exist for Haskell don't
01:47:36 <srhb> Pity.
01:47:44 <kstt> emacs question : how do you set 'haskell-program-name' to 'cabal-dev ghci' and get 'inferior-haskell-load-file' to work ? My source files are never in the top-level cabal directory, but rather in subdirectories.
01:48:55 <kstt> (but 'cabal-dev ghci' seems to insists on being run from the top directory)
01:52:01 <kstt> oh, no ... that works !
01:52:09 <kstt> fantastic, sorry for the noise !
01:54:37 <mbuf> Enigmagic: https://gist.github.com/1466063 when compiling, I get gistfile1.hs:43:15:
01:54:38 <mbuf>     Not in scope: type constructor or class `KnownExtension'
01:56:06 <ddarius> kmc: I'm willing to bet you could claim copyright and, if you wanted, release the code under an open source license, -and- still successfully sue for your paycheck.  Of course, it makes no sense to try to squeeze blood from a stone, and socially you probably don't want to do this (at this time at least.)
01:56:35 <ddarius> Certainly, unless the terms of your contract are rather strange, you have no obligation to release your copyright to them if they haven't paid you.
01:56:51 <kmc> yeah i know what my legal rights are, roughly
01:57:06 <kmc> but i don't need the money
01:57:20 <kmc> and the code isn't good enough that i want to fight someone to open-source it
01:57:43 <ddarius> I agree.  There's probably no sense to do it, and Ryan may well get around to paying you.  No reason to make bad blood.
01:58:00 <kmc> yeah
01:58:12 <kmc> i think the deal is they want to release the iPhone game first, and they are way behind on that
01:59:55 <kmc> not only are they writing an iPhone game in a weird, unsupported language, and developing the toolchain to do so
02:00:07 <kmc> but they're developing a new form of FRP to do it
02:00:19 <kmc> with a custom preprocessor that depends on bleeding-edge GHC features
02:00:29 <kmc> and then a custom game engine on top of that FRP system
02:00:40 <srhb> That sounds pretty hard core, and impossible to drive returns from. :)
02:00:45 <kmc> yep
02:00:46 <ddarius> kmc: I know.  How could they fail?!
02:00:58 <kmc> it sounds like a stereotypical haskell failure story
02:01:14 <kmc> "we tried to do something thousands of other people have done before, got mired in abstract nonsense, and now the product is 2 years late"
02:01:39 <srhb> So, Real World Haskell is a lie?!
02:01:42 <srhb> :)
02:01:55 <kmc> i think writing an iphone game in Haskell using ugly, well-worn techniques of imperative programming would be a totally different story
02:01:57 <ddarius> srhb: Not all Haskell stories are failure stories.
02:02:19 <kmc> but i'm sure others will see it as a mark against the language generally
02:02:30 <ddarius> srhb: Also, the motto is "Avoid success at all costs."
02:02:41 <srhb> Haha.
02:03:18 <kmc> it's just a question of how much ancillary PL research you bite off along with your problem
02:03:32 <ddarius> A long, long time ago when #haskell was considering making a little game Haskell I started a binding to Kyra.
02:04:10 <Peaker> I convinced a coworker to use Haskell for some debug info parsing (the existing libs are more usable than in Python/etc) -- and the coworker is just on the verge of giving up after hitting various quirks (especially seeing how hard-to-debug runtime errors in Haskell are)
02:04:25 <kmc> i think most of the success stories (e.g. http://www.haskell.org/haskellwiki/Haskell_in_industry) aren't trying to solve major open academic problems too
02:04:33 <ddarius> Indeed.
02:04:54 <ddarius> Presumably most of the companies using Haskell are accomplishing things.
02:04:56 <russellw> Peaker, I'm curious, what makes Haskell runtime errors hard to debug?
02:05:31 <Peaker> russellw: For beginners: Lack of stack traces and debugger -- and the less predictable execution order
02:05:39 <Peaker> (ghci debugger isn't particularly usable by a beginner)
02:05:46 <russellw> fair enough
02:05:52 <kmc> lack of stack traces is a problem for everyone, not only beginners
02:05:57 <kstt> kmc: haskell programming in IO hasn't much interest
02:06:09 <kmc> kstt, interest to whom?
02:06:20 <Peaker> Haskell makes it easy to avoid far more runtime errors than other mainstream languages -- but it does not actually avoid them in general.  Typical beginner-facing code has tons of runtime errors
02:06:43 <kstt> To anyone. It is middly expressive and generally slow
02:06:47 <Peaker> partial stdlib,  accidental recursions,  no-optimizations->stack overflows, ...
02:06:55 <ddarius> kstt: ?
02:06:59 <kstt> They could have picked something like scala for that
02:07:01 <kmc> kstt, that is not my experience
02:07:10 <Peaker> partial stdlib (as in "head", "tail", "fromJust", etc...)
02:07:31 <kmc> if i want a high-level language with real data structures, good performance, good concurrency, etc.
02:07:33 <kmc> i reach for Haskell
02:07:42 <kmc> doesn't matter how much of it's "in IO" or not
02:07:44 <Peaker> It seriously weakens my case (which is "Haskell is very safe") when the majority of their first Haskell programs crash with hard-to-debug runtime-errors
02:07:50 <kstt> ok
02:08:04 <kmc> i don't think many people will be won over by "Haskell is very safe" anyway
02:08:06 <kmc> it's just not sexy
02:08:12 <eikke> in lambda calculus, an 'abstraction' is a function expression, right? something like \x -> 2 * x
02:08:16 <kmc> yes
02:08:35 <Peaker> well, my coworkers in particular know how expensive bugs are (many of them lose sleep at nights over bugs, literally..)
02:08:41 <eikke> kmc: ty :)
02:08:53 <kmc> it's not about "know"
02:09:02 <Peaker> I think they find safe very sexy :)
02:09:16 <kstt> kmc: well, the debian shootout shows that haskell does not shine in this area, but then the coder tastes matter the most.
02:09:17 <ddarius> Then why are they using head, tail, and fromJust?
02:09:30 <Peaker> ddarius: They are beginners and seeing beginner-facing code in various help sources
02:09:39 <Axman6> kstt: which benchmark?
02:09:47 <kstt> all of them
02:09:49 <ddarius> Peaker: Are you providing no guidance?
02:09:51 <Axman6> uh...
02:10:00 <Peaker> ddarius: I am not there all of the time.. when I am, I do provide it
02:10:05 <Axman6> you know Haskell is the fastest for some of those benchmarks right?
02:10:16 <Peaker> ddarius: And unfortunately, I can't tell them to avoid some name prefix.. these functions are unmarked danger
02:10:33 <Peaker> The basic safety warnings (such as unexhaustive pattern matches) are also hidden behind -Wall. ghc by default compiles runtime-crashy code
02:10:46 <Axman6> kstt: haskell doesn't perform at all badly in most of those benchmarks really
02:11:03 <Peaker> It's really great that safety is made possible -- and it's really crappy that safety is discouraged in various ways
02:11:56 <Peaker> I'd really like some "this is recursive" annotation like in the ML variants -- and avoid the recursions in the default class methods, to avoid accidental recursions too
02:12:10 <kstt> indeed, haskell is very decent in most of them. But they are other languages that perform better, and are not much more painful to use if all your code must perform side effects
02:12:11 <Peaker> I've been bit by accidental recursions due to typos in my code a few times
02:13:07 <kstt> don't get me wrong, haskell is just amazing. By far the best designed language in my opinion.
02:13:35 <ddarius> kstt is silly.
02:14:19 <salisbury> as a relative beginner, I haven't had all that many run-time errors..
02:14:40 <Axman6> kstt: some of the benchmarks were specifically rewritten because haskell performed so well, thanks to laziness (specifically the binary trees one)
02:14:44 <kstt> But figures are figures : http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=scala <- in all-but-one benchmark, scala code is faster and shorter
02:14:50 <eikke> aja
02:15:06 <Axman6> I wrote a much faster implementation of that actually, i wonder if it would be accepted...
02:15:16 <kstt> that said, I don't like scala. But that does not change the figures, unfortunatly :)
02:15:39 <kstt> Axman6: please send it, if it fits
02:15:47 <salisbury> the main issue I think, is that beginners don't use type-signatures, which I believe makes things harder for GHC
02:16:35 <Axman6> well, they're probably disallow it because it uses a binary heap structure in an array rather than a structure using pointers
02:16:37 <Peaker> salisbury: I tell them to copy&paste the signatures from -Wall output :)
02:17:40 <Peaker> I doubt Scala is more concise than Haskell in general (seeing a bit of typical Scala code). I guess Haskell is sacrificing sanity for performance in the benchmarks
02:18:24 <srhb> I doubt that, given the purpose of those benchmarks.
02:18:34 <kstt> Axman6: I'm not aware of that restriction, is it written somewhere, or do you think so by experience ?
02:19:07 <Peaker> srhb: It's a common allegation -- also that the optimizations are for old GHC's - and that new GHC's would eat nicer/more idiomatic code
02:19:45 <geheimdienst> kstt: one thing to keep in mind with those benchmarks is that mostly, you don't want to buy a little less runtime at the cost of a lot more programmer time
02:20:07 <kstt> geheimdienst: I'm ALL with you here
02:20:18 <kstt> that's why I'm here, and not on #scala
02:20:49 <kstt> but ignoring the reality of figures does not help anyone
02:21:00 <kstt> that's why I appreciate the shootout
02:21:08 <srhb> Absolutely.
02:22:07 <Axman6> kstt: well, they didn't like not allocating the tree at all and letting laziness turn it into a constant space computation
02:23:08 <kstt> Axman6: ok. And what if the laziness is simulated in the code itself ? Do they find it more acceptable ? :)
02:24:43 <kstt> Just to clarify, the original discussion was related to kmc reporting how hard it was to get a haskell-GHC-game-application-for-IPhone-based-on-FRP-because-side-effects-suck©
02:25:22 <Axman6> well, you're asked to make a binary tree, the haskell code did, but the compiler saw it was useless. if you did it explictly then you couldn't say you were doing that
02:26:15 <Axman6> urgh, these scala programs are to ugly >_<
02:26:21 <Axman6> why do people prefer this to java anyway?
02:27:25 <daimrod> because java is worst ?
02:27:53 <kstt> Axman6: haskell programs with more pragmas and ghc-specific hints than proper code are not particulary pretty either.
02:28:51 <kstt> although I notice that things have improved a lot in this area since last time I looked at implementations
02:28:58 <kstt> much cleaner now !
02:29:52 <ddarius> Given the choice between writing non-semantics changing hints and code to improve performance, I'd prefer the hints.
02:29:57 <Guest65743> exit
02:30:00 <Guest65743> quit
02:30:03 <Guest65743> bye
02:30:21 <kstt> looking at shootout implementations in any language, they all seem terribly ugly
02:30:34 <kstt> throughput matters most
02:30:46 <eikke> does the haskell type system have anything alike to ML's value restriction?
02:30:55 <Axman6> i dunno, the haskell binnary trees one is quite clear. the only thing I don't understand is the book in check'
02:31:01 <ddarius> The Shootout is not really representative of ... anything.  At best it gives some very broad strokes that you probably already knew from hearsay.
02:31:17 <ddarius> eikke: Not really.
02:31:37 <ddarius> The monomorphism restriction is vaguely similar but it is not required nor does it serve the same purpose as the value restriction.
02:31:46 <ddarius> The value restriction only makes sense if you have mutation.
02:32:22 <eikke> ddarius: like, IORef?
02:33:34 <ddarius> eikke: I should have said unrestricted mutation, but you can run into exactly the problem the value restriction handles by using IORefs and unsafePerformIO.
02:33:47 <ddarius> That is, you can implement unsafeCoerce using unsafePerformIO and IORefs.
02:34:10 <eikke> sure
02:38:19 <salisbury> anyone know how to remove xml namespaces in HXT?
02:51:44 <salisbury> disregard, I've found it
02:52:42 * hackagebot xournal-parser 0.2 - Xournal file parser  http://hackage.haskell.org/package/xournal-parser-0.2 (IanWooKim)
02:52:44 * hackagebot xournal-render 0.2.0.0 - Xournal file renderer  http://hackage.haskell.org/package/xournal-render-0.2.0.0 (IanWooKim)
02:52:46 * hackagebot hxournal 0.5 - A pen notetaking program written in haskell  http://hackage.haskell.org/package/hxournal-0.5 (IanWooKim)
03:07:43 * hackagebot hxournal 0.5.0.0 - A pen notetaking program written in haskell  http://hackage.haskell.org/package/hxournal-0.5.0.0 (IanWooKim)
03:07:45 * hackagebot hfusion 0.0.6.1 - A library for fusing a subset of Haskell programs.  http://hackage.haskell.org/package/hfusion-0.0.6.1 (FacundoDominguez)
03:21:00 <frerich> Hm, what is something like 'HFusion' good for? Doesn't it make the progarm less generic, and removes some burden from the compiler writer to the program writer?
03:21:36 <frerich> It seems a bit like unrolling a loop manually in case the compilers optimizations don't kick in.
03:22:44 * hackagebot digestive-functors-snap 0.1.2.0 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-snap-0.1.2.0 (JasperVanDerJeugt)
03:32:25 <hpaste> andsens pasted “typeclass instance” at http://hpaste.org/55178
03:32:59 <andsens> would anybody care to help me with that? Not sure how to debug this...
03:33:25 <mauke> andsens: pop is supposed to take two arguments
03:33:37 <wavewave> hi, all! I just announced hxournal!
03:33:51 <andsens> aargh. ffs. Of course
03:34:01 <andsens> Thank you. Looked at this for an hour, lol
03:39:02 <Jaak> nd morning
03:39:11 <Jaak> uhoh, wc
03:41:15 <luite> wavewave: looks interesting... unfortunately I don't have a tablet with wacom input anymore :(
03:51:22 <wavewave> luite: I bought a tablet from ebay. now you can buy a decent one with $100. ;-)
03:52:02 <luite> oh what kind of hardware and operating system?
03:52:03 <wavewave> haskell is so good in GUI programming.
03:52:07 <wavewave> linux
03:52:32 <wavewave> ibm/lenovo thinkpad is most decent.
03:52:41 <wavewave> in terms of linux installation.
03:52:44 <luite> oh right, second hand
03:52:57 <wavewave> yeah.
03:53:01 <luite> thought you meant some ipad clone from ebay :)
03:53:18 <wavewave> i don't count ipad as a tablet.
03:53:31 <wavewave> tablet without pen is useless.
03:53:57 <luite> meh I don't agree, but a pen would definitely increase usefulness :)
03:54:10 <wavewave> I use tablet from 2003, and fortunately I tried almost every tablet.
03:54:42 <wavewave> because my professor is a kind of fanatic of tablet.
03:55:30 <wavewave> anyway.. nowadays hardwares are so cheap.
03:56:47 <luite> well I wanted to wait for something with a higher res screen and hopefully pen input to upgrade my ipad, but it's not there yet, maybe next year
03:57:17 <wavewave> ;-)
03:57:53 <wavewave> anyway I am very happy that haskell is proven very effective in GUI programming
03:58:31 <wavewave> coroutine programming is so useful.
03:58:48 <luite> i used to have an eink reader with xournal, which as ok, but very slow
03:59:02 <wavewave> yeah.. i have it in fact.
03:59:10 <luite> which one?
03:59:31 <wavewave> I had iliad and stolen and later I had entrouge edge
03:59:38 <luite> ah
03:59:43 <luite> i had a dr1000
03:59:48 <wavewave> useless for me.
03:59:49 <luite> until it died and i bought an ipad
03:59:59 <wavewave> e-ink is too slow.
04:00:20 <luite> it worked ok for reading papers and books, but yeah, less then ideal for anything else
04:00:42 <nazgjunk> e-ink currently isn't good for anything but that, yeah.  It's *brilliant* for that, though :P
04:01:06 <wavewave> I am too spoiled by wacom.. so I cannot use anything other than wacom..
04:01:20 <luite> nazgjunk: as long as you have enough light
04:01:28 <luite> tft is better in badly lit places :)
04:01:32 <wavewave> I had motioncomputing's M1200 from the beginning.
04:01:45 <nazgjunk> luite: I've got a cover for my kindle that includes a led light that draws power from the kindle
04:01:54 <wavewave> M1200, M1300, M1400, Thinkpad X41...
04:02:17 <nazgjunk> drains the battery, of course, but it still lasts a decent while (not that I could give you any numbers)
04:02:52 <wavewave> ah... nec litepad, too.
04:03:27 <luite> nazgjunk: hmm how readable is that? I found that I needed a bit more light to read eink than regular paper
04:03:38 <wavewave> I also bought ipad2 for my mom.. so I actually heavily tested ipad2 before giving it to her.
04:03:46 <luite> (although my reader ahd the older screen, not the nwere high contrast screen with 10:1 contrast ratio)
04:06:09 <wavewave> anyway, the biggest barrier against ipad and android for me is that I cannot make a haskell program there!
04:08:49 <wavewave> anyway, please give a try to hxournal (it works with mouse)
04:09:37 <wavewave> I am now planning to design it similarly with emacs.
04:10:51 <wavewave> buffer/window separation and server/client separation
04:13:57 <wavewave> also scriptable with haskell like XMonad or yi
04:16:01 <kalven> k
04:17:13 <k0ral> hi, is it possible to specify 2 *head* source repositories in a cabal package ?
04:22:46 * hackagebot hbro 0.7.1.1 - A minimal KISS compliant browser  http://hackage.haskell.org/package/hbro-0.7.1.1 (koral)
04:30:58 <andsens> In my previous hpaste: http://hpaste.org/55178  How would I go about removing the "Int" from the "Queue" declaration?
04:31:49 <hpaste> andsens annotated “typeclass instance” with “typeclass instance (annotation)” at http://hpaste.org/55178#a55181
04:33:46 <hpaste> andsens pasted “Simple queue” at http://hpaste.org/55182
04:34:15 <andsens> Ignore the annotated version: http://hpaste.org/55182 is better
04:36:25 <wunki> is it possible to do a qualified import from GHCI?
04:38:52 <hpc> wunki: "import qualified Foo [as F]"
04:38:58 <hpc> (the "as" part is optional)
04:39:16 <wunki> hpc: thanks, I was trying :m
04:39:31 <mauke> wunki: no
04:39:33 <hpaste> cwl pasted “snaplet-session” at http://hpaste.org/55183
04:39:45 <andsens> :m sets the context, right?
04:40:04 <hpc> wunki: oh crap, i just tried and it doesn't
04:40:08 <cwl> help me correct it
04:40:33 <cwl> about how to use snaplet-session
04:41:22 <hpc> wunki: i think you might be able to write a file with the imports you want, then run "ghci imports.hs"
04:41:31 <hpc> but dunno if that will work
04:43:22 <wunki> hpc: will just :m for now :)
04:44:25 <cwl> http://hpaste.org/55183
04:49:09 <andsens> Doesn't anybody have an idea on how to remove the "Int" from the "Queue" declaration int this paste:http://hpaste.org/55182 ???
04:49:23 <andsens> argh… http://hpaste.org/55182
04:49:27 <andsens> should be clickable now
04:50:41 <kmc> i don't understand your question
04:51:09 <kmc> if you're asking how to remove stuff then you need to tell us what it is you want to keep
04:51:19 <sshine> andsens, size uses length, which is hardcoded. use genericLength there.
04:51:44 <andsens> I would like to be able to parameterize the type that SimpleQueue holds
04:52:21 <kmc> data SimpleQueue a = SimpleQueue [a] deriving (Show)
04:52:38 <kmc> but then you can't write the instance
04:52:57 <kmc> this is a well-known problem with container types
04:53:08 <kmc> you can solve it with multi-parameter type classes, associated types, and other such extensions
04:53:12 <andsens> sshine: Like so? genericLength :: Num i => a -> i
04:53:12 <kmc> but here i think there is a simpler solution
04:53:25 <andsens> I'm listening kmc…?
04:53:30 <kmc> class Queue q where { pop :: q a -> (a, q a);  push :: a -> q a -> q a;  size :: q a -> Int }
04:54:01 <sshine> kmc, do you then say that Queue is a typeclass for a typeclass?
04:54:03 <kmc> also i think you want pop :: q a -> Maybe (a, q a)
04:54:09 <kmc> no, it's a typeclass for a type constructor
04:54:15 <kmc> q isn't a class there, it's a type constructor
04:54:21 <sshine> ok.
04:55:10 <kmc> the downside is that all of your queue types have to be fully parametric
04:55:12 <andsens> I _think_ I understand.
04:55:20 <kmc> you can't for example invent some super specialized queue for Ints only, and make it an instance
04:55:29 <andsens> Hm, maybe I should just stick with Int then...
04:55:36 <kmc> that's where the type extensions come in
04:55:48 <kmc> if you want [a] to be a queue of a's, *and* for ByteString to be a queue of Word8's
04:56:03 <kmc> why are you using a type class at all?
04:56:08 <andsens> I'm implementing the Chris Okasaki paper on Purely function Queues
04:56:13 <kmc> ah
04:57:46 * hackagebot snaplet-mongoDB 0.2 - Snap Framework MongoDB support as Snaplet  http://hackage.haskell.org/package/snaplet-mongoDB-0.2 (KamilCiemniewski)
04:58:54 <hpaste> andsens pasted “Deduction not possible...?” at http://hpaste.org/55185
04:59:01 <andsens> The whole problem actually arises from a foldl
04:59:46 <kmc> why do you expect «foldl push queue [1..20]» to be an IO action?
05:00:31 <andsens> I don't… do I?
05:00:48 <kmc> you're using it in a "do" block where the next thing is an IO action
05:00:54 <kmc> so it has to be an IO action
05:01:04 <kmc> http://www.haskell.org/haskellwiki/Introduction_to_IO
05:01:05 <andsens> ah, so blah <- foldl .....
05:01:10 * BMeph likes push better as ":: q a -> a -> q a"
05:01:12 <kmc> an IO action is anything of type "IO t" for some t
05:01:16 <kmc> andsens, no, that will have the same problem
05:01:17 <sshine> andsens, that has to be an action as well.
05:01:20 <kmc> maybe you want "let blah = foldl ..."
05:01:35 <kmc> but it doesn't make sense
05:01:40 <kmc> to define this let-binding and then not use it
05:01:45 <andsens> ah yes. let full = foldl push queue [1..20]
05:01:51 <andsens> Well, that's coming....
05:01:53 <kmc> all this code does is print the word "filled"
05:02:19 <andsens> I am going to pop the stuff and print it out… Once I get mapM working....
05:04:05 <sshine> andsens, if you want your Queue to be monadic, I think it makes sense to define push, pop, etc. as monadic actions.
05:04:28 <sshine> andsens, or at least define pushM, popM, etc.
05:04:40 <kmc> i don't think that's what andsens is going for here
05:04:55 <andsens> no, I'm just trying to test my datastructure...
05:05:02 <andsens> Which is going to be benchmarked later on
05:05:09 <kmc> define some properties for it to satisfy
05:05:13 <kmc> and test them with QuickCheck
05:05:17 <andsens> Just getting the hang of it with a Simple Queue
05:05:23 <kmc> these aren't in terms of "do x, then do y"
05:05:33 <kmc> they're in terms of values derived from other values by queue operations
05:05:36 <kmc> declarative, not imperative
05:05:49 <andsens> uuuuh. Sounds good
05:06:03 <kmc> RWH has a chapter about quickcheck
05:06:04 <sshine> I'm not really sure what sequential is supposed to do... fill one queue with twenty items and print ok?
05:06:19 <kmc> the "let"-bound code doesn't run if you don't use it
05:06:41 <andsens> I know. But it is still checked for errors… :-)
05:06:48 <kmc> type errors
05:06:52 <andsens> yes
05:07:03 <kmc> anyway i think you should look at QuickCheck if you haven't already
05:07:16 <andsens> On it right now… thanks!
05:07:28 <andsens> Do you think http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck will suffice to get started?
05:07:45 <kmc> QuickCheck is very nice... I have heard people go so far as to call it the killer feature for Haskell
05:08:34 <kmc> andsens, i don't know; it looks old
05:08:49 <kmc> try http://book.realworldhaskell.org/read/testing-and-quality-assurance.html
05:08:57 <kmc> RWH isn't up-to-date on everything either
05:09:23 <andsens> Actually reading Learn You a Haskell right now
05:09:25 <kmc> but it's widely used, so we can help with any discrepancies
05:09:31 <andsens> I heard RWH should be quite boring...
05:09:40 <kmc> it's also higher-quality writing than the average wiki page
05:10:11 <sshine> andsens, I recently read from both, and I prefer LYAH as well.
05:10:15 <kmc> you asked for an intro to quickcheck
05:10:23 <kmc> i'm not saying you need to read all of RWH
05:10:27 <kmc> but this chapter is such an intro
05:10:48 <kmc> LYAH and RWH are very different books
05:10:58 <kmc> it makes sense to read both, or at least to read the "topics chapters" from the latter
05:11:01 <andsens> hm ok, I think I will definitely pick it up once I have gotten over the basics
05:11:12 <andsens> That was my impression as well
05:11:23 <kmc> myself i learned a lot from the later topics chapters, even though i knew haskell pretty well at the time
05:36:44 <wunki> is this the correct type synonym explanation: https://gist.github.com/5d63b5eca6c9aa6fa5c6 (see comment) ?
05:37:58 <kmc> "returns an Iteree, B.Bytstring and IO Response" is incorrect
05:38:04 <kmc> makes it sound like it returns three things
05:38:20 <kmc> it just returns an Iteratee
05:38:32 <kmc> but Iteratee is a type constructor which takes three parameters
05:38:44 <wunki> kmc: ah, I was actually thinking it returned three things..
05:38:45 <kmc> here those parameters are given as B.ByteString, IO, Response
05:38:54 <kmc> Int -> Maybe Char  doesn't return a Maybe and a Char
05:38:57 <kmc> it returns a Maybe Char
05:39:09 <wunki> kmc: you are completely right.. missed that
05:39:27 <kmc> it may be confusing because IO itself is a type constructor
05:39:36 <kmc> but type constructors can take other type constructors as parameters
05:39:57 <kmc> in this case, Iteratee works over an underlying monad, and here we choose the IO monad
05:40:02 <kmc> but monads are themselves type constructors
05:41:18 <wunki> kmc: that cleared things up for me. Thank you. Going to read more about Iteratee to fully comprehend it.
05:41:23 <kmc> cool :)
06:03:54 <etpace> Is it possible with some clever extensions/fundep hacking for a function to take a function of different aritys? ie: f :: ([Foo ->]* Bar) -> Baz, ie, f takes any function of the types: Bar, Foo -> Bar, Foo -> Foo -> Bar, ... ?
06:04:16 <mauke> sometimes
06:04:22 <si14> hello, guys. how do you add logging in your Haskell apps?
06:04:36 <etpace> writer monad perhaps sil4
06:04:43 <etpace> mauke: when and do you have any examples to look at?
06:07:26 <si14> etpace: didn't see any examples of such use of it
06:07:58 <kmc> etpace, you probably don't want to
06:08:05 <kmc> do you have a particular use-case in mind
06:08:19 <EvanR-work> logging is this thing that managers like to want
06:08:22 <kmc> etpace, Text.Printf is one example
06:08:24 <EvanR-work> log everything
06:08:26 <sipa> etpace: class VarargClass t where f :: t -> Baz; instance VarargClass (Foo -> Bar) where ...; instance VarargClass a => VarargClass (Foo -> a) where ...
06:08:27 <EvanR-work> *every* *thing*
06:08:45 <kmc> it's not a good idea though.  i have problems with printf too
06:08:48 <EvanR-work> log every instance of a particular expression being evaluated
06:09:24 <kmc> Text.Printf is extra double ugly because it does this shit and is also standard Haskell 98
06:09:49 <EvanR-work> standard h96 is ugly?
06:09:51 <EvanR-work> 98
06:10:06 <kmc> sometimes
06:10:22 <kmc> especially if you are trying to use type classes in a strange way
06:10:25 <si14> I can't believe that noone really made something for logging :)
06:10:36 <arw> System.Log.Logger
06:10:39 <EvanR-work> logging inside your pure code is dumb
06:10:55 <kmc> si14, there is stuff at http://hackage.haskell.org/packages/archive/pkg-list.html, did you search for the word "log" or "logging"
06:10:58 <EvanR-work> just add a log action wherever in your IO code
06:11:00 <si14> EvanR-work: it's not if it was called from IO code
06:11:12 <kmc> EvanR-work, there's more to logging than putStr
06:11:24 <etpace> kmc: its used for a code generator function, where each arity corresponds to that arity of function being generated, would be quite bothersome to have createFunction2..6 or whatever
06:11:34 <arw> EvanR-work: yes, but there are plenty of non-pure actions most software does, and that is where you mostly want to log things...
06:11:37 <kmc> etpace, why not take a list
06:11:43 <EvanR-work> then
06:11:50 <EvanR-work> < EvanR-work> just add a log action wherever in your IO code
06:12:04 <si14> EvanR-work: did you write any real app on Haskell?
06:12:41 <EvanR-work> how is that related to logging?
06:12:49 <si14> EvanR-work: pure code is fine, but logging of pure function is perfectly ok if log is returned with the value, so it should be a monad
06:12:53 <kmc> i don't like the attitude where things like logging are dismissed as "something managers like to want"
06:13:11 <EvanR-work> thats exactly what it is
06:13:16 <kmc> life is not some fucking dilbert cartoon where the bosses are out to get you
06:13:21 <EvanR-work> yes it is
06:13:26 <kmc> i mean if your job is, you should quit asap
06:13:34 <etpace> I wouldn't know what generated arity to use when given a ([Foo] -> Bar)
06:13:35 <si14> EvanR-work: it affects the way you think. if you didn't you pretend to think that there is no "real world" or "bugs" or "problems" or "logs" or whatever
06:13:38 * EvanR-work looks at the dilbert cartoon on the wall behind him, posted there by a manager
06:13:41 <kmc> but i've never worked anywhere like that, and yet the bosses wanted logging
06:13:43 <kmc> for good reasons
06:13:48 <kmc> so you know what the hell is going on
06:13:58 <EvanR-work> si14: i definitely log error messages and exceptions
06:13:58 <kmc> etpace, er, go by the length of the list?
06:14:03 <EvanR-work> si14: using stderr ;)
06:14:14 <si14> EvanR-work: sucks to be your colleague
06:14:24 <arw> also, logging is there to make the miserable life of users of your software easier. like "hi there, i've found a condition that is probably a problem and you need to look at that. meanwhile i will not kill myself and continue serving users."
06:14:39 <kmc> shit, logging is there to make developers lives easier
06:14:39 <EvanR-work> thats another subject, user experience
06:14:42 <arw> every different behaviour from software _really_ _sucks_
06:14:49 <kmc> so you know what the hell went wrong when your software failed in the field
06:14:54 <EvanR-work> you will notice that 100% of 'apps' have error messages that no one can understand except MAYBE the engineers
06:15:04 <kmc> etpace, that's a run-time error if it mismatches, but so is the printf hack
06:15:05 <si14> arw: I like that I'm not alone. Now, can you please suggest me any good package for this? :)
06:15:10 <kmc> > printf "%d %d" :: String
06:15:11 <lambdabot>   "*Exception: Printf.printf: argument list ended prematurely
06:15:14 <ben> so what's the problem, tack on a LogT or something to your application's monad transformer stack~
06:15:25 <kmc> ben, which hackage package is that from?
06:15:32 <ben> a custom one i mean
06:15:36 <etpace> kmc: if I give it (\[x,y] -> generate body) then my f doesn't know whether to generate a 2arity low level function or a 27 arity
06:15:43 <arw> si14: as i've said, System.Log.Logger is good, but there are possibly also a lot of other options.
06:15:54 <etpace> I guess I could make it Int -> ([Foo] -> Bar)
06:15:55 <kmc> ben, "what's the problem, just write all the code yourself from scratch"
06:16:02 <ben> i'm just flippantly dismissing your entire argument as an implementation detail because I don't like reading heated arguments in here :(
06:16:04 <kmc> i'm sick of this attitude too
06:16:08 <kmc> it's common in this channel
06:16:20 <kmc> important but practical problems are dismissed because they are theoretically uninteresting
06:16:30 <kmc> and nobody cares that it's a gap in the available libraries
06:16:38 <kmc> because they spend 3 seconds thinking about how you'd solve the problem
06:16:41 <kmc> and consider it as good as solved
06:16:41 <EvanR-work> just dont use any FFI libs and your program wont crash ;)
06:16:42 <arw> si14: as for the "logging from pure code"-part, i'm not quite sure. i've never really tried that.
06:17:05 <si14> kmc: I second you.
06:17:11 <arw> si14: but for everything in IO, you should be fine with System.Log.Logger
06:17:25 <kmc> @hoogle System.Log.Logger
06:17:25 <lambdabot> package HLogger
06:17:26 <lambdabot> package hlogger
06:17:26 <lambdabot> package hslogger
06:17:29 <kmc> hahahahaha
06:17:34 <jessopher> nice
06:17:38 <jessopher> variety
06:17:40 <kmc> the package should be named HaskellHSLoggerForHaskell
06:17:43 <ben> :D
06:18:05 <EvanR-work> exactly why do you need a package for hPutStrLn ?
06:18:10 <si14> arw: thanks. it's just strange that that wasn't done before, looks obvious for me
06:18:11 <kmc> fucking troll
06:18:22 <EvanR-work> youre the troll
06:18:31 <kmc> you've never used a logging library have you
06:18:51 <kmc> timestamps, remote logging, log rotation, multiple outputs, capture (for testing), log levels
06:18:55 <kmc> none of this is important to you
06:19:00 <EvanR-work> whether or not i did, i guess im doomed to not know wtf you are talking about because you spend 30 minutes on a rant with no details
06:19:03 <kmc> just some shit the fucking pointy-haired suits want, right
06:19:05 <ben> hlogger is apparently the new HLogger
06:19:13 <ben> and doesn't actually provide System.Log.Logger from hat I can tell
06:19:23 <kmc> i just named 6 features, hPutStrLn doesn't have those
06:19:25 <ben> and both of them declare themselves obsolete
06:19:39 <EvanR-work> timestamps are easy to do yourself, rotation is something you should do in the shell
06:19:46 <frerich> I think supporting/maintaining any nontrivial application which you deployed is much more painful than it needs to be if you don't use a proper logging library (which takes care about log levels, exact time stamps, convenient formatting and whatnot). So the need for a nice logging framework in *any* programming language with a minimum of self-respect seems like a no-brainer to me :-}
06:19:48 <cheater> kmc: u mad?
06:19:50 <Stevo> hey guys currently doing a implemention of a 234 in haskell and was trying to get some advice, im looking to create a function to assit with a main insert function, this assist function basically handles the first element inserted into a 234 tree problem is i don't know what node i should insert it at the start up
06:20:05 <kmc> EvanR-work, it's all easy to do yourself!  until you do it
06:20:16 <cheater> and yeah
06:20:16 <kmc> that's what i mean by "spend 3 seconds thinking about how you'd solve the problem and consider it as good as solved"
06:20:18 <cheater> i'm with kmc
06:20:24 <cheater> except for the rrraaaggeee
06:20:51 <cheater> but people who sit there looking at available problems, think "ok that's easy, just do 1 2 3" have very obviously never done a day of honest work in their life
06:20:51 <kmc> "rotation is something you should do in the shell"  oh yeah?
06:20:52 <EvanR-work> and would be nice for meta-code stuff like that to all be handled outside the program, by the runtime or debugger
06:21:03 <ben> Looks like the hslogger guys put more thought into logging than I ever have
06:21:30 <EvanR-work> i see theres a penchant for overengineering in here
06:21:48 <EvanR-work> more work is more value
06:22:02 <Stevo> anyone have any opnions on that problem?
06:22:12 <kmc> EvanR-work, all the features i want are important, but all the features i don't want are overengineering
06:22:17 <ben> It seems fairly project-specific what the right quantity of engineering is, why'd you dismiss it all up-front as over-
06:22:22 <frerich> Stevo: People are in the middle of a logging framework bikeshed ;-)
06:22:23 <kmc> all these idiots keep writing software which does things i don't want
06:22:35 <EvanR-work> kmc: except i regularly eliminate features i 'do want' to avoid this
06:22:50 <Stevo> frerich: ;_;
06:22:58 <mauke> frerich: this isn't bikeshedding
06:23:00 <ben> for the record, I've never heard of 234 trees so I would not be helpful regardless ;)
06:23:16 <frerich> Stevo: I would have replied if I knew anything about 234 trees
06:23:24 <kmc> it's not bikeshedding
06:23:29 <frerich> mauke: Whatever you say, I won't get dragged into a meta-discussion :)
06:23:48 <si14> kmc: that's EXACTLY why I don't write my servers in Haskell
06:23:48 <mauke> apology accepted
06:23:53 <EvanR-work> i say avoiding metadiscussions is abominable, discuss
06:24:09 <si14> kmc: Erlang is way better as a *system*, not a nice language with bells and whistles
06:24:30 <frerich> I personally agree with kmc but I think it's pretty fruitless to debate such things here since everybody has an opinion on it ;-)
06:25:05 <kmc> what
06:25:12 <kmc> it's fruitless to debate things where people have opinions?
06:25:15 <kmc> what
06:25:35 <EvanR-work> yes completely
06:25:38 <si14> frerich: nope, it's fruitful to kick shit out from guys who don't really understand what it means to write something for money and not for fun when their mom pays for their basement
06:25:42 <EvanR-work> only argue about stuff that everyone agrees on
06:25:46 <cheater> "I have written a hPutStrLn oneliner with timestamps, remote logging, log rotation, multiple outputs, capture and log levels, but the line is 83 characters and lint only allows 79" - Pierre de Fermat
06:26:22 <scooty-puff> does anyone know of a good paper or other resource describe a type inference algorithm that handles recursive functions?
06:26:25 <EvanR-work> its haskell, your code cant fail, dont worry about it
06:26:28 <scooty-puff> (NOT polymorphic recursion)
06:26:33 <kmc> EvanR-work, now you're really trolling
06:26:47 <frerich> si14: Geez that's a lot of hostility right there. ;-)
06:26:55 <cheater> "If a haskell program compiles, it does what your manager wants" - EvanR
06:27:19 <si14> frerich: it's because of butthurt :)
06:27:20 <EvanR-work> luckily my managers dont know anything about the haskell they are running on, so cant request logs
06:27:21 <mauke> scooty-puff: what type inference algorithm doesn't handle recursive functions?
06:27:29 <cheater> scooty-puff: ask roconnor when he's here
06:27:43 <Saizan> maybe we should calm ourselves and even drop the subject? arguing with someone you consider a troll seems pretty fruitless
06:27:50 <scooty-puff> mauke: i imagine all do, just now sure how to implement it
06:27:50 <si14> EvanR-work: ah, now I see. It doesn't suck to be your colleague because you don't have any
06:27:59 <EvanR-work> well, they all quit
06:28:05 <EvanR-work> and they didnt understand haskell anyway
06:28:16 <si14> EvanR-work: I should say thay neither do you
06:28:24 <EvanR-work> why is that
06:28:28 <scooty-puff> mauke: my first thought was to define everything to be a type variable, and constrain from there - but wasn't sure how to handle let-generalization in such a case
06:28:49 <scooty-puff> cheater: i will, thanks
06:29:08 <si14> EvanR-work: because Haskell is *programming language*. *programming* means *engineering* after all. and *engineer* don't fly in the sky instead of making a good job
06:29:18 <EvanR-work> no i disagree
06:29:25 <EvanR-work> it should be able craftsmanship
06:29:32 <si14> EvanR-work: of course you are
06:29:43 <kmc> no programming is like painting, of course
06:29:50 <kmc> it's like painting and playing a sick guitar solo, all at once
06:29:55 <kmc> and ninjaing a guy in the face
06:29:55 <copumpkin> programming is like taking a dump
06:29:56 <frerich> I thought programming is like burritos.
06:30:00 <si14> EvanR-work: it would be surprising if you will agree about that
06:30:04 <kmc> copumpkin, sounds like logging to me
06:30:06 <copumpkin> frerich: yeah, in the sense I just gave
06:30:15 <EvanR-work> epic trolls
06:30:18 <frerich> ;-)
06:30:20 <kmc> i ninja'd that guy but good with my paint guitar
06:30:28 <kmc> "i ninja'd that guy but good with my paint guitar" -- abraham lincoln
06:30:38 <mauke> what is this, uncyclopedia?
06:30:39 <scooty-puff> mauke: the simple case of just a recursive function seems straightforward with use of  a fixed point combinator - not sure if mutual recursion would be as easy
06:30:59 <Jafet> Recyclopedia
06:31:19 <mauke> scooty-puff: put mutual group in tuples, fixpoint that
06:32:21 <scooty-puff> ah, duh
06:32:25 <scooty-puff> mauke: thanks
06:32:36 <scooty-puff> mauke: just wondering, do you know if ghc does something similar?
06:32:37 <kmc> wait, so why isn't EvanR-work kicked for this behavior
06:32:42 <mauke> scooty-puff: sorry, no idea
06:32:51 <sam4> Hi2026 is it possible for an Integral type to instantiate to RealFrac typeclass?
06:32:56 <EvanR-work> go ahead, censor the dissenters
06:33:05 <kmc> censor the people who admit to trolling
06:33:14 <mauke> kmc: trolling isn't bad per se
06:33:16 <cheater> down with the ivory tower!
06:33:17 <scooty-puff> mauke: k, not a big deal - what you describe sounds very simple - and i imagine ghc has a bunch of other stuff going on for various extensions
06:33:18 <EvanR-work> who did that
06:34:06 <EvanR-work> mauke you caused him to ragequit
06:34:24 <aadrake> Question: Have any of you used Haskell for analysis of large data sets in mongodb?
06:34:30 <Stevo> right then, im trying to create a function that handles the first element in a node, the node in question holds 4 elements and then has 4 leafs. sadly what i currently have doesn't work and i can understand why it doesn't but i don't know what to do, singleton :: a -> Tree234 a   singleton x = ThreeNode x EmptyTree EmptyTree EmptyTree EmptyTree
06:34:51 <mauke> EvanR-work: and you're being a dick
06:35:17 <scooty-puff> roconnor: would have happen to know how the ghc compiler handles function recursion with type inference?
06:36:09 <si14> aadrake: no way
06:36:16 <sshine> Stevo, why doesn't that work?
06:36:19 <sam2> Hi can I ask a question
06:36:26 <si14> aadrake: Mongo is too easy for this channel
06:36:28 <sshine> sam2, yes.
06:36:46 <sam2> is it possible for an Integral type to instantiate RealFrac typeclass?
06:36:54 <si14> aadrake: so just write driver for yourself, it's the best answer that you can get here
06:36:55 <mauke> sam2: sure, why not?
06:37:06 <mauke> si14: ok, stop that
06:37:26 <si14> mauke: too much irony, I suppose?
06:37:30 <sam2> so, is it possible to define it once for all integral types or do I have to instantiate each one?
06:37:35 <Stevo> sshine: couldn't match expected type "Tree234 a" with actual type "Tree234 a0 -> Tree234"
06:37:57 <sam2> I just want to use functions such as round, truncate, etc. for integral types
06:38:03 <sam2> it should just return without doing anything
06:38:06 <mauke> sam2: why?!
06:39:17 <sam2> let me show you the code
06:39:50 <EvanR-work> :t round . fromIntegral
06:39:51 <lambdabot> forall b a. (Integral b, Integral a) => a -> b
06:40:03 <EvanR-work> roundI = round . fromIntegral
06:40:13 <EvanR-work> roundI = id ;)
06:40:20 <sam2> I want to achieve something like this
06:40:20 <sam2> http://hpaste.org/55189
06:42:00 <mauke> sam2: why?
06:42:21 <sam2> because I want the parameter r to be of any real type...
06:42:44 <sam2> so if r*w turns out to be 5.5 for instance
06:42:48 * hackagebot data-clist 0.0.7 - Simple functional ring type.  http://hackage.haskell.org/package/data-clist-0.0.7 (JohnVanEnk)
06:42:50 <sshine> Stevo, what is your Tree234 type defined as?
06:42:53 <sam2> I want an Integral type between -5.5 and 5.5
06:42:59 <sshine> Stevo, does it have five different type parameters?
06:42:59 <Stevo>  data Tree234 a = EmptyTree | TwoNode a a (Tree234 a) (Tree234 a) | ThreeNode a a a (Tree234 a) (Tree234 a) (Tree234 a)| FourNode a a a a (Tree234 a) (Tree234 a) (Tree234 a) (Tree234 a) deriving (Show, Read, Eq)
06:43:20 <Stevo> sshine: data Tree234 a = EmptyTree | TwoNode a a (Tree234 a) (Tree234 a) | ThreeNode a a a (Tree234 a) (Tree234 a) (Tree234 a)| FourNode a a a a (Tree234 a) (Tree234 a) (Tree234 a) (Tree234 a) deriving (Show, Read, Eq)   depends on the node
06:43:25 <mauke> sam2: why?
06:43:44 <sam2> mauke: uh2026 is it not possible?
06:44:13 <mauke> sam2: I can't think of an obvious way and I'm not convinced it would be a good idea
06:44:49 <sam2> mauke: hm.. is there no way to achieve a similar effect?
06:45:02 <mauke> I don't like that effect
06:45:09 <sam2> Haha...
06:45:10 <EvanR-work> similar effect, use Real types
06:45:26 <EvanR-work> forget integral
06:46:03 <quicksilver> round ( realToFrac ( -r*w ) ) would work, wouldn't it?
06:46:17 <sshine> Stevo, so... ThreeNode has to be specified with three a's and three (Tree234 a)s... e.g. ThreeNode x x x EmptyTree EmptyTree EmptyTree
06:46:19 <sam2> :t realToFrac
06:46:20 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
06:46:21 <quicksilver> :t \r -> round ( realToFrac ( -r * 5 ) )
06:46:22 <lambdabot> forall a b. (Real a, Integral b) => a -> b
06:46:36 <quicksilver> not that I *really* have the faintest idea what you're trying to do.
06:46:47 <EvanR-work> quicksilver: he starts with an Integral
06:46:52 <sshine> Stevo, why do you have so many weird constructors? what kind of tree are you building?
06:46:56 <quicksilver> no he doesn't EvanR-work
06:47:07 <quicksilver> he wants to *finish* with an integral
06:47:09 <EvanR-work> oh, well thats what the question was, how to round an integral
06:47:13 <quicksilver> which is what 'round' gives him in my example.
06:47:20 <sam2> let me try realToFrac
06:47:29 <quicksilver> his question made no sense at all to me, but the code he pasted, I believe my solution fixes.
06:48:22 <Stevo> sshine: 234 tree
06:48:29 <Stevo> sshine: http://en.wikipedia.org/wiki/2-3-4_tree
06:49:06 <benmachine> I think quicksilver is right, though I think sam2 wants truncate instead of round
06:49:33 <sshine> Stevo, from that definition, it seems that you have the wrong number of data elements for various constructors.
06:49:54 <benmachine> but I think the point people are trying to make is that it's unusual to need such a function
06:50:43 <sshine> Stevo, i.e. a 2-node has 1 data element, a 3-node has 2 data elements and a 4-node has 3 data elements.
06:50:43 <Stevo> sshine: sorry hold on
06:51:01 <benmachine> also
06:51:08 <Stevo> data Tree234 a = EmptyTree | TwoNode a  (Tree234 a) (Tree234 a) | ThreeNode a a (Tree234 a) (Tree234 a) (Tree234 a)| FourNode a a a (Tree234 a) (Tree234 a) (Tree234 a) (Tree234 a) deriving (Show, Read, Eq)
06:51:14 <benmachine> toRational would work in the place of realToFrac
06:51:22 <Stevo> sshine:data Tree234 a = EmptyTree | TwoNode a  (Tree234 a) (Tree234 a) | ThreeNode a a (Tree234 a) (Tree234 a) (Tree234 a)| FourNode a a a (Tree234 a) (Tree234 a) (Tree234 a) (Tree234 a) deriving (Show, Read, Eq)
06:51:29 <sshine> Stevo, you don't need to paste it twice.
06:52:01 <sshine> Stevo, try and make the singleton function using the TwoNode constructor.
06:52:22 <aadrake> Question: Have any of you used Haskell for analysis of large data sets in mongodb?
06:53:33 <Stevo> sshine: yeah i think i just needed to be convinced out of the fournode cause logically in one way it made sense to me to start of with it
06:54:24 <Stevo> sshine: so data Tree234 a = EmptyTree | TwoNode a  (Tree234 a) (Tree234 a) | ThreeNode a a (Tree234 a) (Tree234 a) (Tree234 a)| FourNode a a a (Tree234 a) (Tree234 a) (Tree234 a) (Tree234 a) deriving (Show, Read, Eq)    singleton :: a -> Tree234 a singleton x = TwoNode x EmptyTree EmptyTree
06:55:21 <quicksilver> aadrake: I would say the answer is no, from the lack of (useful ) answers you received last time.
06:59:27 <aadrake> quicksilver: Thank you.
07:00:34 <Melvar> I just had the stupid idea of an IO action that retrieves the entire filesystem lazily.
07:01:39 <sshine> Melvar, so that you can access directories and files using IO-wrapped data structures?
07:02:15 <int-e> oh it's not that stupid ... you'll run out of file handles very soon and memory usage may become and issue, but theoretically, there's no objection to the idea
07:03:19 <int-e> (well. the theoretical objection that I can think of is that the FS is not quite constant data. but traversing an immutable snapshot that way seems entirely reasonable)
07:06:59 <mellum> So, if I have a function like f x = if x == 1 then 2 else 3 that starts with an "if", and I try to prepend an assert, I get a syntax error. Is there any trick that avoids this without putting braces around the if?
07:07:36 <Jafet> Yes, but you'll need $$$
07:07:47 <sshine> :t $$$
07:07:48 <lambdabot> parse error on input `$$$'
07:08:17 <sshine> @find ($$$)
07:08:18 <lambdabot> Not in scope: type variable `$$$'
07:08:35 <jessopher> maybe just $
07:08:42 <mellum> how would I use that?
07:10:45 <Saizan> f x = assert (...) $ if x == 1 then 2 else 3
07:11:36 <Stevo> sshine: right on my insert method then should i be creating extra functions to handle the other Nodes or could i handle them using guards?
07:11:47 <mellum> Saizan: ah, thanks.
07:18:16 <VHD> is "f1 ( f2 . f3) . f4" equal to "(f1 (f2 . f3)) . f4" or "f1 ((f2 .  f3) . f4)"?
07:18:58 <benmachine> VHD: the former
07:19:16 <benmachine> VHD: function application always comes first
07:19:20 <VHD> thank you
07:19:55 <VHD> i see
07:20:47 <VHD> hmm
07:21:04 <VHD> f1 f2 . f3, they are all functions so how would that get evaluated?
07:21:52 <Stevo> is there anyway i can phrase a function that checks to see if a node has all it's elements filled already?
07:24:06 <VHD> oh so it would be (f1 f2) . f3
07:24:37 <VHD> if I am to assume . is an infix operator, but that just further confuses as I thought it was just a function
07:25:06 <VHD> actually, are infix operators not just functions that take two values?
07:25:08 <wereHamster> infix operators are also just functions
07:25:09 <mauke> VHD: that's like saying, "oh, pi is a constant? I thought it was a number"
07:25:24 <mauke> "operator" is a syntactic property
07:25:32 <VHD> ok, in that sense I am in no way understanding how precedence works
07:26:06 <VHD> "Function application has higher precedence than any infix operator, and thus the right-hand side of the second equation parses as (f x) : (map f xs)"
07:26:13 <VHD> ^ is from the haskell tut on functions
07:26:14 <mauke> right
07:27:05 <VHD> or is it simply, infix functions have lower precedence
07:27:14 <mauke> what's an "infix function"?
07:27:30 <VHD> (+) <- this?
07:27:42 <mauke> ok, but I call it an operator
07:27:44 <VHD> function which allows argument on the left and right.
07:27:58 <mauke> you're using the word "function" in a weird way
07:28:19 <VHD> ok, function is something which takes arguments and outputs a value.
07:28:22 <cheater> yeah the usual thing to say is "infix operator"
07:28:24 <VHD> am I wrong there?
07:28:38 <srhb> That is right, in the most general sense.
07:28:41 <mauke> a function is a type of value
07:28:50 <cheater> a function is a mixfix operator where the one and only keyword is to the left of all arguments
07:29:03 <mauke> cheater: what
07:29:03 <cheater> you can't have an infix function.
07:29:26 <cheater> mauke: psyduck!!
07:29:46 <Saizan> anyhow, infix application, be it of an operator (i.e. those with a name made of symbols) or a prefix function used infix e.g. `f`, has lower precedence than prefix application
07:30:13 <VHD> ah ok
07:33:20 <mellum> can I somehow have a match case that matches [1, x] and [1], and in the latter case I have x=0 in the case body
07:33:43 <roconnor> scooty-puff: eh?
07:36:29 <scooty-puff> roconnor: right, so mauke had detailed a means i could use to handle type inference with function recursion (including mutual recursion)
07:36:44 <scooty-puff> the wikipedia article on the hindely-milner type system detailed some of this too
07:37:08 <scooty-puff> i was wondering if you knew if ghc did something comparable - a fixed point combinator or special REC inference rule
07:37:09 <roconnor> polymorphic recursion?
07:37:22 <Saizan> mellum: you can write f [1,x] = Just x; f [1] = Just 0; f _ = Nothing and then match on f xs instead of xs
07:37:29 <scooty-puff> no, just function recursion (this is for something i'm doing - not a real language or antyhing)
07:37:58 <scooty-puff> i wasn't sure if ghc explicitly used a fixed point combinator, or used some other shortcut
07:37:59 <Saizan> scooty-puff: i think you don't have to do much, just add the identifier to the context when you typecheck its body
07:38:05 <mellum> Saizan: Hmm, okay
07:38:40 <roconnor> scooty-puff: I don't know how GHC does it
07:42:21 <Saizan> type(C,let(X = E0,E1),T) :- type([X:mono(A)|C],E0,A),type([X:poly(C,A)|C],E1,T). -- how i do it in prolog :P
07:43:30 <Saizan> poly(C,A) means that you have to generalize A wrt the vars not appearing in C
08:01:36 <wunki> other people get the "Can't find the prompt" error in Emacs 24 with "haskell-mode" ?
08:02:50 * hackagebot sparsecheck 0.1.0.1 - A Logic Programming Library for Test-Data Generation  http://hackage.haskell.org/package/sparsecheck-0.1.0.1 (KidoTakahiro)
08:09:34 <hpaste> Gothmog_ pasted “Problem with parser alternatives” at http://hpaste.org/55190
08:12:19 <jessopher> Gothmog_: are you dead set on parsec?
08:12:22 <ique> Hey, I have a `Action IO (Maybe a)` that I get back from reading from a database, how can I unpack that to a Maybe a without using do notation?
08:12:45 <Gothmog_> jessopher: Hm, nope, I could rewrite the module, it's not too large...
08:12:51 <kmc> ique, the "do" notation is just syntactic sugar for the (>>=) operator
08:13:09 <Gothmog_> But it would mean rewriting it, of course. :)
08:13:19 <kmc> http://haskell.org/haskellwiki/FAQ#How_do_I_convert_IO_Int_to_Int.3F  http://haskell.org/haskellwiki/Introduction_to_IO
08:13:35 <EvanR-work> :t unsafePerformIO
08:13:36 <lambdabot> Not in scope: `unsafePerformIO'
08:15:59 <kmc> :t (>>=)
08:16:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:16:08 <kmc> this is kind of a crazy type, but you can use it as e.g.
08:16:12 <kmc> (>>=) :: IO a -> (a -> IO b) -> IO b
08:16:21 <kmc> or if your "Action" thing is what I think it is,
08:16:29 <kmc> (>>=) :: Action a -> (a -> Action b) -> Action b
08:16:43 <jessopher> Gothmog_: could you paste the individual parsers, and what you have for the combined parser?
08:16:46 <kmc> of course whatever library is providing "Action" might also provide a way to extract results directly, but I doubt it
08:16:52 <Gothmog_> jessopher: Yes, sure.
08:16:58 <Gothmog_> Just a sec.
08:17:50 * hackagebot sparsecheck 0.1.0.2 - A Logic Programming Library for Test-Data Generation  http://hackage.haskell.org/package/sparsecheck-0.1.0.2 (KidoTakahiro)
08:17:58 <ique> kmc: thanks
08:19:20 <kmc> er, that would be  Action IO a -> (a -> Action IO b) -> Action IO b
08:19:36 <kmc> more specifically  Action IO (Maybe a) -> (Maybe a -> Action IO b) -> Action IO b
08:20:02 <hpaste> Gothmog_ pasted “Parser source” at http://hpaste.org/55191
08:20:02 <ique> kmc: yeah.. i think I have to break up my code a little bit into more separate pieces and I think I'll see more clearly what's happening and what to do
08:20:28 <kmc> cool, that usually helps :)
08:20:28 <Gothmog_> jessopher: There you go.
08:21:10 <Gothmog_> jessopher: I can paste some example file to parse, too, if that helps.
08:25:13 <hpaste> andsens pasted “Ambiguous type” at http://hpaste.org/55192
08:25:37 <andsens> ^^^ I don't get it. Hav stared at this error for quite a while now...
08:27:02 <Lemmih> andsens: What do you think the type of 'test' is?
08:27:15 <jessopher> Gothmog_: you could create a data type with constructor for each of the 'line types', so you could use logical parser combinators, this would require a rewrite of the sub-parsers though
08:27:20 <andsens> a -> IO ()
08:27:27 <andsens> Where a is Queue
08:27:46 <Lemmih> andsens: That won't fly. It has to have a concrete type.
08:28:00 <Lemmih> andsens: Tell it what 'a' is and the error will go away.
08:28:06 <kmc> andsens, the type you give for queueList is wrong.  it says, for any Queue type 'a', that queueList has type [(String, a)]
08:28:15 <Gothmog_> jessopher: Something along: data Combined = Card ... | Seller ... | Offer ...?
08:28:23 <jessopher> Gothmog_:  right
08:28:27 <Gothmog_> That's a good idea. Thanks!
08:28:28 <kmc> andsens, but you defined it using SQ.empty, so it can't be that geveral
08:28:51 <andsens> kmc: But it will have other queues as well..?
08:28:57 <kmc> yeah
08:29:10 <kmc> meaning it's a heterogeneous list
08:29:17 <andsens> ......
08:29:20 <kmc> which is not allowed
08:29:21 <andsens> ah crap
08:29:31 <andsens> of course
08:29:36 <kmc> andsens, to write a list of queues of varying types you would need the ExistentialQuantification extension.  but i think what you really want to do is rethink, and probably simplify this design
08:29:42 <andsens> You can't have a list for Enum either....
08:30:04 <EvanR-work> you can have a list of any given Enum type
08:30:11 <kmc> it is very common that people come in here mired in a design full of types and type classes and fancy extensions
08:30:12 <EvanR-work> [True,False,False,True]
08:30:16 <kmc> and usually there's a simpler way to do it
08:30:43 <kmc> maybe not
08:31:02 <andsens> heh
08:31:14 <andsens> guards… I guess.
08:34:23 * jessopher gives some perversion of that file tree IO idea a shot
08:35:46 <andsens> How do I make the return type of a function concrete?
08:36:31 <Gothmog_> andsens: If you return "expr", you could write expr :: type instead
08:36:31 <dolio> Use a type annotation?
08:37:01 <andsens> in parentheses?
08:37:25 <andsens> Like so:test (create :: Type)
08:37:59 <andsens> What I mean is. can I use it as an argument in the same line
08:38:57 <jessopher> you can
08:39:09 <andsens> kewl
08:41:24 <quicksilver> jessopher: like this  http://www.haskell.org/pipermail/haskell-cafe/2010-August/081808.html
08:41:28 <quicksilver> ?
08:41:49 <quicksilver> (note the criticisms int he discussion ;)
08:42:29 * jessopher reads
08:47:43 <jessopher> Yeah, laziness for the whole tree seems like nonsense. there would have to be some mechanism to request atomic access to the tree while its being read/written to
08:48:36 <jessopher> im not really that interested in the laziness as much as I am working with a whole subsection of the filesystem at once
08:56:00 <rtharper> anyone had problems building uuagc?
08:56:15 <rtharper> I cna't seem to get the cabal package to even attempt building
08:56:29 <rtharper> it just prints "127" and quits
08:57:08 <parcs> @where y-combinator
08:57:08 <lambdabot> I know nothing about y-combinator.
09:06:39 <Zarathu> > 5 + 2
09:06:40 <lambdabot>   7
09:07:15 <EvanR-work> > Product 5 ++ Product 2
09:07:19 <lambdabot>   mueval-core: Time limit exceeded
09:15:05 <copumpkin> > Product 5 ++ Product 2
09:15:07 <lambdabot>   Product {getProduct = 10}
09:15:22 <copumpkin> EvanR-work: she doesn't like you
09:15:29 <EvanR-work> bitch
09:21:38 <copumpkin> preflex: seen bos
09:21:38 <preflex>  bos was last seen on #haskell 9 days, 22 hours, 49 minutes and 44 seconds ago, saying: KirinDave: it's in a horrible state of sin, to be more accurate.
09:21:47 <copumpkin> wow, the mystery of the missing bos!
09:22:03 <copumpkin> I hope Facebook hasn't pulled a Standard Chartered on bos
09:24:37 <carpi> could someone plese tell me the difference between newtype and data?
09:24:54 <quicksilver> copumpkin: they's in ur bos killin' ur open source productivity!
09:25:09 <quicksilver> carpi: newtype can only have a single constructor with a single field
09:25:13 <quicksilver> but has no runtime cost.
09:25:16 <parcs> carpi: google can :P
09:25:22 <quicksilver> and it doesn't generate a new _|_.
09:25:32 <carpi> _|_?
09:25:44 <quicksilver> a new kind of undefined.
09:25:59 <quicksilver> if you don't recognise the symbol I wouldn't worry it's probably not an important part of the answer.
09:26:06 <quicksilver> the other bits were the important parts.
09:26:14 <quicksilver> Also (in GHC) newtypes have special deriving code which is handy.
09:26:52 <carpi> so the reason for having newtype are purely for speed while pattern matching?
09:27:14 <c_wraith> if you mean "as opposed to data", yes.
09:27:23 <c_wraith> if you mean "as opposed to not doing anything", then no.
09:27:31 <parcs> all wrapping/unwrapping of a newtype is compiled away, however the type checker still distinguishes between a newtype and the type that it wraps
09:28:06 <parcs> @src Product
09:28:06 <lambdabot> Source not found. Are you on drugs?
09:28:07 <monochrom> "A New Kind of Undefined" sounds like Wolfram's sequel book :)
09:28:36 <parcs> newtype Product a = Product {getProduct :: a}
09:28:47 <parcs> > case undefined of Product _ -> ()
09:28:48 <lambdabot>   ()
09:28:57 <quicksilver> carpi: another reason is to define different typeclass instances
09:28:58 <parcs> @src Maybe
09:28:58 <lambdabot> data Maybe a = Nothing | Just a
09:29:04 <parcs> > case undefined of Just _ -> ()
09:29:05 <lambdabot>   *Exception: Prelude.undefined
09:29:13 <quicksilver> or, more generally, just to distinguish between two types with teh same representation which mean something different.
09:29:14 <EvanR-work> quicksilver: which you can use data for
09:29:31 <carpi> but it can have more than one type parameter?
09:29:31 <quicksilver> yes.
09:29:51 <parcs> more than one type parameter yes. more than one field no
09:30:49 <carpi> the reason i ask is.. because most haskell code ive come across so far seem to prefer newtype more than data.. or maybe i just saw that kind of code
09:31:43 <parcs> when you have tho choice between newtype and data you should use newtype
09:33:36 <c_wraith> Unless the extra bottom is important.
09:33:47 <quicksilver> yes, newtype is almost invariably better if you only need a single constructor with a single field.
09:33:59 <c_wraith> There's a reason Par from monad-par is defined as data
09:34:37 <EvanR-work> its kind of annoying that the programmer has to make a distinction for performance reasons, seems like C 'volatile' to me
09:34:48 <parcs> carpi: read this also: http://www.haskell.org/haskellwiki/Newtype
09:35:04 <EvanR-work> if it werent for the differing bottom behavior, wouldnt the compiler be able to newtype for you when appropriate
09:35:16 <c_wraith> EvanR-work: really, you should choose based on semantics.
09:35:21 <parcs> EvanR-work: it's not for performance reasons, it's for semantic reason
09:35:45 <EvanR-work> besides bottom, how do the semantics differ?
09:35:52 <EvanR-work> data and newtype are both 'new types'
09:35:54 <c_wraith> EvanR-work: that bottom is *really* important.
09:36:00 <donri> newtype also lets you derive any of the instances of the wrapped type with a ghc ext
09:36:27 <EvanR-work> poo on that extension if it doesnt work for newtype-like data
09:36:39 <copumpkin> EvanR-work: but that's different
09:36:48 <copumpkin> you can have an additional nonterminating computation in it
09:37:02 <EvanR-work> yeah.
09:37:20 <EvanR-work> feels like a step toward assembly language is all
09:37:50 <c_wraith> Oh, heh.  Par got CPS-transformed.  it's a newtype after that
09:38:22 <c_wraith> Looks like the version as published in the paper never was on hackage
09:41:33 <carpi> parcs: thankx for link )
09:46:49 <copumpkin> EvanR-work: yeah, I'm not a huge fan of the distinction but I don't see any real way around it. There's a semantic difference and ghc can't figure out what you want :/
09:47:37 <EvanR-work> copumpkin: that being said, the 'difference' explained to noobs should then be able the bottom thing, rather than 'performance boost'
09:47:45 <EvanR-work> s/able/about/
09:47:49 <copumpkin> yeah
09:49:07 <EvanR-work> > isJust (Just undefined)
09:49:08 <lambdabot>   True
09:49:25 <EvanR-work> > isSum (Sum undefined)
09:49:26 <lambdabot>   Not in scope: `isSum'
09:49:40 <quicksilver> that would be deceptive wouldn't it?
09:50:00 <EvanR-work> i meant to say, the main difference
09:50:03 <quicksilver> in the majority of cases newtype is chosen, it's chosen for performance reasons, or for the convenience of GeneralizedNewtypeDeriving
09:50:11 <quicksilver> not because of the semantic difference.
09:50:25 <quicksilver> it's sufficientlly idiomatic that it can also be said to be making your intention clear
09:50:36 <EvanR-work> ok then its a self fulfilling loss of language dignity ;)
09:50:44 <quicksilver> using a newtype is a way of sayng "this type is implemented just like that type, but they are different"
09:51:17 <EvanR-work> that sounds like a third reason
09:51:50 <EvanR-work> that might be a good main reason
09:53:13 <EvanR-work> so with generalized newtype deriving i can make a bunch of different mutually exclusive Integer types, with no performance penalty?
09:53:35 <EvanR-work> type checker will stop me from mixing them
09:53:43 <c_wraith> You don't need that extension to do so...  It just makes it easy
09:53:46 <QUADRESSMASTER> Anyone here knows anything about liskell?
09:53:50 <EvanR-work> yeah, easy
09:53:53 <QUADRESSMASTER> EvanR-work, darling, long time no seen
09:54:01 <EvanR-work> i dont know you
09:54:07 <c_wraith> but yeah, if you derive Num, that does basically everything
09:54:13 <QUADRESSMASTER> EvanR-work, remember 'Lajla'?
09:54:18 <QUADRESSMASTER> You do remember don't you?
09:54:26 <EvanR-work> if you want people to remember you why do you change your nickname
09:54:41 <QUADRESSMASTER> Dunno, I change it about every 30 minutes if I'm not idling
09:54:49 <QUADRESSMASTER> I more see it as an intersting field where I can input random characters
09:55:49 <EvanR-work> c_wraith: i wonder if 'custom' numbers like that have the same performance as ghc built in stuff?
09:56:13 <c_wraith> EvanR-work: after typechecking, they're identical to the unwrapped versions
09:56:47 <quicksilver> c_wraith: I'm not sure RULES always fire correctly through newtypes.
09:56:49 <quicksilver> maybe they do.
09:56:51 <EvanR-work> right but i have an unsubstantiated feeling that Integer doesnt literally have a Num instance written somewhere in the standard lib
09:57:19 <c_wraith> quicksilver: hmm, that's probably true.  and might even matter, for something like fromIntegral
09:58:50 <rwbarton> EvanR-work: not in the "standard lib" I guess, but in GHC.Num there really is one
09:59:10 <rwbarton> instance Num Integer where (+) = plusInteger; -- etc.
09:59:11 <monochrom> "data" declares another data structure. "newtype" declares another type but the same data structure.
09:59:39 <EvanR-work> data COULD declare the same data structure
09:59:46 <EvanR-work> not necessarily another
10:01:19 <monochrom> well then, my "same" is not the same as yours. my "same" does not include "isomorphic". "data" declares another data structure, maybe isomorphic to an existing one but not the same.
10:01:47 <EvanR-work> newtype doesnt make an isomorphic ?
10:01:53 <monochrom> in the very same sense that "newtype" declares another type, not "could be the same type".
10:02:35 <EvanR-work> dont think the simple rule cuts in the right place
10:02:56 <monochrom> after unwrapping the newtype, you get back the same data structure, and it's my sense of "same"
10:03:12 <benmachine> I think monochrom's original statement is nice; I'd say that data declares another data structure that is sometimes the same
10:03:14 <EvanR-work> that could be true of data
10:03:23 <EvanR-work> benmachine: yes
10:03:24 <monochrom> whereas if you "data E a b = L a | R b" you don't even have an unwrap to Either.
10:03:37 <EvanR-work> no but in another example you could
10:03:51 <benmachine> monochrom: data E a b = E { unE :: Either a b } does
10:04:39 <monochrom> yours has an extra bottom. different data structure. your unwrap is not an isomorphism.
10:05:13 <benmachine> monochrom: this does not align with what you said earlier about how "data" declares a possibly-isomorphic structure
10:05:35 <applicative> newtype doesn't add an extra bottom?  I cant remember how that works.
10:05:37 <monochrom> "data E a b = L a | R b" declares a data structure isomorphic to Either
10:05:49 <monochrom> newtype doesn't add an extra bottom.
10:06:08 <benmachine> monochrom: okay, well, fair enough, but I think the general consensus is that the extra bottom is not important in most uses of newtype
10:06:17 <benmachine> so it's not that interesting as an explanation
10:06:28 <benmachine> well I say the general consensus
10:06:31 <benmachine> that's presumptious of me
10:06:37 <EvanR-work> why would you say that Data E a b = E (Either a b) isnt isomorphic ;)
10:06:54 <benmachine> but that's the impression I got from EvanR and quicksilver (and myself)
10:07:22 <benmachine> EvanR-work: because E has more values than Either
10:07:26 <EvanR-work> i think its important but i think the 'this is a newtype with the same implementation as something' is a better reason
10:07:32 <benmachine> yes
10:07:42 <monochrom> map E ⊥ to which value of Either?
10:07:57 <EvanR-work> ok nvm
10:08:01 <benmachine> well, I mean, it's not important in the sense that I imagine if tomorrow GHC started compiling "newtype" as "data", not many programs would break
10:08:58 <EvanR-work> its important in the same sense as 'if you go into ##c and say char is implemented as a 8 bit byte, youll get torn a new one'
10:09:35 <DrSyzygy> EvanR-work: But! But! If you do that, all your C programs will still work!
10:09:42 <EvanR-work> lol
10:09:54 <DrSyzygy> And if we assume that all C semantics is dictated by observations from gcc, we can keep on going for decades.
10:10:17 <DrSyzygy> Until your software system gets ported to run on a cray, and you realize just WHY the standard says undefined.
10:10:25 <DrSyzygy> (true story -- I'm in the middle of this right now ;-)
10:10:51 <DrSyzygy> turns out gcc and craycc implement different semantics with shifts and sign bits.
10:11:16 <EvanR-work> so yeah, its very important  ;)
10:11:21 <EvanR-work> in some sense
10:15:09 <monochrom> most uses of newtype are FFI (e.g., CInt) and alternative instances. without an extra bottom you gain both easier reasoning (one fewer corner case) and efficiency. not having an extra bottom is important.
10:18:39 <kmc> i disagree about "most uses of newtype"
10:19:30 <rwbarton> "most uses of newtype" for whatever reason makes me think of mtl
10:19:33 <kmc> the general point of newtype is «newtype Gold = Gold Int;  newtype HitPoints = HitPoints Int»
10:19:47 <kmc> now you can't add someone's gold to their hitpoints by accident
10:20:02 <kmc> yet you lose no efficiency vs. storing them both as raw Int
10:20:28 <monochrom> efficiency is when compared to data G = G Int
10:20:39 <applicative> what is the function for showing numbers in different bases, I can't find it
10:20:45 <kmc> :t showIntAtBase
10:20:46 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
10:20:55 <applicative> ah, I missed the Int part
10:21:51 <mm_freak_> Sgeo: netwire 3 actually, but it's not finished yet
10:22:24 <mm_freak_> it should give you an introduction though, so in the worst case you can help yourself by reading the haddocks
10:30:00 <monochrom> well, I guess next time I will say ""data" declares an algebraic datatype, "newtype" declares renamed datatypes", straight from Haskell 2010. (if only a beginner knows what that means)
10:31:28 <donri> that's easily confused for type synonyms by beginners
10:31:39 <carpi> how do we distinguish between bytestrings and strings? they seem to have the same representation..
10:31:40 <donri> the subtle difference between renaming and aliasing
10:31:53 <donri> carpi: they're different types
10:32:04 <monochrom> they have different representations
10:32:39 <carpi> donri: yes.. but in ghci.. they both seem to be represented in between quotes " "
10:32:44 <monochrom> but since representations are not easily observable, I don't understand why "distinguish" and "representation" are in the same sentence.
10:32:46 <donri> carpi: :t
10:33:04 <monochrom> ghci does not tell you representations. emphatically.
10:33:37 <monochrom> all it does is tells you what the author has chosen the Show instances to do
10:33:38 <donri> carpi means that their show is the same
10:33:53 <monochrom> > id
10:33:54 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
10:33:54 <lambdabot>    arising from a use of `...
10:34:11 <monochrom> > getLine
10:34:12 <lambdabot>   <IO [Char]>
10:34:38 <monochrom> don't tell me that lambdabot tells you that getLine has the same representation as <IO [Char]>
10:35:11 <donri> monochrom: carpi might be used to non-haskell terminology e.g. repr() in python
10:35:46 <carpi> i think that is what i was referring to..which is obviously wrong. my apologies
10:36:12 <carpi> maybe i should have said "notation"..
10:36:12 <donri> you want something like "show instance" in place of "representation"
10:36:18 <monochrom> but he/she is obviously not entering a command like ":repr x" into ghci
10:36:23 <carpi> notation sounds more wrong
10:36:46 <donri> monochrom: the value of expressions are automatically show'd in ghci
10:36:58 <gtirloni> there's an "type String = [Char]" in the Prelude.. how is the representation different ([Char] vs. String) ?
10:37:18 <donri> carpi: "show" isn't necessarily the inverse of "read"; that is, it isn't always valid haskell code for producing that value
10:37:20 <monochrom> even in python, if you don't explicitly ask for "repr" you don't always get it
10:37:21 <shachaf> gtirloni: It's a type synonym.
10:37:29 <shachaf> gtirloni: Any time you type what, you could type the other.
10:37:40 <donri> monochrom: in the interactive shell you do
10:37:46 <gtirloni> indeed.. so lambdabot is not so wrong to say getLine :: IO [Char]
10:37:47 <gtirloni> is it?
10:38:11 <shachaf> lambdabot didn't actually say getLine :: IO [Char]. But, yes, that's not wrong. :-)
10:38:18 <keep_learning> kmc, great explanation but if we write data Gold = Gold Int ; data HitPoints = HitPoints Int then we can't also add both.
10:38:44 <keep_learning> kmc, so what is the difference between data and newtype ?
10:39:03 <quicksilver> that would be fine, to be honest.
10:39:18 <quicksilver> it's just that newtype declares your intentions idiomatically and is more efficient.
10:39:32 <quicksilver> and (in GHC) it will optionally write the Num instance for you.
10:39:53 <shachaf> quicksilver: And it has different strictness behaviour.
10:40:47 <kmc> the names are unfortunate, because 'newtype' is much closer to 'data' than to 'type'
10:41:17 <kmc> it's so named because it's a design alternative to 'type' in certain use cases
10:41:22 <keep_learning> quicksilver, we should try to use as much  newtype for efficiency ?
10:41:24 <shachaf> Well, it *is* like type, except that it makes a new type.
10:41:27 <gtirloni> the classtype instances being written automagically is pretty cool
10:41:31 <kmc> but i think things should be named after what they are, and not by analogy
10:42:20 <donri> not that magic
10:42:48 <donri> since you're just wrapping one type, you just defer to that type's instance
10:43:00 <kmc> shachaf, ;P
10:43:58 <quicksilver> shachaf: yes, we've been round this argument twice in the last 20 minutes
10:44:23 <quicksilver> shachaf: :) the strictness / extra _|_ are interesting but in practice (in my opinion) not actually the reason for the choice.
10:44:59 <kmc> the strictness is probably not a big deal by itself, but i suspect there are cases where it enables major optimization
10:45:30 <quicksilver> isn't that optmisation subsumed by the 'representation same as underlying type' optimisation?
10:45:46 <kmc> that's what i mean
10:46:15 <cheater> kmc: so i bet there would be a lot of use for being able to suspend the GC in haskell, and do manual memory mgmt
10:46:20 <monochrom> "no optimization without representation"
10:47:21 <donri> newtype is tax exempt?
10:52:04 <EvanR-work> starve the beast
10:53:43 <donri> spoil the child processes
11:03:12 <carpi> one the packages im using from hackage allows me to pass either strict or lazy bytestrings to its functions. The haskell doc for bytestrings only mentions that bytestrings make use of strict Word8 arrays. I was wondering if there was a seperate doc for lazy and strict bytestrings?
11:03:57 <mauke> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring
11:05:05 <hpaste> keep_learning pasted “Parallel Matrix Multiplication” at http://hpaste.org/55196
11:05:25 <keep_learning> hello all
11:05:51 <keep_learning> I wrote matrix multiplication using par and pseq and would like to hear your comments.
11:06:04 <kmc> carpi, they are separate modules in the 'bytestring' package; you can find the docs on hackage
11:06:33 <carpi> mauke: ah snap.. i was looking at the top level of the byteString doc. thanks
11:07:50 <kmc> carpi, the lazy bytestrings also make use of strict Word8 arrays
11:08:02 <hpaste> keep_learning annotated “Parallel Matrix Multiplication” with “Parallel Matrix Multiplication (annotation)” at http://hpaste.org/55196#a55197
11:08:08 <kmc> carpi, they are lists of chunks, and each chunk is a strict Word8 array
11:09:55 <carpi> ah .. so its like half lazy.. so the components of the chunks are strict but not the chunk itself..
11:10:01 <carpi> or is it the other way around
11:10:20 <kmc> a lazy bytestring is basically a list of strict bytestrings
11:10:38 <DukeDave> So: "Because it was not possible to use C++ directly from these languages an interfacing layer was written in C"
11:10:42 <DukeDave> Is this true?
11:10:47 <kmc> DukeDave, context?
11:10:48 <DukeDave> Ref: http://wxc.sourceforge.net/
11:10:58 <DukeDave> kmc: ^
11:11:18 <kmc> it is hard to call C++ directly from most languages, yes
11:11:23 <kmc> including C++
11:11:23 * DukeDave has been working on wxhaskell for a while, and just now thought "wha?"
11:11:45 <kmc> (by which I mean, it is hard to call between C++ libraries compiled by different compilers)
11:11:57 <DukeDave> Ah
11:11:59 <kmc> C++ ABIs are much less standardized
11:12:12 <kmc> and there's nothing on the Haskell side to help you generate C++-compatible imports
11:12:19 <DukeDave> I didn't think about all that woe
11:12:22 <DukeDave> I see
11:13:13 <DukeDave> Up until now I've just been cargo-cult-esque-ly adding wrappers
11:15:37 <kmc> wxhaskell calls wx's C++ API directly
11:15:37 <kmc> ?
11:16:55 <rfm47> hehe, in #snapframework:  <etabot> carpi is talking about snap in #haskell: mauke: ah snap.. i was looking at the top level of the byteString doc. thanks
11:17:01 <Duffman-> Hello, I'm new here and fairly new to Haskell. Does any of you guys have a few minutes for me?
11:17:24 <kmc> just ask
11:17:28 <donri> Duffman-: better just state your quesiton
11:17:33 <Duffman-> k
11:18:07 <Duffman-> I'm reading the book learn you a haskell for great good and I'm looking at the applicative functors
11:18:19 <Duffman-> now in the book it says f <$> x = fmap f x
11:18:35 <kmc> correct
11:18:39 <kmc> (<$>) = fmap, more concisely
11:18:39 <Duffman-> however when I try this in my GHCI, I get an error
11:18:44 <Duffman-> I'm gonna c/p
11:18:52 <kmc> if you have more than a few lines, use hpaste.org
11:18:54 <Duffman-> fmap (++) Just "johntra" <*> Just "volta"
11:19:30 <Duffman-> giving me this error
11:19:31 <Duffman->     Couldn't match expected type `a0 -> b0' with actual type `[a1]'
11:19:31 <Duffman->     Expected type: [a1] -> [a1] -> a0 -> b0
11:19:31 <Duffman->       Actual type: [a1] -> [a1] -> [a1]
11:19:31 <Duffman->     In the first argument of `fmap', namely `(++)'
11:19:31 <Duffman->     In the first argument of `(<*>)', namely
11:19:31 <Duffman->       `(fmap (++) Just "johntra")'
11:19:42 <kmc> that's more than a few lines
11:19:45 <c_wraith> it's not parsing the way you think.
11:19:50 <kmc> > fmap (++) (Just "johntra") <*> Just "volta"
11:19:52 <lambdabot>   Just "johntravolta"
11:19:53 <Duffman-> ok
11:20:03 <Duffman-> I'll go to hpaste
11:20:13 <c_wraith> the common way to do that would be
11:20:28 <kmc> Duffman-, function-application syntax always binds tighter than infix operators
11:20:32 <c_wraith> > (++) <$> Just "johntr" <*> Just "volta"
11:20:33 <lambdabot>   Just "johntrvolta"
11:20:38 <kissyboy> seems like that's an error on the site
11:20:54 <kmc> so c_wraith's expression parses as   (++) <$> (Just "johntr") <*> (Just "volta")
11:21:04 <kissyboy> oh wait it's not
11:21:07 <kmc> hence  fmap (++) (Just "johntra") <*> Just "volta"
11:21:19 <kmc> (to derive that you also need to know the associativity of <*> and <$>)
11:21:24 <kissyboy> o nthe site the code example is (++) <$> Just "johntra" <*> Just "volta"
11:21:26 <kmc> (the precedence level, i mean)
11:21:29 <Duffman-> so ghci sees just, "johntra", <*>, Just, and "volta" as seperate arguments?
11:21:52 <monochrom> not that simple.
11:21:54 <Duffman-> if I do it my way
11:22:10 <kmc> it's like fmap is a 3-argument function taking (++), Just, and "johntra"
11:22:17 <kmc> (fmap (++) Just "johntra") <*> Just "volta"
11:22:29 <Duffman-> oh I see, I think )
11:22:29 <Duffman-> :)
11:22:30 <kmc> except that haskell doesn't really have 3-arg functions so it's
11:22:31 <monochrom> ghci sees (((fmap (++)) Just) "johntra") <*> (Just "volta")
11:22:35 <kmc> what monochrom said
11:22:53 <monochrom> always parenthesize fully
11:23:32 <Duffman-> thakns for the tip. I tried parenthesize the chunk of code after the <$>, but I think I see now what I did wrong
11:23:42 <Duffman-> paranthesizing*
11:26:13 <monochrom> I had a funny idea for operator precedence, although it is tangential to what we just said.
11:26:53 <dgpratt> does there exist any tool that is capable of auto-parenthesizing a Haskell expression? -- just so you could 'see' how precedence is determining evaluation order?
11:27:15 <kmc> you can parse it with haskell-src-exts and then dump the AST
11:27:30 <kmc> or maybe hse already has a pretty-printer which can leave the parens in
11:27:45 <dgpratt> kmc: hmm; interesting idea
11:28:10 <monochrom> precedence 9 operators look like +, *, etc. precendence 8 operators look like .+., .*., etc. precendence 7 operators look like ..+.., ..*.., etc. and so on for other precedences.
11:28:12 <kmc> that's not an existing tool but it's something one could write pretty easily
11:28:32 <c_wraith> mnoochrom: surely + and * aren't the same precedence
11:28:37 <c_wraith> err, monochrom
11:28:38 <kmc> heh
11:28:54 <kmc> i saw another funny idea for operator precedence, which is horizontal space sensitivity
11:29:01 <kmc> "x + y+z" = x+(y+z)
11:29:03 <c_wraith> I've seen that.
11:29:07 <kmc> "x+y + z" = (x+y)+z
11:29:10 <monochrom> right, in Prelude they have different precedences, but I'm proposing to make them all 9.
11:29:34 <monochrom> because if you want precedence-6 addition, you can write ...+...
11:29:38 <c_wraith> whitespace-sensitive makes sense for 2 levels, but it gets horribly unweildy for more
11:29:53 <c_wraith> ignore my inability to type today
11:30:00 <monochrom> and my idea is inspired by the whitespace version, yes.
11:30:08 <kmc> yeah, i see now
11:30:29 <opqdonut> I think fortress has that
11:30:30 <monochrom> I adapt " " to "." for Haskell legality.
11:31:18 <monochrom> so every operator can enjoy all precedence levels, and you can nominally claim that you seldom need parentheses in practice.
11:31:29 <c_wraith> hah.  as if fortress is ever that simple!
11:31:32 <kmc> i tend to write a lot of parentheses which are not necessary
11:31:34 <kmc> for clarity
11:32:53 <monochrom> I thought this up in response to a haskell-cafe question on how to have fewer parentheses. I intended this to be a mockery of the desire to have fewer parentheses. in fact I originally thought "$$$+$$$" rather than "...+..." for bigger sarcastic effect.
11:33:46 <monochrom> but I didn't post it. I saw the thread too late. would not want to add noise or sarcasm if not done in time
11:34:18 <monochrom> it is not funny to post a parody one week after the original question
11:34:35 <donri> timing: messing up comical effect since the dawn of uhm, time.
11:34:44 <monochrom> heh
11:38:31 <monochrom> my favourite editor MathSPad (http://www.cs.nott.ac.uk/~rcb/mathspad/) features proportional whitespace to hint at precedence too. but it can overriden. and it still features parentheses.
11:40:08 <monochrom> and it looks ok because the spacing is not done by a fixed-width font. it is done by pixels.
11:45:28 <aristid> monochrom: got screenshots?
11:45:50 <monochrom> no
11:46:32 <aristid> would you mind making some?
11:46:41 <monochrom> yes
11:47:04 <aristid> i know i asked in an ambiguous way :P
11:47:12 <monochrom> I mind.
11:47:58 <aristid> too bad, i was curious how mathspad would look and especially how it would do this spacing.
11:48:27 <aristid> and this also reminds me of a reason why this "cloud" stuff is important.
11:48:40 <monochrom> why cloud?
11:48:55 <hamster69> veit kimmel is gay
11:49:30 <aristid> monochrom: well, because if to see an application you only need to click on alink, that greatly diminishes the need for screenshots.
11:49:41 <aristid> monochrom: meanwhile compiling mathspad is a significant hurdle
11:49:58 <hamster69> whois monochrom
11:50:13 <monochrom> it actually doesn't compile since some version of gcc several years ago. but I have a patch to fix it.
11:50:24 --- mode: ChanServ set +o monochrom
11:50:28 <mauke> hamster69: hi
11:50:55 <hamster69> dye you motherfucka
11:51:04 --- mode: monochrom set +b *!*@gateway/web/freenode/ip.217.252.114.153
11:51:05 --- kick: hamster69 was kicked by monochrom (hamster69)
11:51:31 <monochrom> I concede. I will make a screenshot.
11:51:46 <aristid> thank you
11:55:26 <dp_> hio
11:56:08 <self> hamster69?
11:56:43 * ddarius always parses "mathspad" as "math spad."
12:04:23 <lukish> Trying ask again about ex 16 http://blog.tmorris.net/20-intermediate-haskell-exercises/
12:05:08 <Tom^2> Does anyone here have experience using the Render monad in Gtk2Hs? Specifically, I would like to know if it is possible to "get out" from render monad by any other way than using renderWithDrawable. I am calculating the dimensions of a path in render monad, and I would like to set the window size the same as the size of the graphics drawn in the IO monad before calling renderWithDrawable.
12:05:21 <lukish> If moppy is recursive. I get x::a from input (x:xs), get m b with it.
12:05:41 <lukish> But what should I do with xs to get m [b]
12:06:06 <lukish> Sorry, I am asking about ex14.
12:06:59 <mauke> lukish: call moppy on it
12:07:55 <mauke> wait, why do they want me to write sausage in terms of moppy?
12:08:04 <mauke> that seems backwards
12:08:24 <lukish> That's the point, maybe
12:09:00 <niklot_> hi all
12:09:17 <lukish> mauke: moppy (x:xs) f = banana f (unicorn x) ...?
12:09:27 <lukish> banana f (unicorn x) :: m b
12:09:31 <monochrom> aristid: http://www.vex.net/~trebla/tmp/mathspad.png  for this screenshot I set the spacing to be larger than what I normally use. operator precedence from highest to lowest is → × + = ∧
12:09:41 <mauke> moppy [] _ = unicorn []; moppy (x : xs) f = banana (\b -> ...{moppy xs f}...) (f x)
12:09:46 <mauke> is what I got so far
12:10:51 <dgpratt> hi lukish, I was wondering when you'd come back around with more questions
12:11:02 <dgpratt> I got stuck on that one, too
12:11:14 <dgpratt> Axman6 was able to help me through it
12:11:30 <rfm47> Tom^2, i think you need to render it to something to check
12:11:33 <ClaudiusMaximus> Tom^2: i'm sure it's possible, though i've not done it - you probably want to create a temporary surface and use renderWith to compute the size http://hackage.haskell.org/packages/archive/cairo/latest/doc/html/Graphics-Rendering-Cairo.html#t:Render
12:12:06 <aristid> monochrom: is spacing the only way it uses to indicate precedence?
12:12:13 <aristid> monochrom: or are parentheses also sometimes used?
12:12:52 <monochrom> it shows parentheses too. it would show "(a+a)×a"
12:13:08 <ddarius> monochrom is going to be tricked into responding even though what he says is clearly not being read.
12:13:27 <monochrom> and then, both can be overriden. you can force parentheses to appear or disappear. you can change spacing ad-hoc.
12:13:39 <aristid> ddarius: of course.
12:14:38 <aristid> monochrom: what's the input method like?
12:14:42 <lukish> mauke: why second argument to banana is (f x), not (unicorn x)?
12:15:17 <mauke> lukish: because that would set b to x
12:15:20 <Tom^2> ClaudiusMaximus: Actually to calculate the size of the path I am using the textExtentsWidth function, so I don't have to render the path to know the size. The problem is that in order to call that function from IO monad (where I set up the Gtk window), I need to lift somehow the result from Render monad to IO monad. And I don't know if it is possible to go that way.
12:15:21 <mauke> which is pointless
12:15:36 <TomMD> *point-free
12:15:50 <monochrom> the input story is not very nice. those operators are all user-defined, and they are listed in a side window, and you have to click for the operators, there is no provision for keyboard shortcut. you still use keyboard to enter variable names and text, of course.
12:15:55 <mauke> lukish: also because I need to turn x :: a into something :: b somehow
12:16:06 <mauke> lukish: and the only way to do that is to call f
12:16:31 <lukish> So b in \b has type ::b?
12:16:32 <aristid> monochrom: so it's more inspirational than practical.
12:16:56 <mauke> lukish: yes
12:17:07 <mauke> lukish: f x :: m b
12:17:22 <mauke> lukish: and banana :: (a -> m b) -> m a -> m b
12:17:26 <lukish> Yes
12:17:48 <mauke> the only confusing part here is that the 'b' in the first signature corresponds to the 'a' in the second signature
12:17:51 <ben> those exercises seem amusing
12:18:04 <mauke> so I'm going to rewrite that as banana :: (b -> m c) -> m b -> m c
12:18:28 <lukish> let's say than banana :: (x -> m y) -> m x -> m y
12:18:39 <mauke> banana (???) (f x) :: m c with f x :: m b and (...) :: b -> m c
12:18:45 <mauke> heh
12:18:51 <mauke> and I can't even keep ??? and ... straight
12:19:02 <mauke> anyway, the point is that banana's first argument is a function from b to m c
12:19:13 <mauke> and since I'm starting with \b -> ..., that means b :: b
12:22:26 <ClaudiusMaximus> Tom^2: oh, you want  liftIO :: IO a -> Render a  ?
12:22:57 <monochrom> clicking is not so bad because it is just one click for one operator (whereas MS Word etc goofs it because they first require several clicks for "flipping to the right page of symbols"). there are other orthogonal features that make up for it, so overall it is still more efficient than entering TeX by hand, e.g., it copy/cut/paste whole subexpression trees, it converts between a×(b+c) and a×b+a×c in one click.
12:23:23 <Tom^2> ClaudiusMaximus: Actually I would like to have the reverse liftRender :: Render a -> IO a
12:24:42 <clsmith> you know, when i was taught haskell they tried to explain types symbolically, but it makes much more sense to me, for a lot of functions, to see it as a kind of pipeline. Data.Function.on is a good example. it's sort of like a Y shape
12:25:33 <ClaudiusMaximus> Tom^2: mm, i guess maybe the best you can do is create a tiny surface and use renderWith ?
12:26:34 <lukish> Well
12:26:49 <lukish> flip moppy id looks like sausage
12:27:27 <mauke> :t flip mapM id
12:27:27 <lambdabot>     Couldn't match expected type `[a]' against inferred type `a1 -> a1'
12:27:28 <lambdabot>     In the second argument of `flip', namely `id'
12:27:28 <lambdabot>     In the expression: flip mapM id
12:27:34 <lukish> ex 14 have Diffuculty 7 or more, actually.
12:27:37 <mauke> oh, it's already flipped
12:27:40 <mauke> :t mapM id
12:27:41 <lambdabot> forall (m :: * -> *) b. (Monad m) => [m b] -> m [b]
12:27:46 <mauke> yep
12:27:59 * hackagebot fix-parser-simple 15320.3 - Simple fix-expression parser  http://hackage.haskell.org/package/fix-parser-simple-15320.3 (MatthewFarkasDyck)
12:28:47 <dgpratt> lukish: yeah, it was the only one I needed help with
12:28:48 <Tom^2> ClaudiusMaximus: I am starting to think that this is the only way to proceed. There seems to be no other function get from  (Render a) to (IO a) than renderWithDrawable in the Gtk2Hs API.
12:29:02 <monochrom> those are wicked version numbers, 15320.3 etc
12:29:17 <rfm47> Tom^2, i think that's kinda the point of the Render monad
12:29:23 <lukish> dgpratt: what about 19 and 20?
12:29:23 <mauke> lukish: the trick is that banana lets you get at the 'a' from any 'm a'
12:29:28 <mauke> repeat as required
12:29:43 <dgpratt> lukish: I found those relatively easy
12:30:00 <lukish> mauke: well, ok. Trying to use it.
12:30:22 <lukish> dgpratt: i've found 16-18 very easy
12:30:26 <ClaudiusMaximus> Tom^2: there's renderWith in cairo
12:31:17 <Tom^2> rfm47: I think I understand the point of the Render monad is to draw things to surface, but I think the other use is to measure the size of the stuff to be drawn. There should be a separate function for that, IMHO.
12:31:22 <dgpratt> lukish: I wouldn't say I found them *very* easy myself, but I was able to complete them on my own in a relatively short amount of time
12:32:04 <ClaudiusMaximus> Tom^2: looking at the source it might just be the way cairo works (create a surface, then create a cairo context for it) http://hackage.haskell.org/packages/archive/cairo/latest/doc/html/src/Graphics-Rendering-Cairo.html#renderWith
12:33:15 <rfm47> Tom^2, but in the cairo C api, the textextents function needs a drawing context.
12:34:41 <rfm47> that's why it's in the Render monad, if i'm not mistaken
12:36:52 <rfm47> if you want to measure textextents without rendering, you can use renderWithDrawable with some surface, do nothing but return the text extent, and then use that in your GTK calls before doing the visible render?
12:37:13 <Tom^2> rfm47 & ClaudiusMaximus: I was looking at the source myself, and I see that the idea is that Render monad hides the drawing context, so that you don't have to specify it when calling Cairo functions. What I would like to have is some way of executing stuff in the Render monad without actually rendering anything. Since all the measure functions are defined to return Render a as well...
12:39:09 <rfm47> Tom^2, if i'm reading it right, you just do your textExtents and no actual rendering in that Render action and it'll do what you want
12:39:20 <Tom^2> rfm2: You might be onto something. Who says that renderWitDrawable has to render anything :-)
12:39:48 <Tom^2> The name was confusing me...
12:40:16 <xplat> what happened to source links on hpaste?
12:40:59 <rfm47> yep.  for most use cases i think it's a good name.  :-)
12:42:03 <Tom^2> rfm47 and ClaudiusMaximus: Thanks for your help. I will probably use RenderWith to measure the size in any dummy surface, and then use renderWithDrawable to actually draw the thing.
12:44:59 <alshain> hi, I'm trying to read through Philip Wadler's paper on monads, but I'm not too proficient with the Syntax of Haskell (learning Scala atm) and I have a problem with page 7 where it says at the very top: m * \lambda a.n ---- * is defined as (*) :: M a -> (a -> M b) -> M b  --- I can't make sense of the lambda with the dot really, the lambdas that I have seen are like: \x -> x + x, but I can't see this form here. As for the dot: I know it as
12:48:30 <alshain> this is the paper I'm referring to: http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
12:48:56 <applicative> this is bind, no >>=
12:49:02 <applicative> ?
12:49:43 <rwbarton> \lambda a.n is a typical mathematical notation for Haskell's \a -> n
12:49:48 <applicative> @type return
12:49:49 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
12:50:05 <applicative> @type (>>=)
12:50:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:50:31 <alshain> rwbarton: I see, so a is never used in the expression n ?
12:50:55 <rwbarton> let me look at the specific use
12:51:12 <rwbarton> btw your message got cut off after "As for the dot: I know it as"
12:51:25 <alshain>  I
12:51:27 <alshain>                      know it as function composition, but I don't see how that is related to functions.
12:51:40 <applicative> m >>= \a -> exp
12:51:52 <rwbarton> well here 'n' is an expression in which 'a' is in scope
12:53:06 <niklot_> best beginner's learning resource?
12:53:06 <applicative> > [1,2,3] >>= (\x -> [4])
12:53:07 <lambdabot>   [4,4,4]
12:53:25 <kmc> niklot_, for Haskell?  LYAH or RWH
12:53:27 <kmc> @where LYAH
12:53:27 <lambdabot> http://www.learnyouahaskell.com/
12:53:27 <alshain> applicative: is this relevant to my question?
12:53:28 <applicative> niklot_: learn you a haskell, for example;
12:53:29 <kmc> @where RWH
12:53:29 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:53:49 <alshain> rwbarton: ah, so 'n' is just a placehold for an expresion, in which 'a' can be used?
12:54:09 <alshain> placeholder*
12:54:11 <applicative> alshain, thats an instance of the formula, I used it because the x is not used in [4]
12:54:37 <applicative> it is in scope, so we can write
12:54:50 <applicative> > [1,2,3] >>= (\x -> [x + 1])
12:54:54 <lambdabot>   mueval-core: Time limit exceeded
12:55:00 <rwbarton> alshain: yes
12:57:17 <applicative> > let (*) = (>>=) ; m = [1,2,3] ; n = [4] in m * (\a -> n)
12:57:18 <lambdabot>   [4,4,4]
12:57:47 <applicative> ^^^^ here is the same as instancing wadlers m * \a.n
12:58:46 <alshain> > let (*) = (>>=) ; m = [1,2,3] ; n = [4] in m * (\a -> a + n)
12:58:47 <lambdabot>   No instance for (GHC.Num.Num [t])
12:58:48 <lambdabot>    arising from a use of `e_11234' at <in...
12:59:18 <applicative> yeah, not so simple with that case, n would then be using the variable a
12:59:22 <alshain> :(, I thought "a" would be 1, or 2 or 3
12:59:41 <niklot_> ok thanks kmx, applicative, found them
12:59:43 <alshain> so the result would be [5,6,7]
13:01:40 <rwbarton> it is but what's n there?
13:01:54 <rwbarton> you can't add a number and a list
13:02:40 <applicative> > let (*) = (>>=) ; m = [1,2,3] ; n x = [4 + x] in m * (\a -> n a)
13:02:40 <lambdabot>   [5,6,7]
13:03:28 <alshain> 22:29:24 | rwbarton > it is but what's n there?, <<< oh, right, that makes sense
13:07:48 <applicative> > let (*) = (>>=) ; m = [1,2,3] ; n x = [4 + x, 0 + x, 10 ^ x] in m * (\a -> n a)
13:07:49 <lambdabot>   [5,1,10,6,2,100,7,3,1000]
13:08:50 <alshain> applicative: so >== will merge the lists in the end? I see...
13:09:05 <alshain> >>=*
13:09:31 <applicative> alshain, you could say it substitutes then concatenates, in the case of the list monad
13:10:20 <alshain> substitutes? How do you mean? Like: 1 gets mapped to [5,1,10] ?
13:10:29 <applicative> it goes through each of 1,2,3 , replaces it by n of it
13:10:37 <applicative> alshain: yes
13:10:44 <alshain> ok
13:11:02 <clsmith> hm. does (>>=) therefore == concatMap ?
13:11:02 <applicative> n 1 = [5 , 1, 10] given my stupid function n
13:12:02 <applicative> >  let m = [1,2,3] ; n x = [4 + x, 0 + x, 10 ^ x] in concatMap n m
13:12:03 <lambdabot>   [5,1,10,6,2,100,7,3,1000]
13:12:23 <applicative> @type flip concatMap
13:12:24 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
13:12:32 <applicative> @type (>>=)
13:12:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:12:41 <clsmith> cool :)
13:12:53 <applicative> @type join
13:12:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:12:56 <applicative> @type concat
13:12:57 <lambdabot> forall a. [[a]] -> [a]
13:13:07 <clsmith> that solidifies for me why [] is a monad, then
13:13:38 <clsmith> @type (>>= id)
13:13:39 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
13:13:42 <applicative> yes, in this case, the superiority of the definition by 'join' is better, since concat is so familiar
13:14:31 <clsmith> man, haskell is so *neat* sometimes :p
13:14:49 <salisbury> clsmith: all the times
13:14:58 <applicative> but wadler, in the passage alshain is reading is deciding things in favor of (>>=) or (*) as he calls it there
13:15:10 <clsmith> hmm, can you define that if a type is of class X then it must also be of class Y by way of f = ... ?
13:16:01 <applicative> hm, not following
13:16:31 <clsmith> well, a monad is always a functor. so could we define that if a type is a monad it is also a functor by fmap = liftM ?
13:16:51 <MostAwesomeDude> I think there's an instance of Functor for all Monads, isn't there?
13:16:57 <donri> f :: (X a, Y a) => a
13:16:57 <clsmith> i believe so
13:17:11 <MostAwesomeDude> @instance
13:17:12 <lambdabot> Maybe you meant: instances instances-importing
13:17:16 <rfm47> Haskell also permits multiple inheritance, since classes may have more than one superclass. For example, the declaration class (Eq a, Show a) => C a where ...
13:17:22 <MostAwesomeDude> @instances Functor
13:17:23 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
13:17:40 <alshain> applicative: rwbarton thanks, I'll continuing on this tomorrow
13:17:42 <alshain> bye
13:17:53 <MostAwesomeDude> Huh, I guess not. But it's pretty obvious how to fix this for any given monad.
13:17:59 <clsmith> donri: i suppose so. but is there a way to say that... explicitly in the type Monad?
13:18:30 <clsmith> instance Functor a => Monad a where fmap = liftM ?
13:19:00 <clsmith> uh
13:19:05 <clsmith> the other way round, sorry
13:20:47 <bashoo> hello, I'm learning haskell with "learn you a haskell" etc
13:21:13 <kmc> rfm47, i think it's misleading to call that "multiple inheritance"
13:21:21 <kmc> wrt what that term means in other languages
13:21:21 <c_wraith> bashoo: that's a good place to start
13:21:40 <kmc> in fact misleading to call it "inheritance" at all
13:21:50 <applicative> clsmith: given a prior monad instance for M you can write "instance Functor M where fmap = liftM"
13:22:16 <clsmith> applicative: yes, but i'm wondering whether we can omit that entirely, and just make the fact that any monad is also a functor implicit.
13:23:14 <applicative> clsmith: that Monad doesn't presuppose Functor is a frequent complaint; if it did we wouldn't have any use for liftM though, right?
13:23:29 <clsmith> which is good! :p
13:23:38 <bashoo> c_wraith: After I can do a little bit I'm going to try Project Euler
13:23:38 <applicative> clsmith: i guess thats what you're saying, yes
13:24:09 <clsmith> tbh i want map :: Functor f => (a -> b) -> f a -> f b
13:24:18 <c_wraith> bashoo: project Euler will teach you a couple interesting things, but it very rapidly goes from "learning the language" to "this requires knowing a math trick, brute force is impossible"
13:24:20 <clsmith> but maybe that would confuse newcomers
13:24:36 <applicative> clsmith: are you trying to break everything? :)
13:24:39 <clsmith> c_wraith: i found that, yeah. and i suck at maths. <.<
13:24:42 <bashoo> yeah i noticed there is at least one problem that i sunsolved
13:24:58 <bashoo> which surprised me
13:25:00 <clsmith> applicative: well, it wouldn't break, if we said map = fmap = liftM = ... :p
13:25:25 <bashoo> c_wraith: do you have any other suggestions?
13:25:26 <clsmith> but how about in Haskell 2020? :o
13:26:07 <applicative> bashoo, a lot of people use Project Euler for this purpose, by the time you make it through 15 or so, you will have all the syntactic niceties down
13:26:08 <bashoo> I did some C programming 10 years ago but very little since
13:26:18 <c_wraith> bashoo: Just trying to write small programs, like one-off utilities that do simple tasks.  Things that don't require a lot of work, but do make you deal with managing an entire program.
13:27:41 <clsmith> i've always found reimplementing things like nl, grep, etc, quite useful for learning a new language
13:27:55 <Zarathu> http://pastie.org/3007436
13:28:19 <Zarathu> I have some pretty simple test code I'm playing around with ^ but for some reason, yesno 5 throws a strange type error.
13:28:30 <Zarathu> Is there something blatantly wrong with it? I just copied it out of my Haskell book. :/
13:28:43 <donri> i learn best by having a real project that i actually want to finish / get to a useful state
13:28:45 <clsmith> what is the error?
13:28:48 <Zarathu> Ambiguous type variable `a0' in the constraints: (YesNo a0) arising from a use of `yesno' at <interactive>
13:28:58 <clsmith> yesno (5 :: Int) ?
13:29:03 <bashoo> I'd be interested in doing something with monte carlo simulations
13:29:17 <Zarathu> clsmith: That works, but why isn't it able to infer that 5 is an Int?
13:29:19 <applicative> Zarathu: ghci can't tell whether you mean Int or Integer
13:29:34 <c_wraith> or Double or Float, or any other instance of Num
13:29:37 <Zarathu> Hm. I thought 5 was Int by default, and fromInteger or :: Integer casted it to an Integer.
13:29:53 <ziman> :t 5
13:29:53 <lambdabot> forall t. (Num t) => t
13:29:56 <tromp> :t 5
13:29:56 <lambdabot> forall t. (Num t) => t
13:30:01 <Zarathu> >.<
13:30:06 <c_wraith> Zarathu: there is no casting in haskell
13:30:07 <salisbury> yesno :: Int -> Bool
13:30:08 <clsmith> quick, everyone ask lambdabot the type of 5? >.>
13:30:11 <salisbury> would fix that, no?
13:30:17 <tromp> :t cast
13:30:18 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
13:30:19 <donri> Zarathu: number literals are polymorphic/generic to Num
13:30:30 <Zarathu> donri: Cool, that makes sense. Thank you.
13:30:44 <xplat> for data/newtype explanation, i would say 'data declares a new datatype, type declares an alias for an existing type, newtype abstracts an existing type'
13:30:50 <hpaste> applicative pasted “yesno” at http://hpaste.org/55200
13:30:51 <hpaste> applicative pasted “yesno” at http://hpaste.org/55201
13:30:52 <xplat> but then i'd write a paragraph for each to explain
13:30:54 <Zarathu> How would I write a YesNo instance with a class constraint of Num a, so that yesno 5 works?
13:31:18 <Zarathu> Hm.
13:31:24 <donri> Zarathu: so if you use a number literal in a "context" where the expected type is Int, it becomes an Int, but if there's no type hints it'll be "ambiguous"
13:31:26 <Zarathu> That hpaste shows the same thing twice. :/ Kinda redundant.
13:31:50 <Zarathu> Ahh, got it.
13:32:01 <applicative> Zarathu: no, it gives different instances for Int and Integer --- to explain why ghci was confused
13:32:09 <applicative> oh
13:32:28 <Zarathu> applicative: I understand, but I'd like to know how to add a class constraint to an instance to avoid having to write two of them. Super noob here. :)
13:33:29 <Zarathu> instance (Num a) => YesNo a where -- throws an error
13:34:53 <c_wraith> Zarathu: because you're actually defining the instance for *all types*.  That's usually an error, so the compiler tells you so.
13:35:08 <c_wraith> Zarathu: the instance constraint doesn't work the way you think it does
13:35:20 <donri> a noob myself, i think you might be talking about generics/gadts or somesuch
13:35:38 <donri> but don't take my word for it
13:36:02 <c_wraith> Nah, this is different from them.
13:36:34 <clsmith> there is a flag to make ghc accept that, right?
13:36:35 <Zarathu> c_wraith: Okay. Is there *any* way I could write the instance so that yesno 5 works without having to specify that 5 is an Int, and without having to write two different instances?
13:37:17 <c_wraith> Zarathu: no, because the problem isn't the instance.  It's how types are picked given instance restrictions
13:37:20 <Zarathu> It works if I write another function that's :: Int -> Bool, and then call foo 5.
13:37:31 <Zarathu> Okay, got it. Thanks.
13:37:40 <donri> but then that function doesn't work for Integers
13:37:54 <Zarathu> donri: Correct. It would if I added the class constraint to that function.
13:37:58 <Zarathu> Ugh, I keep wanting to say "method". :P
13:38:11 * clsmith purges methods from Zarathu's thoughts
13:38:18 <Zarathu> \o/
13:38:40 <Zarathu> This channel is way more helpful than we are in the ruby/rails channels. :>
13:39:15 <clsmith> yeah, i've found the haskell community to be really friendly (albeit way smarter than i am)
13:39:15 <xplat> well, speaking of helpful, let me repeat my earlier question
13:39:16 <c_wraith> This might be the most helpful channel on freenode.  We even help most trolls.  :)
13:39:18 <xplat> what happened to source links on hpaste?
13:39:29 <c_wraith> preflex: seen chrisdone
13:39:29 <preflex>  chrisdone was last seen on #haskell 1 day, 20 hours, 32 minutes and 22 seconds ago, saying: pandoc notably isn't bsd
13:39:37 <EvanR-work> trolls are people too
13:39:48 <xplat> no they're not, they're minerals
13:39:51 <c_wraith> xplat: I don't know, but chrisdone maintains xpaste
13:40:13 <xplat> @ask chrisdone what happened to source links on hpaste?
13:40:13 <lambdabot> Consider it noted.
13:40:16 <donri> you mean hplat
13:40:27 <c_wraith> err.  hpaste.  yes. :)
13:40:47 <donri> x_wraith: hehe :)
13:41:20 <c_wraith> xplat: do any of the new links that show up when you hit expand work?
13:42:10 <applicative> c_wraith: I can view the raw link
13:42:29 <xplat> c_wraith: oh
13:42:49 <xplat> 'Expand' is strangely non-self-explanatory for my brain
13:42:59 <xplat> i think i'm just used to pictograms for that
13:43:55 <applicative> xplat: I think its because the old default took up took up too much space; 'expand' made sense for the two weeks when we could remember what the previous arrangement looked like
13:44:26 <applicative> c_wraith: I can also view the paste 'in context' in irc
13:44:46 <c_wraith> applicative: sorry, I meant "work" as in "do what you want", not "do something" :)
13:44:56 <xplat> @tell chrisdone never mind; but it really isn't obvious where to find it :(
13:44:56 <lambdabot> Consider it noted.
13:45:05 <scooty-puff> so i see here: http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner under Further Topics, a means to handle recursion when doing type inference using a fixed point combinator
13:45:16 <donri> "Context in IRC" that is shiny
13:45:18 <applicative> it seemed fine, though, i was  just looking at the paste I made a minute ago, though
13:45:28 <scooty-puff> it looks like the defined function can only appear as a monotype in its definition
13:45:35 <scooty-puff> is this true with haskell as well?
13:45:36 <applicative> donri, yeah, i hadn't taken it in
13:45:50 <scooty-puff> (i.e. f is a monotype in f's body)
13:47:05 <donri> https://github.com/chrisdone/amelie you can always send chris a pull-request
13:47:11 <donri> xplat: ^^^
13:48:03 <kstt> hey
13:48:15 <xplat> donri: maybe if i was sure exactly what i want :)
13:48:39 <alistra> hi
13:49:01 <xplat> i'm less of a web designer than a webbed-out whiner
13:49:42 <donri> xplat: how about some monochromatic "plus" icon next to the paste title, and with the whole title also being clickable (and change to "minus" icon on expansion)
13:49:48 <xplat> at least at this point of my life.  implement, yes, design, no.
13:50:28 <xplat> i suppose that would be the standard
13:50:35 <applicative> why not just replace "Expand" with "Other Cool Features"
13:50:57 <donri> it's weird to have expand in the same listing as the other stuff
13:50:57 <kstt> let's say I have 'data A = A' and 'data B = B A'. There is a function 'f' defined in typeclass C. 'A' instance for C is defined. Is there a way to get the trivial C instance for B -- that is: f (B x) = f x -- with less effort than reimplementing it explicitly ?
13:51:45 <xplat> i'd rather replace the 'too big' header with a smaller one though and avoid the 'expand' entirely
13:52:06 <kstt> I think that's more or less what generalizedNewtypeDeriving offers, but can this be done with data decls ?
13:52:18 <Saizan> nope
13:52:40 <Saizan> i.e. GHC doesn't offer a way currently
13:54:38 <kstt> ok thanks Saizan. It isn't that I don't like newtype, but just that sometime the data type must combine 2 other types, instead of just wrapping one, and then proxying to inner data is a bit repetitive.
14:28:19 <DukeDave> Delicious SO karma for a cabal dev:
14:28:19 <DukeDave> http://stackoverflow.com/questions/8482111/when-giving-the-cabal-simple-build-system-a-custom-build-hook-why-are-there-two
14:33:41 <Cale> DukeDave: I think the difference is that the latter doesn't have any conditionals left in it
14:33:48 <Cale> looking at the documentation
14:33:58 <Cale> (I refuse to use StackOverflow)
14:34:08 <Cale> (I am also not a Cabal dev)
14:34:26 <alistra> is matron the female word for patron?
14:34:43 <Cale> http://en.wikipedia.org/wiki/Matron
14:34:56 <DukeDave> Cale: I spotted that also, but I was confused as to why the former would be passedd
14:35:01 <Cale> http://en.wiktionary.org/wiki/matron
14:35:38 <Cale> DukeDave: hmm, well, maybe just because it's available... you might want to have the original unadulterated package description from the .cabal file for some reason
14:35:43 <rfm47> Cale:  for my own curiosity:  why the opposition to SO?
14:36:28 <Cale> rfm47: I just kinda found myself opposed to its effect on pre-existing communities
14:36:59 <Cale> It's also just really weird, interface-wise, and I don't like the karma system.
14:37:32 <DukeDave> Cale: They have an API (I think), perhaps write your own interface? :)
14:37:35 <rfm47> kind-of a walmart opposition?  i haven't used it much, but keep thinking i ought to
14:37:42 <Cale> I'd rather just not use it
14:38:25 <rfm47> fair enough, sorry for the digression.  :-)
14:38:31 <Cale> It's cool
14:39:44 <Cale> DukeDave: Honestly, Reddit provides what I think is a pretty ideal interface for something like that, though we're not really using it for that ATM. The mailing list is decent, and produces lots of good discussion.
14:39:57 <Cale> and of course, IRC :P
14:40:12 <Cale> I prefer karma to be meaningless
14:40:31 <Cale> and conversations to be threaded
14:44:09 <ssbr_> How does one write a multi-line thing in ghci? e.g. a let expression
14:44:49 <DukeDave> Cale: Ah, I never think to look on reddit
14:44:52 <Jafet> :load multilinething.hs
14:45:23 <Cale> DukeDave: We should start an r/HaskellHelp if there isn't one already
14:45:29 <Cale> DukeDave: though honestly...
14:45:36 <Cale> I just don't want the fragmentation
14:45:51 <Jafet> Or use :{, but that looks like the emoticon to describe what happens when you use it
14:45:53 <Cale> So it kind of goes against that desire to keep the community in one place.
14:46:01 <rfm47> Is there a good authoritative FAQ somewhere?
14:46:16 <Cale> ssbr_: use braces and semicolons
14:46:21 <Jafet> @faq can Haskell have a good authoritative FAQ?
14:46:22 <lambdabot> The answer is: Yes! Haskell can do that.
14:46:34 <Cale> ssbr_: but yeah, honestly the answer is you make a file, and don't use let in ghci so much
14:46:37 <kmc> i'm trying to get people to use http://haskell.org/haskellwiki/FAQ
14:46:40 <kmc> rfm47, ^
14:46:50 <kmc> i wouldn't call it "authoritative"
14:47:06 <rfm47> kmc, thanks, i haven't looked at it.
14:47:09 <ssbr_> Cale: I'm learning haskell and want to figure out how let works. :/
14:47:37 <rfm47> ssbr_, let works on multiple lines when it's in a file
14:47:48 <Cale> let <decls> in <expr>
14:47:56 <ssbr_> rfm47: Sure, but isn't the whole point of having an interactive interpreter be to test out things in it?
14:48:05 <Cale> ssbr_: I have nothing against using the expression form of let at ghci ;)
14:48:16 <kmc> let doesn't have to be multiple lines, either
14:48:17 <shadyp\> anyone used Random.MWC with the ST monad? type GenST s = Gen (PrimState (ST s)), how should it be used?
14:48:17 <rfm47> ssbr_, i make no claims that ghci is my ideal interpreter.  :-)
14:48:19 <kmc> you can use braces and semicolons
14:48:28 <ssbr_> Yes, sure, but how do you use braces and semicolons
14:48:28 <kmc> > let { a = 3; b = a + 1 } in b
14:48:29 <lambdabot>   4
14:48:31 <ssbr_> I don't know these things yet
14:48:33 <Cale> ah
14:48:35 <ssbr_> OK, thank you
14:48:49 <Jafet> > let x = 42; y = 69; z w = let a = w^w in a in w x + y
14:48:49 <lambdabot>   Couldn't match expected type `t -> a'
14:48:50 <lambdabot>         against inferred type `Simple...
14:48:52 <kmc> ssbr_, the whitespace dependence in haskell syntax is just sugar for braces and semicolons
14:48:54 <arw> .oO( somebody could write a "let with braces"-tutorial )
14:48:58 <Jafet> > let x = 42; y = 69; z w = let a = w^w in a in z x + y
14:48:59 <lambdabot>   150130937545296572356771972164254457814047970568738777235893533016133
14:49:11 <arw> .oO( or "haskell with braces" )
14:49:14 <kmc> ssbr_, when a line is indented the same as the previous line, it gets an implicit semicolon at the beginning.  when it's indented less, an implicit closing brace
14:49:19 <kmc> those are approximately the rules
14:49:23 <Cale> > case [1,2,3] of { (x:xs) | even x -> x `div` 2 | otherwise -> x; [] -> 0 }
14:49:24 <lambdabot>   1
14:49:37 <Jafet> > let { x = 42; y = 69; z w = w^w where { a = w^w; }; } in z x + y
14:49:38 <lambdabot>   150130937545296572356771972164254457814047970568738777235893533016133
14:49:51 <kmc> this means you never *have* to use whitespace, which is a nice property
14:50:01 <Jafet> >>> from __future__ import braces
14:51:39 <ssbr_> kmc: thanks.
14:51:52 <ssbr_> Eh. I'm alright with just having to use whitespace.
14:52:01 <ssbr_> I've had bad experiences with YAML, which lets you use either.
14:52:07 <ssbr_> (it gets confused, unfortunately)
14:52:16 <kmc> well yeah, if you're gonna allow both then you have to do it right ;)
14:52:33 <kmc> i think "doing it right" means making one sugar for the other, rather than having truly alternative grammars
14:53:11 <kmc> allowing explicit punctuation makes certain things more concise; makes code generation easier; makes it easier for blind programmers (there's at least one who's contributed to hackage)
14:53:27 <arw> truly alternative is also fine, but only if mixing is not possible or only possible by some very explicit and unambiguous mechanism
14:53:38 <kmc> and it makes obfuscated haskell competitions more fun of course
14:54:24 <Jafet> Obfuscation is done differently in Haskell, kmc. You obfuscate a Haskell program by generalising it.
14:54:42 <dylukes> :P
14:54:52 <dylukes> Wait, you obfuscate by... making it more useful?
14:55:17 <dylukes> You can also obfuscate in Haskell by church encoding everything.
14:55:23 <shachaf> "generalising" doesn't necessarily mean "making it more useful".
14:55:30 <kmc> a program is not "useful" if it's so general nobody knows how to use it
14:55:41 <shachaf> Also, Church-encoding occasionally makes things clearer.
14:55:52 <kmc> if you generalize any program far enough, it becomes a lisp interpreter
14:55:53 <shachaf> That's why foldr is a useful function. :-)
14:56:04 <kmc> and yet it is useful to have in this world programs which are not lisp interpreters
14:56:27 <Jafet> A mail-reading lisp interpreter
14:56:34 <shachaf> We should organize another IOHCC.
14:56:44 <arw> no. just more general in a mathematical sense. "now you could use it with the UselessT monad, its a DSL for cannibal recipies and it solves world peace. and also, its intended purpose is a calculator, which can be programmed via the cannibal recipies"
15:08:04 * hackagebot atl 15320.1 - Arrow Transformer Library  http://hackage.haskell.org/package/atl-15320.1 (MatthewFarkasDyck)
15:16:52 <hpaste> m3ga pasted “Enumerator problem” at http://hpaste.org/55202
15:18:29 <m3ga> any enumerator whizzes able to have a look at this? http://hpaste.org/55202
15:18:55 <blackmirroxx> hi
15:21:03 <blackmirroxx> #debian
15:35:32 <ectod> hi
15:36:36 <ectod> i'm new to haskell ( i finished the 13 chapters of the LYAH ) and i have a question about the State Monad if anyone is up :)
15:37:44 <dgpratt> ectod: what's the question?
15:38:31 <ectod> Well i do not really understand how to use it with the >>= function
15:38:36 <ectod> i tried but it's confusing
15:38:52 <ectod> because it's the first monad that we see that actually IS a function
15:39:30 <ectod> what i mean is that it's easy to understand that return 1 >>= (\x -> Just x) >>= etc does what it does
15:40:46 <ectod> but with State Monad, it is not, because it's something like : runState(return 5) 1 >>= (\x -> state (\x -> (s,x)) >>= etc
15:41:16 <kmc> ectod, did you see 'get' and 'put' from http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/packages/mtl-2.0.1.0/doc/html/Control-Monad-State-Class.html
15:41:39 <kmc> state monad actions are largely built out of these "primitives"
15:42:08 <ectod> are they ? the implementation on the source code goes without them as i saw it
15:42:22 <ectod> but yes i saw how they work, put sets the value without changing state, get gets the value
15:42:27 <kmc> you can use State monad without them
15:42:32 <kmc> that's why i said "largely"
15:42:41 <shachaf> ectod: The implementation of State is more or less the only place where you actually use "State" and "runState" yourself, in most cases.
15:43:02 <kmc> ectod, i'm not sure if you're asking about how State is commonly used, or about how it's implemented
15:43:20 <ectod> oh allright shachaf
15:43:31 <ectod> kmc, well i quite understand how they are used in do-notation
15:43:46 <kmc> then all you need to do is understand how "do" translates to (>>=)
15:43:56 <kmc> which is quite simple and is more general than just State
15:44:04 <shachaf> This is true with monads in general. You have the generic Monad API ((>>=)/return), and then some primitives specific to the particular instance that you're using, like get/put or callCC or so on.
15:44:50 <kmc> but sometimes the monad is a concrete (non-abstract) data type, and so you also get constructors and pattern-matching as "primitives"
15:45:13 * BMeph thought "put" and "get" worked on the State, not the value.
15:45:20 <ectod> yes i know do-notation is a syntactic sugar for chaining monadic values with >>=, but as i wanted to implement some state stuff with >>= ( just to see how this would look ) i had some problems
15:46:08 <ectod> because as do is the shorthand, i want to know how to do it with >>= first :)
15:46:27 <dgpratt> ectod: fyi, one way to "see how this would look" is this:
15:46:34 <dgpratt> @undo do { x <- get; put (x-1); get }
15:46:34 <lambdabot> get >>= \ x -> put (x - 1) >> get
15:46:57 <ectod> i write this in ghci ?
15:47:07 <rfm47> ectod, no, to lambdabot here
15:47:17 <rfm47> you can msg her, too
15:48:48 <ectod> dgpratt, what is undo ?
15:49:31 <dgpratt> ectod: a feature of lambdabot; does the transformation from "do" notation to the monad primitives
15:50:19 <dgpratt> ectod: lambdabot is an extremely useful bot for Haskell stuff
15:50:22 <ectod> lambdabot is a bot on this channel ?
15:50:26 <dgpratt> ectod: yes
15:50:26 <ectod> ah ok
15:50:39 <ectod> oh that's nice
15:50:44 <ectod> undo do { x <- get; put (x-1); get }
15:50:44 <rfm47> > reverse $ take 3 [1..]
15:50:45 <lambdabot>   [3,2,1]
15:50:52 <rfm47> (you need an @)
15:51:00 <ectod> ok i get it sorry
15:51:22 <dgpratt> does Cale accept donations? :)
15:51:24 <Patinho`Busy> :O
15:51:28 <Patinho`Busy> lambdabot :OO
15:51:30 <parcs__> omg, ghc-mod is awesome
15:51:30 <preflex>  parcs__: you have 1 new message. '/msg preflex messages' to read it.
15:51:40 <Cale> dgpratt: You want to donate?
15:51:42 <Patinho`Busy> 1:[1,2,3]
15:51:49 <dgpratt> Cale: sure
15:51:50 <Patinho`Busy> ::|
15:52:17 <Patinho`Busy> drop 1 [1,2,3,4,5,6]
15:52:21 <Patinho`Busy> :/
15:52:27 <Cale> dgpratt: Um, I have a paypal registered for cgibbard@gmail.com
15:53:01 <hpc> > fix $ var . show "> fix $ var . show \""
15:53:02 <lambdabot>   Couldn't match expected type `Data.Number.Symbolic.Sym a
15:53:02 <lambdabot>                   ...
15:53:05 <dgpratt> Cale: it won't be much :-) I have 7 mouths to feed :-)
15:53:14 <hpc> :(
15:53:15 <ectod> so i guess i'll check out more deeply put and get, but the LYAH doesn't say it
15:53:19 <Cale> dgpratt: You probably need it more than I do then :)
15:54:03 <ectod> i think the chapter about State monad is a bit tedious, i'll have to read it a few times more, thanks
15:54:51 <ectod> @undo do { a <- getLine; b <- getLine; return (a+b); }
15:54:52 <lambdabot> getLine >>= \ a -> getLine >>= \ b -> return (a + b)
15:55:05 <hpc> ectod: one thing ive found helps is to take a monadic type and remove all the "wrappers"
15:55:26 <hpc> ectod: then think about the uncluttered versions of the functions instead of the wrapped versions
15:55:29 <hpc> @unmtl State s a
15:55:29 <lambdabot> s -> (a, s)
15:55:42 <ectod> you mean remove the 'newtype State s a = State { etc } ?
15:55:43 <dgpratt> Cale: there; buy yurself sumthin' pritty
15:55:48 <hpc> ectod: yeah
15:56:15 <hpc> ectod: it won't be runnable haskell anymore, but it will be easier to read
15:56:41 <ectod> yes it could help, thanks
15:56:49 <Cale> dgpratt: why thank you very much :)
15:57:37 <ectod> i'll work on it all tomorrow.
15:57:56 <ectod> another quick one : what about the 'mtl' and 'monads-fd' clash on GHC packages ?
15:58:23 <dgpratt> Cale: most welcome; a small token...
15:58:50 <ectod> i tried to remove the monads-fd one 'by hand' and rebuild the ghc-pkg cache, but all went wrong and i had to reinstall the whole platform
15:59:04 <shachaf> Cale: Are you going to Hac Boston, by the way?
15:59:04 <ectod> ( ghci was crying out loud )
15:59:29 <ion> Just deleting ~/.ghc should have been enough.
15:59:51 <Cale> shachaf: I'm working on it, we'll see.
15:59:52 <ddarius> Having seven mouths is quite the genetic mutation.
16:00:23 <ectod> ok i'll try it next time
16:00:30 <dgpratt> ddarius: lol
16:00:30 <Cale> ddarius: Sounds pretty biblical end-times-y ;)
16:01:21 <shachaf> Cale: Are you going to have a passport? Once you get that set up, you can always go to BayHac. :-)
16:01:52 <Cale> Y U NO SATISFIED WITH MY INCORPOREAL EXISTENCE
16:02:25 <roconnor> ghc-pkg seems to be a bit of a mess.  Someday the GHC developers will understand that mutable state is bad. :P
16:02:39 <roconnor> (granted almost everything else is just as bad I imagine)
16:03:08 <ectod> i agree i think it 'gets in the way' too much
16:03:36 <ectod> specially when you see how packages and modules are treated, it's just a simple and neat path story
16:04:08 <ectod> the ones you define yourself i mean ofc
16:06:11 <niklot_> hey guys - quick question. I've developed an idea for a physics game and am now considering making it. I have only a basic understanding of programming and have not used any 3D plugins/libs before. Do you think haskell is a suitable language to learn in order to realise my project?
16:06:31 <irene-knapp> niklot: I do not think your project can be done by you :)
16:07:10 <irene-knapp> you need to take some courses in data structures and algorithms, and get some experience working in large codebases
16:07:13 <hpc> niklot_: the right language is the least of your problems
16:07:29 <Peaker> Disagreed -- a lot of determination and some innate competence can overcome lack of experience
16:07:32 <irene-knapp> that's unnecessarily harsh hpc :D
16:07:55 <hpc> niklot_: pick a language you already know well, find libs that do what you need, and learn the hell out of them
16:08:02 <Peaker> niklot_: Haskell is probably a good first language -- but it will take a *lot* of effort
16:08:17 <hpc> making any game is a lot more work than it looks like
16:08:23 <irene-knapp> also, none of the non-expensive-to-license libraries in any language can do that sort of thing :)
16:08:31 <hpc> even if you have made games before and know how difficult it will be, it's always harder
16:08:36 <niklot_> ok thanks, i studied programming for 2 semester at uni but got very sick. I may go back.
16:08:45 <hpc> and 3D in general is a pain in the ass
16:08:49 <irene-knapp> university isn't the one true path to knowledge, but it's a good start
16:08:58 <Eduard_Munteanu> It all depends on the details.
16:09:01 <irene-knapp> yep
16:09:14 <Eduard_Munteanu> 3D/physics game doesn't say that much.
16:09:59 <hpc> niklot_: i understand pygame is pleasant to use and doesn't have a precipitous learning curve
16:10:12 <hpc> if you don't mind learning python
16:10:44 <dmwit> Chipmunk is nice for 2d physics, and has Haskell bindings.
16:10:49 <Axman6> do you ever actually 'learn' python? I always felt like i was hacking stuff together until it worked
16:10:56 <Jafet> @quote python.way
16:10:57 <lambdabot> Jafet says: it's more fashionable nowadays to do it [write code] the python way, pretend your code works when you write it and hope it works when you run it
16:11:04 <dmwit> You can learn Python.
16:11:32 <hpc> Axman6: i suppose at some point, that "until" period becomes very short
16:11:37 <eyebloom> I'm reading through "Monads for Functional Programming" by Phillip Wadler and I'm hoping for some help understanding some things. How does one interpret a expression like eval (Con a) = out (line (Con a) a) ★λ().unit a where out x = (x, ()) (Star is bind in this paper.) The part that is confusing is how () can be a variable in a lambda expression.
16:11:43 <dmwit> You just have to look for a Python tutorial that's trying to teach Python instead of trying to get you productive. =)
16:11:52 <hpc> Axman6: i consider the moment i learned perl to be "i was hacking stuff together, and then it worked"
16:12:02 <niklot_> thanks im reading everything. i may stick with python.. i was envisaging what is essentially a more complicated minecraft
16:12:08 <dmwit> eyebloom: I would read that as a pattern match.
16:12:09 <shachaf> eyebloom: Maybe it's a pattern-match?
16:12:17 <dmwit> eyebloom: \() -> e ~= \x -> case x of () -> e
16:12:50 <Peaker> Python is a nice language to use. In some ways, more usable than Haskell (usable stack traces, very easy metaprogramming).  Python tends to work very nicely when 100% code coverage is still easy -- so it's insidious
16:13:09 <Peaker> once 100% code coverage becomes harder and harder -- Python becomes painful
16:13:14 <dmwit> niklot_: If you will be comparing your game to a popular, on-the-market game, then an inexperienced one-man team simply is not going to cut it.
16:13:28 <eyebloom> I see.
16:13:30 <Peaker> that only happens when you're deep in the project, and highly invested in it
16:13:34 <hpc> Peaker: i could never get a python program to work without dealing with numeric type errors everywhere
16:13:59 <Axman6> hpc: I've made one perl script, and it worked. but i'd never ever say i knew perl, at all :P
16:14:06 <dmwit> niklot_: You can certainly write a game yourself, I'm just suggesting you scale back your goal a bit. =)
16:14:08 <Peaker> hpc: A failing Python program where every-run-is-100%-coverage stage, is very much like a type error in a GHC compilation, except it has an easier to understand message and scope
16:14:09 <Jafet> niklot should still try. When he fails, he will learn how difficult programming is
16:14:12 <Axman6> well, maybe not ever, but not at the moment anyway
16:14:18 <Jafet> And adjust his goals accordingly
16:14:24 <dmwit> Jafet++
16:14:49 <niklot_> im not planning on getting it done by tomorrow :P im happy to work on it forever, just want to make sure i set off in the most productive way
16:15:03 <hpc> Peaker: the message is definitely easier to read, but harder to fix
16:15:15 <Peaker> hpc: why? I don't find Python harder to fix
16:15:22 <hpc> Peaker: because it doesn't give as much type information, and you can't hoogle
16:15:37 <Peaker> hpc: it gives you a concrete failure case, that's actually nicer than abstract type information
16:15:38 <srhb`> There probably isn't such a way. Just don't obsess over the tool you choose for the job when you set out, or you won't even get started, niklot_. Can always change later, since it's a learning process and you won't end up invested in 10000 lines in a month.
16:16:05 <Peaker> hpc: hoogle gets you up to speed nicely, but I don't find myself using it much after I got to know the libraries I'm using
16:16:52 <hpc> Peaker: i still use it a lot, but mostly for date-time stuff
16:17:08 <Peaker> hpc: the lack of hoogle in Python doesn't make errors harder to fix ime
16:17:10 <hpc> and sometimes for libraries that i only need a shallow understanding of
16:18:19 <hpc> Peaker: i don't code in python often enough to keep all the functions in my head, so i always end up googling
16:18:34 <hpc> and for whatever reason, it always takes 2-3 links for me to find the right function
16:19:06 <Eduard_Munteanu> srhb`: right.... first comes the name of the project, then the color of the main menu, then the tool :P
16:19:31 <hpc> Peaker: it's like a lesser version of the hellhole that is php's inconsistent naming conventions
16:19:42 <hpc> Peaker: unindexed functions / typeless functions
16:20:04 <eyebloom> Another question is, in his definition of the Left Unit Monad Law he writes "Compute the value a, bind to the result, and compute n. The result is the same as n with value a substituted for variable b"  as in:  unit a ★ λb.n =  n [a/b]  ... hard to understand if this is equivalent to saying (λb.n) a.
16:21:00 <hpc> eyebloom: n [a/b] is either (n a) or (n b), i forget which
16:21:00 <eyebloom> i.e.  unit a ★ λb.n = (λb.n) a
16:21:32 <hpc> eyebloom: i think that's right
16:21:35 <hpc> i hate that notation, btw
16:21:55 <eyebloom> which the star for bind?
16:22:07 <eyebloom> or the square brackets?
16:22:21 <hpc> the square brackets are function application
16:22:23 <hpc> the star is bind
16:22:34 <eyebloom> which do you hate?
16:22:37 <hpc> eyebloom: here's the law in un-shit-notation
16:22:45 <hpc> eyebloom: return a >>= f == f a
16:22:48 <Jafet> <hpc> dammit stop doing math with my programming language
16:23:01 <hpc> Jafet: :P
16:23:22 <eyebloom> return is unit then and >>= is bind ?
16:23:27 <hpc> eyebloom: yes
16:23:36 <hpc> Jafet: that notation has some really evil hidden consequences
16:23:50 <hpc> Jafet: for one, it requires you to remember the names of parameters to functions
16:23:56 <eyebloom> what are they?
16:24:09 <hpc> Jafet: f = λxy. x
16:24:16 <Jafet> That looks very similar to de Bruijn notation
16:24:25 <hpc> Jafet: f[x/a] and f[y/a] are totally different
16:24:41 <hpc> Jafet: you have to remember the exact definition to know which is which
16:24:58 <hpc> Jafet: oh, and i even got it backwards
16:25:07 <hpc> Jafet: it's f[a/x] and f[a/y]
16:25:27 <hpc> it's too much bullshit to just say f(a) or (f a)
16:25:33 <Peaker> hpc: Python's help() and dir() are useful for lookups
16:25:42 <rwbarton> f(a) is not the same as f[a/x]
16:25:42 <Peaker> hpc: mostly the usable functions are methods of whatever object you have
16:26:30 <eyebloom> So the notation f[x/a] means expression f with a substituted for x?
16:26:38 <hpc> eyebloom: other way around
16:26:42 <Jafet> The problem with help() and dir(), like the problem with ghci tab-completion and Haddock signatures, is that many programmers use them to substitute for documentation.
16:26:47 <eyebloom> gotcha
16:26:59 <hpc> f[a/x] means apply 'a' to 'f', replacing argument 'x'
16:27:15 <Jafet> No, it applies f to a!
16:27:22 <hpc> er, that
16:27:29 <c_wraith> meh.  I apply arguments to functions.
16:27:45 <c_wraith> "here is my neat little function box.  I am going to throw an argument at it, and see what it throws back"
16:27:52 <Jafet> @quote argument
16:27:52 <lambdabot> mike-burns says: Oh good, a semantic argument. Goodnight.
16:27:55 <hpc> c_wraith: high five! verb-nouners unite!
16:27:59 <Jafet> @quote Jafet argument
16:27:59 <lambdabot> Jafet says: unsafeCoerce takes any argument. AND IT WINS THAT ARGUMENT.
16:28:06 <irene-knapp> haha, nice, haha
16:28:07 <c_wraith> haha.  nice
16:28:56 <Peaker> Jafet: help() and haddock are documentation
16:29:36 <Jafet> See "many programmers"
16:30:12 <hpc> Jafet: so "many programmers" use documentation as a substitute for documentation? we should be trying to make that "all programmers" :P
16:30:22 <mike-burns> Some blindly type!
16:30:31 <eyebloom> Thanks for the help.
16:32:38 * irene-knapp blinks
16:32:43 <irene-knapp> that's quite a quit message
16:33:40 <shachaf> irene-knapp: Might be a NetHack reference?
16:33:58 <irene-knapp> oh, hmm, perhaps?
16:34:03 <shachaf> Oh, no, apparently NetHack is referencing something else.
16:34:09 <irene-knapp> it's a song, see
16:34:10 <irene-knapp> but
16:34:15 <irene-knapp> spelled mis-.
16:35:16 <shachaf> When you dismount an unnamed horse, you're told "you've been through the dungeon on a horse with no name".
16:35:24 <irene-knapp> haha, cute
16:35:36 <irene-knapp> felt good to be out of the rain :D
16:35:44 <MostAwesomeDude> There's an old America song with the lyric, "I've been through the desert on a horse with no name."
16:35:57 * MostAwesomeDude doesn't see /part messages, but can guess
16:36:05 <irene-knapp> yeah
16:36:15 <irene-knapp> the part message was "I've horsed through the desert on a bin with no name"
16:36:16 <hpc> "I've bussed through the desert on a Sega Genesis with no name"?
16:36:26 <irene-knapp> heh!  Desert Bus forever!
16:36:30 <irene-knapp> (or at least it'll feel like forever)
16:37:28 <MostAwesomeDude> Haha, nice.
16:37:32 <irene-knapp> yep
16:44:44 <ski> hpc : there's no application at all in there ..
16:46:11 <hpc> ski: oh crap, i forgot about term rewriting
16:46:16 <ski> `n [a/b]' is substitution, not application
16:46:25 <hpc> yeah
16:47:15 * Eduard_Munteanu kinda prefers TaPL's   [x |-> s] t
16:47:27 <hpc> is there any reason why they prefer to rewrite terms rather than just use a function?
16:47:50 <ski> when you present a lambda calculus, you have to define substitution first, to be able to say how an application of a lambda expression reduces
16:48:03 <hpc> ski: i mean beyond that
16:48:16 <Eduard_Munteanu> Let polymorphism?
16:48:19 <hpc> ski: they were using substitution to express the monad laws
16:49:00 <ski> Eduard_Munteanu : yeah, i can never recall which is which of `a' and `b' in `n [a/b]' -- typically, i use `n [a := b]' or `n [a |-> b]' (where `a' here must be a variable)
16:49:19 <ski> hpc : yes. i think that's reasonable
16:49:51 * Eduard_Munteanu reads '|->' as "becomes" though I guess ':=' would be even more clear
16:50:06 <ski> of course, you can express it without substitution, but then to apply the law you may have manually rewrite the expression before or after applying the law, manually
16:50:27 <ski> the advantage to using substitution here is to avoid having to do that
16:51:18 <ski> Eduard_Munteanu : yeah, you can consider `[x |-> a , y |-> b]' to be a function which maps the variables `x',`y' to the terms `a',`b', respectively
16:52:06 <ski> so this function/substitution could be though of as having type `Var -> Expr Var' -- then you apply `(=<<)' to this, to get `Expr Var -> Expr Var', so that you can apply the substitution to other terms than variables
16:52:38 * ion is learning how SQL has something very close to a fixed-point combinator for recursion and when queried with “select … limit …” it behaves like lazy lists.
16:52:43 <ski> (yes, expressions here form a monad :)
16:53:00 <fryguybob> fryguybob: I always think of [a/b] as multiplication b * a / b = a.  But some people mean the opposite...
16:53:36 <ski> fryguybob : yeah, unfortunately there's all kinds of variations in the notation here
16:53:53 <Patinho`Busy> I need some beginners help. anyone have a minute to check my code pls? :/  :)
16:53:59 <ski> fryguybob : do you think that may have been an original motivation for the `[a/b]' notation ?
16:54:18 <ski> (if so, that could be a good way to recall how to interpret that)
16:54:41 <ski> Patinho`Busy : no need to ask to ask, just give a link to your code
16:54:47 <Patinho`Busy> :P
16:54:51 <fryguybob> ski: No idea, but it was the only reasonable motivation I could come up with.
16:54:56 <ski> in case anyone wants to look, and can help, they probably will
16:55:05 <rwbarton> that's certainly a clever way to remember the order
16:55:09 <ski> (otherwise they won't, and you might have to wait longer)
16:55:13 <Patinho`Busy> \o/
16:55:17 <Patinho`Busy> xD
16:55:32 <Patinho`Busy> let me add it on pasteben
16:55:45 <Patinho`Busy> pastebin*
16:55:46 <dgpratt> @where hpaste
16:55:46 <lambdabot> http://hpaste.org/
16:55:52 <ski> fryguybob : there may be something deeper behind that explanation, than just a "dirty" way to remember it ..
16:56:00 <dgpratt> Patinho`Busy: that is preferred for Haskell ^^
16:56:02 <Patinho`Busy> or that
16:56:29 <kulakowski> fryguybob: I've heard the same mnemonic for it
16:56:58 <ski> kulakowski : that's interesting. do you remember any source ?
16:56:58 <hpaste> Nomics pasted “(!!) issue” at http://hpaste.org/55205
16:57:05 <Patinho`Busy> http://hpaste.org/55205
16:57:08 * fryguybob remembers conversion from degrees to radians as pi/180
16:57:10 <Patinho`Busy> \o/
16:57:31 <ben> tau/360 :)
16:57:35 <fryguybob> :D
16:58:23 <ski> Nomics : it's better if you forget about `!!', here
16:58:34 <Nomics> :/
16:58:45 <Nomics> why ?
16:59:02 <Nomics> :/
16:59:08 <ski> let's look at
16:59:17 <ski>   aux2 ((_,_,c):xxs) = ...
16:59:21 <kulakowski> ski: No. Passing comment in a PL class
16:59:28 <ski> and suppose you call this like
16:59:52 <ski>   aux2 [(11,22,[(33,33,33),(44,44,44)]),(55,66,[(77,77,77),(88,88,88)])]
16:59:58 <ski> this is really just sugar for
17:00:11 <ski>   aux2 ((11,22,[(33,33,33),(44,44,44)]) : (55,66,[(77,77,77),(88,88,88)]) : [])
17:00:35 <ski> so, matching this call with the equation head `aux2 ((_,_,c):xxs)' above will yield
17:00:41 <ski>   c = [(33,33,33),(44,44,44)]
17:00:48 <ski>   xss = (55,66,[(77,77,77),(88,88,88)]) : []
17:01:14 <ski> in your comment you stated that you want to return a list of all the `c'-like elements, here
17:01:33 <Nomics> hum... interesting
17:01:33 <ski> i.e. the elements `[(33,33,33),(44,44,44)]',`[(77,77,77),(88,88,88)]' in this case
17:01:42 <ski> so, there is no need to use `!!' here at all
17:01:51 <ski> `c' already contains the list of triples that you want to output
17:02:19 <Nomics> I wanna a list with one triple as output
17:02:23 <ski> and `xss' is the result of the whole input list, which the recursive call will properly translate to a list of the rest triple-lists
17:02:44 <ski>   "So, I tried to create a list: [[(33,33,33),(44,44,44)],[(77,77,77),(88,88,88)]]"
17:02:54 <ski> i interpreted this as you wanting
17:02:59 <ski>   aux2 [(11,22,[(33,33,33),(44,44,44)]),(55,66,[(77,77,77),(88,88,88)])]
17:03:03 <ski> to return
17:03:10 <ski>   [[(33,33,33),(44,44,44)],[(77,77,77),(88,88,88)]]
17:03:26 <ski> in case you want to return something different, you have to say what you want returned
17:03:37 <Nomics> ski ... I dont know how to reach (44,44,44) (for example) frum the full xxs
17:03:39 <Nomics> :S
17:03:50 <ski> are you saying that you want
17:03:53 <ski>   aux2 [(11,22,[(33,33,33),(44,44,44)]),(55,66,[(77,77,77),(88,88,88)])]
17:03:55 <ski> to return
17:03:58 <ski>   (44,44,44)
17:03:59 <ski> ?
17:04:09 <Nomics> So I tried to get [[(33,33,33),(44,44,44)],[(77,77,77),(88,88,88)]] ... and the !!n)!!p
17:04:39 <ski> `!!' can really only be used on lists, you can't use it on tuples
17:04:47 <Nomics> (33,33,33) or (44,44,44) or (77,77,77) or (88,88,88)  <-- one of those
17:05:06 <ski> (and even on lists, it's usually a mistake to use `!!' -- there's usually better ways to do stuff -- and if there isn't, it's usually better not to use lists)
17:05:17 <ski> Nomics : which of them ?
17:05:17 <Nomics> "ghci> ([[(33,33,33),(44,44,44)],[(77,77,77),(88,88,88)]]!!1)!!1
17:05:17 <Nomics> (88,88,88)
17:05:46 <Nomics> one of then, from an index n p
17:06:17 <Nomics> something like: aux2 ((_,_,c):xxs) n p = (c!!n)!!p:aux2 xxs
17:06:25 <ski> hum, actually, i think i was misinterpreting you
17:06:38 <ski> hm
17:07:34 <ski> in that last example, you have a list of lists, so `(... !! n) !!! p' will work
17:07:59 <ski> in your previous example, you have a list of triples, where the last component of each triple is a list
17:08:52 <ski> so, i think you want to (a) access the `n'th triple; (b) access the third component of the triple, which is a list; (c) access the `p'th element of that list
17:08:56 <ski> Nomics : is that right ?
17:09:33 <Nomics> 1 sec... let me read well
17:09:33 <Nomics> xD
17:10:32 <Nomics>  (b) access the third component of the triple, which is a list;   <-- of a long list
17:10:33 <Nomics> :P
17:11:49 <ski> i'm not sure what you mean
17:12:05 <Nomics> [(11,22,[(33,33,33),(44,44,44)]),(55,66,[(77,77,77),(88,88,88)])]  <-- i want to access to 33,33,33 ou 44,44,44 or 77,77,77 or 88,88,88
17:12:14 <ski> yes
17:12:21 <ski> so, this list contains the following elements
17:12:26 <ski>   (11,22,[(33,33,33),(44,44,44)]
17:12:33 <ski>   (55,66,[(77,77,77),(88,88,88)])
17:12:44 <hpc> > let third (_,_,x) = x in join . map third $ [(11,22,[(33,33,33),(44,44,44)]),(55,66,[(77,77,77),(88,88,88)])]
17:12:44 <Nomics> yes
17:12:46 <lambdabot>   [(33,33,33),(44,44,44),(77,77,77),(88,88,88)]
17:12:46 <ski> you want to (a) select one element of these, say the first one
17:13:06 <ski>   (11,22,[(33,33,33),(44,44,44)]
17:13:14 <Nomics> :o
17:13:14 <ski> then, (b) select the last component of the triple
17:13:19 <ski>   [(33,33,33),(44,44,44)]
17:13:38 <ski> lastly, (c) select one the elements of this list, say the second one
17:13:42 <ski>   (44,44,44)
17:13:49 <Nomics> yeap
17:13:53 <ski> ok, good
17:14:02 <Nomics> for example
17:14:05 <Nomics> :)
17:14:44 <ski> Nomics : so, either (A) your code should not match on `[]' and `... : xss', but use `!!'; or (B) should match on those (as you're) doing, but not use `!!' to get the triple
17:14:56 <ski> so, if you write
17:15:13 <ski>   aux2 xss n p = ...(xss !! n)...
17:15:28 <ski> then since `xss' is a list of triples, then `xss !! n' will here be the `n'th triple
17:16:01 <ski> Nomics : so i think your problem is that you were trying to do the same thing in two different ways, simultaneously
17:16:09 <Nomics> xD
17:16:21 <ski> pick one way of doing what you want, then continue solving the rest of what you want to do
17:16:37 <Nomics> that's why I spend like 3h developing this code
17:16:37 <Nomics> xD
17:16:42 <Nomics> lol
17:17:04 <Nomics> thanks sky _o_
17:17:08 <ski> Nomics : to access the last component of the triple, you will want to use one of : (a) a `where'-clause; (b) a helper function; (c) using a `case' expression
17:17:09 <Nomics> thanks ski _o_
17:17:14 <ski> np :)
17:18:41 <ski> Nomics : btw, you should note that when you later will want to *replace* the `n'th element, you will have to do more than using `!!' -- one way is using `take' and `drop' (or `splitAt') as well; another is to define e.g. a `!!<-' function that modifies the `n'th element in any way the user wants to
17:19:15 <Nomics> I will try splitAt
17:19:33 <Peaker> I keep calling that   nth :: Int -> (a -> a) -> [a] -> [a]
17:21:46 <ski> Peaker : hehe, i have been known to say `(!!<-) :: Integral i => [a] -> i -> (a -> a) -> [a]'
17:21:51 <ski> using that, you could write code like
17:22:05 <ski>   (xss !! m) $ \xs ->
17:22:10 <ski>   (xs  !! n) $ \x  ->
17:22:14 <ski>   ..x..
17:22:24 <ski> er, s/!!/!!<-/
17:23:12 <ski> hm, i wonder whether this could be rendered in an indexed continuation monad
17:23:42 <ski> assuming
17:24:49 <ski>   focus :: Integral i => i -> [a] -> Cont2 [a] a a
17:24:54 <ski> one could write something like
17:25:03 <ski>   do xs <- focus m xss
17:25:09 <ski>      x  <- focus n xs
17:25:20 <ski>      return (..x..)
17:26:42 <ski> another useful operation here would be
17:27:05 <ski>   collect :: [a] -> Cont2 [b] b a
17:27:24 <Peaker> ski: I like the SEC view of nth
17:27:44 <ski> Peaker : yes, that is useful for pointless code
17:27:52 * ski was thinking about pointful code
17:28:16 * hackagebot atl 15321.1 - Arrow Transformer Library  http://hackage.haskell.org/package/atl-15321.1 (MatthewFarkasDyck)
17:28:32 <ski> (in case it's not obvious, `collect' is basically `mapM')
17:29:00 <ski> (well, `map', it becomes `mapM' when we generalize `Cont2' to `ContT2')
17:35:34 <m3ga> any enumerator whizzes able to have a look at this? http://hpaste.org/55202
17:37:19 * ski knows almost nothing about enumerators
17:40:35 <irene-knapp> @hoogle iteratee
17:40:35 <lambdabot> package iteratee
17:40:35 <lambdabot> package iteratee-compress
17:40:35 <lambdabot> package iteratee-mtl
17:40:42 <irene-knapp> @hackage iteratee
17:40:42 <lambdabot> http://hackage.haskell.org/package/iteratee
17:40:56 <irene-knapp> bah, stupid link, be more clickable :(
17:41:33 <ion> Huh? It’s perfectly clickable. :-)
17:42:00 <irene-knapp> only to you!  to me it's inside irssi which is inside screen which is inside Terminal.app, and all three of those layers independently prevent clickability
17:42:25 <m3ga> the package i'm using is called enumerator (the other main iteratee impementation).
17:42:28 * ski isn't sure what irssi and screen has to do with it
17:42:30 <irene-knapp> or fail to enable it, I suppose, since its presence would be a feature, rather than its absence being a bug
17:42:32 <mike-burns> Sounds like Terminal.app is the issue.
17:42:42 <mike-burns> I can ctrl-click on it just fine.
17:42:48 <irene-knapp> anyway, I wasn't answering your question - I was trying to figure out where to start in my own iteratee research :)
17:42:50 <ion> Screen and irssi shouldn’t affect it at all. It’s most likely the terminal.
17:42:58 <irene-knapp> hm
17:43:04 <irene-knapp> look at that!  right-click actually works ^^''''
17:43:06 <irene-knapp> I had no idea ^^''''
17:43:34 <mike-burns> Hah; sounds like it wasn't a software problem at all.
17:43:37 <irene-knapp> haha
17:43:42 <irene-knapp> yes - between keyboard and chair
17:43:50 * ski grins
17:43:51 <Nomics> ski you talked about aux functions... and check it: http://hpaste.org/55206
17:43:57 <Nomics> \o/
17:44:06 <Nomics> working
17:44:07 <Nomics> xD
17:44:34 <ski> Nomics : hehe, next time, annotate the original paste with updates :)
17:44:46 <Nomics> i can update?
17:44:47 <Nomics> :o
17:44:56 <Nomics> didnt knew
17:44:58 <Nomics> :/
17:45:24 <Nomics> now I do
17:45:26 <Nomics> :)
17:45:35 <ski> Nomics : you can annotate, so that the new version will appear on the same page as the original one
17:46:08 <ski> (you can't actually update an existing paste, it will always create a new one -- the point is that they can be linked, so that you can easily compare the old and the new one)
17:46:33 <ski> Nomics : note that you can write `aux2' there using `map', instead of using recursion directly
17:46:40 <Nomics> it's always better
17:46:43 <shachaf> ski: Sounds appropriate for Haskell.
17:46:53 <ski> shachaf :)
17:48:15 <ski> Nomics : in fact, the could could be written without either using `map', or any recursive helper function
17:48:49 <ski> Nomics : if you want, you could ponder how one could do that -- otherwise continue with the next exercise or whatever you want to do
17:49:06 <Nomics> :|
17:49:39 <Nomics> now.. you make me thinking ski
17:50:24 <Nomics> and i was already tinking on my next step: I still have no idea about how to change the 3-tuple!
17:50:24 <ski> Nomics : ty :)
17:50:25 <Nomics> xD
17:50:38 <Nomics> ! but… a few hours ago, I also didn’t knew how to access the 3-tuple
17:50:39 <Nomics> lol
17:51:13 <ski> you see that your current `aux3' accesses the component of the triple, by matching on the pattern `(_,_,c)'
17:51:43 <ski> as hpc mentioned a bit up, you could define something like
17:51:44 <ski>   third (_,_,x) = x
17:51:49 <Nomics> should be pretty much the same thing
17:51:57 <Nomics> yeap
17:52:10 <ski> then your current `aux2' could easily be written in terms of `map' and that
17:52:24 <ski> (if you don't see imeeadiately how to do that, you might want to try to do that)
17:53:31 <Nomics> tit makes since using map on aux2. but I learned the map function last week... I have to study it a bit more
17:53:41 <Nomics> it makes since using map on aux2. but I learned the map function last week... I have to study it a bit more
17:54:03 <ski> (itym s/since/sense/)
17:54:35 <mike-burns> Surely there's a better name than `third'.
17:55:49 <ski> mike-burns : maybe you'd prefer `thd3', as Gofer had it (iirc) ?
17:55:57 <kulakowski> fst, snd, _?
17:56:11 <ski> (i.e. `fst3',`snd3',`thd3')
17:56:34 <MostAwesomeDude> fst, snd, thd
17:56:36 <mike-burns> I was thinking `temperatures', `user_ids', or the like.
17:56:43 <MostAwesomeDude> Always expands in my head to fist, sound, thud.
17:56:52 <MostAwesomeDude> I suppose that fists do make a "thud"-like sound.
17:58:30 <ski> @let modFun :: Eq a => (a,b) -> (a -> b) -> (a -> b); modFun (a0,b0) f a | a0 == a = b0 | otherwise = f a
17:58:32 <lambdabot>  Defined.
17:58:56 <ski> (apropos SEC)
18:01:11 <ski> @let modFunRes :: Eq a => a -> (b -> b) -> (a -> b) -> (a -> b); modFunRes a0 g f a | a0 == a = g (f a) | otherwise = f a
18:01:12 <lambdabot>  Defined.
18:02:11 <irene-knapp> @hackage utf8-string
18:02:11 <lambdabot> http://hackage.haskell.org/package/utf8-string
18:07:32 <Nomics> btw ski ... sorry about my bad english. I only had 3 years of enghish at school (when I have 13, 14 an 15 years old) ... considering that… I manage it pretty well!
18:07:34 <Nomics> :P
18:10:57 <Nomics> (i choose French as main foreign language  ß bad choice , btw)
18:10:59 <Nomics> :S
18:23:22 <ski> Nomics : i didn't notice any particular language problem. there are others which are much harder to understand
18:23:34 <Nomics> :)))
18:23:42 <Nomics> thanks
18:25:19 <ski> (i'm not a native speaker either. annoyingly i still relatively often do common silly mistakes which i usually realize just after i've sent a message)
18:26:54 <ski> (such as writing "it's" when i mean "its", or even "you're" when i mean "your" -- i know which is the correct one, but apparently my brain likes to misfire things like this when i'm just trying to express something)
18:28:38 <mike-burns> Native speakers do that often, too.
18:28:51 <vrook> Younger Americans don't seem to know or care about "its" vs "it's". In fact I suspect they no longer read books, in general.
18:29:38 <mike-burns> Harsh.
18:29:43 <salisbury> As a younger-ish Canadian who travels to America frequently I can confirm this
18:30:11 <salisbury> I read quite a bit, but the large majority of people I know my age do not..
18:30:15 <ddarius> My research has shown that most people on IRC cannot read at all.
18:30:24 <copumpkin> wat
18:30:26 <mike-burns> And they also can't use search engines.
18:30:38 <copumpkin> its grammer and its easy
18:31:17 <mike-burns> The person I know who reads the most also can't use "its" or "it's" properly.
18:31:35 <MostAwesomeDude> English is hard.
18:31:37 <fryguybob> its true!
18:31:46 * ski also tries to use "who" vs. "whom" correctly ..
18:31:52 <salisbury> I made an attempt to learn German
18:31:56 <salisbury> that is quite hard
18:32:03 <ski> (.. but afaicu, many people ignore that)
18:32:31 <mike-burns> http://goo.gl/AFVw2 - here's an interesting article about spelling and typos WRT book publishing.
18:32:37 <shachaf> ski: People whom ignore that are at least better than people whom overcorrect themselves.
18:32:54 <ski> hehe, yah
18:32:54 <MostAwesomeDude> shachaf: Ouch, that hurts, stop it!
18:33:32 <vrook> I rebel against the periods inside quotes "like this." It's standard American English.
18:33:54 <mike-burns> In general: typing is hard, and there's no need to be a dick about it to strangers on the Internet.
18:34:30 <ski> (there's a similar thing in swedish where older people use "de" vs. "dem", which are often usually pronounced (colloquially) as "dom". younger people usually can't distinguish between "de" and "dem". it's ok to write "dom", but it's not ok to write "dem" if you mean "de")
18:35:01 <ski> vrook : *nod*, i refuse to do that, as well
18:36:20 <mike-burns> The Swedes I've met know English well.
18:37:07 <mike-burns> They should teach English in America as well as they do in Sweden, basically.
18:37:09 <vrook> So I was looking at Data.List code and found a few gems. I imagined "reverse" in the usual Schemish tail-call way, but the nicer implementation is foldl (flip (:)) [].
18:38:33 <ski> mike-burns : yeah, but i've heard it said that englishmen think we sound scottish :)
18:39:05 <mike-burns> Hah! ... yeah, I can see that actually.
18:39:14 <ski> vrook : yeah, `foldl' is tail-recursive
18:40:25 <salisbury> when is a situation when foldr is better than foldl?
18:40:49 <vrook> when you want to implement reverse?
18:41:18 <copumpkin> foldl is actually the one you use for reverse
18:41:45 <copumpkin> salisbury: any time you want to produce a value lazily
18:41:53 <fryguybob> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
18:42:54 <salisbury> I work with really big data, so I usually use foldl out of fear of stack overflow
18:42:57 <vrook> ski: do you mean foldl' is tail recursive?
18:43:18 <Axman6> vrook: foldl and foldl' are both tail recursive
18:44:03 <Axman6> salisbury: if you eant to be able to stop processing the list early, like in the function and, which takes a list of Bools and tells you whether they're all true. if one isn't, youwant to return immediately with False
18:44:08 <Axman6> @src and
18:44:08 <lambdabot> and   =  foldr (&&) True
18:44:23 <Axman6> > and [False,undefined]
18:44:24 <lambdabot>   False
18:44:46 <vrook> Axman6: but foldl builds intermediates, as explained in the wiki link above.
18:45:00 <salisbury> hmm, seems I should be using foldl' actually..
18:45:02 <Axman6> vrook: doesn't mean it's not tail recursive
18:45:26 <Axman6> salisbury: the more interesting question is when to use foldl instead of foldl', and the answer is: almost never ;)
18:46:06 <salisbury> *goes off to gsub foldl for fold' in all haskell source files I have written
18:46:13 <vrook> Yeah but it's an unusual technical difference. I tend to equate tail recursion with transforming into a constant-space loop.
18:46:25 <vrook> I realize they aren't exactly the same, but people tend to conflate them.
18:46:39 <Axman6> it is, in a way. it's constant stack space anyway.
18:46:52 <Axman6> and that's usually what you mean by constant space loop
18:47:19 <vrook> But isn't Haskell's laziness generating data on the heap, not the stack?
18:47:23 <Axman6> you can have a tail recursive function which builds a linked list in C, and it'll use constant stack space, but obviously not heap space
18:47:45 <vrook> Look at the foldl explanation on the wiki
18:48:02 <copumpkin> vrook: in haskell almost everything happens on the heap, except for forcing thunks
18:49:16 <vrook> Axman6: but that's a bad analogy. In this circumstance foldl' does not create heap objects but foldl does.
18:49:27 <vrook> That's why I said it's tied to laziness.
18:50:05 <Axman6> vrook: the difference between foldl and foldl' is that foldl' forces the accumulating parameter to weak head normal form at each recursive step. that _may_ mean you're not allocating as much, if say your accumulating parameter is a number, and you're summing a list you'll always only have that one number evaluated, instead of a thunk representing the whole sum so far
18:50:19 <Axman6> foldl' certainly does creat heap objects
18:50:23 <Axman6> create*
18:50:32 <u_> are lenses and views sort of the same thing?
18:50:57 <Axman6> :t foldl
18:50:58 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
18:51:29 <Axman6> foldl' (\xs x -> x:xs) [] [1,2,3] -- where do you think that list is created of not on the heap?
18:51:44 <Axman6> > foldl' (\xs x -> x:xs) [] [1,2,3]
18:51:45 <lambdabot>   [3,2,1]
18:51:55 <salisbury> so does that mean you can simulate foldl' with evaluate + foldl
18:52:08 <salisbury> albeit with the introduction of IO..
18:52:13 <vrook> Axman6: C'mon, obviously I couldn't have meant no heap objects anywhere. I'm talking about the intermediates.
18:52:19 <vrook> ... due to laziness.
18:52:48 <Axman6> vrook: what happens with the list in my example for both foldl and foldl' is exactly the same
18:52:58 <Axman6> the intermediates are allocated on the heap
18:53:20 <vrook> Axman6: is the foldl section of the haskell wiki wrong, then?
18:53:36 <vrook> "But instead of being directly reduced, they are allocated on the heap..."
18:53:39 <Axman6> probably not, but i think your understand is
18:54:11 <Axman6> foldl' will recude things more than foldl (unless the compiler see the strictness of the result, but that's another matter)
18:55:12 <salisbury> Is it that, the weak head normal form of the intermediate will be on the heap, rather than the yet-to-be evaluated intermediate function?
18:56:37 <Axman6> ok, so i guess explaining WHNF is important. WHNF is when something has been evaluated enough to tell what constructor is has. so if you've got xs :: [Int], then evaluating xs to WHNF will mean it's been evaluated far enough to tell whether it's _:_ or [], but it does not evaluate any more than that
18:57:26 <salisbury> ahh, I see
18:57:38 <Axman6> HNF is when the whole structure has been evaluated as much as possible (I think). so, for lists, xs would be evaluated to say (1:2:3:[]) under hnf, but only to _:_ under whnf
18:58:23 <vrook> Well I think NF is the whole structure, HNF is the whole head, WHNF is special forms of the head.
18:58:44 <vrook> ... being fully evaluated
18:59:12 <Axman6> uh, yeah i meand NF not HNF before
18:59:16 <Axman6> meant*
19:00:52 <c_wraith> vrook: the difference between HNF and WHNF is how they treat values that are functions.  WHNF just stops.  HNF converts the body of the functions to HNF recursively.
19:01:32 <salisbury> I should really do some in depth lambda calculus
19:01:54 <tromp> weak: don't reduce under abstraction.    head: don't reduce arguments
19:03:29 <ddarius> normal: don't reduce under the influence
19:10:24 <mike-burns> salisbury: http://trylambda.com/ !
19:11:20 <vrook> I was using the ST monad and come to a place where I realized I needed the Random monad, so I used the transformer to combine them. It's not exactly a trivial change, and the resulting code is less clear. But what if I changed my mind later and removed the Random monad? Those changes become wasted.
19:11:26 <vrook> *came to a place
19:12:23 <vrook> It seems things can be a bit impractical at times.
19:12:45 <DukeDave> Erm, in cabal's simple build system, is there any way to get 'information' on the resolved dependencies..
19:12:45 <DukeDave> I.e. cabal knows what my package depends on, and it resolves those dependencies; can I found out 'where' each dependency lives?
19:12:51 <int> Hello, I have a question. Does GHCi cap the amount of memory I can use for my program? If yes, how do I get more?
19:15:02 <Axman6> it didn't use to, i'm not sure if it does. if you need lots of memory however, you should not be using ghci, but compile your program instead
19:19:59 <bashoo> so
19:20:06 <bashoo> I'm trying to do project euler
19:20:10 <bashoo> problem 1
19:20:58 <Axman6> congrats
19:21:33 <bashoo> not so fast Axman6
19:21:48 <ski> vrook : you could abstract your monad into a new name, and make sure only a few primitives depend on the actual implementation
19:22:16 <bashoo> I made a list comprehension with a predicate of mod 3 == 0  and another with mod 5 == 0
19:22:28 <bashoo> and took sums and added them together but it isn't right apparently
19:23:41 <mike-burns> Can you paste something, bashoo ? I didn't quite follow.
19:23:49 <bashoo> ok
19:24:10 <bashoo> *Main> let bob = [ x | x <- [1..999], mod x 3 == 0]
19:24:12 <bashoo> (0.00 secs, 1579980 bytes)
19:24:13 <bashoo> *Main> let bob' = [ x | x <- [1..999], mod x 5 == 0]
19:24:15 <bashoo> (0.00 secs, 1580248 bytes)
19:24:22 <bashoo> sum bob + sum bob'
19:24:25 <mike-burns> Ah.
19:24:43 <Axman6> bashoo: what about 15? it's divisable by 3 and 5
19:24:54 <bashoo> ah
19:25:05 <salisbury> mike-burns: would likely lambda calc be covered if I bought a book on programming language theory?
19:25:06 <bashoo> thanks
19:25:10 <Axman6> you can use (||) to or twp booleans together:
19:25:21 <bashoo> ok I'll look into that
19:25:37 * ski str TaPL has some basic lambda calculus at the start
19:25:39 <Axman6> > sum [x \ x <- [1..999], mod x 3 == 0 || mod x 5 == 0]
19:25:39 <lambdabot>   <no location info>: parse error on input `\'
19:25:46 <Axman6> > sum [x \ x <- [1..999], mod x 3 == 0 || mod x 5 == 0]
19:25:47 <lambdabot>   <no location info>: parse error on input `\'
19:25:52 <Axman6> > sum [x | x <- [1..999], mod x 3 == 0 || mod x 5 == 0]
19:25:53 <lambdabot>   233168
19:25:53 <Axman6> -_-
19:26:05 <bashoo> so || is "or"
19:26:14 <ski> yes
19:29:22 <incluye> you know...logical operators
19:33:10 <ion> > let tri n = n*(n+1) `div` 2 in 3 * tri (999 `div` 3) + 5 * tri (999 `div` 5) - 15 * tri (999 `div` 15)
19:33:10 <lambdabot>   233168
19:35:01 <ion> > let tri n = n*(n+1) `div` 2; triMod n d = d * tri (n `div` d) in 999 `triMod` 3 + 999 `triMod` 5 - 999 `triMod` (3*5)
19:35:01 <lambdabot>   233168
19:35:04 <ion> 233168
19:41:28 <vrook> any f = or . map f -- is there a point-free form of this?
19:41:47 <bashoo> can anyone recommend a good book on haskell? or reference?
19:42:03 <ion> vrook: Yes, but that one is clearer.
19:42:06 <ion> @pl \f -> or . map f
19:42:06 <lambdabot> any
19:42:15 <ion> @pl \f -> foo . bar f
19:42:15 <lambdabot> (foo .) . bar
19:42:49 <tensorpudding> i think real world haskell is still the go-to book for haskell
19:42:50 <vrook> nice. what is pl?
19:42:52 <tensorpudding> is it not?
19:43:06 <ion> @hackage pointfree
19:43:06 <lambdabot> http://hackage.haskell.org/package/pointfree
19:43:27 <bashoo> I'll check it out, thanks
19:43:33 <tensorpudding> it's a plugin that finds pointfree versions of lambda expressions
19:44:31 <ion> There’s a point-free form of any lambda expression, but obviously one should reduce points only when it makes the code *more* readable.
19:45:06 <ski> vrook : `any = or .: map'
19:45:22 <ski> @help pl
19:45:23 <lambdabot> pointless <expr>. Play with pointfree code.
19:45:33 <ion> @pl \a b c d e f g h -> h e a d c a b b a g e
19:45:36 <lambdabot> ((((const .) .) .) .) . flip flip id . ((flip . ((flip . ((ap . (flip .)) .)) .)) .) . (((((flip .) .) .) .) .) . ((((flip .) .) .) .) . join (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((
19:45:37 <lambdabot> flip .) .) .) .) . join . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . flip . (flip .) . ((flip .) .) . (((flip .) .) .) . join (flip . (flip .) . ((flip .) .) . (((flip .) .)
19:45:37 <lambdabot> .) . flip . (flip .) . ((flip .) .) . flip . (flip .) . flip (flip . flip id)))
19:45:37 <lambdabot> optimization suspended, use @pl-resume to continue.
19:45:41 <tensorpudding> @source (.:)
19:45:41 <lambdabot> (.:) not available
19:45:49 <tensorpudding> whats .:
19:45:53 <ion> (.:) = (.).(.)
19:45:58 <ski>   (g .: f) a b = g (f a b)
19:46:11 <ski> (both are correct)
19:46:19 <tensorpudding> more haskell line noise
19:46:23 <ski> indeed
19:46:25 <tensorpudding> well
19:46:29 <tensorpudding> ticker tape noise
19:47:02 <ski> (you'll have to blame me for inventing `.:', though)
19:47:07 <tensorpudding> need to rewrite haskell in braille
19:47:16 <tensorpudding> braillskell
19:47:20 <ski> (well, probably people have thought of it before me. i gave it this name, though)
19:48:24 <vrook> It should have a bird name since it sorta like owl.
19:49:14 <salisbury> ski: TaPL = Types and programming languages?
19:49:34 <ski> yes
19:49:36 <ski> @where TaPL
19:49:37 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
19:50:12 <ski> i think Henk Barendregt has some kind of large book thing about lambda calculus
19:50:25 <ski> vrook : "owl" ?
19:51:07 <tensorpudding> awl
19:51:21 <vrook> ski: owl is ((.)$(.))
19:51:28 <ski> why ?
19:51:34 <vrook> because it looks like an owl
19:51:37 <ski> (or, who says ?)
19:51:45 <ski> ok
19:52:02 * ski thought that this was maybe some bird-name from combinatory calculus
19:52:22 <ski> (see "How to Mock a Mockingbird", with lark, &c.)
19:52:44 <thetallguy> Suppose I am given:   newtype  A x a = A a.  I make can easily make  (A x) an instance of functor.
19:52:59 <vrook> It's like the pattern match (_:_) which is called "female".
19:53:00 <thetallguy> But what if I am given:  newtype B b x = B b
19:53:27 <thetallguy> how do I make B a functor over b?
19:53:28 <shachaf> thetallguy: Well, (B b) isn't an instance of Functor.
19:53:40 <shachaf> thetallguy: You can use newtype Flip a b c = Flip (a c b)
19:54:15 <thetallguy> Then I have to wrap my B's in Flips all the time, right?
19:54:19 <shachaf> But the extra newtype will probably be annoying.
19:54:22 <shachaf> Yep.
19:54:51 <thetallguy> That's what I thought.
19:55:17 <thetallguy> I think it was shorthand.
19:58:52 <thetallguy> no, not shorthand.
19:59:27 <shachaf> thetallguy: ?
20:00:03 <thetallguy> the source doesn't declare a functor, just Traversable
20:00:31 <shachaf> thetallguy: Wait, what am I talking about?
20:00:41 <shachaf> (B b) is an instance of Functor. Just not an interesting one.
20:00:49 <thetallguy> instance Traversable (B b) where traverse f (C c) = pure (C c)
20:01:11 <thetallguy> shachaf: Right.  The functor parameter is a phantom
20:01:57 <thetallguy> so, I naturally wanted to move the phantom into the first position to make the functor on the concrete parameter
20:02:05 <thetallguy> but that's definitely not what's going
20:02:06 <thetallguy> on
20:02:38 <thetallguy> I must puzzle on why one would traverse over a phantom type parameter
20:02:55 <ski> what you want is `instance Functor (\b -> B b x)'
20:03:05 <ski> but you can't do that directly
20:03:06 <shachaf> ski: That's Flip. :-)
20:03:11 <thetallguy> ski: yeah, that's what shachaf offered
20:03:18 <ski> shachaf : no, it's a type lambda
20:03:21 <thetallguy> but that's not what the author is doing
20:03:23 <shachaf> But you need a constructor.
20:03:33 <shachaf> ski: Well, it's Flip if Flip was a type lambda.
20:03:34 <shachaf> Which it's not.
20:03:41 <ski> yeah :)
20:03:42 <shachaf> ...So I guess it's not Flip.
20:04:25 <thetallguy> look at the definition of Traverse instance of B b
20:04:39 <thetallguy> sorry, that should be B b throughout, not C c.
20:05:19 <thetallguy> newtype B b x = B b ; instance Traversable (B b) where   traverse f (B b) = pure (B b)
20:05:32 <thetallguy> f is omitted from the right hand side of traverse
20:06:26 <ski>   traverse f = pure
20:06:33 <thetallguy> yup
20:06:40 <thetallguy> it's just a phantom traversal
20:07:09 <ski> because `x' is a phantom parameter, yes
20:07:18 <thetallguy> Okay, I thought it was broken syntax, but in fact it's a different animal than I thought altogether.
20:07:19 <ski> hm
20:07:30 <ski> @type Data.Traversable.traverse
20:07:31 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
20:07:47 <ski> i suppose `traverse f = pure' will actually not work
20:08:19 * hackagebot attoparsec 0.10.1.0 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.10.1.0 (BryanOSullivan)
20:08:31 <ski> (for similar reasons as why `ma@(Left _) >>= _ = ma' doesn't work for `Monad (Either e)')
20:08:56 <thetallguy> yeah, I tried to implement this with standard Traversable, and it wanted a Functor instance....
20:09:05 <thetallguy> which is how I got started on this
20:09:33 <thetallguy> I must puzzle till my puzzler is sore, clearly.
20:15:51 <salisbury> all of these type theory books are so expensive
20:16:19 <ezyang> Libraries are awesome.
20:16:52 <shachaf> ezyang: Except when they don't allow you to check out any books. :-(
20:17:32 <salisbury> they are.. unfortunately I live in the countryside
20:18:19 * hackagebot HDBC-mysql 0.6.6.0 - MySQL driver for HDBC  http://hackage.haskell.org/package/HDBC-mysql-0.6.6.0 (BryanOSullivan)
20:18:20 <salisbury> is TaPL the most widely recommended?
20:18:43 <ski> i think so
20:18:54 <ski> there's probably papers you could read
20:18:58 <ski> (that's what i did)
20:19:22 * ski can't recall any particular papers to read, though
20:20:06 <salisbury> I'll look into it,
20:20:11 <ski> well, i recall reading "Polymorphic Type Inference" by Michael Schwartzbach in 1995-01 at <http://cs.au.dk/~mis/typeinf.pdf>
20:20:32 <ski> but maybe that assumes too much out of the reader, in this case
20:20:52 <vrook> The :load command in ghci causes other loads to be forgotten. Is there a cumulative load command?
20:20:59 <salisbury> that could be a good thing, in that it directs me towards what I should be reading first
20:21:11 <salisbury> so that I'm not entirely flailing in the dark
20:21:20 * ski mostly read various papers by Wadler, Peyton-Jones, hudak, &c. &c., until it all "clicked"
20:22:16 * BMeph enjoys a Mark Jones selection, as well...
20:22:36 <salisbury> I've gotten all excited now. I think this knowledge will be really useful to my research
20:22:43 <ski> (i remember reading someone on comp.lang.functional explaining that the horizontal bars in typing rules should be read as "if .. and .. and .. then .." -- that helped quite a lot with deciphering the papers)
20:22:56 * ski wonders what salisbury is researching
20:23:13 <salisbury> patterns of information distribution
20:23:28 <salisbury> specifically within the blogosphere
20:23:37 <ski> ok
20:23:43 <ski> (that doesn't tell me very much :)
20:24:58 <salisbury> basically, trying to develop a system/algorithm/whatever that can predict the perceived relevance of an article
20:26:42 <salisbury> and therefore predict how the information contained in that article will spread or not spread
20:27:42 <salisbury> for example, smaller news companies need to buy stories from AP, Reuters etc... and this system can help them select stories that will drive readership, rather than duds
20:29:13 <ski> vrook : you can specify more than one file to load with `:l' (`:load')
20:29:27 <ski> (Hugs also has an `:a' (`:also') command)
20:29:47 <ski> salisbury : ok
20:30:04 <vrook> ski: well this is for inf-haskell. I want to Ctrl-l two files and have ghci remember both.
20:30:32 <ski> BMeph : *nod*, i'm sure i read more authors too, just mentioning the ones i could recall immediately
20:30:33 <shachaf> I once tried to pull dirty tricks with ghci to switch type class instances in mid-program.
20:30:59 <shachaf> I never got it to work properly. :-(
20:32:00 <ski> (e.g. i read a lot of papers on continuations as well, and some staged programming. Olivier Danvy, Julia Lawall, Hayo Thielecke, Andrzej Filinski, Will Clinger, &c.)
20:33:13 <ski> salisbury : hehe, (obviously) i think knowledge about type theory is fun and cool, but i'm wondering how you're thinking it will help (more specifically) with what you're wanting to do
20:33:43 <ski> (of course i think type theory can in general make one's thinking in some aspect less muddled, but i'm wondering if there's any more specific gains)
20:34:08 * ski has no idea what `inf-haskell' is
20:34:35 <ski> vrook : but Hugs' `:also' command will do that -- i'm not sure why GHCi doesn't have such a command
20:37:55 <mateu> I'm reading an example that says: ghc -c MyModule.hs  will only generate object code (and not complain about main missing), but that is not the case.
20:38:37 <shachaf> mateu: You have to name your module something other than Main.
20:41:26 <salisbury> ski: it involves a lot of natural language processing. Creating a specific type system for the different features extracted from texts may provide insights
20:42:39 <ski> ok
20:43:03 <vrook> Is there an inferior-haskell feature which will insert the type of a function which has been loaded? I've been cutting and pasting the :t output like a caveman.
20:43:08 <ski> salisbury : if you're doing natural language processing, you might maybe want to talk to augur (or maybe not)
20:43:14 <ski> (augur is a linguist)
20:43:18 <augur> hello!
20:43:24 <ski> hello augur
20:43:26 <augur> if you're into NLP dont talk to me :(
20:43:30 * ski grins
20:43:31 <augur> hey that rhymes
20:43:32 * mateu was missing the module declaration, duh.
20:43:54 * ski isn't into Neuro-Linguistic Programming
20:43:56 <Jafet> vrook: insert the type where?
20:44:12 <Jafet> The type is already in your code, right?
20:44:13 <salisbury> hey augur, perhaps haskell-overflow?
20:44:21 <salisbury> if you have time
20:45:05 <ski> salisbury : well, i was mostly mentioning augur because *maybe* he knows better references of where to look for stuff about NLP
20:45:09 <vrook> Jafet: Sometimes I don't write the type and paste it in later.
20:45:22 <augur> saati_: why not here?
20:45:24 <vrook> just looking for an "auto-paste" feature instead of caveman copy&paste
20:45:25 <augur> ..
20:45:28 <augur> salisbury: ^
20:45:46 <Jafet> vrook: most people write the types first, so there usually isn't any need for that
20:46:03 <salisbury> augur: well, it's not directly haskell
20:46:07 <augur> thats ok
20:46:40 <Jafet> vrook: why do you want the types from ghci, anyway? You get gunk like (a -> a3 -> a2) -> (a3 -> a2)
20:47:05 <Jafet> Which is worth nothing more than not having a type signature in the first place
20:47:06 <shachaf> Jafet: That's because ghci is stupid about type names. :-(
20:47:18 <shachaf> Jafet: It's worth a litle more, if you want to, say, modify the type.
20:47:31 <shachaf> Or even just so that you can see what the type is without having to check the types of all the values.
20:48:03 <Jafet> But he's already written the code, and then he wants the type of the code.
20:48:36 <salisbury> augur: well, my current approach is based on clustering. I use a viterbi-like algorithm to tag parts of speech. Then I rank nouns based on their frequency in an article
20:48:52 <shachaf> Jafet: Right.
20:49:24 <Jafet> The only time you need to do that is when you're doing something so abstract that you don't know what the types are
20:50:36 <salisbury> Then the nouns are clustered to be 'nearer' to one another, and the articles are clustered based on the relationships their nouns have
20:51:09 <shachaf> Jafet: It doesn't have to be abstract for the types to be helpful.
20:51:09 <vrook> Jafet: I mention it because I was recently using a monad transformer and it was just unwieldy; the whole signature took up more than 80 columns. It was easier to just omit types initially and paste them in later.
20:51:48 <vrook> ghci knows the correct info, why should I spend one second reproducing it?
20:52:04 <salisbury> But this manner of determining relationships between texts is rather .. flat
20:52:08 <Jafet> But, why would you need the type signature in your code?
20:52:14 * ski think it's interesting that John Hughes usually doesn't write type signatures at all
20:52:15 <Jafet> Just to appease -Wall?
20:53:38 <vrook> Jafet: I guess I was following what I perceived as "best practice", which is to write types for top-level things.
20:54:04 <vrook> Maybe that's not really important
20:54:42 <vrook> Given that something can be inferred, is it best practice to omit the type?
20:55:04 <vrook> I think eventually you want to type it.
20:55:40 <Jafet> Having some emacs script to write the type for you strikes me as missing the point of that practice
20:55:55 <salisbury> augur: I'm trying to instead devise a system that could instead identify noun-articles (articles about things) with verb-articles (articles about actions with things)
20:56:18 <Jafet> Gunk with autogenerated type variables conveys no additional meaning, because anyone reading your code can just obtain that gunk with ghci.
20:56:20 <augur> salisbury: yyyeah. cant help you with this, sorry
20:56:49 <wavewave> i wish ghc warns missing top-level signature for exported  symbol.
20:56:54 <salisbury> urg..
20:57:10 <wavewave> exported symbol only
20:57:16 <augur> i dont do NLP
20:57:46 <vrook> Jafet: Well again this is in context of a 100-column monad transformer type. The purpose is not to paste the ghci output and be done with it, but to use it as an automatically-correct starting point.
20:58:14 <ski> augur : sorry if i afflicted you with someone wanting to do something vaguely linguistics-related, whose topic you're not interested it
20:58:40 <augur> hes not doing anything vaguely linguistics-related. :P
20:58:41 <ski> (i was just thinking that you maybe had any pointers)
20:58:48 <augur> NLP is pure states
20:58:53 <augur> stats*
20:58:57 <Jafet> vrook: well, I suppose you'll need some emacs script to do it.
20:59:04 <augur> and machine learning
20:59:10 <ski> it's about (natural) language, ergo linguistics related
20:59:14 <augur> its incidental that the thing being learned is patterns in language
20:59:20 <augur> no, ergo not linguistics
20:59:30 <augur> "about natural language" does not mean "linguistics related"
20:59:34 <Jafet> You can use knowledge of linguistics to improve NLP.
20:59:41 <augur> Jafet: yes, but people dont.
20:59:52 <Jafet> Huh, why don't they?
20:59:58 <ski> augur : maybe there's some linguistics literature about doing it ..
21:00:54 <augur> Jafet: because a) NLPers are software engineers and seek only to model particular data, not discover principles of language organization, or even discover truths about the language in question
21:01:16 <augur> and because b) raw computation can get you pretty far right now with very dumb underlying models
21:01:39 <ski> i can well believe b)
21:01:48 <augur> PCFGs + time get you parsers with 85+% accuracy right now
21:02:32 <augur> its stalling at around there, i think, and prospects are hopeless, but thats irrelevant for most purposes
21:02:38 <Jafet> Well, I suspect neurons have a dumb underlying model
21:02:54 <augur> Jafet: yes so do transistors
21:02:57 <augur> you're missing the point
21:03:30 * ski takes a seat, grabs box of cookies
21:03:56 * Jafet exeunt
21:06:05 <salisbury> augur: what do you mean when you say language organization
21:08:56 <augur> salisbury: the fundamental principles that govern how all human languages work
21:09:46 <augur> roughly, you can think of this as the maximum complexity required for whatever machine/grammar you're running your ML techniques on
21:15:38 <salisbury> Hmm, I suppose then that what I am doing does not contribute towards linguistics. I do believe, though, that it can benefit from learning in that field
21:16:13 <salisbury> I was under the impression that techniques such as part of speech tagging fall within the bounds of linguistics, though
21:17:40 <periodic> Real quick, any thoughts on what libraries to go with for GUI programming, specifically with Windows?
21:18:42 <periodic> I see GTK is covered in RWH
21:23:17 <wavewave> periodic : I don't know about windows GUI. Did you give a try to wxWidget?
21:23:29 <periodic> I used wxWidget once in the past.
21:23:34 <periodic> But that was over a year ago.
21:23:41 <periodic> maybe two.
21:23:53 <wavewave> I guess wxWidget is more cross-platform in its design.
21:24:01 <periodic> Figured I'd see if people had any thoughts on what libraries have matured to a good place.
21:24:21 <wavewave> gtk2hs is mature in X11 land.
21:24:22 <periodic> okay, I'll take a look.
21:24:40 <wavewave> qthaskell seems not usable
21:24:42 <periodic> And thankfully I don't need a very complicated GUI, so I don't need anything like a fancy glade system.
21:25:04 <wavewave> try gtk2hs with cygwin.
21:25:07 <periodic> I just need to give windows users  a way to see the output of the program.  *nix users are generally comfortable with running things in a terminal
21:25:32 <wavewave> I doubt native gtk binding to windows works well.
21:26:00 <wavewave> hmm if your purpose is for other people, cygwin solution is not good.
21:26:06 <periodic> Well, thanks for the info.  I'll dive into wxWidget and I'll be back if it doesn't work. :)
21:26:11 <periodic> Yeah, no cygwin
21:26:26 <periodic> I have a bunch of parser code in Haskell already.
21:26:38 <periodic> So I just want to wrap a small gui around it as it does some uploads
21:26:53 <periodic> Which is the reason I'm using Haskell and not native windows stuff.
21:27:06 <periodic> That and I don't really know windows programming in general...
21:27:50 <wavewave> hmm wxHaskell is pretty dead in activity
21:28:26 <wavewave> but at least screenshot shows Windows apps. so probably it's in working condition.
21:28:41 <periodic> I know I built hello-world in it once...
21:28:48 <periodic> So it does work.
21:29:13 <wavewave> okay.. i guess the situation did not change at all from your last run on, I guess.
21:30:11 <periodic> I was hoping for some super-awesome-easy-to-user-and-full-of-functional-paradigms library had come along in the mean time.
21:30:13 <periodic> Oh well. :P
21:30:17 <periodic> I don't have the time or skill to write one.
21:30:39 <ski> Fudgets is interesting
21:30:54 <ski> (but i think noone has been working on it for some time)
21:31:10 <wavewave> yeah.. support for windows haskell programming looks pretty daunting.
21:32:00 <wavewave> I also remember that conal was complaining about windows gui programming in haskell.
21:32:57 <wavewave> periodic: if you have a chance, see http://www.haskell.org/haskellwiki/GuiTV
21:33:00 <periodic> gui programming in general is problematic...
21:33:23 <wavewave> give a try to GuiTV ;-)
21:33:31 <wavewave> Phooey
21:33:35 <periodic> Huh, interesting.
21:33:39 <periodic> No idea what those two things are.
21:34:03 <wavewave> a kind of functional reactive programming
21:34:07 <ski> @where Phooey
21:34:07 <lambdabot> http://conal.net/phooey/
21:34:11 <periodic> Sounds interesting.  Reading
21:34:45 <ski> @haskellwiki TV
21:34:45 <lambdabot> Unknown command, try @list
21:34:50 <ski> @wiki TV
21:34:50 <lambdabot> http://www.haskell.org/haskellwiki/TV
21:35:18 <Phlogistique> anyone here did some opencv stuff in haskell? the two bindings I see do not seem very mature
21:35:34 <wavewave> today I just announced  a rather big GUI program; hxournal
21:36:30 <periodic> what is it built on, wavewave?
21:36:34 <wavewave> gtk2hs.
21:36:55 <wavewave> I tried some others but for me, support for wacom driver was most important.
21:37:38 <wavewave> on top of gtk2hs, I made a monad-coroutine wrapper
21:37:49 <periodic> Oh cool.  *nix target?
21:37:49 <wavewave> so that I don't need to use IORef.
21:38:03 <wavewave> yeah.. currently...
21:38:21 <wavewave> i haven't tried it on windows.
21:39:18 <periodic> Cool
21:39:31 <periodic> Okay, going to see if I can make Phooey do something cool
21:39:54 <wavewave> yeah.. and if it doesn't work, please push the author, ;-P
21:41:01 <periodic> hehe
21:43:57 <wavewave> haskell GUI programming has a lot of potential.
21:44:31 <d34df00d> I'd like to write a typeclass for representing undirected weighted graphs.
21:44:42 <d34df00d> How'd you define it, so that it can hold weights of different types?
21:44:52 <d34df00d> I'm thinking of type families now, but isn't it an overkill?
21:45:05 <wavewave> type family is not overkill
21:45:35 <d34df00d> And any other possibilities?
21:45:38 <d34df00d> Besides fundeps, of course :)
21:45:40 <wavewave> if it is uniquely defined from node type, I think  type family is the best.
21:45:46 <d34df00d> Hardly so.
21:46:04 <d34df00d> Node type is fixed, it's a plain Int.
21:46:19 <wavewave> Then type family is not adequate.
21:46:24 <d34df00d> I'd like to have that typeclass for working with different representations of a graph.
21:46:38 <d34df00d> Say, adjacency matrix, adj list, etc.
21:46:41 <wavewave> Just use multiparam type class without uniqueness limitation.
21:47:08 <d34df00d> Hmmm.
21:47:14 <d34df00d> And the latter, the uniqueness limitation — what's that?
21:47:16 <wavewave> or use Existential type if you want.
21:47:48 <wavewave> I mean your problem does not define a functional relation between node type and weight type.
21:47:55 <d34df00d> Yeah.
21:47:56 <periodic> okay, closing off those computer to go back to the windows install.  Thanks for the input.
21:48:02 <wavewave> no fundep, no type family .
21:48:14 <wavewave> periodic: you're welcome.
21:48:27 <d34df00d> So I do something like `class Graph g a where ...`, so g denotes the exact graph representation and a denotes the weight type?
21:49:05 <wavewave> yes. that's what i meant .
21:49:51 <d34df00d> But I guess I'd need to use a "inside" g, would that be possible with this approach?
21:50:00 <wavewave> or you can define class Annotation g a
21:50:04 <d34df00d> I'm not used to all this typeclass-fu and designing own typeclasses :)
21:50:38 <wavewave> weight is an annotation for each node position.
21:50:57 <wavewave> and that's indep of whether it's graph or other data structure.
21:51:47 <wavewave> so for Graph typeclass, just define ordinary graph structure interface..
21:51:55 <d34df00d> Oh, I'm afraid I don't get you :(
21:52:05 <d34df00d> For now, the only place I need my a is addEdge function.
21:52:16 <d34df00d> Which looks like addEdge :: g -> (Vertex, Vertex) -> a -> g
21:52:19 <d34df00d> Or smth like that.
21:54:17 <wavewave> define edge and vertex are type family of graph type
21:54:39 <endojelly> hmm. have to check out type families.
21:54:48 <wavewave> and addEdge :: g -> E g  -> g
21:55:10 <wavewave> type E g = (V a, V a) for unannotated.
21:55:10 <d34df00d> Hmmm, why? I wanted them to be fixed to (Int, Int) and Int respectively, for the sake of efficiency.
21:55:21 <d34df00d> So that I could use IntMap and IntSet outside them, for example.
21:55:23 <wavewave> type E g = (V a, V a , w ) for annotated.
21:56:16 <wavewave> why (Int,Int) and Int are more efficient than (Int,Int,Int) ?
21:56:31 <d34df00d> They aren't :)
21:56:49 <wavewave> for weighted edge, you always have (V,V, weight), don't you?
21:56:55 <d34df00d> But since I put vertex type to be decided by the class instance (since it's a type family, after all), I can't rely anymore on it being Int, right?
21:57:57 <wavewave> if you want to specify Vertex as Int, of course you can do that.
21:58:25 <d34df00d> Hmm.
21:58:31 <wavewave> anyway, if you want to make most general interface..
21:58:36 <d34df00d> Let's rewind back a bit, where Graph g a was suggested :)
21:58:47 <d34df00d> It was also my original approach, but I faced this error:
21:59:03 <wavewave> type VertexMap =IntMap V
21:59:19 <d34df00d> http://paste.pocoo.org/show/520114/
21:59:25 <d34df00d> For this simple function I get this:
21:59:27 <wavewave> having VertexMap as another type family.
21:59:49 <d34df00d> http://paste.pocoo.org/show/520115/
21:59:55 <d34df00d> minEdge is defined in the typeclass.
22:00:12 <d34df00d> I guess that error would be everywhere I don't use a, right?
22:01:49 <wavewave> I would not define minEdge defined as a method of typeclass.
22:02:55 <d34df00d> Hm, but that's the point.
22:03:04 <d34df00d> Different graph representations could have optimized minEdge implementations.
22:03:16 <d34df00d> For adjacency matrix, you'd need to scan it all the time.
22:03:23 <d34df00d> For some clever heap structure, you'd perform much better.
22:03:40 <wavewave> okay.
22:04:03 <wavewave> define minEdge :: g -> (edge,weight)
22:04:30 <wavewave> err    minEdge :: g -> Maybe ( edge, weight )
22:05:30 <wavewave> just expose your associated type in type signature.
22:05:47 <d34df00d> You mean, it should be present in minEdge's signature?
22:05:58 <d34df00d> Even if I don't use it in my code and, as such, would match against _?
22:06:06 <wavewave> yes.. if not, there is no way to determine binding of minEdge.
22:06:19 <wavewave> and anyway, the function must be more useful with that ;-)
22:06:37 <d34df00d> Yeah, agreed :)
22:06:51 <d34df00d> But just a theoretical question — what if I had a function that absolutely has no need in "a"?
22:07:06 <wavewave> class Graph g a where type E g  ; minEdge :: g -> Maybe (E g, a)
22:07:13 <d34df00d> Inserting weight somewhere there seems like a kludge to me :(
22:07:27 <wavewave> there is no such situation.
22:07:32 <d34df00d> Why?
22:07:38 <d34df00d> Say, I want to remove all edged from u to v.
22:07:39 <wavewave> by Curry-Howard isomorphism
22:07:47 <wavewave> type signature is a statement.
22:07:54 <d34df00d> Then I have remEdges :: g -> (V, V) -> g
22:08:04 <d34df00d> Hmmmm, what's that isomorphism? :)
22:08:17 <wavewave> if you don't have a type outside, then you don't assert anything.
22:08:33 <wavewave> proof = program
22:08:47 <d34df00d> Then it means I've designed my typeclass in a wrong way, right?
22:09:00 <d34df00d> If I have such functions that don't use a parameter of a type class.
22:09:24 <wavewave> you are considering your typeclass as a kind of box you can put arbitrary things..
22:09:40 <wavewave> but in fact typeclass is a proposition.
22:10:10 <user317> i am trying to grok acid state, so i i am using the helloworld example where it has a database thats a list of strings.  it seems that adding 1000 messages always takes the same amount of time no matter the size of the database
22:10:14 <wavewave> if type g and a satisfies minEdge, then I will call it g and a has a relation Graph.
22:10:43 <wavewave> You should interprete typeclass like that.
22:10:53 <d34df00d> Hm.
22:10:56 <wavewave> so minEdge has no type a
22:10:59 <user317> so how does that work?  wouldn't each update force me to write a the underlying datastruture completely, so the whole list?
22:11:21 <wavewave> then it doesn't make any sense..
22:11:27 <d34df00d> And if for some function f (g, a)'s "satisfability"doesn't depend on a, then what?
22:11:53 <wavewave> d34df00d : then the typeclass has no meaning as a relation.
22:12:08 <wavewave> d34df00d: that's not definable.
22:12:19 <wavewave> d34df00d: type class is different from class.
22:12:30 <wavewave> especially when you have multi param type classes.
22:13:09 <wavewave> just unlearn your previous concept of classes when you do multiparam type classes.. MPTC is a relation.
22:13:20 * hackagebot peggy 0.3.0 - The Parser Generator for Haskell  http://hackage.haskell.org/package/peggy-0.3.0 (HideyukiTanaka)
22:13:25 <d34df00d> Oh, that's a good approach :)
22:13:43 <d34df00d> And if that's a relation for some functions, and for others it isn't?
22:13:57 <d34df00d> Or it has no sense?
22:14:16 <wavewave> if a function is defined between g and a, then yes..
22:14:24 <ski> it's a relatin between types, not values (functions are values)
22:14:34 <d34df00d> Yeah.
22:14:36 <wavewave> by existence, you define a relation of g and a
22:14:40 <d34df00d> But some functions are defined between g and a.
22:14:42 <wavewave> relation of Graph
22:14:46 <d34df00d> And others are defined only using g.
22:14:53 <d34df00d> They have no relation to a.
22:15:05 <wavewave> so that other functions should not be a member of Graph.
22:15:16 <wavewave> because it doesn't make sense.
22:15:34 <ski> d34df00d : if you have operations in a type class `Graph g a' which doesn't depend on `a', then you could break those out into a super-class
22:15:43 <wavewave> and in fact, you cannot make any compilable code anyway ;-)
22:15:46 * ski isn't sure he's understood what d34df00d is wanting to do
22:16:10 <wavewave> so that's why I said you need to define class Graph g where
22:16:25 <d34df00d> Then we get back to the type families, seems like.
22:16:35 <wavewave> because Graph is not a relation between g and a in its sense.
22:16:46 <d34df00d> ski: well, I want to do a typeclass for weighted graph.
22:17:01 <wavewave> I would rather define class (Graph g) => WeightedGraph g a
22:17:01 <d34df00d> ski: some functions use its property of being weighted, while others don't.
22:17:06 <ski> for what opereraions on them ?
22:17:29 <ski> d34df00d : also, you should be able to name at least two different instances of `Graph' that you want to make/use
22:17:37 <wavewave> class (Graph g) => WeightedGraph g a where minEdge :: g -> Maybe (E g, a )
22:17:41 <ski> (otherwise, why use a type class ?)
22:17:54 <wavewave> class Graph g where type E g
22:17:58 <d34df00d> ski: they differ by graph internals representation.
22:18:02 <wavewave> something like that.
22:18:16 <d34df00d> ski: so that I could have different implementations with different space/time/operations tradeoffs.
22:18:29 <ski> d34df00d : "they" being ?
22:18:31 <d34df00d> wavewave: hm, and one more theoretical question.
22:18:43 <wavewave> d34df00d: you're welcome!
22:19:10 <d34df00d> wavewave: what if I have a function that assumes that graph is weighted but doesn't use this property in its signature?
22:19:20 <d34df00d> Like minEdge, but without returning the weight of that edge.
22:19:46 <d34df00d> So that it doesn't make sense to put it into Graph, but putting it into WeightedGraph is also an error, since we don't define a relation?
22:19:56 <wavewave> minEdge' = fmap fst minEdge
22:20:02 <d34df00d> A relation between g and a, I mean.
22:20:10 <d34df00d> Hmm.
22:20:19 <augur> ski: ping
22:20:35 <d34df00d> Since like I can't make an example right off the top of my head where returning any "a" wouldn't make sense, but the corresponding property is assumed.
22:20:36 <augur> oh, you're pretty much talkin
22:20:37 <wavewave> minEdge' should be outside of type class but you can always define a function
22:20:37 <augur> g
22:20:42 <d34df00d> s/Since/Seems/
22:20:42 <augur> ok, ski: http://wellnowwhat.net/linguistics/Some%20Notes%20on%20Derivational%20Economy.pdf
22:21:05 <d34df00d> ski: "they" = typeclass instances.
22:21:57 <wavewave> but in this caes, you have to be careful.
22:22:04 <wavewave> maybe you should use minEdge' like
22:22:39 <wavewave> minEdge' x = fmap fst (minEdge x :: Maybe (ConcreateGraph, ConcreteWeight))
22:22:43 <d34df00d> wavewave: well, I get an error once again :)
22:22:56 <d34df00d> wavewave: I've defined minEdge as minEdge :: g -> Maybe ((Vx, Vx), a)
22:23:04 <d34df00d> And use it like this:
22:23:09 <d34df00d> stepKrus g verts | Just e <- fmap fst $ minEdge g = undefined
22:23:09 <wavewave> so by explicit type annotation, you can resolve the problem .
22:23:24 <d34df00d> Once again, I get ambiguous type variable.
22:23:27 <wavewave> see my minEdge' aboe.
22:23:44 <d34df00d> Yeah, but what ConcreteWeight should be like?
22:23:51 <wavewave> You need to specify ConcreteGraph, ConcreteWeight..
22:23:59 <d34df00d> Since I don't use it at all in my function, I don't know what it is.
22:24:11 <wavewave> if your minEdge is different for differnt weight, how can you know that function at this moment?
22:24:38 <wavewave> for the same vertex type, you can have different minEdge.
22:24:51 <wavewave> if you cannot decide, compiler can't, too.
22:25:26 <wavewave> so.. you need to specialize
22:25:36 <d34df00d> Hmmm.
22:25:41 <wavewave> or your graph type should have a from the beginng
22:25:45 <wavewave> like Graph a
22:25:48 <d34df00d> I feel like I start getting all that stuff.
22:26:01 <wavewave> so define Graph as higher order type.
22:26:06 <wavewave> like Functor.
22:26:12 <d34df00d> I also thought about that.
22:26:19 <wavewave> probably that's the better solution.
22:26:26 <d34df00d> Hm.
22:26:28 <d34df00d> Seems like yes.
22:26:40 <wavewave> and that makes more sense.
22:26:58 <wavewave> because WeightedGraph is really a functor
22:27:19 <wavewave> you can define one WeightedGraph a to another WeightedGraph b
22:27:48 <wavewave> and define unweighted graph as WeightedGraph ()
22:28:05 <d34df00d> But what if I later decide to add something along the vertices?
22:28:07 <wavewave> does it make sense?
22:28:30 <d34df00d> I guess it makes.
22:28:30 <wavewave> I do not understand your question.
22:28:42 <d34df00d> At least, WGraph is really a functor.
22:29:04 <d34df00d> I mean, does this solution scale?
22:29:22 <d34df00d> For now, I make Graph as higher order type, so that it could "store" the weights of edges.
22:29:31 <d34df00d> What if I later want to "store" the weights of nodes?
22:29:43 <d34df00d> I mean, in addition to weights of edges.
22:29:52 <wavewave> that's different type...
22:30:05 <d34df00d> Yeah.
22:30:13 <d34df00d> Surely.
22:30:17 <wavewave> from any solution, you encounter same problem anyway.
22:31:24 <wavewave> you have Graph, WGraph, CGraph, CWGraph (C means colored graph)
22:31:25 <cl1> d34df00d .. what are you writing (not that I could help)?
22:31:54 <wavewave> Graph, WGraph a, CGraph a, CWGraph a b
22:32:27 <wavewave> define common type class for all Graph.. say class IGraph g where ....
22:32:42 <d34df00d> cl1: a simple & stupid Kruskal algorithm for now :)
22:32:50 <d34df00d> cl1: then, Prim's one.
22:32:56 <wavewave> and for each type, make instances of IGraph
22:33:18 * cl1 is learning him a haskell
22:33:29 <wavewave> now using higher order type, you even don't need type class for minEdge
22:33:39 <d34df00d> wavewave: eh, why?
22:34:17 <wavewave> ah.. if you want to have specialization, you need it. sorry I forgot.
22:35:02 <wavewave> anyway.. just experiment ideas.
22:35:18 <d34df00d> Yeah, that's why I implement it in Haskell, after all :)
22:35:25 <d34df00d> To learn how things should be designed and written :)
22:35:37 <wavewave> think about typeclasses and signature as proposition and logic..
22:35:44 <wavewave> that's very important unlearning.
22:35:54 <mzero> from a brief look at the algo., I'm not sure why you need type classes to do this in Haskell...
22:36:12 <mzero> ...but I might be missing what d34df00d needs in the rest of the problem
22:36:39 <d34df00d> mzero: see Prim's algorithm. You could have different strategies for selecting next minimal edge coming from a vertex.
22:37:07 <ski> d34df00d : ok
22:37:17 <ski> augur : SYN
22:37:27 <augur> ski: ACK
22:37:38 <wavewave> it's in a sense inverting a useful OOP way..
22:37:41 <augur> dont syn me man, that hurts!
22:37:47 * augur dresses wound
22:37:47 <augur> :(
22:38:00 <wavewave> if x is a class C, then x will have method m. => that's OOP way of thinking
22:38:03 <ski> you should reply with `SYN ACK' ;)
22:38:35 <wavewave> if a function f is defined for x, then x is a typeclass C => this is the FP way.
22:38:55 <mzero> still not sure that I'd use a type class - perhaps just a passed selector function
22:38:59 <augur> ski: i wasnt replying, i was yelping in pain!
22:39:02 * ski isn't sure whether type classes can be said to be specifically an FP thing
22:39:03 <wavewave> if a function f is defined for x and y, then (x , y ) is a typeclass C.
22:39:04 <cl1> what would i need to learn to understand that Kruskal's algo, and what is its application on?
22:39:13 <ski> augur : ah, ok. that makes sense, then
22:39:17 <augur> :)
22:39:31 <augur> ski: lemme know what you think of that paper. its pretty drafty, but
22:39:35 <wavewave> ski: type theoretic way? then?
22:39:37 <augur> ski: btw, whats your thing? what do you do?
22:39:39 <ski> um, which paper ?
22:39:44 <augur> ski: http://wellnowwhat.net/linguistics/Some%20Notes%20on%20Derivational%20Economy.pdf
22:39:54 <salisbury> augur: on p2, in the ordering of the configuration space, why does
22:40:11 <salisbury> .. I was meant to delete that
22:40:12 <augur> salisbury: why does? because!
22:40:20 <d34df00d> cl1: I guess it's basic graph theory and a bit of thinking :)
22:40:24 <salisbury> I answered my question, I think
22:40:27 <wavewave> at least there is no correspondent to multiparam type classes in OOP.
22:40:34 <d34df00d> mzero: hm, lots of selector functions passing around then.
22:41:08 <augur> salisbury: what was the question
22:41:32 <cl1> d34df00d .. oic, i should learn me some of that too, looks interesting
22:41:55 <mzero> really? guess I don't see it - seems like a straight forward thing to do w/o type classes or selector functions... but hey, w/o a use case, unclear what the implementation needs to serve
22:42:17 <endojelly> cl1, graphs are *everywhere*. you really should take a loot at them! plus they're fun.
22:42:35 <salisbury> (a, b, c), (a, bc), (abc) are all at multiple levels
22:42:42 <cl1> i've been asking about learning how to write a compiler, and graph theory came up
22:42:42 <mzero> wavewave: I think your depictions of OOP and type classes in FP don't ring to my ears
22:43:01 <augur> salisbury: what do you mean?
22:43:31 <endojelly> cl1, compilers are eating transforming and producing graphs like nothing else, yes
22:43:32 <d34df00d> mzero: well, actually for know I just wanted to practice a bit with designing type classes :)
22:43:43 <cl1> not that i want to write a compiler, but I would like to build developer tools, like take source code files and build a gui controls
22:43:53 <endojelly> cl1, and trees are just special graphs.
22:44:33 <cl1> endojelly .. i knew about the trees being special graphs, I learned that today in conversation
22:44:38 <cl1> :D
22:44:42 <wavewave> mzero: yeah.. it's not very well matched probably.. just emphasized  type class is different from class.
22:44:58 <salisbury> when you are generating the configuration space from the derivation space
22:45:02 * d34df00d dreams of making a tool that could be fed with a bunch of C++ source files, and it'd tell what #includes are redundant.
22:45:35 <cl1> d34df00d .. that's the kind of stuff I want to know how to write
22:45:47 <wavewave> d34df00d: btw, I need to go sleep.. hope that I helped you somewhat.
22:45:55 <d34df00d> wavewave: you've surely helped me, thanks a lot!
22:45:58 <cl1> I could care less about writing something that generates machine code
22:46:00 <d34df00d> wavewave: have a good sleep :)
22:46:12 <wavewave> :)
22:46:17 <endojelly> d34df00d, that shouldn't be too hard, actually...
22:46:22 <salisbury> the different concatenations are ordered,
22:46:40 <endojelly> d34df00d, of course it'd be easier as part of an already working compiler
22:48:11 <endojelly> but if you already have full grammars, for the preprocessor language (mostly trivial) and C++ itself (rather not trivial), and a parser which spits out abstract syntax trees for it, it should be pretty easy.
22:48:34 <augur> salisbury: well, if you start with the configuration (a,b,c), where no concatenations have happened, you can do two things: concatenate a with b, producing (ab, c), or you can concatenate b with c, producing (a, bc)
22:49:12 <augur> and from each of this you can only do one thing: concatenate the two elements to produce (abc)
22:50:13 <augur> there's no way (using concatenation) to produce (ab, c) from (a, bc), or vice versa
22:52:23 <cl1> omg .. i forgot how to mark myself as not away .. its been too long since i've been on irc
22:53:11 <d34df00d> Awesome!
22:53:28 <d34df00d> Now I can write `set' = uncurry IS.union $ join (***) (fs' IM.!) (u, v)` instead of `set' = (fs' IM.! u) `IS.union` (fs' IM.! v)`, arrows are everywhere!
22:53:39 <salisbury> I was thinking it would resemble (a, b, c) < (a, bc), (ab, c) < (abc). I think I see where the paper is coming from how though
22:53:49 <salisbury> now*
22:54:28 <augur> salisbury: thats another notation for the same thing. i was just giving the explicit pairwise orderings
22:54:38 <augur> (modulo transitivity)
22:55:06 <salisbury> arrows strike me as being a good metaphor for generating these configuration spaces
22:56:04 <mjrosenb> are there any good introductions to arrows, like the 50,000 introductions to monads?
22:56:15 <augur> salisbury: ?
22:56:43 <salisbury> mjrosenb: play round with HXT, that is how I wrapped my head around them
22:57:06 <mjrosenb> salisbury: i'll try that.
23:02:09 <salisbury> augur: 1 sec
23:02:45 <KUKAREKA> hi, roosters
23:04:41 <salisbury> augur: returnA <<< arr (\tpl -> fst ++ snd) `second` arr (\tpl -> fst ++ snd) `first` arr (\(a, b, c) -> (a, b ++ c) )  &&&  arr (\(a, b, c) -> (a ++ b, c)) -< (a, b, c)
23:05:10 <augur> salisbury: sure. that doesnt make it efficient, thats just a way of representing things. :P
23:05:26 <KUKAREKA> salisbury, I don't understnd rooter's language, sorry
23:05:37 <KUKAREKA> rooster's*
23:06:58 <salisbury> yes, a metaphor
23:08:01 * cl1 thinks programming > sleep
23:08:18 <cl1> must .. learn .. more ... haskell
23:08:45 <KUKAREKA> cl1, try C, rooster
23:09:44 <cl1> KUKAREKA .. rooster is a programming language?
23:10:03 <KUKAREKA> cl1, no, rooster is you
23:10:12 <cl1> i will stay as far away from c as I can, thank you very much
23:10:22 <cl1> I've had my fill of C
23:10:38 <mauke> preflex: quote . oq
23:10:45 <preflex>  <kmc> i'll show you my Coq if you show me yours
23:19:01 <aavogt> is there any use of http://hackage.haskell.org/package/reflection
23:19:36 <aavogt> I end up only passing proxy around as a parameter... at which point I could just pass the actual value being reflected instead
23:20:04 <aavogt> (in situations where I've got it to do something)
23:25:55 <cl1> i just learned the $ operator :O
23:26:33 <shachaf> cl1: Now to being the slow process of unlearning it.
23:26:43 <cl1> orly?
23:26:47 <cl1> why is that?
23:26:52 <shachaf> (In my opinion $ is way overused.)
23:27:18 <cl1> so was goto, but now people just use return in the middle of a function :/
23:27:50 * mjrosenb would probably lixe $ better if its arguments were reversed (just like | from bash, right?)
23:27:55 <shachaf> Quite the analogy.
23:28:00 <shachaf> mjrosenb: That's often called |>
23:28:13 <shachaf> mjrosenb: Would you also like function application better if it was written "x f"? :-)
23:28:32 <mjrosenb> shachaf: *no* :-p
23:28:35 <shachaf> mjrosenb: Surely you'll also grant that $ should be infixl in Haskell. Right?
23:28:47 <KUKAREKA> shut up, boys
23:29:10 <KUKAREKA> only C, only hadrcore
23:30:55 <cl1> i'm the one who got gcc to compile on os x, don't talk to me about hardcore :P
23:31:40 <cl1> i did it so that I could use ada instead of c :P
23:31:53 <KUKAREKA> SHUT UP FAGGOT
23:32:08 <shachaf> @where ops
23:32:09 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
23:32:17 --- mode: ChanServ set +o copumpkin
23:32:21 --- mode: ChanServ set +o mauke
23:32:22 --- mode: mauke set +q *!*@gateway/web/freenode/ip.85.118.226.197
23:32:31 --- mode: copumpkin set -o copumpkin
23:32:34 <augur> copumpkin!
23:32:37 <augur> comment on my paper!
23:32:38 <augur> :|
23:32:38 * copumpkin sits back and looks smug
23:32:46 <shachaf> mauke++ # being around
23:32:47 <copumpkin> augur: I don't just sit around doing nothing all day :P
23:32:57 <augur> copumpkin: no, you sit around looking smug all day!
23:33:01 <copumpkin> yep
23:33:05 <augur> |:
23:33:10 <copumpkin> smugness takes a lot of work
23:33:12 --- mode: mauke set -o mauke
23:33:17 <copumpkin> anyway, I'm exhausted and want to go to sleep
23:33:22 <augur> me too
23:33:26 <augur> night night copumpkin, sleep well!
23:33:30 <copumpkin> night :)
23:36:24 <cl1> while I find the terseness and declarative model inherent in haskell, how do you wrap your head around this code?
23:36:50 <cl1> replicate 100 (producct (map (*3) (zipWith max [1..5] [4..8])))
23:37:06 <cl1> seriously don't you have to compile that in your head to understand it?
23:37:22 <mauke> what do you mean by "compile"?
23:37:51 <cl1> parse it in your head to figure out what its supposed to do, as opposed to just reading it
23:37:56 <mauke> what
23:38:04 <mauke> there's nothing you can "just read"
23:38:08 <mauke> you always have to parse
23:38:44 <cl1> for example I wrote an extenion method in c# today that when called on any object looks like object.IsNotNull(), you can tell what that is from just reading it, no parsing
23:39:03 <mauke> bullshit
23:39:26 <mauke> replicate(100, product(map(mul(3), zipWith(max, [1..5], [4..8]))))
23:39:31 <mauke> there, now it uses C-like syntax
23:39:41 <cl1> mauke .. i know you always have to parse, but you get the point I'm trying to make, i can write c# that is just as difficult to parse in your head as that last line
23:39:58 <mauke> heh, .IsNotNull
23:40:19 <mauke> is that like isNotBottom?
23:42:24 <cl1> i have no idea
23:42:52 <cl1> i guess what i'm trying to ask is, does most haskell look like what I posted or is that crap code?
23:43:14 <mauke> I don't understand what your problem is
23:43:15 <russellw> Not really, null in C# is a perfectly well-defined value. It's only the result of dereferencing a null reference that is undefined
23:43:20 <mauke> that code is completely straightforward
23:43:46 <russellw> and cl1, the answer is, the code you posted was terse because it was written by an expert in the language
23:44:04 <russellw> It's normal for there to be a tradeoff between being concise and being easy for a beginner to read
23:44:10 <cl1> okay, then I guess I just need to get used to it then
23:44:26 <russellw> yeah. You will probably find yourself initially spelling things out in smaller steps
23:44:37 <cl1> its making my head spin right now though. I'm used to imperative
23:44:45 <russellw> And eventually get to the point where you rattle off chunks of code like quoted one :-)
23:45:17 <russellw> I know what you mean. Haskell is something of a jump into the deep end, as opposed to e.g. F# where you can fall back on imperative idioms anytime you like
23:46:34 * aavogt wonders where the idea that you can't do imperative programs in haskell comes from
23:47:17 <aavogt> it may be ugly but it's not much worse than the same program in languages designed for that style
23:47:28 <cl1> actually this learnyouahaskell is a bit easier to follow than the f# tutorials I have found
23:48:37 <copumpkin> aavogt: early return
23:48:39 <cl1> aavogt .. as well, I can do functional programming in c# but it doesn't look all that pretty
23:48:47 <salisbury> augur: this is a really interesting paper
23:48:58 <augur> salisbury: thank you! :)
23:49:02 <augur> copumpkin: go to bed
23:49:14 <copumpkin> augur: go to bed
23:49:26 <shachaf> copumpkin: That's why someone should add early return to IO!
23:49:34 <augur> copumpkin: im talking to an imaginary audience in my head! i cant leave them hanging like that!
23:49:44 <augur> actually im talking to an imaginary question-asker
23:50:02 <copumpkin> shachaf: Reader + ContT IO!
23:50:04 <whotemp> is there a name for the "!!" operator?
23:50:12 <copumpkin> whotemp: bangbangbang
23:50:24 <cl1> whotemp .. indexer?
23:50:32 <copumpkin> that song
23:50:38 <copumpkin> is about that operator
23:50:45 <shachaf> copumpkin: But then you have to lift everything...
23:51:12 <whotemp> cl1: thanks, i wasn't able to google it -__-
23:51:29 <shachaf> whotemp: Hoogle.
23:52:25 <aavogt> shachaf: you can use a base that has everything in MonadIO m => m   instead of IO
23:52:32 <whotemp> shachaf: wow this is great, gonna be able to learn so much faster now!
23:52:33 <aavogt> then fear the monomorphism restriction
23:53:01 <shachaf> aavogt: But that's ugly. :-(
23:54:34 <aavogt> new topic: has anybody called haskell code from R?
23:54:51 <aavogt> (or some other language that's not C)
23:56:48 <cl1> O.M.G @ hoogle
23:57:05 <cl1> this should help alot, thanks shachaf
23:58:08 <cl1> anyone ever used both flex and parsec for comparison, the parsec says its better than flex, but i suspect bias
23:58:52 <shachaf> Well, Parsec does a lot more than flex.
23:59:20 <cl1> i'm learn ing http://learnyouahaskell.com so that I can turn around and learn http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/ which uses parsec
