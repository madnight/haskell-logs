00:01:49 <wereHamster> is it not possible to (++) two 'IO [a]' lists? I have a '[a]', and a function which returns 'IO [a]', and when I try to ++ them with (return x) ++ (func) I get an error
00:05:24 <hpaste> wereHamster pasted “io lists” at http://hpaste.org/55589
00:06:07 <Sgeo_> wereHamster, liftM2 (++)
00:06:14 <wereHamster> hm, errors? ghci doesn't seem to care
00:06:23 <Sgeo_> :t liftM2 (++)
00:06:24 <lambdabot> forall a1 (m :: * -> *). (Monoid a1, Monad m) => m a1 -> m a1 -> m a1
00:07:00 <wereHamster> is it because (++) is simply not defined for m [a] -> m [a] -> m [a]?
00:07:03 <Sgeo_> liftM2 (++) (return [1,2,3]) (return [4,5,6]) :: [[Int]]
00:07:14 <Sgeo_> (++) is defined for [a] -> [a] -> [a]
00:07:15 <Sgeo_> > liftM2 (++) (return [1,2,3]) (return [4,5,6]) :: [[Int]]
00:07:17 <lambdabot>   [[1,2,3,4,5,6]]
00:07:42 <Sgeo_> In order to get it to work on m a (IO would be m), you need to turn the (++) into something that can handle it
00:07:46 <Sgeo_> Two ways to do it:
00:08:00 <Sgeo_> (More than two)
00:08:22 <wereHamster> ah, works :)
00:08:59 * wereHamster is writing a git client in haskell. Yet another one.
00:09:03 <Sgeo_> You could also do (++) <$> myFirstIOList <*> mySecondIOList if you import Control.Applicative
00:09:07 <Sgeo_> I think
00:09:36 <Sgeo_> Note that I am not an expert.
00:09:57 <wereHamster> a better one than I am :)
00:10:26 <Sgeo_> :t liftM2
00:10:27 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
00:10:51 <Sgeo_> liftM2 takes an a -> b -> c and turns it into a (Monad m) => m a -> m b -> m c
00:10:59 <Sgeo_> liftM# are defined up to liftM5
00:11:22 <Sgeo_> :t liftM
00:11:23 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
00:12:17 <Sgeo_> Note that you probably don't need those do
00:12:49 <Sgeo_> Also, what exactly is foo supposed to do
00:13:11 <Sgeo_> I'm thinking perhaps it shouldn't return an IO [Int]
00:13:22 <Sgeo_> wereHamster?
00:13:35 <wereHamster> basically I start with a list of [Hash], and need to turn it into a list of IO [Commit] (because commits are loaded from disk)
00:14:01 <Sgeo_> Ah, and this foo is just a quick example to illustrate your question? Ok
00:14:07 <wereHamster> also note that I have this comment just above the function definition: -- Maybe this is not the smartest way to do it. But what the hell, this works.
00:51:12 <sohum> hrm
00:51:22 <sohum> anyone around?
00:52:03 <hpaste> sohum pasted “Not sure what to call this question...” at http://hpaste.org/55590
00:52:03 <shachaf> There is only silence and some second-hand clothes.
00:52:19 * sohum nabs a deal on the clothes
00:52:44 <sohum> but yea, if someone could have a look at the paste and tell me what they think, that would be great
00:52:57 <sohum> uh
00:52:57 <shachaf> sohum: instance Fooable Foo where foo = xLab?
00:53:06 <shachaf> I don't really know what you want with that type class exactly.
00:53:36 <sohum> shachaf: so I meant to suggest with the mkFoo function that it doesn't _directly_ map onto Fooable
00:54:05 <sohum> shachaf: but it does, in a well defined way, but in a way that doesn't fit the assumptions Fooable makes about a and b
00:54:36 <shachaf> Wait, "make QuasiFoo an instance of Foo"? Foo isn't a type class.
00:54:51 <sohum> pretend I wrote Fooable >_>
00:55:14 <augur> ski: ping
00:55:27 <shachaf> Well, you should figure out what "Fooable" means.
00:55:52 <shachaf> As far as I can tell you only want a function :: QuasiFoo x y -> x. That's easy to do -- xLab is just such a function.
00:56:25 <sohum> I know what it means in my specific implementation, and it means something on a (mkFoo quasiFoo)
00:56:28 <sohum> um.
00:56:31 <sohum> hang on, I'll clarify and repaste
01:01:27 <Sgeo_> Why is the safe-lazy-io package unmaintained? :(
01:03:06 <Sgeo_> What is meant when this thing says that LI is a strict monad and strict applicative functor, but Haskell requires lazy monad and lazy applicative functor?
01:03:24 <Sgeo_> http://hackage.haskell.org/packages/archive/safe-lazy-io/0.1/doc/html/System-IO-Lazy-Input.html#t%3ALI
01:03:50 <teneen> Why is g computed twice in the following:  print $ (g 3) + (g 3) where g x = trace "once" (x+1)
01:04:05 <shachaf> teneen: Because you typed it twice.
01:04:11 <oleiade> ^^
01:04:20 <teneen> shachaf: but it's pure!
01:04:36 <shachaf> Right, so it returns the same result each time.
01:04:39 <teneen> scachaf: there's no need to compute it twice
01:04:46 <shachaf> That doesn't mean that GHC should memoize it automatically.
01:04:48 <Sgeo_> Except that takes up memory
01:04:49 <theorbtwo> teneen: So the haskell compiler could have optimized it away.  It didn't, though.
01:05:13 <teneen> theorbtwo: yes, why isn't it optimized
01:05:20 <Sgeo_> There's no need to compute it twice, but if that were a general rule GHC used, it might take up more memory
01:05:31 <hpaste> sohum annotated “Not sure what to call this question...” with “Not sure what to call this question... (annotation)” at http://hpaste.org/55590#a55591
01:05:33 <teneen> theorbtwo: it's claimed in many Haskell resources that such calls are only computed once
01:06:48 <teneen> Sgeo_:I think it will not take much memory to store the result in the scope of a single expression
01:06:59 <Sgeo_> sohum, I might be misunderstanding, but why not make instance QuasiFoo Fooable where
01:07:07 <Sgeo_> And have the definition of foo use mkFoo?
01:07:42 * Sgeo_ is probably misunderstanding what you want
01:07:43 <theorbtwo> teneen: There's a trade-off to be made between memory usage and execution speed / number of operations performed (since memory usage can have an effect on swappiness and on cache efficency, it's not so clear).  ghc is assuming you considered that trade-off and wrote what you meant.
01:07:54 <theorbtwo> Not neccessarly a good assumption, but *shrug*.
01:08:19 <magicman> teneen: If you want to have "g 3" evaluate only once, give it a name. So something like "let g3 = g 3 in ...".
01:08:43 <sohum> Sgeo_: try it :P the Fooable type class expects the first type in the * -> * -> * kinded thing you pass it to be the result of foo
01:08:50 <Sgeo_> teneen, there are libraries which turn functions like g into functions like g that store results of past computations
01:09:27 <shachaf> teneen: There exist cases where computing g twice makes a lot more sense than computing it once.
01:10:15 <hpaste> sohum annotated “Not sure what to call this question...” with “the error if you try the obvious thing” at http://hpaste.org/55590#a55593
01:10:48 <Sgeo_> sohum, what's wrong with foo = xLab. That fits the type, I think, as someone else mentione
01:10:49 <Sgeo_> d
01:10:57 <teneen> for example in the expression: x + y + z + w + x + x ... Even if y, z and w are expensive computations it also makes sense to store the result of x and not compute it again. At least in the scope of every single expression like this
01:11:24 <Sgeo_> sohum, um, that looks more like a mistake in your definition
01:11:27 <sohum> Sgeo_: forget the type similarities between Foo and QuasiFoo; that's just an artifact of this being a simple test case. The real types are actually distinct and implemented differently
01:11:27 <shachaf> teneen: Consider this expression: (sum (take 1000000 [1..]), length (take 1000000 [1..]))
01:11:45 <Sgeo_> foo . mkFoo is a function
01:11:55 <Sgeo_> Yet foo q should be a result that's not necessarily a function
01:12:02 <Sgeo_> Try removing the q argument
01:12:08 <sohum> uh, yes, I did screw that up
01:12:15 <sohum> the error is actually simpler :P thanks
01:12:22 <teneen> shachaf: mm I see
01:12:24 <Sgeo_> You're welcome.
01:12:41 <magicman> > let f x = [x..] in head (dropWhile (<10000000) (f 1)) + head (f 1)
01:12:43 <lambdabot>   10000001
01:12:51 <magicman> > let f x = [x..] in let f1 = f 1 in head (dropWhile (<10000000) (f1)) + head (f1)
01:12:52 <shachaf> teneen: (Do you?)
01:12:56 <lambdabot>   mueval: ExitFailure 1
01:12:57 <lambdabot>  mueval: Prelude.undefined
01:13:05 <hpaste> sohum annotated “Not sure what to call this question...” with “the _actual_ error if you try the obvious thing (annotation)” at http://hpaste.org/55590#a55594
01:13:29 <magicman> (obligatory artificial example)
01:13:53 <magicman> (not sure why it runs into undefined, though...)
01:13:53 <Sgeo_> shachaf, eek, I'm scared that I might decide to in fact have something like hugelist = take 1000000 [1..] and then fail to realize that that's a memory issue
01:18:25 <Sgeo_> http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.2/doc/html/Data-MemoCombinators.html
01:18:55 <shachaf> Sgeo_: Of course, that does something completely different from what teneen wants (CSE).
01:20:00 <shachaf> teneen: You'll find that if you compile with -O2, it'll only print "once" once.
01:20:15 <Sgeo_> o.O
01:20:32 <matobet> @pl map (\n -> map (!! n) matrix) [0..])
01:20:32 <lambdabot> (line 1, column 36):
01:20:33 <lambdabot> unexpected ")"
01:20:33 <lambdabot> expecting variable, "(", operator or end of input
01:20:37 <teneen> @shachaf not it doesn't
01:20:37 <lambdabot> Unknown command, try @list
01:21:02 <shachaf> teneen: Yes it does.
01:21:06 <teneen> shachaf: I tried it
01:21:28 <shachaf> teneen: Did you recompile with -fforce-recomp?
01:21:56 <teneen> shachaf: yes I did
01:22:08 <teneen> shachaf: it will only print it once if it's a CAF
01:22:33 <shachaf> teneen: Oh, in GHC 6.12 it prints it twice.
01:22:36 <teneen> shachaf: i.e if the output doesn't depend on the input argument]
01:22:36 <shachaf> In GHC 7 it prints it once.
01:22:40 <shachaf> This is an implementation detail.
01:22:48 <teneen> I'm using GHC 7.2.1
01:22:52 <shachaf> teneen: That's not what "CAF" means, I don't think.
01:23:03 <matobet> @pl \matrix -> map (\n -> map (!! n) matrix) [0..length (head matrix) - 1]
01:23:03 <lambdabot> ap (map . flip (map . flip (!!))) (enumFromTo 0 . subtract 1 . length . head)
01:23:29 <teneen> shachaf: f x = const 1, is a CAF
01:26:05 <hpaste> teneen pasted “eval” at http://hpaste.org/55596
01:26:07 <shachaf> teneen: http://hpaste.org/55595
01:27:31 <teneen> shachaf: in 7.2.1 in prints twice :)
01:27:56 <shachaf> teneen: 7.2.1 is a "technology preview release" not meant for end users. :-)
01:28:06 <shachaf> At any rate, this is an implementation detail.
01:28:52 <Sgeo_> @info <$>
01:28:52 <lambdabot> (<$>)
01:29:07 <Sgeo_> lambdabot sucks for some stuff
01:29:09 <shachaf> @info do x
01:29:09 <lambdabot> x
01:29:12 <hpaste> teneen annotated “eval” with “eval (annotation)” at http://hpaste.org/55596#a55598
01:29:20 <shachaf> Sgeo_: That's what your ghci is for, you know. And also /msg lambdabot.
01:29:22 <Sgeo_> I hate having to open ghci just to see an operator's precedence
01:29:56 <shachaf> teneen: Wait, that's a rather different expression.
01:30:14 <Sgeo_> (<$>) is infixl while ($) is infixr
01:30:20 <Sgeo_> Why?
01:30:32 <shachaf> Sgeo_: Because ($) should be infixl.
01:30:46 <shachaf> teneen: (But same behaviour, apparently.)
01:30:54 <Sgeo_> shachaf, wait what?
01:30:55 <Sgeo_> BRB
01:31:13 <shachaf> Sgeo_: Excuse me. Because $ should be infixl.
01:31:24 <shachaf> ($) doesn't have a precedence; only $ does.
01:31:52 <teneen> shachaf: but why would it change from 7.04 to 7.2.1? and what about the special cases you mentioned before?
01:32:06 <shachaf> What special cases?
01:32:20 <shachaf> teneen: Optimizers are mysterious beasts. I don't know why.
01:32:50 <Sgeo_> :t f
01:32:50 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
01:32:51 <teneen> shachaf: the case of extracting a million elements from a list
01:32:58 <shachaf> What about it?
01:33:27 <shachaf> Presumably the optimizer has some heuristics, or whatever it is optimizers have, for when to CSE and when not to.
01:33:35 <shachaf> I don't know much about the GHC optimiser.
01:34:13 <teneen> shachaf: ok
01:34:15 <Sgeo_> shachaf, why should $ be infixl?
01:34:16 <teneen> shachaf: thanks :)
01:34:40 <Sgeo_> (f $ g) $ h would be (f g) h
01:34:44 <Sgeo_> Which is not helpful
01:34:58 <shachaf> teneen: If your question is specifically about why something changed in between GHC 7.0 and GHC 7.2, #ghc might know.
01:35:07 <shachaf> Sgeo_: Because function application is infixl.
01:35:13 <shachaf> Sgeo_: (f $ g) $ h is already (f g) h
01:35:40 <Sgeo_> shachaf, and infixl, which you say $ should be, would make f $ g $ h default to (f $ g) $ h
01:35:53 <shachaf> Sgeo_: Right.
01:36:08 <Sgeo_> Wait, are you a $ hater?
01:36:11 <shachaf> Sgeo_: For the other thing you can say f . g $ h
01:36:53 <shachaf> In particular, this lets you save more parentheses than infixr $
01:37:11 <shachaf> Because you can say things like f x $ g y $ h
01:37:47 <shachaf> Sgeo_: *Anyway*, disregarding what $ should be, <$> should still be infixl, because it's not used to reduce parentehses, it's used to apply functions.
01:38:07 <Sgeo_> Oh, similar to <$> and <*>, except with infixl $ you only need $ ?
01:38:42 <shachaf> ...Something along those lines.
01:50:31 <hpaste> sohum annotated “Not sure what to call this question...” with “possibly simpler way to say what I want” at http://hpaste.org/55590#a55599
01:53:36 * hackagebot NanoProlog 0.3 - Very small interpreter for a Prolog-like language  http://hackage.haskell.org/package/NanoProlog-0.3 (JurrienStutterheim)
01:56:10 <q0tw4> > data A = A
01:56:10 <lambdabot>   <no location info>: parse error on input `data'
01:56:22 <q0tw4> it is not 7.4 :(
01:58:31 <Sgeo_> q0tw4, lambdabot isn't GHCi either
01:58:36 <Sgeo_> @hoogle IO Version
01:58:37 <lambdabot> Did you mean: :: IO Version
01:58:38 <lambdabot> Data.Version module Data.Version
01:58:38 <lambdabot> Data.Version Version :: [Int] -> [String] -> Version
01:59:41 <Sgeo_> @version
01:59:41 <lambdabot> lambdabot 4.2.2.1
01:59:41 <lambdabot> darcs get http://code.haskell.org/lambdabot
02:00:35 <hrolf> Hi #haskell, I'm reading Learn You a Haskell for Great Good and it doesn't explains the /= operator (maybe because it is too obvious.) Can anyone tell me what is it?
02:00:52 <mux> hrolf: it's just inequality, like != in C and many other languages
02:00:59 <mux> or <> in yet other languages
02:01:16 <sohum> hrolf: /= == != :P
02:01:28 <hrolf> I see, I thought it is akin to +=, -= etc. :)
02:01:35 <hrolf> s/is/was
02:01:40 <mux> yeah, I can see why you thought that
02:01:43 <q0tw4> last version of lamdabot in hackage is 4.2.3.2
02:01:55 <shachaf> hrolf: Haskell doesn't have mutation, which frees up (/=) etc. for other purposes. :-)
02:01:57 * hrolf sucks at English
02:02:35 <hrolf> shachaf: Makes sense.
02:03:02 <Sgeo_> > 1 /= 2
02:03:04 <lambdabot>   True
02:03:11 <Sgeo_> > 1 /= 1
02:03:12 <lambdabot>   False
02:03:24 <Blkt> good morning everyone
02:03:26 <Phlogistique> > (/=) /= (/=)
02:03:27 <lambdabot>   *Exception: (/=): No overloading for function
02:03:30 * mux suddenly remembers that inequality is # in Modula-3
02:03:41 <mux> that used to puzzle me a great deal
02:03:52 <opqdonut> heh
02:03:58 <opqdonut> great symbol!
02:04:19 <Phlogistique> what's inequality in GOTO++?
02:04:20 <Sgeo_> Phlogistique, the only reason it's not a type error is because lambdabot has a Eq instance defined for functions
02:04:39 <q0tw4> Can I start my own lambdabot on my computer and connect it to this channel?
02:05:10 <Entroacceptor> I'm not sure people like too many bots in here
02:05:17 <Entroacceptor> but you can start your own instance
02:05:51 <mux> but the fact that lambdabot implements Caleskell rather than Haskell is sometimes confusing to newcomers :-)
02:06:36 <Sgeo_> > (1+) - (2+) $ 5
02:06:37 <lambdabot>   -1
02:06:42 <mux> :t (.)
02:06:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:06:46 <mux> that.
02:09:29 <mgsloan> 0_o seriously? its' on "The New Prelude"??
02:11:00 <mgsloan> that does seem like a bit of a bad decision.  :t and > are used to demonstrate things to nubs.  What'll they think when types come out different?
02:11:27 <mux> they'll have their mind blowns; but that will happen regardless when someone learns haskell :-P
02:11:28 <shachaf> mgsloan: lambdabot uses a few of Cale's functions, yes.
02:11:34 <shachaf> This is a bit controversial.
02:11:34 <mux> I'm not a big fan of this though
02:11:41 <mgsloan> also, I hereby declare that haskell noobs shall be referred to as nubs, in honour of the nub function
02:11:49 <mux> hah
02:12:02 <shachaf> mgsloan: I hereby declare that you're wrong.
02:12:38 <shachaf> (Very wrong.)
02:12:58 <mgsloan> :| Nein!
02:16:04 <mgsloan> alright, does "padawans" float your boat?
02:19:25 * mgsloan felt a great disturbance in the purity... as if a million lazy thunks were suddenly executed in a side-effecting fashion
02:20:33 <Sgeo_> > if True; then 5; else 6
02:20:33 <lambdabot>   <no location info>: parse error on input `;'
02:20:39 <Sgeo_> > { if True; then 5; else 6 }
02:20:40 <lambdabot>   <no location info>: parse error on input `{'
02:20:54 <Sgeo_> > id { if True; then 5; else 6 }
02:20:55 <lambdabot>   <no location info>: parse error on input `if'
02:21:03 <shachaf> Sgeo_: This is what /msg was invented for. :-)
02:21:07 <jessopher> if true { then 5; else 6; }
02:21:11 <jessopher> > if true { then 5; else 6; }
02:21:12 <lambdabot>   <no location info>: parse error on input `then'
02:21:17 * shachaf sighs.
02:21:23 <jessopher> sorry
02:21:24 <shachaf> @google DoAndIfThenElse
02:21:29 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
02:21:29 <lambdabot> Title: DoAndIfThenElse – Haskell Prime
02:21:36 <Sgeo_> shachaf, that's what I was trying to test
02:21:56 <shachaf> That's in Haskell 2010.
02:22:05 <shachaf> It's not in lambdabot.
02:22:07 <Sgeo_> Ah
02:22:47 <shachaf> Keep in mind that lambdabot runs a version of GHC from 2009 (more than 2 years old).
02:23:36 * hackagebot shake 0.1.3 - Build system library, like Make, but properly supports generated files.  http://hackage.haskell.org/package/shake-0.1.3 (NeilMitchell)
02:23:50 <shachaf> Wait, ndm released shake?
02:24:02 <shachaf> When did that happen?
02:24:15 <shachaf> Apparently 2 days ago.
02:24:37 <shachaf> Oh, a different version of shake by the same name.
02:24:37 <lambdabot> shachaf: You have 1 new message. '/msg lambdabot @messages' to read it.
02:27:21 <Sgeo_> >   \x -> x == x == True
02:27:22 <lambdabot>   Precedence parsing error
02:27:22 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
02:27:23 <Sgeo_> >.>
02:27:33 * Sgeo_ should stop
02:28:05 <shachaf> @eval Sgeo_: If you have a question about something, > ... -- Why is this happening? is a reasonable way to ask it.
02:28:31 <shachaf> @eval (I"m using @eval to avoid being notified by lambdabot.)
02:39:46 <Sgeo_> shachaf, I'm just playing with the things I see on the Haskell' thingy
02:40:01 <Sgeo_> Apparently, that line is supposed to parse according to the report, before Haskell 2010
02:48:14 <oleiade> Is there any real difference, other than syntaxic, between "where" statement, and "let ... in" statement in guards matching
02:48:26 <oleiade> ?
02:50:15 <shachaf> oleiade: "where" is associated with a binding (i.e., "=").
02:50:19 <shachaf> "let" is an expression.
02:50:40 <shachaf> (Other than in in the context of "do", perhaps, where it's very slightly different.)
02:50:50 <oleiade> hum, right :-)
02:50:56 <shachaf> "where" gets translated into "let", though, more or less.
02:52:00 <oleiade> It's just that i feel much more confortable in defining name/values and then using it (let/in) rather than do the logic, and then append the names/values, and wanna know if it implies real differences on the output :-)
02:52:09 <oleiade> thanks for you quick answer !
03:03:11 <_Ray_> Hi. If sin :: Floating a => a -> a, how can I be getting this error?     Couldn't match expected type `Integer' with actual type `Float'       In the first argument of `sin', namely `theta'. Theta is gotten from "theta <- [0,step..2*pi]", where step is a Float.
03:07:11 <q0tw4> > [sin theta | theta <- [0,0.1..2*pi]]
03:07:12 <lambdabot>   [0.0,9.983341664682815e-2,0.19866933079506122,0.2955202066613396,0.38941834...
03:07:14 <hpaste> “_Ray_” pasted “Type error?” at http://hpaste.org/55602
03:08:27 <_Ray_> hpaste doesn't seem to mind. The error I get from ghci is "Couldn't match expected type `Integer' with actual type `Float'     In the first argument of `cos', namely `theta'    In the second argument of `(*)', namely `(cos theta)'    In the first argument of `floor', namely `(r * (cos theta))'"
03:12:52 <hpaste> q0tw4 pasted “for _Ray_: r was Integer” at http://hpaste.org/55603
03:13:30 <q0tw4> Integer * (sin ..) :: Integer
03:13:57 <_Ray_> Well, even if I change everything in the signature to Float it's still wrong :s
03:14:41 <_Ray_> Oh, floor returns Integral
03:15:15 <_Ray_> Thanks :)
03:20:15 <hrolf> I'm using tryhaskell.org and when I type "doubleMe x = x + x" I get parse error on input '=' (I get this line from LYaHfGG)
03:22:39 <koala_man> hrolf: I don't think tryhaskell.org supports defining values like that. you can use 'let doubleme x = x + x in doubleme 4' though
03:28:51 <statusfailed> Why does this file (https://github.com/lymar/hastache/blob/master/example/listsGeneric.hs) give a type error when main is commented out?
03:29:11 <statusfailed> I don't see how main can affect the type signature of another function
03:29:51 <statusfailed> I guess it's because main provides an explicit use and so it can infer the type?
03:30:38 <jessopher> whats the type error
03:30:38 <rostayob> is there a preferred lense package?
03:30:42 <rostayob> *lenses
03:31:08 <Entroacceptor> yes, three of them!
03:31:09 <rostayob> fclabels?
03:31:15 <rostayob> data-lens?
03:31:19 <rostayob> which to choose?
03:31:26 <statusfailed> jessopher: Ambiguous type variable `m0' in the constraints
03:31:33 <statusfailed> (etc.)
03:31:34 <statusfailed> it's quite long
03:31:52 <jessopher> paste the error on hpaste, if you could
03:31:54 <statusfailed> I hiaven't used generics before though
03:31:54 <statusfailed> ok
03:31:55 <Entroacceptor> data-accessor
03:31:56 <Lemmih> statusfailed: I think your guess is right.
03:33:08 <hpaste> statusfailed pasted “Hastache generics error” at http://hpaste.org/55604
03:33:21 <statusfailed> jessopher: pasted
03:33:21 <Entroacceptor> rostayob: http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio
03:34:34 <rostayob> Entroacceptor: I think I'll go with fclabels, I'm lazy and I like the automatic deriving
03:34:57 <statusfailed> oh sorry, the line numbers are off in that error
03:34:59 <statusfailed> I used the wrong file
03:35:24 <statusfailed> otherwise it's the same
03:35:48 <jessopher> yeah, it has an ambiguous type without the use, im not familiar with the library, but the error message is pretty straight forward
03:35:50 <mgsloan> <3 fc-labels
03:37:03 <statusfailed> jessopher: I guess I don't really understand the ambiguity though
03:37:42 <statusfailed> why can't m be any monad?
03:39:00 <rostayob> Entroacceptor: actually, data-lens has this http://hackage.haskell.org/packages/archive/data-lens/2.0.2/doc/html/Data-Lens-Lazy.html , which is what I need
03:39:04 * jessopher is generics inept
03:39:37 <jessopher> statusfailed: is there some reason why you cant just specify a type for context?
03:40:34 <statusfailed> jessopher: Oh i can, i'm just not really sure why I have to
03:41:15 <statusfailed> jessopher: i.e. why does it have to be MuContext IO rather than just MuContext m?
03:41:52 <Dodek> hey, is there a way to declare that a module exports a type along with all type constructors? something like module MyModule (MyType(*)) where ...
03:41:55 <Dodek> ?
03:43:56 <jessopher> MyType(Constructor1,..,ConstructorN) or MyType(...) for all constructors
03:44:25 <mreh> quicksilver: Hiya, just working on some reactive again, could you provide some input on the operation of mappend for events
03:47:15 <Dodek> jessopher: i don't understand -- MyType(...) won't compile and MyType() won't export any constructors. what do you mean?
03:47:33 * jessopher may have gotten that wrong
03:49:25 <jessopher> works for me, sec, I'll paste
03:50:00 <mreh> sorry to but in, but isn't the syntax "MyType(..)"
03:50:03 <hpaste> jessopher pasted “type/constructor export” at http://hpaste.org/55605
03:50:30 <jessopher> mreh: you are probably right
03:50:56 * jessopher only half parsed the question
03:51:38 <mreh> Dodek: MyType(..)
03:52:01 <mreh> in your module declaration, module MyModule ( MyType(..) ) where ...
03:52:12 <mreh> where ... is the rest of your program
03:53:16 <Dodek> oh two dots instead of three
03:53:19 <Dodek> thanks, mreh
03:53:33 * jessopher hangs his head in shame :P
03:55:50 <mreh> @tell quicksilver just wrestling with efficiency concerns with the Monoid instance of Event, it seems to hang onto useless data for quite a while, can you suggest a way to have it garbage collected?
03:55:51 <lambdabot> Consider it noted.
03:55:58 <mreh> @botsnack
03:55:58 <lambdabot> :)
03:56:03 <mreh> good lambdabot
03:57:05 <mreh> man this reactive is elegant, apart from when it slows down horrendously
04:24:27 <MiggyX> any good Haskell / functional programming books apart from "learn you a haskell" , "real world haskell" and "haskell the craft of functional programming" ?
04:27:38 <mreh> MiggyX might be time to start reading some papers
04:28:05 <MiggyX> mreh: I've got a big amazon voucher that I need to use :)
04:28:18 <MiggyX> However I will definitely be going through some papers. I'm interested in using Haskell as part of my research
04:32:49 <Botje> MiggyX: depends on which areas you're interested in.
04:32:58 <Botje> if it's compilers I can recommend a few books
04:35:00 <MiggyX> Botje: I'm looking into software development methodologies. Currently they tend to focus more on time and resource management but I think this is only one dimension of the problem. An ideal methodology helps free up developers "brain time" by removing the annoying bits - i.e. death by a thousand cuts :)
04:36:36 <mreh> my functional programming matters - john hughes
04:36:39 <mreh> lol
04:36:56 <mreh> www.cs.utexas.edu/~shmat/courses/cs345/whyfp.pdf
04:37:15 <mreh> that's a good one
04:38:18 <quicksilver> mreh: that is a problem I meant to think about.
04:38:18 <lambdabot> quicksilver: You have 1 new message. '/msg lambdabot @messages' to read it.
04:38:34 <quicksilver> mreh: I don't have a particularly good answer though.
04:38:43 <quicksilver> well, I don't have any answer at all :)
04:46:06 <mreh> quicksilver, okay
04:55:18 <mreh> quicksilver: do you think it's possible?
04:55:33 <Phyx-> afternoon haskellians
04:55:45 <MiggyX> mreh: the idea of code that you can easily reason about is very interesting :)
04:55:52 <quicksilver> mreh: basically it needs restructuring so that stuff is protected under constructors
04:56:24 <mreh> quicksilver: my intuitive says that it has something to do with improving values...
04:56:28 <quicksilver> mreh: and then as things progress you need to destructure and allow the parts you don't need any more to GC
04:56:39 <quicksilver> it is the purpose of improving values, yes
04:56:52 <quicksilver> but there are things about conal's exact approach I didn't like
04:57:19 <mreh> that's the stuff I never did digest
04:57:23 <mreh> unamb etc
04:57:48 <mreh> you've just use a flat time type here right? that's the problem
04:58:02 <quicksilver> he cheated (IMO)
04:58:26 <quicksilver> by trying to map the improving semantics onto GHC's thunks
04:58:39 <quicksilver> rather than actually modelling them explicitly in haskell
05:01:49 * mreh goes to read Warren Burton
05:01:53 <wereHamster> I'm trying to make a recursive parsec parser. With no luck so far (I'm stuck in an endless loop). Does anyone have an example how to do that? Perhaps in an existing library or app?
05:02:30 <mreh> wereHamster: does it consume input?
05:02:57 <wereHamster> mreh: I don't think so
05:03:12 <wereHamster> good point
05:04:28 <wereHamster> the input should be parsed from the end, maybe I could reverse the string?
05:05:17 <quicksilver> you can't have left recursion in parsec parsers
05:05:20 <quicksilver> all otehr recursion is fine
05:05:22 <mreh> Parsec is LL
05:05:51 <mreh> it's possible to convert a left recursive grammar
05:06:05 <quicksilver> well, it's considerably more than LL - it's context sensitve
05:06:20 <quicksilver> but it's left-biased, if you like
05:06:27 <quicksilver> as mreh says, left-recursion can always be removed.
05:06:31 <wereHamster> mreh: what is LL?
05:06:34 <quicksilver> it's a mechanical process in fact.
05:06:50 <quicksilver> wereHamster: it's a classification of grammars. It probably won't help you to know the difference.
05:06:50 <mreh> a class of grammars
05:06:58 <mreh> :)
05:06:58 <quicksilver> Specially since parsec isn't actually LL anyway :)
05:07:11 <wereHamster> I'm struggling with haskell as it is, stop confusing me even more :)
05:08:33 <quicksilver> wereHamster: the short answer is - the solution to your problem is really easy, but you won't get it without showing us the code.
05:09:06 <wereHamster> working on that :)
05:11:40 <mreh> i don't know why, but I feel FPR might be the solution to very large number of problems
05:12:54 <donri> functionally productive reactions?
05:12:59 <hpaste> wereHamster pasted “my non-working parser” at http://hpaste.org/55607
05:13:14 <quicksilver> Fulmopulmonary Resuscitation
05:13:27 <donri> sounds like a ghx extension
05:13:32 <donri> ghc
05:14:03 <wereHamster> quicksilver: see the hpaste
05:14:05 <quicksilver> wereHamster: so the problem is that parent has 'rev' as its leftmost branch
05:14:19 <quicksilver> wereHamster: and rev has parent as its leftmost branch in its first alternative.
05:14:23 <wereHamster> yes. as it should be able to recursively parse "foo^1^2^^"
05:14:32 <quicksilver> this makes a loop
05:14:44 <quicksilver> presumably eventually it is supposed to bottom out at a 'refname' ?
05:14:57 <quicksilver> if that's the case then swapping 'rev' round should break the recursion
05:15:02 <wereHamster> that much I figured out. refname or a few other cases. yes
05:15:02 <quicksilver> rev = refname <|> parent
05:15:15 <quicksilver> it tries the left branch first.
05:15:27 <quicksilver> if parent is first, then it will always end up trying rev again
05:15:30 <quicksilver> infinite loop
05:15:37 <quicksilver> if it tries refname first it has a way of stopping
05:15:48 <wereHamster> but then refname has to be recursive to capture everything that might come after the refname
05:16:06 <wereHamster> sorry, not recursive. But capture the ^^2^ stuff
05:16:34 <quicksilver> I don't understand your objection
05:16:45 <quicksilver> refname <|> parent is statically the same grammar as parent <|> refname
05:16:51 <quicksilver> it doesn't change the language
05:16:59 <quicksilver> it's only an operational cahnge, in that parsec tries the left branch first
05:17:02 <wereHamster> if I reverse parent <|> refname, then the test produces Refname "foo" :: Revision
05:17:20 <wereHamster> I might need to rearrange the data
05:17:27 <mreh> <|> implements choice not sequence
05:18:10 <quicksilver> trying to understand your grammar, wereHamster
05:18:12 <mreh> butting in again
05:18:21 <wereHamster> quicksilver: do you know git?
05:18:31 <quicksilver> nope.
05:18:37 <quicksilver> well I don't know how it names its revisions, anyhow
05:18:46 <quicksilver> I have some limited famliarity with what it does, of course
05:18:49 <hpaste> srhb pasted “Do notation vs chaining” at http://hpaste.org/55608
05:19:17 <srhb> In the above paste I thought I managed to rewrite a chained version of some IO to a do-notation form, however,only the first version works. Can someone tell me what I did wrong?
05:19:20 <quicksilver> is it *always* a refname first, wereHamster ?
05:19:29 <quicksilver> is the grammar not something like:
05:19:39 <wereHamster> quicksilver: yes.
05:19:51 <quicksilver> refname >> many (char '^' <*> optional decimal)
05:20:06 <quicksilver> no recursion at all in the refname part then
05:20:12 <wereHamster> what does >> mean here?
05:20:14 <quicksilver> well no recursion at all at all
05:20:17 <quicksilver> it means "and then"
05:20:28 <quicksilver> in fact, I should have saiid
05:20:34 <wereHamster> what's the difference between that and <*> ?
05:20:37 <quicksilver> refname >> many (char '^' >> optional decimal)
05:20:49 <quicksilver> the difference is that >> ignores the result of the left side
05:21:01 <quicksilver> which is not what you want, but doesn't matter if we're just talking about the grammar
05:21:03 <wereHamster> well, I need that :)
05:21:15 <quicksilver> I know you do but that's not the point yet
05:22:03 <quicksilver> do { r <- refname; n <- many (char '^' *> optional decimal); return (r,n) }
05:22:03 <wereHamster> anyway, there's much more cases than a simple ^n, like ^{}, ~n, @{..}
05:22:04 <quicksilver> then.
05:22:37 <quicksilver> srhb: "only the first version works"
05:22:44 <quicksilver> srhb: is it too much to ask what the second version does?
05:22:57 <quicksilver> does it spray salad dressing all over your bedroom? unleash a horde of snarling dogs?
05:23:07 <srhb> quicksilver: ... I always forget to attach the error. One second. sorry.
05:23:25 <quicksilver> srhb: anyhow I see a problem
05:23:28 <statusfailed> How does OverloadedStrings work?
05:23:34 <statusfailed> that doesn't mean I can treat String as ByteString does it
05:23:38 <statusfailed> no.
05:23:41 <statusfailed> ok nevermind...
05:23:42 <quicksilver> srhb: "path $ \q -> " is not the same as "path >>= \q ->"
05:23:43 <hpaste> srhb annotated “Do notation vs chaining” with “Do notation vs chaining (annotation)” at http://hpaste.org/55608#a55609
05:23:59 <quicksilver> srhb: it's >>= that you can rewrite into do notation, not $.
05:24:35 <srhb> quicksilver: Aha. But since successive calls to path give different results, I thought I could still do like in the do notation.
05:24:47 <quicksilver> wereHamster: fine, but extra cases aside do you see why my grammar is simpler and parses the same stuff?
05:24:54 <wereHamster> quicksilver: I sure do
05:24:56 <quicksilver> wereHamster: you can of course add extra cases too.
05:25:01 <srhb> I mean, dir "set" $ ok "Added a message!" <-- does work
05:25:18 <srhb> (I assume.)
05:25:23 <quicksilver> srhb: "successive calls to path give different results" is not really the point.
05:25:31 <quicksilver> srhb: the point is that do notation represents >>=
05:25:40 <quicksilver> srhb: if you're not using >>= you can't rewrite that into do notation :)
05:25:58 <srhb> quicksilver: Ah, damn. I see it now. Thank you.
05:26:16 <quicksilver> do { q <- path; foo q } is equivalent to path >>= \q -> foo q
05:26:22 <quicksilver> not path $ \q -> foo q
05:27:14 <metallurgy> hey anyone there ?
05:27:19 <metallurgy> i have a quick question ... xD
05:27:27 <srhb> metallurgy: /who #haskell
05:27:31 <srhb> :)
05:27:37 <metallurgy> xD
05:27:50 <metallurgy> well i m just starting to learn haskell and i downloaded winhugs xD
05:27:55 <drdo> Why would one throw an exception with error in the middle of library code?
05:28:06 <wereHamster> quicksilver: maybe I should represent a revision as refname + many modifier where modifier is ^n, ~n etc. What do you think?
05:28:07 <metallurgy> is it correct that i can write haskell in notepad and save it as .hs ?
05:28:08 <quicksilver> drdo: one shouldn't.
05:28:16 <srhb> metallurgy: Of course.
05:28:20 <metallurgy> how come i cant run it though ? what do i have to do ? save somewhere ?
05:28:23 <ion> metallurgy: You may want to use ghci instead of hugs.
05:28:23 <quicksilver> drdo: unless it's intened to represent a case which should never happen.
05:28:36 <srhb> metallurgy: Haskell code is just text, any editor that can save plaintext can write haskell files, including notepad.
05:28:42 <quicksilver> wereHamster: yes, I think that.
05:28:44 <metallurgy> okay
05:28:47 <metallurgy> but where do i save it ?
05:28:49 <drdo> quicksilver: yes of course, unless it is an actual "omg the world is coming to an end error"
05:28:51 <magicman> metallurgy: And also don't step into the .hs.txt trap.
05:28:58 <quicksilver> drdo: right.
05:29:01 <metallurgy> cos dont i need to :load <filename>
05:29:03 <drdo> libraries in hackage using error pissing me off
05:29:03 <srhb> metallurgy: Wherever you like and can conveniently run it afterwards with hugs, ghci, whatever.
05:29:12 <metallurgy> k
05:29:17 <metallurgy> let me try again...thank u !
05:29:38 <srhb> metallurgy: In ghci you would afterwards write :load "c:\path\to\your\file.hs", I believe.
05:29:49 <srhb> I assume hugs is similar.
05:30:43 <drdo> Is there something like the binary library that doesn't do this?
05:30:57 <quicksilver> drdo: yes.
05:31:08 <quicksilver> drdo: Binary is explicitly only for data which is guaranteed to be correctly formed.
05:31:18 <quicksilver> it deliberately has no error catching ability.
05:31:33 <drdo> I need to parse a network protocol, very simple though
05:31:41 <quicksilver> never ever use Binary for a network protocol.
05:31:49 <quicksilver> unless you want third parties to be able to crash your program :)
05:31:53 <quicksilver> try cereal, drod
05:31:54 <quicksilver> drdo
05:32:00 <quicksilver> http://hackage.haskell.org/package/cereal
05:32:04 <ion> cereal is nice-ish, yeah.
05:32:04 <metallurgy> srhb ... thank you ! i have to include the path xD duuuuh
05:32:21 <ion> metallurgy: Or cd to the path first.
05:33:01 <metallurgy> yeah
05:38:21 <wereHamster> how can I tell parsec to peak the next character but not consume it?
05:40:01 <mreh> try?
05:40:19 <mreh> try introduces backtracking
05:40:33 <quicksilver> yeah in practice you use try, rather than an explicit peek
05:41:34 <wereHamster> ok
05:44:39 <int-e> @type Text.ParserCombinators.Parsec.Combinator.lookAhead
05:44:39 <lambdabot> forall tok st a. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
05:47:01 <int-e> there's also Text.ParserCombinators.Parsec.Prim.getInput. But I've also found 'try' to be enough.
05:49:28 <area79> what is the situation of the haskell jobs right now?
05:53:50 * hackagebot floatshow 0.2.2 - Alternative faster String representations for Double and Float,  String representations for more general numeric types.  http://hackage.haskell.org/package/floatshow-0.2.2 (DanielFischer)
06:04:37 <statusfailed> Is a lens just a way of restricting what can be viewed on a data type?
06:04:44 <statusfailed> viewed/accessed
06:08:54 <wereHamster> does <|> consume teh input or backtrack if it doesn't find a match on its left side?
06:12:52 <Saizan> in parsec if you have (a <|> b) and a fails then b will be tried only if a didn't consume input
06:13:06 <Saizan> if you want to backtrack anyway use (try a <|> b)
06:13:50 * hackagebot uni-htk 2.2.1.1 - Graphical User Interface for Haskell Programs  http://hackage.haskell.org/package/uni-htk-2.2.1.1 (ChristianMaeder)
06:16:50 <wereHamster> seems like attoparsec doesn't have such restriction: http://hackage.haskell.org/packages/archive/attoparsec/0.9.0.0/doc/html/Data-Attoparsec.html#v:string
06:21:45 <Saizan> yeah, but that only matters when a = string ..; i think
06:33:12 <mm_freak> wereHamster: it's the same in attoparsec
06:33:21 <mm_freak> you will need the 'try' combinator
07:03:50 * hackagebot arithmoi 0.2.0.2 - Efficient basic number-theoretic functions.  Primes, powers, integer logarithms.  http://hackage.haskell.org/package/arithmoi-0.2.0.2 (DanielFischer)
07:08:36 <aadrake> Is it problematic to parse JSON with aeson if each document may or may not have all fields present?  Will I just end up with a lot of Maybe types in my data declaration?
07:18:50 * hackagebot snap-core 0.7.0.1 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.7.0.1 (DougBeardsley)
07:20:04 <Phyx-> does anyone know if UHC supports unicode files?
07:23:50 * hackagebot stringsearch 0.3.6.3 - Fast searching, splitting and replacing of ByteStrings  http://hackage.haskell.org/package/stringsearch-0.3.6.3 (DanielFischer)
07:24:30 <ClaudiusMaximus> Phyx-: unicode source? or with readFile?  (i think i have an install somewhere, could test)
07:26:34 <Phyx-> ClaudiusMaximus: unicode source, http://svn.zhox.com/AG.hs is the file i'm loading, but I'm calling the parsers directly, I don't have the whole compiler compiled
07:27:01 <Phyx-> I'm trying to figure out if I'm missing a flag, or if the compiler just doesn't allow unicode chars in the file
07:28:15 <ClaudiusMaximus> Phyx-: first guess, what are you locale settings? (link is 404 here)
07:28:32 <Phyx-> ah, seems .hs is not registered
07:29:48 <ClaudiusMaximus> can't seem to find my uhc install - must be on a different machine that isn't powered up at the moment..
07:30:10 <Phyx-> ClaudiusMaximus: my locale settings are set to English, but ghc loads the file fine
07:30:14 <Phyx-> "γ var _ = Nothing"
07:30:24 <Phyx-> UHC doesn't seem to like the γ
07:31:20 <kmc> roconnor, thanks for the bug reports regarding my use of the 'colour' library
07:31:49 <roconnor> kmc: I tried to post to your blog but it looked to me like it didn't work
07:31:53 <roconnor> so I posted to reddit instead
07:32:02 <kmc> ok
07:32:39 <roconnor> I think you will find your gradients prettier with this change
07:32:55 <ClaudiusMaximus> Phyx-: g'luck, not sure what it is, i'm out of ideas (my $LANG is
07:32:56 <roconnor> but if you don't like it you can change back to non-linear RGB
07:32:57 <ClaudiusMaximus> oops
07:33:03 <ClaudiusMaximus> en_GB.UTF-8
07:33:17 <roconnor> kmc: http://scanline.ca/gradients/
07:34:48 <Phyx-> ClaudiusMaximus: Thanks for trying, I'm gonna look at the source of the parser
07:36:37 <kmc> cool
07:39:00 <aadrake> kmc: Can I ask you a question about JSON parsing?
07:40:43 <kmc> why me?
07:41:22 <copumpkin> lol
07:41:26 <Phyx-> lol
07:41:31 <aadrake> kmc: You helped me some days ago, so probably due to anchoring.
07:41:43 <kmc> :)
07:41:48 <kmc> you should just ask the channel
07:41:50 <copumpkin> aadrake: it's generally best on IRC to just ask a channel rather than putting a particular person on the spot
07:41:51 <kmc> i'll answer if i am able
07:42:32 <aadrake> copumpkin: Sometimes that works, but it's also helpful to ask directly due to highlighted names or bell notifications.
07:42:54 <copumpkin> aadrake: yes, but then you're putting someone on the spot and it puts them in the awkward position of having to reject someone or to do some work to answer the question
07:43:13 <copumpkin> which is more of a commitment than many people are willing to put in, if they're just sitting around idling on IRC
07:43:23 <opqdonut> best of both worlds: ask the channel and then add "(kmc? anyone?)"
07:43:28 <aadrake> The situation is that I have a JSON file that is nested, and not all fields are always present, so I'm not sure how the data declaration should work
07:43:50 * hackagebot hmpfr 0.3.3 - Haskell binding to the MPFR library  http://hackage.haskell.org/package/hmpfr-0.3.3 (MichalKonecny)
07:43:54 <copumpkin> put Maybes on fields that may not be available?
07:44:05 <aadrake> copumpkin: That was my first inclination, but I didn't know if that was needed.
07:44:22 <aadrake> copumpkin: If the Maybes aren't there, will there just be a failure if the field isn't present in that document?
07:44:25 <copumpkin> it probably will be, or if they can be absent in particular conditions
07:44:33 <copumpkin> then you might have a more precise type
07:46:23 <aadrake> I haven't done any JSON processing (or anything else) in Haskell, so this is a learning experience for me.  There aren't any particular conditions under which the fields would be absent.  Sometimes they're present and sometimes not.  If they aren't there then I don't care, but if I try to parse something that isn't there I'm confident Haskell will give me an error.
07:46:51 <kmc> what library (if any) are you using to convert between generic JSON types and your declared data type?
07:47:36 <aadrake> kmc: I have been looking at aeson, but the examples are a little tough to follow since I don't know much about Haskell yet.
07:48:01 <kmc> aeson is good
07:48:13 <kmc> but, maybe you should start with something simpler if you don't know haskell yet
07:48:23 <kmc> we can also help you understand the examples
07:49:36 <aadrake> kmc: The examples aren't too bad, but combining them with file IO is taking some time because it's not what I'm used to.  I usually do analysis in R or similar, but I want to start building data analysis tools in Haskell.
07:55:20 <kmc> aadrake, the question is a bit complicated because aeson supports three different ways to generate the parser from a data type
07:55:30 <kmc> see the comment here: http://hackage.haskell.org/packages/archive/aeson/0.4.0.0/doc/html/Data-Aeson.html#t:FromJSON
07:56:24 <aadrake> kmc: The TH option looked interesting to me.
07:56:30 <kmc> they're all interesting :)
07:56:47 <aadrake> kmc: Touchè
07:56:50 <kmc> if you're writing the parser yourself then you can handle missing fields however you like; perhaps using (.:?) and (.!=)
07:58:51 * hackagebot ListLike 3.1.4 - Generic support for list-like structures  http://hackage.haskell.org/package/ListLike-3.1.4 (JohnLato)
07:58:53 <kmc> i think the 'deriving Generic' option is the nicest in terms of how it's implemented, and being closer to how generic traversals in Haskell "should work"
07:58:53 * hackagebot snap-server 0.7.0.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.7.0.1 (DougBeardsley)
07:59:05 <kmc> however it's all kind of the same from the user perspective
07:59:21 <kmc> and it requires GHC 7.2 or newer
07:59:35 <kmc> also the TH version likely produces faster code
07:59:42 <aadrake> kmc: I don't know what those do.  I think I'll start with a subset of the file and get the file IO working, then move on to processing the lines as they're read.
08:03:35 <kmc> aadrake, (.:?) and (.!=) are defined by aeson, they're in the docs.  if that's what you were asking
08:04:19 <kmc> aadrake, processing JSON a line at a time seems unlikely to work
08:06:35 <hpaste> “Anakreontas Mentis” pasted “blaze page with scripts” at http://hpaste.org/55615
08:08:52 <mtbeedee> I am learning haskell and attempted a pw generator
08:08:58 <mtbeedee> it takes an arg from the command line
08:09:06 <mtbeedee> so I guess that taints stuff with IO
08:09:16 <mtbeedee> so I am having a problem getting the function to return the right type
08:09:22 <kmc> IO is not about "tainting"
08:09:28 <kmc> an IO Int is not a "tainted Int"
08:09:34 <mtbeedee> well
08:09:38 <kmc> it's an imperative program as a first-class value
08:09:44 <kmc> a program which, if executed, *would* produce an Int
08:09:52 <kmc> but at the time you're manipulating that value, there's no Int hiding inside
08:09:53 <mtbeedee> hmm
08:10:02 <kmc> http://www.haskell.org/haskellwiki/Introduction_to_IO
08:10:24 <Phyx-> :t isUpper
08:10:25 <lambdabot> Char -> Bool
08:10:48 <kmc> main = do { [arg] <- getArgs;  print (generatePw arg) }  -- maybe use something like this mtbeedee
08:10:49 <Phyx-> > isUpper 'γ'
08:10:49 <lambdabot>   False
08:10:53 <anakreon> Hello. I'm constructing a simple blaze html page but doesn't type check. http://hpaste.org/55616
08:11:01 <anakreon> The offending line is 10
08:11:01 <mtbeedee> I got it to the point where it expects a "String" but the inferred type is "IO [Char]"
08:11:14 <mtbeedee> which I figured would be the same thing basically, kmc
08:11:26 <kmc> mtbeedee, only if a recipe and a cake are the same thing
08:11:43 <kmc> anakreon, you have a type error, but you didn't tell us what it is
08:12:28 <mtbeedee> so at the end of the program where I try to putStrLn
08:12:35 <mtbeedee> and it gets an IO [Char]
08:12:41 <anakreon>     Couldn't match expected type `H.Attribute'
08:12:41 <anakreon>                 with actual type `H.AttributeValue -> H.Attribute'
08:12:42 <anakreon>     In the second argument of `(!)', namely `A.src'
08:12:42 <anakreon>     In the first argument of `mapM_', namely
08:12:44 <anakreon>       `(H.script ! A.type_ "text/javascript" ! A.src)'
08:12:45 <mtbeedee> it doesn't then force it to do the computation and get the "string"
08:12:48 <anakreon>     In a stmt of a 'do' expression:
08:12:50 <kmc> anakreon, better to put it on hpaste
08:12:51 <anakreon>         mapM_ (H.script ! A.type_ "text/javascript" ! A.src) scripts
08:12:52 <Phyx-> > isAlphaNum 'γ'
08:12:52 <lambdabot>   True
08:12:56 <kmc> don't flood the channel with more than a few lines
08:12:57 <kmc> mtbeedee, did you read "Introduction to IO"?
08:13:15 <mtbeedee> kmc: not yet
08:13:20 <mtbeedee> I guess I should do that
08:13:30 <kmc> it is short and helpful :)
08:13:47 <anakreon> I placed the code in hpaste. I have never placed error messages there
08:15:20 <kmc> anakreon, A.src is a function, but you're using it as the right hand argument to (!), which expects an Attribute
08:15:34 <kmc> i think you want:  mapM_ (\x -> H.script ! A.type_ "text/javascript" ! A.src x) scripts
08:15:56 <kmc> equiv.  mapM_ ((H.script !) . (A.type_ "text/javascript" !) . A.src) scripts
08:16:01 <kmc> but this is not necessarily easier to read
08:16:36 <kmc> another way would be:   sequence_  [ H.script ! A.type_ "text/javascript" ! A.src x  |  x <- scripts ]
08:17:32 <carpi> is there a function that take a list and un-concats? like for example if i give it a flat list of 9 elements,  i want it to return a list of list with each inner sublist having length 3..?
08:17:46 <kmc> carpi, i think that's in http://hackage.haskell.org/package/split
08:18:08 <gavri> how does adding "deriving Eq" manage to implement == using the value constructor order when the default definition in the Eq class is recursive with /= ?
08:18:16 <byorgey> yes, map (splitEvery 3)
08:18:36 <roconnor> gavri: generic programming
08:18:42 <kmc> gavri, the default definitions given in "class" are overridden by definitions given in "instance"
08:18:55 <kmc> it doesn't matter if that instance was written by you or derived
08:18:56 <byorgey> gavri: the default definition is only used if you don't specify or derive a more specific one
08:19:13 <geheimdienst> > splitAt 3 [1..10] -- carpi: you could also repeatedly use splitAt
08:19:13 <lambdabot>   ([1,2,3],[4,5,6,7,8,9,10])
08:19:14 <carpi> splitEvery? is that fucntion in prelude or some other library?
08:19:22 <kmc> it's in the package i just sent you a link to
08:19:39 <carpi> ah okie.. thanks.. im taking a look at it )
08:20:40 <carpi> geheimdienst: thanks.. that si definitely works..
08:28:15 <carpi> byorgey: thanks for writing Data.List.Split.. the functions in there was exactly what i was looking for
08:28:29 <byorgey> carpi: you're welcome, glad you find it useful!
08:28:51 * hackagebot ottparse-pretty 0.1.2 - Pretty-printer for Ott parse trees  http://hackage.haskell.org/package/ottparse-pretty-0.1.2 (BrentYorgey)
08:32:17 <mtbeedee> kmc: so I should like do output <- function
08:32:27 <mtbeedee> that will cause output to be the result of calling the function
08:32:37 <kmc> it's not a function, it's an IO action
08:32:43 <kmc> it will cause output to be the result of executing that IO action
08:32:48 <mtbeedee> got you
08:32:55 <kmc> for the scope of the IO action defined by the rest of the 'do' block
08:33:14 <kmc> the key most important thing is that evaluation and execution are distinct
08:33:26 <mtbeedee> HA
08:33:27 <mtbeedee> that worked
08:33:51 * hackagebot statestack 0.1.1 - Simple State-like monad transformer with saveable and restorable state  http://hackage.haskell.org/package/statestack-0.1.1 (BrentYorgey)
08:35:58 <kmc> most people start with a model of "IO taint" or "pure vs. impure functions" but that is fundamentally incorrect
08:36:27 <mtbeedee> kmc: so for any type you can have like "IO a" where your IO will result in an a
08:36:32 <kmc> yes
08:36:46 <mtbeedee> then you need to get it to execute that IO action somehow
08:36:47 <kmc> a value of type IO T is an imperative program which, if executed, would produce a result of type T
08:36:55 <mtbeedee> which seems to be that do <- thingy
08:37:03 <mtbeedee> is there any other way to cause the execution?
08:37:12 <kmc> that doesn't really cause execution
08:37:18 <rwbarton> the do <- thingy is how you build up larger actions out of smaller ones
08:37:20 <kmc> it's actually just gluing together some IO actions to make a bigger IO action
08:37:29 <kmc> in fact the "do" syntax is sugar for this operator:
08:37:33 <kmc> (>>=) :: IO a -> (a -> IO b) -> IO b
08:37:44 <kmc> the only IO action which gets executed is 'main'
08:38:00 <mtbeedee> this is messing with my head
08:38:49 <kmc> that's to be expected :)
08:38:55 <mtbeedee> so the only way to "execute" an "action" is to somehow tie it into some kind of >>= within main?
08:38:59 <kmc> yeah
08:39:12 <kmc> (also when you type an action at the GHCi prompt, it will be executed)
08:39:25 <mtbeedee> because other than that, it is lazy and won't execute any IO that's inside some other function that's never called anyway
08:39:36 <kmc> that's not about "lazy"
08:39:45 <kmc> lazy is about evaluation.  evaluation and execution are distinct.
08:39:45 <mtbeedee> true
08:39:52 <kmc> you can evaluate an IO action without executing it
08:39:53 <mtbeedee> ok, yea
08:40:00 <kmc> there's usually not much point, but you can do it
08:40:12 <mtbeedee> wait, how would that happen?
08:40:21 <mtbeedee> or
08:40:35 <kmc> you can use the 'seq' primitive to evaluate any value
08:40:39 <mtbeedee> you could build up chains of actions resulting in some "IO a"
08:40:39 <kmc> seq :: a -> b -> b
08:40:46 <kmc> but this will not perform IO
08:40:58 <hpc> mtbeedee: what other programming languages do you know?
08:41:14 <kmc> the only action which is executed is 'main'.  actions are values like any other, so they can be passed to functions, returned from functions, etc.  so 'main' is usually an expression which collects IO actions computed from elsewhere, and glues them together
08:41:26 <mtbeedee> hpc: c, java, python
08:41:40 <hpc> mtbeedee: imagine you had a C function main, which read a number from stdin, computed the sqrt, then printed it
08:41:56 <hpc> mtbeedee: you would have a function to read the number, a function to sqrt it, and a function to print it
08:42:07 <hpc> mtbeedee: the read and print functions both perform IO actions
08:42:16 <hpc> mtbeedee: but the sqrt function is just a simple bit of math
08:42:26 <mtbeedee> right, but when "read" and "print" are executed there is something to worth with
08:42:28 <monochrom> you can evaluate "if b then getLine else getLine". the result is getting it simplified to "getLine", assuming that b doesn't blow up.
08:42:41 <hpc> mtbeedee: so what you could theoretically do is mark the sqrt function as "pure"
08:42:41 <mtbeedee> in haskell it seems having some IO action doesn't necessarily cause something to happen
08:42:46 <mux> hpc: eh? I might be missing some context here, but read isn't monadic
08:42:48 <hpc> pure int sqrt(int x) { ...
08:42:58 <hpc> mux: hypothetical C example
08:43:03 <mux> oh, sorry
08:43:16 <hpc> mtbeedee: that "pure" bit just means that the sqrt function can't do anything to the outside world
08:43:28 <kmc> mtbeedee, correct, merely building an action somewhere does not cause IO to occur
08:43:34 <kmc> mtbeedee, the only action which gets executed is 'main'
08:43:53 <Sgeo_> Unless you cheat.
08:43:55 <Sgeo_> >.>
08:43:55 <kmc> hpc, now you're back in the wrong "pure vs impure functions" description
08:43:55 <hpc> mtbeedee: this is convenient, but imagine we were doing a lot of pure calculations; it would be easier to mark the "IO" functions, which deal with the outside world, and the compiler enforces it
08:44:30 <monochrom> in every programming language I have seen, having some code doesn't necessarily cause something to happen
08:44:30 <kmc> i think "pure vs. impure functions" is easy to understand, doesn't really need an analogy to C
08:44:44 <kmc> it's precisely because it's easy to understand that people jump to that as the wrong model for IO in Haskell
08:45:28 <kmc> a function of type «Int -> IO Char» is a pure function like any other.  you can call it many times and even force evaluation of the results, and no IO occurs
08:46:04 <hpc> mtbeedee: in haskell, everything is marked pure; the way you get away with it is that the pure function returns ANOTHER "special" impure computation which does what you want
08:46:13 <hpc> mtbeedee: so you would have something like
08:46:14 <mtbeedee> for example here http://pastebin.com/7pvrZTwA
08:46:16 <mauke> The paste 7pvrZTwA has been copied to http://hpaste.org/55620
08:46:22 <mtbeedee> if you leave off that last putStrLn you evaluate the thing
08:46:27 <kmc> only when that «IO Char» forms part of the IO action named 'main' does the IO occur
08:46:29 <mtbeedee> but never actually force the IO action
08:46:29 <hpc> mtbeedee: (impure int) readInt(int x) {...
08:46:53 <hpc> mtbeedee: which translates in haskell to readInt :: Int -> IO Int
08:47:12 <Sgeo_> mtbeedee, what's the type of getletters?
08:47:23 <mtbeedee> eh, Int -> IO String
08:47:36 <Sgeo_> Cant putStrLn an IO String
08:47:40 <mtbeedee> right
08:47:49 <mtbeedee> you need a output <-  getletters num
08:47:50 <kmc> you can (>>= putStrLn) an IO String
08:47:53 <mtbeedee> and then putstrln output
08:47:56 <kmc> :t (>>= putStrLn)
08:47:56 <lambdabot> IO String -> IO ()
08:48:13 <kmc> @undo do { output <- foo;  putStrLn output }
08:48:13 <lambdabot> foo >>= \ output -> putStrLn output
08:48:17 <kmc> @. pl undo do { output <- foo;  putStrLn output }
08:48:17 <lambdabot> putStrLn =<< foo
08:48:40 <hpc> mtbeedee: there's other functions as well that deal with impurity
08:49:01 <hpc> mtbeedee: you can't turn an impure value into a pure one, but you can "lift" computations
08:49:04 <aninhumer> oh cool, another neat thing lambdabot can do
08:49:08 <kmc> hpc, why are you still going on about "pure vs. impure functions"?  it's emphatically *not* the right way to think about the situation in Haskell.  it results in all kinds of wrong predictions.
08:49:35 * mux sighs
08:50:01 <Sgeo_> Some people wrongly think it's a useful Lie to Children?
08:50:05 <kmc> yes
08:50:15 <kmc> i think those people are wrong
08:50:23 <mux> some people disagree
08:50:26 <hpc> kmc: i was trying to explain it in a way that leads to the correct concept
08:50:37 <rostayob> i've read stuff about haskell talking about monadic computation in general as "impure"
08:50:45 <kmc> i know that when I was learning Haskell, i thought about "pure vs. impure functions" and I was constantly confused, basically cargo-culting "do" everywhere
08:50:50 <mux> I've been taught that way, I don't see how it ever hurt
08:50:50 <mtbeedee> I think I understand what is going on here now
08:50:59 <mtbeedee> thanks
08:51:04 <kmc> then i learned that IO actions are first-class values and it all made sense
08:51:06 <kmc> ymmv of course
08:51:15 <Sgeo_> IO a is a program that, if executed, gives back an a
08:51:37 <rostayob> kmc: you mentioned some time ago an alternative model to haskell "taint" approach to IO
08:51:48 <rostayob> while mantaining purity
08:51:49 <kmc> a Lie to Children is useful if the truth is much more complicated
08:51:50 <rostayob> but I can't remember
08:52:08 <kmc> in this case the truth is simple, and the wrong model is more complicated
08:52:19 <kmc> you have to keep adding rules to match real-world usage
08:52:23 <roconnor> free monad!
08:52:29 <kmc> for example, what about IO Int -> IO Int, or IO (IO Int)
08:52:37 <kmc> rostayob, i don't know what you mean
08:52:49 <rostayob> kmc: you mentioned some other way to do IO in a pure setting once
08:52:54 <kmc> rostayob, i don't know what you mean
08:53:05 <kmc> what do you mean by 'haskell "taint" approach to IO'
08:53:19 <kmc> do you mean the thing i've been saying is a wrong model for the past 20 min?
08:53:21 <rostayob> kmc: mh. ok, maybe it wasn't you, because the person i'm thinking about used that term
08:53:41 <Sgeo_> kmc, I think I've only seen IO (IO a) twice, once as a result of cargo culting <$> and <*>, and once in the documentation of reactive-banana, where the action registers a callback and gives back and action that can be used to deregister the callback
08:53:56 <rostayob> kmc: not really, you've been arguing against seeing monadic IO as "impure"
08:53:56 <kmc> Sgeo_, oh, you're missing out then
08:54:02 <Sgeo_> kmc, where else is it used?
08:54:04 <mtbeedee> one more thing about IO...
08:54:09 <rostayob> :t join
08:54:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:54:13 <monochrom> eh? "an alternative model to haskell "taint" approach to IO" means "a model that doesn't say taint", no?
08:54:40 <mtbeedee> so the only way to use it is to basically hook the input in main to the output from main.  There can be functions in the middle to manipulate it or whatever, but there's always an IO chain of functions in between.
08:54:42 <monochrom> and we just saw a model that doesn't say taint a few minutes ago, no? and it's right from kmc, no?
08:54:50 <kmc> Sgeo_,, how about spawn :: IO a -> IO (IO a)
08:54:52 <hpc> Sgeo_: ive seen IO (a -> IO b, IO ()) before
08:54:54 <kmc> http://hackage.haskell.org/packages/archive/spawn/0.3/doc/html/Control-Concurrent-Spawn.html
08:54:56 <hpc> Sgeo_: in a memo lib
08:55:00 <rostayob> monochrom: well taint in the sense that you can't get out of IO
08:55:15 <rostayob> not in the sense of pure/impure
08:56:08 <kmc> SPJ wrote a chapter for _Beautiful Code_; it defines a function of type [(STM a, a -> IO ())] -> IO ()
08:56:20 <The_Journey> I have a question, if nothing in Haskell can be modified, how can one implement an efficient data structure? Say for like a binary tree of 1000 elements, if you want to insert a new element you have to recreate the entire tree again?
08:56:31 <kmc> The_Journey, no, just the path from the root to the inserted node
08:56:39 <rostayob> The_Journey: pure data structures can be shared
08:56:40 <kmc> precisely because nothing can be modified, you can keep pointers back into the old tree
08:57:00 <mroman> Is there a function which takes a list [a,b,c,d] and a function f
08:57:02 <opqdonut> kmc: produce things concurrently with the "STM a" and then consume them with the "a -> IO ()" ?
08:57:03 <mroman> with returns
08:57:09 <rmyers> hello, im trying to compile "helloworld.hs" as per learn you a haskell - http://learnyouahaskell.com/input-and-output#hello-world - however, when it tries to link, i receive a bajillion errors: "ld: warning: could not create compact unwind for .LFB3: non-standard register 5 being saved in prolog"
08:57:11 <mroman> [f a b, f b c, f c d] ?
08:57:16 <kmc> opqdonut, it's a multi-way choice
08:57:16 <Sgeo_> And by "you", is meant "the program internally", I think
08:57:21 <wereHamster> mm_freak: btw: This combinator is provided for compatibility with Parsec. Attoparsec parsers always backtrack on failure.
08:57:26 <c_wraith> mroman: you can build one
08:57:26 <opqdonut> mroman: zipWith f list (tail list)
08:57:27 <wereHamster> the 'try' combinator
08:57:44 <opqdonut> > let l = [a,b,c,d] in zipWith f l (tail l)
08:57:44 <lambdabot>   Ambiguous type variable `c' in the constraints:
08:57:44 <lambdabot>    `GHC.Show.Show c'
08:57:44 <lambdabot>      a...
08:57:47 <opqdonut> bah!
08:57:54 <opqdonut> > let l = [x,y,z] in zipWith f l (tail l)
08:57:55 <lambdabot>   Ambiguous type variable `c' in the constraints:
08:57:55 <lambdabot>    `GHC.Show.Show c'
08:57:55 <lambdabot>      a...
08:57:57 <kmc> opqdonut, it waits for one of the STM actions to be successful and then executes the corresponding IO
08:57:58 <opqdonut> bah!
08:58:03 <parcs`> :: Expr
08:58:05 <opqdonut> kmc: right
08:58:07 <opqdonut> parcs`: thanks
08:58:11 <mtbeedee> mroman:  maybe some fold
08:58:23 <c_wraith> or :: [Expr]
08:58:29 <opqdonut> > let l = [x,y,z] in zipWith f l (tail l) :: [Expr]
08:58:30 <lambdabot>   [f x y,f y z]
08:58:34 <mm_freak> wereHamster: really?  i always used 'try'
08:58:40 <mm_freak> good to know
08:59:07 <mroman> mtbeedee: Is that possible with a fold?
08:59:18 <kmc> if we treat «IO (IO T)» as something advanced for wizards only, we're just as guilty as those who treat pointers, recursion, and first-class functions as something advanced for wizards only
08:59:19 <mtbeedee> well
08:59:19 <mtbeedee> scan
08:59:53 <kmc> if you're effective at using imperative and functional programming together, you will end up with a lot of types like that one
08:59:55 <mtbeedee> scanl1 (+) [1,2,3,4] will yield like [1,3,5,7]
09:00:16 <Sgeo_> rec = return rec -- what happens if I try to do something like this?
09:00:17 <mtbeedee> oh no, it accumulates
09:00:21 <mtbeedee> not applies
09:00:25 <kmc> Sgeo_, depends on the monad
09:00:28 <c_wraith> Sgeo_: an infinite type error?
09:00:30 <srhb> Does Haskell optimize things like drop 10 $ take 20 [foo i | i <- [1..]]?
09:00:40 <kmc> srhb, Haskell does not require anything in the way of optimization
09:00:40 <opqdonut> srhb: optimize how?
09:00:43 <kmc> GHC likely does
09:01:01 <opqdonut> that will very performant under GHC
09:01:16 <srhb> Sorry, yeah, I meant ghc of course.
09:01:25 <monochrom> I agree that whatever story you tell, it must explain IO (IO T) and (a -> IO T) -> IO T etc. These types are important for doing some kind of OO in Haskell, i.e., almost what every beginner wants to do.
09:01:27 <opqdonut> I mean, as performant as for example "map foo [10..20]"
09:01:47 <Sgeo_> OO in Haskell?
09:02:01 <srhb> So does it know to not evaluate foo i until i = 10, or does it know to optimize [1..] to [10..] already?
09:02:03 <kmc> yeah, as another example, the standard exception handling is based on types like IO a -> (e -> IO a) -> IO a
09:02:28 <opqdonut> srhb: none of the foo i are evaluated
09:02:33 <opqdonut> srhb: until you inspect them
09:02:38 <srhb> Duh, of course.
09:02:43 <srhb> Thanks. :-)
09:03:20 <monochrom> data MyObject = MO{ put :: Int -> IO(); get :: IO Int }  is OO in Haskell, if you don't need inheritance. (You don't need inheritance usually.)
09:03:21 <Sgeo_> srhb, foo isn't evaluated unless the thing resulting from foo i is looked at
09:03:29 <Sgeo_> Oh, opqdonut said tht
09:03:31 <Sgeo_> that
09:03:36 <aninhumer> does that mean it still generates useless 1-9s? or can this be optimised too?
09:03:36 <opqdonut> kmc: that can be understood with the "impure function" model. the impure function model explains all types a0 -> a1 -> ... -> IO res
09:03:46 <opqdonut> kmc: the impure function model fails with nested IOs
09:03:52 <opqdonut> (AIUI)
09:04:04 <kmc> i think it fails to predict the correct order of execution in some other cases
09:04:25 <opqdonut> okay
09:04:26 <kmc> IO Bool -> IO t -> IO t -> IO t
09:04:42 <c_wraith> ifM?
09:04:43 <kmc> the "impure function" model would seem to prescribe a single answer for the order of effects in such a function
09:05:01 <kmc> the truth requires looking at the code to see how these IO actions are wired together
09:05:08 <monochrom> createMO = do { v <- newIORef 0; return MO{put = writeIORef v; get = readIORef v }.  note createMO :: IO MyObject which is isomorphic to IO (Int -> IO (), IO Int)
09:05:21 <aninhumer> :t if
09:05:22 <lambdabot> parse error (possibly incorrect indentation)
09:05:23 <quicksilver> aninhumer: yes, it still generates the useless 1..10
09:05:25 <aninhumer> whoops
09:05:28 <aninhumer> :t ifM
09:05:28 <lambdabot> Not in scope: `ifM'
09:05:33 <mroman> Does Ord imply Eq?
09:05:37 <mroman> or reverse?
09:05:39 <monochrom> and I do not expose the IORef because tomorrow I may change it to MVar or TVar
09:05:44 <alistra> ord imply eq
09:05:46 <Sgeo_> mroman, Ord implies Eq
09:05:46 <kmc> Ord implies Eq
09:05:48 <quicksilver> aninhumer: however it does so in a tight loop without allocating memory so it should be fast.
09:05:50 <kmc> you can ask ghci:  :i Ord
09:05:59 <c_wraith> aninhumer: if someone defined it, it'd have a type similar to what kmc showed there.  It just would be more polymorphic
09:06:01 <alistra> @src Ord
09:06:01 <lambdabot> class  (Eq a) => Ord a  where
09:06:02 <lambdabot>     compare      :: a -> a -> Ordering
09:06:02 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
09:06:02 <lambdabot>     max, min         :: a -> a -> a
09:06:17 <monochrom> so apart from inheritance, I have just done every OO-y thing, including encapsulation.
09:06:40 <kmc> monochrom, indeed, you have hidden state of an unspecified type, without using existential quantification :)
09:07:14 <alistra> :t (==)
09:07:15 <lambdabot> forall a. (Eq a) => a -> a -> Bool
09:07:18 <aninhumer> quicksilver: would it not have to allocate memory to then create the foo 1 - foo 9 thunks?
09:07:19 <kmc> this is one way that imperative stateful objects are nicer than functional pure-update objects
09:07:20 <alistra> :t show
09:07:20 <lambdabot> forall a. (Show a) => a -> String
09:07:27 <alistra> :t on
09:07:28 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
09:09:03 <monochrom> it is still an marvel to me that mutable reference has the power of existential type. then again, it even has the power of type cast in the wrong hands, so why am I surprised :)
09:09:38 <mroman> Ic.
09:09:50 <monochrom> it also has the power of recursion
09:09:56 <mroman> @src Eq
09:09:57 <lambdabot> class  Eq a  where
09:09:57 <lambdabot>     (==), (/=)   :: a -> a -> Bool
09:10:09 <mroman> Eq does not define < and > in that case.
09:10:25 <mroman> :t compare
09:10:26 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
09:10:39 <kmc> right, Eq things are comparable for equality but not necessarily ordering
09:10:44 <kmc> that said you should not trust @src too much
09:10:55 <jamil_1> hi all
09:11:00 <kmc> ghci's :i will also give you the definition of a class
09:11:07 <jamil_1> what is wrong with this code: http://paste.pocoo.org/show/524609/
09:11:24 <kmc> jamil_1, why don't you tell us
09:11:42 <jamil_1> kmc: compiler says: Lab1.hs:21:41: parse error on input `|'
09:11:44 <c_wraith> jamil_1: indentation is wrong
09:11:52 <c_wraith> jamil_1: you probably used tabs
09:11:58 <jamil_1> c_wraith: yep
09:12:05 <kmc> don't use tabs
09:12:32 <c_wraith> in the where block, all the declarations have to start in the same column
09:12:59 <c_wraith> that means the type signature for take_integers needs to start on the same column as the definition for it
09:13:23 <jamil_1> right
09:13:36 <monochrom> jamil_1: look at the paste yourself, right on the paste.pocoo.org page, not in your own editor. you see misalignment. it is also what the compiler sees.
09:14:02 <monochrom> do not trust your editor
09:14:18 <monochrom> programmers need to learn that WYSIWYG does not happen to them
09:14:20 <kmc> don't use tabs ever
09:14:23 <kmc> problem solved
09:15:40 <drdo> I need to mapM over a Data.Map.Map but I also need to key, how can i do this?
09:15:47 <c_wraith> What The Compiler Sees Is What You Get
09:15:48 <drdo> *the key
09:16:14 <mux> drdo: there's a mapWithKey function or something, right?
09:16:22 <mux> @src mapM
09:16:22 <lambdabot> mapM f as = sequence (map f as)
09:16:22 <kmc> drdo, mapM f . M.toList
09:16:38 <mux> drdo: you can use it and use sequence then
09:16:39 <c_wraith> kmc: you forgot the fmap M.fromList
09:16:43 <drdo> Well yes that's what i initially thought of
09:16:50 <drdo> converting to a list
09:17:09 <kmc> oh, i didn't know the result was supposed to be another Map
09:17:14 <kmc> maybe you can use Traversable
09:17:15 <jamil_1> what is the recommended editor for haskell ?
09:17:19 <drdo> Oh no, i actually don't care
09:17:24 <drdo> I want mapM_
09:17:27 <c_wraith> kmc: traversable won't give you the key
09:17:40 <mux> :t \m f -> sequence (mapWithKey f m)
09:17:41 <lambdabot> Not in scope: `mapWithKey'
09:17:47 <mux> :t \m f -> sequence (Data.Map.mapWithKey f m)
09:17:47 <c_wraith> oh, if it's mapM_, that's easier
09:17:48 <lambdabot>     Couldn't match expected type `[m a]'
09:17:49 <lambdabot>            against inferred type `M.Map k b'
09:17:49 <lambdabot>     In the first argument of `sequence', namely `(M.mapWithKey f m)'
09:17:58 <mux> ah, right.
09:18:00 <c_wraith> I wonder if edwardk has anything for this
09:18:16 <rwbarton> @hoogle mapWithKey
09:18:25 <drdo> mapWithKey definetly exists
09:18:32 <mux> it does, I just used it
09:18:40 <mux> only incorrectly :D
09:18:50 <gwern> > (30 * 958) / 60
09:18:54 <gwern> > ((30 * 958) / 60) / 60
09:19:00 <rwbarton> @type Data.Map.mapWithKey
09:19:09 <rwbarton> ... I don't know why I thought that would help.
09:19:30 <kmc> so...  mapM_ f . M.toList
09:19:34 <gwern> @botsnack
09:19:39 <lambdabot> Data.IntMap mapWithKey :: (Key -> a -> b) -> IntMap a -> IntMap b
09:19:39 <lambdabot> Data.Map mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
09:19:40 <lambdabot>   479.0
09:19:41 <lambdabot> forall k a b. (k -> a -> b) -> M.Map k a -> M.Map k b
09:19:41 <lambdabot> :)
09:19:42 <rwbarton> anyways, if you did want a mapWithKeyM that produced another Map you could use mapWithKey (,) plus traverse
09:19:42 <lambdabot>   can't find file: L.hs
09:19:44 <c_wraith> hmm, yes, edwardk does have something for this
09:19:48 <c_wraith> http://hackage.haskell.org/packages/archive/keys/2.1.1.1/doc/html/Data-Key.html
09:19:50 <gwern> huh
09:19:52 <gwern> > ((30 * 958) / 60) / 60
09:20:12 <c_wraith> mapWithKeyM_
09:20:16 <lambdabot>   7.983333333333333
09:20:58 <c_wraith> and there are instances of the required classes for Data.Map.Map
09:21:11 <parcs`> :t mapWithKey
09:21:11 <lambdabot> Not in scope: `mapWithKey'
09:21:15 <parcs`> :t M.mapWithKey
09:21:16 <lambdabot> forall k a b. (k -> a -> b) -> M.Map k a -> M.Map k b
09:21:21 <jamil_1> never use tabs...lesson learned
09:21:24 <gwern> > ((146 + 102) * 5) / 60
09:21:27 <jamil_1> thank ppl
09:21:29 <drdo> oh cool
09:21:31 <lambdabot>   20.666666666666668
09:21:41 <gwern> > (146 + 102)
09:21:42 <c_wraith> jamil_1: as far as editors, most people use vim or emacs, I think
09:21:43 <lambdabot>   248
09:21:48 <parcs`> :t Data.Traversable.sequenceA .M.mapWithKey ?f
09:21:49 <lambdabot> forall (f :: * -> *) a k a1. (Applicative f, ?f::k -> a1 -> f a) => M.Map k a1 -> f (M.Map k a)
09:21:59 <parcs`> do i win
09:22:09 <rwbarton> yes.
09:22:31 <parcs`> parcs`++
09:23:09 <parcs`> @karma parcs`
09:23:09 <lambdabot> You have a karma of 0
09:23:28 * ksf wants a library interface to ghc-pkg
09:24:44 <mux> ksf: I'd have expected Cabal to provide this
09:25:18 <c_wraith> mux: ghc-pkg is not actually part of cabal
09:25:23 <c_wraith> or Cabal, for that matter
09:25:27 <mux> yes I know
09:25:53 <geheimdienst> i'm fairly sure cabal-the-library can tell you the modules in a package, the packages installed, etc.
09:25:55 <ksf> it's got the data types, but I've got no idea how to make it produce one of those
09:27:52 <ksf> ...I'm just going to call out to ghc-pkg, for now.
09:53:52 * hackagebot anansi 0.4.3 - Simple literate programming preprocessor  http://hackage.haskell.org/package/anansi-0.4.3 (JohnMillikin)
09:54:03 <periodic> Huh, infix expressions with Parsec are actually a little tricky.
09:58:15 <parcs`> periodic: are you aware of Text.Parsec.Expr
09:58:24 <Peaker> Does use of GADTs ruin inference?
10:03:42 <periodic> parcs`: I am not!
10:04:05 <periodic> parcs`: I'm trying to get the infix precedence working in attoparsec right now.  Will look at that though.
10:04:34 <periodic> hmm... that looks almost too easy.
10:06:50 <Phyx-> is there a version of haskell IO that autodetects the encoding?
10:07:05 <periodic> Phyx-: I don't think that's possible, technically.
10:07:11 <periodic> You could do some heuristics.
10:07:21 <Phyx-> Notepad++ seems to do it
10:07:48 <Phyx-> i could be wrong though. i'm using System.IO.UTF8.readFile
10:07:50 <periodic> But even with UTF (byte things at the beginning I forgot the name of) they aren't required and lots of streams skip them.
10:07:58 <Phyx-> but it doesn't strip the BOM if present
10:08:00 <periodic> I think there are some basic heuristics.
10:08:04 <periodic> That's it, BOM.
10:08:12 <darkgerm> hello, I'm new to Haskell. I try the Example on wiki but it doesn't work...
10:08:23 <periodic> If there is a good BOM then you can be pretty sure what the encoding is.
10:08:37 <darkgerm> factorial n = if n > 0 then n * factorial (n-1) else 1
10:08:39 <periodic> But if there is no BOM you could maybe look for bytes that should be rare in certain encodings.
10:08:49 <periodic> darkgerm: are you using ghci?
10:08:57 <darkgerm> what I got is "syntax error"
10:09:06 <darkgerm> hugs
10:09:07 <Phyx-> right..
10:09:19 <periodic> > let factorial n = if n > 0 then n * factorial (n-1) else 1
10:09:20 <lambdabot>   not an expression: `let factorial n = if n > 0 then n * factorial (n-1) els...
10:09:22 <kmc> darkgerm, instead of some wiki example i recommend http://tryhaskell.org/
10:09:33 <periodic> > let factorial n = if n > 0 then n * factorial (n-1) else 1 in factorial 5
10:09:34 <lambdabot>   120
10:09:56 <periodic> Phyx-: I hate text encodings, personally.
10:10:39 <kmc> do you hate text too
10:11:16 <darkgerm> can't I define factorial to use?
10:11:21 <kmc> yes
10:11:27 <kmc> either put what you had in a file and load it
10:11:34 <kmc> or type it at the prompt with "let " before it
10:11:35 <periodic> kmc: Text is fine.  If the world were just Unicode code-points, that's fine.  The problem is representing those code-points...
10:11:57 <kmc> darkgerm, you'll also have a much easier time if you use ghci instead of hugs
10:13:01 <Phyx-> Prelude System.IO> localeEncoding
10:13:02 <Phyx-> CP437
10:13:04 <Phyx-> lol, WTH
10:13:08 <kmc> haha
10:13:08 <Phyx-> I don't even know what that is
10:13:11 <kmc> that's the best codepage
10:13:15 <darkgerm> how can I start ghci? command not found...
10:13:22 <kmc> that's the MS-DOS codepage where character 1 is a smiley face
10:13:25 <kmc> darkgerm, you'll have to install it
10:13:41 <kmc> you should just get Haskell Platform
10:13:50 <kmc> www.haskell.org/platform
10:13:54 <kmc> it includes ghci
10:14:01 * Phyx- switches it to utf8
10:14:27 <Saizan> darkgerm: have you installed ghc?
10:14:36 <monochrom> use "chcp 65001" for utf8
10:15:12 <darkgerm> installing now, at lang/ghc, freebsd
10:15:34 <mux> darkgerm: unfortunately this is old
10:15:54 <darkgerm> !!?
10:16:02 <mux> it's ghc 7.0.3
10:16:54 <kmc> that's fine
10:17:25 <kmc> the current Platform version is 7.0.4
10:17:46 <kmc> there are some bugfixes: http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/release-7-0-4.html
10:19:05 <kmc> i don't think it will matter if you're just learning the language
10:19:15 <carpi> is there any function to randomly choose an element from a list?
10:20:04 <darkgerm> thanks!
10:20:42 <monochrom> decompose that into "get a random number" and "index into a list". but you are better off with "index into an array". or at least "a sequence".
10:22:05 <Goosey> No instance for (Show (a0 -> a0))
10:22:05 <Goosey>       arising from a use of `print'
10:22:05 <Goosey>     Possible fix: add an instance declaration for (Show (a0 -> a0))
10:22:05 <Goosey>     In a stmt of an interactive GHCi command: print it
10:22:05 <Goosey> What does this mean? I used the same function before and it worked fine..
10:22:19 <kmc> you're trying to print a function
10:22:22 <carpi> monochrom: thanks.. I should have thought of that )
10:22:32 <kmc> carpi, i recommend Data.Sequence for this
10:22:41 <kmc> Goosey, cause you typed an expression with function type
10:23:02 <Goosey> Oh
10:23:06 <Goosey> Thanks...I fail
10:24:20 <kmc> carpi, QuickCheck has a helper function to pick a random element of a list
10:24:35 <kmc> but it's probably awkward to use outside the context of QuickCheck
10:25:38 <carpi> kmc: i will check that then.. didn't know quckcheck can be used for more than testing)
10:25:56 <kmc> it's probably awkward to use outside the context of QuickCheck
10:26:42 <periodic> damnit, every time I write an Arbitrary instance for a recursive datastructure I forget to limit the depth...
10:26:43 <kmc> the function exists to help you write instances of Arbitrary for your own types
10:29:22 <carpi> actually.. i think this time im gonna do as monochrom suggests. generating an index randomly
10:31:51 <kmc> if you are indexing the same list many times, it will be more efficient to convert it to another data type first
10:32:00 <kmc> because lists do not support efficient random access
10:32:45 <kmc> hmm, has anyone tried to implement pure-functional skip lists?
10:33:49 <Eduard_Munteanu> An immutable array should be fine.
10:33:53 * hackagebot gps2htmlReport 0.2.1 - GPS to HTML Summary Report  http://hackage.haskell.org/package/gps2htmlReport-0.2.1 (RobStewart)
10:34:21 <kmc> for whatever reason i find the Array API to be annoying
10:34:29 <kmc> Data.Sequence and Data.IntMap should *also* be fine
10:34:37 <Eduard_Munteanu> Yeah, it kinda is.
10:34:53 <kmc> Sequence is kind of the best of both worlds between lists and arrays
10:35:02 <Eduard_Munteanu> IIRC there's no way to use a generating function to initialize it, or stuff like that.
10:44:14 <periodic> Recursive decent parsers kinda suck for infix operations, huh?
10:44:18 <periodic> Or is there a trick to it...
10:44:26 <periodic> oooh, wait, I think I know.
10:45:37 <parcs`> left factoring?
10:46:18 <kmc> you could look at how Text.Parsec.Expr works
10:46:33 <periodic> parcs`: exactly.
10:47:03 <periodic> I accidentally un-left-factored when I was trying to just get it working with precedence properly.
10:50:32 <monochrom> my http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements has examples
10:51:35 <kmc> btw you can remove some of the boilerplate at 2.2 with -XRecordWildCards
10:52:11 <periodic> Wow, that made a huge difference.  Was starting to take seconds to parse strings of only ~100 chars, but now it's all instant to do 100 quickcheck tests.
10:52:34 <parcs`> what did? Text.Parsec.Expr?
10:52:40 <periodic> left-factoring.
10:52:44 <periodic> properly.
10:53:25 <periodic> It basically just looks like I cached the result of the higher-precedence sub-expression.
10:53:45 <periodic> Minor change in the structure of the code.
10:54:01 <kmc> it's unfortunate that the programmer must explicitly left-factor the grammar
10:54:05 <kmc> seems low-level
10:54:29 <periodic> kmc: Yeah, it's a bit odd.  There are some automatic transformations you can do, I think...
10:54:39 <kmc> i'm guessing this is not a problem with a parser generator
10:54:47 <periodic> I mean, it's a fairly mechanical transformation.
10:55:09 <periodic> Those have other problems...
10:55:12 <kmc> yes
10:55:33 <periodic> but a parser-generator that generates uses a LALR grammar is guaranteed to run in O(n) I think.
10:55:57 <kmc> *nod*
10:55:57 <periodic> Since every step consumes one character of input and has a finite number of reductions.
10:56:17 <kmc> i bet there are alternative ways to build a parsing EDSL which don't have this problem
10:56:18 <periodic> It's nice, but I would not miss YACC if I never had to use it again.
10:56:39 <kmc> i don't know much about parsing, but i bet edwardk knows
10:57:08 <kmc> i enjoyed his posts and presentation about packrat parsing
10:57:12 <kmc> http://comonad.com/reader/2011/a-parsec-full-of-rats/ http://comonad.com/reader/2011/a-parsec-full-of-rats-part-2/
10:57:30 <kmc> periodic, sure, but in addition to being a parser generator, yacc is a *bad* parser generator *for C*
10:58:05 <Goosey> > map ($ 2) [(a+),(b*)]
10:58:06 <lambdabot>   [a + 2,b * 2]
11:01:15 <lpsmith> Out of curiosity, is there some kind of trick that lets you declare    instance (Class a, Class b, Class c) => Class2 (a,b,c) where ... for all tuple sizes?
11:01:40 <kmc> template haskell
11:02:47 <lpsmith> right,  template haskell would let you define a generator,  but is there any way to say "call this generator whenever you run across a tuple size that isn't covered?"
11:03:09 <kmc> don't think so
11:03:20 <kmc> in practice people don't use big tuples
11:03:34 <kmc> or... shouldn't
11:03:47 <mkscrg> what are folks' feelings in here about enumerator vs iterIO?
11:03:56 <periodic> If you're using big tupples, you should probably reconsider your data types.  Consider using a record type.
11:04:25 <periodic> However, it is unfortunate that there isn't a good way to iterate over a tuple...
11:04:44 <kmc> the components can have different types
11:04:48 <kmc> so what do you iterate exactly
11:05:15 <periodic> I've wanted a way to write a function that takes as input a tuple where every element is of a typeclass/family and the output is an equal size tuple where the types match the type of the inputs in some way.
11:05:28 <periodic> Well, in my case it would defining selects on a DB query.
11:06:09 <periodic> It would be nice to have input of type (NameColumn :: Column Text, BirthdayColumn :: Column Date) and get output of type (Text, Date)
11:06:22 <periodic> where the input is some sort of rank2type.
11:06:32 <periodic> But I'm not sure if that could ever work in the type system.
11:06:49 <periodic> Instead I'm stuck with casting values.
11:07:04 <kmc> ah, so something like
11:07:58 <kmc> (Foo a, Foo b) => (forall t. (Foo t) => t -> t) -> (a, b) -> (a, b)
11:08:48 <wereHamster> is there a library which will help me writing commandline apps (parsing arguments etc)?
11:08:52 <kmc> yes
11:08:55 <kmc> it's called cmdargs
11:08:58 <parcs`> if you need variable-size tuples consider using heterogenous lists
11:09:04 <Goosey> (\x xs -> f x : xs) is it possible to construct that using a function composition?
11:09:14 <kmc> @pl (\x xs -> f x : xs)
11:09:14 <lambdabot> (:) . f
11:09:56 <kmc> periodic, you can write a function of that type.  in GHC 7.4 you can write it once for all type classes, making 'Foo' into a parameter
11:16:47 <Phyx-> i prefer GetOpts myself
11:19:55 <hpaste> kmc pasted “mapping over a pair with a typeclass constraint” at http://hpaste.org/55622
11:20:00 <kmc> periodic, like so ^^
11:20:31 <kmc> i had to pass this 'P' argument because it wouldn't infer the necessary context
11:22:18 <Goosey> kmc: What does pl stand for ?
11:22:24 <kmc> pointless
11:22:32 <mroman> How does ghc convert Numbers to (Num a)?
11:22:33 <kmc> as in http://en.wikipedia.org/wiki/Pointless_topology
11:22:38 <kmc> Numbers?
11:22:41 <mroman> Yes.
11:22:50 <kmc> what is a Number?
11:22:51 <Goosey> kmc: A thanks
11:22:55 <Goosey> Ah*
11:22:55 <mroman> data Baz  = Foo | Bar
11:23:02 <mroman> instance Num Baz where --....
11:23:05 <mroman> 1 :: Baz
11:23:19 <kmc> mroman, in that instance you wrote a definition for fromInteger
11:23:52 <kmc> numeric literals are sugar for an Integer literal and a call to fromInteger
11:24:10 <mroman> Ok.
11:24:11 <mroman> Thanks.
11:24:19 <kmc> (or if you use a decimal point, a Rational integer and a call to fromRational)
11:24:23 <kmc> :t 3.0
11:24:24 <lambdabot> forall t. (Fractional t) => t
11:24:30 <kmc> :t fromRational (3.0 :: Rational)
11:24:31 <lambdabot> forall a. (Fractional a) => a
11:27:45 <periodic> kmc: oh, thanks.
11:28:32 <periodic> Sadly, I must do some "real work" today.
11:28:42 <periodic> PHP memory leak, here I come!
11:29:19 <taesoo> what is ((->) e) fuctor , as mentioned in Typeclassopedia, and how to use it?
11:29:33 <periodic> It's a reader type, i believe.
11:29:45 <periodic> (->) e is a fancy way of writing a partially applied function.
11:29:52 <periodic> not that fancy, it's a fancy type.
11:29:58 <kmc> (((->) e) a)  ≡   (e -> a)
11:30:08 <periodic> normally -> is infix, but in this case it's represented as prefix.  Just like you can do with + or ==
11:30:09 <taesoo> they said that is reader type, but I don't know how to invoke it in ghci? how to play with?
11:30:19 <periodic> It's a type, so you don't really invoke it.
11:30:23 <wereHamster> is there a convention into which directory I shold put files which are compiled into binaries?
11:30:32 <kmc> you just use fmap at this type:
11:30:33 <kmc> fmap :: (a -> b) -> ((e -> a) -> (e -> b))
11:30:34 <periodic> but it's basically a class of functions that take an extra argument.
11:30:43 <c_wraith> > fmap (+5) (*4) 7
11:30:44 <lambdabot>   33
11:31:26 <parcs`> taesoo: import Control.Monad.Instances and apply fmap to functions
11:31:47 <cheater> hello
11:31:55 <taesoo> oh I see, (*4) :: Int -> Int
11:32:37 <parcs`> hi cheater
11:33:10 <cheater> hello parx
11:37:39 <eyebloom> How can I make a type that includes two subtypes: as in for example I want to refer to a list of tuples of type (a, b), as a list of type c rather than carry around variables a and b  in every type definition.
11:37:59 <kmc> type Foo = (Int, Char)
11:38:03 <kmc> that's just a synonym
11:39:30 <eyebloom> What if I want Int and Char to remain variables. As in type variable c is equivalent to a and b together.
11:39:59 <kmc> how do you specify a and b then?
11:40:05 <kmc> it sounds like you want type variables without having type variables
11:40:11 <Saizan> foo :: (c ~ (a,b)) => [c] -> ..
11:40:33 <wereHamster> why do I get tons of warnings about text reloc?
11:40:34 <eyebloom> Well, I just want a and b to be tied together in c
11:40:34 <Saizan> with {-# LANGUAGE TypeFamilies #-}
11:40:57 <eyebloom> I define c at some early point, and a and b are contained within it.
11:41:26 <taesoo> got it. the type, (->):: e -> a, doesn't have a constructor and as an instance of functor typeclass, the (->) behaves like "fmap (+1) (*3) :: Num b => b -> b" and "fmap (+1) (*3) 2 = 7".
11:41:42 <kmc> eyebloom, it doesn't make sense
11:42:11 <eyebloom> One moment I'll try to create a decent example
11:42:24 <copumpkin> omnomnom
11:42:29 <taesoo> am I correct? or still confused? ha
11:43:10 <kmc> taesoo, this part does not make sense: "the type, (->):: e -> a"
11:43:57 <eyebloom> mapTuple :: ((a,b)->(c, d)) -> [(a, b)] -> [(c, d)]
11:43:57 <eyebloom> mapTuple :: (x->y) -> [x] -> [y]
11:44:30 <kmc> maybe your function actually generalizes to the second type
11:44:34 <kmc> maybe your function is just 'map'
11:44:39 <eyebloom> basically since a and b are always together and c and d are always together I'd like to refer to them as x and y instead
11:44:46 <kmc> but anyway, you can use the GHC extension Saizan mentioned
11:45:02 <kmc> mapTuple :: (x ~ (a,b), y ~ (c,d)) => (x->y) -> [x] -> [y]
11:45:23 <eyebloom> Ok I'll look into type families
11:45:24 <kmc> i think most people would find this weird and obfuscated
11:45:33 <kmc> the type families feature isn't really relevant
11:45:43 <kmc> it enables this (a ~ b) constraint for other purposes
11:45:56 <eyebloom> I mean when you look at my actual code you'll understand.
11:46:31 <rwbarton> without other extensions, none of x,y,a,b,c,d are in scope in the body of the function anyways
11:46:40 <parcs`> eyebloom: what does mapTuple do?
11:46:48 <kmc> eyebloom, maybe, maybe i will still consider it weird and obfuscated
11:46:58 <hpaste> eyebloom pasted “eyebloom” at http://hpaste.org/55623
11:47:32 <eyebloom> MapTuple is just a toy example
11:47:42 <kmc> maybe you should write some of these on more than one line
11:48:06 <kmc> also do you really want a 3-tuple for State, or do you want to define a new type
11:49:09 <eyebloom> Right, those are all decent criticisms of the code... but the main one is I have a b and a' b' everywhere and it would be alot more readable if I could keep them together.
11:49:49 <kmc> if you give more context about what you're doing, we can suggest a different design
11:50:32 <eyebloom> Basically I'm defining some very general graph exploration algorithms.
11:50:43 <Saizan> you could define a datatype with kind * -> * -> * to use as a type tuple and define type families Fst and Snd to project the fields out
11:51:25 <eyebloom> They use node labels of type a and edge labels of type b.
11:51:27 <Saizan> and define uncurried versions of most of the types involved
11:52:10 <eyebloom> In many cases you need multiple graph types, one for the source graph and one for the accumulated graph.
11:52:41 <eyebloom> But the label types are always paired for a specific type of graph.
11:53:19 <kmc> ok, then maybe you should read about type families after all
11:53:28 <Saizan> another option is to paramterize over the complete graph type, and have type families to project edge and node labels from there
11:53:38 <kmc> class Graph g where { type Node g; type Edge g; ... }
11:54:00 <kmc> type Morph g h c = g -> [Node] -> h -> g -> c
11:54:00 <Saizan> eyebloom: are you using fgl?
11:54:17 <eyebloom> Yes
11:54:36 <eyebloom> Data.Graph.Inductive.Graph
11:54:49 <kmc> (er, that name Node clashes with the one i defined)
11:54:50 <Saizan> so you don't want to define your own class, but you can still use type families like kmc showed
11:55:26 <cheater> hello
11:55:32 <cheater> is there a visual version of haskell ?
11:55:39 <kmc> eyebloom, in many cases you're not using 'a' and 'b' independently
11:55:42 <Saizan> maybe also a type family Gr g :: * -> * -> *; type instance Gr (gr a b) = gr
11:55:53 <kmc> that's a weird instance
11:56:18 <kmc> eyebloom, i don't think you need to require that all graphs are 2-ary type constructors
11:56:21 <kmc> as the code you pasted does
11:56:27 <eyebloom> So far they are never seperated.
11:56:27 <cheater> as in, a graphical programming interface of some sort
11:56:41 <kmc> since they are never separated you do not need to pass them separately
11:56:43 <kmc> i.e.
11:56:45 <kmc> type Morph g h c = g -> [Node] -> h -> g -> c
11:57:02 <kmc> Morph (FooGraph Int Char) (BarGraph String Bool) ()
11:57:54 <eyebloom> I think once I start calling fgl functions I need them seperate.
11:57:58 <eyebloom> Not sure
12:00:06 <eyebloom> for example the function  match :: Node -> gr a b -> Decomp gr a b
12:00:48 <eyebloom> (Decomp is (Maybe Context ab, g a b)
12:01:49 <eyebloom> If my calling function has parameter of type "h" how can I pass it a type "a b"
12:02:11 <eyebloom> In other words how can an "h" turn back into an "a b".
12:02:17 <rwbarton> "a b" isn't a thing
12:02:22 <rwbarton> it's (g a) b
12:02:27 <rwbarton> (gr a) b
12:02:59 <eyebloom> sorry I would need (gr h) -> (gr a b)
12:03:22 <hpc> that's a kind error
12:03:24 <kmc> eyebloom, i think what you want is some type synonym families
12:03:29 <hpc> i think
12:03:48 <eyebloom> kmc: ok thank you, I'll read up on those.
12:03:52 <rwbarton> you can write something like Uncurry gr h where h = Pair a b and Uncurry gr (Pair a b) = gr a b
12:03:53 <kmc> type family NodeTy g;  type family EdgeTy g
12:04:07 <kmc> instance NodeTy (FooGraph a b) = a
12:04:16 <kmc> instance EdgeTy (FooGraph a b) = b
12:04:49 <kmc> (err, "type instance ...")
12:11:35 <dino-> @paste
12:11:35 <lambdabot> Haskell pastebin: http://hpaste.org/
12:12:41 <hpaste> dino- pasted “hslogger formatter problem” at http://hpaste.org/55624
12:13:04 <dino-> Ok so I made this simple example with code pasted almost directly from System.Log.Logger docs
12:13:12 <dino-> And the noticeM call there, never outputs anything at all.
12:13:36 <dino-> Doesn't matter if I use a streamHandler or a fileHandler there.
12:13:38 <dino-> Any idea what I
12:13:41 <dino-> I'm doing wrong?
12:17:18 <Saizan> maybe you need an higher verbosity level=
12:17:19 <Saizan> ?
12:17:31 <dino-> It's set to DEBUG, should show everything
12:17:45 <dino-> h <- streamHandler stdout DEBUG >>= \lh -> return $
12:18:02 <Saizan> ah, missed that
12:18:08 <dino-> Or do I have it backwards?
12:18:36 <wereHamster> what's the command to ask the bot to simplify an expression?
12:18:36 <dino-> I also tried NoBuffering on stdout
12:19:07 <Saizan>  @pl ? fsvo simplify
12:19:41 <wereHamster> isn't f = [f] same as (:) ? It basically makes a list from the argument, right?
12:20:06 <sipa> (:[]) you mean?
12:20:07 <Saizan> f = [f] is a type error
12:20:13 <wereHamster> set f = [f]
12:20:24 <kmc> :t (:)
12:20:25 <lambdabot> forall a. a -> [a] -> [a]
12:20:26 <sipa> @pl f x = [x]
12:20:26 <lambdabot> f = return
12:20:28 <alistra> Saizan: not if you have infinite types!
12:20:38 <Saizan> it's (:[])
12:20:42 <kmc> :t let f = In [f] in f
12:20:43 <lambdabot> Mu []
12:20:44 <alistra> fix []
12:20:45 <wereHamster> sipa: thanks, that's it
12:20:48 <cheater> @unpl (:)
12:20:48 <lambdabot> (:)
12:20:51 <cheater> hm.
12:20:53 <Saizan> alistra: which we don't have, so it's a type error
12:20:57 <sipa> @unpl (:[])
12:20:57 <lambdabot> (\ a -> a : [])
12:21:43 <alistra> :k []
12:21:44 <lambdabot> * -> *
12:22:07 <alistra> :k [[]]
12:22:08 <lambdabot>     `[]' is not applied to enough type arguments
12:22:08 <lambdabot>     Expected kind `*', but `[]' has kind `* -> *'
12:22:08 <lambdabot>     In the type `[[]]'
12:22:22 <alistra> :k [] []
12:22:22 <dino-> Can somebody else with hslogger installed try that script on the paste?
12:22:23 <lambdabot>     `[]' is not applied to enough type arguments
12:22:23 <lambdabot>     The first argument of `[]' should have kind `*',
12:22:23 <lambdabot>     but `[]' has kind `* -> *'
12:22:31 <kmc> :k [] ([] ())
12:22:32 <lambdabot> *
12:22:34 <dino-> Wonder if it's my system or all systems.
12:22:35 <cheater> @pl (\a -> \b -> [a] ++ b)
12:22:35 <lambdabot> (:)
12:22:40 <cheater> haha that one is good
12:23:02 <kmc> > [[()]] :: [] ([] ())
12:23:03 <lambdabot>   [[()]]
12:23:14 <kmc> > (() : []) : [] :: [] ([] ())
12:23:15 <lambdabot>   [[()]]
12:23:18 <dino-> 15:45 < hpaste> dino- pasted “hslogger formatter problem” at http://hpaste.org/55624
12:23:56 * hackagebot uu-parsinglib 2.7.3.2 - Fast, online, error-correcting, monadic, applicative, merging, permuting, idiomatic parser combinators.  http://hackage.haskell.org/package/uu-parsinglib-2.7.3.2 (DoaitseSwierstra)
12:24:55 <alistra> Fast, online, error-correcting, monadic, applicative, merging, permuting, idiomatic, cheap, buy now, limited offer, in your local store parser
12:24:59 <cheater> > () : []
12:25:00 <lambdabot>   [()]
12:25:13 <cheater> interesting, i didn't know you could do that
12:25:33 <cheater> (() : []) : []
12:25:36 <cheater> > (() : []) : []
12:25:37 <lambdabot>   [[()]]
12:25:48 <cheater> so
12:25:57 <cheater> : [] is just "wrap with brackets"?
12:26:29 <alistra> > 4 :  5 : 2 : []
12:26:30 <lambdabot>   [4,5,2]
12:26:48 <cheater> () : [] : []
12:26:51 <periodic> cheater: really the list type could be thought of as "List a = a : List a | []"
12:26:51 <cheater> > () : [] : []
12:26:52 <lambdabot>   Couldn't match expected type `()' against inferred type `[a]'
12:26:56 <periodic> basically, they are just constructors.
12:27:03 <cheater> periodic: no idea what you mean
12:27:11 <periodic> you could just as easily do it with "List a = Cons a (List a) | Nil"
12:27:33 <periodic> So then you'd do "Cons () Nil" to do the same thing as "() : []"
12:27:42 <periodic> the tricky thing is that (:) is an infix constructor.
12:27:51 <periodic> And that the system has a special syntax for lists.
12:27:55 <periodic> which is really just a shortcut.
12:28:14 <periodic> I could write "() `cons` Nil"
12:28:24 <periodic> by using the backticks to transform it to an infix function.
12:28:31 <periodic> oops, "() `Cons` Nil"
12:28:32 <cheater> that's really cool, thx.
12:28:51 <periodic> Lists aren't really anything magical in the system.  They do get a special syntax.
12:29:00 <taesoo> could you give a hint on this question "Give an example of a type of kind * -> * which cannot be made an instance of Functor (without using undefined)"?
12:29:01 <cheater> not anymore
12:29:06 <periodic> But they aren't a primitive type the way an Int or Float.
12:29:26 <periodic> taesoo: Functors have to obey certain rules, right?
12:29:55 <taesoo> periodic: yes right
12:31:58 <taesoo> periodic: as far as a type f obeys this (a -> b) -> f a -> f b, it's a functor
12:32:54 <c_wraith> well.  that's sufficient to allow it to be an instance of Functor.  But being a proper instance of Functor involves some rules about that transformation.
12:33:30 <kmc> Fast, online, error-correcting, monadic, applicative, merging, permuting, idiomatic, second-generation, outside–in, pull-based, multiple-stakeholder, multiple-scale, high-automation, agile methodology
12:34:07 <c_wraith> the first 7 of those might be applied to parser libraries
12:34:17 <c_wraith> ...  in a meaningful way, that is
12:34:57 <kmc> taesoo, i can give you an example of such a type and you can think of why you couldn't write fmap for it
12:35:53 <cheater> kmc: you forgot webscale
12:36:03 <dino-> Saizan: Thanks for trying to help
12:36:09 <hpaste> spuz pasted “Bind” at http://hpaste.org/55625
12:36:13 <cheater> oh you have multiple-scile craa
12:36:23 <dino-> I'll hit the Joel Overflow with it next, maybe somebody there has exp with hslogger.
12:36:44 <taesoo> kmc: sure I am happy to think about.
12:36:50 <spuz> Hi, how can I replace the do return with a >>= in this function? http://hpaste.org/55625
12:37:47 <monochrom> many1 digits >>= \digits -> return (Number (read digits))
12:38:18 <monochrom> (Number . read) `liftM` many1 digit
12:38:19 <byorgey> spuz: you can always replace   x <- foo; blah  with  foo >>= \x -> blah
12:38:36 <monochrom> you can replace `liftM` by `fmap` or <$>
12:38:37 <spuz> byorgey: thanks
12:38:41 <spuz> and monochrom
12:39:07 <mlb-> hmm, is there a way to tell when I've passed a byte offset while traversing a file?
12:39:12 <spuz> I'm trying to do the exercises in the Write yourself a Scheme tutorial at the moment
12:39:21 <spuz> so still a lot to learn
12:39:37 <mlb-> or would I be better off trying to take a specific sized chunk and operate on that?
12:40:20 <parcs`> > let node = Node in node { rootLabel = () }
12:40:20 <lambdabot>   Couldn't match expected type `Data.Tree.Tree a'
12:40:21 <lambdabot>         against inferred ty...
12:41:16 <taesoo> kmc: given ny function geting one arg (or curried to get one arg), we can apply fmap with proper f on it
12:42:56 <kmc> taesoo, data Foo a = Foo (a -> Int)
12:43:07 <kmc> can you write fmap :: (a -> b) -> (Foo a -> Foo b)
12:44:05 <kmc> satisfying the laws  fmap id ≡ id  and  fmap (f . g) ≡ (fmap f . fmap g)
12:44:08 <track7> anyone know where the flash channel is?
12:45:00 <track7> where people would know about flash maps that pull info and display them from db and xml files?
12:47:04 <hpaste> mizu_no_oto pasted “CmdArgs problem” at http://hpaste.org/55626
12:48:53 <mizu_no_oto> So can anyone tell me why that simple cmdargs test isn't working?
12:49:56 <Enigmagic> mizu_no_oto: remove the 'opt True' flag?
12:50:59 <mizu_no_oto> in that case, test: System.Console.CmdArgs.Implicit, unexpected flag (args/argPos): Flag_ {flagField = "bar", flagFlag =      Random String.
12:51:01 <mizu_no_oto> , flagExplicit = False, flagGroup = Nothing, flagEnum = Nothing}
12:51:17 <mizu_no_oto> So it fails, but just in a different way
12:51:21 <byorgey> mizu_no_oto: what version of cmdargs?
12:53:12 <dino-> Ah, I see you have to set the priority on both the logger and the handler(s)
12:53:13 <dino-> bleh
12:53:21 <dino-> I think this has probably bitten me at least once before.
12:53:31 <dino-> I go away from hslogger for a year and then have to relearn what's what.
12:54:15 <mizu_no_oto> * cmdargs ...  Installed versions: 0.9
12:55:32 <taesoo> kmc: thanks! then why instance Functor Foo where fmap f (Foo g) = Foo (f . g)
12:55:45 <taesoo> kmc: doesn't obey the law?
12:56:10 <kmc> it's a type error
12:56:34 <taesoo> kmc: data Foo a = Foo (Int -> a)?
12:56:44 <kmc> data Foo a = Foo (a -> Int)
12:56:47 <byorgey> mizu_no_oto: hmm, I don't know then
12:56:56 <byorgey> mizu_no_oto: but it seems a bit weird to be using 'opt' for a boolean flag
12:56:59 <kmc> the other way is fine
12:57:05 <kmc> ((->) Int) is already a Functor in the standard libraries
12:57:55 <mizu_no_oto> byorgey: how should I do it?  Isn't opt there so the user has a default value if the flag is present but an explicit value isn't provided?
13:00:10 <Enigmagic> mizu_no_oto: so it looks like you need to remove the help string from the argPos args..
13:00:13 <byorgey> mizu_no_oto: it seems that for Boolean flags you can't give an explicit value anyway
13:00:38 <mizu_no_oto> byorgey:  I guess that makes sense
13:00:38 <byorgey> mizu_no_oto: if the user doesn't provide the flag, it will be False; if they do specify -f it will be True, *without* needing opt
13:02:23 <acowley> Even if I finish this blog post, I'd like to depend on various unreleased versions of things. "Just paste this literate haskell into your editor...and use git to download this, and then use darcs to get the latest version of that...." So easy!
13:03:12 <byorgey> acowley: just provide a script. "In order to read this blog post, first run this script.  Trust me."
13:03:20 <acowley> haha
13:03:28 <acowley> I should have people sign a waiver first
13:03:39 <srhb> Make this script sign the waiver for them.
13:03:51 <acowley> how convenient
13:03:55 <srhb> "Thank you, you've given up your rights. Good luck"
13:04:05 <acowley> "I wouldn't have done that if I were you."
13:04:12 <srhb> :-)
13:04:22 <acowley> It's annoying because I think this is a really kickass demo.
13:04:39 <mizu_no_oto> Enigmagic:  That worked.  Why can't you combine help and argsPos in the same variable?
13:05:06 <taesoo> kmc: yea! I think I finally get it. omg thank you so much
13:05:11 <Enigmagic> mizu_no_oto: *shrug* probably the help generator doesn't provide anything besides the typ in the help output
13:05:52 <mizu_no_oto> It would also be nice if it were documented in either argsPos or help that they don't work together at all...
13:06:13 <Enigmagic> mizu_no_oto: send a patch
13:06:34 <mizu_no_oto> good idea
13:21:26 <track7> trying to make a flash map that can be drilled down into pulling data from a db, http://c.ui.ly/bit/map
13:22:24 <Patrek> In contrast to Eq class, is there anyway to check if the actual values of two "variables" are the same? some kind of binary equality
13:22:56 <c_wraith> Patrek: that question isn't clear at all.  What is it you actually want to check?
13:22:57 <Axman6> Patrek: that doesn't really make sense though. you'd end up with 55 /= sum [1..10]
13:23:54 <Patrek> Axman6 ,what if we force evaluation (seq) ?
13:23:58 <drull95> dunno why i didn't think of it before but i just searched for "c++ working draft" and got what i wanted
13:24:11 <Axman6> then you're doing exactly what the Eq class does...
13:24:21 <drull95> better than staring at someone's  confusing implementation of c++ parser
13:24:31 <Patrek> but Eq class can be implemented in an arbitrary way
13:24:34 <Axman6> drull95: were you looking for the C++ working draft?
13:24:42 <Axman6> Patrek: so?
13:24:47 <hpaste> “parse error” pasted “daavidb” at http://hpaste.org/55627
13:25:00 <drull95> i'm writing a c++ parser to make a c++ binding tool
13:25:12 <drull95> later on i want to add support for c++ calling conventions to ghc
13:25:18 <daavidb> I officialy hate haskell indentation. What's wrong with this? http://hpaste.org/55627 Why do I get a parse error?
13:25:24 <Axman6> o.O... good luck is all i can say
13:25:39 <drull95> so i was looking for a readable grammar to make implementation move along faster
13:25:42 <Axman6> drull95: tabs?
13:25:55 <Axman6> nope
13:26:01 <Axman6> also that was meant for daavidb
13:26:14 <daavidb> they have to be tabs, not spaces?
13:26:26 <Axman6> no, never use tabs
13:26:36 <Axman6> seems that's not the problem. please paste the actual error
13:26:46 <Axman6> me needle in haystack finding tool is broken
13:26:55 <Patrek> so, for a user defined record with a user defined Eq some code reasoning fails,ex: data Person = Person{id::Int, age::Int,name::String}  \n  instance Eq person where p1 == p2 = (id p1) == (id p2)
13:26:57 <daavidb> graphdist.hs:27:16: parse error (possibly incorrect indentation)
13:27:02 <Axman6> oh, you're missing a bracket on line 8
13:27:45 <Axman6> shoule be (\x -> (not x `isin` neighbours))
13:28:07 <daavidb> ah. silly me.
13:28:20 <daavidb> thanks
13:28:23 <Axman6> yeah, blaming haskell's lovely indentation. tut tut tut
13:43:34 <wereHamster> is there a way to make cabal install all dependencies?
13:44:01 <Axman6> that's the default behaviour
13:44:06 <Patrek> I have a class with a method, I want to write the default implementation of it in generic way , what's the best solution?
13:44:16 <kmc> drull95, writing a C++ parser is an insanely difficult task.
13:44:31 <kmc> it's one of the hardest languages to parse, if not the hardest
13:45:09 <Axman6> it cannot be parsed in a single pass i believe (i remember the D language guy talking about how you need to look at every character a minimum of two times or something)
13:45:14 <kmc> drull95, maybe you should use http://hackage.haskell.org/package/LibClang
13:45:24 <russellw> The hardest, definitely. Any chance you could get clang to do the parsing for you, and read LLVM format?
13:45:26 <Axman6> ooo, we have clang bindings? :O
13:45:44 <kmc> writing your own parser might be reasonable if you're sticking to some subset of the language
13:46:21 <Sgeo_> kmc, what about Perl?
13:47:01 <Axman6> perl can't be statically parsed at all, without some knowledge of the context of the operators i think
13:47:50 <kmc> http://www.jeffreykegler.com/Home/perl-and-undecidability
13:47:51 <Cale> Perl can't in general be parsed without executing Perl as well.
13:48:32 <Eduard_Munteanu> That sounds a bit terrible in some ways.
13:48:52 <kmc> what an oddly equivocal statement
13:48:58 <Cale> haha
13:49:21 <monochrom> @nixon
13:49:22 <lambdabot> Certainly in the next 50 years we shall see a woman president, perhaps sooner than you think. A woman can and should be able to do any political job that a man can do.
13:49:25 <Cale> It's fucking awful. It means that you can't write tools that operate on perl code which can be shown to work in general.
13:50:14 <Eduard_Munteanu> Well, I usually don't dismiss weird things like that, but it seems to me you can't even do any sort of static analysis or check the code is safe to run without running it in the first place.
13:50:35 <alistra> well you can write a c++ program that hangs the compiler
13:50:37 <Cale> Right, you can't.
13:50:42 <kmc> static analysis is hard whether or not parsing is hard
13:50:57 <kmc> parsing is just this extra, annoying obstacle to static analysis
13:51:51 <drdo> alistra: Lots of languages are like that, it's not a big deal
13:51:53 * Eduard_Munteanu thinks undecidable typechecking is way less controversial
13:52:34 <alistra> well you can't run a program that you can't parse
13:52:42 <Cale> alistra: Even without extensions, typechecking is exponential space complexity.
13:52:43 <alistra> you can run a not typed program
13:52:48 <Cale> (in Haskell)
13:52:55 <alistra> yeah i remember the
13:52:58 <alistra> id id id id
13:53:02 <Cale> also:
13:53:07 <dylukes> Cale: kudos for avoiding the O(leg) slowdown.
13:53:43 <Cale> :t let f x = (x,x); f1 = f (f x); f2 = f1 (f1 x) in f2
13:53:43 <lambdabot>     Couldn't match expected type `Expr -> t'
13:53:44 <lambdabot>            against inferred type `((Expr, Expr), (Expr, Expr))'
13:53:44 <lambdabot>     In the first argument of `f1', namely `(f1 x)'
13:53:50 <Cale> derp
13:53:57 <Cale> :t let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x) in f2
13:53:58 <lambdabot> forall t. t -> ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))
13:54:14 <dylukes> >_>
13:54:17 <dylukes> why.
13:54:37 <Cale> a few more iterations, and that starts taking a fair amount of space to typecheck ;)
13:54:40 <Eduard_Munteanu> But that's practically the downfall of any language which relies on metaprogramming such as evaluating runtime-generated code etc., no?
13:55:02 <kmc> Patrek, I guess we ignored your question because it's very general and unclear.  can you be more specific?
13:55:22 <aristid> :t (,)(,)
13:55:23 <lambdabot> forall a b b1. b1 -> (a -> b -> (a, b), b1)
13:55:28 <aristid> :t (,).(,)
13:55:28 <lambdabot> forall b a b1. a -> b -> (b1 -> (a, b1), b)
13:55:36 <kmc> :t let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x); f3 x = f2 (f2 x) in f3
13:55:36 <lambdabot> forall t. t -> ((((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((
13:55:37 <lambdabot> t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((
13:55:37 <lambdabot> t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((
13:55:37 <lambdabot> t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))))), (((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), (
13:55:37 <lambdabot> (t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t), (t, t))
13:55:38 <lambdabot> , ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), (
13:55:40 <lambdabot> (t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))))))
13:55:42 <kmc> oh jesus
13:55:42 <Eduard_Munteanu> Whee
13:55:45 <kmc> sorry everyone
13:55:50 <Axman6> you're a monster!
13:55:50 <Cale> lol, it's okay
13:55:51 <aristid> > join(,).join(,)
13:55:52 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> ((a, a), (a, a)))
13:55:52 <lambdabot>    arising ...
13:55:57 <aristid> :t> join(,).join(,)
13:56:02 <aristid> :t join(,).join(,)
13:56:03 <lambdabot> forall a. a -> ((a, a), (a, a))
13:56:05 <Cale> Though... that's interesting. I was pretty sure it cut the output to a few lines
13:56:13 <dylukes> :t let f x = (x,x); f1 x = f (f x); in f1 . f1 . f1 . f1 . f1
13:56:14 <lambdabot> forall t. t -> ((((((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)),
13:56:14 <lambdabot> ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), (
13:56:14 <lambdabot> (t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((
13:56:14 <lambdabot> t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))))), (((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), (
13:56:14 <lambdabot> (t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t), (t, t))
13:56:16 <lambdabot> [21 @more lines]
13:56:16 <shachaf> Cale: I think that's the maximum.
13:56:16 <aristid> :t join(,).join(,).join(,)
13:56:18 <lambdabot> forall a. a -> (((a, a), (a, a)), ((a, a), (a, a)))
13:56:21 <dylukes> I think might is nicer Cale.
13:56:23 <dylukes> mine*
13:56:29 <aristid> :t join(,).join(,).join(,).join(,)
13:56:30 <lambdabot> forall a. a -> ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))
13:56:40 <dylukes> :t let f x = (x,x); f1 x = f (f x); in f1.f1.f1.f1.f1.f1.f1.f1.f1.f1.f1.f1.f1.f1
13:56:44 <dylukes> mueval
13:56:44 <shachaf> dylukes: Well, that's not exponential.
13:56:46 <dylukes> limit exceeded
13:56:47 <dylukes> >_
13:56:48 <dylukes> .
13:56:51 <Eduard_Munteanu> Heh.
13:56:55 <lambdabot> thread killed
13:57:03 <dylukes> mauke/Cale stop it.
13:57:06 <dylukes> π_π
13:57:07 <Cale> what?
13:57:11 <shachaf> People should probably take further botspam to #haskell-overflow.
13:57:31 <dylukes> @nixon ping?
13:57:32 <lambdabot> I played by the rules of politics as I found them.
13:57:35 <Axman6> s/#haskell-overflow/ghci
13:57:40 <Cale> But botspam is the best *kind* of spam!
13:57:46 <dylukes> :D
13:57:49 <dylukes> @botspam
13:57:49 <lambdabot> Unknown command, try @list
13:58:00 <dylukes> @dickballs
13:58:00 <lambdabot> Unknown command, try @list
13:58:06 <shachaf> Cale: Even better than zergling spam?
13:58:09 <dylukes> Was @dickballs ever a real command? Or was that an urban myth?
13:58:16 <shachaf> Cale: (That's the only Starcraft unit I know.)
13:58:31 <dylukes> I think at one point lambdabot's fuzzy matching made @dickballs work for something.
13:58:37 <Cale> drone spam > zergling spam
13:58:46 <dylukes> zealot rush?
13:58:55 <shachaf> This all sounds like #-blah material.
13:59:10 <Cale> I have too many channels to deal with already
13:59:12 <ClaudiusMaximus> @hoogle moebius
13:59:12 <lambdabot> No results found
13:59:19 <kmc> i wanted to talk to Cale about lambdabot in #haskell-blah anyway
13:59:31 <Cale> as long as there's no real discussion going on here, it probably doesn't matter :P
13:59:45 <shachaf> Cale: I have 108 windows in irssi. :-(
13:59:59 <ClaudiusMaximus> am i the only one using moebius transformations (the (az+b)/(cz+d) kind) for anything?
14:00:02 <Cale> kmc: I saw your comments, are you really going to make me waste more of my time recompiling lambdabot?
14:00:03 <dylukes>  /j #haskell-brah
14:00:14 <Eduard_Munteanu> shachaf: how so? I almost never have more than 10-12
14:00:32 <Cale> (if it's about the @nixon thing :P)
14:00:32 <kmc> Cale, I can't "make" you do anything.
14:02:12 <kmc> i don't want to push the issue again because it got pretty ugly last time
14:02:16 <ClaudiusMaximus> @check (<3)
14:02:17 <lambdabot>   Not in scope: `myquickcheck'Not in scope: `<'Not in scope: `$'
14:02:20 <kmc> you've read my comments
14:02:31 <kmc> now people can stop telling me "i'm sure if you complained something would be done"
14:02:33 <Cale> I will remove @nixon if people bug me enough to do it. The stuff he says is indeed more offensive than anything that @vixen could produce, but then, it comes with the historical context that he actually said those things. You needn't be offended at the bot, you should be offended at your country for ever having elected such a person.
14:02:44 <kmc> Cale, oh, trust me, I am
14:02:44 <Cale> (provided that you live in the US :)
14:03:26 <kmc> i don't see the relevance though
14:04:00 <Cale> Honestly, if I have to spend lots of time maintaining lambdabot, I'd rather just rewrite it into something that just does :t and >
14:04:02 <Cale> :P
14:04:20 <Cale> Oh, and maybe @pl and @free
14:04:35 <kmc> if we're removing offensive off-topic quotes because they make the channel less pleasant or less inclusive, then the historical context doesn't matter
14:04:36 <Cale> the haskell-related modules
14:05:08 <Cale> I don't really care either way on any of this.
14:05:11 <kmc> anyway i can't make you do anything, the only "threat" i can provide is that if you don't reinstate @vixen or remove @nixon, i will feel a little less warm & fuzzy about the haskell community
14:05:23 <kmc> there's little reason to care about that
14:05:29 <Cale> I only removed @vixen because people complained to me about it
14:05:44 <kmc> and now i'm complaining to you
14:06:34 <Cale> Wait, I don't understand your options. Shouldn't you be picking one of those two?
14:06:50 <kmc> no, I don't care
14:06:51 <yitz> Cale: if someone goes through vixen's data and changes into just clever bot responses without the offensive personna, would you be willing to reinstate it (perhaps with a different command name)?
14:06:51 <alistra> @vixen
14:06:51 <lambdabot> Any lady who is first lady likes being first lady. I don't care what they say, they like it.
14:07:01 <Cale> kmc: what, then why complain about it?
14:07:09 <kmc> what offends me is the double standard that female masturbation is more offensive than racism, anti-semitism, and homophobia
14:07:18 <kmc> (not to mention political fraud on a massive scale)
14:07:32 <alistra> Cale: will you reinstate it if we'll complain about it?
14:07:42 <Cale> I don't think it was "female masturbation is offensive"
14:07:55 <EvanR-work> kmc: arent those backwards?
14:08:06 <Eduard_Munteanu> I think byorgey complained about it, but I'm unsure what the exact quote was.
14:08:06 <Cale> It was "this stereotype of a female is offensive"
14:08:16 <alistra> Cale: is this like a thing where you count how many people complain on each option?
14:08:25 <kmc> vixen is a stereotype of a woman?
14:09:32 <Axman6> @vixen asl
14:09:32 <lambdabot> When the President does it, that means that it is not illegal.
14:09:41 <Axman6> bleh
14:09:52 <kmc> anyway i hope you understand my position
14:10:10 <kmc> and i hope people will stop telling me "i'm sure if you complain then it will be dealt with promptly because we're all so warm and fuzzy and inclusive and welcoming"
14:10:19 <yitz> kmc: the content varied gradually over time. there were periods where some of the vixen content was pretty clearly offensive. however, that particular content wasn't the point of vixen, and my opinion is that summarily disabling the plugin entirely was very wrong.
14:10:57 <alistra> @vote
14:10:58 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
14:12:12 <Eduard_Munteanu> Maybe the bad parts of vixen could somehow be downvoted, but I'm unsure if anybody wants to take that work on (a plugin or something that does that).
14:12:28 <MiggyX> I'm not sure whether it is a good or bad sign when you find yourself dreaming about parametric polymorphism....
14:12:37 <Eduard_Munteanu> (or simply rewriting vixen)
14:13:07 <Cale> Honestly, I don't see much point in lambdabot doing much more than actual Haskell-related stuff. :P
14:13:38 <alistra> @poll-add Are you confused with the whole vixen situation already?
14:13:39 <lambdabot> usage: @poll-add <poll>   with "ThisTopic" style names
14:14:09 <alistra> @poll-add ConfusedWithVixenSituation
14:14:09 <lambdabot> Added new poll: "ConfusedWithVixenSituation"
14:14:18 <alistra> @choice-add ConfusedWithVixenSituation yes
14:14:18 <lambdabot> New candidate "yes", added to poll "ConfusedWithVixenSituation".
14:14:20 <alistra> @choice-add ConfusedWithVixenSituation no
14:14:21 <lambdabot> New candidate "no", added to poll "ConfusedWithVixenSituation".
14:14:26 <sohum> can someone help me with http://hpaste.org/55599 ?
14:14:46 <alistra> @vote ConfusedWithVixenSituation yes
14:14:46 <lambdabot> voted on "yes"
14:15:32 <Axman6> @vote ConfusedWithVixenSituation dontcare
14:15:32 <lambdabot> "dontcare" is not currently a candidate in this poll
14:16:21 <Cale> sohum: I don't understand your question. "Fooable (mkFoo q)" doesn't make sense because mkFoo q is not a type
14:16:37 <yitz> sohum: what do you mean by "Fooable (mkFoo q) holds"? mkFoo q is not a type, so it can't be an instance of Fooable. What do you mean that it "holds"?
14:16:54 <erkin> Good night.
14:17:11 <alistra> @poll-list
14:17:11 <lambdabot> ["ConfusedWithVixenSituation","best-programming-language","food","naming","president","remove@src","sleep"]
14:17:32 <daavidb> If I write "a = [1,2,3]" is a of type [Integer] or of type [Int]?
14:17:33 <yitz> @help poll
14:17:33 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
14:17:39 <kmc> :t [1,2,3]
14:17:40 <lambdabot> forall t. (Num t) => [t]
14:17:42 <yitz> @help vote
14:17:42 <lambdabot> vote <poll> <choice>        Vote for <choice> in <poll>
14:17:49 <kmc> daavidb, numeric literals are overloaded to work for any type in the Num typeclass
14:17:52 <kmc> > [1,2,3] :: [Int]
14:17:53 <lambdabot>   [1,2,3]
14:17:54 <kmc> > [1,2,3] :: [Integer]
14:17:55 <lambdabot>   [1,2,3]
14:17:56 <sohum> Cale, yitz: that's a mostly confusing bit. keep reading, I think I explain it better in the MFooable example
14:17:58 <kmc> > [1,2,3] :: [Float]
14:17:59 <lambdabot>   [1.0,2.0,3.0]
14:18:02 <Cale> daavidb: It'll tend to be defaulted to Integer, if you leave the monomorphism restriction on.
14:18:07 <yitz> @poll-show ConfusedWithVixenSituation
14:18:07 <lambdabot> ["no","yes"]
14:18:20 <Cale> daavidb: but it depends on how you use a elsewhere
14:18:31 <yitz> @vote ConfusedWithVixenSituation yes
14:18:32 <lambdabot> voted on "yes"
14:18:38 <siracusa> @poll-result remove@src
14:18:38 <lambdabot> Poll results for remove@src (Closed): no=1, yes=1
14:18:40 <kmc> what's "confusing" about the "situation"
14:18:45 <Axman6> acowley: you about? this might be very interesting to our interests: http://www.yesodweb.com/blog/2011/12/resourcet
14:19:02 <Cale> How about a "tired of the @vixen situation" poll?
14:19:13 <Axman6> kmc: why anyone would be so offended by anything either of them say as to cause this much noise in the channel
14:19:14 <Cale> Honestly, I don't want to waste any more time on it :P
14:19:24 <yitz> kmc: i'm take "confused" as a polite way of saying "disagree"
14:19:32 <yitz> s/take/taking/
14:19:34 <alistra> i don't know what, who, why and why isn't it back
14:20:05 <kmc> yitz, it seems the opposite of polite to me.  telling someone you're "confused" about their position, without asking any clarifying questions, seems like a dick way of saying "your opinion does not matter" without saying it.
14:20:08 <alistra> yitz: how can you disagree with a situation
14:20:11 <alistra> it's a type error
14:20:18 <yitz> Cale: so then just put it back and most people will stop complaining
14:20:31 <yitz> hey it's not my poll i was just guessing what was meant
14:20:33 <Axman6> i'm all for removing all the most offensive quotes from both ixens, as long as people shut up about it
14:21:08 <Cale> yitz: Actually, I hate how large and complicated lambdabot is, and if I had to recompile it, I'd probably remove most of the modules which nobody really uses
14:21:09 <Eduard_Munteanu> I guess that needs to be taken care of upstream first.
14:21:27 <alistra> they're moaning about removing them, not keeping them
14:21:28 <Axman6> Cale: like polls? =)
14:21:31 <Cale> indeed
14:21:41 <Axman6> @a
14:21:41 <lambdabot> Maybe you meant: activity activity-full admin all-dicts arr ask . ? @ v
14:21:47 <Axman6> @activity
14:21:47 <lambdabot> 1*total 1*#haskell
14:21:51 <Axman6> o.O
14:21:56 <Axman6> @help activity
14:21:56 <lambdabot> activity seconds. Find out where/how much the bot is being used
14:22:03 <kmc> @yhjulwwiefzojcbxybbruweejw
14:22:03 <lambdabot> "\"#$%&'()*+,\""
14:22:07 <Cale> @activity 1000
14:22:07 <lambdabot> 36*total 23*#haskell 13*private
14:22:12 <Cale> @activity 10000
14:22:12 <lambdabot> 143*total 98*#haskell 43*private 1*#lesswrong 1*#haskell-blah
14:22:18 <yitz> Cale: that's true. there were some attempts at a redesign but no one ever actually finished afaik
14:22:35 <Eduard_Munteanu> Doesn't Cale
14:22:39 <Eduard_Munteanu> ... maintain lambdabot?
14:22:43 <Cale> NO
14:22:50 <kmc> just runs an instance
14:22:56 <Eduard_Munteanu> Not anymore, or was I misremembering completely?
14:23:02 <yitz> on someone else's VM
14:23:04 <Cale> I have never maintained lambdabot
14:23:08 <Eduard_Munteanu> Ah.
14:23:11 <kmc> at this point the thing which annoys me most is that everyone told me yesterday that this would be dealt with immediately, almost like it was silly that i even thought it was an issue
14:23:17 <Cale> Someone put my name in the Maintainer field in a .cabal file
14:23:27 <Cale> and since then, people have been sending me patches
14:23:29 <Eduard_Munteanu> Hm, I knew I remembered something like that.
14:23:31 <Eduard_Munteanu> Heh.
14:23:34 <acowley> Axman6: yes it might! I'm not sure how to integrate it though
14:23:36 <Axman6> poor Cale :(
14:23:42 <ion> :-D
14:23:58 <acowley> Axman6: Also, I'm on a newer laptop today and switching between GPU and CPU works perfectly
14:24:14 <Axman6> acowley: me either. i'd be interested if it could be made to work with retain/release on OpenCL too
14:24:20 <Axman6> excellent :)
14:24:28 <HaskellElephant> Cale: is your name still listed as the maintainer of lambdabot on hackage?
14:24:36 <acowley> Axman6: I've got the blog post in draft form, but I'm not sure what to do about the quasicrystal example that uses an as-yet-unreleased version of gloss
14:24:38 <Cale> HaskellElephant: I don't know, you could go check
14:24:45 <Eduard_Munteanu> @hackage lambdabot
14:24:45 <lambdabot> http://hackage.haskell.org/package/lambdabot
14:24:56 <Cale> apparently it is :P
14:25:18 <Eduard_Munteanu> See? How would I *not* send patches to you? :D
14:25:27 <Cale> Don Stewart is more of a maintainer of lambdabot than I am, lol.
14:25:27 <yitz> If someone's name can be put as maintainer and that person has no way of preventing it or removing themselves, that is a serious bug in hackage
14:25:31 <Axman6> acowley: talk about how you're using a soon to be released version of gloss, show a screen capture of the video running
14:25:38 <Cale> But really, send them to Gwern
14:25:39 <acowley> Axman6: It would indeed be nice if ResourceT could help with exceptions, but I'm not really sure how important it is. Every time I've gotten an exception, it was a pretty fatal bug
14:25:48 <Cale> I have no idea why he put my name there
14:25:56 <HaskellElephant> Cale: It seems that you are listed as the maintainer from version 4.2.1 to 4.2.3.2 ...
14:26:08 <Cale> (or, if he wasn't the one who put my name there, then whoever it was ...)
14:26:10 <Axman6> acowley: sure, but we need to make sure things allocated on the GPU are then released no?
14:26:12 <yitz> send lambdabot patches to mmorrow
14:26:24 <Cale> good plan
14:26:26 <Axman6> yitz: :(
14:26:31 <Eduard_Munteanu> Who wants to take on some of my projects? :P
14:26:33 <HaskellElephant> Cale: It was uploaded by GwernBranwen
14:26:40 <Cale> mmorrow will be right on it when he comes back ;)
14:26:47 <Cale> @seen mmorrow
14:26:47 <lambdabot> Unknown command, try @list
14:26:55 <Axman6> preflex: seen mmorrow
14:26:56 <Cale> oh right, removed that :)
14:27:08 <preflex>  mmorrow was last seen on #ghc 1 year, 338 days, 20 hours, 2 minutes and 58 seconds ago, saying: * mmorrow is rtfm'ing
14:27:08 <Axman6> :\
14:27:19 <Eduard_Munteanu> Didn't preflex answer to @seen as well?
14:27:23 <Cale> That's got to be one heck of a manual
14:27:23 * monochrom sends patches to lambdabot
14:27:38 <mauke> Eduard_Munteanu: I removed it due to complaints
14:27:40 <acowley> Axman6: Yes, but how difficult that is depends on the complexity of your program. If your usage of OpenCL is functional, then the retain/releases are already taken care of. If you want to load certain things into OpenCL and use them across multiple kernel invocations, then, as things stand, you get to do your own retain/releasing.
14:27:46 <monochrom> the manual is written in perl :)
14:27:47 <mauke> (that was a lie. I just removed it)
14:27:47 <Eduard_Munteanu> I see.
14:28:02 <Eduard_Munteanu> Maybe it's The Manual.
14:28:09 <Eduard_Munteanu> (a-la The Book)
14:28:31 <kmc> rostayob, ddarius: I asked Cale directly and it didn't work.  you can update your predictions accordingly
14:28:41 <HaskellElephant> Cale: I think if you are not realy the maintainer of lambdabot you could bring it up on the hackage mailing list or open a ticket on the hackage trac ...
14:28:43 <Axman6> acowley: hmm, true. but at least running everything in ResourceT means that you don't have to worry about releasing things (i think..)
14:29:00 * hackagebot alsa-pcm 0.5.0.1 - Binding to the ALSA Library API (PCM audio).  http://hackage.haskell.org/package/alsa-pcm-0.5.0.1 (HenningThielemann)
14:29:12 <Axman6> i mean, he shows explicit resource releasing there, but I wonder whether it's really necessary
14:29:28 <acowley> Axman6: it automatically releases when you exit the monad through runResource
14:29:46 <acowley> Axman6: but it's not clear when you'd do that if you were working with some mutable array in OpenCL across multiple kernel invocations.
14:29:48 <yitz> HaskellElephant, Cale: perhaps a better plan would be just to ask ross to remove Cale's name if he never agreed to be maintainer
14:30:21 <acowley> Axman6: Perhaps running a kernel loop in ResourceT is the answer there, actually.
14:30:29 <acowley> Axman6: I'll give it a shot next week.
14:30:46 * Sgeo_ just read about ResourceT yesterday
14:30:49 <Axman6> acowley: well, as you say, if an exception is thrown, it's probably a good sign you need to fix the code. so you want to make sure everything is released at that point
14:31:02 <HaskellElephant> yitz: but you need the hackage guys to fix it if his name is to be removed from all the versions right?
14:31:20 <acowley> Axman6: I've not had any catastrophic OS-level problelms when my OpenCL-using process bombs out
14:31:25 * Sgeo_ wonders if he'd be able to take over maintainence of safe-lazy-io
14:31:37 <acowley> In fact, it's usually in my ghci inferior mode and emacs happily restarts it
14:32:05 <Axman6> does the GPU free the data in its own memory when the process exits?
14:32:34 <yitz> HaskellElephant: whatever needs to be removed has to be done manually. i think ross is the one who can do it.
14:32:39 <acowley> I don't know for sure, but like I said, nothing horrible has happened to me today
14:33:08 <Axman6> heh, fair enough. are you on linux, and using the nvidia CUDA SDK stuff?
14:33:14 <hpaste> sohum annotated “Not sure what to call this question...” with “working around lack of fundep-genericness” at http://hpaste.org/55590#a55629
14:33:19 <acowley> Axman6: OS X
14:33:21 <Axman6> if so, you can run nvidia-smi to check memory usage on the device
14:33:30 <Axman6> ah, that makes life less easy, heh
14:33:36 <Sgeo_> I think I see how to turn the LI "strict monad" into a Haskell monad
14:33:39 <Sgeo_> Wait, no
14:33:48 <sohum> Cale, yitz: I think I've clarified my question http://hpaste.org/55629
14:33:48 <Ke> Axman6: I'm pretty sure at least AMD does since I never do that
14:34:15 <Ke> and I expect I would have suffered from the memory leak by now
14:34:20 <Axman6> well, actually, nvisia-smi might exist on OS X too... but you'd need the CUDA toolkit, and an nvidia GPU of course
14:34:27 <Cale> sohum: Define it differently? Invent a new typeclass?
14:34:49 <acowley> Axman6: the laptop I'm on right now has a NVidia GPU btw, but I'm using the OpenCL drivers that ship with OS X
14:34:53 <Cale> sohum: also, what's the point of the b type parameter?
14:34:55 <Axman6> Ke: yeah, it wouldn't surprise me. i'd like to know for sure though
14:35:12 <Cale> In the class definition, there's a type variable b which goes unused by the sole method :P
14:35:17 <Axman6> acowley: i have a feeling the nvidia toold will be able to tell you the info i'm after anyway
14:35:32 <Axman6> sadly my MBP has an AMD GPU, so i'm not sure if i can check stuff like that
14:35:45 <acowley> I think it will be fine
14:36:05 <acowley> that is, I don't think the memory will stay allocated after the host process dies
14:36:12 <acowley> that would lead to way too much trouble for all parties
14:36:51 <sohum> Cale: if I could write instance Fooable f => MFooable (f a b) a b without haskell throwing away the instance head, I'd be totally happy with that, but...
14:37:02 <sohum> Cale: ignore the nonusage of the b! it's a toy example :P
14:38:19 <Cale> sohum: Can it be turned into a non-toy example? There are usually somewhat sensible ways to deal with this, inventing newtypes and such.
14:39:23 <Cale> But it's hard to really understand the intention here.
14:40:26 <bmh> I'm trying to bulid with -Wall and -Werror in cabal. I've specified them as GHC-Options, but they don't seem to be getting used.
14:40:59 <sohum> Cale: sure, hang on
14:41:02 <ByronJohnson> I'm really excited for 7.4, with kind polymorphism, contraints kinds, ByteStrings as Functors, etc.
14:41:40 <Axman6> ByteStrings as Functors? is that even possible?
14:41:53 <kmc> with kind polymorphism maybe
14:41:58 <kmc> but i don't see the point
14:42:09 <kmc> is it just so you can write fmap rather than B.map
14:42:22 <acowley> that seems like a bad idea
14:42:28 <kmc> or are there useful helper functions which you would generalize this way
14:42:32 <Axman6> me either, the only function that makes any sense is Word8 -> Word8) -> ByteString -> ByteString
14:42:35 <Axman6> (*
14:42:39 <kmc> the latter is more plausible if it's also Foldable and Traversable
14:42:58 <Ke> why not just any storable
14:43:17 <Ke> hmm, or any storable of constant size
14:43:32 <kmc> all storable things have constant size
14:43:41 <ByronJohnson> And a cleaner ListLike class without messy functional dependencies
14:43:44 <Ke> ok
14:44:14 <acowley> why not just use Data.Vector.Storable at that point?
14:44:29 <Ke> beats me
14:44:31 <ByronJohnson> IIRC, a cleaner class would be a subclass of two other classes (Monoid and... something else) with only one extra function
14:44:45 * ByronJohnson searches his notes
14:44:47 <acowley> now you people have me worried about 7.4 :(
14:44:51 <Ke> I guess we should just see, what is it about
14:45:00 <Ke> or not
14:45:15 <Axman6> there was some work recently to implement ByteString using Vectors, it looked quite interesting, and the complete implementation was almost trivial.
14:45:21 <ByronJohnson> acowley: ..Why?
14:45:42 <ByronJohnson> acowley: Hetereogenous lists will also be posssible in 7.4, if you haven't heard!
14:46:00 <kmc> they're already possible, or what do you mean?
14:46:05 <Mathnerd314> ByronJohnson: are there ropes?
14:46:35 <acowley> Using vectors to implement bytestrings is fine, but to use something called ByteString to store arbitrary storables instead of Vector seems perverse
14:46:57 <acowley> ByronJohnson: what do the heterogenous lists look like?
14:47:24 <acowley> HList usage in the wild seems minimal
14:47:33 <ByronJohnson> acowley: http://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf
14:47:45 <hpaste> sohum annotated “Not sure what to call this question...” with “non-toy example” at http://hpaste.org/55590#a55630
14:47:48 <Axman6> acowley: well, the point of the work was to get all the optimisation that apply to vectors to apply to bytestrings for free too, which would be nice
14:48:02 <Mathnerd314> ByronJohnson: does 7.4 fix records?
14:48:11 <Axman6> so the optimisations only have to be implemented in one place
14:48:19 <sohum> Cale: see http://hpaste.org/55630 , please
14:48:34 <yitz> Mathnerd314: no, nothing is decide about that yet for how to do it
14:48:40 <acowley> Axman6: sure, and I certainly don't have any issues with that whole idea.
14:49:00 <acowley> It makes sense for ByteString to be a special case of Vector a
14:49:08 <Axman6> i'm not sure i understand your previous complaint
14:49:09 <Mathnerd314> yitz: then where is it being discussed?
14:49:54 <acowley> Axman6: My objection was to using ByteString as a Functor to store arbitrary Storables
14:50:08 <acowley> ByronJohnson: oh right, yes, this is actually a really nice HList implementation!
14:50:12 <Axman6> is that done anywhere?
14:50:12 <ByronJohnson> kmc: The newer implementation is much nicer
14:50:17 <Axman6> i'm confused...
14:50:28 <ByronJohnson> The current ListLike library has a lot of flaws / messy redundancies
14:51:01 <ByronJohnson> For example, IIRC, it defines empty when it is already a subclass of Monoid
14:51:08 <acowley> Axman6: Ke suggested it
14:51:26 <Axman6> oh, i see.
14:51:49 <Axman6> yerah, that doesn't make much sense at all really.
14:53:25 <Cale> sohum: mm... I don't think it makes sense for this Metagraph type to be an instance of Graph
14:53:30 <kmc> GHC's type system has become way more powerful in GHC 7.4
14:53:49 <kmc> this is exciting, but I'm also worried about it
14:54:07 <acowley> I'm really excited
14:54:07 <Axman6> get ready, the confusing types are coming!
14:54:20 <yitz> Mathnerd314: well, there's this page on the GHC Trac wiki:  http://hackage.haskell.org/trac/ghc/wiki/Records
14:54:26 <acowley> I think the types we have today can be more confusing due to too much apparent polymorphism
14:54:47 <kmc> i'm afraid that library developers will go crazy with these features
14:54:57 <acowley> this lets you narrow down the scope of type-level fanciness to just what is intended
14:55:02 <yitz> Mathnerd314: there have been many email discussions about it over the years, and several recently, on the GHC users list.
14:55:04 <sohum> Cale: no? thinking about it as a CombinedNode instance is easiest for _me_ to implement it :P
14:55:04 <Cale> sohum: Would matchAny make sense on this type?
14:55:20 <kmc> there's already too much stuff you need to learn to write practical Haskell code
14:55:31 <acowley> kmc: phantom type all the things?
14:55:32 <Cale> or match, for that matter
14:55:47 <mee> kmc: agreed
14:55:59 <kmc> it gets worse if the library you're trying to use is full of generalized associated type synonym constraint family polymorphic kind families
14:55:59 <Cale> I'm assuming that you're referring to the Graph class from FGL
14:56:12 <kmc> this is one reason I keep snapping at people who say that Haskell = GHC
14:56:25 <kmc> even if you never plan to run your code on a different compiler,
14:56:34 <kmc> it's nice to recognize the well-understood subset of the language
14:57:24 <acowley> kmc: that may be a bit idealistic, unfortunately
14:57:30 <sohum> Cale: well... _kinda_. It needs to rebuild the non-matched graph of the two into the decomposition, I guess..
14:57:32 <kmc> i don't think it's well-understood how these new features interact
14:57:38 <kmc> and i think it will take years to establish best practices for them
14:57:44 <ByronJohnson> kmc: I'm also worried that a standar implementation for restricted Functors, etc. won't be established before a dozen variants are published
14:57:54 <sohum> Cale: hrm. I'm trying to use D.I.Graph as a user-facing interface when it exposes some implementation details as well.
14:57:58 <kmc> and a bunch of libraries written in the meantime will be retrospectively hard to use
14:58:09 <Mathnerd314> the only thing GHC needs now is dependent types
14:58:23 <Cale> sohum: Yeah, it's not a very well-designed typeclass. It only really works well for FGL's graph types.
14:58:25 <ByronJohnson> That, yes
14:58:29 <kmc> Mathnerd314, dependent types are *far* simpler than the current GHC type system
14:58:50 <Cale> sohum: Honestly, I don't use FGL or any of the existing libraries when I implement graphs :P
14:59:11 <sohum> Cale: no? pointers on what's better?
14:59:17 <acowley> fgl is fine!
14:59:26 <acowley> use it until you're sure you don't want it
14:59:27 <Mathnerd314> kmc: right, dependent types erase the distinction between values, types, and kinds
14:59:30 <Cale> fgl is *okay*
14:59:31 <kmc> acowley, well, it's unrealistic to stick entirely to H2010 for everything... i'm saying one should hesitate to enable extensions, and think about the consequences
15:00:02 <Cale> But I'll often just implement whatever graph type I need on the spot using other containers like Data.Map
15:00:06 <acowley> kmc: I agree, I'm unhappy about the language spec. vs. GHC situation, too, but it is hard to identify a sensible course of action as a user
15:00:17 <sohum> aah. hrm/
15:00:24 <Cale> fgl's names for things are not very pretty
15:01:09 <acowley> Cale: I agree FGL isn't great, but I think once you get over the initial pain it's not so bad to use.
15:01:12 <kmc> moreover that one should put some effort towards designing within the bounds of H10, rather than producing an unconstrained design and enabling whatever extensions are needed
15:01:49 <kmc> there should be more clarity and consensus regarding the status of different extensions
15:02:02 <Ke> indeed
15:02:19 <acowley> kmc: I'm all for caution, but there comes a point where you run the risk of being plain ornery
15:02:46 <kmc> well of course one can take it too far
15:02:50 <Ke> though the extension market will in some way probably influence which extensions will be included in the standard later
15:03:01 <yitz> kmc: ghc is funded as a research compiler
15:03:13 <kmc> Ke, but that's also bad, if awkward extensions have to be standardized because they're in common use
15:03:20 <Ke> true
15:03:21 <ion> {-# LANGUAGE Everything #-}
15:03:24 <acowley> I think the Haskell community is vigorous enough to deal with a bit of extension churn
15:03:45 <kmc> the way i see it, there are a few different classes of extensions
15:03:45 <acowley> Sure, it's unfortunate, but we'll never learn what works if we don't aggressively try out all our options
15:04:05 <sohum> {-# LANGUAGE ALLTheExtensions-- I'm sorry, I'll show myself out
15:04:06 <kmc> some are very likely to be in a new spec: Rank2Types (because of ST), MultiParamTypeClasses, etc.
15:04:18 <kmc> these are already widely implemented beyond GHC
15:04:49 <yitz> it's called -fglasgow-exts. they intentionally disabled that so you will make it clear exactly which extensions you are enabling.
15:04:55 <kmc> some are simple syntactic sugar; they may never be standardized, but I don't feel too bad using them, because it's a simple matter to remove them
15:06:26 <kmc> others change the type/class system in deep ways
15:06:43 <kmc> and those are the most worrying
15:06:54 <kmc> there is a ton of potential for unintentional interactions between these features
15:07:09 <sohum> Cale: what interface do you tend to create for your graphs? (or: do you have any insight/advice for designing a user facing graph interface?)
15:07:52 <kmc> including implementation bugs (like the recent GHC bug which breaks the type system if you combine GeneralizedNewtypeDeriving and TypeFamilies)
15:08:52 <kmc> also there are libraries which make assumptions about what the type system allows, which then become false when some new crazy GHC feature is turned on
15:10:42 <acowley> sohum: There is no one right representation for graphs, which is why one tends to reimplement appropriate data structures all the time. FGL is one take on an interface with its own advantages and disadvantages.
15:12:50 <sohum> acowley: interfaces are different from representations, surely? I can conceive of the possibility of a useful generic non-implementation-detail-exposing interface -- all functions in it may not be efficient on every type that implements it, but...
15:13:15 <byorgey> kmc: cool propane package =)
15:13:24 <kmc> thansk
15:13:27 <kmc> thanks*
15:14:50 <byorgey> currently generating an animated quasicrystal using both cores... =)
15:15:41 <acowley> sohum: yes, exactly. My point was just that it would be impossible for FGL to be ideal for all applications of graphs. Offering the most flexible interface likely hides  implementation considerations, so my stance is to use FGL with its quite flexible interface or something more application specific with a more targeted interface.
15:15:56 <acowley> kmc: I'm using a port of your quasicrystal code for an OpenCL demo!
15:16:01 <kmc> sweet
15:16:05 <acowley> kmc: I didn't realize it was yours, actually
15:16:17 <acowley> kmc: Shall I credit you by name in my blog post or just the link to your website?
15:16:43 <kmc> *shrug* link is fine
15:19:11 <byorgey> hehe Rastimation
15:21:56 <sohum> acowley: hrm. right, that makes sense
15:25:05 <Mathnerd314> but after, say, GHC 8.0... is there anything left to implement?
15:25:13 <Mathnerd314> or is it basically done?
15:25:22 <kmc> what?
15:26:04 <mjrosenb> ghc is a "research compiler", every time someone comes up with a new way of thinking about things, ghc gets a new extension
15:26:21 <Peaker> wouldn't quite put it that way
15:27:06 <Philippa> every time someone submits a non-batshit patch for one, though
15:27:17 <Mathnerd314> so... people aren't that smart, eventually they'll run out of new ways to think about things
15:27:25 <kmc> that, uh, hasn't happened yet
15:27:26 <byorgey> Mathnerd314: GHC 8.0 will be released on June 17, 2015. At that time we will know everything there is to know about lazy functional programming.
15:27:44 <Mathnerd314> byorgey: great :-)
15:27:52 <Mathnerd314> that's right when I graduate
15:27:57 <Axman6> Mathnerd314: 40,000+ years of history says your wrong...
15:28:08 <mjrosenb> i,i ghc-9 will be rewritten in basic
15:28:15 <kmc> Mathnerd314, at some point it might be nice to have a big, backwards-incompatible change, and you might want to rename the language (and hence GHC) at that point
15:28:17 <Mathnerd314> Axman6: but 18 years of research says I'm right...
15:28:25 <kmc> but that's essentially arbitrary
15:28:33 <sohum> oh god. there's a Data.Lens and a Data.Lenses. yaaaay.
15:28:51 <Axman6> Mathnerd314: 60 years of research says you're wrong :P
15:29:05 <Eduard_Munteanu> Fundeps vs asstypes isn't even settled yet, despite both being implemented in GHC.
15:29:26 <Mathnerd314> Axman6: but those people didn't have the internet
15:29:34 <Axman6> so?
15:29:38 <byorgey> heh, asstypes
15:29:40 <mjrosenb> Eduard_Munteanu: asstypes?
15:29:57 <Mathnerd314> so they didn't have access to a lot of the information they needed, and reinvented it
15:30:05 <Eduard_Munteanu> Associated types.
15:30:12 <Philippa> kmc: the design space for such changes is of an interestingly large size, I reckon
15:30:16 <Mathnerd314> I have relatively great access
15:30:27 <Mathnerd314> so I don't need to reinvent anything
15:30:29 <Philippa> for example, you'd want to consider the relationship between classes/instances and modules
15:31:16 <kmc> also types/values
15:31:25 <kmc> you can reframe classes as a system of implicit parameters
15:31:35 <kmc> as in scala
15:32:00 <Axman6> Mathnerd314: i can assure you, there is a hell of a lot more that can be added to the field of computer science, and a lot of that can be added to GHC
15:32:20 <Philippa> sure, but there's a strong argument that the essence of Haskell as different from a lazy ML is having separate sorts for classes/constraints and their evidence
15:32:22 <Axman6> computer science is a very young area of academia
15:32:30 <Mathnerd314> Axman6: yeah, but it's growing.
15:32:41 <Mathnerd314> soon the bells will toll...
15:33:03 <Axman6> Mathnerd314: so you honestly believe we'll reach a point, in the next decade or so, where we'll know everything we need to know about computers and computation?
15:33:10 <Philippa> move away from that and you're further into "not just a successor to Haskell" territory and I have to wonder why it's not borging Cayenne while it's at it
15:33:49 <Mathnerd314> Axman6: no, but I think I'll reach a point where I don't need to know anything more than that
15:34:12 <kmc> on December 21, 2012 A.D., Jesus Christ himself will return to Earth and make the final commit on GHC
15:34:24 <Axman6> Mathnerd314: that doesn't mean GHC will stop advancing
15:34:25 <rwbarton> last I checked "what Mathnerd314 needs to know" wasn't a criterion for inclusion in GHC
15:34:32 <m3ga> Mathnerd314: i had people say that to me 20 years ago. they were wrong :-)
15:34:33 <kmc> on the same day Donald Knuth will ascend bodily to heaven and the version number of TeX will become exactly π
15:34:37 <Axman6> @remember kmc  on December 21, 2012 A.D., Jesus Christ himself will return to Earth and make the final commit on GHC
15:34:38 <lambdabot> Okay.
15:34:41 <Philippa> Mathnerd314: please don't confuse your own need for knowledge with the lifetime of a field in here, thanks. It's just a variant of "I live in the only Real World" and it's not welcome here
15:35:10 <Mathnerd314> kmc: certain it's 2012? maybe it's 2011
15:35:17 <ricree> kmc, but the Art of Computer Programming will still be a work in progress
15:35:56 <kmc> TAoCP renamed to taco-p, reimagined as a function which determines whether something is a taco
15:36:37 <ricree> hmmm.... can tacos halt?
15:36:47 <kmc> Mathnerd314, so why are you even interested in Haskell?  maybe everything you need to know was already known decades ago
15:36:52 <kmc> Lisp and C, what more do you need?
15:36:57 <Shin-LaC> after installing a new haskell-package, I have both old and new versions of stuff in ~/.ghc/<blah>/package.conf.d
15:37:04 <Shin-LaC> is there an automated way of cleaning that up?
15:37:07 <Philippa> kmc: a hole in my head, apparently
15:37:11 <Axman6> ricree: some certainly can, some certainly can't, and some, we can't know either way, without eating them for the rest of eternity
15:37:47 <sohum> ricree: tacos can be _used_ to create a halt
15:38:11 <Mathnerd314> kmc: because they aren't in the same space
15:38:13 <sohum> ricree: but the general problem of whether a particular taco will cause a halt is unfortunately undecidable
15:38:22 <Mathnerd314> kmc: they need to interact
15:38:33 <mreh> someone help me understand improving values
15:38:33 <Mathnerd314> borging, basically
15:38:37 <mreh> my head hurts
15:38:50 <Axman6> Mathnerd314: first you join a church
15:38:53 <Axman6> uh, mreh
15:38:59 <kmc> Mathnerd314, it just seems really suspiciously convenient that everything before now was incomplete, but everything after now is unnecessary
15:39:04 <kmc> it sounds like blub to me
15:39:31 <Mathnerd314> kmc: alpha-omega paradox
15:39:35 <mreh> :)
15:40:04 <kmc> Mathnerd314, what's that? google not helping
15:40:41 <Enigmagic> it's a beta reduction sauce, goes well with chicken or pork.
15:42:50 <Mathnerd314> kmc: you mention JC.... assumed you were christian
15:43:05 <kmc> haha
15:43:30 <Axman6> ahh, i'm starting to see where this kind of thinking is coming from =)
15:44:35 <mreh> when is he coming back, he's been a bloody long time!
15:45:01 <Mathnerd314> yeah, I'm just meta-trolling
15:45:06 <Axman6> he just said he wa spopping out for a leak, and it's been 2000 years!
15:45:20 <dgpratt> so yesterday (was it?) I came around to find folks in here debating the merits of Nixon and Hilter...
15:45:30 <mreh> and lo, jesus's final message read "brb"
15:45:39 <dgpratt> ...tonight its Jesus and the end of the world...
15:45:40 <mreh> yeah, that was yesterday, bout 2am
15:45:54 <dgpratt> ...#haskell is on a roll, lately!
15:45:56 <Philippa> Mathnerd314: I don't see the meta part from here, FWIW
15:46:11 <dgpratt> mreh: wasn't 2am here :)
15:46:23 <Mathnerd314> Philippa: trolling trolls?
15:46:31 <mreh> what's a morphism?
15:46:57 <Philippa> Mathnerd314: I didn't say I didn't understand you. I'm saying I can't see who you claim to be trolling that was trolling themselves
15:47:10 <Philippa> mreh: it's a changing
15:47:59 <Mathnerd314> Philippa: I'm trollling myself, obviously, so you can see how to do it
15:48:28 <mreh> these morphism are a changin...
15:49:05 <mreh> bob dyland
15:49:14 <mreh> jesus, i'm tired
15:52:49 <alistra> what will your gardener do about it, mreh?
16:08:47 <xil> hi. Can someone recommend a way to color pixels in a window and capture mouse and keyboard input?
16:09:08 <acowley> I've got to go in a bit, but can anyone check a draft of a blog post for me and leave me any notes?
16:09:17 <acowley> xil: gloss
16:10:07 <xil> acowley: AHA. Finally something extremely simple, for quick and dirty projects
16:10:12 <xil> thank you very much =]
16:10:38 <acowley> xil: glad I could help!
16:11:06 <JoeyA> acowley, xil: +1
16:11:30 <JoeyA> (and +1 to the author of the gloss package, of course)
16:11:39 <xil> =]
16:12:06 <Axman6> Gloss started out as the graphics library used at my university for haskell assignments, called ANUPlot
16:12:27 <acowley> Yes, and the head version now has my patches to support full screen video modes which makes it even awesomer!
16:12:48 <Axman6> whoot!
16:13:24 <acowley> I really hope ben can make a new release on hackage soon
16:13:57 <acowley> Axman6: I shall pick on you to proof read my blog post! There is no rush, I'd like to post it tomorrow.
16:14:33 <acowley> Axman6: just let me know if it's terribly confusing
16:14:38 <Goosey> Hey Axman6 :D
16:14:47 <Axman6> no worries, i'm not doing anything, other than drooling over graphics cards i can't afford :(
16:14:50 <Axman6> o/ Goosey
16:15:01 <Axman6> acowley: Welcome to 404 error page! :(
16:15:15 <acowley> so that's confusing?
16:15:22 <xil> wow I love the way gloss goes iterative simulation
16:15:35 <Axman6> acowley: well, i don't see what it has to do with OpenCL :P
16:15:46 <sohum> @pl \m -> mod labN (ins (m .^ labM) k) m
16:15:46 <lambdabot> mod labN =<< flip ins k . (.^ labM)
16:15:59 <acowley> Axman6: that's how I accelerate the 404
16:16:10 <acowley> darn, I wonder why it's a 404 for you
16:16:10 <sohum> @pl \m -> mod labN (ins (getL labM m) k) m
16:16:10 <lambdabot> mod labN =<< flip ins k . getL labM
16:16:11 <Axman6> ahh, well it all seems fine then, nice and fast
16:16:31 <acowley> meh, I'll just post it
16:16:34 <Axman6> acowley: if it's wordpress, i'd need to be logged in to see the preview, unless you publish it sadly
16:17:01 <acowley> I'll submit the link to reddit tomorrow with any corrections you come up with
16:17:19 <acowley> Axman6: http://www.arcadianvisions.com/blog/?p=346
16:19:30 <Goosey> Axman6: When I come back, mind giving me some challenges? First I'm going to flush windows from my desktop.
16:19:59 <Axman6> when will that be? i'm heading home at lunch time, which is in 35 minutes...
16:20:23 <Axman6> i may or may not be on over the weekend. there's a small holiday on this weekend
16:20:39 <Goosey> Hm...how about you give me a few now and I'll ask the channel for help if I need any
16:20:51 <Axman6> hmm, i'll have to think of some.
16:21:07 <Axman6> actually, want to learn about Mon... uh, Fluffys? =)
16:21:25 <Goosey> Mon...:O
16:21:29 <Goosey> Okay ;D
16:21:33 <Axman6> monads! D:
16:21:36 <Goosey> D:
16:21:42 <Axman6> http://blog.tmorris.net/20-intermediate-haskell-exercises/ i can't recommend this highly enough
16:21:51 <Goosey> Oh, this looks nice
16:22:02 <Goosey> Fluffy o-o?
16:22:10 <Axman6> it gets hard, but it's sosososo worth doing
16:22:26 <Goosey> I don't quite understand what to do based on this?
16:22:46 <Goosey> Is there more to it?
16:22:50 <Axman6> you need to replace all the error parts with things that match the defined type classes
16:22:53 <acowley> Goosey: I'd guess fill in the errors
16:22:56 <Goosey> Oh okay.
16:23:19 <Goosey> How do I know what the correct output is?
16:23:23 <Axman6> for example, to get you started, instance Fluffy [] where furry f xs = map f xs
16:23:32 <kmc> or  furry = map ;)
16:23:45 <Axman6> Goosey: you load it into ghci, and see if it complains or not =)
16:23:53 <Axman6> and also by asking questions in here
16:23:53 <Goosey> So, as long as it works, it's okay?
16:23:59 <mjrosenb> it would be pretty easy to write a testsuite for it :/
16:24:04 <kmc> Goosey, it's mostly a matter of getting something to typecheck, without using error / undefined / etc.
16:24:09 <Axman6> probably. be sure to share what you've got when you think it works
16:24:19 <mjrosenb> excercise 21: write a test suite
16:24:43 <Goosey> Okay, well I'll try this out then.
16:25:07 <sherlock> does anyone have any basic haskell challanges they can link me to?
16:25:18 <xil> um. So Gloss does 2D graphics nice and easily, which is great. But I don't see how it can capture the mouse and keyboard. I am familiar with OpenGL, however, so is there a way to access the underlying OpenGL for input capture?
16:25:32 <ddarius> etc = fix id
16:25:41 <kmc> xil, OpenGL does not provide input either
16:25:47 <sherlock> opengl does not provider input
16:25:50 <sherlock> opengl is a context
16:25:51 <kmc> that's handled by another layer: GLUT, SDL, GTK, etc.
16:25:58 <sherlock> *proide
16:26:01 <sherlock> *provide
16:26:22 <xil> oh. I always use GLUT with OpenGL so I assumed the input was OpenGL. Well then....very interesting
16:26:33 <acowley> xil: Have you looked at the Game interface?
16:26:36 <sherlock> ah, no, glut creates the window, deals with event loops, gets input, etc
16:27:19 <acowley> http://hackage.haskell.org/packages/archive/gloss/1.5.2.1/doc/html/Graphics-Gloss-Interface-Game.html
16:34:14 <sohum> @pl \a b c -> f a b c d e
16:34:14 <lambdabot> flip flip e . (flip .) . flip flip d . (flip .) . f
16:38:05 * Axman6 -> home!
16:51:18 <acowley> Axman6: as a bribe to encourage you to check out my blog post, here's a video of the demo http://www.arcadianvisions.com/images/quasicrystal.mp4
17:05:53 <monochrom> "Do you miss null references from your old imperative programming days? Wish that the worlds best imperative language had null references?  Now your wishes have come true with the new partial-lens package!"  from the announcement of partial-lens. hahaha
17:08:18 <Mathnerd314> lol. what will they think of next? :p
17:11:16 <tehgeekmeister> so, excuse me for being dense, people; what incantation will i need to use to parse a string using this library? http://hackage.haskell.org/packages/archive/atto-lisp/0.2.1.1/doc/html/Data-AttoLisp.html
17:11:27 <tehgeekmeister> i've been looking at the docs for like twenty minutes now
17:12:09 <FliPPeh_> Is there a way to have a typeclass constraint for just one field?
17:12:44 <FliPPeh_> data (Num a) => SchemeVal = SchemeString String | SchemeList [SchemeVal] | SchemeNumber a
17:13:16 <monochrom> have you tried that? does that work?
17:13:24 <FliPPeh_> Does not
17:13:47 <kmc> FliPPeh_, you generally don't want to put constraints on the type declaration
17:13:52 <kmc> but rather on the functions which use that type
17:13:59 <kmc> constraints on types usually don't do what you wish they did
17:14:18 <kmc> if you really want that, you'll probably be happier using the GADTs extension
17:14:20 <kmc> (example, one sec)
17:14:48 <FliPPeh_> kmc: The thing is, I'm trying to implement floating point support in that scheme interpreter from the tutorial, I have 2 discrete constructors, "SchemeNumber Integer" and "SchemeFloating Double"
17:14:59 <FliPPeh_> However, I have to write EVERY number function twice
17:15:01 <kmc> actually... yeah, this is different too
17:15:06 <FliPPeh_> One for SchemeNumber and one for SchemeFloating
17:15:16 <kmc> the problem is that a SchemeNumber might be an Integer or might be a Double
17:15:24 <FliPPeh_> Yea :/
17:15:24 <kmc> it's *not* going to be a value which can become either
17:15:42 <kmc> so if you wanted to do a fancy type trick it would be existential quantification
17:15:46 <kmc> but, i think that's not right either
17:15:58 <kmc> i think you should keep SchemeInteger and SchemeFloating separate
17:16:08 <monochrom> existential is all very well without downcasting
17:16:09 <kmc> and write a rank-2 helper function
17:16:11 <FliPPeh_> Any thing I can do to not write everything twice then?
17:16:24 <kmc> (forall a. (Num a) => a -> a -> a) -> SchemeVal -> SchemeVal -> Maybe SchemeVal
17:16:50 <kmc> applyNum f (SchemeInteger x) (SchemeInteger y) = Just (SchemeInteger (f x y))
17:17:03 <kmc> applyNum f (SchemeInteger x) (SchemeFloating y) = Just (SchemeInteger (f (fromIntegral x) y))
17:17:11 <kmc> errrr
17:17:17 <kmc> applyNum f (SchemeInteger x) (SchemeFloating y) = Just (SchemeFloating (f (fromIntegral x) y))
17:18:20 <ddarius> tehgeekmeister: Parse a String into a Lisp value?
17:18:28 <tehgeekmeister> ddarius: yep
17:18:46 <ddarius> tehgeekmeister: The value 'lisp' is an attoparsec parser.
17:19:24 <FliPPeh_> kmc: What exactly is the "forall" thing for? I've seen it thousands of times but I don't really get it
17:19:34 <FliPPeh_> Isn't generic a -> b generic enough?
17:19:35 <kmc> it's used by a few different GHC extensions
17:19:52 <kmc> in this case the extension is RankNTypes
17:19:55 <tehgeekmeister> ddarius: ah, so i should just look at attoparsec to figure out how to run a parser
17:19:56 <tehgeekmeister> cool
17:20:08 <tehgeekmeister> should've occurred to me earlier
17:20:15 <kmc> so, here's the deal:
17:20:29 <benmachine> kmc: Num isn't enough to use fromIntegral
17:20:37 <kmc> :t fromIntegral
17:20:38 <lambdabot> forall a b. (Integral a, Num b) => a -> b
17:20:45 <kmc> benmachine, x has type Integer there
17:21:02 <benmachine> oh, true
17:21:04 <benmachine> I silly
17:21:06 <kmc> FliPPeh_, (Num a) => (a -> a) -> (Int -> Int)
17:21:26 <sal23> is computing the size of a null-terminated C string pure? for example, something like: size:: Ptr CChar -> Int. I think not
17:21:27 <kmc> this says "pick any numeric type T, and give me a function of type (T -> T),  and I'll give you a function of type (Int -> Int)"
17:21:50 <monochrom> more pointedly, the caller picks T
17:21:54 <kmc> sal23, if you can guarantee that the memory does not ever change, then yes it's externally pure.  the implementation will require unsafePerformIO
17:22:00 <kmc> FliPPeh_, with me so far?
17:22:18 <kmc> the problem is, I can pick T = Double.  i can specialize that type to (Double -> Double) -> (Int -> Int)
17:22:24 <kmc> if i'm calling the function
17:23:10 <sal23> kmc, I am thinking more along the line of - that function takes a pointer address, and during the lifecycle of a program, there is tiny chance that when I call size on a different variable, that variable is assigned that same pointer address after recycling the memory
17:23:36 <sal23> so, given same ptr value, we have two outputs, after the memory is recycled by GC
17:23:55 <kmc> yeah, that violates "guarantee the memory does not ever change"
17:24:09 <FliPPeh_> kmc: I can't see the problem giving the function a double :/
17:24:23 <benmachine> sal23: it depends where you got the Ptr from and who owns the memory it points to
17:24:36 <kmc> FliPPeh_, ok, let's look at a slightly different example
17:24:39 <benmachine> but certainly one could pick a Ptr such that that wasn't pure
17:24:48 <kmc> f :: (Num a) => (a -> a) -> (Either Int Double -> Either Int Double)
17:24:54 <sal23> benmachine, could you elaborate? Ptr is inpure, isn't it?
17:24:59 <kmc> f g (Left x) = Left (g x)
17:24:59 <sal23> impure
17:25:04 <kmc> f g (Right x) = Right (g x)
17:25:21 <kmc> this doesn't typecheck
17:25:29 <kmc> because i'm allowed to call f at a less-polymorphic type
17:25:36 <kmc> like (Double -> Double) -> (Either Int Double -> Either Int Double)
17:25:38 <benmachine> sal23: I don't think you can apply the word "impure" to a type
17:25:57 <kmc> or even (Complex Rational -> Complex Rational) -> (Either Int Double -> Either Int Double)
17:26:06 <kmc> do you see why that's a problem?
17:26:34 <benmachine> sal23: I guess the answer you are looking for is yes, your function is impure
17:26:37 <FliPPeh_> I think, yes
17:26:39 <kmc> ok
17:26:48 <kmc> using forall on the left of -> reverses the responsibility
17:26:56 <sal23> benmachine, true…but generally speaking, the Ptr thing comes from external world, and so, is impure, isn't it?
17:27:01 <kmc> instead of the caller exploiting polymorphism, the callee demands polymorphism
17:27:03 <benmachine> sal23: yeah, generally speaking
17:27:16 <benmachine> sal23: but Ptrs don't *have* to come from the external world
17:27:19 <benmachine> or from memory that can change
17:27:25 <kmc> f :: (forall a. (Num a) => (a -> a)) -> (Either Int Double -> Either Int Double)
17:27:27 <kmc> this type will work
17:27:28 <sal23> I am wondering if there is some reference code that has handled it…just simple size calculation given a CString
17:27:48 <kmc> it says "give me a function which, for any numeric type T, has type T -> T.  I will give you a function of type Either Int Double -> Either Int Double"
17:27:55 <benmachine> I imagine most operations on CString are IO
17:27:57 <kmc> the callee picks T
17:28:19 <sal23> benmachine, that would make sense
17:29:57 <sal23> benmachine, if Ptrs come from within, would GHC manage it so that it appears pure?
17:30:32 <benmachine> sal23: I don't know exactly what you mean, but I suspect the answer is no
17:30:43 <djahandarie> @ask byorgey Yes, just not sure when to stop increasing numbers and if there should even be numbers in my function names that mean anything. I think I need to make a nicer version of ala.
17:30:43 <lambdabot> Consider it noted.
18:08:50 <mreh> how could set two threads off to answer a question and kill the other once one has found an answer?
18:09:17 <luite> theres the unamb package for that
18:09:38 <mreh> it doesn't work though, isn't that what conal was saying?
18:10:21 <JoeyA> What doesn't work?  Is the other thread not dying like it should?
18:10:51 <luite> hmm, didn't know that it didn't work, is this in some specific situation?
18:11:09 <mreh> oh, it unearthed some GHC bugs :)
18:11:27 <luite> when was this?
18:11:41 <mreh> a few years back
18:11:43 <JoeyA> There's this bug I spotted: http://hackage.haskell.org/trac/ghc/ticket/5611  (fixed in GHC 7.2, but not documented before)
18:11:55 <JoeyA> (probably unrelated)
18:12:35 <deech> Just saw the release candidate - the Kinds extension looks pretty epic.
18:12:45 <JoeyA> This is one reason why asynchronous exceptions scare me.
18:13:07 <JoeyA> Another is that it's very difficult to prove that the target thread isn't calling a library function that catches a SomeException and discards it.
18:13:16 <MiggyX> Hi guys, if you have a variable of type Result JSValue -  how do you just get the JSValue bit?
18:13:20 <dropdrive> Hi, is there a way to write simple-ish functions in Haskell and have their implementations be generated for use in, say, Python?
18:13:38 <mreh> this is why we need deterministic semantics of nondeterministic calculations
18:13:55 <JoeyA> So unfortunately, I end up having to use both preemption and polling to get my thread to stop.
18:14:23 <mreh> MiggyX: what's the context?
18:14:57 <JoeyA> guess: http://hackage.haskell.org/packages/archive/json/latest/doc/html/Text-JSON.html#t:Result
18:15:15 <MiggyX> mreh: I've used decode to turn a JSON String into a list of JSValue objects. I want to turn that back into an encoded String. This I can do on a JSValue but I don't know how to get the JSValue itself
18:15:23 <JoeyA> Look up the documentation, and pattern-match.  In this case, parsing may have failed, so handle the error case.
18:15:25 <rwbarton> pattern-match
18:16:08 <MiggyX> I'm doing a pattern match in the code itself to handle that - but I'm testing this in ghci so not sure how to do it manually as it were...
18:16:39 <JoeyA> you could print the Result value, no?
18:16:53 <JoeyA> Or are you trying to map over the "if it succeeded" case easily.
18:17:02 <JoeyA> > (+ 100) <$> Just 5
18:17:03 <lambdabot>   Just 105
18:17:06 <JoeyA> > (+ 100) <$> Nothing
18:17:07 <lambdabot>   Nothing
18:17:15 <JoeyA> ^ You can do that with the Result type, too.
18:17:26 <MiggyX> Well I did let a = <decode>   so now a contains a Result JSValue.
18:17:34 <rwbarton> or you can just write let Ok a = ...
18:27:58 <mm_freak> IIRC except for a function argument you can always move it to the left of the type signature, i.e. a -> (forall b c. b -> c) = forall b c. a -> b -> c
18:28:07 <mm_freak> question:  is this because type arguments are never passed explicitly?
18:29:41 <mm_freak> (not asking for an explanation of higher rank types, just asking whether my intuition is flawed)
18:30:13 <byorgey> mm_freak: I think it's because a -> (forall b c. b -> c) is actually implemented as  forall b c. a -> b -> c
18:30:14 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
18:30:18 <byorgey> although I could be wrong about that
18:31:02 <JoeyA> mm_freak: If you take out type classes, you can implement a Haskell interpreter in which, at runtime, *no* type information is passed around.
18:31:11 <mm_freak> byorgey: i remember an explanation that views 'forall' as the type lambda /\, but then this wouldn't be true
18:31:18 <JoeyA> id :: a -> a doesn't need information about a to know how to just return it.
18:31:30 <ddarius> mm_freak: It would be true up to isomorphism.
18:31:44 <byorgey> mm_freak: forall is indeed type lambda.
18:31:49 <JoeyA> map :: (a -> b) -> [a] -> [b] doesn't need to know about the types a and b to do its job.  It just blindly applies the function you give to each item.
18:31:57 <mm_freak> but since in haskell you never pass type arguments explicitly (you can't), it is true (going beyond up-to-isomorphism)
18:32:12 <byorgey> type arguments ARE explicitly passed in, say, GHC core
18:32:49 <kmc> in system F, ∀ is used in types, and Λ is used in terms
18:32:50 <mm_freak> JoeyA: thanks for your explanation, but i already know that
18:32:52 <kmc> they correspond
18:33:01 <xil> hi. Is there a way to check the syntax of a block of code without compiling?
18:33:08 <byorgey> right, sorry, what kmc said
18:33:15 <mm_freak> i also understand how to /use/ forall…  i just asked for something more fundamental
18:33:15 <kmc> xil, you could write a small program which invokes haskell-src-exts
18:33:24 <kmc> or maybe you could use hlint for this purpose
18:33:43 <ddarius> And in GHC Core, /\a.\(x :: a) -> /\b. \(y :: b) -> x and /\a b. \(x :: a) (y :: b) -> x are not identical.
18:34:03 <ddarius> However, you can write a function that will take the former and produce the latter and vice versa.
18:34:05 <xil> hlint is what I was thinking of but couldn't remember what it was called. But I'm frankly not positive it is what I need. I'll try it though. Thanks kmc =]
18:35:01 <mm_freak> ok, but that doesn't really answer my question…  in haskell itself you can't pass type arguments…  is this the reason why the compiler can do this rewriting?
18:35:16 <kmc> mm_freak, i would say, if you could pass type arguments, then it could not do the rewriting
18:35:50 <mm_freak> as a comparison, in agda you couldn't do that, right?
18:36:00 <mm_freak> (except perhaps for implicit arguments)
18:36:03 <kmc> agda has its own system for implicit arguments
18:36:06 <kmc> right
18:36:08 <byorgey> mm_freak: there's still no reason it couldn't rewrite the type and rewrite your implementation to match
18:37:25 <xil> hmm....I thought there was a web interface for hlint. Am I wrong?
18:37:28 <mm_freak> byorgey: do you mean haskell?  because GHC does in fact rewrite
18:37:33 <kmc> xil, hpaste.org is :)
18:37:43 <mm_freak> :t undefined :: a -> (forall b c. b -> c)
18:37:44 <lambdabot> forall a b c. a -> b -> c
18:37:46 <xil> orly
18:38:10 <mm_freak> byorgey: hence my question =)
18:38:48 <byorgey> mm_freak: I mean that it could in theory still do hat rewrite even if you were allowed to pass explicit type arguments at the source level
18:39:11 <mm_freak> but then it would be an internal rewrite and you as the programmer wouldn't observe it, right?
18:39:41 <byorgey> it depends on what you mean by 'observe'
18:40:16 <mm_freak> well, if the compiler flips my function arguments both at definition and usage, i don't observe the flipping
18:40:31 <mm_freak> except perhaps in the type
18:41:05 <mm_freak> and since there is only one type kind (up to GHC 7.0.3), you couldn't observe that change in the kind
18:41:29 <mm_freak> ok, you could observe going from (* -> *) -> * -> * to * -> (* -> *) -> *
18:42:58 <mm_freak> in fact now that i think about it i couldn't even tell "forall a. a -> (forall b. b -> (forall c. c))" from "forall a b c. a -> b -> c"
18:43:18 <ddarius> If you could, something would be broken.
18:43:31 <mm_freak> yeah, i realize now
18:43:38 <mm_freak> thanks
18:44:59 <mm_freak> so it's not just that the compiler rewrites, but they are in fact identical, right?
18:46:00 <ddarius> mm_freak: In Haskell, yes.
18:46:11 <kmc> they don't exist in Haskell
18:46:29 <xil> hi. Could someone look at this error I'm getting from hlint?
18:46:33 <hpaste> xil pasted “hlint?” at http://hpaste.org/55633
18:46:44 <ddarius> Or more correctly, every term in one type is a term in the other with the same behavior.
18:47:24 <mm_freak> but then i wonder:  isn't the usage of "forall" in constructors with an existential context an abuse?
18:47:29 <mm_freak> the word i mean
18:47:34 <kmc> xil, it's actually the line before, data MPoint = (Int,Double,Double,Double,Double)
18:47:34 <ddarius> No.
18:47:41 <kmc> you didn't define a data constructor
18:47:48 <xil> kmc: oh I see it now, haha. Thanks =]
18:47:53 <ddarius> (Well, not at a technical level.)
18:47:57 <xil> should be type not data
18:48:04 <kmc> either make it a synonym, or define a constructor (in which case, drop the tuple constructor)
18:48:16 <mm_freak> ddarius: would using "exists" be logically wrong?
18:48:35 <Sgeo> If there were a solution to the halting problem, what would be the best type of the function to tell whether something halts or not?
18:48:43 <kmc> mm_freak, it is an abuse of sorts.  it's saying that the constructor has a forall type
18:48:53 <Sgeo> halts :: a -> Bool -- see whether a ever fully evaluates?
18:48:54 <rwbarton> it is more of a trick
18:49:14 <kmc> data Foo = forall a. Bar a
18:49:18 <kmc> Bar :: forall a. a -> Foo
18:49:21 <ddarius> mm_freak: Putting 'exists' where 'forall' is in an existential type would be inconsistent.
18:49:33 <kmc> you would write:  data Foo = Bar (exists a. a)
18:49:40 <ddarius> What kmc said.
18:49:57 <mm_freak> kmc: yeah, that would be what i would do if i wrote that extension
18:49:57 <kmc> (you can write in UHC, iirc)
18:50:08 <mm_freak> but then you could just introduce the full "exists"
18:50:16 <kmc> and «data Foo = forall a. (Show a) => Bar a»  would become  «data Foo = Bar (exists a. (Show a) *> a)»
18:50:29 <ddarius> ski has corrupted many.
18:50:39 <kmc> yes :)
18:51:11 <kmc> *> builds a product of a constraint and a value,  as  =>  builds a function from constraints to values
18:51:22 <kmc> but maybe you'd abandon it and use ConstraintKinds :)
18:51:28 <mm_freak> hehe
18:51:37 <kmc> data Dict ctx where Dict :: ctx => Dict ctx
18:51:38 <mm_freak> i'm back to GHC 7.0.3 now
18:51:47 <mm_freak> so no ConstraintKinds anymore (or yet)
18:51:54 <kmc> data Foo = Bar (exists a. (Dict (Show a), a))
18:52:36 <kmc> (the name "Dict" is kind of a nasty case of naming a feature after its implementation detail, but that kind of usage is common in programming)
18:52:47 <mm_freak> Sgeo: if prime numbers were finite, what would be the best algorithm to find the largest prime?
18:52:56 <ddarius> kmc: How 'bout "Context"?
18:53:01 <Philippa> Evidence?
18:53:02 <kmc> works for me
18:53:09 <kmc> i took Dict from edwardk's blog posts
18:53:20 <kmc> Sgeo, halts ⊥ = False; halts _ = True
18:53:22 <kmc> it's so easy :D
18:53:33 <mm_freak> hehe
18:53:46 <kmc> mm_freak, anyway yes, 'forall' in data constructors is kind of an abuse; I think the GADT syntax is clearer
18:53:57 <mm_freak> kmc: indeed
18:53:58 <kmc> data Foo where Bar :: a -> Foo
18:54:15 <Sgeo> mm_freak, surely it's possible to reason about some impossible things?
18:54:18 <benmachine> kmc: is it always possible to tell whether to use *> or => from context?
18:54:26 <kmc> i don't know
18:54:38 <kmc> is it always possible to tell whether to use (,) or (->) from context?
18:54:57 <mm_freak> Sgeo: well, your type looks reasonable
18:54:58 <benmachine> hmm
18:55:02 <Philippa> I'd prefer data Foo = Bar a :: Foo myself
18:55:08 <mm_freak> in agda the function would even be simpler
18:55:23 <mm_freak> halts _ = true
18:55:28 <kmc> hehe
18:55:40 <ddarius> But it would not be solving the Halting Problem.
18:55:47 <mm_freak> correct
18:55:50 <benmachine> kmc: I suppose what I'm asking is whether you can have a type such that replacing some => with a *> or vice versa is also a (let's say in some sense 'interesting') type
18:55:54 <Philippa> and I'd prefer something that retains the idea of constraints/evidence being at least a potentially separable sort
18:56:17 <benmachine> kmc: because it seems to me like you should be able to work out whether to use => or *> based on how the relevant vars are quantigied
18:56:20 <benmachine> *quantified
18:56:36 <kmc> benmachine, in either case the type variable can be in scope from somewhere else
18:56:45 <mm_freak> halts _ = if terminationCheckerEnabled then (just true) else nothing
18:57:17 <kmc> i think (Enum a *> a) and (Enum a => a) are both interesting types
18:57:23 <kmc> assuming 'a' is in scope from somewhere else
18:57:24 <Sgeo> ddarius, surely it's solving the halting problem of a model of sub-turing-complete computation?
18:57:24 <mm_freak> mustHalt _ = terminationCheckerEnabled
18:57:33 <Sgeo> Or is halting problem not parameterized like that?
18:57:43 <ddarius> Sgeo: I wrote "Halting Problem" for a reason.
18:57:50 <Sgeo> Ah, ok
18:58:02 <mm_freak> Sgeo: "/the/ halting problem" is related to turing machines or anything equivalent
18:58:12 <kmc> Entscheidungsproblem would be a good name for a band
18:58:17 <mm_freak> hehe
18:58:22 <benmachine> kmc: I don't think I regard those as types in this context, since we don't assume implicit forall
18:58:33 <kmc> assuming 'a' is in scope from somewhere else?
18:58:40 <mm_freak> and Unentscheidbar would be a good name for the first album
18:58:51 <rwbarton> (e.g. data Foo a = ...)
18:59:26 <benmachine> kmc: hmm. but suppose you know where a is from and whether it's exists or forall
18:59:30 <benmachine> what then?
18:59:37 <benmachine> (or, just the latter thing I guess)
19:01:43 <ddarius> benmachine: There is nothing non-compositional about this syntax.
19:02:29 <benmachine> ddarius: you mean, that's why there's a => and a *>?
19:02:59 <benmachine> ddarius: there's no other reason?
19:03:15 <Philippa> compositionality is a pretty good reason for it
19:03:22 <rwbarton> one reason is they are entirely different sorts of thing
19:03:24 <benmachine> Philippa: sure
19:03:31 <ddarius> benmachine: I don't even know what you are trying to say, but no, I mean the meaning of => isn't going to change based on whether it's under a forall or an exists.
19:03:33 <BMeph> Has anyone "golfed" a Haskell version of a Whitney (APL/A+/J/Q)-style sort list?
19:03:43 <benmachine> at this point I'm not arguing that *> shouldn't exist, I'm trying to understand it better
19:04:10 <ddarius> The whole reason ski dreamt up *> is exactly because of this fact.
19:04:53 <benmachine> ddarius: but in principle you don't need to pay attention to whether => or *> is used because there's only one sensible choice in a given context?
19:05:04 <ddarius> benmachine: No.
19:05:15 <benmachine> no you don't or no that's wrong?
19:05:20 <ddarius> No that's wrong.
19:05:26 <benmachine> okay
19:06:09 <Philippa> I don't much like *> myself, admittedly
19:06:14 <Philippa> just the choice of glyph
19:06:21 <BMeph> It's not an assignment (that I know of), or contest entry. I'm just curious, that's all.
19:06:22 <Philippa> but I don't have a replacement to hand, so hey
19:06:24 <ddarius> And at any rate, even if it were true, the implementation's job is to do what you tell it to, not what is sensible.
19:06:27 <rwbarton> yes, it looks too much like an arrow to me
19:06:44 <ddarius> It looks too MLy.
19:07:07 <int80_h> @src catMaybes
19:07:07 <lambdabot> catMaybes ls = [x | Just x <- ls]
19:08:30 <xil> hi. Hlint suggested something to me that uses Arrows, but I don't know anything about arrows so I don't understand how this suggestion does what my original code does. Could someone help me understand? Even a link to a relevant resource would be great, I just don't know where to start off.
19:08:33 <hpaste> xil pasted “hlint suggestion” at http://hpaste.org/55634
19:08:57 <kmc> xil, you don't need to understand Arrows in generality.  just the instance for (->)
19:09:02 <Philippa> >>, perhaps? I suspect > is going to be part of any infixish glyph
19:09:04 * hackagebot http-proxy 0.0.3 - A library for writing HTTP and HTTPS proxies  http://hackage.haskell.org/package/http-proxy-0.0.3 (ErikDeCastroLopo)
19:09:13 <kmc> xil, look at http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/ghc-doc/libraries/base-4.3.1.0/Control-Arrow.html
19:09:17 <kmc> and replace a with (->)
19:09:20 <kmc> i.e. (a b c) becomes (b -> c)
19:09:38 <kmc> second :: (b -> c) -> ((d, b) -> (d, c))
19:09:57 <ddarius> If Djinn can figure out implementations of all these types, when (->) is substituted, then a human certainly should be able to.
19:10:08 <kmc> i don't necessarily agree with hlint's suggestion here
19:10:22 <xil> kmc: I see....
19:10:41 <kmc> a lens library is more appropriate if you want to start generalizing these things
19:11:27 <xil> kmc: I think it's waaay too general for me as of yet. Thank you for explaining. I won't need that kind of stuff for any of the projects I'm working on now
19:11:29 <kmc> using Data.Lens:   modL sndLens :: (b -> b) -> (a, b) -> (a, b)
19:11:53 <kmc> hmm, that's less general though
19:13:46 <mgsloan> has anyone packaged up a good way to recompile cabal unpacked / darcs versions of a package in a directory that depend on a given package?
19:13:55 <rwbarton> :t fmap `asTypeOf` second
19:13:56 <lambdabot> forall a b d. (a -> b) -> (d, a) -> (d, b)
19:14:18 <kmc> unfortunately doesn't work for 'first'
19:14:54 <ddarius> newtype Swap f a b = Swap (f b a)
19:15:20 * mgsloan realizes that sentence is kindofa fragment.. bit tired
19:15:48 <kmc> mgsloan, https://github.com/yesodweb/cabal-src/blob/master/README.md ?
19:16:04 <xil> kmc: oh Lens is less general, yeah
19:16:18 <kmc> hm, that's not quite right
19:18:02 <mgsloan> yeah.. this can be easily  solved with a shell script to rebuild everything, but it seems like a problem most people would have
19:18:45 <mgsloan> e.g. I change my source version of diagrams-core, now I need to go and manually recompile diagrams-lib, and then diagrams-cairo, and then the application I'm working on
19:19:04 * hackagebot http-proxy 0.0.4 - A library for writing HTTP and HTTPS proxies  http://hackage.haskell.org/package/http-proxy-0.0.4 (ErikDeCastroLopo)
19:25:20 <MiggyX> If I have a list of tuples with (String, Value),  what's the idiomatic way to search that list for a particular String key and return the value?  Using map or fold?
19:25:36 <monochrom> there is "find"
19:25:57 <Sgeo> :t find
19:25:58 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
19:26:06 <monochrom> err, "lookup" is even better
19:26:08 <conal> :t lookup
19:26:08 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
19:26:24 <kmc> MiggyX, the idiomatic way is that you'd use Data.Map instead of a list of tuples :)
19:26:33 <conal> though lookup has an unfortunate argument ordering
19:26:50 <monochrom> and it is still called "lookup" in Data.Map :)
19:26:58 <conal> yeah, what kmc said
19:26:58 <MiggyX> kmc: It's from the json library :)
19:26:59 <Sgeo> :t Data.Man.lookup
19:27:00 <lambdabot> Couldn't find qualified module.
19:27:04 <Sgeo> :t Data.Map.lookup
19:27:04 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
19:27:14 <Sgeo> Same argument ordering
19:27:19 <conal> sadly
19:27:32 <BMeph> Stricter argument ordering.
19:27:43 <Sgeo> ...stricter?
19:27:58 <BMeph> Sgeo: Ord has more constraints than Eq
19:28:28 <Sgeo> That doesn't have much to do with the order of arguments
19:28:30 <Sgeo> Does it?
19:28:48 <monochrom> I put my map in an MVar or IORef or TVar. withMVar (lookup "me") or readIORef >>= lookup "me" or ... has the exact right argument order, thank you very much.
19:29:21 <Sgeo> If it had the other argument order, what
19:29:24 * BMeph was thinking of "ordering" in a different way, oops.
19:29:31 <Sgeo> what's the most idiomatic way to fix that? (flip lookup)?
19:29:33 <ddarius> flip, the Forgotten Adjunction
19:29:39 <Sgeo> WHat about if there were 3 or more arguments?
19:30:19 <BMeph> So, did anyone think on my question, or even notice that I asked one? ;)
19:31:54 <parcs`> :t flip . flip .: flip
19:31:55 <lambdabot> forall a (f :: * -> *) b a1. (Functor f) => f (a1 -> a -> b) -> a -> a1 -> f b
19:32:14 <Sgeo> .: ?
19:32:18 <Sgeo> :t (.:)
19:32:18 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
19:32:29 <parcs`> :t flip .: (flip .) . flip
19:32:30 <lambdabot> forall a b a1 a2. (a -> a2 -> a1 -> b) -> a2 -> a -> a1 -> b
19:32:31 <BMeph> I.e., (.).(.)
19:32:40 <Sgeo> ieeeee
19:32:44 <parcs`> :t flip .: (flip .:) . flip
19:32:44 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *) b a1. (Functor f, Functor f1) => f (a1 -> f1 (a -> b)) -> a1 -> a -> f (f1 b)
19:32:51 <Sgeo> :t (.).(.)
19:32:52 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
19:32:53 <BMeph> AKA, the Eroticon operator... :)
19:32:59 <confab> haha
19:33:30 <Sgeo> Would this be easier to understand without Caleskell
19:34:34 <BMeph> Sgeo: FSVO "understand", ...no. ;)
19:34:49 <parcs`> :t flip . (flip .) . flip
19:34:50 <lambdabot> forall a (f :: * -> *) b a1. (Functor f) => f (a1 -> a -> b) -> a -> a1 -> f b
19:35:02 * ddarius finds (.:) clearer as double fmap than double compose.
19:35:03 <parcs`> there, flip 3 arguments
19:35:05 * Sgeo doesn't have much intuition for pointfree more complex than simplething1 . simplething2 . simplething3
19:35:07 <Sgeo> etc
19:36:34 <parcs`> a b c -> b a c is flip, b a c -> b c a is (flip .), and b c a -> c b a is flip
19:36:43 <parcs`> compose them all together
19:37:04 <Sgeo> It's the (flip .) that I want to develop intuitions about
19:37:07 <mike-burns> Is there a function like (!!) but which handles an out-of-bound index more smoothly?
19:37:49 <kmc> :t \n listToMaybe . drop n
19:37:49 <lambdabot> parse error on input `.'
19:37:54 <kmc> :t \n -> listToMaybe . drop n
19:37:55 <lambdabot> forall a. Int -> [a] -> Maybe a
19:38:08 <mike-burns> Ah, fancy.
19:38:41 <kmc> (doesn't work for negative indices)
19:39:10 <parcs`> Sgeo: trying to understand the code that @pl spits out helped me a lot
19:39:26 <mike-burns> I just noticed the negative index thing too. Wish it handled that for me, too.
19:39:28 <Sgeo> I guess length n and then deciding what to do based on that is a bad idea/
19:39:30 <Sgeo> ?
19:39:44 <mike-burns> It's certainly more code than I was hoping to write, Sgeo .
19:39:57 <parcs`> @pl \f -> f . (f .) . f
19:39:57 <lambdabot> ap (.) ((.) =<< (.))
19:39:59 <Sgeo> I mean, in terms of laziness and not walking the list twice
19:40:09 <parcs`> wow, that's pretty
19:40:21 * Sgeo yips at the bind that just showed up
19:40:28 <Sgeo> @src (->) (=<<)
19:40:28 <lambdabot> Source not found. :(
19:40:36 <Sgeo> @src (->) (>>=)
19:40:37 <lambdabot> f >>= k = \ r -> k (f r) r
19:41:16 <Sgeo> I know that the Functor and Monad instance of functions is basically Reader, but I have no intuition for what that actually means
19:41:55 <parcs`> :t (=<<) `asTypeOf` (ap . flip)
19:41:56 <lambdabot> forall a b a1. (a -> a1 -> b) -> (a1 -> a) -> a1 -> b
19:41:59 <BMeph> So, anyone have a solution for my function that doesn't sort the list twice?
19:42:49 <parcs`> Sgeo: what what means
19:42:52 <parcs`> ?
19:43:15 <Sgeo> Oh, it's not (->) that's a functor, it's (r ->), right?
19:43:17 <byorgey> BMeph: what was your question?
19:43:23 <parcs`> Sgeo: yeah
19:43:37 <BMeph> byorgey: "Has anyone "golfed" a Haskell version of a Whitney (APL/A+/J/Q)-style sort list?"
19:46:11 <BMeph> By which I mean, given a sortable list, the result is a list of Ints, corresponding to the indices of the original list's elements would have in the sorted version of that list.
19:46:36 <BMeph> s/of the/the/
19:46:45 <parcs`> @pl \f -> ap f (f =<< f)
19:46:45 <lambdabot> ap ap (join (=<<))
19:47:08 <rwbarton> \xs -> map snd . sort $ zip xs [0..] -- ?
19:47:23 <parcs`> :t ap ap (join (=<<)) (.) flip
19:47:23 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
19:47:23 <lambdabot>     Probable cause: `=<<' is applied to too many arguments
19:47:23 <lambdabot>     In the first argument of `join', namely `(=<<)'
19:47:53 <BMeph> rwbarton: Then you'd have to do it again; that gives you the indices of the sorted list in the original version. :)
19:48:18 <rwbarton> sorry this sentence was a bit incomprehensible, let me try again :)
19:48:35 <BMeph> Conceptually: sort2 xs = ns where xs = map (sort xs!!) ns
19:49:17 <rwbarton> oh, so the smallest element is replaced by 0 wherever it occurs, etc.
19:49:37 * BMeph feels spoiled that GHC isn't "loopy" enough to actually run that as viable code...
19:50:19 <BMeph> rwbarton: No, just the first time. The next time it occurs, it would be replaced by 1.
19:50:25 <rwbarton> well I assume they are different
19:51:01 <BMeph> Example: Some...> srt "supercalifragilisticexpialidocious"
19:51:01 <BMeph> -> [27,31,23,7,25,3,0,18,11,9,26,1,10,12,19,13,28,30,14,4,8,33,24,15,2,20,16,6,21,5,17,22,32,29]
19:52:01 <BMeph> > map (sort "supercalifragilisticexpialidocious"!!) [27,31,23,7,25,3,0,18,11,9,26,1,10,12,19,13,28,30,14,4,8,33,24,15,2,20,16,6,21,5,17,22,32,29]
19:52:01 <lambdabot>   "supercalifragilisticexpialidocious"
19:52:03 <Sgeo> BMeph, hmm?
19:52:08 <Sgeo> Why wouldn't that run?
19:52:10 <Veinor> BMeph: that reminds me, i need to hack on my ghci
19:52:24 <Sgeo> Wait, why sort2 vs sort?
19:53:08 <Sgeo> Wait, = ns but ns isn't defined there
19:53:15 <BMeph> Sgeo: "sort" sorts them; "sort2"/"srt" gives the indices of the list in terms of its sorted version.
19:53:30 <rwbarton> the "where" clause in that "definition" is supposed to be a definition of ns
19:54:00 <rwbarton> It does feel like you should be able to do some sneaky tie-the-knot trick
19:54:17 <BMeph> Sgeo: It's a "conceptual" definition; it doesn't run, but if it did, it would work that way... if that makes any sense. :)
19:55:35 <BMeph> > sort "supercalifragilisticexpialidocious"
19:55:36 <lambdabot>   "aaacccdeefgiiiiiiillloopprrssstuux"
19:55:56 <BMeph> > map ("aaacccdeefgiiiiiiillloopprrssstuux"!!) [27,31,23,7,25,3,0,18,11,9,26,1,10,12,19,13,28,30,14,4,8,33,24,15,2,20,16,6,21,5,17,22,32,29]
19:55:57 <lambdabot>   "supercalifragilisticexpialidocious"
19:56:10 <Sgeo> > sort "the quick brown fox jumps over the lazy dog"
19:56:11 <lambdabot>   "        abcdeeefghhijklmnoooopqrrsttuuvwxyz"
19:56:17 <BMeph> (Just in case it wasn't clear what I meant earlier)
19:56:20 <rwbarton> you could do it with IVar for instance, zip with a list of IVars, sort, fill in the IVars with 0.. in their new order and then return the original list of IVars
19:56:56 <Sgeo> IVar?
19:58:04 <BMeph>   sort2 "the quick brown fox jumps over the lazy dog" -> [34,17,12,0,30,36,19,10,21,1,9,31,25,39,24,2,15,26,40,3,20,37,23,29,33,4,27,38,13,32,5,35,18,14,6,22,8,42,41,7,11,28,16]
19:59:22 <kmc> > (map snd.sort.flip zip[0..]) "the quick brown fox jumps over the lazy dog"
19:59:23 <lambdabot>   [3,9,15,19,25,30,34,39,36,10,7,40,2,28,33,16,42,1,32,6,20,8,35,22,14,12,17,...
20:00:18 <BMeph> > (map snd.sort.flip zip[0..].map snd.sort.flip zip[0..]) "the quick brown fox jumps over the lazy dog"
20:00:19 <lambdabot>   [34,17,12,0,30,36,19,10,21,1,9,31,25,39,24,2,15,26,40,3,20,37,23,29,33,4,27...
20:00:59 <kmc> o_O
20:01:08 <ddarius> BMeph: Now apply Bird-style optimizations.
20:01:42 <int80_h> what is the function that has the type String -> [Word8]?
20:01:48 <kmc> const []
20:03:28 <Sgeo> int80_h, I don't think Chars can fit in Word8?
20:03:36 <Sgeo> @hoogle Char -> Word8
20:03:37 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
20:03:38 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
20:03:38 <lambdabot> Prelude error :: [Char] -> a
20:03:41 <rwbarton> as kmc has wittily pointed out, there is more than one such function
20:03:58 <int80_h> Sgeo, I'm trying to use ByteString.pack, but it takes a [Word8]
20:04:00 * kmc so witty
20:04:12 <kmc> int80_h, Strings are composed of characters; ByteStrings are composed of bytes
20:04:18 <Sgeo> @hoogle String -> [Word8]
20:04:18 <lambdabot> Control.Monad.Trans.Error listMsg :: ErrorList a => String -> [a]
20:04:18 <lambdabot> Prelude error :: [Char] -> a
20:04:18 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
20:04:30 <kmc> int80_h, you want to encode those characters using some character encoding?
20:05:02 * BMeph prefers a confectionary chocolate encoding...
20:05:07 <Sgeo> You can't assume that a Char is ASCII
20:05:40 <int80_h> kmc: yes, I am trying to construct a Mail. I am getting tripped up on the MailHeaders, as it takes a (ByteString,Text). I'm having difficulty constructing the ByteString.
20:05:49 <kmc> int80_h, if you want to use the UTF-8 character encoding, try Data.ByteString.UTF8.fromString
20:05:53 <kmc> http://hackage.haskell.org/packages/archive/utf8-string/0.3.7/doc/html/Data-ByteString-UTF8.html
20:06:00 <BMeph> Sqeo: Well, you _can_, but it'd be wrong. ;)
20:06:05 <kmc> another very useful module is http://hackage.haskell.org/packages/archive/text/0.11.1.10/doc/html/Data-Text-Encoding.html
20:06:12 * Sgeo is Sgeo not Sqeo
20:06:23 <kmc> you can assume a Char is ASCII, just like you can assume a Maybe is Just
20:06:49 <kmc> however a lot of standard code is worse than that, because it doesn't even check, just does something unreasonable like wrapping the codepoints
20:06:58 <Sqeo> Just talking to myself... ;þ
20:07:19 <kmc> int80_h, you'll have to figure out what character encoding is expected.  there are many different, incompatible ways to represent a character as a sequence of bytes
20:19:19 <kmc> int80_h, are you using the mime-mail library?  I'm just guessing from context, but it looks like that ByteString is a SMTP header name, and therefore should be in ASCII encoding
20:20:49 <kmc> the UTF-8 encoding function will work fine, provided that your characters are all ASCII characters (value 127 or under)
20:21:32 <kmc> the careful correct way would be to use fromChars and toBytestring from http://hackage.haskell.org/packages/archive/ascii/0.0.4/doc/html/Data-Ascii.html
20:22:25 <kmc> the module Network.Mail.Mime itself uses Data.ByteString.Char8 (boo! hiss!)
20:45:55 <parcs`> is there a function interleave :: [[a]] -> [a]
20:46:34 <ddarius> :t concat . transpose
20:46:35 <lambdabot> forall a. [[a]] -> [a]
20:46:52 <BMeph> parcs' Sounds like the "join" for the Omega Monad may be what you want. :)
20:48:48 <dataangel> In haskell is "foo bar x" ever ambiguous without context, e.g. can it mean either foo(bar(x)) or foo(bar, x) ?
20:48:57 <kmc> writing that function to handle an infinite list of infinite lists is a fun exercise
20:49:11 <kmc> dataangel, no
20:49:14 <kmc> dataangel, it always means ((foo bar) x)
20:49:35 <kmc> which in C syntax is something like ( foo(bar) )(x)
20:49:51 <kmc> but corresponds roughly to foo(bar, x)
20:50:03 <kmc> because that's how multi-argument functions are typically represented in haskell
20:50:42 <dataangel> kmc: Ah, but you don't know whether foo is a function returning an arbitrary function or if currying is taking place (because as far as haskell is concerned (foo bar) is returning a function either way)
20:51:03 <kmc> you don't know because there's no difference
20:51:10 <dataangel> right
20:51:16 <dataangel> interesting
20:52:23 <Axman6> dataangel: i suggest you learn to read haskell types before going further
20:53:03 <kmc> dataangel, it's common to think of the same function-application as multiple arguments in one situation, and returning a function in another situation
20:53:22 <kmc> > (+) 2 3
20:53:23 <lambdabot>   5
20:53:29 <kmc> > map ((+) 2) [3,4]
20:53:30 <lambdabot>   [5,6]
20:53:38 <Sgeo> runState comes to my mind
20:53:42 <Sgeo> :t runState
20:53:43 <lambdabot> forall s a. State s a -> s -> (a, s)
20:54:19 <Sgeo> State is defined as something that contains an s -> (a, s) and calls it runState
20:54:29 <Sgeo> So runState myState gives me an s -> (a, s)
20:54:47 <Sgeo> But it feels more useful to call that with an initial state
20:54:52 <dataangel> I was just considering from the point of code readability whether currying being explicit syntactically would be useful, e.g. if you had to put a sigil in front of the function name to indicate not all arguments were going to be supplied. Currying keeps tripping me up trying to read the RWH examples
20:55:20 <Sgeo> Would I have to put a sigil in front of flip?
20:55:29 <Sgeo> Let's say I wanted flip (.)
20:55:44 <Sgeo> But since that's equivalent to partially applying flip, @flip (.) is what you'd want?
20:56:03 <Sgeo> :t flip
20:56:03 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
20:56:08 <kmc> dataangel, that seems unfortunate because changing «f x = \y -> ...» to «f x y = ...» would break users of f
20:56:22 <dataangel> I'm not specifically familiar with flip but I think that's right. The @ would indicate you're only giving flip the one argument (.) but that it normally takes more.
20:56:38 <Sgeo> dataangel, flip changes the order of arguments of a function
20:56:41 <kmc> :t Prelude.flip
20:56:42 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
20:57:06 <Sgeo> So usually, people don't think of flip as a function that takes more than one argument
20:57:14 <acowley> this really is just an issue of reading types
20:57:25 <Sgeo> It's just a function that takes a function and returns a function, the way people usually think of it
20:57:27 <kmc> Sgeo, the way I interpreted it, it would depend on whether flip is defined as «flip f = \x y -> f y x» or «flip f x y = f y x»
20:57:37 <acowley> the associativity of -> is everything
20:57:41 <dataangel> kmc: Would it? If it were based on the type signature I think not. The types being the same is why those two are equivalent
20:57:43 <kmc> also, am I now not allowed to pass a "3-arg function" to flip, because flip's code uses it without an @
20:58:00 <kmc> dataangel, I don't know, you're the one proposing the feature
20:58:28 <kmc> I don't see how you distinguish "currying" from "returning a function" except by the syntax used at the function's definition
20:58:45 <Sgeo> dataangel, there is literally no type-level distinction between a function that, say, takes one argument and returns a function, and a function that takes more than one argument
20:59:00 <kmc> anyway, I think it's a bad idea.  you will get used to reading curried code
20:59:02 <dataangel> Sgeo, oh right :P
20:59:06 <ddarius> Currying is the primordial case of returning a function.  Supporting higher order functions is equivalent to supporting currying/uncurrying.
20:59:15 <kmc> in general Haskell is optimized for the skilled practitioner and not for beginners
21:00:03 <Sgeo> Is it ok if I can read Haskell at a somewhat advanced level but write at a less advanced level?
21:00:19 <kmc> i don't know what it would mean for that to be "not ok"
21:00:19 <dataangel> if currying were explicit or if parens were always used for parameter passing I wouldn't have a problem, but the combination makes it so when I look at the RWH examples I can never tell what's being passed to what without looking up all the type signatures first
21:00:41 <kmc> dataangel, I think you're confused.  you can always tell what's being passed to what without looking up the type signatures
21:00:53 <kmc> (f x y)  is always  ((f x) y),  never  (f (x y))
21:01:17 <monochrom> I would hate to add that kind of sigil. Deciding "to add or not to add" comes down to a highly subjective and distracting judgement of "perspective" and "intention".
21:01:49 <Sgeo> > flip (-) 3 4
21:01:51 <lambdabot>   1
21:02:16 <Veinor> oh that reminds me
21:02:24 <dataangel> kmc: yeah I haven't grokked the grammar then. I'll try looking again knowing now that it's always unambiguous
21:02:28 <Veinor> in something like f x >>= \ a -> g a >>= \ b -> h
21:02:41 <Veinor> is it f x >>= (\ a -> g a >>= (\ b -> h))
21:02:44 <kmc> put another way:  Haskell parsing is not type-directed
21:02:57 <Sgeo> Does flip take 3 arguments? Does it take one argument, and return a function that acts on the 3 and 4? The answer to both questions is yes. (Well, technically "no" to the first question, but bleh)
21:03:07 <kmc> i'm going to say it takes 2 arguments, just to be perverse
21:03:10 <Veinor> or ((f x) >>= \a -> g a) >>= \b -> h
21:03:20 <Axman6> dataangel: mind you, it's only unambiguous if you're used to it :P
21:03:29 <dataangel> kmc: ah, good to know. I'm coming from C++ which is almost the antithesis in that regard ;p
21:03:31 <Axman6> luckily the compiler is
21:03:46 <kmc> yep :)
21:04:00 <ddarius> Since Haskell has type inference, it pretty much can't have a type directed syntax.
21:04:01 <acowley> Veinor: the first
21:04:10 <Veinor> ah, okay
21:04:14 <kmc> ddarius, that sounds like a nice challenge for an esolang
21:04:15 <monochrom> f x >>= (\ a -> g a >>= (\ b -> h)). lambda tries to extend to the right
21:04:18 <acowley> Veinor: The right associativity is what lets the binding for a be visible in the last part
21:04:29 <Veinor> makes sense
21:04:36 <Veinor> playing around with @do tells me that in this case, they're equivalent
21:04:39 <kmc> make an ambiguous grammar; typecheck all parse trees
21:04:47 <kmc> if more than one typechecks, run them concurrently
21:04:56 <Veinor> haha
21:05:01 <shachaf> Sadly you can't say e.g. "f \x -> x"
21:05:02 <Axman6> and ask the user to resolve conflicts
21:05:24 <rwbarton> it can be a language for a nondeterministic turing machine
21:05:24 <shachaf> kmc: Any program that typechecks is correct, so you might as well pick one randomly.
21:05:28 <kmc> sure
21:05:30 <Veinor> i'm always a fan of \_ ->
21:05:33 <monochrom> >>= is, in fact, infixl 1
21:05:34 <Veinor> the chair function
21:06:35 <dataangel> If you don't know what an operator does (something I keep running into trying to use xmonad), what's the best way to find what module it was imported from so I can lookup the docs?
21:06:48 <scshunt> wom 2
21:06:53 <kmc> load your code in ghci, then
21:06:56 <acowley> Axman6: have you had a chance to check that blog post to see if it's clear?
21:07:02 <kmc> :i #%@*#%^@#$
21:07:39 <ski> ddarius :D
21:07:54 <ski> @remember ddarius ski has corrupted many.
21:07:54 <lambdabot> It is forever etched in my memory.
21:08:00 <ski> <ddarius> It looks too MLy.
21:08:17 * ski rather likes the tuple type syntax in the MLs
21:09:05 <ski> Philippa : the `>' was to add some kind of "directeness / assymetry" to it -- i'm not wedded to the concrete syntax
21:09:36 <kmc> i think in GHC HEAD you would just use ConstraintKinds
21:10:48 <kmc> data Ctx :: Constraint -> * -> * where (*>) :: k => t -> Ctx k t
21:10:58 <Axman6> acowley: sorry, no! had to go get lunch with my girlfriend, and i've been playing with my new thunderbolt display that u just picked up. that gives me an excellent excuse to stair at it! :P
21:11:40 <kmc> but then i guess you have to name it (:*>) or something
21:11:50 <monochrom> ML can afford it because ML is eager. If you write Ctor(x,y), ML'ers do not think of it as one box for Ctor, then one tuple. They know it collapses to one tuple.
21:12:14 <acowley> Axman6: No worries! I just want to make sure the post isn't too obscure, and it's always nice to get some confirmation that code works on other people's computers.
21:12:31 <kmc> ...no, you really want the infix at the type level
21:12:39 <monochrom> whereas if you write Ctor(x,y) to Haskellers, they think it is one box for Ctor, then one tuple. An extra level of indirection for non-strictness
21:12:55 <ski> (monochrom : can afford what ? not having curried data constructors ?)
21:13:21 <monochrom> can afford the Ctor(x,y) notation without suggesting what Haskell would suggest
21:13:28 <rwbarton> writing x * y * z instead of (x,y,z)/((x,y),z)/(x,(y,z)), I guess
21:13:41 <kmc> data (:*>) :: Constraint -> * -> * where K :: k => t -> k :*> t
21:14:16 <kmc> K 3  ::  Ord Bool :*> Int
21:14:53 * ski notes that in O'Caml, `type foo = Foo of int * int' is not the same as `type foo = Foo of (int * int)'
21:15:23 <kmc> sucks
21:15:48 <monochrom> but in OCaml you still write Foo(0,0)
21:15:58 <rwbarton> but they only differ in the syntax you use to work with them, right?
21:16:12 <rwbarton> I only sort of remember OCaml.
21:16:35 <rwbarton> with `type foo = Foo of int * int' you don't write `Foo 0 0'?
21:16:55 <monochrom> ok, I have to check
21:17:40 <augur> a friend who shall remain nameless is curious if its possible to have a strict language with a lazy subcomponent demarcated by types
21:17:41 <ski> rwbarton : with the latter, you can say `Foo (x,y)' as well as `Foo xy'; with the former you can only say `Foo (x,y)'
21:17:47 <Axman6> acowley: "One list bit of mystery" -> "One last bit of mystery"?
21:17:53 <monochrom> it is Foo(0,0)
21:17:53 <rwbarton> oh wow
21:17:59 <ski> augur : i suspect so
21:18:17 <augur> ski: thats what i figure.
21:18:53 <acowley> Axman6: Fixed, thanks!
21:19:20 <ski> in SML, otoh, there is no difference between `datatype foo = Foo of int * int' and `datatype foo = Foo of (int * int)' -- in either case can you say both `Foo (x,y)' and `Foo xy'
21:19:36 <monochrom> LazyML is probably eager with lazy types. and yes it's eager vs lazy, not strict vs lazy. and yes generally you can say that MLs are eager or not, they are given operational semantics rather than denotational semantics
21:20:43 <rwbarton> I wonder then, in OCaml is there some additional runtime penalty for Foo of (int * int)?
21:20:45 <ski> also in `SML' you say `Foo' without applying it to argument, while in O'Caml, you have to say `fun (x,y) -> Foo (x,y)' alt. `fun xy -> Foo xy'
21:21:12 <Axman6> acowley: can i suggest you rename min(1.0f, max(0.0f, wrap(sum))) as a separate function called clamp?
21:21:49 <ski> monochrom : hm, so the formal semantics for SML is operational, and not denotational ?
21:21:59 <monochrom> that's exactly right.
21:22:02 <ski> ok
21:22:10 <acowley> Axman6: Now that I check, I think that's actually a built-in
21:22:19 <Axman6> even better =)
21:23:49 <Axman6> acowley: also seems that computing sin(theta) and cos(theta) outside the forloop might increase performance... except if it means more register usage =)
21:24:05 * hackagebot hothasktags 0.2.1 - Generates ctags for Haskell, incorporating import lists and qualified imports  http://hackage.haskell.org/package/hothasktags-0.2.1 (LukePalmer)
21:24:15 <Axman6> i think it should be ok though. isn't most of the wave expression constant, except phase?
21:24:48 * Axman6 should stop optimising
21:25:05 <acowley> Axman6: that's a point that I didn't spend any words on: this isn't at all carefully optimized. The magic part is that OpenCL is so blindingly fast that even stupid code runs like greased lightning.
21:26:09 <Axman6> can i recommend you put a note in to ease the pain of chronic optimisation junkies like me, along those lines? :P
21:28:08 <acowley> Yeah, that's a good idea
21:28:23 <monochrom> greased lightning may run slower than ungreased lightning. insulator and all that.
21:28:36 <Axman6> just because they're such obvious optimisations (which hopefully any decent opencl compiler will spot
21:28:52 <Sgeo> "Smalltalk (a decent language sullied by terrible engineering)"
21:28:56 <Sgeo> Terrible engineering? How so?
21:29:05 * hackagebot data-inttrie 0.0.7 - A lazy, infinite trie of integers.  http://hackage.haskell.org/package/data-inttrie-0.0.7 (LukePalmer)
21:29:06 <monochrom> ask the author?
21:29:07 * hackagebot data-memocombinators 0.4.3 - Combinators for building memo tables.  http://hackage.haskell.org/package/data-memocombinators-0.4.3 (LukePalmer)
21:30:34 <acowley> Axman6: I'm actually not sure what it will do with that angles array
21:31:31 <shachaf> Axman6: The solution is to stop being "chronic optimisation junkies".
21:31:44 <Axman6> seems to me that the angles array could be replace with static arrays with the sin and cos values precomputed
21:31:51 <acowley> yes absolutely
21:31:57 <acowley> and I'm 100% sympathetic to your pov here
21:32:14 <acowley> but what I find so astounding is just how well this kind of a hack job performs
21:32:22 <Axman6> shachaf: when your code is run several million times a second, small optimisations can actually make a difference
21:32:36 <Axman6> yeah, it's lovely :D
21:32:41 <acowley> Axman6: but you need to be careful about trading resources
21:32:44 <Axman6> i'm just installing gloss now to try it out
21:32:48 <Axman6> yeah
21:32:52 <acowley> with GPUs in particular sometimes recomputing things is faster
21:32:59 <Axman6> yeah
21:33:14 <Axman6> you'd want to copy the angles sin and cos arrays into local memory first
21:33:28 <acowley> yes
21:33:36 <shachaf> Axman6: I'm aware of this.
21:34:04 * shachaf spent a while optimizing code that ran several million times a second.
21:34:05 * hackagebot zoom-cache 1.0.0.0 - A streamable, seekable, zoomable cache file format  http://hackage.haskell.org/package/zoom-cache-1.0.0.0 (ConradParker)
21:34:19 <acowley> but that all gets more involved. Nvidia's OpenCL compiler is more flexible than whatever I have on this laptop. Here, using local arrays is a hassle because I can't just stick a __local qualifier on what would naturally be a private array.
21:34:24 <Axman6> so it turns out that the thunderbolt connectors get quite hot...
21:34:36 <acowley> it's due to the friction between clouds
21:34:50 <Axman6> hmm?
21:34:53 <monochrom> and lightnings. greased lightnings :)
21:35:09 <Axman6> doesn't OpenCL specify the same four memory regious CUDA does, but with different names?
21:35:18 <acowley> (joke … thunder … clouds … iCloud…)
21:35:37 <monochrom> (and thunder, lightning) :)
21:35:37 <acowley> Axman6: yes, but I think I read that they're slightly different. This issue is just one of variable declaration syntax.
21:35:55 <acowley> For instance, some OpenCL drivers support C++ style comments, others don't.
21:35:57 <Axman6> ah fair enough
21:36:02 <Axman6> bleh
21:36:04 <acowley> Some support CPP #defines, others don't.
21:36:05 <acowley> it's awful
21:36:18 <kmc> haha
21:36:25 <acowley> I had a couple days recently where I almost gave up altogether on OpenCL because of stuff like that
21:36:27 <kmc> i remember back when GLSL was like that
21:36:28 <Axman6> you'd think that, with a standardised language 'n all, things would be pretty compatible
21:36:34 <kmc> CUDA and OpenCL were supposed to fix that
21:36:35 <kmc> guess not ;P
21:36:47 * kmc has done GPGPU only in GLSL
21:36:52 <Axman6> CUDA has nothing to be incompatible with :P
21:36:56 <acowley> The problem seems to be that everyone writes their own front end
21:37:07 <kmc> Axman6, what, other versions of the same driver don't count?
21:37:22 <monochrom> they should all use Haskell and parsec to write their frontends
21:37:28 <Axman6> well, there's work to get Clang working as an OpenCL compiler, and it actually works in the latest release, producing PTX code for nvidia GPUs
21:37:45 <acowley> kmc: try out OpenCL with the samples I posted (if you don't mind installing a couple packages from source repositories)
21:38:11 <Axman6> and nvidia's latest compiler is LLVM based, which, according to them, means that people could write alternative backends for CUDA, which could eb quite cool
21:38:22 <acowley> Axman6: I take it you still haven't  heard anything from zhensydow on github regarding the opencl package?
21:38:41 <acowley> I'd really like to get at least one of my changes into the package
21:38:51 <Axman6> nope, only your reply
21:39:10 <acowley> shoot, I hope it's just a holiday issue
21:39:29 <Axman6> bleh, i assume this Quasicrystal stuff really does need that new version of gloss
21:39:40 <acowley> Axman6: you can backport it if you like
21:39:46 <acowley> it's just the animate interface changed
21:39:55 <acowley> which was instigated by me
21:40:09 <Axman6> ah, i see
21:40:20 <acowley> but ben did a nice job with it, so I've adapted all my code to use it
21:40:39 <acowley> which right now is a bit of a pain, but will hopefully be fine when the new version hits hackage
21:42:41 <Axman6> hmm, why is the local size being set to 4327298832 ...
21:42:50 <acowley> where?
21:42:55 <Axman6> [CL_INVALID_WORK_GROUP_SIZE] : OpenCL Error : clEnqueueNDRangeKernel failed: local_size[0] = 4327298832 must evenly divide into global_size[0] = 800
21:43:09 <acowley> Axman6: you didn't install my opencl fork
21:43:18 <Axman6> ah, no
21:43:29 <acowley> Axman6: clEnqueueNDRangeKernel supports a mode where the driver selects the local size it thinks best
21:43:41 <Axman6> interesting
21:43:42 <acowley> for some reason the OpenCL package doesn't expose that, so I added it back in
21:44:00 <acowley> it's the patch I most want to get into the package asap
21:44:05 * hackagebot zoom-cache-pcm 0.2.3.0 - Library for zoom-cache PCM audio codecs  http://hackage.haskell.org/package/zoom-cache-pcm-0.2.3.0 (ConradParker)
21:44:07 * hackagebot zoom-cache-sndfile 1.0.0.0 - Tools for generating zoom-cache-pcm files  http://hackage.haskell.org/package/zoom-cache-sndfile-1.0.0.0 (ConradParker)
21:44:09 * hackagebot scope 0.6.0.0 - An interactive renderer for plotting time-series data  http://hackage.haskell.org/package/scope-0.6.0.0 (ConradParker)
21:45:36 <acowley> This is why byorgey suggested I include a script with the post to download all these pre-release versions :/
21:48:57 <Axman6> acowley: with your latest one (i think), i'm still getting the same error
21:49:26 <Axman6> acowley: does it need to be the develop branch?
21:49:40 <acowley> I only have a master branch
21:49:53 <Axman6> you have a develop branch too apparently
21:50:39 <acowley> Not that I can see
21:51:02 <Axman6> https://github.com/acowley/opencl clearly lists two branches :\
21:51:36 <acowley> if you click on branches it should just show master, though
21:51:50 <acowley> oh I see
21:51:55 <acowley> well, no develop is not my branch
21:52:02 <Axman6> hmm, ok. well anyway, it didn't work, i got the same error
21:52:59 <Axman6> ah, hmm, i have a few different OpenCL packages installed. one sec
21:53:11 <acowley> perhaps it's not picking up the latest version? It looks like my version number isn't bumped
21:53:35 <Axman6> installed things in the wrong order
21:53:42 <acowley> oh no, it is bumped
21:53:44 <acowley> 1.0.3
21:53:52 <acowley> phew
21:54:15 <Axman6> i had bumped my own local OpenCL package to 1.0.3.0, which got chosen over your OpenCL 1.0.3, heh
21:54:29 <acowley> I wish cabal could support darcs and git in Build-Depends
21:54:33 <rwbarton> I'm following the "Yesod in Five Minutes" instructions but the "cabal install yesod" step is taking an hour
21:54:35 <acowley> Axman6: ah, sneaky!
21:56:44 <Axman6> success!
21:57:08 <Axman6> how do i stop it...
21:57:12 <acowley> rwbarton: the assumption was that you would accelerate yourself to near the speed of light after starting the cabal install, then drop out of warp to tutorialize yourself
21:57:17 <acowley> Axman6: gloss default is escape
21:57:39 <Axman6> hmm, all i get is beachball, but the animation continues
21:57:55 <Axman6> had to kill it :\
21:58:09 <acowley> what OS and was this from ghci or compiled?
21:58:23 <Axman6> how do you install gloss with the appropriate thing you mentioned earlier?
21:58:30 <Axman6> Lion, and ghci
21:58:46 <acowley> if you're on a mac, you want: cabal install gloss --flags="-GLUT GLFW"
21:58:57 <Axman6> ah, thanks =)
21:58:59 <acowley> and I do some funny business with ghci
21:59:08 <acowley> you need the no-sandbox thing as mentioned on the gloss page
21:59:39 <acowley> In fact, I have this in my .emacs: (setq haskell-program-name "ghci -fno-ghci-sandbox -framework Carbon")
21:59:53 <Axman6> hmm, ok, i'll try that
22:00:03 <Axman6> i wonder if i have Carbon still...
22:00:20 <acowley> it's almost seamless, but I find that sometimes gloss-driven simulations don't reset when I stop and start them
22:00:26 <Axman6> didn't they get rid of carbon completely in Lion?`
22:00:30 <acowley> Axman6: the laptop I'm on right now is running Lion and has Carbon
22:00:32 <NihilistDandy> Yup
22:00:37 <NihilistDandy> Oh, really?
22:00:50 <Axman6> acowley: hmm, how does that work with 64 bit GHC?
22:00:52 <acowley> well, either it has Carbon or that flag isn't doing anything
22:01:34 <acowley> Axman6: I have no idea! I'm running a 64 bit GHC, though
22:01:46 <Axman6> how odd!
22:02:09 <Axman6> maybe it's not needed at all, but the linking is done lazily... and since it's not needed, you never find out that Carbon is 32 bit only
22:02:14 <acowley> These are the kinds of things I try to not know anything about. If it's working, I kind of don't want to know why :/
22:02:19 <acowley> Axman6: that's entirely possible
22:02:36 <acowley> Well I definitely have a Carbon.framework
22:02:49 <copumpkin> omg new zoom-cache
22:03:29 <Axman6> hmmmm, how did you install glfw? i just did it with homebrew, and only got a .a, no .dylib
22:04:14 <acowley> ah yes
22:04:20 <acowley> that is a ridiculous wart
22:04:31 <acowley> I've done it two ways, but the problem is that homebrew builds the dylib then deletes it
22:04:39 * Axman6 goes to get some water, because it's really hot@!
22:04:43 <acowley> because on OS X you don't install dylibs into system directories or something :/
22:04:46 <Axman6> urgh -_-
22:05:10 <NihilistDandy> acowley: Really? I have lots of dylibs in /usr/local
22:05:19 <acowley> you can either build GLFW yourself, and install the dylib like a sane person. Or build the GLFW-b package form hackage yourself, and find the dylib in some directory like build
22:05:38 <acowley> NihilistDandy: I don't understand it, it's just what I read when I was searching for a solution to the same problem.
22:05:46 <NihilistDandy> Weird
22:06:14 <acowley> NihilistDandy: When I didn't have the dylib from brew, I built from source and there was the dylib. Then I found a bug report thread discussing the issue, and saw the claim that the dylib should be packaged with the application, not installed system-wide
22:06:28 <NihilistDandy> hmm
22:06:30 <acowley> I have my copy in /usr/local/lib
22:06:44 <acowley> I think the brew situation is pretty ridiculous
22:06:59 <NihilistDandy> It's odd that it does that with glfw
22:07:00 <acowley> but I haven't done anything to fix it uther than harumph and sigh to myself
22:07:08 <NihilistDandy> Everything else I've brewed has given me dylibs :/
22:07:17 <NihilistDandy> Very strange
22:07:18 <Axman6> me too
22:07:21 <NihilistDandy> Harumph, indeed
22:08:24 <NihilistDandy> Seems there was a pull request to deal with it: https://github.com/mxcl/homebrew/pull/4448
22:09:25 <acowley> I'm not sure it was ever committed anywhere
22:11:15 <NihilistDandy> It doesn't seem so
22:11:22 <NihilistDandy> But the diff is mildly instructive
22:11:43 <augur> salisbury!
22:11:55 <salisbury> augur!
22:12:01 <augur> sup
22:12:05 <augur> why did my paper inspire you
22:12:45 <salisbury> augur, well I hope I got the correct message from it
22:13:00 <augur> which was? :
22:13:00 <augur> :)
22:13:11 <xil> hi. Is there a monadic version of mapAccum like mapM_?
22:13:38 <salisbury> but I got from it that there is a very large number of syntactic possibilities for a given verbal construct
22:14:02 <salisbury> and therefore there must exist rules by which these words can be combined, to eliminate some of these possibilities
22:14:20 <Axman6> xil: foldM?
22:14:57 <salisbury> which got me thinking that I have a viterbi part-of-speech tagger laying around my hard-drive
22:15:01 <xil> Axman6: aha. I see. Thanks =]
22:15:17 <augur> salisbury: well, thats not really what i was saying, but ok :)
22:15:48 <salisbury> yes, it was a bit (way) over my head, but It got me thinking about this
22:16:39 <salisbury> and I will soon have a large number of gigabytes of text, so I was thinking I could try to divine these rules and have a computational representation of them by combining these two resources of mine
22:16:48 <augur> salisbury: in syntactic theory, there are a number of ideas that basically revolve around this notion: some sentences are good/grammatical not merely because they are well formed but also because building *them*, as opposed to some other sentence with the same words, is cheapest
22:17:07 <augur> so grammatical = well formed and cheapest
22:17:34 <NihilistDandy> Up with which I shall not put~
22:17:43 <augur> but what i point out is that knowing cheapness requires you to know cost, and knowing cost requires that you know all the ways you could have done things
22:17:52 <augur> and some times this is a severely intractable problem
22:18:23 <augur> but, i say, there's light at the end of this tunnel, because you dont need to do all that work after all
22:18:29 <augur> you can take shortcuts
22:19:07 <Axman6> acowley: so it seems just building glfw doesn't give me a .dylib either
22:19:49 <acowley> Axman6: You did the mac build?
22:19:53 <salisbury> hmm, yes. I was thinking though that given enough sentences with each word tagged with its part of speech, there would be a finite (and relatively small) number of frequent part-of-speech patterns
22:20:03 <acowley> make cocoa
22:20:05 <salisbury> (I'm not sure if that is what you mean)
22:20:36 <Axman6> acowley: got it working, but not from ghci. compiled works wine, if i go -framework OpenLc -framework Cocoa
22:20:39 <Axman6> C*
22:20:42 <Axman6> CL* even
22:20:58 <acowley> huh, I don't have to do either of those
22:21:15 <salisbury> and, if each word is represented by a node in a graph-database or some such, relationships could be made between these word-nodes in a meaningful way based on these patterns
22:21:19 <Axman6> uses 500% CPU
22:21:59 <acowley> Axman6: you can have enough CPU to recompute all those sines and cosines :)
22:22:18 <acowley> Axman6: do you have a GPU that could work?
22:22:19 <Axman6> heh
22:23:40 <salisbury> It's rather difficult to explain exactly what I mean,  but that's a rather quick view of what I was thinking
22:23:56 <acowley> It's weird that when I compile I don't need to supply any frameworks. I figured the framework was getting pulled in by the opencl package, so the end application doesn't need it
22:24:14 <acowley> and maybe the cocoa thing is because my computer is weird and unnaturally helpful
22:24:54 <salisbury> augur I also found your context-sensitive grammar articles really interesting @ augury
22:26:51 <acowley> Bleh, I was going to try testing the demo in a linux virtualbox, but the Intel OpenCL SDK is 64-bit only and that virtual machine is 32-bit
22:26:59 <Axman6> acowley: just made the change, and it seems to use less CPU. can't notice any effects to the rendering performance either
22:27:11 <acowley> gloss limits the rate
22:27:45 <acowley> it should be substantially less CPU since all it's doing now is shuttling data GPU -> CPU -> GPU
22:28:14 <acowley> which, again, should make the optimizer inside you cry
22:30:01 <augur> salisbury: no thats not what i mean at all. :)
22:30:15 <Axman6> acowley: indeed :\
22:30:38 <augur> salisbury: the opening example of a configuration space captures it perfectly: you can put together the strings "a", "b", and "c" in two different ways to form the string "abc": ("a" ++ "b") ++ "c" or "a" ++ ("b" ++ "c")
22:31:28 <augur> and if there is a cost assigned to each way of putting the string together, maybe a DIFFERENT cost, then in order to know how much "abc" costs, you have to know what those different ways of forming it are
22:32:07 <acowley> Axman6: by default animate is clamped at 50Hz
22:32:20 <Axman6> oh woah, it looks like instruments now supports performance counter monitoring
22:34:17 <acowley> one my favorite tools on OS X is the OpenGL Profiler, but I've not done anything with Instruments. I hope it becomes a new favorite!
22:34:39 <Axman6> i find instruments often very hard to use.
22:35:13 <acowley> I really wish this computer had more than 2GB of RAM
22:35:14 <Axman6> the way you profile C functions is less than obvious (you don't use the obvious library item)
22:35:17 <Axman6> D:
22:35:49 <acowley> the frustrating thing is that this laptop takes DDR-2 which is more expensive than DDR-3, and it maxes out at 3GB
22:36:05 <Axman6> lame :(
22:36:05 <acowley> Axman6: so Time Profiler isn't a time profiler?
22:36:32 <salisbury> augur, I do suppose I am focus a bit more on that "abc" in fact nothing being "bca" or some other combination
22:36:38 <salisbury> focusing*
22:36:45 <Axman6> that may be the one you do need, i forgot what i was using that didn't work very well. maybe they removed it
22:36:50 <augur> salisbury: right, thats a different issue :)
22:36:58 <augur> well no its actually related, salisbury
22:37:10 <augur> because suppose "abc" cost at least 1
22:37:20 <acowley> when my disk stops swapping, I will try it
22:37:21 <augur> but suppose that "bca" costs at least 2
22:37:29 <The_Journey> hi, what is the function to put a string to the console without putting a newline?
22:37:41 <acowley> augur: why do you say you must be able to enumerate possibilities to define cost?
22:37:42 <augur> then in these theoreis, "bca" is well formed, but not grammatical, because its not the cheapest thing you can build with "a", "b", and "c"
22:37:57 <acowley> The_Journey: putStr
22:38:14 <salisbury> ahh, yeeess
22:38:22 <augur> acowley: well, it depends on how the cost is measured. in this particular case, it's usually measured by assigning a cost to each individual operation you use to build the thing
22:38:29 <augur> and the cost of each operation depends on the order
22:38:51 <salisbury> I see what you mean :D
22:40:50 <salisbury> so what could cause ("a" ++ "b") ++ "c" to be higher cost that "a" ++ ("b" ++ "c")?
22:41:32 <augur> well, im just using that as a way of communicating the idea
22:41:37 <augur> in linguistics its not so simple
22:43:59 <salisbury> but certain syntactic constructs are more costly that others generally, for some reason or the other, correct
22:44:09 <salisbury> ?
22:44:53 <acowley> Axman6: Time Profiler is telling me 73.1% of my time is spent in OpenCL (everything running on the CPU)
22:46:31 <augur> salisbury: yes
22:46:35 <Axman6> i can't get instruments to run it for some reason
22:47:05 <acowley> I attached to the process after starting it myself
22:47:12 <acowley> that was with an -O2 -fllvm build
22:47:23 <augur> salisbury: ok so basically the way we model the construction of phrases is by two processes: merge, which takes two previously unused pieces and puts them together to form a new (unused) piece
22:47:43 <augur> and move, which takes at least one previously used piece and puts it together with another piece to form a new (unused) piece
22:50:11 <augur> salisbury: and some models say simply: merge is free (costs 0), while move costs as much as the reused items are deep. so if you reuse something that's 3 nodes deep, then that costs 3
22:50:56 <mgsloan> an interesting thing is if you can make low cost approximate good design as much as possible
22:51:47 <augur> salisbury: for example, suppose you're going to build the tree ((a,b),(c,b)) from the elements a, b, and c. if you build (a,b) first, then build (c,b), you have to dig 1 node into the currently-built (sub)trees to find b
22:52:01 <augur> so building (c,b) costs 1, if you've already built (a,b).
22:52:17 <augur> but if you built (c,b) first, then its free, but subsequently building (a,b) costs 1 for the same reason
22:52:42 <augur> but now what if you're trying to build the tree (((a,b),d),(c,b))
22:52:45 <mgsloan> I'm not 100% the theory behind this is true, but the way I sometimes describe haskell to people, is that it gives you more freedom to partition your code.  It should be possible to mechanically extract an arbitrary partitioning of the expression tree, creating two functions
22:53:02 <augur> so just like the previous one, but with an extra node above (a,b)
22:53:30 <augur> if you build (c,b) immediately after you build (a,b), then it still only costs 1, but if you wait until after you've build ((a,b),d) then it costs _2_
22:53:40 <augur> because now you have to dig 2 nodes into that tree to find b
22:54:16 <salisbury> This might seem an odd question, but are these build costs applied to computers, the human brain or both?
22:54:20 <nexion> hey guys.. I'm looking for a data type representing an 8-bit integer to indicate a message type in the network protocol and I'm not sure if I should be using Data.ByteString.Char8 or Word8
22:54:27 <augur> so now it matters very much what _all_ of the different ways are that you could build a tree
22:54:47 <augur> salisbury: neither. they're just a mathematical model that attempts to capture certain facts about language
22:54:55 <acowley> nexion: Word8
22:55:42 <augur> well, salisbury, actually i suspect some syntacticians like these models because they think its the sort of things brains would do
22:56:03 <augur> mostly because the way they're described hides the computational cost of actually doing this sort of thing
22:56:24 <augur> people usually describe these things as "don't move something unless you absolutely have to in order to build a well formed tree"
22:56:50 <nexion> acowley, in which case would I want to use the former?
22:56:59 <augur> or "do the smallest movement (where merge is a degenerate movement of length 0) you can in order to build a well formed tree"
22:57:00 <kmc> nexion, you should never use Data.ByteString.Char8
22:57:06 <kmc> note that it's not defining a new type
22:57:07 <acowley> nexion: when dealing with ASCII characters
22:57:21 <kmc> it's defining new functions for working with ByteStrings
22:57:29 <kmc> functions with misleading types which do the wrong thing on almost all inputs
22:57:29 <augur> salisbury: so people see these words "don't ... unless" and "shortest", etc. and think, "ahh! surely that's just the brain being lazy! makes sense!"
22:58:01 <augur> but the point of my paper is to point out that these models are actually not even remotely computationally tractable in the naive form people give to them
22:58:16 <nexion> hm.. good thing I asked
22:58:19 <augur> and so any claim about "economical behavior" is nonsense without further work
22:58:35 <salisbury> yes, I definitely agree with that!
22:58:39 <nexion> I saw Char8 being used in some example a while ago and currently use its' pack and unpack functions
22:58:47 <salisbury> you've presented a good case
22:58:48 <nexion> what should replace those?
22:59:08 <kmc> nexion, ByteStrings contain bytes, not characters
22:59:16 <augur> salisbury: im actually looking into fold fusion to see what i can learn to do
22:59:34 <kmc> if you want to pack a list of bytes, i.e. [Word8], use Data.ByteString.pack
22:59:36 <acowley> I still think Char8 is fine if you know you're dealing with strings of ASCII characters. If there's even the hint of a possibility of non-ASCII, then you jump to Text.
22:59:57 <kmc> if you want to store text, ByteString is the wrong type.  use Data.Text
22:59:59 <nexion> for this project, I've moved to Text
23:00:00 <salisbury> augur, let me ponder something for a second. I may make a paste to try to ask a question that is proving difficult to word
23:00:01 <kmc> from the 'text' package
23:00:05 <acowley> But if I'm parsing a file format that specifies ASCII text, then ByteString.Char8 is faster than Text afaik
23:00:17 <salisbury> (so that I may use text diagrams)
23:00:18 <augur> because given just a tree, you can build the configuration space (the space of all possible choices you couldve made) using a fold, and from the configuration space, you can use a fold to compute the cheapest derivation (the sort of thing you would say should really be done using dynamic programming)
23:00:35 <kmc> if you want to convert between Text and ByteString, with respect to a particular character encoding, using Data.Text.Encoding
23:00:48 <kmc> (or the text-icu package if you have to support a weird encoding)
23:01:00 <augur> salisbury: so i figure that if this is true, fold fusion should make it possible to short circuit the construction of the configuration space entirely, and go from trees right to cheapest cost very easily
23:01:16 <nexion> that answers my questions :)
23:01:17 <nexion> thanks
23:01:21 <kmc> no problem :)
23:01:24 <acowley> nexion: ByteString.Char8 was used mostly before Text came along. ByteString was deservedly very popular, and people wanted to use it in place of String to relive their C string glory days.
23:01:39 <kmc> yeah those foreigners should just learn to speak english ;)
23:01:47 <acowley> exactly
23:02:21 <acowley> just stare blankly at anyone who asks for a funny character until they leave you alone
23:02:31 <acowley> that technique served programmers well for many years
23:02:39 <salisbury> augur, I'm trying to draw these trees using slashes.. this may take a few mins
23:02:44 <augur> lol
23:02:49 <augur> php syntax tree man
23:03:12 <salisbury> whoa
23:03:36 <kmc> w̚h̡a̅t̶ ͥdͯo͚ ͬy̟o͟u͜ ͚m̌e͚a͏n̵,͗ ͐f̡u̴n͕n͗y̔ ͪc̝h̑ảŗa̰c̵t͝e͖r͚sͬ
23:03:43 <kmc> @where zalgo
23:03:44 <lambdabot> import Random;main=mapM_((>>(י=<<randomRIO('̀','ͯ'))).י)=<<getContents;י=putChar
23:04:06 <Veinor> haha
23:05:23 <hpaste> Zarathu pasted “Splitting string” at http://hpaste.org/55642
23:05:38 <Zarathu> Trying to figure out an error in a really simple program...
23:05:56 <Zarathu> Couldn't match expected type `[Char]' with actual type `Maybe String`
23:06:06 <Zarathu> In the expression: ss
23:06:56 <salisbury> ok.. this isn't quite working. I'll try to explain instead.
23:07:31 <salisbury> Could it not be that properties of the words themselves can contribute to the cost
23:07:52 <ski> Zarathu : replace `filter isJust' by `catMaybes' ?
23:07:53 <augur> salisbury: it could be. but that would be a different theory. :)
23:08:00 <ski> @type filter isJust
23:08:01 <lambdabot> forall a. [Maybe a] -> [Maybe a]
23:08:04 <ski> @type catMaybes
23:08:04 <lambdabot> forall a. [Maybe a] -> [a]
23:08:29 <salisbury> and secondly, could sub-sentences (for lack of a better word) not be constructed in parallel and then combined
23:08:42 <Zarathu> ski: Ooh, didn't know about that.
23:08:48 <salisbury> that way, each sub-sentence concatenation can be treated as a merge again
23:09:10 <ski> @index catMaybes
23:09:10 <lambdabot> Data.Maybe
23:09:28 <The_Journey> is there a standard "get next to last element" of a list function?
23:09:30 <augur> salisbury: well, we dont view subsentences as being something specially -- theyre just trees inside bigger trees
23:09:44 <augur> but they cant be completely independent, of course, because they interact
23:09:56 <augur> in fact, most of the use for this is precisely in how subsentences interact
23:10:30 <sattar> The_Journey: http://www.haskell.org/haskellwiki/99_questions/Solutions/2 here you go
23:10:41 <sattar> there's no standard way
23:10:55 <Zarathu> ski: Worked beautifully. Thanks a ton.
23:11:16 <hpaste> Zarathu pasted “Splitting string” at http://hpaste.org/55643
23:11:20 <Zarathu> :)
23:11:22 <ski> > last ((zipWith const `ap` tail) "abcd")
23:11:23 <lambdabot>   'c'
23:11:27 <acowley> Axman6: I implemented the sine/cosine precomputation and it is smoother on my janky laptop
23:11:47 <ski> The_Journey : ^ that's one way
23:11:55 <salisbury> does it have to be a different theory, could the two not contribute simultaneously
23:12:08 <sattar> Is there any function with thsi signature: Monad m,n => m a -> (a -> n b) -> n b
23:12:44 <ski> sattar : no standard one, i think -- i've pondered that signature, though
23:12:46 <augur> salisbury: they could, but that would still be a different theory than the one we have now
23:12:50 <sattar> Hoogle does not come up with anything
23:12:54 <ski> sattar : which application did you have in mind ?
23:13:07 <salisbury> oh, yes true
23:13:19 <salisbury> haha, I didn't think of it that way
23:13:35 <sattar> I have an app that uses the -p 3000 command line parameter
23:13:42 <sattar> I need to get that 3000
23:14:16 <sattar> I used getArgs >>= elemIndex >>= (\id -> id+1)
23:15:01 <sattar> getArgs gives me IO [String], elemIndex gives me Maybe String,
23:15:55 <ski> @type elemIndex
23:15:56 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
23:16:12 <ski> it wants two arguments
23:16:30 <sattar> I just gave you the structure
23:16:40 <Axman6> acowley: good to know :)
23:16:45 <ski> sattar : but you might be better of using a real command line option parser
23:17:00 <sattar> Here's what I'm actually doing: getArgs >>= (\args -> (elemIndex "-p" args) >>= (\id -> warpDebug (args !! (id+1)) Ilm))
23:17:32 <The_Journey> how come putStr does not print to the string to the console right away? how can I make it do so? with _ <- putStr "fooBar"?
23:17:43 <ski> The_Journey : buffering
23:17:47 <sattar> Using a command line parser for just one flag seems a bit overweight
23:17:49 <ski> use `hFlush stdout'
23:17:50 <salisbury> augur, let me read about fold fusion. I've used map fusion before but I've never used fold in that way
23:18:32 <sattar> ski: is doing what I did considered bad practice?
23:18:38 <ski> The_Journey : alternatively change the buffering with `hSetBuffering'
23:19:05 <augur> salisbury: im not sure fold can be used that way actually. im still reading the details of various fusion methods to make sure it can :)
23:19:08 <ski> sattar : well, i don't think you need anything of type `(Monad m,Monad n) => m a -> (a -> n b) -> n b' here
23:19:33 <augur> but i pretty sure it can
23:19:49 <ski> sattar : if it's just for very a simple option, i suppose it's ok to do it manually -- but be sure to switch when you get more options
23:20:25 * ski wonders about what fusion augur is speaking of
23:20:41 <augur> ski: fold fusion!
23:20:51 <sattar> Yeah, but `(Monad m,Monad n) => m a -> (a -> n b) -> n b` is the only way to go here I think, I don't have any other ideas
23:21:01 <augur> ski: hinze, harper, and james give examples like
23:21:11 <ski> sattar : just use `case' on the result from `elemIndex' ?
23:21:15 <augur> sum . filter odd
23:21:20 <augur> being translated into a single fold
23:21:30 <ski> is that using `build'-`foldr' fusion ?
23:21:46 <augur> build has been mentioned but im not sure how it plays into this
23:22:02 <ski> @type GHC.Exts.build
23:22:03 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
23:22:17 <ski> the idea is to use a rewrite rule
23:22:34 <ski>   foldr cons nil (build builder)  =  builder cons nil
23:22:48 <augur> "The original shortcut fusion technique is a fold-centric approach called foldr/build fusion. As its name would suggest, its original intention was to provide fusion for list functions written in terms of foldr and an additional combinator build. In this section, we will explore the foundations of this technique."
23:22:49 <ski> this eliminates generating the intermediate list
23:23:01 <augur> beginning of section 4.3
23:23:05 <augur> er, 5.3
23:23:35 <sattar> ski: I thought of using case before, but since I'm still learning Haskell, I thought I would use Monads. Seems there is no way to use the monadic functions here. Thanks for helping me out
23:23:41 <ski> so, if `filter p xs' is defined as `build (\cons nil -> ...)' and `sum' is defined as `foldr (\n s -> ...) (...)', this rule will fire
23:24:03 <ski> sattar : well, you can use `case' and monads at the same time
23:24:37 <ski> augur : which paper is this ?
23:24:46 <augur> Theory and Practice of Fusion
23:24:55 <nexion> how can I convert from Int to Word32 and detect overflows?
23:25:35 <xil> hi. Is there a straightforward way to find the definitions for class functions for particular instances? Right now I'm interested in the definition of bind for the Maybe monad. But I'd like to be able to see others too
23:25:47 <Axman6> acowley: i got __local working in the kernel, to let tach work item compute the sin and cos values
23:26:07 <acowley> Axman6 I have a vectorized version of wave now, too
23:26:19 <Axman6> nice =)
23:26:21 <acowley> I had put sines and cosines in __constant and couldn't tell which was better between that and __local
23:26:25 <ski> which one of the three at <http://www.cs.ox.ac.uk/people/daniel.james/fusion.html> should i look at ?
23:26:39 <Axman6> i realised i'd beem running the whole thing on the CPU, which is why it was slow/using a lot of CPU =)
23:27:02 <ski> @src Maybe (>>=)
23:27:03 <lambdabot> (Just x) >>= k      = k x
23:27:03 <lambdabot> Nothing  >>= _      = Nothing
23:27:08 <Axman6> for this, __constant is probably better... but I'm not sure. hmm
23:28:08 <augur> ski: i dont even know
23:29:09 <Axman6> acowley: i do love that we can't seem to stop optimising this, even though the speed is capped at 50Hz :P
23:29:13 <nexion> I found fromIntegral, but it doesn't seem to detect overflows -- something using Maybe would be awesome
23:29:19 <nexion> Prelude Data.Word> let x = 300 :: Int
23:29:19 <nexion> Prelude Data.Word> fromIntegral x :: Word8
23:29:19 <nexion> 44
23:29:20 <Axman6> but it is a great way to play with OpenCL
23:29:27 <acowley> Axman6: yeah, I'm really enjoying it :P
23:29:51 <Axman6> acowley: how do you put something into constant memory anyway?
23:30:11 <acowley> just use the __constant qualifier on the formal parameter
23:30:17 <xil> I wanted to use the bind in the Maybe monad to easily quit from an event loop running in the IO monad. Doesn't look like that's going to be possible. Is that right?
23:30:18 <Axman6> ah, i see
23:30:21 <Axman6> makes sense =)
23:30:41 <c_wraith> xil: that's what MaybeT is for
23:31:01 <The_Journey> what is return usually used for?
23:31:18 <c_wraith> The_Journey: return is boring.  its type explains basically everything it does.
23:31:41 <xil> c_wraith: ah the *T types. I have to learn more about how that all works
23:32:12 <c_wraith> xil: basically, it embeds the behavior of one monad's (>>=) function into another's
23:33:41 <augur> ski: i think the last one
23:34:56 <Axman6> acowley: is there a KernelArg instance for CLMem? It would be great to move those constant parameters onto the GPU only once
23:35:25 <acowley> yes, CLMem is Storable and an overlapping instance catches it
23:35:34 <Axman6> excellent
23:36:21 <acowley> Axman6: I checked my optimized animation into github
23:36:47 <acowley> The main sacrifice to flexibility I made is to assume the number of angles is 7.
23:37:39 <Axman6> well, if you had a kernelWithFileAndCompileFlags, you could use -D to define things =)
23:38:07 <Axman6> i was somewhat surprised when i saw you could pass flags to the compiler, but it makes sense
23:38:09 <acowley> it's not the argument passing but the arithmetic unrolling
23:38:24 <acowley> rather than loop over the angles, I cram them all into float8s
23:38:34 <Axman6> ah, heh
23:38:43 <acowley> The magic line: float8 waves = (cos(cosines*u + sines*v + phase) + 1.0f) / 2.0f;
23:39:02 <acowley> full of implicit scalar->vector promotions and magic!
23:39:12 <Axman6> \o/
23:39:55 <acowley> I guess we could crank the resolution to make it slow again
23:40:07 <Axman6> i have tried that, worked fine :P
23:40:17 <Axman6> nice and smooth
23:40:45 <Axman6> it's interesting to see most of the time is spent copying memory, and not computation time
23:40:58 <Axman6> and vm_page_lookup apparently...
23:41:29 <acowley> isn't that often the story for gpgpu stuff, though?
23:41:39 <Axman6> yeah
23:41:57 <Axman6> saturating the compute units is the biggest issue usually
23:42:29 <Axman6> one way i've found to do it at work is to just make sure there's lots of threads using the GPU at the same time. but this is less than ideal when your GPU doesn't have 3GB of RAM
23:43:17 <acowley> CPU threads or GPU threads?
23:43:24 <Axman6> CPU
23:43:31 <acowley> if it's more of the same kind of load, won't you still be IO limited?
23:43:40 <Axman6> the code in question was the malecular dynamics program NAMD
23:44:27 <acowley> did you need to pull the data off the GPU for any reason at rate? The usual thing is to take a quantum entanglement approach and assume that the answer was computed on the GPU without explicitly looking at it.
23:44:30 <Axman6> acowley: well, i seemed to get better GPU utilisation anyway. i haven't looked closely into the memory characteristics, mainly because i'm researching power usage, not GPU performance as such =)
23:44:44 <acowley> How are you measuring GPU usage?
23:45:24 <Axman6> using the nvidia-smi tool, it gives you GPU utilisation
23:45:35 <Axman6> as well as memory usage, and tells you what processes are using the GPU
23:47:40 <Axman6> um, :info is supposed to work on types and classes right?
23:47:46 <Axman6> because it doesn't in my ghci
23:48:40 <shachaf> Axman6: What version is your ghci?
23:48:55 <Axman6> 7.2.1
23:49:05 * hackagebot text 0.11.1.11 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.1.11 (BryanOSullivan)
23:49:07 * hackagebot aeson 0.4.0.1 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.4.0.1 (BryanOSullivan)
23:49:09 <shachaf> Oh, well, I don't know about 7.2.1. In earlier versions it works fine.
23:50:37 <acowley> Well the OpenGL Driver Monitor shows me some things, but I haven't found anything too informative
23:50:55 <Axman6> acowley: any reason clContext etc isn't exported in CLUtil? it means i have no access to the context, so i can't use the vectorToBuffer function :\
23:51:23 <The_Journey> say I want to write a console program that interactively stores user input in a list and then display the entire list each time, how would I go about that?
23:52:11 <Axman6> The_Journey: you could use a State monad, or even better, StateT [input] IO a
23:52:13 <The_Journey> how do I keep the list persistent? every IO example I have seen uses main recursively
23:52:25 <xil> > :t (>>)
23:52:26 <lambdabot>   <no location info>: parse error on input `:'
23:52:30 <xil> :t (>>)
23:52:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
23:52:35 <Axman6> The_Journey: use recursion
23:52:42 <acowley> Axman6: oversight/bug; fixed in repo now
23:52:57 <The_Journey> Axman6: can you show an example?
23:52:58 <Axman6> acowley: excellent. i'll upgrade and install.
23:53:47 <Axman6> The_Journey: foo lst = do { print list; item <- getItem; foo (item:list)}
23:54:41 <The_Journey> Axman6: and how would I use that in conjunction with main = ?
23:54:50 <Axman6> The_Journey: main = foo []
23:55:31 <salisbury> augur, this is all very interesting. I think having a large database of sentences would be useful
23:55:43 <augur> salisbury: ?
23:55:54 <xil> which get's evaluated last, ($) or (>>=)?
23:56:24 <Axman6> xil: it doesn't matter... do you mean how are they parsed?
23:56:39 <salisbury> augur: there must be rules prohibiting certain concatenations, for example
23:56:56 <xil> Axman6: I have a bind on the right side of a $ and want to make sure the entire right side is processed before the $ gives the result to its left side
23:57:00 <salisbury> well, not *must* of course
23:57:06 <salisbury> but it is possible, no?
23:57:38 <augur> salisbury: im not sure what youre saying
23:58:02 <The_Journey> Axman6: is the do { } the same as do without the braces and the semi-colons?
23:58:28 <Axman6> The_Journey: yeah, it's just i prefer not to take up several lines on irc =)
23:58:54 <The_Journey> Axman6: what would be the type of foo?
23:59:07 <salisbury> well,  ("a" ++ "b") ++ "c" / "a" ++ ("b" ++ "c") stops being trivial as the tree gets larger
23:59:12 <Axman6> [Item] -> IO ()
23:59:21 <The_Journey> Axman6: ah ok, thanks
23:59:26 <salisbury> but, say, "a" ++ "b" was not allowed
23:59:27 <augur> salisbury: still not sure what youre suggestion
23:59:29 <augur> is
23:59:29 <xil> actually have to run. Don't worry about answering me Axman6 =]. I'll figure it out tomorrow
23:59:32 <xil> night everyone
23:59:52 <salisbury> then there is only the second possibility, with "b" ++ "c" first
