01:08:26 <_Mikey> @src toUpper
01:08:27 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
01:09:01 <alistra> tupperware
01:09:14 <_Mikey> hah
01:11:52 <Jafet> What do you call the argument to toUpper? A toUpee.
01:12:26 <sbi> uppable
01:13:28 <_Mikey> haha :P
01:13:36 <_Mikey> you guys are just too funny
01:18:24 <alistra> did you guys know, that mac laptops had the apples upside down 10 years ago (so it's upside down, when you have your lid open)
01:19:05 <luite> yes
01:19:08 <silver> no
01:19:09 <MHD> alistra: isn't that #haskell-blah material?
01:19:09 <_Mikey> no, thats pretty lol.
01:19:18 <_Mikey> gonna have to google images that/
01:23:04 <MHD> Any of you ever looked at D?
01:25:12 <_Mikey> I  looked at it briefly
01:25:32 <_Mikey> but it looked in its truest sense.
01:25:42 <_Mikey> I never even compiled anything.
01:30:07 <MHD> It is a pretty great thing.
01:30:38 <MHD> Digital mars basically went and said "Let's remake C++, but do it right this time around."
01:30:56 <MHD> And they did.
01:31:40 <MHD> Definitely one of my favorite languages along with Ruby and, well, this chanell's titular.
01:35:25 <lukish> @pl sum . map (\(x, _, _) -> x)
01:35:25 <lambdabot> (line 1, column 18):
01:35:26 <lambdabot> unexpected ","
01:35:26 <lambdabot> expecting operator or ")"
01:35:26 <lambdabot> ambiguous use of a non associative operator
01:35:30 <lukish> @pl sum . map (\(x, _, _) -> x))
01:35:31 <lambdabot> (line 1, column 18):
01:35:31 <lambdabot> unexpected ","
01:35:31 <lambdabot> expecting operator or ")"
01:35:31 <lambdabot> ambiguous use of a non associative operator
01:36:27 <MostAwesomeDude> Is there a typeclass for an incomplete enum?
01:36:34 <Jafet> Please don't hate C++. It's the best compromise between C and Ada 95.
01:37:03 <lukish> @pl (sum . map (\(x, _, _) -> x))
01:37:04 <lambdabot> (line 1, column 19):
01:37:04 <lambdabot> unexpected ","
01:37:04 <lambdabot> expecting operator or ")"
01:37:04 <lambdabot> ambiguous use of a non associative operator
01:37:17 <MostAwesomeDude> I have a byte which I want to make a type for. This byte can have values 0, 1, and 255. I want to have an Enum-like for this. Suggestions?
01:37:21 <lukish> Arrgh
01:37:44 <alistra> does it have pattern matching?
01:38:06 <Jafet> lukish: there is no combinator for \(x,_,_) -> x
01:38:20 <Jafet> Unsurprisingly, pl cannot express your code with combinators.
01:38:48 <MostAwesomeDude> alistra: Well, not yet. I'm building packet builders and parsers and was hoping for a type constraint.
01:39:24 <Jafet> Why not use Enum?
01:39:41 <Jafet> pred 1 = 0; pred 255 = 1; succ 0 = 1; succ 1 = 255
01:39:48 <MostAwesomeDude> Enum requires contiguous -- oh.
01:40:11 <MostAwesomeDude> That's...interesting.
01:40:18 <Jafet> data ZeroOneInfinity = Zero | One | OxFF deriving Enum
01:41:03 <ddarius> Ox0 Ox1
01:42:26 <lukish> Jafet: \(x,_,_) -> x cannot be writed pointfree?
01:44:08 <shachaf> lukish: It can given a combinator f (x,_,_) = x
01:44:20 <shachaf> How do you expect the pattern-matching to happen otherwise?
01:44:55 <lukish> shachaf: why that `f' is named `combinator'?
01:45:23 <shachaf> @google combinator
01:45:25 <lambdabot> http://en.wikipedia.org/wiki/Combinatory_logic
01:45:25 <lambdabot> Title: Combinatory logic - Wikipedia, the free encyclopedia
01:45:32 <Jafet> "Why do they call him the Rabbi?" "Because he is a rabbi."
01:45:39 <shachaf> The statement is still true if you use the word "function" instead of "combinator".
01:46:16 <shachaf> "Why do they call him the Rabbit?" "Because he is a rabbit."
01:46:43 <MostAwesomeDude> "Why do they call him the Fairy?"
01:48:20 <gwern> hadn't've'd't be a problem before
01:49:47 <mikeplus64> @pl wat
01:49:48 <lambdabot> wat
01:50:02 <alistra> @pl wut
01:50:02 <lambdabot> wut
01:50:16 <alistra> @pl lolwut
01:50:16 <lambdabot> lolwut
01:51:11 <gwern> @pl (lol `wut`)
01:51:12 <lambdabot> (lol `wut`)
01:51:17 <lukish> So, could combinators be written freepointly?
01:51:50 <mikeplus64> @pl What is this madness?
01:51:51 <lambdabot> (line 1, column 22):
01:51:51 <lambdabot> unexpected end of input
01:51:51 <lambdabot> expecting white space or simple term
01:51:57 <mikeplus64> @pl What is this madness
01:51:58 <lambdabot> What is this madness
01:52:21 <Cale> @pl \this -> What is this madness
01:52:21 <lambdabot> flip (What is) madness
01:53:04 <alistra> @pl \a b -> off b a
01:53:04 <lambdabot> flip off
01:54:06 <alistra> nobody noticed the joke :(
01:54:24 <mikeplus64> I noticed
01:54:37 <alistra> ^^
01:54:44 <mikeplus64> haha
01:55:51 <MostAwesomeDude> Ugh, GHC is not super-happy with the whole Enums-with-holes thing.
01:57:50 <rostayob> enums can't have holes in Haskell
01:58:15 <rostayob> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Enum
01:58:44 <MostAwesomeDude> rostayob: Yes, which is why I was asking about a better typeclass for this than Enum.
01:59:11 <rostayob> so you want something that with a single function (a -> Int)?
02:00:58 <ddarius> rostayob: Where in that link is something that says Enum instances can't have holes?
02:02:40 <rostayob> ddarius: succ is defined in terms of fromEnum and toEnum
02:02:59 <MostAwesomeDude> I want something which lets me constrain at the type level.
02:03:09 <ddarius> rostayob: Where do you see that?
02:03:38 <rostayob> ddarius: in the source? thinking about it i guess you can redefine it
02:03:49 <ddarius> rostayob: Yes, you can.  succ is a method of Enum.
02:04:28 <rostayob> ddarius: i still thought that Enum types should always be enumerable with ints
02:04:47 <ddarius> That would be nice, but it isn't even true of standard types.
02:05:10 <rostayob> ddarius: really? what's a standard type that's not enumerable?
02:05:15 <ddarius> Integer
02:05:22 <ddarius> And Float/Double.
02:05:33 <rostayob> oh right, because of the bounds
02:05:39 <MostAwesomeDude> Right, not Bounded.
02:05:59 <ddarius> And Rational.
02:06:57 <ddarius> MostAwesomeDude: Perhaps you should make an Enum that actually represents the semantics these three values have.
02:07:02 <MostAwesomeDude> But anyway, I want only two or three values to be legal, and I want something like toEnum and fromEnum for it. I was kinda hoping that there was something more built-in.
02:07:16 <MostAwesomeDude> ddarius: Well, I only have the names of the values, and the values themselves.
02:07:31 <rostayob> ddarius: btw, how does Enum work with Double/Float?
02:07:37 <rostayob> i can't picture that
02:08:29 <Jafet> > fromEnum 1.0
02:08:30 <lambdabot>   1
02:08:32 <Jafet> > fromEnum 1.5
02:08:33 <lambdabot>   1
02:08:36 <ddarius> It behaves like succ x = x + 1.0.  The end conditions for enumFrom(Then)To are strange and obviously it starts to fail when the exponent is large enough.
02:09:16 <rostayob> ddarius: oh ok... the had a wrong idea of what Enum represents
02:09:40 <ddarius> rostayob: Probably not completely.  Float/Double/Ratio probably shouldn't be instances of Enum.
02:09:49 <rostayob> yeah at least in my mind
02:09:53 <ddarius> But people really want to be able to write [1.0 .. 10.0]
02:13:26 <lars9> > (map fromInteger [1 .. 10])::[Float]
02:13:28 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
02:13:56 <rostayob> ddarius: wait but then the rules for .. are strange, because they're not only depending on Enum
02:14:10 <rostayob> > [0.1,0.2..2.0]
02:14:11 <lambdabot>   [0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.600000...
02:14:28 <ddarius> There are no rules for .., [x .. y] is just syntactic sugar for enumFromTo x y
02:14:57 <osaunders> enumFromThenTo in this case
02:15:05 <rostayob> right, but then the Enum class is kind of weird
02:16:05 <rostayob> if you can modify the enumeration behaviour with those functions
02:16:20 <rostayob> anyway, i guess it doesn't matter
02:16:43 <ddarius> You're not "modifying" the behavior.  There's no behavior to modify.  You are defining it.
02:17:46 <rostayob> ddarius: yeah it just looks strange to have that function in the Enum class
02:25:17 <r-g-w> hi
02:25:32 <hnoob> hi
02:25:41 <r-g-w> Short question:
02:25:51 <r-g-w> what does "import Control.Monad (MonadPlus(..))" exactly mean?
02:26:08 <r-g-w> does it mean that mzero. mplus, and MonadPlus are imported?
02:26:23 <Jafet> Import MonadPlus from Control.Monad, and all its constructors
02:26:28 <Jafet> @where cheatsheet
02:26:28 <lambdabot> http://blog.codeslower.com/static/CheatSheet.pdf
02:27:03 <r-g-w> ok
02:27:30 * hackagebot hopencl 0.2.0 - Haskell bindings for OpenCL  http://hackage.haskell.org/package/hopencl-0.2.0 (MartinDybdal)
02:27:50 <ddarius> MonadPlus isn't a constructor.
02:28:44 <Jafet> Yeah, I'm not sure why I said that
02:29:12 <Jafet> That syntax doesn't have any other meaning, though
02:29:44 <r-g-w> what does this mean now?
02:29:51 <r-g-w> its proper coding...
02:30:44 <ddarius> Jafet: Sure it does, why do you think otherwise?
02:31:57 <hnoob> Noob question (sorry if this channel is not the place) : why does the following line :
02:32:00 <hnoob> let str@s:_ = "hello" in (s, str)
02:32:07 <hnoob> return ('h', 'h') and not ("hello", 'h')
02:32:14 <_Mikey> :t (@)
02:32:16 <lambdabot> parse error on input `@'
02:32:46 <r-g-w> try let str@(s:_)
02:32:55 <rostayob> hnoob: because you're pattern matching 's' with the first character of the string
02:33:11 <_Mikey> no idea what @ is
02:33:13 <_Mikey> :(
02:33:25 <hnoob> thanks !
02:33:40 <rostayob> _Mikey: @ is to bind a variable to the non pattern matched argument
02:34:03 <r-g-w> Back to my question: MonadPlus is a typeclass, so which constructs shall be imported by (..) ?
02:34:11 <rostayob> > let f s@(c:_) = (s, c) in f "hello"
02:34:13 <lambdabot>   ("hello",'h')
02:34:14 <ddarius> r-g-w: All the methods.
02:34:25 <r-g-w> mzero and mplus?
02:35:24 <r-g-w> I supposed that "import Control.Monad (MonadPlus(..))" imports the TypeClass and its methods mplus and mzero... Correct?
02:35:54 <r-g-w> ddarius: Is this ok?
02:36:44 <ddarius> Yes.
02:40:07 <MostAwesomeDude> Hm. Is there a fixed-width floating-point type similar to Data.Word?
02:40:18 <ddarius> @hoogle Fixed
02:40:18 <lambdabot> Data.Fixed module Data.Fixed
02:40:18 <lambdabot> Data.Fixed data Fixed a
02:40:18 <lambdabot> Data.Text.Lazy.Builder.RealFloat Fixed :: FPFormat
02:41:34 <_Mikey> @hoogle Random
02:41:34 <lambdabot> System.Random class Random a
02:41:34 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
02:41:35 <lambdabot> package random
02:41:52 <_Mikey> :t RandomGen
02:41:53 <lambdabot> Not in scope: data constructor `RandomGen'
02:42:08 <_Mikey> :t System.Random.RandomGen
02:42:10 <lambdabot>     Not in scope: data constructor `System.Random.RandomGen'
02:42:13 <MostAwesomeDude> Hm, not quite what I wanted. I want a floating-point type which is always 32 or 64 bits wide, so that I can use it in serialization stuff.
02:42:19 <_Mikey> :t Random
02:42:20 <lambdabot> Not in scope: data constructor `Random'
02:42:23 <_Mikey> ;/
02:45:08 <aristid> :t random
02:45:09 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
02:45:16 <_Mikey> ahh
02:45:35 <_Mikey> how does one get a value which is of type IO a
02:45:42 <aristid> _Mikey: Random and RandomGen are type classes, not values. they thus have no type, and running :t on them is pointless
02:45:43 <_Mikey> and use the a in pure code?
02:45:56 <aristid> :t (>>=)
02:45:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:46:07 <aristid> :t fmap
02:46:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:46:09 <_Mikey> within a do{
02:46:11 <_Mikey> ?
02:46:30 <aristid> :t randomIO
02:46:32 <lambdabot> forall a. (Random a) => IO a
02:47:06 <_Mikey> So, if I take randomIO value, rand
02:47:12 <_Mikey> and do
02:47:25 <_Mikey> x >>= rand
02:47:34 <_Mikey> x should be of type a?
02:47:50 <_Mikey> cause I'm sure that hasn't worked for me in the past.
02:48:25 <aristid> _Mikey: uh, what?
02:48:42 <aristid> do x <- randomIO; JUST DO SOMETHING WITH x
02:49:08 <_Mikey> so x will be of type IO a
02:49:15 <aristid> no, x will be of type a.
02:49:16 <ddarius> http://hackage.haskell.org/packages/archive/fixed-point/latest/doc/html/Data-Fixed-Binary.html#Binary
02:49:35 <_Mikey> so I need to use <- and not bind.
02:49:45 <aristid> you can use bind.
02:49:46 <ddarius> MostAwesomeDude: Wait, do you want floating point or fixed point?
02:50:07 <aristid> randomIO >>= \x -> NOW HERE YOU CAN USE x TOO
02:50:54 <_Mikey>  ok, I'll try it out :)
02:51:15 <aristid> _Mikey: note that :t works in ghci, too.
02:51:44 <_Mikey> does >>= work?
02:51:45 <aristid> and in ghci there's also :info
02:51:48 <aristid> sure
02:51:51 <_Mikey> or is that just within do notation?
02:52:04 <`Zerax`> do is just syntactic sugar for bind
02:52:12 <aristid> no, do notation is translated into >>= by the compiler
02:52:48 <_Mikey> ok so in the interactive I can use >>=
02:53:50 <aristid> and do notation, too.
02:53:57 * ddarius is not sure where some false beliefs come from.
02:54:25 <aristid> ddarius: the mind can be random
02:57:19 <`Zerax`> I think until you understand how operations on monads work, it can seem a bit like hand waving.
02:58:54 <MHD> Always take a really close look at the type signature
02:59:02 <MHD> it can tell you a lot of things really
02:59:37 <`Zerax`> Sure does
03:00:06 <MHD> :t (>>=)
03:00:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
03:00:27 <MHD> _Mikey: Tell me what this ^ typesig means.
03:00:40 <MHD> _Mikey: if you want :)
03:01:04 <MHD> Actually, let me simplify it
03:01:24 <MHD> (Monad m) => m a -> (a -> m b) -> m b
03:01:45 <MostAwesomeDude> ddarius: Fixed-width floating-point. Big-endian IEEE 754.
03:02:02 <ddarius> MostAwesomeDude: What's wrong with Float and Double then?
03:02:49 <MHD> MostAwesomeDude: the specification is for Float and Double to be IEEE 754
03:03:13 <ddarius> MHD: That's not true, but it is true in practice.
03:03:45 <MostAwesomeDude> ddarius, MHD: I don't know if there's anything "wrong" with them. I just need types that are possible to serialize to the IEEE 754 spec.
03:04:11 <MHD> MostAwesomeDude: Float and Double are pretty safe bets
03:07:31 <ddarius> MostAwesomeDude: There's also CFloat and CDouble in the FFI modules, which are instances of Serializable and have whatever guarantees C gives for them.
03:08:04 <ddarius> s/Serializable/Storable/
03:08:23 <ddarius> Of course, Float and Double are also Storable.
03:08:34 <MostAwesomeDude> Storable? Ooh, a new thing.
03:11:04 <ddarius> http://hackage.haskell.org/packages/archive/data-binary-ieee754/0.4.2.1/doc/html/Data-Binary-IEEE754.html
03:12:48 <ddarius> http://hackage.haskell.org/packages/archive/cereal/0.3.4.0/doc/html/Data-Serialize-IEEE754.html
03:44:30 <relation_> can someone help me? i want to sort mutable vector under System.Random.MWC.Monad (Rand), the sorting algorithms are from Data.Vector.Algorithms.Intro.. do I miss something? is it possible?
03:47:35 <relation_> was able to do it like this (with generation of elements) (MWC.Variate a, PrimMonad m, Ord a) ⇒ MWC.Gen (PrimState m) -> m (Vector a), but i cannot figure out how to add State monad there.. answering this will be very helpful too, thanks
03:50:16 <relation_> or do it make a sense to create such an instance? instance (PrimMonad m) ⇒ PrimMonad (Rand m) where
03:50:35 <_Mikey> :t decrement
03:50:36 <lambdabot> Not in scope: `decrement'
03:58:49 <gwern> preflex: seen chrisdone
03:58:50 <preflex>  chrisdone was last seen on #haskell 4 days, 12 hours, 53 minutes and 37 seconds ago, saying: likeso http://hpaste.org/irc/haskell/2011-11-29/15-07-13/54684
04:02:30 <ddarius> Shouldn't the opposite of increment be excrement?
04:02:38 <elliottcable> ddarius: lol.
04:02:41 <elliottcable> ddarius: saw that joke the other day.
04:03:13 <elliottcable> I heard “Bicrement” for incrementing by two, which was pretty excellent
04:06:54 <DevHC> so i've heard like
04:07:11 <DevHC> syntax like: case _ of { ... }
04:07:21 <DevHC> to mean: \x -> case x of { ... }
04:07:25 <DevHC> is blarg
04:07:31 <DevHC> so how about:
04:07:39 <DevHC> casewise { ... }
04:08:33 <clsmith_> hmm. ghc isn't letting me import Data.Binary.Put, because it's "a member of the hidden package `ghc-binary-0.5.0.2'". how do i un-hide it?
04:08:51 <DevHC> ghc-pkg expose binary?
04:09:44 <clsmith_> <in which i discover it isn't actually installed>
04:09:52 <clsmith_> thanks ^^;
04:10:12 <clsmith_> really confusing error message that, though.
04:10:13 <Jafet> Maybe it's just hidden really well.
04:10:18 <clsmith_> lol
04:10:32 <DevHC> try ghc-pkg expose ghc-binary
04:11:09 <clsmith_> ghc-pkg: /var/lib/ghc/package.conf.d/: openBinaryTempFile: permission denied (Permission denied)
04:11:43 <DevHC> mr sudo can help ya
04:11:49 <Jafet> Install binary in ~/.cabal.
04:12:05 <clsmith_> yeah, i just cabal installed binary and it seems okay now
04:44:17 <_Mikey> let a >>= System.random
04:47:37 <tauntaun`> Saizan: the "missing information" idea in quantum mechanics is more technically known as "hidden variables."
04:49:10 <tauntaun`> Btw, these matters are glossed over in the conventional pedagogy in the US.  We are even told that at the quantum level, matter has the properties of both particles and waves, a misleading statement.
04:53:44 <Proge> waddup haskers
05:09:22 <relation_> please can somebody explain me, why the System.Random.MWC.Monad.Rand has two parameters (data Rand m a) instead of just one?
05:10:22 <gwern> relation_: I am guessing a is the kind of data - number, boolean, etc?
05:11:07 <gwern> relation_: if so, I would guess the m is for letting you slot in different kinds of monadIOs - regular IO, a monad transformer using IO, a fake IO with a seed for testing, that sort of thing.
05:11:07 <_Mikey> ooh
05:11:30 <_Mikey> I am failing at getting Random numbers into my program ;/
05:11:54 <gwern> saw a game once that used MonadIO IIRC - so you could plug in an AI function for the 2 players, or hook up a RNG as a player, or hook up a terminal and a AI, etc.
05:11:55 <Proge> random numbers don't exist
05:12:08 <Proge> not in your computer anyway
05:12:20 <gwern> Proge: but of course methods for producing them do :)
05:12:30 <Proge> no methods of creating the illusion do
05:12:48 <Proge> and i can't help you with that i'm affraid
05:12:52 * gwern frowns. that's not how the neumann quote goes
05:12:55 <Proge> unless its in c#
05:13:00 <Proge> then i could
05:13:10 <Proge> i'm a haskell noob
05:13:27 <gwern> 'Any one who considers arithmetical methods of producing random digits is, of course, in a state of sin. For, as has been pointed out several times, there is no such thing as a random number — there are only methods to produce random numbers, and a strict arithmetic procedure of course is not such a method. '
05:14:05 <Proge> is that from the bible?
05:14:16 <Proge> sounds like something jesus would say
05:14:23 <relation_> gwern: ok thanks, I try to formulate another question later
05:32:13 <_Mikey> can you have guards inside where?
05:34:05 <Yankovsky> Hey
05:34:08 <Yankovsky> I want to participate in open source project based on Haskell
05:34:14 <Proge> i want the world
05:34:15 * Phyx- stabs Proge 
05:34:15 <Phyx-> there only needs to be one world dominator
05:34:16 <Proge> i don't have a prob with that
05:34:16 <alex404> Can anyone tell me what ARR_WORDS are in my profile? I'm getting a space leak related to them somehow. In both my type and constructor profiles, ARR_WORDS allocation increases linearly with time, and in the cost centres it's in something called SYSTEM.
05:34:52 <_Mikey> Yankovsky, me too!
05:35:11 <_Mikey> Yankovsky, but I don't know enough.
05:36:11 <Yankovsky> ok, i am not haskell guru too
05:36:20 <Yankovsky> but i can do some simple jobs
05:36:32 <Yankovsky> like bug fixing and bug reporting)
05:36:46 <Yankovsky> i just want to do these in real world project
05:37:16 <Yankovsky> and i don't know where to find one
05:37:38 <_Mikey> Yankovsky, yea, that would be cool.
05:39:06 --- mode: verne.freenode.net set +o ChanServ
05:40:16 <Reaksiyon> Facebook IRC Application : http://apps.facebook.com/sohbetbook/
05:42:42 <_Mikey> amg. you made me go on facebook -.-
05:42:57 <_Mikey> there goes another 2 hours of my time ;/
05:45:13 <Yankovsky> so again
05:45:21 <Phyx-> wth is up with freenode
05:45:23 <Yankovsky> I want to participate in open source project based on Haskell
05:46:20 <Phyx-> Yankovsky: you don't really need to ask to participate, just go to a project' bug trac, like ghc, cabal, haddock etc, and start fixing things and submit back patches
05:46:34 <Phyx-> for the bigger projects, read the developer's guide
05:48:02 <byorgey> Yankovsky: what sort(s) of project would you be interested in working on?
05:48:21 <endojelly> alex404, played around with arrows now, they are pretty awesome
05:48:36 <endojelly> alex404, were you able to find the problem with yours?
05:48:38 <alex404> endojelly: Good to hear :)
05:49:01 <lars9> endojelly: how do you play with arrows?
05:49:11 <Phyx-> lars9: shoot em in the air and run around
05:49:12 <alex404> endojelly: I'm not sure what I remembered asking you, but theoretically things work now, I'm just getting space leaks
05:49:38 <alex404> endojelly: Arrows have been theoretically awesome for what I'm doing
05:49:43 <endojelly> lars9, pretty much like Phyx- says. or you could try implementing a few yourself %)
05:49:59 <Proge> ahhh just found out i can hide join and split msgs in a channel
05:50:03 <alex404> endojelly: Oh yah, I remember what I asked you. I figured it out... I'm just using a lot of things I don't fully understand, like arrow transformers
05:50:03 <Proge> thats better
05:50:11 <Phyx-> Proge: lol, yeah, handy isn't it :P
05:50:18 <Proge> very :)
05:50:22 <Phyx-> Proge: though sometimes, it makes this channel dead quiet
05:50:27 <Proge> perfect
05:50:29 <Phyx-> lol
05:50:46 <endojelly> alex404, I designed a kind of CPU emulator that only executes the exceptions needed by later instructions. it could also reorder them and attempt some parallelization or something. wouldn't be possible with monads, at least not as straightforward
05:50:59 <Phyx-> I have JOINS PARTS QUITS hidden myself
05:51:15 <Proge> i just right clicked the channel in xchat :)
05:51:18 <endojelly> the irc upgrades are over for today, anyway
05:51:25 <Proge> and checked hide
05:51:27 <endojelly> 15:09 [freenode] -Martinp23(martinp23@freenode/staff/martinp23)- [Global Notice] Wheeeeee. The main  part of this week's upgrades is done. Thanks for your patience and I hope you enjoyed the  ride... Our last round of ircd upgrades is next week, so don't miss the fun :)
05:51:28 <Phyx-> aha
05:51:36 <Proge> join / part msgs
05:51:38 <Phyx-> /ignore #haskell JOINS PARTS QUITS works too :)
05:51:45 <Proge> ahah
05:51:47 <Proge> lemme try
05:52:14 <alex404> endojelly: Yah, that sounds like something arrows are needed for. Did you work through Stephens arrow tutorial? That one I found to be pretty cool.
05:52:36 <Proge> xchat doesn't like to play with that command
05:52:46 <Phyx-> alex404: got a link? i need to get around to learning arrows...
05:53:04 <Proge> i can cope with quit msgs i guess
05:53:05 <endojelly> alex404, yes! it was pretty insightful
05:53:23 <alex404> Phyx-: These are the two I found to be the best: http://en.wikibooks.org/wiki/Haskell/Understanding_arrows
05:53:26 <Phyx-> Proge: hmm.. odd. yeah, it's already a significant reduction in noice
05:53:28 <Phyx-> noise*
05:53:33 <alex404> Phyx-: http://en.wikibooks.org/wiki/Haskell/StephensArrowTutorial
05:53:42 <Proge> yep :)
05:53:51 <alex404> Phyx-: The first is easy, the second does cooler things
05:54:09 <Phyx-> alex404: ty, i'll take a look
05:56:50 <endojelly> I would say the primary difference between Monads and Arrows is that with Arrows, I don't need to "execute" the function inside the Arrow to combine it? i.e. in Monads, bind is  m a -> (a -> m b) -> m b, which means that you can't get at m b until you pass the actual value, which is only available "at runtime"
05:57:50 <alex404> That sounds pretty good to me, actually
05:58:17 <endojelly> that's how I tried to justify why I was using an Arrow and not a Monad
06:01:09 <alex404> Yah, in my case, I'm fairly certain I could implement what I want in Monads, but the aesthetic separation between data and process fits what I'm doing much more nicely. Plus, all the synactic sugar with tuples is great.
06:01:15 <carpi> how would you go about splitting a list of even length into 2 halves?
06:01:16 <endojelly> also I feel that Arrows have some kind of "meta level" where things are fixed. I'd also liken that to "compile time" and "runtime".. for example, an arrow function which acts upon an Int could look like this: foo :: MyArrow Int Int. But I could also have a function bar :: Int -> MyArrow () Int, though that one sets the integer at "compile time"
06:02:12 <endojelly> alex404, yop
06:03:26 <endojelly> alex404, the only thing I don't really like is that I sometimes have functions of type MyArrow () SomeType, for example for getting a state, and I have to write x <- getfoo <- ()
06:04:16 <endojelly> I mean x <- getfoo -< ()
06:04:44 <endojelly> and that superfluous () is a bit ugly. some sugar to sweeten it away would be nice.
06:04:56 <alex404> Couldn't you just thread a state arrow through what you're doing?
06:05:05 <carpi> how would you write "div (length lst) 2" using the ($) function?
06:05:07 <alex404> That should allow you to throw away the ()
06:05:13 <carpi> "div $length lst 2" doesn't work
06:05:35 <endojelly> alex404, ah, and then I can combine arrow and monad sugar in one do-block?
06:06:21 <alex404> endojelly: I'm not sure, but I don't see why you need monads. I haven't actually used the StateArrow, but you should be able to write something like: x <- getState
06:06:23 <alex404> And that's it
06:06:23 <endojelly> alex404, hmm... wait, I think that wouldn't work in my case anyway, because getfoo isn't *just* affecting the state, but also stuff in the arrow structure itself
06:06:40 <alex404> And it's still an arrow computation, not a monad one
06:07:00 <endojelly> oh, didn't know there was a StateArrow already, I'll take a look
06:07:48 <carpi> how would you write "div (length lst) 2" using the ($) function?
06:08:42 <alex404> endojelly: Or wait, no, I see your point
06:09:11 <alex404> endojelly: What I said was wrong. With the arrowstate you'd still need something like x <- fetch -< ()
06:09:20 <alex404> endojelly: I was being silly.
06:09:26 <endojelly> alex404, ah, no problem
06:09:31 <endojelly> so there seems to be no sugar or something...
06:09:35 <tauntaun> carpi: flip div 2 $ length lst, maybe?
06:09:43 <alex404> endojelly: You DO seem to want to run monads and arrows together, which probably isn't possible :)
06:10:25 <endojelly> @pl x
06:10:26 <alex404> endojelly: But who knows. It seems unambiguous that x <- getState has to be a monad computation
06:10:32 <carpi> tauntaun: yes that works. Thanks .. but is it possible to do it without using flip?
06:10:52 <tauntaun> dunno...
06:10:54 <endojelly> alex404, yeah, but my "getfoo" is not just getting a state
06:11:08 <endojelly> alex404, it also signals in the arrow that this function *will* get state upon execution
06:12:11 <endojelly> alex404, the difference about "compile time" and "runtime" of the arrow I mentioned earlier... during execution of the arrow, it wants to know whether an attempt at "getting foo" will be made. it's really simple with arrows.
06:13:01 <endojelly> huh, where's lambdabot?
06:13:02 <alex404> endojelly: Yah, so you'll probably just need to feed it the (). With StateArrow in the arrows package, () has a more general type of e, that is, it takes some environment variables that you may want to provide
06:13:18 <alex404> endojelly: No environment variables means ()
06:13:30 <endojelly> oh okay. wonder what uses for that are?
06:14:33 <endojelly> fun thing is, I am actually writing something similar to "x <- getreg reg <- ()"... but it's crucial that the "reg" to get the state from ist *not* determined by the arrow input, but, well, statically
06:15:24 <alex404> endojelly: Of course, that's a big part of arrows.
06:15:47 <endojelly> it's why they're so great, yes 8)
06:16:49 <endojelly> so, now I wonder, what are particularly interesting Arrows?
06:17:24 <endojelly> I think I'm too unimaginative. most of my attempts end up at being some form of state Arrow or another %)
06:17:45 <endojelly> I thought the parsers from the first tutorial were interesting
06:20:06 <alex404> Personally, I'm not thinking too deeply about it. I mean, I read somewhere that arrows were simply a generalization of monads... if your arrow instantiates ArrowApply, then your arrow is mathematically equivalent to a monad...
06:20:15 <alex404> That being said, I just like the style and syntactic sugar
06:20:46 <endojelly> but what about interesting Arrows that aren't Monads?
06:21:06 <alex404> Well the exception thing you described is a case, isn't it?
06:21:22 <endojelly> yeah, and I'm wondering what else there is
06:21:27 <endojelly> freaky stuff %)
06:21:57 <alex404> Yah, I'm not sure. If you look at the arrowspackage, they all (almost all?) seem to instantiate arrowapply
06:22:30 <zdod> How do I get cabal to see my ghc binary?
06:22:45 <endojelly> yeah, and I know most of those as Monads anyway...
06:22:54 <zdod> .cabal has a variable named $pkgid.  How is it defined?
06:23:04 <endojelly> although I'm not sure what that is: http://hackage.haskell.org/packages/archive/arrows/0.4.4.0/doc/html/Control-Arrow-Transformer-Automaton.html
06:23:16 <endojelly> and it doesn't seem to instantiate ArrowApply.
06:23:57 <byorgey> endojelly: that one is apparently quite interesting.
06:24:10 <byorgey> endojelly: you should ask mm_freak about it.
06:24:17 <alex404> That one is awesome
06:24:35 <alex404> I'm using it now
06:24:36 <byorgey> @hackage netwire
06:24:45 <alex404> Though it's less crucial then I thought it would be...
06:24:48 <endojelly> reading some stuff about mealy-style automata right now (which this apparently ist)
06:24:53 <alex404> Yah
06:25:02 <byorgey> http://hackage.haskell.org/package/netwire
06:25:04 <alex404> I'm pretty sure it's the same thing as Circuits in stephens tutorial
06:25:17 <endojelly> oh
06:25:29 <endojelly> a -> (b, a -> (b, a -> (b, ...)))
06:25:35 <endojelly> looks similar, yes
06:25:35 <alex404> aye
06:26:24 <alex404> I'm actually using a combination of Writer and Stream arrows
06:26:32 <alex404> (To get something very much like the Automaton)
06:26:38 <alex404> Now that I look at it
06:26:42 <endojelly> byorgey, thanks, but there's no documentation, apparently...
06:26:50 <alex404> I guess Stream doesn't instantiate arrowapply actually
06:26:54 <alex404> So maybe there's another key case
06:27:06 <alex404> The great thing about Streams is that you can implement loops in your circuit diagrams
06:27:18 <alex404> Which maybe aren't so easy to translate into Monads
06:27:23 <byorgey> endojelly: oh, there isn't? boo.
06:27:55 <alex404> Holy shit netwire!!
06:27:59 <alex404> Maybe that's exactly what I need!
06:28:06 <alex404> Crazy
06:28:26 <endojelly> byorgey, well, at least there aren't even links to the modules on the hackage page
06:29:10 <alex404> I'm using the arrows package, but getting hammered by space leaks...
06:29:21 <byorgey> endojelly: oh, I see, it didn't build on Hackage so it didn't build the docs
06:29:21 <alex404> Maybe this netwire thing has worked around some of those issues...
06:29:33 <endojelly> byorgey, aah.
06:29:51 <byorgey> alex404: I think perhaps it has, apparently the performance is quite good
06:29:53 <jchia> what happened to lambdabot? is it gone?
06:29:53 <endojelly> http://www.haskell.org/haskellwiki/Netwire
06:30:01 <endojelly> jchia, wondering that too
06:30:14 <alex404> byorgey: Super cool,thanks for the tip
06:30:14 <byorgey> @botsnack
06:31:33 <alex404> byorgey: Ah, I see, it's an FRP system. Is it supposed to be an especially good one?
06:31:50 <byorgey> Cale! I call upon you to lift us from our miserable existence sans lamdabot!
06:32:12 <endojelly> maybe it died in the netsplit. and has a grace period for reconnecting or something.
06:32:40 <luite> grace period for lambdabot usually means "until killed and restarted by admin" :p
06:32:45 <byorgey> alex404: I don't really know, but mm_freak has been actively working on it and seems to be quite pleased with it
06:32:47 <endojelly> heh
06:34:17 <alex404> byorgey: Cool
06:34:20 <Phyx-> d
06:34:24 <Phyx-> ah
06:34:27 <alex404> byorgey: Is mm_freak famous or something?
06:34:33 <bwright_> How do I retrieve a random element from a list?
06:34:42 <Phyx-> can someone hilight my name? trying to test something
06:34:53 <byorgey> Phyx-: no
06:34:57 <Phyx-> thanks :)
06:34:59 <Phyx-> works
06:35:00 <byorgey> =
06:35:03 <byorgey> =)
06:35:21 <byorgey> alex404: heh, define 'famous' =)
06:35:38 <endojelly> bwright_, heh. do you know the list's length? because then it becomes an easy tidbit rather than an interesting problem (which is not that hard to solve, however) ;)
06:36:37 <alex404> byorgey: ;P I just mean he's a well respected haskeller. I've known that what I'm doing is broadly FRP, but only now with my performance issues have I thought that I should perhaps use a library which directly supports it. But I don't want to learn the API for something rather half baked
06:36:52 <alex404> byorgey: Anyway, you've already said it seems good, so I'll give it a look
06:37:09 <byorgey> alex404: yes, mm_freak is a well respected haskeller.
06:37:10 <endojelly> alex404, how did you find out that you have space leaks? just profiling?
06:37:17 <alex404> endojelly: Yah
06:37:21 <byorgey> I haven't tried out netwire myself.
06:37:22 <alex404> byorgey: Cheers
06:37:24 <endojelly> ok
06:37:25 <luite> byorgey is a famous haskeller and he says it's good, so it must be!
06:37:33 <alex404> QED
06:37:33 <bwright_> endojelly: I just get stuck in impurity because I cannot assure that the return of a random will always be the same so I end up in the IO monad.
06:38:17 * byorgey makes mental note to be more careful what he says around luite
06:38:34 <endojelly> bwright_, well you will need the IO monad at least at your outmost layer, yeah. unless you want to use unsafePerformIO.
06:39:15 <bwright_> endojelly: I am trying to return an IO String in that case.
06:39:38 <bwright_> So how do I deal with the null case?
06:39:43 <alex404> I wouldn't say that you NEED the outermost to be IO
06:39:49 <alex404> You just need a seed
06:39:56 <alex404> Which of course should probably be random
06:40:36 <alex404> Personally, when it comes to writing things with randomness, I just deal with passing seeds around. I don't think about it in terms of them being IO functions
06:40:40 <endojelly> bwright_, the null case?
06:41:04 <endojelly> alex404, I like passing the random generator around, which basically boils down to the same stuff
06:41:17 <alex404> endojelly: Yah, either one
06:41:20 <hpc> bwright_: there's no "null" in haskell unless you try to handle it explicitly
06:41:31 <hpc> bwright_: for instance, using a Maybe type
06:41:33 <hpc> @src Maybe
06:41:41 <alex404> lambdabot is dead
06:41:45 <bwright_> null is a function in the standard prelude that evaluates to true when given an empty list.
06:41:45 <endojelly> (and, depending on the compiler, might boil down to very similar code in reality)
06:41:54 <hpc> data Maybe a = Nothing | Just a -- Nothing is your "null" here, if you decide to use it
06:42:00 <hpc> bwright_: ah, nvm then :P
06:42:36 <bwright_> I think my issue is with monads. I will have to actually look into that.
06:43:14 <alex404> bwright_: Do you not feel comfortable with monads?
06:43:20 <endojelly> bwright_, hmm. you could either write code that just doesn't handle empty lists (and throws an error at some point if you do pass an empty list), or use Maybe...
06:43:48 <mark_> marjthorpe
06:43:56 <ion> Long live lambdabot
06:44:01 <endojelly> bwright_, the latter solution will pretty quickly land you in the Maybe monad, however. so if it's viable to just disallow empty lists, I'd go for that.
06:44:17 <endojelly> (aka just don't do what you're going to do when the list is empty)
06:45:50 <carpi> is it possible to add elements from the tail in a list?
06:46:05 <bwright_> alex404: Yeh I am sort of getting to an understanding slowly.
06:46:07 <endojelly> carpi, like so? list ++ [ x ] ?
06:46:33 <carpi> endojelly: yes but that is super inefficient.. cos ++ has to traverse all of list before appending [x]
06:46:39 <alex404> bwright_: Just in case you don't know about it, 'Learn you a Haskell' is probably one of the best tutorial out there, and is a good place to learn monads
06:46:54 <endojelly> carpi, that's the problem with lists defined that way :(
06:47:00 <endojelly> carpi, you'd need another data structure
06:47:27 <Phyx-> sss
06:47:35 <endojelly> carpi, maybe a tree, maybe some kind of differential list, depending on what you want to do
06:47:52 <hpc> bwright_: be warned though: don't jump straight to the monad chapter; go through all the typeclass stuff first - those chapters are what make the monad chapter so great
06:47:52 <endojelly> carpi, http://hackage.haskell.org/package/dlist-0.4.1
06:47:57 <bwright_> alex404: Yeh I am trying to take a more mathematical approach to it with endofunctors and its special families of morphisms unit and join.
06:48:18 <carpi> thanks ill check that
06:48:24 <endojelly> carpi, but you really only need this if you want to append at *both* ends
06:48:30 <alex404> bwright_: Cool. Good luck with that.
06:48:33 <endojelly> carpi, otherwise just treat the list in reverse, and append to the front.
06:49:13 <carpi> endojelly: yea thought of that.. but it has unnecessary overhead costs.. reversing everytime i want to append to the tail
06:49:32 <endojelly> carpi, so you do want to append at both ends? dlist might be your solution, then
06:49:49 <carpi> looking at it as we speak thanks
06:51:31 <endojelly> carpi, ah, I forgot something: there's also Data.Sequence... that should be the most efficient
06:55:06 <carpi> i wonder why sequences are not the standard .. i mean its in prelude but only after making an import unlike lists
06:55:29 <endojelly> they are somewhat more complicated, using trees internally (as far as I know)
06:55:44 <endojelly> they are probably deemed too complex for the Prelude
06:55:48 <rick_> why does this give me an error? "True :: (Testable a) => a" (written in ghci with QuickCheck imported)
06:56:18 <hpc> sequences also conflict with a lot of list functions
06:56:22 <endojelly> rick_, what kind of error? and isn't True already defined as a constructor for Bool?
06:56:44 <rick_> Couldn't match expected type `a' against inferred type `Bool'
06:56:53 <rick_> a Bool should be Testable, right?
06:56:54 <hpc> rick_: True is a Bool
06:57:17 <hpc> rick_: it is Testable, but it's not forall a. (Testable a) => a
06:57:57 <hpc> rick_: you can imagine an intermediate step between "i need a Testable" and "this is a Bool" which looks something like
06:58:06 <hpc> rick_: True :: (Testable Bool) => Bool
06:59:15 <hpc> rick_: but that doesn't make sense to express in haskell because the compiler already knows what Bool is an instance of
06:59:27 <rick_> what I'm trying to do is to put a set of Testables in a list, then run quickCheck on them
06:59:56 <rick_> so I have a function like Testable a => [a] -> IO Bool
07:00:15 <Saizan> that's not the right type
07:00:15 <rick_> lets call it run
07:00:42 <rick_> then I want to do run [True, other testables]
07:00:43 <hpc> rick_: so you want a heterogenous list, then?
07:00:55 <rick_> what does that mean?
07:01:17 <endojelly> You might want something operation on [Maybe a] for example.
07:01:22 <endojelly> operating
07:01:31 <hpc> rick_: lists in haskell are normally homogenous, which means they hold things that are all of the same type
07:01:43 <hpc> rick_: so once you put a Bool in there, everything else that goes in has to also be a Bool
07:01:56 <rick_> and Testable are not of the same type?
07:02:28 <endojelly> no, there are a lot of different types that all belong to the type *class* Testable
07:02:30 <hpc> rick_: Testable is just a class; a bucket you can put types in
07:02:43 <rick_> I see
07:02:48 <hpc> (Testable a) => a -- this can describe lots of types
07:02:57 <rick_> thanks for explaining
07:03:19 <byorgey> rick_: I suggest using something like http://hackage.haskell.org/package/test%2Dframework
07:03:31 <hpc> rick_: what you think you want is a list of type [forall a. (Testable a) => a]
07:03:42 <byorgey> which gives you combinators specifically for dealing with this kind of thing
07:03:45 <hpc> rick_: but what you probably really want is advice from others who know more than me :P
07:03:52 <hpc> listen to byorgey ;)
07:04:06 <byorgey> yeah, don't make a heterogeneous list yourself.
07:04:17 <rick_> I guess I can convert all Testables to properties and put them in a list
07:04:35 <byorgey> rick_: yes, that's something like what test-framework does
07:05:00 <rick_> I'll look into that
07:05:46 <rick_> thank you all
07:07:34 <hpc> personally, instead of writing testAll [True, 1, Nothing, ...], I would write [test True, test 1, test Nothing, ...]
07:07:43 <hpc> which would then have the homogenous type [IO Bool]
07:07:52 <hpc> that might not fit your program
07:08:52 <Saizan> ?type property
07:08:55 <Saizan> meh
07:11:03 <Saizan> infixr 5 .:; x .: xs = property x : xs; main = testAll $ True .: 1 .: Nothing .: []
07:12:07 <relation_> if the function def is as follows: f ∷ (PrimMonad m) ⇒ MWC.Gen (PrimState m) → StateT String m Double, is it possible to generate number and modify state with by appending the number? i cannot figure it out
07:12:36 <relation_> where MWC stands for System.Random.MWC
07:12:51 <mreh> would it be futile trying to implement an instance of safecopy for Text.Blaze.Internal.Html?
07:13:02 <mreh> it uses existential qualification
07:13:52 <Proge> i wish i understood that
07:14:09 <mreh> Proge: what?
07:14:19 <Saizan> relation_: a Double?
07:14:19 <mreh> what don't you understand?
07:14:20 <Proge> existential qualification and safecopy
07:14:39 <Proge> new words to me
07:14:58 <Proge> i shall google
07:15:07 <relation_> Saizan: yeah, to generate a Double, and to modify state by appending that number to String state (it's silly, i know)
07:15:12 <Saizan> relation_: do n <- lift uniform; modify (++ show (n :: Double)); return n
07:15:15 <mreh> Proge: see GADTs
07:15:32 <Saizan> actually, the :: Double doesn't matter
07:15:38 <Proge> thanks
07:15:59 <Saizan> relation_: "modify (++ show n)" is not quite efficient though
07:16:48 <relation_> Saizan: thanks, i'll try it.. the efficiency issue, i know.. it will be applied in different place, thanks, i'm going to try it
07:17:10 <Proge> mreh added it to the queue
07:17:17 <Proge> i have much learning to do first
07:17:28 <endojelly> my thermostat is strange. 20.5° is too cold, 21° is too hot.
07:18:10 <Proge> could you explain whats its for in a sentance
07:18:12 <endojelly> maybe it's because it's installed next to the living room door (which leads into the unisolated hallway). I read you shouldn't do that.
07:18:26 <Proge> as in whats a practical use
07:18:30 <byorgey> endojelly: perhaps it is your body's perception of temperature that is strange.
07:18:43 <endojelly> byorgey, or that, yes
07:19:06 <Saizan> mreh: can you link to the definition?
07:19:38 <Proge> i was reading http://www.haskell.org/haskellwiki/GADTs_for_dummies
07:19:54 <Proge> but i need to learn about some of the concepts in it before i can understand it
07:20:49 <Proge> i need GADTs for people who don't know haskell
07:21:42 <hpc> Proge: what knowledge should we assume?
07:21:47 <Proge> c#
07:21:52 <Proge> regex
07:22:00 <Proge> sql
07:22:06 <hpc> ah
07:22:18 <ion> GADTs are a bit like tacos.
07:22:36 <hpc> ion: a burrito, but you can see what type you are getting?
07:22:38 <mreh> Saizan: http://hackage.haskell.org/packages/archive/blaze-html/0.4.0.0/doc/html/Text-Blaze-Internal.html
07:22:49 * hackagebot cabal-debian 1.5 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-1.5 (DavidFox)
07:23:05 <mreh> i see how it can be serialized
07:23:16 <mreh> i don't see*
07:23:32 <Proge> so something with more than one type?
07:23:41 <hpc> Proge: i don't know C# so ill use java syntax and hope it is similar
07:23:52 <hpc> Proge: imagine you had something like
07:24:16 <hpc> class DoubleFloat<T> {T item;}
07:24:19 <Proge> its very similar c# stole java i think
07:24:45 <hpc> Proge: you could make a DoubleFloat<Double> or a DoubleFloat<Float>
07:25:05 <hpc> Proge: but you could also make a DoubleFloat<AbstractStringBuilderFactoryInstanceFactoryBuilderBean>
07:25:05 <Proge> just two types?
07:25:08 <hpc> or something like that
07:25:17 <Proge> or more than one
07:25:21 <Proge> more than two sorry
07:25:23 <mreh> i love that meme
07:25:33 <hpc> Proge: so imagine you gave it two constructors
07:25:34 <mreh> it conforms to my prejudices
07:25:36 <Saizan> mreh: the quantified over types are never used as types of values, nor in typeclass contexts, so you could just unsafeCoerce your way through
07:25:41 <Proge> ah so more than two
07:25:44 <Proge> if the second one
07:25:47 <Proge> was already more than one
07:25:48 <hpc> DoubleFloat<Double>(Double t) {item = t;}
07:25:55 <relation_> Saizan: thanks.. now it's also working the other code.. thanks, i was really uncertain about how to do it.. i've tried a lot of combinations and it was this simple, thanks
07:26:00 <hpc> DoubleFloat<Float>(Float t) {item = t;}
07:26:17 <hpc> Proge: if those are the ONLY two constructors, you can't ever make a value of type DoubleFloat<AbstractStringBuilderFactoryInstanceFactoryBuilderBean>
07:26:20 <mreh> Saizan: what's their purpose?
07:26:28 <hpc> because no constructor has the right type
07:26:52 <hpc> Proge: that's basically what GADTs let you do, is make constructors for parameterized types, where you say WHAT the parameter type is going to be
07:27:01 <mreh> Saizan: and thanks.
07:27:04 <hpc> it's the "<Double>"/"<Float>" magic
07:27:58 <Proge> so am i right in thinking
07:27:58 <mreh> Saizan: I suppose to deduced that HtmlM a, for some a. never appears in the source
07:28:03 <Saizan> mreh: to ensure wellformedness of the html document i think
07:28:14 <mreh> you deduced*
07:28:23 <Proge> hpc: am i right i thinking :)
07:28:35 <Proge> hpc: that its like casting
07:28:56 <Proge> hpc: in c# you have to cast objects into different types
07:28:59 <Saizan> mreh: more that in the definition of HtmlM a, you see 'a' appear only as an argument to HtmlM
07:29:08 <Proge> hpc: before you can use them
07:29:35 <Saizan> mreh: and that the same goes for the existentially quantified b and c
07:30:17 <Proge> hpc: so if i had a float and wanted to use if for something that needed a double as a parameter?
07:30:58 <Saizan> mreh: i think you won't even need unsafeCoerce actually
07:31:06 <Proge> hpc: i could make a GADT? or have i completely misunderstood lol
07:31:45 <hpc> Proge: it's not so much about casting as about the guarantees the compiler can make
07:32:03 <hpc> gimme a sec to paste
07:32:13 <Proge> hpc: as in the cast will never fail
07:32:35 <Proge> hpc: because it can definitely be both types
07:32:35 <mreh> Saizan: thanks for the help
07:32:55 <hpaste> zdod pasted “can't cabal install snap” at http://hpaste.org/54851
07:33:10 <mreh> Saizan: i'll see how far I can get
07:33:25 <hpc> Proge: http://hpaste.org/54852 -- the most important part of this is the last line
07:33:32 <mreh> i don't see how all the as bs and cs won't be unified with () in the end
07:33:39 <hpc> namely, that it doesn't even COMPILE
07:33:59 <mreh> all the constructors of Html objects are of type HtmlM () it seems
07:34:08 <hpc> the GADT gives us a guarantee about what that 'T' could ever possibly be
07:34:15 <mreh> but that doesn't help me I suppose
07:35:53 <mightybyte> Anyone know what's up with this error?  http://hpaste.org/54851
07:36:26 <dcoutts__> mightybyte: linker being killed is almost always an out of memory error
07:36:37 <mightybyte> Ahhh
07:36:38 <mightybyte> Thanks
07:36:41 <dcoutts__> look at the memory use of ld during linking
07:36:44 <dcoutts__> it's enormous
07:36:47 <Proge> hpc: it doesn't compile becuse a string is not a type that contains a double and a float?
07:37:29 <hpc> Proge: not that it "contains", so much as that it "isn't"
07:37:39 <Proge> hpc: ah yes
07:37:44 <hpc> a String is not a Double or a Float, so the compiler goes "whoa now..."
07:37:47 <Proge> hpc: it isn't a double OR a float
07:37:56 <hpc> yeah
07:38:03 <Proge> hpc: thanks for that :)
07:38:10 <hpc> a GADT is kind of like a restriction you impose on yourself
07:38:15 <hpc> and the compiler is able to hold you to it
07:38:20 <Proge> hpc: my first haskell lesson
07:38:26 <hpc> congrats
07:38:44 <Proge> hpc: sounds useful
07:38:56 <Proge> hpc: cuts down on runtime debugging
07:39:16 <Proge> hpc: of things that i currently call just objects
07:39:37 <Proge> hpc: so i could have a list of strings and ints
07:39:46 <Proge> hpc: that the compiler would erro
07:40:04 <Proge> hpc: r if i put a float in
07:40:39 <Proge> hpc: because i'd have a dadts of stringints
07:40:49 <Proge> hpc: gadts
07:40:51 <elliott> Configuring transformers-base-0.4.0.1...
07:40:51 <elliott> cabal: The program ghc version >=6.4 is required but the version of
07:40:52 <elliott> /usr/bin/ghc could not be determined.
07:40:52 <elliott> $ /usr/bin/ghc --version
07:40:52 <elliott> The Glorious Glasgow Haskell Compilation System, version 7.0.3
07:40:52 <elliott> wtf?
07:41:02 <Proge> hpc: and a list of them
07:41:04 <elliott> argh, that split lines on paste that weren't split in my terminal...
07:42:34 <hpc> Proge: that's definitely possible
07:42:45 <Proge> hpc: woohoo magic powers
07:43:19 <dcoutts__> elliott: if you use configure -v3 it'll show what it gets from ghc --numeric-version
07:43:23 <Proge> hpc: i think i'm starting to understand functional programming
07:43:32 <elliott> dcoutts__: it worked when I installed transformers-base explicitly instead of via monad-control :/
07:43:40 <elliott> dcoutts__: so too late I'm afraid, but thanks for future reference
07:43:42 <Proge> hpc: its designed not to break at runtime
07:43:56 <elliott> Proge: That's more "functional languages with strong type systems" than functional programming in general :)
07:44:06 <dcoutts__> elliott: I'd be surprised if it was related to what you were asking to install
07:44:17 <hpc> Proge: that's a property of strong static types than... yeah what elliott said
07:44:44 <hpc> Proge: "static types" essentially means "types are known at compilation"
07:44:47 <Proge>  ahh so i'm learning what strong and loosely typed means
07:44:50 <mreh> ah, i've got to serialise a function
07:44:51 <elliott> Proge: Functional languages I would say are more about easing abstraction by building things up from higher-order building blocks (functions like fmap, foldr, (>>=) etc.) -- it's just that they go really well with a strong type system :)
07:44:52 <hpc> Proge: and "strong" means "you can't fuck shit up"
07:45:07 <elliott> (Because in non-functional languages, types tend to restrict you because you can't express higher-order things.)
07:45:08 <hpc> Proge: haskell is strongly typed because it has no type casts
07:45:25 <elliott> hpc: Well, I was meaning "strong" in the sense of "good" :-)
07:45:29 <hpc> elliott: :P
07:45:44 <elliott> Only Forthers brag about their weak type system.
07:45:48 <osaunders> There isn’t strong agreement on what the difference between strong and weakly typed means. Some guy did a survey and that was his conclusion
07:45:56 <hpc> elliott: only lispers and pythoners and rubyers and...
07:45:59 <Proge> ok so no casting means things are always what they are
07:46:14 <Proge> unless you change them into something new
07:46:21 <Proge> thats different
07:46:26 <hpc> Proge: essentially
07:46:34 <elliott> hpc: Well, I guess you're right about the "dynamic language" faddism. :/
07:46:48 <hpc> Proge: there's no coercing a Double to an Int, but there is a number of ways to round Doubles :D
07:46:52 <elliott> I'd like to think Lispers tend to be better than that, though.
07:46:55 <hpc> stuff like that
07:46:59 <elliott> But that's probably optimistic.
07:47:10 <Proge> elliott are you dissing c#?
07:47:45 <Proge> hpc: yep i understnad now :)
07:47:47 <elliott> Proge: C# isn't a dynamic language, so I'm not dissing it, no. Not to say I *don't* diss C#, just not right now :)
07:48:13 <Proge> elliott: ahh ok i'll fight that war with you another day then ;)
07:48:24 <elliott> Although dissing C# mostly happens by dissing Java and then saying "C#'s almost as bad, but at least it has lambdas".
07:48:33 <Proge> doesn't it have them now?
07:48:45 <Proge> ah sorry
07:48:47 <elliott> Java's getting them.
07:48:47 <Proge> miss read
07:48:56 <elliott> So I'll be able to say "C#'s just as bad" :-)
07:49:00 <Proge> haha
07:49:18 <hpc> java is getting lambdas?
07:49:21 <Proge> elliott: c# keeps stealing everything
07:49:32 <osaunders> They passed over giving Java lambda in the most recent update
07:49:35 <Proge> elliott: so you'll have a longer sentance when .net 5 comes out
07:49:47 <osaunders> Despite lots of discussion and initial enthusiasm
07:49:58 <osaunders> Can’t remember their rationale for that
07:50:11 <bcoppens> I have a cabal file, to which I added my testsuite as a seperate executable (test), which is buildable: false if the test flag is set to false (by default it is)
07:50:18 <elliott> osaunders: What, again?
07:50:23 <elliott> But they just decided on a syntax.
07:50:34 <bcoppens> so it build-depends on test-framework and generates a binary, only when test is True
07:50:34 <elliott> Oh, "most recent".
07:50:37 <osaunders> Oh maybe not again, but I didn’t think this was that long ago
07:50:38 <elliott> No, it's definitely happening this time.
07:50:54 <elliott> I think it's Java 8 they're planned for.
07:50:56 <bcoppens> but now I want to upload it to hackage, and the preview page shows that it depends on test-framework and makes an executable
07:51:06 <bcoppens> I don't really want that, is there a nice way around that?
07:51:15 <elliott> bcoppens: Have you tried cabal's testing functionality?
07:51:30 <elliott> http://www.haskell.org/cabal/users-guide/#test-suites
07:51:41 * elliott isn't familiar with it, but it sounds like the thing here.
07:52:32 <bcoppens> elliott: well I looked at that, but that seems to use sth else than test-framework, and instead uses its own framework?
07:53:31 <elliott> bcoppens: No, you just use exitcode-stdio-1.0.
07:53:37 <elliott> bcoppens: And then main-is: MyMagicTestingProgram.hs
07:53:54 <elliott> bcoppens: As long as it exits code >0 on failure and 0 on success, which test-framework should do, it'll work fine.
07:54:08 <elliott> bcoppens: Then you "cabal test".
07:54:17 <elliott> (I think.)
07:54:48 <bcoppens> aha, that might work, let me try :)
07:58:32 <Shammah> is there a standard function to split a list in equally sized lists?
07:58:52 <Shammah> eq: split 3 [1,2,3,4,5,6,7,8,9] = [[1,2,3], [4,5,6], [7,8,9]]
07:59:00 <statusfailed> Shammah: splitEvery ?
07:59:09 <statusfailed> oh wait
07:59:10 <statusfailed> partition
07:59:21 <statusfailed> http://zvon.org/other/haskell/Outputlist/partition_f.html
07:59:34 <statusfailed> no wait.
07:59:37 <Shammah> yehm but partition takes a function
07:59:40 <bcoppens> elliott: indeed that worked, thanks!
07:59:48 <osaunders> If I take a bytestring and put it in a list 100 times: «replicate 100 someBStr». It only uses enough memory for one string of bytes and 100 pointers to it?
08:00:31 <elliott> bcoppens: np :)
08:00:43 <elliott> Shammah: No. see the split package
08:01:28 <hpc> osaunders: afaik that's what it will do
08:02:18 <elliott> osaunders: Sure.
08:02:46 <elliott> osaunders: Actually it's guaranteed with ByteString's current implementation.
08:03:06 <osaunders> Does this apply to normal strings i.e. lists?
08:03:10 <FUZxxl> @tell
08:03:11 <elliott> But theoretically ByteString could switch to something that GHC could -- again theoretically -- decide to copy for whatever reason it wanted. I think GHC is permitted to copy ByteArray#s around if it wants.
08:03:16 <elliott> osaunders: It applies to everything.
08:03:19 <elliott> osaunders: Lists are boxed.
08:03:24 <statusfailed> Shammah: yeah, is splitEvery what you want?
08:03:51 <elliott> osaunders: Well, what you said isn't strictly true.
08:04:04 <FUZxxl> @tell DanBurton Your ticket was marked as duplicate of #5674. What do you think. Close yours or the other one?
08:04:09 <FUZxxl> @help tell
08:04:20 <FUZxxl> > 1 +1
08:04:20 <elliott> osaunders: It uses enough memory for one string of bytes, the ByteString overhead (not sure how much this is), 100 pointers to it, and 100 * the overhead of [], and 100 pointers to the tails of each list node...
08:04:21 <hpc> /query lambdabot
08:04:30 <elliott> FUZxxl: lambdabot is not here.
08:04:30 <FUZxxl> Lambdabot is offline?
08:04:35 <FUZxxl> hm...
08:04:39 <elliott> You could have just typed "lambda" and <TAB> :-P
08:04:51 <osaunders> elliott: Yeah right. But the point is: GHC is using persistent data structures
08:04:57 <osaunders> ?
08:05:00 <FUZxxl> lambdabot is offline
08:05:01 <osaunders> Is that fair to say?
08:05:08 <elliott> osaunders: Yes. Your program would run incredibly slowly if GHC copied things around all the time!
08:05:12 <hpc> preflex: seen Cale
08:05:13 <preflex>  Cale was last seen on #haskell 6 hours and 13 minutes ago, saying: @pl \this -> What is this madness
08:05:20 <osaunders> elliott: Yeah.
08:05:25 <elliott> osaunders: The whole reason functional tree structures can be efficient is that you have to do comparatively little copying for each operation.
08:05:39 <FUZxxl> preflex: help
08:05:40 <preflex>  try 'help help' or see 'list' for available commands
08:05:51 <FUZxxl> preflix: list
08:05:57 <milktrader> a main function is required for compiling a program, but not for loading a file? Is this correct?
08:05:57 <FUZxxl> preflex: list
08:05:58 <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; PlokiRE: [re]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen];
08:05:59 <preflex>  ZCode: [zdec, zenc]
08:06:16 <FUZxxl> preflex: help tell
08:06:17 <preflex>  tell NICK MESSAGE - when NICK shows activity, tell them MESSAGE
08:06:32 <FUZxxl> preflex: tell DanBurton Your ticket was marked as duplicate of #5674. What do you think. Close yours or the other one?
08:06:32 <preflex>  Consider it noted.
08:06:36 <FUZxxl> okay
08:06:42 <milktrader> ghci does not complain when I invoke :l hello.hs if there is no main function
08:06:53 <osaunders> elliott: K, thanks
08:07:06 <elliott> osaunders: No problem :)
08:07:10 <elliott> milktrader: You can load any module.
08:07:15 <milktrader> but ghc -make hello.hs does not compile
08:07:22 <FUZxxl> milktrader: Technically, a main function is only required upon linking
08:07:28 <osaunders> But there are times when certain operations might cause copies to be made, right? Like say if you map over a list and change every element in some way?
08:07:36 <elliott> milktrader: Do you mean --make?
08:07:40 <milktrader> yes
08:07:42 <elliott> I don't know what ghc -make does but it's probably not pretty.
08:07:51 <elliott> osaunders: You can't change the elements of a list.
08:08:03 <elliott> osaunders: map results in copying because it deconstructs and rebuilds the list.
08:08:12 <elliott> (Incrementally, as you traverse through it.)
08:08:19 <elliott> milktrader: What's the error?
08:08:22 <milktrader> Okay, so you can load functions from a file but since you're not linking the main is optional
08:08:58 <osaunders> elliott: But I’m guessing map id doesn’t actually copy anything or perhaps GHC isn’t smart enough?
08:09:10 <milktrader> hello.hs:1:1: Parse error: naked expression at top level
08:09:19 <elliott> milktrader: You have an error in your prorgam.
08:09:22 <elliott> Nothing to do with main.
08:09:24 <elliott> hpaste.org it
08:09:26 <elliott> osaunders: Well, "map id" might get eliminated into "id".
08:09:28 <sipa1024> osaunders: there may be a rewrite rule that says map id = id
08:09:32 <elliott> osaunders: But map id never copies each /element/ of the list, because id a = a.
08:09:56 <elliott> osaunders: It's not voodoo -- you can tell where the copies are happening going by the program source in most of the cases.
08:09:59 <osaunders> elliott: Ah
08:10:00 <sipa1024> at worst it will build a new list spine, but with identical (uncopied) elements in it
08:10:11 <elliott> osaunders: If there's a pattern match and a constructor, you're copying.
08:10:14 <milktrader> hello.hs:1:1: The function `main' is not defined in module `Main'
08:10:22 <elliott> milktrader: <milktrader> hello.hs:1:1: Parse error: naked expression at top level
08:10:24 <elliott> Did you fix this error?
08:10:35 <elliott> milktrader: Anyway, what you need is to put "module Something where" at the top of the file.
08:10:40 <milktrader> yes, it's now hello = putStr "hello"
08:10:41 <elliott> To compile as a library.
08:11:00 <milktrader> elliott, okay, that good info
08:11:14 <milktrader> but not required for loading to ghci
08:12:11 <elliott> milktrader: Well, ghci just doesn't require "main" in Main.
08:12:22 <elliott> Your module was called Main all along, but since you weren't building a program, you didn't need a "main" function in it.
08:14:46 <milktrader> elliott thanks, I now have known unknowns
08:17:21 <Shammah> statusfailed, yeh, it is, I just figured it would be in the standard library
08:32:50 * hackagebot Lattices 0.0.1 - A library for lattices  http://hackage.haskell.org/package/Lattices-0.0.1 (BartCoppens)
08:45:16 <shapr> So I hear this Haskell language is awesome?
08:45:29 <elliott> @faq Can Haskell be the worst language in the world?
08:45:34 <FUZxxl> shapr: Yes you are right!
08:45:36 <elliott> Oh. lambdabot's not here.
08:45:41 <elliott> I guess Haskell is awesome, then.
08:45:47 <shapr> FUZxxl: So, can I build websites with Haskell?
08:45:47 <FUZxxl> elliott: Lambdabot is offline.
08:45:56 <FUZxxl> shapr: Of course. Google yesod!
08:45:57 <rostayob> shapr: yes, you can
08:45:58 <ion> @faq Can Haskell keep lambdabot running with a decent uptime?
08:45:58 <elliott> shapr: No. Haskell actually explodes if you try that.
08:46:11 <shapr> elliott: Oh, that's too bad.
08:46:23 <shapr> And is there a tutorial for yesod?
08:46:42 <elliott> How To Explode Haskell: The Guide
08:46:42 <Mathnerd314> what the fuck? elliott likes Haskell?
08:46:47 <FUZxxl> shapr: It's supposed to exist somewhere on the internet
08:46:49 <mike-burns> http://trylambda.com/ - You might want to start a little simpler; Haskell is pretty complex.
08:46:50 <elliott> shapr: http://www.yesodweb.com/book
08:47:13 <elliott> Mathnerd314: No. It's the worst language in the world and it can't build websites without exploding!
08:47:13 <shapr> elliott: Ok, I'll read the book and see if I can get it to work.
08:47:28 <Mathnerd314> elliott: ok, much better.
08:47:37 <elliott> shapr: Oh, looks like I'm meant to link you to http://www.yesodweb.com/page/five-minutes instead.
08:47:41 * elliott doesn't know much about Yesod.
08:47:45 <shapr> mike-burns: I'll try yesod, if I bounce, I'll go back to tryhaskell
08:47:50 * hackagebot ruff 0.3 - relatively useful fractal functions  http://hackage.haskell.org/package/ruff-0.3 (ClaudeHeilandAllen)
08:47:52 * hackagebot gruff 0.3 - fractal explorer GUI using the ruff library  http://hackage.haskell.org/package/gruff-0.3 (ClaudeHeilandAllen)
08:47:54 * hackagebot gruff-examples 0.3 - Mandelbrot Set examples using ruff and gruff  http://hackage.haskell.org/package/gruff-examples-0.3 (ClaudeHeilandAllen)
08:48:39 <FUZxxl> shapr: You should laso consider reading learn you a Haskell
08:48:46 <FUZxxl> and Real World Haskell
08:48:54 <shapr> Ok, I'll look into those.
08:48:55 <FUZxxl> Both are awsome for teaching Haskell
08:49:09 <Botje> *snrk*
08:49:25 <TTimo> word
08:49:31 <Botje> shapr: don't forget all about monads and the gentle introduction to haskell ;)
08:49:41 <shapr> Botje: Are those good too? :-)
08:49:47 <elliott> shapr: You should read the Haskell Report. It's great beginner material.
08:50:15 <mike-burns> shapr: No no, tryhaskell is too complex; start with trylambda.com !
08:50:20 <zmv> lol
08:50:38 <shapr> mike-burns: oooh, pretty!
08:50:53 <FUZxxl> shapr: You know, Monads are just like burritos
08:50:53 <FUZxxl> Well, actually they are just monoids in the category of endofunctors, but Haskeller's prefer to refer to them as "warm, fuzzy things" when introducing them to nebies
08:50:54 <FUZxxl> *newbies
08:51:03 <shapr> mike-burns: So, who wrote trylambda.com? :-)
08:51:11 <mike-burns> Oh you know, some guy.
08:51:27 <mike-burns> I just finished it this morning so this is my way of showing it off.
08:51:31 <elliott> shapr: Lambda calculus is too complex.
08:51:38 <elliott> shapr: Try tryskicalculus.com.
08:51:53 <zmv> trolololololololololol
08:51:54 <shapr> mike-burns: That must have been a busy night!
08:51:56 <elliott> shapr: Or the beginner version, tryskcalculus.com. It's technically equivalent.
08:52:18 <FUZxxl> Wow... trylambda.com uses jquery. It MUST be good!
08:52:18 * mike-burns is disappointed that elliott isn't quickly making these Web sites before linking to them.
08:52:29 <danr> elliott: don't forget iota combinator: http://en.wikipedia.org/wiki/Iota_and_Jot
08:52:32 <elliott> FUZxxl: Of course! jQuery is monadic!
08:52:55 <elliott> danr: I like Iota, but I wouldn't call it simpler than SK :)
08:53:04 <shapr> elliott: Yah, I thought you might actually have tryskicalculus, or tryskcalculus
08:53:17 <elliott> There's not much to try, really.
08:53:27 <shapr> I guess you could type in the combinators?
08:53:28 <Philonous> elliott:  I like the I calculus. It has one constant "I" and one production rule " I -> I". I'm still trying to show that it is Church-Rosser, though ;)
08:53:55 <FUZxxl> Why not tryX.com?  X ≡ λx.((xS)K)
08:54:03 <Botje> Philonous: have you tried a proof by intimidation? " go ahead. prove me wrong. I dare you."
08:54:04 <elliott> FUZxxl: That's iota.
08:54:07 <elliott> I think X is something else.
08:54:10 <FUZxxl> elliott: Oh yes.
08:54:14 <elliott> Philonous: Does tryicalculus.com just redirect to tryicalculus.com?
08:54:17 <shapr> FUZxxl: I've heard rumors that X can cover all the other combinators, is that true?
08:54:23 <FUZxxl> hehe
08:54:29 <FUZxxl> shapr: Yes.
08:54:32 <elliott> shapr: It can do every combinator but (\xy.x(yy)x).
08:54:34 <FUZxxl> http://en.wikipedia.org/wiki/Combinatory_logic#One-point_basis
08:54:35 <elliott> Nobody knows why this is the case.
08:54:37 <shapr> elliott: srsly?
08:54:46 <elliott> shapr: No. But man, if only!
08:54:56 <Philonous> Botje:  No, I tried proving it by complete intuition
08:55:02 <elliott> I want that kind of arbitrary complexity from our universe.
08:55:46 <zmv> Philonous: the PMW proving technique always works
08:56:08 <shapr> Hm, yesod doesn't seem too hard to install so far.
08:56:16 <shapr> But it sure does take a long time to build.
08:56:49 <elliott> shapr: That's because GHC compiles everything down to nested applications of X behind the scenes.
08:56:53 <shapr> I could use this time to folow the tutorial.
08:58:54 <shapr> mike-burns: trylambda.com is nifty :-)
08:59:00 <mike-burns> shapr: Thanks!
08:59:10 <shapr> mike-burns: How can I pass it hpaste entries?
08:59:21 <mike-burns> I, um.
08:59:32 <zmv> mike-burns: it needs the complimentary tutorial :P
08:59:43 <mike-burns> It does, but the joke had to end at some point.
09:00:51 * shapr reads the Yesod book
09:01:08 <FUZxxl> zmv: I could try to write one
09:01:15 <zmv> FUZxxl: do eeeeeeet
09:01:23 <mike-burns> Pull requests welcome!
09:01:36 <augur> wibble!
09:02:07 <FUZxxl> mike-burns: You definitly need a function that stops programs that won't halt...
09:02:17 <FUZxxl> make the impossible happen!
09:02:56 <shapr> Yay yesod is installed!
09:04:30 <elliott> shapr: Brace for explosion.
09:06:04 <FUZxxl> mike-burns: Can you hack this page to allow multi-letter identifiers and binding of variables?
09:06:36 <shapr> elliott: It is getting warmer in here, maybe it's a slow explosion?
09:06:45 <mike-burns> FUZxxl: I've wanted the multi-letter indentifiers thing but ... didn't really want to touch the parser.
09:06:54 <mike-burns> I'll try it again in a bit.
09:07:09 <elliott> shapr: It can take up a day to complete. Enough time to finish the tutorial and write your website, one hopes.
09:09:21 <shapr> Hm, yesod init doesn't match the yesod book, perhaps I should add some comments suggesting changes?
09:10:44 <shapr> elliott: Have you built a yesod website?
09:11:11 <elliott> No. But I've blown up a lot of Haskell trying. (Only first sentence is true.)
09:11:23 <shapr> ha
09:11:30 <elliott> I think Yesod gets changed faster than the book does.
09:13:16 <shapr> Ok, foundation created my website, and now it's compiled... and it's still getting warmer in here.
09:13:36 <zmv> elliott > No. But I've blown up a lot of Haskell trying. (Only first sentence is true.) -- UH OH
09:13:53 <zmv> YOU ARE CONTRADICTING YOURSELF
09:13:55 <zmv> SHI-
09:14:45 <zmv> because if "Only first sentence is true." is true, then "Only first sentence is true" is not true!
09:14:46 <Botje> 'THIS. STATEMENT. IS. FALSE.' -- Wheatley
09:14:52 <zmv> haha
09:14:56 <elliott> @faq Can Haskell support stable contradictions?
09:15:11 <donri> @faq Can Haskell support stable IRC connections?
09:15:31 <shapr> donri: Yes, but no one has gotten around to fixing lambdabot
09:15:38 <shapr> donri: Would you like to volunteer?
09:15:40 <sipa1024> lambdabot has preventively disconnected, in order not having to answer contractory questions
09:15:45 <sipa1024> contradictory
09:15:47 <zmv> shit.
09:15:56 <zmv> @protontorpedo
09:16:11 <zmv> fu
09:16:26 <donri> shapr: Unverily.
09:18:30 <shapr> Hm, the code produced by yesod init has excellent comments and is easy to read.
09:19:30 <Phyx-> oh, lambdabot died?
09:19:33 <Phyx-> when?
09:20:04 <mauke> preflex: seen lambdabot
09:20:05 <preflex>  lambdabot was last seen on #haskell 5 hours, 29 minutes and 35 seconds ago, saying: Not in scope: `decrement'
09:20:23 <mauke> preflex: seen Cale
09:20:23 <preflex>  Cale was last seen on #haskell 7 hours, 28 minutes and 12 seconds ago, saying: @pl \this -> What is this madness
09:20:27 <elliott> That was the error that broke the lambda's back.
09:20:31 <zmv> that's a nice way to die
09:20:38 <hpc> preflex: seen lambdabot
09:20:39 <preflex>  lambdabot was last seen on #haskell 5 hours, 30 minutes and 10 seconds ago, saying: Not in scope: `decrement'
09:20:44 <hpc> oh
09:20:54 <mauke> madness
09:20:58 <Botje> it's just flip (what is) madness
09:21:19 <Botje> COME BACK \BOT! we solved it!
09:22:03 <elliott> Botje: It'll only come back if you give it its decrement.
09:22:21 <homie> lol
09:22:40 <zmv> 15:43 <         elliott > Botje: It'll only come back if you give it its decrement.
09:22:43 <zmv> 15:43 -!- Kyril [~carl@fedora/Kyril] has quit [Quit: Konversation terminated!]
09:22:46 <zmv> EPIC WIN
09:23:03 <mauke> zmv: wtf?
09:23:21 <mauke> also, $5 for the "epic" jar
09:23:33 <vrook> Using ghc-6.10.4 -- "cabal install plugins" fails with src/System/Plugins/Env.hs:303:80: Not in scope: `sourcePackageId'
09:23:40 <danr> @pl \for -> out for now
09:23:42 <Botje> mauke++ # I fully endors this product and/or service.
09:23:47 <Botje> *endorse
09:25:24 <vrook> "cabal install cabal-install" fails with Main.hs:73:7:
09:25:26 <vrook>     Could not find module `Distribution.Verbosity'
09:25:42 <vrook> version 1.8.0.2
09:26:38 <vrook> ghc-check reports a lot of missing .hi files, but doesn't recommend how to correct it
09:26:59 <vrook> ghc-pkg check, I mean
09:31:13 <vrook> This is ghc built from macports. I wish the download page for the "haskell platform" would say which ghc version is used.
09:31:56 <elliott> vrook: http://hackage.haskell.org/platform/contents.html
09:33:32 <vrook> What is the recommended route for macs? Are cabal problems like these common?
09:34:19 <Saizan> missing .hi files aren't common
09:34:24 <luite> hmm, I usually build ghc from source on mac
09:35:12 <jaj> luite: good idea in winter when you're out of wood
09:35:30 <luite> yeah makes my laptop toasty :)
09:38:39 <alistra> hpc: is your nick from the haskell program coverage thingy?
09:38:56 <hpc> alistra: when i was in high school, someone called me the head programming czar
09:38:59 <hpc> and the name stuck
09:39:06 <hpc> it's too long for irc, but "hpc" isn't
09:39:22 <alistra> ok
09:39:37 <alistra> just reading thru the ghc manual
09:39:45 <alistra> cool stuff in there
09:39:49 <alistra> > it
09:40:01 <alistra> > 5
09:40:25 <alistra> [*] lambdabot
09:40:40 <dylukes> @nixon
09:40:48 <dylukes> Oh look, lambdabot is dead again...
09:40:51 <dylukes> This is getting old.
09:41:26 <alistra> @revive
09:41:32 <dylukes> @phoenix_down
09:42:37 <Botje> " of Life Saving
09:45:05 <dylukes> :)
09:45:35 <mike-burns> How does one bring lambdabot back up?
09:47:51 * hackagebot unpack-funcs 0.3.0 - Monad transformers that mirror worker-wrapper transformations.  http://hackage.haskell.org/package/unpack-funcs-0.3.0 (LouisWasserman)
10:06:59 <wereHamster> luite: I use homebrew on mac
10:08:18 <luite> wereHamster: can you compile ghc 7.2 without any special configuration with that?
10:10:22 <wereHamster> luite: is that the latest stable version of ghc?
10:10:36 <elliott> wereHamster: Depends on your definition of stable.
10:10:45 <luite> yeah, though not in the platform
10:10:54 <elliott> 7.2 is a "technology preview" series.
10:10:56 <luite> it's more a preview release, 7.4 will be the next "real" stable
10:11:05 <wereHamster> ah, then it probably won't be in homebrew yet
10:11:10 <elliott> Which is to say, they released 7.2.1 and then realised it's buggy.
10:11:15 <elliott> wereHamster: It's certainly the most recent stable GHC though.
10:11:20 <elliott> They just have a warning at the top of the page.
10:11:25 <wereHamster> but you could take a look at how homebrew compiles ghc, whether it uses any special flags
10:11:34 <luite> 7.2.2 fixes the most critical bugs :)
10:11:37 <elliott> https://github.com/mxcl/homebrew/blob/master/Library/Formula/ghc.rb
10:11:46 <elliott> Looks like it has 7.2.2 as long as you tell it you want 7.2.2.
10:11:54 <applicative> homebrew just downloads a binary, no?
10:11:59 <wereHamster> brew install ghc --devel :)
10:12:22 <elliott> applicative: Looks like it.
10:12:33 <wereHamster> applicative: it uses ./configure && make install. I think it compiles the source
10:12:40 <elliott> No.
10:12:43 <elliott>       url "http://www.haskell.org/ghc/dist/7.0.4/ghc-7.0.4-x86_64-apple-darwin.tar.bz2"
10:12:51 <elliott> GHC binaries are installed with ./configure && make install.
10:12:56 <alistra> @hoogle Monad m => [m [a]] -> m [a]
10:13:04 <alistra> fuuuuuuuu, no lambdabot
10:13:20 <elliott> alistra: fmap concat . sequence
10:13:47 <alistra> oh cool
10:16:01 <alistra> elliott++
10:16:06 <elliott> np :)
10:16:10 <dropdrive> Beginner here.  What GUI is recommended for learning more about Haskell, not necessarily just Haskell GUI programming?
10:16:17 <elliott> if only lambdabot was here to record that karma ;-)
10:16:29 <elliott> dropdrive: I'm not sure what you mean.
10:16:30 <alistra> maybe that preflex does
10:16:32 <alistra> i dunno lol
10:16:37 <elliott> preflex: karma elliott
10:16:38 <preflex>  elliott: 6
10:16:49 <alistra> preflex: karma alistra
10:16:49 <preflex>  alistra has no karma
10:16:59 <elliott> alistra++
10:17:01 <dropdrive> elliott: That is, what framework is most aligned with the ideas and techniques of Haskell, and not an ugly hack just to "make it work" in Haskell?
10:17:05 <alistra> preflex: karma alistra
10:17:05 <preflex>  alistra: 1
10:17:28 <elliott> dropdrive: Oh, you'd want to look at Tangible Values and FRP and all that. But functional GUIs are considered very much a research topic.
10:17:52 <irene-knapp> dropdrive: wellll the thing is, there's nothing quite like what you're saying that's mature enough to actually use :(
10:17:55 <elliott> dropdrive: You probably won't want to write a Real Program(tm) with them at this stage, and you should probably wait until you have a very solid grasp of Haskell before taking them on.
10:18:00 <supes> _oz++
10:18:08 <supes> forgot to do that the last time...
10:18:19 <irene-knapp> dropdrive: the closest would be something I came up with myself that's implemented on top of OpenGL and is designed from the ground up to use the Haskell object model instead of the Smalltalk one...
10:18:28 <irene-knapp> dropdrive: but it, like, is nowhere near ready
10:18:34 <elliott> . o O ( Haskell has an object model? )
10:18:43 <irene-knapp> elliott: or whatever the proper term for typeclasses is?
10:18:53 <elliott> . o O ( OpenGL uses Smalltalk's object model? )
10:18:57 <elliott> irene-knapp: Uh, typeclasses.
10:19:04 <irene-knapp> elliott: no, OpenGL doesn't use an object model
10:19:10 <irene-knapp> yeah, fair enough haha
10:19:16 <elliott> irene-knapp: If you're using typeclasses as if they were OOP classes, then I'd be sceptical of how "Haskelly" your library is.
10:19:21 <elliott> But I haven't seen it, so I wouldn't know.
10:19:22 <irene-knapp> um, I'm not
10:19:35 <elliott> Okay. I just got that impression from what you said.
10:19:36 <irene-knapp> I'm just saying that almost all GUI libraries are designed around Smalltalk thingies
10:19:39 <irene-knapp> and my thing isn't
10:19:50 <dropdrive> elliott: Can you explain your "Haskelly" comment?
10:20:00 <elliott> dropdrive: Which one? <elliott> irene-knapp: If you're using typeclasses as if they were OOP classes, then I'd be sceptical of how "Haskelly" your library is.?
10:20:16 <elliott> It seems I was mistaken.
10:20:31 <dropdrive> elliott: Yes, that one about typeclasses as OOP.
10:20:36 <elliott> Ah.
10:20:43 <elliott> Let me get you a good link on the matter.
10:21:13 <elliott> dropdrive: http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
10:21:19 <DukeDave> dropdrive: You might consider reactive-banana-wx as something which both works and isn't just "an ugly hack"
10:21:41 <elliott> Also http://www.haskell.org/haskellwiki/FAQ#I.27m_making_an_RPG._Should_I_define_a_type_for_each_kind_of_monster.2C_and_a_type_class_for_them.3F.
10:21:46 <DukeDave> dropdrive:  http://haskell.org/haskellwiki/Reactive-banana/Examples
10:21:58 <elliott> Yes, reactive-banana-wx is probably the best real-world solution we have.
10:22:15 <elliott> Some of those links are broken though.
10:22:38 <dropdrive> DukeDave: Thanks.  Yeah, I'm not looking for the prettiest solution, just something that's going to expand my mind.  Size (of my mind) matters!
10:22:42 <dropdrive> elliott: Thanks for the links.
10:22:46 <elliott> DukeDave: Still, you have to understand WxWidgets' event model and the like to use it, so it's still "just as ugly" in a sense.
10:22:58 <elliott> But it lets you avoid thinking about it for the most part, and model the *rest* of your program functionally, it's true.
10:23:17 <supes> Does any know how reads works for datatypes that have a variable? For instance 'data Note a = Note (Maybe Mod) a' with 'Mod = Sh | Fl', and 'Diat = C | D'.
10:23:18 <elliott> dropdrive: (To link what DukeDave said to what I said, reactive-banana is an implementation of FRP.)
10:24:03 <elliott> dropdrive: (It avoids a lot of the persistent implementation issues that have plagued FRP by basically having a conservative semantic model -- you can't construct as fancy abstractions as you might like, but you can achieve all the same things, and it has an efficient implementation.)
10:24:07 <DukeDave> elliott: Yes.. Although as someone who has been working on wxhaskell a lot recently I suspect what I consider the mean ugliness has probably shifted towards the obscene :)
10:24:11 <supes> If I give them all a 'deriving (Read)', it compiles, but ' read "C" :: Note DiatonicNatural' does not parse.
10:24:16 <donri> supes: you read it in a context with an inferred or explicit full type?
10:24:24 <elliott> DukeDave: Heh :)
10:24:40 <elliott> DukeDave: Well, at least it has a nicer API than gtk2hs (though that's gtk's fault, not gtk2hs').
10:24:41 <supes> donri: does my last sentence answer that question?
10:24:49 <sunfun> good evening everybody
10:24:56 <elliott> supes: That's not valid syntax.
10:25:04 <elliott> supes: you need e.g. read "Note (Just Sh) C".
10:25:20 <elliott> Basically, what you pass read has to be valid Haskell that constructs read's return value.
10:25:36 <Saizan> supes: read "C" :: Diat would parse
10:26:14 <DukeDave> elliott: Yeah, I'd like to think there's hope..
10:26:26 <Saizan> supes: as would read "Note Nothing C" :: Note Diat
10:27:04 <sunfun> is there a way to use a generic Ord element in a type definition? for example i would like to create a type X that could be an int or a char... is it possible?
10:27:14 <supes> So, maybe I'm just using this wrong, but I'd like to 'convert' a String into a Note Diat.
10:27:34 <elliott> sunfun: You mean a type that can contain any Ord instance?
10:27:44 <sunfun> elliott: yes
10:27:45 <elliott> sunfun: It is possible, but you might not be able to do what you want with it.
10:27:49 <elliott> What's your usecase?
10:27:55 <donri> (Ord x) => x
10:28:15 <sunfun> for instance if i use type Vertex = Int, is there a way to do something like type Vertex=Ord ?
10:28:25 <Saizan> supes: the derived Read instance will only parse valid haskell expressions of the given type, if you want something fancier you've to write a parser yourself
10:28:26 <elliott> sunfun: Ah! You will try and write a function
10:28:27 <sunfun> i know that Ord isn't a type
10:28:31 <elliott> foo :: Vertex -> blah
10:28:35 <elliott> erm
10:28:38 <elliott> foo :: Vertex -> Vertex -> blah
10:28:42 <elliott> And try and compare them, right?
10:28:49 <elliott> If you want to do that: you can't do this.
10:28:51 <elliott> But you *can* write
10:28:58 <elliott> foo :: (Ord a) => Vertex a -> Vertex a -> ...
10:29:10 <elliott> where type Vertex a = a, or newtype Vertex a = Vertex a, etc.
10:29:10 <sunfun> oh ok, but
10:29:17 <sunfun> aaa
10:29:20 <sunfun> ok
10:29:25 <donri> data Vertex = IntVertex Int | CharVertex Char
10:29:30 <elliott> sunfun: Basically, your Ord constraints must be on your functions.
10:29:41 <sunfun> elliott: thanks, it is just what i need
10:29:48 <sunfun> thank you guys
10:29:57 <elliott> sunfun: No problem. I suggest not using "type Vertex a = a", though.
10:29:59 <elliott> It's rather pointless :-)
10:30:08 <supes> Saizan: so, basically, I can only parse it and return the explicit datatype I give it? I cannot ask "what is "C" when expressed in the datatype Note Diat?
10:30:23 <elliott> supes: How could it know?
10:30:31 <elliott> It would have to read your mind to determine what you meant to mean by "C".
10:30:40 <elliott> Anyway, you can write a parser that does that, but it shouldn't be a Read instance.
10:30:59 <sunfun> elliott: but when i have to define a function like Vertex -> something... i have to write Vertex or Vertex a ?
10:31:00 <elliott> Since (C :: Note Diat) isn't valid, (read "C" :: Note Diat) shouldn't be either.
10:31:24 <elliott> sunfun: Vertex a. But if you just have "type Vertex a = a", then (Vertex a) is equivalent to a in all scenarios. You should do something like: newtype Vertex a = Vertex a.
10:31:28 <supes> Hmm. Yeah. I see.
10:31:32 <elliott> Assuming you want the type-safety.
10:32:39 <sunfun> elliott:  so i can do something like type Ver a = Vertex then
10:32:52 <elliott> sunfun: No. "type" just declares synonyms for types.
10:32:55 <elliott> Like C typedef.
10:33:10 <elliott> To create a new type, use "data" or "newtype" (which to use depends on the scenario; "data" always works though).
10:34:00 <ocharles> If I have something that is lift :: m a -> f m a, is it possible to provide something to do a sort of reverse-lift, like unLift :: f m a -> m a?
10:34:27 <ocharles> I'm in control of what m is, but not f
10:34:43 <ocharles> (f is PropertyM from QuickCheck, and I need to be able to call pick from within monad m)
10:34:45 <elliott> ocharles: No.
10:34:53 <elliott> ocharles: Well, it depends on the f.
10:34:58 <ocharles> thought that might be the case
10:35:01 <elliott> You might be able to do it for PropertyM.
10:35:03 <sunfun> elliott: ok, i will try then, thank you
10:35:13 <elliott> But not in general for an f just with lift.
10:37:54 <ocharles> To step back and /achieve, what I'm trying to do is replace monadicIO with some sort of brackettedMonadicIO function, because I need to do some tear down after each test case
10:38:25 <ocharles> I tried a naive myMonadicIO function which works, but the tear down only happens after *all* test cases have ran, not after each test case
10:38:41 <elliott> ocharles: Ah.
10:38:50 <elliott> ocharles: The problem is that bracket takes an IO callback, yes?
10:38:55 <elliott> ocharles: You want http://hackage.haskell.org/package/monad-control.
10:39:03 <Saizan> ocharles: monad-control might work for you
10:39:03 <elliott> ocharles: Unfortunately, it requires an instance for your transformer (PropertyM).
10:39:17 <elliott> ocharles: So either the constructor has to be exported, or you need to hack QuickCheck, basically.
10:39:25 <ocharles> the constructer for PropertyM?
10:39:31 <elliott> You might be able to achieve it without that, but probably not, or you'd already be able to accomplish what you want.
10:39:40 <elliott> ocharles: Yes. I mean, it's not an absolute requirement.
10:39:48 <ocharles> cool, well that is exported
10:39:49 <elliott> ocharles: But you either need to look into the guts of the monad itself, or for it to already provide equivalent operations.
10:39:55 <elliott> Oh, good.
10:40:05 <elliott> You should be able to write a MonadTransControl instance, then.
10:40:35 <ocharles> Hopefully this will run on each test case that quickcheck picks and not after everything :)
10:40:38 <ocharles> I'll investigate, thanks!
10:40:41 <elliott> ocharles: Then you can just use http://hackage.haskell.org/packages/archive/lifted-base/0.1.0.1/doc/html/Control-Exception-Lifted.html#g:9 from the lifted-base package, which works with any MonadBaseControl IO.
10:40:49 <elliott> (which is just like MonadIO for MonadTransControl)
10:41:01 <ocharles> my hackage doesn't seem to be working here, odd
10:41:41 <ocharles> (not to worry, have it installed locally)
10:42:43 <sal23> I don't see forM_ defined for Data.Vector.Unboxed.Vector. Is there any equivalent function for unboxed vectors that does the same thing?
10:43:09 <sunfun> elliott: using data, is it correct this: "data Vertex = Int | Char" ?
10:43:22 <elliott> sunfun: No. Oh, do you only need vertices to be either Ints or Chars?
10:43:55 <sunfun> elliott: yes
10:43:55 <elliott> If so, you can simply write data Vertex = IntV Int | CharV Char -- but note that you will have to be able to compare these to each other, because any function that takes two Vertices could receive e.g. (IntV 42) and (CharV 'a').
10:44:00 <elliott> sunfun: Have you read Learn You a Haskell?
10:44:25 <elliott> It would help you get to grips with things like "data" declarations and their use.
10:44:30 <sunfun> elliott: no i've used programming in haskell
10:44:59 <elliott> Hmm, I vaguely remember that one being quite good, though I've never read it myself.
10:45:07 <elliott> Does it not tell you about data declarations? That would be quite strange if so.
10:45:57 <sunfun> elliott: yes but there are examples like data ... = Just a | Maybe a and something with Trees
10:46:21 <elliott> Right. (It's data Maybe a = Nothing | Just a.)
10:46:30 <elliott> Well, it's just like that, except instead of "a" you fix the specific types being used.
10:46:53 <sunfun> elliott: there are examples like data Answer = Yes | No and other simple examples
10:47:01 <hpaste> Micah pasted “myFlatten” at http://hpaste.org/54854
10:47:51 * hackagebot cabal-install-ghc72 0.10.3 - Temporary version of cabal-install for ghc-7.2  http://hackage.haskell.org/package/cabal-install-ghc72-0.10.3 (TonyHannan)
10:49:08 <elliott> That smells like a recipe for trouble...
10:49:13 <dropdrive> Is there functions like saveToDisk :: String -> a -> IO () and loadFromDisk :: String -> IO a ?
10:49:30 <werbitt> hi, I'm trying to write a myFlatten function for problem 7 on 99 questions. I think I'm providing patterns for an empty list, a list with one item, and a list with more than one item. which seems exhaustive to me. But i'm getting an error. Can anyone provide me with some insight into what I'm doing wrong? (just pasted my code to hpaste)
10:49:30 <elliott> "This package will be removed" -- heh, well that's not possible
10:49:39 <elliott> dropdrive: You can create these with readFile/writeFile and read/show.
10:49:48 <elliott> dropdrive: Or do you want some efficient binary serialisation?
10:49:52 <elliott> dropdrive: If so, take a look at the cereal package.
10:50:07 <elliott> dropdrive: Or even acid-state (which gives you ACID semantics for a file-backed data store).
10:50:09 <gwern> elliott: what, is binary deprecated these days?
10:50:17 <dropdrive> elliott: Thanks.
10:50:23 <elliott> gwern: I don't think so. I prefer cereal, though, and binary hasn't been updated for over two years.
10:50:59 <dropdrive> Last question...what's a nice list of problems for a beginner to work through?
10:51:18 <elliott> dropdrive: depends how beginner you are :)
10:51:25 <Botje> werbitt: your final clause has a lowercase f
10:51:50 <mike-burns> Hawk eye.
10:52:00 <dropdrive> elliott: Well, assume the worst -- if it's too easy I'll come back ;)  Though I worked through maybe a dozen project euler ones before getting slightly bored :(
10:52:01 <werbitt> awesome, thanks!
10:52:09 <werbitt> elliott++
10:52:14 <donri> or safecopy, which is what acid-state uses
10:52:50 <arneis> hi all... I'm trying to work my way through 'learn you a haskell'.. I can't get applicative functors to work though. Do I need to import something to get <*> to work?
10:53:00 <DevHC> > . <
10:53:01 <werbitt> haha, now I know myFlatten doesn't work
10:53:05 <Botje> arneis: they're in Control.Applicative
10:53:20 <DevHC> lambdabot is taking a nap?
10:53:26 <arneis> Botje- thanks :)
10:53:47 <skangas> @pl map (\x -> subst x i e) es
10:53:49 <elliott> werbitt: Wait, why are you thanking me?
10:53:51 <elliott> Botje helped you.
10:53:57 <elliott> Poor Botje.
10:54:10 <werbitt> woops
10:54:15 <werbitt> Botje ++
10:54:22 <werbitt> Botje++
10:55:01 <supes> Thanks elliott, I wrote a function to do what I wanted. It words.
10:55:04 <supes> elliott++
10:55:16 <supes> Works*
10:55:24 <werbitt> maybe not a good idea to try to learn haskell and chat with a vicious hangover
10:56:03 <elliott> preflex: karma elliott
10:56:03 <preflex>  elliott: 8
10:56:07 <elliott> I'm goin' places.
10:56:35 <ocharles> return $ monadic (unsafePerformIO . runDatabase db) (a >> run rollback)
10:56:36 * ocharles shivers
10:56:50 <elliott> ocharles: Don't... do that.
10:56:53 <elliott> It won't even do what you want, most likely.
10:57:08 <ocharles> it does do what I want, and it's pretty much what monadicIO does behind the scenes
10:57:19 <elliott> ocharles: All you need to do is save PropertyM's state, and restore it.
10:57:24 <ocharles> (it runs IO a with 'morallyDubiousIOProperty' which is basically unsafePerformIO)
10:57:33 <elliott> Seriously?
10:57:38 <ocharles> mmhmm
10:57:49 <ocharles> well
10:57:53 * elliott disowns QuickCheck.
10:57:55 <ocharles> maybe I'm lying there :)
10:58:10 <elliott> morallyDubiousIOProperty :: Testable prop => IO prop -> Property
10:58:10 <elliott> morallyDubiousIOProperty = fmap (MkProp . ioRose . fmap unProp) . promote . fmap property
10:58:15 <ocharles> yea, so not what I said
10:58:18 <elliott> ocharles: Well, it's not unsafePerformIO, it just exposes an inner IO.
10:58:20 <ocharles> but it does seem to magically make IO vanish
10:58:25 <elliott> ocharles: The problem with unsafePerformIO is that it doesn't order right.
10:58:27 <ocharles> oh, right
10:58:44 <elliott> Well, hmm.
10:59:02 <elliott> ocharles: Yeah, I'm pretty sure you want to get monadicIO working here. But it's up to you :P
10:59:10 <zhulikas> can someone give me a real-life example where Monoids are useful?
10:59:21 <elliott> PropertyM is weird.
10:59:26 <zhulikas> I mean not in a way that list is a monoid and we use it, but the whole Monoid abstraction
10:59:27 <elliott> It's just Cont (Gen (m Property)).
10:59:29 <hpaste> ocharles pasted “monadicDB” at http://hpaste.org/54855
10:59:39 <elliott> zhulikas: http://apfelmus.nfshost.com/articles/monoid-fingertree.html
10:59:53 <ocharles> That's the property runner I'm trying to write at the moment
11:00:23 <elliott> ocharles: Hm?
11:00:58 <ocharles> elliott: which bit is hm?
11:01:05 <elliott> <ocharles> That's the property runner I'm trying to write at the moment
11:01:05 <MostAwesomeDude> Hey, is there a way to introspect type constructors? I want to be able to take the type constructor of a type and automatically generate a bit of code for it.
11:01:07 <elliott> What's that?
11:01:17 <ocharles> elliott: the hpaste - http://hpaste.org/54855
11:01:32 <elliott> MostAwesomeDude: Are you sure you mean "type constructor"? Take a look at syb and Template Haskell, anyway.
11:01:39 <elliott> Also GHC's new generics.
11:01:52 <MostAwesomeDude> Specifically, I want to effectively create Serialize instances for every constructor in a type. There are about forty constructors to the type.
11:02:01 <elliott> http://hackage.haskell.org/package/syb, http://www.haskell.org/haskellwiki/Template_Haskell, http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/generic-programming.html
11:02:08 <elliott> MostAwesomeDude: Yeah, you want generics of some form.
11:02:10 <MostAwesomeDude> Each constructor looks like DerpPacket Word16 Word16 SomeSerializeableType
11:02:19 <elliott> MostAwesomeDude: Template Haskell could do that at a pinch.
11:02:30 <MostAwesomeDude> elliott: Cool story, I'll take a llook at it.
11:04:06 <DevHC> how do i cope with "undefined symbol forkOS_createThread"?
11:04:20 <ocharles> elliott: while I don't like the look of monadicDB, it does at least seem to work (100 test cases passed)
11:05:02 <elliott> ocharles: Yeah, until you do something sufficiently lazy or whatever... but maybe I'm wrong :)
11:05:16 <ocharles> yea, I don't doubt you for a second
11:05:24 <ocharles> I just lack the understanding of monad-control for now to make that work
11:05:42 <ocharles> totally cop-out argument :)
11:08:33 <ocharles> Running with hpc now to see if it's at least executing what I expect it to
11:20:31 <ocharles> elliott: it's dawned on me too that 'bracket' was really not the right term
11:20:48 <elliott> I assumed you meant Control.Exception.Bracket.
11:20:56 <ocharles> yea, but bracketting is about running code on exception
11:21:05 <ocharles> it's not that I want something to run in the case of exceptions, it's that I want something to run at the end of a test-case
11:21:10 <ocharles> so that's still successful execution
11:21:29 <elliott> ocharles: That's what Control.Exception.bracket is about...
11:22:15 <ocharles> oh right, bracketting is about running that code regardless of exception or success
11:23:17 <ocharles> well anyway, monadicDB was as perdicted, a fail :)
11:23:25 <ocharles> it just doesn't run the actual action at all
11:35:41 <wereHamster> MostAwesomeDude: are you working on the new X11 haskell binding?
11:37:45 <MostAwesomeDude> wereHamster: I'm working on Minecraft!
11:38:01 <sipa> is there a minecraft monad yet?
11:38:10 <ion> Minecraft is great.
11:38:38 <MostAwesomeDude> Minecraft's horrible, but I'm determined to provide high-quality Minecraft servers.
11:38:56 <ion> Are you writing a reimplementation of the server?
11:39:05 <wereHamster> oh, is minecraft open source so that you can implement your own server?
11:39:36 <MostAwesomeDude> I wrote Bravo (bravoserver.org) and I'm working on a Haskell flavor for various reasons.
11:39:39 <mike-burns> It wouldn't need to be open source, it'd just need a documented protocol, yeah?
11:39:44 <MostAwesomeDude> It's not open source. Docs are at wiki.vg.
11:40:45 <zmv> you can always rewrite minecraft on haskell
11:42:07 <hpaste> sal23 pasted “Compilation issue when using unboxed vector forM_” at http://hpaste.org/54856
11:43:28 <sal23> will appreciate help with resolving error with forM_ - Word16 seems to be part of unboxed vector, but I get the error: No instance for (Data.Vector.Unboxed.Base.Unbox a)
11:43:58 <ion> I suppose there’s no direct function for concatMap permutations . subsequences in base?
11:46:38 <A1kmm_> I just defined the following in my program, but it seems so obvious it makes we wonder if it is unidiomiatic / there is a reason it isn't in the library: liftA2 :: Arrow a => (c -> c' -> d) -> a b c -> a b c' -> a b d
11:46:53 <A1kmm_> (defined as: liftA2 f a1 a2 = arr (\a -> (a, a)) >>> (a1 *** a2) >>> arr (\(a, b) -> f a b) )
11:47:13 <A1kmm_> anyone know if there is a reason why something similar isn't in the Arrow library already?
11:47:14 <mike-burns> There's this in Control.Applicative: liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
11:47:37 <ClaudiusMaximus> > filterM (const [False, True]) "fruit"
11:47:39 <mike-burns> Oh you need it to be an Arrow. The name threw me off.
11:47:49 <ClaudiusMaximus> oh..
11:48:11 <A1kmm_> liftA2 is probably a bad name in that case.
11:49:07 <A1kmm_> but I can't find any kind of Arrow function that does what I am defining, which surprises me, it seems like it would be a common thing to do.
11:49:27 <A1kmm_> liftArrow = (^>>)
11:49:45 <A1kmm_> liftArrow2 f a1 a2 = arr (\a -> (a, a)) >>> (a1 *** a2) >>> arr (\(a, b) -> f a b)
11:49:47 <A1kmm_> and so on
11:53:17 <Bsryhv> http://bit.ly/uPBolO
11:53:48 <elliott> <A1kmm_> I just defined the following in my program, but it seems so obvious it makes we wonder if it is unidiomiatic / there is a reason it isn't in the library: liftA2 :: Arrow a => (c -> c' -> d) -> a b c -> a b c' -> a b d
11:54:00 <elliott> A1kmm_: Surely this would be better constructed from arr2 and the arrow combinators?
11:54:10 <ion> Kleisli-ish version of fmap might be useful.
11:54:11 <ion> λ> let f <$< g = (f <$>) . g; infixr 1 <$< in (`map` [5,6,7]) <$< foldr (.) id <$< permutations <=< subsequences $ [ (+1), (2*) ]
11:54:14 <ion> [[5,6,7],[6,7,8],[10,12,14],[11,13,15],[12,14,16]]
11:54:18 <elliott> (where arr2 f = arr (arr . f))
11:54:24 * elliott doesn't know much about arrows.
11:55:30 <ion> I bet that already exists in some of edwardk’s modules. ;-)
11:56:03 * FUZxxl loves codegolf. This is one of FUZxxl's challenges: http://goo.gl/nWfga
11:56:21 <edwardk> ion: type signature?
11:56:24 <elliott> ion: what doesn't :)
11:56:25 <A1kmm_> elliott: Although arr2 depends on the ArrowList class, whereas mine works on any Arrow.
11:56:34 <elliott> A1kmm_: huh. it does?
11:56:37 <elliott> does my definition not work?
11:56:46 <edwardk> :t traverse
11:56:58 <elliott> oh, err, right
11:56:59 <ion> Functor f => (a -> b) -> (t -> f a) -> t -> f b
11:57:04 <elliott> mine is useless without ArrowApply
11:57:11 <edwardk> can't be done.
11:57:19 <edwardk> oh
11:57:21 <edwardk> that
11:57:31 <Bsryhv> http://bit.ly/uPBolO
11:57:40 <zmv> fasta: holy shit
11:57:45 <edwardk> Applicative f => (a -> f b) -> t a -> f (t b)  is better =P
11:57:49 <edwardk> thats just traverse
11:57:52 <elliott> @where ops
11:57:56 <elliott> grr
11:57:57 <elliott> no lambdabot
11:58:11 <fasta> zmv: yes?
11:58:12 * elliott smoke signals
11:58:24 <ezyang> Cale ping
11:58:45 <elliott> mauke?
11:58:53 <elliott> Let's just be mean to Bsryhv.
11:58:54 <mauke> yes?
11:58:56 <fasta> zmv: are you a spam bot from hell?
11:59:01 <elliott> mauke: <Bsryhv> http://bit.ly/uPBolO
11:59:02 <elliott> (twice)
11:59:20 --- mode: ChanServ set +o mauke
11:59:35 <elliott> thanks
12:00:04 <elliott> A1kmm_: i just checked, you do not really need ArrowList for arr2
12:00:10 --- mode: mauke set -o mauke
12:00:10 <elliott>     arr2                :: (b1 -> b2 -> c) -> a (b1, b2) c
12:00:10 <elliott>     arr2                = arr . uncurry
12:01:42 <A1kmm_> elliott: Yeah... I'm not sure why the standard arr2 is defined using ArrowList.
12:02:04 <elliott> A1kmm_: Well, "standard". It's just in hxt.
12:02:06 <Philippa> what's the approved way to grab the entire contents of a file and close it straight away these days?
12:02:20 <elliott> Philippa: Data.ByteString.readFile :-)
12:02:24 <Philippa> (no, I'm not worried about GB-sized files)
12:02:33 <elliott> Philippa: But I think withFile + deepseq should work. Or even just length s `seq` ...
12:02:44 <elliott> + hGetContents, that is.
12:02:49 <Philippa> elliott: characters, not bytes?
12:03:04 <elliott> I think Data.Text has something similar :P
12:03:12 <elliott> http://hackage.haskell.org/packages/archive/text/0.11.1.9/doc/html/Data-Text-IO.html#v:readFile
12:03:26 <elliott> But for Strings you have to roll your own.
12:03:33 <Philippa> joy of joys!
12:03:36 <elliott> It may be in some package, though.
12:03:47 <Philippa> that really ought to be in the Platform by now, yeah
12:04:08 <elliott> Philippa: withFile fn readMode $ \h -> do { s <- hGetContents h; length s `seq` return s }
12:04:10 <elliott> That should do it, at least.
12:07:10 <sal23> is it possible to define a function f type declaration to take only (Word8 or Word16) types as the first argument? "Num a" is too broad declaration for my use case
12:08:30 <Philippa> nope. You can define a typeclass that includes Word8 and Word16, but other instances can be added elsewhere - is that good enough?
12:08:33 <monochrom> there are several "strict I/O" libs on hackage for grabbing entire files and closing right away. for example strict and strict-io
12:08:41 <monochrom> (for [Char])
12:09:08 <Philippa> monochrom: yeah. We really should have readFile' in System.IO and the Prelude though!
12:09:10 <sal23> Philippa, yep, that will work too
12:09:48 <elliott> Philippa: it's an incentive to use ByteString or Text :)
12:09:49 <Philippa> sal23: there aren't "nice" or types - you'd have to build your own datatype, use Either or something of that ilk. Type classes work, but they can't be closed
12:10:12 <elliott> You can close a typeclass -- sort of.
12:10:36 <elliott> I think just not exporting the typeclass works, though I haven't tried recently.
12:10:39 <sal23> Philippa, it will be nice to be able to express union of types in type declaration instead of going through  a typeclass creation
12:10:47 <elliott> sal23: Well, you can do that.
12:10:56 <elliott> data Foo = Foo8 Word8 | Foo8 Word16
12:10:57 <morphles> Im looking for function with signature like "Integral b :: b -> [a] -> [[a]]" That would take list and return list of lists of lenght b. Hoogle does not give anything similar for me.
12:11:10 <Philippa> sal23: you'd be amazed how much of a mess that creates for a typechecker if you want a union type rather than a discriminated union type (in which case Either is fine)
12:11:30 <elliott> morphles: see the split package, most likely
12:11:34 <elliott> assuming you want to split every n elements
12:11:40 <sal23> elliott, yes, that is another approach I thought about. Should work
12:12:05 <monochrom> type class is not for union either
12:12:09 <Philippa> elliott: if we're going to get like that we should have a typeclass for the basic file ops and shove that stuff in either Prelude or a single location too, though
12:12:59 <geheimdienst> morphles: also, note that you must have meant "Integral b => b -> [a] -> [[a]]" :) no wonder that hoogle doesn't find anything for "Integral b :: ..."
12:13:16 <morphles> a
12:13:20 <morphles> thanks
12:13:49 <ion> edwardk: I’m probably just being stupid, but it seems like quite a bit of work to implement the same thing with traverse. :-) :t [ \f g -> join . traverse (pure . f) . g, \f g -> (f <$>) . g]
12:13:59 <ion> FSVO same
12:14:20 <edwardk> well, the type signature you provided seems kinda silly
12:14:29 <edwardk> hence why i was saying traverse is more useful =P
12:14:58 <morphles> bah it will be faster to write function myself than to find and import some package :D
12:15:08 <morphles> its really simple
12:15:43 <ion> I was combining list operations with <=< and ended up with “return . something <=< return . foo <=< bar <=< baz”, at which point i thought “wouldn’t it be nice to have to <$> what <=< is to =<<”. :-)
12:17:50 <morphles> here is my function: "mysplit i xs = (take i xs):(mysplit i (drop i xs))" no lib needed :)
12:18:09 <ion> (hilight: edwardk ↑)
12:19:00 <geheimdienst> cale: you around? lambdabot has locked herself in the bathroom and won't come out
12:19:14 <Phyx-> oh oh
12:19:20 <Phyx-> has she been crying?
12:19:22 <edwardk> ah
12:19:25 <ion> lambdabot won’t come out of the closet. :-(
12:20:58 <`Zerax`> There's a joke in there somewhere
12:21:17 <ion> Just a South Park reference.
12:21:40 <Phyx-> there's *always* a south park reference
12:22:07 <AlpT> $ cabal install happy >>> setup: happy version >=1.17 is required but it could not be found.
12:22:15 <AlpT> oops
12:22:28 <AlpT> I meant, $ cabal  install  haskell-src-exts >> setup: happy version >=1.17 is required  but it could not be found.
12:22:49 <AlpT> I already run  $ cabal install happy, but I get the same error
12:23:03 <AlpT> any suggestion?
12:23:05 <ocharles> AlpT: make sure ~/.cabal/bin is in your $PATH
12:23:10 <AlpT> ok
12:23:17 <ocharles> (at the front too)
12:26:16 <AlpT> same error..
12:28:09 <ocharles> does bas van dijk frequent #haskell at all?
12:31:04 <DevHC_> wait wat
12:31:18 <DevHC_> wasn't there a Monad (Either a) instance in Haskell?
12:31:48 <ezyang> It was... kind of special.
12:32:16 <geheimdienst> there's a Functor instance, if that would help you ... it lives in Control.Monad.Instances
12:33:12 <elliott> ocharles: i don't think so
12:33:20 <elliott> at least i coughed and said words about monad-control and nobody spoke so i went to github
12:33:23 <DevHC_> oh there IS a Monad (Either a) instance :D
12:33:35 <ocharles> ok
12:36:32 <DevHC_> hey wtf
12:36:47 <DevHC_> this Either a instance doesn't work as i thought it would D:
12:36:49 <zmv> wtf "hey wtf"
12:37:32 <ezyang> I wonder what a Bimonad would look like.
12:37:49 <DevHC_> wtf "wtf \"hey wtf\""
12:40:47 <FUZxxl> fix $ show . \x -> "hey \" ++ x ++ "\""
12:42:17 <ion> fix (("hey " ++) . show)
12:42:52 * hackagebot couchdb-enumerator 0.3.3 - Couch DB client library using http-enumerator and aeson  http://hackage.haskell.org/package/couchdb-enumerator-0.3.3 (JohnLenz)
12:43:33 <zzo38> Would bijective function types allow to make number theory with Curry-Howard?
12:43:58 <AlpT> zzo38: perhaps you are interested in Agda
12:44:09 <zzo38> AlpT: Does Agda have such types?
12:44:41 <AlpT> zzo38: yes, you can define them, I don't know what there is in the standard lib though
12:45:02 <zzo38> AlpT: How to define it?
12:45:35 <zzo38> If you have the bijective function types, can it be used to prove Fermat's Last Theorem?
12:45:41 <ocharles> bleh, really not grokking monad-control 0.3, I can't see anything that matches what liftIO used to be
12:45:43 <AlpT> ocharles: I've tried both with PATH="~/.cabal/bin/:${PATH}" and PATH="${PATH}:~/.cabal/bin/", but no luck
12:46:08 <AlpT> zzo38: you can prove anything, you can formalize any constructive/effective mathematical theorem and proof
12:46:08 <alistra> lambdabot, come back
12:46:18 <AlpT> zzo38:  #agda is the best to chat about this
12:46:38 <AlpT> zzo38: you could also formalize the four colors theorem proof
12:46:42 <ocharles> nvm, liftIO is in transformers not monad-control
12:46:43 <AlpT> Coq is another alternative
12:47:11 <AlpT> <- away for 30 mins
12:47:12 <ion> alpt: Are you sure the ~ is expanded?
12:47:35 <ion> Try export PATH="$HOME/.cabal/bin:$PATH"
12:50:32 <Jeanne-Kamikaze> cabal assault part 2: can anyone install anything on windows ? I'm getting utf-8 decoding errors; I have tried the powershell, old cmd.exe, and even some random terminal from sourceforge only to run across the same issue. After googling it seems the locale cannot be changed.
12:50:38 <AlpT> ion:  it is compiling!! thanks!
12:50:48 <AlpT> (now I am really going away)
12:50:51 <Jeanne-Kamikaze> I can't even cabal install cabal
12:51:33 <ezyang> Jeanne-Kamikaze: Can you copypaste the error?
12:51:49 <Jeanne-Kamikaze> sure
12:52:16 <Jeanne-Kamikaze> http://pastebin.com/gQpKtzaA
12:52:18 <mauke> The paste gQpKtzaA has been copied to http://hpaste.org/54857
12:52:21 <Jeanne-Kamikaze> it happens with a billion packages
12:52:24 <vrook> Is someone working on syntax transformers for ghc?
12:52:45 <monochrom> chcp 65001 will get you utf-8
12:52:55 <ezyang> Jeanne-Kamikaze: How did you install GHC and the base packages?
12:52:59 <Jeanne-Kamikaze> no
12:53:02 <Jeanne-Kamikaze> that doesn't work either
12:53:13 <Jeanne-Kamikaze> ezyang, haskell platform download double click
12:53:26 <Jeanne-Kamikaze> monochrom, I already tried that and sitll same error
12:53:41 <monochrom> which GHC version?
12:53:50 <Jeanne-Kamikaze> 7.0.3
12:54:17 <Jeanne-Kamikaze> (it's the latest haskell platform bundle)
12:55:41 <vrook> I found a very strong argument that haskell needs some kind of syntax transformer: http://hackage.haskell.org/packages/archive/monad-control/0.3.0.1/doc/html/src/Control-Monad-Trans-Control.html
12:56:05 <vrook> It uses 9 language extensions, including the C preprocessor
12:56:08 <ezyang> Jeanne-Kamikaze: Huh, are you in a strange locale?
12:56:21 <Jeanne-Kamikaze> I'm on windows 7
12:56:27 <monochrom> actually every windows locale is a strange locale :)
12:56:38 <Jeanne-Kamikaze> and even running chcp 65001 doesn't get the problem solved
12:56:42 <ezyang> Jeanne-Kamikaze: English-US?
12:56:52 <Jeanne-Kamikaze> hmm I think so
12:57:00 <Jeanne-Kamikaze> could be uk
12:57:03 <vrook> Even relatively simple stuff like the Random monad needs 4 extensions.
12:57:44 <ezyang> Did you install MingW and MSys separately?
12:58:22 <Jeanne-Kamikaze> hmm
12:58:25 <monochrom> I don't see how using extensions needs syntax transformer
12:58:45 <Jeanne-Kamikaze> I used mingw-get
12:58:47 <ddarius> monochrom: The problem is that 9 and 4 are small numbers.  We need to increase them.
12:58:49 <ezyang> What happens if you use cmd.exe?
12:58:51 <Jeanne-Kamikaze> as suggested on the msys page
12:59:05 <Jeanne-Kamikaze> the same thing
13:00:07 <vrook> Jeanne-Kamikaze: writing, not using, extensions needs a syntax transformer
13:00:40 <Jeanne-Kamikaze> what ?
13:00:51 <elliott> vrook: You sound like you're trolling.
13:01:01 <ezyang> Can you copypaste your windows environment?
13:01:02 <elliott> At least unless you tell us what your definition of "syntax transformer" is.
13:01:17 <Jeanne-Kamikaze> the env thing ?
13:01:25 <ezyang> using 'SET', I think.
13:01:27 <geheimdienst1> vrook: what would this kind of syntax transformer simplify? the work of somebody who wants to make a new compiler other than ghc ...?
13:01:28 <elliott> I'm pretty sure UnicodeSyntax, RankNTypes, TypeFamilies, and MultiParamTypeClasses don't use any kind of syntax transformer, for instance.
13:01:53 <Jeanne-Kamikaze> http://pastebin.com/aHCQvrW1
13:01:55 <mauke> The paste aHCQvrW1 has been copied to http://hpaste.org/54858
13:02:15 <ddarius> elliott: And at any rate, we have Template Haskell and quasiquoting, though those are extensions.
13:02:30 <vrook> geheimdienst1: did you see the link?
13:02:39 <ezyang> what happens if you clear your PATH (temporarily) so it only contains Haskell Platform paths
13:02:41 <elliott> ddarius: You can't implement syntax transformers with a syntax transformer! That's, like, circular, man.
13:02:49 <vrook> he's using the C preprocessor
13:02:54 <Jeanne-Kamikaze> how do I do that on windows ?
13:02:59 <elliott> vrook: so your argument is not
13:03:08 <elliott> vrook: "haskell needs syntax transformers because extensions must be written with them"
13:03:09 <elliott> but instead
13:03:21 <elliott> "haskell needs a way to replace the limited uses of cpp that are used in conjunction with haskell"
13:03:22 <ezyang> If you're in the msys shell, just export PATH=new value.
13:03:24 <elliott> ?
13:03:31 <ezyang> If you are in cmd, try using SET.
13:03:31 <elliott> that's certainly a reasonable viewpoint, but it's not what you said
13:03:41 <vrook> elliott: no, extensions should be written in an orderly way, not using GHC hacks.
13:03:49 <ezyang> I'm a bit concerned because you have two MingW's in your path
13:03:58 <vrook> up to and including replacing the use of the C preprocessor
13:04:03 <ezyang> (one is GHC bundled, and the other is one you installed yourself)
13:04:11 <elliott> vrook: what do you think an extension is? what do you think is hacky about GHC's implementation of extensions? do you have any idea what you are talking about, or are you just trolling?
13:04:23 <elliott> if you think every extension can be implemented by local syntax transformations, you're very wrong
13:04:33 <tomprince> Those extensions are simply syntax.
13:04:39 <tomprince> s/are/aren't/
13:05:38 <monochrom> haskell needs builtin genetic programming support
13:05:42 <ezyang> Jeanne-Kamikaze: Alternatively, uninstall the extra MingW you installed.
13:05:57 <vrook> elliott: It's downright reasonable to say that extensions should, to the extent possible, be written using non-implementation-specific hacks. You should agree.
13:06:05 <monochrom> so that when you run into type errors, you don't have to understand them, you just fire up genetic programming to fix them
13:06:09 <Jeanne-Kamikaze> I'm trying the export thing, but notice that the haskell mingw appears first
13:06:23 <Jeanne-Kamikaze> also, I installed msys on the custom mingw, not haskell's
13:06:23 <elliott> vrook: No, because to make extension implementation non-implementation-specific is like making language implementation non-implementation-specific.
13:06:23 <geheimdienst1> vrook: fair enough about cpp. and it's not just stuff like "#if version < 4 ...", apparently it's also using #defines for making instances. it all looks a bit unclean
13:06:31 <Jeanne-Kamikaze> now that I think of it
13:06:32 <elliott> It doesn't work. It is all implementation details.
13:06:39 <elliott> Extensions just change the language that the Haskell compiler implements.
13:06:51 <elliott> vrook: But you're being hostile without having any kind of substance to back up your claims, so I'm done with you.
13:06:58 <ezyang> Anyway. I think GHC is calling a binary that it shouldn't, and it has the wrong beahvior.
13:07:06 <ezyang> So nuking the path from orbit is the best way to be sure.
13:07:13 <vrook> elliott: what is hostile? calm down and read what I said.
13:07:14 <Jeanne-Kamikaze> ok I'll uninstall
13:07:21 <ezyang> Well, it might be a different one.
13:07:29 <ezyang> Just edti the PATH first, and see if that helps. Quicker too.
13:07:40 <monochrom> and safer
13:08:10 <elliott> vrook: I'm perfectly calm -- you're the one calling things "hacks" and telling other people they should agree with unreasonable claims without seeming to actually have a grasp on whatever issue you're arguing about...
13:08:40 <vrook> elliott: do you know what is meant by "implementation-specific hack"? It's not derogatory.
13:08:44 <monochrom> write a compiler before creating opinions
13:08:57 <vrook> It's not a put-down of GHC
13:09:13 <elliott> vrook: "hack" is certainly derogatory at least in this context
13:09:15 <vrook> It's an acknowledgement that GHC is doing things not covered by the language itself.
13:09:20 <elliott> Perhaps you should define what you actually mean.
13:09:34 <monochrom> anyway, I thought we're done
13:09:42 <vrook> elliott: you are easily offended. I'm not going to address your offense. I will focus on the argument.
13:09:49 <elliott> monochrom: It's hard to be done.
13:09:54 * elliott tries harder.
13:09:57 <geheimdienst1> elliott: as near as i can tell, his claim seems to be that using the c preprocessor (as Control.Monad.Trans.Control) is unclean
13:10:19 <monochrom> CPP does not account for "9 extensions already"
13:10:47 <Jeanne-Kamikaze> ezyang, I cleared the extra mingw from the path variable, and still same error :/
13:10:52 <geheimdienst1> vrook: btw, check out template haskell, it might replace the c preprocessor for you
13:11:13 <elliott> geheimdienst1: he seems to be making a complaint about extensions in general. vrook: the path for extensions is either into the language because they're a good idea, or rejected because they're a bad idea. Extensions are just modifications to the language. If you want Lisp, you know where to find it, but you can't implement a major type-system extension as a Lisp macro; you would have to modify the innards of your existing type-system macros. The s
13:11:13 <elliott> ame applies for Haskell language extensions. Implementing them requires changing core implementation facilities because they extend the semantics of the language in very non-trivial manners in many cases.
13:11:17 <elliott> That is all I will say on the matter.
13:12:01 <mike-burns> Making that easier sounds nice.
13:12:38 <vrook> elliott: your assumption seems to be "status quo or trolling".
13:12:39 <elliott> mike-burns: So does solving the halting problem. Nice isn't practical.
13:12:42 <vrook> is that right?
13:12:55 <monochrom> GHC is already a syntax transformer. from whatever is in *.hs files to core.
13:12:58 <vrook> suggestions contrary to the status quo are trolling, is that right?
13:13:12 <mike-burns> elliott: But if someone did it I doubt we'd complain.
13:13:23 <elliott> vrook: No, my assumption is "if you make bold claims of implementations being 'hacks' and point to 'proof' that doesn't actually prove anything, you should have a proposed system to back up your claims if you're going to be hostile, or you're just being disruptive". And now this is really the very last word I'll say on the matter.
13:13:38 <geheimdienst1> vrook: take it as an indication that you didn't very clearly or specifically express what your proposal is (what the syntax transformer thing should do, what it would change about extensions, etc.)
13:13:48 <vrook> elliott: the use of the C preprocessor is a hack, in the derogatory sense.
13:14:16 <PaulRS> hello, i'm having problems with Graphics.Vty. When i try to relase the terminal through release_display the terminal becomes somewhat unresponsive. Any ideas what could be causing this, or which command i should use instead of release_display ?
13:14:26 <Jeanne-Kamikaze> oh shit, it works ezyang
13:14:26 <vrook> "implementation-specific hacks" are not derogatory toward the hacks themselves, but they indicate a deficiency being address in an ad hoc manner.
13:14:35 <ezyang> Jeanne-Kamikaze: *sigh* I guessed as much
13:14:36 <monochrom> my assumption is "publish or perish". where is your implementation? publish or perish.
13:14:42 <Jeanne-Kamikaze> ty :)
13:14:55 <Jeanne-Kamikaze> you're the boss now
13:15:03 <ezyang> It could be any of the other library's fault. I suggest binary searching and figuring out specifically which one.
13:15:16 <ezyang> And then posting it to your ticket, so other people may Google and be enlightened :-)
13:15:18 <tomprince> vrook: People don't disagree wrt cpp.
13:15:49 <tomprince> vrock: Regarding other extensions, many of them have made it into Haskell2010. I suspect more will be in the following standard.
13:15:51 <ezyang> (Maybe Windows GHC should also be a bit more strict about auditing the binaries its using)
13:16:18 <ddarius> tomprince: Very few made it into Haskell 2010.  The differences between Haskell 2010 and Haskell 98 are minute.
13:16:30 <vrook> The fact that language extensions use GHC-specific tools is an indication that tools needs to be incorporated into haskell itself. I find it very strange that people are taking this personally.
13:16:52 <monochrom> no, I think you take this personally.
13:17:07 <monochrom> however, I don't find that strange.
13:17:30 <mike-burns> Programmers are also just people with emotions and nostalgia and all that.
13:17:35 <tomprince> They aren't taking it personally, but you are acting very confrontationally.
13:17:36 <vrook> monochrom: why do you think I take it personally? I'm not the one accusing others of trolling.
13:17:39 <ddarius> The tool GHC is using to make these extensions is Haskell.  Haskell is already incorporated into Haskell.
13:18:14 <ezyang> I'm very confused. What's the technical issue being discussed here?
13:18:31 <monochrom> perhaps there is none
13:18:34 <tomprince> I don't think anybody is quite sure.
13:19:04 <mike-burns> I thought it was whether we can reduce the amount of CPP use in Haskell packages.
13:19:14 <monochrom> CPP does not account for "9 extensions already"
13:19:25 <ezyang> Oh. It would be cool if we could reduce CPP usage.
13:19:30 <geheimdienst1> vrook: i think everyone agrees that overuse (or any use) of cpp is smelly. other than cpp, what extension specifically irks you, and what remedy do you propose?
13:19:43 <russellw> ezyang, vrook is saying Haskell would benefit from a macro system like Lisp has, thus avoiding the need to use things like the C preprocessor and various language extensions. I'm under the impression template Haskell provides some of that, though I don't know how much, haven't ever used it
13:20:06 <ezyang> Oh yeah, use Template Haskell for that...
13:20:11 <vrook> mike-burns: the mechanism by which syntax-related extensions are incorporated portably into haskell is the same mechanism by which the C preprocessor becomes unnecessary.
13:20:23 <elliott> ezyang: I'm sure Template Haskell will allow you to implement RankNTypes, MultiParamTypeClasses ...
13:20:25 <mike-burns> We're all blind men feeling the elephant that is vrook 's comment.
13:20:26 <elliott> (which were some of the 9)
13:20:34 <ddarius> The vast majority of extensions are not syntax-related.
13:20:38 <elliott> Sigh, okay, I'll bite.
13:20:48 <ezyang> Oh, is that the contentious claim here?
13:20:49 <elliott> vrook: Look at that file: cpp is only used for cabal versioning constraints, not any kind of code generation.
13:20:59 <elliott> This is by far the vastly most common use for the CPP extension.
13:21:07 <silver> if extension is not implementation-dependend it's part of the language and not extension anymore
13:21:12 <elliott> It needs replacing, but cpp is not used "in the large" at all in this example, so your claim is nonsense.
13:21:12 <vrook> elliott: you didn't look, did you?
13:21:15 <mike-burns> Can we fold that into cabal, then?
13:21:19 <hpaste> Carpi pasted “assignment” at http://hpaste.org/54859
13:21:26 <elliott> vrook: The BASE() things are there, yes.
13:21:30 <elliott> vrook: They can be replicated completely with Template Haskell.
13:21:43 <ezyang> but, no one expects Lisp-style macros to implement RankN types. "What's the problem"
13:21:47 <elliott> Why it isn't used there, I cannot say; you would have to ask the maintainers.
13:22:02 <mike-burns> carpi: Use `let'.
13:22:03 <Draconx> elliott, does GHC support template haskell on all targets yet?
13:22:07 <monochrom> carpi: what the hell is "x = 3" supposed to accomplish there? just delete it.
13:22:18 <ddarius> Template Haskell isn't portable and isn't particularly stable.  CPP is really the most pragmatic solution at this time.
13:22:19 <elliott> ezyang: vrook's contention was that because there are 9 extensions at the top of http://hackage.haskell.org/packages/archive/monad-control/0.3.0.1/doc/html/src/Control-Monad-Trans-Control.html, Haskell needs syntax transformers so that language extensions aren't "implementation-specific hacks". Extracting meaning from that is up to you.
13:22:26 <ezyang> carpi: You need a 'let' before it
13:22:26 <elliott> Draconx: Not sure.
13:22:36 <elliott> ddarius: Yes, those are definitely valid reasons.
13:22:45 <elliott> But vrook didn't ask "are there plans to improve TH".
13:22:53 <elliott> That would be a reasonable question.
13:22:59 <carpi> ezyang: mike-burns monochrom .. but 'let' is in ghci?
13:23:07 <monochrom> not just ghci
13:23:15 <ezyang> OK, so it sounds like there's an instructional lesson to be given here, about how type system extensions work
13:23:20 <Draconx> elliott, last I checked, you couldn't use template haskell on ARM, for instance.
13:23:24 <vrook> elliott: let's turn the question around. Why are you against taking the GHC extensions you see there and constructing a portable framework by which all Haskell extensions do not require implementation-specific functionality?
13:23:47 <ezyang> vrook: Here ya go http://blog.ezyang.com/2011/03/type-tech-tree/
13:23:50 <vrook> (well, most extensions or a good number)
13:23:54 <elliott> vrook: I'm not against it at all. I think it (a) won't work, (b) will be fragile, (c) won't truly be implementation-dependent and (d) will produce much slower programs than GHC if it does work.
13:24:00 <ezyang> carpi: Yes.
13:24:03 <elliott> vrook: But most importantly: (e) you're not offering to do that, you're just complaining.
13:24:12 <elliott> I certainly won't object if you give it a try.
13:24:24 <mike-burns> I think he just wanted feedback.
13:24:34 <ezyang> vrook: I mean, the point of a lot of type systems extensions is, way back in the day when Haskell98 was being formulated, there was this strange, new research concept called "type classes"
13:24:51 <silver> lol
13:24:56 <ezyang> And people really weren't sure how to build these in a way that wouldn't lead to sadness and tears, so they took a very conservative approach to what was allowed, and what wasn't
13:25:22 <vrook> elliott: again, you're ascribing emotive contexts to a straightforward discussion. Could you stop doing that?
13:25:23 <ezyang> But as the years rolled by, we became more and more relaxed, and allowed more and more of the "obvious" use-cases.
13:25:32 <ddarius> ezyang: s/Haskell98/Haskell/
13:25:38 <ezyang> ddarius: Fair enough.
13:25:41 <Botje> Just once i'd like to see 'sadness and tears' in a language spec.
13:25:45 <shachaf> Obvious use cases like IncoherentInstances.
13:25:46 <Cale> What is being proposed here?
13:25:52 <ezyang> Botje: See, for example, Dart :-)
13:25:54 <elliott> vrook: A great trolling technique is to start out with hostile wordings while staying ostensibly neutral, and then accusing people of being emotive when they're not incredibly friendly in return.
13:25:56 <silver> vrook, do you have particualr suggestions?
13:26:08 <geheimdienst> > "lambdabot has locked herself in her room and won't come out"
13:26:10 <elliott> Feel free to assume I'm getting incredibly worked up about this.
13:26:14 <Cale> Implementing type system extensions via preprocessors?
13:26:21 <ezyang> vrook: Anyway, that's the deal. Newcomers find the bazillion type system extensions kind of strange, but you get used to it.
13:26:26 <ezyang> The compiler even suggests which extensions you need!
13:26:30 <geheimdienst> cale: yeah that seems to have to do with the discussion
13:26:34 <vrook> elliott: it is also common that, when someone points out a shortcoming, to call that person trolling when the shortcoming is somehow close or personal to the accuser.
13:26:46 <silver> yada-yada-yafa
13:26:47 <ezyang> If you guys want to talk about trolling, go to #haskell-blah please
13:26:56 <Cale> That sounds quite sketchy to me.
13:27:10 <Cale> You might get it to work to some extent (look at SHE)
13:27:12 <elliott> vrook: I already told you I would be happy to see you implement such a system if the results were as good as what we have now.
13:27:14 <ezyang> There's also interesting research for allowing pluggable type systems.
13:27:14 <elliott> So whatever.
13:27:32 <ddarius> Cale: SHE works because the power is already there.
13:27:33 <ezyang> For example, OutsideIn(X), where X can be instantiated by some other system.
13:27:43 <Cale> ddarius: sure, that too :)
13:28:04 <Cale> But you could maybe get away with generating some unsafeCoerce magic in some cases.
13:28:11 <vrook> elliott: that is also a common pattern. Someone -- usually a relative newcomer -- sees a shortcoming. He mentions it. People say that he should shut up because he hasn't fixed it.
13:28:19 * elliott yawn
13:28:23 <Cale> but it's not going to be as solid and the features will not interact as nicely as when you have a translation of those features into a proper type system which is more general than all of them
13:28:24 <ezyang> vrook: #haskell-blah please
13:28:25 <vrook> You see this on comp.lang.lisp all the time.
13:28:36 <geheimdienst> cale: any chance of resuscitating lambdabot?
13:28:39 <Cale> sure
13:28:50 <ezyang> Cale: I wonder why lambdabot dies.
13:28:57 <vrook> ezyang: please advise elliott as well.
13:29:18 <Cale> ezyang: all kinds of reasons. If it gets disconnected from the network, for some reason it almost never realises this.
13:29:21 <ezyang> sure. Anyone interested in talking about trolling and newcomers, come to #haskell-blah
13:29:29 <ezyang> Cale: Huh. That's interesting.
13:29:44 <elliott> Cale: It's just forgetful :)
13:29:44 <mike-burns> Is that what happened this time?
13:29:45 <Cale> in this case, my screen session is just gone
13:29:50 <ddarius> lambdabot lives in a world of fantasy and make-believe.
13:29:52 <elliott> Was it that server upgrade?
13:30:00 <mike-burns> Sounds like a machine reboot, yeah?
13:30:02 <unixpro1970> test
13:30:24 <ezyang> Oh, that seems plausible
13:30:34 <sipa> Cale: have another bot online that regularly sends a message to lambdabot, and expects an answer within a certain time limit?
13:30:43 <Cale> sipa: haha
13:30:49 <ezyang> It sounds like the IRC library kind of sucks
13:30:57 <geheimdienst> sipa: we already have that, it's called everyone-in-#haskell
13:30:58 <elliott> Cale: sipa may be joking but that's not actually a bad idea :-)
13:31:12 <Cale> yeah :P
13:31:27 <shachaf> Fortunately we have #haskell serving the same purpose.
13:31:28 <Cale> Though you'd have to put it on another server
13:31:46 <elliott> Cale: I assume the server dying is an uncommon cause of lambdabot quits.
13:31:51 <Saizan> sipa: no need for another bot, lambdabot could ping itself
13:32:02 <elliott> Actually I can't imagine why it would cquit other than IRC server updates and bugs.
13:32:03 <elliott> *quit
13:32:10 <elliott> Saizan: or just ping the server...
13:32:13 <Saizan> or was it netsplitted?
13:32:46 <`Zerax`> It already pings the server as part of the IRC protocol, one would think the client just needs to respect the timeouts just as the server does.
13:33:09 * ezyang looks at the code... 
13:33:10 <elliott> `Zerax`: eh, no.
13:33:17 <elliott> most clients just PONG in response to PINGs from the server.
13:33:19 <elliott> Servers don't reply to PONGs.
13:33:57 <`Zerax`> Yes, but if you don't receive any message or PING in the timeout interval...
13:34:06 <elliott> Well, yeah.
13:34:31 <ezyang> well, here's the relevant file http://code.haskell.org/lambdabot/Plugin/IRC.hs
13:34:34 <ezyang> Someone should go make it better
13:34:54 * ddarius eyes ezyang.
13:35:31 <ezyang> "Arrr"
13:35:40 * Phyx- gives ezyang an eye patch
13:36:00 <ezyang> My default excuse for anything I don't want to do these days is "but I have to write PhD apps"
13:36:11 <elliott> ezyang: This is going to be ugly, isn't it?
13:36:19 <elliott> Oh, surprisingly non-ugly.
13:36:48 <vrook> elliott: regarding (a) - (d), those just don't make sense to me. Programmable syntax transformations are used to make code faster, not slower. At worst, the transformed code is identical to what is produced by GHC internals.
13:37:07 <clsmith_> hmm. can i do something like instance Bin a => [a] where? ghc is saying no
13:37:18 <elliott> clsmith_: *Bin [a]
13:37:26 <elliott> vrook: That doesn't work for type system extensions, because you would have to transform preserving well-typedness (or your system is useless)
13:37:36 <ezyang> clsmith_: What's the error? Should be possible.
13:37:48 <ezyang> (usually, it's overlapping instances)
13:37:54 <clsmith_> ah! yeah, i meant Bin a => Bin [a]
13:38:00 <shachaf> elliott: No, class [a]; instance Bin a => [a]
13:38:04 <elliott> shachaf: heh
13:38:16 <ddarius> It's likely IRCBase that needs to be changed, or at least extended, and less so that module.
13:38:31 <Phyx-> i just realized i've never made a socket program in haskell
13:38:51 <ezyang> I'm very surprised that lambdabot is doing raw socket programming to IRC communicate.
13:39:06 <ezyang> Guess it keeps the deps down 8)
13:39:10 <ddarius> ezyang: As opposed to?
13:39:17 <vrook> elliott: this is sort of my point. You want to build real abstractions for that stuff instead of using GHC-specific details.
13:39:52 <ezyang> 'Isn't there a library for it'
13:39:57 <elliott> vrook: Okay. Let us know when you find a way to transform Haskell2010 + GADTs into Haskell2010 without rewriting the entire source so that you're basically using Haskell2010 as a lambda-calculus compiler target.
13:40:11 <elliott> vrook: (You can't, because it massively extends the type system; there is no local transformation.)
13:40:12 <ddarius> ezyang: The one in lambdabot was one of the first ones.
13:40:19 <ezyang> Fair enough :-)
13:40:32 <vrook> elliott: again, you're going ad hominem in response to a simple observation.
13:40:40 <Cale> vrook: GHC translates all the Haskell type system features into another typed language with a more expressive type system than Haskell has (but one which lacks other nice features like inference)
13:40:41 <elliott> vrook: No, I'm just telling you it can't be done.
13:40:49 <Phantom__Hoover> Wait WTF?
13:40:49 <elliott> Not in the way you want.
13:40:53 <Phantom__Hoover> j-invariant was here?
13:40:55 <ddarius> ezyang: But yeah, lambdabot could be significantly simplified and improved by switching over to external libraries.
13:41:14 <Phantom__Hoover> Oh, no; the Tunes logs are the wrong way round.
13:41:17 <Cale> vrook: This means that all the extensions have some hope of interacting in a meaningfully useful way.
13:41:19 <ezyang> "Well, maybe it can be done, but that's an open research problem"
13:42:03 <Cale> vrook: In the past, things inside GHC were perhaps closer to what you are proposing, but we had poor interactions between GADTs and other type system features.
13:42:09 <elliott> ezyang: looks like it'd be easy enough to make \bot detect when it's been disconnected, but having it _reconnect_ is altogether harder...
13:42:20 <elliott> you'd basically want to restart the whole bot
13:42:31 <shachaf> elliott: Nothing wrong with that.
13:42:41 <elliott> shachaf: Yes, but how do you do that from within the LB monad?
13:42:50 <elliott> I suppose you could forkIO $ main >> exitSuccess :-)
13:42:52 <elliott> Erl.
13:42:53 <ezyang> A common pattern is for a daemon to die, and then some supervisor to restart it.
13:42:54 <elliott> Erm.
13:42:54 <elliott> *liftIO
13:43:05 <elliott> ezyang: yes -- but does lambdabot have such a daemon? Cale?
13:43:10 <ezyang> If the Haskell code is well written, you should be able to do this in Haskell.
13:43:39 <Cale> vrook: http://research.microsoft.com/~simonpj/papers/constraints/jfp-outsidein.pdf
13:45:43 <elliott> ezyang: I'm not sure I'd call lambdabot... well-structured.
13:45:53 <elliott> From my glances at the source.
13:46:03 <Cale> elliott: I know very little about how lambdabot works.
13:46:15 <Cale> I just keep it running :P
13:46:15 <elliott> Cale: Well, does lambdabot run in a shell loop?
13:46:19 <Cale> oh, no
13:46:23 <elliott> All that would be required is while true; do lambdabot; done
13:46:29 <Cale> yeah, I could do that
13:46:31 <elliott> Okay.
13:46:51 <hpc> that could end up causing lambdabot to joinspam, if it ever gets into a bad configuration
13:46:57 <elliott> (Does lambdabot sync its state to disk when necessary?)
13:47:00 <elliott> hpc: well, lambdabot; sleep 10; done
13:47:11 <DanBurton> we should have a lambdabot hackathon
13:47:11 <preflex>  DanBurton: you have 1 new message. '/msg preflex messages' to read it.
13:47:12 <elliott> actually
13:47:17 <elliott> I'll make it exit with a specific error code
13:47:21 <elliott> so it can be checked in the loop
13:52:57 <geheimdienst> cale: thanks a lot
13:55:37 <AlpT> getting this same error now: https://groups.google.com/group/leksah/browse_thread/thread/85a61a70c23750d4 ...
13:55:38 <elliott> Cale: heh, looks like lambdabot has a special handler that forces exits to happen with code 1 :/
13:56:01 <elliott> Cale: but while true; do lambdabot; sleep 10; done shouldn't be too disruptive -- if lambdabot gets stuck in a bad configuration, ops can ban it temporarily
13:56:46 <ddarius> elliott: That only helps if lambdabot is actually dying.
13:56:58 <elliott> ddarius: Yes, but that's the patch I'm writing now.
13:57:05 <ddarius> Okay.
13:57:12 <elliott> ddarius: If the server sends it "QUIT ...", or it doesn't get pinged by the server for 200 seconds, it dies.
13:57:24 <elliott> Crude but effective :P
13:57:51 <shachaf> elliott: I don't think you're supposed to rely on server pinging behavior.
13:57:52 <vrook> Cale: Do you envision Haskell extensions like GADTs to be forever implementation-specific, or are there abstractions emerging from it which can be standardized and implemented by other implementations?
13:57:57 <shachaf> elliott: Why not send pings to the server and wait for pongs?
13:57:57 <sm> I use supervisord to monitor/restart hackagebot, you can set the number of attempts, and the minimum time an attempt should run before it decides to give up, etc.
13:58:08 <elliott> shachaf: Because lambdabot's loop isn't written that way :-)
13:58:11 <elliott> Nobody follows the RFC anyway.
13:58:15 <Cale> vrook: Uh, I'm not sure quite what that means.
13:58:32 <sm> there is also a haskell supervisor program (angel) but it's less mature
13:58:49 <shachaf> elliott: Well, for one, you could say "any message" instead of just "ping message".
13:58:54 <tomprince> For another bot, I had it ping itself every minute, to detect network errors, and then try to reconect.
13:58:55 <vrook> Cale: Can you envision a more general Haskell which would include GADTs as a special case?
13:59:07 <elliott> shachaf: Fair enough, that'll be easy.
13:59:11 <hpc> elliott: sending PING once a minute really helps with bot uptime on foonetic, in my experience
13:59:11 <shachaf> elliott: And you could send a ping in the "haven't gotten any message in 200 seconds" case, and then wait for a pong.
13:59:12 <Cale> vrook: The larger problem with implementing these features by source translators is that source translators aren't composed together in any way which is more meaningful than "one after the other"
13:59:15 <hpc> it may help here
13:59:17 <MostAwesomeDude> Man, Template Haskell is difficult. Too bad there's not another way to iterate over type constructors.
13:59:19 <geheimdienst> vrook: i think implementations other than ghc are free to offer the GADT extension. i imagine it's well-defined enough
13:59:22 <elliott> shachaf: Nah, it's in a thread.
13:59:30 <elliott> shachaf: I don't think that'd react well with lambdabot's main loop.
13:59:50 <DanBurton> I think the idea behind GADTs is well-defined, and is implementation-inspecific.
13:59:58 <tomprince> vrook: I suspect GADTs will be availe in a future standard.
14:00:03 <Cale> vrook: Type system features are unfortunately rarely very orthogonal/.
14:00:31 <Cale> You want to be able to use one type system extension inside of your use of another quite often.
14:00:32 <hpc> i would love to see GADTs integrated into the haskell standard
14:01:28 <Cale> vrook: But the approach that Simon has taken is really pretty good: find a system more general than all the type system features you want to have, and implement them all in terms of that.
14:01:42 <Cale> vrook: That's what OutsideIn(X) is.
14:01:49 <Cale> (For an appropriately chosen X)
14:02:10 <ddarius> hpc: They will be some day.
14:02:21 <vrook> Cale: that's basically what I mean -- you need something more general. What if Haskell was defined in terms of that? It's a bit like LIsp being essentially built out of "cons".
14:03:20 <Cale> vrook: Well, that's what GHC is.
14:03:35 <Cale> GHC is a definition of Haskell in terms of OutsideIn(X). :P
14:04:05 <Cale> (amongst other things)
14:04:06 <donri> as a last resort, you can always force restart the bot every X hour or so :P
14:04:35 <vrook> Cale: Could a new Haskell implementation just implement GHC core, thereby getting all the goodies for free?
14:04:42 <ddarius> vrook: Yes.
14:04:45 <ezyang> vrook: Yes!
14:04:45 <Cale> vrook: Yeah
14:04:49 <ezyang> In fact, lots of people have done this.
14:04:58 <ezyang> (well, for certain definition of lots :-)
14:05:00 <vrook> OK so all along I was looking for the answer which is GHC core.
14:05:00 <djahandarie> YES!
14:05:27 <elliott> finally
14:05:36 <ddarius> vrook: The only problem is GHC core is an implementation-specific hack, and fairly unstable, and certainly not standardized, nor would even the GHC team want it to be.
14:05:55 <elliott> Cale: Is it a problem if lambdabot doesn't work with servers that don't PING clients? I don't know of any, but I think the RFC technically allows it; I tried to fix it, but lambdabot's main loop is hostile to it.
14:05:58 <monochrom> <monochrom> GHC is already a syntax transformer. from whatever is in *.hs files to core.
14:06:05 <monochrom> almost an hour ago
14:06:13 <ezyang> elliott: Can you fix it with lightweight threads?
14:06:23 <Cale> elliott: I don't care what you do so long as lambdabot keeps working for me :)
14:06:26 <elliott> ezyang: Yes. But I think there would be a race condition with the main loop.
14:06:28 <vrook> monochrom: sorry, I did miss that.
14:06:32 <ezyang> STM?
14:06:42 <elliott> ezyang: Is hGetLine/hPutStrLn atomic on a line-buffered Handle?
14:06:49 <ddarius> ezyang: Feel free to completely rewrite the core of lambdabot.
14:06:50 <ezyang> Yes, it's locked by an MVAr.
14:06:56 <elliott> Oh. Then yes, I can fix it.
14:06:56 <ezyang> "Arrrrrr"
14:07:02 <Cale> elliott: (You are more lambdabot's maintainer than I am at this point)
14:07:14 <elliott> Cale: I just don't want to break anything :P
14:07:22 <elliott> It's SCARY. I don't think I can even BUILD lambdabot.
14:07:35 <Cale> I think cabal should build lambdabot okay
14:07:48 <Cale> if you cabal configure && cabal build
14:07:48 <ddarius> elliott: Lambdabot builds fine.  Just ignore all the stuff you don't actually need.
14:08:39 <benmachine> elliott: why are you listening for pings? why not just send your own?
14:08:57 <elliott> benmachine: Yeah, I'm doing just that.
14:09:09 <elliott> Although only when the server doesn't send anything in 200 seconds.
14:09:39 <monochrom> yes, do that, listen for pings from servers, ping the server as plan B
14:10:10 <vrook> Is there an effort to clean up and standardize GHC core? That would seem to be the next step since extensions are so commonly used.
14:10:19 <sm> it would be nice for lambdabot source to be browsable .. could it perhaps be moved to darcsden ?
14:10:45 <ezyang> vrook: Not presently.
14:11:04 <Cale> vrook: That might hurt GHC's own progress.
14:11:15 <Axman6> vrook: I think that would make GHC harder to extend. GHC Core is designed as GHC's internal representation, and usually these are not supposed to be exposed to the outside world (at least programmatically)
14:11:17 <Cale> Standardisation is not always a good thing :P
14:11:49 <Philonous> vrook:  Do you happen to be a Scheme guy?
14:12:01 <Cale> In fact, the Haskell Report being treated as much of a standard as it is often bothers me already.
14:12:36 <geheimdienst> the question is also why you would want to standardize. if there'd be 3 other projects that would be much helped by a standard, then okay, but this doesn't seem to be the case
14:13:35 <ddarius> As I just said, standardizing core would be a huge problem and would be opposed by pretty much everyone.
14:14:03 <Saizan> there's an external core which is supposed to be more stable, though i'm not sure how well maintained and useful it is
14:15:56 <vrook> Well it wouldn't be standarized core itself per se, but using core as a reference to make sure all bases are covered. It would certainly be a monumental undertaking, but the outcome would be a language which includes Haskell and all its GHC extensions that could be implemented more than once.
14:16:36 <elliott> Cale: http://hpaste.org/54861 :-(
14:16:46 <silver> and what will happen when new extension will beg to be introduced?
14:16:50 <elliott> vrook: Yhc Core was stable, but Yhc died.
14:16:55 <ddarius> elliott: You don't need mueval.
14:17:08 <elliott> ddarius: Oh, I can twiddle flags? Okay.
14:17:30 <elliott> No, I can't.
14:17:34 <elliott> I suppose I could pacth out the mueval dependency.
14:17:41 <elliott> And then remove the plugin...
14:17:49 <benmachine> elliott: I think mueval is only used via executable?
14:17:53 <elliott> oh, indeed
14:17:55 <Saizan> core is merely a language GHC Haskell can be translated to, so standardizing something like core wouldn't produce something that includes haskell
14:18:02 * elliott removes all the runtime dependencies
14:18:08 <elliott> who cares if it runs if it builds
14:18:19 <ddarius> elliott: That's the spirit.
14:21:08 <Cale> elliott: derp, mueval is not actually a dep of lambdabot
14:21:14 <Cale> elliott: remove it from the .cabal
14:21:26 <Cale> elliott: and/or build it separately
14:30:26 <ClaudiusMaximus> any nice/elegant/magic way to handle file formats that change over time?  i have 5 already, and my app is only at v0.3 (the app only supports the latest file format, but i'll write a file-upgrade tool)   ((i say file format, i mean "deriving (Read, Show)"))
14:34:09 <ezyang> Ugh, Read Show doesn't work very well for this purpose
14:34:20 <Saizan> ClaudiusMaximus: you could try safecopy
14:34:47 <ClaudiusMaximus> ezyang: i know, but i'm more interested in the fun part of the app than parsing/pretty-printing stuff
14:35:02 <ClaudiusMaximus> ezyang: but in the long run i need to think about it...
14:35:09 <ClaudiusMaximus> Saizan: taking a look...
14:36:39 <Axman6> > read "(123, {-hello-} 456)" :: (Int,Int)
14:36:41 <lambdabot>   *Exception: Prelude.read: no parse
14:37:02 <elliott> ClaudiusMaximus: look at safecopy
14:37:12 <elliott> as used in acid-state
14:37:25 <elliott> you can implement v1 with Read/Show
14:37:32 <elliott> and migrate from that
14:37:43 <elliott> oh Saizan said
14:37:57 <ClaudiusMaximus> elliott, Saizan: yep looks awesome :)
14:51:10 <elliott> is show really a build-time dependency of lambdabot?
14:51:14 <elliott> I'd expect it only to be used in @run
14:52:08 <gwern> anyone around familiar with GF?
14:54:14 <Axman6> I have a GF, she's lovely
14:54:43 <gwern> Axman6: har har
14:54:57 <ezyang> What is GF?
14:55:21 <Axman6> yeah, my comment was a roundabout way of asking what ezyang did
14:55:41 <DanBurton> @google haskell gf
14:55:43 <lambdabot> http://www.haskell.org/haskellwiki/Applications_and_libraries/Linguistics
14:55:43 <lambdabot> Title: Applications and libraries/Linguistics - HaskellWiki
14:55:44 <gwern> ezyang: GF is teh big natural language framework in haskell
14:55:49 <ezyang> ah I see.
14:55:51 <gwern> ezyang: I want to syntax highlight English
14:56:03 <gwern> but I don't know if GF is the right tool
14:56:36 <ezyang> Why wouldn't it be the right tool?
14:57:07 <gwern> ezyang: I have no idea. I have no experience with NLP frameworks. this might be like asking whether Haddock is good at highlighting my Scheme code in my Pandoc markdown files
14:57:27 <elliott> haddock is great at that
14:57:29 <DanBurton> syntax highlight...english? o_O
14:57:34 <ezyang> OK. What kind of highlighting on English do you want?
14:59:06 <gwern> ezyang: well, nobody seems to be doing this, so I'm not entirely sure. my initial list is: typographially shrinking unimportant words; coloring parts of speech; shading by quote depth (like a programming language highlighting would); and possibly whitespace layout that reflects the clause-tree structure of a sentence like http://www.readingonline.org/articles/r_walker/ but maybe less verbose
14:59:49 <ezyang> GF seems like a reasonable candidate.
15:00:28 <ezyang> You can at the very least get parse trees.
15:01:17 <elliott> I don't suppose lambdabot's regex-compat dependency is optional. :/
15:01:55 <Axman6> it's probably used for @quote
15:02:02 <Axman6> @quote *iso*
15:02:03 <lambdabot> Plugin `quote' failed with: regex failed: (ReturnCode 13,"Invalid preceding regular expression")
15:02:06 <gwern> yeah, @quote at least is using regexps
15:02:15 <gwern> @quote is.madness
15:02:15 <lambdabot> No quotes match. Do you think like you type?
15:02:24 <gwern> @quote is.*mad
15:02:24 <lambdabot> Korollary says: darcs is free of chemical toxins of big pharma. It's made using all natural herbs and other woo. It's good for you. Cheers.
15:02:29 <irene-knapp> @quote is.*madness
15:02:30 <lambdabot> No quotes match.
15:02:33 <irene-knapp> @quote madness
15:02:34 <lambdabot> shepheb says: unsafePerformIO :: IO a -> Madness
15:02:36 <irene-knapp> hmm
15:02:48 <elliott> gwern: darn :)
15:03:04 <elliott> ok, what does it mean if I'm getting
15:03:07 <elliott> <command line>: cannot satisfy -package-id smallcheck-0.5-478447a920f874c0e35d169fd24b6bd1?
15:03:15 <elliott> when doing cabal-dev install; it's installed smallcheck
15:03:17 <irene-knapp> gwern: I love your concept
15:03:20 <gwern> elliott: reads like your deps are borked
15:03:27 <elliott> gwern: lambdabot's?
15:03:30 <gwern> elliott: ghc-pkg check is the mumbo-jumbo, I think
15:03:50 <benmachine> elliott: I got a similar problem with cabal-dev once
15:03:56 <benmachine> my solution was don't use cabal-dev >_>
15:03:57 <irene-knapp> gwern: TAG (tree-adjoining grammar) is where you probably want to start.  note that I'm not sure there's actually any particular parse algorithm for it; it's just a grammatical formalism.  but there's a very high-coverage grammar of English written in it.
15:04:07 <elliott> benmachine: but lambdabot depends on so much crap :P
15:04:14 <benmachine> elliott: yeah
15:04:20 <elliott> eh, I'll just rm -r ~/.cabal after this
15:04:23 <benmachine> I'm sure there is a fix but buggered if I know what it is
15:04:26 <benmachine> hah
15:04:28 <benmachine> nooo
15:04:30 <elliott> thank god we have bad package managers to urge us into spring cleans
15:04:41 <irene-knapp> haha
15:04:42 <irene-knapp> indeed
15:04:47 <benmachine> isn't it in ~/.ghc anyway
15:04:54 <gwern> irene-knapp: hm. keep that in mind looking at the GF docs
15:04:57 <elliott> benmachine: i just do both
15:05:00 <benmachine> oh no that's just package confs
15:05:07 <elliott> i might start recompiling ghc too
15:05:11 <elliott> you never know what will break next
15:05:33 <benmachine> heh
15:07:52 * hackagebot gruff-examples 0.3.1 - Mandelbrot Set examples using ruff and gruff  http://hackage.haskell.org/package/gruff-examples-0.3.1 (ClaudeHeilandAllen)
15:12:45 <cmasseraf> anyone knows a good article to learn the idea of a stream processor from (I just made some arrow computations but I didn't undestood when they just declared the SP type)
15:15:01 <elliott> Loading package readline-1.0.1.0 ... <command line>: can't load .so/.DLL for: ncurses (/usr/lib/libncurses.so: file too short)
15:15:03 <elliott> what the heck?
15:15:34 <irene-knapp> hmm, weird
15:16:02 <benmachine> elliott: is it a linker script?
15:16:20 <elliott> benmachine: huh. yes.
15:16:27 <elliott> INPUT(-lncursesw)
15:16:30 <parcs_> ghci uses dlopen which can't handle linker scripts
15:16:32 <benmachine> elliott: aiui GHC doesn't like those
15:16:37 <irene-knapp> is it a symlink?  maybe your linker is native-Windows, which doesn't support symlinks, and your /usr/lib is from CygWin, which does?
15:16:42 <elliott> what do I do, then? symlink my ncurses?
15:16:44 <irene-knapp> hmmm
15:16:46 <elliott> (to ncursesw)
15:16:53 <benmachine> symlink works I think
15:16:54 <elliott> destructive but oh well
15:16:57 <elliott> thanks
15:16:59 <benmachine> it always makes me feel uncomfortable
15:17:01 <benmachine> to do so
15:17:05 <benmachine> but it does do the job
15:17:10 <benmachine> there may e a better solution
15:17:15 * elliott hates messing with his package manager's files but *shrugs*
15:17:23 <elliott> maybe i'll extend my spring clean regime to reinstalling the OS
15:17:27 <elliott> then all my problems will disappear
15:17:30 <parcs_> tell ghci to link to ncursesw directly
15:17:30 <irene-knapp> haha
15:18:07 <donri> elliott: which os?
15:18:19 <parcs_> edit ~/.ghc/x86_64-linux-*/package.conf.d/readline-*.conf and  q
15:18:29 <elliott> donri: arch right now. only because it had a more recenter ghc than everyone else at the time
15:18:41 <elliott> parcs_: oh, but i just symlinked everything :P ...guess i'll reinstall that package
15:18:43 <elliott> thanks
15:18:51 <donri> figures. arch likes to break libraries. :)
15:19:00 <elliott> arch likes to break everything
15:19:02 <elliott> but at least it has ghc 7!
15:19:07 <donri> everyone does now
15:19:11 <donri> i recommend fedora
15:19:21 <parcs_> edit that file, change the extra-libraries field or whatever to ncursesw, then run ghc-pkg recache
15:19:22 <elliott> they did _now_. and i have a long-standing bias against rpm distros
15:19:27 <elliott> err, *do _now_
15:19:42 <donri> long-standing suggests outdated
15:19:56 <elliott> perhaps
15:20:10 <elliott> but it's easy to stick with the things whose brokenness I already know in complete detail
15:20:18 <donri> true :)
15:20:26 <benmachine> I install GHC 7 from source anyway
15:20:33 <benmachine> I got bored waiting for arch >_>
15:20:52 <elliott> parcs_: thanks, that worked :)
15:20:58 <parcs_> cool
15:22:40 <hpaste> irene-knapp pasted “Is this an injectivity thing or something?” at http://hpaste.org/54862
15:23:08 <irene-knapp> This is my first time using TypeFamilies, so I'm still feeling out what they can and can't do...
15:23:28 <irene-knapp> this, as I understand it, ought to be something they can do.
15:23:35 <shachaf> elliott: haskell.org/ghc has GHC 7.
15:23:56 <elliott> shachaf: well, yeah :P
15:24:26 <irene-knapp> at first I thought it wasn't "looking through" the type Key keyed0, to see that it matches the type Name TypeConstructor
15:24:26 <shachaf> They've had it more or less since the release, too.
15:24:42 <donri> GHC/Linux
15:24:56 <irene-knapp> but then I realized that actually what it's not doing is trying to figure out what possible value keyed0 could have to yield a translation that unifies
15:25:09 <irene-knapp> if it had gotten as far as Key TypeConstructor, it would be okay
15:26:14 <irene-knapp> can I not mix existential quantification and type functions in this way without breaking type inference? :(
15:26:23 <irene-knapp> if not, can anyone suggest a workaround?
15:26:28 <cgroza> Does anyone know a way to intersect 3 lists in a lazy fashion? I tried intersect l1 $ intersect l2 l3 , but that does not appear to be lazy.
15:27:09 <elliott> cgroza: um... I don't think that's possible.
15:27:32 <ezyang> Is plain intersect lazy?
15:27:39 <cgroza> ezyang: yes.
15:27:41 <ezyang> > [1..] `intersect` [1..]
15:27:43 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:27:44 <shachaf> > take 1 $ intersect [1..] (intersect [0..] [-1..])
15:27:45 <lambdabot>   [1]
15:28:48 <shachaf> Can you give an example of the behavior you want?
15:28:54 <cgroza> shachaf: just realized that. It seems my algorithm is too slow, and I thought it tries to evaluate the infinte list.
15:29:27 <cgroza> shachaf: the exact same behaviour you tried a few seconds ago.
15:29:39 <ClaudiusMaximus> > take 1 $ intersect [0,2..] [1,3..]
15:29:58 <lambdabot>   thread killed
15:29:58 <elliott> *sigh* lambdabot's "modularity" and "sanity checks" get in the way here :)
15:30:54 <ezyang> @src intersect
15:30:55 <lambdabot> intersect = intersectBy (==)
15:31:00 <cgroza> shachaf: my process is getting killed.
15:31:00 <ezyang> @src intersectBy
15:31:01 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
15:32:06 <irene-knapp> hmmm
15:32:07 <shachaf> intersect xs ys = filter (`elem` ys) xs
15:32:09 <irene-knapp> came up with a workaround
15:33:06 <shachaf> > take 1 $ intersect [-1..] (intersect [0..] [1..]) -- Should break.
15:33:22 <lambdabot>   thread killed
15:33:37 <shachaf> cgroza: So it's not very useful as an intersection function in general. :-)
15:34:56 <MostAwesomeDude> Hm. So I understand that there's special record syntax for mutating a record.
15:35:04 <shachaf> MostAwesomeDude: No.
15:35:09 <shachaf> MostAwesomeDude: There's no mutation.
15:35:20 <MostAwesomeDude> I mean, not mutating, but returning a copy of the record with only certain fields changed.
15:35:25 <Axman6> there is syntax for creating a new record from another one
15:35:29 <MostAwesomeDude> Right.
15:35:34 <shachaf> Yes, there's record {field = newValue} syntax.
15:35:37 * MostAwesomeDude is not exactly high on the blood sugar
15:35:48 <Axman6> updateFoo x y = x { foo = y }
15:35:52 <shachaf> Which is distinct from Constructor {field=initialValue} syntax, by the  way.
15:36:05 <shachaf> MostAwesomeDude: Also look into lenses.
15:36:18 <Axman6> yeah, lenses are quite cool
15:36:25 <MostAwesomeDude> Anyway, I happen to need that as a function which I can apply to a record; do I have to just suck it up and write out a lambda (\r -> r { field = value }) ?
15:37:06 <ddarius> Yes.
15:37:41 <Axman6> ezyang: the latest haskell communities and activities report says you've been improving the RTS in GHC. what've you been working on?
15:38:59 <shachaf> MostAwesomeDude: Or look into lenses.
15:40:21 <ezyang> Hmm, what time period is this HCAR dated for?
15:40:40 <MostAwesomeDude> Hm. Lenses seem maybe like a bit of overkill. Maybe I don't understand them yet.
15:40:43 <ezyang> Oh, this would probably be the runtime GC stats stuff.
15:40:47 <Axman6> about a year ago today until today? =)
15:40:57 <ezyang> Oh, an entire year!
15:41:05 <elliott> Cale: Well, I have an ugly patch here which should make lambdabot resilient to disconnections. It even compiles. The resulting lambdabot even runs. It can even @pl. Haven't tried connecting it to IRC, though... Is there a standard way of submitting patches? I've got a darcs checkout.
15:41:08 <ezyang> Man, that's such a long time ^_^"
15:41:13 <Igloo> It's only 6 months
15:41:16 <elliott> MostAwesomeDude: A lens is literally just (a -> b, a -> b -> a).
15:41:20 <elliott> MostAwesomeDude: i.e. get and set on a field.
15:41:28 <Axman6> MostAwesomeDude: they're very useful if you need to go several layers deep
15:41:28 <shachaf> elliott: You can use darcs.
15:41:34 <elliott> (data-lens uses a more efficient representation, but it doesn't matter for understanding it.)
15:41:48 <elliott> shachaf: I've forgotten how to use darcs after all this time :(
15:41:52 <elliott> Guess I should try and remember.
15:41:58 <shachaf> A data-lens is literally* just a -> (b, b -> a).
15:42:06 <elliott> * lambdabot has quit (Ping timeout: 240 seconds)
15:42:09 <shachaf> elliott: There's "darcs send".
15:42:09 <elliott> how timely
15:42:19 <elliott> shachaf: ah, OK
15:42:45 <shachaf> elliott: I don't know that Cale has commit access to lambdabot either, though. :-)
15:42:59 <elliott> lambdabot sure is a ghost town :P
15:46:04 <mzero> I have release candidates of Haskell Platform 2011.4.0.0 for Mac OS X out if anyone wants to try 'em (32bit and 64bit, 10.6 and 10.7 only)
15:46:25 <mzero> http://www.ozonehouse.com/mark/platform/
15:46:50 <mzero> mind you - these are RC, so there still could be issues or problems
15:47:39 <elliott> shachaf: Patch bundle will be sent to: cgibbard [at] gmail.com
15:47:48 <elliott> Thanks darcs.
15:47:52 <shachaf> Tharcs.
15:47:52 * hackagebot BiobaseInfernal 0.6.2.0 - Infernal data structures and tools  http://hackage.haskell.org/package/BiobaseInfernal-0.6.2.0 (ChristianHoener)
15:47:57 <elliott> Tharcs.
15:48:08 <elliott> Well, it's better than "thit".
15:48:44 <DanBurton> what does "darcs" even mean?
15:48:51 <DanBurton> is it a word?
15:48:56 <irene-knapp> it's a lowercase acronym
15:48:57 <hpc> @wn darcs
15:49:11 <Axman6> dave;s advances revision control syytem
15:49:12 <DanBurton> @google wiktionary darcs
15:49:12 <hpc> Darcs Advanced Revision Control System
15:49:14 <Axman6> system*
15:49:24 <DanBurton> lambdabot down?
15:49:26 <mzero> "We include ... verbose Infernal results, and tabulated Infernal results" -- sounds like the accounting department in Hades!
15:49:26 <elliott> DanBurton: dangerously accurate reverse carbonation simulator
15:49:29 <Axman6> it used to be Dave's right?
15:49:35 <irene-knapp> what is reverse carbonation? :D
15:49:48 <elliott> DanBurton: yes, it's because my patch hasn't been applied yet! :)
15:49:59 <elliott> Cale: Should I just "darcs send" this thing or should I actually verify it can connect to IRC first? :-)
15:53:54 <shachaf> elliott: Feel free to test it in that other channel.
15:54:15 <elliott> shachaf: How do you even get lambdabot to connect to IRC?
15:54:24 <elliott> It's a mystery!
15:54:27 <shachaf> elliott: There's a .rc file, isn't there?
15:54:57 <shachaf> You might want to modify it a bit, but it's the gist of it.
15:55:15 <elliott> shachaf: Ooh, so there is. How do you actually run it, though?
15:55:52 <shachaf> elliott: You can just type commands from the .rc file into the lambdabot prompt.
15:55:53 <Axman6> ha, just found out a package of mine is used in the Fibon benchmark suite =)
15:55:55 <shachaf> That's all it is.
15:56:02 <elliott> shachaf: Or just "rc online.rc"...
15:56:10 <shachaf> elliott: Or that.
15:56:18 <elliott> Gosh.
15:56:21 <elliott> @pl \a -> a
15:56:25 <elliott> Er.
15:56:29 <shachaf> elliott: One time I had the name "kappabot" registered with nickserv. :-(
15:56:31 <elliott> It might be using some prefix that I don't know what it is.
15:56:43 <elliott> What's \bot's default prefix?
15:57:03 <hpc> one of '@' or '?'
15:57:08 <elliott> ?pl \a -> a
15:57:15 <elliott> Well, kappabot must be broken then.
15:57:15 <hpc> it's not here
15:57:18 <elliott> Yes it is.
15:57:23 <elliott> It's just one less.
15:57:27 <hpc> shachaf: you should register "rhobot"
15:57:31 <hpc> shachaf: just to be a punny bastard
15:57:53 <shachaf> > 1 + 1
15:57:59 <elliott> shachaf: It heard that.
15:58:05 <elliott> It didn't work, of course, because I don't have mueval.
15:58:07 <elliott> But it heard that.
15:58:20 <shachaf> @echo hello
15:58:46 <shachaf> elliott: Do you have anything weird in Config.hs?
15:59:06 <elliott>         commandPrefixes = ["@","?"],
15:59:07 <elliott>         evalPrefixes    = [">"],
15:59:08 <elliott> @help
15:59:13 <elliott> :-/
15:59:21 <Axman6> kappabot: stop sucking
15:59:27 <Axman6> @help
15:59:35 <Axman6> well I've done all I can do
15:59:37 <elliott> > Why do you hear this but not the other stuff?
15:59:42 <elliott> I didn't even change any of that stuff.
15:59:51 <irene-knapp> what is reverse carbonation? :D
15:59:53 <irene-knapp> er
15:59:54 <irene-knapp> sorry, miskey
16:00:06 <elliott> irene-knapp: great for version control
16:00:19 <irene-knapp> haha
16:00:20 <irene-knapp> okay then
16:00:40 <elliott> Well, it... works enough.
16:00:44 <elliott> I guess I just messed up my build somehow.
16:01:00 <elliott> I didn't touch command-parsing at all, so that should be fine.
16:01:29 <shachaf> elliott: Maybe the ping-checker is breaking it!
16:01:40 <shachaf> To be scientific, you must test a vanilla build.
16:01:43 <elliott> shachaf: I forgot the lines where it intercepts messages beginning with @ or ?!!!!!!
16:01:55 <elliott> No that's like ten times more work than I can be bothered with.
16:02:04 <shachaf> elliott: If it's broken in both vanilla and elliottpatch, then you can proclaim that your patch works.
16:02:30 <elliott> Yeah, but I could also proclaim that my patch works anyway.
16:02:32 <elliott> Nobody can stop me.
16:03:17 <shachaf> You can also write a patch to solve the halting problem and proclaim that it works.
16:03:20 <shachaf> Proof by broken lambdabot.
16:03:36 <shachaf> Pseudonym would know.
16:03:39 <shachaf> Pseudonym knows everything.
16:03:46 <Pseudonym> Only because I know how to use Google.
16:04:04 <shachaf> Pseudonym: Didn't you write lambdabot or something?
16:04:22 <Pseudonym> It's been almost completely rewritten since, but yes.
16:04:32 <elliott> Pseudonym: Hey, I have someone to blame! Great.
16:04:49 * Pseudonym checks the logs
16:05:09 <elliott> Pseudonym: I'm rewriting lambdabot to not fall down whenever it gets disconnected.
16:05:18 <elliott> Pseudonym: How I achieved this would probably horrify you.
16:05:37 <shachaf> elliott: You're rewriting lambdabot to *die* whenever disconnected, instead.
16:05:41 <Pseudonym> If you looked at the version I last hacked on, you'd be even more horrified.
16:05:41 <elliott> shachaf: No, I fixed that.
16:05:45 <shachaf> Which is clearly far superior to falling down.
16:05:48 <elliott> Now it, uh, does something worse.
16:05:53 <hpc> lol
16:05:54 <Pseudonym> Clue: It predates Data.Map.
16:05:54 <shachaf> Oh?
16:06:13 <elliott> How do you get the diff for a change with darcs?
16:06:20 <elliott> I can't really *tell* this, just show it.
16:06:55 <shachaf> elliott: Doesn't darcs send give you a .dpatch?
16:08:05 <hpaste> elliott pasted “lambdabot patch” at http://hpaste.org/54864
16:08:12 <elliott> shachaf: Don't judge me.
16:08:18 <elliott> Pseudonym: Is Data.Map really that recent?
16:08:32 <Pseudonym> No, but lambdabot is really that old.
16:08:38 <Pseudonym> Kind of.
16:08:38 <shachaf> elliott: I think you're looking for "is lambdabot really that old?".
16:08:50 <Pseudonym> I didn't have the most recent GHC at the time.
16:08:51 <elliott> Heh, I like how I messed up the indentation in that addServer thing.
16:08:58 <elliott> Thankfully it's non-layout, so it doesn't matter!!!!
16:10:21 <irene-knapp> okay then
16:10:23 <irene-knapp> er
16:10:25 <irene-knapp> I keep doing that ><
16:10:36 <shachaf> Saying "okay then"?
16:10:57 <irene-knapp> no, tabbing to Terminal and hitting up-then-return to re-execute the previous command, but landing in the IRC window instead and thereby repeating myself
16:11:08 <shachaf> okay then
16:11:11 <shachaf> Oops.
16:11:21 <elliott> okay then
16:11:25 <irene-knapp> haha
16:15:17 <MostAwesomeDude> Is there a full if-else for monads, like Control.Monad.when but with an else branch?
16:15:43 <shachaf> MostAwesomeDude: There's... if...
16:15:50 <elliott> MostAwesomeDude: a >>= \b -> if b then x else y
16:15:57 <Pseudonym> It depends what semantics you want, though.
16:15:57 <elliott> or a >>= bool x y if you have bool
16:15:58 <shachaf> elliott: That's not what when does.
16:16:02 <hpc> MostAwesomeDude: the indentation rules of if-then-else in do-blocks can be odd
16:16:06 <elliott> shachaf: Oh, right.
16:16:09 <elliott> MostAwesomeDude: Yes, it's called if.
16:16:10 <MostAwesomeDude> hpc: Yes, as I am finding.
16:16:18 <Pseudonym> In a nondeterminism monad, you'd like if-then-else with soft cut.
16:16:22 <elliott> MostAwesomeDude: Indent if like this:
16:16:22 <elliott> if foo
16:16:24 <elliott>   then ...
16:16:25 <hpc> in fact, the rules are kind of odd anyway
16:16:25 <elliott>   else ...
16:16:31 <elliott> Indent it like that everywhere, and you'll have no troubles.
16:16:43 <DanBurton> @let ifM b t f = do b' <- b; if b then t else f
16:16:51 <shachaf> {-# LANGUAGE DoAndIfThenElse #-}
16:16:52 <elliott> DanBurton: but that's not what when doeds :)
16:17:10 <DanBurton> what does when do?
16:17:19 <DanBurton> it's basically the same
16:17:20 <elliott> when b m = if b then m else return ()
16:17:22 <elliott> it's not.
16:17:33 <DanBurton> but he asked for an else branch
16:17:38 <Pseudonym> DanBurton: ifM :: (MonadSomething m) => m a -> (a -> m b) -> m b -> m b
16:17:46 <MostAwesomeDude> @ty Control.Monad.when
16:17:49 <elliott> DanBurton: so? yours has the condition as a monadic computation
16:17:50 <cmasseraf> Anyone knows why I'm getting this error: `>>>' is not a (visible) method of class `Arrow'
16:17:51 <elliott> which is not like when at all
16:17:59 <elliott> cmasseraf: Arrow is a subclass of Category now
16:18:03 <elliott> implement Category, with (.) instead of (>>>)
16:18:05 <elliott> (it's the same, just flipped)
16:18:10 <DanBurton> I was under the impression that such was desired
16:18:18 <cmasseraf> oh ok =)
16:18:22 <cmasseraf> thanks
16:18:27 <Axman6> rebindable syntax is anothe roption
16:18:27 <mzero> cmasseraf: 'cause it is a function defined in Control.Category
16:18:32 <Axman6> another*
16:18:38 <hpc> cmasseraf: if you are using Category stuff, you will want to hide id and (.) from Prelude
16:18:51 <mzero> d'oh - elliott beat me to it!
16:18:54 <hpc> the Category ones are more general, and the instance for (->) gives you the Prelude versions
16:19:20 * mzero wishes bool was in the standard Prelude...
16:19:29 <hpc> bool?
16:19:54 <elliott> DanBurton: well, ok, I agree it's a vague question :)
16:19:55 <Pseudonym> mzero, it has to be built-in to implement if-then-else.
16:19:57 <elliott> hpc: bool a b c = if c then a else b
16:20:04 <elliott> Pseudonym: bool not Bool
16:20:07 <mzero> exactly!
16:20:07 <elliott> and Bool is not built in anyway
16:20:19 <elliott> it desugars to case on Bool, which is defined in Prelude, which is Haskell code, not built-in
16:20:19 <hpc> elliott: ive seen that implemented more often as (t ?? f) p = if p then t else f
16:20:28 <elliott> hpc: meh -- infix overload
16:20:29 <mzero> Pseudonym: it may be built-in, but it isn't exported!
16:20:32 <elliott> hpc: bool composes better
16:20:39 <elliott> mzero: i think Pseudonym thought you meant Bool itself
16:20:45 <Pseudonym> Yes.
16:20:47 * elliott has not seen bool anywhere built-in
16:20:47 <mzero> ah, I didn't
16:21:14 <mzero> Maybe and maybe, Either and either --- why no bool for Bool.... :-(
16:21:22 <elliott> make a proposal? :)
16:21:26 <elliott> i think there's a process for it
16:21:29 <mzero> of course, strangely, if it were kept consistent with the others, it would probably be
16:21:37 * gwern sends off a reqest for info to the GF mailing list; but it's moderated
16:21:38 <mzero> bool a b c = if c then b else a
16:21:42 <hpc> clearly we need a function "io"
16:21:48 <mzero> and that would probably feel strange
16:22:10 <DanBurton> this should go in TheRealPrelude
16:22:34 <elliott> hpc: io :: (Monad m) => (IOPrim a -> m a) -> IO a -> m a?
16:22:50 <elliott> IOPrim a is of course defined as newtype IOPrim a = IOPrim (IO a) for extensibility
16:23:02 <hpc> lol
16:23:28 <shachaf> We need a function foo a b c = if b then a else c
16:23:35 <shachaf> Because "b" has to stand for "boolean".
16:23:48 <elliott> taxi c a b = if b then c else a
16:25:24 <elliott> preflex: tell Cale Here's a patch that compiles, works, and connects to IRC; some problems on my end but not something that this could cause: http://hpaste.org/raw/54865
16:25:24 <preflex>  Consider it noted.
16:25:29 <elliott> preflex: tell Cale (No wrapper script required.)
16:25:29 <preflex>  Consider it noted.
16:25:42 <elliott> There, now I can forget about this forever.
16:26:52 <Axman6> famous last words
16:27:09 <elliott> Axman6: You're the first to snark; it's your problem now. These are the rules.
16:27:16 <elliott> If it breaks, you gotta fix it.
16:27:30 <Axman6> I'll fix it
16:27:35 <Axman6> by filing bug reports to you
16:27:50 <elliott> Axman6: I'll delegate them to you.
16:27:58 <irene-knapp> haha
16:27:58 <Pseudonym> Not accepting the patch is an acceptable answer.
16:27:59 <irene-knapp> ><
16:28:15 <elliott> Pseudonym: That's the clever bit! Cale's the one who has to do that.
16:28:20 * Axman6 will blog about how horrible elliott is
16:28:29 <elliott> Nooo! My reputation!
16:29:01 <Axman6> "Every time someone submits a bug, he kills a kitten!"
16:29:31 <Axman6> "And if he ever does actually fix anything, it's only so it will make the death of these kittens even more painful!"
16:30:02 <shachaf> elliott: Isn't your reputation "that one person in #esoteric who does bad things"?
16:30:14 <elliott> Axman6: Wait, I thought you were going to write a blog post full of _false_ allegations.
16:30:33 <Axman6> I'm starting with the not so bad true ones
16:31:12 <shachaf> elliott: If you mix some true ones in, then readers can never know.
16:31:20 <hpc> Axman6: for extra fun, you should sneak in stuff like "he comments his code"
16:31:31 <elliott> "He once wrote a lambdabot patch that INTRODUCED TAB INDENTATION ACCIDENTALLY".
16:31:36 * elliott shame
16:31:48 <elliott> hpc: Haha, well that's a ridiculous allegation if I ever heard one.
16:31:54 <Axman6> "Sometimes he uses x as a type veriable, and a as a pattern variable!"
16:32:15 <elliott> I could never, ever use x as a type variable.
16:32:29 <elliott> Even if I'd already used 24 type variables already.
16:32:38 <Cale> heh
16:32:38 <preflex>  Cale: you have 2 new messages. '/msg preflex messages' to read them.
16:32:43 <elliott> Er, 23. I think.
16:32:47 <elliott> Counting is hard.
16:32:47 <ddarius> What's wrong with x as a type variable?
16:33:03 <elliott> x is a value! If you do that, Haskell will become dependently-typed.
16:33:05 <Axman6> "Once, I saw him use StateT result predicate monad as a type, the horrer!"
16:33:14 <Axman6> horror even
16:33:19 <elliott> The terms will break through the colon and you'll need major surgery to correct it.
16:33:34 <jk4> oh hi Axman6
16:33:46 <Axman6> 'lo
16:33:47 <jk4> not hanging out in #ada ? :)
16:33:58 <hpc> Axman6: you make me want to write evil haskell code
16:34:10 <hpc> i wonder how many ContT layers i could stack before my head hurts
16:34:11 <Axman6> no, that course finished, and I have no time for Ada at the moment :(
16:34:18 <jk4> bummer
16:34:33 <Axman6> I can never think of anything to write in Ada anyway
16:34:58 <elliott> Ada has merits?
16:35:03 <Axman6> many
16:35:05 <jk4> haskell has merits?
16:35:06 <roconnor> elliott: bound checking
16:35:19 <elliott> roconnor: yeah, but all you need to add is a g...
16:35:46 <roconnor> that's all I remember about Ada
16:35:53 <roconnor> maybe it has some sort of module system too
16:36:05 <jk4> it has a packages, yes
16:36:06 <Axman6> Ada has far more than that' it's got some of the most powerful concurrency primitves of any language for one
16:36:16 <elliott> oh well that sounds interesting.
16:36:17 <jk4> concurrency is built in
16:36:19 <elliott> does it have lambdas? :p
16:36:23 <Axman6> no
16:36:27 <roconnor> Axman6: really?  I find that hard to believe
16:36:40 * elliott is sceptical of the concurrency primitives of an ostensibly imperative language, to be quiet honest.
16:36:41 <elliott> quite
16:37:01 <hpc> to be loudly honest ;)
16:37:15 <ddarius> "It is found that the scattering of coherent light by an electron describing a well-behaved trajectory can yield chaotic spectra when the laser ponderomotive force strongly modulates the electron's proper time."
16:37:15 <irene-knapp> >< >< >< ><
16:37:23 <Axman6> lambdas would probably make verifying your code correct more difficult (where correct usually has real-time constraints)
16:37:25 <roconnor> Well I'll be damned
16:37:30 <irene-knapp> have to use Template Haskell, in order to generate my Typeable* and Data instances
16:37:37 <roconnor> (tasks, synchronous Message passing, protected objects and nondeterministic select statements)
16:37:55 <hpc> irene-knapp: "have to"?
16:38:08 <elliott> irene-knapp: deriving (Typeable)
16:38:15 <irene-knapp> because, see, you can't derive a Typeable* instance on a type of kind :: (* -> *) -> *
16:38:18 <elliott> Oh.
16:38:20 <irene-knapp> haha
16:38:29 <elliott> You can't make an instance for those full stop.
16:38:33 <irene-knapp> yes, you can
16:38:40 <elliott> How?
16:38:42 <Axman6> the asynchronous transfer co control stuff is kinda cool. you say something like "Do this stuff, until this other entry (read call to a porotected procedure) succeeds, then immeduately kill the studff that was running"
16:39:03 <irene-knapp> mkTyCon :: Word# -> Word# -> String -> String -> String -> TyCon
16:39:11 <irene-knapp> followed by
16:39:16 <irene-knapp> mkTyConApp :: TyCon -> [TypeRep] -> TypeRep
16:39:32 <elliott> irene-knapp: Ouch.
16:39:40 <irene-knapp> you can derive Typeable1 on the * -> * parameter, use that to build your manual Typeable1 instance, and then derive Data on the whole thing
16:39:44 <irene-knapp> yeah I know!
16:39:46 <elliott> irene-knapp: But what class is it an instance of?
16:39:51 <elliott> Typeable1 is (* -> *) -> *, no?
16:39:56 <elliott> * -> Constraint
16:39:56 <elliott> :p
16:40:12 <irene-knapp> elliott: oh hmmm :/
16:40:48 <irene-knapp> yes, I guess it is
16:41:35 <Axman6> jk4: so what brings you here?
16:41:35 <irene-knapp> okay, that's okay :) I just need to define a new class TypeableInAComplicatedWay, right
16:41:54 <irene-knapp> and then instance TypeableInAComplicatedWay a => Typeable a
16:41:58 <elliott> Typeable1Of1
16:42:02 <irene-knapp> yes, that's a good name
16:42:11 <elliott> This one goes up to Typeable11.
16:42:21 * irene-knapp nods
16:43:18 <ddarius> irene-knapp: The kind polymorphism will allow a generic Typeable class to be made.
16:43:32 <irene-knapp> ddarius: hmmmmm, that would be very, very nice!
16:43:35 <Axman6> will it be made though?
16:43:35 <irene-knapp> ddarius: is that in HEAD yet?
16:43:52 <ddarius> Axman6: Eventually.
16:43:52 <irene-knapp> also, I really wanted kind polymorphism for my own code, too, ahhaahahah
16:43:56 <elliott> It's for 7.4, I think, no?
16:44:16 <irene-knapp> hmmm
16:44:22 <irene-knapp> of course, I can't build HEAD still
16:44:29 <irene-knapp> because I decided it was more fun to write my own code than debug GHC ><
16:44:34 <augur> byorgey: the sftom video on vimeo is busted :(
16:44:36 <irene-knapp> so I can't really use it yet anyway
16:44:40 <augur> do you have a non-busted copy?
16:45:31 <DanBurton> rumor is that GHC 7.4 and corresponding Haskell Platform will be out by the end of the month. Anyone know if this is on track still?
16:46:16 <elliott> the haskell platform is coming out next month, every month
16:46:32 <Axman6> DanBurton: mzero may know
16:46:33 <shachaf> elliott: Also last month.
16:46:38 <shachaf> Jam tomorrow and jam yesterday.
16:46:50 <donri> It also already came out, this month.
16:46:52 <augur> byorgey: ah! its not as busted as i thought
16:46:53 <shachaf> I hope the next Haskell Platform includes GHC 7.4. :-(
16:47:01 <augur> i was on windows and my volume there is wonky, but on mac os its ok!
16:47:02 <augur> hooray!
16:47:03 <augur> :D
16:47:20 <DanBurton> shachaf: i'm pretty sure it will; I think they are just delaying release until 7.4 releases
16:47:31 <elliott> Isn't that what they said about 7.2?
16:47:43 <shachaf> elliott: 7.2 is a "preview release".
16:47:52 <elliott> shachaf: Only 'cuz it turned out to be broken.
16:47:52 <Axman6> maybe 7.2 was GHC's vista release
16:47:55 <shachaf> That's why the minor version number is even, see.
16:47:57 <shachaf> elliott: Right.
16:48:20 <donri> Haskell 98 ^w ME
16:48:32 <DanBurton> lol
16:48:35 <Axman6> ha
16:48:49 <elliott> ^w?
16:48:53 <donri> delete-word
16:49:09 <Axman6> try it
16:49:18 <Axman6> if you're on a decent OS
16:49:19 <elliott> Oh.
16:49:21 <elliott> It's ^W.
16:49:31 <donri> well, it can also be close-tab/window, depending on your irc client
16:49:34 <elliott> > ord 'W' - ord '@'
16:49:34 <donri> so maybe not try it *here*
16:49:38 <elliott> > ord 'w' - ord '@'
16:49:45 <elliott> If lambdabot were here she'd have proved me right.
16:49:47 <Pseudonym> @botsnack
16:49:53 <elliott> Thanks, lambdabot.
16:49:55 <shachaf> I have ^W bound to "Halt and Catch Fire".
16:50:00 <donri> Uhmyes, ^W, duno why I made that lowercase
16:50:11 <shachaf> donri: Because you don't use shift?
16:50:30 <elliott> But that isn't how the notation works. :'(
16:50:38 <elliott> GHC needs an -XHaskell14 flag.
16:50:53 <donri> Irreluvant, as elliott notes the notation is ^W.
16:51:03 <elliott> It's really irreluvant.
16:51:05 <Axman6> is that the Haskell for 14 year ods?
16:51:07 <Axman6> olds*
16:51:12 <elliott> Yes. But also Haskell 1.4.
16:51:17 <Axman6> where lol = fix error
16:51:36 <donri> infixl !!!!!!!!! 1111
16:51:42 <elliott> :D donri++
16:52:27 <Axman6> i like the WTF operator in C: ??!. you can do thingThatShouldNeverBeFalse ??!??! omgMaybeWellTryThis
16:53:31 <elliott> Axman6: Isn't ?? a GNU extension?
16:54:03 <donri> ??!! is the ternary in perl6
16:54:14 <Axman6> no, it's C's trigraphs
16:54:20 <Axman6> ??! -> |
16:54:44 <shachaf> Perl12 uses ???!!!
16:54:56 <donri> perl for 12 year olds?
16:54:58 <elliott> Axman6: ah
16:55:00 <Draconx> this one's fun in C: // omg why the hell does this happen !??/
16:55:03 <hpc> donri: you mean PHP?
16:55:17 <elliott> Draconx: surely /* ?
16:55:17 <donri> ah!
16:55:17 <Axman6> ha
16:55:22 <Draconx> elliott, no.
16:55:28 <elliott> Draconx: What does !?? become?
16:55:31 <Draconx> elliott, the // is very important.
16:55:38 <Draconx> elliott, nothing, but the ??/ becomes a backslash.
16:55:44 <Axman6> ha
16:56:02 <donri> wat.
16:56:08 <hpc> oh, so it comments the line below too?
16:56:11 <Draconx> yeah.
16:56:15 <hpc> lol
16:56:38 <elliott> Draconx: heh
16:56:48 <elliott> i wonder if emacs handles that
16:57:22 <donri> http://stackoverflow.com/questions/1642028/what-is-the-name-of-this-operator
16:57:26 <irene-knapp> hahaha trigraphs eh?
16:57:29 <ddarius> ??/ becomes a backslash?  Wtf?
16:57:45 <irene-knapp> trigraphs are part of the C standard used for writing C on a C=64 keyboard
16:57:55 <irene-knapp> (and possibly others, but that's the only one I've seen where they'd be needed)
16:57:58 <shachaf> ddarius: It's disabled in gcc by default nowadays.
17:00:37 <ddarius> shachaf: I'm aware of trigraphs.  I just find the choice of ??/ to be \ to be rather odd choice.
17:01:21 <shachaf> ddarius: Why?
17:01:57 <shachaf> Most of them are mnemonics in some way or another.
17:02:12 <ddarius> Let's have ??+ be -.
17:02:48 <donri> Let's have que be ¿
17:05:27 <cmasseraf> how do I hide something from the prelude in GHCi, I just keeps there
17:06:01 <shachaf> cm: :m - Prelude
17:06:25 <shachaf> Then import Prelude hiding ((.),id)
17:06:33 <geheimdienst> cmasseraf: you can put "import Prelude hiding (zip)" at the top of your file for example
17:06:53 <cmasseraf> thanks
17:06:53 <shachaf> geheimdienst: Doesn't work in ghci; you need to :m -.
17:07:18 <geheimdienst> right, he said ghci, sorry
17:22:36 * ddarius should move to Arizona.
17:23:41 <shachaf> ddarius: Why Arizona?
17:23:55 * geheimdienst should drink some arizona
17:26:28 <ddarius> shachaf: I keep wanting to interact with physicists in Arizona.
17:27:16 <mzero> DanBurton: I just put up a release candidate of Haskell Platform 2011.4.0.0 for Mac OS X
17:27:20 <mzero> is that what you're looking for
17:27:20 <mzero> ?
17:27:26 <shachaf> Particular physicists?
17:28:01 <shachaf> mzero: Is there going to be a "Linux" Haskell Platform that's not so annoying to install?
17:28:07 <geheimdienst> shachaf: dude, those are called particle physicists
17:28:22 <mzero> I don't know - I only do the Mac packaging -- but I suspect not, since there is no single Linux packaging standard
17:28:39 <shachaf> mzero: I don't mean packages.
17:29:13 <shachaf> Right now to get it working without your distributions' packages, you have to download GHC manually and then get the Haskell Platform source and fiddle with that.
17:29:20 <shachaf> It would be nice if it was just one package like everyone else gets.
17:31:20 <geheimdienst> shachaf: what linux distribution? i find it perfectly fine to get ghc via distro packages, everything else via cabal (arch linux)
17:31:36 <shachaf> geheimdienst: Well, not if you want a recent version.
17:31:41 <mzero> shachaf - don't know - I'm not a linux packaging adept!
17:31:44 <shachaf> In, say, Ubuntu.
17:31:53 <shachaf> mzero: Who's the person to complain to?
17:32:07 <mzero> I doubt complaining to anyone would help
17:32:10 <mzero> :-)
17:32:17 <mike-burns> Mark Shuttleworth.
17:32:17 <mzero> Linus?
17:32:27 <shachaf> mzero: Who does the Linux packaging?
17:32:31 <elliott> shachaf: There's a patched cabal on Hackage now. It sounds like a bad idea to me.
17:32:33 <geheimdienst> shachaf: if the main ubuntu repos don't have it, isn't there one of those ppa thingies that offer ghcs which are more recent?
17:32:58 <mzero> There isn't one, shachaf, there is one per major linux distro -- because that's the state of Linux packaging, alas
17:33:09 <shachaf> mzero: I see.
17:33:41 <shachaf> Can't there just be a make install-style tar.gz that includes GHC and HP binaries?
17:33:55 <cmasseraf> anyone could enlight me on how this works: (oL,sL) = unzip $ f $ zip iL $ stream sL where stream ~(x:xs) = x:stream xs
17:34:09 <cmasseraf> I don't get this recursive pattern :/
17:34:10 <elliott> stream doesn't appear to do anything at all.
17:34:15 <elliott> Wait, yes it does.
17:34:28 <cmasseraf> I know it breaks the stricness of zip
17:34:42 <elliott> stream _|_ = repeat _|_, stream (x:xs) = x : stream xs.
17:34:46 <mzero> shachaf - different linux distros put different parts in different places
17:34:47 <elliott> stream [] = repeat _|_ too.
17:34:49 <mzero> so, alas, no
17:35:24 <geheimdienst> shachaf: how about this for a start? https://launchpad.net/~someone561/+archive/ppa
17:35:30 <shachaf> mzero: But when you get the source package and do "make install" it does *something*.
17:35:58 <cmasseraf> elliot: I did not understand your contruction there
17:36:04 <shachaf> geheimdienst: I'm aware of the PPA, but that's pretty distribution-specific and also just someone561's packages rather than anything pseudo-official.
17:36:18 <geheimdienst> shachaf: right, sure
17:36:18 <mzero> true 'nuf, shachaf  - but I don't think that install location matches standard linux locations....
17:36:36 <shachaf> mzero: It just installs in /usr/local/...
17:36:37 <mike-burns> There's a standard Linux installation location?
17:36:40 <shachaf> It's pretty standard.
17:37:03 <mzero> .... but in any event - why not offer to be the "tarball Linux" packager?
17:37:25 <shachaf> I can do that.
17:37:35 <shachaf> Whom do I complain to for that?
17:37:41 <mzero> well, many systems want things in /usr/opt or /usr/local/opt ... and the location of various link libs isn't always the same...
17:37:53 <cmasseraf> elliot: http://pastebin.com/ngcU0HhV
17:37:55 <mauke> The paste ngcU0HhV has been copied to http://hpaste.org/54867
17:37:57 <mzero> .... I don't know really - after all, I develop on Mac!
17:38:03 <cmasseraf> it's line 16~18
17:38:19 <shachaf> mzero: And somehow downloading the GHC binary works for me anyway. :-)
17:38:26 <shachaf> The package lets you specify a prefix when you install.
17:38:32 <cmasseraf> the rest I managed to understand but this loop I can't get it
17:39:22 <mzero> shachaf: e-mail haskell-platform@projects.haskell.org
17:43:49 <elliott> mm_freak: btw, i was trying to install netwire to take a look at it, but it need updating for monad-control 0.3... just a head's up :)
17:44:21 <elliott> cmasseraf: I'm not the best person to ask, I don't think. But stream xs basically turns xs into an infinite list no matter what xs is.
17:44:58 <mm_freak> elliott: i have already updated it locally, but haven't tested it enough to upload
17:45:00 <shachaf> elliott: If only you thought! You would be much better at answering these sorts of questions.
17:45:14 <elliott> Thinking is hard.
17:45:15 <elliott> mm_freak: ah, ok
17:45:21 <mm_freak> elliott: you can expect the updated version in a couple of hours
17:45:26 <elliott> cool
17:45:42 <cmasseraf> elliot: I know that stream is used to break the strictness of the zip function
17:45:51 <cmasseraf> but the loop itself is killing my brain
17:45:58 <cmasseraf> I can't get it
17:46:21 <elliott> cmasseraf: well, do you know what the ~ does?
17:46:36 <elliott> ~(x:xs) is a lazy pattern match. it doesn't force the argument
17:46:45 <elliott> when x or xs is forced, /then/ it tries to match on the argument
17:46:54 <elliott> and is (error "...") if the list turns out to be [] instead
17:47:04 <elliott> now, stream never forces xs, just x
17:47:12 <elliott> so stream (repeat 1) = 1 : 1 : 1 : 1 : 1 : ...
17:47:35 <elliott> stream [1,2] = 1 : 2 : error "hey, [] isn't (x:xs)! (in x)" : stream (error "hey, [] is't (x:xs)! (in xs)"
17:47:53 <elliott> stream (error "hey, [] isn't (x:xs)! (in xs)") = another error : another error : ...
17:48:06 <elliott> (because forcing x forces (error "..."), which causes the whole thing to be (error "...")
17:48:09 <elliott> cmasseraf: hope that helps...
17:48:28 <elliott> basically it turns any value of type [a] into a lazy infinite stream of its elements, and does really weird things on finite lists :)
17:48:38 <elliott> (terminates them with an infinite list of undefined values)
17:50:22 <cmasseraf> the thing is... it will never give an error since the iL list is is smaller or equal to the sL in "zip iL $ stream sL"
17:51:28 <elliott> cmasseraf: right
17:51:47 <elliott> cmasseraf: i'm really not sure what it's being used for
17:51:59 <cmasseraf> I've sent you a pastebin
17:52:04 <elliott> cmasseraf: but if it helps, it means that the pattern-matches zip does on (y:ys) for its second arguments always succeed
17:52:06 <cmasseraf> http://pastebin.com/ngcU0HhV
17:52:06 <mauke> The paste ngcU0HhV has been copied to http://hpaste.org/54867
17:52:07 <elliott> without even examining the value
17:52:13 <elliott> yeah, I saw it
17:52:15 <elliott> I can't quite understand it
17:52:30 <elliott> oh!
17:52:30 <cmasseraf> it's a loop for a stream processor
17:52:32 <elliott> hmm
17:52:34 <elliott>     let (oL,sL) = unzip $ f $ zip iL sL in
17:52:39 <cmasseraf> I don't get the recursive function
17:52:49 <elliott> I think it's because sL is circularly defined
17:52:56 <elliott> you need to make sure elements are produced before they're consumed
17:53:00 <elliott> but zip would consume them immediately
17:53:10 <elliott> so you have to turn it into a stream, so you're basically "promising" there'll be an infinite list there
17:53:12 <elliott> so that pattern-matches work
17:53:15 <elliott> and then you fill in the values based on that
17:53:20 <elliott> this is the best I can explain it, sorry :-(
17:53:45 <cmasseraf> now I'll trying to get that into brain! :)
17:53:56 <ddarius> Just calculate.
17:54:29 <elliott> Yeah, I don't think thinking is very helpful with this contraption.
17:54:34 <elliott> Or is it that I don't calculate thinking is very helpful?
17:58:24 <cmasseraf> oh wait! I think I got it! it's beacuse the sL must always be a delayed value... so it'll be a know value the first time and the positions it'll be calculated from the first one
17:58:39 <cmasseraf> the previous one the be correct
17:58:53 <elliott> it sounds like you've got it, but who can tell with these things :)
17:58:58 <cmasseraf> haha
17:59:14 <cmasseraf> Lazyness in some cases can do some heavy brainfuck
18:01:35 <Axman6> anyoone know where ManateeLazyCat disappeared to?
18:03:28 <djahandarie> Maybe he got eaten by the great firewall of China.
18:03:36 <ddarius> preflex: seen ManateeLazyCat
18:03:37 <preflex>  ManateeLazyCat was last seen on #haskell 46 days, 9 hours, 11 minutes and 51 seconds ago, saying: Good night all. :)
18:03:51 <ddarius> Axman6: Check the logs then.  He explains.
18:04:20 <elliott> (Around 11.10.20.)
18:04:25 <cmasseraf> elliot: is there a way to tell GHCi to show the unroll of the function?
18:04:30 <elliott> cmasseraf: Unroll howso?
18:04:59 <elliott> ddarius: "Hi all. :)" / "Good night all. :)" is a good explanation.
18:05:00 <cmasseraf> see how it's evaluated... steb by step
18:05:23 <elliott> cmasseraf: ah. there's a ghci debugger, but it's not very popular. there's stepeval, but it's limited (hpaste integrates it)
18:12:32 <augur_> @tell conal i really dont get this hoas stuff :(
18:12:38 <augur_> ..
18:12:41 <augur_> !tell conal i really dont get this hoas stuff :(
18:12:44 <augur_> oh.
18:12:48 <augur_> wheres lembdabot!
18:12:48 <augur_> D:
18:13:27 <Axman6> dead
18:13:31 <augur_> D:
18:13:34 <Axman6> elliott killed it
18:13:49 <Axman6> because he's a kitten killing monster
18:13:53 <elliott> It's true.
18:14:08 <JuanDaugherty> :t 1
18:14:09 <elliott> preflex: tell augur_ you do tells too
18:14:09 <preflex>  Consider it noted.
18:14:23 <augur_> psh
18:14:23 <preflex>  augur_: you have 1 new message. '/msg preflex messages' to read it.
18:14:25 <augur_> preflex
18:14:26 <augur_> psh
18:14:49 <augur_> elliott: i do tells too?! :o
18:14:59 <elliott> apparently
18:15:13 <augur_> someone should write a bot that understands pronouns
18:16:59 <parcs_> preflex: tell parcs_ hai
18:16:59 <preflex>  what
18:17:11 <parcs_> preflex: tell preflex hai
18:17:11 <preflex>  what
18:17:28 <elliott> preflex: what
18:17:53 * hackagebot cabal-install-ghc72 0.10.4 - Temporary version of cabal-install for ghc-7.2  http://hackage.haskell.org/package/cabal-install-ghc72-0.10.4 (TonyHannan)
18:17:55 * hackagebot logic-classes 0.48 - Support for propositional and first order logic, normal forms, and a resolution theorem prover.  http://hackage.haskell.org/package/logic-classes-0.48 (DavidFox)
18:27:50 <augur_> edwardk: do you know anything about higher order syntax?
18:28:00 <augur_> higher order *abstract syntax, rather
18:28:47 <edwardk> yes
18:29:03 <augur_> edwardk: what are they :(
18:29:34 <edwardk> basically its about using binding in your underlying language to represent binding in the language you are representing
18:29:48 <edwardk> example:
18:30:04 <edwardk> data Exp a = Var a | App (Exp a) (Exp a) | ...
18:30:09 <edwardk> how do you want to represent lambdas?
18:30:17 <edwardk> you can use Lam a (Exp a)
18:30:22 <edwardk> or you can use the hoas approach
18:30:26 <edwardk> Lam (Exp a -> Exp a)
18:30:28 <augur_> ya
18:30:29 <augur_> ok
18:30:47 <edwardk> it gets somewhat tricky to 'see' into lambdas in the latter scenario
18:30:54 <edwardk> but its typically REALLY fast
18:31:02 <augur_> fast??
18:31:10 <edwardk> http://www.augustsson.net/Darcs/Lambda/top.pdf
18:31:12 <djahandarie> And it also tends to make writing interpreters super easy.
18:31:21 <edwardk> check the benchmarks at the end
18:32:30 <edwardk> when building embedded DSLs i almost _always_ use hoas representations. when building compilers and interpreters for external dsls or languages i only occasionally do so
18:32:51 <edwardk> by then you often have enough things that want to traverse the syntax tree and that need to see under your lambdas or foralls that it gets in the way
18:32:57 <Jafet> So fast, it zips by without you getting to analyze it
18:33:54 <edwardk> jafet: that is the problem. if you want to take apart and assemble terms in lots of interesting ways then hoas often has lots of hidden lookups, etc.
18:33:55 <augur_> edwardk: i dont understand how do higher order functions in the underlying language tho
18:34:04 <augur_> i mean, if you have some underlying function (a -> b) -> c
18:34:24 <augur_> assuming its a constant of the language
18:34:49 <edwardk> well, maybe its easier if you take a step up and make it a strongly typed DSL using a GADT
18:34:56 <irene-knapp> bleh!  Template Haskell can't make a standalone deriving declaration :(
18:35:08 <augur_> it'd look like... app (const "f") (lam (\x -> app (const "g") x))  ??
18:35:45 <edwardk> data Exp t where Var :: Int -> Exp a; App :: Exp (a -> b) -> Exp a -> Exp b; Lam :: (Exp a -> Exp b) -> Exp (a -> b)
18:35:58 <edwardk> so you need an Exp ((a -> b) -> c)
18:37:11 <augur_> edwardk: im just thinking in terms of natural language semantics where you want to have things like binding in things like "every boy is tall" where its something like (every boy) (Lam x (x is tall)) in the syntax
18:37:27 <augur_> and this gets interpreted as every boy (\x -> tall x) in the semantics, you know?
18:38:17 <elliott> Every `App` Boy `App` Lam (\x -> IsTall x)
18:38:25 <elliott> "Or whatever".
18:38:43 <augur_> elliott: yeah except thats not the syntax of it, right
18:38:51 <edwardk> in general systems like you describe need to see under their binders a lot.
18:38:56 <edwardk> this tends to make HOAS a bad fit
18:39:14 <augur_> edwardk: why would it need to see under the binder?
18:39:58 <edwardk> well, you have lots of 'forall' and 'exists' style quantifiers which you often instantiate look under to see if its a monotype, etc.
18:40:09 <augur_> a wha
18:40:34 <JoeyA> forall x. boy x -> tall x
18:41:14 <augur_> JoeyA: actually we usually prefer to think of it as   forall x s.t. boy x. tall x
18:41:32 <augur_> JoeyA: more like an actual predicate on a set
18:41:33 <edwardk> for things like what joy provided you often have lots of those statements and need to use their left hand sides like patterns, this means you often look 'under' the binder in annoying ways for which hoas is a bad fit
18:41:37 <JoeyA> ah
18:41:51 <augur_> edwardk: i have no idea what that means :\
18:42:05 <augur_> i dont know why you're looking underneath the binder her
18:42:20 <edwardk> in other words, how would you write that predicate in haskell, and pattern match on it, etc?
18:42:27 <augur_> its exactly parallel to haskell all (\x -> prime x) [1,2,3]
18:42:30 <edwardk> forall x.    is a binder
18:42:44 <edwardk> the Boy x => … is a predicate associated with that binder
18:42:50 <augur_> i mean, its practically word for word identical
18:42:53 * hackagebot Unixutils 1.47 - A crude interface between Haskell and Unix-like operating systems  http://hackage.haskell.org/package/Unixutils-1.47 (DavidFox)
18:43:10 <edwardk> yes, which is fine if you accept a trivial implementation of your semantics
18:43:23 <edwardk> but if you ever want to OPTIMIZE them, then you run into problems
18:43:29 <augur_> thats all im asking for
18:43:36 <augur_> i dont understand how that specific thing translates
18:43:42 <augur_> i mean do it for haskell instead, i dont care
18:43:54 <edwardk> you _can_ do it with hoas, but since you typically need to make up some kind of barendregt-style variable supply or locally nameless plumbing, etc. anyways the hoas just starts getting in your way
18:43:55 <augur_> i just dont understand how a higher order function in the object language gets interpreted
18:44:25 <augur_> hell, forget the quantifier
18:44:44 <augur_> how is this done (\f -> f 1) (\x -> x*x)
18:45:41 <edwardk> whnf :: Exp a -> a; whnf (App f a) = case whnf f of { Lam b -> whnf (b a); f' -> App f' a }; whnf x = x
18:45:59 <edwardk> that is your whnf evaluator for the cheesy Exp data type i just gave
18:46:14 <edwardk> what you wrote becomes something like
18:47:00 <edwardk> App (Lam (\f -> f `App` LitInt 1)) (Lam (\x -> times `App` x `App` x))
18:47:16 <augur_> hmm
18:47:22 <edwardk> with sugary enough syntax you can get it down pretty close to the original
18:47:53 * hackagebot process-qq 0.2.0 - Quasi-Quoters for exec process  http://hackage.haskell.org/package/process-qq-0.2.0 (HideyukiTanaka)
18:48:20 <edwardk> i do recommend you read that short little lambda calculus tutorial i pasted a link to earlier
18:48:45 <edwardk> lennart describes the different ways to deal with binders rather nicely in that
18:48:54 <edwardk> he leaves out a lot of locally nameless variants, etc.
18:48:57 <edwardk> but its a good intro
18:49:35 <augur_> edwardk: i will definitely read it
18:50:51 <Axman6> edwardk: bleh, reading that has made me figure out what I did wrong with my own LC evaluator >_<
18:51:01 <edwardk> =)
18:51:20 <edwardk> i often start with hoas because its easy to prototype with
18:51:33 <edwardk> and like i said, makes really nice EDSLs
18:52:21 <mike-burns> Maybe you need to try LC: http://trylambda.com/
18:52:23 <augur_> edwardk: hmm. i see i see ok. so this would be non-ideal for natural language semantics because it blurs the lines between the syntactic domain and the semantic domain
18:52:41 <Axman6> sub e@(Lam v e') | v == x = e <- is what i was missing from mine. i was doing something stupid which involved recursing into the e' for some dumb reason
18:52:52 <augur_> edwardk: so that basically you end up having syntactic objects that have semantic values stored in them, and thats how the truth evaluation occurs
18:52:53 <edwardk> at least it makes it harder to deal with the semantics in a way that doesn't very closely reflect the syntax
18:53:11 <edwardk> Axman6: you can use the Barendregt convention to avoid having to do that
18:53:30 <augur_> edwardk: so theres basically no way to map things to raw semantic objects in the meta language, you basically end up computing over the trees themselves
18:53:32 <Axman6> just got up to that section =)
18:53:35 <edwardk> basically you abuse the invariant that every binder in your program must bind distinct variable IDs
18:53:41 <edwardk> then you can skip that case
18:53:50 <edwardk> since the variable you are binding can never have been previously bound
18:54:00 <edwardk> all you need is a globally fresh variable supply
18:54:11 <augur_> actually i suppose in any non-compositional semantic theory you'd need to do that to some degree anyway
18:54:17 <augur_> like, unless you do variable free stuff
18:54:43 <edwardk> augur: yes, but the willingness to put up with debruijn indices is a good cylon detector
18:54:46 <Axman6> edwardk: yeah i implemented something like that, but of course got it quite wrong
18:54:48 <augur_> :p
18:55:02 <edwardk> Axman6: http://hackage.haskell.org/packages/archive/concurrent-supply/0.1.1/doc/html/Control-Concurrent-Supply.html =)
18:55:09 <augur_> edwardk: not even variable free in that sense
18:55:11 <edwardk> Axman6: a nice high performance splittable variable supply
18:55:26 <augur_> but in the jacobson-do-everything-with-SK-calculus type stuff
18:55:32 <augur_> which is even worse than debruijn
18:55:35 <Axman6> well, generating unique variables wasn't too hard
18:55:37 <edwardk> Axman6: i use that to do typechecking in parallel across multiple cores
18:56:10 <edwardk> well, the goal there is block allocating to amortize synchronization costs
18:56:11 <Axman6> is type checking that computationally intensive?
18:56:17 <augur_> i suppose if you reader monad everything its easier
18:56:19 <edwardk> it can be
18:56:28 <JuanDaugherty> in haskell yeah
18:56:49 <edwardk> augur: for the supply?
18:57:01 <edwardk> augur: typically thats done with state rather than reader
18:58:07 <edwardk> we actually FINALLY quashed a rather persistent bug the other day in our type inference engine that was caused by one case where we screwed up the Barendregt convention =/
18:58:39 <augur_> edwardk: well basically you'd do something like   [[t_i]] = lookup i   etc. so that when you write   foo (Lam x (bar y))   when you go down in to evaluate bar y its all smuggling in these variable environments
18:58:42 <edwardk> (we use HOAS at the term level, but Barendregt at the type and kind level)
18:59:03 <augur_> so y evaluates to a function that picks the value for y out of the environment
18:59:07 <edwardk> augur: yes, thats fairly common
18:59:30 <augur_> and i guess thats an acceptable "variable free" way of doing things
18:59:31 <edwardk> thats usually done as part of any foo <-> hoas conversion
18:59:42 <edwardk> well, you still need the supply of 'i's
18:59:49 <augur_> not really variable free in the object language, but its compositional at least
18:59:57 <augur_> because "x" has a denotation
18:59:58 <edwardk> which makes your convention basically a barendregt <-> hoas translation layer
19:02:27 <augur_> edwardk: in those contexts, Lam would be something like... [[Lam v b]] = \x env -> [[b]] (extend env v x) right?
19:02:35 <augur_> i think thats what you'd want
19:03:22 <edwardk> *nods*
19:04:49 <augur_> i should go back and re-read barker and pryor's notes
19:04:55 <byorgey> mike-burns: input > (\m. \n. m (\n. \s. \z. n s (s z)) n) (\s. \z. s (s z)) (\s. \z. s z) yields \s.\z.\n.\s.\z.n s s z \s.\z.s z s s z
19:04:57 <augur_> or perhaps even my own blog posts lolol
19:05:01 <byorgey> doesn't seem right...
19:06:05 <edwardk> mr. yorgey here knows more than i ever will about binders though. he's even got a library ;)
19:07:05 <edwardk> if i wasn't a slave to premature optimization he could have saved me a lot of effort
19:07:29 * byorgey knows more than he wants to about binders
19:09:04 <edwardk> Now that byogey has unbound, I think the next naming library needs to be something like loose-leaf
19:09:16 <augur_> lol
19:09:45 <byorgey> mike-burns: (\x. \y. x y) y z  yields "too much recursion"; should be y z
19:10:02 <Axman6> o.O
19:10:11 <augur> besides binders, does HOAS do anything nifty?
19:10:18 <edwardk> augur: nope
19:10:21 <augur> aww :(
19:10:23 <edwardk> since its all about binders
19:10:29 <augur> well, ACGs are nifty at least!
19:10:57 <byorgey> Axman6: don't be hard on mike-burns, getting capture-avoiding substitution right is tricky!
19:11:17 <edwardk> barendregt is your friend
19:11:35 <augur> the one true god is your friend
19:11:35 <Axman6> byorgey: i know, i've done it and failed myself =)
19:11:37 <augur> i mean uh..
19:11:41 <augur> de bruijn is your friend
19:11:49 <augur> >_>
19:11:50 <augur> <_<
19:11:57 <edwardk> augur: you are sounding more and more like a cylon every day
19:12:06 <augur> =--
19:12:07 <augur> -=-
19:12:10 <augur> --=
19:12:24 <edwardk> or knight rider
19:12:27 <Axman6> hmm, would DeBruijn be more efficient in a language that used mutation?
19:12:27 <edwardk> =)
19:12:27 <augur> lol
19:12:32 <byorgey> Axman6: =)  it seems to be required.
19:12:36 <augur> cylons have the eye thing!
19:12:47 <Axman6> byorgey: hmm?
19:12:50 <edwardk> Axman6: its nice for when you want to do hash consing
19:13:29 <edwardk> Axman6: because you get nice normal forms and don't have to worry about alpha equivalence nonsense
19:13:36 <byorgey> Axman6: I mean that trying and failing (at leats the first time) to implement substitution is required.  I've done it too.
19:13:48 <Axman6> oh right. yeah
19:13:54 <Axman6> I should try it again sometime
19:14:09 <edwardk> augur: yeah i was just teasing coz of the other thing that does the eyes =)
19:14:22 <byorgey> TaPL has a nice explanation of the relevant issues.
19:14:39 <Axman6> isn't nightrider more:
19:14:41 <Axman6> =----=
19:14:44 <augur> edwardk: the popular asian underground song mundian to bach ke sampled the night rider theme
19:14:44 <Axman6> -=--=-
19:14:47 <Axman6> --==--
19:14:51 <edwardk> could be
19:14:53 <Axman6> -=--=-
19:14:54 <Axman6> =----=
19:15:06 <ddarius> At least Axman6 has the decency not to perpetuate his failures onto the rest of us.
19:15:17 <Axman6> yeah!
19:15:19 <Axman6> I do?
19:15:30 <augur> or at least the moonbootica remix did
19:15:54 <augur> nope, the original did too
19:15:57 <augur> awesome
19:16:24 <edwardk> augur: http://www.youtube.com/watch?v=jsr7D2G4IUU&feature=fvwrel
19:17:23 <augur> BY YOUR COMMAND, MICHAEL
19:18:27 <Axman6> wut, who defines zero as \z.\s.z and not \s.\z.z
19:18:30 <Axman6> this is madness
19:19:20 <byorgey> Axman6: hmm, I would usually write  \s.\z.z... but then again, we do usually write  data Nat = Zero | Succ Nat
19:19:49 <Axman6> i don't see the connection
19:19:55 <elliott> Axman6: but that breaks n = \f. f^n :(
19:19:59 <ddarius> @src Ordering
19:20:05 <ddarius> Bloody 'bot.
19:20:13 <elliott> Axman6: the connection is that Zero | Succ Nat -> z s
19:20:15 <elliott> Succ Nat | Zero -> s z
19:20:33 <Axman6> hmm
19:20:46 <ddarius> I usually see zero first
19:20:57 <elliott> right
19:21:09 <elliott> which corresponds to the wrong way around, 0 = \z.\s.z
19:21:22 <elliott> we need a third option. laying them out vertically?
19:21:26 <Axman6> well, to me, \s.\z.z makes sense to me, simply because when you have say 3 \s.\z.s(s(s z)), the s is apllied on the same as where it actually get applied. the swapping just makes me have to think harder
19:21:44 <Axman6> and when i'm as tired as i am right now, i don't want to think too much
19:21:49 <elliott> Axman6: yeah, but the constructor ordering is relevant since the church representation of a data type is a generic operation :)
19:23:13 <ddarius> Axman6: Then I would recommend writing '3'.
19:23:23 <Axman6> that too
19:29:10 <ddarius> I can't help but get the feeling that some words are redundant in this title: "Spin-Orbit-Mediated Anisotropic Spin Interaction in Interacting Electron Systems"
19:30:21 <irene-knapp> haha
19:31:43 <elliott> ddarius: Does that have anything to do with spin interaction?
19:39:07 * ddarius finds some unbelievable crap on arXiv.
19:40:02 <djahandarie> ddarius, I don't think that's limited to only arXiv.
19:40:06 <ion> hah
19:45:03 <ddarius> Just to be clear, the unbelievable crap was not the paper I referenced before (which isn't on arXiv anyway, to my knowledge.)
20:00:08 <JoeyA> When is using ReaderT advantageous compared to simply passing the environment as a parameter?
20:00:36 <Axman6> when you need to pass it thorugh a lot of stuff that has no need for it
20:00:52 <JoeyA> You still have to specify the argument in the ReaderT type
20:01:18 <JoeyA> And you have to lift computations that don't need it (e.g. IO actions)
20:20:59 <ddarius> JoeyA: It's advantageous when you are already using a monad.
20:21:10 <jmcarthur> JoeyA: it just depends on which is going to be a bigger burden to you. also, Reader is very useful as part of a larger stack
20:22:08 <JoeyA> Thanks.
20:22:53 * hackagebot convertible-text 0.4.0 - Typeclasses and instances for converting between types  http://hackage.haskell.org/package/convertible-text-0.4.0 (MichaelSnoyman)
20:23:28 <JoeyA> Also, from y'all's experience, is it often better to implement one's own monad, rather than using stock monad transformers?
20:23:49 <JoeyA> Or does that tend to lead to hard-to-understand code?
20:26:33 <jmcarthur> i would say, but exceptions are not uncommon
20:26:52 <ddarius> JoeyA: It's mostly irrelevant.  If you use transformers, you should newtype wrap the final monad (transformer) anyway.
20:27:07 <ddarius> Basically, how you implement it should not be exposed in the interface.
20:27:16 <JoeyA> good point
20:27:18 <ddarius> You'll probably need to do this for other reasons anyway.
20:27:28 <ddarius> E.g. you don't want to allow complete access to some state.
20:27:55 * hackagebot data-object-yaml 0.3.3.6 - Serialize data to and from Yaml files  http://hackage.haskell.org/package/data-object-yaml-0.3.3.6 (MichaelSnoyman)
20:27:57 * hackagebot data-object-json 0.3.1.7 - Serialize JSON data to/from Haskell using the data-object library.  http://hackage.haskell.org/package/data-object-json-0.3.1.7 (MichaelSnoyman)
20:39:54 <PIRS> @pl \x \y -> (flip y) . (flip x)
20:40:05 <PIRS> ...
20:40:22 <PIRS> lambdabot?
20:40:36 <monochrom> @pl \x -> x
20:40:44 <PIRS> id
20:40:45 <monochrom> ah, dead
20:42:08 <Axman6> Cale: are you going have lambdabot rejoin us anytime soon?
20:42:18 <djahandarie> He did, but I guess it died again.
20:50:32 <Jafet> flip (.) flip . flip (.) . flip
20:51:47 <leoncamel> hey, is there anybody play c++ template with ghc?
20:52:53 <ddarius> I don't know what that means.
20:53:00 <Axman6> me either
20:53:09 <Axman6> ghc has nothing to do with C++
20:54:43 <leoncamel> Sorry, i mean how can I linking c++ tempalte functions with ghc.
20:54:57 <Axman6> by writing a C wrapper usually
20:55:08 <ddarius> leoncamel: The same way you do for any other language.  You don't.  You provide a C interface.
20:57:00 <leoncamel> If I got a lots of functions like this : "template <some_type> sometype2 function(/* .. */ )". The only way is, to wrap all of them into c functions?
20:57:53 * hackagebot sbv 0.9.23 - Symbolic bit vectors: Bit-precise verification and automatic C-code generation.  http://hackage.haskell.org/package/sbv-0.9.23 (LeventErkok)
20:58:55 <ddarius> leoncamel: That's true regardless of what language you are trying to interface to C++, even C++.
21:00:19 <ddarius> The absolute best you could hope for is something that, when given the source of the C++ code, would automatically generate the C functions.
21:00:24 <Axman6> I assume it's (only slightly) easier in C++ though
21:13:26 <edmund_> hello, i have some ffi troubles with shared libraries.
21:13:47 <edmund_> basically, i am seeing problems consistent with http://hackage.haskell.org/trac/ghc/ticket/3807 , but im using 7.0.3 (the bug was fixed in 7.0.1)
21:15:15 <edmund_> i.e., i got exactly the same error as descirbed in the ticket when loading my shared library, and explicitly linking against libHSrts.a fixed my problem (though now I have another undefined symbol..)
21:29:42 <elliott> Cale: yay!
21:29:44 <elliott> @botsnack
21:29:44 <lambdabot> :)
21:30:19 <Cale> oh, I'm still applying your patch though
21:30:26 <Cale> Just brought lambdabot up :)
21:30:32 * elliott is just happy to see lambdabot back :P
21:38:06 <MachinesAreUs> hi there! anyone to answer a simple question about pattern matching?
21:38:58 <Axman6> MachinesAreUs: only if you ask it
21:40:37 <MachinesAreUs> i'm giving a try to Conway's Game of Life, I have a 'evolveCell' function and I'm representing a neighborhood as a list of list, 3 cells each.
21:41:25 <MachinesAreUs>  But when I use this pattern in order to avoid ill-formed parameters evolveCell ((_:_:_:[]):(_:cell:_:[]):(_:_:_:[])) , sometimes I get an error evaluating the function
21:42:47 <edmund_> the last thing should be a list, no?
21:43:26 <MachinesAreUs> It is, for example, evaluating     evolveCell [[X,O,O],[O,X,O],[O,O,O]]      I get "Non-exhaustive patterns in function GameOfLife.evolveCell  "
21:43:38 <Axman6> not every cell has 8 neighbours does it?
21:43:51 <BMeph> MachinesAreUs: Have you tried 'evolveCell ((_:_:_:[]):(_:cell:_:[]):(_:_:_:[])):[]'? :)
21:44:23 <MachinesAreUs> what's the purpouse of the last :[]
21:44:26 <edmund_> and i would add , this seems like a good place for tuples not lists
21:44:26 <MachinesAreUs> ?
21:45:26 <BMeph> MachinesAreUs: Also, there should be a 'default' clause, in case your pattern isn't seen, even if you just say 'evolveCell _ = error "zOMG, teh UnPossible happened!"' ;)
21:45:59 <MachinesAreUs> I designed my pattern in order for it to match only lists of three rows of three cells each. what's wrong with it?
21:46:01 <Saizan> MachinesAreUs: the cells on the borders won't have all their neighbours, so you need some pattern to handle them too
21:46:40 <Saizan> MachinesAreUs: i'm assuming you're calling evolveCell for all the cells in the board
21:46:44 <MachinesAreUs> BMeph: you are right, thx
21:46:48 <BMeph> MachinesAreUs: The purpose of the last ':[]' is to remind you that you're using a list of lists, and not a list of two lists of lists, and a list of cells, since that's one of those 'unpossible' things. ;)
21:48:24 <BMeph> MachinesAreUs: Also, listen to Cale and Axman6, they're smarter (and younger!) than me, so they're quicker on their mental feet. For that matter, is ddarius weighs in at all, just do what he says. :)
21:48:44 <BMeph> is ddarius -> if ddarius
21:49:40 <Axman6> MachinesAreUs: you need to do what BMeph said earlier to match what you actually think it's matching
21:50:31 <Axman6> personally, i'd use [[_,_,_],[_,cell,_],[_,_,_]]
21:50:45 <MachinesAreUs> Bmeph: thanks, it works
21:50:48 <Axman6> makes is much clearer that's what you're trying to do
21:51:03 <MachinesAreUs> Axman6: I tried something like that in the first place, but it didn't work
21:51:41 <Axman6> > let foo [[_,_,_],[_,cell,_],[_,_,_]] = cell in ["the","red","cat"]
21:51:42 <lambdabot>   ["the","red","cat"]
21:51:45 <Axman6> > let foo [[_,_,_],[_,cell,_],[_,_,_]] = cell in foo ["the","red","cat"]
21:51:47 <lambdabot>   'e'
21:51:52 <MostAwesomeDude> Hey, how could I check the typeclass instances for a type, in ghci?
21:51:58 <Eduard_Munteanu> There are ways to make the "world" lazily extend to infinity, IIRC>
21:52:11 <Axman6> :info Class
21:52:31 <MachinesAreUs> Axman6: I see, thx!
21:53:38 <MostAwesomeDude> Ah.
22:00:48 * BMeph would go with Axman6's latest advise.
22:03:08 * Axman6 -> home
22:04:55 <elliott> bye lambdabot
22:08:18 <tgeeky> hm
22:08:43 <tgeeky> has anyone seen something which is like hackage's 'doctest' package, but a little more full featured?
22:08:48 <tgeeky> I think I saw it on github, but I can't find it now
22:22:00 <elliott> hi lambdabot
22:22:02 <MachinesAreUs> BMeph++
22:22:03 <elliott> bit late...
22:22:42 <BMeph> :)
22:22:54 * hackagebot msgpack 0.7.0 - A Haskell implementation of MessagePack  http://hackage.haskell.org/package/msgpack-0.7.0 (HideyukiTanaka)
22:54:03 <NemesisD> hi all. i was looking for advice on how to structure a program i'm writing for performance
23:01:47 <opqdonut> choose the right data structures and prepare to profile and optimize
23:02:00 <opqdonut> there's not much more I can tell you without details
23:02:08 <NemesisD> understandable ;)
23:02:54 <opqdonut> Data.Vector (array library), Bytestrings (fast strings) and Iteratees (IO model) have a good performance track record
23:03:15 <NemesisD> the application is pretty simple, given a list of databases and a chunk of ids to search for, it fires off a query per database, it then collects them, calculates some statistics on them and stores them elsewhere
23:03:19 <ddarius> Use text not bytestring if your data is actually textual strings.
23:03:47 <ddarius> (and you are doing any kind of processing)
23:04:15 <opqdonut> yeah, right
23:04:16 <NemesisD> so the first bit is impure, and there should be some degree of concurrency there, as the database server can handle multiple simultaneous requests, the second bit is pure and I can probably handle that nicely with Control.Concurrent.Strategies
23:04:46 <opqdonut> I think people tend to use http://hackage.haskell.org/package/pool for database connections
23:05:17 <opqdonut> but I haven't done any real db stuff myself
23:06:10 <NemesisD> my first stab was to use parallel-io because it was really simple, but im not so sure that mapping concurrent database requests to a pool of native threads makes sense, because it is IO bound, not cpu bound
23:07:04 <NemesisD> what makes more sense to me is to make N concurrent db requests, where N is determined independent of available threads, but how nice i want to be to the db server
23:07:32 <ddarius> Just forkIO a thread for however many requests you want to make.
23:08:43 <ddarius> In fact, just forkIO for every request.
23:08:54 <ddarius> It's all just going to be waiting on handles in epoll or what have you.
23:09:14 <NemesisD> maybe forkIO and pooling is the right approach then, ddarius ? i may have say 400 dbs i need to query, but i have to collect the results from all of the dbs before i can proceed, and i certainly don't want to execute 400 concurrent db requests
23:09:34 <MostAwesomeDude> Haskell threads are m:n; don't be afraid to forkIO.
23:09:59 <ddarius> If they are all going to the same DB, that might be slightly not friendly, but if these are serious DBs, 400 requests is quite doable.  If they are going to different DBs, what's the problem?
23:10:16 <ddarius> The IO to read the data returned is also going to be mostly asynchronous.
23:10:38 <ddarius> The network will throttle to what you program can actually handle.
23:11:21 <NemesisD> same db, and it may be able to handle 400, but thats just a numler i pulled out of the air, my intuition (which may be wrong) is that i ned to throttle it
23:11:59 <NemesisD> im  planning on pointing this at a mysql read slave so theoretically production traffic won't be hitting it, i could probably be as abusive as i please
23:12:08 <ddarius> NemesisD: Okay, then you can throttle them.  There's no real need to pool the threads, but you can pool the connections.
23:15:14 <NemesisD> ddarius: so if i run my program with +RTS -N on a system with 4 cores, what happens when i spawn a ton of threads?
23:15:18 <ddarius> I'm assuming that you are either getting a fairly large amount of data overall or your processing is fairly intensive, in which case how you connect to the DBs doesn't matter too much.  If this is not the case and connecting to the DBs may be the limiting point, then you probably don't have any performance concerns.
23:16:15 <ddarius> NemesisD: 4-6 or so threads are allocated, most of the IO calls use non-blocking interfaces so don't rely on OS threads anyway, your forkIO threads are mapped many to many onto 4-5 of the OS threads.
23:16:29 <ddarius> One or so is kept aside for handling all IO.
23:17:28 <Saizan> hoping the mysql lib doesn't just delegate to a C layer with blocking I/O, but i guess that'd just be too wrong
23:18:01 <MostAwesomeDude> Curious. Is there a way to wrap/alias Int or Integer such that my wrapper is contained to a range?
23:18:19 <MostAwesomeDude> Say, 0 through 15.
23:18:31 <ddarius> MostAwesomeDude: You can just make an abstract type that enforces that invariant as you would in any language.
23:18:43 <NemesisD> its the one Brian O'Sullivan wrote, mysql-simple, which relies on mysql which are "low level bindings to the C mysqlapi API"
23:19:06 <MostAwesomeDude> ddarius: But wouldn't I have to name every type constructor in that range?
23:19:50 <ddarius> MostAwesomeDude: I said "abstract" not "algebraic."  Most languages don't have algebraic data types.  Just think about how you would do it in Java, say.
23:20:02 <leoncamel> If I have a sort of c++ STL functions, something like "void print_vector(vector<int> vi)". What is the best way to integrate these c++ STL functions into haskell ?
23:20:50 <MostAwesomeDude> ddarius: TBF in Java I would do a range check on every single invocation of the methods in question.
23:20:51 <leoncamel> As far as i know, the haskell FFI can only handle basic c types.
23:21:05 <Saizan> NemesisD: bos is the one who rewrote the I/O manager, so you should be safe :)
23:22:32 <ddarius> MostAwesomeDude: If you wanted to make an abstract data type in Java that was restricted to only holding values 0 through 15, how would you do it?
23:23:33 <issactrotts> For some reason cabal isn't installing anything into my ~/.cabal/bin.
23:23:44 <MostAwesomeDude> ddarius: Constrain on instantiation? I don't know exactly which technique you're hoping I will divine. I can't think of how to do this, which is why I'm asking.
23:24:45 <ddarius> MostAwesomeDude: I'm asking how you would do this in Java (or really any other language you are familiar with.)  Hopefully you know how you might go about it there.  What you suggested sounds like it's the right thing.
23:26:00 <shachaf> MostAwesomeDude: ddarius is probably saying that although in some cases type-level magic works well to represent things at the type level, you can always just make a type that means whatever you want and then represent it however you want and enforce your constraints yourself.
23:26:47 <MostAwesomeDude> ddarius: What I'd do in Java or Python is raise an error on instantiation. Alternatively I might just passthrough underlying errors. I'm trying to figure out how I would construct a type in Ix which I could use for a fixed-size multidimensional array index.
23:27:44 <NemesisD> hmm, anyone actually used Data.Pool before? i'm a bit confused by the possibility for pool exhaustion in it
23:27:54 <shachaf> MostAwesomeDude: A common alternative to (or a special case of) raising an error is to return a Maybe value. :-)
23:27:56 <Saizan> the type-level magic in this case would be to tag it with type-level peano naturals
23:28:13 <shachaf> Saizan: Or some other type-level numbers.
23:29:02 <ddarius> You can do the same thing in Haskell.  module MyModule(MyConstrainedType, mkCT, value) where newtype MyConstrainedType = MkCT Int; mkCT i | i >= 0 && i <= 15 = MkCT i | otherwise = error "out of range"; value (MkCT i) = i;
23:29:20 <ddarius> NemesisD: I'm using it right this second.
23:29:32 <ddarius> NemesisD: If you are out of things in the pool it blocks.
23:29:54 * shachaf wonders what the Haskell thing ddarius has been working on recently is.
23:30:03 <djahandarie> World-taker-over.
23:30:20 <ddarius> djahandarie: I wouldn't want to take over the world.  That would be way too much hassle, and not rewarding at all.
23:30:47 <djahandarie> The rewards are in the challenge!
23:30:58 <shachaf> @brain
23:31:10 <shachaf> @botsnack
23:31:42 <NemesisD> ddarius: actually im not sure if pool even makes sense since the "resource creator" takes no input. my problem is that i must execute queries in parallel across multiple databases. you have to know the db at connection time
23:32:01 <NemesisD> i don't need a pool per db since theres only 1 query to execute at a time per db
23:32:32 <ddarius> If you are making connections against the same database server, then those would be what you are pooling.
23:32:54 * hackagebot svm-simple 0.2.6 - Medium level, simplified, bindings to libsvm  http://hackage.haskell.org/package/svm-simple-0.2.6 (VilleTirronen)
23:33:37 <shachaf> djahandarie: A world-taker-over that generates HTML/
23:33:40 <shachaf> s/.$/?/
23:34:00 <djahandarie> Live status reports!
23:34:09 <NemesisD> ddarius: the connect function in my mysql library must specify the database to use. so i can't pool a bunch of connections because each time i need to access a connection in the pool, i'll need a different database
23:34:31 <NemesisD> it won't let you connect and then later decide which database to use
23:35:19 <ddarius> NemesisD: You can't execute a USE [FooBarDB] command?
23:36:12 <NemesisD> ddarius: maybe. i've never tried. i'll write up a test case and see if that works
23:36:28 <djahandarie> (It'll work.)
23:37:30 <NemesisD> ddarius: with pool, what's the workflow when all your resources are being used? it would be nice if i could just queue work to be done and let the pool get it done as resources become available. that doesn't seem to be what withPoolAllocate does
23:38:25 <ddarius> NemesisD: You ask for resources, if all the resources are in use you block.  Just forkIO a thread for all your queries.  The scheduler is the queue, pool is the throttler.
23:43:34 <issactrotts> Question: On my Mac running Lion, everything is getting installed into ~/Library/Haskell/bin but nothing is going into ~/.cabal/bin. Anyone know why?
23:53:31 <NemesisD> thanks ddarius, ill start looking into how i'm going to merge all these concepts together. gotta run
