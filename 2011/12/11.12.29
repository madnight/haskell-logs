00:03:09 <kizzo> There doesn't seem to be too much information regarding haskell interaction with blender (blender.org).
00:03:31 <ddarius> Why would there be?
00:04:02 <kizzo> One obvious interaction I can think of is wrapping Blender's C API with raw haskell, but am wondering if there is a reason why is hasn't been done already.
00:04:26 <ddarius> No one has cared to yet.
00:04:37 <kizzo> ddarius: I am currently trying to make a game and 1. Blender, in and of itself, would be very nice to use..
00:04:45 <kizzo> and 2. Haskell would be very nice to use too.
00:04:52 <kizzo> Ok, that's a good answer.
00:05:38 <ddarius> Blender is a 3D modeller.  I don't see why you need Haskell bound to it to make a game.  I don't see how that benefits you at all.
00:06:28 <Cale> ddarius: I believe that blender also has a bit more than just 3D modelling in place for games.
00:08:38 <Cale> It also seems to include the better part of a game engine.
00:11:18 <ddarius> Cale: I guess.  It didn't the last time I was looking at it.  I'm still not convinced it's really the best way to go about making a game, but clearly I'm fairly ignorant of its current capabilities.
00:13:28 <joshuajcheek> Hi, finally got to the part in "Learn You a Haskel" where we do Hello World. It outputs 15k lines to stderr, and takes 6 seconds. Is this common, or is something wrong with my system? https://gist.github.com/1533017
00:14:07 <GorDonFreeMan> nothin unusual there
00:14:36 <Cale> joshuajcheek: What is it printing to stderr?
00:15:17 <Cale> I mean... it's hard to know what's wrong with only the length of the error message as a guide.
00:15:44 <Cale> But that sounds like you have a bad installation of ghc.
00:16:07 <ddarius> Cale: Why would you want to know what the error messages say?
00:16:13 <Cale> lol
00:16:47 <joshuajcheek> Cale: Looks like lots of warnings, though hard to tell with 15k lines. The last page worth are all "ld: warning: text reloc in _cZh_str to _stg_ap_pppppp_info"
00:17:28 <Cale> What platform is this on?
00:17:40 <Cale> Linux?
00:17:56 <GorDonFreeMan> probably on a scientific calculator
00:18:02 <GorDonFreeMan> or maybe mac
00:18:34 <joshuajcheek> Actually it's all warnings, I just ran it through `grep -v warning` and nothing except 'compiling' and 'linking' came out. Still takes 6 seconds, though (14 when I let it print the output)
00:18:49 <joshuajcheek> On Mac OSX Lion
00:18:59 <GorDonFreeMan> i knew i knew
00:19:00 <Cale> joshuajcheek: okay, and how did you install ghc?
00:19:44 <Cale> The current binaries provided for GHC are built for Snow Leopard.
00:19:45 <joshuajcheek> Cale: With homebrew
00:20:00 <Cale> So you'll probably have to compile your way up from something old...
00:20:20 <joshuajcheek> How long does it take you to build Hello World?
00:20:31 <GorDonFreeMan> like a few minutes
00:20:40 <GorDonFreeMan> if you have 1GB ram at least
00:20:44 <Cale> Please don't listen to GorDonFreeMan, he's a troll ;)
00:21:02 <GorDonFreeMan> actually i used ghc and i know
00:21:22 <GorDonFreeMan> and hello world is ~1MB
00:21:34 <Cale> real	0m0.305s
00:21:40 <Cale> for building hello world
00:21:52 <GorDonFreeMan> ok i only have 1G ram now
00:21:59 <GorDonFreeMan> and only 2.2GHz amd 64
00:22:09 <joshuajcheek> Cale: Okay, thank you (Time is the biggest reason I am interested in playing w/ Haskell over Clojure)
00:22:28 <joshuajcheek> I'll look for a tutorial to build it myself
00:22:35 <Cale> joshuajcheek: If you ask me, types should be the biggest reason ;)
00:23:16 <Cale> joshuajcheek: Building GHC yourself will take a long time, but shouldn't be too hard... however, you'll require a binary which works better than your current version does in order to do that.
00:23:19 <joshuajcheek> Cale: That played into it, as well. I do Ruby and find myself often wishing I had types. Though that could just be a consequence of how I code.
00:23:30 <joshuajcheek> by "wishing I had types" I mean "static typing"
00:23:33 <Cale> Well, a type system is a nice thing to have.
00:23:43 <mrcarrot> time ghc -o hello hello.hs
00:23:51 <mrcarrot>     0m1.52s real     0m1.04s user     0m0.30s system
00:24:06 <mrcarrot> that is an old, old amd (before fancy 64 bit)
00:24:15 <mrcarrot> and far from 1G of ram
00:25:13 <joshuajcheek> How long does it take to build a project with tens of thousands of lines in it?
00:25:17 <Cale> Yeah, it should not require a very noticeable amount of memory to compile hello world.
00:25:34 <Cale> joshuajcheek: Depends on what those lines are, and how hard you're pushing the optimiser.
00:26:06 <Cale> joshuajcheek: Typechecking is (multiply?) exponential space in the worst case, but I only know of contrived ways to hit that.
00:26:08 <joshuajcheek> Cale: Lets say we are in development mode and don't push the optimiser
00:26:33 <Cale> A few minutes perhaps?
00:26:56 <Cale> GHC itself can take upwards of an hour or two to build.
00:27:06 <Cale> It really depends...
00:27:18 <joshuajcheek> Does HS have effective linking like C projects do, such that you don't need to recompile files because you can link them in if they haven't' changed?
00:27:22 <Cale> yeah
00:27:26 <joshuajcheek> Cool.
00:27:29 <Cale> and ghc --make does that
00:27:42 <Cale> (well enough for simple projects anyway)
00:28:02 <GorDonFreeMan> well actually i was having some system thrashing problems with ghc that caused it to even my desktop clock stop for some time
00:28:23 <GorDonFreeMan> this happens when too much memory is allocated
00:28:25 <Cale> GorDonFreeMan: Very weird, possibly something wrong with your installation of GHC.
00:29:06 <Cale> In most cases, compilation will not use very much memory.
00:29:23 <Cale> But if you have large machine-generated Haskell source files, it certainly can.
00:29:39 <joshuajcheek> I do Rails and to load a Rails project of thousands of often takes 20-40 seconds. You have to pay it every time, no matter what (there are relevant nuances around this, of course). We also do a shitload of testing, and to load all that stuff up and run all tests, it can get into the minutes.
00:29:46 <GorDonFreeMan> no i was starting out with 100 lines at most
00:29:56 <Cale> GorDonFreeMan: Yeah, that shouldn't be happening.
00:29:56 <GorDonFreeMan> it took minutes
00:30:17 <Cale> If you still have the source files, I can try building them myself and see if I get the same result.
00:30:22 <mrcarrot> joshuajcheek: usually you would not compile between tests while you are developing. instead you would run it in interpreted mode
00:30:27 <Cale> and then we can submit a bug
00:30:43 <GorDonFreeMan> no matter, i went coding in C in the mean time
00:30:58 <Cale> Yeah, but C requires headache pills to program in.
00:31:02 <GorDonFreeMan> i couldn't even get my ghc plot a pixel array
00:31:24 <Cale> Ah, there are some nice libraries to make that easy.
00:31:35 <GorDonFreeMan> yes, buti had cabal fail if you remember
00:31:56 <GorDonFreeMan> and there is no graphic output lib by default
00:32:22 <GorDonFreeMan> you could file a bugreport for me on this
00:32:32 <GorDonFreeMan> no basic libraries included by default.
00:33:00 <Cale> It's hard to include GUI libraries by default because they tend to have lots of dependencies and not be entirely cross platform.
00:33:10 <Cale> It's easier just to get people to install the ones they want via hackage.
00:33:29 <Cale> If cabal install isn't working for you, then that should be the first order of business.
00:33:36 <Cale> (making that work)
00:33:45 <mrcarrot> GorDonFreeMan: good luck to get portable pixel plotter with C. that is also platform independent
00:33:57 <GorDonFreeMan> i use only linux btw
00:33:59 <joshuajcheek> mrcarrot: I've heard this, but it's unclear to me how interpreted mode can avoid the penalties that compiling has to pay. Does it not evaluate the code until you use it? Does it not perform things like type checking until the code is invoked, thus moving cost to runtime? Or is the benefit just that it doesn't have to translate to machine code, thus sparing (I assume) half the effort?
00:34:00 <mrcarrot> also no
00:34:01 <Cale> Once it's installed, it's trivial to set up a decent GUI library.
00:34:07 <Cale> GorDonFreeMan: That *should* make things easy
00:34:08 <GorDonFreeMan> though i use SDL's framebuffer now
00:34:11 <GorDonFreeMan> http://matrix.z-labor.com/tmp/C/sdltext_fps_d_asdf2.c
00:34:21 <GorDonFreeMan> check out my technology test if you like
00:34:41 <GorDonFreeMan> this took my to code less time than trying to install ghc.
00:34:43 <mrcarrot> joshuajcheek: it does type checks and such...
00:35:09 <GorDonFreeMan> (i dont have enough root space now to simply install as usual)
00:35:24 <GorDonFreeMan> ghc is like 950MB+
00:35:44 <ddarius> HOpenGL is part of the Haskell Platform.
00:37:33 <issactrotts> Anyone know of a way to tell cabal-install to save its solution and reuse it later?
00:39:23 <Cale> GorDonFreeMan: you might be interested in the gloss library for Haskell, see for instance: http://www.youtube.com/watch?v=vm78Tkc-KhM
00:39:35 <Cale> (the entire code for that little demo is shown in the video)
00:39:43 <GorDonFreeMan> Cale<< yes you already recommended that me
00:40:00 <GorDonFreeMan> wanted to plot a circle with it
00:40:14 <GorDonFreeMan> but then i had cabal fail
00:40:23 <Cale> Yeah, you need to get cabal install working.
00:40:24 <GorDonFreeMan> and no gloss.
00:40:43 <GorDonFreeMan> or maybe get another 1TB hdd and make my root larger
00:41:01 <GorDonFreeMan> then i can install as usual.
00:41:05 <Cale> Oh, you're out of disk space?
00:41:06 <GorDonFreeMan> less hassle maybe
00:41:09 <GorDonFreeMan> yes
00:41:17 <Cale> Yeah, that'll make *everything* hard :P
00:41:18 <GorDonFreeMan> i made my root 9GB only
00:41:46 <Cale> Given that my machine is for personal use, I tend to just have one big partition per disk.
00:42:00 <GorDonFreeMan> ofcourse without /tmp and /var and /home, those i put separate
00:42:10 <Cale> (I don't separate /home)
00:42:34 <Cale> Just because it ends up being inconvenient in exactly this way :P
00:42:50 <Cale> There are semi-decent tools for resizing partitions these days though.
00:42:56 <GorDonFreeMan> one partition is not cool, because it causes unnecessary fragmentation, and logs may fill up your root
00:42:56 <mrcarrot> i am usually having /home separate because it makes it easy to reinstall the system
00:42:59 <Cale> Kinda scary to use, but they actually do work.
00:43:17 <mrcarrot> but the rest as / on home computers
00:43:26 <GorDonFreeMan> /home filling up your root isn't cool either
00:43:30 <Cale> I don't see why it should cause unnecessary fragmentation.
00:43:50 <ddarius> They are more than semi-decent.  They used to be semi-decent.  Now they are simple and, in my experience, work fine even when needing to do things like resize installed file systems.
00:44:09 <mrcarrot> i usually put something like 20-25G for / and the rest for /home + a swap partition
00:44:46 <Cale> ddarius: The one I was using successfully resized a partition that I wanted to resize, but failed to move it to the left, thankfully before it had a chance to actually lose data.
00:45:01 <Cale> er, to the right rather
00:45:20 <ByronJohnson> lvm makes it easier to resize and manage partitions
00:45:31 <GorDonFreeMan> i have lvm2
00:45:51 <mrcarrot> then the root partition could be grown...
00:46:03 <GorDonFreeMan> no, i filled up the whole drive
00:46:12 <mrcarrot> what filesystem?
00:46:20 <GorDonFreeMan> ext3 ext4
00:46:33 <mrcarrot> they are shrinkable
00:46:34 <Cale> Then the answer is clear: delete stuff or just go out and buy another hard drive. They're *really* cheap these days :P
00:46:47 <mrcarrot> GorDonFreeMan: you can shrink one partition, then grow /
00:46:53 <GorDonFreeMan> mrcarrot<< yes, but i have 900GB data
00:47:07 <GorDonFreeMan> on 2 hdds
00:47:12 <GorDonFreeMan> so no free space
00:47:39 <GorDonFreeMan> and i don't want to delete my movies ;/
00:48:07 <mrcarrot> GorDonFreeMan: just put movies on a usb disk and done :)
00:48:09 <ddarius> Buy a 1TB external drived for $100 dollars.
00:48:10 <Sgeo> Will the Haskell ecosystem ever switch to a system like Nix?
00:48:33 <ddarius> Sgeo: Nix is a model for what the packaging people are trying to do.
00:48:38 <GorDonFreeMan> mrcarrot<< yes that will me my solution;>
00:48:48 <GorDonFreeMan> be
00:50:29 <Sgeo> ddarius, ooh
00:52:35 <GorDonFreeMan> anyway i need new hardware too
00:53:12 <GorDonFreeMan> was thinking about a 2-6 core phenom II with 8GB+ 1333MHz DDR3
00:53:34 <GorDonFreeMan> that would handle ghc well i believe
01:17:28 <joshuajcheek> Installed from source, it's taking only 0.3-0.7sec to build Hello World now.
01:18:23 <Cale> joshuajcheek: okay, great :)
01:18:52 <joshuajcheek> Using ghc 7.2.1
01:19:16 <joshuajcheek> No warnings, either. :)
01:21:40 <GorDonFreeMan> joshuajcheek<< is cabal thing working for you?
01:22:30 <joshuajcheek> GorDonFreeMan: I haven't tried to install it yet, the instructions (https://gist.github.com/1169332) looked formidable, and IDK if they're fixed yet. Figure I'll wait until I get to the point of needing it before I spend the time on it.
01:25:43 <joshuajcheek> TBH, it might not be that long. I have an idea for a project I wouldn't mind trying in Haskell that could require Cabal libs (specifically YAML or some sort of human-readable marshaling tool like JSON, or XML if I get desperate)
01:28:25 <randomclown> Anyone here?
01:29:27 <randomclown> Anyways, I'm trying to write a function that takes a string and returns the last consecutive digits of the string
01:29:50 <randomclown> so if input is "00aaaa" should give "aaaa"
01:30:05 <randomclown> or input is "aaaa2222aaa" should give "aaa"
01:30:30 <randomclown> can somebody hint me the on the right direction?
01:30:56 <mrcarrot> randomclown: that would be very easy with a recursive function
01:31:17 <mux> > reverse . takeWhile isDigit . reverse $ "333bb2222"
01:31:19 <lambdabot>   "2222"
01:31:58 <MasseR> Then again, that doesn't work with clowns example about "aaaaa2222aaa" returning "aaa"
01:32:06 <randomclown> yeah
01:32:22 <copumpkin> nondigits?
01:32:28 <copumpkin> or are you talking about hex digits?
01:32:33 <randomclown> as long as the digits are the same
01:32:33 <MasseR> Last consecutive symbols?
01:32:35 <randomclown> ascii digits
01:32:41 <copumpkin> aaa isn't a digit
01:32:50 <copumpkin> alpha?
01:32:54 <randomclown> sorry alphanumeric
01:33:00 <randomclown> I meant to say character
01:33:02 <copumpkin> alphanumeric includes number
01:33:11 <mux> oh.
01:33:12 <copumpkin> just alpha?
01:33:17 <randomclown> ascii character
01:33:25 <copumpkin> uh
01:33:44 <copumpkin> > > reverse . takeWhile ((<128) . ord) . reverse $ "aaaa2222aaa"
01:33:44 <lambdabot>   <no location info>: parse error on input `>'
01:33:47 <copumpkin> > reverse . takeWhile ((<128) . ord) . reverse $ "aaaa2222aaa"
01:33:48 <lambdabot>   "aaaa2222aaa"
01:33:51 <copumpkin> magic!
01:33:53 <copumpkin> all the ascii you want
01:34:08 <copumpkin> > reverse . takeWhile isAlpha . reverse $ "aaaa2222aaa"
01:34:09 <MasseR> copumpkin: But "as long as they are the same" :)
01:34:09 <lambdabot>   "aaa"
01:34:29 <randomclown> what about "1111000"
01:34:38 <copumpkin> > last . group $ "aaaa2222aaa"
01:34:39 <lambdabot>   "aaa"
01:34:51 <copumpkin> > last . group $ "1111000"
01:34:52 <lambdabot>   "000"
01:35:01 <randomclown> ah group
01:35:33 <randomclown> I see, should checkout all the built in functions first
01:36:56 <randomclown> thank you copumpkin
01:36:58 <copumpkin> np
01:37:07 * ddarius still doesn't understand this predilection for the word "built-in."
01:37:57 <Cale> Yeah, group isn't built in, it's a library function.
01:38:05 <Cale> seq is built in :)
01:38:51 <randomclown> right
01:39:43 <rostayob> http://www.youtube.com/watch?v=LR8fQiskYII&t=2m45s
01:40:37 <rostayob> "Haskell, a programming language for geniuses by geniuses"
01:42:48 * hackagebot authenticate 0.11.0 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.11.0 (MichaelSnoyman)
01:42:50 * hackagebot data-object-yaml 0.3.4 - Serialize data to and from Yaml files (deprecated)  http://hackage.haskell.org/package/data-object-yaml-0.3.4 (MichaelSnoyman)
01:42:52 * hackagebot http-conduit 1.0.0 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.0.0 (MichaelSnoyman)
01:42:54 * hackagebot xml-conduit 0.5.0 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-0.5.0 (MichaelSnoyman)
01:42:56 * hackagebot yaml 0.5.0 - Low-level binding to the libyaml C library.  http://hackage.haskell.org/package/yaml-0.5.0 (MichaelSnoyman)
01:47:58 * hackagebot path-pieces 0.1.0 - Components of paths.  http://hackage.haskell.org/package/path-pieces-0.1.0 (MichaelSnoyman)
01:48:04 <ddarius> "Haskell, a programming language by geniuses for idiots a.k.a. humans."
01:49:10 <Sgeo> > System.Info.os
01:49:11 <lambdabot>   Not in scope: `System.Info.os'
01:50:13 <Cale> "Haskell, a programming language by geniuses for idiots a.k.a. geniuses."
01:50:42 <ddarius> I was considering coining the word "idiuses"
01:52:14 <MasseR> :/ Does this mean snoyman will stop supporting http-enumerator
01:52:39 <ddarius> Probably.
02:03:10 <Sgeo> Will someone please fix the HUnit documentation?
02:03:48 <ddarius> Submit a patch to the maintainer.
02:04:10 <Sgeo> I guess I should figure out how to do that at some poit
02:04:12 <Sgeo> point
02:15:51 <yitz> MasseR: i doubt that support for http-enumerator will end so fast. there is a lot of production code out there using it.
02:16:11 <MasseR> yitz: Hope so :)
02:16:44 <ivanm> conduits definitely seem nice
02:17:58 <yitz> ivanm: yeah. i think we will need a number of smaller steps progressing towards the ideal that frp is aiming for, and this is one more.
02:18:40 <ivanm> I've never really looked at FRP, but conduits make a lot more sense from the beginning than iteratees do
02:19:25 <MasseR> Uhm, conduits relate to FRP? (functional reactive programming)
02:20:20 <yitz> MasseR: just asked snoyberg (works here). he said that there are bugs in http-enumerator that can't be fixed using enumerators. that's a big part of the motivation to migrate to conduits.
02:21:11 <yitz> MasseR: based on your request, he's thinking of writing a blog post about the issue you are raising.
02:22:15 <ivanm> yitz: you work with snoyberg?
02:22:26 <Sgeo> There's no Data instance for Maybe?
02:22:55 <yitz> ivanm: yes.
02:23:11 <Sgeo> Oh, maybe there is for Maybe Int and the like
02:23:21 <Sgeo> empty :: Maybe Int certainly seemed to work
02:24:27 <yitz> Sgeo: instance Data a => Data (Maybe a) -- Defined in Data.Data
02:24:38 <Sgeo> Mm.
02:25:08 <Sgeo> I guess though if people write their own types, they're not too likely to derive Data, are they?
02:25:27 <rostayob> Sgeo: you can use standalone deriving in that case
02:25:31 <yitz> Sgeo: depends on the author. some people provide that religiously.
02:26:00 <Sgeo> yitz, even though it requires a language extension? o.O
02:26:31 <rostayob> Sgeo: most packages are GHC-only anyway
02:26:55 <yitz> Sgeo: right, so other authors don't, for that reason.
02:28:05 <yitz> Sgeo, rostayob: providing the instance doesn't hurt though. that doesn't use any extension. it's in base, so it doesn't even require any extra dependency.
02:28:25 <yitz> so i imagine most people would happily provide the instance if you need it and ask for it.
02:28:30 <Sgeo> It doesn't require DeriveDataTypeable?
02:28:57 <yitz> Sgeo: oh, if you want to derive it automatically, yes. i suppose that's what you
02:29:00 <yitz> would usually do.
02:29:21 <yitz> right there was a whole issue with that.
02:29:33 <Sgeo> o.O?
02:30:09 <yitz> JaffaCake changed the API of Typeable, figuring it wouldn't affect anyone because they are probably just deriving instances automatically.
02:30:17 <yitz> then there was a whole uproar
02:30:40 <yitz> because a lot of people *didn't* deriving the instance automatically, because they didn't want to use the extension.
02:30:55 <yitz> so the change ended up breaking lots of packages
02:31:15 <yitz> anyway
02:37:48 * hackagebot hfann 0.4 - Haskell binding to the FANN library  http://hackage.haskell.org/package/hfann-0.4 (DavidHimmelstrup)
02:51:14 <nexion> what's a good way to parse numeric values from a Data.Text.Lazy value?
02:52:52 <nexion> "17" :: Text -> 17 :: Integer or 17 :: Word8, etc
02:53:12 <chemistree> [x | x <- [1..5]]
02:53:18 <chemistree> how is that read in english?
02:55:03 <chemistree> "output x for input [1,2,3,4,5]"? thats not right...
02:55:48 <chemistree> "for output x, assign to x [1,2,3,4,5]". like that?
02:56:38 * Sgeo should go ahead and write his AWObject class
03:00:56 <randomclown> for all x E [1, 5]
03:01:05 <randomclown> where E is the set belong to operator
03:02:15 <Cale> the list of values x where x is chosen from the list [1..5]
03:02:43 <Cale> [1..5] could be read as "the range 1 to 5" or something
03:02:44 <Saizan> "x such that x in [1..5]" would be the set comprehension reading
03:02:50 * hackagebot authenticate 0.11.0.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.11.0.1 (MichaelSnoyman)
03:05:09 <yitz> nexion: Data.Text.Lazy.Read
03:05:16 <eikke> when using Foreign.Marshal.Array.newArray and castPtr to pass the result into some C layer (which will only run some time later), is this pointer guaranteed to remain 'correct', as in: GC won't move the array around behind my back?
03:05:31 <Sgeo> @hoogle centimeter
03:05:31 <lambdabot> No results found
03:05:51 <Sgeo> Any pre-existing stuff on Hackage for centimeter stuff?
03:06:02 <Sgeo> I think I want all my distance stuff to be statically checked
03:06:23 <Sgeo> Should I just define some stuff for my own use?
03:07:00 <chemistree> randomclown: E is "there exists" (extistential operator)?
03:07:20 <randomclown> yeah my bad, I couldn't be bothered to find the belongs to operator
03:08:33 <randomclown> chemistree: for all x ∈ [1, 5]
03:08:43 <randomclown> integer x
03:14:19 <chemistree> ∀ x  ∈ [1..5]  == "for all x there exists an x from the range 1 to 5" ?
03:16:55 <randomclown> x is an integer such that x is between 1 and 5
03:17:51 * hackagebot OpenCLWrappers 0.0.1.0 - The OpenCL Standard for heterogenous data-parallel computing  http://hackage.haskell.org/package/OpenCLWrappers-0.0.1.0 (EmilKarlson)
03:20:05 <rribeiro> Hello all!
03:20:38 <rribeiro> I'm have some trouble in creating a parsec parser to process haskell type signatures
03:20:52 <rribeiro> the main problem is to process applications
03:21:16 <rribeiro> Someone could help me with this?
03:24:52 <mm_freak> rribeiro: do you /want/ to write the parser yourself?  there are ready-made haskell parsers
03:26:11 <rribeiro> mm_freak: I want to create the parser by myself.
03:26:34 <rribeiro> mm_freak: the main problem is to parser applications
03:27:05 <rribeiro> mm_freak: like : (Monad m) => m a -> (a -> m b) -> m b
03:27:58 <rribeiro> mm_freak: there are parsec based parsers? I've seen only parsers created with happy
03:28:51 <Sgeo> There's nothing wrong with using Parsec for something relatively easy without it, right?
03:29:00 <HugoDaniel> :)
03:29:02 <Sgeo> Although I don't know much about parsing, so I may be mistaken about easy
03:31:37 <kallisti> Sgeo: iirc, parsec cannot define left recursive grammars.
03:31:52 * Sgeo has no idea what a left recursive grammar is
03:39:41 <mm_freak> rribeiro: you should ask a specific question
03:44:03 <rribeiro> mm_freak: I've written the following parser for applications :  btype = foldl1 TyApp <$> many1 atype <* whiteSpace
03:44:34 <rribeiro> mm_freak: When I've tried to parse "m a" it parses only "m"
03:45:52 <Sgeo> Is there a way to tell GeneralizedNewtypeDeriving to just derive all instances?
03:45:57 <Sgeo> Of a newtype?
03:46:25 <copumpkin> no
03:46:56 <rribeiro> mm_freak: Why this happen? the combinator many1 should repeat a parser p several times, no?
03:50:21 <Blkt> good morning everyone
03:50:31 <Lemmih> rribeiro: Are you using a lexer?
03:51:04 <mm_freak> rribeiro: your parser parses a type name, i presume…  a type name doesn't include the space
03:51:37 <mm_freak> so it parses arbitrarily many type names, but that parser doesn't also parse the terminating space
03:51:40 <rribeiro> mm_freak: I'm using the parsec TokenParser lexer
03:51:49 <mm_freak> oh, in that case ask Lemmih =P
03:52:17 <rribeiro> mm_freak: ok. I'll ask him
03:52:27 <Lemmih> How is 'atype' defined?
03:52:31 <rribeiro> mm_freak: thanks
03:52:41 <rribeiro> atype = try gtycon <|>  try tuplety   <|>  TyParen <$> parens typ  <|> listty  <|> tyvar
03:55:02 <rribeiro> Lemmih: where these parsers only process type constructors, tuples, listas and variables
03:55:17 <Lemmih> rribeiro: Right, hm.
03:56:41 <Lemmih> rribeiro: I suggest narrowing the problem down a bit more. Try something like 'many1 tyvar' on 'm a'.
03:57:35 <Sgeo> ARe there tools to make parsing left-recursive grammars easy?
03:57:53 <rribeiro> Lemmih: ok. I'll try to reduce the problem a bit to find out where is the problem. Thanks!
04:04:48 <chemistree> how do you read the input of a listcomprehension: [ .. | (x, y) <- xs]
04:05:18 <chemistree> the "(x, y) <- xs " part
04:05:24 <chemistree> ?
04:09:13 <Lemmih> I read it as: ... where x and y are pairs in xs.
04:09:26 <Lemmih> But I'm not a mathematician.
04:09:34 <chemistree> nor am I, thanks
04:23:30 <bford> hi folks can anyone give me a quick hand with bytestrings?
04:24:22 <Bynbo7> not without knowing the problem
04:24:36 <bford> I'd like to encode a list of ints into a list of ByteStrings. Something like fmap <conversion> [1..10] but I think I'm missing something    fundamental
04:25:35 <Axman6> well, you can use the binary package... but first you should probably have a good reason for doing that. why do you need to do that?
04:27:00 <bford> i'm playing around with the conduit stuff and I'm writing a Sink that sends its stream onto a zeromq socket. I  just want to test it with something simple like sending a stream of ints, but the send function on a socket requires bytestrings
04:27:34 <Axman6> well, you probably do want to use the binary package then
04:27:45 <Axman6> just call encode on the ints and you'll get bytestrings
04:28:16 <bford> so I'd have something   like: sourceList [1..10] $$ <convert-to-bs> $= zmqSink
04:28:53 <bford> I got that far by then ran into Lazy vs not Lazy bytestrings :-)
04:28:55 <Axman6> sure
04:29:08 <Axman6> ah, you may need the cereal package then
04:29:53 <bford> ah ha - that looks promising! thanks
04:30:12 <Axman6> it would be nice to have one package for both...
04:33:58 <ivanm> that reminds me: is there any way to interoperate between binary/cereal and blaze-builder and a "real" parsing library?
04:34:44 <ivanm> I'd prefer not to have the class I'm working on rely upon outputting/consuming ByteStrings directly, but AFAICT that's what I need to do if I want to be able to use binary/cereal for one of the options
04:54:53 <chemistree> what purpose is your haskell program serving you?
04:55:29 <mike-burns> Frustration.
04:55:41 <nazgjunk> the nature of software
04:55:57 <chemistree> what purpose is your haskell program serving you?  I ask out of curiosity as to what other Haskell programmers are using the language for
04:56:01 <chemistree> LOL
04:56:07 <chemistree> frustration, thats a given
04:56:41 <biio> I was running low on curse words, so I took a course in haskell, now I'm set for life
04:56:50 <mike-burns> I'm building libraries that make it easier to work with some HTTP JSON APIs, to actually answer your question.
04:57:44 <mike-burns> And bigger picture: building tools to combine and interface with those APIs from my day-to-day workflow.
04:57:57 <mike-burns> But mostly: frustration.
04:58:42 <chemistree> Are the libraries intened to be a plugin for your internet browser? Is the hope for other people to also use your program, or just for personal frustration?
04:58:54 <Lemmih> chemistree: Haskell keeps me sane. Probably wouldn't have chosen this line of work if I had to work with, say, C++ or Java.
04:59:37 <chemistree> Lemih: is Haskell part of your 'occupation'/ career?
04:59:45 <mike-burns> chemistree: I've build some command-line tools for the project management tool I use, and I expect other people to use these tools.
05:00:34 <mike-burns> chemistree: And I've built a library for the version control system I use, and used that to make other parts of my life easier. I don't expect people to use the library, but they might.
05:02:34 <chemistree> mike-burns: that sounds worthy, a little technical for my current understanding
05:03:28 <mike-burns> chemistree: Do you use git?
05:05:47 <bford> Axman6, thanks for the help, it's working fine now
05:06:06 <chemistree> :mike-burns: no I have not yet used git, I am automatically interested however, as linus torvalds designed it
05:06:12 <mike-burns> chemistree: http://goo.gl/4LKgk - here's an implementation of `git log' using my library. It's just a sample (so it doesn't do everything the real life `git log' does), but it might be understandable, too.
05:06:20 <Lemmih> chemistree: Yes, I was a fulltime Haskell coder for a couple of years. Now I'm back in school.
05:06:35 <mike-burns> Linus Torvalds is bad at things, but worse is better.
05:07:32 <chemistree> nice oxymoron
05:09:01 <Leif_Bork> Hi! If you have a program that compares bytestrings very very much, performance is of importance, and you know there are reoccurring strings, would you replace the strings with hashes or something?
05:09:25 <chemistree> Lemmih: what school?
05:09:42 <Guest37712> Is there an easy way to determine the cause of a stack space overflow?
05:12:09 <hughfdjackson> just a bit of a 'duh' question
05:12:20 <Leif_Bork> Mine?
05:12:20 <hughfdjackson> what practical advantage is there to monads over your traditional imperative state-keeping?
05:12:28 <hughfdjackson> Leif_Bork: no, mine ;)
05:12:44 <Leif_Bork> Aah =)
05:13:11 <Leif_Bork> So I guess I wonder if the hash is stored in the bytestring, and if not, if it is costful to calculate it
05:14:03 <chemistree> mike-burns: If I were to copy and paste your gitlog.hs code into my text editor, save, and run in ghc. how would I use it? What would it do for me (or anyone else)?
05:14:18 <mike-burns> Leif_Bork: I think you'll need to try it and benchmark this.
05:14:59 <chemistree> or is my "copy -paste - save- run" idea wrong from the get go?
05:15:03 <mike-burns> chemistree: `cabal install github' first. Or, if you clone the repo, you can    runhaskell samples/Repos/Commits/GitLog.hs   and it'll just work.
05:15:30 <mike-burns> Well, you should    cabal install github    anyway.
05:15:34 <Leif_Bork> mike-burns: Thanks!
05:16:36 <chemistree> mike-burns: nice prime number identifier!
05:16:52 <mike-burns> chemistree: It will show all commits to the hardcoded git repo, specified in that file. You can change the strings on line 7 if you want, or you can play with the  getArgs  function to expand the sample.
05:16:54 <mike-burns> Thank you!
05:18:40 <aadrake> Is there an easy way to determine the cause of a stack space overflow?
05:19:42 <aadrake_> Weird
05:20:37 <chemistree> although the code is a bit over my head (I am only a familiar with list comprehensions and some pattern matching!) I think it is good to read your code. Familiarize myself with the language
05:21:26 <mike-burns> chemistree: The formatCommit and formatAuthor functions should be straightforward; they pull strings out of a data structure and combine them with (++).
05:21:52 <chemistree> I will look into github and see what it could do for me, along with trying to understand what your repository does on top of that... might take me some time...
05:22:09 <mike-burns> Good luck there. git is a lot to master.
05:22:22 <mike-burns> aadrake: I wish I knew the answer to your question.
05:23:19 <aadrake> mike-burns: I don't know what is causing the overflow in my code, so I'm not sure how to refactor.  I'm thinking that it has something to do with liftIO and mapM_ but I'm not sure
05:23:41 <chemistree> mike-burns: so formatCommit and formatAuthor are pulling strings out of a data structure native to github? that is why I need github in order for your "patch" to do anything for me?
05:24:00 <mike-burns> aadrake: http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/profiling.html - any advice I give would probably come from this.
05:24:21 <mike-burns> chemistree: Yes, the data structure is part of this github package.
05:24:58 <mike-burns> chemistree: This github package you're looking at provides data structures representing everything on the GitHub Web page, along with functions to populate those data structures.
05:25:56 <aadrake> mike-burns: I'm still working with the MongoDB library, but having some trouble operating on a cursor instead of a result set because the cursor has type Maybe Document.  Have you worked with it before?
05:26:13 <mike-burns> I have not.
05:27:25 <aadrake> mike-burns: Ah well.  The documentation battle continues :)
05:27:58 <mike-burns> It might help to investigate the source code, though that's a awful suggestion most of the time.
05:36:11 <aadrake> mike-burns: I sent an email to the person listed as the library owner on github so we'll see what comes of it.
05:41:22 <asda8> how would I replace an element in an association list?
05:41:45 <mjrosenb> aadrake: you seem to have an extra letter
05:42:02 <mike-burns> @h [(a,b)] -> a -> b -> [(a,b)]
05:42:03 <lambdabot> Maybe you meant: hackage help hitchcock hoogle hoogle+ . ? @ v
05:42:10 <mike-burns> @hoogle [(a,b)] -> a -> b -> [(a,b)]
05:42:11 <lambdabot> Data.Graph.Inductive.NodeMap delMapNode :: (Ord a, DynGraph g) => NodeMap a -> a -> g a b -> g a b
05:42:11 <lambdabot> Data.Graph.Inductive.NodeMap insMapNode_ :: (Ord a, DynGraph g) => NodeMap a -> a -> g a b -> g a b
05:42:11 <lambdabot> Data.Graph.Inductive.NodeMap delMapNodes :: (Ord a, DynGraph g) => NodeMap a -> [a] -> g a b -> g a b
05:42:50 <chemistree> I want to set a lenght limit of say, 10, to pi
05:43:00 <aadrake> mjrosenb: What do you mean?
05:43:05 <aadrake> mjrosenb: Extra letter?
05:44:50 <chemistree> Oh, maybe it would be better to do: GHC> take 10 [pi]
05:45:18 <chemistree> answered myself
05:46:52 <hpaste> ecyrb pasted “STM problem?” at http://hpaste.org/55837
05:47:13 <ecyrb> ^ yeah, I'm stuck
05:47:41 <mjrosenb> aadrake: my bad, I have a friend whose nick is 'adrake'
05:48:28 <chemistree> Actually not quite....  why does  "take 4 [1..10]" give "[1,2,3,4]", while "take 4 [pi]" gives "[3.141592653589793]"?
05:49:23 <mike-burns> :t take
05:49:24 <lambdabot> forall a. Int -> [a] -> [a]
05:49:35 <mike-burns> > length [pi]
05:49:36 <lambdabot>   1
05:49:43 <chemistree> the length of 'take 4 pi' should be 4, [3.141], instead the length is more like 15 or so
05:49:56 <mike-burns> :t pi
05:49:57 <lambdabot> forall a. (Floating a) => a
05:50:20 <Clint> > pi
05:50:21 <lambdabot>   3.141592653589793
05:50:31 <mjrosenb> chemistree: [pi] is a list of a single floating point value
05:50:34 <aadrake> mjrosenb: Tell your friend that I wouldn't mind having their name :)
05:50:43 <chemistree> length [pi]... I see, still why is there a such a low limit to pi output?
05:50:58 <mjrosenb> chemistree: so th length should be one.
05:52:02 <mike-burns> What, you want more pi?
05:52:03 <Clint> > take 4 (show pi)
05:52:04 <lambdabot>   "3.14"
05:52:18 <chemistree> well I at least want the option to see more pi
05:52:32 <ben> i, too, would like the option for more pie
05:52:52 <mike-burns> If you're doing that level of calculation you might need to compute your own pi.
05:53:16 <mike-burns> @hoogle tau
05:53:16 <lambdabot> package tau
05:53:17 <lambdabot> Network.HTTP.Base getAuth :: Monad m => Request ty -> m URIAuthority
05:53:17 <lambdabot> Network.Browser getAuthorities :: BrowserAction t [Authority]
05:53:18 <chemistree> of course I could google pi and take a longer pi output and assign it to a new name: [pi'] or something like that
05:53:24 <mjrosenb> chemistree: so i think the only type that implements Floating are the IEEE floating values, which are limited to about 47 bits of precision
05:55:06 <chemistree> ben: LOL
05:58:08 <chemistree> I think a way to side-step the 47 bit limit would be to drop the "3." and just assign the decimal value of pi to a new name "morePi = 14159265358979323846264338327950288419716939937510..."
05:58:30 <ben> How are you going to use it in calculations?
05:58:33 <chemistree> assign the decimal value of pi as an integer,
05:58:40 <chemistree> I'm not
05:58:50 <chemistree> I will use it for patterns
05:59:33 <chemistree> squences of the value that have prime sums can be grouped and used
06:01:12 <chemistree> such as: [1 4], [1 5 9 2]
06:01:32 <chemistree> in other words: [5], [17], ...
06:03:28 <chemistree> so a function would have to be assigned to  morePi that groups each sequence of adjacent numbers that sum to prime.
06:04:18 <tulcod> i'm in a VPS and just installed ghc, but ghci doesn't give me a Prelude> prompt. the cursor just sits there. i can enter stuff though (which i can't see, much like a password prompt), which is executed just fine, but just can't see a prompt or my own input. any ideas?
06:04:46 <tulcod> for example, typing "hello" (blindly) and pressing enter results in getting "hello" back
06:05:05 <chemistree> or would that have to be done manually? by assigning [1 4] = s1, [1 5 9 2]  = s2... and so on... that would be way to laborious
06:05:45 <chemistree> try setting the prompt
06:05:58 <tulcod> :set prompt "hello " doesn't help
06:05:59 <chemistree> :set prompt "GHC> "
06:06:16 <tulcod> it doesn't give an error message either, though
06:06:26 <ecyrb> nevermind.  I'm an idiot.
06:06:45 <chemistree> did you try reopening GHC?
06:06:53 <tulcod> yes
06:07:01 <tulcod> and python's interactive shell works fine :P
06:07:50 <solarus> tulcod: try another terminal like xterm
06:08:08 <solarus> logging in from xterm that is
06:08:14 <tulcod> it's some kinda old openvz setup, by the way
06:08:26 <tulcod> running linux 2.6.18, i think
06:08:58 <chemistree> 5 + 2
06:09:09 <tulcod> solarus: same
06:09:22 <chemistree> lamdabot
06:09:51 <solarus> > 5 + 2
06:09:52 <lambdabot>   7
06:10:09 <chemistree> > 5 *2
06:10:10 <lambdabot>   10
06:10:18 <chemistree> > pi
06:10:19 <lambdabot>   3.141592653589793
06:10:34 <chemistree> > fib
06:10:35 <lambdabot>   Not in scope: `fib'
06:10:53 <chemistree> > 89/244
06:10:53 <lambdabot>   0.36475409836065575
06:11:07 <chemistree> > 244/89
06:11:07 <lambdabot>   2.741573033707865
06:11:19 <chemistree> k, I get it
06:11:30 <chemistree> ...
06:11:40 <chemistree> > "hey"
06:11:40 <lambdabot>   "hey"
06:11:59 <aadrake> >:t iterateUntil
06:12:17 <chemistree> :t iterateuntil
06:12:18 <lambdabot> Not in scope: `iterateuntil'
06:12:20 <tulcod> any ideas? ghci doesn't say "Prelude> " at each line, and input is much like a password prompt, ie blind, but otherwise its output works fine
06:13:07 <mjrosenb> tulcod: i'd strace it.
06:13:22 <aadrake> chemistree: Strange.  I wonder why it doesn't show up
06:13:38 <chemistree> what is it suppose to do?
06:13:48 <chemistree> iterateuntil
06:14:17 <aadrake> chemistree: It's in Control.Monad.Loops
06:14:21 <mjrosenb> @hoogle iterateuntil
06:14:21 <lambdabot> No results found
06:14:28 <mjrosenb> @hoogle iterateUntil
06:14:28 <lambdabot> No results found
06:14:41 <chemistree> hoogle? or google?
06:14:52 <mjrosenb> chemistree: hoogle
06:14:56 <mjrosenb> @hoogle foldr
06:14:57 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
06:14:57 <lambdabot> Data.List foldr :: (a -> b -> b) -> b -> [a] -> b
06:14:57 <lambdabot> Prelude foldr1 :: (a -> a -> a) -> [a] -> a
06:15:17 <tulcod> mjrosenb: it explodes
06:15:52 <chemistree> @hoogle iterateuntil
06:15:53 <lambdabot> No results found
06:16:18 <tulcod> mjrosenb: http://pastebin.com/KtHVDyaD
06:16:20 <tulcod> ad infinitum
06:16:20 <mauke> The paste KtHVDyaD has been copied to http://hpaste.org/55838
06:19:26 <mjrosenb> tulcod: yeah... ghc does some evil things with sigalarm
06:19:51 <mjrosenb> tulcod: i'd recommend that you ignore those
06:20:20 <chemistree> is github simply a place to share code? opensource heaven?
06:20:22 <nexion> I remember there being a language extension that allowed referring to type variables from functions... does anyone know what it's called?
06:20:35 <tulcod> chemistree: basically, yeah. you can create git repositories there
06:27:36 <Saizan> nexion: ScopedTypeVariables
06:28:39 <nexion> that's the one, thanks :)
06:28:41 <chemistree> so is github used for storing code of any language? Also, can anyone take bits and pieces of otherpeoples code and use it for their own program?
06:28:57 <yrlnry> github can be used to store anything at all.
06:29:16 <yrlnry> Git works better with text files than with not-text files however.
06:29:18 <mjrosenb> chemistree: it is like sourceforge, but only for git, and a bit less geared towards having a 'project'
06:29:39 <ion> chemistree: Whenever you use a library (such as libc) you’re using bits and pieces of other people’s code for your own program.
06:30:51 <Ke> using github has no effect on the legal status of your code
06:31:48 <hughfdjackson> https://gist.github.com/1534483 i'm getting an error while doing the 'write yourself a scheme in 48 hours' tutorial
06:31:51 <Ke> besides making it accessible (well it actually might have an effect in some countries)
06:31:53 <mike-burns> chemistree: There are also private repos, which you can't see.
06:32:10 <hughfdjackson> :3 i don't suppose i could bother some of you fellows/fellettes to have a gander?
06:32:20 <mjrosenb> mike-burns: not that you can prove their existence :-p
06:32:30 <mike-burns> Hah.
06:32:56 <mike-burns> hughfdjackson: What if you move the    char '"'   to the next line?
06:33:00 <mjrosenb> hughfdjackson: haskell is whitespace sensitive
06:33:04 <yrlnry> hughfdjackson:  line 31 is not indented past the "do", so haskell doesn't understandc that you want it to be part of the do block.
06:33:12 <hughfdjackson> OH
06:33:16 <hughfdjackson> *past* the do
06:33:42 <yrlnry> You can write do { .... } and indent it however you like, or you can indent the contents of the block to the right of the "do".
06:33:50 <yrlnry> (Or move the "do" itself leftward similarly.)
06:34:03 <hughfdjackson> mike-burns: which char '"'?
06:34:06 <hpc> it doesn't have to be to the right of the "do" either; just different from the alignment of the "do"
06:34:08 <hughfdjackson> line 30?
06:34:10 <mike-burns> hpc: The one on line 30.
06:34:14 <hpc> but definitely have it somewhere to the right :P
06:34:29 <aadrake> Have any of you guys seen this? http://hackage.haskell.org/packages/archive/monad-loops/0.3.1.1/doc/html/Control-Monad-Loops.html
06:34:55 <hughfdjackson> okay, fixed :)
06:34:56 <mike-burns> Nope,but it looks nice.
06:35:10 <hughfdjackson> turned out my indentation was okay, but mike-burns' suggestion was a must
06:35:24 <hughfdjackson> + changing the last line to return $ String x
06:36:11 <mjrosenb> hughfdjackson: you should be able to have the char '"' on the same line as the do, just x needs to be lined up with the c in char.
06:36:29 <hughfdjackson> oOo
06:36:30 * hughfdjackson tries
06:37:11 <hughfdjackson> seems like no dice
06:37:23 <nexion> if I have a function with the signature "(Integral a, Bounded a) -> a" and would like to call maxBound on the type that is a, how can this be achieved?
06:37:48 <hpc> nexion: you mean "(Integral a, Bounded a) => a -> a?
06:37:55 <nexion> yeah, that
06:38:00 <nexion> er wait..
06:38:05 <hughfdjackson> the problem's solved in another way :) i'm sure once i understand it well enough i'll get it
06:38:12 <nexion> it only returns a, doesn't take an a
06:38:27 <hpc> :t (. maxBound)
06:38:28 <lambdabot> forall a b (f :: * -> *). (Bounded (f a), Functor f) => (a -> b) -> f b
06:38:41 <hpc> :t (Prelude.. maxBound)
06:38:42 <lambdabot> forall b c a. (Bounded (a -> b)) => (b -> c) -> a -> c
06:39:05 <hpc> :t (maxBound Prelude..) -- derp, this
06:39:06 <lambdabot> forall b c a. (Bounded (b -> c)) => (a -> b) -> a -> c
06:39:06 <mjrosenb> hughfdjackson: seems to work for me :/
06:39:14 <hpc> ...or not
06:39:42 <ion> hughfdjackson: The left hand side of all the lines in the do block (beginning from the word after “do”) should form a vertical line.
06:40:05 <nexion> to put that into context, I'm trying to write a function that will verify the bounds of its only argument and make sure converting it into the return type will not cause an overflow
06:40:21 <hughfdjackson> ion: :D win
06:40:29 <hughfdjackson> i was indenting it *past* the c in char
06:40:34 <hughfdjackson> not *to* the c in char
06:42:14 <nexion> so my question is how to get the bounds of the return type
06:42:40 <litb> does haskell even have a notion of "sizeof"?
06:42:45 <hughfdjackson> without meaning to be an irritating newbie
06:42:51 <litb> it doesn't seem to be byte processing
06:43:05 <hughfdjackson> what is the point of char '"' in that do block? (block?)
06:43:07 <hpc> @hoogle range
06:43:07 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
06:43:07 <lambdabot> Data.Ix rangeSize :: Ix a => (a, a) -> Int
06:43:07 <lambdabot> Language.Haskell.TH.Syntax data Range
06:43:24 <hughfdjackson> :P i thought it looked like an empty statement, so to speak, and removed them both.. with no ill effects
06:44:10 <litb> > range (1, 20)
06:44:11 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
06:44:14 <litb> hm
06:44:44 <litb> Int implements the type class  Ix
06:45:27 <hpc> > rangeSize (1, 50)
06:45:28 <lambdabot>   50
06:46:12 <litb> how can i make lambda bot spit out the  Ix Int  instance ?
06:46:23 <litb> @instance Ix Int
06:46:23 <lambdabot> Maybe you meant: instances instances-importing
06:49:55 <tulcod> chemistree: if you're interested, i tracked back the disappearing prompt problem. it's something to do with /dev/tty which is not created in the right way by default, or something like that
06:50:41 <megamix> how can i use filename :: String in two data constructors
06:53:57 <megamix> how can i do data File = File {filename :: String}  and data File2 = File2 {filename :: String}
06:54:56 <hpc> megamix: you don't; at least, not in the same scope
06:55:41 <hpc> megamix: what would be the type of 'filename'?
06:55:53 <megamix> there is no way to do that, like predifining filename
06:55:58 <chemistree> tulcod: interesting, does that have to do with the version of GHC you are running?
06:56:27 <tulcod> i haven't tried any different versions
06:56:35 <megamix> filename is just a string
06:56:43 <chemistree> I downloaded the Haskell package that comes with GHC, did not have that problem myself
06:56:57 <tulcod> well this is in some weird openvz install
06:59:36 <chemistree> tulcod: by the way, I have no clue what "/del/tty" means... but something that is also a little 'off-line' in GHC is the ":t" command under ":?"
06:59:52 <chemistree> it is off to the right after ":script"
07:02:35 <tulcod> chemistree: /dev/tty is a linux device file... /dev contains a couple of crucial files representing physical and virtual block devices
07:02:39 <tulcod> so it's an OS thing
07:02:57 <chemistree> ok,
07:04:08 <chemistree> I am running windows at the moment, plan to have linux distro (not sure which, I am thinking ubuntu to start with) in about a week when netbook arrives.
07:05:25 <hpc> chemistree: if you are leaning towards ubuntu now, might i suggest debian
07:05:37 <hpc> chemistree: with the stable and testing repos both turned on
07:06:23 <tulcod> hpc: why's that?
07:06:25 <Brandon_R> hey guys
07:06:29 <hpc> it's basically ubuntu with less ridiculous policies about when you can be root, and faster updates
07:06:31 <chemistree> hpc: thnks for the suggestion
07:06:32 <tulcod> chemistree will want an easy setup
07:06:47 <chemistree> tulcod: yes
07:06:51 <tulcod> ubuntu is way easier to get started with than debian
07:07:13 <mrcarrot> hpc: as somebody that has to fight with debian servers, i definitely do not recommend to have two different kind of repos activated
07:07:34 <tulcod> sure, ubuntu has a lot of disadvantages as well, but the install procedure is definitely an advantage
07:07:56 <hpc> i didn't find debian to be any harder to install than ubuntu
07:08:09 <hpc> almost easier, in fact
07:08:15 <mrcarrot> the sad thing is that i can neither recommend debian nor ubuntu as both are really bad. debian stable has only ghc 6
07:09:10 <tulcod> why'd you use debian stable :P
07:09:24 <tulcod> debian stable is for rockets and submarines
07:09:30 <mrcarrot> because testing is very often really broken. at least when i have been trying
07:09:54 <mrcarrot> i have been giving it a go a few times... and each time a thumb down
07:10:24 <tulcod> chemistree: should you ever feel like something more geeky, i can recommend arch linux. but just start with ubuntu, it's one of the easiest distros out there
07:10:44 <mrcarrot> tulcod: even worse... debian testing is at least better than arch
07:10:56 <tulcod> mrcarrot: i have never had breakage with arch
07:11:11 <chemistree> I am trying desperately to find a linux distro (i believe it is a distro, it may just be a program however) for audio and visual editing
07:11:15 <hpc> ive never managed to install arch
07:11:18 <hpc> ...ever
07:11:23 <chemistree> like a linux replacement for Photoshop
07:11:29 <chemistree> I cannot remember the name...
07:11:29 <hpc> it just keeps breaking for silly reasons
07:11:33 <tulcod> chemistree: most distributions offer roughly the same packages
07:11:39 <hpc> missing packages, missing ethernet drivers
07:11:40 <tulcod> chemistree: gimp?
07:11:42 <mrcarrot> chemistree: any distro has gimp... and audacity
07:11:50 <tulcod> ^
07:12:39 <chemistree> gimp sounds good, but that is not what I am referring to...
07:12:44 <mrcarrot> my preferences goes in this order: openbsd (not linux), slackware/salixos, scientific linux
07:12:45 <tulcod> inkscape?
07:12:56 <tulcod> mrcarrot: please don't touch my machines
07:13:18 <mrcarrot> tulcod: i will not, unless you pay me for doing it. i have enough with work
07:13:27 <mbernstein> Building ghc isn't particularly hard and there's a 64bit binary download so you can build future versions or the haskell-platform - debian having ghc6 isn't that good of a reason to ignore it
07:14:54 <aadrake> mrcarrot: Are you sure that testing has ghc6?
07:15:57 <hpc> testing has ghc7 and a totally separate ghc6 package
07:15:57 <mrcarrot> aadrake: i talked about stable... testing might have 7, or with big probablility have
07:16:08 <mbernstein> sid definitely has 7
07:16:20 <hpc> plus oodles of "libghc-..." and "libghc6-..." packages
07:17:11 <chemistree> does anyone know of a linux distro that is entirely built towards image manipulation and audio manipulation?
07:17:29 <chemistree> I cannot remember the name...
07:17:43 <hpc> mint has a particular emphasis on having oodles of codecs
07:17:59 <hpc> it could easily have the manipulation packages too
07:18:18 <aadrake> chemistree: I'm not sure, I like Debian for everything so that's all I've used for years.
07:18:43 <tulcod> chemistree: most distros support most software
07:18:53 <chemistree> logo is something like a circle with a ... a... oh man this is bothering me...
07:19:03 <hpc> chemistree: burrito!
07:19:05 <tulcod> chemistree: it's not a thing worth considering when you're choosing a distro. you consider its stability, the number of packages offered, how up to date things are, the way the package manager works, etc
07:19:21 <chemistree> ok, maybe it is not a distro, but just a program...
07:19:42 <tulcod> the init system, even
07:19:59 <chemistree> hpc: can you link me to burrito
07:20:01 <tulcod> how quickly it boots, i suppose, although that can be tweaked
07:20:12 <chemistree> that is ringing a bell... faintly
07:20:27 <hpc> chemistree: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Monad -- the Burrito type class :D
07:21:00 <tulcod> it's like a taco, within a taco, ...!
07:21:42 <chemistree> oh...
07:21:58 <hpc> @quote burrito
07:21:58 <lambdabot> syntaxglitch says: a monad is an endospacesuit on a burrito category
07:22:02 <srhb> Why do I always see a `seq` b in examples and not just seq a b? Is there some magic going on here?
07:22:11 <hpc> srhb: it's just infix notation
07:22:15 <hpc> srhb: makes it easier to read
07:22:16 <srhb> Yes, I know that.
07:22:20 <srhb> Hm.. Okay.
07:22:30 <hpc> it's also why you might see x `elem` xs
07:22:41 <companion_cube> java n'edst pas un langage de niche ? !
07:22:44 <srhb> that one I get because it approaches normal spokes English.
07:22:46 <hpc> it reads more like "x ∈ xs"
07:22:55 <hpc> and also like english
07:23:00 <companion_cube> oops, wrong chan
07:23:05 <tulcod> :P
07:23:52 <srhb> OK, so convention and some people think it's easier to read. I'm glad to hear that, I was starting to suspect it would only actually work in infix notation. :-)
07:30:17 <srhb> Once a function has been evaluated for a given set of arguments, is it's value cached, and can I rely on this?
07:30:32 <Saizan> nope
07:30:36 <srhb> To both?
07:30:41 <Saizan> yeah
07:30:50 <srhb> Hm. So it's a ghci thing.
07:30:59 <Lemmih> What is?
07:31:13 <maltem> srhb, it is not cached, but if you use *the same binding* again then that value is retained
07:31:18 <srhb> I see.
07:31:33 <hpc> you can do some oddness with let...in and lambda to achieve memoization
07:31:37 <hpc> but i don't understand it
07:32:22 <Saizan> right, if you have "let x = f arg in (x,x)" then f arg will only be evaluate once even if you use x twice
07:32:27 <maltem> So, if you write f 1000 and in another place you write f 1000 again, it will be computed again. On the other hand, you can "cache" the value by writing, say, let x = f 1000 in 
07:32:50 <Saizan> *even if x is used twice
07:32:52 <srhb> Got it. That is exactly what was happening, I just forgot to think of "main" as a biding.
07:35:13 <tulcod> maltem: is that standardized to any degree?
07:38:44 <ncs> i have created a module (say module Test) in which i have defined a datatype. Now I want to import this to another file but when i just say import Test then i don't see that datatype in the new file.. does anyone know how i can do that?
07:39:18 <aadrake> ncs: I'm pretty new to this, but I think Real World Haskell has a chapter on creating/importing/using modules.
07:39:47 <mrcarrot> so does LYAH
07:41:03 <maltem> tulcod, I don't think so, no. Except that it would be common sense for anyone who dares to write a Haskell compiler
07:41:39 <maltem> Among ghc developers it is referred to as sharing
07:41:57 <tulcod> maltem: well i would guess you can cache stuff more often
07:42:21 <tulcod> i mean, what you're saying is that caching happens only when non-lazy evaluation would have directly given you the value anyway
07:42:26 <tulcod> if that makes any sense
07:42:54 <maltem> tulcod, a particular more agressive stance on retaining values is referred to as Common Subexpression Elimination, or CSE
07:43:29 <tulcod> hm, i can take a guess as to how that would work
07:44:09 <tulcod> maltem: would you happen to know of any truly insightful methods as well?
07:44:21 <maltem> (CSE is often considered as not feasible, or too hard to implement in general. The more you retain, the more you have to think about space leaks)
07:44:53 <maltem> I cannot think of any
07:45:00 <tulcod> hm ok
07:47:04 <xcycgx> i need cvv
07:56:02 <chemistree> looking for something like gimp, only it is different in that it does audio as well. and it is on version 10.'something', or higher
07:57:06 <chemistree> it might actually be a distro... I dont really know, someone suggested it on  http://www.mpc-forums.com/memberlist.php?mode=viewprofile&u=38638 , now I cannot find that comment
07:58:01 <aadrake> chemistree: Audacity?
07:58:10 <aadrake> chemistree: You can do some basic audio editing and stuff with that
07:58:52 <chemistree> the discussion went from audacity -> rosegarden -> _________
08:00:46 <chemistree> yeah I like audacity, although the program I am looking for also does visual (like photoshop) and the audio part can sequence sound.
08:01:22 <chemistree> I believe it is soley for Linux.... and strangly it is a distro itself...I think
08:01:30 <aadrake> chemistree: I have no idea
08:02:00 <hpc> JACK?
08:02:19 <hughfdjackson> hpc: JACKs an audio server
08:02:23 <hughfdjackson> it's very unlikely to be that
08:02:45 <hughfdjackson> chemistree: >.> unfortunately i'm drawing a blank on this one
08:03:00 <chemistree> thats ok, i'll keep looking. The webpage for it was very nice, super professional and sleek looking.
08:03:45 <chemistree> starts with a D... i'll leave it at that
08:06:51 <chemistree> Ubuntu studio
08:06:55 <chemistree> !! lol
08:06:58 <chemistree> what a relief
08:07:00 <hughfdjackson> haha
08:07:05 <hughfdjackson> isn't that always the way?
08:08:17 <aadrake> chemistree: I don't think that starts with a D
08:08:33 <chemistree> http://ubuntustudio.org/files/US4.png what is happening here? is this image editing program part of Ubuntu Studio or a seperate program
08:08:46 <chemistree> aadrake: you got it, I was way off huh
08:09:05 <aadrake> chemistree: That is a cool website though
08:09:17 <aadrake> chemistree: Interesting distribution
08:10:44 <chemistree> someone suggested Ubuntu to me earlier... do you think ubuntu studio would also be a user friendly distro?
08:11:43 <hughfdjackson> chemistree: the svg editing program is inkscape
08:11:48 <mjrosenb> chemistree: not sure what you mean by 'a separate program'
08:11:48 <hughfdjackson> you can get it on any x11 supporting system
08:11:57 <hughfdjackson> inc max OSX and ubuntu standard
08:12:03 <mjrosenb> chemistree: there are about 4 different image editing programs running at once there.
08:12:40 <chemistree> lets put it this way, I don't know what I am talking about
08:13:04 <mjrosenb> chemistree: figured that out already :-p
08:14:30 <chemistree> what I do know is I want to be able to edit images similarly to photoshop and audio similarly to audacity or reason, all on linux. Ubuntu studio seems like it does that well. But I dont know if it will do so any better than regular Ubundu... thats where I am at
08:16:10 <chemistree> hughfdjackson: "the svg editing program is inkscape" refering to that image I linked to?
08:16:47 <aristid> seems to be pretty easy to capture haskell-cafe with a flamewar
08:16:58 <hughfdjackson> chemistree: yup
08:17:04 <mike-burns> aristid: We are programmers, afterall.
08:17:22 <monochrom> where is the flame war?
08:17:45 <aristid> monochrom: that never-ending purity thread
08:17:56 <aristid> i told gmail now that it should be ignored
08:18:30 <aristid> i guess there have been worse threads, but i have had a... haskell-cafe subscription pause for a few months now
08:19:56 <monochrom> oh, and I thought my lazy strict was bad enough
08:20:14 <k0ral> hi, I'm reading some Haskell code and I'm surprised to see the following syntax: (`function1` function2 argument); given the context, I would interpret it as (function1 $ function2 argument), is that right ?
08:20:45 <opqdonut> k0ral: nah, taht's (\x -> function x (function2 argument))
08:21:03 <opqdonut> think sections: (+ 1), (+ 2*2)
08:21:17 <opqdonut> > (+ inc 1) 2
08:21:18 <lambdabot>   Not in scope: `inc'
08:21:31 <opqdonut> > (+ succ 1) 2
08:21:32 <lambdabot>   4
08:21:34 <opqdonut> there
08:21:51 <k0ral> where is this syntax documented ?
08:22:03 <opqdonut> e.g. in the haskell report
08:22:44 <aadrake> What is the output type of liftIO?
08:22:47 <monochrom> purity and referential transparency are relative. when you re-draw the line between the observable and the unobservable, and the line between what you input and what you don't input, then that also re-defines referential transparency. and so different people at different times have different opinions on what's referential transparency. purity is even worse.
08:22:51 <aadrake> :t liftIO
08:22:51 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
08:23:30 <monochrom> @quote monochrom debates
08:23:30 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
08:23:33 <aadrake> So if I were writing a type signature for a function that uses liftIO, what would be the rightmost item?
08:23:34 <monochrom> :)
08:24:39 <monochrom> oh, has anyone mentioned that blog post about "C is a pure language too" yet? :)
08:25:03 <hughfdjackson> :P wait wut?
08:25:05 <mike-burns> aadrake: Probably    (MonadIO m) => m a   though you can also try writing the function and using type inference.
08:25:06 <hughfdjackson> linkies
08:26:03 <aadrake> mike-burns: So then the type definition would be functionName :: [Document] -> (MonadIO m) => m a?
08:26:13 <aadrake> I don't even know if that makes syntactical sense.
08:26:26 <monochrom> I have forgotten the url altogether. the gist is "your C program is just a recipe of actions sitting there", in the same sense that "your IO code is just a recipe of actions sitting there", and both are pure.
08:26:41 <mike-burns> aadrake: functionName :: (MonadIO m) => [Document] -> m a
08:26:48 <monochrom> and I don't know whether that's sarcasm or a fresh perspective or both
08:27:33 <aadrake> mike-burns: Got it
08:27:49 <miden> hi
08:28:32 <aadrake> mike-burns:  Not in scope: type constructor or class `MonadIO'
08:28:54 <mike-burns> @hoogle MonadIO
08:28:55 <lambdabot> Control.Monad.IO.Class class Monad m => MonadIO m
08:28:55 <lambdabot> package monadIO
08:28:56 <aadrake> mike-burns: Which is weird, since the code works without the type signature
08:29:21 <mike-burns> aadrake: import Control.Monad
08:29:54 <aadrake> mike-burns: I'm guessing it works because I already have import Control.Monad.Trans (liftIO)
08:30:36 <mike-burns> Yup.
08:30:55 <miden> question: I want to learn about happy and alex... I created my .x file and i executed like alex token.x ... What's the next step? After that i cannot import Token in my main prog...Haskell cannot find the datatypes...
08:31:07 * chemistree is dancing a jig 
08:31:25 <chemistree> stoked that I found Ubuntu studio
08:31:45 <chemistree> ..."re"found, I should say
08:31:55 <aadrake> I'm out for now.  Have a good evening all.
08:32:15 <chemistree> good morning here,
08:32:20 <miden> question: I want to learn about happy and alex... I created my .x file and i executed like alex token.x ... What's the next step? After that i cannot import Token in my main prog...Haskell cannot find the datatypes... ...?
08:32:20 <chemistree> later aadrake
08:34:04 <miggyx> hmm, after playing with Haskell, I looked at some other functional languages. I was finding Haskell quite a challenge so thought I might try something easier… turns out the bits that I was having trouble with are the best bits. For example another language which allows IO wherever you want, loses some of the best things about pure functions. So I've given up on that and gone back to Haskell :)
08:35:00 <monochrom> it may have also made your life easier by bootstrapping with another functional language first
08:35:14 <mike-burns> miden: hpaste some code, maybe?
08:35:43 <hpc> miggyx: haha, i didn't fully appreciate haskell's syntax until i tried lisp
08:36:09 <miden> my output file wokrs m8. But when try to import that file in my main prog .. it cannot find anything
08:36:13 <miden> and the code is huge :s
08:36:31 <hpc> there's something about (map (f . g)) that (lambda (xs) (mapcar (lambda (x) (f (g x))) xs)) can't quite reproduce :P
08:36:51 <miggyx> hpc: plus some of the things I want to do is fairly simple in Haskell but almost impossible to do elsewhere - precisely because of the enforced purity
08:40:00 <miggyx> hpc: There are some nice moments with Haskell though - like when your brain finally grasps polymorphic parameters :)
08:44:16 <k0ral> how close to evil are IORef-s ?
08:44:57 <Lemmih> k0ral: Not very.
08:45:51 <zachk> IORef-s still fit into the type system and are managed by compiler
08:47:22 <k0ral> fine, so I'm not throwing away this piece of code and I shall keep reading it :)
08:48:15 <k0ral> but can't IORef always be replaced with the State monad ?
08:48:20 <hpc> not always
08:48:48 <hpc> at least, not always in a simple way
08:49:23 <hpc> and it might have different performance
08:49:32 <hpc> same goes for ST
08:49:51 <k0ral> do you mean a better performance for IORef ?
08:49:51 <hpc> sometimes it's just too hard to write something functionally, and you just need mutation
08:52:05 <zachk> like interfacing with openGL
08:52:52 * edwardk waves hello
08:53:19 * hpc particles
08:58:11 * zachk frobnicates 
09:06:42 <wavewave> hi
09:06:48 <mmaruseacph2> hi
09:15:09 <miden> can someone explain to me how is it possible to connect the datatypes from a alex file to your main program? It cannot find them...
09:15:59 <hughfdjackson> thunk is possibly the best bit of jargon ever
09:16:06 <chemistree> what is the type of  3.55
09:16:07 <chemistree> ?
09:16:19 <hughfdjackson> :t 3.55
09:16:20 <lambdabot> forall t. (Fractional t) => t
09:16:29 <hughfdjackson> > :t 3.55
09:16:30 <lambdabot>   <no location info>: parse error on input `:'
09:16:33 <hughfdjackson> durn
09:17:12 <hughfdjackson> oh, wait
09:17:20 <hughfdjackson> it worked the first time :p
09:19:23 <monochrom> 3.55 is polymorphic. defaults to Double
09:33:56 <edwardk> hrmm. newtype T m a = T { runT :: forall m. Monad n => (forall b. m b -> n b) -> n b } is a cute monad
09:34:04 <edwardk> er forall n. Monad n =>
09:34:17 <edwardk> bah
09:34:18 <edwardk> newtype T m a = T { runT :: forall n. Monad n => (forall b. m b -> n b) -> n a }
09:34:52 <edwardk> where the polymorphic argument is required to be a monad homomorphism, not just a natural transformation
09:35:43 <edwardk> basically its the monad for 'you're allowed to program with side effects in m, but you have to plumb through any other side-effects that the thing that runs you wants
09:35:46 <copumpkin> omg it's an edwardk
09:35:46 <copumpkin> guess what I've finally started working on :P
09:35:46 <hughfdjackson> i think the scheme parser has served to confuse me somewhat
09:35:55 <edwardk> copumpkin: pushing the deadline =)
09:36:06 <hughfdjackson> ^^ i think i'll tackle some of the haskell 99 instead
09:36:33 <wingie> in which fields are haskell used mainly?
09:37:25 <edwardk> wingie: its a general purpose programming language so it finds use in a lot of spaces
09:37:55 <edwardk> that said, its had a lot of success in markets where its useful to be able to prove code correct in the end or even just have a higher degree of confidence in its correctness
09:38:24 <edwardk> so its taken off in the financial space, in designing netlists for cpus (there is a company bluespec with a modified haskel compiler that spits out circuit designs)
09:38:51 <edwardk> its also being used in cryptography, analyzing cryptographic protocols (by galois and out at mitre)
09:39:47 <edwardk> there is a nice version control system in it (darcs) which helped pioneer a lot of interesting ways to resolve patch conflicts, and which in some sense benefits from the very pure nature of the code and the ease of encoding more mathematical thinking
09:41:10 <miden> can someone explain  how is it possible to connect the datatypes from an alex file to your main program? I cannot understand
09:42:13 <KorriX> Is there anybody who __simply__ can explain for what are monads, monoids and functors ?
09:42:41 <wavewave> it's basically a pattern in higher order type
09:43:10 <wavewave> functor may be the easiest.
09:43:12 <mike-burns> KorriX: http://www.haskell.org/haskellwiki/Typeclassopedia
09:43:55 <KorriX> thanks, i haven't read this :)
09:43:57 <wavewave> KorriX : if you understand C++'s standard template library
09:44:08 <mike-burns> Hah.
09:44:38 <wavewave> KorriX : you know many container types are just parameterized.
09:44:50 <litb> why is it that c++ and haskell are often mentioned together
09:44:58 <litb> is there something deeper to it
09:45:06 <monochrom> because people have day jobs with c++
09:45:11 <litb> hmm
09:45:39 <monochrom> you wouldn't bring up PL/I if you haven't used it
09:45:41 <mike-burns> Lots of people who did Haskell years back came to it from C++, possibly because Haskell is another fast, type-checked language, but done right.
09:45:47 <wavewave> litb: of course, without c++, explanation is easier... but i guess the questioner wants to find some context.
09:46:06 <litb> ohh
09:46:19 <mike-burns> These days I suspect more people are coming to Haskell from Python, Ruby, etc.
09:46:37 <monochrom> it also explains why in the 1970s people talked about PL/I in #haskell
09:47:01 <wavewave> KorriX  : then you probably wonder whether there is a general function for generic container type.
09:47:27 <Cale> If you've been a programmer for long enough, you've probably had to learn some C++ at some point.
09:47:30 <KorriX> \say wavewave Can you give me an example of parametrized container in haskell ?
09:47:34 <wavewave> for example.. there are array type and list type
09:47:45 <wavewave> KorriX : lots of them   list is the simplest.
09:47:46 <wavewave> [a]
09:48:14 <wingie> edwardk: could it be compared to erlang?
09:48:20 <wingie> but more dynamical?
09:48:25 <wavewave> KorriX : [a] is  [] a ,
09:48:39 <wavewave> [] is a higher order type like C++ template.
09:48:41 <KorriX> and [] is monad ?
09:48:42 <edwardk> wingie: one sec. i have a writeup on why i use haskell over erlang these days
09:48:46 <wingie> and could it be used as a backend server for a web app like node.js/ruby/php/python/perl?
09:48:52 <wavewave> KorriX: indeed. it's also a monad..
09:49:09 <wavewave> KorriX: but not all higher order types are monad..
09:49:19 <edwardk> http://stackoverflow.com/questions/2199368/why-did-you-decide-against-using-erlang/2200776#2200776
09:49:30 <edwardk> wingie: that says pretty much what i want to say about the relationship with erlang
09:49:33 <KorriX> beautyful language ...
09:49:36 <edwardk> without spamming the channel =)
09:49:44 <tulcod> ugh, guys, i can't click the link when you keep talking!
09:49:54 <wavewave> KorriX : so now consider you have a list type [a] and an map type (Map k a )
09:50:12 <KorriX> map is type ?
09:50:12 <monochrom> use /ignore * to stop everyone from talking
09:50:18 <KorriX> not typical function ?
09:50:33 <wavewave> KorriX: yes.. it's balanced tree type
09:50:46 <wavewave> with key type and value type as parameter.
09:50:58 <wavewave> so Map is even higher order type.
09:51:21 <wavewave> KorriX: or you can compare it with template with two parameters.
09:52:04 <KorriX> sorry - it was 'Map' not 'map' :)
09:52:04 <wavewave> KorriX : anyway, now you want to change each element of type a to of type b with a function f : a -> b
09:52:43 <KorriX> for examle turn list [1,2,3] into ['1','2','3']
09:52:47 <litb> monochrom: i wonder whether /ignore * ignores even yourself?
09:52:52 <wavewave> KorriX: then resultant function must be    [a] -> [b] type for a list.
09:53:08 <wavewave> KorriX: and Map k a -> Map k b for Map type.
09:53:22 <wavewave> [a] -> [b] is actually [] a -> [] b
09:53:31 <monochrom> ha, I don't know
09:53:31 <KorriX> yes
09:53:56 <wavewave> KorriX : so you find aha.. there must be a general class of higher order type
09:54:23 <wavewave> which can change f :: a -> b to (fmap f) :: m a -> m b
09:54:39 <wavewave> KorriX : such type m is called Functor
09:55:27 <wavewave> KorriX : there are many such patterns for higher order types.
09:55:43 <wavewave> Monad, Applicative, Functor ...
09:56:09 <wavewave> KorriX: by the way Monoid is just for simple type, you don't event need higher order types.
09:56:48 <wavewave> KorriX : once you realize those patterns, suddenly lots of generic functions are given to you as free.
09:57:12 <KorriX> Also, what are '>>=', '<*>', '<$>' and '<=<' operators ?
09:57:56 <wavewave> KorriX : they are generic functions that I mentioned for each specific class of the above patterns.
09:58:08 <mike-burns> :t (>>=)
09:58:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:58:18 <wavewave> >>=, <=< for monad, <*> for Applicative, <$> for functor
09:58:50 <wavewave> they are freely given to you, once you know the data type you are dealing with is just Monad, Applicative and/or Functor
09:59:30 <wavewave> explanation of specific meaning of those functions will be too lengthy and deep, so I recommend you to read some good material.
09:59:38 <KorriX> can you give me an practical example of using it ?
09:59:59 <mike-burns> getContents >>= putStrLn
10:00:04 <wavewave> each operator has an alias, >>=  is bind .
10:00:05 <mike-burns> :t getContents
10:00:06 <lambdabot> IO String
10:00:10 <mike-burns> :t putStrLn
10:00:11 <lambdabot> String -> IO ()
10:00:33 <mike-burns> (>>=) is a function for chaining things of the above types.
10:01:04 <wavewave> bind means : get the result from lhs monad and chain it to next rhs function which results in another monad.
10:01:26 <wavewave> I use the term 'monad' rather sloppily.
10:01:26 <KorriX> it looks like pipes in bash
10:01:36 <wavewave> exactly.
10:02:01 <mike-burns> Many things in Haskell look like pipes.
10:02:05 <mike-burns> :t (.)
10:02:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:02:10 <wavewave> KorriX: but in fact, it's real operational meaning can be different for different monads.
10:02:50 <wavewave> monad is more abstract concept than usual sequence of computation.
10:03:10 <wavewave> and that's why beginners easily get lost.
10:03:17 <KorriX> 'do' construction is connected with monad :)
10:03:30 <wavewave> 'do' is a syntactic sugar.
10:03:42 <KorriX> over ugly lambda's
10:04:04 <wavewave> after you learn haskell, you will find haskell is merely a set of syntatic sugars over lambda calculus.
10:04:22 <wavewave> core language of haskell is very simple and concise and consistent
10:05:10 <wavewave> KorriX : so.. just read some easy material and try to write down some example codes.
10:05:33 <rostayob> wavewave: that's not true
10:05:47 <rostayob> well...
10:05:54 <rostayob> can you fully express term rewriting systems in lambda calculus?
10:05:54 <Cale> Well, it's a set of syntactic sugars over System FC or something
10:05:55 <yitz> edwardk: ha! it's hard for me to imagine you programming in erlang
10:05:59 <wavewave> rostayob: I anticipated some objection, ;-P
10:06:01 <KorriX> i wan't to write simple arithmetical parser in haskell :)
10:06:08 <KorriX> *want
10:06:09 <edwardk> yitz: ?
10:06:21 <Cale> I'm not actually sure you can call typeclasses a syntactic sugaring though
10:06:25 <edwardk> yitz: keep in mind i wrote perl for better than a decade ;)
10:06:33 <yitz> as you mentioned there, category-extras...
10:06:41 <rostayob> Cale: haskell 98 type classes are
10:06:45 <monochrom> core language of haskell /= core language of GHC
10:06:51 <yitz> edwardk: ok, so did i, but still.. those were different days
10:06:53 <rostayob> sugar for record passing if you whish....
10:07:10 <KorriX> where are differences beetween haskell and GHC ?
10:07:12 <Cale> rostayob: Well, they have a translation into System F, but it's not local.
10:07:29 <monochrom> Haskell is underspecified, GHC is overspecified
10:07:42 <rostayob> Cale: maybe we should agree about what we mean by "sugar" :P
10:07:46 <hughfdjackson> http://www.haskell.org/haskellwiki/99_questions/Solutions/1 look way different to mine:
10:07:47 <wavewave> okay, okay.. I will not insist that haskell is merely syntactic sugar. the word is rather subjective.
10:07:48 <wingie> arent there times you need oop to solve your problems very simply? if so how do you proceed?
10:07:51 <hughfdjackson> myLast a = a !! (length a - 1)
10:08:18 <rostayob> hughfdjackson: that traverses the list twice
10:08:33 <hughfdjackson> rostayob: :P i was gonna say 'am i doing it wrong?'
10:08:37 <wavewave> just wanted to emphasize that 'do notation' is a syntactic sugar
10:08:40 <hughfdjackson> the answer seems to be.. yes xD
10:08:47 <rostayob> hughfdjackson: I wouldn't say it's "wrong", but it's not efficient
10:08:54 <monochrom> or perhaps you're looking for an answer of the form: "where are the differences between python and pypy?"
10:09:03 <rostayob> also i wouldn't use needlessly a partial function - (!!)
10:09:46 <hughfdjackson> partial function?
10:09:55 <mike-burns> > [] !! 1
10:09:56 <lambdabot>   *Exception: Prelude.(!!): index too large
10:10:02 <hughfdjackson> in the sense of partial application, that doesn't make much sense to me xD
10:10:04 <rostayob> hughfdjackson: function that doesn't accepts all inputs
10:10:14 <rostayob> that fails on some input
10:10:15 <hughfdjackson> oh, okay ^_^
10:10:18 <rwbarton> myLast also doesn't accept all inputs, so in a sense it is necessary
10:10:21 <monochrom> if you don't need inheritance, the rest of OOP can be done with records.
10:10:22 <srhb`> That's very not the same as partial application, to make it clear.
10:10:36 <mike-burns> monochrom: Are we sure don't need inheritance!
10:10:37 <hughfdjackson> :D it has become clear
10:10:39 <rostayob> rwbarton: that's true
10:11:03 <wavewave> KorriX : By the way, I started the discussion with parameterized container for the sake of easy understanding. but higher order type is again much more abstract concept than containers.
10:11:03 <rostayob> i'd still avoid partial functions... then you end up refactoring code and copy-pasting and they're all over :P
10:11:12 <monochrom> I agree, but I'm tired of debates.
10:11:21 <monochrom> @quote monochrom debates
10:11:22 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
10:11:23 <monochrom> :)
10:11:29 <mike-burns> 'Tis the season.
10:11:54 <monochrom> "there is no flying inheritance monster" :)
10:11:56 <KorriX> After three days with haskell i think that python is unsuccessful version of him ...
10:12:09 <yitz> monochrom: some pointless debates can be settled by using @unpl
10:12:39 <rostayob> KorriX: python is a completely different thing
10:12:57 <rostayob> it starts from completely different goals
10:13:03 <rostayob> *with
10:13:05 <MostAwesomeDude> KorriX: Hehe, Python predates Haskell by a few years.
10:13:11 <rostayob> MostAwesomeDude: does it?
10:13:25 <MostAwesomeDude> Python's as old as Linux, IIRC Haskell was sometime in the mid-90s.
10:13:25 <rostayob> python is younger than haskell afaik
10:13:35 <rostayob> no, haskell is late 80s
10:13:36 <wavewave> python is towards imperative nirvana although I doubt it will reach.
10:13:41 <KorriX> have lambda calculs and lot of functional paradigm inside
10:13:46 <MostAwesomeDude> Huh, alright.
10:13:48 <monochrom> python is as old as linux?!
10:13:52 <rostayob> MostAwesomeDude: python is 1991, haskell is 1990
10:13:55 <MostAwesomeDude> Ah.
10:14:00 <ben> A narrow victory
10:14:01 <MostAwesomeDude> Python was inspired by
10:14:02 <mike-burns> I didn't realize Haskell so was young.
10:14:10 <yitz> MostAwesomeDude: actually some features of Python were explicitly borrowed from Haskell (and the also the other way around). but yes, they are very different in nature.
10:14:13 <monochrom> 1991? ok that's as old as linux
10:14:14 <KorriX> *lot from (sorry for my english - i am not 'native' speaker)
10:14:15 <MostAwesomeDude> Urg. Self and Smalltalk. Objects. Totally different paradigm.
10:14:20 <wavewave> even we can count Miranda.
10:14:22 <rostayob> although monadic haskell is somewhere around 1994, I think.
10:15:33 <yitz> rostayob: that's ok, python also changed quite a bit since 1991. especially in the early years.
10:15:54 <monochrom> http://python-history.blogspot.com/2009/01/brief-timeline-of-python.html  yikes
10:16:24 <mike-burns> 2011 - fixed the problem with their hashtable.
10:16:30 <rostayob> ehe
10:16:52 <rostayob> did they?
10:17:00 <rostayob> i think it's going to be 2012
10:17:01 <KorriX> Backing down to parsing - haskell allows to recursive using names of "variables" before declaration  - it is similar to practices in BNF notation
10:17:28 <hughfdjackson> whats the use in prelude's id?
10:17:29 <rostayob> KorriX: yes. what you're used to do with functions (calling inside the definition) you can do with any binding in haskell.
10:17:37 <mike-burns> hughfdjackson: The `id' function?
10:17:38 <wavewave> KorriX: definitely.. look up parsec.
10:17:39 <hughfdjackson> a -> a seems like an odd signature
10:17:47 <hughfdjackson> mike-burns: yup
10:17:51 <mike-burns> It's fantastic.
10:17:53 <monochrom> indeed, you can write "f :: MyType -> Int" on line 15, then finally "data MyType = ..." on line 14329.
10:17:57 <rostayob> hughfdjackson: sometimes you're using higher-order functions that do stuff and combining them and you  want to keep things the same
10:18:08 <wavewave> hughfdjackson : lots of use of id..
10:18:14 <hughfdjackson> hehe
10:18:18 <rostayob> in general when working with combinators
10:18:18 <hughfdjackson> 'things the same'?
10:18:23 <wavewave> it's like what's the use of 0 or 1.
10:18:29 <rwbarton> you'd use id when passing it to a higher-order function
10:18:30 <monochrom> and "instance Show MyType" on line 3000 while you're at it
10:18:41 <rwbarton> like foldr (.) id to compose a list of functions of type a -> a
10:18:47 <rostayob> hughfdjackson: yes, when using and composing higher-order functions it is often useful
10:18:56 <wavewave> id is really identity of function composition algebra.
10:18:58 <hughfdjackson> rwbarton: but semantic difference has it to simply the value itself?
10:19:42 <rwbarton> what value?
10:19:50 <rwbarton> if you have "id a" you can replace it by "a"
10:19:54 <wavewave> hughfdjackson : with id, you can have more unified interface.
10:19:57 <rwbarton> but if you pass "id" to some other function you can't do that
10:20:31 <wavewave> hughfdjackson : for example, see function maybe
10:20:39 <wavewave> :t maybe
10:20:40 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:21:09 <yitz> @type curry id
10:21:09 <lambdabot> forall a b. a -> b -> (a, b)
10:21:49 <yitz> @type flip id
10:21:49 <lambdabot> forall a b. a -> (a -> b) -> b
10:22:09 <wavewave> yitz: good ;-)
10:22:21 <chemistree> let add = 2+5
10:22:30 <hughfdjackson> :P this is what my relatives must feel like when they see me doing imperative programming
10:22:35 <chemistree> add
10:22:38 <yitz> @type maybe id
10:22:38 <lambdabot> forall a a1. (a1 -> a -> a) -> Maybe a1 -> a -> a
10:22:42 <rwbarton> 7
10:22:45 <KorriX> for what from practical side is Maybe ?
10:22:55 <etpace> Hmm.. anyone know of a tool that takes my code base and highlgiths any unused functions?
10:23:03 <srhb`> KorriX: Maybe a value, maybe not.
10:23:03 <etpace> think I might have some dead code laying about.
10:23:23 <rostayob> etpace: GHC?
10:23:24 <KorriX> little bit crazy
10:23:29 <MostAwesomeDude> :t Data.Map.lookup
10:23:30 <rostayob> ah
10:23:30 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
10:23:33 <KorriX> Value or Exception :)
10:23:33 <yitz> etpace: tr hlint
10:23:34 <rostayob> you mean whole program analysis
10:23:38 <yitz> try hlint
10:23:47 <rostayob> yitz: i doubt that hlint does that across modules
10:23:48 <monochrom> GHC with some option can find unused functions
10:23:54 <srhb`> KorriX: Could be, but needn't be. Depends on the context. :-)
10:23:59 <wavewave> learning functional programming is a bit like learning mathematics in nature.
10:24:08 <yitz> rostayob: right only within a module
10:24:09 <monochrom> GHC with optimizations will skip generating code for unused functions
10:24:30 <MostAwesomeDude> KorriX: The Either type is used to carry exception-like contexts. Maybe is for when the computation might fail in a safe, recoverable way.
10:24:31 <yitz> rostayob: but it does a lot of good stuff. etpace really should try it :)
10:24:39 <rostayob> yitz: that is true :)
10:24:46 <rostayob> i personally don't obsess over lint tools
10:24:49 <rostayob> but once in a while
10:24:56 <wavewave> once you know it, it's very simple.. but before it, it's hard to figure out what's going on.
10:25:09 <rostayob> or maybe it's just the high quality of GHC's warnings
10:25:27 <etpace> thanks, ill have a look at hlint
10:25:30 <mike-burns> wavewave: Sounds like everything.
10:25:50 <wavewave> mike-burns: well, yeah, you're right.
10:26:16 <wavewave> mike-burns : I want to emphasize that actually underlying principle is not that many.
10:26:26 <hughfdjackson> wait, is id just a function that returns what it was given for the sake of passing a function when yo don't want anything done?
10:26:32 <mike-burns> hughfdjackson: Yes.
10:26:38 <rostayob> hughfdjackson: precisely
10:26:42 <hughfdjackson> ^_^ ah, the fresh air of enlightenment
10:26:45 <hughfdjackson> cheers folks
10:26:52 <rwbarton> another example is
10:26:54 <wavewave> hughfdjackson: look! it's simple!
10:27:16 <rwbarton> > zipWith id [(* 10), (* 100), (* 1000)] [2, 3, 4]
10:27:18 <lambdabot>   [20,300,4000]
10:27:32 <mike-burns> hughfdjackson: http://goo.gl/xtfLc - here's an example where I used it.
10:27:43 <mike-burns> (Elsewhere in that link you'll see a foldr (.) id .)
10:28:41 <hughfdjackson> :D cheers for the help guys
10:29:21 <wavewave> hughfdjackson: now figure out what's the use of Identity monad ;-)
10:29:34 <rostayob> sadly we can't have a type level id :(
10:29:36 <hughfdjackson> wavewave: :P i only get some much brainpower a day
10:29:39 <wingie> what lang is haskell written in?
10:29:41 <rostayob> which I needed more than once
10:29:44 <rostayob> wingie: guess
10:29:48 <hughfdjackson> wingie: does it matter? xD
10:29:48 <wingie> haskell?
10:29:51 <rostayob> good
10:29:56 <mike-burns> There are many Haskell compilers.
10:30:02 <wingie> hughfdjackson: of course
10:30:06 <hughfdjackson> if you mean.. what language a compiler is written in
10:30:08 <rostayob> the main one, GHC, is Haskell and C
10:30:13 <mike-burns> With some Perl.
10:30:17 <KorriX> with is the best one and why it is GHC ;) ?
10:30:19 <wavewave> perl?
10:30:22 <wingie> hughfdjackson: i dont wanna install java :)
10:30:26 <rostayob> well perl is part of the build tools
10:30:31 <mike-burns> Yeah.
10:30:32 <rostayob> i guess it counts
10:30:34 <rostayob> maybe
10:30:42 <mike-burns> It's needed to build it!
10:30:44 <hughfdjackson> ah, well, if you're not compiling it i guess it does matter ^_^
10:30:48 <wavewave> okay.. then with make language
10:30:55 <rostayob> wavewave: once upon a time a perl script mangled the assembler generated by GHC
10:30:55 <mike-burns> Oh good call.
10:31:05 <rostayob> wavewave: but that's not true anymore
10:31:15 <wingie> cool that it's self compiled
10:31:24 <rostayob> wingie: not truly, the RTS is C
10:31:31 <wingie> RTS?
10:31:34 <rostayob> run time system
10:31:37 <wingie> ok
10:31:43 <KorriX> i am very lucky that is not Lisp :)
10:31:58 <rostayob> but the "compiling" part as in lexing parsing type checking code generation is all haskell
10:31:59 <wavewave> wingie: ghc compiler bootstrapping is fairly good.
10:32:27 <wingie> im really new in functional programming area .. what is GHC?
10:32:34 <rostayob> wingie: the main haskell compiler
10:32:42 <wingie> ok
10:32:43 <wavewave> de facto standard haskell compiler.
10:32:50 <KorriX> Glassgow Haskell Compiler
10:32:51 <rostayob> wingie: there are others but almost all Haskell code you'll encounter is GHC haskell
10:33:01 <wingie> cool
10:33:25 <yitz> the G also stands for Glorious
10:34:00 <wingie> another question since haskell is pure functional, will there be times you want to use oop to solve a problem? and how do you proceed?
10:34:48 <edwardk> wingie: usually you shift the focus around, "oop" techniques get used when building the classes that describe how you manipulate data, not the data you are passing around.
10:34:56 <edwardk> you _can_ use oop, using various encodings
10:34:56 <KorriX> How much slower is Haskell in comparision with C (average) ?
10:34:57 <rostayob> wingie: i never feel like using OOP. i feel like using C when i feel like doing low level systems programming
10:35:05 <yitz> wingie: most people would never want to touch oop again after learning function programming. but many have to anyway, at work.
10:35:12 <mike-burns> I use OOP sometimes.
10:35:12 <edwardk> directly on the data, but you tend not to once you get past a certain point
10:35:24 <wavewave> KorriX : in average, twice  ..
10:35:32 <nexion> work should use haskell
10:35:48 <KorriX> OOP is very natural for humans
10:35:55 <jessopher> some humans
10:35:58 <rostayob> KorriX: not really
10:36:03 <edwardk> i used to start with an oop based encoding of the problem, then figure out the existential i needed to properly encode the class, then i'd get done and see that as a bag of functions that i wanted the type to be in the first place
10:36:05 <rostayob> functions are more "natural" imho
10:36:06 <monochrom> if you don't need inheritance, the rest of OOP can be done with records.
10:36:07 <mike-burns> A common and good interview question is "What is an example for which you would not use OO?", or "When would you not use a functional solution?". People who have trouble answering those don't have a strong enough understanding of the downsides.
10:36:17 <edwardk> and i just make a data type that has that functionality and offers the traversals or whatever i need directly
10:36:20 <wavewave> KorriX: actually code performance is varying quite much depending on how you write a code.
10:36:25 <copumpkin> omnom
10:36:29 <wingie> is anyone here using Javascript? If so, are you only using it in a FP way?
10:36:30 <yitz> wingie: the main thing similar to oop that people feel a need for is better record syntax than what we have currently.
10:36:37 <rostayob> monochrom: I think then when people mention OOP they mean java/c++ style OOP. otherwisie, i agree with you :P
10:36:45 <rostayob> *otherwise
10:36:47 <edwardk> and you come out of the other side of 'crazy type' land with something simple and obviously correct
10:36:55 <mike-burns> wingie: I use jQuery, in a jQuery way.
10:37:01 <monochrom> if you don't need inheritance, the rest of java/c++ stype OOP can be done with records.
10:37:29 <edwardk> yitz: *shrug* i rather like the simplicity of the current system. some horribly complicated system that induces hlist-like overhead would ruin the language for me
10:37:29 <wavewave> I found that parameterized types are much more intuitive than OOP inheritance.
10:37:36 <mike-burns> monochrom: Records and typeclasses.
10:37:53 <yitz> edwardk: i wouldn't want that either
10:38:01 * hackagebot constraints 0.2 - Constraint manipulation  http://hackage.haskell.org/package/constraints-0.2 (EdwardKmett)
10:38:06 <KorriX> we are to define all what surrounds us. Each deffinition looks like: dog - is an animal who have long tail and can run very fast. And dog is class, "Your dog" is object, animal is base class, long tail is class field, ability of running is method - modify state of dog - his position
10:38:10 <rostayob> monochrom: yeah but inheritance is historically a huge part of java/c++ object model
10:38:14 <KorriX> is realy natural
10:38:16 <edwardk> well, the main problem with OOP is the lie it makes of liskov substitutability by letting you ask what class something has
10:38:26 <rostayob> here we go
10:38:27 <yitz> edwardk: the namespace issue is a serious one in many common practical programming situations though
10:38:32 <edwardk> once you get rid of that, you wind up with pretty much exactly what you can encode in a functional setting
10:38:40 * monochrom has a dilbert substitutability principle
10:38:44 * mike-burns steps away.
10:38:47 <wavewave> KorriX : how about cat?
10:38:51 <monochrom> let's see if lambdabot has it
10:38:56 <monochrom> @quote monochrom dilbert
10:38:56 <lambdabot> monochrom says: Dilbert's substitutability principle.  A subclass's programmer should work as a drop-in replacement of his/her predecessor.
10:38:57 <KorriX> exacly the same :D
10:39:09 <wavewave> KorriX: cat has a tail. but it cannot be a dog class.
10:39:21 <yitz> edwardk: and we ought to have something just a little more composable. but right, not at the expense of type system complexity.
10:39:29 <edwardk> yitz: sure. its kinda nice in other languages not having to make up a million names for the same field
10:39:30 <wavewave> KorriX: then will you append Tailful class below Animal later?
10:39:45 <rostayob> edwardk: i think that if you give up reflection in languages like java you're pretty much screwed in many occasions
10:39:50 <rostayob> you need to upcast, occasionally
10:39:52 <KorriX> we can design better class relations for animals
10:39:52 <edwardk> in practice when i want to have that sort of sugary name overloading i make a class for the field, then put a lens in the class
10:39:59 <KorriX> this was only the example
10:40:02 <rostayob> if the type system is not expressive enough
10:40:07 <wavewave> and then..... later if you find.. shrimp also has a tail.
10:40:10 <edwardk> rostayob: a large part of that is library design
10:40:14 <edwardk> and the language
10:40:15 <edwardk> yes
10:40:17 <yitz> edwardk: sometimes it's not just a question of nice. when you've got hundreds of fields, it's a real cost.
10:40:19 <wavewave> Ah.. shrimp is animal.. sorry.
10:40:28 <edwardk> yitz: i agree
10:40:41 <rostayob> edwardk: still, i don't think that type reflection is a mistake in java
10:40:44 <wavewave> just in case you put tailful under mammal.
10:40:52 <edwardk> its the right solution for the language that evolved
10:40:55 <rostayob> yeah
10:41:08 <rostayob> but considering the goals of a language like java
10:41:09 <edwardk> the .net ecosystem couldn't live without it either
10:41:14 <rostayob> it's probably the right thing to do
10:41:39 <edwardk> well, it permitted the community to run ahead and fix a lot of the horrible parts of the language in code
10:41:40 <wavewave> KorriX:  I understand your intent.. but in fact, this is a well known problem of parameterization of OOP classes.
10:41:41 <edwardk> which is nice
10:41:52 <jessopher> i dont mind class hierarchies as much as i mind mutable objects as a default. Objects are my problem with oop.
10:42:04 <edwardk> but it largely prevents any sort of principled attempt at revisiting the core issues that made the community go out and do so in the first place
10:42:04 <rostayob> edwardk: before generics upcasts were even more essential
10:42:09 <edwardk> sure
10:42:19 <edwardk> in a language without generics life is hell
10:42:22 <wavewave> KorriX : modern OOP design tends to reduce inheritance as much as possible.
10:42:28 <rostayob> edwardk: welcome to java < 1.5 :P
10:42:34 <wavewave> heavier use of templates.
10:42:43 <rostayob> wavewave: generics. i *hate* templates
10:42:56 <rostayob> templates make me cry
10:42:56 <edwardk> in a language without higher kinds and polymorphism, you absolutely CAN'T encode a lot of things without having lots of upcasting
10:43:05 <wavewave> rostayob: yup.. generics!
10:43:13 <wingie> jessopher: why are objects bad?
10:43:21 <edwardk> so even with java post 1.5 there still exist problems where you need to cast through objects
10:43:22 <yitz> wow, i still remember those stl error messages in c++. that was before they made really big screens, too.
10:43:32 <rostayob> relevant: http://weegen.home.xs4all.nl/eelis/analogliterals.xhtml
10:43:34 <jessopher> i dont think they are bad, i just do not like mutable objects as a default
10:43:38 <wavewave> I read several books on good C++ design....
10:43:47 <edwardk> and since scala has subtyping but not constrained higher kinds, you still have some places you need it even in scala
10:43:48 <benokit> in ghci : whats the difference between, for example, :m +Data.Ratio or :m Data.Ratio ?
10:43:54 <wavewave> one of the book is 'Modern C++ design'
10:43:54 <KorriX> when you want to solve some mathematical problems - functional paradigm is more expressivelly, when you have database, and work on data - OOP is simplier
10:43:56 <rostayob> gotta go, bye haskell
10:44:22 <wavewave> see you!
10:44:42 <srhb`> KorriX: Uh, that's very subjective.
10:44:45 <edwardk> (you can't make things like: type Foo[+T[+_] :< Foo[+_]] = …) rather you can say it, but it doesn't mean the right thing
10:44:46 <wingie> anyone here using javascript?
10:44:47 <hughfdjackson> :P the idea of myLast = head . reverse is .. nice
10:44:52 <hughfdjackson> wingie: moi
10:45:00 <wavewave> KorriX: hmm.. that will invoke many objection here ;-P
10:45:03 <wingie> hughfdjackson: are you doing only FP style?
10:45:08 <hughfdjackson> wingie: no
10:45:35 <wavewave> KorriX: anyway.. even for good OOP design, functional paradigm proved its usefulness.
10:46:00 <yitz> edwardk: what language is that ??
10:46:04 <wingie> hughfdjackson: why not? is it because of all the libs are in oop?
10:46:10 <hughfdjackson> i like oop
10:46:15 <hughfdjackson> it has it's uses for some things
10:46:18 <mike-burns> benokit: The + adds it to the environment instead of replacing the current env.
10:46:23 <KorriX> simple example: bank system - every client is object and objects are interacting ...
10:46:27 <hughfdjackson> i choose FP vs OOP on a case by case basis
10:46:30 <hughfdjackson> whatever makes most sense
10:46:36 <mike-burns> I just write code.
10:46:38 <KorriX> how it should be implemented in haskell ?
10:46:52 <mike-burns> KorriX: I think that's the example in the STM paper.
10:46:54 <mike-burns> IIRC.
10:47:00 <hughfdjackson> sometimes i write my OOP tools in a functional style :|
10:47:15 <wavewave> actually haskell implementation is known as best for that bank problem. hehe
10:47:18 <KorriX> STM ? what is this ?
10:47:19 <hughfdjackson> http://github.com/hughfdjackson/anew/ <-- case in point
10:47:27 <yitz> KorriX: you described an OO design of a banking system. for fp, you would design it differently.
10:47:35 <wingie> hughfdjackson: cool .. im using Sproutcore and they have a statechart (many here is using a statechart?)...i can't imagine coding without it .. but thats pure oop
10:47:44 <wavewave> read the paper Beautiful Concurrency by Simon Peyton-Jones.
10:47:49 <hughfdjackson> wingie: in short, i don't believe that one is the one true way - either way has its uses
10:47:57 <mike-burns> The Design Patterns book is mostly functional.
10:48:04 <mike-burns> It's the same thing.
10:48:06 <wingie> it seems that you shouldn't take one to the extreme but combine them/or use either one of them depending on scenario
10:48:17 <wingie> yepp
10:48:35 <srhb`> KorriX: One of the things you'll learn if you dive into this is that the scalable OOP bank system is littered with interesting locks if you want any kind of concurrency.
10:48:52 <srhb`> KorriX: Your example is awesome because it shows a huge shortcoming in normal OO paradigms.
10:49:18 <wingie> srhb`: how about you are using a Database on erlang .. wouldn't that solve the concurrency problem?
10:49:27 <srhb`> wingie: I assume so
10:49:27 <mike-burns> No.
10:49:49 <srhb`> But here you're assumign that the database cannot be concurrent in any way, I think
10:49:55 <srhb`> or database actions, more like
10:49:56 <wavewave> concurrency problem is very multi-layered.
10:49:58 <mike-burns> Swapping Postgres with CouchDB doesn't solve all your concurrency issues.
10:50:17 <wavewave> I don't think there is a single solution.
10:50:20 <wingie> damn this is serious shit
10:50:25 <mike-burns> Just write code.
10:50:28 <wingie> i need 10 years more to understand it all =)
10:50:32 <srhb`> :-)
10:50:50 <yitz> wingie: never mind just write stuff and have fun
10:50:54 <benokit> I dont get it, isnt it that I just add a module. How environment is defined?
10:51:06 <wavewave> one complication of concurrency/parallel problem is related to granuality.
10:51:06 <wingie> yitz: yeah im coding an web app and FP has helped me a lot
10:51:22 <wingie> learning for real world needs .. thats fun!
10:52:17 <Cale> benokit: :m ModuleName will unimport all other modules.
10:52:22 <mike-burns> benokit: http://hpaste.org/55842 - see how the :m replaced Data.Maybe with Control.Monad, but :m+ added to it.
10:52:22 <wavewave> some discussion about Software Transactional Memory, nested data parallelism and such guide current trend
10:53:19 <benokit> I see, thanks
10:53:40 <Cale> Besides, if you're really keeping track of bank accounts, your data should be fairly immutable anyway
10:53:53 <Cale> (you're extending data over time, rather than replacing it)
10:54:14 <wavewave> Cale: nowadays, nobody replace data ;-)
10:54:31 <wavewave> data is so precious, storage is so cheap.
10:55:02 <monochrom> and backup times grow exponentially
10:55:20 <mike-burns> But so do the number of computers doing the backups.
10:55:25 <wavewave> yeah... also data incompatibility issues.
10:55:53 <wingie> perhaps the data is outdated too and needs to be replaced
10:56:10 <mike-burns> Data are not replaced.
10:56:30 <mike-burns> This haskell-cafe purity thread has gone on way too long.
10:57:47 <srhb> We need a replacement to IRC that automatically splits off channels when conversation veers off track. That would be cool.
10:58:12 <monochrom> automatically?
10:58:12 <mike-burns> Like this one?
10:59:22 <srhb> Obviously, it's like the classical DND good evil lawful chaotix axes, once you veer off to one side you get the messages from others who do so too, but not otherwise.
10:59:28 <srhb> (It was a joke, sorry.)
10:59:48 <monochrom> people will have long threads arguing by what criteria the universally-imposing, centralized, automatic algorithm should decide to split.
11:00:00 <srhb> Sure, but only in that room. Hah! :P
11:00:01 <mike-burns> Huh, I first participated in an OOP/Haskell discussion in 2004, according to the haskell-cafe archives.
11:00:22 * EvanR-work rolls the dice
11:00:28 <EvanR-work> im chaotic stupid
11:00:43 <srhb> Problem with the idea is obviously that once 90% of users have split into "evil OOP room", how do you manage to talk about it enough to get into it yourself?
11:00:48 <monochrom> it is way more feasible to ask for client-side software that helps an individual user do his/her desired splitting
11:01:06 <ben> monochrom: messages in irc just need to carry an obligatory in-reply-to field!
11:01:14 <mike-burns> I'd rather an op who kicked people for talking about OT material.
11:01:17 * srhb envisions users chanting "java. java. java." over and over again.
11:01:21 <mike-burns> Like this.
11:01:38 <ben> mike-burns: but what criteria will the universally-imposing, centralized op decide by??
11:01:48 <mike-burns> They decide. They're the op.
11:02:04 --- mode: ChanServ set +o monochrom
11:02:19 <monochrom> /mode +bbbb monochrom monochrom monochrom monochrom
11:02:23 <KorriX> better will be haskell interpreter on channel
11:02:23 --- mode: monochrom set -o monochrom
11:02:32 <rwbarton> > "like this"
11:02:33 <mike-burns> > show "Likethis?"
11:02:33 <lambdabot>   "like this"
11:02:34 <lambdabot>   "\"Likethis?\""
11:03:52 <ben> >fix show
11:04:01 <ben> > fix show
11:04:02 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
11:04:04 <ben> cripes, picky interpreter
11:11:01 <wavewave> anyone tried frege?
11:12:50 <zhulikas> maybe someone can help me properly setup debian 6 x64 + lighttpd to support haskell through fastcgi?
11:13:16 <zhulikas> what I am missing is correct lighttpd configuration
11:13:20 <wavewave> what do you mean by support haskell in lighttpd?
11:13:38 <zhulikas> well, there is a tutorial
11:13:39 <zhulikas> http://blog.prb.io/wiring-haskell-into-a-fastcgi-web-server.html
11:13:47 <wavewave> probably, I can help you. I have done that before.
11:14:08 <zhulikas> I already have php defined in fastcgi.server
11:14:22 <zhulikas> and now add this bit of code shown on the website I gave you
11:14:39 <zhulikas> so no syntax errors for configuration
11:14:53 <singpolyma> For exception handling, one usually needs to specify the type of exceptions caught (such as SomeException), what is a good way to do that?  Say I'm using r <- try (...) then case r of Left ex -> ...  -- where should the type specifier go?
11:14:54 <zhulikas> but when I restart lighttpd, it doesn't work (cannot access anything through browser)
11:15:02 <wavewave> hmm I remember I did it with yesod..
11:15:20 <zhulikas> I was told that even if syntax is correct, lighttpd may fail to start without showing any error messages
11:16:14 <nexion> I was told that nesting TVars, like so: TVar (Map SiteId (TVar SiteEntry)), is a bad idea. Is it true?
11:16:20 <mike-burns> singpolyma: (Left SomeException) -> ...
11:17:31 <edwardk> yitz: scala
11:17:34 <edwardk> @hpaste
11:17:34 <lambdabot> Haskell pastebin: http://hpaste.org/
11:17:35 <singpolyma> mike-burns: but what if I want access to the execption variable?
11:18:13 <ban_rock> I can't seem to figure this one out. I've got: foo = handle (alwaysError) (blah), where alwaysError returns (return Nothing) for any exception; then at some point I do bar <- foo, check that isNothing(bar) == False, and then when I try to use fromJust(bar) I see that there was an error evaluating blah
11:18:22 <hpaste> edwardk pasted “a fun monad transformer” at http://hpaste.org/55843
11:18:36 <ban_rock> I don't understand how Haskell can decide that isNothing(bar) == False without evaluating blah
11:18:38 <edwardk> something cute for those of you playing around with ghc 7.4
11:19:06 <zhulikas> wavewave, yesod seems nice. I might try that. And maybe look into alternatives too
11:19:44 <iago> hi,is there any "hGetWhile" function :: Handle -> (Char -> Bool) -> IO String ? I did not found it through hoogle, nor I see any Control.Monad combinator that would do that easily in combination with hGetChar... any clue?
11:19:48 <hpaste> wavewave pasted “lighttpd” at http://hpaste.org/55844
11:19:53 <rwbarton> ban_rock: handle tells you whether there was an exception while *executing* blah
11:20:01 <rwbarton> which is an IO action
11:20:02 <edwardk> i started with a monad transformer newtype HomT m a = HomT { runHomT :: forall n. Monad n => (forall b. m b -> n b) -> n a }
11:20:07 <wavewave> zhulikas : this was what I found from my old config file.
11:20:13 <edwardk> but then I needed another one for dealing with MonadPlus homomorphisms
11:20:14 <mike-burns> singpolyma: (Left (SomeException e)) -> ...   - like that?
11:20:15 <edwardk> etc
11:20:22 <rwbarton> however the result of that IO action might be a value which raises an exception with error
11:20:30 <edwardk> so i realized with constraint kinds i could factor out the constraint
11:20:34 <rwbarton> when it is *evaluated* later
11:20:38 <edwardk> that said, its a fairly ugly factoring
11:20:56 <edwardk> and i still had to have the Monadic and MonadicPlus classes =/
11:21:04 <singpolyma> mike-burns: oh, I see. cool.  thanks
11:21:25 <wavewave> zhulikas : hmm difference is maybe 'check-local', and 'idle-timeout'
11:21:29 <zhulikas> thanks, I'll try that, wavewave
11:21:39 <zhulikas> and yesod looks reaaaly promising
11:21:56 <wavewave> yes. it's quite fast.
11:22:06 <ban_rock> rwbarton: ok, so do I want something else instead of handle? blah is basically an attempt to parse something from IO
11:22:28 <zhulikas> did you try to compare it with frameworks on other programming languages?
11:22:36 <wavewave> yesod support fastcgi as a backend by the way.
11:22:39 <zhulikas> let's say compare yesod with django or zend framework
11:22:48 <mike-burns> Yesod is less mature than those.
11:23:00 <wavewave> zhulikas : no. I am not an expert of web devel.
11:23:02 <mike-burns> Which criteria are you comparing on?
11:23:09 <zhulikas> mike-burns, speed
11:23:21 <zhulikas> I know yesod is faster
11:23:25 <zhulikas> but I wonder how much
11:23:27 <mike-burns> zhulikas: What speed? "Hello, world"? DB access?
11:23:27 <wavewave> I guess that yesod is faster.
11:23:28 <zhulikas> or how many times :)
11:23:34 <zhulikas> average
11:23:45 <zhulikas> ok, maybe my question is stupid
11:23:50 <mike-burns> Eh, get back to me when you hav ean actual thing to benchmark.
11:23:59 <zhulikas> hehe, ok :D
11:24:12 <mike-burns> You might care to know that most speed issues in Web apps is DB-related.
11:24:20 <rwbarton> ban_rock: what you want is to evaluate the value you're going to use inside that IO action blah
11:24:31 <wavewave> I think that basically haskell should be much faster than other web framework in other language.
11:24:44 <rwbarton> (or possibly, use some kind of parser that doesn't use an exception to indicate failure...)
11:25:01 <MostAwesomeDude> Hm. How would I go about creating a bogomips-like benchmark for an app? I want to be able to estimate how long a computation will take, based on the number of elements in the computation, without actually running it. This is a web service and I want to be able to reject requests that will take more than, say, 5 minutes.
11:25:02 <mike-burns> Once you have a speed issue that isn't DB-related, you know what causes it and what component to replace.
11:25:10 <hiptobecubic> Why does compiling haskell code seem to take so much more memory than other languages? I'm in the middle of building wxcore and ghc is using almost 1Gb of ram
11:25:14 <wavewave> basic web server (warp in this case) is fast and text builders and parsers are fast.
11:25:38 <wavewave> DB connection part.. I don't know but I don't have any reason why haskell is slower.
11:26:03 <mike-burns> Well, once you have a non-DB speed issue, your team of 12+ employees will help you solve it for your very successful Web site.
11:26:17 <maltem> hiptobecubic, ghc really isn't optimised for low memory consumption. That's about the reason
11:26:20 <hiptobecubic> Now it's' well over 1gb and climbing
11:26:53 <wavewave> hiptobecubic: yeah.. that's typical .
11:27:32 <wavewave> With my old test notebook, I always worry about whether it will successfully compile without hitting swapping.
11:27:39 <hiptobecubic> Well it broke 2gb and now i'm swapping... less than half way done.
11:28:07 <maltem> could be that wx contains generated code that hits some worst case
11:28:10 <wavewave> especially for GUI FFI binding
11:28:14 <monochrom> because GHC is written in Haskell again :)
11:28:17 <wavewave> it's generated code problme.
11:28:41 <wavewave> gtk2hs also has similar problem.
11:28:58 <hiptobecubic> I realize it may not be "optimized for low memory consumption" but christ. How did anyone use this even a few years ago? 2Gb in a laptop was normal a year or two ago
11:29:10 <monochrom> also there is linking. GHC-generated object files take the conventional linker a lot of time and memory. try the "gold" linker instead.
11:29:17 <MostAwesomeDude> ^^
11:29:23 <wavewave> It's more like a problem of gtk2hs. because it compiles every FFI binding into just one stub code.
11:29:24 <MostAwesomeDude> I can vouch for this.
11:29:42 <wavewave> gold?
11:30:00 <monochrom> hmm, maybe gtk2hs could use split-objs
11:30:00 <hiptobecubic> There it goes... memory usage dropped from 2GB to 100Mb. Now my mouse moves again :)
11:30:19 <wavewave> oh.. i haven't heard of this! this sounds good
11:30:27 <monochrom> anyway, with overwhelming probability, you're seeing the linker, not GHC itself
11:30:55 <wavewave> how can i replace a linker for ghc?
11:31:08 <maltem> my guess is you can't (without much work)
11:31:14 <hiptobecubic> monochrom, doesn't the linking happen at the end? This was at [ 8 of 22]
11:31:25 <monochrom> by putting the linker on the path and calling it ld
11:31:37 <wavewave> ah.. is it safe?
11:31:38 <monochrom> ok, [8 of 22] is GHC itself
11:32:00 <monochrom> it seems safe for GHC-generated code for me
11:32:02 <wavewave> i mean gold is a real replacement of ld at all?
11:32:18 <monochrom> gold may be missing a feature but I don't know
11:32:26 <parcs`>  it is intended to be a drop-in replacement
11:32:36 <monochrom> wikipedia may know more than I do
11:33:03 <parcs`> however that is not the case (yet)
11:33:09 <wavewave> hmm. one thing I learned today. ;-)
11:33:14 <parcs`> but for ghc linking it should work fine
11:33:38 <wavewave> slow compiletime is always annoying.
11:33:50 <wavewave> I want parallel building!!
11:34:09 <monochrom> http://xkcd.com/303/
11:34:24 <jdlasd> haskell is too popular. discuss.
11:34:49 <saati> wavewave: create a Makefile, make -jX
11:35:04 <wavewave> saati : not available for a cabal package.
11:35:26 <monochrom> haskell is so popular, light bents when travelling near it
11:35:28 <saati> that's sad :/
11:36:17 <wavewave> parallel compilation for a cabal was this year's GSoC project which I most expected.
11:36:37 <saati> and what happened?
11:37:20 <wavewave> seems not very successful from somebody's blog post.. I am looking for the post.
11:39:45 <wavewave> cannot find it.
11:40:19 <wavewave> it looks like ghc has all relevant information in its command line option when it is used in cabal
11:41:31 <wavewave> so.. if we execute that one by one for each haskell file, then parallelizing may not be that difficult.
11:42:07 <wavewave> monolithic linking is unavoidable, but parallel compiling looks possible.
11:43:02 * hackagebot sock2stream 0.2 - Tunnel a socket over a single datastream (stdin/stdout)  http://hackage.haskell.org/package/sock2stream-0.2 (StephenWeber)
11:43:38 <wavewave> oh.. I was wrong.. the GSoC seems successful.
11:43:56 <wavewave> http://dissocial.st/blog/2011-08-22-GSoC-Final
11:44:52 <wavewave> ah. okay it works at the level of package.
11:57:37 <refox> The GHC API changed with version 7 of GHC. I have some code that should run with GHC version 6.10.4 as well as 7.0.4. I have code that works for each version individually. The question is how to dynamically use the version depending on the GHC version installed on the system?
11:58:02 * hackagebot TypeCompose 0.9.1 - Type composition classes & instances  http://hackage.haskell.org/package/TypeCompose-0.9.1 (ConalElliott)
12:12:25 <hughfdjackson> ^_^ i love how much humour went into learn you a haskel
12:12:26 <hughfdjackson> l
12:15:09 <erkin> Same.
12:15:32 <Leif_Bork> Will a foldr be faster than sum $ map ...?
12:17:37 <zachk> could be, but it might also be less readable, and it depends on the optimizations of the compiler
12:19:15 <Saizan> you're likely to want foldl' for sum
12:20:23 <Saizan> sum $ map f xs == foldl' (\a x -> a + f x) 0 xs
12:21:57 <Leif_Bork> Thanks!
12:23:04 <Leif_Bork> In which module is foldl'?
12:23:12 <opqdonut> Data.List
12:24:10 <Leif_Bork> Thanks!
12:24:14 <wavewave> try to use Hayoo
12:24:26 <wavewave> for finding functions in general.
12:24:30 <mike-burns> @hoogle foldl'
12:24:31 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
12:24:32 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
12:24:32 <lambdabot> Data.ByteString.Char8 foldl' :: (a -> Char -> a) -> a -> ByteString -> a
12:24:57 <wavewave> hoogle, too of course.
12:25:10 <mike-burns> sum . map f  sure reads more succinctly.
12:30:49 <Leif_Bork> wavewave: thx
12:30:56 <Raydiation> ive just started reading a haskell book and im wondering if you use this language primarily for computation
12:31:07 <mike-burns> Raydiation: As opposed to?
12:31:34 <Raydiation> mike-burns: for instance python for web applications
12:31:49 <dmwit> A web application is a computation.
12:31:50 <Raydiation> maybe im just too stuck in oop
12:31:51 * mike-burns isn't sure where to begin.
12:31:53 <luite> there a a few good web frameworks for haskell
12:31:56 <dmwit> It's all just numbers to the CPU.
12:32:06 <mike-burns> I'm sure they can compute things in Python.
12:32:10 <zachk> raydiation: which book?
12:32:28 <Raydiation> zachk: for the great good
12:32:31 <mike-burns> "Haskell for Computation, and THAT'S IT". Buy it now on Amazon!
12:32:59 <mike-burns> Raydiation: http://hackage.haskell.org/packages/archive/pkg-list.html - this is what we use Haskell for.
12:33:14 <dmwit> main = myHugeTopLevelComputation `seq` return ()
12:33:24 * mike-burns dies
12:35:55 <zachk> raydiation: you could try "Real World Haskell" for real world applications
12:36:22 <monochrom> http://www.amazon.com/haskell-for-computation-and-thats-it/dp/1593272839/  buy it now on amazon!
12:36:25 <Raydiation> zachk: ty
12:36:33 <mike-burns> Oh I hope this link works.
12:36:45 <mike-burns> A+
12:36:49 <monochrom> haha
12:36:54 <monochrom> \∩/
12:38:23 <Raydiation> are there structs in haskell? how do you store information that belongs together? in tuples?
12:38:28 <mike-burns> Records
12:39:35 <rageous> I'm new -- is there a special trick to get pattern matching to work within a where statement?
12:39:45 <mike-burns> No trick. What's the issue you're seeing?
12:39:53 <rageous> Let me paste it someplace.
12:39:53 <mike-burns> Is your indentation off?
12:39:58 <Leif_Bork> Raydiation: This page is pretty nice: http://learnyouahaskell.com/making-our-own-types-and-typeclasses
12:40:01 <zachk> http://hpaste.org
12:40:02 <rageous> Does white space matter in Haskell?
12:40:05 <azaq23> > let x = f where (f:fs) = [1, 2] in x
12:40:05 <lambdabot>   1
12:40:10 <mike-burns> rageous: Yes.
12:40:13 <Raydiation> Leif_Bork: ty :)
12:40:36 <krakrjak> rageous: it does, but it's pretty forgiving.
12:40:37 <zachk> rageous: layout does
12:40:52 <rageous> I'm following along with examples from Learn you a Haskell, but let me copy this into Codepad or something.
12:41:43 <krakrjak> rageous: at hpaste.org you can paste your code and it can announce the pasting on this channel.
12:41:56 <rageous> Oh, neat.
12:42:23 <hpaste> rageous pasted “Where Statement” at http://hpaste.org/55845
12:42:43 <rageous> And you pros will see the error immediately, I trust.
12:42:50 <mike-burns> Line    (skinny,   up with the b in   bmi
12:43:33 <rageous> Is there a tab normally after where
12:43:34 <rageous> ?
12:43:41 <mike-burns> We don't use the tab character.
12:45:29 <rageous> mike-burns: Now it gives me a 'parse error on input' for the '(' char at the beginning of (skinny, normal, fat)
12:46:01 <mike-burns> I got it working, but I replaced all tab characters with two spaces.
12:46:18 <dmwit> Tab character is fine, but you must line up all the beginnings of lines within a block.
12:46:26 <hpaste> mike-burns annotated “Where Statement” with “Where Statement (annotation)” at http://hpaste.org/55845#a55846
12:46:32 <dmwit> So, the ( of (skinny, normal, fat) and the b of bmi must line up.
12:46:44 <dmwit> You should treat tab character widths as incomparable to spaces and letters.
12:47:15 <dmwit> So, instead of two tab characters at the beginning of the (skinny, normal, fat) line, it should be a tab character followed by five spaces.
12:47:26 <rageous> I'm coming from some Python background. I can change this behavior.
12:47:50 <dmwit> Coming from Python, your best bet is probably just to start your blocks on a different line from the "where".
12:47:53 <dmwit> Then there's no messing around.
12:47:57 <Leif_Bork> Raydiation: Scala might be easier to start with for web stuff, but I have never used Haskell for it. Here's a web framework for scala: http://liftweb.net/ and a project that brings GWT to scala: http://scalagwt.github.com/
12:48:00 <dmwit> Just use a deeper indentation and be consistent about it.
12:48:07 <ban_rock> What's the easiest way to parse a string into, say, a Complex Double? Giving a function of type String -> Maybe(Complex Double)
12:48:29 <ban_rock> surely there's a sensible way to use read, as opposed to writing something from scratch; I'm really not looking for anything fancy
12:48:29 <hpaste> dmwit annotated “Where Statement” with “Where Statement (annotation)” at http://hpaste.org/55845#a55847
12:48:38 <rageous> Thanks very much.
12:48:53 <dmwit> ban_rock: reads
12:49:03 <dmwit> > 1 :+ 3
12:49:04 <lambdabot>   1.0 :+ 3.0
12:49:11 <dmwit> > reads "1.0 :+ 3.0"
12:49:12 <lambdabot>   []
12:49:19 <dmwit> > reads "1.0 :+ 3.0" :: [(Complex Double, String)]
12:49:20 <lambdabot>   [(1.0 :+ 3.0,"")]
12:49:26 <dmwit> > reads "nonsense" :: [(Complex Double, String)]
12:49:27 <lambdabot>   []
12:49:35 <dmwit> > reads "1.0 :+ 3.0nonsense" :: [(Complex Double, String)]
12:49:36 <lambdabot>   [(1.0 :+ 3.0,"nonsense")]
12:50:25 <rageous> tsk, tsk. Why didn't they teach us Haskell instead of Scheme for our introduction to computer science?
12:50:36 <ban_rock> ok that looks great and will save me a fair amount of effort, thanks!
12:50:49 <Leif_Bork> Raydiation: Oh, this was quite fine: http://www.haskell.org/haskellwiki/Web/Frameworks
12:51:26 <hpaste> “trythis ” annotated “Where Statement” with “Where Statement (annotation)” at http://hpaste.org/55845#a55848
12:52:11 <Raydiation> Leif_Bork: i was wondering if asking about frameworks is considered flamebait so i was holding back :)
12:53:12 <mike-burns> Yesod is rather popular, for some value of popular.
12:54:10 <luite> hmm, Hoogle has already moved to Warp
12:55:07 <luite> Yesod is undergoing some major changes right now, moving away from enumerator to a different (own) iteratee lib
12:55:15 <zhulikas> which debian package contains runProcess.h which is required by haskell process package?
12:55:19 <ion> luite: Interesting. Why?
12:55:31 <luite> this will lead to the 0.10 release, hopefully the last release before 1.0
12:55:36 <mike-burns> ion: http://www.yesodweb.com/blog/2011/12/conduits
12:55:49 <luite> ion: enumerator has some problems with resource acquisition and exception handling
12:56:06 <ion> mike-burns: Thanks
12:56:27 <ion> luite: Nice to hear there’s an implementation that takes those things into concern.
12:57:08 <luite> ion: yeah it was bugging me in Yesod, I was considering doing it myself, but I'm glad Michael already picked this up, and that the decision was made to include it as soon as possible
12:57:33 <luite> therefore an extra 0.10 release to test conduit and to see what other api changes should be necessary
13:04:28 <luite> and I hope that after 1.0 the higher level packages will get some more attention, the authentication subsite is rather inflexible at the moment, forms could see some improvements to make it easier to compose forms of subforms and to make more advanced input fields
13:09:28 <luite> but I already like things as they are at the moment, ghc 7.4 will make it even better (template haskell dependency tracking!)
13:12:19 <zhulikas> can anyone help me to install process package on debian 6 x64? I do have runProcess.h in include directory but it keeps complaining
13:13:13 <xplat> does hxt-tagsoup correctly parse html5?
13:13:34 <mike-burns> zhulikas: http://hackage.haskell.org/trac/ghc/ticket/5449 - not sure if anyone has it working.
13:13:55 <monochrom> runProcess.h comes with GHC
13:14:06 <zhulikas> it's also mentioned here
13:14:06 <zhulikas> http://markmail.org/message/u7anrdgi7cet2qg4?q=python
13:14:12 <zhulikas> I'll try to build from git repo
13:14:12 <xplat> i know tagsoup by itself is claimed to, but i don't know for the combination with hxt, which 'uses tagsoup as a lexer'
13:16:51 <zhulikas> it doesn't build either
13:17:07 <monochrom> in fact process comes with GHC. why build it yourself? must you use version 1.1.0.0?
13:17:08 <zhulikas> wavewave, how did you manage to install yesod?
13:17:43 <zhulikas> yup, it's in the GHC
13:17:50 <zhulikas> but why the hell it keeps asking for process
13:18:12 <zhulikas> it's also registered in ghc-pkg
13:18:17 <monochrom> that depends on what you're doing, and I don't know, and it must be a long story
13:18:31 <zhulikas> cabal install yesod
13:18:34 <zhulikas> that's what I do
13:19:03 <mike-burns> Does a ghc-pkg check explain anything interesting?
13:19:26 <hpaste> zhulikas pasted “error message” at http://hpaste.org/55849
13:20:37 <mike-burns> cabal install yesod filepath mime-mail   -- how about this?
13:21:14 <luite> you're not trying to install with ghc 7.4 rc1 right?
13:21:30 <monochrom> "cabal install --dry-run yesod" over here on a clean GHC 7.0.4 does not say process will be built. you have an unclean suite of packages
13:22:09 <monochrom> "ghc -v" may show a lot of uncleanness
13:22:38 <monochrom> uncleanness means "package ___ is unusable ..."
13:23:04 <zhulikas> ok, I got disconnected
13:23:11 <zhulikas> <hpaste> zhulikas pasted “error message” at http://hpaste.org/55849
13:23:11 <zhulikas> * VYOKQXNB (~LOCALSERV@ool-4b7fc343.static.optonline.net) has joined #haskell
13:23:11 <zhulikas> * VYOKQXNB has quit (Excess Flood)
13:23:11 <zhulikas> <zhulikas> :)
13:23:15 <zhulikas> this is the last thing I've seen
13:23:25 <hpaste> zhulikas pasted “ghc-pkg list” at http://hpaste.org/55851
13:23:28 <monochrom> <mike-burns> cabal install yesod filepath mime-mail   -- how about this?
13:23:33 <monochrom> <luite> you're not trying to install with ghc 7.4 rc1 right?
13:23:37 <monochrom> <monochrom> "cabal install --dry-run yesod" over here on a clean GHC 7.0.4 does not say process will be built. you have an unclean suite of packages
13:23:42 <monochrom> <monochrom> "ghc -v" may show a lot of uncleanness
13:23:46 <monochrom> <monochrom> uncleanness means "package ___ is unusable ..."
13:24:12 <zhulikas> ok, I have some unused packages
13:24:23 <zhulikas> and multiple versions of same package
13:24:27 <zhulikas> for example filepath
13:24:34 <monochrom> yes that's very unclean.
13:24:47 <zhulikas> should I look into ways to clean it first?
13:25:11 <monochrom> if you prefer to start over, "cd ~/.ghc", "ls", there is something you like to erase there
13:25:22 <zhulikas> oh, yeah
13:25:34 <luite> and run cabal update first, before installing new things
13:26:02 <luite> I personally use cabal-dev for all my yesod stuff
13:26:16 <luite> but that results in rather long build times
13:26:36 <monochrom> there is also a surgical-strike approach with a lot of manual work
13:26:58 <monochrom> for future reference, read my http://www.vex.net/~trebla/haskell/sicp.xhtml
13:27:03 <hiptobecubic> I'm looking at ch05 for RWH and I feel like there's just no way I would have invented such a system for handling json. How long after discovering Haskell did it take you before you were producing non-trivial things?
13:28:04 * hackagebot data-lens-template 2.1.3 - Utilities for Data.Lens  http://hackage.haskell.org/package/data-lens-template-2.1.3 (EdwardKmett)
13:28:25 <monochrom> the beginning "data JValue = a lot of cases" is immediate since day one
13:28:34 <monochrom> or at least was immediate for me
13:28:51 <mike-burns> That's not how I work with JSON, to be fair.
13:29:03 <monochrom> yes, even though I had prior OOP exposure and would use subclasses in C++
13:30:54 <mike-burns> hiptobecubic: It also _is_ a problem that this is a very non-obvious way of working with JSON, for someone who works with JSON a lot.
13:31:08 <mike-burns> It's more complex than you (or I!) are used to.
13:31:14 <mike-burns> Them's the breaks.
13:32:13 <monochrom> the improved pretty-printing using the Doc thing had never occured to me. I had to read a paper or have seen Text.PrettyPrinting for it. that's the value of education. don't hope to invent everything yourself. would take you 2 million years.
13:33:44 <mike-burns> I still don't have a handle on which layers of abstraction are right.
13:33:49 <mike-burns> That's too vague.
13:34:17 <mike-burns> For example, I know that making everything a typeclass is not useful.
13:34:29 <mike-burns> But this Doc thing also wouldn't have occured to me.
13:36:13 <monochrom> Doc does not add any benefit (compared to String, (++), etc) if all you do is at the end serialize Doc back to String in only one way, ever
13:37:09 <mike-burns> But using Doc even if you only serialize to String means that in the future you can serialize to something else without changing API.
13:37:21 <monochrom> the fun begins when you want several different formats and options for serializing Doc to String. for example customizable indentation. for example customizable line width and line breaks
13:37:30 <mike-burns> And I don't know when it's ... right, I guess ... to add such an abstraction in preparation for the future.
13:37:48 <micahjohnston> does anyone have advice on how I can move more code out of the IO monad?
13:37:50 <micahjohnston> https://github.com/micahjohnston/Paws.hs/blob/stack/Runner.hs
13:38:01 <micahjohnston> as you can see, that code is quite ugly, owing to the fact that so much of it is in IO
13:38:14 <micahjohnston> I'm implementing an imperative language
13:38:21 <micahjohnston> I don't expect anyone to read through the code and give in-depth suggestions
13:38:41 <micahjohnston> but does anyone have any suggestions for how to implement an interpreter of an imperative language in Haskell without much code in IO?
13:39:13 <edwardk> bah
13:39:15 <monochrom> I don't, in fact, advocate premature generalization extensibility all that crap. the truth is that you don't see the future. every single "extensibility" you add grants you extensibility in one direction and costs you inextensibility in another direction. you don't see the future, you don't know which direction you will go.
13:39:51 <MostAwesomeDude> micahjohnston: Considered using State or ST for your state instead of MVars?
13:39:57 <edwardk> don't you hate it when you write something fairly nice, then you write the fully general version of it and its insanely complicated and would be impossible for folks to understand?
13:40:20 <micahjohnston> MostAwesomeDude: I'm not sure how I would use those when every operation in this language potentially has a side effect
13:40:29 <micahjohnston> and I think that those would have the same effect on my code as writing it in IO
13:40:38 <mike-burns> monochrom: I completely agree and when I work in a ducktyped language that is exactly how I work, and that's fine because it (probably) won't break API. In Haskell, though, you'd need to do something less straightforward to avoid breaking the API for the same change.
13:40:40 <MostAwesomeDude> micahjohnston: What kind of side effectsÂ?
13:40:53 <mike-burns> edwardk: That sounds like an edwardk problem.
13:40:59 <micahjohnston> MostAwesomeDude: things like printing things out, reading things in, drawing pictures, launching missiles
13:41:07 <edwardk> mike-burns: hah
13:41:09 <micahjohnston> MostAwesomeDude: unrestricted side effects like most imperative languages can do
13:41:29 <edwardk> it started innocently enough
13:41:49 <MostAwesomeDude> micahjohnston: Well, aren't most side effects in this language just mutating the global state of the interpreter, not things beyond the interpreter?
13:42:01 <micahjohnston> most are
13:42:05 <micahjohnston> but it's a rather dynamic language
13:42:19 <micahjohnston> no way to statically guarantee which things will and won't affect the outside world
13:42:38 <edwardk> generalized the monad newtype S a = S ((a -> Bool) -> a) to add an arbitrary monadic effect
13:42:45 <ban_rock> yet another stupid question: say I have two objects foo, bar of type MyType, how do I go about defining a function f :: MyType -> String such that f(foo) = "a" and f(bar) = "b"?
13:42:56 <edwardk> newtype S a = S (forall m. Monad m => (a -> m Bool) -> m a)
13:43:29 <monochrom> the expression problem states that adding data cases is at odds with adding operations. the edwardk problem states that he has solved the expression problem but it's overly complicated and no one else understands :)
13:43:39 <mike-burns> ban_rock: pattern mattching.
13:43:49 <edwardk> that way the code that builds the S can only use the >>= and return, and basically can't get any benefit from the monad other than stitching together calls
13:44:04 <edwardk> but that pattern itself can be generalized
13:44:09 <edwardk> into a monad transformer
13:44:20 <ban_rock> mike-burns: yeah, but if I write f foo = "a" it takes it to mean f applied to anything is "a"
13:44:32 <monochrom> (the expression problem is why I call "OOP is extensible / more extensible" bullshit)
13:44:34 <mike-burns> ban_rock: Do you mean   f Foo = "a"   ?
13:44:44 <mike-burns> (Capitalization.)
13:44:53 <rwbarton> "two objects foo, bar of type MyType" isn't very meaningful
13:44:56 <rwbarton> what if they're equal?
13:44:59 <edwardk> newtype TransT m a = TransT { runTransT :: forall n. Monad n => (forall b. m b -> n b) -> n a }
13:45:25 <edwardk> but that has a constraint in it, and i need a different newtype if i want to make one that can allow me to thread arbitrary MonadPlus code through it
13:45:26 <mike-burns> Well now you simply have too many lowercase letters, edwardk .
13:45:43 <edwardk> So we can fix that by adding another lower case letter
13:45:46 <ban_rock> rwbarton: yes, I understand that's why there's a problem, however they are not equal
13:45:48 <mike-burns> Hah.
13:45:56 <mm_freak> :t (.) (.) . (.)
13:45:57 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
13:46:10 <rwbarton> f x = if x == foo then "a" else if x == bar then "b" else ???
13:46:23 <rwbarton> or f x | x == foo = "a" | x == bar = "b" | otherwise = ???
13:46:29 <edwardk> newtype HomT p m a = HomT { runHomT :: forall n. p n => (forall b. m b -> n b) -> n a) } -- using the new constraint kind in ghc 7.4
13:46:33 <mm_freak> :t (.) (.) . ((.) :: (b -> c) -> (a -> b) -> a -> c)
13:46:34 <lambdabot> forall a b (f :: * -> *) b1. (Functor f) => (b1 -> b) -> (a -> b1) -> f a -> f b
13:46:40 <rwbarton> assuming you can compare MyType for equality
13:47:06 <mm_freak> :t let (f . g) x = f (g x) in (.) (.) . (.)
13:47:07 <lambdabot> forall t t1 t2 t3. (t3 -> t1) -> (t -> t3) -> (t2 -> t) -> t2 -> t1
13:47:16 <mike-burns> Ah I think I saw this in your constraints package from earlier, edwardk . But ... I didn't understand it.
13:47:23 <edwardk> with that we can use HomT Monad m a -- for code that uses only the Monad structure on n and the lifting of actions in m through a monad homomorphism
13:47:46 <edwardk> and HomT MonadPlus m a for code that uses the monad plus combinators
13:48:11 <ban_rock> rwbarton: well, at the moment I can't compare for equality, but I guess if I have to define equality for things in MyClass to make this work I'll have to do that
13:48:19 <ban_rock> MyType, sorry
13:48:21 <edwardk> where we're relying on (forall b. m b -> n b) to be a monad homomorphism in one case and a 'monadplus' homomorphism in the other.
13:48:25 <mike-burns> edwardk: Do you have an example that uses these abstractions to produce something that is, in the end, simple and useful?
13:48:30 <edwardk> yes
13:48:30 <hiptobecubic> :t flip
13:48:32 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:48:44 <edwardk> well, before i added all the HomT stuff =)
13:48:45 <rwbarton> ban_rock: It feels like you're asking the wrong question, or maybe I just don't understand.
13:48:49 <zhulikas> ok, my haskell-platform was waaay too old
13:48:57 <mike-burns> ban_rock: hpaste some code.
13:48:58 <zhulikas> I got newer one and it works now.
13:49:03 <rwbarton> in general there could be a lot of ways to do this
13:49:31 <edwardk> mike-burns: the reason for playing with this is that there is a monad for searching potentially infinite spaces (with predicates that do bounded work) in finite time
13:50:05 <mike-burns> edwardk: Well that does sound useful!
13:50:09 <edwardk> mike-burns: the stock version of this monad blows up pretty quickly, but by threading through that parameterized monad you can peek in at what is being done in such a way that that blow up doesn't happen
13:50:45 <hiptobecubic> :t flip (.) (.) . flip ((.) . (flip (.))) . uncurry
13:50:46 <lambdabot> forall a b (f :: * -> *) b1 a1 b2. (Functor f) => (a1 -> b2 -> f b -> b1) -> (a -> b) -> (a1, b2) -> f a -> b1
13:51:11 <zhulikas> looks like ascii boobs
13:51:15 <edwardk> so for example you can in the lazy naturals for "epsilon (> Succ Zero)"  and it will find Succ (Succ Zero)
13:51:23 <hiptobecubic> zhulikas, my favorite kind
13:51:53 <edwardk> or given type Cantor = Int -> Bool, you can ask for one such that f 10 /= f 11 and it'll give you a function for which that property holds
13:52:01 <rwbarton> I want to implement branch-and-bound search with that technique some time
13:52:08 <mike-burns> Wild.
13:52:14 <edwardk> or one for which it fails, but it only ever fails if there is no such function
13:52:28 <hpaste> ban-rock pasted “general silliness” at http://hpaste.org/55853
13:52:49 <ban_rock> so that's what I would've liked to write but it doesn't work
13:52:51 <mike-burns> ban_rock: You want to use | instead of a pattern match.
13:53:01 <mike-burns> showGradient h | warm h = ...
13:53:24 <edwardk> so p (epsilon p) gives you a true or false -- but it only works if p can inspect any value in the set in a bounded amount of time, and if the set has some kind of search procedure. there is one for cantor's set, and for the lazy naturals (or any regular polynomial algebraic data type for that matter)
13:53:24 <rwbarton> what?
13:53:39 <zhulikas> warm has only one argument in type definition, but you write two
13:53:55 <edwardk> rwbarton: i was building a "finite domain" constraint solver that could use these as sort of 'cofinite' arguments
13:54:03 <rwbarton> sounds interesting
13:54:17 <edwardk> rwbarton: that is what led to the silly monad i pasted above
13:54:30 <Axman6> ban_rock: you also need to use where before [n',h'] = map (fromIntegral) [n,h]: where [n',h'] = map (fromIntegral) [n,h]
13:54:34 <edwardk> rwbarton: did you see my most recent blog post?
13:55:31 <rwbarton> edwardk: yeah but I didn't really read it closely
13:56:25 <rwbarton> but I think the gist of it was to do the search trick more efficiently?
13:56:44 <edwardk> rwbarton: basically abusing parametricity to take escardo's monad and get better introspection capabilities which can radically change the asymptotics of it
13:57:53 <edwardk> instead of (Cantor -> Bool) -> Cantor     you thread the monad through but keep them from using any properties of any particular monad, so in the end all they can do is program with it like it was a cumbersome version of the identity monad.
13:58:11 <rwbarton> the thing I was thinking about is replacing Bool with the value of a function you're trying to optimize
13:58:22 <rwbarton> except instead of just using the value, you use a list of improving bounds on the value
13:58:33 <edwardk> then you use their function which is polymorphic in the choice of monad
13:58:34 <edwardk> well
13:58:35 <rwbarton> then I think what you get out is basically branch-and-bound
13:58:44 <edwardk> the Bool is a nice limiting version of the monad
13:58:58 <edwardk> it works as a monad with any value for that slot though
13:59:37 <edwardk> in the end you ultimately use some decision procedure applied to whatever value you give back there, so it seems that you don't win a lot by varying it
13:59:51 <ban_rock> mike-burns: I still don't understand what to write, sorry
14:00:22 <edwardk> coz you could always 'finally encode' the decision procedure in the -> Bool version
14:01:05 <rwbarton> ban_rock: what you're trying to do there doesn't make sense
14:01:31 <rwbarton> unless you want to try to recover h from just the function warm h, which might be possible
14:01:40 <hpaste> mike-burns annotated “general silliness” with “general silliness (annotation)” at http://hpaste.org/55853#a55854
14:02:19 <mike-burns> I took some guesses and didn't try it in GHC but that's closer to the right idea.
14:03:24 <rwbarton> ban_rock: once I form "warm h" that is just a function Int -> Colour. It doesn't "know" any more that it was formed by applying warm to h.
14:03:39 <rwbarton> so there's no way to get h back out, in general.
14:03:51 <rwbarton> for example, it might not depend on h at all (here it looks like it will, in fact)
14:03:55 <ban_rock> ok, good point
14:04:58 <rwbarton> it looks like you would like to, maybe for debugging purposes or something, take an Int -> Colour and somehow work out how you formed it
14:05:24 <rwbarton> Alternatively, you can do something like
14:05:30 <rwbarton> type Gradient = (Int -> Colour, String)
14:05:46 <rwbarton> warm2 h = (warm h, "Warm (height " ++show h ++ ")")
14:07:04 <ban_rock> yeah I suppose I'll do that
14:07:24 <ban_rock> thanks
14:07:33 <ban_rock> sorry for being confusing
14:13:04 * hackagebot yaml 0.5.0.1 - Low-level binding to the libyaml C library.  http://hackage.haskell.org/package/yaml-0.5.0.1 (MichaelSnoyman)
14:20:32 <MostAwesomeDude> I have a bunch of no-argument constructors on a type, and a record which is associated with that type, all of which is open-coded into a function recordForType :: Type -> Record. Is there a better way to handle this pattern of static but highly-patterned data?
14:23:23 <srhb> So will I know when I understand monads? :-)
14:23:43 <monochrom> tomorrow
14:23:54 <mercury^_> Know what?
14:25:25 <iceman111> What blog post?
14:25:52 <srhb> I fear that I won't know if I understand monads. I'm sure it'll go away when I actually do. :P
14:26:00 <mikeplus64> there are no "monads", I don't know what you're talking about
14:26:10 * srhb rips out hair
14:26:12 <mikeplus64> lol
14:27:22 <iceman111> plus++
14:27:35 <mikeplus64> my nooby definition of them is that they encapsulate data
14:30:12 <srhb> Hah, I can make my own operators. Cool.
14:30:32 <srhb> Who needs monads when I can have a ^-^ operator.
14:45:53 <tsousa> is there market oportunitie for someone who knows Haskell? or it is too complicted?
14:46:16 <hughfdjackson> i'm not sure complexity would be the barrier to getting a job
14:46:33 <hughfdjackson> normally, knowing complex things makes you more valuable as an employee ;)
14:47:23 <ehuber_> haskell makes you a better thinker, probably, imo
14:47:32 <tsousa> i am not saying that haskell is complicted. i am asking if it is complicted to get a job with Haskell
14:47:49 <hughfdjackson> oh ^^
14:49:12 <ehuber_> i only know of one company in SF hiring people for haskell
14:49:40 <tsousa> that sucks
14:50:06 <tsousa> i want to get some kind of freelancer job in programming to make some money while i am online
14:50:51 <ehuber_> you should follow up with the appropriate mailing lists / irc channels
14:51:14 <tsousa> the haskell? something there some jobs in here=
14:51:15 <tsousa> ?
14:51:20 <ehuber_> i suspect that if you do good work, people wont care what language it's in, particularly if you are doing the project beginning to end
14:52:56 <tsousa> ehuber_, but that is kinda hard monitoring a lot of channels. i cant be active in all of them
14:54:07 <ehuber_> Le Pétomane (play /ləˈpɛtəmeɪn/, French pronunciation: [ləpetɔˈman]) was the stage name of the French flatulist (professional farter) and entertainer Joseph Pujol (June 1, 1857–1945).
14:54:14 <ehuber_> oops, meant for another channel
14:57:18 <aristid> ehuber_: good to know!
14:57:48 <mux> I'm dying to know what channel that was meant for :-P
15:06:45 <hughfdjackson> learn you a haskell has a re-implementation of javascript-like truthy/falsyness with typeclassest
15:06:51 <hughfdjackson> it's pretty damn impressive
15:06:52 <hughfdjackson> just sayin
15:07:18 <mercury^> What is typeclassest?
15:07:29 <hughfdjackson> :P theres an errant t on the end there
15:07:37 <hughfdjackson> obviously overexcited xD
15:10:05 <chrisdone> anyone successfully compiled uhc recently and on what ghc version? with e484883 (HEAD) from the github mirror, linking install/101/bin/ehc has some undefined references.
15:11:56 <lpsmith> chrisdone, no, not recently unfortunately
15:12:15 <lpsmith> Has anybody written a supervisor process for remote-haskell?
15:19:13 <simon__> hello. i have a question. how is f a = a `op` b different from f = (`op b)?
15:19:46 <simon__> i'm trying to write a function with memoization and it works with a section but fails with an explicit argument
15:22:54 <ehuber_> what's the failure ? :)
15:23:25 <simon__> it won't cache the results between different calls to the function
15:23:54 <lpsmith> simon__, are you using unsafePerformIO out of curiousity?
15:24:03 <simon__> no
15:24:12 <ehuber_> small enough to hpaste the whole thing? :)
15:24:17 <lpsmith> there _shouldn't_ be any difference then
15:24:30 <simon__> there's an example on haskellwiki for fibonacci numbers
15:24:42 <simon__> memoized_fib :: Int -> Integer memoized_fib =    let fib 0 = 0        fib 1 = 1        fib n = memoized_fib (n-2) + memoized_fib (n-1)    in  (map fib [0 ..] !!)
15:25:34 <lpsmith> I would check that the difference really is what you think it is.   I think something else is different and you aren't realizing it.
15:26:07 <ehuber_> when i got lost (frequent) i do lots of nested lets with explicit type constraints :D
15:26:59 <gwern> 'loli has been deprecated in favor of miku (by the same author)' <-- before I got into Vocaloid, this edit summary would not have bothered me
15:27:39 <lpsmith> Barring that,  you can hpaste something,   maybe minimal version that exhibits the behavior if you don't want to reveal what you are doing.
15:28:24 <simon__> i've posted the example from haskellwiki
15:28:42 <simon__> if i change the section to (map fib [0 ..] !! n) it fails
15:30:29 <lpsmith> simon__:  you have to be making another change in addition to that one,  as there isn't an "n" in scope
15:30:47 <lpsmith> also,  is this ghci only, or does the behavior change when you compile the definition?
15:31:00 <simon__> lpsmith: yes ofcourse, memoized_fib n = instead of memoized_fib =
15:31:20 <simon__> i've only tried it in ghci
15:33:11 <lpsmith> yeah,  that is causing the memo table to be recomputed,  though with let-floating you might see a change in behavior under compiliation
15:34:00 <chrisdone> yaaay. uhc built with ghc 7.0.4
15:34:09 * chrisdone claps like a seal
15:34:36 <chrisdone> jscript generation here i come
15:35:43 <lpsmith> err
15:35:55 <lpsmith> simon__, which version of ghc are you using?
15:36:11 <simon__> 6.12.3
15:36:43 <matobet> @pl \x y -> q y . q x
15:36:44 <lambdabot> flip ((.) . q) . q
15:37:02 <lpsmith> simon__, all these work for me under ghc-7.0.3
15:37:04 <lpsmith> http://hpaste.org/55861
15:37:38 <simon__> alright i'll just update then, thanks a lot
15:38:37 <lpsmith> Actually, they all work for me with ghc-6.12.3 as well
15:39:12 <lpsmith> (though there was a bug in like,  6.8.2 I think that variables weren't scoped right that screwed up some memoization for me.
15:39:29 <lpsmith> (ghci only)
15:39:54 <lpsmith> oh duh
15:40:11 <lpsmith> n/m,  I forgot to update the name of memoized_fib in the variants
15:41:14 <iceman111> husky
15:42:43 <lpsmith> ok,  I broke memoization in ghc-7.0.3,  though compilation -O restores it thanks to let floating
15:43:09 <lpsmith> simon__, the issue is that the (map fib [2..]) list gets recomputed every time you enter the function
15:43:38 <ski>   memoized_fib = let foo = map fib [2..] in \n -> ..foo..n..  -- ?
15:43:58 <lpsmith> you could write (let xs = map fib [2..] in \n -> xs !!n), which fixes it,  and GHC will actually do for you in this case
15:43:58 <ski> (or using `where')
15:44:37 <iceman111> husssky
15:45:03 <simon__> lpsmith:  i see, thanks for the help
15:51:33 <vhd> Ok I know this is invalid, but anyone know why? "data Expression = [Element]
15:51:33 <vhd> data Element = Digit | Plus | Multiply
15:51:33 <vhd> type Digit = Int"
15:52:27 <ivanm> vhd: you need a constructor for data
15:52:28 <vhd> I understand it causes problems for pattern matching
15:52:33 <ivanm> otherwise, type Expression = [Element]
15:52:37 <ivanm> ^^ that just defines it as an alias
15:53:20 <vhd> oh
15:53:25 * vhd facepalm
15:59:39 <int80_h> is it legal to put a let binding inside a where binding?
16:00:12 <vhd> why would you need to do that?
16:00:20 <parcs`> > let f x = x where g x = let y = x in y in f ()
16:00:21 <lambdabot>   ()
16:00:24 <lukish_> Can anyone show some simple example of using gnuplot lib? How can I get plot for :: [(Int,Int)]?
16:01:06 <int80_h> hmm my indentation is prolly off then
16:19:52 <Jacco> What does "let x = y" (in do construction) translate to? Is it just "return y >>= (\x -> ..." ?
16:20:58 <Sgeo> What's the preferred way in Haskell to prevent confusion of units?
16:22:26 <hpaste> lukish pasted “gnuplot” at http://hpaste.org/55863
16:22:28 <lukish_> I run it and got nothing. How can I get picture or something?
16:27:30 <iceman111> anyone here?
16:28:09 <iceman111> you there?
16:28:20 <adu> hi iceman111
16:28:32 <iceman111> Hello adu
16:28:40 <adu> how are you?
16:28:51 <iceman111> Tired.  u?
16:29:08 <adu> invigorated
16:29:24 <iceman111> really adu?
16:30:38 <monochrom> Jacco: an example: do { x<-m; let y = f x; blah y } is translated to m >>= \x -> let y = f x in blah y
16:31:02 <monochrom> in general, do's let is translated to let-in
16:33:12 <tibbe> What extension do I need to write something like: builtinCounters :: Map.Map T.Text (forall a. Show a => Stats.GCStats -> a)
16:33:27 <adu> iceman111: yes
16:33:40 <Sgeo> Uh
16:33:40 <tibbe> i.e. I want a Map from string keys to functions that operate on some record that contains things that have a Show instance
16:33:48 <Sgeo> :t sin
16:33:49 <lambdabot> forall a. (Floating a) => a -> a
16:34:28 <Sgeo> There has got to be a more sane way to deal with Units
16:34:53 <Sgeo> Maybe a data type with a number and a unit combined together, like a tuple
16:34:56 * Sgeo decides on that
16:35:00 <blackdog> is it expected behaviour with cabal that the test-suite executable can't use the library it's testing? i seem to have to re-add all my build-depends
16:35:03 <parcs`> tibbe: ImpredicativeTypes?
16:36:11 <tibbe> parcs`: is there a way to rewrite that using a wrapper data type?
16:36:33 <tibbe> I really just want a map of projection functions
16:36:35 <cmccann> Sgeo, what are you trying to accomplish?
16:36:51 <Sgeo> cmccann, preventing confusion in programs written by users of my library
16:37:16 <Sgeo> So they don't accidentally pass a value in meters to a function expecting centimeters, for instance
16:37:32 <cmccann> so you want to distinguish units of measurement by types?
16:37:36 <Sgeo> Yes
16:37:45 <parcs`> tibbe: you can use an existential
16:38:02 <Sgeo> I'm currently thinking (Integer, Centimeter) where Centimeter is part of some Enum might be better than my current approach
16:38:12 <cmccann> Sgeo, have you seen stuff like http://hackage.haskell.org/package/dimensional ?
16:38:18 <Sgeo> cmccann, no
16:38:35 <Sgeo> cmccann, ty
16:38:41 <cmccann> might be overkill for your purposes
16:38:44 <tibbe> parcs`: what would that look like?
16:38:52 <cmccann> Sgeo, but at least something to look at for ideas
16:39:16 <parcs`> tibbe: data ProjF = forall a. Show a => ProjF (Stats.GCStats -> a); builtinCounters :: Map.Map T.Text ProjF
16:40:01 <parcs`> tibbe: but consider refactoring the type to Map.Map T.Text (GCStats -> String)
16:40:17 <parcs`> all you can do with a forall a. Show a => a is turn it into a String anyway
16:40:34 <tibbe> right
16:40:37 <tibbe> I
16:40:44 <tibbe> I'll have to add 20 show calls though :/
16:41:16 <tibbe> emacs to the rescue
16:41:36 <parcs`> maybe you can refactor those too
16:46:43 <mdmkolbe> Template Haskell question: I can convert from a "Q a" to a "Quasi m => m a" using "runQ", but what about the other way around?
16:48:41 <parcs`> mdmkolbe: Q is an instance of Quasi
16:49:29 <mdmkolbe> The context is that I'm operating in a custom "Quasi m" monad and want to use quotes (i.e. [| ... |]) and splices (i.e. [| ... $( ... ) ...|]) to keep the code clean, but those forms seem to be hard wired to "Q Exp" rather than a general "Quasi m => m Q".
16:49:30 <mdmkolbe>   (I'd actually prefer to be able to set a flag (like overloaded string litterals) so I don't have to keep switching between the types.)
16:50:33 <ski> parcs` : almost all
16:51:20 <mdmkolbe> parcs`: Perhaps my question is misleading.  I want to convert to a particular "m".
16:51:42 <hpc> @src Q
16:51:43 <lambdabot> Source not found. I've seen penguins that can type better than that.
16:51:51 <parcs`> mdmkolbe: so ie (Quasi m1, Quasi m2) => m1 -> m2?
16:51:55 <parcs`> ski: what else?
16:53:04 <ski> parcs` : `showsPrec :: Show a => Int -> a -> ShowS'
16:53:49 <ski> the `ShowS' is supposed to be basically a `String', but the `Int' has some effect
16:53:54 <mdmkolbe> parcs`: yeah, though I could weaken the type to simply "Q a -> Q' a" where "Q'" happens to be an instance of "Quasi".
16:54:07 <ski> maybe returning `(Int,String)' would be equivalent
16:54:19 <parcs`> @src Show
16:54:19 <lambdabot> class  Show a  where
16:54:19 <lambdabot>     showsPrec :: Int -> a -> ShowS
16:54:19 <lambdabot>     show      :: a   -> String
16:54:19 <lambdabot>     showList  :: [a] -> ShowS
16:55:06 <mdmkolbe> parcs`: sorry, I should have written that type the other way around I need "Q' a -> Q a" where "Q'" is an instance of Quasi
16:55:26 <mdmkolbe> (runQ already provides me with "Q -> Q'")
16:55:40 * ski . o O ( `forall q. Quasi q => q a -> Q a' )
16:55:58 <hpc> @hoogle !
16:55:59 <lambdabot> Prelude (!!) :: [a] -> Int -> a
16:55:59 <lambdabot> Data.List (!!) :: [a] -> Int -> a
16:55:59 <lambdabot> Data.IntMap (!) :: IntMap a -> Key -> a
16:56:01 <hpc> @hoogle Q
16:56:02 <lambdabot> Prelude quot :: Integral a => a -> a -> a
16:56:02 <lambdabot> Prelude quotRem :: Integral a => a -> a -> (a, a)
16:56:02 <lambdabot> Control.Concurrent.QSem module Control.Concurrent.QSem
16:56:19 <parcs`> mdmkolbe: you would have to create that function yourself
16:56:38 <parcs`> there's no way to generically do tha
16:57:17 <mdmkolbe> parcs`: I don't see even a non-general way to do that
16:59:27 <parcs`> mdmkolbe: what exactly is Q'?
16:59:33 <mdmkolbe> (the constructors for "Q" are hidden, and the provided operatiosn don't seem to be sufficient)
16:59:35 <rwbarton> @hoogle runQ
16:59:36 <lambdabot> Language.Haskell.TH.Syntax runQ :: Quasi m => Q a -> m a
16:59:36 <lambdabot> Language.Haskell.TH runQ :: Quasi m => Q a -> m a
17:00:02 <mdmkolbe> parcs`: type Q' a = StateT S Q a
17:00:30 <parcs`> mdmkolbe: so unQ = (`runStateT` myState)
17:00:42 <mdmkolbe> where "S" is a fixed type for the state I'm threading through
17:00:54 <parcs`> you want that state to persist between splices?
17:00:57 <rwbarton> what do you need to convert exactly?
17:01:02 <ski> @hoogle Quasi m => (Q a -> Q b) -> (m a -> Q b)
17:01:07 <lambdabot> Data.Generics.Aliases ext1T :: (Data d, Typeable1 t) => (forall e. Data e => e -> e) -> (forall f. Data f => t f -> t f) -> d -> d
17:01:09 <mdmkolbe> parcs`: yes, I want the state to persist between splices.
17:01:21 <rwbarton> [| ... |] produces a Q Exp, right? so surely that direction is fine?
17:01:24 <parcs`> mdmkolbe: use a global IORef
17:02:57 <mdmkolbe> parcs`: note that by between splices, these splices are not at the top level.
17:03:08 <rwbarton> it sounds reminiscent of the monad-peel/monad-control stuff though I never actually looked into that
17:04:35 <parcs`> mdmkolbe: i think a global IORef will still be your best bet
17:04:37 <mdmkolbe> that is to say, I'm writting a function of type "blah -> Q Exp" and as part of the computation of that function I use "Q' Exp" in order to manage a memoization table.
17:05:16 <rwbarton> my understanding is you'd like to write [| ... $( ... ) ...|] :: Q' Exp where the inner ... :: Q' Exp
17:05:35 <mdmkolbe> rwbarton: exactly
17:06:10 <rwbarton> which is like when you want to pass your FancyTransformerStack actions as a gtk callback or whatever
17:06:17 <rwbarton> more or less
17:06:35 <mdmkolbe> rwbarton: I have no idea what that means
17:06:39 * mdmkolbe is not a GTK+ programmer
17:06:45 <rwbarton> neither am I
17:07:19 <rwbarton> usually the answer is to somehow stuff your extra monad layers back into IO
17:07:20 <mdmkolbe> parcs`: I'm thinking through the IORef idea
17:07:26 <rwbarton> using an IORef or something like that, yeah
17:08:15 <rwbarton> and I think there is a fancy approach also, but never having had to do this myself, I haven't looked into it
17:08:50 <mdmkolbe> rwbarton: you realize your last statement could be said about anything in haskell ;-J
17:09:04 <rwbarton> heh
17:09:30 * ski . o O ( `class MonadTransformer t => MonadTransformer1 t where lift1 :: Monad m => (m a -> m b) -> (t m a -> t m b)' )
17:09:56 <rwbarton> isn't there something like that on hackage somewhere?
17:10:06 * ski has no idea
17:10:12 <cmccann> there is an upper bound on finding fancier approaches in Haskell, and it's when you start using Agda because it seems simpler
17:10:34 <rwbarton> yeah, I'm mostly hoping someone will pipe up now and say "oh yes that's the monad-papaya package"
17:11:29 <mdmkolbe> as it stands now, I'm just writting "LamE  ... VarP ... VarE, etc" because I can't use quotation
17:12:06 * mdmkolbe wants an -XOverloadedQuotes flag
17:12:17 * cmccann would be more interested in something like (MonadTransformer t, Monad m, Monad n) => (m a -> n a) -> (t m a -> t n a)
17:12:18 <ski> hm, maybe `class MonadTransformer t => MonadFunctor t where tmap :: (Monad m,Monad n) => (forall a. m a -> n a) -> (forall a. t m a -> t n a)' is more sensible
17:12:28 <cmccann> heh
17:12:40 <ski> (which isn't the same as what cmccann said)
17:13:04 <cmccann> ski, no, but it's what I meant to say
17:13:10 <ski> heh, ok
17:13:42 <ski> @quote overloaded
17:13:42 <lambdabot> glguy says: map became not overloaded in the great polymorphic scare of haskell 98
17:13:46 <j2j`> a
17:13:51 <ski> b
17:14:16 <hpc> haha
17:14:21 <Sgeo> hmm?
17:15:47 <cmccann> ski, http://hackage.haskell.org/packages/archive/Monatron/0.3.1/doc/html/Control-Monatron-MonadT.html#t:FMonadT
17:15:51 <cmccann> not quite the same
17:15:56 <cmccann> but I knew I'd seen something like it
17:16:58 <ski> close enough
17:17:06 <ksf> http://www.youtube.com/user/28c3
17:17:09 <ski> but that `MonadT t' looks strange
17:17:18 <ksf> *this* is how you do conferences: put up videos straight away.
17:18:15 <rwbarton> it looks like it's trying to express that t m is a monad whenever m is a monad
17:18:24 <ski> i would have expected `tbind :: (Monad m,Monad n) => t m a -> (forall a. m a -> t n a) -> t n a' instead of `tbind :: Monad m => t m a -> (a -> t m b) -> t m b'
17:20:37 <ksf> ...still no icfp 2011 videos online, it seems.
17:40:02 <mkscrg> Does `fix` get used for anything other than recursive-izing anonymous functions?
17:41:14 <aristid> mkscrg: it can also be used to recursive-ize functions that are not anonymous
17:41:34 <Entroacceptor> and to create infinite lists on irc
17:41:41 <mkscrg> aristid: fair enough.
17:41:42 <mauke> it can be used to create cyclic data
17:43:01 <Philippa> mkscrg: it can be the first step in some interesting refactorings
17:43:30 <mkscrg> Philippa: yeah, i can see how that would be
17:43:30 <lpsmith> is it my imagination, or does the linker for GHC 7 have a serious performance problem?
17:44:14 <mkscrg> fair to say that recursivizing things is its most common use case?
17:48:17 <cmccann> mkscrg, as far as I know the main use of fix is to do this
17:48:19 <cmccann> > fix error
17:48:20 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
17:50:37 <parcs`> > fix show
17:50:40 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
17:51:01 <mauke> > fmap fix return ()
17:51:02 <lambdabot>   ()
18:03:06 * hackagebot enumerator-tf 0.1.1 - Enumerator instances for monads-tf classes  http://hackage.haskell.org/package/enumerator-tf-0.1.1 (JohnMillikin)
18:03:50 <Guest39809> what is the general opinion on name shadowing?
18:04:17 <Guest39809> i kind of like doing it in do blocks to shadow and updated variable (where the old one should not be updated)
18:04:53 <Guest39809> or in a function for a fold - where the initial and its updated value on each pass of the fold have the same name
18:05:18 <Guest39809> i.e. let f a b = a + b in foldr b ...
18:05:24 <Guest39809> err, foldr f b ...
18:05:43 <Guest39809> but the warning messages keep worrying me
18:05:55 <Guest39809> and i don't just want to outright disable the warning..
18:07:03 <Guest39809> *should not be updated -> should not be used
18:07:23 <mm_freak> Guest39809: i don't like to shadow variables, because it holds the danger of using the wrong variable when changing code
18:07:37 * cmccann concurs with mm_freak
18:08:09 <cmccann> also, it makes it harder to tell which one is being used in a specific context
18:08:58 <parcs`> Guest39809: if you do only a couple of variable updates you can get away with naming them foo, foo', foo'', etc.. if you need a lot of names then consider using StateT
18:09:00 <Guest39809> do you just add a ', or something along those lines?
18:09:03 <mm_freak> Guest39809: note that usually the shadowed variable usually has the same name as the new variable in this style, so the type checker can't always find such errors
18:09:27 <mm_freak> my personal convention is to append an apostrophe to the older variable
18:09:31 <mm_freak> x'' becomes x' becomes x
18:09:43 <Guest39809> ok
18:09:52 <mm_freak> most haskellers seem to do the exact opposite
18:10:04 <Guest39809> i will probably add ', mostly because i've already started doing that, and not sure where..
18:10:05 <Guest39809> right
18:10:52 <cmccann> yeah, I also tend to use x' for the "new" version of x
18:11:07 <cmccann> though even that I try to avoid when possible, since it's still easy to mistype or misread
18:11:19 <cmccann> and the same concern about "probably the same type" applies
18:11:56 <rwbarton> maybe off-topic, but if it's a function parameter you're shadowing via a let-binding, you can use a view pattern instead to avoid ever naming the original argument
18:12:13 <mm_freak> yeah, i use view patterns a lot
18:13:10 <cmccann> I also find that in many cases where you'd have a succession of values like that, you don't use the intermediate values for much
18:13:34 <cmccann> so when possible I extract whatever the intermediate stuff is and then do it all at once
18:15:17 <mm_freak> at these points haskell could benefit from linear/uniqueness types
18:16:02 <awilson> Hello all. I'm new to Haskell, working my way through LYAH. When talking Applicative Functors, how is the <*> operator pronounced?
18:16:33 <cmccann> mm_freak, yes, but that's slightly more ambitious than moving a few definitions into a where clause
18:16:47 <rwbarton> probably would also have more syntactic overhead
18:17:11 <cmccann> awilson, http://stackoverflow.com/q/3242361/157360
18:17:38 <cmccann> awilson, that contains my slightly lengthy answer to that question, heh
18:18:04 <rwbarton>  lax monoidal functors are interesting >:|
18:18:09 <cmccann> haha
18:18:22 <mm_freak> rwbarton: how come?  to me it would be something like a kind annotation
18:18:24 <cmccann> not interesting enough to get a fancy name like monad, apparently
18:18:25 <rwbarton> these aren't arrows we're talking about!
18:18:34 <awilson> cmccann: thanks!
18:18:57 <awilson> Be back in a week once I get through it :-)
18:19:02 <cmccann> hahaha
18:19:09 <mm_freak> f :: forall (a :: Linear *). (a ~ Int) => Int -> Int
18:19:11 <mm_freak> something like that
18:19:33 <mm_freak> awilson: i'd pronounce it "applied to"
18:19:41 <rwbarton> linear types just don't fit into haskell's type system at all
18:19:49 <mm_freak> rwbarton: why not?
18:19:55 <rwbarton> again with the example I gave before
18:19:57 <rwbarton> \x -> (x, x)
18:20:10 <rwbarton> has type forall a. a -> (a, a)
18:20:15 <mm_freak> sure, that's the point of them…  to disallow that
18:20:29 <rwbarton> right, and they don't exist in haskell :P
18:20:30 <mm_freak> you can't write this function, when 'a' is of kind Linear *
18:20:46 <rwbarton> but I already wrote it
18:20:51 <rwbarton> so you really need to do the opposite
18:20:54 <rwbarton> mark all your non-linear types
18:21:03 <rwbarton> and only allow me to write \x -> (x, x) at those types
18:21:14 <rwbarton> something like !a -> (!a, !a)
18:21:20 <mm_freak> i don't see it…  the * kind could be the default, and you would have to annotate linear types explicitly
18:21:34 <rwbarton> except you should add a ton more non-linearity markers everywhere
18:21:59 <awilson> Thanks mm_freak
18:22:15 <cmccann> rwbarton, don't you also need the four connectives from linear logic somehow, too
18:22:20 <mm_freak> awilson: don't confuse it with regular function application though
18:22:34 <rwbarton> then when you want to introduce linearity in your example use case, you have to somehow "convert" to a linear type
18:22:49 <rwbarton> cmccann: yeah, like a !-version of (->) and (,)
18:22:56 <mm_freak> rwbarton: what is the next higher level after kinds?  sorts?
18:23:00 <rwbarton> or, well, (->) at least
18:23:06 * hackagebot ekg 0.2.0.0 - Remote monitoring of processes  http://hackage.haskell.org/package/ekg-0.2.0.0 (JohanTibell)
18:23:10 <rwbarton> mm_freak: it seems that the terminology is inconsistent but I would call them that
18:23:30 <awilson> No... actually I was thinking just that: can't *any* operator be called "applied to"?
18:23:32 <rwbarton> ("inconsistent" as in not universally agreed)
18:23:35 <cmccann> rwbarton, no, I mean distinguishing between the different kinds of conjunctions and disjunctions
18:24:43 <mm_freak> well, i see what you are trying to say…  but i'm not really asking for linear logic…  i'm just asking for something along the lines of uniqueness types…  IMO that doesn't require changing the type system…  it just requires a kind constructor
18:25:11 <mm_freak> forall (a :: Unique *). (a ~ Int) => a -> a
18:25:18 <mm_freak> something like that
18:25:38 <mm_freak> not sure if that doesn't introduce any logical inconsistency though
18:26:09 <cmccann> mm_freak, you could actually fake that to some extent using newtype wrappers and existentials
18:26:13 <cmccann> cf. runST
18:26:41 <mm_freak> i know, but it's not the real thing, merely an approximation with much weaker guarantees
18:26:44 <rwbarton> that might work, although I don't see how "a ~ Int" could be satisfied if a and Int have different kinds, you'd need some other syntax to express what the "underlying type" of a is.
18:27:01 <mm_freak> yeah, true
18:27:26 <mm_freak> perhaps even just:  Unique a -> Unique a
18:27:28 <mm_freak> uhm
18:27:32 <mm_freak> perhaps even just:  Unique Int -> Unique Int
18:27:53 * cmccann would like to see a type system that started with full linear logic and adjusted it as necessary for practical use, rather than trying to bolt linear-flavored stuff onto a normal type system
18:27:56 <mm_freak> Unique :: * -> Unique *
18:28:28 <rwbarton> mm_freak, but Unique Int has kind Unique * right
18:28:34 <rwbarton> so that is a kind mismatch with (->)
18:28:44 <mm_freak> indeed
18:28:49 <rwbarton> unless you want to say that this is a new, or polymorphic (->)
18:29:01 <mm_freak> well, we have PolyKinds since GHC 7.4
18:29:09 <rwbarton> Unique Int is such a strange concept though
18:29:10 <mm_freak> so (->) could indeed be polymorphic
18:29:37 <rwbarton> I wouldn't be able to use a "value" of that type normally
18:29:44 <rwbarton> since the type doesn't have kind *
18:29:54 <mm_freak> correct
18:30:02 <rwbarton> so you would need some entirely separate language to work with them (again, unless you did something cleverly kind-polymorphic)
18:30:12 <mm_freak> but if (->) is polymorphic, this should be /much/ of an issue
18:30:55 <mm_freak> after all since kind polymorphism you have much more potential for kind errors
18:33:18 <rwbarton> cmccann: that would be interesting. Something like a linear Agda, maybe, though whatever Agda's type system is is already very complicated
18:35:04 <cmccann> rwbarton, I figure somebody must have a toy implementation of something like that, but I haven't found one yet :T
18:41:59 <awilson> cmmcann: thanks for the Applicative explanation, superb!
18:42:14 <awilson> *cmccann*
18:42:23 <cmccann> awilson, thanks :]
18:43:18 <awilson> Incidentally, I've noticed as a beginner (with Functors too) that explanations make much more sense to me when they talk about the "lifting" concept (as you did)
18:43:32 <awilson> All this talk of "contexts" and "boxes" doesn't help much, it seems to me.
18:43:44 <mbetter> what about spacesuits?
18:43:54 <awilson> My "aha" moment with Functors came when I looked at the CT explanation
18:43:58 <companion_cube> they're like monads.
18:44:03 <awilson> Or Burritos? :-)
18:44:05 <cmccann> mbetter, and burritos too
18:44:21 <mbetter> didn't see that one
18:44:22 <cmccann> they're like boxes full of burritos being lifted by a guy wearing a space suit
18:44:25 <mbetter> now it all makes sense
18:44:32 <awilson> Aha!
18:44:56 <companion_cube> well obviously by transivity, spacesuits are like burritos
18:45:04 <cmccann> right
18:45:17 <mbetter> if i'm trying to define an instance of Typeable, what exactly am I trying to do?
18:45:24 <companion_cube> that's why mexicans have been the first men in space
18:45:27 <companion_cube> oh, wait.
18:45:33 <cmccann> mbetter, probably the wrong thing
18:45:35 <dmwit> Did somebody say "derive Typeable" yet?
18:45:39 <dmwit> You should never write your own instance.
18:45:41 <msieradzki> To ask potentially flamewar starting question (but without intention of it) why are records stalled? Is it because they're technically hard to implement once you decide on specific solution or is it because there are no satisfying solutions or something else?
18:45:54 <mbetter> can i derive an instance outside of the declaration?
18:46:16 <parcs`> msieradzki: have you read this: http://www.haskell.org/pipermail/glasgow-haskell-users/2011-December/021359.html
18:46:18 <cmccann> msieradzki, because everyone agrees that records suck the way they are now, but nobody can agree on what to do instead
18:46:47 <mbetter> records seem to work ok until i'm trying to update them
18:46:52 <mbetter> then everything falls apart
18:46:59 <cmccann> mbetter, use a lens library
18:47:03 <msieradzki> Yes, I did. I also don't like having entityField for 50 entities in HDBC binding module :)
18:47:07 <rwbarton> mbetter: in any place where all the constructors of your type are in scope, yes, using standalone deriving--in fact for Typeable perhaps you don't even need that condition
18:48:20 <mbetter> rwbarton: ahh, that's what i should have been googling
18:49:29 <mbetter> rwbarton: thanks
18:50:17 <cmccann> awilson, and yeah, while the term "lifting" is badly overloaded it's also fairly neutral in avoiding unwanted connotations
18:53:32 <zmv> burritos suck, tacos ftw
18:53:57 <tensorpudding> zmv, you're out of line, mister!
18:54:00 <companion_cube> man, you're saying that tacos are cooler than spacesuits
18:54:02 <zmv> ):
18:54:28 <zmv> companion_cube: no, I'm saying taco spacesuits are cooler than spacesuits
18:54:31 <companion_cube> just imagine what the first man on the moon would have looked like if he weared tacos instead of a spacesuit
18:54:45 <tensorpudding> the contents of your wrapped tortilla are vitally important
18:54:54 <zmv> it would have looked awesome
18:56:24 <cmccann> huh, so I guess if you unwrap a burrito, dump the filling out, and put it back together as a taco
18:56:29 <cmccann> that's like a monad transformer
18:56:37 <cmccann> makes sense to me
18:56:48 <awilson> cmccann: Yes. When I read the Category Theory basis for Functors I thought: "so, the type constructor maps objects to the new category, and fmap maps the morphisms... why the hell didn't they just say that at the start?!!"
18:57:27 <cmccann> well, it's always the same category, but yes :]
18:57:31 <mbetter> if you take a small burrito and put it in a taco shell and put meat, cheese and lettuce on top
18:57:37 <mbetter> that's like a monad transformer
18:57:44 <cmccann> mbetter, ah, good point
18:58:28 <companion_cube> it's burritos all the way down anyway
18:58:55 <awilson> Ok. So we are not lifting from HASK to some other category? (like, the subcategory of HASK where all objects are Maybes, for example)?
18:59:04 <mbetter> companion_cube: you're not supposed to talk
18:59:16 <companion_cube> no, you're not supposed to listen
18:59:18 <companion_cube> :p
18:59:20 <cmccann> awilson, it's a subcategory, yes, but that's (usually) not helpful
18:59:35 <companion_cube> and besides, gladOS never said i could not go on irc
18:59:37 <cmccann> since you can't really do much with those subcategories
18:59:43 <mbetter> good point
18:59:56 <mbetter> at least you're not threatening to stab me
19:00:00 <awilson> Ok. I guess I was thinking about it in isolation, as a way of understanding functors.
19:00:17 <companion_cube> note to myself: threaten to stab mbetter
19:00:33 <awilson> Actually *doing stuff* with ANY of this is way in the future :-)
19:00:41 <cmccann> awilson, your understanding is correct, yeah
19:02:53 <mbetter> oh, so to derive Typeable, I really need to derive Typeable1
19:03:17 <cmccann> awilson, and for what it's worth the Category type class describes categories whose objects are the same as Hask but whose arrows are something else
19:12:12 <cmccann> so I was looking through some old comment threads on reddit for some reason the other day and noticed this:
19:12:13 <cmccann> http://www.reddit.com/r/programming/comments/84sqt/dear_reddit_i_am_seeing_12_articles_in/c0895ua
19:12:29 <cmccann> obviously a joke, but even funnier two years later, heh
19:12:42 <mbetter> lol
19:12:57 <cmccann> (check the commenter's submissions if you don't know why it's funny)
19:13:38 <mbetter> bonus wrote LYAH, right?
19:13:43 <cmccann> yeah
19:13:46 <zmv> yeah
19:14:53 <awilson> cmccann: thanks for your help.
19:15:19 <mikeplus64> what's the different between runghc and runhaskell?
19:15:21 <cmccann> awilson, you're welcome
19:16:32 <donri> mikeplus64: none, if you only have ghc installed
19:18:54 * cmccann should write a Haskell book one of these days, or something
19:19:28 <chadz> thats a surefire getrich scheme
19:19:30 <donri> is there a de facto cabal flag for building tests?
19:19:58 <cmccann> chadz, I figure I'm already halfway there, the sum total of my posts on Stack Overflow must be nearly book length by now
19:20:44 <chadz> anyone use much of vty-ui?
19:22:25 <chadz> i'm trying to resolve the best way to manage state
19:23:26 <cmccann> chadz, how so?
19:24:35 <chadz> well, with vty-ui you basically create your ui elements, set some handlers, and then call runUi
19:24:55 <cmccann> it's all driven by event handlers that run in IO, right?
19:24:58 <chadz> yeah
19:25:04 <chadz> i can't figure out how to sneak in my own monad
19:25:22 <cmccann> you probably should just stash things in IORefs
19:25:42 <chadz> yeah, thats what i was thinking
19:25:56 <chadz> i've never played with iorefs yet tho
19:26:17 <cmccann> do you know if the event handlers block?
19:26:54 <chadz> i think they do
19:27:25 <cmccann> then IORefs are just mutable storage cells, there's not much to worry about
19:27:33 <cmccann> as long as you're not poking at them from multiple threads
19:28:04 <cmccann> create your IORefs at the start, pass them in to the IO actions that get run as event handlers
19:28:11 <cmccann> read and write the IORefs
19:29:26 <cmccann> could also consider having a separate thread to do non-UI stuff, and let it communicate with the UI stuff using STM or whatever
19:29:59 <chadz> yeah, that's a possibility too.
19:30:17 <cmccann> depending on whether you have stuff that could run in the background, or if the logic is more linear and less event-driven
19:30:31 <chadz> would be a lot cleaner if you could just specify your own monad for vty-ui ;)
19:30:49 <cmccann> yes, I loathe the IO action callback approach
19:31:09 <chadz> i'm still pretty noob... how would that work in essence
19:31:17 <chadz> is there a way to require that the monad provided has IO at some level?
19:31:28 <mbetter>  MonadIO
19:31:29 <mbetter> ?
19:31:30 <cmccann> there is, but that doesn't help here
19:31:44 <chadz> well, assuming that vty has to do IO
19:31:46 <cmccann> because you don't control the event loop, and the library demands things with IO
19:31:53 <chadz> it would have to do various lifts to actually get to the io monad, right?
19:32:16 <cmccann> yes, you could do that if you were writing your own library
19:32:26 <cmccann> but that converts IO to something else
19:32:29 <chadz> does implementing MonadIO act in defining how to perform IO?
19:32:40 <chadz> yeah, i know that doesnt help here
19:32:47 <mm_freak> i don't understand why libraries insist on having their own builtin event loop…  that's the reason i stopped using vty-ui
19:32:53 <dylukes> My friends facebook status:
19:32:54 <dylukes> I love how the geodesic dome in the Sims 3 is made up completely of equilateral triangles and ALL of them are six to a vertex. Yeah that's sort of impossible. All geodesic domes (spheres) need exactly 12 vertexes where 5 triangles meet and the rest are hexagonal. FFFFFFFFFFFFFFFF
19:32:56 <dylukes> this amused me.
19:33:00 <dylukes> Cale: seems like your kind of thing.
19:33:13 <chadz> mm_freak: i'm sur ethe author would love feedback ;)
19:33:44 <mm_freak> chadz: i'm not patient enough to wait for other authors to fix their libraries…  i usually just roll my own =)
19:33:46 <cmccann> chadz, if you have a transformer stack with IO at the bottom, the MonadIO class gives you something that lifts an IO action through the intermediate layers
19:34:05 <cmccann> it's nothing terribly fancy
19:34:18 <JoeyA> mm_freak: What's a better approach.  When I write loopy code (e.g. listen for asynchronous notifications on a database connection), I find myself wondering what to do.
19:34:32 <JoeyA> s/approach./approach?/
19:34:36 <mm_freak> JoeyA: getEvent, pollEvent, just like SDL does
19:34:47 <mm_freak> SDL has no builtin event loop, but allows you to write your own loop polling for events
19:34:48 <Solver> congratulations to haskell.org in becoming an SPI associated project
19:34:57 <mm_freak> such libraries are much more composable, and i can use my usual FRP approach with them
19:35:35 <mm_freak> JoeyA: in case of own, application-specific events you can do even better and use STM or something like that
19:36:01 <JoeyA> mm_freak: See, that's the thing.  There's so many ways to do it.
19:36:11 <cmccann> mm_freak, or I can use my preferred monadic unfolding style
19:36:26 <karoyakani> @pl (\x-> delete 2 . delete 5 . delete 9 $ x )
19:36:26 <lambdabot> delete 2 . delete 5 . delete 9
19:36:34 <JoeyA> cmccann: What's that?
19:36:37 <mm_freak> JoeyA: as a library author i think it's reasonable to provide stepping functions…  that was my main reason for abandoning yampa, for example
19:36:52 <mm_freak> the author of the animas fork thinked further and gave stepping functions
19:36:57 <cmccann> mm_freak, amazing how the library not having a built-in event loop lets you pick different styles by personal taste, huh
19:38:07 <cmccann> JoeyA, do you know what unfoldr does?
19:38:26 <JoeyA> cmccann: Yes
19:38:38 <Sgeo_> :t unfoldr
19:38:39 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
19:39:42 <JoeyA> So what if I'm not just generating events, but also doing stuff?  For example, download from a URL every 20 seconds.
19:40:00 <JoeyA> Timing is part of the logic, so a step function seems a little awkward.
19:40:00 <mm_freak> threads?
19:40:18 <cmccann> JoeyA, take the same idea as unfoldr, except start with a function like (b -> m (a, b)) or such
19:40:22 <JoeyA> mm_freak: Do I spawn the thread in my code, or do I provide a loop function so the caller can spawn the thread?
19:40:48 <mm_freak> JoeyA: your example is very vague…  it depends on the application
19:41:02 <cmccann> JoeyA, and then have all the "looping" occur in an unfoldM or some variation on such
19:41:34 <JoeyA> mm_freak: It shouldn't depend on the application.  Suppose I want to parse JSON.  Parsing JSON is, for the most part, not application-specific.  A general library can be written for it.
19:42:34 <cmccann> avoiding direct recursion makes it easier to splice new bits in the middle or adjust the behavior of the whole program, plus I find the style aesthetically pleasing I suppose
19:42:53 <mm_freak> cmccann: good approach, but i'd still provide stepping functions, because your interface might not fit the application logic
19:43:11 <JoeyA> But downloading from a URL every 20 seconds, and doing something with each result, is a pretty simple task.  I just don't know which of the several approaches is best.
19:43:16 <mm_freak> the problem is comparable to openFile/hClose vs. withFile
19:43:27 <mm_freak> withFile is great, but doesn't fit everywhere
19:43:59 <cmccann> mm_freak, not sure what stepping functions means here, I lost a bit of context while being distracted, sorry
19:44:22 <mm_freak> cmccann: withEvents vs. getNextEvent
19:44:28 <JoeyA> Approaches including: 1) Expose a step action that returns the download, plus an action to invoke after using the downloaded content, 2) Provide a loop and take a callback 3) Spawn a thread and take a callback 4) Use enumerator ...
19:45:13 <mm_freak> the downloading bit is probably outside the scope of a library, so you would just write a second thread that does the downloading
19:45:25 <cmccann> mm_freak, I'd usually favor getNextEvent with my approach, actually
19:45:41 <mm_freak> cmccann: your approach sounded a lot like withEvents to me
19:45:43 <JoeyA> mm_freak: Library or not, I want to be able to encapsulate the logic of downloading and waiting
19:45:56 <JoeyA> it's not simply cycle (sleep 20 >> download)
19:46:11 <JoeyA> download takes time, so I want to account for that by reducing the time spent sleeping
19:46:28 <JoeyA> err, forever (sleep 20 >> download)
19:46:58 <JoeyA> There's also the issue of stopping the thread correctly.  killThread doesn't always work ( http://hackage.haskell.org/trac/ghc/ticket/5611 )
19:46:59 <cmccann> mm_freak, my approach is more like providing the bits and pieces to build your own withEvents
19:47:35 <mm_freak> JoeyA: set an STM flag to True every 20 seconds
19:47:46 <mm_freak> the timer can be controlled by an event or a separate thread
19:48:09 <mm_freak> cmccann: i see…  i just provide the getEvent (what i'm calling a stepping function)
19:48:36 <JoeyA> Yes, but which?  When I write concurrent or eventful code in Haskell, I frequently stare at a fork in the road.  It's annoying.
19:49:47 <cmccann> mm_freak, ah, to be clear, I'm talking about my approach in the context of writing the application code, where I'd be relying on using something like getEvent
19:50:41 <cmccann> possibly using some very generic functions to assemble the pieces
19:50:49 <JoeyA> More than once, I've written modules to encapsulate parts of my task, and had to throw them away because they didn't fit together.  I don't run into this problem often.
19:51:02 <JoeyA> (err, I usually don't run into this problem in other contexts)
19:51:39 <cmccann> JoeyA, as a rule of thumb, when writing concurrent code, if you come to a fork in the road you should take both paths
19:51:44 <cmccann> that's the whole point, after all ;]
19:51:52 <mike-burns> You have the program working but you're trying to refactor?
19:52:03 <mbetter> like a quantum robert frost
19:52:11 <JoeyA> mike-burns: Almost-working, and hard to extend.
19:53:28 <JoeyA> Writing nondeterministic code doesn't make me a nondeterministic programmer.
19:54:12 <mm_freak> cmccann: i see…  i took the library author's perspective
19:55:08 <cmccann> mm_freak, I was contrasting my approach to your mention of FRP style
19:55:22 <cmccann> and noting that both are much easier if the library doesn't try to do everything for us
19:55:46 <mm_freak> cmccann: in FRP i strictly separate the two parts of the program:  the highly declarative reactive system and the highly imperative loop that runs it
19:55:57 <mm_freak> yeah, correct
19:56:25 <mm_freak> hence my preference of SDL over GLUT and a custom library over vty-ui
19:56:45 <Sgeo_> Wait, so usually people prefer polling?
19:56:50 <mm_freak> i do
19:56:54 <JoeyA> mm_freak: When you do FRP, do you use an FRP library, or do you usually do it yourself?
19:57:05 <JoeyA> I've heard about FRP, but don't really understand it.
19:57:07 <cmccann> yeah, the monadic unfolding stuff is my way of writing imperative non-loops in a declarative way and leaving the looping out of the core logic entirely, heh
19:57:08 <mm_freak> JoeyA: i use my own library, netwire
19:57:19 <Sgeo_> I need to bind to an event-based library though
19:57:27 <Sgeo_> So should I still bother turning that into polling?
19:57:31 <mbetter> there was a FRP primer on r/haskell the other day, i think
19:57:45 <mm_freak> Sgeo_: if the ready-made main loop works for you, use it
19:57:54 <cmccann> Sgeo_, if you've got ffi bindings to something that expects event callbacks it's easier to live with that
19:58:35 <Sgeo_> I do think I'll write a function to convert the function that expects a callback into a function that blocks. Does that make sense?
19:58:36 <cmccann> if you can poll for events, like with SDL, I'd suggest doing that
19:58:59 <JoeyA> mbetter: This? http://alfredodinapoli.wordpress.com/2011/12/24/functional-reactive-programming-kick-starter-guide/
19:59:06 <Sgeo_> So I can have a thread that blocks waiting for XYZ, for instance
19:59:47 <cmccann> Sgeo_, be careful with threading, a lot of foreign libraries can get cranky about that
19:59:59 <Sgeo_> Including this one, as a matter of fact
20:00:09 <Sgeo_> But I _think_ I understand exactly how it gets cranky about it
20:00:32 <cmccann> if the foreign library expects to run in a single thread I really encourage humoring it unless you're confident you know how it will react
20:00:43 <cmccann> because if you're wrong that's going to be hellish to debug
20:00:46 <cmccann> in my experience
20:00:57 <mm_freak> JoeyA: if you've never worked with FRP before, first you need to choose one of the two main approaches to FRP in haskell:  behavior-based FRP and arrowized FRP
20:01:05 <Sgeo_> That doesn't mean I can't make a binding that hides the details of it running in one thread
20:01:21 <cmccann> Sgeo_, yeah, though that can get pretty elaborate
20:01:33 <mm_freak> netwire is AFRP and is quite advanced…  it's actually easy to use, but without documentation it can make your brain hurt
20:01:35 <cmccann> it's a matter of how much effort you want to spend working around the library
20:03:08 <Axman6> mbetter: http://alfredodinapoli.wordpress.com/2011/12/24/functional-reactive-programming-kick-starter-guide/ that one? (i literally started reading it 5 minutes ago)
20:03:22 <Axman6> uh, yeah, JoeyA already beat me...
20:03:34 <mbetter> that's the one
20:03:34 <mm_freak> just never look into the haddock documentation of the Control.Wire.Types module =)
20:07:16 <joshuajcheek> Is there an intuitive reason that `name <- getLine` coerces getLine's type from 'IO String' to just 'String' but if I try to use getLine directly that it has the wrong type e.g. `"hello: " ++ getLine`? (meaning if it's just "implementation details leaking out" then I can memorize when to do what, but if there's a good reason then I'd like to understand it)
20:07:35 <mike-burns> That didn't coerce anything.
20:07:44 <mike-burns> :t (>>=)
20:07:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
20:08:20 <mike-burns> do { name -> getLine ; return name }   is the same as  getLine >>= \name -> return name
20:08:34 <Axman6> <-*
20:08:42 <mike-burns> Hah, yes.
20:08:52 <mm_freak> joshuajcheek: note that you can use "<-" only in do-notation…  it's a convenience construct to compose an action from smaller actions and translates to applications of (>>=)
20:09:17 <ksf> why does the haskellwiki cookie me even when I'm not logged in?
20:09:19 <Axman6> joshuajcheek: there's no coercing going on. you need to understand the type of >>= for it to make sense...
20:09:32 <mm_freak> joshuajcheek: IO String is the type for an action that, when run, results in a String…  and the "<-" gives its result a name
20:09:40 <mm_freak> its result is of type String
20:10:05 <parcs`> joshuajcheek: what tutorial are you reading?
20:10:15 <mm_freak> ksf: most web applications do that
20:10:32 <mbetter> one of my beefs with a lot of tutorials is that they use do notation before >>= and return are fully explained
20:10:43 <ksf> ...well, it just suceeded in not getting automatically indexed by my yacy proxy.
20:10:47 <mm_freak> mbetter: i think there is nothing wrong with that
20:10:57 <joshuajcheek> parcs`: Simultaneously reading Learn You a Haskell and a Gentle Guide to Haskell 98. Already went through tryhaskell.org
20:11:04 <ksf> you don't need to cookie the whole page to do anything you want to do for non-logged in users.
20:11:37 <mbetter> mm_freak: i guess, but i think it made me think i understood more than i actually did
20:11:58 <mm_freak> ksf: many web apps and frameworks set a session cookie unconditionally, because conditionalizing would be additional programming effort
20:12:11 <mm_freak> ksf: in fact, that's what i do, too
20:12:32 <mm_freak> mbetter: understanding do-notation is equivalent to understanding (>>=)
20:12:54 <mm_freak> (without syntactic extensions like DoRec)
20:13:12 <mm_freak> (and disregarding the minor "fail" rule)
20:13:33 <mbetter> mm_freak: but without the explicit (>>=), it isn't obvious to beginners that there's something else going on
20:13:44 <mm_freak> mbetter: it doesn't have to be
20:13:49 <mike-burns> But they seldom need to know, too.
20:14:02 <mm_freak> no C++ programmer really understands what's going on in C++ ;)
20:14:11 <mike-burns> do-notation is also a nice imperative programming language.
20:14:17 <mm_freak> yet they write large applications in it
20:14:17 <parcs`> joshuajcheek: ah, LYAH will eventually fully explain 'do' notation fully
20:14:30 <ksf> why would one ever set a cookie before logging in?
20:14:32 <mike-burns> Though the errors make no sense without understanding what's going on.
20:14:37 <mike-burns> ksf: Because it's easier that way.
20:14:51 <mbetter> mike-burns: until you run into what joshuajcheek is currently running into
20:14:57 <ksf> if you want to set a cookie for tracking, use a 1x1 image.
20:14:57 <mike-burns> mbetter: Yup.
20:15:04 <mm_freak> ksf: ultimate destinations, for example
20:15:24 <mm_freak> ksf: a site might ask you to fill out a form and then return you to the origin URL
20:15:30 <ksf> the thing is that cookies mean that it's dynamic content.
20:15:42 <mike-burns> Yeah, what is the actual problem ksf ?
20:15:46 <ksf> crawlers have to be pessimistic, there
20:15:52 <mm_freak> not at all…  cookies mean that the site stores something locally, nothing more, nothing less
20:15:59 <mm_freak> everything else is application-specific, including sessions
20:16:19 <ksf> yeah but the crawler doesn't know that you aren't using the cookie to make the site dynamic.
20:16:31 <mm_freak> it doesn't have to
20:16:44 <mike-burns> Are you claiming that crawlers skip sites that set cookies?
20:16:48 <ksf> well, of course not. it can just refuse to index you anyway.
20:16:55 <mbetter> a cookie just means state
20:16:56 <mm_freak> why would it?
20:17:09 <ksf> ...not pages setting cookies, but those *reading* them.
20:17:19 <mm_freak> all pages read cookies
20:17:26 <mbetter> cookies are always sent
20:17:30 <mbetter> on every request
20:18:00 <mike-burns> ksf: Are you writing a bot?
20:18:04 <mike-burns> Er, crawler?
20:18:33 <ksf> nope, I looked at the reject-index log of my yacy proxy.
20:18:51 <mm_freak> the server does not ask for the stored cookies…  it receives them unconditionally, whenever a page is visited that has the cookie in scope
20:18:54 <mbetter> a bot that doesn't accept cookies isn't going to know that a server may return different content based on a cookie
20:18:59 <ksf> (which is a p2p search engine)
20:20:05 <ksf> well... yacy sure would have to re-fetch the site without any cookies set to index it. because you *could* mess with the contents.
20:20:31 <ksf> ...and I wouldn't want to put any pages I access with a login cookie into the global index.
20:20:36 <mm_freak> a crawler which makes this distinction through cookies is broken
20:20:59 <ksf> it's a proxy. the crawler doesn't send cookies, so it doesn't have to distinguish.
20:21:17 <ksf> there's a lot of non-cookie sites out there, though.
20:21:31 <mm_freak> most of them static HTML =)
20:21:55 <ksf> well, but newspapers sure track people around.
20:22:16 <mm_freak> which newspaper doesn't set a session cookie at least?
20:22:22 <ksf> ...a cookie on a separate domain.
20:22:26 <Sgeo_> Considering that the thing that makes the library not type-safe is also the clinically insane way it wants arguments to functions and return stuff from functions
20:24:18 <ksf> taz.de, at least.
20:24:41 <mm_freak> note also that most sites don't need to track users across sites, so tracking via session is enough for them
20:25:04 <mbetter> facebook being a noteable exception
20:25:18 <mm_freak> indeed, taz.de doesn't set a session cookie unconditionally, but most sites do
20:25:22 * ksf blackholed that kraken.
20:25:36 <mm_freak> the common web frameworks do that, unless you explicitly tell them not to
20:25:54 <mike-burns> Patches welcome.
20:26:25 <mm_freak> patches for what?
20:26:47 <ksf> what I also noticed is that having a proxy actually speeds up browsing considerably.
20:27:05 <ksf> I've got *no* idea why firefox isn't smart enough on its own.
20:27:39 <mm_freak> ksf: a multi-user proxy surely speeds up the browsing, when the sites overlap
20:28:03 <ksf> also loading pages of the same domain, due to cached scripts, images etc.
20:28:21 <mm_freak> btw, firefox /is/ smart enough to do that ;)
20:28:46 <ksf> it does'nt feel like it is.
20:29:28 <mm_freak> but it can't predict where you want to go next, and also the proxy server has a constant speed, while without a proxy your request speed depends on the target server
20:29:54 <mm_freak> if a site is written with that in mind, firefox actually even does prefetching
20:30:35 <ksf> well, let's see how it works out, I'm still undecided on using yacy as a proxy.
20:30:46 <mbetter> my beef with firefox at the moment is that it keeps decoded images for the entire page in memory
20:31:39 <mbetter> chrome will toss the decoded bitmap when you scroll away
20:31:48 <ksf> what it does pretty well already is search, though.
20:32:30 <mm_freak> ksf: most providers provide an own proxy server for their users
20:32:36 <mm_freak> t-com does, for example
20:32:45 <mm_freak> i've used it when i was a t-com customer
20:34:07 <ksf> actually, haskell.org could go ahead and index itself. would stop me from crawling it ;)
20:43:32 <MasterPrime> any minecraftian devs in here?
20:44:41 <mbetter> lovecraftian, maybe
20:45:11 <MasterPrime> oh. well there's a dead haskell project that I'd like to see updated but I don't know haskell. frankly, it scares me.
20:45:19 <mbetter> what project
20:45:21 <mbetter> ?
20:45:24 <cmccann> fun fact, the implementation of unsafePerformIO was transcribed directly from the necronomicon
20:45:53 <MasterPrime> mbetter: https://github.com/FalconNL/mc2obj
20:46:46 <cmccann> MasterPrime, revived in what way
20:47:00 <cmccann> new features, or just dealing with stuff getting out of date
20:47:06 <mbetter> wow, that looks somewhat complicated
20:47:19 <MasterPrime> it's just out of date.
20:47:21 <MasterPrime> not by much.
20:47:30 <MasterPrime> only 1 release and they didn't add a whole lot to it.
20:47:48 <rwbarton> people here can probably help with getting it to build with current GHC, if it doesn't already
20:48:09 <rwbarton> though the last commit is from only two months ago so that might not be a concern
20:48:11 <MasterPrime> actually it's a "doing" thing. I know absolutely nothing about haskell.
20:48:11 <cmccann> why not learn enough Haskell to fix it? doesn't look too complicated
20:48:18 <MasterPrime> haskell is scary.
20:48:52 <cmccann> plenty of xmonad users with little haskell knowledge seem to get by
20:48:59 <cmccann> based on the occasional questions we get in here
20:49:00 <mbetter> MasterPrime: a monad is just a monoid in the category of endofunctors, what's the problem?
20:49:08 <cmccann> mbetter, :P
20:49:29 <MasterPrime> is there an english haskell channel around here?
20:49:49 * Sgeo_ doesn't see any Esperanto spoken in here.
20:50:59 <MasterPrime> I'm not a coder in any sense of the word. I can do your basic HTML and CSS. I can read and understand C and java and can visualize the logical structure of the languages. I have no idea what's happening in haskell.
20:51:07 <mzero> MasterPrime: no need to be scared of it anymore - many people have done a great deal to make it much more approachable
20:52:30 <MasterPrime> so what you're saying is my lazy attempts to not learn haskell and see if I can get a bunch of people on the internet to do it are going to fail and I'll just need to nut up and do it myself?
20:52:36 <mzero> MasterPrime: get a taste for it with this video: http://www.youtube.com/watch?v=b9FagOVqxmI
20:53:32 <mbetter> mzero: i love that video, that's what got me started with haskell
20:53:49 <mzero> oh - excellent (since that's me in that video!)
20:54:16 <mbetter> ah, you're mark! thank you!
20:54:24 <mzero> welcome!
20:54:26 <MasterPrime> you work at google?
20:55:00 <mzero> yup
20:55:01 <ksf> I found it to be completely underwhelming, but then I already can code haskell
20:55:35 <MasterPrime> before I continue this video, you should tell someone to give us more information on the google fiber. I live in KC and I am wanting it soooooo hard.
20:56:10 <mzero> ksf, indeed, you aren't the target audience!
20:58:01 <mzero> MasterPrime: all I can point you to is the public web page ( http://www.google.com/fiber/kansascity/index.html ) and blog ( http://googlefiberblog.blogspot.com/ ) --- I work in security research, and wouldn't know where to begin!
20:58:29 <MasterPrime> I got those. There's just been no updates forever.
20:58:57 <Axman6> MasterPrime: then take it up with the people who can do something about it, in a forum that's more appropriate
21:04:12 <mbetter> i wish i didn't use Text.JSON when i started this project, i've gotta go and convert the whole mess to Aeson
21:09:00 <MasterPrime> I got work early so i'm gonna go to bed now. I'm gonna watch this video and try to pick up and update this project. I'll be back but I'm warning you, I question everything.
21:09:27 <mzero> great - we'll be here
21:09:44 <mzero> welcome to the start of a really fun journey
21:10:32 <cmccann> MasterPrime, Haskell questions on Stack Overflow tend to get answered pretty quickly, too
21:11:05 <MasterPrime> I've noticed a lot of questions on SO get answered pretty quickly. I just like lookin through code there.
21:11:23 * cmccann needs an RSS feed just to have a chance to answer before someone else does :[
21:12:27 <MasterPrime> I don't think I'm in danger of knowing something just yet.
21:12:59 <mbetter> i've got a UTF-8 encoded string stored as a ByteString. Is there any way to get it to Text without going through String?
21:13:42 <mzero> decodeUtf8
21:13:51 <mzero> decodeASCII :: ByteString -> Text
21:13:58 <mzero> sorry
21:13:58 <mzero> decodeUtf8 :: ByteString -> Text
21:14:02 <mzero> in Data.Text.Encoding
21:14:18 <mbetter> mzero: thanks, i don't know how i missed that
21:14:34 <mzero> @hoogle ByteString -> Text
21:14:34 <lambdabot> Data.Text.Encoding decodeASCII :: ByteString -> Text
21:14:35 <lambdabot> Data.Text.Lazy.Encoding decodeASCII :: ByteString -> Text
21:14:35 <lambdabot> Data.Text.Encoding decodeUtf16BE :: ByteString -> Text
21:14:53 <mzero> don't know how hoogle missed it either -- probably the fourth entry
21:15:02 <rwbarton> @hoogle+
21:15:02 <lambdabot> Data.Text.Lazy.Encoding decodeUtf16BE :: ByteString -> Text
21:15:02 <lambdabot> Data.Text.Encoding decodeUtf16LE :: ByteString -> Text
21:15:02 <lambdabot> Data.Text.Lazy.Encoding decodeUtf16LE :: ByteString -> Text
21:15:20 <mzero> @hoogle+
21:15:21 <lambdabot> Data.Text.Encoding decodeUtf32BE :: ByteString -> Text
21:15:21 <lambdabot> Data.Text.Lazy.Encoding decodeUtf32BE :: ByteString -> Text
21:15:21 <lambdabot> Data.Text.Encoding decodeUtf32LE :: ByteString -> Text
21:15:26 <mbetter> my results are really hit and miss with hoogle
21:15:42 <rwbarton> well "16" < "32" < "8"
21:16:43 <rwbarton> @hoogle+
21:16:44 <lambdabot> Data.Text.Lazy.Encoding decodeUtf32LE :: ByteString -> Text
21:16:44 <lambdabot> Data.Text.Encoding decodeUtf8 :: ByteString -> Text
21:16:44 <lambdabot> Data.Text.Lazy.Encoding decodeUtf8 :: ByteString -> Text
21:16:47 <rwbarton> hooray!
21:16:49 <mzero> see, they should have named the encoding  AAATheBestYo  rather than UTF8
21:17:31 <mzero> I was just lamenting that with the demise of paper phonebooks, there is no incentive to name your business AAAAAAPlumbers
21:18:19 <mbetter> mzero: a modification to pagerank would fix that right up
21:18:36 <mzero> i'll let them know back at the farm
21:23:07 * hackagebot postgresql-simple 0.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.0 (LeonSmith)
21:27:37 <miggyx> is Haskell a good fit for a high performance server that needs to do a lot of calculations based on network requests?  Not a troll question :)
21:28:06 <lpsmith> depends.   It's probably a lot better fit than say,  Python, Perl or PHP
21:28:25 <JoeyA> http://themonadreader.files.wordpress.com/2011/10/issue19.pdf
21:29:04 <JoeyA> ^ One article describes a fast web server written in Haskell.
21:29:31 <miggyx> JoeyA: unfortunately I can't get to wordpress.com from here :/
21:30:20 <miggyx> basically it will have some long running work - an update will come in and it will recalculate stuff but at the same time needs to respond to individual requests - and stop calculating if a new update comes in that makes a previous update its calculating with obsolete. Easy in Java or C - but no idea where to start in Haskell
21:30:28 <miggyx> so just thought I'd ask whether it was a sane idea :)
21:30:57 <mzero> sounds great to me - Haskell should have all the machinery to do this easy
21:33:54 <ddarius> If it's easy in Java or C, it will be even easier in Haskell.
21:34:10 <ddarius> Well, for someone who knows Haskell.
21:34:57 <ddarius> Of course, if it is easy in Java or C and you already know Java or C and you don't know Haskell, why not do it in Java or C unless the purpose is to learn Haskell?
21:35:25 <Enigmagic> IORefs to the rescue!
21:35:39 <Enigmagic> making Haskell easy since 1996
21:36:02 <Enigmagic> unless you're using arrays
21:36:17 * ski stares blankly
21:36:52 <ddarius> ski has been doing that a lot of late.
21:36:58 <Enigmagic> i didn't notice any comments on <ddarius> If it's easy in Java or C, it will be even easier in Haskell.  <ddarius> Well, for someone who knows Haskell.
21:37:59 <Enigmagic> i've noticed that my day job is easier now that i've been doing it for a while
21:38:05 * ski wonders what shape to make the next ginger cookie in, after the Akraa' Neonor
21:40:13 <monochrom> make a lambda shape
21:52:13 <miggyx> ddarius: There are many reasons to learn Haskell :)
21:54:02 <miggyx> especially when dealing with finance and stuff like that. I just hope I can make something work in Haskell without spending 6 months on it first :)
22:03:09 * hackagebot couchdb-enumerator 0.3.5 - Couch DB client library using http-enumerator and aeson  http://hackage.haskell.org/package/couchdb-enumerator-0.3.5 (JohnLenz)
22:19:04 <mm_freak> is there a darcs/git/whatever version of the stm library?
22:19:11 <mm_freak> hackage doesn't link to one
22:37:41 <Darkone> quick, utterly stupid question, but it's late, and I figure it would be easier to use haskell for this than try and cludge it together in python: trying to map a function over a list (string, actually) that takes a char, and converts it into a string
22:38:01 <ivanm> Darkone: so what's the question? :p
22:38:03 <Axman6> > map show "Hello"
22:38:04 <lambdabot>   ["'H'","'e'","'l'","'l'","'o'"]
22:38:11 * ivanm randomly guesses Darkone wants concatMap
22:38:21 <ivanm> > concatMap (:[]) "hello"
22:38:23 <lambdabot>   "hello"
22:38:31 <ivanm> > concatMap show "hello"
22:38:32 <lambdabot>   "'h''e''l''l''o'"
22:38:38 <Axman6> > map return "Hello" :: [String]
22:38:38 <lambdabot>   ["H","e","l","l","o"]
22:39:33 <jdavis> I am on page 199 of RWH, "Regular Expressions in Haskell". I can't reproduce what I see in the page, and the type errors are a little confusing. What do I need to import to make that work? Or is it outdated somehow? Can someone explain the type errors I'm seeing here? http://pastebin.com/c3GJuSe0
22:39:35 <mauke> The paste c3GJuSe0 has been copied to http://hpaste.org/55868
22:39:45 <Darkone> So, uhhh, I'm just getting errors everywhere. I'm using the Data.Map module to use a keymap to store the associations.... okay, screw this, just going to pastebin the code and the error. It's too late and I can't make words come out.
22:40:50 <Darkone> I think it's something obvious, and maybe it's supposed to be that I'm supposed to be extracting something from a maybe or using a different function but graaaaah
22:40:57 <ivanm> jdavis: the library has changed a bit since RWH came out
22:41:22 <ivanm> jdavis: so the Bool option might not be available anymore
22:41:47 <jdavis> ivanm: OK. Can you please explain how to read that error message?
22:42:18 <ivanm> jdavis: so =~ is an overloaded operator operating on a type class
22:42:29 <jdavis> ivanm, I'm not so interested in regexes, but I would like to see some similar examples of annotating the return type to pick the function.
22:42:31 <ivanm> and there's no instance such that the returned value is a Bool
22:42:42 <ivanm> > return 3 :: Maybe Int
22:42:43 <lambdabot>   Just 3
22:42:46 <eyebloom> Is there a better way to return multiple value from a function than wrapping them in tuples?
22:42:47 <ivanm> > return 3 :: [Int]
22:42:48 <lambdabot>   [3]
22:42:52 <ivanm> > return 3 :: Either String Int
22:42:53 <lambdabot>   Right 3
22:43:03 <ivanm> eyebloom: if they're all the same type, use a list
22:43:15 <eyebloom> No different types.
22:43:16 <ivanm> possibly use a custom data type if it's a common grouping of values
22:43:23 <ivanm> otherwise, use tuples
22:43:26 <rwbarton> or if you want to give the various values names, you could introduce a record type
22:43:31 <Darkone> wait
22:43:32 <ivanm> but if you're returning more than 3 values, you're probably doing it wrong
22:43:45 <Darkone> if you run a Map over a string, what's input to the function?
22:43:58 <eyebloom> It's two or 3
22:44:00 <ivanm> (and a specific data type - possibly with records as rwbarton suggests - makes more sense)
22:44:00 <mzero> eyebloom: depends on semantically what you're trying to say the function returns --- if it always returns some fixed number of things and they have "positional meaning" then a tuple is perfect
22:44:10 <ivanm> Darkone: do you mean Map or map ?
22:44:10 <Darkone> That is, "abc" would input a, b, and c. Would those be strings or chars?
22:44:13 <Darkone> map
22:44:15 <jdavis> ivanm: OK, thank you. I guess I'm having trouble with the complex type class constraint in the type of +~
22:44:17 <Darkone> lowercaase
22:44:21 <Darkone> sorry
22:44:21 <jdavis> =~ I mean
22:44:25 <mzero> if, on the other hand, you mean the function returns several things, (wether fixed or no), then list may be more appropriate
22:44:26 <ivanm> jdavis: yeah, it's a bit heavy
22:44:41 <ski> Darkone : characters
22:44:45 <ivanm> Darkone: the individual characters within a String are Chars
22:44:46 <rwbarton> jdavis: it's essentially an implementation detail which unfortunately is exposed in the compiler error messages
22:44:49 <eyebloom> Tuples are very "pythonic". Curry is very Haskellic.
22:44:50 <mzero> further more, you may really prefer a small data type for the return
22:44:57 <ivanm> eyebloom: huh?
22:45:01 <ivanm> eyebloom: for input parameters, yes
22:45:15 <ivanm> for output parameters, you can't really do it any other way
22:45:31 <jdavis> rwbarton, ivanm, ok, thank you. I'll file this as "I'll know when I start writing my own typeclasses" I suppose?
22:45:51 <ivanm> jdavis: nah, it's just that that typeclass is rather hairy
22:45:53 <eyebloom> Anonymous function with curried values.
22:46:22 <rwbarton> I mean, I just read that message as "x =~ y can't have type Bool".  Beyond that the details are not interesting unless you're an implementor of the regex package.
22:46:23 <mzero> eyebloom: ? what?   perhaps you should describe what the function returns?
22:46:34 <ivanm> rwbarton: agreed
22:46:35 <jdavis> ivanm: is that just a series of constructors?
22:46:41 <eyebloom> It's more a question of style.
22:47:05 <jdavis> ivanm: let me rephrase, one second
22:47:08 <ivanm> jdavis: the regex stuff is done to be polymorphic in both the input and output types, which isn't very usual (as it gets complicated and hairy)
22:47:09 <eyebloom> I'm not having trouble, I just think the code is ugly.
22:47:13 <ski> eyebloom : if you really want, you could use CPS
22:47:16 <ivanm> eyebloom: what code?
22:47:34 <eyebloom> Some code I'm working on.
22:47:46 <ski> paste the code ?
22:47:50 <eyebloom> Sure
22:48:03 <jdavis> ivanm, so are RegexMaker Regex CompOption ExecOption all like composed typeclasses or something? Or are some of those constructors?
22:48:30 <ivanm> jdavis: RegexMaker and RegexContext are classes
22:48:33 <rwbarton> the first word in each one (RegexMaker/RegexContext) are type classes, the rest are types
22:48:42 <ivanm> Regex, CompOption and ExecOption are data types
22:48:53 <ivanm> you can't really compose classes
22:49:14 <hpaste> darkone pasted “ohgodwat” at http://hpaste.org/55869
22:49:17 <jdavis> ivanm: yeah, that's what I thought. But how do you mix data types into a class constraint?
22:49:21 <Darkone> There.
22:49:30 <Darkone> That's the ugly code and the error.
22:49:34 <ivanm> jdavis: by specifying the instances
22:49:44 <hpaste> eyebloom pasted “Some code” at http://hpaste.org/55870
22:49:45 <rwbarton> "RegexMaker Regex CompOption ExecOption [Char]" is the assertion that the 4-tuple of types (Regex, CompOption, ExecOption, [Char]) satisfy the RegexMaker predicate, if you like
22:49:51 <Darkone> because I have no clue how to phrase the question that i need to ask to solve this myself.
22:50:00 <ivanm> Darkone: use mapMaybe from Data.Maybe
22:50:10 <ivanm> but I would suggest you clean your code up first
22:50:10 <rwbarton> meaning someone wrote instance RegexMaker Regex CompOption ExecOption [Char] where ...
22:50:36 <ivanm> and if all your values are Chars, why use Strings in convKey
22:50:43 <ivanm> having explicit types is a good idea
22:50:53 <mzero> several questions, darkone
22:50:56 <Darkone> ivanm, I haven't done anything in haskell in a long time, and it's like, 2am, and it's easier with haskell than python, and uhh
22:51:06 <ivanm> heh
22:51:18 <ivanm> eyebloom: so what's your question actually regarding?
22:51:19 <Darkone> the values are stirngs in case I want to replace with more than one character
22:51:24 <jdavis> rwbarton: Ok, I'm starting to get it. I am past maximum confusion, and it's slowly sinking in.
22:51:26 <mzero> 1) why is convkey Map String String    and not Map Char Char?
22:51:26 <Darkone> Like replacing b with sh
22:51:28 <ski> Darkone : what do you want to do with the `Maybe's ?
22:51:30 <ivanm> though I agree that the current layout of FGL is rather fugly, using 4-tuples for Contexts
22:51:33 <Sgeo_> @hoogle b -> Maybe b -> b
22:51:34 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
22:51:34 <lambdabot> Prelude asTypeOf :: a -> a -> a
22:51:34 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
22:51:46 <Sgeo_> So fromMaybe is just supplying id as the function to maybe, right?
22:51:51 <mzero> 2) What do you want doStuff to return if the input is alphabetic, but not in the convkey ?
22:51:52 <ivanm> Darkone: if you're replacing a Char with a String, it should be Map Char String, not Map String String
22:52:03 <rwbarton> jdavis: however i'm not sure that in this case the issue isn't just that you've not loaded the module which defines some of those instances
22:52:04 <jdavis> rwbarton, ivanm, is there a simpler example that I can try out for a while?
22:52:06 <ivanm> Sgeo_: yup
22:52:10 <ivanm> jdavis: for?
22:52:12 <rwbarton> like Text.Regex.Base.RegexLike perhaps
22:52:16 <eyebloom> ivanm: I'm just asking if stylisticly there is a better way.
22:52:33 <ivanm> eyebloom: which particular bit?
22:52:46 <eyebloom> returning tuples
22:52:46 <ivanm> but I would suggest that your State, etc. be actual data types
22:52:54 <Darkone> oh god I have no clue. I'm just trying to make a thingy that takes a string, makes it lowercase, removes repeated letters, then turns the letters into one or more other letters
22:52:54 <jdavis> ivanm, I don't understand the question, "for" what?
22:53:03 <rwbarton> example of what
22:53:08 <Darkone> Does that make sense?
22:53:08 <ivanm> eyebloom: stylistically, if the types aren't really meant to be grouped together, then use tuples
22:53:09 * hackagebot pqc 0.4.1 - Parallel batch driver for QuickCheck  http://hackage.haskell.org/package/pqc-0.4.1 (KidoTakahiro)
22:53:18 <ivanm> jdavis: what do you want an example of?
22:53:21 <mzero> Darkone - sure it make sense
22:53:35 <eyebloom> Is there any performance difference between data and tuples
22:53:37 <ivanm> Darkone: well, the first bit is: map head . group . map toLower
22:53:57 <ivanm> eyebloom: IIRC, GHC has some optimisations on using tuples for params to functions...
22:54:02 <jdavis> ivanm, rwbarton: an instance of a type class that has more type constructors in it, that would lead to something like (SomeClass SomeConstructor1 SomeConstructor2 a) => ...
22:54:15 <ivanm> eyebloom: otherwise, I've found that if you're just replacing values, data types often use less memory rather than unpacking and repacking tuples
22:54:18 <rwbarton> so, a multiparameter type class
22:54:24 <Darkone> ivanm, I had that, just uglier.
22:54:27 <ivanm> (if you're using record syntax rather than unpacking and repacking the data type)
22:54:42 <mzero> Darkone --  you'll need    concatMap destuff    because dosutff is going to map each character to a string, but you want them all smooched together in the end
22:54:48 <ivanm> jdavis: monad transformers?
22:54:49 <mzero> then the last bit of the puzzle is that
22:54:56 <mzero> destuff should be   Char -> String
22:55:03 <ivanm> mzero: he's using Maybe, so mapMaybe makes sense
22:55:05 <mzero> not Char -> Maybe String
22:55:19 <jdavis> ivanm: ok, I can look into that.
22:55:24 <mzero> no, I suspect what he wants is that if the character isn't in the Map, then just return it as is
22:55:27 <ivanm> mzero: or else do "fromMaybe []"
22:55:32 * ski wonders whether the constraint `DynGraph gr' really should be in the type signature `Grow'
22:55:34 <eyebloom> ivanm: So tuples are more memory but better performance and data vice versa?
22:55:54 <Darkone> mzero, yes. the Map.lookup function returns a maybe value
22:56:01 <ivanm> eyebloom: performance is a bit tricky, it's some fancy newtype trick or something
22:56:09 <mzero> I know - but what do you want destuff to return if the letter isn't in the map?
22:56:11 <ivanm> eyebloom: if you just happen to be returning two values, use a tuple
22:56:19 <mzero> do you want to drop that letter, or keep it?
22:56:24 <ivanm> if you're going to keep that data grouped together and it's a common grouping, use a data type
22:56:36 <Darkone> mzero, just return the letter as is.
22:56:41 <mzero> exactly
22:56:45 <eyebloom> How about currying values into a function, how does that compare?
22:56:47 <ski> eyebloom : also, i suspect that the state monad could help
22:56:56 <mzero> so destuff shouldn't return Maybe String, just String
22:57:01 <Darkone> So it will go through, and only change letters that I have in the list.
22:57:25 <Darkone> mzero, okay, then do I use that fromMaybe thing on    Map.lookup ...   ?
22:57:28 <ivanm> eyebloom: it just means that you can have a function "f :: a -> b -> c" and use "uncurry f" rather than explicitly unpacking values yourself
22:57:31 <Darkone> I assume?
22:57:35 <jdavis> ivanm, rwbarton, thank you. After reading the part about defining instances I think I understand, or at least understand where to look.
22:57:47 <ivanm> stylistically, it's prefered not to take tuples as inputs unless they *should* be grouped together
22:57:50 <mzero> try     destuff x = fromMaybe [x] (Map.lookup [x] convkey)
22:57:55 <eyebloom> ski: Thanks, work in progress, I'm avoid monads and typeclasses until it's further along.
22:58:04 <mzero> mind you, I'd change the map to be Map Char String....
22:58:24 <mzero> then it would be   destuff x = fromMaybe [x] $ Map.lookup x convkey
22:58:26 <ivanm> Darkone: but have the Map be "Map Char String" as your current approach can't replace sub-strings anyway; that way your lookup will only be "Map.lookup x convkey"
22:58:38 <mzero> now destuff :: Char -> String
22:58:48 <eyebloom> ivanm: What do yo mean by should?
22:59:21 <mzero> so on line 16, you want just    putStrLn $ concatMap destuff $ map head $ group $ map toLower l
22:59:25 <ivanm> eyebloom: depends on the context: sometimes it makes more sense when writing a function that you have two values that belong together
22:59:52 <Darkone> mzero, the one you listed worked perfectly.
22:59:56 <ivanm> and if the only time that function is used is with values that are tupled anyway (typically mapping over a [(a,b)] list or something) then you might as well make that explicit
23:00:00 <mzero> or   putStrLn $ concaMap (doStuff . head) $ group $ map toLower l
23:00:06 <Darkone> The 'destuff x = fromMaybe [x] (Map.lookup [x] convkey)'
23:00:11 <mzero> sure
23:00:12 <Darkone> well, dostuff*
23:00:38 <Darkone> and that, I made it slightly less ugly, if out of habit. dammit I need to go sleep :(
23:00:39 <mzero> but notice that you're taking and input Char and making it a one character string with  [x]    --- and all the keys in your map are just one character strings
23:01:00 <Darkone> good point, I know
23:01:07 <mzero> so you could make the map   [('a', "i"), ('b', "k"), .....   notice the use of Char for the key and String for the value
23:01:18 <Darkone> it was a kludge because this is just a quick timesaver to avoid ahving to convert things by hand
23:01:20 <ski> eyebloom : you might find <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html> interesting
23:01:25 <mzero> then you wouldn't need to string-ify the x in Map.lookup
23:01:45 <Darkone> and I didn't want to go through each key to make it into a char
23:01:58 <Darkone> tl;dr I was lazy there
23:01:58 <mzero> mind you - I notice that your map is really Char to Char --- there are no multiple character replacements
23:02:12 <ivanm> mzero: he said down the track that could change
23:02:25 <Darkone> Yes, but I wanted to be able to do something like a to ar, or the such
23:02:26 <mzero> if that were so, I'd be tempted to do    convkey = Map.fromList $ zip "abcef..." "iksfahj..."
23:02:30 <ivanm> if you ever really need String -> String, using an actual parsing library would probably make more sense
23:02:33 <Darkone> And down the track, it's done now, really.
23:02:40 <eyebloom> Oh thanks, I'm down with M. I just avoid putting into code until the code is further along.
23:02:41 <mzero> I know - just sayin
23:02:42 <Darkone> That's all I wanted to doo.
23:03:03 <mzero> enjoy
23:03:10 <Darkone> thanks, you two.
23:03:31 <Darkone> now I can sleep and not think about this crud all night
23:03:38 <mzero> heh
23:03:40 <mzero> ngith all
23:03:54 <ski> eyebloom : anyway, i doubt you really want `type Grow gr a b = DynGraph gr => ...'
23:04:17 <Darkone> Just toher crud, like the impossible task of balancing powers in a P&P system I'm working on ._.
23:04:41 <Darkone> And making a simple system that can do not-simple things, and blargh.
23:04:49 <ski> (presumably you want to express a presupposition here ..)
23:04:54 <Darkone> Night.
23:05:22 <eyebloom> ski: Not eventually IMHO but it's helpful when you are trying to understand something, to see all the plumbing... and that's where I'm at with this particular code.
23:05:45 <ski> eyebloom : yeah, but i suspect that doesn't do what you think it does
23:05:59 <ski> (or maybe that's better expressed conversely)
23:06:11 <eyebloom> ?
23:07:09 <eyebloom> grow might not have been the right name.
23:07:20 <ski> `type Grow gr a b = (DynGraph gr) => gr a b -> Context a b -> gr a b' doesn't meant that : `Grow gr a b' basically means, `gr a b -> Context a b -> gr a b'; oh and btw, i want `DynGraph gr' to always be the case when using this
23:07:30 <ski> (s/meant/mean/)
23:09:12 <eyebloom> I'm still not understanding you? gr is a type variable because I'm experimenting with different internal representations.
23:10:52 <ski> looking at
23:10:54 <ski>   dfs :: (TileGraph gr, DynGraph gr) => Push gr a b a' b'
23:11:02 <ski> this is an abbreviation of
23:11:03 <rwbarton> he's talking about what it means to put that (DynGraph gr) => there
23:11:21 <eyebloom> Yes I'm using RankNTypes
23:12:35 <eyebloom> It has to be a Dyngraph because it uses & operator.
23:13:00 <ski>   dfs :: (TileGraph gr, DynGraph gr) => (DynGraph gr => gr a b -> Context a b -> gr a b) -> (DynGraph gr => gr a' b' -> Context a' b' -> gr a' b') -> Hold -> gr a b -> (gr a' b', [Node]) -> (Context a b, Context a b, [Node]) -> (gr a b, (gr a' b', [Node]))
23:13:07 <ski> but i suspect you really wanted
23:13:19 <ski>   dfs :: (TileGraph gr, DynGraph gr) => (gr a b -> Context a b -> gr a b) -> (gr a' b' -> Context a' b' -> gr a' b') -> Hold -> gr a b -> (gr a' b', [Node]) -> (Context a b, Context a b, [Node]) -> (gr a b, (gr a' b', [Node]))
23:13:51 <eyebloom> Oh right. That may be a relic from some recent refactoring.
23:14:03 <eyebloom> I'm not sure that the compiler cares though.
23:14:13 <ski> eyebloom : afaics, apart from the `DynGraph gr => ..' in the type signature, you don't seem to be using `RankNTypes'
23:14:40 <ski> the point isn't whether the compiler cares. the point is whether you have expressed what you thought you expressed
23:15:39 <eyebloom> What's the difference?
23:16:14 <rwbarton> is a type like (C x => x) -> x legal in haskell 98?
23:16:20 <ski> rwbarton : no
23:16:39 <ski> in this case, probably just that it will pass around more dictionaries than it would have to otherwise
23:17:17 <eyebloom> Ah, good point.
23:18:59 <ski> i would suggest turning off `RankNTypes', unless you know that it is the kind of thing you want to do
23:19:36 <eyebloom> I think in this case it's just either passing a Graph dictionary or a Dyngraph dictionary.
23:19:52 <eyebloom> Which is probably about the same penalty.
23:31:58 <ncs> i have created a module (say module Test) in which i have defined a datatype. now i want to use that module in a new file but import Test does not import the datatype in the new file.. any ideas?
23:38:39 <NihilistDandy> newsham: Are you Tim Newsham?
23:43:10 * hackagebot xturtle 0.0.1 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.0.1 (YoshikuniJujo)
23:57:27 <savage_> whats up?
23:57:50 <Ke> I guess ghc optimizes foldM_ x y [0..hugeInt] in a reasonable manner?
