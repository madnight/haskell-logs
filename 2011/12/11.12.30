00:01:54 <JuanDaugherty> yello savage_
00:03:36 <savage_> how long have you been coding with haskell?
00:07:59 <mm_freak> Ke: i don't think so, but you can count on the laziness of the list
00:08:22 <mm_freak> so it at least runs in O(1) memory in principle
00:08:44 <mm_freak> if you want more speed, perform explicit recursion
00:09:30 <Ke> well it's not really about milliseconds, as long as the memory use is not O(n)
00:10:08 <Ke> ie. as long as it works for arbitrarily large hugeInt
00:10:29 <mm_freak> the memory use will be O(1), if your list is not shared
00:10:43 <Ke> well it's a literal here
00:10:50 <mm_freak> so if you write a list literal, there shouldn't be a problem
00:11:07 <Ke> ok thanks
00:11:07 <GorDonFreeMan> http://www.snorgtees.com/t-shirts/if-zombies-chase-us
00:11:08 <GorDonFreeMan> :)
00:11:14 <Ke> actually that is easy to test
00:11:37 <GorDonFreeMan> my preference for coding is C, but it was nice to start out with haskell's logic
00:11:52 <GorDonFreeMan> it gives another aspect to c0ding
00:11:52 <mm_freak> Ke: sure, just use an infinite list =)
00:12:03 <mm_freak> if it keeps allocating memory, you have a problem
00:14:51 <Ke> it seems that ghc doesn't warn about too large Int literals
00:15:38 <mm_freak> it can't really
00:15:48 <mm_freak> fromInteger is an opaque function
00:16:17 <mm_freak> if anything, fromInteger could warn, but only at runtime, and you surely don't want that =)
00:16:37 <Peaker> why not?
00:17:03 <merijn> GorDonFreeMan: After working on a mid-size multithreaded C application for a few months, I really long for haskell development. You never really appreciate referential transparency until you don't have it...
00:17:15 <GorDonFreeMan> my project is now, to maintain functional locig over my C program
00:17:35 <GorDonFreeMan> looks nice, and is small :)
00:17:44 <mm_freak> Peaker: because in some cases it's legitimate to do it
00:17:47 <GorDonFreeMan> also does what i want
00:17:53 <Peaker> it could inline fromInteger when specialized to Int
00:18:00 <Peaker> and warn
00:18:09 <mm_freak> you mean at compile time?
00:18:17 <GorDonFreeMan> merijn<< only hassles with memory allocation
00:18:46 <GorDonFreeMan> ans also :) more difficult multithreading
00:18:54 <merijn> Memory allocation is easy to fix, that's what valgrind is for. Race conditions and lock orders are the bane of my existence
00:19:27 <GorDonFreeMan> actually valgrind always reports leaking to me because i use SDL...
00:19:42 <mm_freak> GorDonFreeMan: i wouldn't write a single line of C, unless i absolutely have to…  it's not only that multithreaded code gives you headache, but also you just can't convert all design patterns from haskell to C
00:20:02 <mm_freak> i don't see the benefit of C over haskell
00:20:17 <mm_freak> except perhaps for embedded programming, but i'm an application programmer
00:20:20 <GorDonFreeMan> mm_freak<< currently, the benefit for me, is working, vs not working :)
00:20:39 <GorDonFreeMan> also i have a realtime project too
00:20:51 <mm_freak> GorDonFreeMan: yeah, after spending 80% of development time for debugging ;)
00:21:07 <GorDonFreeMan> i have all the time i want
00:21:09 <merijn> mm_freak: My advisor doesn't know haskell and would have a heartattack if I replaced his C code base with a haskell implementation, is that a valid benefit? :p
00:21:24 <Ke> mm_freak: there is no abusive runtime in C
00:21:27 <Ke> =oP
00:21:32 <mm_freak> merijn: why don't you tell him about haskell?
00:21:35 <GorDonFreeMan> btw
00:21:36 <GorDonFreeMan> Timer resolution: 1 ns
00:21:36 <GorDonFreeMan> clock_gettime
00:21:36 <GorDonFreeMan>  nothing took: 8.380000000e-07 seconds
00:21:40 <mm_freak> Ke: abusive?
00:21:43 <merijn> Although, in hindsight I would've been more productive if I had
00:21:44 <GorDonFreeMan> smartdelay 1s took: 1.000000279 seconds
00:21:51 <GorDonFreeMan> can you do this in haskell?
00:21:54 <Ke> ie. you can eg. seccomp C
00:22:09 <GorDonFreeMan> usleep(+0.100000000 s) took: 0.100061042 seconds
00:22:11 <Ke> anything that can't be seccomped is abusive =oP
00:22:23 <merijn> mm_freak: In less than a month I graduate and while he'll be paying me he won't be able to grade me or influence my degree, so that seems like a better time to attempt that conversation :p
00:22:50 <mm_freak> GorDonFreeMan: not to that precision, but i'm getting into the tens of microseconds range
00:23:04 <GorDonFreeMan> mm_freak<< and what about random glitches?
00:23:19 <mm_freak> merijn: honestly i'd just do it
00:23:42 <GorDonFreeMan> also memory is slooow
00:24:02 <mm_freak> GorDonFreeMan: i don't have much experience with real-time coding…  my FRP system performs with well over 600k FPS, which is enough for my purposes
00:24:05 <merijn> mm_freak: Already replaced his version control and the licensing, gotta pace my battles ;)
00:24:23 <merijn> GorDonFreeMan: Random glitches are, by definition, random. So why worry about them
00:24:29 <GorDonFreeMan> mm_freak<< whyt do you mean by that?
00:24:40 <GorDonFreeMan> you run GHC code on some FPGA ? or what?
00:24:40 <mm_freak> GorDonFreeMan: by what?
00:24:55 <mm_freak> GorDonFreeMan: on PCs, laptops and servers
00:25:35 <GorDonFreeMan> what hardware is able to do 600k FPS with any loop?
00:26:06 <mm_freak> GorDonFreeMan: you are confusing something…  i'm not talking about graphics
00:26:25 <mm_freak> just a loop, which does some busy work, in my case stepping an FRP system
00:27:32 <GorDonFreeMan> hmm, a function call costs on my system 270-870ns ...
00:27:50 <mm_freak> haskell code doesn't compile the same way as C code
00:27:57 <GorDonFreeMan> it"s 2.2GHz amd 64 with 400MHz ddr memory
00:28:29 <mm_freak> well, you can prove it to yourself…  download the netwire library and write a small FRP system…  test it with the 'testWireM' function
00:28:50 <mm_freak> using only the applicative interface you can get well over 2m FPS
00:28:51 <GorDonFreeMan> mm_freak<< so haskell does more advanced code than a c function call?
00:29:28 <mm_freak> in haskell you don't necessarily get CALL/RET…  i don't know what exactly it compiles to, but it's based on thunks and is in principle stackless
00:29:47 <mm_freak> i should say with GHC
00:30:00 <flux> of course, you might not get it on c either :). but maybe haskell is better at optimizing/inlining seemingly indirect calls?
00:30:32 <ski> it needs a stack for knowing what to do after a pattern-match
00:30:42 <Axman6> i believe that GHC doesn't even emit call instructions.
00:30:48 <GorDonFreeMan> well c can do some function parameter passing too in registers, but that is not possible in all cases, but i have noticed that if i use a macro instead a function call i gain 600ns
00:31:18 <mm_freak> ski: even if the pattern has only variables?
00:31:36 <Axman6> GorDonFreeMan: if you're using GCC and mark the function static inline, then it will be basically equivalent to a macro
00:31:51 <GorDonFreeMan> i did that but it ws slower than a macro ;/
00:31:55 <ski> mm_freak : in that case there's no thunks to force, so no
00:32:17 <mm_freak> ski: so it's forcing, not patterns?
00:32:38 <ski> pattern-matching is the main thing forcing a thunk to evaluate
00:32:49 <ski> (there's also `seq', and bang patterns)
00:33:01 <mm_freak> yeah, but does it need the stack for forcing in genereal?
00:33:07 <merijn> flux: In general GHC is just better at optimising period, because haskell's semantics are much more conducive to optimisation then C's semantics
00:33:10 <ski> that doesn't mean that every pattern-match will cause a forcing
00:33:20 <GorDonFreeMan> so, why do you guys don't make a code first work, and then add the super hi tech statistical magic after ?
00:33:30 <GorDonFreeMan> ( i'm thinking about the CABAL thing )
00:33:37 <mm_freak> anyway…  stack operations aren't expensive…  what is expensive is the jump
00:33:38 <ski> generally, you need a stack to remember what to do *after* doing something
00:34:16 <mm_freak> GorDonFreeMan: not sure what you mean
00:34:37 <GorDonFreeMan> ski<< yeah i see, if i'd do hardcore optimization in asm i'd put the return address in a register
00:35:03 <merijn> flux: I remember during compiler class there were tons of optimisations that were mentioned as follows "here we can do optimisation X, but of course that relies on Y not changing, which is not guaranteed by C's semantics. So in practice we can only do it in a very limited set of situations where we know Y can't change."
00:35:10 <mm_freak> GorDonFreeMan: that won't save you…  the jump is expensive
00:35:17 <ski> GorDonFreeMan : that doesn't matter much here -- where do you put the contents of that register, if you want to call a sub-routine ?
00:35:20 <GorDonFreeMan> mm_freak<< well i meant that cabal attempts to count the spaces in the config file... and there is regexp,,.... and it could just match out the options
00:35:21 <mm_freak> i guess haskell code gets a long with less jumps
00:36:11 <ski> (or rather, it only matters that much for subroutines which doesn't call other subroutines, i.e. leaf subroutines)
00:36:12 <GorDonFreeMan> mm_freak<< how about cache misses?
00:36:22 <GorDonFreeMan> larger code will have cache misses
00:36:37 <GorDonFreeMan> that will cause severe penalty
00:37:02 <merijn> Higher level code allows higher level optimisations which may benefit you significantly more than low level optimisations
00:37:25 <ski> (such as loop fusion)
00:37:26 <mm_freak> not sure how it works in modern processors, but i remember that a jump used to abandon the cache altogether
00:37:46 <GorDonFreeMan> you can't just unroll my arbitrary loop and prefetch 100MB code into cpu cache,,,
00:38:15 <mm_freak> i think that the type system and the semantics play a central role in optimizing code…  not relevant to C here, but haskell doesn't emit RTTI, for example
00:38:31 <merijn> I remember this anecdote from an engineer working on a windowing interface (keep in mind, this was 70s-80s) which they wrote entirely in ASM. A competitor wrote it in some different language. The competitors code ended up needlessly refreshing the task bar a couple hundred times a second and other similar inefficient things, but in the end it was still significantly faster than the ASM implementation
00:39:12 <GorDonFreeMan> ok, ASM needs higher skills to do right
00:39:14 <merijn> ski: loop fusion gives me tinglies :)
00:39:22 <GorDonFreeMan> and more advanced macros
00:39:28 <GorDonFreeMan> but you can do anything you want
00:39:44 * ski wonders how to make loop fusion a non-optimization
00:39:59 <merijn> Ok, that's it
00:40:04 <mm_freak> GorDonFreeMan: it's a common misconception that this freedom gives you more speed…  in general a compiler is better than a human at writing machine code
00:40:07 <GorDonFreeMan> look at fasm if you would like to see some advanced asm
00:40:26 <merijn> Once my thesis I'm done I'm going to write a paper proving the No Free Lunch theorem for programming language semantics
00:40:46 <mm_freak> there is nothing wrong with hand-optimizing a certain inner loop, but if anything it's just stupid to write a whole application in asm today
00:40:48 <GorDonFreeMan> of course, if you just specify the functions like in GHC that makes development fast.
00:41:08 * ski wonders what "just specify the functions" means
00:41:10 <GorDonFreeMan> and it's more flexible than some bash script, and faster
00:41:18 <merijn> GorDonFreeMan: Hand written is not always faster than high level code, because the human mind can't deal with ASM on a large scale
00:41:41 <GorDonFreeMan> merijn<< this is why macro was invented
00:41:49 <merijn> Macro's are not good enough
00:42:00 <GorDonFreeMan> maybe
00:42:05 <mm_freak> GorDonFreeMan: haskell basically takes this idea to the next level:  not only is the compiler better at writing code, but the run-time system is also better at managing your resources
00:42:08 <ksf> http://www.youtube.com/watch?v=3kEfedtQVOY
00:42:20 <ski> you need something like a type system, which can communicate information across different parts of the program
00:42:20 <merijn> Sure, you can optimise a single function in ASM. But you try writing an entire OS in ASM. The human mind can't hold the ASM of an entire OS
00:42:20 <aadrake> Question: I'm retrieving batches of records from MongoDB and need to iterate on the nextBatch function in the MongoDB library.  I'm having a hard time conceptualizing this functionally.  Does anyone have some advice or suggestions?
00:42:29 <ski> s/type system/type inference system/
00:42:39 <mm_freak> in fact, when i write networking code in haskell it's very difficult to beat with a C implementation, and the equivalent C code is going to look very ugly and be very long
00:42:40 <GorDonFreeMan> mm_freak<< i remember guys here said not to rely on ghc for realtime tasks
00:42:49 <GorDonFreeMan> because of the random latencies it may cause
00:42:58 <GorDonFreeMan> like 10ms+
00:43:05 <mm_freak> yeah, there is some truth to that, because the garbage collector may introduce delays
00:43:08 <c_wraith> GorDonFreeMan: stop-the-world GC isn't compatible with hard real-time
00:43:10 <merijn> ksf: That's the computational linguistics and protocol/file format security talk?
00:43:16 <c_wraith> and GHC uses stop-the-world GC
00:43:16 <ksf> jep
00:43:22 <mm_freak> haskell is not really suitable for real-time development at this point
00:43:40 <mm_freak> you can get to comparable speeds, but you can't do much about the delays
00:43:54 <merijn> ksf: Haven't seen it yet, but it is on the top of my list
00:44:04 <ksf> it's brilliant
00:44:18 <GorDonFreeMan> but if it has low enough latency, and high enough performance maybe it could handle my vectorgraphic designing needs
00:44:24 <GorDonFreeMan> i was thinking about this
00:44:34 <GorDonFreeMan> and it would be much simpler to code it than in C
00:44:38 <ksf> I'm still not entirely convinced when it comes to length fields, though.
00:44:42 <mm_freak> you need real time properties for that?
00:44:51 <GorDonFreeMan> (given it allows me enough sequential freedom)
00:45:02 <ksf> ...at least if the length fields are finite.
00:45:11 <GorDonFreeMan> mm_freak<< no, i need realtime for hardware interface, and CNC machine control
00:45:38 <ksf> a) you can model that with nothing more than a bigger dfa (though that's impractical) and b) it's trivial to implement safely outside of the dfa
00:46:29 <mm_freak> GorDonFreeMan: as long as you don't need real time responsivity, haskell is fine
00:47:26 <mm_freak> for arithmetic code you get near C performance (though you likely won't reach it), and for networking code you can even outperform the usual C implementations
00:48:19 <GorDonFreeMan> i'm doing cpu intensive calculations, and coordinate geometry now
00:49:01 <GorDonFreeMan> are matrix transformations straight forward in haskell?
00:49:16 <GorDonFreeMan> how does it handle sse2 code?
00:50:11 <mm_freak> GHC does not generate SSE code…  matrix transformations are easy to write in haskell, but you can use the hmatrix library, which uses a fast C library for that
00:52:53 <BMeph> Is there a function named already that works like: "if p x then x else y"?
00:54:07 <mm_freak> BMeph: fromMaybe ;)
00:54:26 <mm_freak> > fromMaybe 15 (Just 3)
00:54:27 <lambdabot>   3
00:54:29 <mm_freak> > fromMaybe 15 Nothing
00:54:30 <lambdabot>   15
00:54:42 <mm_freak> you can use that together with 'guard'
00:58:55 <BMeph> Dang, I actually need something more like the reverse: f :: a -> (a -> Maybe b) -> a -> a
00:59:09 <ncs> i have created a module (say module Test) in which i have defined a datatype. now i want to use that module in a new file but import Test does not import the datatype in the new file.. any ideas?
00:59:58 <merijn> BMeph: What would that actually do?
00:59:58 <BMeph> ncs: Export the type? ;)
01:00:07 <ncs> how?
01:00:37 <c_wraith> BMeph: the fact that b appears only once in there makes it seem a bit limited
01:00:47 <BMeph> ncs: Place the nam of the type in the export list.
01:01:11 <mm_freak> ncs: module Test (MyType(..)) where
01:01:22 <mm_freak> or leave out the export list entirely thereby exporting everything
01:01:48 <BMeph> merijn, c_wraith: f def g a | g a = Nothing = def   | otherwise = a
01:02:05 <ncs> ok! thanks!
01:02:11 <BMeph> | g a == Nothing = def
01:03:05 <BMeph> ncs: Alternatively, you can omit the export list and thus export everything in the module.
01:03:11 * hackagebot yaml 0.5.1 - Low-level binding to the libyaml C library.  http://hackage.haskell.org/package/yaml-0.5.1 (MichaelSnoyman)
01:03:47 <BMeph> ncs: Depending on what "extra" goodies are in the module besides what you want to use, that's also allowed.
01:05:59 <lukish_>  [04:59:27] <         hpaste> lukish pasted “gnuplot” at http://hpaste.org/55863
01:06:02 <lukish_>  [04:59:28] <        lukish_> I run it and got nothing. How can I get picture or something?
01:06:24 <ivanm> lukish_: do you have the non-Haskell gnuplot package installed?
01:06:51 <ivanm> and if you're using the X11 terminal, I presume you're on a *nix OS?
01:07:00 <ivanm> (or something with X support)
01:08:25 <aadrake> So if I have something of type [[Int]] and I want to examine each list and return false if empty, would I write something like emptyCheck [] = False; emptyCheck list = emptyCheck (tail list)?
01:09:48 <ivanm> @type not . null
01:09:49 <lambdabot> forall a. [a] -> Bool
01:09:50 <ivanm> aadrake: ^^
01:09:52 <aadrake> I guess I could use emptyCheck list = null list
01:10:10 <ivanm> @type map (not . null)
01:10:11 <lambdabot> forall a. [[a]] -> [Bool]
01:11:42 <aadrake> ivanm: The reason I ask is because I'm trying to figure out the MongoDB library and the nextBatch function returns [] when it gets to the end of the document set.  So I need to keep calling that until [] is returned.
01:12:05 <ivanm> so it returns a list?
01:12:11 <ivanm> or each time you call it it returns a list?
01:12:42 <aadrake> Each time you call it it returns a list
01:12:45 <aadrake> Of lists
01:12:46 <Axman6> aadrake: you seem to be jumping into more advanced haskell usage before understanding the basics
01:13:33 <aadrake> Axman6: Granted, but I need to do this for work.  It will allow me to benchmark Haskell against other solutions.
01:14:01 <ivanm> aadrake: benchmarking an implementation in a language you don't know well won't be that great
01:14:26 <Axman6> aadrake: well, it'll allow you to benchmark your bad haskell code
01:14:34 <BMeph> :t any null
01:14:35 <lambdabot> forall a. [[a]] -> Bool
01:14:44 <aadrake> ivanm: That's kind of my goal.  I plan to show that even though I'm not familiar with the language and the code isn't optimized it is still faster than the current tools.
01:14:57 <BMeph> aadrake: Try that ome. ;)
01:15:08 <lukish_> ivanm: yes, i have ubuntu. Installing gnuplot now
01:15:26 <ivanm> BMeph: it sounds like it does some kind of "getNextRow :: IO [[a]]" thing IIUC what aadrake is saying properly
01:15:31 <ivanm> analogous to getNextLine
01:15:36 <ivanm> so using any, etc. won't work
01:15:43 <aadrake> BMeph: I don't think that will work
01:16:06 <lukish_> ivanm: installed gnuplot, worked now.
01:16:09 <aadrake> BMeph: It will return false on the entire set of lists if any of them is empty
01:16:10 <ivanm> good-o
01:16:15 <BMeph> aadrake: Hey, you're the one who said "emptyCheck [] = False; emptyCheck list = emptyCheck (tail list)"
01:16:18 <Ke> how come this doesn't use 100% cputime http://users.tkk.fi/~jkarlson/codes/test.hs
01:16:54 <BMeph> aadrake: Oops, my bad: not . any null
01:17:08 <Axman6> because delays are a sign that the OS/RTS can look for something else to run, and delay n says delay for _at least_ this long
01:17:13 <aadrake> BMeph: :)
01:17:32 <lukish_> Well, what should I use go draw line for list of points :: [(Int,Int)]?
01:17:51 <Ke> Axman6: but there are no other threads
01:18:19 <ivanm> lukish_: any particular reason for using the gnuplot library?  Most people wanting nice-looking plots use Chart nowadays I think
01:19:05 <Ke> select(0, [], [], NULL, {0, 20000})     = 0 (Timeout)
01:19:06 <lukish_> ivanm: no actually, just first I've googled out
01:19:16 <Axman6> Ke: the second half of my statement is the important one. you'll probably find that it uses epoll for the delays, so there's some delay time waiting for the event 'your timer has completed' to fire
01:19:31 <ivanm> heh
01:19:32 <Ke> it seems that sleeping 20000 ns seems sensible for some reason
01:19:40 <ivanm> Ke: why are you sleeping?
01:20:02 <Ke> ivanm: (10:35:01) <        Ke> I guess ghc optimizes foldM_ x y [0..hugeInt] in a reasonable manner?
01:20:21 <ivanm> Ke: I meant, why are you *wanting* to do that?
01:20:34 <ivanm> or are you just using threadDelay to test the foldM_ call?
01:20:41 <Ke> yes
01:21:08 <Ke> it's there just to prevent optimization
01:21:34 <Axman6> ghc won't optimise threadDelay 0
01:21:45 <Axman6> it's a dumb way of saying yeild
01:21:49 <Ke> indeed it won't
01:25:52 <Ke> so any other function to prevent optimiztion?
01:30:16 <hpaste> kizzo pasted “Proper syntax” at http://hpaste.org/55873
01:35:31 <Sgeo_> kizzo,
01:35:37 <Sgeo_> do is for monads
01:36:08 <Sgeo_> your expression with do is not a Bool
01:36:21 <Sgeo_> Since your using doesDirectoryExist, it's probably IO Bool
01:36:59 <Sgeo_> Also, with bools, you don't need to compare against True
01:37:53 <ivanm> Ke: do a criterion computation?
01:39:01 <kizzo> Sgeo_: Thank you, but I am still not sure of exactly what to do with that information.  The last line now looks like "return r"
01:39:10 <kizzo> at least
01:39:33 <Sgeo_> Yes, but that wasn't the problem with the code that's preventing compilation (if that was unclear)
01:39:54 <Sgeo_> The problem is that works is really :: String -> IO Bool
01:41:12 <Sgeo_> Do you see why?
01:41:34 <Sgeo_> do is used as a convenient way to piece together monads, of which IO is an example.
01:41:50 <Sgeo_> But the result of a do expression should be a monad, in this case, some sort of IO a
01:41:56 <Sgeo_> (And in this case, IO Bool)
01:42:06 <kizzo> Yeah I need to review the Input and Output section of learnyou.
01:42:13 <Sgeo_> But you're declaring your function works as :: String -> Bool
01:42:25 <kizzo> I have commented out that line, mmhmm.
01:42:28 <Sgeo_> And in valid, you're also trying to use it like String -> Bool
01:42:59 <Sgeo_> When it's really a String -> IO Bool. And you can't "perform", so to speak, an IO action outside of an IO action.
01:43:09 <Sgeo_> So valid itself needs to return an IO action
01:43:31 <kizzo> Alrighty.
01:43:38 <kizzo> Experimenting..
02:10:43 <Ke> Axman6: still sleep functions rarely delay necessarily just for fun, perhaps the random 20000 is just there to compensate some inteface limitation, os limitation or timer imprecision
02:10:51 <Ke> unnecassarily
02:11:14 <ezyang> Is it just me, or does the ResourceT transformer kind of do poorly on the "oops I freed it but actually I need it later" front?
02:13:12 * hackagebot resource-pool-catchio 0.2.0.3 - Fork of resource-pool, with a MonadCatchIO constraint  http://hackage.haskell.org/package/resource-pool-catchio-0.2.0.3 (JurrienStutterheim)
02:14:48 <ezyang> Also, can someone exlain to me what the benefits of inversion of control in the original iteratees design was?
02:15:34 <ezyang> Maybe I should go to #yesod
02:16:24 <ksf> syntactically, it isn't.
02:16:30 <ksf> practically, it meant getting shit done.
02:16:52 <Saizan> ezyang: oleg's original material does
02:17:04 <ksf> http://pchiusano.blogspot.com/2011/12/programmatic-translation-to-iteratees.html
02:21:17 <ezyang> I guess I'm a little confused how Conduits are able to get rid of IoC and still manage to preserve the benefits.
02:21:29 <ezyang> I guess the key change is from push to pull?
02:22:41 <ezyang> Oh, I see, the programattic translation article explains this nicely.
02:23:11 * hackagebot snaplet-hdbc 0.7.2 - HDBC snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-hdbc-0.7.2 (JurrienStutterheim)
02:23:53 <ezyang> ...but is that actually what Conduits do?
02:24:13 <Ke>                2 MB total memory in use (0 MB lost due to fragmentation)
02:24:42 <Ke> I guess this means there is no 100M memory leak in haskell code, but somewhere inside the FFI code?
02:41:36 <ezyang> (sigh) I can't wait until Oleg weighs in on the discussion
02:42:50 <ezyang> I am annoyed at conduits but I can't tell if this is just at how they're implemented, or if there's actually an underlying problem.
02:44:24 <Sgeo_> What's the difference between conduits and enumerators/iteratees?
02:44:59 <ezyang> Sgeo_: I'd love to know, there's some descriptions on the documentation that exists so far.
02:45:27 <ezyang> I think the big smell is that I can't automatically convert an interatee into a conduit (and vice versa)
02:51:27 <ivanm> Sgeo_: I think it's that conduits keep some state internal so that you can explicitly close a resource
02:51:46 <ivanm> and they also seem a lot easier to understand
02:52:12 <Sgeo_> Can sinks communicate upwards to the chain?
02:52:16 <Sgeo_> I think iterIO allows that
02:52:45 <Sgeo_> I have a use-case in mind, but it's so vague I'm not sure it's real
02:52:47 * Sgeo_ keeps reading
02:53:14 * hackagebot yaml 0.5.1.1 - Low-level binding to the libyaml C library.  http://hackage.haskell.org/package/yaml-0.5.1.1 (MichaelSnoyman)
02:54:47 <ivanm> Sgeo_: from what the blog posts have covered, no; but I think he's been hinting at something like that...
02:55:20 <Sgeo_> I think for my (again, vague) use case, I could do without it
02:57:02 <Sgeo_> That sinkState thing makes me vaguely think of EL.foldr
02:57:11 <Sgeo_> But I'm not experienced enough with enumerators to say.
03:16:14 <Sgeo_> How are conduits simpler than enumerators?
03:28:14 <iago> Sgeo_, did you read something about conduits ?
03:29:03 <Sgeo_> I read the blogposts
03:29:10 <Sgeo_> But maybe I wasn't paying enough attention
03:30:07 <iago> Sgeo_, well, I'm not an expert, I just used enumerators a few times
03:30:16 <iago> and I just read a blogpost about conduits
03:30:39 <iago> IMO conduits is just another re-implementation of enumerators
03:30:53 <iago> but the author has changed the names
03:31:13 <iago> and the library is supposed to fix a few design flaws
03:32:20 <Sgeo_> o.O is peek possible in enumerator?
03:33:00 <iago> I think it is
03:33:16 * hackagebot OpenCL 1.0.2.6 - Haskell high-level wrapper for OpenCL  http://hackage.haskell.org/package/OpenCL-1.0.2.6 (LuisCabellos)
03:33:44 <iago> not 100% sure, since I did not care too much about the internals until now
03:33:48 <ivanm> iago: it doesn't seem to be a re-implementation at all
03:33:53 <ivanm> similar concepts
03:36:03 <iago> well, I didn't read enough about the internals of conduits, but from the point of view of a programmer, both libraries look very similar
03:36:45 <ivanm> except that the terminology is a lot clearer with conduits, and you don't have as much mangling of types
03:36:56 <Sgeo_> mangling of types?
03:37:20 <ivanm> see the recent google+ comments (I think it was by blackdog) about how to get some types working properly when composing enumerators or something
03:38:41 <aninhumer> Hmm, I'm not clear why you need a new term for "fusing" it looks like it's just composition
03:39:56 <ksf> fusion is a thing the compiler does, not the programmer
03:40:03 <iago> ivanm, perhaps, I just take a very quick look to conduits, but that would be cool
03:40:08 <Patrek> How can I instantiate a typeclass  for constrained polymorphic types?  instance Showable (Num a=> a)  and instance Showable (Show a => a) ?
03:40:21 <Saizan> Patrek: you can't
03:40:37 <Patrek> why?
03:40:37 <ksf> instance Show a => Showable a
03:40:51 <ksf> requring UndecidabeInstances, though
03:40:56 <iago> Patrek, you cannot do that, in that way
03:41:06 <ksf> ...because you could add instance Showable a => Show a and have a loop.
03:41:49 <Saizan> also, you can't have both instance Show a => Showable a; and instance Num a => Showable a; and retain sanity
03:42:00 <Patrek> ksf: that includes Char, Int and basically every type!
03:42:03 <aninhumer> ksf: I don't really see the distiction, afaics the programmer and compiler do roughly the same thing they would for say function composition?
03:42:03 <ksf> instance Show a => Show (Foo a) works, though.
03:42:05 <Saizan> because e.g. which instance should be used for Int ?
03:42:46 <ksf> aninhumer, composition is you saying map f . map g or map (f . g). fusion is the compiler turning the former into the latter.
03:43:18 <ksf> it's also known as deforestation.
03:43:57 <aninhumer> ksf: isn't that just a usual part of any compilation though?
03:44:40 <ksf> not necessarily. and not every fusion technique catches every oportunity.
03:45:08 <Patrek> Saizan: sanity?
03:45:49 <aninhumer> ksf: Ah hmm, I just realised the term was a general one the blog writer was using, not a new one
03:45:53 <aninhumer> that makes more sense
03:46:10 <aninhumer> I thought they were just inventing a new word for no reason
03:46:11 <ksf> aninhumer, http://scholar.google.com/scholar?cluster=6305039901575196405&hl=en&as_sdt=0,5   gives a great example.
03:46:34 <Patrek> so basically it is not possible to have overloaded functions for constrained polymorphic types?
03:47:26 <aninhumer> ksf: I'll add this to my giant pile of papers I intend to read one day :P
03:49:19 <Patrek> any solution in generics? to implement an overloaded function for constrained polymorphic types
04:03:04 <Patrek> how can I express type inequality for inputs of a function?
04:03:59 <ezyang> I... don't think you can do that?
04:04:04 <ezyang> What are you realy trying to do?
04:05:57 <Patrek> I have a higher order function that takes a binary function (a->b->c) as input and I need to express that  a /= b
04:06:28 <Sgeo_> Is adding onto the end of an IO action more efficient than appending to a list?
04:06:35 <ezyang> I can trivially fake out your function by constructing a newtype.
04:06:49 <Patrek> how?
04:07:05 <ezyang> Sgeo_: They're equally efficient, but it's fine cuz Haskell is lazy :-)
04:08:08 <maltem> Patrek, ezyang is saying that inequality between types isn't really meaningful
04:10:11 <Sgeo_> OverlappingInstances? >:D
04:10:16 <Sgeo_> (Don't actually do that)
04:10:55 <KorriX> Is there any simple web framework for haskell (like cherrypy for python ...) ?
04:13:41 <tsousa> why is that functional programming language is not very used in companys?
04:14:17 <Sgeo_> Instead of events or polling, would it make sense to structure an application around a Source/Enumerator that gave off .. events, for lack of a better word?
04:16:02 <ezyang> kj7kjrKorriX: Super simple? Try the 'cgi' package. More complex? Maybe Yesod? Snap?
04:16:21 <mrcarrot> tsousa: it is used... but through the backdoor. there are though many companies using pure functional program also
04:16:55 <mrcarrot> tsousa: many of the advanced functions that has been creeping into imperative languages are actually coming from functional programming
04:17:20 <tsousa> mrcarrot, but not so muuch Haskell? company use what functional programming language?
04:17:38 <mrcarrot> tsousa: to learn yourself functional programming, means that you are becoming better programmer also with other languages
04:19:36 <Patrek> in a higher order function, hf:: a -> (a->b) -> Bool, I want to express that b is a concrete type and not a polymorphic type, for example, I want the type checker to reject ,  f:: a -> Maybe a ,    hf "2" f  but accept g:: String -> Maybe String, hf "2" g
04:19:39 <mrcarrot> tsousa: linspire is one example of haskell used in a company
04:19:51 <tsousa> mrcarrot, yes i know but comparing the time that takes me to write a simpe program in python and in Haskell, Haskell takes 2x more time lol
04:20:04 <ezyang> Patrek: Is this for optimization purposes?
04:20:29 <ion> I wonder if any Haskell web servers/frameworks use hash tables for data from Mallory? I wonder if the hash table implementations for Haskell take this attack into account? http://events.ccc.de/congress/2011/Fahrplan/attachments/2007_28C3_Effective_DoS_on_web_application_platforms.pdf
04:20:30 <mrcarrot> tsousa: that is the problem in the beginning. actually, i am writing faster in haskell than in python
04:21:19 <Patrek> ezyang,  that is because hf needs to hold certain properties
04:21:20 <mrcarrot> tsousa: then you also have to take into account less time debugging things...
04:22:04 <mrcarrot> it is often no surprise that a haskell program (smaller) is working from first trial, once it compiles
04:22:48 <ezyang> Patrek: I'm still a bit confused.
04:22:49 <KorriX> and what with templating systems ?
04:22:52 <ion> Even if Haskell takes 2× more time laughing out loud, at least there’s laughter involved.
04:23:21 <mrcarrot> yeah, haskell gave back the joy of programming, that i had lost long time ago.
04:23:26 <tsousa> mrcarrot, in my case a spend most of my time in Haskell in debugging. that types are awesome ehehe
04:23:52 <Patrek> ezyang: hf needs to be aware of the fact that there is no "generator" function (... -> a) available in hf, hence hf holds certain properties
04:23:59 <tsousa> mrcarrot, how long do you know Haskell?
04:25:08 <mrcarrot> i learned it in uni (10 years ago). at that time i thought it is the worst language and thought i would never look at it again. it was too different. now i have been a half year learning it over again, and i really like it this time
04:25:51 <mrcarrot> i am not a haskell expert in any way.. and not a fanboi either. but i think it is a very great language
04:26:11 <mrcarrot> it is having its problem as every language
04:26:25 <Axman6> tsousa: there are plenty of companies using haskell these days. not for their main operations, but places like Google and Facebook have both started using it
04:26:40 <tsousa> yeh i think so too. but it a bit different. i had never did any functional programming language before
04:26:56 <tsousa> Axman6, to do what?
04:27:51 <Axman6> facebook use haskell to refactor PHP code, makes their development a lot easier. google are using it for several things i believe, but they don't like to talk about it too much. mzero works at google and might be able to tell you more
04:28:27 <Axman6> i worked for a high frequency trading company in Japan earlier in the year, and almost everything i the company ws written in haskell (most importantly, the trader itself)
04:28:46 <mrcarrot> i know this is a bit stupid and oversimplified, but this is how haskell is compared to other languages: with other languages it is like learning to count, and you need to know just 0 and 1 and you can begin. with haskell you need to know 0 to 9, but the numbers gets shorter
04:29:06 <Axman6> Galois use a lot of haskell for lots of crypto work, as well as other high assurance systems (including at least one project for NASA)
04:29:13 <mrcarrot> i mean, with haskell you need to know more "commands" than with other, but it pays of in shorter code
04:29:23 <ezyang> Patrek: Hmm.
04:29:30 <mrcarrot> (except for very interactive applications)
04:29:48 <Cale> mrcarrot: I'm not sure that's entirely true... hmmm
04:30:06 <ezyang> I think I can almost see where you're going, do you have a specific example?
04:30:15 <mrcarrot> Cale: that is why i said "over simplified"
04:30:19 <Cale> mrcarrot: I guess if you consider that there are a few more higher order functions on lists than there are types of loop in most imperative languages...
04:30:44 <Cale> Then maybe in that sense, there's a bit of a longer stretch to learning how to write basic programs.
04:30:51 <WarzoneCommand> suppose I have an x of type a, then can I somehow write something like : if a is showable then show x else "" ?
04:31:10 <Patrek> ezyang: In automated testing, when it comes to testing polymorphic functions
04:31:30 <Cale> WarzoneCommand: nope, because there's no way to know when compiling a module that any given type certainly *isn't* a member of a typeclass
04:31:37 <ksf> WarzoneCommand, well...
04:31:41 <Cale> WarzoneCommand: (since future modules are always allowed to add instances)
04:31:42 <ezyang> So, I think, what you want here, is to have a higher-rank type for your testing command.
04:31:47 <ksf> overlapping instances should work.
04:31:50 <mrcarrot> Cale: i just know that i was able to pick up almost any imperative language in a couple of hours. with haskell, i had to learn a lot more to be able to do the same things
04:32:04 <Cale> mrcarrot: Even your first imperative language?
04:32:13 <mrcarrot> and my code became shorter (as long as it was not a lot of interaction with the user)
04:32:19 <tsousa> Axman6, that is pretty awesome. did you get this job because you are a good haskell coder or because of some degree?
04:32:25 <Cale> mrcarrot: Once you know one imperative language, learning another is easy, obviously.
04:32:32 <ezyang> Actually, that doesn't manage it.
04:32:33 <ksf> newtype Foo a = Foo a; instance (Show a) => Show (Foo a) where show (Foo x) = x; instance Show (Foo a) where show _ = ""
04:32:44 <ksf> but that's *evil*.
04:33:08 <Cale> mrcarrot: If you know Haskell, learning Clean is almost trivial. Learning O'Caml still won't take you more than a week or two.
04:33:16 <Axman6> tsousa: neither :P i guess i had enough haskell skills to get the job (well internship)
04:33:33 <WarzoneCommand> so what is the canonical way of doing something like this?
04:33:45 <WarzoneCommand> I'm building some kind of tree data structure
04:33:48 <Patrek> ezyang: http://publications.lib.chalmers.se/records/fulltext/local_99387.pdf
04:33:55 <ksf> the canonical way is not to do such stuff.
04:33:59 <WarzoneCommand> and if I can show the data in a node I would like to show the thing
04:34:12 <WarzoneCommand> and otherwise just print the name of the constructor of the node
04:34:17 <Cale> WarzoneCommand: Are there existentials or something?
04:34:22 <WarzoneCommand> nope
04:34:33 <Cale> WarzoneCommand: Then you should know the type of the data in the node.
04:34:38 <tsousa> Axman6, yeh that is awesome. i dont know if i am going to university but i would like to get a job in development
04:34:41 <Cale> when you're going to show it...
04:34:45 <WarzoneCommand> yes
04:35:00 <ksf> WarzoneCommand, do instance Show a => Show (Tree a). then, if you have an a that can't be shown, transform it to Tree () or something.
04:35:04 <Cale> So you should know if it's showable or not, and just be able to use show or not depending.
04:35:37 <Axman6> tsousa: if you can go to university, i'd personally recommend it, especially if it's one that teaches you more than just how to pump out crappy java apps
04:36:51 <mrcarrot> i wonder how big percent of everybody writing haskell had to begin completely over with haskell a few times...
04:37:10 <ksf> count me in.
04:37:21 <ksf> I guess I had it easy, though, I knew scheme and loved continuations.
04:37:49 <ksf> ...and wrote java code at work that made my coworkers shiver in horror.
04:38:37 <Cale> I don't think I could say I had to begin completely over with it at some point. I learned it slowly over the course of a year or two though (at least, most of it? I'm still learning things about new stuff that gets added to GHC...)
04:39:11 <Sgeo_> https://github.com/snoyberg/conduit this seems to be a better explanation of the differences between conduits and enumerators
04:39:14 <tsousa> Axman6, if i am going i woudl go to a university that teach Haskell,C,Java and assembly
04:39:26 <ksf> well, I interpreted that as having your understanding of how haskell works repeatedly nuked from under your brain.
04:40:18 <tsousa> you guys sometimes dont want to code Haskell anymore?
04:41:00 <ion> Huh?
04:41:33 <Cale> tsousa: Not really, except to program in fantasy languages which don't actually exist.
04:41:46 <ion> Blub is the best programming language.
04:42:01 <tsousa> ehehe
04:42:13 <tsousa> is there any exercices online?
04:42:21 <Cale> There are things which annoy me about Haskell, but they are far less severe than the things which annoy me about essentially every other programming language.
04:42:50 <tsousa> Cale, like what?
04:43:21 <Cale> 'fail' shouldn't be a method of the Monad class, we should get MonadZero back...
04:43:46 <aadrake> I have liftIO $ mapM_ (print . exclude ["_id"]) docs (where docs is of type [Document]) but I seem to be having problems with the type signature.  liftIO has type Control.Monad.IO.Class.MonadIO m => IO a -> m a but any type signature with MonadIO has a scope error.  Ideas?
04:44:00 <Cale> It might be nice to tidy up the Num class a bit (actually I rather like most of the numeric hierarchy in the Prelude, but there are some details...)
04:44:25 <Cale> Specifically, Show and Eq shouldn't be superclasses of Num, and abs/signum belong in their own class.
04:45:08 <Cale> It should be possible to elide the scrutinee of case expressions to make a 'section' of case
04:45:28 <Cale> (case of ...) should be equivalent to (\fresh -> case fresh of ...)
04:45:46 <ion> And Monad doesn’t depend on Functor and Applicative/Pointed, and you can’t choose to implement a monad in terms of fmap and join (except with something like m >>= f = join' (fmap f m) where { join' = … } which isn’t as nice).
04:45:55 <Cale> Yeah, that's also true...
04:46:07 <Cale> There are lots of little wibbles in the standard libraries...
04:46:15 <ezyang> Patrek: I think the best guarantee you can give of this sort is the type signature of the function. It's tough, because in order to actually test the function you need to have a way of generating values.
04:46:23 <ion> And most things in base that use Int should use Integer.
04:46:29 <ksf> I fear we won't even get them fixed.
04:46:38 <Cale> It would be nice at least for 'map' to be the functorial map, and have a special lmap for lists if we're going to have a specialised one.
04:46:50 <ksf> still makes sense to do all the design work, though, in the hope that e.g. disciple takes them up
04:46:50 <Cale> Oh yes, Int should be out of the Prelude entirely.
04:47:00 <hughfdjackson> what's the difference between Integer and Integral?
04:47:05 <ksf> Int is generally questionable.
04:47:07 <hughfdjackson> i feel like i'm missing something fundamental :P
04:47:07 <Cale> Integer is a type
04:47:09 <ion> Integral is a type class, Integer is a type.
04:47:10 <Cale> Integral is a typeclass
04:47:19 <hughfdjackson> ^_^ okay! cheers guys
04:47:27 <Sgeo_> > length [1..fromInegral (maxBound::Int) + 1]
04:47:28 <lambdabot>   Not in scope: `fromInegral'
04:47:32 <Sgeo_> > length [1..fromIntegral (maxBound::Int) + 1]
04:47:34 <lambdabot>  Terminated
04:47:38 <hughfdjackson> i take it Int and Integer are of the typeclass Integral?
04:47:41 <Sgeo_> > geneericLength [1..fromIntegral (maxBound::Int) + 1]
04:47:42 <lambdabot>   Not in scope: `geneericLength'
04:47:45 <mrcarrot> i think Int should not be out, but not used as default (even though ghc will make it into Integer if it becomes too big)
04:47:46 <Sgeo_> > genericLength [1..fromIntegral (maxBound::Int) + 1]
04:47:48 <lambdabot>   *Exception: stack overflow
04:47:50 <Sgeo_> o.O
04:48:01 <ion> hughfdjackson: See “:i Integral” in ghci.
04:48:02 <Cale> The types which are instances of Integral include Int, Integer, Int64, Word8, Word16, Word32, etc.
04:48:14 <mrcarrot> by specifying ::Int, you might get a bit of speed up if you know it is going to be just small numbers
04:48:26 <Cale> mrcarrot: I just think you should have to import a separate module to use Int
04:48:43 <ksf> it's got the most unspecified semantics of the whole prelude.
04:48:48 <ksf> "at least 31 bits"
04:48:58 <Cale> Integer is good and fast enough in almost all cases
04:49:01 <ion> mrcarrot: Then you probably know which bit size you want and choose something from Data.Int or Data.Word.
04:49:20 <Sgeo_> On GHCi, the line of code I tried seems to be taking forever
04:49:30 <Cale> Starfire: which line?
04:49:41 * ksf wants arbitrary-length integers, not just variable-length ones.
04:49:43 <Cale> er, Sgeo_ rather
04:49:57 <Sgeo_> <Sgeo_> > genericLength [1..fromIntegral (maxBound::Int) + 1]
04:50:10 <ksf> 2^15 :: Int 15
04:50:12 <Cale> what's maxBound :: Int on your system?
04:50:16 <Cale> > maxBound :: Int
04:50:17 <lambdabot>   9223372036854775807
04:50:42 <ksf> actually, no, that'd be Word 15
04:50:44 <alexanderpine> hello everyone
04:50:48 <ksf> Int needs an upper and lower bound.
04:51:41 <hughfdjackson> ion: cheers
04:52:00 <ion> (minBound :: Int 42 59) == 42 ;-)
04:52:33 <Sgeo_> Computer wnet weird for a while
04:52:34 <hughfdjackson> :|
04:52:36 <hughfdjackson> type classes
04:52:38 <Sgeo_> Still being weird
04:52:44 <hughfdjackson> they seem to be a very nice idea
04:52:45 <Sgeo_> Ok, it's better
04:53:05 <Sgeo_> 2147483647
04:54:14 <rtharper> is it normal for tt mode in lhs2TeX to italicise types?
04:54:37 <rtharper> and for verb mode to add a ' just before a newline char?
04:56:22 <rtharper> as is there a way to disable the latter?
04:56:23 <rtharper> and*
04:59:21 <wingie> isn't it expensive to use recursion instead of for loops in langs that are not fully functional like javascript?
05:00:43 <hpc> wingie: sometimes; some languages have tail-call optimization
05:00:59 <hughfdjackson> :P wingie ask #javascript questions in #javascript preferentially
05:01:04 <hpc> and in some languages, function calls are significantly more expensive than a for loop
05:01:11 <hpc> javascript i believe is one of those languages
05:01:22 <hughfdjackson> hpc: depends on the implementation
05:01:40 <hughfdjackson> we have an array.forEach(function(val, key){}) method now
05:01:48 <hughfdjackson> it's normally slower than for(;;) ..
05:01:52 <hughfdjackson> but it's *so* much cleaner
05:02:02 <hughfdjackson> especially in a non-block-scoped language
05:04:05 <hughfdjackson> hpc: the real issue with recursion as iteration in js is that there's no TCO, as mentioned
05:04:13 <hughfdjackson> :D lunch time!
05:04:54 <ezyang> Yeah, I'll happily trade away a little speed for sensible scoping in JS.
05:05:03 <merijn> Am I the only one who finds tail recursive functions horribly unreadable?
05:06:06 <merijn> I was TA'ing a ocaml practical and without laziness the "naive" implementation of map has significant problems compared to a tail recursive version
05:06:16 <merijn> The naive version is however much nicer, imo
05:10:20 <bford> can anyone tell my why the usual Class(..) export mechanism doesn't export GADT constructors?
05:11:21 <ezyang> merijn: Meh? They're really the easiest way to encode arbitrary loops without busting out mutable references.
05:12:24 <merijn> ezyang: I'm not saying anything about the technical desirability of tail recursive functions. They're obviously superior, my points was that they are just so much harder to parse as a programmer
05:12:46 <ksf> not at all.
05:13:08 <ksf> loops have all kinds of scary side-effects you have to deal with.
05:13:25 <merijn> ksf: I wasn't comparing with loops
05:13:35 <merijn> I was comparing with "naive" recursion
05:13:50 <merijn> "map f x:xs = f x : map f xs" vs a tail recursive function of map
05:13:55 <ksf> then... do you mean haskell-tr or scheme-tr
05:14:15 <merijn> The former of is (IMO) obviously superior from a readability perspective
05:14:31 <ezyang> merijn: Oh, well, the tail recursive function is inferior in a lazy language.
05:14:41 <ksf> map f = go where go x:xs = f x : go xs
05:15:10 <merijn> ksf: That's not tail recursive
05:15:38 <ezyang> since it requires everything to be consumed
05:15:48 <hpc> am i correct in assuming that the preferred way to get haskell on debian testing is to apt-get haskell-platform, then cabal everything else?
05:15:55 <merijn> ezyang: I was just sort of polling whether the readability of tail recursive function was just my inferiority as a programmer or whether everyone finds them harder to parse
05:16:24 <ezyang> Oh. I definitely think that ordinary recursio nis easier to read.
05:16:33 <ksf> merijn, tail recursion is a matter of evaluation, not whether the recursive call is, syntactically, nested.
05:16:55 <PatrickRobotham> ksf: Why do you introduce go?
05:17:04 <sp3ctum_> i read on the haskell wiki somewhere that tail recursion is not that big of a deal normally. any thoughts on why this statement could have been made?
05:17:09 <ksf> so that f isn't passed in the tight loop.
05:17:20 <merijn> sp3ctum_: Yes, because of laziness
05:17:41 <sp3ctum_> merijn, can you elaborate on why that is so
05:17:48 <ksf> http://www.haskell.org/haskellwiki/Worker_wrapper
05:17:58 <merijn> sp3ctum_: In a non-lazy language "map f x:xs = f x : map f xs" has to traverse the entirety of xs before the result can be returned
05:18:00 <ezyang> sp3ctum_: The basic intuition is that a lazy function can return earlier
05:18:26 <merijn> sp3ctum_: This means that your stack keeps growing for each list item (eventually blowing your stack space if the list is too long)
05:19:03 <merijn> sp3ctum_: In a lazy language "map f x:xs = f x : map f xs" can just return "f x : <thunk to future computation>"
05:19:08 <sp3ctum_> merijn, that's assuming that all of the input need not be traversed, right?
05:19:33 <sp3ctum_> i mean, it's probably more efficient in that case
05:19:47 <ezyang> sp3ctum_: Nope, it has an impact even when the entire input is traversed.
05:19:55 <merijn> sp3ctum_: Even if you traverse all input you only do so after earlier items have already been returned. The result is that you don't need around a stack entry for each recursive call
05:20:46 <merijn> sp3ctum_: You just have "the current stack entry" and a thunk. Once you evaluate the thunk you can already throw out the current stack entry
05:21:02 <sp3ctum_> but that sounds like tail call optimization, right?
05:21:04 <ksf> lazy evaluation does mean that you can walk an arbitrary-length list in O(1) space. you don't need stack to work on one element at once.
05:21:28 <sp3ctum_> in my mind tco ~ loops in iterative languages in terms of speed
05:21:32 <merijn> sp3ctum_: The effect is the same, yes. i.e. O(1) stack space, but the semantics are different
05:21:46 <ksf> ...map isn't a function that describes a loop that gets executed. something else executes it.
05:22:26 <sp3ctum_> but why, then, does tco matter at all?
05:22:36 <ksf> it does matter in strict language.
05:22:43 <ksf> or in a strict setting in haskell.
05:22:48 <merijn> sp3ctum_: In haskell it doesn't much
05:23:14 <ksf> usuall people use foldr because it can work on infinite lists. foldl is quite useless, if then you want foldl'... strict and tail-recursive.
05:23:18 <sp3ctum_> merijn, but in haskell, it's still possible to get stack overflows on non-tail call optimized functions if i'm right
05:23:51 <ezyang> sp3ctum_: Yep.
05:23:52 <merijn> sp3ctum_: You can get stack overflows without recursion too
05:24:25 <merijn> sp3ctum_: It depends on the order in which you create and evaluate thunks
05:24:39 <sp3ctum_> merijn, how?
05:25:11 <merijn> I'm not that well-informed on the topics of how haskell's evaluation works. But I'm sure someone else here knows enough to explain when it can happen
05:26:07 * ezyang doesn't know how to make stack overflows without recursion, except the silly way... 
05:28:20 <Botje> int foo[ 1024 ^ 3 ]
05:28:32 <Botje> (with ^ being power, too lazy to type it out)
05:29:50 <merijn> ezyang: I didn't say there was a non-silly way of doing that :p
05:30:16 <merijn> ezyang: Just pointing out that it's not really a matter of recursion or not, but just how stacks work :p
05:31:02 <Sgeo_> I don't think I like how this doesn't work:
05:31:12 <Sgeo_> > case () of | False -> 5 | True -> 6
05:31:13 <lambdabot>   <no location info>: parse error on input `|'
05:31:15 <Sgeo_> But this does:
05:31:27 <Sgeo_> > case () of () | False -> 5 | True -> 6
05:31:28 <lambdabot>   6
05:31:59 <merijn> Sgeo_: Seems obvious
05:32:02 <Botje> Sgeo_: you have to pattern match once before you can use guards
05:32:05 <Botje> it's just like in functions
05:32:12 <Cale> sp3ctum_: GHC doesn't have a call stack
05:32:38 <merijn> Sgeo_: The second matches on () and true/false are guards, in the first true and false are patterns and neither match ()
05:32:38 <Cale> sp3ctum_: The stack which is referred to when you get a stack overflow is a stack used for pattern matches
05:33:03 <Sgeo_> merijn, uh, there is no pattern in the first
05:33:07 <Cale> TCO is pretty much meaningless in the case of GHC's evaluator, because there's no call stack to avoid putting things on
05:33:19 <Sgeo_> And if your explanation was correct, it would be a type error not a parse error
05:33:49 <Cale> sp3ctum_: The pattern matching stack basically consists of case expressions whose scrutinee is not sufficiently evaluated yet to pattern match
05:34:08 <Sgeo_> Cale, so what does boom x = 1 + boom (x-1) do if there's no call stack?
05:34:44 <ezyang> Sgeo_: + has an implicit pattern match
05:34:46 <hiptobecubic> I see the difference between (^) and (**), but why use (^^) instead of just (**) for non integer exponentiation?
05:34:50 <sp3ctum_> Cale, oh, interesting
05:34:50 <solarus> Sgeo_: it will be a type error if you remove the |
05:35:14 <solarus> > case () of False -> 5; True -> 6
05:35:15 <lambdabot>   Couldn't match expected type `()'
05:35:15 <lambdabot>         against inferred type `GHC.Bool.B...
05:35:50 <Cale> Sgeo_: Yeah, if you do something like :info Integer, you'll see that Integer actually does have a couple of constructors, and there's a pattern match which happens in the implementation of (+)
05:36:05 <Cale> Same goes for Int
05:36:17 <Cale> (It has only one constructor, but there's still a pattern match there)
05:36:35 <Cale> All evaluation at the core level happens because of case expressions
05:36:44 <ClaudiusMaximus> > 3 ^^ negate 3 :: Rational   -- hiptobecubic
05:36:45 <lambdabot>   1 % 27
05:37:15 <Cale> (all pattern matches and any other thing which needs to cause evaluation to occur before it can work will compile into something involving a case expression)
05:42:11 <hiptobecubic> Cale, i see. So using ^^ give it a more specific type? such that the compiler knows it has a rational representation?
05:43:30 <ClaudiusMaximus> :t ((^), (^^), (**))
05:43:31 <lambdabot> forall a b a1 b1 a2. (Num a, Integral b, Fractional a1, Integral b1, Floating a2) => (a -> b -> a, a1 -> b1 -> a1, a2 -> a2 -> a2)
05:43:57 <ClaudiusMaximus> with the added condition that ^ only works for non-negative powers
05:44:19 <Cale> kind of confusing to do them all at once like that :P
05:44:22 <Cale> :t (^)
05:44:23 <hiptobecubic> Indeed
05:44:23 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
05:44:27 <Cale> :t (^^)
05:44:28 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
05:44:30 <Cale> :t (**)
05:44:31 <Renze> Hi!
05:44:31 <lambdabot> forall a. (Floating a) => a -> a -> a
05:44:50 <Cale> They correspond to 3 different types of exponentation in mathematics
05:45:38 <Cale> The first will work with any kind of number for the base (really, anything which could be multiplied and has a unit with respect to multiplication would work, but we use Num), and only allows positive integer exponents
05:46:14 <Cale> The second (^^) will work with arbitrary integer exponents, but that requires the ability to find multiplicative inverses for the base type.
05:46:35 <Cale> (that is, it requires an instance of Fractional)
05:46:47 <hiptobecubic> Right
05:47:23 <hiptobecubic> Is there a difference, then, between Rational and Fractional?
05:47:33 <Cale> Rational is a specific type
05:47:39 <asda8> is there an efficient data structure which provides a two-way mapping (e.g. 1 maps to 'disznosajt' and 'disznosajt' in turn maps to 1)? I don't want to list every mapping twice in the src.
05:47:41 <hiptobecubic> of Fractional?
05:47:42 <Cale> (type Rational = Ratio Integer)
05:47:52 <Cale> Fractional is a typeclass which defines division
05:47:55 <hiptobecubic> ok
05:48:01 <Cale> :t (/)
05:48:02 <lambdabot> forall a. (Fractional a) => a -> a -> a
05:48:08 <Botje> asda8: a bimap?
05:48:09 <Cale> > 2/3 :: Rational
05:48:10 <lambdabot>   2 % 3
05:48:15 <Cale> > 2/3 :: Double
05:48:15 <asda8> Botje: I guess :)
05:48:16 <lambdabot>   0.6666666666666666
05:48:19 <Cale> > 2/3 :: Complex Double
05:48:20 <lambdabot>   0.6666666666666666 :+ 0.0
05:48:27 <hiptobecubic> That's nice.
05:48:54 <Botje> asda8: there's Data.Bimap
05:48:57 <Cale> asda8: There's a Bimap package on Hackage
05:49:11 * ezyang seems to recall that just maintains two maps 
05:49:16 <Cale> yes, that's all it does
05:49:18 <asda8> thanks, I didn't know the formal name for this
05:49:28 <Cale> It's not some clever quadtree-like thing
05:49:57 * ezyang isn't really sure the data structure is called a bimap, either... 
05:52:02 <ezyang> At least, you might get confused with th efunctorial bimap
05:52:55 <hiptobecubic> Cale, how long have you been haskelling?
05:53:07 <Cale> hiptobecubic: about 10 years
05:53:58 <KorriX> > 2**5
05:53:59 <lambdabot>   32.0
05:54:25 <KorriX> does lambdabot evaluate any haskell code ?
05:54:32 <KorriX> infinite loop's too ?
05:54:45 <ezyang> > fix id
05:54:45 <wingie> ghci is really cool
05:54:49 <lambdabot>   mueval-core: Time limit exceeded
05:55:03 <ezyang> > putStrLn "foo"
05:55:04 <lambdabot>   <IO ()>
05:55:33 <hiptobecubic> Cale, alright i suppose that explains a bit :)
05:57:00 <hpaste> aadrake pasted “hmongo” at http://hpaste.org/55876
05:57:51 <aadrake> Can anyone offer some ideas for the processDocs function in http://hpaste.org/55876
06:02:09 <hiptobecubic> It should be possible to add a declaration for Show (->) to be able to print functions, no?
06:02:33 <ezyang> hiptobecubic: Uh.
06:02:35 <hiptobecubic> Not the source, but the type at least?
06:02:46 <ezyang> For one thing, (->) has the wrong kind ;-)
06:02:53 <jdlasd> that would be (Show (a->b))
06:03:07 <jdlasd> :k (->)
06:03:08 <lambdabot> ?? -> ? -> *
06:03:16 <jdlasd> :k (a -> b)
06:03:17 <lambdabot> Not in scope: type variable `a'
06:03:17 <lambdabot> Not in scope: type variable `b'
06:03:26 <jdlasd> urgh
06:04:17 <hiptobecubic> right... but you can get  the def from GHC.Prim
06:04:25 <hiptobecubic> :i (->)
06:04:40 <hiptobecubic> ... or perhaps not. ghci does it
06:04:59 <mike-burns> lambdabot doesn't do @info or :i .
06:05:14 <mike-burns> If that's your biggest let-down of 2011, you're doing well.
06:05:34 <zhulikas> getHomeR :: Handler RepHtml
06:05:39 <zhulikas> how to understand such type signature?
06:05:48 <mike-burns> With :i !
06:05:51 <zhulikas> Handler RepHtml
06:06:13 <mike-burns> :hoogle getHomeR
06:06:19 <mike-burns> @hoogle getHomeR
06:06:20 <lambdabot> No results found
06:06:32 <zhulikas> that's part of yesod
06:06:37 <hiptobecubic> Prelude Data.Ratio> :i (->)
06:06:37 <zhulikas> an example code
06:06:38 <hiptobecubic> data (->) a b 	-- Defined in GHC.Prim
06:07:01 <zhulikas> ok, how should I understand this:
06:07:05 <zhulikas> a :: B C
06:07:05 <zhulikas> ?
06:07:09 <hiptobecubic> So it's a type with two parameters, right? That correspond to the argument and the return type?
06:07:10 <zhulikas> C is type
06:07:20 <zhulikas> C is subtype of B?
06:07:25 <zhulikas> no
06:07:27 <zhulikas> there is no ->
06:07:37 * mike-burns tries to follow the two separate threads.
06:07:45 <hiptobecubic> B is a type which has a parameter i think. which is C
06:07:50 <hiptobecubic> as in "Ratio Integer"
06:07:59 <Renze> hiptobecubic: I came across a nice article about Show (a->b) today somewhere on haskell.org, which explains why it isn't possible
06:08:06 <zhulikas> aaah
06:08:31 <hiptobecubic> A Handler of RepHtmls, if you will
06:08:35 <zhulikas> getHomeR :: Handler RepHtml .... so Handler is actually (Handler a)
06:08:48 <hiptobecubic> I hope that's what it says anyway, otherwise I've learned less than I thought about this.
06:08:55 <zhulikas> hehe :D
06:09:06 <zhulikas> I just didn't see such thing before
06:09:07 <mike-burns> Use :i to find out! In ghci.
06:10:16 <zhulikas> I can't :D
06:10:33 <hiptobecubic> Renze, still have the link?
06:10:52 <Renze> hiptobecubic: http://www.haskell.org/haskellwiki/Show_instance_for_functions
06:10:59 <Sgeo_> :t (a->a->b)->[a]->b
06:11:00 <lambdabot> parse error on input `->'
06:11:08 <Sgeo_> @hoogle (a->a->b)->[a]->b
06:11:09 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
06:11:09 <lambdabot> Data.List foldl1 :: (a -> a -> a) -> [a] -> a
06:11:09 <lambdabot> Prelude foldr1 :: (a -> a -> a) -> [a] -> a
06:12:04 <Sgeo_> Guess there's nothing wrong with writing a manual recursion, right?
06:12:15 <hiptobecubic> Renze, thanks
06:16:59 <hiptobecubic> Renze, that doesn't explain what i want though, or even what they say at the beginning. Why can't show just return a string representation of the type of the function? It must know that much.
06:17:58 <hiptobecubic> as in   show head = "[a] -> a"
06:18:41 <hpc> > fix (show . head)
06:18:45 <lambdabot>   mueval-core: Time limit exceeded
06:20:14 <ClaudiusMaximus> hiptobecubic: for monomorphic functions you can > instance (Typeable a, Typeable b) => Show (a -> b) where show = show . typeOf
06:20:53 <ClaudiusMaximus> hiptobecubic: to get show head = "[a] -> a" you need some polymorphic typeable thing afaict
06:26:24 <ClaudiusMaximus> hiptobecubic: Data.PolyTypeable.polyTypeOf in polytypeable seems to do the trick, but i couldn't get it to work in a Show instance in 5 mins of poking, so i gave up
06:28:27 <parcs`> someone should make an 'sqlite-simple' package :P
06:29:23 <cobra-the-joker_> Hey there every one ... i want to make a function that generates a random *"Int"*
06:30:13 <parcs`> > randomIO :: Int
06:30:14 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
06:30:14 <lambdabot>         against inferred type ...
06:30:23 <Sgeo_> > randomIO :: IO Int
06:30:24 <lambdabot>   <IO Int>
06:30:35 <Sgeo_> :t randomIO
06:30:36 <lambdabot> forall a. (Random a) => IO a
06:30:58 <Sgeo_> > putStrLn "<IO ()>"
06:30:59 <lambdabot>   <IO ()>
06:31:43 * Sgeo_ is not a shachef-level troll
06:32:00 <Sgeo_> Or, well, much of a troll at all
06:58:14 <KorriX> Does anybody have contact with erlang ?
07:00:04 <hughfdjackson> i spoke to him last week
07:00:09 <hughfdjackson> doing alright
07:00:22 <hughfdjackson> wife's out of town for a while, so he's at a loose end
07:03:47 <aadrake> Has anyone else had the experience that examples of Haskell stuff on the web, or in books, are contrived and not necessarily helpful for learning?
07:05:07 <KorriX> aadrake Try learnyouahaskell.com - is good to 'understand' haskell
07:06:21 <mike-burns> aadrake: Yes. 100%.
07:07:30 <aadrake> KorriX: I've gone through a good bit of LYAH, but it wasn't giving me what I need.  It's really great for learning standard library functions though :)
07:07:45 <hughfdjackson> aadrake: there's a tutorial on writing a scheme interpreter
07:07:49 <hughfdjackson> which i honestly struggled with xD
07:08:03 <mike-burns> aadrake: Gotta pick your own project and just do it.
07:08:32 <aadrake> mike-burns: Trying to, but it's hard to do so when example code is fairly far removed from reality
07:08:49 <aadrake> mike-burns: I've been trying to figure out this MongoDB thing for days and now I'm quite stuck
07:09:06 <mike-burns> Oh yeah, that makes sense.
07:09:13 <mike-burns> Did you figure out that thing you hpasted earlier?
07:09:21 <aadrake> mike-burns: No.
07:09:21 <Enigmagic> aadrake: stuck on what?
07:09:23 <KorriX> aadrake: I think, that after 'kick start tutorials' you need to start write sth big. Then you will have problems, and solving it will give you lot of expirience
07:09:52 <aadrake> KorriX: I agree.  I'm trying to write some stuff now, but there aren't really examples for what I want to do and when I try to change it up I get to do battle with the type system :)
07:10:12 <aadrake> Enigmagic: I'm trying to do some stuff with the MongoDB library but having a hard time wrapping my head around it
07:10:48 <Enigmagic> aadrake: ok.. what are you trying to do?
07:10:59 <Enigmagic> we use mongo a lot
07:11:05 <KorriX> aadrake: parsing is very interesting part of IT - try to write your own DSL
07:11:40 <aadrake> Enigmagic: I want to iterate through all the records, concatenate the fields, hash that, and print to stdout
07:12:08 <aadrake> Enigmagic: The problem comes up because I need to use next or nextBatch instead of rest and I'm not sure how to make that work
07:12:34 <KorriX> aadrake: and you realy need to do it inside of query ?
07:12:48 <Enigmagic> aadrake: not sure how to recurse using next?
07:13:01 <aadrake> Enigmagic: It's in the MongoDB library
07:13:25 <darrint> :t fromJust
07:13:25 <lambdabot> forall a. Maybe a -> a
07:13:31 <Enigmagic> aadrake: i know, what problem are you having with next?
07:15:18 <aadrake> Enigmagic: Maybe it would be easier to show the code.  http://hpaste.org/55876
07:15:48 <aadrake> KorriX: I'm not doing this within the query, I need to figure out how to iterate on next or nextBatch so that I can process all the records in the collection.
07:16:28 <statusfailed> Weird, i'm getting this: Ambiguous module name `Control.Monad.Trans'
07:16:41 <statusfailed> what are monads-fd and mtl?
07:17:05 <statusfailed> oh, I should use mtl
07:17:17 <statusfailed> does that mean use ghc-pkg unregister monads-fd?
07:18:17 <dmwit> no
07:18:18 <Enigmagic> aadrake: hang on a sec
07:18:19 <parcs`> no, use the -hide-package monads-fd flag or the PackageImports language extension to resolve the ambiguity
07:18:20 <dmwit> ghc-pkg hide is probably better
07:18:38 <dmwit> The best solution is to use cabal. =)
07:18:40 <parcs`> dmwit: what does that do?
07:19:09 <dmwit> parcs`: It sets a package as "hidden" -- not automatically loaded by GHC(i).
07:19:18 <statusfailed> oops, I removed it...
07:19:21 <dmwit> It's still registered, though, so you can still manually enable it with -package.
07:19:34 <statusfailed> do I need it for anything?
07:19:48 <dmwit> ghc-pkg check will tell you if any other packages broke
07:19:50 <statusfailed> it said only Yi relies on it, which i've removed
07:19:52 <statusfailed> ok
07:20:20 <dmwit> However, ghc-pkg check will not tell you if any executables you installed broke as a result.
07:20:22 <aadrake> Enigmagic: If you can offer advice that would be helpful.  I'd really like to have this working before I leave for the day.
07:20:53 <Enigmagic> aadrake: yeah just i'm also making breakfast :-)
07:22:48 <mike-burns> If I wanted to persist some data while doing the least amount of effort, which library/database/filestore/whatever do you guys recommend?
07:23:04 <aadrake> mike-burns: How much data?
07:23:14 <mike-burns> Small amount.
07:23:19 <Cale> Show/Read?
07:23:21 <Cale> heh
07:23:29 <mike-burns> Yeah that'd probably work.
07:23:30 <Cale> Or cereal
07:23:42 <Cale> (or binary)
07:24:02 <Cale> cereal has somewhat nicer error handling, if you're worried about that
07:24:10 <mike-burns> I do love nice error handling!
07:24:33 <mike-burns> Thanks for the suggestions.
07:25:37 <hpaste> Duffman- pasted “Function composition” at http://hpaste.org/55880
07:26:10 <Duffman-> Hey guys, I have a small question, code snippet can be found at: http://hpaste.org/55880
07:26:45 <Duffman-> I thought the bottom line should do the exact same as the upper one since "." is right associative. But instead, it generates an error ... Am I misunderstanding the big difference between "$" and "." or is there something else I'm not seeing clear?
07:26:51 <Enigmagic> aadrake: maybe something like this? https://gist.github.com/b451dcf118682d994ab0
07:27:02 <mauke> Duffman-: 'zipWith max [1,2] [4,5]' is not a function
07:27:05 <mauke> Duffman-: you can't compose it
07:27:09 <mike-burns> :t replicate 2. product . map (*3) . zipWith max
07:27:10 <lambdabot>     Couldn't match expected type `[a]'
07:27:10 <lambdabot>            against inferred type `[a1] -> [a1]'
07:27:10 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
07:27:17 <mike-burns> :t replicate 2. product . map (*3) . zipWith
07:27:17 <hpc> > zipWith max [1,2] [4,5]
07:27:18 <lambdabot>     Couldn't match expected type `[a]'
07:27:18 <lambdabot>            against inferred type `[a1] -> [b] -> [c]'
07:27:18 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
07:27:18 <lambdabot>   [4,5]
07:27:30 <hpc> :t max
07:27:31 <lambdabot> forall a. (Ord a) => a -> a -> a
07:27:55 <byorgey> Duffman-: ($) and (.) are not interchangeable
07:28:05 <Enigmagic> aadrake: just fill in the hash function..
07:28:09 <mauke> > (replicate 2 . product . map (*3) . zipWith max [1,2]) [4,5]
07:28:10 <lambdabot>   [180,180]
07:28:24 <mauke> now that's a pipeline
07:28:33 <Duffman-> oh I see
07:28:56 <Duffman-> zipwith max [4,5] [1,2] is a function application whereas "." takes functions?
07:29:21 <mike-burns> :t (.)
07:29:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:29:27 <mike-burns> :t ($)
07:29:28 <lambdabot> forall a b. (a -> b) -> a -> b
07:29:37 <mauke> Duffman-: zipwith max [4,5] [1,2] is a list
07:29:44 <aadrake> Enigmagic: Does printDocs ever get used there?
07:29:55 <Duffman-> ok, thanks. Stupid question :(
07:30:00 <Enigmagic> aadrake: no, i didn't delete it though
07:30:04 <Enigmagic> do you want printdocs to work?
07:30:05 <Duffman-> I see where I'm mistaken
07:30:28 <byorgey> Duffman-: it wasn't a stupid question.
07:30:32 <aadrake> Enigmagic: Ideally, yes :)
07:30:42 <Duffman-> :)
07:30:47 <aadrake> the hash of the doc should be printed
07:32:07 <aadrake> Enigmagic: I think I see where I was confused
07:33:25 <Enigmagic> aadrake: you should be able to stick a liftIO (print ...) in the hashDocs function
07:33:48 <aadrake> Cool, I'll keep working on it.  Thank you for the help.
07:34:18 <Enigmagic> np
07:35:34 <aadrake> Enigmagic: Are you going to be around for a while?  I may have follow-up questions as I try to work through this.
07:36:47 <Enigmagic> aadrake: i'll be around all day, but i might not being paying attention to irc
07:37:37 <Enigmagic> i'll respond to PMs eventually though
07:40:10 <aadrake> Enigmagic: I'm curious about Just doc -> hashDocs (hash seed doc) cursor.  Does that mean that the hash of one doc becomes the seed for the next?
07:41:59 <Enigmagic> aadrake: if you only want to hash each doc individually then just ignore that bit
07:43:28 <aadrake> Enigmagic: Yes, I'm looking to output the hash of each individual document.
07:44:50 <aadrake> Enigmagic: I may get rid of the seed and just use the cursor as the only argument
07:44:58 <Enigmagic> aadrake: that's what i'd do
07:45:10 <Enigmagic> i thought you were trying to hash all the docs together :-)
07:45:31 <aadrake> Enigmagic: Nope.  What do I return in that case?
07:46:14 <Enigmagic> if you're just calling print, then return ()
07:46:31 <Enigmagic> if you want to build up a collection, it might be a good idea to stick them in a Set or a list
07:47:01 <aadrake> Enigmagic: Right now, I'm just calling print
07:47:28 <Enigmagic> () would be the simplest thing for now
07:48:48 <hughfdjackson> :P just to throw out a stupid revelation of mine
07:49:16 <hughfdjackson> foo = 3 * 3 <-- foo is a function that takes no params
07:49:18 <mike-burns> People sure are down on themselves today.
07:49:26 <hughfdjackson> foo <-- returns 9
07:49:44 <hughfdjackson> foo looks like a data point, but it's really just a function, right?
07:49:45 <hpc> hughfdjackson: it's not a function, it's a value
07:49:47 <Enigmagic> foo is the value 9
07:49:49 <hughfdjackson> ah, damnit
07:49:50 <hpc> functions are values
07:49:51 <merijn> Hugglesworth: Not true, though
07:49:54 <hpc> values are not functions
07:49:54 <hughfdjackson> wait
07:49:58 <hughfdjackson> okay
07:50:00 <hughfdjackson> damnit
07:50:03 <hpc> sqrt -- function and value
07:50:06 <hpc> 5 -- value
07:50:21 <merijn> hughfdjackson: The key inside is that there is no such thing as a function declaration. Only name-value bindings
07:50:21 <hpc> functions are values with type (a -> b) for some a, b
07:50:30 <merijn> It's just that functions happen to be values too
07:50:33 <mike-burns> Functions have a type with (->) in it.
07:50:37 <mike-burns> Oh hpc just said that.
07:50:47 <hughfdjackson> okay :)
07:50:53 <merijn> s/inside/insight
07:51:00 <merijn> Sometimes I hate my brain
07:51:16 <ion> It’s okay, we hate your brain, too.
07:51:25 <mike-burns> Braaaaaains.
07:52:12 <merijn> hughfdjackson: For a more in-depth discussion why values are not nullary functions: http://conal.net/blog/posts/everything-is-a-function-in-haskell
07:52:25 <hughfdjackson> merijn: :D cheers
07:52:29 <aadrake> Enigmagic: It's pretty close now, just trying to figure out the printing
07:52:37 <hpc> conal.net suffers from perpetual slowness
07:52:43 <hpc> it's very strange
07:52:46 <merijn> Yeah
07:52:51 <mike-burns> Haskell can't scale.
07:52:54 <merijn> It was dog slow when I just went there
07:53:18 <hpc> it's not like it's hard to make a website load quickly either :/
07:53:29 <mike-burns> Hah.
07:53:46 <hughfdjackson> merijn: :| the first two paragraphs sum me up to a T
07:54:08 <hughfdjackson> it'd just be really elegant if they were ;) you know a sort of all-encompassing zen-like warm-fuzzy-feeling-inside type thing
07:54:46 <merijn> You can still have that feeling about values :p
07:54:53 <hughfdjackson> hehe
07:55:04 <hughfdjackson> i'm sure they'll endear themselves to me xD
07:55:07 <merijn> (Well, not entirely because types are not values, unfortunately :p)
07:55:10 <aadrake> Enigmagic: liftIO $ (print . md5 . runPut . putDocument) mDoc doesn't seem to work
07:55:14 <mike-burns> It's probably more important to believe that everything has a value.
07:55:17 <hpc> merijn: "everything is a value, except for the things that are types"
07:55:20 <hpc> :P
07:55:48 <hpc> and with new GHC extensions, you get "everything is a value, except for the things that are types, except when values are being used as types"
07:55:52 <Enigmagic> aadrake: it doesn't print anything or it doesn't print the right thing?
07:55:52 <hpc> or something like that
07:55:55 <merijn> hpc: Time to go back to learning Agda so I can just say "everything is a type" :p
07:56:01 <hpc> :D
07:56:18 <hughfdjackson> merijn: out of interest, since this blog mentions #haskell, whose is it? ^^
07:56:18 <merijn> It's types all the way down!
07:56:27 <hpc> hughfdjackson: conal's
07:56:31 <aadrake> Enigmagic: Type error when I compile
07:56:33 <hpc> preflex: seen conal
07:56:34 <preflex>  conal was last seen on #haskell 1 day, 21 hours, 15 minutes and 13 seconds ago, saying: roconnor: yeah -- wow!
07:56:42 <Enigmagic> aadrake: what's the error?
07:56:42 <hughfdjackson> ooh ^_^ okay
07:56:46 <hpc> :P
07:56:51 <aadrake> Enigmagic: Couldn't match [Field] with Maybe Document
07:57:15 <aadrake> I think it's because mDoc is a list of fields but the cursor has type Maybe Document
07:57:24 <Enigmagic> aadrake: you need the case statement from the example i pasted... and use 'doc' instead of 'mDoc'
08:00:22 <aadrake> Enigmagic: I have the case statement, but if I put the printing inside it I'm not sure where it would go.  Just doc -> print and then hasDocs cursor
08:00:25 <aadrake> ?
08:00:52 <Enigmagic> yep
08:01:09 <Enigmagic> you can stick a 'do' block in there too if it makes it easier to write
08:02:02 <aadrake> Enigmagic: It's the and part that gets me.  How do you do two things in one line of the case statement?
08:02:20 <aadrake> Enigmagic: I guess adding a do block is possible
08:02:54 <mzero> do { thingA; thingB }      or     thingA >> thingB
08:03:58 * mzero guessing, as I just dropped in... :-)
08:04:19 <Enigmagic> yup :)
08:04:59 <aadrake> mzero: Yes
08:05:02 <aadrake> mzero: Thank you
08:05:20 <mzero> remember that >> can be chained    thingA >> thingB >> thingC
08:05:35 <mzero> though at some point a do block is easier to read
08:06:56 <aadrake> mzero: It's good to have options
08:07:08 <aadrake> Enigmagic: It's all working now.  Thank you again for helping.
08:07:15 <drdo> If i read from a handle using hGet and then getContents, do the contents have what i read before?
08:08:32 <mzero> dodo , you mean if you read from stein via hGet... then read via getContents?   No, I'm pretty sure you'll only get what is left of the input with getContents at that point
08:08:44 <mzero> er, drdo  --- silly auto compleation!
08:08:48 <hpc> @src getContents
08:08:48 <lambdabot> getContents = hGetContents stdin
08:08:51 <drdo> alright, cool, that's what i wanted
08:08:57 <hpc> @src hGetContents
08:08:58 <lambdabot> Source not found.
08:09:00 <hpc> pah
08:09:02 <Enigmagic> aadrake: sweet
08:10:44 <aadrake> Enigmagic: I'll let you know what the speedup is over the same solution in R.  I'm hoping for a significant difference
08:18:39 <Enigmagic> aadrake: yah lmk
08:19:16 <aadrake> Enigmagic: The first run was much faster.  The R version was 4627 seconds and the Haskell version was 450 seconds.
08:19:45 <hpc> aadrake: i call that a win
08:19:51 <aadrake> Enigmagic: I'm running it again after recompiling with optimizations.
08:20:08 <mike-burns> It produces the same values?
08:20:29 <aadrake> hpc: Indeed.  The bigger difference was outputing the records to CSV and then parsing that with Haskell.  That took only 108 seconds.
08:21:17 <aadrake> mike-burns: If I bothered to strip some brackets from the Haskell output before hashing, then yes.
08:21:59 <aadrake> mike-burns: Right now I'm just looking at how fast I can iterate and hash
08:23:37 <hpaste> Renze pasted “Random doesn't work” at http://hpaste.org/55882
08:23:58 <Renze> Does anybody know why this doesn't work? My ghci crashes when I try it. http://hpaste.org/55882
08:24:00 <Botje> :t getStdRandom
08:24:00 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
08:24:14 <Renze> It is typecorrect
08:24:20 <Botje> Renze: what do you mean by 'crashes' ?
08:24:39 <Renze> if i try: randomDay <ENTER>, then it shuts itself down
08:24:40 <Botje> did you (random guess) forgot to add a deriving Show to the definition for Day ?
08:24:55 <Renze> No, it has deriving (Show, ..)
08:25:11 <Renze> But that should give a error like: no Show instance of Day
08:25:32 <byorgey> Renze: what version of ghc?
08:25:46 <Renze> To be precise: data Day = Monday | Tuesday | Wednesday | Thursday | Friday deriving (Eq, Show, Enum)
08:25:48 <Botje> Renze: works for me
08:25:56 <Renze> 6.12.3
08:26:32 <Renze> Hmm, that could be the problem I guess
08:27:03 <byorgey> Renze: hmm, I just tried it with 6.12.3 and it works for me
08:27:10 <W_Blas> I need to define a ternary tree in Haskell. I'm considering using lists now, but is there something like structures in Haskell?
08:27:12 <byorgey> Renze: can you hpaste the exact .hs file you are using?
08:27:18 <hpc> the version of ghc shouldn't matter for something so simple
08:27:21 <byorgey> Renze: it sounds like a bug though
08:27:27 <mike-burns> W_Blas: There are records, and there's also all of Hackage.
08:27:31 <aadrake> Enigmagic: Do you think it is possible to do some parallelization with this method or does the fact that we are using a single cursor prevent that from being possible?
08:27:45 <byorgey> hpc: eh? why not? If it's a bug in ghc then it definitely matters
08:28:01 <Renze> The file is kind off.. large
08:28:14 <mzero> wishes that parsec had versions of sepBy, EndBy and sepEndBy that returned the separator as well....
08:28:17 <ClaudiusMaximus> perhaps something corrupted the random number generator state (eg:  getStdRandom (\g -> (42, fix error))  )
08:28:17 <Enigmagic> aadrake: if you have a way of partitioning the documents... you could have multiple cursors
08:28:22 <Renze> It are 7 at the moment, ~50kb, so that'll mean loads of extra information
08:28:30 <byorgey> Renze: ok, never mind
08:28:35 <Renze> But I'll try it in a separate file first, see if that solves the problem
08:28:40 <hpc> aadrake: or you can have a single cursor and forkIO the processing of each one
08:28:59 <byorgey> Renze: anyway, if ghci crashes it is a bug in ghci.  It should never crash, no matter what code you give it.
08:29:08 <mike-burns> W_Blas: http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Tree.html
08:29:09 <aadrake> hpc: The processing is pretty limited, just md5
08:29:17 <hpc> byorgey: even crashy segfault code?
08:29:18 <Lemmih> byorgey: Really?
08:29:43 <hpc> if gtk causes a segfault, i expect it to segfault ghci
08:29:45 <byorgey> unless you are using unsafePerformIO or something like that
08:29:49 <hpc> unless some deep magic is happening
08:29:54 <byorgey> or FFI calls to something that segfaults
08:30:14 <Renze> No, I already removed my unsafePerformIO because I thaught that caused the problem, but it didn't
08:30:21 <W_Blas> mike-burns: Unfortunately I have to define my own tree.
08:30:32 <byorgey> Renze: 6.12.3 is a bit old at this point, you may want to upgrade to the latest Haskell Platform anyway
08:30:48 <mike-burns> W_Blas: I understand; we must all go on these vision quests.
08:31:07 <Renze> byorgey: I know, but there was a problem with 7 which I can't recall, I think it had something to do with profiling
08:31:30 <aadrake> mike-burns: Taking it back
08:31:39 <W_Blas> mike-burns: Maybe there is a sort of variant records like in Pascal as well?
08:31:52 <mike-burns> W_Blas: I don't know Pascal, but there are records in Haskell.
08:32:09 <mike-burns> If you search the Web for them you'll find people complaining about their syntax.
08:32:23 <monochrom> pascal variant record = c union
08:32:39 <mike-burns> What's that mean in Haskell?
08:32:44 <Renze> byorgey: It works in a separate file with only import System.Random, data Day = ..., randomDay = ...
08:33:03 <mike-burns> W_Blas: http://goo.gl/0GDU - Records in Haskell.
08:33:03 <W_Blas> mike-burns: A similar concept is called union in C
08:33:05 <monochrom> actually, approximately
08:33:35 <monochrom> in any case, both are unchecked versions of "data R = Case1 ... | Case2 ..."
08:33:42 <mike-burns> Ah.
08:34:25 <monochrom> pascal variant record provides more help for you to check manually, but not automatically like haskell
08:34:42 <monochrom> ("more help" compared with C union)
08:34:44 <byorgey> Renze: definitely sounds like a bug then.  If function X works when on its own, it should not make ghci crash when it happens to be embedded in a larger module.
08:34:46 <hpc> it's kind of like data R = R V1 V2 ...; makeR v = R (coerce v) (coerce v) ...
08:34:51 <hpc> even
08:35:11 <byorgey> I don't think anyone can argue with that, even if the larger module happens to involve unsafePerformIO or FFI or whatever.
08:35:25 <Renze> What is FFI?
08:35:35 <hpc> foreign function interface
08:35:39 <ksion> Foreign Function Interface; bindings to C, basically.
08:35:42 <hpc> it's how you call C code and stuff
08:36:08 <aadrake> I'm out for the day.  Have a good new year all.
08:36:12 <aadrake> Enigmagic: Thanks again for your help
08:38:27 <Renze> byorgey: if I try getStdRandom $ randomR (0,4) directly in ghci, it works fine
08:38:42 <byorgey> Renze: as it should
08:38:53 <Renze> When I havel oaded all the modules
08:39:20 <Renze> Could reinstalling ghci work?
08:39:43 <byorgey> Probably not, but who knows?
08:39:45 <Botje> this is probably not a ghci problem.
08:39:56 <Botje> Renze: have you tried attaching gdb to your ghci process?
08:39:58 <mike-burns> Or more than just a ghci problem.
08:40:09 <Botje> maybe you can locate the library that's crashing
08:41:49 <Renze> Botje: I have no idea what gdb is, so I'll figure it out while reinstalling ghci just to be sure that doesn't fix it
08:43:23 <byorgey> gdb is the GNU debugger
08:43:52 <byorgey> if you haven't even heard of it then using it to locate the library that's crashing is likely to be difficult.
08:47:23 <merijn> On the other hand, if you expect to program for the rest of your life, investing a week to learn GDB is probably very useful :p
08:48:40 <byorgey> on the other other hand, if you expect to program for the rest of your life in Haskell, it probably isn't.
08:48:57 <monochrom> expect to program python, php, java, and c# for the rest of my life
08:49:05 <Renze> I never planned to program the rest of my life and I don't have a week time
08:49:06 <Botje> ..unless you have to debug FFI libs!
08:49:09 <hpc> on the other other hand, you should be able to reason about program behavior without a debugger
08:49:26 <mike-burns> GDB is super useful if you write a ton of C code.
08:49:35 <mike-burns> ... I've used GDB once.
08:49:39 <Renze> I have 4 days, 5 hours and 34 minutes left, so a week doesn't fit in my planning
08:49:48 <monochrom> debugger is for figuring out someone else's code
08:49:49 <byorgey> hehe
08:50:12 <W_Blas> How do I access n-th list element?
08:50:20 <byorgey> Renze: well in that case I'm especially sorry you seem to have run into a GHC bug. =(
08:50:26 <mike-burns> W_Blas: (!!) , but you probably don't want to.
08:50:26 <Renze> W_Blas: list !! n
08:50:31 <monochrom> xs !! n
08:50:41 <W_Blas> Thanks!
08:50:53 <ksion> You don't want to because it's O(n).
08:51:07 <merijn> ksion: Also because it's unsafe
08:51:09 <mike-burns> You don't want to because your algorithm is wrong.
08:51:13 <monochrom> but you don't know what W_Blas is doing.
08:51:32 <mike-burns> I do know that W_Blas didn't know about `data' or records 20 minutes ago.
08:51:33 <ksion> merijn: Well, it's as 'safe' as using head on list that can possibly be empty.
08:52:09 <W_Blas> I just want to compare and sort lists by 2nd element
08:52:32 <byorgey> W_Blas: and why do you want to do that?
08:52:36 <monochrom> xs!!2 is O(1)
08:52:45 <Renze> byorgey: It wouldn't be that much of a problem if it just was a normal assignment in which the code actually matters, in which case the teacher could still give a 'acceptable' grade, but... I don't think my teacher knows Haskell as much as I do (and I'm not even an expert), because the assignment was just: solve the problem, and reason about the results.
08:53:20 <ksion> monochrom: Is !! 0-based or 1-based?
08:53:28 <Renze> 0
08:53:52 <ksion> So that would be xs!!1. Still, I'd rather pattern-match to extract 2nd element.
08:54:29 <mike-burns> W_Blas: I think you want a tuple or a record, not a list.
08:54:43 <merijn> monochrom: xs!!n is O(1) (in the input size) for any n >.>
08:55:33 <mike-burns> (!!)'s performance is barely why it's not appropriate to use most of the time!
08:56:45 <mike-burns> W_Blas: Also, perhaps you could use a pattern match to achieve the (!!) instead.
08:56:46 <hpc> merijn: as n approaches infinity, (xs !! n) approaches undefined? :P
08:57:14 <mzero> W_Blas: if you find yourself with lists like [ data, key ]  what you probably want is (data, key)
08:57:34 <mzero> this is because with the list form, you aren't garunteed at compile time, by the type system, to always have a data and a key
08:57:42 <mzero> whereas with the tuple form, you can't make a mistake!
08:57:52 <merijn> mzero: Sure you can :)
08:57:57 <mzero> (and sure, tuples work for any given n)
08:58:08 <merijn> undefined :)
08:58:17 <merijn> Also, I think tuples are restricted to a length of 63
08:58:25 <mzero> merijn: I don't think this the time for type gymnastics .... :-)
08:58:25 <merijn> Or at least the tuple functions are
08:58:31 <hpc> i thought it was 62
08:58:33 <mzero> and sure, tuples beyond 8 are asking for trouble
08:58:37 <hpc> in any event, never use tuples larger than 2
08:58:49 <mzero> not from Haskell, but from other programmers (including your future self, which is another programmer!)
08:58:50 <W_Blas> mzero: Do you mean (hash) map?
08:59:04 <mzero> Not neccissarily
08:59:06 <merijn> hpc: Well, 3-4 might be useful for points
08:59:23 <mzero> I don't know what you are doing, but when you are explicitly always working with the 2nd element of list, it "smells wrong"
08:59:32 <hpc> merijn: i would rather use a data structure
09:00:20 <mzero> because if the values in the list have positional meaning -- that is, something like "the 1st is the name, and the 2nd is the place, and the 3rd is warning level"   ---- that isn't a good candidate for a list
09:00:28 <hpc> data Point = Point {x :: Double, y :: Double, z :: Double} -- a strong type and helpful syntax/functions for free
09:00:51 <mike-burns> W_Blas: You're building a ternary tree from scratch? Can you hpaste the data structure you've built?
09:01:26 <mike-burns> @paste
09:01:27 <lambdabot> Haskell pastebin: http://hpaste.org/
09:02:17 <W_Blas> mike-burns: A single row is sufficient: data Node = Node { child :: [Node], payload :: [Integer] }
09:02:53 <W_Blas> "payload" is needed for my problem.
09:02:58 <byorgey> that looks like a rose tree, not a ternary tree.
09:03:13 <byorgey> in which case you might as well use  Data.Tree .
09:03:33 <byorgey> Node is exactly equivalent to  Tree [Integer].
09:03:37 <rwbarton> I used a 4-tuple recently
09:04:05 <rwbarton> I wanted to find the position of the first local maximum in a list so I wrote something like  zip4 [0..] xs (drop 1 xs) (drop 2 xs)
09:04:28 <byorgey> W_Blas: but if you really want to enforce that it is a ternary tree, then you should do something like   Node = Empty | Node { children :: (Node, Node, Node), payload :: [Integer] }
09:06:01 <Renze> Well, I found the problem. I imported all of the packages which are imported in another module in my testfile (with only import System.Random, data Day = .., randomDay = ...), and it crashes
09:06:19 <Renze> So I'll now check which import causes the problem
09:06:19 <mzero> quick question, W_Blas, is this a problem set? (want to know which way to help)
09:06:28 <byorgey> Renze: ah, interesting
09:06:44 <mzero> also, when you were asking about !! were you using it to index the [Node] list or the [Integer] list?
09:06:51 <byorgey> Renze: I await the result with a combination of interest and trepidation
09:07:41 <Renze> import qualified Data.ByteString.Char8 as B (readFile)
09:07:48 <Renze> and also simplified: import Data.ByteString.Char8
09:09:16 <byorgey> Renze: so you have a module with just  import System.Random; import Data.ByteString.Char8; data Day = ...; randomDay = ...  ?
09:09:47 <Renze> byorgey: yes
09:09:51 <byorgey> and then you load it into ghci by typing   ghci Foo.hs  and then evaluate 'randomDay' and it crashes?
09:10:24 <W_Blas> mzero: In short, I need to create a ternary tree (payload is in leaves only), then parse a tree putting all the payloads into list and then soft the list by the second element.
09:10:33 <W_Blas> * sort
09:10:39 <Renze> Not typing anything, I'm using Windows. I do: test.hs -> Open with -> ghci
09:11:02 <byorgey> Renze: ok, fair enough
09:11:03 <Renze> and then evaluating randomDay, yes
09:11:08 <mzero> so, the payloads must have a 2nd element? can they have any number of Integers beyond 2?
09:11:36 <byorgey> Renze: interesting.  I just tried it myself (also with ghci-6.12.3) and it works fine, it does not crash.
09:11:41 <byorgey> but I am on linux.
09:12:05 <Renze> byorgey: which version of ByteString do you have?
09:12:35 <byorgey> 0.9.1.7
09:12:43 <byorgey> good question
09:12:48 <Renze> I have 0.9.2.0
09:13:08 <byorgey> ok, let me try that, just a second
09:13:22 <mzero> (I'm also wondering -- are you putting them into the tree in order to sort them? Otherwise, why put them into the tree, then pull them out into a list again before sorting?)
09:13:23 * hackagebot parsec-tagsoup 0.1 - Parsec parsers for Tagsoup tag streams  http://hackage.haskell.org/package/parsec-tagsoup-0.1 (PepeIborra)
09:14:18 <W_Blas> mzero: I already have a tree.
09:14:32 <W_Blas> I need to process it.
09:15:24 <mzero> so, you're going to walk the tree, pulling out the payloads into a list, then sort the list ... only you want it sorted on the second element of the payload lists, correct?
09:16:55 <byorgey> Renze: still no crash for me with bytestring-0.9.2.0
09:17:08 <Renze> Ok, this is strange. I tried to go back to 0.9.1.7 with cabal install bytestring-0.9.1.7 --reinstall, and now Random nor System.Random is found
09:18:17 <byorgey> Renze: if you open a command prompt and type  ghc-pkg check, do you get any output?
09:19:41 <Renze> byorgey: Yes, random is over there, but reinstalling random also doesn't work (some win32 package can't install because he has permissions errors when deleting a non-empty map).
09:20:48 <Renze> I'm installing Haskell Platform 2011.4.0.0 now, maybe that fixes it, or else I'll format my computer...
09:21:06 <Renze> Wasting time on this doesn't seem to fix it, as I already tried some other things a couple of day ago
09:21:21 <byorgey> heh, no need to format your computer =)
09:21:35 <Renze> It works.
09:21:40 <byorgey> hehe
09:22:00 <Renze> I assumed the problem lied in cabal (I really don't like cabal so I'll also say the fault is in there)
09:22:58 <mzero> W_Blas:    map snd $ sort [ (k, p) | p@(_:k:_) <- payloads ]
09:22:59 <hpc> i hated cabal too, until this morning
09:23:06 <hpc> Renze: the trick is to --global EVERYTHING
09:23:16 <hpc> per-user packages are evil
09:23:19 <byorgey> what!
09:23:25 <dino-> Anyone here use gitit? Just installed it and when I make a page link like [Foo]() as the docs suggest, it produces a tag like: <a title="Go to wiki page">Foo</a>
09:23:26 <mzero> but that will drop all lists with fewere than two elements on the floor
09:23:27 <Renze> hpc: I only use one account
09:23:30 <dino-> And no href attr at all.
09:23:33 <rwbarton> let's see how much you like cabal in a week
09:23:42 <mzero> and does a secondary sort on the whole payload (if the 2nd elements match)
09:23:49 <dino-> Am I doing this wrong? I see other links in this very page (the Front Page) that follow this empty ( ) format and link somewhere.
09:23:58 <mzero> all that said, payload looks like the wrong type for the data it holds
09:26:29 <byorgey> Renze: don'the usual advice is to leave the stuff that comes with the Platform in your global package DB, and then install everything --user.
09:26:46 <byorgey> that way you can easily delete just the user DB if it becomes screwed up, without having to reinstall the whole platform.
09:26:52 <W_Blas> mzero: Thanks!
09:31:26 <dino-> Hm, I think it's more breakage due to me putting this behind a proxy with apache. Gitit seems to have a lot of trouble with this. Had to already fix the Login/Logout js template for it.
09:31:59 <dino-> When I try a wiki link using the demo gitit server, all behaves normally. Just not on my own system.
09:40:05 <asda8> is there a haskell package for statistics (with methods to calculate mean, median, standard deviation, quartiles, chronbach's alpha, etc.)?
09:40:43 <hpc> asda8: probably; there should be a statistics category on hackage that you can look at
09:40:52 <byorgey> @package statistics
09:40:52 <lambdabot> http://hackage.haskell.org/package/statistics
09:41:06 <byorgey> that package is supposedly really good although I have not used it myself.
09:42:50 <asda8> hpc: i've checked them out, but can't find what I need
09:43:59 <asda8> hpc: hstatistics comes closest, but still only a few methods of what I would need
09:45:37 <aadrake> asda8: I just got back, what are you looking for exactly?
09:45:58 <hpc> 13:17 < asda8> is there a haskell package for statistics (with methods to calculate mean, median, standard deviation, quartiles, chronbach's alpha, etc.)?
09:47:17 <aadrake> asda8: Right.  I'm not sure if it has everything you need but there is a statistics package available
09:47:28 <asda8> well they are not very hard to implement anyway, just thought there is a ready-to-go package which is tested well and performant
09:47:49 <aadrake> asda8: Try cabal install statistics
09:48:24 <aadrake> asda8: It contains various distributions and tests
09:48:36 <dino-> hpc: I do that too, set global as default in cabal conf. Use --user occasionally for development.
09:49:16 <asda8> aadrake: yeah, maybe Statistics.Sample will do. thanks!
09:50:54 <asda8> hm, what is this Vector typeclass? can I use these functions with lists?
09:53:32 <aadrake> asda8: I have no idea
09:58:31 <asda8> aadrake: seems like it, Data.Vector has a fromList function which works
10:12:11 <int80_h> what is the operator that is like ($) but goes left to right?
10:15:04 <hpc> int80_h: as in associates differently, or as in (flip ($))?
10:15:12 <hpc> the latter is generally called (#)
10:31:23 <int80_h> hpc: the latter, thanks :)
10:46:49 --- mode: pratchett.freenode.net set +o ChanServ
10:47:14 <aadrake> Is there an easy way to update GHC on Mac OS to 7.4 or do I need to build from source?
10:48:47 <mdmkolbe> Where is the appropriate place to submit feature requests so they will actually get seen?  Is it <http://hackage.haskell.org/trac/ghc/report> ?  (The request is about generalizing "[| ... $( ... ) ... |]" to arbitrary instances of "Quasi" instead of just the "Q" type.)
10:49:22 <mdmkolbe> (As it stands, I'm hacking around it by using an IORef (ugh!))
10:49:59 <hpc> mdmkolbe: check the info on the TH package; it might have more specific contact info
10:50:07 <hpc> @hackage template-haskell
10:50:07 <lambdabot> http://hackage.haskell.org/package/template-haskell
10:50:42 <hpc> libraries@haskell.org
10:51:02 <aadrake> Is there an easy way to update GHC on Mac OS to 7.4 or do I need to build from source?
10:53:54 <SilverFang> Hello all.
10:54:51 <mdmkolbe> Does libraries@haskell.org have any particular customs I should be aware of?  (I notice a lot of "Proposal: ..." messages, but see no pattern to them.)
10:55:12 <dmwit> mdmkolbe: Yes, there's a process on the wiki.
10:55:28 <dmwit> http://www.haskell.org/haskellwiki/Library_submissions
10:55:32 <byorgey> aadrake: 7.4 is not released yet, but you can see if there is an installer at http://www.haskell.org/ghc/dist/7.4.1-rc1/
11:07:11 <mekeor> @src (#)
11:07:12 <lambdabot> Source not found. Do you think like you type?
11:07:22 <mekeor> @hoogle (#)
11:07:22 <lambdabot> keyword #
11:07:22 <lambdabot> GHC.Exts C# :: Char# -> Char
11:07:22 <lambdabot> GHC.Exts D# :: Double# -> Double
11:13:03 <mzero> # is a "sepcial" identifier character
11:13:30 <mzero> it is used by GHC to name "internal" things - and normally isn't available for use (Haskell's identifiers don't include #)
11:18:59 <hpc> mzero: it's available as a symbol if you don't turn on magic hash
11:19:13 <mzero> ah - good point
11:19:18 <mzero> though one doesn't see it much!
11:19:25 <mzero> well, maybe in code golf
11:19:32 <hpc> and possibly even with - it could mess up parsing rules
11:19:39 <hpc> mzero: and in polyglots
11:19:53 <hpc> as a comment with functional code after it
11:36:01 <aadrake> So when I update GHC, I have to cabal-install all my libraries again?
11:36:52 <byorgey> aadrake: yes.
11:37:11 <byorgey> because they have to be recompiled with the new GHC.
11:37:49 <aadrake> byorgey: I figured that, but what of packages that cannot be recompiled?
11:38:22 <aadrake> byorgey: For example, bson wouldn't compile.
11:38:57 <byorgey> aadrake: well, many packages still need to be updated to cowork with ghc 7.4
11:39:11 <aadrake> byorgey: I guess it just isn't GHC 7.4 compatible right now
11:40:13 <byorgey> sometimes it is for simple reasons like specifying an upper bound for the 'base' package that can be relaxed once it has been tested with the new version of base
11:41:14 <byorgey> you can try fixing it youself by (1) cabal unpack bson (2) cd bson (3) get it to compile (4) increment the version number in bson.cabal (5) cabal install
11:42:11 <aadrake> byorgey: I emailed the maintainer.  I've been conversing with him on another library so I figured he would want to know.
11:42:27 <byorgey> sure
11:44:07 <hughfdjackson> as a semi OT question, what projects are you working on?
11:44:22 <hughfdjackson> ^_^ want to get a little feel for what the haskell scene is like, beyond being a really interesting language
11:46:38 <aadrake> byorgey: How can I compile the library locally?  Do I just ghc filenameOfLibrary.hs?
11:49:39 <aadrake> byorgey: Nevermind.  I found a tutorial
11:51:24 <roSievers> Hi, I need some higher order function that will apply a simple function n times "(a -> a) -> Int -> a"
11:51:43 <roSievers> is there some function to do that for me?
11:52:31 <roSievers> oops, should be "(a -> a) -> Int -> a -> a"
11:52:42 <aadrake> roSievers: How about map and replicate?
11:53:35 <aadrake> >map (replicate 3) [3..6]
11:53:37 <RandySavage25> roSievers, have you gotten Haskell to work on Android yet???
11:54:06 <rwbarton> @type \f n x -> iterate f x !! n
11:54:07 <lambdabot> forall a. (a -> a) -> Int -> a -> a
11:54:28 <byorgey> aadrake: which tutorial?
11:54:39 <roSievers> RandySavage25: I didn't do anything with android
11:55:15 <byorgey> aadrake: you can 'cabal build' just to test whether it compiles
11:55:23 <byorgey> aadrake: or 'cabal install' to build and install it
11:55:32 <aadrake> byorgey: Not really a tutorial, just some documentation http://www.haskell.org/ghc/docs/7.0.2/html/Cabal/builders.html
11:55:42 <aadrake> byorgey: The bigger problem is that now ghci produces a segfault
11:55:52 <aadrake> byorgey: After updating to 7.4
11:55:54 <byorgey> aadrake: oh, don't use the runhaskell Setup stuff
11:56:05 <byorgey> cabal does that for you
11:56:35 <aadrake> byorgey: Doing it the cabal way now
11:56:51 <aadrake> byorgey: I'm not sure how to fix the issue though.  The error message was fairly long
11:57:16 <byorgey> aadrake: if you paste the error message on hpaste I can take a look
11:57:34 <byorgey> no promises, but I've updated several packages for 7.4 and might have some ideas
11:57:56 <hpaste> aadrake pasted “bson error” at http://hpaste.org/55890
11:58:37 <aadrake> http://hpaste.org/55890
12:02:40 <aadrake> byorgey: Is that message saying it should be showHex (show n)?
12:02:53 <byorgey> let me look, just a second
12:03:12 <byorgey> ah yes, the 'Num' class used to have 'Eq' and 'Show' as superclasses, but does not anymore
12:03:37 <byorgey> you just need to change the type signature of showHexLen to (Integral n, Show n) => ...
12:03:43 <Enigmagic> which broke a lot of packages..
12:04:10 <byorgey> aadrake: note that the 'possible fix' suggests doing exactly that
12:04:34 <byorgey> Enigmagic: of course it did, but it's the Right Thing (tm)
12:04:47 <aadrake> byorgey: I noticed that
12:05:05 <byorgey> Haskell has a long history of choosing the Right Thing (tm) over backwards compatibility
12:05:05 <aadrake> byorgey: What's the standard procedure for submitting the fixed version?  Do I leave that to the maintainer or is it something anyone can do?
12:05:15 <Enigmagic> byorgey: yeah, well maybe they'll do the right thing everywhere else too ;)
12:05:23 <byorgey> Enigmagic: yes, I hope so =)
12:05:53 <byorgey> aadrake: you should leave it to the maintainer to actually upload a new version, but you are encouraged to send the maintainer a patch with the fixes
12:10:29 <aadrake> byorgey: There's also an error when trying to install the mongodb library: cabal: cannot configure monad-control-0.2.0.3. It requires base >=3 && <4.5
12:10:51 <aadrake> byorgey: Then a long list of all the versions of base that were excluded for various reasons :)
12:12:24 <aadrake> byorgey: I have version 4.5 installed but the mongodb package requires strictly less than 4.5.  Is that normal behavior?  It makes more sense to me to just require versions greater than some number instead of bounding the potential versions.
12:12:58 <BrianHV> I'm trying to build plugins-auto, which depends on plugins, the latter of which won't build on 7.2. plugins has Don Stewart listed as the maintainer. is he the sort who would respond to a personal email about that, or would it be better to post to cafe or SO or something?
12:13:12 <byorgey> aadrake: this is normal.
12:13:19 <byorgey> aadrake: base-4.5 comes with ghc 7.4.
12:13:58 <byorgey> aadrake: often people list an upper bound because they want to be able to test with the new version of base when it comes out, rather than having the package just break
12:14:31 <byorgey> aadrake: opinions actually differ about best practices here for base in particular. usually packages will work just fine with the newer version of base.
12:15:15 <luite> I think upper bounds do more harm than good usually....
12:15:25 <aadrake> byorgey: I just unpacked and made the change in the .cabal file.  Hopefully that's all it takes.  Poor Tony is going to have a flood of emails from me.
12:15:30 <aadrake> luite: I agree
12:15:47 <byorgey> aadrake: yes. don't forget to increment the version number of the package you edited as well
12:15:54 <byorgey> e.g. from 0.2.0.3 to 0.2.0.3.1
12:15:54 <Enigmagic> aadrake: you'll also want to bump the version number, i usually just add a .0 to the end
12:16:15 <byorgey> otherwise cabal sometimes gets confused and tries to install it from Hackage anyway, instead of using your edited version
12:16:35 <luite> I'm not sure what the right solution is, but if we want to keep upper bounds, there must probably be some easier way to override them. perhaps some wiki-like overrides file on hackage that can be quickly edited to resolve problems
12:16:49 <byorgey> luite: that might be a good idea.
12:17:19 <byorgey> luite: personally, I feel that using an upper bound is OK as long as you are committed to testing and updating as soon as new versions of packages come out
12:17:38 <byorgey> I use upper bounds for base but have already updated all my packages to work with ghc 7.4.
12:17:38 <Enigmagic> until you're on vacation when ghc 7.4.1 comes out
12:18:08 <rwbarton> It still seems like one would be more likely to fail to update one's packages than that they would actually break
12:18:11 <byorgey> it would have to be a very long vacation.  there's usually plenty of time to try out the release candidate etc.
12:18:24 <byorgey> rwbarton: well, in the particular case of the 'base' package I agree
12:18:26 <aadrake> byorgey: Control/Monad/MVar.hs:16:8: Could not find module `Control.Exception.Control'
12:18:36 <Enigmagic> byorgey: i'm just saying in practice, when we rev compilers here there are a lot of broken packages on hackage that require patching
12:18:40 <luite> byorgey: well the problem is often that say you depend on lib-x 0.8, and 0.9 gets released and installed, some of your deps still have 0.8, some no upper bounds, some start to use new features of 0.9, then cabal tends to get stuck, you have to mail 10 authors of depedencies of your package to get it installing again
12:18:51 <aadrake> The documentation online shows it was in base 4.4.1.0
12:18:58 <luite> this happens to yesod regularly
12:19:17 <Enigmagic> aadrake: what version of monad-control do you have installed?
12:19:25 <rwbarton> yeah, I meant with base
12:20:16 <byorgey> luite: yeah, I know. This is why Michael made his 'packdeps' tool (which I also use).
12:20:21 <aadrake> Enigmagic: I'm not sure how to find out, but I have base 4.5 installed
12:20:29 <Enigmagic> aadrake: ghc-pkg list monad-control
12:20:45 <Enigmagic> i think you have 0.3.x installed and the mongoDB package on hackage isn't updated
12:20:47 <aadrake> Enigmagic: 0.3.1
12:20:59 <byorgey> aadrake: I don't see a module called Control.Exception.Control in base 4.4.1.0
12:21:05 <Enigmagic> aadrake: fork and install it from here https://github.com/TonyGen/mongoDB-haskell
12:21:12 <luite> bounds on template-haskell and process and things are also risky, you generall don't want to have cabal reinstall those, but cabal will happily do that and break your installation
12:21:15 <aadrake> Enigmagic: I already unpacked the mongodb package and have been updating it
12:21:15 <Enigmagic> i patched it a while ago and they haven't done a release yet
12:21:19 <aadrake> Enigmagic: I had to do the same with bson
12:21:47 <byorgey> luite: that's a good point.
12:21:49 <aadrake> byorgey: Sorry, I saw Control.Exception
12:21:50 <Enigmagic> aadrake: you want this patch https://github.com/TonyGen/mongoDB-haskell/commit/6faad5d866f2184baf6324838ee5b9ee616ce08c
12:22:03 <byorgey> luite: at least cabal refuses to reinstall base
12:22:54 <luite> yeah, perhaps more should be added to some blacklist, but I have no idea how cabal decides whether it can install a pacakge (version) or not
12:23:36 <luite> anyway, upgrading to ghc 7.4 seems to be mostly about mailing people to upgrade their base bounds, again...
12:26:31 <monochrom> my http://www.vex.net/~trebla/haskell/sicp.xhtml shows a way to get cabal to reinstall things. if ghc were on hackage, cabal would like to reinstall that, too
12:26:39 <darrint> Is there an easy way to convert a lazy bytestring to a strict one? Or to encode a Binary directly to a strict bytestring or text?
12:27:23 <monochrom> however, the real criterion is not whether something is on hackage, but rather whether something depends on some other things you can replace.
12:28:11 <monochrom> for example, base depends just on integer-gmp, ghc-prim, and builtin_rts. you have almost no way to "upgrade" any of those three.
12:29:43 <aadrake> Enigmagic: Done.  This all started because I wanted to try out ekg, which requires ghc 7.4 (I think).
12:29:59 <monochrom> whereas if you "upgrade" containers, then cabal will love to reinstall ghc and template-haskell
12:30:48 <Enigmagic> aadrake: yeah that's one of the things i'm looking forward to once 7.4.1 is out
12:31:29 <Enigmagic> saves me some time since ekg like functionality was already on my TODO list :P
12:32:03 <aadrake> Enigmagic: I'm using it on the code you helped me with earlier. Productivity is showing 100%, so that's cool
12:32:44 <aadrake> Enigmagic: It makes me kind of skeptical, but cool nonetheless.
12:33:32 <Enigmagic> aadrake: have you tried specifying +RTS -sstderr -RTS on the commandline? that tracks various scheduler things too
12:33:54 <Enigmagic> not sure what ekg is using for 'productivity'
12:34:22 <aadrake> Enigmagic: I think I read somewhere that it's the same, although I cannot say with certainty.
12:35:56 <aadrake> Enigmagic: 100% productive may lead to the false conclusion that further optimizations are impossible.  I guess it's just saying that the GC isn't wrecking my day.
12:38:40 <iceman111> hello hask
12:39:17 <Enigmagic> aadrake: that'd be my guess too
12:39:33 <Renze> Is there an e defined somewhere?
12:40:25 <byorgey> > exp 1
12:40:26 <lambdabot>   2.718281828459045
12:40:32 <byorgey> hi iceman111
12:40:54 <Renze> Ah, nice :)
12:40:58 <iceman111> hello byorgey
12:47:33 <BMeph> Is something wrong with freenode? We've gona a whole two hours without a net split! ;þ
12:47:51 <aadrake> Enigmagic: One thing to note about ekg, is that it added 16.3MB to the size of the binary
12:47:55 <snappy> is there anything right with freenode?
12:48:27 * hackagebot postgresql-libpq 0.6.1 - low-level binding to libpq  http://hackage.haskell.org/package/postgresql-libpq-0.6.1 (LeonSmith)
12:48:27 <BMeph> snappy: We have #haskell, and that's quite alright by me. :)
12:48:56 <snappy> good thing it's not ##haskell
12:49:02 <snappy> but that'll happen in a few months
12:50:41 <monochrom> ChanServ is what's right with freenode (compared to EFnet)
12:50:52 <monochrom> also NickServ
12:53:49 <MostAwesomeDude> Scuttlebutt is that there's a DDoS happening on a couple nodes right now.
12:54:09 <MostAwesomeDude> Service *should* be up for every node right now, but I can't say for sure.
12:56:22 <Enigmagic> aadrake: we're switching over to dynamic linking as part of the 7.4.x upgrade so i'm not too worried about it
12:56:40 <Enigmagic> i don't like 80 meg executables that much :-)
13:06:12 <aadrake> Enigmagic: When you say we, who do you mean exactly?
13:08:26 * hackagebot fuzzytime 0.7.6 - A 'ten past six' style clock  http://hackage.haskell.org/package/fuzzytime-0.7.6 (KamilStachowski)
13:09:30 <yottabit> i'm looking for a function that returns all even values..
13:09:50 <hughfdjackson> even
13:09:51 <hughfdjackson> i believe
13:09:57 <Renze> yes
13:10:04 <yottabit> filter
13:10:05 <Renze> no
13:10:11 <Renze> indeed
13:10:17 <Renze> filter even list
13:10:26 <hughfdjackson> oh, so it is
13:10:28 <hughfdjackson> *ahem*
13:10:31 <hughfdjackson> mea culpa
13:12:26 <yottabit> > do filter even[1..10]
13:12:27 <lambdabot>   [2,4,6,8,10]
13:13:02 <hughfdjackson> > filter even [1..10]
13:13:03 <lambdabot>   [2,4,6,8,10]
13:13:25 <hughfdjackson> ^^ ah, just confirming my suspecion that the do was redundant
13:13:33 <yottabit> always one-upping me
13:14:03 <hughfdjackson> heheh
13:14:08 <hughfdjackson> :| i'm seriously awful with haskell
13:14:23 <hughfdjackson> i just wanted to test that out in case i was going mad ;)
13:14:23 <yottabit> i'm even awfuler most likely
13:14:52 <byorgey> 'do' is always redundant when followed by a single expression.
13:15:40 <rwbarton> > do ()
13:15:41 <lambdabot>   ()
13:15:59 <byorgey> wat
13:16:09 <Renze> > ()
13:16:09 <lambdabot>   ()
13:16:13 <byorgey> I didn't expect that to work with a non-monadic type.
13:16:23 <byorgey> but I guess 'do e' is just literally desugared to 'e'.
13:16:45 <dgpratt> @undo do ()
13:16:45 <lambdabot> ()
13:16:52 <yottabit> i've been playing around with too much r lately
13:17:04 <yottabit> i keep wanting to do...
13:17:06 <yottabit> > ?do
13:17:07 <lambdabot>   mueval-core: internal error: PAP object entered!
13:17:07 <lambdabot>      (GHC version 6.12.3 f...
13:17:38 <yottabit> or..
13:17:39 <yottabit> > help(do)
13:17:40 <lambdabot>   <no location info>: Empty 'do' construct
13:18:01 <rwbarton> that first error is pretty neat
13:18:04 <rwbarton> > ?x
13:18:05 <lambdabot>   mueval-core: internal error: PAP object entered!
13:18:05 <lambdabot>      (GHC version 6.12.3 f...
13:18:21 <rwbarton> :t ?do
13:18:22 <lambdabot> forall t. (?do::t) => t
13:18:35 <DukeDave> @seen kowey
13:18:36 <lambdabot> Unknown command, try @list
13:18:41 <DukeDave> @list
13:18:41 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:20:29 <dgpratt> preflex: seen kowey
13:20:29 <preflex>  kowey was last seen on #darcs 22 hours, 12 minutes and 15 seconds ago, saying: good night!
13:21:28 <DukeDave> dgpratt: Cheers :)
13:21:33 <DukeDave> Do we have tell?
13:22:00 <dgpratt> lambdabot has tell, I'm fairly certain
13:24:28 <yottabit> curious to know how you would output a list to the terminal...
13:24:36 <yottabit> putStrLn outputs String
13:24:54 <yottabit> you would have to convert the list of Int to a list of Strings...
13:25:06 <yottabit> Strings are a list of Char..
13:25:13 <byorgey> yottabit: just use 'print'
13:25:18 <yottabit> So maybe convert a list of Int to a list of Char
13:25:47 <yottabit> or that
13:26:15 <DukeDave> @tell kowey Did you ever get anywhere with your wx-config replacement? (http://comments.gmane.org/gmane.comp.lang.haskell.wxhaskell.general/1052)
13:26:15 <lambdabot> Consider it noted.
13:26:24 <byorgey> yottabit: to convert an [Int] to a [String] you could use 'map show'
13:26:29 <byorgey> > map show [1,2,3]
13:26:30 <lambdabot>   ["1","2","3"]
13:26:41 <yottabit> ah yes
13:27:02 <byorgey> yottabit: print = putStrLn . show
13:27:16 <byorgey> so it first converts a value to a String using 'show' and then outputs it to the terminal
13:27:33 <byorgey> and 'show' knows how to handle lists
13:27:36 <byorgey> > show [1,2,3]
13:27:37 <lambdabot>   "[1,2,3]"
13:27:43 * yottabit has to step away for a few moments
13:27:53 <yottabit> but first...
13:29:19 <hpaste> ybit pasted “no luck” at http://hpaste.org/55902
13:29:51 <yottabit> hints appreciated
13:30:01 <byorgey> yottabit: filter (even (fib)) and  filter even fib  are not the same
13:30:11 <byorgey> filter even fib  parses as  (filter even) fib
13:30:27 <byorgey> filter (even (fib)) tries to pass the list fib as an argument to the function 'even' which does not make sense
13:30:33 <byorgey> since even expects a number, and fib is a list
13:30:56 <hpaste> ybit annotated “no luck” with “no luck (annotation)” at http://hpaste.org/55902#a55903
13:32:14 <Clint> fib is a list?
13:36:39 <byorgey> oh! haha, that's another reason it doesn't work
13:37:41 <byorgey> yottabit: if you want a list of fibonacci numbers you have to do  map fib [0..]
13:37:53 <byorgey> since fib is a function that gives you the nth fibonacci number for a given n
13:41:05 <W_Blas> Is there a "root" data type in Haskell? I mean something like Object in Java.
13:41:14 <monochrom> no
13:41:44 <sipa> ()
13:41:52 <dolio> Haskell does not make use of subtyping.
13:42:09 <mauke> > 0-0 2-2 1-1 3-3
13:42:10 <lambdabot>   -6
13:42:41 <ksion> Haskell doesn't have inheritance of types, altough it does have something similar to interfaces.
13:50:57 <erkin> G'night.
13:51:37 <W_Blas> Suppose I have a data type: data Node = Empty | Node { children :: (Node, Node, Node), payload :: [Integer] }
13:52:08 <W_Blas> How do I access its fields in function f (Node ch, pl) = <something>
13:52:36 <saati> W_Blas: that's not a correct function
13:52:44 <mauke> that looks invalid
13:52:47 <rwbarton> it might be, but it's probably not what you meant
13:52:50 <monochrom> 1st way: f (Node (c0, c1, c2) n) = ...
13:52:52 <rwbarton> oh wait
13:52:57 <rwbarton> no, it's not
13:53:23 <monochrom> 2nd way: f Node{children=(c0,c1,c2), payload=n} = ...
13:53:43 <monochrom> in both ways, you can now use c0, c1, c2, n on the RHS
13:53:44 <saati> if you use record syntax you have children n and playload n
13:53:48 <W_Blas> seems the first way is correct...
13:53:56 <yottabit> fib isn't a list, aye...
13:57:13 <kizzo> What is ":/" ?  I see it here: http://hackage.haskell.org/package/directory-tree, in an expression like "do (b :/ dt) <- readDirectory dir"
13:58:26 * hackagebot syb-with-class 0.6.1.3 - Scrap Your Boilerplate With Class  http://hackage.haskell.org/package/syb-with-class-0.6.1.3 (AndreaVezzosi)
13:58:38 <monochrom> I think it's from filepath
13:59:13 <irene-knapp> well, punctuation starting with : is a constructor (as if it were uppercased)
13:59:21 <monochrom> sorry, no
13:59:32 <irene-knapp> so it's a constructor for some datatype, most likely a directory-related one
13:59:44 <monochrom> look at AnchoredDirTree
14:00:02 <yottabit> i'd like to know how to do..
14:00:39 <yottabit> fib 0 = 0
14:00:42 <yottabit> fib 1 = 1
14:00:52 <yottabit> fib n = fib (n-2) + (n-1) in ghci
14:01:00 <yottabit> think we went over this previously
14:01:05 <yottabit> time to grep the logs
14:01:17 <rwbarton> one way is let { fib 0 = 0; fib 1 = 1; ... }
14:01:37 <kizzo> Thank you both for the help - I get it now.
14:01:51 <monochrom> there is also a way to split it into several lines in ghci but I don't care enough for it
14:02:06 <saati> yottabit: you can use a case too
14:02:29 <monochrom> case does not save the number of {}s
14:02:31 <yottabit> fib :: Num a => a -> a
14:02:53 <yottabit> woah, so it isn't a list
14:03:03 <saati> monochrom: i don't follow
14:03:33 <monochrom> let { fib n = case n of { 0 -> 0; 1 -> 1; n -> fib (n-2) + fib (n-1) } }
14:03:43 <tommd> How can I get Alex to give me an EOF token?  I seem to be missing the documentation for that.
14:04:31 <saati> monochrom: let fib n = case n of { 0 -> 0; 1 -> 1; n -> fib (n-2) + fib (n-1) } this works too
14:04:44 <monochrom> yes. see the {}s?
14:05:22 <saati> sure but you don't have to repeat fib
14:06:25 <monochrom> but now you follow
14:08:51 <saati> anyhow this is a really unefficent fibonacci function
14:09:14 <yottabit> hah
14:09:26 <yottabit> my brain can't handle the other stuff right now
14:12:49 <yottabit> > filter even [1..10]
14:12:50 <lambdabot>   [2,4,6,8,10]
14:13:00 <Renze> it still works!
14:13:09 <yottabit> whoo!
14:13:09 <Renze> a miracle! :)
14:13:31 <yottabit> by golly there's a chance after all
14:13:58 <yottabit> ..that it won't break..
14:14:14 <yottabit> no? right. back to work
14:21:13 <lukish_> Is array faster that list?
14:21:23 <mauke> no
14:21:25 <irene-knapp> depends on what you're doing with it
14:21:34 <mauke> neither of them move
14:21:37 <shachaf> Is array longer than list?
14:21:48 <irene-knapp> shachaf: haha
14:21:49 <shachaf> mauke++
14:21:52 <irene-knapp> shachaf++
14:21:54 <mauke> shachaf: yes
14:21:59 <lukish_> Is array louder than list?
14:22:16 <irene-knapp> yes; I can't stand array's Hawaiian shirt
14:22:54 <lukish_> Well, I'm talking about memoization cituation
14:22:58 * irene-knapp nods
14:23:01 <mauke> > comparing length "array" "list"
14:23:01 <lambdabot>   GT
14:23:29 <lukish_> Is array better than simple list in case of memoization?
14:23:53 <mauke> that still means nothing
14:24:10 <shachaf> Is array more noble than list?
14:24:36 <BMeph> Is array cuter than list?
14:24:38 <W_Blas> In f Node{children=(c0,c1,c2), payload=n}  can I get a variable for Node itself somehow as well?
14:24:43 <irene-knapp> BMeph: for sure
14:24:55 <mauke> W_Blas: foo@Node{...}
14:25:17 <BMeph> irene-knapp: I think so, too.
14:25:27 <irene-knapp> hehe
14:25:58 <byorgey> lukish_: accessing the nth element of an array is (essentially) O(1), whereas accessing the nth element of a list is O(n).
14:26:25 <byorgey> so it is (probably) faster to access the 200th element of an array than the 200th element of a list.
14:26:38 <hiptobecubic> Maybe it's my inexperience talking, but chapter 5 and chapter 6, which builds on chapter 5, seem really farfetched and impractical. It makes it difficult to grasp what's really happening and how to properly use typeclasses
14:26:43 <mauke> but what if there are infinitely many elements?
14:26:44 <lukish_> Can I store 10^10 values in array?
14:28:09 <byorgey> lukish_: sure, if you have enough RAM. (hint: you probably don't)
14:28:13 <ehuber_> if you only need up to N elements ahead at a time, you can make a lazy ringbuffer :D
14:46:42 <mbetter> does anybody have a good lens tutorial?
14:48:30 <lukish_> http://hpaste.org/55904 trying to solve http://projecteuler.net/problem=214
14:48:51 <lukish_> But array of 40000000 element is bad idea/
14:49:20 <lukish_> How can I keep all that values and do not recalculate them?
14:50:16 <mbetter> exit
14:50:20 <mbetter> oops
14:52:23 <russellw> lukish_, there are people who do heavy-duty calculations on arrays much larger than ten billion elements. I don't know whether that's the best way to solve the particular problem you are looking at at the moment, but if it is, go ahead and use an array of the size you need
14:54:59 <lukish_> Well
14:55:00 <lukish_> λ> take 20 $ assocs eulerChains
14:55:00 <lukish_> [(1,1),(2,2),(3,3),(4,3),(5,4),(6,3),(7,4),(8,4),(9,4),(10,4),(11,5),(12,4),(13,5),(14,4),(15,5),(16,5),(17,6),(18,4),(19,5),(20,5)]
14:55:03 <lukish_> it :: [(Integer, Integer)]
14:55:06 <lukish_> λ> ghc: out of memory (requested 1048576 bytes)
14:55:36 <shachaf> That's a lotta bytes.
14:56:23 <lukish_> > 1048576 / 1024 / 1024
14:56:24 <lambdabot>   1.0
14:56:36 <lukish_> > 1048576 / (1024 * 1024)
14:56:37 <lambdabot>   1.0
14:56:40 <aninhumer> lukish_: could you expand the tree backwards?
14:56:43 <shachaf> > 1024 * 1024
14:56:44 <lambdabot>   1048576
14:56:52 <aninhumer> and stop at depth 25?
14:56:57 <lukish_> It's a megabyte or what?
14:57:04 <shachaf> It's a megabyte.
14:57:37 <lukish_> It's to much, actually
14:57:51 <lukish_> 21 century for god sake :)
14:59:05 <lukish_> aninhumer: and how can it be useful?
14:59:41 <lukish_> Searching the tree for some value will be long
14:59:59 <lukish_> And I can't actually stoped at 25 length
15:00:27 <lukish_> Because I need to calculate some values, that might be deeper than 25
15:00:55 <lukish_> Tree is not about memoization, it I'm getting right your idea
15:01:50 <aninhumer> lukish_: Why would you need to know any chains longer than 25?
15:02:22 <rwbarton> if you have 1G of ram I don't see why the 40M long array would be a problem
15:03:30 <aninhumer> That said, I'm not sure if the function is reversible in any useful way
15:04:57 <W_Blas> I have a list. How do I apply a function f to every element of the list?
15:05:02 <mbetter> map
15:06:07 <aninhumer> W_Blas: map f list
15:06:08 <shachaf> W_Blas: If you can figure out the type of the function you want, Hoogle can often find it for you.
15:06:12 <shachaf> (For cases like this.)
15:06:25 <Renze> http://www.haskell.org/hoogle
15:06:39 <aninhumer> @hoogle (a -> b) -> [a] -> [b]
15:06:40 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
15:06:40 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
15:06:40 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
15:06:51 <Renze> f.e. this type was: (a -> b) -> [a] -> [b] .. too late.
15:09:32 <mzero> W_Blas: do you want a list of the results?
15:10:03 <mzero> that is another good question to ask... or are the result of applying the function to be "rolled up" somehow...
15:10:26 <mzero> ... or is the function in IO, and you don't care about the results ---- there are functions for all of these
15:10:27 <W_Blas> mzero: Don't worry I made it already: applyFunction:: [Integer] -> (Integer -> Integer) -> [Integer]
15:10:34 <W_Blas> applyFunction (h:t) f = (f h) : ( applyFunction t f )
15:10:51 <mzero> sure --- but that is just    map with the arguments reversed
15:10:59 <mzero> @src map
15:11:00 <lambdabot> map _ []     = []
15:11:00 <lambdabot> map f (x:xs) = f x : map f xs
15:11:14 <mzero> use that
15:11:31 <Renze> or flip map
15:11:31 <W_Blas> Thanks!
15:11:35 <Renze> or: flip map*
15:12:02 <aninhumer> W_Blas:  it's a worthwhile excercise to make the function yourself, but you should probably learn the library function as well :)
15:12:40 <mbetter> i think i ended up making three or four different variations of fmap
15:12:47 <mbetter> before i got fmap
15:13:19 <aninhumer> I didn't realise liftM was just fmap for some time
15:14:27 <ksion> It has different typeclass requirement for first argument, IIRC.
15:14:32 <ksion> Monad rather than Functor.
15:14:46 <shachaf> There are probably a dozen different fmap-equivalent functions in the standard library.
15:15:38 <lukish_> I can't understand that message: ghc: out of memory (requested 1048576 bytes)
15:15:46 <lukish_> Is 1Mb is a limit?
15:16:09 <mbetter> maybe 1 meg is the allocation that pushed you over the limit
15:16:37 <ksion> 1MB is definetely not the limit; today I managed to make GHC grab a whopping 2.5gig ;)
15:20:04 <hpaste> Duffman- pasted “BST” at http://hpaste.org/55909
15:21:04 <Duffman-> I'm reading this book "learn you a haskell for great good" and there's this example in it that's about BST and recursive data structures so I know the focus of this exercise is not on the use of foldr and foldl
15:21:12 <luite> Duffman-: check the types of foldr and foldl to see why
15:21:22 <Duffman-> :t foldl
15:21:22 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
15:21:26 <lpsmith> I don't suppose there is a way of writing a quickcheck test of type :: Int -> IO Bool,  for example
15:21:53 <lpsmith> quickcheck seems rather oriented towards testing pure computations
15:22:06 <lpsmith> and hunit doesn't seem to have enough support for generating inputs
15:22:28 <byorgey> lpsmith: not true, check out http://hackage.haskell.org/packages/archive/QuickCheck/2.4.2/doc/html/Test-QuickCheck-Monadic.html
15:24:35 <Duffman-> luite, is it because the accumulator of foldl has to be of the same type as the first argument of the lambda?
15:25:01 <luite> :t foldl
15:25:02 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
15:25:04 <luite> :t foldr
15:25:05 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:25:22 <lpsmith> byorgey, thanks!
15:25:32 <luite> Duffman-: aw the a's and b's are flipped, but check the first argument
15:25:43 <Duffman-> yes the lambda
15:26:48 <byorgey> Duffman-: so you probably want  foldl (flip treeInsert)
15:27:02 <byorgey> > foldr f z [a,b,c]
15:27:03 <lambdabot>   f a (f b (f c z))
15:27:08 <byorgey> > foldl f z [a,b,c]
15:27:09 <lambdabot>   f (f (f z a) b) c
15:27:28 <byorgey> if you look at the above examples you'll see how f takes the arguments in opposite orders
15:28:00 <Duffman-> yes I see
15:29:19 <Duffman-> thanks
15:31:17 <Duffman-> is there a version of this lambda bot one can use without polluting this channel?
15:31:52 <byorgey> Duffman-: you can converse with lambdabot privately
15:31:53 <sipa> just pm it
15:32:08 <Duffman-> you can?
15:32:15 <Duffman-> I just tried and typed " :t 'a' "
15:32:17 <Duffman-> :t 'a'
15:32:17 <mbetter> just keep it clean
15:32:17 <lambdabot> Char
15:32:28 <hpc> Duffman-: use @type
15:32:28 <Duffman-> but it didn't give me a response
15:32:39 <Duffman-> oh
15:32:40 <hpc> for some reason, the ":blah" commands don't work in PM
15:32:41 <Duffman-> I see
15:32:46 <Duffman-> k thx! :)
15:32:52 <Duffman-> will be of great help I believe
15:33:00 <hpc> > text "this still works in PM just fine"
15:33:01 <lambdabot>   this still works in PM just fine
15:33:46 <luite> :t also works in ghci of course
15:33:47 <lambdabot> parse error on input `in'
15:33:54 <Duffman-> yes I know
15:34:05 <Duffman-> but the examle byorgey used doesn't I think, and that is pretty useful
15:34:40 <luite> that's true, it uses a bit of cheating, you could make it work in ghci if you load some file
15:35:14 <Sgeo_> @type works in oh someone said that
15:35:15 <lambdabot> parse error on input `in'
15:35:21 <Sgeo_> @type works
15:35:22 <lambdabot> Not in scope: `works'
15:35:23 <byorgey> you would have to  cabal install simple-reflect and then load some module
15:35:41 <luite> yeah, lambdabot defines all single-letter names as some simple-reflect Expr type
15:35:51 <Duffman-> is it okay if I just use lambdabot in PM
15:35:56 <luite> of course
15:36:34 <Duffman-> saves me the trouble of going through the install. I'm using windows so I imagine it will be a bit of a hassle setting up the environment.
15:36:35 <Duffman-> :p
15:36:48 <luite> oh it's probably relatively simple, just cabal install
15:37:00 <luite> I don't think it has non-haskell dependencies
15:48:14 <yottabit> this is being executed right now
15:48:16 <yottabit> https://github.com/heath/Project-Euler-Problems/blob/master/haskell/two.hs
15:48:23 <yottabit> bets are on if it ever stops
15:48:45 <rwbarton> it will never stop
15:48:51 <rwbarton> (spoiler)
15:48:56 <mauke> all programs halt
15:48:57 <yottabit> oh boy
15:49:01 <mauke> proof: shotgun.
15:49:38 <mauke> yottabit: that program may or may not halt but you will never get an answer
15:49:52 <mauke> you want takeWhile
15:49:53 <yottabit> My logic is fallable
15:50:00 <saati> hmm that naive fib implementation is quite good when compiled and not interpreted
15:50:27 <mauke> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in sum (filter even (takeWhile (< 4000) fibs))
15:50:28 <lambdabot>   3382
15:50:36 <mauke> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in sum (filter even (takeWhile (< 4000000) fibs))
15:50:37 <lambdabot>   4613732
15:50:43 <yottabit> takewhile as opposed to...
15:50:47 <yottabit> oh
15:52:16 <yottabit> i really like takeWhile
15:52:18 <yottabit> thanks mauke!
15:52:40 <nuttycom> Can somebody tell me what the ! means in this data declaration:
15:52:42 <nuttycom> data Iteratee el m a = IE_done ! a
15:52:42 <nuttycom> 		     | IE_cont ! (Maybe ErrMsg)
15:52:42 <nuttycom> 		               (Stream el -> m (Iteratee el m a, Stream el))
15:52:57 <mauke> it's a strictness annotation
15:53:26 <ion> fibs = 0 : 1 : …
15:53:28 <Axman6> nuttycom: means that the Maybe will always be evaluated to WHNF when you create an IE_cont
15:53:50 <Axman6> i'm not sure it's a useful place to have it, but i could be wrong
15:54:18 <yottabit> didn't make it that far in the list here: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
15:54:33 <yottabit> probably a good idea to go through all of it
15:55:55 <yottabit> there's just so much to learn in haskell, it seems overwhelming but exciting
15:56:08 <Axman6> let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in sum . filter even . takeWhile (< 4000000) $ fibs
15:56:15 <Axman6> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in sum . filter even . takeWhile (< 4000000) $ fibs
15:56:17 <lambdabot>   4613732
15:56:29 * yottabit is thankful for being introduced to it
15:57:12 <nuttycom> yottabit: Well, I'm actually just trying to port haskell code to Scala at the moment. So I'm learning haskell inside-out.
15:57:30 <Renze> I like this before bedtime :)
15:57:44 <Renze> All day long was I working to test some functions, and now most of them work just fine :D
15:57:45 <nuttycom> I'm happy to have been introduced to it too!
15:57:52 <yottabit> nuttycom: that seems like one extremely large project
15:58:03 <Renze> Although some function give Nothing back too often, but that's a problem for tomorrow.
15:58:17 <Renze> Always fun with ghci spamming over your screen
15:58:27 * hackagebot vector 0.9.1 - Efficient Arrays  http://hackage.haskell.org/package/vector-0.9.1 (RomanLeshchinskiy)
15:58:49 <nuttycom> yottabit: Well, a lot of it has been done already (via scalaz) so I'm just adding some somewhat more esoteric enumeratees.
15:58:51 <yottabit> nuttycom: aren't there extremely huge issues with making haskell compile to a jvm?
15:59:04 <nuttycom> Not trying to make haskell compile.
15:59:04 <yottabit> iirc, it's been attempted before several times
15:59:08 <nuttycom> Porting the library.
15:59:10 <yottabit> oh
16:00:07 <nuttycom> Some day I'll have time to actually learn haskell properly. For now, it's just a source of inspiration.
16:01:17 <yottabit> if you have about 100 .hs files and you need to compile all of them...
16:01:35 <yottabit> you're looking at a messy dir in the end
16:01:50 <yottabit> what to do with the output from ghc?
16:02:02 <ion> cabal compiles them under a separate directory.
16:05:17 <monochrom> normally, you only have one executable and you only need to focus on it
16:05:46 <irene-knapp> :t find
16:05:47 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
16:05:52 <monochrom> but also normally, you don't put all 100 files in the same directory. you can have 100 files, but in different directories
16:08:58 <irene-knapp> > on fst (==) (5, 10) (5, 0)
16:08:59 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a, b) -> c
16:09:06 <irene-knapp> > on (==) fst (5, 10) (5, 0)
16:09:07 <lambdabot>   True
16:09:54 <ClaudiusMaximus> > on (==) fst (5, 10) (5, "no Num String for you today")
16:09:55 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
16:09:55 <lambdabot>    arising from the literal ...
16:09:59 <irene-knapp> haha
16:10:03 <irene-knapp> indeed
16:11:06 <irene-knapp> @hoogle on
16:11:06 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
16:11:07 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
16:11:07 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
16:11:16 <yottabit> i'd like to do something like [x | x <- (fibs < 4000000)]
16:12:52 <monochrom> [x | x <- fibs, x < 4000000]
16:16:15 <solarus> that would produce bottom if you try to access a fibonacci number above 4000000 btw
16:16:21 <monochrom> which will not stop because it doesn't know it can stop
16:16:37 <solarus> exactly :)
16:16:40 <monochrom> [x | x <- takeWhile (< 4000000) fibs]
16:17:24 <monochrom> which is wrong if fibs is maliciously ordered randomly
16:17:44 <monochrom> "the only way to win is not to play"
16:19:36 <monochrom> actually, another way to win is to get a clear specification first, and have it signed by the requester.
16:19:40 <ion> > fix $ \sbif -> 610:377:zipWith (-) sbif (tail sbif)
16:19:40 <lambdabot>   [610,377,233,144,89,55,34,21,13,8,5,3,2,1,1,0,1,-1,2,-3,5,-8,13,-21,34,-55,...
16:21:23 <ion> > fix $ \fibs -> (-55):34:zipWith (+) fibs (tail fibs)
16:21:23 <lambdabot>   [-55,34,-21,13,-8,5,-3,2,-1,1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,...
16:22:05 <monochrom> I had a homework question of how to drive the euclidean algorithm insane, err, drive it to use the most number of steps (given an input size, of course). I didn't know how. later, I was delighted that fibonacci numbers were an answer. it's obvious in retrospect.
16:24:11 <cmccann> monochrom, the golden ratio, right?
16:25:30 <cmccann> I seem to recall that being the relevant part
16:27:30 * cmccann recalls the golden ratio having a very simple representation as a continued fraction for basically that reason
16:28:06 <centrinia> You mean 1+1/(1+1/(1+...)))
16:28:52 <rwbarton> yes, and if you truncate that continued fraction you get the ratio between two consecutive fibonacci numbers
16:29:45 <cmccann> centrinia, yeah, which I think amounts to providing the least information possible at each step of the fraction, or something, I don't recall clearly
16:29:51 <MostAwesomeDude> Interestingly, that continued fraction [1; 1, 1, ... ] has other fun properties.
16:30:05 <centrinia> @let foobar n = foldl (\b a -> a+1%b) 1 (replicate n 1)
16:30:06 <lambdabot>  <local>:10:26:
16:30:06 <lambdabot>      Occurs check: cannot construct the infinite type: a = Ra...
16:30:19 <centrinia> @let foobar n = foldl (\b a -> a+1%b) (1%1) (replicate n (1%1))
16:30:19 <lambdabot>  <local>:10:26:
16:30:20 <lambdabot>      Occurs check: cannot construct the infinite type: a = Ra...
16:30:26 <MostAwesomeDude> It is the slowest-converging irrational number by any approximation method.
16:30:29 <centrinia> @let foobar n = foldl (\b a -> a+1%b) (1%1) (replicate n (1))
16:30:30 <lambdabot>  <local>:10:26:
16:30:30 <lambdabot>      Occurs check: cannot construct the infinite type: a = Ra...
16:30:46 <centrinia> @let foobar n = foldl (\b a -> a+1%b) (1) (replicate n (1%1))
16:30:47 <lambdabot>  <local>:10:26:
16:30:47 <lambdabot>      Occurs check: cannot construct the infinite type: a = Ra...
16:30:51 <centrinia> Hmm.
16:31:03 <centrinia> @let foobar n = foldl (\b a -> a+1/b) (1) (replicate n 1)
16:31:05 <lambdabot>  Defined.
16:31:07 <BMeph> @let foobar n = foldl (\b a -> a+recip b) (1) (replicate n (1%1))
16:31:08 <lambdabot>  <local>:10:0:
16:31:08 <lambdabot>      Warning: Pattern match(es) are overlapped
16:31:08 <lambdabot>               I...
16:31:09 <centrinia> > foobar 10
16:31:11 <lambdabot>   1.6179775280898876
16:31:16 <ion> The cargo cult says hello.
16:31:25 <centrinia> @let foobar2 n = foldl (\b a -> a+1/b) (1%1) (replicate n 1)
16:31:26 <lambdabot>  Defined.
16:31:31 <centrinia> > foobar2 3
16:31:33 <lambdabot>   5 % 3
16:31:33 <BMeph> Bah, too slow again... :)
16:31:35 <centrinia> > foobar2 10
16:31:37 <lambdabot>   144 % 89
16:31:50 <centrinia> > [foobar2 n | n <- [1..]]
16:31:52 <lambdabot>   [2 % 1,3 % 2,5 % 3,8 % 5,13 % 8,21 % 13,34 % 21,55 % 34,89 % 55,144 % 89,23...
16:32:12 <monochrom> I don't actually see how the ratio is important. I only see this: a step goes from (x, y) to (y, z) where z = x - q*y. To gain more steps later, make z bigger, make q smaller, make it 1, so z = x - y. Looking ahead a few more steps like this, and it looks really like ion's zipWith (-) sbif (tail sbif)
16:40:45 <monochrom> my http://www.vex.net/~trebla/haskell/calculator/Calculator.html has an algorithm for continued fractions of square roots of positive integers
16:41:00 <irene-knapp> monochrom: ah!  excellent
16:41:14 <irene-knapp> I have actually been wanting such a beast.  does it generalize to nth roots?
16:41:25 <monochrom> I copied it out of a book. I no longer know what's going on!
16:41:29 <irene-knapp> haha okay!
16:41:32 <monochrom> no
16:41:35 <irene-knapp> drat
16:41:41 <centrinia> Hmm, the Ackermann function.
16:41:47 <irene-knapp> I like the documentation of it
16:42:01 <monochrom> it comes from some Lucas sequence thing, which is very specific for square roots
16:42:01 <irene-knapp> of ack, I mean
16:42:05 <irene-knapp> right, okay, hmmm
16:43:24 <irene-knapp> oh cool, I read up on that
16:43:51 <irene-knapp> that's a fun identity :D but useless for my thing, yes
16:45:28 <monochrom> if you like the Ackermann function, you may also like my http://www.vex.net/~trebla/compsci/imperative-functional.html
16:45:47 * irene-knapp nods
16:45:52 <irene-knapp> nice thing
16:46:00 <irene-knapp> didn't even attempt to figure it out, haha
16:46:16 <cmccann> irene-knapp, have you seen this? http://www.tweedledum.com/rwg/cfup.htm
16:46:34 <cmccann> it's an interesting read
16:46:46 <irene-knapp> I haven't seen that document but it looks like algorithms I'm aware of
16:47:04 <irene-knapp> this is similar, in fact, to something I want to do
16:47:10 <irene-knapp> and possibly will let me do it :D
16:47:13 <cmccann> there's a lot of stuff in there
16:47:23 <irene-knapp> I want to define "data Irrational ?" :D
16:47:38 <irene-knapp> and operations on it
16:47:44 <rwbarton> why is this text document written in fortran
16:47:47 <tommd> Is there a way to tell Cabal that your main is in a module other than Main?
16:47:48 <irene-knapp> lol
16:47:54 <cmccann> you probably want data Real unless you have some way you expect to exclude rationals :P
16:47:58 <tommd> like GHC's --main-is Module.func ?
16:48:05 <irene-knapp> I think Real is taken, haha
16:48:08 <irene-knapp> but yeah, point.
16:48:23 <irene-knapp> tommd: put a line in your .cabal file's library or executable section, reading main-is: Foo.hs
16:48:32 <cmccann> irene-knapp, call it ℝ then
16:48:41 <irene-knapp> cmccann: your Unicode did not display for me
16:48:45 <cmccann> pf
16:48:46 <tommd> irene-knapp: But Foo can't say "module Foo where" (so it seems)
16:48:49 <irene-knapp> unless it was a zero-width space
16:48:50 <cmccann> okay, step 1, get a better font
16:48:51 <mauke> U+211D (e2 84 9d): DOUBLE-STRUCK CAPITAL R [ℝ]
16:48:52 <cmccann> then call it that
16:48:55 <irene-knapp> tommd: true, it needs to call itself Main internally
16:49:36 <irene-knapp> oh cool, Mauke!  haha!  and it's capitalized so I can blithely use it as a type constructor and pretend the capitalization-and-non-English-letters-used-for-math impedance mismatch does not exist
16:49:47 <cmccann> irene-knapp, anyway, the stuff in that document should give you basically everything you need to define a real number type using lazy continued fractions and do arithmetic on them
16:49:51 <tommd> That is what I wish to avoid.  GHC doesn't require it and it's a bit annoying that cabal does.
16:49:57 <irene-knapp> yeah, wow, awesome cmccann.  I see that!
16:50:16 <irene-knapp> tommd: ah, yeah, I agree, but dcoutts's technical judgement is usually excellent and I suspect he has his reasons
16:50:28 <irene-knapp> (he's the cabal maintainer)
16:50:30 <cmccann> irene-knapp, yeah, the blackboard bold stuff counts as letters in Unicode and GHC treats them as such
16:50:39 <irene-knapp> cmccann: yeah, heh
16:50:46 <irene-knapp> which is great for them
16:50:49 <tommd> I know who Duncan is.  This just seems arbitrary (choose a subset to support/require from the compilers).
16:50:49 <irene-knapp> not so great for capital-delta
16:51:05 <tommd> oh well.
16:51:05 <irene-knapp> well, I imagine that he wanted to choose a subset that all the compilers supported
16:51:10 <irene-knapp> it's possible that hugs doesn't, for example
16:51:13 <irene-knapp> but I'm just guessing
16:51:32 <tommd> Ironic, seeing as this is Mark Jones's code that I'm cabalizing.
16:51:34 <cmccann> irene-knapp, I occasionally use that to represent parameterized interval or offset types, actually
16:51:54 <irene-knapp> cmccann: okay.  yeah.  well, it would be nicest if the capitalization thing were merely advisory, haha
16:52:20 <cmccann> I like the consistency on one hand, it aids in reading code most of the time
16:52:26 <irene-knapp> cmccann: because in the specific case of capital-delta, it is "really" a symbol (unless you're a Greek user)
16:52:27 <cmccann> but it's annoying when it gets in the way of standard names
16:52:41 <irene-knapp> yes, indeed
16:55:01 <cmccann> irene-knapp, at any rate, if you implement the stuff from that document let me know, I'd like to see
16:55:33 <irene-knapp> cmccann: I shall endeavour to remember to tell you about it.  actually, it might make a better project for this weekend than my planned one? :D
16:56:04 <cmccann> it's certainly better than my project for this weekend
16:56:36 <irene-knapp> hehe
16:56:38 <irene-knapp> what's yours?
16:57:48 <cmccann> seeing how far I can get on a complete and pathologically compliant html5 parser
16:57:57 <irene-knapp> hah, okay
16:57:59 <irene-knapp> that's kinda cool though
16:58:25 <cmccann> I have a jug of holy water and a professional exorcist on speed dial so I think I'm set
16:58:30 <irene-knapp> haha very nice
16:58:53 <irene-knapp> as long as the threat is Biblical in nature rather than Lovecraftian, that should do it
16:59:28 <cmccann> yes, I'm hoping it won't come to that
17:00:27 <cmccann> though I'm pretty sure I could hear shrill flutes piping mindlessly from the outer chaos last time I looked at the html5 spec
17:00:31 <cmccann> so I'm not optimistic
17:00:38 <irene-knapp> oh dear oh dear.
17:01:05 <irene-knapp> just remember, if it takes the color out of space, summon Rainbow Brite promptly to restore it.
17:01:16 <cmccann> ok. good plan.
17:01:18 <irene-knapp> :D
17:02:52 <cmccann> anyway, do you have a github or anything to upload the continued fraction stuff?
17:03:33 <irene-knapp> I have a personal website but it's a mishmash of stuff with my old and new names
17:03:44 <irene-knapp> http://ireneknapp.com/software/
17:03:52 <irene-knapp> sorry, I realize that github does nice things like lets you "watch" me
17:03:56 <irene-knapp> but I can't stand git, I use darcs
17:04:26 <cmccann> haha
17:04:32 <irene-knapp> yeah
17:04:49 <ion> HTML5 should copy useWord97LineBreakRules from the standard document format.
17:04:54 <irene-knapp> ahahahaa
17:05:12 <cmccann> heh
17:05:33 * cmccann appreciates the reminder that there are worse things than html5 out there
17:05:37 <irene-knapp> indeed
17:06:59 <peterjoel> hi, does anyone know if #haskell-iphone channel is dead, or did I just get the wrong channel?
17:08:00 <jsc> hi guys! I'm trying to implement Shamir's Secret Sharing scheme in haskell, but when I try and use a finite field (just `mod` p, no galois fields or anything) it doesn't work. My code is: http://www.demigods.org/secrets.hs .  On line 36 is where I'm running into trouble. I guess I don't have a very structured question, I'm just not sure what to do at this point
17:11:00 <cmccann> jsc, clarify "doesn't work"?
17:11:38 <jsc> when I keep the value in the field, trying to interpolate it back to get the secret results in nonsense
17:11:41 <jsc> I know that's vague too
17:11:52 <jsc> but I'm not sure exactly why it is doing that
17:12:02 <rwbarton> so your problem is of the form "my program runs but it does not produce the output I expected"
17:12:22 <jsc> rwbarton: yes
17:12:25 <jsc> which now that you put it that way
17:12:27 <jsc> my bad
17:12:32 <jsc> I'll take a look at it tomorrow
17:12:43 <peterjoel> That channel does seem dead. So I'll ask here… Am I likely to run into problems trying to generate C code from GHC and then compiling that for the iphone with the usual iphone dev tools?
17:13:11 <cmccann> jsc, yeah, that doesn't give us much to go on :]
17:13:52 <centrinia> Why are you using rational arithmetic in lagrange?
17:13:52 <cmccann> isn't the C backend pretty much getting deprecated right in the face these days?
17:14:08 <byorgey> peterjoel: I don't think the C backend is maintained anymore?  Also, even generated C code still depends on the Haskell runtime.
17:14:18 <jsc> centrinia: because I have to divide by (c-i) and if it's Integer ghc gets mad at me
17:14:28 <byorgey> disclaimer, I actually don't really know all that much about it...
17:14:52 <centrinia> Divide modulo p as well.
17:15:11 <jsc> centrinia: ha! Oh man, I completely forgot
17:15:13 <centrinia> You can use the extended Euclidean algorithm to compute reciprocals.
17:15:14 <jsc> thank you so much!
17:15:14 <centrinia> http://www.vex.net/~trebla/haskell/calculator/Calculator.html
17:15:19 <peterjoel> right ok. That's the sort of info that I was looking for
17:15:37 <jsc> I feel pretty foolish but thank you for setting me straight
17:15:53 <peterjoel> I hadn't realised there is a runtime. I thought it was just compiled down to machine code, which ran natively
17:16:14 <byorgey> no, there is definitely a (rather clever) runtime
17:16:24 <peterjoel> I must have read some out-of-date documentation that talked about extracting c code from ghc
17:16:46 <mauke> the runtime is written in C
17:16:54 <peterjoel> can you give me a link to where I can read about the runtime?
17:17:49 <peterjoel> actually nm, it was easy to find on google :/
17:55:42 <MasterPrime> who here is using crux?
17:56:06 <MasterPrime> or can help me get my lan working in it 2.7
17:56:25 <MasterPrime> I tried in crux but they're idle.
18:00:49 <monochrom> what is crux?
18:01:28 <MasterPrime> linux distro
18:01:50 <vodik> i think your on the wrong channel
18:01:53 <cmccann> probably a bit off topic here
18:01:59 <monochrom> and what is lan?
18:02:05 <MasterPrime> local area network
18:02:17 <mauke> MasterPrime: how is that a haskell question?
18:02:53 <hughfdjackson> mauke: :D ah, i remember
18:03:05 <hughfdjackson> it was you whose explanation of haskell IO i didn't understand
18:03:19 <MasterPrime> it's only a haskell question in that I'm trying to install it to use as a platform for coding in haskell.
18:03:20 <hughfdjackson> (due entirely to not understanding haskell)
18:03:53 <hughfdjackson> MasterPrime: it's a haskell question insomuch as asking how i can sew my fingers back on so i can code is a haskell question, don't you think? ^_^
18:04:29 <monochrom> I actually don't mind
18:05:30 <MasterPrime> hughfdjackson: how can I sew without fingers?
18:05:40 <mauke> laser vision
18:05:51 <hughfdjackson> a friend :D
18:05:55 <hughfdjackson> friends are great
18:06:06 <ion> We wouldn’t know.
18:07:11 <MasterPrime> ion: because it's not a haskell question?
18:08:50 <MasterPrime> is my brain messing with me or did someone just tell me to ask in ##osx?
18:13:32 <bss03> So, I'm getting a non-exahstive pattern match warning, and I'm fairly sure my patterns are indeed exhaustive.
18:13:55 <bss03> Anyone willing to look at an hpaste and provided independent confirmation of that?
18:14:12 <cmccann> bss03, might as well hpaste it
18:14:23 <cmccann> no promises whether I can help though
18:14:26 <rwbarton> are you using anything fancy like guards?
18:15:06 <hpaste> “Boyd Stephen Smith Jr.” pasted “Non-exhaustive meld?” at http://hpaste.org/55913
18:15:50 <bss03> rwbarton: Yeah, there are guards, but I thought GHC has been smart enough to recognize this guard pattern before.
18:16:33 <cmccann> bss03, is that guard pattern exhaustive even if the Ord instance is doing something funny
18:16:38 <mauke> bss03: that's not exhaustive
18:16:39 <rwbarton> GHC has no reason to think that at least one of x <= y and y <= x is True
18:16:53 <bss03> Kk.
18:17:00 <bss03> I'll just go with an otherwise there.
18:17:23 <ion> Your name would be even more awesome if you wrote it like Sir Boyd Stephen Smith Jr., Esq.
18:18:00 <bss03> Well, I've yet to be knighted, and I don't really know much law.
18:18:06 <monochrom> there seems to be some conflict between Sir and Esq
18:18:57 <bss03> cmccann: Well, I suppse compare could always return GT...
18:19:15 <monochrom> ah, american esq vs british esq
18:19:21 <Guest39809> is it possible using terminfo or otherwise to figure out if i can print colorized output (using wl-pprint-terminfo)?
18:19:45 <cmccann> > (0/0) <= (0/0)
18:19:46 <lambdabot>   False
18:19:47 <Guest39809> i tried getCapability term termColors when piping to less, and it said 8, which would not print correctly
18:20:27 <cmccann> the floating point Ord instance can really ruin your day
18:21:00 <bss03> Guest39808: Less tries to mangle ANSI color codes by default, IIRC.
18:21:41 <Guest39809> is it possible to maybe take a more conservative approach, and check if stdout is being piped to somewhere other than directly to the screen?
18:21:45 <bss03> Guest39808: But, I do believe that termColors is the "best way" to determine if colorized output is supported.
18:21:56 <Guest39809> ok
18:21:58 <vodik> cmccann: 0/0 is still a divide by 0 error, no?
18:22:04 <mauke> vodik: no
18:22:07 <cmccann> > 0/0
18:22:08 <lambdabot>   NaN
18:22:13 <cmccann> :t (/)
18:22:14 <lambdabot> forall a. (Fractional a) => a -> a -> a
18:22:17 <mauke> Guest39809: yes
18:22:23 <bss03> Guest39809: You do probably want to check to make sure the Handle you are writing to is a terminal.
18:22:33 <vodik> cmccann: okay, but isn't NaN == NaN always False?
18:22:42 <vodik> cmccann: because NaN is an error condition?
18:22:49 <bss03> > NaN == NaN
18:22:50 <lambdabot>   Not in scope: data constructor `NaN'Not in scope: data constructor `NaN'
18:22:56 <cmccann> vodik, yes, NaN breaks all kinds of expected behavior for Eq and Ord
18:23:06 <bss03> > (0/0) == (0/0)
18:23:06 <lambdabot>   False
18:23:08 <Guest39809> o duh, hIsTerminalDevice
18:23:13 <cmccann> > compare (0/0) (0/0)
18:23:14 <lambdabot>   GT
18:23:21 <cmccann> > (0/0) > (0/0)
18:23:22 <lambdabot>   False
18:23:28 <cmccann> yep.
18:23:32 <mauke> @hoogle hIsTerminalDevice
18:23:32 <lambdabot> System.IO hIsTerminalDevice :: Handle -> IO Bool
18:23:33 <lambdabot> GHC.IO.Handle hIsTerminalDevice :: Handle -> IO Bool
18:23:38 <irene-knapp> > (0/0) < (0/0)
18:23:39 <lambdabot>   False
18:23:45 <irene-knapp> just curious :)
18:23:49 <mauke> oh, interesting
18:23:53 <vodik> > (0/0) /= (0/0)
18:23:53 <ion> herTerminalDevice
18:23:54 <lambdabot>   True
18:23:58 <irene-knapp> ion: hehe
18:24:07 <mauke> for the record, isatty is in System.Posix.Terminal.queryTerminal
18:24:10 <monochrom> herMajestyDevice
18:24:25 * cmccann wonders where to get an initial device instead 
18:39:02 <Sgeo_> With conduits, what if my problem really does involve push-based IO?
18:39:10 <Sgeo_> A Source that pushes?
19:09:51 <bss03> So, where is the best place to put Arbitrary and CoArbitrary instances?
19:10:22 <bss03> I.e. is it mostly okay to ignore "orphan instance" warnings for those?
19:11:36 <bss03> My gut says that I should isolate the test code in it's own module, so that QC doesn't have to be installed for consumers of the main module.
19:12:14 <c_wraith> bss03: that's what I've done in the past.  And yes, ignored the orphan instance warning for the test modules.
19:34:09 <sordina> Is there a nice way to make this absolute function not dependant on Maybe? https://github.com/sordina/Midi/blob/master/src/TimeSet.hs
19:36:30 <sordina> I'm having a mental blank
19:37:56 <sordina> I thought about using monoidal properties, but I don't have any 0 element.
19:38:13 <rwbarton> scanl1?
19:38:39 <rwbarton> I think that's what you're trying to do with the Maybes
19:38:45 <rwbarton> > scanl1 f [x, y, z]
19:38:46 <lambdabot>   [x,f x y,f (f x y) z]
19:39:00 <bss03> sordina: Is there a suitable mempty implementation for your tuples there?
19:39:13 <sordina> bss03: nope
19:39:27 <bss03> sordina: is "a" supposed to work on empty lists?
19:39:38 <sordina> rwbarton: Yep that might work. I'll probably just have to make a special case for the empty list.
19:39:44 <sordina> That's what I'm trying to avoid.
19:39:50 <rwbarton> > scanl1 f []
19:39:51 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:39:51 <lambdabot>    `SimpleReflect.FromExpr ...
19:39:52 <bss03> sordina: if not, scanl1 sounds like a good idea.
19:39:59 <rwbarton> > scanl1 undefined []
19:40:00 <Veinor> scanl1 f errors
19:40:00 <lambdabot>   []
19:40:08 <Veinor> oh no i'm thinking of foldl1
19:40:19 * bss03 was too.
19:41:07 <bss03> > scanl (+) ([] :: [Int])
19:41:08 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
19:41:08 <lambdabot>    arising from a use of `GHC...
19:41:18 <bss03> > scanl1 (+) ([] :: [Int])
19:41:19 <lambdabot>   []
19:41:46 <rwbarton> scanl1 is a lot more useful compared to scanl than foldl1 is compared to foldl, for this reason
19:42:07 * bss03 agrees.
19:42:42 <sordina> Ah1!
19:42:53 <sordina> I never would have imagined that it would do that!
19:43:10 <sordina> Everything else just seems to error out on the empty list.
19:43:19 <sordina> So I assumed that scanl1 would too.
19:43:37 <sordina> Thanks :D
19:45:28 <sordina> absolute = scanl1 f where f (a,_) (b,y) = (a+b, y) -- Much nicer!
19:55:43 <sshine> where do I see which function to minimally implement for a given typeclass?
19:55:59 <mauke> the documentation
19:57:02 <sshine> found it.
19:59:07 <sshine> wait, no. http://www.haskell.org/ghc/docs/6.4/html/libraries/base/Prelude.html doesn't mention which functions to minimally implement, as far as I can see.
20:00:26 <mauke> for which class?
20:00:30 <lars9> is it possible to define a type like this? data Helper a = forall b . [((a -> b), Helper b)]
20:01:21 <lars9> a helper a is a list of (getter a -> b , helper b)
20:03:16 <bss03> I think you need a tag there, and I'm still not comfortable with explicit-for-all on data types.
20:03:38 <rwbarton> what is b?
20:03:47 <rwbarton> specifically, who chooses what b is?
20:04:22 <lars9> this is a tree of closures, built from bottom up
20:06:20 <rwbarton> does it have to be the same b for every list element?
20:06:33 <rwbarton> anyways, you can just use laziness for that (tree of closures)...
20:06:43 <lars9> for example if a = (Int, Float), then helper a would be: [(fst, Helper Int), (snd, Helper Float)], is it possible to hide details of Int/Float and put them into a list?
20:07:27 <rwbarton> it is possible
20:07:46 <rwbarton> data HelperNode a = forall b. HelperNode (a -> b) (Helper b)
20:07:49 <lars9> how to define the type?
20:07:54 <rwbarton> type Helper a = [HelperNode a]
20:08:00 <rwbarton> if I guess what you want correctly
20:08:03 <lars9> i didn't use existential type a lot
20:09:10 <rwbarton> I'm not sure what you can do with this though
20:09:52 <rwbarton> it looks just like data Tree = Node [Tree] AFAICT
20:11:16 <rwbarton> since I can never really use that function, since I don't know what b is--b only appears in Helper b, so all I can do is pass it to a function b -> c, but I don't know what c is, since ...
20:12:14 <rwbarton> Sometimes this can be useful as a representation, as long as you realize that in the end all you're getting out is a tree
20:13:45 <rwbarton> actually no, I don't see how it would be useful here
20:17:20 <lars9> i build a tree of closures for structural operation on some types, then i apply the closure to a stream of new values. for sake of performance, i need to cache intermediate values, that means i need to preserve the type of intermediate nodes...
20:17:42 <rwbarton> but you can't get out the values at the end, because you've forgotten the types
20:18:03 <rwbarton> right?
20:18:13 <lars9> seems right.
20:18:49 <rwbarton> so your options seem to be (1) encode the structure of the tree and the intermediate types in the type of your tree (2) use Typeable
20:19:01 <rwbarton> ... and hope for the best
20:19:54 <lars9> for example, to print all simple type values of a data strucutre, (Int, Float), we can do this [ (myPrintInt . fst), (myPrintFloat . snd) ], it is alright.
20:21:10 <BMeph> rwbarton: I think you meant to say:
20:21:22 <BMeph> 3) ????   4) PROFIT!
20:21:29 <BMeph> ;)
20:22:22 <rwbarton> if you have some "final results" that are all of the same type you can consider
20:22:30 <lars9> but if it's not a simple (Int, Float) but a complicated tree-like type, this method can not preserve intermediate results. for example (Char, (Int, Float)), we have to do [(myPrintChar . fst),  (myPrintInt . fst . snd),  (myPrintFloat . snd . snd)], the getters will be longer and longer
20:22:45 <rwbarton> data HelperNode a c = Result (a -> c) | forall b. HelperNode (a -> b) (Helper b c)
20:22:51 <rwbarton> type Helper a c = [HelperNode a c]
20:23:00 <lars9> because we toss the intermediate types so there is no way to cache the data
20:23:50 <lars9> and according to my profiling these long getters are using a lot of CPU now.
20:23:59 <rwbarton> (or use a GADT, data HelperNode :: * -> * -> * where Done :: HelperNode a a; Function :: (a -> b) -> Helper b c -> Helper a c)
20:24:19 <ddarius> Woo
20:24:23 <rwbarton> hmm, i see
21:05:48 <bss03> Hrm, what is a good benchmark for mergable priority queues?
21:06:54 <bss03> I have some that a asymtotically optimal, but they seem slower than simpler implementations.
21:07:28 <bss03> But, right now I'm just looking at the time it takes to run the QC suite, for sizes/#runs in the 3k range.
21:12:08 <byorgey> bss03: if you are serious about benchmarking, you should use the 'criterion' package
21:12:32 <byorgey> (although that doesn't really answer your question)
21:12:58 <bss03> byorgey: I'll look at it.  Surely it's better than what I'm doing. :P
21:14:52 <bss03> byorgey: I want to show an implementation that has good asymptotic behavior, but also has good practical performance.
21:15:01 <byorgey> bss03: also, does http://hackage.haskell.org/package/pqueue not fit your needs?
21:16:10 <byorgey> I think Louis spent a good amount of effort optimizing that implementation
21:16:38 <bss03> byorgey: I'll look at it as a "gold standard" then.
21:17:40 <bss03> byorgey: "My purpose" is to make something faster than we already have. :P
21:18:05 <byorgey> fair enough! In that case don't let me stop you =)
21:19:13 <bss03> byorgey: The implementation says it is a binomial heap + global root.  I'm following on Okasaki paper that has a few improvements on that, and trying to do better than the results in that paper.
21:19:33 <bss03> "the implementaiton" = Data.PQueue.Min
21:20:32 <byorgey> sounds cool
21:21:34 <bss03> Yeah, it's kinda fun.  Though, I don't know it'll actually get anywhere.  It's sort of an acedemic exercise; I'm thinking of going back for a post-graduate degree.
21:25:10 <tommd> Does GHC (not cabal!) define a version or macro so I can conditionally include code for GHC 7 but not GHC 6?
21:25:41 <bss03> The value of __GLASGOW_HASKELL__ (see Section 4.11.3, “Options affecting the C pre-processor”) for a major release x.y.z is the integer xyy (if y is a single digit, then a leading zero is added, so for example in version 6.8.2 of GHC we would have __GLASGOW_HASKELL__==608)
21:26:35 <bss03> tommd: So, check if __GLASGOW_HASKELL__ >= 700?
21:37:50 <int80_h> is there a simple way to write a function with this type foo :: [a] -> [b] -> [Either a b]
21:38:22 <shachaf> @hoogle [a] -> [b] -> [Either a b]
21:38:22 <lambdabot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
21:38:22 <lambdabot> Text.Parsec.Prim runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
21:38:22 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
21:38:29 <bss03> :t \x y -> map Left a ++ map Right b
21:38:30 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Expr'
21:38:30 <lambdabot>     In the second argument of `map', namely `a'
21:38:30 <lambdabot>     In the first argument of `(++)', namely `map Left a'
21:38:30 <shachaf> What do you want the function to do?
21:38:39 <bss03> :t \x y -> map Left x ++ map Right y
21:38:40 <lambdabot> forall a b. [a] -> [b] -> [Either a b]
21:38:49 <shachaf> [Either a b] has more information than ([a],[b])
21:38:57 <ddarius> "The set R consists of triples (s_1, s_2, s_3), where s_1, s_2, s_3 are in R."
21:39:28 <byorgey> ddarius: least or greatest fixed point? =)
21:39:33 <bss03> ddarius: Odd.
21:39:41 <int80_h> bss03: thanks
21:42:20 <int80_h> shachaf : I wanted to merge two lists, and distinguish them with the Left and Right constructors
21:42:32 <shachaf> int80_h: In what order?
21:42:59 <int80_h> shachaf: order isn't important yet. When I am done I will just order the Right values
21:43:38 <shachaf> [Either a b] seems like a weird type to me to represent ([a],[b]) as.
21:43:43 <shachaf> You can do what bss03 said.
21:44:03 <int80_h> shachaf the Left values are being transformed into the Right values through a series of functions, then the Right values will be sorted
21:44:34 <shachaf> Maybe you should say what you're actually trying to do. :-)
21:44:52 <byorgey> but you need the Right values around in order to know what to do with the Left values?
21:45:17 <int80_h> byorgey: yes
21:45:37 <rwbarton> Perhaps it would be best if we just answered your original question "no".
21:45:48 <shachaf> rwbarton++
21:45:49 <ddarius> rwbarton: That's my approach.
21:45:51 <bss03> int80_h, sounds like you should just carry around a [b] and an [a], gradually prepending items to the [b], then sorting it after you are done.  [Either a b] could be used, but it seems--odd--at least to me.
21:47:08 <int80_h> bss03: yeah I am dealing with old functions where I made a [Either a b], only today I realized it's just better to have a ([a],[b]). But for the sake of getting this project done I'm keeping the old structure for now, and I'll change it in the next version.
21:47:31 <bss03> Kk.
21:48:45 <int80_h> I was having a huge problem until I discovered partionEither, then thought "Uh it should just be ([a],[b]) in the first place".
21:48:50 <shachaf> int80_h: Ah. In that case I would say -- well, I'd say to go ahead and change it.
21:49:21 <shachaf> But if you really insist on not doing it then you could do what bss03 said.
21:49:40 <bss03> The type checker will make sure you caught everything if/when you do decide to change it. :)
21:49:53 <int80_h> shachaf: hmm , you know I'm looking this over. You're right, I wouldn't have to re-write that much.
21:50:06 <shachaf> The type checker will help you along!
21:50:55 <int80_h> oh yes I am grateful for the type check. I had help on stackoverflow with a set of complicated types that got severly simplied. The type checker helped me make all the right changes quickly.
21:51:06 <int80_h> simplified
21:52:07 <int80_h> :q
21:52:09 <int80_h> \quit
21:54:49 <bss03> /quit int80_h
21:55:03 <MostAwesomeDude> /quit /quit
21:58:12 <companion_cube> fix /quit
22:06:48 <sshine> hmm.. I've got an infinite list and a list-comprehension on that list, and at some point, the list comprehension stops generating values, and I'd like to know the length of the list so far.
22:07:13 <sshine> I should probably limit the list before doing the list comprehension, but is there another way?
22:07:33 <sshine> i.e. do a list comprehension on an infinite list and obtain a finite list.
22:07:52 <ski> equivalent to the hasling problem (i.e. in general unsolvable)
22:08:05 <sshine> darnit.
22:08:06 <ski> s/hasling/halting/, sorry
22:10:47 <ski> (it's not that hard to write a function `atLeast :: Integer -> [a] -> ()' where `atLeast n xs' will terminate if there's at least `n' elements in the list -- it will simply "block" until it finds that many elements, not terminating if there will never be -- but i suspect this doesn't help much)
22:14:02 <mjrosenb> sshine: i'd do something like keep track of the index into the list, and the number of elements found thusfar, and if the index is N times the the last element found, assume you won't find any more
22:14:06 <mjrosenb> but that is an assumption
22:19:51 <sshine> mjrosenb, I just put a cap on the list, since I know when there are no more values beyond a certain point.
22:33:08 <bss03> The GHC manual says that the interface file shows the strictness of my functions; how do I read the interface file?
22:33:19 <bss03> interface file = *.hi, right?
22:33:53 <bss03> I just see binary noise when I look at it (in less).
22:34:20 <ionit> hello ladies!
22:34:25 <ionit> and gents too
22:35:03 <ionit> I am thinking of learning Haskell
22:35:09 <sshine> congratulations.
22:35:15 <ionit> I have learned C and C++
22:35:23 <ionit> think it should be good for me?
22:35:26 <ionit> I mean easy
22:35:49 <bss03> Haskell is rarely easy to learn, as I understand it.
22:35:54 <mzero> ionit: well... that depends --
22:36:10 <ionit> bss03: why do you have to scare me like that?
22:36:14 <sshine> ionit, you could learn a functional language that isn't lazy to begin with.
22:36:24 <mgsloan> It's easier to learn if you don't expect it to be like the languages you already know
22:36:41 <ionit> no I am not expecting it to be C/C++
22:36:41 <mzero> if you expect Haskell to be sorta-kinda like C or C++, the way Java is sorta-kinda like C++... then it will be hard
22:36:48 <mm_freak> it's easiest to learn if you don't know C and C++
22:36:56 <mm_freak> your own knowledge will get in your way
22:36:57 <bss03> LYAH helps; "You could have invented Monads" explains Monads well; RWH is also good, but I think for later.
22:37:03 <mzero> then, good, put aside what you've learned from C and C++
22:37:05 <mzero> and dive in!
22:37:12 <mzero> we can suggest several good starting points
22:37:18 <mzero> @where LYAH
22:37:19 <lambdabot> http://www.learnyouahaskell.com/
22:37:23 <mzero> @where RWH
22:37:24 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
22:37:26 <ionit> so far I see it has far more stuff that I would usually have to write a function myself
22:37:33 <mm_freak> but other than that, if you have your knowledge under control and completely forget what you knew about programming while learning haskell, you're going to enjoy it =)
22:37:54 <bss03> Oh, also, to "wet yoiur whistle" if you haven't seen much Haskell, is to watch mzero's Haskell Amuse-Booche (sp?).
22:38:20 <mzero> ionit: perhaps, but that really isn't the heart of the matter - the heart of the matter is relearning how to look at programming
22:38:20 <ionit> what is that ? "mzero's Haskell Amuse-Booche (sp?)." ?
22:38:24 <mgsloan> if you're very experienced with the STL and boost lambda / functional, C++ concepts, those can certainly help and map to haskell constructs
22:38:36 <ionit> I see
22:38:39 <mzero> http://www.youtube.com/watch?v=b9FagOVqxmI
22:38:58 <mzero> a 1 hour introductory romp through Haskell for complete newcomers to the language
22:39:04 <bss03> mzero has a video on youtube that is a kind introduction to Haskell.
22:39:18 <mm_freak> it's a demo of haskell
22:39:27 <ionit> I am allergic to *tube
22:39:33 <mm_freak> a great one, too…  sadly it only introduces the pure side of haskell
22:39:35 <ionit> but thanks for the info
22:39:47 <mzero> aimed at getting programmers excited about what Haskell has to offer
22:39:52 <bss03> I think it is also on Google Video -- wasn't it a tech talk, mzero?
22:39:55 <mzero> (It was a 1 hour talk I gave at Google)
22:40:00 <mm_freak> haskell demos rarely even touch stuff like concurrency
22:40:01 <mzero> yup
22:40:02 <ionit> wow!!
22:40:18 <ionit> mzero: I gotta learn how to give talks
22:40:22 <mzero> yeah, it isn't your run-of-the-mill-watch-my-kid-snort-noodles thing
22:40:43 <ionit> I almost had a heart attack when I had to give a speech for 2 minutes
22:41:04 <mzero> heh - well, here I had to keep about 150+ people spell-bound for an hour!
22:41:09 <mzero> took a lot of prep :-)
22:41:19 <ionit> wow!!
22:41:29 <ionit> so you are my give speech hero then
22:41:39 <bss03> Oh, and something I find interesting is the "Haskell for Kids" blogs; it's stuff I already understood when I found it, but if a 12 yr. old can learn Haskell that way, so can you. :)
22:41:44 <mm_freak> haskell teaches you how not to write loops =)
22:41:44 <ionit> I am going through http://tryhaskell.org
22:41:49 <mzero> anyhow, the code and slides are also available -- you can just read 'em if you want, but I suggest hearing my spiel, I'm told I make it sound rather exciting
22:42:07 <ionit> too exciting
22:42:19 <ionit> I mean I am already excited and didn't yet watch the video
22:42:27 <mzero> heh
22:42:31 <mm_freak> mzero: i'd say you have found a good way to show why functional style matterns
22:42:32 <bss03> mzero: You /almost/ convinced one of my roommates to take up Haskell after I put it on the big screen in the TV room.
22:42:34 <mm_freak> matters
22:42:50 <mzero> yikes - on the big screen --- that sounds scary!
22:42:58 <bss03> 54" of glory. :P
22:43:13 * mzero wonders if he shaved that morning...
22:43:31 <ionit> errrr.... where are the int short float part?
22:43:38 <ionit> don't I have to define types?
22:43:57 <rfw> ionit: welcome to the magical world of haskell
22:43:58 <ionit> int iNumbers?
22:44:00 <mzero> where are you looking?
22:44:11 <ionit> I am looking at the chatzilla windo
22:44:14 <ionit> *window
22:44:24 <mm_freak> ionit: types are written capitalized, and you have your usual C counterparts predefined
22:44:25 <mzero> where are the numbers? where are you expecting them
22:44:28 <mzero> > 3
22:44:29 <lambdabot>   3
22:44:30 <mm_freak> Int, Float, Double, Char, etc.
22:44:33 <mzero> look! a number
22:44:34 <bss03> > 3.0
22:44:34 <lambdabot>   3.0
22:44:38 <bss03> :t 3.0
22:44:38 <lambdabot> forall t. (Fractional t) => t
22:44:42 <rfw> ionit: are you talking about declaring types for variables?
22:44:47 <ionit> yep
22:44:53 <mm_freak> ionit: in your type signature
22:44:55 <bss03> Oh, you don't have to do that most of the time.
22:45:00 <rfw> ah, you don't relaly have to
22:45:01 <ionit> ??
22:45:04 <rfw> type inference and all that magic
22:45:05 <ionit> why?
22:45:05 <mzero> exactly!
22:45:07 <bss03> But, we suggest one on each top-level declaration.
22:45:11 <mm_freak> ionit: watch mzero's video
22:45:16 <mm_freak> watch it fully
22:45:16 <rfw> if you type a = 3, haskell can infer that a is an Integer
22:45:24 <bss03> :t 3
22:45:25 <lambdabot> forall t. (Num t) => t
22:45:30 <bss03> :t pi
22:45:31 <ionit> no,I am already excited,if I watch his video,I might get over too excited and die
22:45:31 <rfw> well, a number
22:45:31 <lambdabot> forall a. (Floating a) => a
22:45:32 <mzero> in Haskell you write fewer types, but get stronger type checking!
22:45:48 <bss03> The best types are the types your don't have to type.
22:45:49 <mm_freak> ionit: if you watch his video, you will understand how it works in haskell
22:45:52 <mzero> well, the video might explain why you type fewer types
22:45:58 <ionit> I see
22:46:13 <rfw> ionit: it's best to just completely discard any notions of C++/C things
22:46:14 <ionit> but my internet sucks big donkies ***,its only 512kbps
22:46:18 <bss03> The worst types are the ones where you have to type "type" to tell the compiler your are typing a type.
22:46:20 <mzero> we can explain it here, too, but it might take somewhat long via text
22:46:22 <ionit> 1 hour video will take forever to load
22:46:33 <rfw> and pretend you don't know any programming at all
22:46:40 <ionit> huh?
22:46:41 <Nereid> haskell is exciting!
22:46:45 <bss03> Download it in the background and start reading LYAH.
22:47:00 <ionit> I got the epub version of LYAH in ipad
22:47:05 <mzero> well - just stream it off YouTube - it will take less that 512kbps I'm pretty cure!
22:47:06 <mzero> sure
22:47:07 <bss03> If you ever get stuck on the word "Monad", search for "You could have invented Monads" and read that.
22:47:23 <mm_freak> ionit: it's not really that variables have /data types/, but rather everything has a /type/
22:47:36 <mm_freak> and that's one of the reasons the compiler can figure out the types for you
22:47:44 <ionit> nice compiler
22:47:54 <ionit> what are included in my haskell package?
22:47:55 <mm_freak> if you write 'f x' and 'f' is of type 'Int -> Double', then 'x' must be of type 'Int'
22:48:04 <mm_freak> and whatever is the result of 'f x' must be Double
22:48:06 <rfw> the grass is much greener on this side of the programming language fence, ionit
22:48:17 <mzero> did you install Haskell Platform, ionit ?
22:48:27 <ionit> no,downloading yet
22:48:30 <Rodayo> In regards to this table: "http://www.haskell.org/haskellwiki/Comparison_of_functional_programming_languages" what's a "side-effect" IO?
22:48:30 <lambdabot> Rodayo: You have 1 new message. '/msg lambdabot @messages' to read it.
22:48:38 <ionit> btw will it compile to exe and executables?
22:48:45 <rfw> sure
22:48:46 <mm_freak> ionit: it's not the compiler, it's the language…  a compiler that doesn't infer the types is simply not a haskell compiler =)
22:48:46 <ionit> or just like python script?
22:48:57 <rfw> it does either
22:48:59 <bss03> ionit: The default mode is to compile to a (mostly static) executable.
22:49:06 <mzero> okay - well, you'll get a compiler, an interactive interpreter, and more libraries than you can shake a stick at
22:49:14 <Orthebox> Hi what's the best introduction to Haskell for someone who came from Python? Just wanted to know. Thanks :)
22:49:33 <rfw> Orthebox: i hear people are rather fond of LYAH
22:49:34 <bss03> ionit: You can also produce shared libraries, and I think we are supposed to be able to load modules from shared libraries, but I haven't done that last part yet.
22:49:43 <mm_freak> Orthebox: first learn to act like you don't know any python at all =)
22:49:47 <rfw> Orthebox: at least, i came from python and found LYAH great
22:49:47 <ionit> yep,LYAH is good enough
22:49:53 <mm_freak> Orthebox: then read LYAH or RWH
22:49:54 <mzero> or, if you want to watch an intro, http://www.youtube.com/watch?v=b9FagOVqxmI
22:50:01 <mzero> as we were just saying
22:50:04 <mzero> @where LYAH
22:50:04 <lambdabot> http://www.learnyouahaskell.com/
22:50:12 <ionit> @where mzero
22:50:12 <lambdabot> I know nothing about mzero.
22:50:16 <Orthebox> Thanks guys! What's RWH btw?
22:50:17 <ionit> ??
22:50:23 <mm_freak> @hoogle mzero
22:50:24 <lambdabot> Control.Monad mzero :: MonadPlus m => m a
22:50:27 <mzero> @where RWH
22:50:27 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
22:50:27 <bss03> My newer flatmate to Haskell says LYAH is really good.
22:50:28 <ionit> Real world haskel
22:50:31 <ionit> *haskell
22:50:34 <Orthebox> Oh
22:50:39 <Orthebox> Kk will try both then
22:50:51 <mm_freak> i should change my nick to zeroArrow
22:50:56 <mzero> real world haskell is a book - LYAH starts very small, and builds up in bits -- RWH dives in pretty quick with working programs
22:51:00 <ionit> LYAH is easier to understand than facebook
22:51:01 <mzero> different styles
22:51:05 <Orthebox> But I know that functional programming in haskell is totally different than in python
22:51:11 <Orthebox> ionit: Lol
22:51:23 <ionit> no seriously
22:51:28 <mm_freak> Orthebox: that's because you don't do a great deal of FP in python
22:51:40 <mplus> >>= mzero
22:51:44 <mzero> The video is just a 1 hour romp through some working code for people who've never seen functional programming before
22:51:57 <Orthebox> K man thanks guys gonna try it out
22:52:25 <mm_freak> seems like many people get interested in haskell these days
22:52:28 <mzero> yes, Functional Programming in Python is just a mere hint of what Haskell has to offer
22:52:37 <mm_freak> perhaps the future of programming isn't that bleak
22:52:51 <ski> @where+ mzero mzero's Haskell video : <http://www.youtube.com/watch?v=b9FagOVqxmI> -- "a 1 hour introductory romp through Haskell for complete newcomers to the language"
22:52:51 <lambdabot> I will remember.
22:53:09 <mzero> fun!
22:53:16 <ionit> fun!
22:53:19 <ionit> lazy
22:53:31 <mplus> Having tried to write something like Parsec in Python, I'd have to say that functional programming in python is lacking in some respects.
22:53:39 <ionit> meh ... there are premade functions in haskell
22:53:50 <ionit> so I just tell do this and that
22:53:52 <MostAwesomeDude> mplus: So don't write Parsec. Use Construct.
22:53:57 <mm_freak> mplus: that's really a matter of syntax
22:53:59 <ionit> and am 1337
22:54:01 <mm_freak> and of missing currying
22:54:02 <mzero> don't get hung up on the lazy - btw, you'll get the hang of lazy eventually --- the big deal is pure - lazy implies pure - but purity is what let's you program like you're on steriods
22:54:12 <mplus> The transparency of partial function application makes it easier to compose HOFs
22:54:34 <ionit> think I'll ask my shell provider to install haskell
22:54:53 <mzero> run it locally if you can
22:55:03 <mzero> running ghci in a command shell is a very nice way to explore Haskell
22:55:26 <ionit> I have a local copy,but I am mostly working in a remote shell as I move around a lot
22:55:34 <mm_freak> having it on a server lets you run haskell web sites though
22:55:40 <ski> @where whyfp
22:55:40 <lambdabot> http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html
22:55:43 <ski> might also be interesting
22:55:49 <ionit> haskell websites?
22:55:52 <ionit> what is that?
22:55:59 <mm_freak> ionit: web applications built in haskell
22:56:07 <ionit> heh
22:56:10 <ionit> nice
22:56:10 <ski> a paper by John Hughes, named "Why Functional Programming Matters"
22:56:19 <mm_freak> there are powerful web frameworks for haskell like yesod and snap
22:56:19 <ionit> matters
22:57:01 <ionit> so I can write stuff for wordpress as well?
22:57:08 <mm_freak> no
22:57:13 <mm_freak> wordpress is PHP
22:57:14 <ionit> no?
22:57:20 <ionit> you broke my heart
22:57:23 <mzero> no - you can write a competitor for wordpress!
22:57:27 <ionit> no I meant web applications
22:57:35 <mm_freak> you could write a better wordpress though
22:57:45 <ionit> no wordpress is better as is
22:57:52 <mzero> later all - bed time for me
22:57:53 <ionit> why reinvent a better wheel?
22:57:59 <ionit> gnite
22:58:02 * ski . o O ( "What ails or ales, one thing is clear, spirits are not served in here." )
22:58:33 <mm_freak> ionit: because PHP sucks…  i'd rather reinvent wordpress than write extensions for it in PHP
22:58:46 <mm_freak> i reinvent typo3 extensions on a daily basis
22:59:07 <mm_freak> in haskell that is
22:59:24 <ionit> wow!!
22:59:36 <ionit> so now I can handover haskell to script kiddies then
22:59:39 <bss03> The GHC manual says that the interface file shows the strictness of my functions; how do I read the interface file?
22:59:44 <bss03> interface file = *.hi, right?
22:59:50 <bss03> I just see binary noise when I look at it (in less).
23:00:04 <mm_freak> ionit: deployment of haskell web applications is nontrivial though
23:00:08 <mm_freak> so no, it
23:00:18 <mm_freak> it's not like sending a PHP tarball
23:00:44 <mm_freak> bss03: the interface is not for humans
23:00:47 <ionit> no I mean they can make their own bruteforce google t'day apps by themselves instead of downloading premade trojans in vb
23:01:09 <mm_freak> ionit: i don't understand what you mean
23:01:22 <ionit> joking?
23:01:56 <bss03> mm_freak, then how can I see the strictness properties of my functions?
23:02:16 <bss03> mmfreak: Is there some option to GHC to get it to print that stuff out?
23:03:50 <msieradzki> I forgot what it was but I think there was something that you could run over .hi file to get listing
23:05:01 <ddarius> Don't most of the current Haskell web frameworks produce entire HTTP servers, so deploying is just running the executable?
23:05:45 <bss03> Most of them also have a WAI binding, so you can use SCGI or CGI, too.
23:07:09 <jdavis> Reading LYAH. It mentions the "flip" function with a signature like: "flip' :: (a -> b -> c) -> (b -> a -> c)". What's the difference between that and: "let flip' f x y = f y x"
23:07:42 <rfw> jdavis: the :: thing is the type specification
23:07:54 <bss03> jdavis, nothing
23:07:57 <bss03> @src flip
23:07:58 <lambdabot> flip f x y = f y x
23:07:59 <ddarius> :t let flip' f x y = f y x in f
23:08:00 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
23:08:05 <ddarius> Doh.
23:08:07 <ddarius> :t let flip' f x y = f y x in flip
23:08:08 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
23:08:11 <ddarius> :t let flip' f x y = f y x in flip'
23:08:12 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> t1 -> t -> t2
23:08:15 <rfw> never mind, i can't read
23:08:53 <ionit> :t let x=y in z
23:08:53 <lambdabot> Expr
23:09:05 <ionit> nice
23:09:06 <bss03> :: (a -> b -> c) -> (b -> a -> c) is the same as :: (a -> b -> c) -> b -> a -> c, by associativity of ->
23:09:07 <jdavis> is there any difference between the type specifications: "(a -> b -> c) -> (b -> a -> c)" and "(t1 -> t2 -> t) -> t2 -> t1 -> t"?
23:09:12 <dmwit> Are you asking the difference between a type signature and a definition?
23:09:14 <dmwit> jdavis: no
23:09:14 <jdavis> oh.
23:09:23 <ionit> so lambdabot can execute haskell syntax?
23:09:31 <dmwit> joni6128: yes
23:09:39 <ionit> :t let x= 12.5 in x+x
23:09:40 <lambdabot> forall a. (Fractional a) => a
23:09:44 <ionit> meh
23:09:48 <bss03> > take 5 . fix $ (1:) . scanl (+) 1
23:09:49 <dmwit> > let x = 12.5 in x + x
23:09:49 <lambdabot>   [1,1,2,3,5]
23:09:50 <lambdabot>   25.0
23:10:07 <ddarius> One doesn't normally say that syntax is executed.
23:10:11 <jdavis> Thank you, I was confused about that. I wonder why they opted for the more complex definition then? I think my version is a little more obvious and readable.
23:10:43 <jdavis> wow, nevermind, they explain right afterward.
23:10:45 <dmwit> jdavis: Maybe you should link us to the discussion we're trying to analyze.
23:11:00 <jdavis> http://learnyouahaskell.com/higher-order-functions
23:11:06 * ddarius likes how BONUS has been pluralized.
23:11:17 <jdavis> I just got caught up on that section, but should have read one paragraph down.
23:15:05 <ionit> this is silly
23:15:22 <ionit> but do I define all of my custom functions using let function = do this ?
23:15:40 <ddarius> No, you define none of your (top-level) functions like that.
23:15:42 <bss03> ionit: Not usually.
23:15:49 <ionit> then?
23:15:59 <bss03> ionit: You do in ghci, but in *.hs files, they will just be top level declarations.
23:16:08 <ddarius> ionit: Then you read an introduction to Haskell.
23:16:09 <ionit> ...
23:16:46 <ionit> I'll,but currently I am trying out the lessons in "tryhaskell.org"
23:17:01 <ionit> I like to start from gound zero when I learn something new
23:17:02 <Rodayo> Could someone explain what this function is doing: "filter (not . any isSpace) . groupBy ((==) `on` isSpace) $ "hey guys its me"" ?
23:17:57 <c_wraith> break it down into pieces
23:18:12 <c_wraith> > groupBy ((==) `on` isSpace) $ "hey guys its me"
23:18:12 <bss03> First is groups [spaces] and [non-spaces].
23:18:13 <lambdabot>   ["hey"," ","guys"," ","its"," ","me"]
23:18:23 <bss03> Then, it drops the [spaces].
23:18:51 <bss03> It's a poorly performing words, I think.
23:19:01 <bss03> > filter (not . any isSpace) . groupBy ((==) `on` isSpace) $ "hey guys its me"
23:19:02 <lambdabot>   ["hey","guys","its","me"]
23:19:07 <bss03> > words "hey guys its me"
23:19:08 <lambdabot>   ["hey","guys","its","me"]
23:19:44 <c_wraith> well.  the performance won't be much worse.  Maybe a little
23:20:17 <bss03> Agreed.
23:21:15 <Rodayo> Yeh I got it off learnyouahaskell, i stopped there and had to think about what it was doing
23:21:34 <c_wraith> Rodayo: did you break it down into lots of subexpressions?
23:21:36 <c_wraith> like..
23:21:44 <c_wraith> :t (==) `on` isSpace
23:21:45 <lambdabot> Char -> Char -> Bool
23:22:00 <Rodayo> i understood that part
23:22:09 <Rodayo> i wasn't sure what the first argument to filter was
23:22:20 <c_wraith> :t not . any isSpace
23:22:21 <lambdabot> [Char] -> Bool
23:22:22 <Rodayo> so I guess it's (not . any isSpace) correct?
23:22:28 <c_wraith> yes
23:22:35 <c_wraith> :t any isSpace
23:22:36 <lambdabot> [Char] -> Bool
23:22:47 <c_wraith> > any isSpace "bill"
23:22:48 <lambdabot>   False
23:22:51 <c_wraith> > any isSpace "bill and ted"
23:22:52 <lambdabot>   True
23:23:07 <c_wraith> the (not .) in front just reverses it.
23:23:25 <Rodayo> it's filter composed with groupBy then appleid to the string
23:23:27 <Rodayo> ?
23:23:31 <c_wraith> yes
23:24:22 <c_wraith> remember that function application (by juxtaposition) binds more tightly than infix operator (like '.') application
23:24:37 <Rodayo> okay, makes sense now. I guess I haven't gotten used to reading programs written in this way
23:24:42 <c_wraith> And $ binds the least tightly
23:25:20 <c_wraith> so you're creating the composite function on one side of the $, and applying it to the value on the other side
23:25:34 <bss03> @pl \x y -> f (g x) (g y)
23:25:34 <lambdabot> (. g) . f . g
23:26:22 <c_wraith> bss03: that's liftM2 in the function monad.
23:26:37 <c_wraith> oh, no it's not
23:27:32 <c_wraith> It's close, but liftM2 is about arguments, not functions
23:29:04 <bss03> So, you mean...
23:29:35 <bss03> @pl \f g -> a (f b) (g b)
23:29:36 <lambdabot> (. ($ b)) . a . ($ b)
23:29:39 <c_wraith> yes
23:30:21 <c_wraith> :t liftM2 `asTypeOf` \f g h x -> f (g x) (h x)
23:30:22 <lambdabot> forall a1 a2 r t. (Monad ((->) t)) => (a1 -> a2 -> r) -> (t -> a1) -> (t -> a2) -> t -> r
23:30:37 <bss03> Yeah, I think I might have recognized that at this point.
23:30:57 <c_wraith> Huh.  I've never seen lambdabot spit out (Monad ((->) t)) as a constraint before
23:31:03 <bss03> I've been really "seeing" the Monad properties of ((->) a) since about 2 months ago.
23:31:46 <bss03> Shouldn't lambdabot know (Monad ((->) t))?
23:31:53 <c_wraith> usually, that constraint is only shown by ghc when the instance isn't in scope
23:32:10 <bss03> :t (||) `liftM2` (==1) (==0)
23:32:10 <lambdabot>     Couldn't match expected type `m Bool' against inferred type `Bool'
23:32:11 <lambdabot>     In the second argument of `liftM2', namely `(== 1) (== 0)'
23:32:11 <lambdabot>     In the expression: (||) `liftM2` (== 1) (== 0)
23:32:31 <c_wraith> bss03: that's applying args in the wrong order
23:32:56 <c_wraith> :t (||) `liftM2` (==1) $ (==0)
23:32:56 <lambdabot> forall a. (Num a) => a -> Bool
23:33:27 <bss03> So, it knows about the instance, clearly.
23:33:38 <bss03> But, it still feels compelled to mention it.
23:33:57 <c_wraith> like I said...  ghci will spit out that constraint when the instance isn't in scope
23:34:20 <c_wraith> I've never seen it (or something defined in terms of it, like :t) spit it out when the instance is in scope
23:35:25 <bss03> @pl \x -> f x 0 []
23:35:25 <lambdabot> flip (flip f 0) []
23:44:17 <Sgeo_> Well, that was stupid of me
23:44:27 <Sgeo_> Or, well, ugly-code of me
23:44:47 <hpaste> Sgeo pasted “Silly” at http://hpaste.org/55916
23:45:16 <Sgeo_> Changed into one line
23:45:35 <bss03> (==) . maxError?
23:45:39 <bss03> (==0) . maxError?
23:46:00 <Sgeo_> ..that would work too o.O
23:49:27 <bss03> Well, I should have been in bed hours ago.  More code optimization tomorrow.
