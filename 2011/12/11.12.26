00:00:11 <qnikst> will hIsEOF work in this situation?
00:03:11 <carpi> [ show x ++ [y] | x <- [1,2], y <- ['a'..'d']]  . In the preceeding list comp, is it true that list 'y' will be traversed twice since list x has 2 elements?
00:03:42 <kmc> > [ show x ++ [y] | x <- [1,2], y <- ['a'..'d']]
00:03:44 <lambdabot>   ["1a","1b","1c","1d","2a","2b","2c","2d"]
00:05:02 <kmc> does that answer your question?
00:05:26 <carpi> kmc: does that prove that y is traveresed twice indeed since x has 2 elements? Or in other words, can it be considered that the list x if like the outer loop and list y the inner loop in any imperative language?
00:06:02 <kmc> well each of the elements from 'y' appears twice
00:06:06 <carpi> kmc: sry if i sound confusing. The issue is not with the actual result of that comprehension, as much as it is..a way of thinking about it..
00:07:06 <carpi> But from the result it seems like what i think about list comps is true
00:07:24 <kmc> it's basically true, yeah
00:07:36 <Sgeo> Does anyone use hpage?
00:07:48 <carpi> thanks for the clarification )
00:08:59 <kmc> it's weird to focus on the verb 'traverse' because that's kind of an implementation detail
00:09:14 <kmc> carpi, try not to worry about verbs like 'traversed', just think about expressions and what they evaluate to
00:09:29 <kmc> declarative / denotational mindset, compared to imperative mindset
00:09:31 <carpi> kmc: true.. it just goes to show im still thinking with an imperative mindset
00:09:35 <kmc> yeah
00:09:50 <carpi> can't seem to come out it.. this sucs
00:09:58 <kmc> you'll get it eventually
00:11:31 <carpi> last night.. i was trying to write a simple function to list out the primefactors of a number. I did it using recursion and then wondered if i can do it without using recursion. And i spent all day trying to do just that using foldl, until someone here told me about unfoldr..
00:11:46 <kmc> imperative mindset is frequently useful, even in Haskell
00:12:06 <kmc> but it's a shitty default
00:12:22 <kmc> we should think first about what programs mean, and only when necessary think about what they do step by step
00:12:44 <carpi> thats when i realized, you can't use 'product' to do '+'. so in haskell its even more important to use the right function for the job
00:12:49 <kmc> by the way ghc supports a variation of the list comprehension which produces another result
00:12:54 <kmc> > [ show x ++ [y] | x <- [1,2] | y <- ['a'..'d']]
00:12:55 <lambdabot>   ["1a","2b"]
00:13:34 <carpi> thats like a zip
00:13:38 <kmc> this acts like zipWith, whereas the original acts like concatMap
00:13:39 <kmc> yep :)
00:16:24 <kmc> > let sum = log . product . map exp in sum [2,3]   -- using 'product' to do '+'  ;)
00:16:26 <lambdabot>   5.0
00:16:32 <kmc> historically the reverse is more important
00:17:22 <carpi> i would have never thought of making a list comp like that if i wanted such a result.. i would have used zip. but is there any difference ? say in terms of speed ? i think using 'zip' is more readable
00:17:54 <kmc> i also think zip or zipWith is more readable, in most cases
00:18:16 <kmc> but i also think 'map' and 'filter' are more readable than plain old list comprehensions
00:18:32 <kmc> (the zipping comprehensions are slightly worse because they aren't standard Haskell; it's a GHC extension)
00:19:12 <kmc> imo the most useful property of list comprehensions is that pattern match failure discards that element
00:19:15 <kmc> @src catMaybes
00:19:15 <lambdabot> catMaybes ls = [x | Just x <- ls]
00:19:17 <carpi> ah okay.. so whatever can be done with list comps can be done with a combination of maps and filters
00:19:25 <kmc> if you are making use of this feature, it is harder to translate to map, filter, etc.
00:19:35 <kmc> the result is uglier
00:21:15 <kmc> carpi, yeah, list comprehensions are defined in terms of a translation to more fundamental syntax
00:21:18 <kmc> http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11
00:23:02 <kmc> the translation of list comprehensions into concatMap etc. is very similar to the translation of 'do' syntax into (>>=) etc
00:23:32 <kmc> in fact GHC has an extension which generalizes comprehensions to all types which have defined an (>>=) operator
00:23:45 <kmc> for lists,   xs >>= f  =  concatMap f xs
00:24:08 <kmc> (this generalization of comprehensions was also present in old versions of Haskell, but was removed in Haskell 98 for some reason)
00:25:42 * hackagebot multirec 0.7.1 - Generic programming for families of recursive datatypes  http://hackage.haskell.org/package/multirec-0.7.1 (AndresLoeh)
00:27:56 <salisbury> > ("a", 2, 4) == ("a", 2, 4)
00:27:57 <lambdabot>   True
00:29:31 <Sgeo> > ('a', 2, 4) == ("a", 2, 4) -- Will not type
00:29:31 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
00:29:32 <lambdabot>         against inferred type...
00:30:12 <carpi> the link you gave me, mentions the 'let' expressiosn can be used in list comps.. how would that work? [x + n | x <- [1,2,3], let n = 3]? but that example is trivial
00:31:08 <kmc> > [ (a,c)  |  a <- [3..5],  let b = a*a,  c <- [b..b+2] ]
00:31:09 <lambdabot>   [(3,9),(3,10),(3,11),(4,16),(4,17),(4,18),(5,25),(5,26),(5,27)]
00:31:27 <salisbury> Sgeo, what are single quotes actually for?
00:31:39 <kmc> single quotes are for character literals
00:31:41 <kmc> :t 'x'
00:31:41 <lambdabot> Char
00:32:04 <kmc> double quotes are string literals; strings are lists of chars
00:32:54 <kmc> "a" = ['a']
00:34:16 <Sgeo> > show ['a', 'b', 'c']
00:34:17 <lambdabot>   "\"abc\""
00:34:23 <Sgeo> Ok, that was a bad idea
00:34:31 <Sgeo> > ['a', 'b', 'c'] == "abc"
00:34:32 <lambdabot>   True
00:35:05 <ion> > ['a', 'b', 'c']
00:35:06 <lambdabot>   "abc"
00:35:23 <salisbury> > (2, 'a' 4) ==  ('a', 2, 4)
00:35:24 <lambdabot>   Couldn't match expected type `t1 -> t'
00:35:24 <lambdabot>         against inferred type `GHC.T...
00:35:34 <salisbury> > (2, "a" 4) ==  ("a", 2, 4)
00:35:35 <lambdabot>   Couldn't match expected type `t1 -> t'
00:35:35 <lambdabot>         against inferred type `[GHC....
00:35:39 <salisbury> hmm
00:35:52 <kmc> > 'a' 4
00:35:53 <lambdabot>   Couldn't match expected type `t1 -> t'
00:35:53 <lambdabot>         against inferred type `GHC.T...
00:35:54 <salisbury> no "False"
00:36:02 <salisbury> ohh..
00:36:06 <salisbury> > (2, "a", 4) ==  ("a", 2, 4)
00:36:07 <kmc> there are two problems, one is that you're missing a comma
00:36:07 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
00:36:07 <lambdabot>    arising from the literal ...
00:36:12 <kmc> but it's a type error anyway
00:36:20 <kmc> > 'x' == True
00:36:21 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
00:36:21 <lambdabot>         against inferred type...
00:36:27 <kmc> (==) can only compare things of the same type
00:36:58 <kmc> :t (2, 'a', 4)
00:36:59 <lambdabot> forall t t1. (Num t, Num t1) => (t, Char, t1)
00:37:04 <kmc> :t ('a', 2, 4)
00:37:05 <lambdabot> forall t t1. (Num t, Num t1) => (Char, t, t1)
00:37:14 <Sgeo> > 1 == 2
00:37:15 <lambdabot>   False
00:37:16 <salisbury> I was wondering if the order was important
00:37:21 <kmc> yes
00:44:01 <kmc> the type of a tuple includes the types of its elements, in order
00:44:53 <kmc> :t ('a', True, Just 'x')
00:44:54 <lambdabot> (Char, Bool, Maybe Char)
01:04:32 <Jeanne-Kamikaze> is paul h. liu here by any chance ?
01:35:56 <hrolf_> In Haskell how are lists compared? Like [3,2,1] > [2,10,100] would give True. But how? 3 > 2 => True, 2 > 10 => False, 1 > 100 => False ?
01:37:08 <ion> Say, you have a list of numbered sections and subsections like 3.2.1 and 2.10.100 for a book. Which would come later?
01:37:49 <hrolf_> 3.2.1 would be later.
01:38:10 <ion> @src [] >
01:38:10 <lambdabot> Source not found. I've seen penguins that can type better than that.
01:39:00 <hrolf_> ion: But what is this type of comparison called?
01:39:45 <ion> hrolf: http://en.wikipedia.org/wiki/Lexicographical_order
01:41:54 <hrolf_> ion: That is rather difficult to understand for someone with a weak mathematical fu. (me)
01:42:59 <ion> It’s exactly how you’d intuitively sort strings, but generalized to any sortable values.
01:44:12 <ddarius> In fact, since Strings are lists of characters in Haskell, it is exactly that.
01:45:17 <ion> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Classes.html#line-189
01:49:00 <Sgeo> Is there a general way to say "A function that takes any amount of arguments and returns an IO ()"?
01:49:22 <ion> Define “any”.
01:49:50 <Sgeo> Such that, say, String -> IO () fits, and FilePath -> String -> IO () fits, etc. etc.
01:51:17 <ion> Well, “a function”. :-)
01:51:28 <Sgeo> And that String -> Int doesn't fit.
01:53:48 <c_wraith> are there ways to do it?  yes.  Are any of them good?  Not especially.
01:55:02 <c_wraith> like, you could do something with polykinds and gadts.  you could do something with printf-style instances.
01:55:24 <c_wraith> neither is going to be especially easy to use
01:56:29 <c_wraith> actually, an instance-based approach would be easier than printf
01:56:49 <Sgeo> Isn't instance-based approach basically what printf uses?
01:56:59 <c_wraith> yes
01:57:04 <c_wraith> I just meant it wouldn't need to be as complex
01:57:11 <Sgeo> Ah
01:57:11 <c_wraith> you'd only need one class
01:57:51 <Sgeo> I understand the technique well enough, I think.
02:01:42 <c_wraith> create some class.  create an instance Foo (IO ()) and an instance Foo b => Foo (a -> b)
02:02:03 <c_wraith> and so long as no other instances sneak in, it does what you want
02:06:00 <donri> how bad is it to use a license not known to cabal? i want to use the 2-clause bsd license :/
02:07:43 <donri> i guess it wouldn't be too bad to list it as BSD3 and actually have BSD2 in the license file?
02:07:57 <c_wraith> just list it as BSD2
02:08:05 <c_wraith> edit the .cabal file
02:08:09 <donri> but cabal doesn't know about BSD2?
02:08:13 <c_wraith> it doesn't care
02:08:16 <donri> OK
02:08:24 <c_wraith> it has a list of things it will auto-generate for you
02:08:25 <donri> i thought maybe hackage2 cared
02:08:30 <c_wraith> But it doesn't care about the actual content
02:08:51 <donri> if it will autogenerate, why does it complain for BSD3 about missing license-file?
02:09:46 <c_wraith> I think it complains about a missing LICENSE file if you have anything set
02:09:59 <c_wraith> or maybe just if you upload to hackage without a LICENSE file
02:10:08 <donri> so what does autogenerate mean?
02:10:14 <donri> i might've misunderstood
02:10:14 <c_wraith> if you run cabal init
02:10:24 <c_wraith> it will create LICENCE files for you
02:10:27 <c_wraith> based on what you choose
02:10:31 <donri> oh
02:10:59 <donri> thanks then :)
02:12:03 <donri> "License names are the constants of the License type." does that mean I should write it like "UnknownLicense "BSD2"" or does cabal do that for me internally?
02:12:47 <c_wraith> not sure, there
02:12:55 <c_wraith> it probably does that for you
02:13:31 <donri> * 'license: BSD2' is not a recognised license.
02:14:16 <donri> i'll just set it to OtherLicense and refer to license-file
02:14:26 <donri> it couldn't parse UnknownLicense with arguments :P
02:27:41 <Renze> Hi!
02:28:13 <Sgeo> Hi
02:28:18 * Sgeo should be asleep right now
02:29:07 <ChemisTree> how did you make that comment Sgeo
02:29:27 <Sgeo> Repeat after me:
02:29:32 <Sgeo> /me learned how to use /me.
02:29:37 <Renze> I've got a strange problem: System.Random is installed (standard with Haskell Platform, and I reinstalled it), but ghci and ghc both say: 'Could not find module `System.Random`'. How can i fix this?
02:30:12 <ChemisTree> me
02:30:14 <ChemisTree> '.e
02:30:17 * ChemisTree
02:30:20 <Sgeo> Yay
02:30:27 <Sgeo> /me says hello
02:30:28 <ChemisTree> ?? cool
02:30:28 <lambdabot>  cool
02:30:29 * Sgeo says hello
02:30:51 * ChemisTree like this? /me
02:30:56 <Sgeo> Yes
02:31:09 <ChemisTree> oh, but drop the '/me'
02:31:16 <Sgeo> Drop the last me, not the first
02:31:38 * ChemisTree yeah
02:31:44 * Sgeo claps
02:31:53 * ChemisTree bows
02:32:39 <ChemisTree>  /me
02:33:38 <ChemisTree> what other commands are there in this IRC besides /me and /join ?
02:34:13 <ChemisTree> ?
02:34:16 <donri> @google irc commands
02:34:18 <lambdabot> http://www.ircbeginner.com/ircinfo/ircc-commands.html
02:34:18 <lambdabot> Title: #Beginner - IRC Commands, the Basics
02:34:22 <cwl> snap-extension-mongodb no longer exists in the repository
02:34:30 <cwl> I have a project depends on it
02:34:41 <cwl> how to build the project
02:35:01 <cwl> what is the better way to work around such problem
02:35:17 <donri> cwl: perhaps port it to snaplet-mongoDB?
02:35:43 * hackagebot servius 0.0.0 - Serve Shakespearean templates via Warp  http://hackage.haskell.org/package/servius-0.0.0 (MichaelSnoyman)
02:35:45 * hackagebot shakespeare-css 0.10.5 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-0.10.5 (MichaelSnoyman)
02:35:45 <cwl> donri: I don't like programming with snaplet
02:35:48 <Sgeo> Some clients let you easily escape / at the beginning of a line with another /
02:35:55 <cwl> hate that style
02:36:00 <Sgeo> //me becomes /me
02:36:03 <cwl> make me write more code
02:36:07 <Sgeo> If I want to say
02:36:09 <Sgeo> /me waves
02:36:11 <Sgeo> I write:
02:36:12 <donri> cwl: if you're going to use snap and want to reuse integration libs, snaplets are the way to go
02:36:13 <Sgeo> //me waves
02:36:23 <donri> cwl: so either set up mongo yourself or don't use snap :P
02:37:04 <cwl> donri: I like snap before 0.6, the code is clean and easy to understand
02:37:55 <cwl> what a pity
02:38:25 <donri> what's wrong with snaplets though?
02:38:32 <ChemisTree> ..
02:39:32 <donri> cwl: if you're confused by the docs for snaplets, i think those are for people creating snaplets and not necessary for using existing snaplets
02:39:56 <psylo>  
02:40:11 <cwl> donri: for example, I want to set something in session. with snaplet, I write `withSession $ setInSession ...`, with the pure snap, ApplicationState is an instance of HasSession, and I write `setInSession`
02:40:43 * hackagebot shakespeare-i18n 0.0.0 - A type-based approach to internationalization.  http://hackage.haskell.org/package/shakespeare-i18n-0.0.0 (MichaelSnoyman)
02:40:45 * hackagebot shakespeare-js 0.10.4 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-0.10.4 (MichaelSnoyman)
02:41:02 <donri> cwl: do you actually have to bother with that though?
02:41:21 <cwl> what?
02:41:27 <cwl> I don't understand
02:41:44 <donri> i thought snaplets weren't required for application code
02:42:41 <spuz> If I have a function such as: randomText gen = take 100 $ randomRs ('a', 'z') gen
02:42:44 <spuz> how would I call it multiple times and get a different random string each time?
02:42:53 <donri> spuz: state monad
02:43:33 <Renze> you can get a new gen back from random
02:43:42 <rodayo> Since haskell programs use recursion to implement loops does stack overflow ever become an issue? Or does the compiler turn it into an actual loop?
02:44:15 <donri> foldl can easily overflow the stack right?
02:44:16 <cwl> donri: I can just ignore the existence of snaplets, but the snap-extension-* disappears
02:44:23 <Renze> randomR ('a', 'z') gen = (char, gen)
02:44:43 <donri> cwl: because they'll internally use the snaplets api, but you don't need to work directly with it yourself i think?
02:44:44 <cwl> why don't they just let it stay in the repository as an old version
02:45:16 <spuz> donri: what does the state monad give me?
02:45:40 <donri> spuz: you can thread through the creation of new random generators
02:45:47 * hackagebot wai-extra 0.4.6 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.4.6 (MichaelSnoyman)
02:45:49 * hackagebot warp 0.4.6.3 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-0.4.6.3 (MichaelSnoyman)
02:45:51 * hackagebot yesod 0.9.4 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.9.4 (MichaelSnoyman)
02:45:53 * hackagebot yesod-core 0.9.4 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.9.4 (MichaelSnoyman)
02:45:55 * hackagebot yesod-default 0.5.0 - Default config and main functions for your yesod application  http://hackage.haskell.org/package/yesod-default-0.5.0 (MichaelSnoyman)
02:46:56 <donri> spuz: http://book.realworldhaskell.org/read/monads.html#monads.state.random
02:50:57 * hackagebot yesod-form 0.3.4.2 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-0.3.4.2 (MichaelSnoyman)
02:50:59 * hackagebot yesod-json 0.2.2.3 - Generate content for Yesod using the aeson package.  http://hackage.haskell.org/package/yesod-json-0.2.2.3 (MichaelSnoyman)
02:51:01 * hackagebot yesod-static 0.3.2.1 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-0.3.2.1 (MichaelSnoyman)
02:56:32 <Jeanne-Kamikaze> when instancing Storable to be able to pass structures to C, is there a difference between "sizeOf _ = #{size my_struct}" and "sizeOf _ = (#size my_struct)" ? These tutorials use different syntax and none explain what all of this stuff is.
02:57:01 <c_wraith> Jeanne-Kamikaze: those parens are entirely outside the hsc2hs scope
02:57:18 <c_wraith> it's the difference between 4 and (4)
02:57:24 <Jeanne-Kamikaze> oh
02:57:27 <c_wraith> that is, none at all, when it's a single token
02:57:48 <c_wraith> the {} are a little more interesting
02:57:55 <Jeanne-Kamikaze> so, #size my_struct is the same as #{size my_struct} ?
02:58:00 <c_wraith> yeah
02:58:10 <c_wraith> I don't remember when the {} are required
02:58:12 <Jeanne-Kamikaze> why have two different versions of the same thing ?
02:58:13 <Jeanne-Kamikaze> ah
02:58:17 <c_wraith> but I prefer to use them, because it's clearer
03:00:17 <c_wraith> I think when they're necessary is when they group something, like...  #{foo bar} baz
03:00:18 <carpi> what is the meaning of the word 'combinator'? i see it popping up in all sorts of places.. wikipedia has a vague description of 'combinator logic' and not 'combinators' as nouns
03:00:31 <c_wraith> otherwise, the # scopes arguments to the end of the line
03:00:34 <carpi> or maybe they both are same
03:01:55 <c_wraith> combinators are often defined as functions that work on other functions
03:02:40 <carpi> so its basically a mathematical term for higher order functiosn
03:02:59 <c_wraith> depends on who's doing the defining, mostly
03:03:34 <Sgeo> When writing a type signature, is it unstylish to put unneeded parentheses in to better indicate the intended intuition?
03:04:04 <copumpkin> I'll sometimes write unnecessary parentheses to illustrate correspondences that are meaningful
03:04:09 <copumpkin> like fmap :: (a -> b) -> (f a -> f b)
03:04:11 <Botje> if you're returning a function, sure
03:06:07 <Jeanne-Kamikaze> ok thanks
03:10:45 * hackagebot hmatrix 0.13.0.0 - Linear algebra and numerical computation  http://hackage.haskell.org/package/hmatrix-0.13.0.0 (AlbertoRuiz)
03:10:47 * hackagebot hmatrix-tests 0.1.0.0 - Tests for hmatrix  http://hackage.haskell.org/package/hmatrix-tests-0.1.0.0 (AlbertoRuiz)
03:17:00 <aristid> too bad hmatrix is GPL
03:20:46 * hackagebot hmatrix-special 0.2.0 - Interface to GSL special functions  http://hackage.haskell.org/package/hmatrix-special-0.2.0 (AlbertoRuiz)
03:20:48 * hackagebot hmatrix-glpk 0.3.0 - Linear Programming based on GLPK  http://hackage.haskell.org/package/hmatrix-glpk-0.3.0 (AlbertoRuiz)
03:20:50 * hackagebot hTensor 0.8.0 - Multidimensional arrays and simple tensor computations.  http://hackage.haskell.org/package/hTensor-0.8.0 (AlbertoRuiz)
03:27:52 <carpi> in quickcheck is it possible to tell one of the generator functions to produce  a list of a certain size?
03:28:23 <carpi> i tried "sample' $ resize 20 $ elements [1,2,3,4]" but it always produces a list of size 11
03:31:05 <iwtu>  /bye
03:31:20 <iwtu> exit
03:44:33 <Sgeo> Well, that was an interesting crash course in MPTC, fundeps, and FlexibleInstances
03:48:27 <carpi> no wories : ) "sample $ suchThat (listOf (elements [1,2])) (\x -> (length x) == 5)" works
03:49:03 <carpi> ah shite.. i just realized theres a function just for this 'vectorOF'
03:53:13 <Sgeo> FlexibleInstances was wrong. UndecidableInstances was right
03:53:13 <Peaker> I've grown to find ((==5) . length)  more readable than \x -> length x == 5
03:53:34 <Sgeo> (After I fixed a bug I found not by testing, but by staring at the code until I understood what I wrote and how it differed from what I wanted)
03:53:57 <Peaker> Sgeo: what was the bug?
03:54:22 <Sgeo> A failure to do the induction I actually wanted between instances
03:54:43 <Sgeo> instance (MakeFunCapClass a b) => MakeFunCapClass (a -> IO b) (a -> Cap b) where
03:54:47 <Sgeo> That is not what I wanted
03:54:57 <Sgeo> What I wanted was instance (MakeFunCapClass a b) => MakeFunCapClass (c -> a) (c -> b) where
03:54:57 <Sgeo>  I think
03:59:43 <Sgeo> http://hpaste.org/55731
04:02:40 <nlogax> has anyone here used shake? wondering how to get a list of files from a directory and then `want` all of them (after replacing dir and extension)
04:03:53 <Peaker> nlogax: the newly released one? ndm said he wouldn't use it for production just yet :-(  (I just looked at it, it doesn't seem to be fully implemented yet)
04:04:26 <Peaker> nlogax: I think the actions exported are mostly in the Act monad, rather than the Shake monad.. Maybe there's a lifter from the former to the latter?
04:09:00 <nlogax> Peaker: oh, i see. yes, there's `getDirectoryFiles :: FilePath -> FilePattern -> Action [FilePath]`, and `want [FilePath] -> Rules ()`, i tried fmapping `want . replaceStuff` to fit into the main `shake :: ShakeOptions -> Rules () -> IO ()` function, and it typechecked but just didn't do anything :P
04:18:10 <Sgeo> To whoever told me that I could in fact do what I wanted with a printf-style system: Thank you so much!
04:18:22 <Sgeo> Although I ended up using MPTCs and Fundeps and Undecidable Instances
04:23:07 <mreh> i always wondered about a printf-style type system
04:23:40 <mreh> you could potentially end up writing all those rules
04:35:56 <Future28> I was recommended to come here from the math channel.
04:36:10 <Future28> I'm after some answers relating to maths in computer science
04:38:50 <mah_b> you should probably ask if you want answers :)
04:39:13 <Future28> What sort of maths and how much of it is involved in computer science?
04:52:21 <ChemisTree> what about a specific question
04:52:56 <Future28> What sort of maths is involved in computer science?
04:53:03 <ChemisTree> discrete mathematics
04:53:03 <Future28> How much math is involved in computer science?
04:53:16 <ChemisTree> recursive statements
04:53:24 <ChemisTree> algebra
04:53:32 <ChemisTree> Boolean logic
04:53:48 <ChemisTree> infinite sets
04:54:20 <ChemisTree> patterns
04:54:45 <Future28> I'll do some research on those, thanks for your help.
04:55:56 <ChemisTree> sure, but I think other's in here could provide better computer science math topics to research
04:56:10 <Future28> Yep, maybe I'll drop in tomorrow, it's getting late..
04:56:22 <ChemisTree> Discrete Mathematics  seems to be most suited for this
04:56:28 <Future28> Yep
04:56:56 <ChemisTree> it's early here
04:57:04 <ChemisTree> ?me stretch
04:57:04 <lambdabot> Maybe you meant: messages messages? . ? @ bf do ft id let map more msg pl rc time v wn
04:57:19 * ChemisTree stretch
04:57:44 <Future28> Haha
04:57:50 <Future28> It's about 1am here
04:58:13 <ChemisTree> Hawaii?
04:58:23 <Future28> No!
04:58:28 <ChemisTree> no, australia
04:58:30 <Future28> Australia!
04:58:33 <Future28> Hahaha.
04:58:41 <Future28> Nice,
04:58:44 <ChemisTree> ha
04:59:11 <Future28> Thanks again, I might drop in again soon.
04:59:28 <ChemisTree> ever been to eden project?
05:00:04 <Future28> What's that?
05:00:31 <Future28> A quick google search shows me somewhere in the UK
05:00:33 <Future28> So no
05:02:17 <carpi> are there any libraries on hackage for indexing text files?
05:10:48 * hackagebot yesod-json 0.2.3 - Generate content for Yesod using the aeson package.  http://hackage.haskell.org/package/yesod-json-0.2.3 (FelipeLessa)
05:13:01 * Sgeo made id a security hole :/
05:14:15 <mreh> carpi: IxSet?
05:14:26 <mreh> that's like a generic index datatype
05:14:55 <mreh> i've never had the chace to put it through its paces though
05:15:29 <mreh> just use an associative list if you're really stuck for an implementation
05:16:29 <mreh> you can provide IxSet with functions to extract indexes from your data, it's quite neat
05:17:17 <carpi> thanks.. i will check it out. is it something that comes with haskell or is it on hackage?
05:17:24 <mreh> hackage
05:17:33 <mreh> do you plan on keeping these text files in memory?
05:18:03 <mreh> (a practical consideration)
05:18:31 <carpi> one at a time..
05:18:41 <carpi> so i open a file, index it and then close it
05:18:44 <carpi> and then the next one
05:19:12 <mreh> what do you plan to do with this index?
05:19:26 <mreh> store it?
05:20:01 <carpi> ...search for a string from that index to determine the most likely file to contain to information required
05:20:12 <carpi> s/to/the
05:21:02 <mreh> if you're performing frequency analysis, you might need to roll your own
05:22:38 <carpi> so if the name of the program is hasdex then 'hasdex "cancer treatment" "medindex"' should give a list of results that contains the names of files that are most likely to have information about cancer treatement
05:30:14 <hpc> i just installed debian testing on this server
05:30:33 <hpc> should i install the platform through apt, or install just ghc and then cabal the rest?
05:31:09 <Saizan> depends how much of the platform you want, i guess
05:32:32 <hpc> Saizan: im not sure how much of it i want
05:33:00 <hpc> i definitely need gtk, mueval, hdbc, posix, and the sha1 package
05:33:16 <din> hy
05:33:29 <din>  how can i learn haskell
05:34:03 <hpc> @where lyah
05:34:04 <lambdabot> http://www.learnyouahaskell.com/
05:34:06 <hpc> din: ^
05:34:42 <din> is it case sensitive
05:34:57 <maltem> din, the Haskell wiki should have a list of resources somewhere
05:37:57 <maltem> Call that fast information retrieval
05:38:40 <hpc> Saizan: mostly i just want to be able to install any package i want, without worrying about breaking everything
05:38:46 <mike-burns> It's easier to apt-get install haskell-platform.
05:40:06 <hpc> mike-burns: i know it's easier, and is what i did before; im wondering which one will be more future-proof
06:03:42 <Mathnerd314> 5 years...
06:22:55 <augur> !seen edwardk
06:22:59 <augur> @seen edwardk
06:22:59 <lambdabot> Unknown command, try @list
06:23:01 <augur> :|
06:23:36 <hpc> preflex: seen edwardk
06:23:36 <preflex>  edwardk was last seen on #haskell 1 day, 8 hours, 36 minutes and 23 seconds ago, saying: @tell roconnor sounds good. feel like maintaining a package? =)
06:27:47 <rewq123> can I disable logging to stderr (default) in hslogger? I just want to log to a file.
06:30:27 <Jeanne-Kamikaze> can someone help me with lazyness ? How do I force the evaluation of v2' here: http://hpaste.org/55733 ? The timer is being ticked before v2' is evaluated, so the time offset is wrong
06:30:41 <hpc> rewq123: looking through hslogger's documentation, it looks like it might be possible, but i can't see how i would do it
06:31:18 <hpc> :t evaluate -- Jeanne-Kamikaze
06:31:18 <dylukes> Jeanne-Kamikaze: Looks like the evaluation of mul is not the problem,
06:31:18 <lambdabot> Not in scope: `evaluate'
06:31:23 <hpc> @hoogle evaluate
06:31:24 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
06:31:24 <lambdabot> Control.Exception evaluate :: a -> IO a
06:31:24 <lambdabot> Control.OldException evaluate :: a -> IO a
06:31:27 <dylukes> but rather, when v1 and v2 are being evaluated.
06:31:28 <hpc> @hoogle rnf
06:31:28 <lambdabot> Control.DeepSeq rnf :: NFData a => a -> ()
06:31:35 <mike-burns> rewq123: Maybe you can use setHandlers to do that?
06:31:51 <hpc> Jeanne-Kamikaze: do {...; evaluate $ rnf blah; ...}
06:32:18 <Jeanne-Kamikaze> will try that thanks
06:32:25 <hpc> Jeanne-Kamikaze: there are likely better solutions; that was just an off-the-top-of-my-head idea
06:32:41 <Jeanne-Kamikaze> dylukes, what's the problem with v1 and v2 ?
06:33:21 <dylukes> oh, I misunderstood slightly, I see.
06:33:30 <dylukes> Use seq.
06:33:33 <Jeanne-Kamikaze> hpc, it works thanks
06:33:44 <Jeanne-Kamikaze> dylukes, I tried using seq and it didn't do it, maybe I did it wrong
06:34:00 <Jeanne-Kamikaze> I tried: let v2' = let v = mul v1 v2 n in v `seq` v
06:34:19 <dylukes> erk
06:34:20 <dylukes> http://neilmitchell.blogspot.com/2008/05/bad-strictness.html
06:34:21 <dylukes> See this.
06:34:24 <hpc> seq evaluates to weak head normal form (ie, one constructor deep)
06:34:28 <dylukes> x `seq` x is never right.
06:34:32 <Jeanne-Kamikaze> oh
06:34:39 <Jeanne-Kamikaze> will give it a read, thanks
06:34:50 <rewq123> mike-burns: maybe using, 'updateGlobalLogger rootLoggerName' with setHandlers and an empty list?
06:34:52 <Jeanne-Kamikaze> at least I got the one in mul right :D, it was stack overflowing
06:35:28 <mike-burns> rewq123: Yeah, or the handler for the file you want to log to in the list.
06:36:08 <rewq123> mike-burns: will try it, thanks
06:36:57 <joe9> anyone tried the haskell web browser? any thoughts? like it or hate it? too slow?
06:37:25 <mike-burns> Couldn't get it to build.
06:40:15 <rewq123> mike-burns: works nicely, thanks again!
06:40:33 <mike-burns> Glad to hear it.
06:45:25 <Jeanne-Kamikaze> dylukes, lazy strictness, I see...
06:55:50 * hackagebot palindromes 0.2.1 - Finding palindromes in strings  http://hackage.haskell.org/package/palindromes-0.2.1 (JohanJeuring)
07:00:05 <augur> any good haskell videos lately?
07:00:32 * dylukes still bemoans the lack of Haskell the Movie.
07:00:38 <singpoly1a> If I have a handle representing a network connection, and I give the handle to two separate threads.  And one of those threads only reads from the handle and the other only writes.  Is that safe?
07:00:53 <Saizan> i want Haskell the Operetta
07:01:09 <Saizan> singpoly1a: yeah
07:01:36 <singpoly1a> Saizan: cool.  thanks
07:14:04 <mike-burns> augur: http://goo.gl/8QAxU - here's a recent Haskell video.
07:25:50 * hackagebot strptime 1.0.3 - Efficient parsing of LocalTime using a binding to C's strptime,  with some extra features (i.e. fractional seconds)  http://hackage.haskell.org/package/strptime-1.0.3 (EugeneKirpichov)
07:29:14 <ion> mike-burns: Thanks
07:30:48 <rewq123> I want to do a lot of database queries from my small app using ODBC. Are there any alternatives to HDBC-odbc for this?
07:31:29 <hpc> rewq123: the obnoxious answer would be to use HDBC-postgres or HDBC-mysql :P
07:31:51 <rewq123> hpc: for MS SQL SERVER? :)
07:32:48 <hpc> rewq123: not sure; there's some higher-level packages that you might like to look at
07:33:05 <hpc> i forget the names; they are in the database category
07:33:45 <rewq123> hpc: I have issues with speed, but I don't really know if HDBC is slow, or if it's just the ODBC overhead
07:34:03 <hpc> rewq123: i haven't had performance issues with hdbc
07:35:42 <rewq123> hpc: I have to read 100M rows and write them to a different DB
07:36:27 <rewq123> hpc: the previous implementation of this was in C and it's a lot faster
07:36:36 <hpc> huh
07:37:01 <rewq123> hpc: I just don't know if it's because the C implementation isn't using ODBC or because of HDBC
07:37:20 <rewq123> hpc: probably both :(
07:39:31 <rewq123> hpc: so while I'm stuck with ODBC using haskell I want to eliminate any other overhead
07:41:42 <hpc> http://hackage.haskell.org/package/Takusen -- you might like to try that
07:42:39 <rewq123> hpc: thanks, I'll check it out
07:44:01 <Jacco> What is the correct syntax for a type constraint in a polymorphic "data" definition?
07:44:50 <dmwit> Jacco: The correct syntax is not to do it.
07:44:57 <dmwit> Restrict the functions that use that data type instead.
07:46:07 <Jacco> Hmm, ok, but that feels like unnecessary code
07:46:15 <dmwit> If you must, you may look up DatatypeContexts online; however, it doesn't do what you might wish it did. The functions using that data type *still* require the long contexts.
07:46:23 <dmwit> Jacco: eh?
07:46:25 <Jacco> well
07:46:28 <dmwit> "unnecessary code"?
07:46:36 <Jacco> ok, I should be more clear
07:46:38 <Jacco> for instance
07:46:52 <Jacco> making this kind of data: data Dictionary k v = D [(k,v)]
07:46:56 <dmwit> Types get inferred, so you never have to write them explicitly, and they're completely erased, so they don't appear in your final program...
07:47:07 <Jacco> I would like k to be an instance of Eq
07:47:21 <ciaranm> you don't need k to be Eq to know whether your dictionary is empty
07:47:27 <Jacco> I know i could use that constraint in all the functions that need a dictionary
07:47:30 <ciaranm> or to create a dictionary with a single element in it
07:47:41 <dmwit> Jacco: Yes, I'm well aware of the use case.
07:48:01 <gabre> hello
07:48:29 <Jacco> ciaranm: Maybe not for checking if it's empty, but I wouldn't like to have a dictionary with keys that are not comparable
07:48:34 * kejoki__ the noob is finding the ghci "parse error ... [possibly incorrect indentation]" from ghci to be less than helpful
07:49:08 <Jacco> so I should explicitly use the constraint for every function that uses the Dictionary type?
07:49:18 <ciaranm> Jacco: no, just every function that needs it
07:49:50 <gabre> hello all, I d like to ask about the GTK2HS, I have a list [Render ()]
07:50:03 <rwbarton> personally I find it ugly that functions like 'singleton' end up not having the context also
07:50:04 <lambdabot> rwbarton: You have 1 new message. '/msg lambdabot @messages' to read it.
07:50:09 <gabre> and I d like to draw all the elements of the list
07:50:51 * hackagebot buildwrapper 0.2.2 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.2.2 (JeanPhilippeMoresmau)
07:50:56 <gabre> the question is, how can I do it, I tried mapM_ but nothing is drawn on the display
07:51:17 <rwbarton> that seems like an implementation detail that one normally would not want to expose
07:51:18 <hpc> gabre: what does happen?
07:51:19 <hpc> nothing?
07:51:23 <hpc> or does it freeze?
07:51:33 <gabre> nothing is drawn no freeze and no exception
07:51:51 <gabre> no freeze, no exception, no error, just nothing is drawn
07:51:58 <Jacco> ciaranm: but that's not in line with the semantics of a dictionary, a datastructure with keys that, in my opinion should be instance of Eq. There shouldn't be a dictionary that uses a type as key that is not comparable
07:52:08 <gabre> I can show the code
07:52:23 <ciaranm> Jacco: you aren't thinking functionally
07:52:35 <rwbarton> really you'd like to say that Dictionary has kind <Eq> -> * -> * where <Eq> is the subkind of those types which are an instance of Eq
07:53:13 <jro_> is the efficiency of the haskell HashMap O(1) for searches?
07:53:51 <ciaranm> jro_: no hashmap is O(1). define your list of acceptable cheats if you want the answer to be "yes".
07:54:12 <rwbarton> Jacco: what you want is perfectly reasonable, but Haskell doesn't really support it cleanly
07:54:22 <gabre> http://pastebin.com/H8TbDFe8
07:54:25 <mauke> The paste H8TbDFe8 has been copied to http://hpaste.org/55734
07:54:26 <gabre> the code
07:55:02 <hpc> gabre: oh god, are you using single-space tabs?
07:55:14 <gabre> yeah, sorry :S :S
07:55:24 <augur> mike-burns: just finished watching that
07:55:26 <augur> thats why i aked :)
07:55:29 <gabre> I use the default for gEdit
07:56:41 <gabre> (btw the list will be generated, but now, I left it "wired")
07:56:46 <hpaste> hpc annotated “gabre code” with “gabre code (annotation)” at http://hpaste.org/55734#a55735
07:56:48 <jro_> rehrase: what are the conditions ot the the O(1)
07:57:12 <jro_> for lookup
07:57:37 <jro_> same as "anywhere else"
07:58:16 <hpc> gabre: not sure what's wrong, but i suspect you will have to look through the gtk docs or google
07:58:19 <rwbarton> Jacco: even if you could require that the first argument of Dictionary is always a type with an Eq instance, you'd have to write that instance in the context everywhere you use Dictionary, since Haskell doesn't have partial type signatures
07:58:22 <hpc> i don't see anything wrong with your code
07:59:00 <rwbarton> so, the ability to do this doesn't buy you much
07:59:11 <gabre> :( thank u hpc
07:59:58 <rwbarton> lines 7-10 look very implausible
08:00:13 <gabre> I dont know the reason, why nothing is drawn
08:00:15 <jro_> so, I suspect this implementation to fail with scalal in a reason which is relates to the hashmap performance
08:00:29 <jro_> https://github.com/jrosti/asdf/blob/master/functional-programming/src/main/haskell/Phonecode.hs
08:00:55 <gabre> is there a way to test my full code in action?
08:01:27 <gabre> I can pastebin it, and if u have GTK2HS and haskell-platform u can use it
08:04:48 <jro_> Scala 1.6s, Haskell 29.3s, Java 0.24s
08:04:54 <Jacco> rwbarton: Ah, ok I see. So if you see a dataconstructor as a function, restricting that constructor would be restricting only that function and not the type, am I correct?
08:05:17 <ciaranm> jro_: just to be clear: which haskell?
08:05:36 <jro_> 7.03
08:05:42 <ciaranm> as in ghc?
08:05:56 <jro_> oops, ghc version 7.0.3
08:06:28 <jro_> scala -version 2.9.1.final
08:07:55 <hpaste> kejok__ pasted “noob frustration” at http://hpaste.org/55736
08:09:59 <jro_> scala version is is identical with control structures (expect "monad" or list comprenhsesinos), and writte by Odersky
08:10:17 <jro_> The Java version is by Joshua Bloch
08:10:20 <kejoki__> any explanation of http://hpaste.org/55736 much appreciated.
08:12:17 <rwbarton> kejoki__: lines 3-7 don't produce a parse error.
08:14:04 <kejoki__> rwbarton: !!
08:14:50 <kejoki__> ["you are kidding me!!"] !! 0
08:14:59 <rwbarton> ??
08:15:18 <rwbarton> it produced an error that's not a parse error
08:17:08 <siracusa> kejoki__: What's the exact error message?
08:19:33 <kejoki__> Strange.  The error I get is "parse error (possibly incorrect indentation)" at the end of the file.  The function was inserted into a file that loaded just fine.  When I play a bit with how things are lined up, the same error with show up somewhere within the definition.  I'm having a very difficult time isolating what I'm doing wrong.
08:19:48 <kejoki__> with* will
08:21:28 <siracusa> I also only get a type error
08:21:58 <ChemisTree> is this a good channel to ask about using cygwin Terminal in Windows?
08:22:00 <EvanR-work> kejoki__: maybe you have tabs and spaces mixed
08:22:07 <rwbarton> why don't you try removing the last declaration group from your program until the error goes away
08:22:29 <ChemisTree> via comments
08:23:00 <kejoki__> EvanR: doh.  I bet I haven't set up the new emacs to untabify.
08:23:39 <kejoki__> rwbarton: I should've done that before I started whining.  oog.
08:24:05 <ChemisTree> I have the directory open with gvim, now how do I open gVim from Emachine shell?
08:24:31 <ChemisTree> I have the directory open with gvim inside, now how do I open gVim from Emachine shell?
08:24:56 <siracusa> ChemisTree: This channel is about the programming language Haskell
08:30:24 <ChemisTree> Need help: Does this make sense... I am trying to open Vim with command shell (cygwin, bash).
08:31:43 <ChemisTree> am in directory " /cygdrive/c/documents and settings/name"
08:31:57 <siracusa> ChemisTree: --> #cygwin
08:31:58 <mike-burns> ChemisTree: Try #cygwin or #vim .
08:32:07 <ChemisTree> thanks
08:35:55 <gavri> this question probably requires having an understanding of how monads work, but could someone explain how forever works?  http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Monad.html#forever
08:36:23 <gavri> specifically, how is each iteration actually evaluated so that the side effects are forced
08:36:32 <gavri> instead of being lazy
08:36:35 <ciaranm> gavri: that's what >> does
08:36:41 <mike-burns> @src forever
08:36:41 <lambdabot> Source not found. My brain just exploded
08:36:59 <ciaranm> x >> forever x, presumably
08:38:29 <gavri> does IO use the default implementation of >> from the monad typeclass?
08:38:39 <copumpkin> yes, oddly
08:38:44 <copumpkin> even though someone defined a more specialized one
08:38:46 <copumpkin> thenIO
08:39:29 <EvanR-work> why is it odd?
08:39:42 <ciaranm> because it's not even
08:44:09 <ryuk58> i want to this "do writeFile \"out.tex\" $ prettyprint dat $ prettyprint2 dat2" but this way is wrong. how can i solve it?
08:44:23 <kejoki__> and so, my lesson one is "don't use names that are standard type var names" and lesson two is "don't force a type just because."
08:44:26 <ciaranm> ryuk58: what do you think $ does?
08:44:27 <kejoki__>   And thank you to rwbarton.
08:45:12 <gavri> where could I find the definition of bind for IO? hoogle isn't helping
08:45:14 <mike-burns> :t writeFile
08:45:15 <lambdabot> FilePath -> String -> IO ()
08:45:19 <ryuk58> i think $ will write that file with the funcion
08:45:34 <ryuk58> function*
08:45:41 <ciaranm> ryuk58: that's not what $ means
08:45:49 <Silvah> :t ($)
08:45:50 <lambdabot> forall a b. (a -> b) -> a -> b
08:45:50 <ciaranm> ryuk58: try doing it without using $ first
08:46:36 <Jeanne-Kamikaze> from a performance / pattern matching thing perspective, is there a difference between having two data types and one type with two constructors ?
08:46:41 <mike-burns> gavri: That's going to be in the GHC internals, but in the Haskell Prelude it's    m >> k  =  m >>= \_ -> k    http://www.haskell.org/onlinereport/standard-prelude.html
08:47:34 <Jeanne-Kamikaze> oh, nvm
08:48:10 <ryuk58> with $ doesnt work at all
08:48:15 <mike-burns> :t ($)
08:48:16 <lambdabot> forall a b. (a -> b) -> a -> b
08:48:17 <ryuk58> without*
08:48:37 <ciaranm> ryuk58: $ is just confusing you. work out how to do it without $.
09:51:50 <rewq123> I've been using a simple recursive function to model a state-machine (the next state is passed as an argument in recursive function call), but I'm not satisfied with readability. Are there any alternatives?
09:53:17 <WarzoneCommand> hmm question
09:53:22 <ddarius> rewq123: There are a lot of alternatives.
09:53:53 <ddarius> rewq123: What exactly do you find deficient in your current approach?
09:54:40 <WarzoneCommand> I need a balanced binary search tree that I can specify a function that determines whether or not one should go left or right in the searchtree (when you do a lookup/insert/whatever).
09:54:50 <WarzoneCommand> is there something particularly suited for that on hackage?
09:54:56 <exFalso> good evening
09:54:57 <exFalso> does anyone know how to parserFail in parsec so that it backtraces one token instead of failing the whole parse?
09:55:20 <hpc> WarzoneCommand: sounds like Set
09:55:26 <ddarius> exFalso: You can't do that locally.
09:55:46 <byorgey> exFalso: if you want a particular parse to backtrack when it fails you can surround it with 'try'.
09:55:47 <exFalso> http://scienceblogs.com/goodmath/2009/11/advanced_haskell_data_structur.php
09:55:50 <WarzoneCommand> hpc: set, such as in a mathematical set?
09:55:55 <byorgey> exFalso: otherwise parsec does not backtrack at all.
09:56:08 <exFalso> byorgey: just one token
09:56:10 <hpc> @hoogle Set
09:56:10 <lambdabot> Data.Bits setBit :: Bits a => a -> Int -> a
09:56:10 <lambdabot> Control.OldException setUncaughtExceptionHandler :: (Exception -> IO ()) -> IO ()
09:56:10 <lambdabot> Data.Set module Data.Set
09:56:24 <exFalso> byorgey: isnt parsec LL1?
09:56:47 <byorgey> exFalso: I don't know.
09:56:50 <hpc> WarzoneCommand: internally, i believe it's a sorted binary tree; it uses the Ord instance of the data you store inside to determine how it is ordered
09:56:51 <irene-knapp> yes, it is, heh
09:56:53 <irene-knapp> LL1
09:57:02 <exFalso> byorgey: i know it can backtrace one with tokenPrim but i need to capture that in a fail
09:57:12 <rewq123> ddarius: my state-machine's only input is an initial state, it produces new states until it reaches an 'end' state
09:57:15 <ddarius> exFalso: Prasec is not LL1.
09:57:25 <rewq123> ddarius: somehow I would like to express this in the type system
09:57:31 <exFalso> it is really neat if you use patten match failures to backtrack in monad comprehensions
09:58:05 <WarzoneCommand> hmm yes
09:58:24 <exFalso> (that link above is about red black trees)
09:58:28 <hpc> rewq123: State?
09:58:30 <hpc> @hoogle State
09:58:30 <lambdabot> Control.Monad.State module Control.Monad.State
09:58:31 <lambdabot> Control.Monad.Trans.State module Control.Monad.Trans.State
09:58:31 <lambdabot> Graphics.UI.GLUT.State module Graphics.UI.GLUT.State
09:58:43 <WarzoneCommand> I was hoping that I could avoid having to rewrap some existing data structure again
09:58:52 <WarzoneCommand> exFalso: I know, I was allready looking into RB-trees
09:58:52 <exFalso> ddaruis: you mean because of try?
09:58:55 <ddarius> Parsec is LL(1) except when you don't want it to be then it's LL(infinity) except when you use the fact that it's a monad then its context sensitive except when you use the fact that it is embedded in Haskell in which case it is Turing complete.
09:59:18 <exFalso> haha true
09:59:22 <WarzoneCommand> but for some weird reason everyone that has ever implemented one doesn't think it is good/usefull enough to actually put it up on hackage and maintain the thing
09:59:37 <hpc> ddarius: lol
09:59:57 <hpc> ddarius: what's the difference between context-sensitive and turing-complete?
10:01:49 <ddarius> hpc: See Type-1 grammars here: http://en.wikipedia.org/wiki/Chomsky_hierarchy
10:02:48 <hpc> ddarius: cool; sounds like the turing-machine version of agda
10:03:14 <djahandarie> The difference is that context-sensitive is a type of language and turing machine is a type of automaton ;p
10:03:49 <djahandarie> lol, totally misread turing-complete as turing machine
10:03:53 * djahandarie walks out slowly
10:03:58 <hpc> djahandarie: that's like the difference between "laptop" and "notebook"
10:03:58 <hpc> :P
10:15:12 <Mathnerd314> yay, getting kickbanned from every channel on the planet.
10:15:21 <Mathnerd314> #haskell is next
10:15:36 <Mathnerd314> dajksafhk.fcmfihlasfjmkhsdfk.mrvjtioc7789f789477848957479053788eruuuiillllioeululjfkljklsfjkl;sfjdljksl;jsfl;sfj;sflsjflsf;kjlsdjsdl;jksdf;kjdk;lskjl;kdjdjdkl;jdl;djskljkljkl;djkdjdljkl
10:15:43 <Mathnerd314> fdskldsfjkldjdfklzm,vnm.v,mnzv,.mnv.fm,nzvm,vfnzv,vfnzf.zvfnfvm,kfvnvfvm,klfvnnnn.vklvnkv.kzfvk
10:15:46 <Mathnerd314> dfszdkkkkkkjz;kllk;kljkl;zf
10:15:49 <Mathnerd314> df;dlzfl;zfjzffzj;ldkjd;ljd;kjffff;
10:15:50 --- mode: ChanServ set +o Saizan
10:15:50 <irene-knapp> very funny
10:15:52 <Mathnerd314> dz;dkjdl;jkl;djl;zdjdzl;kjl;dj
10:15:54 <Mathnerd314> d;kzl;klj
10:15:58 <Mathnerd314> kickban me please!
10:15:59 --- mode: Saizan set +b *!*mathnerd3@*.6.28.53.206.cos.dyn.pcisys.net
10:15:59 --- kick: Mathnerd314 was kicked by Saizan (get sober)
10:16:02 <irene-knapp> lol
10:16:13 <mike-burns> We all have different ways to use our winter vacation.
10:16:16 <irene-knapp> yep
10:16:22 --- mode: Saizan set -o Saizan
10:17:03 <Nafai> If you are going to annoy on the Internet, at least skillfully troll.
10:17:05 <Nafai> Geez.
10:22:35 <tech2> he's got a while to go I guess, not jaded enough yet.
10:46:10 <BMeph> "Please, if you're going to Troll on the 'Net, Troll responsibly." ;þ
10:51:07 <carpi> could someone please tell me why "fib = 1:2:[(head fib) + (head (tail fib))]" is not working?
10:51:12 <desdur> The following works fine (resulting in Just 4): ghci> (+) <$> Just 2 <*> Just 2
10:51:50 <desdur> But similar construct with string doesnt work: ghci> (++) <$> Just "aaa" <*> Just "bbb"
10:52:02 <carpi> i also tried  fib = 1:2:[foldr (+) (head fib) (tail fib)] .. not working :(
10:52:48 <ddarius> Woo, Inkscape's support for tablets got better or I just never found the option I found now.
10:52:49 <ciaranm> carpi: your [] contains a single element
10:53:11 <carpi> ciaranm: but what the version with the fold?
10:53:30 <Saizan> > (++) <$> Just "aaa" <*> Just "bbb"
10:53:31 <lambdabot>   Just "aaabbb"
10:54:05 <ciaranm> carpi: foldr gives you a single element
10:54:20 <ciaranm> > let fib = 1:1:zipWith (+) fib (tail fib) in take 10 fib
10:54:21 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
10:54:24 <ciaranm> is probably what you want
10:54:29 <desdur> lamdabot: I'm getting No instance for (Data.String.IsString [a0])
10:54:45 <carpi> yup..thanks you
10:55:57 <c0r> Hello there
10:56:08 <irene-knapp> @hoogle [a] -> Int -> Maybe a
10:56:08 <lambdabot> Prelude (!!) :: [a] -> Int -> a
10:56:08 <lambdabot> Data.List (!!) :: [a] -> Int -> a
10:56:08 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
10:58:15 <desdur> So here is my snippet that doesn't work for me: http://hpaste.org/55737
10:59:16 <monochrom> > (++) <$> Just "aaa" <*> Just "bbb"
10:59:17 <lambdabot>   Just "aaabbb"
10:59:58 <desdur> ok, but it doesn't work for me.. what modules should I import besides Control.Applicative?
10:59:58 <monochrom> turn off OverloadedStrings
11:00:38 <desdur> 1)how (in ghci)? 2)is it on by default?
11:00:52 <monochrom> it is off by default. I don't know why you have it.
11:01:23 <monochrom> you are not lacking things. you are having extraneous things.
11:03:55 <desdur> monochrom: ok, I was in a directory with a cabal package that used OverloadedStrings, thanks!
11:04:03 <desdur> monochrom++
11:04:45 <mike-burns> Given how many people have been looking for a   [a] -> Int -> Maybe a   recently, I'm shocked it's not hidden in some package.
11:05:07 <desdur> @karma monochrom++
11:05:08 <lambdabot> monochrom++ has a karma of 0
11:05:18 <desdur> @karma+ monochrom
11:05:18 <lambdabot> monochrom's karma raised to 6.
11:05:25 <desdur> :)
11:05:27 <rostayob> oh god we have karma?
11:05:56 <desdur> http://www.haskell.org/haskellwiki/Lambdabot
11:06:32 <Lemmih> rostayob: Yeah but the exchange rate vs. Reddit karma is horrible.
11:06:53 <carpi> running "fib = 1:2:(zipWith (+) fib (tail fib))" stalled my computer. RAM usage spiked and I coudln't move the curosr for a bit. Only after 5 minutes did i get control back.. what about that statement makes my computer crawl?
11:06:54 <monochrom> reddit karma can't buy me love
11:07:10 <carpi> im afradi to run that statement again :(
11:07:20 <hpc> carpi: it didn't output anything?
11:07:27 <irene-knapp> um, the fact that it's asking for the end of a recursive list, isn't it?
11:07:34 <irene-knapp> er, infinite
11:07:41 <carpi> hpc: it output some numbers and then stopped
11:07:43 <monochrom> Prelude> fib = 1:2:(zipWith (+) fib (tail fib))
11:07:43 <monochrom> <interactive>:1:5: parse error on input `='
11:07:44 <rostayob> carpi: that statement doesn't terminate if you demand the entire list. it should print a never ending list
11:08:00 <monochrom> is what I get. no crawling.
11:08:27 <carpi> hpc: actually that was the definition. that acutall statement is "fibtermslessthan4million = filter (<4000000) fib"
11:08:29 <irene-knapp> > let fib = 1:1:(zipWith (+) fib (tail fib)) in take 20 fib
11:08:30 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
11:08:41 <rostayob> carpi: that should terminate
11:08:46 <irene-knapp> > let fib = 1:1:(zipWith (+) fib (tail fib)) in length $ filter (<4000000) fib
11:08:49 <hpc> rostayob: no it shouldn't
11:08:50 <lambdabot>   mueval-core: Time limit exceeded
11:08:53 <irene-knapp> > let fib = 1:1:(zipWith (+) fib (tail fib)) in length $ filter (<400000) fib
11:08:57 <lambdabot>   mueval-core: Time limit exceeded
11:09:00 <irene-knapp> > let fib = 1:1:(zipWith (+) fib (tail fib)) in length $ filter (<40000) fib
11:09:03 <rostayob> hpc: why not?
11:09:04 <lambdabot>   mueval-core: Time limit exceeded
11:09:06 <hpc> carpi: it prints a bunch of numbers, but the result of filter doesn't terminate until the input terminates
11:09:07 <irene-knapp> > let fib = 1:1:(zipWith (+) fib (tail fib)) in length $ filter (<4000) fib
11:09:11 <lambdabot>   mueval-core: Time limit exceeded
11:09:11 <hpc> carpi: you should use takeWhile
11:09:13 <irene-knapp> > let fib = 1:1:(zipWith (+) fib (tail fib)) in length $ filter (<400) fib
11:09:14 <rostayob> hpc: oh, right
11:09:16 <irene-knapp> oh right
11:09:17 <lambdabot>   mueval-core: Time limit exceeded
11:09:27 <irene-knapp> > let fib = 1:1:(zipWith (+) fib (tail fib)) in length $ takeWhile (<4000000) fib
11:09:27 <lambdabot>   33
11:09:30 <irene-knapp> there we go, hehe
11:09:33 <irene-knapp> > let fib = 1:1:(zipWith (+) fib (tail fib)) in takeWhile (<4000000) fib
11:09:34 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
11:09:36 <irene-knapp> neat
11:09:40 <irene-knapp> they get big fast, don't they
11:09:46 <irene-knapp> > let fib = 1:1:(zipWith (+) fib (tail fib)) in drop 10 $ takeWhile (<4000000) fib
11:09:47 <lambdabot>   [89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,1...
11:09:48 <mike-burns> Heh.
11:09:51 <irene-knapp> > let fib = 1:1:(zipWith (+) fib (tail fib)) in drop 20 $ takeWhile (<4000000) fib
11:09:52 <lambdabot>   [10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2...
11:09:56 <irene-knapp> > let fib = 1:1:(zipWith (+) fib (tail fib)) in drop 30 $ takeWhile (<4000000) fib
11:09:57 <lambdabot>   [1346269,2178309,3524578]
11:10:00 <irene-knapp> yeah, heh
11:10:02 <hpc> irene-knapp: it's asymptotically exponential
11:10:16 <irene-knapp> is it?  I thought it was its own thing, not exactly exponential?
11:10:33 <exFalso> fib starts with 0:1 hey
11:10:43 <carpi> ah.. so when we use filter.. the function doesn't care that the element greater than 4 million is past.. it keep checking for other elemtns in the infinite list for numbers less than 4 million even though there aren't any
11:10:59 <carpi> s/greater/lesser
11:11:08 <carpi> and takeWhile stops
11:11:13 <mike-burns> Right.
11:11:15 <monochrom> you define fib as a top-level thing at the prompt. the infinite list is not being forgotten as you go. it keeps a lot of memory as hostage. then your computer thrash.
11:11:23 <hpc> irene-knapp: https://upload.wikimedia.org/wikipedia/en/math/0/d/2/0d28afc97e00939a78d4f7d95a4fc46d.png
11:11:38 <hpc> irene-knapp: the limit of the ratio of consecutive fibs approaches φ
11:11:46 <irene-knapp> hmmmm okay!
11:11:51 <irene-knapp> yes, I knew that :)
11:12:33 <hpc> so it approaches F(x) = φ**x
11:12:39 <irene-knapp> hmm
11:12:44 <irene-knapp> okay, I guess
11:13:39 <hpc> well, kφ**x
11:13:44 <hpc> for some k
11:13:48 <exFalso> if you're using xmonad's Spiral layout holding down shift-windows-enter will tak you to φ ratio windows
11:14:29 <rostayob> the golden ratio really is everywhere!
11:14:53 <rostayob> seashells, xmonad
11:15:01 <exFalso> haha
11:15:06 <hpc> lambdabot oneliners
11:15:41 <monochrom> the fibonacci sequence is everywhere in nature, for example haskell tutorials and python tutorials
11:15:57 <irene-knapp> ahahahaha
11:15:58 <hpc> @remember monochrom the fibonacci sequence is everywhere in nature, for example haskell tutorials and python tutorials
11:15:59 <lambdabot> Nice!
11:16:00 <rostayob> and very inefficient javascript functions too
11:16:02 <irene-knapp> nicely said
11:16:04 <wavewave> hi.
11:16:10 <exFalso> hai
11:18:08 <wavewave> just read about semantic editor combinators
11:18:15 <wavewave> conal's blog article
11:18:46 <wavewave> nice interpretation of point-free style code.
11:20:08 <dskippy> Can someone explain to me why this is an illegal type? "type BinOp = Integral a => Ratio a -> Ratio a -> Ratio a"
11:20:17 <mike-burns> Hi dskippy .
11:20:24 <dskippy> Woa
11:20:27 <dskippy> Hey
11:20:32 <rostayob> dskippy: you can't include constraints in type synonyms.
11:20:35 <dskippy> How have you been?
11:20:50 <rostayob> also, the 'a' there is unbound
11:20:52 <hpc> dskippy: the type is legal, but the type alias is a higher-rank type
11:20:54 <mike-burns> I've been great. And I'll PM you.
11:20:55 <rostayob> (the type variable)
11:21:05 <dskippy> Will RankNTypes work?
11:21:21 <krakrjak> so better would be BinOp :: Integral a => Ratio a -> a -> a??
11:21:23 <tigger_> I'm curious about the type system in haskell, besides the fact that functions have type constructor (->), how is the type system better than that of languages like C++ or C#, which also verify that all functions receive the appropriate type and return the correct type (assuming we don't do type casts)? I often feel that's really the most important part of the type system
11:21:31 <hpc> also what rostayob said
11:21:32 <rostayob> dskippy: possibly...
11:21:38 <rostayob> but i don't think so
11:22:24 <tech2> tigger_: because you can easily work around the type system in C etc., unions, typecasting etc.
11:22:28 <dskippy> Hm. The type makes sense to me. It might make sense to the compiler if I ask it to use RankNTypes. It mentions that in the error message.
11:22:30 <rostayob> dskippy: actually, they do work
11:22:33 <wavewave> tigger_ : hmm rather difficult to parse your question.
11:22:44 <monochrom> C++ and C# do not have sum types. that is, the like of "data X = X0 Int | X1 Bool"
11:22:48 <exFalso> tigger_: thats a HUGE question
11:22:49 <rostayob> dskippy: e.g. type Foo = forall a. Show a => a ->  a works here.
11:23:12 <exFalso> monochrom: they have unions its just that they are not disjoint
11:23:44 <monochrom> well yeah, its union types are also unchecked.
11:23:47 <rostayob> (with Rank2Types)
11:23:58 <exFalso> tigger_: for one the type system is CLOSED under -> that is you can return functions jsut as easily as return a base type
11:24:01 <rostayob> also, you have to initialize them with their first value. C unions suck.
11:24:28 <rostayob> well i guess C would suck more without them but they're still pretty raw, but that's C
11:24:28 <tigger_> exFalso: hmmm Okay, yeah I was just looking for a laymans reason, why one might prefer a type system like haskell provides as opposed to C/C++, assuming you don't do casts.
11:24:33 <wavewave> thae result type checking and inference is  a key  idea
11:25:16 <wavewave> tigger_: which part of type system do you want to compare?
11:25:40 <wavewave> so many things are so much different. .
11:25:46 <exFalso> tigger_: the haskell type system is very powerful, they often say that once your haskell program typechecks your program is correct. this is not a true statement, but close
11:26:23 <rostayob> tigger_: Haskell type system is way more powerful than C/C++ one. the most striking difference, in my opinion, is polymorphism
11:26:28 <rostayob> (polymorphism, not inheritance)
11:26:36 <tigger_> I'm not really sure what the type system is actually. Is it just checking function signatures and variables inside closures to make sure they all match up or more than that. I'm coming from the perspective that the type system helps to ensure correctness of a program, but so do C++ in the regard that they also check function types and variables
11:26:39 <rostayob> and actual type safety
11:26:47 <wavewave> since you understand result type checking in c/c++,  actually not allowing typecast is a key idea.
11:27:08 <tigger_> rostayob: actual type saftey? as in prohibitng casts?
11:27:16 <rostayob> tigger_: the key idea of type systems like the ones in haskell is that a program "can't go wrong"
11:27:30 <rostayob> you'll never get a null pointer exception, or a casting exception
11:27:59 <rostayob> you might have partial functions, but you can't have type-related run time errors, ever
11:28:21 <tigger_> wavewave: but you technically can still do in haskell, in unsafe or something, no? It's jsut bad practice, as is the case in c, where typecasts are usually used to give polymorphism, at least when I use them.
11:28:26 <rostayob> so that doesn't eliminate all run time errors, but it really cuts the number down
11:28:43 <rostayob> tigger_: no, you can't do type-unsafe stuff in Haskell 98
11:28:44 <monochrom> C++ has typecase, that is, you can do the equivalent of f :: a -> a, f x = if x's type is Int then x+1 else x
11:28:50 <exFalso> tigger_: nope, you cant do
11:29:10 <rostayob> tigger_: there are some compiler-specific facilities to do unsafe stuff, but that's not haskell
11:29:11 <tigger_> oh okay, nvm then, sorry, i thought there was something in unsafeio
11:29:23 <rostayob> tigger_: yeah, that's something provided mostly to call foreign code
11:29:27 <rostayob> but it's not haskell 98
11:29:28 <exFalso> WE DONT TALK ABOUT UNSAFEIO
11:29:32 <tech2> heh
11:29:37 <exFalso> also that has nothing to do with types
11:29:42 <rostayob> exFalso: It does
11:29:51 <rostayob> you can break type safety with unsafePerformIO
11:30:03 <davean> you can write coerce
11:30:11 <exFalso> rostayob: how?
11:30:13 <davean> (using it as a primative)
11:30:23 <rostayob> modifying a polymorphic reference for example
11:30:26 <exFalso> unsafePerformIO is well typed
11:30:49 <wavewave> tigger_ : let me say like this. In haskell, without unsafe thing, you can do everything.
11:30:52 <monochrom> Haskell does not have typecase for a->a (it has typecase if you use type class, but then the type sig is no longer a->a). so when you look at a->a you already know that it must be id or it must die. this is why exFalso says once your haskell program typechecks your program is correct. to a very large extent. thus, once f typechecks, it is id or it dies.
11:30:59 <tigger_> okay, thanks everyone, just seems like casting can be avoided in other languages as well, but maybe that's the point
11:31:44 <wavewave> tigger_ : this is not a simple achievment.. actually it's very profound achievement.
11:31:48 <exFalso> rostayob: can you point me to some code?
11:31:53 <monochrom> a more useful example is g :: (a,b)->a. it must be fst or it dies. you don't have that guarantee in C++. but some people enjoy the typecase
11:32:01 <rostayob> exFalso: I'll construct something wait
11:32:05 <davean> exFalso, it is in the wiki
11:32:27 <rostayob> exFalso: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Unsafe.html
11:32:34 <wavewave> tigger_ : haskell is a kind of strictly following mathematics of type theory.
11:32:38 <tigger_> wavewave: yes, I would definitly appreciate it more if I studied how hard it actually is to do correctly
11:32:58 <tigger_> wavewave: more than i already do that is
11:33:13 <wavewave> tigger_ : although it still has some quirks.. definitely most consistent among mainstream languages.
11:33:26 <wavewave> if you count haskell as mainstream language.
11:33:28 <rostayob> exFalso: btw, this is why in well typed but not pure languages (like SML) they go to great lengths to ensure that that kind of thing doesn't happen. in SML you can't have polymorphism outside abstractions
11:34:07 <rostayob> (you can't have something 'foo :: a', but you can have 'foo :: () -> a')
11:34:17 <tigger_> monochrom: the id example is a good one
11:34:23 <exFalso> aahh because you dont bind the type when you execute... nice
11:34:30 <wavewave> tigger_ : besides the consistency... another interesting part of haskell type system is higher order type.
11:34:52 <wavewave> that's all possible only on top of consistency btw
11:34:56 <rostayob> exFalso: yep yep
11:35:16 <wavewave> tigger_ : as you took an example of (->) , that's higher order type
11:35:19 <tigger_> wavewave: you mean like :k * -> *
11:35:25 <wavewave> another big example is monad.
11:35:25 <tigger_> wavewave: monads or something
11:35:29 <wavewave> yes..
11:35:33 <rostayob> exFalso: this is how SML solves the problem http://users.cis.fiu.edu/~smithg/cop4555/valrestr.html
11:35:42 <rostayob> "solves"
11:35:46 <rostayob> it's pretty annoying
11:36:05 <wavewave> higher order type also makes currying more consistent too
11:36:10 <monochrom> it is an instance when monomorphism restriction is not confusing :)
11:37:07 <tigger_> okay thanks all!
11:37:09 <wavewave> tigger_ : c++ counterpart of haskell higher order type may be template
11:37:22 <wavewave> but it's not consistent at all in my opinion
11:37:39 <c_wraith> equality type variables.  Ick.
11:37:49 <c_wraith> Type classes are way better for that problem
11:38:06 <wavewave> of course.. another big thing is typeclasses ;-)
11:38:12 <rostayob> templates are crap. really. java generics are a bit better but templates...
11:38:19 <wavewave> and all fancy types.
11:38:37 <rostayob> relevant: http://weegen.home.xs4all.nl/eelis/analogliterals.xhtml
11:38:39 <wavewave> multi parameter type classes, type family, functional dep ..
11:38:46 <rostayob> wavewave: that's not haskell
11:38:47 <wavewave> existential types
11:38:59 <tigger_> yeah i was thinking about that, a friend was comparing python with haskell, and I guess you do get typeclasses in python with duck typing, but theres no real way to guarantee that the interface is actually followed
11:39:01 <wavewave> rostayob: yeah. haskell'''
11:39:20 <wavewave> or ghc haskell
11:39:28 <wavewave> or de facto standard haskell
11:39:33 <tigger_> unless you had typed python? but im guess thats still waek somehow
11:39:58 <wavewave> duck type is different..
11:39:58 <rostayob> tigger_: with python you can write generic code in the sense that you call some methods hoping that that objects has methods/attributes named that way.
11:39:58 <exFalso> python is not even a programming language
11:40:03 <rostayob> but that's very different
11:40:09 <tigger_> exFalso: lol, heyheyhey cmon now
11:40:14 <wavewave> I would not think duck type similar to typeclass
11:40:39 <tigger_> wavewave: hm okay, well maybe in the most naive sense, since all objects have that method
11:40:41 <rostayob> i'd say that writing python code in python is bad practice
11:41:04 <rostayob> with type classes everything is much clearer (and safer of course)
11:41:05 <exFalso> dynamic typing downgrades a programming language to scripting language, duck typing donwgrades it into...
11:41:12 <tigger_> wavewave: please ignore my ignorance haha
11:41:15 <wavewave> tigger_ : anyway, you had better not compare haskell with other OOP concept directly
11:41:39 <wavewave> tigger_ : no problem ;-) I am also still learning.
11:41:49 <rostayob> tigger_: anyway, try LYAH
11:41:51 <rostayob> @where LYAH
11:41:51 <lambdabot> http://www.learnyouahaskell.com/
11:42:24 <tigger_> oh yeah LYAH is great! I really like RealWorldHaskell as well
11:42:37 <tigger_> frequently go back to both! thx
11:42:53 <wavewave> tigger_ : great! welcom to haskell world!
11:47:08 <tigger_> wavewave: I think if you're a programmer who makes a lot of mistakes or is a noob, like myself, haskell might be the best choice of language to learn, since it stops all those dumb mistakes from slowing you down. Whereas if you're a real boss programmer you could just do it in assembly and it'd be beautiful interfaces and everything! lol
11:47:41 <djahandarie> Said Real Boss Programmer does not exist.
11:47:47 <tigger_> haha exactly!
11:48:14 <tech2> Mel, the last real programmer, he'd hate all you quiche-eaters ;)
11:48:23 <wavewave> tigger_ : I am actually looking at the problem differently
11:48:38 <cmccann> cf. http://www.cs.utah.edu/~elb/folklore/mel.html
11:48:59 <wavewave> if you are a real boss programmer, then you will make haskell-like language in assembly finally.
11:49:02 <tech2> thanks cmccann, I couldn't be bothered hunting
11:49:54 <tech2> wavewave: or forth, then things get really surreal.
11:50:02 <tigger_> cmccann: so real boss programmer does exist! hahaha
11:50:03 <wavewave> it seems that the final destination of really good architecture in software approaches towards some consistent language
11:50:37 <wavewave> consistency is not confined to any language. it's mathematics after all.
11:52:21 <wavewave> for example, I predict that currying which is very typical in haskell will be everywhere soon in any language in 10 years.
11:52:37 <wavewave> list comprehension is already everywhere.
11:52:51 <wavewave> that will have monadic context in every language too
11:53:25 <wavewave> type inference is already in c++
11:54:08 <wavewave> c++ community will revolutionize their template system more like haskell higher order type soon.
11:54:36 <wavewave> haskell will look like more agda-like, too. but not sure yet
11:54:58 <mike-burns> And we'll program with our minds, man.
11:55:17 <tigger_> wavewave: interesting, yeah that makes sense. but things like list comprehension almost seem like false translations? in haskell lists are additive monads. But, I don't know enough to say for sure, but in python I'm guessing they are just directly interpretted as loops and nested ifs. the compiler will lead to the same result but from fundamentally different places imo.
11:55:42 <wavewave> list is monad.
11:56:07 <wavewave> first, list comprehension in python is directly from haskell
11:56:07 <cmccann> if you want a better example, the LINQ stuff in .NET is directly based on the list monad
11:56:25 <wavewave> but probably list comprehension is not first in haskell, I heard so..
11:57:22 <wavewave> by the way, monad does not mean anything specific in implementation.
11:57:53 <tigger_> wavewave: let me rephrase. in haskell list comprensions are directly a result of the bind operation defined for them, and guards, so a very general pattern, since monads are general. However in python, which takes from haskell, afaik, I could be wrong, they don't need the whole monadic basis for lists, they simply use nested loops and ifs, and sidestep the monad part, but I really might be wrong about that?
11:57:59 <wavewave> tigger_ : whether it uses loop or recursion in its implementation is not a matter of monad.
11:58:26 <wavewave> tigger_ : ah.. yeah.. definitely, python didn't take the concept of monad at all.
11:58:36 <wavewave> only list comprehension for convenience.
11:58:41 <tigger_> wavewave: so list comprehensions in python are sorta cheap translations in some sense, which is what I was trying to get at
11:58:55 <wavewave> so I *predict* that it will accept monad soon. ;-P
11:59:28 <wavewave> tigger_ : i got your point. ;-)
12:00:16 <conal> Sgeo: the two are very different paradigms. FRP is about precise semantics and continuous time, while enumerators/iteratees is an implementation technique.
12:01:02 <conal> Sgeo: although "FRP" is sometimes used differently to mean various implementation techniques.
12:01:03 <alistra> hi
12:05:30 <wavewave> haskell type system is a big achievement. I think if haskell succeeded earlier, we could not get this now.
12:05:45 <cmccann> conal, iteratees have a fair amount in common with a few extant FRP implementations, that's probably the source of the confusion
12:06:14 <wavewave> actually I do GUI programming using iteratee
12:06:37 <wavewave> more exactly, using coroutine.
12:07:05 <carpi> what does it mean when ghci says "No instance for (Floating Integer)"? Does it mean that the type Integer is not an instance of the type class Floating?
12:07:09 <conal> cmccann: and folks with a mainly operational outlook may then miss the fundamental semantic differences.
12:07:37 <monochrom> it means you wrote like sqrt x but x is Integer but sqrt doesn't want an Integer
12:07:41 <hpc> carpi: exactly
12:07:51 <hpc> carpi: you are using (/) i take it?
12:08:14 <hpc> carpi: if you want integral division, use div; if you want floating division, use fromInteger on both arguments
12:08:14 <wavewave> sqrt (fromIntegral  x)
12:08:14 <carpi> hpc: sqrt
12:08:18 <hpc> ah, or that
12:08:25 <wavewave> :t sqrt . fromIntegral
12:08:26 <lambdabot> forall a a1. (Floating a, Integral a1) => a1 -> a
12:08:28 <hpc> use fromInteger
12:08:31 <hpc> @src fromIntegral
12:08:31 <lambdabot> fromIntegral = fromInteger . toInteger
12:08:32 <monochrom> next time I will have to guess sin
12:08:58 <cmccann> conal, well, in the end comparing FRP to iteratees is a conceptual type error. comparing FRP to the overall concept of incremental IO that iteratees attempt to solve would at least be well-defined
12:09:10 <cmccann> or comparing iteratees to a specific FRP implementation
12:09:27 <carpi> both of them not working :(
12:11:38 <conal> cmccann: i tried to stir up a discussion of what iteratees _mean_ in august 2010 but didn't find iteratee folks interested. and without a meaning, the implementation issues don't interest me. if interest sparks up, i'd love to hear about it.
12:11:48 <wavewave> I feel like iteratee is still stateful monadic operation and FRP is to promote all operations to pure function as a funciton of time (or equivalent thing), am I right?
12:12:03 <cmccann> conal, I think I participated in that discussion, actually
12:13:27 <conal> wavewave: for me, FRP is mainly about (a) denotative and (b) continuous time. and iteratee is neither.
12:14:04 <conal> wavewave: as i understand and use the term, "monadic" is just about packaging, not semantics.
12:14:05 <wavewave> conal: that's right.. iteratee is not.
12:14:52 <cmccann> conal, I think I mostly argued that iteratees have about as much meaning as a left fold, i.e. there's abstract structure that preserves invariants but no higher-level semantics intrinsic to the concept
12:15:05 <cmccann> not just an implementation, but a tool for implementating other things
12:15:21 <wavewave> conal : I understood iteratee as coroutine which is resumable continuation with suspension functor
12:15:48 <conal> cmccann: the iteratee uses i've seen mainly depend on non-denotative types like IO, which is a semantic non-starter.
12:16:27 <alistra> how to make haddock display coverage
12:16:29 <conal> wavewave: that's the kind of idea that people could explore to see whether it turns out to make sense and be useful.
12:16:48 <cmccann> conal, yes, but that's orthogonal to iteratees, at most they require some monad
12:18:03 <conal> cmccann: so does the identity functor/monad transformer. what interests me is whether they have useful semantics in themselves and whether they free us from imperative problem-solving.
12:18:08 <wavewave> For me, Mario Blazevic's article in last monad reader was very helpful.
12:18:35 <cmccann> wavewave has the right idea, it's just some sort of fold or other recursive function, turned inside out a couple times so that the fold can be suspended and resumed, continuation style
12:18:48 <conal> wavewave: i.e., whether that description can be made precise, tractably simple, and useful.
12:20:24 <wavewave> anyway, coroutine is very useful practical intermediate step towards true denotational idea for me.
12:21:16 <conal> wavewave: maybe. i don't know how we could find out whether actually it's an intermediate step before seeing where it goes next.
12:21:23 <cmccann> conal, if memory serves me you can derive something equivalent to iteratees as a free (co)monad of something with a bit of scaffolding around it
12:21:23 <wavewave> I personally use coroutine on top of gtk2hs and so make push-style event process to pull-style event processing
12:21:53 <wavewave> conal: actually I got that idea from your blog ;-) thanks for nice posts
12:21:59 <roconnor> wavewave: I am inturigued and would like to subscribe to your library.
12:22:34 <carpi> the type signature somettimes mention "(Num a) => a -> a" and sometimes simply say "Num a => a -> a". Is there a difference?
12:22:36 <wavewave> roconnor: not very good as a library at all.. anyway it's in my hxournal program.
12:22:38 <conal> cmccann: "free" is never very compelling to me, since as i understand it. i'm looking for semantics, not syntax.
12:22:51 <mauke> carpi: no
12:22:53 <conal> wavewave: :)
12:23:07 <carpi> thnks )
12:23:24 <cmccann> conal, how is "free" is a matter of syntax?
12:23:30 <wavewave> Business logic of GUI programming is inverted. so use of coroutine makes the logic more human friendly.
12:23:55 <wavewave> but still the best will be denotational semantics..
12:24:14 <wavewave> for my purpose, I couldn't find mature GUI library of FRP yet.
12:26:03 <conal> wavewave: even if you don't find a library to your liking, you can still improve your own understanding by taking a denotational perspective in your own thinking. by asking "what is a GUI?" and requiring mathy precision in your answer (no operational mechanisms or hand-waving).
12:26:06 <hpaste> Carpi pasted “type error” at http://hpaste.org/55738
12:26:07 <carpi> can someone please tell me how i might fix it? ^^^^
12:26:32 <mauke> carpi: add type signatures
12:26:48 <wavewave> conal: definitely. that's what I am thinking of every day these days. ;-)
12:27:10 <conal> wavewave: nice :)
12:28:28 <wavewave> so many new things to learn and think of..
12:28:44 <hpaste> Carpi pasted “type error” at http://hpaste.org/55739
12:28:46 <carpi> thanks for mentioning it. Now i added them : ) ^^
12:28:53 <ClaudiusMaximus> some results of my holiday haskell hacking..  http://claudiusmaximus.goto10.org/cm/2011-12-26_poincare_half-plane_metric_for_zoom_animation.html
12:29:59 <mauke> carpi: wrong error message
12:31:38 <cmccann> conal, to help me better understand what you're looking for, how would you describe the semantics of something like foldl?
12:32:03 <carpi> oh shite .spegetti sauce.. i suck. moment please
12:32:14 <hpaste> Carpi pasted “type error” at http://hpaste.org/55740
12:32:26 <carpi> i thought the error message wouldn't change
12:32:53 <mauke> carpi: and now the answers you got before apply
12:33:21 <carpi> before apply?
12:33:23 <mauke> <monochrom> it means you wrote like sqrt x but x is Integer but sqrt doesn't want an Integer
12:33:38 <mauke> and now: the answers (that you got before) apply
12:33:52 <conal> cmccann: lists & list folds already have clear semantics. i'm talking about the bigger picture of how iteratees get used. i've not seen a useful abstraction there--one that's distinguishable from implementation.
12:34:13 <carpi> yes .. but i tried fromIntegral and fromInteger.. still doesn't work
12:34:34 <mauke> "doesn't work" is meaningless
12:34:41 <mauke> what did you do? what happened?
12:34:48 <cmccann> conal, how they get used is a very different question from iteratees as a concept underlying the various implementations
12:35:35 <carpi> I tried changing the 9th line to sqrtn = sqrt (fromIntegral n)
12:35:49 <mauke> what happened?
12:35:54 <doserj> carpi: you also need to fix the lessThanSqrtN line
12:36:30 <carpi> and i get the same error message only diference being the phrase "sqrt n" is replaced by "sqrt (fromIntegral n)"
12:36:36 <conal> cmccann: i wonder: is the denotative part of the iteratee notion nontrivial enough to allow us to solve interesting problems denotatively, or does one still have to drag in non-denotative tools like IO?
12:37:20 <conal> cmccann: or is iteratee mainly another implementation technique for imperative programming?
12:37:25 <mauke> carpi: add type signatures to sqrtn and lessThenSqrtN
12:37:30 <carpi> yup i think i need to prepend the 9th line with truncate
12:37:49 <carpi> typee signature in the middle of a function? how?
12:38:10 <mauke> it's not in the middle of a function
12:38:11 <cmccann> conal, it's an abstraction for incremental recursion, that's not inherently imperative
12:38:49 <carpi> mauke: you mean like using the '::' syntax?
12:38:50 <cmccann> conal, in many ways the underlying concept isn't too far from the transducer automata that I think you used for an experimental FRP implementation
12:38:51 <conal> cmccann: great. start with that intuition and see if you can make it precise, and if so find out what's left and how useful it is.
12:39:08 <wavewave> can iteratee be understood as differentiation of some monad ?
12:39:15 <wavewave> like zipper
12:39:48 <mauke> carpi: http://hpaste.org/55741
12:39:59 <conal> cmccann: again, i'm looking for meaning, so i'd steer away from comparisons with implementations (or FRP or whatever).
12:40:52 <carpi> thank you . I never knew we could do something like that
12:41:38 <cmccann> conal, my only point there was that it's not tied to just implementing imperative programs
12:41:42 <Saizan> if you have Stream A -> B where B is discrete you can "memoize" that was Free (A ->) B because of continuity, iteratees are more like Free (\ X -> B , A -> X) B because of eof though
12:42:04 <Saizan> s/was/as/
12:42:10 <augur> are there any nice guides to various recursion schemes
12:42:16 <cmccann> conal, and asking about the semantics of foldl wasn't just a rhetorical question, I'd actually like to know how you'd describe the semantics of something like that.
12:42:16 <carpi> so it seems like sqrt needs an argument whose type is an instance of the floating typeClass
12:42:18 <augur> discussing the relations between the,?
12:42:19 <augur> them*
12:42:20 <conal> cmccann: ah, thanks. i guess i wasn't as clear as i'd thought. i'm looking for a *non-operational* perspective.
12:42:41 <carpi> is theere a function to convert an integer to a type that belongs to the floating typeclass?
12:42:44 <Saizan> when B = Nu G it gets more complicate
12:42:54 <c_wraith> :t fromIntegral
12:42:54 <lambdabot> forall a b. (Integral a, Num b) => a -> b
12:43:03 <conal> cmccann: for semantics, start with a _type_, not a function.
12:43:32 <carpi> but it seems like fromIntegral returns a type that is an instance of Num typeclass
12:43:39 <carpi> maybe thats the erro?
12:43:58 <c_wraith> any instance of Floating should also be an instance of Num
12:44:03 <c_wraith> @src Floating
12:44:03 <lambdabot> class  (Fractional a) => Floating a  where
12:44:03 <lambdabot>     pi                                                      :: a
12:44:03 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
12:44:03 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
12:44:03 <lambdabot>     (**), logBase                                           :: a -> a -> a
12:44:09 <c_wraith> @src Fractional
12:44:09 <lambdabot> class  (Num a) => Fractional a  where
12:44:09 <lambdabot>     (/)             :: a -> a -> a
12:44:09 <lambdabot>     recip           :: a -> a
12:44:11 <lambdabot>     fromRational    :: Rational -> a
12:44:18 <mauke> carpi: no, fromIntegral returns whatever type you want
12:44:21 <c_wraith> Yes, any instance of Floating is *required* to be an instance of Num
12:44:24 <mauke> i.e. you get to choose
12:44:25 <wavewave> start with type.. not a function.
12:44:44 <wavewave> hmm
12:44:51 <monochrom> wow, are we still struggling with numbers?
12:45:52 <cmccann> conal, ok, lists in general then
12:45:53 <wavewave> monochrom: definitely..  everything is number since pythagoras
12:45:59 <carpi> hmm.. i did sqrt (fromIntegral n :: Float) that seems to work though now i get another error but i thin k i can fix it : )
12:46:02 <monochrom> heh
12:46:11 <cmccann> monochrom, numbers are one of the three most difficult things in programming, we've been over this
12:46:19 <cmccann> the other two being text and timestamps
12:46:41 <c_wraith> I think timestamps win for absolute hardest
12:46:45 <conal> lists have a simple definition and a fixpoint semantics. do you want something else?
12:46:45 <monochrom> we should stick with simple booleans :)
12:46:47 <c_wraith> well, time in general, not just timestamps
12:47:46 <cmccann> c_wraith, I said timestamps because dealing with them in general tends to touch on most of the associated issues, but yeah
12:48:11 <carpi> success..  sucess.. the program compilesss. Best christmass ever :D
12:48:29 <monochrom> afterall, Robert Tennant showed that lexical scoping, recursion, and boolean state variables already get you Turing-completeness.
12:48:44 <cmccann> conal, not particularly, and I'd describe iteratees in general about the same way. a slightly more complicated definition than lists, that's all.
12:49:17 <monochrom> now I have to check whether it was Robert Tennant
12:49:24 <conal> cmccann: sure we can describe them that way. my question is whether we're talking sense or just fooling ourselves.
12:49:32 <c_wraith> monochrom: which is why all programs are written in assembly, because it's good enough to make computers do whatever you need, without any extra complication
12:50:04 <BMeph> c_wraith: What do you mean by "time" - time as a point, or time as an interval? :)
12:50:06 <conal> i mean, "... whether we'd be talking sense ..."
12:50:46 <conal> sometimes ideas sound simple only because they're not expressed precisely.
12:51:16 <cmccann> conal, honestly I think iteratees sound complicated mostly because they aren't expressed precisely enough
12:51:18 <conal> and it's hard to know without actually making the idea precise and seeing whether simplicity survives.
12:51:19 <c_wraith> BMeph: both.  Each have incredible problems
12:51:23 <conal> "Everything is vague to a degree you do not realize till you have tried to make it precise." - Bertrand Russell
12:51:44 <conal> cmccann: another fine speculation. is it true? who knows?
12:52:11 <mreh> conal: how stable is reactive these days?
12:52:20 <conal> i don't mind speculations, as long as we're not satisfied to stop there.
12:52:24 <djahandarie> conal, I like that quote :)
12:52:36 <conal> djahandarie: me, too. nails it! :)
12:52:46 <conal> mreh: reactive is _very_ stable.
12:52:55 <conal> mreh: but that's not a good thing.
12:53:31 <conal> djahandarie: here's another you might like:
12:53:32 <mreh> conal: I meant: can I use it yet? :)
12:53:41 <conal> "The demand for certainty is one which is natural to man, but is nevertheless an intellectual vice. So long as men are not trained to withhold judgment in the absence of evidence, they will be led astray by cocksure prophets, and it is likely that their leaders will be either ignorant fanatics or dishonest charlatans. To endure uncertainty is difficult, but so are most of the other virtues." - Bertrand Russell
12:54:00 <conal> mreh: happily?
12:54:25 <mreh> conal: is it still suffering from bugs in the implementation?
12:54:32 <cmccann> speaking of quotes, I'm fond of: "Civilization advances by extending the number of operations which we can perform without thinking about them."
12:55:01 <conal> cmccann: i like that one also.
12:55:03 <monochrom> it is Edmund Clarke, not Robert Tennent. "Programming Language Constructs for Which It Is Impossible to Obtain Good {Hoare} Axiom Systems"  Journal of ACM v26 1979
12:55:11 <carpi> would there be a huge difference in performance if a function were to run uncompiled in ghci as opposed to if it were run after compilation using ghc.. with optimizations?
12:55:18 <ehuber_> it would appear that the .cabal for hsc2hs is really broken? it's missing quite a few build-depends statements..
12:55:31 <djahandarie> conal, not bad, though the language is a little too colorful for my tastes. :p
12:56:15 <cmccann> How about: "The utility of a language as a tool of thought increases with the range of topics it can treat, but decreases with the amount of vocabulary and the complexity of grammatical rules which the user must keep in mind. Economy of notation is therefore important."
12:56:26 <conal> djahandarie: and evaluative & opinionated, which i dislike from almost everyone. russell i'll forgive.
12:56:41 <djahandarie> lol
12:57:04 <conal> mreh: i don't know. there were some terribly subtle operational bugs, some of which turned out to be ghc bugs and i don't know about the others. i got burned out in the process figuring out which was which.
12:57:15 * cmccann prefers to just go straight to Dijkstra for excessively opinionated quotes, why settle for second-best?
12:57:23 <conal> mreh: and then i got interested in other things, particularly pure functional/denotative gpu programming.
12:57:53 <conal> i do hope our species graduates past opinions.
12:57:55 <mreh> conal: not fun eh? okay. having read papers i'm keen to see how reactive can help me
12:58:35 <conal> mreh: exactly. not fun.
12:58:35 <conal> i
12:58:36 <conal>  go
12:58:40 <conal> oops.
12:58:40 <conal> i
12:58:59 <xil> hi. Could someone recommend a package for arbitrary precision floats? I found http://hackage.haskell.org/package/hmpfr but it says it's rather slow.
12:58:59 <conal> sheesh. i have to find another IRC client (besides colloquy)
12:59:38 <byorgey> carpi: yes, often it can be a difference of 100x or more.
13:00:28 <conal> xil: do you want infinite precision -- where you don't have to specify your desired precision before a computation?
13:00:43 <copumpkin> xil: I promised edwardk I'd get a different mpfr library that isn't slow working before the end of the year
13:00:47 <copumpkin> I have a couple more days
13:00:48 <roconnor> xil: what do you mean by arbitrary precision float exactly; do you mean exact real arithmetic or software floating point?
13:01:13 <carpi> hmm thats huge.. thanks for the clarification )
13:01:29 <mreh> arbitary precision floating point sounds like the antithesis of floating point
13:01:35 <conal> xil: so that every bit you extract is correct?
13:01:52 <cmccann> conal, anyway, I'd be happy to discuss the iteratee stuff further if you want but it's not something I quite have off the top of my head and IRC is awkward for the purpose. I'm less than enthused with the whole concept anyway, to be honest.
13:01:53 <xil> okay so I'm writing a Mandelbrot set viewer. I'd like it that when I reach the limit of Double precision, it will kick in with arbitrary precision. Whatever is fastest is what I mean by "arbitrary". So if specifying the precision beforehand is faster then I can go with that
13:02:03 <ClaudiusMaximus> copumpkin: my offer of assistance is still open, if there's anything i can do (though, i'll be away most of the next 2 days...)
13:02:29 <copumpkin> ClaudiusMaximus: well, I only told him I'd resolve the outstanding mpfr-specific issues, not that I'd finish the bindings for him :P
13:02:30 <ClaudiusMaximus> xil: in my Mandelbrot set viewer i switch to DoubleDouble then QuadDouble then hmpfr
13:02:33 <conal> cmccann: then we're both unenthused about iteratees, so it would probably be neither fun nor fruitful.
13:02:38 <copumpkin> if I fix the annoying shit, he'll write all the remaining bindings
13:02:45 <copumpkin> and then I can relax and enjoy the crazy shit he makes with it
13:02:53 <ClaudiusMaximus> xil: using bindings to libqd
13:03:01 <copumpkin> so probably not much to help with really :)
13:03:02 <copumpkin> thanks though!
13:03:03 <xil> ClaudiusMaximus: wow. Didn't know there was DoubleDouble or QuadDouble. I'll do that then for starters
13:03:11 <roconnor> xil: how do you know you've reached the limit of double precision?
13:03:20 <ClaudiusMaximus> xil: http://hackage.haskell.org/package/qd
13:03:44 <conal> xil: that's exactly the sort of thing i'd like to see non-strict functional programming do well. i don't think we're there. and may not be headed in that direction.
13:03:44 <xil> roconnor: well it's a constant, so I can just hard code it. When the size of the visible area is small enough I kick in to higher precision
13:04:11 <copumpkin> yeah, conceptually using something like CReal for a mandelbrot viewer would be nice
13:04:25 <ClaudiusMaximus> roconnor: in mine, i use 2^N pixel spacing, so when there's not enough bits free to distinguish neighbouring pixels well enough, i bump it up to the next precision
13:04:55 <ClaudiusMaximus> where "well enough" is hardcoded thresholds..
13:05:06 <roconnor> xil: ClaudiusMaximus: why are you guys using floating point at all?
13:05:16 <roconnor> instead of Complex Rational?
13:05:17 <xil> roconnor: how else can it be done?
13:05:21 <xil> oh....
13:05:37 <xil> hadn't thought about that
13:05:42 <copumpkin> floating point is probably a lot faster?
13:05:55 <ClaudiusMaximus> roconnor: i use Complex Rational for the viewport parameters, but i don't want to wait forever with zillions of ram
13:06:03 <roconnor> to compute if sqrt |x| < 2, just check if |x|^2 < 4
13:06:25 <ClaudiusMaximus> of course, it's a different Complex to Data.Complex because of silly RealFloat things
13:06:52 <copumpkin> ClaudiusMaximus: those will be gone soon
13:07:01 <conal> the whole situation with floating point is so painful to me, especially in our community which like principled, correctness-friendly programming.
13:07:16 <ClaudiusMaximus> copumpkin: really? completely?  (what about abs and signum ?)
13:07:27 * cmccann resists the temptation to complain about the Ord instance on floats
13:07:29 <copumpkin> c
13:07:31 <roconnor> ClaudiusMaximus: why do you use the floating point rounding policy instead of using approxRational?
13:07:37 <copumpkin> ClaudiusMaximus: no, I meant the data type constraint
13:07:49 <roconnor> @hoogle approx
13:07:50 <lambdabot> Data.Ratio approxRational :: RealFrac a => a -> a -> Rational
13:07:50 <lambdabot> package approximate-equality
13:08:08 <ClaudiusMaximus> copumpkin: ok, yeah that's gone in 7.4rc1
13:08:14 <conal> the provided hardware gives a compromise that almost always either wasteful of time & power or is incorrect, by computing either too many or too few bits.
13:09:05 <roconnor> xil ClaudiusMaximus: BTW, drawing the mandelbrot set by sampling pixels offers basically no guarentee about the correctness of your image.
13:09:11 <conal> and maybe this situation is hopeless for CPUs but hopeful for FPGA-like hardware.
13:09:33 <mreh> conal: why does the disclaimer about bugs in reactive only appear after 0.11.2?
13:09:37 <xil> roconnor: it's an approximation though, and a pretty good one usually
13:09:51 <roconnor> xil: why do you think it is a good approximation?
13:10:05 <xil> I haven't studied the moth behind it really. Just doing it for fun and education in Haskell really
13:10:10 <roconnor> :)
13:10:12 <roconnor> ok
13:10:13 <cmccann> conal, are you familiar with gosper's continued fraction representation for arbitrary precision numbers?
13:10:14 <ClaudiusMaximus> roconnor: true.. using distance estimator gives you error bounds i think, but that assumes floating point errors cancel out on average
13:10:16 <c_wraith> look out, there's a moth behind you!
13:10:22 <xil> roconnor: it's good up to the precision of the float times the number of iterations
13:11:23 <roconnor> xil: not really,  aliasing will make you miss all the filiaments.
13:11:32 <xil> I don't alias yet =P
13:11:49 <roconnor> xil: if you are sampling on a gid then you are subject to aliasing
13:11:53 <roconnor> *grid
13:12:16 <xil> oh whoops, thought about anti-aliasing. Of course it's aliasing, haha
13:12:41 <roconnor> but anyhow, ya it is a fun way to use haskell
13:12:50 <xil> so you say filaments ey? I don't think I know what those are
13:13:05 <roconnor> xil: I recommend something like Complex Rationall and approximateRational used reasonably.
13:13:45 <xil> I'll check it out then =]. I missed some of what y'all were discussing up there. Thought I saw someone say something about the performance of Complex Rational?
13:13:59 <roconnor> xil: filaments are thin threads of mandlebrot that connect larger regions.  The main spike is essentailly a filament.
13:14:37 <roconnor> xil: anything that doesn't use the hardware FPU will be relatively slow
13:14:50 <ClaudiusMaximus> xil: the filaments are the best bits! http://claudiusmaximus.goto10.org/g/mandelbrot/zigzaggingagain720p.png
13:14:52 <xil> ah well you can see the filaments as you zoom in
13:15:22 <xil> wow, that's awesome
13:15:39 <cmccann> shading by escape time tends to show where the filaments are
13:15:49 <conal> mreh: no deep reason. maybe just that i finally got around to warning people.
13:16:05 <conal> cmccann: i've not looked at it recently.
13:16:08 <xil> cmccann: I didn't know there was another way of shading
13:16:19 <ClaudiusMaximus> xil: http://mrob.com/pub/muency/distanceestimator.html
13:17:14 <conal> roconnor: though i wonder whether FPGAs offer something more flexible that can give both efficiency and correctness, unlike FPUs
13:17:29 <roconnor> It isn't actually known if the madelbrot set is computable or not; though there is an algorithm that, if it terminates (ie if it is an algorithm), does work.
13:17:32 <conal> roconnor: ie neither too many nor too few bits.
13:17:51 <roconnor> conal: it's hard to do arbitrary precission on an FPGA.
13:17:56 <cmccann> conal, his description of it is very imperative but it maintains the semantics of real numbers surprisingly well
13:18:21 <cmccann> it's also nicely suited to Haskell since the whole thing is very corecursive
13:18:28 <xil> by the way. This is a short series I made zooming in to a new place I found that I really like. And how amazingly similar the copy at the end is to the whole http://imgur.com/a/jaZt9
13:18:38 <conal> roconnor: do you know of references? it's something i want to explore at Tabula.
13:19:08 <roconnor> conal: there were some FPGA talks at ICFP 2011; so you can check the proceedings.  But that is all I know.
13:20:13 <conal> roconnor: do you have any references on arbitrary precision on FPGA? what's behind your remark about it being difficult?
13:21:20 <roconnor> conal: it was based on the talks I heard at ICFP 2011
13:21:49 <roconnor> conal: I was extrapolating from their remarks about how implementing recursion in FPGAs was tricky
13:21:52 <conal> roconnor: ah. i'll poke around in the proceedings and see what i find. thanks.
13:21:57 <roconnor> or at least the remarks that I recall
13:22:00 <conal> roconnor: oh! that paper.
13:26:55 <maurer> Does anyone recall if hPutStr is gauranteed not to interleave with other threads calling hPutStr
13:27:13 <mauke> I doubt it is
13:27:42 <maurer> :( I guess I'll lock it with an MVar or something
13:28:07 <shachaf> maurer: I think it is.
13:28:11 <conal> maurer: and hide that lock in a hPutStr' that does guarantee.
13:28:30 <shachaf> A Handle is already made up for MVars, at any rate.
13:29:56 <Philonous> I wish there where example solutions to the exercises in software foundations
13:33:07 <carpi> [x*y | x <- threeDigitNumbers, y <- threeDigitNumbers, isNumPalin (x*y)] .. in that statement .. is the computation (x*y) performed twice?
13:36:54 <conal> carpi: i'd expect so. depends on CSE, i guess. you can use a 'let'
13:39:01 <carpi> conal: coud you please tell me where might you add the let?
13:39:12 <carpi> along with the predicates just before the end of the list?
13:39:32 <conal> carpi: right before the isNumPalin
13:42:19 <augur> hey conal
13:42:26 <conal> hey augur
13:42:30 <augur> hows life dude
13:42:44 <conal> augur: sweet. you?
13:42:52 <augur> decent
13:43:08 <augur> on break from school
13:43:18 <g_> can pattern matching be done on something other than values?  like if x>5 use this definition, otherwise use the other definition?
13:43:20 <conal> carpi: [z | x <- threeDigitNumbers, y <- threeDigitNumbers, let z = x*y, isNumPalin z]
13:43:43 <g_> of if x is even use this definition, otherwise use this definition
13:43:47 <carpi> conal: thank you. it works. : ) but i think the let statement could also be place before the x <- ... and y <- ... expression or after the isNumPalin too..
13:43:51 <conal> g_: what do you mean other than values? what else?
13:44:05 <g_> conal: an expression i guess
13:44:30 <conal> carpi: try other orderings and see what you get
13:44:36 <cl1> g_ like a function guard?
13:44:50 <g_> cl1: maybe, i will look that up
13:45:38 <g_> cl1: yes
13:45:51 <cl1> g_, yay! i got something right for a change
13:45:59 <g_> exactly like that.  not the syntax i was attempting; thanks!
13:46:02 * cl1 is still a total n00b
13:47:44 <BMeph> g_: Look up "ViewPatterns", that might be helpful, even if it isn't what you mean.
13:53:02 <bss03> Is there are way to wrap an IO a from that is uses a "different" stdin?
13:53:40 <bss03> I'm trying to write a HUnit test to show some brokenness in some toy code, and it always reads from stdin.
13:53:56 <bss03> I want to supply it some toy input.
13:54:10 <c_wraith> bss03: make the code take a file handle instead of reading from stdin.
13:54:35 <bss03> I am trying to write the test to justify changes to the code.  The toy code is not mine.
13:54:42 <conal> bss03: i don't know, but i wonder: can you refactor your 'IO a' thingie into a non-IO part and a tiny IO part?
13:55:23 <conal> bss03: if so, your code will probably be better in itself, as well as giving you the flexibility you're asking about.
13:55:34 <bss03> I found with thread (http://www.haskell.org/pipermail/libraries/2002-November/000726.html), but it doesn't seem like anything came out of it.
13:56:45 <bss03> Well, the problem is in a simple terminal menu loop: display list of choices, take input, validate, either loop or return.
13:57:31 <bss03> So, the IO part isn't really that big, but they've got quite a few cases where is doesn't loop or return, but instead crashes based on user input.
13:58:49 <conal> bss03: if you show us the IO part, maybe we can help you make it nearly disappear, so that the testing you want can be done on the functional (non-IO) part.
13:58:50 <bss03> If I dupTo someFd stdInput, will stdin follow?
13:59:52 <cmccann> bss03, I'm assuming you can't really change the code you're trying to test?
14:00:02 <lukish_> Trying to use Network.Curl . Goal is to parse reputation value from http://api.stackoverflow.com/1.1/users/1 for example.
14:00:11 <lukish_> So, what I did already is
14:00:12 <lukish_> userReputation id = curlGetString url [] >>= return . snd where url = "http://api.stackoverflow.com/1.1/users/" ++ (show id)
14:00:32 <bss03> https://gitorious.org/linux-parallel-port-io/linux-parallel-port-io/blobs/master/paraio.hs -- recAnswer throws an exception on the input " \n", for example.
14:00:45 <lukish_> And now I have something like "\US\139\b\NUL\NUL\NUL\NUL\NUL\EOT\NUL\236\189\a`\FSI\150%&/m\202{\DELJ\245J\215\224t\16...
14:00:51 <lukish_> What should I do next?
14:01:10 <bss03> I wanted to show the error via an HUnit test, and after that fix up recAnswer.
14:02:14 <cmccann> bss03, ugh, that's a lot of unnecessary mucking around in IO :[
14:02:54 <bss03> lukish: Looks like JSON, use one of the JSON libraries to pull out the value(s) you need.
14:04:17 <lukish_> bss03: firstly I wanna have JSON, not htat \US\139 stuff
14:05:13 <bss03> cmccann: The code is being written as an exercise for someone quite new to Haskell.  He wanted a project, and someone else wanted an example of a parallel port I/O in Haskell.
14:07:24 <cmccann> bss03, ok, but it really seems like it's making things more difficult than they need to be
14:08:21 <bss03> lukish_: That \US\139 stuff is... well, it doesn't look like Unicode to me, but it is supposed to be JSON, since it is just the respose body.
14:10:06 <bss03> lukish_: I've never used Network.Curl, I always used Network.HTTP instead... but I doubt that's the problem.
14:10:11 <bss03> lukish_:
14:10:57 <bss03> lukish_: Do the response headers indicate a transfer-encoding or anything like that?  Maybe you are looking at binary (e.g. GZIP) data as a haskell String.
14:11:00 <conal> bss03: that code looks to be imperative mainly by habit. i bet you could clean it up a lot.
14:11:08 <cmccann> bss03, I just think that restructuring the code to make it simpler to work with would be more helpful than messing around with HUnit, really :T
14:12:29 <conal> bss03: and then the stdin inflexibility would go away.
14:14:46 <bss03> krakrjak: Did you see what they said about your code?  Imperative by habit.  Shame. ;)
14:15:41 <lukish_> I did not see any response headers
14:17:05 <bss03> conal, cmccann: I think that I don't really want to make it work on an arbitrary Handle pair like stdin/stdout...  since the code really won't be used much outside of a terminal.
14:17:59 <bss03> conal, cmccann: It seems like less mucking about to "swap out" stdin temporarily.
14:18:41 <conal> bss03: are you also learning to think & program functionally? there are deep obstacles to composability in imperative programming. See, e.g., John Backus's Turing Award lecture.
14:19:11 <conal> bss03: this stdin issue is just one symptom. an iceberg tip.
14:19:51 <bss03> conal: Well, got the last 6 months I've been doing imperative work, but I've done some purely functional stuff since then.
14:20:40 <bss03> conal: I'm been fiddling with one of Okasaki's asyptotically-optimal datastructures and trying to optimize it's practical performance while remaining purely functional.
14:20:53 <conal> bss03: nice.
14:21:42 <cmccann> bss03, here's an example for you
14:21:48 <hpaste> “C. McCann” pasted “less imperative style” at http://hpaste.org/55748
14:22:23 <conal> bss03: if you're reprogramming your brain to think functionally, you may like the exercise of splitting up that wad imperative code (paraio.hs) as i suggested before: a tiny bit of IO and a purely functional heart
14:22:38 <bss03> Yeah, that's probably similatr to how I would write it.
14:23:18 <cmccann> bss03, I'd still do things differently--I really dislike direct recursion in IO--but it just seems drastically simpler to do something like that example compared to the way it was
14:23:22 <bss03> cmccann: I don't like the use of "5" as a sentry value, a Maybe Port is a much better return type.
14:23:23 <conal> bss03: you can go further still. smaller imperative piece.
14:24:54 <cmccann> in an actual program I'd pull the recursion apart and build the logic in pure functions, have auxiliary functions to connect input/output, and then a parametric driver function that handles the recursion
14:25:02 <cmccann> but that would be overkill for something this simple
14:25:47 <conal> cmccann: overkill?? i bet it can be simpler than what you've written.
14:26:01 <cmccann> even if it is nice to be able to swap IO out for something that just replays a list of inputs and test the entire program without any IO at all
14:26:41 <cmccann> conal, depends on your definition of simpler
14:26:58 <cmccann> would probably be more code since I'd have to reimplement some generic combinators for the example
14:27:37 <conal> for learning purposes, i recommend taking your program to the functional extreme, and make it as elegant as possible there. only then you have enough info to know where to ideally draw the functional/imperative line.
14:27:50 <cmccann> with the proper combinator library to supply the monadic unfolds and whatnot it likely would be simpler
14:29:50 <ehuber_> hm, the process-1.0.1.5 that came with my installation of ghc7.0.4 has a different hash than the process-1.0.1.5 that is in hackage .. naughty naughty? :)
14:30:02 <ehuber_> made installation of hsc2hs kind of a pain..
14:30:28 <cl1> is this valid for getting the first item in a list of lists and the head and tail of that first item? intersperse' sep ((x:xs):xxs) = x:sep:xs:intersperse' xxs
14:33:57 <doserj> cl1: that can't possibly typecheck. You are putting x and xs in the same list, but they have different types
14:34:35 <cl1> x is of type a and xs is of type [a] xxs is of type [[a]]
14:34:41 <cl1> @type (:)
14:34:42 <lambdabot> forall a. a -> [a] -> [a]
14:35:52 <cl1> doserj, how is x:sep:xs not going to type check? x and sep are the same type and xs is a list of that type?
14:36:16 <shachaf> cl1: infixr :
14:36:25 <shachaf> cl1: Why don't you ask ghci and see what it says?
14:36:30 <maurer> Anyone know how to invoke lseek64 via the unix bindings? They appear to use lseek
14:37:00 <maurer> (and I need offsets dramatically greater than 32-bits
14:37:01 <cl1> couldn't match type `[a]' with actual type `[[a0]] -> [a0]'
14:37:42 <doserj> cl1: oh, yes. that error is because you forgot the sep argument in the recursive call probably
14:38:52 <shachaf> maurer: I don't think the package "unix" has bindings for it.
14:39:00 <maurer> shachaf: :(
14:39:00 <cl1> doserj, thanks, that at least got me a different error :D
14:39:21 <maurer> shachaf: Is there a reccomended way to be able to do a 64-bit seek?
14:41:31 <JuanDaugherty> just do it
14:42:03 <JuanDaugherty> it's an ancient API, the only complication is the word expansion
14:42:05 <shachaf> maurer: Hmm, are you sure the regular lseek isn't a 64-bit seek?
14:42:24 <parcs`> 32 bit seeks ought to be enough for everyone
14:43:02 * BMeph goes to get a towel after spewing coffee on his desk...
14:43:21 <roconnor> I can't wait for 256 bit processors
14:43:24 <shachaf> c_lseek :: CInt -> System.Posix.Types.COff -> CInt -> IO System.Posix.Types.COff; newtype COff = System.Posix.Type.COff Int64
14:43:43 <maurer> shachaf:        lseek(2) uses the type off_t.  This is a 32-bit signed type on 32-bit architectures, unless one compiles with
14:43:46 <maurer> etc.
14:43:50 <roconnor> no more virtual memory
14:44:02 <shachaf> maurer: I mean that the Haskell binding is to lseek and not lseek64 in the first place.
14:44:10 <roconnor> just randomly grab a segment; it isn't likely to conflict
14:44:12 <maurer> shachaf: I know this via strace
14:44:22 <maurer> strace reports lseek and lseek64 separately
14:44:23 <shachaf> Ah, I was about to strace it myself. :-)
14:44:36 <cl1> i wish i understood these error messages better
14:45:06 <cl1> Occurs check: cannot construct the infinite type : a0 = [a0] in the first argument of `(:)', namely `xs'
14:45:14 <shachaf> That's kind of odd. Why does c_lseek take a 64-bit Int?
14:45:34 <shachaf> cl1; It probably means you're trying to make a list which contains itself, or something of its own type.
14:46:00 <cl1> something of its own type? what?
14:46:03 <shachaf> Keep in mind that a:b:c = a:(b:c), not (a:b):c
14:46:20 <cl1> intersperse' sep ((x:xs):xxs) = x:sep:xs:intersperse' sep xxs
14:46:24 <shachaf> If an error message is too confusing, just ignore it and instead randomly fiddle with the source code until it's gone. :-)
14:46:28 <cl1> yes i know that (:) is infixr
14:46:28 <shachaf> cl1: Exactly.
14:46:36 <shachaf> So that's equivalent to?
14:46:55 <cl1> x:(sep:(xs:intersperse' xxs))
14:47:27 <shachaf> Right.
14:47:30 <doserj> so you have the list (intersperse' xxs), then you add the element xs, then sep, then x
14:47:41 <doserj> but x and xs have different types
14:47:46 <maurer> shachaf: Presumably because they wanted it to be "If you're on 64-bit, you can seek 64-bit" but didn't quite get there?
14:47:57 <cl1> oh
14:47:57 <shachaf> maurer: I suppose.
14:48:44 <shachaf> maurer: Oh, right, it does use lseek. :-(
14:48:54 <shachaf> maurer: I think you might just have to do it yourself.
14:48:56 <cl1> the problem is that xs is [a] and intersperse' sep xxs is also [a]
14:48:59 <cl1> got it
14:49:14 <shachaf> maurer: You can take inspiration from the implementation in "base", though.
14:49:40 <JuanDaugherty> are there two conflated cases, the actual need for 64 bit seek and mere conformity with 64 bit?
14:49:53 <shachaf> maurer: base also says: "// These are wrapped because on some OSs (eg. Linux) they are macros which redirect to the 64-bit-off_t versions when large file support is enabled."
14:50:18 <JuanDaugherty> the former would seem to imply virtual media, not a real block device
14:50:27 <shachaf> But I guess that's not very relevant because you straced it.
14:50:54 <shachaf> strace++
14:52:23 <cl1> intersperse' sep ((x:xs):xxs) = x:sep:xs ++ intersperse' sep xxs
14:52:52 <cl1> why does this care?  when i call: intersperse' [(-1)] [[1,2,3],[4,5],[6,7,8]]
14:53:05 <cl1> i get: No instance for (Num [t0])
14:53:19 <cl1> arising from the literal `8'
14:53:33 <shachaf> When you get that error, it means you're using a list as a number.
14:53:34 <cl1> i'm not even doing anything with the type that is contained in the list
14:53:45 <conal> cl1: have you declared a type for intersperse' ?
14:53:59 <cl1> intersperse' :: a -> [[a]] -> [a]
14:54:07 <cl1> DOH
14:54:23 <cl1> i know where I screwed up
14:54:56 <cl1> I am being very dense today
14:55:08 <cl1> too much christmas cheer i guess?
14:55:10 <cl1> lol
14:55:34 <conal> cl1: almost always, attention to types leads me out of these confusions.
14:57:30 <cl1> well the fact that it was complaining about 8 instead of telling me my parameter type didn't match what I had called didn't help me much
14:57:38 <maurer> shachaf: Yeah, just made a package, now trying ito u
14:57:42 <maurer> *it out
14:58:31 <carpi> how can we convert a char like '1' to an int or integer?
14:58:47 <carpi> read doesn't work on chars
14:59:03 <cl1> carpi: read [x] ?
14:59:19 <cl1> or read ['1']
14:59:35 <litb> hello folks
14:59:37 <cl1> @type read ['1'] :: Int
14:59:37 <lambdabot> Int
14:59:45 <carpi> ah.. spegetti sauce.. i suuuk :
15:00:21 <cl1> carpi, not any worse than me :D
15:00:23 <ddarius> "sphagetti"
15:00:49 <litb> " spaghetti"
15:00:53 <carpi> i can't even spell sphagetti.. none can beat me at being worser :)
15:01:04 <ion> > map digitToInt "1å"
15:01:05 <lambdabot>   [1,*Exception: Char.digitToInt: not a digit '\229'
15:01:09 <carpi> worser? is that even a word.?
15:01:52 <litb> lol worser
15:02:46 <maurer> Hm, it still prints lseek
15:02:54 <maurer> I could have sworn I'd seen strace print lseek64 bfore
15:02:56 <maurer> *before
15:06:04 <shachaf> maurer: Wait, you did a foreign FFI call to lseek64 and it still prints lseek?
15:06:31 <shachaf> maurer: (Anyway, I think it *does* call lseek.)
15:06:51 <carpi> how come '..' is not a function?
15:07:07 <maurer> shachaf: I called via
15:07:07 <maurer> foreign import ccall safe lseek64 :: Fd -> Word64 -> CInt -> IO Word64
15:07:08 <ddarius> Because it's syntactic sugar for a function.
15:07:28 <carpi> syntactic sugar? you mean like a shorthand?
15:07:36 <ddarius> Yes.
15:07:49 <carpi> is it possible to make our own syntactic sugar?
15:08:49 <homie> that requires medical research!
15:08:50 <homie> lol
15:09:07 <ddarius> It depends on how you define "syntactic sugar."  By one definition the answer would be "no" but essentially "no by definition..."
15:10:59 <carpi> thanks for the clarification.. though im sure there is more to it than that..
15:11:10 <ddarius> There isn't.
15:11:36 <osfameron> I like the "no, by definition" thing
15:11:47 <osfameron> though it's not really true of Lisp, say
15:12:22 <cmccann> it's possible to make your own syntactic sugar using a preprocessor of some sort
15:12:53 <ion> There’s also quasiquotation. It’s not quite the same thing, though.
15:12:59 <cmccann> of course, you'll then be writing code in something that's not entirely Haskell
15:13:35 <cmccann> quasiquotation is like zero-calorie syntactic artificial sweetener
15:13:40 <cmccann> the kind with a weird bitter aftertaste
15:14:06 <carpi> template haskell might be useful for creating our own syntactic sugar.  i think
15:14:40 <shachaf> maurer: Yes, I get the same thing calling lseek64 in C.
15:15:27 <maurer> shachaf: That's odd
15:16:04 <shachaf> maurer: Oh, apparently in 64-bit Linux there's only one system call for both.
15:16:08 <maurer> Oh, OK
15:16:29 <shachaf> (At least, looking through unistd_64.h seems to indicate that.)
15:17:02 <shachaf> Yes, compiling the C program with -m32 strace shows a call to _llseek.
15:17:39 <shachaf> (You also need to define _LARGEFILE64_SOURCE.)
15:17:39 <shachaf> fg
15:17:44 <Cale> cmccann: Though, what exactly Haskell is, is hard to say ;)
15:18:08 <shachaf> Birds, too.
15:18:11 <Cale> I hope we can eventually get our changes to Arrows made into a proper GHC extension.
15:18:41 <Cale> The existing arrow class and syntax is not nearly as useful as it easily could be
15:19:40 <Sgeo> How much abuse of typeclasses is too much?
15:19:50 <Cale> Sgeo: heh
15:20:18 <Sgeo> https://github.com/Sgeo/haskell-capabilities/blob/master/capabilities.hs
15:20:24 <Cale> Sgeo: If you have many classes with only one instance, it's probably worth taking a step back and reconsidering whether you actually need that polymorphism
15:20:43 <Sgeo> It has been suggested that I put an IO a -> Cap a in a module marked unsafe so untrustworthy stuff can't use it
15:20:47 <Sgeo> Then I wouldn't need the typeclass
15:21:02 <Sgeo> But, if I continue on the typeclass route, I can make makeCap even easier to use
15:21:18 <Sgeo> And I think it being easy-to-use is important, otherwise someone may screw up
15:21:27 <ion> cale: What changes to Arrows?
15:21:59 <Cale> ion: The Arrow class is missing a few primitives and at least one law :)
15:22:25 <Sgeo> o.O
15:22:47 <Sgeo> And currently, makeCap is easier to use than just giving raw access to Cap would be, I think
15:23:15 <Cale> In particular, it should be possible to translate the Arrow syntax sugar while limiting the use of arr to just complex pattern matching (i.e. on non-pairs), and expression construction on the right side of -<
15:23:24 <cmccann> Cale, Haskell is whatever the report says it is, of course. How that relates to the class of programs accepted by GHC is a trickier matter...
15:23:57 <Cale> cmccann: Haskell is also all the languages which are accepted by GHC + various combinations of extensions
15:24:02 <Sgeo> \x -> x == True == True is supposed to parse in Haskell98, right?
15:24:24 <Sgeo> But iirc no tools actually allow it
15:24:25 <Cale> Sgeo: it *parses*
15:24:38 <Sgeo> > \x -> x == True == True
15:24:39 <lambdabot>   Precedence parsing error
15:24:39 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
15:24:46 <Cale> oh, right, no it doesn't
15:24:56 <Cale> == isn't infixl or infixr
15:25:01 <Cale> it's just infix
15:25:05 <Cale> so it doesn't parse
15:25:15 <Cale> > \x -> (x == True) == True
15:25:16 <lambdabot>   Overlapping instances for GHC.Show.Show
15:25:16 <lambdabot>                              (GHC.B...
15:25:19 <Sgeo> But according to something I read, it should, because the lambda should extend as far as it can go, which should be just past the first True but not including ==
15:25:20 <Cale> :t \x -> (x == True) == True
15:25:20 <lambdabot> Bool -> Bool
15:25:37 <Cale> Sgeo: yeah, that part is fine, read the error message
15:25:57 <Cale> The problem is with using == twice at the same level like that
15:27:19 <cl1> can you define types in your functions?
15:27:45 <cmccann> speaking of infix parsing, somehow it still surprises me that this works:
15:27:49 <cmccann> :t (1 + 2 * 3 +)
15:27:50 <lambdabot> forall t. (Num t) => t -> t
15:28:10 <Cale> cl1: no
15:28:19 <Cale> cl1: well...
15:28:19 <Sgeo> So, any advice wrt typeclass abuse?
15:28:32 <Cale> cl1: If you mean via newtype/data, then no
15:28:42 <Sgeo> Keep abusing typeclasses to make usage easier, or stop abusing typeclasses because typeclass abuse is... I'm not actually sure what's wrong with it.
15:28:56 <cl1> Cale, yes via newtype or data
15:29:18 <Cale> cl1: 'where' and 'let' only allow for function and pattern bindings, and type declarations (i.e. like x :: t)
15:29:31 <Cale> They don't allow you to locally define new datatypes.
15:29:32 <cmccann> Sgeo, inappropriate use of typeclasses tends to result in awkward program design and unnecessary complexity in the long run
15:29:43 <cl1> Cale, would be cool if they did :D
15:29:54 <Cale> That has occasionally been proposed, but it would be of limited usefulness.
15:30:23 <cl1> Cale, exactly, it would limit the type to the function. LOL
15:30:26 <Cale> because you wouldn't be able to allow values of that datatype to escape, except possibly wrapped in an existential, say
15:30:43 <Cale> Maybe that's exactly what you want anyhow
15:31:09 <Cale> But... meh, you can do this abstraction at the module level easily enough, usually.
15:31:18 <cl1> i guess modules do pretty much the same thing by not exporting the type. its just not as local to where its used
15:31:23 <Cale> yeah
15:31:43 <Sgeo> I don't know if my typeclass abuse makes things needlessly complicated
15:31:52 <Sgeo> It makes using my function makeCap nice and simple
15:31:59 <Sgeo> makeCap putStrLn works nicely, for example
15:32:11 <Sgeo> makeCap forkIO doesn't, yet, but working on it.
15:32:27 <Sgeo> makeCap printf doesn't work, and I'm not entirely sure why
15:32:53 <Cale> cl1: Now, if you could somehow make the datatype being defined locally dependent on the parameters to the function, *that* would be different.
15:32:56 <Sgeo> Nor how to get a printfCap currently. I know how to get a forkCap without any more abuses, but I'd feel safer if people did makeCap forkIO and had it just work
15:33:14 <cmccann> Sgeo, a bit of typeclass trickery to create a nicer API isn't that bad
15:33:15 <Cale> cl1: but it's hard to say how that would even look
15:33:28 <Cale> (syntactically and semantically)
15:33:33 <cmccann> it's when you start building the main logic of a program around a bunch of type classes that it tends to be a problem
15:34:12 <Cale> I think it semantically has potential to make sense, but syntactically, it's really hard to find a notation which is any good.
15:34:37 <cl1> how about data keyword working similar to where, placed at the end of the function
15:34:40 <Cale> It starts looking like local template haskell :P
15:35:19 <Cale> cl1: I mean, the thing where the structure of the type that you define locally depends on the values of the parameters to the function.
15:35:40 <Cale> That's rather tricky to do well :)
15:35:48 <cl1> Cale, i would imagine so
15:36:35 <cmccann> Cale, what if it was allowed to depend on the type parameters to the function?
15:36:41 <cmccann> like a sort of local type family.
15:36:54 <Cale> That would maybe be easier...
15:37:15 <Cale> but not by much :P
15:37:28 <cmccann> seems like it'd be the same as type families, just with some weird scoping
15:37:40 <Cale> Yeah possibly
15:37:48 <cmccann> much less awkward than depending on runtime values
15:38:21 <Cale> I can sort of imagine a syntax for it at least.
15:39:13 <alistra> can anyone tell me what's wrong with my cabal?
15:39:13 <alistra> Building source dist for data-structure-inferrer-1.0.20111227...
15:39:14 <alistra> Preprocessing executable 'dsinf' for data-structure-inferrer-1.0.20111227...
15:39:14 <alistra> cabal: dist/src/sdist.-22312/data-structure-inferrer-1.0.20111227: does not
15:39:14 <alistra> exist
15:40:14 <mgccl> I declared instance (Integral a)=> Fractional (CF a), but I don't think it's possible to implement this at all.
15:41:10 <mgccl> Since fromRational is Rational->a, and my operations can only generate Integer from Integers, thus the result is always CF Integer, which is different from CF a, and the compiler complains
15:42:56 <cmccann> mgccl, you can't use fromInteger or something like that?
15:43:22 <cmccann> or more likely fromIntegral
15:44:09 <mgccl> cmccann: ohh! thx, yes I could use that!
15:48:58 * Sgeo wonders if his printf problems are actually intractable even given just the constructor
15:49:17 <cmccann> Sgeo, is this the magic type hackery version of printf?
15:49:28 <cmccann> because that's going to be awkward for what you're doing, yes
15:49:55 <Sgeo> cmccann, even if I don't use typeclasses, just have Cap be exported from an unsafe module?
15:50:49 <cmccann> Sgeo, that would be fine I assume
15:51:19 * Sgeo isn't entirely sure how it would be done
15:51:30 <Sgeo> I mean, getting printfCap given such a system
15:51:47 <Sgeo> Other than replicating the magic type hackery of printf
15:52:21 <cmccann> Sgeo, ah, maybe I'm confused about what you're trying to do
15:52:43 <cmccann> if you use printf normally and then wrap the result in Cap it should work the same as always
15:52:48 <Sgeo> A bunch of people in another channel are yelling at me to stop using typeclasses for this
15:53:31 <Sgeo> cmccann, but I want to pass around a (<varargs> -> Cap ()), not a ... hm
15:53:55 <cmccann> I'm still not sure what the type class stuff is really accomplishing for you, the varargs thing doesn't seem all that useful
15:54:36 <Sgeo> it means that makeCap putStrLn :: String -> Cap ()
15:54:59 <Sgeo> Having it easier to get that type might make this easier to use, and thus safer
15:55:03 <cmccann> why is something like "mkCap foo x y z" better than a "mkCap $ foo x y z" where mkCap :: IO a -> Cap a
15:55:16 <cmccann> the varargs thing seems like a lot of hassle
15:56:33 <Sgeo> Because I want to be able to pass around a x -> y -> z -> Cap () made from a x -> y -> z -> IO (). I guess .. hmm
15:56:53 <Sgeo> But it's not mkCap foo x y z
15:58:46 <Sgeo> It's makeCap foo instead of, say, fooCap x y z = mkCap $ foo x y z
15:59:47 <Sgeo> Hmm, I think part of it was my desire for makeCap to be in IO
16:02:33 <cmccann> Sgeo, I kinda see what you're going for but it's not really going to work as well as you'd like, I suspect
16:02:49 <cmccann> it'll probably be way more hassle than it's worth
16:04:30 <cmccann> I've written stuff like that before just because it's fun to mess around with type hackery, but it's a lot of baroque and fragile code just to provide a minor convenience that most Haskell programmers don't expect
16:08:42 <Cale> http://channel9.msdn.com/Blogs/Charles/YOW-2011-Simon-Peyton-Jones-and-John-Hughes-Its-Raining-Haskell :D
16:09:03 <cmccann> Sgeo, it's not too hard to handle some simple cases, but what about polymorphic functions, generic monadic combinators, functions that take IO actions as arguments...
16:09:29 <Sgeo> Was planning a way to deal with that third case
16:10:01 <Sgeo> Also, if I do want makeCap to live in IO, do I have a choice?
16:10:05 <cmccann> Sgeo, you may find this question and its answers interesting: http://stackoverflow.com/q/7030476/157360
16:10:14 <cmccann> to give you an idea of how convoluted this sort of thing can become :P
16:10:34 <cmccann> Sgeo, what exactly do you mean by making it "live in IO"?
16:12:21 <Sgeo> cmccann, currently, makeCap roughly returns an IO Cap (or IO ( stuff -> Cap)) rather than the Cap directly
16:12:39 <Sgeo> The reason is so that only something that has access to IO can turn an IO into a Cap
16:15:14 <cmccann> I still think it'd be easier to have makeCap take an IO action and just deal with handling different numbers of arguments manually :T
16:15:36 <cmccann> so you'd have (IO a -> IO (Cap a)) or the like
16:16:06 <Sgeo> How do you make that handle different numbers of arguments manually?
16:16:44 <Sgeo> How would you take a function of that type, and putStrLn :: String -> IO (), to get IO (String -> Cap ())?
16:16:48 <iwtu> Hello. Do I need wrap my file in module or is any way to generate documentation by haddock in this file http://paste.pocoo.org/show/526233/
16:18:04 <cmccann> the simple, albeit tedious, way would be to have things like "makeCap1 :: (a -> IO b) -> IO (a -> Cap b)", "makeCap2 :: (a -> b -> IO c) -> IO (a -> b -> Cap c)" and so on
16:18:15 <Sgeo> Indeed
16:19:32 <cmccann> Sgeo, as far as I can tell, all you really want here is "\f -> return . Cap ??? f" where ??? is n-ary function composition
16:20:36 <cmccann> and the type class stuff is just trying to recursively figure out how many arguments are involved
16:20:44 <iwtu> pls. anyone some experencie with haddock? :-)
16:21:26 <alistra> iwtu: haddock file?
16:22:01 <alistra> haddock -h file.hs
16:22:10 <iwtu> I need document this http://paste.pocoo.org/show/526233/ byt haddock -h file.hs give me just empty main
16:22:14 <iwtu> alistra:
16:25:16 <alistra> iwtu: haddock -h 4.hs -o doc --ignore-all-exports
16:25:22 <alistra> --ignore-all-exports
16:25:25 <alistra> no module needed then
16:26:00 * hackagebot blaze-html 0.4.3.1 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.4.3.1 (JasperVanDerJeugt)
16:26:25 <alistra> iwtu: http://alistra.ath.cx/tmp/doc
16:26:31 <alistra> w8
16:27:04 <alistra> http://alistra.ath.cx/tmp/doc/ iwtu now
16:27:25 <cmccann> Sgeo, anyway, I really do encourage you to just do things the stupidly simple way for now even if it is a bit clumsier. leave the magic type class hackery aside unless you really actually need it for some reason, which you usually don't
16:28:32 <iwtu> alistra: you made me happy :-))
16:29:10 <alistra> well nobody wants to help me with my cabal sdist problem
16:32:31 <iwtu> alistra: anyway to set encoding utf-8?
16:33:04 <alistra> haddock --help|grep unicode
16:34:47 <iwtu> doesn't work
16:35:16 <alistra> well i have no experience in unicode there
16:39:38 <iwtu> it doesn't seem very well :(
17:03:33 <iwtu> alistra: can you help me with "About program" ? standard comments don't work.
17:06:13 <tsuraan> I'm looking at the AES library, and it has the requirement that when it gets a lazy bytestring as its input, all the strict bytestring components of the lazy bytestring must have lengths that are multiple of 16
17:06:51 <tsuraan> is there a fast way to convert a LazyByteString into a LazyByteString that meets that requirement?  Is there some common library to do it, or am I rolling my own?
17:07:56 <shachaf> tsuraan: That seems like a pretty specific requirement; you'll probably need to do it on your own.
17:08:01 <shachaf> On the other hand it seems like aone-liner.
17:08:39 <shachaf> I don't think a user of the lazy ByteString API should care about chunk sizes, though...
17:08:42 <shachaf> Seems like a n abuse.
17:09:00 <tsuraan> it is a binding to a C library, so I'd guess it's probably an abuse :)
17:09:21 <shachaf> Yes, I imagine that it should at least take a list of strict ByteStrings.
17:12:26 <Cale> tsuraan: Yeah, though probably it should be doing that chunk-sizing for you
17:13:13 <Cale> While the lazy bytestring API exposes information about the sizes of chunks in the string, it's really not something which you're supposed to use or rely on, I think.
17:13:28 * shachaf is in agreement.
17:13:36 <tsuraan> is there a preferred AES library that people use?
17:13:53 <tsuraan> I figured the one named "AES" would be sane, but it seems a little bit less than sane :)
17:14:05 <Cale> Crypto is probably the most stable one
17:14:22 <tsuraan> yeah, that.  somehow I forgot about that library :-/
17:14:33 <Cale> I've never really used it, so I don't know if it's good or not.
17:14:51 <Cale> It may be a little antequated
17:15:00 <Cale> It was written prior to ByteString existing.
17:15:32 <tsuraan> heh, that is pretty old-school
17:16:06 <shachaf> let lazyToStrict :: LB.ByteString -> SB.ByteString; lazyToStrict = SB.concat . LB.toChunks; rechunk = LB.fromChunks . unfoldr (\lb -> case LB.splitAt 16 lb of (h,t) | LB.null t -> Nothing | otherwise -> Just (lazyToStrict h, t))
17:16:42 <shachaf> Wait, that's broken.
17:17:11 <tsuraan> we also don't need 16-byte chunks, just chunks that are multiple of 16 bytes.  so if a chunk is good, we don't need to do any copying
17:17:17 <ddarius> FastPackedString has been around for a long time.
17:17:43 <shachaf> Make that "LB.null h", not "LB.null t".
17:18:01 <Cale> ddarius: But as far as I know it wasn't really widely used or depended on by other libraries until it was named ByteString.
17:18:02 <shachaf> Foiled by relying on the type-checker too much.
17:18:10 <shachaf> Oh, multiples of 16 bytes?
17:18:16 <tsuraan> yeah
17:18:39 <shachaf> Well, this'll make chunks that are too small, but it won't actually do any copying for a chunk that's a multiple of 16 bytes, I think.
17:18:53 <Cale> Getting into the basic set of GHC packages probably had a lot to do with that.
17:19:18 <shachaf> A ByteString is an index into an actual string of bytes in memory somewhere.
17:19:20 <Cale> also, all the publicity from stream fusion :)
17:20:26 <Cale> ByteString's stream fusion was probably the first case I ever saw of Haskell programs getting really competitive with C programs on microbenchmarks.
17:20:38 <shachaf> Yay, microbenchmarks.
17:21:32 <shachaf> tsuraan: Anyway, you could do something in the spirit of my function easily enough.
17:21:32 <Cale> Microbenchmarks may not be an indicator of much, but the language shootout can be good for language publicity anyway if you're winning :)
17:22:01 <shachaf> You might need to check for chunk sizes explicitly, though.
17:22:57 <tsuraan> I'm still hoping to find a library that doesn't have that requirement.  I hate copying memory around :)
17:23:14 <tsuraan> SimpleAES doesn't say it has the requirement.  that's a start
17:23:33 <shachaf> tsuraan: Well, if it's an FFI to a C function, it'll probably have to copy the memory around eventually.
17:23:46 <tsuraan> now to see if quicktest can generate variations of a lazy bytestring that just differ in their chunk sizes
17:23:53 <Cale> Someone should write a ByteString interface for Crypto.
17:24:12 <shachaf> tsuraan: This rechunking shouldn't copy the actual memory of the ByteStrings unless there's an unaligned chunk boundary.
17:24:40 <Cale> I think really all you'd need to reimplement is cipher block chaining.
17:25:02 <tsuraan> my bytestrings come from a network card, so I think the chunks might really be in different places
17:25:26 <Cale> which is actually pretty damn simple, when you get down to it
17:25:42 <shachaf> tsuraan: As long as they're big enough it oughtn't matter, though, I think.
17:25:43 <tsuraan> also, about the FFI thing, I thought that one of the cool things about bytestrings and the FFI is that they often didn't require any copying
17:25:47 <tsuraan> true
17:26:03 <Cale> http://hackage.haskell.org/packages/archive/Crypto/4.2.4/doc/html/src/Codec-Encryption-Modes.html#cbc -- you need to do this for ByteStrings, which you might just be able to do by replacing the HOFs with their ByteString equivalents.
17:26:17 <shachaf> tsuraan: You're probably worrying too much and should benchmark first and ask questions later. :-)
17:26:43 <Cale> and profile before saying what's too slow ;)
17:27:02 <tsuraan> profiling is fun too, I suppose :)
17:27:35 <tsuraan> haskell's the only runtime I've used that gives me pretty graphs of exactly how slow my stuff really is
17:27:41 <Cale> It's very easy to waste time on things which are already good in any language, but particularly in Haskell.
17:27:53 <Cale> (unless you use the profiler)
17:28:21 <Cale> There's a lot of magic which happens surrounding ByteStrings with rewrite rules
17:28:55 <Cale> and so things can be unintuitively fast, and require very little copying even when written in a modular way (actually, *especially* when written in a modular way)
17:28:56 <tsuraan> I tend to make criterion suites for most of my stuff.  it's pretty fun
17:29:39 <tsuraan> that's probably the coolest package I've ever seen
17:29:48 <Cale> Because all the higher order things turn into stream transformations with conversions to and from a stream type, and then those conversion/deconversion operations are eliminated, and the stream operations can be inlined
17:30:16 <Cale> and the code you write ends up looking very different from the compiled output
17:30:28 <Cale> (even moreso than usual for Haskell code)
17:30:38 <shachaf> Except when it doesn't work, and then all you have is stream confusion.
17:30:41 <Cale> haha
17:30:56 <tsuraan> if you write a function like shachaf wrote above, the compiler isn't going to magically align all your bytestring chunks at allocation time though, is it?
17:31:02 <Cale> Yeah, if you compile without at least -O, it's really terrible
17:31:54 <shachaf> tsuraan: That depends on where the allocation is happening, I suppose.
17:32:11 <shachaf> At any rate it only really matters if the chunks are small, I would imagine.
17:33:15 <tsuraan> yeah, I'll have to write it up and see if there even is a noticable effect
17:33:46 <tsuraan> I also write python, where substrings actually allocate entirely new strings, so I just have a hard-wired aversion to doing that at all.
17:34:07 <shachaf> Aren't Python strings immutable?
17:34:14 <tsuraan> yeah :-/
17:34:19 <tsuraan> cpython's runtime is crap though
17:34:52 <tsuraan> at least 2.x.  I still haven't seen 3.x, but I'd be surprised if they ever changed that
17:35:59 <bobzhang> does anyone know how to use yacc to do context-senstive parsing? I mean before the component of symbols to be parsed do some actions. Thanks :)
17:36:43 <exFalso> :hoogle [a]->[b]->[(a,b)]
17:36:56 <exFalso> @hoogle [a]->[b]->[(a,b)]
17:36:56 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
17:36:56 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
17:36:56 <lambdabot> Test.QuickCheck.Modifiers shrinkState :: ShrinkState s a => a -> s -> [(a, s)]
17:37:10 <shachaf> exFalso: See also zipWith if you want to map something over it immediately.
17:37:12 <exFalso> ahh cartesian product?
17:37:25 <shachaf> exFalso: Oh, no, zip isn't Cartesian product.
17:37:29 <shachaf> > liftM2 (,) "abc" "def"
17:37:30 <lambdabot>   [('a','d'),('a','e'),('a','f'),('b','d'),('b','e'),('b','f'),('c','d'),('c'...
17:37:40 <shachaf> > sequence ["abc","def"]
17:37:41 <lambdabot>   ["ad","ae","af","bd","be","bf","cd","ce","cf"]
17:37:51 <exFalso> awesome thanks:)
17:38:10 <shachaf> > [(x,y) | x <- "abc", y <- "def"]
17:38:11 <lambdabot>   [('a','d'),('a','e'),('a','f'),('b','d'),('b','e'),('b','f'),('c','d'),('c'...
17:38:45 <exFalso> yeah i was hoping i can avoid list comprehensions
17:39:09 <exFalso> liftM2 (,) is perfect
17:39:33 <shachaf> > liftA2 (,) "abc" "def"
17:39:33 <lambdabot>   [('a','d'),('a','e'),('a','f'),('b','d'),('b','e'),('b','f'),('c','d'),('c'...
17:41:34 <singpolyma> When I run cabal haddock --hyperlink-source --executables on my project I get haddock: failed to parse haddock prologue from file  -- I thought at first that it wanted me to add a documentation comment to the module, but that doesn't help. any ideas?
17:42:52 <aavogt> the "prologue" thing is some documentation that appears at the top of the table of contents for the whole project
17:43:05 <aavogt> which is ex. the description here http://xmonad.org/xmonad-docs/xmonad/
17:43:56 <aavogt> singpolyma: try adding your own prologue specified with the --prologue argument
17:44:39 <Cale> singpolyma: The funny thing about haddock (which is actually pretty reasonable if you think about it) is that your comments can't just be any Haskell comments, but have to conform a bit to a given syntax. It could be that something about the syntax of that comment it doesn't like.
17:45:11 <Cale> (Haddock's error messages are often a little vague)
17:46:25 <singpolyma> aavogt: hmm, cabal does not like me adding that option.  I assume cabal wants to be generating that prologue itself, and for some reason is failing
17:50:53 <singpolyma> aavogt: oh, it seems I cannot have < or > in the cabal "description" field
17:50:54 <singpolyma> hmm
17:52:24 <blackdog> if i want Data.Monoid, do I need to import base, or is there a way to do it and keep haskell2010?
17:53:02 <iwtu> alistra: please.. I am desperate
17:53:52 <iwtu> http://paste.pocoo.org/show/526256/
17:54:48 <augur> anyone know what a histomorphism is?
17:55:03 <iwtu> would like someone to tell me how can make "About program" by haddock ?
17:55:33 <ddarius> Someone had way too much time on their hands: http://www.lorentzcenter.nl/lc/web/2011/467/info.php3?wsid=467
17:56:17 <ddarius> I believe it's a recursion scheme that supports course-of-values recursion.
17:56:41 <augur> ddarius: thats what ive heard
17:56:49 <augur> is there a nice writeup that you know of
17:58:30 <ddarius> "We completed the prototype after several years and showed it to our would-be user group, and were shattered to hear them say, No, thanks, we actually like drawing on the whiteboards. We dont want to take the time to put the drawings into the computer. Um, may we use the drawing editor portion of your tool suite? Listening to other tools vendors, we heard the same experiences, usually ending up with, they u
17:58:30 <ddarius> se just the drawing editor portion. In other words,"
17:59:22 <augur> what
17:59:35 <monochrom> it is what your hair looks like when you write too many proofs :)
18:01:59 <dassouki> after running the osx installer, I don't have a haskell app in my Applicatiosn folder nor can I ascess haskell from the command prompt
18:02:02 <dassouki> terminal
18:06:01 * hackagebot sock2stream 0.1 - Tunnel a socket over a single datastream (stdin/stdout)  http://hackage.haskell.org/package/sock2stream-0.1 (StephenWeber)
18:06:36 <rewq123> prepareLargeQuery in Takusen does not do anything special for ODBC I imagine... or does it?
18:07:09 <rewq123> DBMS specific docs seem to be missing for the newer versions
18:11:01 * hackagebot pktree 0.1 - Implementation of the PKTree spatial index data structure  http://hackage.haskell.org/package/pktree-0.1 (StephenWeber)
18:19:21 <hpaste> Teste pasted “Teste” at http://hpaste.org/55756
18:20:08 <JoeyA> Typo, or cheap viagra spam?
18:21:31 <rewq123> JoeyA: perhaps it's in spanish or some other language
18:21:31 * ski stares blankly
18:22:20 <JoeyA> Ah
18:23:53 <JoeyA> I guess that's why some sites (e.g. StackOverflow) have a minimum post length.  This is an example where spam detection is impossible, even for humans.
18:24:15 <JoeyA> (unless we're not human enough)
18:26:40 * ddarius pulls out his whip, starts cracking it, and yelling, "Be more human!"
18:27:25 <conn> A very noob question here: how can I write Person {name = "noob", dob = toCalendarTime `fmap` getClockTime } somewhere outside main?
18:28:07 <JoeyA> Looks like a mixture of values and IO.  Does that even work inside of main?
18:28:27 <ddarius> Depends on the type of dob.
18:28:39 <ddarius> Though it probably isn't IO CalendarTime
18:28:40 <JoeyA> @hoogle toCalendarTime
18:28:41 <lambdabot> System.Time toCalendarTime :: ClockTime -> IO CalendarTime
18:29:00 <conn> dob is just CalendarTime
18:29:51 <conn> I'm used to .NET and Ruby, we just write dob = DateTime.Now. I'm all confused with impure vs pure thing
18:30:03 <JoeyA> Just wondering, does Haskell (or a GHC extension thereof) support syntax something like this?  Person {name <- prompt "Name?"; dob <- toCalendarTime <$> getClockTime}
18:30:14 <JoeyA> (that is, using do-like syntax to construct a record)
18:30:55 <JoeyA> Constructing a record is otherwise annoying, if you want to name members.
18:31:37 <JoeyA> conn: d <- toCalendarTime `fmap` getClockTime; ... Person {name = "noob"; dob = d}
18:31:55 <conn> I think you'd have to be in main to do that
18:32:40 <conn> I'm constructing this Person somewhere else (and I have no way to pass the dob as parameter to that function)
18:33:04 <JoeyA> conn: You have to be in the IO monad.
18:33:24 <conn> Yeah, that's the problem.
18:34:22 <salisbury> :t ByteString
18:34:23 <lambdabot> Not in scope: data constructor `ByteString'
18:34:37 * JoeyA wonders if someone's official date of birth will be calculated by getClockTime at some point
18:34:57 <conn> I'm trying to write a Blog using Yesod, and I create a new Post on  a POST request. That Post needs the getClockTime to store as its creation time and I don't know how to do that
18:35:34 <salisbury> hmm.. can I treat bytestring as [Word8]? I want to foldM..
18:35:38 <JoeyA> conn: You calculate it in the IO monad.  Could you post the context of your code?
18:36:11 <JoeyA> You might be in an IO-capable monad already.  You might be able to say: d <- liftIO $ toCalendarTime `fmap` getClockTime
18:36:13 <JoeyA> @hoogle liftIO
18:36:14 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
18:36:14 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
18:36:14 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
18:36:18 <hpaste> conn pasted “Blog in Yesod” at http://hpaste.org/55757
18:36:21 <JoeyA> Control.Monad.IO.Class
18:36:40 <JoeyA> postNewPostR :: Handler RepHtml ?
18:37:13 <conn> yeah, Yesod needs that
18:37:43 <JoeyA> where is Handler defined?
18:38:06 <conn> Yesod.Handler I guess?
18:38:24 <salisbury> :t Data.ByteString.Char8.unpack
18:38:25 <lambdabot> BSC.ByteString -> [Char]
18:38:52 <JoeyA> Yu'd think (I'm not seeing it)
18:39:05 <ddarius> @hoogle Foldable
18:39:05 <lambdabot> Data.Foldable module Data.Foldable
18:39:05 <lambdabot> Data.Foldable class Foldable t
18:39:05 <lambdabot> Control.Seq seqFoldable :: Foldable t => Strategy a -> Strategy (t a)
18:40:01 <ddarius> @hoogle (a -> Word8 -> a) -> a -> ByteString -> a
18:40:01 <lambdabot> Data.ByteString.Lazy foldl :: (a -> Word8 -> a) -> a -> ByteString -> a
18:40:01 <lambdabot> Data.ByteString foldl :: (a -> Word8 -> a) -> a -> ByteString -> a
18:40:01 <lambdabot> Data.ByteString.Lazy foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
18:40:09 <conn> I see it's not Yesod.Handler
18:40:12 <JoeyA> conn: I don't have yesod installed.  Mind typing the following in GHCi?
18:40:15 <JoeyA> import Yesod
18:40:17 <JoeyA> :i Handler
18:40:22 <ddarius> @hoogle Monad m => (a -> Word8 -> m a) -> m a -> ByteString -> m a
18:40:23 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
18:40:23 <lambdabot> Data.Foldable foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
18:40:23 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
18:42:25 <conn> I did that. Strangely I get Not in scope: data constructor 'Handler'
18:43:15 <JoeyA> conn: Does the code you posted compile otherwise?
18:43:43 <conn> Yep. It does.
18:43:46 <JoeyA> Maybe there's an insane amount of Template Haskell going on.  I don't know...
18:43:57 <salisbury> ddarius: I don't think it's possible?
18:44:23 <conn> Yesod definitely uses TemplateHaskell
18:44:32 <JoeyA> conn: In any case, try d <- liftIO $ toCalendarTime <$> getClockTime
18:44:52 <salisbury> without unsafePerformIO, at least..
18:44:58 <JoeyA> If Handler is an instance of MonadIO, this should work.
18:45:53 <conn> I got it.
18:46:15 <conn> type Handler = GHandler Blog Blog
18:46:21 <conn> -- Defined at app.hs:(49,1)-(53,2)
18:47:19 <conn> type GHandler sub master =   GGHandler     sub     master     (Data.Enumerator.Internal.Iteratee        Data.ByteString.Internal.ByteString IO)   	-- Defined in Yesod.Handler
18:48:04 <JoeyA> conn: It looks to me like Handler has a MonadIO instance.  Try using liftIO to get the time.
18:49:02 <conn> can you tell me what exactly I have to write? I never used liftIO before.
18:49:38 <JoeyA> conn: Take whatever you would have written in main, and apply liftIO to it.
18:49:44 <JoeyA> @hoogle liftIO
18:49:45 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
18:49:45 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
18:49:45 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
18:50:03 <JoeyA> for example, d <- liftIO (toCalendarTime `fmap` getClockTime)
18:50:33 <djahandarie> That's one way to advertise, I guess.
18:50:41 <confab> djahandarie: right?
18:50:53 <confab> i think it's the wrong kind of advert though
18:50:59 <djahandarie> No kidding :)
18:54:40 <Sgeo> Advertise?
18:58:07 <salisbury> hmm hackage tells me Bytestring folds etc.. deal with Word8, GHC says char
19:00:52 <shachaf> salisbury: ByteString doesn't have anything to do with Char.
19:01:14 <shachaf> It's Word8, or, if you're using Data.ByteString.Char8 (which you shouldn't), Char8.
19:01:29 <ddarius> Char
19:01:54 <salisbury> ah, yes
19:01:58 <salisbury> char8 was the problem
19:02:05 <salisbury> dunno why I was putting that in there
19:02:13 <CaucusMan> Mitt Romney has experience fixing problems! When Mitt was elected Governor of Massachusetts in 2002, the state was in severe disarray, its budget was out of balance, spending was soaring, and taxpayers were being required to pay more and more in taxes for diminishing services. The state economy was in a tailspin, with businesses cutting back on investment or even closing and unemployment ticking up. Mitt made hard decisions that brought state sp
19:02:13 <CaucusMan> ending under control. He restructured and consolidated government programs, paring back where necessary and finding efficiencies throughout. Vote Mitt Romney 2012! http://www.mittromney.com
19:02:30 --- mode: ChanServ set +o monochrom
19:02:34 --- mode: monochrom set +b *!*CaucusMan@*.meth.lab.im
19:02:34 --- kick: CaucusMan was kicked by monochrom (CaucusMan)
19:02:48 <salisbury> .meth.lab.im eh?..
19:03:40 <augur> its interesting that caucusman didnt just enter the room but has been here a while
19:03:50 <augur> channel, even
19:04:26 --- mode: monochrom set -b *!*CaucusMan@*.meth.lab.im
19:04:42 --- mode: monochrom set +b *!*@*.lab.im
19:04:48 --- mode: monochrom set -o monochrom
19:05:25 <salisbury> augur!
19:08:32 <augur> salisbury!
19:10:57 <salisbury> Have you any more interesting papers?
19:11:01 <salisbury> Monday is my paper night
19:13:04 <Martty> theres A4
19:13:07 <Martty> and Letter
19:14:41 <ben> hm, that's not nice
19:14:57 <ben> reading on a pf_unix pipe just stalls if there's no writer to it? :(
19:15:12 <cl1> okay, i give up on FP
19:15:28 <cl1> y'all can't seem to write any tutorials that do NOT involve complex math
19:16:00 <ddarius> Thought I think may be interesting keep coming into my head and I keep forgetting them before I can think about them.
19:16:42 <ddarius> LYAH is where I go to brush up on string theory.
19:17:19 <cl1> LOL
19:17:44 <djahandarie> ddarius, that sounds like it would not be very effective.
19:17:58 <ddarius> djahandarie: String theory is a bunch of hogwash anyway.
19:18:25 * monochrom writes tutorials that don't seem to involve math
19:19:00 <ddarius> That's the problem monochrom.  You're infected.  You write math without even realizing it.  You're a carrier.
19:19:24 <djahandarie> ddarius, what, not a fan of cobordisms?
19:19:40 <monochrom> oh, I don't mean seem-to-me. I mean seem-to-other-people. they told me they didn't see math.
19:20:24 * ddarius references his comment with regards to being a carrier.
19:20:38 <ddarius> djahandarie: I hear it's pretty math.  It's just not physics.
19:21:03 <djahandarie> Oh. I don't really know much about physics. :(
19:21:03 * hackagebot hdaemonize-buildfix 0.4.5 - Library to handle the details of writing daemons for UNIX  http://hackage.haskell.org/package/hdaemonize-buildfix-0.4.5 (MarkWotton)
19:21:15 <monochrom> maybe I'm a carrier but I write math without the readers realizing it.
19:22:15 <_jesse_> what does ||| do in haskell? I'm having a bit of trouble googling it
19:22:44 <monochrom> that really depends on context. actual code? actual import lines?
19:22:55 <monochrom> origin?
19:23:07 <_jesse_> ah, I'm trying to bumble my way through some xmonad conf
19:23:16 <monochrom> I don't know xmonad.
19:23:26 <_jesse_> I spent some time with haskell a few months ago, but I never got that far with it
19:23:50 <djahandarie> @hoogle (|||)
19:23:50 <lambdabot> Control.Arrow (|||) :: ArrowChoice a => a b d -> a c d -> a (Either b c) d
19:24:01 <djahandarie> Hmm, something tells me that isn't the one xmonad is using
19:24:16 <djahandarie> Might be worth asking in #xmonad
19:24:23 <augur> i hate it when people use a for arrows
19:24:26 <djahandarie> They are generally pretty active as far as I know
19:24:40 <augur> i wish they'd use a better notation. its just so hard to read a as anything other than a random boring variable
19:24:43 <augur> when its really not
19:25:01 <monochrom> they should use arr for arrows. arr ye matey -> arr ahoi matey -> ...
19:25:10 <augur> i wonder, is it possible to use operators for variables?
19:25:13 <augur> like
19:25:16 <augur> could you do
19:25:16 <_jesse_> will do, forgot about hoogle
19:25:32 <ddarius> :t arr :: (r -> r) -> arr r rr
19:25:33 <lambdabot>     Could not deduce (Arrow arr) from the context ()
19:25:34 <lambdabot>       arising from a use of `arr' at <interactive>:1:0-2
19:25:34 <lambdabot>     Possible fix:
19:25:36 <monochrom> there is an extension for that
19:25:57 <augur> ArrowChoice (~>) => (b ~> d) -> (c ~> d) -> (Either b c ~> d)
19:26:00 <djahandarie> ddarius, clearly not a good choice of variable names. :)
19:26:06 <monochrom> some people do that
19:26:14 <ddarius> :t arr :: (Arrow (~>)) => (r -> r) -> (r ~> r)
19:26:15 <lambdabot> forall r (~> :: * -> * -> *). (Arrow (~>)) => (r -> r) -> (~>) r r
19:26:26 <augur> well then!
19:26:31 <augur> it looks like you can!
19:26:35 <monochrom> :t arr :: (r -> r) -> arr r r
19:26:36 <lambdabot>     Could not deduce (Arrow arr) from the context ()
19:26:36 <lambdabot>       arising from a use of `arr' at <interactive>:1:0-2
19:26:36 <lambdabot>     Possible fix:
19:26:42 <augur> now see, that would be so much more useful
19:26:44 <monochrom> oh nevermind
19:27:08 <monochrom> :t arr :: Arrow arr => (r -> r) -> arr r r
19:27:09 <lambdabot> forall r (arr :: * -> * -> *). (Arrow arr) => (r -> r) -> arr r r
19:27:12 <monochrom> there!
19:29:39 <ddarius> :t arr :: Arrow a => (a' -> a'') -> a a' a'' -- cleared up
19:29:40 <lambdabot> forall a' a'' (a :: * -> * -> *). (Arrow a) => (a' -> a'') -> a a' a''
19:29:48 <djahandarie> Heh
19:30:12 <monochrom> naw, that is hardly clear
19:31:56 <monochrom> :t id :: â -> â
19:31:57 <lambdabot> parse error (possibly incorrect indentation)
19:32:02 <monochrom> oh well
19:32:26 <monochrom> :t arr :: Arrow arr => (arr' -> arr'') -> arr arr' arr''
19:32:26 <lambdabot> forall arr' arr'' (arr :: * -> * -> *). (Arrow arr) => (arr' -> arr'') -> arr arr' arr''
19:33:34 <ddarius> :t arr :: Arrow (~>) => ((~~>) -> (~~~>)) -> (~~>) ~> (~~~>)
19:33:35 <lambdabot> forall ~~> ~~~> (~> :: * -> * -> *). (Arrow (~>)) => ((~~>) -> (~~~>)) -> (~>) (~~>) (~~~>)
19:34:05 <augur> ddarius:  hate you so much :(
19:34:26 <ddarius> :t arr :: Arrow (-~~>) => ((~-~>) -> (~~->)) -> (~-~>) -~~> (~~->)
19:34:27 <lambdabot> forall ~-~> ~~-> (-~~> :: * -> * -> *). (Arrow (-~~>)) => ((~-~>) -> (~~->)) -> (-~~>) (~-~>) (~~->)
19:34:32 <augur> @_@
19:34:33 <augur> %_%
19:34:35 <augur> #_#
19:34:38 <augur> &_&
19:34:59 <djahandarie> :t arr :: Arrow (==>) => ((===>) -> (====>)) -> (===>) ==> (====>)
19:35:00 <lambdabot> forall ===> ====> (==> :: * -> * -> *). (Arrow (==>)) => ((===>) -> (====>)) -> (==>) (===>) (====>)
19:35:18 <ksf> ggnah
19:35:23 <djahandarie> Hahaha
19:35:52 <ksf> ghc-pkg dump returns utf8 bytes in its output.
19:36:02 <ksf> well, or something else.
19:36:21 <ksf> at least readProcess is choking on it.
19:36:42 <monochrom> arr :: Arrow (←) => ((↑) -> (→)) -> ((←) (↑) (→))  try this in your ghci
19:37:45 <ksf> works flawlessly. *my terminal* is perfectly capable of outputting utf8.
19:37:46 <djahandarie> ↑↑↓↓←→←→BA
19:38:30 <ksf> ...it's just that my locale is POSIX.
19:38:32 <monochrom> also Arrow a => (α -> ɑ) -> a α ɑ
19:38:37 <ksf> ...as it's supposed to be.
19:39:34 <monochrom> posix locale is the best thing since sliced ascii locale
19:39:46 <ksf> I should probably set CTYPE to some utf8 thing, but that's not the point, the point is that ghc's io layer prefers to crash instead of just defaulting to utf8 when it sees non-ascii bytes.
19:40:31 <monochrom> defaulting to utf8 angers some other people
19:40:32 <ksf> *especially* when the locale is posix.
19:40:52 <ksf> it'd be a different thing if the locale is a destinctinctly non-ascii non-utf8 locale.
19:42:20 <AfC> Now if they could just get λ working for lamda functions.
19:42:36 <ksf> doesn't it?
19:42:41 <ksf> sure you're using the right lambda?
19:42:50 <c_wraith> djahandarie had 30 lives now.  unfortunately for him, even 30 lives is really hard to make it through the game with
19:43:06 <ksf> if then it's gotta be the math symbol, the greek lower letter is an alphabetical character.
19:43:08 <ddarius> AfC: Why have something complicated like λ, why not have l be the replacement for \?
19:43:21 <ksf> l is a letter, too.
19:43:49 <ksf> > map isAlpha "λl"
19:43:49 <lambdabot>   [True,True]
19:44:04 * monochrom suggests ^ replace \
19:44:16 <augur> monochrom: you curryist you
19:44:20 <AfC> ksf: rumour has it that the people who work on Haskell compilers are really smart. Surely they can figure out the special case to make (λ x → doSuff x) work
19:44:28 <augur> i bet you'd really prefer a carat superscript replace ^!
19:44:31 * ddarius recommends using ^ and a combining character.
19:44:45 <djahandarie> AfC, it already works with an extension, and no one uses it because it's retarded.
19:45:30 <augur> ô.o
19:46:43 <AfC> djahandarie: http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/syntax-extns.html doesn't show λ as being a replacement for \
19:46:51 <ksf> > map isAlpha "λλ𝛌𝜆𝝀𝝺𝞴"
19:46:52 <lambdabot>   [True,True,True,True,True,True,True]
19:46:54 <ksf> damn.
19:47:09 <ddarius> ksf: Better luck next time.
19:47:10 <JoeyA> > map ord "λλ𝛌𝜆𝝀𝝺𝞴"
19:47:11 <lambdabot>   [955,955,120524,120582,120640,120698,120756]
19:47:23 <JoeyA> > map (printf "%x") "λλ𝛌𝜆𝝀𝝺𝞴"
19:47:23 <lambdabot>   Ambiguous type variable `b' in the constraints:
19:47:23 <lambdabot>    `GHC.Show.Show b'
19:47:23 <lambdabot>      a...
19:47:29 <JoeyA> > map (printf "%x") "λλ𝛌𝜆𝝀𝝺𝞴" :: [String]
19:47:30 <lambdabot>   ["3bb","3bb","1d6cc","1d706","1d740","1d77a","1d7b4"]
19:47:56 <ksf> > isAlpha '∧'
19:47:57 <lambdabot>   False
19:48:06 <AfC> ksf: like I said, surely a special case would be in order. After all, they can handle the letter w in "where" so surely they can figure out how to parse the letter λ as in \ :/
19:48:10 <djahandarie> AfC, oh, my mistake then. That was the extension I was thinking of.
19:48:25 <ksf> well, yes.
19:48:32 <djahandarie> (I hold that the entire extension is stupid.)
19:48:34 <ddarius> I mean really, no one writes code like \x -> x
19:48:35 <ksf> just make the thing a reserved word.
19:48:46 <AfC> ksf: exactly
19:49:25 <ksf> and what about all those people wanting to use greek single-letter variables?
19:49:26 <monochrom> then linear algebra people can't use λ for eigenvalues
19:49:31 <djahandarie> AfC, you can always make emacs automatically display unicode symbols instead of the ascii ones.
19:49:41 <AfC> djahandarie: oh, horrors
19:49:56 <djahandarie> Better than actually having unicode in the file, imo.
19:50:02 <ksf> yep.
19:50:14 <ddarius> djahandarie: Why piss off no one when you can piss off everyone?
19:50:31 <ksf> and if you really want unicode, lobby until you get "MATHEMATICAL SYMBOL LAMBDA" passed, that isn't a letter.
19:50:36 <AfC> Uh, guys? It's 2011. We've had unicode safe source code in computer programming languages for bloody years
19:51:01 <djahandarie> AfC, sure. But I'm not greek, and I don't want greek symbols in my damn code.
19:51:06 <ksf> AfC, using unicode in your source is a sure way to scare off contributors.
19:51:07 <AfC> ksf: that would certainly help, I grant you, but as you say it's not hard to make a reserved word out of λ
19:52:00 * ksf doesn't see the symbols anymore, anyway.
19:52:09 <AfC> djahandarie: sure, but meanwhile \ is overloaded as character escape, lamda declaration, and whitespace skipper.
19:52:16 <AfC> djahandarie: it's *messy* and inconsistent.
19:52:31 <ksf> that's in entirely different places.
19:52:35 <djahandarie> Hasn't caused me any problems.
19:52:39 <ddarius> AfC: You have a hard time realizing whether you are in a string or not?
19:52:51 <drdo> The people demand pretty λ
19:52:52 <monochrom> then again "forall" is overloaded as forall and exists :)
19:53:07 <ddarius> No it isn't.
19:53:36 <AfC> (have to go for a meeting, lovely chatting, not meaning to drop out in the middle of a discussion)
19:53:49 <ddarius> . is the thing that is massively overloaded.
19:54:00 <siracusa> AfC: The GHC sources are available online, feel free to hack them and compile your own GHC that makes λ a reserved keyword :-P
19:54:01 <ddarius> There's a discussion?
19:54:09 <ksf> AfC, if you care about pretty code, hack on yi. to be precise, hack up a mode in which all code you're not actively editing is displayed with lhs2tex
19:54:15 <drdo> Can someone point me to an example explaining how lazy IO is bad? I keep hearing about it but i still don't understand why
19:54:16 <ddarius> Because I always write: letx=xinx
19:54:57 <ddarius> do s <- hGetContents h; hClose h; print s
19:55:00 <AfC> drdo: look for Oleg's slides where he introduced Interatees. There's a version annotated with comments & explaination
19:55:24 <drdo> IterateeIO-talk-notes.pdf ?
19:55:35 <augur> ddarius: do you know of any nice discussions of various recursion schemes and what sorts of problems can be solved with them?
19:55:40 <augur> and how they relate?
19:55:50 <ksf> mapM hOpen =<<  lines <$> hGetContents f
19:56:19 <ddarius> @google recursion schemes from comonads
19:56:21 <lambdabot> http://www.fing.edu.uy/~pardo/papers/njc01.ps.gz
19:56:29 <ddarius> Then forget about such filth.
19:57:02 <ksf> the most severe problem is really handles: not closing them early, closing them early enough as not to run out of them.
19:57:03 <augur> infact i have that open currently!
19:57:22 <augur> but i mean, im more curious about like... what _must_ be expressed as this or that kind of scheme, etc.
19:57:41 <drdo> ksf: Don't they just get closed when you reach them or there's an error?
19:57:47 <drdo> *reach the end
19:57:49 <ddarius> Almost nothing, which that paper already vaguely suggests.
19:58:21 <drdo> and you need to keep the handle around anyway to do output
19:58:29 <ksf> I think they do. the whole thing is not really problematic if all you do is read a single file.
19:58:44 <drdo> I'm writing a bittorrent client and i don't see the problem
19:58:51 <augur> ddarius: wait what
19:59:09 <ksf> oh, you will. you will need a gazillion of handles, and those are a limited ressource.
19:59:19 <ksf> also, there already is a bittorrent client in haskell.
19:59:31 <ksf> could use some love
19:59:34 <drdo> ksf: How do iteratees suddenly make handles disappear?
19:59:57 <ksf> they allow you to precisely control the lifetime of each handle.
20:00:27 <drdo> And lazy IO doesn't why?
20:01:04 <lpsmith> drdo:  another http://hpaste.org/55758
20:01:04 <ksf> well, you could close the handle early. that would silently make hGetContents return less bytes than expected.
20:01:28 <cl1> is there a sort function on lists that takes the method that does the sorting?
20:01:35 <ksf> or you could leak handles because you're not forcing enough of what hGetContents returns to ever make it close the handle.
20:01:45 <lpsmith> cl1, sortBy
20:01:55 <cl1> lpsmith, thanks
20:01:56 <drdo> ksf: I can't leak handles, i need the handles for output
20:02:42 <lpsmith> cl1, you might also find (nub)sortOn useful:  http://hackage.haskell.org/packages/archive/data-ordlist/0.4.4/doc/html/Data-List-Ordered.html#v:sort
20:03:00 <ksf> drdo, it surely is possible to write lazy IO code that works, and doesn't leak.
20:03:21 <ksf> ...but it's as with unsafePerformIO, you're playing with a shotgun.
20:04:04 <cl1> lpsmith, don't have Ord implemented
20:04:07 <drdo> ksf: This is why i don't understand the problem, i'm getting these "*hand-wave*, everything will stop working, you are the devil" arguments
20:04:39 <ksf> drdo, well, all I can reliably say is: when it *does* stop working, which it just might, then you're going to have a hard time.
20:10:20 <lpsmith> drdo, you should try my example
20:10:20 <augur> ddarius: ?
20:10:20 <lpsmith> it works by the way if you use a different filename
20:10:20 <ksf> drdo, also, http://www.haskell.org/pipermail/haskell/2009-March/021064.html
20:10:20 <drdo> lpsmith: Your example is not a real example
20:10:20 <lpsmith> yes it is
20:10:20 <lpsmith> I've run into that exact problem
20:10:20 <lpsmith> I mean, the program was a little more complicated,  but that distills the essence
20:10:20 <drdo> I can show you an example where anything at all does something bad
20:10:20 <drdo> does that mean everything is bad?
20:10:20 <ddarius> lpsmith: This is a common pattern for drdo.
20:10:20 <ksf> drdo, the question is: do you rather spend some time figuring out how to efficiently do strict IO, or do you want to risk wasting away hours debugging your lazy code?
20:10:20 <lpsmith> drdo, experience has shown lazy IO tends to be more trouble than it's worth.  Bad resource consumption,  space leaks,  semantic traps...  ddarius's example is another very good one.
20:10:20 <drdo> ksf: I'm all for writing nice code, but i really don't see where the problem is in my particular application
20:10:20 <drdo> I understand there might be a problem if all you are doing is input
20:10:20 <drdo> But in a situation where you need to keep the handle around for output anyway...
20:11:13 <ksf> drdo, how do you intend to do handle-specific bandwidth metering and timeouts with lazy IO?
20:12:11 <ksf> ...and you need to do that, because you've got to rate peers depending on what they send you so you can properly split your upload bandwidth.
20:13:04 <ksf> ...you can write a client without that, but it's going to *suck* at downloading.
20:13:19 * ddarius kicks the spirit of Christmas past in the face.
20:13:38 <ddarius> in victorious defiance if that wasn't clear
20:14:23 <ddarius> ksf: Just let drdo go an his own and take pleasure in his torment.
20:14:28 <drdo> By measuring how much time it takes to get a piece
20:14:45 <ksf> drdo, that said, definitely have a look at combinatorrent. it's quite erlangy
20:14:57 <ksf> yes. and for that you need the io monad.
20:15:01 <ddarius> Especially the Erlang version of combinatorrent.
20:15:08 <drdo> yes i do
20:15:38 <ksf> ...well, just try.
20:15:56 <ksf> probably going to teach more than anything we could say.
20:16:22 <drdo> I started learning about iteratees but it's not clear to me what the problem even is so i'm having trouble finding the motivation
20:16:41 <ddarius> Vaya con Dios
20:17:55 <ksf> the problem, at its heart, is that lazy IO removes the possibility to control when side-effects take place.
20:18:28 <monochrom> a blog article that shows your approach simpler then the iteratee approach is the motivation
20:18:42 <ksf> even if your code works, semantically, it may still leak memory like a sieve all the time.
20:19:27 <ksf> ...because you're reading and reading bytes without ever processing them. or even overflowing the network input buffer.
20:20:21 <ksf> sucking bytes out of a handle is easy, sucking results out of a pure computation and making sure *that* is sucking enough bytes out of the handle is another matter.
20:20:34 <ksf> possible, yes, but very likely nasty to get right.
20:20:56 <drdo> I'm just using lazy IO for convinience really, i never leave the IO monad
20:20:59 <dolio> I don't recall memory leaks being the problem.
20:21:04 <drdo> only the parsing code is pure
20:21:34 <dolio> Unless you need to run two passes over a list, which is unrelated to lazy I/O.
20:22:22 <drdo> the parser parses the lazy bytestring and gives me back a message and the rest of the bytestring
20:22:33 <drdo> that's all i'm doing really
20:22:49 <ddarius> drdo: Just go do it.  Why are you talking to us?
20:23:06 <drdo> ddarius: I have been warned there may be dragons
20:23:25 <dolio> Lazy I/O works fine when you're doing really simple stuff.
20:23:30 <ddarius> drdo: You apparently don't care.  Do you want someone to write your program for you?
20:23:46 <drdo> ddarius: Are you serious?
20:23:47 <dolio> Or, the right kind of simple stuff.
20:23:49 <monochrom> St. George had been warned about dragons, too. He killed the dragon and blogged about it. And got sainted.
20:23:59 * djahandarie hums "you're a mean one, mr. grinch"
20:24:09 <drdo> I'm trying to understand what the problem is
20:24:31 <monochrom> I made up the part about blogging.
20:24:47 <dolio> They didn't have blogs back then?
20:24:50 <dolio> In the dragon age?
20:24:56 <ddarius> drdo: Apparently you'll only agree that there is a problem if someone shows that it will be a problem on the exact program you're going to write.  I'm suggesting you write that program.
20:25:13 <ddarius> dolio: What are you talking about?  Blogs are older than Jesus.
20:25:18 <monochrom> their blog sites were broken because the dragon ate the cables
20:25:39 <dolio> I think you're thinking of zines.
20:25:42 <ddarius> BCE, Blogs Came Erste
20:26:04 * hackagebot pqc 0.3 - Parallel batch driver for QuickCheck  http://hackage.haskell.org/package/pqc-0.3 (KidoTakahiro)
20:26:46 <monochrom> the dragon also ate the pigeons (the backup communication links)
20:26:54 <dolio> drdo: One problem people have is that they lazily read in hundreds of files in series, but don't use all of each one.
20:27:06 <dolio> Then they run out of file descriptors before the garbage collector can close the handles.
20:27:23 <dolio> Iteratees make sure each file gets processed and closed in turn.
20:27:49 <dolio> With a better interface than getLine and such.
20:28:59 <ksf> I still think drdo's problem will be input buffer overflows.
20:29:43 <ksf> with lazy IO, there's no epoll and subsequent reading going on, but hoping that stuff will be forced in time.
20:30:15 <dolio> At least, supposedly a better interface. The articles people write on this stuff are never particularly convincing on that end, and I haven't written anything that really needs iteratees yet, so I don't have a lot of experience with the APIs out there.
20:30:57 <ksf> drdo, anyhow, if you only use lazy IO in a tiny part or your code and that already exists, move on. more important than having bug-free code is the ability to replace it with bug-free code without reengineering everything.
20:31:15 <augur> ddarius: ?
20:32:24 <drdo> ksf: I'm always happy to learn about better ways to do stuff
20:39:05 <monochrom> here be dragon: http://www.ikea.com/ca/en/catalog/products/80197535/
20:39:32 <dolio> Good at hugging?
20:41:20 <dolio> That reminds me, this was amusing me on my flight a few days ago: http://www.skymall.com/shopping/zoom.htm?pid=204072606&ddi=/products/e6/29/0c/204072606gx1.jpg
20:41:32 <Goosey> Where is lambdabot?
20:42:00 <dolio> He's got a look that says: 'ah yes! Now I'm experiencing the internet!'
20:42:13 <dolio> Thanks to these SkyMall computer glasses.
20:42:35 <dolio> Vacation.
20:43:28 <ksf> the encoding stuff is nasty, btw. if there were a version of readProcess that just returned a bytestring...
20:43:48 <ksf> ...I could explicitely utf8-decode that thing.
20:45:53 <b7j0c> i have a small haskell program to read the local dictionary file into memcache: https://gist.github.com/1522774 . can someone take a look at that link (its a very short program) and help me explain why even when compiled with -O2, it takes three times as long as a perl script to do the same task?
20:46:38 <b7j0c> i tried switching between strict and lazy bytestrings, did not seem to make a difference
20:48:15 <ksf> gggnah. readProcess first hGetContents the output, *then spawns a thread forcing the output*, then writes the stdin, then takes an mvar that's putted at the end of the thread. then waits for the program to terminate.
20:48:43 <ksf> ...this is just the thing iteratees are made for.
20:50:53 <monochrom> http://www.vex.net/~trebla/tmp/dragon.jpg  hehehe!
20:52:54 <ksf> b7j0c, your code looks fine for me, the culprit could be the memcache bindings.
20:53:04 <ksf> a profile will tell you more.
20:53:20 <b7j0c> thats what i thought too...it actually blew up periodically also. bummer :(
20:53:48 <ksf> it shouldn't blow up with lazy bytestrings.
20:53:54 <shachaf> b7j0c: You could try memcached bindings that write ByteStrings rather than Strings.
20:54:21 <b7j0c> no i mean it actually seemed to mangle its connections to memcache, fatally
20:54:57 <shachaf> b7j0c: Switching your program to use mapM_ instead of mapM seems to cut its runtime significantly
20:55:14 * shachaf is not running a very thorough benchmark or anything, though.
20:55:20 <b7j0c> oh thats cool. any idea why?
20:55:29 <ksf> oh, yes, it's constructing the whole list.
20:55:50 <shachaf> It has to make this huge list of Bools.
20:55:51 <ksf> b7j0c, you're allocating a list the length of the wordfile.
20:56:04 <shachaf> Well, the number of words in the file.
20:57:11 <b7j0c> hmm, okay, thats interesting. AH. okay i see the difference between sequence and sequence_
20:57:14 <ksf> b7j0c, try sets <- fmap all ( mapM ....  ; print sets
20:57:46 <ksf> though that may not work. depends on how smart ghc is by now.
20:57:51 <b7j0c> hmm okay thats also a good suggestion ksf
20:58:02 <ksf> ...but that way you're not right-out telling ghc to keep the list around.
20:58:28 <b7j0c> man i wish this wasn't so mind-bending, the perl version took three minutes to write and just crushes the haskell version :(
20:58:29 <ksf> if in doubt, write a custom monadic fold.
20:58:51 <b7j0c> mind you, chugging through files is its strength to be fair
20:58:52 <shachaf> b7j0c: Is the Perl version constructing a huge list?
20:59:04 <ksf> easiest way is to give setword a third argument and replace mapM with foldM
20:59:21 <b7j0c> no, i didn't think that was the part of the code that was crippling it
20:59:24 <ksf> ...returning the accumulated boolean each call.
20:59:36 <b7j0c> i guess i could take out the check
21:00:02 <ksf> oh, (== True) == id
21:00:26 <b7j0c> okay, well these are some great suggestions! thanks a lot folks!
21:00:35 <shachaf> ksf: And "all id" == and.
21:00:37 <ksf> @test \x -> (== True) x == id x
21:00:48 <ksf> @bot
21:00:58 <c_wraith> isn't that command @check, anyway?
21:01:04 <c_wraith> ... when the bot's alive
21:01:07 <ksf> @check \x -> (== True) x == id x
21:01:24 <c_wraith> but yeah, lambdabot appears to have gone on holiday
21:01:32 <c_wraith> Cale, you around to bring her back?
21:01:58 <b7j0c> WHOAH. mapM_ really is the trick
21:02:16 <b7j0c> now perl is in second place :)
21:02:26 <ksf> yeah, but that makes you lose the final boolean.
21:02:35 <b7j0c> no biggie
21:02:37 <shachaf> You can use an IORef or something ugly like that instead of and <$> the list.
21:02:43 <shachaf> It stays just as fast (I just tried it).
21:02:49 * ksf slaps shachaf
21:03:00 <shachaf> Presumably you can do the same thing with a nice monadic fold like ksf said.
21:03:32 <parcs`> b7j0c: what are the run-time numbers now, btw?
21:03:54 <b7j0c> haskell, compiled, went from 18 secs wall-clock time to 2.5
21:04:00 <ksf> foldM (setword conn) True words
21:04:01 <b7j0c> perl was about 5
21:04:33 <b7j0c> this is on a 2009 macbook pro running ubuntu
21:04:34 <ksf> and then setword conn word res = ... whatever ... return (success && res)
21:04:52 <shachaf> ksf: I think it's nicer to leave setword as it is and wrap something else around it to do the folding.
21:05:09 <ksf> WriterT.
21:05:17 <shachaf> Well, there's WriterT.
21:05:32 <shachaf> You could "tell" each word as it fails instead of printing it straight in setword (which is ugly).
21:05:50 <shachaf> That's a good thing to do regardless, unless there's a large number of failures or something.
21:05:53 <Cale> b7j0c: also make sure you're compiling with -O or -O2
21:06:10 <b7j0c> yes Cale i am
21:06:15 <b7j0c> but thanks for the reminder
21:06:17 <Cale> okay :)
21:06:33 <ksf> it's not really a surprise that haskell is faster than perl, though.
21:06:41 <ksf> perl being interpreted and all.
21:07:12 <b7j0c> true, but props to perl in that the naive, unexplored, unoptimized version was decently performing. and it also beat the racket solution i wrote
21:07:14 <Cale> Compiling without optimizations will still be likely faster than ghci's bytecode interepretation, but can easily be orders of magnitude (or even asymptotically) slower than compiled code.
21:07:14 <shachaf> It's still doing all this ByteString->String->ByteString conversion.
21:07:20 <Cale> er, optimized code*
21:07:28 <shachaf> By the way, you should be using encodeUTF8 or something, rather than Char8.pack. Char8 is evil.
21:07:40 <b7j0c> oh, okay, that is new to me
21:07:53 <b7j0c> i will look into encodeUTF8
21:08:04 <ksf> ...you can just use the String version of readFile
21:08:12 <shachaf> What ksf says is also true.
21:08:14 <ksf> or rather hGetContents, in this case.
21:08:19 <shachaf> The point is mainly not to use Char8.
21:08:30 <mm_freak> i got a function that looks like an unzip:  Input (a, b) -> (Input a, Input b)
21:08:30 <b7j0c> that is what i had previously, but then mistakingly believed it might have been the root of the issues
21:08:38 <mm_freak> is "unzip" the name of this generic pattern?
21:09:02 <mm_freak> the Input type is not a list type…  is simply wraps a value with some additional information
21:09:36 <ksf> looks like distributivity to me.
21:09:45 <shachaf> @hoogle (r -> (a,b)) -> (r -> a, r -> b)
21:09:45 <lambdabot> No results found
21:09:55 <shachaf> Hmm.
21:10:00 <mm_freak> ksf: "distributeInput" doesn't sound very useful
21:10:09 <mm_freak> currently i call it splitInput
21:10:31 <Axman6> @djinn (r -> (a,b)) -> (r -> a, r -> b)
21:10:31 <lambdabot> f a =
21:10:31 <lambdabot>     (\ b ->
21:10:31 <lambdabot>      case a b of
21:10:31 <lambdabot>      (c, _) -> c,
21:10:31 <lambdabot>      \ d ->
21:10:33 <lambdabot>      case a d of
21:10:35 <lambdabot>      (_, e) -> e)
21:10:52 <mm_freak> @hoogle F (a, b) -> (F a, F b)
21:10:52 <lambdabot> Warning: Unknown type F
21:10:52 <lambdabot> No results found
21:10:55 <Axman6> that's mighty ugly...
21:11:00 <ksf> @hoogle (f (a,b)) -> (f a, f b)
21:11:00 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
21:11:00 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
21:11:01 <mm_freak> @hoogle f (a, b) -> (f a, f b)
21:11:01 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
21:11:02 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
21:11:13 <mm_freak> ok, nevermind
21:12:01 <ksf> @hoogle (f (g a b) -> g (f a, f b)
21:12:01 <lambdabot> Parse error:
21:12:01 <lambdabot>   (f (g a b) -> g (f a, f b)
21:12:01 <lambdabot>   ^
21:12:07 <ksf> @hoogle f (g a b) -> g (f a, f b)
21:12:07 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
21:12:07 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
21:12:07 <lambdabot> Data.Either partitionEithers :: [Either a b] -> ([a], [b])
21:12:44 <ksf> Either == (,)? hoogle constantly teaches me new things.
21:14:13 <ksf> @hoogle f (g a b) -> g (f a) (f b)
21:14:13 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
21:14:13 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
21:14:14 <ksf> doh.
21:14:23 <Axman6> so, um, how do you use Data.Binary with 7.2.1? It seems to be hidden...
21:14:58 <ksf> maybe it's pre-packaged but not supposed to be pre-packaged?
21:15:38 <Axman6> hmm, possibly. maybe that's something that got fixed in a later GHC
21:15:40 <shachaf> @let іd (Left x) = (x,undefined); і (Right y) = (undefined,y)
21:15:41 <lambdabot>  Defined.
21:15:48 <shachaf> @undefine
21:15:51 <shachaf> @let іd (Left x) = (x,undefined); іd (Right y) = (undefined,y)
21:15:52 <lambdabot>  Defined.
21:16:22 <ksf> isomorphic up to evaluation.
21:17:43 * ddarius read git reflog as git re-flog
21:27:40 <mm_freak> when i write a function (f . Left), where 'f' immediately pattern-matches on its argument, is it likely that GHC optimizes this pattern match away?
21:28:03 <c_wraith> probably not
21:28:23 <c_wraith> all the various fusion systems are about making sure GHC does that optimization
21:28:32 <ddarius> c_wraith: No.
21:28:47 <c_wraith> well, the list fusion optimizations are
21:29:02 <ddarius> c_wraith: The foldr/build only applys to, well, foldr/build.
21:29:12 <ddarius> (there's also unfoldr/destroy)
21:29:16 <Axman6> i believe that's different to fusion
21:29:42 <ddarius> Stream fusion relies on GHC doing things like the above and arranges things so that GHC will have easy optimization problems like that.
21:29:47 <ddarius> Where easy = non-recursive.
21:30:23 <mm_freak> is there a somewhat clean way to make sure that it does?
21:30:38 <ddarius> mm_freak: By not worrying about it.
21:30:42 <c_wraith> well, obviously, you shouldn't take my word for this, and should test it.
21:30:43 <ddarius> You can check the core.
21:30:51 <c_wraith> yeah, the core is the only way to be sure
21:30:58 <mm_freak> ddarius: well, i'm worried because my application is performance-critical
21:31:41 <ddarius> mm_freak: If you don't know the answer to this question from heart, then this is very likely not the code you need to worry about.
21:33:07 <mm_freak> ddarius: usually i wouldn't care, because usually the code runs just fast enough, but in this particular case i'm expecting thousands to millions of these pattern matches each second, so now i'm worried about performance
21:35:03 <ddarius> A million per second still gives you 1000 cycles to play with, and if it is allocating (which it won't be because of this) it will be in cache.  The only worry then would be the branch prediction.
21:35:24 <ddarius> At any rate, that missed the point of my previous statement.
21:35:30 <mm_freak> right…  i'll just try
21:36:05 <mm_freak> i asked because if it won't perform fast enough, i'll have to rewrite lots of code
21:36:21 <mm_freak> but your last argument is convincing
21:37:18 <mm_freak> how is pattern matching actually implemented?  just an indexed table lookup i guess?
21:37:26 <word101> @pl \x -> f . g . h (i x)
21:37:27 <lambdabot> ((f . g) .) . h . i
21:37:37 <ksf> mm_freak, just a switch.
21:37:39 <mm_freak> (per constructor)
21:37:53 <mm_freak> ksf: what kind of "switch"?  if it's a C switch, that'
21:37:55 <mm_freak> 's bad
21:37:56 <ksf> also, why write (f . Left) and (f. Right) when you can write l and r ?
21:38:11 <ksf> why? it's constant time.
21:38:36 <mm_freak> ksf: because 'f' is complicated, and i'd like not to write two versions of it…  also i'm expecting to replace Either by a type with more constructors
21:39:01 <mm_freak> a C switch is constant time?
21:39:04 <ksf> well, then write l = f . Left and voila, your code is easily fixable should it hit the fan.
21:39:10 <ksf> of course.
21:39:22 <ksf> either a computed jump or table lookup.
21:39:36 <word101> thank you @pl
21:39:39 <ksf> ...and constructor ids are all adjacent.
21:39:44 <mm_freak> ksf: it's not a style question, but a performance question…  performancewise there is no difference between "l x" and "f . Left $ x"
21:40:40 <ksf> well, but *if* you need to change f . Left  into l because of performance issues, you'll be glad to already have written your code like that.
21:40:54 <ksf> always optimise code evolvability.
21:41:11 <mm_freak> good point
21:43:56 <ddarius> For a small number of constructors it does essentially an if branch on a tag, otherwise it does an indirect jump.
21:48:54 <cl1> i'm doing this stupid graham scan algo, if i have a line with slope zero, then how would i figure out if i need to return need to return 1.0 (cos 0) or -1.0 (cos pi) ?
21:49:26 <cl1> i guess if x2 < x1 then -1 else 1 ?
21:49:58 <ksf> If I'm guessing right what it's about then your guess is right.
21:51:04 * hackagebot todos 0.5.2 - Easy-to-use TODOs manager.  http://hackage.haskell.org/package/todos-0.5.2 (IlyaPortnov)
21:51:19 <ksf> another possibility might be to sort x1 and x2 first.
21:51:56 <ksf> ...that is, switch them if they're the wrong way round.
21:53:29 <cl1> ksf .. i know that the order of points is correct and returning 1.0 or -1.0 is important
21:54:26 <cl1> i'm doing exercise #12 on this page http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html
21:54:37 <ksf> well, if your start point can't be to the right of the end point, you can hardcode 1.
21:54:40 <cl1> it is kicking my ass up and down the street. I have not done trig in 18 years
21:54:57 <cl1> ksf .. it can
21:55:13 <ksf> well, then switch them if they're the wrong way around.
21:55:16 <cl1> but if x2 < x1 then i'll know the order and can return the proper answer
21:55:32 <cl1> ksf .. they aren't the wrong way around
21:55:37 <ksf> lines' dont care about whether you draw them start to end or end or start.
21:55:57 <cl1> no but the orientation in realtion to the start point matters
21:55:58 <ksf> ...I'm just saying that switching points beforehand might make the algorithm simpler.
21:56:07 <cl1> it won't
21:56:29 <mm_freak> related question:  if my type is a newtype (such as Kleisli), does constructing immediately followed by pattern matching involve overhead?  intuitively i'd say no, but in more complicated scenarios it seems to make a difference
21:56:42 <ksf> oh, I was thinking of completely different things.
21:56:51 <mm_freak> particularly the GLdouble type from the OpenGL library, which is a newtype of CDouble, is slower than CDouble
21:57:19 <ddarius> mm_freak: There are probably RULES that are failing to fire due to the type.
21:57:23 <mm_freak> and not just a little but, but realToFrac from CDouble to CDouble is 40 times faster than realToFrac from GLdouble to GLdouble
21:57:44 <mm_freak> ddarius: assuming there are no rules, should it be the same?
21:57:50 <mm_freak> (the performance)
21:58:28 <c_wraith> cl1: graham scan doesn't need to calculate actual angles.
21:58:36 <ddarius> Newtype constructors become id essentially fairly early.  If you do something like map NewType xs, it will become map id xs which won't be optimized to just xs.
21:58:58 <mm_freak> ddarius: ah, good to know
21:59:08 <c_wraith> cl1: cross products of vectors is sufficient
21:59:21 * ddarius retches on the cross product.
21:59:39 <mm_freak> i always assumed that newtype constructors get optimized away completely and only non-firing RULES remain
22:00:19 <mm_freak> but yeah, that explains my factor 40 slowdown in my particular benchmark
22:00:26 <c_wraith> mm_freak: they can, but not always.  What happens when you map a newtype constructor over a list?
22:00:52 <mm_freak> c_wraith: according to ddarius that becomes map id
22:01:04 <c_wraith> mm_freak: yep
22:01:14 <ksf> hopefully, there's a rule saying map id == id
22:01:25 <c_wraith> I'm not sure there actually is such a rule
22:01:30 <ksf> ...at the right stage of the compiler.
22:02:00 <mm_freak> i don't see why you can't just produce the same code for newtypes?  after all only the dictionary changes
22:02:08 <ksf> it might be easier for the compiler to fuse the map.
22:02:37 <c_wraith> yeah, if the map gets fused, it's almost certain the (id .) or (. id) will get RULEd out
22:02:59 <mm_freak> c_wraith: if you can calculate the number of them at compile time
22:03:10 <mm_freak> getLine >>= map id
22:03:14 <mm_freak> uhm
22:03:19 <mm_freak> fmap (map id) getLine
22:03:27 <ddarius> c_wraith: It would just get optimized out.  There wouldn't be a RULE for that.
22:03:37 <c_wraith> oh, right, the simplifier picks up that one
22:03:58 <mm_freak> i'd think that it gets optimized to fmap id getLine right away, which in turn gets optimized to getLine
22:03:58 <c_wraith> ...  though as ghc 7.4 shows, the simplifier has some bizarre restrictions now.
22:04:16 * ski thinks `newtype k (Foo a b) = CxtFoo (k (..a..b..))' could be helpful for `map MkNewType' situations ..
22:04:38 <ddarius> ski and his crazy ideas.
22:04:51 * ski concurs
22:05:04 <ksf> did you just pattern-match on a type, there?
22:05:10 <ski> no
22:05:49 <ski> the type of the data constructor `CxtFoo' is supposed to be `forall k a b. k (..a..b..) -> k (Foo a b)'
22:06:04 * hackagebot yaml-rpc 0.3.1 - Simple library for network (TCP/IP) YAML RPC  http://hackage.haskell.org/package/yaml-rpc-0.3.1 (IlyaPortnov)
22:06:48 <ksf> newtype k a b = CxtFoo (k (Foo a b)) ?
22:06:49 <cl1> c_wraith, i'm not calculating angles, i'm ordering the points
22:07:01 <cl1> at least not yet
22:07:04 <c_wraith> cl1: you don't need to use trig for that, either
22:07:23 <ski> e.g. `newtype k (Flip f a b) = CxtFlip (f b a)' will get `CxtFlip :: forall_kind k0 k1 k2. forall (k :: k2 -> *) (f :: k1 -> k0 -> k2) (a :: k0) (b :: k1). k (f b a) -> k (Flip f a b)'
22:07:26 <cl1> c_wraith, i have to know trig to know that adj/hyp = cos a
22:07:27 <ksf> c1de0x, http://en.wikipedia.org/wiki/Graham_scan#Pseudocode
22:07:27 * ddarius recommends never using trigonometry.
22:07:31 <ksf> ccw. that function. use it.
22:07:42 <ski> ksf : that `newtype k a b = CxtFoo (k (Foo a b))' would be invalid
22:07:53 <c1de0x> ksf:?
22:07:54 <ski> (no type being defined)
22:08:05 <ksf> cl1, not c1de0x
22:08:07 <ksf> sorry
22:08:09 <c_wraith> cl1: you need to *know* trig, sure.  you don't need to *use* it.
22:08:13 <c1de0x> oh. nm then
22:09:12 <cl1> c_wraith, yes, and my trig is quite rusty. that's why i was asking the question to be sure I remembered correctly
22:09:20 <ski> an extension like this would need some consistency checks, to make sure the type variable `k' here really has an arbitrary domain
22:09:34 <ski> (otherwise it wouldn't be sound)
22:09:37 <ksf> ski, your pattern matching on a type isn't any more valid.
22:09:56 <ski> i'm not pattern-matching on a type at all
22:10:10 <ksf> well, you're using a constructor where only variables can be.
22:10:18 <ksf> that's pattern matching on the type level.
22:10:33 <ski> well, this is a (vague) suggestion for extension
22:10:44 <cl1> c_wraith, not that I don't appreciate the advice, just letting you know i understand all of what you are saying :)
22:10:53 <ski> if i was saying `newtype Foo (Bar a) ... = ...', *then* i'd be pattern-matching
22:10:56 <ksf> ski, what about a data family?
22:11:19 <ski> but just saying `newtype k (Foo a b) = ...' is just reifying the (type-level) continuation
22:11:44 <ski> and that's why we need to have checks on that continuation, to make sure we don't introduce "type-level continuation side-effects)
22:11:54 <word101> @pl (\(f x) -> x)
22:11:54 <lambdabot> (line 1, column 6):
22:11:54 <lambdabot> unexpected "x"
22:11:54 <lambdabot> expecting operator or ")"
22:12:05 <cl1> @info ccw
22:12:06 <lambdabot> ccw
22:12:24 <ksf> function ccw(p1, p2, p3):   return (p2.x - p1.x)*(p3.y - p1.y) - (p2.y - p1.y)*(p3.x - p1.x)
22:12:29 <ksf> (from the wikipedia page)
22:13:03 <ski> ksf : i think this really only make sense for `newtype's, the reason being the assumption that with type erasure, values of the new type will be represented in exactly the same way as values of the body type
22:13:10 <cl1> ksf - hoogle returned something to do with FrontFaceDirection for ccw
22:13:19 <ksf> @hoogle ccw
22:13:19 <lambdabot> Graphics.Rendering.OpenGL.GL.Colors CCW :: FrontFaceDirection
22:13:30 <ksf> well, I wasn't talking about opengl.
22:13:40 <word101> @pl \(Just x) -> x
22:13:40 <lambdabot> (line 1, column 8):
22:13:40 <lambdabot> unexpected "x"
22:13:40 <lambdabot> expecting operator or ")"
22:13:58 <ksf> :t fromJust
22:13:59 <lambdabot> forall a. Maybe a -> a
22:14:51 <ski> ksf : let's say i have `x :: Maybe (Flip (->) Int Bool)', then i should be able to say `case x of CxtFlip y -> ..y..' with `y :: Maybe (Bool -> Int)'
22:15:04 <ski> now imagine using `[]' or other stuff instead of `Maybe' here
22:15:44 <ksf> I think you can already do that.
22:16:09 <ksf> well, the -> might get problematic.
22:16:37 <word101> elemIndex returned Just Int. thanks for the info
22:16:42 <cl1> ksf - i already have that part figured out. I'm trying to sort the points before I start getting the turn direction, and I have to use the cos of the angle between the line created by the start point and the other point and the x-axis to order them
22:17:02 <cl1> s/other point/other points/
22:17:20 <cl1> i'm getting there, no worries
22:18:06 <ski> ksf : do you mean using coercions as at <http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes> ?
22:18:08 <ksf> wikipedia says "by polar angle".
22:18:26 <ski> ksf : i'm not sure why `(->)' would be problematic here
22:18:58 <ski> one potential issue is the same as with deriving equality constraints on newtypes
22:20:20 <ksf> dunno, when I'm hacking on the type level I rarely understand what ghc is doing behind my back.
22:27:53 <xil> hi. I was wondering if someone could help me understand parallel strategies and all of that, or provide me with an article explaining it. I've been doing some snooping and the best I've been able to find so far is a great article on DPH, but then I found out the implementation isn't stable yet. I've only been avoiding strategies because of a lack of information on how they work/how to use them
22:30:36 <snappy> win 42
22:31:39 <ski> win 120
22:31:49 <ski> (did i win ?)
22:34:38 <snappy> yes.
22:42:05 <shachaf> ski: I'm at 108. :-(
22:42:06 <Cale> xil: www.haskell.org/~simonmar/papers/strategies.pdf
22:42:17 <shachaf> (With 4 more in my other irssi process, though.)
22:42:56 <Cale> xil: There's also an older paper describing the previous design of the library you may want to go over which I can dig up if you want.
22:43:14 <Cale> http://www.macs.hw.ac.uk/~dsg/gph/papers/html/Strategies/strategies.html
22:43:51 <xil> Cale: oh thank you so much! =]
22:44:16 <Cale> http://hackage.haskell.org/packages/archive/parallel/3.2.0.2/doc/html/Control-Parallel-Strategies.html -- also, read the Haddock
22:45:13 <xil> not sure what Haddock refers to specifically, but I have read the doc you just linked. But I'm missing too much information to have made sense of it =/
22:47:07 <Cale> okay
22:47:29 <Cale> Haddock is the documentation generator which produces that style of documentation from the comments in the source code.
22:48:24 <xil> so when someone says "read the Haddock" are they referring to the hackage doc page like you linked, and so you were referring to the link in the same post, or the commented source, or something else?
22:48:50 <Cale> the documentation, usually :)
22:49:23 <Cale> xil: GHC 7.4 should be out soonish, and DPH is supposed to be more ready to be tried out in that version.
22:49:45 <Cale> (lots of cool new type system features are coming as well :)
22:50:08 <xil> cool. Would you recommend DPH over Strategies per se?
22:50:16 <ivanm> do we have the type context stuff to be able to do aliases of type classes?
22:50:31 <ivanm> (in 7.4)
22:51:45 <byorgey> ivanm: yes
22:51:46 <ski> shachaf : heh, and i always write the full `window' every time :)
22:51:55 <ivanm> excellent!
22:52:02 <shachaf> ski: Do you remember the numbers?
22:52:13 <shachaf> ski: I usually use /j #channel (with tab completion).
22:52:25 <ski> the lowest ones (and a few of the higher ones)
22:52:25 <mkramer> I have a [(Num -> Num -> Num)] and a [Num].  I want to do a nested loop, where I loop/map through the [(Num -> Num -> Num)], for each consecutive pair in the [Num], and return a list of the results
22:52:35 <ski> (e.g. #haskell always is number four)
22:53:11 <ski> (shachaf : most of the higher ones are old privmsg windows, though)
22:53:24 <mkramer> by the way, hi #haskell :)
22:53:44 <shachaf> ski: Only 27 channels seem to be on Freenode.
22:53:46 <ski> #haskell replies with "hi"
22:53:47 <shachaf> Oh, privmsg.
22:53:48 <hpaste> cl1 pasted “showing off my hard work” at http://hpaste.org/55759
22:54:07 <cl1> i got it all working, YAY!
22:54:24 <byorgey> @type \fs xs -> [ f x y | f <- fs, (x,y) <- zip xs (tail xs) ]  -- mkramer
22:54:25 <lambdabot> forall a t. [a -> a -> t] -> [a] -> [t]
22:54:33 <ski> shachaf : yeah, i havn't actually joined that many *channels*
22:54:54 <cl1> all the help I recieved that made this possible is much appreciated
22:55:09 <ski> mkramer : and you have one less function in the list, than inputs in the other list ?
22:55:18 <mkramer> byorgey: that's dense to me...working through it
22:55:39 <mkramer> ski: i want to apply each function in the [Num -> Num -> Num] to every pair in the [Num]
22:55:56 <byorgey> mkramer: that may not be exactly what you are looking for but hopefully it will give you some ideas.
22:56:21 <ski> mkramer : hm, each, ok
22:56:47 <byorgey> > let foo fs xs = [ f x y | f <- fs, (x,y) <- zip xs (tail xs) ] in  foo [(+), (*)] [1,2,3,4]
22:56:48 <lambdabot>   [3,5,7,2,6,12]
22:57:01 <mkramer> byorgey: so that's a list comprehension where you are pulling things out of two lists and applying them to f
22:57:06 <Axman6> mkramer: this may or may not be important, but are you sure it's [Num -> Num -> Num] and not Num a => [a -> a -> a]?
22:57:11 <ski> > [f a b | f <- [divMod,quotRem] , (a,b) <- (zip `ap` tail) [7,-7,17,-17,7]]
22:57:11 <lambdabot>   [(-1,0),(-1,10),(-1,0),(-3,4),(-1,0),(0,-7),(-1,0),(-2,-3)]
22:57:26 <ski> @quote aztec
22:57:26 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
22:57:41 <mkramer> Ahh, exactly right Axman6
22:58:10 * ski is tired, didn't even notice the `Num' thing
22:58:26 <byorgey> Num seems irrelevant anyway
22:58:33 <ski> (exactly)
22:59:00 <mkramer> it is for the problem at hand
23:00:00 <byorgey> mkramer: I just mean that what you are trying to do would apply to any types; the fact that you have numeric types is irrelevant
23:00:22 <byorgey> although it may of course be relevant to whatever else your program does.
23:00:37 <mkramer> I'm agreeing with you :)
23:00:50 <byorgey> oh, I see, right =)
23:00:51 * ski disagrees, just to be contrary
23:05:49 <xil> wow. I've read the description of how par works so many times now, but it was this sentence that triggered understanding: "We should think of par as an annotation; it merely hints to the Haskell implementation that it might be beneficial to evaluate the first argument in parallel."
23:06:31 <xil> not how it works, but what it does
23:11:01 <ksf> xil, well, the reason for that roundabout sentence is that par, denotationally, doesn't mean a thing.
23:11:28 <ksf> all results are still the same as before, all bottoms still bottoms, and all values still values.
23:11:59 <ksf> a haskell implementation not supporting threads could just do par _ x = x
23:12:53 <xil> yeah. I just had trouble understanding entirely what par did until that
23:13:26 <shachaf> ski: What are 2 and 3?
23:13:45 <xil> shachaf: ski: what are you two talking about?
23:14:29 <shachaf> We're telling jokes through a secret code.
23:14:34 <ski> 2 is NickServ, and 3 is a channel about a topic i was interested in for a while (and still is, i suppose), but which seems pretty dead (the topic, not the channel) atm
23:14:41 <xil> lol, okay
23:14:47 <shachaf> NickServ? Why is NickServ even open?
23:15:04 * shachaf tries to figure out what the topic channel is.
23:15:27 <ski> well, mostly so that i get my replies to `/msg NickServ info ...' in a single window
23:16:53 <ski> (you might have noticed i have done `/mode ski -i' -- i think for some time it was the default, before they changed it)
23:19:10 <shachaf> ski: Oh, yes.
23:19:21 <shachaf> ski: Why not put NickServ in position 80 or something?
23:19:57 <ski> then i can't reach it easily
23:20:40 * ski still wonders how to convince irssi to put the "system" tab in window 0
23:21:24 * ski suspects it needs a recompilation
23:21:34 <shachaf> ski: By "0" do you mean "10"?
23:21:41 <shachaf> (Which is the window you get to by pressing Alt-0.)
23:21:46 <ski> no, i mean `0', as in "zero"
23:21:56 <shachaf> Oh.
23:22:02 * ski has the `0' key to the left of the `1' key, on the keyboard
23:22:08 <shachaf> !
23:22:14 <shachaf> Where do you get such a keyboard?
23:22:22 <ski> i swapped the keys myself
23:22:27 <shachaf> ski++
23:22:38 <shachaf> ski: Now swap ASCII to match.
23:22:41 <xil> I use programmer's Dvorak
23:22:44 <ski> not that hard, neither on the Logitech, nor on the Model M
23:23:02 <shachaf> Wait, ASCII already matches.
23:23:02 <ski> swap ASCII ?
23:23:09 <shachaf> Never mind, I thought ASCII has 0 after 9.
23:23:26 <ski> they weren't *that* braindead ;)
23:24:06 <ski> (i know there's probably some valid reasons for having `0' after `9' -- i got too fed up, personally, about it though)
23:24:23 <kmc> > ['0'..'9']
23:24:24 <lambdabot>   "0123456789"
23:26:39 <incluye> xil: reasons programmer dvorak sucks: 7. number layout. 5. number layout. 3. number layout.
23:27:11 <kmc> jesus, i forgot about that
23:27:15 <c_wraith> sounds like it has 3 in the right spot
23:27:16 <xil> incluye: I actually love the number layout. It's really awkward to get used to, but it's sooo much more intuitive to me
23:27:29 <xil> no, 3 is where 4 is in QWERTY
23:27:55 <xil> '-' is where 1 is, so it pushes it all to the right
23:30:25 <xil> can someone help me understand weak head normal form? I've read a bit about it but the only stuff I've found is incredibly technical, and too much for me to understand as of yet
23:31:09 <kmc> an expression is in whnf if the outermost thing is not an application
23:31:15 <kmc> a constructor is in whnf; so is a lambda
23:31:16 <incluye> I'd totally use programmer dvorak if I could get a special keyboard for it
23:31:46 <xil> incluye: why do you need the special keyboard?
23:31:52 <kmc> «2+2» is not whnf, because it's an application of (+) to 2, and could be reduced immediately
23:32:17 <incluye> just for the learning probably
23:32:19 <xil> kmc: so what does it mean to "evaluate something to whnf"?
23:32:30 <xil> incluye: I left my keyboard in QWERTY, only changed the numbers
23:32:41 <incluye> :P
23:32:51 <shachaf> xil: Evaluate it until it's in WHNF.
23:32:53 <kmc> xil, evaluating an expression means applying the evaluation rules of the language
23:33:20 <kmc> such as the rules about function application and 'case'
23:33:28 <kmc> you apply these until the expression is in whnf and then you stop
23:33:59 <xil> oh until the *only* thing left is the outermost non application
23:34:16 <kmc> the only thing left is the entire expression?
23:34:23 <kmc> i mean, sure
23:34:34 <stone_> well  , it's cool
23:35:02 <kmc> if the expression is an application, you apply the beta-reduction rule
23:35:03 <xil> I'm still not following exactly, haha. Let's say I have some big functionally pure mathematical function
23:35:25 <xil> kmc: ah
23:35:51 <kmc> if it's a 'case' you evaluate the scrutinee to whnf, and then follow the appropriate pattern
23:36:06 <kmc> if it's a constructor or a lambda, you stop
23:36:17 <kmc> evaluating to whnf is important in Haskell, because it's the minimum evaluation you need to do useful pattern-matching
23:36:41 <kmc> evaluating data to whnf tells you which constructor was used
23:37:04 <xil> I see
23:37:08 <kmc> you can think of a primitive form of 'case', where the patterns are all like (C x y ...) or _, and it always evaluates the scrutinee to whnf
23:37:16 <kmc> then you can think of Haskell's 'case' as sugar for that
23:37:37 <kmc> Haskell lets you build complicated nested patterns, which could force more than one level of constructors
23:38:04 <kmc> also Haskell's 'case' doesn't force evaluation if none of the patterns need it
23:38:10 <kmc> > case undefined of _ -> ()
23:38:10 <lambdabot>   ()
23:38:53 <xil> interesting
23:40:27 <JoeyA> I have a Map k v, and I want to turn it into a Map k (Foo v), where building the Foo requires monadic activity.  Is that what traverse is for?
23:40:45 <JoeyA> (e.g. newFoo :: v -> IO (Foo v))
23:42:06 <kmc> @type Data.Traversable.traverse putStr :: M.Map Int String -> IO (M.Map Int ())
23:42:07 <lambdabot> M.Map Int String -> IO (M.Map Int ())
23:43:13 <JoeyA> I guess mapM would be more appropriate
23:43:42 <ski> @type Data.Traversable.mapM
23:43:43 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
23:43:44 <ski> @type Data.Traversable.traverse
23:43:45 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
23:44:22 <JoeyA> @type Data.Traversable.mapM putStrLn
23:44:23 <lambdabot> forall (t :: * -> *). (Data.Traversable.Traversable t) => t String -> IO (t ())
23:45:09 <ski> @instances-importing Data.Traversable Data.Map Traversable
23:45:09 <lambdabot> Map k, Maybe, []
23:45:10 <JoeyA> So traverse and mapM are theoretically equivalent, correct?
23:45:18 <ski> yeah
23:45:41 <ski> really, if `Applicative' was a superclass of `Monad', we wouldn't need `Data.Traversable.mapM'
23:45:45 <JoeyA> (the wart being that Monad doesn't imply Applicative, even though it "should")
23:46:03 <kmc> the name mapM is more evocative if uglier
23:46:13 * ski agrees
23:46:18 <kmc> nearly every function can be said to 'traverse' something ;P
23:46:29 <ski> @hoogle mapA
23:46:29 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
23:46:29 <lambdabot> Data.Traversable mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
23:46:29 <lambdabot> Data.List mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
23:46:30 <c_wraith> const traverses the void
23:46:47 <incluye> @type mapM_
23:46:48 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
23:47:07 <xil> I'm a bit confused about seq vs deepseq, because rnf sounds like deepseq but rnf is defined as flip seq ()
23:47:16 <ski> @type Data.Foldable.mapM_
23:47:16 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Foldable.Foldable t, Monad m) => (a -> m b) -> t a -> m ()
23:47:19 <ski> @type Data.Foldable.foldMap
23:47:19 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
23:47:19 <kmc> xil, it is?
23:47:27 <xil> rnf a = a `seq` ()
23:47:33 <xil> http://hackage.haskell.org/packages/archive/deepseq/latest/doc/html/Control-DeepSeq.html#t:NFData
23:47:33 <kmc> xil, that's the class default only
23:47:50 <incluye> I think it's hilarious how there are functions in the standard library called mapM and mapM_
23:47:56 <xil> oh but you're supposed to override it when you define te instance with something deeper?
23:47:59 <incluye> like "fuck it, we're out of names, just stick an underscore on"
23:47:59 <ivanm> incluye: why is that hilarious?
23:48:08 * ski isn't really happy with class defaults which are not laws
23:48:09 <ivanm> the underscore is a naming convention
23:48:14 <incluye> yeah, exactly
23:48:17 <incluye> I guess you had to be there
23:48:21 <kmc> xil "The default implementation of 'rnf' is «rnf a = a `seq` ()» which may be convenient when defining instances for data types with no unevaluated fields (e.g. enumerations)."
23:48:27 <ivanm> ski: you mean that if you override the defaults you should guarantee it has the same behaviour?
23:48:57 <ski> ivanm : yeah, i think that argument has some sense in it -- i'm not sure how practical it would be in the large, though
23:49:04 <ivanm> yeah
23:49:07 <kmc> yeah i think this is a bad default
23:49:21 <xil> kmc: right, I get that now. Didn't realize that "default" meant class default. Thought it meant "most compilers have this as the definition", which confused me. Thanks =]
23:49:32 <kmc> very easy to write «rnf a = a `seq` ()» yourself, or even «rnf !a = ()»
23:49:43 <ski> yeah, what kmc said :)
23:49:46 <kmc> and then you're explicit about it
23:50:10 <ski> (and in other cases, writing `foo = defaultFoo' is often not that terrible)
23:50:13 <kmc> instance NFData Foo where rnf !x = ()
23:50:21 <kmc> that's plausible as a single line :)
23:50:48 <ivanm> kmc: or just (`seq` ()) ;)
23:50:51 <kmc>  > let f !_ = () in f undefined
23:50:53 <kmc> > let f !_ = () in f undefined
23:50:54 <lambdabot>   *Exception: Prelude.undefined
23:51:10 <kmc> not sure how i feel about the pattern !_
23:51:27 <ski> well, it's some kind of counterpart to `~', no ?
23:51:41 <shachaf> kmc: What's wrong with it?
23:51:53 <kmc> shachaf, it looks silly and is silly
23:52:46 <c_wraith> rnf is kind of silly, when you look at it that way
23:52:56 <shachaf> kmc: Is that because what you're doing when you want to use it is silly?
23:53:14 <shachaf> I see no reason to ban the pattern !_ given the patterns ! and _.
23:53:33 <ski> (oh, missed the `_' there)
23:53:34 <kmc> me either
23:53:56 * ski . o O ( `!,fail' )
23:54:00 <kmc> "dogs are funny looking"   "WHY DO YOU WANT TO BAN DOGS, YOU MONSTER?!?!?"
23:54:10 <dolio> seq !_ x = x
23:54:27 <shachaf> kmc: Fair enough. :-)
23:54:38 <c_wraith> I pronounce !_ as a sort of emphatic silence
23:54:39 <shachaf> You can't actually write a "reduce to normal form" function in Haskell, can you?
23:55:03 <kmc> not one that works on functions
23:55:06 <c_wraith> you can for any specific algebraic data type
23:55:06 <ski> shachaf : *nod*, since you can't reduce under lambda
23:55:07 <shachaf> Right.
23:55:12 <c_wraith> but yeah, functions..
23:55:32 <kmc> you can't reduce «Maybe (Int -> Int)» even though it's an algebraic data type ;)
23:55:41 <c_wraith> It's polymorphic
23:55:45 <c_wraith> I should have said monomorphic
23:55:52 <kmc> it's not polymorphic
23:55:59 <c_wraith> well, Maybe is polymorphic
23:56:00 * ski . o O ( "you know what i meant !" -- "no i don't :/" )
23:56:01 <kmc> how about  data Foo = Foo (Int -> Int)
23:56:07 <kmc> maybe the right term is "first-order data type", *shrug*
23:56:19 <ski> `Maybe' isn't polymorphic, it is parametric
23:56:26 <c_wraith> err, so it is
23:56:32 <ski> (`Maybe' has a simple monomorphic kind, tyvm)
23:56:40 <kmc> but that Foo is neither
23:56:50 <kmc> it's just a plain old datatype with a function in it
23:57:21 <JoeyA> @src Data.Traversable.foldl'
23:57:21 <lambdabot> Source not found. Do you think like you type?
23:57:29 <JoeyA> @src Data.Foldable.foldl'
23:57:29 <lambdabot> Source not found. Maybe you made a typo?
23:57:39 <c_wraith> I suspect you could find someone to argue Maybe (Int -> Int) isn't algebraic, since it contains non-algebraic components.
23:57:53 <kmc> i expect i can find someone to argue anything
23:58:07 <kmc> especially if someone else is willing to argue the opposite
23:58:21 <shachaf> kmc: You don't even need to look outside #haskell.
23:58:25 <c_wraith> Is there a term for recursively algebraic?
23:58:47 <ivanm> JoeyA: lambdabot doesn't contain all of base for @src
23:58:58 <shachaf> "recursively algebratic" would seem to mean "recursively algebraic" to me.
23:59:10 <kmc> shachaf, it's a little confusing outside context
23:59:15 <c_wraith> shachaf: I meant an existing term :)
23:59:16 <shachaf> True.
23:59:24 <kmc> i would probably say "first-order data type", but I don't think it's an established term
23:59:47 <kmc> sometimes you also might want to exclude abstract types
23:59:59 <shachaf> kmc: What would second-/third- order be by that scheme?
