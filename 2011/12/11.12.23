00:01:16 <salisbury> take the sentence "the dog ate the food", I would say it is unlikely that "ate" ++ "the" would be concatenated before "the" ++ "dog"
00:01:57 <salisbury> when generating language in the brain, at least.
00:02:07 <salisbury> and the brain seems to be able to resolve these problems quickly
00:02:13 <augur> well yes but thats tangential to the point because a) we're not talking about concatenation but tree building, and b) that's part of the well formedness of the trees not part of the rules of cost
00:06:01 <salisbury> what are the leaves of a tree? are they individual words?
00:06:23 <salisbury> the tree*
00:06:36 <augur> yeah
00:08:25 <salisbury> and the total complexity of the tree-building is related to the total number of words, right?
00:09:38 <augur> tree building is something i havent addressed yet. i think it's possible to find a nice algorithm for computing all of the well formed trees you can build from a set of words
00:09:42 <augur> but i dont have one yet i dont think
00:09:45 <augur> im close but not quite there
00:11:58 <salisbury> but imagine some set of rules stipulated that only certain merges could occur.
00:12:01 <Veinor> sounds like you're talking about constituency
00:12:07 <Veinor> in some vague sense
00:13:31 <salisbury> then you could take a set of words, and there may be some words that can only be concatenated with each other. So you could just fold over the list initially and perform these merges
00:14:45 <salisbury> now you have a new set of both individual words and small sub-sentences that can all be treated as leaves. This should reduce total tree-building cost at a rate exponential to the number of initial exclusive-merges found
00:14:55 <salisbury> or not..
00:17:24 <salisbury> hmm, maybe not exponentially.
00:18:07 <augur> salisbury: still tangential
00:18:21 <augur> oh, well no its not
00:19:05 <augur> but im not sure how easy it would be to do what you're suggesting
00:19:12 <augur> also its hard to really see what you mean :P
00:19:33 <salisbury> hehe, but this is why I think a large database of sentences would be useful.
00:19:56 <salisbury> perhaps these rules can be observed 'empirically'
00:20:23 <The_Journey> what is the syntax for multiple type constraints? I'm trying to do (Show a) => (Show b) => instance (Show (Foo a b)) but ghc keeps spitting malformed instance header at me
00:20:41 <augur> salisbury: it sounds like you're aiming for grammar induction
00:20:45 <augur> research exists for this
00:21:07 <augur> the answer is generally: not without lots of assumptions and lots of statistics and lots of willingness to accept crumminess
00:22:18 <salisbury> or maybe the data set wasn't big enough. I'll have a look at grammar induction
00:22:33 <augur> no its big enough, trust me
00:22:43 <augur> they usually work with the NYT gigaword corps
00:22:45 <augur> corpus*
00:23:25 <augur> and current calculations show that the law of decreasing returns is making it so that we're hitting a bit of a limit in what bigger corpuses can give us
00:23:43 <augur> theres something like an exponential relationship between the improvement we want and the data we need to get it
00:24:32 <salisbury> arg..
00:24:34 <augur> to the point where there isnt enough data in the entirety of all english text ever, spoken as well as written, to get the kind of success we'd really like
00:26:31 <augur> salisbury: http://elanguage.net/journals/index.php/lilt/article/view/2587/2551
00:27:09 <augur> section 3, specifically 3.1
00:28:04 <augur> 1 million hours of speech for HMM voice recognition is required for human-level abilities
00:31:41 <salisbury> damn
00:32:06 <salisbury> but children can do it so quickly
00:32:35 <augur> yes
00:32:43 <augur> thats because they have a lot of built in assumptions
00:32:52 <augur> not just assumptions but constraints
00:39:13 * hackagebot flock 0.2.5.1 - Wrapper for flock(2)  http://hackage.haskell.org/package/flock-0.2.5.1 (ErikHesselink)
00:51:22 <carpi> is there a way to call an IO action repeatedly..so that it continuously takes input and stops only when a certain contidtion is met?
00:57:07 <pedro3005> how do I convert a float to int?
00:57:17 <Sgeo> :t ceiling
00:57:18 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
00:57:21 <Sgeo> :t floor
00:57:21 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
00:57:25 <pedro3005> oh yeah
00:57:26 <Sgeo> :t round
00:57:27 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
00:58:06 <salisbury> augur: I will look into this some more, I have to get to sleep atm
00:58:18 <salisbury> but it's pretty closely related to what I'm trying to do as well
00:59:02 --- mode: ChanServ set +b GoMittGo!*@*
00:59:02 --- kick: GoMittGo was kicked by ChanServ (Banned: politbot)
00:59:06 <salisbury> so I thank you greatly for the insights
01:35:09 <cl1> are there paid for tools that have a source stepping debugger for haskell?
01:35:38 <cl1> or free
01:38:05 <quicksilver> ghci's debugger can do stepping
01:38:20 <quicksilver> but source stepping is a rather different concept for haskell's evaluation order
01:39:14 * hackagebot kqueue 0.1.2.1 - A binding to the kqueue event library.  http://hackage.haskell.org/package/kqueue-0.1.2.1 (ErikHesselink)
01:41:42 <cl1> so ghci lets me "walk" through the source code during evalutation?
01:42:34 <ceii> cl1: no. It only allows you to set break points and step evaluation, and tells you where you are in the source
01:42:56 <cl1> bleh
01:47:18 <quicksilver> cl1: walking through source code doesn't make sense in haskell
01:47:23 <quicksilver> haskell does not evaluate line by line
01:47:49 <quicksilver> what ghci does is as close as you can get to "stepping" although some of the details of the ghci debugger are probably a bit clunkier than they could be
01:48:17 <quicksilver> it's not that nobody has implented the feature you ask for - it's that the feature doesn't make sense.
01:48:36 <nexion> what's a "hidden package"? trying to use Data.Binary.Put
01:49:04 <quicksilver> GHC comes with its own binary package, nexion, but you're not supposed to use it, so its hidden.
01:50:30 <nexion> I'd like to use some of the functions it provides (serializing numbers into ByteString). Is there something I can use instead?
01:51:04 <quicksilver> you are intended to install your own binary pacakge with cabal, I think
01:51:25 <nexion> ah
01:52:28 <nexion> you are correct
01:52:30 <nexion> thanks :)
01:53:03 <quicksilver> although I don't think there is any harm in just unhiding that one
02:03:12 <augur> ski: it seems like the hinze et al paper is just extensing the foldr/build method to a categorical analysis
02:03:13 <augur> or something
02:04:57 <augur> in fact, it seems like they show that the acid rain rule is generally true
02:13:33 <Sgeo> Can I define instances on specific function types?
02:13:43 <Sgeo> e.g. instance Eq (Hi -> Bye) where
02:16:15 <augur> try it and see!
02:16:55 <nexion> what's the way to convert a lazy bytestring into a strict one? I see toChunks, but would like to know why it returns a list (of 64k chunks?) and why there doesn't seem to be direct version
02:20:00 <m3ga> nexion: probably a bad idea, but bs = BS.concat $ LBS.toChunks lbs
02:20:55 <quicksilver> Sgeo: haskell98 disallows that for no terribly good reason.
02:21:04 <quicksilver> FlexibleInstances permits it.
02:21:13 <quicksilver> it's not a controversial extension
02:24:05 <nexion> m3ga, is that because the intent of the Lazy bytestring is to be like an infinite list, which someoneone would want to access in chunks?
02:24:58 <m3ga> yes.
02:26:39 <m3ga> nexion: we use ByteStrings for efficiency. converting from LBS to BS should be avoided if you want efficiency.
02:27:38 <Sgeo> quicksilver, ty
02:28:15 <nexion> I agree.. I'm looking for Data.Binary.Put that produces a strict ByteString instead
02:28:31 <nexion> I found the binary-strict package, but that seems to only be for Get
02:30:14 <Blkt> good day everyone
02:30:31 <quicksilver> nexion: what's your actual objective? Why is a lazy bytestring not good enough for you?
02:31:12 <Peaker> My guess is that some other library wants a strict bytestring.. these two types should have had better names
02:31:50 <nexion> quicksilver, I haven't considered them.. I'm using ByteString (strict) for sending/receiving data on a socket
02:31:51 <Peaker> and we could have had type-classes letting code be agnostic to which it is...
02:32:04 * Peaker beats the dead horse a bit more
02:32:05 <quicksilver> nexion: just send the lazy one on the socket.
02:32:14 <nexion> are lazy bytestrings just overall better for most cases?
02:32:21 <quicksilver> yes.
02:32:44 <quicksilver> the only bad thing about them is they encourage people to confuse interleaved IO with laziness
02:32:53 <quicksilver> or, worse still, actually used interleaved IO in real programs.
02:33:01 <quicksilver> doesn't sound like you're suffering from that, though, so that's fine.
02:35:43 <quicksilver> Peaker: I don't think it's a real obstacle to writing good code. It's not difficult to write "class SomeKindaByteyThing a where putStr a :: a -> IO ()" and "instance SomeKindaByteyThing L.ByteString"
02:35:57 <quicksilver> which is exactly what I would quickly write if I hit this issue in a real program.
02:36:13 <Peaker> quicksilver: Independent instances are one of the huge advantages in Haskell, IMO
02:50:36 <statusfailed> How do I convert String to non-lazy ByteString?
02:54:02 <Peaker> statusfailed: A UTF8 one?
02:54:12 <statusfailed> I don't know ;_;
02:54:22 <Peaker> statusfailed: String is a list of unicode code-points
02:54:33 <Peaker> statusfailed: ByteString is a list of bytes.. you need to translate unicode code points to bytes somehow
02:55:02 <statusfailed> well okay, UTF8 then
02:55:05 <statusfailed> how do I do that?
02:55:08 <Peaker> statusfailed: either you discard all non-ascii information and then they fit in bytes (Data.ByteString.Char8.pack) or you encode the unicode info into UTF8 (Data.ByteString.UTF8.fromString)
02:55:16 <statusfailed> ok
02:56:00 <statusfailed> ok question 2
02:56:09 <statusfailed> how do I convert Lazy bytestring to strict?
02:56:41 <statusfailed> I thought it was just a list of strict ones, so can I just do fromChunks?
02:56:49 <statusfailed> Peaker: also thanks :P
02:58:07 <quicksilver> concat and fromChunks, yes.
02:58:16 <quicksilver> but the next question is, why bother?
02:58:23 <quicksilver> what can you do with a strict BS you can't do with a lazy BS?
02:58:58 <statusfailed> it's going between APIs
02:59:05 <statusfailed> one wants lazy one wants strict
02:59:24 <statusfailed> I don't care either way
03:00:13 <statusfailed> but I get a type error with fromChunks :\
03:00:44 <quicksilver> you will note I said "concat and fromChunk"
03:01:08 <quicksilver> hmm actually itsn't it toChunks? concat and toChunks.
03:01:47 <statusfailed> not sure :)
03:02:45 <statusfailed> ah, BS.concat . BL.toChunks
03:02:55 <statusfailed> BS/ByteString BL/LAzy
03:04:20 <statusfailed> cheers!
03:34:21 * hackagebot fclabels 1.1.0.1 - First class accessor labels.  http://hackage.haskell.org/package/fclabels-1.1.0.1 (SebastiaanVisser)
03:49:39 <Sgeo> :t foldM
03:49:39 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
03:57:35 <Sgeo> :t Control.Category.id
03:57:36 <lambdabot> forall (cat :: * -> * -> *) a. (Control.Category.Category cat) => cat a a
03:59:56 <Sgeo> :t Control.Monad.State.get
03:59:57 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
04:00:07 <Sgeo> Hmm, fclabels also calls a function get
04:00:16 <Sgeo> That seems like it could be annoying to deal with
04:00:52 <donri> Sgeo: qualified imports?
04:02:48 <ClaudiusMaximus> :t Control.Monad.State.gets
04:02:49 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
04:07:29 <ClaudiusMaximus> fclabels does look nice, it's really not fun writing things like  foo{ bar = (bar foo){ baz = (baz (bar foo)){ quux = "etc" } } }
04:08:54 <Sgeo> ClaudiusMaximus, thing is, there are other packages that do similar
04:09:01 <donri> data-lens is nice too
04:11:06 <ClaudiusMaximus> cool
04:11:17 <rs46> it's a shame that the hackage servers are running gtk2hsC2hs 0.13.4 . The latest version of the cairo package requires 0.13.5 .
04:11:41 <rs46> this means that all packages that depend on cairo do not compile on those servers
04:11:55 <rs46> and therefore don't produce the haddock documentation on hackage
04:11:57 <rs46> :-(
04:12:27 <hpaste> ique pasted “hmatrix IO” at http://hpaste.org/55645
04:12:45 <ique> Hey, I have an IO Monad related question.. I have a function f :: [Double] -> IO [Double] that I want to find the root of with the hmatrix package. So i have to use a function "root" which takes a function [Double] -> [Double]. Can I make this work somehow?
04:13:02 <ique> quick example code is in the paste above
04:13:33 <ique> The reason the function returns IO [Double] is that I do some database lookups for parameters in the function
04:14:53 <sipa> root `fmap` f
04:15:47 <sipa> oh wait
04:16:22 <rs46> I believe your type signature should also be:
04:16:25 <rs46> findRoot = ([Double] -> [Double]) -> IO [Double]
04:17:36 <ique> Hmm.. What exactly does fmap do? I thought I understood but from looking at the type signature now I'm not sure
04:19:17 <ique> rs46: yeah that's true.. I just took what the root function would give me straight up
04:21:39 <Axman6> ique: do you understand what map does for lists?
04:21:58 <ique> the problem is that the input to root, which I can't change is [Double] -> [Double] and I have [Double] -> IO [Double] :S
04:22:06 <ique> Axman6: yes!
04:22:28 <Axman6> ique: why is it IO [Double]?
04:22:45 <Axman6> ique: fmap is just the same idea generalised to other types.
04:22:50 <Axman6> @src Maybe fmap
04:22:50 <lambdabot> fmap _ Nothing       = Nothing
04:22:51 <lambdabot> fmap f (Just a)      = Just (f a)
04:22:59 <Axman6> @src Either fmap
04:22:59 <lambdabot> fmap _ (Left x) = Left x
04:22:59 <lambdabot> fmap f (Right y) = Right (f y)
04:23:07 <Axman6> @src (->) fmap
04:23:07 <lambdabot> fmap = (.)
04:23:10 <ique> Axman6: because I have to do DB queries in it to look up parameters for the function
04:23:30 <Axman6> hmm
04:23:46 <ClaudiusMaximus> ique: can you do the db queries beforehand?  like  mkFunction :: ... -> IO ([Double] -> [Double])
04:23:54 <Axman6> ique: well, last resort is to use unsafePerformIO, but you should probably find a better way to access your data
04:25:35 <ique> ClaudiusMaximus: That might not be impossible actually.. would take some rewriting of stuff but would probably be worth it to not use unsafe
04:26:06 <ique> Axman6: thanks.. i'll try to figure out some way to return IO ([Double] -> [Double]) instead and then I should be able to use fmap right
04:27:24 <alistra> @src error
04:27:25 <lambdabot> error s = throw (ErrorCall s)
04:27:39 <alistra> @src throw
04:27:39 <lambdabot> throw exception = raise# exception
04:27:47 <alistra> @src raise#
04:27:47 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
04:28:15 <ClaudiusMaximus> ique: i guess something like   findRoot `fmap` mkFunction ...   would work
04:29:01 <ique> ClaudiusMaximus: yeah looking at the types from a short test says that should work
04:30:46 <FliPPeh_> What are my best options to implement some kind of dynamic plugin system the safest way? Anyone with experience here?
04:31:05 <FliPPeh_> Dynamic module loading sounds dangerous and writing an embedded language sounds like a pain :)
04:31:26 <alistra> FliPPeh_: dsl is the usual way but you can explore safe inports
04:31:33 <alistra> imports* the new gizmo in ghc
04:33:37 <FliPPeh_> alistra: Do those safe imports work during runtime? Import sounds a lot like compile time
04:34:10 <FliPPeh_> The plan is to load different modules with a similar structure but different behaviour
04:34:39 <FliPPeh_> Kind of like irssi does with perl scripts
04:43:53 <Cthululz> remember when google first started?  everyone shit themselves at what it brought to the internet.. well welcome to the next pants shitting: http://tawlk.com  you can search social networks in real time and see what people are saying as it happens
04:44:29 <FliPPeh_> I hate web 3.0 :(
04:45:32 <Cthululz> no account needed
04:45:49 <Cthululz> just type in words and see who is saying them and where from
04:46:01 <Cthululz> facebook myspace google plus
04:46:06 <Cthululz> it grabs it all
04:46:08 <aadrake> I've been working on a CSV parser using http://book.realworldhaskell.org/read/using-parsec.html as the example.  I need to take each line, concatenate it, md5 it, and then output all to another file.  Would this be much faster using attoparsec?
04:46:17 <FliPPeh_> Except it doesn't finish loading
04:52:27 <alpounet> aadrake, attoparsec is faster generally yes
04:52:40 <Eduard_Munteanu> aadrake: you could be using a CSV lib though
04:52:56 <alpounet> indeed, there are some out there
05:00:15 <aadrake> alpounet: Faster is better in this case as the file is quite large.
05:00:24 <aadrake> Eduard_Munteanu: Do you have a reccomendation?
05:00:57 <Eduard_Munteanu> I used one at some point, but I'm unsure which one. You might want to look around Hackage.
05:01:42 <aadrake> Eduard_Munteanu: I am very new to Haskell so I'm using these work problems for learning.  I need faster tools for my data analysis so I thought it was a good opportunity to start switching to Haskell.
05:01:50 <aadrake> Eduard_Munteanu: I'll look around.
05:02:42 <Eduard_Munteanu> (although I used it for creating CSVs, not reading them)
05:03:05 <aadrake> Eduard_Munteanu: Are these libraries faster than attoparsec?
05:03:43 <Eduard_Munteanu> Not necessarily either way, but it might be easier to just get started with a CSV lib.
05:03:58 <Eduard_Munteanu> Especially if you say you're new to this stuff.
05:04:15 <aadrake> Eduard_Munteanu: Quite new.  As in less than two weeks new.
05:04:57 <ClaudiusMaximus> i'd probably try something like   main = interact (unlines . map md5sum . lines)  unless you really need real parsing (i'm not sure exactly what you need/want to do)
05:06:26 <aadrake> ClaudiusMaximus: Right now it's more of a proof-of-concept and to get some benchmarks against other solutions in R, Ruby, etc.
05:06:38 <ClaudiusMaximus> @hoogle interact
05:06:39 <lambdabot> Prelude interact :: (String -> String) -> IO ()
05:06:39 <lambdabot> System.IO interact :: (String -> String) -> IO ()
05:06:39 <lambdabot> Data.ByteString interact :: (ByteString -> ByteString) -> IO ()
05:07:47 <Eduard_Munteanu> aadrake: don't forget to turn optimizations on and use ghc (not ghci) to compare performance
05:07:56 <aadrake> Eduard_Munteanu: Indeed :)
05:08:36 <Eduard_Munteanu> @where alioth
05:08:36 <lambdabot> I know nothing about alioth.
05:08:43 <Eduard_Munteanu> Damn.
05:08:49 <Eduard_Munteanu> @google alioth benchmark
05:08:50 <lambdabot> http://shootout.alioth.debian.org/
05:08:51 <lambdabot> Title: Computer Language Benchmarks Game
05:09:17 <Eduard_Munteanu> If you're interested in general benchmarking, although that's usually not idiomatic Haskell code.
05:09:50 <aadrake> Eduard_Munteanu: I've browsed that but it seemed to be an unfair comparison because of restrictions placed on certain languages, like Haskell, so that they cannot perform optimally.
05:10:52 <Eduard_Munteanu> Yeah, indeed. It also doesn't account for external libs. Haskell can call out C code for e.g. intensive computations.
05:11:42 <Eduard_Munteanu> (and anyway performance figures and requirements depend on the actual app)
05:12:00 <aadrake> ClaudiusMaximus: In the interact (unlines . map md5sum . lines) example, how would I incorporate the file IO into that?
05:12:16 <ClaudiusMaximus> aadrake: interact reads from stdin and writes to stdout
05:12:22 <aadrake> Pipes it is
05:14:00 <aadrake> ClaudiusMaximus: md5sum is in Data.Digest.OpenSSL.MD5, correct?
05:14:12 <ClaudiusMaximus> aadrake: i think there are a few around
05:14:27 <ClaudiusMaximus> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:md5
05:21:57 <Phlogistique> @pl \(a,b,_) -> (a,b) -- why does this fail?
05:21:57 <lambdabot> (line 1, column 6):
05:21:57 <lambdabot> unexpected ","
05:21:57 <lambdabot> expecting letter or digit, operator or ")"
05:21:57 <lambdabot> ambiguous use of a non associative operator
05:23:12 <ClaudiusMaximus> pl doesn't understand tuples >2 is my guess
05:23:51 <aadrake> ClaudiusMaximus: I'm not sure that interact will work as I need to concatenate the values present in the line.  Not all lines have all values, and additionally interact also brings in all the quotation marks and commas since it reads from stdin
05:24:17 <Phlogistique> as a side note, how would you pl \(a,b,_) -> (a,b) ?
05:24:37 <ClaudiusMaximus> aadrake: ah, ok - so you do need a real parser in that case
05:27:22 <Peaker> Where's an instance of Random for Int?
05:27:24 <ClaudiusMaximus> aadrake: but maybe it would be worth parsing on a line-by-line basis, because unless you're careful it might end up trying to keep everything in memory in case of parse failure at line 932415
05:27:52 <aadrake> ClaudiusMaximus: That would be unfortunate because the file in question has about 3 million lines :)
05:29:07 <aadrake> ClaudiusMaximus: I think getContents reads the lines lazily, so my plan now is to use that combined with md5 map concat line (or similar) to read, parse, and write
05:29:23 <aadrake> The file doesn't fit in memory so lazy reading is important in this case.
05:30:42 <aadrake> ClaudiusMaximus: I've gotten as far as parsing the file and writing the concatenated output to stdout
05:30:43 <ClaudiusMaximus> aadrake: right; another thing to think about is character encoding - md5sum is only for binary representations afaik - lazy ByteString might be the way to go for ascii, otherwise lazy Text and explicitly encoding to utf-8 or so
05:32:05 <aadrake> ClaudiusMaximus: All the stuff I've looked at is based around ByteString, but the example from RWH uses parsec with always returns strings.  I read that there is supposed to be a fromString function in ByteString but I didn't have much luck with that.
05:33:26 <aadrake> in Data.ByteString that is
05:33:38 <aadrake> or Data.ByteString.Lazy
05:34:53 <Peaker> System.Random is quite awful
05:36:03 <FliPPeh_> Urgh, I hate the / and div madness
05:36:12 <ClaudiusMaximus> aadrake: http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:encode%20utf  might have some options, i can't recommend any in particular
05:36:20 <FliPPeh_> How can I write a function that accepts any combination of integral and fractional?
05:36:39 <FliPPeh_> (Num a) => a -> a -> a
05:36:59 <quicksilver> "any combination of" ?
05:37:06 <aadrake> ClaudiusMaximus: Thank you for your help
05:37:09 <quicksilver> I'm not sure your question makes sense (yet?)
05:37:18 <FliPPeh_> Number Integer, Float Double
05:37:29 <FliPPeh_> Two types that the function could use
05:37:36 <FliPPeh_> numBinop f ((Number n) : (Number m) : []) = return . Number $ f n m
05:37:39 <FliPPeh_> numBinop f ((Float  n) : (Float  m) : []) = return . Float $ f n m
05:37:40 <FliPPeh_> etc
05:37:46 <quicksilver> Number isn't a type.
05:37:46 <Lemmih> FliPPeh_: The first step is to realize that you don't really want to. Then the second step doesn't matter. (:
05:38:03 <quicksilver> oh, Number and Float are constructors you have invented?
05:38:10 <FliPPeh_> Yep
05:38:36 <quicksilver> so you want to apply "f" to two arguments
05:38:39 <FliPPeh_> yes
05:38:52 <quicksilver> which are either Integer or Double
05:38:57 <FliPPeh_> yep
05:39:02 <quicksilver> and what does it return?
05:39:03 <alistra> @hoogle [Either a b] -> b
05:39:03 <lambdabot> Data.Either rights :: [Either a b] -> [b]
05:39:03 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
05:39:03 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
05:39:08 <alistra> sweet
05:39:11 <mreh> quicksilver: could you give me a clue as to where all the cruft is collecting in merging event streams?
05:39:33 <quicksilver> mreh: because mappend doesn't check whether or not an event can possibly occur again, I think
05:39:36 <mreh> it seems to be in the channel, but i can't see what's holding onto the tail
05:39:45 <quicksilver> mreh: so even whe events "finish" and never happen again, they stay in the mappend
05:40:24 <mreh> quicksilver: that's what I thought, but I just spent the last half an hour convincing myself otherwise :)
05:40:24 <quicksilver> FliPPeh_: f :: Either Integer Double -> Either Integer Double -> WhatEverItWasYouWanted
05:40:27 <mreh> crazy
05:40:40 <quicksilver> mreh: I might be wrong :)
05:40:41 <FliPPeh_> quicksilver: It returns depending on the combination either "Number $ f n m" if both were integers or "Float $ f n m" if any of them was a floating
05:40:57 <quicksilver> FliPPeh_: f :: Either Integer Double -> Either Integer Double -> Either Integer Double then
05:41:16 <FliPPeh_> Which should be fine as both Number and Float construct the same type in the end
05:41:36 <quicksilver> although you may not really need the iether type
05:41:45 <quicksilver> since it's a subtype of your existing type
05:41:47 <FliPPeh_> It's quite cumbersome I guess
05:41:52 <quicksilver> you may just list the four case
05:42:14 <mreh> quicksilver: right... you're mappending two futures speculatively choosing which one comes next
05:42:17 <FliPPeh_> The current method works really well
05:42:19 <quicksilver> numBinop f ((Float n) : (Number m) : _) = return . Float $ f n (fromIntegral m)
05:42:22 <FliPPeh_> EXCEPT for / and div
05:42:30 <quicksilver> and the same thing with n+m reversed
05:42:32 <FliPPeh_> I can add, subtract and multiply between the types just fine
05:42:44 <rostayob> When I try to load a file with haskell-mode, emacs just hangs (it shows the loading symbol on the mouse)
05:42:46 <FliPPeh_> Just / and div are throwing a riot
05:42:51 <rostayob> opening ghci without loading the file works
05:42:56 <FliPPeh_> Because Double is no member of integral
05:43:05 <FliPPeh_> Which div wants
05:43:16 <FliPPeh_> And Integer is no member of fractional as requested by /
05:43:31 <quicksilver> well the answer to your question is you must decide what you want it to do
05:43:35 <quicksilver> actually doing it should be fine.
05:44:14 <FliPPeh_> But I _can't_ do it
05:44:40 <aadrake> One last question, when I try to do something like putStrLn (md5 (map concat r))
05:44:50 <quicksilver> FliPPeh_: Show us the code.
05:44:51 <FliPPeh_> As long as my passed functions just require a Num constraint, all is well because both are guaranteed to be a Num instance
05:44:58 <aadrake> I get an error about type mismatch
05:45:16 <quicksilver> FliPPeh_: right. You can't pass (/) or (div) to a function expecting a Num constraint.
05:45:22 <Lemmih> aadrake: What's the type of 'md5'?
05:45:52 <aadrake> It's from Data.Digest.Pure.MD5, so the type (I think) is Data.Digest.Pure.MD5.MD5Digest
05:46:07 <hpaste> flippeh pasted “Number madness” at http://hpaste.org/55646
05:46:11 <aadrake> Lemmih: The rigid type system is taking some getting used to :)
05:46:21 <pigdude> i have a buffer in my editor that i write to stdin of `runghc`. i get error <interactive>:1:33: Not in scope: `main'
05:46:23 <Lemmih> aadrake: It's a function so there should be a '->' in there somewhere.
05:46:38 <pigdude> however, I am certain this has worked for me in the passt
05:46:40 <ClaudiusMaximus> > let Left i /_ Left j = Left $ i `div` j ; Right f /_ Right g = Right $ f / g in (Left 3 /_ Left 2, Right 3.0 /_ Right 2.0)
05:46:41 <lambdabot>   <no location info>: Parse error in pattern
05:46:48 <aadrake> Lemmih: This if the full line: Right r -> mapM_ putStrLn (md5 (map concat r))
05:47:06 <quicksilver> FliPPeh_: I'm not really sure what to say now. Neither (/) nor "div" is a Num function, so neither of them is appropriate for numBinop.
05:47:18 <FliPPeh_> quicksilver: That's exactly my point
05:47:19 <pigdude> my test program, fully, is "length' xs = sum [1 | _ <- xs]"
05:47:20 <Lemmih> aadrake: Figuring out the type of 'md5' is a good thing to do first.
05:47:26 <quicksilver> FliPPeh_: so what do you actually want?
05:47:28 <Lemmih> aadrake: Ask GHCi if necessary.
05:47:36 <FliPPeh_> quicksilver: I simply want division
05:48:09 <quicksilver> FliPPeh_: you're answering the wrong question.
05:48:25 <FliPPeh_> quicksilver: But I can't put an Integral or Fractional instance on any of the numbers because the other one won't like that
05:48:27 <quicksilver> FliPPeh_: you have written code which works nicely on "Num" operators
05:48:36 <quicksilver> FliPPeh_: There is no "Num" operator for division.
05:48:42 <FliPPeh_> quicksilver: I know that
05:48:49 <quicksilver> FliPPeh_: so your approach will not work for division.
05:48:53 <quicksilver> so what do you *really* want?
05:48:58 <pigdude> what is this?
05:49:16 <aadrake> Lemmih: In GHCi when I import Data.Digest.Pure.MD5 I get that md5 is not in scope.  I think I'm doing something quite wrong.  Thank you for the help
05:49:17 <FliPPeh_> quicksilver: THAT function that works with division
05:49:25 <Lemmih> aadrake: (I know its type, btw. I want to show you how to find the solution instead of just giving it to you.)
05:49:43 <aadrake> Lemmih: md5 :: Data.ByteString.Lazy.Internal.ByteString -> MD5Digest
05:49:59 <quicksilver> FliPPeh_: I would suggest that one possible solution is to notice your code never uses Num polymorphism. It always uses either the Integer or Double functions, and you want it ot behave differently for Integer and Double.
05:50:05 <FliPPeh_> But as I said, I can't write any function that accepts an integral or a fractional because the other number can't work in that constraint
05:50:07 <pigdude> ..
05:50:10 <quicksilver> FliPPeh_: so, pass two functions, one for Integer and one for Double.
05:50:27 <Lemmih> aadrake: Excellent. Now it should be obvious that there are two type problems with your code.
05:50:35 <Phlogistique> auto-answering my previous question:
05:50:38 <Phlogistique> fsts = join $ flip ((,) . fst3) . snd3 where { fst3 (a,_,_) = a; snd3 (_,a,_) = a }
05:50:49 <Lemmih> aadrake: Firstly, the argument to 'md5' is of the wrong type. Secondly, the argument to 'putStrLn' is of the wrong type.
05:50:57 <Lemmih> aadrake: With me so far?
05:51:43 <aadrake> Lemmih: The argument to md5 is a String right now, but should be a ByteString, correct?
05:51:44 <pigdude> i have a buffer in my editor that i write to stdin of `runghc`. i get error <interactive>:1:33: Not in scope: `main'
05:51:54 <Lemmih> aadrake: Yes, exactly.
05:52:10 <aadrake> Then also, the result from md5 is of type MD5Digest but putStrLn wants a String
05:52:15 <aadrake> Is all that correct?
05:52:18 <Lemmih> aadrake: Yep.
05:52:42 <Lemmih> aadrake: And MD5Digest is an instance of Show so you can use 'print' instead of 'putStrLn'.
05:52:46 <hpaste> quicksilver annotated “Number madness” with “Number madness (annotation)” at http://hpaste.org/55646#a55647
05:52:52 <Lemmih> aadrake: (print = putStrLn . show)
05:53:21 <quicksilver> FliPPeh_: annotated your post with one possible version. I can't test the code because it doesn't compile here anyway.
05:53:22 <aadrake> Lemmih: I was using print, but the output was double-quoted, which I did not want
05:53:29 <alistra> how to make haddock link to those packages: Warning: Defs.Common: could not find link destinations for:
05:53:29 <alistra>     GHC.Base.String GHC.Classes.Eq GHC.Show.Show
05:53:37 <FliPPeh_> quicksilver: I'll try it out, thanks
05:53:43 <FliPPeh_> I just hope I won't need more numeric types
05:53:50 <FliPPeh_> This feels really hacky :/
05:53:54 <quicksilver> it's not hacky at all
05:53:59 <quicksilver> it's specifying what you mean
05:54:06 <quicksilver> (/) and div are completely different functions
05:54:13 <pigdude> :^(
05:54:15 <quicksilver> it would be hacky if the language had some magic way to choose the one you wanted.
05:54:21 <pigdude> i don't think anybody hears my question?
05:54:29 <quicksilver> what I've written explicitly makes it clear which to use.
05:54:32 * hackagebot gps2htmlReport 0.2.2 - GPS to HTML Summary Report  http://hackage.haskell.org/package/gps2htmlReport-0.2.2 (RobStewart)
05:54:35 <quicksilver> pigdude: your question "what is this"?
05:54:38 <aadrake> Lemmih: Also, I was looking into how to convert a String to a ByteString, and I saw the fromString function, but got stuck on how to use it
05:54:40 <pigdude> quicksilver, no
05:54:55 <Peaker> div should perhaps have worked with non-integrals too, simply doing floor-division
05:54:57 <FliPPeh_> Yes but now I have to modify the primitives to use two equal functions in most cases, i.e. ("+", numBinop (+) (+))
05:55:17 <quicksilver> pigdude: runghc is a tool for running 'main' actions. Your code has no main action.
05:55:23 <quicksilver> pigdude: that's why you get an error.
05:55:30 <Lemmih> aadrake: There's a 'pack' function of type 'String -> ByteString'.
05:55:31 <quicksilver> pigdude: ghci is a better tool for experimenting.
05:55:39 <Lemmih> aadrake: From Data.ByteString.Char8.
05:55:41 <quicksilver> FliPPeh_: they're not equal.
05:55:45 <pigdude> hm, i know i got :w !runghc to work before...weird
05:55:48 <pigdude> thanks quicksilver
05:55:54 <FliPPeh_> quicksilver: In case of (+) they are
05:56:02 <FliPPeh_> Unless I'm being stupid again
05:56:04 <quicksilver> FliPPeh_: (+) :: Integer -> Integer -> Integer and (+) :: Double -> Double -> Double are entirely different functions.
05:56:12 <quicksilver> FliPPeh_: they just use the same name (overloading)
05:56:30 <aadrake> Lemmih: I tried that, but got a wholly different type error
05:56:37 <FliPPeh_> quicksilver: Alright, thanks :)
05:56:39 <FliPPeh_> Works nicely
05:56:40 <quicksilver> Peaker: yes, perhaps, but that wouldn't have given FliPPeh_ what I think he wants.
05:56:48 <quicksilver> Peaker: he doesn't want "div" semantics for Float.
05:56:54 <quicksilver> well that's my guess.
05:57:44 <FliPPeh_> Well, I just wanted a blunt C-style division that would simply drop the floating part if the arguments permit it
05:57:49 <quicksilver> Peaker: (if you ever do want that, check out Data.Fixed.div')
05:58:10 <FliPPeh_> But I guess Haskell forces me to be sane :)
05:58:42 <quicksilver> well haskell lets you do what you want, it forces you to be a bit more precise about what it is that you want
05:58:48 <aadrake> Lemmih: I think it's related to my syntax actually
05:58:48 <quicksilver> by not having implicit conversions
05:59:46 <FliPPeh_> So what would I do in the case of "mod"?
05:59:56 <FliPPeh_> The integral version is simply "mod", but what about the fractional?
06:00:06 <quicksilver> there is a mod' in Data.Fixed
06:00:14 <quicksilver> > 4.5 `mod'` 1.2
06:00:15 <lambdabot>   0.9000000000000004
06:00:26 <quicksilver> :t mod'
06:00:27 <lambdabot> forall a. (Real a) => a -> a -> a
06:00:33 <FliPPeh_> Ahh!
06:01:29 <Lemmih> aadrake: Just keep at it. It'll work eventually. (:
06:01:49 <aadrake> Lemmih: I will, thank you for the help.
06:02:56 <quicksilver> FliPPeh_: if it's just writing it twice which annoys you, you can still have a helper function which takes any Num-polymorphic and uses it for both cases.
06:03:01 <quicksilver> FliPPeh_: I'll annotate it again
06:04:22 <hpaste> quicksilver annotated “Number madness” with “Number madness (annotation) (annotation)” at http://hpaste.org/55646#a55648
06:04:48 <quicksilver> FliPPeh_: see new version. numBinop for where it's num-polymorphic and idBinop for where you have to specify separate behaviour.
06:05:45 <FliPPeh_> quicksilver: Looks like a good solution, thank you :)
06:06:26 <wereHamster> is there a way to detect unused functions?
06:06:51 <quicksilver> wereHamster: there should a warning for it I'd think
06:06:54 <quicksilver> try -Wall
06:08:34 <FliPPeh_> Any implementations of the quot and rem functions for fractionals? Data.Fixed shows nothing
06:12:47 <quicksilver> FliPPeh_: I think not, although you can derive them easily from mod and div
06:12:53 <quicksilver> they only differ on how they handle negative numbers
06:16:28 <wereHamster> What's your opinion about OverloadedStrings? Should I use it? Or avoid whenever possible?
06:16:34 <wereHamster> or extensions in general
06:18:39 <FliPPeh_> quicksilver: Nice, that's what I was doing anyways :)
06:23:52 <Cale> wereHamster: Extensions are generally good. If you get enough of them, you'll end up limiting yourself to GHC, but there are not so many other viable options right now. OverloadedStrings in particular... well, do you have a new representation of strings?
06:24:21 <Cale> It would be not so advisable to *abuse* OverloadedStrings to let string notation represent other random stuff.
06:24:58 <Cale> But if you have another library along the lines of Data.Text or Data.ByteString, it's fine
06:28:04 <hpaste> wyfrn pasted “modify a record typew” at http://hpaste.org/55649
06:28:51 <wyfrn_> hi all .. is there a way to modify in a generic way (pls see the link above)
06:29:06 <quicksilver> wyfrn_: there are lots of librarie with that in mind
06:29:16 <quicksilver> wyfrn_: data-lens, fclabels, data-accessor
06:29:26 <quicksilver> the first being preferable to my way of thinking.
06:29:27 <byorgey> Cale: one other good use of OverloadedStrings I've seen is in hakyll, where strings can be used to denote patterns for matching/routing
06:29:35 * hackagebot elerea 2.7.0 - A minimalistic FRP library  http://hackage.haskell.org/package/elerea-2.7.0 (GergelyPatai)
06:29:54 <byorgey> i.e. they get parsed into a pattern AST
06:30:30 <quicksilver> how is that different from just having the function take a String argument and do that behind the scenes?
06:30:54 <byorgey> quicksilver: because the actual pattern language is more expressive than what you can get just from parsing strings
06:31:16 <byorgey> i.e. with strings you can do things like "foo/*" but you can't say "match one of these three options"
06:31:50 <byorgey> I don't know, it feels quite natural and useful to me when I work with hakyll
06:32:01 <byorgey> and because you can only use patterns with certain functions, type inference is never a problem
06:35:45 <wyfrn_> quicksilver, thx
06:36:23 <quicksilver> byorgey: so the strings exist as a shortcut to a more expressive type but you can use that type directly instead?
06:36:46 <byorgey> quicksilver: right
06:37:08 <quicksilver> byorgey: that seems a fairly pointless trick, you could just overload that function instead
06:38:37 <byorgey> quicksilver: I suppose so.
06:39:32 <quicksilver> probalby harmless also.
06:40:17 <byorgey> it does mean the function is monomorphic, making it slightly easier to understand when looking at the generated Haddock.
06:40:31 <byorgey> not that that is a sufficient argument for using OverloadedStrings.
06:49:35 * hackagebot acid-state 0.6.2 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.6.2 (DavidHimmelstrup)
06:50:25 <aadrake> Question: putStrLn (show (md5 (B.pack r))) works fine in GHCi but Right r -> mapM_ putStrLn (show (md5 (B.pack (map concat r)))) fails miserably when I try to compile.  Why is that?
06:51:22 <parcs`> putStrLn . show = print
06:51:41 <aadrake> parcs`: Yes, but print produces quoted output
06:51:57 <parcs`> :t mapM_ putStrLn
06:51:57 <lambdabot> [String] -> IO ()
06:52:06 <parcs`> :t mapM_ putStrLn . show
06:52:07 <lambdabot>     Couldn't match expected type `[Char]' against inferred type `Char'
06:52:07 <lambdabot>       Expected type: a -> [String]
06:52:07 <lambdabot>       Inferred type: a -> String
06:52:55 <parcs`> you can't putStrLn a Char, only a [Char]. why do you have mapM_ there?
06:53:15 <aadrake> parcs`: I was using a CSV parsing example from RHW
06:53:34 <parcs`> remove the mapM_ and it should work
06:53:58 <parcs`> also print produces quoted output too, so use that
06:54:36 * hackagebot safecopy 0.6.1 - Binary serialization with version control.  http://hackage.haskell.org/package/safecopy-0.6.1 (DavidHimmelstrup)
06:55:47 <byorgey> aadrake: what is the type of r?
06:56:19 <aadrake> byorgey: [Char]
06:56:20 <byorgey> aadrake: also, "fails miserably" is not very specific.  I doubt you actually get an error from GHC complaining about misery.
06:56:37 <aadrake> byorgey: No, GHC is completely impartial of course.
06:56:37 <byorgey> aadrake: then (map concat r) does not make sense.
06:56:47 <byorgey> aadrake: what are you trying to do?
06:57:17 <aadrake> byorgey: I have a CSV file, I want to concatenate the fields, md5 them, and then output the hashes unquoted.
06:57:45 <byorgey> aadrake: wait, I'm sorry, I meant the type of r in your second example.
06:57:50 <aadrake> byorgey: In the compiled example, r is of type [String]
06:58:45 <byorgey> aadrake: can you paste the complete code you are trying to compile, along with the error message, on hpaste.org?
06:58:57 <aadrake> byorgey: Sure
07:02:28 <hpaste> aadrake pasted “paste” at http://hpaste.org/55650
07:02:48 <pigdude> i like haskell :^)
07:02:57 <aadrake> byorgey: The code is basically a direct copy of the version from RWH, I'm just trying to change the output
07:04:15 <byorgey> aadrake: ah, I see now
07:05:24 <byorgey> aadrake: (map concat r) makes sense, that will take r, which is actually of type [[String]] (i.e. list of list of strings) and concatenate every inner list to give you a [String]
07:05:41 <aadrake> byorgey: Correct
07:05:48 <hpc> :t words .: lines
07:05:48 <lambdabot> String -> [[String]]
07:05:49 <byorgey> aadrake: but then you call B.pack on that, and B.pack expects a String
07:06:23 <byorgey> aadrake: you really want to call B.pack (and hash, etc.) on *each* of those Strings individually, right?
07:06:26 <aadrake> byorgey: So I need another map then?
07:06:43 <aadrake> Or map2 or something?
07:06:48 <aadrake> byorgey: Correct, each string
07:07:00 <byorgey> aadrake: one way to do it would be to insert lots more calls to 'map', like  (map show (map md5 (map B.pack ...
07:07:05 <byorgey> aadrake: but there is a better way
07:07:33 <byorgey> mapM_ (putStrLn . show . md5 . B.pack . concat) r
07:07:59 <byorgey> that calls the function pipeline (putStrLn . ... . concat) on every element of r
07:08:20 <byorgey> have you read about the function composition operator (.) ?
07:08:37 <aadrake> byorgey:I have
07:08:40 <byorgey> ok
07:09:22 <aadrake> byorgey: That does indeed solve the problem.  I have been messing with this for many hours.  Thank you for the advice.
07:09:36 * hackagebot IORefCAS 0.2 - Atomic compare and swap for IORefs and STRefs.  http://hackage.haskell.org/package/IORefCAS-0.2 (RyanNewton)
07:09:40 <pigdude> is this how one might add a common suffix to a function? http://paste.pocoo.org/show/525005/
07:09:49 <byorgey> aadrake: you're welcome.
07:09:52 <pigdude> in this case, I wanted "!" out of catType
07:10:28 <byorgey> pigdude: looks fine
07:10:43 <pigdude> ok :*3
07:10:50 <byorgey> pigdude: you could also write  sayKitty = exclaim . catType
07:10:51 <aadrake> byorgey: Now we get to see how Haskell compares to my current tools where speed is concerned.
07:11:07 <pigdude> byorgey, that is the compose operator right?
07:11:18 <byorgey> pigdude: right
07:11:33 <byorgey> aadrake: well, it appears you have written your own CSV parser using parsec, which is not particularly known for its speed
07:11:36 <pigdude> byorgey, in that case there's no reason to do sayKitty :: (Integral a) => a -> String ?
07:11:47 <byorgey> pigdude: sure there is
07:11:53 <pigdude> oh, ok
07:12:00 <pigdude> i felt that lines 1 and 4 were repetitive
07:12:25 <byorgey> pigdude: well, those two functions happen to have the same type
07:12:48 <pigdude> yea, i thought that maybe ghc would infer that from the body of sayKitty
07:12:56 <byorgey> pigdude: the type signatures are not *necessary*; they can be inferred.
07:12:56 <pigdude> but i made it explicit to be sure
07:12:59 <pigdude> ok
07:13:02 <byorgey> But writing them is good practice.
07:13:07 <pigdude> thanks!
07:13:28 <byorgey> It's a form of documentation, helps clarify your thinking, and results in better error messages when you make a mistake
07:14:07 <pigdude> byorgey, sure, this is familiar
07:14:13 <pigdude> i try to be good w/ my api docs :^)
07:14:14 <Andrew___C> grrr : given up on Gtk+ install, hence on nice GtkTV interface.. went for annoying text interface only to find  hSetBuffering stdin NoBuffering doesn't work on Windows  as a three-year old bug with priority 'low'. It's like the Haskell community says User Interface? Windows? Together? Why would you want that? Surely no-one wants that?
07:14:33 <aadrake> byorgey: Would it be difficult to modify that code so that the hashes are output as they are calculated instead of stored in memory until the whole thing is processed?
07:14:34 <augur> pigdude: any relation to pigworker?
07:14:38 <byorgey> aadrake: if you want something fast on large CSV files, perhaps you want to look at http://hackage.haskell.org/package/attoparsec or an existing CSV parser like http://hackage.haskell.org/package/bytestring%2Dcsv
07:14:42 <pigdude> augur, i hope not
07:14:56 <augur> also, wee, first volume of principia mathematica! :D
07:15:14 <parcs`> i would suggest http://hackage.haskell.org/package/csv-enumerator
07:15:15 <pigdude> augur, i'm just javascript guy :^p
07:15:29 <augur> pigdude: oh, so you compile agda to JS then? :D
07:15:32 <aadrake> byorgey: I looked at those today but I was having a hard enough time with the example that was essentially given to me.  :)
07:16:08 <aadrake> byorgey: The files I work on typically are pretty large, regularly over 10GB
07:16:16 <augur> byorgey: is division of species the multiplicative version of subtraction? pairs that eliminate shared product terms on both sides?
07:16:18 <byorgey> aadrake: fair enough!  I'm just pointing out that you may want to reserve judgment re: efficiency.
07:16:30 <pigdude> augur, hehe nope :^)
07:17:13 <aadrake> byorgey: I'm guessing that the efficiency will be better than what I've been using, which is R with mongodb or PostgreSQL
07:17:25 <byorgey> aadrake: yeah, if you want incremental output see http://hackage.haskell.org/package/csv-enumerator as parcs` suggested, although iteratees/enumerators currently have a bad reputation for being hard to understand
07:17:29 <byorgey> aadrake: hehe, fair enough
07:17:34 <byorgey> aadrake: be sure to compile with -O2
07:18:17 <byorgey> aadrake: modifying your example code to be incremental would be difficult.  The problem is that the entire parse fails if any part of it fails, and it has to decide whether the parse succeeded or not before it can proceed
07:18:47 <byorgey> well, I guess I don't know if it would be difficult, I just mean it wouldn't be entirely straightforward.
07:19:11 <aadrake> byorgey: No problem, it's just taking up a ton of memory
07:19:13 <byorgey> parsec is not really designed for creating streaming parsers.
07:19:20 <byorgey> yeah, I'm not surprised.
07:19:53 <quicksilver> streaming parsers are quite a different problem
07:19:59 <quicksilver> in a sense they are impossible :)
07:20:07 <aadrake> byorgey: In fact, if it's doing everything in memory before it does the parsing then this isn't going to work :)
07:20:07 <quicksilver> you have to weaken the notion of parser slightly.
07:20:21 <quicksilver> in *practice* you can normally break your stream into chunks
07:20:27 <quicksilver> and parse the chunks independently
07:20:29 <parcs`> byorgey: yeah, enumerators would help with that memory problem
07:20:30 <quicksilver> and that's good enough.
07:20:36 <quicksilver> parcs`: no, they wouldn't.
07:20:47 <byorgey> quicksilver: good point.
07:20:58 <aadrake> quicksilver: In this case the data can be broken up pretty easily because each line represents one record
07:21:04 <quicksilver> then it's fine
07:21:17 <quicksilver> just have a line parser not a whole-of-data parser
07:21:42 <aadrake> Well, it ran for a while and then died because memory allocation filed :)
07:22:04 <parcs`> quicksilver: why wouldn't they?
07:22:28 <aadrake> quicksilver: I saw the example in RWH and wanted to give it a shot.
07:22:37 <byorgey> I see now.  aadrake already has a 'line' parser.  In fact  csvFile = endBy line eol.
07:23:04 <byorgey> so instead of calling parse csvFile on the entire file, just break up the file into lines (using 'lines') then call  parse line  on each.
07:23:04 <aadrake> byorgey: Does that mean it's not so hard to modify the code to work line-by-line after all?
07:23:14 <aadrake> byorgey: That doesn't sound bad
07:23:19 <byorgey> aadrake: yes, I spoke a little too quickly.  Once again quicksilver saves the day.
07:24:10 <quicksilver> parcs`: they wouldn't solve the general problem of "parsers needs to see the end of the data to start producing results"
07:24:18 <aadrake> So should I have c <- lines getContents
07:24:24 <byorgey> aadrake: then instead of checking whether the parse of the entire file succeeded (case parse ... of ...), you check whether each line succeeded, and throw away lines that didn't (or print an error message, or whatever)
07:24:28 <quicksilver> parcs`: they might alleviate some other problems of course
07:24:46 <byorgey> aadrake: getContents :: IO String, and lines expects a String, so that doesn't type check
07:24:58 <byorgey> aadrake: you can do   c <- fmap lines getContents
07:25:28 <kmc> Andrew___C, :(  well, it's not a sexy research problem.  do you have a link to that ghc bug?
07:25:50 <aadrake> byorgey: That gives a type error actually
07:26:12 <byorgey> aadrake: well, now  c :: [String]  so you have to use it in a different way below
07:26:18 <byorgey> before it was  c :: String
07:26:25 <aadrake> byorgey: Oh right
07:27:04 <byorgey> aadrake: I'd do something like  mapM_ processLine c
07:27:17 <byorgey> then define  processLine :: String -> IO ()
07:28:53 <aadrake> byorgey: And doing IO all over the place isn't frowned upon?
07:29:37 <byorgey> aadrake: oh, it is =)  I just thought that would provide you the easiest migration path from your current code, and then you could refactor later
07:30:49 <aadrake> byorgey: So I created the processLine function, which was basically just the same line we already had, but now since we changed the type of c there's a type error from parse csvFile "(stdin)" c
07:31:44 <byorgey> aadrake: so processLine takes an argument which you also named c?
07:31:53 <aadrake> No, I named it line
07:31:54 <byorgey> (nothing wrong with that, just trying to understand)
07:32:08 <byorgey> 'line' is probably a bad name since you already have a function named 'line'
07:32:18 <byorgey> well, a parser
07:32:35 <byorgey> and we are going to need to use that parser =)
07:32:51 <aadrake> Okay, I'll go with a
07:33:10 <byorgey> aadrake: so processLine should not be referring to c anymore, but to its argument a
07:33:26 <aadrake> processLine :: String -> IO ()
07:33:27 <aadrake> processLine a = (putStrLn . show . md5 . B.pack . concat) a-
07:33:29 <kmc> Andrew___C, do you have GTK+ installed such that you can compile a example GTK program written in C using MinGW?  this might be a useful, better documented step
07:33:38 <aadrake> byorgey: That's what I wrote
07:33:53 <kmc> aadrake, doing IO all over the place isn't frowned upon if your problem naturally involves IO all over the place
07:33:53 <byorgey> aadrake: processLine is going to have to do some parsing
07:34:03 <kmc> certainly you shouldn't stop abstracting just because there's some IO going on
07:34:07 <Andrew___C> cabal install gtk fails
07:34:18 <Andrew___C> kmc: cabal install gtk fails
07:34:28 <byorgey> aadrake: something like  processLine a = case parse line "(stdin)" a of ...
07:34:46 <Andrew___C> Glade runs
07:34:50 <Andrew___C> kmc: Glade runs
07:35:05 <Andrew___C> kmc: the example programs run
07:35:27 <Andrew___C> kmc: but I haven't compiled anything with minGW myself
07:35:57 <Andrew___C> kmc: if you have a tiny example you can hpaste for me that'd be great, but whilst I can read C, I can't write it.
07:36:12 <aadrake> byorgey: Okay, working on that a bit now
07:38:02 <Andrew___C> kmc: I'll try to compile the examples in gtkglext-examples but won't know (if they fail) whether they should work or not!
07:39:15 <kmc> gtkglext is an extra thing
07:39:35 <kmc> as far as I know, you need to install GTK+ for Windows in the "normal way" before you do anything related to Haskell
07:39:39 <kmc> i don't know what that way is
07:39:46 <kmc> but that's how it is on every other platform
07:39:48 <aadrake> byorgey: So the output of fmap lines getContents will be [String]?
07:40:37 <kmc> i just found this link:  http://kemovitra.blogspot.com/2009/06/compiling-gtk-2-for-windows.html
07:40:46 <kmc> dunno if it's helpful, maybe step 14 at least
07:41:09 <Andrew___C> kmc: I installed it using the GTK+/Glade installer I downloaded. I didn't use the default location, but surely something's very broken if it's written with hard-coded directories, so I don't think it's that.
07:41:13 <kmc> http://www.ibiblio.org/apollo/WinGtkHowto.html
07:41:22 <kmc> ok
07:47:30 <mroman> Is there yet a haskell package for relational algebra?
07:47:39 <Andrew___C> kmc: read compiling-gtk-2-for-windows - it culminates in a successful run of gtk-demo.exe, which already runs successfully. gtk appears to be installed fine. Here's where I'm at: http://hpaste.org/55554
07:48:14 <Botje> buh
07:48:16 <Botje> oops
07:48:29 <aadrake> byorgey: So I'm down to two type errors but I'm not clear about what mapM_ is doing.  Is that even still necessary?
07:48:46 <parcs`> where can one find a large csv file on the internet
07:49:47 <Andrew___C> parcs`: yuou could fill a spreadsheet with =rand() then save as csv
07:50:44 <aadrake> parcs`: You could download this loan data: https://www.lendingclub.com/info/download-data.action
07:50:50 <Andrew___C> aadrake: mapM_ takes an IO thing and runs it on a whole list
07:51:47 <aadrake> parcs`: It's not terribly large, but it's not so small either
07:53:21 <aadrake> parcs`: http://stat-computing.org/dataexpo/2009/the-data.html
07:53:26 <aadrake> parcs`: That is quite a bit of data
07:54:34 <aadrake> Andrew___C: I was using mapM_ to print elements of a list (at least I think that's what was going on) but now I'm operating on individual list items so I'm not sure that I still need it
07:55:25 <Andrew___C> aadrake: http://hpaste.org
07:55:45 <Andrew___C> ...if you like...
07:56:37 <hpaste> aadrake pasted “paste” at http://hpaste.org/55651
07:56:46 <aadrake> Andrew___C: The mapM_ was in Right r -> (putStrLn . show . md5 . B.pack . concat) r
07:57:06 <aadrake> I took it out and no more type error.
07:57:24 <quicksilver> your analysis is correct
07:57:31 <quicksilver> you neede dthat when it was working on a whole list
07:57:38 <quicksilver> you don't need it when it's working on one elmenet at t time
07:57:53 <aadrake> quicksilver: Thank you
07:57:59 <Andrew___C> aadrake: show generates one thing, yes, so you shouldn't need it
07:58:16 <parcs`> aadrake: thanks!
07:59:02 <aadrake> parcs`: The airline data is a pretty large set amongst those that I know of just sitting around on the web.
08:00:03 <aadrake> Andrew___C: I still have one more type error from map processLine c
08:00:48 <Andrew___C> aadrake: what is the type of processLine and of c?
08:02:45 <aadrake> processLine is String -> IO and c is whatever type results from fmap lines getContents, which I'm guessing is [String]
08:03:38 <quicksilver> fmap lines getContents is IO [String]
08:03:44 <quicksilver> so you want mapM_ processLine c
08:03:45 <quicksilver> not just map.
08:03:49 <Andrew___C> :t getContents
08:03:50 <lambdabot> IO String
08:03:56 <aadrake> quicksilver: Ah, that's the problem
08:12:26 <aadrake> quicksilver: Thank you for the input, it's running now and using no memory since it's parsing each line
08:12:30 <aadrake> and not storing it
08:13:03 <quicksilver> yay.
08:13:12 <parcs`> the version i have parses a 122M csv file, printing the md5 checksum of each row, in 75 seconds and with constant 6MB memory usage
08:13:33 <ion> So it’s too bloated to run on my Amiga 500.
08:13:43 <aadrake> parcs`: Mine is still running, but the file is about 900mb
08:14:03 <aadrake> parcs`: Memory usage is effectively 0 because nothing is going in RAM
08:14:25 <parcs`> well SOME ram needs to be allocated :P
08:14:37 * hackagebot websockets 0.4.1.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.4.1.0 (JasperVanDerJeugt)
08:14:38 <aadrake> parcs`: Did you write your own version or use the modified RWH one that I've been messing with?
08:14:48 <kmc> Andrew___C, do you have the file glib-2.0/glib.h anywhere on your system?
08:14:49 <aadrake> parcs`: Of course some is allocated, that's why I said effectively 0 :)
08:15:08 <ion> 0 FSVO 0
08:15:25 <parcs`> aadrake: i wrote a version using csv-enumerator
08:15:32 <parcs`> check it out here: http://paste.pocoo.org/show/525029/
08:15:34 <Andrew___C> kmc: yup. C:\Programs\prog\C\Gtk+\include\glib-2.0\glib.h
08:16:15 <kmc> did you try:  cabal install pango --extra-include-dirs=C:\Programs\prog\C\Gtk+\include
08:16:48 <Andrew___C> kmc: no - will do, thanks!.....
08:17:18 <kmc> you might also need --extra-lib-dirs down the line.  i'm not sure what the right directory for that one is
08:17:31 <kmc> perhaps C:\Programs\prog\C\Gtk+\lib
08:18:09 <parcs`> i wish there were a way to more efficiently print an MD5Digest instead of just using show
08:18:41 <aadrake> parcs`: Wow, this was a huge speedup over R
08:18:56 <aadrake> The R version was about 750 records per second.  Haskell is 8200.
08:20:05 <parcs`> nice!
08:20:18 <Andrew___C> kmc: you're a genius: we've broken through the preprocessing barrier - looking gooooooood....
08:20:33 <parcs`> > 1311827 / 75
08:20:34 <lambdabot>   17491.02666666667
08:20:34 <Andrew___C> kmc: yyyyyyyyyyyyyyyyyyyeeeeeeeeeeeeeeeeeeeeessssssssssssssssssssssss!!!!!!!!!!!!!!!!!!!!!!!
08:20:42 <Andrew___C> kmc: now gtk
08:20:47 <aadrake> parcs`: Nice indeed.  Especially since this was a subset of the files I normally get to play with.  Thank you for your help
08:21:06 <aadrake> Is there an advantage to your solution over the one that I have now?
08:21:38 <nexion> is it possible to catch exceptions outside of IO?
08:21:38 <parcs`> aadrake: it should be faster
08:21:52 <shepheb> I remember, a few years ago, there was a set of diagrams of monads and monad transformers showing how, for example, State threaded a value between all the branches of a recursive computation. I think they were on sigfpe's blog, but I'm not certain. I can't seem to find them on Google.
08:21:55 <parcs`> i am not by how much, though
08:21:58 <parcs`> not sure*
08:22:33 <kmc> nexion, not without cheating
08:23:01 <kmc> nexion, if that's what you want, you should represent failure using some data type like Maybe or Either
08:23:15 <kmc> instead of using runtime-system exceptions
08:23:55 <kmc> of course most of the time that question is asked here, the answer is "use reads instead of read"
08:24:06 <nexion> I'm using getWord8 in the Get monad which throws if there's no data to read
08:24:14 <kmc> that sucks
08:24:17 <nexion> I could check "remaining" before reading, but..
08:24:42 <aadrake> parcs`: Let me try it on my data real quick
08:24:46 <kmc> you can check isEmpty
08:26:07 <kmc> you can make a helper of type Get (Maybe Word8)
08:26:15 <aadrake> parcs`: The version I used took 365 seconds
08:26:24 <aadrake> I'm about to start yours
08:26:25 <nexion> I'm curious why catch is restricted to IO.. is it because the code might not be evaluated until it's printed?
08:27:44 <kmc> it would break referential transparency
08:28:13 <kmc> you can get an exception for running out of memory, or one thrown by another thread
08:28:40 <nexion> good point
08:28:40 <quicksilver> shepheb: that's very likely. sigfpe likes diagrams.
08:28:42 <ion> You should avoid exceptions outside IO altogether.
08:28:51 <kmc> if you had a function «catch :: a -> Maybe a» then the same call «catch x» could return Nothing or (Just _) depending on what some other thread does
08:28:53 <kmc> not ok
08:29:14 <kmc> even ignoring asynchronous exceptions, it would let you observe evaluation order
08:29:24 <kmc> > error "foo" + error "bar"
08:29:25 <lambdabot>   *Exception: foo
08:29:41 <ion> > error "foo" `seq` error "bar"
08:29:42 <lambdabot>   *Exception: foo
08:29:46 <quicksilver> shepheb: possibly this one? http://blog.sigfpe.com/2009/12/where-do-monads-come-from.html doesn't seem quite like your description.
08:29:57 <kmc> yeah, seq doesn't fix evaluation order either
08:30:04 <kmc> in the original paper on exception-handling in Haskell, the denotation of such an expression is a *set* of exceptions
08:30:16 <kmc> and 'catch' nondeterministically provides one of those exceptions
08:30:22 <kmc> which is why it needs to be in IO
08:30:24 <ion> Interesting
08:30:31 <kmc> otherwise many optimizations would be invalid
08:30:32 <parcs`> > 1311827 / 64
08:30:33 <lambdabot>   20497.296875
08:30:44 <ion> (the set thing)
08:31:14 <kmc> the only guarantee about seq is the denotational semantics:  seq ⊥ y = ⊥;  seq x y = y
08:31:31 <kmc> operationally it's allowed to force x before, after, or concurrently with forcing y
08:31:53 <kmc> so when you need to control the order of evaluation, use pseq instead
08:31:53 <ddarius> And in practice it does sometimes force y first.
08:32:04 <shepheb> quicksilver: yeah, I saw that one, that's not it. GIS with site:sigfpe.com didn't do it.
08:32:12 <quicksilver> ddarius: do you have an example?
08:32:23 <kmc> the point of 'seq' is to change the denotational semantics of your code, so that more optimizations become valid
08:32:30 <kmc> not to specifically control operational behavior
08:32:39 <kmc> though it's widely abused for that
08:32:40 <ddarius> monochrom posted an example on the mailing list a few years back.
08:33:01 <aadrake> parcs`: I compiled it the same way I did the other version, but the cpu usage on yours is a little lower (~105%) as compared to mine (~130%).  Do you suppose that's because yours is more efficient and therefore waiting on the HDD more than the other version?
08:33:03 * kmc wonders how the GHC implementations of seq and pseq differ
08:33:31 <ddarius> pseq is like seq but it annotates y as being lazy.
08:33:36 <parcs`> aadrake: i am not sure..
08:33:45 <parcs`> seems plausible
08:34:08 <aadrake> parcs`: I'm thinking a SSD is in my future
08:34:43 <aadrake> parcs`: My version was 365 seconds, your version is 188 seconds
08:35:09 <parcs`> ok, so about 2x the speedup
08:35:49 <aadrake> parcs`: Yup
08:36:07 <aadrake> parcs`: Mine was about 8200 records per second and yours is about 16000 records per second
08:36:29 <aadrake> Now what I need to do is store the output from both and compare it.  The output should be identical
08:37:45 <aadrake> parcs`: It's approximately 21x faster than the version in R
08:37:51 <parcs`> oh wait, i think i've found a potential optimization
08:38:03 <parcs`> MD5Digest has a Serialize instance
08:40:36 <aadrake> parcs`: I have no idea what that means
08:41:14 <quicksilver> it means you might be able to avoid the slow "show" call
08:41:20 <parcs`> http://paste.pocoo.org/show/525038/
08:41:27 <aadrake> quicksilver: I read that show was a big slowdown
08:41:36 <parcs`> aadrake: try running that.. by my tests it seems to be about %25 faster
08:41:39 <aadrake> quicksilver: I think one person said that after optimizations that was the bottlneck in their code
08:41:46 <kmc> Strings are big and slow
08:42:00 <kmc> in the best case though, 'print' might fuse with 'show'
08:42:10 <kmc> but that'll still be character-at-a-time
08:42:33 <parcs`> > 1311827 / 45
08:42:34 <lambdabot>   29151.71111111111
08:42:43 <parcs`> 30000 row per second
08:42:50 <quicksilver> it can be a bottleneck yes
08:42:58 <quicksilver> so can putStr / putStrLN
08:43:03 <quicksilver> (but bytestring hPut is good)
08:44:25 <aadrake> parcs`: Is the output binary?
08:44:37 <parcs`> aadrake: no
08:44:47 <parcs`> then again i haven't checked because i'm piping to /dev/null
08:45:00 <parcs`> otherwise my terminal becomes unresponsive
08:45:35 <aadrake> parcs`: Try head 1987.csv > mini1987.csv and then have a go on the smaller one.
08:45:52 <parcs`> oh, it is binary :(
08:46:01 <parcs`> well that sucks
08:46:50 <aadrake> parcs`: I may be able to read it into other stuff in binary form.  I haven't tried that yet.
08:47:26 <Eduard_Munteanu> Maybe you want to go through the Data.Text stuff instead of plain strings.
08:47:41 <Eduard_Munteanu> It's pretty much the text-oriented analog of bytestrings.
08:48:07 <parcs`> Eduard_Munteanu: we are serializing  an MD5Digest
08:48:23 <Eduard_Munteanu> Ah, nvm then :)
08:48:42 <parcs`> if you serialize it through show, it's converted to hexadecimal. if you serialize it through cereal, it's converted to binary
08:49:30 <Eduard_Munteanu> What's MD5Digest anyway? An Integer?
08:49:37 <kmc> which library?
08:49:45 <parcs`> puremd5
08:49:49 <roconnor> Eduard_Munteanu: Word160?
08:49:56 <parcs`> it's a (Word32, Word32, Word32, Word32)
08:50:00 <parcs`> or something
08:50:01 <Eduard_Munteanu> Heh.
08:50:13 <kmc> but it's opaque :/
08:50:35 * Eduard_Munteanu looks if it has a Storable instance or something.
08:50:38 <kmc> it does
08:50:41 <kmc> we were just talking about it.
08:50:49 <kmc> er, Serialize, sorry
08:51:02 <kmc> also Binary
08:51:08 <aadrake> parcs`: It's about a 20% improvement on my file
08:51:20 <aadrake> 157 seconds
08:51:33 <parcs`> aadrake: i got around the same improvement
08:51:39 <kmc> anyway it sounds like you want a function that converts a binary ByteString to an ASCII hexidecimal Text
08:52:28 <ryuk58> how can i turn this [[["lowly.mp3"],["2018 kB"],["MP3"],["lowly"],["yerzmyey"],["2003"],[""]]] into this [["lowly.mp3","2018 kB","MP3","lowly","yerzmyey","2003",""]]
08:52:30 <Eduard_Munteanu> kmc: since it's Word32-based I guess an unrolled variant that used bitops on that would be faster
08:52:30 <kmc> (that is, hexidecimal using the characters in ASCII)
08:52:43 <kmc> > concat [[["lowly.mp3"],["2018 kB"],["MP3"],["lowly"],["yerzmyey"],["2003"],[""]]]
08:52:44 <lambdabot>   [["lowly.mp3"],["2018 kB"],["MP3"],["lowly"],["yerzmyey"],["2003"],[""]]
08:52:45 <parcs`> binary -> hexadecimal bytestring would suffice
08:52:50 <aadrake> parcs`: It works out to about 19,100 records per second
08:52:51 <kmc> > concat $ concat [[["lowly.mp3"],["2018 kB"],["MP3"],["lowly"],["yerzmyey"],["2003"],[""]]]
08:52:52 <lambdabot>   ["lowly.mp3","2018 kB","MP3","lowly","yerzmyey","2003",""]
08:53:10 <kmc> i don't like "hexidecimal bytestring" because you're using bytestring to represent text
08:53:14 <kmc> but it might be fastest
08:53:17 <ryuk58> k thx
08:53:20 <parcs`> this is about speed :P
08:53:37 <kmc> everything's about speed to some degree
08:53:40 <kmc> there's always a tradeoff
08:54:35 <parcs`> i don't see a tradeoff in the case of md5
08:54:40 <aadrake> parcs`: I'm looking forward to testing this on a full size data set
08:54:52 <kmc> if speed is your only goal then you should fabricate a custom ASIC
08:55:03 <srhb> ASIC?
08:55:09 <c_wraith> custom chip
08:55:11 <c_wraith> hardware
08:55:14 <srhb> Haha, okay.
08:55:20 <kmc> btw, the 'ascii' library provides a type for ASCII text
08:55:31 <kmc> implemented with ByteString
08:55:45 <c_wraith> Oh, that's handy.
08:56:15 <roconnor> omg, haskell record updates can change the type!
08:56:29 <Eduard_Munteanu> Sure :P
08:56:36 <kmc> not much of an API but it at least gives you a distinct type for "ASCII text" versus "just some bytes"
08:57:03 <Eduard_Munteanu> I wonder if there's a reasonable usecase for that though.
08:58:26 <c_wraith> roconnor: they can?  I could swear I've run into type errors because they can't
08:58:42 <roconnor> data R a = R { x :: a }
08:58:43 <roconnor> upd :: R Int -> R Bool
08:58:45 <roconnor> upd r = r { x = True }
08:58:54 <c_wraith> Huh.
08:59:10 <c_wraith> I wonder if that works because it's the only field in the record
08:59:25 <roconnor> I don't get that impression
08:59:26 <Eduard_Munteanu> Not AFAIK.
08:59:47 <c_wraith> strange.   wonder what the problem I actually ran into was, then.
09:00:23 <Eduard_Munteanu> c_wraith: I've seen people complain GHC couldn't infer the type of some expression
09:00:29 <c_wraith> oh, maybe that was it
09:00:39 <Eduard_Munteanu> (since the type wasn't constrained because of records changing types)
09:00:47 <aadrake> parcs`: I have to head out since it's about 1830 here.  Thank you again for the help.
09:00:51 <c_wraith> because it was just a subexpression in a larger function body
09:01:00 <Eduard_Munteanu> Yeah.
09:01:05 <quicksilver> I think it might be a GHC extension that it can do that
09:01:15 <quicksilver> perhaps even an accidental GHC extension
09:01:25 <quicksilver> a corrolary of the way they happen to desugar
09:01:34 <quicksilver> but it's been kept now because it's useful?
09:01:42 <Eduard_Munteanu> I kinda want that in Agda though, since it makes a bit more sense in the context of dependent types.
09:02:07 <c_wraith> I don't see why type inference would fail, though
09:02:29 <c_wraith> it seems like all the necessary information would be present
09:02:57 <parcs`> aadrake: no problem. take care
09:03:19 <Eduard_Munteanu> c_wraith: I guess it could assume you don't change types but I'm unsure
09:03:38 <Eduard_Munteanu> (just assume, not actually enforce that)
09:04:05 <c_wraith> I'm sure it's something like that...  Assuming you don't mean to change types, unless you explicitly annotate that you do.
09:05:03 <Eduard_Munteanu> Also if a certain value is totally optimized out then maybe the typechecker shouldn't complain.
09:05:20 <Eduard_Munteanu> But again, I'm not sure how easy that is to accomplish.
09:06:01 <Saizan> if you have r :: R 'A where 'A is a meta-variable, and use only r {x = True} then you won't get any more constraints about 'A, and if your whole expression can't generalize on 'A and you have a context like Foo 'A you get an ambiguous type variable error
09:06:02 <kmc> it would be very bad if types don't get checked because of optimizations
09:07:19 <Saizan> without the context it'll "default" 'A to Any, i think
09:07:27 <Eduard_Munteanu> kmc: AFAIU typing in this context is necessary to interpret that value, but if the value is irrelevant, and the type is too, then ambiguity shouldn't matter, perhaps.
09:12:58 <Eduard_Munteanu> Well, maybe I should take that back though, I'm not really sure that's sound.
09:18:00 <Saizan> http://hpaste.org/55652
09:31:43 <OscarZ> if I have two lists of a custom type [MyType] and I'd like to get all pairs between the two lists that satisfy some predicate.. there's probably some ready function for this?
09:33:09 <c_wraith> OscarZ: that's probably best-written as a comprehension
09:33:48 <OscarZ> c_wraith: of course.. thanks
09:35:23 <Andrew___C> kmc: gtk finished installing! it worked! you're my hero! thank-you thank-you thank-tou!
09:40:47 <_|ur1> Hi
09:41:24 <_|ur1> May I ask for help in some basic stuff?
09:41:57 <hpc> _|ur1: i suppose that's better than "can i ask a question" :P
09:42:05 <hpc> _|ur1: ask away
09:42:56 <_|ur1> it is about mirroring a "Rose". The data Structure is like that: data Rose a = Node a [Rose a]  deriving (Eq, Show)
09:43:26 <_|ur1> i made some tries, but there is somehow a recursion level missing
09:43:51 <_|ur1> it looks like this
09:43:52 <_|ur1> mirror :: Rose a -> Rose a
09:43:52 <_|ur1>     mirror (Node label []) = Node label []
09:43:52 <_|ur1>     mirror (Node label xl) = Node label (reverse xl)
09:44:40 <_|ur1> i guess, i have to call mirror again on xl, but my tries give me just errors
09:44:53 <hpc> morror (Node l xs) = Node l (reverse . map mirror $ xs)
09:45:15 <hpc> :t map
09:45:15 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:45:18 <hpc> :t map ?mirror
09:45:19 <lambdabot> forall a b. (?mirror::a -> b) => [a] -> [b]
09:45:37 <hpc> in this case, the 'a' and 'b' types are both 'Rose a'
09:45:42 <hpc> mirror :: Rose a -> Rose a
09:45:49 <hpc> map mirror :: [Rose a] -> [Rose a]
09:46:08 <hpc> and that should mirror the whole tree
09:46:22 <_|ur1> ok, let me try
09:48:16 <_|ur1> thx
09:48:54 <_|ur1> what do the "." and "$" operators make?
09:49:12 <hpc> (.) is the composition function
09:49:18 <hpc> (f . g) x = f (g x)
09:49:33 <hpc> and ($) is function application, with a very low precedence
09:49:38 <parcs`> "reverse . map mirror $ xs" can be written as "reverse (map mirror xs))" if you like
09:49:44 <hpc> they're just tricks to get rid of some parens
09:49:50 <hpc> in this context, anyway
09:50:27 <_|ur1> thx. that's why i'm asking. I can't start with tricks, without knowing the basics :)
09:51:29 <hpc> _|ur1: keep those functions in mind, as they have a habit of coming up often and making lots of code much shorter
09:51:32 <hpc> for instance
09:52:14 <hpc> > let withWords f = unwords . map f . words in withWords reverse "each word in this will be reversed"
09:52:16 <_|ur1> lambdabot: thank you too, but i descided to take the other sollution because we were working with recursion in the class
09:52:16 <lambdabot>   "hcae drow ni siht lliw eb desrever"
09:52:46 <hpc> compare with, withWords f xs = unwords (map f (words xs))
09:53:25 <aristid> proof that point-free style is more readable!
09:54:33 <_|ur1> i wanted to say the same. for me as a beginner it is more readable to use parens
09:57:56 <monochrom> I don't use $ unless it is of the kind "withFile x $ \y -> do ..."
09:58:55 <ion> I dislike the fact you need to use $ in there.
09:59:04 <hpc> agreed
09:59:05 <ion> I’d prefer “withFile x \y -> …”
09:59:38 <ion> Hmm. If the parser was changed to support that, would *any* code break?
09:59:50 <hpc> i don't think so
10:00:34 <parcs`> i wonder why the parser doesn't support that
10:00:45 <parcs`> i bet there's a good reason
10:00:54 <ion> Also: fooBar do …
10:01:37 <parcs`> > do do do do 5
10:01:38 <lambdabot>   5
10:01:52 <parcs`> consecutive 'do's don't have to be delimited
10:02:49 <ion> > do not otherwise
10:02:50 <lambdabot>   False
10:03:18 <parcs`> > do not do otherwise
10:03:18 <lambdabot>   <no location info>: parse error on input `do'
10:03:25 <parcs`> > do not (do otherwise)
10:03:26 <lambdabot>   False
10:08:48 <drdo> network package is crazy about endianess
10:09:43 <c_wraith> since the network is the only place where you *really* should care about endianess, that seems right.
10:10:53 <drdo> c_wraith: I don't mean crazy as in "it cares", i mean crazy as in crazy behaviour
10:11:02 <c_wraith> oh
10:11:13 <drdo> spend like 2 hours going insane about why it could never connect
10:12:03 <monochrom> I don't seem to observe crazy behaviour. has always worked for me, with little effort.
10:12:36 <c_wraith> well, there's the fact that several of the types are bizarre
10:12:38 <drdo> I'm reading Word32's in BE and naturally they are converted to Host order
10:12:47 <ion> I don’t see endianness. Our society is plagued by endianness racism. All bytes are precious.
10:12:48 <c_wraith> and should never be constructed with their constructors
10:13:04 <drdo> but then network expects BE
10:13:08 <c_wraith> because the constructors make implicit endianness assumptions
10:13:18 <drdo> and I still can't figure out the port thing
10:13:24 <parcs`> all bytes are equal, but some bytes are more equal than others
10:13:28 <c_wraith> :t fromEnum
10:13:28 <lambdabot> forall a. (Enum a) => a -> Int
10:13:45 <drdo> it converts the endianess sometimes and sometimes not really
10:13:50 <c_wraith> use toEnum to construct Port, I think is what is guaranteed to work cross-platform
10:14:04 <ion> @check \a b -> (a :: Word8) == b  -- is lambdabot a racist?
10:14:04 <lambdabot>   Not in scope: `myquickcheck'Not in scope: type constructor or class `Word8'...
10:15:20 <aristid> @check \a -> a == a
10:15:20 <lambdabot>   Not in scope: `myquickcheck'Not in scope: `=='Not in scope: `$'
10:15:23 <aristid> OMG
10:15:26 <drdo> Why not do the easy, predictable thing and just take everything in host order and be portable? :S
10:16:25 <monochrom> in some programs I have hardcoded port numbers, and I just write "PortNumber 33401". it's a Num instance. in some other programs I use fromIntegral.
10:17:17 <drdo> I was using getWord32be from cereal to get addresses, and naturally it converts to host order
10:18:04 <monochrom> taking everything in host order is "easy, predictable" for one party by shoveling the problem to other parties.
10:18:50 <monochrom> oh, wait, sorry, I misread. taking everything in network order shovels the problem to other parties.
10:19:04 <drdo> monochrom: The nice easy thing is to keep everything in host order and not have to worry if some data is supposed to be in this order or that order
10:19:18 <drdo> and just worry when reading data
10:19:22 <monochrom> but AFAIK network already takes everything in host order and does the network order conversion.
10:19:35 <drdo> no it doesn't
10:19:54 <drdo> not addresses anyway
10:20:06 <monochrom> "getWord32be from cereal" doesn't sound like from the network package
10:21:06 <abc> abc
10:22:52 <Phlogistique> .
10:31:29 <abc> boring
10:31:50 <Aune> Why doesn't this work:    (apply (lambda (x) (map circle x)) '(10 20))     ? I get "expected one argument given two: 10 20", but what I want to do is pass a list to my function and map over it.
10:32:39 <shachaf> Aune: Probably because it's Scheme.
10:32:45 <shachaf> Scheme is rarely valid Haskell. :-)
10:33:14 <Aune> Well, yeah, so, what am I not understanding here?
10:33:33 <shachaf> Aune: If you just want to call the function with the argument, you can just ((lambda (x) (map circle x)) '(10 20))
10:33:36 <shachaf> (I imagine.)
10:34:44 <shachaf> Aune: (Also, I note that you're in both #haskell and #scheme. This is #haskell.)
10:34:57 <Aune> Hmmm, darn
10:35:06 <Aune> Wrong window ^^
10:35:06 <abc> let's just do (map circle '(10 20))
10:35:41 <monochrom> "apply" probably means something else
10:35:48 <shachaf> abc: Well, sure, but I imagine Aune was testing something about lambdas.
10:35:49 <byorgey> > ($) (\x -> map f x) [10,20]
10:35:49 <lambdabot>   Ambiguous type variable `b' in the constraints:
10:35:50 <lambdabot>    `SimpleReflect.FromExpr ...
10:35:54 <drdo> monochrom: getWord32be reads 4 bytes in BE and gets you a proper Word32 in host order
10:37:32 <Aune> I was actually playing around with lambdas and folds yes, also I might have completely misunderstod what apply is for
10:38:10 <shachaf> > (apply (lambda (x y z) (list x y z)) '(1 2 3))
10:38:10 <shachaf> (1 2 3)
10:38:11 <lambdabot>   <no location info>:
10:38:11 <lambdabot>      lexical error in string/character literal at chara...
10:38:59 <abc> ah... reminds me of those good old days in college banging my head on a solaris terminal just to figure out I missed a right parent
10:39:08 <ddarius> Aune: apply is not id in Scheme, but, at any rate #scheme.
10:39:39 <Aune> ddarius, point take
10:41:31 <abc> let me ask you guys, does these lisp-like language have any commercial use?  besides giving college kids headachs?
10:41:52 <lpsmith> abc, that's why you use a scheme-compatible text editor such as Emacs when you edit scheme.   You can find those missing right parens very easily with automatic matching/automatic reindentation.
10:42:14 <drdo> abc: No, java is the shit, go use java
10:42:19 <Sgeo> :t liftM
10:42:19 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:42:20 <lpsmith> abc,  absolutely,  definitely more than Haskell at the moment,  though that might be changing.
10:42:25 <monochrom> yes, Paul Graham uses them for commercial use
10:42:32 <jessopher> lol
10:42:39 <lpsmith> heh
10:43:15 <lpsmith> Lisp is Paul Graham's blub.    Haskell is kind of my blub.
10:43:27 <abc> yep, love/hate java...
10:43:44 <byorgey> lpsmith: lisp-like languages have more commercial use than Haskell?
10:43:47 <sanjoyd> Suggestions for a Haskell web framework?
10:43:49 <drdo> So is there anything i can use to convert Word32 endianess?
10:43:56 <lpsmith> byorgey, yeah, I'm pretty sure they do.
10:44:13 <jessopher> not in an intrinsic sense, in an actual commercial use sense
10:44:15 <monochrom> at least Paul Graham is more famous than every Haskeller
10:44:20 <abc> good question sanjoyd, co-ask
10:44:37 <monochrom> yesod is a good Haskell web framework
10:45:50 <sanjoyd> monochrom: PG is more famous for his YC work than his hacking.
10:45:55 <sanjoyd> (I think.)
10:45:58 <kmc> Lisp is much older than Haskell
10:46:15 <monochrom> yes, but then that makes him famous
10:46:58 <monochrom> at any rate he does brag about using lisp or whatever for his own commercial use
10:47:25 <aristid> i think it was lisp
10:47:40 <kmc> yeah, ViaWeb was written in lisp
10:47:49 <monochrom> but perhaps one day you blow his cover and shows that he uses PHP all along and it's a big scandal
10:47:55 <kmc> i think its commercial success has little to do with the choice of language
10:48:15 <kmc> and i think the success or failure of companies using haskell today has little to do with the technical properties of the language
10:48:17 <kmc> but that's life
10:48:22 <aristid> monochrom: apparently part of the source code of hacker news is available, and it's arc (his own lisp dialect)
10:48:30 <monochrom> yes, I was about to say, if you're good you can use bloody anything for commercial use
10:49:05 <kmc> the big non-technical benefit of using Haskell (or other weird languages) is that it attracts good programmers
10:49:15 <kmc> and you can pay them relatively less, because they enjoy the job that much more
10:49:32 <benmachine> kmc: why do you think the technical properties are unimportant?
10:49:44 <abc> but if you're trying to staff a team,  you'll have hard time finding someone
10:49:48 <jessopher> if you can manage to get enough of them
10:50:13 <aristid> \
10:50:26 <aristid> sorry
10:50:30 <monochrom> drdo: I am reading network source code. it takes port numbers in host order and converts to network order. intToPortNumber v = PortNum (htons (fromIntegral v)). intToPortNumber is used by the Enum instance and Num instance etc
10:50:42 <kmc> http://www.lucduc.com/2010/10/equation-of-finding-top-notch.html
10:51:07 <kmc> abc, it depends what kind of team you need
10:51:15 <drdo> monochrom: It's weird, if i use PortNum i don't get conversion, if i don't, i do
10:51:32 <drdo> But for addresses i never get
10:51:40 <drdo> And i can't find anything to convert it
10:51:40 <ddarius> Arc is a joke.  At least it's a funny joke.
10:51:41 <rwbarton> the weird thing is that the PortNum constructor is exported at all
10:51:50 <rwbarton> is there a good reason for that?
10:52:02 <drdo> I can't think of any
10:52:27 <kmc> benmachine, because technical success is only a small part of business success, and choice of tools is only a small part of technical success
10:52:38 <monochrom> well then, don't use PortNum? which is what c_wraith said. <c_wraith> and should never be constructed with their constructors <c_wraith> because the constructors make implicit endianness assumptions
10:52:46 <jeff_s_> Are there any newer developments for subtyping than what was presented in the OOHaskell paper?
10:52:47 <parcs`> sanjoyd: happstack
10:52:51 <drdo> monochrom: The problem is not ports
10:52:54 <drdo> it's addresses
10:53:07 <drdo> I don't get conversion for addresses
10:53:17 <benmachine> kmc: hmm. I suppose so, but presumably it has /some/ effect
10:53:20 <kmc> yeah
10:53:25 <kmc> i agree it has some effect
10:53:28 <kmc> if i said otherwise, i misspoke
10:53:50 <drdo> I'd say it has way more effect than you guys are saying it does
10:54:04 <benmachine> kmc: you didn't say otherwise, I just wanted to clarify :)
10:54:05 <kmc> also there are many negatives for using haskell commercially
10:54:08 <drdo> Not directly because of the technical aspects, but because people will be that much happier
10:54:09 <kmc> in addition to the positives
10:54:13 <drdo> and that leads to better work
10:54:33 <kmc> drdo, personally, I am happy when I work with smart people.  the language is secondary to that
10:54:51 <kmc> the last job I had, I was programming mainly Python and systems-level C, at a company where most of the developers know Haskell
10:54:56 <kmc> that was great
10:55:03 <drdo> kmc: It's the same for me, but there's a limit
10:55:25 <kmc> granted there are some tools which are so bad they'd be a dealbreaker
10:55:40 <kmc> but i think smart people won't work at such a company, anyway
10:56:33 <drdo> Pretty please someone tell me how to convert Word32 to big endian :(
10:56:40 <dzhus> does anyone got idea if hmatrix can into cross product?
10:57:48 <kmc> drdo, http://hackage.haskell.org/packages/archive/storable-endian/0.2.5/doc/html/Data-Storable-Endian.html
10:58:01 <kmc> also http://hackage.haskell.org/packages/archive/binary/0.5/doc/html/Data-Binary.html "Values are always encoded in network order (big endian) form"
10:58:03 <monochrom> drdo: I concede that the HostAddress type takes network order
10:58:08 <znutar_> the whole angle of trying to find "top notch" people to work at some place for "reasonable" rates always feels scammy to me.
10:58:54 <rwbarton> if you are getting your Word32 from binary, use getWord32host maybe?
10:59:00 <jeff_s_> A reasonable price for top notch people is a top notch price.
10:59:14 <znutar_> Usually if the place is doing something amazingly cool enough that really wonderful folks will take a big pay cut to work there, word will get around among the top notch people
11:00:39 <ddarius> There are other ways of providing value beyond rates.
11:01:34 <kmc> rather than saying "you can get good people for less if you have cool stuff to work on" i think it's more fair to say "you can keep good people at a bad job a bit longer if you pay them a lot"
11:01:49 <kmc> (particularly if you have a yearly bonus cycle, go finance industry!)
11:03:02 <lpsmith> yeah,  it takes some combination of money,  projects,  and co-workers and other working environment issues to attract and retain top employees.  Deficiencies in one area can be made up, to an extent,  by strengths in others.
11:03:10 <kmc> also if what your company does is unusual, then it's harder for your employees to "comparison shop"
11:03:58 <drdo> I'd say the most important attribute is just for your company to work on interesting stuff
11:04:11 <kmc> i think it's funny all these startups looking for world-class epic ninja olympic-class rockstar geniuses to make a webapp in Rails and connect it to a MySQL database
11:04:26 <drdo> Most good people will work for a bit less money if they get to work on stuff they find interesting
11:04:46 <jessopher> yeah, this all relies on some meaningful qualification of 'top notch' anyhow
11:04:56 <lpsmith> drdo, that's often used as an excuse by employers not to pay right.   The key is "a bit less", not "a lot less".
11:04:57 <kmc> i'll grant that having the best people does help with this task, but it's basically the same as what everyone else is doing, so you will lose out to whoever has the most VC funding for inflated salaries
11:05:24 <alistra> @hoogle io
11:05:25 <lambdabot> Prelude data IO a :: * -> *
11:05:25 <lambdabot> System.IO data IO a :: * -> *
11:05:25 <lambdabot> Prelude type IOError = IOException
11:05:25 <drdo> lpsmith: yes, a bit less, most people won't starve just to work on interesting stuff :P
11:05:33 <kmc> *cough* grad school
11:05:40 <alistra> @hoogle monadio
11:05:40 <lambdabot> Control.Monad.IO.Class class Monad m => MonadIO m
11:05:40 <lambdabot> package monadIO
11:05:45 <parcs`> data IO a :: * -> * what
11:05:55 <kmc> heh
11:06:20 <ddarius> kmc: In theory, the value in grad school is the degree.
11:06:29 <ddarius> That is how you are getting "paid."
11:06:55 <kmc> in theory, but in practice most of my grad student friends see it as a way to work on cool stuff and delay the real world for a while
11:07:02 <kmc> maybe this says something about my friends
11:07:11 <parcs`> isn't vc funding only like 20k? at least that's how much YC funds
11:07:11 <drdo> kmc: That seems about right
11:07:14 <ddarius> (In practice, there are other things that are actually valuable [including interesting work topics], and the degree isn't as valuable as advertised for at least our field.)
11:07:18 <mee> that made sense in 2009 when no one was hiring.
11:07:19 <kmc> parcs`, YC is the very earliest stage
11:07:23 <drdo> "delay the real world and get to work on your pet projects"
11:07:29 <drdo> is what it's really all about
11:07:35 <parcs`> kmc: ah..
11:07:37 <kmc> parcs`, later funding rounds will be many millions
11:07:42 <ciaranm> YC is basically a scam
11:07:47 <c_wraith> parcs`: as opposed to the company I'm at, which got 15.5M in its last round
11:07:51 <kmc> with YC the money is not the point... the value is supposed to be that you meet all these Valley insiders through PG etc.
11:07:51 <ddarius> kmc: So the question will be what happens to them when they finally fail to delay the real world.
11:08:13 <drdo> ddarius: they delay more by getting a phd
11:08:31 <drdo> then they delay indefinetly by going into research/teaching
11:08:41 <parcs`> so YC gives some guys 20k and then they get a fixed percentage of profits from that startup forever?
11:08:44 <kmc> if you just want $20k to work on a personal project for a summer, work at Facegooglezon for a year
11:08:56 <ciaranm> YC gives you a pittance and then owns you
11:08:57 <kmc> parcs`, not a percentage of profits; they get equity
11:09:13 <drdo> parcs`: Wait, YC is just 20k ?
11:09:30 <parcs`> drdo: that's what i read
11:09:38 <ddarius> Hopefully they get a pittance in equity.
11:09:42 <drdo> How much equity do they get?
11:09:46 <kmc> they get about 1% i think
11:09:50 <znutar_> I read something like $20k for 5% but that was a while back
11:09:50 <drdo> ah
11:10:05 <kmc> i doubt it's as much as 5%
11:10:24 <drdo> For some reason i had it my mind that YC was 250k
11:10:31 <kmc> no
11:10:35 <kmc> like i said, the money isn't the point
11:10:42 <drdo> Now i see it
11:10:49 <drdo> 20k is not even worth the effort
11:10:51 <kmc> it's just so you don't have to worry about paying for rent and ramen noodles
11:11:01 <kmc> they want you to focus on the company
11:11:20 <kmc> if people have to take side jobs to make ends meet, they don't commit to the startup
11:11:20 <ciaranm> they want a cheap way of getting a large stake in everything in case someone succeeds
11:11:22 <ddarius> "A wise man knows everything.  A shrewd one, everybody."
11:11:26 <mee> also the press and connections you get are probably more valuable
11:11:33 <kmc> yes, that is entirely the point
11:11:37 <kmc> and i'm not sure that's worth it, either
11:11:47 <kmc> but to the extent YC is worth it, it's for the press and the connections
11:11:55 <copumpkin> ddarius: augur would like that sentence
11:12:08 <copumpkin> the second, one, that is
11:12:08 <ddarius> copumpkin: It came from a fortune cookie I just ate.  It seems apropos.
11:12:10 <drdo> I'm fascinated by these web startups
11:12:11 <copumpkin> -,
11:12:14 <drdo> I really don't understand it
11:12:27 <znutar_> "Y-Combinator invests about $18,000 per company for the session, and asks an equity stake that averages about 6 percent." from some inc.com slideshow in 2010
11:12:32 <kmc> huh
11:12:35 <parcs`> lol
11:12:42 <kmc> i read it was less, was trying to find the source
11:12:44 <mee> the bay area is crazy.
11:13:20 <kmc> it definitely annoys me how PG et al. play up their idea of "the startup" as an integral part of "nerd culture"
11:13:30 <kmc> like you're not a real hacker unless you've started a company by the age of 15
11:13:35 <drdo> lol
11:13:36 <copumpkin> it's true
11:13:42 <c_wraith> yes, it's best to just ignore those people.
11:13:44 <znutar_> It's an integral part of post dot-com wheeling and dealing culture, for sure
11:13:46 <kmc> they want to capture the minds of young, naive people
11:14:10 <kmc> the alternative is to work a few years before starting your own company
11:14:19 <kmc> then you don't need to sell 6% equity for $18k
11:14:29 <c_wraith> anyone who analyzes college in terms of solely money spent, opportunity cost, and change in future earnings...  Completely ignoring the point of life :)
11:14:30 <kmc> and you can make contacts along the way, if you're good at that kind of thing
11:14:52 <kmc> c_wraith, that's an interesting point, because I actually think that doing a startup is a "lifestyle expense" for a lot of people
11:14:54 <mee> also find out that your idea was really bad :)
11:15:14 <c_wraith> kmc: yes, they don't seem to realize that there are other acceptable lifestyle expenses
11:15:23 <kmc> like cocaine
11:15:29 <znutar_> people that have a life are unfortunately more expensive because they do things outside work, though
11:15:47 <kmc> anyway i see the appeal of living with your friends and working all day and all night on something you care about.  it's a lot like college, really
11:16:03 <c_wraith> less booze, more responsibility
11:16:05 <kmc> i think that makes *more* sense as a lifestyle expense, and less as a rational investment
11:16:08 <ciaranm> college involves working on something you care about?
11:16:13 <kmc> sometimes
11:16:19 <znutar_> I cared about getting laid
11:16:19 <drdo> where is that college?
11:16:20 <XniX23> rarely
11:16:38 * ciaranm seems to recall it being about doing enough of the "mandatory" classes to be able to do the interesting ones
11:16:39 <c_wraith> Most of the time I remember from college was actually doing interesting projects.
11:16:51 <c_wraith> but I'm really good at forgetting things I don't care about
11:16:52 <drdo> i'm in college in CS
11:16:53 <mee> yeah, college was awesome. I miss it.
11:16:57 <drdo> I rarely go there
11:17:16 <drdo> I just show up to take tests
11:17:17 <mee> of course, I didn't study CS. I might feel differently if I had
11:17:28 <copumpkin> I enjoyed it
11:17:37 <copumpkin> I just wish I'd gotten more haskelly goodness
11:17:44 <ciaranm> if you do "CS" you don't do "CS". you do software engineering with a bit of CS thrown in if you're lucky...
11:17:56 <kmc> depends on the school
11:17:57 <copumpkin> ciaranm: I did a fair amount of CS
11:18:04 <kmc> where i went it was almost the opposite
11:18:05 <drdo> ciaranm: It's about half here
11:18:22 <kmc> nobody taught us good engineering or how to use version control or how to work with other people and maintain a schedule
11:18:25 <kmc> i think we suffered for that
11:18:29 <copumpkin> ciaranm: we had no C++, no course for "software engineering", no mention of design patterns anywhere
11:18:32 <copumpkin> ciaranm: etc.
11:18:37 <kmc> likewise nobody taught languages, they just expected you to learn them on your own
11:18:43 <drdo> kmc: That's the right thing to do
11:18:45 <copumpkin> ciaranm: at least three courses with no programming at all
11:19:01 <drdo> copumpkin: what?
11:19:07 <drdo> 3?
11:19:08 <copumpkin> I took a languages course but it was nothing like what I'd consider real PL
11:19:20 <copumpkin> drdo: yeah, maybe more
11:19:22 <kmc> drdo, I don't necessarily agree.  i think even a very CS-oriented program benefits from a small class where people are like "hey, here's how to use git.  here's how to set up a wiki and a bug tracker.  you should do this for any project"
11:19:23 <drdo> We have about half with no programming
11:19:24 <mee> ciaranm: true, but I like engineering, too.
11:20:11 <drdo> we basically get the same as everyone else, analysis, differential equations, probability/statistics, physics, etc....
11:20:23 <copumpkin> oh, I meant CS stuff
11:20:31 <daimrod> kmc: some universities give this kind of courses.
11:20:36 <ciaranm> software engineering is about replacing the possibility of complete failure with the probability of mediocrity, replacing skilled programmers with minimum wage replaceable parts programmers and replacing responsibility with lack of liability
11:20:36 <copumpkin> I had to take a lot of general courses
11:21:04 <Andrew__C> drdo: you should get algebra too. algebra thinking is good for understanding functional programming
11:21:06 <mee> that's quite the cynical view.
11:21:12 <drdo> Andrew__C: Yes we had that
11:21:16 <drdo> first year first semester
11:21:32 <drdo> Andrew__C: You get functional programming right away
11:21:32 <rostayob> my university has both, if you want you can go almost fully theorethical
11:21:45 <rostayob> but there is a mandatory softeng course every term
11:21:47 <drdo> the introductory course uses scheme and doesn't get into mutation until almost the end
11:21:50 <rostayob> which is pretty crap actually
11:22:24 <rostayob> but there are awesome courses, like a 3rd year undergraduate course only on type systems, which is quite rare I think
11:22:45 <kmc> ciaranm, wow
11:22:49 <Andrew__C> drdo: goodo. I only met fp in my second year, they made me learn modula 2 (a pascal derivative) in 1st yr CS, but the algebraic thinking made fp sooo easy for me compared with the straight CS undergrads
11:23:06 <drdo> Andrew__C: It wasn't that interesting for me
11:23:10 <rostayob> i met Haskell in my first day of uni :P
11:23:15 <drdo> I had already read SICP before going to college
11:23:27 <rostayob> first lecture, haskell, bam
11:23:41 <kmc> ciaranm, is that actually how you feel about the entire idea of "software engineering", or just what's taught under that name currently?
11:24:07 <drdo> kmc: The whole thing is rotten
11:24:18 <kmc> 'cause I'm pretty sure that software is in fact an engineered artifact, and that we ought to be able to come up with principles for engineering it in a not-shitty way
11:24:20 <ciaranm> kmc: it's how i feel about the thing that NATO started that corporate software development picked up
11:24:27 <kmc> just like any other engineered artifact
11:24:58 <kmc> i hear arguments to the contrary but they usually boil down to "i'm a hacker and hacking is just like making a beautiful painting and how dare you call my art engineering"
11:25:00 <ciaranm> people forget that "software engineering" was invented by the military as a way of avoiding having to deal with programmers
11:25:00 <kmc> which is stupid
11:25:11 <rostayob> softeng is a craft but it's very different from mechanical engineering, or civil
11:25:38 <drdo> kmc: It's way worse to force people on known to be bad ways
11:25:49 <kmc> anyway everything you said software engineering stands for makes business sense in many contexts
11:25:57 <bd_> kmc: software engineering is a much newer craft than regular engineering
11:26:04 <kmc> businesses indeed prefer likely mediocrity to the possibility of complete failure
11:26:09 <ciaranm> good programmers are expensive, so software engineering is about how to get away with having cheap, bad programmers
11:26:14 <bd_> with normal engineering you have standardized practices because you're basically building the same thing over and over again
11:26:27 <kmc> bd_, right, that's why we aren't any good at it yet, but it doesn't mean there's nothing to be good at
11:27:03 <bd_> kmc: sure. but it might take quite a while to get to the same level of standardization as regular mechanical engineering or architecture :)
11:27:08 <kmc> sure
11:27:12 <znutar_> I'm always surprised that people draw parallels with things like mechanical engineering, but not with computer hardware
11:27:31 <kmc> "hacker culture" seems to have bought into the idea that programming is an irreducible, mystical art, and the idea that good programmers are a bazillion times more productive than average programmers
11:27:37 <rostayob> znutar_: computer hardware is not softeng
11:27:43 <kmc> these things make you feel good if you are a self-identified "hacker"
11:27:48 <bd_> rostayob: well, VHDL and the like blur the lines a birt
11:27:49 <bd_> bit*
11:27:52 <kmc> if you believe in these things then there is little point to software engineering
11:28:01 <kmc> but I think they're bullshit
11:28:06 <rostayob> bd_: true... and that's why you usually do parallels with mecheng :P
11:28:09 <drdo> software engineering is a lot like religion
11:28:23 <drdo> they keep preaching even though it's fairly obvious they are wrong
11:28:26 <copumpkin> yeah, cause yours is wrong and mine is right
11:28:30 <mreh> polemical
11:28:32 <irene-knapp> I dunno? the productivity difference between a good programmer and a bad programmer is higher than it is in other disciplines, I think
11:28:36 <irene-knapp> maybe not a bazillion
11:28:36 <copumpkin> dumbass, you're going to hell for writing that code
11:28:44 <tarmstrong> drdo: no, that's what an absence of software engineering is.
11:28:59 <tarmstrong> drdo: although it's often called software engineering...
11:29:12 <ciaranm> if producing buggy code had consequences, the difference between a good programmer and a bad programmer would stand out a lot more
11:29:28 <irene-knapp> ciaranm: yes, heh.  well it DOES - just not for the person who writes it!
11:30:14 <kmc> http://www.readability.com/articles/5egv0hme?legacy_bookmarklet=1 "Fact and folklore in software engineering"
11:30:24 <mee> I think we're still very much figuring out how to write and engineer software -- this makes it an interesting/good time to be in the field
11:30:52 <kmc> this basically debunks the claim that good programmers are 10x more productive than average
11:31:03 <irene-knapp> I dislike this guy's example, haha
11:31:09 <kmc> shows that there's no justification for the claim
11:31:17 <irene-knapp> he takes as an example of a scientific fact that water boils at 100 degrees Celsius
11:31:36 <irene-knapp> unfortunately for the example, that is the definition of the Celsius scale, not something that needs to be established!
11:31:52 <Saizan> anyhow the fact that engeneering feels like religion is pretty consistent with its immaturity, so you actually agree on something
11:31:52 <tarmstrong> also a good article: http://www.americanscientist.org/issues/id.13845,y.0,no.,content.true,page.1,css.print/issue.aspx
11:31:58 <irene-knapp> anyway, reading the rest of it, or at least skimming
11:32:23 <kmc> certainly the worst programmers are net negative, so it's not hard to beat that by a factor of 10 or more :)
11:32:31 <irene-knapp> okay, so, hmm
11:32:33 <kmc> and maybe the best 0.001% of programmers are amazing
11:32:34 <irene-knapp> haha
11:32:42 <irene-knapp> he starts by excluding debugging as a task
11:32:44 <kmc> but these are not so relevant to businesses
11:32:53 <irene-knapp> surely debugging and writing new code are both necessary parts of what we should call "programming"
11:33:03 <irene-knapp> especially if we're talking about business value
11:33:29 <ciaranm> "business value" is delivering first, regardless of quality
11:33:33 <irene-knapp> now, that said, I think the specific references he claims are bad, he is right about - they do not establish what they want to
11:33:42 <kmc> ciaranm, depends on the business.  if you're making planes and your plane crashes...
11:33:55 <ciaranm> kmc: then you've already sold the planes
11:34:02 <irene-knapp> I'm making futures of the species.  What happens if those crash?
11:34:04 <mreh> sort of works is usually good enough
11:34:17 <kmc> there is a very simple explanation for why this 10x claim gets repeated and believed so much without any evidence
11:34:22 <kmc> it makes the people repeating it feel good
11:34:27 <irene-knapp> oh, certainly
11:34:31 * jessopher sees lots of excluded middles in this conversation
11:34:36 <irene-knapp> but that said, the claim has come from managers, not just programmers :)
11:34:42 <irene-knapp> there's a Steve Jobs story
11:34:48 <znutar_> is there much evidence to the contrary?  e.g. surveys of productivity that showed little variance
11:34:51 <ciaranm> another explanation is that some of us have dealt with "average programmers"...
11:34:54 <irene-knapp> an outsider asked, "How many man-months did you spend on QuickDraw?"
11:35:05 <kmc> i can repeat this claim and implicitly place myself in that 10x productive group, and back it up with some meaningless group-signifiers like reading Hacker News or whatever
11:35:05 <irene-knapp> he turns to Bill Atkinson.  "Bill, how long did it take you to write QuickDraw?"
11:35:08 <irene-knapp> "About six months."
11:35:17 <irene-knapp> Jobs turns back to the outsider.  "Sixty man-months."
11:35:21 <kmc> see also Dunning-Kruger effect
11:35:28 <irene-knapp> haha
11:35:30 <rostayob> i wouldn't listen to what jobs says about programming anyways :)
11:35:38 <irene-knapp> was that an intentional joke?  you're using a citation? :D
11:35:54 <irene-knapp> oh, yes, that effect, right.  (looked it up)
11:36:05 <irene-knapp> (that's the one where you don't know how bad you are so you don't realize you're THAT bad!)
11:36:24 <kmc> it's the one (or at least related to the one) where everyone thinks they're above average
11:36:28 <irene-knapp> yes
11:36:33 <ciaranm> try getting a bunch of "typical programmers" to code a binary search sometime
11:37:12 <irene-knapp> anyway, I doubt there is evidence against the asserted high variance, either
11:37:18 <irene-knapp> there simply hasn't been any properly-conducted study
11:37:24 <irene-knapp> I'm not sure how one would conduct such a study though
11:37:37 <znutar_> It's a bit expensive and difficult to test, I bet
11:37:54 <kmc> there's plenty of evidence to support high variance in software development outcomes
11:37:55 <mreh> it's not interesting, no conclusive answers
11:38:06 <mee> the citation-digging bit of this is fun. I need to do this more.
11:38:26 <kmc> what i dispute is that it comes down to having enough of these magical 10x Real Hackers (who happen to be the people perpetuating the idea that it does)
11:38:50 <irene-knapp> oh for sure, I never want a Real Hacker on my team, if that's how he self-identifies
11:38:57 <ciaranm> kmc: you're missing that probably everyone in this channel is one of those 10x people (even the idiots)
11:38:58 <kmc> maybe it's more about having a team that works well together, rather than the strengths of any particular member of that team
11:39:03 <irene-knapp> I want someone who is as good as those people, but also doesn't have the damn cowboy attitude :)
11:39:10 <znutar_> I dislike the idea that there's 10x people, rather than 10x tuples of (person, task, environment)
11:39:17 <kmc> znutar_, yeah
11:39:21 <irene-knapp> znutar: that's true too, yes.
11:39:25 <ddarius> Most of what I've read about software engineering makes sense regardless of the quality of the programmers.
11:39:51 <ddarius> Also, good managers very much understand the value of good people.
11:39:52 <kmc> sometimes we miscategorize something as "intelligence" or "skill" when it's actually "spent 200 hours reading manpages"
11:39:59 <irene-knapp> ddarius: yes, indeed
11:40:06 <irene-knapp> kmc: well, there's that
11:40:13 <irene-knapp> one could lump that under "experience"
11:40:20 <irene-knapp> but we weren't discussing intelligence or skill, or even experience
11:40:22 <irene-knapp> those are causes
11:40:29 <irene-knapp> we were discussing productivity and/or business value, which are effects
11:40:38 <kmc> good managers understand the value of good people, but stereotypical Real Hackers belittle the value of managers
11:40:43 <znutar_> because there's plenty of examples of some dude showing up, sees that people are doing something an unproductive way, and writes a little shell script that saves hundreds of man-hours a month or whatever
11:40:59 <ddarius> kmc: Yes, I more or less agree with your view of "Real Hackers."
11:41:01 <irene-knapp> granted for the point you're making, which is that this folklore perpetuates itself because people like to flatter themselves, conflation of the cause and effect is relevant
11:41:02 <monochrom> different programmers want different extents of engineering practice. different projects call for different extents, too. this is why people argue so much over software engineering.
11:41:13 <kmc> it's possible these people really don't exist
11:41:13 <znutar_> and it's just that the team had fallen into some local minimum of doing things in a weird way or whatever
11:41:20 <kmc> they're all just reddit troll personae
11:41:22 <ddarius> monochrom is correct.
11:41:24 <kmc> that'd be cool i guess
11:41:48 <irene-knapp> haha
11:41:50 <parcs`> #haskell is the 1%
11:41:57 <ddarius> kmc: I'm pretty sure Paul Graham exists and his attitude is not just a show.  That said, I find Paul Graham a joke.
11:41:59 <irene-knapp> I thought we were the 10%
11:42:14 <ciaranm> we're the 1% that are 10x
11:42:25 <irene-knapp> Paul Graham needs to be taken in the context of "trying to sell his venture capital contracts to new college graduates"
11:42:43 <irene-knapp> I'm the 0%.  (to a first order of approximation)
11:42:43 <ddarius> irene-knapp: I'm talking about stuff long before YC.
11:42:48 <irene-knapp> oh, okay then
11:42:58 <irene-knapp> well, I don't find him that great either
11:43:04 <ciaranm> to a first order of approximation, cows don't exist
11:43:10 <kmc> i enjoyed _On Lisp_
11:43:17 <ddarius> kmc: As did I.
11:43:22 <irene-knapp> cairanm: that was in fact my point :D
11:43:27 <ddarius> On Lisp was primarily a technical book.
11:43:32 <kmc> "Why don't you live your life, like that cow from the video?"  "He was a horse."   "Yeah... because he followed his dreams."
11:43:37 <irene-knapp> I never read _On Lisp_, actually
11:43:42 <irene-knapp> kmc: hahaha
11:43:44 <monochrom> hahahah kmc
11:43:50 <znutar_> On Lisp was neat, whatever my disagreements with the philosophy might be
11:43:50 <ion> This is what your brain looks like… ON LISP
11:43:51 <kmc> i think the style in _On Lisp_ is not how I / any sane person would program in Lisp
11:43:53 <geheimdienst> kmc: meow!
11:43:54 <kmc> but it's fun to read!
11:44:11 <irene-knapp> I spent like upwards of six years self-identifying as a Common Lisp programmer, right
11:44:12 <ddarius> (That said, I think some of the things he shows how to implement are not good ideas, such as most of the "anaphora."
11:44:13 <ddarius> )
11:44:14 <irene-knapp> but I never read it ><
11:44:16 <irene-knapp> oh well
11:44:16 <ciaranm> sane people don't program in lisp or C, since it's not 1980 any more
11:44:20 <geheimdienst> @remember kmc "Why don't you live your life, like that cow from the video?"  "He was a horse."   "Yeah... because he followed his dreams."
11:44:21 <lambdabot> Done.
11:44:31 <kmc> dude it's just a quote from TV
11:44:34 <irene-knapp> ciaranm: C is decentish even today.  (what would you replace it with, for its purpose?)
11:44:36 <kmc> @forget kmc "Why don't you live your life, like that cow from the video?"  "He was a horse."   "Yeah... because he followed his dreams."
11:44:36 <lambdabot> Done.
11:44:42 <znutar_> kmc: yeah the idea that things will get done faster by letting every programmer make up their own languages makes me scratch my head
11:44:50 <ciaranm> irene-knapp: i'm not aware of c having a purpose any more
11:44:57 <kmc> znutar_, yeah.  i think it's a good idea in moderation
11:44:59 <irene-knapp> implementing the GHC RTS :D
11:45:01 <ddarius> irene-knapp is not a Real Lisp Hacker.
11:45:03 <drdo> znutar_: That is exactly what you do
11:45:05 <irene-knapp> so that nobody else has to use it :D
11:45:11 <kmc> particularly when some programmers can make a nice DSL for use by a bunch of non-programmers
11:45:11 <ciaranm> that doesn't count!
11:45:14 <irene-knapp> haha!
11:45:16 <irene-knapp> how does it not count?
11:45:23 <drdo> if you write a function, your language is now haskell + your function
11:45:23 <irene-knapp> that's like saying machine code doesn't have a purpose because you don't like it
11:45:26 <kmc> like the Haskell DSLs used by financial experts to model financial contracts
11:45:26 <ion> I love how easy it is to write some small part in C in a Haskell project.
11:45:36 <kmc> (note: i say "non-programmers" not "non-technical".  big fucking difference.)
11:45:39 <ciaranm> irene-knapp: C is used for that for historical reasons
11:45:41 <irene-knapp> kmc: yeah, indeed
11:45:55 <ciaranm> irene-knapp: had we grown up with, say, a Pascal OS, then you'd do it in Pascal instead
11:45:56 <ddarius> kmc: That's where a manager comes in.  You organize the skillsets of your development team so that you can multiply the abilities of everyone.  Then everyone can be a 10x programmer.
11:45:56 <irene-knapp> ciaranm: I disagree.  It would be very difficult to write a Haskell RTS in Haskell.
11:46:05 <danm__> kmc: that was an interesting read, re: modeling financial contracts in haskell
11:46:07 <kmc> (non-technical managers will never program in anything other than Excel, and that's just the way it is)
11:46:08 <jeff_s_> Let's rewrite the Linux kernel in Haskell!
11:46:14 <ddarius> kmc: Excel is powerful.
11:46:16 <irene-knapp> ciaranm: okay, but then my position would be that Pascal served a purpose still =p
11:46:23 <danm__> I like excel :\
11:46:23 <kmc> indeed it is
11:46:32 <irene-knapp> ciaranm: (I did grow up with a Pascal OS.  Mac OS pre-X was Pascal.)
11:46:36 <ddarius> Also, the integration with things like Sql Server Analysis Services makes Excel -extremely- useful.
11:46:54 <irene-knapp> ciaranm: (I hated it though.  For all the reasons in _Why Pascal is Not My Favorite Programming Language_ -- Brian Kernighan)
11:47:06 <irene-knapp> (wait, no, that was Dijkstra)
11:47:11 <irene-knapp> (sp)
11:47:18 <irene-knapp> (Djikstra)
11:47:29 * mee is reminded he needs to finish the last couple pages of that old SPJ paper on modelling financial contracts
11:47:36 <irene-knapp> heh, cool
11:48:14 <kmc> dĳkstra
11:48:24 <irene-knapp> d6a
11:48:36 <kmc> or is it d5a????
11:48:43 <irene-knapp> haha dammit :D
11:49:05 <ddarius> dIstra (crappy joke no one but me will understand)
11:49:16 <danm__> the mood in here is decidedly different today, everyone tipsy on eggnog or something?
11:49:18 <irene-knapp> er, indeed.  but you're welcome to explain it.
11:49:20 <kmc> (the ĳ ligature in Unicode is officially discouraged, though)
11:49:23 <irene-knapp> danm: I'm here!
11:49:36 <irene-knapp> if it's a ligature it's still that many letters
11:50:03 <irene-knapp> danm: but I've been in this channel for a long time and I have seen it in this mood before, I think it just depends on who's around and stuff
11:50:13 <irene-knapp> danm: and whether we have technical topics to discuss or are boring ourselves
11:50:17 <ddarius> Another more understandable one may be d(-1)stra
11:50:23 <irene-knapp> so - speaking of that, first-class record accessors.
11:50:24 <danm__> fair enough :)
11:50:25 <irene-knapp> haha!
11:50:33 <c_wraith> I do think the upcoming holiday is a factor
11:50:42 <irene-knapp> yeah, that's possible
11:50:42 <c_wraith> fewer people in the middle of serious things
11:50:47 <irene-knapp> some of us are actually on holiday already~
11:50:50 <ddarius> c_wraith: Says you.
11:50:53 <danm__> I'm very serious all of the time
11:51:02 <c_wraith> ddarius: fewer, not 0
11:51:04 <irene-knapp> shirley you're joking.
11:51:53 <kmc> > generalCategory 'ĳ'
11:51:54 <lambdabot>   LowercaseLetter
11:51:57 <geheimdienst> c_wraith: please don't use euphemisms like "holidays". call it by its name and say hanukkah. don't take the han out of hanukkah
11:52:09 <kmc> no thursday without thor!
11:52:17 <irene-knapp> keep the X in Xmas!
11:52:23 <c_wraith> geheimdienst: what?  I was talking about new year's
11:52:27 <irene-knapp> I'm on two holidays
11:52:35 <irene-knapp> I grew up as the child of a mixed marriage
11:52:43 <irene-knapp> but I don't like Christianity, so now I'm a Jewish athiest
11:52:52 <kmc> > let ĳsselmeer = "meer van de Zuiderzee" in ĳsselmeer
11:52:53 <lambdabot>   "meer van de Zuiderzee"
11:53:01 <geheimdienst> c_wraith: http://thefw.com/han-solo-hanukkah-photo/
11:53:07 <c_wraith> geheimdienst: I've seen it :)
11:53:19 <irene-knapp> hah, nice
11:54:09 <monochrom> well, happy hanukkah. I heard that it commemorates overthrowing some bad rulers. really cool.
11:54:21 <irene-knapp> thanks, but I don't practice :D
11:54:44 <geheimdienst> monochrom: so it's like an election or something
11:55:38 <kmc> wait, isn't it about the triumph of religious extremists?
11:56:14 <kmc> the maccabees would kidnap children and forcibly circumcise them
11:57:19 <kmc> hanukkah celebrates their victory over the more secular jews who were trying to integrate with greek society
11:58:00 <ClaudiusMaximus> when will Data.Complex have few enough needless constraints so that i can use Complex Rational ?
11:58:23 <monochrom> when Haskell 2020
11:59:14 <monochrom> and yes, let it be a warning to all who write "data C a => T a = ..."
11:59:25 <ClaudiusMaximus> > abs (1 :+ 1)  -- that's probably a fair estimate if this is anything to go by :(
11:59:26 <lambdabot>   1.4142135623730951 :+ 0.0
11:59:37 <c_wraith> GHC 7.4 sort of unilaterally removed some of Num's superclasses
11:59:50 <c_wraith> I wonder if a future version of GHC could do the same with Ratio
11:59:53 <irene-knapp> that was actually done by the prime committee, wasn't it?
11:59:55 <c_wraith> err, Complex, not Ratio
11:59:58 <monochrom> oh! no wonder there is a thread on the GHC mailing list :)
12:00:39 <ClaudiusMaximus> c_wraith: yeah, and the constraint is removed from the data Complex as far as i can tell, but not things like realPart
12:02:15 <ClaudiusMaximus> c_wraith: so you can construct a Complex Rational, but can't use realPart on it :/
12:02:27 <c_wraith> well.  Sounds like the job isn't done
12:05:22 <monochrom> http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg20799.html
12:05:42 <monochrom> apparently removing the Show superclass is committee-sanctioned
12:07:13 <ClaudiusMaximus> seems Complex (*) does RealFloat voodoo to avoid overflow/underflow..
12:07:34 <joe9> anyone tried https://github.com/k0ral/hbro
12:07:42 <joe9> is it fast enough? better than uzbl?
12:07:49 <rwbarton> ClaudiusMaximus: yeah, abs has a pretty complicated definition for that reason
12:07:55 <rwbarton> maybe other functions too
12:09:26 <qnikst> hello is there a way to select package for importing in ghci, i've got:
12:09:27 <qnikst>     Ambiguous module name `Control.Monad.Trans':
12:09:27 <qnikst>       it was found in multiple packages: mtl-2.0.1.0 monads-tf-0.1.0.0
12:10:16 <kmc> qnikst, ghci -hide-package mtl
12:10:26 <ClaudiusMaximus> qnikst: you can ":set -hide-package monads-tf" (or mtl if you prefer) but that "resets" ghci which might not be what you want
12:11:30 <qnikst> thanks
12:19:31 <Dodek> suppose i have a [Maybe a] list. i want to convert it to [a] list, dropping the Nothing-s. what's the higher order way to do it?
12:19:38 <roconnor> Dodek: catMaybes
12:19:40 <ddarius> catMaybes
12:19:44 <ddarius> Which isn't higher order at all.
12:19:55 <Dodek> oh
12:20:20 <Dodek> i thought that one can use Foldable and Monoid in a clever way
12:20:22 <Dodek> :)
12:20:31 <Saizan> technically it'd be if your Maybe's contain functions
12:20:46 <aavogt> @type mconcat . map maybeToList
12:20:47 <lambdabot> forall a. [Maybe a] -> [a]
12:21:02 <Dodek> thanks
12:21:17 <roconnor> @type concatMap maybeToList
12:21:18 <lambdabot> forall b. [Maybe b] -> [b]
12:21:27 <roconnor> @src catMaybes
12:21:27 <lambdabot> catMaybes ls = [x | Just x <- ls]
12:22:04 <Saizan> ?type foldMap (foldMap (:[]))
12:22:05 <lambdabot> Not in scope: `foldMap'
12:22:05 <lambdabot> Not in scope: `foldMap'
12:24:10 <irene-knapp> hmmm
12:24:11 <irene-knapp> :t fmap
12:24:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:24:29 <irene-knapp> @hoogle Functor f => (a -> a -> b) -> f a -> f a -> f b
12:24:30 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
12:24:30 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:24:30 <lambdabot> Data.IntMap unionWith :: (a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
12:24:36 <irene-knapp> hmmm
12:24:48 <irene-knapp> what I want is something like fzip, heh
12:24:53 <irene-knapp> is there such a thing?
12:24:58 <irene-knapp> @hoogle fzip
12:24:58 <lambdabot> No results found
12:25:04 <ddarius> In random libraries about.
12:25:10 <irene-knapp> hmm, oh well
12:25:15 * irene-knapp shall do the ad-hoc thing :)
12:27:02 <ddarius> @hoogle MonadZip
12:27:02 <lambdabot> No results found
12:27:16 <wereHamster> how can I decrease the size of my binary? It's a very simple app, and even stripped it's >3MB
12:27:32 <c_wraith> wereHamster: for what purpose?
12:27:49 <wereHamster> for what purpose the app is or why I want to decrease its size?
12:27:53 <c_wraith> the latter
12:28:05 <c_wraith> you could link it dynamically, but that won't help if you want to distribute the binary
12:28:06 <rostayob> wereHamster: the "problem" is that GHC links every haskell library statically
12:28:17 <benmachine> it doesn't *have* to
12:28:21 <rostayob> you could link it dynamically but i'm not sure how good that would be
12:28:39 <wereHamster> doesn't the load time suffer if the binary is huge?
12:28:45 <c_wraith> not practically
12:28:47 <ddarius> wereHamster: No.
12:28:59 <c_wraith> and it's not like dynamic linking results in faster loading, anyway
12:29:23 <ddarius> Most operating systems simply memory map the executable which is more or less constant time with respect to the file size.
12:29:26 <NihilistDandy> And is 3 MB really a lot?
12:29:34 <rostayob> yes
12:29:40 <rostayob> GHC executables are really big
12:29:47 <rostayob> even for really simple things
12:30:00 <ddarius> Clearly, though, what we need to do is make a HRE.
12:30:01 <c_wraith> eh.  There's the overhead for the RTS, but that's basically constant.
12:30:24 <eikke> ddarius: why would a memory mapping be O(filesize)?
12:30:39 <mbetter> my current project is generating a 19 meg executable
12:30:45 <ddarius> eikke: I didn't say it would be.
12:30:56 <irene-knapp> hmm
12:31:03 <irene-knapp> my project is coming in at 4.2M
12:31:12 * irene-knapp shrugs
12:31:15 <rostayob> it's pretty bad
12:31:36 <mbetter> i haven't really cleaned up the export lists, though.. that might help some
12:31:58 <c_wraith> export lists should be irrelevant after the linking is completed
12:32:27 <ddarius> rostayob: If you included the JRE in every jar, Java applications would be much worse.  As is, Java applications are often fairly heavy.
12:32:49 <mbetter> Maybe that's just how it is. I'm pretty new to this
12:32:56 <rostayob> ddarius: I'm not saying it's not justified.
12:33:05 <rostayob> but it is a disadvantage
12:33:38 <ddarius> Not much of one and it's surmountable.
12:34:01 <NihilistDandy> The largest I've seen is ~65 MB, and that's pandoc
12:34:07 <rostayob> ddarius: i agree that is not a big problem, but how do you overcome it?
12:34:18 <mbetter> can you specify GHC command line options in a file somewhere? i would like to add a search directory when just running "GHC"
12:34:26 <ddarius> rostayob: You do what everyone else is doing to get small file sizes.  Dynamically link.
12:34:37 <NihilistDandy> mbetter: Alias ghc to something with flags
12:34:59 <ddarius> Of course to do that you need to require the users already have the dynamically linked libraries, which is where an HRE would come in.
12:35:01 <NihilistDandy> alias ghc="ghc --your-options"
12:35:13 <mbetter> NihilistDandy: thanks, that's what i figured.
12:35:13 <rostayob> oh ok. the problem is that, as you said, that binary wouldn't be portable
12:35:38 <rostayob> ddarius: HRE?
12:35:43 <ddarius> rostayob: Neither are the binaries in C or Java or the scripts in Ruby that don't bundle everything with them.
12:35:49 <ddarius> rostayob: Haskell Runtime Environment.
12:36:05 <rostayob> oh. yeah that would be cool
12:38:28 <rostayob> ddarius: yeah but C binaries have a far lower overhead. and Java binaries as you said defer some of the size to the JRE
12:38:33 <drdo> hmm, why is inet_addr in IO?
12:40:15 <c_wraith> drdo: heh.  that one could be unsafeDupablePerformIO'd, yes
12:40:26 <ddarius> rostayob: The OS and libc etc. and the C runtime environment.  All anyone is doing to get small binary sizes, is defer the size elsewhere.
12:40:40 <ddarius> s/and the/are the/
12:40:47 <NihilistDandy> Truth
12:41:50 <irene-knapp> Truth :: Bool
12:42:04 <irene-knapp> so I thought of something
12:42:07 <irene-knapp> record kinds
12:42:19 <drdo> c_wraith: Eh, just that i need to convert an address in dotted format, guess i'll just write my own
12:42:25 <rostayob> ddarius: that's true, but Haskell requires a more complex runtime than C in any case
12:42:30 <ddarius> rostayob: Agreed.
12:42:46 <irene-knapp> they would be useful when you want to partially apply a type constructor, but you don't want the partial applications you can construct to be constrained by the order of the parameters to the algebraic type constructor
12:42:52 <ddarius> rostayob: You are getting something for that.  Haskell, the language, and GHC specifically, provides far more than C.
12:43:02 <irene-knapp> this is not theoretical; I wanted it rather badly earlier this week
12:43:21 <irene-knapp> am I crazy? :)
12:43:25 <ddarius> irene-knapp: Yes.
12:43:32 <irene-knapp> okay, but is my idea also crazy?
12:43:40 <rostayob> ddarius: sure, and that's why I code in Haskell all the time :)
12:44:04 <ddarius> irene-knapp: From one perspective, no, but I think the consequences would be worse than you think.
12:44:07 <irene-knapp> hmmm
12:44:14 <irene-knapp> well, I'm interested in your insights
12:44:32 <irene-knapp> I see the implementation difficulties, of course
12:44:45 <irene-knapp> but I'm thinking of including them in my toy language just to see how they work out
12:45:04 <ddarius> irene-knapp: I doubt that, but I don't completely understand what you are going for.  At any rate, I'm going to be playing and singing American Pie for the next several minutes.
12:45:09 <irene-knapp> okay, haha
12:45:14 <irene-knapp> have fun with that!
12:45:21 <irene-knapp> keep that levy lubricated
12:45:28 <irene-knapp> er
12:45:29 <irene-knapp> levee
12:45:33 <irene-knapp> whatever ><
12:46:21 <Saizan> i think the ML folks do something similar with their functors
12:46:34 <irene-knapp> interesting
12:46:39 <Saizan> they get passed a module with named type fields
12:46:43 <irene-knapp> oh fun
12:47:19 <Saizan> (the module can also contain values, it's more or less a dependent record)
12:47:25 * irene-knapp ndos
12:47:34 <Saizan> btw, you can do something similar with type families
12:47:35 * irene-knapp nods, too
12:47:43 <irene-knapp> oh, yeah, so I could!
12:47:44 <irene-knapp> good call
12:47:55 <irene-knapp> I worked around it already, so I don't really need it anymore, haha
12:48:06 <irene-knapp> that module is a mess, but it typechecks and appears to work, so ><
12:48:15 <irene-knapp> over a thousand lines ><
12:48:23 <Saizan> have a family for each field and make new instances of each to make new "modules"
12:48:31 <irene-knapp> hm, right, I see
12:48:52 <ddarius> @google shan module ml haskell type classes
12:48:54 <lambdabot> http://www.cse.unsw.edu.au/~chak/papers/modules-classes.pdf
12:48:54 <lambdabot> Title: ML Modules and Haskell Type Classes: A Constructive Comparison
12:49:05 <ddarius> @google chakravarty module ml haskell type classes
12:49:06 <lambdabot> http://lambda-the-ultimate.org/node/1558
12:49:06 <lambdabot> Title: ML Modules and Haskell Type Classes: A Constructive Comparison | Lambda the Ulti ...
12:49:12 <ddarius> Tsk.
12:49:26 <irene-knapp> ah!  I had seen that paper-thing before, but not made sense of it
12:49:59 <ddarius> There's another one that is a bit more readable.
12:50:02 <irene-knapp> ahh
12:50:05 <irene-knapp> and you're looking for it
12:50:06 <irene-knapp> I see
12:50:20 <ddarius> If I'm not mixing them up, but there are two or three very similar papers.
12:50:24 <irene-knapp> hmm okay
12:50:41 <pdxleif> Anyone know of a good Haskell-ish thing on the JVM?
12:51:04 <pdxleif> There was CAL OpenQuark or whatever - I heard about a newer one, too, but can't recall the name at the moment.
12:51:16 <rostayob> pdxleif: code.google.com/p/frege/
12:51:32 <pdxleif> rostayab: That was it, thanks!
12:51:58 <rostayob> yw
13:03:50 <ddarius> Not as good as last time.
13:18:39 <xil> hi. I have a TArray full of visual information and I'm trying to figure out how to display it on the screen. Someone recommended gloss but looking at it now it looks like it can't handle the IO monad, so I don't know how I can give it the info in the TArray...
13:18:46 <Guest14151> > let map' f = foldr (:) . f []
13:18:47 <lambdabot>   not an expression: `let map' f = foldr (:) . f []'
13:18:58 <Guest14151> > let map' f = foldr (:) . f [] in map' (+1) [0..5]
13:18:59 <lambdabot>   Couldn't match expected type `[t1] -> t'
13:18:59 <lambdabot>         against inferred type `[[a...
13:19:36 <irene-knapp> whoa
13:19:41 <irene-knapp> I think I just sent GHC into an infinite loop
13:19:43 <c_wraith> xil: indeed, gloss isn't designed for that.
13:19:54 <irene-knapp> possibly by making it try to construct infinitely many instances?  not sure
13:20:20 <xil> c_wraith: I would use OpenGL directly if it was easier to set pixels, but I'mnot comfortable with pointers enough
13:20:30 <byorgey> xil: you want to generate a single visualization? or you want to have the visualization update along with the array?
13:20:52 <xil> byorgey: update with the array
13:20:52 <c_wraith> xil: honestly, I have little experience with graphics in haskell.  Minor use of the SDL binding, which seemed to work ok-enough
13:21:39 <xil> c_wraith: I've never actually used SDL. Tried learning it once but gave up out of laziness. I'll check it out now though I suppose
13:21:58 <irene-knapp> PHEW
13:21:59 <c_wraith> xil: I'm not sure I'd really recommend it.  I had to go to the C docs a bunch.
13:22:00 <benmachine> SDL's fairly straightforward I reckon
13:22:03 <irene-knapp> that nearly brought my system down
13:22:10 <xil> c_wraith: yeah that's why I gave up before
13:22:13 <irene-knapp> GHC took like, 4G of /real/ memory (I have 8G, thankfully!)
13:23:25 <xil> byorgey: I'd be satisfied with manually invalidating the screen every time I need to update, like with OpenGL. Or even just having it update at a regular frame rate
13:23:52 <sal23> does unsafeWrite for a boxed vector make a O(n) copy of the input elements when writing? or does it just store a reference to elements. The second option would make more sense provided those input elements are immutable
13:24:26 <irene-knapp> okay so hm ><
13:24:36 <irene-knapp> I would like dearly to know why that happened and how I can make it not happen again
13:25:21 <c_wraith> can you make it happen again?
13:25:24 <c_wraith> that's the first step
13:25:49 <irene-knapp> yes
13:25:53 <irene-knapp> every time I try to compile my program ><
13:26:02 <c_wraith> at least it's reproducable!
13:26:04 <irene-knapp> I'm telling #ghc about my "accomplishment" now but nobody seems to be around
13:26:05 <irene-knapp> haha true!
13:28:14 <byorgey> xil: well, if you're OK with manually regenerating the screen every time you update, then gloss should work just fine
13:28:48 <xil> byorgey: but gloss won't work in the IO monad for that. My "world" would have the TArray and would have to return IO Picture. But I can't do that
13:30:16 * Sgeo envisions a password-protected state monad
13:31:02 <exFalso> good evening
13:31:02 <exFalso> if i have a thread that is reading from a socket stream is it safe to shut it down using killThread/throwTo?
13:32:05 <Enigmagic> exFalso: safe it what sense? it will work.
13:32:14 <byorgey> xil: well, you CAN call pure code from within an IO computation.  the real problem is that you can't tell gloss to *update* a window instead of creating a new one.
13:32:17 <monochrom> I think so. the kill is only honoured at thread-rescheduling points
13:32:37 <byorgey> xil: another option would be to use the Gtk backend for diagrams
13:32:39 <exFalso> safe as in the stream will be usable afterwards
13:32:41 <byorgey> @where diagrams
13:32:41 <lambdabot> I know nothing about diagrams.
13:32:53 <byorgey> @where+ diagrams http://projects.haskell.org/diagrams/
13:32:53 <lambdabot> Done.
13:32:55 <exFalso> ok thank you!
13:33:10 <xil> byorgey: I tried learning Gtk. Don't think I want to do it right now. I'm looking for something really simple
13:33:16 <byorgey> xil: fair enough.
13:33:18 <Enigmagic> exFalso: i haven't had any problems with it... though connect isn't exception safe, if you use it.
13:34:37 <dmwit> ?flush
13:34:38 <exFalso> Enigmagic: no, the reading thread is forked from thre thread that connectTo'd and it is shut down safely
13:34:38 <lambdabot> Not enough privileges
13:35:09 <Sgeo> :t (1,,1)
13:35:10 <lambdabot> Illegal tuple section: use -XTupleSections
13:35:17 <Sgeo> :t (1,1,)
13:35:18 <lambdabot> Illegal tuple section: use -XTupleSections
13:35:24 <Sgeo> :t (1,)
13:35:25 <lambdabot> Illegal tuple section: use -XTupleSections
13:35:28 <Sgeo> Ok
13:35:46 <Sgeo> :t (,,) 1 1
13:35:47 <lambdabot> forall t t1 c. (Num t, Num t1) => c -> (t, t1, c)
13:35:55 <Goosey> Is there a list where I can find all the haskell modules and their functions?
13:36:30 <rostayob> Goosey: you should have a list for the global packages somewhere
13:36:34 <monochrom> "all"? you can get close to "all" by http://hackage.haskell.org/packages/archive/pkg-list.html
13:36:35 <rostayob> mine is in /usr/local/share/doc/ghc/html/libraries/index.html
13:36:36 <kmc> the modules in Haskell Platform are here: http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/index.html
13:36:54 <kmc> actually the newer one: http://lambda.haskell.org/platform/doc/current/index.html
13:37:01 <Goosey> Hm, thanks
13:37:09 <kmc> that's not "all the haskell modules"
13:37:16 <monochrom> but no list will have really "all" because no list has my modules.
13:37:19 <kmc> anyone can write a module and not share it with you
13:37:31 <Goosey> All the standard modules*
13:37:47 <Goosey> That came with the platform I suppose
13:37:50 <kmc> there are many different definitions of "standard" you can use
13:37:55 <kmc> Platform is probably the useful one
13:38:00 <xil> *ugh* I have all the logic done and no way to display it on the screen -_-
13:38:33 <c_wraith> xil: you could just output an image of some sort, if you don't need your program to display it
13:38:54 <xil> c_wraith: it's an interactive Mandelbrot set viewer
13:39:35 <Goosey> xil: Wouldn't have been better to design prerequesites first?
13:39:53 <xil> Goosey: not sure what you mean
13:40:39 <Goosey> xil: It seems to me, logically, you should have written the view before the actual algorithm. I mean, what use is the algorithm if you can't see its output?
13:41:08 <kmc> i don't agree
13:41:16 <xil> Goosey: I've been experimenting lately with MVC programming strategies. I used to make the view first but this time wanted to try starting with the model
13:41:25 <Goosey> It just seems like there is a logical process.
13:41:27 <monochrom> that is not logically. motivationally, yes.
13:41:54 <ddarius> The tasks are independent once interfaces have been defined.
13:41:55 <xil> the reason is that until the model is done I don't necessarily know all of the things I'll have access to in the view
13:42:14 <Goosey> xil: kmc I'm not saying I'm in any way correctly defining the correct process, I'm just saying that if you ran into such a problem, it seems you didn't approach it correctly.
13:42:33 <kmc> in many cases the algorithm is something tricky that might not even be possible, while the view is straightforward if time-consuming
13:42:36 <Goosey> xil: That makes sense, I would probably do the algorithm first in that case.
13:42:37 <xil> Goosey: oh yeah, I got that. I'm just experimenting with strategies is all
13:42:58 <kmc> wouldn't it be equally dumb to polish some awesome UI to an algorithm which turns out to be impossible or uninteresting?
13:43:06 <Goosey> Then I would make a simplistic memory viewer and I would manually check the algorithm's logic
13:43:11 <xil> I just want a simple 2D graphics interface, like Java's AWT and Swing T_T
13:43:24 <irene-knapp> ><
13:43:29 <Goosey> kmc: Of course, unless you make a general UI that could be a template for future applications.
13:43:31 <irene-knapp> I do not think that word ("simple") means what you think
13:43:51 <Goosey> irene-knapp: basic*
13:44:10 <irene-knapp> I really wouldn't call AWT or Swing basic, either
13:44:11 <nus> @where HTk
13:44:11 <lambdabot> I know nothing about htk.
13:44:11 <kmc> i just think you have way too little information to tell xil that they're Doing It Wrong
13:44:13 <Goosey> I'd output the bare minimum required to check the logic.
13:44:15 <irene-knapp> they're rather complicated as these things go
13:44:17 <ddarius> AWT and Swing are simple 2D graphics interfaces?
13:44:39 <Goosey> kmc: I'm not saying he is, I'm saying there is probably a better way.
13:44:48 <c_wraith> know what a simple 2d graphics interface is?  PSET, from BASIC. :)
13:44:52 <kmc> there's always a better way in hindsight
13:44:53 <irene-knapp> haha yes, haha
13:44:56 <irene-knapp> PSET was fun
13:44:57 <Goosey> I'm not trying to attack anybody, I was just saying what I thought.
13:45:10 <Goosey> I probably know the least about haskell in this channel after all :P
13:45:11 <xil> kmc: I didn't think Goosey was criticizing me, just offering a suggestion
13:45:39 <xil> ddarius: well they offer simple ways to draw your own stuff
13:45:44 <kmc> i didn't think it was an attack, either
13:46:27 <ClaudiusMaximus> i need to fix an annoyment in my own Mandelbrot set viewer - when rendering zooming animations there's annoying jitter (due to overcomplicated/messy internals, again..)
13:46:36 <chadz> anyone know of any projects using vty-ui?
13:46:57 <xil> all I need is a way to specify the color values of points on the screen. That's all I want to do. I'd like keyboard and mouse input at some point, but right now just the ability to set pixels
13:47:21 <c_wraith> so..  you do want PSET
13:47:33 <kmc> how about SDL
13:47:52 <Sgeo> With Template Haskell, can I have the compiler process my TH using file and show me the non-TH version?
13:47:59 <parcs`> you can do that easily with opengl
13:48:14 <ddarius> My experience is that GUI frameworks are horrible about letting you just draw a point on a screen and even if they support it in a reasonable way, it is extremely inefficient and thus unusable.
13:48:15 <kmc> Sgeo, not exactly, but ghc -ddump-splices
13:48:15 <c_wraith> SDL honestly isn't that bad, it's just underdocumented, and you'll end up going to the C docs sometimes.
13:48:23 <xil> kmc: I'd love to know how to code SDL, but it was painful to learn. I would learn it in time, but am just hoping there is something quicker for the short term
13:48:30 <ddarius> c_wraith: That's probably by design.
13:48:36 <cgroza> @hoogle a -> b -> (a,b)
13:48:37 <lambdabot> Data.Generics.Twins gmapAccumT :: Data d => (forall e. Data e => a -> e -> (a, e)) -> a -> d -> (a, d)
13:48:37 <lambdabot> Data.ByteString.Lazy mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
13:48:37 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
13:48:47 <xil> parcs`: the problem is that you have to use pointers, and I'm unconfident with pointers in Haskell
13:49:02 <monochrom> maybe you know little about haskell, but you have demonstrated full compatibility with how #haskell works for the most part. that is, at the first hint of a broad, vague question, you don't ask for clarifications or definitions or information or details, you go ahead spew out reams after reams of well-intented answers. it is actually pretty marvellous, that from an informationless question you can generate much informationful
13:49:02 <monochrom>  answer.
13:49:15 <cgroza> that is not what I need. Is there a function that packs arguments for me in a tupple?
13:49:43 <kmc> xil, it seems given this discussion that there is nothing quicker for the short term
13:49:51 <rwbarton> cgroza: the tuple constructor, (,) ?
13:49:51 <kmc> we can help you with pointers in Haskell
13:49:54 <kmc> there is not much to it
13:49:57 <kmc> > (,) 2 3
13:49:58 <lambdabot>   (2,3)
13:50:05 <monochrom> it is really like someone's cynical description of managers. it says that the ideal manager needs 0 information and can already make decisions.
13:50:29 <parcs`> xil: hardly
13:50:43 <monochrom> anyway, welcome to the club.
13:50:48 <xil> well let me just do the OpenGL stuff I guess. I'll have to learn SDL some time though. I feel like OpenGL is overkill none the less....unless SDL uses OpenGL?
13:50:55 <kmc> it does not
13:51:07 <kmc> not by default anyway
13:51:08 <kmc> rather, you can use SDL to get a context for drawing OpenGL
13:51:13 <xil> ah
13:51:53 <kmc> i think "overkill" is generally a pretty weak criticism -- who cares if the library that does what you need also does things you don't need?
13:52:05 <kmc> but, I think OpenGL is not very well suited to your task
13:52:12 <kmc> it is a 2D and 3D vector graphics library, not a bitmap graphics library
13:52:24 <kmc> it doesn't handle creating a window, getting input, etc.
13:52:28 <kmc> that's left to another layer, often SDL
13:52:46 <kmc> parcs` says it's easy to draw individual pixels with OpenGL but that is not my recollection
13:52:47 <ddarius> Actually, a crucial skill for a leader is the ability to make decisions given too little information.
13:52:59 <cgroza> rwbarton: can I curry it?
13:53:15 <rwbarton> curry (,) is just id
13:53:15 <kmc> you will have to learn how a bunch of 2D and 3D vector graphics features work, just so you can keep them out of your way
13:53:20 <rwbarton> :t curry (,)
13:53:21 <lambdabot> forall a b b1. a -> b -> b1 -> ((a, b), b1)
13:53:23 <irene-knapp> ddarius: also a crucial skill for a random-number generator.
13:53:29 <rwbarton> oh
13:53:31 <kmc> xil, use SDL.
13:53:31 <rwbarton> :t uncurry (,)
13:53:32 <lambdabot> forall a b. (a, b) -> (a, b)
13:53:34 <irene-knapp> if it's truly too-little information, then, uh, the RNG would do just as well :)
13:53:34 <ddarius> irene-knapp: Yes and no.
13:53:37 <tech2> ddarius: more to the point, it's a person you can rely on to bear the responsibility for having done so, good or bad.
13:53:42 <cgroza> rwbarton: it seems to be what I need. Thanks.
13:53:48 <xil> kmc: but I'd have to learn it right now, whereas I know OpenGL
13:53:51 <ddarius> irene-knapp: Only if you had an appropriate distribution.
13:53:53 <irene-knapp> if you alter your original statement to "? given less information than one might want", I'd agree
13:53:57 <ddarius> tech2: Indeed.
13:54:01 <kmc> do you know how to draw individual pixels with OpenGL?
13:54:17 <xil> kmc: I've seen it before, but didn't want to learn pointers at the time
13:54:36 <irene-knapp> pointers ><
13:54:40 <irene-knapp> oh well
13:55:26 <ddarius> irene-knapp: Even if the problem does come down to one that is essentially just a coin toss, the ability to 1) realize that you are not going to get more information and more analysis will not help, and 2) actually make a decision is necessary.
13:55:43 <irene-knapp> that's true, yes
13:55:46 <irene-knapp> stated that way, I agree
13:55:55 <kmc> xil, time to learn pointers i feel
13:56:01 <irene-knapp> but I would say it more as
13:56:12 <irene-knapp> "The ability to know when to act"
13:56:36 <xil> kmc: yeah. I've used them for piping visual data to ffmpeg once
13:56:52 <ddarius> irene-knapp: I agree, that is the key.  I'm focusing particularly on the fact that many people have a hard time actually making a decision when there is not a clear winner.
13:56:54 <monochrom> actually, you can know when to act, and still not act timely.
13:57:25 <irene-knapp> yes, that makes sense to me
13:57:31 <irene-knapp> monochrom: well, fair.
14:02:09 <xil> does MArray.getElems produce a list in index order?
14:05:08 <c_wraith> xil: it should.  I believe it's documented to do so
14:05:23 <xil> c_wraith: getAssocs is documented to do so, but not getElems
14:05:37 <xil> http://hackage.haskell.org/packages/archive/array/latest/doc/html/Data-Array-MArray.html#v:getElems
14:06:12 <c_wraith> well, the implementation certainly will return them in order.
14:06:20 <c_wraith> If you're comfortable depending on just that :)
14:07:00 <xil> would it be awful to do (map snd . getAssocs)?
14:07:05 <c_wraith> (I just clicked on the source link there to see what it's actually doing)
14:07:19 <c_wraith> Nah, it wouldn't be awful, though it's a doing a bit more work
14:07:44 <c_wraith> oh, hmm.
14:07:44 <xil> yeah I'm looking at the source too, but I frankly don't understand it
14:07:49 <c_wraith> actually, it would be a lot slower
14:07:57 <c_wraith> since it uses safeIndex, rather than unsafeRead
14:08:07 <c_wraith> so over a sufficiently large array, that difference will really add up
14:08:54 <c_wraith> err, both use UnsafeRead, it just adds safeIndex on top of it for one.  But it's in the critical path, so it can't leave it unevaluated.
14:09:09 <c_wraith> ...  That's kind of a flaw in that function
14:09:12 <xil> I guess I'll hope it's in order for now. Until I find a bette rway to do this
14:14:42 * hackagebot text 0.11.1.12 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.1.12 (BryanOSullivan)
14:15:54 <hpaste> kmc pasted “sdl example (for xil)” at http://hpaste.org/55662
14:16:12 <kmc> xil, this code sucks in a lot of ways, it makes assumptions you're not allowed to make, but it might help you get started
14:17:19 <xil> kmc: the hardest part about SDL was getting a window I could draw on setup. I just didn't want to read through the C docs. Thank you so much for this. I'll use it to help figure that stuff out ^_^
14:17:20 <kmc> note in particular there's no bounds checking on putPixel, so if you pass bad x,y coordinates you can overwrite arbitraryr memory
14:17:46 <kmc> yeah, unfortunately I think you will have to read the C docs a bit to expand this
14:17:54 <xil> oh yeah, but this'll help
14:18:04 <kmc> i kludged this together mostly from http://www.libsdl.org/cgi/docwiki.cgi/Initializing_SDL and http://www.libsdl.org/cgi/docwiki.cgi/Introduction_to_SDL_Video
14:18:34 <xil> I read a lot of C docs for OpenGL when learning it and that was on Java. Had do to it for Haskell too, but far less so because I already knew how it worked
14:18:49 <kmc> *nod*
14:19:13 <kmc> http://lazyfoo.net/SDL_tutorials/ also helpful
14:19:52 <kmc> hmm, i guess 'frame' really should use 'bracket'
14:19:53 <kmc> :t bracket
14:19:54 <lambdabot> Not in scope: `bracket'
14:20:01 <kmc> :t Control.Exception.bracket
14:20:02 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
14:20:26 <Sgeo> Isn't that different from a default bracket somewhere, or am I thinking of a different function?
14:20:35 <cgroza> @type (,)
14:20:36 <lambdabot> forall a b. a -> b -> (a, b)
14:23:20 <kmc> Sgeo, I don't understand the question.  it's the standard Control.Exception.bracket
14:23:40 <kmc> there is also bracket_ "where the return value from the first computation is not required."
14:24:07 <Sgeo> kmc, there's a function which is in Prelude but there's a different better function in Control.Exception, I think
14:24:10 <ddarius> kmc: He's thinking of a bracket in a different module.  I believe bracket is a standard function, whereas Control.Exception is not a standard module.
14:24:49 <kmc> there's no bracket in my Prelude
14:24:53 <kmc> @hoogle bracket
14:24:53 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
14:24:53 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
14:24:53 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
14:25:23 <ddarius> It's in IO I believe, not the Prelude.
14:25:37 <kmc> :t IO.bracket
14:25:38 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
14:25:39 <ddarius> http://haskell.org/onlinereport/io.html
14:25:48 <kmc> does that one catch only IOErrors?
14:25:59 <ddarius> kmc: Something like that, probably.
14:26:03 <ddarius> It can only be specified to.
14:26:55 <monochrom> yes
14:27:38 <xil> how do I put a list into a Ptr?
14:28:24 <monochrom> more precisely, GHC's IO.bracket (and System.IO.bracket) is good for IOErrors only. Control.Exception.bracket is good for all exceptions, emphatically all those new-fangled async exceptions. I don't know about other compilers.
14:28:30 <xil> I have a Ptr Word8 and a [Word8]
14:28:31 <c_wraith> xil: depends on exactly what you want
14:28:48 <c_wraith> xil: is the Ptr supposed to refer to an *array* of Word8?
14:28:52 <xil> yes
14:28:53 <benmachine> Prelude has a 'catch' function
14:29:01 <benmachine> and C.E has a better one
14:29:08 <xil> c_wraith: allocArray to make it
14:29:09 <kmc> xil, http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/haskell2010-1.0.0.0/Foreign-Marshal-Array.html
14:29:21 <kmc> some other nice stuff in http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/haskell2010-1.0.0.0/Foreign-Marshal-Utils.html
14:29:27 <monochrom> Prelude's catch is System.IO's catch and is only good for IOErrors again.
14:29:42 * hackagebot aeson 0.5.0.0 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.5.0.0 (BryanOSullivan)
14:29:59 <c_wraith> xil: something like withArray from Foreign.Marshal.Array
14:30:02 <xil> kmc: *facepalm* I was there and just didn't look at those other functions
14:30:15 <kmc> monochrom, hmm, that seems kind of weird.  it seems like for portability you would want the spec's 'bracket' to deal with all exceptions, even implementation-specific ones
14:30:34 <xil> c_wraith: why not pokeArray?
14:30:39 <kmc> otherwise you can't portably and safely acquire resources
14:30:53 <benmachine> I have a question: I have a function Text -> Lens A (Maybe (B,C)) and I want Text -> Lens A (Maybe C), any ideas? (Lens being from data-lens)
14:30:59 <c_wraith> xil: because withArray takes care of allocating the memory and then releasing it for you later
14:31:09 <c_wraith> xil: of course, if you don't want it released later, don't do that
14:31:34 <benmachine> I can do it if I can get Lens (Maybe (B,C)) (Maybe C), and I can get Lens (B,C) C
14:31:43 <xil> c_wraith: isn't it wasteful to release if I'm doing this many times per second?
14:31:54 <benmachine> not sure if that's the right approach, though. I can write a Lens a b -> Lens (Maybe a) (Maybe b) but I'm pretty sure it breaks the laws
14:31:55 <c_wraith> xil: not really.
14:32:01 <xil> c_wraith: well then...haha
14:32:25 <c_wraith> xil: I mean, sure, it won't be as fast as possible, but it probably won't be the slowest part of the process
14:32:43 <xil> and withArray figures out the amount of space to allocate on its own based on the list, assuming the list is finite?
14:32:46 <kmc> xil, you're writing pixels into a software buffer individually and then copying them to the graphics card on every frame.
14:32:50 <kmc> don't worry about performance just yet
14:32:56 <teneen> I've a question concerning the source of Control.Monad.Reader.Class
14:33:10 <teneen> in the declaration class (Monad m) => MonadReader r m | m -> r
14:33:17 <teneen> m has to be a Monad
14:33:27 <teneen> while in the instance of ((->) r)
14:33:32 <c_wraith> xil: honestly, when you're working for maximum performance, you won't be working with [Word], you'll be working with something like StorableVector
14:33:33 <teneen> it is not a monad
14:33:40 <c_wraith> that is so a monad
14:33:45 <teneen> Control.Monad.Instances is not imported !
14:33:50 <Sgeo> Template Haskell is LamE
14:33:51 <xil> c_wraith: haha, okay I gotcha
14:33:55 <xil> kmc: will do =]
14:34:22 <teneen> here http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/src/Control-Monad-Reader-Class.html#local
14:34:48 <teneen> from where did it get the monad instance for ((->) r) ?!
14:35:31 <pshf> okay, quick question, I want to define something like (Ord a) => MyClass (a,a), with the fact that if a is of type Num then (a,a), of type MyClass, is also a subclass of Num; how do I do this exactly? where's a good place to learn about this properly?
14:36:23 <kmc> "(a,a), of type MyClass"?   well, which is it, a type or a class?
14:36:25 <c_wraith> teneen: did you check all the transitive imports?
14:36:29 <benmachine> teneen: I bet it imports something that imports Control.Monad.Instances
14:36:40 <benmachine> teneen: http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/src/Control-Monad-Trans-Reader.html
14:36:44 <kmc> also 'subclass' isn't the right word
14:36:48 <pshf> sorry, class
14:37:07 <kmc> also where does Ord come into it
14:37:35 <pshf> kmc: it doesn't ,it was just for sake of concrete example
14:37:44 <pshf> also it says subclass here: http://www.haskell.org/tutorial/classes.html
14:37:46 <teneen> benmachine,c_wraith: I didn't know that transitive imports are also imported, shouldn't "import" only import functions which are exported by the module being imported?
14:37:56 <benmachine> teneen: instances are infectious
14:38:11 <c_wraith> teneen: instances are imported transitively.  names are not
14:38:14 <kmc> pshf, subclass is used to describe a class which requires some class constraint to hold
14:38:24 <kmc> it sounds like you want an *Instance* which requires a constraint
14:38:47 <teneen> c_wraith,benmachine: ohh I see
14:38:53 <teneen> c_wraith,benmachine: Thanks
14:39:05 <kmc> class MyClass t where { ... };   instance (Num a, MyClass (a,a)) => Num (a,a) where { ... }
14:39:07 <c_wraith> teneen: that's actually a requirement when you want the property that all modules in a program see the same instances for given type/class pairs
14:39:15 <kmc> that will require some GHC type class extensions
14:39:20 <kmc> it's also not a very good idea
14:39:31 <teneen> c_wraith: yes, it makes sense
14:39:39 <kmc> because you're defining an instance Num (a,a)  in a module other than the ones defining Num and (,)
14:39:43 <kmc> a so-called "orphan instance"
14:39:52 <kmc> it would be much better to create your own type rather than re-using (,)
14:41:21 * Sgeo should try writing his password-protected State monad
14:41:25 <Sgeo> Would be a good excersize
14:41:28 <pshf> hmm
14:42:08 <kmc> how's that work Sgeo?
14:43:03 <Sgeo> data ProtectedState s = ProtectedState { hashedPass :: String, state :: s}. >>= would make sure that the password matches before allowing an "update", otherwise... let me change the type
14:43:57 <Sgeo> ProtectedState { hashedPass :: String, state :: s, failedChanges :: [<not sure right now>]}
14:44:11 <Sgeo> Or I could just discard failed writes
14:44:19 <ddarius> That seems like it is pushing a concern far too deep.
14:45:05 <Sgeo> It's not intended to be particularly useful except in a hypothetical HaskellNomic perhaps
14:48:38 <Sgeo> Hmm, I'm actually not sure if I can hash the password, come to think of it. the f in x >>= f needs to return something of the type
14:51:05 <ddarius> Sgeo: What you'd want, roughly, is ReaderT Password (State s a) newtype wrapped with putWithPassword checking against the password in the environment.
14:51:34 <ddarius> Obviously this can be generalized to a monad transformer immediately, and you could add an ErrorT layer to handle mismatched passwords.
14:52:07 <Sgeo> But then in principle a function could be written that gets the password out.
14:52:27 <ddarius> Sgeo: No, you'd newtype wrap it and only export a limited interface.
14:52:48 <ddarius> Otherwise, I could just use put to write to the state ignoring the password entirely anyway.
15:04:00 <kmc> there's probably a way to do this with an "unguessable" password
15:04:32 <kmc> rather than a hashed string, a value whose unique creation is guaranteed by the runtime system
15:04:41 <hpaste> irene-knapp pasted “99 lines of DOOM” at http://hpaste.org/55664
15:05:07 <kmc> vanilla GHC Haskell allows many features which can work around such features easily, like unsafeCoerce
15:05:12 <kmc> but it might stand up in Safe Haskell
15:05:37 <kmc> (i expect that Safe Haskell as currently implemented has holes, though)
15:10:02 <xil> hi. Can someone help me understand this hlint error?
15:10:04 <hpaste> xil pasted “hlint wut?” at http://hpaste.org/55665
15:11:08 <rwbarton> does ghc give a parse error also?
15:11:18 <Sgeo> What happens when you try to compile MandelbrotModel.hs ?
15:12:06 <tgeeky> xil: it's the space between \ and (?
15:12:12 <c_wraith> that space is fine
15:12:14 <xil> oh uh...how do I import other .hs files in the same dir?
15:12:18 <tgeeky> ok
15:12:19 <c_wraith> I have to assume the problem is a previous line
15:12:20 <rwbarton> the space is valid, but maybe hlint doesn't like it?
15:12:23 <tgeeky> xil: ignore that. I'm stupid.
15:12:25 <kmc> xil, name the file Foo.hs, then do "import Foo"
15:12:34 <kmc> Foo.hs needs to say "module Foo where" at the top
15:12:39 <c_wraith> also, you have to put a module Foo line in the file
15:12:40 <xil> kmc: did, but ghci is failing on it
15:12:50 <kmc> failing?
15:13:08 <xil> "Could not find module..."
15:13:14 <dmwit> xil: Store module Foo.Bar.Baz in file Foo/Bar/Baz.hs
15:13:16 <geekosaur> notice the ">".  I'm thinking something is failing to unlit
15:13:32 <kmc> i think that's how hlint indicates the line
15:13:36 <geekosaur> nemmind, that's pribably an artifact of how it reports
15:13:39 <geekosaur> yeh
15:14:06 <xil> misspelling on the module
15:14:09 <tgeeky> xil: nice fact, hpaste runs hlint over parsable code, so if you paste the source instead of the console excerpt, it should run hlint
15:14:17 <xil> the compile fails the same way
15:14:18 <geekosaur> next guess is hlint doesn't handle unsaturated declarations properly, but I'd think someone would have noticed that
15:14:58 <hpaste> xil pasted “paste ALL the code!” at http://hpaste.org/55666
15:15:32 <Sgeo> Does hlint on hpaste complain on parse errors, or just shut up?
15:15:33 <rwbarton> yeah, the previous code is bad, missing a } somewhere
15:15:43 <geekosaur> guess after that is it doesn't handle replacing the definitions of certain functions that it knows to look for specific issues about; iterate is a Prelude function
15:15:43 <xil> oh I see
15:15:45 <xil> whoops
15:15:47 <xil> thanks rwbarton
15:16:09 <geekosaur> ah
15:19:28 <xil> does anyone know why hlint and ghc don't catch the mismatched brackets first?
15:38:17 <drull95> whoo hoo! transcribing the grammar is done. now to fix bug after bug till it typechecks
15:38:26 <drull95> ^ c++ grammar
15:38:51 <kmc> haha
15:39:01 <kmc> you realize that only a few people have ever written full C++ parsers
15:39:20 <kmc> it is incredibly hard
15:39:40 <kmc> moreover it's a waste of your time
15:39:50 <drull95> yeah, i followed the grammar given in the working draft so it's a good start
15:39:59 <kmc> ok
15:40:01 <kmc> it's not going to work
15:40:05 <drull95> well at least parsing headers is useful for a binding generator
15:40:15 <drull95> i'd like to bind opencv
15:40:27 <drull95> without going through a lot of tedious work
15:40:34 <kmc> sure, if your goal is just "parse some selected, well-behaved C++ headers" then that's ok
15:40:46 <DasIch_> kmc: in attempting it you at least learn that you shouldn't
15:40:55 <kmc> but maybe using LibClang is less work
15:41:36 <drull95> we'll see. i'm going to try it for a week or two. i'm not expecting to make a perfect one
15:41:42 <drull95> worse is better and all that
15:42:12 <alistra> if anybody remembers my project https://github.com/alistra/data-structure-inferrer, it just analyzed its first C file today :P
15:42:20 <drull95> one thing i'd like to make is a refactoring tool, where refactoring means assisted translation into haskell :P
15:42:25 <ddarius> Or SWIG.
15:43:13 <kmc> drull95, why aren't you using LibClang
15:43:27 <drull95> never thought about it
15:43:36 <kmc> i suggested it a few days ago when you asked
15:43:40 <kmc> about parsing C++
15:43:47 <drull95> i tried looking at elsa, a defunct parser, but it's a mess
15:43:49 <ddarius> "I'll just write a parser for C++.  How hard could it be?"
15:43:54 <benmachine> hahaha
15:43:55 <drull95> bad memory i guess
15:43:57 <kmc> LibClang is Not Invented Here
15:44:22 <drull95> well it's fun.
15:44:26 <mike-burns> drull95: is this a project you're doing for fun, or is there actual money/time at stake?
15:44:41 <kmc> writing a C++ parser is fun?
15:44:44 <drull95> mike-burns, i'm a hobbyist
15:44:49 <kmc> i can think of few software projects less fun than that
15:44:53 <kmc> but, whatever suits you
15:45:01 <mike-burns> drull95: Awesome.
15:45:04 <mike-burns> Haters gonna hate.
15:46:01 <parcs`> what/with what library are you writing the parser in?
15:47:01 <drull95>  parsec
15:47:10 <cgroza> I did use parsec to parse my own lisp like language.
15:47:13 <alistra> i'm using a C parser
15:47:17 <alistra> and it's a nightmare
15:47:26 <alistra> not to tell anything about crazy c++ magick
15:47:35 * ddarius wishes he could watch "The Girl Who Leapt Through Time" for the first time again.
15:50:22 <hpaste> irene-knapp pasted “23 lines of DOOM” at http://hpaste.org/55667
15:50:39 <irene-knapp> ddarius: that was an awesome movie!
15:50:51 <irene-knapp> is it released anywhere, or you saw it at a film festival?
15:51:33 <ddarius> I don't know and no.  Also there are like fifty versions.
15:51:47 <xil> how do I compile a standalone executable? I ran "ghc --make" on the main .hs file but it only produced .hi and .o files
15:51:52 <irene-knapp> are there really?  wow, I see
15:51:58 <kmc> xil, it should have created an executable too
15:52:06 <irene-knapp> I saw it at a film festival here in NYC.  where did you see it?
15:52:08 <kmc> named after the main file
15:52:10 <xil> kmc: didn't. Do I need a Main module?
15:52:11 <alistra> ./main
15:52:23 <kmc> can you hpaste the command line you used and the output from ghc
15:53:16 <hpaste> xil pasted “building with ghc” at http://hpaste.org/55668
15:53:32 <ddarius> irene-knapp: I'm talking about the 2006 animated version, which I downloaded.
15:54:01 <irene-knapp> ddarius: that sounds like the version I saw, then.  I see!
15:54:14 <kmc> xil, hmm.  i guess if you have no Main module, then it silently decides not to produce an executable
15:54:27 <xil> haha. Okay. I can easily make a Main module
15:54:36 <kmc> well you did define 'main' somewhere, right?
15:54:44 <xil> yes
15:54:59 <pdxleif> Did you get an a.out or anything?
15:54:59 <xil> but maybe it should be called "mandelbrot" rather than "main" because the module is Mandelbrot?
15:55:01 <kmc> just change that file's first line to 'module Main where'
15:55:10 <xil> yeah I'll just do that
15:56:09 <xil> =/. This isn't working. It should at least be painting the screen with black, but it just does that thing where it smears what was on the screen already
15:56:58 <xil> also it keeps running in the background....
15:57:35 <c_wraith> xil: alpha blending modes, maybe?
15:57:44 <xil> c_wraith: no alpha
15:58:14 <c_wraith> well.  as a note, calling sdl's buffer flip function *doesn't clear* the current buffer.
15:58:24 <xil> OpenGL
15:58:39 <xil> required less learning in the short term
15:58:40 <acowley> what's up?
15:58:44 <c_wraith> ah, well, that changes things
15:59:40 <ddarius> How do people eat baked potatoes in addition to other food?
15:59:58 <acowley> I stick to baked sweet potatoes
16:00:22 <c_wraith> ddarius: in my family, by mashing them up. :)
16:00:45 <c_wraith> and figuring out how to fit everything else into the potato skin
16:01:02 <ddarius> I mash the potatoes with skins, and, actually, I don't eat baked potatoes.
16:01:44 <c_wraith> eh.  potatoes for baking have way more substantial skins than potatoes for boiling.
16:01:50 <ddarius> c_wraith: If you want to achieve bliss just before dying of a heart attack, replace milk with mayonaisse in mashed potatoes (and also add small chunks of cheddar.)
16:02:17 <ddarius> I don't use the smeary yellow potatoes for mash.
16:02:57 <c_wraith> I think I prefer red potatoes, when boiled.
16:03:30 <xil> I don't understand. I close this window but the program doesn't stop
16:03:32 <c_wraith> But traditional baker potatoes have really thick skins, even for russets
16:03:33 <xil> I have to kill it
16:03:34 <ddarius> Red potatoes are okay.
16:03:56 <c_wraith> xil: there's probably no handler for quitting the program just because the window closes
16:04:16 <xil> c_wraith: it's the default behavior for mainLoop, which I use
16:07:07 <tigger_> quick question, I find myself doing this frequently, and wondered if theres a better way to update a record value, as in the following code: new_data = old_data { some_record = update (some_record old_data) }, is there some pattern that makes it so I don't have to repeat the record extraction. not a big deal, just curious
16:07:39 <Axman6> tigger_: lenses!
16:08:28 <tigger_> Axman6: http://hackage.haskell.org/package/lenses?
16:08:33 <acowley> tigger_: use data-lens
16:08:55 <parcs`> how would i go about marshalling C structs to an equivalent haskell data type?
16:09:02 <acowley> tigger_: then it's just new_data = (some_record ^%= update) old_data  ((I think))
16:09:16 <rostayob> why is it that haskell kinds are not polymorphic? e.g. 'Foo a b = Bar (a b)', Foo : (* -> *) -> * -> *  and not something like (a -> *) -> * -> *?
16:09:29 <ddarius> (\r@Record{..} -> r{ field = update field }) r
16:09:33 <tigger_> Axman: cool thanks
16:09:38 <kmc> rostayob, that's just how it's specified.  but GHC 7.4 supports a polymorphic kinds extension
16:09:43 <tigger_> acowley: thanks!
16:09:44 * ddarius wonders if that is better or worse that just using the extracting function.
16:09:53 <parcs`> would something like newtype Foo = Foo (# CUInt, CUInt, CUInt #) work?
16:09:55 <kmc> parcs`, there are many ways.  i usually use hsc2hs
16:10:04 <rostayob> kmc: so there are no theoretical problems (e.g. in type inference) with polymorphic kinds?
16:10:13 <ddarius> rostayob: Because that would complicate the kind level.
16:10:14 <parcs`> kmc: what is the manual way?
16:10:16 <kmc> parcs`, what do you mean "work"?  you can't unsafeCoerce a Foo to a Ptr CFoo, if that's the question
16:10:46 <kmc> parcs`, https://github.com/kmcallister/hdis86/blob/master/Hdis86/C.hsc#L107
16:10:58 <kmc> here i don't even have a Haskell datatype for the struct
16:11:04 * ddarius loves the way hsc2hs works.
16:11:11 <kmc> just an empty type for a pointer tag, and some getters
16:11:23 <rostayob> ddarius: "compicate" as in undecidability or worse or just more complex inference algorithm?
16:11:30 <kmc> parcs`, iirc the hsc2hs manual (part of the ghc manual) is pretty good
16:11:35 <tigger_> ddarius: I was having a hard time asking that question here, since I thought there couldn't be an easier way, but It's just come up too often especially when accessors have long names... it got way too painful... thank goodness haskell has a better way.
16:11:37 <ion> I love bindings-DSL.
16:11:39 <ddarius> rostayob: Inference isn't the only issue.
16:13:20 <rostayob> ddarius: if you have time, what are the other issues?
16:13:38 <xil> I have a TArray with 360,000 elements and my program is getting stuck on "atomically $ getElems marr". Does anyone have any ideas why that might be?
16:14:45 <c_wraith> what version of ghc?
16:14:48 <augur> anyone familiar with the FGL?
16:14:52 <c_wraith> I seem to remember bugs related to that
16:14:58 <xil> c_wraith: 7.0.3
16:15:02 <c_wraith> hmm.
16:16:00 <c_wraith> I don't know.  Any particular reason you're using a TArray, though?
16:16:06 <xil> thread safe
16:16:15 <c_wraith> I'm not sure that's relevant
16:16:22 <xil> suggest away =]
16:16:34 <xil> well, let me say what I'm doing first maybe?...
16:16:42 <c_wraith> yes, that's pretty necessary
16:16:44 <c_wraith> :)
16:17:35 <parcs`> thanks, i'll check out hsc2hs and bindings-dsl
16:17:41 <xil> I have one thread computing the color values of points on the field (it's a Mandelbrot set viewer). So I need to store those values somewhere so that the View can read them and put them on the screen. Doing this in OpenGL I need the end product to go into a pointer array
16:18:02 <parcs`> heh, bindings-DSL has the dependency 'base < 1000'
16:18:21 <c_wraith> Why do you have an array at all?  there's no inter-dependence between the values of points
16:18:24 <kmc> bindings-DSL is a set of macros for hsc2hs
16:18:29 <kmc> i have not used it, but it looks nice
16:18:54 <xil> c_wraith: noobishness =]. I'd do it very differently in Java. I just don't know programming strategies in Haskell quite yet
16:19:36 <c_wraith> xil: I see no need for an array at all.  You should be able to just get away with mapping a function over a list of coordinates
16:19:54 <rampion1> can someone help me figure out why ghc —make isn't finding an installed package?
16:19:55 <rampion1> % cabal install hspec
16:19:55 <rampion1> % ghc-pkg expose hspec-0.9.0
16:19:55 <rampion1> % ghc —make Ex.hs
16:19:55 <rampion1> Ex.hs:4:8:
16:19:55 <rampion1>     Could not find module `Test.HSpec':
16:19:56 <rampion1>       Use -v to see a list of the files searched for.
16:20:15 <Goosey> (\l@(x:xs) -> (x,length l)) What does @ mean?
16:20:28 <rampion1> Goosey - it means match both patterns
16:20:29 <cmccann> xil, if the values you're writing to the array are being read back out and written somewhere else to actually display the image, you'd probably be better off ditching the array
16:20:31 <Axman6> Goosey: it gives a name to that whole expression:
16:20:35 <Axman6> > (\
16:20:35 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:20:37 <hpc> Goosey: it means, match on (x:xs)
16:20:41 <hpc> Goosey: but call the whole thing l
16:20:41 <rampion1> bind the argument to both l and (x:xs)
16:20:55 <Axman6> > (\l@(x:xs) -> (x,xs,l)) [1,2,3]
16:20:56 <kmc> you can't use it with arbitrary two patterns though
16:20:56 <lambdabot>   (1,[2,3],[1,2,3])
16:20:57 <Goosey> Oh okay
16:20:59 <kmc> only variable@pattern
16:20:59 <xil> c_wraith: mind a private chat?
16:21:11 <Goosey> X:XS is the pattern matching of the list L
16:21:18 <c_wraith> xil: not at all
16:21:21 <Axman6> yeah, basically
16:21:30 <kmc> rampion1, because it's named Test.Hspec not Test.HSpec
16:21:36 <Goosey> Okay, thanks
16:21:37 <Axman6> Goosey: how did you go with those intermediate haskell exercises i gave you?
16:21:46 <rampion1> @kmc: thanks
16:21:46 <lambdabot> Unknown command, try @list
16:22:03 <Goosey> Axman6: They're still a bit too complex, I have them bookmarked for when I complete LYAH.
16:22:10 <cmccann> rampion1, IRC doesn't need @ signs to talk to people :P
16:22:53 <Axman6> Goosey: LYAH will probably give you plenty of the answers. but they're still worth doing, to make sure you understood them properly
16:23:16 <rampion1> but I love my at-symbol
16:23:16 <Goosey> Alright, well I will then :P
16:23:16 <kmc> hi cmccann :)
16:23:27 <kmc> @cmcann hi #lol #wtf #irc
16:23:27 <lambdabot> Unknown command, try @list
16:24:38 <ion> @haskell Hi #greeting #irc
16:24:39 <lambdabot> Unknown command, try @list
16:24:45 <cmccann> heya kmc, how goes :]
16:24:53 <kmc> goes well
16:26:38 <parcs`> can the ffi handle functions that return structs by value?
16:27:00 <kmc> i don't know of a way to do so
16:27:14 <kmc> i would write a wrapper in C which stores it to a pointer
16:27:22 <cmccann> even if there is a way to do so, the wrapper is probably easier
16:27:50 <parcs`> curses
16:28:04 <kmc> it's easy to make cabal build some c code along with your haskell library
16:30:19 <parcs`> wouldn't an unboxed tuple (# CInt, CInt, Cint #) have the same internal representation as a struct { int a; int b; int c; }?
16:30:31 <kmc> only by accident
16:30:42 <kmc> actually, not even then
16:30:46 <kmc> unboxed tuples aren't values
16:31:06 <kmc> they're basically the syntax for functions returning multiple values
16:31:18 <kmc> you can't store them in data structures or pass them to functions
16:31:40 <cmccann> kmc, so hey, I seem to recall you being interested in various flavors of stuff to help people learn Haskell, does that remain accurate
16:32:03 <parcs`> i see
16:32:16 <kmc> parcs`, basically the only use is, you can call a function which returns an unboxed tuple, and you have to pattern-match the unboxed tuple at the call site
16:32:48 <kmc> and iirc GHC implements this by passing the values in different STG registers
16:32:59 <kmc> which usually means different CPU architecture registers
16:35:04 <Goosey> Gosh, string manipulation is stupid easy in haskell..
16:35:09 <kmc> no it isn't
16:35:15 <kmc> there's not even a 'split' function in the standard library
16:35:20 <Goosey> >_>
16:35:24 <alistra> @src split
16:35:24 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
16:35:28 <alistra> @hoogle split
16:35:28 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
16:35:29 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
16:35:29 <lambdabot> Data.Typeable splitTyConApp :: TypeRep -> (TyCon, [TypeRep])
16:35:31 <kmc> see 'split' package on hackage
16:35:34 <Goosey> well with the list mdule
16:35:35 <Axman6> Goosey: some things are, some are a pain in the arse, that other languages handle much better
16:35:43 <hpc> @hoogle strings
16:35:43 <lambdabot> package stringsearch
16:35:43 <lambdabot> Data.ByteString findSubstrings :: ByteString -> ByteString -> [Int]
16:35:43 <lambdabot> Data.ByteString.Char8 findSubstrings :: ByteString -> ByteString -> [Int]
16:35:50 <kmc> parcs`, probably «data Foo = Foo Int# Int# Int#» has the same representation as «struct { void *info_table; long x; long y; long z; }»
16:35:51 <kmc> but maybe not
16:35:59 <kmc> maybe your C compiler puts padding in weird places
16:36:01 <hpc> @hoogle Data.String
16:36:01 <lambdabot> Prelude type String = [Char]
16:36:01 <lambdabot> Data.String type String = [Char]
16:36:01 <lambdabot> Data.String module Data.String
16:36:03 <cmccann> it's easy compared to some languages, but that has more to do with those languages being terrible than Haskell being good
16:36:03 <alistra> kmc: did you mean split like in python?
16:36:04 <kmc> maybe GHC does
16:36:19 <kmc> parcs`, so I think it's best to treat that as coincidence
16:36:56 <kmc> cmccann, yeah, I'm broadly interested in helping people learn Haskell
16:36:59 <Goosey> cmccann: definitely...
16:37:00 <kmc> what did you have in mind
16:38:00 <peppect> mknb
16:38:01 <cmccann> kmc, thinking about worked examples of simple but not-completely-trivial programs, particularly ones that do things people often assume Haskell isn't good at
16:38:13 <kmc> what about what's in RWH
16:38:18 <kmc> how does that compare to what you want
16:38:35 <kmc> i think more examples of concurrent network servers would be great
16:38:42 <hpc> cmccann: my favorite token example is simple CGI
16:38:44 <kmc> like a little MUD, using STM to handle interaction between players
16:39:02 <cmccann> kmc, been a little while since I read RWH but I recall it spending a fair amount of time on the language itself
16:39:11 <Mongey> If I had some like data State = State {modified = Bool} how would I access the value of modified in a function ?
16:39:19 <hpc> cmccann: it lends itself well to dramatic reductions in code size with a few well-writen functions
16:39:39 <ddarius> `
16:39:48 <cmccann> I'm more thinking just a straightforward presentation of programs, with some explanation of "why I did it this way"
16:40:02 <cmccann> for people who get the basic syntax and such, but don't know where to start on actually doing things
16:40:37 <cmccann> hpc, yeah, that'd be a good possibility
16:41:02 <hpc> cmccann:
16:41:06 <hpc> er
16:41:13 <cmccann> kmc, a MUD sort of thing was actually the first thing on my list already, haha
16:41:27 <hpc> cmccann: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=5 -- poorly edited, but covers all the important stuff
16:41:47 <hpc> i still need to go back and revise it with the rest of the code
16:44:02 <ddarius> Mongey: That's a syntax error.
16:44:11 <cmccann> hpc, hm, that's actually even simpler than what I was thinking of, I guess
16:45:39 * ddarius wants to beat hpc after reading the first code block on that page.
16:46:13 <hpc> ddarius: beat me at making the code as readable as possible?
16:46:25 <Mongey> ddarius I meant data State = State {modified::Bool}
16:46:45 <parcs`> Mongey: given a value 's' of type 'State', 'modified s' gives you the value of the 'modified' field
16:46:54 <ddarius> Mongey: The modified is a function State -> Bool.  You can also use record patterns.
16:47:13 <cmccann> kmc, my secondary goal, in a loose sense, would be to ensure the examples are "complete" in some sense, in the sense of not taking bogus shortcuts to "simplify" things
16:47:15 <Goosey> It seems like monads are nothing more than data structures
16:47:36 <alistra> instances of monads are data structures
16:47:37 <Mongey> parcs` , ddarius : cheers
16:47:44 <Goosey> I haven't read anything about them, but Maybe was just used.
16:50:15 <kmc> Goosey, "Monad" is the name of a generic interface supported by a variety of data structures
16:50:31 <Goosey> Yeah
16:50:41 <kmc> it does different things for each data structure
16:50:44 <kmc> fairly unrelated things
16:50:56 <Goosey> kmc: I guessed Maybe's structure based on what it did and when I did @src Maybe I was right :D
16:51:21 <kmc> well, the fact that Maybe is a monad is irrelevant
16:51:26 <kmc> if you are just now learning what Maybe is
16:51:45 <kmc> you can use it directly through pattern-matching
16:51:51 <kmc> you don't have to care that there's this monadic interface
16:52:09 <Goosey> Yeah, that's what they said, just to pretend it's magic until you are able to grasp it.
16:52:18 <cmccann> Goosey: Maybe you were right? Well, were you or weren't you? :]
16:52:29 <kmc> Goosey, that doesn't make sense to me
16:52:34 <kmc> are you talking about the definition of Maybe
16:52:40 <kmc> or about the «instance Monad Maybe where ...»
16:53:10 <kmc> @src Maybe
16:53:10 <lambdabot> data Maybe a = Nothing | Just a
16:53:11 * cmccann recalls reinventing the monad instance for Either at least twice prior to really understanding the whole monad thing
16:53:33 <dmwit> ?quote doomed
16:53:33 <lambdabot> Pseudonym says: Those who reinvent monads are doomed to understand them.
16:53:44 <cmccann> dmwit, pretty much
16:53:45 <kmc> haha
16:53:48 <ddarius> kmc: Most of what Goosey is saying makes little sense.  This is not an area in which to invest your time.  You'll just catch bitterness.
16:53:49 <Goosey> kmc: I was talking about the instance of monad
16:54:03 <kmc> oh, well "@src Maybe" says nothing about that
16:54:08 <Goosey> I'm just saying I think that I'll be able to understand monads when they come :/
16:54:16 <kmc> maybe these were two unrelated statements by you and I misunderstood
16:54:24 <kmc> ddarius, catch?
16:54:42 <kmc> ;)
16:54:45 <NihilistDandy> try, then catch
16:54:55 * cmccann throws some bitterness
16:55:01 <Goosey> I'll just slowly fade back into the lurk-zone and read more LYAH
16:55:30 <kmc> Goosey, it's common to have epiphanies about "Oh, monads are just <foo>!".  these are universally not to be trusted
16:55:39 <Goosey> Oh okay
16:55:41 <Goosey> xD
16:55:56 <kmc> like i said, it's a very generic interface to a lot of different, unrelated behavior
16:56:03 <kmc> so it's hard to come up with a tight analogy for all of that
16:56:36 <cmccann> monads are just an overused quote from James Iry's blog, what's the problem
16:57:00 <NihilistDandy> Though really they're burritos
16:57:01 <c_wraith> I like James Iry's later comment that he managed to google-bomb himself for the phrase "mostly wrong" with that post.
16:57:03 <NihilistDandy> Or spacesuits
16:57:04 <NihilistDandy> Or something
16:58:20 <cmccann> @quote syntaxglitch burrito
16:58:20 <lambdabot> syntaxglitch says: a monad is an endospacesuit on a burrito category
16:58:54 <wereHamster> if I import something in my module, will that be available only to my own module or also to modules which import me?
16:58:56 <kmc> monads are like inside jokes, they annoy the crap out of anyone learning Haskell
16:59:16 <kmc> wereHamster, only in your own module, unless you explicitly export it
16:59:25 <c_wraith> wereHamster: only in your module, unless you re-export it.  and except for instances
16:59:46 <wereHamster> and if I don't explicitly export anything, haskell exports everything, right?
16:59:59 <c_wraith> only things defined in that module, by default
17:00:07 <kmc> if there is no export list, then it exports everything defined in your module
17:00:16 <kmc> "don't explicitly export anything" is ambiguous because you can also have an empty export list
17:00:20 <cmccann> kmc, the interesting thing is that "inside jokes about inside jokes about X" are also "inside jokes about X". still working on defining fmap and return, though.
17:00:25 <wereHamster> can I say export everything that I imported?
17:00:45 <kmc> no but you can re-export a whole module by name
17:00:52 <kmc> module Foo(module Bar) where { import Bar }
17:01:05 <kmc> if you also want to export everything defined locally,
17:01:09 <kmc> module Foo(module Foo, module Bar) where { import Bar }
17:01:33 <c_wraith> a module explicitly exporting everything it defines results in funny-looking declarations.
17:01:53 <kmc> cmccann, trust me, others have been down that path
17:02:02 <kmc> it results in... more inside jokes and more annoying beginners
17:02:51 <cmccann> kmc, yeah, I should probably get back to thinking about example programs
17:04:25 <kniu> is there a typeclass for lookups?
17:04:31 <kniu> like
17:04:40 <wereHamster> c_wraith: I have about 100 modules which I want to import somewhere, so I thought I'd generate a 'proxy' module so I only have to write a single import like where I need them
17:04:41 <kniu> instance Lookupable [(k, v)] where
17:04:53 <kniu> instance Lookupable Map where
17:04:56 <kniu> or something
17:05:16 <cmccann> kniu, not a standard type class because that's not going to work very well without GHC extensions
17:05:30 <cmccann> there may be something on Hackage though
17:05:40 <kmc> http://hackage.haskell.org/package/keys
17:05:48 <c_wraith> wereHamster: it can be done, but it'll need a lot of boilerplate.  Haskell doesn't provide a convenient way to cut down on that.
17:06:26 <wereHamster> c_wraith: I can generate the boilerplate code as long as it is in the 'proxy' module
17:06:30 <kniu> thanks kmc
17:06:30 <c_wraith> wereHamster: except to editorialize to say "maybe if there are that many modules, some should be re-exporting others in ways that make sense for common use patterns, anyway"
17:06:50 <ybit> looking for a mentor..
17:07:03 <ybit> someone who will hold the whip over me and make me work on haskell projects
17:07:33 <wereHamster> c_wraith: all of those are 'top level' modules, there are no inter dependencies.
17:07:36 <c_wraith> wereHamster: anyway, you can do it.  Just a long list of explicit module exports, and then later importing those same modules
17:07:43 <cmccann> ybit, just pop into #haskell and ask if you should be working on haskell projects every so often
17:07:51 <cmccann> like mentoring-on-demand
17:08:03 <kmc> yeah but #haskell is a great distraction from working on haskell projects
17:08:19 <cmccann> kmc, speaking from experience?
17:08:21 <cmccann> ;]
17:08:40 <ybit> r makes it so easy to fool yourself into thinking you are actually getting work done
17:09:25 <ybit> right and irc is a distraction... so back to work :)
17:09:36 <mgsloan> true, because you're learning things.  It can also be a good motivator, seeing people get excited about stuff 'n such
17:10:37 <cmccann> for what it's worth, trying to answer questions on Stack Overflow was my major source of motivation while learning Haskell
17:11:05 <cmccann> you can basically chart the course of my understanding of the language by looking at the answers I've posted in chronological order
17:11:08 <rampion1> teaching is a great way to learn
17:11:32 <cmccann> other than about 3 months of lead time when I was getting the basics figured out
17:11:46 <kmc> true but most of what you can teach here is details, not big-picture stuff
17:12:37 <kmc> answering questions in #haskell or Stack Overflow won't teach you how to design a big project
17:13:00 <rampion1> so anyone want to check out my command line argument parser? https://github.com/rampion/ReadArgs/blob/master/ReadArgsEx.hs
17:13:19 <mike-burns> ybit: If you can't find a mentor to crack the "write more Haskell!" whip, another option is to arrange to give a presentation in Haskell on a project that you haven't finished yet.
17:14:13 <mike-burns> Deadlines, etc.
17:14:20 <kmc> rampion1, what's the design goal?  how does it differ from cmdargs, parseargs, simpleargs, GetOpt, etc?
17:14:22 <cmccann> mike-burns, ah, the "playing chicken with your procrastination" strategy I see
17:14:31 <mike-burns> Hah, I like that description cmccann .
17:15:12 <cmccann> mike-burns, that's pretty much how it works, and I know because that's how I got through college, haha
17:15:19 <rampion1> kmc: SimpleArgs plus optional and variable arguments, basically
17:15:46 <mike-burns> I'm in the middle of playing chicken right now in exactly the way I've described.
17:15:59 * ddarius is at the end of playing chicken.
17:16:15 <ybit> maybe i could work on some ghc bugs or something
17:16:52 <kmc> who in this channel is working on big, long-term projects in Haskell, with external goals?
17:17:10 <cmccann> define "big"
17:17:25 <kmc> no u
17:17:31 <cmccann> >:[
17:17:50 <irene-knapp> define external
17:18:10 <ddarius> define Haskell
17:18:12 <kmc> how about "someone else cares if it gets done" for starters
17:18:19 <irene-knapp> oh, then no, haha
17:18:53 <kmc> apparently people *do* use Haskell for projects like this, based on what i read elsewhere
17:18:59 <kmc> but i think those people are underrepresented here
17:19:15 <mike-burns> Those people should hire more of us. Clearly.
17:19:16 <irene-knapp> possible
17:19:22 <cmccann> probably because they're too busy writing Haskell to waste time on IRC
17:19:27 <kmc> right
17:19:41 <ddarius> Which means that that statement is likely true for many IRC channels.
17:19:59 <kmc> and they know enough already that lurking here isn't such a good use of time
17:20:18 <dolio> How come all the people working on big, important projects in computer programming don't have any free time?
17:20:31 <gwern> > 730+680
17:20:32 <lambdabot>   1410
17:20:37 <ddarius> Lennart is here upon occasion.
17:20:47 <ddarius> As well as Don and Manuel.
17:21:00 <cmccann> "upon occasion" being the important part there
17:21:02 <kmc> presumably a project could be important and still consume less than 80 hours a week
17:21:05 <kmc> *nod*
17:21:10 <ddarius> And Simon Marlow and very rarely Simon Peyton Jones.
17:21:14 <irene-knapp> dolio: lol
17:21:48 <cmccann> I know Lennart is on Stack Overflow and reddit pretty regularly as well, so it's possible he's just extremely efficient at working on his big important projects
17:22:50 <ddarius> If I were working on a "big, important" project in Haskell right now, I probably wouldn't talk about it much or at all here.
17:23:35 <kmc> yes, it seems that many of the 'real world' uses of haskell are unpublished software in secretive industries
17:23:42 <kmc> (defense, intelligence, finance)
17:23:55 <ddarius> kmc: Yes, though that doesn't have much to do with my statement.
17:23:56 <dolio> Kind of like the real world uses of everything else?
17:24:01 <cmccann> ddarius, I always figured the main reason you're in here is to find people who are wrong about something, so that you can tell them as much ;]
17:24:17 <ddarius> cmccann: I don't need to be here to do that.
17:24:29 <kmc> it seems like the ratio is different
17:24:30 <dolio> Yes, there are wrong people all over the place.
17:24:44 <kmc> just walk down the street
17:24:50 <kmc> "hey you!  you're wrong about something!"
17:24:52 <cmccann> yes, that's true
17:24:58 <ddarius> cmccann: I will agree that that is usually what I do, besides using #haskell as my own twitter feed.
17:25:01 <kmc> yelling at signs on the T
17:25:06 <mike-burns> The ratio is definitely different, judging from the people I know in #ruby or #python.
17:25:07 <kmc> "hey, that train hasn't gone there since the 80's"
17:25:54 <ybit> looking for some practical project to work on..
17:26:06 <ybit> wouldn't mind implementing org-mode for yi
17:26:13 <kmc> revive 'buddha', the declarative debugger for Haskell 98
17:26:20 <kmc> make it work on modern GHC
17:26:50 <mike-burns> Haskell definitely has the opposite problem of e.g. Rails: tons of hirable devs, all willing to work on Haskell for cheap.
17:27:11 <kmc> mike-burns, really?  i think the number of people who know Haskell well enough to work on a "real project" is pretty small
17:27:28 <mike-burns> Same is true of every language.
17:27:31 <kmc> no it's not
17:27:38 <mike-burns> OK, not Java.
17:27:39 <kmc> that is false
17:27:56 <kmc> not Java or C or C++ or Python or C# or Ruby or PHP or Perl or Javascript or Visual Basic or ASP.NET or ...
17:27:59 <mike-burns> It's definitely true in Ruby.
17:28:04 * ddarius is not willing to work on Haskell for cheap unless I'm doing it of my own accord.  I am willing to have someone pay me to do something I'm already doing.
17:28:14 <cmccann> the number of programmers who know programming well enough to work on a "real project" is pretty small
17:28:37 <kmc> maybe so but the number who can do it in Haskell is far smaller
17:28:48 <cmccann> granted, yes
17:29:04 <ddarius> That's almost a tautology.
17:29:09 <kmc> if i wanted to wank about how we're all magical 10x master hackers then I would still read reddit
17:29:37 <mike-burns> Sure, but that's how we all start. We get hired by BSing our way in and then adopt a quick "sink or swim" mentality.
17:29:50 <mike-burns> This isn't special to Haskell, really.
17:29:52 <ddarius> mike-burns: Speak for yourself.
17:30:01 <mike-burns> OK.
17:30:05 <mike-burns> That's how I start, etc.
17:30:19 <cmccann> however, Haskell is enough of a niche language with a high enough learning curve that an unusual proportion of people who use it actually do know it well compared to most other languages
17:30:38 <kmc> i disagree, depending on how you define the term "use it"
17:30:51 <kmc> a great many people learn Haskell well enough to write fibonacci and quicksort
17:30:59 <kmc> and maybe a couple of utilities for personal use
17:32:02 <kmc> the path from there to working on a big, messy codebase is much trickier than the similar path for, say, Python
17:32:25 <mike-burns> What can we do to make that more streamlined?
17:32:32 <cmccann> kmc, I'm not claiming it's any particularly large portion, just larger than most other languages. if there's a point of disagreement, it's probably in how negative my assessment is of the situation for other languages
17:32:39 <ddarius> Make fibonacci and quicksort messier.
17:32:42 <mike-burns> Hah.
17:32:47 <kmc> more detailed explanation of lazy evaluation and structural sharing in persistent data
17:33:02 <kmc> more detailed writeups of all the performance-tuning black magic
17:33:08 <kmc> fewer ghc bugs
17:33:27 <cmccann> kmc, more seriously though, how do you define "big" in this context? honest question, I'm curious.
17:33:40 <AfC> ghc error messages that actually make sense
17:33:53 <kmc> i don't know
17:34:11 <mike-burns> Hm, I feel like I should help with this. Guess I should try some ghc bugs.
17:37:23 <Philippa> ddarius, mike-burns: what value of "cheap" are you using?
17:38:17 <mike-burns> I meant it as "less than they'd get for a Java job".
17:38:34 <c_wraith> AfC: what part of "my brain exploded" doesn't make sense? :)
17:40:00 <Philippa> mike-burns: honestly? I'm probably worth more in Haskell anyway
17:40:09 <cmccann> ghc's error messages are actually pretty helpful if you know how to interpret them
17:40:14 <Philippa> modulo the rarity factor
17:40:25 <mike-burns> Philippa: It's the rarity factor that does it, though.
17:40:57 <cmccann> I keep meaning to write up a "GHC error-ese to English dictionary"
17:41:02 <Philippa> cmccann: mostly. You can get into some really nasty tangles with recursion or with constraints that you can't see why they won't solve
17:41:32 <Philippa> the undecidability of polymorphic recursion means that accidentally introducing it (yes, I've done this) *really* hurts
17:42:01 <cmccann> Philippa, most of those can still be interpreted though, it's just that the interpretation is "GHC is really confused about X, do something to help it and try again"
17:42:16 <cmccann> like adding strategic type signatures for what you think something should be
17:42:19 <cgroza> cmccann: and sometimes the type inference will give you misleading errors. Adding a type signature usualy gives GHC a hint.
17:43:19 <cmccann> cgroza, right, recognizing when that's happening is part of learning to interpret the errors :]
17:44:18 <kmc> i think i'd accept lower pay to work at a company where everyone knows haskell, all else being equal
17:44:24 <kmc> whether they actually use haskell is less important
17:44:40 <mike-burns> Seems reasonable to me.
17:45:14 <Philippa> cmccann: sure. It's "pretty helpful" that I'm disputing, not "interpretable" :-)
17:45:15 <cmccann> but mostly I'd be after things like "infinite type" errors which sound weird to newcomers, or stuff like "no instance for X" when GHC always suggests adding an instance even though that's almost never the actual error
17:45:42 <Philippa> kmc: I'd certainly take a career path with a lower long-term payout for it
17:45:50 <cmccann> Philippa, they're helpful in that they help you pinpoint the error efficiently if you know how to interpret them, in contrast to completely uninformative errors
17:46:12 <xil> hi. I'm implementing a message buffer for communicating between my two threads. I currently do it with a TChan and a data type I made for messages. c_wraith had suggested something with a mutable variable storing a function from [Command] -> [Command]. Does anyone know what he might have meant and how to do it?
17:46:12 <Philippa> I have comparatively high base requirements unfortunately, which limits things at the junior end of the scale
17:46:21 <cmccann> they're often unhelpful or worse if you don't know how to interpret them :[
17:46:29 <Philippa> cmccann: the constraint ones don't really do it by much
17:46:41 <AfC> cmccann: yeah, that's the one that gets me. "Add an instance" oh. Good. Yes. Let me get right on that. I'm sure it will help.
17:47:37 <kmc> i think you're best off ignoring all suggestions from ghc
17:47:50 * AfC writes that down
17:47:55 <AfC> :)
17:48:09 <cmccann> AfC, yeah, in my experience both personally and from questions on Stack Overflow, 95% of the time those come from something like forgetting a map
17:48:17 <c_wraith> xil: hah, I'm back around now.
17:48:21 <cmccann> and thus trying to sum [[Int]] instead of [Int]
17:48:37 <xil> c_wraith: oh hey. I'd love to know more about it now =]
17:48:38 <cmccann> and GHC suggesting a Num instance for [a] is really, really not useful there
17:49:29 <Philippa> I've said it before and I'll say it again: we need typing debuggers
17:49:30 <AfC> cmccann: the other one I blow all the time is forgetting to add the variable at the end of a function chain. You suddenly get horrible errors about missing (a -> b) when really all you needed to do was change blah to blah x
17:49:54 <cmccann> AfC, yeah
17:50:02 <AfC> I mean, yes, sure, after I figure it out I realize what IT thought I was trying to do, and why in that circumstance that error would make snes.
17:50:12 <AfC> sense* but since I wasn't doing anything of the sort, it's quite misleading
17:50:31 <hpc> AfC: always start from the line number; the rest of the error message is "hints" :P
17:50:34 <cmccann> AfC, hence why I've wanted to write a translation guide :]
17:50:38 <AfC> hpc: heh
17:52:25 <cmccann> kmc, by the way, any other ideas for interesting example programs? simple games are my usual stand-by so "something that isn't tetris using SDL" and "a MUD server" were the only two I already had planned
17:53:26 <kmc> hmm
17:53:28 <kmc> i'll think about it
17:53:39 <cmccann> kmc, no rush :]
17:53:57 <rampion1> cmccann: I've got half a game written - it's a mediator for a game of Clue
17:54:05 <cmccann> I'm just thinking about it because of a short example I wrote as part of a reddit discussion I wasted entirely too much time on
17:54:15 <rampion1> just need some player implementations
17:54:39 <cmccann> rampion1, was more hoping for non-game ideas actually, for variety, but that could be interesting as well
17:55:03 <cmccann> rampion1, is the code on github or anything?
17:55:04 <hpc> cmccann: bindings for some google APIs?
17:55:11 <kmc> cmccann, oh, i have an example
17:55:16 <kmc> this is something i wrote recently
17:55:29 <Eduard_Munteanu> General Haskell projects?
17:55:39 <rampion1> https://github.com/rampion/clue
17:55:44 <hpc> Eduard_Munteanu: simple ones that are useful as examples
17:55:49 <Eduard_Munteanu> Ah.
17:55:59 <hpc> Eduard_Munteanu: "interesting example programs"
17:56:08 <kmc> so the story here is, i have a bunch of music files in various formats (flac, mp3, m4a, in various quality levels)
17:56:09 <cmccann> hpc, I'm somewhat ambivalent about things like that, because the incidental complexity of interfacing with whatever can easily swamp the actual program logic
17:56:22 <kmc> and i wanted to re-encode them all as ogg vorbis, for listening on the go
17:56:34 <kmc> and i wanted to distribute this task across several machines
17:56:39 <kmc> all of which have access to the music directory via sshfs
17:56:41 <hpc> cmccann: google's docs tell you how to interface with them using curl
17:56:43 <Eduard_Munteanu> Not that simple, but not really large either... I was thinking it'd be nice have a slim KVM client written in Haskell. All that C device emulation kinda makes me cringe.
17:57:05 <hpc> cmccann: and then the rest is json; you can use existing libraries and just pull out the data and do some interesting things with it
17:57:20 <hpc> the boring stuff should be fairly simple
17:57:20 <kmc> so i wrote a tiny "distributed job scheduler" in Haskell, which uses ssh to invoke a python script that does the encoding for a single album
17:57:24 <kmc> http://hpaste.org/54422
17:57:36 <hpc> kmc: ooh, neat
17:58:13 <cmccann> Eduard_Munteanu, for my purposes, Haskell programs that do something interesting, probably between 200 and 800 lines of code give or take, are conceptually complete and useful, and not stereotypical "things Haskell is best at" like compilers
17:58:14 <hpc> kmc: did you find that it duplicated work much?
17:58:45 <Eduard_Munteanu> Ah.
17:58:50 <cmccann> hpc, might not be too bad then, if it can be offloaded to existing libraries in a straightforward way
17:58:59 <hpc> cmccann: you can write an IRC bot with plenty of cool features in about that many lines
17:59:23 <cmccann> an IRC bot would fit, yeah
17:59:41 <hpc> cmccann: for a while the bot i maintain was about 700 lines of haskell, with a symbolic calculator/differentiator and an RPN calculator that was bordering on becoming a stack-based programming language
17:59:43 <cmccann> though we already have lambdabot and I'd rather not just reinvent wheels
17:59:59 <hpc> now it's perl and does scarier things
18:00:14 <cmccann> so I'd need something interesting for the bot to do beyond just "be on IRC"
18:00:27 <kmc> hpc, what do you mean?
18:00:27 <hpc> cmccann: the wheel there would be "lambdabot minus the insane dependencies"
18:00:31 <Philippa> I tend to think of IRC bots as a "stereotypical thing", but I realise that's because my stereotype's slightly more general
18:00:35 <cmccann> hpc, hahaha
18:00:38 <Eduard_Munteanu> Dunno, but recently I kinda felt the urge some things out to be implemented in a safer language.
18:00:39 <kmc> an IRC-based MUD might be fun
18:01:00 <hpc> kmc: the scarier things, why it's perl now, or how it worked in haskell?
18:01:05 <Philippa> (IRC bot = stateful interpreter with a slightly different IO layer from usual)
18:01:11 <cmccann> kmc, ehh I think that'd be awkward at best
18:01:14 <kmc> hpc, i meant <hpc> kmc: did you find that it duplicated work much?
18:01:20 <kmc> what do you mean by duplicating work
18:01:41 <hpc> kmc: like, did the same file get encoded on multiple machines
18:01:53 <hpc> suppose there was a delay getting the file from the sshfs
18:01:57 <kmc> (btw this code shows off two of my small utility libs from hackage ;)
18:01:58 <cmccann> Philippa, IRC bots are kind of borderline, but if it did something interesting it might be worthwhile
18:02:04 <Philippa> I don't have a particular domain, but pick a constraint problem and instrument the fuck out of it for fun and profit?
18:02:05 <Eduard_Munteanu> cmccann: here's one that's been bugging me... a password manager
18:02:07 <kmc> hpc, no, I think as written it will encode each album at most once
18:02:29 <hpc> ah, cool
18:02:34 <kmc> it does nothing to handle failure, but that worked out okay
18:02:46 <cmccann> Eduard_Munteanu, elaborate a bit?
18:02:49 <Philippa> cmccann: coupling it with safe access to some toy DB might work. Injection-proof, that kind of thing
18:02:52 <kmc> the python script (enc.py) creates a pidfile in the output directory, and deletes it on exit
18:02:59 <hpc> i imagine the failures would do noisy things, yeah
18:02:59 <kmc> so i can tell if one of them crashed
18:03:16 <Eduard_Munteanu> Most stuff I've looked into was GUI-only and had incompatible formats, I kinda settled with pwsafe after all which has a CLI interface. But that sort of stuff is usually old.
18:03:16 <kmc> you could rewrite that script in Haskell too, but I think it's less of a clear win
18:03:37 <cmccann> Philippa, still seems a bit aimless, I guess? I'm hoping for something more concrete and self-contained.
18:03:42 <kmc> also it's more particular to the way i organize music, and less broadly interesting
18:03:54 <kmc> it extracts some metadata from the file paths, etc.
18:04:02 <hpc> cmccann: oh, here's a good one, even though it's very simple: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=11
18:04:14 <cmccann> Eduard_Munteanu, hm. could be interesting, but not something I have a clear enough idea of to tackle personally right now.
18:04:14 <Philippa> if it weren't knowingly kludgy I'd suggest my wordpress toolchain
18:04:17 * cmccann adds it to his list anyway
18:04:25 <Philippa> I mean, it's pandoc lashed up to a few tools in a very scripty kind of way
18:04:46 <kmc> (by the way, is there a nicer implementation of that 'Queue' type from http://hpaste.org/54422 ?)
18:04:47 <hpc> ("simple" in what it does, not in how it accomplishes it)
18:04:49 <Philippa> but it's make my blogging work a lot more pleasant
18:04:58 <Eduard_Munteanu> Yeah, maybe it's not a good idea, but certainly I found that field lacking in the Linux world.
18:05:10 <Philippa> and there's a myth that haskell is bad for IO and thus bad for scripty stuff
18:05:48 <cmccann> Philippa, oh yeah, some sort of "lashing pandoc up with other stuff in a scripty way" was also on my list, haha
18:05:56 <hpc> Philippa: it is at times difficult due to the lack of "interface" bindings the way perl has
18:06:20 <Philippa> hpc: yeah, sometimes you find nobody's made the localised wheel you need
18:06:39 <Philippa> if you've got a situation where it doesn't exist anyway then Haskell's pretty good for it though
18:06:49 <cmccann> unfortunately the stuff I wanted to do didn't quite mesh with pandoc
18:06:50 <hpc> indeed
18:08:05 <hpc> i wish i was sufficiently un-lazy to upload some of my stuff to hackage
18:08:15 <kmc> putting it on github is a start
18:08:26 <hpc> indeed, but i suck at git
18:08:26 <cmccann> for what it's worth, here's the (not very good) example code that made me start thinking about this: https://gist.github.com/1494865/a04ad443c1ef3bc4714196327901c1da2d27f94c
18:08:37 <Eduard_Munteanu> Git is a start ;)
18:08:41 <hpc> ive tried, and it just doesn't play nice with my brain
18:09:03 <kmc> hpc, did you try learning the data model, or did you try learning the 100 randomly-named commands?
18:09:18 <cmccann> with the disclaimer that I was actively avoiding many abstractions and all non-standard libraries
18:09:29 <kmc> git is a simple and beautiful data model, with a terrible UI
18:09:49 <hpc> kmc: tried learning to use it like svn
18:10:00 <kmc> yeah, fuck that
18:10:04 <Eduard_Munteanu> :)
18:10:29 <kmc> http://progit.org/book/ch9-0.html
18:10:30 <kmc> http://eagain.net/articles/git-for-computer-scientists/
18:10:58 * Eduard_Munteanu thinks it's time he started some self-contained projects himself, so far he's been contributing here and there
18:11:18 <kmc> once you understand the data model, you can at least guess at what each terrible bit of UI does, and (more importantly) you can un-fuck your repo from nearly any mistake
18:14:43 <hpc> kmc: that second link makes way more sense than graph diagrams usually do to me
18:14:50 <kmc> :)
18:17:44 <Philippa> I need to put a name to a structure, or at least enough of it to explain it...
18:17:51 <dylukes> Hm?
18:17:54 <dylukes> Describe it?
18:18:29 <kmc> type Blob = ByteString;  type Tree = [(Name, FSMetadata, Ref (Either Blob Tree))]
18:18:35 <kmc> data Commit = Commit { parent :: Ref Commit,  rootTree :: Ref Tree,  author, message :: String }
18:18:42 <Philippa> okay, taking the sum/product of two monoids is pretty boring
18:18:43 <kmc> type Ref a = SHA1Sum
18:19:14 <Philippa> suppose I've got a monoid that's built like that except the two are recursively intertwined?
18:19:41 <kmc> ok, that should be parents :: [Ref Commit]
18:20:06 <hpaste> wb3k pasted “Simple compiling issues?” at http://hpaste.org/55670
18:20:22 <ddarius> kmc: I was about to say...
18:20:29 <Philippa> that might be too weak to be worth identifying, thinking about it
18:20:41 <kmc> and i mean, it's missing other stuff, but that's the idea
18:20:42 <roconnor> anyone else have base16-bytestring-0.1.1.3 fail to install?
18:21:01 <wb3k> could anyone tell me why the hello world example i posted compiles, but the other script I have does not? pasted above
18:21:24 <kmc> wb3k, main = print (sum  ... )
18:21:30 <kmc> main needs to be an IO action
18:22:00 <wb3k> ok, thank you!
18:22:17 <kmc> it's easier to do these kinds of things in ghci
18:22:29 <sohum> @pl \a b c -> (f a b c) . (g a b c)
18:22:29 <lambdabot> ap (ap . (liftM2 (.) .) . f) g
18:23:14 <Philippa> hmm. Thinking a bit harder: I think I want something where the operator of the composed monoid will, in some cases, look at just one of the components, do whatever, then do something to both afterwards (that may well be id)
18:23:37 <ddarius> Philippa: instance (Monoid m1, Monoid m2) => Monoid [Either m1 m2] where mempty = []; mappend = normalize .: (++) where normalize will multiply adjacent Lefts or Rights?
18:23:47 <djahandarie> Hmm, trying to `cabal install attoparsec`, but getting this error: "cabal: can't find source for QC/ByteString in tests, dist/build/autogen"
18:23:48 <lambdabot> djahandarie: You have 1 new message. '/msg lambdabot @messages' to read it.
18:24:20 <djahandarie> Any thoughts?
18:24:47 <Philippa> ddarius: I guess I'm trying to capture "modules communicating across a boundary" for single-threaded processes or something like it
18:25:39 <Philippa> though there'd probably be an identifiable submonoid (where there're fewer values) where there's no cross-boundary communication
18:26:01 <Philippa> eh, I probably don't need this now. I'm trying to generalise what I'm doing too fast :-)
18:26:49 * cgroza picks his nose.
18:27:18 * kmc puts on his robe and wizard hat
18:27:27 <ddarius> A state machine can be viewed as a monoid action, where the monoid is the transitions, but this wouldn't distinguish "external" from "internal" transitions.
18:28:27 <Philippa> yeah. The submonoid aspect might be worth hanging onto for future musing
18:28:35 <Philippa> idea, even
18:28:53 <Philippa> (obviously "sub" is for the internal view!)
18:29:42 <Philippa> I guess I'm after that coupled with the "internal followed by a decision about external" pattern
18:29:55 <Philippa> I'm messing around with composing constraint systems, in case you're wondering
18:30:57 <ddarius> Philippa: Wouldn't you just make your transitions then be { internal action; decide about external }
18:31:20 <kmc> oh someone was asking the other day for a practical example of nested IO types
18:31:40 <ddarius> kmc: See copumpkin's watchdog function.
18:31:45 <kmc> that music encoder thingy has IO [IO ()]
18:32:05 <kmc> in fact it has IO [[IO ()]]
18:32:44 <Philippa> ddarius: yeah, though then you get a very different feel to the decision mechanism if you're just coding it up. This isn't (directly) for code at this stage
18:33:13 <Philippa> anyway, I've got plenty of time - I'm starting out with cases where you don't need the external interaction, thankfully
18:37:14 <drull95> parsec3's types kind of scare me
18:37:28 <drull95> i've never had to use flexible contexts before
18:37:35 <drull95> didn't even know it existed
18:38:27 <Philippa> that's a bit of a pain, yeah. It quickly turns out to be something that should've been there all along, though
18:38:38 <ddarius> It's a fairly pedestrian extension.
18:39:46 <Philippa> I think I'm going to start ramping down for bed. ddarius, want to respond to my PMs any (even if only with "WTF?!") before I head off?
18:41:57 <ddarius> Philippa: I don't really have much to say other than I tend to take the perspective of type systems as sorts of logic languages and consider the modularity tools that they use.
18:42:22 <ddarius> Though that's somewhat at the wrong level.
18:43:02 <ddarius> (Though it may be interesting for separate compilation.)
18:44:41 <Philippa> do they use anything that'd be non-obvious to me? I've got impractical experience with prolog and that's about it
18:46:42 <Philippa> but yeah, agreed re level
18:47:26 <ddarius> Actually, I should have said program in a logic language, in which case the level fits a bit more.
18:47:47 <ddarius> Prolog is horrible about modularity and has nothing notable to say about it.  lambdaProlog has some interesting aspects.
18:48:14 <Philippa> mmm. lambdaProlog is probably closer to the level I want to think at, too
18:49:23 * ski . o O ( "modules communicating across a boundary" ? )
18:50:49 <Philippa> ski: closer to modules in the hardware sense, I suspect. Boundary ~= interface, though
18:51:27 <ski> linking ?
18:52:34 <ddarius> Allowing HM(X+Y) is a somewhat different problem.
18:53:16 <Philippa> yeah. Also not what I'm doing, though
18:53:35 <ddarius> Philippa: Okay, just checking.
18:55:01 <Philippa> hopefully I'll get my first baby step blogged soon, anyway. I'm part way through the post
19:17:31 <JoeyA> What's a good way to have a set such that I can insert/delete items, but the items aren't comparable (e.g. event handlers) ?
19:17:55 <c_wraith> a list
19:18:31 <JoeyA> In languages like C, people often use doubly-linked lists to this effect.
19:18:56 <JoeyA> One can efficiently insert *and delete* items, but no ordering function is required for those items.
19:19:16 <JoeyA> I implemented a doubly-linked package (stm-linkedlist), but I'd prefer something more functional.
19:19:19 <c_wraith> if you can't identify them, how are you deleting them?
19:19:27 <drdo> do threads in haskell form a hierarchy? (i.e. does it matter if whoever forked me off dies, and what happens with exceptions?)
19:19:29 <ddarius> You can only efficiently delete if you have the direct link to the node.  Not just the content.
19:19:45 <ddarius> drdo: No.
19:19:54 <JoeyA> drdo: No, they don't form a hierarchy.  However, note that when main ends, the program ends (even if other threads aren't done yet).
19:20:16 <JoeyA> c_wraith: You could come up with an ad hoc "key", for example.
19:20:17 <drdo> So for exceptions, a thread never gets an exception thrown in another thread?
19:20:20 <ddarius> If the "sets" are typically small, I'd just use a list.
19:20:25 <drdo> (excluding throwTo)
19:20:39 <c_wraith> JoeyA: in that case, you can order by the ad-hoc key
19:20:44 <JoeyA> e.g. insert :: a -> (USet a, Key a)
19:20:47 <ddarius> If they were larger, I'd use a IntMap and simply associate a key to each entry.
19:20:50 <c_wraith> also known as Data.Map
19:20:59 <c_wraith> or yes, IntMap
19:21:12 <JoeyA> Right, I'm thinking of that too.
19:21:24 <JoeyA> Similar to an incrementing key in SQL.
19:21:56 <JoeyA> What I don't like about this approach is that Int can run out.
19:22:02 <JoeyA> (wrap around)
19:22:23 <ddarius> JoeyA: Then use Integer and a Map.
19:22:25 <JoeyA> Sure, if I use Int64, that is very unlikely, but still...
19:22:43 <JoeyA> but Integer is more overhead.
19:23:07 <dmwit> Hm. You get your choice of efficient or semantically clean.
19:23:20 <dmwit> Don't whine about both choices, just pick one and get on with your life. =P
19:23:24 <JoeyA> Even the incrementing key approach isn't semantically clean.
19:23:38 <JoeyA> If I take a key from one map and try to use it in another map, I can get incorrect behavior.
19:23:49 <dmwit> I don't really know what you're talking about, I just saw you rejecting both Int64 and Integer.
19:23:54 <ddarius> I would actually have the keys produced with the elements rather than the "set" providing new keys.
19:24:06 <JoeyA> I can use phantom types (e.g. Key a) to ensure it's at least typesafe, but:
19:24:46 <kmc> 2^64 nanoseconds is 292 years
19:25:02 <JoeyA> (m1, k1) = insert a empty; (m2, k2) = insert b empty; delete k2 m1 -- wrong
19:25:25 <JoeyA> ddarius: What if those elements are functions?
19:25:38 <ddarius> JoeyA: (Int, a -> b)
19:26:16 <ddarius> JoeyA: If you want a mutable structure, make one.  There is nothing "wrong" about the behavior you described.
19:27:01 <JoeyA> ddarius: It's wrong in that it's incorrect use of the API.  That's why I wouldn't call it "semantically clean"
19:27:25 <ddarius> JoeyA: It's completely legitimate to attempt to remove an element from a set that does not have the element.
19:27:47 <ddarius> You can either have that be raised as an error, or, more likely, have it do nothing (i.e. return the set unchanged.)
19:27:52 <JoeyA> ddarius: In that case, delete k2 m1 should == m1, but it doesn't
19:28:05 <ddarius> JoeyA: Why not?
19:28:32 <JoeyA> Because, as I see it, data USet a = USet Int (Map Int a)
19:28:40 <JoeyA> where Int increments per insertion
19:29:07 <JoeyA> (Int64 or Integer would be preferable)
19:29:26 <ddarius> JoeyA: I'm failing to see why delete k2 m1 would not be m1.
19:30:09 <JoeyA> ddarius: Because m1 and m2 are equivalent, except for the values of a and b.
19:30:21 <ddarius> JoeyA: m2 is not even mentioned.
19:30:31 <ddarius> Did you mean to say that delete k2 m2 /= m1 ?
19:30:37 <JoeyA> (m1, k1) = insert a empty; (m2, k2) = insert b empty; delete k2 m1 -- wrong
19:30:44 <JoeyA> ddarius: No, k2 m1
19:31:26 <JoeyA> I think the API semantics I have in mind violate referential transparency.
19:31:39 <ddarius> Oh, I see what you are doing.  Again, I would associate the keys to the elements rather than have the set generate them.
19:31:54 <dr0b3rts> Maybe you could use System.Mem.StableName or Foreigh.StablePtr?
19:32:20 <JoeyA> No Ord instance for StableName
19:32:34 <dr0b3rts> hashStableName
19:32:51 <JoeyA> ah, right
19:34:05 <xil> can I just pass a TChan to another thread that I'll be communicating with through, or do I need to duplicate it before passing it over?
19:34:07 <dr0b3rts> But, mkStableName may return a different StableName after an object is evaluated.
19:34:24 <JoeyA> This is a pretty common problem: maintain a set of event handlers with no differentiating key, that supports efficient insertion and deletion.
19:34:51 <JoeyA> xil: As long as the other thread is the only receiver, you should be fine.
19:35:03 <ddarius> xil: It depends on the semantics, you want, but I'm pretty sure you are worrying about random arbitrarily limitations based on experience with other languages.
19:35:19 <xil> okay, so then I'm having a problem. I wrote to the chan but it's not coming out the other side
19:35:38 <ddarius> JoeyA: Usually that "set" is ordered, i.e. a lists.  For example, the event handlers are called in the order they are registered.
19:36:09 <ddarius> Also, usually systems that do this have a notion of object identity.
19:36:16 <JoeyA> ddarius: Event handlers may be registered by different threads, so register/unregister is not FIFO.
19:36:29 <ddarius> In C#, for example, to remove a handler, you have to use the exact same reference.
19:36:56 <JoeyA> And with a doubly linked list, you just use the node.
19:37:47 <JoeyA> I just wonder if there's a purer-functional solution to the problem.
19:37:58 <JoeyA> (than using, say, stm-linkedlist)
19:40:08 <ddarius> JoeyA: All the "typical" solutions you've mentioned rely on a notion of object identity, what I said above can be viewed as simply making an explicit notion of object identity.
19:40:16 <JoeyA> I think it would be better to consider the ad-hoc key generation as a separate problem.
19:40:19 <JoeyA> Right
19:40:36 <JoeyA> ad-hoc keys are impure by nature.
19:40:45 <ddarius> Mildly.
19:41:02 <JoeyA> Two runs of the same code installing different (but similar) event handlers should not have conflicting keys.
19:41:38 <JoeyA> So I'm thinking: generateKey :: IO (Key a)
19:41:45 <xil> anyone have any ideas for why this TChan is empty after I've written to it? I create it and write to it right away, then forkIO a thread that is passed the TChan as a parameter. But that thread just sees an empty channel
19:42:20 <JoeyA> xil: Could you post a sample illustrating the problem?
19:42:24 <ddarius> xil: Code doesn't lie.  Post code.
19:42:34 <ddarius> Let me correct.  Post -the- code.
19:42:49 <xil> I don't really know what code to post, but I guess I'll give it a shot. One moment
19:43:08 <ddarius> You have some program that does something you don't expect, otherwise are you just imagining problems to have?
19:43:38 <JoeyA> main = do {chan <- newTChanIO; (atomically $ writeTChan chan "hello"); forkIO $ (atomically $ readTChan chan) >>= putStrLn}
19:43:42 <JoeyA> That ought to work.
19:43:53 <JoeyA> Otherwise, back to C++ for me.
19:44:16 <kmc> is there a good STM implementation for C++?
19:44:20 <JoeyA> (barring obvious mistakes)
19:44:35 <JoeyA> kmc: Using one thread and a select loop ;-)
19:45:54 <cl1> as a parameter pattern, if I want to name a list and get the head and the tail how would I write that? foo list(x:xs) ?
19:46:09 <ddarius> kmc: Keir Fraser's thesis used C++ I think (or maybe just C.)
19:46:22 <kmc> > let wholelist@(listhead:listtail) = "like this cl1?" in (wholelist, listhead, listtail)
19:46:23 <lambdabot>   ("like this cl1?",'l',"ike this cl1?")
19:46:28 <ddarius> Admittedly, the STM described in it wasn't as featureful as GHC's STM.
19:46:35 <JoeyA> list@(x:xs)
19:46:53 <cl1> thanks
19:46:55 <JoeyA> > let f list@(x:xs) = (show list, show x, show xs) in f "hello"
19:46:56 <lambdabot>   ("\"hello\"","'h'","\"ello\"")
19:47:05 <ddarius> I think I've heard of some other STM implementations for C++ elsewhere, but I could be wrong about that.
19:47:38 <xil> oh silly me. I've made this mistake before. I want to execute something from the Maybe monad in the IO monad and cheat by just putting the Maybe stuff in a return. But laziness keeps it from being executed
19:47:58 <dr0b3rts> JoeyA: Add a threadDelay 1000 to the end; otherwise main exits too early.
19:48:40 <JoeyA> dr0b3rts: Ah, right
19:48:41 <djahandarie> xil, you have two too many monads in that statement.
19:48:59 <ddarius> xil: I would recommend that you don't think of Maybe monadically.  "Executing" a monadic action in the Maybe monad is a no-op.
19:49:17 <xil> well I really just wanted the convenience of bind for Maybe
19:49:31 <xil> but I'll just make a case-of
19:49:52 <ddarius> xil: You can use (>>=), my point is that the result is just a value.
19:50:06 <ddarius> Whether you are doing this in an IO computation or not is rather irrelevant.
19:50:26 <xil> but with Maybe it won't do what's on the right if the input is Nothing, and that's what I wanted
19:50:35 <xil> but I didn't care about the result of the computation because it's an IO computation
19:50:48 <xil> but this is the WRONG way to do it
19:50:54 <ddarius> xil: Probably.
19:51:03 <ddarius> I'd recommend the maybe function, but doing a case is fine too.
19:51:59 <ddarius> VLC has an easter egg.
19:52:11 <xil> ddarius: oho. The maybe function is what I need. Also, what's the easter egg?
19:52:58 <djahandarie> Is the easter egg that it crashs randomly for no good reason?
19:53:04 <xil> lol
19:56:14 <ddarius> djahandarie: No, it's always done that.
20:06:30 <xil> okay so that was awful. My program used up all 4GB of my RAM
20:06:45 <djahandarie> Watch out for that.
20:07:16 <xil> a few MBs, sure I get that. But htop claims my RAM was full
20:07:38 <djahandarie> It probably was.
20:09:26 <kmc> with GHC Haskell it's easy to make programs which consume all your RAM
20:09:30 <kmc> by accident
20:09:33 <xil> haha
20:09:44 <djahandarie> You can add that to your slides kmc.
20:09:58 <xil> can someone help me figure out why mine is doing this?
20:10:24 <djahandarie> If you post the code on http://hpaste.org
20:11:13 <hpaste> xil pasted “Mandelbrot.hs” at http://hpaste.org/55671
20:11:39 <hpaste> xil pasted “MandelbrotModel.hs” at http://hpaste.org/55672
20:11:58 <xil> the only thing in MandelbrotAux is the ternary function (?:)
20:12:05 <djahandarie> What were you changing when this started?
20:12:21 <xil> it's been this way from the beginning
20:12:39 <djahandarie> Are you compiling with -O2?
20:12:42 <xil> no
20:12:50 <djahandarie> Do that.
20:12:57 <xil> ghc --make -O2?
20:13:00 <djahandarie> Yeah.
20:13:10 <xil> what is that flag?
20:13:16 <djahandarie> It turns on the optimizations.
20:13:46 <xil> it's not sucking up the RAM
20:14:31 <kmc> you also need -fforce-recomp
20:14:40 <kmc> otherwise it will use the files it already compiled without optimization
20:15:37 <JoeyA> (unwarranted code review: what's with that ?: function?  What's wrong with good old fashioned if-then-else?)
20:15:43 <djahandarie> You probably have a 'memory leak' somewhere anyways. Read http://book.realworldhaskell.org/read/profiling-and-optimization.html which shows you how to get graphs of where your memory is going.
20:15:54 <djahandarie> (Under the 'space profiling' section.)
20:17:02 <xil> well I narrowed it down
20:17:21 <xil> the memory problem is at line 48 in Mandelbrot.hs
20:17:37 <djahandarie> The commented out one?
20:17:39 <xil> if I comment it out no problem. Keep it in, problem
20:17:41 <xil> right
20:18:55 <xil> I'm just imagining the facepalms some of you must be experiencing looking at this code, haha
20:21:29 <djahandarie> I don't see why that should be causing any issues assuming line 43 isn't.
20:22:30 <xil> line 43 takes FOREVER to finish, but if I comment it out and uncomment 48 then I get those memory problems
20:22:56 <rwbarton> oh
20:23:27 <rwbarton> because when "points" is going to be used again on line 48, it all needs to be retained
20:24:09 <rwbarton> when you don't have line 48, it can get garbage collected as it is produced
20:24:09 <xil> I don't actually need either of those lines. The real point of them is to figure out what part of 45 and 46 are responsible for the problem
20:24:25 <JoeyA> xil: Maybe pnts is never being forced throughout the computation.
20:24:30 <xil> 48 makes me think that that stuff with concatMap is causing the problem
20:24:43 <xil> JoeyA: entirely possible. I don't understand laziness fully
20:24:59 <rwbarton> well, it sounds like you're just trying to allocate an enormous array on that line
20:25:03 <xil> the point is to have tho computation happen in the other thread
20:25:04 <JoeyA> > foldl (+) 0 [1..1000000]
20:25:06 <lambdabot>   *Exception: stack overflow
20:25:09 <JoeyA> > foldl' (+) 0 [1..1000000]
20:25:10 <lambdabot>   500000500000
20:25:48 <JoeyA> xil: The first one fails because the additions aren't performed.  foldl doesn't need to know what the accumulator is until it's done accumulating.
20:26:18 <JoeyA> So the accumulator goes like this: (1+2) ((1+2)+3) (((1+2)+3)+4) ...
20:26:52 <JoeyA> At the end, ((((((((((((((((((...1+2)+3)+4)...+1000000), a stack overflow occurs because the expression is too deep.
20:27:12 <JoeyA> foldl', on the other hand, forces the expression for each item.
20:27:14 <rwbarton> I think the problem here is simpler
20:27:14 <xil> yeah I understand the difference
20:27:23 <xil> but I don't know how to force the computation to happen in the other thread
20:27:27 <rwbarton> where is eventLoop, anyways
20:27:32 <rwbarton> is that part of the API you're using?
20:27:33 <xil> the other paste
20:27:36 <rwbarton> oh
20:27:37 <xil> http://hpaste.org/55672
20:27:40 <rwbarton> thanks
20:27:47 <xil> anything to make the help easier =]
20:27:48 <xil> haha
20:27:49 <JoeyA> xil: Your code doesn't look like it's forcing pnts.
20:28:06 <JoeyA> You could say: newpnts <- evaluate $ iterateScreen pnts
20:28:07 <hpaste> cl1 pasted “palindrome” at http://hpaste.org/55673
20:28:20 <xil> laziness is one of the things I know least about regarding Haskell
20:28:52 <cl1> please critique .. note, even though I know about the list functions we have not learned them in the tutorial yet, therefore I did not use them
20:29:48 <cl1> they all work, I would like code review of my paste
20:29:55 <xil> JoeyA: why does evaluate force the computation?
20:30:13 <JoeyA> xil: That's what it does by definition :-)
20:30:32 <rwbarton> so it looks like your list has size roughly 800*800*(4+4+8+8+4+8+8+12+12+12+12+8)
20:30:34 <JoeyA> evaluate a = IO $ \s -> seq# a s -- NB. see #2273, #5129
20:30:35 <xil> oh newpnts isn't defined in the IO monad. I've made this mistake before too
20:30:37 <JoeyA> ^ scary...
20:30:39 <rwbarton> > 800*800*(4+4+8+8+4+8+8+12+12+12+12+8)
20:30:40 <lambdabot>   64000000
20:30:47 <rwbarton> that's not so unreasonably large
20:31:08 <rwbarton> maybe double that on a 64-bit system
20:31:24 <xil> it's hardly optimized
20:31:26 <dmwit> > 64000000 / 1024 / 1024 / 1024
20:31:27 <lambdabot>   5.9604644775390625e-2
20:31:28 <JoeyA> xil: In pure code, you can use seq.  However, it doesn't force the expression if the function in which seq lives isn't forced.
20:31:47 <dmwit> If those are bytes, that looks like about 60 megabytes -- not so bad.
20:31:53 <JoeyA> so force :: a -> a; force a = a `seq` a  isn't very useful.
20:32:05 <dmwit> JoeyA: No, it isn't useful at all.
20:32:12 <dmwit> It's anti-useful, because it's not called "id".
20:32:12 <rwbarton> those are supposed to be bytes, yeah
20:32:24 <cl1> > foldr (+) 0 [1..1000000]
20:32:25 <lambdabot>   *Exception: stack overflow
20:32:54 <JoeyA> @src foldl'
20:32:54 <lambdabot> foldl' f a []     = a
20:32:54 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
20:33:04 <cl1> > foldl (+) 0 [1..1000000]
20:33:05 <lambdabot>   *Exception: stack overflow
20:33:23 <cl1> @src foldr
20:33:23 <lambdabot> foldr f z []     = z
20:33:24 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:33:30 <Veinor> > foldl' (+) 0 [1..1000000]
20:33:31 <lambdabot>   500000500000
20:33:49 <JoeyA> Here, seq ensures that the accumulator a' is forced before the next call to foldl'
20:34:20 <cl1> interesting
20:34:35 <kmc> haha, I love a single line of code with two bugtracker references
20:34:52 <xil> I put the evaluate in there and it's still suffering the same problem
20:35:04 <cl1> kmc?
20:35:16 <kmc> cl1?
20:35:29 <cl1> what single line of code in what?
20:35:31 <kmc> the implementation of 'evaluate' given by JoeyA
20:35:36 <kmc> GHC's implementation
20:35:57 <cl1> oh
20:37:26 <kmc> Haskell is like sausages
20:37:31 <kmc> if you like the result, you don't want to see how it's made
20:38:04 <kmc> GHC's implementation of IO is particularly nasty
20:38:32 <cl1> there are better ones?
20:38:48 <kmc> i'm not aware of one
20:38:53 <kmc> it is probably possible to do better, yes
20:39:13 * xil is crying
20:39:38 <xil> why does this have to be so complicated
20:39:52 <cl1> xil: relationships are like that sometimes
20:40:29 <kmc> i mean, there are conceptually nicer implementations of IO for Haskell, but I don't know how to combine those with the performance of GHC's implementation
20:41:14 <monochrom> what is being so complicated?
20:41:22 <kmc> the thing about GHC's implementation is that it's all impure functions underneath, so IO actions are subject to the same optimizations as functions
20:41:32 <xil> monochrom: Mandelbrot set viewer
20:41:38 <kmc> you don't pay the "interpretive overhead" of IO being this abstract data type
20:42:11 <xil> I wrote it all. It should display and compute and everything. But it won't. It just eats my memory and does nothing
20:42:24 <kmc> the weird thing is that GHC exposes this implementation in library code at the "Haskell" source level
20:42:45 <kmc> rather than making it a primitive, implemented in a strict, impure intermediate language (something like Core)
20:42:49 <rwbarton> xil: what you want to do is fully evaluate newpnts before you write it to dout
20:43:08 <xil> rwbarton: I put 'evaluate' in there
20:43:23 <xil> newpnts <- evaluate $ iterateScreen pnts
20:43:25 <monochrom> did you finish writing the whole thing before you started troubleshooting, like the way you write a sociology essay? that would complicate everything, yes.
20:43:36 <rwbarton> something like "evaluate (deepseq newpnts ())"
20:44:14 <xil> monochrom: basically, yes. I just don't know how to do things properly
20:44:54 <xil> monochrom: like how to make sure the testing is done properly. There is too much I don't know
20:45:34 <rwbarton> xil, just an evaluate won't do you much good
20:45:59 <rwbarton> because it will only evaluate the outermost constructor of newpnts, which is just a (:)
20:46:04 <penelope> a ! on your data can do some good?
20:46:24 <rwbarton> it could, his data is a huge list of pairs of tuples though
20:46:25 <monochrom> well, I hope now you know what to do when you don't know
20:47:38 <monochrom> i.e., the more you don't know, the more you be conservative and incremental, not more coding.
20:47:59 <kmc> unfortunately space leaks are a highly non-local property
20:47:59 <xil> monochrom: it's a learning process
20:48:22 <xil> rwbarton: what do you recommend then? Just that deepseq thing?
20:48:36 <penelope> A recursive structure is necessary?
20:49:02 <cl1> could someone code review this: http://hpaste.org/55673
20:54:41 <monochrom> is that a list of tuples of numbers? like [(Double, Double)]?
20:54:59 <xil> monochrom: is that aimed at me?
20:55:06 <cl1> its supposed to take a list like [1,2,3] and output [1,2,3,3,2,1]
20:55:24 <monochrom> I would say at your program rather than at you
20:55:36 <cl1> it works, i was just wondering if it was crappy looking code, or unconventional
20:55:48 <xil> monochrom: [((Int,Int),(Int,Double,Double,Double,Double,Bool))]
20:56:19 <cl1> oh, ur talkin to xil
20:56:20 <penelope> cli: it could be prettier
20:56:24 <monochrom> the list should or should not be lazy. in fact it should or should not be a list to begin with. this part I don't know.
20:56:28 <kmc> cl1, it's strange to write «x:front(xs)», better to write «x : front xs»
20:56:36 <kmc> f x  not  f(x)
20:57:05 <monochrom> but most likely, the tuples and tuples inside should be replaced by an eager type, so that one seq evaluations them all
20:57:12 <kmc> also we'd usually write the pattern x:[] as [x]
20:57:50 <kmc> i'll let others review the higher level stuff
20:57:57 <cl1> kmc: ah good one [x] instead of x:[]
20:58:13 <cl1> kmc: well thanks for that much :)
20:58:17 <monochrom> "data Eager = E !Int !Double !Int" -- eager data type. either unevaluated altogether, or all 3 fields evaluated immediately, no grey area
20:58:38 <monochrom> the "!" marks eager fields. without "!" is lazy as default
20:58:56 <penelope> monochrom: I've had to do data Foo = Foo !Int !Int !Int !Int
20:59:13 <monochrom> yeah, in fact Data.Map's definition is full of !s
20:59:15 <penelope> rather than ((a,b),(c,d))
21:00:09 <dr0b3rts> Write "last yList : palin [] (front yList)"... function application is always performed before operators (like :)
21:00:21 <kmc> it's unfortunate that there's no standard strict tuple types
21:00:29 <kmc> also a spine-strict list
21:00:32 <monochrom> "data Map k a  = Tip | Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a)" -- "my god, it's full of bangs"
21:00:40 <xil> monochrom: so if I make the data type strict then it'll evaluate immediately and on the second thread where it's supposed to happen?
21:00:42 <kmc> or a spine-and-elements-strict list
21:01:07 <monochrom> that depends
21:02:23 <penelope> so:
21:02:40 <xil> if I describe the scenario, would anyone not mind recommending a setup to accomplish it?
21:02:45 <penelope> why is xs ++ reverse xs wrong?
21:04:03 <xil> I have 2 threads. The main thread for the GUI and the second for the computation. I am doing a fractal program so it's computing points on the screen and uses complex numbers for the points. The info about those points needs to be accessible to the main thread so it can convert that to pixel/color data
21:04:39 <cl1> if (:) is infixr 5 then how does it know that i'm not trying to pass it as a value to last in the following statement?  last x : foo y
21:05:01 <kmc> function application always binds tighter than infix operators
21:05:08 <kmc> if you wanted to pass it as a value you'd have to say:   last x (:) foo y
21:05:14 <penelope> also
21:05:17 <cl1> i see
21:05:18 <kmc> putting it in parentheses makes it a normal name
21:05:18 <penelope> why 2 threads?
21:05:48 <xil> penelope: I don't want to computation to block GUI stuff, which tends to happen when they are in the same thread
21:05:55 <penelope> yes,
21:05:56 <penelope> but
21:06:16 <penelope> fractal computation is easily parallized.
21:06:44 <kmc> that seems like something to do after getting this version working
21:06:55 <JoeyA> Where are primops defined in the GHC source?
21:06:57 <kmc> also parallelizing computation in GHC Haskell doesn't require threads
21:07:05 <JoeyA> (in particular, I'm looking for newPinnedByteArray# )
21:07:07 <kmc> you use Control.Parallel.par and friends
21:07:38 <kmc> JoeyA, http://hackage.haskell.org/trac/ghc/wiki/AddingNewPrimitiveOperations
21:07:39 <penelope> But is concurrent programming any different?
21:07:47 <xil> I've written half a dozen fractal programs -- in other languages albeit. I wanted to try something new here, but frankly I'll go for what will work
21:07:54 <kmc> concurrent programming is very very different from parallel pure functional programming
21:08:05 <monochrom> function application is like infixl 10
21:08:30 <kmc> JoeyA, out-of-line primops are Cmm functions defined in http://hackage.haskell.org/trac/ghc/browser/rts/PrimOps.cmm
21:08:33 <penelope> I kind of think of both as adverbs.
21:08:51 <JoeyA> kmc: Thanks.
21:08:58 <kmc> haha, stg_newPinnedByteArrayzh is right at the top :)
21:09:38 <monochrom> stg_huzzahzh
21:09:40 <JoeyA> lol
21:09:48 <kmc> for an inline primop you modify the compiler directly, to tell it how that primop translates to Cmm
21:10:21 <cl1> Cmm?
21:10:30 <kmc> Cmm is one of the intermediate languages used by GHC
21:10:33 <kmc> it's a dialect of C--
21:10:36 <cl1> ah
21:10:44 <xil> I'll try for a non concurrent/parallel version for now. Once I get that working I'll come back and maybe figure out parallelism and/or concurrency
21:10:52 <kmc> C-- is a compiler-independent backend language somewhat like LLVM, but it never caught on outside GHC
21:10:58 <xil> but it's bed time. Thank you everyone for the help =]. Good night
21:14:37 <cl1> so its not human readable, its an ast type language?
21:14:50 <kmc> that doesn't make sense.  every language has an AST
21:15:19 <kmc> if you're asking "is there a concrete syntax for Cmm" the answer is yes
21:15:21 <cl1> but not all languages are human readable, i should have said: its just an ast?
21:15:36 <kmc> http://hackage.haskell.org/trac/ghc/browser/rts/PrimOps.cmm this file is written in Cmm.  you be the judge of whether it's human-readable :)
21:15:36 <cl1> so you can write cmm in a text editor then?
21:16:04 <cl1> lol
21:16:06 <kmc> there's a paper somewhere which describes the language
21:16:12 <kmc> it's a lot like C, syntactically
21:16:21 <cl1> okay, so haskell gets translated into that, and then compiled into binary?
21:16:30 <kmc> it has fewer types; just machine types, basically
21:16:39 <kmc> and it supports some things like explicit tail calls, which C doesn't
21:16:51 <penelope> cmm is C ish, llvm is asmish
21:16:55 <cl1> that's important
21:16:58 <kmc> cl1, yes, there are many other stages too
21:17:41 <cl1> i'm guessing writing a compiler for haskell is much more complicated than a c compiler
21:17:46 <kmc> yeah
21:17:50 <penelope> well
21:17:51 <kmc> especially if you want good performance
21:18:06 <penelope> C is one thing. C++ is another.
21:19:06 <cl1> penelope, i would imagine so
21:19:42 <kmc> cl1, GHC compiles Haskell -> Core -> STG -> Cmm -> LLVM -> machine code
21:19:48 <penelope> Also, don't forget: the architecture of our current chips is based around running C.
21:19:49 * hackagebot wai-middleware-route 0.1.0.1 - Wai dispatch middleware  http://hackage.haskell.org/package/wai-middleware-route-0.1.0.1 (AlexanderDorofeev)
21:20:07 <kmc> (for some platforms, it can generate machine code directly from Cmm.  it can also compile via C instead of LLVM, though performance is bad.)
21:20:38 <kmc> Core is a Haskell-like language where syntactic sugar has been removed; type classes are replaced with explicit arguments; polymorphism is explicit
21:20:47 <kmc> many optimizations happen in this form
21:21:28 <kmc> STG is "a stylised form of [Core], the style being one that happens to be ideally suited to... code generation"
21:21:38 <penelope> (Core is where you find out whether your inner loops are actually fused correctly)
21:22:02 <kmc> Cmm is a low-level language similar to C.  LLVM is a low-level language similar to portable assembly
21:22:05 <kmc> machine code is machine code :)
21:22:08 * cl1 listens
21:22:09 <penelope> (code generation on van nuemanman machines)
21:22:46 <cl1> so if i could figure out how to translate LLVM to idl haskell could run on the .net clr
21:23:20 <kmc> yeah and there will be a billion small problems you'll need to solve one by one before it works
21:23:29 <kmc> there have been Haskell for .NET projects before
21:23:33 <kmc> nobody wants to maintain them
21:23:38 <penelope> ah
21:24:06 <cl1> from what i've read, it seems like they are always college projects that never get finished
21:24:14 <kmc> there's a lot of that
21:24:56 <cl1> i would be happy if i could just get syntax highlighting and ghci to load up in it. I could worry about the rest later
21:24:56 <kmc> making something like that work really well, and maintaining it, is a huge amount of work
21:25:03 <kmc> boring, unsexy, un-researchy work
21:25:10 <penelope> I haven't followed up, but I thought haskell was well supported on MS, since they hired all the prominent haskell programmers.
21:25:28 <cl1> i do boring unsexy work all the time
21:25:31 <kmc> and so it doesn't get done unless some company wants it
21:25:34 <byorgey> heck, even most sexy researchy work doesn't end up getting maintained.
21:25:44 <kmc> byorgey, because maintaining it is not sexy
21:25:52 <byorgey> ah, good point.
21:26:04 <penelope> Probably why we're still using emacs.
21:26:10 <kmc> and there's a chicken and egg problem: if Haskell doesn't work on JVM / .NET, then your JVM/.NET company won't even consider it, so won't push for big risky projects to make it work
21:26:25 <kmc> penelope, you're wrong.  MS didn't hire "all the prominent haskell programmers"
21:26:36 <kmc> they hired some of the main GHC developers
21:26:46 <kmc> into Microsoft Research, which is pretty disconnected from the rest of MS
21:26:54 <kmc> afaik they've received no push to make GHC work with .NET stack
21:27:04 <kmc> in fact Microsoft might feel threatened if they did
21:27:14 <kmc> because it might cut into Microsoft's investment in F# as the practical .NET functional language
21:27:30 <kmc> remember, GHC is an open-source project
21:27:45 <penelope> No disrispect indended. But I thought they were there reason behind "Power Shell" and F#
21:27:49 <kmc> BSD license
21:28:18 <drbean> It's MS' skunkworks?
21:28:23 <byorgey> the GHC developers and the F# developers are separate people.
21:28:40 <byorgey> MS research likes to have GHC around because it generates good ideas they can incorporate into F#, C#, etc.
21:28:52 <penelope> F# is a bit more like a sad Camel.
21:28:58 <kmc> i think 'skunkworks' still means a department focused on potential products
21:28:59 <byorgey> hehe
21:29:03 <drbean> On an intellectual level?
21:29:12 <kmc> i think there's little push to turn anything MSR does into products
21:30:03 <cl1> lots of stuff has come out of MSR .. it just usually doesn't look anything like the original that came out
21:30:07 <cl1> and a few have
21:30:19 <cl1> Rx reactive extensions, makes events first class objects
21:30:46 <cl1> and that pre/post-condition invariant library came from there
21:31:24 <cl1> as far as open source goes, asp.net mvc is open source. and they are making versions of their compilers in the corresponding language so people can learn from what they have done
21:31:41 <cl1> that compiler thing is supposed to be with .net 4.5
21:31:53 <cl1> so MS is getting better about open source
21:32:31 * cl1 is not an MS fanboy
21:32:38 <kmc> F# might be uglier than Haskell, but I can't blame them for picking a strict language for their big industrial push
21:32:46 <cl1> i'm just glad to see they are starting to accept open source for what it is
21:33:07 <kmc> laziness is still causing huge performance problems for Haskell programmers
21:33:13 <kmc> we still don't have good tools to deal with that
21:33:17 <ion> And also their code
21:33:21 <cl1> especially one that already has an OO model built in so it can work with the existing .net stuff
21:33:50 <penelope> But I don't think we would have gotten monads without lazyness.
21:33:54 <cl1> kmc .. that is probably why haskell is not more popular, the lack of good tools (debugger, performance analyzers, etc.)
21:34:06 <kmc> that is one of many reasons
21:34:18 <penelope> hah
21:34:35 <kmc> penelope, maybe that's true historically
21:34:38 <penelope> you should see a java programmer struggle with python.
21:34:44 <kmc> but you can use monads in a strict language with impure evaluation too
21:34:57 <kmc> penelope, what does that mean?
21:35:49 <cl1> if you have bind and return you have a monad, correct?
21:36:07 <kmc> if you have bind and return of certain types obeying certain laws
21:36:40 <kmc> many languages allow you to define specific monads this way
21:36:48 <kmc> but few languages allow you to write code which is generic over all monads
21:36:49 <kmc> in a nice way
21:36:51 <penelope> Many professional programmers (which means Java programmers, these days) just aren't used to programming in an environment without all the help.
21:36:54 <penelope> Or
21:36:58 <kmc> Haskell supports the right kind of polymorphism for that
21:37:06 <penelope> With any level of abstraction.
21:37:14 <cl1> *cough*c# is used more than java*cough*
21:37:45 <penelope> cl1: ? really? Today?
21:37:56 <fantasticsid> //clojure
21:38:04 <cl1> yeah its like 80% c# 20% java
21:38:10 <cl1> out of c# and java developers
21:38:18 <kmc> hmm #haskell is not the best place to argue about Java vs C# vs Python vs whatever
21:38:21 <penelope> Ok,http://hpaste.org/55673
21:38:45 <penelope> Yeah
21:39:17 <penelope> Also, the hpaste was my cat.
21:39:59 <cl1> i got my information about c#/java from the recruiter/headhunter people
21:40:15 <cl1> you hpasted your cat? it looks an aweful lot like code :P
21:40:33 <penelope> fuzzy logic.
21:40:46 <cl1> lol
21:41:00 <byorgey> cl1: no, I think penelope meant that the cat wrote that code.
21:41:52 <kmc> penelope, laziness was the original reason for separating evaluation and execution in Haskell
21:42:01 <kmc> but it's clear now that was a good idea, even if laziness was not
21:42:18 <monochrom> no one, absolutely no one on earth, has comprehensive tallies of programming language use of the whole world. an individual can only claim to have tallied his little pocket of reality.
21:42:22 <kmc> i would love to program in a language which is like Haskell in most ways but has strict evaluation
21:42:48 <drdo> kmc: oh yes
21:43:07 <drdo> I don't think lazy eval is a net win in practice to be honest
21:43:17 <kmc> yeah
21:43:26 <kmc> there are real benefits to laziness, but they're somewhat fuzzy design-level things
21:43:28 <drdo> It's cool in theory
21:43:38 <kmc> compared to "oh god why is my factorial function consuming 200 GB / second of RAM"
21:44:20 <penelope> I think my argument is that we wouldn't have needed to discover monads etc without the constrictions of laziness.
21:44:21 <monochrom> that is only when you focus so much on number-crunching
21:44:45 <kmc> penelope, maybe so.  but that shouldn't restrict what language we use today
21:45:00 <monochrom> go to ocaml and discover "oh god why is my print(map f xs) consuming 200GB/second of RAM"
21:45:09 <kmc> it's a pretty tenuous path, from laziness to separating evaluation and execution (which has many other benefits), to monads (which are used for many other things)
21:45:34 <drdo> Is there something to convert a bytestring to something like an unboxed vector of Bool? (bitvector)
21:45:41 <parcs`> there is a compiler plugin that makes everytihng strict
21:45:48 <kmc> for GHC?
21:45:52 <parcs`> yeah
21:46:02 <cl1> strict means?
21:46:23 <parcs`> https://github.com/thoughtpolice/strict-ghc-plugin
21:46:24 <kmc> a function f is strict if  f ⊥ = ⊥
21:46:38 <kmc> ⊥ represents any computation which does not terminate, i.e. an exception or an infinite loop
21:46:48 <kmc> parcs`, cool! thanks
21:47:04 <NihilistDandy> I suppose you could contribute to Disciple :D
21:47:44 <cl1> so strict is like eager evalutation?
21:48:00 <ion> s/like //
21:48:11 <kmc> no, they are not the same thing
21:48:19 <kmc> "strict" describes the denotational semantics
21:48:20 <monochrom> there is no "does not terminate", "abort", "infinite loop" in denotational semantics. you have already chosen denotational semantics when you say "⊥"
21:48:29 <kmc> "eager" describes an implementation strategy for strict semantics
21:48:31 <cl1> of course not, its never that simple with haskell
21:49:09 <monochrom> however, by the time you have said "infinite loop", you have already chosen operational semantics, at which point it is eager, not strict.
21:49:23 <kmc> similarly "lazy" is an implementation strategy for "non-strict semantics"
21:49:30 <kmc> it's the strategy used by essentially all haskell implementations
21:49:31 <drdo> cl1: it basically just means arguments to functions get reduced before the function body
21:49:40 <kmc> but technically Haskell is not a "lazy language" just a "non-strict language"
21:49:57 <monochrom> the diesease with you all is "strict vs lazy". make up your mind already.
21:50:10 <cl1> LOL
21:50:25 <kmc> there are interesting alternatives to lazy evaluation for implementing Haskell semantics
21:50:32 <kmc> for example, speculative parallel evaluation
21:50:38 <parcs`> strazy
21:50:47 <monochrom> I call that crazy evaluation
21:50:47 <penelope> I think it depends on our marketing segment.
21:51:55 <drdo> kmc: That's another thing that's cool in theory but not so cool in practice :P
21:52:12 <kmc> yeah, nobody has made it work well yet
21:52:42 <kmc> hell even GHC's "semi-implicit parallelism" is tricky enough
21:52:45 <drdo> doesn't make sense for current hardware
21:53:05 <drdo> 4/6/8 is pretty much 1
21:53:18 * monochrom decides to whine about this in haskell-cafe. long overdue whine
21:53:41 <kmc> i'm sympathetic to the argument that it's not worth optimizing your language for shared-memory concurrency / parallelism
21:53:56 <kmc> because all big gains will be had on distributed hardware
21:54:29 <drdo> kmc: I'm eagerly waiting for the hardware guys to make some cool architecture without shared memory
21:54:29 <kmc> and even when you have shared memory, it's not uniformly shared, and it's better to treat it as a distributed system
21:55:15 <cl1> that goes with the example i give. If you write a program that is twice as fast as mine, but I can run it on 4 machines, then mine is twice as fast as yours
21:55:16 <drdo> the current model just doesn't scale
21:55:17 <penelope> kmc: there are different classes of problems
21:55:27 <cl1> and gets faster the more machines i throw at it
21:55:42 * cl1 works with distributed stuff
21:55:51 <drdo> cl1: linear scaling doesn't happen just like that in real life
21:56:06 <drdo> only on very specific problems
21:56:11 <cl1> it doesn't have to be linear to be distributable
21:56:29 <cl1> even sequential processes can be distributed to reduce the workload
21:56:37 <drdo> yes but at some point you're spending money to make it run slower
21:57:14 <ddarius> drdo: There are many, many non-shared memory machines.
21:57:20 <penelope> Not if you need n x m communication
21:57:22 <drdo> ddarius: Where are they?
21:57:22 <penelope> e.g.
21:57:37 <penelope> Multi body solution.
21:57:44 <ddarius> drdo: Supercomputers / mainframes mostly.
21:58:00 <drdo> ddarius: link
21:58:40 <drdo> clusters don't count
21:58:45 <kmc> obviously there are no non-shared memory machines, because I will declare that something without shared memory is not a "machine" but a "cluster"
21:58:56 <kmc> (this is the best way to win an argument)
21:59:13 <drdo> put a cluster on a chip
21:59:17 <drdo> that's what i'm talking about
21:59:28 <ion> Mainframes are things in Hollywood movies into which one subnets the hacking access matrix.
21:59:30 <kmc> http://techresearch.intel.com/ProjectDetails.aspx?Id=1
22:00:15 <drdo> that's more like it
22:00:34 <NihilistDandy> ion's got the chops
22:00:37 <drdo> isn't that still shared memory though?
22:02:10 <cl1> i like that link
22:02:19 <cl1> "hardward support for message passing" that's very nice
22:02:49 <ion> I wouldn’t mind having one of those on my desk. :-)
22:03:00 <kmc> it's not clear what "hardware support for message passing" is
22:05:01 <cl1> we currently have to create queues to store messages on, this garuntees if the computer on the other end goes down, it will pick the message up when it is brought back online
22:05:10 <drdo> I'm assuming they do packet switching on the chip
22:05:20 <cl1> its for fault tolerence
22:05:33 <cl1> so nothing gets lost in the event of a network failure
22:07:00 <cl1> you also aren't garunteed to recieve a response immediately, but eventually you will
22:07:21 <cl1> so i can't call like a traditional method and block until i recieve a response
22:07:50 <cl1> when the process on the other machine gets ready to respond, it will send a message out on the bus, just like the callee
22:07:58 <cl1> its cool stuff
22:11:54 <The_Journey> hi, what is the preferred way to check if a given string is numeric or not?
22:12:48 <cl1> well i'm out for the night, i'll be lucky if I make it on the computer at all this weekend. so happy holidays all
22:13:37 <penelope> Depends what kind of number your are looking for?
22:13:56 <ddarius> Reading the specs for Blue Gene/Q is interesting.
22:16:30 <ddarius> The_Journey: You parse it.  If you succeed, then you'll have the number.  If you fail, you'll have nothing.
22:18:23 <The_Journey> ddarius: oh, I'm asking what is the usual way to check if a string is numeric in Haskell, like is there a function that does that in the standard library?
22:19:11 <penelope> So we're looking for integers?
22:19:27 <ddarius> The_Journey: The usual way is to attempt to parse it.  So your question is changed into "What is the usual way to parse a string into a number?"
22:19:37 <The_Journey> ok.. that
22:19:53 <ddarius> The_Journey: It depends on your goals.  reads is in the Prelude and slow as fuck.
22:20:12 <The_Journey> ddarius: how would you do it
22:20:12 <ion> Is deadbeef a number? Is -9.5e-7 a number?
22:20:48 <penelope> and what about 34+34i?
22:20:51 <penelope> or
22:21:14 <drdo> all isDigit
22:21:30 <penelope> 12+23i+34j+45k+
22:22:28 <The_Journey> well using all isDigit will only verify if the string is an Integer, no?
22:22:48 <drdo> That's what you asked for isn't it?
22:22:52 <penelope> @type isDigit
22:22:53 <lambdabot> Char -> Bool
22:23:00 <ion> It’ll only verify if the string is a natural number.
22:23:09 <ion> s/is a/represents a base-10/
22:23:43 <penelope> @map map isDigit
22:23:43 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
22:24:01 <penelope> @type map isDigit
22:24:02 <lambdabot> [Char] -> [Bool]
22:24:15 <The_Journey> drdo: well I'm looking how to check if the string is numeric, like negative float, integer etc...
22:24:21 <penelope> @type and $ map isDigit
22:24:22 <lambdabot>     Couldn't match expected type `[Bool]'
22:24:22 <lambdabot>            against inferred type `[Char] -> [Bool]'
22:24:22 <lambdabot>     In the second argument of `($)', namely `map isDigit'
22:24:43 <ion> If it is, what are you going to do with the string?
22:24:43 <kmc> is "dreiundzwanzig" a number
22:24:54 <kmc> what about "twelfhundredneep"
22:25:04 <The_Journey> gonna put it in a list?
22:25:14 <ddarius> > isDigit 'a' -- penelope
22:25:14 <lambdabot>   False
22:25:16 <kmc> The_Journey, maybe you'd like http://haskell.org/haskellwiki/FAQ#How_do_I_catch_the_error_thrown_by_read_on_a_parse_failure.3F
22:25:35 <ddarius> > filter isDigit ['\0'..]
22:25:36 <lambdabot>   "0123456789"
22:25:39 <The_Journey> map isDigit "-123.123"
22:25:43 <ddarius> That was pretty quick.
22:25:50 <kmc> > dreiundzwanzig
22:25:51 <lambdabot>   23
22:26:00 <ion> So you don’t want the actual number, you just want to check if it’s parseable?
22:26:15 <The_Journey> oh... so I use reads and pattern match, gotcha
22:26:18 <drdo> checking if it's parseable is the same as parsing :P
22:27:03 <ion> That’s an implementation detail. We’re talking about what he *wants*. ;-)
22:27:25 <penelope> all isDigit?
22:27:28 <drdo> checking if it's parseable is also an implementation detail
22:27:35 <drdo> He wants to know if it represents a number
22:27:37 <drdo> :P
22:27:42 <ion> heh
22:28:41 <tigger_> I've been playing around with lenses, and am not able to resolve something. The code is here as is the error message: https://gist.github.com/1516620, if you load this into the interpreter it gives an error about inability to compose lenses. I thought composition since lenses are instances of category, or possibly the issue is with Data.Lens.Template. any help is appreciated
22:28:41 <penelope> So which subset of number representations are you interested in parsing?
22:28:54 <kmc> > fünf * dreiundzwanzig
22:28:55 <lambdabot>   161
22:29:09 <drdo> > λ * λ
22:29:10 <lambdabot>   Not in scope: `
22:29:16 <drdo> fail
22:29:35 <tigger_> I thought composition was possible since lenses are instances of category* - typo
22:30:43 <ion> tigger: Try import Prelude hiding (.); import Control.Category
22:30:47 <ion> hiding ((.)) that is.
22:30:57 <ddarius> http://www.top500.org/blog/2011/12/11/about_haskell_and_haswell
22:32:04 <penelope> Hmm.
22:32:18 <penelope> Maybe a cabal issue?
22:32:33 <tigger_> ion: great thanks! should have figured that one out...
22:32:37 <penelope> Try wiping your cabal state clean...
22:32:59 <ddarius> "Memory is like an orgasm.  It's a lot better if you don't have to fake it." - Seymour Cray
22:33:48 <drdo> Please tell me how to fake memory
22:33:53 <drdo> I'll take that magic
22:34:17 <ddarius> It's called virtual memory.
22:34:23 <drdo> That's not really faking
22:34:30 <drdo> it's still memory, just slower
22:34:56 <kmc> virtual memory ≠ swapfile
22:35:51 <penelope> http://en.wikipedia.org/wiki/Entropy_in_thermodynamics_and_information_theory
22:36:07 <kmc> swapping to disk is only one of the applications of virtual memory
22:36:11 <drdo> someone should write a proof for ∀x fakesMemory x ⇒ memory x
22:36:34 <ion> penelope: Boltzmann had incredibly wide and lumpy shoulders. http://upload.wikimedia.org/wikipedia/commons/6/63/Zentralfriedhof_Vienna_-_Boltzmann.JPG
22:37:17 <penelope> But he covered those with his indefinate beard.
22:37:21 <drdo> ion: Looks like some super viking
22:39:44 <ddarius> kmc: That article references IBM's C++ STM compiler, by the way.
22:39:51 <kmc> yeah, i saw
22:40:23 <xil> hi. I'm back
22:40:26 <kmc> hi xil
22:40:50 <xil> turns out that doing it without parallelism or concurrency is an order of magnitude easier =]
22:42:08 <xil> but I'm here with a question. What's a way to generate a list than starts at some fixed number and increases by a fixed amount. Something like [x,(x+h)..] but I don't want to use that notation because x and h are ridiculous expressions that I don't want to type out in this way
22:42:36 <kmc> let x = ridiculous_expression_for_x; h = ridiculous_expression_for_h   in  [x,x+h..]
22:42:37 <drdo> give them a name?
22:42:49 <kmc> btw [x,y..] is sugar for (enumFromThen x y)
22:42:51 <kmc> if that helps
22:43:06 <xil> I was looking for the latter form, yes
22:43:17 <xil> but I should ask, I suppose, can I next let blocks?
22:43:18 <kmc> because you want to use it points-free?
22:43:26 <kmc> yes
22:43:29 <kmc> let x = e in e
22:43:33 <xil> curiosity mostly
22:43:36 <kmc> that's an expression; both e's are expressions
22:43:41 <kmc> therefore you can nest let blocks
22:44:19 <drdo> I never understood why points-free is called that
22:44:24 <xil> I guess I'll just nest it. I've just never liked the [a,b..c] notation. I love [a..b] but I don't like that ',b' in there
22:44:35 <kmc> drdo, http://en.wikipedia.org/wiki/Pointless_topology
22:44:41 <penelope> In the future, every expression will be points-free.
22:44:44 <kmc> "points" are the function arguments
22:45:00 <ddarius> Points are the points in the space...
22:45:28 <drdo> points-free usually has a lot of points
22:45:32 <drdo> "."
22:45:43 <ion> Remove all the points! http://s3.amazonaws.com/kym-assets/entries/icons/original/000/006/199/x-all-the-y.png
22:45:48 <penelope> and -> really means givin x, y
22:45:51 <kmc> right
22:46:00 <kmc> huh?
22:46:07 * ddarius wonders if drdo is going to say the same things every night.
22:46:18 <penelope> -> means given x, then y
22:46:25 * drdo wonders why ddarius would wonder that
22:46:45 <kmc> penelope, huh?
22:47:48 <penelope> kmc: -> was chosen as the notation for argument because it resembled the mathmatical notation for implies.
22:47:58 <kmc> argument where?
22:48:10 <penelope> e.g.
22:48:41 <penelope> x :: Bool -> Bool
22:48:57 <penelope> x = True
22:49:00 <kmc> well, i think that's directly derived from the way functions are written in math
22:49:01 <penelope> there fore
22:49:21 <kmc> f : R³ → Z
22:49:22 <kmc> or what-not
22:49:45 <kmc> whether that notation relates to the "implies" notation, I don't know
22:49:54 <penelope> I mean
22:49:59 <penelope> x y = True
22:50:03 <kmc> function types are indeed related to logical implication, via the curry-howard isomorphism
22:50:08 <kmc> but i'm not sure that informed the choice of syntax
22:50:13 <penelope> Oh
22:50:16 <penelope> But it is!
22:50:18 <dolio> I expect the notation is older.
22:50:38 <dolio> But I don't know.
22:50:56 <penelope> -> is directly tied to the maths/logic notation.
22:51:21 <penelope> It's really about implication, not arguments and return values.
22:51:25 <kmc> is it?
22:51:32 <kmc> [citation needed]
22:52:12 <penelope> We don't need citations! P -> Q
22:52:25 <kmc> haven't you seen things in maths like  f : R³ → Z
22:52:47 <kmc> isn't that a closer analogue to the haskell syntax
22:54:21 <penelope> The basic idea is that if a is true, then b is true.
22:55:00 <penelope> And, is the syllogism, if a is true, and b is true, than a(b) is true
22:55:01 * ddarius recommends kmc stop talking since it has no effect.
22:55:02 <kmc> i don't understand why you are saying the things you are saying
22:55:09 <kmc> or how they relate to each other, to Haskell, or to the outside world
22:55:30 <kmc> ddarius, :/
22:55:40 <NihilistDandy> Sigh
22:56:00 <ddarius> kmc: Only in this particular circumstance.
22:56:08 <kmc> and many others like it
22:56:13 <kmc> but yes
22:56:15 <ddarius> Though, admittedly, most of what everyone says has no effect on other people.
22:57:58 <ddarius> "Everyone has so much to say they talk, talk, talk their lives away; don't even hesitate."
22:59:22 <dolio> Why cite historical references when you can make up post-hoc etymology?
23:01:04 <ion> Interestingly, the word “etymology” comes from the etymole, a subterranean mammal.
23:01:10 <monochrom> http://www.mail-archive.com/haskell-cafe@haskell.org/msg95730.html
23:01:12 <kmc> the symbol :: in Haskell is named "paamayim nekudotayim", which is Hebrew for "terrible lizard"
23:01:29 <kmc> it was chosen because it resembles a dinosaur
23:01:39 <penelope> I miss the dinosaur.
23:01:48 <drdo> Oh yes
23:01:59 <drdo> Now i see it, totally a dinosaur
23:02:12 <NihilistDandy> lol
23:04:01 <Goosey> Night everyone, merry christmas. o/
23:04:05 <kmc> 'night Goosey
23:05:58 <ddarius> The incontrovertible historical evidence: http://web.archive.org/web/20010224002304/http://haskell.cs.yale.edu/ghc/
23:06:39 <kmc> sweet, I always wanted GHC 4.08.1 for PA-RISC
23:06:40 <NihilistDandy> monochrom: I find your message too lazy. It needs to be more contractible.~
23:07:59 <ddarius> Things were so much simpler back then.
23:08:47 <kmc> http://web.archive.org/web/20000615003619/http://www.pms.informatik.uni-muenchen.de/forschung/haskell-wish-list/items.php3?sort=c&mono=y
23:09:46 <ddarius> All those kids thinking they are coming up with new ideas.
23:10:01 <kmc> a lot of these are still unimplemented in GHC!
23:10:24 <ddarius> Especially the stuff for Hugs!
23:10:31 <kmc> especially that
23:10:39 <kmc> next time Google Summer of Code ideas are wanted, I will suggest this page!
23:10:58 <kmc> "Description (Sven Panne, 1999-09-07)  NHC comes with a fancy graphical debugger, which is an important feature GHC currently lacks."
23:12:36 <ddarius> NHC's fancy debugger might have been Hat.
23:18:20 <ddarius> In fact, as far as I can tell, it was Hat.
23:57:58 <NihilistDandy> Anyone know why this typechecks in ghci and lambdabot, but only runs on the bot?
23:58:00 <NihilistDandy> ((.).(.).(.)) ((+).(+)) (((+).).(+)) 2 3 4 (+ 1) 5
23:58:04 <NihilistDandy> @type ((.).(.).(.)) ((+).(+)) (((+).).(+)) 2 3 4 (+ 1) 5
23:58:05 <lambdabot> forall a. (Num a) => a
23:58:11 <NihilistDandy> > ((.).(.).(.)) ((+).(+)) (((+).).(+)) 2 3 4 (+ 1) 5
23:58:13 <lambdabot>   20
