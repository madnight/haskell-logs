00:00:12 <Enigmagic> vhd: yeah they're the sledgehammer of Haskell :-)
00:00:51 <MostAwesomeDude> lewis1711: Hm. So the problem there is that "lookup" can fail. Maybe you want to restructure your code such that it can't fail.
00:00:55 <MostAwesomeDude> :t lookup
00:00:56 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
00:01:40 <mauke> ew, 'head'
00:01:46 <mauke> (head can also fail)
00:02:01 * lewis1711 doesn't laugh
00:02:16 <mauke> blargh, everything in there is unsafe
00:02:23 <mauke> head, last, read
00:02:30 <kniu> alright
00:02:36 <kniu> I just re-read the conversation we had
00:03:02 <kniu> it was like one of those movies with a twist at the end
00:03:11 <mauke> I was wrong about "I'm never cute"
00:03:31 <lewis1711> MostAwesomeDude: but can't lookup always fail by its very nature
00:03:37 <mauke> the second repetition of "won't work in IO ()" was cute
00:03:38 <lewis1711> unless...
00:03:47 <kniu> if you know Tyler Durden is in the protagonist's head, you notice a whole bunch of things in the second time you watch
00:03:58 <kniu> same thing here
00:04:02 <MostAwesomeDude> Whoa, whoa, spoilers.
00:04:11 <kniu> now that I know what your actual objection was, those questions make sense
00:04:13 <mauke> kniu: but that's another point; I didn't mean "won't work with IO", I meant "won't work in IO ()"
00:04:27 <mauke> in other words, you're in a context that demands IO ()
00:04:36 <kniu> mauke, do you not see how those two statements can be taken as synonymous?
00:04:58 <mauke> yeah, but only for the interpretation I'm describing
00:05:14 <mauke> I can see how "with IO" could be answered by "liftIO"
00:05:29 <Saizan> i think providing a bit more context and/or being a bit more verbose would have speeded things up
00:05:31 <kniu> the whole thing could have been resolved very quickly with a "his gtk2hs callback needs something of type IO ()"
00:05:49 <mauke> kniu: ok, I thought that was blindingly obvious
00:05:53 <kniu> it was not
00:06:00 <mauke> he'd mentioned gtk2hs like 5 times before State even came up
00:06:51 <vhd> I felt like a kid watching mom and dad fight over uncle toms visits every weekday.
00:07:38 * mauke kisses kniu
00:07:43 <mauke> I'm sorry, darling
00:08:07 <kniu> he also mentioned a paper on Monads and asks whether state always needs to be "passed in"
00:08:36 <lewis1711> https://gist.github.com/1454829 ok I'm sure I'm doing all sorts of things wrong here..
00:08:46 <kniu> I think it was reasonable to suggest the State monad in that context
00:08:51 <mauke> the answer to that is "mostly yes unless you allow unsafePerformIO"
00:09:24 <mauke> I think of State as automatic some of the plumbing, but it's still "passing in state"
00:09:29 <kniu> the answer to that is "mostly no because you have the State monad"
00:09:31 <mauke> *automating
00:09:52 <Saizan> you keep making unqualified statements :)
00:10:01 <kniu> who, me?
00:10:03 <Saizan> misleading each other
00:10:05 <Saizan> both
00:10:13 <mauke> s/^the/my/
00:11:53 <Saizan> "passing in" is quite obviously ambiguous here, do we mean in the implementation or in the EDSL generated by State? so any complete answer to "does state always needs to be passed in" should disambiguate that first
00:13:06 <vhd> what would be the correct what to say what I was asking?
00:13:11 <Enigmagic> lewis1711: generally it's better to make atomLookup return a Maybe, like atomLookup :: String -> Maybe Atom
00:13:47 <kniu> vhd, the miscommunication was not your fault
00:13:52 <kniu> don't blame yourself
00:13:58 <Enigmagic> lewis1711: or use Either and give a slightly more verbose error if possible
00:14:10 <mauke> :D
00:14:12 <kniu> mommy and daddy just have to get away from each other for a while, okay?
00:14:18 <vhd> :D
00:14:24 <mauke> vhd: we will always love you!
00:14:38 <lewis1711> Enigmagic: but then I don't know how to get the Atom. I want the Atom! I think I need a break
00:15:42 <Enigmagic> lewis1711: a case statement further up will do the trick. if you're just trying to get it working then there is certainly no harm in using error instead of Maybe or Either but it should be cleaned up
00:16:53 <Enigmagic> lewis1711: if it's core logic in a long running app then error is a no-no, but a small command line app it's not so bad... but if it's left around there is a tendency for semi-working functions to get used more than they should.
00:18:03 <kniu> you know what?
00:18:25 <kniu> StateT CAN be used here, despite all that
00:18:31 <Enigmagic> kniu: yeah?
00:18:47 <kniu> it's not the BEST solution because there's very little code that actually uses the state,
00:19:10 <Enigmagic> kniu: can it be used in my sample app? https://gist.github.com/3835cdb637678acf6829
00:19:33 <mauke> kniu: so where do you get the initial state from and where are you going to store the final state? :-D
00:19:40 <kniu> but you can definitely use the gtk2hs functions INSIDE a liftIO and use some combinators to turn the StateT Int IO () into an IO () to be given to the callback
00:20:08 <kniu> Enigmagic, I will modify your sample app
00:20:12 <kniu> give me a few minutes
00:20:17 <Enigmagic> kniu: sure thing
00:21:25 <mauke> Enigmagic: ourCallback x = print (x * 2 - 1)
00:21:47 <Enigmagic> mauke: :P don't make me change it
00:23:27 <Enigmagic> if it's not clear i'll modify it but the idea is that it should implement a scan without explicitly passing state
00:25:47 <kniu> > -- please modify ourCallback so this program outputs "1" "3" instead of "1" "2" without changing any other functions
00:25:48 <lambdabot>   not an expression: `-- please modify ourCallback so this program outputs "1...
00:25:49 <kniu> this is impossible
00:26:05 <mauke> there are at least three ways to do it
00:26:19 <kniu> well
00:26:20 <Enigmagic> kniu: it's not impossible, and it's what many C APIs look like with simple haskell bindings
00:27:16 <kniu> it's not impossible if you allow unsafePerformIO
00:27:22 <mauke> yes, that's #3
00:27:32 <kniu> but any other solution would require you to at least modify main
00:27:35 <mauke> #1 is my solution above
00:27:40 <mauke> modifying main is #2
00:27:49 <kniu> that's not what he was getting at
00:27:56 <mauke> #2 is legal because main is technically not a function
00:27:59 <kniu> and modifying main is explicitly disallowed
00:28:04 <kniu> what
00:28:12 <kniu> oh, right
00:28:18 <kniu> it's an IO action
00:28:22 <kniu> but those are all loopholes
00:28:23 <mauke> exactly
00:28:33 <mauke> so what?
00:28:41 <kniu> it's not the spirit of his question
00:28:59 <mauke> your task as a programmer is to reach through the loopholes and punch the problem specification in the face
00:29:19 <kniu> in this situation, being such a programmer does not facilitate discussion
00:29:33 <mauke> I actually think modifying main is in the spirit of the discussion
00:29:49 <mauke> because no matter what your C API looks like, you're still in control of main
00:29:55 <kniu> Enigmagic disallowed that (in spirit, not letter, but you get what I mean)
00:30:13 <Enigmagic> mauke: yes it is, but the StateT solutions wouldn't be any easier if main was modified imo
00:30:19 <mauke> sure
00:30:32 <kniu> wouldn't be easier, but would be possible
00:30:36 <kniu> let me show you what I mean
00:30:40 <mauke> ok!
00:30:42 <Enigmagic> kniu: sure
00:35:51 <vhd> out of curiosity, does anyone do profession haskell work?
00:36:02 <Enigmagic> vhd: yes sir.
00:36:02 <vhd> anyone here that is*
00:36:13 <mauke> some people, yes
00:36:13 <Enigmagic> 60-80 hours a week, depending on the week.
00:36:20 <vhd> what do you do, if you dont mind talking about it
00:36:25 <saati> what is it used for "in the industry" ?
00:36:53 <Enigmagic> automated trading of stocks
00:37:10 <lars9> Enigmagic: tsuru capital?
00:37:19 <Enigmagic> lars9: no, i work for myself
00:37:27 <lars9> Enigmagic: awesome
00:37:32 <Enigmagic> 50k lines of haskell
00:37:44 <AfC> That's a non-trivial amount of code
00:37:49 <Enigmagic> and about 2k of C++
00:38:29 <lars9> i watched a CUFP talk, a guy in Tokyo use haskell for finance system
00:38:46 <Enigmagic> AfC: well, about half is machine generated... but there is a lot of hand-written code for simulation and testing
00:39:37 <Enigmagic> maybe not half
00:39:47 <lars9> is seems this year's CUFP videos are not online
00:40:19 <lars9> *it
00:40:27 <Enigmagic> sloc is 69k right now :|
00:41:45 <lars9> that's a lot of haskell
00:43:45 <kniu> Enigmagic, https://gist.github.com/edb8ffdde27f6f855e38
00:44:08 <salisbury> Haskell is absolutely amazing.
00:44:13 <kniu> indeed
00:46:30 <salisbury> I would love to learn of ongoing research  with Haskell or on Haskell itself.
00:46:51 <salisbury> does anyone know of anything?
00:49:14 <AfC> salisbury: um, there's tons
00:49:30 <AfC> salisbury: most of the academic volume in and around Haskell is just that.
00:50:38 <hpaste> sattu94 pasted “xmonad.hs error” at http://hpaste.org/55064
00:51:20 <kniu> Enigmagic, thoughts?
00:51:24 <kniu> or mauke?
00:51:29 <Enigmagic> kniu: lemme look hang on
00:53:01 <Enigmagic> kniu: perhaps my example was overly simplified
00:53:23 <kniu> perhaps
00:54:07 <salisbury> AfC: I don't really know anyone else who knows it. I've only ever seen it used by myself on a personal research project.
00:54:57 <kniu> salisbury, read these: http://okmij.org/ftp/Haskell/
00:55:10 <Enigmagic> kniu: ourCallback needs to keep the type of "Int -> IO ()"
00:55:36 <kniu> also, http://research.microsoft.com/en-us/people/simonpj/
00:55:37 <Enigmagic> kniu: you can add all the parameters you want (and modify main accordingly)
00:55:37 <mauke> it does
00:55:50 <kniu> and http://research.microsoft.com/en-us/people/simonmar/
00:56:14 <kniu> mauke, what does what
00:56:30 <mauke> er
00:56:45 <kniu> Enigmagic, why do you insist on ourCallback having that type (or existing, for that matter?)
00:56:49 <mauke> I mean: as far as I can see ourCallback has the type Int -> IO () in kniu's code
00:57:11 <kniu> yeah, that too
00:57:16 <Enigmagic> kniu: because the C API needs a function of type "Int -> IO ()"
00:57:16 <kniu> it's just called callback now
00:57:22 <kniu> and that's what I've given it
00:57:27 <kniu> where's the problem?
00:57:39 <Enigmagic> mauke: where?
00:57:47 <mauke> Enigmagic: line 16
00:58:02 <mauke> kniu: how about this one: http://hpaste.org/55065
00:58:14 <salisbury> AfC: oh, nice this will keep me going a while
00:58:18 <mauke> kniu: output we want: "foo\nbar\nbaz"
00:58:29 <salisbury> AfC: thank you kindly
00:58:32 <Enigmagic> mauke: how would that get passed to a C function that takes a callback?
00:58:42 <kniu> salisbury, shouldn't you be thanking me?
00:58:50 <mauke> Enigmagic: like in line 18
00:58:50 <kniu> I feel so unappreciated ;_;
00:59:05 <salisbury> kniu: I was realizing as you responded
00:59:07 <AfC> kniu: thank you (less 5% shipping and handling)
01:00:07 <Enigmagic> mauke: and that works with threads eh?
01:01:30 <salisbury> kniu: Thank you kindly also
01:01:37 <kniu> mauke, does it have to be foo\nbar\nbaz
01:01:49 <mauke> kniu: what else do you have in mind?
01:02:05 <kniu> meh, don't matter
01:02:41 <kniu> mauke, you've stumped me
01:03:06 <kniu> in this case the only solution is using an IORef
01:03:45 <mauke> kniu: not quite, I can think of at least one other solution
01:03:52 <kniu> is it a loophole again?
01:03:54 <mauke> not counting unsafe*
01:04:30 <kniu> yeah I'll just print "foo\nbar\nbaz" elsewhere and have callback do nothing
01:06:37 <mauke> http://hpaste.org/55065
01:06:45 <mauke> didn't even have to change main
01:06:55 <kniu> :|
01:15:11 <Saizan> http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html <- on other ways to handle callback apis
01:27:48 <VHD__> wow, IORef really makes life easier. :D Now I can get this work done by today!
01:29:30 <luite> just convert everything to IORef and haskell will be so easy!
01:32:35 <Enigmagic> Saizan: think that would work with threads?
01:32:39 <lukish> I want to install some libs with cabal with some new options (like profilling). But cabal tells me, that some libs which new libs depends on was installed without that support
01:32:46 <lukish> And I should reinstall them
01:32:55 <lukish> How can I tell cabal to reinstall it manually
01:32:57 <lukish> ?
01:33:44 <Enigmagic> vhd: ignore the haters, IORefs have their place in the world. if you like Haskell enough to keep using it then you'll find ways to not use IORefs as often in the future.
01:34:46 <VHD__> of course, but for not they do a good job. I am sure with more experience, I will know better :D (I hope)
01:34:50 <VHD__> now*
01:34:55 <Enigmagic> yep :_)
01:35:08 <shachaf> Enigmagic: If you do everything with IORefs, are you really going to like Haskell all that much?
01:35:18 <shachaf> It's a bit clumsy with them, after all.
01:35:26 <Enigmagic> shachaf: it's not great, for sure.
01:36:04 <Enigmagic> but i'd rather help someone into Haskell even if it involves IORefs (whether or not they are required) than to kick someone out and tell them to go back to node.js or java :P
01:37:31 <VHD__> My projects constraints is that I have to use gtk2hs, I am however open to doing it the "right" way.
01:38:06 <mauke> I have nothing against IORefs
01:38:10 <Enigmagic> vhd: honestly i think that IORefs are just fine in this case.
01:38:13 <mauke> preflex uses IO all over the place
01:38:53 <Enigmagic> sometimes you need to use locks too
02:21:31 <lewis1711> ok I can't find much that explains how to use maybe for noobs. do I have to bite the monad bullet then?
02:22:22 <ddarius> No, you have to bite the learning Haskell bullet.
02:23:22 <DanBurton> Maybe's rather straightforward. Values are Just something, or Nothing.
02:23:27 <lukish> Proceeding try to solve http://blog.tmorris.net/20-intermediate-haskell-exercises/ . In 9th exercies how can I define unicorn?
02:23:42 <lewis1711> how do I unmaybe a maybe?
02:23:52 <lukish> I realized that unicorn is :: a -> (t -> a)
02:24:00 <DanBurton> lewis1711: you can't. What if it's Nothing?
02:24:03 <ddarius> @djinn a -> t -> a
02:24:04 <lambdabot> f a _ = a
02:24:07 <lukish> But having a how can I get t ->a
02:24:13 <DanBurton> lewis1711: so instead use a case statement
02:24:37 <lukish> @djiin a -> (t -> a)
02:24:37 <lambdabot> f a _ = a
02:24:55 <lewis1711> I tried. https://gist.github.com/1454829
02:25:32 <DanBurton> lewis1711: you forgot "of". case foo of
02:26:04 <lewis1711> ohh. thanks
02:26:28 <DanBurton> lewis1711: but why throw an error if it's not found? Just leave it in a Maybe, I'd say.
02:26:43 <DanBurton> Maybe is an elegant way to indicate that there may not be an answer
02:26:50 <DanBurton> > find 3 [1,2,4,5]
02:26:51 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
02:26:51 <lambdabot>    arising from the literal `3'...
02:26:54 <lewis1711> yes but I don't know how to use a maybe
02:26:55 <DanBurton> boo
02:27:03 <DanBurton> > find (==3) [1,2,4,5]
02:27:04 <lambdabot>   Nothing
02:27:10 <DanBurton> > find (==3) [1..5]
02:27:11 <lambdabot>   Just 3
02:27:11 <lewis1711> then I have to making everything a maybe all the way up the call stack
02:27:21 <lewis1711> like some kind of filthy monadic virus
02:27:27 <DanBurton> lol
02:27:52 <DanBurton> it doesn't have to go all the way; there has to be *some* point where you handle the case where it is Nothing
02:28:02 <ddarius> "Why pollute my code with error checking when I could just crash the entire program?!"
02:29:14 <lewis1711> because it's just a commandline program I run. if it crashes I get the prompt back
02:29:50 <lewis1711> DanBurton: is this some kind of category theory exception throwing?
02:30:02 <DanBurton> it's more Haskellish to...not crash :)
02:30:28 <DanBurton> instead of throwing an exception, you just handle the Nothing case in your IO code
02:30:50 <lewis1711> oh. that makes more sense
02:31:03 <DanBurton> if it's Just something, you print the corresponding message. if it's Nothing, you print an error message
02:31:12 <lewis1711> ok I'll keep that in mind, but it's not relevant to this particular program
02:31:14 <ddarius> lewis1711: No, but 2+2 is a manipulation of the free monoid generated by the singleton set, so I suggest you jettison basic arithmetic.
02:31:56 * DanBurton nods and pretends like he understands that
02:32:17 <lewis1711> i got monoid, singleton, and set. but appareantly haskell monoids aren't the monoids I learned in maths
02:32:22 <lewis1711> so pretty much nothing
02:32:46 <DanBurton> just smile and nod
02:34:16 <DanBurton> lewis1711: have you read / are you reading LYAH?
02:34:48 <ddarius> The Haskell Monoid class describes pointed magmas if you ignore the laws.  If you assume the laws, they are exactly monoids with computable multiplication.
02:35:20 <lewis1711> I've read about 3/4ths of it
02:35:37 * ddarius shouldn't reveal the secret about free pointed magmas.
02:35:40 <lewis1711> guess I should get onto the bit about functors
02:35:51 <lewis1711> pointed magmas? now you're just making up word
02:35:54 <lewis1711> s
02:35:58 * DanBurton wants some pointed magmas for free
02:36:35 <DanBurton> lewis1711: I really like the way LYAH introduces Functor and Monad
02:36:48 <DanBurton> I think that was my first experience learning about them
02:36:57 <DanBurton> And then I read RWH which I also highly recommend
02:39:23 <kowey> anybody here using MacOS X Lion? (I hear luite in particular is)
02:40:04 <kowey> looking for people's experiences with the Haskell cairo package
02:42:59 <lukish> @djiin (a -> (t -> b)) -> (t -> a) -> (t -> b)
02:43:00 <lambdabot> f a b c = a (b c) c
02:44:27 <lukish> What is a here? (a ->)?
02:45:13 <Botje> the type of a in f a b c= ... you mean?
02:45:29 <Botje> or the one in the type you gave
02:45:42 <lukish> @djiin (x -> (t -> y)) -> (t -> x) -> (t -> y)
02:45:43 <lambdabot> f a b c = a (b c) c
02:45:53 <lukish> What type a have here?
02:46:40 <Botje> c :: t, b :: t -> x, a :: x -> t -> y
02:46:53 <Botje> just like you asked for
02:47:44 <Botje> note that your type is equivalent to (x -> t -> y) -> (t -> x) -> t -> y
02:47:54 <ddarius> Exercise: Implement a function f :: ((() -> ()) -> ()) -> Bool, with the following semantics: f ($ ()) = True; f (const ()) = False; f undefined = undefined
02:57:09 <lukish> @pl (\x y z -> (x $ y $ z) $ z)
02:57:10 <lambdabot> flip flip id . liftM2
02:57:37 <lukish> @pl (\x y z -> x (y z) z)
02:57:37 <lambdabot> flip flip id . liftM2
02:57:41 <lukish> Okay
02:58:14 <shachaf> Poor man's function equality, @pl.
02:58:29 <lewis1711> I'm all haskelled out. night everyone
02:58:45 <lukish> @pl (\x y z -> (x $ (y z) z)
02:58:45 <lambdabot> (line 1, column 25):
02:58:46 <lambdabot> unexpected end of input
02:58:46 <lambdabot> expecting variable, "(", operator or ")"
02:58:48 <ddarius> @. djinn type (=<<)
02:58:50 <lambdabot> Cannot parse command
02:58:54 <lukish> @pl (\x y z -> (x $ y z) z)
02:58:55 <lambdabot> flip flip id . liftM2
03:04:08 <ddarius> > x + y == (x + y :: Expr)
03:04:09 <lambdabot>   True
03:04:15 <ddarius> > x + y == (x + z :: Expr)
03:04:17 <lambdabot>   False
03:04:41 <mauke> > x + y == x + z
03:04:43 <lambdabot>   False
03:05:05 <ddarius> > let f = \x y z -> (x $ y $ z) $ z; g = \x y z -> x (y z) z in f x y z == g x y z
03:05:06 <lambdabot>   Couldn't match expected type `b -> a -> b1'
03:05:06 <lambdabot>         against inferred type `...
03:05:35 <ddarius> > let f1 = \x y z -> (x $ y $ z) $ z; f2 = \x y z -> x (y z) z in f1 f g x == f2 f g x
03:05:36 <lambdabot>   Ambiguous type variable `b' in the constraints:
03:05:37 <lambdabot>    `SimpleReflect.FromExpr ...
03:05:50 <ddarius> Point.
03:16:05 * ddarius wonders if IBM has consultants to help them specifically design horrible user interfaces.
03:16:58 <shachaf> ddarius: I expect that that's the case, although not with that job description.
03:21:56 <aristid> > x==y
03:21:57 <lambdabot>   False
03:22:12 <aristid> hmm
03:22:29 <Jafet> > let x=y in x==y
03:22:31 <lambdabot>   True
03:22:41 <aristid> > x+y==y+x
03:22:42 <lambdabot>   False
03:22:45 <aristid> lol.
03:22:59 <Jafet> @pl \x y -> y + x
03:23:00 <lambdabot> (+)
03:23:01 <ddarius> (+) isn't commutative.
03:23:13 <aristid> ddarius: for Expr obviously not
03:23:14 <ddarius>  @pl makes unreasonable assumption.
03:23:18 <ddarius> +s
03:23:23 <Jafet> > x*(y*z) == (x*y)*z
03:23:24 <lambdabot>   False
03:23:37 <Jafet> Man, Expr is so abstract.
03:23:56 <aristid> i would call it an outlaw
03:25:02 <bwright> Well x*(y*z) where x, y and z could refer to any arbitary type.
03:26:01 <bwright> mm that is confusing.
03:26:16 <bwright> because (*) has a typeclass of Num
03:26:38 <Jafet> > let 6*9 = 42 in 6*9
03:26:39 <lambdabot>   42
03:27:36 <n0den1te> wat.
03:28:00 <bwright> It is just preforming a rewrite rule correct?
03:28:42 <bwright> Because let 6*9 = 42 in 9*6 will produce an error.
03:29:03 <n0den1te> Ah, I see where this comes from, yes..
03:29:34 <bwright> 6*9 is a pattern somehow...
03:29:43 <aristid> bwright: i'm not sure if Num has any laws
03:30:09 <aristid> > let 6*9 = 42 in 6*9
03:30:10 <lambdabot>   42
03:30:11 <n0den1te> precisely why I was surprised the first time around, it eval'd 6*9 into a token
03:30:20 <aristid> n0den1te: no.
03:30:27 <aristid> > let 6 * 9 = 42 in 6*9
03:30:28 <lambdabot>   42
03:30:51 <n0den1te> > let 6(*)9 = 42 in 6(*)9
03:30:53 <lambdabot>   <no location info>: Parse error in pattern
03:31:04 <bwright> let (6*9) = 42 in (6*9)
03:31:04 <n0den1te> hmm
03:31:11 <bwright> that will fail also.
03:31:17 <aristid> n0den1te: functions can SHADOW other functions, if they are locally scoped.
03:31:45 <aristid> bwright: just try it instead of declaring things that may or may not be true.
03:32:02 <aristid> bwright: your prediction record isn't that great :P
03:32:03 <bwright> 6*9 in a function of type Num a => a and so is 42
03:32:16 <bwright> so you are shadowing that function by the function 42
03:32:25 <aristid> :t let 8*9=9 in (*)
03:32:27 <lambdabot> forall t t1 t2. (Num t2, Num t1, Num t) => t -> t1 -> t2
03:32:45 <aristid> note how this is NOT the same type as regular (*) has
03:32:55 <Jafet> (I love doing that to this channel.)
03:33:25 <aristid> Jafet: :)
03:33:41 <n0den1te> aristid: are there no rules for Nums? :/ Numeric literals in place of functions confuse me.
03:33:49 <bwright> Hmm odd.
03:34:19 <n0den1te> Jafet: keep 'em coming, I say! (wherever that came from)
03:34:48 <aristid> n0den1te: if you define a new function, there is no rule for that at all
03:35:15 <aristid> and let defines new functions. always. even if they have a name that already existed. that name is shadowed, then.
03:35:42 <n0den1te> aristid: does that mean I can define a function using numeric literals alone and ghc would be smart enough to make them out? hmm, not that I know of - but that's one darn smart compiler. :)
03:36:14 <mauke> huh? where do you see numeric literals in place of functions?
03:36:39 <mauke> this is just normal pattern matching (more or less)
03:37:16 <shachaf> mauke: Well, admittedly the fact that you can "pattern match" on numeric literals is a bit weird.
03:39:30 <ddarius> shachaf: Not really.
03:40:07 <ddarius> The type that results is, arguably, a bit weird, but the Report defines Integer, at least, as equivalent to an infinitely wide sum type.
03:40:07 <aristid> ddarius: they are not constructors
03:40:18 <aristid> :t 1
03:40:19 <lambdabot> forall t. (Num t) => t
03:40:24 <aristid> note how it doesn't say Integer:)
03:40:34 <n0den1te> :t let 1=42 in 1
03:40:34 <ddarius> aristid: Note what I said.
03:40:36 <lambdabot> forall t. (Num t) => t
03:40:46 <aristid> ddarius: i did.
03:40:51 <n0den1te> > let 1 = 42 in 1
03:40:52 <lambdabot>   1
03:40:58 <bwright> aristid: Out of interest why does 6*9 work but (6*9) produce a pattern error?
03:41:29 <aristid> > let (a) = 2 in a
03:41:30 <lambdabot>   2
03:41:47 <aristid> > let (6*9) = 2 in 6*9
03:41:48 <lambdabot>   <no location info>: Parse error in pattern
03:41:53 <aristid> bwright: dunno.
03:42:14 <bwright> That was the prediction I made, so I was correct.
03:42:22 <bwright> ^_^ just thought I would point that out.
03:42:52 <n0den1te> > let 42 = 24 in 42
03:42:52 <gavri> is there anything like ruby's bundler for haskell? something that would give me the frozen state of the app and the packages it depends on, a snapshot of capri or cabal-dev or virthualenv's choice of packages
03:42:53 <lambdabot>   42
03:43:28 <n0den1te> > let (a*b) = 42 in a*b
03:43:29 <lambdabot>   <no location info>: Parse error in pattern
03:43:42 <n0den1te> > let (a*b) = 42 in (a*b)
03:43:43 <lambdabot>   <no location info>: Parse error in pattern
03:44:17 <ddarius> That doesn't work for the same reason let (f x y) = ... in ... doesn't work.
03:51:00 <etpace> I'm writing a parser for something similar to haskell, atm I have a semi working expression parser, but im having trouble parsing something like "let expr in .." as when I do e <- expr, my expr consumes the "in" too (eg: let bar = foo in.., thinks the expr on the RHS is (App foo in)), how do I solve this?
03:51:08 <etpace> (using parsec btw)
03:51:29 <mauke> don't let the expression parser consume "in"
03:51:33 <mauke> make it a keyword
03:52:26 <etpace> hmm
03:54:01 <etpace>  I originally was using token and that solved it nicely (with reserved etc), but the problem was building the expression parser with whitespace as application (the token module was greedily eating whitespace), i guess I'll redefine a string parser to respect keywords
03:55:38 <ddarius> etpace: You don't need to explicitly recognize whitespace to have juxtaposition mean application.
03:56:37 <etpace> Really? can you explain how?
03:57:11 <mauke> if your parser fails on (sqrt)42, it's already broken
03:57:54 <ddarius> Indeed, as mauke demonstrates, relying on whitespace is wrong.
03:57:54 <etpace> hm
03:59:56 <etpace> something like lookAhead term maybe?
04:00:02 <ddarius> No.
04:00:04 <etpace> need to suceed on two adjacent terms
04:01:23 <etpace> are you able to explain what I'm trying to match on?
04:01:55 <ddarius> etpace: Write out EBNF for the language you want to parse.
04:02:58 <ddarius> It's pretty easy to take most EBNF and produce a Parsec parser from it if all the occurrences of left recursion can be replaced by an iteration construct.
04:03:59 <ddarius> Alternatively, write out left factored BNF.  That should make what to do clear as well.
04:23:34 <rtharper> is there any sort of probabilistic bag/set lib?
04:25:15 <donri> rtharper: http://fedoraproject.org/wiki/Upgrading
04:25:23 <donri> sorry wrong channel and user :P
04:25:32 <rtharper> man was I confused..
04:25:40 <donri> :D
04:25:50 <mauke> probabilistic upgrading
04:26:52 <rtharper> maybe i'll write a probabilistic bag, then
04:27:16 <rtharper> a list would do for my purposes, though
04:27:23 <ddarius> "probabilistic bag/set" is not a very ambiguous or clear specification.
04:27:31 <ddarius> s/ambiguous/unambiguous/
04:27:47 <rtharper> ddarius: One where you can ask for a random element
04:28:16 <donri> do you mean random-access?
04:28:24 <rtharper> donri: sure don't
04:28:47 <ddarius> See, I was thinking that maybe you wanted something like a Bloom filter.
04:29:02 <rtharper> I mean where just ask for an element, it gives you a random one (with uniform probability, preferably)
04:29:18 <rtharper> ah, sorry, my mistake then =)
04:29:27 <bl4ckcomb> can I define a parameter that can be virtually anything? [(?,Int)] should match [(1, 1), ('a', 3)]
04:29:38 <rtharper> bl4ckcomb: no
04:29:53 <mauke> [(1, 1), ('a', 3)] isn't a valid value anyway
04:30:08 <bl4ckcomb> ok
04:30:17 <ddarius> mauke: It would be presumably if he could do what he described.
04:30:41 <mauke> he was talking about parameters so this probably involves a function
04:30:55 <mauke> foo [(1, 1), ('a', 3)] will error no matter how you define foo
04:31:00 <ddarius> Indeed, with free existentials, [(exists a. a, Int)] would do what he described (though very likely not what he wants.)
04:31:28 <rtharper> bl4ckcomb: without special extensions, you can't have a list where elements of are different types
04:31:46 <gavri> just in case anyone missed this earlier and has an answer: is there something like ruby's bundler for haskell? something that would give me the frozen state of the app and the packages it depends on, a snapshot of capri or cabal-dev or virthualenv's choice of packages maybe
04:32:11 <bl4ckcomb> mauke, yes you're right. what I'm trying to do is making a binary tree in which the 2 value parts can either be a value or a subtree
04:32:33 <donri> bl4ckcomb: see Data.Dynamic
04:32:44 <ddarius> mauke: If there was a type that could do what he wanted, then functions would be able to take them as parameters and there would be values of that type.  The fact that such a type doesn't exist is why that wouldn't be a valid value.
04:32:52 <ddarius> donri: That's a horrible solution.
04:33:11 <donri> in deed, i wrote that before reading eir actual problem
04:33:31 <mauke> ddarius: no matter how you define a new type, [...] wouldn't be a value of it
04:34:03 <ddarius> mauke: [...] is an instance of [(exists a. a, Int)]
04:34:04 <donri> bl4ckcomb: just wrap the values in an algebraic datatype of your own?
04:34:15 <ddarius> mauke seems to have issues with the subjunctive.
04:34:36 <mauke> no, with existentials
04:34:50 <mauke> I'm making some interesting assumptions about type checkins
04:34:55 <mauke> *checking
04:35:41 <hpc> gavri: you mean something that would read all the dependencies for a package, then download the most recent stuff that satisfies it and tarball all of them?
04:35:43 <bl4ckcomb> donri, ah that seems interesting. thank you
04:35:43 <mauke> bl4ckcomb: do you mean like data Tree a = Leaf a | Node (Tree a) (Tree a)?
04:35:53 <hpc> gavri: try going through the cabal manpage, perhaps
04:35:56 <donri> data BTree a = Leaf a | Node (BTree a) (BTree a)
04:36:03 <bl4ckcomb> mauke, yes exactly (that's what I read from donri's advice)
04:36:33 <mauke> er, how were you going to do it before?
04:38:14 <bl4ckcomb> mauke, I've just started experimenting in Haskell.
04:39:12 <ddarius> bl4ckcomb: There's some reason you asked your original question.  That is what mauke is wondering about.
04:40:54 <bl4ckcomb> I wasn't going to do it since I didn't know how to do it? I'm used to _ in prolog and I hoped there was something similar in haskell
04:41:53 <mauke> what's _ in prolog?
04:42:04 <ddarius> The same thing it is in Haskell.
04:42:13 <mauke> oh, boring
04:43:17 <milktrader> Is it true that you cannot iterate in Haskell in a C-like manner because of the issue of immutable objects, and that the preferred method is recursion?
04:43:30 <ddarius> milktrader: No.
04:43:48 <ddarius> milktrader: You can't because Haskell doesn't have any control structures other than recursion and pattern matching.
04:44:10 <mauke> depends a lot on how you define "C-like manner"
04:44:41 <milktrader> for( int a = 0; i < 10; i++)
04:44:57 <mauke> why would I want to do that when I can say 'forM_ [0 .. 9]'?
04:45:26 <hpc> mauke: because with the loop you can decide later to increment by TWO! lololol
04:45:51 <mauke> hpc: no, the correct answer is "because the C for loop doesn't iterate 10 times"
04:45:57 <hpc> also that
04:46:00 <mauke> note how it initializes a but checks i
04:46:15 <mauke> subtle bug!
04:46:20 <hpc> milktrader: i think you answered your own question ;)
04:46:39 <_oz> epic.
04:46:44 <mauke> I shall proceed to define "C-like manner" as "subtly broken"
04:47:10 <hpc> milktrader: looping constructs in haskell are all higher-order functions; if you have some particular form of looping that you use a lot, you can write a function to abstract over it easily
04:47:33 <milktrader> the two books I'm reading emphasize recursion and I have had the impression that recursion is slower than iteration
04:47:44 <ddarius> milktrader: You're wrong.
04:47:59 <hpc> milktrader: recursion is only slower in languages that are designed to favor iteration
04:48:26 <milktrader> Now I've also read that if you call the function once with a helper function then it mitigates the problem
04:48:54 <hpc> milktrader: in languages like lisp, tail recursion gets optimized to the same code as an explicit loop
04:49:10 <ddarius> hpc: Be careful with your wording.
04:49:17 <hpc> er
04:49:18 <ddarius> CL doesn't guarantee tail call optimization.
04:49:31 <ddarius> Admittedly, neither does Haskell.
04:49:40 <daimrod> but scheme does
04:49:40 <hpc> milktrader: SOMETIMES gets optimized to the same assembly that an explicit loop would generate
04:49:57 <hpc> (assuming you could be arsed to write the correct loop, which can sometimes be more lines)
04:50:13 <hpc> ddarius: i didn't think haskell had a concept of tail calls
04:50:32 <ddarius> hpc: "Tail call" is a syntactic property.
04:50:50 <milktrader> okay, I get the joke now. s/a/i
04:52:08 <ddarius> hpc: At any rate, almost no language explicitly define "tail positions," but few people have problems talking about tail call optimization in those languages.
04:52:43 <donri> milktrader: a similar bug in haskell would likely lead to compile-time errors, but not necessarily in C
04:53:06 <erus`> anyone want a fitocracy invite?
04:53:59 <Lemmih> erus`: Sure.
04:55:39 <milktrader> is there a base function that implements factorial and how would I see its implementation?
04:55:59 <donri> @src fac
04:55:59 <lambdabot> Source not found. You type like i drive.
04:56:04 <hpc> @src fact
04:56:04 <lambdabot> Source not found. :(
04:56:08 <hpc> @hoogle fact
04:56:08 <lambdabot> package factory
04:56:09 <lambdabot> package Facts
04:56:09 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment data BlendingFactor
04:56:15 <hpc> @hoogle factorial
04:56:15 <lambdabot> No results found
04:56:20 <hpc> apparently not
04:56:33 <mauke> milktrader: factorial n = product [1 .. n]
04:56:34 <hpc> milktrader: generally people will use fact n = product [1..n]
04:56:55 <hpc> or if they expect huge numbers that would stack overflow, fact = foldl' (*) 1
04:56:56 <ddarius> Generally people won't use factorial.
04:57:07 <mauke> hpc: or -O2
04:57:09 <hpc> or if they expect huge numbers that would stack overflow, fact n = foldl' (*) 1 [1..n] -- this, rather
04:57:13 <hpc> or -O2 lol
04:58:11 <donri> scumbag #haskell, ask for examples of iteration, get back insanely terse and high-level code
04:58:14 <milktrader> okay, good I'll take a look at those. R uses the gamma function (doesn't iterate or recurse)
04:58:35 <mauke> then how does it work?
04:59:51 <ddarius> There is gluten-free nail polish...
05:00:17 <ddarius> Or I should say, nail polish advertised as gluten-free allegedly.
05:01:03 <etpace> ddarius: I've written out what I believe is what I want, but Im unsure how to remove the left recursion (even using chainl1), my expr grammar is along the lines of: MUL := MUL * MUL | APP, APP := APP APP | TERM, TERM = (EXPR) | VARIABLE | INT, so I'd have mul = (mul `chainl1` op "==") <|> app? but that doesn't halt
05:01:45 <mauke> APP APP? holy shit
05:01:55 <mauke> that's like while (fork()) fork();
05:02:05 <mauke> etpace: also ambiguous
05:02:34 <mauke> a b c could be parsed as either of (a b) c or a (b c) according to that grammar
05:02:38 <milktrader> R uses it to capture non-integer values, but I think there second choice would be iteration over recursion. But then I learn Haskell doesn't shun recursion and encourages it
05:03:06 <hpc> etpace: in yacc and yacc-like substitutes, the prefered technique is to compute the first set of a production and do production := first production_tail
05:03:16 * milktrader trying to wrap my mind around functional programming
05:03:19 <ddarius> The Gamma function is probably implemented with some sort of iteration, though possibly it is just interpolated from a lookup table.
05:03:40 <donri> @where LYAH
05:03:40 <lambdabot> http://www.learnyouahaskell.com/
05:03:43 <donri> ... has a chapter on "thinking functionally"
05:04:19 <ddarius> Also, I highly suspect that R's Gamma function returns floating point numbers and thus will quickly become inaccurate for even moderate inputs.
05:04:33 <mauke> etpace: your MUL has the same problem
05:04:37 <milktrader> LYAH and Real World Haskell are my two sources for now, thanks for the reco
05:04:38 <etpace> I know
05:04:42 <ddarius> etpace: Look up left factoring.
05:04:46 <etpace> but that's how the grammar seems to "be"?
05:04:50 <mauke> etpace: no, it isn't
05:05:03 <etpace> (and its left recursive, not sure how to notate that in ebnf)
05:05:14 <mauke> 'a b c' does not mean both '(a b) c' and 'a (b c)'
05:05:29 <hpc> milktrader: add the haskell wikibook to that list; it is poorly edited and incomplete, but it has some topics that you can't find in the other two
05:05:37 <etpace> I know, but im unsure how to denote which one in ebnf
05:05:48 <hpaste> Carpi pasted “When is it evaluated?” at http://hpaste.org/55068
05:05:49 <milktrader> factorial(3.14)
05:05:49 <milktrader> [1] 7.173269 << from the R console
05:05:54 <carpi> could someone please tell me what is happening here? ^^^
05:06:11 <ddarius> > product [1..100]
05:06:12 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
05:06:15 <mauke> etpace: my first attempt would be: app = atom+
05:06:19 <ddarius> milktrader: What does R say?
05:06:21 <hpc> carpi: im gonna annotate your paste
05:06:48 <mauke> carpi: it doesn't matter when it is evaluated because the value is a constant
05:06:51 <ddarius> (i.e. for factorial(100) if that is not clear.)
05:06:56 <mauke> carpi: that is, evaluating getLine doesn't read a line
05:07:16 <donri> @where typeclassopedia
05:07:16 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
05:07:19 <donri> ... is also a good read
05:07:24 <carpi> hpc: thancs
05:07:30 <milktrader> ddarius it returns 7.173269 for factorial(3.14)
05:07:40 <carpi> mauke: i understand that much...but in that case when does getLine read a line?
05:07:44 <mauke> carpi: never
05:07:46 <carpi> at the print
05:07:57 <mauke> carpi: getLine is a constant
05:08:01 <milktrader> oh wait
05:08:18 <milktrader> 9.332622e+157
05:08:42 <ddarius> milktrader: Yes, which is quite imprecise.
05:08:43 <carpi> mauke: maybe i should have used the word 'executed' as opposed to 'evaluated'
05:08:48 <milktrader> good point
05:08:52 <mauke> carpi: that completely changes everything
05:09:32 <mauke> carpi: nothing within Haskell executes actions
05:10:04 <mauke> as far as Haskell is concerned, an "action" is just some abstract value like any other
05:10:31 <milktrader> product [1..314]
05:10:37 <carpi> mauke: or rather.. what if the expression was like "x = "has " ++ "kraft"".. now when would x be evaluated in this context
05:10:40 <milktrader> oops
05:10:57 <milktrader> product [1..3.14]
05:11:11 <hpaste> hpc annotated “When is it evaluated?” with “When is it evaluated? (annotation)” at http://hpaste.org/55068#a55069
05:11:14 <mauke> carpi: I'd hope compiler optimization would evaluate it at compile time
05:11:21 <hpc> carpi: http://hpaste.org/55069
05:12:01 <mauke> hpc: it is valid Haskell up to "Has " ++ x
05:12:05 <mauke> that part is a type error
05:12:24 <donri> milktrader: you need a > to get lambdabot to evaluate it, but it won't work like that anyway
05:12:40 <hpc> mauke: yeah, and it won't execute even if it did compile
05:12:45 <mauke> right
05:12:47 <donri> > [1..3.14]
05:12:48 <lambdabot>   [1.0,2.0,3.0]
05:12:49 <ddarius> It will do something but it won't calculate the Gamma function.
05:12:59 <milktrader> got it
05:13:25 <hpc> carpi: anyhoo, execution is your usual "run the program, do the stuff" action
05:13:49 <hpc> carpi: evaluation is more like "find the value of this expression"
05:13:51 <mauke> that somewhat glosses over the details
05:13:53 <carpi> hpc: the thing is.. im trying to understand why haskell is called lazy..
05:14:14 <donri> > [1..] !! 0
05:14:15 <lambdabot>   1
05:14:17 <mauke> > [1 ..]
05:14:18 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
05:14:19 <hpc> carpi: haskell has both strict and lazy IO (don't bother learning that yet)
05:14:20 <mauke> infinite list
05:14:32 <mauke> (and forget about lazy IO)
05:14:37 <hpc> carpi: and it also has lazy evaluation (and strict evaluation with flags and stuff)
05:14:38 <mauke> > take 10 (filter even [1 ..])
05:14:39 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
05:14:46 <hpc> carpi: imagine something like
05:14:57 <hpc> > let ones = 1 : ones in ones -- infinite list of ones
05:14:58 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:15:02 <mauke> carpi: haskell is lazy because f (g x) calls f before g
05:15:08 <mauke> hpc: that's not lazy
05:15:33 <donri> well, the fact that it evaluates at all is laziness?
05:15:40 <hpc> carpi: so at first, ones = THUNK
05:15:52 <hpc> carpi: where "THUNK" means we haven't evaluated it yet
05:16:02 <mauke> donri: struct node ones = { 1, &ones };
05:16:16 <hpc> carpi: then we want to look at the first element, so we evaluate the spine of the list and get
05:16:16 <carpi> hpc: and the expression after 'in' makes the evaluation strict?
05:16:24 <hpc> ones = (THUNK) : (THUNK)
05:16:29 <hpc> then evaluate the head of the list
05:16:35 <hpc> ones = 1 : THUNK
05:16:39 <mauke> carpi: ok, you may want to learn some haskell basics first
05:16:40 <hpc> and so forth
05:16:47 <mauke> carpi: 'let .. in' is how you define local variables
05:17:05 <hpc> carpi: but the evaluation doesn't happen until you need it to
05:17:21 <hpc> carpi: making sense so far?
05:17:22 <donri> hpc: i read you're getting an overhaul in 7.4
05:17:31 <donri> "Profiling and hpc overhaul."
05:17:44 <carpi> hpc: (THUNK) : (THUNK) makes sense
05:17:48 <hpc> im using really fuzzy language, so you should check a better resource after getting the concept down
05:17:55 <donri> HPC coverage "how much hpc is in my code?"
05:19:00 <hpc> carpi: https://en.wikibooks.org/wiki/Haskell/Laziness
05:19:31 <hpc> carpi: the key point is, until you need to know the value of something, it's a thunk
05:19:32 <donri> oic, "haskell program coverage"; that makes "hpc coverage" an instance of the RAS syndrome
05:20:00 <hpc> carpi: to open up a thunk, you pattern match on it
05:20:16 <mauke> (it's called a "thunk" because it's already been thunk of)
05:20:26 <hpc> > let ones = 1 : ones in (case ones of _ -> 5) -- no evaluation of ones
05:20:27 <lambdabot>   5
05:20:52 <thierrygar> florestine#27
05:20:54 <hpc> > let ones = 1 : ones in (case ones of (x:xs) -> 5) -- evaluates ones as far as (thunk : thunk)
05:20:55 <lambdabot>   5
05:21:02 <hpc> > let ones = 1 : ones in (case ones of (x:xs) -> x) -- evaluates ones as far as (1 : thunk)
05:21:03 <lambdabot>   1
05:21:34 <hpc> > let ones = 1 : ones in (case ones of (1:xs) -> 5) -- better example
05:21:35 <lambdabot>   5
05:22:22 <VeXocide> hi, is it possible to override the Data.Map and Data.Set Show to return a different representation?
05:22:35 <carpi> hpc: so in your example when you do "let ones = 1:ones in ones" (THUNK):(THUNK) in the first loop becomes 1:(THUNK):(THUNK) in the second recursive loop and so on ad infinitum..or something similar?
05:23:00 <carpi> oh and thankx for link : )
05:23:04 <hpc> carpi: yeah, more or less
05:23:06 <Cale> VeXocide: Not without recompiling containers.
05:23:09 <mauke> carpi: no, ones = 1:ones isn't actually infinite, just cyclic
05:23:13 <donri> VeXocide: wrap them in newtypes?
05:23:17 <Cale> VeXocide: But you can make a newtype with a different Show instance
05:23:38 <Cale> VeXocide: Or just use a different function :P
05:23:40 <mauke> carpi: that is, you have a (:) boxes with two slots. the first slow contains 1, the second slow points back to the box
05:23:49 <mauke> oh god
05:23:56 <hpc> carpi: also what mauke said, which i sort of glossed over - in this specific example, ones is totally evaluated once you evaluate the (:) and the 1
05:23:56 <mauke> carpi: that is, you have a (:) box with two slots. the first slot contains 1, the second slot points back to the box
05:23:57 <carpi> /s/show/slot )
05:24:03 <VeXocide> donri, Cale: thanks, that's too much trouble for something I don't care about enough :)
05:24:12 <mauke> apparently I can't type "slot"
05:24:18 <hpc> carpi: because of loopy-pointery implementation details
05:25:08 <Saizan> ones' = map id ones; there, now eveyone will agree that ones' is infinite
05:25:57 <carpi> thanks for the explanation and annotation. now i have a hazy picture.. but i think i will read that link you gave earlier..none the less..
05:27:17 <carpi> i think someone should write a sandbox game using haskell .. ala minecraft..but instead of building stuff out of blocks.. you build stuff out of haskell code.. that way us lesser haskell newbies can learn and have fun at the same time : )
05:27:28 <carpi> I already have a name - "Haskraft" : )
05:28:11 <Cale> carpi: I've been thinking of at some point when I'm less busy writing a minecraft in Haskell which uses something like hint to provide a detailed modding API.
05:29:13 <Eliel> carpi: that sounds like a fun idea :)
05:29:38 <hpaste> zhulikas pasted “problems with instances” at http://hpaste.org/55070
05:29:57 <zhulikas> line 8 and 16 does not compile
05:30:50 <Cale> zhulikas: You're trying to fmap a pair over the b in line 8
05:30:53 <Cale> f is a pair
05:31:04 <carpi> Cale: i already started writing some base code.. but to be honest im too scared to continue. The problem is im just soo not confident about my knowledge of haskell..that everytime i sit down to write a little bit more of the game.. i kinda feel scared that ill make a mistake somewhere.. i don't know if anyone can associate with that. : D
05:31:08 <Cale> same problem with line 16
05:31:34 <Cale> carpi: The typechecker will catch it
05:31:37 <zhulikas> a pair you say...
05:32:12 <zhulikas> I'm not sure if that makes sense
05:32:14 <zhulikas> ZWriter (a', b') <*> b = fmap a' b
05:32:28 <Cale> it doesn't :)
05:32:32 <zhulikas> hehe :)
05:32:39 <zhulikas> then I have a wrong understanding of <*>
05:32:46 <Cale> you have a Monoid instance for a reason, use it
05:32:57 <Cale> :)
05:32:58 <carpi>  haha.. you have a point.
05:33:03 <zhulikas> <*> is a composition?
05:33:10 <zhulikas> of two values
05:33:18 <zhulikas> for some odd reason I thought it
05:33:24 <zhulikas> for some odd reason I thought it's more of a mapping
05:33:34 <Cale> (<*>) :: (Applicative f) => f (a -> b) -> f a -> f b
05:33:54 <zhulikas> so f (a -> b) comes before <*>
05:33:59 <carpi> but realy.. dear haskellers.. when you sit down to write a large volume of code.. how do you proceed.. ? i mean what is your typical workflow like in terms of mindset and approach? any ideas would help??
05:34:20 <carpi> Eliel: i agree ).
05:34:25 <Cale> carpi: Well, there isn't just one way to approach any given programming problem...
05:34:31 <mreh> i tend to rewrite and rewrite
05:34:41 <zhulikas> I tend to not write
05:34:47 <mreh> after I've got something working
05:34:58 <Cale> carpi: But common ways are to write the code you want to be writing and then see if you can implement the things that you've used to write it.
05:35:05 <carpi> mreh: but doesn't that make the code unstructured?
05:35:27 <mreh> carpi: yes
05:35:38 <Cale> Or to build something from top to bottom which compiles but perhaps doesn't do much, and then expand out around that, adding things as you need them.
05:35:56 <hpc> carpi: for short stuff i tend to write from bottom to top
05:35:57 <mreh> it's too much of an impossible task to imagine an entire solution at once
05:36:16 <Cale> carpi: Haskell code is fairly easy to restructure, as far as programming languages go.
05:36:18 <hpc> carpi: start by breaking the problem into the smallest pieces i can, then put the pieces together in code until i have a running program
05:36:21 <mreh> and you find out what the tricky bits are, where you keep tripping yourself up
05:36:25 <Cale> Or even rewrite, a lot of the time.
05:36:28 <hpc> i tend to do the opposite on larger programs
05:36:54 <hpc> and yeah, lots of rewriting
05:37:07 <carpi> mreh: i totally agree.. because there have been times when i want to write a sufficiently large volume of code. and i try to plan every thing before i even start.. and guess what.. i end up not even starting.. i don't like that about myself
05:37:08 <hpc> i think ive rewritten my website once and my IRC bot three times
05:37:53 <mreh> carpi: you have to fight that, do something, and then evaluate
05:37:58 <carpi> Cale: the restructuring aspect makes a huge difference.. not only that.. with haskell.. ive noticed that if the type systems validates my code.. more often than not.. the entire thing works : )
05:38:02 <hpc> carpi: try writing your plan in pseudo-haskell, and write working code when it becomes easy to do so
05:38:03 <mreh> it wont be perfect :)
05:38:49 <carpi> hpc: to be honest.. i think that wouldn't work.. because in many ways haskell is already like pseudocode :)
05:38:56 <Cale> carpi: Yeah, and not only that, but you can just break something, and then keep hammering away at it with the compiler, and GHC will tell you exactly where all the things are that you need to change.
05:39:19 <mreh> this whole FilterMonad in happstack leaves a bad taste in my mouth
05:39:30 <mreh> it's so not declarative
05:39:46 <hpc> carpi: and if you need to see how a larger piece of code compiles without the noise of errors further down, you can use "undefined" as a placeholder for unfinished function definitions
05:40:00 <hpc> foo = complicated x where x = undefined
05:40:03 <zhulikas> how to write Applicative instance for a type which has multiple values? :|
05:40:05 <mreh> i've set the response, now I want you to leave it at that please!
05:40:25 <hpc> zhulikas: "multiple values" meaning like... lists?
05:40:31 <hpc> @src [] (<*>)
05:40:31 <lambdabot> (<*>) = ap
05:40:36 <mreh> hpc: ooh, i use that lots
05:40:39 <Cale> You can be somewhat mindless about things like that, where in untyped languages you end up having to think really really hard about even fairly small changes, because if you break something, you just have to figure out what's going wrong by actually running the program and looking at how it is broken. :P
05:40:42 <hpc> ...gee thanks lambdabot
05:40:49 <zhulikas> hpc, newtype ZWriter a b = ZWriter (b, a)
05:40:51 <zhulikas> for such a type
05:40:55 <Cale> @src [] ap
05:40:56 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
05:40:58 <Cale> @src ap
05:40:59 <lambdabot> ap = liftM2 id
05:41:03 <Cale> @src liftM2
05:41:03 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
05:41:03 <hpc> zhulikas: ah, that's easy
05:41:16 <hpc> instance Applicative (ZWriter a) where
05:41:50 <zhulikas> I am interested in <*> part
05:41:56 <gavri> hpc, yeah, that's what I meant about the bundler. thanks
05:41:59 <hpc>   (ZWriter (f, x)) <*> (ZWriter (v, x')) = ZWriter ((f v), something x x'))
05:42:15 <Cale> zhulikas: ZWriter (f, m) <*> ZWriter (x, m') = ZWriter (f x, mappend m m')
05:42:26 <hpc> zhulikas: something like that; i think you need a Monoid constraint in there
05:42:35 <hpc> yeah, what Cale just said
05:42:50 <zhulikas> @t (<*>)
05:42:51 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
05:42:58 <zhulikas> @type (<*>)
05:42:58 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:43:15 <zhulikas> how "ZWriter (f, m)" is a f (a -> b) ?
05:43:28 <Cale> It's a ZWriter m (a -> b)
05:43:31 <zhulikas> and ZWriter (x, m') is not
05:43:38 <hpc> zhulikas: the "f" is ZWriter m
05:43:39 <Cale> where there's an instance of Monoid for m
05:43:42 <hpc> er
05:44:10 <hpc> ZWriter (f, m) :: ZWriter m (a -> b)
05:44:22 <hpc> that f :: (a -> b)
05:44:24 <hpc> m :: m
05:44:37 <`Zerax`> Cale, have you written any other articles about Haskell topics apart from 'Monads as Computation' and 'Monads as Containers'? I found them quite accessible and interesting to read... so I'm curious whether you've written anything else.
05:45:00 <Cale> `Zerax`: a little introduction to IO...
05:45:06 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
05:45:09 <zhulikas> and ZWriter (x, m') :: f a
05:45:10 <zhulikas> ?
05:45:16 <Cale> `Zerax`: and lots of posts on Reddit...
05:45:30 <`Zerax`> Ah cool, thanks, I'll take a look.
05:45:32 <Cale> But I'd have to dig through my comments to find them
05:46:32 <VeXocide> if I have a list of true / false values, what's the easiest way to do x or y depending on whether the value is true or false for each item in that list?
05:46:47 <hpc> :t or -- VeXocide
05:46:47 <lambdabot> [Bool] -> Bool
05:46:49 <hpc> :t and -- VeXocide
05:46:51 <lambdabot> [Bool] -> Bool
05:46:57 <hpc> > or [False, False, True]
05:46:58 <lambdabot>   True
05:47:03 <hpc> > and [False, False, True]
05:47:04 <lambdabot>   False
05:47:08 <zhulikas> I don't understand how can these values be of different types, on one side it's (a -> b), on another just a
05:47:24 <hpc> VeXocide: i think that's what you want
05:48:16 <Cale> zhulikas: because the types of f and x are different
05:49:08 <zhulikas> well, I thought that they have to be of the same type
05:49:22 <zhulikas> if they don't, that changes pretty much everything
05:49:58 <VeXocide> hpc, this is the context, http://codepad.org/ZPeFtusm, I want to write evaluate_process, now Set.map (evaluate_logical b) variables gives me a set of true / false and I want to execute either p or q for each value in that set
05:50:20 <VeXocide> hpc, sorry, I want to write evaluate_process (IfThenElse b p q) variables
05:50:22 <hpc> VeXocide: oh
05:50:38 <hpc> VeXocide: what i would do is write
05:50:46 <hpc> (t ?? f) p = if p then t else f
05:50:53 <mauke> bool :: Bool -> a -> a -> a
05:50:59 <mauke> no
05:51:10 <mauke> bool :: a -> a -> Bool -> a
05:51:14 <hpc> VeXocide: then evaluateProcess t f bs = Set.map (t ?? f) bs
05:51:22 <mauke> bool f t c = case c of False -> f; True -> t
05:51:33 <hpc> VeXocide: for certain values of "t", "f"
05:52:01 <VeXocide> hpc, for clarity, t is what to process when true, f for false and p the predicate?
05:52:07 <hpc> yeah
05:52:28 <mauke> mine is called 'bool' in analogy to 'maybe' and 'either'
05:52:30 <hpc> that will produce a Set of actions... which occurs to me might be a problem
05:53:04 <hpc> VeXocide: i would convert the set of Bool to a list, then use a regular map, then sequence the actions
05:53:08 <hpc> :t sequence
05:53:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:53:15 <mauke> :t mapM_
05:53:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
05:53:22 <hpc> or mapM :P
05:55:00 <VeXocide> hpc, I think a Set.union (Set.map (eval_i_t_e p q var) (set-of-true/false)) 'll work where eval_i_t_e is process -> process -> (Set variables) -> bool -> (Set variables)
05:55:05 <hpc> evaluateProcess set = let list = toList set in mapM (ifTrue ?? ifFalse) list
05:55:51 <hpc> VeXocide: ah, k
05:56:08 <hpc> VeXocide: i got thrown when you said "execute", since it sounded like you wanted to do a bunch of monadic actions
05:56:42 <VeXocide> hpc, ah, thanks anyways, I think I'll manage now
06:24:02 <lukish> Trying install lambdabot http://paste.lisp.org/display/126400
06:24:09 <lukish> What should I do?
06:32:20 <jessopher> lukish: what OS are you installing this on?
06:32:27 <lukish> gentoo
06:33:03 <jessopher> hsPlugin is just taking a big dump for whatever reason
06:34:31 <lukish> jessopher: so what should I do?
06:35:03 <jessopher> also what version of ghc are you using?
06:35:12 <lukish> 7.0.4
06:36:16 <jessopher> i dont know what you should do off hand, but i am gonna try to build it myself in a slightly different environment and see what i get
06:36:38 <lukish> Good luck, lol
06:37:12 <lukish> Main thing is I've added profiling option
06:37:15 <lukish> To cabal's config
06:37:39 <jessopher> oh well that might have something to do with it, given the nature of the plugin code
06:37:56 <jessopher> im not even gonna attempt that
06:52:14 * hackagebot hakyll 3.2.3.2 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.3.2 (JasperVanDerJeugt)
06:57:14 * hackagebot monadloc 0.6 - A class for monads which can keep a monadic call trace  http://hackage.haskell.org/package/monadloc-0.6 (PepeIborra)
06:57:16 * hackagebot monadloc-pp 0.1 - A preprocessor for generating monadic call traces  http://hackage.haskell.org/package/monadloc-pp-0.1 (PepeIborra)
07:10:24 <fsgxdroid> i have a problem, with following code:
07:10:27 <fsgxdroid> parenDigits xs = [if isNumber x then "(" ++ x ++ ")" else x | x <- xs]
07:10:37 <fsgxdroid> Couldn't match expected type `Char' with actual type `[a0]'
07:11:03 <mauke> fsgxdroid: what's the type of isNumber?
07:11:20 <fsgxdroid> Data.Char function
07:11:32 <mauke> :t Data.Char.isNumber
07:11:34 <lambdabot> Char -> Bool
07:11:42 <mauke> fsgxdroid: you can't ++ a Char
07:12:14 * hackagebot control-monad-exception 0.10.0 - Explicitly typed, checked exceptions with stack traces  http://hackage.haskell.org/package/control-monad-exception-0.10.0 (PepeIborra)
07:14:00 <fsgxdroid> if the input is following > parenDigits "as&#67aB3TY", then output should be "as&#(6)(7)aB(3)TY
07:14:19 <roconnor> @hoogle isDigit
07:14:20 <lambdabot> Data.Char isDigit :: Char -> Bool
07:15:04 <rexim> concatMap?
07:15:12 <roconnor> > isDigit '٠'
07:15:13 <lambdabot>   False
07:15:43 <roconnor> fsgxdroid: "(" ++ [x] ++ ")"
07:16:49 <rexim> > concatMap (\x -> if isDigit x then "(" ++ [x] ++ ")" else [x]) "as&#67aB3TY"
07:16:51 <lambdabot>   "as&#(6)(7)aB(3)TY"
07:21:35 <fsgxdroid> rexim: ty, got it working now,  but what is the meaning of "\x ->"?
07:22:03 <cgroza> @type contactMap
07:22:03 <rexim> It's lambda function.
07:22:05 <lambdabot> Not in scope: `contactMap'
07:22:16 <cgroza> @type concatMap
07:22:18 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
07:22:20 <alistra> @pl \y x -> off x y
07:22:21 <lambdabot> flip off
07:22:32 <rexim> > (\x y -> x + y) 10 20
07:22:34 <lambdabot>   30
07:22:52 <fsgxdroid> nice :)
07:23:20 <fsgxdroid> cool language
07:27:14 * hackagebot fix-parser-simple 15318.1 - Simple fix-expression parser  http://hackage.haskell.org/package/fix-parser-simple-15318.1 (MatthewFarkasDyck)
07:27:16 * hackagebot safe-failure-cme 0.1.0 - control-monad-exception Instances for safe-failure  http://hackage.haskell.org/package/safe-failure-cme-0.1.0 (PepeIborra)
07:32:14 * hackagebot generic-tree 15318.1 - Generic Tree data type  http://hackage.haskell.org/package/generic-tree-15318.1 (MatthewFarkasDyck)
07:32:24 <ion> Nice version number.
07:33:04 <ion> > 15318/365 + 1970
07:33:05 <lambdabot>   2011.9671232876713
07:57:14 * hackagebot jack 0.6 - Bindings for the JACK Audio Connection Kit  http://hackage.haskell.org/package/jack-0.6 (HenningThielemann)
08:07:47 <sam0> Hi
08:07:59 <sam0> I am trying to get a sample of random numbers in haskell
08:08:26 <sam0> I have perform some computations that takes in random numbers
08:09:04 <sam0> but I want to get a sample of random numbers in some form of an array (list) format beforehand
08:09:26 <sam0> and when I just want to run the computation by taking a number from this list
08:09:39 <sam0> instead of just getting random numbers each time
08:09:44 <sam0> is there a best way to do this?
08:09:54 <hpc> :t randoms
08:09:55 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
08:10:41 <sam0> so the reason why I want to do this is due to the speed
08:11:05 <sam0> I want to precompute all the random numbers before running the actual code to test performance
08:11:05 <byorgey> I don't think it will make much difference then.
08:11:27 <statusfailed> Is there a function for the state monad evaluating a list of inputs and updating the current state for each input?
08:11:31 <statusfailed> instead of using recursion
08:11:48 <sam0> because I am running some tests on a specific code and I don't want creating random numbers as part of the code
08:11:53 <hpc> statusfailed: what type do you want it to have?
08:11:57 <byorgey> statusfailed: mapM, or mapM_, probably
08:12:00 <statusfailed> a general type
08:12:00 <sam0> Integer
08:12:42 <jmcarthur> sam0: take some numbers from randoms and deepSeq it?
08:13:04 <statusfailed> ok so something like: last $ mapM_ updateMyState [i,n,p,u,t,s]
08:13:04 <sam0> hm2026 let me check what deepSeq do
08:13:06 <hpc> :t deepseq . take 1000 . randoms
08:13:07 <lambdabot> Not in scope: `deepseq'
08:13:20 <hpc> sam0: it evaluates its argument to normal form
08:13:33 <hpc> (as opposed to seq/evaluate, which are whnf)
08:14:08 <sam0> I see2026 I think that might be exactly what I want
08:14:24 <sam0> one more question is...
08:14:35 <parcs> :t True `asTypeOf` ?x
08:14:37 <lambdabot> (?x::Bool) => Bool
08:14:58 <heatsink> What are implicit parameters used for?
08:14:58 <sam0> I want to create this list of random numbers2026 so can I make it sort of a global variable as in other languages so that it is visible to other functions?
08:15:27 <cheater> sam0: yes.
08:15:31 <hpc> heatsink: obfuscation and lambdabot type querying trickery
08:15:38 <heatsink> haha okay
08:15:52 <hpc> heatsink: also dynamic scope, if you don't consider that a subset of obfuscation ;)
08:16:40 <byorgey> sam0: the short answer is: you can't.
08:17:17 <sam0> oh2026 I can't what?
08:17:26 <sam0> you mean I can't precompute random numbers?
08:17:37 <hpc> sam0: can't have globals
08:17:50 <rwbarton> you can make it a global "variable" if its value doesn't change from run to run of your program
08:18:20 <sam0> Oh I see...
08:18:22 <roconnor> > randoms (mkRandomGen 20111210) :: [Int]
08:18:23 <lambdabot>   Not in scope: `mkRandomGen'
08:18:28 <roconnor> > randoms (mkRandom 20111210) :: [Int]
08:18:29 <lambdabot>   Not in scope: `mkRandom'
08:18:34 <roconnor> @hoogle mkRand
08:18:35 <lambdabot> No results found
08:18:39 <rwbarton> otherwise you will have to compute it in main or somewhere, and pass it around
08:18:41 <hpc> @hoogle Int -> StdGen
08:18:42 <lambdabot> System.Random mkStdGen :: Int -> StdGen
08:18:42 <lambdabot> Prelude (!!) :: [a] -> Int -> a
08:18:42 <lambdabot> Data.List (!!) :: [a] -> Int -> a
08:18:57 <roconnor> > randoms (mkStdGen 20111210) :: [Int]
08:18:59 <lambdabot>   [-9136512605747487326,-1506097140583724017,-3840266465156267852,-3131965477...
08:18:59 <hpc> > randoms (mkStdGen 20111210) :: [Int]
08:19:00 <lambdabot>   [-9136512605747487326,-1506097140583724017,-3840266465156267852,-3131965477...
08:19:04 <sam0> I see...
08:20:01 <roconnor> sam0: I'm not sure you quite understand how laziness impacts program development
08:20:47 <roconnor> sam0: With laziness you can easily separate your code that uses random numbers from the code that generates random numbers, and laziness will still mean the random numbers are generated on demand.
08:21:05 <roconnor> sam0: in other words, pass an infinite list of random numbers into your function.
08:21:57 <sam0> yes2026 let me explain myself again...
08:22:14 * hackagebot fix-parser-simple 15318.2 - Simple fix-expression parser  http://hackage.haskell.org/package/fix-parser-simple-15318.2 (MatthewFarkasDyck)
08:22:25 <sam0> what I am trying to do is get gaussian random sample...
08:22:33 <hpc> sam0: why am i seeing ^2026 on every one of your lines?
08:22:43 <sam0> oh...
08:22:48 <sam0> I think something is weird
08:22:50 <sam0> I'll comeback
08:23:04 <jessopher> some kind of unicode comma mangling?
08:23:19 <roconnor> http://www.fileformat.info/info/unicode/char/2026/index.htm ?
08:23:21 <sam6> hi
08:23:22 <hpc> ah
08:23:29 <sam6> is it better?
08:23:36 <statusfailed> give us a comma
08:23:36 <hpc> yeah, i think
08:23:53 <roconnor> or give us a horizontal ellipsis
08:23:58 <jessopher> well it was elipsis, yeah
08:24:01 <statusfailed> oh it was?
08:24:07 <sam6> ok2026 so what I want is a gaussian set of random numbers
08:24:13 <statusfailed> hahah
08:24:14 <roconnor> :D
08:24:18 <jessopher> lol, well atleast we know what it is
08:24:19 <sam6> so I am getting a random number from a specific range
08:24:34 <sam6> and then with certain probability, I am rejecting it or keeping it
08:24:40 <hpc> oh, that it was
08:25:03 <sam6> and I want to make a list with these accepted random numbers
08:25:22 <roconnor> sounds good
08:25:31 <sam6> but since this is expensive2026 I want to precompute it before hand
08:25:39 <roconnor> what is expensive?
08:26:04 <rwbarton> I think he said earlier he wants to benchmark an algorithm to which these random numbers are the input
08:26:05 <sam6> getting a random number2026 checking for probability and putting it in a list
08:26:15 <roconnor> are you going to reuse this list?
08:26:46 <roconnor> rwbarton: oooh
08:26:48 <roconnor> benchmarking
08:27:00 <sam6> so once I have this list, whenever I am going to use random numbers in my code, I wanted to simply take from this list
08:27:03 <rwbarton> I could have misinterpreted though
08:27:16 <sam6> yes I wanted to test the efficiency of a certain piece of code
08:27:30 <jessopher> then deepSeq is probably what you want
08:27:58 <sam6> I'm assuming just taking from the list is faster than gettting random num, accepting or rejecting with probability, compute again if rejected2026
08:28:11 <pidhash> someone could help with this code http://nopaste.info/3149b20c35.html ?
08:29:58 <rwbarton> pidhash: looks like you have an indentation issue? right now "myFunction = id" is part of that do block in mainWith
08:30:00 <sam6> let me just write a piece of code and show
08:30:30 <hpc> pidhash: indent it like this
08:30:32 <hpc> foo = ...
08:30:33 <hpc>   where
08:30:37 <hpc>     bar = ...
08:30:40 <hpc>     baz = ...
08:31:17 <pidhash> so myFunction is like a case ?
08:33:20 <hpc> pidhash: what you have now is
08:33:23 <hpc> foo = ...
08:33:27 <hpc>   where bar = do
08:33:30 <hpc>     ...
08:33:34 <hpc>     baz = ...
08:33:46 <hpc> pidhash: in other words, "baz = ..." is part of that do-block
08:34:54 <GordonFreeman> hii
08:35:02 <GordonFreeman> how would you get t from this? R_t=R_0*(1+A*t+B*t*t+(t-100)*C*t*t*t);
08:36:21 <rwbarton> quartic formula?
08:36:31 <GordonFreeman> it has t^3
08:36:36 <rwbarton> (not a serious suggestion)
08:36:48 <byorgey> GordonFreeman: it has t^4 also.
08:37:03 <hpc> GordonFreeman: try #math, perhaps
08:37:12 <GordonFreeman> ok
08:38:11 <byorgey> GordonFreeman: do you mean you want to know how to find t in general? or you want a Haskell program to solve it?
08:38:29 <GordonFreeman> i would like to calculate t
08:38:39 <GordonFreeman> i have all other values
08:38:54 <byorgey> unfortunately I don't know of any good numerical root-finding packages for Haskell
08:39:17 <GordonFreeman> i know SQRT, that will work for me
08:39:58 <byorgey> GordonFreeman: SQRT?
08:40:19 <GordonFreeman> for calculating square roots
08:40:55 <pidhash> sorry ask again but I am new with haskel in this code http://nopaste.info/3149b20c35.html, myFunction = id is just in do scope
08:40:56 <byorgey> when I said "root-finding" I meant finding roots (zeros) of functions, not calculating square roots
08:41:08 <pidhash> *haskell
08:41:58 <rwbarton> GordonFreeman: do you need this ability to solve for t in a Haskell program, or can you just use an external tool like WolframAlpha
08:42:37 <GordonFreeman> well i wouldn't like to use wolframalpha for calculating temperature of my RTD temperature sensor
08:42:47 <GordonFreeman> (in my program)
08:42:52 <mzero> pidhash: you have an indentation problem
08:43:16 <mzero> indent lines 12 though 16 so they are past the start of 'mainWith'
08:43:54 <vrook> For a given monad Foo and its transformer version FooT, is Foo the composition of FooT with the identity monad?
08:44:03 <rwbarton> GordonFreeman: look into http://en.wikipedia.org/wiki/Root-finding_algorithm
08:44:09 <hpc> vrook: yes
08:44:24 <hpc> vrook: dunno if there's a rule about that, but it's how mtl works
08:44:35 <vrook> So why aren't all monads defined in terms of the transformer monad? Just for efficiency?
08:44:49 <byorgey> vrook: not all monads can be made into a monad transformer.
08:44:57 <hpc> notable case: []
08:44:59 <GordonFreeman> ohh so i must calculate the whole equation over and over to find the answer?
08:44:59 <hpaste> mzero pasted “re-indented” at http://hpaste.org/55073
08:45:08 <mzero> see that, pidhash
08:45:11 <vrook> OK well take the ones that can, then.
08:45:17 <aninhumer> Also I suspect it's easier to work out what they do from non-transformer code
08:45:45 <byorgey> vrook: well, no particular reason then.
08:45:46 <rwbarton> in some mtl-type libraries (maybe including the current mtl?) they actually are defined that way
08:46:03 <rwbarton> State s = StateT s Identity etc.
08:46:12 <byorgey> yes, in 'transformers' they are defined that way (which is where mtl gets them)
08:47:11 <byorgey> GordonFreeman: aha, try http://hackage.haskell.org/package/roots
08:47:12 <aninhumer> hpc: doesn't ListT exist?
08:47:24 <byorgey> aninhumer: it does, but the version in mtl is broken
08:47:32 <byorgey> i.e. it does not satisfy the monad laws
08:47:50 <byorgey> to be more precise, ListT m  only satisfies the monad laws when m is a commutative monad
08:48:11 <rwbarton> but there's that other ListT which is a monad transformer
08:48:16 <sam6> is there euler's constant (e) in haskell?
08:48:23 <heatsink> > exp 1
08:48:24 <byorgey> > exp 1
08:48:24 <lambdabot>   2.718281828459045
08:48:25 <lambdabot>   2.718281828459045
08:48:26 <sam6> I see
08:48:27 <sam6> thanks
08:48:35 <byorgey> heatsink wins!
08:48:43 <heatsink> I am the iron pony!
08:49:12 <mreh> i didn't know that
08:49:31 <byorgey> aninhumer: see http://www.haskell.org/haskellwiki/ListT_done_right
08:49:32 <sam6> do I have to import package to use it?
08:49:44 <byorgey> sam6: no
08:50:09 <rwbarton> pretty sure there is no "IOT done right" though.
08:50:29 <mreh> you cannot escape from IO
08:50:44 <cheater> except for Unsafe functions
08:50:52 <rwbarton> there is actually an STT package, but it is "done wrong"
08:50:55 <mreh> silence!
08:51:01 <mreh> they must not know
08:51:21 <cheater> what is STT?
08:51:38 <mreh> the ST monad transformer? (guess)
08:51:43 <mreh> never used it
08:51:54 <vrook> I see "escape" used with monads. Does it mean something like the opposite of lift?
08:51:55 <byorgey> that's what it is supposed to be
08:51:58 <rwbarton> yes, although it doesn't exist really
08:52:09 <rwbarton> or it exists, but it doesn't really work
08:52:16 <byorgey> vrook: yes, something like  m a -> a
08:52:27 <mreh> vrook, it's the opposite of return
08:52:36 <byorgey> vrook: when you hear people say "you can't escape from a monad" ignore them
08:52:50 <byorgey> vrook: what they mean is that there's no *general* way to escape from any monad.
08:52:52 <rwbarton> http://hackage.haskell.org/packages/archive/STMonadTrans/0.2/doc/html/Control-Monad-ST-Trans.html
08:53:19 <vrook> So one would say that runST provides an escape from ST?
08:53:21 <byorgey> vrook: but most monads do have a way to "run" them and "escape"
08:53:26 <byorgey> vrook: yes, exactly
08:53:51 <byorgey> for Maybe there is 'maybe'; for State there is runState (and evalState and execState); and so on
08:54:15 <hpc> for IO there is unsafePerformIO, but we pretend it doesn't exist
08:54:16 <mreh> Maybe is one of the few you can pattern match
08:54:17 <byorgey> vrook: really the only monad that has no such thing is IO, unless you count unsafePerformIO which is cheating
08:54:23 <hpc> IO is the one monad you can't escape from
08:55:12 <mreh> that's where they keep Lord Xenu
08:55:36 <vrook> We escape from IO after the Big Crunch.
08:55:47 <vrook> Big Bang gives another IO
08:55:53 <mreh> that's superstition
08:56:46 <aninhumer> We must not discuss unsafePerformIO lest Xenu hear of it
08:56:53 <mreh> i've found what I was looking for, finishWith!
08:57:31 <vrook> I was almost being serious. You can't escape from IO because it's tied to our universe, right?
08:57:43 <vrook> That's the general idea, anyway, I think.
08:58:15 <monochrom> no. you can't escape because we artificially make that rule.
08:58:32 <vrook> But the reason for the rule is the connection to the real world.
08:58:47 <mreh> it's for referencial transparency
08:58:58 <byorgey> vrook: yes, that's one way of thinking about it.
08:59:02 <mreh> i think
08:59:13 <monochrom> depends on definition of "reason"
08:59:41 <hpc> monochrom: the reason behind the artifical rule
09:00:10 <monochrom> all other programming languages certainly show that it is unnecessary. the universe still hasn't disappeared in a puff of logic despite the presence of C.
09:00:33 <vrook> Monads are little universes created in Haskell, except IO which is the universe in which Haskell lives.
09:00:37 <mreh> if you were able to write seemingly pure functions that were able to evaluate IO, then you could get yourself into big trouble
09:00:58 <monochrom> you are philosophizing too much.
09:00:58 <mreh> hence unsafePerformIO being outlawed
09:01:27 <mreh> they would no longer be pure functions
09:01:34 <vrook> One can never philosophize too much.
09:01:55 <mreh> until you need money to buy bread
09:02:02 * jessopher has all of his arithmetic operations report results to an international database
09:02:48 <monochrom> haskell does not create little universes, just as it does not create flying spaghetti monsters
09:03:07 <jessopher> thats debatable
09:03:54 <aristid> it's a question of faith
09:04:24 <JoeyA> Haskell doesn't create little universes, it manipulates the *real* world.  http://hackage.haskell.org/package/acme-realworld
09:04:45 <jessopher> i was more refering to the spaghetti monsters
09:06:18 <monochrom> a programming language represents a tradeoff concerning restrictions. more restrictions buys you easier proofs of programming correctness. less restrictions buys you more freedom. that is all. there is no supernatural energy field involved.
09:06:49 <sam6> can I have some help on the error?
09:06:50 <sam6> http://hpaste.org/55074
09:08:04 <russellw> monochrom, that's an interesting viewpoint; it's curious that different people think so differently
09:08:36 <russellw> In that there are people who will accept restrictions for easier proofs of correctness; I would never do that. If that was the only tradeoff, I would always go for maximum freedom
09:09:07 <russellw> The tradeoff I accept is that restrictions buy features. For example, if you want precise garbage collection, you have to give up pointer arithmetic
09:09:20 <russellw> And if you want referential transparency, you have to give up side effects
09:09:22 <JoeyA> sam6: Looks like -> (g, Integer) should read -> (Integer, g)
09:09:25 <JoeyA> @type randomR
09:09:26 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
09:09:27 <rwbarton> the feature here is being able to reason about your program
09:09:28 <hpc> russellw: you also can sometimes buy ease of writing code
09:09:35 <sam6> oops, I just saw that...
09:09:37 <sam6> thanks
09:09:46 <hpc> russellw: with a sufficiently advanced type system, once you know what type you want your function to have, it almost writes itself
09:09:55 <hpc> (or does, in the most general cases)
09:10:04 <rwbarton> (because you already had to write it, at the type level :P)
09:10:45 <russellw> But isn't that about what's happening in your head? And couldn't it still happen in your head even if there wasn't a type checker actually implemented in the compiler? In other words,
09:11:02 <russellw> Having learned Haskell, couldn't you go ahead and use the lessons from it to program that way in scheme?
09:11:12 <monochrom> referential transparency is definitely an ease of proofs of correctness. "x :: Int" being different values at different times you look makes you work harder to mathematically or logically model the nature of x in proofs.
09:11:20 <hpc> russellw: sure; you won't have a compiler to hold your hand though
09:11:41 <jessopher> and as far as explaining certain idioms is concerned, if doing it in terms of a supernatural energy field yeilds a shorter more comprehensible explanation, then i can't see why not
09:11:41 <hpc> (i don't know scheme) or if you do, not as strict a compiler
09:11:53 <sam6> how do I convert an Integer to a Double?
09:12:01 <sam6> I want to do (Integer / Integer) => Double
09:12:04 <hpc> sam6: fromInteger
09:12:13 <russellw> monochrom, true, and I can actually understand why people want it for that. But the reason I want referential transparency is entirely different
09:12:14 <sam6> I see
09:12:25 <hpc> > (\x y -> fromInteger x / fromInteger y) 100 200
09:12:26 <lambdabot>   0.5
09:12:50 <vrook> Ideally I think types should come after something is coded. You don't really know the types until you've clearly defined the algorithm. When you don't know the algorithm -- when you need to discover it -- types are a hinderance.
09:13:04 <russellw> hpc, yeah. Scheme has no static types at all. Though you could write a type checker for scheme if you really wanted
09:13:06 <hpc> vrook: i would argue the opposite
09:13:24 <monochrom> precise garbage collection is partly ease of proofs and partly a productivity boost, yes.
09:13:27 <hpc> vrook: if you don't know the algorithm, you should at least know WHAT it is you want to calculate
09:13:53 <mreh> this sounds like denotational semantics
09:13:57 <hpc> you can't do ANY programming until you know that
09:14:09 <russellw> Though I have to say, coming from the other direction, I have seen people claim dynamically typed languages are especially good for exploratory programming, because they make your code more flexible, and I don't really get that
09:14:19 <vrook> hpc: knowing what you want to calculate does not give you the algorithm.
09:14:36 <monochrom> eliminating pointer arithmetic also increases ease of proofs by reducing aliasing a bit.
09:14:50 <byorgey> russellw: it's true if you're used to an inexpressive static type system that only gets in your way.
09:14:54 <russellw> To me, it's precisely when I'm making a lot of changes that a static type system is of most value, because it means when I change something in one place, the compiler lets me know what else I need to change - that is, in practice it makes my code more flexible
09:14:56 <sam6> how do I get a random number from 0 to 1
09:15:01 <hpc> russellw: they have a point, to some extent; it's easier to write something like print "foo = $foo" in perl and not worry about if it is a string or a number
09:15:15 <hpc> russellw: or if it's a pointer, it will still print something so you can see what it is
09:15:35 <JoeyA> randomRIO (0, 1) :: IO Double
09:15:36 <russellw> byorgey, oddly enough no - I'm actually working in C++ at the moment, and I find its static type system is useful in that regard
09:15:37 <hpc> sam6: use randomR - it takes a tuple that defines the range of things to produce
09:16:16 <JoeyA> However, randomRIO (0, 1) :: IO Int can return either 0 or 1.
09:16:41 <JoeyA> Usually, when you want to return a floating number from 0 to 1, you want to include 0 and exclude 0.  What does randomRIO (0, 1) :: IO Double do?
09:16:50 <russellw> hpc, yeah, but oddly enough, the language I found best in that regard is F# - I was very pleasantly surprised the way its built-in print function gives more useful output for arbitrary data structures than in any other language I ever used
09:16:51 <hpc> russellw: for my IRC bot, i have to do a bit of wiggling to make sure some things are numbers when they need to be, but otherwise it's nice to be able to read a string of input and treat it as a number and have it do something useful
09:16:54 <JoeyA> err, include 0 and exclude 1, i.e. [0, 1)
09:17:19 <sam6> hpc: do I have to specify a type?
09:17:31 <byorgey> russellw: fair enough. I certainly agree with you re: static type systems.
09:17:33 <sam6> hpc: how can I get a decimal between 0 and 1?
09:17:54 <hpc> russellw: in one particularly pathological case, i read in a string from a privmsg, use it as a regex, see if some defined variables match it, then print the ones that do
09:18:08 <hpc> russellw: or if they don't, i print the internal representation of the regex
09:18:13 <russellw> hpc, true, I can see that being handy
09:18:51 <hpc> (though, i only need to do that because my bot can reload modules at runtime)
09:19:07 <sam6> wait2026 how do I get a floating number from 0 to 1 again?
09:19:27 <hpc> :t randomR
09:19:28 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
09:19:36 <mreh> > getRandomR (0,1) :: IO Float
09:19:38 <lambdabot>   <IO Float>
09:19:58 <hpc> :t randomR (0, 1 :: Double)
09:19:59 <lambdabot> forall g. (RandomGen g) => g -> (Double, g)
09:20:00 <monochrom> or Double instead of Float, depending on your specification
09:20:31 <sam6> I see2026 it worked thankx
09:23:57 <dmwit> What's with the ^2026 in your messages?
09:24:07 <monochrom> PJIRC encoding
09:24:19 <dmwit> > text '\2026'
09:24:20 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
09:24:20 <lambdabot>         against inferred ty...
09:24:30 <hpc> > text "\2026"
09:24:31 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
09:24:43 <hpc> anyhoo, it's an ellipsis
09:24:54 <dmwit> k
09:25:01 <hpc> and thank god im not the only one; i thought it was irssi
09:25:18 <dmwit> So IRC doesn't have a specified encoding? (Or specifies ASCII or something stupid like that?)
09:25:44 <dmwit> Come to think of it, is IRC even specified?
09:25:57 <`Zerax`> There are some RFCs, but the encoding isn't specified.
09:25:57 <jessopher> it is... sort of
09:26:01 <hpc> dmwit: the protocol part needs to be ASCII
09:26:17 <parcs> > read "12e1000000000000" :: Integer
09:26:23 <lambdabot>   mueval: ExitFailure 1
09:26:23 <lambdabot>  mueval: Prelude.undefined
09:26:28 <hpc> or a charset with an ASCII-like mapping between 0 and 127
09:27:09 <hpc> otherwise the ":Spock!foo@bar PRIVMSG #haskell :blargleblargle" protocol stuff would be unreadable
09:27:11 <monochrom> IRC was specified with ASCII in mind, but allowed 8-bit instead of just 7-bit. anything other than ASCII would have to be firstly shoehorned into 8-bit and secondly a convention among channel participants.
09:27:14 * hackagebot xmobar 0.14 - A Minimalistic Text Based Status Bar  http://hackage.haskell.org/package/xmobar-0.14 (JoseAntonioOrtegaRuiz)
09:27:38 <dmwit> Cool, that clears things up.
09:27:47 <hpc> and IRC is specified
09:28:18 <hpc> imo they are some of the most readable RFCs out there
09:28:29 <monochrom> so basically most people in #haskell have agreed to utf-8 or too lazy to object.
09:29:05 <donri> one encoding to rule them all
09:30:02 <hpc> one monad to rule them all and in the darkness (>>=) them
09:30:16 <sam6> I have a function that gives an Integer
09:30:18 <byorgey> withDarkness $ \d -> mapM_ (>>= d) them
09:30:26 <JoeyA> One IRC channel I visit has a bot that kickbans if you post invalid UTF-8.
09:30:29 <sam6> how do I call the function 50 times to make alist of Integer?
09:30:41 <JoeyA> Sounds harsh, but I think it's a good idea.
09:30:52 <sam6> oh wait2026 I can recurse
09:31:05 <byorgey> sam6: replicate? map?
09:31:27 <sam6> oh2026 let me try
09:31:32 <donri> hpc:  and the `return` of the king
09:31:41 <byorgey> sam6: what is this function's type?
09:32:19 <Chaze> argh, i hate how permutation/combination stuff keeps messing with my head when i turned away from it for too long..
09:32:29 <monochrom> but PJIRC is peculiar. it is the only client that invents a new encoding, thus becoming the only software that decodes it. here is the encoding: to send U+2026 (so it's \x2026 not \2026), you send "\x1E" and then "2026".
09:32:46 <Chaze> is there a word for this: foo "AB" = ["","A","B","AB","BA"]
09:33:18 <Chaze> kinda like permutation on "inits" of a list, i think
09:33:36 <sam6> http://hpaste.org/55075
09:33:46 <sam6> I'm not sure the best way to make a list of random numbers
09:33:50 <sam6> from what I have so far
09:34:35 <carpi> Does the name 'Ix' for module Ix stand for 'Index' or 'Indexed'?
09:35:21 <monochrom> why do you want to know?
09:35:25 <byorgey> sam6: you're going to have to return a new generator from getGaussRand
09:36:30 <Chaze> yeah, how would you call foo (if it has a name)?
09:36:35 <Chaze> > let foo = (concatMap inits) . permutations
09:36:37 <lambdabot>   not an expression: `let foo = (concatMap inits) . permutations'
09:36:38 <carpi> monochrom: Just curious..because I was going through the docs at haskell.org about array.. and it struck me that the name Ix has nothing to do with arrays unless it stands for something like 'Index' or 'Indexed'
09:36:46 <vrook>  infinityOf x = x : infinityOf x -- Is this function in prelude or elsewhere?
09:36:58 <sam6> I see.. let me make some changes
09:37:30 <monochrom> an Int can be used as an array index. so we add Int to Ix
09:38:39 <Chaze> vrook: repeat?
09:38:52 <carpi> ah aoky.. makes sense : ). but if thats the case, then is it possible that arrays in Ix have a fixed maximum size?
09:38:55 <monochrom> > repeat 'x'
09:38:57 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
09:39:05 <vrook> thanks
09:39:12 <dmos> does anyone have advice/pointers for left factoring in attoparsec (besides the obvious and tedious choice)?
09:39:25 <monochrom> when you create an array, you specify a size, and the array stays that size forever
09:40:28 <monochrom> I don't know what is the maximum allowed size.
09:41:28 <carpi> monochrom: if index type of array is an Int then it must be the maximum a value of type Int can hold. but im not sure either
09:41:29 <hpc> monochrom: presumably the size of your RAM
09:41:32 <applicative_> > subsequences "AB"
09:41:34 <lambdabot>   ["","A","B","AB"]
09:41:39 <monochrom> but Integer is also Ix
09:42:18 <monochrom> alternatively but equivalently, (Int,Int) is also Ix, and (Int,Int,Int), etc.
09:42:27 <ClaudiusMaximus> :t rangeSize
09:42:29 <lambdabot> forall a. (Ix a) => (a, a) -> Int
09:42:53 <monochrom> ah, that probably nails it.
09:43:13 <ClaudiusMaximus> > rangeSize (minBound :: Int, maxBound)
09:43:15 <lambdabot>   0
09:43:16 <kulakowski> > concatMap permutations $ inits "AB"
09:43:18 <lambdabot>   ["","A","AB","BA"]
09:45:08 <JoeyA> > permutations=<<inits"AB" -- if you're code-golfing
09:45:09 <lambdabot>   ["","A","AB","BA"]
09:45:14 <TomMD_> Is there a zero-copy function :: ByteString -> Repa.Array sh WordX
09:45:16 <TomMD_> ?
09:46:11 <sam6> Please help http://hpaste.org/55076
09:47:55 <vrook> sam6: have you tried Control.Monad.Random ?
09:48:15 <vrook> I had a similar issue which was helped by the random monad
09:49:52 <sam6> hm2026 what does random monad do?
09:49:59 <vrook> sam6: here's my example: https://gist.github.com/1455828
09:50:39 <vrook> sam6: random monad keeps track of successive generators for you
09:52:35 <sam6> reading from it2026 I think that might exactly be what I want
09:53:17 <cheater> kmc: do you have a link for those visual cortex resonance goggles, i know someone working on something similar and wanted to link them up
10:08:22 <lukish> Trying to ask last time. http://paste.lisp.org/display/126400 what's wrong?
10:12:15 * hackagebot happstack-server 6.4.4 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.4.4 (JeremyShaw)
10:12:56 <sam5> Hi
10:13:00 <vrook> evalRandIO (getRandomR ((1 :: Int), 10)) >>= print  -- when I remove :: Int, there is an error from ambiguity between Num and Random. I don't understand why Random is an instance of Int, Integer, etc. And even if there is a good reason for that, I don't understand why I have to supply the type -- why can't something be both a Num and a Random?
10:13:00 <sam5> so...
10:13:14 <sam5> can I have a function that holds a list of Integers
10:13:27 <sam5> and everytime I call the function it return the first element in the list
10:13:43 <sam5> and removes the first element from the list that it is holding?
10:13:58 <sam5> basically2026 if myFunc holds [1, 2, 3, 4]
10:14:09 <sam5> and if I call myFunc, it returns 1
10:14:15 <sam5> if I call myFunc again, it return 2
10:14:19 <sam5> is that possible in haskell?
10:14:26 <sam5> or to achieve something similar?
10:14:42 <cheater> reader monad
10:14:50 <cheater> state monad
10:14:52 <cheater> etc
10:15:18 <_oz> cheater: can't do that with reader actually.
10:15:42 <cheater> _oz: but you can with reader+state
10:15:55 <_oz> why?
10:15:59 <_oz> why not just state?
10:16:15 <cheater> because he still needs access to the list, and passing it around is boring.
10:16:19 <cheater> alternatively he can use the list monad
10:16:26 <cheater> and instead of myFunc just use <-
10:16:55 <_oz> anyway, sam5, functions in haskell return the same value (with same arguments) every time they are called.
10:17:10 <_oz> if you want such a function, you'll probably need a state monad
10:17:22 <donri> is it possible? yes. is it recommended? no :)
10:17:29 <sam5> I see...
10:17:42 <_oz> there might be easier ways to solve what you are trying to do, if you tell us what you are actually trying to do :)
10:17:48 <sam5> I'm trying to read up on statemonad2026 but what's the difference between reader and state monad?
10:18:14 <donri> global state like that is bad design anyway, regardless of haskell
10:18:40 <sam5> what I am trying to do is...
10:18:59 <sam5> to precompute a list of Ints that is expensive
10:19:11 <_oz> the difference between state and reader monads is the same  difference between (r -> a) and (s -> (a,s))
10:19:21 <sam5> and then run my function with that list
10:19:41 <sam5> oh I see2026 I guess I'll have to read up on that...
10:20:11 <_oz> sam5: you can define the list as a top level definition
10:20:18 <_oz> and refer to it as many times as you want
10:21:14 <sam5> oh.. how do you make a top level deifinition?
10:21:29 <_oz> myList = [1,2,3]
10:22:21 <sam5> oh.. yes2026 but myList might get changed2026 so that's the problem.
10:22:28 <sam5> here is actually what I am trying to do
10:22:36 <sam5> http://hpaste.org/55076
10:22:51 <pidhash> hey someone could explain me how indent works in haskell
10:23:28 <pidhash> seems a little different than ruby or pyton
10:24:00 <_oz> sam5: do you know how many random numbers myFunction will need beforehand though?
10:24:28 <applicative_> pidhash: if you have an example of something not working maybe we can help correct it?
10:24:32 <sam5> perhaps about 30~40
10:24:51 <sam5> my plan was2026 to have a list of random numbers generated and then when it runs out, then compute it again
10:25:01 <_oz> you can always say callMyFunc = let randoms = ... in myFunction randoms
10:25:39 <_oz> you can call deepseq while defining randoms, so it'll get evaluated before it's passed to myFunction
10:28:00 <sam5> yes2026 I think that can be a possibility2026 but what I wanted was to have a function that contains a list of random numbers internally and then return one number at a time
10:28:30 <sam5> when it runs out, then it internally calculated another 30~40 list of random Integers without the user not noticing it
10:28:46 <sam5> without the user noticing it*
10:29:38 <_oz> if you really want that, use the state monad while defining myFunction.
10:29:56 <_oz> what if the type of myFunction?
10:30:01 <_oz> what is*
10:31:11 <sam5> there are multiple of them actually2026
10:31:47 <sam5> I am doing this in a cryptographic research lab
10:32:01 <sam5> and we want to use this random generation scheme everytime we need a random number
10:32:20 <sam5> so there isn't one function that will need this...
10:32:23 <pidhash> applicative_: http://www.nopaste.pl/17a0
10:32:31 <_oz> are you familiar with monads then?
10:32:41 <sam5> that's why I kinda wanted it to be similar to global variable
10:32:59 <shurikas> how to escape " in strings ? I need some regexp
10:33:13 <shurikas> and find particular piece of text inside an html doc
10:33:22 <shurikas> please don't suggest tagsoup or anything else
10:33:22 <sam5> I know very basics of monads
10:33:30 <sam5> but I am not familiar with state monads
10:33:38 <shurikas> unless it's easier than regexp
10:33:42 <cheater> they're like federal monads
10:34:08 <pidhash> applicative_: http://www.nopaste.pl/17a1 (why this don't works ?)
10:34:22 <pidhash> they seems to be the same
10:34:38 <_oz> sam5: I'd use a state monad given your needs. so I suggest you try to understand how it works, and ask questions about that if you need to.
10:35:58 <sam5> I see2026 thanks for so much help!
10:41:48 <shurikas> "<a href=\"asdf\"></a>" =~~ "\"[^\"]*\"" :: Maybe String
10:41:58 <shurikas> this prints the actual \"asdf\"
10:42:01 <shurikas> instead of "asdf"
10:42:21 <shurikas> even though it escapes " in code, but it still uses backslash with "
10:42:43 <shurikas> can I expect it to work with a real html and match <a href="asdf"></a> ?
10:42:44 <rwbarton> maybe in http://www.nopaste.pl/17a0 the "myFunction = id" is treated as a top-level declaration?
10:42:56 * rwbarton can't read poorly indented haskell
10:43:53 <Proge> shurikas
10:43:55 <rwbarton> and in http://www.nopaste.pl/17a1 there is an error on line 10 because it's not treated as part of the where block
10:43:59 <Proge> i've had this problem
10:44:11 <shurikas> how did you solve it?
10:44:15 <Proge> what language you using?
10:44:30 <shurikas> PCRE for regex
10:44:33 <shurikas> Text.Regex.PCRE
10:44:58 <ciaranm> what's the currently fashionable way of handling input with parsec where whitespace between tokens should always be ignored?
10:45:05 <Proge> my prob was having to triple or quad escape \
10:45:14 <Proge> but that makes for a messy regex
10:45:23 <shurikas> it doesn't matter as long as it works
10:45:24 <Proge> in c# you can switch strings so "" means "
10:45:28 <Proge> and no need to escape
10:45:36 <Proge> can you do that in PCRE?
10:46:09 <shurikas> PCRE is regex library where regex is written in perl style
10:46:22 <rwbarton> shurikas: you are probably just print-ing the string instead of putStr-ing it
10:46:23 <shurikas> and this problem is with Haskell, not regex
10:46:24 <Proge> which part of the link are you trying to extraxt?
10:46:39 <Proge> ok
10:46:47 <shurikas> rwbarton, what's the difference?
10:46:53 <shurikas> afaik print = putStrLn $ show
10:46:59 <rwbarton> yes, that is the difference
10:47:08 <Cale> shurikas: Applying show to a string will quote it
10:47:08 <shurikas> I am using putStrLn
10:47:15 <Cale> > show "hello"
10:47:16 <lambdabot>   "\"hello\""
10:47:20 <Cale> > show (show "hello")
10:47:21 <lambdabot>   "\"\\\"hello\\\"\""
10:47:27 <Cale> > show (show (show "hello"))
10:47:28 <lambdabot>   "\"\\\"\\\\\\\"hello\\\\\\\"\\\"\""
10:47:29 <shurikas> hmm, ok
10:47:50 <shurikas> > show "\""
10:47:52 <lambdabot>   "\"\\\"\""
10:48:03 <shurikas> > print "\""
10:48:04 <lambdabot>   <IO ()>
10:48:07 <rwbarton> lambdabot is print-ing the result for an extra layer of quotedness
10:48:08 <shurikas> great.
10:48:18 <rwbarton> or show-ing it perhaps
10:48:35 <shurikas> well, it prints "\"" in ghci
10:48:37 <shurikas> instead of """
10:48:43 <Cale> Of course
10:48:53 <Cale> because """ is a syntax error
10:48:57 <shurikas> why don't it escape as in every other language?
10:49:05 <rwbarton> it does?
10:49:05 <Cale> "every other language"?
10:49:08 <Cale> It does
10:49:09 <shurikas> Cale, that's why I am using escape characters.
10:49:14 <shurikas> \
10:49:39 <shurikas> so let's say I enter "\"" in my code. How can I print it as """ ?
10:49:40 <rwbarton> the string containing a single character which is a double quote, i.e., ['"'], is called "\""
10:49:55 <monochrom> putChar and putStrLn will give you "
10:50:03 <shurikas> damn, it does o.O
10:50:03 <Cale> shurikas: by printing a double quote explicitly before and after it?
10:50:06 <rwbarton> why would you ever want that? but:  putStr $ "\"" ++ mystring ++ "\""
10:50:29 <shurikas> then why I get normal string from http request?
10:50:36 <shurikas> which contains only " instead of \" everywhere
10:50:42 <rwbarton> ...
10:50:59 <Cale> shurikas: What?
10:51:07 <rwbarton> the string "\"" does not "contain" a backslash
10:51:10 <monochrom> http does not do that kind of escaping
10:51:24 <shurikas> rwbarton, that's great.
10:51:35 <Cale> "\"" = ['"'] = '"' : []
10:51:48 <shurikas> hmm
10:51:52 <monochrom> the notation "\"" is for string literals in haskell source code only
10:51:57 <shurikas> so you say it's ", but it's printed as \" ?
10:52:03 <rwbarton> no
10:52:08 <rwbarton> well, maybe
10:52:31 <rwbarton> print ['"'] will output the four characters "\"" (plus a newline)
10:52:36 <Cale> shurikas: It's written as \" when you're trying to not end the string that you're writing :P
10:53:18 <shurikas> rwbarton, I get input <a href="asdf"></a>. Will regex "\"[^\"]*\"" match asdf ?
10:53:27 <rwbarton> yes
10:53:31 <shurikas> ok!
10:53:37 <shurikas> thank you very much
10:53:44 <Cale> shurikas: Don't use regex to parse HTML
10:53:45 <bertolo> hi guys
10:53:55 <shurikas> Cale, why not?
10:54:01 <monochrom> if that regex is a string literal in haskell source code
10:54:05 <bertolo> how can i delete a file from haskell pastebin?
10:54:09 <Cale> Because Zalgo
10:54:31 <Cale> http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454
10:54:44 <monochrom> if you use getLine to ask the user to enter the regex, the user enters "[^"]*"
10:55:05 <Cale> bertolo: what?
10:55:17 <bertolo> i need to delete a file on haskell pastebin
10:55:18 <bertolo> but i cant
10:55:24 <monochrom> to delete a file from haskell pastebin, hack into it and delete
10:55:29 <bertolo> i press Report / Delete
10:55:37 <bertolo> and it only allows to report
10:55:55 <shurikas> Cale, I just want to extract an exact string from html ;) for learning purpose!
10:56:11 <shurikas> I think I don't need to use an html parser for that
10:56:15 <carpi> coudl someone please tell me what "failed to load interface for " mean?
10:56:26 <Cale> shurikas: You could at least use TagSoup
10:56:35 <shurikas> :)
10:56:36 <monochrom> "I just want" "all I want" is a statistical indicator of disasters
10:56:42 <Cale> http://hackage.haskell.org/package/tagsoup
10:56:53 <shurikas> right...
10:57:06 <shurikas> I used tagsoup in android, in c#. Time to use it in haskell
10:57:23 <bertolo> noone can help me with that?
10:57:25 <carpi> i think i got it.. an object file that ghc is looking for is unavailable.. i think thats what it mean )
10:57:42 <Cale> bertolo: None of us are in control of exactly what's on that pastebin
10:57:55 <bertolo> so whenever u post there
10:57:58 <bertolo> u cant delete it?
10:58:02 <Cale> Pretty much
10:58:06 <bertolo> if my teacher
10:58:14 <bertolo> remember to write one single variable name on google
10:58:16 <monochrom> then too bad
10:58:16 <bertolo> i will be expelled
10:58:18 <bertolo> from college
10:58:30 <bertolo> for sharing my code
10:58:40 <bertolo> omfg
10:58:48 <monochrom> well, congrats
11:00:40 <cheater> in order to get "yadda" from this document: http://pastebin.com/4u4KRKZ5     would the right xpath be /bar/baz/@foo     or ./baz/@foo ?
11:00:40 <mauke> The paste 4u4KRKZ5 has been copied to http://p3rl.org/8937MDON
11:04:48 <kmc> when you share things with The Internet, they stay shared
11:05:44 <kmc> bertolo, and now you're spamming the pastebin
11:05:48 <kmc> quite ineffectively i might add
11:06:06 <bertolo> kmc
11:06:07 <bertolo> i had to
11:06:08 <bertolo> sorry
11:06:10 <bertolo> i msut
11:06:12 <bertolo> in order
11:06:15 <bertolo> to not be expelled
11:06:27 <kmc> you realize all the pastes since forever are available
11:06:27 <kmc> http://hpaste.org/browse/page/100
11:06:50 <bertolo> still
11:06:56 <bertolo> i just want to mess
11:06:57 <kmc> @tell chrisdone this bertolo clown is spamming hpaste, maybe you can block their IP or something
11:06:58 <lambdabot> Consider it noted.
11:06:59 <bertolo> with google searches
11:07:13 <kmc> you know that you're allowed to put more than three words on the same line of IRC, right
11:07:14 <bertolo> i wont spamm much more
11:07:15 * hackagebot noodle 0.0.19 - the noodle programming language  http://hackage.haskell.org/package/noodle-0.0.19 (JesseRudolph)
11:08:15 <`Zerax`> 'much', heh
11:09:00 <kmc> you could at least write a bot to spam it
11:09:07 <kmc> then you would learn something in addition to annoying others
11:09:09 <nh2> is it possible in a cabal executable to include all the build-depends of the library section? In my current setup, I have to specify all build-depends in every executable section
11:11:09 <kmc> bertolo, cut it the fuck out
11:11:19 <bertolo> sorry
11:11:20 <bertolo> :(
11:11:23 <bertolo> im fucking sorry
11:11:26 <bertolo> must do it
11:11:28 <bertolo> all night long
11:11:30 <kmc> fucking cut it out
11:11:42 <kmc> cut out it fucking
11:11:49 <kmc> fucking it out cut
11:12:40 <russellw> bertolo, at the moment nobody cares if you shared code, but if you keep this up all night long, there's a nonzero risk of provoking people enough that somebody will take the trouble to track down where you go to college and bring this to the attention of your professor
11:12:47 <russellw> So I would suggest quitting while you're behind
11:13:06 <bertolo> true
11:13:10 <bertolo> il send email to him
11:13:12 <bertolo> first
11:13:15 <bertolo> and explain my solution
11:13:18 <bertolo> and keep spamm
11:13:44 <kmc> i remember when i would join #haskell and immediately learn something cool about Haskell and CS
11:13:55 <kmc> now i just get some fresh stupidity like this
11:14:10 <bertolo> stupidity
11:14:15 <bertolo> is not being able to delete
11:14:19 <bertolo> the file i posted
11:14:23 <bertolo> that is stupidituy
11:14:33 <russellw> And you think he's going to believe you over an e-mail with attached URL and IRC log? At this stage I'm tempted to take the trouble myself just to discourage somebody this stupid from polluting the pool of programmers
11:14:34 <kmc> you seem to have a fundamental misunderstanding about the internet
11:14:34 <jessopher> no i think thats a lack of access
11:14:35 <cheater> what is your major malfunction bertolo
11:14:47 <bertolo> i stopped
11:14:59 <bertolo> my major malfunction is not being able to delete the code
11:15:00 <bertolo> i shared
11:15:02 <bertolo> on pastebin
11:15:08 <bertolo> to solve and useless doubt
11:15:11 <bertolo> an*
11:15:29 <bertolo> and now i can be expelled of college for sharing it
11:15:43 <cheater> why don't you just contact the pastebin maintainers and ask them to remove it
11:15:47 <cheater> be nice and polite
11:15:49 <cheater> and they just might.
11:17:30 <bertolo> i cant contact them
11:17:36 <bertolo> because i dont know how
11:17:41 <bertolo> i wish i coudl
11:17:45 <bertolo> i would donate to get it deleted
11:17:46 <bertolo> lol
11:17:53 <bertolo> the major problem
11:18:01 <bertolo> of alskdnmaf
11:18:03 <bertolo> fuck my lfie
11:18:59 <`Zerax`> I'm confused, you don't want your professor to find the code, so you're spamming the code you're about to submit so it can be easily found, and you can be easily identified by the IP address you submitted it with? Or am I missing something.
11:20:06 <plat0> How come there are no ops here?  This is really not on topic.
11:20:59 <hpaste> bertolonooob annotated “bertolonooob” with “bertolonooob (annotation)” at http://hpaste.org/55061#a55091
11:21:11 <bertolo> lol
11:21:23 <alistra> bertolonoob
11:21:23 <donri> bertolo: so click report/delete and explain in the comment field why you need it removed?
11:21:31 <bertolo> i did
11:21:33 <bertolo> several times
11:21:46 <donri> bertolo: it must first be reviewed by the admin
11:21:51 <bertolo> hes not here
11:21:55 <bertolo> i mean
11:21:58 <bertolo> i asked since yesterday
11:22:01 <donri> he will read it at some point?
11:22:03 <bertolo> and still nothing done
11:22:15 <bertolo> at any time my teacher can remember of searching some keyword on google
11:22:15 <donri> i'll give you his email if you stop spamming :P
11:22:17 <bertolo> and im done
11:22:25 <parcs> nice code, can i use it?
11:22:30 <bertolo> i dont know if i should email my teacher right away
11:22:37 <bertolo> or just wait for the admin
11:22:41 <bertolo> sure use it
11:22:43 <hpaste> wereHamster pasted “arc” at http://hpaste.org/55092
11:22:54 <thierrygar> paying attention to noise just prolongs the noise
11:23:03 <wereHamster> what is haskell complain there about?
11:23:23 * Philippa would, if unable to remove the code, mail the teacher apologetically explaining what'd gone wrong before the deadline so as to make it clear it wasn't a deliberate attempt to cheat
11:23:29 <bertolo> a small issue with [IO()]
11:23:40 <bertolo> that was solved right away
11:23:59 <bertolo> if he spots me
11:24:08 <parcs> wereHamster: first of all, don't use data type contexts. second of all, add the (Eq a, Ord a) constraint to the type signature of newARC
11:24:10 <Saizan> bertolo: we can't help you, sorry, but this is not the place to vent your problems.
11:24:21 <bertolo> the whole discipline can be erased from everyone
11:24:25 <wereHamster> parcs: what is a 'data type context'?
11:24:27 <rwbarton> wereHamster: data (Eq a, Ord a) => ARC a = ARC ... means that the ARC data constructor gets type (Eq a, Ord a) => ... -> ARC a
11:24:32 <bertolo> Saizan: i understand
11:24:34 <bertolo> thanks all anyway
11:24:44 <parcs> wereHamster: data (Eq a, Ord a) => ARC a = ...
11:24:47 <bertolo> im going to Ping pastebin with 300 computers now :(
11:24:52 <parcs> (Eq a, Ord a) is a data type context
11:25:05 <wereHamster> parcs: I thought having the constraints in the data woudl be enough, can't haskell infer the constraints whenever I use ARC a ?
11:25:19 <rwbarton> it can
11:25:24 <jessopher> i dont think ping and 300 computers is gonna do anything substantial, but if it makes you feel better
11:25:30 <rwbarton> but! you gave a type signature newARC :: ARC a
11:25:46 <rwbarton> and you are not allowed to give type signatures which are wrong
11:26:02 <parcs> wereHamster: what rwbarton said. also, Ord a implies Eq a
11:26:07 <wereHamster> ah, I think I'm starting to understand.
11:26:11 <parcs> so Eq a, Ord a is redundant
11:26:50 <rwbarton> actually what I mean is it can infer the constraints when you use the *data* constructor ARC
11:27:00 <wereHamster> so, what I'm trying to do is wrap a list (actually a couple of lists) in my own data type. The elements stored in the list shold be Ord/Eq. what would be the proper way?
11:28:20 <rwbarton> you can add the context Ord a to newARC, that will express your intent
11:28:42 <wereHamster> but then I'd have to add the contxt to every function that uses ARC a, wouldn't I?
11:28:48 <jessopher> can you have constraints inside type aliases? type ARC a = (Ord a) => MARC a
11:28:48 <rwbarton> yes
11:29:21 <wereHamster> the thing with haskell is, whenever I try to do somethign even really simple, those kinds of problems^Wchallenges discourage me :-/
11:29:53 <rwbarton> normally what people do is just leave off the type context from the data declaration and only put a context on those functions which require one
11:30:01 <parcs> wereHamster: what is the problem?
11:30:20 <wereHamster> rwbarton: yep, but then I got other warnings when I tried to use e `elem` (list ac)
11:30:41 <wereHamster> parcs: the error from the pastie :)
11:31:07 <parcs> wereHamster: rwbarton solved that problem quite simply: add the Ord a constraint to the type of newARC
11:32:03 <parcs> this is why data type contexts are bad, they don't do what you think they do
11:32:08 <parcs> they are actually pretty useless
11:32:45 <wereHamster> sure, I appreaciate the help. What I mean is, whenever I hit even the slightest problem, I have no clue what to do and have to ask either here or other friends
11:33:45 <mm_freak_> is there a library for web routes that is not bound to a monad?
11:33:58 <mm_freak_> web-routes-boomerang is bound to a monad
11:34:11 <dropdrive> What typeclass (?) do I use for a type that is ordered and every value has a unique "next larger" and "next smaller"?
11:34:12 <mm_freak_> and web-routes-quasi is too TH-heavy
11:34:27 <mm_freak_> dropdrive: Enum
11:34:30 <donri> there's web-routes-regular which i don't know how it works
11:34:41 <donri> http://tutorialpedia.org/tutorials/Happstack+type+safe+URLs.html
11:34:41 <mm_freak_> donri: thanks, i'll try
11:35:12 <donri> mm_freak_: why do you want a "monad free" one?
11:35:18 <dropdrive> mm_freak_: Thanks.
11:36:01 <mm_freak_> donri: because handling routes is essentially a pure process…  i'd like not to "pollute" my transformer stack
11:36:13 <donri> monads are not "impure"
11:36:18 <hpaste> wereHamster pasted “arc” at http://hpaste.org/55093
11:36:43 <mm_freak_> donri: "pure" in the sense of effect-free
11:36:48 <wereHamster> is there a way to express the constraint globally? the (Ord a) should apply to any function that uses ARC a
11:37:02 <mm_freak_> donri: where "effect" is not meant to be impure
11:37:42 <mm_freak_> wereHamster: by using a type class for the operations
11:37:44 <vrook> Trying to combine ST and Random monads. Error at third line from bottom. https://gist.github.com/1456131
11:37:53 <mm_freak_> wereHamster: then you can say:  instance Ord a => MyClass …
11:39:55 <parcs> wereHamster: yes, using a language extension called GADTs
11:40:10 <donri> mm_freak_: not sure what you're on about though; boomerang is just a parser combinator of sorts
11:40:22 <donri> it makes sense for parsing PATH_INFO
11:41:53 <rwbarton> vrook: you want randTest :: (RandomGen g) => RandT g (ST s [Int]), I think? And certainly you don't want to use Control.Monad.State at all
11:42:59 <mm_freak_> donri: what is this RouteT about?
11:43:14 <donri> mm_freak_: that's part of web-routes core
11:43:24 <rwbarton> ST s (RandT g m [Int]) is an ST computation whose result is a computation in a RandT-transformed mystery monad m whose result in turn is a list of Ints
11:43:29 <mm_freak_> donri: yes, but why a monad?
11:43:39 <donri> mm_freak_: it's useful because it lets you build URLs from your sitemap
11:43:52 <mm_freak_> or put differently, do i need to thread this monad through all of my code?
11:44:29 <mm_freak_> or can i runRouteT at a certain place and not have it in my general transformer stack?
11:44:29 <donri> i've only used it with happstack, where you can simply add it in the type for handlers
11:44:37 <mm_freak_> hmm, ok
11:44:46 <mm_freak_> i'll take a look at it
11:45:00 <donri> http://happstack.com/docs/crashcourse/WebRoutes.html might help, regardless of if you're using happstack or not
11:45:48 <donri> i suspect for happstack the RouteT is handled by the implSite function
11:46:06 <mm_freak_> apparently RouteT is just ReaderT with some function
11:46:41 <vrook> rwbarton: thanks, that looks closer. RandT needs another argument, but randTest :: (RandomGen g) => RandT g (ST s [Int]) [Int] doesn't work.  (Also, I added Control.Monad.State for lift.)
11:46:57 <rwbarton> oh oops
11:47:01 <rwbarton> RandT g (ST s) [Int]
11:47:04 <donri> mm_freak_: it's needed for showURL i think http://happstack.com/docs/crashcourse/WebRoutes.html#web-routes-type-families
11:48:18 <donri> and you'll want to use that to make sure web-routes is two-ways
11:49:06 <vrook> rwbarton: thanks, almost there! randTest works when I change the last line to lift $ getElems arr
11:49:33 <vrook> now I need to figure out what main looks like
11:49:39 <alistra> @hoogle Monad m => m()
11:49:40 <lambdabot> Data.Foldable sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
11:49:40 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
11:49:40 <lambdabot> Control.Monad sequence_ :: Monad m => [m a] -> m ()
11:49:57 <jessopher> if i have a package that contains executables that depend on the package itself, will it prefer a previous version over the current version if a previous version is installed?
11:50:00 <alistra> @instances State
11:50:01 <lambdabot> Couldn't find class `State'. Try @instances-importing
11:50:08 <donri> mm_freak_: read the paragraph and list from "The other thing you will notice is the RouteT monad transformer in the type signature."
11:50:18 <alistra> @src State
11:50:19 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
11:50:50 <donri> mm_freak_: so RouteT is optional but useful
11:54:00 <mm_freak_> donri: yeah, just read the page you linked
11:54:15 <mm_freak_> i think, i will give web-routes-th a go, because it seems to get along with only little TH usage
11:54:46 <donri> it's what i use :)
11:55:21 <dropdrive> Is there a data type like Eq a => [(a, b)] where the first entries are guaranteed to be unique?
11:56:25 <jessopher> Data.Map is something like that
12:04:51 <SoleSoul> Hi. How can I round a floating point decimal number to 2 digits after the . ? The round should be to the closest number, up or down.
12:05:28 <kmc> :t (/100) . fromIntegral . round . (* 100)
12:05:30 <lambdabot> forall a a1. (Fractional a, RealFrac a1) => a1 -> a
12:05:39 <mm_freak_> donri: ok, web-routes-th is very straightforward, but also not very nice
12:05:48 <mm_freak_> you can't make your own URLs with it
12:05:59 <donri> mm_freak_: yea that's what boomerang is for
12:06:12 <mm_freak_> and boomerang is very verbose compared to web-routes-quasi =/
12:06:23 <donri> -quasi doesn't use web-routes anymore
12:06:37 <mm_freak_> actually web-routes-quasi is great, but i have no idea at all how to use the TH part of it
12:06:50 <donri> i like the "verbosity", what it really means is that it's reusable/combinable etc
12:06:52 <mm_freak_> haddock stops being useful, as soon as it comes to TH
12:07:11 <mm_freak_> yeah, that's true
12:07:16 <donri> see yesod docs for -quasi
12:07:16 <mm_freak_> ok, i'll look into -boomerang
12:07:56 <mm_freak_> yesod docs don't help, because i'm not asking how to use the template language
12:08:12 <donri> but -quasi is the yesod routing system
12:08:24 <donri> http://www.yesodweb.com/book/routing-and-handlers
12:08:27 <SoleSoul> kmc: cool :) thanks!
12:08:58 <mm_freak_> donri: i mean, there is no documentation at all how to incorporate the TH features into a non-yesod project
12:09:00 <kmc> SoleSoul, if you are just printing the number, you might use printf instead
12:09:05 <vrook> What is the lift-to-transformer operation that takes me from Foo to FooT?
12:09:14 <kmc> vrook, none
12:09:40 <mm_freak_> donri: and it's not anywhere near straightforward
12:09:46 <donri> agreed
12:10:01 <SoleSoul> kmc: I need the value so your solution is what I needed.
12:10:30 <vrook> I have something of type RandT g (ST s) [Int] -- how do I call evalRandIO to get the party started?
12:10:50 <fryguybob> do g <- getStdGen ; print $ runST $ evalRandT randTest g -- vrook
12:10:52 <vrook> I need a runST and a evalRandIO somewhere
12:11:04 <kmc> vrook, evalRandT instead?
12:11:21 <mm_freak_> vrook: the runRandT function (or whatever it's called in your library) will give you an ST s [Int]
12:11:35 <mm_freak_> you can then pass that one to runST
12:11:45 <kmc> or to stToIO
12:11:50 <mm_freak_> so the pattern is:  runST (evalRandT …)
12:17:15 * hackagebot plugins-auto 0.0.2 - Automatic recompilation and reloading of haskell modules.  http://hackage.haskell.org/package/plugins-auto-0.0.2 (FacundoDominguez)
12:18:03 <vrook> thanks to all. this almost works -- puts "100" in a random spot, but it chooses the random number at compile time. https://gist.github.com/1456300
12:18:23 <vrook> when I recompile, I get a different spot. And it stays the same for subsequent calls to main
12:18:44 <kmc> that seems quite unlikely
12:18:55 <kmc> are you waiting more than a second between runs
12:19:12 <vrook> yes. Actually it's a ghci-only thing.
12:19:21 <vrook> It works fine when I compile with ghc.
12:19:32 <kmc> i think you want newStdGen not getStdGen
12:19:57 <vrook> yes that's it, thanks
12:20:02 * fryguybob apologizes for getStdGen.
12:20:28 <vrook> but still, isn't it strange that ghc and ghci have different behavior?
12:20:53 <SoleSoul> I there a way to print the following string in ghci?   {"word"}   The problem is I couldn't print the " without printing \" and I need the " alone.
12:20:54 <kmc> if you quit and re-start ghci, which behavior do you get?
12:21:04 <kmc> SoleSoul, putStr
12:21:08 <rwbarton> if you renamed main to main' and wrote "main = main' >> main' >> main'", then you would also get the same random number 3 times
12:21:14 <kmc> putStr "{\"word\"}"
12:21:26 <SoleSoul> kmc: Thanks again :)
12:21:30 <SoleSoul> perfect
12:21:36 <fryguybob> kmc: btw, I used your slides the other day, thanks for sharing them.
12:21:44 <kmc> vrook, getStdGen and newStdGen are accessing a piece of implicit global state
12:21:54 <vrook> yeah I'm comparing apples to oranges -- re-run program vs call same function in same program
12:22:01 <kmc> starting ghci initializes the haskell runtime only once
12:22:05 <vrook> yep
12:22:10 <kmc> even if you invoke the main action more than once
12:22:15 <kmc> (main isn't a function, by the way)
12:22:18 <kmc> fryguybob, cool!  which ones?
12:22:35 <fryguybob>  "Why learn Haskell?"
12:22:38 <kmc> cool
12:22:43 <kmc> in what context did you use them
12:22:57 <fryguybob> I was giving a talk about STM and needed some background and examples.
12:23:11 <ion> @type main
12:23:12 <lambdabot> [String] -> [String] -> IO Int
12:23:18 <kmc> are your slides online?
12:23:40 <fryguybob> I didn't make any slides just shuttled around yours as questions came up.
12:23:45 <kmc> cool
12:24:11 <ion> You stole his intellectual property. Now he’ll never get it back.
12:24:30 <kmc> as it happens i am working on some slides right now, but there's no haskell in them
12:24:43 <copumpkin> anyone excited about the upcoming STM killer?
12:24:49 <kmc> what's that
12:24:52 <ion> copumpkin: URL?
12:25:05 <copumpkin> edwardk's latest creation, inspired by the all-powerful Daan
12:25:22 <fryguybob> concurrent revisions?
12:25:28 <copumpkin> yeah
12:25:55 <fryguybob> I noticed that made it on to here also:  http://rise4fun.com/Revisions
12:26:14 <vrook> I suppose there is a way to abstract away the many "lift" calls inside a transformer do block?
12:26:29 <ulrivo> hi. I am learning OpenGL using Haskell. With my program, I have a big difference between ghc and ghci, and I have no idea to find out why?
12:26:30 <kmc> vrook, lift the whole do block?
12:26:49 <vrook> kmc: but there's one thing that's unlifted
12:26:49 <Philippa> copumpkin: I'm definitely going to have fun with it, though we'll be attacking similar problems
12:26:51 <copumpkin> fryguybob: except edwardk's are pure and very haskellish, and are going to be friggin awesome
12:26:54 <companion_cube> ulrivo: you mean, in performance?
12:27:11 <fryguybob> copumpkin: Yeah, I've been watching his progress it is exciting.
12:27:37 <ulrivo> @cc: no…it seems to me that DisplayLists doesn't work with ghc, but with ghci
12:27:38 <lambdabot> Not enough privileges
12:27:39 <companion_cube> afaik ghci is interpreted and ghc compiles to native call
12:27:56 <kmc> ulrivo, are you using multiple threads?
12:28:13 <companion_cube> ulrivo: sorry, i don't know mushc about openGL
12:28:21 <ulrivo> no…I don't think so. it is a simple opengl program
12:28:24 <companion_cube> (and tip: use <tab> to complete nicknames on irc ;))
12:28:43 <ulrivo> thank you companion_cube ;-)
12:28:51 <ville> (not an IRC feature. rather a client feature)
12:29:49 <ion> Another tip: you might find the context switch to result verification you need to do after tab completion slower than just typing the nick. :-P Depends on the nick length, though.
12:30:54 <ion> Well, perhaps not just the result verification, but the iteration through the alternatives when the first result isn’t the one you want.
12:31:09 <jessopher> it should always complete to the closest match, taking into acount the age of their last message in the channel
12:31:20 <jessopher> but it never does
12:32:50 <ion> To rephrase: typing the nick is a predictable O(n) operation without a context switch away from typing. Tab completion is not.:-)
12:35:23 <ulrivo> what are differences between ghc and ghci (beside interpreting/compiling)?
12:36:32 <kmc> ghci is interactive
12:36:34 <donri> ghci is interactive
12:36:38 <kmc> ghc compiles a set of files
12:38:00 <ulrivo> okay. I mean…if a program behaves differently under ghci as compiled with ghc…what could be the reason?
12:38:30 <donri> optimizations could be one
12:38:31 <Cale> ulrivo: ghci is threaded by default
12:39:03 <Cale> It also tends to set input and output buffering options
12:39:18 <mm_freak_> donri: i'm not entirely happy with web-routes-boomerang…  it still seems to be inconvenient, unless you use happstack =/
12:39:23 <Cale> What is the difference in behaviour that you're seeing?
12:39:37 <jessopher> http://hackage.haskell.org/packages/archive/noodle/0.0.19/logs/failure/ghc-7.2 is this the result of anything I might beable to control by changing some aspect of my package?
12:40:54 <ulrivo> @Cale: the program renders a scene, you can switch with a key press whether it uses DisplayLists or not. this works fine under ghci, but there is no difference when compiled with ghc
12:40:55 <lambdabot> Unknown command, try @list
12:41:03 <jessopher> lol
12:41:06 <donri> mm_freak_: haven't tried it, perhaps talk to stepcut
12:41:52 <ulrivo> (DisplayList do kind of caching/compiling of OpenGL commands)
12:43:47 <donri> mm_freak_: curious, what are you using other than happstack?
12:50:13 <mm_freak_> donri: i'm writing an own web framework based on WAI and netwire
12:51:34 <donri> cool
12:52:08 <mm_freak_> however, routing is really a difficult issue =/
12:52:18 <TomvdZ> I would like to map an IO function over a Data.Map. Could anyone enlighten me on how I could do that?
12:52:30 <mm_freak_> TomvdZ: mapM
12:52:41 <mm_freak_> TomvdZ: see Data.Foldable and Data.Traversable
12:52:59 <donri> and Control.Monad
12:53:03 <TomvdZ> No, I'm not looking for mapM. That works for lists but not for Data.Map.
12:53:14 <mm_freak_> TomvdZ: again: see Data.Foldable and Data.Traversable
12:53:36 <TomvdZ> Okay, thanks!
12:54:06 <donri> also sequence . Map.map (which i suspect is what the traversable instance does for Map, or something)
12:54:45 <mm_freak_> donri: that's just mapM
12:55:29 <donri> mm_freak_: Map.map, not Prelude.map
12:55:30 <TomvdZ> I think that Data.Map is an instance of Data.Traversable so you can use Data.Traversable.mapM on it but not Prelude.mapM.
12:55:42 <mm_freak_> donri: web-routes-th would be great if only it would allow me to write my resource locations myself =/
12:56:40 <mm_freak_> donri: and using another 'sequence', namely the one from Data.Traversable =)
12:56:51 <mm_freak_> and then that's just Data.Traversable.mapM
12:57:00 <donri> aye, as i suspected :)
12:57:48 <mm_freak_> i wonder if i could just use boomerang and implement the rest myself
12:58:05 <donri> mm_freak_: you could just use web-routes without anything extra, though then there's duplication of mapping *to* and *from URLs, duplication that must be kept synchronised
12:58:48 <donri> so you can either use -th to generate mappings based on the show instances for your Sitemap, or -boomerang to parse/build URLs yourself
12:59:14 <donri> (well, probably it uses the Typeable instances, not Show)
13:03:51 <mm_freak_> donri: i'm actually concerned about the user side, because the library side will just use web-routes
13:04:07 <mm_freak_> the other packages are then addons, just like in happstack
13:04:14 <vrook> k y = f $ g $ h x y -- can k be defined in point-free fasion?
13:04:37 <vrook> *fashion
13:04:45 <donri> mm_freak_: then it's a simple matter of what best-practice you'll recommend in your docs :P
13:05:08 <mm_freak_> donri: however, web-routes-boomerang doesn't seem to define a PathInfo instance
13:05:20 <mm_freak_> rather it requires you to go through the Site type, which i really want to avoid
13:05:52 <mm_freak_> vrook: k = f . g . h x
13:06:03 <mm_freak_> or wait
13:06:14 <mm_freak_> @pl \y -> f $ g $ h x y
13:06:15 <lambdabot> f . g . h x
13:06:17 <mm_freak_> yeah
13:08:19 <mm_freak_> web-routes-boomerang would be optimal, if it would also define PathInfo instances
13:09:43 <donri> mm_freak_: what's wrong with Site?
13:10:01 <donri> looks simple enough to derive a PathInfo from a Site btw
13:10:04 <mm_freak_> donri: it requires a handler function
13:10:10 <mm_freak_> as far as i see
13:11:43 <mm_freak_> it just doesn't really fit my model
13:13:34 <donri> that does look a little awkwardly coupled, unless i'm missing the reason for it
13:13:37 <donri> stepcut?
13:14:40 <mm_freak_> donri: well, the only real way i see is to use multiple, independent wires, but then it would be very difficult to have global application state
13:14:48 <vrook> mm_freak_: Are you sure? k' 3 is a function, not an integer. https://gist.github.com/1456541
13:15:19 <mm_freak_> vrook: "k' y =" is wrong
13:15:26 <mm_freak_> you want "k' ="
13:15:38 <mm_freak_> that's the point of pointfree style after all =)
13:15:52 <vrook> oops, thanks
13:16:36 <vrook> can I somehow permanently enable ghci to give me warnings for unused parameters?
13:16:48 <kmc> ghci -Wall
13:17:05 <kmc> you can probably put ":set -Wall" in ~/.ghci
13:18:02 <vrook> yep that does it, thanks.
13:18:24 <shachaf> I wonder whether there's a way to speed up ghci's start-up time with a lot of imports.
13:19:32 <carpi> hex number can be represented by 0x and octal by 0o.. what about binary?
13:19:41 <kmc> none
13:19:49 <Axman6> there's no syntax for binary numbers
13:19:49 <kmc> not in haskell
13:20:33 <carpi> oh thats a surpise
13:20:39 <donri> mm_freak_: the handler is just something that takes a Sitemap value and produces a value of any type of your choosing; how does that not fit into your model?
13:21:07 <shachaf> You can represent 0000 by 0, 1111 by f, and so on.
13:22:51 <carpi> nibbles )luv em
13:23:46 <mm_freak_> vrook, kmc: -W is enough
13:23:51 <mm_freak_> -Wall can get very annoying
13:24:40 <mm_freak_> donri: problem is:  that would be the URL type in my case
13:24:45 <donri> -Wall -Werror
13:26:08 <byorgey> carpi: however, it would not be hard to make a quasiquoter to recognize binary numbers
13:26:19 <byorgey> (in fact, such a thing may already be on Hackage)
13:26:30 <mm_freak_> one idea that comes to my mind is to have one global application wire and then one wire for each route…  perhaps that wouldn't be too bad
13:26:35 <kmc> everything i write is -Wall-clean
13:26:41 <byorgey> so you could write something like  [b| 10011101 |]
13:26:49 <kmc> except for a few files that have individual warnings disabled
13:27:15 * byorgey does the same as kmc
13:27:28 <mm_freak_> what's the -clean?
13:27:51 <shachaf> mm_freak_: I think it means "doesn't print errors with -Wall".
13:27:56 <donri> mm_freak_: i don't know what a wire is but surely you have some point in your app where you want to dispatch to behavior specific to a route?
13:28:02 <donri> otherwise what's the point of routing
13:28:21 <kmc> what shachaf said
13:28:27 <mm_freak_> donri: having a specific route is an event…  it's FRP
13:28:38 <arw> couldn't you just build some binaryToInt and hope the compiler does constant folding?
13:28:58 <donri> mm_freak_: so then you fire the event in the handler?
13:29:26 <mm_freak_> donri: you don't fire events…  the firing is implicit
13:29:39 <mm_freak_> donri: i can't explain that without explaining the whole of netwire =)
13:29:49 <byorgey> arw: sure, you could
13:30:08 <byorgey> arw: though I'm not sure whether it would.
13:31:04 <byorgey> arw: "constant folding" is like "2 + 5" ==> "7".  turning 'binaryToInt "101"' into "5" is more like partial evaluation.
13:31:50 <byorgey> it could work if it inlines sufficiently vigorously I suppose.
13:32:35 <arw> byorgey: its always partial evaluation, its just that most compilers, even in C and stuff, assume that simple arithmetics and certain string functions are side-effect-free.
13:33:02 <byorgey> arw: yes, good point.
13:33:58 <parcs> mm_freak_: what does -Wall enable that -W doesn't
13:34:02 <arw> byorgey: but I agree that its maybe a little much to hope for in that case.
13:34:51 <dropdrive> Which package(s) should I use for parsing gigantic text files of integers and real numbers into Int and Double?
13:35:17 <mm_freak_> parcs: well, i don't know exactly, but i remember it being /very/ pedantic
13:35:29 <mm_freak_> dropdrive: if you want speed, you'll likely want attoparsec
13:35:38 <parcs> dropdrive: attoparsec-enumerator
13:35:48 <mzero> while it seems tempting to go ahead and create something like [b| 100111101|] in TH, thanks to the "execute once" nature of Haskell, a (module) global like:   syncByte = binaryToInt "100111101"   will only execute once per program, and almost certainly efficient enough --- and the advantage of not complicating the programming space (with TH constructs)
13:36:24 <parcs> mm_freak_: i see.. i wasn't even aware -W existed, i've always used -Wall
13:36:48 <donri> I think -Wall is really -W all
13:36:53 <donri> aka "warn all"
13:37:00 <mm_freak_> parcs: if it doesn't bother you, go with it
13:37:10 <mm_freak_> nothing wrong with -Wall, just that i don't like it =)
13:37:24 <dropdrive> mm_freak_: Thanks...I can't even figure out how to get a Double out from String/ByteString/LazyByteString
13:37:25 <parcs> mm_freak_: well i may like -W better :P
13:37:34 <mm_freak_> dropdrive: read
13:37:43 <mm_freak_> > read "2.5" :: Double
13:37:44 <lambdabot>   2.5
13:37:49 <kmc> mm_freak_, which -Wall warnings annoy you?
13:37:50 <mm_freak_> or 'reads', if you want to handle errors
13:38:23 <dropdrive> mm_freak_: Doesn't this require String, which defeats the use of ByteString?
13:38:39 <mm_freak_> kmc: not sure
13:38:58 <mm_freak_> dropdrive: you had "String" in your choice =)
13:39:32 <mm_freak_> dropdrive: there are fast variants for ByteString and Text, but for parsing more than just one number, you should go with attoparsec
13:39:45 <parcs> dropdrive: by the way, how are the integers and doubles delimited in the text file?
13:39:57 <dropdrive> parcs: whitespace and newlines.
13:40:14 <mm_freak_> dropdrive: note, you may also be happy with lazy I/O and the usual functions from Data.ByteString to actually /parse/ the file
13:40:25 <mm_freak_> then just apply a fast reader to the individual number strings
13:40:25 <dropdrive> mm_freak_: I see -- do you know where the fast variants live?
13:40:33 <dropdrive> mm_freak_: Hmm, I didn't even consider that!
13:40:54 <mm_freak_> dropdrive: there are at least readInt and readInteger in Data.ByteString.Char8
13:40:56 <mm_freak_> same for Lazy
13:41:15 <mm_freak_> for floating point numbers i don't know
13:41:29 <kmc> ugh Char8
13:41:30 <lukish> http://blog.tmorris.net/20-intermediate-haskell-exercises/ confused on exercise 12
13:41:34 <kmc> that's such a misguided module
13:41:40 <vrook> do g <- newStdGen ; print $ runST $ evalRandT randTest g -- this works, but the following fails with "Quantified type variable `s' escapes" -- newStdGen >>= print . runST . evalRandT randTest
13:41:58 <kmc> yeah
13:42:04 <vrook> "Inferred type is less polymorphic than expected"
13:42:07 <kmc> (.) doesn't eat the higher-rank type of runST properly
13:42:20 <lukish> Should I define jellybean using banana and unicorn or what?
13:42:25 <kmc> it would have to instantiate a type variable in (.)'s type at a quantified type
13:43:28 <kmc> :t print . runST
13:43:30 <lambdabot> forall a. (Show a) => (forall s. ST s a) -> IO ()
13:43:35 <kmc> hmm
13:43:43 <Saizan> :t \f -> runST . f
13:43:45 <lambdabot>     Cannot match a monotype with `f (forall s. ST s a)'
13:43:45 <lambdabot>       Expected type: f (forall s. ST s a)
13:43:45 <lambdabot>       Inferred type: t
13:43:50 <kmc> i'm surprised that one worked
13:44:34 <vrook> So it's the forall extension in ST?
13:44:57 <vrook> ... which has some ill-defined scope?
13:45:00 <kmc> i don't know what that question means exactly
13:45:06 <kmc> it's not "ill-defined"
13:45:15 <kmc> it's just some type system features which interact poorly
13:45:36 <kmc> type inference for a language where you can have foralls anywhere in a type is undecidable
13:45:36 <Saizan> it's just that practical type inference for higher-rank types hasn't been figured out that well yet
13:45:57 <kmc> so Haskell restricts you to implicit forall at the outermost position
13:46:02 <kmc> and GHC relaxes that restriction, but then you're on your own as far as inference goes
13:46:52 <vrook> I've googled the error but I still don't quite understand. What does it mean for `s' to escape?
13:47:16 <Saizan> (they seem to want to go into requiring more annotations but at least make it more predictable)
13:47:20 <vrook> it's going outside the forall scope?
13:48:14 <gwern> hm. today seems like a good day to update my Haskell Summer of Code page. by december 10, the SoC results should be clear
13:49:46 <Saizan> vrook: in a sense yes, "s escapes" means that if you were to construct a typing derivation you'd have to use 's' where it's not in scope
13:51:03 <yitz> gwern: yes, at least until google decides to move their summer of code to australia
13:51:22 <gwern> yitz: you know, I would say that's absurd but given their decisions over the last few years...
13:51:30 <yitz> hah
13:51:31 <Saizan> or at least that the inference engine decided to try to build
13:51:50 <Saizan> +the one
13:51:51 <vrook> So runST . evalRandT randTest would have some signature involving this `a', but the `a' was restricted to the forall clause?
13:52:10 * gwern ponders where to find info on the OpenGL SoC
13:53:27 <yitz> gwern: if they did both, there could be summers of code going on for six months of every year
13:53:50 <gwern> yitz: but think of teh moneys! it'd cost like .1% of their profits to run *two* SoCs
13:53:53 <gwern> madness
13:54:05 <Saizan> vrook: do you mean 's' ?
13:54:11 <yitz> gwern: ok. but we can always dream
13:54:16 <vrook> yes, 's'
13:54:40 <vrook> hm but runST's output type doesn't involve an s
13:54:48 <xil> hi. What is the equivalent of an empty Array?
13:54:57 <kmc> an empty Array
13:55:17 <xil> kmc: I mean, programmatically. How do I express an empty Array
13:55:20 <xil> like [] for lists
13:55:35 <lukish> How can define function (Some  m) => m (m a) -> m a?
13:55:43 <copumpkin> xil: it's not nearly as useful, I warn you
13:55:44 <lukish> When m is not monad
13:55:57 <carpi> do the functions declared in a typeclass have any special status in haskell or are they just like any other function in haskell?
13:56:00 <xil> copumpkin: it's never going to be used, I just need teh placeholder
13:56:07 <kmc> xil, lower bound greater than upper bound
13:56:10 <kmc> > array (1,0) []
13:56:12 <lambdabot>   array (1,0) []
13:56:13 <gwern> man, the google SoC site is terrible, it won't even tell you if a project paid out or not
13:56:33 <xil> kmc: ah there, thanks =]
13:57:24 <yitz> gwern: maybe email them, tell them you run the site for the haskell community to assess our SoC projects. maybe they'll help out.
13:57:48 <gwern> http://www.google-melange.com/gsoc/org/google/gsoc2011/haskell <-- where the deuce is the opengl SoC?
13:58:05 <yitz> gwern: or ask one of our google guys if they can help out
13:58:32 <Saizan> vrook: the problem is the input type, it gets something of type ST s0 a for some undetermined but already specific s0, while it really wants a forall s. ST s a, i.e. one that works for every s
13:58:48 <mzero> lukish: what is Some?
13:59:22 <lukish> mzero:  http://blog.tmorris.net/20-intermediate-haskell-exercises/ exercise 12
13:59:32 <mzero> lovely
13:59:33 <gwern> hm... don't see any opengl 4.0-related package or a package named what the soc proposal said.... maybe the SoC site simply hides failed projects?
13:59:34 <raichoo> Some is Just
13:59:41 <raichoo> Some comes from Scala
13:59:52 <shurikas> *** Exception: getRequest: Not a valid URL - http://www.google.com/ig/calculator?hl=en&q=100eur%3D%3Fdkk
13:59:57 <shurikas> that's using simpleHTTP (getRequest url) (where url is given url)
13:59:59 <mzero> lukish: I did those the other night - they were fun
14:00:02 <shurikas> any workarounds?
14:00:03 <mzero> so the way to think about this one is
14:00:04 <gwern> if only Jason Dagit were here! if only I remembered what nick corresponded to 'Jason Dagit'!
14:00:18 <kmc> i know edwardk has been active with SoC recently
14:00:19 <mzero> you can't know anything about values of type a, right? because the function works for all a
14:00:21 <kmc> you could ask him
14:00:33 <lukish> mzero: yep
14:00:35 <parcs> gwern: dagit i believe
14:00:43 <gwern> preflex: seen edwardk
14:00:44 <preflex>  edwardk was last seen on #haskell-blah 15 hours, 8 minutes and 48 seconds ago, saying: x!y is 3 chars
14:00:47 <gwern> preflex: seen dagit
14:00:48 <preflex>  dagit was last seen on #haskell 167 days, 19 hours, 38 minutes and 54 seconds ago, saying: danharaj, oleg has a paper that shoes how they are related
14:00:50 <vrook> Saizan: ok, so when the argument is passed explicitly in the 'do' block, there is something concrete to infer so runST is happy?
14:01:04 <mzero> and the only think you know about values of type m a is that they are Misty -- that is the functions defined in class Misty work on 'em
14:01:15 <lukish> mzero: yep
14:01:21 <mzero> now you have all the pieces that can work on 'em
14:01:38 <mzero> so - do any of those functions seem to have a similar form?
14:01:58 <lukish> Any of which functions?
14:02:09 <yitz> gwern: full list is here, no mention of opengl: http://www.google-melange.com/gsoc/projects/list/google/gsoc2011
14:02:15 <Saizan> vrook: so then it'd have to try to use the 's' quantified in the forall to define s0, but that definition would be outside of the scope of 's', hence the error
14:02:15 * hackagebot cabal2nix 1.21 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.21 (PeterSimons)
14:02:17 <lukish> Functions from earlier exercises?
14:02:28 * gwern runs a google search on 'Alexander Göransson opengl' post august 1st. nada. gonna mark this one as failed.
14:02:37 <mzero> the only functions you can use --- those defined in class Misty: banana, unicorn --- and the functions defined in terms of them like furry'
14:02:51 <mzero> and of course, the standard set of functions that work on all values, like id and the like
14:03:27 <lukish> I need something like banana, but backwards
14:03:40 <mzero> well - not really!
14:03:43 <Saizan> vrook: it's more about the types of the combinators involved than concreteness
14:03:52 <lukish> Some abanana
14:03:58 <mzero> look at the type of the thing you are trying to create:    m (m a)  ->  m a
14:04:21 <lukish> I can't actually understand what m (m a) is
14:04:27 <mzero> now look at the type of banana --- or rather, the type of ba
14:04:28 <mzero> AH
14:04:43 <Saizan> vrook: my rule of thumb is that if are having problems with runST you should try to apply it directly to its argument rather than use an HOF
14:04:44 <lukish> If m is [], m (m a) is list of lists
14:04:52 <mzero> do you understand    m Int     ?
14:04:59 <mzero> how about     m (Maybe Int)    ?
14:05:02 <mzero> are those clear?
14:05:23 <mzero> how about    m (Maybe a)    ?
14:05:28 <mzero> no generalize
14:05:43 <mzero> m (m a)   ---- and yes, if m is [], then this is a list of lists, or   [ [ a ] ]
14:05:58 <mzero> if m is Maybe it is     Maybe (Maybe a)
14:06:04 <lukish> Yep
14:06:10 <mzero> are all this clear?
14:06:18 <lukish> Seems like this.
14:06:33 <mzero> then    m (m a)  shouldn't be too much of a stretch.....
14:07:05 <mzero> but let me ask you this     if  I have a value of    m (m a)    and pass it to a function that takes type   m b    --- what type will b be in that application?
14:07:08 <vrook> Saizan: ok thanks for the explanation.
14:07:19 * gwern emails dagit. hope that galois address works
14:07:30 <byorgey> gwern: Jason Dagit = lispy
14:07:42 <gwern> too late!
14:07:45 <byorgey> hehe
14:08:03 <lukish> mzero: (m (m (m b))) ?
14:08:20 * mzero feels like the mother in XKCD: cleaning up from baking cookies... and teaching Haskell
14:09:07 <vrook> The thing that surprises me is that there is any difference between point-free and point-ful notation. I would have originally imagined that they generate the same Core code. But they are different, as shown by the monomorphism restriction and this runST thing.
14:09:31 <Saizan> they might generate the same core code
14:09:32 <kmc> Core is generated after typechecking
14:09:38 <kmc> and is an implementation detail anyway
14:09:39 <mzero> nope    try again here     I have    f :: m b ->  ...     and v :: m (m a)      when I apply    f v    then    m b  will be matched with m (m a)     --- do that and look to see what unifies with the b
14:09:47 <kmc> vrook, monomorphism restriction is explicitly a syntactic rule
14:09:59 <kmc> it cares whether a particular binding uses function or pattern syntax
14:10:17 <byorgey> gwern: note the GHC plugins work (from 2008) has now been merged into GHC
14:10:23 <lukish> mzero: okay, it's m a
14:10:26 <kmc> anyway the key is that (.) and ($) aren't just a different syntax -- they are real higher-order functions with types etc.
14:10:26 <byorgey> not sure whether anyone is using it
14:10:27 <mzero> bingo
14:10:38 <kmc> and the polymorphism of those types interacts poorly with the polymorphism of runST's type
14:10:41 <gwern> byorgey: bleh, couldn't you tell me this later, I'm trying to figure out whether the cabal REPL stuff was ever merged
14:10:43 <kmc> a phenomenon you won't see in standard Haskell
14:10:50 <gwern> preflex: seen dcoutts
14:10:50 <yitz> preflex: seen lispy
14:10:50 <preflex>  dcoutts was last seen on #haskell 1 day, 5 hours, 33 minutes and 46 seconds ago, saying: lars9: ok, just follow the advice in the error message
14:10:52 <preflex>  lispy was last seen on #haskell 21 days, 23 hours, 28 minutes and 20 seconds ago, saying: So before those you have to tell your OS that you intend to allow sharing
14:11:03 <gwern> it wasn't merged. hm.
14:11:10 <byorgey> gwern: I'll tell you later, no problem
14:11:13 <mm_freak_> donri: i think i have found the solution…  i'll use web-routes-boomerang with the parsers/printers from boomerang directly
14:11:14 <mzero> lukish: now - look at your available functions to work with, and see if anything can be used to match your desired   m (m a) -> m a
14:11:16 <mm_freak_> seems to work well
14:11:28 <russellw> kmc, I am curious, what was the advantage of making $ a higher order function? I would have thought just making it syntax sugar was the obvious way to implement it?
14:11:37 <kmc> russellw, i would think the exact opposite
14:11:42 <kmc> if it's a HOF then it just lives in a library
14:11:49 <kmc> if it's syntactic sugar then it's a special rule in the language definition
14:11:54 <kmc> and every compiler needs a special case for it
14:11:58 <kmc> anyway, it's useful in other roles
14:12:03 <kmc> > map ($ 3) [pred, succ]
14:12:04 <lambdabot>   [2,4]
14:12:15 <kmc> > zipWith ($) [pred, succ] [1, 10]
14:12:16 <russellw> ah! Okay fair enough
14:12:17 <lambdabot>   [0,11]
14:12:44 <kmc> Haskell has a tendency to do with library functions what other languages do with special case rules
14:13:16 <kmc> which has some unexpected benefits and drawbacks
14:13:17 <mzero> which means, that you can "extend" Haskell without actually having to extend it --- which is why DSLs in Haskell are so popular
14:13:22 <vrook> But at least hypothetically, couldn't GHC have been designed such that f $ g $ h x y and f . g . h x are literally equivalent, such as one transforms into the other, or vice versa?
14:13:36 <russellw> makes sense
14:13:41 <kmc> vrook, sure.  but it wouldn't be implementing Haskell, then
14:13:50 <mzero> crook - those two expressions ARE equivalent,
14:14:02 <vrook> except when they are not
14:14:12 <mzero> it is only when assigned to top level identifiers that they aren't, due to MR
14:14:19 <Saizan> they are different expressions, they parse differently and typecheck differently
14:14:26 <Saizan> they evaluate to the same, that's all
14:14:28 <vrook> mzero: I was referring to runST
14:14:30 <byorgey> gwern: I also have some perspective on #6 (darcs-bridge) when you get to it.
14:14:35 <kmc> the issue with MR is really that «f x = ...» is not equivalent to «f = \x -> ...»
14:14:35 <russellw> MR?
14:14:40 <kmc> monomorphism restriction
14:14:50 <lukish> mzero: seem's like furry' can helps , but it have redundant first argument.
14:14:54 <russellw> ah, okay
14:15:16 <Saizan> vrook: IOW the answer is still "because . and $ aren't syntax sugar"
14:15:24 <mzero> lukish: good - that is one possible candidate, now find another
14:15:52 <vrook> Saizan: yeah that's where my understanding was different. I was thinking of them as sugar.
14:16:04 <gwern> yeah, I'm marking cabal REPL a failure too. patches not merged, no discussion on cabal-dev, author has not posted since august...
14:16:16 <kmc> yeah
14:16:25 <kmc> thinking of . and $ as sugar for parentheses is another one of these misleading analogies
14:17:00 <mzero> none the less, don't get the impression that parentheses are therefore preferable ---
14:17:16 <kmc> sometimes they are, sometimes they aren't
14:17:26 <mzero> those HOF were created because they can generally make code clearer --
14:17:34 <yitz> kmc: it comes from trying to help someone who doesn't know haskell to read haskell code and get the basic idea. you have to say that, otherwise they have no idea what is going on.
14:17:42 <mzero> kmc, sure, but I don't think people should have the impression that they are "paying a price" for not writing the parenthesis
14:18:10 <mzero> in the vast majority of cases, there is no penalty for having used the HOFs rather then explicitly parenthesizing or writing out extra lambdas
14:18:15 <kmc> what penalty?
14:18:19 <kmc> are you talking about performance?
14:18:32 <lukish> mzero: unicorn is unusable, because I haven't need of m a from m
14:18:36 <Saizan> yitz: one reason i refrain from using them when writing code meant for early newbies
14:18:45 <mzero> the others seem concerned about the code generated... which is a legitimate concern at times
14:18:48 * yitz nods
14:19:11 <mzero> lukish: good! keep going - you're getting the knack of this --- it is all about the type matching
14:19:38 <lukish> mzero: banana is unusable too, because I haven't (a -> m b), only m a
14:20:41 <mzero> lukish: apply the same reasoning you did about furry' to banana --- that is, don't worry about the first argument -- because you want a      x -> y    in the end, so if you have  a    w -> x -> y    maybe by supplying the right w you'll get the   x -> y  you want
14:22:06 <lukish> (a -> b) is (m a -> m b) in that case, right?
14:22:23 <gwern> at least jasper didn't mess up on the utf-8 SoC
14:22:34 <gwern> this was starting to look pretty negative :)
14:24:02 <mzero> for the first argument of furry' ?     Look at it this way, you have to build    m (m a) -> m a     if you used furry' , that is, applied furry' to just the right first argument (x -> y)   then  given that the second argument of furry' would match   m (m a)  and the result   m a    what would the type of the first argument have to be?
14:24:39 <kmc> yitz, sure, but there's a difference between "trying to help someone who doesn't know haskell to read haskell code and get the basic idea" and "trying to teach haskell"
14:24:50 <kmc> maybe i missed the context for why we're talking about the former
14:26:37 <dropdrive> @pl catMaybes
14:26:37 <lambdabot> catMaybes
14:26:45 <mzero> it might help you if you renamed the type variables in   furry'    to say  e and f    so    furry' :: (e -> f) -> m e -> m f
14:27:20 <kmc> ezyang did a blog post about "how to read haskell like python" (http://blog.ezyang.com/2011/11/how-to-read-haskell/) and says to ignore types, classes, instances, return, do, fmap, const, lift, liftIO; to pretend that <- is assignment, etc
14:27:28 <mzero> yitz - when I teach newbies I try get them off parenthesis very quickly - and I teach . up front
14:27:44 <kmc> but if you actually want to learn haskell, i think that advice is counterproductive
14:27:58 <sal23> how do I get the length of a storable vector in bytes? the storable vector might have null terminated c strings of varying lengths.
14:29:08 <kmc> sal23, then it's a vector of pointers, no?
14:29:22 <lukish> mzero: if I assosiate m (m a) to m e, so i need to assosiate (m a -> m b) to (e -> f)
14:29:33 <lukish> But I don't have this one
14:29:39 <sal23> kmc: no, the strings are packed in the storable using custom definition
14:29:42 <kmc> what's the actual type sal23?
14:29:56 <kmc> how did you write your custom Storable instance?
14:30:10 <gwern> bleh. parallel cabal-install hasn't been merged either
14:30:15 <kmc> Storable types need to have fixed size
14:30:36 <sal23> kmc: I haven't written it yet, but my guess is that Vector has a constructor which contains foreignptr, offset and length in bytes
14:30:48 <sal23> kmc: I am trying to get O(1) length information
14:31:19 <kmc> so you have a bunch of C strings which are contiguous in memory
14:31:37 <kmc> and you want to turn that into a Vector of some kind of string type?
14:32:39 <sal23> kmc: yes, but with constant length information
14:32:51 <kmc> that's not how Vector.Storable works
14:33:12 <kmc> it requires that the elements are instances of Storable
14:33:24 <sal23> kmc: you can define your own instance
14:33:29 <kmc> of Storable, yes
14:33:50 <kmc> a Storable type is required to have a fixed-size byte representation
14:33:51 <mzero> lukish: right --- now try the same thing with banana
14:33:57 <kmc> a size known at compile time
14:34:05 <kmc> so you can't make strings themselves storable
14:34:10 * mzero is making salt crystal pictures with the kid and may be in and out
14:34:18 <kmc> you can have a Vector (Ptr CChar), sure
14:34:25 <kmc> but that's not contiguous C strings in memory
14:34:36 <kmc> it's contiguous pointers
14:34:46 <sal23> kmc: that sounds right. So, there is no known way to pack C Strings in a storable vector with total length information?
14:34:49 <kmc> to memory which you have to separately allocate and manage
14:35:25 <kmc> what do you mean by "no known way"
14:35:49 <kmc> you can make a huge Vector Word8 and use that as the underlying store for whatever data layout you like
14:36:00 <sal23> kmc: if it is assigned pointers to chars because of fixed size limitation, then to compute length, each pointer will have to be walked to find length of each string
14:36:11 <kmc> yes
14:36:47 <kmc> and each string itself
14:37:06 <sal23> kmc: that is what I meant by no known way to  store CStrings in storable vector with O(1) length information of bytes
14:37:12 <kmc> you can build this yourself with extra bookkeeping
14:37:19 <kmc> it's not something Storable Vector does for you
14:37:29 <kmc> it doesn't make sense with the model of an array of fixed-size, opaque values
14:37:43 <sal23> kmc: yep, that would make sense
14:38:48 <mm_freak_> does anyone know a nice way to handle pattern match errors in arrow notation like 'fail' for do-notation?
14:39:06 <gwern> byorgey: ok so what about the bridge
14:40:28 <byorgey> gwern: currently I would say "unknown".  Owen clearly did good work, and the bridge was usable (if a bit clunky).  I was using it to mirror some darcs repos on github.
14:40:32 <lukish> mzero: to banana I have (m a -> m b) -> m a -> m b
14:40:39 <gwern> byorgey: where is it?
14:40:41 <byorgey> gwern: however, I ran into some critical bugs and Owen has been working on fixing them.
14:41:10 <lukish> (m (m a) -> m b) -> m a -> m b *
14:41:20 <gwern> (ah good owen has a blog)
14:41:39 <byorgey> gwern: so it could turn out to be a success, but it will depend on whether he gets the bugs fixed and gets it packaged up nicely so people can use it
14:42:32 <mzero> lukish:    let's get our a's and b's clear... the best way is to NOT have them in both.....   so you need to create  m (m a) -> a
14:42:58 <mzero> and you've got banana :: (x -> m y) -> m x -> m y
14:43:05 <byorgey> gwern: http://wiki.darcs.net/DarcsBridgeUsage
14:43:14 <gwern> (yeah, he linked it i nthe final SoC post)
14:43:21 <byorgey> ok, right
14:43:25 <mzero> now, try matching what you want to build to the last two types of banana -- like you did with furry' ---- what will x and y be?
14:43:56 <chrisdone> quickpoll: do you guys use hayoo or hoogle often in daily developing?
14:43:57 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
14:44:30 <gwern> byorgey: geez, you need to install a fork?
14:44:37 <gwern> chrisdone: I use hoogle pretty frequently but hardly ever hayoo
14:44:53 <byorgey> chrisdone: I'm the same as gwern
14:45:00 <byorgey> gwern: it's not a fork
14:45:04 <dgpratt> chrisdone: not sure it's fair to say I 'develop' with Haskell, but...Hoogle almost always
14:45:13 <gwern> byorgey: so what's darcs-screened?
14:45:22 <chrisdone> hm, consistent with my experience. good to know
14:45:30 <byorgey> gwern: that's basically just darcs HEAD
14:45:43 <gwern> byorgey: oh. so there hasn't been a release of darcs since?
14:45:52 <byorgey> gwern: right, not yet
14:45:58 <lukish> mzero: x - m a, y - m b
14:46:33 <chrisdone> so it's essentially using it for standard lib function search, rather than, say, searching hackage for a function or type—presumably you just look on hackage for a package that sounds likely
14:47:00 <chrisdone> kmc: i hope that bertolo is okay, somehow i get the feeling he's not safe crossing the road
14:47:09 * chrisdone deletes spam pastes
14:48:39 <gwern> byorgey: so successful with a question mark
14:48:48 <vrook> inside a do-block for a transformer monad I have many "lift $ ..." lines, but not all are lifts so I cannot lift the block. Is there a prettier way to do this?
14:48:52 <gwern> byorgey: any thoughts on the final SoC, the v3 darcs patch format?
14:49:21 <gwern> vrook: group them together and then lift *that* block? :)
14:50:05 <chrisdone> vrook: the problem might be solvable elsewhere… what monad are you lifting from and to?
14:50:13 <Saizan> there's the "auto-lifting typeclasses" approach
14:50:17 <deech> Hi all, I am using haskell-mode for emacs. But I am unable to get GHCI buffer tab-complete to work (it inserts an actual tab instead). Has anyone else had this issue?
14:50:53 <chrisdone> deech: i'm not confident that ever worked in inf-haskell
14:50:59 * chrisdone checks
14:51:04 <deech> chrisdone: Oh, that's a shame.
14:51:04 <vrook> I guess I was exaggerating when I said "many". There are three lift lines and one non-lift line. https://gist.github.com/1456996
14:51:20 <Saizan> e.g. get :: MonadState m s => m s, and there are MonadState instances for most transformers that just lift get, so that you can just use get
14:51:20 <vrook> How would you prettify that?
14:51:41 <deech> chrisdone: By the way, your recent video is cool.
14:52:38 <chrisdone> deech: nope, doesn't seem to support it. for what it's worth, haskell-emacs's repl has autocomplete, but for the project code, rather than the current ghci session. maybe that can be extended actually…
14:52:45 <chrisdone> deech: thanks, have you tried it?
14:52:58 <deech> chrisdone: No, there's a big fat warning on your Github page :)
14:53:01 <mzero> lukish - what is b?   try matching     m (m a) -> m a     to     m x -> m y
14:53:13 <Saizan> ah, what i described doesn't apply to ST currently, since such a class doesn't exist
14:53:35 <deech> chrisdone: Is it safe to use now?
14:53:45 <chrisdone> deech: maybe i should change it to, “give it a try, but don't complain too much if it has bugs at this stage” :P
14:53:48 <lukish> mzero: where m x -> my came from?
14:54:04 <deech> chrisdone: Ok, that's good enough for me. I'll try it right now.
14:54:05 <mzero> (remember, we've renamed the types of banana to be    (x -> m y) -> m x -> m y
14:54:24 <chrisdone> deech: well, i'm not sure, it's safe enough for me but it's mine. ivanm's been using it for a while afaik and some other chaps
14:54:35 <chrisdone> deech: awesome. live User Experience™ testing right here
14:54:49 <mzero> that is just variable renaming, right?     so   banana :: (x -> m y) -> m x -> m y     says exactly the same thing as   banana :: (a -> m b) -> m a -> m b
14:54:55 <deech> chrisdone: Well, if I'm knocked off it's because the mode wiped my root directory.
14:55:13 <chrisdone> deech: i fixed that bug
14:55:15 * chrisdone joking
14:57:04 <chrisdone> deech: i recommend trying the command line given in the README, as that's a quickstart to just check The Bloody Thing Works, and then you're not wasting time setting up your .emacs
14:57:13 <lukish> mzero: matching "m (m a) -> m a" to "m x -> m y" means that I need to find such a, that I get "m x -> m y" from it?
14:57:17 <mzero> lukish: do you see how the a and b in the original banana, and the x and y in my renamed version --- are just type variables, right? their names don't matter -- they could have been larry and moe    banana :: (larry -> m moe) -> m larry -> m moe
14:57:36 <lukish> Yes, thats clear
14:57:55 <chrisdone> side point: did someone at one point suggest supporting `_' for type variables?
14:58:10 <mzero> lukish: try it the other way --- you've been given (or your function jellybean will be given) an argument of type m (m a)   --- how does that correspond to m x   ?
14:58:17 * gwern reads http://web.mornfall.net/blog/soc_reloaded:_outcomes.html and is less than impressed. pretty much as I predicted.
14:58:35 <Jafet> _ won't have many uses as a type variable.
14:58:49 <lukish> mzero: giving to it m x as a?
14:58:58 <mzero> correctomundo!
14:59:03 <mzero> no
14:59:08 <mzero> wrongomundo (my bad)
14:59:10 <DanBurton> lol
14:59:24 <mzero> if      m (m a)    is equivalent to    m x      --- what is x?
14:59:56 <lukish> m a
14:59:57 <chrisdone> Jafet: e.g., this could be cute: f :: (_,_,_,a) -> a, instead of, f :: (a1,a2,a3,a) -> a
15:00:06 * mzero really really really wishes he had font control in IRC
15:00:09 <mzero> lukish: right
15:00:36 <mzero> so now,    what is y?    remember, we're matching    m (m a) -> m a     to the end of    banana :: (x -> m y) -> m x -> m y
15:01:16 <lukish> a
15:01:19 <mzero> good
15:01:45 <mzero> now ----    if x is m a and y is a    then, what is the type of the first argument to    banana :: (x -> m y) -> m x -> m y
15:01:48 <gwern> mzero: nein! plain text uber alles
15:02:01 * Jafet s/ \+/ /g's mzero
15:02:02 <chrisdone> deech: success?
15:02:14 <lukish> m a -> a
15:02:39 <Jafet> Ascii ueber alles
15:02:46 <mzero> lukish: substitute your matches for x and y very carefully
15:02:59 <deech> chrisdone: Yup, I cloned it and loaded it up with your init.el file
15:03:08 * gwern decides the darcs v3 patch format SoC was a failure
15:03:18 <vrook> does ghci have a "rollback" feature for loading? Often I will have an error and then want to use :t and :i, but I can't use those because they aren't imported. I end up making a separate file which is empty except for the imports, and I load that after I have an error and want to use :t :i.
15:03:39 <deech> chrisdone: I haven't seen the auto-complete feature before, how do I get it to kick in? Tab in a source file doesn't seem to work.
15:03:46 <mads-> Hello
15:04:05 <Saizan> chrisdone: yes, it's been suggested, or more generally unification variables, it'd be nice if someone went and implemented it
15:04:09 <vrook> I can import them directly, but then my ghci prompt is uselessly long
15:04:09 <chrisdone> vrook: in haskell-emacs it maintains a current and a background ghci session, so that there is always a ghci session with the latest successful load, so you don't have that problem
15:04:09 <Jafet> vrook: everyone makes a separate file like that. Did you call yours ~/.ghci?
15:04:09 <lukish> mzero: m a -> m a, I mean
15:04:43 <Jafet> echo ':set prompt "> "' >> ~/.ghci
15:04:44 <mzero> aha ----    know any functions that look like that?
15:04:48 <lukish> m a -> m a look like id
15:04:54 <mzero> yessssh!
15:05:10 <Jafet> It's a shame that set prompt doesn't take ([String] -> String).
15:05:14 <lukish> So, banana's first argument will be id
15:05:15 <mzero> so - the key to solving these is doing the type algebra - which is just basic substitutions with variable renaming
15:05:29 <chrisdone> Saizan: ‘more generally unification variables’? sounds saucy—what's that?
15:05:47 <mzero> and it really really really helps to rename all the free variables so they are different --- rather than reusing a and b in every function
15:06:14 <chrisdone> deech: umm. so in your haskell file hit C-` which'll make sure you have a project session started and associated with that file
15:06:17 <vrook> Jafet: as I said, the prompt is uselessly (inconveniently) too long, sometimes wrapping.
15:06:23 <mzero> lukish ---   if you "partially" applied banana to id what do you get?    that is.... what is the type of      banana id     ?
15:06:34 <chrisdone> deech: then save the buffer and it'll generate a tags file. after that autocomplete works as-you-type. does it work?
15:06:44 <vrook> chrisdone: haskell-emacs is different from inferior-emacs?
15:06:47 <lukish> (m a) -> (m b)
15:06:57 * BMeph says: "The key to mathematics is to see that it isn't a social encounter; it doesn't work better if you answer the question you think is coming next - you have to match the questions to their answers."
15:07:01 <mzero> again - do your type substitutions very very carefully -
15:07:06 <chrisdone> vrook: yeah, an eventual haskell-mode replacement
15:07:09 <vrook> chrisdone: oops, I mean inf-haskell
15:07:11 <mzero> helps to write them out, one per line,
15:07:29 <Saizan> chrisdone: e.g. if 'a is the syntax for an unification variable, a signature like f :: 'a -> 'a -> X would mean that f is constrained to take 2 arguments of the same type, but the exact type would be determined by inference
15:07:31 <mzero> and remember - there was no a or b in our re-typed banana ---
15:07:38 <Jafet> vrook: I don't understand what the prompt being too long has to do with ghci losing imports after an error, if anything.
15:07:40 <chrisdone> vrook: for example: http://www.youtube.com/watch?v=pMEyz4leeLk
15:07:50 <fsgxdroid> can somebody give me a hint how to solve following algoritm in haskell (link includes perl example): http://pastebin.com/YVXHBuww
15:07:51 <mauke> The paste YVXHBuww has been copied to http://hpaste.org/55096
15:08:30 <vrook> Jafet: I thought you were suggesting adding the imports to .ghci, which is inconvenient because of the resulting prompt.
15:08:44 <lukish> mzero: (m (m x)) -> a
15:08:48 * BMeph always thought that an algorithm ->Was<- a solution...
15:09:05 <lukish> (m (m a)) -> a *
15:09:21 <Jafet> vrook: I suppose it is, if you have many imports.
15:09:28 <lukish> I have utc+4, sorry for mistakes.
15:09:31 <mzero> fsgxdroid: If I give you the result of diagonalizing a 2 element list, and a third element, how would you produce the result for the 3 element list?
15:09:34 <BMeph> lukish: Remember my aphorism. Answer the question asked, not the question you think is coming next. ;)
15:09:38 <chrisdone> vrook: you can just :set prompt "> "
15:09:54 <lukish> BMeph: okay
15:10:21 <chrisdone> Saizan: hmm. what does that allow differently that normal f :: a -> a -> x doesn't?
15:10:53 <mzero> lukish:  ----   first write out     banana :: (x -> m y) -> m x -> m y     but replacing your substitutions for x and y  with what you got when you matched the end to    m (m a) -> m a
15:10:53 <deech> chrisdone: Ok, I think I did something wrong. I restarted emacs, and I set up a "Test" project in the "/tmp" directory and have the "Prepare Your Face" REPL running. I looked in the /tmp directory and there isn't a "Test" folder.
15:10:54 <gwern> byorgey: so are there any actual uses of the GHC plugins yet?
15:11:11 <mzero> you should have a result that is only in terms of m and a   --- since there is no b here anymore, right?
15:11:26 <fsgxdroid> mzero: still thinking...
15:11:53 <lukish> mzero: so I have (m (m a)) -> a for 2nd and 3rd
15:11:54 <vrook> chrisdone: ok, but that still leaves me with manually copying imports over to ghci. I'll look at haskell-emacs, thanks.
15:12:07 <Saizan> chrisdone: it allows f to actually be of type (Int -> Int -> X) for example, so if Int was actually a huge type expression you'd have saved that space in the type signature
15:12:10 <mzero> or, fsgxdroid: let me rephrase ---- you give me a three element list... I'll give you back either the first element or the last element (you pick) --- and the diagonalization of the list of the remaining two
15:12:24 <chrisdone> deech: you're saying the project was deleted when you closed emacs?
15:12:38 <mzero> lukish: I think you've mis-written down how you matched m a
15:12:40 <mzero> to m x
15:12:42 <mzero> er
15:12:44 <mzero>  m y
15:13:18 <mzero> if we x is m a    and y is a    then what is   banana :: (x -> m y) -> m x -> m y
15:13:31 <Saizan> chrisdone: basically they are named _'s so that they can be referred to
15:13:33 <chrisdone> Saizan: hmm. i think it get it but not sure, you're saying i could have f a b = a + b; f :: 'a -> 'a -> Int?
15:13:34 <mzero> don't gobble m's only substitute  x and y
15:13:46 <lukish> (m a -> m a) -> m (m a) -> a
15:13:49 <Saizan> chrisdone: yes
15:13:58 <mzero> what happened to the m in m y ?
15:14:08 <deech> chrisdone: Started a new emacs, did a "hs-project-start", and gave it the project name "Test" and the directory "/tmp". The REPL started up and I am trying to figure out how to add ".hs" files to this project.
15:14:09 <chrisdone> Saizan: pretty nice. and then when i :t it in ghci presumably it'd show the full type
15:14:16 <lukish> (m a -> m a) -> m (m a) -> m a*
15:14:16 <Saizan> chrisdone: yeah
15:14:20 <chrisdone> nice
15:14:23 <fsgxdroid> mzero: maybe first element
15:14:26 <mzero> lukish:  --- yes -- do you see that?
15:14:38 <mzero> fsgxdroid: sure that's probably how I'd do it!
15:14:46 <lukish> I've already forgot what are we trying to have :)
15:14:49 <chrisdone> deech: so just open a file in that directory, it'll default to using that project. then f5 to load it in the ghci
15:15:00 <augur> http://campl.us/g25b
15:15:10 <lukish> Nice, we are trying to have 2nd and 3rd of it
15:15:23 <chrisdone> deech: if you open any .hs file it'll either associate with the project in the same dir, or if it can't figure it out, will prompt you for the project name
15:15:46 <mzero> lukish: what are we trying to have? what is the desired type of the function  jellybean
15:16:06 <lukish>  m (m a) -> m a
15:16:23 <fsgxdroid> mzero: diagonalize (x:xs) = - thats beginning, so probably i need to make recursion and take length of the list?
15:16:43 <Saizan> augur: awww
15:16:59 <chrisdone> vrook: so i'm not sure what your essential problem is, that loading a module and getting a compile error resets any work done in ghci—which haskell-emacs tries to solve, or that when you start ghci up there are some modules you always use that you'd want imported already, in which case a .ghci in your home or your particular project dir will sort. which was it?
15:17:16 <chrisdone> deech: did it work?
15:17:19 <mzero> fsgxdroid: okay - sounds like a plan
15:18:05 <vrook> chrisdone: I want the former, which is what haskell-emacs solves. I don't really want default imports, only the ones in the file I'm working on.
15:18:25 <vrook> btw :set prompt "> " in .ghci hangs ghci
15:18:48 <marv> what haskell data type should i use for a timestamp?
15:18:54 <deech> chrisdone: Yes. By the way C-`, even though it's defined in the init.el file you provided seems to do a "Mark Set". I invoked the command manually.
15:19:01 <chrisdone> deech: it doesn't /save/ projects (yet), btw, or manage files for you, like that, emacs does that okay. it just associates files that have been opened with a particular started session
15:19:06 <Axman6> marv: UTCTime works quite well I think
15:19:45 <chrisdone> deech: ah, that sucks. heh, yeah, anyway you sorted it. got file loading to work then?
15:20:25 <deech> chrisdone: Yes, it's working! Great mode! Is there an indentation mode?
15:20:31 <chrisdone> vrook: it hangs? for mine it just shows a new prompt. where are you running that? vanilla ghci or wrapped in emacs or what?
15:21:00 <chrisdone> deech: yeah, in hs-config.el i've listed some options. basically you can just set one of them in your .emacs. there's…
15:21:24 <chrisdone> deech: see the hs-config-indent-function
15:22:01 <chrisdone> deech: pop (setq hs-config-indent-function 'hs-indent-glfsf-cycle) in your .emacs if you want that indentation mode
15:22:05 <vrook> chrisdone: I may have misunderstood -- I put it in my .ghci file.
15:22:19 <chrisdone> vrook: and ghci hangs when you start it?
15:22:36 <deech> chrisdone: Awesome. Thanks for the help. Already the GHCI buffer is better than haskell-mode
15:22:46 <fsgxdroid> mzero, diagonalize :: [Int] -> [[Int]], is it possible to accomplish this task only with one argument without using helper functions?
15:23:24 <mzero> fsgxdroid: I'm not sure - but the two solutions I think of both have helper functions --- is there a restriction against helper functions?
15:23:25 <vrook> chrisdone: yep, but only while inside emacs when I hit C-l. This is sorta old, ghci-6.12.3, which is the only binary for OS X 10.5
15:23:26 <chrisdone> deech: woot! fwiw, the (defvar hs-config-preliminary-load-file nil) should be set to t if you want it to make use of two ghci sessions to avoid the problem vrook is describing. i disabled it by default but i use it personally
15:23:31 <fsgxdroid> mzero, no
15:23:38 <mzero> good - don't fear 'em!
15:24:02 <vrook> ghci works in a terminal with :set prompt
15:24:07 * mzero sings "c'mon baby now, (c'mon baby), don't fear the where clause....."
15:24:12 <chrisdone> vrook: ahh. yeah. haskell-mode expects a certain format of prompt
15:24:22 <fsgxdroid> mzero, i'm thinking i need function to initalize this x dimensional list
15:24:29 <chrisdone> vrook: :set prompt "Haskell> " will work fine, i'd wage
15:24:32 <fsgxdroid> mzero, writing zeros
15:25:16 <chrisdone> (haskell-emacs sets your prompt to “λ> ”, naturally :p)
15:25:20 <mzero> well - before you hit details -- just, in words, what is your plan of attack? given the smaller result, how do you transform that into the result with one extra number?
15:25:39 <deech> chrisdone: Cool! Thanks again. I have to go, but I'll keep playing.
15:25:50 <chrisdone> deech: no problemo, laters :)
15:26:19 <mzero> wonders if ghci's prompt shouldn't really be something like   print =<<      :-)
15:26:26 <chrisdone> teehee
15:27:16 <chrisdone> mzero: i like that python's repl, when recieving as input “quit”, says “Use quit() or Ctrl-D (i.e. EOF) to exit”, instead of just quitting
15:27:17 <gwern> 2011 results http://www.gwern.net/Haskell%20Summer%20of%20Code#results-1
15:27:52 <Jafet> quit = raiseSignal sigQuit?
15:27:55 <donri> chrisdone: quit is an object that implements both __repr__ and __call__ ;)
15:28:05 <gwern> if you wish to correct my vicious and impolite judgments where I lack crucial information and have artificial standards, now's the chance :)
15:28:25 <lukish> mzero: so jellybean will be not use furry'?
15:29:02 <chrisdone> donri: i think you told me that before. it implements __funny__
15:29:11 <mzero> lukish - well, do the same sort of substitution we did for banana on furry' and see what you come up with for the type of furry's first argument
15:29:22 <Jafet> Jellybean will be not use furry'? What has mzero been telling lukish about monads?
15:29:24 <donri> __funky_dynamic_oop__
15:29:51 <donri> chrisdone: anyway the proper ghci prompt is ">>> " because it works with haddock and doctest
15:30:04 <mzero> Jafet: we're talking about Misty --- (and not the My Little Pony variety)
15:30:13 <hpc> donri: but it looks so much like python!
15:30:13 <lukish> Jafet: I hope there is no place to monads at all conversation.
15:30:29 <donri> hpc: ohnoes i bet they patented it and everything
15:31:09 <hpaste> fsgxdroid pasted “diagonalize” at http://hpaste.org/55097
15:31:18 <chrisdone> λ> is sexy
15:31:49 <donri> I used to have → as my bash prompt
15:31:58 <donri> with ← for exit status
15:32:15 <chrisdone> and ☞ for pipe?
15:32:26 <donri> li'a
15:32:45 * geheimdienst 's ghci prompt is ☢
15:32:56 <donri> because it runs in the IO monad amarite
15:33:01 <chrisdone> unsafePerformRadioactiveSubstanceAbuse
15:33:15 <mzero> fsgxdroid: so - before you write some code - what is your plan? what is the recursion? how would you do it manually
15:33:16 <geheimdienst> *shrug* to remind everyone it's the atomic age
15:33:33 <donri> geheimdienst: did you get my message on the wiki? *spammin'*
15:33:51 <geheimdienst> donri, huh? checking
15:33:55 <fsgxdroid> mzero, use some sort of counter
15:33:58 <mzero> and, well, yes, I did manage to solve it without a helper function, and without calling length --- but it probably isn't the most obvious thing -- so you shouldn't strive for that solution at front
15:34:05 <chrisdone> geheimdienst: http://www.youtube.com/watch?v=5SYIZK2yAEU
15:34:26 <geheimdienst> donri: oh right, not bad :)
15:34:38 <donri> pandoc :)
15:34:48 <chrisdone> pandoc ♥
15:34:49 <mzero> fsgxdroid: I suggest you write down on paper the diagonalization of [3, 7, 9, 10] and see how you'd manually transform that into the diagonalization of [99, 3, 7, 9, 10]
15:34:57 <shachaf> mzero: To solve what?
15:35:04 <fsgxdroid> mzero, ok i'll try it
15:35:08 <geheimdienst> donri, so you have pandoc witchcraft set up which outputs into the wiki? cool
15:35:13 <donri> chrisdone: wanna help? https://github.com/dag/all-about-monads
15:35:14 <mzero> shachaf: fsgxdroid's diagonalization function
15:35:23 * shachaf is trying to find initial question.
15:35:23 <mzero> (don't solve it here - he's working' on it!)
15:35:29 <ddarius> geheimdienst: The atomic age has long since ended.
15:35:50 <gwern> yeah, it's all continuous Fire and Aether now
15:35:50 <shachaf> Ah, I see.
15:35:54 <mzero> shachaf: http://pastebin.com/YVXHBuww
15:35:54 <mauke> The paste YVXHBuww has been copied to http://hpaste.org/55096
15:36:17 <mzero> why does mauke do that?
15:36:25 <shachaf> mzero: Because pastebin.com is annoying.
15:36:27 <donri> because pastebin.com sucks and hpaste.org owns
15:36:38 <mzero> ah, of course, silly me
15:37:09 <ddarius> Of all the paste sites that are available, pastebin does seem like one of the absolute worse.
15:37:16 <chrisdone> donri: so the current wiki page generated from your repo, or is your repo a generated version that's not generating anything correct yet?
15:37:29 <donri> chrisdone: wiki is from repo
15:37:38 <donri> "make" produces a .mediawiki
15:37:53 <lukish> mzero: so, furry' :: (m a -> a) -> (m (m a)) -> (m a)
15:38:05 <lukish> 2nd and 3rd like 2nd ant 3rd of banana
15:38:32 <chrisdone> let's try this mother
15:39:01 <mzero> right - so, to recap, lukish, if you are trying to make the 2'nd arg, and result of either furry' or banana match your desired function, jellybean, where jellybean :: m (m a) -> m a
15:39:02 <chrisdone> okay, my first partch is adding a cabal file
15:39:06 * chrisdone forks
15:39:16 <donri> :)
15:39:39 <mzero> then you end up with       furry' :: (m a -> a) -> m (m a) -> m a       or      banana :: (m a -> m a) -> m (m a) -> m a
15:40:27 <shachaf> mzero: Did your solution involve zipWith-const-style tricks?
15:40:39 <mzero> and to recap further ----    if you have some function     f :: q -> r -> s    and apply it to some value v :: q     then you end up with something of type    r -> s     right?   that is     f v has the type  r -> s
15:40:47 <mzero> shachaf:  no
15:41:26 <shachaf> mzero: Oh, I was just being silly.
15:41:40 <ddarius> What's wrong with zipWith const?\
15:41:44 <mzero> lukish: are those statements clear to you? if not, then just ask, 'cause understanding those are key to solving this problem
15:42:07 <lukish> mzero: recap further?
15:42:10 <shachaf> ddarius: Is anything wrong with it?
15:42:31 <mzero> let's start with the last --- do you understand the point of  the type of partially applying   f to v?
15:42:34 <lukish> f q :: r -> s . That's clear.
15:42:38 <mzero> good
15:43:59 <shachaf> mzero: What about map (const 0)? :-)
15:44:03 <mzero> then do you see that all our type variable substitution work has been to show that IF the last two types in furry' and banana 's signatures are going to match    m (m a) -> m a    then we have type signatures for their first argument    notably (m a -> a) for furry' and (m a -> m a) for banana
15:44:34 <mzero> shachaf: I think fsgxdroid is trying to solve this one for a problem set... so I'm not givin' away any answers just yet!  :-)
15:45:25 <DanBurton> furry bananas? is this the 20 intermediate haskell exercises?
15:45:35 <lukish> DanBurton: yep
15:45:36 <shachaf> I think what I'm saying isn't very giving-away-answers.
15:45:51 <mzero> no, but it might if keep responding!  :-)
15:45:54 <DanBurton> @google haskell 20 intermediate exercises
15:45:56 <lambdabot> http://blog.tmorris.net/20-intermediate-haskell-exercises/
15:45:57 <lambdabot> Title: λ Tony’s blog λ » Blog Archive » 20 Intermediate Haskell Exercises
15:46:09 <DanBurton> those were fun :)
15:46:36 <mzero> yeah - i did them the other night will sitting in the room as my son fell asleep -- it was kind of like a bed-time story for me!
15:46:37 <donri> I got 1 and 2 then I gave up *attention span*
15:47:18 <mzero> "and they all lived Misty furry banana unicorn in the end!"
15:47:25 <fsgxdroid> mzero, question about diagonalize' :: [Int] -> Int -> [Int] ... is "[Int] -> Int" are arguments and last part is return?
15:47:37 <lukish> mzero: well. We've found such x and y substitution, that when we apply them to banana and furry' we have them signatures some -> m (m a) -> m a.
15:47:37 <mzero> yes,
15:47:38 <DanBurton> don't be afraid to skip some lol
15:47:49 <lukish> But how can it be usable?
15:47:50 <hpaste> fsgxdroid annotated “diagonalize” with “diagonalize (annotation)” at http://hpaste.org/55097#a55098
15:48:05 <chrisdone> ah, i think i've seen that exercise set before. i like those kind of questions. i gave similar q's to a haskell guy interviewing for us
15:48:06 <DanBurton> it's hard at first to wrap your brain around (a ->) instances
15:49:05 <DanBurton> funny that he uses "unicorn" instead of something that starts with "r"
15:49:16 <ddarius> DanBurton: unit
15:49:20 <mzero> okay ---    so, lukish   do this:   I need a function that adds 3 to an Int, that is      add3 :: Int -> Int       now, write this using only the function    add :: Int -> Int -> Int
15:49:21 <DanBurton> ddarius: shhhh
15:49:58 <mzero> let   add x y = x + y;  add3 = ????  in add3 10
15:50:15 <mzero> in the ??? only use add
15:50:40 <lukish> add3 = add 3?
15:50:45 <mzero> yessssh!
15:51:09 <ddarius> In which we discover mzero is a lush.
15:51:18 * DanBurton wonders where mzero is going with this
15:51:50 <mzero> so, I need  jellybean :: m (m a) -> m a      write this using only either furry' :: (m a -> a) -> m (m a) -> m a     or    banana :: (m a -> m a) -> m (m a) -> m a
15:52:01 <mzero> for one of those, you're going to not have to hunt very far
15:52:09 <lukish> banana id
15:52:15 * hackagebot elerea 2.6.0 - A minimalistic FRP library  http://hackage.haskell.org/package/elerea-2.6.0 (GergelyPatai)
15:52:16 <mzero> what is the type of that?
15:52:25 <lukish> m (m  a) -> m a
15:52:26 <mzero> what is the type of jellybean
15:52:39 <mzero> what is a suitable definition of jellybean?
15:52:44 <mzero> does it do what you expect?
15:52:52 <lukish> Well, yes.
15:53:16 <lukish> And we are spending third our only to write banana id?
15:53:22 <lukish> Oh lord
15:53:30 <lukish> hour*
15:54:11 <mzero> well --- is it a solution to number 12?
15:54:30 <lukish> Well, I'm feeling like retard with all those questions
15:54:36 <lukish> mzero: jellybean = banana id
15:54:38 <mzero> nah - you shouldn't at all
15:54:42 <mzero> ta da!!!!
15:54:46 * mzero rings gong
15:54:49 <lukish> But.
15:55:31 <Saizan> banana :: (m a -> m a) -> m (m a) -> m a ? weren't these supposed to match standard combinators?
15:55:35 <mzero> because the point of those 20 exercises is to get you to concentrate on following the types, and manipulating functions by understanding their types, the their mechanics
15:55:58 <lukish> I still have some misunderstanding. Where are those substitutions (x to m a) and (y to a)?
15:56:07 <DanBurton> the 20 exercises are great for training your brain to think in Haskell
15:56:08 <mzero> Saizan: eh? banana :: (a -> m b) -> m a -> m b
15:56:41 <DanBurton> once you can play with types as if they were legos, Haskell makes tons of sense
15:56:42 <Saizan> mzero: i guess you meant it specialized above
15:58:58 <mzero> lukish
15:59:11 <lukish> DanBurton: well, I have 3 paper lists scribbled with a -> b and all that BANANA-stuff, and I've done is explore id.
15:59:16 <lukish> What a day!
15:59:34 <mzero> write down on a piece of paper the type declaration of banana     and then, on a line under it, the type declaration of jellybean .... but line up the two type parts of jellybean with the last two of banana
15:59:44 <DanBurton> lukish: have you figured out what Fluffy and Misty are yet?
15:59:58 <mzero> no - don't! they are abbbbbstract!
16:00:04 <mzero> don't break the spell!  :-)
16:00:11 <DanBurton> :)
16:00:18 <Axman6> they mean NOTHING!
16:00:22 <lukish> I don't care yet.
16:00:39 <mzero> what you're doing is learning to manipulate types and choose functions to implement things soley based on the types?
16:00:40 <lukish> maybe is something like that functors monadic things.
16:00:47 <mzero> er s/?/!/
16:00:57 <lukish> Fluffy is seems like that actually
16:01:03 <lukish> Liek functor.
16:01:18 <dgpratt> gig's up, guys
16:02:41 <lukish> mzero: so, ok. If we said, that we use (x -> m y) as id, that why x is m a and y is a
16:02:44 <lukish> Right?
16:03:12 <mzero> yes
16:03:24 <lukish> Great.
16:04:02 <hpaste> fsgxdroid annotated “diagonalize” with “diagonalize (annotation)” at http://hpaste.org/55097#a55100
16:04:21 <lukish> mzero: thanks for all that tips and hints.
16:04:28 <mzero> the point of the exercises is to focus solely on the types - and see that the type of a function says way more about it than you might have imagined
16:04:38 <mzero> welcome, lukish
16:09:46 <hpaste> fsgxdroid annotated “diagonalize” with “diagonalize (annotation, almost there)” at http://hpaste.org/55097#a55102
16:11:52 <dgpratt> I'm embarrassed to say this, but...I didn't really realize what banana was at first; the parameter order was enough to throw me off the trail...
16:12:31 <shachaf> You *should* be embarrassed.
16:12:36 <shachaf> Look at dgpratt, everybody!
16:12:41 * chrisdone is actually eating a banana presently, and looks at it wondorously
16:12:42 <monochrom> the rise of the planet of the bananas
16:12:46 <dgpratt> the good thing was that it tricked me into solving things in a way that I would not have, and that way turned out to be better
16:13:03 <dgpratt> shachaf: :-P
16:13:30 * mzero thinks the author of that diagonalization problem was being cruel to include the python solution
16:13:59 <shachaf> mzero: Python solution?
16:14:20 <mzero> yeah- in the original statement of the problem, the instructor included a python solution!
16:14:24 <shachaf> Do you mean the Perl code?
16:14:32 <mzero> d'oh - perl
16:14:32 <mzero> yes
16:14:37 <mzero> never mind (in a tiny voice)
16:14:38 <shachaf> I thought that was fsgxdroid's solution in Perl, not part of the problem statement.
16:14:48 <monochrom> perl is even more cruel :)
16:14:58 <mateu> perl++
16:15:08 <mzero> hmmm... not sure
16:15:35 <shachaf> Anyway, the problem can be solved in at most 31 characters in lambdabotskell.
16:16:14 <shachaf> 29, in fact.
16:16:17 <dgpratt> shachaf: anything longer is not a valid solution?
16:16:32 <shachaf> dgpratt: I was giving an upper bound on the shortest solution.
16:16:48 <fsgxdroid> shachaf, first i wrote solutin in perl and now tring to translate to haskell :)
16:16:49 <mzero> anything longer is not a #haskell-wizard solution
16:17:13 <shachaf> Exactly.
16:17:17 <monochrom> self-inflicted cruelty
16:17:31 <mzero> fsgxdroid: so, probably translating that solution isn't going to be pleasant
16:17:58 <shachaf> mzero: fsgxdroid's recent attempts seem to be along the right tracks.
16:18:11 <monochrom> you don't even try to translate C to Perl.
16:18:23 <hpaste> fsgxdroid annotated “diagonalize” with “update” at http://hpaste.org/55097#a55103
16:18:37 <mzero> ah yes, that later one is getting on track!
16:21:01 <fsgxdroid> how can i do following [0] x 3 = [0,0,0]?
16:21:23 <shachaf> fsgxdroid: If you figure out the type of the function you want, you can look for it on Hoogle.
16:21:32 <shachaf> fsgxdroid: However, "length" is probably not what you want to use.
16:22:03 <shachaf> fsgxdroid: Your solution ought to be able to diagonalize infinite lists.
16:24:19 <mzero> fsgxdroid: I'd say solve it with length first - and we'll talk about how to get rid of that later --- assuming length seems natural to you
16:24:49 <fsgxdroid> mzero, alright
16:24:51 <mzero> as for [0] x 3 yielding [0,0,0]   --- you can write it yourself, or use Hoogle to find the standard function that does it
16:25:18 <ben> it'll have to be `x` though, no?
16:25:34 <fsgxdroid> mzero, how can i use hoogle for that particular search?
16:25:38 <mzero> yes, he was just perl'izing
16:25:46 <mzero> what are the types, fsgxdroid ?
16:25:57 <mzero> (it's the basic question to any Haskell problem!  :-) )
16:26:07 <fsgxdroid> [Int] -> Int -> [Int]
16:26:23 <fsgxdroid> [0] x 3 = [0,0,0]
16:26:27 <fsgxdroid> right?
16:26:31 <mzero> put that into hoogle!
16:26:42 <donri> @hoogle [Int] -> Int -> [Int]
16:26:43 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
16:26:43 <lambdabot> Prelude drop :: Int -> [a] -> [a]
16:26:43 <lambdabot> Data.List drop :: Int -> [a] -> [a]
16:26:47 <mzero> but let me ask you this?    what would    [0, 1] x 3 yield?
16:27:18 * hackagebot hfusion 0.0.6 - A library for fusing a subset of Haskell programs.  http://hackage.haskell.org/package/hfusion-0.0.6 (FacundoDominguez)
16:27:29 <chrisdone> don't copy that floppy! run it through in hoogle
16:27:31 <monochrom> > ord 'x'
16:27:32 <lambdabot>   120
16:27:34 <chrisdone> donri: pull!
16:27:41 <fsgxdroid> hm, [ [0,1], [0,1], [0,1] ]
16:27:56 <fryguybob> @type [ [0,1], [0,1], [0,1] ]
16:27:57 <lambdabot> forall t. (Num t) => [[t]]
16:28:06 <monochrom> [0] x 3 is not even valid syntax
16:28:10 <donri> chrisdone: y u no send pull request
16:28:57 <mzero> monochrom: they were asking how to do something they knew how to do in Perl
16:29:08 <chrisdone> donri: where are the example .hs files?
16:29:19 <chrisdone> donri: referenced in the pdf
16:29:54 <ion> > (replicate 3 [0,1], concat . replicate 3 $ [0,1])
16:29:56 <lambdabot>   ([[0,1],[0,1],[0,1]],[0,1,0,1,0,1])
16:30:54 <donri> chrisdone: the examples directory, perchance?
16:31:42 <mzero> fsgxdroid: if  [0, 1] `x` 3 is  [ [0,1], [0,1], [0, 1] ]
16:31:59 <mzero> then why isn't     [0] `x` 3   then   [ [0],  [0], [0] ]  ???
16:32:24 <fsgxdroid> mzero, sry, my bad, i understand the problem
16:32:27 <hpaste> fsgxdroid annotated “diagonalize” with “diagonalize (update)” at http://hpaste.org/55097#a55104
16:32:34 <mzero> excellent
16:32:59 <fsgxdroid> so this is little update now, but the problem is, that i need to have zeros in left
16:33:12 <chrisdone> donri: i don't mean in the repo, i presumed that was garnered from elsewhere
16:33:18 <mzero> fsgxdroid: so far so good
16:33:49 <mzero> now - explain carefully what you want to do with the  result of the recursive call   diagonalize xs
16:34:02 <mzero> (at least to yourself... or to all of us!)
16:34:26 <monochrom> explain to Santa
16:35:16 <donri> chrisdone: the tutorial got kinda lost in a server move of haskell.org, only lone PDFs have been available from arbitrary sources. I got the html from the author, including the examples etc.
16:35:33 <donri> chrisdone: (thus the need for this port)
16:35:33 <chrisdone> donri: oh okies
16:35:56 <hpaste> fsgxdroid annotated “diagonalize” with “diagonalize (hardcoded constant)” at http://hpaste.org/55097#a55105
16:36:05 <fsgxdroid> it works now
16:36:10 <fsgxdroid> but with only 3 element list
16:36:44 <fsgxdroid> probably i need to get initial list length to the function
16:38:40 <chrisdone> donri: are you working on fixing the internal links?
16:38:47 <chrisdone> donri: or what part are you doing?
16:39:07 <donri> chrisdone: not anything atm; i listed issues i could find in the github issues
16:42:27 <chrisdone> donri: so the example urls should be All_About_Monads/Example1, no?
16:42:51 <chrisdone> or Example_1
16:44:03 <donri> chrisdone: something like that yea. I wanted to automate adding all those but the haskellwiki mediawiki api is hidden by an apache rewrite rule :/
16:46:01 <chrisdone> no one written some haskell to edit the haskell wiki yet?
16:46:44 <donri> there's a mediawiki package that doesn't build on ghc7 :)
16:47:09 <donri> or with base4 really
16:47:26 <chrisdone> but you said the api is blocked anyway
16:47:42 <donri> yea, at least that's my guess
16:47:55 <donri> it should normally be under api.php, which redirects to the non-existing page Api.php
16:49:10 <chrisdone> maybe it's an old version and it's something else
16:49:49 <donri> maybe, but it seems likely that there is a rewrite rule in place since /Bla works in place of index.php?page=Bla or whatever
16:50:07 <donri> and likely that it neglects to check for existing files
16:50:18 <donri> anyone know who operates the wiki?
16:54:18 <dropdrive> How do I write a function that works with all the different ByteString's?  Or is it fundamentally not the point of the different ByteString's?
16:55:00 <chrisdone> make a small class
16:57:19 <aristid> dropdrive: well depending on what you do, if you always read lazy bytestrings and write strict bytestrings, you should be fine
17:00:33 <dropdrive> aristid: Fine in what sense -- that a function written to take a lazy BS will work when passed a non-lazy BS?
17:01:02 <aristid> dropdrive: it is always cheap to convert a strict to a lazy bytestring.
17:01:09 <aristid> dropdrive: but not in the other direction.
17:01:24 <dropdrive> aristid: I see, thanks.
17:01:36 <ddarius> dropdrive: There probably should be (and I'm pretty sure there is somewhere) a class that unifies various IO operations for various "string" types, but it doesn't make as much sense to have a class just "unify" lazy and strict bytestrings in the same way that it doesn't make much sense to "unify" lists and arrays.
17:02:39 <dropdrive> ddarius: I see.
17:03:03 <ddarius> In fact, "unifying" lazy and strict bytestrings -would- be unifying lists and arrays.
17:04:36 <Solver> quicj question - what license is The Haskell Platform distributed under?  I looked at the web site but didn't see it
17:04:46 <Solver> I know GHC is distributed under a BSD 3-clause
17:04:54 <dropdrive> Another question ... I've written a function f :: FilePath -> FilePath -> IO a.  This function is very slow.  Is there a way to "save" the results to disk so that if (1) the mtimes of the FilePaths haven't changed, and (2) the implementation of "f" hasn't changed, then the result is read from disk if available?
17:05:29 <ddarius> Solver: The Haskell Platform is just a list of libraries and tools.
17:05:32 <dropdrive> I suppose I can do (1), but how to do (2)?
17:05:54 <Solver> ddarius: so they could have different licenses?  everything is under FOSS licenses right?
17:06:22 <ddarius> Solver: Yes, I'm quite certain everything in the Haskell Platform (currently) is under one free license or another.
17:06:46 <ddarius> Most Haskell libraries are BSD but there are some exceptions.  I think essentially everything on Hackage is under a free license.
17:07:16 <aavogt> dropdrive: you could keep track of a version of 'f' that wrote some output (say put that in the first line of the file) but I don't know of a way for that to happen without manually bumping a version number for f somewhere
17:07:18 <Solver> ok thanks
17:07:27 <gwern> free under some definition or other
17:07:38 <gwern> we settled that years ago, not that it was really an issue
17:07:47 <Solver> gwern: ah cool
17:08:07 <chrisdone> pandoc notably isn't bsd
17:08:33 <Solver> I use the normal FOSS community definition of a license being endorsed by the OSI and/or the FSF
17:09:24 <roconnor> hi gwern
17:11:40 <Solver> chrisdone: I found a thread in haskell-cafe that pointed me to this:
17:11:43 <Solver> http://trac.haskell.org/haskell-platform/wiki/AddingPackages#Interimlicensepolicy
17:14:29 <edwardk> preflex: xseen gwern
17:14:30 <preflex>  gwern was last seen on freenode/#haskell 6 minutes and 51 seconds ago, saying: we settled that years ago, not that it was really an issue
17:14:33 <edwardk> oh hai
17:15:14 <edwardk> gwern: lispy's gsoc student dropped out before the half-way point
17:15:18 <edwardk> gwern: though lispy himself has been doing some stuff to the opengl bindings
17:15:24 <gwern> edwardk: I figured as much
17:15:36 <gwern> edwardk: any thoughts on the others?
17:15:43 <edwardk> other projects?
17:16:05 <gwern> 1yes
17:16:37 <edwardk> well, the data.text project produced some general purpose performance improvements in data.text but the main utf-8 switch wasn't done.
17:17:14 <gwern> edwardk: I know, I meant comments on http://www.gwern.net/Haskell%20Summer%20of%20Code#results-1
17:17:22 <edwardk> turned out surprisingly to be a bit slower for most operations and harder to interoperate with libraries, and only really faster when streaming, etc.
17:17:24 <edwardk> oh
17:17:26 <edwardk> haven't looked
17:19:07 <edwardk> well, i don't necessarily agree on your assment of petr rockai's work
17:19:23 * gwern is not surprised
17:19:41 <edwardk> and i don't know enough about the status of the two cabal projects to really offer an opinion one way or the other
17:20:28 <gwern> (but I stand by it. it's multiple SoCs away from any kind of completion, petr says, and nothing has been contributed back to darcs. any payoff from this SoC is years away, speculative, and would only benefit darcs' developers and the actual users only indirectly)
17:20:39 <edwardk> well, it was deliberately long term work
17:20:44 <gwern> SoCs aren't research projects, basically
17:21:12 <edwardk> and petr has demonstrated a long term commitment to improving darcs, so funding some research isn't something i can really say was a bad idea
17:21:19 <edwardk> i can understand that point of view
17:23:18 <edwardk> in the end though, we can only work with the proposals we actually get and i still think we took chances on the best project proposals we received.
17:23:55 <edwardk> that petr's work had a longer time horizon than a typical gsoc project was one of the factors weighed when it was proposed
17:25:01 <edwardk> i think i asked last year, but i will again this year, please get involved in the selection process, we can add you to the mentor list and you can comment on these things as they are being proposed rather than after they've succeeeded or failed ;)
17:26:16 <gwern> but then I'd be all conflicted-of-interestedness
17:26:30 <edwardk> you don't have to actually choose to mentor in the end
17:26:33 <edwardk> just vote
17:27:02 <edwardk> i care more about the end result than the scientific method in this case ;)
17:27:04 <gwern> mm. as I said last time, I can't sign up right now which means I will forget to sign up when gsoc finally does let us sign up
17:27:18 <gwern> I have to say, I hope google handles payments better than all the other aspects...
17:27:22 <edwardk> i'll harass you for a few weeks when registration opens
17:28:17 <edwardk> we haven't really had any issues with the payments, and even in the few cases where a mentor or a student has screwed up on submitting things on time, the organizer on google's side has been able to work with me to get it resolved really quickly
17:33:09 <hpaste> fsgxdroid annotated “diagonalize” with “diagonalize (help plz - error)” at http://hpaste.org/55097#a55106
17:47:20 * hackagebot anansi 0.4.2 - Simple literate programming preprocessor  http://hackage.haskell.org/package/anansi-0.4.2 (JohnMillikin)
17:48:51 <fsgxdroid> i'm getting errors but i don't know how to fix it
17:48:53 <hpaste> fsgxdroid annotated “diagonalize” with “diagonalize (help plz - error) (annotation)” at http://hpaste.org/55097#a55107
17:49:56 <azaq23> and the error is?
17:50:53 <fsgxdroid> Couldn't match expected type `Int' with actual type `[t0]'
17:51:24 <byorgey> fsgxdroid: in the first line of diagonalize' you have [blah] : foo
17:51:42 <byorgey> fsgxdroid: (:) has type  a -> [a] -> [a]
17:51:57 <byorgey> that is, it takes an element and a list, and puts the element at the beginning of the list
17:52:08 <byorgey> so [foo] : blah  only makes sense if you are trying to construct a list of lists
17:52:21 <byorgey> because [foo] is a singleton list containing the element foo
17:52:32 <fsgxdroid> alright, so i should use ++  operator?
17:53:01 <byorgey> fsgxdroid: if you are trying to put two lists together to make one list, yes
17:53:31 <fsgxdroid> but still, it won't compile
17:53:33 <fsgxdroid> Couldn't match expected type `Int' with actual type `[Int]'
17:53:45 <azaq23> also, you're doing replicate i ++ ...
17:53:52 <azaq23> :t replicate
17:53:53 <lambdabot> forall a. Int -> a -> [a]
17:54:14 <byorgey> azaq23: that part looks OK to me
17:54:16 <azaq23> misread ignore me
17:54:17 <byorgey> it's replicate' not replicate
17:54:29 <fsgxdroid> azaq23: actually yes
17:54:29 <byorgey> although that does point out the fact that replicate' is probably not the best name =)
17:54:36 <fsgxdroid> :)
17:55:02 <byorgey> I might call it "zeros"
17:55:21 <gwern> preflex: seen sclv
17:55:22 <preflex>  sclv was last seen on #haskell 181 days, 4 hours, 51 minutes and 38 seconds ago, saying: that goes for any type, not just function types
17:55:40 <hpaste> fsgxdroid annotated “diagonalize” with “diagonalize (zeros update)” at http://hpaste.org/55097#a55108
17:55:56 <shachaf> fsgxdroid: You should figure out the difference between (:) and (++). It's pretty important. (:) is a constructor, which is much more fundamental than (++).
17:58:07 <fsgxdroid> shachaf, i thought ":" takes head of the list
17:59:47 <fsgxdroid> ok, gonna take a sleep, will continue tomorrow, bye
18:01:01 <Axman6> fsgxdroid: (:) constructs a list from an element and another list
18:01:19 * BMeph weeps for the compilers of the programs of the youth of today...or something like that.
18:02:08 <ddarius> "Won't somebody PLEASE think of the compilers?"
18:02:20 * hackagebot couch-hs 0.1.5 - A CouchDB view server for Haskell.  http://hackage.haskell.org/package/couch-hs-0.1.5 (PeterSagerson)
18:02:54 <BMeph> "Think of the starving compilers in Java-land..." :D
18:03:39 <BMeph> Okay, off-topic, but I "couldn't" resist the dig. :)
18:05:01 * BMeph is just glad there was no "zeros x = replicate x y where y = 0" there... :\
18:08:01 <gwern> Liam O'Connor  = kamatsu?
18:08:06 <djahandarie> Yes
18:08:57 <ddarius> zeros x = f y where f = replicate x; y = 0
18:09:19 <shachaf> Djaharius Andarie = djahandarie?
18:09:38 <djahandarie> No, that's geheimdienst.
18:09:44 <djahandarie> Common mistake.
18:10:04 <shachaf> djahandarie: Which side of the = was wrong?
18:10:10 <shachaf> Which one are you replacing, I mean.
18:10:20 <roconnor> > replicate 0 7
18:10:22 <lambdabot>   []
18:11:01 <BMeph> zeros x = f w where w = 0; f = g x; g = replicate
18:11:16 * gwern finishes quoting criticisms of his SoC review in the review
18:11:20 <djahandarie> Are we doing reverse-golfing here or?
18:11:32 <shachaf> @ty flip flip flip flip
18:11:33 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) b1. (Functor f, Functor f1) => f1 ((f (a -> b) -> a -> f b) -> b1) -> f1 b1
18:11:34 <shachaf> @ty flip flip flip flip flip
18:11:35 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) b1. (Functor f, Functor f1) => f1 ((f (a -> b) -> a -> f b) -> b1) -> f1 b1
18:11:37 <shachaf> @ty flip flip flip flip flip flip flip flip flip
18:11:38 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) b1. (Functor f, Functor f1) => f1 ((f (a -> b) -> a -> f b) -> b1) -> f1 b1
18:11:39 <edwardk> gwern: delightfully meta ;)
18:11:44 <shachaf> @let buffalo = flip
18:11:45 <lambdabot>  Defined.
18:11:49 <gwern> edwardk: I think of it as the lazy way to be honest
18:11:53 <edwardk> now i'll need to criticise the way you quote me =)
18:12:24 <djahandarie> "That blockquote clearly needs to be indented by 0.5 em!"
18:12:35 <BMeph> djahandarie: Snarky commentary on a new-to-Haskell programmer's style. :)
18:12:48 <gwern> edwardk: I didn't quote you, IIRC. I know there was, shall we say, discussion here, but I apparently lost my copied quotes
18:12:56 <shachaf> English needs different punctuation for quoting meaning and for quoting text.
18:28:02 <gwern> http://www.reddit.com/r/haskell/comments/n82ln/summer_of_code_2011_retrospective/ <-- go my pretty upvoting minions
18:30:03 * DanBurton flies off to reddit to perform upvoting magic
18:30:38 <gwern> well done thou faithful and loyal Burtoneque monkey
18:37:38 <dropdrive> Int has range equivalent to at least 29-bit signed binary -- this is more general with GHC 64-bit?
18:38:01 <gwern> dropdrive: sure. compare maxBound :: Int on a 32bit or 64bit system
18:38:13 <gwern> > maxBound :: Int -- IIRC, lambdabot is 64-bit
18:38:15 <lambdabot>   9223372036854775807
18:38:35 <dropdrive> gwern: Thanks :)
18:39:14 <ddarius> Use Int64/32 (or Word64/32) if you need a specific bitwidth.
18:39:43 <dropdrive> ddarius: I did not know those existed.  Thanks.
18:41:38 <xil> hi. Does O(a:ls) == O(ls ++ a)?
18:42:08 <roconnor> no
18:42:14 <shachaf> xil: That would depend on what O is.
18:42:33 <Scriptor> xil: ++ takes two lists of some type, : takes a list and an element of the same type as elements of that list
18:43:58 <xil> well assuming that 'a' is just a singlet, or obviously one element in the left half. O() is Big-O
18:43:58 <Axman6> xil: look at the source for (++) to see why ls ++ a = O(length ls) and a : ls = O(1)
18:44:16 <ddarius> I think what he try to ask is is the asymptotic running time of (a:) the same as (++[a]).
18:44:24 <xil> Axman6: I've seen it but wasn't sure how Haskell optimizes
18:44:38 <xil> ddarius: yes, that is a much better way of putting it
18:45:09 <Axman6> xil: can you possibly append onto a singly linked list in anything other than O(n) time?
18:45:11 <Scriptor> xil: in short, since lists are basically linked lists, ++ has to traverse through to the end of the list
18:45:28 <Axman6> (if you have no reference to the end of the list, but even having that implies you have mutable lists i guess)
18:45:58 <xil> Axman6: I didn't really know that lists were singly linked internally. Ignorance =]
18:46:08 <ddarius> xil: There is no "internally."
18:46:10 <ddarius> @src []
18:46:11 <lambdabot> data [] a = [] | a : [a]
18:46:25 <xil> what about tuples?
18:46:27 <ddarius> Other than special names, [] is exactly like a normal data type.
18:46:36 <Axman6> xil: there's no "internally" about it. lists aren't special. they're the same as if you'd written data List a = Nil | Cons a (List a)
18:46:40 <ddarius> Admittedly, the Report says nothing about how these are represented.
18:46:51 <parcs> @src (,)
18:46:52 <lambdabot> Source not found. It can only be attributed to human error.
18:46:57 <parcs> @src ,
18:46:57 <lambdabot> Source not found. Sorry.
18:47:07 <ddarius> But there is an "obvious" representation and it is, more or less, what every implementation uses.
18:47:20 <Axman6> tuples are also just normal data types (though they have syntax you can't define; their syntax is part of the language)
18:47:30 <xil> it's nice to know that lists are normal. Very nice, but I thought they might not be because I read something in the docs on data types or something that tuples are not normal
18:47:36 <parcs> data (,) a b .. n = (,) a b .. n
18:47:41 <Axman6> data Tuple a b = T a b ~= (,) a b
18:47:52 <ddarius> @src (,)
18:47:53 <lambdabot> Source not found. You untyped fool!
18:48:24 <parcs> the first few tuple types are pregenerated, the rest are autogenerated as needed/used
18:48:34 <ddarius> Anyway, I think GHC actually has, data (,,) a b c = (,,) a b c or something like that in its internal libraries somewhere.
18:49:17 <xil> okay, well that's what I was looking for. Thanks everyone for all the info. Learning is fun =]
18:49:32 <copumpkin> http://haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.2.0.0/src/GHC-Tuple.html#%28%2C%29
18:49:58 <copumpkin> {- Manuel says: Including one more declaration gives a segmentation fault.
18:50:00 <copumpkin> always encouraging
18:50:56 <monochrom> hehe
18:58:34 <parcs> a segmentation fault in haddock or ghc?
18:58:59 <copumpkin>  who knows
19:00:36 <ddarius> I would think GHC.
19:00:51 <ddarius> Probably when it attempts to compile the declaration.
19:00:55 <parcs> well ghc-prim is a documentation-only module no?
19:01:14 <parcs> or rather a package that only exists to document
19:01:46 <ddarius> You can always add another declaration and run Haddock against it and find out.
19:02:39 <copumpkin> parcs: that's haskell code
19:02:47 <copumpkin> parcs: it's only in the ghc-prim module
19:02:58 <copumpkin> the only module (I think) that doesn't actually have any source code is GHC.Prim
19:06:06 <parcs> hmm, yeah. guess it's ghc then
19:15:37 <mreh> what's the most likely reason i've corrupted my acid-state database?
19:15:51 <mreh> i'm only accessing it with one process
19:16:44 <mreh> oh, i changed a definition
19:16:52 <mreh> silly meeeeee
19:16:52 <mdxbhmt> \punon databases shouldn't trip like that. \punoff
19:17:23 * mreh smiles wryly
19:18:01 <mreh> you might say i'll have to drop acid...
19:18:06 <mreh> GWAFFAW
19:18:23 <mreh> anyone else?
19:21:18 <tgeeky> didn't someone write something like hnotify that worked on Windows?
19:26:34 <thierrygar> florestine#27
20:25:25 <exFalso> evening
20:25:46 <exFalso> can anyone explain why the following stack overflows?: http://pastebin.com/eJPbwcx9
20:25:48 <mauke> The paste eJPbwcx9 has been copied to http://hpaste.org/55110
20:26:12 <exFalso> if one uncomments the second Ord function it works
20:26:35 <mauke> because your Ord instance is broken
20:26:54 <mauke> it says here: "Minimal complete definition: (<=) or compare"
20:27:14 <exFalso> oh i thought it defaults
20:27:21 <exFalso> which is why it requires Eq
20:27:26 <exFalso> my bad, thanks!
20:28:26 <shachaf> Well, that was fast.
20:58:12 <Axman6> hmm, so I'm looking at the IORefCAS package, which implements compare and swap functions. I find it very odd that it implements one for STRefs
20:59:20 <shachaf> Axman6: So do I.
21:00:45 <Axman6> I also wonder whether atomicModiftIORefCAS does anything at all differently to atomicModifyIORef
21:07:37 <ddarius> Axman6: The documentation seems to suggest so.
21:09:04 <ddarius> As for doing it for STRefs, a) it is probably trivial to support, so why not? and b) unsafeSTToIO.
21:09:50 <ddarius> (or just stToIO)
21:16:24 <ddarius> > 110 * 1.08
21:16:26 <lambdabot>   118.80000000000001
21:18:31 <Scriptor> do any systems/languages do decimal multiplication by moving the decimal place over
21:18:38 <Scriptor> multiplying whole numbers, and moving it back again?
21:20:06 <byorgey> Scriptor: well, that is essentially how floating-point multiplication works
21:20:11 <byorgey> except in base 2 instead of base 10
21:20:49 <byorgey> and without actually "moving" the binary point; the exponents (i.e. location of the binary point) are just tracked separately
21:21:06 <Axman6> Scriptor: have a look at fixed point arithmetic as well
21:24:20 <Scriptor> yep, I've only skimmed through explanations of floating and fixed point arithmetic
21:27:06 <Axman6> Scriptor: IEEE-754 is pretty cool, but has some (somewhat necessary) oddities. fixed point is extremely useful when you know what precision you need and the range of numbers you'll have to cover. it's also really fasy, because basically all operations are integer operations, with possible shifts if you're multiplying/dividing
21:28:15 <Scriptor> huh, that sounds kinda like what I described, worry about placing the decimal point at the end only
21:30:02 <byorgey> preflex: xseen edwardk
21:30:02 <preflex>  edwardk was last seen on freenode/#haskell 3 hours, 18 minutes and 13 seconds ago, saying: now i'll need to criticise the way you quote me =)
21:30:09 <edwardk> yo
21:30:16 <byorgey> hi edwardk
21:30:22 <mzero> Note that IEEE-854 describes arbitrary radix floating point, analogous to 754, and you can implement a base-10 floating point system from there
21:30:32 * mzero has done so, thrice
21:30:59 <byorgey> edwardk: I seem to recall you explaining to me how Applicative+recursion can be used to parse a somewhat larger class of languages than just context-free
21:31:02 <byorgey> but I forget the details
21:31:14 <byorgey> I wanted to mention something about it in the Typeclassopedia
21:31:15 <edwardk> oh, its fairly easy
21:31:20 <mauke> infinite grammarz
21:31:23 <edwardk> yeah
21:31:33 <byorgey> ah. right.
21:31:45 <edwardk> the context-freeness comes from the finite size of the grammar
21:31:50 <edwardk> make an infinite tree
21:31:53 <shachaf> Mmm, grammarz.
21:31:58 <byorgey> makes sense.
21:32:07 <byorgey> so what class of languages is that?  does it have a name?
21:32:16 <Draconx|Laptop> mzero, despite the title, IEEE 854 describes only base-2 and base-10 floating point.
21:32:18 <edwardk> then you can use this to parse context-sensitively anything with a finite alphabet
21:32:34 <byorgey> ah, makes sense
21:32:45 <mzero> hmmm... don't have my copy at hand (it's at work, and I'm not)
21:32:48 <edwardk> its a context-sensitive language, just with the niggling caveat that the alphabet must be finite
21:33:07 <mauke> oh noes, a finite alphabet
21:33:25 <byorgey> ok, thanks
21:38:30 <byorgey> edwardk: hmm, wait, I don't see it. Doesn't this argument only work for Alternative (and not for just plain Applicative)? or am I missing something?
21:38:42 <edwardk> yes alternative
21:38:46 <byorgey> ok.
21:39:45 <edwardk> but you need a monadplus for parsing in the other style anyways ;)
21:43:30 <byorgey> true
22:27:21 * hackagebot oi 0.0.1 - Purely Functional Lazy Interaction with the outer world  http://hackage.haskell.org/package/oi-0.0.1 (NobuoYamashita)
22:38:02 <Veinor> bleh
22:44:48 <wavewave> hi
23:03:18 <accel> suppose, hypothetically, I was writng a WYSIWYG HTML editor in haskell. Would zippers be the right way to store the DOM tree, or is there a more elegant algorithm?
23:04:00 <wavewave> accel: if you have one cursor, zipper is good.
23:05:48 <accel> wavewave: now i;m curious
23:05:51 <accel> how do you handle multiple cursors?
23:06:18 <wavewave> I am just using map.
23:06:28 <wavewave> multiple cursor is headache.
23:06:42 <edwardk> accel: with multiple cursors you can borrow a trick from oleg (see his zipperfs)
23:07:08 <wavewave> edwardk: for me, it was too complicated.
23:07:12 <edwardk> accel: but its really just single cursored structures plus some transaction plumbing
23:07:13 <edwardk> yeah
23:07:16 <edwardk> it is
23:08:09 <wavewave> Data.Map is quite fast for my purpose, so I am now not worrrying about it much.
23:08:27 <wavewave> If my data type is rather serial... then I use Data.Sequence
23:08:32 <accel> got it
23:08:33 <wavewave> with multiple holes.
23:08:35 <accel> zippers are awesome
23:08:39 <accel> I don't know how else to phrase it
23:08:53 <accel> did I mention taht zippers are awesome?
23:08:58 <accel> going from O(log n) to O(1) is so fucking cool
23:09:12 <accel> someone should write a book of these things
23:09:14 <shachaf> Not as cool as going from O(1) to O(1/log n)
23:09:16 <accel> and call it functional pearls or something
23:09:38 <wavewave> zipper is basically differentiation.
23:09:41 <accel> shachaf: I can't think of anything that runs in O(1 / log n) time
23:09:58 <shachaf> What, you can't think of an algorithm that gets faster as you give it more input?
23:10:01 <shachaf> They're all over the place!
23:10:13 <DanBurton> is that average case or worst case?
23:10:14 <accel> shachaf: you know, there is the smallest unit of operation
23:10:16 <accel> thus, for big enough n
23:10:20 <accel> your algorithm needs to take 0 time
23:10:29 <accel> I was considering worst case
23:10:37 <accel> but perhaps shachaf was talking average case
23:11:04 <johnbender> can anyone tell me what operation the back slash in FV is supposed to represent https://gist.github.com/b35febb0221fbc4891fb I'm working through Pierce's first book on types
23:11:16 <DanBurton> shachaf: "they're all over the place!" name 3
23:11:24 <Saizan> johnbender: set difference
23:11:27 <johnbender> also, not sure where else to ask (everyone here is so helpful :D)
23:11:40 <accel> I think it was a joke :-)
23:11:40 <johnbender> Saizan: ah! thank you, that makes things much clearer
23:12:11 <DanBurton> yeah I just wanted to see what bs he would make up
23:12:24 <Saizan> const 1, const 2, const 3
23:12:45 <Saizan> or not, i guess
23:13:03 <shachaf> It all depends on how you define n.
23:13:06 <johnbender> Saizan: I found a sample proof online for |FV(t)| <= size(t) but I couldn't follow how |FV(t1) \ {x}| <= |FV(t1)|
23:13:15 <johnbender> Saizan: much appreciated
23:13:25 <DanBurton> shachaf: also how you define log
23:13:30 <DanBurton> and how you define /
23:13:40 <Saizan> n is more variable
23:13:49 <Saizan> johnbender: np
23:13:59 <shachaf> DanBurton: I think those have standard meanings.
23:17:24 <wavewave> my hxournal got in quite good shape now ;-)
23:18:45 <Veinor> bleh
23:18:52 <Veinor> cabal needs patching to install on 7.2 :/
23:19:00 <accel> zippers are the fucking coolest things ever
23:19:09 <accel> i thoguht about this prolem for 2 days
23:19:12 <accel> then I reada bout zippers
23:19:37 <wavewave> accel: zipper is profound in fact.
23:20:21 <wavewave> you can derive a zipper from arbitrary algebraic data type.
23:20:58 <ddarius> From an arbitrary regular data type, and likely for many irregular ones as well.  I'm not sure it has been done for arbitrary data types.
23:21:40 <ddarius> Maybe for species.
23:21:47 <shachaf> What are regular/irregular data types?
23:22:51 <ddarius> shachaf: The most restrictive definition of regular might be "sum of product" types.  Strictly positive types would be somewhat less restrictive.
23:23:20 <ddarius> Nested data types are usually considered irregular, though I think those can be handled.
23:23:42 <ddarius> A type like data D = D (D -> D) would usually not be considered regular.
23:26:46 <ddarius> D_x(x^x) = D_x(e^(xln x)) = D(xln x)x^x = (ln x + 1)x^x.  Now all we need to know is what the natural logarithm is as a type constructor.
23:27:29 * shachaf still hasn't figured out what division is.
23:28:25 <ddarius> In this case the only place division came up was in x/x.
23:28:37 <ddarius> So I just silently swept that under the rug.
23:29:19 <shachaf> I wonder whether log or logBase 2 would be "simpler" as a type.
23:29:35 <Saizan> ln(A -> B) = A
23:30:05 <ddarius> e^A is the Set A.
23:30:09 <ddarius> s/the//
23:30:18 <hpaste> cedricshock pasted “Cannot deduce instance” at http://hpaste.org/55114
23:30:30 <dolio> Isn't it bags?
23:30:31 <shachaf> e^A? Not 2^A?
23:30:45 <shachaf> I'd expect (A -> Bool) to be (Set A)
23:30:57 <ddarius> shachaf: This is a different kind of thing.
23:31:14 <shachaf> Oh. It's not the same kind of thing?
23:31:19 <Saizan> mh, i guess it was log_B not ln
23:32:23 <cedricshock> Can anyone see why ghc create a new type "a0" instead of the quite repeatedly specified "a" in my paste "Cannot deduce instance"? I am abusing quite a few compiler extensions.
23:33:41 <Veinor> hmm
23:33:47 <Veinor> i'm running into that libstdc++ bug
23:33:52 <Veinor> http://hackage.haskell.org/trac/ghc/ticket/5289#comment:29
23:35:14 <wavewave> rename your libstdc++.dylib.xx
23:35:21 <Saizan> cedricshock: maybe you need ScopedTypeVariables ?
23:35:28 <ddarius> cedricshock: What's the type of Apply?
23:35:43 <Veinor> wavewave: ?
23:36:29 <wavewave> Veinor: for a temporary fix.. link libstdc++.so.xx to libstdc++.so
23:36:35 <cedricshock> ddarius
23:36:51 <cedricshock> : it's in the data type application one line above the instance declaration
23:36:54 <wavewave> for mac os x, similarly do that for dylib
23:37:16 <ddarius> Oh god, don't use contexts on data declarations.
23:37:20 <Saizan> cedricshock: it simply has no reason to decide that (method d) should be of type 'a'
23:37:27 <Veinor> right, i did that
23:37:56 <wavewave> this happened quite often now with new text package.
23:37:56 <Veinor> and it's still not finding it
23:38:23 <Veinor> i have a /usr/local/lib/libstdc++.so
23:38:54 <wavewave> is your /usr/local/lib in library path? it should be so usually.
23:39:02 <ddarius> Or that method f shoud be of type a -> b.
23:39:25 <Veinor> how do i check that?
23:39:30 <cedricshock> Saizon, excellent. Hit the nail on the head.
23:39:56 <ddarius> cedricshock: Incidentally, this is all going to end in tears.
23:39:57 <shachaf> e^A = 1 + A + A^2/2 + A^3/6 + ...
23:40:10 <wavewave> hmm.. i don't remember how to check it.. but try  LD_LIBRARY_PATH=/usr/local/lib cabal install
23:40:35 <wavewave> just include /usr/local/lib in dynamic lib path.
23:40:37 <Veinor> so i should reinstall double-conversion?
23:40:47 <shachaf> ddarius: Is that that kind of thing or the other kind of thing?
23:41:19 <wavewave> Veinor: I don't think so.. i just assume you encounter the problem when doing cabal install.
23:41:32 <wavewave> export LD_LIBRARY_PATH=/usr/local/lib
23:41:44 <cedricshock> Probably, that's usually what happens with MultiParamTypeClasses.
23:41:50 <wavewave> and try some of your command that caused a problem.
23:42:36 <Veinor> well, i tried just using the library in ghci
23:42:41 <lukish> Could you, guys, vote to reopen that question? http://stackoverflow.com/questions/8455780/
23:42:42 <Veinor> and it caused a floating point exception
23:43:19 <wavewave> hmm.. exception? not the loading problem?
23:43:32 <Veinor> well, it's the same problem, i think
23:44:27 <wavewave> hmm yeah.. i found that the bug report said it now.
23:44:42 <Saizan> lukish: the simplest way is to just unregister all packages that don't have profiling enabled, with ghc-pkg unregister
23:45:22 <ddarius> cedricshock: The issue isn't the MultiParamTypeClasses, it's 1) the extremely generic type method has, and 2) the other extensions you are no doubt using to get GHC to accept this.
23:45:46 <ddarius> shachaf: That is a valid expansion for species.
23:46:10 <shachaf> I should learn about what "species" actually are.
23:46:12 <cedricshock> ddarius: that type is going to get even worse when I throw existential quantification on top of it.
23:46:19 <lukish> Saizan: how can it be useful?
23:47:13 <Saizan> lukish: once they are unregistered cabal will no longer see them installed, so it'll reinstall them automatically
23:47:27 <ddarius> shachaf: Brent has some okay introductory blog posts and an enjoyable talk.
23:48:07 <Veinor> yeah, nothing i've done in that bug report is helping
23:48:09 <Veinor> :/
23:48:10 <ddarius> shachaf: If you can find it in a library, I highly recommend (with Brent) "Combinatorial Species and Tree-like Structures."
23:50:16 <Veinor> meh, i just won't use double-conversions until 7.4 :P
